{
  "module_name": "process_pptables_v1_0.c",
  "hash_id": "8eb1f205a3d1ee3e3ae2f7947d5ced2c2669375493b09db0bd05d431159c29e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/process_pptables_v1_0.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"process_pptables_v1_0.h\"\n#include \"ppatomctrl.h\"\n#include \"atombios.h\"\n#include \"hwmgr.h\"\n#include \"cgs_common.h\"\n#include \"pptable_v1_0.h\"\n\n \nstatic void set_hw_cap(struct pp_hwmgr *hwmgr, bool setIt, enum phm_platform_caps cap)\n{\n\tif (setIt)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\n\telse\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\n}\n\n\n \nstatic int set_platform_caps(struct pp_hwmgr *hwmgr, uint32_t powerplay_caps)\n{\n\tPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE16____),\n\t\t\"ATOM_PP_PLATFORM_CAP_ASPM_L1 is not supported!\", continue);\n\tPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE64____),\n\t\t\"ATOM_PP_PLATFORM_CAP_GEMINIPRIMARY is not supported!\", continue);\n\tPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE512____),\n\t\t\"ATOM_PP_PLATFORM_CAP_SIDEPORTCONTROL is not supported!\", continue);\n\tPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE1024____),\n\t\t\"ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1 is not supported!\", continue);\n\tPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE2048____),\n\t\t\"ATOM_PP_PLATFORM_CAP_HTLINKCONTROL is not supported!\", continue);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_POWERPLAY),\n\t\t\tPHM_PlatformCaps_PowerPlaySupport\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\n\t\t\tPHM_PlatformCaps_BiosPowerSourceControl\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_HARDWAREDC),\n\t\t\tPHM_PlatformCaps_AutomaticDCTransition\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_MVDD_CONTROL),\n\t\t\tPHM_PlatformCaps_EnableMVDDControl\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_VDDCI_CONTROL),\n\t\t\tPHM_PlatformCaps_ControlVDDCI\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_VDDGFX_CONTROL),\n\t\t\tPHM_PlatformCaps_ControlVDDGFX\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_BACO),\n\t\t\tPHM_PlatformCaps_BACO\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_DISABLE_VOLTAGE_ISLAND),\n\t\t\tPHM_PlatformCaps_DisableVoltageIsland\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_COMBINE_PCC_WITH_THERMAL_SIGNAL),\n\t\t\tPHM_PlatformCaps_CombinePCCWithThermalSignal\n\t\t  );\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_TONGA_PLATFORM_LOAD_POST_PRODUCTION_FIRMWARE),\n\t\t\tPHM_PlatformCaps_LoadPostProductionFirmware\n\t\t  );\n\n\treturn 0;\n}\n\n \nstatic const void *get_powerplay_table(struct pp_hwmgr *hwmgr)\n{\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\n\tu16 size;\n\tu8 frev, crev;\n\tvoid *table_address = (void *)hwmgr->soft_pp_table;\n\n\tif (!table_address) {\n\t\ttable_address = (ATOM_Tonga_POWERPLAYTABLE *)\n\t\t\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\t\tindex, &size, &frev, &crev);\n\t\thwmgr->soft_pp_table = table_address;\t \n\t\thwmgr->soft_pp_table_size = size;\n\t}\n\n\treturn table_address;\n}\n\nstatic int get_vddc_lookup_table(\n\t\tstruct pp_hwmgr\t*hwmgr,\n\t\tphm_ppt_v1_voltage_lookup_table\t**lookup_table,\n\t\tconst ATOM_Tonga_Voltage_Lookup_Table *vddc_lookup_pp_tables,\n\t\tuint32_t max_levels\n\t\t)\n{\n\tuint32_t i;\n\tphm_ppt_v1_voltage_lookup_table *table;\n\tphm_ppt_v1_voltage_lookup_record *record;\n\tATOM_Tonga_Voltage_Lookup_Record *atom_record;\n\n\tPP_ASSERT_WITH_CODE((0 != vddc_lookup_pp_tables->ucNumEntries),\n\t\t\"Invalid CAC Leakage PowerPlay Table!\", return 1);\n\n\ttable = kzalloc(struct_size(table, entries, max_levels), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->count = vddc_lookup_pp_tables->ucNumEntries;\n\n\tfor (i = 0; i < vddc_lookup_pp_tables->ucNumEntries; i++) {\n\t\trecord = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tphm_ppt_v1_voltage_lookup_record,\n\t\t\t\t\tentries, table, i);\n\t\tatom_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_Voltage_Lookup_Record,\n\t\t\t\t\tentries, vddc_lookup_pp_tables, i);\n\t\trecord->us_calculated = 0;\n\t\trecord->us_vdd = le16_to_cpu(atom_record->usVdd);\n\t\trecord->us_cac_low = le16_to_cpu(atom_record->usCACLow);\n\t\trecord->us_cac_mid = le16_to_cpu(atom_record->usCACMid);\n\t\trecord->us_cac_high = le16_to_cpu(atom_record->usCACHigh);\n\t}\n\n\t*lookup_table = table;\n\n\treturn 0;\n}\n\n \nstatic int get_platform_power_management_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tATOM_Tonga_PPM_Table *atom_ppm_table)\n{\n\tstruct phm_ppm_table *ptr = kzalloc(sizeof(ATOM_Tonga_PPM_Table), GFP_KERNEL);\n\tstruct phm_ppt_v1_information *pp_table_information =\n\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tif (NULL == ptr)\n\t\treturn -ENOMEM;\n\n\tptr->ppm_design\n\t\t= atom_ppm_table->ucPpmDesign;\n\tptr->cpu_core_number\n\t\t= le16_to_cpu(atom_ppm_table->usCpuCoreNumber);\n\tptr->platform_tdp\n\t\t= le32_to_cpu(atom_ppm_table->ulPlatformTDP);\n\tptr->small_ac_platform_tdp\n\t\t= le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDP);\n\tptr->platform_tdc\n\t\t= le32_to_cpu(atom_ppm_table->ulPlatformTDC);\n\tptr->small_ac_platform_tdc\n\t\t= le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDC);\n\tptr->apu_tdp\n\t\t= le32_to_cpu(atom_ppm_table->ulApuTDP);\n\tptr->dgpu_tdp\n\t\t= le32_to_cpu(atom_ppm_table->ulDGpuTDP);\n\tptr->dgpu_ulv_power\n\t\t= le32_to_cpu(atom_ppm_table->ulDGpuUlvPower);\n\tptr->tj_max\n\t\t= le32_to_cpu(atom_ppm_table->ulTjmax);\n\n\tpp_table_information->ppm_parameter_table = ptr;\n\n\treturn 0;\n}\n\n \nstatic int init_dpm_2_parameters(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\n\t\t)\n{\n\tint result = 0;\n\tstruct phm_ppt_v1_information *pp_table_information = (struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tATOM_Tonga_PPM_Table *atom_ppm_table;\n\tuint32_t disable_ppm = 0;\n\tuint32_t disable_power_control = 0;\n\n\tpp_table_information->us_ulv_voltage_offset =\n\t\tle16_to_cpu(powerplay_table->usUlvVoltageOffset);\n\n\tpp_table_information->ppm_parameter_table = NULL;\n\tpp_table_information->vddc_lookup_table = NULL;\n\tpp_table_information->vddgfx_lookup_table = NULL;\n\t \n\thwmgr->platform_descriptor.TDPODLimit =\n\t\tle16_to_cpu(powerplay_table->usPowerControlLimit);\n\thwmgr->platform_descriptor.TDPAdjustment = 0;\n\thwmgr->platform_descriptor.VidAdjustment = 0;\n\thwmgr->platform_descriptor.VidAdjustmentPolarity = 0;\n\thwmgr->platform_descriptor.VidMinLimit = 0;\n\thwmgr->platform_descriptor.VidMaxLimit = 1500000;\n\thwmgr->platform_descriptor.VidStep = 6250;\n\n\tdisable_power_control = 0;\n\tif (0 == disable_power_control) {\n\t\t \n\t\tif (hwmgr->platform_descriptor.TDPODLimit != 0)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerControl);\n\t}\n\n\tif (0 != powerplay_table->usVddcLookupTableOffset) {\n\t\tconst ATOM_Tonga_Voltage_Lookup_Table *pVddcCACTable =\n\t\t\t(ATOM_Tonga_Voltage_Lookup_Table *)(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usVddcLookupTableOffset));\n\n\t\tresult = get_vddc_lookup_table(hwmgr,\n\t\t\t&pp_table_information->vddc_lookup_table, pVddcCACTable, 16);\n\t}\n\n\tif (0 != powerplay_table->usVddgfxLookupTableOffset) {\n\t\tconst ATOM_Tonga_Voltage_Lookup_Table *pVddgfxCACTable =\n\t\t\t(ATOM_Tonga_Voltage_Lookup_Table *)(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usVddgfxLookupTableOffset));\n\n\t\tresult = get_vddc_lookup_table(hwmgr,\n\t\t\t&pp_table_information->vddgfx_lookup_table, pVddgfxCACTable, 16);\n\t}\n\n\tdisable_ppm = 0;\n\tif (0 == disable_ppm) {\n\t\tatom_ppm_table = (ATOM_Tonga_PPM_Table *)\n\t\t\t(((unsigned long)powerplay_table) + le16_to_cpu(powerplay_table->usPPMTableOffset));\n\n\t\tif (0 != powerplay_table->usPPMTableOffset) {\n\t\t\tif (get_platform_power_management_table(hwmgr, atom_ppm_table) == 0) {\n\t\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_EnablePlatformPowerManagement);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int get_valid_clk(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_clock_array **clk_table,\n\t\tphm_ppt_v1_clock_voltage_dependency_table const *clk_volt_pp_table\n\t\t)\n{\n\tuint32_t i;\n\tstruct phm_clock_array *table;\n\tphm_ppt_v1_clock_voltage_dependency_record *dep_record;\n\n\tPP_ASSERT_WITH_CODE((0 != clk_volt_pp_table->count),\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\ttable = kzalloc(struct_size(table, values, clk_volt_pp_table->count),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->count = (uint32_t)clk_volt_pp_table->count;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tdep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\tphm_ppt_v1_clock_voltage_dependency_record,\n\t\t\t\tentries, clk_volt_pp_table, i);\n\t\ttable->values[i] = (uint32_t)dep_record->clk;\n\t}\n\t*clk_table = table;\n\n\treturn 0;\n}\n\nstatic int get_hard_limits(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_clock_and_voltage_limits *limits,\n\t\tATOM_Tonga_Hard_Limit_Table const *limitable\n\t\t)\n{\n\tPP_ASSERT_WITH_CODE((0 != limitable->ucNumEntries), \"Invalid PowerPlay Table!\", return -1);\n\n\t \n\tlimits->sclk = le32_to_cpu(limitable->entries[0].ulSCLKLimit);\n\tlimits->mclk = le32_to_cpu(limitable->entries[0].ulMCLKLimit);\n\tlimits->vddc = le16_to_cpu(limitable->entries[0].usVddcLimit);\n\tlimits->vddci = le16_to_cpu(limitable->entries[0].usVddciLimit);\n\tlimits->vddgfx = le16_to_cpu(limitable->entries[0].usVddgfxLimit);\n\n\treturn 0;\n}\n\nstatic int get_mclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table **pp_tonga_mclk_dep_table,\n\t\tATOM_Tonga_MCLK_Dependency_Table const *mclk_dep_table\n\t\t)\n{\n\tuint32_t i;\n\tphm_ppt_v1_clock_voltage_dependency_table *mclk_table;\n\tphm_ppt_v1_clock_voltage_dependency_record *mclk_table_record;\n\tATOM_Tonga_MCLK_Dependency_Record *mclk_dep_record;\n\n\tPP_ASSERT_WITH_CODE((0 != mclk_dep_table->ucNumEntries),\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tmclk_table = kzalloc(struct_size(mclk_table, entries, mclk_dep_table->ucNumEntries),\n\t\t\t     GFP_KERNEL);\n\tif (!mclk_table)\n\t\treturn -ENOMEM;\n\n\tmclk_table->count = (uint32_t)mclk_dep_table->ucNumEntries;\n\n\tfor (i = 0; i < mclk_dep_table->ucNumEntries; i++) {\n\t\tmclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tphm_ppt_v1_clock_voltage_dependency_record,\n\t\t\t\t\t\tentries, mclk_table, i);\n\t\tmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_MCLK_Dependency_Record,\n\t\t\t\t\t\tentries, mclk_dep_table, i);\n\t\tmclk_table_record->vddInd = mclk_dep_record->ucVddcInd;\n\t\tmclk_table_record->vdd_offset = le16_to_cpu(mclk_dep_record->usVddgfxOffset);\n\t\tmclk_table_record->vddci = le16_to_cpu(mclk_dep_record->usVddci);\n\t\tmclk_table_record->mvdd = le16_to_cpu(mclk_dep_record->usMvdd);\n\t\tmclk_table_record->clk = le32_to_cpu(mclk_dep_record->ulMclk);\n\t}\n\n\t*pp_tonga_mclk_dep_table = mclk_table;\n\n\treturn 0;\n}\n\nstatic int get_sclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table **pp_tonga_sclk_dep_table,\n\t\tPPTable_Generic_SubTable_Header const  *sclk_dep_table\n\t\t)\n{\n\tuint32_t i;\n\tphm_ppt_v1_clock_voltage_dependency_table *sclk_table;\n\tphm_ppt_v1_clock_voltage_dependency_record *sclk_table_record;\n\n\tif (sclk_dep_table->ucRevId < 1) {\n\t\tconst ATOM_Tonga_SCLK_Dependency_Table *tonga_table =\n\t\t\t    (ATOM_Tonga_SCLK_Dependency_Table *)sclk_dep_table;\n\t\tATOM_Tonga_SCLK_Dependency_Record *sclk_dep_record;\n\n\t\tPP_ASSERT_WITH_CODE((0 != tonga_table->ucNumEntries),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\t\tsclk_table = kzalloc(struct_size(sclk_table, entries, tonga_table->ucNumEntries),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!sclk_table)\n\t\t\treturn -ENOMEM;\n\n\t\tsclk_table->count = (uint32_t)tonga_table->ucNumEntries;\n\n\t\tfor (i = 0; i < tonga_table->ucNumEntries; i++) {\n\t\t\tsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Tonga_SCLK_Dependency_Record,\n\t\t\t\t\t\tentries, tonga_table, i);\n\t\t\tsclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tphm_ppt_v1_clock_voltage_dependency_record,\n\t\t\t\t\t\tentries, sclk_table, i);\n\t\t\tsclk_table_record->vddInd = sclk_dep_record->ucVddInd;\n\t\t\tsclk_table_record->vdd_offset = le16_to_cpu(sclk_dep_record->usVddcOffset);\n\t\t\tsclk_table_record->clk = le32_to_cpu(sclk_dep_record->ulSclk);\n\t\t\tsclk_table_record->cks_enable =\n\t\t\t\t(((sclk_dep_record->ucCKSVOffsetandDisable & 0x80) >> 7) == 0) ? 1 : 0;\n\t\t\tsclk_table_record->cks_voffset = (sclk_dep_record->ucCKSVOffsetandDisable & 0x7F);\n\t\t}\n\t} else {\n\t\tconst ATOM_Polaris_SCLK_Dependency_Table *polaris_table =\n\t\t\t    (ATOM_Polaris_SCLK_Dependency_Table *)sclk_dep_table;\n\t\tATOM_Polaris_SCLK_Dependency_Record *sclk_dep_record;\n\n\t\tPP_ASSERT_WITH_CODE((0 != polaris_table->ucNumEntries),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\t\tsclk_table = kzalloc(struct_size(sclk_table, entries, polaris_table->ucNumEntries),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!sclk_table)\n\t\t\treturn -ENOMEM;\n\n\t\tsclk_table->count = (uint32_t)polaris_table->ucNumEntries;\n\n\t\tfor (i = 0; i < polaris_table->ucNumEntries; i++) {\n\t\t\tsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Polaris_SCLK_Dependency_Record,\n\t\t\t\t\t\tentries, polaris_table, i);\n\t\t\tsclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tphm_ppt_v1_clock_voltage_dependency_record,\n\t\t\t\t\t\tentries, sclk_table, i);\n\t\t\tsclk_table_record->vddInd = sclk_dep_record->ucVddInd;\n\t\t\tsclk_table_record->vdd_offset = le16_to_cpu(sclk_dep_record->usVddcOffset);\n\t\t\tsclk_table_record->clk = le32_to_cpu(sclk_dep_record->ulSclk);\n\t\t\tsclk_table_record->cks_enable =\n\t\t\t\t(((sclk_dep_record->ucCKSVOffsetandDisable & 0x80) >> 7) == 0) ? 1 : 0;\n\t\t\tsclk_table_record->cks_voffset = (sclk_dep_record->ucCKSVOffsetandDisable & 0x7F);\n\t\t\tsclk_table_record->sclk_offset = le32_to_cpu(sclk_dep_record->ulSclkOffset);\n\t\t}\n\t}\n\t*pp_tonga_sclk_dep_table = sclk_table;\n\n\treturn 0;\n}\n\nstatic int get_pcie_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_pcie_table **pp_tonga_pcie_table,\n\t\tPPTable_Generic_SubTable_Header const *ptable\n\t\t)\n{\n\tuint32_t i, pcie_count;\n\tphm_ppt_v1_pcie_table *pcie_table;\n\tstruct phm_ppt_v1_information *pp_table_information =\n\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tphm_ppt_v1_pcie_record *pcie_record;\n\n\tif (ptable->ucRevId < 1) {\n\t\tconst ATOM_Tonga_PCIE_Table *atom_pcie_table = (ATOM_Tonga_PCIE_Table *)ptable;\n\t\tATOM_Tonga_PCIE_Record *atom_pcie_record;\n\n\t\tPP_ASSERT_WITH_CODE((atom_pcie_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\t\tpcie_table = kzalloc(struct_size(pcie_table, entries,\n\t\t\t\t\t\t atom_pcie_table->ucNumEntries),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcie_table)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tpcie_count = (pp_table_information->vdd_dep_on_sclk->count) + 1;\n\t\tif ((uint32_t)atom_pcie_table->ucNumEntries <= pcie_count)\n\t\t\tpcie_count = (uint32_t)atom_pcie_table->ucNumEntries;\n\t\telse\n\t\t\tpr_err(\"Number of Pcie Entries exceed the number of SCLK Dpm Levels! Disregarding the excess entries...\\n\");\n\n\t\tpcie_table->count = pcie_count;\n\t\tfor (i = 0; i < pcie_count; i++) {\n\t\t\tpcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tphm_ppt_v1_pcie_record,\n\t\t\t\t\t\tentries, pcie_table, i);\n\t\t\tatom_pcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Tonga_PCIE_Record,\n\t\t\t\t\t\tentries, atom_pcie_table, i);\n\t\t\tpcie_record->gen_speed = atom_pcie_record->ucPCIEGenSpeed;\n\t\t\tpcie_record->lane_width = le16_to_cpu(atom_pcie_record->usPCIELaneWidth);\n\t\t}\n\n\t\t*pp_tonga_pcie_table = pcie_table;\n\t} else {\n\t\t \n\t\tconst ATOM_Polaris10_PCIE_Table *atom_pcie_table = (ATOM_Polaris10_PCIE_Table *)ptable;\n\t\tATOM_Polaris10_PCIE_Record *atom_pcie_record;\n\n\t\tPP_ASSERT_WITH_CODE((atom_pcie_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\t\tpcie_table = kzalloc(struct_size(pcie_table, entries,\n\t\t\t\t\t\t atom_pcie_table->ucNumEntries),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcie_table)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tpcie_count = (pp_table_information->vdd_dep_on_sclk->count) + 1;\n\t\tif ((uint32_t)atom_pcie_table->ucNumEntries <= pcie_count)\n\t\t\tpcie_count = (uint32_t)atom_pcie_table->ucNumEntries;\n\t\telse\n\t\t\tpr_err(\"Number of Pcie Entries exceed the number of SCLK Dpm Levels! Disregarding the excess entries...\\n\");\n\n\t\tpcie_table->count = pcie_count;\n\n\t\tfor (i = 0; i < pcie_count; i++) {\n\t\t\tpcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tphm_ppt_v1_pcie_record,\n\t\t\t\t\t\tentries, pcie_table, i);\n\t\t\tatom_pcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Polaris10_PCIE_Record,\n\t\t\t\t\t\tentries, atom_pcie_table, i);\n\t\t\tpcie_record->gen_speed = atom_pcie_record->ucPCIEGenSpeed;\n\t\t\tpcie_record->lane_width = le16_to_cpu(atom_pcie_record->usPCIELaneWidth);\n\t\t\tpcie_record->pcie_sclk = le32_to_cpu(atom_pcie_record->ulPCIE_Sclk);\n\t\t}\n\n\t\t*pp_tonga_pcie_table = pcie_table;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_cac_tdp_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_cac_tdp_table **cac_tdp_table,\n\t\tconst PPTable_Generic_SubTable_Header * table\n\t\t)\n{\n\tuint32_t table_size;\n\tstruct phm_cac_tdp_table *tdp_table;\n\n\ttable_size = sizeof(uint32_t) + sizeof(struct phm_cac_tdp_table);\n\ttdp_table = kzalloc(table_size, GFP_KERNEL);\n\n\tif (NULL == tdp_table)\n\t\treturn -ENOMEM;\n\n\thwmgr->dyn_state.cac_dtp_table = kzalloc(table_size, GFP_KERNEL);\n\n\tif (NULL == hwmgr->dyn_state.cac_dtp_table) {\n\t\tkfree(tdp_table);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (table->ucRevId < 3) {\n\t\tconst ATOM_Tonga_PowerTune_Table *tonga_table =\n\t\t\t(ATOM_Tonga_PowerTune_Table *)table;\n\t\ttdp_table->usTDP = le16_to_cpu(tonga_table->usTDP);\n\t\ttdp_table->usConfigurableTDP =\n\t\t\tle16_to_cpu(tonga_table->usConfigurableTDP);\n\t\ttdp_table->usTDC = le16_to_cpu(tonga_table->usTDC);\n\t\ttdp_table->usBatteryPowerLimit =\n\t\t\tle16_to_cpu(tonga_table->usBatteryPowerLimit);\n\t\ttdp_table->usSmallPowerLimit =\n\t\t\tle16_to_cpu(tonga_table->usSmallPowerLimit);\n\t\ttdp_table->usLowCACLeakage =\n\t\t\tle16_to_cpu(tonga_table->usLowCACLeakage);\n\t\ttdp_table->usHighCACLeakage =\n\t\t\tle16_to_cpu(tonga_table->usHighCACLeakage);\n\t\ttdp_table->usMaximumPowerDeliveryLimit =\n\t\t\tle16_to_cpu(tonga_table->usMaximumPowerDeliveryLimit);\n\t\ttdp_table->usDefaultTargetOperatingTemp =\n\t\t\tle16_to_cpu(tonga_table->usTjMax);\n\t\ttdp_table->usTargetOperatingTemp =\n\t\t\tle16_to_cpu(tonga_table->usTjMax);  \n\t\ttdp_table->usPowerTuneDataSetID =\n\t\t\tle16_to_cpu(tonga_table->usPowerTuneDataSetID);\n\t\ttdp_table->usSoftwareShutdownTemp =\n\t\t\tle16_to_cpu(tonga_table->usSoftwareShutdownTemp);\n\t\ttdp_table->usClockStretchAmount =\n\t\t\tle16_to_cpu(tonga_table->usClockStretchAmount);\n\t} else if (table->ucRevId < 4) {    \n\t\tconst ATOM_Fiji_PowerTune_Table *fijitable =\n\t\t\t(ATOM_Fiji_PowerTune_Table *)table;\n\t\ttdp_table->usTDP = le16_to_cpu(fijitable->usTDP);\n\t\ttdp_table->usConfigurableTDP = le16_to_cpu(fijitable->usConfigurableTDP);\n\t\ttdp_table->usTDC = le16_to_cpu(fijitable->usTDC);\n\t\ttdp_table->usBatteryPowerLimit = le16_to_cpu(fijitable->usBatteryPowerLimit);\n\t\ttdp_table->usSmallPowerLimit = le16_to_cpu(fijitable->usSmallPowerLimit);\n\t\ttdp_table->usLowCACLeakage = le16_to_cpu(fijitable->usLowCACLeakage);\n\t\ttdp_table->usHighCACLeakage = le16_to_cpu(fijitable->usHighCACLeakage);\n\t\ttdp_table->usMaximumPowerDeliveryLimit =\n\t\t\tle16_to_cpu(fijitable->usMaximumPowerDeliveryLimit);\n\t\ttdp_table->usDefaultTargetOperatingTemp =\n\t\t\tle16_to_cpu(fijitable->usTjMax);\n\t\ttdp_table->usTargetOperatingTemp =\n\t\t\tle16_to_cpu(fijitable->usTjMax);  \n\t\ttdp_table->usPowerTuneDataSetID =\n\t\t\tle16_to_cpu(fijitable->usPowerTuneDataSetID);\n\t\ttdp_table->usSoftwareShutdownTemp =\n\t\t\tle16_to_cpu(fijitable->usSoftwareShutdownTemp);\n\t\ttdp_table->usClockStretchAmount =\n\t\t\tle16_to_cpu(fijitable->usClockStretchAmount);\n\t\ttdp_table->usTemperatureLimitHotspot =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitHotspot);\n\t\ttdp_table->usTemperatureLimitLiquid1 =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitLiquid1);\n\t\ttdp_table->usTemperatureLimitLiquid2 =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitLiquid2);\n\t\ttdp_table->usTemperatureLimitVrVddc =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitVrVddc);\n\t\ttdp_table->usTemperatureLimitVrMvdd =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitVrMvdd);\n\t\ttdp_table->usTemperatureLimitPlx =\n\t\t\tle16_to_cpu(fijitable->usTemperatureLimitPlx);\n\t\ttdp_table->ucLiquid1_I2C_address =\n\t\t\tfijitable->ucLiquid1_I2C_address;\n\t\ttdp_table->ucLiquid2_I2C_address =\n\t\t\tfijitable->ucLiquid2_I2C_address;\n\t\ttdp_table->ucLiquid_I2C_Line =\n\t\t\tfijitable->ucLiquid_I2C_Line;\n\t\ttdp_table->ucVr_I2C_address = fijitable->ucVr_I2C_address;\n\t\ttdp_table->ucVr_I2C_Line = fijitable->ucVr_I2C_Line;\n\t\ttdp_table->ucPlx_I2C_address = fijitable->ucPlx_I2C_address;\n\t\ttdp_table->ucPlx_I2C_Line = fijitable->ucPlx_I2C_Line;\n\t} else {\n\t\tconst ATOM_Polaris_PowerTune_Table *polaristable =\n\t\t\t(ATOM_Polaris_PowerTune_Table *)table;\n\t\ttdp_table->usTDP = le16_to_cpu(polaristable->usTDP);\n\t\ttdp_table->usConfigurableTDP = le16_to_cpu(polaristable->usConfigurableTDP);\n\t\ttdp_table->usTDC = le16_to_cpu(polaristable->usTDC);\n\t\ttdp_table->usBatteryPowerLimit = le16_to_cpu(polaristable->usBatteryPowerLimit);\n\t\ttdp_table->usSmallPowerLimit = le16_to_cpu(polaristable->usSmallPowerLimit);\n\t\ttdp_table->usLowCACLeakage = le16_to_cpu(polaristable->usLowCACLeakage);\n\t\ttdp_table->usHighCACLeakage = le16_to_cpu(polaristable->usHighCACLeakage);\n\t\ttdp_table->usMaximumPowerDeliveryLimit =\n\t\t\tle16_to_cpu(polaristable->usMaximumPowerDeliveryLimit);\n\t\ttdp_table->usDefaultTargetOperatingTemp =\n\t\t\tle16_to_cpu(polaristable->usTjMax);\n\t\ttdp_table->usTargetOperatingTemp =\n\t\t\tle16_to_cpu(polaristable->usTjMax);  \n\t\ttdp_table->usPowerTuneDataSetID =\n\t\t\tle16_to_cpu(polaristable->usPowerTuneDataSetID);\n\t\ttdp_table->usSoftwareShutdownTemp =\n\t\t\tle16_to_cpu(polaristable->usSoftwareShutdownTemp);\n\t\ttdp_table->usClockStretchAmount =\n\t\t\tle16_to_cpu(polaristable->usClockStretchAmount);\n\t\ttdp_table->usTemperatureLimitHotspot =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitHotspot);\n\t\ttdp_table->usTemperatureLimitLiquid1 =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitLiquid1);\n\t\ttdp_table->usTemperatureLimitLiquid2 =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitLiquid2);\n\t\ttdp_table->usTemperatureLimitVrVddc =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitVrVddc);\n\t\ttdp_table->usTemperatureLimitVrMvdd =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitVrMvdd);\n\t\ttdp_table->usTemperatureLimitPlx =\n\t\t\tle16_to_cpu(polaristable->usTemperatureLimitPlx);\n\t\ttdp_table->ucLiquid1_I2C_address =\n\t\t\tpolaristable->ucLiquid1_I2C_address;\n\t\ttdp_table->ucLiquid2_I2C_address =\n\t\t\tpolaristable->ucLiquid2_I2C_address;\n\t\ttdp_table->ucLiquid_I2C_Line =\n\t\t\tpolaristable->ucLiquid_I2C_Line;\n\t\ttdp_table->ucVr_I2C_address = polaristable->ucVr_I2C_address;\n\t\ttdp_table->ucVr_I2C_Line = polaristable->ucVr_I2C_Line;\n\t\ttdp_table->ucPlx_I2C_address = polaristable->ucPlx_I2C_address;\n\t\ttdp_table->ucPlx_I2C_Line = polaristable->ucPlx_I2C_Line;\n\t\ttdp_table->usBoostPowerLimit = polaristable->usBoostPowerLimit;\n\t\ttdp_table->ucCKS_LDO_REFSEL = polaristable->ucCKS_LDO_REFSEL;\n\t\ttdp_table->ucHotSpotOnly = polaristable->ucHotSpotOnly;\n\t}\n\n\t*cac_tdp_table = tdp_table;\n\n\treturn 0;\n}\n\nstatic int get_mm_clock_voltage_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_mm_clock_voltage_dependency_table **tonga_mm_table,\n\t\tconst ATOM_Tonga_MM_Dependency_Table * mm_dependency_table\n\t\t)\n{\n\tuint32_t i;\n\tconst ATOM_Tonga_MM_Dependency_Record *mm_dependency_record;\n\tphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table;\n\tphm_ppt_v1_mm_clock_voltage_dependency_record *mm_table_record;\n\n\tPP_ASSERT_WITH_CODE((0 != mm_dependency_table->ucNumEntries),\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\tmm_table = kzalloc(struct_size(mm_table, entries, mm_dependency_table->ucNumEntries),\n\t\t\t   GFP_KERNEL);\n\tif (!mm_table)\n\t\treturn -ENOMEM;\n\n\tmm_table->count = mm_dependency_table->ucNumEntries;\n\n\tfor (i = 0; i < mm_dependency_table->ucNumEntries; i++) {\n\t\tmm_dependency_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Tonga_MM_Dependency_Record,\n\t\t\t\t\t\tentries, mm_dependency_table, i);\n\t\tmm_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tphm_ppt_v1_mm_clock_voltage_dependency_record,\n\t\t\t\t\tentries, mm_table, i);\n\t\tmm_table_record->vddcInd = mm_dependency_record->ucVddcInd;\n\t\tmm_table_record->vddgfx_offset = le16_to_cpu(mm_dependency_record->usVddgfxOffset);\n\t\tmm_table_record->aclk = le32_to_cpu(mm_dependency_record->ulAClk);\n\t\tmm_table_record->samclock = le32_to_cpu(mm_dependency_record->ulSAMUClk);\n\t\tmm_table_record->eclk = le32_to_cpu(mm_dependency_record->ulEClk);\n\t\tmm_table_record->vclk = le32_to_cpu(mm_dependency_record->ulVClk);\n\t\tmm_table_record->dclk = le32_to_cpu(mm_dependency_record->ulDClk);\n\t}\n\n\t*tonga_mm_table = mm_table;\n\n\treturn 0;\n}\n\nstatic int get_gpio_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_gpio_table **pp_tonga_gpio_table,\n\t\tconst ATOM_Tonga_GPIO_Table *atom_gpio_table)\n{\n\tuint32_t table_size;\n\tstruct phm_ppt_v1_gpio_table *pp_gpio_table;\n\tstruct phm_ppt_v1_information *pp_table_information =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\ttable_size = sizeof(struct phm_ppt_v1_gpio_table);\n\tpp_gpio_table = kzalloc(table_size, GFP_KERNEL);\n\tif (!pp_gpio_table)\n\t\treturn -ENOMEM;\n\n\tif (pp_table_information->vdd_dep_on_sclk->count <\n\t\t\tatom_gpio_table->ucVRHotTriggeredSclkDpmIndex)\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"SCLK DPM index for VRHot cannot exceed the total sclk level count!\",);\n\telse\n\t\tpp_gpio_table->vrhot_triggered_sclk_dpm_index =\n\t\t\t\tatom_gpio_table->ucVRHotTriggeredSclkDpmIndex;\n\n\t*pp_tonga_gpio_table = pp_gpio_table;\n\n\treturn 0;\n}\n \nstatic int init_clock_voltage_dependency(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\n\t\t)\n{\n\tint result = 0;\n\tstruct phm_ppt_v1_information *pp_table_information =\n\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tconst ATOM_Tonga_MM_Dependency_Table *mm_dependency_table =\n\t\t(const ATOM_Tonga_MM_Dependency_Table *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usMMDependencyTableOffset));\n\tconst PPTable_Generic_SubTable_Header *pPowerTuneTable =\n\t\t(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usPowerTuneTableOffset));\n\tconst ATOM_Tonga_MCLK_Dependency_Table *mclk_dep_table =\n\t\t(const ATOM_Tonga_MCLK_Dependency_Table *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usMclkDependencyTableOffset));\n\tconst PPTable_Generic_SubTable_Header *sclk_dep_table =\n\t\t(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usSclkDependencyTableOffset));\n\tconst ATOM_Tonga_Hard_Limit_Table *pHardLimits =\n\t\t(const ATOM_Tonga_Hard_Limit_Table *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usHardLimitTableOffset));\n\tconst PPTable_Generic_SubTable_Header *pcie_table =\n\t\t(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usPCIETableOffset));\n\tconst ATOM_Tonga_GPIO_Table *gpio_table =\n\t\t(const ATOM_Tonga_GPIO_Table *)(((unsigned long) powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usGPIOTableOffset));\n\n\tpp_table_information->vdd_dep_on_sclk = NULL;\n\tpp_table_information->vdd_dep_on_mclk = NULL;\n\tpp_table_information->mm_dep_table = NULL;\n\tpp_table_information->pcie_table = NULL;\n\tpp_table_information->gpio_table = NULL;\n\n\tif (powerplay_table->usMMDependencyTableOffset != 0)\n\t\tresult = get_mm_clock_voltage_table(hwmgr,\n\t\t&pp_table_information->mm_dep_table, mm_dependency_table);\n\n\tif (result == 0 && powerplay_table->usPowerTuneTableOffset != 0)\n\t\tresult = get_cac_tdp_table(hwmgr,\n\t\t&pp_table_information->cac_dtp_table, pPowerTuneTable);\n\n\tif (result == 0 && powerplay_table->usSclkDependencyTableOffset != 0)\n\t\tresult = get_sclk_voltage_dependency_table(hwmgr,\n\t\t&pp_table_information->vdd_dep_on_sclk, sclk_dep_table);\n\n\tif (result == 0 && powerplay_table->usMclkDependencyTableOffset != 0)\n\t\tresult = get_mclk_voltage_dependency_table(hwmgr,\n\t\t&pp_table_information->vdd_dep_on_mclk, mclk_dep_table);\n\n\tif (result == 0 && powerplay_table->usPCIETableOffset != 0)\n\t\tresult = get_pcie_table(hwmgr,\n\t\t&pp_table_information->pcie_table, pcie_table);\n\n\tif (result == 0 && powerplay_table->usHardLimitTableOffset != 0)\n\t\tresult = get_hard_limits(hwmgr,\n\t\t&pp_table_information->max_clock_voltage_on_dc, pHardLimits);\n\n\thwmgr->dyn_state.max_clock_voltage_on_dc.sclk =\n\t\tpp_table_information->max_clock_voltage_on_dc.sclk;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.mclk =\n\t\tpp_table_information->max_clock_voltage_on_dc.mclk;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.vddc =\n\t\tpp_table_information->max_clock_voltage_on_dc.vddc;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.vddci =\n\t\tpp_table_information->max_clock_voltage_on_dc.vddci;\n\n\tif (result == 0 && (NULL != pp_table_information->vdd_dep_on_mclk)\n\t\t&& (0 != pp_table_information->vdd_dep_on_mclk->count))\n\t\tresult = get_valid_clk(hwmgr, &pp_table_information->valid_mclk_values,\n\t\tpp_table_information->vdd_dep_on_mclk);\n\n\tif (result == 0 && (NULL != pp_table_information->vdd_dep_on_sclk)\n\t\t&& (0 != pp_table_information->vdd_dep_on_sclk->count))\n\t\tresult = get_valid_clk(hwmgr, &pp_table_information->valid_sclk_values,\n\t\tpp_table_information->vdd_dep_on_sclk);\n\n\tif (!result && gpio_table)\n\t\tresult = get_gpio_table(hwmgr, &pp_table_information->gpio_table,\n\t\t\t\tgpio_table);\n\n\treturn result;\n}\n\n \nstatic int init_over_drive_limits(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table)\n{\n\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\tle32_to_cpu(powerplay_table->ulMaxODEngineClock);\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock =\n\t\tle32_to_cpu(powerplay_table->ulMaxODMemoryClock);\n\n\thwmgr->platform_descriptor.minOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.maxOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.overdriveVDDCStep = 0;\n\n\treturn 0;\n}\n\n \nstatic int init_thermal_controller(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\n\t\t)\n{\n\tconst PPTable_Generic_SubTable_Header *fan_table;\n\tATOM_Tonga_Thermal_Controller *thermal_controller;\n\n\tthermal_controller = (ATOM_Tonga_Thermal_Controller *)\n\t\t(((unsigned long)powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usThermalControllerOffset));\n\tPP_ASSERT_WITH_CODE((0 != powerplay_table->usThermalControllerOffset),\n\t\t\"Thermal controller table not set!\", return -1);\n\n\thwmgr->thermal_controller.ucType = thermal_controller->ucType;\n\thwmgr->thermal_controller.ucI2cLine = thermal_controller->ucI2cLine;\n\thwmgr->thermal_controller.ucI2cAddress = thermal_controller->ucI2cAddress;\n\n\thwmgr->thermal_controller.fanInfo.bNoFan =\n\t\t(0 != (thermal_controller->ucFanParameters & ATOM_TONGA_PP_FANPARAMETERS_NOFAN));\n\n\thwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\n\t\tthermal_controller->ucFanParameters &\n\t\tATOM_TONGA_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\n\thwmgr->thermal_controller.fanInfo.ulMinRPM\n\t\t= thermal_controller->ucFanMinRPM * 100UL;\n\thwmgr->thermal_controller.fanInfo.ulMaxRPM\n\t\t= thermal_controller->ucFanMaxRPM * 100UL;\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\tATOM_TONGA_PP_THERMALCONTROLLER_NONE != hwmgr->thermal_controller.ucType,\n\t\t\tPHM_PlatformCaps_ThermalController\n\t\t  );\n\n\tif (0 == powerplay_table->usFanTableOffset) {\n\t\thwmgr->thermal_controller.use_hw_fan_control = 1;\n\t\treturn 0;\n\t}\n\n\tfan_table = (const PPTable_Generic_SubTable_Header *)\n\t\t(((unsigned long)powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usFanTableOffset));\n\n\tPP_ASSERT_WITH_CODE((0 != powerplay_table->usFanTableOffset),\n\t\t\"Fan table not set!\", return -1);\n\tPP_ASSERT_WITH_CODE((0 < fan_table->ucRevId),\n\t\t\"Unsupported fan table format!\", return -1);\n\n\thwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay\n\t\t= 100000;\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\n\tif (fan_table->ucRevId < 8) {\n\t\tconst ATOM_Tonga_Fan_Table *tonga_fan_table =\n\t\t\t(ATOM_Tonga_Fan_Table *)fan_table;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTHyst\n\t\t\t= tonga_fan_table->ucTHyst;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMin\n\t\t\t= le16_to_cpu(tonga_fan_table->usTMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMed\n\t\t\t= le16_to_cpu(tonga_fan_table->usTMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTHigh\n\t\t\t= le16_to_cpu(tonga_fan_table->usTHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin\n\t\t\t= le16_to_cpu(tonga_fan_table->usPWMMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMed\n\t\t\t= le16_to_cpu(tonga_fan_table->usPWMMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh\n\t\t\t= le16_to_cpu(tonga_fan_table->usPWMHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax\n\t\t\t= 10900;                   \n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax\n\t\t\t= le16_to_cpu(tonga_fan_table->usTMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode\n\t\t\t= tonga_fan_table->ucFanControlMode;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM\n\t\t\t= le16_to_cpu(tonga_fan_table->usFanPWMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity\n\t\t\t= 4836;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity\n\t\t\t= le16_to_cpu(tonga_fan_table->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM\n\t\t\t= le16_to_cpu(tonga_fan_table->usFanRPMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit\n\t\t\t= (le32_to_cpu(tonga_fan_table->ulMinFanSCLKAcousticLimit) / 100);  \n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTargetTemperature\n\t\t\t= tonga_fan_table->ucTargetTemperature;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit\n\t\t\t= tonga_fan_table->ucMinimumPWMLimit;\n\t} else if (fan_table->ucRevId == 8) {\n\t\tconst ATOM_Fiji_Fan_Table *fiji_fan_table =\n\t\t\t(ATOM_Fiji_Fan_Table *)fan_table;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTHyst\n\t\t\t= fiji_fan_table->ucTHyst;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMin\n\t\t\t= le16_to_cpu(fiji_fan_table->usTMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMed\n\t\t\t= le16_to_cpu(fiji_fan_table->usTMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTHigh\n\t\t\t= le16_to_cpu(fiji_fan_table->usTHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin\n\t\t\t= le16_to_cpu(fiji_fan_table->usPWMMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMed\n\t\t\t= le16_to_cpu(fiji_fan_table->usPWMMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh\n\t\t\t= le16_to_cpu(fiji_fan_table->usPWMHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax\n\t\t\t= le16_to_cpu(fiji_fan_table->usTMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode\n\t\t\t= fiji_fan_table->ucFanControlMode;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanPWMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity\n\t\t\t= 4836;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanRPMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit\n\t\t\t= (le32_to_cpu(fiji_fan_table->ulMinFanSCLKAcousticLimit) / 100);  \n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTargetTemperature\n\t\t\t= fiji_fan_table->ucTargetTemperature;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit\n\t\t\t= fiji_fan_table->ucMinimumPWMLimit;\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainEdge);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainHotspot);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainLiquid);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainVrVddc);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainVrMvdd);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainPlx);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm\n\t\t\t= le16_to_cpu(fiji_fan_table->usFanGainHbm);\n\t} else if (fan_table->ucRevId >= 9) {\n\t\tconst ATOM_Polaris_Fan_Table *polaris_fan_table =\n\t\t\t(ATOM_Polaris_Fan_Table *)fan_table;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTHyst\n\t\t\t= polaris_fan_table->ucTHyst;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMin\n\t\t\t= le16_to_cpu(polaris_fan_table->usTMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMed\n\t\t\t= le16_to_cpu(polaris_fan_table->usTMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTHigh\n\t\t\t= le16_to_cpu(polaris_fan_table->usTHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin\n\t\t\t= le16_to_cpu(polaris_fan_table->usPWMMin);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMed\n\t\t\t= le16_to_cpu(polaris_fan_table->usPWMMed);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh\n\t\t\t= le16_to_cpu(polaris_fan_table->usPWMHigh);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax\n\t\t\t= le16_to_cpu(polaris_fan_table->usTMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode\n\t\t\t= polaris_fan_table->ucFanControlMode;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanPWMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity\n\t\t\t= 4836;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanRPMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit\n\t\t\t= (le32_to_cpu(polaris_fan_table->ulMinFanSCLKAcousticLimit) / 100);  \n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTargetTemperature\n\t\t\t= polaris_fan_table->ucTargetTemperature;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit\n\t\t\t= polaris_fan_table->ucMinimumPWMLimit;\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainEdge);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainHotspot);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainLiquid);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainVrVddc);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainVrMvdd);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainPlx);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm\n\t\t\t= le16_to_cpu(polaris_fan_table->usFanGainHbm);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM\n\t\t\t= le16_to_cpu(polaris_fan_table->ucEnableZeroRPM);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanStopTemperature\n\t\t\t= le16_to_cpu(polaris_fan_table->ucFanStopTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanStartTemperature\n\t\t\t= le16_to_cpu(polaris_fan_table->ucFanStartTemperature);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int check_powerplay_tables(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\n\t\t)\n{\n\tconst ATOM_Tonga_State_Array *state_arrays;\n\n\tstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usStateArrayOffset));\n\n\tPP_ASSERT_WITH_CODE((ATOM_Tonga_TABLE_REVISION_TONGA <=\n\t\tpowerplay_table->sHeader.ucTableFormatRevision),\n\t\t\"Unsupported PPTable format!\", return -1);\n\tPP_ASSERT_WITH_CODE((0 != powerplay_table->usStateArrayOffset),\n\t\t\"State table is not set!\", return -1);\n\tPP_ASSERT_WITH_CODE((0 < powerplay_table->sHeader.usStructureSize),\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\tPP_ASSERT_WITH_CODE((0 < state_arrays->ucNumEntries),\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\treturn 0;\n}\n\nstatic int pp_tables_v1_0_initialize(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table;\n\n\thwmgr->pptable = kzalloc(sizeof(struct phm_ppt_v1_information), GFP_KERNEL);\n\n\tPP_ASSERT_WITH_CODE((NULL != hwmgr->pptable),\n\t\t\t    \"Failed to allocate hwmgr->pptable!\", return -ENOMEM);\n\n\tpowerplay_table = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((NULL != powerplay_table),\n\t\t\"Missing PowerPlay Table!\", return -1);\n\n\tresult = check_powerplay_tables(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"check_powerplay_tables failed\", return result);\n\n\tresult = set_platform_caps(hwmgr,\n\t\t\t\t   le32_to_cpu(powerplay_table->ulPlatformCaps));\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"set_platform_caps failed\", return result);\n\n\tresult = init_thermal_controller(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_thermal_controller failed\", return result);\n\n\tresult = init_over_drive_limits(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_over_drive_limits failed\", return result);\n\n\tresult = init_clock_voltage_dependency(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_clock_voltage_dependency failed\", return result);\n\n\tresult = init_dpm_2_parameters(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_dpm_2_parameters failed\", return result);\n\n\treturn result;\n}\n\nstatic int pp_tables_v1_0_uninitialize(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v1_information *pp_table_information =\n\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tkfree(pp_table_information->vdd_dep_on_sclk);\n\tpp_table_information->vdd_dep_on_sclk = NULL;\n\n\tkfree(pp_table_information->vdd_dep_on_mclk);\n\tpp_table_information->vdd_dep_on_mclk = NULL;\n\n\tkfree(pp_table_information->valid_mclk_values);\n\tpp_table_information->valid_mclk_values = NULL;\n\n\tkfree(pp_table_information->valid_sclk_values);\n\tpp_table_information->valid_sclk_values = NULL;\n\n\tkfree(pp_table_information->vddc_lookup_table);\n\tpp_table_information->vddc_lookup_table = NULL;\n\n\tkfree(pp_table_information->vddgfx_lookup_table);\n\tpp_table_information->vddgfx_lookup_table = NULL;\n\n\tkfree(pp_table_information->mm_dep_table);\n\tpp_table_information->mm_dep_table = NULL;\n\n\tkfree(pp_table_information->cac_dtp_table);\n\tpp_table_information->cac_dtp_table = NULL;\n\n\tkfree(hwmgr->dyn_state.cac_dtp_table);\n\thwmgr->dyn_state.cac_dtp_table = NULL;\n\n\tkfree(pp_table_information->ppm_parameter_table);\n\tpp_table_information->ppm_parameter_table = NULL;\n\n\tkfree(pp_table_information->pcie_table);\n\tpp_table_information->pcie_table = NULL;\n\n\tkfree(pp_table_information->gpio_table);\n\tpp_table_information->gpio_table = NULL;\n\n\tkfree(hwmgr->pptable);\n\thwmgr->pptable = NULL;\n\n\treturn 0;\n}\n\nconst struct pp_table_func pptable_v1_0_funcs = {\n\t.pptable_init = pp_tables_v1_0_initialize,\n\t.pptable_fini = pp_tables_v1_0_uninitialize,\n};\n\nint get_number_of_powerplay_table_entries_v1_0(struct pp_hwmgr *hwmgr)\n{\n\tATOM_Tonga_State_Array const *state_arrays;\n\tconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((NULL != pp_table),\n\t\t\t\"Missing PowerPlay Table!\", return -1);\n\tPP_ASSERT_WITH_CODE((pp_table->sHeader.ucTableFormatRevision >=\n\t\t\tATOM_Tonga_TABLE_REVISION_TONGA),\n\t\t\t\"Incorrect PowerPlay table revision!\", return -1);\n\n\tstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)pp_table) +\n\t\t\tle16_to_cpu(pp_table->usStateArrayOffset));\n\n\treturn (uint32_t)(state_arrays->ucNumEntries);\n}\n\n \nstatic uint32_t make_classification_flags(struct pp_hwmgr *hwmgr,\n\t\tuint16_t classification, uint16_t classification2)\n{\n\tuint32_t result = 0;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\tresult |= PP_StateClassificationFlag_Boot;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\tresult |= PP_StateClassificationFlag_Thermal;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\n\t\tresult |= PP_StateClassificationFlag_Rest;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\n\t\tresult |= PP_StateClassificationFlag_Forced;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\tresult |= PP_StateClassificationFlag_ACPI;\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\n\n\treturn result;\n}\n\nstatic int ppt_get_num_of_vce_state_table_entries_v1_0(struct pp_hwmgr *hwmgr)\n{\n\tconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\n\tconst ATOM_Tonga_VCE_State_Table *vce_state_table;\n\n\n\tif (pp_table == NULL)\n\t\treturn 0;\n\n\tvce_state_table = (void *)pp_table +\n\t\t\tle16_to_cpu(pp_table->usVCEStateTableOffset);\n\n\treturn vce_state_table->ucNumEntries;\n}\n\nstatic int ppt_get_vce_state_table_entry_v1_0(struct pp_hwmgr *hwmgr, uint32_t i,\n\t\tstruct amd_vce_state *vce_state, void **clock_info, uint32_t *flag)\n{\n\tconst ATOM_Tonga_VCE_State_Record *vce_state_record;\n\tATOM_Tonga_SCLK_Dependency_Record *sclk_dep_record;\n\tATOM_Tonga_MCLK_Dependency_Record *mclk_dep_record;\n\tATOM_Tonga_MM_Dependency_Record *mm_dep_record;\n\tconst ATOM_Tonga_POWERPLAYTABLE *pptable = get_powerplay_table(hwmgr);\n\tconst ATOM_Tonga_VCE_State_Table *vce_state_table = (ATOM_Tonga_VCE_State_Table *)(((unsigned long)pptable)\n\t\t\t\t\t\t\t  + le16_to_cpu(pptable->usVCEStateTableOffset));\n\tconst ATOM_Tonga_SCLK_Dependency_Table *sclk_dep_table = (ATOM_Tonga_SCLK_Dependency_Table *)(((unsigned long)pptable)\n\t\t\t\t\t\t\t  + le16_to_cpu(pptable->usSclkDependencyTableOffset));\n\tconst ATOM_Tonga_MCLK_Dependency_Table *mclk_dep_table = (ATOM_Tonga_MCLK_Dependency_Table *)(((unsigned long)pptable)\n\t\t\t\t\t\t\t  + le16_to_cpu(pptable->usMclkDependencyTableOffset));\n\tconst ATOM_Tonga_MM_Dependency_Table *mm_dep_table = (ATOM_Tonga_MM_Dependency_Table *)(((unsigned long)pptable)\n\t\t\t\t\t\t\t  + le16_to_cpu(pptable->usMMDependencyTableOffset));\n\n\tPP_ASSERT_WITH_CODE((i < vce_state_table->ucNumEntries),\n\t\t\t \"Requested state entry ID is out of range!\",\n\t\t\t return -EINVAL);\n\n\tvce_state_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_VCE_State_Record,\n\t\t\t\t\tentries, vce_state_table, i);\n\tsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_SCLK_Dependency_Record,\n\t\t\t\t\tentries, sclk_dep_table,\n\t\t\t\t\tvce_state_record->ucSCLKIndex);\n\tmm_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_MM_Dependency_Record,\n\t\t\t\t\tentries, mm_dep_table,\n\t\t\t\t\tvce_state_record->ucVCEClockIndex);\n\t*flag = vce_state_record->ucFlag;\n\n\tvce_state->evclk = le32_to_cpu(mm_dep_record->ulEClk);\n\tvce_state->ecclk = le32_to_cpu(mm_dep_record->ulEClk);\n\tvce_state->sclk = le32_to_cpu(sclk_dep_record->ulSclk);\n\n\tif (vce_state_record->ucMCLKIndex >= mclk_dep_table->ucNumEntries)\n\t\tmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_MCLK_Dependency_Record,\n\t\t\t\t\tentries, mclk_dep_table,\n\t\t\t\t\tmclk_dep_table->ucNumEntries - 1);\n\telse\n\t\tmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\tATOM_Tonga_MCLK_Dependency_Record,\n\t\t\t\t\tentries, mclk_dep_table,\n\t\t\t\t\tvce_state_record->ucMCLKIndex);\n\n\tvce_state->mclk = le32_to_cpu(mclk_dep_record->ulMclk);\n\treturn 0;\n}\n\n \nint get_powerplay_table_entry_v1_0(struct pp_hwmgr *hwmgr,\n\t\tuint32_t entry_index, struct pp_power_state *power_state,\n\t\tint (*call_back_func)(struct pp_hwmgr *, void *,\n\t\t\t\tstruct pp_power_state *, void *, uint32_t))\n{\n\tint result = 0;\n\tconst ATOM_Tonga_State_Array *state_arrays;\n\tconst ATOM_Tonga_State *state_entry;\n\tconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\n\tint i, j;\n\tuint32_t flags = 0;\n\n\tPP_ASSERT_WITH_CODE((NULL != pp_table), \"Missing PowerPlay Table!\", return -1;);\n\tpower_state->classification.bios_index = entry_index;\n\n\tif (pp_table->sHeader.ucTableFormatRevision >=\n\t\t\tATOM_Tonga_TABLE_REVISION_TONGA) {\n\t\tstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)pp_table) +\n\t\t\t\tle16_to_cpu(pp_table->usStateArrayOffset));\n\n\t\tPP_ASSERT_WITH_CODE((0 < pp_table->usStateArrayOffset),\n\t\t\t\t\"Invalid PowerPlay Table State Array Offset.\", return -1);\n\t\tPP_ASSERT_WITH_CODE((0 < state_arrays->ucNumEntries),\n\t\t\t\t\"Invalid PowerPlay Table State Array.\", return -1);\n\t\tPP_ASSERT_WITH_CODE((entry_index <= state_arrays->ucNumEntries),\n\t\t\t\t\"Invalid PowerPlay Table State Array Entry.\", return -1);\n\n\t\tstate_entry = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\n\t\t\t\t\t\tATOM_Tonga_State, entries,\n\t\t\t\t\t\tstate_arrays, entry_index);\n\n\t\tresult = call_back_func(hwmgr, (void *)state_entry, power_state,\n\t\t\t\t(void *)pp_table,\n\t\t\t\tmake_classification_flags(hwmgr,\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification),\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification2)));\n\t}\n\n\tif (!result && (power_state->classification.flags &\n\t\t\tPP_StateClassificationFlag_Boot))\n\t\tresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(power_state->hardware));\n\n\thwmgr->num_vce_state_tables = i = ppt_get_num_of_vce_state_table_entries_v1_0(hwmgr);\n\n\tif ((i != 0) && (i <= AMD_MAX_VCE_LEVELS)) {\n\t\tfor (j = 0; j < i; j++)\n\t\t\tppt_get_vce_state_table_entry_v1_0(hwmgr, j, &(hwmgr->vce_states[j]), NULL, &flags);\n\t}\n\n\treturn result;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}