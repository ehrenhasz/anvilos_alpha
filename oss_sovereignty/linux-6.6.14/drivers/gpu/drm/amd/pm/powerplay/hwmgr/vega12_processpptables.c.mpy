{
  "module_name": "vega12_processpptables.c",
  "hash_id": "a9bef8db5cc11674807423e1fab8124da122a9bbd51577600a74ec9a45a5b695",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_processpptables.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"vega12/smu9_driver_if.h\"\n#include \"vega12_processpptables.h\"\n#include \"ppatomfwctrl.h\"\n#include \"atomfirmware.h\"\n#include \"pp_debug.h\"\n#include \"cgs_common.h\"\n#include \"vega12_pptable.h\"\n\nstatic void set_hw_cap(struct pp_hwmgr *hwmgr, bool enable,\n\t\tenum phm_platform_caps cap)\n{\n\tif (enable)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\n\telse\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\n}\n\nstatic const void *get_powerplay_table(struct pp_hwmgr *hwmgr)\n{\n\tint index = GetIndexIntoMasterDataTable(powerplayinfo);\n\n\tu16 size;\n\tu8 frev, crev;\n\tconst void *table_address = hwmgr->soft_pp_table;\n\n\tif (!table_address) {\n\t\ttable_address = (ATOM_Vega12_POWERPLAYTABLE *)\n\t\t\t\tsmu_atom_get_data_table(hwmgr->adev, index,\n\t\t\t\t\t\t&size, &frev, &crev);\n\n\t\thwmgr->soft_pp_table = table_address;\t \n\t\thwmgr->soft_pp_table_size = size;\n\t}\n\n\treturn table_address;\n}\n\nstatic int check_powerplay_tables(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega12_POWERPLAYTABLE *powerplay_table)\n{\n\tPP_ASSERT_WITH_CODE((powerplay_table->sHeader.format_revision >=\n\t\tATOM_VEGA12_TABLE_REVISION_VEGA12),\n\t\t\"Unsupported PPTable format!\", return -1);\n\tPP_ASSERT_WITH_CODE(powerplay_table->sHeader.structuresize > 0,\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\treturn 0;\n}\n\nstatic int set_platform_caps(struct pp_hwmgr *hwmgr, uint32_t powerplay_caps)\n{\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA12_PP_PLATFORM_CAP_POWERPLAY),\n\t\t\tPHM_PlatformCaps_PowerPlaySupport);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA12_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\n\t\t\tPHM_PlatformCaps_BiosPowerSourceControl);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA12_PP_PLATFORM_CAP_BACO),\n\t\t\tPHM_PlatformCaps_BACO);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA12_PP_PLATFORM_CAP_BAMACO),\n\t\t\t PHM_PlatformCaps_BAMACO);\n\n\treturn 0;\n}\n\nstatic int append_vbios_pptable(struct pp_hwmgr *hwmgr, PPTable_t *ppsmc_pptable)\n{\n\tstruct pp_atomfwctrl_smc_dpm_parameters smc_dpm_table;\n\n\tPP_ASSERT_WITH_CODE(\n\t\tpp_atomfwctrl_get_smc_dpm_information(hwmgr, &smc_dpm_table) == 0,\n\t\t\"[appendVbiosPPTable] Failed to retrieve Smc Dpm Table from VBIOS!\",\n\t\treturn -1);\n\n\tppsmc_pptable->Liquid1_I2C_address = smc_dpm_table.liquid1_i2c_address;\n\tppsmc_pptable->Liquid2_I2C_address = smc_dpm_table.liquid2_i2c_address;\n\tppsmc_pptable->Vr_I2C_address = smc_dpm_table.vr_i2c_address;\n\tppsmc_pptable->Plx_I2C_address = smc_dpm_table.plx_i2c_address;\n\n\tppsmc_pptable->Liquid_I2C_LineSCL = smc_dpm_table.liquid_i2c_linescl;\n\tppsmc_pptable->Liquid_I2C_LineSDA = smc_dpm_table.liquid_i2c_linesda;\n\tppsmc_pptable->Vr_I2C_LineSCL = smc_dpm_table.vr_i2c_linescl;\n\tppsmc_pptable->Vr_I2C_LineSDA = smc_dpm_table.vr_i2c_linesda;\n\n\tppsmc_pptable->Plx_I2C_LineSCL = smc_dpm_table.plx_i2c_linescl;\n\tppsmc_pptable->Plx_I2C_LineSDA = smc_dpm_table.plx_i2c_linesda;\n\tppsmc_pptable->VrSensorPresent = smc_dpm_table.vrsensorpresent;\n\tppsmc_pptable->LiquidSensorPresent = smc_dpm_table.liquidsensorpresent;\n\n\tppsmc_pptable->MaxVoltageStepGfx = smc_dpm_table.maxvoltagestepgfx;\n\tppsmc_pptable->MaxVoltageStepSoc = smc_dpm_table.maxvoltagestepsoc;\n\n\tppsmc_pptable->VddGfxVrMapping = smc_dpm_table.vddgfxvrmapping;\n\tppsmc_pptable->VddSocVrMapping = smc_dpm_table.vddsocvrmapping;\n\tppsmc_pptable->VddMem0VrMapping = smc_dpm_table.vddmem0vrmapping;\n\tppsmc_pptable->VddMem1VrMapping = smc_dpm_table.vddmem1vrmapping;\n\n\tppsmc_pptable->GfxUlvPhaseSheddingMask = smc_dpm_table.gfxulvphasesheddingmask;\n\tppsmc_pptable->SocUlvPhaseSheddingMask = smc_dpm_table.soculvphasesheddingmask;\n\n\tppsmc_pptable->GfxMaxCurrent = smc_dpm_table.gfxmaxcurrent;\n\tppsmc_pptable->GfxOffset = smc_dpm_table.gfxoffset;\n\tppsmc_pptable->Padding_TelemetryGfx = smc_dpm_table.padding_telemetrygfx;\n\n\tppsmc_pptable->SocMaxCurrent = smc_dpm_table.socmaxcurrent;\n\tppsmc_pptable->SocOffset = smc_dpm_table.socoffset;\n\tppsmc_pptable->Padding_TelemetrySoc = smc_dpm_table.padding_telemetrysoc;\n\n\tppsmc_pptable->Mem0MaxCurrent = smc_dpm_table.mem0maxcurrent;\n\tppsmc_pptable->Mem0Offset = smc_dpm_table.mem0offset;\n\tppsmc_pptable->Padding_TelemetryMem0 = smc_dpm_table.padding_telemetrymem0;\n\n\tppsmc_pptable->Mem1MaxCurrent = smc_dpm_table.mem1maxcurrent;\n\tppsmc_pptable->Mem1Offset = smc_dpm_table.mem1offset;\n\tppsmc_pptable->Padding_TelemetryMem1 = smc_dpm_table.padding_telemetrymem1;\n\n\tppsmc_pptable->AcDcGpio = smc_dpm_table.acdcgpio;\n\tppsmc_pptable->AcDcPolarity = smc_dpm_table.acdcpolarity;\n\tppsmc_pptable->VR0HotGpio = smc_dpm_table.vr0hotgpio;\n\tppsmc_pptable->VR0HotPolarity = smc_dpm_table.vr0hotpolarity;\n\n\tppsmc_pptable->VR1HotGpio = smc_dpm_table.vr1hotgpio;\n\tppsmc_pptable->VR1HotPolarity = smc_dpm_table.vr1hotpolarity;\n\tppsmc_pptable->Padding1 = smc_dpm_table.padding1;\n\tppsmc_pptable->Padding2 = smc_dpm_table.padding2;\n\n\tppsmc_pptable->LedPin0 = smc_dpm_table.ledpin0;\n\tppsmc_pptable->LedPin1 = smc_dpm_table.ledpin1;\n\tppsmc_pptable->LedPin2 = smc_dpm_table.ledpin2;\n\n\tppsmc_pptable->PllGfxclkSpreadEnabled = smc_dpm_table.pllgfxclkspreadenabled;\n\tppsmc_pptable->PllGfxclkSpreadPercent = smc_dpm_table.pllgfxclkspreadpercent;\n\tppsmc_pptable->PllGfxclkSpreadFreq = smc_dpm_table.pllgfxclkspreadfreq;\n\n\tppsmc_pptable->UclkSpreadEnabled = 0;\n\tppsmc_pptable->UclkSpreadPercent = smc_dpm_table.uclkspreadpercent;\n\tppsmc_pptable->UclkSpreadFreq = smc_dpm_table.uclkspreadfreq;\n\n\tppsmc_pptable->SocclkSpreadEnabled = 0;\n\tppsmc_pptable->SocclkSpreadPercent = smc_dpm_table.socclkspreadpercent;\n\tppsmc_pptable->SocclkSpreadFreq = smc_dpm_table.socclkspreadfreq;\n\n\tppsmc_pptable->AcgGfxclkSpreadEnabled = smc_dpm_table.acggfxclkspreadenabled;\n\tppsmc_pptable->AcgGfxclkSpreadPercent = smc_dpm_table.acggfxclkspreadpercent;\n\tppsmc_pptable->AcgGfxclkSpreadFreq = smc_dpm_table.acggfxclkspreadfreq;\n\n\tppsmc_pptable->Vr2_I2C_address = smc_dpm_table.Vr2_I2C_address;\n\n\tppsmc_pptable->Vr2_I2C_address = smc_dpm_table.Vr2_I2C_address;\n\n\treturn 0;\n}\n\n#define VEGA12_ENGINECLOCK_HARDMAX 198000\nstatic int init_powerplay_table_information(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega12_POWERPLAYTABLE *powerplay_table)\n{\n\tstruct phm_ppt_v3_information *pptable_information =\n\t\t(struct phm_ppt_v3_information *)hwmgr->pptable;\n\tuint32_t disable_power_control = 0;\n\n\thwmgr->thermal_controller.ucType = powerplay_table->ucThermalControllerType;\n\tpptable_information->uc_thermal_controller_type = powerplay_table->ucThermalControllerType;\n\n\tset_hw_cap(hwmgr,\n\t\tATOM_VEGA12_PP_THERMALCONTROLLER_NONE != hwmgr->thermal_controller.ucType,\n\t\tPHM_PlatformCaps_ThermalController);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);\n\n\tif (le32_to_cpu(powerplay_table->ODSettingsMax[ATOM_VEGA12_ODSETTING_GFXCLKFMAX]) > VEGA12_ENGINECLOCK_HARDMAX)\n\t\thwmgr->platform_descriptor.overdriveLimit.engineClock = VEGA12_ENGINECLOCK_HARDMAX;\n\telse\n\t\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\t\tle32_to_cpu(powerplay_table->ODSettingsMax[ATOM_VEGA12_ODSETTING_GFXCLKFMAX]);\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock =\n\t\tle32_to_cpu(powerplay_table->ODSettingsMax[ATOM_VEGA12_ODSETTING_UCLKFMAX]);\n\n\tphm_copy_overdrive_settings_limits_array(hwmgr,\n\t\t\t\t\t\t &pptable_information->od_settings_max,\n\t\t\t\t\t\t powerplay_table->ODSettingsMax,\n\t\t\t\t\t\t ATOM_VEGA12_ODSETTING_COUNT);\n\tphm_copy_overdrive_settings_limits_array(hwmgr,\n\t\t\t\t\t\t &pptable_information->od_settings_min,\n\t\t\t\t\t\t powerplay_table->ODSettingsMin,\n\t\t\t\t\t\t ATOM_VEGA12_ODSETTING_COUNT);\n\n\t \n\n\tif (hwmgr->platform_descriptor.overdriveLimit.engineClock > 0\n\t\t&& hwmgr->platform_descriptor.overdriveLimit.memoryClock > 0)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_ACOverdriveSupport);\n\n\tpptable_information->us_small_power_limit1 = le16_to_cpu(powerplay_table->usSmallPowerLimit1);\n\tpptable_information->us_small_power_limit2 = le16_to_cpu(powerplay_table->usSmallPowerLimit2);\n\tpptable_information->us_boost_power_limit = le16_to_cpu(powerplay_table->usBoostPowerLimit);\n\tpptable_information->us_od_turbo_power_limit = le16_to_cpu(powerplay_table->usODTurboPowerLimit);\n\tpptable_information->us_od_powersave_power_limit = le16_to_cpu(powerplay_table->usODPowerSavePowerLimit);\n\n\tpptable_information->us_software_shutdown_temp = le16_to_cpu(powerplay_table->usSoftwareShutdownTemp);\n\n\thwmgr->platform_descriptor.TDPODLimit = le32_to_cpu(powerplay_table->ODSettingsMax[ATOM_VEGA12_ODSETTING_POWERPERCENTAGE]);\n\n\tdisable_power_control = 0;\n\tif (!disable_power_control) {\n\t\t \n\t\tif (hwmgr->platform_descriptor.TDPODLimit)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_PowerControl);\n\t}\n\n\tphm_copy_clock_limits_array(hwmgr, &pptable_information->power_saving_clock_max, powerplay_table->PowerSavingClockMax, ATOM_VEGA12_PPCLOCK_COUNT);\n\tphm_copy_clock_limits_array(hwmgr, &pptable_information->power_saving_clock_min, powerplay_table->PowerSavingClockMin, ATOM_VEGA12_PPCLOCK_COUNT);\n\n\tpptable_information->smc_pptable = kmemdup(&(powerplay_table->smcPPTable),\n\t\t\t\t\t\t   sizeof(PPTable_t), GFP_KERNEL);\n\tif (pptable_information->smc_pptable == NULL)\n\t\treturn -ENOMEM;\n\n\treturn append_vbios_pptable(hwmgr, (pptable_information->smc_pptable));\n}\n\nstatic int vega12_pp_tables_initialize(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tconst ATOM_Vega12_POWERPLAYTABLE *powerplay_table;\n\n\thwmgr->pptable = kzalloc(sizeof(struct phm_ppt_v3_information), GFP_KERNEL);\n\tPP_ASSERT_WITH_CODE((hwmgr->pptable != NULL),\n\t\t\"Failed to allocate hwmgr->pptable!\", return -ENOMEM);\n\n\tpowerplay_table = get_powerplay_table(hwmgr);\n\tPP_ASSERT_WITH_CODE((powerplay_table != NULL),\n\t\t\"Missing PowerPlay Table!\", return -1);\n\n\tresult = check_powerplay_tables(hwmgr, powerplay_table);\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\"check_powerplay_tables failed\", return result);\n\n\tresult = set_platform_caps(hwmgr,\n\t\t\tle32_to_cpu(powerplay_table->ulPlatformCaps));\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\"set_platform_caps failed\", return result);\n\n\tresult = init_powerplay_table_information(hwmgr, powerplay_table);\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\"init_powerplay_table_information failed\", return result);\n\n\treturn result;\n}\n\nstatic int vega12_pp_tables_uninitialize(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v3_information *pp_table_info =\n\t\t\t(struct phm_ppt_v3_information *)(hwmgr->pptable);\n\n\tkfree(pp_table_info->power_saving_clock_max);\n\tpp_table_info->power_saving_clock_max = NULL;\n\n\tkfree(pp_table_info->power_saving_clock_min);\n\tpp_table_info->power_saving_clock_min = NULL;\n\n\tkfree(pp_table_info->od_settings_max);\n\tpp_table_info->od_settings_max = NULL;\n\n\tkfree(pp_table_info->od_settings_min);\n\tpp_table_info->od_settings_min = NULL;\n\n\tkfree(pp_table_info->smc_pptable);\n\tpp_table_info->smc_pptable = NULL;\n\n\tkfree(hwmgr->pptable);\n\thwmgr->pptable = NULL;\n\n\treturn 0;\n}\n\nconst struct pp_table_func vega12_pptable_funcs = {\n\t.pptable_init = vega12_pp_tables_initialize,\n\t.pptable_fini = vega12_pp_tables_uninitialize,\n};\n\n#if 0\nstatic uint32_t make_classification_flags(struct pp_hwmgr *hwmgr,\n\t\tuint16_t classification, uint16_t classification2)\n{\n\tuint32_t result = 0;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\tresult |= PP_StateClassificationFlag_Boot;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\tresult |= PP_StateClassificationFlag_Thermal;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\n\t\tresult |= PP_StateClassificationFlag_Rest;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\n\t\tresult |= PP_StateClassificationFlag_Forced;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\tresult |= PP_StateClassificationFlag_ACPI;\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\n\n\treturn result;\n}\n\nint vega12_get_powerplay_table_entry(struct pp_hwmgr *hwmgr,\n\t\tuint32_t entry_index, struct pp_power_state *power_state,\n\t\tint (*call_back_func)(struct pp_hwmgr *, void *,\n\t\t\t\tstruct pp_power_state *, void *, uint32_t))\n{\n\tint result = 0;\n\tconst ATOM_Vega12_State_Array *state_arrays;\n\tconst ATOM_Vega12_State *state_entry;\n\tconst ATOM_Vega12_POWERPLAYTABLE *pp_table =\n\t\t\tget_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE(pp_table, \"Missing PowerPlay Table!\",\n\t\t\treturn -1;);\n\tpower_state->classification.bios_index = entry_index;\n\n\tif (pp_table->sHeader.format_revision >=\n\t\t\tATOM_Vega12_TABLE_REVISION_VEGA12) {\n\t\tstate_arrays = (ATOM_Vega12_State_Array *)\n\t\t\t\t(((unsigned long)pp_table) +\n\t\t\t\tle16_to_cpu(pp_table->usStateArrayOffset));\n\n\t\tPP_ASSERT_WITH_CODE(pp_table->usStateArrayOffset > 0,\n\t\t\t\t\"Invalid PowerPlay Table State Array Offset.\",\n\t\t\t\treturn -1);\n\t\tPP_ASSERT_WITH_CODE(state_arrays->ucNumEntries > 0,\n\t\t\t\t\"Invalid PowerPlay Table State Array.\",\n\t\t\t\treturn -1);\n\t\tPP_ASSERT_WITH_CODE((entry_index <= state_arrays->ucNumEntries),\n\t\t\t\t\"Invalid PowerPlay Table State Array Entry.\",\n\t\t\t\treturn -1);\n\n\t\tstate_entry = &(state_arrays->states[entry_index]);\n\n\t\tresult = call_back_func(hwmgr, (void *)state_entry, power_state,\n\t\t\t\t(void *)pp_table,\n\t\t\t\tmake_classification_flags(hwmgr,\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification),\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification2)));\n\t}\n\n\tif (!result && (power_state->classification.flags &\n\t\t\tPP_StateClassificationFlag_Boot))\n\t\tresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(power_state->hardware));\n\n\treturn result;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}