{
  "module_name": "vega10_processpptables.c",
  "hash_id": "17d37db7487f5005aa0e9fd926944e763130ec952d5844e099fad54f3d72a762",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_processpptables.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"vega10_processpptables.h\"\n#include \"ppatomfwctrl.h\"\n#include \"atomfirmware.h\"\n#include \"pp_debug.h\"\n#include \"cgs_common.h\"\n#include \"vega10_pptable.h\"\n\n#define NUM_DSPCLK_LEVELS 8\n#define VEGA10_ENGINECLOCK_HARDMAX 198000\n\nstatic void set_hw_cap(struct pp_hwmgr *hwmgr, bool enable,\n\t\tenum phm_platform_caps cap)\n{\n\tif (enable)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\n\telse\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\n}\n\nstatic const void *get_powerplay_table(struct pp_hwmgr *hwmgr)\n{\n\tint index = GetIndexIntoMasterDataTable(powerplayinfo);\n\n\tu16 size;\n\tu8 frev, crev;\n\tconst void *table_address = hwmgr->soft_pp_table;\n\n\tif (!table_address) {\n\t\ttable_address = (ATOM_Vega10_POWERPLAYTABLE *)\n\t\t\t\tsmu_atom_get_data_table(hwmgr->adev, index,\n\t\t\t\t\t\t&size, &frev, &crev);\n\n\t\thwmgr->soft_pp_table = table_address;\t \n\t\thwmgr->soft_pp_table_size = size;\n\t}\n\n\treturn table_address;\n}\n\nstatic int check_powerplay_tables(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table)\n{\n\tconst ATOM_Vega10_State_Array *state_arrays;\n\n\tstate_arrays = (ATOM_Vega10_State_Array *)(((unsigned long)powerplay_table) +\n\t\tle16_to_cpu(powerplay_table->usStateArrayOffset));\n\n\tPP_ASSERT_WITH_CODE((powerplay_table->sHeader.format_revision >=\n\t\t\tATOM_Vega10_TABLE_REVISION_VEGA10),\n\t\t\"Unsupported PPTable format!\", return -1);\n\tPP_ASSERT_WITH_CODE(powerplay_table->usStateArrayOffset,\n\t\t\"State table is not set!\", return -1);\n\tPP_ASSERT_WITH_CODE(powerplay_table->sHeader.structuresize > 0,\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\tPP_ASSERT_WITH_CODE(state_arrays->ucNumEntries > 0,\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\treturn 0;\n}\n\nstatic int set_platform_caps(struct pp_hwmgr *hwmgr, uint32_t powerplay_caps)\n{\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA10_PP_PLATFORM_CAP_POWERPLAY),\n\t\t\tPHM_PlatformCaps_PowerPlaySupport);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA10_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\n\t\t\tPHM_PlatformCaps_BiosPowerSourceControl);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA10_PP_PLATFORM_CAP_HARDWAREDC),\n\t\t\tPHM_PlatformCaps_AutomaticDCTransition);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA10_PP_PLATFORM_CAP_BACO),\n\t\t\tPHM_PlatformCaps_BACO);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (powerplay_caps & ATOM_VEGA10_PP_PLATFORM_COMBINE_PCC_WITH_THERMAL_SIGNAL),\n\t\t\tPHM_PlatformCaps_CombinePCCWithThermalSignal);\n\n\treturn 0;\n}\n\nstatic int init_thermal_controller(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table)\n{\n\tconst ATOM_Vega10_Thermal_Controller *thermal_controller;\n\tconst Vega10_PPTable_Generic_SubTable_Header *header;\n\tconst ATOM_Vega10_Fan_Table *fan_table_v1;\n\tconst ATOM_Vega10_Fan_Table_V2 *fan_table_v2;\n\tconst ATOM_Vega10_Fan_Table_V3 *fan_table_v3;\n\n\tthermal_controller = (ATOM_Vega10_Thermal_Controller *)\n\t\t\t(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usThermalControllerOffset));\n\n\tPP_ASSERT_WITH_CODE((powerplay_table->usThermalControllerOffset != 0),\n\t\t\t\"Thermal controller table not set!\", return -EINVAL);\n\n\thwmgr->thermal_controller.ucType = thermal_controller->ucType;\n\thwmgr->thermal_controller.ucI2cLine = thermal_controller->ucI2cLine;\n\thwmgr->thermal_controller.ucI2cAddress = thermal_controller->ucI2cAddress;\n\n\thwmgr->thermal_controller.fanInfo.bNoFan =\n\t\t\t(0 != (thermal_controller->ucFanParameters &\n\t\t\tATOM_VEGA10_PP_FANPARAMETERS_NOFAN));\n\n\thwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\n\t\t\tthermal_controller->ucFanParameters &\n\t\t\tATOM_VEGA10_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\n\thwmgr->thermal_controller.fanInfo.ulMinRPM =\n\t\t\tthermal_controller->ucFanMinRPM * 100UL;\n\thwmgr->thermal_controller.fanInfo.ulMaxRPM =\n\t\t\tthermal_controller->ucFanMaxRPM * 100UL;\n\n\thwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay\n\t\t\t= 100000;\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\tATOM_VEGA10_PP_THERMALCONTROLLER_NONE != hwmgr->thermal_controller.ucType,\n\t\t\tPHM_PlatformCaps_ThermalController);\n\n\tif (!powerplay_table->usFanTableOffset)\n\t\treturn 0;\n\n\theader = (const Vega10_PPTable_Generic_SubTable_Header *)\n\t\t\t(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usFanTableOffset));\n\n\tif (header->ucRevId == 10) {\n\t\tfan_table_v1 = (ATOM_Vega10_Fan_Table *)header;\n\n\t\tPP_ASSERT_WITH_CODE((fan_table_v1->ucRevId >= 8),\n\t\t\t\t\"Invalid Input Fan Table!\", return -EINVAL);\n\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usMaxFanRPM =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanRPMMax);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanRPMMaxLimit =\n\t\t\t\tle16_to_cpu(fan_table_v1->usThrottlingRPM);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanAcousticLimit);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax =\n\t\t\t\tle16_to_cpu(fan_table_v1->usTargetTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin =\n\t\t\t\tle16_to_cpu(fan_table_v1->usMinimumPWMLimit);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulTargetGfxClk =\n\t\t\t\tle16_to_cpu(fan_table_v1->usTargetGfxClk);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainEdge);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainHotspot);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainLiquid);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainVrVddc);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainVrMvdd);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainPlx);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanGainHbm);\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM =\n\t\t\t\tfan_table_v1->ucEnableZeroRPM;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStopTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanStopTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStartTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v1->usFanStartTemperature);\n\t} else if (header->ucRevId == 0xb) {\n\t\tfan_table_v2 = (ATOM_Vega10_Fan_Table_V2 *)header;\n\n\t\thwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\n\t\t\t\tfan_table_v2->ucFanParameters & ATOM_VEGA10_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\t\thwmgr->thermal_controller.fanInfo.ulMinRPM = fan_table_v2->ucFanMinRPM * 100UL;\n\t\thwmgr->thermal_controller.fanInfo.ulMaxRPM = fan_table_v2->ucFanMaxRPM * 100UL;\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usMaxFanRPM =\n\t\t\t\tfan_table_v2->ucFanMaxRPM * 100UL;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanRPMMaxLimit =\n\t\t\t\tle16_to_cpu(fan_table_v2->usThrottlingRPM);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanAcousticLimitRpm);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax =\n\t\t\t\tle16_to_cpu(fan_table_v2->usTargetTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin =\n\t\t\t\tle16_to_cpu(fan_table_v2->usMinimumPWMLimit);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulTargetGfxClk =\n\t\t\t\tle16_to_cpu(fan_table_v2->usTargetGfxClk);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainEdge);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainHotspot);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainLiquid);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainVrVddc);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainVrMvdd);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainPlx);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanGainHbm);\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM =\n\t\t\t\tfan_table_v2->ucEnableZeroRPM;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStopTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanStopTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStartTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v2->usFanStartTemperature);\n\t} else if (header->ucRevId > 0xb) {\n\t\tfan_table_v3 = (ATOM_Vega10_Fan_Table_V3 *)header;\n\n\t\thwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\n\t\t\t\tfan_table_v3->ucFanParameters & ATOM_VEGA10_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\t\thwmgr->thermal_controller.fanInfo.ulMinRPM = fan_table_v3->ucFanMinRPM * 100UL;\n\t\thwmgr->thermal_controller.fanInfo.ulMaxRPM = fan_table_v3->ucFanMaxRPM * 100UL;\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanOutputSensitivity);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usMaxFanRPM =\n\t\t\t\tfan_table_v3->ucFanMaxRPM * 100UL;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanRPMMaxLimit =\n\t\t\t\tle16_to_cpu(fan_table_v3->usThrottlingRPM);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanAcousticLimitRpm);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax =\n\t\t\t\tle16_to_cpu(fan_table_v3->usTargetTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin =\n\t\t\t\tle16_to_cpu(fan_table_v3->usMinimumPWMLimit);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ulTargetGfxClk =\n\t\t\t\tle16_to_cpu(fan_table_v3->usTargetGfxClk);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainEdge);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainHotspot);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainLiquid);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainVrVddc);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainVrMvdd);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainPlx);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanGainHbm);\n\n\t\thwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM =\n\t\t\t\tfan_table_v3->ucEnableZeroRPM;\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStopTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanStopTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usZeroRPMStartTemperature =\n\t\t\t\tle16_to_cpu(fan_table_v3->usFanStartTemperature);\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usMGpuThrottlingRPMLimit =\n\t\t\t\tle16_to_cpu(fan_table_v3->usMGpuThrottlingRPM);\n\t}\n\n\treturn 0;\n}\n\nstatic int init_over_drive_limits(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table)\n{\n\tconst ATOM_Vega10_GFXCLK_Dependency_Table *gfxclk_dep_table =\n\t\t\t(const ATOM_Vega10_GFXCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usGfxclkDependencyTableOffset));\n\tbool is_acg_enabled = false;\n\tATOM_Vega10_GFXCLK_Dependency_Record_V2 *patom_record_v2;\n\n\tif (gfxclk_dep_table->ucRevId == 1) {\n\t\tpatom_record_v2 =\n\t\t\t(ATOM_Vega10_GFXCLK_Dependency_Record_V2 *)gfxclk_dep_table->entries;\n\t\tis_acg_enabled =\n\t\t\t(bool)patom_record_v2[gfxclk_dep_table->ucNumEntries-1].ucACGEnable;\n\t}\n\n\tif (powerplay_table->ulMaxODEngineClock > VEGA10_ENGINECLOCK_HARDMAX &&\n\t\t!is_acg_enabled)\n\t\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\t\tVEGA10_ENGINECLOCK_HARDMAX;\n\telse\n\t\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\t\tle32_to_cpu(powerplay_table->ulMaxODEngineClock);\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock =\n\t\t\tle32_to_cpu(powerplay_table->ulMaxODMemoryClock);\n\n\thwmgr->platform_descriptor.minOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.maxOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.overdriveVDDCStep = 0;\n\n\treturn 0;\n}\n\nstatic int get_mm_clock_voltage_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_mm_clock_voltage_dependency_table **vega10_mm_table,\n\t\tconst ATOM_Vega10_MM_Dependency_Table *mm_dependency_table)\n{\n\tuint32_t i;\n\tconst ATOM_Vega10_MM_Dependency_Record *mm_dependency_record;\n\tphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table;\n\n\tPP_ASSERT_WITH_CODE((mm_dependency_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tmm_table = kzalloc(struct_size(mm_table, entries, mm_dependency_table->ucNumEntries),\n\t\t\t   GFP_KERNEL);\n\tif (!mm_table)\n\t\treturn -ENOMEM;\n\n\tmm_table->count = mm_dependency_table->ucNumEntries;\n\n\tfor (i = 0; i < mm_dependency_table->ucNumEntries; i++) {\n\t\tmm_dependency_record = &mm_dependency_table->entries[i];\n\t\tmm_table->entries[i].vddcInd = mm_dependency_record->ucVddcInd;\n\t\tmm_table->entries[i].samclock =\n\t\t\t\tle32_to_cpu(mm_dependency_record->ulPSPClk);\n\t\tmm_table->entries[i].eclk = le32_to_cpu(mm_dependency_record->ulEClk);\n\t\tmm_table->entries[i].vclk = le32_to_cpu(mm_dependency_record->ulVClk);\n\t\tmm_table->entries[i].dclk = le32_to_cpu(mm_dependency_record->ulDClk);\n\t}\n\n\t*vega10_mm_table = mm_table;\n\n\treturn 0;\n}\n\nstatic void get_scl_sda_value(uint8_t line, uint8_t *scl, uint8_t *sda)\n{\n\tswitch (line) {\n\tcase Vega10_I2CLineID_DDC1:\n\t\t*scl = Vega10_I2C_DDC1CLK;\n\t\t*sda = Vega10_I2C_DDC1DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDC2:\n\t\t*scl = Vega10_I2C_DDC2CLK;\n\t\t*sda = Vega10_I2C_DDC2DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDC3:\n\t\t*scl = Vega10_I2C_DDC3CLK;\n\t\t*sda = Vega10_I2C_DDC3DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDC4:\n\t\t*scl = Vega10_I2C_DDC4CLK;\n\t\t*sda = Vega10_I2C_DDC4DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDC5:\n\t\t*scl = Vega10_I2C_DDC5CLK;\n\t\t*sda = Vega10_I2C_DDC5DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDC6:\n\t\t*scl = Vega10_I2C_DDC6CLK;\n\t\t*sda = Vega10_I2C_DDC6DATA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_SCLSDA:\n\t\t*scl = Vega10_I2C_SCL;\n\t\t*sda = Vega10_I2C_SDA;\n\t\tbreak;\n\tcase Vega10_I2CLineID_DDCVGA:\n\t\t*scl = Vega10_I2C_DDCVGACLK;\n\t\t*sda = Vega10_I2C_DDCVGADATA;\n\t\tbreak;\n\tdefault:\n\t\t*scl = 0;\n\t\t*sda = 0;\n\t\tbreak;\n\t}\n}\n\nstatic int get_tdp_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_tdp_table **info_tdp_table,\n\t\tconst Vega10_PPTable_Generic_SubTable_Header *table)\n{\n\tuint32_t table_size;\n\tstruct phm_tdp_table *tdp_table;\n\tuint8_t scl;\n\tuint8_t sda;\n\tconst ATOM_Vega10_PowerTune_Table *power_tune_table;\n\tconst ATOM_Vega10_PowerTune_Table_V2 *power_tune_table_v2;\n\tconst ATOM_Vega10_PowerTune_Table_V3 *power_tune_table_v3;\n\n\ttable_size = sizeof(uint32_t) + sizeof(struct phm_tdp_table);\n\n\ttdp_table = kzalloc(table_size, GFP_KERNEL);\n\n\tif (!tdp_table)\n\t\treturn -ENOMEM;\n\n\tif (table->ucRevId == 5) {\n\t\tpower_tune_table = (ATOM_Vega10_PowerTune_Table *)table;\n\t\ttdp_table->usMaximumPowerDeliveryLimit = le16_to_cpu(power_tune_table->usSocketPowerLimit);\n\t\ttdp_table->usTDC = le16_to_cpu(power_tune_table->usTdcLimit);\n\t\ttdp_table->usEDCLimit = le16_to_cpu(power_tune_table->usEdcLimit);\n\t\ttdp_table->usSoftwareShutdownTemp =\n\t\t\t\tle16_to_cpu(power_tune_table->usSoftwareShutdownTemp);\n\t\ttdp_table->usTemperatureLimitTedge =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitTedge);\n\t\ttdp_table->usTemperatureLimitHotspot =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitHotSpot);\n\t\ttdp_table->usTemperatureLimitLiquid1 =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitLiquid1);\n\t\ttdp_table->usTemperatureLimitLiquid2 =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitLiquid2);\n\t\ttdp_table->usTemperatureLimitHBM =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitHBM);\n\t\ttdp_table->usTemperatureLimitVrVddc =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitVrSoc);\n\t\ttdp_table->usTemperatureLimitVrMvdd =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitVrMem);\n\t\ttdp_table->usTemperatureLimitPlx =\n\t\t\t\tle16_to_cpu(power_tune_table->usTemperatureLimitPlx);\n\t\ttdp_table->ucLiquid1_I2C_address = power_tune_table->ucLiquid1_I2C_address;\n\t\ttdp_table->ucLiquid2_I2C_address = power_tune_table->ucLiquid2_I2C_address;\n\t\ttdp_table->ucLiquid_I2C_Line = power_tune_table->ucLiquid_I2C_LineSCL;\n\t\ttdp_table->ucLiquid_I2C_LineSDA = power_tune_table->ucLiquid_I2C_LineSDA;\n\t\ttdp_table->ucVr_I2C_address = power_tune_table->ucVr_I2C_address;\n\t\ttdp_table->ucVr_I2C_Line = power_tune_table->ucVr_I2C_LineSCL;\n\t\ttdp_table->ucVr_I2C_LineSDA = power_tune_table->ucVr_I2C_LineSDA;\n\t\ttdp_table->ucPlx_I2C_address = power_tune_table->ucPlx_I2C_address;\n\t\ttdp_table->ucPlx_I2C_Line = power_tune_table->ucPlx_I2C_LineSCL;\n\t\ttdp_table->ucPlx_I2C_LineSDA = power_tune_table->ucPlx_I2C_LineSDA;\n\t\thwmgr->platform_descriptor.LoadLineSlope = le16_to_cpu(power_tune_table->usLoadLineResistance);\n\t} else if (table->ucRevId == 6) {\n\t\tpower_tune_table_v2 = (ATOM_Vega10_PowerTune_Table_V2 *)table;\n\t\ttdp_table->usMaximumPowerDeliveryLimit = le16_to_cpu(power_tune_table_v2->usSocketPowerLimit);\n\t\ttdp_table->usTDC = le16_to_cpu(power_tune_table_v2->usTdcLimit);\n\t\ttdp_table->usEDCLimit = le16_to_cpu(power_tune_table_v2->usEdcLimit);\n\t\ttdp_table->usSoftwareShutdownTemp =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usSoftwareShutdownTemp);\n\t\ttdp_table->usTemperatureLimitTedge =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitTedge);\n\t\ttdp_table->usTemperatureLimitHotspot =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitHotSpot);\n\t\ttdp_table->usTemperatureLimitLiquid1 =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitLiquid1);\n\t\ttdp_table->usTemperatureLimitLiquid2 =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitLiquid2);\n\t\ttdp_table->usTemperatureLimitHBM =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitHBM);\n\t\ttdp_table->usTemperatureLimitVrVddc =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitVrSoc);\n\t\ttdp_table->usTemperatureLimitVrMvdd =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitVrMem);\n\t\ttdp_table->usTemperatureLimitPlx =\n\t\t\t\tle16_to_cpu(power_tune_table_v2->usTemperatureLimitPlx);\n\t\ttdp_table->ucLiquid1_I2C_address = power_tune_table_v2->ucLiquid1_I2C_address;\n\t\ttdp_table->ucLiquid2_I2C_address = power_tune_table_v2->ucLiquid2_I2C_address;\n\n\t\tget_scl_sda_value(power_tune_table_v2->ucLiquid_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucLiquid_I2C_Line = scl;\n\t\ttdp_table->ucLiquid_I2C_LineSDA = sda;\n\n\t\ttdp_table->ucVr_I2C_address = power_tune_table_v2->ucVr_I2C_address;\n\n\t\tget_scl_sda_value(power_tune_table_v2->ucVr_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucVr_I2C_Line = scl;\n\t\ttdp_table->ucVr_I2C_LineSDA = sda;\n\t\ttdp_table->ucPlx_I2C_address = power_tune_table_v2->ucPlx_I2C_address;\n\n\t\tget_scl_sda_value(power_tune_table_v2->ucPlx_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucPlx_I2C_Line = scl;\n\t\ttdp_table->ucPlx_I2C_LineSDA = sda;\n\n\t\thwmgr->platform_descriptor.LoadLineSlope =\n\t\t\t\t\tle16_to_cpu(power_tune_table_v2->usLoadLineResistance);\n\t} else {\n\t\tpower_tune_table_v3 = (ATOM_Vega10_PowerTune_Table_V3 *)table;\n\t\ttdp_table->usMaximumPowerDeliveryLimit   = le16_to_cpu(power_tune_table_v3->usSocketPowerLimit);\n\t\ttdp_table->usTDC                         = le16_to_cpu(power_tune_table_v3->usTdcLimit);\n\t\ttdp_table->usEDCLimit                    = le16_to_cpu(power_tune_table_v3->usEdcLimit);\n\t\ttdp_table->usSoftwareShutdownTemp        = le16_to_cpu(power_tune_table_v3->usSoftwareShutdownTemp);\n\t\ttdp_table->usTemperatureLimitTedge       = le16_to_cpu(power_tune_table_v3->usTemperatureLimitTedge);\n\t\ttdp_table->usTemperatureLimitHotspot     = le16_to_cpu(power_tune_table_v3->usTemperatureLimitHotSpot);\n\t\ttdp_table->usTemperatureLimitLiquid1     = le16_to_cpu(power_tune_table_v3->usTemperatureLimitLiquid1);\n\t\ttdp_table->usTemperatureLimitLiquid2     = le16_to_cpu(power_tune_table_v3->usTemperatureLimitLiquid2);\n\t\ttdp_table->usTemperatureLimitHBM         = le16_to_cpu(power_tune_table_v3->usTemperatureLimitHBM);\n\t\ttdp_table->usTemperatureLimitVrVddc      = le16_to_cpu(power_tune_table_v3->usTemperatureLimitVrSoc);\n\t\ttdp_table->usTemperatureLimitVrMvdd      = le16_to_cpu(power_tune_table_v3->usTemperatureLimitVrMem);\n\t\ttdp_table->usTemperatureLimitPlx         = le16_to_cpu(power_tune_table_v3->usTemperatureLimitPlx);\n\t\ttdp_table->ucLiquid1_I2C_address         = power_tune_table_v3->ucLiquid1_I2C_address;\n\t\ttdp_table->ucLiquid2_I2C_address         = power_tune_table_v3->ucLiquid2_I2C_address;\n\t\ttdp_table->usBoostStartTemperature       = le16_to_cpu(power_tune_table_v3->usBoostStartTemperature);\n\t\ttdp_table->usBoostStopTemperature        = le16_to_cpu(power_tune_table_v3->usBoostStopTemperature);\n\t\ttdp_table->ulBoostClock                  = le32_to_cpu(power_tune_table_v3->ulBoostClock);\n\n\t\tget_scl_sda_value(power_tune_table_v3->ucLiquid_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucLiquid_I2C_Line             = scl;\n\t\ttdp_table->ucLiquid_I2C_LineSDA          = sda;\n\n\t\ttdp_table->ucVr_I2C_address              = power_tune_table_v3->ucVr_I2C_address;\n\n\t\tget_scl_sda_value(power_tune_table_v3->ucVr_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucVr_I2C_Line                 = scl;\n\t\ttdp_table->ucVr_I2C_LineSDA              = sda;\n\n\t\ttdp_table->ucPlx_I2C_address             = power_tune_table_v3->ucPlx_I2C_address;\n\n\t\tget_scl_sda_value(power_tune_table_v3->ucPlx_I2C_Line, &scl, &sda);\n\n\t\ttdp_table->ucPlx_I2C_Line                = scl;\n\t\ttdp_table->ucPlx_I2C_LineSDA             = sda;\n\n\t\thwmgr->platform_descriptor.LoadLineSlope =\n\t\t\t\t\tle16_to_cpu(power_tune_table_v3->usLoadLineResistance);\n\t}\n\n\t*info_tdp_table = tdp_table;\n\n\treturn 0;\n}\n\nstatic int get_socclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table **pp_vega10_clk_dep_table,\n\t\tconst ATOM_Vega10_SOCCLK_Dependency_Table *clk_dep_table)\n{\n\tuint32_t i;\n\tphm_ppt_v1_clock_voltage_dependency_table *clk_table;\n\n\tPP_ASSERT_WITH_CODE(clk_dep_table->ucNumEntries,\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tclk_table = kzalloc(struct_size(clk_table, entries, clk_dep_table->ucNumEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn -ENOMEM;\n\n\tclk_table->count = (uint32_t)clk_dep_table->ucNumEntries;\n\n\tfor (i = 0; i < clk_dep_table->ucNumEntries; i++) {\n\t\tclk_table->entries[i].vddInd =\n\t\t\t\tclk_dep_table->entries[i].ucVddInd;\n\t\tclk_table->entries[i].clk =\n\t\t\t\tle32_to_cpu(clk_dep_table->entries[i].ulClk);\n\t}\n\n\t*pp_vega10_clk_dep_table = clk_table;\n\n\treturn 0;\n}\n\nstatic int get_mclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table **pp_vega10_mclk_dep_table,\n\t\tconst ATOM_Vega10_MCLK_Dependency_Table *mclk_dep_table)\n{\n\tuint32_t i;\n\tphm_ppt_v1_clock_voltage_dependency_table *mclk_table;\n\n\tPP_ASSERT_WITH_CODE(mclk_dep_table->ucNumEntries,\n\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tmclk_table = kzalloc(struct_size(mclk_table, entries, mclk_dep_table->ucNumEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!mclk_table)\n\t\treturn -ENOMEM;\n\n\tmclk_table->count = (uint32_t)mclk_dep_table->ucNumEntries;\n\n\tfor (i = 0; i < mclk_dep_table->ucNumEntries; i++) {\n\t\tmclk_table->entries[i].vddInd =\n\t\t\t\tmclk_dep_table->entries[i].ucVddInd;\n\t\tmclk_table->entries[i].vddciInd =\n\t\t\t\tmclk_dep_table->entries[i].ucVddciInd;\n\t\tmclk_table->entries[i].mvddInd =\n\t\t\t\tmclk_dep_table->entries[i].ucVddMemInd;\n\t\tmclk_table->entries[i].clk =\n\t\t\t\tle32_to_cpu(mclk_dep_table->entries[i].ulMemClk);\n\t}\n\n\t*pp_vega10_mclk_dep_table = mclk_table;\n\n\treturn 0;\n}\n\nstatic int get_gfxclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t**pp_vega10_clk_dep_table,\n\t\tconst ATOM_Vega10_GFXCLK_Dependency_Table *clk_dep_table)\n{\n\tuint32_t i;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t\t*clk_table;\n\tATOM_Vega10_GFXCLK_Dependency_Record_V2 *patom_record_v2;\n\n\tPP_ASSERT_WITH_CODE((clk_dep_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tclk_table = kzalloc(struct_size(clk_table, entries, clk_dep_table->ucNumEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn -ENOMEM;\n\n\tclk_table->count = clk_dep_table->ucNumEntries;\n\n\tif (clk_dep_table->ucRevId == 0) {\n\t\tfor (i = 0; i < clk_table->count; i++) {\n\t\t\tclk_table->entries[i].vddInd =\n\t\t\t\tclk_dep_table->entries[i].ucVddInd;\n\t\t\tclk_table->entries[i].clk =\n\t\t\t\tle32_to_cpu(clk_dep_table->entries[i].ulClk);\n\t\t\tclk_table->entries[i].cks_enable =\n\t\t\t\t(((le16_to_cpu(clk_dep_table->entries[i].usCKSVOffsetandDisable) & 0x8000)\n\t\t\t\t\t\t>> 15) == 0) ? 1 : 0;\n\t\t\tclk_table->entries[i].cks_voffset =\n\t\t\t\tle16_to_cpu(clk_dep_table->entries[i].usCKSVOffsetandDisable) & 0x7F;\n\t\t\tclk_table->entries[i].sclk_offset =\n\t\t\t\tle16_to_cpu(clk_dep_table->entries[i].usAVFSOffset);\n\t\t}\n\t} else if (clk_dep_table->ucRevId == 1) {\n\t\tpatom_record_v2 = (ATOM_Vega10_GFXCLK_Dependency_Record_V2 *)clk_dep_table->entries;\n\t\tfor (i = 0; i < clk_table->count; i++) {\n\t\t\tclk_table->entries[i].vddInd =\n\t\t\t\t\tpatom_record_v2->ucVddInd;\n\t\t\tclk_table->entries[i].clk =\n\t\t\t\t\tle32_to_cpu(patom_record_v2->ulClk);\n\t\t\tclk_table->entries[i].cks_enable =\n\t\t\t\t\t(((le16_to_cpu(patom_record_v2->usCKSVOffsetandDisable) & 0x8000)\n\t\t\t\t\t\t\t>> 15) == 0) ? 1 : 0;\n\t\t\tclk_table->entries[i].cks_voffset =\n\t\t\t\t\tle16_to_cpu(patom_record_v2->usCKSVOffsetandDisable) & 0x7F;\n\t\t\tclk_table->entries[i].sclk_offset =\n\t\t\t\t\tle16_to_cpu(patom_record_v2->usAVFSOffset);\n\t\t\tpatom_record_v2++;\n\t\t}\n\t} else {\n\t\tkfree(clk_table);\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\"Unsupported GFXClockDependencyTable Revision!\",\n\t\t\treturn -EINVAL);\n\t}\n\n\t*pp_vega10_clk_dep_table = clk_table;\n\n\treturn 0;\n}\n\nstatic int get_pix_clk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t**pp_vega10_clk_dep_table,\n\t\tconst  ATOM_Vega10_PIXCLK_Dependency_Table *clk_dep_table)\n{\n\tuint32_t i;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t\t*clk_table;\n\n\tPP_ASSERT_WITH_CODE((clk_dep_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\tclk_table = kzalloc(struct_size(clk_table, entries, clk_dep_table->ucNumEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn -ENOMEM;\n\n\tclk_table->count = clk_dep_table->ucNumEntries;\n\n\tfor (i = 0; i < clk_table->count; i++) {\n\t\tclk_table->entries[i].vddInd =\n\t\t\t\tclk_dep_table->entries[i].ucVddInd;\n\t\tclk_table->entries[i].clk =\n\t\t\t\tle32_to_cpu(clk_dep_table->entries[i].ulClk);\n\t}\n\n\t*pp_vega10_clk_dep_table = clk_table;\n\n\treturn 0;\n}\n\nstatic int get_dcefclk_voltage_dependency_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t**pp_vega10_clk_dep_table,\n\t\tconst ATOM_Vega10_DCEFCLK_Dependency_Table *clk_dep_table)\n{\n\tuint32_t i;\n\tuint8_t num_entries;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table\n\t\t\t\t*clk_table;\n\tuint32_t dev_id;\n\tuint32_t rev_id;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE((clk_dep_table->ucNumEntries != 0),\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n \n\tdev_id = adev->pdev->device;\n\trev_id = adev->pdev->revision;\n\n\tif (dev_id == 0x6863 && rev_id == 0 &&\n\t\tclk_dep_table->entries[clk_dep_table->ucNumEntries - 1].ulClk < 90000)\n\t\tnum_entries = clk_dep_table->ucNumEntries + 1 > NUM_DSPCLK_LEVELS ?\n\t\t\t\tNUM_DSPCLK_LEVELS : clk_dep_table->ucNumEntries + 1;\n\telse\n\t\tnum_entries = clk_dep_table->ucNumEntries;\n\n\n\tclk_table = kzalloc(struct_size(clk_table, entries, num_entries),\n\t\t\t    GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn -ENOMEM;\n\n\tclk_table->count = (uint32_t)num_entries;\n\n\tfor (i = 0; i < clk_dep_table->ucNumEntries; i++) {\n\t\tclk_table->entries[i].vddInd =\n\t\t\t\tclk_dep_table->entries[i].ucVddInd;\n\t\tclk_table->entries[i].clk =\n\t\t\t\tle32_to_cpu(clk_dep_table->entries[i].ulClk);\n\t}\n\n\tif (i < num_entries) {\n\t\tclk_table->entries[i].vddInd = clk_dep_table->entries[i-1].ucVddInd;\n\t\tclk_table->entries[i].clk = 90000;\n\t}\n\n\t*pp_vega10_clk_dep_table = clk_table;\n\n\treturn 0;\n}\n\nstatic int get_pcie_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_pcie_table **vega10_pcie_table,\n\t\tconst Vega10_PPTable_Generic_SubTable_Header *table)\n{\n\tuint32_t i, pcie_count;\n\tstruct phm_ppt_v1_pcie_table *pcie_table;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tconst ATOM_Vega10_PCIE_Table *atom_pcie_table =\n\t\t\t(ATOM_Vega10_PCIE_Table *)table;\n\n\tPP_ASSERT_WITH_CODE(atom_pcie_table->ucNumEntries,\n\t\t\t\"Invalid PowerPlay Table!\",\n\t\t\treturn 0);\n\n\tpcie_table = kzalloc(struct_size(pcie_table, entries, atom_pcie_table->ucNumEntries),\n\t\t\t     GFP_KERNEL);\n\tif (!pcie_table)\n\t\treturn -ENOMEM;\n\n\tpcie_count = table_info->vdd_dep_on_sclk->count;\n\tif (atom_pcie_table->ucNumEntries <= pcie_count)\n\t\tpcie_count = atom_pcie_table->ucNumEntries;\n\telse\n\t\tpr_info(\"Number of Pcie Entries exceed the number of\"\n\t\t\t\t\" GFXCLK Dpm Levels!\"\n\t\t\t\t\" Disregarding the excess entries...\\n\");\n\n\tpcie_table->count = pcie_count;\n\n\tfor (i = 0; i < pcie_count; i++) {\n\t\tpcie_table->entries[i].gen_speed =\n\t\t\t\tatom_pcie_table->entries[i].ucPCIEGenSpeed;\n\t\tpcie_table->entries[i].lane_width =\n\t\t\t\tatom_pcie_table->entries[i].ucPCIELaneWidth;\n\t\tpcie_table->entries[i].pcie_sclk =\n\t\t\t\tatom_pcie_table->entries[i].ulLCLK;\n\t}\n\n\t*vega10_pcie_table = pcie_table;\n\n\treturn 0;\n}\n\nstatic int get_hard_limits(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_clock_and_voltage_limits *limits,\n\t\tconst ATOM_Vega10_Hard_Limit_Table *limit_table)\n{\n\tPP_ASSERT_WITH_CODE(limit_table->ucNumEntries,\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\t \n\tlimits->sclk = le32_to_cpu(limit_table->entries[0].ulSOCCLKLimit);\n\tlimits->mclk = le32_to_cpu(limit_table->entries[0].ulMCLKLimit);\n\tlimits->gfxclk = le32_to_cpu(limit_table->entries[0].ulGFXCLKLimit);\n\tlimits->vddc = le16_to_cpu(limit_table->entries[0].usVddcLimit);\n\tlimits->vddci = le16_to_cpu(limit_table->entries[0].usVddciLimit);\n\tlimits->vddmem = le16_to_cpu(limit_table->entries[0].usVddMemLimit);\n\n\treturn 0;\n}\n\nstatic int get_valid_clk(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tstruct phm_clock_array **clk_table,\n\t\tconst phm_ppt_v1_clock_voltage_dependency_table *clk_volt_pp_table)\n{\n\tuint32_t i;\n\tstruct phm_clock_array *table;\n\n\tPP_ASSERT_WITH_CODE(clk_volt_pp_table->count,\n\t\t\t\"Invalid PowerPlay Table!\", return -1);\n\n\ttable = kzalloc(struct_size(table, values, clk_volt_pp_table->count),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->count = (uint32_t)clk_volt_pp_table->count;\n\n\tfor (i = 0; i < table->count; i++)\n\t\ttable->values[i] = (uint32_t)clk_volt_pp_table->entries[i].clk;\n\n\t*clk_table = table;\n\n\treturn 0;\n}\n\nstatic int init_powerplay_extended_tables(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table)\n{\n\tint result = 0;\n\tstruct phm_ppt_v2_information *pp_table_info =\n\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tconst ATOM_Vega10_MM_Dependency_Table *mm_dependency_table =\n\t\t\t(const ATOM_Vega10_MM_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usMMDependencyTableOffset));\n\tconst Vega10_PPTable_Generic_SubTable_Header *power_tune_table =\n\t\t\t(const Vega10_PPTable_Generic_SubTable_Header *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usPowerTuneTableOffset));\n\tconst ATOM_Vega10_SOCCLK_Dependency_Table *socclk_dep_table =\n\t\t\t(const ATOM_Vega10_SOCCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usSocclkDependencyTableOffset));\n\tconst ATOM_Vega10_GFXCLK_Dependency_Table *gfxclk_dep_table =\n\t\t\t(const ATOM_Vega10_GFXCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usGfxclkDependencyTableOffset));\n\tconst ATOM_Vega10_DCEFCLK_Dependency_Table *dcefclk_dep_table =\n\t\t\t(const ATOM_Vega10_DCEFCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usDcefclkDependencyTableOffset));\n\tconst ATOM_Vega10_MCLK_Dependency_Table *mclk_dep_table =\n\t\t\t(const ATOM_Vega10_MCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usMclkDependencyTableOffset));\n\tconst ATOM_Vega10_Hard_Limit_Table *hard_limits =\n\t\t\t(const ATOM_Vega10_Hard_Limit_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usHardLimitTableOffset));\n\tconst Vega10_PPTable_Generic_SubTable_Header *pcie_table =\n\t\t\t(const Vega10_PPTable_Generic_SubTable_Header *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usPCIETableOffset));\n\tconst ATOM_Vega10_PIXCLK_Dependency_Table *pixclk_dep_table =\n\t\t\t(const ATOM_Vega10_PIXCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usPixclkDependencyTableOffset));\n\tconst ATOM_Vega10_PHYCLK_Dependency_Table *phyclk_dep_table =\n\t\t\t(const ATOM_Vega10_PHYCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usPhyClkDependencyTableOffset));\n\tconst ATOM_Vega10_DISPCLK_Dependency_Table *dispclk_dep_table =\n\t\t\t(const ATOM_Vega10_DISPCLK_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usDispClkDependencyTableOffset));\n\n\tpp_table_info->vdd_dep_on_socclk = NULL;\n\tpp_table_info->vdd_dep_on_sclk = NULL;\n\tpp_table_info->vdd_dep_on_mclk = NULL;\n\tpp_table_info->vdd_dep_on_dcefclk = NULL;\n\tpp_table_info->mm_dep_table = NULL;\n\tpp_table_info->tdp_table = NULL;\n\tpp_table_info->vdd_dep_on_pixclk = NULL;\n\tpp_table_info->vdd_dep_on_phyclk = NULL;\n\tpp_table_info->vdd_dep_on_dispclk = NULL;\n\n\tif (powerplay_table->usMMDependencyTableOffset)\n\t\tresult = get_mm_clock_voltage_table(hwmgr,\n\t\t\t\t&pp_table_info->mm_dep_table,\n\t\t\t\tmm_dependency_table);\n\n\tif (!result && powerplay_table->usPowerTuneTableOffset)\n\t\tresult = get_tdp_table(hwmgr,\n\t\t\t\t&pp_table_info->tdp_table,\n\t\t\t\tpower_tune_table);\n\n\tif (!result && powerplay_table->usSocclkDependencyTableOffset)\n\t\tresult = get_socclk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_socclk,\n\t\t\t\tsocclk_dep_table);\n\n\tif (!result && powerplay_table->usGfxclkDependencyTableOffset)\n\t\tresult = get_gfxclk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_sclk,\n\t\t\t\tgfxclk_dep_table);\n\n\tif (!result && powerplay_table->usPixclkDependencyTableOffset)\n\t\tresult = get_pix_clk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_pixclk,\n\t\t\t\t(const ATOM_Vega10_PIXCLK_Dependency_Table *)\n\t\t\t\tpixclk_dep_table);\n\n\tif (!result && powerplay_table->usPhyClkDependencyTableOffset)\n\t\tresult = get_pix_clk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_phyclk,\n\t\t\t\t(const ATOM_Vega10_PIXCLK_Dependency_Table *)\n\t\t\t\tphyclk_dep_table);\n\n\tif (!result && powerplay_table->usDispClkDependencyTableOffset)\n\t\tresult = get_pix_clk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_dispclk,\n\t\t\t\t(const ATOM_Vega10_PIXCLK_Dependency_Table *)\n\t\t\t\tdispclk_dep_table);\n\n\tif (!result && powerplay_table->usDcefclkDependencyTableOffset)\n\t\tresult = get_dcefclk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_dcefclk,\n\t\t\t\tdcefclk_dep_table);\n\n\tif (!result && powerplay_table->usMclkDependencyTableOffset)\n\t\tresult = get_mclk_voltage_dependency_table(hwmgr,\n\t\t\t\t&pp_table_info->vdd_dep_on_mclk,\n\t\t\t\tmclk_dep_table);\n\n\tif (!result && powerplay_table->usPCIETableOffset)\n\t\tresult = get_pcie_table(hwmgr,\n\t\t\t\t&pp_table_info->pcie_table,\n\t\t\t\tpcie_table);\n\n\tif (!result && powerplay_table->usHardLimitTableOffset)\n\t\tresult = get_hard_limits(hwmgr,\n\t\t\t\t&pp_table_info->max_clock_voltage_on_dc,\n\t\t\t\thard_limits);\n\n\thwmgr->dyn_state.max_clock_voltage_on_dc.sclk =\n\t\t\tpp_table_info->max_clock_voltage_on_dc.sclk;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.mclk =\n\t\t\tpp_table_info->max_clock_voltage_on_dc.mclk;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.vddc =\n\t\t\tpp_table_info->max_clock_voltage_on_dc.vddc;\n\thwmgr->dyn_state.max_clock_voltage_on_dc.vddci =\n\t\t\tpp_table_info->max_clock_voltage_on_dc.vddci;\n\n\tif (!result &&\n\t\tpp_table_info->vdd_dep_on_socclk &&\n\t\tpp_table_info->vdd_dep_on_socclk->count)\n\t\tresult = get_valid_clk(hwmgr,\n\t\t\t\t&pp_table_info->valid_socclk_values,\n\t\t\t\tpp_table_info->vdd_dep_on_socclk);\n\n\tif (!result &&\n\t\tpp_table_info->vdd_dep_on_sclk &&\n\t\tpp_table_info->vdd_dep_on_sclk->count)\n\t\tresult = get_valid_clk(hwmgr,\n\t\t\t\t&pp_table_info->valid_sclk_values,\n\t\t\t\tpp_table_info->vdd_dep_on_sclk);\n\n\tif (!result &&\n\t\tpp_table_info->vdd_dep_on_dcefclk &&\n\t\tpp_table_info->vdd_dep_on_dcefclk->count)\n\t\tresult = get_valid_clk(hwmgr,\n\t\t\t\t&pp_table_info->valid_dcefclk_values,\n\t\t\t\tpp_table_info->vdd_dep_on_dcefclk);\n\n\tif (!result &&\n\t\tpp_table_info->vdd_dep_on_mclk &&\n\t\tpp_table_info->vdd_dep_on_mclk->count)\n\t\tresult = get_valid_clk(hwmgr,\n\t\t\t\t&pp_table_info->valid_mclk_values,\n\t\t\t\tpp_table_info->vdd_dep_on_mclk);\n\n\treturn result;\n}\n\nstatic int get_vddc_lookup_table(\n\t\tstruct pp_hwmgr\t*hwmgr,\n\t\tphm_ppt_v1_voltage_lookup_table\t**lookup_table,\n\t\tconst ATOM_Vega10_Voltage_Lookup_Table *vddc_lookup_pp_tables,\n\t\tuint32_t max_levels)\n{\n\tuint32_t i;\n\tphm_ppt_v1_voltage_lookup_table *table;\n\n\tPP_ASSERT_WITH_CODE((vddc_lookup_pp_tables->ucNumEntries != 0),\n\t\t\t\"Invalid SOC_VDDD Lookup Table!\", return 1);\n\n\ttable = kzalloc(struct_size(table, entries, max_levels), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->count = vddc_lookup_pp_tables->ucNumEntries;\n\n\tfor (i = 0; i < vddc_lookup_pp_tables->ucNumEntries; i++)\n\t\ttable->entries[i].us_vdd =\n\t\t\t\tle16_to_cpu(vddc_lookup_pp_tables->entries[i].usVdd);\n\n\t*lookup_table = table;\n\n\treturn 0;\n}\n\nstatic int init_dpm_2_parameters(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table)\n{\n\tint result = 0;\n\tstruct phm_ppt_v2_information *pp_table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tuint32_t disable_power_control = 0;\n\n\tpp_table_info->us_ulv_voltage_offset =\n\t\tle16_to_cpu(powerplay_table->usUlvVoltageOffset);\n\n\tpp_table_info->us_ulv_smnclk_did =\n\t\t\tle16_to_cpu(powerplay_table->usUlvSmnclkDid);\n\tpp_table_info->us_ulv_mp1clk_did =\n\t\t\tle16_to_cpu(powerplay_table->usUlvMp1clkDid);\n\tpp_table_info->us_ulv_gfxclk_bypass =\n\t\t\tle16_to_cpu(powerplay_table->usUlvGfxclkBypass);\n\tpp_table_info->us_gfxclk_slew_rate =\n\t\t\tle16_to_cpu(powerplay_table->usGfxclkSlewRate);\n\tpp_table_info->uc_gfx_dpm_voltage_mode  =\n\t\t\tle16_to_cpu(powerplay_table->ucGfxVoltageMode);\n\tpp_table_info->uc_soc_dpm_voltage_mode  =\n\t\t\tle16_to_cpu(powerplay_table->ucSocVoltageMode);\n\tpp_table_info->uc_uclk_dpm_voltage_mode =\n\t\t\tle16_to_cpu(powerplay_table->ucUclkVoltageMode);\n\tpp_table_info->uc_uvd_dpm_voltage_mode  =\n\t\t\tle16_to_cpu(powerplay_table->ucUvdVoltageMode);\n\tpp_table_info->uc_vce_dpm_voltage_mode  =\n\t\t\tle16_to_cpu(powerplay_table->ucVceVoltageMode);\n\tpp_table_info->uc_mp0_dpm_voltage_mode  =\n\t\t\tle16_to_cpu(powerplay_table->ucMp0VoltageMode);\n\tpp_table_info->uc_dcef_dpm_voltage_mode =\n\t\t\tle16_to_cpu(powerplay_table->ucDcefVoltageMode);\n\n\tpp_table_info->ppm_parameter_table = NULL;\n\tpp_table_info->vddc_lookup_table = NULL;\n\tpp_table_info->vddmem_lookup_table = NULL;\n\tpp_table_info->vddci_lookup_table = NULL;\n\n\t \n\thwmgr->platform_descriptor.TDPODLimit =\n\t\tle16_to_cpu(powerplay_table->usPowerControlLimit);\n\thwmgr->platform_descriptor.TDPAdjustment = 0;\n\thwmgr->platform_descriptor.VidAdjustment = 0;\n\thwmgr->platform_descriptor.VidAdjustmentPolarity = 0;\n\thwmgr->platform_descriptor.VidMinLimit = 0;\n\thwmgr->platform_descriptor.VidMaxLimit = 1500000;\n\thwmgr->platform_descriptor.VidStep = 6250;\n\n\tdisable_power_control = 0;\n\tif (!disable_power_control) {\n\t\t \n\t\tif (hwmgr->platform_descriptor.TDPODLimit)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerControl);\n\t}\n\n\tif (powerplay_table->usVddcLookupTableOffset) {\n\t\tconst ATOM_Vega10_Voltage_Lookup_Table *vddc_table =\n\t\t\t\t(ATOM_Vega10_Voltage_Lookup_Table *)\n\t\t\t\t(((unsigned long)powerplay_table) +\n\t\t\t\tle16_to_cpu(powerplay_table->usVddcLookupTableOffset));\n\t\tresult = get_vddc_lookup_table(hwmgr,\n\t\t\t\t&pp_table_info->vddc_lookup_table, vddc_table, 8);\n\t}\n\n\tif (powerplay_table->usVddmemLookupTableOffset) {\n\t\tconst ATOM_Vega10_Voltage_Lookup_Table *vdd_mem_table =\n\t\t\t\t(ATOM_Vega10_Voltage_Lookup_Table *)\n\t\t\t\t(((unsigned long)powerplay_table) +\n\t\t\t\tle16_to_cpu(powerplay_table->usVddmemLookupTableOffset));\n\t\tresult = get_vddc_lookup_table(hwmgr,\n\t\t\t\t&pp_table_info->vddmem_lookup_table, vdd_mem_table, 4);\n\t}\n\n\tif (powerplay_table->usVddciLookupTableOffset) {\n\t\tconst ATOM_Vega10_Voltage_Lookup_Table *vddci_table =\n\t\t\t\t(ATOM_Vega10_Voltage_Lookup_Table *)\n\t\t\t\t(((unsigned long)powerplay_table) +\n\t\t\t\tle16_to_cpu(powerplay_table->usVddciLookupTableOffset));\n\t\tresult = get_vddc_lookup_table(hwmgr,\n\t\t\t\t&pp_table_info->vddci_lookup_table, vddci_table, 4);\n\t}\n\n\treturn result;\n}\n\nstatic int vega10_pp_tables_initialize(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table;\n\n\thwmgr->pptable = kzalloc(sizeof(struct phm_ppt_v2_information), GFP_KERNEL);\n\n\tPP_ASSERT_WITH_CODE((hwmgr->pptable != NULL),\n\t\t\t    \"Failed to allocate hwmgr->pptable!\", return -ENOMEM);\n\n\tpowerplay_table = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((powerplay_table != NULL),\n\t\t\"Missing PowerPlay Table!\", return -1);\n\n\tresult = check_powerplay_tables(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"check_powerplay_tables failed\", return result);\n\n\tresult = set_platform_caps(hwmgr,\n\t\t\t\t   le32_to_cpu(powerplay_table->ulPlatformCaps));\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"set_platform_caps failed\", return result);\n\n\tresult = init_thermal_controller(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_thermal_controller failed\", return result);\n\n\tresult = init_over_drive_limits(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_over_drive_limits failed\", return result);\n\n\tresult = init_powerplay_extended_tables(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_powerplay_extended_tables failed\", return result);\n\n\tresult = init_dpm_2_parameters(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_dpm_2_parameters failed\", return result);\n\n\treturn result;\n}\n\nstatic int vega10_pp_tables_uninitialize(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v2_information *pp_table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tkfree(pp_table_info->vdd_dep_on_sclk);\n\tpp_table_info->vdd_dep_on_sclk = NULL;\n\n\tkfree(pp_table_info->vdd_dep_on_mclk);\n\tpp_table_info->vdd_dep_on_mclk = NULL;\n\n\tkfree(pp_table_info->valid_mclk_values);\n\tpp_table_info->valid_mclk_values = NULL;\n\n\tkfree(pp_table_info->valid_sclk_values);\n\tpp_table_info->valid_sclk_values = NULL;\n\n\tkfree(pp_table_info->vddc_lookup_table);\n\tpp_table_info->vddc_lookup_table = NULL;\n\n\tkfree(pp_table_info->vddmem_lookup_table);\n\tpp_table_info->vddmem_lookup_table = NULL;\n\n\tkfree(pp_table_info->vddci_lookup_table);\n\tpp_table_info->vddci_lookup_table = NULL;\n\n\tkfree(pp_table_info->ppm_parameter_table);\n\tpp_table_info->ppm_parameter_table = NULL;\n\n\tkfree(pp_table_info->mm_dep_table);\n\tpp_table_info->mm_dep_table = NULL;\n\n\tkfree(pp_table_info->cac_dtp_table);\n\tpp_table_info->cac_dtp_table = NULL;\n\n\tkfree(hwmgr->dyn_state.cac_dtp_table);\n\thwmgr->dyn_state.cac_dtp_table = NULL;\n\n\tkfree(pp_table_info->tdp_table);\n\tpp_table_info->tdp_table = NULL;\n\n\tkfree(hwmgr->pptable);\n\thwmgr->pptable = NULL;\n\n\treturn 0;\n}\n\nconst struct pp_table_func vega10_pptable_funcs = {\n\t.pptable_init = vega10_pp_tables_initialize,\n\t.pptable_fini = vega10_pp_tables_uninitialize,\n};\n\nint vega10_get_number_of_powerplay_table_entries(struct pp_hwmgr *hwmgr)\n{\n\tconst ATOM_Vega10_State_Array *state_arrays;\n\tconst ATOM_Vega10_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((pp_table != NULL),\n\t\t\t\"Missing PowerPlay Table!\", return -1);\n\tPP_ASSERT_WITH_CODE((pp_table->sHeader.format_revision >=\n\t\t\tATOM_Vega10_TABLE_REVISION_VEGA10),\n\t\t\t\"Incorrect PowerPlay table revision!\", return -1);\n\n\tstate_arrays = (ATOM_Vega10_State_Array *)(((unsigned long)pp_table) +\n\t\t\tle16_to_cpu(pp_table->usStateArrayOffset));\n\n\treturn (uint32_t)(state_arrays->ucNumEntries);\n}\n\nstatic uint32_t make_classification_flags(struct pp_hwmgr *hwmgr,\n\t\tuint16_t classification, uint16_t classification2)\n{\n\tuint32_t result = 0;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\tresult |= PP_StateClassificationFlag_Boot;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\tresult |= PP_StateClassificationFlag_Thermal;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\n\t\tresult |= PP_StateClassificationFlag_Rest;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\n\t\tresult |= PP_StateClassificationFlag_Forced;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\tresult |= PP_StateClassificationFlag_ACPI;\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\n\n\treturn result;\n}\n\nint vega10_get_powerplay_table_entry(struct pp_hwmgr *hwmgr,\n\t\tuint32_t entry_index, struct pp_power_state *power_state,\n\t\tint (*call_back_func)(struct pp_hwmgr *, void *,\n\t\t\t\tstruct pp_power_state *, void *, uint32_t))\n{\n\tint result = 0;\n\tconst ATOM_Vega10_State_Array *state_arrays;\n\tconst ATOM_Vega10_State *state_entry;\n\tconst ATOM_Vega10_POWERPLAYTABLE *pp_table =\n\t\t\tget_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE(pp_table, \"Missing PowerPlay Table!\",\n\t\t\treturn -1;);\n\tpower_state->classification.bios_index = entry_index;\n\n\tif (pp_table->sHeader.format_revision >=\n\t\t\tATOM_Vega10_TABLE_REVISION_VEGA10) {\n\t\tstate_arrays = (ATOM_Vega10_State_Array *)\n\t\t\t\t(((unsigned long)pp_table) +\n\t\t\t\tle16_to_cpu(pp_table->usStateArrayOffset));\n\n\t\tPP_ASSERT_WITH_CODE(pp_table->usStateArrayOffset > 0,\n\t\t\t\t\"Invalid PowerPlay Table State Array Offset.\",\n\t\t\t\treturn -1);\n\t\tPP_ASSERT_WITH_CODE(state_arrays->ucNumEntries > 0,\n\t\t\t\t\"Invalid PowerPlay Table State Array.\",\n\t\t\t\treturn -1);\n\t\tPP_ASSERT_WITH_CODE((entry_index <= state_arrays->ucNumEntries),\n\t\t\t\t\"Invalid PowerPlay Table State Array Entry.\",\n\t\t\t\treturn -1);\n\n\t\tstate_entry = &(state_arrays->states[entry_index]);\n\n\t\tresult = call_back_func(hwmgr, (void *)state_entry, power_state,\n\t\t\t\t(void *)pp_table,\n\t\t\t\tmake_classification_flags(hwmgr,\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification),\n\t\t\t\t\tle16_to_cpu(state_entry->usClassification2)));\n\t}\n\n\tif (!result && (power_state->classification.flags &\n\t\t\tPP_StateClassificationFlag_Boot))\n\t\tresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(power_state->hardware));\n\n\treturn result;\n}\n\nint vega10_baco_set_cap(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\n\tconst ATOM_Vega10_POWERPLAYTABLE *powerplay_table;\n\n\tpowerplay_table = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((powerplay_table != NULL),\n\t\t\"Missing PowerPlay Table!\", return -1);\n\n\tresult = check_powerplay_tables(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"check_powerplay_tables failed\", return result);\n\n\tset_hw_cap(\n\t\t\thwmgr,\n\t\t\t0 != (le32_to_cpu(powerplay_table->ulPlatformCaps) & ATOM_VEGA10_PP_PLATFORM_CAP_BACO),\n\t\t\tPHM_PlatformCaps_BACO);\n\treturn result;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}