{
  "module_name": "vega20_hwmgr.c",
  "hash_id": "6ac6a442279c07dfd152ae427be02a2890890bb680ad63c4409e8e55f2ed6938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"hwmgr.h\"\n#include \"amd_powerplay.h\"\n#include \"vega20_smumgr.h\"\n#include \"hardwaremanager.h\"\n#include \"ppatomfwctrl.h\"\n#include \"atomfirmware.h\"\n#include \"cgs_common.h\"\n#include \"vega20_powertune.h\"\n#include \"vega20_inc.h\"\n#include \"pppcielanes.h\"\n#include \"vega20_hwmgr.h\"\n#include \"vega20_processpptables.h\"\n#include \"vega20_pptable.h\"\n#include \"vega20_thermal.h\"\n#include \"vega20_ppsmc.h\"\n#include \"pp_debug.h\"\n#include \"amd_pcie_helpers.h\"\n#include \"ppinterrupt.h\"\n#include \"pp_overdriver.h\"\n#include \"pp_thermal.h\"\n#include \"soc15_common.h\"\n#include \"vega20_baco.h\"\n#include \"smuio/smuio_9_0_offset.h\"\n#include \"smuio/smuio_9_0_sh_mask.h\"\n#include \"nbio/nbio_7_4_sh_mask.h\"\n\n#define smnPCIE_LC_SPEED_CNTL\t\t\t0x11140290\n#define smnPCIE_LC_LINK_WIDTH_CNTL\t\t0x11140288\n\n#define LINK_WIDTH_MAX\t\t\t\t6\n#define LINK_SPEED_MAX\t\t\t\t3\nstatic const int link_width[] = {0, 1, 2, 4, 8, 12, 16};\nstatic const int link_speed[] = {25, 50, 80, 160};\n\nstatic void vega20_set_default_registry_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\n\tdata->gfxclk_average_alpha = PPVEGA20_VEGA20GFXCLKAVERAGEALPHA_DFLT;\n\tdata->socclk_average_alpha = PPVEGA20_VEGA20SOCCLKAVERAGEALPHA_DFLT;\n\tdata->uclk_average_alpha = PPVEGA20_VEGA20UCLKCLKAVERAGEALPHA_DFLT;\n\tdata->gfx_activity_average_alpha = PPVEGA20_VEGA20GFXACTIVITYAVERAGEALPHA_DFLT;\n\tdata->lowest_uclk_reserved_for_ulv = PPVEGA20_VEGA20LOWESTUCLKRESERVEDFORULV_DFLT;\n\n\tdata->display_voltage_mode = PPVEGA20_VEGA20DISPLAYVOLTAGEMODE_DFLT;\n\tdata->dcef_clk_quad_eqn_a = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->dcef_clk_quad_eqn_b = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->dcef_clk_quad_eqn_c = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_a = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_b = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_c = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_a = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_b = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_c = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_a = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_b = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_c = PPREGKEY_VEGA20QUADRATICEQUATION_DFLT;\n\n\t \n\tdata->registry_data.disallowed_features = 0xE0041C00;\n\t \n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetSmuVersion, &hwmgr->smu_version);\n\tif (hwmgr->smu_version < 0x282100)\n\t\tdata->registry_data.disallowed_features |= FEATURE_ECC_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_PCIE_DPM_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DPM_LINK_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_SCLK_DPM_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DPM_GFXCLK_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_SOCCLK_DPM_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DPM_SOCCLK_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_MCLK_DPM_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DPM_UCLK_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_DCEFCLK_DPM_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DPM_DCEFCLK_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_ULV_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_ULV_MASK;\n\n\tif (!(hwmgr->feature_mask & PP_SCLK_DEEP_SLEEP_MASK))\n\t\tdata->registry_data.disallowed_features |= FEATURE_DS_GFXCLK_MASK;\n\n\tdata->registry_data.od_state_in_dc_support = 0;\n\tdata->registry_data.thermal_support = 1;\n\tdata->registry_data.skip_baco_hardware = 0;\n\n\tdata->registry_data.log_avfs_param = 0;\n\tdata->registry_data.sclk_throttle_low_notification = 1;\n\tdata->registry_data.force_dpm_high = 0;\n\tdata->registry_data.stable_pstate_sclk_dpm_percentage = 75;\n\n\tdata->registry_data.didt_support = 0;\n\tif (data->registry_data.didt_support) {\n\t\tdata->registry_data.didt_mode = 6;\n\t\tdata->registry_data.sq_ramping_support = 1;\n\t\tdata->registry_data.db_ramping_support = 0;\n\t\tdata->registry_data.td_ramping_support = 0;\n\t\tdata->registry_data.tcp_ramping_support = 0;\n\t\tdata->registry_data.dbr_ramping_support = 0;\n\t\tdata->registry_data.edc_didt_support = 1;\n\t\tdata->registry_data.gc_didt_support = 0;\n\t\tdata->registry_data.psm_didt_support = 0;\n\t}\n\n\tdata->registry_data.pcie_lane_override = 0xff;\n\tdata->registry_data.pcie_speed_override = 0xff;\n\tdata->registry_data.pcie_clock_override = 0xffffffff;\n\tdata->registry_data.regulator_hot_gpio_support = 1;\n\tdata->registry_data.ac_dc_switch_gpio_support = 0;\n\tdata->registry_data.quick_transition_support = 0;\n\tdata->registry_data.zrpm_start_temp = 0xffff;\n\tdata->registry_data.zrpm_stop_temp = 0xffff;\n\tdata->registry_data.od8_feature_enable = 1;\n\tdata->registry_data.disable_water_mark = 0;\n\tdata->registry_data.disable_pp_tuning = 0;\n\tdata->registry_data.disable_xlpp_tuning = 0;\n\tdata->registry_data.disable_workload_policy = 0;\n\tdata->registry_data.perf_ui_tuning_profile_turbo = 0x19190F0F;\n\tdata->registry_data.perf_ui_tuning_profile_powerSave = 0x19191919;\n\tdata->registry_data.perf_ui_tuning_profile_xl = 0x00000F0A;\n\tdata->registry_data.force_workload_policy_mask = 0;\n\tdata->registry_data.disable_3d_fs_detection = 0;\n\tdata->registry_data.fps_support = 1;\n\tdata->registry_data.disable_auto_wattman = 1;\n\tdata->registry_data.auto_wattman_debug = 0;\n\tdata->registry_data.auto_wattman_sample_period = 100;\n\tdata->registry_data.fclk_gfxclk_ratio = 0;\n\tdata->registry_data.auto_wattman_threshold = 50;\n\tdata->registry_data.gfxoff_controlled_by_driver = 1;\n\tdata->gfxoff_allowed = false;\n\tdata->counter_gfxoff = 0;\n\tdata->registry_data.pcie_dpm_key_disabled = !(hwmgr->feature_mask & PP_PCIE_DPM_MASK);\n}\n\nstatic int vega20_set_features_platform_caps(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tif (data->vddci_control == VEGA20_VOLTAGE_CONTROL_NONE)\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ControlVDDCI);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_TablelessHardwareInterface);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_BACO);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_EnableSMU7ThermalManagement);\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_UVDPowerGating);\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_VCE)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_VCEPowerGating);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_UnTabledHardwareInterface);\n\n\tif (data->registry_data.od8_feature_enable)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_OD8inACSupport);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_ActivityReporting);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_FanSpeedInTableIsRPM);\n\n\tif (data->registry_data.od_state_in_dc_support) {\n\t\tif (data->registry_data.od8_feature_enable)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_OD8inDCSupport);\n\t}\n\n\tif (data->registry_data.thermal_support &&\n\t    data->registry_data.fuzzy_fan_control_support &&\n\t    hwmgr->thermal_controller.advanceFanControlParameters.usTMax)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ODFuzzyFanControlSupport);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DynamicPowerManagement);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SMC);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_ThermalPolicyDelay);\n\n\tif (data->registry_data.force_dpm_high)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ExclusiveModeAlwaysHigh);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DynamicUVDState);\n\n\tif (data->registry_data.sclk_throttle_low_notification)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_SclkThrottleLowNotification);\n\n\t \n\t \n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerContainment);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DiDtSupport);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SQRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DBRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_TDRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_TCPRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DBRRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DiDtEDCEnable);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_GCEDC);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PSM);\n\n\tif (data->registry_data.didt_support) {\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_DiDtSupport);\n\t\tif (data->registry_data.sq_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_SQRamping);\n\t\tif (data->registry_data.db_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_DBRamping);\n\t\tif (data->registry_data.td_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_TDRamping);\n\t\tif (data->registry_data.tcp_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_TCPRamping);\n\t\tif (data->registry_data.dbr_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_DBRRamping);\n\t\tif (data->registry_data.edc_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_DiDtEDCEnable);\n\t\tif (data->registry_data.gc_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_GCEDC);\n\t\tif (data->registry_data.psm_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_PSM);\n\t}\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_RegulatorHot);\n\n\tif (data->registry_data.ac_dc_switch_gpio_support) {\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_AutomaticDCTransition);\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_SMCtoPPLIBAcdcGpioScheme);\n\t}\n\n\tif (data->registry_data.quick_transition_support) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_AutomaticDCTransition);\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_SMCtoPPLIBAcdcGpioScheme);\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_Falcon_QuickTransition);\n\t}\n\n\tif (data->lowest_uclk_reserved_for_ulv != PPVEGA20_VEGA20LOWESTUCLKRESERVEDFORULV_DFLT) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_LowestUclkReservedForUlv);\n\t\tif (data->lowest_uclk_reserved_for_ulv == 1)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_LowestUclkReservedForUlv);\n\t}\n\n\tif (data->registry_data.custom_fan_support)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_CustomFanControlSupport);\n\n\treturn 0;\n}\n\nstatic void vega20_init_dpm_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t top32, bottom32;\n\tint i;\n\n\tdata->smu_features[GNLD_DPM_PREFETCHER].smu_feature_id =\n\t\t\tFEATURE_DPM_PREFETCHER_BIT;\n\tdata->smu_features[GNLD_DPM_GFXCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_GFXCLK_BIT;\n\tdata->smu_features[GNLD_DPM_UCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_UCLK_BIT;\n\tdata->smu_features[GNLD_DPM_SOCCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_SOCCLK_BIT;\n\tdata->smu_features[GNLD_DPM_UVD].smu_feature_id =\n\t\t\tFEATURE_DPM_UVD_BIT;\n\tdata->smu_features[GNLD_DPM_VCE].smu_feature_id =\n\t\t\tFEATURE_DPM_VCE_BIT;\n\tdata->smu_features[GNLD_ULV].smu_feature_id =\n\t\t\tFEATURE_ULV_BIT;\n\tdata->smu_features[GNLD_DPM_MP0CLK].smu_feature_id =\n\t\t\tFEATURE_DPM_MP0CLK_BIT;\n\tdata->smu_features[GNLD_DPM_LINK].smu_feature_id =\n\t\t\tFEATURE_DPM_LINK_BIT;\n\tdata->smu_features[GNLD_DPM_DCEFCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_DCEFCLK_BIT;\n\tdata->smu_features[GNLD_DS_GFXCLK].smu_feature_id =\n\t\t\tFEATURE_DS_GFXCLK_BIT;\n\tdata->smu_features[GNLD_DS_SOCCLK].smu_feature_id =\n\t\t\tFEATURE_DS_SOCCLK_BIT;\n\tdata->smu_features[GNLD_DS_LCLK].smu_feature_id =\n\t\t\tFEATURE_DS_LCLK_BIT;\n\tdata->smu_features[GNLD_PPT].smu_feature_id =\n\t\t\tFEATURE_PPT_BIT;\n\tdata->smu_features[GNLD_TDC].smu_feature_id =\n\t\t\tFEATURE_TDC_BIT;\n\tdata->smu_features[GNLD_THERMAL].smu_feature_id =\n\t\t\tFEATURE_THERMAL_BIT;\n\tdata->smu_features[GNLD_GFX_PER_CU_CG].smu_feature_id =\n\t\t\tFEATURE_GFX_PER_CU_CG_BIT;\n\tdata->smu_features[GNLD_RM].smu_feature_id =\n\t\t\tFEATURE_RM_BIT;\n\tdata->smu_features[GNLD_DS_DCEFCLK].smu_feature_id =\n\t\t\tFEATURE_DS_DCEFCLK_BIT;\n\tdata->smu_features[GNLD_ACDC].smu_feature_id =\n\t\t\tFEATURE_ACDC_BIT;\n\tdata->smu_features[GNLD_VR0HOT].smu_feature_id =\n\t\t\tFEATURE_VR0HOT_BIT;\n\tdata->smu_features[GNLD_VR1HOT].smu_feature_id =\n\t\t\tFEATURE_VR1HOT_BIT;\n\tdata->smu_features[GNLD_FW_CTF].smu_feature_id =\n\t\t\tFEATURE_FW_CTF_BIT;\n\tdata->smu_features[GNLD_LED_DISPLAY].smu_feature_id =\n\t\t\tFEATURE_LED_DISPLAY_BIT;\n\tdata->smu_features[GNLD_FAN_CONTROL].smu_feature_id =\n\t\t\tFEATURE_FAN_CONTROL_BIT;\n\tdata->smu_features[GNLD_DIDT].smu_feature_id = FEATURE_GFX_EDC_BIT;\n\tdata->smu_features[GNLD_GFXOFF].smu_feature_id = FEATURE_GFXOFF_BIT;\n\tdata->smu_features[GNLD_CG].smu_feature_id = FEATURE_CG_BIT;\n\tdata->smu_features[GNLD_DPM_FCLK].smu_feature_id = FEATURE_DPM_FCLK_BIT;\n\tdata->smu_features[GNLD_DS_FCLK].smu_feature_id = FEATURE_DS_FCLK_BIT;\n\tdata->smu_features[GNLD_DS_MP1CLK].smu_feature_id = FEATURE_DS_MP1CLK_BIT;\n\tdata->smu_features[GNLD_DS_MP0CLK].smu_feature_id = FEATURE_DS_MP0CLK_BIT;\n\tdata->smu_features[GNLD_XGMI].smu_feature_id = FEATURE_XGMI_BIT;\n\tdata->smu_features[GNLD_ECC].smu_feature_id = FEATURE_ECC_BIT;\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tdata->smu_features[i].smu_feature_bitmap =\n\t\t\t(uint64_t)(1ULL << data->smu_features[i].smu_feature_id);\n\t\tdata->smu_features[i].allowed =\n\t\t\t((data->registry_data.disallowed_features >> i) & 1) ?\n\t\t\tfalse : true;\n\t}\n\n\t \n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumTop32, &top32);\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumBottom32, &bottom32);\n\n\tadev->unique_id = ((uint64_t)bottom32 << 32) | top32;\n}\n\nstatic int vega20_set_private_data_based_on_pptable(struct pp_hwmgr *hwmgr)\n{\n\treturn 0;\n}\n\nstatic int vega20_hwmgr_backend_fini(struct pp_hwmgr *hwmgr)\n{\n\tkfree(hwmgr->backend);\n\thwmgr->backend = NULL;\n\n\treturn 0;\n}\n\nstatic int vega20_hwmgr_backend_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tdata = kzalloc(sizeof(struct vega20_hwmgr), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->backend = data;\n\n\thwmgr->workload_mask = 1 << hwmgr->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT];\n\thwmgr->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;\n\thwmgr->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;\n\n\tvega20_set_default_registry_data(hwmgr);\n\n\tdata->disable_dpm_mask = 0xff;\n\n\t \n\tdata->vddc_control = VEGA20_VOLTAGE_CONTROL_NONE;\n\tdata->mvdd_control = VEGA20_VOLTAGE_CONTROL_NONE;\n\tdata->vddci_control = VEGA20_VOLTAGE_CONTROL_NONE;\n\n\tdata->water_marks_bitmap = 0;\n\tdata->avfs_exist = false;\n\n\tvega20_set_features_platform_caps(hwmgr);\n\n\tvega20_init_dpm_defaults(hwmgr);\n\n\t \n\tvega20_set_private_data_based_on_pptable(hwmgr);\n\n\tdata->is_tlu_enabled = false;\n\n\thwmgr->platform_descriptor.hardwareActivityPerformanceLevels =\n\t\t\tVEGA20_MAX_HARDWARE_POWERLEVELS;\n\thwmgr->platform_descriptor.hardwarePerformanceLevels = 2;\n\thwmgr->platform_descriptor.minimumClocksReductionPercentage = 50;\n\n\thwmgr->platform_descriptor.vbiosInterruptId = 0x20000400;  \n\t \n\thwmgr->platform_descriptor.clockStep.engineClock = 500;\n\thwmgr->platform_descriptor.clockStep.memoryClock = 500;\n\n\tdata->total_active_cus = adev->gfx.cu_info.number;\n\tdata->is_custom_profile_set = false;\n\n\treturn 0;\n}\n\nstatic int vega20_init_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\n\tdata->low_sclk_interrupt_threshold = 0;\n\n\treturn 0;\n}\n\nstatic int vega20_setup_asic_task(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tint ret = 0;\n\tbool use_baco = (amdgpu_in_reset(adev) &&\n\t\t\t (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)) ||\n\t\t(adev->in_runpm && amdgpu_asic_supports_baco(adev));\n\n\tret = vega20_init_sclk_threshold(hwmgr);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to init sclk threshold!\",\n\t\t\treturn ret);\n\n\tif (use_baco) {\n\t\tret = vega20_baco_apply_vdci_flush_workaround(hwmgr);\n\t\tif (ret)\n\t\t\tpr_err(\"Failed to apply vega20 baco workaround!\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic void vega20_init_dpm_state(struct vega20_dpm_state *dpm_state)\n{\n\tdpm_state->soft_min_level = 0x0;\n\tdpm_state->soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_state->hard_min_level = 0x0;\n\tdpm_state->hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n}\n\nstatic int vega20_get_number_of_dpm_level(struct pp_hwmgr *hwmgr,\n\t\tPPCLK_e clk_id, uint32_t *num_of_levels)\n{\n\tint ret = 0;\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetDpmFreqByIndex,\n\t\t\t(clk_id << 16 | 0xFF),\n\t\t\tnum_of_levels);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetNumOfDpmLevel] failed to get dpm levels!\",\n\t\t\treturn ret);\n\n\treturn ret;\n}\n\nstatic int vega20_get_dpm_frequency_by_index(struct pp_hwmgr *hwmgr,\n\t\tPPCLK_e clk_id, uint32_t index, uint32_t *clk)\n{\n\tint ret = 0;\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetDpmFreqByIndex,\n\t\t\t(clk_id << 16 | index),\n\t\t\tclk);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetDpmFreqByIndex] failed to get dpm freq by index!\",\n\t\t\treturn ret);\n\n\treturn ret;\n}\n\nstatic int vega20_setup_single_dpm_table(struct pp_hwmgr *hwmgr,\n\t\tstruct vega20_single_dpm_table *dpm_table, PPCLK_e clk_id)\n{\n\tint ret = 0;\n\tuint32_t i, num_of_levels, clk;\n\n\tret = vega20_get_number_of_dpm_level(hwmgr, clk_id, &num_of_levels);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetupSingleDpmTable] failed to get clk levels!\",\n\t\t\treturn ret);\n\n\tdpm_table->count = num_of_levels;\n\n\tfor (i = 0; i < num_of_levels; i++) {\n\t\tret = vega20_get_dpm_frequency_by_index(hwmgr, clk_id, i, &clk);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetupSingleDpmTable] failed to get clk of specific level!\",\n\t\t\treturn ret);\n\t\tdpm_table->dpm_levels[i].value = clk;\n\t\tdpm_table->dpm_levels[i].enabled = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_setup_gfxclk_dpm_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table;\n\tint ret = 0;\n\n\tdpm_table = &(data->dpm_table.gfx_table);\n\tif (data->smu_features[GNLD_DPM_GFXCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_GFXCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get gfxclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.gfx_clock / 100;\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_setup_memclk_dpm_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table;\n\tint ret = 0;\n\n\tdpm_table = &(data->dpm_table.mem_table);\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_UCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get memclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.mem_clock / 100;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int vega20_setup_default_dpm_tables(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table;\n\tint ret = 0;\n\n\tmemset(&data->dpm_table, 0, sizeof(data->dpm_table));\n\n\t \n\tdpm_table = &(data->dpm_table.soc_table);\n\tif (data->smu_features[GNLD_DPM_SOCCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_SOCCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get socclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.soc_clock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.gfx_table);\n\tret = vega20_setup_gfxclk_dpm_table(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.mem_table);\n\tret = vega20_setup_memclk_dpm_table(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.eclk_table);\n\tif (data->smu_features[GNLD_DPM_VCE].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_ECLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get eclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.eclock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.vclk_table);\n\tif (data->smu_features[GNLD_DPM_UVD].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_VCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get vclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.vclock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.dclk_table);\n\tif (data->smu_features[GNLD_DPM_UVD].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_DCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get dclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.dclock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.dcef_table);\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_DCEFCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get dcefclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.dcef_clock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.pixel_table);\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_PIXCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get pixclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else\n\t\tdpm_table->count = 0;\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.display_table);\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_DISPCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get dispclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else\n\t\tdpm_table->count = 0;\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.phy_table);\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_PHYCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get phyclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else\n\t\tdpm_table->count = 0;\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.fclk_table);\n\tif (data->smu_features[GNLD_DPM_FCLK].enabled) {\n\t\tret = vega20_setup_single_dpm_table(hwmgr, dpm_table, PPCLK_FCLK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[SetupDefaultDpmTable] failed to get fclk dpm levels!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = data->vbios_boot_state.fclock / 100;\n\t}\n\tvega20_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tmemcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega20_dpm_table));\n\n\treturn 0;\n}\n\n \nstatic int vega20_init_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct pp_atomfwctrl_bios_boot_up_values boot_up_values;\n\tstruct phm_ppt_v3_information *pptable_information =\n\t\t(struct phm_ppt_v3_information *)hwmgr->pptable;\n\n\tresult = pp_atomfwctrl_get_vbios_bootup_values(hwmgr, &boot_up_values);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[InitSMCTable] Failed to get vbios bootup values!\",\n\t\t\treturn result);\n\n\tdata->vbios_boot_state.vddc     = boot_up_values.usVddc;\n\tdata->vbios_boot_state.vddci    = boot_up_values.usVddci;\n\tdata->vbios_boot_state.mvddc    = boot_up_values.usMvddc;\n\tdata->vbios_boot_state.gfx_clock = boot_up_values.ulGfxClk;\n\tdata->vbios_boot_state.mem_clock = boot_up_values.ulUClk;\n\tdata->vbios_boot_state.soc_clock = boot_up_values.ulSocClk;\n\tdata->vbios_boot_state.dcef_clock = boot_up_values.ulDCEFClk;\n\tdata->vbios_boot_state.eclock = boot_up_values.ulEClk;\n\tdata->vbios_boot_state.vclock = boot_up_values.ulVClk;\n\tdata->vbios_boot_state.dclock = boot_up_values.ulDClk;\n\tdata->vbios_boot_state.fclock = boot_up_values.ulFClk;\n\tdata->vbios_boot_state.uc_cooling_id = boot_up_values.ucCoolingID;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetMinDeepSleepDcefclk,\n\t\t(uint32_t)(data->vbios_boot_state.dcef_clock / 100),\n\t\t\tNULL);\n\n\tmemcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t));\n\n\tresult = smum_smc_table_manager(hwmgr,\n\t\t\t\t\t(uint8_t *)pp_table, TABLE_PPTABLE, false);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[InitSMCTable] Failed to upload PPtable!\",\n\t\t\treturn result);\n\n\treturn 0;\n}\n\n \nstatic int vega20_override_pcie_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t pcie_gen = 0, pcie_width = 0, smu_pcie_arg, pcie_gen_arg, pcie_width_arg;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tint i;\n\tint ret;\n\n\tif (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4)\n\t\tpcie_gen = 3;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)\n\t\tpcie_gen = 2;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)\n\t\tpcie_gen = 1;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN1)\n\t\tpcie_gen = 0;\n\n\tif (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X16)\n\t\tpcie_width = 6;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X12)\n\t\tpcie_width = 5;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X8)\n\t\tpcie_width = 4;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X4)\n\t\tpcie_width = 3;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X2)\n\t\tpcie_width = 2;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X1)\n\t\tpcie_width = 1;\n\n\t \n\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\tpcie_gen_arg = (pp_table->PcieGenSpeed[i] > pcie_gen) ? pcie_gen :\n\t\t\tpp_table->PcieGenSpeed[i];\n\t\tpcie_width_arg = (pp_table->PcieLaneCount[i] > pcie_width) ? pcie_width :\n\t\t\tpp_table->PcieLaneCount[i];\n\n\t\tif (pcie_gen_arg != pp_table->PcieGenSpeed[i] || pcie_width_arg !=\n\t\t    pp_table->PcieLaneCount[i]) {\n\t\t\tsmu_pcie_arg = (i << 16) | (pcie_gen_arg << 8) | pcie_width_arg;\n\t\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_OverridePcieParameters, smu_pcie_arg,\n\t\t\t\tNULL);\n\t\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[OverridePcieParameters] Attempt to override pcie params failed!\",\n\t\t\t\treturn ret);\n\t\t}\n\n\t\t \n\t\tpp_table->PcieGenSpeed[i] = pcie_gen_arg;\n\t\tpp_table->PcieLaneCount[i] = pcie_width_arg;\n\t}\n\n\t \n\tif (data->registry_data.pcie_dpm_key_disabled) {\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\tsmu_pcie_arg = (i << 16) | (pcie_gen << 8) | pcie_width;\n\t\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_OverridePcieParameters, smu_pcie_arg,\n\t\t\t\tNULL);\n\t\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[OverridePcieParameters] Attempt to override pcie params failed!\",\n\t\t\t\treturn ret);\n\n\t\t\tpp_table->PcieGenSpeed[i] = pcie_gen;\n\t\t\tpp_table->PcieLaneCount[i] = pcie_width;\n\t\t}\n\t\tret = vega20_enable_smc_features(hwmgr,\n\t\t\t\tfalse,\n\t\t\t\tdata->smu_features[GNLD_DPM_LINK].smu_feature_bitmap);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to Disable DPM LINK Failed!\",\n\t\t\t\treturn ret);\n\t\tdata->smu_features[GNLD_DPM_LINK].enabled = false;\n\t\tdata->smu_features[GNLD_DPM_LINK].supported = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_set_allowed_featuresmask(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t allowed_features_low = 0, allowed_features_high = 0;\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++)\n\t\tif (data->smu_features[i].allowed)\n\t\t\tdata->smu_features[i].smu_feature_id > 31 ?\n\t\t\t\t(allowed_features_high |=\n\t\t\t\t ((data->smu_features[i].smu_feature_bitmap >> SMU_FEATURES_HIGH_SHIFT)\n\t\t\t\t  & 0xFFFFFFFF)) :\n\t\t\t\t(allowed_features_low |=\n\t\t\t\t ((data->smu_features[i].smu_feature_bitmap >> SMU_FEATURES_LOW_SHIFT)\n\t\t\t\t  & 0xFFFFFFFF));\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\tPPSMC_MSG_SetAllowedFeaturesMaskHigh, allowed_features_high, NULL);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\"[SetAllowedFeaturesMask] Attempt to set allowed features mask(high) failed!\",\n\t\treturn ret);\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\tPPSMC_MSG_SetAllowedFeaturesMaskLow, allowed_features_low, NULL);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\"[SetAllowedFeaturesMask] Attempt to set allowed features mask (low) failed!\",\n\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_run_btc(struct pp_hwmgr *hwmgr)\n{\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunBtc, NULL);\n}\n\nstatic int vega20_run_btc_afll(struct pp_hwmgr *hwmgr)\n{\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunAfllBtc, NULL);\n}\n\nstatic int vega20_enable_all_smu_features(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint64_t features_enabled;\n\tint i;\n\tbool enabled;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_EnableAllSmuFeatures,\n\t\t\tNULL)) == 0,\n\t\t\t\"[EnableAllSMUFeatures] Failed to enable all smu features!\",\n\t\t\treturn ret);\n\n\tret = vega20_get_enabled_smc_features(hwmgr, &features_enabled);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[EnableAllSmuFeatures] Failed to get enabled smc features!\",\n\t\t\treturn ret);\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tenabled = (features_enabled & data->smu_features[i].smu_feature_bitmap) ?\n\t\t\ttrue : false;\n\t\tdata->smu_features[i].enabled = enabled;\n\t\tdata->smu_features[i].supported = enabled;\n\n#if 0\n\t\tif (data->smu_features[i].allowed && !enabled)\n\t\t\tpr_info(\"[EnableAllSMUFeatures] feature %d is expected enabled!\", i);\n\t\telse if (!data->smu_features[i].allowed && enabled)\n\t\t\tpr_info(\"[EnableAllSMUFeatures] feature %d is expected disabled!\", i);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_notify_smc_display_change(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled)\n\t\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetUclkFastSwitch,\n\t\t\t1,\n\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int vega20_send_clock_ratio(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\n\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetFclkGfxClkRatio,\n\t\t\tdata->registry_data.fclk_gfxclk_ratio,\n\t\t\tNULL);\n}\n\nstatic int vega20_disable_all_smu_features(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tint i, ret = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_DisableAllSmuFeatures,\n\t\t\tNULL)) == 0,\n\t\t\t\"[DisableAllSMUFeatures] Failed to disable all smu features!\",\n\t\t\treturn ret);\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++)\n\t\tdata->smu_features[i].enabled = 0;\n\n\treturn 0;\n}\n\nstatic int vega20_od8_set_feature_capabilities(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v3_information *pptable_information =\n\t\t(struct phm_ppt_v3_information *)hwmgr->pptable;\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega20_od8_settings *od_settings = &(data->od8_settings);\n\n\tod_settings->overdrive8_capabilities = 0;\n\n\tif (data->smu_features[GNLD_DPM_GFXCLK].enabled) {\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_GFXCLK_LIMITS] &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_GFXCLK_FMAX] > 0 &&\n\t\t    pptable_information->od_settings_min[OD8_SETTING_GFXCLK_FMIN] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_GFXCLK_FMAX] >=\n\t\t    pptable_information->od_settings_min[OD8_SETTING_GFXCLK_FMIN]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_GFXCLK_LIMITS;\n\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_GFXCLK_CURVE] &&\n\t\t    (pptable_information->od_settings_min[OD8_SETTING_GFXCLK_VOLTAGE1] >=\n\t\t     pp_table->MinVoltageGfx / VOLTAGE_SCALE) &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_GFXCLK_VOLTAGE3] <=\n\t\t     pp_table->MaxVoltageGfx / VOLTAGE_SCALE) &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_GFXCLK_VOLTAGE3] >=\n\t\t     pptable_information->od_settings_min[OD8_SETTING_GFXCLK_VOLTAGE1]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_GFXCLK_CURVE;\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled) {\n\t\tpptable_information->od_settings_min[OD8_SETTING_UCLK_FMAX] =\n\t\t\tdata->dpm_table.mem_table.dpm_levels[data->dpm_table.mem_table.count - 2].value;\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_UCLK_MAX] &&\n\t\t    pptable_information->od_settings_min[OD8_SETTING_UCLK_FMAX] > 0 &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_UCLK_FMAX] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_UCLK_FMAX] >=\n\t\t    pptable_information->od_settings_min[OD8_SETTING_UCLK_FMAX]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_UCLK_MAX;\n\t}\n\n\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_POWER_LIMIT] &&\n\t    pptable_information->od_settings_max[OD8_SETTING_POWER_PERCENTAGE] > 0 &&\n\t    pptable_information->od_settings_max[OD8_SETTING_POWER_PERCENTAGE] <= 100 &&\n\t    pptable_information->od_settings_min[OD8_SETTING_POWER_PERCENTAGE] > 0 &&\n\t    pptable_information->od_settings_min[OD8_SETTING_POWER_PERCENTAGE] <= 100)\n\t\tod_settings->overdrive8_capabilities |= OD8_POWER_LIMIT;\n\n\tif (data->smu_features[GNLD_FAN_CONTROL].enabled) {\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_FAN_ACOUSTIC_LIMIT] &&\n\t\t    pptable_information->od_settings_min[OD8_SETTING_FAN_ACOUSTIC_LIMIT] > 0 &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_FAN_ACOUSTIC_LIMIT] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_FAN_ACOUSTIC_LIMIT] >=\n\t\t     pptable_information->od_settings_min[OD8_SETTING_FAN_ACOUSTIC_LIMIT]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_ACOUSTIC_LIMIT_SCLK;\n\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_FAN_SPEED_MIN] &&\n\t\t    (pptable_information->od_settings_min[OD8_SETTING_FAN_MIN_SPEED] >=\n\t\t    (pp_table->FanPwmMin * pp_table->FanMaximumRpm / 100)) &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_FAN_MIN_SPEED] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_FAN_MIN_SPEED] >=\n\t\t     pptable_information->od_settings_min[OD8_SETTING_FAN_MIN_SPEED]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_FAN_SPEED_MIN;\n\t}\n\n\tif (data->smu_features[GNLD_THERMAL].enabled) {\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_TEMPERATURE_FAN] &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_FAN_TARGET_TEMP] > 0 &&\n\t\t    pptable_information->od_settings_min[OD8_SETTING_FAN_TARGET_TEMP] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_FAN_TARGET_TEMP] >=\n\t\t     pptable_information->od_settings_min[OD8_SETTING_FAN_TARGET_TEMP]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_TEMPERATURE_FAN;\n\n\t\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_TEMPERATURE_SYSTEM] &&\n\t\t    pptable_information->od_settings_max[OD8_SETTING_OPERATING_TEMP_MAX] > 0 &&\n\t\t    pptable_information->od_settings_min[OD8_SETTING_OPERATING_TEMP_MAX] > 0 &&\n\t\t    (pptable_information->od_settings_max[OD8_SETTING_OPERATING_TEMP_MAX] >=\n\t\t     pptable_information->od_settings_min[OD8_SETTING_OPERATING_TEMP_MAX]))\n\t\t\tod_settings->overdrive8_capabilities |= OD8_TEMPERATURE_SYSTEM;\n\t}\n\n\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_MEMORY_TIMING_TUNE])\n\t\tod_settings->overdrive8_capabilities |= OD8_MEMORY_TIMING_TUNE;\n\n\tif (pptable_information->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_FAN_ZERO_RPM_CONTROL] &&\n\t    pp_table->FanZeroRpmEnable)\n\t\tod_settings->overdrive8_capabilities |= OD8_FAN_ZERO_RPM_CONTROL;\n\n\tif (!od_settings->overdrive8_capabilities)\n\t\thwmgr->od_enabled = false;\n\n\treturn 0;\n}\n\nstatic int vega20_od8_set_feature_id(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_od8_settings *od_settings = &(data->od8_settings);\n\n\tif (od_settings->overdrive8_capabilities & OD8_GFXCLK_LIMITS) {\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMIN].feature_id =\n\t\t\tOD8_GFXCLK_LIMITS;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMAX].feature_id =\n\t\t\tOD8_GFXCLK_LIMITS;\n\t} else {\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMIN].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMAX].feature_id =\n\t\t\t0;\n\t}\n\n\tif (od_settings->overdrive8_capabilities & OD8_GFXCLK_CURVE) {\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ1].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ2].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ3].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].feature_id =\n\t\t\tOD8_GFXCLK_CURVE;\n\t} else {\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ1].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ2].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ3].feature_id =\n\t\t\t0;\n\t\tod_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].feature_id =\n\t\t\t0;\n\t}\n\n\tif (od_settings->overdrive8_capabilities & OD8_UCLK_MAX)\n\t\tod_settings->od8_settings_array[OD8_SETTING_UCLK_FMAX].feature_id = OD8_UCLK_MAX;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_UCLK_FMAX].feature_id = 0;\n\n\tif (od_settings->overdrive8_capabilities & OD8_POWER_LIMIT)\n\t\tod_settings->od8_settings_array[OD8_SETTING_POWER_PERCENTAGE].feature_id = OD8_POWER_LIMIT;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_POWER_PERCENTAGE].feature_id = 0;\n\n\tif (od_settings->overdrive8_capabilities & OD8_ACOUSTIC_LIMIT_SCLK)\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_ACOUSTIC_LIMIT].feature_id =\n\t\t\tOD8_ACOUSTIC_LIMIT_SCLK;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_ACOUSTIC_LIMIT].feature_id =\n\t\t\t0;\n\n\tif (od_settings->overdrive8_capabilities & OD8_FAN_SPEED_MIN)\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_MIN_SPEED].feature_id =\n\t\t\tOD8_FAN_SPEED_MIN;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_MIN_SPEED].feature_id =\n\t\t\t0;\n\n\tif (od_settings->overdrive8_capabilities & OD8_TEMPERATURE_FAN)\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_TARGET_TEMP].feature_id =\n\t\t\tOD8_TEMPERATURE_FAN;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_FAN_TARGET_TEMP].feature_id =\n\t\t\t0;\n\n\tif (od_settings->overdrive8_capabilities & OD8_TEMPERATURE_SYSTEM)\n\t\tod_settings->od8_settings_array[OD8_SETTING_OPERATING_TEMP_MAX].feature_id =\n\t\t\tOD8_TEMPERATURE_SYSTEM;\n\telse\n\t\tod_settings->od8_settings_array[OD8_SETTING_OPERATING_TEMP_MAX].feature_id =\n\t\t\t0;\n\n\treturn 0;\n}\n\nstatic int vega20_od8_get_gfx_clock_base_voltage(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t *voltage,\n\t\tuint32_t freq)\n{\n\tint ret = 0;\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetAVFSVoltageByDpm,\n\t\t\t((AVFS_CURVE << 24) | (OD8_HOTCURVE_TEMPERATURE << 16) | freq),\n\t\t\tvoltage);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetBaseVoltage] failed to get GFXCLK AVFS voltage from SMU!\",\n\t\t\treturn ret);\n\n\t*voltage = *voltage / VOLTAGE_SCALE;\n\n\treturn 0;\n}\n\nstatic int vega20_od8_initialize_default_settings(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v3_information *pptable_information =\n\t\t(struct phm_ppt_v3_information *)hwmgr->pptable;\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_od8_settings *od8_settings = &(data->od8_settings);\n\tOverDriveTable_t *od_table = &(data->smc_state_table.overdrive_table);\n\tint i, ret = 0;\n\n\t \n\tvega20_od8_set_feature_capabilities(hwmgr);\n\n\t \n\tvega20_od8_set_feature_id(hwmgr);\n\n\t \n\tret = smum_smc_table_manager(hwmgr, (uint8_t *)od_table, TABLE_OVERDRIVE, true);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to export over drive table!\",\n\t\t\treturn ret);\n\n\tif (od8_settings->overdrive8_capabilities & OD8_GFXCLK_LIMITS) {\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMIN].default_value =\n\t\t\tod_table->GfxclkFmin;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMAX].default_value =\n\t\t\tod_table->GfxclkFmax;\n\t} else {\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMIN].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FMAX].default_value =\n\t\t\t0;\n\t}\n\n\tif (od8_settings->overdrive8_capabilities & OD8_GFXCLK_CURVE) {\n\t\tod_table->GfxclkFreq1 = od_table->GfxclkFmin;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ1].default_value =\n\t\t\tod_table->GfxclkFreq1;\n\n\t\tod_table->GfxclkFreq3 = od_table->GfxclkFmax;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ3].default_value =\n\t\t\tod_table->GfxclkFreq3;\n\n\t\tod_table->GfxclkFreq2 = (od_table->GfxclkFreq1 + od_table->GfxclkFreq3) / 2;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ2].default_value =\n\t\t\tod_table->GfxclkFreq2;\n\n\t\tPP_ASSERT_WITH_CODE(!vega20_od8_get_gfx_clock_base_voltage(hwmgr,\n\t\t\t\t   &(od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].default_value),\n\t\t\t\t     od_table->GfxclkFreq1),\n\t\t\t\t\"[PhwVega20_OD8_InitializeDefaultSettings] Failed to get Base clock voltage from SMU!\",\n\t\t\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].default_value = 0);\n\t\tod_table->GfxclkVolt1 = od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].default_value\n\t\t\t* VOLTAGE_SCALE;\n\n\t\tPP_ASSERT_WITH_CODE(!vega20_od8_get_gfx_clock_base_voltage(hwmgr,\n\t\t\t\t   &(od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].default_value),\n\t\t\t\t     od_table->GfxclkFreq2),\n\t\t\t\t\"[PhwVega20_OD8_InitializeDefaultSettings] Failed to get Base clock voltage from SMU!\",\n\t\t\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].default_value = 0);\n\t\tod_table->GfxclkVolt2 = od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].default_value\n\t\t\t* VOLTAGE_SCALE;\n\n\t\tPP_ASSERT_WITH_CODE(!vega20_od8_get_gfx_clock_base_voltage(hwmgr,\n\t\t\t\t   &(od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].default_value),\n\t\t\t\t     od_table->GfxclkFreq3),\n\t\t\t\t\"[PhwVega20_OD8_InitializeDefaultSettings] Failed to get Base clock voltage from SMU!\",\n\t\t\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].default_value = 0);\n\t\tod_table->GfxclkVolt3 = od8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].default_value\n\t\t\t* VOLTAGE_SCALE;\n\t} else {\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ1].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE1].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ2].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE2].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_FREQ3].default_value =\n\t\t\t0;\n\t\tod8_settings->od8_settings_array[OD8_SETTING_GFXCLK_VOLTAGE3].default_value =\n\t\t\t0;\n\t}\n\n\tif (od8_settings->overdrive8_capabilities & OD8_UCLK_MAX)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_UCLK_FMAX].default_value =\n\t\t\tod_table->UclkFmax;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_UCLK_FMAX].default_value =\n\t\t\t0;\n\n\tif (od8_settings->overdrive8_capabilities & OD8_POWER_LIMIT)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_POWER_PERCENTAGE].default_value =\n\t\t\tod_table->OverDrivePct;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_POWER_PERCENTAGE].default_value =\n\t\t\t0;\n\n\tif (od8_settings->overdrive8_capabilities & OD8_ACOUSTIC_LIMIT_SCLK)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_ACOUSTIC_LIMIT].default_value =\n\t\t\tod_table->FanMaximumRpm;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_ACOUSTIC_LIMIT].default_value =\n\t\t\t0;\n\n\tif (od8_settings->overdrive8_capabilities & OD8_FAN_SPEED_MIN)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_MIN_SPEED].default_value =\n\t\t\tod_table->FanMinimumPwm * data->smc_state_table.pp_table.FanMaximumRpm / 100;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_MIN_SPEED].default_value =\n\t\t\t0;\n\n\tif (od8_settings->overdrive8_capabilities & OD8_TEMPERATURE_FAN)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_TARGET_TEMP].default_value =\n\t\t\tod_table->FanTargetTemperature;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_FAN_TARGET_TEMP].default_value =\n\t\t\t0;\n\n\tif (od8_settings->overdrive8_capabilities & OD8_TEMPERATURE_SYSTEM)\n\t\tod8_settings->od8_settings_array[OD8_SETTING_OPERATING_TEMP_MAX].default_value =\n\t\t\tod_table->MaxOpTemp;\n\telse\n\t\tod8_settings->od8_settings_array[OD8_SETTING_OPERATING_TEMP_MAX].default_value =\n\t\t\t0;\n\n\tfor (i = 0; i < OD8_SETTING_COUNT; i++) {\n\t\tif (od8_settings->od8_settings_array[i].feature_id) {\n\t\t\tod8_settings->od8_settings_array[i].min_value =\n\t\t\t\tpptable_information->od_settings_min[i];\n\t\t\tod8_settings->od8_settings_array[i].max_value =\n\t\t\t\tpptable_information->od_settings_max[i];\n\t\t\tod8_settings->od8_settings_array[i].current_value =\n\t\t\t\tod8_settings->od8_settings_array[i].default_value;\n\t\t} else {\n\t\t\tod8_settings->od8_settings_array[i].min_value =\n\t\t\t\t0;\n\t\t\tod8_settings->od8_settings_array[i].max_value =\n\t\t\t\t0;\n\t\t\tod8_settings->od8_settings_array[i].current_value =\n\t\t\t\t0;\n\t\t}\n\t}\n\n\tret = smum_smc_table_manager(hwmgr, (uint8_t *)od_table, TABLE_OVERDRIVE, false);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to import over drive table!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_od8_set_settings(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t index,\n\t\tuint32_t value)\n{\n\tOverDriveTable_t od_table;\n\tint ret = 0;\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_od8_single_setting *od8_settings =\n\t\t\tdata->od8_settings.od8_settings_array;\n\n\tret = smum_smc_table_manager(hwmgr, (uint8_t *)(&od_table), TABLE_OVERDRIVE, true);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to export over drive table!\",\n\t\t\treturn ret);\n\n\tswitch (index) {\n\tcase OD8_SETTING_GFXCLK_FMIN:\n\t\tod_table.GfxclkFmin = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_FMAX:\n\t\tif (value < od8_settings[OD8_SETTING_GFXCLK_FMAX].min_value ||\n\t\t    value > od8_settings[OD8_SETTING_GFXCLK_FMAX].max_value)\n\t\t\treturn -EINVAL;\n\n\t\tod_table.GfxclkFmax = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_FREQ1:\n\t\tod_table.GfxclkFreq1 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_VOLTAGE1:\n\t\tod_table.GfxclkVolt1 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_FREQ2:\n\t\tod_table.GfxclkFreq2 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_VOLTAGE2:\n\t\tod_table.GfxclkVolt2 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_FREQ3:\n\t\tod_table.GfxclkFreq3 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_GFXCLK_VOLTAGE3:\n\t\tod_table.GfxclkVolt3 = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_UCLK_FMAX:\n\t\tif (value < od8_settings[OD8_SETTING_UCLK_FMAX].min_value ||\n\t\t    value > od8_settings[OD8_SETTING_UCLK_FMAX].max_value)\n\t\t\treturn -EINVAL;\n\t\tod_table.UclkFmax = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_POWER_PERCENTAGE:\n\t\tod_table.OverDrivePct = (int16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_FAN_ACOUSTIC_LIMIT:\n\t\tod_table.FanMaximumRpm = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_FAN_MIN_SPEED:\n\t\tod_table.FanMinimumPwm = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_FAN_TARGET_TEMP:\n\t\tod_table.FanTargetTemperature = (uint16_t)value;\n\t\tbreak;\n\tcase OD8_SETTING_OPERATING_TEMP_MAX:\n\t\tod_table.MaxOpTemp = (uint16_t)value;\n\t\tbreak;\n\t}\n\n\tret = smum_smc_table_manager(hwmgr, (uint8_t *)(&od_table), TABLE_OVERDRIVE, false);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to import over drive table!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_get_sclk_od(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = hwmgr->backend;\n\tstruct vega20_single_dpm_table *sclk_table =\n\t\t\t&(data->dpm_table.gfx_table);\n\tstruct vega20_single_dpm_table *golden_sclk_table =\n\t\t\t&(data->golden_dpm_table.gfx_table);\n\tint value = sclk_table->dpm_levels[sclk_table->count - 1].value;\n\tint golden_value = golden_sclk_table->dpm_levels\n\t\t\t[golden_sclk_table->count - 1].value;\n\n\t \n\tvalue -= golden_value;\n\tvalue = DIV_ROUND_UP(value * 100, golden_value);\n\n\treturn value;\n}\n\nstatic int vega20_set_sclk_od(\n\t\tstruct pp_hwmgr *hwmgr, uint32_t value)\n{\n\tstruct vega20_hwmgr *data = hwmgr->backend;\n\tstruct vega20_single_dpm_table *golden_sclk_table =\n\t\t\t&(data->golden_dpm_table.gfx_table);\n\tuint32_t od_sclk;\n\tint ret = 0;\n\n\tod_sclk = golden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value * value;\n\tod_sclk /= 100;\n\tod_sclk += golden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value;\n\n\tret = vega20_od8_set_settings(hwmgr, OD8_SETTING_GFXCLK_FMAX, od_sclk);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetSclkOD] failed to set od gfxclk!\",\n\t\t\treturn ret);\n\n\t \n\tret = vega20_setup_gfxclk_dpm_table(hwmgr);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetSclkOD] failed to refresh gfxclk table!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_get_mclk_od(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = hwmgr->backend;\n\tstruct vega20_single_dpm_table *mclk_table =\n\t\t\t&(data->dpm_table.mem_table);\n\tstruct vega20_single_dpm_table *golden_mclk_table =\n\t\t\t&(data->golden_dpm_table.mem_table);\n\tint value = mclk_table->dpm_levels[mclk_table->count - 1].value;\n\tint golden_value = golden_mclk_table->dpm_levels\n\t\t\t[golden_mclk_table->count - 1].value;\n\n\t \n\tvalue -= golden_value;\n\tvalue = DIV_ROUND_UP(value * 100, golden_value);\n\n\treturn value;\n}\n\nstatic int vega20_set_mclk_od(\n\t\tstruct pp_hwmgr *hwmgr, uint32_t value)\n{\n\tstruct vega20_hwmgr *data = hwmgr->backend;\n\tstruct vega20_single_dpm_table *golden_mclk_table =\n\t\t\t&(data->golden_dpm_table.mem_table);\n\tuint32_t od_mclk;\n\tint ret = 0;\n\n\tod_mclk = golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value * value;\n\tod_mclk /= 100;\n\tod_mclk += golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value;\n\n\tret = vega20_od8_set_settings(hwmgr, OD8_SETTING_UCLK_FMAX, od_mclk);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetMclkOD] failed to set od memclk!\",\n\t\t\treturn ret);\n\n\t \n\tret = vega20_setup_memclk_dpm_table(hwmgr);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[SetMclkOD] failed to refresh memclk table!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic void vega20_populate_umdpstate_clocks(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *gfx_table = &(data->dpm_table.gfx_table);\n\tstruct vega20_single_dpm_table *mem_table = &(data->dpm_table.mem_table);\n\n\tif (gfx_table->count > VEGA20_UMD_PSTATE_GFXCLK_LEVEL &&\n\t    mem_table->count > VEGA20_UMD_PSTATE_MCLK_LEVEL) {\n\t\thwmgr->pstate_sclk = gfx_table->dpm_levels[VEGA20_UMD_PSTATE_GFXCLK_LEVEL].value;\n\t\thwmgr->pstate_mclk = mem_table->dpm_levels[VEGA20_UMD_PSTATE_MCLK_LEVEL].value;\n\t} else {\n\t\thwmgr->pstate_sclk = gfx_table->dpm_levels[0].value;\n\t\thwmgr->pstate_mclk = mem_table->dpm_levels[0].value;\n\t}\n\n\thwmgr->pstate_sclk_peak = gfx_table->dpm_levels[gfx_table->count - 1].value;\n\thwmgr->pstate_mclk_peak = mem_table->dpm_levels[mem_table->count - 1].value;\n}\n\nstatic int vega20_get_max_sustainable_clock(struct pp_hwmgr *hwmgr,\n\t\tPP_Clock *clock, PPCLK_e clock_select)\n{\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetDcModeMaxDpmFreq,\n\t\t\t(clock_select << 16),\n\t\t\tclock)) == 0,\n\t\t\t\"[GetMaxSustainableClock] Failed to get max DC clock from SMC!\",\n\t\t\treturn ret);\n\n\t \n\tif (*clock == 0) {\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetMaxDpmFreq,\n\t\t\t(clock_select << 16),\n\t\t\tclock)) == 0,\n\t\t\t\"[GetMaxSustainableClock] failed to get max AC clock from SMC!\",\n\t\t\treturn ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_init_max_sustainable_clocks(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_max_sustainable_clocks *max_sustainable_clocks =\n\t\t&(data->max_sustainable_clocks);\n\tint ret = 0;\n\n\tmax_sustainable_clocks->uclock = data->vbios_boot_state.mem_clock / 100;\n\tmax_sustainable_clocks->soc_clock = data->vbios_boot_state.soc_clock / 100;\n\tmax_sustainable_clocks->dcef_clock = data->vbios_boot_state.dcef_clock / 100;\n\tmax_sustainable_clocks->display_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->phy_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->pixel_clock = 0xFFFFFFFF;\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled)\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->uclock),\n\t\t\t\tPPCLK_UCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max UCLK from SMC!\",\n\t\t\t\treturn ret);\n\n\tif (data->smu_features[GNLD_DPM_SOCCLK].enabled)\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->soc_clock),\n\t\t\t\tPPCLK_SOCCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max SOCCLK from SMC!\",\n\t\t\t\treturn ret);\n\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->dcef_clock),\n\t\t\t\tPPCLK_DCEFCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max DCEFCLK from SMC!\",\n\t\t\t\treturn ret);\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->display_clock),\n\t\t\t\tPPCLK_DISPCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max DISPCLK from SMC!\",\n\t\t\t\treturn ret);\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->phy_clock),\n\t\t\t\tPPCLK_PHYCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max PHYCLK from SMC!\",\n\t\t\t\treturn ret);\n\t\tPP_ASSERT_WITH_CODE((ret = vega20_get_max_sustainable_clock(hwmgr,\n\t\t\t\t&(max_sustainable_clocks->pixel_clock),\n\t\t\t\tPPCLK_PIXCLK)) == 0,\n\t\t\t\t\"[InitMaxSustainableClocks] failed to get max PIXCLK from SMC!\",\n\t\t\t\treturn ret);\n\t}\n\n\tif (max_sustainable_clocks->soc_clock < max_sustainable_clocks->uclock)\n\t\tmax_sustainable_clocks->uclock = max_sustainable_clocks->soc_clock;\n\n\treturn 0;\n}\n\nstatic int vega20_enable_mgpu_fan_boost(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\n\tresult = smum_send_msg_to_smc(hwmgr,\n\t\tPPSMC_MSG_SetMGpuFanBoostLimitRpm,\n\t\tNULL);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableMgpuFan] Failed to enable mgpu fan boost!\",\n\t\t\treturn result);\n\n\treturn 0;\n}\n\nstatic void vega20_init_powergate_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\n\tdata->uvd_power_gated = true;\n\tdata->vce_power_gated = true;\n}\n\nstatic int vega20_enable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_NumOfDisplays, 0, NULL);\n\n\tresult = vega20_set_allowed_featuresmask(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to set allowed featuresmask!\\n\",\n\t\t\treturn result);\n\n\tresult = vega20_init_smc_table(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to initialize SMC table!\",\n\t\t\treturn result);\n\n\tresult = vega20_run_btc(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to run btc!\",\n\t\t\treturn result);\n\n\tresult = vega20_run_btc_afll(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to run btc afll!\",\n\t\t\treturn result);\n\n\tresult = vega20_enable_all_smu_features(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to enable all smu features!\",\n\t\t\treturn result);\n\n\tresult = vega20_override_pcie_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to override pcie parameters!\",\n\t\t\treturn result);\n\n\tresult = vega20_notify_smc_display_change(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to notify smc display change!\",\n\t\t\treturn result);\n\n\tresult = vega20_send_clock_ratio(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to send clock ratio!\",\n\t\t\treturn result);\n\n\t \n\tvega20_init_powergate_state(hwmgr);\n\n\tresult = vega20_setup_default_dpm_tables(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to setup default DPM tables!\",\n\t\t\treturn result);\n\n\tresult = vega20_init_max_sustainable_clocks(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to get maximum sustainable clocks!\",\n\t\t\treturn result);\n\n\tresult = vega20_power_control_set_level(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to power control set level!\",\n\t\t\treturn result);\n\n\tresult = vega20_od8_initialize_default_settings(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[EnableDPMTasks] Failed to initialize odn settings!\",\n\t\t\treturn result);\n\n\tvega20_populate_umdpstate_clocks(hwmgr);\n\n\tresult = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetPptLimit,\n\t\t\tPOWER_SOURCE_AC << 16, &hwmgr->default_power_limit);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"[GetPptLimit] get default PPT limit failed!\",\n\t\t\treturn result);\n\thwmgr->power_limit =\n\t\thwmgr->default_power_limit;\n\n\treturn 0;\n}\n\nstatic uint32_t vega20_find_lowest_dpm_level(\n\t\tstruct vega20_single_dpm_table *table)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (table->dpm_levels[i].enabled)\n\t\t\tbreak;\n\t}\n\tif (i >= table->count) {\n\t\ti = 0;\n\t\ttable->dpm_levels[i].enabled = true;\n\t}\n\n\treturn i;\n}\n\nstatic uint32_t vega20_find_highest_dpm_level(\n\t\tstruct vega20_single_dpm_table *table)\n{\n\tint i = 0;\n\n\tPP_ASSERT_WITH_CODE(table != NULL,\n\t\t\t\"[FindHighestDPMLevel] DPM Table does not exist!\",\n\t\t\treturn 0);\n\tPP_ASSERT_WITH_CODE(table->count > 0,\n\t\t\t\"[FindHighestDPMLevel] DPM Table has no entry!\",\n\t\t\treturn 0);\n\tPP_ASSERT_WITH_CODE(table->count <= MAX_REGULAR_DPM_NUMBER,\n\t\t\t\"[FindHighestDPMLevel] DPM Table has too many entries!\",\n\t\t\treturn MAX_REGULAR_DPM_NUMBER - 1);\n\n\tfor (i = table->count - 1; i >= 0; i--) {\n\t\tif (table->dpm_levels[i].enabled)\n\t\t\tbreak;\n\t}\n\tif (i < 0) {\n\t\ti = 0;\n\t\ttable->dpm_levels[i].enabled = true;\n\t}\n\n\treturn i;\n}\n\nstatic int vega20_upload_dpm_min_level(struct pp_hwmgr *hwmgr, uint32_t feature_mask)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t min_freq;\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_GFXCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_GFXCLK_MASK)) {\n\t\tmin_freq = data->dpm_table.gfx_table.dpm_state.soft_min_level;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_GFXCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min gfxclk !\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_UCLK_MASK)) {\n\t\tmin_freq = data->dpm_table.mem_table.dpm_state.soft_min_level;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_UCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min memclk !\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UVD].enabled &&\n\t   (feature_mask & FEATURE_DPM_UVD_MASK)) {\n\t\tmin_freq = data->dpm_table.vclk_table.dpm_state.soft_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_VCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min vclk!\",\n\t\t\t\t\treturn ret);\n\n\t\tmin_freq = data->dpm_table.dclk_table.dpm_state.soft_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_DCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min dclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_VCE].enabled &&\n\t   (feature_mask & FEATURE_DPM_VCE_MASK)) {\n\t\tmin_freq = data->dpm_table.eclk_table.dpm_state.soft_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_ECLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min eclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_SOCCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_SOCCLK_MASK)) {\n\t\tmin_freq = data->dpm_table.soc_table.dpm_state.soft_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_SOCCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min socclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_FCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_FCLK_MASK)) {\n\t\tmin_freq = data->dpm_table.fclk_table.dpm_state.soft_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t\t(PPCLK_FCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft min fclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_DCEFCLK_MASK)) {\n\t\tmin_freq = data->dpm_table.dcef_table.dpm_state.hard_min_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetHardMinByFreq,\n\t\t\t\t\t(PPCLK_DCEFCLK << 16) | (min_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set hard min dcefclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_upload_dpm_max_level(struct pp_hwmgr *hwmgr, uint32_t feature_mask)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t max_freq;\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_GFXCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_GFXCLK_MASK)) {\n\t\tmax_freq = data->dpm_table.gfx_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_GFXCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max gfxclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_UCLK_MASK)) {\n\t\tmax_freq = data->dpm_table.mem_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_UCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max memclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UVD].enabled &&\n\t   (feature_mask & FEATURE_DPM_UVD_MASK)) {\n\t\tmax_freq = data->dpm_table.vclk_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_VCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max vclk!\",\n\t\t\t\t\treturn ret);\n\n\t\tmax_freq = data->dpm_table.dclk_table.dpm_state.soft_max_level;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_DCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max dclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_VCE].enabled &&\n\t   (feature_mask & FEATURE_DPM_VCE_MASK)) {\n\t\tmax_freq = data->dpm_table.eclk_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_ECLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max eclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_SOCCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_SOCCLK_MASK)) {\n\t\tmax_freq = data->dpm_table.soc_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_SOCCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max socclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\tif (data->smu_features[GNLD_DPM_FCLK].enabled &&\n\t   (feature_mask & FEATURE_DPM_FCLK_MASK)) {\n\t\tmax_freq = data->dpm_table.fclk_table.dpm_state.soft_max_level;\n\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t(PPCLK_FCLK << 16) | (max_freq & 0xffff),\n\t\t\t\t\tNULL)),\n\t\t\t\t\t\"Failed to set soft max fclk!\",\n\t\t\t\t\treturn ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_enable_disable_vce_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_VCE].supported) {\n\t\tif (data->smu_features[GNLD_DPM_VCE].enabled == enable) {\n\t\t\tif (enable)\n\t\t\t\tPP_DBG_LOG(\"[EnableDisableVCEDPM] feature VCE DPM already enabled!\\n\");\n\t\t\telse\n\t\t\t\tPP_DBG_LOG(\"[EnableDisableVCEDPM] feature VCE DPM already disabled!\\n\");\n\t\t}\n\n\t\tret = vega20_enable_smc_features(hwmgr,\n\t\t\t\tenable,\n\t\t\t\tdata->smu_features[GNLD_DPM_VCE].smu_feature_bitmap);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to Enable/Disable DPM VCE Failed!\",\n\t\t\t\treturn ret);\n\t\tdata->smu_features[GNLD_DPM_VCE].enabled = enable;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_get_clock_ranges(struct pp_hwmgr *hwmgr,\n\t\tuint32_t *clock,\n\t\tPPCLK_e clock_select,\n\t\tbool max)\n{\n\tint ret;\n\t*clock = 0;\n\n\tif (max) {\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_GetMaxDpmFreq, (clock_select << 16),\n\t\t\t\tclock)) == 0,\n\t\t\t\t\"[GetClockRanges] Failed to get max clock from SMC!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_GetMinDpmFreq,\n\t\t\t\t(clock_select << 16),\n\t\t\t\tclock)) == 0,\n\t\t\t\t\"[GetClockRanges] Failed to get min clock from SMC!\",\n\t\t\t\treturn ret);\n\t}\n\n\treturn 0;\n}\n\nstatic uint32_t vega20_dpm_get_sclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t gfx_clk;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE(data->smu_features[GNLD_DPM_GFXCLK].enabled,\n\t\t\t\"[GetSclks]: gfxclk dpm not enabled!\\n\",\n\t\t\treturn -EPERM);\n\n\tif (low) {\n\t\tret = vega20_get_clock_ranges(hwmgr, &gfx_clk, PPCLK_GFXCLK, false);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetSclks]: fail to get min PPCLK_GFXCLK\\n\",\n\t\t\treturn ret);\n\t} else {\n\t\tret = vega20_get_clock_ranges(hwmgr, &gfx_clk, PPCLK_GFXCLK, true);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetSclks]: fail to get max PPCLK_GFXCLK\\n\",\n\t\t\treturn ret);\n\t}\n\n\treturn (gfx_clk * 100);\n}\n\nstatic uint32_t vega20_dpm_get_mclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t mem_clk;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE(data->smu_features[GNLD_DPM_UCLK].enabled,\n\t\t\t\"[MemMclks]: memclk dpm not enabled!\\n\",\n\t\t\treturn -EPERM);\n\n\tif (low) {\n\t\tret = vega20_get_clock_ranges(hwmgr, &mem_clk, PPCLK_UCLK, false);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetMclks]: fail to get min PPCLK_UCLK\\n\",\n\t\t\treturn ret);\n\t} else {\n\t\tret = vega20_get_clock_ranges(hwmgr, &mem_clk, PPCLK_UCLK, true);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[GetMclks]: fail to get max PPCLK_UCLK\\n\",\n\t\t\treturn ret);\n\t}\n\n\treturn (mem_clk * 100);\n}\n\nstatic int vega20_get_metrics_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t    SmuMetrics_t *metrics_table,\n\t\t\t\t    bool bypass_cache)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tif (bypass_cache ||\n\t    !data->metrics_time ||\n\t    time_after(jiffies, data->metrics_time + msecs_to_jiffies(1))) {\n\t\tret = smum_smc_table_manager(hwmgr,\n\t\t\t\t\t     (uint8_t *)(&data->metrics_table),\n\t\t\t\t\t     TABLE_SMU_METRICS,\n\t\t\t\t\t     true);\n\t\tif (ret) {\n\t\t\tpr_info(\"Failed to export SMU metrics table!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->metrics_time = jiffies;\n\t}\n\n\tif (metrics_table)\n\t\tmemcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t));\n\n\treturn ret;\n}\n\nstatic int vega20_get_gpu_power(struct pp_hwmgr *hwmgr, int idx,\n\t\tuint32_t *query)\n{\n\tint ret = 0;\n\tSmuMetrics_t metrics_table;\n\n\tret = vega20_get_metrics_table(hwmgr, &metrics_table, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tif (hwmgr->smu_version == 0x282e00)\n\t\t\t*query = metrics_table.AverageSocketPower << 8;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\t*query = metrics_table.CurrSocketPower << 8;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_get_current_clk_freq(struct pp_hwmgr *hwmgr,\n\t\tPPCLK_e clk_id, uint32_t *clk_freq)\n{\n\tint ret = 0;\n\n\t*clk_freq = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_GetDpmClockFreq, (clk_id << 16),\n\t\t\tclk_freq)) == 0,\n\t\t\t\"[GetCurrentClkFreq] Attempt to get Current Frequency Failed!\",\n\t\t\treturn ret);\n\n\t*clk_freq = *clk_freq * 100;\n\n\treturn 0;\n}\n\nstatic int vega20_get_current_activity_percent(struct pp_hwmgr *hwmgr,\n\t\tint idx,\n\t\tuint32_t *activity_percent)\n{\n\tint ret = 0;\n\tSmuMetrics_t metrics_table;\n\n\tret = vega20_get_metrics_table(hwmgr, &metrics_table, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\t*activity_percent = metrics_table.AverageGfxActivity;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\t*activity_percent = metrics_table.AverageUclkActivity;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid index for retrieving clock activity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_read_sensor(struct pp_hwmgr *hwmgr, int idx,\n\t\t\t      void *value, int *size)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tSmuMetrics_t metrics_table;\n\tuint32_t val_vid;\n\tint ret = 0;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = vega20_get_metrics_table(hwmgr, &metrics_table, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*((uint32_t *)value) = metrics_table.AverageGfxclkFrequency * 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr,\n\t\t\t\tPPCLK_UCLK,\n\t\t\t\t(uint32_t *)value);\n\t\tif (!ret)\n\t\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = vega20_get_current_activity_percent(hwmgr, idx, (uint32_t *)value);\n\t\tif (!ret)\n\t\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\t*((uint32_t *)value) = vega20_thermal_get_temperature(hwmgr);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = vega20_get_metrics_table(hwmgr, &metrics_table, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*((uint32_t *)value) = metrics_table.TemperatureEdge *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = vega20_get_metrics_table(hwmgr, &metrics_table, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*((uint32_t *)value) = metrics_table.TemperatureHBM *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_UVD_POWER:\n\t\t*((uint32_t *)value) = data->uvd_power_gated ? 0 : 1;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VCE_POWER:\n\t\t*((uint32_t *)value) = data->vce_power_gated ? 0 : 1;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\t*size = 16;\n\t\tret = vega20_get_gpu_power(hwmgr, idx, (uint32_t *)value);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tval_vid = (RREG32_SOC15(SMUIO, 0, mmSMUSVI0_TEL_PLANE0) &\n\t\t\tSMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR_MASK) >>\n\t\t\tSMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR__SHIFT;\n\t\t*((uint32_t *)value) =\n\t\t\t(uint32_t)convert_to_vddc((uint8_t)val_vid);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_ENABLED_SMC_FEATURES_MASK:\n\t\tret = vega20_get_enabled_smc_features(hwmgr, (uint64_t *)value);\n\t\tif (!ret)\n\t\t\t*size = 8;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int vega20_display_clock_voltage_request(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_display_clock_request *clock_req)\n{\n\tint result = 0;\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tenum amd_pp_clock_type clk_type = clock_req->clock_type;\n\tuint32_t clk_freq = clock_req->clock_freq_in_khz / 1000;\n\tPPCLK_e clk_select = 0;\n\tuint32_t clk_request = 0;\n\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].enabled) {\n\t\tswitch (clk_type) {\n\t\tcase amd_pp_dcef_clock:\n\t\t\tclk_select = PPCLK_DCEFCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_disp_clock:\n\t\t\tclk_select = PPCLK_DISPCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_pixel_clock:\n\t\t\tclk_select = PPCLK_PIXCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_phy_clock:\n\t\t\tclk_select = PPCLK_PHYCLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"[DisplayClockVoltageRequest]Invalid Clock Type!\");\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!result) {\n\t\t\tclk_request = (clk_select << 16) | clk_freq;\n\t\t\tresult = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinByFreq,\n\t\t\t\t\tclk_request,\n\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int vega20_get_performance_level(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state,\n\t\t\t\tPHM_PerformanceLevelDesignation designation, uint32_t index,\n\t\t\t\tPHM_PerformanceLevel *level)\n{\n\treturn 0;\n}\n\nstatic int vega20_notify_smc_display_config_after_ps_adjustment(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table =\n\t\t\t&data->dpm_table.mem_table;\n\tstruct PP_Clocks min_clocks = {0};\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tmin_clocks.dcefClock = hwmgr->display_config->min_dcef_set_clk;\n\tmin_clocks.dcefClockInSR = hwmgr->display_config->min_dcef_deep_sleep_set_clk;\n\tmin_clocks.memoryClock = hwmgr->display_config->min_mem_set_clock;\n\n\tif (data->smu_features[GNLD_DPM_DCEFCLK].supported) {\n\t\tclock_req.clock_type = amd_pp_dcef_clock;\n\t\tclock_req.clock_freq_in_khz = min_clocks.dcefClock * 10;\n\t\tif (!vega20_display_clock_voltage_request(hwmgr, &clock_req)) {\n\t\t\tif (data->smu_features[GNLD_DS_DCEFCLK].supported)\n\t\t\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetMinDeepSleepDcefclk,\n\t\t\t\t\tmin_clocks.dcefClockInSR / 100,\n\t\t\t\t\tNULL)) == 0,\n\t\t\t\t\t\"Attempt to set divider for DCEFCLK Failed!\",\n\t\t\t\t\treturn ret);\n\t\t} else {\n\t\t\tpr_info(\"Attempt to set Hard Min for DCEFCLK Failed!\");\n\t\t}\n\t}\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled) {\n\t\tdpm_table->dpm_state.hard_min_level = min_clocks.memoryClock / 100;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetHardMinByFreq,\n\t\t\t\t(PPCLK_UCLK << 16) | dpm_table->dpm_state.hard_min_level,\n\t\t\t\tNULL)),\n\t\t\t\t\"[SetHardMinFreq] Set hard min uclk failed!\",\n\t\t\t\treturn ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_force_dpm_highest(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t soft_level;\n\tint ret = 0;\n\n\tsoft_level = vega20_find_highest_dpm_level(&(data->dpm_table.gfx_table));\n\n\tdata->dpm_table.gfx_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.gfx_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.gfx_table.dpm_levels[soft_level].value;\n\n\tsoft_level = vega20_find_highest_dpm_level(&(data->dpm_table.mem_table));\n\n\tdata->dpm_table.mem_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.mem_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.mem_table.dpm_levels[soft_level].value;\n\n\tsoft_level = vega20_find_highest_dpm_level(&(data->dpm_table.soc_table));\n\n\tdata->dpm_table.soc_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.soc_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.soc_table.dpm_levels[soft_level].value;\n\n\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to highest!\",\n\t\t\treturn ret);\n\n\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_force_dpm_lowest(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t soft_level;\n\tint ret = 0;\n\n\tsoft_level = vega20_find_lowest_dpm_level(&(data->dpm_table.gfx_table));\n\n\tdata->dpm_table.gfx_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.gfx_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.gfx_table.dpm_levels[soft_level].value;\n\n\tsoft_level = vega20_find_lowest_dpm_level(&(data->dpm_table.mem_table));\n\n\tdata->dpm_table.mem_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.mem_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.mem_table.dpm_levels[soft_level].value;\n\n\tsoft_level = vega20_find_lowest_dpm_level(&(data->dpm_table.soc_table));\n\n\tdata->dpm_table.soc_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.soc_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.soc_table.dpm_levels[soft_level].value;\n\n\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to highest!\",\n\t\t\treturn ret);\n\n\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\n\treturn 0;\n\n}\n\nstatic int vega20_unforce_dpm_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t soft_min_level, soft_max_level;\n\tint ret = 0;\n\n\t \n\tsoft_min_level =\n\t\tvega20_find_lowest_dpm_level(&(data->dpm_table.gfx_table));\n\tsoft_max_level =\n\t\tvega20_find_highest_dpm_level(&(data->dpm_table.gfx_table));\n\n\tdata->dpm_table.gfx_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.gfx_table.dpm_levels[soft_min_level].value;\n\tdata->dpm_table.gfx_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.gfx_table.dpm_levels[soft_max_level].value;\n\n\t \n\tsoft_min_level =\n\t\tvega20_find_lowest_dpm_level(&(data->dpm_table.mem_table));\n\tsoft_max_level =\n\t\tvega20_find_highest_dpm_level(&(data->dpm_table.mem_table));\n\n\tdata->dpm_table.mem_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.mem_table.dpm_levels[soft_min_level].value;\n\tdata->dpm_table.mem_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.mem_table.dpm_levels[soft_max_level].value;\n\n\t \n\tsoft_min_level =\n\t\tvega20_find_lowest_dpm_level(&(data->dpm_table.soc_table));\n\tsoft_max_level =\n\t\tvega20_find_highest_dpm_level(&(data->dpm_table.soc_table));\n\n\tdata->dpm_table.soc_table.dpm_state.soft_min_level =\n\t\tdata->dpm_table.soc_table.dpm_levels[soft_min_level].value;\n\tdata->dpm_table.soc_table.dpm_state.soft_max_level =\n\t\tdata->dpm_table.soc_table.dpm_levels[soft_max_level].value;\n\n\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload DPM Bootup Levels!\",\n\t\t\treturn ret);\n\n\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_GFXCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_UCLK_MASK |\n\t\t\t\t\t\t FEATURE_DPM_SOCCLK_MASK);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload DPM Max Levels!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_get_profiling_clk_mask(struct pp_hwmgr *hwmgr, enum amd_dpm_forced_level level,\n\t\t\t\tuint32_t *sclk_mask, uint32_t *mclk_mask, uint32_t *soc_mask)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *gfx_dpm_table = &(data->dpm_table.gfx_table);\n\tstruct vega20_single_dpm_table *mem_dpm_table = &(data->dpm_table.mem_table);\n\tstruct vega20_single_dpm_table *soc_dpm_table = &(data->dpm_table.soc_table);\n\n\t*sclk_mask = 0;\n\t*mclk_mask = 0;\n\t*soc_mask  = 0;\n\n\tif (gfx_dpm_table->count > VEGA20_UMD_PSTATE_GFXCLK_LEVEL &&\n\t    mem_dpm_table->count > VEGA20_UMD_PSTATE_MCLK_LEVEL &&\n\t    soc_dpm_table->count > VEGA20_UMD_PSTATE_SOCCLK_LEVEL) {\n\t\t*sclk_mask = VEGA20_UMD_PSTATE_GFXCLK_LEVEL;\n\t\t*mclk_mask = VEGA20_UMD_PSTATE_MCLK_LEVEL;\n\t\t*soc_mask  = VEGA20_UMD_PSTATE_SOCCLK_LEVEL;\n\t}\n\n\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK) {\n\t\t*sclk_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) {\n\t\t*mclk_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t*sclk_mask = gfx_dpm_table->count - 1;\n\t\t*mclk_mask = mem_dpm_table->count - 1;\n\t\t*soc_mask  = soc_dpm_table->count - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_force_clock_level(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, uint32_t mask)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tuint32_t soft_min_level, soft_max_level, hard_min_level;\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\t\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tif (soft_max_level >= data->dpm_table.gfx_table.count) {\n\t\t\tpr_err(\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\tsoft_max_level,\n\t\t\t\t\tdata->dpm_table.gfx_table.count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->dpm_table.gfx_table.dpm_state.soft_min_level =\n\t\t\tdata->dpm_table.gfx_table.dpm_levels[soft_min_level].value;\n\t\tdata->dpm_table.gfx_table.dpm_state.soft_max_level =\n\t\t\tdata->dpm_table.gfx_table.dpm_levels[soft_max_level].value;\n\n\t\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_GFXCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn ret);\n\n\t\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_GFXCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\t\tbreak;\n\n\tcase PP_MCLK:\n\t\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\t\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tif (soft_max_level >= data->dpm_table.mem_table.count) {\n\t\t\tpr_err(\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\tsoft_max_level,\n\t\t\t\t\tdata->dpm_table.mem_table.count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->dpm_table.mem_table.dpm_state.soft_min_level =\n\t\t\tdata->dpm_table.mem_table.dpm_levels[soft_min_level].value;\n\t\tdata->dpm_table.mem_table.dpm_state.soft_max_level =\n\t\t\tdata->dpm_table.mem_table.dpm_levels[soft_max_level].value;\n\n\t\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_UCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn ret);\n\n\t\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_UCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\n\t\tbreak;\n\n\tcase PP_SOCCLK:\n\t\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\t\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tif (soft_max_level >= data->dpm_table.soc_table.count) {\n\t\t\tpr_err(\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\tsoft_max_level,\n\t\t\t\t\tdata->dpm_table.soc_table.count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->dpm_table.soc_table.dpm_state.soft_min_level =\n\t\t\tdata->dpm_table.soc_table.dpm_levels[soft_min_level].value;\n\t\tdata->dpm_table.soc_table.dpm_state.soft_max_level =\n\t\t\tdata->dpm_table.soc_table.dpm_levels[soft_max_level].value;\n\n\t\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_SOCCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn ret);\n\n\t\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_SOCCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\n\t\tbreak;\n\n\tcase PP_FCLK:\n\t\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\t\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tif (soft_max_level >= data->dpm_table.fclk_table.count) {\n\t\t\tpr_err(\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\tsoft_max_level,\n\t\t\t\t\tdata->dpm_table.fclk_table.count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->dpm_table.fclk_table.dpm_state.soft_min_level =\n\t\t\tdata->dpm_table.fclk_table.dpm_levels[soft_min_level].value;\n\t\tdata->dpm_table.fclk_table.dpm_state.soft_max_level =\n\t\t\tdata->dpm_table.fclk_table.dpm_levels[soft_max_level].value;\n\n\t\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_FCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn ret);\n\n\t\tret = vega20_upload_dpm_max_level(hwmgr, FEATURE_DPM_FCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn ret);\n\n\t\tbreak;\n\n\tcase PP_DCEFCLK:\n\t\thard_min_level = mask ? (ffs(mask) - 1) : 0;\n\n\t\tif (hard_min_level >= data->dpm_table.dcef_table.count) {\n\t\t\tpr_err(\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\thard_min_level,\n\t\t\t\t\tdata->dpm_table.dcef_table.count - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->dpm_table.dcef_table.dpm_state.hard_min_level =\n\t\t\tdata->dpm_table.dcef_table.dpm_levels[hard_min_level].value;\n\n\t\tret = vega20_upload_dpm_min_level(hwmgr, FEATURE_DPM_DCEFCLK_MASK);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn ret);\n\n\t\t \n\n\t\tbreak;\n\n\tcase PP_PCIE:\n\t\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\t\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\t\tif (soft_min_level >= NUM_LINK_LEVELS ||\n\t\t    soft_max_level >= NUM_LINK_LEVELS)\n\t\t\treturn -EINVAL;\n\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetMinLinkDpmByIndex, soft_min_level,\n\t\t\tNULL);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"Failed to set min link dpm level!\",\n\t\t\treturn ret);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_dpm_force_dpm_level(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tint ret = 0;\n\tuint32_t sclk_mask, mclk_mask, soc_mask;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tret = vega20_force_dpm_highest(hwmgr);\n\t\tbreak;\n\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tret = vega20_force_dpm_lowest(hwmgr);\n\t\tbreak;\n\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tret = vega20_unforce_dpm_levels(hwmgr);\n\t\tbreak;\n\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tret = vega20_get_profiling_clk_mask(hwmgr, level, &sclk_mask, &mclk_mask, &soc_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvega20_force_clock_level(hwmgr, PP_SCLK, 1 << sclk_mask);\n\t\tvega20_force_clock_level(hwmgr, PP_MCLK, 1 << mclk_mask);\n\t\tvega20_force_clock_level(hwmgr, PP_SOCCLK, 1 << soc_mask);\n\t\tbreak;\n\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic uint32_t vega20_get_fan_control_mode(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\n\tif (data->smu_features[GNLD_FAN_CONTROL].enabled == false)\n\t\treturn AMD_FAN_CTRL_MANUAL;\n\telse\n\t\treturn AMD_FAN_CTRL_AUTO;\n}\n\nstatic void vega20_set_fan_control_mode(struct pp_hwmgr *hwmgr, uint32_t mode)\n{\n\tswitch (mode) {\n\tcase AMD_FAN_CTRL_NONE:\n\t\tvega20_fan_ctrl_set_fan_speed_pwm(hwmgr, 255);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_MANUAL:\n\t\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\t\tvega20_fan_ctrl_stop_smc_fan_control(hwmgr);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\t\tvega20_fan_ctrl_start_smc_fan_control(hwmgr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int vega20_get_dal_power_level(struct pp_hwmgr *hwmgr,\n\t\tstruct amd_pp_simple_clock_info *info)\n{\n#if 0\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_clock_and_voltage_limits *max_limits =\n\t\t\t&table_info->max_clock_voltage_on_ac;\n\n\tinfo->engine_max_clock = max_limits->sclk;\n\tinfo->memory_max_clock = max_limits->mclk;\n#endif\n\treturn 0;\n}\n\n\nstatic int vega20_get_sclks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table = &(data->dpm_table.gfx_table);\n\tint i, count;\n\n\tif (!data->smu_features[GNLD_DPM_GFXCLK].enabled)\n\t\treturn -1;\n\n\tcount = (dpm_table->count > MAX_NUM_CLOCKS) ? MAX_NUM_CLOCKS : dpm_table->count;\n\tclocks->num_levels = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic uint32_t vega20_get_mem_latency(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock)\n{\n\treturn 25;\n}\n\nstatic int vega20_get_memclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table = &(data->dpm_table.mem_table);\n\tint i, count;\n\n\tif (!data->smu_features[GNLD_DPM_UCLK].enabled)\n\t\treturn -1;\n\n\tcount = (dpm_table->count > MAX_NUM_CLOCKS) ? MAX_NUM_CLOCKS : dpm_table->count;\n\tclocks->num_levels = data->mclk_latency_table.count = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdata->mclk_latency_table.entries[i].frequency =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us =\n\t\t\tdata->mclk_latency_table.entries[i].latency =\n\t\t\tvega20_get_mem_latency(hwmgr, dpm_table->dpm_levels[i].value);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_get_dcefclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table = &(data->dpm_table.dcef_table);\n\tint i, count;\n\n\tif (!data->smu_features[GNLD_DPM_DCEFCLK].enabled)\n\t\treturn -1;\n\n\tcount = (dpm_table->count > MAX_NUM_CLOCKS) ? MAX_NUM_CLOCKS : dpm_table->count;\n\tclocks->num_levels = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_get_socclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table = &(data->dpm_table.soc_table);\n\tint i, count;\n\n\tif (!data->smu_features[GNLD_DPM_SOCCLK].enabled)\n\t\treturn -1;\n\n\tcount = (dpm_table->count > MAX_NUM_CLOCKS) ? MAX_NUM_CLOCKS : dpm_table->count;\n\tclocks->num_levels = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us = 0;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int vega20_get_clock_by_type_with_latency(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tint ret;\n\n\tswitch (type) {\n\tcase amd_pp_sys_clock:\n\t\tret = vega20_get_sclks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_mem_clock:\n\t\tret = vega20_get_memclocks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_dcef_clock:\n\t\tret = vega20_get_dcefclocks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_soc_clock:\n\t\tret = vega20_get_socclocks(hwmgr, clocks);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_get_clock_by_type_with_voltage(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_voltage *clocks)\n{\n\tclocks->num_levels = 0;\n\n\treturn 0;\n}\n\nstatic int vega20_set_watermarks_for_clocks_ranges(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t   void *clock_ranges)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tWatermarks_t *table = &(data->smc_state_table.water_marks_table);\n\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges = clock_ranges;\n\n\tif (!data->registry_data.disable_water_mark &&\n\t    data->smu_features[GNLD_DPM_DCEFCLK].supported &&\n\t    data->smu_features[GNLD_DPM_SOCCLK].supported) {\n\t\tsmu_set_watermarks_for_clocks_ranges(table, wm_with_clock_ranges);\n\t\tdata->water_marks_bitmap |= WaterMarksExist;\n\t\tdata->water_marks_bitmap &= ~WaterMarksLoaded;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_odn_edit_dpm_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong *input, uint32_t size)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_od8_single_setting *od8_settings =\n\t\t\tdata->od8_settings.od8_settings_array;\n\tOverDriveTable_t *od_table =\n\t\t\t&(data->smc_state_table.overdrive_table);\n\tint32_t input_clk, input_vol, i;\n\tuint32_t input_index;\n\tint od8_id;\n\tint ret;\n\n\tPP_ASSERT_WITH_CODE(input, \"NULL user input for clock and voltage\",\n\t\t\t\treturn -EINVAL);\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (!(od8_settings[OD8_SETTING_GFXCLK_FMIN].feature_id &&\n\t\t      od8_settings[OD8_SETTING_GFXCLK_FMAX].feature_id)) {\n\t\t\tpr_info(\"Sclk min/max frequency overdrive not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tpr_info(\"invalid number of input parameters %d\\n\",\n\t\t\t\t\tsize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput_index = input[i];\n\t\t\tinput_clk = input[i + 1];\n\n\t\t\tif (input_index != 0 && input_index != 1) {\n\t\t\t\tpr_info(\"Invalid index %d\\n\", input_index);\n\t\t\t\tpr_info(\"Support min/max sclk frequency setting only which index by 0/1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (input_clk < od8_settings[OD8_SETTING_GFXCLK_FMIN].min_value ||\n\t\t\t    input_clk > od8_settings[OD8_SETTING_GFXCLK_FMAX].max_value) {\n\t\t\t\tpr_info(\"clock freq %d is not within allowed range [%d - %d]\\n\",\n\t\t\t\t\tinput_clk,\n\t\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FMIN].min_value,\n\t\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FMAX].max_value);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif ((input_index == 0 && od_table->GfxclkFmin != input_clk) ||\n\t\t\t    (input_index == 1 && od_table->GfxclkFmax != input_clk))\n\t\t\t\tdata->gfxclk_overdrive = true;\n\n\t\t\tif (input_index == 0)\n\t\t\t\tod_table->GfxclkFmin = input_clk;\n\t\t\telse\n\t\t\t\tod_table->GfxclkFmax = input_clk;\n\t\t}\n\n\t\tbreak;\n\n\tcase PP_OD_EDIT_MCLK_VDDC_TABLE:\n\t\tif (!od8_settings[OD8_SETTING_UCLK_FMAX].feature_id) {\n\t\t\tpr_info(\"Mclk max frequency overdrive not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tpr_info(\"invalid number of input parameters %d\\n\",\n\t\t\t\t\tsize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput_index = input[i];\n\t\t\tinput_clk = input[i + 1];\n\n\t\t\tif (input_index != 1) {\n\t\t\t\tpr_info(\"Invalid index %d\\n\", input_index);\n\t\t\t\tpr_info(\"Support max Mclk frequency setting only which index by 1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (input_clk < od8_settings[OD8_SETTING_UCLK_FMAX].min_value ||\n\t\t\t    input_clk > od8_settings[OD8_SETTING_UCLK_FMAX].max_value) {\n\t\t\t\tpr_info(\"clock freq %d is not within allowed range [%d - %d]\\n\",\n\t\t\t\t\tinput_clk,\n\t\t\t\t\tod8_settings[OD8_SETTING_UCLK_FMAX].min_value,\n\t\t\t\t\tod8_settings[OD8_SETTING_UCLK_FMAX].max_value);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (input_index == 1 && od_table->UclkFmax != input_clk)\n\t\t\t\tdata->memclk_overdrive = true;\n\n\t\t\tod_table->UclkFmax = input_clk;\n\t\t}\n\n\t\tbreak;\n\n\tcase PP_OD_EDIT_VDDC_CURVE:\n\t\tif (!(od8_settings[OD8_SETTING_GFXCLK_FREQ1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ3].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE3].feature_id)) {\n\t\t\tpr_info(\"Voltage curve calibrate not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 3) {\n\t\t\tif (i + 3 > size) {\n\t\t\t\tpr_info(\"invalid number of input parameters %d\\n\",\n\t\t\t\t\tsize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinput_index = input[i];\n\t\t\tinput_clk = input[i + 1];\n\t\t\tinput_vol = input[i + 2];\n\n\t\t\tif (input_index > 2) {\n\t\t\t\tpr_info(\"Setting for point %d is not supported\\n\",\n\t\t\t\t\t\tinput_index + 1);\n\t\t\t\tpr_info(\"Three supported points index by 0, 1, 2\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tod8_id = OD8_SETTING_GFXCLK_FREQ1 + 2 * input_index;\n\t\t\tif (input_clk < od8_settings[od8_id].min_value ||\n\t\t\t    input_clk > od8_settings[od8_id].max_value) {\n\t\t\t\tpr_info(\"clock freq %d is not within allowed range [%d - %d]\\n\",\n\t\t\t\t\tinput_clk,\n\t\t\t\t\tod8_settings[od8_id].min_value,\n\t\t\t\t\tod8_settings[od8_id].max_value);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tod8_id = OD8_SETTING_GFXCLK_VOLTAGE1 + 2 * input_index;\n\t\t\tif (input_vol < od8_settings[od8_id].min_value ||\n\t\t\t    input_vol > od8_settings[od8_id].max_value) {\n\t\t\t\tpr_info(\"clock voltage %d is not within allowed range [%d - %d]\\n\",\n\t\t\t\t\tinput_vol,\n\t\t\t\t\tod8_settings[od8_id].min_value,\n\t\t\t\t\tod8_settings[od8_id].max_value);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tswitch (input_index) {\n\t\t\tcase 0:\n\t\t\t\tod_table->GfxclkFreq1 = input_clk;\n\t\t\t\tod_table->GfxclkVolt1 = input_vol * VOLTAGE_SCALE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tod_table->GfxclkFreq2 = input_clk;\n\t\t\t\tod_table->GfxclkVolt2 = input_vol * VOLTAGE_SCALE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tod_table->GfxclkFreq3 = input_clk;\n\t\t\t\tod_table->GfxclkVolt3 = input_vol * VOLTAGE_SCALE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tdata->gfxclk_overdrive = false;\n\t\tdata->memclk_overdrive = false;\n\n\t\tret = smum_smc_table_manager(hwmgr,\n\t\t\t\t\t     (uint8_t *)od_table,\n\t\t\t\t\t     TABLE_OVERDRIVE, true);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Failed to export overdrive table!\",\n\t\t\t\treturn ret);\n\t\tbreak;\n\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tret = smum_smc_table_manager(hwmgr,\n\t\t\t\t\t     (uint8_t *)od_table,\n\t\t\t\t\t     TABLE_OVERDRIVE, false);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Failed to import overdrive table!\",\n\t\t\t\treturn ret);\n\n\t\t \n\t\tif (data->gfxclk_overdrive) {\n\t\t\tdata->gfxclk_overdrive = false;\n\n\t\t\tret = vega20_setup_gfxclk_dpm_table(hwmgr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (data->memclk_overdrive) {\n\t\t\tdata->memclk_overdrive = false;\n\n\t\t\tret = vega20_setup_memclk_dpm_table(hwmgr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_set_mp1_state(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum pp_mp1_state mp1_state)\n{\n\tuint16_t msg;\n\tint ret;\n\n\tswitch (mp1_state) {\n\tcase PP_MP1_STATE_SHUTDOWN:\n\t\tmsg = PPSMC_MSG_PrepareMp1ForShutdown;\n\t\tbreak;\n\tcase PP_MP1_STATE_UNLOAD:\n\t\tmsg = PPSMC_MSG_PrepareMp1ForUnload;\n\t\tbreak;\n\tcase PP_MP1_STATE_RESET:\n\t\tmsg = PPSMC_MSG_PrepareMp1ForReset;\n\t\tbreak;\n\tcase PP_MP1_STATE_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr, msg, NULL)) == 0,\n\t\t\t    \"[PrepareMp1] Failed!\",\n\t\t\t    return ret);\n\n\treturn 0;\n}\n\nstatic int vega20_get_ppfeature_status(struct pp_hwmgr *hwmgr, char *buf)\n{\n\tstatic const char *ppfeature_name[] = {\n\t\t\t\t\"DPM_PREFETCHER\",\n\t\t\t\t\"GFXCLK_DPM\",\n\t\t\t\t\"UCLK_DPM\",\n\t\t\t\t\"SOCCLK_DPM\",\n\t\t\t\t\"UVD_DPM\",\n\t\t\t\t\"VCE_DPM\",\n\t\t\t\t\"ULV\",\n\t\t\t\t\"MP0CLK_DPM\",\n\t\t\t\t\"LINK_DPM\",\n\t\t\t\t\"DCEFCLK_DPM\",\n\t\t\t\t\"GFXCLK_DS\",\n\t\t\t\t\"SOCCLK_DS\",\n\t\t\t\t\"LCLK_DS\",\n\t\t\t\t\"PPT\",\n\t\t\t\t\"TDC\",\n\t\t\t\t\"THERMAL\",\n\t\t\t\t\"GFX_PER_CU_CG\",\n\t\t\t\t\"RM\",\n\t\t\t\t\"DCEFCLK_DS\",\n\t\t\t\t\"ACDC\",\n\t\t\t\t\"VR0HOT\",\n\t\t\t\t\"VR1HOT\",\n\t\t\t\t\"FW_CTF\",\n\t\t\t\t\"LED_DISPLAY\",\n\t\t\t\t\"FAN_CONTROL\",\n\t\t\t\t\"GFX_EDC\",\n\t\t\t\t\"GFXOFF\",\n\t\t\t\t\"CG\",\n\t\t\t\t\"FCLK_DPM\",\n\t\t\t\t\"FCLK_DS\",\n\t\t\t\t\"MP1CLK_DS\",\n\t\t\t\t\"MP0CLK_DS\",\n\t\t\t\t\"XGMI\",\n\t\t\t\t\"ECC\"};\n\tstatic const char *output_title[] = {\n\t\t\t\t\"FEATURES\",\n\t\t\t\t\"BITMASK\",\n\t\t\t\t\"ENABLEMENT\"};\n\tuint64_t features_enabled;\n\tint i;\n\tint ret = 0;\n\tint size = 0;\n\n\tphm_get_sysfs_buf(&buf, &size);\n\n\tret = vega20_get_enabled_smc_features(hwmgr, &features_enabled);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[EnableAllSmuFeatures] Failed to get enabled smc features!\",\n\t\t\treturn ret);\n\n\tsize += sysfs_emit_at(buf, size, \"Current ppfeatures: 0x%016llx\\n\", features_enabled);\n\tsize += sysfs_emit_at(buf, size, \"%-19s %-22s %s\\n\",\n\t\t\t\toutput_title[0],\n\t\t\t\toutput_title[1],\n\t\t\t\toutput_title[2]);\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tsize += sysfs_emit_at(buf, size, \"%-19s 0x%016llx %6s\\n\",\n\t\t\t\t\tppfeature_name[i],\n\t\t\t\t\t1ULL << i,\n\t\t\t\t\t(features_enabled & (1ULL << i)) ? \"Y\" : \"N\");\n\t}\n\n\treturn size;\n}\n\nstatic int vega20_set_ppfeature_status(struct pp_hwmgr *hwmgr, uint64_t new_ppfeature_masks)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tuint64_t features_enabled, features_to_enable, features_to_disable;\n\tint i, ret = 0;\n\tbool enabled;\n\n\tif (new_ppfeature_masks >= (1ULL << GNLD_FEATURES_MAX))\n\t\treturn -EINVAL;\n\n\tret = vega20_get_enabled_smc_features(hwmgr, &features_enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tfeatures_to_disable =\n\t\tfeatures_enabled & ~new_ppfeature_masks;\n\tfeatures_to_enable =\n\t\t~features_enabled & new_ppfeature_masks;\n\n\tpr_debug(\"features_to_disable 0x%llx\\n\", features_to_disable);\n\tpr_debug(\"features_to_enable 0x%llx\\n\", features_to_enable);\n\n\tif (features_to_disable) {\n\t\tret = vega20_enable_smc_features(hwmgr, false, features_to_disable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (features_to_enable) {\n\t\tret = vega20_enable_smc_features(hwmgr, true, features_to_enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = vega20_get_enabled_smc_features(hwmgr, &features_enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tenabled = (features_enabled & data->smu_features[i].smu_feature_bitmap) ?\n\t\t\ttrue : false;\n\t\tdata->smu_features[i].enabled = enabled;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_get_current_pcie_link_width_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_LINK_WIDTH_CNTL) &\n\t\tPCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK)\n\t\t>> PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT;\n}\n\nstatic int vega20_get_current_pcie_link_width(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t width_level;\n\n\twidth_level = vega20_get_current_pcie_link_width_level(hwmgr);\n\tif (width_level > LINK_WIDTH_MAX)\n\t\twidth_level = 0;\n\n\treturn link_width[width_level];\n}\n\nstatic int vega20_get_current_pcie_link_speed_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_SPEED_CNTL) &\n\t\tPSWUSP0_PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK)\n\t\t>> PSWUSP0_PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\n}\n\nstatic int vega20_get_current_pcie_link_speed(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t speed_level;\n\n\tspeed_level = vega20_get_current_pcie_link_speed_level(hwmgr);\n\tif (speed_level > LINK_SPEED_MAX)\n\t\tspeed_level = 0;\n\n\treturn link_speed[speed_level];\n}\n\nstatic int vega20_print_clock_levels(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, char *buf)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_od8_single_setting *od8_settings =\n\t\t\tdata->od8_settings.od8_settings_array;\n\tOverDriveTable_t *od_table =\n\t\t\t&(data->smc_state_table.overdrive_table);\n\tPPTable_t *pptable = &(data->smc_state_table.pp_table);\n\tstruct pp_clock_levels_with_latency clocks;\n\tstruct vega20_single_dpm_table *fclk_dpm_table =\n\t\t\t&(data->dpm_table.fclk_table);\n\tint i, now, size = 0;\n\tint ret = 0;\n\tuint32_t gen_speed, lane_width, current_gen_speed, current_lane_width;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr, PPCLK_GFXCLK, &now);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to get current gfx clk Failed!\",\n\t\t\t\treturn ret);\n\n\t\tif (vega20_get_sclks(hwmgr, &clocks)) {\n\t\t\tsize += sprintf(buf + size, \"0: %uMhz * (DPM disabled)\\n\",\n\t\t\t\tnow / 100);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.data[i].clocks_in_khz == now * 10) ? \"*\" : \"\");\n\t\tbreak;\n\n\tcase PP_MCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr, PPCLK_UCLK, &now);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to get current mclk freq Failed!\",\n\t\t\t\treturn ret);\n\n\t\tif (vega20_get_memclocks(hwmgr, &clocks)) {\n\t\t\tsize += sprintf(buf + size, \"0: %uMhz * (DPM disabled)\\n\",\n\t\t\t\tnow / 100);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.data[i].clocks_in_khz == now * 10) ? \"*\" : \"\");\n\t\tbreak;\n\n\tcase PP_SOCCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr, PPCLK_SOCCLK, &now);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to get current socclk freq Failed!\",\n\t\t\t\treturn ret);\n\n\t\tif (vega20_get_socclocks(hwmgr, &clocks)) {\n\t\t\tsize += sprintf(buf + size, \"0: %uMhz * (DPM disabled)\\n\",\n\t\t\t\tnow / 100);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.data[i].clocks_in_khz == now * 10) ? \"*\" : \"\");\n\t\tbreak;\n\n\tcase PP_FCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr, PPCLK_FCLK, &now);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to get current fclk freq Failed!\",\n\t\t\t\treturn ret);\n\n\t\tfor (i = 0; i < fclk_dpm_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, fclk_dpm_table->dpm_levels[i].value,\n\t\t\t\tfclk_dpm_table->dpm_levels[i].value == (now / 100) ? \"*\" : \"\");\n\t\tbreak;\n\n\tcase PP_DCEFCLK:\n\t\tret = vega20_get_current_clk_freq(hwmgr, PPCLK_DCEFCLK, &now);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"Attempt to get current dcefclk freq Failed!\",\n\t\t\t\treturn ret);\n\n\t\tif (vega20_get_dcefclocks(hwmgr, &clocks)) {\n\t\t\tsize += sprintf(buf + size, \"0: %uMhz * (DPM disabled)\\n\",\n\t\t\t\tnow / 100);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.data[i].clocks_in_khz == now * 10) ? \"*\" : \"\");\n\t\tbreak;\n\n\tcase PP_PCIE:\n\t\tcurrent_gen_speed =\n\t\t\tvega20_get_current_pcie_link_speed_level(hwmgr);\n\t\tcurrent_lane_width =\n\t\t\tvega20_get_current_pcie_link_width_level(hwmgr);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\tgen_speed = pptable->PcieGenSpeed[i];\n\t\t\tlane_width = pptable->PcieLaneCount[i];\n\n\t\t\tsize += sprintf(buf + size, \"%d: %s %s %dMhz %s\\n\", i,\n\t\t\t\t\t(gen_speed == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(gen_speed == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(lane_width == 1) ? \"x1\" :\n\t\t\t\t\t(lane_width == 2) ? \"x2\" :\n\t\t\t\t\t(lane_width == 3) ? \"x4\" :\n\t\t\t\t\t(lane_width == 4) ? \"x8\" :\n\t\t\t\t\t(lane_width == 5) ? \"x12\" :\n\t\t\t\t\t(lane_width == 6) ? \"x16\" : \"\",\n\t\t\t\t\tpptable->LclkFreq[i],\n\t\t\t\t\t(current_gen_speed == gen_speed) &&\n\t\t\t\t\t(current_lane_width == lane_width) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\t}\n\t\tbreak;\n\n\tcase OD_SCLK:\n\t\tif (od8_settings[OD8_SETTING_GFXCLK_FMIN].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FMAX].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_SCLK\");\n\t\t\tsize += sprintf(buf + size, \"0: %10uMhz\\n\",\n\t\t\t\tod_table->GfxclkFmin);\n\t\t\tsize += sprintf(buf + size, \"1: %10uMhz\\n\",\n\t\t\t\tod_table->GfxclkFmax);\n\t\t}\n\t\tbreak;\n\n\tcase OD_MCLK:\n\t\tif (od8_settings[OD8_SETTING_UCLK_FMAX].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_MCLK\");\n\t\t\tsize += sprintf(buf + size, \"1: %10uMhz\\n\",\n\t\t\t\tod_table->UclkFmax);\n\t\t}\n\n\t\tbreak;\n\n\tcase OD_VDDC_CURVE:\n\t\tif (od8_settings[OD8_SETTING_GFXCLK_FREQ1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ3].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE3].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_VDDC_CURVE\");\n\t\t\tsize += sprintf(buf + size, \"0: %10uMhz %10dmV\\n\",\n\t\t\t\tod_table->GfxclkFreq1,\n\t\t\t\tod_table->GfxclkVolt1 / VOLTAGE_SCALE);\n\t\t\tsize += sprintf(buf + size, \"1: %10uMhz %10dmV\\n\",\n\t\t\t\tod_table->GfxclkFreq2,\n\t\t\t\tod_table->GfxclkVolt2 / VOLTAGE_SCALE);\n\t\t\tsize += sprintf(buf + size, \"2: %10uMhz %10dmV\\n\",\n\t\t\t\tod_table->GfxclkFreq3,\n\t\t\t\tod_table->GfxclkVolt3 / VOLTAGE_SCALE);\n\t\t}\n\n\t\tbreak;\n\n\tcase OD_RANGE:\n\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_RANGE\");\n\n\t\tif (od8_settings[OD8_SETTING_GFXCLK_FMIN].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FMAX].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FMIN].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FMAX].max_value);\n\t\t}\n\n\t\tif (od8_settings[OD8_SETTING_UCLK_FMAX].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"MCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_UCLK_FMAX].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_UCLK_FMAX].max_value);\n\t\t}\n\n\t\tif (od8_settings[OD8_SETTING_GFXCLK_FREQ1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_FREQ3].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE1].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE2].feature_id &&\n\t\t    od8_settings[OD8_SETTING_GFXCLK_VOLTAGE3].feature_id) {\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_SCLK[0]: %7uMhz %10uMhz\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ1].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ1].max_value);\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_VOLT[0]: %7dmV %11dmV\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE1].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE1].max_value);\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_SCLK[1]: %7uMhz %10uMhz\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ2].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ2].max_value);\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_VOLT[1]: %7dmV %11dmV\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE2].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE2].max_value);\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_SCLK[2]: %7uMhz %10uMhz\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ3].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_FREQ3].max_value);\n\t\t\tsize += sprintf(buf + size, \"VDDC_CURVE_VOLT[2]: %7dmV %11dmV\\n\",\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE3].min_value,\n\t\t\t\tod8_settings[OD8_SETTING_GFXCLK_VOLTAGE3].max_value);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn size;\n}\n\nstatic int vega20_set_uclk_to_highest_dpm_level(struct pp_hwmgr *hwmgr,\n\t\tstruct vega20_single_dpm_table *dpm_table)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_UCLK].enabled) {\n\t\tPP_ASSERT_WITH_CODE(dpm_table->count > 0,\n\t\t\t\t\"[SetUclkToHightestDpmLevel] Dpm table has no entry!\",\n\t\t\t\treturn -EINVAL);\n\t\tPP_ASSERT_WITH_CODE(dpm_table->count <= NUM_UCLK_DPM_LEVELS,\n\t\t\t\t\"[SetUclkToHightestDpmLevel] Dpm table has too many entries!\",\n\t\t\t\treturn -EINVAL);\n\n\t\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetHardMinByFreq,\n\t\t\t\t(PPCLK_UCLK << 16) | dpm_table->dpm_state.hard_min_level,\n\t\t\t\tNULL)),\n\t\t\t\t\"[SetUclkToHightestDpmLevel] Set hard min uclk failed!\",\n\t\t\t\treturn ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_set_fclk_to_highest_dpm_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table = &(data->dpm_table.fclk_table);\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_FCLK].enabled) {\n\t\tPP_ASSERT_WITH_CODE(dpm_table->count > 0,\n\t\t\t\t\"[SetFclkToHightestDpmLevel] Dpm table has no entry!\",\n\t\t\t\treturn -EINVAL);\n\t\tPP_ASSERT_WITH_CODE(dpm_table->count <= NUM_FCLK_DPM_LEVELS,\n\t\t\t\t\"[SetFclkToHightestDpmLevel] Dpm table has too many entries!\",\n\t\t\t\treturn -EINVAL);\n\n\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\tPP_ASSERT_WITH_CODE(!(ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSoftMinByFreq,\n\t\t\t\t(PPCLK_FCLK << 16) | dpm_table->dpm_state.soft_min_level,\n\t\t\t\tNULL)),\n\t\t\t\t\"[SetFclkToHightestDpmLevel] Set soft min fclk failed!\",\n\t\t\t\treturn ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int vega20_pre_display_configuration_changed_task(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_NumOfDisplays, 0, NULL);\n\n\tret = vega20_set_uclk_to_highest_dpm_level(hwmgr,\n\t\t\t&data->dpm_table.mem_table);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vega20_set_fclk_to_highest_dpm_level(hwmgr);\n}\n\nstatic int vega20_display_configuration_changed_task(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tint result = 0;\n\tWatermarks_t *wm_table = &(data->smc_state_table.water_marks_table);\n\n\tif ((data->water_marks_bitmap & WaterMarksExist) &&\n\t    !(data->water_marks_bitmap & WaterMarksLoaded)) {\n\t\tresult = smum_smc_table_manager(hwmgr,\n\t\t\t\t\t\t(uint8_t *)wm_table, TABLE_WATERMARKS, false);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to update WMTABLE!\",\n\t\t\t\treturn result);\n\t\tdata->water_marks_bitmap |= WaterMarksLoaded;\n\t}\n\n\tif ((data->water_marks_bitmap & WaterMarksExist) &&\n\t    data->smu_features[GNLD_DPM_DCEFCLK].supported &&\n\t    data->smu_features[GNLD_DPM_SOCCLK].supported) {\n\t\tresult = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_NumOfDisplays,\n\t\t\thwmgr->display_config->num_display,\n\t\t\tNULL);\n\t}\n\n\treturn result;\n}\n\nstatic int vega20_enable_disable_uvd_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tif (data->smu_features[GNLD_DPM_UVD].supported) {\n\t\tif (data->smu_features[GNLD_DPM_UVD].enabled == enable) {\n\t\t\tif (enable)\n\t\t\t\tPP_DBG_LOG(\"[EnableDisableUVDDPM] feature DPM UVD already enabled!\\n\");\n\t\t\telse\n\t\t\t\tPP_DBG_LOG(\"[EnableDisableUVDDPM] feature DPM UVD already disabled!\\n\");\n\t\t}\n\n\t\tret = vega20_enable_smc_features(hwmgr,\n\t\t\t\tenable,\n\t\t\t\tdata->smu_features[GNLD_DPM_UVD].smu_feature_bitmap);\n\t\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\t\"[EnableDisableUVDDPM] Attempt to Enable/Disable DPM UVD Failed!\",\n\t\t\t\treturn ret);\n\t\tdata->smu_features[GNLD_DPM_UVD].enabled = enable;\n\t}\n\n\treturn 0;\n}\n\nstatic void vega20_power_gate_vce(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\n\tif (data->vce_power_gated == bgate)\n\t\treturn ;\n\n\tdata->vce_power_gated = bgate;\n\tif (bgate) {\n\t\tvega20_enable_disable_vce_dpm(hwmgr, !bgate);\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\t\tAMD_PG_STATE_GATE);\n\t} else {\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\t\tAMD_PG_STATE_UNGATE);\n\t\tvega20_enable_disable_vce_dpm(hwmgr, !bgate);\n\t}\n\n}\n\nstatic void vega20_power_gate_uvd(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\n\tif (data->uvd_power_gated == bgate)\n\t\treturn ;\n\n\tdata->uvd_power_gated = bgate;\n\tvega20_enable_disable_uvd_dpm(hwmgr, !bgate);\n}\n\nstatic int vega20_apply_clocks_adjust_rules(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct vega20_single_dpm_table *dpm_table;\n\tbool vblank_too_short = false;\n\tbool disable_mclk_switching;\n\tbool disable_fclk_switching;\n\tuint32_t i, latency;\n\n\tdisable_mclk_switching = ((1 < hwmgr->display_config->num_display) &&\n\t\t\t\t!hwmgr->display_config->multi_monitor_in_sync) ||\n\t\t\t\tvblank_too_short;\n\tlatency = hwmgr->display_config->dce_tolerable_mclk_in_active_latency;\n\n\t \n\tdpm_table = &(data->dpm_table.gfx_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_GFXCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_GFXCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_GFXCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[0].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\t \n\tdpm_table = &(data->dpm_table.mem_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_MCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_MCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_MCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[0].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\t \n\tif (dpm_table->dpm_state.hard_min_level < (hwmgr->display_config->min_mem_set_clock / 100))\n\t\tdpm_table->dpm_state.hard_min_level = hwmgr->display_config->min_mem_set_clock / 100;\n\n\t \n\tif (disable_mclk_switching) {\n\t\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\tfor (i = 0; i < data->mclk_latency_table.count - 1; i++) {\n\t\t\tif (data->mclk_latency_table.entries[i].latency <= latency) {\n\t\t\t\tif (dpm_table->dpm_levels[i].value >= (hwmgr->display_config->min_mem_set_clock / 100)) {\n\t\t\t\t\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[i].value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hwmgr->display_config->nb_pstate_switch_disable)\n\t\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\n\tif ((disable_mclk_switching &&\n\t    (dpm_table->dpm_state.hard_min_level == dpm_table->dpm_levels[dpm_table->count - 1].value)) ||\n\t     hwmgr->display_config->min_mem_set_clock / 100 >= dpm_table->dpm_levels[dpm_table->count - 1].value)\n\t\tdisable_fclk_switching = true;\n\telse\n\t\tdisable_fclk_switching = false;\n\n\t \n\tdpm_table = &(data->dpm_table.fclk_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tif (hwmgr->display_config->nb_pstate_switch_disable || disable_fclk_switching)\n\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\n\t \n\tdpm_table = &(data->dpm_table.vclk_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_UVDCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_UVDCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_UVDCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\t \n\tdpm_table = &(data->dpm_table.dclk_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_UVDCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_UVDCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_UVDCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\t \n\tdpm_table = &(data->dpm_table.soc_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_SOCCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_SOCCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_SOCCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\t \n\tdpm_table = &(data->dpm_table.eclk_table);\n\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.soft_max_level = VG20_CLOCK_MAX_DEFAULT;\n\tdpm_table->dpm_state.hard_min_level = dpm_table->dpm_levels[0].value;\n\tdpm_table->dpm_state.hard_max_level = VG20_CLOCK_MAX_DEFAULT;\n\n\tif (PP_CAP(PHM_PlatformCaps_UMDPState)) {\n\t\tif (VEGA20_UMD_PSTATE_VCEMCLK_LEVEL < dpm_table->count) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_VCEMCLK_LEVEL].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[VEGA20_UMD_PSTATE_VCEMCLK_LEVEL].value;\n\t\t}\n\n\t\tif (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t\tdpm_table->dpm_state.soft_min_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t\tdpm_table->dpm_state.soft_max_level = dpm_table->dpm_levels[dpm_table->count - 1].value;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nvega20_check_smc_update_required_for_display_configuration(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tbool is_update_required = false;\n\n\tif (data->display_timing.num_existing_displays !=\n\t\t\thwmgr->display_config->num_display)\n\t\tis_update_required = true;\n\n\tif (data->registry_data.gfx_clk_deep_sleep_support &&\n\t   (data->display_timing.min_clock_in_sr !=\n\t    hwmgr->display_config->min_core_set_clock_in_sr))\n\t\tis_update_required = true;\n\n\treturn is_update_required;\n}\n\nstatic int vega20_disable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\n\tret = vega20_disable_all_smu_features(hwmgr);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[DisableDpmTasks] Failed to disable all smu features!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic int vega20_power_off_asic(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_hwmgr *data = (struct vega20_hwmgr *)(hwmgr->backend);\n\tint result;\n\n\tresult = vega20_disable_dpm_tasks(hwmgr);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"[PowerOffAsic] Failed to disable DPM!\",\n\t\t\t);\n\tdata->water_marks_bitmap &= ~(WaterMarksLoaded);\n\n\treturn result;\n}\n\nstatic int conv_power_profile_to_pplib_workload(int power_profile)\n{\n\tint pplib_workload = 0;\n\n\tswitch (power_profile) {\n\tcase PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT:\n\t\tpplib_workload = WORKLOAD_DEFAULT_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_FULLSCREEN3D:\n\t\tpplib_workload = WORKLOAD_PPLIB_FULL_SCREEN_3D_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_POWERSAVING:\n\t\tpplib_workload = WORKLOAD_PPLIB_POWER_SAVING_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_VIDEO:\n\t\tpplib_workload = WORKLOAD_PPLIB_VIDEO_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_VR:\n\t\tpplib_workload = WORKLOAD_PPLIB_VR_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_COMPUTE:\n\t\tpplib_workload = WORKLOAD_PPLIB_COMPUTE_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_CUSTOM:\n\t\tpplib_workload = WORKLOAD_PPLIB_CUSTOM_BIT;\n\t\tbreak;\n\t}\n\n\treturn pplib_workload;\n}\n\nstatic int vega20_get_power_profile_mode(struct pp_hwmgr *hwmgr, char *buf)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tuint32_t i, size = 0;\n\tuint16_t workload_type = 0;\n\tstatic const char *title[] = {\n\t\t\t\"PROFILE_INDEX(NAME)\",\n\t\t\t\"CLOCK_TYPE(NAME)\",\n\t\t\t\"FPS\",\n\t\t\t\"UseRlcBusy\",\n\t\t\t\"MinActiveFreqType\",\n\t\t\t\"MinActiveFreq\",\n\t\t\t\"BoosterFreqType\",\n\t\t\t\"BoosterFreq\",\n\t\t\t\"PD_Data_limit_c\",\n\t\t\t\"PD_Data_error_coeff\",\n\t\t\t\"PD_Data_error_rate_coeff\"};\n\tint result = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tphm_get_sysfs_buf(&buf, &size);\n\n\tsize += sysfs_emit_at(buf, size, \"%16s %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\ttitle[0], title[1], title[2], title[3], title[4], title[5],\n\t\t\ttitle[6], title[7], title[8], title[9], title[10]);\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_CUSTOM; i++) {\n\t\t \n\t\tworkload_type = conv_power_profile_to_pplib_workload(i);\n\t\tresult = vega20_get_activity_monitor_coeff(hwmgr,\n\t\t\t\t(uint8_t *)(&activity_monitor), workload_type);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"[GetPowerProfile] Failed to get activity monitor!\",\n\t\t\t\treturn result);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s:\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == hwmgr->power_profile_mode) ? \"*\" : \" \");\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t0,\n\t\t\t\"GFXCLK\",\n\t\t\tactivity_monitor.Gfx_FPS,\n\t\t\tactivity_monitor.Gfx_UseRlcBusy,\n\t\t\tactivity_monitor.Gfx_MinActiveFreqType,\n\t\t\tactivity_monitor.Gfx_MinActiveFreq,\n\t\t\tactivity_monitor.Gfx_BoosterFreqType,\n\t\t\tactivity_monitor.Gfx_BoosterFreq,\n\t\t\tactivity_monitor.Gfx_PD_Data_limit_c,\n\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t1,\n\t\t\t\"SOCCLK\",\n\t\t\tactivity_monitor.Soc_FPS,\n\t\t\tactivity_monitor.Soc_UseRlcBusy,\n\t\t\tactivity_monitor.Soc_MinActiveFreqType,\n\t\t\tactivity_monitor.Soc_MinActiveFreq,\n\t\t\tactivity_monitor.Soc_BoosterFreqType,\n\t\t\tactivity_monitor.Soc_BoosterFreq,\n\t\t\tactivity_monitor.Soc_PD_Data_limit_c,\n\t\t\tactivity_monitor.Soc_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Soc_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t2,\n\t\t\t\"UCLK\",\n\t\t\tactivity_monitor.Mem_FPS,\n\t\t\tactivity_monitor.Mem_UseRlcBusy,\n\t\t\tactivity_monitor.Mem_MinActiveFreqType,\n\t\t\tactivity_monitor.Mem_MinActiveFreq,\n\t\t\tactivity_monitor.Mem_BoosterFreqType,\n\t\t\tactivity_monitor.Mem_BoosterFreq,\n\t\t\tactivity_monitor.Mem_PD_Data_limit_c,\n\t\t\tactivity_monitor.Mem_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t3,\n\t\t\t\"FCLK\",\n\t\t\tactivity_monitor.Fclk_FPS,\n\t\t\tactivity_monitor.Fclk_UseRlcBusy,\n\t\t\tactivity_monitor.Fclk_MinActiveFreqType,\n\t\t\tactivity_monitor.Fclk_MinActiveFreq,\n\t\t\tactivity_monitor.Fclk_BoosterFreqType,\n\t\t\tactivity_monitor.Fclk_BoosterFreq,\n\t\t\tactivity_monitor.Fclk_PD_Data_limit_c,\n\t\t\tactivity_monitor.Fclk_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Fclk_PD_Data_error_rate_coeff);\n\t}\n\n\treturn size;\n}\n\nstatic int vega20_set_power_profile_mode(struct pp_hwmgr *hwmgr, long *input, uint32_t size)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tint workload_type, result = 0;\n\tuint32_t power_profile_mode = input[size];\n\n\tif (power_profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tpr_err(\"Invalid power profile mode %d\\n\", power_profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\t\tif (size == 0 && !data->is_custom_profile_set)\n\t\t\treturn -EINVAL;\n\t\tif (size < 10 && size != 0)\n\t\t\treturn -EINVAL;\n\n\t\tresult = vega20_get_activity_monitor_coeff(hwmgr,\n\t\t\t\t(uint8_t *)(&activity_monitor),\n\t\t\t\tWORKLOAD_PPLIB_CUSTOM_BIT);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"[SetPowerProfile] Failed to get activity monitor!\",\n\t\t\t\treturn result);\n\n\t\t \n\t\tif (size == 0)\n\t\t\tgoto out;\n\n\t\tswitch (input[0]) {\n\t\tcase 0:  \n\t\t\tactivity_monitor.Gfx_FPS = input[1];\n\t\t\tactivity_monitor.Gfx_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Gfx_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Gfx_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Gfx_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Gfx_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Gfx_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tactivity_monitor.Soc_FPS = input[1];\n\t\t\tactivity_monitor.Soc_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Soc_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Soc_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Soc_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Soc_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Soc_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Soc_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Soc_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tactivity_monitor.Mem_FPS = input[1];\n\t\t\tactivity_monitor.Mem_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Mem_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Mem_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Mem_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Mem_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Mem_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Mem_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tactivity_monitor.Fclk_FPS = input[1];\n\t\t\tactivity_monitor.Fclk_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Fclk_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Fclk_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Fclk_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Fclk_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Fclk_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Fclk_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Fclk_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = vega20_set_activity_monitor_coeff(hwmgr,\n\t\t\t\t(uint8_t *)(&activity_monitor),\n\t\t\t\tWORKLOAD_PPLIB_CUSTOM_BIT);\n\t\tdata->is_custom_profile_set = true;\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"[SetPowerProfile] Failed to set activity monitor!\",\n\t\t\t\treturn result);\n\t}\n\nout:\n\t \n\tworkload_type =\n\t\tconv_power_profile_to_pplib_workload(power_profile_mode);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_SetWorkloadMask,\n\t\t\t\t\t\t1 << workload_type,\n\t\t\t\t\t\tNULL);\n\n\thwmgr->power_profile_mode = power_profile_mode;\n\n\treturn 0;\n}\n\nstatic int vega20_notify_cac_buffer_info(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t virtual_addr_low,\n\t\t\t\t\tuint32_t virtual_addr_hi,\n\t\t\t\t\tuint32_t mc_addr_low,\n\t\t\t\t\tuint32_t mc_addr_hi,\n\t\t\t\t\tuint32_t size)\n{\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSystemVirtualDramAddrHigh,\n\t\t\t\t\tvirtual_addr_hi,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSystemVirtualDramAddrLow,\n\t\t\t\t\tvirtual_addr_low,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramAddrHigh,\n\t\t\t\t\tmc_addr_hi,\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramAddrLow,\n\t\t\t\t\tmc_addr_low,\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramSize,\n\t\t\t\t\tsize,\n\t\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int vega20_get_thermal_temperature_range(struct pp_hwmgr *hwmgr,\n\t\tstruct PP_TemperatureRange *thermal_data)\n{\n\tstruct phm_ppt_v3_information *pptable_information =\n\t\t(struct phm_ppt_v3_information *)hwmgr->pptable;\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\n\tmemcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));\n\n\tthermal_data->max = pp_table->TedgeLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->edge_emergency_max = (pp_table->TedgeLimit + CTF_OFFSET_EDGE) *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->hotspot_crit_max = pp_table->ThotspotLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->hotspot_emergency_max = (pp_table->ThotspotLimit + CTF_OFFSET_HOTSPOT) *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->mem_crit_max = pp_table->ThbmLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->mem_emergency_max = (pp_table->ThbmLimit + CTF_OFFSET_HBM)*\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->sw_ctf_threshold = pptable_information->us_software_shutdown_temp *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn 0;\n}\n\nstatic int vega20_smu_i2c_bus_access(struct pp_hwmgr *hwmgr, bool acquire)\n{\n\tint res;\n\n\t \n\tif (!vega20_is_smc_ram_running(hwmgr))\n\t\treturn 0;\n\n\tres = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\t  (acquire ?\n\t\t\t\t\t\t  PPSMC_MSG_RequestI2CBus :\n\t\t\t\t\t\t  PPSMC_MSG_ReleaseI2CBus),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  NULL);\n\n\tPP_ASSERT_WITH_CODE(!res, \"[SmuI2CAccessBus] Failed to access bus!\", return res);\n\treturn res;\n}\n\nstatic int vega20_set_df_cstate(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum pp_df_cstate state)\n{\n\tint ret;\n\n\t \n\tif (hwmgr->smu_version < 0x283200) {\n\t\tpr_err(\"Df cstate control is supported with 40.50 and later SMC fw!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_DFCstateControl, state,\n\t\t\t\tNULL);\n\tif (ret)\n\t\tpr_err(\"SetDfCstate failed!\\n\");\n\n\treturn ret;\n}\n\nstatic int vega20_set_xgmi_pstate(struct pp_hwmgr *hwmgr,\n\t\t\t\t  uint32_t pstate)\n{\n\tint ret;\n\n\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\t  PPSMC_MSG_SetXgmiMode,\n\t\t\t\t\t\t  pstate ? XGMI_MODE_PSTATE_D0 : XGMI_MODE_PSTATE_D3,\n\t\t\t\t\t\t  NULL);\n\tif (ret)\n\t\tpr_err(\"SetXgmiPstate failed!\\n\");\n\n\treturn ret;\n}\n\nstatic void vega20_init_gpu_metrics_v1_0(struct gpu_metrics_v1_0 *gpu_metrics)\n{\n\tmemset(gpu_metrics, 0xFF, sizeof(struct gpu_metrics_v1_0));\n\n\tgpu_metrics->common_header.structure_size =\n\t\t\t\tsizeof(struct gpu_metrics_v1_0);\n\tgpu_metrics->common_header.format_revision = 1;\n\tgpu_metrics->common_header.content_revision = 0;\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n}\n\nstatic ssize_t vega20_get_gpu_metrics(struct pp_hwmgr *hwmgr,\n\t\t\t\t      void **table)\n{\n\tstruct vega20_hwmgr *data =\n\t\t\t(struct vega20_hwmgr *)(hwmgr->backend);\n\tstruct gpu_metrics_v1_0 *gpu_metrics =\n\t\t\t&data->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tuint32_t fan_speed_rpm;\n\tint ret;\n\n\tret = vega20_get_metrics_table(hwmgr, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tvega20_init_gpu_metrics_v1_0(gpu_metrics);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureHBM;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\n\tvega20_fan_ctrl_get_fan_speed_rpm(hwmgr, &fan_speed_rpm);\n\tgpu_metrics->current_fan_speed = (uint16_t)fan_speed_rpm;\n\n\tgpu_metrics->pcie_link_width =\n\t\t\tvega20_get_current_pcie_link_width(hwmgr);\n\tgpu_metrics->pcie_link_speed =\n\t\t\tvega20_get_current_pcie_link_speed(hwmgr);\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_0);\n}\n\nstatic const struct pp_hwmgr_func vega20_hwmgr_funcs = {\n\t \n\t.backend_init = vega20_hwmgr_backend_init,\n\t.backend_fini = vega20_hwmgr_backend_fini,\n\t.asic_setup = vega20_setup_asic_task,\n\t.power_off_asic = vega20_power_off_asic,\n\t.dynamic_state_management_enable = vega20_enable_dpm_tasks,\n\t.dynamic_state_management_disable = vega20_disable_dpm_tasks,\n\t \n\t.apply_clocks_adjust_rules = vega20_apply_clocks_adjust_rules,\n\t.pre_display_config_changed = vega20_pre_display_configuration_changed_task,\n\t.display_config_changed = vega20_display_configuration_changed_task,\n\t.check_smc_update_required_for_display_configuration =\n\t\tvega20_check_smc_update_required_for_display_configuration,\n\t.notify_smc_display_config_after_ps_adjustment =\n\t\tvega20_notify_smc_display_config_after_ps_adjustment,\n\t \n\t.get_sclk = vega20_dpm_get_sclk,\n\t.get_mclk = vega20_dpm_get_mclk,\n\t.get_dal_power_level = vega20_get_dal_power_level,\n\t.get_clock_by_type_with_latency = vega20_get_clock_by_type_with_latency,\n\t.get_clock_by_type_with_voltage = vega20_get_clock_by_type_with_voltage,\n\t.set_watermarks_for_clocks_ranges = vega20_set_watermarks_for_clocks_ranges,\n\t.display_clock_voltage_request = vega20_display_clock_voltage_request,\n\t.get_performance_level = vega20_get_performance_level,\n\t \n\t.force_dpm_level = vega20_dpm_force_dpm_level,\n\t.get_power_profile_mode = vega20_get_power_profile_mode,\n\t.set_power_profile_mode = vega20_set_power_profile_mode,\n\t \n\t.set_power_limit = vega20_set_power_limit,\n\t.get_sclk_od = vega20_get_sclk_od,\n\t.set_sclk_od = vega20_set_sclk_od,\n\t.get_mclk_od = vega20_get_mclk_od,\n\t.set_mclk_od = vega20_set_mclk_od,\n\t.odn_edit_dpm_table = vega20_odn_edit_dpm_table,\n\t \n\t.force_clock_level = vega20_force_clock_level,\n\t.print_clock_levels = vega20_print_clock_levels,\n\t.read_sensor = vega20_read_sensor,\n\t.get_ppfeature_status = vega20_get_ppfeature_status,\n\t.set_ppfeature_status = vega20_set_ppfeature_status,\n\t \n\t.powergate_uvd = vega20_power_gate_uvd,\n\t.powergate_vce = vega20_power_gate_vce,\n\t \n\t.start_thermal_controller = vega20_start_thermal_controller,\n\t.stop_thermal_controller = vega20_thermal_stop_thermal_controller,\n\t.get_thermal_temperature_range = vega20_get_thermal_temperature_range,\n\t.register_irq_handlers = smu9_register_irq_handlers,\n\t.disable_smc_firmware_ctf = vega20_thermal_disable_alert,\n\t \n\t.get_fan_speed_pwm = vega20_fan_ctrl_get_fan_speed_pwm,\n\t.set_fan_speed_pwm = vega20_fan_ctrl_set_fan_speed_pwm,\n\t.get_fan_speed_info = vega20_fan_ctrl_get_fan_speed_info,\n\t.get_fan_speed_rpm = vega20_fan_ctrl_get_fan_speed_rpm,\n\t.set_fan_speed_rpm = vega20_fan_ctrl_set_fan_speed_rpm,\n\t.get_fan_control_mode = vega20_get_fan_control_mode,\n\t.set_fan_control_mode = vega20_set_fan_control_mode,\n\t \n\t.notify_cac_buffer_info = vega20_notify_cac_buffer_info,\n\t.enable_mgpu_fan_boost = vega20_enable_mgpu_fan_boost,\n\t \n\t.get_asic_baco_capability = vega20_baco_get_capability,\n\t.get_asic_baco_state = vega20_baco_get_state,\n\t.set_asic_baco_state = vega20_baco_set_state,\n\t.set_mp1_state = vega20_set_mp1_state,\n\t.smu_i2c_bus_access = vega20_smu_i2c_bus_access,\n\t.set_df_cstate = vega20_set_df_cstate,\n\t.set_xgmi_pstate = vega20_set_xgmi_pstate,\n\t.get_gpu_metrics = vega20_get_gpu_metrics,\n};\n\nint vega20_hwmgr_init(struct pp_hwmgr *hwmgr)\n{\n\thwmgr->hwmgr_func = &vega20_hwmgr_funcs;\n\thwmgr->pptable_func = &vega20_pptable_funcs;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}