{
  "module_name": "smu8_hwmgr.c",
  "hash_id": "2885c7e96a5f72fef7c0ee58d2d4de4c76ffcdb267cc6ed03da4cd56b5caaf45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"atom-types.h\"\n#include \"atombios.h\"\n#include \"processpptables.h\"\n#include \"cgs_common.h\"\n#include \"smu/smu_8_0_d.h\"\n#include \"smu8_fusion.h\"\n#include \"smu/smu_8_0_sh_mask.h\"\n#include \"smumgr.h\"\n#include \"hwmgr.h\"\n#include \"hardwaremanager.h\"\n#include \"cz_ppsmc.h\"\n#include \"smu8_hwmgr.h\"\n#include \"power_state.h\"\n#include \"pp_thermal.h\"\n\n#define ixSMUSVI_NB_CURRENTVID 0xD8230044\n#define CURRENT_NB_VID_MASK 0xff000000\n#define CURRENT_NB_VID__SHIFT 24\n#define ixSMUSVI_GFX_CURRENTVID  0xD8230048\n#define CURRENT_GFX_VID_MASK 0xff000000\n#define CURRENT_GFX_VID__SHIFT 24\n\nstatic const unsigned long smu8_magic = (unsigned long) PHM_Cz_Magic;\n\nstatic struct smu8_power_state *cast_smu8_power_state(struct pp_hw_power_state *hw_ps)\n{\n\tif (smu8_magic != hw_ps->magic)\n\t\treturn NULL;\n\n\treturn (struct smu8_power_state *)hw_ps;\n}\n\nstatic const struct smu8_power_state *cast_const_smu8_power_state(\n\t\t\t\tconst struct pp_hw_power_state *hw_ps)\n{\n\tif (smu8_magic != hw_ps->magic)\n\t\treturn NULL;\n\n\treturn (struct smu8_power_state *)hw_ps;\n}\n\nstatic uint32_t smu8_get_eclk_level(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t clock, uint32_t msg)\n{\n\tint i = 0;\n\tstruct phm_vce_clock_voltage_dependency_table *ptable =\n\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\n\tswitch (msg) {\n\tcase PPSMC_MSG_SetEclkSoftMin:\n\tcase PPSMC_MSG_SetEclkHardMin:\n\t\tfor (i = 0; i < (int)ptable->count; i++) {\n\t\t\tif (clock <= ptable->entries[i].ecclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PPSMC_MSG_SetEclkSoftMax:\n\tcase PPSMC_MSG_SetEclkHardMax:\n\t\tfor (i = ptable->count - 1; i >= 0; i--) {\n\t\t\tif (clock >= ptable->entries[i].ecclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic uint32_t smu8_get_sclk_level(struct pp_hwmgr *hwmgr,\n\t\t\t\tuint32_t clock, uint32_t msg)\n{\n\tint i = 0;\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\n\tswitch (msg) {\n\tcase PPSMC_MSG_SetSclkSoftMin:\n\tcase PPSMC_MSG_SetSclkHardMin:\n\t\tfor (i = 0; i < (int)table->count; i++) {\n\t\t\tif (clock <= table->entries[i].clk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PPSMC_MSG_SetSclkSoftMax:\n\tcase PPSMC_MSG_SetSclkHardMax:\n\t\tfor (i = table->count - 1; i >= 0; i--) {\n\t\t\tif (clock >= table->entries[i].clk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic uint32_t smu8_get_uvd_level(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t clock, uint32_t msg)\n{\n\tint i = 0;\n\tstruct phm_uvd_clock_voltage_dependency_table *ptable =\n\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\n\tswitch (msg) {\n\tcase PPSMC_MSG_SetUvdSoftMin:\n\tcase PPSMC_MSG_SetUvdHardMin:\n\t\tfor (i = 0; i < (int)ptable->count; i++) {\n\t\t\tif (clock <= ptable->entries[i].vclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PPSMC_MSG_SetUvdSoftMax:\n\tcase PPSMC_MSG_SetUvdHardMax:\n\t\tfor (i = ptable->count - 1; i >= 0; i--) {\n\t\t\tif (clock >= ptable->entries[i].vclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic uint32_t smu8_get_max_sclk_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tif (data->max_sclk_level == 0) {\n\t\tsmum_send_msg_to_smc(hwmgr,\n\t\t\t\tPPSMC_MSG_GetMaxSclkLevel,\n\t\t\t\t&data->max_sclk_level);\n\t\tdata->max_sclk_level += 1;\n\t}\n\n\treturn data->max_sclk_level;\n}\n\nstatic int smu8_initialize_dpm_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tdata->gfx_ramp_step = 256*25/100;\n\tdata->gfx_ramp_delay = 1;  \n\n\tdata->mgcg_cgtt_local0 = 0x00000000;\n\tdata->mgcg_cgtt_local1 = 0x00000000;\n\tdata->clock_slow_down_freq = 25000;\n\tdata->skip_clock_slow_down = 1;\n\tdata->enable_nb_ps_policy = 1;  \n\tdata->voltage_drop_in_dce_power_gating = 0;  \n\tdata->voting_rights_clients = 0x00C00033;\n\tdata->static_screen_threshold = 8;\n\tdata->ddi_power_gating_disabled = 0;\n\tdata->bapm_enabled = 1;\n\tdata->voltage_drop_threshold = 0;\n\tdata->gfx_power_gating_threshold = 500;\n\tdata->vce_slow_sclk_threshold = 20000;\n\tdata->dce_slow_sclk_threshold = 30000;\n\tdata->disable_driver_thermal_policy = 1;\n\tdata->disable_nb_ps3_in_battery = 0;\n\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\t\t\tPHM_PlatformCaps_ABM);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t    PHM_PlatformCaps_NonABMSupportInPPLib);\n\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_DynamicM3Arbiter);\n\n\tdata->override_dynamic_mgpg = 1;\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t  PHM_PlatformCaps_DynamicPatchPowerState);\n\n\tdata->thermal_auto_throttling_treshold = 0;\n\tdata->tdr_clock = 0;\n\tdata->disable_gfx_power_gating_in_uvd = 0;\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_DynamicUVDState);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_UVDDPM);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_VCEDPM);\n\n\tdata->cc6_settings.cpu_cc6_disable = false;\n\tdata->cc6_settings.cpu_pstate_disable = false;\n\tdata->cc6_settings.nb_pstate_switch_disable = false;\n\tdata->cc6_settings.cpu_pstate_separation_time = 0;\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t   PHM_PlatformCaps_DisableVoltageIsland);\n\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t      PHM_PlatformCaps_UVDPowerGating);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t      PHM_PlatformCaps_VCEPowerGating);\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t      PHM_PlatformCaps_UVDPowerGating);\n\tif (adev->pg_flags & AMD_PG_SUPPORT_VCE)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t      PHM_PlatformCaps_VCEPowerGating);\n\n\n\treturn 0;\n}\n\n \nstatic uint32_t smu8_convert_8Bit_index_to_voltage(\n\t\t\tstruct pp_hwmgr *hwmgr, uint16_t voltage)\n{\n\treturn 6200 - (voltage * 25);\n}\n\nstatic int smu8_construct_max_power_limits_table(struct pp_hwmgr *hwmgr,\n\t\t\tstruct phm_clock_and_voltage_limits *table)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct smu8_sys_info *sys_info = &data->sys_info;\n\tstruct phm_clock_voltage_dependency_table *dep_table =\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\n\tif (dep_table->count > 0) {\n\t\ttable->sclk = dep_table->entries[dep_table->count-1].clk;\n\t\ttable->vddc = smu8_convert_8Bit_index_to_voltage(hwmgr,\n\t\t   (uint16_t)dep_table->entries[dep_table->count-1].v);\n\t}\n\ttable->mclk = sys_info->nbp_memory_clock[0];\n\treturn 0;\n}\n\nstatic int smu8_init_dynamic_state_adjustment_rule_settings(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tATOM_CLK_VOLT_CAPABILITY *disp_voltage_table)\n{\n\tstruct phm_clock_voltage_dependency_table *table_clk_vlt;\n\n\ttable_clk_vlt = kzalloc(struct_size(table_clk_vlt, entries, 8),\n\t\t\t\tGFP_KERNEL);\n\n\tif (NULL == table_clk_vlt) {\n\t\tpr_err(\"Can not allocate memory!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttable_clk_vlt->count = 8;\n\ttable_clk_vlt->entries[0].clk = PP_DAL_POWERLEVEL_0;\n\ttable_clk_vlt->entries[0].v = 0;\n\ttable_clk_vlt->entries[1].clk = PP_DAL_POWERLEVEL_1;\n\ttable_clk_vlt->entries[1].v = 1;\n\ttable_clk_vlt->entries[2].clk = PP_DAL_POWERLEVEL_2;\n\ttable_clk_vlt->entries[2].v = 2;\n\ttable_clk_vlt->entries[3].clk = PP_DAL_POWERLEVEL_3;\n\ttable_clk_vlt->entries[3].v = 3;\n\ttable_clk_vlt->entries[4].clk = PP_DAL_POWERLEVEL_4;\n\ttable_clk_vlt->entries[4].v = 4;\n\ttable_clk_vlt->entries[5].clk = PP_DAL_POWERLEVEL_5;\n\ttable_clk_vlt->entries[5].v = 5;\n\ttable_clk_vlt->entries[6].clk = PP_DAL_POWERLEVEL_6;\n\ttable_clk_vlt->entries[6].v = 6;\n\ttable_clk_vlt->entries[7].clk = PP_DAL_POWERLEVEL_7;\n\ttable_clk_vlt->entries[7].v = 7;\n\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = table_clk_vlt;\n\n\treturn 0;\n}\n\nstatic int smu8_get_system_info_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tATOM_INTEGRATED_SYSTEM_INFO_V1_9 *info = NULL;\n\tuint32_t i;\n\tint result = 0;\n\tuint8_t frev, crev;\n\tuint16_t size;\n\n\tinfo = (ATOM_INTEGRATED_SYSTEM_INFO_V1_9 *)smu_atom_get_data_table(hwmgr->adev,\n\t\t\tGetIndexIntoMasterTable(DATA, IntegratedSystemInfo),\n\t\t\t&size, &frev, &crev);\n\n\tif (info == NULL) {\n\t\tpr_err(\"Could not retrieve the Integrated System Info Table!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (crev != 9) {\n\t\tpr_err(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sys_info.bootup_uma_clock =\n\t\t\t\t   le32_to_cpu(info->ulBootUpUMAClock);\n\n\tdata->sys_info.bootup_engine_clock =\n\t\t\t\tle32_to_cpu(info->ulBootUpEngineClock);\n\n\tdata->sys_info.dentist_vco_freq =\n\t\t\t\t   le32_to_cpu(info->ulDentistVCOFreq);\n\n\tdata->sys_info.system_config =\n\t\t\t\t     le32_to_cpu(info->ulSystemConfig);\n\n\tdata->sys_info.bootup_nb_voltage_index =\n\t\t\t\t  le16_to_cpu(info->usBootUpNBVoltage);\n\n\tdata->sys_info.htc_hyst_lmt =\n\t\t\t(info->ucHtcHystLmt == 0) ? 5 : info->ucHtcHystLmt;\n\n\tdata->sys_info.htc_tmp_lmt =\n\t\t\t(info->ucHtcTmpLmt == 0) ? 203 : info->ucHtcTmpLmt;\n\n\tif (data->sys_info.htc_tmp_lmt <=\n\t\t\tdata->sys_info.htc_hyst_lmt) {\n\t\tpr_err(\"The htcTmpLmt should be larger than htcHystLmt.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sys_info.nb_dpm_enable =\n\t\t\t\tdata->enable_nb_ps_policy &&\n\t\t\t\t(le32_to_cpu(info->ulSystemConfig) >> 3 & 0x1);\n\n\tfor (i = 0; i < SMU8_NUM_NBPSTATES; i++) {\n\t\tif (i < SMU8_NUM_NBPMEMORYCLOCK) {\n\t\t\tdata->sys_info.nbp_memory_clock[i] =\n\t\t\t  le32_to_cpu(info->ulNbpStateMemclkFreq[i]);\n\t\t}\n\t\tdata->sys_info.nbp_n_clock[i] =\n\t\t\t    le32_to_cpu(info->ulNbpStateNClkFreq[i]);\n\t}\n\n\tfor (i = 0; i < MAX_DISPLAY_CLOCK_LEVEL; i++) {\n\t\tdata->sys_info.display_clock[i] =\n\t\t\t\t\tle32_to_cpu(info->sDispClkVoltageMapping[i].ulMaximumSupportedCLK);\n\t}\n\n\t \n\tfor (i = 0; i < SMU8_NUM_NBPSTATES; i++) {\n\t\tdata->sys_info.nbp_voltage_index[i] =\n\t\t\t     le16_to_cpu(info->usNBPStateVoltage[i]);\n\t}\n\n\tif (!data->sys_info.nb_dpm_enable) {\n\t\tfor (i = 1; i < SMU8_NUM_NBPSTATES; i++) {\n\t\t\tif (i < SMU8_NUM_NBPMEMORYCLOCK) {\n\t\t\t\tdata->sys_info.nbp_memory_clock[i] =\n\t\t\t\t    data->sys_info.nbp_memory_clock[0];\n\t\t\t}\n\t\t\tdata->sys_info.nbp_n_clock[i] =\n\t\t\t\t    data->sys_info.nbp_n_clock[0];\n\t\t\tdata->sys_info.nbp_voltage_index[i] =\n\t\t\t\t    data->sys_info.nbp_voltage_index[0];\n\t\t}\n\t}\n\n\tif (le32_to_cpu(info->ulGPUCapInfo) &\n\t\tSYS_INFO_GPUCAPS__ENABEL_DFS_BYPASS) {\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t    PHM_PlatformCaps_EnableDFSBypass);\n\t}\n\n\tdata->sys_info.uma_channel_number = info->ucUMAChannelNumber;\n\n\tsmu8_construct_max_power_limits_table (hwmgr,\n\t\t\t\t    &hwmgr->dyn_state.max_clock_voltage_on_ac);\n\n\tsmu8_init_dynamic_state_adjustment_rule_settings(hwmgr,\n\t\t\t\t    &info->sDISPCLK_Voltage[0]);\n\n\treturn result;\n}\n\nstatic int smu8_construct_boot_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->boot_power_level.engineClock =\n\t\t\t\tdata->sys_info.bootup_engine_clock;\n\n\tdata->boot_power_level.vddcIndex =\n\t\t\t(uint8_t)data->sys_info.bootup_nb_voltage_index;\n\n\tdata->boot_power_level.dsDividerIndex = 0;\n\tdata->boot_power_level.ssDividerIndex = 0;\n\tdata->boot_power_level.allowGnbSlow = 1;\n\tdata->boot_power_level.forceNBPstate = 0;\n\tdata->boot_power_level.hysteresis_up = 0;\n\tdata->boot_power_level.numSIMDToPowerDown = 0;\n\tdata->boot_power_level.display_wm = 0;\n\tdata->boot_power_level.vce_wm = 0;\n\n\treturn 0;\n}\n\nstatic int smu8_upload_pptable_to_smu(struct pp_hwmgr *hwmgr)\n{\n\tstruct SMU8_Fusion_ClkTable *clock_table;\n\tint ret;\n\tuint32_t i;\n\tvoid *table = NULL;\n\tpp_atomctrl_clock_dividers_kong dividers;\n\n\tstruct phm_clock_voltage_dependency_table *vddc_table =\n\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\tstruct phm_clock_voltage_dependency_table *vdd_gfx_table =\n\t\thwmgr->dyn_state.vdd_gfx_dependency_on_sclk;\n\tstruct phm_acp_clock_voltage_dependency_table *acp_table =\n\t\thwmgr->dyn_state.acp_clock_voltage_dependency_table;\n\tstruct phm_uvd_clock_voltage_dependency_table *uvd_table =\n\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\tstruct phm_vce_clock_voltage_dependency_table *vce_table =\n\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\n\tif (!hwmgr->need_pp_table_upload)\n\t\treturn 0;\n\n\tret = smum_download_powerplay_table(hwmgr, &table);\n\n\tPP_ASSERT_WITH_CODE((0 == ret && NULL != table),\n\t\t\t    \"Fail to get clock table from SMU!\", return -EINVAL;);\n\n\tclock_table = (struct SMU8_Fusion_ClkTable *)table;\n\n\t \n\tPP_ASSERT_WITH_CODE((vddc_table->count <= SMU8_MAX_HARDWARE_POWERLEVELS),\n\t\t\t    \"Dependency table entry exceeds max limit!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE((vdd_gfx_table->count <= SMU8_MAX_HARDWARE_POWERLEVELS),\n\t\t\t    \"Dependency table entry exceeds max limit!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE((acp_table->count <= SMU8_MAX_HARDWARE_POWERLEVELS),\n\t\t\t    \"Dependency table entry exceeds max limit!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE((uvd_table->count <= SMU8_MAX_HARDWARE_POWERLEVELS),\n\t\t\t    \"Dependency table entry exceeds max limit!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE((vce_table->count <= SMU8_MAX_HARDWARE_POWERLEVELS),\n\t\t\t    \"Dependency table entry exceeds max limit!\", return -EINVAL;);\n\n\tfor (i = 0; i < SMU8_MAX_HARDWARE_POWERLEVELS; i++) {\n\n\t\t \n\t\tclock_table->SclkBreakdownTable.ClkLevel[i].GnbVid =\n\t\t\t(i < vddc_table->count) ? (uint8_t)vddc_table->entries[i].v : 0;\n\t\tclock_table->SclkBreakdownTable.ClkLevel[i].Frequency =\n\t\t\t(i < vddc_table->count) ? vddc_table->entries[i].clk : 0;\n\n\t\tatomctrl_get_engine_pll_dividers_kong(hwmgr,\n\t\t\t\t\t\t      clock_table->SclkBreakdownTable.ClkLevel[i].Frequency,\n\t\t\t\t\t\t      &dividers);\n\n\t\tclock_table->SclkBreakdownTable.ClkLevel[i].DfsDid =\n\t\t\t(uint8_t)dividers.pll_post_divider;\n\n\t\t \n\t\tclock_table->SclkBreakdownTable.ClkLevel[i].GfxVid =\n\t\t\t(i < vdd_gfx_table->count) ? (uint8_t)vdd_gfx_table->entries[i].v : 0;\n\n\t\t \n\t\tclock_table->AclkBreakdownTable.ClkLevel[i].GfxVid =\n\t\t\t(i < acp_table->count) ? (uint8_t)acp_table->entries[i].v : 0;\n\t\tclock_table->AclkBreakdownTable.ClkLevel[i].Frequency =\n\t\t\t(i < acp_table->count) ? acp_table->entries[i].acpclk : 0;\n\n\t\tatomctrl_get_engine_pll_dividers_kong(hwmgr,\n\t\t\t\t\t\t      clock_table->AclkBreakdownTable.ClkLevel[i].Frequency,\n\t\t\t\t\t\t      &dividers);\n\n\t\tclock_table->AclkBreakdownTable.ClkLevel[i].DfsDid =\n\t\t\t(uint8_t)dividers.pll_post_divider;\n\n\n\t\t \n\t\tclock_table->VclkBreakdownTable.ClkLevel[i].GfxVid =\n\t\t\t(i < uvd_table->count) ? (uint8_t)uvd_table->entries[i].v : 0;\n\t\tclock_table->VclkBreakdownTable.ClkLevel[i].Frequency =\n\t\t\t(i < uvd_table->count) ? uvd_table->entries[i].vclk : 0;\n\n\t\tatomctrl_get_engine_pll_dividers_kong(hwmgr,\n\t\t\t\t\t\t      clock_table->VclkBreakdownTable.ClkLevel[i].Frequency,\n\t\t\t\t\t\t      &dividers);\n\n\t\tclock_table->VclkBreakdownTable.ClkLevel[i].DfsDid =\n\t\t\t(uint8_t)dividers.pll_post_divider;\n\n\t\tclock_table->DclkBreakdownTable.ClkLevel[i].GfxVid =\n\t\t\t(i < uvd_table->count) ? (uint8_t)uvd_table->entries[i].v : 0;\n\t\tclock_table->DclkBreakdownTable.ClkLevel[i].Frequency =\n\t\t\t(i < uvd_table->count) ? uvd_table->entries[i].dclk : 0;\n\n\t\tatomctrl_get_engine_pll_dividers_kong(hwmgr,\n\t\t\t\t\t\t      clock_table->DclkBreakdownTable.ClkLevel[i].Frequency,\n\t\t\t\t\t\t      &dividers);\n\n\t\tclock_table->DclkBreakdownTable.ClkLevel[i].DfsDid =\n\t\t\t(uint8_t)dividers.pll_post_divider;\n\n\t\t \n\t\tclock_table->EclkBreakdownTable.ClkLevel[i].GfxVid =\n\t\t\t(i < vce_table->count) ? (uint8_t)vce_table->entries[i].v : 0;\n\t\tclock_table->EclkBreakdownTable.ClkLevel[i].Frequency =\n\t\t\t(i < vce_table->count) ? vce_table->entries[i].ecclk : 0;\n\n\n\t\tatomctrl_get_engine_pll_dividers_kong(hwmgr,\n\t\t\t\t\t\t      clock_table->EclkBreakdownTable.ClkLevel[i].Frequency,\n\t\t\t\t\t\t      &dividers);\n\n\t\tclock_table->EclkBreakdownTable.ClkLevel[i].DfsDid =\n\t\t\t(uint8_t)dividers.pll_post_divider;\n\n\t}\n\tret = smum_upload_powerplay_table(hwmgr);\n\n\treturn ret;\n}\n\nstatic int smu8_init_sclk_limit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\tunsigned long clock = 0, level;\n\n\tif (NULL == table || table->count <= 0)\n\t\treturn -EINVAL;\n\n\tdata->sclk_dpm.soft_min_clk = table->entries[0].clk;\n\tdata->sclk_dpm.hard_min_clk = table->entries[0].clk;\n\n\tlevel = smu8_get_max_sclk_level(hwmgr) - 1;\n\n\tif (level < table->count)\n\t\tclock = table->entries[level].clk;\n\telse\n\t\tclock = table->entries[table->count - 1].clk;\n\n\tdata->sclk_dpm.soft_max_clk = clock;\n\tdata->sclk_dpm.hard_max_clk = clock;\n\n\treturn 0;\n}\n\nstatic int smu8_init_uvd_limit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_uvd_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\tunsigned long clock = 0;\n\tuint32_t level;\n\n\tif (NULL == table || table->count <= 0)\n\t\treturn -EINVAL;\n\n\tdata->uvd_dpm.soft_min_clk = 0;\n\tdata->uvd_dpm.hard_min_clk = 0;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxUvdLevel, &level);\n\n\tif (level < table->count)\n\t\tclock = table->entries[level].vclk;\n\telse\n\t\tclock = table->entries[table->count - 1].vclk;\n\n\tdata->uvd_dpm.soft_max_clk = clock;\n\tdata->uvd_dpm.hard_max_clk = clock;\n\n\treturn 0;\n}\n\nstatic int smu8_init_vce_limit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_vce_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\tunsigned long clock = 0;\n\tuint32_t level;\n\n\tif (NULL == table || table->count <= 0)\n\t\treturn -EINVAL;\n\n\tdata->vce_dpm.soft_min_clk = 0;\n\tdata->vce_dpm.hard_min_clk = 0;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxEclkLevel, &level);\n\n\tif (level < table->count)\n\t\tclock = table->entries[level].ecclk;\n\telse\n\t\tclock = table->entries[table->count - 1].ecclk;\n\n\tdata->vce_dpm.soft_max_clk = clock;\n\tdata->vce_dpm.hard_max_clk = clock;\n\n\treturn 0;\n}\n\nstatic int smu8_init_acp_limit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_acp_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.acp_clock_voltage_dependency_table;\n\tunsigned long clock = 0;\n\tuint32_t level;\n\n\tif (NULL == table || table->count <= 0)\n\t\treturn -EINVAL;\n\n\tdata->acp_dpm.soft_min_clk = 0;\n\tdata->acp_dpm.hard_min_clk = 0;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxAclkLevel, &level);\n\n\tif (level < table->count)\n\t\tclock = table->entries[level].acpclk;\n\telse\n\t\tclock = table->entries[table->count - 1].acpclk;\n\n\tdata->acp_dpm.soft_max_clk = clock;\n\tdata->acp_dpm.hard_max_clk = clock;\n\treturn 0;\n}\n\nstatic void smu8_init_power_gate_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->uvd_power_gated = false;\n\tdata->vce_power_gated = false;\n\tdata->samu_power_gated = false;\n#ifdef CONFIG_DRM_AMD_ACP\n\tdata->acp_power_gated = false;\n#else\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ACPPowerOFF, NULL);\n\tdata->acp_power_gated = true;\n#endif\n\n}\n\nstatic void smu8_init_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->low_sclk_interrupt_threshold = 0;\n}\n\nstatic int smu8_update_sclk_limit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\n\tunsigned long clock = 0;\n\tunsigned long level;\n\tunsigned long stable_pstate_sclk;\n\tunsigned long percentage;\n\n\tdata->sclk_dpm.soft_min_clk = table->entries[0].clk;\n\tlevel = smu8_get_max_sclk_level(hwmgr) - 1;\n\n\tif (level < table->count)\n\t\tdata->sclk_dpm.soft_max_clk  = table->entries[level].clk;\n\telse\n\t\tdata->sclk_dpm.soft_max_clk  = table->entries[table->count - 1].clk;\n\n\tclock = hwmgr->display_config->min_core_set_clock;\n\tif (clock == 0)\n\t\tpr_debug(\"min_core_set_clock not set\\n\");\n\n\tif (data->sclk_dpm.hard_min_clk != clock) {\n\t\tdata->sclk_dpm.hard_min_clk = clock;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSclkHardMin,\n\t\t\t\t\t\t smu8_get_sclk_level(hwmgr,\n\t\t\t\t\tdata->sclk_dpm.hard_min_clk,\n\t\t\t\t\t     PPSMC_MSG_SetSclkHardMin),\n\t\t\t\t\t\t NULL);\n\t}\n\n\tclock = data->sclk_dpm.soft_min_clk;\n\n\t \n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t     PHM_PlatformCaps_StablePState)) {\n\t\tpercentage = 75;\n\t\t \n\t\tstable_pstate_sclk = (hwmgr->dyn_state.max_clock_voltage_on_ac.mclk *\n\t\t\t\t\tpercentage) / 100;\n\n\t\tif (clock < stable_pstate_sclk)\n\t\t\tclock = stable_pstate_sclk;\n\t}\n\n\tif (data->sclk_dpm.soft_min_clk != clock) {\n\t\tdata->sclk_dpm.soft_min_clk = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\t\tdata->sclk_dpm.soft_min_clk,\n\t\t\t\t\t     PPSMC_MSG_SetSclkSoftMin),\n\t\t\t\t\t\tNULL);\n\t}\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t    PHM_PlatformCaps_StablePState) &&\n\t\t\t data->sclk_dpm.soft_max_clk != clock) {\n\t\tdata->sclk_dpm.soft_max_clk = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\t\tPPSMC_MSG_SetSclkSoftMax),\n\t\t\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_set_deep_sleep_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_SclkDeepSleep)) {\n\t\tuint32_t clks = hwmgr->display_config->min_core_set_clock_in_sr;\n\t\tif (clks == 0)\n\t\t\tclks = SMU8_MIN_DEEP_SLEEP_SCLK;\n\n\t\tPP_DBG_LOG(\"Setting Deep Sleep Clock: %d\\n\", clks);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetMinDeepSleepSclk,\n\t\t\t\tclks,\n\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_set_watermark_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data =\n\t\t\t\t  hwmgr->backend;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetWatermarkFrequency,\n\t\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int smu8_nbdpm_pstate_enable_disable(struct pp_hwmgr *hwmgr, bool enable, bool lock)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\n\tif (hw_data->is_nb_dpm_enabled) {\n\t\tif (enable) {\n\t\t\tPP_DBG_LOG(\"enable Low Memory PState.\\n\");\n\n\t\t\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_EnableLowMemoryPstate,\n\t\t\t\t\t\t(lock ? 1 : 0),\n\t\t\t\t\t\tNULL);\n\t\t} else {\n\t\t\tPP_DBG_LOG(\"disable Low Memory PState.\\n\");\n\n\t\t\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_DisableLowMemoryPstate,\n\t\t\t\t\t\t(lock ? 1 : 0),\n\t\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_disable_nb_dpm(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tunsigned long dpm_features = 0;\n\n\tif (data->is_nb_dpm_enabled) {\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, true, true);\n\t\tdpm_features |= NB_DPM_MASK;\n\t\tret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\t\t\t  hwmgr,\n\t\t\t\t\t\t\t  PPSMC_MSG_DisableAllSmuFeatures,\n\t\t\t\t\t\t\t  dpm_features,\n\t\t\t\t\t\t\t  NULL);\n\t\tif (ret == 0)\n\t\t\tdata->is_nb_dpm_enabled = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu8_enable_nb_dpm(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tunsigned long dpm_features = 0;\n\n\tif (!data->is_nb_dpm_enabled) {\n\t\tPP_DBG_LOG(\"enabling ALL SMU features.\\n\");\n\t\tdpm_features |= NB_DPM_MASK;\n\t\tret = smum_send_msg_to_smc_with_parameter(\n\t\t\t\t\t\t\t  hwmgr,\n\t\t\t\t\t\t\t  PPSMC_MSG_EnableAllSmuFeatures,\n\t\t\t\t\t\t\t  dpm_features,\n\t\t\t\t\t\t\t  NULL);\n\t\tif (ret == 0)\n\t\t\tdata->is_nb_dpm_enabled = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu8_update_low_mem_pstate(struct pp_hwmgr *hwmgr, const void *input)\n{\n\tbool disable_switch;\n\tbool enable_low_mem_state;\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\tconst struct phm_set_power_state_input *states = (struct phm_set_power_state_input *)input;\n\tconst struct smu8_power_state *pnew_state = cast_const_smu8_power_state(states->pnew_state);\n\n\tif (hw_data->sys_info.nb_dpm_enable) {\n\t\tdisable_switch = hw_data->cc6_settings.nb_pstate_switch_disable ? true : false;\n\t\tenable_low_mem_state = hw_data->cc6_settings.nb_pstate_switch_disable ? false : true;\n\n\t\tif (pnew_state->action == FORCE_HIGH)\n\t\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, false, disable_switch);\n\t\telse if (pnew_state->action == CANCEL_FORCE_HIGH)\n\t\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, true, disable_switch);\n\t\telse\n\t\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, enable_low_mem_state, disable_switch);\n\t}\n\treturn 0;\n}\n\nstatic int smu8_set_power_state_tasks(struct pp_hwmgr *hwmgr, const void *input)\n{\n\tint ret = 0;\n\n\tsmu8_update_sclk_limit(hwmgr);\n\tsmu8_set_deep_sleep_sclk_threshold(hwmgr);\n\tsmu8_set_watermark_threshold(hwmgr);\n\tret = smu8_enable_nb_dpm(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tsmu8_update_low_mem_pstate(hwmgr, input);\n\n\treturn 0;\n}\n\n\nstatic int smu8_setup_asic_task(struct pp_hwmgr *hwmgr)\n{\n\tint ret;\n\n\tret = smu8_upload_pptable_to_smu(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tret = smu8_init_sclk_limit(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tret = smu8_init_uvd_limit(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tret = smu8_init_vce_limit(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\tret = smu8_init_acp_limit(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu8_init_power_gate_state(hwmgr);\n\tsmu8_init_sclk_threshold(hwmgr);\n\n\treturn 0;\n}\n\nstatic void smu8_power_up_display_clock_sys_pll(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\n\thw_data->disp_clk_bypass_pending = false;\n\thw_data->disp_clk_bypass = false;\n}\n\nstatic void smu8_clear_nb_dpm_flag(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\n\thw_data->is_nb_dpm_enabled = false;\n}\n\nstatic void smu8_reset_cc6_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\n\thw_data->cc6_settings.cc6_setting_changed = false;\n\thw_data->cc6_settings.cpu_pstate_separation_time = 0;\n\thw_data->cc6_settings.cpu_cc6_disable = false;\n\thw_data->cc6_settings.cpu_pstate_disable = false;\n}\n\nstatic void smu8_program_voting_clients(struct pp_hwmgr *hwmgr)\n{\n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tixCG_FREQ_TRAN_VOTING_0,\n\t\t\t\tSMU8_VOTINGRIGHTSCLIENTS_DFLT0);\n}\n\nstatic void smu8_clear_voting_clients(struct pp_hwmgr *hwmgr)\n{\n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tixCG_FREQ_TRAN_VOTING_0, 0);\n}\n\nstatic int smu8_start_dpm(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->dpm_flags |= DPMFlags_SCLK_Enabled;\n\n\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableAllSmuFeatures,\n\t\t\t\tSCLK_DPM_MASK,\n\t\t\t\tNULL);\n}\n\nstatic int smu8_stop_dpm(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tunsigned long dpm_features = 0;\n\n\tif (data->dpm_flags & DPMFlags_SCLK_Enabled) {\n\t\tdpm_features |= SCLK_DPM_MASK;\n\t\tdata->dpm_flags &= ~DPMFlags_SCLK_Enabled;\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DisableAllSmuFeatures,\n\t\t\t\t\tdpm_features,\n\t\t\t\t\tNULL);\n\t}\n\treturn ret;\n}\n\nstatic int smu8_program_bootup_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->sclk_dpm.soft_min_clk = data->sys_info.bootup_engine_clock;\n\tdata->sclk_dpm.soft_max_clk = data->sys_info.bootup_engine_clock;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_min_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax),\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic void smu8_reset_acp_boot_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tdata->acp_boot_level = 0xff;\n}\n\nstatic void smu8_populate_umdpstate_clocks(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\n\thwmgr->pstate_sclk = table->entries[0].clk / 100;\n\thwmgr->pstate_mclk = 0;\n\n\thwmgr->pstate_sclk_peak = table->entries[table->count - 1].clk / 100;\n\thwmgr->pstate_mclk_peak = 0;\n}\n\nstatic int smu8_enable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tsmu8_program_voting_clients(hwmgr);\n\tif (smu8_start_dpm(hwmgr))\n\t\treturn -EINVAL;\n\tsmu8_program_bootup_state(hwmgr);\n\tsmu8_reset_acp_boot_level(hwmgr);\n\n\tsmu8_populate_umdpstate_clocks(hwmgr);\n\n\treturn 0;\n}\n\nstatic int smu8_disable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tsmu8_disable_nb_dpm(hwmgr);\n\n\tsmu8_clear_voting_clients(hwmgr);\n\tif (smu8_stop_dpm(hwmgr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int smu8_power_off_asic(struct pp_hwmgr *hwmgr)\n{\n\tsmu8_disable_dpm_tasks(hwmgr);\n\tsmu8_power_up_display_clock_sys_pll(hwmgr);\n\tsmu8_clear_nb_dpm_flag(hwmgr);\n\tsmu8_reset_cc6_data(hwmgr);\n\treturn 0;\n}\n\nstatic int smu8_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state  *prequest_ps,\n\t\t\tconst struct pp_power_state *pcurrent_ps)\n{\n\tstruct smu8_power_state *smu8_ps =\n\t\t\t\tcast_smu8_power_state(&prequest_ps->hardware);\n\n\tconst struct smu8_power_state *smu8_current_ps =\n\t\t\t\tcast_const_smu8_power_state(&pcurrent_ps->hardware);\n\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct PP_Clocks clocks = {0, 0, 0, 0};\n\tbool force_high;\n\n\tsmu8_ps->need_dfs_bypass = true;\n\n\tdata->battery_state = (PP_StateUILabel_Battery == prequest_ps->classification.ui_label);\n\n\tclocks.memoryClock = hwmgr->display_config->min_mem_set_clock != 0 ?\n\t\t\t\thwmgr->display_config->min_mem_set_clock :\n\t\t\t\tdata->sys_info.nbp_memory_clock[1];\n\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_StablePState))\n\t\tclocks.memoryClock = hwmgr->dyn_state.max_clock_voltage_on_ac.mclk;\n\n\tforce_high = (clocks.memoryClock > data->sys_info.nbp_memory_clock[SMU8_NUM_NBPMEMORYCLOCK - 1])\n\t\t\t|| (hwmgr->display_config->num_display >= 3);\n\n\tsmu8_ps->action = smu8_current_ps->action;\n\n\tif (hwmgr->request_dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, false, false);\n\telse if (hwmgr->request_dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD)\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, false, true);\n\telse if (!force_high && (smu8_ps->action == FORCE_HIGH))\n\t\tsmu8_ps->action = CANCEL_FORCE_HIGH;\n\telse if (force_high && (smu8_ps->action != FORCE_HIGH))\n\t\tsmu8_ps->action = FORCE_HIGH;\n\telse\n\t\tsmu8_ps->action = DO_NOTHING;\n\n\treturn 0;\n}\n\nstatic int smu8_hwmgr_backend_init(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct smu8_hwmgr *data;\n\n\tdata = kzalloc(sizeof(struct smu8_hwmgr), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->backend = data;\n\n\tresult = smu8_initialize_dpm_defaults(hwmgr);\n\tif (result != 0) {\n\t\tpr_err(\"smu8_initialize_dpm_defaults failed\\n\");\n\t\treturn result;\n\t}\n\n\tresult = smu8_get_system_info_data(hwmgr);\n\tif (result != 0) {\n\t\tpr_err(\"smu8_get_system_info_data failed\\n\");\n\t\treturn result;\n\t}\n\n\tsmu8_construct_boot_state(hwmgr);\n\n\thwmgr->platform_descriptor.hardwareActivityPerformanceLevels =  SMU8_MAX_HARDWARE_POWERLEVELS;\n\n\treturn result;\n}\n\nstatic int smu8_hwmgr_backend_fini(struct pp_hwmgr *hwmgr)\n{\n\tif (hwmgr != NULL) {\n\t\tkfree(hwmgr->dyn_state.vddc_dep_on_dal_pwrl);\n\t\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\n\n\t\tkfree(hwmgr->backend);\n\t\thwmgr->backend = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int smu8_phm_force_dpm_highest(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\t\tPPSMC_MSG_SetSclkSoftMin),\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax),\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int smu8_phm_unforce_dpm_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\tunsigned long clock = 0, level;\n\n\tif (NULL == table || table->count <= 0)\n\t\treturn -EINVAL;\n\n\tdata->sclk_dpm.soft_min_clk = table->entries[0].clk;\n\tdata->sclk_dpm.hard_min_clk = table->entries[0].clk;\n\n\tlevel = smu8_get_max_sclk_level(hwmgr) - 1;\n\n\tif (level < table->count)\n\t\tclock = table->entries[level].clk;\n\telse\n\t\tclock = table->entries[table->count - 1].clk;\n\n\tdata->sclk_dpm.soft_max_clk = clock;\n\tdata->sclk_dpm.hard_max_clk = clock;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_min_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_max_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax),\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int smu8_phm_force_dpm_lowest(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\tdata->sclk_dpm.soft_min_clk,\n\t\t\tPPSMC_MSG_SetSclkSoftMax),\n\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\tsmu8_get_sclk_level(hwmgr,\n\t\t\t\tdata->sclk_dpm.soft_min_clk,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin),\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int smu8_dpm_force_dpm_level(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tret = smu8_phm_force_dpm_highest(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tret = smu8_phm_force_dpm_lowest(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tret = smu8_phm_unforce_dpm_levels(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu8_dpm_powerdown_uvd(struct pp_hwmgr *hwmgr)\n{\n\tif (PP_CAP(PHM_PlatformCaps_UVDPowerGating))\n\t\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_UVDPowerOFF, NULL);\n\treturn 0;\n}\n\nstatic int smu8_dpm_powerup_uvd(struct pp_hwmgr *hwmgr)\n{\n\tif (PP_CAP(PHM_PlatformCaps_UVDPowerGating)) {\n\t\treturn smum_send_msg_to_smc_with_parameter(\n\t\t\thwmgr,\n\t\t\tPPSMC_MSG_UVDPowerON,\n\t\t\tPP_CAP(PHM_PlatformCaps_UVDDynamicPowerGating) ? 1 : 0,\n\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int  smu8_dpm_update_vce_dpm(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_vce_clock_voltage_dependency_table *ptable =\n\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\n\t \n\tif (PP_CAP(PHM_PlatformCaps_StablePState) ||\n\t    hwmgr->en_umd_pstate) {\n\t\tdata->vce_dpm.hard_min_clk =\n\t\t\t\t  ptable->entries[ptable->count - 1].ecclk;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetEclkHardMin,\n\t\t\tsmu8_get_eclk_level(hwmgr,\n\t\t\t\tdata->vce_dpm.hard_min_clk,\n\t\t\t\tPPSMC_MSG_SetEclkHardMin),\n\t\t\tNULL);\n\t} else {\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetEclkHardMin,\n\t\t\t\t\t0,\n\t\t\t\t\tNULL);\n\t\t \n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetEclkSoftMin,\n\t\t\t\t\t1,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu8_dpm_powerdown_vce(struct pp_hwmgr *hwmgr)\n{\n\tif (PP_CAP(PHM_PlatformCaps_VCEPowerGating))\n\t\treturn smum_send_msg_to_smc(hwmgr,\n\t\t\t\t\t    PPSMC_MSG_VCEPowerOFF,\n\t\t\t\t\t    NULL);\n\treturn 0;\n}\n\nstatic int smu8_dpm_powerup_vce(struct pp_hwmgr *hwmgr)\n{\n\tif (PP_CAP(PHM_PlatformCaps_VCEPowerGating))\n\t\treturn smum_send_msg_to_smc(hwmgr,\n\t\t\t\t\t    PPSMC_MSG_VCEPowerON,\n\t\t\t\t\t    NULL);\n\treturn 0;\n}\n\nstatic uint32_t smu8_dpm_get_mclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\treturn data->sys_info.bootup_uma_clock;\n}\n\nstatic uint32_t smu8_dpm_get_sclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct pp_power_state  *ps;\n\tstruct smu8_power_state  *smu8_ps;\n\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tps = hwmgr->request_ps;\n\n\tif (ps == NULL)\n\t\treturn -EINVAL;\n\n\tsmu8_ps = cast_smu8_power_state(&ps->hardware);\n\n\tif (low)\n\t\treturn smu8_ps->levels[0].engineClock;\n\telse\n\t\treturn smu8_ps->levels[smu8_ps->level-1].engineClock;\n}\n\nstatic int smu8_dpm_patch_boot_state(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tstruct pp_hw_power_state *hw_ps)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct smu8_power_state *smu8_ps = cast_smu8_power_state(hw_ps);\n\n\tsmu8_ps->level = 1;\n\tsmu8_ps->nbps_flags = 0;\n\tsmu8_ps->bapm_flags = 0;\n\tsmu8_ps->levels[0] = data->boot_power_level;\n\n\treturn 0;\n}\n\nstatic int smu8_dpm_get_pp_table_entry_callback(\n\t\t\t\t\t\t     struct pp_hwmgr *hwmgr,\n\t\t\t\t\t   struct pp_hw_power_state *hw_ps,\n\t\t\t\t\t\t\t  unsigned int index,\n\t\t\t\t\t\t     const void *clock_info)\n{\n\tstruct smu8_power_state *smu8_ps = cast_smu8_power_state(hw_ps);\n\n\tconst ATOM_PPLIB_CZ_CLOCK_INFO *smu8_clock_info = clock_info;\n\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\t    hwmgr->dyn_state.vddc_dependency_on_sclk;\n\tuint8_t clock_info_index = smu8_clock_info->index;\n\n\tif (clock_info_index > (uint8_t)(hwmgr->platform_descriptor.hardwareActivityPerformanceLevels - 1))\n\t\tclock_info_index = (uint8_t)(hwmgr->platform_descriptor.hardwareActivityPerformanceLevels - 1);\n\n\tsmu8_ps->levels[index].engineClock = table->entries[clock_info_index].clk;\n\tsmu8_ps->levels[index].vddcIndex = (uint8_t)table->entries[clock_info_index].v;\n\n\tsmu8_ps->level = index + 1;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SclkDeepSleep)) {\n\t\tsmu8_ps->levels[index].dsDividerIndex = 5;\n\t\tsmu8_ps->levels[index].ssDividerIndex = 5;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_dpm_get_num_of_pp_table_entries(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tunsigned long ret = 0;\n\n\tresult = pp_tables_get_num_of_entries(hwmgr, &ret);\n\n\treturn result ? 0 : ret;\n}\n\nstatic int smu8_dpm_get_pp_table_entry(struct pp_hwmgr *hwmgr,\n\t\t    unsigned long entry, struct pp_power_state *ps)\n{\n\tint result;\n\tstruct smu8_power_state *smu8_ps;\n\n\tps->hardware.magic = smu8_magic;\n\n\tsmu8_ps = cast_smu8_power_state(&(ps->hardware));\n\n\tresult = pp_tables_get_entry(hwmgr, entry, ps,\n\t\t\tsmu8_dpm_get_pp_table_entry_callback);\n\n\tsmu8_ps->uvd_clocks.vclk = ps->uvd_clocks.VCLK;\n\tsmu8_ps->uvd_clocks.dclk = ps->uvd_clocks.DCLK;\n\n\treturn result;\n}\n\nstatic int smu8_get_power_state_size(struct pp_hwmgr *hwmgr)\n{\n\treturn sizeof(struct smu8_power_state);\n}\n\nstatic void smu8_hw_print_display_cfg(\n\tconst struct cc6_settings *cc6_settings)\n{\n\tPP_DBG_LOG(\"New Display Configuration:\\n\");\n\n\tPP_DBG_LOG(\"   cpu_cc6_disable: %d\\n\",\n\t\t\tcc6_settings->cpu_cc6_disable);\n\tPP_DBG_LOG(\"   cpu_pstate_disable: %d\\n\",\n\t\t\tcc6_settings->cpu_pstate_disable);\n\tPP_DBG_LOG(\"   nb_pstate_switch_disable: %d\\n\",\n\t\t\tcc6_settings->nb_pstate_switch_disable);\n\tPP_DBG_LOG(\"   cpu_pstate_separation_time: %d\\n\\n\",\n\t\t\tcc6_settings->cpu_pstate_separation_time);\n}\n\n static int smu8_set_cpu_power_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\tuint32_t data = 0;\n\n\tif (hw_data->cc6_settings.cc6_setting_changed) {\n\n\t\thw_data->cc6_settings.cc6_setting_changed = false;\n\n\t\tsmu8_hw_print_display_cfg(&hw_data->cc6_settings);\n\n\t\tdata |= (hw_data->cc6_settings.cpu_pstate_separation_time\n\t\t\t& PWRMGT_SEPARATION_TIME_MASK)\n\t\t\t<< PWRMGT_SEPARATION_TIME_SHIFT;\n\n\t\tdata |= (hw_data->cc6_settings.cpu_cc6_disable ? 0x1 : 0x0)\n\t\t\t<< PWRMGT_DISABLE_CPU_CSTATES_SHIFT;\n\n\t\tdata |= (hw_data->cc6_settings.cpu_pstate_disable ? 0x1 : 0x0)\n\t\t\t<< PWRMGT_DISABLE_CPU_PSTATES_SHIFT;\n\n\t\tPP_DBG_LOG(\"SetDisplaySizePowerParams data: 0x%X\\n\",\n\t\t\tdata);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetDisplaySizePowerParams,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int smu8_store_cc6_data(struct pp_hwmgr *hwmgr, uint32_t separation_time,\n\t\t\tbool cc6_disable, bool pstate_disable, bool pstate_switch_disable)\n{\n\tstruct smu8_hwmgr *hw_data = hwmgr->backend;\n\n\tif (separation_time !=\n\t    hw_data->cc6_settings.cpu_pstate_separation_time ||\n\t    cc6_disable != hw_data->cc6_settings.cpu_cc6_disable ||\n\t    pstate_disable != hw_data->cc6_settings.cpu_pstate_disable ||\n\t    pstate_switch_disable != hw_data->cc6_settings.nb_pstate_switch_disable) {\n\n\t\thw_data->cc6_settings.cc6_setting_changed = true;\n\n\t\thw_data->cc6_settings.cpu_pstate_separation_time =\n\t\t\tseparation_time;\n\t\thw_data->cc6_settings.cpu_cc6_disable =\n\t\t\tcc6_disable;\n\t\thw_data->cc6_settings.cpu_pstate_disable =\n\t\t\tpstate_disable;\n\t\thw_data->cc6_settings.nb_pstate_switch_disable =\n\t\t\tpstate_switch_disable;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_get_dal_power_level(struct pp_hwmgr *hwmgr,\n\t\tstruct amd_pp_simple_clock_info *info)\n{\n\tuint32_t i;\n\tconst struct phm_clock_voltage_dependency_table *table =\n\t\t\thwmgr->dyn_state.vddc_dep_on_dal_pwrl;\n\tconst struct phm_clock_and_voltage_limits *limits =\n\t\t\t&hwmgr->dyn_state.max_clock_voltage_on_ac;\n\n\tinfo->engine_max_clock = limits->sclk;\n\tinfo->memory_max_clock = limits->mclk;\n\n\tfor (i = table->count - 1; i > 0; i--) {\n\t\tif (limits->vddc >= table->entries[i].v) {\n\t\t\tinfo->level = table->entries[i].clk;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int smu8_force_clock_level(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, uint32_t mask)\n{\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMin,\n\t\t\t\tmask,\n\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSclkSoftMax,\n\t\t\t\tmask,\n\t\t\t\tNULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_print_clock_levels(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, char *buf)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_clock_voltage_dependency_table *sclk_table =\n\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\tuint32_t i, now;\n\tint size = 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tnow = PHM_GET_FIELD(cgs_read_ind_register(hwmgr->device,\n\t\t\t\tCGS_IND_REG__SMC,\n\t\t\t\tixTARGET_AND_CURRENT_PROFILE_INDEX),\n\t\t\t\tTARGET_AND_CURRENT_PROFILE_INDEX,\n\t\t\t\tCURR_SCLK_INDEX);\n\n\t\tfor (i = 0; i < sclk_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, sclk_table->entries[i].clk / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_MCLK:\n\t\tnow = PHM_GET_FIELD(cgs_read_ind_register(hwmgr->device,\n\t\t\t\tCGS_IND_REG__SMC,\n\t\t\t\tixTARGET_AND_CURRENT_PROFILE_INDEX),\n\t\t\t\tTARGET_AND_CURRENT_PROFILE_INDEX,\n\t\t\t\tCURR_MCLK_INDEX);\n\n\t\tfor (i = SMU8_NUM_NBPMEMORYCLOCK; i > 0; i--)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\tSMU8_NUM_NBPMEMORYCLOCK-i, data->sys_info.nbp_memory_clock[i-1] / 100,\n\t\t\t\t\t(SMU8_NUM_NBPMEMORYCLOCK-i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn size;\n}\n\nstatic int smu8_get_performance_level(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state,\n\t\t\t\tPHM_PerformanceLevelDesignation designation, uint32_t index,\n\t\t\t\tPHM_PerformanceLevel *level)\n{\n\tconst struct smu8_power_state *ps;\n\tstruct smu8_hwmgr *data;\n\tuint32_t level_index;\n\tuint32_t i;\n\n\tif (level == NULL || hwmgr == NULL || state == NULL)\n\t\treturn -EINVAL;\n\n\tdata = hwmgr->backend;\n\tps = cast_const_smu8_power_state(state);\n\n\tlevel_index = index > ps->level - 1 ? ps->level - 1 : index;\n\tlevel->coreClock = ps->levels[level_index].engineClock;\n\n\tif (designation == PHM_PerformanceLevelDesignation_PowerContainment) {\n\t\tfor (i = 1; i < ps->level; i++) {\n\t\t\tif (ps->levels[i].engineClock > data->dce_slow_sclk_threshold) {\n\t\t\t\tlevel->coreClock = ps->levels[i].engineClock;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (level_index == 0)\n\t\tlevel->memory_clock = data->sys_info.nbp_memory_clock[SMU8_NUM_NBPMEMORYCLOCK - 1];\n\telse\n\t\tlevel->memory_clock = data->sys_info.nbp_memory_clock[0];\n\n\tlevel->vddc = (smu8_convert_8Bit_index_to_voltage(hwmgr, ps->levels[level_index].vddcIndex) + 2) / 4;\n\tlevel->nonLocalMemoryFreq = 0;\n\tlevel->nonLocalMemoryWidth = 0;\n\n\treturn 0;\n}\n\nstatic int smu8_get_current_shallow_sleep_clocks(struct pp_hwmgr *hwmgr,\n\tconst struct pp_hw_power_state *state, struct pp_clock_info *clock_info)\n{\n\tconst struct smu8_power_state *ps = cast_const_smu8_power_state(state);\n\n\tclock_info->min_eng_clk = ps->levels[0].engineClock / (1 << (ps->levels[0].ssDividerIndex));\n\tclock_info->max_eng_clk = ps->levels[ps->level - 1].engineClock / (1 << (ps->levels[ps->level - 1].ssDividerIndex));\n\n\treturn 0;\n}\n\nstatic int smu8_get_clock_by_type(struct pp_hwmgr *hwmgr, enum amd_pp_clock_type type,\n\t\t\t\t\t\tstruct amd_pp_clocks *clocks)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tint i;\n\tstruct phm_clock_voltage_dependency_table *table;\n\n\tclocks->count = smu8_get_max_sclk_level(hwmgr);\n\tswitch (type) {\n\tcase amd_pp_disp_clock:\n\t\tfor (i = 0; i < clocks->count; i++)\n\t\t\tclocks->clock[i] = data->sys_info.display_clock[i] * 10;\n\t\tbreak;\n\tcase amd_pp_sys_clock:\n\t\ttable = hwmgr->dyn_state.vddc_dependency_on_sclk;\n\t\tfor (i = 0; i < clocks->count; i++)\n\t\t\tclocks->clock[i] = table->entries[i].clk * 10;\n\t\tbreak;\n\tcase amd_pp_mem_clock:\n\t\tclocks->count = SMU8_NUM_NBPMEMORYCLOCK;\n\t\tfor (i = 0; i < clocks->count; i++)\n\t\t\tclocks->clock[i] = data->sys_info.nbp_memory_clock[clocks->count - 1 - i] * 10;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_get_max_high_clocks(struct pp_hwmgr *hwmgr, struct amd_pp_simple_clock_info *clocks)\n{\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\tunsigned long level;\n\tconst struct phm_clock_and_voltage_limits *limits =\n\t\t\t&hwmgr->dyn_state.max_clock_voltage_on_ac;\n\n\tif ((NULL == table) || (table->count <= 0) || (clocks == NULL))\n\t\treturn -EINVAL;\n\n\tlevel = smu8_get_max_sclk_level(hwmgr) - 1;\n\n\tif (level < table->count)\n\t\tclocks->engine_max_clock = table->entries[level].clk;\n\telse\n\t\tclocks->engine_max_clock = table->entries[table->count - 1].clk;\n\n\tclocks->memory_max_clock = limits->mclk;\n\n\treturn 0;\n}\n\nstatic int smu8_thermal_get_temperature(struct pp_hwmgr *hwmgr)\n{\n\tint actual_temp = 0;\n\tuint32_t val = cgs_read_ind_register(hwmgr->device,\n\t\t\t\t\t     CGS_IND_REG__SMC, ixTHM_TCON_CUR_TMP);\n\tuint32_t temp = PHM_GET_FIELD(val, THM_TCON_CUR_TMP, CUR_TEMP);\n\n\tif (PHM_GET_FIELD(val, THM_TCON_CUR_TMP, CUR_TEMP_RANGE_SEL))\n\t\tactual_temp = ((temp / 8) - 49) * PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\telse\n\t\tactual_temp = (temp / 8) * PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn actual_temp;\n}\n\nstatic int smu8_read_sensor(struct pp_hwmgr *hwmgr, int idx,\n\t\t\t  void *value, int *size)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk;\n\n\tstruct phm_vce_clock_voltage_dependency_table *vce_table =\n\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\n\tstruct phm_uvd_clock_voltage_dependency_table *uvd_table =\n\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\n\tuint32_t sclk_index = PHM_GET_FIELD(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixTARGET_AND_CURRENT_PROFILE_INDEX),\n\t\t\t\t\tTARGET_AND_CURRENT_PROFILE_INDEX, CURR_SCLK_INDEX);\n\tuint32_t uvd_index = PHM_GET_FIELD(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixTARGET_AND_CURRENT_PROFILE_INDEX_2),\n\t\t\t\t\tTARGET_AND_CURRENT_PROFILE_INDEX_2, CURR_UVD_INDEX);\n\tuint32_t vce_index = PHM_GET_FIELD(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixTARGET_AND_CURRENT_PROFILE_INDEX_2),\n\t\t\t\t\tTARGET_AND_CURRENT_PROFILE_INDEX_2, CURR_VCE_INDEX);\n\n\tuint32_t sclk, vclk, dclk, ecclk, tmp, activity_percent;\n\tuint16_t vddnb, vddgfx;\n\tint result;\n\n\t \n\tif (*size < 4)\n\t\treturn -EINVAL;\n\t*size = 4;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tif (sclk_index < NUM_SCLK_LEVELS) {\n\t\t\tsclk = table->entries[sclk_index].clk;\n\t\t\t*((uint32_t *)value) = sclk;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\ttmp = (cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixSMUSVI_NB_CURRENTVID) &\n\t\t\tCURRENT_NB_VID_MASK) >> CURRENT_NB_VID__SHIFT;\n\t\tvddnb = smu8_convert_8Bit_index_to_voltage(hwmgr, tmp) / 4;\n\t\t*((uint32_t *)value) = vddnb;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\ttmp = (cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixSMUSVI_GFX_CURRENTVID) &\n\t\t\tCURRENT_GFX_VID_MASK) >> CURRENT_GFX_VID__SHIFT;\n\t\tvddgfx = smu8_convert_8Bit_index_to_voltage(hwmgr, (u16)tmp) / 4;\n\t\t*((uint32_t *)value) = vddgfx;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_UVD_VCLK:\n\t\tif (!data->uvd_power_gated) {\n\t\t\tif (uvd_index >= SMU8_MAX_HARDWARE_POWERLEVELS) {\n\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tvclk = uvd_table->entries[uvd_index].vclk;\n\t\t\t\t*((uint32_t *)value) = vclk;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*((uint32_t *)value) = 0;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_UVD_DCLK:\n\t\tif (!data->uvd_power_gated) {\n\t\t\tif (uvd_index >= SMU8_MAX_HARDWARE_POWERLEVELS) {\n\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tdclk = uvd_table->entries[uvd_index].dclk;\n\t\t\t\t*((uint32_t *)value) = dclk;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*((uint32_t *)value) = 0;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_VCE_ECCLK:\n\t\tif (!data->vce_power_gated) {\n\t\t\tif (vce_index >= SMU8_MAX_HARDWARE_POWERLEVELS) {\n\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tecclk = vce_table->entries[vce_index].ecclk;\n\t\t\t\t*((uint32_t *)value) = ecclk;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*((uint32_t *)value) = 0;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tresult = smum_send_msg_to_smc(hwmgr,\n\t\t\t\tPPSMC_MSG_GetAverageGraphicsActivity,\n\t\t\t\t&activity_percent);\n\t\tif (0 == result)\n\t\t\tactivity_percent = activity_percent > 100 ? 100 : activity_percent;\n\t\telse\n\t\t\treturn -EIO;\n\t\t*((uint32_t *)value) = activity_percent;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_UVD_POWER:\n\t\t*((uint32_t *)value) = data->uvd_power_gated ? 0 : 1;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_VCE_POWER:\n\t\t*((uint32_t *)value) = data->vce_power_gated ? 0 : 1;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_GPU_TEMP:\n\t\t*((uint32_t *)value) = smu8_thermal_get_temperature(hwmgr);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smu8_notify_cac_buffer_info(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t virtual_addr_low,\n\t\t\t\t\tuint32_t virtual_addr_hi,\n\t\t\t\t\tuint32_t mc_addr_low,\n\t\t\t\t\tuint32_t mc_addr_hi,\n\t\t\t\t\tuint32_t size)\n{\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramAddrHiVirtual,\n\t\t\t\t\tmc_addr_hi,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramAddrLoVirtual,\n\t\t\t\t\tmc_addr_low,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramAddrHiPhysical,\n\t\t\t\t\tvirtual_addr_hi,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramAddrLoPhysical,\n\t\t\t\t\tvirtual_addr_low,\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramBufferSize,\n\t\t\t\t\tsize,\n\t\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int smu8_get_thermal_temperature_range(struct pp_hwmgr *hwmgr,\n\t\tstruct PP_TemperatureRange *thermal_data)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tmemcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange));\n\n\tthermal_data->max = (data->thermal_auto_throttling_treshold +\n\t\t\tdata->sys_info.htc_hyst_lmt) *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn 0;\n}\n\nstatic int smu8_enable_disable_uvd_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tuint32_t dpm_features = 0;\n\n\tif (enable &&\n\t\tphm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t  PHM_PlatformCaps_UVDDPM)) {\n\t\tdata->dpm_flags |= DPMFlags_UVD_Enabled;\n\t\tdpm_features |= UVD_DPM_MASK;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t    PPSMC_MSG_EnableAllSmuFeatures,\n\t\t\t    dpm_features,\n\t\t\t    NULL);\n\t} else {\n\t\tdpm_features |= UVD_DPM_MASK;\n\t\tdata->dpm_flags &= ~DPMFlags_UVD_Enabled;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t   PPSMC_MSG_DisableAllSmuFeatures,\n\t\t\t   dpm_features,\n\t\t\t   NULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu8_dpm_update_uvd_dpm(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct phm_uvd_clock_voltage_dependency_table *ptable =\n\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\n\tif (!bgate) {\n\t\t \n\t\tif (PP_CAP(PHM_PlatformCaps_StablePState) ||\n\t\t    hwmgr->en_umd_pstate) {\n\t\t\tdata->uvd_dpm.hard_min_clk =\n\t\t\t\t   ptable->entries[ptable->count - 1].vclk;\n\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetUvdHardMin,\n\t\t\t\tsmu8_get_uvd_level(hwmgr,\n\t\t\t\t\tdata->uvd_dpm.hard_min_clk,\n\t\t\t\t\tPPSMC_MSG_SetUvdHardMin),\n\t\t\t\tNULL);\n\n\t\t\tsmu8_enable_disable_uvd_dpm(hwmgr, true);\n\t\t} else {\n\t\t\tsmu8_enable_disable_uvd_dpm(hwmgr, true);\n\t\t}\n\t} else {\n\t\tsmu8_enable_disable_uvd_dpm(hwmgr, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_enable_disable_vce_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tuint32_t dpm_features = 0;\n\n\tif (enable && phm_cap_enabled(\n\t\t\t\thwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_VCEDPM)) {\n\t\tdata->dpm_flags |= DPMFlags_VCE_Enabled;\n\t\tdpm_features |= VCE_DPM_MASK;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t    PPSMC_MSG_EnableAllSmuFeatures,\n\t\t\t    dpm_features,\n\t\t\t    NULL);\n\t} else {\n\t\tdpm_features |= VCE_DPM_MASK;\n\t\tdata->dpm_flags &= ~DPMFlags_VCE_Enabled;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t   PPSMC_MSG_DisableAllSmuFeatures,\n\t\t\t   dpm_features,\n\t\t\t   NULL);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void smu8_dpm_powergate_acp(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tif (data->acp_power_gated == bgate)\n\t\treturn;\n\n\tif (bgate)\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ACPPowerOFF, NULL);\n\telse\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ACPPowerON, NULL);\n}\n\n#define WIDTH_4K\t\t3840\n\nstatic void smu8_dpm_powergate_uvd(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tdata->uvd_power_gated = bgate;\n\n\tif (bgate) {\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\tAMD_PG_STATE_GATE);\n\t\tamdgpu_device_ip_set_clockgating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\tAMD_CG_STATE_GATE);\n\t\tsmu8_dpm_update_uvd_dpm(hwmgr, true);\n\t\tsmu8_dpm_powerdown_uvd(hwmgr);\n\t} else {\n\t\tsmu8_dpm_powerup_uvd(hwmgr);\n\t\tamdgpu_device_ip_set_clockgating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\tAMD_CG_STATE_UNGATE);\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\tAMD_PG_STATE_UNGATE);\n\t\tsmu8_dpm_update_uvd_dpm(hwmgr, false);\n\t}\n\n\t \n\tif (adev->asic_type == CHIP_STONEY &&\n\t    adev->uvd.decode_image_width >= WIDTH_4K)\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr,\n\t\t\t\t\t\t bgate,\n\t\t\t\t\t\t true);\n}\n\nstatic void smu8_dpm_powergate_vce(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\n\tif (bgate) {\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\tAMD_PG_STATE_GATE);\n\t\tamdgpu_device_ip_set_clockgating_state(hwmgr->adev,\n\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\tAMD_CG_STATE_GATE);\n\t\tsmu8_enable_disable_vce_dpm(hwmgr, false);\n\t\tsmu8_dpm_powerdown_vce(hwmgr);\n\t\tdata->vce_power_gated = true;\n\t} else {\n\t\tsmu8_dpm_powerup_vce(hwmgr);\n\t\tdata->vce_power_gated = false;\n\t\tamdgpu_device_ip_set_clockgating_state(hwmgr->adev,\n\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\tAMD_CG_STATE_UNGATE);\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCE,\n\t\t\t\t\tAMD_PG_STATE_UNGATE);\n\t\tsmu8_dpm_update_vce_dpm(hwmgr);\n\t\tsmu8_enable_disable_vce_dpm(hwmgr, true);\n\t}\n}\n\nstatic const struct pp_hwmgr_func smu8_hwmgr_funcs = {\n\t.backend_init = smu8_hwmgr_backend_init,\n\t.backend_fini = smu8_hwmgr_backend_fini,\n\t.apply_state_adjust_rules = smu8_apply_state_adjust_rules,\n\t.force_dpm_level = smu8_dpm_force_dpm_level,\n\t.get_power_state_size = smu8_get_power_state_size,\n\t.powerdown_uvd = smu8_dpm_powerdown_uvd,\n\t.powergate_uvd = smu8_dpm_powergate_uvd,\n\t.powergate_vce = smu8_dpm_powergate_vce,\n\t.powergate_acp = smu8_dpm_powergate_acp,\n\t.get_mclk = smu8_dpm_get_mclk,\n\t.get_sclk = smu8_dpm_get_sclk,\n\t.patch_boot_state = smu8_dpm_patch_boot_state,\n\t.get_pp_table_entry = smu8_dpm_get_pp_table_entry,\n\t.get_num_of_pp_table_entries = smu8_dpm_get_num_of_pp_table_entries,\n\t.set_cpu_power_state = smu8_set_cpu_power_state,\n\t.store_cc6_data = smu8_store_cc6_data,\n\t.force_clock_level = smu8_force_clock_level,\n\t.print_clock_levels = smu8_print_clock_levels,\n\t.get_dal_power_level = smu8_get_dal_power_level,\n\t.get_performance_level = smu8_get_performance_level,\n\t.get_current_shallow_sleep_clocks = smu8_get_current_shallow_sleep_clocks,\n\t.get_clock_by_type = smu8_get_clock_by_type,\n\t.get_max_high_clocks = smu8_get_max_high_clocks,\n\t.read_sensor = smu8_read_sensor,\n\t.power_off_asic = smu8_power_off_asic,\n\t.asic_setup = smu8_setup_asic_task,\n\t.dynamic_state_management_enable = smu8_enable_dpm_tasks,\n\t.power_state_set = smu8_set_power_state_tasks,\n\t.dynamic_state_management_disable = smu8_disable_dpm_tasks,\n\t.notify_cac_buffer_info = smu8_notify_cac_buffer_info,\n\t.get_thermal_temperature_range = smu8_get_thermal_temperature_range,\n};\n\nint smu8_init_function_pointers(struct pp_hwmgr *hwmgr)\n{\n\thwmgr->hwmgr_func = &smu8_hwmgr_funcs;\n\thwmgr->pptable_func = &pptable_funcs;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}