{
  "module_name": "smu10_hwmgr.c",
  "hash_id": "24d16ce54ea77d0388e2ce71f54f12462789ef62f04a030053b24d342278a912",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"atom-types.h\"\n#include \"atombios.h\"\n#include \"processpptables.h\"\n#include \"cgs_common.h\"\n#include \"smumgr.h\"\n#include \"hwmgr.h\"\n#include \"hardwaremanager.h\"\n#include \"rv_ppsmc.h\"\n#include \"smu10_hwmgr.h\"\n#include \"power_state.h\"\n#include \"soc15_common.h\"\n#include \"smu10.h\"\n#include \"asic_reg/pwr/pwr_10_0_offset.h\"\n#include \"asic_reg/pwr/pwr_10_0_sh_mask.h\"\n\n#define SMU10_MAX_DEEPSLEEP_DIVIDER_ID     5\n#define SMU10_MINIMUM_ENGINE_CLOCK         800    \n#define SCLK_MIN_DIV_INTV_SHIFT         12\n#define SMU10_DISPCLK_BYPASS_THRESHOLD     10000  \n#define SMC_RAM_END                     0x40000\n\nstatic const unsigned long SMU10_Magic = (unsigned long) PHM_Rv_Magic;\n\n\nstatic int smu10_display_clock_voltage_request(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_display_clock_request *clock_req)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tenum amd_pp_clock_type clk_type = clock_req->clock_type;\n\tuint32_t clk_freq = clock_req->clock_freq_in_khz / 1000;\n\tPPSMC_Msg        msg;\n\n\tswitch (clk_type) {\n\tcase amd_pp_dcf_clock:\n\t\tif (clk_freq == smu10_data->dcf_actual_hard_min_freq)\n\t\t\treturn 0;\n\t\tmsg =  PPSMC_MSG_SetHardMinDcefclkByFreq;\n\t\tsmu10_data->dcf_actual_hard_min_freq = clk_freq;\n\t\tbreak;\n\tcase amd_pp_soc_clock:\n\t\t msg = PPSMC_MSG_SetHardMinSocclkByFreq;\n\t\tbreak;\n\tcase amd_pp_f_clock:\n\t\tif (clk_freq == smu10_data->f_actual_hard_min_freq)\n\t\t\treturn 0;\n\t\tsmu10_data->f_actual_hard_min_freq = clk_freq;\n\t\tmsg = PPSMC_MSG_SetHardMinFclkByFreq;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"[DisplayClockVoltageRequest]Invalid Clock Type!\");\n\t\treturn -EINVAL;\n\t}\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, msg, clk_freq, NULL);\n\n\treturn 0;\n}\n\nstatic struct smu10_power_state *cast_smu10_ps(struct pp_hw_power_state *hw_ps)\n{\n\tif (SMU10_Magic != hw_ps->magic)\n\t\treturn NULL;\n\n\treturn (struct smu10_power_state *)hw_ps;\n}\n\nstatic const struct smu10_power_state *cast_const_smu10_ps(\n\t\t\t\tconst struct pp_hw_power_state *hw_ps)\n{\n\tif (SMU10_Magic != hw_ps->magic)\n\t\treturn NULL;\n\n\treturn (struct smu10_power_state *)hw_ps;\n}\n\nstatic int smu10_initialize_dpm_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tsmu10_data->dce_slow_sclk_threshold = 30000;\n\tsmu10_data->thermal_auto_throttling_treshold = 0;\n\tsmu10_data->is_nb_dpm_enabled = 1;\n\tsmu10_data->dpm_flags = 1;\n\tsmu10_data->need_min_deep_sleep_dcefclk = true;\n\tsmu10_data->num_active_display = 0;\n\tsmu10_data->deep_sleep_dcefclk = 0;\n\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_SclkDeepSleep);\n\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_SclkThrottleLowNotification);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_PowerPlaySupport);\n\treturn 0;\n}\n\nstatic int smu10_construct_max_power_limits_table(struct pp_hwmgr *hwmgr,\n\t\t\tstruct phm_clock_and_voltage_limits *table)\n{\n\treturn 0;\n}\n\nstatic int smu10_init_dynamic_state_adjustment_rule_settings(\n\t\t\t\t\t\t\tstruct pp_hwmgr *hwmgr)\n{\n\tint count = 8;\n\tstruct phm_clock_voltage_dependency_table *table_clk_vlt;\n\n\ttable_clk_vlt = kzalloc(struct_size(table_clk_vlt, entries, count),\n\t\t\t\tGFP_KERNEL);\n\n\tif (NULL == table_clk_vlt) {\n\t\tpr_err(\"Can not allocate memory!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttable_clk_vlt->count = count;\n\ttable_clk_vlt->entries[0].clk = PP_DAL_POWERLEVEL_0;\n\ttable_clk_vlt->entries[0].v = 0;\n\ttable_clk_vlt->entries[1].clk = PP_DAL_POWERLEVEL_1;\n\ttable_clk_vlt->entries[1].v = 1;\n\ttable_clk_vlt->entries[2].clk = PP_DAL_POWERLEVEL_2;\n\ttable_clk_vlt->entries[2].v = 2;\n\ttable_clk_vlt->entries[3].clk = PP_DAL_POWERLEVEL_3;\n\ttable_clk_vlt->entries[3].v = 3;\n\ttable_clk_vlt->entries[4].clk = PP_DAL_POWERLEVEL_4;\n\ttable_clk_vlt->entries[4].v = 4;\n\ttable_clk_vlt->entries[5].clk = PP_DAL_POWERLEVEL_5;\n\ttable_clk_vlt->entries[5].v = 5;\n\ttable_clk_vlt->entries[6].clk = PP_DAL_POWERLEVEL_6;\n\ttable_clk_vlt->entries[6].v = 6;\n\ttable_clk_vlt->entries[7].clk = PP_DAL_POWERLEVEL_7;\n\ttable_clk_vlt->entries[7].v = 7;\n\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = table_clk_vlt;\n\n\treturn 0;\n}\n\nstatic int smu10_get_system_info_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)hwmgr->backend;\n\n\tsmu10_data->sys_info.htc_hyst_lmt = 5;\n\tsmu10_data->sys_info.htc_tmp_lmt = 203;\n\n\tif (smu10_data->thermal_auto_throttling_treshold == 0)\n\t\t smu10_data->thermal_auto_throttling_treshold = 203;\n\n\tsmu10_construct_max_power_limits_table (hwmgr,\n\t\t\t\t    &hwmgr->dyn_state.max_clock_voltage_on_ac);\n\n\tsmu10_init_dynamic_state_adjustment_rule_settings(hwmgr);\n\n\treturn 0;\n}\n\nstatic int smu10_construct_boot_state(struct pp_hwmgr *hwmgr)\n{\n\treturn 0;\n}\n\nstatic int smu10_set_clock_limit(struct pp_hwmgr *hwmgr, const void *input)\n{\n\tstruct PP_Clocks clocks = {0};\n\tstruct pp_display_clock_request clock_req;\n\n\tclocks.dcefClock = hwmgr->display_config->min_dcef_set_clk;\n\tclock_req.clock_type = amd_pp_dcf_clock;\n\tclock_req.clock_freq_in_khz = clocks.dcefClock * 10;\n\n\tPP_ASSERT_WITH_CODE(!smu10_display_clock_voltage_request(hwmgr, &clock_req),\n\t\t\t\t\"Attempt to set DCF Clock Failed!\", return -EINVAL);\n\n\treturn 0;\n}\n\nstatic int smu10_set_min_deep_sleep_dcefclk(struct pp_hwmgr *hwmgr, uint32_t clock)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (clock && smu10_data->deep_sleep_dcefclk != clock) {\n\t\tsmu10_data->deep_sleep_dcefclk = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetMinDeepSleepDcefclk,\n\t\t\t\t\tsmu10_data->deep_sleep_dcefclk,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu10_set_hard_min_dcefclk_by_freq(struct pp_hwmgr *hwmgr, uint32_t clock)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (clock && smu10_data->dcf_actual_hard_min_freq != clock) {\n\t\tsmu10_data->dcf_actual_hard_min_freq = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinDcefclkByFreq,\n\t\t\t\t\tsmu10_data->dcf_actual_hard_min_freq,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu10_set_hard_min_fclk_by_freq(struct pp_hwmgr *hwmgr, uint32_t clock)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (clock && smu10_data->f_actual_hard_min_freq != clock) {\n\t\tsmu10_data->f_actual_hard_min_freq = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\tsmu10_data->f_actual_hard_min_freq,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu10_set_hard_min_gfxclk_by_freq(struct pp_hwmgr *hwmgr, uint32_t clock)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (clock && smu10_data->gfx_actual_soft_min_freq != clock) {\n\t\tsmu10_data->gfx_actual_soft_min_freq = clock;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\tclock,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu10_set_soft_max_gfxclk_by_freq(struct pp_hwmgr *hwmgr, uint32_t clock)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (clock && smu10_data->gfx_max_freq_limit != (clock * 100))  {\n\t\tsmu10_data->gfx_max_freq_limit = clock * 100;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\tclock,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int smu10_set_active_display_count(struct pp_hwmgr *hwmgr, uint32_t count)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (smu10_data->num_active_display != count) {\n\t\tsmu10_data->num_active_display = count;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetDisplayCount,\n\t\t\t\tsmu10_data->num_active_display,\n\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_set_power_state_tasks(struct pp_hwmgr *hwmgr, const void *input)\n{\n\treturn smu10_set_clock_limit(hwmgr, input);\n}\n\nstatic int smu10_init_power_gate_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tsmu10_data->vcn_power_gated = true;\n\tsmu10_data->isp_tileA_power_gated = true;\n\tsmu10_data->isp_tileB_power_gated = true;\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)\n\t\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\t\t   PPSMC_MSG_SetGfxCGPG,\n\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t   NULL);\n\telse\n\t\treturn 0;\n}\n\n\nstatic int smu10_setup_asic_task(struct pp_hwmgr *hwmgr)\n{\n\treturn smu10_init_power_gate_state(hwmgr);\n}\n\nstatic int smu10_reset_cc6_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tsmu10_data->separation_time = 0;\n\tsmu10_data->cc6_disable = false;\n\tsmu10_data->pstate_disable = false;\n\tsmu10_data->cc6_setting_changed = false;\n\n\treturn 0;\n}\n\nstatic int smu10_power_off_asic(struct pp_hwmgr *hwmgr)\n{\n\treturn smu10_reset_cc6_data(hwmgr);\n}\n\nstatic bool smu10_is_gfx_on(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t reg;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treg = RREG32_SOC15(PWR, 0, mmPWR_MISC_CNTL_STATUS);\n\tif ((reg & PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS_MASK) ==\n\t    (0x2 << PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS__SHIFT))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int smu10_disable_gfx_off(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tif (adev->pm.pp_feature & PP_GFXOFF_MASK) {\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_DisableGfxOff, NULL);\n\n\t\t \n\t\twhile (!smu10_is_gfx_on(hwmgr))\n\t\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_disable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\treturn 0;\n}\n\nstatic int smu10_enable_gfx_off(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tif (adev->pm.pp_feature & PP_GFXOFF_MASK)\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_EnableGfxOff, NULL);\n\n\treturn 0;\n}\n\nstatic void smu10_populate_umdpstate_clocks(struct pp_hwmgr *hwmgr)\n{\n\thwmgr->pstate_sclk = SMU10_UMD_PSTATE_GFXCLK;\n\thwmgr->pstate_mclk = SMU10_UMD_PSTATE_FCLK;\n\n\tsmum_send_msg_to_smc(hwmgr,\n\t\t\t     PPSMC_MSG_GetMaxGfxclkFrequency,\n\t\t\t     &hwmgr->pstate_sclk_peak);\n\thwmgr->pstate_mclk_peak = SMU10_UMD_PSTATE_PEAK_FCLK;\n}\n\nstatic int smu10_enable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tint ret = -EINVAL;\n\n\tif (adev->in_suspend) {\n\t\tpr_info(\"restore the fine grain parameters\\n\");\n\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\tsmu10_data->gfx_actual_soft_min_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\tsmu10_data->gfx_actual_soft_max_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsmu10_populate_umdpstate_clocks(hwmgr);\n\n\treturn 0;\n}\n\nstatic int smu10_gfx_off_control(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tif (enable)\n\t\treturn smu10_enable_gfx_off(hwmgr);\n\telse\n\t\treturn smu10_disable_gfx_off(hwmgr);\n}\n\nstatic int smu10_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state  *prequest_ps,\n\t\t\tconst struct pp_power_state *pcurrent_ps)\n{\n\treturn 0;\n}\n\n \nstatic const DpmClock_t VddDcfClk[] = {\n\t{ 300, 2600},\n\t{ 600, 3200},\n\t{ 600, 3600},\n};\n\nstatic const DpmClock_t VddSocClk[] = {\n\t{ 478, 2600},\n\t{ 722, 3200},\n\t{ 722, 3600},\n};\n\nstatic const DpmClock_t VddFClk[] = {\n\t{ 400, 2600},\n\t{1200, 3200},\n\t{1200, 3600},\n};\n\nstatic const DpmClock_t VddDispClk[] = {\n\t{ 435, 2600},\n\t{ 661, 3200},\n\t{1086, 3600},\n};\n\nstatic const DpmClock_t VddDppClk[] = {\n\t{ 435, 2600},\n\t{ 661, 3200},\n\t{ 661, 3600},\n};\n\nstatic const DpmClock_t VddPhyClk[] = {\n\t{ 540, 2600},\n\t{ 810, 3200},\n\t{ 810, 3600},\n};\n\nstatic int smu10_get_clock_voltage_dependency_table(struct pp_hwmgr *hwmgr,\n\t\t\tstruct smu10_voltage_dependency_table **pptable,\n\t\t\tuint32_t num_entry, const DpmClock_t *pclk_dependency_table)\n{\n\tuint32_t i;\n\tstruct smu10_voltage_dependency_table *ptable;\n\n\tptable = kzalloc(struct_size(ptable, entries, num_entry), GFP_KERNEL);\n\tif (NULL == ptable)\n\t\treturn -ENOMEM;\n\n\tptable->count = num_entry;\n\n\tfor (i = 0; i < ptable->count; i++) {\n\t\tptable->entries[i].clk         = pclk_dependency_table->Freq * 100;\n\t\tptable->entries[i].vol         = pclk_dependency_table->Vol;\n\t\tpclk_dependency_table++;\n\t}\n\n\t*pptable = ptable;\n\n\treturn 0;\n}\n\n\nstatic int smu10_populate_clock_table(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t result;\n\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tDpmClocks_t  *table = &(smu10_data->clock_table);\n\tstruct smu10_clock_voltage_information *pinfo = &(smu10_data->clock_vol_info);\n\n\tresult = smum_smc_table_manager(hwmgr, (uint8_t *)table, SMU10_CLOCKTABLE, true);\n\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"Attempt to copy clock table from smc failed\",\n\t\t\treturn result);\n\n\tif (0 == result && table->DcefClocks[0].Freq != 0) {\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dcefclk,\n\t\t\t\t\t\tNUM_DCEFCLK_DPM_LEVELS,\n\t\t\t\t\t\t&smu10_data->clock_table.DcefClocks[0]);\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_socclk,\n\t\t\t\t\t\tNUM_SOCCLK_DPM_LEVELS,\n\t\t\t\t\t\t&smu10_data->clock_table.SocClocks[0]);\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_fclk,\n\t\t\t\t\t\tNUM_FCLK_DPM_LEVELS,\n\t\t\t\t\t\t&smu10_data->clock_table.FClocks[0]);\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_mclk,\n\t\t\t\t\t\tNUM_MEMCLK_DPM_LEVELS,\n\t\t\t\t\t\t&smu10_data->clock_table.MemClocks[0]);\n\t} else {\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dcefclk,\n\t\t\t\t\t\tARRAY_SIZE(VddDcfClk),\n\t\t\t\t\t\t&VddDcfClk[0]);\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_socclk,\n\t\t\t\t\t\tARRAY_SIZE(VddSocClk),\n\t\t\t\t\t\t&VddSocClk[0]);\n\t\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_fclk,\n\t\t\t\t\t\tARRAY_SIZE(VddFClk),\n\t\t\t\t\t\t&VddFClk[0]);\n\t}\n\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dispclk,\n\t\t\t\t\tARRAY_SIZE(VddDispClk),\n\t\t\t\t\t&VddDispClk[0]);\n\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dppclk,\n\t\t\t\t\tARRAY_SIZE(VddDppClk), &VddDppClk[0]);\n\tsmu10_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_phyclk,\n\t\t\t\t\tARRAY_SIZE(VddPhyClk), &VddPhyClk[0]);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &result);\n\tsmu10_data->gfx_min_freq_limit = result / 10 * 1000;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &result);\n\tsmu10_data->gfx_max_freq_limit = result / 10 * 1000;\n\n\treturn 0;\n}\n\nstatic int smu10_hwmgr_backend_init(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct smu10_hwmgr *data;\n\n\tdata = kzalloc(sizeof(struct smu10_hwmgr), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->backend = data;\n\n\tresult = smu10_initialize_dpm_defaults(hwmgr);\n\tif (result != 0) {\n\t\tpr_err(\"smu10_initialize_dpm_defaults failed\\n\");\n\t\treturn result;\n\t}\n\n\tsmu10_populate_clock_table(hwmgr);\n\n\tresult = smu10_get_system_info_data(hwmgr);\n\tif (result != 0) {\n\t\tpr_err(\"smu10_get_system_info_data failed\\n\");\n\t\treturn result;\n\t}\n\n\tsmu10_construct_boot_state(hwmgr);\n\n\thwmgr->platform_descriptor.hardwareActivityPerformanceLevels =\n\t\t\t\t\t\tSMU10_MAX_HARDWARE_POWERLEVELS;\n\n\thwmgr->platform_descriptor.hardwarePerformanceLevels =\n\t\t\t\t\t\tSMU10_MAX_HARDWARE_POWERLEVELS;\n\n\thwmgr->platform_descriptor.vbiosInterruptId = 0;\n\n\thwmgr->platform_descriptor.clockStep.engineClock = 500;\n\n\thwmgr->platform_descriptor.clockStep.memoryClock = 500;\n\n\thwmgr->platform_descriptor.minimumClocksReductionPercentage = 50;\n\n\t \n\thwmgr->od_enabled = 1;\n\t \n\tdata->fine_grain_enabled = 0;\n\treturn result;\n}\n\nstatic int smu10_hwmgr_backend_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct smu10_clock_voltage_information *pinfo = &(smu10_data->clock_vol_info);\n\n\tkfree(pinfo->vdd_dep_on_dcefclk);\n\tpinfo->vdd_dep_on_dcefclk = NULL;\n\tkfree(pinfo->vdd_dep_on_socclk);\n\tpinfo->vdd_dep_on_socclk = NULL;\n\tkfree(pinfo->vdd_dep_on_fclk);\n\tpinfo->vdd_dep_on_fclk = NULL;\n\tkfree(pinfo->vdd_dep_on_dispclk);\n\tpinfo->vdd_dep_on_dispclk = NULL;\n\tkfree(pinfo->vdd_dep_on_dppclk);\n\tpinfo->vdd_dep_on_dppclk = NULL;\n\tkfree(pinfo->vdd_dep_on_phyclk);\n\tpinfo->vdd_dep_on_phyclk = NULL;\n\n\tkfree(hwmgr->dyn_state.vddc_dep_on_dal_pwrl);\n\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\n\n\tkfree(hwmgr->backend);\n\thwmgr->backend = NULL;\n\n\treturn 0;\n}\n\nstatic int smu10_dpm_force_dpm_level(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tstruct smu10_hwmgr *data = hwmgr->backend;\n\tuint32_t min_sclk = hwmgr->display_config->min_core_set_clock;\n\tuint32_t min_mclk = hwmgr->display_config->min_mem_set_clock/100;\n\tuint32_t index_fclk = data->clock_vol_info.vdd_dep_on_fclk->count - 1;\n\tuint32_t index_socclk = data->clock_vol_info.vdd_dep_on_socclk->count - 1;\n\tuint32_t fine_grain_min_freq = 0, fine_grain_max_freq = 0;\n\n\tif (hwmgr->smu_version < 0x1E3700) {\n\t\tpr_info(\"smu firmware version too old, can not set dpm level\\n\");\n\t\treturn 0;\n\t}\n\n\tif (min_sclk < data->gfx_min_freq_limit)\n\t\tmin_sclk = data->gfx_min_freq_limit;\n\n\tmin_sclk /= 100;  \n\tif (min_mclk < data->clock_table.FClocks[0].Freq)\n\t\tmin_mclk = data->clock_table.FClocks[0].Freq;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tdata->gfx_max_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PEAK_FCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PEAK_SOCCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_VCE,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\tdata->gfx_max_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PEAK_FCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PEAK_SOCCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_VCE,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tmin_sclk,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\tmin_sclk,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\tmin_mclk,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tmin_mclk,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_GFXCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_FCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_SOCCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PROFILE_VCE,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_GFXCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_FCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_SOCCLK,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_PROFILE_VCE,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tmin_sclk,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\thwmgr->display_config->num_display > 3 ?\n\t\t\t\t\t\t(data->clock_vol_info.vdd_dep_on_fclk->entries[0].clk / 100) :\n\t\t\t\t\t\tmin_mclk,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\tdata->clock_vol_info.vdd_dep_on_socclk->entries[0].clk / 100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_MIN_VCE,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\tdata->gfx_max_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tdata->clock_vol_info.vdd_dep_on_fclk->entries[index_fclk].clk / 100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\tdata->clock_vol_info.vdd_dep_on_socclk->entries[index_socclk].clk / 100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\tSMU10_UMD_PSTATE_VCE,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tdata->fine_grain_enabled = 0;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &fine_grain_min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &fine_grain_max_freq);\n\n\t\tdata->gfx_actual_soft_min_freq = fine_grain_min_freq;\n\t\tdata->gfx_actual_soft_max_freq = fine_grain_max_freq;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tdata->gfx_min_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\tdata->gfx_min_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\tmin_mclk,\n\t\t\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tmin_mclk,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\t\tdata->fine_grain_enabled = 1;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic uint32_t smu10_dpm_get_mclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct smu10_hwmgr *data;\n\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tdata = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (low)\n\t\treturn data->clock_vol_info.vdd_dep_on_fclk->entries[0].clk;\n\telse\n\t\treturn data->clock_vol_info.vdd_dep_on_fclk->entries[\n\t\t\tdata->clock_vol_info.vdd_dep_on_fclk->count - 1].clk;\n}\n\nstatic uint32_t smu10_dpm_get_sclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct smu10_hwmgr *data;\n\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tdata = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (low)\n\t\treturn data->gfx_min_freq_limit;\n\telse\n\t\treturn data->gfx_max_freq_limit;\n}\n\nstatic int smu10_dpm_patch_boot_state(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tstruct pp_hw_power_state *hw_ps)\n{\n\treturn 0;\n}\n\nstatic int smu10_dpm_get_pp_table_entry_callback(\n\t\t\t\t\t\t     struct pp_hwmgr *hwmgr,\n\t\t\t\t\t   struct pp_hw_power_state *hw_ps,\n\t\t\t\t\t\t\t  unsigned int index,\n\t\t\t\t\t\t     const void *clock_info)\n{\n\tstruct smu10_power_state *smu10_ps = cast_smu10_ps(hw_ps);\n\n\tsmu10_ps->levels[index].engine_clock = 0;\n\n\tsmu10_ps->levels[index].vddc_index = 0;\n\tsmu10_ps->level = index + 1;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SclkDeepSleep)) {\n\t\tsmu10_ps->levels[index].ds_divider_index = 5;\n\t\tsmu10_ps->levels[index].ss_divider_index = 5;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_dpm_get_num_of_pp_table_entries(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tunsigned long ret = 0;\n\n\tresult = pp_tables_get_num_of_entries(hwmgr, &ret);\n\n\treturn result ? 0 : ret;\n}\n\nstatic int smu10_dpm_get_pp_table_entry(struct pp_hwmgr *hwmgr,\n\t\t    unsigned long entry, struct pp_power_state *ps)\n{\n\tint result;\n\tstruct smu10_power_state *smu10_ps;\n\n\tps->hardware.magic = SMU10_Magic;\n\n\tsmu10_ps = cast_smu10_ps(&(ps->hardware));\n\n\tresult = pp_tables_get_entry(hwmgr, entry, ps,\n\t\t\tsmu10_dpm_get_pp_table_entry_callback);\n\n\tsmu10_ps->uvd_clocks.vclk = ps->uvd_clocks.VCLK;\n\tsmu10_ps->uvd_clocks.dclk = ps->uvd_clocks.DCLK;\n\n\treturn result;\n}\n\nstatic int smu10_get_power_state_size(struct pp_hwmgr *hwmgr)\n{\n\treturn sizeof(struct smu10_power_state);\n}\n\nstatic int smu10_set_cpu_power_state(struct pp_hwmgr *hwmgr)\n{\n\treturn 0;\n}\n\n\nstatic int smu10_store_cc6_data(struct pp_hwmgr *hwmgr, uint32_t separation_time,\n\t\t\tbool cc6_disable, bool pstate_disable, bool pstate_switch_disable)\n{\n\tstruct smu10_hwmgr *data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (separation_time != data->separation_time ||\n\t\t\tcc6_disable != data->cc6_disable ||\n\t\t\tpstate_disable != data->pstate_disable) {\n\t\tdata->separation_time = separation_time;\n\t\tdata->cc6_disable = cc6_disable;\n\t\tdata->pstate_disable = pstate_disable;\n\t\tdata->cc6_setting_changed = true;\n\t}\n\treturn 0;\n}\n\nstatic int smu10_get_dal_power_level(struct pp_hwmgr *hwmgr,\n\t\tstruct amd_pp_simple_clock_info *info)\n{\n\treturn -EINVAL;\n}\n\nstatic int smu10_force_clock_level(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, uint32_t mask)\n{\n\tstruct smu10_hwmgr *data = hwmgr->backend;\n\tstruct smu10_voltage_dependency_table *mclk_table =\n\t\t\t\t\tdata->clock_vol_info.vdd_dep_on_fclk;\n\tuint32_t low, high;\n\n\tlow = mask ? (ffs(mask) - 1) : 0;\n\thigh = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tif (low > 2 || high > 2) {\n\t\t\tpr_info(\"Currently sclk only support 3 levels on RV\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\tlow == 2 ? data->gfx_max_freq_limit/100 :\n\t\t\t\t\t\tlow == 1 ? SMU10_UMD_PSTATE_GFXCLK :\n\t\t\t\t\t\tdata->gfx_min_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\thigh == 0 ? data->gfx_min_freq_limit/100 :\n\t\t\t\t\t\thigh == 1 ? SMU10_UMD_PSTATE_GFXCLK :\n\t\t\t\t\t\tdata->gfx_max_freq_limit/100,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\n\tcase PP_MCLK:\n\t\tif (low > mclk_table->count - 1 || high > mclk_table->count - 1)\n\t\t\treturn -EINVAL;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\tmclk_table->entries[low].clk/100,\n\t\t\t\t\t\tNULL);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\tmclk_table->entries[high].clk/100,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\n\tcase PP_PCIE:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int smu10_print_clock_levels(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, char *buf)\n{\n\tstruct smu10_hwmgr *data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct smu10_voltage_dependency_table *mclk_table =\n\t\t\tdata->clock_vol_info.vdd_dep_on_fclk;\n\tuint32_t i, now, size = 0;\n\tuint32_t min_freq, max_freq = 0;\n\tuint32_t ret = 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetGfxclkFrequency, &now);\n\n\t \n\t\tif (now == data->gfx_max_freq_limit/100)\n\t\t\ti = 2;\n\t\telse if (now == data->gfx_min_freq_limit/100)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\n\t\tsize += sprintf(buf + size, \"0: %uMhz %s\\n\",\n\t\t\t\t\tdata->gfx_min_freq_limit/100,\n\t\t\t\t\ti == 0 ? \"*\" : \"\");\n\t\tsize += sprintf(buf + size, \"1: %uMhz %s\\n\",\n\t\t\t\t\ti == 1 ? now : SMU10_UMD_PSTATE_GFXCLK,\n\t\t\t\t\ti == 1 ? \"*\" : \"\");\n\t\tsize += sprintf(buf + size, \"2: %uMhz %s\\n\",\n\t\t\t\t\tdata->gfx_max_freq_limit/100,\n\t\t\t\t\ti == 2 ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_MCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetFclkFrequency, &now);\n\n\t\tfor (i = 0; i < mclk_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti,\n\t\t\t\t\tmclk_table->entries[i].clk / 100,\n\t\t\t\t\t((mclk_table->entries[i].clk / 100)\n\t\t\t\t\t == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase OD_SCLK:\n\t\tif (hwmgr->od_enabled) {\n\t\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &min_freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &max_freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_SCLK\");\n\t\t\tsize += sprintf(buf + size, \"0: %10uMhz\\n\",\n\t\t\t(data->gfx_actual_soft_min_freq > 0) ? data->gfx_actual_soft_min_freq : min_freq);\n\t\t\tsize += sprintf(buf + size, \"1: %10uMhz\\n\",\n\t\t\t(data->gfx_actual_soft_max_freq > 0) ? data->gfx_actual_soft_max_freq : max_freq);\n\t\t}\n\t\tbreak;\n\tcase OD_RANGE:\n\t\tif (hwmgr->od_enabled) {\n\t\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &min_freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &max_freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_RANGE\");\n\t\t\tsize += sprintf(buf + size, \"SCLK: %7uMHz %10uMHz\\n\",\n\t\t\t\tmin_freq, max_freq);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int smu10_get_performance_level(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state,\n\t\t\t\tPHM_PerformanceLevelDesignation designation, uint32_t index,\n\t\t\t\tPHM_PerformanceLevel *level)\n{\n\tstruct smu10_hwmgr *data;\n\n\tif (level == NULL || hwmgr == NULL || state == NULL)\n\t\treturn -EINVAL;\n\n\tdata = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (index == 0) {\n\t\tlevel->memory_clock = data->clock_vol_info.vdd_dep_on_fclk->entries[0].clk;\n\t\tlevel->coreClock = data->gfx_min_freq_limit;\n\t} else {\n\t\tlevel->memory_clock = data->clock_vol_info.vdd_dep_on_fclk->entries[\n\t\t\tdata->clock_vol_info.vdd_dep_on_fclk->count - 1].clk;\n\t\tlevel->coreClock = data->gfx_max_freq_limit;\n\t}\n\n\tlevel->nonLocalMemoryFreq = 0;\n\tlevel->nonLocalMemoryWidth = 0;\n\n\treturn 0;\n}\n\nstatic int smu10_get_current_shallow_sleep_clocks(struct pp_hwmgr *hwmgr,\n\tconst struct pp_hw_power_state *state, struct pp_clock_info *clock_info)\n{\n\tconst struct smu10_power_state *ps = cast_const_smu10_ps(state);\n\n\tclock_info->min_eng_clk = ps->levels[0].engine_clock / (1 << (ps->levels[0].ss_divider_index));\n\tclock_info->max_eng_clk = ps->levels[ps->level - 1].engine_clock / (1 << (ps->levels[ps->level - 1].ss_divider_index));\n\n\treturn 0;\n}\n\n#define MEM_FREQ_LOW_LATENCY        25000\n#define MEM_FREQ_HIGH_LATENCY       80000\n#define MEM_LATENCY_HIGH            245\n#define MEM_LATENCY_LOW             35\n#define MEM_LATENCY_ERR             0xFFFF\n\n\nstatic uint32_t smu10_get_mem_latency(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock)\n{\n\tif (clock >= MEM_FREQ_LOW_LATENCY &&\n\t\t\tclock < MEM_FREQ_HIGH_LATENCY)\n\t\treturn MEM_LATENCY_HIGH;\n\telse if (clock >= MEM_FREQ_HIGH_LATENCY)\n\t\treturn MEM_LATENCY_LOW;\n\telse\n\t\treturn MEM_LATENCY_ERR;\n}\n\nstatic int smu10_get_clock_by_type_with_latency(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tuint32_t i;\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct smu10_clock_voltage_information *pinfo = &(smu10_data->clock_vol_info);\n\tstruct smu10_voltage_dependency_table *pclk_vol_table;\n\tbool latency_required = false;\n\n\tif (pinfo == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase amd_pp_mem_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_mclk;\n\t\tlatency_required = true;\n\t\tbreak;\n\tcase amd_pp_f_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_fclk;\n\t\tlatency_required = true;\n\t\tbreak;\n\tcase amd_pp_dcf_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_dcefclk;\n\t\tbreak;\n\tcase amd_pp_disp_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_dispclk;\n\t\tbreak;\n\tcase amd_pp_phy_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_phyclk;\n\t\tbreak;\n\tcase amd_pp_dpp_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_dppclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (pclk_vol_table == NULL || pclk_vol_table->count == 0)\n\t\treturn -EINVAL;\n\n\tclocks->num_levels = 0;\n\tfor (i = 0; i < pclk_vol_table->count; i++) {\n\t\tif (pclk_vol_table->entries[i].clk) {\n\t\t\tclocks->data[clocks->num_levels].clocks_in_khz =\n\t\t\t\tpclk_vol_table->entries[i].clk * 10;\n\t\t\tclocks->data[clocks->num_levels].latency_in_us = latency_required ?\n\t\t\t\tsmu10_get_mem_latency(hwmgr,\n\t\t\t\t\t\t      pclk_vol_table->entries[i].clk) :\n\t\t\t\t0;\n\t\t\tclocks->num_levels++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_get_clock_by_type_with_voltage(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_voltage *clocks)\n{\n\tuint32_t i;\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct smu10_clock_voltage_information *pinfo = &(smu10_data->clock_vol_info);\n\tstruct smu10_voltage_dependency_table *pclk_vol_table = NULL;\n\n\tif (pinfo == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase amd_pp_mem_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_mclk;\n\t\tbreak;\n\tcase amd_pp_f_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_fclk;\n\t\tbreak;\n\tcase amd_pp_dcf_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_dcefclk;\n\t\tbreak;\n\tcase amd_pp_soc_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_socclk;\n\t\tbreak;\n\tcase amd_pp_disp_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_dispclk;\n\t\tbreak;\n\tcase amd_pp_phy_clock:\n\t\tpclk_vol_table = pinfo->vdd_dep_on_phyclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (pclk_vol_table == NULL || pclk_vol_table->count == 0)\n\t\treturn -EINVAL;\n\n\tclocks->num_levels = 0;\n\tfor (i = 0; i < pclk_vol_table->count; i++) {\n\t\tif (pclk_vol_table->entries[i].clk) {\n\t\t\tclocks->data[clocks->num_levels].clocks_in_khz = pclk_vol_table->entries[i].clk  * 10;\n\t\t\tclocks->data[clocks->num_levels].voltage_in_mv = pclk_vol_table->entries[i].vol;\n\t\t\tclocks->num_levels++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\nstatic int smu10_get_max_high_clocks(struct pp_hwmgr *hwmgr, struct amd_pp_simple_clock_info *clocks)\n{\n\tclocks->engine_max_clock = 80000;  \n\treturn 0;\n}\n\nstatic int smu10_thermal_get_temperature(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t reg_value = RREG32_SOC15(THM, 0, mmTHM_TCON_CUR_TMP);\n\tint cur_temp =\n\t\t(reg_value & THM_TCON_CUR_TMP__CUR_TEMP_MASK) >> THM_TCON_CUR_TMP__CUR_TEMP__SHIFT;\n\n\tif (cur_temp & THM_TCON_CUR_TMP__CUR_TEMP_RANGE_SEL_MASK)\n\t\tcur_temp = ((cur_temp / 8) - 49) * PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\telse\n\t\tcur_temp = (cur_temp / 8) * PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn cur_temp;\n}\n\nstatic int smu10_read_sensor(struct pp_hwmgr *hwmgr, int idx,\n\t\t\t  void *value, int *size)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t sclk, mclk, activity_percent;\n\tbool has_gfx_busy;\n\tint ret = 0;\n\n\t \n\tif ((adev->apu_flags & AMD_APU_IS_PICASSO) &&\n\t    (hwmgr->smu_version >= 0x41e3b))\n\t\thas_gfx_busy = true;\n\telse if ((adev->apu_flags & AMD_APU_IS_RAVEN) &&\n\t\t (hwmgr->smu_version >= 0x1e5500))\n\t\thas_gfx_busy = true;\n\telse\n\t\thas_gfx_busy = false;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetGfxclkFrequency, &sclk);\n\t\t\t \n\t\t*((uint32_t *)value) = sclk * 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetFclkFrequency, &mclk);\n\t\t\t \n\t\t*((uint32_t *)value) = mclk * 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_TEMP:\n\t\t*((uint32_t *)value) = smu10_thermal_get_temperature(hwmgr);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VCN_POWER_STATE:\n\t\t*(uint32_t *)value =  smu10_data->vcn_power_gated ? 0 : 1;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tif (!has_gfx_busy)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse {\n\t\t\tret = smum_send_msg_to_smc(hwmgr,\n\t\t\t\t\t\t   PPSMC_MSG_GetGfxBusy,\n\t\t\t\t\t\t   &activity_percent);\n\t\t\tif (!ret)\n\t\t\t\t*((uint32_t *)value) = min(activity_percent, (u32)100);\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu10_set_watermarks_for_clocks_ranges(struct pp_hwmgr *hwmgr,\n\t\tvoid *clock_ranges)\n{\n\tstruct smu10_hwmgr *data = hwmgr->backend;\n\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges = clock_ranges;\n\tWatermarks_t *table = &(data->water_marks_table);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint i;\n\n\tsmu_set_watermarks_for_clocks_ranges(table, wm_with_clock_ranges);\n\n\tif (adev->apu_flags & AMD_APU_IS_RAVEN2) {\n\t\tfor (i = 0; i < NUM_WM_RANGES; i++)\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].WmType = (uint8_t)0;\n\n\t\tfor (i = 0; i < NUM_WM_RANGES; i++)\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmType = (uint8_t)0;\n\t}\n\n\tsmum_smc_table_manager(hwmgr, (uint8_t *)table, (uint16_t)SMU10_WMTABLE, false);\n\tdata->water_marks_exist = true;\n\treturn 0;\n}\n\nstatic int smu10_smus_notify_pwe(struct pp_hwmgr *hwmgr)\n{\n\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_SetRccPfcPmeRestoreRegister, NULL);\n}\n\nstatic int smu10_powergate_mmhub(struct pp_hwmgr *hwmgr)\n{\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_PowerGateMmHub, NULL);\n}\n\nstatic int smu10_powergate_sdma(struct pp_hwmgr *hwmgr, bool gate)\n{\n\tif (gate)\n\t\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_PowerDownSdma, NULL);\n\telse\n\t\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_PowerUpSdma, NULL);\n}\n\nstatic void smu10_powergate_vcn(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\n\tif (bgate) {\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCN,\n\t\t\t\t\t\tAMD_PG_STATE_GATE);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_PowerDownVcn, 0, NULL);\n\t\tsmu10_data->vcn_power_gated = true;\n\t} else {\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_PowerUpVcn, 0, NULL);\n\t\tamdgpu_device_ip_set_powergating_state(hwmgr->adev,\n\t\t\t\t\t\tAMD_IP_BLOCK_TYPE_VCN,\n\t\t\t\t\t\tAMD_PG_STATE_UNGATE);\n\t\tsmu10_data->vcn_power_gated = false;\n\t}\n}\n\nstatic int conv_power_profile_to_pplib_workload(int power_profile)\n{\n\tint pplib_workload = 0;\n\n\tswitch (power_profile) {\n\tcase PP_SMC_POWER_PROFILE_FULLSCREEN3D:\n\t\tpplib_workload = WORKLOAD_PPLIB_FULL_SCREEN_3D_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_VIDEO:\n\t\tpplib_workload = WORKLOAD_PPLIB_VIDEO_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_VR:\n\t\tpplib_workload = WORKLOAD_PPLIB_VR_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_COMPUTE:\n\t\tpplib_workload = WORKLOAD_PPLIB_COMPUTE_BIT;\n\t\tbreak;\n\tcase PP_SMC_POWER_PROFILE_CUSTOM:\n\t\tpplib_workload = WORKLOAD_PPLIB_CUSTOM_BIT;\n\t\tbreak;\n\t}\n\n\treturn pplib_workload;\n}\n\nstatic int smu10_get_power_profile_mode(struct pp_hwmgr *hwmgr, char *buf)\n{\n\tuint32_t i, size = 0;\n\tstatic const uint8_t\n\t\tprofile_mode_setting[6][4] = {{70, 60, 0, 0,},\n\t\t\t\t\t\t{70, 60, 1, 3,},\n\t\t\t\t\t\t{90, 60, 0, 0,},\n\t\t\t\t\t\t{70, 60, 0, 0,},\n\t\t\t\t\t\t{70, 90, 0, 0,},\n\t\t\t\t\t\t{30, 60, 0, 6,},\n\t\t\t\t\t\t};\n\tstatic const char *title[6] = {\"NUM\",\n\t\t\t\"MODE_NAME\",\n\t\t\t\"BUSY_SET_POINT\",\n\t\t\t\"FPS\",\n\t\t\t\"USE_RLC_BUSY\",\n\t\t\t\"MIN_ACTIVE_LEVEL\"};\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tphm_get_sysfs_buf(&buf, &size);\n\n\tsize += sysfs_emit_at(buf, size, \"%s %16s %s %s %s %s\\n\", title[0],\n\t\t\ttitle[1], title[2], title[3], title[4], title[5]);\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_COMPUTE; i++)\n\t\tsize += sysfs_emit_at(buf, size, \"%3d %14s%s: %14d %3d %10d %14d\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == hwmgr->power_profile_mode) ? \"*\" : \" \",\n\t\t\tprofile_mode_setting[i][0], profile_mode_setting[i][1],\n\t\t\tprofile_mode_setting[i][2], profile_mode_setting[i][3]);\n\n\treturn size;\n}\n\nstatic bool smu10_is_raven1_refresh(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tif ((adev->apu_flags & AMD_APU_IS_RAVEN) &&\n\t    (hwmgr->smu_version >= 0x41e2b))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int smu10_set_power_profile_mode(struct pp_hwmgr *hwmgr, long *input, uint32_t size)\n{\n\tint workload_type = 0;\n\tint result = 0;\n\n\tif (input[size] > PP_SMC_POWER_PROFILE_COMPUTE) {\n\t\tpr_err(\"Invalid power profile mode %ld\\n\", input[size]);\n\t\treturn -EINVAL;\n\t}\n\tif (hwmgr->power_profile_mode == input[size])\n\t\treturn 0;\n\n\t \n\tworkload_type =\n\t\tconv_power_profile_to_pplib_workload(input[size]);\n\tif (workload_type &&\n\t    smu10_is_raven1_refresh(hwmgr) &&\n\t    !hwmgr->gfxoff_state_changed_by_workload) {\n\t\tsmu10_gfx_off_control(hwmgr, false);\n\t\thwmgr->gfxoff_state_changed_by_workload = true;\n\t}\n\tresult = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ActiveProcessNotify,\n\t\t\t\t\t\t1 << workload_type,\n\t\t\t\t\t\tNULL);\n\tif (!result)\n\t\thwmgr->power_profile_mode = input[size];\n\tif (workload_type && hwmgr->gfxoff_state_changed_by_workload) {\n\t\tsmu10_gfx_off_control(hwmgr, true);\n\t\thwmgr->gfxoff_state_changed_by_workload = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_asic_reset(struct pp_hwmgr *hwmgr, enum SMU_ASIC_RESET_MODE mode)\n{\n\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\t   PPSMC_MSG_DeviceDriverReset,\n\t\t\t\t\t\t   mode,\n\t\t\t\t\t\t   NULL);\n}\n\nstatic int smu10_set_fine_grain_clk_vol(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong *input, uint32_t size)\n{\n\tuint32_t min_freq, max_freq = 0;\n\tstruct smu10_hwmgr *smu10_data = (struct smu10_hwmgr *)(hwmgr->backend);\n\tint ret = 0;\n\n\tif (!hwmgr->od_enabled) {\n\t\tpr_err(\"Fine grain not support\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!smu10_data->fine_grain_enabled) {\n\t\tpr_err(\"pp_od_clk_voltage is not accessible if power_dpm_force_performance_level is not in manual mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (type == PP_OD_EDIT_SCLK_VDDC_TABLE) {\n\t\tif (size != 2) {\n\t\t\tpr_err(\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &min_freq);\n\t\t\tif (input[1] < min_freq) {\n\t\t\t\tpr_err(\"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu10_data->gfx_actual_soft_min_freq = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &max_freq);\n\t\t\tif (input[1] > max_freq) {\n\t\t\t\tpr_err(\"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu10_data->gfx_actual_soft_max_freq = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (type == PP_OD_RESTORE_DEFAULT_TABLE) {\n\t\tif (size != 0) {\n\t\t\tpr_err(\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMinGfxclkFrequency, &min_freq);\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetMaxGfxclkFrequency, &max_freq);\n\n\t\tsmu10_data->gfx_actual_soft_min_freq = min_freq;\n\t\tsmu10_data->gfx_actual_soft_max_freq = max_freq;\n\t} else if (type == PP_OD_COMMIT_DPM_TABLE) {\n\t\tif (size != 0) {\n\t\t\tpr_err(\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (smu10_data->gfx_actual_soft_min_freq > smu10_data->gfx_actual_soft_max_freq) {\n\t\t\tpr_err(\"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\",\n\t\t\t\t\tsmu10_data->gfx_actual_soft_min_freq, smu10_data->gfx_actual_soft_max_freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetHardMinGfxClk,\n\t\t\t\t\tsmu10_data->gfx_actual_soft_min_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\tsmu10_data->gfx_actual_soft_max_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_gfx_state_change(struct pp_hwmgr *hwmgr, uint32_t state)\n{\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GpuChangeState, state, NULL);\n\n\treturn 0;\n}\n\nstatic const struct pp_hwmgr_func smu10_hwmgr_funcs = {\n\t.backend_init = smu10_hwmgr_backend_init,\n\t.backend_fini = smu10_hwmgr_backend_fini,\n\t.apply_state_adjust_rules = smu10_apply_state_adjust_rules,\n\t.force_dpm_level = smu10_dpm_force_dpm_level,\n\t.get_power_state_size = smu10_get_power_state_size,\n\t.powerdown_uvd = NULL,\n\t.powergate_uvd = smu10_powergate_vcn,\n\t.powergate_vce = NULL,\n\t.get_mclk = smu10_dpm_get_mclk,\n\t.get_sclk = smu10_dpm_get_sclk,\n\t.patch_boot_state = smu10_dpm_patch_boot_state,\n\t.get_pp_table_entry = smu10_dpm_get_pp_table_entry,\n\t.get_num_of_pp_table_entries = smu10_dpm_get_num_of_pp_table_entries,\n\t.set_cpu_power_state = smu10_set_cpu_power_state,\n\t.store_cc6_data = smu10_store_cc6_data,\n\t.force_clock_level = smu10_force_clock_level,\n\t.print_clock_levels = smu10_print_clock_levels,\n\t.get_dal_power_level = smu10_get_dal_power_level,\n\t.get_performance_level = smu10_get_performance_level,\n\t.get_current_shallow_sleep_clocks = smu10_get_current_shallow_sleep_clocks,\n\t.get_clock_by_type_with_latency = smu10_get_clock_by_type_with_latency,\n\t.get_clock_by_type_with_voltage = smu10_get_clock_by_type_with_voltage,\n\t.set_watermarks_for_clocks_ranges = smu10_set_watermarks_for_clocks_ranges,\n\t.get_max_high_clocks = smu10_get_max_high_clocks,\n\t.read_sensor = smu10_read_sensor,\n\t.set_active_display_count = smu10_set_active_display_count,\n\t.set_min_deep_sleep_dcefclk = smu10_set_min_deep_sleep_dcefclk,\n\t.dynamic_state_management_enable = smu10_enable_dpm_tasks,\n\t.power_off_asic = smu10_power_off_asic,\n\t.asic_setup = smu10_setup_asic_task,\n\t.power_state_set = smu10_set_power_state_tasks,\n\t.dynamic_state_management_disable = smu10_disable_dpm_tasks,\n\t.powergate_mmhub = smu10_powergate_mmhub,\n\t.smus_notify_pwe = smu10_smus_notify_pwe,\n\t.display_clock_voltage_request = smu10_display_clock_voltage_request,\n\t.powergate_gfx = smu10_gfx_off_control,\n\t.powergate_sdma = smu10_powergate_sdma,\n\t.set_hard_min_dcefclk_by_freq = smu10_set_hard_min_dcefclk_by_freq,\n\t.set_hard_min_fclk_by_freq = smu10_set_hard_min_fclk_by_freq,\n\t.set_hard_min_gfxclk_by_freq = smu10_set_hard_min_gfxclk_by_freq,\n\t.set_soft_max_gfxclk_by_freq = smu10_set_soft_max_gfxclk_by_freq,\n\t.get_power_profile_mode = smu10_get_power_profile_mode,\n\t.set_power_profile_mode = smu10_set_power_profile_mode,\n\t.asic_reset = smu10_asic_reset,\n\t.set_fine_grain_clk_vol = smu10_set_fine_grain_clk_vol,\n\t.gfx_state_change = smu10_gfx_state_change,\n};\n\nint smu10_init_function_pointers(struct pp_hwmgr *hwmgr)\n{\n\thwmgr->hwmgr_func = &smu10_hwmgr_funcs;\n\thwmgr->pptable_func = &pptable_funcs;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}