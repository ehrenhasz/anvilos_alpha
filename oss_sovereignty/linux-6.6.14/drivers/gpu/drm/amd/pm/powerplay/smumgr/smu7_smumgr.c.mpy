{
  "module_name": "smu7_smumgr.c",
  "hash_id": "785ec1ee3fe224c28bb871271a06f906c31fd11b7b9f6af911fc090985ddafa1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/smu7_smumgr.c",
  "human_readable_source": " \n\n\n#include \"pp_debug.h\"\n#include \"smumgr.h\"\n#include \"smu_ucode_xfer_vi.h\"\n#include \"ppatomctrl.h\"\n#include \"cgs_common.h\"\n#include \"smu7_ppsmc.h\"\n#include \"smu7_smumgr.h\"\n#include \"smu7_common.h\"\n\n#include \"polaris10_pwrvirus.h\"\n\n#define SMU7_SMC_SIZE 0x20000\n\nstatic int smu7_set_smc_sram_address(struct pp_hwmgr *hwmgr, uint32_t smc_addr, uint32_t limit)\n{\n\tPP_ASSERT_WITH_CODE((0 == (3 & smc_addr)), \"SMC address must be 4 byte aligned.\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE((limit > (smc_addr + 3)), \"SMC addr is beyond the SMC RAM area.\", return -EINVAL);\n\n\tcgs_write_register(hwmgr->device, mmSMC_IND_INDEX_11, smc_addr);\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);  \n\treturn 0;\n}\n\n\nint smu7_copy_bytes_from_smc(struct pp_hwmgr *hwmgr, uint32_t smc_start_address, uint32_t *dest, uint32_t byte_count, uint32_t limit)\n{\n\tuint32_t data;\n\tuint32_t addr;\n\tuint8_t *dest_byte;\n\tuint8_t i, data_byte[4] = {0};\n\tuint32_t *pdata = (uint32_t *)&data_byte;\n\n\tPP_ASSERT_WITH_CODE((0 == (3 & smc_start_address)), \"SMC address must be 4 byte aligned.\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE((limit > (smc_start_address + byte_count)), \"SMC address is beyond the SMC RAM area.\", return -EINVAL);\n\n\taddr = smc_start_address;\n\n\twhile (byte_count >= 4) {\n\t\tsmu7_read_smc_sram_dword(hwmgr, addr, &data, limit);\n\n\t\t*dest = PP_SMC_TO_HOST_UL(data);\n\n\t\tdest += 1;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\tif (byte_count) {\n\t\tsmu7_read_smc_sram_dword(hwmgr, addr, &data, limit);\n\t\t*pdata = PP_SMC_TO_HOST_UL(data);\n\t \n\t\tdest_byte = (uint8_t *)dest;\n\t\tfor (i = 0; i < byte_count; i++)\n\t\t\tdest_byte[i] = data_byte[i];\n\t}\n\n\treturn 0;\n}\n\n\nint smu7_copy_bytes_to_smc(struct pp_hwmgr *hwmgr, uint32_t smc_start_address,\n\t\t\t\tconst uint8_t *src, uint32_t byte_count, uint32_t limit)\n{\n\tint result;\n\tuint32_t data = 0;\n\tuint32_t original_data;\n\tuint32_t addr = 0;\n\tuint32_t extra_shift;\n\n\tPP_ASSERT_WITH_CODE((0 == (3 & smc_start_address)), \"SMC address must be 4 byte aligned.\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE((limit > (smc_start_address + byte_count)), \"SMC address is beyond the SMC RAM area.\", return -EINVAL);\n\n\taddr = smc_start_address;\n\n\twhile (byte_count >= 4) {\n\t \n\t\tdata = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];\n\n\t\tresult = smu7_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_11, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\tif (0 != byte_count) {\n\n\t\tdata = 0;\n\n\t\tresult = smu7_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\n\t\toriginal_data = cgs_read_register(hwmgr->device, mmSMC_IND_DATA_11);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (0x100 * data) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tresult = smu7_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_11, data);\n\t}\n\n\treturn 0;\n}\n\n\nint smu7_program_jump_on_start(struct pp_hwmgr *hwmgr)\n{\n\tstatic const unsigned char data[4] = { 0xE0, 0x00, 0x80, 0x40 };\n\n\tsmu7_copy_bytes_to_smc(hwmgr, 0x0, data, 4, sizeof(data)+1);\n\n\treturn 0;\n}\n\nbool smu7_is_smc_ram_running(struct pp_hwmgr *hwmgr)\n{\n\treturn ((0 == PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable))\n\t&& (0x20100 <= cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixSMC_PC_C)));\n}\n\nint smu7_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret;\n\n\tPHM_WAIT_FIELD_UNEQUAL(hwmgr, SMC_RESP_0, SMC_RESP, 0);\n\n\tret = PHM_READ_FIELD(hwmgr->device, SMC_RESP_0, SMC_RESP);\n\n\tif (ret == 0xFE)\n\t\tdev_dbg(adev->dev, \"last message was not supported\\n\");\n\telse if (ret != 1)\n\t\tdev_info(adev->dev,\n\t\t\t\"\\nlast message was failed ret is %d\\n\", ret);\n\n\tcgs_write_register(hwmgr->device, mmSMC_RESP_0, 0);\n\tcgs_write_register(hwmgr->device, mmSMC_MESSAGE_0, msg);\n\n\tPHM_WAIT_FIELD_UNEQUAL(hwmgr, SMC_RESP_0, SMC_RESP, 0);\n\n\tret = PHM_READ_FIELD(hwmgr->device, SMC_RESP_0, SMC_RESP);\n\n\tif (ret == 0xFE)\n\t\tdev_dbg(adev->dev, \"message %x was not supported\\n\", msg);\n\telse if (ret != 1)\n\t\tdev_dbg(adev->dev,\n\t\t\t\"failed to send message %x ret is %d \\n\",  msg, ret);\n\n\treturn 0;\n}\n\nint smu7_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr, uint16_t msg, uint32_t parameter)\n{\n\tPHM_WAIT_FIELD_UNEQUAL(hwmgr, SMC_RESP_0, SMC_RESP, 0);\n\n\tcgs_write_register(hwmgr->device, mmSMC_MSG_ARG_0, parameter);\n\n\treturn smu7_send_msg_to_smc(hwmgr, msg);\n}\n\nuint32_t smu7_get_argument(struct pp_hwmgr *hwmgr)\n{\n\treturn cgs_read_register(hwmgr->device, mmSMC_MSG_ARG_0);\n}\n\nint smu7_send_msg_to_smc_offset(struct pp_hwmgr *hwmgr)\n{\n\treturn smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_Test, 0x20000, NULL);\n}\n\nenum cgs_ucode_id smu7_convert_fw_type_to_cgs(uint32_t fw_type)\n{\n\tenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\n\n\tswitch (fw_type) {\n\tcase UCODE_ID_SMU:\n\t\tresult = CGS_UCODE_ID_SMU;\n\t\tbreak;\n\tcase UCODE_ID_SMU_SK:\n\t\tresult = CGS_UCODE_ID_SMU_SK;\n\t\tbreak;\n\tcase UCODE_ID_SDMA0:\n\t\tresult = CGS_UCODE_ID_SDMA0;\n\t\tbreak;\n\tcase UCODE_ID_SDMA1:\n\t\tresult = CGS_UCODE_ID_SDMA1;\n\t\tbreak;\n\tcase UCODE_ID_CP_CE:\n\t\tresult = CGS_UCODE_ID_CP_CE;\n\t\tbreak;\n\tcase UCODE_ID_CP_PFP:\n\t\tresult = CGS_UCODE_ID_CP_PFP;\n\t\tbreak;\n\tcase UCODE_ID_CP_ME:\n\t\tresult = CGS_UCODE_ID_CP_ME;\n\t\tbreak;\n\tcase UCODE_ID_CP_MEC:\n\t\tresult = CGS_UCODE_ID_CP_MEC;\n\t\tbreak;\n\tcase UCODE_ID_CP_MEC_JT1:\n\t\tresult = CGS_UCODE_ID_CP_MEC_JT1;\n\t\tbreak;\n\tcase UCODE_ID_CP_MEC_JT2:\n\t\tresult = CGS_UCODE_ID_CP_MEC_JT2;\n\t\tbreak;\n\tcase UCODE_ID_RLC_G:\n\t\tresult = CGS_UCODE_ID_RLC_G;\n\t\tbreak;\n\tcase UCODE_ID_MEC_STORAGE:\n\t\tresult = CGS_UCODE_ID_STORAGE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n\nint smu7_read_smc_sram_dword(struct pp_hwmgr *hwmgr, uint32_t smc_addr, uint32_t *value, uint32_t limit)\n{\n\tint result;\n\n\tresult = smu7_set_smc_sram_address(hwmgr, smc_addr, limit);\n\n\t*value = result ? 0 : cgs_read_register(hwmgr->device, mmSMC_IND_DATA_11);\n\n\treturn result;\n}\n\nint smu7_write_smc_sram_dword(struct pp_hwmgr *hwmgr, uint32_t smc_addr, uint32_t value, uint32_t limit)\n{\n\tint result;\n\n\tresult = smu7_set_smc_sram_address(hwmgr, smc_addr, limit);\n\n\tif (result)\n\t\treturn result;\n\n\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_11, value);\n\n\treturn 0;\n}\n\nstatic int smu7_populate_single_firmware_entry(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tuint32_t fw_type,\n\t\t\t\t\t\tstruct SMU_Entry *entry)\n{\n\tint result = 0;\n\tstruct cgs_firmware_info info = {0};\n\n\tresult = cgs_get_firmware_info(hwmgr->device,\n\t\t\t\tsmu7_convert_fw_type_to_cgs(fw_type),\n\t\t\t\t&info);\n\n\tif (!result) {\n\t\tentry->version = info.fw_version;\n\t\tentry->id = (uint16_t)fw_type;\n\t\tentry->image_addr_high = upper_32_bits(info.mc_addr);\n\t\tentry->image_addr_low = lower_32_bits(info.mc_addr);\n\t\tentry->meta_data_addr_high = 0;\n\t\tentry->meta_data_addr_low = 0;\n\n\t\t \n\t\tif (!hwmgr->not_vf)\n\t\t\tinfo.image_size -= 20;\n\t\tentry->data_size_byte = info.image_size;\n\t\tentry->num_register_entries = 0;\n\t}\n\n\tif ((fw_type == UCODE_ID_RLC_G)\n\t\t|| (fw_type == UCODE_ID_CP_MEC))\n\t\tentry->flags = 1;\n\telse\n\t\tentry->flags = 0;\n\n\treturn 0;\n}\n\nint smu7_request_smu_load_fw(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\tuint32_t fw_to_load;\n\tint r = 0;\n\n\tamdgpu_ucode_init_bo(hwmgr->adev);\n\n\tif (smu_data->soft_regs_start)\n\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tsmu_data->soft_regs_start + smum_get_offsetof(hwmgr,\n\t\t\t\t\tSMU_SoftRegisters, UcodeLoadStatus),\n\t\t\t\t\t0x0);\n\n\tif (hwmgr->chip_id > CHIP_TOPAZ) {  \n\t\tif (hwmgr->not_vf) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SMU_DRAM_ADDR_HI,\n\t\t\t\t\t\tupper_32_bits(smu_data->smu_buffer.mc_addr),\n\t\t\t\t\t\tNULL);\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SMU_DRAM_ADDR_LO,\n\t\t\t\t\t\tlower_32_bits(smu_data->smu_buffer.mc_addr),\n\t\t\t\t\t\tNULL);\n\t\t}\n\t\tfw_to_load = UCODE_ID_RLC_G_MASK\n\t\t\t   + UCODE_ID_SDMA0_MASK\n\t\t\t   + UCODE_ID_SDMA1_MASK\n\t\t\t   + UCODE_ID_CP_CE_MASK\n\t\t\t   + UCODE_ID_CP_ME_MASK\n\t\t\t   + UCODE_ID_CP_PFP_MASK\n\t\t\t   + UCODE_ID_CP_MEC_MASK;\n\t} else {\n\t\tfw_to_load = UCODE_ID_RLC_G_MASK\n\t\t\t   + UCODE_ID_SDMA0_MASK\n\t\t\t   + UCODE_ID_SDMA1_MASK\n\t\t\t   + UCODE_ID_CP_CE_MASK\n\t\t\t   + UCODE_ID_CP_ME_MASK\n\t\t\t   + UCODE_ID_CP_PFP_MASK\n\t\t\t   + UCODE_ID_CP_MEC_MASK\n\t\t\t   + UCODE_ID_CP_MEC_JT1_MASK\n\t\t\t   + UCODE_ID_CP_MEC_JT2_MASK;\n\t}\n\n\tif (!smu_data->toc) {\n\t\tstruct SMU_DRAMData_TOC *toc;\n\n\t\tsmu_data->toc = kzalloc(sizeof(struct SMU_DRAMData_TOC), GFP_KERNEL);\n\t\tif (!smu_data->toc)\n\t\t\treturn -ENOMEM;\n\t\ttoc = smu_data->toc;\n\t\ttoc->num_entries = 0;\n\t\ttoc->structure_version = 1;\n\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_RLC_G, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_CE, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_PFP, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_ME, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_MEC, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_MEC_JT1, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_CP_MEC_JT2, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_SDMA0, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_SDMA1, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t\tif (!hwmgr->not_vf)\n\t\t\tPP_ASSERT_WITH_CODE(0 == smu7_populate_single_firmware_entry(hwmgr,\n\t\t\t\tUCODE_ID_MEC_STORAGE, &toc->entry[toc->num_entries++]),\n\t\t\t\t\"Failed to Get Firmware Entry.\", r = -EINVAL; goto failed);\n\t}\n\tmemcpy_toio(smu_data->header_buffer.kaddr, smu_data->toc,\n\t\t    sizeof(struct SMU_DRAMData_TOC));\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_DRV_DRAM_ADDR_HI,\n\t\t\tupper_32_bits(smu_data->header_buffer.mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_DRV_DRAM_ADDR_LO,\n\t\t\tlower_32_bits(smu_data->header_buffer.mc_addr),\n\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_LoadUcodes, fw_to_load, NULL);\n\n\tr = smu7_check_fw_load_finish(hwmgr, fw_to_load);\n\tif (!r)\n\t\treturn 0;\n\n\tpr_err(\"SMU load firmware failed\\n\");\n\nfailed:\n\tkfree(smu_data->toc);\n\tsmu_data->toc = NULL;\n\treturn r;\n}\n\n \nint smu7_check_fw_load_finish(struct pp_hwmgr *hwmgr, uint32_t fw_type)\n{\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\tuint32_t ret;\n\n\tret = phm_wait_on_indirect_register(hwmgr, mmSMC_IND_INDEX_11,\n\t\t\t\t\tsmu_data->soft_regs_start + smum_get_offsetof(hwmgr,\n\t\t\t\t\tSMU_SoftRegisters, UcodeLoadStatus),\n\t\t\t\t\tfw_type, fw_type);\n\treturn ret;\n}\n\nint smu7_reload_firmware(struct pp_hwmgr *hwmgr)\n{\n\treturn hwmgr->smumgr_funcs->start_smu(hwmgr);\n}\n\nstatic int smu7_upload_smc_firmware_data(struct pp_hwmgr *hwmgr, uint32_t length, uint32_t *src, uint32_t limit)\n{\n\tuint32_t byte_count = length;\n\n\tPP_ASSERT_WITH_CODE((limit >= byte_count), \"SMC address is beyond the SMC RAM area.\", return -EINVAL);\n\n\tcgs_write_register(hwmgr->device, mmSMC_IND_INDEX_11, 0x20000);\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 1);\n\n\tfor (; byte_count >= 4; byte_count -= 4)\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_11, *src++);\n\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);\n\n\tPP_ASSERT_WITH_CODE((0 == byte_count), \"SMC size must be divisible by 4.\", return -EINVAL);\n\n\treturn 0;\n}\n\n\nint smu7_upload_smu_firmware_image(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\n\tstruct cgs_firmware_info info = {0};\n\n\tif (smu_data->security_hard_key == 1)\n\t\tcgs_get_firmware_info(hwmgr->device,\n\t\t\tsmu7_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);\n\telse\n\t\tcgs_get_firmware_info(hwmgr->device,\n\t\t\tsmu7_convert_fw_type_to_cgs(UCODE_ID_SMU_SK), &info);\n\n\thwmgr->is_kicker = info.is_kicker;\n\thwmgr->smu_version = info.version;\n\tresult = smu7_upload_smc_firmware_data(hwmgr, info.image_size, (uint32_t *)info.kptr, SMU7_SMC_SIZE);\n\n\treturn result;\n}\n\nstatic void execute_pwr_table(struct pp_hwmgr *hwmgr, const PWR_Command_Table *pvirus, int size)\n{\n\tint i;\n\tuint32_t reg, data;\n\n\tfor (i = 0; i < size; i++) {\n\t\treg  = pvirus->reg;\n\t\tdata = pvirus->data;\n\t\tif (reg != 0xffffffff)\n\t\t\tcgs_write_register(hwmgr->device, reg, data);\n\t\telse\n\t\t\tbreak;\n\t\tpvirus++;\n\t}\n}\n\nstatic void execute_pwr_dfy_table(struct pp_hwmgr *hwmgr, const PWR_DFY_Section *section)\n{\n\tint i;\n\n\tcgs_write_register(hwmgr->device, mmCP_DFY_CNTL, section->dfy_cntl);\n\tcgs_write_register(hwmgr->device, mmCP_DFY_ADDR_HI, section->dfy_addr_hi);\n\tcgs_write_register(hwmgr->device, mmCP_DFY_ADDR_LO, section->dfy_addr_lo);\n\tfor (i = 0; i < section->dfy_size; i++)\n\t\tcgs_write_register(hwmgr->device, mmCP_DFY_DATA_0, section->dfy_data[i]);\n}\n\nint smu7_setup_pwr_virus(struct pp_hwmgr *hwmgr)\n{\n\texecute_pwr_table(hwmgr, pwr_virus_table_pre, ARRAY_SIZE(pwr_virus_table_pre));\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section1);\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section2);\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section3);\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section4);\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section5);\n\texecute_pwr_dfy_table(hwmgr, &pwr_virus_section6);\n\texecute_pwr_table(hwmgr, pwr_virus_table_post, ARRAY_SIZE(pwr_virus_table_post));\n\n\treturn 0;\n}\n\nint smu7_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_smumgr *smu_data;\n\tint r;\n\t \n\tsmu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\tsmu_data->header_buffer.data_size =\n\t\t\t((sizeof(struct SMU_DRAMData_TOC) / 4096) + 1) * 4096;\n\n \n\tr = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\tsmu_data->header_buffer.data_size,\n\t\tPAGE_SIZE,\n\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t&smu_data->header_buffer.handle,\n\t\t&smu_data->header_buffer.mc_addr,\n\t\t&smu_data->header_buffer.kaddr);\n\n\tif (r)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tsmu_data->smu_buffer.data_size = 200*4096;\n\tr = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\tsmu_data->smu_buffer.data_size,\n\t\tPAGE_SIZE,\n\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t&smu_data->smu_buffer.handle,\n\t\t&smu_data->smu_buffer.mc_addr,\n\t\t&smu_data->smu_buffer.kaddr);\n\n\tif (r) {\n\t\tamdgpu_bo_free_kernel(&smu_data->header_buffer.handle,\n\t\t\t\t\t&smu_data->header_buffer.mc_addr,\n\t\t\t\t\t&smu_data->header_buffer.kaddr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (smum_is_hw_avfs_present(hwmgr) &&\n\t    (hwmgr->feature_mask & PP_AVFS_MASK))\n\t\thwmgr->avfs_supported = true;\n\n\treturn 0;\n}\n\n\nint smu7_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\n\tamdgpu_bo_free_kernel(&smu_data->header_buffer.handle,\n\t\t\t\t\t&smu_data->header_buffer.mc_addr,\n\t\t\t\t\t&smu_data->header_buffer.kaddr);\n\n\tif (hwmgr->not_vf)\n\t\tamdgpu_bo_free_kernel(&smu_data->smu_buffer.handle,\n\t\t\t\t\t&smu_data->smu_buffer.mc_addr,\n\t\t\t\t\t&smu_data->smu_buffer.kaddr);\n\n\n\tkfree(smu_data->toc);\n\tsmu_data->toc = NULL;\n\tkfree(hwmgr->smu_backend);\n\thwmgr->smu_backend = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}