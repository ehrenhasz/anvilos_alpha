{
  "module_name": "polaris10_smumgr.c",
  "hash_id": "c7754e592739d878033c2beae5844c11d75e60fc19207ad4e9fd40bd9266c732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/polaris10_smumgr.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"pp_debug.h\"\n#include \"smumgr.h\"\n#include \"smu74.h\"\n#include \"smu_ucode_xfer_vi.h\"\n#include \"polaris10_smumgr.h\"\n#include \"smu74_discrete.h\"\n#include \"smu/smu_7_1_3_d.h\"\n#include \"smu/smu_7_1_3_sh_mask.h\"\n#include \"gmc/gmc_8_1_d.h\"\n#include \"gmc/gmc_8_1_sh_mask.h\"\n#include \"oss/oss_3_0_d.h\"\n#include \"gca/gfx_8_0_d.h\"\n#include \"bif/bif_5_0_d.h\"\n#include \"bif/bif_5_0_sh_mask.h\"\n#include \"ppatomctrl.h\"\n#include \"cgs_common.h\"\n#include \"smu7_ppsmc.h\"\n#include \"smu7_smumgr.h\"\n\n#include \"smu7_dyn_defaults.h\"\n\n#include \"smu7_hwmgr.h\"\n#include \"hardwaremanager.h\"\n#include \"atombios.h\"\n#include \"pppcielanes.h\"\n\n#include \"dce/dce_10_0_d.h\"\n#include \"dce/dce_10_0_sh_mask.h\"\n\n#define POLARIS10_SMC_SIZE 0x20000\n#define POWERTUNE_DEFAULT_SET_MAX    1\n#define VDDC_VDDCI_DELTA            200\n#define MC_CG_ARB_FREQ_F1           0x0b\n\nstatic const struct polaris10_pt_defaults polaris10_power_tune_data_set_array[POWERTUNE_DEFAULT_SET_MAX] = {\n\t \n\t{ 1, 0xF, 0xFD, 0x19, 5, 45, 0, 0xB0000,\n\t{ 0x79, 0x253, 0x25D, 0xAE, 0x72, 0x80, 0x83, 0x86, 0x6F, 0xC8, 0xC9, 0xC9, 0x2F, 0x4D, 0x61},\n\t{ 0x17C, 0x172, 0x180, 0x1BC, 0x1B3, 0x1BD, 0x206, 0x200, 0x203, 0x25D, 0x25A, 0x255, 0x2C3, 0x2C5, 0x2B4 } },\n};\n\nstatic const sclkFcwRange_t Range_Table[NUM_SCLK_RANGE] = {\n\t\t\t{VCO_2_4, POSTDIV_DIV_BY_16,  75, 160, 112},\n\t\t\t{VCO_3_6, POSTDIV_DIV_BY_16, 112, 224, 160},\n\t\t\t{VCO_2_4, POSTDIV_DIV_BY_8,   75, 160, 112},\n\t\t\t{VCO_3_6, POSTDIV_DIV_BY_8,  112, 224, 160},\n\t\t\t{VCO_2_4, POSTDIV_DIV_BY_4,   75, 160, 112},\n\t\t\t{VCO_3_6, POSTDIV_DIV_BY_4,  112, 216, 160},\n\t\t\t{VCO_2_4, POSTDIV_DIV_BY_2,   75, 160, 108},\n\t\t\t{VCO_3_6, POSTDIV_DIV_BY_2,  112, 216, 160} };\n\n#define PPPOLARIS10_TARGETACTIVITY_DFLT                     50\n\nstatic const SMU74_Discrete_GraphicsLevel avfs_graphics_level_polaris10[8] = {\n\t \n\t \n\t{ 0x100ea446, 0x00, 0x03, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x30750000, 0x3000, 0, 0x2600, 0, 0, 0x0004, 0x8f02, 0xffff, 0x2f00, 0x300e, 0x2700 } },\n\t{ 0x400ea446, 0x01, 0x04, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x409c0000, 0x2000, 0, 0x1e00, 1, 1, 0x0004, 0x8300, 0xffff, 0x1f00, 0xcb5e, 0x1a00 } },\n\t{ 0x740ea446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x50c30000, 0x2800, 0, 0x2000, 1, 1, 0x0004, 0x0c02, 0xffff, 0x2700, 0x6433, 0x2100 } },\n\t{ 0xa40ea446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x60ea0000, 0x3000, 0, 0x2600, 1, 1, 0x0004, 0x8f02, 0xffff, 0x2f00, 0x300e, 0x2700 } },\n\t{ 0xd80ea446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x70110100, 0x3800, 0, 0x2c00, 1, 1, 0x0004, 0x1203, 0xffff, 0x3600, 0xc9e2, 0x2e00 } },\n\t{ 0x3c0fa446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x80380100, 0x2000, 0, 0x1e00, 2, 1, 0x0004, 0x8300, 0xffff, 0x1f00, 0xcb5e, 0x1a00 } },\n\t{ 0x6c0fa446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0x905f0100, 0x2400, 0, 0x1e00, 2, 1, 0x0004, 0x8901, 0xffff, 0x2300, 0x314c, 0x1d00 } },\n\t{ 0xa00fa446, 0x01, 0x00, 0x3200, 0, 0, 0, 0, 0, 0, 0x01, 0x01, 0x0a, 0x00, 0x00, 0x00, { 0xa0860100, 0x2800, 0, 0x2000, 2, 1, 0x0004, 0x0c02, 0xffff, 0x2700, 0x6433, 0x2100 } }\n};\n\nstatic const SMU74_Discrete_MemoryLevel avfs_memory_level_polaris10 = {\n\t0x100ea446, 0, 0x30750000, 0x01, 0x01, 0x01, 0x00, 0x00, 0x64, 0x00, 0x00, 0x1f00, 0x00, 0x00};\n\nstatic int polaris10_perform_btc(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\n\tif (0 != smu_data->avfs_btc_param) {\n\t\tif (0 != smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_PerformBtc, smu_data->avfs_btc_param,\n\t\t\t\t\tNULL)) {\n\t\t\tpr_info(\"[AVFS][SmuPolaris10_PerformBtc] PerformBTC SMU msg failed\");\n\t\t\tresult = -1;\n\t\t}\n\t}\n\tif (smu_data->avfs_btc_param > 1) {\n\t\t \n\t\t \n\t\tcgs_write_register(hwmgr->device, mmCP_MEC_CNTL, 0x50000000);\n\t\t \n\t\tcgs_write_register(hwmgr->device, mmGRBM_SOFT_RESET, 0xffffffff);\n\t\tcgs_write_register(hwmgr->device, mmGRBM_SOFT_RESET, 0);\n\t}\n\treturn result;\n}\n\n\nstatic int polaris10_setup_graphics_level_structure(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t vr_config;\n\tuint32_t dpm_table_start;\n\n\tuint16_t u16_boot_mvdd;\n\tuint32_t graphics_level_address, vr_config_address, graphics_level_size;\n\n\tgraphics_level_size = sizeof(avfs_graphics_level_polaris10);\n\tu16_boot_mvdd = PP_HOST_TO_SMC_US(1300 * VOLTAGE_SCALE);\n\n\tPP_ASSERT_WITH_CODE(0 == smu7_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, DpmTable),\n\t\t\t\t&dpm_table_start, 0x40000),\n\t\t\t\"[AVFS][Polaris10_SetupGfxLvlStruct] SMU could not communicate starting address of DPM table\",\n\t\t\treturn -1);\n\n\t \n\tvr_config = 0x01000500;  \n\n\tvr_config_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, VRConfig);\n\n\tPP_ASSERT_WITH_CODE(0 == smu7_copy_bytes_to_smc(hwmgr, vr_config_address,\n\t\t\t\t(uint8_t *)&vr_config, sizeof(uint32_t), 0x40000),\n\t\t\t\"[AVFS][Polaris10_SetupGfxLvlStruct] Problems copying VRConfig value over to SMC\",\n\t\t\treturn -1);\n\n\tgraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, GraphicsLevel);\n\n\tPP_ASSERT_WITH_CODE(0 == smu7_copy_bytes_to_smc(hwmgr, graphics_level_address,\n\t\t\t\t(uint8_t *)(&avfs_graphics_level_polaris10),\n\t\t\t\tgraphics_level_size, 0x40000),\n\t\t\t\"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of SCLK DPM table failed!\",\n\t\t\treturn -1);\n\n\tgraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, MemoryLevel);\n\n\tPP_ASSERT_WITH_CODE(0 == smu7_copy_bytes_to_smc(hwmgr, graphics_level_address,\n\t\t\t\t(uint8_t *)(&avfs_memory_level_polaris10), sizeof(avfs_memory_level_polaris10), 0x40000),\n\t\t\t\t\"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of MCLK DPM table failed!\",\n\t\t\treturn -1);\n\n\t \n\n\tgraphics_level_address = dpm_table_start + offsetof(SMU74_Discrete_DpmTable, BootMVdd);\n\n\tPP_ASSERT_WITH_CODE(0 == smu7_copy_bytes_to_smc(hwmgr, graphics_level_address,\n\t\t\t(uint8_t *)(&u16_boot_mvdd), sizeof(u16_boot_mvdd), 0x40000),\n\t\t\t\"[AVFS][Polaris10_SetupGfxLvlStruct] Copying of DPM table failed!\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n\nstatic int polaris10_avfs_event_mgr(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_smumgr *smu_data = (struct smu7_smumgr *)(hwmgr->smu_backend);\n\n\tif (!hwmgr->avfs_supported)\n\t\treturn 0;\n\n\tPP_ASSERT_WITH_CODE(0 == polaris10_setup_graphics_level_structure(hwmgr),\n\t\t\"[AVFS][Polaris10_AVFSEventMgr] Could not Copy Graphics Level table over to SMU\",\n\t\treturn -EINVAL);\n\n\tif (smu_data->avfs_btc_param > 1) {\n\t\tpr_info(\"[AVFS][Polaris10_AVFSEventMgr] AC BTC has not been successfully verified on Fiji. There may be in this setting.\");\n\t\tPP_ASSERT_WITH_CODE(0 == smu7_setup_pwr_virus(hwmgr),\n\t\t\"[AVFS][Polaris10_AVFSEventMgr] Could not setup Pwr Virus for AVFS \",\n\t\treturn -EINVAL);\n\t}\n\n\tPP_ASSERT_WITH_CODE(0 == polaris10_perform_btc(hwmgr),\n\t\t\t\t\"[AVFS][Polaris10_AVFSEventMgr] Failure at SmuPolaris10_PerformBTC. AVFS Disabled\",\n\t\t\t return -EINVAL);\n\n\treturn 0;\n}\n\nstatic int polaris10_start_smu_in_protection_mode(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\n\t \n\t \n\n\t \n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL, rst_reg, 1);\n\n\tresult = smu7_upload_smu_firmware_image(hwmgr);\n\tif (result != 0)\n\t\treturn result;\n\n\t \n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixSMU_STATUS, 0);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\n\n\t \n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL, rst_reg, 0);\n\n\n\tPHM_WAIT_VFPF_INDIRECT_FIELD(hwmgr, SMC_IND, RCU_UC_EVENTS, INTERRUPTS_ENABLED, 1);\n\n\n\t \n\tsmu7_send_msg_to_smc_offset(hwmgr);\n\n\t \n\t \n\n\tPHM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(hwmgr, SMC_IND, SMU_STATUS, SMU_DONE, 0);\n\n\tif (1 != PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\t\tSMU_STATUS, SMU_PASS))\n\t\tPP_ASSERT_WITH_CODE(false, \"SMU Firmware start failed!\", return -1);\n\n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixFIRMWARE_FLAGS, 0);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL, rst_reg, 1);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL, rst_reg, 0);\n\n\t \n\tPHM_WAIT_VFPF_INDIRECT_FIELD(hwmgr, SMC_IND, FIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\n\n\treturn result;\n}\n\nstatic int polaris10_start_smu_in_non_protection_mode(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\n\t \n\tPHM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(hwmgr, SMC_IND, RCU_UC_EVENTS, boot_seq_done, 0);\n\n\t \n\t \n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tixFIRMWARE_FLAGS, 0);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL,\n\t\t\t\t\trst_reg, 1);\n\n\tresult = smu7_upload_smu_firmware_image(hwmgr);\n\tif (result != 0)\n\t\treturn result;\n\n\t \n\tsmu7_program_jump_on_start(hwmgr);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\tSMC_SYSCON_RESET_CNTL, rst_reg, 0);\n\n\t \n\n\tPHM_WAIT_VFPF_INDIRECT_FIELD(hwmgr, SMC_IND,\n\t\t\t\t\tFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\n\n\treturn result;\n}\n\nstatic int polaris10_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\t \n\tif (!smu7_is_smc_ram_running(hwmgr) && hwmgr->not_vf) {\n\t\tsmu_data->protected_mode = (uint8_t) (PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMU_FIRMWARE, SMU_MODE));\n\t\tsmu_data->smu7_data.security_hard_key = (uint8_t) (PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMU_FIRMWARE, SMU_SEL));\n\n\t\t \n\t\tif (smu_data->protected_mode == 0)\n\t\t\tresult = polaris10_start_smu_in_non_protection_mode(hwmgr);\n\t\telse\n\t\t\tresult = polaris10_start_smu_in_protection_mode(hwmgr);\n\n\t\tif (result != 0)\n\t\t\tPP_ASSERT_WITH_CODE(0, \"Failed to load SMU ucode.\", return result);\n\n\t\tpolaris10_avfs_event_mgr(hwmgr);\n\t}\n\n\t \n\tsmu7_read_smc_sram_dword(hwmgr, SMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, SoftRegisters),\n\t\t\t\t\t&(smu_data->smu7_data.soft_regs_start), 0x40000);\n\n\tresult = smu7_request_smu_load_fw(hwmgr);\n\n\treturn result;\n}\n\nstatic bool polaris10_is_hw_avfs_present(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t efuse;\n\n\tefuse = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixSMU_EFUSE_0 + (49*4));\n\tefuse &= 0x00000001;\n\tif (efuse)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int polaris10_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data;\n\n\tsmu_data = kzalloc(sizeof(struct polaris10_smumgr), GFP_KERNEL);\n\tif (smu_data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = smu_data;\n\n\tif (smu7_init(hwmgr)) {\n\t\tkfree(smu_data);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_get_dependency_volt_by_clk(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table,\n\t\tuint32_t clock, SMU_VoltageLevel *voltage, uint32_t *mvdd)\n{\n\tuint32_t i;\n\tuint16_t vddci;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\t*voltage = *mvdd = 0;\n\n\t \n\tif (dep_table->count == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\t \n\t\tif (dep_table->entries[i].clk >= clock) {\n\t\t\t*voltage |= (dep_table->entries[i].vddc *\n\t\t\t\t\tVOLTAGE_SCALE) << VDDC_SHIFT;\n\t\t\tif (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)\n\t\t\t\t*voltage |= (data->vbios_boot_state.vddci_bootup_value *\n\t\t\t\t\t\tVOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\t\telse if (dep_table->entries[i].vddci)\n\t\t\t\t*voltage |= (dep_table->entries[i].vddci *\n\t\t\t\t\t\tVOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\t\telse {\n\t\t\t\tvddci = phm_find_closest_vddci(&(data->vddci_voltage_table),\n\t\t\t\t\t\t(dep_table->entries[i].vddc -\n\t\t\t\t\t\t\t\t(uint16_t)VDDC_VDDCI_DELTA));\n\t\t\t\t*voltage |= (vddci * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\t\t}\n\n\t\t\tif (SMU7_VOLTAGE_CONTROL_NONE == data->mvdd_control)\n\t\t\t\t*mvdd = data->vbios_boot_state.mvdd_bootup_value *\n\t\t\t\t\tVOLTAGE_SCALE;\n\t\t\telse if (dep_table->entries[i].mvdd)\n\t\t\t\t*mvdd = (uint32_t) dep_table->entries[i].mvdd *\n\t\t\t\t\tVOLTAGE_SCALE;\n\n\t\t\t*voltage |= 1 << PHASES_SHIFT;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\t*voltage |= (dep_table->entries[i - 1].vddc * VOLTAGE_SCALE) << VDDC_SHIFT;\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)\n\t\t*voltage |= (data->vbios_boot_state.vddci_bootup_value *\n\t\t\t\tVOLTAGE_SCALE) << VDDCI_SHIFT;\n\telse if (dep_table->entries[i-1].vddci) {\n\t\t*voltage |= (dep_table->entries[i - 1].vddci * VOLTAGE_SCALE) << VDDC_SHIFT;\n\t} else {\n\t\tvddci = phm_find_closest_vddci(&(data->vddci_voltage_table),\n\t\t\t\t(dep_table->entries[i].vddc -\n\t\t\t\t\t\t(uint16_t)VDDC_VDDCI_DELTA));\n\t\t*voltage |= (vddci * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\t}\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE == data->mvdd_control)\n\t\t*mvdd = data->vbios_boot_state.mvdd_bootup_value * VOLTAGE_SCALE;\n\telse if (dep_table->entries[i].mvdd)\n\t\t*mvdd = (uint32_t) dep_table->entries[i - 1].mvdd * VOLTAGE_SCALE;\n\n\treturn 0;\n}\n\nstatic uint16_t scale_fan_gain_settings(uint16_t raw_setting)\n{\n\tuint32_t tmp;\n\ttmp = raw_setting * 4096 / 100;\n\treturn (uint16_t)tmp;\n}\n\nstatic int polaris10_populate_bapm_parameters_in_dpm_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\tconst struct polaris10_pt_defaults *defaults = smu_data->power_tune_defaults;\n\tSMU74_Discrete_DpmTable  *table = &(smu_data->smc_state_table);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_cac_tdp_table *cac_dtp_table = table_info->cac_dtp_table;\n\tstruct pp_advance_fan_control_parameters *fan_table =\n\t\t\t&hwmgr->thermal_controller.advanceFanControlParameters;\n\tint i, j, k;\n\tconst uint16_t *pdef1;\n\tconst uint16_t *pdef2;\n\n\ttable->DefaultTdp = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usTDP * 128));\n\ttable->TargetTdp  = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usTDP * 128));\n\n\tPP_ASSERT_WITH_CODE(cac_dtp_table->usTargetOperatingTemp <= 255,\n\t\t\t\t\"Target Operating Temp is out of Range!\",\n\t\t\t\t);\n\n\ttable->TemperatureLimitEdge = PP_HOST_TO_SMC_US(\n\t\t\tcac_dtp_table->usTargetOperatingTemp * 256);\n\ttable->TemperatureLimitHotspot = PP_HOST_TO_SMC_US(\n\t\t\tcac_dtp_table->usTemperatureLimitHotspot * 256);\n\ttable->FanGainEdge = PP_HOST_TO_SMC_US(\n\t\t\tscale_fan_gain_settings(fan_table->usFanGainEdge));\n\ttable->FanGainHotspot = PP_HOST_TO_SMC_US(\n\t\t\tscale_fan_gain_settings(fan_table->usFanGainHotspot));\n\n\tpdef1 = defaults->BAPMTI_R;\n\tpdef2 = defaults->BAPMTI_RC;\n\n\tfor (i = 0; i < SMU74_DTE_ITERATIONS; i++) {\n\t\tfor (j = 0; j < SMU74_DTE_SOURCES; j++) {\n\t\t\tfor (k = 0; k < SMU74_DTE_SINKS; k++) {\n\t\t\t\ttable->BAPMTI_R[i][j][k] = PP_HOST_TO_SMC_US(*pdef1);\n\t\t\t\ttable->BAPMTI_RC[i][j][k] = PP_HOST_TO_SMC_US(*pdef2);\n\t\t\t\tpdef1++;\n\t\t\t\tpdef2++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void polaris10_populate_zero_rpm_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tSMU74_Discrete_DpmTable  *table = &(smu_data->smc_state_table);\n\tuint16_t fan_stop_temp =\n\t\t((uint16_t)hwmgr->thermal_controller.advanceFanControlParameters.ucFanStopTemperature) << 8;\n\tuint16_t fan_start_temp =\n\t\t((uint16_t)hwmgr->thermal_controller.advanceFanControlParameters.ucFanStartTemperature) << 8;\n\n\tif (hwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM) {\n\t\ttable->FanStartTemperature = PP_HOST_TO_SMC_US(fan_start_temp);\n\t\ttable->FanStopTemperature = PP_HOST_TO_SMC_US(fan_stop_temp);\n\t}\n}\n\nstatic int polaris10_populate_svi_load_line(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tconst struct polaris10_pt_defaults *defaults = smu_data->power_tune_defaults;\n\n\tsmu_data->power_tune_table.SviLoadLineEn = defaults->SviLoadLineEn;\n\tsmu_data->power_tune_table.SviLoadLineVddC = defaults->SviLoadLineVddC;\n\tsmu_data->power_tune_table.SviLoadLineTrimVddC = 3;\n\tsmu_data->power_tune_table.SviLoadLineOffsetVddC = 0;\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_tdc_limit(struct pp_hwmgr *hwmgr)\n{\n\tuint16_t tdc_limit;\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tconst struct polaris10_pt_defaults *defaults = smu_data->power_tune_defaults;\n\n\ttdc_limit = (uint16_t)(table_info->cac_dtp_table->usTDC * 128);\n\tsmu_data->power_tune_table.TDC_VDDC_PkgLimit =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(tdc_limit);\n\tsmu_data->power_tune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\n\t\t\tdefaults->TDC_VDDC_ThrottleReleaseLimitPerc;\n\tsmu_data->power_tune_table.TDC_MAWt = defaults->TDC_MAWt;\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_dw8(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tconst struct polaris10_pt_defaults *defaults = smu_data->power_tune_defaults;\n\tuint32_t temp;\n\n\tif (smu7_read_smc_sram_dword(hwmgr,\n\t\t\tfuse_table_offset +\n\t\t\toffsetof(SMU74_Discrete_PmFuses, TdcWaterfallCtl),\n\t\t\t(uint32_t *)&temp, SMC_RAM_END))\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"Attempt to read PmFuses.DW6 (SviLoadLineEn) from SMC Failed!\",\n\t\t\t\treturn -EINVAL);\n\telse {\n\t\tsmu_data->power_tune_table.TdcWaterfallCtl = defaults->TdcWaterfallCtl;\n\t\tsmu_data->power_tune_table.LPMLTemperatureMin =\n\t\t\t\t(uint8_t)((temp >> 16) & 0xff);\n\t\tsmu_data->power_tune_table.LPMLTemperatureMax =\n\t\t\t\t(uint8_t)((temp >> 8) & 0xff);\n\t\tsmu_data->power_tune_table.Reserved = (uint8_t)(temp & 0xff);\n\t}\n\treturn 0;\n}\n\nstatic int polaris10_populate_temperature_scaler(struct pp_hwmgr *hwmgr)\n{\n\tint i;\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tsmu_data->power_tune_table.LPMLTemperatureScaler[i] = 0;\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_fuzzy_fan(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n \n\tif ((hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity & (1 << 15))\n\t\t|| 0 == hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity)\n\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity =\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity;\n\n\tsmu_data->power_tune_table.FuzzyFan_PwmSetDelta = PP_HOST_TO_SMC_US(\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity);\n\treturn 0;\n}\n\nstatic int polaris10_populate_gnb_lpml(struct pp_hwmgr *hwmgr)\n{\n\tint i;\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tsmu_data->power_tune_table.GnbLPML[i] = 0;\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_bapm_vddc_base_leakage_sidd(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tuint16_t hi_sidd = smu_data->power_tune_table.BapmVddCBaseLeakageHiSidd;\n\tuint16_t lo_sidd = smu_data->power_tune_table.BapmVddCBaseLeakageLoSidd;\n\tstruct phm_cac_tdp_table *cac_table = table_info->cac_dtp_table;\n\n\thi_sidd = (uint16_t)(cac_table->usHighCACLeakage / 100 * 256);\n\tlo_sidd = (uint16_t)(cac_table->usLowCACLeakage / 100 * 256);\n\n\tsmu_data->power_tune_table.BapmVddCBaseLeakageHiSidd =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(hi_sidd);\n\tsmu_data->power_tune_table.BapmVddCBaseLeakageLoSidd =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(lo_sidd);\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_pm_fuses(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tuint32_t pm_fuse_table_offset;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerContainment)) {\n\t\tif (smu7_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU74_Firmware_Header, PmFuseTable),\n\t\t\t\t&pm_fuse_table_offset, SMC_RAM_END))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to get pm_fuse_table_offset Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (polaris10_populate_svi_load_line(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate SviLoadLine Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (polaris10_populate_tdc_limit(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate TDCLimit Failed!\", return -EINVAL);\n\n\t\tif (polaris10_populate_dw8(hwmgr, pm_fuse_table_offset))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate TdcWaterfallCtl, \"\n\t\t\t\t\t\"LPMLTemperature Min and Max Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (0 != polaris10_populate_temperature_scaler(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate LPMLTemperatureScaler Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (polaris10_populate_fuzzy_fan(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate Fuzzy Fan Control parameters Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (polaris10_populate_gnb_lpml(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate GnbLPML Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\n\t\tif (polaris10_populate_bapm_vddc_base_leakage_sidd(hwmgr))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to populate BapmVddCBaseLeakage Hi and Lo \"\n\t\t\t\t\t\"Sidd Failed!\", return -EINVAL);\n\n\t\tif (smu7_copy_bytes_to_smc(hwmgr, pm_fuse_table_offset,\n\t\t\t\t(uint8_t *)&smu_data->power_tune_table,\n\t\t\t\t(sizeof(struct SMU74_Discrete_PmFuses) - 92), SMC_RAM_END))\n\t\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\t\"Attempt to download PmFuseTable Failed!\",\n\t\t\t\t\treturn -EINVAL);\n\t}\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_mvdd_table(struct pp_hwmgr *hwmgr,\n\t\t\tSMU74_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t count, level;\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\n\t\tcount = data->mvdd_voltage_table.count;\n\t\tif (count > SMU_MAX_SMIO_LEVELS)\n\t\t\tcount = SMU_MAX_SMIO_LEVELS;\n\t\tfor (level = 0; level < count; level++) {\n\t\t\ttable->SmioTable2.Pattern[level].Voltage =\n\t\t\t\tPP_HOST_TO_SMC_US(data->mvdd_voltage_table.entries[level].value * VOLTAGE_SCALE);\n\t\t\t \n\t\t\ttable->SmioTable2.Pattern[level].Smio =\n\t\t\t\t(uint8_t) level;\n\t\t\ttable->Smio[level] |=\n\t\t\t\tdata->mvdd_voltage_table.entries[level].smio_low;\n\t\t}\n\t\ttable->SmioMask2 = data->mvdd_voltage_table.mask_low;\n\n\t\ttable->MvddLevelCount = (uint32_t) PP_HOST_TO_SMC_UL(count);\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_vddc_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tuint32_t count, level;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tcount = data->vddc_voltage_table.count;\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control) {\n\t\tif (count > SMU_MAX_SMIO_LEVELS)\n\t\t\tcount = SMU_MAX_SMIO_LEVELS;\n\t\tfor (level = 0; level < count; ++level) {\n\t\t\ttable->SmioTable1.Pattern[level].Voltage =\n\t\t\t\tPP_HOST_TO_SMC_US(data->vddc_voltage_table.entries[level].value * VOLTAGE_SCALE);\n\t\t\ttable->SmioTable1.Pattern[level].Smio = (uint8_t) level;\n\n\t\t\ttable->Smio[level] |= data->vddc_voltage_table.entries[level].smio_low;\n\t\t}\n\n\t\ttable->SmioMask1 = data->vddc_voltage_table.mask_low;\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_vddci_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tuint32_t count, level;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tcount = data->vddci_voltage_table.count;\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\n\t\tif (count > SMU_MAX_SMIO_LEVELS)\n\t\t\tcount = SMU_MAX_SMIO_LEVELS;\n\t\tfor (level = 0; level < count; ++level) {\n\t\t\ttable->SmioTable1.Pattern[level].Voltage =\n\t\t\t\tPP_HOST_TO_SMC_US(data->vddci_voltage_table.entries[level].value * VOLTAGE_SCALE);\n\t\t\ttable->SmioTable1.Pattern[level].Smio = (uint8_t) level;\n\n\t\t\ttable->Smio[level] |= data->vddci_voltage_table.entries[level].smio_low;\n\t\t}\n\n\t\ttable->SmioMask1 = data->vddci_voltage_table.mask_low;\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_cac_table(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tuint32_t count;\n\tuint8_t index;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_voltage_lookup_table *lookup_table =\n\t\t\ttable_info->vddc_lookup_table;\n\t \n\tfor (count = 0; count < lookup_table->count; count++) {\n\t\tindex = phm_get_voltage_index(lookup_table,\n\t\t\t\tdata->vddc_voltage_table.entries[count].value);\n\t\ttable->BapmVddcVidLoSidd[count] = convert_to_vid(lookup_table->entries[index].us_cac_low);\n\t\ttable->BapmVddcVidHiSidd[count] = convert_to_vid(lookup_table->entries[index].us_cac_mid);\n\t\ttable->BapmVddcVidHiSidd2[count] = convert_to_vid(lookup_table->entries[index].us_cac_high);\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_voltage_tables(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tpolaris10_populate_smc_vddc_table(hwmgr, table);\n\tpolaris10_populate_smc_vddci_table(hwmgr, table);\n\tpolaris10_populate_smc_mvdd_table(hwmgr, table);\n\tpolaris10_populate_cac_table(hwmgr, table);\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_ulv_level(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_Ulv *state)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tstate->CcPwrDynRm = 0;\n\tstate->CcPwrDynRm1 = 0;\n\n\tstate->VddcOffset = (uint16_t) table_info->us_ulv_voltage_offset;\n\tstate->VddcOffsetVid = (uint8_t)(table_info->us_ulv_voltage_offset *\n\t\t\tVOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);\n\n\tif ((hwmgr->chip_id == CHIP_POLARIS12) ||\n\t    ASICID_IS_P20(adev->pdev->device, adev->pdev->revision) ||\n\t    ASICID_IS_P21(adev->pdev->device, adev->pdev->revision) ||\n\t    ASICID_IS_P30(adev->pdev->device, adev->pdev->revision) ||\n\t    ASICID_IS_P31(adev->pdev->device, adev->pdev->revision))\n\t\tstate->VddcPhase = data->vddc_phase_shed_control ^ 0x3;\n\telse\n\t\tstate->VddcPhase = (data->vddc_phase_shed_control) ? 0 : 1;\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm);\n\tCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm1);\n\tCONVERT_FROM_HOST_TO_SMC_US(state->VddcOffset);\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_ulv_state(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\treturn polaris10_populate_ulv_level(hwmgr, &table->Ulv);\n}\n\nstatic int polaris10_populate_smc_link_level(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_dpm_table *dpm_table = &data->dpm_table;\n\tint i;\n\n\t \n\tfor (i = 0; i <= dpm_table->pcie_speed_table.count; i++) {\n\t\ttable->LinkLevel[i].PcieGenSpeed  =\n\t\t\t\t(uint8_t)dpm_table->pcie_speed_table.dpm_levels[i].value;\n\t\ttable->LinkLevel[i].PcieLaneCount = (uint8_t)encode_pcie_lane_width(\n\t\t\t\tdpm_table->pcie_speed_table.dpm_levels[i].param1);\n\t\ttable->LinkLevel[i].EnabledForActivity = 1;\n\t\ttable->LinkLevel[i].SPC = (uint8_t)(data->pcie_spc_cap & 0xff);\n\t\ttable->LinkLevel[i].DownThreshold = PP_HOST_TO_SMC_UL(5);\n\t\ttable->LinkLevel[i].UpThreshold = PP_HOST_TO_SMC_UL(30);\n\t}\n\n\tsmu_data->smc_state_table.LinkLevelCount =\n\t\t\t(uint8_t)dpm_table->pcie_speed_table.count;\n\n \n\tdata->dpm_level_enable_mask.pcie_dpm_enable_mask =\n\t\t\tphm_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\n\n\treturn 0;\n}\n\n\nstatic void polaris10_get_sclk_range_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t   SMU74_Discrete_DpmTable  *table)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tuint32_t i, ref_clk;\n\n\tstruct pp_atom_ctrl_sclk_range_table range_table_from_vbios = { { {0} } };\n\n\tref_clk = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\tif (0 == atomctrl_get_smc_sclk_range_table(hwmgr, &range_table_from_vbios)) {\n\t\tfor (i = 0; i < NUM_SCLK_RANGE; i++) {\n\t\t\ttable->SclkFcwRangeTable[i].vco_setting = range_table_from_vbios.entry[i].ucVco_setting;\n\t\t\ttable->SclkFcwRangeTable[i].postdiv = range_table_from_vbios.entry[i].ucPostdiv;\n\t\t\ttable->SclkFcwRangeTable[i].fcw_pcc = range_table_from_vbios.entry[i].usFcw_pcc;\n\n\t\t\ttable->SclkFcwRangeTable[i].fcw_trans_upper = range_table_from_vbios.entry[i].usFcw_trans_upper;\n\t\t\ttable->SclkFcwRangeTable[i].fcw_trans_lower = range_table_from_vbios.entry[i].usRcw_trans_lower;\n\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_pcc);\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_trans_upper);\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_trans_lower);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NUM_SCLK_RANGE; i++) {\n\t\tsmu_data->range_table[i].trans_lower_frequency = (ref_clk * Range_Table[i].fcw_trans_lower) >> Range_Table[i].postdiv;\n\t\tsmu_data->range_table[i].trans_upper_frequency = (ref_clk * Range_Table[i].fcw_trans_upper) >> Range_Table[i].postdiv;\n\n\t\ttable->SclkFcwRangeTable[i].vco_setting = Range_Table[i].vco_setting;\n\t\ttable->SclkFcwRangeTable[i].postdiv = Range_Table[i].postdiv;\n\t\ttable->SclkFcwRangeTable[i].fcw_pcc = Range_Table[i].fcw_pcc;\n\n\t\ttable->SclkFcwRangeTable[i].fcw_trans_upper = Range_Table[i].fcw_trans_upper;\n\t\ttable->SclkFcwRangeTable[i].fcw_trans_lower = Range_Table[i].fcw_trans_lower;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_pcc);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_trans_upper);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->SclkFcwRangeTable[i].fcw_trans_lower);\n\t}\n}\n\nstatic int polaris10_calculate_sclk_params(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock, SMU_SclkSetting *sclk_setting)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tconst SMU74_Discrete_DpmTable *table = &(smu_data->smc_state_table);\n\tstruct pp_atomctrl_clock_dividers_ai dividers;\n\tuint32_t ref_clock;\n\tuint32_t pcc_target_percent, pcc_target_freq, ss_target_percent, ss_target_freq;\n\tuint8_t i;\n\tint result;\n\tuint64_t temp;\n\n\tsclk_setting->SclkFrequency = clock;\n\t \n\tresult = atomctrl_get_engine_pll_dividers_ai(hwmgr, clock,  &dividers);\n\tif (result == 0) {\n\t\tsclk_setting->Fcw_int = dividers.usSclk_fcw_int;\n\t\tsclk_setting->Fcw_frac = dividers.usSclk_fcw_frac;\n\t\tsclk_setting->Pcc_fcw_int = dividers.usPcc_fcw_int;\n\t\tsclk_setting->PllRange = dividers.ucSclkPllRange;\n\t\tsclk_setting->Sclk_slew_rate = 0x400;\n\t\tsclk_setting->Pcc_up_slew_rate = dividers.usPcc_fcw_slew_frac;\n\t\tsclk_setting->Pcc_down_slew_rate = 0xffff;\n\t\tsclk_setting->SSc_En = dividers.ucSscEnable;\n\t\tsclk_setting->Fcw1_int = dividers.usSsc_fcw1_int;\n\t\tsclk_setting->Fcw1_frac = dividers.usSsc_fcw1_frac;\n\t\tsclk_setting->Sclk_ss_slew_rate = dividers.usSsc_fcw_slew_frac;\n\t\treturn result;\n\t}\n\n\tref_clock = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\tfor (i = 0; i < NUM_SCLK_RANGE; i++) {\n\t\tif (clock > smu_data->range_table[i].trans_lower_frequency\n\t\t&& clock <= smu_data->range_table[i].trans_upper_frequency) {\n\t\t\tsclk_setting->PllRange = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsclk_setting->Fcw_int = (uint16_t)((clock << table->SclkFcwRangeTable[sclk_setting->PllRange].postdiv) / ref_clock);\n\ttemp = clock << table->SclkFcwRangeTable[sclk_setting->PllRange].postdiv;\n\ttemp <<= 0x10;\n\tdo_div(temp, ref_clock);\n\tsclk_setting->Fcw_frac = temp & 0xffff;\n\n\tpcc_target_percent = 10;  \n\tpcc_target_freq = clock - (clock * pcc_target_percent / 100);\n\tsclk_setting->Pcc_fcw_int = (uint16_t)((pcc_target_freq << table->SclkFcwRangeTable[sclk_setting->PllRange].postdiv) / ref_clock);\n\n\tss_target_percent = 2;  \n\tsclk_setting->SSc_En = 0;\n\tif (ss_target_percent) {\n\t\tsclk_setting->SSc_En = 1;\n\t\tss_target_freq = clock - (clock * ss_target_percent / 100);\n\t\tsclk_setting->Fcw1_int = (uint16_t)((ss_target_freq << table->SclkFcwRangeTable[sclk_setting->PllRange].postdiv) / ref_clock);\n\t\ttemp = ss_target_freq << table->SclkFcwRangeTable[sclk_setting->PllRange].postdiv;\n\t\ttemp <<= 0x10;\n\t\tdo_div(temp, ref_clock);\n\t\tsclk_setting->Fcw1_frac = temp & 0xffff;\n\t}\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_single_graphic_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock, struct SMU74_Discrete_GraphicsLevel *level)\n{\n\tint result;\n\t \n\tuint32_t mvdd;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tSMU_SclkSetting curr_sclk_setting = { 0 };\n\tphm_ppt_v1_clock_voltage_dependency_table *vdd_dep_table = NULL;\n\n\tresult = polaris10_calculate_sclk_params(hwmgr, clock, &curr_sclk_setting);\n\n\tif (hwmgr->od_enabled)\n\t\tvdd_dep_table = (phm_ppt_v1_clock_voltage_dependency_table *)&data->odn_dpm_table.vdd_dependency_on_sclk;\n\telse\n\t\tvdd_dep_table = table_info->vdd_dep_on_sclk;\n\n\t \n\tresult = polaris10_get_dependency_volt_by_clk(hwmgr,\n\t\t\tvdd_dep_table, clock,\n\t\t\t&level->MinVoltage, &mvdd);\n\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"can not find VDDC voltage value for \"\n\t\t\t\"VDDC engine clock dependency table\",\n\t\t\treturn result);\n\tlevel->ActivityLevel = data->current_profile_setting.sclk_activity;\n\n\tlevel->CcPwrDynRm = 0;\n\tlevel->CcPwrDynRm1 = 0;\n\tlevel->EnabledForActivity = 0;\n\tlevel->EnabledForThrottle = 1;\n\tlevel->UpHyst = data->current_profile_setting.sclk_up_hyst;\n\tlevel->DownHyst = data->current_profile_setting.sclk_down_hyst;\n\tlevel->VoltageDownHyst = 0;\n\tlevel->PowerThrottle = 0;\n\tdata->display_timing.min_clock_in_sr = hwmgr->display_config->min_core_set_clock_in_sr;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SclkDeepSleep))\n\t\tlevel->DeepSleepDivId = smu7_get_sleep_divider_id_from_clock(clock,\n\t\t\t\t\t\t\t\thwmgr->display_config->min_core_set_clock_in_sr);\n\n\t \n\tif (data->update_up_hyst)\n\t\tlevel->UpHyst = (uint8_t)data->up_hyst;\n\tif (data->update_down_hyst)\n\t\tlevel->DownHyst = (uint8_t)data->down_hyst;\n\n\tlevel->SclkSetting = curr_sclk_setting;\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(level->MinVoltage);\n\tCONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm);\n\tCONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm1);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->ActivityLevel);\n\tCONVERT_FROM_HOST_TO_SMC_UL(level->SclkSetting.SclkFrequency);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Fcw_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Fcw_frac);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Pcc_fcw_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Sclk_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Pcc_up_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Pcc_down_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Fcw1_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Fcw1_frac);\n\tCONVERT_FROM_HOST_TO_SMC_US(level->SclkSetting.Sclk_ss_slew_rate);\n\treturn 0;\n}\n\nstatic void polaris10_get_vddc_shared_railinfo(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tSMU74_Discrete_DpmTable *table = &(smu_data->smc_state_table);\n\tuint8_t shared_rail;\n\n\tif (!atomctrl_get_vddc_shared_railinfo(hwmgr, &shared_rail))\n\t\ttable->SharedRails = shared_rail;\n}\n\nstatic int polaris10_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *hw_data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_dpm_table *dpm_table = &hw_data->dpm_table;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_pcie_table *pcie_table = table_info->pcie_table;\n\tuint8_t pcie_entry_cnt = (uint8_t) hw_data->dpm_table.pcie_speed_table.count;\n\tint result = 0;\n\tuint32_t array = smu_data->smu7_data.dpm_table_start +\n\t\t\toffsetof(SMU74_Discrete_DpmTable, GraphicsLevel);\n\tuint32_t array_size = sizeof(struct SMU74_Discrete_GraphicsLevel) *\n\t\t\tSMU74_MAX_LEVELS_GRAPHICS;\n\tstruct SMU74_Discrete_GraphicsLevel *levels =\n\t\t\tsmu_data->smc_state_table.GraphicsLevel;\n\tuint32_t i, max_entry;\n\tuint8_t hightest_pcie_level_enabled = 0,\n\t\tlowest_pcie_level_enabled = 0,\n\t\tmid_pcie_level_enabled = 0,\n\t\tcount = 0;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tpp_atomctrl_clock_dividers_vi dividers;\n\tuint32_t dpm0_sclkfrequency = levels[0].SclkSetting.SclkFrequency;\n\n\tif (ASICID_IS_P20(adev->pdev->device, adev->pdev->revision) ||\n\t    ASICID_IS_P30(adev->pdev->device, adev->pdev->revision))\n\t\tpolaris10_get_vddc_shared_railinfo(hwmgr);\n\n\tpolaris10_get_sclk_range_table(hwmgr, &(smu_data->smc_state_table));\n\n\tfor (i = 0; i < dpm_table->sclk_table.count; i++) {\n\n\t\tresult = polaris10_populate_single_graphic_level(hwmgr,\n\t\t\t\tdpm_table->sclk_table.dpm_levels[i].value,\n\t\t\t\t&(smu_data->smc_state_table.GraphicsLevel[i]));\n\t\tif (result)\n\t\t\treturn result;\n\n\t\t \n\t\tif (i > 1)\n\t\t\tlevels[i].DeepSleepDivId = 0;\n\t}\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_SPLLShutdownSupport)) {\n\t\tsmu_data->smc_state_table.GraphicsLevel[0].SclkSetting.SSc_En = 0;\n\t\tif (dpm0_sclkfrequency != levels[0].SclkSetting.SclkFrequency) {\n\t\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\t\tdpm_table->sclk_table.dpm_levels[0].value,\n\t\t\t\t\t&dividers);\n\t\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\t\"can not find divide id for sclk\",\n\t\t\t\t\treturn result);\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetGpuPllDfsForSclk,\n\t\t\t\t\tdividers.real_clock < dpm_table->sclk_table.dpm_levels[0].value ?\n\t\t\t\t\tdividers.pll_post_divider - 1 : dividers.pll_post_divider,\n\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\tsmu_data->smc_state_table.GraphicsDpmLevelCount =\n\t\t\t(uint8_t)dpm_table->sclk_table.count;\n\thw_data->dpm_level_enable_mask.sclk_dpm_enable_mask =\n\t\t\tphm_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\n\n\tfor (i = 0; i < smu_data->smc_state_table.GraphicsDpmLevelCount; i++)\n\t\tsmu_data->smc_state_table.GraphicsLevel[i].EnabledForActivity =\n\t\t\t(hw_data->dpm_level_enable_mask.sclk_dpm_enable_mask & (1 << i)) >> i;\n\n\tif (pcie_table != NULL) {\n\t\tPP_ASSERT_WITH_CODE((1 <= pcie_entry_cnt),\n\t\t\t\t\"There must be 1 or more PCIE levels defined in PPTable.\",\n\t\t\t\treturn -EINVAL);\n\t\tmax_entry = pcie_entry_cnt - 1;\n\t\tfor (i = 0; i < dpm_table->sclk_table.count; i++)\n\t\t\tlevels[i].pcieDpmLevel =\n\t\t\t\t\t(uint8_t) ((i < max_entry) ? i : max_entry);\n\t} else {\n\t\twhile (hw_data->dpm_level_enable_mask.pcie_dpm_enable_mask &&\n\t\t\t\t((hw_data->dpm_level_enable_mask.pcie_dpm_enable_mask &\n\t\t\t\t\t\t(1 << (hightest_pcie_level_enabled + 1))) != 0))\n\t\t\thightest_pcie_level_enabled++;\n\n\t\twhile (hw_data->dpm_level_enable_mask.pcie_dpm_enable_mask &&\n\t\t\t\t((hw_data->dpm_level_enable_mask.pcie_dpm_enable_mask &\n\t\t\t\t\t\t(1 << lowest_pcie_level_enabled)) == 0))\n\t\t\tlowest_pcie_level_enabled++;\n\n\t\twhile ((count < hightest_pcie_level_enabled) &&\n\t\t\t\t((hw_data->dpm_level_enable_mask.pcie_dpm_enable_mask &\n\t\t\t\t\t\t(1 << (lowest_pcie_level_enabled + 1 + count))) == 0))\n\t\t\tcount++;\n\n\t\tmid_pcie_level_enabled = (lowest_pcie_level_enabled + 1 + count) <\n\t\t\t\thightest_pcie_level_enabled ?\n\t\t\t\t\t\t(lowest_pcie_level_enabled + 1 + count) :\n\t\t\t\t\t\thightest_pcie_level_enabled;\n\n\t\t \n\t\tfor (i = 2; i < dpm_table->sclk_table.count; i++)\n\t\t\tlevels[i].pcieDpmLevel = hightest_pcie_level_enabled;\n\n\t\t \n\t\tlevels[0].pcieDpmLevel = lowest_pcie_level_enabled;\n\n\t\t \n\t\tlevels[1].pcieDpmLevel = mid_pcie_level_enabled;\n\t}\n\t \n\tresult = smu7_copy_bytes_to_smc(hwmgr, array, (uint8_t *)levels,\n\t\t\t(uint32_t)array_size, SMC_RAM_END);\n\n\treturn result;\n}\n\n\nstatic int polaris10_populate_single_memory_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock, struct SMU74_Discrete_MemoryLevel *mem_level)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tint result = 0;\n\tuint32_t mclk_stutter_mode_threshold = 40000;\n\tphm_ppt_v1_clock_voltage_dependency_table *vdd_dep_table = NULL;\n\n\n\tif (hwmgr->od_enabled)\n\t\tvdd_dep_table = (phm_ppt_v1_clock_voltage_dependency_table *)&data->odn_dpm_table.vdd_dependency_on_mclk;\n\telse\n\t\tvdd_dep_table = table_info->vdd_dep_on_mclk;\n\n\tif (vdd_dep_table) {\n\t\tresult = polaris10_get_dependency_volt_by_clk(hwmgr,\n\t\t\t\tvdd_dep_table, clock,\n\t\t\t\t&mem_level->MinVoltage, &mem_level->MinMvdd);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find MinVddc voltage value from memory \"\n\t\t\t\t\"VDDC voltage dependency table\", return result);\n\t}\n\n\tmem_level->MclkFrequency = clock;\n\tmem_level->EnabledForThrottle = 1;\n\tmem_level->EnabledForActivity = 0;\n\tmem_level->UpHyst = data->current_profile_setting.mclk_up_hyst;\n\tmem_level->DownHyst = data->current_profile_setting.mclk_down_hyst;\n\tmem_level->VoltageDownHyst = 0;\n\tmem_level->ActivityLevel = data->current_profile_setting.mclk_activity;\n\tmem_level->StutterEnable = false;\n\tmem_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\n\n\tdata->display_timing.num_existing_displays = hwmgr->display_config->num_display;\n\tdata->display_timing.vrefresh = hwmgr->display_config->vrefresh;\n\n\tif (mclk_stutter_mode_threshold &&\n\t\t(clock <= mclk_stutter_mode_threshold) &&\n\t\t(PHM_READ_FIELD(hwmgr->device, DPG_PIPE_STUTTER_CONTROL,\n\t\t\t\tSTUTTER_ENABLE) & 0x1) &&\n\t\t(data->display_timing.num_existing_displays <= 2) &&\n\t\tdata->display_timing.num_existing_displays)\n\t\tmem_level->StutterEnable = true;\n\n\tif (!result) {\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(mem_level->MinMvdd);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(mem_level->MclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(mem_level->ActivityLevel);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(mem_level->MinVoltage);\n\t}\n\treturn result;\n}\n\nstatic int polaris10_populate_all_memory_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *hw_data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_dpm_table *dpm_table = &hw_data->dpm_table;\n\tint result;\n\t \n\tuint32_t array = smu_data->smu7_data.dpm_table_start +\n\t\t\toffsetof(SMU74_Discrete_DpmTable, MemoryLevel);\n\tuint32_t array_size = sizeof(SMU74_Discrete_MemoryLevel) *\n\t\t\tSMU74_MAX_LEVELS_MEMORY;\n\tstruct SMU74_Discrete_MemoryLevel *levels =\n\t\t\tsmu_data->smc_state_table.MemoryLevel;\n\tuint32_t i;\n\n\tfor (i = 0; i < dpm_table->mclk_table.count; i++) {\n\t\tPP_ASSERT_WITH_CODE((0 != dpm_table->mclk_table.dpm_levels[i].value),\n\t\t\t\t\"can not populate memory level as memory clock is zero\",\n\t\t\t\treturn -EINVAL);\n\t\tresult = polaris10_populate_single_memory_level(hwmgr,\n\t\t\t\tdpm_table->mclk_table.dpm_levels[i].value,\n\t\t\t\t&levels[i]);\n\t\tif (i == dpm_table->mclk_table.count - 1)\n\t\t\tlevels[i].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tsmu_data->smc_state_table.MemoryDpmLevelCount =\n\t\t\t(uint8_t)dpm_table->mclk_table.count;\n\thw_data->dpm_level_enable_mask.mclk_dpm_enable_mask =\n\t\t\tphm_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\n\n\tfor (i = 0; i < smu_data->smc_state_table.MemoryDpmLevelCount; i++)\n\t\tsmu_data->smc_state_table.MemoryLevel[i].EnabledForActivity =\n\t\t\t(hw_data->dpm_level_enable_mask.mclk_dpm_enable_mask & (1 << i)) >> i;\n\n\t \n\tresult = smu7_copy_bytes_to_smc(hwmgr, array, (uint8_t *)levels,\n\t\t\t(uint32_t)array_size, SMC_RAM_END);\n\n\treturn result;\n}\n\nstatic int polaris10_populate_mvdd_value(struct pp_hwmgr *hwmgr,\n\t\tuint32_t mclk, SMIO_Pattern *smio_pat)\n{\n\tconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tuint32_t i = 0;\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE != data->mvdd_control) {\n\t\t \n\t\tfor (i = 0; i < table_info->vdd_dep_on_mclk->count; i++) {\n\t\t\tif (mclk <= table_info->vdd_dep_on_mclk->entries[i].clk) {\n\t\t\t\tsmio_pat->Voltage = data->mvdd_voltage_table.entries[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tPP_ASSERT_WITH_CODE(i < table_info->vdd_dep_on_mclk->count,\n\t\t\t\t\"MVDD Voltage is outside the supported range.\",\n\t\t\t\treturn -EINVAL);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_acpi_level(struct pp_hwmgr *hwmgr,\n\t\tSMU74_Discrete_DpmTable *table)\n{\n\tint result = 0;\n\tuint32_t sclk_frequency;\n\tconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tSMIO_Pattern vol_level;\n\tuint32_t mvdd;\n\n\ttable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\t \n\tsclk_frequency = data->vbios_boot_state.sclk_bootup_value;\n\tresult = polaris10_get_dependency_volt_by_clk(hwmgr,\n\t\t\ttable_info->vdd_dep_on_sclk,\n\t\t\tsclk_frequency,\n\t\t\t&table->ACPILevel.MinVoltage, &mvdd);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"Cannot find ACPI VDDC voltage value \"\n\t\t\t\"in Clock Dependency Table\",\n\t\t\t);\n\n\tresult = polaris10_calculate_sclk_params(hwmgr, sclk_frequency,  &(table->ACPILevel.SclkSetting));\n\tPP_ASSERT_WITH_CODE(result == 0, \"Error retrieving Engine Clock dividers from VBIOS.\", return result);\n\n\ttable->ACPILevel.DeepSleepDivId = 0;\n\ttable->ACPILevel.CcPwrDynRm = 0;\n\ttable->ACPILevel.CcPwrDynRm1 = 0;\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.Flags);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.MinVoltage);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm1);\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SclkSetting.SclkFrequency);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Fcw_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Fcw_frac);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Pcc_fcw_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Sclk_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Pcc_up_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Pcc_down_slew_rate);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Fcw1_int);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Fcw1_frac);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->ACPILevel.SclkSetting.Sclk_ss_slew_rate);\n\n\n\t \n\ttable->MemoryACPILevel.MclkFrequency = data->vbios_boot_state.mclk_bootup_value;\n\tresult = polaris10_get_dependency_volt_by_clk(hwmgr,\n\t\t\ttable_info->vdd_dep_on_mclk,\n\t\t\ttable->MemoryACPILevel.MclkFrequency,\n\t\t\t&table->MemoryACPILevel.MinVoltage, &mvdd);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"Cannot find ACPI VDDCI voltage value \"\n\t\t\t\"in Clock Dependency Table\",\n\t\t\t);\n\n\tif (!((SMU7_VOLTAGE_CONTROL_NONE == data->mvdd_control) ||\n\t\t\t(data->mclk_dpm_key_disabled)))\n\t\tpolaris10_populate_mvdd_value(hwmgr,\n\t\t\t\tdata->dpm_table.mclk_table.dpm_levels[0].value,\n\t\t\t\t&vol_level);\n\n\tif (0 == polaris10_populate_mvdd_value(hwmgr, 0, &vol_level))\n\t\ttable->MemoryACPILevel.MinMvdd = PP_HOST_TO_SMC_UL(vol_level.Voltage);\n\telse\n\t\ttable->MemoryACPILevel.MinMvdd = 0;\n\n\ttable->MemoryACPILevel.StutterEnable = false;\n\n\ttable->MemoryACPILevel.EnabledForThrottle = 0;\n\ttable->MemoryACPILevel.EnabledForActivity = 0;\n\ttable->MemoryACPILevel.UpHyst = 0;\n\ttable->MemoryACPILevel.DownHyst = 100;\n\ttable->MemoryACPILevel.VoltageDownHyst = 0;\n\t \n\ttable->MemoryACPILevel.ActivityLevel =\n\t\t\tPP_HOST_TO_SMC_US(data->current_profile_setting.sclk_activity);\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->MemoryACPILevel.MclkFrequency);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->MemoryACPILevel.MinVoltage);\n\n\treturn result;\n}\n\nstatic int polaris10_populate_smc_vce_level(struct pp_hwmgr *hwmgr,\n\t\tSMU74_Discrete_DpmTable *table)\n{\n\tint result = -EINVAL;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t vddci;\n\n\ttable->VceLevelCount = (uint8_t)(mm_table->count);\n\ttable->VceBootLevel = 0;\n\n\tfor (count = 0; count < table->VceLevelCount; count++) {\n\t\ttable->VceLevel[count].Frequency = mm_table->entries[count].eclk;\n\t\ttable->VceLevel[count].MinVoltage = 0;\n\t\ttable->VceLevel[count].MinVoltage |=\n\t\t\t\t(mm_table->entries[count].vddc * VOLTAGE_SCALE) << VDDC_SHIFT;\n\n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control)\n\t\t\tvddci = (uint32_t)phm_find_closest_vddci(&(data->vddci_voltage_table),\n\t\t\t\t\t\tmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\n\t\telse if (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control)\n\t\t\tvddci = mm_table->entries[count].vddc - VDDC_VDDCI_DELTA;\n\t\telse\n\t\t\tvddci = (data->vbios_boot_state.vddci_bootup_value * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\n\n\t\ttable->VceLevel[count].MinVoltage |=\n\t\t\t\t(vddci * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\ttable->VceLevel[count].MinVoltage |= 1 << PHASES_SHIFT;\n\n\t\t \n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->VceLevel[count].Frequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for VCE engine clock\",\n\t\t\t\treturn result);\n\n\t\ttable->VceLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->VceLevel[count].Frequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->VceLevel[count].MinVoltage);\n\t}\n\treturn result;\n}\n\nstatic int polaris10_populate_smc_samu_level(struct pp_hwmgr *hwmgr,\n\t\tSMU74_Discrete_DpmTable *table)\n{\n\tint result = -EINVAL;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t vddci;\n\n\ttable->SamuLevelCount = (uint8_t)(mm_table->count);\n\ttable->SamuBootLevel = 0;\n\n\tfor (count = 0; count < table->SamuLevelCount; count++) {\n\t\ttable->SamuLevel[count].Frequency = mm_table->entries[count].samclock;\n\t\ttable->SamuLevel[count].MinVoltage |=\n\t\t\t\t(mm_table->entries[count].vddc * VOLTAGE_SCALE) << VDDC_SHIFT;\n\n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control)\n\t\t\tvddci = (uint32_t)phm_find_closest_vddci(&(data->vddci_voltage_table),\n\t\t\t\t\t\tmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\n\t\telse if (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control)\n\t\t\tvddci = mm_table->entries[count].vddc - VDDC_VDDCI_DELTA;\n\t\telse\n\t\t\tvddci = (data->vbios_boot_state.vddci_bootup_value * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\n\n\t\ttable->SamuLevel[count].MinVoltage |=\n\t\t\t\t(vddci * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\ttable->SamuLevel[count].MinVoltage |= 1 << PHASES_SHIFT;\n\n\t\t \n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->SamuLevel[count].Frequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for VCE engine clock\",\n\t\t\t\treturn result);\n\n\t\ttable->SamuLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->SamuLevel[count].Frequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->SamuLevel[count].MinVoltage);\n\t}\n\treturn result;\n}\n\nstatic int polaris10_populate_memory_timing_parameters(struct pp_hwmgr *hwmgr,\n\t\tint32_t eng_clock, int32_t mem_clock,\n\t\tSMU74_Discrete_MCArbDramTimingTableEntry *arb_regs)\n{\n\tuint32_t dram_timing;\n\tuint32_t dram_timing2;\n\tuint32_t burst_time;\n\tint result;\n\n\tresult = atomctrl_set_engine_dram_timings_rv770(hwmgr,\n\t\t\teng_clock, mem_clock);\n\tPP_ASSERT_WITH_CODE(result == 0,\n\t\t\t\"Error calling VBIOS to set DRAM_TIMING.\", return result);\n\n\tdram_timing = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING);\n\tdram_timing2 = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING2);\n\tburst_time = PHM_READ_FIELD(hwmgr->device, MC_ARB_BURST_TIME, STATE0);\n\n\n\tarb_regs->McArbDramTiming  = PP_HOST_TO_SMC_UL(dram_timing);\n\tarb_regs->McArbDramTiming2 = PP_HOST_TO_SMC_UL(dram_timing2);\n\tarb_regs->McArbBurstTime   = (uint8_t)burst_time;\n\n\treturn 0;\n}\n\nstatic int polaris10_program_memory_timing_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *hw_data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct SMU74_Discrete_MCArbDramTimingTable arb_regs;\n\tuint32_t i, j;\n\tint result = 0;\n\n\tfor (i = 0; i < hw_data->dpm_table.sclk_table.count; i++) {\n\t\tfor (j = 0; j < hw_data->dpm_table.mclk_table.count; j++) {\n\t\t\tresult = polaris10_populate_memory_timing_parameters(hwmgr,\n\t\t\t\t\thw_data->dpm_table.sclk_table.dpm_levels[i].value,\n\t\t\t\t\thw_data->dpm_table.mclk_table.dpm_levels[j].value,\n\t\t\t\t\t&arb_regs.entries[i][j]);\n\t\t\tif (result == 0 && i == 0)\n\t\t\t\tresult = atomctrl_set_ac_timing_ai(hwmgr, hw_data->dpm_table.mclk_table.dpm_levels[j].value, j);\n\t\t\tif (result != 0)\n\t\t\t\treturn result;\n\t\t}\n\t}\n\n\tresult = smu7_copy_bytes_to_smc(\n\t\t\thwmgr,\n\t\t\tsmu_data->smu7_data.arb_table_start,\n\t\t\t(uint8_t *)&arb_regs,\n\t\t\tsizeof(SMU74_Discrete_MCArbDramTimingTable),\n\t\t\tSMC_RAM_END);\n\treturn result;\n}\n\nstatic int polaris10_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tint result = -EINVAL;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t vddci;\n\n\ttable->UvdLevelCount = (uint8_t)(mm_table->count);\n\ttable->UvdBootLevel = 0;\n\n\tfor (count = 0; count < table->UvdLevelCount; count++) {\n\t\ttable->UvdLevel[count].MinVoltage = 0;\n\t\ttable->UvdLevel[count].VclkFrequency = mm_table->entries[count].vclk;\n\t\ttable->UvdLevel[count].DclkFrequency = mm_table->entries[count].dclk;\n\t\ttable->UvdLevel[count].MinVoltage |= (mm_table->entries[count].vddc *\n\t\t\t\tVOLTAGE_SCALE) << VDDC_SHIFT;\n\n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control)\n\t\t\tvddci = (uint32_t)phm_find_closest_vddci(&(data->vddci_voltage_table),\n\t\t\t\t\t\tmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\n\t\telse if (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control)\n\t\t\tvddci = mm_table->entries[count].vddc - VDDC_VDDCI_DELTA;\n\t\telse\n\t\t\tvddci = (data->vbios_boot_state.vddci_bootup_value * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\n\t\ttable->UvdLevel[count].MinVoltage |= (vddci * VOLTAGE_SCALE) << VDDCI_SHIFT;\n\t\ttable->UvdLevel[count].MinVoltage |= 1 << PHASES_SHIFT;\n\n\t\t \n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->UvdLevel[count].VclkFrequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for Vclk clock\", return result);\n\n\t\ttable->UvdLevel[count].VclkDivider = (uint8_t)dividers.pll_post_divider;\n\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->UvdLevel[count].DclkFrequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for Dclk clock\", return result);\n\n\t\ttable->UvdLevel[count].DclkDivider = (uint8_t)dividers.pll_post_divider;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].VclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].DclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].MinVoltage);\n\t}\n\n\treturn result;\n}\n\nstatic int polaris10_populate_smc_boot_level(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tint result = 0;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\ttable->GraphicsBootLevel = 0;\n\ttable->MemoryBootLevel = 0;\n\n\t \n\tresult = phm_find_boot_level(&(data->dpm_table.sclk_table),\n\t\t\tdata->vbios_boot_state.sclk_bootup_value,\n\t\t\t(uint32_t *)&(table->GraphicsBootLevel));\n\tif (result) {\n\t\ttable->GraphicsBootLevel = 0;\n\t\tresult = 0;\n\t}\n\n\tresult = phm_find_boot_level(&(data->dpm_table.mclk_table),\n\t\t\tdata->vbios_boot_state.mclk_bootup_value,\n\t\t\t(uint32_t *)&(table->MemoryBootLevel));\n\tif (result) {\n\t\ttable->MemoryBootLevel = 0;\n\t\tresult = 0;\n\t}\n\n\ttable->BootVddc  = data->vbios_boot_state.vddc_bootup_value *\n\t\t\tVOLTAGE_SCALE;\n\ttable->BootVddci = data->vbios_boot_state.vddci_bootup_value *\n\t\t\tVOLTAGE_SCALE;\n\ttable->BootMVdd  = data->vbios_boot_state.mvdd_bootup_value *\n\t\t\tVOLTAGE_SCALE;\n\n\tCONVERT_FROM_HOST_TO_SMC_US(table->BootVddc);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->BootVddci);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->BootMVdd);\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_smc_initailial_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *hw_data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tuint8_t count, level;\n\n\tcount = (uint8_t)(table_info->vdd_dep_on_sclk->count);\n\n\tfor (level = 0; level < count; level++) {\n\t\tif (table_info->vdd_dep_on_sclk->entries[level].clk >=\n\t\t\t\thw_data->vbios_boot_state.sclk_bootup_value) {\n\t\t\tsmu_data->smc_state_table.GraphicsBootLevel = level;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcount = (uint8_t)(table_info->vdd_dep_on_mclk->count);\n\tfor (level = 0; level < count; level++) {\n\t\tif (table_info->vdd_dep_on_mclk->entries[level].clk >=\n\t\t\t\thw_data->vbios_boot_state.mclk_bootup_value) {\n\t\t\tsmu_data->smc_state_table.MemoryBootLevel = level;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define STRAP_ASIC_RO_LSB    2168\n#define STRAP_ASIC_RO_MSB    2175\n\nstatic int polaris10_populate_clock_stretcher_data_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *sclk_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\tuint32_t ro, efuse, volt_without_cks, volt_with_cks, value;\n\tuint8_t i, stretch_amount, volt_offset = 0;\n\n\tstretch_amount = (uint8_t)table_info->cac_dtp_table->usClockStretchAmount;\n\n\t \n\tatomctrl_read_efuse(hwmgr, STRAP_ASIC_RO_LSB, STRAP_ASIC_RO_MSB, &efuse);\n\tro = ((efuse * (data->ro_range_maximum - data->ro_range_minimum)) / 255) +\n\t\tdata->ro_range_minimum;\n\n\t \n\tfor (i = 0; i < sclk_table->count; i++) {\n\t\tsmu_data->smc_state_table.Sclk_CKS_masterEn0_7 |=\n\t\t\t\tsclk_table->entries[i].cks_enable << i;\n\t\tif (hwmgr->chip_id == CHIP_POLARIS10) {\n\t\t\tvolt_without_cks = (uint32_t)((2753594000U + (sclk_table->entries[i].clk/100) * 136418 - (ro - 70) * 1000000) / \\\n\t\t\t\t\t\t(2424180 - (sclk_table->entries[i].clk/100) * 1132925/1000));\n\t\t\tvolt_with_cks = (uint32_t)((2797202000U + sclk_table->entries[i].clk/100 * 3232 - (ro - 65) * 1000000) / \\\n\t\t\t\t\t(2522480 - sclk_table->entries[i].clk/100 * 115764/100));\n\t\t} else {\n\t\t\tvolt_without_cks = (uint32_t)((2416794800U + (sclk_table->entries[i].clk/100) * 1476925/10 - (ro - 50) * 1000000) / \\\n\t\t\t\t\t\t(2625416 - (sclk_table->entries[i].clk/100) * (12586807/10000)));\n\t\t\tvolt_with_cks = (uint32_t)((2999656000U - sclk_table->entries[i].clk/100 * 392803 - (ro - 44) * 1000000) / \\\n\t\t\t\t\t(3422454 - sclk_table->entries[i].clk/100 * (18886376/10000)));\n\t\t}\n\n\t\tif (volt_without_cks >= volt_with_cks)\n\t\t\tvolt_offset = (uint8_t)(((volt_without_cks - volt_with_cks +\n\t\t\t\t\tsclk_table->entries[i].cks_voffset) * 100 + 624) / 625);\n\n\t\tsmu_data->smc_state_table.Sclk_voltageOffset[i] = volt_offset;\n\t}\n\n\tsmu_data->smc_state_table.LdoRefSel = (table_info->cac_dtp_table->ucCKS_LDO_REFSEL != 0) ? table_info->cac_dtp_table->ucCKS_LDO_REFSEL : 5;\n\n\t \n\tif (stretch_amount == 0 || stretch_amount > 5) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ClockStretcher);\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"Stretch Amount in PPTable not supported\",\n\t\t\t\treturn -EINVAL);\n\t}\n\n\tvalue = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixPWR_CKS_CNTL);\n\tvalue &= 0xFFFFFFFE;\n\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, ixPWR_CKS_CNTL, value);\n\n\treturn 0;\n}\n\nstatic int polaris10_populate_vr_config(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU74_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tuint16_t config;\n\n\tconfig = VR_MERGED_WITH_VDDC;\n\ttable->VRConfig |= (config << VRCONF_VDDGFX_SHIFT);\n\n\t \n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) {\n\t\tconfig = VR_SVI2_PLANE_1;\n\t\ttable->VRConfig |= config;\n\t} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control) {\n\t\tconfig = VR_SMIO_PATTERN_1;\n\t\ttable->VRConfig |= config;\n\t} else {\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"VDDC should be on SVI2 control in merged mode!\",\n\t\t\t\t);\n\t}\n\t \n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control) {\n\t\tconfig = VR_SVI2_PLANE_2;   \n\t\ttable->VRConfig |= (config << VRCONF_VDDCI_SHIFT);\n\t} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\n\t\tconfig = VR_SMIO_PATTERN_1;\n\t\ttable->VRConfig |= (config << VRCONF_VDDCI_SHIFT);\n\t} else {\n\t\tconfig = VR_STATIC_VOLTAGE;\n\t\ttable->VRConfig |= (config << VRCONF_VDDCI_SHIFT);\n\t}\n\t \n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->mvdd_control) {\n\t\tif (config != VR_SVI2_PLANE_2) {\n\t\t\tconfig = VR_SVI2_PLANE_2;\n\t\t\ttable->VRConfig |= (config << VRCONF_MVDD_SHIFT);\n\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, smu_data->smu7_data.soft_regs_start +\n\t\t\t\toffsetof(SMU74_SoftRegisters, AllowMvddSwitch), 0x1);\n\t\t} else {\n\t\t\tconfig = VR_STATIC_VOLTAGE;\n\t\t\ttable->VRConfig |= (config << VRCONF_MVDD_SHIFT);\n\t\t}\n\t} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\n\t\tconfig = VR_SMIO_PATTERN_2;\n\t\ttable->VRConfig |= (config << VRCONF_MVDD_SHIFT);\n\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, smu_data->smu7_data.soft_regs_start +\n\t\t\toffsetof(SMU74_SoftRegisters, AllowMvddSwitch), 0x1);\n\t} else {\n\t\tconfig = VR_STATIC_VOLTAGE;\n\t\ttable->VRConfig |= (config << VRCONF_MVDD_SHIFT);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int polaris10_populate_avfs_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tSMU74_Discrete_DpmTable  *table = &(smu_data->smc_state_table);\n\tint result = 0;\n\tstruct pp_atom_ctrl__avfs_parameters avfs_params = {0};\n\tAVFS_meanNsigma_t AVFS_meanNsigma = { {0} };\n\tAVFS_Sclk_Offset_t AVFS_SclkOffset = { {0} };\n\tuint32_t tmp, i;\n\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *sclk_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\n\n\tif (!hwmgr->avfs_supported)\n\t\treturn 0;\n\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control) {\n\t\thwmgr->avfs_supported = 0;\n\t\treturn 0;\n\t}\n\n\tresult = atomctrl_get_avfs_information(hwmgr, &avfs_params);\n\n\tif (0 == result) {\n\t\tif (ASICID_IS_P20(adev->pdev->device, adev->pdev->revision) ||\n\t\t    ((hwmgr->chip_id == CHIP_POLARIS12) && !ASICID_IS_P23(adev->pdev->device, adev->pdev->revision)) ||\n\t\t    ASICID_IS_P21(adev->pdev->device, adev->pdev->revision)) {\n\t\t\tavfs_params.ucEnableApplyAVFS_CKS_OFF_Voltage = 1;\n\t\t\tif ((adev->pdev->device == 0x67ef && adev->pdev->revision == 0xe5) ||\n\t\t\t    (adev->pdev->device == 0x67ff && adev->pdev->revision == 0xef)) {\n\t\t\t\tif ((avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a0 == 0xEA522DD3) &&\n\t\t\t\t    (avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a1 == 0x5645A) &&\n\t\t\t\t    (avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a2 == 0x33F9E) &&\n\t\t\t\t    (avfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_m1 == 0xFFFFC5CC) &&\n\t\t\t\t    (avfs_params.usAVFSGB_FUSE_TABLE_CKSOFF_m2 == 0x1B1A) &&\n\t\t\t\t    (avfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_b == 0xFFFFFCED)) {\n\t\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a0   = 0xF718F1D4;\n\t\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a1   = 0x323FD;\n\t\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a2   = 0x1E455;\n\t\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_m1 = 0;\n\t\t\t\t\tavfs_params.usAVFSGB_FUSE_TABLE_CKSOFF_m2 = 0;\n\t\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_b  = 0x23;\n\t\t\t\t}\n\t\t\t} else if (hwmgr->chip_id == CHIP_POLARIS12 && !ASICID_IS_P23(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a0   = 0xF6B024DD;\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a1   = 0x3005E;\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a2   = 0x18A5F;\n\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_m1 = 0x315;\n\t\t\t\tavfs_params.usAVFSGB_FUSE_TABLE_CKSOFF_m2 = 0xFED1;\n\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_b  = 0x3B;\n\t\t\t} else if (ASICID_IS_P20(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a0   = 0xF843B66B;\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a1   = 0x59CB5;\n\t\t\t\tavfs_params.ulGB_VDROOP_TABLE_CKSOFF_a2   = 0xFFFF287F;\n\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_m1 = 0;\n\t\t\t\tavfs_params.usAVFSGB_FUSE_TABLE_CKSOFF_m2 = 0xFF23;\n\t\t\t\tavfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_b  = 0x58;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 == result) {\n\t\ttable->BTCGB_VDROOP_TABLE[0].a0  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSON_a0);\n\t\ttable->BTCGB_VDROOP_TABLE[0].a1  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSON_a1);\n\t\ttable->BTCGB_VDROOP_TABLE[0].a2  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSON_a2);\n\t\ttable->BTCGB_VDROOP_TABLE[1].a0  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a0);\n\t\ttable->BTCGB_VDROOP_TABLE[1].a1  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a1);\n\t\ttable->BTCGB_VDROOP_TABLE[1].a2  = PP_HOST_TO_SMC_UL(avfs_params.ulGB_VDROOP_TABLE_CKSOFF_a2);\n\t\ttable->AVFSGB_VDROOP_TABLE[0].m1 = PP_HOST_TO_SMC_UL(avfs_params.ulAVFSGB_FUSE_TABLE_CKSON_m1);\n\t\ttable->AVFSGB_VDROOP_TABLE[0].m2 = PP_HOST_TO_SMC_US(avfs_params.usAVFSGB_FUSE_TABLE_CKSON_m2);\n\t\ttable->AVFSGB_VDROOP_TABLE[0].b  = PP_HOST_TO_SMC_UL(avfs_params.ulAVFSGB_FUSE_TABLE_CKSON_b);\n\t\ttable->AVFSGB_VDROOP_TABLE[0].m1_shift = 24;\n\t\ttable->AVFSGB_VDROOP_TABLE[0].m2_shift  = 12;\n\t\ttable->AVFSGB_VDROOP_TABLE[1].m1 = PP_HOST_TO_SMC_UL(avfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_m1);\n\t\ttable->AVFSGB_VDROOP_TABLE[1].m2 = PP_HOST_TO_SMC_US(avfs_params.usAVFSGB_FUSE_TABLE_CKSOFF_m2);\n\t\ttable->AVFSGB_VDROOP_TABLE[1].b  = PP_HOST_TO_SMC_UL(avfs_params.ulAVFSGB_FUSE_TABLE_CKSOFF_b);\n\t\ttable->AVFSGB_VDROOP_TABLE[1].m1_shift = 24;\n\t\ttable->AVFSGB_VDROOP_TABLE[1].m2_shift  = 12;\n\t\ttable->MaxVoltage                = PP_HOST_TO_SMC_US(avfs_params.usMaxVoltage_0_25mv);\n\t\tAVFS_meanNsigma.Aconstant[0]      = PP_HOST_TO_SMC_UL(avfs_params.ulAVFS_meanNsigma_Acontant0);\n\t\tAVFS_meanNsigma.Aconstant[1]      = PP_HOST_TO_SMC_UL(avfs_params.ulAVFS_meanNsigma_Acontant1);\n\t\tAVFS_meanNsigma.Aconstant[2]      = PP_HOST_TO_SMC_UL(avfs_params.ulAVFS_meanNsigma_Acontant2);\n\t\tAVFS_meanNsigma.DC_tol_sigma      = PP_HOST_TO_SMC_US(avfs_params.usAVFS_meanNsigma_DC_tol_sigma);\n\t\tAVFS_meanNsigma.Platform_mean     = PP_HOST_TO_SMC_US(avfs_params.usAVFS_meanNsigma_Platform_mean);\n\t\tAVFS_meanNsigma.PSM_Age_CompFactor = PP_HOST_TO_SMC_US(avfs_params.usPSM_Age_ComFactor);\n\t\tAVFS_meanNsigma.Platform_sigma     = PP_HOST_TO_SMC_US(avfs_params.usAVFS_meanNsigma_Platform_sigma);\n\n\t\tfor (i = 0; i < NUM_VFT_COLUMNS; i++) {\n\t\t\tAVFS_meanNsigma.Static_Voltage_Offset[i] = (uint8_t)(sclk_table->entries[i].cks_voffset * 100 / 625);\n\t\t\tAVFS_SclkOffset.Sclk_Offset[i] = PP_HOST_TO_SMC_US((uint16_t)(sclk_table->entries[i].sclk_offset) / 100);\n\t\t}\n\n\t\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, AvfsMeanNSigma),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\t\tsmu7_copy_bytes_to_smc(hwmgr,\n\t\t\t\t\ttmp,\n\t\t\t\t\t(uint8_t *)&AVFS_meanNsigma,\n\t\t\t\t\tsizeof(AVFS_meanNsigma_t),\n\t\t\t\t\tSMC_RAM_END);\n\n\t\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU74_Firmware_Header, AvfsSclkOffsetTable),\n\t\t\t\t&tmp, SMC_RAM_END);\n\t\tsmu7_copy_bytes_to_smc(hwmgr,\n\t\t\t\t\ttmp,\n\t\t\t\t\t(uint8_t *)&AVFS_SclkOffset,\n\t\t\t\t\tsizeof(AVFS_Sclk_Offset_t),\n\t\t\t\t\tSMC_RAM_END);\n\n\t\tdata->avfs_vdroop_override_setting = (avfs_params.ucEnableGB_VDROOP_TABLE_CKSON << BTCGB0_Vdroop_Enable_SHIFT) |\n\t\t\t\t\t\t(avfs_params.ucEnableGB_VDROOP_TABLE_CKSOFF << BTCGB1_Vdroop_Enable_SHIFT) |\n\t\t\t\t\t\t(avfs_params.ucEnableGB_FUSE_TABLE_CKSON << AVFSGB0_Vdroop_Enable_SHIFT) |\n\t\t\t\t\t\t(avfs_params.ucEnableGB_FUSE_TABLE_CKSOFF << AVFSGB1_Vdroop_Enable_SHIFT);\n\t\tdata->apply_avfs_cks_off_voltage = avfs_params.ucEnableApplyAVFS_CKS_OFF_Voltage == 1;\n\t}\n\treturn result;\n}\n\nstatic void polaris10_initialize_power_tune_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct  phm_ppt_v1_information *table_info =\n\t\t\t(struct  phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tif (table_info &&\n\t\t\ttable_info->cac_dtp_table->usPowerTuneDataSetID <= POWERTUNE_DEFAULT_SET_MAX &&\n\t\t\ttable_info->cac_dtp_table->usPowerTuneDataSetID)\n\t\tsmu_data->power_tune_defaults =\n\t\t\t\t&polaris10_power_tune_data_set_array\n\t\t\t\t[table_info->cac_dtp_table->usPowerTuneDataSetID - 1];\n\telse\n\t\tsmu_data->power_tune_defaults = &polaris10_power_tune_data_set_array[0];\n\n}\n\nstatic int polaris10_init_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct smu7_hwmgr *hw_data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct SMU74_Discrete_DpmTable *table = &(smu_data->smc_state_table);\n\tuint8_t i;\n\tstruct pp_atomctrl_gpio_pin_assignment gpio_pin;\n\tpp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_ppt_v1_gpio_table *gpio_table = table_info->gpio_table;\n\n\tpolaris10_initialize_power_tune_defaults(hwmgr);\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE != hw_data->voltage_control)\n\t\tpolaris10_populate_smc_voltage_tables(hwmgr, table);\n\n\ttable->SystemFlags = 0;\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_AutomaticDCTransition))\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_StepVddc))\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (hw_data->is_memory_gddr5)\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tif (hw_data->ulv_supported && table_info->us_ulv_voltage_offset) {\n\t\tresult = polaris10_populate_ulv_state(hwmgr, table);\n\t\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\t\"Failed to initialize ULV state!\", return result);\n\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tixCG_ULV_PARAMETER, SMU7_CGULVPARAMETER_DFLT);\n\t}\n\n\tresult = polaris10_populate_smc_link_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize Link Level!\", return result);\n\n\tresult = polaris10_populate_all_graphic_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize Graphics Level!\", return result);\n\n\tresult = polaris10_populate_all_memory_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize Memory Level!\", return result);\n\n\tresult = polaris10_populate_smc_acpi_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize ACPI Level!\", return result);\n\n\tresult = polaris10_populate_smc_vce_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize VCE Level!\", return result);\n\n\tresult = polaris10_populate_smc_samu_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize SAMU Level!\", return result);\n\n\t \n\tresult = polaris10_program_memory_timing_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to Write ARB settings for the initial state.\", return result);\n\n\tresult = polaris10_populate_smc_uvd_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize UVD Level!\", return result);\n\n\tresult = polaris10_populate_smc_boot_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize Boot Level!\", return result);\n\n\tresult = polaris10_populate_smc_initailial_state(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize Boot State!\", return result);\n\n\tresult = polaris10_populate_bapm_parameters_in_dpm_table(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to populate BAPM Parameters!\", return result);\n\n\tpolaris10_populate_zero_rpm_parameters(hwmgr);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_ClockStretcher)) {\n\t\tresult = polaris10_populate_clock_stretcher_data_table(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\t\"Failed to populate Clock Stretcher Data Table!\",\n\t\t\t\treturn result);\n\t}\n\n\tresult = polaris10_populate_avfs_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result, \"Failed to populate AVFS Parameters!\", return result;);\n\n\ttable->CurrSclkPllRange = 0xff;\n\ttable->GraphicsVoltageChangeEnable  = 1;\n\ttable->GraphicsThermThrottleEnable  = 1;\n\ttable->GraphicsInterval = 1;\n\ttable->VoltageInterval  = 1;\n\ttable->ThermalInterval  = 1;\n\ttable->TemperatureLimitHigh =\n\t\t\ttable_info->cac_dtp_table->usTargetOperatingTemp *\n\t\t\tSMU7_Q88_FORMAT_CONVERSION_UNIT;\n\ttable->TemperatureLimitLow  =\n\t\t\t(table_info->cac_dtp_table->usTargetOperatingTemp - 1) *\n\t\t\tSMU7_Q88_FORMAT_CONVERSION_UNIT;\n\ttable->MemoryVoltageChangeEnable = 1;\n\ttable->MemoryInterval = 1;\n\ttable->VoltageResponseTime = 0;\n\ttable->PhaseResponseTime = 0;\n\ttable->MemoryThermThrottleEnable = 1;\n\ttable->PCIeBootLinkLevel = hw_data->dpm_table.pcie_speed_table.count;\n\ttable->PCIeGenInterval = 1;\n\ttable->VRConfig = 0;\n\n\tresult = polaris10_populate_vr_config(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to populate VRConfig setting!\", return result);\n\thw_data->vr_config = table->VRConfig;\n\ttable->ThermGpio = 17;\n\ttable->SclkStepSize = 0x4000;\n\n\tif (atomctrl_get_pp_assign_pin(hwmgr, VDDC_VRHOT_GPIO_PINID, &gpio_pin)) {\n\t\ttable->VRHotGpio = gpio_pin.uc_gpio_pin_bit_shift;\n\t\tif (gpio_table)\n\t\t\ttable->VRHotLevel = gpio_table->vrhot_triggered_sclk_dpm_index;\n\t} else {\n\t\ttable->VRHotGpio = SMU7_UNUSED_GPIO_PIN;\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_RegulatorHot);\n\t}\n\n\tif (atomctrl_get_pp_assign_pin(hwmgr, PP_AC_DC_SWITCH_GPIO_PINID,\n\t\t\t&gpio_pin)) {\n\t\ttable->AcDcGpio = gpio_pin.uc_gpio_pin_bit_shift;\n\t\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_AutomaticDCTransition) &&\n\t\t    !smum_send_msg_to_smc(hwmgr, PPSMC_MSG_UseNewGPIOScheme, NULL))\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_SMCtoPPLIBAcdcGpioScheme);\n\t} else {\n\t\ttable->AcDcGpio = SMU7_UNUSED_GPIO_PIN;\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_AutomaticDCTransition);\n\t}\n\n\t \n\tif (atomctrl_get_pp_assign_pin(hwmgr, THERMAL_INT_OUTPUT_GPIO_PINID,\n\t\t\t&gpio_pin)) {\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ThermalOutGPIO);\n\n\t\ttable->ThermOutGpio = gpio_pin.uc_gpio_pin_bit_shift;\n\n\t\t \n\t\ttable->ThermOutPolarity = (0 == (cgs_read_register(hwmgr->device, mmGPIOPAD_A)\n\t\t\t\t\t& (1 << gpio_pin.uc_gpio_pin_bit_shift))) ? 1:0;\n\t\ttable->ThermOutMode = SMU7_THERM_OUT_MODE_THERM_ONLY;\n\n\t\t \n\t\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_RegulatorHot)\n\t\t&& phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_CombinePCCWithThermalSignal))\n\t\t\ttable->ThermOutMode = SMU7_THERM_OUT_MODE_THERM_VRHOT;\n\t} else {\n\t\ttable->ThermOutGpio = 17;\n\t\ttable->ThermOutPolarity = 1;\n\t\ttable->ThermOutMode = SMU7_THERM_OUT_MODE_DISABLE;\n\t}\n\n\t \n\tfor (i = 0; i <= hw_data->dpm_table.pcie_speed_table.count; i++) {\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr, smu_data->bif_sclk_table[i], &dividers);\n\t\tPP_ASSERT_WITH_CODE((result == 0), \"Can not find DFS divide id for Sclk\", return result);\n\n\t\tif (i == 0)\n\t\t\ttable->Ulv.BifSclkDfs = PP_HOST_TO_SMC_US((USHORT)(dividers.pll_post_divider));\n\t\telse\n\t\t\ttable->LinkLevel[i-1].BifSclkDfs = PP_HOST_TO_SMC_US((USHORT)(dividers.pll_post_divider));\n\t}\n\n\tfor (i = 0; i < SMU74_MAX_ENTRIES_SMIO; i++)\n\t\ttable->Smio[i] = PP_HOST_TO_SMC_UL(table->Smio[i]);\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SystemFlags);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->VRConfig);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMask1);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMask2);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SclkStepSize);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->CurrSclkPllRange);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitHigh);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitLow);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->VoltageResponseTime);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);\n\n\t \n\tresult = smu7_copy_bytes_to_smc(hwmgr,\n\t\t\tsmu_data->smu7_data.dpm_table_start +\n\t\t\toffsetof(SMU74_Discrete_DpmTable, SystemFlags),\n\t\t\t(uint8_t *)&(table->SystemFlags),\n\t\t\tsizeof(SMU74_Discrete_DpmTable) - 3 * sizeof(SMU74_PIDController),\n\t\t\tSMC_RAM_END);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to upload dpm data to SMC memory!\", return result);\n\n\tresult = polaris10_populate_pm_fuses(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to  populate PM fuses to SMC memory!\", return result);\n\n\treturn 0;\n}\n\nstatic int polaris10_program_mem_timing_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tif (data->need_update_smu7_dpm_table &\n\t\t(DPMTABLE_OD_UPDATE_SCLK + DPMTABLE_OD_UPDATE_MCLK))\n\t\treturn polaris10_program_memory_timing_parameters(hwmgr);\n\n\treturn 0;\n}\n\nstatic int polaris10_thermal_avfs_enable(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tif (!hwmgr->avfs_supported)\n\t\treturn 0;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetGBDroopSettings, data->avfs_vdroop_override_setting,\n\t\t\tNULL);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_EnableAvfs, NULL);\n\n\t \n\tif (data->apply_avfs_cks_off_voltage)\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ApplyAvfsCksOffVoltage, NULL);\n\n\treturn 0;\n}\n\nstatic int polaris10_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tSMU74_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\n\tuint32_t duty100;\n\tuint32_t t_diff1, t_diff2, pwm_diff1, pwm_diff2;\n\tuint16_t fdo_min, slope1, slope2;\n\tuint32_t reference_clock;\n\tint res;\n\tuint64_t tmp64;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\tif (smu_data->smu7_data.fan_table_start == 0) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\tduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\n\tif (duty100 == 0) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\t \n\tif (hwmgr->thermal_controller.use_hw_fan_control)\n\t\treturn 0;\n\n\ttmp64 = hwmgr->thermal_controller.advanceFanControlParameters.\n\t\t\tusPWMMin * duty100;\n\tdo_div(tmp64, 10000);\n\tfdo_min = (uint16_t)tmp64;\n\n\tt_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usTMed -\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMin;\n\tt_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usTHigh -\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMed;\n\n\tpwm_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed -\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin;\n\tpwm_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh -\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMed;\n\n\tslope1 = (uint16_t)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\n\tslope2 = (uint16_t)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\n\n\tfan_table.TempMin = cpu_to_be16((50 + hwmgr->\n\t\t\tthermal_controller.advanceFanControlParameters.usTMin) / 100);\n\tfan_table.TempMed = cpu_to_be16((50 + hwmgr->\n\t\t\tthermal_controller.advanceFanControlParameters.usTMed) / 100);\n\tfan_table.TempMax = cpu_to_be16((50 + hwmgr->\n\t\t\tthermal_controller.advanceFanControlParameters.usTMax) / 100);\n\n\tfan_table.Slope1 = cpu_to_be16(slope1);\n\tfan_table.Slope2 = cpu_to_be16(slope2);\n\n\tfan_table.FdoMin = cpu_to_be16(fdo_min);\n\n\tfan_table.HystDown = cpu_to_be16(hwmgr->\n\t\t\tthermal_controller.advanceFanControlParameters.ucTHyst);\n\n\tfan_table.HystUp = cpu_to_be16(1);\n\n\tfan_table.HystSlope = cpu_to_be16(1);\n\n\tfan_table.TempRespLim = cpu_to_be16(5);\n\n\treference_clock = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\tfan_table.RefreshPeriod = cpu_to_be32((hwmgr->\n\t\t\tthermal_controller.advanceFanControlParameters.ulCycleDelay *\n\t\t\treference_clock) / 1600);\n\n\tfan_table.FdoMax = cpu_to_be16((uint16_t)duty100);\n\n\tfan_table.TempSrc = (uint8_t)PHM_READ_VFPF_INDIRECT_FIELD(\n\t\t\thwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_MULT_THERMAL_CTRL, TEMP_SEL);\n\n\tres = smu7_copy_bytes_to_smc(hwmgr, smu_data->smu7_data.fan_table_start,\n\t\t\t(uint8_t *)&fan_table, (uint32_t)sizeof(fan_table),\n\t\t\tSMC_RAM_END);\n\n\tif (!res && hwmgr->thermal_controller.\n\t\t\tadvanceFanControlParameters.ucMinimumPWMLimit)\n\t\tres = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetFanMinPwm,\n\t\t\t\thwmgr->thermal_controller.\n\t\t\t\tadvanceFanControlParameters.ucMinimumPWMLimit,\n\t\t\t\tNULL);\n\n\tif (!res && hwmgr->thermal_controller.\n\t\t\tadvanceFanControlParameters.ulMinFanSCLKAcousticLimit)\n\t\tres = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetFanSclkTarget,\n\t\t\t\thwmgr->thermal_controller.\n\t\t\t\tadvanceFanControlParameters.ulMinFanSCLKAcousticLimit,\n\t\t\t\tNULL);\n\n\tif (res)\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\n\treturn 0;\n}\n\nstatic int polaris10_update_uvd_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tuint32_t mm_boot_level_offset, mm_boot_level_value;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tsmu_data->smc_state_table.UvdBootLevel = 0;\n\tif (table_info->mm_dep_table->count > 0)\n\t\tsmu_data->smc_state_table.UvdBootLevel =\n\t\t\t\t(uint8_t) (table_info->mm_dep_table->count - 1);\n\tmm_boot_level_offset = smu_data->smu7_data.dpm_table_start + offsetof(SMU74_Discrete_DpmTable,\n\t\t\t\t\t\tUvdBootLevel);\n\tmm_boot_level_offset /= 4;\n\tmm_boot_level_offset *= 4;\n\tmm_boot_level_value = cgs_read_ind_register(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, mm_boot_level_offset);\n\tmm_boot_level_value &= 0x00FFFFFF;\n\tmm_boot_level_value |= smu_data->smc_state_table.UvdBootLevel << 24;\n\tcgs_write_ind_register(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, mm_boot_level_offset, mm_boot_level_value);\n\n\tif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_UVDDPM) ||\n\t\tphm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_StablePState))\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_UVDDPM_SetEnabledMask,\n\t\t\t\t(uint32_t)(1 << smu_data->smc_state_table.UvdBootLevel),\n\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int polaris10_update_vce_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tuint32_t mm_boot_level_offset, mm_boot_level_value;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_StablePState))\n\t\tsmu_data->smc_state_table.VceBootLevel =\n\t\t\t(uint8_t) (table_info->mm_dep_table->count - 1);\n\telse\n\t\tsmu_data->smc_state_table.VceBootLevel = 0;\n\n\tmm_boot_level_offset = smu_data->smu7_data.dpm_table_start +\n\t\t\t\t\toffsetof(SMU74_Discrete_DpmTable, VceBootLevel);\n\tmm_boot_level_offset /= 4;\n\tmm_boot_level_offset *= 4;\n\tmm_boot_level_value = cgs_read_ind_register(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, mm_boot_level_offset);\n\tmm_boot_level_value &= 0xFF00FFFF;\n\tmm_boot_level_value |= smu_data->smc_state_table.VceBootLevel << 16;\n\tcgs_write_ind_register(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, mm_boot_level_offset, mm_boot_level_value);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_StablePState))\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_VCEDPM_SetEnabledMask,\n\t\t\t\t(uint32_t)1 << smu_data->smc_state_table.VceBootLevel,\n\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int polaris10_update_bif_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_pcie_table *pcie_table = table_info->pcie_table;\n\tint max_entry, i;\n\n\tmax_entry = (SMU74_MAX_LEVELS_LINK < pcie_table->count) ?\n\t\t\t\t\t\tSMU74_MAX_LEVELS_LINK :\n\t\t\t\t\t\tpcie_table->count;\n\t \n\tfor (i = 0; i < max_entry; i++)\n\t\tsmu_data->bif_sclk_table[i] = pcie_table->entries[i].pcie_sclk;\n\treturn 0;\n}\n\nstatic int polaris10_update_smc_table(struct pp_hwmgr *hwmgr, uint32_t type)\n{\n\tswitch (type) {\n\tcase SMU_UVD_TABLE:\n\t\tpolaris10_update_uvd_smc_table(hwmgr);\n\t\tbreak;\n\tcase SMU_VCE_TABLE:\n\t\tpolaris10_update_vce_smc_table(hwmgr);\n\t\tbreak;\n\tcase SMU_BIF_TABLE:\n\t\tpolaris10_update_bif_smc_table(hwmgr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int polaris10_update_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\n\tint result = 0;\n\tuint32_t low_sclk_interrupt_threshold = 0;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SclkThrottleLowNotification)\n\t\t&& (data->low_sclk_interrupt_threshold != 0)) {\n\t\tlow_sclk_interrupt_threshold =\n\t\t\t\tdata->low_sclk_interrupt_threshold;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(low_sclk_interrupt_threshold);\n\n\t\tresult = smu7_copy_bytes_to_smc(\n\t\t\t\thwmgr,\n\t\t\t\tsmu_data->smu7_data.dpm_table_start +\n\t\t\t\toffsetof(SMU74_Discrete_DpmTable,\n\t\t\t\t\tLowSclkInterruptThreshold),\n\t\t\t\t(uint8_t *)&low_sclk_interrupt_threshold,\n\t\t\t\tsizeof(uint32_t),\n\t\t\t\tSMC_RAM_END);\n\t}\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t\"Failed to update SCLK threshold!\", return result);\n\n\tresult = polaris10_program_mem_timing_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t\"Failed to program memory timing parameters!\",\n\t\t\t);\n\n\treturn result;\n}\n\nstatic uint32_t polaris10_get_offsetof(uint32_t type, uint32_t member)\n{\n\tswitch (type) {\n\tcase SMU_SoftRegisters:\n\t\tswitch (member) {\n\t\tcase HandshakeDisables:\n\t\t\treturn offsetof(SMU74_SoftRegisters, HandshakeDisables);\n\t\tcase VoltageChangeTimeout:\n\t\t\treturn offsetof(SMU74_SoftRegisters, VoltageChangeTimeout);\n\t\tcase AverageGraphicsActivity:\n\t\t\treturn offsetof(SMU74_SoftRegisters, AverageGraphicsActivity);\n\t\tcase AverageMemoryActivity:\n\t\t\treturn offsetof(SMU74_SoftRegisters, AverageMemoryActivity);\n\t\tcase PreVBlankGap:\n\t\t\treturn offsetof(SMU74_SoftRegisters, PreVBlankGap);\n\t\tcase VBlankTimeout:\n\t\t\treturn offsetof(SMU74_SoftRegisters, VBlankTimeout);\n\t\tcase UcodeLoadStatus:\n\t\t\treturn offsetof(SMU74_SoftRegisters, UcodeLoadStatus);\n\t\tcase DRAM_LOG_ADDR_H:\n\t\t\treturn offsetof(SMU74_SoftRegisters, DRAM_LOG_ADDR_H);\n\t\tcase DRAM_LOG_ADDR_L:\n\t\t\treturn offsetof(SMU74_SoftRegisters, DRAM_LOG_ADDR_L);\n\t\tcase DRAM_LOG_PHY_ADDR_H:\n\t\t\treturn offsetof(SMU74_SoftRegisters, DRAM_LOG_PHY_ADDR_H);\n\t\tcase DRAM_LOG_PHY_ADDR_L:\n\t\t\treturn offsetof(SMU74_SoftRegisters, DRAM_LOG_PHY_ADDR_L);\n\t\tcase DRAM_LOG_BUFF_SIZE:\n\t\t\treturn offsetof(SMU74_SoftRegisters, DRAM_LOG_BUFF_SIZE);\n\t\t}\n\t\tbreak;\n\tcase SMU_Discrete_DpmTable:\n\t\tswitch (member) {\n\t\tcase UvdBootLevel:\n\t\t\treturn offsetof(SMU74_Discrete_DpmTable, UvdBootLevel);\n\t\tcase VceBootLevel:\n\t\t\treturn offsetof(SMU74_Discrete_DpmTable, VceBootLevel);\n\t\tcase LowSclkInterruptThreshold:\n\t\t\treturn offsetof(SMU74_Discrete_DpmTable, LowSclkInterruptThreshold);\n\t\t}\n\t\tbreak;\n\t}\n\tpr_warn(\"can't get the offset of type %x member %x\\n\", type, member);\n\treturn 0;\n}\n\nstatic uint32_t polaris10_get_mac_definition(uint32_t value)\n{\n\tswitch (value) {\n\tcase SMU_MAX_LEVELS_GRAPHICS:\n\t\treturn SMU74_MAX_LEVELS_GRAPHICS;\n\tcase SMU_MAX_LEVELS_MEMORY:\n\t\treturn SMU74_MAX_LEVELS_MEMORY;\n\tcase SMU_MAX_LEVELS_LINK:\n\t\treturn SMU74_MAX_LEVELS_LINK;\n\tcase SMU_MAX_ENTRIES_SMIO:\n\t\treturn SMU74_MAX_ENTRIES_SMIO;\n\tcase SMU_MAX_LEVELS_VDDC:\n\t\treturn SMU74_MAX_LEVELS_VDDC;\n\tcase SMU_MAX_LEVELS_VDDGFX:\n\t\treturn SMU74_MAX_LEVELS_VDDGFX;\n\tcase SMU_MAX_LEVELS_VDDCI:\n\t\treturn SMU74_MAX_LEVELS_VDDCI;\n\tcase SMU_MAX_LEVELS_MVDD:\n\t\treturn SMU74_MAX_LEVELS_MVDD;\n\tcase SMU_UVD_MCLK_HANDSHAKE_DISABLE:\n\t\treturn SMU7_UVD_MCLK_HANDSHAKE_DISABLE |\n\t\t\t\tSMU7_VCE_MCLK_HANDSHAKE_DISABLE;\n\t}\n\n\tpr_warn(\"can't get the mac of %x\\n\", value);\n\treturn 0;\n}\n\nstatic int polaris10_process_firmware_header(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t tmp;\n\tint result;\n\tbool error = false;\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, DpmTable),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\tsmu_data->smu7_data.dpm_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, SoftRegisters),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (!result) {\n\t\tdata->soft_regs_start = tmp;\n\t\tsmu_data->smu7_data.soft_regs_start = tmp;\n\t}\n\n\terror |= (0 != result);\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, mcRegisterTable),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (!result)\n\t\tsmu_data->smu7_data.mc_reg_table_start = tmp;\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, FanTable),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (!result)\n\t\tsmu_data->smu7_data.fan_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, mcArbDramTimingTable),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (!result)\n\t\tsmu_data->smu7_data.arb_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = smu7_read_smc_sram_dword(hwmgr,\n\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\toffsetof(SMU74_Firmware_Header, Version),\n\t\t\t&tmp, SMC_RAM_END);\n\n\tif (!result)\n\t\thwmgr->microcode_version_info.SMC = tmp;\n\n\terror |= (0 != result);\n\n\treturn error ? -1 : 0;\n}\n\nstatic uint8_t polaris10_get_memory_modile_index(struct pp_hwmgr *hwmgr)\n{\n\treturn (uint8_t) (0xFF & (cgs_read_register(hwmgr->device, mmBIOS_SCRATCH_4) >> 16));\n}\n\nstatic int polaris10_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)(hwmgr->smu_backend);\n\tpp_atomctrl_mc_reg_table *mc_reg_table = &smu_data->mc_reg_table;\n\tuint8_t module_index = polaris10_get_memory_modile_index(hwmgr);\n\n\tmemset(mc_reg_table, 0, sizeof(pp_atomctrl_mc_reg_table));\n\n\treturn atomctrl_initialize_mc_reg_table_v2_2(hwmgr, module_index, mc_reg_table);\n}\n\nstatic bool polaris10_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\treturn (1 == PHM_READ_INDIRECT_FIELD(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, FEATURE_STATUS, VOLTAGE_CONTROLLER_ON))\n\t\t\t? true : false;\n}\n\nstatic int polaris10_update_dpm_settings(struct pp_hwmgr *hwmgr,\n\t\t\t\tvoid *profile_setting)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct polaris10_smumgr *smu_data = (struct polaris10_smumgr *)\n\t\t\t(hwmgr->smu_backend);\n\tstruct profile_mode_setting *setting;\n\tstruct SMU74_Discrete_GraphicsLevel *levels =\n\t\t\tsmu_data->smc_state_table.GraphicsLevel;\n\tuint32_t array = smu_data->smu7_data.dpm_table_start +\n\t\t\toffsetof(SMU74_Discrete_DpmTable, GraphicsLevel);\n\n\tuint32_t mclk_array = smu_data->smu7_data.dpm_table_start +\n\t\t\toffsetof(SMU74_Discrete_DpmTable, MemoryLevel);\n\tstruct SMU74_Discrete_MemoryLevel *mclk_levels =\n\t\t\tsmu_data->smc_state_table.MemoryLevel;\n\tuint32_t i;\n\tuint32_t offset, up_hyst_offset, down_hyst_offset, clk_activity_offset, tmp;\n\n\tif (profile_setting == NULL)\n\t\treturn -EINVAL;\n\n\tsetting = (struct profile_mode_setting *)profile_setting;\n\n\tif (setting->bupdate_sclk) {\n\t\tif (!data->sclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_FreezeLevel, NULL);\n\t\tfor (i = 0; i < smu_data->smc_state_table.GraphicsDpmLevelCount; i++) {\n\t\t\tif (levels[i].ActivityLevel !=\n\t\t\t\tcpu_to_be16(setting->sclk_activity)) {\n\t\t\t\tlevels[i].ActivityLevel = cpu_to_be16(setting->sclk_activity);\n\n\t\t\t\tclk_activity_offset = array + (sizeof(SMU74_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_GraphicsLevel, ActivityLevel);\n\t\t\t\toffset = clk_activity_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(clk_activity_offset, tmp, levels[i].ActivityLevel, sizeof(uint16_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\n\t\t\t}\n\t\t\tif (levels[i].UpHyst != setting->sclk_up_hyst ||\n\t\t\t\tlevels[i].DownHyst != setting->sclk_down_hyst) {\n\t\t\t\tlevels[i].UpHyst = setting->sclk_up_hyst;\n\t\t\t\tlevels[i].DownHyst = setting->sclk_down_hyst;\n\t\t\t\tup_hyst_offset = array + (sizeof(SMU74_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_GraphicsLevel, UpHyst);\n\t\t\t\tdown_hyst_offset = array + (sizeof(SMU74_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_GraphicsLevel, DownHyst);\n\t\t\t\toffset = up_hyst_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(up_hyst_offset, tmp, levels[i].UpHyst, sizeof(uint8_t));\n\t\t\t\ttmp = phm_set_field_to_u32(down_hyst_offset, tmp, levels[i].DownHyst, sizeof(uint8_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\t\t\t}\n\t\t}\n\t\tif (!data->sclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_UnfreezeLevel, NULL);\n\t}\n\n\tif (setting->bupdate_mclk) {\n\t\tif (!data->mclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_FreezeLevel, NULL);\n\t\tfor (i = 0; i < smu_data->smc_state_table.MemoryDpmLevelCount; i++) {\n\t\t\tif (mclk_levels[i].ActivityLevel !=\n\t\t\t\tcpu_to_be16(setting->mclk_activity)) {\n\t\t\t\tmclk_levels[i].ActivityLevel = cpu_to_be16(setting->mclk_activity);\n\n\t\t\t\tclk_activity_offset = mclk_array + (sizeof(SMU74_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_MemoryLevel, ActivityLevel);\n\t\t\t\toffset = clk_activity_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(clk_activity_offset, tmp, mclk_levels[i].ActivityLevel, sizeof(uint16_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\n\t\t\t}\n\t\t\tif (mclk_levels[i].UpHyst != setting->mclk_up_hyst ||\n\t\t\t\tmclk_levels[i].DownHyst != setting->mclk_down_hyst) {\n\t\t\t\tmclk_levels[i].UpHyst = setting->mclk_up_hyst;\n\t\t\t\tmclk_levels[i].DownHyst = setting->mclk_down_hyst;\n\t\t\t\tup_hyst_offset = mclk_array + (sizeof(SMU74_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_MemoryLevel, UpHyst);\n\t\t\t\tdown_hyst_offset = mclk_array + (sizeof(SMU74_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU74_Discrete_MemoryLevel, DownHyst);\n\t\t\t\toffset = up_hyst_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(up_hyst_offset, tmp, mclk_levels[i].UpHyst, sizeof(uint8_t));\n\t\t\t\ttmp = phm_set_field_to_u32(down_hyst_offset, tmp, mclk_levels[i].DownHyst, sizeof(uint8_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\t\t\t}\n\t\t}\n\t\tif (!data->mclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_UnfreezeLevel, NULL);\n\t}\n\treturn 0;\n}\n\nconst struct pp_smumgr_func polaris10_smu_funcs = {\n\t.name = \"polaris10_smu\",\n\t.smu_init = polaris10_smu_init,\n\t.smu_fini = smu7_smu_fini,\n\t.start_smu = polaris10_start_smu,\n\t.check_fw_load_finish = smu7_check_fw_load_finish,\n\t.request_smu_load_fw = smu7_reload_firmware,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = smu7_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = smu7_send_msg_to_smc_with_parameter,\n\t.get_argument = smu7_get_argument,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.update_smc_table = polaris10_update_smc_table,\n\t.get_offsetof = polaris10_get_offsetof,\n\t.process_firmware_header = polaris10_process_firmware_header,\n\t.init_smc_table = polaris10_init_smc_table,\n\t.update_sclk_threshold = polaris10_update_sclk_threshold,\n\t.thermal_avfs_enable = polaris10_thermal_avfs_enable,\n\t.thermal_setup_fan_table = polaris10_thermal_setup_fan_table,\n\t.populate_all_graphic_levels = polaris10_populate_all_graphic_levels,\n\t.populate_all_memory_levels = polaris10_populate_all_memory_levels,\n\t.get_mac_definition = polaris10_get_mac_definition,\n\t.initialize_mc_reg_table = polaris10_initialize_mc_reg_table,\n\t.is_dpm_running = polaris10_is_dpm_running,\n\t.is_hw_avfs_present = polaris10_is_hw_avfs_present,\n\t.update_dpm_settings = polaris10_update_dpm_settings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}