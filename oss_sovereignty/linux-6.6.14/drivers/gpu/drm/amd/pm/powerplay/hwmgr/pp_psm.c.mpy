{
  "module_name": "pp_psm.c",
  "hash_id": "6c68f6e48fa4ddd99c36d4457426e472d420bd0be8c3952e490837bb67c60e7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"pp_psm.h\"\n\nint psm_init_power_state_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tunsigned int i;\n\tunsigned int table_entries;\n\tstruct pp_power_state *state;\n\tint size;\n\n\tif (hwmgr->hwmgr_func->get_num_of_pp_table_entries == NULL)\n\t\treturn 0;\n\n\tif (hwmgr->hwmgr_func->get_power_state_size == NULL)\n\t\treturn 0;\n\n\thwmgr->num_ps = table_entries = hwmgr->hwmgr_func->get_num_of_pp_table_entries(hwmgr);\n\n\thwmgr->ps_size = size = hwmgr->hwmgr_func->get_power_state_size(hwmgr) +\n\t\t\t\t\t  sizeof(struct pp_power_state);\n\n\tif (table_entries == 0 || size == 0) {\n\t\tpr_warn(\"Please check whether power state management is supported on this asic\\n\");\n\t\treturn 0;\n\t}\n\n\thwmgr->ps = kcalloc(table_entries, size, GFP_KERNEL);\n\tif (hwmgr->ps == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->request_ps = kzalloc(size, GFP_KERNEL);\n\tif (hwmgr->request_ps == NULL) {\n\t\tkfree(hwmgr->ps);\n\t\thwmgr->ps = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\thwmgr->current_ps = kzalloc(size, GFP_KERNEL);\n\tif (hwmgr->current_ps == NULL) {\n\t\tkfree(hwmgr->request_ps);\n\t\tkfree(hwmgr->ps);\n\t\thwmgr->request_ps = NULL;\n\t\thwmgr->ps = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tstate = hwmgr->ps;\n\n\tfor (i = 0; i < table_entries; i++) {\n\t\tresult = hwmgr->hwmgr_func->get_pp_table_entry(hwmgr, i, state);\n\t\tif (result) {\n\t\t\tkfree(hwmgr->current_ps);\n\t\t\tkfree(hwmgr->request_ps);\n\t\t\tkfree(hwmgr->ps);\n\t\t\thwmgr->current_ps = NULL;\n\t\t\thwmgr->request_ps = NULL;\n\t\t\thwmgr->ps = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (state->classification.flags & PP_StateClassificationFlag_Boot) {\n\t\t\thwmgr->boot_ps = state;\n\t\t\tmemcpy(hwmgr->current_ps, state, size);\n\t\t\tmemcpy(hwmgr->request_ps, state, size);\n\t\t}\n\n\t\tstate->id = i + 1;  \n\n\t\tif (state->classification.flags & PP_StateClassificationFlag_Uvd)\n\t\t\thwmgr->uvd_ps = state;\n\t\tstate = (struct pp_power_state *)((unsigned long)state + size);\n\t}\n\n\treturn 0;\n}\n\nint psm_fini_power_state_table(struct pp_hwmgr *hwmgr)\n{\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->ps)\n\t\treturn 0;\n\n\tkfree(hwmgr->current_ps);\n\tkfree(hwmgr->request_ps);\n\tkfree(hwmgr->ps);\n\thwmgr->request_ps = NULL;\n\thwmgr->ps = NULL;\n\thwmgr->current_ps = NULL;\n\treturn 0;\n}\n\nstatic int psm_get_ui_state(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum PP_StateUILabel ui_label,\n\t\t\t\tunsigned long *state_id)\n{\n\tstruct pp_power_state *state;\n\tint table_entries;\n\tint i;\n\n\ttable_entries = hwmgr->num_ps;\n\tstate = hwmgr->ps;\n\n\tfor (i = 0; i < table_entries; i++) {\n\t\tif (state->classification.ui_label & ui_label) {\n\t\t\t*state_id = state->id;\n\t\t\treturn 0;\n\t\t}\n\t\tstate = (struct pp_power_state *)((unsigned long)state + hwmgr->ps_size);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int psm_get_state_by_classification(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_StateClassificationFlag flag,\n\t\t\t\t\tunsigned long *state_id)\n{\n\tstruct pp_power_state *state;\n\tint table_entries;\n\tint i;\n\n\ttable_entries = hwmgr->num_ps;\n\tstate = hwmgr->ps;\n\n\tfor (i = 0; i < table_entries; i++) {\n\t\tif (state->classification.flags & flag) {\n\t\t\t*state_id = state->id;\n\t\t\treturn 0;\n\t\t}\n\t\tstate = (struct pp_power_state *)((unsigned long)state + hwmgr->ps_size);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int psm_set_states(struct pp_hwmgr *hwmgr, unsigned long state_id)\n{\n\tstruct pp_power_state *state;\n\tint table_entries;\n\tint i;\n\n\ttable_entries = hwmgr->num_ps;\n\n\tstate = hwmgr->ps;\n\n\tfor (i = 0; i < table_entries; i++) {\n\t\tif (state->id == state_id) {\n\t\t\tmemcpy(hwmgr->request_ps, state, hwmgr->ps_size);\n\t\t\treturn 0;\n\t\t}\n\t\tstate = (struct pp_power_state *)((unsigned long)state + hwmgr->ps_size);\n\t}\n\treturn -EINVAL;\n}\n\nint psm_set_boot_states(struct pp_hwmgr *hwmgr)\n{\n\tunsigned long state_id;\n\tint ret = -EINVAL;\n\n\tif (!hwmgr->ps)\n\t\treturn 0;\n\n\tif (!psm_get_state_by_classification(hwmgr, PP_StateClassificationFlag_Boot,\n\t\t\t\t\t&state_id))\n\t\tret = psm_set_states(hwmgr, state_id);\n\n\treturn ret;\n}\n\nint psm_set_performance_states(struct pp_hwmgr *hwmgr)\n{\n\tunsigned long state_id;\n\tint ret = -EINVAL;\n\n\tif (!hwmgr->ps)\n\t\treturn 0;\n\n\tif (!psm_get_ui_state(hwmgr, PP_StateUILabel_Performance,\n\t\t\t\t\t&state_id))\n\t\tret = psm_set_states(hwmgr, state_id);\n\n\treturn ret;\n}\n\nint psm_set_user_performance_state(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_StateUILabel label_id,\n\t\t\t\t\tstruct pp_power_state **state)\n{\n\tint table_entries;\n\tint i;\n\n\tif (!hwmgr->ps)\n\t\treturn 0;\n\n\ttable_entries = hwmgr->num_ps;\n\t*state = hwmgr->ps;\n\nrestart_search:\n\tfor (i = 0; i < table_entries; i++) {\n\t\tif ((*state)->classification.ui_label & label_id)\n\t\t\treturn 0;\n\t\t*state = (struct pp_power_state *)((uintptr_t)*state + hwmgr->ps_size);\n\t}\n\n\tswitch (label_id) {\n\tcase PP_StateUILabel_Battery:\n\tcase PP_StateUILabel_Balanced:\n\t\tlabel_id = PP_StateUILabel_Performance;\n\t\tgoto restart_search;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void power_state_management(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tstruct pp_power_state *new_ps)\n{\n\tstruct pp_power_state *pcurrent;\n\tstruct pp_power_state *requested;\n\tbool equal;\n\n\tif (new_ps != NULL)\n\t\trequested = new_ps;\n\telse\n\t\trequested = hwmgr->request_ps;\n\n\tpcurrent = hwmgr->current_ps;\n\n\tphm_apply_state_adjust_rules(hwmgr, requested, pcurrent);\n\tif (pcurrent == NULL || (0 != phm_check_states_equal(hwmgr,\n\t\t\t&pcurrent->hardware, &requested->hardware, &equal)))\n\t\tequal = false;\n\n\tif (!equal || phm_check_smc_update_required_for_display_configuration(hwmgr)) {\n\t\tphm_set_power_state(hwmgr, &pcurrent->hardware, &requested->hardware);\n\t\tmemcpy(hwmgr->current_ps, hwmgr->request_ps, hwmgr->ps_size);\n\t}\n}\n\nint psm_adjust_power_state_dynamic(struct pp_hwmgr *hwmgr, bool skip_display_settings,\n\t\t\t\t\t\tstruct pp_power_state *new_ps)\n{\n\tuint32_t index;\n\tlong workload;\n\n\tif (hwmgr->not_vf) {\n\t\tif (!skip_display_settings)\n\t\t\tphm_display_configuration_changed(hwmgr);\n\n\t\tif (hwmgr->ps)\n\t\t\tpower_state_management(hwmgr, new_ps);\n\t\telse\n\t\t\t \n\t\t\tphm_apply_clock_adjust_rules(hwmgr);\n\n\t\tif (!skip_display_settings)\n\t\t\tphm_notify_smc_display_config_after_ps_adjustment(hwmgr);\n\t}\n\n\tif (!phm_force_dpm_levels(hwmgr, hwmgr->request_dpm_level))\n\t\thwmgr->dpm_level = hwmgr->request_dpm_level;\n\n\tif (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\tindex = fls(hwmgr->workload_mask);\n\t\tindex = index > 0 && index <= Workload_Policy_Max ? index - 1 : 0;\n\t\tworkload = hwmgr->workload_setting[index];\n\n\t\tif (hwmgr->power_profile_mode != workload && hwmgr->hwmgr_func->set_power_profile_mode)\n\t\t\thwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}