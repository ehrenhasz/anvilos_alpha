{
  "module_name": "ppatomctrl.c",
  "hash_id": "10f09400ab5ef2e2efdf7ad7a75f806e3ae243ecab85c94b295ba7d5319706d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/ppatomctrl.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include \"atom.h\"\n#include \"ppatomctrl.h\"\n#include \"atombios.h\"\n#include \"cgs_common.h\"\n#include \"ppevvmath.h\"\n\n#define MEM_ID_MASK           0xff000000\n#define MEM_ID_SHIFT          24\n#define CLOCK_RANGE_MASK      0x00ffffff\n#define CLOCK_RANGE_SHIFT     0\n#define LOW_NIBBLE_MASK       0xf\n#define DATA_EQU_PREV         0\n#define DATA_FROM_TABLE       4\n\nunion voltage_object_info {\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO v1;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V2 v2;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V3_1 v3;\n};\n\nstatic int atomctrl_retrieve_ac_timing(\n\t\tuint8_t index,\n\t\tATOM_INIT_REG_BLOCK *reg_block,\n\t\tpp_atomctrl_mc_reg_table *table)\n{\n\tuint32_t i, j;\n\tuint8_t tmem_id;\n\tATOM_MEMORY_SETTING_DATA_BLOCK *reg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t((uint8_t *)reg_block + (2 * sizeof(uint16_t)) + le16_to_cpu(reg_block->usRegIndexTblSize));\n\n\tuint8_t num_ranges = 0;\n\n\twhile (*(uint32_t *)reg_data != END_OF_REG_DATA_BLOCK &&\n\t\t\tnum_ranges < VBIOS_MAX_AC_TIMING_ENTRIES) {\n\t\ttmem_id = (uint8_t)((*(uint32_t *)reg_data & MEM_ID_MASK) >> MEM_ID_SHIFT);\n\n\t\tif (index == tmem_id) {\n\t\t\ttable->mc_reg_table_entry[num_ranges].mclk_max =\n\t\t\t\t(uint32_t)((*(uint32_t *)reg_data & CLOCK_RANGE_MASK) >>\n\t\t\t\t\t\tCLOCK_RANGE_SHIFT);\n\n\t\t\tfor (i = 0, j = 1; i < table->last; i++) {\n\t\t\t\tif ((table->mc_reg_address[i].uc_pre_reg_data &\n\t\t\t\t\t\t\tLOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\n\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t(uint32_t)*((uint32_t *)reg_data + j);\n\t\t\t\t\tj++;\n\t\t\t\t} else if ((table->mc_reg_address[i].uc_pre_reg_data &\n\t\t\t\t\t\t\tLOW_NIBBLE_MASK) == DATA_EQU_PREV) {\n\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_ranges++;\n\t\t}\n\n\t\treg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t((uint8_t *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize)) ;\n\t}\n\n\tPP_ASSERT_WITH_CODE((*(uint32_t *)reg_data == END_OF_REG_DATA_BLOCK),\n\t\t\t\"Invalid VramInfo table.\", return -1);\n\ttable->num_entries = num_ranges;\n\n\treturn 0;\n}\n\n \nstatic int atomctrl_set_mc_reg_address_table(\n\t\tATOM_INIT_REG_BLOCK *reg_block,\n\t\tpp_atomctrl_mc_reg_table *table)\n{\n\tuint8_t i = 0;\n\tuint8_t num_entries = (uint8_t)((le16_to_cpu(reg_block->usRegIndexTblSize))\n\t\t\t/ sizeof(ATOM_INIT_REG_INDEX_FORMAT));\n\tATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\n\n\tnum_entries--;         \n\n\tPP_ASSERT_WITH_CODE((num_entries <= VBIOS_MC_REGISTER_ARRAY_SIZE),\n\t\t\t\"Invalid VramInfo table.\", return -1);\n\n\t \n\twhile ((!(format->ucPreRegDataLength & ACCESS_PLACEHOLDER)) &&\n\t\t\t(i < num_entries)) {\n\t\ttable->mc_reg_address[i].s1 =\n\t\t\t(uint16_t)(le16_to_cpu(format->usRegIndex));\n\t\ttable->mc_reg_address[i].uc_pre_reg_data =\n\t\t\tformat->ucPreRegDataLength;\n\n\t\ti++;\n\t\tformat = (ATOM_INIT_REG_INDEX_FORMAT *)\n\t\t\t((uint8_t *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\n\t}\n\n\ttable->last = i;\n\treturn 0;\n}\n\nint atomctrl_initialize_mc_reg_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t module_index,\n\t\tpp_atomctrl_mc_reg_table *table)\n{\n\tATOM_VRAM_INFO_HEADER_V2_1 *vram_info;\n\tATOM_INIT_REG_BLOCK *reg_block;\n\tint result = 0;\n\tu8 frev, crev;\n\tu16 size;\n\n\tvram_info = (ATOM_VRAM_INFO_HEADER_V2_1 *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tGetIndexIntoMasterTable(DATA, VRAM_Info), &size, &frev, &crev);\n\n\tif (module_index >= vram_info->ucNumOfVRAMModule) {\n\t\tpr_err(\"Invalid VramInfo table.\");\n\t\tresult = -1;\n\t} else if (vram_info->sHeader.ucTableFormatRevision < 2) {\n\t\tpr_err(\"Invalid VramInfo table.\");\n\t\tresult = -1;\n\t}\n\n\tif (0 == result) {\n\t\treg_block = (ATOM_INIT_REG_BLOCK *)\n\t\t\t((uint8_t *)vram_info + le16_to_cpu(vram_info->usMemClkPatchTblOffset));\n\t\tresult = atomctrl_set_mc_reg_address_table(reg_block, table);\n\t}\n\n\tif (0 == result) {\n\t\tresult = atomctrl_retrieve_ac_timing(module_index,\n\t\t\t\t\treg_block, table);\n\t}\n\n\treturn result;\n}\n\nint atomctrl_initialize_mc_reg_table_v2_2(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t module_index,\n\t\tpp_atomctrl_mc_reg_table *table)\n{\n\tATOM_VRAM_INFO_HEADER_V2_2 *vram_info;\n\tATOM_INIT_REG_BLOCK *reg_block;\n\tint result = 0;\n\tu8 frev, crev;\n\tu16 size;\n\n\tvram_info = (ATOM_VRAM_INFO_HEADER_V2_2 *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tGetIndexIntoMasterTable(DATA, VRAM_Info), &size, &frev, &crev);\n\n\tif (module_index >= vram_info->ucNumOfVRAMModule) {\n\t\tpr_err(\"Invalid VramInfo table.\");\n\t\tresult = -1;\n\t} else if (vram_info->sHeader.ucTableFormatRevision < 2) {\n\t\tpr_err(\"Invalid VramInfo table.\");\n\t\tresult = -1;\n\t}\n\n\tif (0 == result) {\n\t\treg_block = (ATOM_INIT_REG_BLOCK *)\n\t\t\t((uint8_t *)vram_info + le16_to_cpu(vram_info->usMemClkPatchTblOffset));\n\t\tresult = atomctrl_set_mc_reg_address_table(reg_block, table);\n\t}\n\n\tif (0 == result) {\n\t\tresult = atomctrl_retrieve_ac_timing(module_index,\n\t\t\t\t\treg_block, table);\n\t}\n\n\treturn result;\n}\n\n \nint atomctrl_set_engine_dram_timings_rv770(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t engine_clock,\n\t\tuint32_t memory_clock)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tSET_ENGINE_CLOCK_PS_ALLOCATION engine_clock_parameters;\n\n\t \n\tengine_clock_parameters.ulTargetEngineClock =\n\t\tcpu_to_le32((engine_clock & SET_CLOCK_FREQ_MASK) |\n\t\t\t    ((COMPUTE_ENGINE_PLL_PARAM << 24)));\n\n\t \n\tengine_clock_parameters.sReserved.ulClock =\n\t\tcpu_to_le32(memory_clock & SET_CLOCK_FREQ_MASK);\n\n\treturn amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, DynamicMemorySettings),\n\t\t\t(uint32_t *)&engine_clock_parameters);\n}\n\n \nstatic ATOM_VOLTAGE_OBJECT_INFO *get_voltage_info_table(void *device)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 size;\n\tunion voltage_object_info *voltage_info;\n\n\tvoltage_info = (union voltage_object_info *)\n\t\tsmu_atom_get_data_table(device, index,\n\t\t\t&size, &frev, &crev);\n\n\tif (voltage_info != NULL)\n\t\treturn (ATOM_VOLTAGE_OBJECT_INFO *) &(voltage_info->v3);\n\telse\n\t\treturn NULL;\n}\n\nstatic const ATOM_VOLTAGE_OBJECT_V3 *atomctrl_lookup_voltage_type_v3(\n\t\tconst ATOM_VOLTAGE_OBJECT_INFO_V3_1 * voltage_object_info_table,\n\t\tuint8_t voltage_type, uint8_t voltage_mode)\n{\n\tunsigned int size = le16_to_cpu(voltage_object_info_table->sHeader.usStructureSize);\n\tunsigned int offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V3_1, asVoltageObj[0]);\n\tuint8_t *start = (uint8_t *)voltage_object_info_table;\n\n\twhile (offset < size) {\n\t\tconst ATOM_VOLTAGE_OBJECT_V3 *voltage_object =\n\t\t\t(const ATOM_VOLTAGE_OBJECT_V3 *)(start + offset);\n\n\t\tif (voltage_type == voltage_object->asGpioVoltageObj.sHeader.ucVoltageType &&\n\t\t\tvoltage_mode == voltage_object->asGpioVoltageObj.sHeader.ucVoltageMode)\n\t\t\treturn voltage_object;\n\n\t\toffset += le16_to_cpu(voltage_object->asGpioVoltageObj.sHeader.usSize);\n\t}\n\n\treturn NULL;\n}\n\n \nint atomctrl_get_memory_pll_dividers_si(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_value,\n\t\tpp_atomctrl_memory_clock_param *mpll_param,\n\t\tbool strobe_mode)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_1 mpll_parameters;\n\tint result;\n\n\tmpll_parameters.ulClock = cpu_to_le32(clock_value);\n\tmpll_parameters.ucInputFlag = (uint8_t)((strobe_mode) ? 1 : 0);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam),\n\t\t(uint32_t *)&mpll_parameters);\n\n\tif (0 == result) {\n\t\tmpll_param->mpll_fb_divider.clk_frac =\n\t\t\tle16_to_cpu(mpll_parameters.ulFbDiv.usFbDivFrac);\n\t\tmpll_param->mpll_fb_divider.cl_kf =\n\t\t\tle16_to_cpu(mpll_parameters.ulFbDiv.usFbDiv);\n\t\tmpll_param->mpll_post_divider =\n\t\t\t(uint32_t)mpll_parameters.ucPostDiv;\n\t\tmpll_param->vco_mode =\n\t\t\t(uint32_t)(mpll_parameters.ucPllCntlFlag &\n\t\t\t\t\tMPLL_CNTL_FLAG_VCO_MODE_MASK);\n\t\tmpll_param->yclk_sel =\n\t\t\t(uint32_t)((mpll_parameters.ucPllCntlFlag &\n\t\t\t\t\t\tMPLL_CNTL_FLAG_BYPASS_DQ_PLL) ? 1 : 0);\n\t\tmpll_param->qdr =\n\t\t\t(uint32_t)((mpll_parameters.ucPllCntlFlag &\n\t\t\t\t\t\tMPLL_CNTL_FLAG_QDR_ENABLE) ? 1 : 0);\n\t\tmpll_param->half_rate =\n\t\t\t(uint32_t)((mpll_parameters.ucPllCntlFlag &\n\t\t\t\t\t\tMPLL_CNTL_FLAG_AD_HALF_RATE) ? 1 : 0);\n\t\tmpll_param->dll_speed =\n\t\t\t(uint32_t)(mpll_parameters.ucDllSpeed);\n\t\tmpll_param->bw_ctrl =\n\t\t\t(uint32_t)(mpll_parameters.ucBWCntl);\n\t}\n\n\treturn result;\n}\n\n \nint atomctrl_get_memory_pll_dividers_vi(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_value, pp_atomctrl_memory_clock_param *mpll_param)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_2 mpll_parameters;\n\tint result;\n\n\tmpll_parameters.ulClock.ulClock = cpu_to_le32(clock_value);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam),\n\t\t\t(uint32_t *)&mpll_parameters);\n\n\tif (!result)\n\t\tmpll_param->mpll_post_divider =\n\t\t\t\t(uint32_t)mpll_parameters.ulClock.ucPostDiv;\n\n\treturn result;\n}\n\nint atomctrl_get_memory_pll_dividers_ai(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t clock_value,\n\t\t\t\t\tpp_atomctrl_memory_clock_param_ai *mpll_param)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_3 mpll_parameters = {{0}, 0, 0};\n\tint result;\n\n\tmpll_parameters.ulClock.ulClock = cpu_to_le32(clock_value);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam),\n\t\t\t(uint32_t *)&mpll_parameters);\n\n\t \n\tudelay(10);\n\n\tif (!result) {\n\t\tmpll_param->ulMclk_fcw_int =\n\t\t\tle16_to_cpu(mpll_parameters.usMclk_fcw_int);\n\t\tmpll_param->ulMclk_fcw_frac =\n\t\t\tle16_to_cpu(mpll_parameters.usMclk_fcw_frac);\n\t\tmpll_param->ulClock =\n\t\t\tle32_to_cpu(mpll_parameters.ulClock.ulClock);\n\t\tmpll_param->ulPostDiv = mpll_parameters.ulClock.ucPostDiv;\n\t}\n\n\treturn result;\n}\n\nint atomctrl_get_engine_pll_dividers_kong(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t  uint32_t clock_value,\n\t\t\t\t\t  pp_atomctrl_clock_dividers_kong *dividers)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V4 pll_parameters;\n\tint result;\n\n\tpll_parameters.ulClock = cpu_to_le32(clock_value);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\n\t\t(uint32_t *)&pll_parameters);\n\n\tif (0 == result) {\n\t\tdividers->pll_post_divider = pll_parameters.ucPostDiv;\n\t\tdividers->real_clock = le32_to_cpu(pll_parameters.ulClock);\n\t}\n\n\treturn result;\n}\n\nint atomctrl_get_engine_pll_dividers_vi(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_value,\n\t\tpp_atomctrl_clock_dividers_vi *dividers)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 pll_patameters;\n\tint result;\n\n\tpll_patameters.ulClock.ulClock = cpu_to_le32(clock_value);\n\tpll_patameters.ulClock.ucPostDiv = COMPUTE_GPUCLK_INPUT_FLAG_SCLK;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\n\t\t(uint32_t *)&pll_patameters);\n\n\tif (0 == result) {\n\t\tdividers->pll_post_divider =\n\t\t\tpll_patameters.ulClock.ucPostDiv;\n\t\tdividers->real_clock =\n\t\t\tle32_to_cpu(pll_patameters.ulClock.ulClock);\n\n\t\tdividers->ul_fb_div.ul_fb_div_frac =\n\t\t\tle16_to_cpu(pll_patameters.ulFbDiv.usFbDivFrac);\n\t\tdividers->ul_fb_div.ul_fb_div =\n\t\t\tle16_to_cpu(pll_patameters.ulFbDiv.usFbDiv);\n\n\t\tdividers->uc_pll_ref_div =\n\t\t\tpll_patameters.ucPllRefDiv;\n\t\tdividers->uc_pll_post_div =\n\t\t\tpll_patameters.ucPllPostDiv;\n\t\tdividers->uc_pll_cntl_flag =\n\t\t\tpll_patameters.ucPllCntlFlag;\n\t}\n\n\treturn result;\n}\n\nint atomctrl_get_engine_pll_dividers_ai(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_value,\n\t\tpp_atomctrl_clock_dividers_ai *dividers)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_7 pll_patameters;\n\tint result;\n\n\tpll_patameters.ulClock.ulClock = cpu_to_le32(clock_value);\n\tpll_patameters.ulClock.ucPostDiv = COMPUTE_GPUCLK_INPUT_FLAG_SCLK;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\n\t\t(uint32_t *)&pll_patameters);\n\n\tif (0 == result) {\n\t\tdividers->usSclk_fcw_frac     = le16_to_cpu(pll_patameters.usSclk_fcw_frac);\n\t\tdividers->usSclk_fcw_int      = le16_to_cpu(pll_patameters.usSclk_fcw_int);\n\t\tdividers->ucSclkPostDiv       = pll_patameters.ucSclkPostDiv;\n\t\tdividers->ucSclkVcoMode       = pll_patameters.ucSclkVcoMode;\n\t\tdividers->ucSclkPllRange      = pll_patameters.ucSclkPllRange;\n\t\tdividers->ucSscEnable         = pll_patameters.ucSscEnable;\n\t\tdividers->usSsc_fcw1_frac     = le16_to_cpu(pll_patameters.usSsc_fcw1_frac);\n\t\tdividers->usSsc_fcw1_int      = le16_to_cpu(pll_patameters.usSsc_fcw1_int);\n\t\tdividers->usPcc_fcw_int       = le16_to_cpu(pll_patameters.usPcc_fcw_int);\n\t\tdividers->usSsc_fcw_slew_frac = le16_to_cpu(pll_patameters.usSsc_fcw_slew_frac);\n\t\tdividers->usPcc_fcw_slew_frac = le16_to_cpu(pll_patameters.usPcc_fcw_slew_frac);\n\t}\n\treturn result;\n}\n\nint atomctrl_get_dfs_pll_dividers_vi(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_value,\n\t\tpp_atomctrl_clock_dividers_vi *dividers)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tCOMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 pll_patameters;\n\tint result;\n\n\tpll_patameters.ulClock.ulClock = cpu_to_le32(clock_value);\n\tpll_patameters.ulClock.ucPostDiv =\n\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\n\t\t(uint32_t *)&pll_patameters);\n\n\tif (0 == result) {\n\t\tdividers->pll_post_divider =\n\t\t\tpll_patameters.ulClock.ucPostDiv;\n\t\tdividers->real_clock =\n\t\t\tle32_to_cpu(pll_patameters.ulClock.ulClock);\n\n\t\tdividers->ul_fb_div.ul_fb_div_frac =\n\t\t\tle16_to_cpu(pll_patameters.ulFbDiv.usFbDivFrac);\n\t\tdividers->ul_fb_div.ul_fb_div =\n\t\t\tle16_to_cpu(pll_patameters.ulFbDiv.usFbDiv);\n\n\t\tdividers->uc_pll_ref_div =\n\t\t\tpll_patameters.ucPllRefDiv;\n\t\tdividers->uc_pll_post_div =\n\t\t\tpll_patameters.ucPllPostDiv;\n\t\tdividers->uc_pll_cntl_flag =\n\t\t\tpll_patameters.ucPllCntlFlag;\n\t}\n\n\treturn result;\n}\n\n \nuint32_t atomctrl_get_reference_clock(struct pp_hwmgr *hwmgr)\n{\n\tATOM_FIRMWARE_INFO *fw_info;\n\tu8 frev, crev;\n\tu16 size;\n\tuint32_t clock;\n\n\tfw_info = (ATOM_FIRMWARE_INFO *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\tGetIndexIntoMasterTable(DATA, FirmwareInfo),\n\t\t\t&size, &frev, &crev);\n\n\tif (fw_info == NULL)\n\t\tclock = 2700;\n\telse\n\t\tclock = (uint32_t)(le16_to_cpu(fw_info->usReferenceClock));\n\n\treturn clock;\n}\n\n \nbool atomctrl_is_voltage_controlled_by_gpio_v3(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type,\n\t\tuint8_t voltage_mode)\n{\n\tATOM_VOLTAGE_OBJECT_INFO_V3_1 *voltage_info =\n\t\t(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *)get_voltage_info_table(hwmgr->adev);\n\tbool ret;\n\n\tPP_ASSERT_WITH_CODE((NULL != voltage_info),\n\t\t\t\"Could not find Voltage Table in BIOS.\", return false;);\n\n\tret = (NULL != atomctrl_lookup_voltage_type_v3\n\t\t\t(voltage_info, voltage_type, voltage_mode)) ? true : false;\n\n\treturn ret;\n}\n\nint atomctrl_get_voltage_table_v3(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type,\n\t\tuint8_t voltage_mode,\n\t\tpp_atomctrl_voltage_table *voltage_table)\n{\n\tATOM_VOLTAGE_OBJECT_INFO_V3_1 *voltage_info =\n\t\t(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *)get_voltage_info_table(hwmgr->adev);\n\tconst ATOM_VOLTAGE_OBJECT_V3 *voltage_object;\n\tunsigned int i;\n\n\tPP_ASSERT_WITH_CODE((NULL != voltage_info),\n\t\t\t\"Could not find Voltage Table in BIOS.\", return -1;);\n\n\tvoltage_object = atomctrl_lookup_voltage_type_v3\n\t\t(voltage_info, voltage_type, voltage_mode);\n\n\tif (voltage_object == NULL)\n\t\treturn -1;\n\n\tPP_ASSERT_WITH_CODE(\n\t\t\t(voltage_object->asGpioVoltageObj.ucGpioEntryNum <=\n\t\t\tPP_ATOMCTRL_MAX_VOLTAGE_ENTRIES),\n\t\t\t\"Too many voltage entries!\",\n\t\t\treturn -1;\n\t\t\t);\n\n\tfor (i = 0; i < voltage_object->asGpioVoltageObj.ucGpioEntryNum; i++) {\n\t\tvoltage_table->entries[i].value =\n\t\t\tle16_to_cpu(voltage_object->asGpioVoltageObj.asVolGpioLut[i].usVoltageValue);\n\t\tvoltage_table->entries[i].smio_low =\n\t\t\tle32_to_cpu(voltage_object->asGpioVoltageObj.asVolGpioLut[i].ulVoltageId);\n\t}\n\n\tvoltage_table->mask_low    =\n\t\tle32_to_cpu(voltage_object->asGpioVoltageObj.ulGpioMaskVal);\n\tvoltage_table->count      =\n\t\tvoltage_object->asGpioVoltageObj.ucGpioEntryNum;\n\tvoltage_table->phase_delay =\n\t\tvoltage_object->asGpioVoltageObj.ucPhaseDelay;\n\n\treturn 0;\n}\n\nstatic bool atomctrl_lookup_gpio_pin(\n\t\tATOM_GPIO_PIN_LUT * gpio_lookup_table,\n\t\tconst uint32_t pinId,\n\t\tpp_atomctrl_gpio_pin_assignment *gpio_pin_assignment)\n{\n\tunsigned int size = le16_to_cpu(gpio_lookup_table->sHeader.usStructureSize);\n\tunsigned int offset = offsetof(ATOM_GPIO_PIN_LUT, asGPIO_Pin[0]);\n\tuint8_t *start = (uint8_t *)gpio_lookup_table;\n\n\twhile (offset < size) {\n\t\tconst ATOM_GPIO_PIN_ASSIGNMENT *pin_assignment =\n\t\t\t(const ATOM_GPIO_PIN_ASSIGNMENT *)(start + offset);\n\n\t\tif (pinId == pin_assignment->ucGPIO_ID) {\n\t\t\tgpio_pin_assignment->uc_gpio_pin_bit_shift =\n\t\t\t\tpin_assignment->ucGpioPinBitShift;\n\t\t\tgpio_pin_assignment->us_gpio_pin_aindex =\n\t\t\t\tle16_to_cpu(pin_assignment->usGpioPin_AIndex);\n\t\t\treturn true;\n\t\t}\n\n\t\toffset += offsetof(ATOM_GPIO_PIN_ASSIGNMENT, ucGPIO_ID) + 1;\n\t}\n\n\treturn false;\n}\n\n \nstatic ATOM_GPIO_PIN_LUT *get_gpio_lookup_table(void *device)\n{\n\tu8 frev, crev;\n\tu16 size;\n\tvoid *table_address;\n\n\ttable_address = (ATOM_GPIO_PIN_LUT *)\n\t\tsmu_atom_get_data_table(device,\n\t\t\t\tGetIndexIntoMasterTable(DATA, GPIO_Pin_LUT),\n\t\t\t\t&size, &frev, &crev);\n\n\tPP_ASSERT_WITH_CODE((NULL != table_address),\n\t\t\t\"Error retrieving BIOS Table Address!\", return NULL;);\n\n\treturn (ATOM_GPIO_PIN_LUT *)table_address;\n}\n\n \nbool atomctrl_get_pp_assign_pin(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst uint32_t pinId,\n\t\tpp_atomctrl_gpio_pin_assignment *gpio_pin_assignment)\n{\n\tbool bRet = false;\n\tATOM_GPIO_PIN_LUT *gpio_lookup_table =\n\t\tget_gpio_lookup_table(hwmgr->adev);\n\n\tPP_ASSERT_WITH_CODE((NULL != gpio_lookup_table),\n\t\t\t\"Could not find GPIO lookup Table in BIOS.\", return false);\n\n\tbRet = atomctrl_lookup_gpio_pin(gpio_lookup_table, pinId,\n\t\tgpio_pin_assignment);\n\n\treturn bRet;\n}\n\nint atomctrl_calculate_voltage_evv_on_sclk(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type,\n\t\tuint32_t sclk,\n\t\tuint16_t virtual_voltage_Id,\n\t\tuint16_t *voltage,\n\t\tuint16_t dpm_level,\n\t\tbool debug)\n{\n\tATOM_ASIC_PROFILING_INFO_V3_4 *getASICProfilingInfo;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tEFUSE_LINEAR_FUNC_PARAM sRO_fuse;\n\tEFUSE_LINEAR_FUNC_PARAM sCACm_fuse;\n\tEFUSE_LINEAR_FUNC_PARAM sCACb_fuse;\n\tEFUSE_LOGISTIC_FUNC_PARAM sKt_Beta_fuse;\n\tEFUSE_LOGISTIC_FUNC_PARAM sKv_m_fuse;\n\tEFUSE_LOGISTIC_FUNC_PARAM sKv_b_fuse;\n\tEFUSE_INPUT_PARAMETER sInput_FuseValues;\n\tREAD_EFUSE_VALUE_PARAMETER sOutput_FuseValues;\n\n\tuint32_t ul_RO_fused, ul_CACb_fused, ul_CACm_fused, ul_Kt_Beta_fused, ul_Kv_m_fused, ul_Kv_b_fused;\n\tfInt fSM_A0, fSM_A1, fSM_A2, fSM_A3, fSM_A4, fSM_A5, fSM_A6, fSM_A7;\n\tfInt fMargin_RO_a, fMargin_RO_b, fMargin_RO_c, fMargin_fixed, fMargin_FMAX_mean, fMargin_Plat_mean, fMargin_FMAX_sigma, fMargin_Plat_sigma, fMargin_DC_sigma;\n\tfInt fLkg_FT, repeat;\n\tfInt fMicro_FMAX, fMicro_CR, fSigma_FMAX, fSigma_CR, fSigma_DC, fDC_SCLK, fSquared_Sigma_DC, fSquared_Sigma_CR, fSquared_Sigma_FMAX;\n\tfInt fRLL_LoadLine, fDerateTDP, fVDDC_base, fA_Term, fC_Term, fB_Term, fRO_DC_margin;\n\tfInt fRO_fused, fCACm_fused, fCACb_fused, fKv_m_fused, fKv_b_fused, fKt_Beta_fused, fFT_Lkg_V0NORM;\n\tfInt fSclk_margin, fSclk, fEVV_V;\n\tfInt fV_min, fV_max, fT_prod, fLKG_Factor, fT_FT, fV_FT, fV_x, fTDP_Power, fTDP_Power_right, fTDP_Power_left, fTDP_Current, fV_NL;\n\tuint32_t ul_FT_Lkg_V0NORM;\n\tfInt fLn_MaxDivMin, fMin, fAverage, fRange;\n\tfInt fRoots[2];\n\tfInt fStepSize = GetScaledFraction(625, 100000);\n\n\tint result;\n\n\tgetASICProfilingInfo = (ATOM_ASIC_PROFILING_INFO_V3_4 *)\n\t\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tGetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo),\n\t\t\t\t\tNULL, NULL, NULL);\n\n\tif (!getASICProfilingInfo)\n\t\treturn -1;\n\n\tif (getASICProfilingInfo->asHeader.ucTableFormatRevision < 3 ||\n\t    (getASICProfilingInfo->asHeader.ucTableFormatRevision == 3 &&\n\t     getASICProfilingInfo->asHeader.ucTableContentRevision < 4))\n\t\treturn -1;\n\n\t \n\tfRLL_LoadLine = Divide(getASICProfilingInfo->ulLoadLineSlop, 1000);\n\n\tswitch (dpm_level) {\n\tcase 1:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM1), 1000);\n\t\tbreak;\n\tcase 2:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM2), 1000);\n\t\tbreak;\n\tcase 3:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM3), 1000);\n\t\tbreak;\n\tcase 4:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM4), 1000);\n\t\tbreak;\n\tcase 5:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM5), 1000);\n\t\tbreak;\n\tcase 6:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM6), 1000);\n\t\tbreak;\n\tcase 7:\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM7), 1000);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"DPM Level not supported\\n\");\n\t\tfDerateTDP = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulTdpDerateDPM0), 1000);\n\t}\n\n\t \n\t \n\tsRO_fuse = getASICProfilingInfo->sRoFuse;\n\n\tsInput_FuseValues.usEfuseIndex = sRO_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sRO_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sRO_fuse.ucEfuseLength;\n\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\t \n\tul_RO_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfMin = GetScaledFraction(le32_to_cpu(sRO_fuse.ulEfuseMin), 1);\n\tfRange = GetScaledFraction(le32_to_cpu(sRO_fuse.ulEfuseEncodeRange), 1);\n\tfRO_fused = fDecodeLinearFuse(ul_RO_fused, fMin, fRange, sRO_fuse.ucEfuseLength);\n\n\tsCACm_fuse = getASICProfilingInfo->sCACm;\n\n\tsInput_FuseValues.usEfuseIndex = sCACm_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sCACm_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sCACm_fuse.ucEfuseLength;\n\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\tul_CACm_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfMin = GetScaledFraction(le32_to_cpu(sCACm_fuse.ulEfuseMin), 1000);\n\tfRange = GetScaledFraction(le32_to_cpu(sCACm_fuse.ulEfuseEncodeRange), 1000);\n\n\tfCACm_fused = fDecodeLinearFuse(ul_CACm_fused, fMin, fRange, sCACm_fuse.ucEfuseLength);\n\n\tsCACb_fuse = getASICProfilingInfo->sCACb;\n\n\tsInput_FuseValues.usEfuseIndex = sCACb_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sCACb_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sCACb_fuse.ucEfuseLength;\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\tul_CACb_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfMin = GetScaledFraction(le32_to_cpu(sCACb_fuse.ulEfuseMin), 1000);\n\tfRange = GetScaledFraction(le32_to_cpu(sCACb_fuse.ulEfuseEncodeRange), 1000);\n\n\tfCACb_fused = fDecodeLinearFuse(ul_CACb_fused, fMin, fRange, sCACb_fuse.ucEfuseLength);\n\n\tsKt_Beta_fuse = getASICProfilingInfo->sKt_b;\n\n\tsInput_FuseValues.usEfuseIndex = sKt_Beta_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sKt_Beta_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sKt_Beta_fuse.ucEfuseLength;\n\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\tul_Kt_Beta_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfAverage = GetScaledFraction(le32_to_cpu(sKt_Beta_fuse.ulEfuseEncodeAverage), 1000);\n\tfRange = GetScaledFraction(le32_to_cpu(sKt_Beta_fuse.ulEfuseEncodeRange), 1000);\n\n\tfKt_Beta_fused = fDecodeLogisticFuse(ul_Kt_Beta_fused,\n\t\t\tfAverage, fRange, sKt_Beta_fuse.ucEfuseLength);\n\n\tsKv_m_fuse = getASICProfilingInfo->sKv_m;\n\n\tsInput_FuseValues.usEfuseIndex = sKv_m_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sKv_m_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sKv_m_fuse.ucEfuseLength;\n\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\tif (result)\n\t\treturn result;\n\n\tul_Kv_m_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfAverage = GetScaledFraction(le32_to_cpu(sKv_m_fuse.ulEfuseEncodeAverage), 1000);\n\tfRange = GetScaledFraction((le32_to_cpu(sKv_m_fuse.ulEfuseEncodeRange) & 0x7fffffff), 1000);\n\tfRange = fMultiply(fRange, ConvertToFraction(-1));\n\n\tfKv_m_fused = fDecodeLogisticFuse(ul_Kv_m_fused,\n\t\t\tfAverage, fRange, sKv_m_fuse.ucEfuseLength);\n\n\tsKv_b_fuse = getASICProfilingInfo->sKv_b;\n\n\tsInput_FuseValues.usEfuseIndex = sKv_b_fuse.usEfuseIndex;\n\tsInput_FuseValues.ucBitShift = sKv_b_fuse.ucEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = sKv_b_fuse.ucEfuseLength;\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\tul_Kv_b_fused = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfAverage = GetScaledFraction(le32_to_cpu(sKv_b_fuse.ulEfuseEncodeAverage), 1000);\n\tfRange = GetScaledFraction(le32_to_cpu(sKv_b_fuse.ulEfuseEncodeRange), 1000);\n\n\tfKv_b_fused = fDecodeLogisticFuse(ul_Kv_b_fused,\n\t\t\tfAverage, fRange, sKv_b_fuse.ucEfuseLength);\n\n\t \n\t \n\n\tsInput_FuseValues.usEfuseIndex = getASICProfilingInfo->usLkgEuseIndex;\n\tsInput_FuseValues.ucBitShift = getASICProfilingInfo->ucLkgEfuseBitLSB;\n\tsInput_FuseValues.ucBitLength = getASICProfilingInfo->ucLkgEfuseLength;\n\n\tsOutput_FuseValues.sEfuse = sInput_FuseValues;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&sOutput_FuseValues);\n\n\tif (result)\n\t\treturn result;\n\n\tul_FT_Lkg_V0NORM = le32_to_cpu(sOutput_FuseValues.ulEfuseValue);\n\tfLn_MaxDivMin = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulLkgEncodeLn_MaxDivMin), 10000);\n\tfMin = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulLkgEncodeMin), 10000);\n\n\tfFT_Lkg_V0NORM = fDecodeLeakageID(ul_FT_Lkg_V0NORM,\n\t\t\tfLn_MaxDivMin, fMin, getASICProfilingInfo->ucLkgEfuseLength);\n\tfLkg_FT = fFT_Lkg_V0NORM;\n\n\t \n\tfSM_A0 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A0), 1000000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A0_sign)));\n\tfSM_A1 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A1), 1000000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A1_sign)));\n\tfSM_A2 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A2), 100000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A2_sign)));\n\tfSM_A3 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A3), 1000000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A3_sign)));\n\tfSM_A4 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A4), 1000000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A4_sign)));\n\tfSM_A5 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A5), 1000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A5_sign)));\n\tfSM_A6 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A6), 1000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A6_sign)));\n\tfSM_A7 = fMultiply(GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulSM_A7), 1000),\n\t\t\tConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A7_sign)));\n\n\tfMargin_RO_a = ConvertToFraction(le32_to_cpu(getASICProfilingInfo->ulMargin_RO_a));\n\tfMargin_RO_b = ConvertToFraction(le32_to_cpu(getASICProfilingInfo->ulMargin_RO_b));\n\tfMargin_RO_c = ConvertToFraction(le32_to_cpu(getASICProfilingInfo->ulMargin_RO_c));\n\n\tfMargin_fixed = ConvertToFraction(le32_to_cpu(getASICProfilingInfo->ulMargin_fixed));\n\n\tfMargin_FMAX_mean = GetScaledFraction(\n\t\tle32_to_cpu(getASICProfilingInfo->ulMargin_Fmax_mean), 10000);\n\tfMargin_Plat_mean = GetScaledFraction(\n\t\tle32_to_cpu(getASICProfilingInfo->ulMargin_plat_mean), 10000);\n\tfMargin_FMAX_sigma = GetScaledFraction(\n\t\tle32_to_cpu(getASICProfilingInfo->ulMargin_Fmax_sigma), 10000);\n\tfMargin_Plat_sigma = GetScaledFraction(\n\t\tle32_to_cpu(getASICProfilingInfo->ulMargin_plat_sigma), 10000);\n\n\tfMargin_DC_sigma = GetScaledFraction(\n\t\tle32_to_cpu(getASICProfilingInfo->ulMargin_DC_sigma), 100);\n\tfMargin_DC_sigma = fDivide(fMargin_DC_sigma, ConvertToFraction(1000));\n\n\tfCACm_fused = fDivide(fCACm_fused, ConvertToFraction(100));\n\tfCACb_fused = fDivide(fCACb_fused, ConvertToFraction(100));\n\tfKt_Beta_fused = fDivide(fKt_Beta_fused, ConvertToFraction(100));\n\tfKv_m_fused =  fNegate(fDivide(fKv_m_fused, ConvertToFraction(100)));\n\tfKv_b_fused = fDivide(fKv_b_fused, ConvertToFraction(10));\n\n\tfSclk = GetScaledFraction(sclk, 100);\n\n\tfV_max = fDivide(GetScaledFraction(\n\t\t\t\t le32_to_cpu(getASICProfilingInfo->ulMaxVddc), 1000), ConvertToFraction(4));\n\tfT_prod = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulBoardCoreTemp), 10);\n\tfLKG_Factor = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulEvvLkgFactor), 100);\n\tfT_FT = GetScaledFraction(le32_to_cpu(getASICProfilingInfo->ulLeakageTemp), 10);\n\tfV_FT = fDivide(GetScaledFraction(\n\t\t\t\tle32_to_cpu(getASICProfilingInfo->ulLeakageVoltage), 1000), ConvertToFraction(4));\n\tfV_min = fDivide(GetScaledFraction(\n\t\t\t\t le32_to_cpu(getASICProfilingInfo->ulMinVddc), 1000), ConvertToFraction(4));\n\n\t \n\n\tfA_Term = fAdd(fMargin_RO_a, fAdd(fMultiply(fSM_A4, fSclk), fSM_A5));\n\tfB_Term = fAdd(fAdd(fMultiply(fSM_A2, fSclk), fSM_A6), fMargin_RO_b);\n\tfC_Term = fAdd(fMargin_RO_c,\n\t\t\tfAdd(fMultiply(fSM_A0, fLkg_FT),\n\t\t\tfAdd(fMultiply(fSM_A1, fMultiply(fLkg_FT, fSclk)),\n\t\t\tfAdd(fMultiply(fSM_A3, fSclk),\n\t\t\tfSubtract(fSM_A7, fRO_fused)))));\n\n\tfVDDC_base = fSubtract(fRO_fused,\n\t\t\tfSubtract(fMargin_RO_c,\n\t\t\t\t\tfSubtract(fSM_A3, fMultiply(fSM_A1, fSclk))));\n\tfVDDC_base = fDivide(fVDDC_base, fAdd(fMultiply(fSM_A0, fSclk), fSM_A2));\n\n\trepeat = fSubtract(fVDDC_base,\n\t\t\tfDivide(fMargin_DC_sigma, ConvertToFraction(1000)));\n\n\tfRO_DC_margin = fAdd(fMultiply(fMargin_RO_a,\n\t\t\tfGetSquare(repeat)),\n\t\t\tfAdd(fMultiply(fMargin_RO_b, repeat),\n\t\t\tfMargin_RO_c));\n\n\tfDC_SCLK = fSubtract(fRO_fused,\n\t\t\tfSubtract(fRO_DC_margin,\n\t\t\tfSubtract(fSM_A3,\n\t\t\tfMultiply(fSM_A2, repeat))));\n\tfDC_SCLK = fDivide(fDC_SCLK, fAdd(fMultiply(fSM_A0, repeat), fSM_A1));\n\n\tfSigma_DC = fSubtract(fSclk, fDC_SCLK);\n\n\tfMicro_FMAX = fMultiply(fSclk, fMargin_FMAX_mean);\n\tfMicro_CR = fMultiply(fSclk, fMargin_Plat_mean);\n\tfSigma_FMAX = fMultiply(fSclk, fMargin_FMAX_sigma);\n\tfSigma_CR = fMultiply(fSclk, fMargin_Plat_sigma);\n\n\tfSquared_Sigma_DC = fGetSquare(fSigma_DC);\n\tfSquared_Sigma_CR = fGetSquare(fSigma_CR);\n\tfSquared_Sigma_FMAX = fGetSquare(fSigma_FMAX);\n\n\tfSclk_margin = fAdd(fMicro_FMAX,\n\t\t\tfAdd(fMicro_CR,\n\t\t\tfAdd(fMargin_fixed,\n\t\t\tfSqrt(fAdd(fSquared_Sigma_FMAX,\n\t\t\tfAdd(fSquared_Sigma_DC, fSquared_Sigma_CR))))));\n\t \n\n\tfA_Term = fAdd(fMultiply(fSM_A4, fAdd(fSclk, fSclk_margin)), fSM_A5);\n\tfB_Term = fAdd(fMultiply(fSM_A2, fAdd(fSclk, fSclk_margin)), fSM_A6);\n\tfC_Term = fAdd(fRO_DC_margin,\n\t\t\tfAdd(fMultiply(fSM_A0, fLkg_FT),\n\t\t\tfAdd(fMultiply(fMultiply(fSM_A1, fLkg_FT),\n\t\t\tfAdd(fSclk, fSclk_margin)),\n\t\t\tfAdd(fMultiply(fSM_A3,\n\t\t\tfAdd(fSclk, fSclk_margin)),\n\t\t\tfSubtract(fSM_A7, fRO_fused)))));\n\n\tSolveQuadracticEqn(fA_Term, fB_Term, fC_Term, fRoots);\n\n\tif (GreaterThan(fRoots[0], fRoots[1]))\n\t\tfEVV_V = fRoots[1];\n\telse\n\t\tfEVV_V = fRoots[0];\n\n\tif (GreaterThan(fV_min, fEVV_V))\n\t\tfEVV_V = fV_min;\n\telse if (GreaterThan(fEVV_V, fV_max))\n\t\tfEVV_V = fSubtract(fV_max, fStepSize);\n\n\tfEVV_V = fRoundUpByStepSize(fEVV_V, fStepSize, 0);\n\n\t \n\n\tfV_x = fV_min;\n\n\twhile (GreaterThan(fAdd(fV_max, fStepSize), fV_x)) {\n\t\tfTDP_Power_left = fMultiply(fMultiply(fMultiply(fAdd(\n\t\t\t\tfMultiply(fCACm_fused, fV_x), fCACb_fused), fSclk),\n\t\t\t\tfGetSquare(fV_x)), fDerateTDP);\n\n\t\tfTDP_Power_right = fMultiply(fFT_Lkg_V0NORM, fMultiply(fLKG_Factor,\n\t\t\t\tfMultiply(fExponential(fMultiply(fAdd(fMultiply(fKv_m_fused,\n\t\t\t\tfT_prod), fKv_b_fused), fV_x)), fV_x)));\n\t\tfTDP_Power_right = fMultiply(fTDP_Power_right, fExponential(fMultiply(\n\t\t\t\tfKt_Beta_fused, fT_prod)));\n\t\tfTDP_Power_right = fDivide(fTDP_Power_right, fExponential(fMultiply(\n\t\t\t\tfAdd(fMultiply(fKv_m_fused, fT_prod), fKv_b_fused), fV_FT)));\n\t\tfTDP_Power_right = fDivide(fTDP_Power_right, fExponential(fMultiply(\n\t\t\t\tfKt_Beta_fused, fT_FT)));\n\n\t\tfTDP_Power = fAdd(fTDP_Power_left, fTDP_Power_right);\n\n\t\tfTDP_Current = fDivide(fTDP_Power, fV_x);\n\n\t\tfV_NL = fAdd(fV_x, fDivide(fMultiply(fTDP_Current, fRLL_LoadLine),\n\t\t\t\tConvertToFraction(10)));\n\n\t\tfV_NL = fRoundUpByStepSize(fV_NL, fStepSize, 0);\n\n\t\tif (GreaterThan(fV_max, fV_NL) &&\n\t\t\t(GreaterThan(fV_NL, fEVV_V) ||\n\t\t\tEqual(fV_NL, fEVV_V))) {\n\t\t\tfV_NL = fMultiply(fV_NL, ConvertToFraction(1000));\n\n\t\t\t*voltage = (uint16_t)fV_NL.partial.real;\n\t\t\tbreak;\n\t\t} else\n\t\t\tfV_x = fAdd(fV_x, fStepSize);\n\t}\n\n\treturn result;\n}\n\n \nint atomctrl_get_voltage_evv_on_sclk(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type,\n\t\tuint32_t sclk, uint16_t virtual_voltage_Id,\n\t\tuint16_t *voltage)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tGET_VOLTAGE_INFO_INPUT_PARAMETER_V1_2 get_voltage_info_param_space;\n\tint result;\n\n\tget_voltage_info_param_space.ucVoltageType   =\n\t\tvoltage_type;\n\tget_voltage_info_param_space.ucVoltageMode   =\n\t\tATOM_GET_VOLTAGE_EVV_VOLTAGE;\n\tget_voltage_info_param_space.usVoltageLevel  =\n\t\tcpu_to_le16(virtual_voltage_Id);\n\tget_voltage_info_param_space.ulSCLKFreq      =\n\t\tcpu_to_le32(sclk);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, GetVoltageInfo),\n\t\t\t(uint32_t *)&get_voltage_info_param_space);\n\n\t*voltage = result ? 0 :\n\t\t\tle16_to_cpu(((GET_EVV_VOLTAGE_INFO_OUTPUT_PARAMETER_V1_2 *)\n\t\t\t\t(&get_voltage_info_param_space))->usVoltageLevel);\n\n\treturn result;\n}\n\n \nint atomctrl_get_voltage_evv(struct pp_hwmgr *hwmgr,\n\t\t\t     uint16_t virtual_voltage_id,\n\t\t\t     uint16_t *voltage)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tGET_VOLTAGE_INFO_INPUT_PARAMETER_V1_2 get_voltage_info_param_space;\n\tint result;\n\tint entry_id;\n\n\t \n\tfor (entry_id = 0; entry_id < hwmgr->dyn_state.vddc_dependency_on_sclk->count; entry_id++) {\n\t\tif (hwmgr->dyn_state.vddc_dependency_on_sclk->entries[entry_id].v == virtual_voltage_id) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry_id >= hwmgr->dyn_state.vddc_dependency_on_sclk->count) {\n\t        pr_debug(\"Can't find requested voltage id in vddc_dependency_on_sclk table!\\n\");\n\t        return -EINVAL;\n\t}\n\n\tget_voltage_info_param_space.ucVoltageType = VOLTAGE_TYPE_VDDC;\n\tget_voltage_info_param_space.ucVoltageMode = ATOM_GET_VOLTAGE_EVV_VOLTAGE;\n\tget_voltage_info_param_space.usVoltageLevel = virtual_voltage_id;\n\tget_voltage_info_param_space.ulSCLKFreq =\n\t\tcpu_to_le32(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[entry_id].clk);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, GetVoltageInfo),\n\t\t\t(uint32_t *)&get_voltage_info_param_space);\n\n\tif (0 != result)\n\t\treturn result;\n\n\t*voltage = le16_to_cpu(((GET_EVV_VOLTAGE_INFO_OUTPUT_PARAMETER_V1_2 *)\n\t\t\t\t(&get_voltage_info_param_space))->usVoltageLevel);\n\n\treturn result;\n}\n\n \nuint32_t atomctrl_get_mpll_reference_clock(struct pp_hwmgr *hwmgr)\n{\n\tATOM_COMMON_TABLE_HEADER *fw_info;\n\tuint32_t clock;\n\tu8 frev, crev;\n\tu16 size;\n\n\tfw_info = (ATOM_COMMON_TABLE_HEADER *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tGetIndexIntoMasterTable(DATA, FirmwareInfo),\n\t\t\t\t&size, &frev, &crev);\n\n\tif (fw_info == NULL)\n\t\tclock = 2700;\n\telse {\n\t\tif ((fw_info->ucTableFormatRevision == 2) &&\n\t\t\t(le16_to_cpu(fw_info->usStructureSize) >= sizeof(ATOM_FIRMWARE_INFO_V2_1))) {\n\t\t\tATOM_FIRMWARE_INFO_V2_1 *fwInfo_2_1 =\n\t\t\t\t(ATOM_FIRMWARE_INFO_V2_1 *)fw_info;\n\t\t\tclock = (uint32_t)(le16_to_cpu(fwInfo_2_1->usMemoryReferenceClock));\n\t\t} else {\n\t\t\tATOM_FIRMWARE_INFO *fwInfo_0_0 =\n\t\t\t\t(ATOM_FIRMWARE_INFO *)fw_info;\n\t\t\tclock = (uint32_t)(le16_to_cpu(fwInfo_0_0->usReferenceClock));\n\t\t}\n\t}\n\n\treturn clock;\n}\n\n \nstatic ATOM_ASIC_INTERNAL_SS_INFO *asic_internal_ss_get_ss_table(void *device)\n{\n\tATOM_ASIC_INTERNAL_SS_INFO *table = NULL;\n\tu8 frev, crev;\n\tu16 size;\n\n\ttable = (ATOM_ASIC_INTERNAL_SS_INFO *)\n\t\tsmu_atom_get_data_table(device,\n\t\t\tGetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info),\n\t\t\t&size, &frev, &crev);\n\n\treturn table;\n}\n\nbool atomctrl_is_asic_internal_ss_supported(struct pp_hwmgr *hwmgr)\n{\n\tATOM_ASIC_INTERNAL_SS_INFO *table =\n\t\tasic_internal_ss_get_ss_table(hwmgr->adev);\n\n\tif (table)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic int asic_internal_ss_get_ss_asignment(struct pp_hwmgr *hwmgr,\n\t\tconst uint8_t clockSource,\n\t\tconst uint32_t clockSpeed,\n\t\tpp_atomctrl_internal_ss_info *ssEntry)\n{\n\tATOM_ASIC_INTERNAL_SS_INFO *table;\n\tATOM_ASIC_SS_ASSIGNMENT *ssInfo;\n\tint entry_found = 0;\n\n\tmemset(ssEntry, 0x00, sizeof(pp_atomctrl_internal_ss_info));\n\n\ttable = asic_internal_ss_get_ss_table(hwmgr->adev);\n\n\tif (NULL == table)\n\t\treturn -1;\n\n\tssInfo = &table->asSpreadSpectrum[0];\n\n\twhile (((uint8_t *)ssInfo - (uint8_t *)table) <\n\t\tle16_to_cpu(table->sHeader.usStructureSize)) {\n\t\tif ((clockSource == ssInfo->ucClockIndication) &&\n\t\t\t((uint32_t)clockSpeed <= le32_to_cpu(ssInfo->ulTargetClockRange))) {\n\t\t\tentry_found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tssInfo = (ATOM_ASIC_SS_ASSIGNMENT *)((uint8_t *)ssInfo +\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT));\n\t}\n\n\tif (entry_found) {\n\t\tssEntry->speed_spectrum_percentage =\n\t\t\tle16_to_cpu(ssInfo->usSpreadSpectrumPercentage);\n\t\tssEntry->speed_spectrum_rate = le16_to_cpu(ssInfo->usSpreadRateInKhz);\n\n\t\tif (((GET_DATA_TABLE_MAJOR_REVISION(table) == 2) &&\n\t\t\t(GET_DATA_TABLE_MINOR_REVISION(table) >= 2)) ||\n\t\t\t(GET_DATA_TABLE_MAJOR_REVISION(table) == 3)) {\n\t\t\tssEntry->speed_spectrum_rate /= 100;\n\t\t}\n\n\t\tswitch (ssInfo->ucSpreadSpectrumMode) {\n\t\tcase 0:\n\t\t\tssEntry->speed_spectrum_mode =\n\t\t\t\tpp_atomctrl_spread_spectrum_mode_down;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tssEntry->speed_spectrum_mode =\n\t\t\t\tpp_atomctrl_spread_spectrum_mode_center;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tssEntry->speed_spectrum_mode =\n\t\t\t\tpp_atomctrl_spread_spectrum_mode_down;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn entry_found ? 0 : 1;\n}\n\n \nint atomctrl_get_memory_clock_spread_spectrum(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst uint32_t memory_clock,\n\t\tpp_atomctrl_internal_ss_info *ssInfo)\n{\n\treturn asic_internal_ss_get_ss_asignment(hwmgr,\n\t\t\tASIC_INTERNAL_MEMORY_SS, memory_clock, ssInfo);\n}\n\n \nint atomctrl_get_engine_clock_spread_spectrum(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst uint32_t engine_clock,\n\t\tpp_atomctrl_internal_ss_info *ssInfo)\n{\n\treturn asic_internal_ss_get_ss_asignment(hwmgr,\n\t\t\tASIC_INTERNAL_ENGINE_SS, engine_clock, ssInfo);\n}\n\nint atomctrl_read_efuse(struct pp_hwmgr *hwmgr, uint16_t start_index,\n\t\tuint16_t end_index, uint32_t *efuse)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t mask;\n\tint result;\n\tREAD_EFUSE_VALUE_PARAMETER efuse_param;\n\n\tif ((end_index - start_index)  == 31)\n\t\tmask = 0xFFFFFFFF;\n\telse\n\t\tmask = (1 << ((end_index - start_index) + 1)) - 1;\n\n\tefuse_param.sEfuse.usEfuseIndex = cpu_to_le16((start_index / 32) * 4);\n\tefuse_param.sEfuse.ucBitShift = (uint8_t)\n\t\t\t(start_index - ((start_index / 32) * 32));\n\tefuse_param.sEfuse.ucBitLength  = (uint8_t)\n\t\t\t((end_index - start_index) + 1);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\n\t\t\t(uint32_t *)&efuse_param);\n\t*efuse = result ? 0 : le32_to_cpu(efuse_param.ulEfuseValue) & mask;\n\n\treturn result;\n}\n\nint atomctrl_set_ac_timing_ai(struct pp_hwmgr *hwmgr, uint32_t memory_clock,\n\t\t\t      uint8_t level)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tDYNAMICE_MEMORY_SETTINGS_PARAMETER_V2_1 memory_clock_parameters;\n\tint result;\n\n\tmemory_clock_parameters.asDPMMCReg.ulClock.ulClockFreq =\n\t\tmemory_clock & SET_CLOCK_FREQ_MASK;\n\tmemory_clock_parameters.asDPMMCReg.ulClock.ulComputeClockFlag =\n\t\tADJUST_MC_SETTING_PARAM;\n\tmemory_clock_parameters.asDPMMCReg.ucMclkDPMState = level;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings),\n\t\t(uint32_t *)&memory_clock_parameters);\n\n\treturn result;\n}\n\nint atomctrl_get_voltage_evv_on_sclk_ai(struct pp_hwmgr *hwmgr, uint8_t voltage_type,\n\t\t\t\tuint32_t sclk, uint16_t virtual_voltage_Id, uint32_t *voltage)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint result;\n\tGET_VOLTAGE_INFO_INPUT_PARAMETER_V1_3 get_voltage_info_param_space;\n\n\tget_voltage_info_param_space.ucVoltageType = voltage_type;\n\tget_voltage_info_param_space.ucVoltageMode = ATOM_GET_VOLTAGE_EVV_VOLTAGE;\n\tget_voltage_info_param_space.usVoltageLevel = cpu_to_le16(virtual_voltage_Id);\n\tget_voltage_info_param_space.ulSCLKFreq = cpu_to_le32(sclk);\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, GetVoltageInfo),\n\t\t\t(uint32_t *)&get_voltage_info_param_space);\n\n\t*voltage = result ? 0 :\n\t\tle32_to_cpu(((GET_EVV_VOLTAGE_INFO_OUTPUT_PARAMETER_V1_3 *)(&get_voltage_info_param_space))->ulVoltageLevel);\n\n\treturn result;\n}\n\nint atomctrl_get_smc_sclk_range_table(struct pp_hwmgr *hwmgr, struct pp_atom_ctrl_sclk_range_table *table)\n{\n\n\tint i;\n\tu8 frev, crev;\n\tu16 size;\n\n\tATOM_SMU_INFO_V2_1 *psmu_info =\n\t\t(ATOM_SMU_INFO_V2_1 *)smu_atom_get_data_table(hwmgr->adev,\n\t\t\tGetIndexIntoMasterTable(DATA, SMU_Info),\n\t\t\t&size, &frev, &crev);\n\n\n\tfor (i = 0; i < psmu_info->ucSclkEntryNum; i++) {\n\t\ttable->entry[i].ucVco_setting = psmu_info->asSclkFcwRangeEntry[i].ucVco_setting;\n\t\ttable->entry[i].ucPostdiv = psmu_info->asSclkFcwRangeEntry[i].ucPostdiv;\n\t\ttable->entry[i].usFcw_pcc =\n\t\t\tle16_to_cpu(psmu_info->asSclkFcwRangeEntry[i].ucFcw_pcc);\n\t\ttable->entry[i].usFcw_trans_upper =\n\t\t\tle16_to_cpu(psmu_info->asSclkFcwRangeEntry[i].ucFcw_trans_upper);\n\t\ttable->entry[i].usRcw_trans_lower =\n\t\t\tle16_to_cpu(psmu_info->asSclkFcwRangeEntry[i].ucRcw_trans_lower);\n\t}\n\n\treturn 0;\n}\n\nint atomctrl_get_vddc_shared_railinfo(struct pp_hwmgr *hwmgr, uint8_t *shared_rail)\n{\n\tATOM_SMU_INFO_V2_1 *psmu_info =\n\t\t(ATOM_SMU_INFO_V2_1 *)smu_atom_get_data_table(hwmgr->adev,\n\t\t\tGetIndexIntoMasterTable(DATA, SMU_Info),\n\t\t\tNULL, NULL, NULL);\n\tif (!psmu_info)\n\t\treturn -1;\n\n\t*shared_rail = psmu_info->ucSharePowerSource;\n\n\treturn 0;\n}\n\nint atomctrl_get_avfs_information(struct pp_hwmgr *hwmgr,\n\t\t\t\t  struct pp_atom_ctrl__avfs_parameters *param)\n{\n\tATOM_ASIC_PROFILING_INFO_V3_6 *profile = NULL;\n\n\tif (param == NULL)\n\t\treturn -EINVAL;\n\n\tprofile = (ATOM_ASIC_PROFILING_INFO_V3_6 *)\n\t\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tGetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo),\n\t\t\t\t\tNULL, NULL, NULL);\n\tif (!profile)\n\t\treturn -1;\n\n\tparam->ulAVFS_meanNsigma_Acontant0 = le32_to_cpu(profile->ulAVFS_meanNsigma_Acontant0);\n\tparam->ulAVFS_meanNsigma_Acontant1 = le32_to_cpu(profile->ulAVFS_meanNsigma_Acontant1);\n\tparam->ulAVFS_meanNsigma_Acontant2 = le32_to_cpu(profile->ulAVFS_meanNsigma_Acontant2);\n\tparam->usAVFS_meanNsigma_DC_tol_sigma = le16_to_cpu(profile->usAVFS_meanNsigma_DC_tol_sigma);\n\tparam->usAVFS_meanNsigma_Platform_mean = le16_to_cpu(profile->usAVFS_meanNsigma_Platform_mean);\n\tparam->usAVFS_meanNsigma_Platform_sigma = le16_to_cpu(profile->usAVFS_meanNsigma_Platform_sigma);\n\tparam->ulGB_VDROOP_TABLE_CKSOFF_a0 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSOFF_a0);\n\tparam->ulGB_VDROOP_TABLE_CKSOFF_a1 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSOFF_a1);\n\tparam->ulGB_VDROOP_TABLE_CKSOFF_a2 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSOFF_a2);\n\tparam->ulGB_VDROOP_TABLE_CKSON_a0 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSON_a0);\n\tparam->ulGB_VDROOP_TABLE_CKSON_a1 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSON_a1);\n\tparam->ulGB_VDROOP_TABLE_CKSON_a2 = le32_to_cpu(profile->ulGB_VDROOP_TABLE_CKSON_a2);\n\tparam->ulAVFSGB_FUSE_TABLE_CKSOFF_m1 = le32_to_cpu(profile->ulAVFSGB_FUSE_TABLE_CKSOFF_m1);\n\tparam->usAVFSGB_FUSE_TABLE_CKSOFF_m2 = le16_to_cpu(profile->usAVFSGB_FUSE_TABLE_CKSOFF_m2);\n\tparam->ulAVFSGB_FUSE_TABLE_CKSOFF_b = le32_to_cpu(profile->ulAVFSGB_FUSE_TABLE_CKSOFF_b);\n\tparam->ulAVFSGB_FUSE_TABLE_CKSON_m1 = le32_to_cpu(profile->ulAVFSGB_FUSE_TABLE_CKSON_m1);\n\tparam->usAVFSGB_FUSE_TABLE_CKSON_m2 = le16_to_cpu(profile->usAVFSGB_FUSE_TABLE_CKSON_m2);\n\tparam->ulAVFSGB_FUSE_TABLE_CKSON_b = le32_to_cpu(profile->ulAVFSGB_FUSE_TABLE_CKSON_b);\n\tparam->usMaxVoltage_0_25mv = le16_to_cpu(profile->usMaxVoltage_0_25mv);\n\tparam->ucEnableGB_VDROOP_TABLE_CKSOFF = profile->ucEnableGB_VDROOP_TABLE_CKSOFF;\n\tparam->ucEnableGB_VDROOP_TABLE_CKSON = profile->ucEnableGB_VDROOP_TABLE_CKSON;\n\tparam->ucEnableGB_FUSE_TABLE_CKSOFF = profile->ucEnableGB_FUSE_TABLE_CKSOFF;\n\tparam->ucEnableGB_FUSE_TABLE_CKSON = profile->ucEnableGB_FUSE_TABLE_CKSON;\n\tparam->usPSM_Age_ComFactor = le16_to_cpu(profile->usPSM_Age_ComFactor);\n\tparam->ucEnableApplyAVFS_CKS_OFF_Voltage = profile->ucEnableApplyAVFS_CKS_OFF_Voltage;\n\n\treturn 0;\n}\n\nint  atomctrl_get_svi2_info(struct pp_hwmgr *hwmgr, uint8_t voltage_type,\n\t\t\t\tuint8_t *svd_gpio_id, uint8_t *svc_gpio_id,\n\t\t\t\tuint16_t *load_line)\n{\n\tATOM_VOLTAGE_OBJECT_INFO_V3_1 *voltage_info =\n\t\t(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *)get_voltage_info_table(hwmgr->adev);\n\n\tconst ATOM_VOLTAGE_OBJECT_V3 *voltage_object;\n\n\tPP_ASSERT_WITH_CODE((NULL != voltage_info),\n\t\t\t\"Could not find Voltage Table in BIOS.\", return -EINVAL);\n\n\tvoltage_object = atomctrl_lookup_voltage_type_v3\n\t\t(voltage_info, voltage_type,  VOLTAGE_OBJ_SVID2);\n\n\t*svd_gpio_id = voltage_object->asSVID2Obj.ucSVDGpioId;\n\t*svc_gpio_id = voltage_object->asSVID2Obj.ucSVCGpioId;\n\t*load_line = voltage_object->asSVID2Obj.usLoadLine_PSI;\n\n\treturn 0;\n}\n\nint atomctrl_get_leakage_id_from_efuse(struct pp_hwmgr *hwmgr, uint16_t *virtual_voltage_id)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tSET_VOLTAGE_PS_ALLOCATION allocation;\n\tSET_VOLTAGE_PARAMETERS_V1_3 *voltage_parameters =\n\t\t\t(SET_VOLTAGE_PARAMETERS_V1_3 *)&allocation.sASICSetVoltage;\n\tint result;\n\n\tvoltage_parameters->ucVoltageMode = ATOM_GET_LEAKAGE_ID;\n\n\tresult = amdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\tGetIndexIntoMasterTable(COMMAND, SetVoltage),\n\t\t\t(uint32_t *)voltage_parameters);\n\n\t*virtual_voltage_id = voltage_parameters->usVoltageLevel;\n\n\treturn result;\n}\n\nint atomctrl_get_leakage_vddc_base_on_leakage(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint16_t *vddc, uint16_t *vddci,\n\t\t\t\t\tuint16_t virtual_voltage_id,\n\t\t\t\t\tuint16_t efuse_voltage_id)\n{\n\tint i, j;\n\tint ix;\n\tu16 *leakage_bin, *vddc_id_buf, *vddc_buf, *vddci_id_buf, *vddci_buf;\n\tATOM_ASIC_PROFILING_INFO_V2_1 *profile;\n\n\t*vddc = 0;\n\t*vddci = 0;\n\n\tix = GetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo);\n\n\tprofile = (ATOM_ASIC_PROFILING_INFO_V2_1 *)\n\t\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tix,\n\t\t\t\t\tNULL, NULL, NULL);\n\tif (!profile)\n\t\treturn -EINVAL;\n\n\tif ((profile->asHeader.ucTableFormatRevision >= 2) &&\n\t\t(profile->asHeader.ucTableContentRevision >= 1) &&\n\t\t(profile->asHeader.usStructureSize >= sizeof(ATOM_ASIC_PROFILING_INFO_V2_1))) {\n\t\tleakage_bin = (u16 *)((char *)profile + profile->usLeakageBinArrayOffset);\n\t\tvddc_id_buf = (u16 *)((char *)profile + profile->usElbVDDC_IdArrayOffset);\n\t\tvddc_buf = (u16 *)((char *)profile + profile->usElbVDDC_LevelArrayOffset);\n\t\tif (profile->ucElbVDDC_Num > 0) {\n\t\t\tfor (i = 0; i < profile->ucElbVDDC_Num; i++) {\n\t\t\t\tif (vddc_id_buf[i] == virtual_voltage_id) {\n\t\t\t\t\tfor (j = 0; j < profile->ucLeakageBinNum; j++) {\n\t\t\t\t\t\tif (efuse_voltage_id <= leakage_bin[j]) {\n\t\t\t\t\t\t\t*vddc = vddc_buf[j * profile->ucElbVDDC_Num + i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvddci_id_buf = (u16 *)((char *)profile + profile->usElbVDDCI_IdArrayOffset);\n\t\tvddci_buf   = (u16 *)((char *)profile + profile->usElbVDDCI_LevelArrayOffset);\n\t\tif (profile->ucElbVDDCI_Num > 0) {\n\t\t\tfor (i = 0; i < profile->ucElbVDDCI_Num; i++) {\n\t\t\t\tif (vddci_id_buf[i] == virtual_voltage_id) {\n\t\t\t\t\tfor (j = 0; j < profile->ucLeakageBinNum; j++) {\n\t\t\t\t\t\tif (efuse_voltage_id <= leakage_bin[j]) {\n\t\t\t\t\t\t\t*vddci = vddci_buf[j * profile->ucElbVDDCI_Num + i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid atomctrl_get_voltage_range(struct pp_hwmgr *hwmgr, uint32_t *max_vddc,\n\t\t\t\t\t\t\tuint32_t *min_vddc)\n{\n\tvoid *profile;\n\n\tprofile = smu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tGetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo),\n\t\t\t\t\tNULL, NULL, NULL);\n\n\tif (profile) {\n\t\tswitch (hwmgr->chip_id) {\n\t\tcase CHIP_TONGA:\n\t\tcase CHIP_FIJI:\n\t\t\t*max_vddc = le32_to_cpu(((ATOM_ASIC_PROFILING_INFO_V3_3 *)profile)->ulMaxVddc) / 4;\n\t\t\t*min_vddc = le32_to_cpu(((ATOM_ASIC_PROFILING_INFO_V3_3 *)profile)->ulMinVddc) / 4;\n\t\t\treturn;\n\t\tcase CHIP_POLARIS11:\n\t\tcase CHIP_POLARIS10:\n\t\tcase CHIP_POLARIS12:\n\t\t\t*max_vddc = le32_to_cpu(((ATOM_ASIC_PROFILING_INFO_V3_6 *)profile)->ulMaxVddc) / 100;\n\t\t\t*min_vddc = le32_to_cpu(((ATOM_ASIC_PROFILING_INFO_V3_6 *)profile)->ulMinVddc) / 100;\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t*max_vddc = 0;\n\t*min_vddc = 0;\n}\n\nint atomctrl_get_edc_hilo_leakage_offset_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t       AtomCtrl_HiLoLeakageOffsetTable *table)\n{\n\tATOM_GFX_INFO_V2_3 *gfxinfo = smu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tGetIndexIntoMasterTable(DATA, GFX_Info),\n\t\t\t\t\tNULL, NULL, NULL);\n\tif (!gfxinfo)\n\t\treturn -ENOENT;\n\n\ttable->usHiLoLeakageThreshold = gfxinfo->usHiLoLeakageThreshold;\n\ttable->usEdcDidtLoDpm7TableOffset = gfxinfo->usEdcDidtLoDpm7TableOffset;\n\ttable->usEdcDidtHiDpm7TableOffset = gfxinfo->usEdcDidtHiDpm7TableOffset;\n\n\treturn 0;\n}\n\nstatic AtomCtrl_EDCLeakgeTable *get_edc_leakage_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t      uint16_t offset)\n{\n\tvoid *table_address;\n\tchar *temp;\n\n\ttable_address = smu_atom_get_data_table(hwmgr->adev,\n\t\t\tGetIndexIntoMasterTable(DATA, GFX_Info),\n\t\t\tNULL, NULL, NULL);\n\tif (!table_address)\n\t\treturn NULL;\n\n\ttemp = (char *)table_address;\n\ttable_address += offset;\n\n\treturn (AtomCtrl_EDCLeakgeTable *)temp;\n}\n\nint atomctrl_get_edc_leakage_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t   AtomCtrl_EDCLeakgeTable *table,\n\t\t\t\t   uint16_t offset)\n{\n\tuint32_t length, i;\n\tAtomCtrl_EDCLeakgeTable *leakage_table =\n\t\tget_edc_leakage_table(hwmgr, offset);\n\n\tif (!leakage_table)\n\t\treturn -ENOENT;\n\n\tlength = sizeof(leakage_table->DIDT_REG) /\n\t\t sizeof(leakage_table->DIDT_REG[0]);\n\tfor (i = 0; i < length; i++)\n\t\ttable->DIDT_REG[i] = leakage_table->DIDT_REG[i];\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}