{
  "module_name": "smu10_smumgr.c",
  "hash_id": "14a5cec9206bcfecf644dc7c59d1ef927317dd700c8b457858726d38e90f9f51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/smu10_smumgr.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"smumgr.h\"\n#include \"smu10_inc.h\"\n#include \"soc15_common.h\"\n#include \"smu10_smumgr.h\"\n#include \"ppatomctrl.h\"\n#include \"rv_ppsmc.h\"\n#include \"smu10_driver_if.h\"\n#include \"smu10.h\"\n#include \"pp_debug.h\"\n\n\n#define BUFFER_SIZE                 80000\n#define MAX_STRING_SIZE             15\n#define BUFFER_SIZETWO              131072\n\n#define MP0_Public                  0x03800000\n#define MP0_SRAM                    0x03900000\n#define MP1_Public                  0x03b00000\n#define MP1_SRAM                    0x03c00004\n\n#define smnMP1_FIRMWARE_FLAGS       0x3010028\n\n\nstatic uint32_t smu10_wait_for_response(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t reg;\n\n\treg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n\n\tphm_wait_for_register_unequal(hwmgr, reg,\n\t\t\t0, MP1_C2PMSG_90__CONTENT_MASK);\n\n\treturn RREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n\nstatic int smu10_send_msg_to_smc_without_waiting(struct pp_hwmgr *hwmgr,\n\t\tuint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_66, msg);\n\n\treturn 0;\n}\n\nstatic uint32_t smu10_read_arg_from_smc(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn RREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_82);\n}\n\nstatic int smu10_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tsmu10_wait_for_response(hwmgr);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90, 0);\n\n\tsmu10_send_msg_to_smc_without_waiting(hwmgr, msg);\n\n\tif (smu10_wait_for_response(hwmgr) == 0)\n\t\tdev_err(adev->dev, \"Failed to send Message %x.\\n\", msg);\n\n\treturn 0;\n}\n\n\nstatic int smu10_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,\n\t\tuint16_t msg, uint32_t parameter)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tsmu10_wait_for_response(hwmgr);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90, 0);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_82, parameter);\n\n\tsmu10_send_msg_to_smc_without_waiting(hwmgr, msg);\n\n\n\tif (smu10_wait_for_response(hwmgr) == 0)\n\t\tdev_err(adev->dev, \"Failed to send Message %x.\\n\", msg);\n\n\treturn 0;\n}\n\nstatic int smu10_copy_table_from_smc(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, int16_t table_id)\n{\n\tstruct smu10_smumgr *priv =\n\t\t\t(struct smu10_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL;);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableSmu2Dram,\n\t\t\tpriv->smu_tables.entry[table_id].table_id,\n\t\t\tNULL);\n\n\tamdgpu_asic_invalidate_hdp(adev, NULL);\n\n\tmemcpy(table, (uint8_t *)priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\treturn 0;\n}\n\nstatic int smu10_copy_table_to_smc(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, int16_t table_id)\n{\n\tstruct smu10_smumgr *priv =\n\t\t\t(struct smu10_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL;);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL;);\n\n\tmemcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\tamdgpu_asic_flush_hdp(adev, NULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableDram2Smu,\n\t\t\tpriv->smu_tables.entry[table_id].table_id,\n\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int smu10_verify_smc_interface(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t smc_driver_if_version;\n\n\tsmum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetDriverIfVersion,\n\t\t\t&smc_driver_if_version);\n\n\tif ((smc_driver_if_version != SMU10_DRIVER_IF_VERSION) &&\n\t    (smc_driver_if_version != SMU10_DRIVER_IF_VERSION + 1)) {\n\t\tpr_err(\"Attempt to read SMC IF Version Number Failed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_smumgr *priv =\n\t\t\t(struct smu10_smumgr *)(hwmgr->smu_backend);\n\n\tif (priv) {\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_WMTABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_CLOCKTABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[SMU10_CLOCKTABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[SMU10_CLOCKTABLE].table);\n\t\tkfree(hwmgr->smu_backend);\n\t\thwmgr->smu_backend = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu10_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetSmuVersion, &hwmgr->smu_version);\n\tadev->pm.fw_version = hwmgr->smu_version >> 8;\n\n\tif (!(adev->apu_flags & AMD_APU_IS_RAVEN2) &&\n\t    (adev->apu_flags & AMD_APU_IS_RAVEN) &&\n\t    adev->pm.fw_version < 0x1e45)\n\t\tadev->pm.pp_feature &= ~PP_GFXOFF_MASK;\n\n\tif (smu10_verify_smc_interface(hwmgr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int smu10_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu10_smumgr *priv;\n\tint r;\n\n\tpriv = kzalloc(sizeof(struct smu10_smumgr), GFP_KERNEL);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = priv;\n\n\t \n\tr = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(Watermarks_t), PAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].handle,\n\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].table);\n\n\tif (r)\n\t\tgoto err0;\n\n\tpriv->smu_tables.entry[SMU10_WMTABLE].version = 0x01;\n\tpriv->smu_tables.entry[SMU10_WMTABLE].size = sizeof(Watermarks_t);\n\tpriv->smu_tables.entry[SMU10_WMTABLE].table_id = TABLE_WATERMARKS;\n\n\t \n\tr = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(DpmClocks_t), PAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t&priv->smu_tables.entry[SMU10_CLOCKTABLE].handle,\n\t\t\t&priv->smu_tables.entry[SMU10_CLOCKTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[SMU10_CLOCKTABLE].table);\n\n\tif (r)\n\t\tgoto err1;\n\n\tpriv->smu_tables.entry[SMU10_CLOCKTABLE].version = 0x01;\n\tpriv->smu_tables.entry[SMU10_CLOCKTABLE].size = sizeof(DpmClocks_t);\n\tpriv->smu_tables.entry[SMU10_CLOCKTABLE].table_id = TABLE_DPMCLOCKS;\n\n\treturn 0;\n\nerr1:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_WMTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[SMU10_WMTABLE].table);\nerr0:\n\tkfree(priv);\n\treturn -EINVAL;\n}\n\nstatic int smu10_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table, uint16_t table_id, bool rw)\n{\n\tint ret;\n\n\tif (rw)\n\t\tret = smu10_copy_table_from_smc(hwmgr, table, table_id);\n\telse\n\t\tret = smu10_copy_table_to_smc(hwmgr, table, table_id);\n\n\treturn ret;\n}\n\n\nconst struct pp_smumgr_func smu10_smu_funcs = {\n\t.name = \"smu10_smu\",\n\t.smu_init = &smu10_smu_init,\n\t.smu_fini = &smu10_smu_fini,\n\t.start_smu = &smu10_start_smu,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = &smu10_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = &smu10_send_msg_to_smc_with_parameter,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.get_argument = smu10_read_arg_from_smc,\n\t.smc_table_manager = smu10_smc_table_manager,\n};\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}