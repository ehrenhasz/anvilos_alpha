{
  "module_name": "smu7_thermal.c",
  "hash_id": "6782e20d48dbc2676adafd2710de5f28d0e45f9bf55f2c6011b14ebbb4d09bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_thermal.c",
  "human_readable_source": " \n\n#include <asm/div64.h>\n#include \"smu7_thermal.h\"\n#include \"smu7_hwmgr.h\"\n#include \"smu7_common.h\"\n\nint smu7_fan_ctrl_get_fan_speed_info(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_fan_speed_info *fan_speed_info)\n{\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\treturn -ENODEV;\n\n\tfan_speed_info->supports_percent_read = true;\n\tfan_speed_info->supports_percent_write = true;\n\tfan_speed_info->min_percent = 0;\n\tfan_speed_info->max_percent = 100;\n\n\tif (PP_CAP(PHM_PlatformCaps_FanSpeedInTableIsRPM) &&\n\t    hwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution) {\n\t\tfan_speed_info->supports_rpm_read = true;\n\t\tfan_speed_info->supports_rpm_write = true;\n\t\tfan_speed_info->min_rpm = hwmgr->thermal_controller.fanInfo.ulMinRPM;\n\t\tfan_speed_info->max_rpm = hwmgr->thermal_controller.fanInfo.ulMaxRPM;\n\t} else {\n\t\tfan_speed_info->min_rpm = 0;\n\t\tfan_speed_info->max_rpm = 0;\n\t}\n\n\treturn 0;\n}\n\nint smu7_fan_ctrl_get_fan_speed_pwm(struct pp_hwmgr *hwmgr,\n\t\tuint32_t *speed)\n{\n\tuint32_t duty100;\n\tuint32_t duty;\n\tuint64_t tmp64;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\treturn -ENODEV;\n\n\tduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tduty = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_STATUS, FDO_PWM_DUTY);\n\n\tif (duty100 == 0)\n\t\treturn -EINVAL;\n\n\n\ttmp64 = (uint64_t)duty * 255;\n\tdo_div(tmp64, duty100);\n\t*speed = MIN((uint32_t)tmp64, 255);\n\n\treturn 0;\n}\n\nint smu7_fan_ctrl_get_fan_speed_rpm(struct pp_hwmgr *hwmgr, uint32_t *speed)\n{\n\tuint32_t tach_period;\n\tuint32_t crystal_clock_freq;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan ||\n\t    !hwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution)\n\t\treturn -ENODEV;\n\n\ttach_period = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_TACH_STATUS, TACH_PERIOD);\n\n\tif (tach_period == 0)\n\t\treturn -EINVAL;\n\n\tcrystal_clock_freq = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\t*speed = 60 * crystal_clock_freq * 10000 / tach_period;\n\n\treturn 0;\n}\n\n \nint smu7_fan_ctrl_set_static_mode(struct pp_hwmgr *hwmgr, uint32_t mode)\n{\n\tif (hwmgr->fan_ctrl_is_in_default_mode) {\n\t\thwmgr->fan_ctrl_default_mode =\n\t\t\t\tPHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\t\tCG_FDO_CTRL2, FDO_PWM_MODE);\n\t\thwmgr->tmin =\n\t\t\t\tPHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t\t\tCG_FDO_CTRL2, TMIN);\n\t\thwmgr->fan_ctrl_is_in_default_mode = false;\n\t}\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL2, TMIN, 0);\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL2, FDO_PWM_MODE, mode);\n\n\treturn 0;\n}\n\n \nint smu7_fan_ctrl_set_default_mode(struct pp_hwmgr *hwmgr)\n{\n\tif (!hwmgr->fan_ctrl_is_in_default_mode) {\n\t\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tCG_FDO_CTRL2, FDO_PWM_MODE, hwmgr->fan_ctrl_default_mode);\n\t\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tCG_FDO_CTRL2, TMIN, hwmgr->tmin);\n\t\thwmgr->fan_ctrl_is_in_default_mode = true;\n\t}\n\n\treturn 0;\n}\n\nint smu7_fan_ctrl_start_smc_fan_control(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\n\tif (PP_CAP(PHM_PlatformCaps_ODFuzzyFanControlSupport)) {\n\t\tresult = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_StartFanControl,\n\t\t\t\t\tFAN_CONTROL_FUZZY, NULL);\n\n\t\tif (PP_CAP(PHM_PlatformCaps_FanSpeedInTableIsRPM))\n\t\t\thwmgr->hwmgr_func->set_max_fan_rpm_output(hwmgr,\n\t\t\t\t\thwmgr->thermal_controller.\n\t\t\t\t\tadvanceFanControlParameters.usMaxFanRPM);\n\t\telse\n\t\t\thwmgr->hwmgr_func->set_max_fan_pwm_output(hwmgr,\n\t\t\t\t\thwmgr->thermal_controller.\n\t\t\t\t\tadvanceFanControlParameters.usMaxFanPWM);\n\n\t} else {\n\t\tresult = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_StartFanControl,\n\t\t\t\t\tFAN_CONTROL_TABLE, NULL);\n\t}\n\n\tif (!result && hwmgr->thermal_controller.\n\t\t\tadvanceFanControlParameters.ucTargetTemperature)\n\t\tresult = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetFanTemperatureTarget,\n\t\t\t\thwmgr->thermal_controller.\n\t\t\t\tadvanceFanControlParameters.ucTargetTemperature,\n\t\t\t\tNULL);\n\n\tif (!result &&\n\t    (hwmgr->chip_id == CHIP_POLARIS10 ||\n\t    hwmgr->chip_id == CHIP_POLARIS11 ||\n\t    hwmgr->chip_id == CHIP_POLARIS12) &&\n\t    hwmgr->thermal_controller.advanceFanControlParameters.ucEnableZeroRPM &&\n\t    !PP_CAP(PHM_PlatformCaps_customThermalManagement))\n\t\tresult = smum_send_msg_to_smc(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableZeroRpm,\n\t\t\t\tNULL);\n\n\thwmgr->fan_ctrl_enabled = true;\n\n\treturn result;\n}\n\n\nint smu7_fan_ctrl_stop_smc_fan_control(struct pp_hwmgr *hwmgr)\n{\n\thwmgr->fan_ctrl_enabled = false;\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_StopFanControl, NULL);\n}\n\n \nint smu7_fan_ctrl_set_fan_speed_pwm(struct pp_hwmgr *hwmgr,\n\t\tuint32_t speed)\n{\n\tuint32_t duty100;\n\tuint32_t duty;\n\tuint64_t tmp64;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\treturn 0;\n\n\tspeed = MIN(speed, 255);\n\n\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\tsmu7_fan_ctrl_stop_smc_fan_control(hwmgr);\n\n\tduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\n\tif (duty100 == 0)\n\t\treturn -EINVAL;\n\n\ttmp64 = (uint64_t)speed * duty100;\n\tdo_div(tmp64, 255);\n\tduty = (uint32_t)tmp64;\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL0, FDO_STATIC_DUTY, duty);\n\n\treturn smu7_fan_ctrl_set_static_mode(hwmgr, FDO_PWM_MODE_STATIC);\n}\n\n \nint smu7_fan_ctrl_reset_fan_speed_to_default(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\treturn 0;\n\n\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl)) {\n\t\tresult = smu7_fan_ctrl_set_static_mode(hwmgr, FDO_PWM_MODE_STATIC);\n\t\tif (!result)\n\t\t\tresult = smu7_fan_ctrl_start_smc_fan_control(hwmgr);\n\t} else\n\t\tresult = smu7_fan_ctrl_set_default_mode(hwmgr);\n\n\treturn result;\n}\n\n \nint smu7_fan_ctrl_set_fan_speed_rpm(struct pp_hwmgr *hwmgr, uint32_t speed)\n{\n\tuint32_t tach_period;\n\tuint32_t crystal_clock_freq;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan ||\n\t\t\t(hwmgr->thermal_controller.fanInfo.\n\t\t\tucTachometerPulsesPerRevolution == 0) ||\n\t\t\tspeed == 0 ||\n\t\t\t(speed < hwmgr->thermal_controller.fanInfo.ulMinRPM) ||\n\t\t\t(speed > hwmgr->thermal_controller.fanInfo.ulMaxRPM))\n\t\treturn 0;\n\n\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\tsmu7_fan_ctrl_stop_smc_fan_control(hwmgr);\n\n\tcrystal_clock_freq = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\ttach_period = 60 * crystal_clock_freq * 10000 / (8 * speed);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tCG_TACH_CTRL, TARGET_PERIOD, tach_period);\n\n\treturn smu7_fan_ctrl_set_static_mode(hwmgr, FDO_PWM_MODE_STATIC_RPM);\n}\n\n \nint smu7_thermal_get_temperature(struct pp_hwmgr *hwmgr)\n{\n\tint temp;\n\n\ttemp = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_MULT_THERMAL_STATUS, CTF_TEMP);\n\n\t \n\tif (temp & 0x200)\n\t\ttemp = SMU7_THERMAL_MAXIMUM_TEMP_READING;\n\telse\n\t\ttemp = temp & 0x1ff;\n\n\ttemp *= PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn temp;\n}\n\n \nstatic int smu7_thermal_set_temperature_range(struct pp_hwmgr *hwmgr,\n\t\tint low_temp, int high_temp)\n{\n\tint low = SMU7_THERMAL_MINIMUM_ALERT_TEMP *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tint high = SMU7_THERMAL_MAXIMUM_ALERT_TEMP *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\tif (low < low_temp)\n\t\tlow = low_temp;\n\tif (high > high_temp)\n\t\thigh = high_temp;\n\n\tif (low > high)\n\t\treturn -EINVAL;\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, DIG_THERM_INTH,\n\t\t\t(high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES));\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, DIG_THERM_INTL,\n\t\t\t(low / PP_TEMPERATURE_UNITS_PER_CENTIGRADES));\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_CTRL, DIG_THERM_DPM,\n\t\t\t(high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES));\n\n\treturn 0;\n}\n\n \nstatic int smu7_thermal_initialize(struct pp_hwmgr *hwmgr)\n{\n\tif (hwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution)\n\t\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\tCG_TACH_CTRL, EDGE_PER_REV,\n\t\t\t\thwmgr->thermal_controller.fanInfo.\n\t\t\t\tucTachometerPulsesPerRevolution - 1);\n\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_FDO_CTRL2, TACH_PWM_RESP_RATE, 0x28);\n\n\treturn 0;\n}\n\n \nstatic void smu7_thermal_enable_alert(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t alert;\n\n\talert = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, THERM_INT_MASK);\n\talert &= ~(SMU7_THERMAL_HIGH_ALERT_MASK | SMU7_THERMAL_LOW_ALERT_MASK);\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, THERM_INT_MASK, alert);\n\n\t \n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_Thermal_Cntl_Enable, NULL);\n}\n\n \nint smu7_thermal_disable_alert(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t alert;\n\n\talert = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, THERM_INT_MASK);\n\talert |= (SMU7_THERMAL_HIGH_ALERT_MASK | SMU7_THERMAL_LOW_ALERT_MASK);\n\tPHM_WRITE_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tCG_THERMAL_INT, THERM_INT_MASK, alert);\n\n\t \n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_Thermal_Cntl_Disable, NULL);\n}\n\n \nint smu7_thermal_stop_thermal_controller(struct pp_hwmgr *hwmgr)\n{\n\tint result = smu7_thermal_disable_alert(hwmgr);\n\n\tif (!hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\tsmu7_fan_ctrl_set_default_mode(hwmgr);\n\n\treturn result;\n}\n\n \nstatic int smu7_thermal_start_smc_fan_control(struct pp_hwmgr *hwmgr)\n{\n \n\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl)) {\n\t\tsmu7_fan_ctrl_start_smc_fan_control(hwmgr);\n\t\tsmu7_fan_ctrl_set_static_mode(hwmgr, FDO_PWM_MODE_STATIC);\n\t}\n\n\treturn 0;\n}\n\nint smu7_start_thermal_controller(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct PP_TemperatureRange *range)\n{\n\tint ret = 0;\n\n\tif (range == NULL)\n\t\treturn -EINVAL;\n\n\tsmu7_thermal_initialize(hwmgr);\n\tret = smu7_thermal_set_temperature_range(hwmgr, range->min, range->max);\n\tif (ret)\n\t\treturn -EINVAL;\n\tsmu7_thermal_enable_alert(hwmgr);\n\tret = smum_thermal_avfs_enable(hwmgr);\n\tif (ret)\n\t\treturn -EINVAL;\n\n \n\tsmum_thermal_setup_fan_table(hwmgr);\n\tsmu7_thermal_start_smc_fan_control(hwmgr);\n\treturn 0;\n}\n\n\n\nint smu7_thermal_ctrl_uninitialize_thermal_controller(struct pp_hwmgr *hwmgr)\n{\n\tif (!hwmgr->thermal_controller.fanInfo.bNoFan)\n\t\tsmu7_fan_ctrl_set_default_mode(hwmgr);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}