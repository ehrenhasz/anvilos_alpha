{
  "module_name": "ci_smumgr.c",
  "hash_id": "8208cbf2badbb8fef6677d8bde57d7425ba54abbcdf0a0c4c402253433a2df63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/ci_smumgr.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"linux/delay.h\"\n#include <linux/types.h>\n#include <linux/pci.h>\n\n#include \"smumgr.h\"\n#include \"pp_debug.h\"\n#include \"ci_smumgr.h\"\n#include \"ppsmc.h\"\n#include \"smu7_hwmgr.h\"\n#include \"hardwaremanager.h\"\n#include \"ppatomctrl.h\"\n#include \"cgs_common.h\"\n#include \"atombios.h\"\n#include \"pppcielanes.h\"\n#include \"smu7_smumgr.h\"\n\n#include \"smu/smu_7_0_1_d.h\"\n#include \"smu/smu_7_0_1_sh_mask.h\"\n\n#include \"dce/dce_8_0_d.h\"\n#include \"dce/dce_8_0_sh_mask.h\"\n\n#include \"bif/bif_4_1_d.h\"\n#include \"bif/bif_4_1_sh_mask.h\"\n\n#include \"gca/gfx_7_2_d.h\"\n#include \"gca/gfx_7_2_sh_mask.h\"\n\n#include \"gmc/gmc_7_1_d.h\"\n#include \"gmc/gmc_7_1_sh_mask.h\"\n\n#include \"processpptables.h\"\n\n#define MC_CG_ARB_FREQ_F0           0x0a\n#define MC_CG_ARB_FREQ_F1           0x0b\n#define MC_CG_ARB_FREQ_F2           0x0c\n#define MC_CG_ARB_FREQ_F3           0x0d\n\n#define SMC_RAM_END 0x40000\n\n#define CISLAND_MINIMUM_ENGINE_CLOCK 800\n#define CISLAND_MAX_DEEPSLEEP_DIVIDER_ID 5\n\nstatic const struct ci_pt_defaults defaults_hawaii_xt = {\n\t1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0xB0000,\n\t{ 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  },\n\t{ 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 }\n};\n\nstatic const struct ci_pt_defaults defaults_hawaii_pro = {\n\t1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0x65062,\n\t{ 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  },\n\t{ 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 }\n};\n\nstatic const struct ci_pt_defaults defaults_bonaire_xt = {\n\t1, 0xF, 0xFD, 0x19, 5, 45, 0, 0xB0000,\n\t{ 0x79,  0x253, 0x25D, 0xAE,  0x72,  0x80,  0x83,  0x86,  0x6F,  0xC8,  0xC9,  0xC9,  0x2F,  0x4D,  0x61  },\n\t{ 0x17C, 0x172, 0x180, 0x1BC, 0x1B3, 0x1BD, 0x206, 0x200, 0x203, 0x25D, 0x25A, 0x255, 0x2C3, 0x2C5, 0x2B4 }\n};\n\n\nstatic const struct ci_pt_defaults defaults_saturn_xt = {\n\t1, 0xF, 0xFD, 0x19, 5, 55, 0, 0x70000,\n\t{ 0x8C,  0x247, 0x249, 0xA6,  0x80,  0x81,  0x8B,  0x89,  0x86,  0xC9,  0xCA,  0xC9,  0x4D,  0x4D,  0x4D  },\n\t{ 0x187, 0x187, 0x187, 0x1C7, 0x1C7, 0x1C7, 0x210, 0x210, 0x210, 0x266, 0x266, 0x266, 0x2C9, 0x2C9, 0x2C9 }\n};\n\n\nstatic int ci_set_smc_sram_address(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t smc_addr, uint32_t limit)\n{\n\tif ((0 != (3 & smc_addr))\n\t\t|| ((smc_addr + 3) >= limit)) {\n\t\tpr_err(\"smc_addr invalid \\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcgs_write_register(hwmgr->device, mmSMC_IND_INDEX_0, smc_addr);\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\n\treturn 0;\n}\n\nstatic int ci_copy_bytes_to_smc(struct pp_hwmgr *hwmgr, uint32_t smc_start_address,\n\t\t\t\tconst uint8_t *src, uint32_t byte_count, uint32_t limit)\n{\n\tint result;\n\tuint32_t data = 0;\n\tuint32_t original_data;\n\tuint32_t addr = 0;\n\tuint32_t extra_shift;\n\n\tif ((3 & smc_start_address)\n\t\t|| ((smc_start_address + byte_count) >= limit)) {\n\t\tpr_err(\"smc_start_address invalid \\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = smc_start_address;\n\n\twhile (byte_count >= 4) {\n\t \n\t\tdata = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];\n\n\t\tresult = ci_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\tif (0 != byte_count) {\n\n\t\tdata = 0;\n\n\t\tresult = ci_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\n\t\toriginal_data = cgs_read_register(hwmgr->device, mmSMC_IND_DATA_0);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (0x100 * data) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tresult = ci_set_smc_sram_address(hwmgr, addr, limit);\n\n\t\tif (0 != result)\n\t\t\treturn result;\n\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_0, data);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int ci_program_jump_on_start(struct pp_hwmgr *hwmgr)\n{\n\tstatic const unsigned char data[4] = { 0xE0, 0x00, 0x80, 0x40 };\n\n\tci_copy_bytes_to_smc(hwmgr, 0x0, data, 4, sizeof(data)+1);\n\n\treturn 0;\n}\n\nstatic bool ci_is_smc_ram_running(struct pp_hwmgr *hwmgr)\n{\n\treturn ((0 == PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable))\n\t&& (0x20100 <= cgs_read_ind_register(hwmgr->device,\n\t\t\tCGS_IND_REG__SMC, ixSMC_PC_C)));\n}\n\nstatic int ci_read_smc_sram_dword(struct pp_hwmgr *hwmgr, uint32_t smc_addr,\n\t\t\t\tuint32_t *value, uint32_t limit)\n{\n\tint result;\n\n\tresult = ci_set_smc_sram_address(hwmgr, smc_addr, limit);\n\n\tif (result)\n\t\treturn result;\n\n\t*value = cgs_read_register(hwmgr->device, mmSMC_IND_DATA_0);\n\treturn 0;\n}\n\nstatic int ci_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret;\n\n\tcgs_write_register(hwmgr->device, mmSMC_RESP_0, 0);\n\tcgs_write_register(hwmgr->device, mmSMC_MESSAGE_0, msg);\n\n\tPHM_WAIT_FIELD_UNEQUAL(hwmgr, SMC_RESP_0, SMC_RESP, 0);\n\n\tret = PHM_READ_FIELD(hwmgr->device, SMC_RESP_0, SMC_RESP);\n\n\tif (ret != 1)\n\t\tdev_info(adev->dev,\n\t\t\t\"failed to send message %x ret is %d\\n\", msg,ret);\n\n\treturn 0;\n}\n\nstatic int ci_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint16_t msg, uint32_t parameter)\n{\n\tcgs_write_register(hwmgr->device, mmSMC_MSG_ARG_0, parameter);\n\treturn ci_send_msg_to_smc(hwmgr, msg);\n}\n\nstatic void ci_initialize_power_tune_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t dev_id;\n\n\tdev_id = adev->pdev->device;\n\n\tswitch (dev_id) {\n\tcase 0x67BA:\n\tcase 0x67B1:\n\t\tsmu_data->power_tune_defaults = &defaults_hawaii_pro;\n\t\tbreak;\n\tcase 0x67B8:\n\tcase 0x66B0:\n\t\tsmu_data->power_tune_defaults = &defaults_hawaii_xt;\n\t\tbreak;\n\tcase 0x6640:\n\tcase 0x6641:\n\tcase 0x6646:\n\tcase 0x6647:\n\t\tsmu_data->power_tune_defaults = &defaults_saturn_xt;\n\t\tbreak;\n\tcase 0x6649:\n\tcase 0x6650:\n\tcase 0x6651:\n\tcase 0x6658:\n\tcase 0x665C:\n\tcase 0x665D:\n\tcase 0x67A0:\n\tcase 0x67A1:\n\tcase 0x67A2:\n\tcase 0x67A8:\n\tcase 0x67A9:\n\tcase 0x67AA:\n\tcase 0x67B9:\n\tcase 0x67BE:\n\tdefault:\n\t\tsmu_data->power_tune_defaults = &defaults_bonaire_xt;\n\t\tbreak;\n\t}\n}\n\nstatic int ci_get_dependency_volt_by_clk(struct pp_hwmgr *hwmgr,\n\tstruct phm_clock_voltage_dependency_table *allowed_clock_voltage_table,\n\tuint32_t clock, uint32_t *vol)\n{\n\tuint32_t i = 0;\n\n\tif (allowed_clock_voltage_table->count == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < allowed_clock_voltage_table->count; i++) {\n\t\tif (allowed_clock_voltage_table->entries[i].clk >= clock) {\n\t\t\t*vol = allowed_clock_voltage_table->entries[i].v;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*vol = allowed_clock_voltage_table->entries[i - 1].v;\n\treturn 0;\n}\n\nstatic int ci_calculate_sclk_params(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock, struct SMU7_Discrete_GraphicsLevel *sclk)\n{\n\tconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tuint32_t spll_func_cntl            = data->clock_registers.vCG_SPLL_FUNC_CNTL;\n\tuint32_t spll_func_cntl_3          = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\n\tuint32_t spll_func_cntl_4          = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\n\tuint32_t cg_spll_spread_spectrum   = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\n\tuint32_t cg_spll_spread_spectrum_2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\n\tuint32_t ref_clock;\n\tuint32_t ref_divider;\n\tuint32_t fbdiv;\n\tint result;\n\n\t \n\tresult = atomctrl_get_engine_pll_dividers_vi(hwmgr, clock,  &dividers);\n\n\tPP_ASSERT_WITH_CODE(result == 0,\n\t\t\t\"Error retrieving Engine Clock dividers from VBIOS.\",\n\t\t\treturn result);\n\n\t \n\tref_clock = atomctrl_get_reference_clock(hwmgr);\n\tref_divider = 1 + dividers.uc_pll_ref_div;\n\n\t \n\tfbdiv = dividers.ul_fb_div.ul_fb_divider & 0x3FFFFFF;\n\n\t \n\tspll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,\n\t\t\tSPLL_REF_DIV, dividers.uc_pll_ref_div);\n\tspll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,\n\t\t\tSPLL_PDIV_A,  dividers.uc_pll_post_div);\n\n\t \n\tspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3, CG_SPLL_FUNC_CNTL_3,\n\t\t\tSPLL_FB_DIV, fbdiv);\n\n\t \n\tspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3, CG_SPLL_FUNC_CNTL_3,\n\t\t\tSPLL_DITHEN, 1);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_EngineSpreadSpectrumSupport)) {\n\t\tstruct pp_atomctrl_internal_ss_info ss_info;\n\t\tuint32_t vco_freq = clock * dividers.uc_pll_post_div;\n\n\t\tif (!atomctrl_get_engine_clock_spread_spectrum(hwmgr,\n\t\t\t\tvco_freq, &ss_info)) {\n\t\t\tuint32_t clk_s = ref_clock * 5 /\n\t\t\t\t\t(ref_divider * ss_info.speed_spectrum_rate);\n\t\t\tuint32_t clk_v = 4 * ss_info.speed_spectrum_percentage *\n\t\t\t\t\tfbdiv / (clk_s * 10000);\n\n\t\t\tcg_spll_spread_spectrum = PHM_SET_FIELD(cg_spll_spread_spectrum,\n\t\t\t\t\tCG_SPLL_SPREAD_SPECTRUM, CLKS, clk_s);\n\t\t\tcg_spll_spread_spectrum = PHM_SET_FIELD(cg_spll_spread_spectrum,\n\t\t\t\t\tCG_SPLL_SPREAD_SPECTRUM, SSEN, 1);\n\t\t\tcg_spll_spread_spectrum_2 = PHM_SET_FIELD(cg_spll_spread_spectrum_2,\n\t\t\t\t\tCG_SPLL_SPREAD_SPECTRUM_2, CLKV, clk_v);\n\t\t}\n\t}\n\n\tsclk->SclkFrequency        = clock;\n\tsclk->CgSpllFuncCntl3      = spll_func_cntl_3;\n\tsclk->CgSpllFuncCntl4      = spll_func_cntl_4;\n\tsclk->SpllSpreadSpectrum   = cg_spll_spread_spectrum;\n\tsclk->SpllSpreadSpectrum2  = cg_spll_spread_spectrum_2;\n\tsclk->SclkDid              = (uint8_t)dividers.pll_post_divider;\n\n\treturn 0;\n}\n\nstatic void ci_populate_phase_value_based_on_sclk(struct pp_hwmgr *hwmgr,\n\t\t\t\tconst struct phm_phase_shedding_limits_table *pl,\n\t\t\t\t\tuint32_t sclk, uint32_t *p_shed)\n{\n\tunsigned int i;\n\n\t \n\t*p_shed = 1;\n\n\tfor (i = 0; i < pl->count; i++) {\n\t\tif (sclk < pl->entries[i].Sclk) {\n\t\t\t*p_shed = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic uint8_t ci_get_sleep_divider_id_from_clock(uint32_t clock,\n\t\t\tuint32_t clock_insr)\n{\n\tuint8_t i;\n\tuint32_t temp;\n\tuint32_t min = min_t(uint32_t, clock_insr, CISLAND_MINIMUM_ENGINE_CLOCK);\n\n\tif (clock < min) {\n\t\tpr_info(\"Engine clock can't satisfy stutter requirement!\\n\");\n\t\treturn 0;\n\t}\n\tfor (i = CISLAND_MAX_DEEPSLEEP_DIVIDER_ID;  ; i--) {\n\t\ttemp = clock >> i;\n\n\t\tif (temp >= min || i == 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int ci_populate_single_graphic_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock, struct SMU7_Discrete_GraphicsLevel *level)\n{\n\tint result;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\n\tresult = ci_calculate_sclk_params(hwmgr, clock, level);\n\n\t \n\tresult = ci_get_dependency_volt_by_clk(hwmgr,\n\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk, clock,\n\t\t\t(uint32_t *)(&level->MinVddc));\n\tif (result) {\n\t\tpr_err(\"vdd_dep_on_sclk table is NULL\\n\");\n\t\treturn result;\n\t}\n\n\tlevel->SclkFrequency = clock;\n\tlevel->MinVddcPhases = 1;\n\n\tif (data->vddc_phase_shed_control)\n\t\tci_populate_phase_value_based_on_sclk(hwmgr,\n\t\t\t\thwmgr->dyn_state.vddc_phase_shed_limits_table,\n\t\t\t\tclock,\n\t\t\t\t&level->MinVddcPhases);\n\n\tlevel->ActivityLevel = data->current_profile_setting.sclk_activity;\n\tlevel->CcPwrDynRm = 0;\n\tlevel->CcPwrDynRm1 = 0;\n\tlevel->EnabledForActivity = 0;\n\t \n\tlevel->EnabledForThrottle = 1;\n\tlevel->UpH = data->current_profile_setting.sclk_up_hyst;\n\tlevel->DownH = data->current_profile_setting.sclk_down_hyst;\n\tlevel->VoltageDownH = 0;\n\tlevel->PowerThrottle = 0;\n\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SclkDeepSleep))\n\t\tlevel->DeepSleepDivId =\n\t\t\t\tci_get_sleep_divider_id_from_clock(clock,\n\t\t\t\t\t\tCISLAND_MINIMUM_ENGINE_CLOCK);\n\n\t \n\tlevel->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\n\n\tif (0 == result) {\n\t\tlevel->MinVddc = PP_HOST_TO_SMC_UL(level->MinVddc * VOLTAGE_SCALE);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->MinVddcPhases);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->SclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(level->ActivityLevel);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->CgSpllFuncCntl3);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->CgSpllFuncCntl4);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->SpllSpreadSpectrum);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->SpllSpreadSpectrum2);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm1);\n\t}\n\n\treturn result;\n}\n\nstatic int ci_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_dpm_table *dpm_table = &data->dpm_table;\n\tint result = 0;\n\tuint32_t array = smu_data->dpm_table_start +\n\t\t\toffsetof(SMU7_Discrete_DpmTable, GraphicsLevel);\n\tuint32_t array_size = sizeof(struct SMU7_Discrete_GraphicsLevel) *\n\t\t\tSMU7_MAX_LEVELS_GRAPHICS;\n\tstruct SMU7_Discrete_GraphicsLevel *levels =\n\t\t\tsmu_data->smc_state_table.GraphicsLevel;\n\tuint32_t i;\n\n\tfor (i = 0; i < dpm_table->sclk_table.count; i++) {\n\t\tresult = ci_populate_single_graphic_level(hwmgr,\n\t\t\t\tdpm_table->sclk_table.dpm_levels[i].value,\n\t\t\t\t&levels[i]);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (i > 1)\n\t\t\tsmu_data->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;\n\t\tif (i == (dpm_table->sclk_table.count - 1))\n\t\t\tsmu_data->smc_state_table.GraphicsLevel[i].DisplayWatermark =\n\t\t\t\tPPSMC_DISPLAY_WATERMARK_HIGH;\n\t}\n\n\tsmu_data->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;\n\n\tsmu_data->smc_state_table.GraphicsDpmLevelCount = (u8)dpm_table->sclk_table.count;\n\tdata->dpm_level_enable_mask.sclk_dpm_enable_mask =\n\t\tphm_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\n\n\tresult = ci_copy_bytes_to_smc(hwmgr, array,\n\t\t\t\t   (u8 *)levels, array_size,\n\t\t\t\t   SMC_RAM_END);\n\n\treturn result;\n\n}\n\nstatic int ci_populate_svi_load_line(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tconst struct ci_pt_defaults *defaults = smu_data->power_tune_defaults;\n\n\tsmu_data->power_tune_table.SviLoadLineEn = defaults->svi_load_line_en;\n\tsmu_data->power_tune_table.SviLoadLineVddC = defaults->svi_load_line_vddc;\n\tsmu_data->power_tune_table.SviLoadLineTrimVddC = 3;\n\tsmu_data->power_tune_table.SviLoadLineOffsetVddC = 0;\n\n\treturn 0;\n}\n\nstatic int ci_populate_tdc_limit(struct pp_hwmgr *hwmgr)\n{\n\tuint16_t tdc_limit;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tconst struct ci_pt_defaults *defaults = smu_data->power_tune_defaults;\n\n\ttdc_limit = (uint16_t)(hwmgr->dyn_state.cac_dtp_table->usTDC * 256);\n\tsmu_data->power_tune_table.TDC_VDDC_PkgLimit =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(tdc_limit);\n\tsmu_data->power_tune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\n\t\t\tdefaults->tdc_vddc_throttle_release_limit_perc;\n\tsmu_data->power_tune_table.TDC_MAWt = defaults->tdc_mawt;\n\n\treturn 0;\n}\n\nstatic int ci_populate_dw8(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tconst struct ci_pt_defaults *defaults = smu_data->power_tune_defaults;\n\tuint32_t temp;\n\n\tif (ci_read_smc_sram_dword(hwmgr,\n\t\t\tfuse_table_offset +\n\t\t\toffsetof(SMU7_Discrete_PmFuses, TdcWaterfallCtl),\n\t\t\t(uint32_t *)&temp, SMC_RAM_END))\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"Attempt to read PmFuses.DW6 (SviLoadLineEn) from SMC Failed!\",\n\t\t\t\treturn -EINVAL);\n\telse\n\t\tsmu_data->power_tune_table.TdcWaterfallCtl = defaults->tdc_waterfall_ctl;\n\n\treturn 0;\n}\n\nstatic int ci_populate_fuzzy_fan(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset)\n{\n\tuint16_t tmp;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\n\tif ((hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity & (1 << 15))\n\t\t|| 0 == hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity)\n\t\ttmp = hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity;\n\telse\n\t\ttmp = hwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity;\n\n\tsmu_data->power_tune_table.FuzzyFan_PwmSetDelta = CONVERT_FROM_HOST_TO_SMC_US(tmp);\n\n\treturn 0;\n}\n\nstatic int ci_populate_bapm_vddc_vid_sidd(struct pp_hwmgr *hwmgr)\n{\n\tint i;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint8_t *hi_vid = smu_data->power_tune_table.BapmVddCVidHiSidd;\n\tuint8_t *lo_vid = smu_data->power_tune_table.BapmVddCVidLoSidd;\n\tuint8_t *hi2_vid = smu_data->power_tune_table.BapmVddCVidHiSidd2;\n\n\tPP_ASSERT_WITH_CODE(NULL != hwmgr->dyn_state.cac_leakage_table,\n\t\t\t    \"The CAC Leakage table does not exist!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count <= 8,\n\t\t\t    \"There should never be more than 8 entries for BapmVddcVid!!!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count == hwmgr->dyn_state.vddc_dependency_on_sclk->count,\n\t\t\t    \"CACLeakageTable->count and VddcDependencyOnSCLk->count not equal\", return -EINVAL);\n\n\tfor (i = 0; (uint32_t) i < hwmgr->dyn_state.cac_leakage_table->count; i++) {\n\t\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_EVV)) {\n\t\t\tlo_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc1);\n\t\t\thi_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc2);\n\t\t\thi2_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc3);\n\t\t} else {\n\t\t\tlo_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc);\n\t\t\thi_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Leakage);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_populate_vddc_vid(struct pp_hwmgr *hwmgr)\n{\n\tint i;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint8_t *vid = smu_data->power_tune_table.VddCVid;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tPP_ASSERT_WITH_CODE(data->vddc_voltage_table.count <= 8,\n\t\t\"There should never be more than 8 entries for VddcVid!!!\",\n\t\treturn -EINVAL);\n\n\tfor (i = 0; i < (int)data->vddc_voltage_table.count; i++)\n\t\tvid[i] = convert_to_vid(data->vddc_voltage_table.entries[i].value);\n\n\treturn 0;\n}\n\nstatic int ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tu8 *hi_vid = smu_data->power_tune_table.BapmVddCVidHiSidd;\n\tu8 *lo_vid = smu_data->power_tune_table.BapmVddCVidLoSidd;\n\tint i, min, max;\n\n\tmin = max = hi_vid[0];\n\tfor (i = 0; i < 8; i++) {\n\t\tif (0 != hi_vid[i]) {\n\t\t\tif (min > hi_vid[i])\n\t\t\t\tmin = hi_vid[i];\n\t\t\tif (max < hi_vid[i])\n\t\t\t\tmax = hi_vid[i];\n\t\t}\n\n\t\tif (0 != lo_vid[i]) {\n\t\t\tif (min > lo_vid[i])\n\t\t\t\tmin = lo_vid[i];\n\t\t\tif (max < lo_vid[i])\n\t\t\t\tmax = lo_vid[i];\n\t\t}\n\t}\n\n\tif ((min == 0) || (max == 0))\n\t\treturn -EINVAL;\n\tsmu_data->power_tune_table.GnbLPMLMaxVid = (u8)max;\n\tsmu_data->power_tune_table.GnbLPMLMinVid = (u8)min;\n\n\treturn 0;\n}\n\nstatic int ci_populate_bapm_vddc_base_leakage_sidd(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint16_t HiSidd;\n\tuint16_t LoSidd;\n\tstruct phm_cac_tdp_table *cac_table = hwmgr->dyn_state.cac_dtp_table;\n\n\tHiSidd = (uint16_t)(cac_table->usHighCACLeakage / 100 * 256);\n\tLoSidd = (uint16_t)(cac_table->usLowCACLeakage / 100 * 256);\n\n\tsmu_data->power_tune_table.BapmVddCBaseLeakageHiSidd =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(HiSidd);\n\tsmu_data->power_tune_table.BapmVddCBaseLeakageLoSidd =\n\t\t\tCONVERT_FROM_HOST_TO_SMC_US(LoSidd);\n\n\treturn 0;\n}\n\nstatic int ci_populate_pm_fuses(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint32_t pm_fuse_table_offset;\n\tint ret = 0;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerContainment)) {\n\t\tif (ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, PmFuseTable),\n\t\t\t\t&pm_fuse_table_offset, SMC_RAM_END)) {\n\t\t\tpr_err(\"Attempt to get pm_fuse_table_offset Failed!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = ci_populate_bapm_vddc_vid_sidd(hwmgr);\n\t\t \n\t\tret |= ci_populate_vddc_vid(hwmgr);\n\t\t \n\t\tret |= ci_populate_svi_load_line(hwmgr);\n\t\t \n\t\tret |= ci_populate_tdc_limit(hwmgr);\n\t\t \n\t\tret |= ci_populate_dw8(hwmgr, pm_fuse_table_offset);\n\n\t\tret |= ci_populate_fuzzy_fan(hwmgr, pm_fuse_table_offset);\n\n\t\tret |= ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(hwmgr);\n\n\t\tret |= ci_populate_bapm_vddc_base_leakage_sidd(hwmgr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ci_copy_bytes_to_smc(hwmgr, pm_fuse_table_offset,\n\t\t\t\t(uint8_t *)&smu_data->power_tune_table,\n\t\t\t\tsizeof(struct SMU7_Discrete_PmFuses), SMC_RAM_END);\n\t}\n\treturn ret;\n}\n\nstatic int ci_populate_bapm_parameters_in_dpm_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tconst struct ci_pt_defaults *defaults = smu_data->power_tune_defaults;\n\tSMU7_Discrete_DpmTable  *dpm_table = &(smu_data->smc_state_table);\n\tstruct phm_cac_tdp_table *cac_dtp_table = hwmgr->dyn_state.cac_dtp_table;\n\tstruct phm_ppm_table *ppm = hwmgr->dyn_state.ppm_parameter_table;\n\tconst uint16_t *def1, *def2;\n\tint i, j, k;\n\n\tdpm_table->DefaultTdp = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usTDP * 256));\n\tdpm_table->TargetTdp = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usConfigurableTDP * 256));\n\n\tdpm_table->DTETjOffset = 0;\n\tdpm_table->GpuTjMax = (uint8_t)(data->thermal_temp_setting.temperature_high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES);\n\tdpm_table->GpuTjHyst = 8;\n\n\tdpm_table->DTEAmbientTempBase = defaults->dte_ambient_temp_base;\n\n\tif (ppm) {\n\t\tdpm_table->PPM_PkgPwrLimit = (uint16_t)ppm->dgpu_tdp * 256 / 1000;\n\t\tdpm_table->PPM_TemperatureLimit = (uint16_t)ppm->tj_max * 256;\n\t} else {\n\t\tdpm_table->PPM_PkgPwrLimit = 0;\n\t\tdpm_table->PPM_TemperatureLimit = 0;\n\t}\n\n\tCONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_PkgPwrLimit);\n\tCONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_TemperatureLimit);\n\n\tdpm_table->BAPM_TEMP_GRADIENT = PP_HOST_TO_SMC_UL(defaults->bapm_temp_gradient);\n\tdef1 = defaults->bapmti_r;\n\tdef2 = defaults->bapmti_rc;\n\n\tfor (i = 0; i < SMU7_DTE_ITERATIONS; i++) {\n\t\tfor (j = 0; j < SMU7_DTE_SOURCES; j++) {\n\t\t\tfor (k = 0; k < SMU7_DTE_SINKS; k++) {\n\t\t\t\tdpm_table->BAPMTI_R[i][j][k] = PP_HOST_TO_SMC_US(*def1);\n\t\t\t\tdpm_table->BAPMTI_RC[i][j][k] = PP_HOST_TO_SMC_US(*def2);\n\t\t\t\tdef1++;\n\t\t\t\tdef2++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_get_std_voltage_value_sidd(struct pp_hwmgr *hwmgr,\n\t\tpp_atomctrl_voltage_table_entry *tab, uint16_t *hi,\n\t\tuint16_t *lo)\n{\n\tuint16_t v_index;\n\tbool vol_found = false;\n\t*hi = tab->value * VOLTAGE_SCALE;\n\t*lo = tab->value * VOLTAGE_SCALE;\n\n\tPP_ASSERT_WITH_CODE(NULL != hwmgr->dyn_state.vddc_dependency_on_sclk,\n\t\t\t\"The SCLK/VDDC Dependency Table does not exist.\\n\",\n\t\t\treturn -EINVAL);\n\n\tif (NULL == hwmgr->dyn_state.cac_leakage_table) {\n\t\tpr_warn(\"CAC Leakage Table does not exist, using vddc.\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (v_index = 0; (uint32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) {\n\t\tif (tab->value == hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) {\n\t\t\tvol_found = true;\n\t\t\tif ((uint32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) {\n\t\t\t\t*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;\n\t\t\t\t*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage * VOLTAGE_SCALE);\n\t\t\t} else {\n\t\t\t\tpr_warn(\"Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index, using maximum index from CAC table.\\n\");\n\t\t\t\t*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;\n\t\t\t\t*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vol_found) {\n\t\tfor (v_index = 0; (uint32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) {\n\t\t\tif (tab->value <= hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) {\n\t\t\t\tvol_found = true;\n\t\t\t\tif ((uint32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) {\n\t\t\t\t\t*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;\n\t\t\t\t\t*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage) * VOLTAGE_SCALE;\n\t\t\t\t} else {\n\t\t\t\t\tpr_warn(\"Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index in second look up, using maximum index from CAC table.\");\n\t\t\t\t\t*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;\n\t\t\t\t\t*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!vol_found)\n\t\t\tpr_warn(\"Unable to get std_vddc from SCLK/VDDC Dependency Table, using vddc.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_voltage_table(struct pp_hwmgr *hwmgr,\n\t\tpp_atomctrl_voltage_table_entry *tab,\n\t\tSMU7_Discrete_VoltageLevel *smc_voltage_tab)\n{\n\tint result;\n\n\tresult = ci_get_std_voltage_value_sidd(hwmgr, tab,\n\t\t\t&smc_voltage_tab->StdVoltageHiSidd,\n\t\t\t&smc_voltage_tab->StdVoltageLoSidd);\n\tif (result) {\n\t\tsmc_voltage_tab->StdVoltageHiSidd = tab->value * VOLTAGE_SCALE;\n\t\tsmc_voltage_tab->StdVoltageLoSidd = tab->value * VOLTAGE_SCALE;\n\t}\n\n\tsmc_voltage_tab->Voltage = PP_HOST_TO_SMC_US(tab->value * VOLTAGE_SCALE);\n\tCONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageHiSidd);\n\tCONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageLoSidd);\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_vddc_table(struct pp_hwmgr *hwmgr,\n\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tunsigned int count;\n\tint result;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\ttable->VddcLevelCount = data->vddc_voltage_table.count;\n\tfor (count = 0; count < table->VddcLevelCount; count++) {\n\t\tresult = ci_populate_smc_voltage_table(hwmgr,\n\t\t\t\t&(data->vddc_voltage_table.entries[count]),\n\t\t\t\t&(table->VddcLevel[count]));\n\t\tPP_ASSERT_WITH_CODE(0 == result, \"do not populate SMC VDDC voltage table\", return -EINVAL);\n\n\t\t \n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control) {\n\t\t\ttable->VddcLevel[count].Smio = (uint8_t) count;\n\t\t\ttable->Smio[count] |= data->vddc_voltage_table.entries[count].smio_low;\n\t\t\ttable->SmioMaskVddcVid |= data->vddc_voltage_table.entries[count].smio_low;\n\t\t} else {\n\t\t\ttable->VddcLevel[count].Smio = 0;\n\t\t}\n\t}\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->VddcLevelCount);\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_vdd_ci_table(struct pp_hwmgr *hwmgr,\n\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t count;\n\tint result;\n\n\ttable->VddciLevelCount = data->vddci_voltage_table.count;\n\n\tfor (count = 0; count < table->VddciLevelCount; count++) {\n\t\tresult = ci_populate_smc_voltage_table(hwmgr,\n\t\t\t\t&(data->vddci_voltage_table.entries[count]),\n\t\t\t\t&(table->VddciLevel[count]));\n\t\tPP_ASSERT_WITH_CODE(result == 0, \"do not populate SMC VDDCI voltage table\", return -EINVAL);\n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\n\t\t\ttable->VddciLevel[count].Smio = (uint8_t) count;\n\t\t\ttable->Smio[count] |= data->vddci_voltage_table.entries[count].smio_low;\n\t\t\ttable->SmioMaskVddciVid |= data->vddci_voltage_table.entries[count].smio_low;\n\t\t} else {\n\t\t\ttable->VddciLevel[count].Smio = 0;\n\t\t}\n\t}\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->VddciLevelCount);\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_mvdd_table(struct pp_hwmgr *hwmgr,\n\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t count;\n\tint result;\n\n\ttable->MvddLevelCount = data->mvdd_voltage_table.count;\n\n\tfor (count = 0; count < table->MvddLevelCount; count++) {\n\t\tresult = ci_populate_smc_voltage_table(hwmgr,\n\t\t\t\t&(data->mvdd_voltage_table.entries[count]),\n\t\t\t\t&table->MvddLevel[count]);\n\t\tPP_ASSERT_WITH_CODE(result == 0, \"do not populate SMC mvdd voltage table\", return -EINVAL);\n\t\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\n\t\t\ttable->MvddLevel[count].Smio = (uint8_t) count;\n\t\t\ttable->Smio[count] |= data->mvdd_voltage_table.entries[count].smio_low;\n\t\t\ttable->SmioMaskMvddVid |= data->mvdd_voltage_table.entries[count].smio_low;\n\t\t} else {\n\t\t\ttable->MvddLevel[count].Smio = 0;\n\t\t}\n\t}\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->MvddLevelCount);\n\n\treturn 0;\n}\n\n\nstatic int ci_populate_smc_voltage_tables(struct pp_hwmgr *hwmgr,\n\tSMU7_Discrete_DpmTable *table)\n{\n\tint result;\n\n\tresult = ci_populate_smc_vddc_table(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"can not populate VDDC voltage table to SMC\", return -EINVAL);\n\n\tresult = ci_populate_smc_vdd_ci_table(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"can not populate VDDCI voltage table to SMC\", return -EINVAL);\n\n\tresult = ci_populate_smc_mvdd_table(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"can not populate MVDD voltage table to SMC\", return -EINVAL);\n\n\treturn 0;\n}\n\nstatic int ci_populate_ulv_level(struct pp_hwmgr *hwmgr,\n\t\tstruct SMU7_Discrete_Ulv *state)\n{\n\tuint32_t voltage_response_time, ulv_voltage;\n\tint result;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tstate->CcPwrDynRm = 0;\n\tstate->CcPwrDynRm1 = 0;\n\n\tresult = pp_tables_get_response_times(hwmgr, &voltage_response_time, &ulv_voltage);\n\tPP_ASSERT_WITH_CODE((0 == result), \"can not get ULV voltage value\", return result;);\n\n\tif (ulv_voltage == 0) {\n\t\tdata->ulv_supported = false;\n\t\treturn 0;\n\t}\n\n\tif (data->voltage_control != SMU7_VOLTAGE_CONTROL_BY_SVID2) {\n\t\t \n\t\tif (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)\n\t\t\tstate->VddcOffset = 0;\n\t\telse\n\t\t\t \n\t\t\tstate->VddcOffset = (uint16_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage);\n\t} else {\n\t\t \n\t\tif (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)\n\t\t\tstate->VddcOffsetVid = 0;\n\t\telse   \n\t\t\tstate->VddcOffsetVid = (uint8_t)(\n\t\t\t\t\t(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage)\n\t\t\t\t\t\t* VOLTAGE_VID_OFFSET_SCALE2\n\t\t\t\t\t\t/ VOLTAGE_VID_OFFSET_SCALE1);\n\t}\n\tstate->VddcPhase = 1;\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm);\n\tCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm1);\n\tCONVERT_FROM_HOST_TO_SMC_US(state->VddcOffset);\n\n\treturn 0;\n}\n\nstatic int ci_populate_ulv_state(struct pp_hwmgr *hwmgr,\n\t\t SMU7_Discrete_Ulv *ulv_level)\n{\n\treturn ci_populate_ulv_level(hwmgr, ulv_level);\n}\n\nstatic int ci_populate_smc_link_level(struct pp_hwmgr *hwmgr, SMU7_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct smu7_dpm_table *dpm_table = &data->dpm_table;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint32_t i;\n\n \n\tfor (i = 0; i <= dpm_table->pcie_speed_table.count; i++) {\n\t\ttable->LinkLevel[i].PcieGenSpeed  =\n\t\t\t(uint8_t)dpm_table->pcie_speed_table.dpm_levels[i].value;\n\t\ttable->LinkLevel[i].PcieLaneCount =\n\t\t\t(uint8_t)encode_pcie_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);\n\t\ttable->LinkLevel[i].EnabledForActivity = 1;\n\t\ttable->LinkLevel[i].DownT = PP_HOST_TO_SMC_UL(5);\n\t\ttable->LinkLevel[i].UpT = PP_HOST_TO_SMC_UL(30);\n\t}\n\n\tsmu_data->smc_state_table.LinkLevelCount =\n\t\t(uint8_t)dpm_table->pcie_speed_table.count;\n\tdata->dpm_level_enable_mask.pcie_dpm_enable_mask =\n\t\tphm_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\n\n\treturn 0;\n}\n\nstatic int ci_calculate_mclk_params(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t memory_clock,\n\t\tSMU7_Discrete_MemoryLevel *mclk,\n\t\tbool strobe_mode,\n\t\tbool dllStateOn\n\t\t)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t  dll_cntl = data->clock_registers.vDLL_CNTL;\n\tuint32_t  mclk_pwrmgt_cntl = data->clock_registers.vMCLK_PWRMGT_CNTL;\n\tuint32_t  mpll_ad_func_cntl = data->clock_registers.vMPLL_AD_FUNC_CNTL;\n\tuint32_t  mpll_dq_func_cntl = data->clock_registers.vMPLL_DQ_FUNC_CNTL;\n\tuint32_t  mpll_func_cntl = data->clock_registers.vMPLL_FUNC_CNTL;\n\tuint32_t  mpll_func_cntl_1 = data->clock_registers.vMPLL_FUNC_CNTL_1;\n\tuint32_t  mpll_func_cntl_2 = data->clock_registers.vMPLL_FUNC_CNTL_2;\n\tuint32_t  mpll_ss1 = data->clock_registers.vMPLL_SS1;\n\tuint32_t  mpll_ss2 = data->clock_registers.vMPLL_SS2;\n\n\tpp_atomctrl_memory_clock_param mpll_param;\n\tint result;\n\n\tresult = atomctrl_get_memory_pll_dividers_si(hwmgr,\n\t\t\t\tmemory_clock, &mpll_param, strobe_mode);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Error retrieving Memory Clock Parameters from VBIOS.\", return result);\n\n\tmpll_func_cntl = PHM_SET_FIELD(mpll_func_cntl, MPLL_FUNC_CNTL, BWCTRL, mpll_param.bw_ctrl);\n\n\tmpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,\n\t\t\t\t\t\t\tMPLL_FUNC_CNTL_1, CLKF, mpll_param.mpll_fb_divider.cl_kf);\n\tmpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,\n\t\t\t\t\t\t\tMPLL_FUNC_CNTL_1, CLKFRAC, mpll_param.mpll_fb_divider.clk_frac);\n\tmpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,\n\t\t\t\t\t\t\tMPLL_FUNC_CNTL_1, VCO_MODE, mpll_param.vco_mode);\n\n\tmpll_ad_func_cntl = PHM_SET_FIELD(mpll_ad_func_cntl,\n\t\t\t\t\t\t\tMPLL_AD_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_divider);\n\n\tif (data->is_memory_gddr5) {\n\t\tmpll_dq_func_cntl  = PHM_SET_FIELD(mpll_dq_func_cntl,\n\t\t\t\t\t\t\t\tMPLL_DQ_FUNC_CNTL, YCLK_SEL, mpll_param.yclk_sel);\n\t\tmpll_dq_func_cntl  = PHM_SET_FIELD(mpll_dq_func_cntl,\n\t\t\t\t\t\t\t\tMPLL_DQ_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_divider);\n\t}\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_MemorySpreadSpectrumSupport)) {\n\t\tpp_atomctrl_internal_ss_info ss_info;\n\t\tuint32_t freq_nom;\n\t\tuint32_t tmp;\n\t\tuint32_t reference_clock = atomctrl_get_mpll_reference_clock(hwmgr);\n\n\t\t \n\t\tif (1 == mpll_param.qdr)\n\t\t\tfreq_nom = memory_clock * 4 * (1 << mpll_param.mpll_post_divider);\n\t\telse\n\t\t\tfreq_nom = memory_clock * 2 * (1 << mpll_param.mpll_post_divider);\n\n\t\t \n\t\ttmp = (freq_nom / reference_clock);\n\t\ttmp = tmp * tmp;\n\n\t\tif (0 == atomctrl_get_memory_clock_spread_spectrum(hwmgr, freq_nom, &ss_info)) {\n\t\t\tuint32_t clks = reference_clock * 5 / ss_info.speed_spectrum_rate;\n\t\t\tuint32_t clkv =\n\t\t\t\t(uint32_t)((((131 * ss_info.speed_spectrum_percentage *\n\t\t\t\t\t\t\tss_info.speed_spectrum_rate) / 100) * tmp) / freq_nom);\n\n\t\t\tmpll_ss1 = PHM_SET_FIELD(mpll_ss1, MPLL_SS1, CLKV, clkv);\n\t\t\tmpll_ss2 = PHM_SET_FIELD(mpll_ss2, MPLL_SS2, CLKS, clks);\n\t\t}\n\t}\n\n\tmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, DLL_SPEED, mpll_param.dll_speed);\n\tmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK0_PDNB, dllStateOn);\n\tmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK1_PDNB, dllStateOn);\n\n\n\tmclk->MclkFrequency   = memory_clock;\n\tmclk->MpllFuncCntl    = mpll_func_cntl;\n\tmclk->MpllFuncCntl_1  = mpll_func_cntl_1;\n\tmclk->MpllFuncCntl_2  = mpll_func_cntl_2;\n\tmclk->MpllAdFuncCntl  = mpll_ad_func_cntl;\n\tmclk->MpllDqFuncCntl  = mpll_dq_func_cntl;\n\tmclk->MclkPwrmgtCntl  = mclk_pwrmgt_cntl;\n\tmclk->DllCntl         = dll_cntl;\n\tmclk->MpllSs1         = mpll_ss1;\n\tmclk->MpllSs2         = mpll_ss2;\n\n\treturn 0;\n}\n\nstatic uint8_t ci_get_mclk_frequency_ratio(uint32_t memory_clock,\n\t\tbool strobe_mode)\n{\n\tuint8_t mc_para_index;\n\n\tif (strobe_mode) {\n\t\tif (memory_clock < 12500)\n\t\t\tmc_para_index = 0x00;\n\t\telse if (memory_clock > 47500)\n\t\t\tmc_para_index = 0x0f;\n\t\telse\n\t\t\tmc_para_index = (uint8_t)((memory_clock - 10000) / 2500);\n\t} else {\n\t\tif (memory_clock < 65000)\n\t\t\tmc_para_index = 0x00;\n\t\telse if (memory_clock > 135000)\n\t\t\tmc_para_index = 0x0f;\n\t\telse\n\t\t\tmc_para_index = (uint8_t)((memory_clock - 60000) / 5000);\n\t}\n\n\treturn mc_para_index;\n}\n\nstatic uint8_t ci_get_ddr3_mclk_frequency_ratio(uint32_t memory_clock)\n{\n\tuint8_t mc_para_index;\n\n\tif (memory_clock < 10000)\n\t\tmc_para_index = 0;\n\telse if (memory_clock >= 80000)\n\t\tmc_para_index = 0x0f;\n\telse\n\t\tmc_para_index = (uint8_t)((memory_clock - 10000) / 5000 + 1);\n\n\treturn mc_para_index;\n}\n\nstatic int ci_populate_phase_value_based_on_mclk(struct pp_hwmgr *hwmgr, const struct phm_phase_shedding_limits_table *pl,\n\t\t\t\t\tuint32_t memory_clock, uint32_t *p_shed)\n{\n\tunsigned int i;\n\n\t*p_shed = 1;\n\n\tfor (i = 0; i < pl->count; i++) {\n\t\tif (memory_clock < pl->entries[i].Mclk) {\n\t\t\t*p_shed = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_populate_single_memory_level(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t memory_clock,\n\t\tSMU7_Discrete_MemoryLevel *memory_level\n\t\t)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tint result = 0;\n\tbool dll_state_on;\n\tuint32_t mclk_edc_wr_enable_threshold = 40000;\n\tuint32_t mclk_edc_enable_threshold = 40000;\n\tuint32_t mclk_strobe_mode_threshold = 40000;\n\n\tif (hwmgr->dyn_state.vddc_dependency_on_mclk != NULL) {\n\t\tresult = ci_get_dependency_volt_by_clk(hwmgr,\n\t\t\thwmgr->dyn_state.vddc_dependency_on_mclk, memory_clock, &memory_level->MinVddc);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"can not find MinVddc voltage value from memory VDDC voltage dependency table\", return result);\n\t}\n\n\tif (NULL != hwmgr->dyn_state.vddci_dependency_on_mclk) {\n\t\tresult = ci_get_dependency_volt_by_clk(hwmgr,\n\t\t\t\thwmgr->dyn_state.vddci_dependency_on_mclk,\n\t\t\t\tmemory_clock,\n\t\t\t\t&memory_level->MinVddci);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"can not find MinVddci voltage value from memory VDDCI voltage dependency table\", return result);\n\t}\n\n\tif (NULL != hwmgr->dyn_state.mvdd_dependency_on_mclk) {\n\t\tresult = ci_get_dependency_volt_by_clk(hwmgr,\n\t\t\t\thwmgr->dyn_state.mvdd_dependency_on_mclk,\n\t\t\t\tmemory_clock,\n\t\t\t\t&memory_level->MinMvdd);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"can not find MinVddci voltage value from memory MVDD voltage dependency table\", return result);\n\t}\n\n\tmemory_level->MinVddcPhases = 1;\n\n\tif (data->vddc_phase_shed_control) {\n\t\tci_populate_phase_value_based_on_mclk(hwmgr, hwmgr->dyn_state.vddc_phase_shed_limits_table,\n\t\t\t\tmemory_clock, &memory_level->MinVddcPhases);\n\t}\n\n\tmemory_level->EnabledForThrottle = 1;\n\tmemory_level->EnabledForActivity = 1;\n\tmemory_level->UpH = data->current_profile_setting.mclk_up_hyst;\n\tmemory_level->DownH = data->current_profile_setting.mclk_down_hyst;\n\tmemory_level->VoltageDownH = 0;\n\n\t \n\tmemory_level->ActivityLevel = data->current_profile_setting.mclk_activity;\n\tmemory_level->StutterEnable = 0;\n\tmemory_level->StrobeEnable = 0;\n\tmemory_level->EdcReadEnable = 0;\n\tmemory_level->EdcWriteEnable = 0;\n\tmemory_level->RttEnable = 0;\n\n\t \n\tmemory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\n\n\tdata->display_timing.num_existing_displays = hwmgr->display_config->num_display;\n\tdata->display_timing.vrefresh = hwmgr->display_config->vrefresh;\n\n\t \n\n\t \n\tmemory_level->StrobeEnable = (mclk_strobe_mode_threshold != 0) &&\n\t\t(memory_clock <= mclk_strobe_mode_threshold);\n\n\t \n\tif (data->is_memory_gddr5) {\n\t\tmemory_level->StrobeRatio = ci_get_mclk_frequency_ratio(memory_clock,\n\t\t\t\t\tmemory_level->StrobeEnable);\n\n\t\tif ((mclk_edc_enable_threshold != 0) &&\n\t\t\t\t(memory_clock > mclk_edc_enable_threshold)) {\n\t\t\tmemory_level->EdcReadEnable = 1;\n\t\t}\n\n\t\tif ((mclk_edc_wr_enable_threshold != 0) &&\n\t\t\t\t(memory_clock > mclk_edc_wr_enable_threshold)) {\n\t\t\tmemory_level->EdcWriteEnable = 1;\n\t\t}\n\n\t\tif (memory_level->StrobeEnable) {\n\t\t\tif (ci_get_mclk_frequency_ratio(memory_clock, 1) >=\n\t\t\t\t\t((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC7) >> 16) & 0xf))\n\t\t\t\tdll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\n\t\t\telse\n\t\t\t\tdll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC6) >> 1) & 0x1) ? 1 : 0;\n\t\t} else\n\t\t\tdll_state_on = data->dll_default_on;\n\t} else {\n\t\tmemory_level->StrobeRatio =\n\t\t\tci_get_ddr3_mclk_frequency_ratio(memory_clock);\n\t\tdll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\n\t}\n\n\tresult = ci_calculate_mclk_params(hwmgr,\n\t\tmemory_clock, memory_level, memory_level->StrobeEnable, dll_state_on);\n\n\tif (0 == result) {\n\t\tmemory_level->MinVddc = PP_HOST_TO_SMC_UL(memory_level->MinVddc * VOLTAGE_SCALE);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MinVddcPhases);\n\t\tmemory_level->MinVddci = PP_HOST_TO_SMC_UL(memory_level->MinVddci * VOLTAGE_SCALE);\n\t\tmemory_level->MinMvdd = PP_HOST_TO_SMC_UL(memory_level->MinMvdd * VOLTAGE_SCALE);\n\t\t \n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkFrequency);\n\t\t \n\t\tCONVERT_FROM_HOST_TO_SMC_US(memory_level->ActivityLevel);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_1);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_2);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllAdFuncCntl);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllDqFuncCntl);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkPwrmgtCntl);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->DllCntl);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs1);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs2);\n\t}\n\n\treturn result;\n}\n\nstatic int ci_populate_all_memory_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_dpm_table *dpm_table = &data->dpm_table;\n\tint result;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t dev_id;\n\n\tuint32_t level_array_address = smu_data->dpm_table_start + offsetof(SMU7_Discrete_DpmTable, MemoryLevel);\n\tuint32_t level_array_size = sizeof(SMU7_Discrete_MemoryLevel) * SMU7_MAX_LEVELS_MEMORY;\n\tSMU7_Discrete_MemoryLevel *levels = smu_data->smc_state_table.MemoryLevel;\n\tuint32_t i;\n\n\tmemset(levels, 0x00, level_array_size);\n\n\tfor (i = 0; i < dpm_table->mclk_table.count; i++) {\n\t\tPP_ASSERT_WITH_CODE((0 != dpm_table->mclk_table.dpm_levels[i].value),\n\t\t\t\"can not populate memory level as memory clock is zero\", return -EINVAL);\n\t\tresult = ci_populate_single_memory_level(hwmgr, dpm_table->mclk_table.dpm_levels[i].value,\n\t\t\t&(smu_data->smc_state_table.MemoryLevel[i]));\n\t\tif (0 != result)\n\t\t\treturn result;\n\t}\n\n\tsmu_data->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;\n\n\tdev_id = adev->pdev->device;\n\n\tif ((dpm_table->mclk_table.count >= 2)\n\t\t&& ((dev_id == 0x67B0) ||  (dev_id == 0x67B1))) {\n\t\tsmu_data->smc_state_table.MemoryLevel[1].MinVddci =\n\t\t\t\tsmu_data->smc_state_table.MemoryLevel[0].MinVddci;\n\t\tsmu_data->smc_state_table.MemoryLevel[1].MinMvdd =\n\t\t\t\tsmu_data->smc_state_table.MemoryLevel[0].MinMvdd;\n\t}\n\tsmu_data->smc_state_table.MemoryLevel[0].ActivityLevel = 0x1F;\n\tCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.MemoryLevel[0].ActivityLevel);\n\n\tsmu_data->smc_state_table.MemoryDpmLevelCount = (uint8_t)dpm_table->mclk_table.count;\n\tdata->dpm_level_enable_mask.mclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\n\tsmu_data->smc_state_table.MemoryLevel[dpm_table->mclk_table.count-1].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;\n\n\tresult = ci_copy_bytes_to_smc(hwmgr,\n\t\tlevel_array_address, (uint8_t *)levels, (uint32_t)level_array_size,\n\t\tSMC_RAM_END);\n\n\treturn result;\n}\n\nstatic int ci_populate_mvdd_value(struct pp_hwmgr *hwmgr, uint32_t mclk,\n\t\t\t\t\tSMU7_Discrete_VoltageLevel *voltage)\n{\n\tconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tuint32_t i = 0;\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE != data->mvdd_control) {\n\t\t \n\t\tfor (i = 0; i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count; i++) {\n\t\t\tif (mclk <= hwmgr->dyn_state.mvdd_dependency_on_mclk->entries[i].clk) {\n\t\t\t\t \n\t\t\t\tvoltage->Voltage = data->mvdd_voltage_table.entries[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tPP_ASSERT_WITH_CODE(i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count,\n\t\t\t\"MVDD Voltage is outside the supported range.\", return -EINVAL);\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_acpi_level(struct pp_hwmgr *hwmgr,\n\tSMU7_Discrete_DpmTable *table)\n{\n\tint result = 0;\n\tconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\n\tSMU7_Discrete_VoltageLevel voltage_level;\n\tuint32_t spll_func_cntl    = data->clock_registers.vCG_SPLL_FUNC_CNTL;\n\tuint32_t spll_func_cntl_2  = data->clock_registers.vCG_SPLL_FUNC_CNTL_2;\n\tuint32_t dll_cntl          = data->clock_registers.vDLL_CNTL;\n\tuint32_t mclk_pwrmgt_cntl  = data->clock_registers.vMCLK_PWRMGT_CNTL;\n\n\n\t \n\ttable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (data->acpi_vddc)\n\t\ttable->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->acpi_vddc * VOLTAGE_SCALE);\n\telse\n\t\ttable->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->min_vddc_in_pptable * VOLTAGE_SCALE);\n\n\ttable->ACPILevel.MinVddcPhases = data->vddc_phase_shed_control ? 0 : 1;\n\t \n\ttable->ACPILevel.SclkFrequency = atomctrl_get_reference_clock(hwmgr);\n\n\t \n\tresult = atomctrl_get_engine_pll_dividers_vi(hwmgr,\n\t\ttable->ACPILevel.SclkFrequency,  &dividers);\n\n\tPP_ASSERT_WITH_CODE(result == 0,\n\t\t\"Error retrieving Engine Clock dividers from VBIOS.\", return result);\n\n\t \n\ttable->ACPILevel.SclkDid = (uint8_t)dividers.pll_post_divider;\n\ttable->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\n\ttable->ACPILevel.DeepSleepDivId = 0;\n\n\tspll_func_cntl      = PHM_SET_FIELD(spll_func_cntl,\n\t\t\t\t\t\t\tCG_SPLL_FUNC_CNTL,   SPLL_PWRON,     0);\n\tspll_func_cntl      = PHM_SET_FIELD(spll_func_cntl,\n\t\t\t\t\t\t\tCG_SPLL_FUNC_CNTL,   SPLL_RESET,     1);\n\tspll_func_cntl_2    = PHM_SET_FIELD(spll_func_cntl_2,\n\t\t\t\t\t\t\tCG_SPLL_FUNC_CNTL_2, SCLK_MUX_SEL,   4);\n\n\ttable->ACPILevel.CgSpllFuncCntl = spll_func_cntl;\n\ttable->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;\n\ttable->ACPILevel.CgSpllFuncCntl3 = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\n\ttable->ACPILevel.CgSpllFuncCntl4 = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\n\ttable->ACPILevel.SpllSpreadSpectrum = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\n\ttable->ACPILevel.SpllSpreadSpectrum2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\n\ttable->ACPILevel.CcPwrDynRm = 0;\n\ttable->ACPILevel.CcPwrDynRm1 = 0;\n\n\t \n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.Flags);\n\t \n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SclkFrequency);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl2);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl3);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl4);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum2);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm1);\n\n\n\t \n\ttable->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;\n\ttable->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)\n\t\ttable->MemoryACPILevel.MinVddci = table->MemoryACPILevel.MinVddc;\n\telse {\n\t\tif (data->acpi_vddci != 0)\n\t\t\ttable->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->acpi_vddci * VOLTAGE_SCALE);\n\t\telse\n\t\t\ttable->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->min_vddci_in_pptable * VOLTAGE_SCALE);\n\t}\n\n\tif (0 == ci_populate_mvdd_value(hwmgr, 0, &voltage_level))\n\t\ttable->MemoryACPILevel.MinMvdd =\n\t\t\tPP_HOST_TO_SMC_UL(voltage_level.Voltage * VOLTAGE_SCALE);\n\telse\n\t\ttable->MemoryACPILevel.MinMvdd = 0;\n\n\t \n\tmclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK0_RESET, 0x1);\n\tmclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK1_RESET, 0x1);\n\n\t \n\tmclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK0_PDNB, 0);\n\tmclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,\n\t\tMCLK_PWRMGT_CNTL, MRDCK1_PDNB, 0);\n\n\t \n\tdll_cntl            = PHM_SET_FIELD(dll_cntl,\n\t\tDLL_CNTL, MRDCK0_BYPASS, 0);\n\tdll_cntl            = PHM_SET_FIELD(dll_cntl,\n\t\tDLL_CNTL, MRDCK1_BYPASS, 0);\n\n\ttable->MemoryACPILevel.DllCntl            =\n\t\tPP_HOST_TO_SMC_UL(dll_cntl);\n\ttable->MemoryACPILevel.MclkPwrmgtCntl     =\n\t\tPP_HOST_TO_SMC_UL(mclk_pwrmgt_cntl);\n\ttable->MemoryACPILevel.MpllAdFuncCntl     =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_AD_FUNC_CNTL);\n\ttable->MemoryACPILevel.MpllDqFuncCntl     =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_DQ_FUNC_CNTL);\n\ttable->MemoryACPILevel.MpllFuncCntl       =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL);\n\ttable->MemoryACPILevel.MpllFuncCntl_1     =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_1);\n\ttable->MemoryACPILevel.MpllFuncCntl_2     =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_2);\n\ttable->MemoryACPILevel.MpllSs1            =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS1);\n\ttable->MemoryACPILevel.MpllSs2            =\n\t\tPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS2);\n\n\ttable->MemoryACPILevel.EnabledForThrottle = 0;\n\ttable->MemoryACPILevel.EnabledForActivity = 0;\n\ttable->MemoryACPILevel.UpH = 0;\n\ttable->MemoryACPILevel.DownH = 100;\n\ttable->MemoryACPILevel.VoltageDownH = 0;\n\t \n\ttable->MemoryACPILevel.ActivityLevel = PP_HOST_TO_SMC_US(data->current_profile_setting.mclk_activity);\n\n\ttable->MemoryACPILevel.StutterEnable = 0;\n\ttable->MemoryACPILevel.StrobeEnable = 0;\n\ttable->MemoryACPILevel.EdcReadEnable = 0;\n\ttable->MemoryACPILevel.EdcWriteEnable = 0;\n\ttable->MemoryACPILevel.RttEnable = 0;\n\n\treturn result;\n}\n\nstatic int ci_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tint result = 0;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_uvd_clock_voltage_dependency_table *uvd_table =\n\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\n\ttable->UvdLevelCount = (uint8_t)(uvd_table->count);\n\n\tfor (count = 0; count < table->UvdLevelCount; count++) {\n\t\ttable->UvdLevel[count].VclkFrequency =\n\t\t\t\t\tuvd_table->entries[count].vclk;\n\t\ttable->UvdLevel[count].DclkFrequency =\n\t\t\t\t\tuvd_table->entries[count].dclk;\n\t\ttable->UvdLevel[count].MinVddc =\n\t\t\t\t\tuvd_table->entries[count].v * VOLTAGE_SCALE;\n\t\ttable->UvdLevel[count].MinVddcPhases = 1;\n\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->UvdLevel[count].VclkFrequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for Vclk clock\", return result);\n\n\t\ttable->UvdLevel[count].VclkDivider = (uint8_t)dividers.pll_post_divider;\n\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->UvdLevel[count].DclkFrequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for Dclk clock\", return result);\n\n\t\ttable->UvdLevel[count].DclkDivider = (uint8_t)dividers.pll_post_divider;\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].VclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].DclkFrequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->UvdLevel[count].MinVddc);\n\t}\n\n\treturn result;\n}\n\nstatic int ci_populate_smc_vce_level(struct pp_hwmgr *hwmgr,\n\t\tSMU7_Discrete_DpmTable *table)\n{\n\tint result = -EINVAL;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_vce_clock_voltage_dependency_table *vce_table =\n\t\t\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\n\ttable->VceLevelCount = (uint8_t)(vce_table->count);\n\ttable->VceBootLevel = 0;\n\n\tfor (count = 0; count < table->VceLevelCount; count++) {\n\t\ttable->VceLevel[count].Frequency = vce_table->entries[count].evclk;\n\t\ttable->VceLevel[count].MinVoltage =\n\t\t\t\tvce_table->entries[count].v * VOLTAGE_SCALE;\n\t\ttable->VceLevel[count].MinPhases = 1;\n\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->VceLevel[count].Frequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for VCE engine clock\",\n\t\t\t\treturn result);\n\n\t\ttable->VceLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->VceLevel[count].Frequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->VceLevel[count].MinVoltage);\n\t}\n\treturn result;\n}\n\nstatic int ci_populate_smc_acp_level(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tint result = -EINVAL;\n\tuint8_t count;\n\tstruct pp_atomctrl_clock_dividers_vi dividers;\n\tstruct phm_acp_clock_voltage_dependency_table *acp_table =\n\t\t\t\thwmgr->dyn_state.acp_clock_voltage_dependency_table;\n\n\ttable->AcpLevelCount = (uint8_t)(acp_table->count);\n\ttable->AcpBootLevel = 0;\n\n\tfor (count = 0; count < table->AcpLevelCount; count++) {\n\t\ttable->AcpLevel[count].Frequency = acp_table->entries[count].acpclk;\n\t\ttable->AcpLevel[count].MinVoltage = acp_table->entries[count].v;\n\t\ttable->AcpLevel[count].MinPhases = 1;\n\n\t\tresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\n\t\t\t\ttable->AcpLevel[count].Frequency, &dividers);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"can not find divide id for engine clock\", return result);\n\n\t\ttable->AcpLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->AcpLevel[count].Frequency);\n\t\tCONVERT_FROM_HOST_TO_SMC_US(table->AcpLevel[count].MinVoltage);\n\t}\n\treturn result;\n}\n\nstatic int ci_populate_memory_timing_parameters(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t engine_clock,\n\t\tuint32_t memory_clock,\n\t\tstruct SMU7_Discrete_MCArbDramTimingTableEntry *arb_regs\n\t\t)\n{\n\tuint32_t dramTiming;\n\tuint32_t dramTiming2;\n\tuint32_t burstTime;\n\tint result;\n\n\tresult = atomctrl_set_engine_dram_timings_rv770(hwmgr,\n\t\t\t\tengine_clock, memory_clock);\n\n\tPP_ASSERT_WITH_CODE(result == 0,\n\t\t\"Error calling VBIOS to set DRAM_TIMING.\", return result);\n\n\tdramTiming  = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING);\n\tdramTiming2 = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING2);\n\tburstTime = PHM_READ_FIELD(hwmgr->device, MC_ARB_BURST_TIME, STATE0);\n\n\tarb_regs->McArbDramTiming  = PP_HOST_TO_SMC_UL(dramTiming);\n\tarb_regs->McArbDramTiming2 = PP_HOST_TO_SMC_UL(dramTiming2);\n\tarb_regs->McArbBurstTime = (uint8_t)burstTime;\n\n\treturn 0;\n}\n\nstatic int ci_program_memory_timing_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tint result = 0;\n\tSMU7_Discrete_MCArbDramTimingTable  arb_regs;\n\tuint32_t i, j;\n\n\tmemset(&arb_regs, 0x00, sizeof(SMU7_Discrete_MCArbDramTimingTable));\n\n\tfor (i = 0; i < data->dpm_table.sclk_table.count; i++) {\n\t\tfor (j = 0; j < data->dpm_table.mclk_table.count; j++) {\n\t\t\tresult = ci_populate_memory_timing_parameters\n\t\t\t\t(hwmgr, data->dpm_table.sclk_table.dpm_levels[i].value,\n\t\t\t\t data->dpm_table.mclk_table.dpm_levels[j].value,\n\t\t\t\t &arb_regs.entries[i][j]);\n\n\t\t\tif (0 != result)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == result) {\n\t\tresult = ci_copy_bytes_to_smc(\n\t\t\t\thwmgr,\n\t\t\t\tsmu_data->arb_table_start,\n\t\t\t\t(uint8_t *)&arb_regs,\n\t\t\t\tsizeof(SMU7_Discrete_MCArbDramTimingTable),\n\t\t\t\tSMC_RAM_END\n\t\t\t\t);\n\t}\n\n\treturn result;\n}\n\nstatic int ci_populate_smc_boot_level(struct pp_hwmgr *hwmgr,\n\t\t\tSMU7_Discrete_DpmTable *table)\n{\n\tint result = 0;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\n\ttable->GraphicsBootLevel = 0;\n\ttable->MemoryBootLevel = 0;\n\n\t \n\tresult = phm_find_boot_level(&(data->dpm_table.sclk_table),\n\t\t\tdata->vbios_boot_state.sclk_bootup_value,\n\t\t\t(uint32_t *)&(smu_data->smc_state_table.GraphicsBootLevel));\n\n\tif (0 != result) {\n\t\tsmu_data->smc_state_table.GraphicsBootLevel = 0;\n\t\tpr_err(\"VBIOS did not find boot engine clock value in dependency table. Using Graphics DPM level 0!\\n\");\n\t\tresult = 0;\n\t}\n\n\tresult = phm_find_boot_level(&(data->dpm_table.mclk_table),\n\t\tdata->vbios_boot_state.mclk_bootup_value,\n\t\t(uint32_t *)&(smu_data->smc_state_table.MemoryBootLevel));\n\n\tif (0 != result) {\n\t\tsmu_data->smc_state_table.MemoryBootLevel = 0;\n\t\tpr_err(\"VBIOS did not find boot engine clock value in dependency table. Using Memory DPM level 0!\\n\");\n\t\tresult = 0;\n\t}\n\n\ttable->BootVddc = data->vbios_boot_state.vddc_bootup_value;\n\ttable->BootVddci = data->vbios_boot_state.vddci_bootup_value;\n\ttable->BootMVdd = data->vbios_boot_state.mvdd_bootup_value;\n\n\treturn result;\n}\n\nstatic int ci_populate_mc_reg_address(struct pp_hwmgr *hwmgr,\n\t\t\t\t SMU7_Discrete_MCRegisters *mc_reg_table)\n{\n\tconst struct ci_smumgr *smu_data = (struct ci_smumgr *)hwmgr->smu_backend;\n\n\tuint32_t i, j;\n\n\tfor (i = 0, j = 0; j < smu_data->mc_reg_table.last; j++) {\n\t\tif (smu_data->mc_reg_table.validflag & 1<<j) {\n\t\t\tPP_ASSERT_WITH_CODE(i < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE,\n\t\t\t\t\"Index of mc_reg_table->address[] array out of boundary\", return -EINVAL);\n\t\t\tmc_reg_table->address[i].s0 =\n\t\t\t\tPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s0);\n\t\t\tmc_reg_table->address[i].s1 =\n\t\t\t\tPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s1);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tmc_reg_table->last = (uint8_t)i;\n\n\treturn 0;\n}\n\nstatic void ci_convert_mc_registers(\n\tconst struct ci_mc_reg_entry *entry,\n\tSMU7_Discrete_MCRegisterSet *data,\n\tuint32_t num_entries, uint32_t valid_flag)\n{\n\tuint32_t i, j;\n\n\tfor (i = 0, j = 0; j < num_entries; j++) {\n\t\tif (valid_flag & 1<<j) {\n\t\t\tdata->value[i] = PP_HOST_TO_SMC_UL(entry->mc_data[j]);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic int ci_convert_mc_reg_table_entry_to_smc(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tconst uint32_t memory_clock,\n\t\tSMU7_Discrete_MCRegisterSet *mc_reg_table_data\n\t\t)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint32_t i = 0;\n\n\tfor (i = 0; i < smu_data->mc_reg_table.num_entries; i++) {\n\t\tif (memory_clock <=\n\t\t\tsmu_data->mc_reg_table.mc_reg_table_entry[i].mclk_max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((i == smu_data->mc_reg_table.num_entries) && (i > 0))\n\t\t--i;\n\n\tci_convert_mc_registers(&smu_data->mc_reg_table.mc_reg_table_entry[i],\n\t\t\t\tmc_reg_table_data, smu_data->mc_reg_table.last,\n\t\t\t\tsmu_data->mc_reg_table.validflag);\n\n\treturn 0;\n}\n\nstatic int ci_convert_mc_reg_table_to_smc(struct pp_hwmgr *hwmgr,\n\t\tSMU7_Discrete_MCRegisters *mc_regs)\n{\n\tint result = 0;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tint res;\n\tuint32_t i;\n\n\tfor (i = 0; i < data->dpm_table.mclk_table.count; i++) {\n\t\tres = ci_convert_mc_reg_table_entry_to_smc(\n\t\t\t\thwmgr,\n\t\t\t\tdata->dpm_table.mclk_table.dpm_levels[i].value,\n\t\t\t\t&mc_regs->data[i]\n\t\t\t\t);\n\n\t\tif (0 != res)\n\t\t\tresult = res;\n\t}\n\n\treturn result;\n}\n\nstatic int ci_update_and_upload_mc_reg_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint32_t address;\n\tint32_t result;\n\n\tif (0 == (data->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))\n\t\treturn 0;\n\n\n\tmemset(&smu_data->mc_regs, 0, sizeof(SMU7_Discrete_MCRegisters));\n\n\tresult = ci_convert_mc_reg_table_to_smc(hwmgr, &(smu_data->mc_regs));\n\n\tif (result != 0)\n\t\treturn result;\n\n\taddress = smu_data->mc_reg_table_start + (uint32_t)offsetof(SMU7_Discrete_MCRegisters, data[0]);\n\n\treturn  ci_copy_bytes_to_smc(hwmgr, address,\n\t\t\t\t (uint8_t *)&smu_data->mc_regs.data[0],\n\t\t\t\tsizeof(SMU7_Discrete_MCRegisterSet) * data->dpm_table.mclk_table.count,\n\t\t\t\tSMC_RAM_END);\n}\n\nstatic int ci_populate_initial_mc_reg_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\n\tmemset(&smu_data->mc_regs, 0x00, sizeof(SMU7_Discrete_MCRegisters));\n\tresult = ci_populate_mc_reg_address(hwmgr, &(smu_data->mc_regs));\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize MCRegTable for the MC register addresses!\", return result;);\n\n\tresult = ci_convert_mc_reg_table_to_smc(hwmgr, &smu_data->mc_regs);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize MCRegTable for driver state!\", return result;);\n\n\treturn ci_copy_bytes_to_smc(hwmgr, smu_data->mc_reg_table_start,\n\t\t\t(uint8_t *)&smu_data->mc_regs, sizeof(SMU7_Discrete_MCRegisters), SMC_RAM_END);\n}\n\nstatic int ci_populate_smc_initial_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tuint8_t count, level;\n\n\tcount = (uint8_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->count);\n\n\tfor (level = 0; level < count; level++) {\n\t\tif (hwmgr->dyn_state.vddc_dependency_on_sclk->entries[level].clk\n\t\t\t >= data->vbios_boot_state.sclk_bootup_value) {\n\t\t\tsmu_data->smc_state_table.GraphicsBootLevel = level;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcount = (uint8_t)(hwmgr->dyn_state.vddc_dependency_on_mclk->count);\n\n\tfor (level = 0; level < count; level++) {\n\t\tif (hwmgr->dyn_state.vddc_dependency_on_mclk->entries[level].clk\n\t\t\t>= data->vbios_boot_state.mclk_bootup_value) {\n\t\t\tsmu_data->smc_state_table.MemoryBootLevel = level;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_populate_smc_svi2_config(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t    SMU7_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control)\n\t\ttable->SVI2Enable = 1;\n\telse\n\t\ttable->SVI2Enable = 0;\n\treturn 0;\n}\n\nstatic int ci_start_smc(struct pp_hwmgr *hwmgr)\n{\n\t \n\tci_program_jump_on_start(hwmgr);\n\n\t \n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\n\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_RESET_CNTL, rst_reg, 0);\n\n\tPHM_WAIT_INDIRECT_FIELD(hwmgr, SMC_IND, FIRMWARE_FLAGS,\n\t\t\t\t INTERRUPTS_ENABLED, 1);\n\n\treturn 0;\n}\n\nstatic int ci_populate_vr_config(struct pp_hwmgr *hwmgr, SMU7_Discrete_DpmTable *table)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tuint16_t config;\n\n\tconfig = VR_SVI2_PLANE_1;\n\ttable->VRConfig |= (config<<VRCONF_VDDGFX_SHIFT);\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) {\n\t\tconfig = VR_SVI2_PLANE_2;\n\t\ttable->VRConfig |= config;\n\t} else {\n\t\tpr_info(\"VDDCshould be on SVI2 controller!\");\n\t}\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control) {\n\t\tconfig = VR_SVI2_PLANE_2;\n\t\ttable->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);\n\t} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\n\t\tconfig = VR_SMIO_PATTERN_1;\n\t\ttable->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);\n\t}\n\n\tif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\n\t\tconfig = VR_SMIO_PATTERN_2;\n\t\ttable->VRConfig |= (config<<VRCONF_MVDD_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_init_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tSMU7_Discrete_DpmTable  *table = &(smu_data->smc_state_table);\n\tstruct pp_atomctrl_gpio_pin_assignment gpio_pin;\n\tu32 i;\n\n\tci_initialize_power_tune_defaults(hwmgr);\n\tmemset(&(smu_data->smc_state_table), 0x00, sizeof(smu_data->smc_state_table));\n\n\tif (SMU7_VOLTAGE_CONTROL_NONE != data->voltage_control)\n\t\tci_populate_smc_voltage_tables(hwmgr, table);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_AutomaticDCTransition))\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_StepVddc))\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (data->is_memory_gddr5)\n\t\ttable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tif (data->ulv_supported) {\n\t\tresult = ci_populate_ulv_state(hwmgr, &(table->Ulv));\n\t\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to initialize ULV state!\", return result);\n\n\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\tixCG_ULV_PARAMETER, 0x40035);\n\t}\n\n\tresult = ci_populate_all_graphic_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize Graphics Level!\", return result);\n\n\tresult = ci_populate_all_memory_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize Memory Level!\", return result);\n\n\tresult = ci_populate_smc_link_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize Link Level!\", return result);\n\n\tresult = ci_populate_smc_acpi_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize ACPI Level!\", return result);\n\n\tresult = ci_populate_smc_vce_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize VCE Level!\", return result);\n\n\tresult = ci_populate_smc_acp_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize ACP Level!\", return result);\n\n\t \n\t \n\tresult = ci_program_memory_timing_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to Write ARB settings for the initial state.\", return result);\n\n\tresult = ci_populate_smc_uvd_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize UVD Level!\", return result);\n\n\ttable->UvdBootLevel  = 0;\n\ttable->VceBootLevel  = 0;\n\ttable->AcpBootLevel  = 0;\n\ttable->SamuBootLevel  = 0;\n\n\ttable->GraphicsBootLevel = 0;\n\ttable->MemoryBootLevel = 0;\n\n\tresult = ci_populate_smc_boot_level(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to initialize Boot Level!\", return result);\n\n\tresult = ci_populate_smc_initial_state(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result, \"Failed to initialize Boot State!\", return result);\n\n\tresult = ci_populate_bapm_parameters_in_dpm_table(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result, \"Failed to populate BAPM Parameters!\", return result);\n\n\ttable->UVDInterval = 1;\n\ttable->VCEInterval = 1;\n\ttable->ACPInterval = 1;\n\ttable->SAMUInterval = 1;\n\ttable->GraphicsVoltageChangeEnable  = 1;\n\ttable->GraphicsThermThrottleEnable  = 1;\n\ttable->GraphicsInterval = 1;\n\ttable->VoltageInterval  = 1;\n\ttable->ThermalInterval  = 1;\n\n\ttable->TemperatureLimitHigh =\n\t\t(data->thermal_temp_setting.temperature_high *\n\t\t SMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\ttable->TemperatureLimitLow =\n\t\t(data->thermal_temp_setting.temperature_low *\n\t\tSMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\ttable->MemoryVoltageChangeEnable  = 1;\n\ttable->MemoryInterval  = 1;\n\ttable->VoltageResponseTime  = 0;\n\ttable->VddcVddciDelta = 4000;\n\ttable->PhaseResponseTime  = 0;\n\ttable->MemoryThermThrottleEnable  = 1;\n\n\tPP_ASSERT_WITH_CODE((1 <= data->dpm_table.pcie_speed_table.count),\n\t\t\t\"There must be 1 or more PCIE levels defined in PPTable.\",\n\t\t\treturn -EINVAL);\n\n\ttable->PCIeBootLinkLevel = (uint8_t)data->dpm_table.pcie_speed_table.count;\n\ttable->PCIeGenInterval = 1;\n\n\tresult = ci_populate_vr_config(hwmgr, table);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to populate VRConfig setting!\", return result);\n\tdata->vr_config = table->VRConfig;\n\n\tci_populate_smc_svi2_config(hwmgr, table);\n\n\tfor (i = 0; i < SMU7_MAX_ENTRIES_SMIO; i++)\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(table->Smio[i]);\n\n\ttable->ThermGpio  = 17;\n\ttable->SclkStepSize = 0x4000;\n\tif (atomctrl_get_pp_assign_pin(hwmgr, VDDC_VRHOT_GPIO_PINID, &gpio_pin)) {\n\t\ttable->VRHotGpio = gpio_pin.uc_gpio_pin_bit_shift;\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_RegulatorHot);\n\t} else {\n\t\ttable->VRHotGpio = SMU7_UNUSED_GPIO_PIN;\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_RegulatorHot);\n\t}\n\n\ttable->AcDcGpio = SMU7_UNUSED_GPIO_PIN;\n\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SystemFlags);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->VRConfig);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcVid);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcPhase);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddciVid);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskMvddVid);\n\tCONVERT_FROM_HOST_TO_SMC_UL(table->SclkStepSize);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitHigh);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitLow);\n\ttable->VddcVddciDelta = PP_HOST_TO_SMC_US(table->VddcVddciDelta);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->VoltageResponseTime);\n\tCONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);\n\n\ttable->BootVddc = PP_HOST_TO_SMC_US(table->BootVddc * VOLTAGE_SCALE);\n\ttable->BootVddci = PP_HOST_TO_SMC_US(table->BootVddci * VOLTAGE_SCALE);\n\ttable->BootMVdd = PP_HOST_TO_SMC_US(table->BootMVdd * VOLTAGE_SCALE);\n\n\t \n\tresult = ci_copy_bytes_to_smc(hwmgr, smu_data->dpm_table_start +\n\t\t\t\t\toffsetof(SMU7_Discrete_DpmTable, SystemFlags),\n\t\t\t\t\t(uint8_t *)&(table->SystemFlags),\n\t\t\t\t\tsizeof(SMU7_Discrete_DpmTable)-3 * sizeof(SMU7_PIDController),\n\t\t\t\t\tSMC_RAM_END);\n\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\"Failed to upload dpm data to SMC memory!\", return result;);\n\n\tresult = ci_populate_initial_mc_reg_table(hwmgr);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\"Failed to populate initialize MC Reg table!\", return result);\n\n\tresult = ci_populate_pm_fuses(hwmgr);\n\tPP_ASSERT_WITH_CODE(0 == result,\n\t\t\t\"Failed to  populate PM fuses to SMC memory!\", return result);\n\n\tci_start_smc(hwmgr);\n\n\treturn 0;\n}\n\nstatic int ci_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *ci_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tSMU7_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\n\tuint32_t duty100;\n\tuint32_t t_diff1, t_diff2, pwm_diff1, pwm_diff2;\n\tuint16_t fdo_min, slope1, slope2;\n\tuint32_t reference_clock;\n\tint res;\n\tuint64_t tmp64;\n\n\tif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl))\n\t\treturn 0;\n\n\tif (hwmgr->thermal_controller.fanInfo.bNoFan) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\tif (0 == ci_data->fan_table_start) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\tduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_FDO_CTRL1, FMAX_DUTY100);\n\n\tif (0 == duty100) {\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);\n\t\treturn 0;\n\t}\n\n\ttmp64 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin * duty100;\n\tdo_div(tmp64, 10000);\n\tfdo_min = (uint16_t)tmp64;\n\n\tt_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usTMed - hwmgr->thermal_controller.advanceFanControlParameters.usTMin;\n\tt_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usTHigh - hwmgr->thermal_controller.advanceFanControlParameters.usTMed;\n\n\tpwm_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin;\n\tpwm_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed;\n\n\tslope1 = (uint16_t)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\n\tslope2 = (uint16_t)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\n\n\tfan_table.TempMin = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMin) / 100);\n\tfan_table.TempMed = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMed) / 100);\n\tfan_table.TempMax = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMax) / 100);\n\n\tfan_table.Slope1 = cpu_to_be16(slope1);\n\tfan_table.Slope2 = cpu_to_be16(slope2);\n\n\tfan_table.FdoMin = cpu_to_be16(fdo_min);\n\n\tfan_table.HystDown = cpu_to_be16(hwmgr->thermal_controller.advanceFanControlParameters.ucTHyst);\n\n\tfan_table.HystUp = cpu_to_be16(1);\n\n\tfan_table.HystSlope = cpu_to_be16(1);\n\n\tfan_table.TempRespLim = cpu_to_be16(5);\n\n\treference_clock = amdgpu_asic_get_xclk((struct amdgpu_device *)hwmgr->adev);\n\n\tfan_table.RefreshPeriod = cpu_to_be32((hwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay * reference_clock) / 1600);\n\n\tfan_table.FdoMax = cpu_to_be16((uint16_t)duty100);\n\n\tfan_table.TempSrc = (uint8_t)PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_MULT_THERMAL_CTRL, TEMP_SEL);\n\n\tres = ci_copy_bytes_to_smc(hwmgr, ci_data->fan_table_start, (uint8_t *)&fan_table, (uint32_t)sizeof(fan_table), SMC_RAM_END);\n\n\treturn res;\n}\n\nstatic int ci_program_mem_timing_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tif (data->need_update_smu7_dpm_table &\n\t\t\t(DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_OD_UPDATE_MCLK))\n\t\treturn ci_program_memory_timing_parameters(hwmgr);\n\n\treturn 0;\n}\n\nstatic int ci_update_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\n\tint result = 0;\n\tuint32_t low_sclk_interrupt_threshold = 0;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SclkThrottleLowNotification)\n\t\t&& (data->low_sclk_interrupt_threshold != 0)) {\n\t\tlow_sclk_interrupt_threshold =\n\t\t\t\tdata->low_sclk_interrupt_threshold;\n\n\t\tCONVERT_FROM_HOST_TO_SMC_UL(low_sclk_interrupt_threshold);\n\n\t\tresult = ci_copy_bytes_to_smc(\n\t\t\t\thwmgr,\n\t\t\t\tsmu_data->dpm_table_start +\n\t\t\t\toffsetof(SMU7_Discrete_DpmTable,\n\t\t\t\t\tLowSclkInterruptT),\n\t\t\t\t(uint8_t *)&low_sclk_interrupt_threshold,\n\t\t\t\tsizeof(uint32_t),\n\t\t\t\tSMC_RAM_END);\n\t}\n\n\tresult = ci_update_and_upload_mc_reg_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE((0 == result), \"Failed to upload MC reg table!\", return result);\n\n\tresult = ci_program_mem_timing_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t\"Failed to program memory timing parameters!\",\n\t\t\t);\n\n\treturn result;\n}\n\nstatic uint32_t ci_get_offsetof(uint32_t type, uint32_t member)\n{\n\tswitch (type) {\n\tcase SMU_SoftRegisters:\n\t\tswitch (member) {\n\t\tcase HandshakeDisables:\n\t\t\treturn offsetof(SMU7_SoftRegisters, HandshakeDisables);\n\t\tcase VoltageChangeTimeout:\n\t\t\treturn offsetof(SMU7_SoftRegisters, VoltageChangeTimeout);\n\t\tcase AverageGraphicsActivity:\n\t\t\treturn offsetof(SMU7_SoftRegisters, AverageGraphicsA);\n\t\tcase AverageMemoryActivity:\n\t\t\treturn offsetof(SMU7_SoftRegisters, AverageMemoryA);\n\t\tcase PreVBlankGap:\n\t\t\treturn offsetof(SMU7_SoftRegisters, PreVBlankGap);\n\t\tcase VBlankTimeout:\n\t\t\treturn offsetof(SMU7_SoftRegisters, VBlankTimeout);\n\t\tcase DRAM_LOG_ADDR_H:\n\t\t\treturn offsetof(SMU7_SoftRegisters, DRAM_LOG_ADDR_H);\n\t\tcase DRAM_LOG_ADDR_L:\n\t\t\treturn offsetof(SMU7_SoftRegisters, DRAM_LOG_ADDR_L);\n\t\tcase DRAM_LOG_PHY_ADDR_H:\n\t\t\treturn offsetof(SMU7_SoftRegisters, DRAM_LOG_PHY_ADDR_H);\n\t\tcase DRAM_LOG_PHY_ADDR_L:\n\t\t\treturn offsetof(SMU7_SoftRegisters, DRAM_LOG_PHY_ADDR_L);\n\t\tcase DRAM_LOG_BUFF_SIZE:\n\t\t\treturn offsetof(SMU7_SoftRegisters, DRAM_LOG_BUFF_SIZE);\n\t\t}\n\t\tbreak;\n\tcase SMU_Discrete_DpmTable:\n\t\tswitch (member) {\n\t\tcase LowSclkInterruptThreshold:\n\t\t\treturn offsetof(SMU7_Discrete_DpmTable, LowSclkInterruptT);\n\t\t}\n\t\tbreak;\n\t}\n\tpr_debug(\"can't get the offset of type %x member %x\\n\", type, member);\n\treturn 0;\n}\n\nstatic uint32_t ci_get_mac_definition(uint32_t value)\n{\n\tswitch (value) {\n\tcase SMU_MAX_LEVELS_GRAPHICS:\n\t\treturn SMU7_MAX_LEVELS_GRAPHICS;\n\tcase SMU_MAX_LEVELS_MEMORY:\n\t\treturn SMU7_MAX_LEVELS_MEMORY;\n\tcase SMU_MAX_LEVELS_LINK:\n\t\treturn SMU7_MAX_LEVELS_LINK;\n\tcase SMU_MAX_ENTRIES_SMIO:\n\t\treturn SMU7_MAX_ENTRIES_SMIO;\n\tcase SMU_MAX_LEVELS_VDDC:\n\t\treturn SMU7_MAX_LEVELS_VDDC;\n\tcase SMU_MAX_LEVELS_VDDCI:\n\t\treturn SMU7_MAX_LEVELS_VDDCI;\n\tcase SMU_MAX_LEVELS_MVDD:\n\t\treturn SMU7_MAX_LEVELS_MVDD;\n\t}\n\n\tpr_debug(\"can't get the mac of %x\\n\", value);\n\treturn 0;\n}\n\nstatic int ci_load_smc_ucode(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t byte_count, start_addr;\n\tuint8_t *src;\n\tuint32_t data;\n\n\tstruct cgs_firmware_info info = {0};\n\n\tcgs_get_firmware_info(hwmgr->device, CGS_UCODE_ID_SMU, &info);\n\n\thwmgr->is_kicker = info.is_kicker;\n\thwmgr->smu_version = info.version;\n\tbyte_count = info.image_size;\n\tsrc = (uint8_t *)info.kptr;\n\tstart_addr = info.ucode_start_address;\n\n\tif  (byte_count > SMC_RAM_END) {\n\t\tpr_err(\"SMC address is beyond the SMC RAM area.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcgs_write_register(hwmgr->device, mmSMC_IND_INDEX_0, start_addr);\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);\n\n\tfor (; byte_count >= 4; byte_count -= 4) {\n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\t\tcgs_write_register(hwmgr->device, mmSMC_IND_DATA_0, data);\n\t\tsrc += 4;\n\t}\n\tPHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\n\n\tif (0 != byte_count) {\n\t\tpr_err(\"SMC size must be divisible by 4\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_upload_firmware(struct pp_hwmgr *hwmgr)\n{\n\tif (ci_is_smc_ram_running(hwmgr)) {\n\t\tpr_info(\"smc is running, no need to load smc firmware\\n\");\n\t\treturn 0;\n\t}\n\tPHM_WAIT_INDIRECT_FIELD(hwmgr, SMC_IND, RCU_UC_EVENTS,\n\t\t\tboot_seq_done, 1);\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_MISC_CNTL,\n\t\t\tpre_fetcher_en, 1);\n\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable, 1);\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_RESET_CNTL, rst_reg, 1);\n\treturn ci_load_smc_ucode(hwmgr);\n}\n\nstatic int ci_process_firmware_header(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *ci_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\n\tuint32_t tmp = 0;\n\tint result;\n\tbool error = false;\n\n\tif (ci_upload_firmware(hwmgr))\n\t\treturn -EINVAL;\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, DpmTable),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\tci_data->dpm_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, SoftRegisters),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result) {\n\t\tdata->soft_regs_start = tmp;\n\t\tci_data->soft_regs_start = tmp;\n\t}\n\n\terror |= (0 != result);\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, mcRegisterTable),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\tci_data->mc_reg_table_start = tmp;\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, FanTable),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\tci_data->fan_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, mcArbDramTimingTable),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\tci_data->arb_table_start = tmp;\n\n\terror |= (0 != result);\n\n\tresult = ci_read_smc_sram_dword(hwmgr,\n\t\t\t\tSMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\toffsetof(SMU7_Firmware_Header, Version),\n\t\t\t\t&tmp, SMC_RAM_END);\n\n\tif (0 == result)\n\t\thwmgr->microcode_version_info.SMC = tmp;\n\n\terror |= (0 != result);\n\n\treturn error ? 1 : 0;\n}\n\nstatic uint8_t ci_get_memory_modile_index(struct pp_hwmgr *hwmgr)\n{\n\treturn (uint8_t) (0xFF & (cgs_read_register(hwmgr->device, mmBIOS_SCRATCH_4) >> 16));\n}\n\nstatic bool ci_check_s0_mc_reg_index(uint16_t in_reg, uint16_t *out_reg)\n{\n\tbool result = true;\n\n\tswitch (in_reg) {\n\tcase  mmMC_SEQ_RAS_TIMING:\n\t\t*out_reg = mmMC_SEQ_RAS_TIMING_LP;\n\t\tbreak;\n\n\tcase  mmMC_SEQ_DLL_STBY:\n\t\t*out_reg = mmMC_SEQ_DLL_STBY_LP;\n\t\tbreak;\n\n\tcase  mmMC_SEQ_G5PDX_CMD0:\n\t\t*out_reg = mmMC_SEQ_G5PDX_CMD0_LP;\n\t\tbreak;\n\n\tcase  mmMC_SEQ_G5PDX_CMD1:\n\t\t*out_reg = mmMC_SEQ_G5PDX_CMD1_LP;\n\t\tbreak;\n\n\tcase  mmMC_SEQ_G5PDX_CTRL:\n\t\t*out_reg = mmMC_SEQ_G5PDX_CTRL_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_CAS_TIMING:\n\t\t*out_reg = mmMC_SEQ_CAS_TIMING_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_MISC_TIMING:\n\t\t*out_reg = mmMC_SEQ_MISC_TIMING_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_MISC_TIMING2:\n\t\t*out_reg = mmMC_SEQ_MISC_TIMING2_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_PMG_DVS_CMD:\n\t\t*out_reg = mmMC_SEQ_PMG_DVS_CMD_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_PMG_DVS_CTL:\n\t\t*out_reg = mmMC_SEQ_PMG_DVS_CTL_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_RD_CTL_D0:\n\t\t*out_reg = mmMC_SEQ_RD_CTL_D0_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_RD_CTL_D1:\n\t\t*out_reg = mmMC_SEQ_RD_CTL_D1_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_WR_CTL_D0:\n\t\t*out_reg = mmMC_SEQ_WR_CTL_D0_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_WR_CTL_D1:\n\t\t*out_reg = mmMC_SEQ_WR_CTL_D1_LP;\n\t\tbreak;\n\n\tcase mmMC_PMG_CMD_EMRS:\n\t\t*out_reg = mmMC_SEQ_PMG_CMD_EMRS_LP;\n\t\tbreak;\n\n\tcase mmMC_PMG_CMD_MRS:\n\t\t*out_reg = mmMC_SEQ_PMG_CMD_MRS_LP;\n\t\tbreak;\n\n\tcase mmMC_PMG_CMD_MRS1:\n\t\t*out_reg = mmMC_SEQ_PMG_CMD_MRS1_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_PMG_TIMING:\n\t\t*out_reg = mmMC_SEQ_PMG_TIMING_LP;\n\t\tbreak;\n\n\tcase mmMC_PMG_CMD_MRS2:\n\t\t*out_reg = mmMC_SEQ_PMG_CMD_MRS2_LP;\n\t\tbreak;\n\n\tcase mmMC_SEQ_WR_CTL_2:\n\t\t*out_reg = mmMC_SEQ_WR_CTL_2_LP;\n\t\tbreak;\n\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int ci_set_s0_mc_reg_index(struct ci_mc_reg_table *table)\n{\n\tuint32_t i;\n\tuint16_t address;\n\n\tfor (i = 0; i < table->last; i++) {\n\t\ttable->mc_reg_address[i].s0 =\n\t\t\tci_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address)\n\t\t\t? address : table->mc_reg_address[i].s1;\n\t}\n\treturn 0;\n}\n\nstatic int ci_copy_vbios_smc_reg_table(const pp_atomctrl_mc_reg_table *table,\n\t\t\t\t\tstruct ci_mc_reg_table *ni_table)\n{\n\tuint8_t i, j;\n\n\tPP_ASSERT_WITH_CODE((table->last <= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),\n\t\t\"Invalid VramInfo table.\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE((table->num_entries <= MAX_AC_TIMING_ENTRIES),\n\t\t\"Invalid VramInfo table.\", return -EINVAL);\n\n\tfor (i = 0; i < table->last; i++)\n\t\tni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\n\n\tni_table->last = table->last;\n\n\tfor (i = 0; i < table->num_entries; i++) {\n\t\tni_table->mc_reg_table_entry[i].mclk_max =\n\t\t\ttable->mc_reg_table_entry[i].mclk_max;\n\t\tfor (j = 0; j < table->last; j++) {\n\t\t\tni_table->mc_reg_table_entry[i].mc_data[j] =\n\t\t\t\ttable->mc_reg_table_entry[i].mc_data[j];\n\t\t}\n\t}\n\n\tni_table->num_entries = table->num_entries;\n\n\treturn 0;\n}\n\nstatic int ci_set_mc_special_registers(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tstruct ci_mc_reg_table *table)\n{\n\tuint8_t i, j, k;\n\tuint32_t temp_reg;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\n\tfor (i = 0, j = table->last; i < table->last; i++) {\n\t\tPP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),\n\t\t\t\"Invalid VramInfo table.\", return -EINVAL);\n\n\t\tswitch (table->mc_reg_address[i].s1) {\n\n\t\tcase mmMC_SEQ_MISC1:\n\t\t\ttemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_EMRS);\n\t\t\ttable->mc_reg_address[j].s1 = mmMC_PMG_CMD_EMRS;\n\t\t\ttable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_EMRS_LP;\n\t\t\tfor (k = 0; k < table->num_entries; k++) {\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t((temp_reg & 0xffff0000)) |\n\t\t\t\t\t((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\n\t\t\t}\n\t\t\tj++;\n\n\t\t\tPP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),\n\t\t\t\t\"Invalid VramInfo table.\", return -EINVAL);\n\t\t\ttemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS);\n\t\t\ttable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS;\n\t\t\ttable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS_LP;\n\t\t\tfor (k = 0; k < table->num_entries; k++) {\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\n\t\t\t\tif (!data->is_memory_gddr5)\n\t\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\n\t\t\t}\n\t\t\tj++;\n\n\t\t\tif (!data->is_memory_gddr5) {\n\t\t\t\tPP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),\n\t\t\t\t\t\"Invalid VramInfo table.\", return -EINVAL);\n\t\t\t\ttable->mc_reg_address[j].s1 = mmMC_PMG_AUTO_CMD;\n\t\t\t\ttable->mc_reg_address[j].s0 = mmMC_PMG_AUTO_CMD;\n\t\t\t\tfor (k = 0; k < table->num_entries; k++) {\n\t\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase mmMC_SEQ_RESERVE_M:\n\t\t\ttemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1);\n\t\t\ttable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS1;\n\t\t\ttable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS1_LP;\n\t\t\tfor (k = 0; k < table->num_entries; k++) {\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\t\t\t}\n\t\t\tj++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\ttable->last = j;\n\n\treturn 0;\n}\n\nstatic int ci_set_valid_flag(struct ci_mc_reg_table *table)\n{\n\tuint8_t i, j;\n\n\tfor (i = 0; i < table->last; i++) {\n\t\tfor (j = 1; j < table->num_entries; j++) {\n\t\t\tif (table->mc_reg_table_entry[j-1].mc_data[i] !=\n\t\t\t\ttable->mc_reg_table_entry[j].mc_data[i]) {\n\t\t\t\ttable->validflag |= (1 << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)(hwmgr->smu_backend);\n\tpp_atomctrl_mc_reg_table *table;\n\tstruct ci_mc_reg_table *ni_table = &smu_data->mc_reg_table;\n\tuint8_t module_index = ci_get_memory_modile_index(hwmgr);\n\n\ttable = kzalloc(sizeof(pp_atomctrl_mc_reg_table), GFP_KERNEL);\n\n\tif (NULL == table)\n\t\treturn -ENOMEM;\n\n\t \n\tcgs_write_register(hwmgr->device, mmMC_SEQ_RAS_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RAS_TIMING));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_CAS_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_CAS_TIMING));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_DLL_STBY_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_DLL_STBY));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_EMRS_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_EMRS));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS1_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_TIMING));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS2_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS2));\n\tcgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_2_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_2));\n\n\tresult = atomctrl_initialize_mc_reg_table(hwmgr, module_index, table);\n\n\tif (0 == result)\n\t\tresult = ci_copy_vbios_smc_reg_table(table, ni_table);\n\n\tif (0 == result) {\n\t\tci_set_s0_mc_reg_index(ni_table);\n\t\tresult = ci_set_mc_special_registers(hwmgr, ni_table);\n\t}\n\n\tif (0 == result)\n\t\tci_set_valid_flag(ni_table);\n\n\tkfree(table);\n\n\treturn result;\n}\n\nstatic bool ci_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\treturn ci_is_smc_ram_running(hwmgr);\n}\n\nstatic int ci_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct ci_smumgr *ci_priv;\n\n\tci_priv = kzalloc(sizeof(struct ci_smumgr), GFP_KERNEL);\n\n\tif (ci_priv == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = ci_priv;\n\n\treturn 0;\n}\n\nstatic int ci_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tkfree(hwmgr->smu_backend);\n\thwmgr->smu_backend = NULL;\n\treturn 0;\n}\n\nstatic int ci_start_smu(struct pp_hwmgr *hwmgr)\n{\n\treturn 0;\n}\n\nstatic int ci_update_dpm_settings(struct pp_hwmgr *hwmgr,\n\t\t\t\tvoid *profile_setting)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct ci_smumgr *smu_data = (struct ci_smumgr *)\n\t\t\t(hwmgr->smu_backend);\n\tstruct profile_mode_setting *setting;\n\tstruct SMU7_Discrete_GraphicsLevel *levels =\n\t\t\tsmu_data->smc_state_table.GraphicsLevel;\n\tuint32_t array = smu_data->dpm_table_start +\n\t\t\toffsetof(SMU7_Discrete_DpmTable, GraphicsLevel);\n\n\tuint32_t mclk_array = smu_data->dpm_table_start +\n\t\t\toffsetof(SMU7_Discrete_DpmTable, MemoryLevel);\n\tstruct SMU7_Discrete_MemoryLevel *mclk_levels =\n\t\t\tsmu_data->smc_state_table.MemoryLevel;\n\tuint32_t i;\n\tuint32_t offset, up_hyst_offset, down_hyst_offset, clk_activity_offset, tmp;\n\n\tif (profile_setting == NULL)\n\t\treturn -EINVAL;\n\n\tsetting = (struct profile_mode_setting *)profile_setting;\n\n\tif (setting->bupdate_sclk) {\n\t\tif (!data->sclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_FreezeLevel, NULL);\n\t\tfor (i = 0; i < smu_data->smc_state_table.GraphicsDpmLevelCount; i++) {\n\t\t\tif (levels[i].ActivityLevel !=\n\t\t\t\tcpu_to_be16(setting->sclk_activity)) {\n\t\t\t\tlevels[i].ActivityLevel = cpu_to_be16(setting->sclk_activity);\n\n\t\t\t\tclk_activity_offset = array + (sizeof(SMU7_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_GraphicsLevel, ActivityLevel);\n\t\t\t\toffset = clk_activity_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(clk_activity_offset, tmp, levels[i].ActivityLevel, sizeof(uint16_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\n\t\t\t}\n\t\t\tif (levels[i].UpH != setting->sclk_up_hyst ||\n\t\t\t\tlevels[i].DownH != setting->sclk_down_hyst) {\n\t\t\t\tlevels[i].UpH = setting->sclk_up_hyst;\n\t\t\t\tlevels[i].DownH = setting->sclk_down_hyst;\n\t\t\t\tup_hyst_offset = array + (sizeof(SMU7_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_GraphicsLevel, UpH);\n\t\t\t\tdown_hyst_offset = array + (sizeof(SMU7_Discrete_GraphicsLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_GraphicsLevel, DownH);\n\t\t\t\toffset = up_hyst_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(up_hyst_offset, tmp, levels[i].UpH, sizeof(uint8_t));\n\t\t\t\ttmp = phm_set_field_to_u32(down_hyst_offset, tmp, levels[i].DownH, sizeof(uint8_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\t\t\t}\n\t\t}\n\t\tif (!data->sclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_UnfreezeLevel, NULL);\n\t}\n\n\tif (setting->bupdate_mclk) {\n\t\tif (!data->mclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_FreezeLevel, NULL);\n\t\tfor (i = 0; i < smu_data->smc_state_table.MemoryDpmLevelCount; i++) {\n\t\t\tif (mclk_levels[i].ActivityLevel !=\n\t\t\t\tcpu_to_be16(setting->mclk_activity)) {\n\t\t\t\tmclk_levels[i].ActivityLevel = cpu_to_be16(setting->mclk_activity);\n\n\t\t\t\tclk_activity_offset = mclk_array + (sizeof(SMU7_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_MemoryLevel, ActivityLevel);\n\t\t\t\toffset = clk_activity_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(clk_activity_offset, tmp, mclk_levels[i].ActivityLevel, sizeof(uint16_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\n\t\t\t}\n\t\t\tif (mclk_levels[i].UpH != setting->mclk_up_hyst ||\n\t\t\t\tmclk_levels[i].DownH != setting->mclk_down_hyst) {\n\t\t\t\tmclk_levels[i].UpH = setting->mclk_up_hyst;\n\t\t\t\tmclk_levels[i].DownH = setting->mclk_down_hyst;\n\t\t\t\tup_hyst_offset = mclk_array + (sizeof(SMU7_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_MemoryLevel, UpH);\n\t\t\t\tdown_hyst_offset = mclk_array + (sizeof(SMU7_Discrete_MemoryLevel) * i)\n\t\t\t\t\t\t+ offsetof(SMU7_Discrete_MemoryLevel, DownH);\n\t\t\t\toffset = up_hyst_offset & ~0x3;\n\t\t\t\ttmp = PP_HOST_TO_SMC_UL(cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset));\n\t\t\t\ttmp = phm_set_field_to_u32(up_hyst_offset, tmp, mclk_levels[i].UpH, sizeof(uint8_t));\n\t\t\t\ttmp = phm_set_field_to_u32(down_hyst_offset, tmp, mclk_levels[i].DownH, sizeof(uint8_t));\n\t\t\t\tcgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(tmp));\n\t\t\t}\n\t\t}\n\t\tif (!data->mclk_dpm_key_disabled)\n\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_UnfreezeLevel, NULL);\n\t}\n\treturn 0;\n}\n\nstatic int ci_update_uvd_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct smu7_hwmgr *data = hwmgr->backend;\n\tstruct ci_smumgr *smu_data = hwmgr->smu_backend;\n\tstruct phm_uvd_clock_voltage_dependency_table *uvd_table =\n\t\t\thwmgr->dyn_state.uvd_clock_voltage_dependency_table;\n\tuint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_PEAK;\n\tuint32_t max_vddc = adev->pm.ac_power ? hwmgr->dyn_state.max_clock_voltage_on_ac.vddc :\n\t\t\t\t\t\thwmgr->dyn_state.max_clock_voltage_on_dc.vddc;\n\tint32_t i;\n\n\tif (PP_CAP(PHM_PlatformCaps_UVDDPM) || uvd_table->count <= 0)\n\t\tsmu_data->smc_state_table.UvdBootLevel = 0;\n\telse\n\t\tsmu_data->smc_state_table.UvdBootLevel = uvd_table->count - 1;\n\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, DPM_TABLE_475,\n\t\t\t\tUvdBootLevel, smu_data->smc_state_table.UvdBootLevel);\n\n\tdata->dpm_level_enable_mask.uvd_dpm_enable_mask = 0;\n\n\tfor (i = uvd_table->count - 1; i >= 0; i--) {\n\t\tif (uvd_table->entries[i].v <= max_vddc)\n\t\t\tdata->dpm_level_enable_mask.uvd_dpm_enable_mask |= 1 << i;\n\t\tif (hwmgr->dpm_level & profile_mode_mask || !PP_CAP(PHM_PlatformCaps_UVDDPM))\n\t\t\tbreak;\n\t}\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_UVDDPM_SetEnabledMask,\n\t\t\t\tdata->dpm_level_enable_mask.uvd_dpm_enable_mask,\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int ci_update_vce_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct smu7_hwmgr *data = hwmgr->backend;\n\tstruct phm_vce_clock_voltage_dependency_table *vce_table =\n\t\t\thwmgr->dyn_state.vce_clock_voltage_dependency_table;\n\tuint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_PEAK;\n\tuint32_t max_vddc = adev->pm.ac_power ? hwmgr->dyn_state.max_clock_voltage_on_ac.vddc :\n\t\t\t\t\t\thwmgr->dyn_state.max_clock_voltage_on_dc.vddc;\n\tint32_t i;\n\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, DPM_TABLE_475,\n\t\t\t\tVceBootLevel, 0);  \n\n\tdata->dpm_level_enable_mask.vce_dpm_enable_mask = 0;\n\n\tfor (i = vce_table->count - 1; i >= 0; i--) {\n\t\tif (vce_table->entries[i].v <= max_vddc)\n\t\t\tdata->dpm_level_enable_mask.vce_dpm_enable_mask |= 1 << i;\n\t\tif (hwmgr->dpm_level & profile_mode_mask || !PP_CAP(PHM_PlatformCaps_VCEDPM))\n\t\t\tbreak;\n\t}\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_VCEDPM_SetEnabledMask,\n\t\t\t\tdata->dpm_level_enable_mask.vce_dpm_enable_mask,\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic int ci_update_smc_table(struct pp_hwmgr *hwmgr, uint32_t type)\n{\n\tswitch (type) {\n\tcase SMU_UVD_TABLE:\n\t\tci_update_uvd_smc_table(hwmgr);\n\t\tbreak;\n\tcase SMU_VCE_TABLE:\n\t\tci_update_vce_smc_table(hwmgr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void ci_reset_smc(struct pp_hwmgr *hwmgr)\n{\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t  SMC_SYSCON_RESET_CNTL,\n\t\t\t\t  rst_reg, 1);\n}\n\n\nstatic void ci_stop_smc_clock(struct pp_hwmgr *hwmgr)\n{\n\tPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,\n\t\t\t\t  SMC_SYSCON_CLOCK_CNTL_0,\n\t\t\t\t  ck_disable, 1);\n}\n\nstatic int ci_stop_smc(struct pp_hwmgr *hwmgr)\n{\n\tci_reset_smc(hwmgr);\n\tci_stop_smc_clock(hwmgr);\n\n\treturn 0;\n}\n\nconst struct pp_smumgr_func ci_smu_funcs = {\n\t.name = \"ci_smu\",\n\t.smu_init = ci_smu_init,\n\t.smu_fini = ci_smu_fini,\n\t.start_smu = ci_start_smu,\n\t.check_fw_load_finish = NULL,\n\t.request_smu_load_fw = NULL,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = ci_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = ci_send_msg_to_smc_with_parameter,\n\t.get_argument = smu7_get_argument,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.get_offsetof = ci_get_offsetof,\n\t.process_firmware_header = ci_process_firmware_header,\n\t.init_smc_table = ci_init_smc_table,\n\t.update_sclk_threshold = ci_update_sclk_threshold,\n\t.thermal_setup_fan_table = ci_thermal_setup_fan_table,\n\t.populate_all_graphic_levels = ci_populate_all_graphic_levels,\n\t.populate_all_memory_levels = ci_populate_all_memory_levels,\n\t.get_mac_definition = ci_get_mac_definition,\n\t.initialize_mc_reg_table = ci_initialize_mc_reg_table,\n\t.is_dpm_running = ci_is_dpm_running,\n\t.update_dpm_settings = ci_update_dpm_settings,\n\t.update_smc_table = ci_update_smc_table,\n\t.stop_smc = ci_stop_smc,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}