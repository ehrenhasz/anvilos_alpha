{
  "module_name": "common_baco.c",
  "hash_id": "4df9de618ee7cbf61304db1e5d2e9c70000cb4c72bc804a9ecd81bb554a51949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/common_baco.c",
  "human_readable_source": " \n\n#include \"common_baco.h\"\n\n\nstatic bool baco_wait_register(struct pp_hwmgr *hwmgr, u32 reg, u32 mask, u32 value)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tu32 timeout = 5000, data;\n\n\tdo {\n\t\tmsleep(1);\n\t\tdata = RREG32(reg);\n\t\ttimeout--;\n\t} while (value != (data & mask) && (timeout != 0));\n\n\tif (timeout == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool baco_cmd_handler(struct pp_hwmgr *hwmgr, u32 command, u32 reg, u32 mask,\n\t\t\t\tu32 shift, u32 value, u32 timeout)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tu32 data;\n\tbool ret = true;\n\n\tswitch (command) {\n\tcase CMD_WRITE:\n\t\tWREG32(reg, value << shift);\n\t\tbreak;\n\tcase CMD_READMODIFYWRITE:\n\t\tdata = RREG32(reg);\n\t\tdata = (data & (~mask)) | (value << shift);\n\t\tWREG32(reg, data);\n\t\tbreak;\n\tcase CMD_WAITFOR:\n\t\tret = baco_wait_register(hwmgr, reg, mask, value);\n\t\tbreak;\n\tcase CMD_DELAY_MS:\n\t\tif (timeout)\n\t\t\t \n\t\t\tmsleep(timeout);\n\t\tbreak;\n\tcase CMD_DELAY_US:\n\t\tif (timeout)\n\t\t\t \n\t\t\tudelay(timeout);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(adev->dev, \"Invalid BACO command.\\n\");\n\t\tret = false;\n\t}\n\n\treturn ret;\n}\n\nbool baco_program_registers(struct pp_hwmgr *hwmgr,\n\t\t\t    const struct baco_cmd_entry *entry,\n\t\t\t    const u32 array_size)\n{\n\tu32 i, reg = 0;\n\n\tfor (i = 0; i < array_size; i++) {\n\t\tif ((entry[i].cmd == CMD_WRITE) ||\n\t\t    (entry[i].cmd == CMD_READMODIFYWRITE) ||\n\t\t    (entry[i].cmd == CMD_WAITFOR))\n\t\t\treg = entry[i].reg_offset;\n\t\tif (!baco_cmd_handler(hwmgr, entry[i].cmd, reg, entry[i].mask,\n\t\t\t\t     entry[i].shift, entry[i].val, entry[i].timeout))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool soc15_baco_program_registers(struct pp_hwmgr *hwmgr,\n\t\t\t\t const struct soc15_baco_cmd_entry *entry,\n\t\t\t\t const u32 array_size)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tu32 i, reg = 0;\n\n\tfor (i = 0; i < array_size; i++) {\n\t\tif ((entry[i].cmd == CMD_WRITE) ||\n\t\t    (entry[i].cmd == CMD_READMODIFYWRITE) ||\n\t\t    (entry[i].cmd == CMD_WAITFOR))\n\t\t\treg = adev->reg_offset[entry[i].hwip][entry[i].inst][entry[i].seg]\n\t\t\t\t+ entry[i].reg_offset;\n\t\tif (!baco_cmd_handler(hwmgr, entry[i].cmd, reg, entry[i].mask,\n\t\t\t\t     entry[i].shift, entry[i].val, entry[i].timeout))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}