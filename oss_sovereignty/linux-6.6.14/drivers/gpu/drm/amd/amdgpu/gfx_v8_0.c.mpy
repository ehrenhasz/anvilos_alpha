{
  "module_name": "gfx_v8_0.c",
  "hash_id": "e6e9861b646970d5bdcfee5c15c75574308dd3f45286ecb62fa66bd9f2d06c20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"amdgpu_ring.h\"\n#include \"vi.h\"\n#include \"vi_structs.h\"\n#include \"vid.h\"\n#include \"amdgpu_ucode.h\"\n#include \"amdgpu_atombios.h\"\n#include \"atombios_i2c.h\"\n#include \"clearstate_vi.h\"\n\n#include \"gmc/gmc_8_2_d.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n\n#include \"oss/oss_3_0_d.h\"\n#include \"oss/oss_3_0_sh_mask.h\"\n\n#include \"bif/bif_5_0_d.h\"\n#include \"bif/bif_5_0_sh_mask.h\"\n#include \"gca/gfx_8_0_d.h\"\n#include \"gca/gfx_8_0_enum.h\"\n#include \"gca/gfx_8_0_sh_mask.h\"\n\n#include \"dce/dce_10_0_d.h\"\n#include \"dce/dce_10_0_sh_mask.h\"\n\n#include \"smu/smu_7_1_3_d.h\"\n\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n\n#define GFX8_NUM_GFX_RINGS     1\n#define GFX8_MEC_HPD_SIZE 4096\n\n#define TOPAZ_GB_ADDR_CONFIG_GOLDEN 0x22010001\n#define CARRIZO_GB_ADDR_CONFIG_GOLDEN 0x22010001\n#define POLARIS11_GB_ADDR_CONFIG_GOLDEN 0x22011002\n#define TONGA_GB_ADDR_CONFIG_GOLDEN 0x22011003\n\n#define ARRAY_MODE(x)\t\t\t\t\t((x) << GB_TILE_MODE0__ARRAY_MODE__SHIFT)\n#define PIPE_CONFIG(x)\t\t\t\t\t((x) << GB_TILE_MODE0__PIPE_CONFIG__SHIFT)\n#define TILE_SPLIT(x)\t\t\t\t\t((x) << GB_TILE_MODE0__TILE_SPLIT__SHIFT)\n#define MICRO_TILE_MODE_NEW(x)\t\t\t\t((x) << GB_TILE_MODE0__MICRO_TILE_MODE_NEW__SHIFT)\n#define SAMPLE_SPLIT(x)\t\t\t\t\t((x) << GB_TILE_MODE0__SAMPLE_SPLIT__SHIFT)\n#define BANK_WIDTH(x)\t\t\t\t\t((x) << GB_MACROTILE_MODE0__BANK_WIDTH__SHIFT)\n#define BANK_HEIGHT(x)\t\t\t\t\t((x) << GB_MACROTILE_MODE0__BANK_HEIGHT__SHIFT)\n#define MACRO_TILE_ASPECT(x)\t\t\t\t((x) << GB_MACROTILE_MODE0__MACRO_TILE_ASPECT__SHIFT)\n#define NUM_BANKS(x)\t\t\t\t\t((x) << GB_MACROTILE_MODE0__NUM_BANKS__SHIFT)\n\n#define RLC_CGTT_MGCG_OVERRIDE__CPF_MASK            0x00000001L\n#define RLC_CGTT_MGCG_OVERRIDE__RLC_MASK            0x00000002L\n#define RLC_CGTT_MGCG_OVERRIDE__MGCG_MASK           0x00000004L\n#define RLC_CGTT_MGCG_OVERRIDE__CGCG_MASK           0x00000008L\n#define RLC_CGTT_MGCG_OVERRIDE__CGLS_MASK           0x00000010L\n#define RLC_CGTT_MGCG_OVERRIDE__GRBM_MASK           0x00000020L\n\n \n#define SET_BPM_SERDES_CMD    1\n#define CLE_BPM_SERDES_CMD    0\n\n \nenum {\n\tBPM_REG_CGLS_EN = 0,         \n\tBPM_REG_CGLS_ON,             \n\tBPM_REG_CGCG_OVERRIDE,       \n\tBPM_REG_MGCG_OVERRIDE,       \n\tBPM_REG_FGCG_OVERRIDE,       \n\tBPM_REG_FGCG_MAX\n};\n\n#define RLC_FormatDirectRegListLength        14\n\nMODULE_FIRMWARE(\"amdgpu/carrizo_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/carrizo_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/carrizo_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/carrizo_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/carrizo_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/carrizo_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/stoney_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/stoney_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/stoney_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/stoney_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/stoney_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/tonga_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/tonga_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/tonga_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/tonga_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/tonga_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/tonga_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/topaz_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/topaz_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/topaz_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/topaz_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/topaz_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/fiji_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/fiji_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/fiji_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/fiji_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/fiji_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/fiji_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/polaris10_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_ce_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_pfp_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_me_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_mec_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_mec2_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris10_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/polaris11_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_ce_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_pfp_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_me_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_mec_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_mec2_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris11_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/polaris12_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_ce_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_pfp_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_me_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_mec_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_mec2_2.bin\");\nMODULE_FIRMWARE(\"amdgpu/polaris12_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/vegam_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/vegam_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/vegam_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/vegam_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/vegam_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/vegam_rlc.bin\");\n\nstatic const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =\n{\n\t{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},\n\t{mmGDS_VMID1_BASE, mmGDS_VMID1_SIZE, mmGDS_GWS_VMID1, mmGDS_OA_VMID1},\n\t{mmGDS_VMID2_BASE, mmGDS_VMID2_SIZE, mmGDS_GWS_VMID2, mmGDS_OA_VMID2},\n\t{mmGDS_VMID3_BASE, mmGDS_VMID3_SIZE, mmGDS_GWS_VMID3, mmGDS_OA_VMID3},\n\t{mmGDS_VMID4_BASE, mmGDS_VMID4_SIZE, mmGDS_GWS_VMID4, mmGDS_OA_VMID4},\n\t{mmGDS_VMID5_BASE, mmGDS_VMID5_SIZE, mmGDS_GWS_VMID5, mmGDS_OA_VMID5},\n\t{mmGDS_VMID6_BASE, mmGDS_VMID6_SIZE, mmGDS_GWS_VMID6, mmGDS_OA_VMID6},\n\t{mmGDS_VMID7_BASE, mmGDS_VMID7_SIZE, mmGDS_GWS_VMID7, mmGDS_OA_VMID7},\n\t{mmGDS_VMID8_BASE, mmGDS_VMID8_SIZE, mmGDS_GWS_VMID8, mmGDS_OA_VMID8},\n\t{mmGDS_VMID9_BASE, mmGDS_VMID9_SIZE, mmGDS_GWS_VMID9, mmGDS_OA_VMID9},\n\t{mmGDS_VMID10_BASE, mmGDS_VMID10_SIZE, mmGDS_GWS_VMID10, mmGDS_OA_VMID10},\n\t{mmGDS_VMID11_BASE, mmGDS_VMID11_SIZE, mmGDS_GWS_VMID11, mmGDS_OA_VMID11},\n\t{mmGDS_VMID12_BASE, mmGDS_VMID12_SIZE, mmGDS_GWS_VMID12, mmGDS_OA_VMID12},\n\t{mmGDS_VMID13_BASE, mmGDS_VMID13_SIZE, mmGDS_GWS_VMID13, mmGDS_OA_VMID13},\n\t{mmGDS_VMID14_BASE, mmGDS_VMID14_SIZE, mmGDS_GWS_VMID14, mmGDS_OA_VMID14},\n\t{mmGDS_VMID15_BASE, mmGDS_VMID15_SIZE, mmGDS_GWS_VMID15, mmGDS_OA_VMID15}\n};\n\nstatic const u32 golden_settings_tonga_a11[] =\n{\n\tmmCB_HW_CONTROL, 0xfffdf3cf, 0x00007208,\n\tmmCB_HW_CONTROL_3, 0x00000040, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmGB_GPU_ID, 0x0000000f, 0x00000000,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_FIFO_DEPTH_CNTL, 0x000003ff, 0x000000fc,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0000003c,\n\tmmSQ_RANDOM_WAVE_PRI, 0x001fffff, 0x000006fd,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCC_EXE_DISABLE, 0x00000002, 0x00000002,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000002fb,\n\tmmTCP_CHAN_STEER_HI, 0xffffffff, 0x0000543b,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0xa9210876,\n\tmmVGT_RESET_DEBUG, 0x00000004, 0x00000004,\n};\n\nstatic const u32 tonga_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x16000012,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002A,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22011003,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF\n};\n\nstatic const u32 tonga_mgcg_cgcg_init[] =\n{\n\tmmRLC_CGTT_MGCG_OVERRIDE, 0xffffffff, 0xffffffff,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCB_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_BCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPF_CLK_CTRL, 0xffffffff, 0x40000100,\n\tmmCGTT_GDS_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_IA_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PA_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_WD_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_RLC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SPI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQ_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQG_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL0, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL1, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL2, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL3, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL4, 0xffffffff, 0x00000100,\n\tmmCGTT_TCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_TCP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_VGT_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmDB_CGTT_CLK_CTRL_0, 0xffffffff, 0x00000100,\n\tmmTA_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmTCA_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTCC_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTD_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCGTS_CU0_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU0_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU0_TA_SQC_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU0_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU0_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU1_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU1_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU1_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU1_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU1_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU2_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU2_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU2_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU2_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU2_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU3_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU3_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU3_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU3_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU3_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU4_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU4_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU4_TA_SQC_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU4_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU4_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU5_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU5_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU5_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU5_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU5_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU6_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU6_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU6_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU6_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU6_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU7_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU7_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU7_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU7_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU7_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_SM_CTRL_REG, 0xffffffff, 0x96e00200,\n\tmmCP_RB_WPTR_POLL_CNTL, 0xffffffff, 0x00900100,\n\tmmRLC_CGCG_CGLS_CTRL, 0xffffffff, 0x0020003c,\n\tmmCP_MEM_SLP_CNTL, 0x00000001, 0x00000001,\n};\n\nstatic const u32 golden_settings_vegam_a11[] =\n{\n\tmmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,\n\tmmCB_HW_CONTROL_2, 0x0f000000, 0x0d000000,\n\tmmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x3a00161a,\n\tmmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0001003c,\n\tmmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,\n\tmmSQ_CONFIG, 0x07f80000, 0x01180000,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,\n\tmmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0x32761054,\n\tmmVGT_RESET_DEBUG, 0x00000004, 0x00000004,\n};\n\nstatic const u32 vegam_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22011003,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,\n};\n\nstatic const u32 golden_settings_polaris11_a11[] =\n{\n\tmmCB_HW_CONTROL, 0x0000f3cf, 0x00007208,\n\tmmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,\n\tmmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x16000012,\n\tmmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0001003c,\n\tmmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,\n\tmmSQ_CONFIG, 0x07f80000, 0x01180000,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f3,\n\tmmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0x00003210,\n\tmmVGT_RESET_DEBUG, 0x00000004, 0x00000004,\n};\n\nstatic const u32 polaris11_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22011002,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,\n};\n\nstatic const u32 golden_settings_polaris10_a11[] =\n{\n\tmmATC_MISC_CG, 0x000c0fc0, 0x000c0200,\n\tmmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,\n\tmmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,\n\tmmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x16000012,\n\tmmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002a,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0001003c,\n\tmmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,\n\tmmSQ_CONFIG, 0x07f80000, 0x07180000,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,\n\tmmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,\n\tmmVGT_RESET_DEBUG, 0x00000004, 0x00000004,\n};\n\nstatic const u32 polaris10_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x16000012,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002A,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22011003,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,\n};\n\nstatic const u32 fiji_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x3a00161a,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22011003,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmSPI_CONFIG_CNTL_1, 0x0000000f, 0x00000009,\n};\n\nstatic const u32 golden_settings_fiji_a10[] =\n{\n\tmmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0001003c,\n\tmmSQ_RANDOM_WAVE_PRI, 0x001fffff, 0x000006fd,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCC_EXE_DISABLE, 0x00000002, 0x00000002,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000000ff,\n\tmmVGT_RESET_DEBUG, 0x00000004, 0x00000004,\n};\n\nstatic const u32 fiji_mgcg_cgcg_init[] =\n{\n\tmmRLC_CGTT_MGCG_OVERRIDE, 0xffffffff, 0xffffffff,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCB_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_BCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPF_CLK_CTRL, 0xffffffff, 0x40000100,\n\tmmCGTT_GDS_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_IA_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PA_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_WD_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_RLC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SPI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQ_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQG_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL0, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL1, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL2, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL3, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL4, 0xffffffff, 0x00000100,\n\tmmCGTT_TCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_TCP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_VGT_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmDB_CGTT_CLK_CTRL_0, 0xffffffff, 0x00000100,\n\tmmTA_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmTCA_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTCC_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTD_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCGTS_SM_CTRL_REG, 0xffffffff, 0x96e00200,\n\tmmCP_RB_WPTR_POLL_CNTL, 0xffffffff, 0x00900100,\n\tmmRLC_CGCG_CGLS_CTRL, 0xffffffff, 0x0020003c,\n\tmmCP_MEM_SLP_CNTL, 0x00000001, 0x00000001,\n};\n\nstatic const u32 golden_settings_iceland_a11[] =\n{\n\tmmCB_HW_CONTROL_3, 0x00000040, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmDB_DEBUG3, 0xc0000000, 0xc0000000,\n\tmmGB_GPU_ID, 0x0000000f, 0x00000000,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x00000002,\n\tmmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0000003c,\n\tmmSQ_RANDOM_WAVE_PRI, 0x001fffff, 0x000006fd,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCC_EXE_DISABLE, 0x00000002, 0x00000002,\n\tmmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f1,\n\tmmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0x00000010,\n};\n\nstatic const u32 iceland_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x00000002,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x00000000,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22010001,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF\n};\n\nstatic const u32 iceland_mgcg_cgcg_init[] =\n{\n\tmmRLC_CGTT_MGCG_OVERRIDE, 0xffffffff, 0xffffffff,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCB_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_BCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CP_CLK_CTRL, 0xffffffff, 0xc0000100,\n\tmmCGTT_CPC_CLK_CTRL, 0xffffffff, 0xc0000100,\n\tmmCGTT_CPF_CLK_CTRL, 0xffffffff, 0xc0000100,\n\tmmCGTT_GDS_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_IA_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PA_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_WD_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_RLC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SPI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQ_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQG_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL0, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL1, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL2, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL3, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL4, 0xffffffff, 0x00000100,\n\tmmCGTT_TCI_CLK_CTRL, 0xffffffff, 0xff000100,\n\tmmCGTT_TCP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_VGT_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmDB_CGTT_CLK_CTRL_0, 0xffffffff, 0x00000100,\n\tmmTA_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmTCA_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTCC_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTD_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCGTS_CU0_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU0_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU0_TA_SQC_CTRL_REG, 0xffffffff, 0x0f840f87,\n\tmmCGTS_CU0_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU0_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU1_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU1_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU1_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU1_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU1_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU2_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU2_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU2_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU2_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU2_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU3_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU3_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU3_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU3_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU3_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU4_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU4_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU4_TA_SQC_CTRL_REG, 0xffffffff, 0x0f840f87,\n\tmmCGTS_CU4_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU4_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU5_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU5_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU5_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU5_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU5_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_SM_CTRL_REG, 0xffffffff, 0x96e00200,\n\tmmCP_RB_WPTR_POLL_CNTL, 0xffffffff, 0x00900100,\n\tmmRLC_CGCG_CGLS_CTRL, 0xffffffff, 0x0020003c,\n};\n\nstatic const u32 cz_golden_settings_a11[] =\n{\n\tmmCB_HW_CONTROL_3, 0x00000040, 0x00000040,\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmGB_GPU_ID, 0x0000000f, 0x00000000,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x00000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0000003c,\n\tmmSQ_RANDOM_WAVE_PRI, 0x001fffff, 0x000006fd,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x00010000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCC_EXE_DISABLE, 0x00000002, 0x00000002,\n\tmmTCP_ADDR_CONFIG, 0x0000000f, 0x000000f3,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0x00001302\n};\n\nstatic const u32 cz_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x00000002,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x00000000,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x22010001,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF\n};\n\nstatic const u32 cz_mgcg_cgcg_init[] =\n{\n\tmmRLC_CGTT_MGCG_OVERRIDE, 0xffffffff, 0xffffffff,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCB_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_BCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_CPF_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_GDS_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_IA_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PA_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_WD_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmCGTT_PC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_RLC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SC_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SPI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQ_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SQG_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL0, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL1, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL2, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL3, 0xffffffff, 0x00000100,\n\tmmCGTT_SX_CLK_CTRL4, 0xffffffff, 0x00000100,\n\tmmCGTT_TCI_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_TCP_CLK_CTRL, 0xffffffff, 0x00000100,\n\tmmCGTT_VGT_CLK_CTRL, 0xffffffff, 0x06000100,\n\tmmDB_CGTT_CLK_CTRL_0, 0xffffffff, 0x00000100,\n\tmmTA_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmTCA_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTCC_CGTT_SCLK_CTRL, 0xffffffff, 0x00000100,\n\tmmTD_CGTT_CTRL, 0xffffffff, 0x00000100,\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmCGTS_CU0_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU0_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU0_TA_SQC_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU0_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU0_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU1_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU1_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU1_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU1_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU1_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU2_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU2_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU2_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU2_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU2_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU3_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU3_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU3_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU3_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU3_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU4_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU4_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU4_TA_SQC_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU4_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU4_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU5_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU5_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU5_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU5_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU5_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU6_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU6_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU6_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU6_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU6_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_CU7_SP0_CTRL_REG, 0xffffffff, 0x00010000,\n\tmmCGTS_CU7_LDS_SQ_CTRL_REG, 0xffffffff, 0x00030002,\n\tmmCGTS_CU7_TA_CTRL_REG, 0xffffffff, 0x00040007,\n\tmmCGTS_CU7_SP1_CTRL_REG, 0xffffffff, 0x00060005,\n\tmmCGTS_CU7_TD_TCP_CTRL_REG, 0xffffffff, 0x00090008,\n\tmmCGTS_SM_CTRL_REG, 0xffffffff, 0x96e00200,\n\tmmCP_RB_WPTR_POLL_CNTL, 0xffffffff, 0x00900100,\n\tmmRLC_CGCG_CGLS_CTRL, 0xffffffff, 0x0020003f,\n\tmmCP_MEM_SLP_CNTL, 0x00000001, 0x00000001,\n};\n\nstatic const u32 stoney_golden_settings_a11[] =\n{\n\tmmDB_DEBUG2, 0xf00fffff, 0x00000400,\n\tmmGB_GPU_ID, 0x0000000f, 0x00000000,\n\tmmPA_SC_ENHANCE, 0xffffffff, 0x20000001,\n\tmmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0001003c,\n\tmmTA_CNTL_AUX, 0x000f000f, 0x000b0000,\n\tmmTCC_CTRL, 0x00100000, 0xf31fff7f,\n\tmmTCC_EXE_DISABLE, 0x00000002, 0x00000002,\n\tmmTCP_ADDR_CONFIG, 0x0000000f, 0x000000f1,\n\tmmTCP_CHAN_STEER_LO, 0xffffffff, 0x10101010,\n};\n\nstatic const u32 stoney_golden_common_all[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmPA_SC_RASTER_CONFIG, 0xffffffff, 0x00000000,\n\tmmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x00000000,\n\tmmGB_ADDR_CONFIG, 0xffffffff, 0x12010001,\n\tmmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,\n\tmmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,\n};\n\nstatic const u32 stoney_mgcg_cgcg_init[] =\n{\n\tmmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,\n\tmmRLC_CGCG_CGLS_CTRL, 0xffffffff, 0x0020003f,\n\tmmCP_MEM_SLP_CNTL, 0xffffffff, 0x00020201,\n\tmmRLC_MEM_SLP_CNTL, 0xffffffff, 0x00020201,\n\tmmCGTS_SM_CTRL_REG, 0xffffffff, 0x96940200,\n};\n\n\nstatic const char * const sq_edc_source_names[] = {\n\t\"SQ_EDC_INFO_SOURCE_INVALID: No EDC error has occurred\",\n\t\"SQ_EDC_INFO_SOURCE_INST: EDC source is Instruction Fetch\",\n\t\"SQ_EDC_INFO_SOURCE_SGPR: EDC source is SGPR or SQC data return\",\n\t\"SQ_EDC_INFO_SOURCE_VGPR: EDC source is VGPR\",\n\t\"SQ_EDC_INFO_SOURCE_LDS: EDC source is LDS\",\n\t\"SQ_EDC_INFO_SOURCE_GDS: EDC source is GDS\",\n\t\"SQ_EDC_INFO_SOURCE_TA: EDC source is TA\",\n};\n\nstatic void gfx_v8_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void gfx_v8_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic void gfx_v8_0_set_gds_init(struct amdgpu_device *adev);\nstatic void gfx_v8_0_set_rlc_funcs(struct amdgpu_device *adev);\nstatic u32 gfx_v8_0_get_csb_size(struct amdgpu_device *adev);\nstatic void gfx_v8_0_get_cu_info(struct amdgpu_device *adev);\nstatic void gfx_v8_0_ring_emit_ce_meta(struct amdgpu_ring *ring);\nstatic void gfx_v8_0_ring_emit_de_meta(struct amdgpu_ring *ring);\n\n#define CG_ACLK_CNTL__ACLK_DIVIDER_MASK                    0x0000007fL\n#define CG_ACLK_CNTL__ACLK_DIVIDER__SHIFT                  0x00000000L\n\nstatic void gfx_v8_0_init_golden_registers(struct amdgpu_device *adev)\n{\n\tuint32_t data;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TOPAZ:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\ticeland_mgcg_cgcg_init,\n\t\t\t\t\t\t\tARRAY_SIZE(iceland_mgcg_cgcg_init));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_iceland_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_iceland_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\ticeland_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(iceland_golden_common_all));\n\t\tbreak;\n\tcase CHIP_FIJI:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tfiji_mgcg_cgcg_init,\n\t\t\t\t\t\t\tARRAY_SIZE(fiji_mgcg_cgcg_init));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_fiji_a10,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_fiji_a10));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tfiji_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(fiji_golden_common_all));\n\t\tbreak;\n\n\tcase CHIP_TONGA:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\ttonga_mgcg_cgcg_init,\n\t\t\t\t\t\t\tARRAY_SIZE(tonga_mgcg_cgcg_init));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_tonga_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_tonga_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\ttonga_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(tonga_golden_common_all));\n\t\tbreak;\n\tcase CHIP_VEGAM:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_vegam_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_vegam_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tvegam_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(vegam_golden_common_all));\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_polaris11_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_polaris11_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tpolaris11_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(polaris11_golden_common_all));\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_polaris10_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_polaris10_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tpolaris10_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(polaris10_golden_common_all));\n\t\tdata = RREG32_SMC(ixCG_ACLK_CNTL);\n\t\tdata &= ~CG_ACLK_CNTL__ACLK_DIVIDER_MASK;\n\t\tdata |= 0x18 << CG_ACLK_CNTL__ACLK_DIVIDER__SHIFT;\n\t\tWREG32_SMC(ixCG_ACLK_CNTL, data);\n\t\tif ((adev->pdev->device == 0x67DF) && (adev->pdev->revision == 0xc7) &&\n\t\t    ((adev->pdev->subsystem_device == 0xb37 && adev->pdev->subsystem_vendor == 0x1002) ||\n\t\t     (adev->pdev->subsystem_device == 0x4a8 && adev->pdev->subsystem_vendor == 0x1043) ||\n\t\t     (adev->pdev->subsystem_device == 0x9480 && adev->pdev->subsystem_vendor == 0x1680))) {\n\t\t\tamdgpu_atombios_i2c_channel_trans(adev, 0x10, 0x96, 0x1E, 0xDD);\n\t\t\tamdgpu_atombios_i2c_channel_trans(adev, 0x10, 0x96, 0x1F, 0xD0);\n\t\t}\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tcz_mgcg_cgcg_init,\n\t\t\t\t\t\t\tARRAY_SIZE(cz_mgcg_cgcg_init));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tcz_golden_settings_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(cz_golden_settings_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tcz_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(cz_golden_common_all));\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tstoney_mgcg_cgcg_init,\n\t\t\t\t\t\t\tARRAY_SIZE(stoney_mgcg_cgcg_init));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tstoney_golden_settings_a11,\n\t\t\t\t\t\t\tARRAY_SIZE(stoney_golden_settings_a11));\n\t\tamdgpu_device_program_register_sequence(adev,\n\t\t\t\t\t\t\tstoney_golden_common_all,\n\t\t\t\t\t\t\tARRAY_SIZE(stoney_golden_common_all));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v8_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(mmSCRATCH_REG0, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\tamdgpu_ring_write(ring, mmSCRATCH_REG0 - PACKET3_SET_UCONFIG_REG_START);\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(mmSCRATCH_REG0);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\nstatic int gfx_v8_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\n\tunsigned int index;\n\tuint64_t gpu_addr;\n\tuint32_t tmp;\n\tlong r;\n\n\tr = amdgpu_device_wb_get(adev, &index);\n\tif (r)\n\t\treturn r;\n\n\tgpu_addr = adev->wb.gpu_addr + (index * 4);\n\tadev->wb.wb[index] = cpu_to_le32(0xCAFEDEAD);\n\tmemset(&ib, 0, sizeof(ib));\n\n\tr = amdgpu_ib_get(adev, NULL, 20, AMDGPU_IB_POOL_DIRECT, &ib);\n\tif (r)\n\t\tgoto err1;\n\n\tib.ptr[0] = PACKET3(PACKET3_WRITE_DATA, 3);\n\tib.ptr[1] = WRITE_DATA_DST_SEL(5) | WR_CONFIRM;\n\tib.ptr[2] = lower_32_bits(gpu_addr);\n\tib.ptr[3] = upper_32_bits(gpu_addr);\n\tib.ptr[4] = 0xDEADBEEF;\n\tib.length_dw = 5;\n\n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r)\n\t\tgoto err2;\n\n\tr = dma_fence_wait_timeout(f, false, timeout);\n\tif (r == 0) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto err2;\n\t} else if (r < 0) {\n\t\tgoto err2;\n\t}\n\n\ttmp = adev->wb.wb[index];\n\tif (tmp == 0xDEADBEEF)\n\t\tr = 0;\n\telse\n\t\tr = -EINVAL;\n\nerr2:\n\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\nerr1:\n\tamdgpu_device_wb_free(adev, index);\n\treturn r;\n}\n\n\nstatic void gfx_v8_0_free_microcode(struct amdgpu_device *adev)\n{\n\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\tamdgpu_ucode_release(&adev->gfx.ce_fw);\n\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\tif ((adev->asic_type != CHIP_STONEY) &&\n\t    (adev->asic_type != CHIP_TOPAZ))\n\t\tamdgpu_ucode_release(&adev->gfx.mec2_fw);\n\n\tkfree(adev->gfx.rlc.register_list_format);\n}\n\nstatic int gfx_v8_0_init_microcode(struct amdgpu_device *adev)\n{\n\tconst char *chip_name;\n\tchar fw_name[30];\n\tint err;\n\tstruct amdgpu_firmware_info *info = NULL;\n\tconst struct common_firmware_header *header = NULL;\n\tconst struct gfx_firmware_header_v1_0 *cp_hdr;\n\tconst struct rlc_firmware_header_v2_0 *rlc_hdr;\n\tunsigned int *tmp = NULL, i;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TOPAZ:\n\t\tchip_name = \"topaz\";\n\t\tbreak;\n\tcase CHIP_TONGA:\n\t\tchip_name = \"tonga\";\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\tchip_name = \"carrizo\";\n\t\tbreak;\n\tcase CHIP_FIJI:\n\t\tchip_name = \"fiji\";\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\tchip_name = \"stoney\";\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\t\tchip_name = \"polaris10\";\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\t\tchip_name = \"polaris11\";\n\t\tbreak;\n\tcase CHIP_POLARIS12:\n\t\tchip_name = \"polaris12\";\n\t\tbreak;\n\tcase CHIP_VEGAM:\n\t\tchip_name = \"vegam\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (adev->asic_type >= CHIP_POLARIS10 && adev->asic_type <= CHIP_POLARIS12) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp_2.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\t\tif (err == -ENODEV) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\t\t}\n\t} else {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\t}\n\tif (err)\n\t\tgoto out;\n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.pfp_fw->data;\n\tadev->gfx.pfp_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);\n\tadev->gfx.pfp_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);\n\n\tif (adev->asic_type >= CHIP_POLARIS10 && adev->asic_type <= CHIP_POLARIS12) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me_2.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\t\tif (err == -ENODEV) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\t\t}\n\t} else {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\t}\n\tif (err)\n\t\tgoto out;\n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.me_fw->data;\n\tadev->gfx.me_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);\n\n\tadev->gfx.me_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);\n\n\tif (adev->asic_type >= CHIP_POLARIS10 && adev->asic_type <= CHIP_POLARIS12) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ce_2.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.ce_fw, fw_name);\n\t\tif (err == -ENODEV) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ce.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.ce_fw, fw_name);\n\t\t}\n\t} else {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ce.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.ce_fw, fw_name);\n\t}\n\tif (err)\n\t\tgoto out;\n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.ce_fw->data;\n\tadev->gfx.ce_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);\n\tadev->gfx.ce_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);\n\n\t \n\tif (adev->gfx.ce_feature_version >= 46 &&\n\t    adev->gfx.pfp_feature_version >= 46) {\n\t\tadev->virt.chained_ib_support = true;\n\t\tDRM_INFO(\"Chained IB support enabled!\\n\");\n\t} else\n\t\tadev->virt.chained_ib_support = false;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.rlc_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\trlc_hdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\tadev->gfx.rlc_fw_version = le32_to_cpu(rlc_hdr->header.ucode_version);\n\tadev->gfx.rlc_feature_version = le32_to_cpu(rlc_hdr->ucode_feature_version);\n\n\tadev->gfx.rlc.save_and_restore_offset =\n\t\t\tle32_to_cpu(rlc_hdr->save_and_restore_offset);\n\tadev->gfx.rlc.clear_state_descriptor_offset =\n\t\t\tle32_to_cpu(rlc_hdr->clear_state_descriptor_offset);\n\tadev->gfx.rlc.avail_scratch_ram_locations =\n\t\t\tle32_to_cpu(rlc_hdr->avail_scratch_ram_locations);\n\tadev->gfx.rlc.reg_restore_list_size =\n\t\t\tle32_to_cpu(rlc_hdr->reg_restore_list_size);\n\tadev->gfx.rlc.reg_list_format_start =\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_format_start);\n\tadev->gfx.rlc.reg_list_format_separate_start =\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_format_separate_start);\n\tadev->gfx.rlc.starting_offsets_start =\n\t\t\tle32_to_cpu(rlc_hdr->starting_offsets_start);\n\tadev->gfx.rlc.reg_list_format_size_bytes =\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_format_size_bytes);\n\tadev->gfx.rlc.reg_list_size_bytes =\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_size_bytes);\n\n\tadev->gfx.rlc.register_list_format =\n\t\t\tkmalloc(adev->gfx.rlc.reg_list_format_size_bytes +\n\t\t\t\t\tadev->gfx.rlc.reg_list_size_bytes, GFP_KERNEL);\n\n\tif (!adev->gfx.rlc.register_list_format) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp = (unsigned int *)((uintptr_t)rlc_hdr +\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_format_array_offset_bytes));\n\tfor (i = 0 ; i < (adev->gfx.rlc.reg_list_format_size_bytes >> 2); i++)\n\t\tadev->gfx.rlc.register_list_format[i] =\tle32_to_cpu(tmp[i]);\n\n\tadev->gfx.rlc.register_restore = adev->gfx.rlc.register_list_format + i;\n\n\ttmp = (unsigned int *)((uintptr_t)rlc_hdr +\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_array_offset_bytes));\n\tfor (i = 0 ; i < (adev->gfx.rlc.reg_list_size_bytes >> 2); i++)\n\t\tadev->gfx.rlc.register_restore[i] = le32_to_cpu(tmp[i]);\n\n\tif (adev->asic_type >= CHIP_POLARIS10 && adev->asic_type <= CHIP_POLARIS12) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec_2.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\t\tif (err == -ENODEV) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\t\t}\n\t} else {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\t}\n\tif (err)\n\t\tgoto out;\n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\tadev->gfx.mec_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);\n\tadev->gfx.mec_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);\n\n\tif ((adev->asic_type != CHIP_STONEY) &&\n\t    (adev->asic_type != CHIP_TOPAZ)) {\n\t\tif (adev->asic_type >= CHIP_POLARIS10 && adev->asic_type <= CHIP_POLARIS12) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec2_2.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec2_fw, fw_name);\n\t\t\tif (err == -ENODEV) {\n\t\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec2.bin\", chip_name);\n\t\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec2_fw, fw_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec2.bin\", chip_name);\n\t\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec2_fw, fw_name);\n\t\t}\n\t\tif (!err) {\n\t\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\t\tadev->gfx.mec2_fw->data;\n\t\t\tadev->gfx.mec2_fw_version =\n\t\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\t\tadev->gfx.mec2_feature_version =\n\t\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tadev->gfx.mec2_fw = NULL;\n\t\t}\n\t}\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_PFP];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_CP_PFP;\n\tinfo->fw = adev->gfx.pfp_fw;\n\theader = (const struct common_firmware_header *)info->fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_ME];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_CP_ME;\n\tinfo->fw = adev->gfx.me_fw;\n\theader = (const struct common_firmware_header *)info->fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_CE];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_CP_CE;\n\tinfo->fw = adev->gfx.ce_fw;\n\theader = (const struct common_firmware_header *)info->fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_G];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_G;\n\tinfo->fw = adev->gfx.rlc_fw;\n\theader = (const struct common_firmware_header *)info->fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC1];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_CP_MEC1;\n\tinfo->fw = adev->gfx.mec_fw;\n\theader = (const struct common_firmware_header *)info->fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\n\t \n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(cp_hdr->jt_size) << 2, PAGE_SIZE);\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_STORAGE];\n\t\tinfo->ucode_id = AMDGPU_UCODE_ID_STORAGE;\n\t\tinfo->fw = adev->gfx.mec_fw;\n\t\tadev->firmware.fw_size +=\n\t\t\tALIGN(le32_to_cpu(64 * PAGE_SIZE), PAGE_SIZE);\n\t}\n\n\tif (adev->gfx.mec2_fw) {\n\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC2];\n\t\tinfo->ucode_id = AMDGPU_UCODE_ID_CP_MEC2;\n\t\tinfo->fw = adev->gfx.mec2_fw;\n\t\theader = (const struct common_firmware_header *)info->fw->data;\n\t\tadev->firmware.fw_size +=\n\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t}\n\nout:\n\tif (err) {\n\t\tdev_err(adev->dev,\n\t\t\t\"gfx8: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.ce_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.mec2_fw);\n\t}\n\treturn err;\n}\n\nstatic void gfx_v8_0_get_csb_buffer(struct amdgpu_device *adev,\n\t\t\t\t    volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (adev->gfx.rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index -\n\t\t\t\t\t\tPACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tbuffer[count++] = cpu_to_le32(mmPA_SC_RASTER_CONFIG -\n\t\t\tPACKET3_SET_CONTEXT_REG_START);\n\tbuffer[count++] = cpu_to_le32(adev->gfx.config.rb_config[0][0].raster_config);\n\tbuffer[count++] = cpu_to_le32(adev->gfx.config.rb_config[0][0].raster_config_1);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic int gfx_v8_0_cp_jump_table_num(struct amdgpu_device *adev)\n{\n\tif (adev->asic_type == CHIP_CARRIZO)\n\t\treturn 5;\n\telse\n\t\treturn 4;\n}\n\nstatic int gfx_v8_0_rlc_init(struct amdgpu_device *adev)\n{\n\tconst struct cs_section_def *cs_data;\n\tint r;\n\n\tadev->gfx.rlc.cs_data = vi_cs_data;\n\n\tcs_data = adev->gfx.rlc.cs_data;\n\n\tif (cs_data) {\n\t\t \n\t\tr = amdgpu_gfx_rlc_init_csb(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif ((adev->asic_type == CHIP_CARRIZO) ||\n\t    (adev->asic_type == CHIP_STONEY)) {\n\t\tadev->gfx.rlc.cp_table_size = ALIGN(96 * 5 * 4, 2048) + (64 * 1024);  \n\t\tr = amdgpu_gfx_rlc_init_cpt(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (adev->gfx.rlc.funcs->update_spm_vmid)\n\t\tadev->gfx.rlc.funcs->update_spm_vmid(adev, 0xf);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_mec_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.hpd_eop_obj, NULL, NULL);\n}\n\nstatic int gfx_v8_0_mec_init(struct amdgpu_device *adev)\n{\n\tint r;\n\tu32 *hpd;\n\tsize_t mec_hpd_size;\n\n\tbitmap_zero(adev->gfx.mec_bitmap[0].queue_bitmap, AMDGPU_MAX_COMPUTE_QUEUES);\n\n\t \n\tamdgpu_gfx_compute_queue_acquire(adev);\n\n\tmec_hpd_size = adev->gfx.num_compute_rings * GFX8_MEC_HPD_SIZE;\n\tif (mec_hpd_size) {\n\t\tr = amdgpu_bo_create_reserved(adev, mec_hpd_size, PAGE_SIZE,\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_obj,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_gpu_addr,\n\t\t\t\t\t      (void **)&hpd);\n\t\tif (r) {\n\t\t\tdev_warn(adev->dev, \"(%d) create HDP EOP bo failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tmemset(hpd, 0, mec_hpd_size);\n\n\t\tamdgpu_bo_kunmap(adev->gfx.mec.hpd_eop_obj);\n\t\tamdgpu_bo_unreserve(adev->gfx.mec.hpd_eop_obj);\n\t}\n\n\treturn 0;\n}\n\nstatic const u32 vgpr_init_compute_shader[] =\n{\n\t0x7e000209, 0x7e020208,\n\t0x7e040207, 0x7e060206,\n\t0x7e080205, 0x7e0a0204,\n\t0x7e0c0203, 0x7e0e0202,\n\t0x7e100201, 0x7e120200,\n\t0x7e140209, 0x7e160208,\n\t0x7e180207, 0x7e1a0206,\n\t0x7e1c0205, 0x7e1e0204,\n\t0x7e200203, 0x7e220202,\n\t0x7e240201, 0x7e260200,\n\t0x7e280209, 0x7e2a0208,\n\t0x7e2c0207, 0x7e2e0206,\n\t0x7e300205, 0x7e320204,\n\t0x7e340203, 0x7e360202,\n\t0x7e380201, 0x7e3a0200,\n\t0x7e3c0209, 0x7e3e0208,\n\t0x7e400207, 0x7e420206,\n\t0x7e440205, 0x7e460204,\n\t0x7e480203, 0x7e4a0202,\n\t0x7e4c0201, 0x7e4e0200,\n\t0x7e500209, 0x7e520208,\n\t0x7e540207, 0x7e560206,\n\t0x7e580205, 0x7e5a0204,\n\t0x7e5c0203, 0x7e5e0202,\n\t0x7e600201, 0x7e620200,\n\t0x7e640209, 0x7e660208,\n\t0x7e680207, 0x7e6a0206,\n\t0x7e6c0205, 0x7e6e0204,\n\t0x7e700203, 0x7e720202,\n\t0x7e740201, 0x7e760200,\n\t0x7e780209, 0x7e7a0208,\n\t0x7e7c0207, 0x7e7e0206,\n\t0xbf8a0000, 0xbf810000,\n};\n\nstatic const u32 sgpr_init_compute_shader[] =\n{\n\t0xbe8a0100, 0xbe8c0102,\n\t0xbe8e0104, 0xbe900106,\n\t0xbe920108, 0xbe940100,\n\t0xbe960102, 0xbe980104,\n\t0xbe9a0106, 0xbe9c0108,\n\t0xbe9e0100, 0xbea00102,\n\t0xbea20104, 0xbea40106,\n\t0xbea60108, 0xbea80100,\n\t0xbeaa0102, 0xbeac0104,\n\t0xbeae0106, 0xbeb00108,\n\t0xbeb20100, 0xbeb40102,\n\t0xbeb60104, 0xbeb80106,\n\t0xbeba0108, 0xbebc0100,\n\t0xbebe0102, 0xbec00104,\n\t0xbec20106, 0xbec40108,\n\t0xbec60100, 0xbec80102,\n\t0xbee60004, 0xbee70005,\n\t0xbeea0006, 0xbeeb0007,\n\t0xbee80008, 0xbee90009,\n\t0xbefc0000, 0xbf8a0000,\n\t0xbf810000, 0x00000000,\n};\n\nstatic const u32 vgpr_init_regs[] =\n{\n\tmmCOMPUTE_STATIC_THREAD_MGMT_SE0, 0xffffffff,\n\tmmCOMPUTE_RESOURCE_LIMITS, 0x1000000,  \n\tmmCOMPUTE_NUM_THREAD_X, 256*4,\n\tmmCOMPUTE_NUM_THREAD_Y, 1,\n\tmmCOMPUTE_NUM_THREAD_Z, 1,\n\tmmCOMPUTE_PGM_RSRC1, 0x100004f,  \n\tmmCOMPUTE_PGM_RSRC2, 20,\n\tmmCOMPUTE_USER_DATA_0, 0xedcedc00,\n\tmmCOMPUTE_USER_DATA_1, 0xedcedc01,\n\tmmCOMPUTE_USER_DATA_2, 0xedcedc02,\n\tmmCOMPUTE_USER_DATA_3, 0xedcedc03,\n\tmmCOMPUTE_USER_DATA_4, 0xedcedc04,\n\tmmCOMPUTE_USER_DATA_5, 0xedcedc05,\n\tmmCOMPUTE_USER_DATA_6, 0xedcedc06,\n\tmmCOMPUTE_USER_DATA_7, 0xedcedc07,\n\tmmCOMPUTE_USER_DATA_8, 0xedcedc08,\n\tmmCOMPUTE_USER_DATA_9, 0xedcedc09,\n};\n\nstatic const u32 sgpr1_init_regs[] =\n{\n\tmmCOMPUTE_STATIC_THREAD_MGMT_SE0, 0x0f,\n\tmmCOMPUTE_RESOURCE_LIMITS, 0x1000000,  \n\tmmCOMPUTE_NUM_THREAD_X, 256*5,\n\tmmCOMPUTE_NUM_THREAD_Y, 1,\n\tmmCOMPUTE_NUM_THREAD_Z, 1,\n\tmmCOMPUTE_PGM_RSRC1, 0x240,  \n\tmmCOMPUTE_PGM_RSRC2, 20,\n\tmmCOMPUTE_USER_DATA_0, 0xedcedc00,\n\tmmCOMPUTE_USER_DATA_1, 0xedcedc01,\n\tmmCOMPUTE_USER_DATA_2, 0xedcedc02,\n\tmmCOMPUTE_USER_DATA_3, 0xedcedc03,\n\tmmCOMPUTE_USER_DATA_4, 0xedcedc04,\n\tmmCOMPUTE_USER_DATA_5, 0xedcedc05,\n\tmmCOMPUTE_USER_DATA_6, 0xedcedc06,\n\tmmCOMPUTE_USER_DATA_7, 0xedcedc07,\n\tmmCOMPUTE_USER_DATA_8, 0xedcedc08,\n\tmmCOMPUTE_USER_DATA_9, 0xedcedc09,\n};\n\nstatic const u32 sgpr2_init_regs[] =\n{\n\tmmCOMPUTE_STATIC_THREAD_MGMT_SE0, 0xf0,\n\tmmCOMPUTE_RESOURCE_LIMITS, 0x1000000,\n\tmmCOMPUTE_NUM_THREAD_X, 256*5,\n\tmmCOMPUTE_NUM_THREAD_Y, 1,\n\tmmCOMPUTE_NUM_THREAD_Z, 1,\n\tmmCOMPUTE_PGM_RSRC1, 0x240,  \n\tmmCOMPUTE_PGM_RSRC2, 20,\n\tmmCOMPUTE_USER_DATA_0, 0xedcedc00,\n\tmmCOMPUTE_USER_DATA_1, 0xedcedc01,\n\tmmCOMPUTE_USER_DATA_2, 0xedcedc02,\n\tmmCOMPUTE_USER_DATA_3, 0xedcedc03,\n\tmmCOMPUTE_USER_DATA_4, 0xedcedc04,\n\tmmCOMPUTE_USER_DATA_5, 0xedcedc05,\n\tmmCOMPUTE_USER_DATA_6, 0xedcedc06,\n\tmmCOMPUTE_USER_DATA_7, 0xedcedc07,\n\tmmCOMPUTE_USER_DATA_8, 0xedcedc08,\n\tmmCOMPUTE_USER_DATA_9, 0xedcedc09,\n};\n\nstatic const u32 sec_ded_counter_registers[] =\n{\n\tmmCPC_EDC_ATC_CNT,\n\tmmCPC_EDC_SCRATCH_CNT,\n\tmmCPC_EDC_UCODE_CNT,\n\tmmCPF_EDC_ATC_CNT,\n\tmmCPF_EDC_ROQ_CNT,\n\tmmCPF_EDC_TAG_CNT,\n\tmmCPG_EDC_ATC_CNT,\n\tmmCPG_EDC_DMA_CNT,\n\tmmCPG_EDC_TAG_CNT,\n\tmmDC_EDC_CSINVOC_CNT,\n\tmmDC_EDC_RESTORE_CNT,\n\tmmDC_EDC_STATE_CNT,\n\tmmGDS_EDC_CNT,\n\tmmGDS_EDC_GRBM_CNT,\n\tmmGDS_EDC_OA_DED,\n\tmmSPI_EDC_CNT,\n\tmmSQC_ATC_EDC_GATCL1_CNT,\n\tmmSQC_EDC_CNT,\n\tmmSQ_EDC_DED_CNT,\n\tmmSQ_EDC_INFO,\n\tmmSQ_EDC_SEC_CNT,\n\tmmTCC_EDC_CNT,\n\tmmTCP_ATC_EDC_GATCL1_CNT,\n\tmmTCP_EDC_CNT,\n\tmmTD_EDC_CNT\n};\n\nstatic int gfx_v8_0_do_edc_gpr_workarounds(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[0];\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\tint r, i;\n\tu32 tmp;\n\tunsigned total_size, vgpr_offset, sgpr_offset;\n\tu64 gpu_addr;\n\n\t \n\tif (adev->asic_type != CHIP_CARRIZO)\n\t\treturn 0;\n\n\t \n\tif (!ring->sched.ready)\n\t\treturn 0;\n\n\ttmp = RREG32(mmGB_EDC_MODE);\n\tWREG32(mmGB_EDC_MODE, 0);\n\n\ttotal_size =\n\t\t(((ARRAY_SIZE(vgpr_init_regs) / 2) * 3) + 4 + 5 + 2) * 4;\n\ttotal_size +=\n\t\t(((ARRAY_SIZE(sgpr1_init_regs) / 2) * 3) + 4 + 5 + 2) * 4;\n\ttotal_size +=\n\t\t(((ARRAY_SIZE(sgpr2_init_regs) / 2) * 3) + 4 + 5 + 2) * 4;\n\ttotal_size = ALIGN(total_size, 256);\n\tvgpr_offset = total_size;\n\ttotal_size += ALIGN(sizeof(vgpr_init_compute_shader), 256);\n\tsgpr_offset = total_size;\n\ttotal_size += sizeof(sgpr_init_compute_shader);\n\n\t \n\tmemset(&ib, 0, sizeof(ib));\n\tr = amdgpu_ib_get(adev, NULL, total_size,\n\t\t\t\t\tAMDGPU_IB_POOL_DIRECT, &ib);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: failed to get ib (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vgpr_init_compute_shader); i++)\n\t\tib.ptr[i + (vgpr_offset / 4)] = vgpr_init_compute_shader[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(sgpr_init_compute_shader); i++)\n\t\tib.ptr[i + (sgpr_offset / 4)] = sgpr_init_compute_shader[i];\n\n\t \n\tib.length_dw = 0;\n\n\t \n\t \n\tfor (i = 0; i < ARRAY_SIZE(vgpr_init_regs); i += 2) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = vgpr_init_regs[i] - PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = vgpr_init_regs[i + 1];\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)vgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = mmCOMPUTE_PGM_LO - PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = 8;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\t \n\tfor (i = 0; i < ARRAY_SIZE(sgpr1_init_regs); i += 2) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = sgpr1_init_regs[i] - PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = sgpr1_init_regs[i + 1];\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = mmCOMPUTE_PGM_LO - PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = 8;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\t \n\tfor (i = 0; i < ARRAY_SIZE(sgpr2_init_regs); i += 2) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = sgpr2_init_regs[i] - PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = sgpr2_init_regs[i + 1];\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = mmCOMPUTE_PGM_LO - PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = 8;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: ib submit failed (%d).\\n\", r);\n\t\tgoto fail;\n\t}\n\n\t \n\tr = dma_fence_wait(f, false);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: fence wait failed (%d).\\n\", r);\n\t\tgoto fail;\n\t}\n\n\ttmp = REG_SET_FIELD(tmp, GB_EDC_MODE, DED_MODE, 2);\n\ttmp = REG_SET_FIELD(tmp, GB_EDC_MODE, PROP_FED, 1);\n\tWREG32(mmGB_EDC_MODE, tmp);\n\n\ttmp = RREG32(mmCC_GC_EDC_CONFIG);\n\ttmp = REG_SET_FIELD(tmp, CC_GC_EDC_CONFIG, DIS_EDC, 0) | 1;\n\tWREG32(mmCC_GC_EDC_CONFIG, tmp);\n\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sec_ded_counter_registers); i++)\n\t\tRREG32(sec_ded_counter_registers[i]);\n\nfail:\n\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\n\n\treturn r;\n}\n\nstatic int gfx_v8_0_gpu_early_init(struct amdgpu_device *adev)\n{\n\tu32 gb_addr_config;\n\tu32 mc_arb_ramcfg;\n\tu32 dimm00_addr_map, dimm01_addr_map, dimm10_addr_map, dimm11_addr_map;\n\tu32 tmp;\n\tint ret;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TOPAZ:\n\t\tadev->gfx.config.max_shader_engines = 1;\n\t\tadev->gfx.config.max_tile_pipes = 2;\n\t\tadev->gfx.config.max_cu_per_sh = 6;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_texture_channel_caches = 2;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TOPAZ_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_FIJI:\n\t\tadev->gfx.config.max_shader_engines = 4;\n\t\tadev->gfx.config.max_tile_pipes = 16;\n\t\tadev->gfx.config.max_cu_per_sh = 16;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 4;\n\t\tadev->gfx.config.max_texture_channel_caches = 16;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TONGA_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\tret = amdgpu_atombios_get_gfx_info(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = POLARIS11_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\tcase CHIP_VEGAM:\n\t\tret = amdgpu_atombios_get_gfx_info(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TONGA_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_TONGA:\n\t\tadev->gfx.config.max_shader_engines = 4;\n\t\tadev->gfx.config.max_tile_pipes = 8;\n\t\tadev->gfx.config.max_cu_per_sh = 8;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_texture_channel_caches = 8;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TONGA_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\tadev->gfx.config.max_shader_engines = 1;\n\t\tadev->gfx.config.max_tile_pipes = 2;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_cu_per_sh = 8;\n\t\tadev->gfx.config.max_texture_channel_caches = 2;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CARRIZO_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\tadev->gfx.config.max_shader_engines = 1;\n\t\tadev->gfx.config.max_tile_pipes = 2;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 1;\n\t\tadev->gfx.config.max_cu_per_sh = 3;\n\t\tadev->gfx.config.max_texture_channel_caches = 2;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 16;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CARRIZO_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tdefault:\n\t\tadev->gfx.config.max_shader_engines = 2;\n\t\tadev->gfx.config.max_tile_pipes = 4;\n\t\tadev->gfx.config.max_cu_per_sh = 2;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_texture_channel_caches = 4;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TONGA_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\tadev->gfx.config.mc_arb_ramcfg = RREG32(mmMC_ARB_RAMCFG);\n\tmc_arb_ramcfg = adev->gfx.config.mc_arb_ramcfg;\n\n\tadev->gfx.config.num_banks = REG_GET_FIELD(mc_arb_ramcfg,\n\t\t\t\tMC_ARB_RAMCFG, NOOFBANK);\n\tadev->gfx.config.num_ranks = REG_GET_FIELD(mc_arb_ramcfg,\n\t\t\t\tMC_ARB_RAMCFG, NOOFRANKS);\n\n\tadev->gfx.config.num_tile_pipes = adev->gfx.config.max_tile_pipes;\n\tadev->gfx.config.mem_max_burst_length_bytes = 256;\n\tif (adev->flags & AMD_IS_APU) {\n\t\t \n\t\ttmp = RREG32(mmMC_FUS_DRAM0_BANK_ADDR_MAPPING);\n\t\tdimm00_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM0_BANK_ADDR_MAPPING, DIMM0ADDRMAP);\n\t\tdimm01_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM0_BANK_ADDR_MAPPING, DIMM1ADDRMAP);\n\n\t\ttmp = RREG32(mmMC_FUS_DRAM1_BANK_ADDR_MAPPING);\n\t\tdimm10_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM1_BANK_ADDR_MAPPING, DIMM0ADDRMAP);\n\t\tdimm11_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM1_BANK_ADDR_MAPPING, DIMM1ADDRMAP);\n\n\t\t \n\t\tif ((dimm00_addr_map == 0) || (dimm00_addr_map == 3) || (dimm00_addr_map == 4) || (dimm00_addr_map > 12))\n\t\t\tdimm00_addr_map = 0;\n\t\tif ((dimm01_addr_map == 0) || (dimm01_addr_map == 3) || (dimm01_addr_map == 4) || (dimm01_addr_map > 12))\n\t\t\tdimm01_addr_map = 0;\n\t\tif ((dimm10_addr_map == 0) || (dimm10_addr_map == 3) || (dimm10_addr_map == 4) || (dimm10_addr_map > 12))\n\t\t\tdimm10_addr_map = 0;\n\t\tif ((dimm11_addr_map == 0) || (dimm11_addr_map == 3) || (dimm11_addr_map == 4) || (dimm11_addr_map > 12))\n\t\t\tdimm11_addr_map = 0;\n\n\t\t \n\t\t \n\t\tif ((dimm00_addr_map == 11) || (dimm01_addr_map == 11) || (dimm10_addr_map == 11) || (dimm11_addr_map == 11))\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 2;\n\t\telse\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 1;\n\t} else {\n\t\ttmp = REG_GET_FIELD(mc_arb_ramcfg, MC_ARB_RAMCFG, NOOFCOLS);\n\t\tadev->gfx.config.mem_row_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;\n\t\tif (adev->gfx.config.mem_row_size_in_kb > 4)\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 4;\n\t}\n\n\tadev->gfx.config.shader_engine_tile_size = 32;\n\tadev->gfx.config.num_gpus = 1;\n\tadev->gfx.config.multi_gpu_tile_size = 64;\n\n\t \n\tswitch (adev->gfx.config.mem_row_size_in_kb) {\n\tcase 1:\n\tdefault:\n\t\tgb_addr_config = REG_SET_FIELD(gb_addr_config, GB_ADDR_CONFIG, ROW_SIZE, 0);\n\t\tbreak;\n\tcase 2:\n\t\tgb_addr_config = REG_SET_FIELD(gb_addr_config, GB_ADDR_CONFIG, ROW_SIZE, 1);\n\t\tbreak;\n\tcase 4:\n\t\tgb_addr_config = REG_SET_FIELD(gb_addr_config, GB_ADDR_CONFIG, ROW_SIZE, 2);\n\t\tbreak;\n\t}\n\tadev->gfx.config.gb_addr_config = gb_addr_config;\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_compute_ring_init(struct amdgpu_device *adev, int ring_id,\n\t\t\t\t\tint mec, int pipe, int queue)\n{\n\tint r;\n\tunsigned irq_type;\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[ring_id];\n\tunsigned int hw_prio;\n\n\tring = &adev->gfx.compute_ring[ring_id];\n\n\t \n\tring->me = mec + 1;\n\tring->pipe = pipe;\n\tring->queue = queue;\n\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\tring->doorbell_index = adev->doorbell_index.mec_ring0 + ring_id;\n\tring->eop_gpu_addr = adev->gfx.mec.hpd_eop_gpu_addr\n\t\t\t\t+ (ring_id * GFX8_MEC_HPD_SIZE);\n\tsprintf(ring->name, \"comp_%d.%d.%d\", ring->me, ring->pipe, ring->queue);\n\n\tirq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP\n\t\t+ ((ring->me - 1) * adev->gfx.mec.num_pipe_per_mec)\n\t\t+ ring->pipe;\n\n\thw_prio = amdgpu_gfx_is_high_priority_compute_queue(adev, ring) ?\n\t\t\tAMDGPU_RING_PRIO_2 : AMDGPU_RING_PRIO_DEFAULT;\n\t \n\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq, irq_type,\n\t\t\t     hw_prio, NULL);\n\tif (r)\n\t\treturn r;\n\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_sq_irq_work_func(struct work_struct *work);\n\nstatic int gfx_v8_0_sw_init(void *handle)\n{\n\tint i, j, k, r, ring_id;\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_kiq *kiq;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TONGA:\n\tcase CHIP_CARRIZO:\n\tcase CHIP_FIJI:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\t\tadev->gfx.mec.num_mec = 2;\n\t\tbreak;\n\tcase CHIP_TOPAZ:\n\tcase CHIP_STONEY:\n\tdefault:\n\t\tadev->gfx.mec.num_mec = 1;\n\t\tbreak;\n\t}\n\n\tadev->gfx.mec.num_pipe_per_mec = 4;\n\tadev->gfx.mec.num_queue_per_pipe = 8;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_CP_END_OF_PIPE, &adev->gfx.eop_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_CP_PRIV_REG_FAULT,\n\t\t\t      &adev->gfx.priv_reg_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_CP_PRIV_INSTR_FAULT,\n\t\t\t      &adev->gfx.priv_inst_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_CP_ECC_ERROR,\n\t\t\t      &adev->gfx.cp_ecc_error_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_SQ_INTERRUPT_MSG,\n\t\t\t      &adev->gfx.sq_irq);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_irq_add() for SQ failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tINIT_WORK(&adev->gfx.sq_work.work, gfx_v8_0_sq_irq_work_func);\n\n\tadev->gfx.gfx_current_status = AMDGPU_GFX_NORMAL_MODE;\n\n\tr = gfx_v8_0_init_microcode(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to load gfx firmware!\\n\");\n\t\treturn r;\n\t}\n\n\tr = adev->gfx.rlc.funcs->init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tr = gfx_v8_0_mec_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init MEC BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\t\tring->ring_obj = NULL;\n\t\tsprintf(ring->name, \"gfx\");\n\t\t \n\t\tif (adev->asic_type != CHIP_TOPAZ) {\n\t\t\tring->use_doorbell = true;\n\t\t\tring->doorbell_index = adev->doorbell_index.gfx_ring0;\n\t\t}\n\n\t\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq,\n\t\t\t\t     AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP,\n\t\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\n\t \n\tring_id = 0;\n\tfor (i = 0; i < adev->gfx.mec.num_mec; ++i) {\n\t\tfor (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {\n\t\t\t\tif (!amdgpu_gfx_is_mec_queue_enabled(adev, 0, i,\n\t\t\t\t\t\t\t\t     k, j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tr = gfx_v8_0_compute_ring_init(adev,\n\t\t\t\t\t\t\t\tring_id,\n\t\t\t\t\t\t\t\ti, k, j);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\n\t\t\t\tring_id++;\n\t\t\t}\n\t\t}\n\t}\n\n\tr = amdgpu_gfx_kiq_init(adev, GFX8_MEC_HPD_SIZE, 0);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init KIQ BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tkiq = &adev->gfx.kiq[0];\n\tr = amdgpu_gfx_kiq_init_ring(adev, &kiq->ring, &kiq->irq, 0);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_gfx_mqd_sw_init(adev, sizeof(struct vi_mqd_allocation), 0);\n\tif (r)\n\t\treturn r;\n\n\tadev->gfx.ce_ram_size = 0x8000;\n\n\tr = gfx_v8_0_gpu_early_init(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.gfx_ring[i]);\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.compute_ring[i]);\n\n\tamdgpu_gfx_mqd_sw_fini(adev, 0);\n\tamdgpu_gfx_kiq_free_ring(&adev->gfx.kiq[0].ring);\n\tamdgpu_gfx_kiq_fini(adev, 0);\n\n\tgfx_v8_0_mec_fini(adev);\n\tamdgpu_gfx_rlc_fini(adev);\n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.clear_state_obj,\n\t\t\t\t&adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cs_ptr);\n\tif ((adev->asic_type == CHIP_CARRIZO) ||\n\t    (adev->asic_type == CHIP_STONEY)) {\n\t\tamdgpu_bo_free_kernel(&adev->gfx.rlc.cp_table_obj,\n\t\t\t\t&adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cp_table_ptr);\n\t}\n\tgfx_v8_0_free_microcode(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_tiling_mode_table_init(struct amdgpu_device *adev)\n{\n\tuint32_t *modearray, *mod2array;\n\tconst u32 num_tile_mode_states = ARRAY_SIZE(adev->gfx.config.tile_mode_array);\n\tconst u32 num_secondary_tile_mode_states = ARRAY_SIZE(adev->gfx.config.macrotile_mode_array);\n\tu32 reg_offset;\n\n\tmodearray = adev->gfx.config.tile_mode_array;\n\tmod2array = adev->gfx.config.macrotile_mode_array;\n\n\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\tmodearray[reg_offset] = 0;\n\n\tfor (reg_offset = 0; reg_offset <  num_secondary_tile_mode_states; reg_offset++)\n\t\tmod2array[reg_offset] = 0;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_TOPAZ:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7 && reg_offset != 12 && reg_offset != 17 &&\n\t\t\t    reg_offset != 23)\n\t\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tcase CHIP_FIJI:\n\tcase CHIP_VEGAM:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[7] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[12] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[17] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[23] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[30] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tcase CHIP_TONGA:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[7] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[12] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[17] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[23] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[30] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[7] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[12] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[17] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[23] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[30] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[7] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[12] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[17] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[23] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[30] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7 && reg_offset != 12 && reg_offset != 17 &&\n\t\t\t    reg_offset != 23)\n\t\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(adev->dev,\n\t\t\t \"Unknown chip type (%d) in function gfx_v8_0_tiling_mode_table_init() falling through to CHIP_CARRIZO\\n\",\n\t\t\t adev->asic_type);\n\t\tfallthrough;\n\n\tcase CHIP_CARRIZO:\n\t\tmodearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tTILE_SPLIT(ADDR_SURF_TILE_SPLIT_2KB) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\tmodearray[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2));\n\t\tmodearray[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\tPIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\tMICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\tSAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\tmodearray[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\tmodearray[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\tmodearray[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t\t PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t\t MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t\t SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmod2array[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmod2array[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmod2array[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\t BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\t MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\t NUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7 && reg_offset != 12 && reg_offset != 17 &&\n\t\t\t    reg_offset != 23)\n\t\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, modearray[reg_offset]);\n\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, mod2array[reg_offset]);\n\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v8_0_select_se_sh(struct amdgpu_device *adev,\n\t\t\t\t  u32 se_num, u32 sh_num, u32 instance,\n\t\t\t\t  int xcc_id)\n{\n\tu32 data;\n\n\tif (instance == 0xffffffff)\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_INDEX, instance);\n\n\tif (se_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_INDEX, se_num);\n\n\tif (sh_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_INDEX, sh_num);\n\n\tWREG32(mmGRBM_GFX_INDEX, data);\n}\n\nstatic void gfx_v8_0_select_me_pipe_q(struct amdgpu_device *adev,\n\t\t\t\t  u32 me, u32 pipe, u32 q, u32 vm, u32 xcc_id)\n{\n\tvi_srbm_select(adev, me, pipe, q, vm);\n}\n\nstatic u32 gfx_v8_0_get_rb_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata =  RREG32(mmCC_RB_BACKEND_DISABLE) |\n\t\tRREG32(mmGC_USER_RB_BACKEND_DISABLE);\n\n\tdata = REG_GET_FIELD(data, GC_USER_RB_BACKEND_DISABLE, BACKEND_DISABLE);\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_backends_per_se /\n\t\t\t\t\t adev->gfx.config.max_sh_per_se);\n\n\treturn (~data) & mask;\n}\n\nstatic void\ngfx_v8_0_raster_config(struct amdgpu_device *adev, u32 *rconf, u32 *rconf1)\n{\n\tswitch (adev->asic_type) {\n\tcase CHIP_FIJI:\n\tcase CHIP_VEGAM:\n\t\t*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |\n\t\t\t  RB_XSEL2(1) | PKR_MAP(2) |\n\t\t\t  PKR_XSEL(1) | PKR_YSEL(1) |\n\t\t\t  SE_MAP(2) | SE_XSEL(2) | SE_YSEL(3);\n\t\t*rconf1 |= SE_PAIR_MAP(2) | SE_PAIR_XSEL(3) |\n\t\t\t   SE_PAIR_YSEL(2);\n\t\tbreak;\n\tcase CHIP_TONGA:\n\tcase CHIP_POLARIS10:\n\t\t*rconf |= RB_MAP_PKR0(2) | RB_XSEL2(1) | SE_MAP(2) |\n\t\t\t  SE_XSEL(1) | SE_YSEL(1);\n\t\t*rconf1 |= SE_PAIR_MAP(2) | SE_PAIR_XSEL(2) |\n\t\t\t   SE_PAIR_YSEL(2);\n\t\tbreak;\n\tcase CHIP_TOPAZ:\n\tcase CHIP_CARRIZO:\n\t\t*rconf |= RB_MAP_PKR0(2);\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\t*rconf |= RB_MAP_PKR0(2) | RB_XSEL2(1) | SE_MAP(2) |\n\t\t\t  SE_XSEL(1) | SE_YSEL(1);\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\t*rconf |= 0x0;\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unknown asic: 0x%x\\n\", adev->asic_type);\n\t\tbreak;\n\t}\n}\n\nstatic void\ngfx_v8_0_write_harvested_raster_configs(struct amdgpu_device *adev,\n\t\t\t\t\tu32 raster_config, u32 raster_config_1,\n\t\t\t\t\tunsigned rb_mask, unsigned num_rb)\n{\n\tunsigned sh_per_se = max_t(unsigned, adev->gfx.config.max_sh_per_se, 1);\n\tunsigned num_se = max_t(unsigned, adev->gfx.config.max_shader_engines, 1);\n\tunsigned rb_per_pkr = min_t(unsigned, num_rb / num_se / sh_per_se, 2);\n\tunsigned rb_per_se = num_rb / num_se;\n\tunsigned se_mask[4];\n\tunsigned se;\n\n\tse_mask[0] = ((1 << rb_per_se) - 1) & rb_mask;\n\tse_mask[1] = (se_mask[0] << rb_per_se) & rb_mask;\n\tse_mask[2] = (se_mask[1] << rb_per_se) & rb_mask;\n\tse_mask[3] = (se_mask[2] << rb_per_se) & rb_mask;\n\n\tWARN_ON(!(num_se == 1 || num_se == 2 || num_se == 4));\n\tWARN_ON(!(sh_per_se == 1 || sh_per_se == 2));\n\tWARN_ON(!(rb_per_pkr == 1 || rb_per_pkr == 2));\n\n\tif ((num_se > 2) && ((!se_mask[0] && !se_mask[1]) ||\n\t\t\t     (!se_mask[2] && !se_mask[3]))) {\n\t\traster_config_1 &= ~SE_PAIR_MAP_MASK;\n\n\t\tif (!se_mask[0] && !se_mask[1]) {\n\t\t\traster_config_1 |=\n\t\t\t\tSE_PAIR_MAP(RASTER_CONFIG_SE_PAIR_MAP_3);\n\t\t} else {\n\t\t\traster_config_1 |=\n\t\t\t\tSE_PAIR_MAP(RASTER_CONFIG_SE_PAIR_MAP_0);\n\t\t}\n\t}\n\n\tfor (se = 0; se < num_se; se++) {\n\t\tunsigned raster_config_se = raster_config;\n\t\tunsigned pkr0_mask = ((1 << rb_per_pkr) - 1) << (se * rb_per_se);\n\t\tunsigned pkr1_mask = pkr0_mask << rb_per_pkr;\n\t\tint idx = (se / 2) * 2;\n\n\t\tif ((num_se > 1) && (!se_mask[idx] || !se_mask[idx + 1])) {\n\t\t\traster_config_se &= ~SE_MAP_MASK;\n\n\t\t\tif (!se_mask[idx]) {\n\t\t\t\traster_config_se |= SE_MAP(RASTER_CONFIG_SE_MAP_3);\n\t\t\t} else {\n\t\t\t\traster_config_se |= SE_MAP(RASTER_CONFIG_SE_MAP_0);\n\t\t\t}\n\t\t}\n\n\t\tpkr0_mask &= rb_mask;\n\t\tpkr1_mask &= rb_mask;\n\t\tif (rb_per_se > 2 && (!pkr0_mask || !pkr1_mask)) {\n\t\t\traster_config_se &= ~PKR_MAP_MASK;\n\n\t\t\tif (!pkr0_mask) {\n\t\t\t\traster_config_se |= PKR_MAP(RASTER_CONFIG_PKR_MAP_3);\n\t\t\t} else {\n\t\t\t\traster_config_se |= PKR_MAP(RASTER_CONFIG_PKR_MAP_0);\n\t\t\t}\n\t\t}\n\n\t\tif (rb_per_se >= 2) {\n\t\t\tunsigned rb0_mask = 1 << (se * rb_per_se);\n\t\t\tunsigned rb1_mask = rb0_mask << 1;\n\n\t\t\trb0_mask &= rb_mask;\n\t\t\trb1_mask &= rb_mask;\n\t\t\tif (!rb0_mask || !rb1_mask) {\n\t\t\t\traster_config_se &= ~RB_MAP_PKR0_MASK;\n\n\t\t\t\tif (!rb0_mask) {\n\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\tRB_MAP_PKR0(RASTER_CONFIG_RB_MAP_3);\n\t\t\t\t} else {\n\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\tRB_MAP_PKR0(RASTER_CONFIG_RB_MAP_0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rb_per_se > 2) {\n\t\t\t\trb0_mask = 1 << (se * rb_per_se + rb_per_pkr);\n\t\t\t\trb1_mask = rb0_mask << 1;\n\t\t\t\trb0_mask &= rb_mask;\n\t\t\t\trb1_mask &= rb_mask;\n\t\t\t\tif (!rb0_mask || !rb1_mask) {\n\t\t\t\t\traster_config_se &= ~RB_MAP_PKR1_MASK;\n\n\t\t\t\t\tif (!rb0_mask) {\n\t\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\t\tRB_MAP_PKR1(RASTER_CONFIG_RB_MAP_3);\n\t\t\t\t\t} else {\n\t\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\t\tRB_MAP_PKR1(RASTER_CONFIG_RB_MAP_0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tgfx_v8_0_select_se_sh(adev, se, 0xffffffff, 0xffffffff, 0);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG, raster_config_se);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG_1, raster_config_1);\n\t}\n\n\t \n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n}\n\nstatic void gfx_v8_0_setup_rb(struct amdgpu_device *adev)\n{\n\tint i, j;\n\tu32 data;\n\tu32 raster_config = 0, raster_config_1 = 0;\n\tu32 active_rbs = 0;\n\tu32 rb_bitmap_width_per_sh = adev->gfx.config.max_backends_per_se /\n\t\t\t\t\tadev->gfx.config.max_sh_per_se;\n\tunsigned num_rb_pipes;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v8_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tdata = gfx_v8_0_get_rb_active_bitmap(adev);\n\t\t\tactive_rbs |= data << ((i * adev->gfx.config.max_sh_per_se + j) *\n\t\t\t\t\t       rb_bitmap_width_per_sh);\n\t\t}\n\t}\n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\n\tadev->gfx.config.backend_enable_mask = active_rbs;\n\tadev->gfx.config.num_rbs = hweight32(active_rbs);\n\n\tnum_rb_pipes = min_t(unsigned, adev->gfx.config.max_backends_per_se *\n\t\t\t     adev->gfx.config.max_shader_engines, 16);\n\n\tgfx_v8_0_raster_config(adev, &raster_config, &raster_config_1);\n\n\tif (!adev->gfx.config.backend_enable_mask ||\n\t\t\tadev->gfx.config.num_rbs >= num_rb_pipes) {\n\t\tWREG32(mmPA_SC_RASTER_CONFIG, raster_config);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG_1, raster_config_1);\n\t} else {\n\t\tgfx_v8_0_write_harvested_raster_configs(adev, raster_config, raster_config_1,\n\t\t\t\t\t\t\tadev->gfx.config.backend_enable_mask,\n\t\t\t\t\t\t\tnum_rb_pipes);\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v8_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tadev->gfx.config.rb_config[i][j].rb_backend_disable =\n\t\t\t\tRREG32(mmCC_RB_BACKEND_DISABLE);\n\t\t\tadev->gfx.config.rb_config[i][j].user_rb_backend_disable =\n\t\t\t\tRREG32(mmGC_USER_RB_BACKEND_DISABLE);\n\t\t\tadev->gfx.config.rb_config[i][j].raster_config =\n\t\t\t\tRREG32(mmPA_SC_RASTER_CONFIG);\n\t\t\tadev->gfx.config.rb_config[i][j].raster_config_1 =\n\t\t\t\tRREG32(mmPA_SC_RASTER_CONFIG_1);\n\t\t}\n\t}\n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n}\n\n#define DEFAULT_SH_MEM_BASES\t(0x6000)\n \nstatic void gfx_v8_0_init_compute_vmid(struct amdgpu_device *adev)\n{\n\tint i;\n\tuint32_t sh_mem_config;\n\tuint32_t sh_mem_bases;\n\n\t \n\tsh_mem_bases = DEFAULT_SH_MEM_BASES | (DEFAULT_SH_MEM_BASES << 16);\n\n\tsh_mem_config = SH_MEM_ADDRESS_MODE_HSA64 <<\n\t\t\tSH_MEM_CONFIG__ADDRESS_MODE__SHIFT |\n\t\t\tSH_MEM_ALIGNMENT_MODE_UNALIGNED <<\n\t\t\tSH_MEM_CONFIG__ALIGNMENT_MODE__SHIFT |\n\t\t\tMTYPE_CC << SH_MEM_CONFIG__DEFAULT_MTYPE__SHIFT |\n\t\t\tSH_MEM_CONFIG__PRIVATE_ATC_MASK;\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tvi_srbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tWREG32(mmSH_MEM_CONFIG, sh_mem_config);\n\t\tWREG32(mmSH_MEM_APE1_BASE, 1);\n\t\tWREG32(mmSH_MEM_APE1_LIMIT, 0);\n\t\tWREG32(mmSH_MEM_BASES, sh_mem_bases);\n\t}\n\tvi_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tWREG32(amdgpu_gds_reg_offset[i].mem_base, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].mem_size, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].gws, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].oa, 0);\n\t}\n}\n\nstatic void gfx_v8_0_init_gds_vmid(struct amdgpu_device *adev)\n{\n\tint vmid;\n\n\t \n\tfor (vmid = 1; vmid < AMDGPU_NUM_VMID; vmid++) {\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].mem_base, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].mem_size, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].gws, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].oa, 0);\n\t}\n}\n\nstatic void gfx_v8_0_config_init(struct amdgpu_device *adev)\n{\n\tswitch (adev->asic_type) {\n\tdefault:\n\t\tadev->gfx.config.double_offchip_lds_buf = 1;\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\t\tadev->gfx.config.double_offchip_lds_buf = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v8_0_constants_init(struct amdgpu_device *adev)\n{\n\tu32 tmp, sh_static_mem_cfg;\n\tint i;\n\n\tWREG32_FIELD(GRBM_CNTL, READ_TIMEOUT, 0xFF);\n\tWREG32(mmGB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmHDP_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmDMIF_ADDR_CALC, adev->gfx.config.gb_addr_config);\n\n\tgfx_v8_0_tiling_mode_table_init(adev);\n\tgfx_v8_0_setup_rb(adev);\n\tgfx_v8_0_get_cu_info(adev);\n\tgfx_v8_0_config_init(adev);\n\n\t \n\t \n\tsh_static_mem_cfg = REG_SET_FIELD(0, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   SWIZZLE_ENABLE, 1);\n\tsh_static_mem_cfg = REG_SET_FIELD(sh_static_mem_cfg, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   ELEMENT_SIZE, 1);\n\tsh_static_mem_cfg = REG_SET_FIELD(sh_static_mem_cfg, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   INDEX_STRIDE, 3);\n\tWREG32(mmSH_STATIC_MEM_CONFIG, sh_static_mem_cfg);\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->vm_manager.id_mgr[0].num_ids; i++) {\n\t\tvi_srbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tif (i == 0) {\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_CONFIG, DEFAULT_MTYPE, MTYPE_UC);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, APE1_MTYPE, MTYPE_UC);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, ALIGNMENT_MODE,\n\t\t\t\t\t    SH_MEM_ALIGNMENT_MODE_UNALIGNED);\n\t\t\tWREG32(mmSH_MEM_CONFIG, tmp);\n\t\t\tWREG32(mmSH_MEM_BASES, 0);\n\t\t} else {\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_CONFIG, DEFAULT_MTYPE, MTYPE_NC);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, APE1_MTYPE, MTYPE_UC);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, ALIGNMENT_MODE,\n\t\t\t\t\t    SH_MEM_ALIGNMENT_MODE_UNALIGNED);\n\t\t\tWREG32(mmSH_MEM_CONFIG, tmp);\n\t\t\ttmp = adev->gmc.shared_aperture_start >> 48;\n\t\t\tWREG32(mmSH_MEM_BASES, tmp);\n\t\t}\n\n\t\tWREG32(mmSH_MEM_APE1_BASE, 1);\n\t\tWREG32(mmSH_MEM_APE1_LIMIT, 0);\n\t}\n\tvi_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\tgfx_v8_0_init_compute_vmid(adev);\n\tgfx_v8_0_init_gds_vmid(adev);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\t \n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\n\tWREG32(mmPA_SC_FIFO_SIZE,\n\t\t   (adev->gfx.config.sc_prim_fifo_size_frontend <<\n\t\t\tPA_SC_FIFO_SIZE__SC_FRONTEND_PRIM_FIFO_SIZE__SHIFT) |\n\t\t   (adev->gfx.config.sc_prim_fifo_size_backend <<\n\t\t\tPA_SC_FIFO_SIZE__SC_BACKEND_PRIM_FIFO_SIZE__SHIFT) |\n\t\t   (adev->gfx.config.sc_hiz_tile_fifo_size <<\n\t\t\tPA_SC_FIFO_SIZE__SC_HIZ_TILE_FIFO_SIZE__SHIFT) |\n\t\t   (adev->gfx.config.sc_earlyz_tile_fifo_size <<\n\t\t\tPA_SC_FIFO_SIZE__SC_EARLYZ_TILE_FIFO_SIZE__SHIFT));\n\n\ttmp = RREG32(mmSPI_ARB_PRIORITY);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS0, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS1, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS2, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS3, 2);\n\tWREG32(mmSPI_ARB_PRIORITY, tmp);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n}\n\nstatic void gfx_v8_0_wait_for_rlc_serdes(struct amdgpu_device *adev)\n{\n\tu32 i, j, k;\n\tu32 mask;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v8_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\t\t\tif (RREG32(mmRLC_SERDES_CU_MASTER_BUSY) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tif (k == adev->usec_timeout) {\n\t\t\t\tgfx_v8_0_select_se_sh(adev, 0xffffffff,\n\t\t\t\t\t\t      0xffffffff, 0xffffffff, 0);\n\t\t\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\t\t\t\tDRM_INFO(\"Timeout wait for RLC serdes %u,%u\\n\",\n\t\t\t\t\t i, j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tmask = RLC_SERDES_NONCU_MASTER_BUSY__SE_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__GC_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC0_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC1_MASTER_BUSY_MASK;\n\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\tif ((RREG32(mmRLC_SERDES_NONCU_MASTER_BUSY) & mask) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v8_0_enable_gui_idle_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 tmp = RREG32(mmCP_INT_CNTL_RING0);\n\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_BUSY_INT_ENABLE, enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_EMPTY_INT_ENABLE, enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CMP_BUSY_INT_ENABLE, enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, GFX_IDLE_INT_ENABLE, enable ? 1 : 0);\n\n\tWREG32(mmCP_INT_CNTL_RING0, tmp);\n}\n\nstatic void gfx_v8_0_init_csb(struct amdgpu_device *adev)\n{\n\tadev->gfx.rlc.funcs->get_csb_buffer(adev, adev->gfx.rlc.cs_ptr);\n\t \n\tWREG32(mmRLC_CSIB_ADDR_HI,\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr >> 32);\n\tWREG32(mmRLC_CSIB_ADDR_LO,\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr & 0xfffffffc);\n\tWREG32(mmRLC_CSIB_LENGTH,\n\t\t\tadev->gfx.rlc.clear_state_size);\n}\n\nstatic void gfx_v8_0_parse_ind_reg_list(int *register_list_format,\n\t\t\t\tint ind_offset,\n\t\t\t\tint list_size,\n\t\t\t\tint *unique_indices,\n\t\t\t\tint *indices_count,\n\t\t\t\tint max_indices,\n\t\t\t\tint *ind_start_offsets,\n\t\t\t\tint *offset_count,\n\t\t\t\tint max_offset)\n{\n\tint indices;\n\tbool new_entry = true;\n\n\tfor (; ind_offset < list_size; ind_offset++) {\n\n\t\tif (new_entry) {\n\t\t\tnew_entry = false;\n\t\t\tind_start_offsets[*offset_count] = ind_offset;\n\t\t\t*offset_count = *offset_count + 1;\n\t\t\tBUG_ON(*offset_count >= max_offset);\n\t\t}\n\n\t\tif (register_list_format[ind_offset] == 0xFFFFFFFF) {\n\t\t\tnew_entry = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tind_offset += 2;\n\n\t\t \n\t\tfor (indices = 0;\n\t\t\tindices < *indices_count;\n\t\t\tindices++) {\n\t\t\tif (unique_indices[indices] ==\n\t\t\t\tregister_list_format[ind_offset])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (indices >= *indices_count) {\n\t\t\tunique_indices[*indices_count] =\n\t\t\t\tregister_list_format[ind_offset];\n\t\t\tindices = *indices_count;\n\t\t\t*indices_count = *indices_count + 1;\n\t\t\tBUG_ON(*indices_count >= max_indices);\n\t\t}\n\n\t\tregister_list_format[ind_offset] = indices;\n\t}\n}\n\nstatic int gfx_v8_0_init_save_restore_list(struct amdgpu_device *adev)\n{\n\tint i, temp, data;\n\tint unique_indices[] = {0, 0, 0, 0, 0, 0, 0, 0};\n\tint indices_count = 0;\n\tint indirect_start_offsets[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\tint offset_count = 0;\n\n\tint list_size;\n\tunsigned int *register_list_format =\n\t\tkmemdup(adev->gfx.rlc.register_list_format,\n\t\t\tadev->gfx.rlc.reg_list_format_size_bytes, GFP_KERNEL);\n\tif (!register_list_format)\n\t\treturn -ENOMEM;\n\n\tgfx_v8_0_parse_ind_reg_list(register_list_format,\n\t\t\t\tRLC_FormatDirectRegListLength,\n\t\t\t\tadev->gfx.rlc.reg_list_format_size_bytes >> 2,\n\t\t\t\tunique_indices,\n\t\t\t\t&indices_count,\n\t\t\t\tARRAY_SIZE(unique_indices),\n\t\t\t\tindirect_start_offsets,\n\t\t\t\t&offset_count,\n\t\t\t\tARRAY_SIZE(indirect_start_offsets));\n\n\t \n\tWREG32_FIELD(RLC_SRM_CNTL, AUTO_INCR_ADDR, 1);\n\n\tWREG32(mmRLC_SRM_ARAM_ADDR, 0);\n\tfor (i = 0; i < adev->gfx.rlc.reg_list_size_bytes >> 2; i++)\n\t\tWREG32(mmRLC_SRM_ARAM_DATA, adev->gfx.rlc.register_restore[i]);\n\n\t \n\tWREG32(mmRLC_GPM_SCRATCH_ADDR, adev->gfx.rlc.reg_list_format_start);\n\tfor (i = 0; i < adev->gfx.rlc.reg_list_format_size_bytes >> 2; i++)\n\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, register_list_format[i]);\n\n\tlist_size = adev->gfx.rlc.reg_list_size_bytes >> 2;\n\tlist_size = list_size >> 1;\n\tWREG32(mmRLC_GPM_SCRATCH_ADDR, adev->gfx.rlc.reg_restore_list_size);\n\tWREG32(mmRLC_GPM_SCRATCH_DATA, list_size);\n\n\t \n\tWREG32(mmRLC_GPM_SCRATCH_ADDR,\n\t\tadev->gfx.rlc.starting_offsets_start);\n\tfor (i = 0; i < ARRAY_SIZE(indirect_start_offsets); i++)\n\t\tWREG32(mmRLC_GPM_SCRATCH_DATA,\n\t\t\t\tindirect_start_offsets[i]);\n\n\t \n\ttemp = mmRLC_SRM_INDEX_CNTL_ADDR_0;\n\tdata = mmRLC_SRM_INDEX_CNTL_DATA_0;\n\tfor (i = 0; i < ARRAY_SIZE(unique_indices); i++) {\n\t\tif (unique_indices[i] != 0) {\n\t\t\tWREG32(temp + i, unique_indices[i] & 0x3FFFF);\n\t\t\tWREG32(data + i, unique_indices[i] >> 20);\n\t\t}\n\t}\n\tkfree(register_list_format);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_enable_save_restore_machine(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD(RLC_SRM_CNTL, SRM_ENABLE, 1);\n}\n\nstatic void gfx_v8_0_init_power_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data;\n\n\tWREG32_FIELD(CP_RB_WPTR_POLL_CNTL, IDLE_POLL_COUNT, 0x60);\n\n\tdata = REG_SET_FIELD(0, RLC_PG_DELAY, POWER_UP_DELAY, 0x10);\n\tdata = REG_SET_FIELD(data, RLC_PG_DELAY, POWER_DOWN_DELAY, 0x10);\n\tdata = REG_SET_FIELD(data, RLC_PG_DELAY, CMD_PROPAGATE_DELAY, 0x10);\n\tdata = REG_SET_FIELD(data, RLC_PG_DELAY, MEM_SLEEP_DELAY, 0x10);\n\tWREG32(mmRLC_PG_DELAY, data);\n\n\tWREG32_FIELD(RLC_PG_DELAY_2, SERDES_CMD_DELAY, 0x3);\n\tWREG32_FIELD(RLC_AUTO_PG_CTRL, GRBM_REG_SAVE_GFX_IDLE_THRESHOLD, 0x55f0);\n\n}\n\nstatic void cz_enable_sck_slow_down_on_power_up(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, SMU_CLK_SLOWDOWN_ON_PU_ENABLE, enable ? 1 : 0);\n}\n\nstatic void cz_enable_sck_slow_down_on_power_down(struct amdgpu_device *adev,\n\t\t\t\t\t\t  bool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, SMU_CLK_SLOWDOWN_ON_PD_ENABLE, enable ? 1 : 0);\n}\n\nstatic void cz_enable_cp_power_gating(struct amdgpu_device *adev, bool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, CP_PG_DISABLE, enable ? 0 : 1);\n}\n\nstatic void gfx_v8_0_init_pg(struct amdgpu_device *adev)\n{\n\tif ((adev->asic_type == CHIP_CARRIZO) ||\n\t    (adev->asic_type == CHIP_STONEY)) {\n\t\tgfx_v8_0_init_csb(adev);\n\t\tgfx_v8_0_init_save_restore_list(adev);\n\t\tgfx_v8_0_enable_save_restore_machine(adev);\n\t\tWREG32(mmRLC_JUMP_TABLE_RESTORE, adev->gfx.rlc.cp_table_gpu_addr >> 8);\n\t\tgfx_v8_0_init_power_gating(adev);\n\t\tWREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);\n\t} else if ((adev->asic_type == CHIP_POLARIS11) ||\n\t\t   (adev->asic_type == CHIP_POLARIS12) ||\n\t\t   (adev->asic_type == CHIP_VEGAM)) {\n\t\tgfx_v8_0_init_csb(adev);\n\t\tgfx_v8_0_init_save_restore_list(adev);\n\t\tgfx_v8_0_enable_save_restore_machine(adev);\n\t\tgfx_v8_0_init_power_gating(adev);\n\t}\n\n}\n\nstatic void gfx_v8_0_rlc_stop(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD(RLC_CNTL, RLC_ENABLE_F32, 0);\n\n\tgfx_v8_0_enable_gui_idle_interrupt(adev, false);\n\tgfx_v8_0_wait_for_rlc_serdes(adev);\n}\n\nstatic void gfx_v8_0_rlc_reset(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD(GRBM_SOFT_RESET, SOFT_RESET_RLC, 1);\n\tudelay(50);\n\n\tWREG32_FIELD(GRBM_SOFT_RESET, SOFT_RESET_RLC, 0);\n\tudelay(50);\n}\n\nstatic void gfx_v8_0_rlc_start(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD(RLC_CNTL, RLC_ENABLE_F32, 1);\n\n\t \n\tif (!(adev->flags & AMD_IS_APU))\n\t\tgfx_v8_0_enable_gui_idle_interrupt(adev, true);\n\n\tudelay(50);\n}\n\nstatic int gfx_v8_0_rlc_resume(struct amdgpu_device *adev)\n{\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tgfx_v8_0_init_csb(adev);\n\t\treturn 0;\n\t}\n\n\tadev->gfx.rlc.funcs->stop(adev);\n\tadev->gfx.rlc.funcs->reset(adev);\n\tgfx_v8_0_init_pg(adev);\n\tadev->gfx.rlc.funcs->start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_cp_gfx_enable(struct amdgpu_device *adev, bool enable)\n{\n\tu32 tmp = RREG32(mmCP_ME_CNTL);\n\n\tif (enable) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_HALT, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_HALT, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, CE_HALT, 0);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_HALT, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_HALT, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, CE_HALT, 1);\n\t}\n\tWREG32(mmCP_ME_CNTL, tmp);\n\tudelay(50);\n}\n\nstatic u32 gfx_v8_0_get_csb_size(struct amdgpu_device *adev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = vi_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tcount += 4;\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nstatic int gfx_v8_0_cp_gfx_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.gfx_ring[0];\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint r, i;\n\n\t \n\tWREG32(mmCP_MAX_CONTEXT, adev->gfx.config.max_hw_contexts - 1);\n\tWREG32(mmCP_ENDIAN_SWAP, 0);\n\tWREG32(mmCP_DEVICE_ID, 1);\n\n\tgfx_v8_0_cp_gfx_enable(adev, true);\n\n\tr = amdgpu_ring_alloc(ring, gfx_v8_0_get_csb_size(adev) + 4);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, 0x80000000);\n\tamdgpu_ring_write(ring, 0x80000000);\n\n\tfor (sect = vi_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       PACKET3(PACKET3_SET_CONTEXT_REG,\n\t\t\t\t\t       ext->reg_count));\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       ext->reg_index - PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tamdgpu_ring_write(ring, ext->extent[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tamdgpu_ring_write(ring, mmPA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tamdgpu_ring_write(ring, adev->gfx.config.rb_config[0][0].raster_config);\n\tamdgpu_ring_write(ring, adev->gfx.config.rb_config[0][0].raster_config_1);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_BASE, 2));\n\tamdgpu_ring_write(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));\n\tamdgpu_ring_write(ring, 0x8000);\n\tamdgpu_ring_write(ring, 0x8000);\n\n\tamdgpu_ring_commit(ring);\n\n\treturn 0;\n}\nstatic void gfx_v8_0_set_cpg_door_bell(struct amdgpu_device *adev, struct amdgpu_ring *ring)\n{\n\tu32 tmp;\n\t \n\tif (adev->asic_type == CHIP_TOPAZ)\n\t\treturn;\n\n\ttmp = RREG32(mmCP_RB_DOORBELL_CONTROL);\n\n\tif (ring->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\tDOORBELL_OFFSET, ring->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t\t\tDOORBELL_HIT, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t\t    DOORBELL_EN, 1);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL, DOORBELL_EN, 0);\n\t}\n\n\tWREG32(mmCP_RB_DOORBELL_CONTROL, tmp);\n\n\tif (adev->flags & AMD_IS_APU)\n\t\treturn;\n\n\ttmp = REG_SET_FIELD(0, CP_RB_DOORBELL_RANGE_LOWER,\n\t\t\t\t\tDOORBELL_RANGE_LOWER,\n\t\t\t\t\tadev->doorbell_index.gfx_ring0);\n\tWREG32(mmCP_RB_DOORBELL_RANGE_LOWER, tmp);\n\n\tWREG32(mmCP_RB_DOORBELL_RANGE_UPPER,\n\t\tCP_RB_DOORBELL_RANGE_UPPER__DOORBELL_RANGE_UPPER_MASK);\n}\n\nstatic int gfx_v8_0_cp_gfx_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tu64 rb_addr, rptr_addr, wptr_gpu_addr;\n\n\t \n\tWREG32(mmCP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32(mmCP_RB_VMID, 0);\n\n\t \n\tring = &adev->gfx.gfx_ring[0];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = REG_SET_FIELD(0, CP_RB0_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, RB_BLKSZ, rb_bufsz - 2);\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, MTYPE, 3);\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, MIN_IB_AVAILSZ, 1);\n#ifdef __BIG_ENDIAN\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, BUF_SWAP, 1);\n#endif\n\tWREG32(mmCP_RB0_CNTL, tmp);\n\n\t \n\tWREG32(mmCP_RB0_CNTL, tmp | CP_RB0_CNTL__RB_RPTR_WR_ENA_MASK);\n\tring->wptr = 0;\n\tWREG32(mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\n\t \n\trptr_addr = ring->rptr_gpu_addr;\n\tWREG32(mmCP_RB0_RPTR_ADDR, lower_32_bits(rptr_addr));\n\tWREG32(mmCP_RB0_RPTR_ADDR_HI, upper_32_bits(rptr_addr) & 0xFF);\n\n\twptr_gpu_addr = ring->wptr_gpu_addr;\n\tWREG32(mmCP_RB_WPTR_POLL_ADDR_LO, lower_32_bits(wptr_gpu_addr));\n\tWREG32(mmCP_RB_WPTR_POLL_ADDR_HI, upper_32_bits(wptr_gpu_addr));\n\tmdelay(1);\n\tWREG32(mmCP_RB0_CNTL, tmp);\n\n\trb_addr = ring->gpu_addr >> 8;\n\tWREG32(mmCP_RB0_BASE, rb_addr);\n\tWREG32(mmCP_RB0_BASE_HI, upper_32_bits(rb_addr));\n\n\tgfx_v8_0_set_cpg_door_bell(adev, ring);\n\t \n\tamdgpu_ring_clear_ring(ring);\n\tgfx_v8_0_cp_gfx_start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_cp_compute_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable) {\n\t\tWREG32(mmCP_MEC_CNTL, 0);\n\t} else {\n\t\tWREG32(mmCP_MEC_CNTL, (CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK));\n\t\tadev->gfx.kiq[0].ring.sched.ready = false;\n\t}\n\tudelay(50);\n}\n\n \nstatic void gfx_v8_0_kiq_setting(struct amdgpu_ring *ring)\n{\n\tuint32_t tmp;\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\ttmp = RREG32(mmRLC_CP_SCHEDULERS);\n\ttmp &= 0xffffff00;\n\ttmp |= (ring->me << 5) | (ring->pipe << 3) | (ring->queue);\n\tWREG32(mmRLC_CP_SCHEDULERS, tmp);\n\ttmp |= 0x80;\n\tWREG32(mmRLC_CP_SCHEDULERS, tmp);\n}\n\nstatic int gfx_v8_0_kiq_kcq_enable(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *kiq_ring = &adev->gfx.kiq[0].ring;\n\tuint64_t queue_mask = 0;\n\tint r, i;\n\n\tfor (i = 0; i < AMDGPU_MAX_COMPUTE_QUEUES; ++i) {\n\t\tif (!test_bit(i, adev->gfx.mec_bitmap[0].queue_bitmap))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON(i >= (sizeof(queue_mask)*8))) {\n\t\t\tDRM_ERROR(\"Invalid KCQ enabled: %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tqueue_mask |= (1ull << i);\n\t}\n\n\tr = amdgpu_ring_alloc(kiq_ring, (8 * adev->gfx.num_compute_rings) + 8);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock KIQ (%d).\\n\", r);\n\t\treturn r;\n\t}\n\t \n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_SET_RESOURCES, 6));\n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, lower_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring, upper_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\t\tuint64_t mqd_addr = amdgpu_bo_gpu_offset(ring->mqd_obj);\n\t\tuint64_t wptr_addr = ring->wptr_gpu_addr;\n\n\t\t \n\t\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));\n\t\t \n\t\tamdgpu_ring_write(kiq_ring,\n\t\t\t\t  PACKET3_MAP_QUEUES_NUM_QUEUES(1));\n\t\tamdgpu_ring_write(kiq_ring,\n\t\t\t\t  PACKET3_MAP_QUEUES_DOORBELL_OFFSET(ring->doorbell_index) |\n\t\t\t\t  PACKET3_MAP_QUEUES_QUEUE(ring->queue) |\n\t\t\t\t  PACKET3_MAP_QUEUES_PIPE(ring->pipe) |\n\t\t\t\t  PACKET3_MAP_QUEUES_ME(ring->me == 1 ? 0 : 1));  \n\t\tamdgpu_ring_write(kiq_ring, lower_32_bits(mqd_addr));\n\t\tamdgpu_ring_write(kiq_ring, upper_32_bits(mqd_addr));\n\t\tamdgpu_ring_write(kiq_ring, lower_32_bits(wptr_addr));\n\t\tamdgpu_ring_write(kiq_ring, upper_32_bits(wptr_addr));\n\t}\n\n\tamdgpu_ring_commit(kiq_ring);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_deactivate_hqd(struct amdgpu_device *adev, u32 req)\n{\n\tint i, r = 0;\n\n\tif (RREG32(mmCP_HQD_ACTIVE) & CP_HQD_ACTIVE__ACTIVE_MASK) {\n\t\tWREG32_FIELD(CP_HQD_DEQUEUE_REQUEST, DEQUEUE_REQ, req);\n\t\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t\tif (!(RREG32(mmCP_HQD_ACTIVE) & CP_HQD_ACTIVE__ACTIVE_MASK))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tif (i == adev->usec_timeout)\n\t\t\tr = -ETIMEDOUT;\n\t}\n\tWREG32(mmCP_HQD_DEQUEUE_REQUEST, 0);\n\tWREG32(mmCP_HQD_PQ_RPTR, 0);\n\tWREG32(mmCP_HQD_PQ_WPTR, 0);\n\n\treturn r;\n}\n\nstatic void gfx_v8_0_mqd_set_priority(struct amdgpu_ring *ring, struct vi_mqd *mqd)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) {\n\t\tif (amdgpu_gfx_is_high_priority_compute_queue(adev, ring)) {\n\t\t\tmqd->cp_hqd_pipe_priority = AMDGPU_GFX_PIPE_PRIO_HIGH;\n\t\t\tmqd->cp_hqd_queue_priority =\n\t\t\t\tAMDGPU_GFX_QUEUE_PRIORITY_MAXIMUM;\n\t\t}\n\t}\n}\n\nstatic int gfx_v8_0_mqd_init(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct vi_mqd *mqd = ring->mqd_ptr;\n\tuint64_t hqd_gpu_addr, wb_gpu_addr, eop_base_addr;\n\tuint32_t tmp;\n\n\tmqd->header = 0xC0310800;\n\tmqd->compute_pipelinestat_enable = 0x00000001;\n\tmqd->compute_static_thread_mgmt_se0 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se1 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se2 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se3 = 0xffffffff;\n\tmqd->compute_misc_reserved = 0x00000003;\n\tmqd->dynamic_cu_mask_addr_lo = lower_32_bits(ring->mqd_gpu_addr\n\t\t\t\t\t\t     + offsetof(struct vi_mqd_allocation, dynamic_cu_mask));\n\tmqd->dynamic_cu_mask_addr_hi = upper_32_bits(ring->mqd_gpu_addr\n\t\t\t\t\t\t     + offsetof(struct vi_mqd_allocation, dynamic_cu_mask));\n\teop_base_addr = ring->eop_gpu_addr >> 8;\n\tmqd->cp_hqd_eop_base_addr_lo = eop_base_addr;\n\tmqd->cp_hqd_eop_base_addr_hi = upper_32_bits(eop_base_addr);\n\n\t \n\ttmp = RREG32(mmCP_HQD_EOP_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_EOP_CONTROL, EOP_SIZE,\n\t\t\t(order_base_2(GFX8_MEC_HPD_SIZE / 4) - 1));\n\n\tmqd->cp_hqd_eop_control = tmp;\n\n\t \n\ttmp = REG_SET_FIELD(RREG32(mmCP_HQD_PQ_DOORBELL_CONTROL),\n\t\t\t    CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t    DOORBELL_EN,\n\t\t\t    ring->use_doorbell ? 1 : 0);\n\n\tmqd->cp_hqd_pq_doorbell_control = tmp;\n\n\t \n\tmqd->cp_mqd_base_addr_lo = ring->mqd_gpu_addr & 0xfffffffc;\n\tmqd->cp_mqd_base_addr_hi = upper_32_bits(ring->mqd_gpu_addr);\n\n\t \n\ttmp = RREG32(mmCP_MQD_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_MQD_CONTROL, VMID, 0);\n\tmqd->cp_mqd_control = tmp;\n\n\t \n\thqd_gpu_addr = ring->gpu_addr >> 8;\n\tmqd->cp_hqd_pq_base_lo = hqd_gpu_addr;\n\tmqd->cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);\n\n\t \n\ttmp = RREG32(mmCP_HQD_PQ_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, QUEUE_SIZE,\n\t\t\t    (order_base_2(ring->ring_size / 4) - 1));\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, RPTR_BLOCK_SIZE,\n\t\t\t(order_base_2(AMDGPU_GPU_PAGE_SIZE / 4) - 1));\n#ifdef __BIG_ENDIAN\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, ENDIAN_SWAP, 1);\n#endif\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, UNORD_DISPATCH, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, ROQ_PQ_IB_FLIP, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, PRIV_STATE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, KMD_QUEUE, 1);\n\tmqd->cp_hqd_pq_control = tmp;\n\n\t \n\twb_gpu_addr = ring->rptr_gpu_addr;\n\tmqd->cp_hqd_pq_rptr_report_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_rptr_report_addr_hi =\n\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\twb_gpu_addr = ring->wptr_gpu_addr;\n\tmqd->cp_hqd_pq_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\n\ttmp = 0;\n\t \n\tif (ring->use_doorbell) {\n\t\ttmp = RREG32(mmCP_HQD_PQ_DOORBELL_CONTROL);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\tDOORBELL_OFFSET, ring->doorbell_index);\n\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t\t DOORBELL_EN, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t\t DOORBELL_SOURCE, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t\t DOORBELL_HIT, 0);\n\t}\n\n\tmqd->cp_hqd_pq_doorbell_control = tmp;\n\n\t \n\tring->wptr = 0;\n\tmqd->cp_hqd_pq_wptr = ring->wptr;\n\tmqd->cp_hqd_pq_rptr = RREG32(mmCP_HQD_PQ_RPTR);\n\n\t \n\tmqd->cp_hqd_vmid = 0;\n\n\ttmp = RREG32(mmCP_HQD_PERSISTENT_STATE);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PERSISTENT_STATE, PRELOAD_SIZE, 0x53);\n\tmqd->cp_hqd_persistent_state = tmp;\n\n\t \n\ttmp = RREG32(mmCP_HQD_IB_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_IB_CONTROL, MIN_IB_AVAIL_SIZE, 3);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_IB_CONTROL, MTYPE, 3);\n\tmqd->cp_hqd_ib_control = tmp;\n\n\ttmp = RREG32(mmCP_HQD_IQ_TIMER);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_IQ_TIMER, MTYPE, 3);\n\tmqd->cp_hqd_iq_timer = tmp;\n\n\ttmp = RREG32(mmCP_HQD_CTX_SAVE_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_CTX_SAVE_CONTROL, MTYPE, 3);\n\tmqd->cp_hqd_ctx_save_control = tmp;\n\n\t \n\tmqd->cp_hqd_eop_rptr = RREG32(mmCP_HQD_EOP_RPTR);\n\tmqd->cp_hqd_eop_wptr = RREG32(mmCP_HQD_EOP_WPTR);\n\tmqd->cp_hqd_ctx_save_base_addr_lo = RREG32(mmCP_HQD_CTX_SAVE_BASE_ADDR_LO);\n\tmqd->cp_hqd_ctx_save_base_addr_hi = RREG32(mmCP_HQD_CTX_SAVE_BASE_ADDR_HI);\n\tmqd->cp_hqd_cntl_stack_offset = RREG32(mmCP_HQD_CNTL_STACK_OFFSET);\n\tmqd->cp_hqd_cntl_stack_size = RREG32(mmCP_HQD_CNTL_STACK_SIZE);\n\tmqd->cp_hqd_wg_state_offset = RREG32(mmCP_HQD_WG_STATE_OFFSET);\n\tmqd->cp_hqd_ctx_save_size = RREG32(mmCP_HQD_CTX_SAVE_SIZE);\n\tmqd->cp_hqd_eop_done_events = RREG32(mmCP_HQD_EOP_EVENTS);\n\tmqd->cp_hqd_error = RREG32(mmCP_HQD_ERROR);\n\tmqd->cp_hqd_eop_wptr_mem = RREG32(mmCP_HQD_EOP_WPTR_MEM);\n\tmqd->cp_hqd_eop_dones = RREG32(mmCP_HQD_EOP_DONES);\n\n\t \n\tgfx_v8_0_mqd_set_priority(ring, mqd);\n\tmqd->cp_hqd_quantum = RREG32(mmCP_HQD_QUANTUM);\n\n\t \n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tmqd->cp_hqd_active = 1;\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_mqd_commit(struct amdgpu_device *adev,\n\t\t\tstruct vi_mqd *mqd)\n{\n\tuint32_t mqd_reg;\n\tuint32_t *mqd_data;\n\n\t \n\tmqd_data = &mqd->cp_mqd_base_addr_lo;\n\n\t \n\tWREG32_FIELD(CP_PQ_WPTR_POLL_CNTL, EN, 0);\n\n\t \n\tfor (mqd_reg = mmCP_HQD_VMID; mqd_reg <= mmCP_HQD_EOP_CONTROL; mqd_reg++)\n\t\tWREG32(mqd_reg, mqd_data[mqd_reg - mmCP_MQD_BASE_ADDR]);\n\n\t \n\tif (adev->asic_type != CHIP_TONGA) {\n\t\tWREG32(mmCP_HQD_EOP_RPTR, mqd->cp_hqd_eop_rptr);\n\t\tWREG32(mmCP_HQD_EOP_WPTR, mqd->cp_hqd_eop_wptr);\n\t\tWREG32(mmCP_HQD_EOP_WPTR_MEM, mqd->cp_hqd_eop_wptr_mem);\n\t}\n\n\tfor (mqd_reg = mmCP_HQD_EOP_EVENTS; mqd_reg <= mmCP_HQD_ERROR; mqd_reg++)\n\t\tWREG32(mqd_reg, mqd_data[mqd_reg - mmCP_MQD_BASE_ADDR]);\n\n\t \n\tfor (mqd_reg = mmCP_MQD_BASE_ADDR; mqd_reg <= mmCP_HQD_ACTIVE; mqd_reg++)\n\t\tWREG32(mqd_reg, mqd_data[mqd_reg - mmCP_MQD_BASE_ADDR]);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_kiq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct vi_mqd *mqd = ring->mqd_ptr;\n\n\tgfx_v8_0_kiq_setting(ring);\n\n\tif (amdgpu_in_reset(adev)) {  \n\t\t \n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation));\n\n\t\t \n\t\tring->wptr = 0;\n\t\tamdgpu_ring_clear_ring(ring);\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tvi_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tgfx_v8_0_mqd_commit(adev, mqd);\n\t\tvi_srbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t} else {\n\t\tmemset((void *)mqd, 0, sizeof(struct vi_mqd_allocation));\n\t\t((struct vi_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;\n\t\t((struct vi_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;\n\t\tif (amdgpu_sriov_vf(adev) && adev->in_suspend)\n\t\t\tamdgpu_ring_clear_ring(ring);\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tvi_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tgfx_v8_0_mqd_init(ring);\n\t\tgfx_v8_0_mqd_commit(adev, mqd);\n\t\tvi_srbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct vi_mqd_allocation));\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_kcq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct vi_mqd *mqd = ring->mqd_ptr;\n\tint mqd_idx = ring - &adev->gfx.compute_ring[0];\n\n\tif (!amdgpu_in_reset(adev) && !adev->in_suspend) {\n\t\tmemset((void *)mqd, 0, sizeof(struct vi_mqd_allocation));\n\t\t((struct vi_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;\n\t\t((struct vi_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tvi_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tgfx_v8_0_mqd_init(ring);\n\t\tvi_srbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct vi_mqd_allocation));\n\t} else {\n\t\t \n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct vi_mqd_allocation));\n\t\t \n\t\tring->wptr = 0;\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v8_0_set_mec_doorbell_range(struct amdgpu_device *adev)\n{\n\tif (adev->asic_type > CHIP_TONGA) {\n\t\tWREG32(mmCP_MEC_DOORBELL_RANGE_LOWER, adev->doorbell_index.kiq << 2);\n\t\tWREG32(mmCP_MEC_DOORBELL_RANGE_UPPER, adev->doorbell_index.mec_ring7 << 2);\n\t}\n\t \n\tWREG32_FIELD(CP_PQ_STATUS, DOORBELL_ENABLE, 1);\n}\n\nstatic int gfx_v8_0_kiq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tint r;\n\n\tring = &adev->gfx.kiq[0].ring;\n\n\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\tr = amdgpu_bo_kmap(ring->mqd_obj, &ring->mqd_ptr);\n\tif (unlikely(r != 0)) {\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\treturn r;\n\t}\n\n\tgfx_v8_0_kiq_init_queue(ring);\n\tamdgpu_bo_kunmap(ring->mqd_obj);\n\tring->mqd_ptr = NULL;\n\tamdgpu_bo_unreserve(ring->mqd_obj);\n\treturn 0;\n}\n\nstatic int gfx_v8_0_kcq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = NULL;\n\tint r = 0, i;\n\n\tgfx_v8_0_cp_compute_enable(adev, true);\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\n\t\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tgoto done;\n\t\tr = amdgpu_bo_kmap(ring->mqd_obj, &ring->mqd_ptr);\n\t\tif (!r) {\n\t\t\tr = gfx_v8_0_kcq_init_queue(ring);\n\t\t\tamdgpu_bo_kunmap(ring->mqd_obj);\n\t\t\tring->mqd_ptr = NULL;\n\t\t}\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\tif (r)\n\t\t\tgoto done;\n\t}\n\n\tgfx_v8_0_set_mec_doorbell_range(adev);\n\n\tr = gfx_v8_0_kiq_kcq_enable(adev);\n\tif (r)\n\t\tgoto done;\n\ndone:\n\treturn r;\n}\n\nstatic int gfx_v8_0_cp_test_all_rings(struct amdgpu_device *adev)\n{\n\tint r, i;\n\tstruct amdgpu_ring *ring;\n\n\t \n\tring = &adev->gfx.gfx_ring[0];\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\treturn r;\n\n\tring = &adev->gfx.kiq[0].ring;\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\t\tamdgpu_ring_test_helper(ring);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_cp_resume(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tif (!(adev->flags & AMD_IS_APU))\n\t\tgfx_v8_0_enable_gui_idle_interrupt(adev, false);\n\n\tr = gfx_v8_0_kiq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v8_0_cp_gfx_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v8_0_kcq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v8_0_cp_test_all_rings(adev);\n\tif (r)\n\t\treturn r;\n\n\tgfx_v8_0_enable_gui_idle_interrupt(adev, true);\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_cp_enable(struct amdgpu_device *adev, bool enable)\n{\n\tgfx_v8_0_cp_gfx_enable(adev, enable);\n\tgfx_v8_0_cp_compute_enable(adev, enable);\n}\n\nstatic int gfx_v8_0_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tgfx_v8_0_init_golden_registers(adev);\n\tgfx_v8_0_constants_init(adev);\n\n\tr = adev->gfx.rlc.funcs->resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v8_0_cp_resume(adev);\n\n\treturn r;\n}\n\nstatic int gfx_v8_0_kcq_disable(struct amdgpu_device *adev)\n{\n\tint r, i;\n\tstruct amdgpu_ring *kiq_ring = &adev->gfx.kiq[0].ring;\n\n\tr = amdgpu_ring_alloc(kiq_ring, 6 * adev->gfx.num_compute_rings);\n\tif (r)\n\t\tDRM_ERROR(\"Failed to lock KIQ (%d).\\n\", r);\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\n\t\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_UNMAP_QUEUES, 4));\n\t\tamdgpu_ring_write(kiq_ring,  \n\t\t\t\t\t\tPACKET3_UNMAP_QUEUES_ACTION(1) |  \n\t\t\t\t\t\tPACKET3_UNMAP_QUEUES_QUEUE_SEL(0) |\n\t\t\t\t\t\tPACKET3_UNMAP_QUEUES_ENGINE_SEL(0) |\n\t\t\t\t\t\tPACKET3_UNMAP_QUEUES_NUM_QUEUES(1));\n\t\tamdgpu_ring_write(kiq_ring, PACKET3_UNMAP_QUEUES_DOORBELL_OFFSET0(ring->doorbell_index));\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t}\n\tr = amdgpu_ring_test_helper(kiq_ring);\n\tif (r)\n\t\tDRM_ERROR(\"KCQ disable failed\\n\");\n\n\treturn r;\n}\n\nstatic bool gfx_v8_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (REG_GET_FIELD(RREG32(mmGRBM_STATUS), GRBM_STATUS, GUI_ACTIVE)\n\t\t|| RREG32(mmGRBM_STATUS2) != 0x8)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic bool gfx_v8_0_rlc_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (RREG32(mmGRBM_STATUS2) != 0x8)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int gfx_v8_0_wait_for_rlc_idle(void *handle)\n{\n\tunsigned int i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (gfx_v8_0_rlc_is_idle(handle))\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int gfx_v8_0_wait_for_idle(void *handle)\n{\n\tunsigned int i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (gfx_v8_0_is_idle(handle))\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int gfx_v8_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_put(adev, &adev->gfx.priv_reg_irq, 0);\n\tamdgpu_irq_put(adev, &adev->gfx.priv_inst_irq, 0);\n\n\tamdgpu_irq_put(adev, &adev->gfx.cp_ecc_error_irq, 0);\n\n\tamdgpu_irq_put(adev, &adev->gfx.sq_irq, 0);\n\n\t \n\tgfx_v8_0_kcq_disable(adev);\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tpr_debug(\"For SRIOV client, shouldn't do anything.\\n\");\n\t\treturn 0;\n\t}\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\tif (!gfx_v8_0_wait_for_idle(adev))\n\t\tgfx_v8_0_cp_enable(adev, false);\n\telse\n\t\tpr_err(\"cp is busy, skip halt cp\\n\");\n\tif (!gfx_v8_0_wait_for_rlc_idle(adev))\n\t\tadev->gfx.rlc.funcs->stop(adev);\n\telse\n\t\tpr_err(\"rlc is busy, skip halt rlc\\n\");\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_suspend(void *handle)\n{\n\treturn gfx_v8_0_hw_fini(handle);\n}\n\nstatic int gfx_v8_0_resume(void *handle)\n{\n\treturn gfx_v8_0_hw_init(handle);\n}\n\nstatic bool gfx_v8_0_check_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(mmGRBM_STATUS);\n\tif (tmp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |\n\t\t   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |\n\t\t   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |\n\t\t   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |\n\t\t   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |\n\t\t   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK |\n\t\t   GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK)) {\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_CP, 1);\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_GFX, 1);\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset,\n\t\t\t\t\t\tSRBM_SOFT_RESET, SOFT_RESET_GRBM, 1);\n\t}\n\n\t \n\ttmp = RREG32(mmGRBM_STATUS2);\n\tif (REG_GET_FIELD(tmp, GRBM_STATUS2, RLC_BUSY))\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_RLC, 1);\n\n\tif (REG_GET_FIELD(tmp, GRBM_STATUS2, CPF_BUSY) ||\n\t    REG_GET_FIELD(tmp, GRBM_STATUS2, CPC_BUSY) ||\n\t    REG_GET_FIELD(tmp, GRBM_STATUS2, CPG_BUSY)) {\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\t\tSOFT_RESET_CPF, 1);\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\t\tSOFT_RESET_CPC, 1);\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\t\tSOFT_RESET_CPG, 1);\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET,\n\t\t\t\t\t\tSOFT_RESET_GRBM, 1);\n\t}\n\n\t \n\ttmp = RREG32(mmSRBM_STATUS);\n\tif (REG_GET_FIELD(tmp, SRBM_STATUS, GRBM_RQ_PENDING))\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset,\n\t\t\t\t\t\tSRBM_SOFT_RESET, SOFT_RESET_GRBM, 1);\n\tif (REG_GET_FIELD(tmp, SRBM_STATUS, SEM_BUSY))\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset,\n\t\t\t\t\t\tSRBM_SOFT_RESET, SOFT_RESET_SEM, 1);\n\n\tif (grbm_soft_reset || srbm_soft_reset) {\n\t\tadev->gfx.grbm_soft_reset = grbm_soft_reset;\n\t\tadev->gfx.srbm_soft_reset = srbm_soft_reset;\n\t\treturn true;\n\t} else {\n\t\tadev->gfx.grbm_soft_reset = 0;\n\t\tadev->gfx.srbm_soft_reset = 0;\n\t\treturn false;\n\t}\n}\n\nstatic int gfx_v8_0_pre_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 grbm_soft_reset = 0;\n\n\tif ((!adev->gfx.grbm_soft_reset) &&\n\t    (!adev->gfx.srbm_soft_reset))\n\t\treturn 0;\n\n\tgrbm_soft_reset = adev->gfx.grbm_soft_reset;\n\n\t \n\tadev->gfx.rlc.funcs->stop(adev);\n\n\tif (REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CP) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_GFX))\n\t\t \n\t\tgfx_v8_0_cp_gfx_enable(adev, false);\n\n\tif (REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CP) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPF) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPC) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPG)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\n\t\t\tmutex_lock(&adev->srbm_mutex);\n\t\t\tvi_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\t\tgfx_v8_0_deactivate_hqd(adev, 2);\n\t\t\tvi_srbm_select(adev, 0, 0, 0, 0);\n\t\t\tmutex_unlock(&adev->srbm_mutex);\n\t\t}\n\t\t \n\t\tgfx_v8_0_cp_compute_enable(adev, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif ((!adev->gfx.grbm_soft_reset) &&\n\t    (!adev->gfx.srbm_soft_reset))\n\t\treturn 0;\n\n\tgrbm_soft_reset = adev->gfx.grbm_soft_reset;\n\tsrbm_soft_reset = adev->gfx.srbm_soft_reset;\n\n\tif (grbm_soft_reset || srbm_soft_reset) {\n\t\ttmp = RREG32(mmGMCON_DEBUG);\n\t\ttmp = REG_SET_FIELD(tmp, GMCON_DEBUG, GFX_STALL, 1);\n\t\ttmp = REG_SET_FIELD(tmp, GMCON_DEBUG, GFX_CLEAR, 1);\n\t\tWREG32(mmGMCON_DEBUG, tmp);\n\t\tudelay(50);\n\t}\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(adev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(adev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t}\n\n\tif (grbm_soft_reset || srbm_soft_reset) {\n\t\ttmp = RREG32(mmGMCON_DEBUG);\n\t\ttmp = REG_SET_FIELD(tmp, GMCON_DEBUG, GFX_STALL, 0);\n\t\ttmp = REG_SET_FIELD(tmp, GMCON_DEBUG, GFX_CLEAR, 0);\n\t\tWREG32(mmGMCON_DEBUG, tmp);\n\t}\n\n\t \n\tudelay(50);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_post_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 grbm_soft_reset = 0;\n\n\tif ((!adev->gfx.grbm_soft_reset) &&\n\t    (!adev->gfx.srbm_soft_reset))\n\t\treturn 0;\n\n\tgrbm_soft_reset = adev->gfx.grbm_soft_reset;\n\n\tif (REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CP) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPF) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPC) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CPG)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\n\t\t\tmutex_lock(&adev->srbm_mutex);\n\t\t\tvi_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\t\tgfx_v8_0_deactivate_hqd(adev, 2);\n\t\t\tvi_srbm_select(adev, 0, 0, 0, 0);\n\t\t\tmutex_unlock(&adev->srbm_mutex);\n\t\t}\n\t\tgfx_v8_0_kiq_resume(adev);\n\t\tgfx_v8_0_kcq_resume(adev);\n\t}\n\n\tif (REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_CP) ||\n\t    REG_GET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET, SOFT_RESET_GFX))\n\t\tgfx_v8_0_cp_gfx_resume(adev);\n\n\tgfx_v8_0_cp_test_all_rings(adev);\n\n\tadev->gfx.rlc.funcs->start(adev);\n\n\treturn 0;\n}\n\n \nstatic uint64_t gfx_v8_0_get_gpu_clock_counter(struct amdgpu_device *adev)\n{\n\tuint64_t clock;\n\n\tmutex_lock(&adev->gfx.gpu_clock_mutex);\n\tWREG32(mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\tclock = (uint64_t)RREG32(mmRLC_GPU_CLOCK_COUNT_LSB) |\n\t\t((uint64_t)RREG32(mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\tmutex_unlock(&adev->gfx.gpu_clock_mutex);\n\treturn clock;\n}\n\nstatic void gfx_v8_0_ring_emit_gds_switch(struct amdgpu_ring *ring,\n\t\t\t\t\t  uint32_t vmid,\n\t\t\t\t\t  uint32_t gds_base, uint32_t gds_size,\n\t\t\t\t\t  uint32_t gws_base, uint32_t gws_size,\n\t\t\t\t\t  uint32_t oa_base, uint32_t oa_size)\n{\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].mem_base);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gds_base);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].mem_size);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gds_size);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].gws);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gws_size << GDS_GWS_VMID0__SIZE__SHIFT | gws_base);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].oa);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, (1 << (oa_size + oa_base)) - (1 << oa_base));\n}\n\nstatic uint32_t wave_read_ind(struct amdgpu_device *adev, uint32_t simd, uint32_t wave, uint32_t address)\n{\n\tWREG32(mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(address << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK));\n\treturn RREG32(mmSQ_IND_DATA);\n}\n\nstatic void wave_read_regs(struct amdgpu_device *adev, uint32_t simd,\n\t\t\t   uint32_t wave, uint32_t thread,\n\t\t\t   uint32_t regno, uint32_t num, uint32_t *out)\n{\n\tWREG32(mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(regno << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(thread << SQ_IND_INDEX__THREAD_ID__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK) |\n\t\t(SQ_IND_INDEX__AUTO_INCR_MASK));\n\twhile (num--)\n\t\t*(out++) = RREG32(mmSQ_IND_DATA);\n}\n\nstatic void gfx_v8_0_read_wave_data(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd, uint32_t wave, uint32_t *dst, int *no_fields)\n{\n\t \n\tdst[(*no_fields)++] = 0;\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_STATUS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_HW_ID);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW1);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_GPR_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_LDS_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TRAPSTS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_STS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TBA_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TBA_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TMA_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TMA_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_DBG0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_M0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_MODE);\n}\n\nstatic void gfx_v8_0_read_wave_sgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t     uint32_t wave, uint32_t start,\n\t\t\t\t     uint32_t size, uint32_t *dst)\n{\n\twave_read_regs(\n\t\tadev, simd, wave, 0,\n\t\tstart + SQIND_WAVE_SGPRS_OFFSET, size, dst);\n}\n\n\nstatic const struct amdgpu_gfx_funcs gfx_v8_0_gfx_funcs = {\n\t.get_gpu_clock_counter = &gfx_v8_0_get_gpu_clock_counter,\n\t.select_se_sh = &gfx_v8_0_select_se_sh,\n\t.read_wave_data = &gfx_v8_0_read_wave_data,\n\t.read_wave_sgprs = &gfx_v8_0_read_wave_sgprs,\n\t.select_me_pipe_q = &gfx_v8_0_select_me_pipe_q\n};\n\nstatic int gfx_v8_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->gfx.xcc_mask = 1;\n\tadev->gfx.num_gfx_rings = GFX8_NUM_GFX_RINGS;\n\tadev->gfx.num_compute_rings = min(amdgpu_gfx_get_num_kcq(adev),\n\t\t\t\t\t  AMDGPU_MAX_COMPUTE_RINGS);\n\tadev->gfx.funcs = &gfx_v8_0_gfx_funcs;\n\tgfx_v8_0_set_ring_funcs(adev);\n\tgfx_v8_0_set_irq_funcs(adev);\n\tgfx_v8_0_set_gds_init(adev);\n\tgfx_v8_0_set_rlc_funcs(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_reg_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_inst_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = gfx_v8_0_do_edc_gpr_workarounds(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.cp_ecc_error_irq, 0);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_irq_get() failed to get IRQ for EDC, r: %d.\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.sq_irq, 0);\n\tif (r) {\n\t\tDRM_ERROR(\n\t\t\t\"amdgpu_irq_get() failed to get IRQ for SQ, r: %d.\\n\",\n\t\t\tr);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_enable_gfx_static_mg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tif ((adev->asic_type == CHIP_POLARIS11) ||\n\t    (adev->asic_type == CHIP_POLARIS12) ||\n\t    (adev->asic_type == CHIP_VEGAM))\n\t\t \n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_GFX, enable);\n\n\tWREG32_FIELD(RLC_PG_CNTL, STATIC_PER_CU_PG_ENABLE, enable ? 1 : 0);\n}\n\nstatic void gfx_v8_0_enable_gfx_dynamic_mg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tbool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, DYN_PER_CU_PG_ENABLE, enable ? 1 : 0);\n}\n\nstatic void polaris11_enable_gfx_quick_mg_power_gating(struct amdgpu_device *adev,\n\t\tbool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, QUICK_PG_ENABLE, enable ? 1 : 0);\n}\n\nstatic void cz_enable_gfx_cg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t  bool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, GFX_POWER_GATING_ENABLE, enable ? 1 : 0);\n}\n\nstatic void cz_enable_gfx_pipeline_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tWREG32_FIELD(RLC_PG_CNTL, GFX_PIPELINE_PG_ENABLE, enable ? 1 : 0);\n\n\t \n\tif (!enable)\n\t\tRREG32(mmDB_RENDER_CONTROL);\n}\n\nstatic void cz_update_gfx_cg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t  bool enable)\n{\n\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) && enable) {\n\t\tcz_enable_gfx_cg_power_gating(adev, true);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)\n\t\t\tcz_enable_gfx_pipeline_power_gating(adev, true);\n\t} else {\n\t\tcz_enable_gfx_cg_power_gating(adev, false);\n\t\tcz_enable_gfx_pipeline_power_gating(adev, false);\n\t}\n}\n\nstatic int gfx_v8_0_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_PG_STATE_GATE);\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t\tAMD_PG_SUPPORT_RLC_SMU_HS |\n\t\t\t\tAMD_PG_SUPPORT_CP |\n\t\t\t\tAMD_PG_SUPPORT_GFX_DMG))\n\t\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\tswitch (adev->asic_type) {\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS) {\n\t\t\tcz_enable_sck_slow_down_on_power_up(adev, true);\n\t\t\tcz_enable_sck_slow_down_on_power_down(adev, true);\n\t\t} else {\n\t\t\tcz_enable_sck_slow_down_on_power_up(adev, false);\n\t\t\tcz_enable_sck_slow_down_on_power_down(adev, false);\n\t\t}\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_CP)\n\t\t\tcz_enable_cp_power_gating(adev, true);\n\t\telse\n\t\t\tcz_enable_cp_power_gating(adev, false);\n\n\t\tcz_update_gfx_cg_power_gating(adev, enable);\n\n\t\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG) && enable)\n\t\t\tgfx_v8_0_enable_gfx_static_mg_power_gating(adev, true);\n\t\telse\n\t\t\tgfx_v8_0_enable_gfx_static_mg_power_gating(adev, false);\n\n\t\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG) && enable)\n\t\t\tgfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, true);\n\t\telse\n\t\t\tgfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, false);\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\t\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG) && enable)\n\t\t\tgfx_v8_0_enable_gfx_static_mg_power_gating(adev, true);\n\t\telse\n\t\t\tgfx_v8_0_enable_gfx_static_mg_power_gating(adev, false);\n\n\t\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG) && enable)\n\t\t\tgfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, true);\n\t\telse\n\t\t\tgfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, false);\n\n\t\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_QUICK_MG) && enable)\n\t\t\tpolaris11_enable_gfx_quick_mg_power_gating(adev, true);\n\t\telse\n\t\t\tpolaris11_enable_gfx_quick_mg_power_gating(adev, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t\tAMD_PG_SUPPORT_RLC_SMU_HS |\n\t\t\t\tAMD_PG_SUPPORT_CP |\n\t\t\t\tAMD_PG_SUPPORT_GFX_DMG))\n\t\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n\treturn 0;\n}\n\nstatic void gfx_v8_0_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint data;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\t*flags = 0;\n\n\t \n\tdata = RREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__CPF_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_MGCG;\n\n\t \n\tdata = RREG32(mmRLC_CGCG_CGLS_CTRL);\n\tif (data & RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGCG;\n\n\t \n\tif (data & RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGLS;\n\n\t \n\tdata = RREG32(mmCGTS_SM_CTRL_REG);\n\tif (!(data & CGTS_SM_CTRL_REG__OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGTS;\n\n\t \n\tif (!(data & CGTS_SM_CTRL_REG__LS_OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGTS_LS;\n\n\t \n\tdata = RREG32(mmRLC_MEM_SLP_CNTL);\n\tif (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_RLC_LS | AMD_CG_SUPPORT_GFX_MGLS;\n\n\t \n\tdata = RREG32(mmCP_MEM_SLP_CNTL);\n\tif (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CP_LS | AMD_CG_SUPPORT_GFX_MGLS;\n}\n\nstatic void gfx_v8_0_send_serdes_cmd(struct amdgpu_device *adev,\n\t\t\t\t     uint32_t reg_addr, uint32_t cmd)\n{\n\tuint32_t data;\n\n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\n\tWREG32(mmRLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\tWREG32(mmRLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\n\tdata = RREG32(mmRLC_SERDES_WR_CTRL);\n\tif (adev->asic_type == CHIP_STONEY)\n\t\tdata &= ~(RLC_SERDES_WR_CTRL__WRITE_COMMAND_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__READ_COMMAND_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__P1_SELECT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__P2_SELECT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__RDDATA_RESET_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__POWER_DOWN_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__POWER_UP_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__SHORT_FORMAT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__SRBM_OVERRIDE_MASK);\n\telse\n\t\tdata &= ~(RLC_SERDES_WR_CTRL__WRITE_COMMAND_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__READ_COMMAND_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__P1_SELECT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__P2_SELECT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__RDDATA_RESET_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__POWER_DOWN_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__POWER_UP_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__SHORT_FORMAT_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__BPM_DATA_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__REG_ADDR_MASK |\n\t\t\t  RLC_SERDES_WR_CTRL__SRBM_OVERRIDE_MASK);\n\tdata |= (RLC_SERDES_WR_CTRL__RSVD_BPM_ADDR_MASK |\n\t\t (cmd << RLC_SERDES_WR_CTRL__BPM_DATA__SHIFT) |\n\t\t (reg_addr << RLC_SERDES_WR_CTRL__REG_ADDR__SHIFT) |\n\t\t (0xff << RLC_SERDES_WR_CTRL__BPM_ADDR__SHIFT));\n\n\tWREG32(mmRLC_SERDES_WR_CTRL, data);\n}\n\n#define MSG_ENTER_RLC_SAFE_MODE     1\n#define MSG_EXIT_RLC_SAFE_MODE      0\n#define RLC_GPR_REG2__REQ_MASK 0x00000001\n#define RLC_GPR_REG2__REQ__SHIFT 0\n#define RLC_GPR_REG2__MESSAGE__SHIFT 0x00000001\n#define RLC_GPR_REG2__MESSAGE_MASK 0x0000001e\n\nstatic bool gfx_v8_0_is_rlc_enabled(struct amdgpu_device *adev)\n{\n\tuint32_t rlc_setting;\n\n\trlc_setting = RREG32(mmRLC_CNTL);\n\tif (!(rlc_setting & RLC_CNTL__RLC_ENABLE_F32_MASK))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void gfx_v8_0_set_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tuint32_t data;\n\tunsigned i;\n\tdata = RREG32(mmRLC_CNTL);\n\tdata |= RLC_SAFE_MODE__CMD_MASK;\n\tdata &= ~RLC_SAFE_MODE__MESSAGE_MASK;\n\tdata |= (1 << RLC_SAFE_MODE__MESSAGE__SHIFT);\n\tWREG32(mmRLC_SAFE_MODE, data);\n\n\t \n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif ((RREG32(mmRLC_GPM_STAT) &\n\t\t     (RLC_GPM_STAT__GFX_CLOCK_STATUS_MASK |\n\t\t      RLC_GPM_STAT__GFX_POWER_STATUS_MASK)) ==\n\t\t    (RLC_GPM_STAT__GFX_CLOCK_STATUS_MASK |\n\t\t     RLC_GPM_STAT__GFX_POWER_STATUS_MASK))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!REG_GET_FIELD(RREG32(mmRLC_SAFE_MODE), RLC_SAFE_MODE, CMD))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v8_0_unset_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tuint32_t data;\n\tunsigned i;\n\n\tdata = RREG32(mmRLC_CNTL);\n\tdata |= RLC_SAFE_MODE__CMD_MASK;\n\tdata &= ~RLC_SAFE_MODE__MESSAGE_MASK;\n\tWREG32(mmRLC_SAFE_MODE, data);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!REG_GET_FIELD(RREG32(mmRLC_SAFE_MODE), RLC_SAFE_MODE, CMD))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v8_0_update_spm_vmid(struct amdgpu_device *adev, unsigned vmid)\n{\n\tu32 data;\n\n\tamdgpu_gfx_off_ctrl(adev, false);\n\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tdata = RREG32_NO_KIQ(mmRLC_SPM_VMID);\n\telse\n\t\tdata = RREG32(mmRLC_SPM_VMID);\n\n\tdata &= ~RLC_SPM_VMID__RLC_SPM_VMID_MASK;\n\tdata |= (vmid & RLC_SPM_VMID__RLC_SPM_VMID_MASK) << RLC_SPM_VMID__RLC_SPM_VMID__SHIFT;\n\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tWREG32_NO_KIQ(mmRLC_SPM_VMID, data);\n\telse\n\t\tWREG32(mmRLC_SPM_VMID, data);\n\n\tamdgpu_gfx_off_ctrl(adev, true);\n}\n\nstatic const struct amdgpu_rlc_funcs iceland_rlc_funcs = {\n\t.is_rlc_enabled = gfx_v8_0_is_rlc_enabled,\n\t.set_safe_mode = gfx_v8_0_set_safe_mode,\n\t.unset_safe_mode = gfx_v8_0_unset_safe_mode,\n\t.init = gfx_v8_0_rlc_init,\n\t.get_csb_size = gfx_v8_0_get_csb_size,\n\t.get_csb_buffer = gfx_v8_0_get_csb_buffer,\n\t.get_cp_table_num = gfx_v8_0_cp_jump_table_num,\n\t.resume = gfx_v8_0_rlc_resume,\n\t.stop = gfx_v8_0_rlc_stop,\n\t.reset = gfx_v8_0_rlc_reset,\n\t.start = gfx_v8_0_rlc_start,\n\t.update_spm_vmid = gfx_v8_0_update_spm_vmid\n};\n\nstatic void gfx_v8_0_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t temp, data;\n\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\t \n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) {\n\t\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_RLC_LS)\n\t\t\t\t \n\t\t\t\tWREG32_FIELD(RLC_MEM_SLP_CNTL, RLC_MEM_LS_EN, 1);\n\n\t\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CP_LS)\n\t\t\t\tWREG32_FIELD(CP_MEM_SLP_CNTL, CP_MEM_LS_EN, 1);\n\t\t}\n\n\t\t \n\t\ttemp = data = RREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tif (adev->flags & AMD_IS_APU)\n\t\t\tdata &= ~(RLC_CGTT_MGCG_OVERRIDE__CPF_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__RLC_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__MGCG_MASK);\n\t\telse\n\t\t\tdata &= ~(RLC_CGTT_MGCG_OVERRIDE__CPF_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__RLC_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__MGCG_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__GRBM_MASK);\n\n\t\tif (temp != data)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_MGCG_OVERRIDE, CLE_BPM_SERDES_CMD);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGTS) {\n\t\t\t \n\t\t\ttemp = data = RREG32(mmCGTS_SM_CTRL_REG);\n\t\t\tdata &= ~(CGTS_SM_CTRL_REG__SM_MODE_MASK);\n\t\t\tdata |= (0x2 << CGTS_SM_CTRL_REG__SM_MODE__SHIFT);\n\t\t\tdata |= CGTS_SM_CTRL_REG__SM_MODE_ENABLE_MASK;\n\t\t\tdata &= ~CGTS_SM_CTRL_REG__OVERRIDE_MASK;\n\t\t\tif ((adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) &&\n\t\t\t    (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGTS_LS))\n\t\t\t\tdata &= ~CGTS_SM_CTRL_REG__LS_OVERRIDE_MASK;\n\t\t\tdata |= CGTS_SM_CTRL_REG__ON_MONITOR_ADD_EN_MASK;\n\t\t\tdata |= (0x96 << CGTS_SM_CTRL_REG__ON_MONITOR_ADD__SHIFT);\n\t\t\tif (temp != data)\n\t\t\t\tWREG32(mmCGTS_SM_CTRL_REG, data);\n\t\t}\n\t\tudelay(50);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\t} else {\n\t\t \n\t\ttemp = data = RREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= (RLC_CGTT_MGCG_OVERRIDE__CPF_MASK |\n\t\t\t\tRLC_CGTT_MGCG_OVERRIDE__RLC_MASK |\n\t\t\t\tRLC_CGTT_MGCG_OVERRIDE__MGCG_MASK |\n\t\t\t\tRLC_CGTT_MGCG_OVERRIDE__GRBM_MASK);\n\t\tif (temp != data)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tdata = RREG32(mmRLC_MEM_SLP_CNTL);\n\t\tif (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;\n\t\t\tWREG32(mmRLC_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\t \n\t\tdata = RREG32(mmCP_MEM_SLP_CNTL);\n\t\tif (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;\n\t\t\tWREG32(mmCP_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\t \n\t\ttemp = data = RREG32(mmCGTS_SM_CTRL_REG);\n\t\tdata |= (CGTS_SM_CTRL_REG__OVERRIDE_MASK |\n\t\t\t\tCGTS_SM_CTRL_REG__LS_OVERRIDE_MASK);\n\t\tif (temp != data)\n\t\t\tWREG32(mmCGTS_SM_CTRL_REG, data);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_MGCG_OVERRIDE, SET_BPM_SERDES_CMD);\n\n\t\tudelay(50);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\t}\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic void gfx_v8_0_update_coarse_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t temp, temp1, data, data1;\n\n\ttemp = data = RREG32(mmRLC_CGCG_CGLS_CTRL);\n\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)) {\n\t\ttemp1 = data1 =\tRREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tdata1 &= ~RLC_CGTT_MGCG_OVERRIDE__CGCG_MASK;\n\t\tif (temp1 != data1)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data1);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_CGCG_OVERRIDE, CLE_BPM_SERDES_CMD);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_CGLS_EN, SET_BPM_SERDES_CMD);\n\n\t\t \n\t\tdata |= RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS) {\n\t\t\t \n\t\t\tdata |= RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\n\t\t\ttemp1 = data1 =\tRREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\t\tdata1 &= ~RLC_CGTT_MGCG_OVERRIDE__CGLS_MASK;\n\n\t\t\tif (temp1 != data1)\n\t\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data1);\n\t\t} else {\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\t\t}\n\n\t\tif (temp != data)\n\t\t\tWREG32(mmRLC_CGCG_CGLS_CTRL, data);\n\n\t\t \n\t\tgfx_v8_0_enable_gui_idle_interrupt(adev, true);\n\t} else {\n\t\t \n\t\tgfx_v8_0_enable_gui_idle_interrupt(adev, false);\n\n\t\t \n\t\ttemp1 = data1 =\tRREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tdata1 |= (RLC_CGTT_MGCG_OVERRIDE__CGCG_MASK |\n\t\t\t\tRLC_CGTT_MGCG_OVERRIDE__CGLS_MASK);\n\t\tif (temp1 != data1)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data1);\n\n\t\t \n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_CGCG_OVERRIDE, SET_BPM_SERDES_CMD);\n\n\t\t \n\t\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\t\t \n\t\tgfx_v8_0_send_serdes_cmd(adev, BPM_REG_CGLS_EN, CLE_BPM_SERDES_CMD);\n\n\t\t \n\t\tdata &= ~(RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK |\n\t\t\t  RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK);\n\t\tif (temp != data)\n\t\t\tWREG32(mmRLC_CGCG_CGLS_CTRL, data);\n\t\t \n\t\tgfx_v8_0_enable_gui_idle_interrupt(adev, true);\n\t}\n\n\tgfx_v8_0_wait_for_rlc_serdes(adev);\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\nstatic int gfx_v8_0_update_gfx_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t    bool enable)\n{\n\tif (enable) {\n\t\t \n\t\tgfx_v8_0_update_medium_grain_clock_gating(adev, enable);\n\t\tgfx_v8_0_update_coarse_grain_clock_gating(adev, enable);\n\t} else {\n\t\t \n\t\tgfx_v8_0_update_coarse_grain_clock_gating(adev, enable);\n\t\tgfx_v8_0_update_medium_grain_clock_gating(adev, enable);\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v8_0_tonga_update_gfx_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tuint32_t msg_id, pp_state = 0;\n\tuint32_t pp_support_state = 0;\n\n\tif (adev->cg_flags & (AMD_CG_SUPPORT_GFX_CGCG | AMD_CG_SUPPORT_GFX_CGLS)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS) {\n\t\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\t\t\tpp_state = PP_STATE_LS;\n\t\t}\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG) {\n\t\t\tpp_support_state |= PP_STATE_SUPPORT_CG;\n\t\t\tpp_state |= PP_STATE_CG;\n\t\t}\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_CG,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\tif (adev->cg_flags & (AMD_CG_SUPPORT_GFX_MGCG | AMD_CG_SUPPORT_GFX_MGLS)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) {\n\t\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\t\t\tpp_state = PP_STATE_LS;\n\t\t}\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG) {\n\t\t\tpp_support_state |= PP_STATE_SUPPORT_CG;\n\t\t\tpp_state |= PP_STATE_CG;\n\t\t}\n\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_MG,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_polaris_update_gfx_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\n\tuint32_t msg_id, pp_state = 0;\n\tuint32_t pp_support_state = 0;\n\n\tif (adev->cg_flags & (AMD_CG_SUPPORT_GFX_CGCG | AMD_CG_SUPPORT_GFX_CGLS)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS) {\n\t\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\t\t\tpp_state = PP_STATE_LS;\n\t\t}\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG) {\n\t\t\tpp_support_state |= PP_STATE_SUPPORT_CG;\n\t\t\tpp_state |= PP_STATE_CG;\n\t\t}\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_CG,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\tif (adev->cg_flags & (AMD_CG_SUPPORT_GFX_3D_CGCG | AMD_CG_SUPPORT_GFX_3D_CGLS)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS) {\n\t\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\t\t\tpp_state = PP_STATE_LS;\n\t\t}\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG) {\n\t\t\tpp_support_state |= PP_STATE_SUPPORT_CG;\n\t\t\tpp_state |= PP_STATE_CG;\n\t\t}\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_3D,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\tif (adev->cg_flags & (AMD_CG_SUPPORT_GFX_MGCG | AMD_CG_SUPPORT_GFX_MGLS)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) {\n\t\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\t\t\tpp_state = PP_STATE_LS;\n\t\t}\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG) {\n\t\t\tpp_support_state |= PP_STATE_SUPPORT_CG;\n\t\t\tpp_state |= PP_STATE_CG;\n\t\t}\n\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_MG,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_RLC_LS) {\n\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\t\telse\n\t\t\tpp_state = PP_STATE_LS;\n\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\t\tPP_BLOCK_GFX_RLC,\n\t\t\t\tpp_support_state,\n\t\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CP_LS) {\n\t\tpp_support_state = PP_STATE_SUPPORT_LS;\n\n\t\tif (state == AMD_CG_STATE_UNGATE)\n\t\t\tpp_state = 0;\n\t\telse\n\t\t\tpp_state = PP_STATE_LS;\n\t\tmsg_id = PP_CG_MSG_ID(PP_GROUP_GFX,\n\t\t\tPP_BLOCK_GFX_CP,\n\t\t\tpp_support_state,\n\t\t\tpp_state);\n\t\tamdgpu_dpm_set_clockgating_by_smu(adev, msg_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_FIJI:\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\t\tgfx_v8_0_update_gfx_clock_gating(adev,\n\t\t\t\t\t\t state == AMD_CG_STATE_GATE);\n\t\tbreak;\n\tcase CHIP_TONGA:\n\t\tgfx_v8_0_tonga_update_gfx_clock_gating(adev, state);\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\t\tgfx_v8_0_polaris_update_gfx_clock_gating(adev, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u64 gfx_v8_0_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\treturn *ring->rptr_cpu_addr;\n}\n\nstatic u64 gfx_v8_0_ring_get_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->use_doorbell)\n\t\t \n\t\treturn *ring->wptr_cpu_addr;\n\telse\n\t\treturn RREG32(mmCP_RB0_WPTR);\n}\n\nstatic void gfx_v8_0_ring_set_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->use_doorbell) {\n\t\t \n\t\t*ring->wptr_cpu_addr = lower_32_bits(ring->wptr);\n\t\tWDOORBELL32(ring->doorbell_index, lower_32_bits(ring->wptr));\n\t} else {\n\t\tWREG32(mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\t\t(void)RREG32(mmCP_RB0_WPTR);\n\t}\n}\n\nstatic void gfx_v8_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\n{\n\tu32 ref_and_mask, reg_mem_engine;\n\n\tif ((ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) ||\n\t    (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)) {\n\t\tswitch (ring->me) {\n\t\tcase 1:\n\t\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP2_MASK << ring->pipe;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP6_MASK << ring->pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\treg_mem_engine = 0;\n\t} else {\n\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP0_MASK;\n\t\treg_mem_engine = WAIT_REG_MEM_ENGINE(1);  \n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_OPERATION(1) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |   \n\t\t\t\t reg_mem_engine));\n\tamdgpu_ring_write(ring, mmGPU_HDP_FLUSH_REQ);\n\tamdgpu_ring_write(ring, mmGPU_HDP_FLUSH_DONE);\n\tamdgpu_ring_write(ring, ref_and_mask);\n\tamdgpu_ring_write(ring, ref_and_mask);\n\tamdgpu_ring_write(ring, 0x20);  \n}\n\nstatic void gfx_v8_0_ring_emit_vgt_flush(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE, 0));\n\tamdgpu_ring_write(ring, EVENT_TYPE(VS_PARTIAL_FLUSH) |\n\t\tEVENT_INDEX(4));\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE, 0));\n\tamdgpu_ring_write(ring, EVENT_TYPE(VGT_FLUSH) |\n\t\tEVENT_INDEX(0));\n}\n\nstatic void gfx_v8_0_ring_emit_ib_gfx(struct amdgpu_ring *ring,\n\t\t\t\t\tstruct amdgpu_job *job,\n\t\t\t\t\tstruct amdgpu_ib *ib,\n\t\t\t\t\tuint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 header, control = 0;\n\n\tif (ib->flags & AMDGPU_IB_FLAG_CE)\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER_CONST, 2);\n\telse\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\n\tcontrol |= ib->length_dw | (vmid << 24);\n\n\tif (amdgpu_sriov_vf(ring->adev) && (ib->flags & AMDGPU_IB_FLAG_PREEMPT)) {\n\t\tcontrol |= INDIRECT_BUFFER_PRE_ENB(1);\n\n\t\tif (!(ib->flags & AMDGPU_IB_FLAG_CE) && vmid)\n\t\t\tgfx_v8_0_ring_emit_de_meta(ring);\n\t}\n\n\tamdgpu_ring_write(ring, header);\n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v8_0_ring_emit_ib_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t\t  uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);\n\n\t \n\tif (ib->flags & AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID) {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tamdgpu_ring_write(ring, mmGDS_COMPUTE_MAX_WAVE_ID - PACKET3_SET_CONFIG_REG_START);\n\t\tamdgpu_ring_write(ring, ring->adev->gds.gds_compute_max_wave_id);\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t\t(2 << 0) |\n#endif\n\t\t\t\t(ib->gpu_addr & 0xFFFFFFFC));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v8_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t\t u64 seq, unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EOP_TC_WB_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, (upper_32_bits(addr) & 0xffff) |\n\t\t\t\tDATA_SEL(1) | INT_SEL(0));\n\tamdgpu_ring_write(ring, lower_32_bits(seq - 1));\n\tamdgpu_ring_write(ring, upper_32_bits(seq - 1));\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EOP_TC_WB_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, (upper_32_bits(addr) & 0xffff) |\n\t\t\t  DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n\n}\n\nstatic void gfx_v8_0_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_MEM_SPACE(1) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |  \n\t\t\t\t WAIT_REG_MEM_ENGINE(usepfp)));  \n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, upper_32_bits(addr) & 0xffffffff);\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, 0xffffffff);\n\tamdgpu_ring_write(ring, 4);  \n}\n\nstatic void gfx_v8_0_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned vmid, uint64_t pd_addr)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\n\tamdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_OPERATION(0) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(0) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(0)));  \n\tamdgpu_ring_write(ring, mmVM_INVALIDATE_REQUEST);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0x20);  \n\n\t \n\tif (usepfp) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tamdgpu_ring_write(ring, 0x0);\n\t}\n}\n\nstatic u64 gfx_v8_0_ring_get_wptr_compute(struct amdgpu_ring *ring)\n{\n\treturn *ring->wptr_cpu_addr;\n}\n\nstatic void gfx_v8_0_ring_set_wptr_compute(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\t*ring->wptr_cpu_addr = lower_32_bits(ring->wptr);\n\tWDOORBELL32(ring->doorbell_index, lower_32_bits(ring->wptr));\n}\n\nstatic void gfx_v8_0_ring_emit_fence_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t     u64 addr, u64 seq,\n\t\t\t\t\t     unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, 5));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EOP_TC_WB_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n}\n\nstatic void gfx_v8_0_ring_emit_fence_kiq(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t\t u64 seq, unsigned int flags)\n{\n\t \n\tBUG_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t WRITE_DATA_DST_SEL(5) | WR_CONFIRM));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\n\tif (flags & AMDGPU_FENCE_FLAG_INT) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\t\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t\t WRITE_DATA_DST_SEL(0) | WR_CONFIRM));\n\t\tamdgpu_ring_write(ring, mmCPC_INT_STATUS);\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring, 0x20000000);  \n\t}\n}\n\nstatic void gfx_v8_ring_emit_sb(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic void gfx_v8_ring_emit_cntxcntl(struct amdgpu_ring *ring, uint32_t flags)\n{\n\tuint32_t dw2 = 0;\n\n\tif (amdgpu_sriov_vf(ring->adev))\n\t\tgfx_v8_0_ring_emit_ce_meta(ring);\n\n\tdw2 |= 0x80000000;  \n\tif (flags & AMDGPU_HAVE_CTX_SWITCH) {\n\t\tgfx_v8_0_ring_emit_vgt_flush(ring);\n\t\t \n\t\tdw2 |= 0x8001;\n\t\t \n\t\tdw2 |= 0x01000000;\n\t\t \n\t\tdw2 |= 0x10002;\n\n\t\t \n\t\tif (AMDGPU_PREAMBLE_IB_PRESENT & flags)\n\t\t\tdw2 |= 0x10000000;\n\t} else {\n\t\t \n\t\tif (AMDGPU_PREAMBLE_IB_PRESENT_FIRST & flags)\n\t\t\tdw2 |= 0x10000000;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, dw2);\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic unsigned gfx_v8_0_ring_emit_init_cond_exec(struct amdgpu_ring *ring)\n{\n\tunsigned ret;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COND_EXEC, 3));\n\tamdgpu_ring_write(ring, lower_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, 0);  \n\tret = ring->wptr & ring->buf_mask;\n\tamdgpu_ring_write(ring, 0x55aa55aa);  \n\treturn ret;\n}\n\nstatic void gfx_v8_0_ring_emit_patch_cond_exec(struct amdgpu_ring *ring, unsigned offset)\n{\n\tunsigned cur;\n\n\tBUG_ON(offset > ring->buf_mask);\n\tBUG_ON(ring->ring[offset] != 0x55aa55aa);\n\n\tcur = (ring->wptr & ring->buf_mask) - 1;\n\tif (likely(cur > offset))\n\t\tring->ring[offset] = cur - offset;\n\telse\n\t\tring->ring[offset] = (ring->ring_size >> 2) - offset + cur;\n}\n\nstatic void gfx_v8_0_ring_emit_rreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t    uint32_t reg_val_offs)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COPY_DATA, 4));\n\tamdgpu_ring_write(ring, 0 |\t \n\t\t\t\t(5 << 8) |\t \n\t\t\t\t(1 << 20));\t \n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, lower_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n\tamdgpu_ring_write(ring, upper_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n}\n\nstatic void gfx_v8_0_ring_emit_wreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t  uint32_t val)\n{\n\tuint32_t cmd;\n\n\tswitch (ring->funcs->type) {\n\tcase AMDGPU_RING_TYPE_GFX:\n\t\tcmd = WRITE_DATA_ENGINE_SEL(1) | WR_CONFIRM;\n\t\tbreak;\n\tcase AMDGPU_RING_TYPE_KIQ:\n\t\tcmd = 1 << 16;  \n\t\tbreak;\n\tdefault:\n\t\tcmd = WR_CONFIRM;\n\t\tbreak;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, cmd);\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void gfx_v8_0_ring_soft_recovery(struct amdgpu_ring *ring, unsigned vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t value = 0;\n\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CMD, 0x03);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, MODE, 0x01);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CHECK_VMID, 1);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, VM_ID, vmid);\n\tWREG32(mmSQ_CMD, value);\n}\n\nstatic void gfx_v8_0_set_gfx_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t enum amdgpu_interrupt_state state)\n{\n\tWREG32_FIELD(CP_INT_CNTL_RING0, TIME_STAMP_INT_ENABLE,\n\t\t     state == AMDGPU_IRQ_STATE_DISABLE ? 0 : 1);\n}\n\nstatic void gfx_v8_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     int me, int pipe,\n\t\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tu32 mec_int_cntl, mec_int_cntl_reg;\n\n\t \n\n\tif (me == 1) {\n\t\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE0_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE1_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE2_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE3_INT_CNTL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"invalid me %d\\n\", me);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tmec_int_cntl = RREG32(mec_int_cntl_reg);\n\t\tmec_int_cntl &= ~CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tmec_int_cntl = RREG32(mec_int_cntl_reg);\n\t\tmec_int_cntl |= CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v8_0_set_priv_reg_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t     struct amdgpu_irq_src *source,\n\t\t\t\t\t     unsigned type,\n\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tWREG32_FIELD(CP_INT_CNTL_RING0, PRIV_REG_INT_ENABLE,\n\t\t     state == AMDGPU_IRQ_STATE_DISABLE ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_set_priv_inst_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t\t      unsigned type,\n\t\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tWREG32_FIELD(CP_INT_CNTL_RING0, PRIV_INSTR_INT_ENABLE,\n\t\t     state == AMDGPU_IRQ_STATE_DISABLE ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_set_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_irq_src *src,\n\t\t\t\t\t    unsigned type,\n\t\t\t\t\t    enum amdgpu_interrupt_state state)\n{\n\tswitch (type) {\n\tcase AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP:\n\t\tgfx_v8_0_set_gfx_eop_interrupt_state(adev, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 1, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE1_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 1, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE2_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 1, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE3_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 1, 3, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE0_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 2, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE1_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 2, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE2_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 2, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE3_EOP:\n\t\tgfx_v8_0_set_compute_eop_interrupt_state(adev, 2, 3, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v8_0_set_cp_ecc_int_state(struct amdgpu_device *adev,\n\t\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t\t unsigned int type,\n\t\t\t\t\t enum amdgpu_interrupt_state state)\n{\n\tint enable_flag;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tenable_flag = 0;\n\t\tbreak;\n\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tenable_flag = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_FIELD(CP_INT_CNTL, CP_ECC_ERROR_INT_ENABLE, enable_flag);\n\tWREG32_FIELD(CP_INT_CNTL_RING0, CP_ECC_ERROR_INT_ENABLE, enable_flag);\n\tWREG32_FIELD(CP_INT_CNTL_RING1, CP_ECC_ERROR_INT_ENABLE, enable_flag);\n\tWREG32_FIELD(CP_INT_CNTL_RING2, CP_ECC_ERROR_INT_ENABLE, enable_flag);\n\tWREG32_FIELD(CPC_INT_CNTL, CP_ECC_ERROR_INT_ENABLE, enable_flag);\n\tWREG32_FIELD(CP_ME1_PIPE0_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME1_PIPE1_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME1_PIPE2_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME1_PIPE3_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME2_PIPE0_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME2_PIPE1_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME2_PIPE2_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\tWREG32_FIELD(CP_ME2_PIPE3_INT_CNTL, CP_ECC_ERROR_INT_ENABLE,\n\t\t     enable_flag);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_set_sq_int_state(struct amdgpu_device *adev,\n\t\t\t\t     struct amdgpu_irq_src *source,\n\t\t\t\t     unsigned int type,\n\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tint enable_flag;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tenable_flag = 1;\n\t\tbreak;\n\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tenable_flag = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_FIELD(SQ_INTERRUPT_MSG_CTRL, STALL,\n\t\t     enable_flag);\n\n\treturn 0;\n}\n\nstatic int gfx_v8_0_eop_irq(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_irq_src *source,\n\t\t\t    struct amdgpu_iv_entry *entry)\n{\n\tint i;\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\n\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\tswitch (me_id) {\n\tcase 0:\n\t\tamdgpu_fence_process(&adev->gfx.gfx_ring[0]);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\t \n\t\t\tif ((ring->me == me_id) && (ring->pipe == pipe_id) && (ring->queue == queue_id))\n\t\t\t\tamdgpu_fence_process(ring);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v8_0_fault(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\tint i;\n\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\tswitch (me_id) {\n\tcase 0:\n\t\tdrm_sched_fault(&adev->gfx.gfx_ring[0].sched);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\tif (ring->me == me_id && ring->pipe == pipe_id &&\n\t\t\t    ring->queue == queue_id)\n\t\t\t\tdrm_sched_fault(&ring->sched);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v8_0_priv_reg_irq(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal register access in command stream\\n\");\n\tgfx_v8_0_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v8_0_priv_inst_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal instruction in command stream\\n\");\n\tgfx_v8_0_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v8_0_cp_ecc_error_irq(struct amdgpu_device *adev,\n\t\t\t\t     struct amdgpu_irq_src *source,\n\t\t\t\t     struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"CP EDC/ECC error detected.\");\n\treturn 0;\n}\n\nstatic void gfx_v8_0_parse_sq_irq(struct amdgpu_device *adev, unsigned ih_data,\n\t\t\t\t  bool from_wq)\n{\n\tu32 enc, se_id, sh_id, cu_id;\n\tchar type[20];\n\tint sq_edc_source = -1;\n\n\tenc = REG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_CMN, ENCODING);\n\tse_id = REG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_CMN, SE_ID);\n\n\tswitch (enc) {\n\t\tcase 0:\n\t\t\tDRM_INFO(\"SQ general purpose intr detected:\"\n\t\t\t\t\t\"se_id %d, immed_overflow %d, host_reg_overflow %d,\"\n\t\t\t\t\t\"host_cmd_overflow %d, cmd_timestamp %d,\"\n\t\t\t\t\t\"reg_timestamp %d, thread_trace_buff_full %d,\"\n\t\t\t\t\t\"wlt %d, thread_trace %d.\\n\",\n\t\t\t\t\tse_id,\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, IMMED_OVERFLOW),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, HOST_REG_OVERFLOW),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, HOST_CMD_OVERFLOW),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, CMD_TIMESTAMP),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, REG_TIMESTAMP),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, THREAD_TRACE_BUF_FULL),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, WLT),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_AUTO, THREAD_TRACE)\n\t\t\t\t\t);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\n\t\t\tcu_id = REG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, CU_ID);\n\t\t\tsh_id = REG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, SH_ID);\n\n\t\t\t \n\t\t\tif (from_wq) {\n\t\t\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\t\t\tgfx_v8_0_select_se_sh(adev, se_id, sh_id, cu_id, 0);\n\n\t\t\t\tsq_edc_source = REG_GET_FIELD(RREG32(mmSQ_EDC_INFO), SQ_EDC_INFO, SOURCE);\n\n\t\t\t\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\t\t\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\t\t\t}\n\n\t\t\tif (enc == 1)\n\t\t\t\tsprintf(type, \"instruction intr\");\n\t\t\telse\n\t\t\t\tsprintf(type, \"EDC/ECC error\");\n\n\t\t\tDRM_INFO(\n\t\t\t\t\"SQ %s detected: \"\n\t\t\t\t\t\"se_id %d, sh_id %d, cu_id %d, simd_id %d, wave_id %d, vm_id %d \"\n\t\t\t\t\t\"trap %s, sq_ed_info.source %s.\\n\",\n\t\t\t\t\ttype, se_id, sh_id, cu_id,\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, SIMD_ID),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, WAVE_ID),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, VM_ID),\n\t\t\t\t\tREG_GET_FIELD(ih_data, SQ_INTERRUPT_WORD_WAVE, PRIV) ? \"true\" : \"false\",\n\t\t\t\t\t(sq_edc_source != -1) ? sq_edc_source_names[sq_edc_source] : \"unavailable\"\n\t\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"SQ invalid encoding type\\n.\");\n\t}\n}\n\nstatic void gfx_v8_0_sq_irq_work_func(struct work_struct *work)\n{\n\n\tstruct amdgpu_device *adev = container_of(work, struct amdgpu_device, gfx.sq_work.work);\n\tstruct sq_work *sq_work = container_of(work, struct sq_work, work);\n\n\tgfx_v8_0_parse_sq_irq(adev, sq_work->ih_data, true);\n}\n\nstatic int gfx_v8_0_sq_irq(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tunsigned ih_data = entry->src_data[0];\n\n\t \n\tif (work_pending(&adev->gfx.sq_work.work)) {\n\t\tgfx_v8_0_parse_sq_irq(adev, ih_data, false);\n\t} else {\n\t\tadev->gfx.sq_work.ih_data = ih_data;\n\t\tschedule_work(&adev->gfx.sq_work.work);\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v8_0_emit_mem_sync(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\tamdgpu_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA |\n\t\t\t  PACKET3_TC_WB_ACTION_ENA);   \n\tamdgpu_ring_write(ring, 0xffffffff);   \n\tamdgpu_ring_write(ring, 0);   \n\tamdgpu_ring_write(ring, 0x0000000A);  \n}\n\nstatic void gfx_v8_0_emit_mem_sync_compute(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_ACQUIRE_MEM, 5));\n\tamdgpu_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA |\n\t\t\t  PACKET3_TC_WB_ACTION_ENA);   \n\tamdgpu_ring_write(ring, 0xffffffff);\t \n\tamdgpu_ring_write(ring, 0xff);\t\t \n\tamdgpu_ring_write(ring, 0);\t\t \n\tamdgpu_ring_write(ring, 0);\t\t \n\tamdgpu_ring_write(ring, 0x0000000A);\t \n}\n\n\n \n#define mmSPI_WCL_PIPE_PERCENT_CS_DEFAULT\t0x0000007f\nstatic void gfx_v8_0_emit_wave_limit_cs(struct amdgpu_ring *ring,\n\t\t\t\t\tuint32_t pipe, bool enable)\n{\n\tuint32_t val;\n\tuint32_t wcl_cs_reg;\n\n\tval = enable ? 0x1 : mmSPI_WCL_PIPE_PERCENT_CS_DEFAULT;\n\n\tswitch (pipe) {\n\tcase 0:\n\t\twcl_cs_reg = mmSPI_WCL_PIPE_PERCENT_CS0;\n\t\tbreak;\n\tcase 1:\n\t\twcl_cs_reg = mmSPI_WCL_PIPE_PERCENT_CS1;\n\t\tbreak;\n\tcase 2:\n\t\twcl_cs_reg = mmSPI_WCL_PIPE_PERCENT_CS2;\n\t\tbreak;\n\tcase 3:\n\t\twcl_cs_reg = mmSPI_WCL_PIPE_PERCENT_CS3;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tamdgpu_ring_emit_wreg(ring, wcl_cs_reg, val);\n\n}\n\n#define mmSPI_WCL_PIPE_PERCENT_GFX_DEFAULT\t0x07ffffff\nstatic void gfx_v8_0_emit_wave_limit(struct amdgpu_ring *ring, bool enable)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t val;\n\tint i;\n\n\t \n\tval = enable ? 0x1f : mmSPI_WCL_PIPE_PERCENT_GFX_DEFAULT;\n\tamdgpu_ring_emit_wreg(ring, mmSPI_WCL_PIPE_PERCENT_GFX, val);\n\n\t \n\tfor (i = 0; i < adev->gfx.mec.num_pipe_per_mec; i++) {\n\t\tif (i != ring->pipe)\n\t\t\tgfx_v8_0_emit_wave_limit_cs(ring, i, enable);\n\n\t}\n\n}\n\nstatic const struct amd_ip_funcs gfx_v8_0_ip_funcs = {\n\t.name = \"gfx_v8_0\",\n\t.early_init = gfx_v8_0_early_init,\n\t.late_init = gfx_v8_0_late_init,\n\t.sw_init = gfx_v8_0_sw_init,\n\t.sw_fini = gfx_v8_0_sw_fini,\n\t.hw_init = gfx_v8_0_hw_init,\n\t.hw_fini = gfx_v8_0_hw_fini,\n\t.suspend = gfx_v8_0_suspend,\n\t.resume = gfx_v8_0_resume,\n\t.is_idle = gfx_v8_0_is_idle,\n\t.wait_for_idle = gfx_v8_0_wait_for_idle,\n\t.check_soft_reset = gfx_v8_0_check_soft_reset,\n\t.pre_soft_reset = gfx_v8_0_pre_soft_reset,\n\t.soft_reset = gfx_v8_0_soft_reset,\n\t.post_soft_reset = gfx_v8_0_post_soft_reset,\n\t.set_clockgating_state = gfx_v8_0_set_clockgating_state,\n\t.set_powergating_state = gfx_v8_0_set_powergating_state,\n\t.get_clockgating_state = gfx_v8_0_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v8_0_ring_funcs_gfx = {\n\t.type = AMDGPU_RING_TYPE_GFX,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = false,\n\t.get_rptr = gfx_v8_0_ring_get_rptr,\n\t.get_wptr = gfx_v8_0_ring_get_wptr_gfx,\n\t.set_wptr = gfx_v8_0_ring_set_wptr_gfx,\n\t.emit_frame_size =  \n\t\t5 +   \n\t\t7 +   \n\t\tVI_FLUSH_GPU_TLB_NUM_WREG * 5 + 9 +  \n\t\t12 +   \n\t\t20 +  \n\t\t4 +  \n\t\t5 +  \n\t\t7 +\t  \n\t\t4 +\t  \n\t\t14 +  \n\t\t31 +  \n\t\t3 +  \n\t\t5 +  \n\t\t12 + 12 +  \n\t\t2 +  \n\t\t5,  \n\t.emit_ib_size =\t4,  \n\t.emit_ib = gfx_v8_0_ring_emit_ib_gfx,\n\t.emit_fence = gfx_v8_0_ring_emit_fence_gfx,\n\t.emit_pipeline_sync = gfx_v8_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v8_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v8_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v8_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v8_0_ring_test_ring,\n\t.test_ib = gfx_v8_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_switch_buffer = gfx_v8_ring_emit_sb,\n\t.emit_cntxcntl = gfx_v8_ring_emit_cntxcntl,\n\t.init_cond_exec = gfx_v8_0_ring_emit_init_cond_exec,\n\t.patch_cond_exec = gfx_v8_0_ring_emit_patch_cond_exec,\n\t.emit_wreg = gfx_v8_0_ring_emit_wreg,\n\t.soft_recovery = gfx_v8_0_ring_soft_recovery,\n\t.emit_mem_sync = gfx_v8_0_emit_mem_sync,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v8_0_ring_funcs_compute = {\n\t.type = AMDGPU_RING_TYPE_COMPUTE,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = false,\n\t.get_rptr = gfx_v8_0_ring_get_rptr,\n\t.get_wptr = gfx_v8_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v8_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tVI_FLUSH_GPU_TLB_NUM_WREG * 5 + 7 +  \n\t\t7 + 7 + 7 +  \n\t\t7 +  \n\t\t5 +  \n\t\t15,  \n\t.emit_ib_size =\t7,  \n\t.emit_ib = gfx_v8_0_ring_emit_ib_compute,\n\t.emit_fence = gfx_v8_0_ring_emit_fence_compute,\n\t.emit_pipeline_sync = gfx_v8_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v8_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v8_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v8_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v8_0_ring_test_ring,\n\t.test_ib = gfx_v8_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_wreg = gfx_v8_0_ring_emit_wreg,\n\t.emit_mem_sync = gfx_v8_0_emit_mem_sync_compute,\n\t.emit_wave_limit = gfx_v8_0_emit_wave_limit,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v8_0_ring_funcs_kiq = {\n\t.type = AMDGPU_RING_TYPE_KIQ,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = false,\n\t.get_rptr = gfx_v8_0_ring_get_rptr,\n\t.get_wptr = gfx_v8_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v8_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\t17 +  \n\t\t7 + 7 + 7,  \n\t.emit_ib_size =\t7,  \n\t.emit_fence = gfx_v8_0_ring_emit_fence_kiq,\n\t.test_ring = gfx_v8_0_ring_test_ring,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_rreg = gfx_v8_0_ring_emit_rreg,\n\t.emit_wreg = gfx_v8_0_ring_emit_wreg,\n};\n\nstatic void gfx_v8_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tadev->gfx.kiq[0].ring.funcs = &gfx_v8_0_ring_funcs_kiq;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tadev->gfx.gfx_ring[i].funcs = &gfx_v8_0_ring_funcs_gfx;\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tadev->gfx.compute_ring[i].funcs = &gfx_v8_0_ring_funcs_compute;\n}\n\nstatic const struct amdgpu_irq_src_funcs gfx_v8_0_eop_irq_funcs = {\n\t.set = gfx_v8_0_set_eop_interrupt_state,\n\t.process = gfx_v8_0_eop_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v8_0_priv_reg_irq_funcs = {\n\t.set = gfx_v8_0_set_priv_reg_fault_state,\n\t.process = gfx_v8_0_priv_reg_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v8_0_priv_inst_irq_funcs = {\n\t.set = gfx_v8_0_set_priv_inst_fault_state,\n\t.process = gfx_v8_0_priv_inst_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v8_0_cp_ecc_error_irq_funcs = {\n\t.set = gfx_v8_0_set_cp_ecc_int_state,\n\t.process = gfx_v8_0_cp_ecc_error_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v8_0_sq_irq_funcs = {\n\t.set = gfx_v8_0_set_sq_int_state,\n\t.process = gfx_v8_0_sq_irq,\n};\n\nstatic void gfx_v8_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.eop_irq.num_types = AMDGPU_CP_IRQ_LAST;\n\tadev->gfx.eop_irq.funcs = &gfx_v8_0_eop_irq_funcs;\n\n\tadev->gfx.priv_reg_irq.num_types = 1;\n\tadev->gfx.priv_reg_irq.funcs = &gfx_v8_0_priv_reg_irq_funcs;\n\n\tadev->gfx.priv_inst_irq.num_types = 1;\n\tadev->gfx.priv_inst_irq.funcs = &gfx_v8_0_priv_inst_irq_funcs;\n\n\tadev->gfx.cp_ecc_error_irq.num_types = 1;\n\tadev->gfx.cp_ecc_error_irq.funcs = &gfx_v8_0_cp_ecc_error_irq_funcs;\n\n\tadev->gfx.sq_irq.num_types = 1;\n\tadev->gfx.sq_irq.funcs = &gfx_v8_0_sq_irq_funcs;\n}\n\nstatic void gfx_v8_0_set_rlc_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.rlc.funcs = &iceland_rlc_funcs;\n}\n\nstatic void gfx_v8_0_set_gds_init(struct amdgpu_device *adev)\n{\n\t \n\tadev->gds.gds_size = RREG32(mmGDS_VMID0_SIZE);\n\tadev->gds.gws_size = 64;\n\tadev->gds.oa_size = 16;\n\tadev->gds.gds_compute_max_wave_id = RREG32(mmGDS_COMPUTE_MAX_WAVE_ID);\n}\n\nstatic void gfx_v8_0_set_user_cu_inactive_bitmap(struct amdgpu_device *adev,\n\t\t\t\t\t\t u32 bitmap)\n{\n\tu32 data;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tdata = bitmap << GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;\n\tdata &= GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;\n\n\tWREG32(mmGC_USER_SHADER_ARRAY_CONFIG, data);\n}\n\nstatic u32 gfx_v8_0_get_cu_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata =  RREG32(mmCC_GC_SHADER_ARRAY_CONFIG) |\n\t\tRREG32(mmGC_USER_SHADER_ARRAY_CONFIG);\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_cu_per_sh);\n\n\treturn ~REG_GET_FIELD(data, CC_GC_SHADER_ARRAY_CONFIG, INACTIVE_CUS) & mask;\n}\n\nstatic void gfx_v8_0_get_cu_info(struct amdgpu_device *adev)\n{\n\tint i, j, k, counter, active_cu_number = 0;\n\tu32 mask, bitmap, ao_bitmap, ao_cu_mask = 0;\n\tstruct amdgpu_cu_info *cu_info = &adev->gfx.cu_info;\n\tunsigned disable_masks[4 * 2];\n\tu32 ao_cu_num;\n\n\tmemset(cu_info, 0, sizeof(*cu_info));\n\n\tif (adev->flags & AMD_IS_APU)\n\t\tao_cu_num = 2;\n\telse\n\t\tao_cu_num = adev->gfx.config.max_cu_per_sh;\n\n\tamdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tao_bitmap = 0;\n\t\t\tcounter = 0;\n\t\t\tgfx_v8_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tif (i < 4 && j < 2)\n\t\t\t\tgfx_v8_0_set_user_cu_inactive_bitmap(\n\t\t\t\t\tadev, disable_masks[i * 2 + j]);\n\t\t\tbitmap = gfx_v8_0_get_cu_active_bitmap(adev);\n\t\t\tcu_info->bitmap[0][i][j] = bitmap;\n\n\t\t\tfor (k = 0; k < adev->gfx.config.max_cu_per_sh; k ++) {\n\t\t\t\tif (bitmap & mask) {\n\t\t\t\t\tif (counter < ao_cu_num)\n\t\t\t\t\t\tao_bitmap |= mask;\n\t\t\t\t\tcounter ++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\t\t\tactive_cu_number += counter;\n\t\t\tif (i < 2 && j < 2)\n\t\t\t\tao_cu_mask |= (ao_bitmap << (i * 16 + j * 8));\n\t\t\tcu_info->ao_cu_bitmap[i][j] = ao_bitmap;\n\t\t}\n\t}\n\tgfx_v8_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tcu_info->number = active_cu_number;\n\tcu_info->ao_cu_mask = ao_cu_mask;\n\tcu_info->simd_per_cu = NUM_SIMD_PER_CU;\n\tcu_info->max_waves_per_simd = 10;\n\tcu_info->max_scratch_slots_per_cu = 32;\n\tcu_info->wave_front_size = 64;\n\tcu_info->lds_size = 64;\n}\n\nconst struct amdgpu_ip_block_version gfx_v8_0_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 8,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &gfx_v8_0_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version gfx_v8_1_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 8,\n\t.minor = 1,\n\t.rev = 0,\n\t.funcs = &gfx_v8_0_ip_funcs,\n};\n\nstatic void gfx_v8_0_ring_emit_ce_meta(struct amdgpu_ring *ring)\n{\n\tuint64_t ce_payload_addr;\n\tint cnt_ce;\n\tunion {\n\t\tstruct vi_ce_ib_state regular;\n\t\tstruct vi_ce_ib_state_chained_ib chained;\n\t} ce_payload = {};\n\n\tif (ring->adev->virt.chained_ib_support) {\n\t\tce_payload_addr = amdgpu_csa_vaddr(ring->adev) +\n\t\t\toffsetof(struct vi_gfx_meta_data_chained_ib, ce_payload);\n\t\tcnt_ce = (sizeof(ce_payload.chained) >> 2) + 4 - 2;\n\t} else {\n\t\tce_payload_addr = amdgpu_csa_vaddr(ring->adev) +\n\t\t\toffsetof(struct vi_gfx_meta_data, ce_payload);\n\t\tcnt_ce = (sizeof(ce_payload.regular) >> 2) + 4 - 2;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, cnt_ce));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(2) |\n\t\t\t\tWRITE_DATA_DST_SEL(8) |\n\t\t\t\tWR_CONFIRM) |\n\t\t\t\tWRITE_DATA_CACHE_POLICY(0));\n\tamdgpu_ring_write(ring, lower_32_bits(ce_payload_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ce_payload_addr));\n\tamdgpu_ring_write_multiple(ring, (void *)&ce_payload, cnt_ce - 2);\n}\n\nstatic void gfx_v8_0_ring_emit_de_meta(struct amdgpu_ring *ring)\n{\n\tuint64_t de_payload_addr, gds_addr, csa_addr;\n\tint cnt_de;\n\tunion {\n\t\tstruct vi_de_ib_state regular;\n\t\tstruct vi_de_ib_state_chained_ib chained;\n\t} de_payload = {};\n\n\tcsa_addr = amdgpu_csa_vaddr(ring->adev);\n\tgds_addr = csa_addr + 4096;\n\tif (ring->adev->virt.chained_ib_support) {\n\t\tde_payload.chained.gds_backup_addrlo = lower_32_bits(gds_addr);\n\t\tde_payload.chained.gds_backup_addrhi = upper_32_bits(gds_addr);\n\t\tde_payload_addr = csa_addr + offsetof(struct vi_gfx_meta_data_chained_ib, de_payload);\n\t\tcnt_de = (sizeof(de_payload.chained) >> 2) + 4 - 2;\n\t} else {\n\t\tde_payload.regular.gds_backup_addrlo = lower_32_bits(gds_addr);\n\t\tde_payload.regular.gds_backup_addrhi = upper_32_bits(gds_addr);\n\t\tde_payload_addr = csa_addr + offsetof(struct vi_gfx_meta_data, de_payload);\n\t\tcnt_de = (sizeof(de_payload.regular) >> 2) + 4 - 2;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, cnt_de));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\tWRITE_DATA_DST_SEL(8) |\n\t\t\t\tWR_CONFIRM) |\n\t\t\t\tWRITE_DATA_CACHE_POLICY(0));\n\tamdgpu_ring_write(ring, lower_32_bits(de_payload_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(de_payload_addr));\n\tamdgpu_ring_write_multiple(ring, (void *)&de_payload, cnt_de - 2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}