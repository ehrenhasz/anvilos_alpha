{
  "module_name": "amdgpu_psp.c",
  "hash_id": "f4dc80c435938257d3f9330eab7d31dd52e777ffc6fb5ac4857b2eac5a388b8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <drm/drm_drv.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ucode.h\"\n#include \"amdgpu_xgmi.h\"\n#include \"soc15_common.h\"\n#include \"psp_v3_1.h\"\n#include \"psp_v10_0.h\"\n#include \"psp_v11_0.h\"\n#include \"psp_v11_0_8.h\"\n#include \"psp_v12_0.h\"\n#include \"psp_v13_0.h\"\n#include \"psp_v13_0_4.h\"\n\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_securedisplay.h\"\n#include \"amdgpu_atomfirmware.h\"\n\n#define AMD_VBIOS_FILE_MAX_SIZE_B      (1024*1024*3)\n\nstatic int psp_load_smu_fw(struct psp_context *psp);\nstatic int psp_rap_terminate(struct psp_context *psp);\nstatic int psp_securedisplay_terminate(struct psp_context *psp);\n\nstatic int psp_ring_init(struct psp_context *psp,\n\t\t\t enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct psp_ring *ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tring = &psp->km_ring;\n\n\tring->ring_type = ring_type;\n\n\t \n\tring->ring_size = 0x1000;\n\tret = amdgpu_bo_create_kernel(adev, ring->ring_size, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->firmware.rbuf,\n\t\t\t\t      &ring->ring_mem_mc_addr,\n\t\t\t\t      (void **)&ring->ring_mem);\n\tif (ret) {\n\t\tring->ring_size = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void psp_check_pmfw_centralized_cstate_management(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tpsp->pmfw_centralized_cstate_management = false;\n\t\treturn;\n\t}\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 4):\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 2):\n\tcase IP_VERSION(13, 0, 7):\n\t\tpsp->pmfw_centralized_cstate_management = true;\n\t\tbreak;\n\tdefault:\n\t\tpsp->pmfw_centralized_cstate_management = false;\n\t\tbreak;\n\t}\n}\n\nstatic int psp_init_sriov_microcode(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar ucode_prefix[30];\n\tint ret = 0;\n\n\tamdgpu_ucode_ip_version_decode(adev, MP0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 0):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 9):\n\t\tadev->virt.autoload_ucode_id = AMDGPU_UCODE_ID_CP_MEC2;\n\t\tret = psp_init_cap_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 2):\n\t\tadev->virt.autoload_ucode_id = AMDGPU_UCODE_ID_CP_MEC2;\n\t\tret = psp_init_cap_microcode(psp, ucode_prefix);\n\t\tret &= psp_init_ta_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 0):\n\t\tadev->virt.autoload_ucode_id = 0;\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 6):\n\t\tret = psp_init_cap_microcode(psp, ucode_prefix);\n\t\tret &= psp_init_ta_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 10):\n\t\tadev->virt.autoload_ucode_id = AMDGPU_UCODE_ID_CP_MES1_DATA;\n\t\tret = psp_init_cap_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int psp_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 0):\n\t\tpsp_v3_1_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = false;\n\t\tbreak;\n\tcase IP_VERSION(10, 0, 0):\n\tcase IP_VERSION(10, 0, 1):\n\t\tpsp_v10_0_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = false;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 4):\n\t\tpsp_v11_0_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = false;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 7):\n\t\tadev->psp.sup_pd_fw_up = !amdgpu_sriov_vf(adev);\n\t\tfallthrough;\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 5, 0):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\t\tpsp_v11_0_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(12, 0, 1):\n\t\tpsp_v12_0_set_psp_funcs(psp);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 2):\n\tcase IP_VERSION(13, 0, 6):\n\t\tpsp_v13_0_set_psp_funcs(psp);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 3):\n\tcase IP_VERSION(13, 0, 5):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(13, 0, 11):\n\tcase IP_VERSION(14, 0, 0):\n\t\tpsp_v13_0_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 8):\n\t\tif (adev->apu_flags & AMD_APU_IS_CYAN_SKILLFISH2) {\n\t\t\tpsp_v11_0_8_set_psp_funcs(psp);\n\t\t\tpsp->autoload_supported = false;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 7):\n\tcase IP_VERSION(13, 0, 10):\n\t\tpsp_v13_0_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = true;\n\t\tadev->psp.sup_ifwi_up = !amdgpu_sriov_vf(adev);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 4):\n\t\tpsp_v13_0_4_set_psp_funcs(psp);\n\t\tpsp->autoload_supported = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpsp->adev = adev;\n\n\tpsp_check_pmfw_centralized_cstate_management(psp);\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn psp_init_sriov_microcode(psp);\n\telse\n\t\treturn psp_init_microcode(psp);\n}\n\nvoid psp_ta_free_shared_buf(struct ta_mem_context *mem_ctx)\n{\n\tamdgpu_bo_free_kernel(&mem_ctx->shared_bo, &mem_ctx->shared_mc_addr,\n\t\t\t      &mem_ctx->shared_buf);\n\tmem_ctx->shared_bo = NULL;\n}\n\nstatic void psp_free_shared_bufs(struct psp_context *psp)\n{\n\tvoid *tmr_buf;\n\tvoid **pptr;\n\n\t \n\tpptr = amdgpu_sriov_vf(psp->adev) ? &tmr_buf : NULL;\n\tamdgpu_bo_free_kernel(&psp->tmr_bo, &psp->tmr_mc_addr, pptr);\n\tpsp->tmr_bo = NULL;\n\n\t \n\tpsp_ta_free_shared_buf(&psp->xgmi_context.context.mem_context);\n\n\t \n\tpsp_ta_free_shared_buf(&psp->ras_context.context.mem_context);\n\n\t \n\tpsp_ta_free_shared_buf(&psp->hdcp_context.context.mem_context);\n\n\t \n\tpsp_ta_free_shared_buf(&psp->dtm_context.context.mem_context);\n\n\t \n\tpsp_ta_free_shared_buf(&psp->rap_context.context.mem_context);\n\n\t \n\tpsp_ta_free_shared_buf(&psp->securedisplay_context.context.mem_context);\n\n\n}\n\nstatic void psp_memory_training_fini(struct psp_context *psp)\n{\n\tstruct psp_memory_training_context *ctx = &psp->mem_train_ctx;\n\n\tctx->init = PSP_MEM_TRAIN_NOT_SUPPORT;\n\tkfree(ctx->sys_cache);\n\tctx->sys_cache = NULL;\n}\n\nstatic int psp_memory_training_init(struct psp_context *psp)\n{\n\tint ret;\n\tstruct psp_memory_training_context *ctx = &psp->mem_train_ctx;\n\n\tif (ctx->init != PSP_MEM_TRAIN_RESERVE_SUCCESS) {\n\t\tDRM_DEBUG(\"memory training is not supported!\\n\");\n\t\treturn 0;\n\t}\n\n\tctx->sys_cache = kzalloc(ctx->train_data_size, GFP_KERNEL);\n\tif (ctx->sys_cache == NULL) {\n\t\tDRM_ERROR(\"alloc mem_train_ctx.sys_cache failed!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto Err_out;\n\t}\n\n\tDRM_DEBUG(\"train_data_size:%llx,p2c_train_data_offset:%llx,c2p_train_data_offset:%llx.\\n\",\n\t\t  ctx->train_data_size,\n\t\t  ctx->p2c_train_data_offset,\n\t\t  ctx->c2p_train_data_offset);\n\tctx->init = PSP_MEM_TRAIN_INIT_SUCCESS;\n\treturn 0;\n\nErr_out:\n\tpsp_memory_training_fini(psp);\n\treturn ret;\n}\n\n \nstatic bool psp_get_runtime_db_entry(struct amdgpu_device *adev,\n\t\t\t\t     enum psp_runtime_entry_type entry_type,\n\t\t\t\t     void *db_entry)\n{\n\tuint64_t db_header_pos, db_dir_pos;\n\tstruct psp_runtime_data_header db_header = {0};\n\tstruct psp_runtime_data_directory db_dir = {0};\n\tbool ret = false;\n\tint i;\n\n\tif (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 6))\n\t\treturn false;\n\n\tdb_header_pos = adev->gmc.mc_vram_size - PSP_RUNTIME_DB_OFFSET;\n\tdb_dir_pos = db_header_pos + sizeof(struct psp_runtime_data_header);\n\n\t \n\tamdgpu_device_vram_access(adev, db_header_pos, (uint32_t *)&db_header,\n\t\t\tsizeof(struct psp_runtime_data_header), false);\n\n\tif (db_header.cookie != PSP_RUNTIME_DB_COOKIE_ID) {\n\t\t \n\t\tdev_dbg(adev->dev, \"PSP runtime database doesn't exist\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tamdgpu_device_vram_access(adev, db_dir_pos, (uint32_t *)&db_dir,\n\t\t\tsizeof(struct psp_runtime_data_directory), false);\n\n\tif (db_dir.entry_count >= PSP_RUNTIME_DB_DIAG_ENTRY_MAX_COUNT) {\n\t\t \n\t\tdev_warn(adev->dev, \"Invalid PSP runtime database entry count\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < db_dir.entry_count && !ret; i++) {\n\t\tif (db_dir.entry_list[i].entry_type == entry_type) {\n\t\t\tswitch (entry_type) {\n\t\t\tcase PSP_RUNTIME_ENTRY_TYPE_BOOT_CONFIG:\n\t\t\t\tif (db_dir.entry_list[i].size < sizeof(struct psp_runtime_boot_cfg_entry)) {\n\t\t\t\t\t \n\t\t\t\t\tdev_warn(adev->dev, \"Invalid PSP runtime database boot cfg entry size\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tamdgpu_device_vram_access(adev, db_header_pos + db_dir.entry_list[i].offset,\n\t\t\t\t\t\t\t  (uint32_t *)db_entry, sizeof(struct psp_runtime_boot_cfg_entry), false);\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\tcase PSP_RUNTIME_ENTRY_TYPE_PPTABLE_ERR_STATUS:\n\t\t\t\tif (db_dir.entry_list[i].size < sizeof(struct psp_runtime_scpm_entry)) {\n\t\t\t\t\t \n\t\t\t\t\tdev_warn(adev->dev, \"Invalid PSP runtime database scpm entry size\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tamdgpu_device_vram_access(adev, db_header_pos + db_dir.entry_list[i].offset,\n\t\t\t\t\t\t\t  (uint32_t *)db_entry, sizeof(struct psp_runtime_scpm_entry), false);\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\tint ret;\n\tstruct psp_runtime_boot_cfg_entry boot_cfg_entry;\n\tstruct psp_memory_training_context *mem_training_ctx = &psp->mem_train_ctx;\n\tstruct psp_runtime_scpm_entry scpm_entry;\n\n\tpsp->cmd = kzalloc(sizeof(struct psp_gfx_cmd_resp), GFP_KERNEL);\n\tif (!psp->cmd) {\n\t\tDRM_ERROR(\"Failed to allocate memory to command buffer!\\n\");\n\t\tret = -ENOMEM;\n\t}\n\n\tadev->psp.xgmi_context.supports_extended_data =\n\t\t!adev->gmc.xgmi.connected_to_cpu &&\n\t\t\tadev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 2);\n\n\tmemset(&scpm_entry, 0, sizeof(scpm_entry));\n\tif ((psp_get_runtime_db_entry(adev,\n\t\t\t\tPSP_RUNTIME_ENTRY_TYPE_PPTABLE_ERR_STATUS,\n\t\t\t\t&scpm_entry)) &&\n\t    (scpm_entry.scpm_status != SCPM_DISABLE)) {\n\t\tadev->scpm_enabled = true;\n\t\tadev->scpm_status = scpm_entry.scpm_status;\n\t} else {\n\t\tadev->scpm_enabled = false;\n\t\tadev->scpm_status = SCPM_DISABLE;\n\t}\n\n\t \n\n\tmemset(&boot_cfg_entry, 0, sizeof(boot_cfg_entry));\n\tif (psp_get_runtime_db_entry(adev,\n\t\t\t\tPSP_RUNTIME_ENTRY_TYPE_BOOT_CONFIG,\n\t\t\t\t&boot_cfg_entry)) {\n\t\tpsp->boot_cfg_bitmask = boot_cfg_entry.boot_cfg_bitmask;\n\t\tif ((psp->boot_cfg_bitmask) &\n\t\t    BOOT_CFG_FEATURE_TWO_STAGE_DRAM_TRAINING) {\n\t\t\t \n\t\t\tmem_training_ctx->enable_mem_training = true;\n\t\t}\n\n\t} else {\n\t\t \n\t\tmem_training_ctx->enable_mem_training = true;\n\t}\n\n\tif (mem_training_ctx->enable_mem_training) {\n\t\tret = psp_memory_training_init(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to initialize memory training!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = psp_mem_training(psp, PSP_MEM_TRAIN_COLD_BOOT);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to process memory training!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = amdgpu_bo_create_kernel(adev, PSP_1_MEG, PSP_1_MEG,\n\t\t\t\t      amdgpu_sriov_vf(adev) ?\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM : AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &psp->fw_pri_bo,\n\t\t\t\t      &psp->fw_pri_mc_addr,\n\t\t\t\t      &psp->fw_pri_buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_bo_create_kernel(adev, PSP_FENCE_BUFFER_SIZE, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &psp->fence_buf_bo,\n\t\t\t\t      &psp->fence_buf_mc_addr,\n\t\t\t\t      &psp->fence_buf);\n\tif (ret)\n\t\tgoto failed1;\n\n\tret = amdgpu_bo_create_kernel(adev, PSP_CMD_BUFFER_SIZE, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &psp->cmd_buf_bo, &psp->cmd_buf_mc_addr,\n\t\t\t\t      (void **)&psp->cmd_buf_mem);\n\tif (ret)\n\t\tgoto failed2;\n\n\treturn 0;\n\nfailed2:\n\tamdgpu_bo_free_kernel(&psp->fence_buf_bo,\n\t\t\t      &psp->fence_buf_mc_addr, &psp->fence_buf);\nfailed1:\n\tamdgpu_bo_free_kernel(&psp->fw_pri_bo,\n\t\t\t      &psp->fw_pri_mc_addr, &psp->fw_pri_buf);\n\treturn ret;\n}\n\nstatic int psp_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\tstruct psp_gfx_cmd_resp *cmd = psp->cmd;\n\n\tpsp_memory_training_fini(psp);\n\n\tamdgpu_ucode_release(&psp->sos_fw);\n\tamdgpu_ucode_release(&psp->asd_fw);\n\tamdgpu_ucode_release(&psp->ta_fw);\n\tamdgpu_ucode_release(&psp->cap_fw);\n\tamdgpu_ucode_release(&psp->toc_fw);\n\n\tkfree(cmd);\n\tcmd = NULL;\n\n\tpsp_free_shared_bufs(psp);\n\n\tif (psp->km_ring.ring_mem)\n\t\tamdgpu_bo_free_kernel(&adev->firmware.rbuf,\n\t\t\t\t      &psp->km_ring.ring_mem_mc_addr,\n\t\t\t\t      (void **)&psp->km_ring.ring_mem);\n\n\tamdgpu_bo_free_kernel(&psp->fw_pri_bo,\n\t\t\t      &psp->fw_pri_mc_addr, &psp->fw_pri_buf);\n\tamdgpu_bo_free_kernel(&psp->fence_buf_bo,\n\t\t\t      &psp->fence_buf_mc_addr, &psp->fence_buf);\n\tamdgpu_bo_free_kernel(&psp->cmd_buf_bo, &psp->cmd_buf_mc_addr,\n\t\t\t      (void **)&psp->cmd_buf_mem);\n\n\treturn 0;\n}\n\nint psp_wait_for(struct psp_context *psp, uint32_t reg_index,\n\t\t uint32_t reg_val, uint32_t mask, bool check_changed)\n{\n\tuint32_t val;\n\tint i;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (psp->adev->no_hw_access)\n\t\treturn 0;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tval = RREG32(reg_index);\n\t\tif (check_changed) {\n\t\t\tif (val != reg_val)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif ((val & mask) == reg_val)\n\t\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn -ETIME;\n}\n\nint psp_wait_for_spirom_update(struct psp_context *psp, uint32_t reg_index,\n\t\t\t       uint32_t reg_val, uint32_t mask, uint32_t msec_timeout)\n{\n\tuint32_t val;\n\tint i;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (psp->adev->no_hw_access)\n\t\treturn 0;\n\n\tfor (i = 0; i < msec_timeout; i++) {\n\t\tval = RREG32(reg_index);\n\t\tif ((val & mask) == reg_val)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\n\treturn -ETIME;\n}\n\nstatic const char *psp_gfx_cmd_name(enum psp_gfx_cmd_id cmd_id)\n{\n\tswitch (cmd_id) {\n\tcase GFX_CMD_ID_LOAD_TA:\n\t\treturn \"LOAD_TA\";\n\tcase GFX_CMD_ID_UNLOAD_TA:\n\t\treturn \"UNLOAD_TA\";\n\tcase GFX_CMD_ID_INVOKE_CMD:\n\t\treturn \"INVOKE_CMD\";\n\tcase GFX_CMD_ID_LOAD_ASD:\n\t\treturn \"LOAD_ASD\";\n\tcase GFX_CMD_ID_SETUP_TMR:\n\t\treturn \"SETUP_TMR\";\n\tcase GFX_CMD_ID_LOAD_IP_FW:\n\t\treturn \"LOAD_IP_FW\";\n\tcase GFX_CMD_ID_DESTROY_TMR:\n\t\treturn \"DESTROY_TMR\";\n\tcase GFX_CMD_ID_SAVE_RESTORE:\n\t\treturn \"SAVE_RESTORE_IP_FW\";\n\tcase GFX_CMD_ID_SETUP_VMR:\n\t\treturn \"SETUP_VMR\";\n\tcase GFX_CMD_ID_DESTROY_VMR:\n\t\treturn \"DESTROY_VMR\";\n\tcase GFX_CMD_ID_PROG_REG:\n\t\treturn \"PROG_REG\";\n\tcase GFX_CMD_ID_GET_FW_ATTESTATION:\n\t\treturn \"GET_FW_ATTESTATION\";\n\tcase GFX_CMD_ID_LOAD_TOC:\n\t\treturn \"ID_LOAD_TOC\";\n\tcase GFX_CMD_ID_AUTOLOAD_RLC:\n\t\treturn \"AUTOLOAD_RLC\";\n\tcase GFX_CMD_ID_BOOT_CFG:\n\t\treturn \"BOOT_CFG\";\n\tdefault:\n\t\treturn \"UNKNOWN CMD\";\n\t}\n}\n\nstatic int\npsp_cmd_submit_buf(struct psp_context *psp,\n\t\t   struct amdgpu_firmware_info *ucode,\n\t\t   struct psp_gfx_cmd_resp *cmd, uint64_t fence_mc_addr)\n{\n\tint ret;\n\tint index;\n\tint timeout = 20000;\n\tbool ras_intr = false;\n\tbool skip_unsupport = false;\n\n\tif (psp->adev->no_hw_access)\n\t\treturn 0;\n\n\tmemset(psp->cmd_buf_mem, 0, PSP_CMD_BUFFER_SIZE);\n\n\tmemcpy(psp->cmd_buf_mem, cmd, sizeof(struct psp_gfx_cmd_resp));\n\n\tindex = atomic_inc_return(&psp->fence_value);\n\tret = psp_ring_cmd_submit(psp, psp->cmd_buf_mc_addr, fence_mc_addr, index);\n\tif (ret) {\n\t\tatomic_dec(&psp->fence_value);\n\t\tgoto exit;\n\t}\n\n\tamdgpu_device_invalidate_hdp(psp->adev, NULL);\n\twhile (*((unsigned int *)psp->fence_buf) != index) {\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\t \n\t\tras_intr = amdgpu_ras_intr_triggered();\n\t\tif (ras_intr)\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t\tamdgpu_device_invalidate_hdp(psp->adev, NULL);\n\t}\n\n\t \n\tskip_unsupport = (psp->cmd_buf_mem->resp.status == TEE_ERROR_NOT_SUPPORTED ||\n\t\tpsp->cmd_buf_mem->resp.status == PSP_ERR_UNKNOWN_COMMAND) && amdgpu_sriov_vf(psp->adev);\n\n\tmemcpy(&cmd->resp, &psp->cmd_buf_mem->resp, sizeof(struct psp_gfx_resp));\n\n\t \n\tif (!skip_unsupport && (psp->cmd_buf_mem->resp.status || !timeout) && !ras_intr) {\n\t\tif (ucode)\n\t\t\tDRM_WARN(\"failed to load ucode %s(0x%X) \",\n\t\t\t\t  amdgpu_ucode_name(ucode->ucode_id), ucode->ucode_id);\n\t\tDRM_WARN(\"psp gfx command %s(0x%X) failed and response status is (0x%X)\\n\",\n\t\t\t psp_gfx_cmd_name(psp->cmd_buf_mem->cmd_id), psp->cmd_buf_mem->cmd_id,\n\t\t\t psp->cmd_buf_mem->resp.status);\n\t\t \n\t\tif ((ucode && amdgpu_sriov_vf(psp->adev)) || !timeout) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (ucode) {\n\t\tucode->tmr_mc_addr_lo = psp->cmd_buf_mem->resp.fw_addr_lo;\n\t\tucode->tmr_mc_addr_hi = psp->cmd_buf_mem->resp.fw_addr_hi;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic struct psp_gfx_cmd_resp *acquire_psp_cmd_buf(struct psp_context *psp)\n{\n\tstruct psp_gfx_cmd_resp *cmd = psp->cmd;\n\n\tmutex_lock(&psp->mutex);\n\n\tmemset(cmd, 0, sizeof(struct psp_gfx_cmd_resp));\n\n\treturn cmd;\n}\n\nstatic void release_psp_cmd_buf(struct psp_context *psp)\n{\n\tmutex_unlock(&psp->mutex);\n}\n\nstatic void psp_prep_tmr_cmd_buf(struct psp_context *psp,\n\t\t\t\t struct psp_gfx_cmd_resp *cmd,\n\t\t\t\t uint64_t tmr_mc, struct amdgpu_bo *tmr_bo)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t size = 0;\n\tuint64_t tmr_pa = 0;\n\n\tif (tmr_bo) {\n\t\tsize = amdgpu_bo_size(tmr_bo);\n\t\ttmr_pa = amdgpu_gmc_vram_pa(adev, tmr_bo);\n\t}\n\n\tif (amdgpu_sriov_vf(psp->adev))\n\t\tcmd->cmd_id = GFX_CMD_ID_SETUP_VMR;\n\telse\n\t\tcmd->cmd_id = GFX_CMD_ID_SETUP_TMR;\n\tcmd->cmd.cmd_setup_tmr.buf_phy_addr_lo = lower_32_bits(tmr_mc);\n\tcmd->cmd.cmd_setup_tmr.buf_phy_addr_hi = upper_32_bits(tmr_mc);\n\tcmd->cmd.cmd_setup_tmr.buf_size = size;\n\tcmd->cmd.cmd_setup_tmr.bitfield.virt_phy_addr = 1;\n\tcmd->cmd.cmd_setup_tmr.system_phy_addr_lo = lower_32_bits(tmr_pa);\n\tcmd->cmd.cmd_setup_tmr.system_phy_addr_hi = upper_32_bits(tmr_pa);\n}\n\nstatic void psp_prep_load_toc_cmd_buf(struct psp_gfx_cmd_resp *cmd,\n\t\t\t\t      uint64_t pri_buf_mc, uint32_t size)\n{\n\tcmd->cmd_id = GFX_CMD_ID_LOAD_TOC;\n\tcmd->cmd.cmd_load_toc.toc_phy_addr_lo = lower_32_bits(pri_buf_mc);\n\tcmd->cmd.cmd_load_toc.toc_phy_addr_hi = upper_32_bits(pri_buf_mc);\n\tcmd->cmd.cmd_load_toc.toc_size = size;\n}\n\n \nstatic int psp_load_toc(struct psp_context *psp,\n\t\t\tuint32_t *tmr_size)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd = acquire_psp_cmd_buf(psp);\n\n\t \n\tpsp_copy_fw(psp, psp->toc.start_addr, psp->toc.size_bytes);\n\n\tpsp_prep_load_toc_cmd_buf(cmd, psp->fw_pri_mc_addr, psp->toc.size_bytes);\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\tif (!ret)\n\t\t*tmr_size = psp->cmd_buf_mem->resp.tmr_size;\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic bool psp_boottime_tmr(struct psp_context *psp)\n{\n\tswitch (psp->adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 6):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int psp_tmr_init(struct psp_context *psp)\n{\n\tint ret = 0;\n\tint tmr_size;\n\tvoid *tmr_buf;\n\tvoid **pptr;\n\n\t \n\ttmr_size = PSP_TMR_SIZE(psp->adev);\n\n\t \n\tif (!amdgpu_sriov_vf(psp->adev) &&\n\t    psp->toc.start_addr &&\n\t    psp->toc.size_bytes &&\n\t    psp->fw_pri_buf) {\n\t\tret = psp_load_toc(psp, &tmr_size);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to load toc\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!psp->tmr_bo) {\n\t\tpptr = amdgpu_sriov_vf(psp->adev) ? &tmr_buf : NULL;\n\t\tret = amdgpu_bo_create_kernel(psp->adev, tmr_size,\n\t\t\t\t\t      PSP_TMR_ALIGNMENT,\n\t\t\t\t\t      AMDGPU_HAS_VRAM(psp->adev) ?\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM :\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t      &psp->tmr_bo, &psp->tmr_mc_addr,\n\t\t\t\t\t      pptr);\n\t}\n\n\treturn ret;\n}\n\nstatic bool psp_skip_tmr(struct psp_context *psp)\n{\n\tswitch (psp->adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(13, 0, 2):\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 10):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int psp_tmr_load(struct psp_context *psp)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev) && psp_skip_tmr(psp))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_prep_tmr_cmd_buf(psp, cmd, psp->tmr_mc_addr, psp->tmr_bo);\n\tif (psp->tmr_bo)\n\t\tDRM_INFO(\"reserve 0x%lx from 0x%llx for PSP TMR\\n\",\n\t\t\t amdgpu_bo_size(psp->tmr_bo), psp->tmr_mc_addr);\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic void psp_prep_tmr_unload_cmd_buf(struct psp_context *psp,\n\t\t\t\t\tstruct psp_gfx_cmd_resp *cmd)\n{\n\tif (amdgpu_sriov_vf(psp->adev))\n\t\tcmd->cmd_id = GFX_CMD_ID_DESTROY_VMR;\n\telse\n\t\tcmd->cmd_id = GFX_CMD_ID_DESTROY_TMR;\n}\n\nstatic int psp_tmr_unload(struct psp_context *psp)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev) && psp_skip_tmr(psp))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_prep_tmr_unload_cmd_buf(psp, cmd);\n\tdev_dbg(psp->adev->dev, \"free PSP TMR buffer\\n\");\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_tmr_terminate(struct psp_context *psp)\n{\n\treturn psp_tmr_unload(psp);\n}\n\nint psp_get_fw_attestation_records_addr(struct psp_context *psp,\n\t\t\t\t\tuint64_t *output_ptr)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\tif (!output_ptr)\n\t\treturn -EINVAL;\n\n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tcmd->cmd_id = GFX_CMD_ID_GET_FW_ATTESTATION;\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\tif (!ret) {\n\t\t*output_ptr = ((uint64_t)cmd->resp.uresp.fwar_db_info.fwar_db_addr_lo) +\n\t\t\t      ((uint64_t)cmd->resp.uresp.fwar_db_info.fwar_db_addr_hi << 32);\n\t}\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_boot_config_get(struct amdgpu_device *adev, uint32_t *boot_cfg)\n{\n\tstruct psp_context *psp = &adev->psp;\n\tstruct psp_gfx_cmd_resp *cmd;\n\tint ret;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tcmd->cmd_id = GFX_CMD_ID_BOOT_CFG;\n\tcmd->cmd.boot_cfg.sub_cmd = BOOTCFG_CMD_GET;\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\tif (!ret) {\n\t\t*boot_cfg =\n\t\t\t(cmd->resp.uresp.boot_cfg.boot_cfg & BOOT_CONFIG_GECC) ? 1 : 0;\n\t}\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_boot_config_set(struct amdgpu_device *adev, uint32_t boot_cfg)\n{\n\tint ret;\n\tstruct psp_context *psp = &adev->psp;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tcmd->cmd_id = GFX_CMD_ID_BOOT_CFG;\n\tcmd->cmd.boot_cfg.sub_cmd = BOOTCFG_CMD_SET;\n\tcmd->cmd.boot_cfg.boot_config = boot_cfg;\n\tcmd->cmd.boot_cfg.boot_config_valid = boot_cfg;\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_rl_load(struct amdgpu_device *adev)\n{\n\tint ret;\n\tstruct psp_context *psp = &adev->psp;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\tif (!is_psp_fw_valid(psp->rl))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\tmemcpy(psp->fw_pri_buf, psp->rl.start_addr, psp->rl.size_bytes);\n\n\tcmd->cmd_id = GFX_CMD_ID_LOAD_IP_FW;\n\tcmd->cmd.cmd_load_ip_fw.fw_phy_addr_lo = lower_32_bits(psp->fw_pri_mc_addr);\n\tcmd->cmd.cmd_load_ip_fw.fw_phy_addr_hi = upper_32_bits(psp->fw_pri_mc_addr);\n\tcmd->cmd.cmd_load_ip_fw.fw_size = psp->rl.size_bytes;\n\tcmd->cmd.cmd_load_ip_fw.fw_type = GFX_FW_TYPE_REG_LIST;\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nint psp_spatial_partition(struct psp_context *psp, int mode)\n{\n\tstruct psp_gfx_cmd_resp *cmd;\n\tint ret;\n\n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tcmd->cmd_id = GFX_CMD_ID_SRIOV_SPATIAL_PART;\n\tcmd->cmd.cmd_spatial_part.mode = mode;\n\n\tdev_info(psp->adev->dev, \"Requesting %d partitions through PSP\", mode);\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_asd_initialize(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev) || !psp->asd_context.bin_desc.size_bytes)\n\t\treturn 0;\n\n\tpsp->asd_context.mem_context.shared_mc_addr  = 0;\n\tpsp->asd_context.mem_context.shared_mem_size = PSP_ASD_SHARED_MEM_SIZE;\n\tpsp->asd_context.ta_load_type                = GFX_CMD_ID_LOAD_ASD;\n\n\tret = psp_ta_load(psp, &psp->asd_context);\n\tif (!ret)\n\t\tpsp->asd_context.initialized = true;\n\n\treturn ret;\n}\n\nstatic void psp_prep_ta_unload_cmd_buf(struct psp_gfx_cmd_resp *cmd,\n\t\t\t\t       uint32_t session_id)\n{\n\tcmd->cmd_id = GFX_CMD_ID_UNLOAD_TA;\n\tcmd->cmd.cmd_unload_ta.session_id = session_id;\n}\n\nint psp_ta_unload(struct psp_context *psp, struct ta_context *context)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_prep_ta_unload_cmd_buf(cmd, context->session_id);\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\n\tcontext->resp_status = cmd->resp.status;\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_asd_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->asd_context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->asd_context);\n\tif (!ret)\n\t\tpsp->asd_context.initialized = false;\n\n\treturn ret;\n}\n\nstatic void psp_prep_reg_prog_cmd_buf(struct psp_gfx_cmd_resp *cmd,\n\t\tuint32_t id, uint32_t value)\n{\n\tcmd->cmd_id = GFX_CMD_ID_PROG_REG;\n\tcmd->cmd.cmd_setup_reg_prog.reg_value = value;\n\tcmd->cmd.cmd_setup_reg_prog.reg_id = id;\n}\n\nint psp_reg_program(struct psp_context *psp, enum psp_reg_prog_id reg,\n\t\tuint32_t value)\n{\n\tstruct psp_gfx_cmd_resp *cmd;\n\tint ret = 0;\n\n\tif (reg >= PSP_REG_LAST)\n\t\treturn -EINVAL;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_prep_reg_prog_cmd_buf(cmd, reg, value);\n\tret = psp_cmd_submit_buf(psp, NULL, cmd, psp->fence_buf_mc_addr);\n\tif (ret)\n\t\tDRM_ERROR(\"PSP failed to program reg id %d\", reg);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic void psp_prep_ta_load_cmd_buf(struct psp_gfx_cmd_resp *cmd,\n\t\t\t\t     uint64_t ta_bin_mc,\n\t\t\t\t     struct ta_context *context)\n{\n\tcmd->cmd_id\t\t\t\t= context->ta_load_type;\n\tcmd->cmd.cmd_load_ta.app_phy_addr_lo\t= lower_32_bits(ta_bin_mc);\n\tcmd->cmd.cmd_load_ta.app_phy_addr_hi\t= upper_32_bits(ta_bin_mc);\n\tcmd->cmd.cmd_load_ta.app_len\t\t= context->bin_desc.size_bytes;\n\n\tcmd->cmd.cmd_load_ta.cmd_buf_phy_addr_lo =\n\t\tlower_32_bits(context->mem_context.shared_mc_addr);\n\tcmd->cmd.cmd_load_ta.cmd_buf_phy_addr_hi =\n\t\tupper_32_bits(context->mem_context.shared_mc_addr);\n\tcmd->cmd.cmd_load_ta.cmd_buf_len = context->mem_context.shared_mem_size;\n}\n\nint psp_ta_init_shared_buf(struct psp_context *psp,\n\t\t\t\t  struct ta_mem_context *mem_ctx)\n{\n\t \n\treturn amdgpu_bo_create_kernel(psp->adev, mem_ctx->shared_mem_size,\n\t\t\t\t      PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &mem_ctx->shared_bo,\n\t\t\t\t      &mem_ctx->shared_mc_addr,\n\t\t\t\t      &mem_ctx->shared_buf);\n}\n\nstatic void psp_prep_ta_invoke_cmd_buf(struct psp_gfx_cmd_resp *cmd,\n\t\t\t\t       uint32_t ta_cmd_id,\n\t\t\t\t       uint32_t session_id)\n{\n\tcmd->cmd_id\t\t\t\t= GFX_CMD_ID_INVOKE_CMD;\n\tcmd->cmd.cmd_invoke_cmd.session_id\t= session_id;\n\tcmd->cmd.cmd_invoke_cmd.ta_cmd_id\t= ta_cmd_id;\n}\n\nint psp_ta_invoke(struct psp_context *psp,\n\t\t  uint32_t ta_cmd_id,\n\t\t  struct ta_context *context)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_prep_ta_invoke_cmd_buf(cmd, ta_cmd_id, context->session_id);\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\tcontext->resp_status = cmd->resp.status;\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nint psp_ta_load(struct psp_context *psp, struct ta_context *context)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd;\n\n\tcmd = acquire_psp_cmd_buf(psp);\n\n\tpsp_copy_fw(psp, context->bin_desc.start_addr,\n\t\t    context->bin_desc.size_bytes);\n\n\tpsp_prep_ta_load_cmd_buf(cmd, psp->fw_pri_mc_addr, context);\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\tcontext->resp_status = cmd->resp.status;\n\n\tif (!ret)\n\t\tcontext->session_id = cmd->resp.session_id;\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nint psp_xgmi_invoke(struct psp_context *psp, uint32_t ta_cmd_id)\n{\n\treturn psp_ta_invoke(psp, ta_cmd_id, &psp->xgmi_context.context);\n}\n\nint psp_xgmi_terminate(struct psp_context *psp)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 4) ||\n\t    (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 2) &&\n\t     adev->gmc.xgmi.connected_to_cpu))\n\t\treturn 0;\n\n\tif (!psp->xgmi_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->xgmi_context.context);\n\n\tpsp->xgmi_context.context.initialized = false;\n\n\treturn ret;\n}\n\nint psp_xgmi_initialize(struct psp_context *psp, bool set_extended_data, bool load_ta)\n{\n\tstruct ta_xgmi_shared_memory *xgmi_cmd;\n\tint ret;\n\n\tif (!psp->ta_fw ||\n\t    !psp->xgmi_context.context.bin_desc.size_bytes ||\n\t    !psp->xgmi_context.context.bin_desc.start_addr)\n\t\treturn -ENOENT;\n\n\tif (!load_ta)\n\t\tgoto invoke;\n\n\tpsp->xgmi_context.context.mem_context.shared_mem_size = PSP_XGMI_SHARED_MEM_SIZE;\n\tpsp->xgmi_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->xgmi_context.context.mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &psp->xgmi_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = psp_ta_load(psp, &psp->xgmi_context.context);\n\tif (!ret)\n\t\tpsp->xgmi_context.context.initialized = true;\n\telse\n\t\treturn ret;\n\ninvoke:\n\t \n\txgmi_cmd = (struct ta_xgmi_shared_memory *)(psp->xgmi_context.context.mem_context.shared_buf);\n\tmemset(xgmi_cmd, 0, sizeof(struct ta_xgmi_shared_memory));\n\txgmi_cmd->flag_extend_link_record = set_extended_data;\n\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__INITIALIZE;\n\n\tret = psp_xgmi_invoke(psp, xgmi_cmd->cmd_id);\n\n\treturn ret;\n}\n\nint psp_xgmi_get_hive_id(struct psp_context *psp, uint64_t *hive_id)\n{\n\tstruct ta_xgmi_shared_memory *xgmi_cmd;\n\tint ret;\n\n\txgmi_cmd = (struct ta_xgmi_shared_memory *)psp->xgmi_context.context.mem_context.shared_buf;\n\tmemset(xgmi_cmd, 0, sizeof(struct ta_xgmi_shared_memory));\n\n\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__GET_HIVE_ID;\n\n\t \n\tret = psp_xgmi_invoke(psp, xgmi_cmd->cmd_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*hive_id = xgmi_cmd->xgmi_out_message.get_hive_id.hive_id;\n\n\treturn 0;\n}\n\nint psp_xgmi_get_node_id(struct psp_context *psp, uint64_t *node_id)\n{\n\tstruct ta_xgmi_shared_memory *xgmi_cmd;\n\tint ret;\n\n\txgmi_cmd = (struct ta_xgmi_shared_memory *)psp->xgmi_context.context.mem_context.shared_buf;\n\tmemset(xgmi_cmd, 0, sizeof(struct ta_xgmi_shared_memory));\n\n\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__GET_NODE_ID;\n\n\t \n\tret = psp_xgmi_invoke(psp, xgmi_cmd->cmd_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*node_id = xgmi_cmd->xgmi_out_message.get_node_id.node_id;\n\n\treturn 0;\n}\n\nstatic bool psp_xgmi_peer_link_info_supported(struct psp_context *psp)\n{\n\treturn (psp->adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 2) &&\n\t\tpsp->xgmi_context.context.bin_desc.fw_version >= 0x2000000b) ||\n\t\tpsp->adev->ip_versions[MP0_HWIP][0] >= IP_VERSION(13, 0, 6);\n}\n\n \nstatic void psp_xgmi_reflect_topology_info(struct psp_context *psp,\n\t\t\t\t\tstruct psp_xgmi_node_info node_info)\n{\n\tstruct amdgpu_device *mirror_adev;\n\tstruct amdgpu_hive_info *hive;\n\tuint64_t src_node_id = psp->adev->gmc.xgmi.node_id;\n\tuint64_t dst_node_id = node_info.node_id;\n\tuint8_t dst_num_hops = node_info.num_hops;\n\tuint8_t dst_num_links = node_info.num_links;\n\n\thive = amdgpu_get_xgmi_hive(psp->adev);\n\tlist_for_each_entry(mirror_adev, &hive->device_list, gmc.xgmi.head) {\n\t\tstruct psp_xgmi_topology_info *mirror_top_info;\n\t\tint j;\n\n\t\tif (mirror_adev->gmc.xgmi.node_id != dst_node_id)\n\t\t\tcontinue;\n\n\t\tmirror_top_info = &mirror_adev->psp.xgmi_context.top_info;\n\t\tfor (j = 0; j < mirror_top_info->num_nodes; j++) {\n\t\t\tif (mirror_top_info->nodes[j].node_id != src_node_id)\n\t\t\t\tcontinue;\n\n\t\t\tmirror_top_info->nodes[j].num_hops = dst_num_hops;\n\t\t\t \n\t\t\tif (dst_num_links)\n\t\t\t\tmirror_top_info->nodes[j].num_links = dst_num_links;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tamdgpu_put_xgmi_hive(hive);\n}\n\nint psp_xgmi_get_topology_info(struct psp_context *psp,\n\t\t\t       int number_devices,\n\t\t\t       struct psp_xgmi_topology_info *topology,\n\t\t\t       bool get_extended_data)\n{\n\tstruct ta_xgmi_shared_memory *xgmi_cmd;\n\tstruct ta_xgmi_cmd_get_topology_info_input *topology_info_input;\n\tstruct ta_xgmi_cmd_get_topology_info_output *topology_info_output;\n\tint i;\n\tint ret;\n\n\tif (!topology || topology->num_nodes > TA_XGMI__MAX_CONNECTED_NODES)\n\t\treturn -EINVAL;\n\n\txgmi_cmd = (struct ta_xgmi_shared_memory *)psp->xgmi_context.context.mem_context.shared_buf;\n\tmemset(xgmi_cmd, 0, sizeof(struct ta_xgmi_shared_memory));\n\txgmi_cmd->flag_extend_link_record = get_extended_data;\n\n\t \n\ttopology_info_input = &xgmi_cmd->xgmi_in_message.get_topology_info;\n\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__GET_GET_TOPOLOGY_INFO;\n\ttopology_info_input->num_nodes = number_devices;\n\n\tfor (i = 0; i < topology_info_input->num_nodes; i++) {\n\t\ttopology_info_input->nodes[i].node_id = topology->nodes[i].node_id;\n\t\ttopology_info_input->nodes[i].num_hops = topology->nodes[i].num_hops;\n\t\ttopology_info_input->nodes[i].is_sharing_enabled = topology->nodes[i].is_sharing_enabled;\n\t\ttopology_info_input->nodes[i].sdma_engine = topology->nodes[i].sdma_engine;\n\t}\n\n\t \n\tret = psp_xgmi_invoke(psp, TA_COMMAND_XGMI__GET_GET_TOPOLOGY_INFO);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttopology_info_output = &xgmi_cmd->xgmi_out_message.get_topology_info;\n\ttopology->num_nodes = xgmi_cmd->xgmi_out_message.get_topology_info.num_nodes;\n\tfor (i = 0; i < topology->num_nodes; i++) {\n\t\t \n\t\tif (topology_info_output->nodes[i].num_hops)\n\t\t\ttopology->nodes[i].num_hops = topology_info_output->nodes[i].num_hops;\n\n\t\t \n\t\tif (!get_extended_data) {\n\t\t\ttopology->nodes[i].node_id = topology_info_output->nodes[i].node_id;\n\t\t\ttopology->nodes[i].is_sharing_enabled =\n\t\t\t\t\ttopology_info_output->nodes[i].is_sharing_enabled;\n\t\t\ttopology->nodes[i].sdma_engine =\n\t\t\t\t\ttopology_info_output->nodes[i].sdma_engine;\n\t\t}\n\n\t}\n\n\t \n\tif (psp_xgmi_peer_link_info_supported(psp)) {\n\t\tstruct ta_xgmi_cmd_get_peer_link_info_output *link_info_output;\n\t\tbool requires_reflection =\n\t\t\t(psp->xgmi_context.supports_extended_data && get_extended_data) ||\n\t\t\t\tpsp->adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 6);\n\n\t\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__GET_PEER_LINKS;\n\n\t\tret = psp_xgmi_invoke(psp, TA_COMMAND_XGMI__GET_PEER_LINKS);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlink_info_output = &xgmi_cmd->xgmi_out_message.get_link_info;\n\t\tfor (i = 0; i < topology->num_nodes; i++) {\n\t\t\t \n\t\t\ttopology->nodes[i].num_links = get_extended_data ?\n\t\t\t\t\ttopology->nodes[i].num_links +\n\t\t\t\t\t\t\tlink_info_output->nodes[i].num_links :\n\t\t\t\t\t((requires_reflection && topology->nodes[i].num_links) ? topology->nodes[i].num_links :\n\t\t\t\t\t link_info_output->nodes[i].num_links);\n\n\t\t\t \n\t\t\tif (requires_reflection && topology->nodes[i].num_hops)\n\t\t\t\tpsp_xgmi_reflect_topology_info(psp, topology->nodes[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint psp_xgmi_set_topology_info(struct psp_context *psp,\n\t\t\t       int number_devices,\n\t\t\t       struct psp_xgmi_topology_info *topology)\n{\n\tstruct ta_xgmi_shared_memory *xgmi_cmd;\n\tstruct ta_xgmi_cmd_get_topology_info_input *topology_info_input;\n\tint i;\n\n\tif (!topology || topology->num_nodes > TA_XGMI__MAX_CONNECTED_NODES)\n\t\treturn -EINVAL;\n\n\txgmi_cmd = (struct ta_xgmi_shared_memory *)psp->xgmi_context.context.mem_context.shared_buf;\n\tmemset(xgmi_cmd, 0, sizeof(struct ta_xgmi_shared_memory));\n\n\ttopology_info_input = &xgmi_cmd->xgmi_in_message.get_topology_info;\n\txgmi_cmd->cmd_id = TA_COMMAND_XGMI__SET_TOPOLOGY_INFO;\n\ttopology_info_input->num_nodes = number_devices;\n\n\tfor (i = 0; i < topology_info_input->num_nodes; i++) {\n\t\ttopology_info_input->nodes[i].node_id = topology->nodes[i].node_id;\n\t\ttopology_info_input->nodes[i].num_hops = topology->nodes[i].num_hops;\n\t\ttopology_info_input->nodes[i].is_sharing_enabled = 1;\n\t\ttopology_info_input->nodes[i].sdma_engine = topology->nodes[i].sdma_engine;\n\t}\n\n\t \n\treturn psp_xgmi_invoke(psp, TA_COMMAND_XGMI__SET_TOPOLOGY_INFO);\n}\n\n \nstatic void psp_ras_ta_check_status(struct psp_context *psp)\n{\n\tstruct ta_ras_shared_memory *ras_cmd =\n\t\t(struct ta_ras_shared_memory *)psp->ras_context.context.mem_context.shared_buf;\n\n\tswitch (ras_cmd->ras_status) {\n\tcase TA_RAS_STATUS__ERROR_UNSUPPORTED_IP:\n\t\tdev_warn(psp->adev->dev,\n\t\t\t\t\"RAS WARNING: cmd failed due to unsupported ip\\n\");\n\t\tbreak;\n\tcase TA_RAS_STATUS__ERROR_UNSUPPORTED_ERROR_INJ:\n\t\tdev_warn(psp->adev->dev,\n\t\t\t\t\"RAS WARNING: cmd failed due to unsupported error injection\\n\");\n\t\tbreak;\n\tcase TA_RAS_STATUS__SUCCESS:\n\t\tbreak;\n\tcase TA_RAS_STATUS__TEE_ERROR_ACCESS_DENIED:\n\t\tif (ras_cmd->cmd_id == TA_RAS_COMMAND__TRIGGER_ERROR)\n\t\t\tdev_warn(psp->adev->dev,\n\t\t\t\t\t\"RAS WARNING: Inject error to critical region is not allowed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(psp->adev->dev,\n\t\t\t\t\"RAS WARNING: ras status = 0x%X\\n\", ras_cmd->ras_status);\n\t\tbreak;\n\t}\n}\n\nint psp_ras_invoke(struct psp_context *psp, uint32_t ta_cmd_id)\n{\n\tstruct ta_ras_shared_memory *ras_cmd;\n\tint ret;\n\n\tras_cmd = (struct ta_ras_shared_memory *)psp->ras_context.context.mem_context.shared_buf;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tret = psp_ta_invoke(psp, ta_cmd_id, &psp->ras_context.context);\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn ret;\n\n\tif (ras_cmd->if_version > RAS_TA_HOST_IF_VER) {\n\t\tDRM_WARN(\"RAS: Unsupported Interface\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\tif (ras_cmd->ras_out_message.flags.err_inject_switch_disable_flag) {\n\t\t\tdev_warn(psp->adev->dev, \"ECC switch disabled\\n\");\n\n\t\t\tras_cmd->ras_status = TA_RAS_STATUS__ERROR_RAS_NOT_AVAILABLE;\n\t\t} else if (ras_cmd->ras_out_message.flags.reg_access_failure_flag)\n\t\t\tdev_warn(psp->adev->dev,\n\t\t\t\t \"RAS internal register access blocked\\n\");\n\n\t\tpsp_ras_ta_check_status(psp);\n\t}\n\n\treturn ret;\n}\n\nint psp_ras_enable_features(struct psp_context *psp,\n\t\tunion ta_ras_cmd_input *info, bool enable)\n{\n\tstruct ta_ras_shared_memory *ras_cmd;\n\tint ret;\n\n\tif (!psp->ras_context.context.initialized)\n\t\treturn -EINVAL;\n\n\tras_cmd = (struct ta_ras_shared_memory *)psp->ras_context.context.mem_context.shared_buf;\n\tmemset(ras_cmd, 0, sizeof(struct ta_ras_shared_memory));\n\n\tif (enable)\n\t\tras_cmd->cmd_id = TA_RAS_COMMAND__ENABLE_FEATURES;\n\telse\n\t\tras_cmd->cmd_id = TA_RAS_COMMAND__DISABLE_FEATURES;\n\n\tras_cmd->ras_in_message = *info;\n\n\tret = psp_ras_invoke(psp, ras_cmd->cmd_id);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint psp_ras_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->ras_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->ras_context.context);\n\n\tpsp->ras_context.context.initialized = false;\n\n\treturn ret;\n}\n\nint psp_ras_initialize(struct psp_context *psp)\n{\n\tint ret;\n\tuint32_t boot_cfg = 0xFF;\n\tstruct amdgpu_device *adev = psp->adev;\n\tstruct ta_ras_shared_memory *ras_cmd;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tif (!adev->psp.ras_context.context.bin_desc.size_bytes ||\n\t    !adev->psp.ras_context.context.bin_desc.start_addr) {\n\t\tdev_info(adev->dev, \"RAS: optional ras ta ucode is not available\\n\");\n\t\treturn 0;\n\t}\n\n\tif (amdgpu_atomfirmware_dynamic_boot_config_supported(adev)) {\n\t\t \n\t\tret = psp_boot_config_get(adev, &boot_cfg);\n\t\tif (ret)\n\t\t\tdev_warn(adev->dev, \"PSP get boot config failed\\n\");\n\n\t\tif (!amdgpu_ras_is_supported(psp->adev, AMDGPU_RAS_BLOCK__UMC)) {\n\t\t\tif (!boot_cfg) {\n\t\t\t\tdev_info(adev->dev, \"GECC is disabled\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = psp_boot_config_set(adev, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_warn(adev->dev, \"PSP set boot config failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tdev_warn(adev->dev, \"GECC will be disabled in next boot cycle if set amdgpu_ras_enable and/or amdgpu_ras_mask to 0x0\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (boot_cfg == 1) {\n\t\t\t\tdev_info(adev->dev, \"GECC is enabled\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = psp_boot_config_set(adev, BOOT_CONFIG_GECC);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_warn(adev->dev, \"PSP set boot config failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tdev_warn(adev->dev, \"GECC will be enabled in next boot cycle\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpsp->ras_context.context.mem_context.shared_mem_size = PSP_RAS_SHARED_MEM_SIZE;\n\tpsp->ras_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->ras_context.context.mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &psp->ras_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tras_cmd = (struct ta_ras_shared_memory *)psp->ras_context.context.mem_context.shared_buf;\n\tmemset(ras_cmd, 0, sizeof(struct ta_ras_shared_memory));\n\n\tif (amdgpu_ras_is_poison_mode_supported(adev))\n\t\tras_cmd->ras_in_message.init_flags.poison_mode_en = 1;\n\tif (!adev->gmc.xgmi.connected_to_cpu && !adev->gmc.is_app_apu)\n\t\tras_cmd->ras_in_message.init_flags.dgpu_mode = 1;\n\tras_cmd->ras_in_message.init_flags.xcc_mask =\n\t\tadev->gfx.xcc_mask;\n\tras_cmd->ras_in_message.init_flags.channel_dis_num = hweight32(adev->gmc.m_half_use) * 2;\n\n\tret = psp_ta_load(psp, &psp->ras_context.context);\n\n\tif (!ret && !ras_cmd->ras_status)\n\t\tpsp->ras_context.context.initialized = true;\n\telse {\n\t\tif (ras_cmd->ras_status)\n\t\t\tdev_warn(psp->adev->dev, \"RAS Init Status: 0x%X\\n\", ras_cmd->ras_status);\n\n\t\t \n\t\tpsp->ras_context.context.initialized = false;\n\t}\n\n\treturn ret;\n}\n\nint psp_ras_trigger_error(struct psp_context *psp,\n\t\t\t  struct ta_ras_trigger_error_input *info, uint32_t instance_mask)\n{\n\tstruct ta_ras_shared_memory *ras_cmd;\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\tuint32_t dev_mask;\n\n\tif (!psp->ras_context.context.initialized)\n\t\treturn -EINVAL;\n\n\tswitch (info->block_id) {\n\tcase TA_RAS_BLOCK__GFX:\n\t\tdev_mask = GET_MASK(GC, instance_mask);\n\t\tbreak;\n\tcase TA_RAS_BLOCK__SDMA:\n\t\tdev_mask = GET_MASK(SDMA0, instance_mask);\n\t\tbreak;\n\tcase TA_RAS_BLOCK__VCN:\n\tcase TA_RAS_BLOCK__JPEG:\n\t\tdev_mask = GET_MASK(VCN, instance_mask);\n\t\tbreak;\n\tdefault:\n\t\tdev_mask = instance_mask;\n\t\tbreak;\n\t}\n\n\t \n\tdev_mask <<= AMDGPU_RAS_INST_SHIFT;\n\tdev_mask &= AMDGPU_RAS_INST_MASK;\n\tinfo->sub_block_index |= dev_mask;\n\n\tras_cmd = (struct ta_ras_shared_memory *)psp->ras_context.context.mem_context.shared_buf;\n\tmemset(ras_cmd, 0, sizeof(struct ta_ras_shared_memory));\n\n\tras_cmd->cmd_id = TA_RAS_COMMAND__TRIGGER_ERROR;\n\tras_cmd->ras_in_message.trigger_error = *info;\n\n\tret = psp_ras_invoke(psp, ras_cmd->cmd_id);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tif (amdgpu_ras_intr_triggered())\n\t\treturn 0;\n\n\tif (ras_cmd->ras_status == TA_RAS_STATUS__TEE_ERROR_ACCESS_DENIED)\n\t\treturn -EACCES;\n\telse if (ras_cmd->ras_status)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n \n\n \nstatic int psp_hdcp_initialize(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->hdcp_context.context.bin_desc.size_bytes ||\n\t    !psp->hdcp_context.context.bin_desc.start_addr) {\n\t\tdev_info(psp->adev->dev, \"HDCP: optional hdcp ta ucode is not available\\n\");\n\t\treturn 0;\n\t}\n\n\tpsp->hdcp_context.context.mem_context.shared_mem_size = PSP_HDCP_SHARED_MEM_SIZE;\n\tpsp->hdcp_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->hdcp_context.context.mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &psp->hdcp_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = psp_ta_load(psp, &psp->hdcp_context.context);\n\tif (!ret) {\n\t\tpsp->hdcp_context.context.initialized = true;\n\t\tmutex_init(&psp->hdcp_context.mutex);\n\t}\n\n\treturn ret;\n}\n\nint psp_hdcp_invoke(struct psp_context *psp, uint32_t ta_cmd_id)\n{\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\treturn psp_ta_invoke(psp, ta_cmd_id, &psp->hdcp_context.context);\n}\n\nstatic int psp_hdcp_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->hdcp_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->hdcp_context.context);\n\n\tpsp->hdcp_context.context.initialized = false;\n\n\treturn ret;\n}\n \n\n \nstatic int psp_dtm_initialize(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->dtm_context.context.bin_desc.size_bytes ||\n\t    !psp->dtm_context.context.bin_desc.start_addr) {\n\t\tdev_info(psp->adev->dev, \"DTM: optional dtm ta ucode is not available\\n\");\n\t\treturn 0;\n\t}\n\n\tpsp->dtm_context.context.mem_context.shared_mem_size = PSP_DTM_SHARED_MEM_SIZE;\n\tpsp->dtm_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->dtm_context.context.mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &psp->dtm_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = psp_ta_load(psp, &psp->dtm_context.context);\n\tif (!ret) {\n\t\tpsp->dtm_context.context.initialized = true;\n\t\tmutex_init(&psp->dtm_context.mutex);\n\t}\n\n\treturn ret;\n}\n\nint psp_dtm_invoke(struct psp_context *psp, uint32_t ta_cmd_id)\n{\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\treturn psp_ta_invoke(psp, ta_cmd_id, &psp->dtm_context.context);\n}\n\nstatic int psp_dtm_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->dtm_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->dtm_context.context);\n\n\tpsp->dtm_context.context.initialized = false;\n\n\treturn ret;\n}\n \n\n \nstatic int psp_rap_initialize(struct psp_context *psp)\n{\n\tint ret;\n\tenum ta_rap_status status = TA_RAP_STATUS__SUCCESS;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->rap_context.context.bin_desc.size_bytes ||\n\t    !psp->rap_context.context.bin_desc.start_addr) {\n\t\tdev_info(psp->adev->dev, \"RAP: optional rap ta ucode is not available\\n\");\n\t\treturn 0;\n\t}\n\n\tpsp->rap_context.context.mem_context.shared_mem_size = PSP_RAP_SHARED_MEM_SIZE;\n\tpsp->rap_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->rap_context.context.mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &psp->rap_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = psp_ta_load(psp, &psp->rap_context.context);\n\tif (!ret) {\n\t\tpsp->rap_context.context.initialized = true;\n\t\tmutex_init(&psp->rap_context.mutex);\n\t} else\n\t\treturn ret;\n\n\tret = psp_rap_invoke(psp, TA_CMD_RAP__INITIALIZE, &status);\n\tif (ret || status != TA_RAP_STATUS__SUCCESS) {\n\t\tpsp_rap_terminate(psp);\n\t\t \n\t\tpsp_ta_free_shared_buf(&psp->rap_context.context.mem_context);\n\n\t\tdev_warn(psp->adev->dev, \"RAP TA initialize fail (%d) status %d.\\n\",\n\t\t\t ret, status);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_rap_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\tif (!psp->rap_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->rap_context.context);\n\n\tpsp->rap_context.context.initialized = false;\n\n\treturn ret;\n}\n\nint psp_rap_invoke(struct psp_context *psp, uint32_t ta_cmd_id, enum ta_rap_status *status)\n{\n\tstruct ta_rap_shared_memory *rap_cmd;\n\tint ret = 0;\n\n\tif (!psp->rap_context.context.initialized)\n\t\treturn 0;\n\n\tif (ta_cmd_id != TA_CMD_RAP__INITIALIZE &&\n\t    ta_cmd_id != TA_CMD_RAP__VALIDATE_L0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&psp->rap_context.mutex);\n\n\trap_cmd = (struct ta_rap_shared_memory *)\n\t\t  psp->rap_context.context.mem_context.shared_buf;\n\tmemset(rap_cmd, 0, sizeof(struct ta_rap_shared_memory));\n\n\trap_cmd->cmd_id = ta_cmd_id;\n\trap_cmd->validation_method_id = METHOD_A;\n\n\tret = psp_ta_invoke(psp, rap_cmd->cmd_id, &psp->rap_context.context);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (status)\n\t\t*status = rap_cmd->rap_status;\n\nout_unlock:\n\tmutex_unlock(&psp->rap_context.mutex);\n\n\treturn ret;\n}\n \n\n \nstatic int psp_securedisplay_initialize(struct psp_context *psp)\n{\n\tint ret;\n\tstruct ta_securedisplay_cmd *securedisplay_cmd;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->securedisplay_context.context.bin_desc.size_bytes ||\n\t    !psp->securedisplay_context.context.bin_desc.start_addr) {\n\t\tdev_info(psp->adev->dev, \"SECUREDISPLAY: securedisplay ta ucode is not available\\n\");\n\t\treturn 0;\n\t}\n\n\tpsp->securedisplay_context.context.mem_context.shared_mem_size =\n\t\tPSP_SECUREDISPLAY_SHARED_MEM_SIZE;\n\tpsp->securedisplay_context.context.ta_load_type = GFX_CMD_ID_LOAD_TA;\n\n\tif (!psp->securedisplay_context.context.initialized) {\n\t\tret = psp_ta_init_shared_buf(psp,\n\t\t\t\t\t     &psp->securedisplay_context.context.mem_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = psp_ta_load(psp, &psp->securedisplay_context.context);\n\tif (!ret) {\n\t\tpsp->securedisplay_context.context.initialized = true;\n\t\tmutex_init(&psp->securedisplay_context.mutex);\n\t} else\n\t\treturn ret;\n\n\tmutex_lock(&psp->securedisplay_context.mutex);\n\n\tpsp_prep_securedisplay_cmd_buf(psp, &securedisplay_cmd,\n\t\t\tTA_SECUREDISPLAY_COMMAND__QUERY_TA);\n\n\tret = psp_securedisplay_invoke(psp, TA_SECUREDISPLAY_COMMAND__QUERY_TA);\n\n\tmutex_unlock(&psp->securedisplay_context.mutex);\n\n\tif (ret) {\n\t\tpsp_securedisplay_terminate(psp);\n\t\t \n\t\tpsp_ta_free_shared_buf(&psp->securedisplay_context.context.mem_context);\n\t\tdev_err(psp->adev->dev, \"SECUREDISPLAY TA initialize fail.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (securedisplay_cmd->status != TA_SECUREDISPLAY_STATUS__SUCCESS) {\n\t\tpsp_securedisplay_parse_resp_status(psp, securedisplay_cmd->status);\n\t\tdev_err(psp->adev->dev, \"SECUREDISPLAY: query securedisplay TA failed. ret 0x%x\\n\",\n\t\t\tsecuredisplay_cmd->securedisplay_out_message.query_ta.query_cmd_ret);\n\t\t \n\t\tpsp->securedisplay_context.context.bin_desc.size_bytes = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_securedisplay_terminate(struct psp_context *psp)\n{\n\tint ret;\n\n\t \n\tif (amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif (!psp->securedisplay_context.context.initialized)\n\t\treturn 0;\n\n\tret = psp_ta_unload(psp, &psp->securedisplay_context.context);\n\n\tpsp->securedisplay_context.context.initialized = false;\n\n\treturn ret;\n}\n\nint psp_securedisplay_invoke(struct psp_context *psp, uint32_t ta_cmd_id)\n{\n\tint ret;\n\n\tif (!psp->securedisplay_context.context.initialized)\n\t\treturn -EINVAL;\n\n\tif (ta_cmd_id != TA_SECUREDISPLAY_COMMAND__QUERY_TA &&\n\t    ta_cmd_id != TA_SECUREDISPLAY_COMMAND__SEND_ROI_CRC)\n\t\treturn -EINVAL;\n\n\tret = psp_ta_invoke(psp, ta_cmd_id, &psp->securedisplay_context.context);\n\n\treturn ret;\n}\n \n\nint amdgpu_psp_wait_for_bootloader(struct amdgpu_device *adev)\n{\n\tstruct psp_context *psp = &adev->psp;\n\tint ret = 0;\n\n\tif (!amdgpu_sriov_vf(adev) && psp->funcs && psp->funcs->wait_for_bootloader != NULL)\n\t\tret = psp->funcs->wait_for_bootloader(psp);\n\n\treturn ret;\n}\n\nstatic int psp_hw_start(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tif ((is_psp_fw_valid(psp->kdb)) &&\n\t\t    (psp->funcs->bootloader_load_kdb != NULL)) {\n\t\t\tret = psp_bootloader_load_kdb(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load kdb failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->spl)) &&\n\t\t    (psp->funcs->bootloader_load_spl != NULL)) {\n\t\t\tret = psp_bootloader_load_spl(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load spl failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->sys)) &&\n\t\t    (psp->funcs->bootloader_load_sysdrv != NULL)) {\n\t\t\tret = psp_bootloader_load_sysdrv(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load sys drv failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->soc_drv)) &&\n\t\t    (psp->funcs->bootloader_load_soc_drv != NULL)) {\n\t\t\tret = psp_bootloader_load_soc_drv(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load soc drv failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->intf_drv)) &&\n\t\t    (psp->funcs->bootloader_load_intf_drv != NULL)) {\n\t\t\tret = psp_bootloader_load_intf_drv(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load intf drv failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->dbg_drv)) &&\n\t\t    (psp->funcs->bootloader_load_dbg_drv != NULL)) {\n\t\t\tret = psp_bootloader_load_dbg_drv(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load dbg drv failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->ras_drv)) &&\n\t\t    (psp->funcs->bootloader_load_ras_drv != NULL)) {\n\t\t\tret = psp_bootloader_load_ras_drv(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load ras_drv failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif ((is_psp_fw_valid(psp->sos)) &&\n\t\t    (psp->funcs->bootloader_load_sos != NULL)) {\n\t\t\tret = psp_bootloader_load_sos(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"PSP load sos failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = psp_ring_create(psp, PSP_RING_TYPE__KM);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP create ring failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_in_reset(adev))\n\t\tgoto skip_pin_bo;\n\n\tif (!psp_boottime_tmr(psp)) {\n\t\tret = psp_tmr_init(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"PSP tmr init failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\nskip_pin_bo:\n\t \n\tif (psp->pmfw_centralized_cstate_management) {\n\t\tret = psp_load_smu_fw(psp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = psp_tmr_load(psp);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP load tmr failed!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_get_fw_type(struct amdgpu_firmware_info *ucode,\n\t\t\t   enum psp_gfx_fw_type *type)\n{\n\tswitch (ucode->ucode_id) {\n\tcase AMDGPU_UCODE_ID_CAP:\n\t\t*type = GFX_FW_TYPE_CAP;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA0:\n\t\t*type = GFX_FW_TYPE_SDMA0;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA1:\n\t\t*type = GFX_FW_TYPE_SDMA1;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA2:\n\t\t*type = GFX_FW_TYPE_SDMA2;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA3:\n\t\t*type = GFX_FW_TYPE_SDMA3;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA4:\n\t\t*type = GFX_FW_TYPE_SDMA4;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA5:\n\t\t*type = GFX_FW_TYPE_SDMA5;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA6:\n\t\t*type = GFX_FW_TYPE_SDMA6;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA7:\n\t\t*type = GFX_FW_TYPE_SDMA7;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MES:\n\t\t*type = GFX_FW_TYPE_CP_MES;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MES_DATA:\n\t\t*type = GFX_FW_TYPE_MES_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MES1:\n\t\t*type = GFX_FW_TYPE_CP_MES_KIQ;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MES1_DATA:\n\t\t*type = GFX_FW_TYPE_MES_KIQ_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_CE:\n\t\t*type = GFX_FW_TYPE_CP_CE;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_PFP:\n\t\t*type = GFX_FW_TYPE_CP_PFP;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_ME:\n\t\t*type = GFX_FW_TYPE_CP_ME;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC1:\n\t\t*type = GFX_FW_TYPE_CP_MEC;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC1_JT:\n\t\t*type = GFX_FW_TYPE_CP_MEC_ME1;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC2:\n\t\t*type = GFX_FW_TYPE_CP_MEC;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC2_JT:\n\t\t*type = GFX_FW_TYPE_CP_MEC_ME2;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_P:\n\t\t*type = GFX_FW_TYPE_RLC_P;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_V:\n\t\t*type = GFX_FW_TYPE_RLC_V;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_G:\n\t\t*type = GFX_FW_TYPE_RLC_G;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL:\n\t\t*type = GFX_FW_TYPE_RLC_RESTORE_LIST_SRM_CNTL;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM:\n\t\t*type = GFX_FW_TYPE_RLC_RESTORE_LIST_GPM_MEM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM:\n\t\t*type = GFX_FW_TYPE_RLC_RESTORE_LIST_SRM_MEM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_IRAM:\n\t\t*type = GFX_FW_TYPE_RLC_IRAM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_DRAM:\n\t\t*type = GFX_FW_TYPE_RLC_DRAM_BOOT;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_GLOBAL_TAP_DELAYS:\n\t\t*type = GFX_FW_TYPE_GLOBAL_TAP_DELAYS;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SE0_TAP_DELAYS:\n\t\t*type = GFX_FW_TYPE_SE0_TAP_DELAYS;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SE1_TAP_DELAYS:\n\t\t*type = GFX_FW_TYPE_SE1_TAP_DELAYS;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SE2_TAP_DELAYS:\n\t\t*type = GFX_FW_TYPE_SE2_TAP_DELAYS;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SE3_TAP_DELAYS:\n\t\t*type = GFX_FW_TYPE_SE3_TAP_DELAYS;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SMC:\n\t\t*type = GFX_FW_TYPE_SMU;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_PPTABLE:\n\t\t*type = GFX_FW_TYPE_PPTABLE;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_UVD:\n\t\t*type = GFX_FW_TYPE_UVD;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_UVD1:\n\t\t*type = GFX_FW_TYPE_UVD1;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_VCE:\n\t\t*type = GFX_FW_TYPE_VCE;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_VCN:\n\t\t*type = GFX_FW_TYPE_VCN;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_VCN1:\n\t\t*type = GFX_FW_TYPE_VCN1;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_DMCU_ERAM:\n\t\t*type = GFX_FW_TYPE_DMCU_ERAM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_DMCU_INTV:\n\t\t*type = GFX_FW_TYPE_DMCU_ISR;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_VCN0_RAM:\n\t\t*type = GFX_FW_TYPE_VCN0_RAM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_VCN1_RAM:\n\t\t*type = GFX_FW_TYPE_VCN1_RAM;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_DMCUB:\n\t\t*type = GFX_FW_TYPE_DMUB;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH0:\n\t\t*type = GFX_FW_TYPE_SDMA_UCODE_TH0;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH1:\n\t\t*type = GFX_FW_TYPE_SDMA_UCODE_TH1;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_IMU_I:\n\t\t*type = GFX_FW_TYPE_IMU_I;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_IMU_D:\n\t\t*type = GFX_FW_TYPE_IMU_D;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP:\n\t\t*type = GFX_FW_TYPE_RS64_PFP;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME:\n\t\t*type = GFX_FW_TYPE_RS64_ME;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC:\n\t\t*type = GFX_FW_TYPE_RS64_MEC;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P0_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_PFP_P0_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P1_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_PFP_P1_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P0_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_ME_P0_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P1_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_ME_P1_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P0_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_MEC_P0_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P1_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_MEC_P1_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P2_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_MEC_P2_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P3_STACK:\n\t\t*type = GFX_FW_TYPE_RS64_MEC_P3_STACK;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_MAXIMUM:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void psp_print_fw_hdr(struct psp_context *psp,\n\t\t\t     struct amdgpu_firmware_info *ucode)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tstruct common_firmware_header *hdr;\n\n\tswitch (ucode->ucode_id) {\n\tcase AMDGPU_UCODE_ID_SDMA0:\n\tcase AMDGPU_UCODE_ID_SDMA1:\n\tcase AMDGPU_UCODE_ID_SDMA2:\n\tcase AMDGPU_UCODE_ID_SDMA3:\n\tcase AMDGPU_UCODE_ID_SDMA4:\n\tcase AMDGPU_UCODE_ID_SDMA5:\n\tcase AMDGPU_UCODE_ID_SDMA6:\n\tcase AMDGPU_UCODE_ID_SDMA7:\n\t\thdr = (struct common_firmware_header *)\n\t\t\tadev->sdma.instance[ucode->ucode_id - AMDGPU_UCODE_ID_SDMA0].fw->data;\n\t\tamdgpu_ucode_print_sdma_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_CE:\n\t\thdr = (struct common_firmware_header *)adev->gfx.ce_fw->data;\n\t\tamdgpu_ucode_print_gfx_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_PFP:\n\t\thdr = (struct common_firmware_header *)adev->gfx.pfp_fw->data;\n\t\tamdgpu_ucode_print_gfx_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_ME:\n\t\thdr = (struct common_firmware_header *)adev->gfx.me_fw->data;\n\t\tamdgpu_ucode_print_gfx_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC1:\n\t\thdr = (struct common_firmware_header *)adev->gfx.mec_fw->data;\n\t\tamdgpu_ucode_print_gfx_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_RLC_G:\n\t\thdr = (struct common_firmware_header *)adev->gfx.rlc_fw->data;\n\t\tamdgpu_ucode_print_rlc_hdr(hdr);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_SMC:\n\t\thdr = (struct common_firmware_header *)adev->pm.fw->data;\n\t\tamdgpu_ucode_print_smc_hdr(hdr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int psp_prep_load_ip_fw_cmd_buf(struct amdgpu_firmware_info *ucode,\n\t\t\t\t       struct psp_gfx_cmd_resp *cmd)\n{\n\tint ret;\n\tuint64_t fw_mem_mc_addr = ucode->mc_addr;\n\n\tcmd->cmd_id = GFX_CMD_ID_LOAD_IP_FW;\n\tcmd->cmd.cmd_load_ip_fw.fw_phy_addr_lo = lower_32_bits(fw_mem_mc_addr);\n\tcmd->cmd.cmd_load_ip_fw.fw_phy_addr_hi = upper_32_bits(fw_mem_mc_addr);\n\tcmd->cmd.cmd_load_ip_fw.fw_size = ucode->ucode_size;\n\n\tret = psp_get_fw_type(ucode, &cmd->cmd.cmd_load_ip_fw.fw_type);\n\tif (ret)\n\t\tDRM_ERROR(\"Unknown firmware type\\n\");\n\n\treturn ret;\n}\n\nint psp_execute_ip_fw_load(struct psp_context *psp,\n\t\t\t   struct amdgpu_firmware_info *ucode)\n{\n\tint ret = 0;\n\tstruct psp_gfx_cmd_resp *cmd = acquire_psp_cmd_buf(psp);\n\n\tret = psp_prep_load_ip_fw_cmd_buf(ucode, cmd);\n\tif (!ret) {\n\t\tret = psp_cmd_submit_buf(psp, ucode, cmd,\n\t\t\t\t\t psp->fence_buf_mc_addr);\n\t}\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nstatic int psp_load_smu_fw(struct psp_context *psp)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = psp->adev;\n\tstruct amdgpu_firmware_info *ucode =\n\t\t\t&adev->firmware.ucode[AMDGPU_UCODE_ID_SMC];\n\tstruct amdgpu_ras *ras = psp->ras_context.ras;\n\n\t \n\tif (adev->in_runpm && (adev->pm.rpm_mode == AMDGPU_RUNPM_BACO))\n\t\treturn 0;\n\n\tif (!ucode->fw || amdgpu_sriov_vf(psp->adev))\n\t\treturn 0;\n\n\tif ((amdgpu_in_reset(adev) &&\n\t     ras && adev->ras_enabled &&\n\t     (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 4) ||\n\t      adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 2)))) {\n\t\tret = amdgpu_dpm_set_mp1_state(adev, PP_MP1_STATE_UNLOAD);\n\t\tif (ret)\n\t\t\tDRM_WARN(\"Failed to set MP1 state prepare for reload\\n\");\n\t}\n\n\tret = psp_execute_ip_fw_load(psp, ucode);\n\n\tif (ret)\n\t\tDRM_ERROR(\"PSP load smu failed!\\n\");\n\n\treturn ret;\n}\n\nstatic bool fw_load_skip_check(struct psp_context *psp,\n\t\t\t       struct amdgpu_firmware_info *ucode)\n{\n\tif (!ucode->fw || !ucode->ucode_size)\n\t\treturn true;\n\n\tif (ucode->ucode_id == AMDGPU_UCODE_ID_SMC &&\n\t    (psp_smu_reload_quirk(psp) ||\n\t     psp->autoload_supported ||\n\t     psp->pmfw_centralized_cstate_management))\n\t\treturn true;\n\n\tif (amdgpu_sriov_vf(psp->adev) &&\n\t    amdgpu_virt_fw_load_skip_check(psp->adev, ucode->ucode_id))\n\t\treturn true;\n\n\tif (psp->autoload_supported &&\n\t    (ucode->ucode_id == AMDGPU_UCODE_ID_CP_MEC1_JT ||\n\t     ucode->ucode_id == AMDGPU_UCODE_ID_CP_MEC2_JT))\n\t\t \n\t\treturn true;\n\n\treturn false;\n}\n\nint psp_load_fw_list(struct psp_context *psp,\n\t\t     struct amdgpu_firmware_info **ucode_list, int ucode_count)\n{\n\tint ret = 0, i;\n\tstruct amdgpu_firmware_info *ucode;\n\n\tfor (i = 0; i < ucode_count; ++i) {\n\t\tucode = ucode_list[i];\n\t\tpsp_print_fw_hdr(psp, ucode);\n\t\tret = psp_execute_ip_fw_load(psp, ucode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int psp_load_non_psp_fw(struct psp_context *psp)\n{\n\tint i, ret;\n\tstruct amdgpu_firmware_info *ucode;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (psp->autoload_supported &&\n\t    !psp->pmfw_centralized_cstate_management) {\n\t\tret = psp_load_smu_fw(psp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < adev->firmware.max_ucodes; i++) {\n\t\tucode = &adev->firmware.ucode[i];\n\n\t\tif (ucode->ucode_id == AMDGPU_UCODE_ID_SMC &&\n\t\t    !fw_load_skip_check(psp, ucode)) {\n\t\t\tret = psp_load_smu_fw(psp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fw_load_skip_check(psp, ucode))\n\t\t\tcontinue;\n\n\t\tif (psp->autoload_supported &&\n\t\t    (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 7) ||\n\t\t     adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 11) ||\n\t\t     adev->ip_versions[MP0_HWIP][0] == IP_VERSION(11, 0, 12)) &&\n\t\t    (ucode->ucode_id == AMDGPU_UCODE_ID_SDMA1 ||\n\t\t     ucode->ucode_id == AMDGPU_UCODE_ID_SDMA2 ||\n\t\t     ucode->ucode_id == AMDGPU_UCODE_ID_SDMA3))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tpsp_print_fw_hdr(psp, ucode);\n\n\t\tret = psp_execute_ip_fw_load(psp, ucode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (psp->autoload_supported && ucode->ucode_id == (amdgpu_sriov_vf(adev) ?\n\t\t    adev->virt.autoload_ucode_id : AMDGPU_UCODE_ID_RLC_G)) {\n\t\t\tret = psp_rlc_autoload_start(psp);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"Failed to start rlc autoload\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_load_fw(struct amdgpu_device *adev)\n{\n\tint ret;\n\tstruct psp_context *psp = &adev->psp;\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_in_reset(adev)) {\n\t\t \n\t\tpsp_ring_stop(psp, PSP_RING_TYPE__KM);\n\t} else {\n\t\tmemset(psp->fence_buf, 0, PSP_FENCE_BUFFER_SIZE);\n\n\t\tret = psp_ring_init(psp, PSP_RING_TYPE__KM);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"PSP ring init failed!\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tret = psp_hw_start(psp);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = psp_load_non_psp_fw(psp);\n\tif (ret)\n\t\tgoto failed1;\n\n\tret = psp_asd_initialize(psp);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP load asd failed!\\n\");\n\t\tgoto failed1;\n\t}\n\n\tret = psp_rl_load(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP load RL failed!\\n\");\n\t\tgoto failed1;\n\t}\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_in_reset(adev)) {\n\t\tif (adev->gmc.xgmi.num_physical_nodes > 1) {\n\t\t\tret = psp_xgmi_initialize(psp, false, true);\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\t\"XGMI: Failed to initialize XGMI session\\n\");\n\t\t}\n\t}\n\n\tif (psp->ta_fw) {\n\t\tret = psp_ras_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\t\"RAS: Failed to initialize RAS\\n\");\n\n\t\tret = psp_hdcp_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"HDCP: Failed to initialize HDCP\\n\");\n\n\t\tret = psp_dtm_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"DTM: Failed to initialize DTM\\n\");\n\n\t\tret = psp_rap_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"RAP: Failed to initialize RAP\\n\");\n\n\t\tret = psp_securedisplay_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"SECUREDISPLAY: Failed to initialize SECUREDISPLAY\\n\");\n\t}\n\n\treturn 0;\n\nfailed1:\n\tpsp_free_shared_bufs(psp);\nfailed:\n\t \n\tpsp_ring_destroy(psp, PSP_RING_TYPE__KM);\n\treturn ret;\n}\n\nstatic int psp_hw_init(void *handle)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tmutex_lock(&adev->firmware.mutex);\n\t \n\tret = amdgpu_ucode_init_bo(adev);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = psp_load_fw(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP firmware loading failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tmutex_unlock(&adev->firmware.mutex);\n\treturn 0;\n\nfailed:\n\tadev->firmware.load_type = AMDGPU_FW_LOAD_DIRECT;\n\tmutex_unlock(&adev->firmware.mutex);\n\treturn -EINVAL;\n}\n\nstatic int psp_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\n\tif (psp->ta_fw) {\n\t\tpsp_ras_terminate(psp);\n\t\tpsp_securedisplay_terminate(psp);\n\t\tpsp_rap_terminate(psp);\n\t\tpsp_dtm_terminate(psp);\n\t\tpsp_hdcp_terminate(psp);\n\n\t\tif (adev->gmc.xgmi.num_physical_nodes > 1)\n\t\t\tpsp_xgmi_terminate(psp);\n\t}\n\n\tpsp_asd_terminate(psp);\n\tpsp_tmr_terminate(psp);\n\n\tpsp_ring_destroy(psp, PSP_RING_TYPE__KM);\n\n\treturn 0;\n}\n\nstatic int psp_suspend(void *handle)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\n\tif (adev->gmc.xgmi.num_physical_nodes > 1 &&\n\t    psp->xgmi_context.context.initialized) {\n\t\tret = psp_xgmi_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate xgmi ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (psp->ta_fw) {\n\t\tret = psp_ras_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate ras ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = psp_hdcp_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate hdcp ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = psp_dtm_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate dtm ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = psp_rap_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate rap ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = psp_securedisplay_terminate(psp);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to terminate securedisplay ta\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = psp_asd_terminate(psp);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to terminate asd\\n\");\n\t\tgoto out;\n\t}\n\n\tret = psp_tmr_terminate(psp);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to terminate tmr\\n\");\n\t\tgoto out;\n\t}\n\n\tret = psp_ring_stop(psp, PSP_RING_TYPE__KM);\n\tif (ret)\n\t\tDRM_ERROR(\"PSP ring stop failed\\n\");\n\nout:\n\treturn ret;\n}\n\nstatic int psp_resume(void *handle)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct psp_context *psp = &adev->psp;\n\n\tDRM_INFO(\"PSP is resuming...\\n\");\n\n\tif (psp->mem_train_ctx.enable_mem_training) {\n\t\tret = psp_mem_training(psp, PSP_MEM_TRAIN_RESUME);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to process memory training!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&adev->firmware.mutex);\n\n\tret = psp_hw_start(psp);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = psp_load_non_psp_fw(psp);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = psp_asd_initialize(psp);\n\tif (ret) {\n\t\tDRM_ERROR(\"PSP load asd failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tret = psp_rl_load(adev);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"PSP load RL failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (adev->gmc.xgmi.num_physical_nodes > 1) {\n\t\tret = psp_xgmi_initialize(psp, false, true);\n\t\t \n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"XGMI: Failed to initialize XGMI session\\n\");\n\t}\n\n\tif (psp->ta_fw) {\n\t\tret = psp_ras_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\t\"RAS: Failed to initialize RAS\\n\");\n\n\t\tret = psp_hdcp_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"HDCP: Failed to initialize HDCP\\n\");\n\n\t\tret = psp_dtm_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"DTM: Failed to initialize DTM\\n\");\n\n\t\tret = psp_rap_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"RAP: Failed to initialize RAP\\n\");\n\n\t\tret = psp_securedisplay_initialize(psp);\n\t\tif (ret)\n\t\t\tdev_err(psp->adev->dev,\n\t\t\t\t\"SECUREDISPLAY: Failed to initialize SECUREDISPLAY\\n\");\n\t}\n\n\tmutex_unlock(&adev->firmware.mutex);\n\n\treturn 0;\n\nfailed:\n\tDRM_ERROR(\"PSP resume failed\\n\");\n\tmutex_unlock(&adev->firmware.mutex);\n\treturn ret;\n}\n\nint psp_gpu_reset(struct amdgpu_device *adev)\n{\n\tint ret;\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP)\n\t\treturn 0;\n\n\tmutex_lock(&adev->psp.mutex);\n\tret = psp_mode1_reset(&adev->psp);\n\tmutex_unlock(&adev->psp.mutex);\n\n\treturn ret;\n}\n\nint psp_rlc_autoload_start(struct psp_context *psp)\n{\n\tint ret;\n\tstruct psp_gfx_cmd_resp *cmd = acquire_psp_cmd_buf(psp);\n\n\tcmd->cmd_id = GFX_CMD_ID_AUTOLOAD_RLC;\n\n\tret = psp_cmd_submit_buf(psp, NULL, cmd,\n\t\t\t\t psp->fence_buf_mc_addr);\n\n\trelease_psp_cmd_buf(psp);\n\n\treturn ret;\n}\n\nint psp_ring_cmd_submit(struct psp_context *psp,\n\t\t\tuint64_t cmd_buf_mc_addr,\n\t\t\tuint64_t fence_mc_addr,\n\t\t\tint index)\n{\n\tunsigned int psp_write_ptr_reg = 0;\n\tstruct psp_gfx_rb_frame *write_frame;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct psp_gfx_rb_frame *ring_buffer_start = ring->ring_mem;\n\tstruct psp_gfx_rb_frame *ring_buffer_end = ring_buffer_start +\n\t\tring->ring_size / sizeof(struct psp_gfx_rb_frame) - 1;\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t ring_size_dw = ring->ring_size / 4;\n\tuint32_t rb_frame_size_dw = sizeof(struct psp_gfx_rb_frame) / 4;\n\n\t \n\tpsp_write_ptr_reg = psp_ring_get_wptr(psp);\n\n\t \n\t \n\t \n\tif ((psp_write_ptr_reg % ring_size_dw) == 0)\n\t\twrite_frame = ring_buffer_start;\n\telse\n\t\twrite_frame = ring_buffer_start + (psp_write_ptr_reg / rb_frame_size_dw);\n\t \n\tif ((write_frame < ring_buffer_start) || (ring_buffer_end < write_frame)) {\n\t\tDRM_ERROR(\"ring_buffer_start = %p; ring_buffer_end = %p; write_frame = %p\\n\",\n\t\t\t  ring_buffer_start, ring_buffer_end, write_frame);\n\t\tDRM_ERROR(\"write_frame is pointing to address out of bounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(write_frame, 0, sizeof(struct psp_gfx_rb_frame));\n\n\t \n\twrite_frame->cmd_buf_addr_hi = upper_32_bits(cmd_buf_mc_addr);\n\twrite_frame->cmd_buf_addr_lo = lower_32_bits(cmd_buf_mc_addr);\n\twrite_frame->fence_addr_hi = upper_32_bits(fence_mc_addr);\n\twrite_frame->fence_addr_lo = lower_32_bits(fence_mc_addr);\n\twrite_frame->fence_value = index;\n\tamdgpu_device_flush_hdp(adev, NULL);\n\n\t \n\tpsp_write_ptr_reg = (psp_write_ptr_reg + rb_frame_size_dw) % ring_size_dw;\n\tpsp_ring_set_wptr(psp, psp_write_ptr_reg);\n\treturn 0;\n}\n\nint psp_init_asd_microcode(struct psp_context *psp, const char *chip_name)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar fw_name[PSP_FW_NAME_LEN];\n\tconst struct psp_firmware_header_v1_0 *asd_hdr;\n\tint err = 0;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_asd.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->psp.asd_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tasd_hdr = (const struct psp_firmware_header_v1_0 *)adev->psp.asd_fw->data;\n\tadev->psp.asd_context.bin_desc.fw_version = le32_to_cpu(asd_hdr->header.ucode_version);\n\tadev->psp.asd_context.bin_desc.feature_version = le32_to_cpu(asd_hdr->sos.fw_version);\n\tadev->psp.asd_context.bin_desc.size_bytes = le32_to_cpu(asd_hdr->header.ucode_size_bytes);\n\tadev->psp.asd_context.bin_desc.start_addr = (uint8_t *)asd_hdr +\n\t\t\t\tle32_to_cpu(asd_hdr->header.ucode_array_offset_bytes);\n\treturn 0;\nout:\n\tamdgpu_ucode_release(&adev->psp.asd_fw);\n\treturn err;\n}\n\nint psp_init_toc_microcode(struct psp_context *psp, const char *chip_name)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar fw_name[PSP_FW_NAME_LEN];\n\tconst struct psp_firmware_header_v1_0 *toc_hdr;\n\tint err = 0;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_toc.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->psp.toc_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\ttoc_hdr = (const struct psp_firmware_header_v1_0 *)adev->psp.toc_fw->data;\n\tadev->psp.toc.fw_version = le32_to_cpu(toc_hdr->header.ucode_version);\n\tadev->psp.toc.feature_version = le32_to_cpu(toc_hdr->sos.fw_version);\n\tadev->psp.toc.size_bytes = le32_to_cpu(toc_hdr->header.ucode_size_bytes);\n\tadev->psp.toc.start_addr = (uint8_t *)toc_hdr +\n\t\t\t\tle32_to_cpu(toc_hdr->header.ucode_array_offset_bytes);\n\treturn 0;\nout:\n\tamdgpu_ucode_release(&adev->psp.toc_fw);\n\treturn err;\n}\n\nstatic int parse_sos_bin_descriptor(struct psp_context *psp,\n\t\t\t\t   const struct psp_fw_bin_desc *desc,\n\t\t\t\t   const struct psp_firmware_header_v2_0 *sos_hdr)\n{\n\tuint8_t *ucode_start_addr  = NULL;\n\n\tif (!psp || !desc || !sos_hdr)\n\t\treturn -EINVAL;\n\n\tucode_start_addr  = (uint8_t *)sos_hdr +\n\t\t\t    le32_to_cpu(desc->offset_bytes) +\n\t\t\t    le32_to_cpu(sos_hdr->header.ucode_array_offset_bytes);\n\n\tswitch (desc->fw_type) {\n\tcase PSP_FW_TYPE_PSP_SOS:\n\t\tpsp->sos.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->sos.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->sos.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->sos.start_addr\t   = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_SYS_DRV:\n\t\tpsp->sys.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->sys.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->sys.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->sys.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_KDB:\n\t\tpsp->kdb.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->kdb.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->kdb.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->kdb.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_TOC:\n\t\tpsp->toc.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->toc.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->toc.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->toc.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_SPL:\n\t\tpsp->spl.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->spl.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->spl.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->spl.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_RL:\n\t\tpsp->rl.fw_version         = le32_to_cpu(desc->fw_version);\n\t\tpsp->rl.feature_version    = le32_to_cpu(desc->fw_version);\n\t\tpsp->rl.size_bytes         = le32_to_cpu(desc->size_bytes);\n\t\tpsp->rl.start_addr         = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_SOC_DRV:\n\t\tpsp->soc_drv.fw_version         = le32_to_cpu(desc->fw_version);\n\t\tpsp->soc_drv.feature_version    = le32_to_cpu(desc->fw_version);\n\t\tpsp->soc_drv.size_bytes         = le32_to_cpu(desc->size_bytes);\n\t\tpsp->soc_drv.start_addr         = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_INTF_DRV:\n\t\tpsp->intf_drv.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->intf_drv.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->intf_drv.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->intf_drv.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_DBG_DRV:\n\t\tpsp->dbg_drv.fw_version         = le32_to_cpu(desc->fw_version);\n\t\tpsp->dbg_drv.feature_version    = le32_to_cpu(desc->fw_version);\n\t\tpsp->dbg_drv.size_bytes         = le32_to_cpu(desc->size_bytes);\n\t\tpsp->dbg_drv.start_addr         = ucode_start_addr;\n\t\tbreak;\n\tcase PSP_FW_TYPE_PSP_RAS_DRV:\n\t\tpsp->ras_drv.fw_version         = le32_to_cpu(desc->fw_version);\n\t\tpsp->ras_drv.feature_version    = le32_to_cpu(desc->fw_version);\n\t\tpsp->ras_drv.size_bytes         = le32_to_cpu(desc->size_bytes);\n\t\tpsp->ras_drv.start_addr         = ucode_start_addr;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(psp->adev->dev, \"Unsupported PSP FW type: %d\\n\", desc->fw_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_init_sos_base_fw(struct amdgpu_device *adev)\n{\n\tconst struct psp_firmware_header_v1_0 *sos_hdr;\n\tconst struct psp_firmware_header_v1_3 *sos_hdr_v1_3;\n\tuint8_t *ucode_array_start_addr;\n\n\tsos_hdr = (const struct psp_firmware_header_v1_0 *)adev->psp.sos_fw->data;\n\tucode_array_start_addr = (uint8_t *)sos_hdr +\n\t\tle32_to_cpu(sos_hdr->header.ucode_array_offset_bytes);\n\n\tif (adev->gmc.xgmi.connected_to_cpu ||\n\t    (adev->ip_versions[MP0_HWIP][0] != IP_VERSION(13, 0, 2))) {\n\t\tadev->psp.sos.fw_version = le32_to_cpu(sos_hdr->header.ucode_version);\n\t\tadev->psp.sos.feature_version = le32_to_cpu(sos_hdr->sos.fw_version);\n\n\t\tadev->psp.sys.size_bytes = le32_to_cpu(sos_hdr->sos.offset_bytes);\n\t\tadev->psp.sys.start_addr = ucode_array_start_addr;\n\n\t\tadev->psp.sos.size_bytes = le32_to_cpu(sos_hdr->sos.size_bytes);\n\t\tadev->psp.sos.start_addr = ucode_array_start_addr +\n\t\t\t\tle32_to_cpu(sos_hdr->sos.offset_bytes);\n\t} else {\n\t\t \n\t\tsos_hdr_v1_3 = (const struct psp_firmware_header_v1_3 *)adev->psp.sos_fw->data;\n\n\t\tadev->psp.sos.fw_version = le32_to_cpu(sos_hdr_v1_3->sos_aux.fw_version);\n\t\tadev->psp.sos.feature_version = le32_to_cpu(sos_hdr_v1_3->sos_aux.fw_version);\n\n\t\tadev->psp.sys.size_bytes = le32_to_cpu(sos_hdr_v1_3->sys_drv_aux.size_bytes);\n\t\tadev->psp.sys.start_addr = ucode_array_start_addr +\n\t\t\tle32_to_cpu(sos_hdr_v1_3->sys_drv_aux.offset_bytes);\n\n\t\tadev->psp.sos.size_bytes = le32_to_cpu(sos_hdr_v1_3->sos_aux.size_bytes);\n\t\tadev->psp.sos.start_addr = ucode_array_start_addr +\n\t\t\tle32_to_cpu(sos_hdr_v1_3->sos_aux.offset_bytes);\n\t}\n\n\tif ((adev->psp.sys.size_bytes == 0) || (adev->psp.sos.size_bytes == 0)) {\n\t\tdev_warn(adev->dev, \"PSP SOS FW not available\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint psp_init_sos_microcode(struct psp_context *psp, const char *chip_name)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar fw_name[PSP_FW_NAME_LEN];\n\tconst struct psp_firmware_header_v1_0 *sos_hdr;\n\tconst struct psp_firmware_header_v1_1 *sos_hdr_v1_1;\n\tconst struct psp_firmware_header_v1_2 *sos_hdr_v1_2;\n\tconst struct psp_firmware_header_v1_3 *sos_hdr_v1_3;\n\tconst struct psp_firmware_header_v2_0 *sos_hdr_v2_0;\n\tint err = 0;\n\tuint8_t *ucode_array_start_addr;\n\tint fw_index = 0;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_sos.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->psp.sos_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tsos_hdr = (const struct psp_firmware_header_v1_0 *)adev->psp.sos_fw->data;\n\tucode_array_start_addr = (uint8_t *)sos_hdr +\n\t\tle32_to_cpu(sos_hdr->header.ucode_array_offset_bytes);\n\tamdgpu_ucode_print_psp_hdr(&sos_hdr->header);\n\n\tswitch (sos_hdr->header.header_version_major) {\n\tcase 1:\n\t\terr = psp_init_sos_base_fw(adev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (sos_hdr->header.header_version_minor == 1) {\n\t\t\tsos_hdr_v1_1 = (const struct psp_firmware_header_v1_1 *)adev->psp.sos_fw->data;\n\t\t\tadev->psp.toc.size_bytes = le32_to_cpu(sos_hdr_v1_1->toc.size_bytes);\n\t\t\tadev->psp.toc.start_addr = (uint8_t *)adev->psp.sys.start_addr +\n\t\t\t\t\tle32_to_cpu(sos_hdr_v1_1->toc.offset_bytes);\n\t\t\tadev->psp.kdb.size_bytes = le32_to_cpu(sos_hdr_v1_1->kdb.size_bytes);\n\t\t\tadev->psp.kdb.start_addr = (uint8_t *)adev->psp.sys.start_addr +\n\t\t\t\t\tle32_to_cpu(sos_hdr_v1_1->kdb.offset_bytes);\n\t\t}\n\t\tif (sos_hdr->header.header_version_minor == 2) {\n\t\t\tsos_hdr_v1_2 = (const struct psp_firmware_header_v1_2 *)adev->psp.sos_fw->data;\n\t\t\tadev->psp.kdb.size_bytes = le32_to_cpu(sos_hdr_v1_2->kdb.size_bytes);\n\t\t\tadev->psp.kdb.start_addr = (uint8_t *)adev->psp.sys.start_addr +\n\t\t\t\t\t\t    le32_to_cpu(sos_hdr_v1_2->kdb.offset_bytes);\n\t\t}\n\t\tif (sos_hdr->header.header_version_minor == 3) {\n\t\t\tsos_hdr_v1_3 = (const struct psp_firmware_header_v1_3 *)adev->psp.sos_fw->data;\n\t\t\tadev->psp.toc.size_bytes = le32_to_cpu(sos_hdr_v1_3->v1_1.toc.size_bytes);\n\t\t\tadev->psp.toc.start_addr = ucode_array_start_addr +\n\t\t\t\tle32_to_cpu(sos_hdr_v1_3->v1_1.toc.offset_bytes);\n\t\t\tadev->psp.kdb.size_bytes = le32_to_cpu(sos_hdr_v1_3->v1_1.kdb.size_bytes);\n\t\t\tadev->psp.kdb.start_addr = ucode_array_start_addr +\n\t\t\t\tle32_to_cpu(sos_hdr_v1_3->v1_1.kdb.offset_bytes);\n\t\t\tadev->psp.spl.size_bytes = le32_to_cpu(sos_hdr_v1_3->spl.size_bytes);\n\t\t\tadev->psp.spl.start_addr = ucode_array_start_addr +\n\t\t\t\tle32_to_cpu(sos_hdr_v1_3->spl.offset_bytes);\n\t\t\tadev->psp.rl.size_bytes = le32_to_cpu(sos_hdr_v1_3->rl.size_bytes);\n\t\t\tadev->psp.rl.start_addr = ucode_array_start_addr +\n\t\t\t\tle32_to_cpu(sos_hdr_v1_3->rl.offset_bytes);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tsos_hdr_v2_0 = (const struct psp_firmware_header_v2_0 *)adev->psp.sos_fw->data;\n\n\t\tif (le32_to_cpu(sos_hdr_v2_0->psp_fw_bin_count) >= UCODE_MAX_PSP_PACKAGING) {\n\t\t\tdev_err(adev->dev, \"packed SOS count exceeds maximum limit\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (fw_index = 0; fw_index < le32_to_cpu(sos_hdr_v2_0->psp_fw_bin_count); fw_index++) {\n\t\t\terr = parse_sos_bin_descriptor(psp,\n\t\t\t\t\t\t       &sos_hdr_v2_0->psp_fw_bin[fw_index],\n\t\t\t\t\t\t       sos_hdr_v2_0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"unsupported psp sos firmware\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tamdgpu_ucode_release(&adev->psp.sos_fw);\n\n\treturn err;\n}\n\nstatic int parse_ta_bin_descriptor(struct psp_context *psp,\n\t\t\t\t   const struct psp_fw_bin_desc *desc,\n\t\t\t\t   const struct ta_firmware_header_v2_0 *ta_hdr)\n{\n\tuint8_t *ucode_start_addr  = NULL;\n\n\tif (!psp || !desc || !ta_hdr)\n\t\treturn -EINVAL;\n\n\tucode_start_addr  = (uint8_t *)ta_hdr +\n\t\t\t    le32_to_cpu(desc->offset_bytes) +\n\t\t\t    le32_to_cpu(ta_hdr->header.ucode_array_offset_bytes);\n\n\tswitch (desc->fw_type) {\n\tcase TA_FW_TYPE_PSP_ASD:\n\t\tpsp->asd_context.bin_desc.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->asd_context.bin_desc.feature_version   = le32_to_cpu(desc->fw_version);\n\t\tpsp->asd_context.bin_desc.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->asd_context.bin_desc.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_XGMI:\n\t\tpsp->xgmi_context.context.bin_desc.fw_version       = le32_to_cpu(desc->fw_version);\n\t\tpsp->xgmi_context.context.bin_desc.size_bytes       = le32_to_cpu(desc->size_bytes);\n\t\tpsp->xgmi_context.context.bin_desc.start_addr       = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_RAS:\n\t\tpsp->ras_context.context.bin_desc.fw_version        = le32_to_cpu(desc->fw_version);\n\t\tpsp->ras_context.context.bin_desc.size_bytes        = le32_to_cpu(desc->size_bytes);\n\t\tpsp->ras_context.context.bin_desc.start_addr        = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_HDCP:\n\t\tpsp->hdcp_context.context.bin_desc.fw_version       = le32_to_cpu(desc->fw_version);\n\t\tpsp->hdcp_context.context.bin_desc.size_bytes       = le32_to_cpu(desc->size_bytes);\n\t\tpsp->hdcp_context.context.bin_desc.start_addr       = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_DTM:\n\t\tpsp->dtm_context.context.bin_desc.fw_version       = le32_to_cpu(desc->fw_version);\n\t\tpsp->dtm_context.context.bin_desc.size_bytes       = le32_to_cpu(desc->size_bytes);\n\t\tpsp->dtm_context.context.bin_desc.start_addr       = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_RAP:\n\t\tpsp->rap_context.context.bin_desc.fw_version       = le32_to_cpu(desc->fw_version);\n\t\tpsp->rap_context.context.bin_desc.size_bytes       = le32_to_cpu(desc->size_bytes);\n\t\tpsp->rap_context.context.bin_desc.start_addr       = ucode_start_addr;\n\t\tbreak;\n\tcase TA_FW_TYPE_PSP_SECUREDISPLAY:\n\t\tpsp->securedisplay_context.context.bin_desc.fw_version =\n\t\t\tle32_to_cpu(desc->fw_version);\n\t\tpsp->securedisplay_context.context.bin_desc.size_bytes =\n\t\t\tle32_to_cpu(desc->size_bytes);\n\t\tpsp->securedisplay_context.context.bin_desc.start_addr =\n\t\t\tucode_start_addr;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(psp->adev->dev, \"Unsupported TA type: %d\\n\", desc->fw_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_ta_v1_microcode(struct psp_context *psp)\n{\n\tconst struct ta_firmware_header_v1_0 *ta_hdr;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tta_hdr = (const struct ta_firmware_header_v1_0 *) adev->psp.ta_fw->data;\n\n\tif (le16_to_cpu(ta_hdr->header.header_version_major) != 1)\n\t\treturn -EINVAL;\n\n\tadev->psp.xgmi_context.context.bin_desc.fw_version =\n\t\tle32_to_cpu(ta_hdr->xgmi.fw_version);\n\tadev->psp.xgmi_context.context.bin_desc.size_bytes =\n\t\tle32_to_cpu(ta_hdr->xgmi.size_bytes);\n\tadev->psp.xgmi_context.context.bin_desc.start_addr =\n\t\t(uint8_t *)ta_hdr +\n\t\tle32_to_cpu(ta_hdr->header.ucode_array_offset_bytes);\n\n\tadev->psp.ras_context.context.bin_desc.fw_version =\n\t\tle32_to_cpu(ta_hdr->ras.fw_version);\n\tadev->psp.ras_context.context.bin_desc.size_bytes =\n\t\tle32_to_cpu(ta_hdr->ras.size_bytes);\n\tadev->psp.ras_context.context.bin_desc.start_addr =\n\t\t(uint8_t *)adev->psp.xgmi_context.context.bin_desc.start_addr +\n\t\tle32_to_cpu(ta_hdr->ras.offset_bytes);\n\n\tadev->psp.hdcp_context.context.bin_desc.fw_version =\n\t\tle32_to_cpu(ta_hdr->hdcp.fw_version);\n\tadev->psp.hdcp_context.context.bin_desc.size_bytes =\n\t\tle32_to_cpu(ta_hdr->hdcp.size_bytes);\n\tadev->psp.hdcp_context.context.bin_desc.start_addr =\n\t\t(uint8_t *)ta_hdr +\n\t\tle32_to_cpu(ta_hdr->header.ucode_array_offset_bytes);\n\n\tadev->psp.dtm_context.context.bin_desc.fw_version =\n\t\tle32_to_cpu(ta_hdr->dtm.fw_version);\n\tadev->psp.dtm_context.context.bin_desc.size_bytes =\n\t\tle32_to_cpu(ta_hdr->dtm.size_bytes);\n\tadev->psp.dtm_context.context.bin_desc.start_addr =\n\t\t(uint8_t *)adev->psp.hdcp_context.context.bin_desc.start_addr +\n\t\tle32_to_cpu(ta_hdr->dtm.offset_bytes);\n\n\tadev->psp.securedisplay_context.context.bin_desc.fw_version =\n\t\tle32_to_cpu(ta_hdr->securedisplay.fw_version);\n\tadev->psp.securedisplay_context.context.bin_desc.size_bytes =\n\t\tle32_to_cpu(ta_hdr->securedisplay.size_bytes);\n\tadev->psp.securedisplay_context.context.bin_desc.start_addr =\n\t\t(uint8_t *)adev->psp.hdcp_context.context.bin_desc.start_addr +\n\t\tle32_to_cpu(ta_hdr->securedisplay.offset_bytes);\n\n\tadev->psp.ta_fw_version = le32_to_cpu(ta_hdr->header.ucode_version);\n\n\treturn 0;\n}\n\nstatic int parse_ta_v2_microcode(struct psp_context *psp)\n{\n\tconst struct ta_firmware_header_v2_0 *ta_hdr;\n\tstruct amdgpu_device *adev = psp->adev;\n\tint err = 0;\n\tint ta_index = 0;\n\n\tta_hdr = (const struct ta_firmware_header_v2_0 *)adev->psp.ta_fw->data;\n\n\tif (le16_to_cpu(ta_hdr->header.header_version_major) != 2)\n\t\treturn -EINVAL;\n\n\tif (le32_to_cpu(ta_hdr->ta_fw_bin_count) >= UCODE_MAX_PSP_PACKAGING) {\n\t\tdev_err(adev->dev, \"packed TA count exceeds maximum limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (ta_index = 0; ta_index < le32_to_cpu(ta_hdr->ta_fw_bin_count); ta_index++) {\n\t\terr = parse_ta_bin_descriptor(psp,\n\t\t\t\t\t      &ta_hdr->ta_fw_bin[ta_index],\n\t\t\t\t\t      ta_hdr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint psp_init_ta_microcode(struct psp_context *psp, const char *chip_name)\n{\n\tconst struct common_firmware_header *hdr;\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar fw_name[PSP_FW_NAME_LEN];\n\tint err;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ta.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->psp.ta_fw, fw_name);\n\tif (err)\n\t\treturn err;\n\n\thdr = (const struct common_firmware_header *)adev->psp.ta_fw->data;\n\tswitch (le16_to_cpu(hdr->header_version_major)) {\n\tcase 1:\n\t\terr = parse_ta_v1_microcode(psp);\n\t\tbreak;\n\tcase 2:\n\t\terr = parse_ta_v2_microcode(psp);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev, \"unsupported TA header version\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tif (err)\n\t\tamdgpu_ucode_release(&adev->psp.ta_fw);\n\n\treturn err;\n}\n\nint psp_init_cap_microcode(struct psp_context *psp, const char *chip_name)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar fw_name[PSP_FW_NAME_LEN];\n\tconst struct psp_firmware_header_v1_0 *cap_hdr_v1_0;\n\tstruct amdgpu_firmware_info *info = NULL;\n\tint err = 0;\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tdev_err(adev->dev, \"cap microcode should only be loaded under SRIOV\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_cap.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->psp.cap_fw, fw_name);\n\tif (err) {\n\t\tif (err == -ENODEV) {\n\t\t\tdev_warn(adev->dev, \"cap microcode does not exist, skip\\n\");\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tdev_err(adev->dev, \"fail to initialize cap microcode\\n\");\n\t}\n\n\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_CAP];\n\tinfo->ucode_id = AMDGPU_UCODE_ID_CAP;\n\tinfo->fw = adev->psp.cap_fw;\n\tcap_hdr_v1_0 = (const struct psp_firmware_header_v1_0 *)\n\t\tadev->psp.cap_fw->data;\n\tadev->firmware.fw_size += ALIGN(\n\t\t\tle32_to_cpu(cap_hdr_v1_0->header.ucode_size_bytes), PAGE_SIZE);\n\tadev->psp.cap_fw_version = le32_to_cpu(cap_hdr_v1_0->header.ucode_version);\n\tadev->psp.cap_feature_version = le32_to_cpu(cap_hdr_v1_0->sos.fw_version);\n\tadev->psp.cap_ucode_size = le32_to_cpu(cap_hdr_v1_0->header.ucode_size_bytes);\n\n\treturn 0;\n\nout:\n\tamdgpu_ucode_release(&adev->psp.cap_fw);\n\treturn err;\n}\n\nstatic int psp_set_clockgating_state(void *handle,\n\t\t\t\t     enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int psp_set_powergating_state(void *handle,\n\t\t\t\t     enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\nstatic ssize_t psp_usbc_pd_fw_sysfs_read(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tuint32_t fw_ver;\n\tint ret;\n\n\tif (!adev->ip_blocks[AMD_IP_BLOCK_TYPE_PSP].status.late_initialized) {\n\t\tDRM_INFO(\"PSP block is not ready yet.\");\n\t\treturn -EBUSY;\n\t}\n\n\tmutex_lock(&adev->psp.mutex);\n\tret = psp_read_usbc_pd_fw(&adev->psp, &fw_ver);\n\tmutex_unlock(&adev->psp.mutex);\n\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to read USBC PD FW, err = %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn sysfs_emit(buf, \"%x\\n\", fw_ver);\n}\n\nstatic ssize_t psp_usbc_pd_fw_sysfs_write(struct device *dev,\n\t\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t\t       const char *buf,\n\t\t\t\t\t\t       size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tint ret, idx;\n\tchar fw_name[100];\n\tconst struct firmware *usbc_pd_fw;\n\tstruct amdgpu_bo *fw_buf_bo = NULL;\n\tuint64_t fw_pri_mc_addr;\n\tvoid *fw_pri_cpu_addr;\n\n\tif (!adev->ip_blocks[AMD_IP_BLOCK_TYPE_PSP].status.late_initialized) {\n\t\tDRM_INFO(\"PSP block is not ready yet.\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!drm_dev_enter(ddev, &idx))\n\t\treturn -ENODEV;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s\", buf);\n\tret = request_firmware(&usbc_pd_fw, fw_name, adev->dev);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tret = amdgpu_bo_create_kernel(adev, usbc_pd_fw->size, 0x100000,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &fw_buf_bo, &fw_pri_mc_addr,\n\t\t\t\t      &fw_pri_cpu_addr);\n\tif (ret)\n\t\tgoto rel_buf;\n\n\tmemcpy_toio(fw_pri_cpu_addr, usbc_pd_fw->data, usbc_pd_fw->size);\n\n\tmutex_lock(&adev->psp.mutex);\n\tret = psp_load_usbc_pd_fw(&adev->psp, fw_pri_mc_addr);\n\tmutex_unlock(&adev->psp.mutex);\n\n\tamdgpu_bo_free_kernel(&fw_buf_bo, &fw_pri_mc_addr, &fw_pri_cpu_addr);\n\nrel_buf:\n\trelease_firmware(usbc_pd_fw);\nfail:\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to load USBC PD FW, err = %d\", ret);\n\t\tcount = ret;\n\t}\n\n\tdrm_dev_exit(idx);\n\treturn count;\n}\n\nvoid psp_copy_fw(struct psp_context *psp, uint8_t *start_addr, uint32_t bin_size)\n{\n\tint idx;\n\n\tif (!drm_dev_enter(adev_to_drm(psp->adev), &idx))\n\t\treturn;\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\tmemcpy(psp->fw_pri_buf, start_addr, bin_size);\n\n\tdrm_dev_exit(idx);\n}\n\n \nstatic DEVICE_ATTR(usbc_pd_fw, 0644,\n\t\t   psp_usbc_pd_fw_sysfs_read,\n\t\t   psp_usbc_pd_fw_sysfs_write);\n\nint is_psp_fw_valid(struct psp_bin_desc bin)\n{\n\treturn bin.size_bytes;\n}\n\nstatic ssize_t amdgpu_psp_vbflash_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\t\tchar *buffer, loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\tadev->psp.vbflash_done = false;\n\n\t \n\tif (adev->psp.vbflash_image_size > AMD_VBIOS_FILE_MAX_SIZE_B) {\n\t\tdev_err(adev->dev, \"File size cannot exceed %u\", AMD_VBIOS_FILE_MAX_SIZE_B);\n\t\tkvfree(adev->psp.vbflash_tmp_buf);\n\t\tadev->psp.vbflash_tmp_buf = NULL;\n\t\tadev->psp.vbflash_image_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!adev->psp.vbflash_tmp_buf) {\n\t\tadev->psp.vbflash_tmp_buf = kvmalloc(AMD_VBIOS_FILE_MAX_SIZE_B, GFP_KERNEL);\n\t\tif (!adev->psp.vbflash_tmp_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&adev->psp.mutex);\n\tmemcpy(adev->psp.vbflash_tmp_buf + pos, buffer, count);\n\tadev->psp.vbflash_image_size += count;\n\tmutex_unlock(&adev->psp.mutex);\n\n\tdev_dbg(adev->dev, \"IFWI staged for update\");\n\n\treturn count;\n}\n\nstatic ssize_t amdgpu_psp_vbflash_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t       struct bin_attribute *bin_attr, char *buffer,\n\t\t\t\t       loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tstruct amdgpu_bo *fw_buf_bo = NULL;\n\tuint64_t fw_pri_mc_addr;\n\tvoid *fw_pri_cpu_addr;\n\tint ret;\n\n\tif (adev->psp.vbflash_image_size == 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(adev->dev, \"PSP IFWI flash process initiated\");\n\n\tret = amdgpu_bo_create_kernel(adev, adev->psp.vbflash_image_size,\n\t\t\t\t\tAMDGPU_GPU_PAGE_SIZE,\n\t\t\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t\t&fw_buf_bo,\n\t\t\t\t\t&fw_pri_mc_addr,\n\t\t\t\t\t&fw_pri_cpu_addr);\n\tif (ret)\n\t\tgoto rel_buf;\n\n\tmemcpy_toio(fw_pri_cpu_addr, adev->psp.vbflash_tmp_buf, adev->psp.vbflash_image_size);\n\n\tmutex_lock(&adev->psp.mutex);\n\tret = psp_update_spirom(&adev->psp, fw_pri_mc_addr);\n\tmutex_unlock(&adev->psp.mutex);\n\n\tamdgpu_bo_free_kernel(&fw_buf_bo, &fw_pri_mc_addr, &fw_pri_cpu_addr);\n\nrel_buf:\n\tkvfree(adev->psp.vbflash_tmp_buf);\n\tadev->psp.vbflash_tmp_buf = NULL;\n\tadev->psp.vbflash_image_size = 0;\n\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to load IFWI, err = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(adev->dev, \"PSP IFWI flash process done\");\n\treturn 0;\n}\n\n \nstatic struct bin_attribute psp_vbflash_bin_attr = {\n\t.attr = {.name = \"psp_vbflash\", .mode = 0660},\n\t.size = 0,\n\t.write = amdgpu_psp_vbflash_write,\n\t.read = amdgpu_psp_vbflash_read,\n};\n\n \nstatic ssize_t amdgpu_psp_vbflash_status(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tuint32_t vbflash_status;\n\n\tvbflash_status = psp_vbflash_status(&adev->psp);\n\tif (!adev->psp.vbflash_done)\n\t\tvbflash_status = 0;\n\telse if (adev->psp.vbflash_done && !(vbflash_status & 0x80000000))\n\t\tvbflash_status = 1;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", vbflash_status);\n}\nstatic DEVICE_ATTR(psp_vbflash_status, 0440, amdgpu_psp_vbflash_status, NULL);\n\nstatic struct bin_attribute *bin_flash_attrs[] = {\n\t&psp_vbflash_bin_attr,\n\tNULL\n};\n\nstatic struct attribute *flash_attrs[] = {\n\t&dev_attr_psp_vbflash_status.attr,\n\t&dev_attr_usbc_pd_fw.attr,\n\tNULL\n};\n\nstatic umode_t amdgpu_flash_attr_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\tif (attr == &dev_attr_usbc_pd_fw.attr)\n\t\treturn adev->psp.sup_pd_fw_up ? 0660 : 0;\n\n\treturn adev->psp.sup_ifwi_up ? 0440 : 0;\n}\n\nstatic umode_t amdgpu_bin_flash_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\t\t\tint idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\treturn adev->psp.sup_ifwi_up ? 0660 : 0;\n}\n\nconst struct attribute_group amdgpu_flash_attr_group = {\n\t.attrs = flash_attrs,\n\t.bin_attrs = bin_flash_attrs,\n\t.is_bin_visible = amdgpu_bin_flash_attr_is_visible,\n\t.is_visible = amdgpu_flash_attr_is_visible,\n};\n\nconst struct amd_ip_funcs psp_ip_funcs = {\n\t.name = \"psp\",\n\t.early_init = psp_early_init,\n\t.late_init = NULL,\n\t.sw_init = psp_sw_init,\n\t.sw_fini = psp_sw_fini,\n\t.hw_init = psp_hw_init,\n\t.hw_fini = psp_hw_fini,\n\t.suspend = psp_suspend,\n\t.resume = psp_resume,\n\t.is_idle = NULL,\n\t.check_soft_reset = NULL,\n\t.wait_for_idle = NULL,\n\t.soft_reset = NULL,\n\t.set_clockgating_state = psp_set_clockgating_state,\n\t.set_powergating_state = psp_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version psp_v3_1_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 3,\n\t.minor = 1,\n\t.rev = 0,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v10_0_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 10,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v11_0_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 11,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v11_0_8_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 11,\n\t.minor = 0,\n\t.rev = 8,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v12_0_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 12,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v13_0_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 13,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &psp_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version psp_v13_0_4_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_PSP,\n\t.major = 13,\n\t.minor = 0,\n\t.rev = 4,\n\t.funcs = &psp_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}