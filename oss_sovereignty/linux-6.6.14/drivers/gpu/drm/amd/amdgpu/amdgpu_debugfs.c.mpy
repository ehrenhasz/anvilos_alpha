{
  "module_name": "amdgpu_debugfs.c",
  "hash_id": "a91e2b2323a940f0384236d9ee7d9ffeea4bdcf7354cc580277d6ef267ba2a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c",
  "human_readable_source": " \n\n#include <linux/kthread.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_pm.h\"\n#include \"amdgpu_dm_debugfs.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_rap.h\"\n#include \"amdgpu_securedisplay.h\"\n#include \"amdgpu_fw_attestation.h\"\n#include \"amdgpu_umr.h\"\n\n#include \"amdgpu_reset.h\"\n#include \"amdgpu_psp_ta.h\"\n\n#if defined(CONFIG_DEBUG_FS)\n\n \nstatic int  amdgpu_debugfs_process_reg_op(bool read, struct file *f,\n\t\tchar __user *buf, size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\tbool pm_pg_lock, use_bank, use_ring;\n\tunsigned int instance_bank, sh_bank, se_bank, me, pipe, queue, vmid;\n\n\tpm_pg_lock = use_bank = use_ring = false;\n\tinstance_bank = sh_bank = se_bank = me = pipe = queue = vmid = 0;\n\n\tif (size & 0x3 || *pos & 0x3 ||\n\t\t\t((*pos & (1ULL << 62)) && (*pos & (1ULL << 61))))\n\t\treturn -EINVAL;\n\n\t \n\tpm_pg_lock = (*pos >> 23) & 1;\n\n\tif (*pos & (1ULL << 62)) {\n\t\tse_bank = (*pos & GENMASK_ULL(33, 24)) >> 24;\n\t\tsh_bank = (*pos & GENMASK_ULL(43, 34)) >> 34;\n\t\tinstance_bank = (*pos & GENMASK_ULL(53, 44)) >> 44;\n\n\t\tif (se_bank == 0x3FF)\n\t\t\tse_bank = 0xFFFFFFFF;\n\t\tif (sh_bank == 0x3FF)\n\t\t\tsh_bank = 0xFFFFFFFF;\n\t\tif (instance_bank == 0x3FF)\n\t\t\tinstance_bank = 0xFFFFFFFF;\n\t\tuse_bank = true;\n\t} else if (*pos & (1ULL << 61)) {\n\n\t\tme = (*pos & GENMASK_ULL(33, 24)) >> 24;\n\t\tpipe = (*pos & GENMASK_ULL(43, 34)) >> 34;\n\t\tqueue = (*pos & GENMASK_ULL(53, 44)) >> 44;\n\t\tvmid = (*pos & GENMASK_ULL(58, 54)) >> 54;\n\n\t\tuse_ring = true;\n\t} else {\n\t\tuse_bank = use_ring = false;\n\t}\n\n\t*pos &= (1UL << 22) - 1;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tif (use_bank) {\n\t\tif ((sh_bank != 0xFFFFFFFF && sh_bank >= adev->gfx.config.max_sh_per_se) ||\n\t\t    (se_bank != 0xFFFFFFFF && se_bank >= adev->gfx.config.max_shader_engines)) {\n\t\t\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\t\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\tamdgpu_gfx_select_se_sh(adev, se_bank,\n\t\t\t\t\tsh_bank, instance_bank, 0);\n\t} else if (use_ring) {\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tamdgpu_gfx_select_me_pipe_q(adev, me, pipe, queue, vmid, 0);\n\t}\n\n\tif (pm_pg_lock)\n\t\tmutex_lock(&adev->pm.mutex);\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tif (read) {\n\t\t\tvalue = RREG32(*pos >> 2);\n\t\t\tr = put_user(value, (uint32_t *)buf);\n\t\t} else {\n\t\t\tr = get_user(value, (uint32_t *)buf);\n\t\t\tif (!r)\n\t\t\t\tamdgpu_mm_wreg_mmio_rlc(adev, *pos >> 2, value, 0);\n\t\t}\n\t\tif (r) {\n\t\t\tresult = r;\n\t\t\tgoto end;\n\t\t}\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\nend:\n\tif (use_bank) {\n\t\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\t} else if (use_ring) {\n\t\tamdgpu_gfx_select_me_pipe_q(adev, 0, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t}\n\n\tif (pm_pg_lock)\n\t\tmutex_unlock(&adev->pm.mutex);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn result;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\treturn amdgpu_debugfs_process_reg_op(true, f, buf, size, pos);\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_write(struct file *f, const char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\treturn amdgpu_debugfs_process_reg_op(false, f, (char __user *)buf, size, pos);\n}\n\nstatic int amdgpu_debugfs_regs2_open(struct inode *inode, struct file *file)\n{\n\tstruct amdgpu_debugfs_regs2_data *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\trd->adev = file_inode(file)->i_private;\n\tfile->private_data = rd;\n\tmutex_init(&rd->lock);\n\n\treturn 0;\n}\n\nstatic int amdgpu_debugfs_regs2_release(struct inode *inode, struct file *file)\n{\n\tstruct amdgpu_debugfs_regs2_data *rd = file->private_data;\n\n\tmutex_destroy(&rd->lock);\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t amdgpu_debugfs_regs2_op(struct file *f, char __user *buf, u32 offset, size_t size, int write_en)\n{\n\tstruct amdgpu_debugfs_regs2_data *rd = f->private_data;\n\tstruct amdgpu_device *adev = rd->adev;\n\tssize_t result = 0;\n\tint r;\n\tuint32_t value;\n\n\tif (size & 0x3 || offset & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tmutex_lock(&rd->lock);\n\n\tif (rd->id.use_grbm) {\n\t\tif ((rd->id.grbm.sh != 0xFFFFFFFF && rd->id.grbm.sh >= adev->gfx.config.max_sh_per_se) ||\n\t\t    (rd->id.grbm.se != 0xFFFFFFFF && rd->id.grbm.se >= adev->gfx.config.max_shader_engines)) {\n\t\t\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\t\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\t\tmutex_unlock(&rd->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\tamdgpu_gfx_select_se_sh(adev, rd->id.grbm.se,\n\t\t\t\t\t\t  rd->id.grbm.sh,\n\t\t\t\t\t\t  rd->id.grbm.instance, rd->id.xcc_id);\n\t}\n\n\tif (rd->id.use_srbm) {\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tamdgpu_gfx_select_me_pipe_q(adev, rd->id.srbm.me, rd->id.srbm.pipe,\n\t\t\t\t\t    rd->id.srbm.queue, rd->id.srbm.vmid, rd->id.xcc_id);\n\t}\n\n\tif (rd->id.pg_lock)\n\t\tmutex_lock(&adev->pm.mutex);\n\n\twhile (size) {\n\t\tif (!write_en) {\n\t\t\tvalue = RREG32(offset >> 2);\n\t\t\tr = put_user(value, (uint32_t *)buf);\n\t\t} else {\n\t\t\tr = get_user(value, (uint32_t *)buf);\n\t\t\tif (!r)\n\t\t\t\tamdgpu_mm_wreg_mmio_rlc(adev, offset >> 2, value, rd->id.xcc_id);\n\t\t}\n\t\tif (r) {\n\t\t\tresult = r;\n\t\t\tgoto end;\n\t\t}\n\t\toffset += 4;\n\t\tsize -= 4;\n\t\tresult += 4;\n\t\tbuf += 4;\n\t}\nend:\n\tif (rd->id.use_grbm) {\n\t\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, rd->id.xcc_id);\n\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\t}\n\n\tif (rd->id.use_srbm) {\n\t\tamdgpu_gfx_select_me_pipe_q(adev, 0, 0, 0, 0, rd->id.xcc_id);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t}\n\n\tif (rd->id.pg_lock)\n\t\tmutex_unlock(&adev->pm.mutex);\n\n\tmutex_unlock(&rd->lock);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn result;\n}\n\nstatic long amdgpu_debugfs_regs2_ioctl(struct file *f, unsigned int cmd, unsigned long data)\n{\n\tstruct amdgpu_debugfs_regs2_data *rd = f->private_data;\n\tstruct amdgpu_debugfs_regs2_iocdata v1_data;\n\tint r;\n\n\tmutex_lock(&rd->lock);\n\n\tswitch (cmd) {\n\tcase AMDGPU_DEBUGFS_REGS2_IOC_SET_STATE_V2:\n\t\tr = copy_from_user(&rd->id, (struct amdgpu_debugfs_regs2_iocdata_v2 *)data,\n\t\t\t\t   sizeof(rd->id));\n\t\tif (r)\n\t\t\tr = -EINVAL;\n\t\tgoto done;\n\tcase AMDGPU_DEBUGFS_REGS2_IOC_SET_STATE:\n\t\tr = copy_from_user(&v1_data, (struct amdgpu_debugfs_regs2_iocdata *)data,\n\t\t\t\t   sizeof(v1_data));\n\t\tif (r) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tgoto v1_copy;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto done;\n\t}\n\nv1_copy:\n\trd->id.use_srbm = v1_data.use_srbm;\n\trd->id.use_grbm = v1_data.use_grbm;\n\trd->id.pg_lock = v1_data.pg_lock;\n\trd->id.grbm.se = v1_data.grbm.se;\n\trd->id.grbm.sh = v1_data.grbm.sh;\n\trd->id.grbm.instance = v1_data.grbm.instance;\n\trd->id.srbm.me = v1_data.srbm.me;\n\trd->id.srbm.pipe = v1_data.srbm.pipe;\n\trd->id.srbm.queue = v1_data.srbm.queue;\n\trd->id.xcc_id = 0;\ndone:\n\tmutex_unlock(&rd->lock);\n\treturn r;\n}\n\nstatic ssize_t amdgpu_debugfs_regs2_read(struct file *f, char __user *buf, size_t size, loff_t *pos)\n{\n\treturn amdgpu_debugfs_regs2_op(f, buf, *pos, size, 0);\n}\n\nstatic ssize_t amdgpu_debugfs_regs2_write(struct file *f, const char __user *buf, size_t size, loff_t *pos)\n{\n\treturn amdgpu_debugfs_regs2_op(f, (char __user *)buf, *pos, size, 1);\n}\n\nstatic int amdgpu_debugfs_gprwave_open(struct inode *inode, struct file *file)\n{\n\tstruct amdgpu_debugfs_gprwave_data *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\trd->adev = file_inode(file)->i_private;\n\tfile->private_data = rd;\n\tmutex_init(&rd->lock);\n\n\treturn 0;\n}\n\nstatic int amdgpu_debugfs_gprwave_release(struct inode *inode, struct file *file)\n{\n\tstruct amdgpu_debugfs_gprwave_data *rd = file->private_data;\n\n\tmutex_destroy(&rd->lock);\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t amdgpu_debugfs_gprwave_read(struct file *f, char __user *buf, size_t size, loff_t *pos)\n{\n\tstruct amdgpu_debugfs_gprwave_data *rd = f->private_data;\n\tstruct amdgpu_device *adev = rd->adev;\n\tssize_t result = 0;\n\tint r;\n\tuint32_t *data, x;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tdata = kcalloc(1024, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmutex_lock(&adev->grbm_idx_mutex);\n\tamdgpu_gfx_select_se_sh(adev, rd->id.se, rd->id.sh, rd->id.cu, rd->id.xcc_id);\n\n\tif (!rd->id.gpr_or_wave) {\n\t\tx = 0;\n\t\tif (adev->gfx.funcs->read_wave_data)\n\t\t\tadev->gfx.funcs->read_wave_data(adev, rd->id.xcc_id, rd->id.simd, rd->id.wave, data, &x);\n\t} else {\n\t\tx = size >> 2;\n\t\tif (rd->id.gpr.vpgr_or_sgpr) {\n\t\t\tif (adev->gfx.funcs->read_wave_vgprs)\n\t\t\t\tadev->gfx.funcs->read_wave_vgprs(adev, rd->id.xcc_id, rd->id.simd, rd->id.wave, rd->id.gpr.thread, *pos, size>>2, data);\n\t\t} else {\n\t\t\tif (adev->gfx.funcs->read_wave_sgprs)\n\t\t\t\tadev->gfx.funcs->read_wave_sgprs(adev, rd->id.xcc_id, rd->id.simd, rd->id.wave, *pos, size>>2, data);\n\t\t}\n\t}\n\n\tamdgpu_gfx_select_se_sh(adev, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, rd->id.xcc_id);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\tif (!x) {\n\t\tresult = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twhile (size && (*pos < x * 4)) {\n\t\tuint32_t value;\n\n\t\tvalue = data[*pos >> 2];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r) {\n\t\t\tresult = r;\n\t\t\tgoto done;\n\t\t}\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\ndone:\n\tamdgpu_virt_disable_access_debugfs(adev);\n\tkfree(data);\n\treturn result;\n}\n\nstatic long amdgpu_debugfs_gprwave_ioctl(struct file *f, unsigned int cmd, unsigned long data)\n{\n\tstruct amdgpu_debugfs_gprwave_data *rd = f->private_data;\n\tint r = 0;\n\n\tmutex_lock(&rd->lock);\n\n\tswitch (cmd) {\n\tcase AMDGPU_DEBUGFS_GPRWAVE_IOC_SET_STATE:\n\t\tif (copy_from_user(&rd->id,\n\t\t\t\t   (struct amdgpu_debugfs_gprwave_iocdata *)data,\n\t\t\t\t   sizeof(rd->id)))\n\t\t\tr = -EFAULT;\n\t\tgoto done;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto done;\n\t}\n\ndone:\n\tmutex_unlock(&rd->lock);\n\treturn r;\n}\n\n\n\n\n \nstatic ssize_t amdgpu_debugfs_regs_pcie_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tvalue = RREG32_PCIE(*pos);\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_pcie_write(struct file *f, const char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tr = get_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tWREG32_PCIE(*pos, value);\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_didt_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tif (!adev->didt_rreg)\n\t\treturn -EOPNOTSUPP;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tvalue = RREG32_DIDT(*pos >> 2);\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_didt_write(struct file *f, const char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tif (!adev->didt_wreg)\n\t\treturn -EOPNOTSUPP;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tr = get_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tWREG32_DIDT(*pos >> 2, value);\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_smc_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (!adev->smc_rreg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tvalue = RREG32_SMC(*pos);\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_regs_smc_write(struct file *f, const char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (!adev->smc_wreg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tr = get_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tWREG32_SMC(*pos, value);\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn r;\n}\n\n \n\nstatic ssize_t amdgpu_debugfs_gca_config_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\tuint32_t *config, no_regs = 0;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tconfig = kmalloc_array(256, sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\t \n\tconfig[no_regs++] = 5;\n\tconfig[no_regs++] = adev->gfx.config.max_shader_engines;\n\tconfig[no_regs++] = adev->gfx.config.max_tile_pipes;\n\tconfig[no_regs++] = adev->gfx.config.max_cu_per_sh;\n\tconfig[no_regs++] = adev->gfx.config.max_sh_per_se;\n\tconfig[no_regs++] = adev->gfx.config.max_backends_per_se;\n\tconfig[no_regs++] = adev->gfx.config.max_texture_channel_caches;\n\tconfig[no_regs++] = adev->gfx.config.max_gprs;\n\tconfig[no_regs++] = adev->gfx.config.max_gs_threads;\n\tconfig[no_regs++] = adev->gfx.config.max_hw_contexts;\n\tconfig[no_regs++] = adev->gfx.config.sc_prim_fifo_size_frontend;\n\tconfig[no_regs++] = adev->gfx.config.sc_prim_fifo_size_backend;\n\tconfig[no_regs++] = adev->gfx.config.sc_hiz_tile_fifo_size;\n\tconfig[no_regs++] = adev->gfx.config.sc_earlyz_tile_fifo_size;\n\tconfig[no_regs++] = adev->gfx.config.num_tile_pipes;\n\tconfig[no_regs++] = adev->gfx.config.backend_enable_mask;\n\tconfig[no_regs++] = adev->gfx.config.mem_max_burst_length_bytes;\n\tconfig[no_regs++] = adev->gfx.config.mem_row_size_in_kb;\n\tconfig[no_regs++] = adev->gfx.config.shader_engine_tile_size;\n\tconfig[no_regs++] = adev->gfx.config.num_gpus;\n\tconfig[no_regs++] = adev->gfx.config.multi_gpu_tile_size;\n\tconfig[no_regs++] = adev->gfx.config.mc_arb_ramcfg;\n\tconfig[no_regs++] = adev->gfx.config.gb_addr_config;\n\tconfig[no_regs++] = adev->gfx.config.num_rbs;\n\n\t \n\tconfig[no_regs++] = adev->rev_id;\n\tconfig[no_regs++] = lower_32_bits(adev->pg_flags);\n\tconfig[no_regs++] = lower_32_bits(adev->cg_flags);\n\n\t \n\tconfig[no_regs++] = adev->family;\n\tconfig[no_regs++] = adev->external_rev_id;\n\n\t \n\tconfig[no_regs++] = adev->pdev->device;\n\tconfig[no_regs++] = adev->pdev->revision;\n\tconfig[no_regs++] = adev->pdev->subsystem_device;\n\tconfig[no_regs++] = adev->pdev->subsystem_vendor;\n\n\t \n\tconfig[no_regs++] = adev->flags & AMD_IS_APU ? 1 : 0;\n\n\t \n\tconfig[no_regs++] = upper_32_bits(adev->pg_flags);\n\tconfig[no_regs++] = upper_32_bits(adev->cg_flags);\n\n\twhile (size && (*pos < no_regs * 4)) {\n\t\tuint32_t value;\n\n\t\tvalue = config[*pos >> 2];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r) {\n\t\t\tkfree(config);\n\t\t\treturn r;\n\t\t}\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tkfree(config);\n\treturn result;\n}\n\n \nstatic ssize_t amdgpu_debugfs_sensor_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tint idx, x, outsize, r, valuesize;\n\tuint32_t values[16];\n\n\tif (size & 3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EINVAL;\n\n\t \n\tidx = *pos >> 2;\n\n\tvaluesize = sizeof(values);\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_dpm_read_sensor(adev, idx, &values[0], &valuesize);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\tif (r) {\n\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\treturn r;\n\t}\n\n\tif (size > valuesize) {\n\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\treturn -EINVAL;\n\t}\n\n\toutsize = 0;\n\tx = 0;\n\tif (!r) {\n\t\twhile (size) {\n\t\t\tr = put_user(values[x++], (int32_t *)buf);\n\t\t\tbuf += 4;\n\t\t\tsize -= 4;\n\t\t\toutsize += 4;\n\t\t}\n\t}\n\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn !r ? outsize : r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_wave_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = f->f_inode->i_private;\n\tint r, x;\n\tssize_t result = 0;\n\tuint32_t offset, se, sh, cu, wave, simd, data[32];\n\n\tif (size & 3 || *pos & 3)\n\t\treturn -EINVAL;\n\n\t \n\toffset = (*pos & GENMASK_ULL(6, 0));\n\tse = (*pos & GENMASK_ULL(14, 7)) >> 7;\n\tsh = (*pos & GENMASK_ULL(22, 15)) >> 15;\n\tcu = (*pos & GENMASK_ULL(30, 23)) >> 23;\n\twave = (*pos & GENMASK_ULL(36, 31)) >> 31;\n\tsimd = (*pos & GENMASK_ULL(44, 37)) >> 37;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\t \n\tmutex_lock(&adev->grbm_idx_mutex);\n\tamdgpu_gfx_select_se_sh(adev, se, sh, cu, 0);\n\n\tx = 0;\n\tif (adev->gfx.funcs->read_wave_data)\n\t\tadev->gfx.funcs->read_wave_data(adev, 0, simd, wave, data, &x);\n\n\tamdgpu_gfx_select_se_sh(adev, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\tif (!x) {\n\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (size && (offset < x * 4)) {\n\t\tuint32_t value;\n\n\t\tvalue = data[offset >> 2];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r) {\n\t\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\t\treturn r;\n\t\t}\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\toffset += 4;\n\t\tsize -= 4;\n\t}\n\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn result;\n}\n\n \nstatic ssize_t amdgpu_debugfs_gpr_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = f->f_inode->i_private;\n\tint r;\n\tssize_t result = 0;\n\tuint32_t offset, se, sh, cu, wave, simd, thread, bank, *data;\n\n\tif (size > 4096 || size & 3 || *pos & 3)\n\t\treturn -EINVAL;\n\n\t \n\toffset = (*pos & GENMASK_ULL(11, 0)) >> 2;\n\tse = (*pos & GENMASK_ULL(19, 12)) >> 12;\n\tsh = (*pos & GENMASK_ULL(27, 20)) >> 20;\n\tcu = (*pos & GENMASK_ULL(35, 28)) >> 28;\n\twave = (*pos & GENMASK_ULL(43, 36)) >> 36;\n\tsimd = (*pos & GENMASK_ULL(51, 44)) >> 44;\n\tthread = (*pos & GENMASK_ULL(59, 52)) >> 52;\n\tbank = (*pos & GENMASK_ULL(61, 60)) >> 60;\n\n\tdata = kcalloc(1024, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0)\n\t\tgoto err;\n\n\tr = amdgpu_virt_enable_access_debugfs(adev);\n\tif (r < 0)\n\t\tgoto err;\n\n\t \n\tmutex_lock(&adev->grbm_idx_mutex);\n\tamdgpu_gfx_select_se_sh(adev, se, sh, cu, 0);\n\n\tif (bank == 0) {\n\t\tif (adev->gfx.funcs->read_wave_vgprs)\n\t\t\tadev->gfx.funcs->read_wave_vgprs(adev, 0, simd, wave, thread, offset, size>>2, data);\n\t} else {\n\t\tif (adev->gfx.funcs->read_wave_sgprs)\n\t\t\tadev->gfx.funcs->read_wave_sgprs(adev, 0, simd, wave, offset, size>>2, data);\n\t}\n\n\tamdgpu_gfx_select_se_sh(adev, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tvalue = data[result >> 2];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r) {\n\t\t\tamdgpu_virt_disable_access_debugfs(adev);\n\t\t\tgoto err;\n\t\t}\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\tsize -= 4;\n\t}\n\n\tkfree(data);\n\tamdgpu_virt_disable_access_debugfs(adev);\n\treturn result;\n\nerr:\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\tkfree(data);\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_gfxoff_residency_read(struct file *f, char __user *buf,\n\t\t\t\t\t\t    size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tr = amdgpu_get_gfx_off_residency(adev, &value);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_gfxoff_residency_write(struct file *f, const char __user *buf,\n\t\t\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tu32 value;\n\n\t\tr = get_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tamdgpu_set_gfx_off_residency(adev, value ? true : false);\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\n\n \nstatic ssize_t amdgpu_debugfs_gfxoff_count_read(struct file *f, char __user *buf,\n\t\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tu64 value = 0;\n\n\t\tr = amdgpu_get_gfx_off_entrycount(adev, &value);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = put_user(value, (u64 *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\n \nstatic ssize_t amdgpu_debugfs_gfxoff_write(struct file *f, const char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tuint32_t value;\n\n\t\tr = get_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tamdgpu_gfx_off_ctrl(adev, value ? true : false);\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\n\n \nstatic ssize_t amdgpu_debugfs_gfxoff_read(struct file *f, char __user *buf,\n\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tu32 value = adev->gfx.gfx_off_state;\n\n\t\tr = put_user(value, (u32 *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\nstatic ssize_t amdgpu_debugfs_gfxoff_status_read(struct file *f, char __user *buf,\n\t\t\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tssize_t result = 0;\n\tint r;\n\n\tif (size & 0x3 || *pos & 0x3)\n\t\treturn -EINVAL;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tu32 value;\n\n\t\tr = amdgpu_get_gfx_off_status(adev, &value);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = put_user(value, (u32 *)buf);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tresult += 4;\n\t\tbuf += 4;\n\t\t*pos += 4;\n\t\tsize -= 4;\n\t}\n\n\tr = result;\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn r;\n}\n\nstatic const struct file_operations amdgpu_debugfs_regs2_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = amdgpu_debugfs_regs2_ioctl,\n\t.read = amdgpu_debugfs_regs2_read,\n\t.write = amdgpu_debugfs_regs2_write,\n\t.open = amdgpu_debugfs_regs2_open,\n\t.release = amdgpu_debugfs_regs2_release,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gprwave_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = amdgpu_debugfs_gprwave_ioctl,\n\t.read = amdgpu_debugfs_gprwave_read,\n\t.open = amdgpu_debugfs_gprwave_open,\n\t.release = amdgpu_debugfs_gprwave_release,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_regs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_regs_read,\n\t.write = amdgpu_debugfs_regs_write,\n\t.llseek = default_llseek\n};\nstatic const struct file_operations amdgpu_debugfs_regs_didt_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_regs_didt_read,\n\t.write = amdgpu_debugfs_regs_didt_write,\n\t.llseek = default_llseek\n};\nstatic const struct file_operations amdgpu_debugfs_regs_pcie_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_regs_pcie_read,\n\t.write = amdgpu_debugfs_regs_pcie_write,\n\t.llseek = default_llseek\n};\nstatic const struct file_operations amdgpu_debugfs_regs_smc_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_regs_smc_read,\n\t.write = amdgpu_debugfs_regs_smc_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gca_config_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gca_config_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_sensors_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_sensor_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_wave_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_wave_read,\n\t.llseek = default_llseek\n};\nstatic const struct file_operations amdgpu_debugfs_gpr_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gpr_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gfxoff_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gfxoff_read,\n\t.write = amdgpu_debugfs_gfxoff_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gfxoff_status_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gfxoff_status_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gfxoff_count_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gfxoff_count_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations amdgpu_debugfs_gfxoff_residency_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_gfxoff_residency_read,\n\t.write = amdgpu_debugfs_gfxoff_residency_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations *debugfs_regs[] = {\n\t&amdgpu_debugfs_regs_fops,\n\t&amdgpu_debugfs_regs2_fops,\n\t&amdgpu_debugfs_gprwave_fops,\n\t&amdgpu_debugfs_regs_didt_fops,\n\t&amdgpu_debugfs_regs_pcie_fops,\n\t&amdgpu_debugfs_regs_smc_fops,\n\t&amdgpu_debugfs_gca_config_fops,\n\t&amdgpu_debugfs_sensors_fops,\n\t&amdgpu_debugfs_wave_fops,\n\t&amdgpu_debugfs_gpr_fops,\n\t&amdgpu_debugfs_gfxoff_fops,\n\t&amdgpu_debugfs_gfxoff_status_fops,\n\t&amdgpu_debugfs_gfxoff_count_fops,\n\t&amdgpu_debugfs_gfxoff_residency_fops,\n};\n\nstatic const char * const debugfs_regs_names[] = {\n\t\"amdgpu_regs\",\n\t\"amdgpu_regs2\",\n\t\"amdgpu_gprwave\",\n\t\"amdgpu_regs_didt\",\n\t\"amdgpu_regs_pcie\",\n\t\"amdgpu_regs_smc\",\n\t\"amdgpu_gca_config\",\n\t\"amdgpu_sensors\",\n\t\"amdgpu_wave\",\n\t\"amdgpu_gpr\",\n\t\"amdgpu_gfxoff\",\n\t\"amdgpu_gfxoff_status\",\n\t\"amdgpu_gfxoff_count\",\n\t\"amdgpu_gfxoff_residency\",\n};\n\n \nint amdgpu_debugfs_regs_init(struct amdgpu_device *adev)\n{\n\tstruct drm_minor *minor = adev_to_drm(adev)->primary;\n\tstruct dentry *ent, *root = minor->debugfs_root;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(debugfs_regs); i++) {\n\t\tent = debugfs_create_file(debugfs_regs_names[i],\n\t\t\t\t\t  S_IFREG | 0444, root,\n\t\t\t\t\t  adev, debugfs_regs[i]);\n\t\tif (!i && !IS_ERR_OR_NULL(ent))\n\t\t\ti_size_write(ent->d_inode, adev->rmmio_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_debugfs_test_ib_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_device *adev = m->private;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tint r = 0, i;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn r;\n\t}\n\n\t \n\tr = down_write_killable(&adev->reset_domain->sem);\n\tif (r)\n\t\treturn r;\n\n\t \n\tfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\n\t\tstruct amdgpu_ring *ring = adev->rings[i];\n\n\t\tif (!ring || !ring->sched.thread)\n\t\t\tcontinue;\n\t\tkthread_park(ring->sched.thread);\n\t}\n\n\tseq_puts(m, \"run ib test:\\n\");\n\tr = amdgpu_ib_ring_tests(adev);\n\tif (r)\n\t\tseq_printf(m, \"ib ring tests failed (%d).\\n\", r);\n\telse\n\t\tseq_puts(m, \"ib ring tests passed.\\n\");\n\n\t \n\tfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\n\t\tstruct amdgpu_ring *ring = adev->rings[i];\n\n\t\tif (!ring || !ring->sched.thread)\n\t\t\tcontinue;\n\t\tkthread_unpark(ring->sched.thread);\n\t}\n\n\tup_write(&adev->reset_domain->sem);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn 0;\n}\n\nstatic int amdgpu_debugfs_evict_vram(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)data;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tint r;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn r;\n\t}\n\n\t*val = amdgpu_ttm_evict_resources(adev, TTM_PL_VRAM);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn 0;\n}\n\n\nstatic int amdgpu_debugfs_evict_gtt(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)data;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tint r;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn r;\n\t}\n\n\t*val = amdgpu_ttm_evict_resources(adev, TTM_PL_TT);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn 0;\n}\n\nstatic int amdgpu_debugfs_benchmark(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)data;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tint r;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_benchmark(adev, val);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn r;\n}\n\nstatic int amdgpu_debugfs_vm_info_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_device *adev = m->private;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_file *file;\n\tint r;\n\n\tr = mutex_lock_interruptible(&dev->filelist_mutex);\n\tif (r)\n\t\treturn r;\n\n\tlist_for_each_entry(file, &dev->filelist, lhead) {\n\t\tstruct amdgpu_fpriv *fpriv = file->driver_priv;\n\t\tstruct amdgpu_vm *vm = &fpriv->vm;\n\n\t\tseq_printf(m, \"pid:%d\\tProcess:%s ----------\\n\",\n\t\t\t\tvm->task_info.pid, vm->task_info.process_name);\n\t\tr = amdgpu_bo_reserve(vm->root.bo, true);\n\t\tif (r)\n\t\t\tbreak;\n\t\tamdgpu_debugfs_vm_bo_info(vm, m);\n\t\tamdgpu_bo_unreserve(vm->root.bo);\n\t}\n\n\tmutex_unlock(&dev->filelist_mutex);\n\n\treturn r;\n}\n\nDEFINE_SHOW_ATTRIBUTE(amdgpu_debugfs_test_ib);\nDEFINE_SHOW_ATTRIBUTE(amdgpu_debugfs_vm_info);\nDEFINE_DEBUGFS_ATTRIBUTE(amdgpu_evict_vram_fops, amdgpu_debugfs_evict_vram,\n\t\t\t NULL, \"%lld\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(amdgpu_evict_gtt_fops, amdgpu_debugfs_evict_gtt,\n\t\t\t NULL, \"%lld\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(amdgpu_benchmark_fops, NULL, amdgpu_debugfs_benchmark,\n\t\t\t \"%lld\\n\");\n\nstatic void amdgpu_ib_preempt_fences_swap(struct amdgpu_ring *ring,\n\t\t\t\t\t  struct dma_fence **fences)\n{\n\tstruct amdgpu_fence_driver *drv = &ring->fence_drv;\n\tuint32_t sync_seq, last_seq;\n\n\tlast_seq = atomic_read(&ring->fence_drv.last_seq);\n\tsync_seq = ring->fence_drv.sync_seq;\n\n\tlast_seq &= drv->num_fences_mask;\n\tsync_seq &= drv->num_fences_mask;\n\n\tdo {\n\t\tstruct dma_fence *fence, **ptr;\n\n\t\t++last_seq;\n\t\tlast_seq &= drv->num_fences_mask;\n\t\tptr = &drv->fences[last_seq];\n\n\t\tfence = rcu_dereference_protected(*ptr, 1);\n\t\tRCU_INIT_POINTER(*ptr, NULL);\n\n\t\tif (!fence)\n\t\t\tcontinue;\n\n\t\tfences[last_seq] = fence;\n\n\t} while (last_seq != sync_seq);\n}\n\nstatic void amdgpu_ib_preempt_signal_fences(struct dma_fence **fences,\n\t\t\t\t\t    int length)\n{\n\tint i;\n\tstruct dma_fence *fence;\n\n\tfor (i = 0; i < length; i++) {\n\t\tfence = fences[i];\n\t\tif (!fence)\n\t\t\tcontinue;\n\t\tdma_fence_signal(fence);\n\t\tdma_fence_put(fence);\n\t}\n}\n\nstatic void amdgpu_ib_preempt_job_recovery(struct drm_gpu_scheduler *sched)\n{\n\tstruct drm_sched_job *s_job;\n\tstruct dma_fence *fence;\n\n\tspin_lock(&sched->job_list_lock);\n\tlist_for_each_entry(s_job, &sched->pending_list, list) {\n\t\tfence = sched->ops->run_job(s_job);\n\t\tdma_fence_put(fence);\n\t}\n\tspin_unlock(&sched->job_list_lock);\n}\n\nstatic void amdgpu_ib_preempt_mark_partial_job(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_job *job;\n\tstruct drm_sched_job *s_job, *tmp;\n\tuint32_t preempt_seq;\n\tstruct dma_fence *fence, **ptr;\n\tstruct amdgpu_fence_driver *drv = &ring->fence_drv;\n\tstruct drm_gpu_scheduler *sched = &ring->sched;\n\tbool preempted = true;\n\n\tif (ring->funcs->type != AMDGPU_RING_TYPE_GFX)\n\t\treturn;\n\n\tpreempt_seq = le32_to_cpu(*(drv->cpu_addr + 2));\n\tif (preempt_seq <= atomic_read(&drv->last_seq)) {\n\t\tpreempted = false;\n\t\tgoto no_preempt;\n\t}\n\n\tpreempt_seq &= drv->num_fences_mask;\n\tptr = &drv->fences[preempt_seq];\n\tfence = rcu_dereference_protected(*ptr, 1);\n\nno_preempt:\n\tspin_lock(&sched->job_list_lock);\n\tlist_for_each_entry_safe(s_job, tmp, &sched->pending_list, list) {\n\t\tif (dma_fence_is_signaled(&s_job->s_fence->finished)) {\n\t\t\t \n\t\t\tlist_del_init(&s_job->list);\n\t\t\tsched->ops->free_job(s_job);\n\t\t\tcontinue;\n\t\t}\n\t\tjob = to_amdgpu_job(s_job);\n\t\tif (preempted && (&job->hw_fence) == fence)\n\t\t\t \n\t\t\tjob->preemption_status |= AMDGPU_IB_PREEMPTED;\n\t}\n\tspin_unlock(&sched->job_list_lock);\n}\n\nstatic int amdgpu_debugfs_ib_preempt(void *data, u64 val)\n{\n\tint r, length;\n\tstruct amdgpu_ring *ring;\n\tstruct dma_fence **fences = NULL;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)data;\n\n\tif (val >= AMDGPU_MAX_RINGS)\n\t\treturn -EINVAL;\n\n\tring = adev->rings[val];\n\n\tif (!ring || !ring->funcs->preempt_ib || !ring->sched.thread)\n\t\treturn -EINVAL;\n\n\t \n\tif (ring->trail_seq != le32_to_cpu(*ring->trail_fence_cpu_addr))\n\t\treturn -EBUSY;\n\n\tlength = ring->fence_drv.num_fences_mask + 1;\n\tfences = kcalloc(length, sizeof(void *), GFP_KERNEL);\n\tif (!fences)\n\t\treturn -ENOMEM;\n\n\t \n\tr = down_read_killable(&adev->reset_domain->sem);\n\tif (r)\n\t\tgoto pro_end;\n\n\t \n\tkthread_park(ring->sched.thread);\n\n\t \n\tr = amdgpu_ring_preempt_ib(ring);\n\tif (r) {\n\t\tDRM_WARN(\"failed to preempt ring %d\\n\", ring->idx);\n\t\tgoto failure;\n\t}\n\n\tamdgpu_fence_process(ring);\n\n\tif (atomic_read(&ring->fence_drv.last_seq) !=\n\t    ring->fence_drv.sync_seq) {\n\t\tDRM_INFO(\"ring %d was preempted\\n\", ring->idx);\n\n\t\tamdgpu_ib_preempt_mark_partial_job(ring);\n\n\t\t \n\t\tamdgpu_ib_preempt_fences_swap(ring, fences);\n\n\t\tamdgpu_fence_driver_force_completion(ring);\n\n\t\t \n\t\tamdgpu_ib_preempt_job_recovery(&ring->sched);\n\n\t\t \n\t\tamdgpu_fence_wait_empty(ring);\n\n\t\t \n\t\tamdgpu_ib_preempt_signal_fences(fences, length);\n\t}\n\nfailure:\n\t \n\tkthread_unpark(ring->sched.thread);\n\n\tup_read(&adev->reset_domain->sem);\n\npro_end:\n\tkfree(fences);\n\n\treturn r;\n}\n\nstatic int amdgpu_debugfs_sclk_set(void *data, u64 val)\n{\n\tint ret = 0;\n\tuint32_t max_freq, min_freq;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)data;\n\n\tif (amdgpu_sriov_vf(adev) && !amdgpu_sriov_is_pp_one_vf(adev))\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\treturn ret;\n\t}\n\n\tret = amdgpu_dpm_get_dpm_freq_range(adev, PP_SCLK, &min_freq, &max_freq);\n\tif (ret == -EOPNOTSUPP) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret || val > max_freq || val < min_freq) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = amdgpu_dpm_set_soft_freq_range(adev, PP_SCLK, (uint32_t)val, (uint32_t)val);\n\tif (ret)\n\t\tret = -EINVAL;\n\nout:\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_ib_preempt, NULL,\n\t\t\tamdgpu_debugfs_ib_preempt, \"%llu\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_sclk_set, NULL,\n\t\t\tamdgpu_debugfs_sclk_set, \"%llu\\n\");\n\nstatic ssize_t amdgpu_reset_dump_register_list_read(struct file *f,\n\t\t\t\tchar __user *buf, size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tchar reg_offset[12];\n\tint i, ret, len = 0;\n\n\tif (*pos)\n\t\treturn 0;\n\n\tmemset(reg_offset, 0, 12);\n\tret = down_read_killable(&adev->reset_domain->sem);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < adev->num_regs; i++) {\n\t\tsprintf(reg_offset, \"0x%x\\n\", adev->reset_dump_reg_list[i]);\n\t\tup_read(&adev->reset_domain->sem);\n\t\tif (copy_to_user(buf + len, reg_offset, strlen(reg_offset)))\n\t\t\treturn -EFAULT;\n\n\t\tlen += strlen(reg_offset);\n\t\tret = down_read_killable(&adev->reset_domain->sem);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tup_read(&adev->reset_domain->sem);\n\t*pos += len;\n\n\treturn len;\n}\n\nstatic ssize_t amdgpu_reset_dump_register_list_write(struct file *f,\n\t\t\tconst char __user *buf, size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tchar reg_offset[11];\n\tuint32_t *new = NULL, *tmp = NULL;\n\tint ret, i = 0, len = 0;\n\n\tdo {\n\t\tmemset(reg_offset, 0, 11);\n\t\tif (copy_from_user(reg_offset, buf + len,\n\t\t\t\t\tmin(10, ((int)size-len)))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tnew = krealloc_array(tmp, i + 1, sizeof(uint32_t), GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_free;\n\t\t}\n\t\ttmp = new;\n\t\tif (sscanf(reg_offset, \"%X %n\", &tmp[i], &ret) != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tlen += ret;\n\t\ti++;\n\t} while (len < size);\n\n\tnew = kmalloc_array(i, sizeof(uint32_t), GFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\tret = down_write_killable(&adev->reset_domain->sem);\n\tif (ret)\n\t\tgoto error_free;\n\n\tswap(adev->reset_dump_reg_list, tmp);\n\tswap(adev->reset_dump_reg_value, new);\n\tadev->num_regs = i;\n\tup_write(&adev->reset_domain->sem);\n\tret = size;\n\nerror_free:\n\tif (tmp != new)\n\t\tkfree(tmp);\n\tkfree(new);\n\treturn ret;\n}\n\nstatic const struct file_operations amdgpu_reset_dump_register_list = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_reset_dump_register_list_read,\n\t.write = amdgpu_reset_dump_register_list_write,\n\t.llseek = default_llseek\n};\n\nint amdgpu_debugfs_init(struct amdgpu_device *adev)\n{\n\tstruct dentry *root = adev_to_drm(adev)->primary->debugfs_root;\n\tstruct dentry *ent;\n\tint r, i;\n\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\n\tdebugfs_create_x32(\"amdgpu_smu_debug\", 0600, root,\n\t\t\t   &adev->pm.smu_debug_mask);\n\n\tent = debugfs_create_file(\"amdgpu_preempt_ib\", 0600, root, adev,\n\t\t\t\t  &fops_ib_preempt);\n\tif (IS_ERR(ent)) {\n\t\tDRM_ERROR(\"unable to create amdgpu_preempt_ib debugsfs file\\n\");\n\t\treturn PTR_ERR(ent);\n\t}\n\n\tent = debugfs_create_file(\"amdgpu_force_sclk\", 0200, root, adev,\n\t\t\t\t  &fops_sclk_set);\n\tif (IS_ERR(ent)) {\n\t\tDRM_ERROR(\"unable to create amdgpu_set_sclk debugsfs file\\n\");\n\t\treturn PTR_ERR(ent);\n\t}\n\n\t \n\tamdgpu_ttm_debugfs_init(adev);\n\tamdgpu_debugfs_pm_init(adev);\n\tamdgpu_debugfs_sa_init(adev);\n\tamdgpu_debugfs_fence_init(adev);\n\tamdgpu_debugfs_gem_init(adev);\n\n\tr = amdgpu_debugfs_regs_init(adev);\n\tif (r)\n\t\tDRM_ERROR(\"registering register debugfs failed (%d).\\n\", r);\n\n\tamdgpu_debugfs_firmware_init(adev);\n\tamdgpu_ta_if_debugfs_init(adev);\n\n#if defined(CONFIG_DRM_AMD_DC)\n\tif (adev->dc_enabled)\n\t\tdtn_debugfs_init(adev);\n#endif\n\n\tfor (i = 0; i < AMDGPU_MAX_RINGS; ++i) {\n\t\tstruct amdgpu_ring *ring = adev->rings[i];\n\n\t\tif (!ring)\n\t\t\tcontinue;\n\n\t\tamdgpu_debugfs_ring_init(adev, ring);\n\t}\n\n\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\tif (!amdgpu_vcnfw_log)\n\t\t\tbreak;\n\n\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tamdgpu_debugfs_vcn_fwlog_init(adev, i, &adev->vcn.inst[i]);\n\t}\n\n\tamdgpu_ras_debugfs_create_all(adev);\n\tamdgpu_rap_debugfs_init(adev);\n\tamdgpu_securedisplay_debugfs_init(adev);\n\tamdgpu_fw_attestation_debugfs_init(adev);\n\n\tdebugfs_create_file(\"amdgpu_evict_vram\", 0444, root, adev,\n\t\t\t    &amdgpu_evict_vram_fops);\n\tdebugfs_create_file(\"amdgpu_evict_gtt\", 0444, root, adev,\n\t\t\t    &amdgpu_evict_gtt_fops);\n\tdebugfs_create_file(\"amdgpu_test_ib\", 0444, root, adev,\n\t\t\t    &amdgpu_debugfs_test_ib_fops);\n\tdebugfs_create_file(\"amdgpu_vm_info\", 0444, root, adev,\n\t\t\t    &amdgpu_debugfs_vm_info_fops);\n\tdebugfs_create_file(\"amdgpu_benchmark\", 0200, root, adev,\n\t\t\t    &amdgpu_benchmark_fops);\n\tdebugfs_create_file(\"amdgpu_reset_dump_register_list\", 0644, root, adev,\n\t\t\t    &amdgpu_reset_dump_register_list);\n\n\tadev->debugfs_vbios_blob.data = adev->bios;\n\tadev->debugfs_vbios_blob.size = adev->bios_size;\n\tdebugfs_create_blob(\"amdgpu_vbios\", 0444, root,\n\t\t\t    &adev->debugfs_vbios_blob);\n\n\tadev->debugfs_discovery_blob.data = adev->mman.discovery_bin;\n\tadev->debugfs_discovery_blob.size = adev->mman.discovery_tmr_size;\n\tdebugfs_create_blob(\"amdgpu_discovery\", 0444, root,\n\t\t\t    &adev->debugfs_discovery_blob);\n\n\treturn 0;\n}\n\n#else\nint amdgpu_debugfs_init(struct amdgpu_device *adev)\n{\n\treturn 0;\n}\nint amdgpu_debugfs_regs_init(struct amdgpu_device *adev)\n{\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}