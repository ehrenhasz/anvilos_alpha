{
  "module_name": "amdgpu_cs.c",
  "hash_id": "d314e3508956aa63ce1c4deeacc6720457cd25771f052fe427e91c3c0ceabc86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c",
  "human_readable_source": " \n\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/sync_file.h>\n#include <linux/dma-buf.h>\n\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_syncobj.h>\n#include <drm/ttm/ttm_tt.h>\n\n#include \"amdgpu_cs.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_trace.h\"\n#include \"amdgpu_gmc.h\"\n#include \"amdgpu_gem.h\"\n#include \"amdgpu_ras.h\"\n\nstatic int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p,\n\t\t\t\t struct amdgpu_device *adev,\n\t\t\t\t struct drm_file *filp,\n\t\t\t\t union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = filp->driver_priv;\n\n\tif (cs->in.num_chunks == 0)\n\t\treturn -EINVAL;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->adev = adev;\n\tp->filp = filp;\n\n\tp->ctx = amdgpu_ctx_get(fpriv, cs->in.ctx_id);\n\tif (!p->ctx)\n\t\treturn -EINVAL;\n\n\tif (atomic_read(&p->ctx->guilty)) {\n\t\tamdgpu_ctx_put(p->ctx);\n\t\treturn -ECANCELED;\n\t}\n\n\tamdgpu_sync_create(&p->sync);\n\tdrm_exec_init(&p->exec, DRM_EXEC_INTERRUPTIBLE_WAIT |\n\t\t      DRM_EXEC_IGNORE_DUPLICATES);\n\treturn 0;\n}\n\nstatic int amdgpu_cs_job_idx(struct amdgpu_cs_parser *p,\n\t\t\t     struct drm_amdgpu_cs_chunk_ib *chunk_ib)\n{\n\tstruct drm_sched_entity *entity;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_get_entity(p->ctx, chunk_ib->ip_type,\n\t\t\t\t  chunk_ib->ip_instance,\n\t\t\t\t  chunk_ib->ring, &entity);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (entity->rq == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tif (p->entities[i] == entity)\n\t\t\treturn i;\n\n\t \n\tif (i == AMDGPU_CS_GANG_SIZE)\n\t\treturn -EINVAL;\n\n\tp->entities[i] = entity;\n\tp->gang_size = i + 1;\n\treturn i;\n}\n\nstatic int amdgpu_cs_p1_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct drm_amdgpu_cs_chunk_ib *chunk_ib,\n\t\t\t   unsigned int *num_ibs)\n{\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (num_ibs[r] >= amdgpu_ring_max_ibs(chunk_ib->ip_type))\n\t\treturn -EINVAL;\n\n\t++(num_ibs[r]);\n\tp->gang_leader_idx = r;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p1_user_fence(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_cs_chunk_fence *data,\n\t\t\t\t   uint32_t *offset)\n{\n\tstruct drm_gem_object *gobj;\n\tunsigned long size;\n\n\tgobj = drm_gem_object_lookup(p->filp, data->handle);\n\tif (gobj == NULL)\n\t\treturn -EINVAL;\n\n\tp->uf_bo = amdgpu_bo_ref(gem_to_amdgpu_bo(gobj));\n\tdrm_gem_object_put(gobj);\n\n\tsize = amdgpu_bo_size(p->uf_bo);\n\tif (size != PAGE_SIZE || data->offset > (size - 8))\n\t\treturn -EINVAL;\n\n\tif (amdgpu_ttm_tt_get_usermm(p->uf_bo->tbo.ttm))\n\t\treturn -EINVAL;\n\n\t*offset = data->offset;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p1_bo_handles(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct drm_amdgpu_bo_list_in *data)\n{\n\tstruct drm_amdgpu_bo_list_entry *info;\n\tint r;\n\n\tr = amdgpu_bo_create_list_entry_array(data, &info);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_bo_list_create(p->adev, p->filp, info, data->bo_number,\n\t\t\t\t  &p->bo_list);\n\tif (r)\n\t\tgoto error_free;\n\n\tkvfree(info);\n\treturn 0;\n\nerror_free:\n\tkvfree(info);\n\n\treturn r;\n}\n\n \nstatic int amdgpu_cs_pass1(struct amdgpu_cs_parser *p,\n\t\t\t   union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_ibs[AMDGPU_CS_GANG_SIZE] = { };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tuint64_t *chunk_array_user;\n\tuint64_t *chunk_array;\n\tuint32_t uf_offset = 0;\n\tsize_t size;\n\tint ret;\n\tint i;\n\n\tchunk_array = kvmalloc_array(cs->in.num_chunks, sizeof(uint64_t),\n\t\t\t\t     GFP_KERNEL);\n\tif (!chunk_array)\n\t\treturn -ENOMEM;\n\n\t \n\tchunk_array_user = u64_to_user_ptr(cs->in.chunks);\n\tif (copy_from_user(chunk_array, chunk_array_user,\n\t\t\t   sizeof(uint64_t)*cs->in.num_chunks)) {\n\t\tret = -EFAULT;\n\t\tgoto free_chunk;\n\t}\n\n\tp->nchunks = cs->in.num_chunks;\n\tp->chunks = kvmalloc_array(p->nchunks, sizeof(struct amdgpu_cs_chunk),\n\t\t\t    GFP_KERNEL);\n\tif (!p->chunks) {\n\t\tret = -ENOMEM;\n\t\tgoto free_chunk;\n\t}\n\n\tfor (i = 0; i < p->nchunks; i++) {\n\t\tstruct drm_amdgpu_cs_chunk __user *chunk_ptr = NULL;\n\t\tstruct drm_amdgpu_cs_chunk user_chunk;\n\t\tuint32_t __user *cdata;\n\n\t\tchunk_ptr = u64_to_user_ptr(chunk_array[i]);\n\t\tif (copy_from_user(&user_chunk, chunk_ptr,\n\t\t\t\t       sizeof(struct drm_amdgpu_cs_chunk))) {\n\t\t\tret = -EFAULT;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tp->chunks[i].chunk_id = user_chunk.chunk_id;\n\t\tp->chunks[i].length_dw = user_chunk.length_dw;\n\n\t\tsize = p->chunks[i].length_dw;\n\t\tcdata = u64_to_user_ptr(user_chunk.chunk_data);\n\n\t\tp->chunks[i].kdata = kvmalloc_array(size, sizeof(uint32_t),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (p->chunks[i].kdata == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\ti--;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t\tsize *= sizeof(uint32_t);\n\t\tif (copy_from_user(p->chunks[i].kdata, cdata, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\n\t\t \n\t\tret = -EINVAL;\n\t\tswitch (p->chunks[i].chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_ib))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_ib(p, p->chunks[i].kdata, num_ibs);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_FENCE:\n\t\t\tif (size < sizeof(struct drm_amdgpu_cs_chunk_fence))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_user_fence(p, p->chunks[i].kdata,\n\t\t\t\t\t\t      &uf_offset);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_BO_HANDLES:\n\t\t\tif (size < sizeof(struct drm_amdgpu_bo_list_in))\n\t\t\t\tgoto free_partial_kdata;\n\n\t\t\tret = amdgpu_cs_p1_bo_handles(p, p->chunks[i].kdata);\n\t\t\tif (ret)\n\t\t\t\tgoto free_partial_kdata;\n\t\t\tbreak;\n\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto free_partial_kdata;\n\t\t}\n\t}\n\n\tif (!p->gang_size) {\n\t\tret = -EINVAL;\n\t\tgoto free_all_kdata;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tret = amdgpu_job_alloc(p->adev, vm, p->entities[i], vm,\n\t\t\t\t       num_ibs[i], &p->jobs[i]);\n\t\tif (ret)\n\t\t\tgoto free_all_kdata;\n\t}\n\tp->gang_leader = p->jobs[p->gang_leader_idx];\n\n\tif (p->ctx->generation != p->gang_leader->generation) {\n\t\tret = -ECANCELED;\n\t\tgoto free_all_kdata;\n\t}\n\n\tif (p->uf_bo)\n\t\tp->gang_leader->uf_addr = uf_offset;\n\tkvfree(chunk_array);\n\n\t \n\tamdgpu_vm_set_task_info(vm);\n\n\treturn 0;\n\nfree_all_kdata:\n\ti = p->nchunks - 1;\nfree_partial_kdata:\n\tfor (; i >= 0; i--)\n\t\tkvfree(p->chunks[i].kdata);\n\tkvfree(p->chunks);\n\tp->chunks = NULL;\n\tp->nchunks = 0;\nfree_chunk:\n\tkvfree(chunk_array);\n\n\treturn ret;\n}\n\nstatic int amdgpu_cs_p2_ib(struct amdgpu_cs_parser *p,\n\t\t\t   struct amdgpu_cs_chunk *chunk,\n\t\t\t   unsigned int *ce_preempt,\n\t\t\t   unsigned int *de_preempt)\n{\n\tstruct drm_amdgpu_cs_chunk_ib *chunk_ib = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tint r;\n\n\tr = amdgpu_cs_job_idx(p, chunk_ib);\n\tif (r < 0)\n\t\treturn r;\n\n\tjob = p->jobs[r];\n\tring = amdgpu_job_ring(job);\n\tib = &job->ibs[job->num_ibs++];\n\n\t \n\tif (p->uf_bo && ring->funcs->no_user_fence)\n\t\treturn -EINVAL;\n\n\tif (chunk_ib->ip_type == AMDGPU_HW_IP_GFX &&\n\t    chunk_ib->flags & AMDGPU_IB_FLAG_PREEMPT) {\n\t\tif (chunk_ib->flags & AMDGPU_IB_FLAG_CE)\n\t\t\t(*ce_preempt)++;\n\t\telse\n\t\t\t(*de_preempt)++;\n\n\t\t \n\t\tif (*ce_preempt > 1 || *de_preempt > 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (chunk_ib->flags & AMDGPU_IB_FLAG_PREAMBLE)\n\t\tjob->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT;\n\n\tr =  amdgpu_ib_get(p->adev, vm, ring->funcs->parse_cs ?\n\t\t\t   chunk_ib->ib_bytes : 0,\n\t\t\t   AMDGPU_IB_POOL_DELAYED, ib);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to get ib !\\n\");\n\t\treturn r;\n\t}\n\n\tib->gpu_addr = chunk_ib->va_start;\n\tib->length_dw = chunk_ib->ib_bytes / 4;\n\tib->flags = chunk_ib->flags;\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_dependencies(struct amdgpu_cs_parser *p,\n\t\t\t\t     struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_dep *deps = chunk->kdata;\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_dep);\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_ctx *ctx;\n\t\tstruct drm_sched_entity *entity;\n\t\tstruct dma_fence *fence;\n\n\t\tctx = amdgpu_ctx_get(fpriv, deps[i].ctx_id);\n\t\tif (ctx == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_ctx_get_entity(ctx, deps[i].ip_type,\n\t\t\t\t\t  deps[i].ip_instance,\n\t\t\t\t\t  deps[i].ring, &entity);\n\t\tif (r) {\n\t\t\tamdgpu_ctx_put(ctx);\n\t\t\treturn r;\n\t\t}\n\n\t\tfence = amdgpu_ctx_get_fence(ctx, entity, deps[i].handle);\n\t\tamdgpu_ctx_put(ctx);\n\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tif (chunk->chunk_id == AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES) {\n\t\t\tstruct drm_sched_fence *s_fence;\n\t\t\tstruct dma_fence *old = fence;\n\n\t\t\ts_fence = to_drm_sched_fence(fence);\n\t\t\tfence = dma_fence_get(&s_fence->scheduled);\n\t\t\tdma_fence_put(old);\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_syncobj_lookup_and_add(struct amdgpu_cs_parser *p,\n\t\t\t\t\t uint32_t handle, u64 point,\n\t\t\t\t\t u64 flags)\n{\n\tstruct dma_fence *fence;\n\tint r;\n\n\tr = drm_syncobj_find_fence(p->filp, handle, point, flags, &fence);\n\tif (r) {\n\t\tDRM_ERROR(\"syncobj %u failed to find fence @ %llu (%d)!\\n\",\n\t\t\t  handle, point, r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_sync_fence(&p->sync, fence);\n\tdma_fence_put(fence);\n\treturn r;\n}\n\nstatic int amdgpu_cs_p2_syncobj_in(struct amdgpu_cs_parser *p,\n\t\t\t\t   struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, deps[i].handle, 0, 0);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_wait(struct amdgpu_cs_parser *p,\n\t\t\t\t\t      struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i, r;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tr = amdgpu_syncobj_lookup_and_add(p, syncobj_deps[i].handle,\n\t\t\t\t\t\t  syncobj_deps[i].point,\n\t\t\t\t\t\t  syncobj_deps[i].flags);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_out(struct amdgpu_cs_parser *p,\n\t\t\t\t    struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_sem *deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_sem);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tp->post_deps[i].syncobj =\n\t\t\tdrm_syncobj_find(p->filp, deps[i].handle);\n\t\tif (!p->post_deps[i].syncobj)\n\t\t\treturn -EINVAL;\n\t\tp->post_deps[i].chain = NULL;\n\t\tp->post_deps[i].point = 0;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_syncobj_timeline_signal(struct amdgpu_cs_parser *p,\n\t\t\t\t\t\tstruct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_syncobj *syncobj_deps = chunk->kdata;\n\tunsigned int num_deps;\n\tint i;\n\n\tnum_deps = chunk->length_dw * 4 /\n\t\tsizeof(struct drm_amdgpu_cs_chunk_syncobj);\n\n\tif (p->post_deps)\n\t\treturn -EINVAL;\n\n\tp->post_deps = kmalloc_array(num_deps, sizeof(*p->post_deps),\n\t\t\t\t     GFP_KERNEL);\n\tp->num_post_deps = 0;\n\n\tif (!p->post_deps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_deps; ++i) {\n\t\tstruct amdgpu_cs_post_dep *dep = &p->post_deps[i];\n\n\t\tdep->chain = NULL;\n\t\tif (syncobj_deps[i].point) {\n\t\t\tdep->chain = dma_fence_chain_alloc();\n\t\t\tif (!dep->chain)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdep->syncobj = drm_syncobj_find(p->filp,\n\t\t\t\t\t\tsyncobj_deps[i].handle);\n\t\tif (!dep->syncobj) {\n\t\t\tdma_fence_chain_free(dep->chain);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdep->point = syncobj_deps[i].point;\n\t\tp->num_post_deps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_p2_shadow(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_cs_chunk *chunk)\n{\n\tstruct drm_amdgpu_cs_chunk_cp_gfx_shadow *shadow = chunk->kdata;\n\tint i;\n\n\tif (shadow->flags & ~AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tp->jobs[i]->shadow_va = shadow->shadow_va;\n\t\tp->jobs[i]->csa_va = shadow->csa_va;\n\t\tp->jobs[i]->gds_va = shadow->gds_va;\n\t\tp->jobs[i]->init_shadow =\n\t\t\tshadow->flags & AMDGPU_CS_CHUNK_CP_GFX_SHADOW_FLAGS_INIT_SHADOW;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_pass2(struct amdgpu_cs_parser *p)\n{\n\tunsigned int ce_preempt = 0, de_preempt = 0;\n\tint i, r;\n\n\tfor (i = 0; i < p->nchunks; ++i) {\n\t\tstruct amdgpu_cs_chunk *chunk;\n\n\t\tchunk = &p->chunks[i];\n\n\t\tswitch (chunk->chunk_id) {\n\t\tcase AMDGPU_CHUNK_ID_IB:\n\t\t\tr = amdgpu_cs_p2_ib(p, chunk, &ce_preempt, &de_preempt);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_DEPENDENCIES:\n\t\tcase AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES:\n\t\t\tr = amdgpu_cs_p2_dependencies(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_IN:\n\t\t\tr = amdgpu_cs_p2_syncobj_in(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_OUT:\n\t\t\tr = amdgpu_cs_p2_syncobj_out(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_wait(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL:\n\t\t\tr = amdgpu_cs_p2_syncobj_timeline_signal(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase AMDGPU_CHUNK_ID_CP_GFX_SHADOW:\n\t\t\tr = amdgpu_cs_p2_shadow(p, chunk);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic u64 us_to_bytes(struct amdgpu_device *adev, s64 us)\n{\n\tif (us <= 0 || !adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\t \n\treturn us << adev->mm_stats.log2_max_MBps;\n}\n\nstatic s64 bytes_to_us(struct amdgpu_device *adev, u64 bytes)\n{\n\tif (!adev->mm_stats.log2_max_MBps)\n\t\treturn 0;\n\n\treturn bytes >> adev->mm_stats.log2_max_MBps;\n}\n\n \nstatic void amdgpu_cs_get_threshold_for_moves(struct amdgpu_device *adev,\n\t\t\t\t\t      u64 *max_bytes,\n\t\t\t\t\t      u64 *max_vis_bytes)\n{\n\ts64 time_us, increment_us;\n\tu64 free_vram, total_vram, used_vram;\n\t \n\tconst s64 us_upper_bound = 200000;\n\n\tif (!adev->mm_stats.log2_max_MBps) {\n\t\t*max_bytes = 0;\n\t\t*max_vis_bytes = 0;\n\t\treturn;\n\t}\n\n\ttotal_vram = adev->gmc.real_vram_size - atomic64_read(&adev->vram_pin_size);\n\tused_vram = ttm_resource_manager_usage(&adev->mman.vram_mgr.manager);\n\tfree_vram = used_vram >= total_vram ? 0 : total_vram - used_vram;\n\n\tspin_lock(&adev->mm_stats.lock);\n\n\t \n\ttime_us = ktime_to_us(ktime_get());\n\tincrement_us = time_us - adev->mm_stats.last_update_us;\n\tadev->mm_stats.last_update_us = time_us;\n\tadev->mm_stats.accum_us = min(adev->mm_stats.accum_us + increment_us,\n\t\t\t\t      us_upper_bound);\n\n\t \n\tif (free_vram >= 128 * 1024 * 1024 || free_vram >= total_vram / 8) {\n\t\ts64 min_us;\n\n\t\t \n\t\tif (!(adev->flags & AMD_IS_APU))\n\t\t\tmin_us = bytes_to_us(adev, free_vram / 4);\n\t\telse\n\t\t\tmin_us = 0;  \n\n\t\tadev->mm_stats.accum_us = max(min_us, adev->mm_stats.accum_us);\n\t}\n\n\t \n\t*max_bytes = us_to_bytes(adev, adev->mm_stats.accum_us);\n\n\t \n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc)) {\n\t\tu64 total_vis_vram = adev->gmc.visible_vram_size;\n\t\tu64 used_vis_vram =\n\t\t  amdgpu_vram_mgr_vis_usage(&adev->mman.vram_mgr);\n\n\t\tif (used_vis_vram < total_vis_vram) {\n\t\t\tu64 free_vis_vram = total_vis_vram - used_vis_vram;\n\n\t\t\tadev->mm_stats.accum_us_vis = min(adev->mm_stats.accum_us_vis +\n\t\t\t\t\t\t\t  increment_us, us_upper_bound);\n\n\t\t\tif (free_vis_vram >= total_vis_vram / 2)\n\t\t\t\tadev->mm_stats.accum_us_vis =\n\t\t\t\t\tmax(bytes_to_us(adev, free_vis_vram / 2),\n\t\t\t\t\t    adev->mm_stats.accum_us_vis);\n\t\t}\n\n\t\t*max_vis_bytes = us_to_bytes(adev, adev->mm_stats.accum_us_vis);\n\t} else {\n\t\t*max_vis_bytes = 0;\n\t}\n\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\n \nvoid amdgpu_cs_report_moved_bytes(struct amdgpu_device *adev, u64 num_bytes,\n\t\t\t\t  u64 num_vis_bytes)\n{\n\tspin_lock(&adev->mm_stats.lock);\n\tadev->mm_stats.accum_us -= bytes_to_us(adev, num_bytes);\n\tadev->mm_stats.accum_us_vis -= bytes_to_us(adev, num_vis_bytes);\n\tspin_unlock(&adev->mm_stats.lock);\n}\n\nstatic int amdgpu_cs_bo_validate(void *param, struct amdgpu_bo *bo)\n{\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct amdgpu_cs_parser *p = param;\n\tstruct ttm_operation_ctx ctx = {\n\t\t.interruptible = true,\n\t\t.no_wait_gpu = false,\n\t\t.resv = bo->tbo.base.resv\n\t};\n\tuint32_t domain;\n\tint r;\n\n\tif (bo->tbo.pin_count)\n\t\treturn 0;\n\n\t \n\tif (p->bytes_moved < p->bytes_moved_threshold &&\n\t    (!bo->tbo.base.dma_buf ||\n\t    list_empty(&bo->tbo.base.dma_buf->attachments))) {\n\t\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t\t    (bo->flags & AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)) {\n\t\t\t \n\t\t\tif (p->bytes_moved_vis < p->bytes_moved_vis_threshold)\n\t\t\t\tdomain = bo->preferred_domains;\n\t\t\telse\n\t\t\t\tdomain = bo->allowed_domains;\n\t\t} else {\n\t\t\tdomain = bo->preferred_domains;\n\t\t}\n\t} else {\n\t\tdomain = bo->allowed_domains;\n\t}\n\nretry:\n\tamdgpu_bo_placement_from_domain(bo, domain);\n\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\n\tp->bytes_moved += ctx.bytes_moved;\n\tif (!amdgpu_gmc_vram_full_visible(&adev->gmc) &&\n\t    amdgpu_bo_in_cpu_visible_vram(bo))\n\t\tp->bytes_moved_vis += ctx.bytes_moved;\n\n\tif (unlikely(r == -ENOMEM) && domain != bo->allowed_domains) {\n\t\tdomain = bo->allowed_domains;\n\t\tgoto retry;\n\t}\n\n\treturn r;\n}\n\nstatic int amdgpu_cs_parser_bos(struct amdgpu_cs_parser *p,\n\t\t\t\tunion drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct ttm_operation_ctx ctx = { true, false };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct drm_gem_object *obj;\n\tunsigned long index;\n\tunsigned int i;\n\tint r;\n\n\t \n\tif (cs->in.bo_list_handle) {\n\t\tif (p->bo_list)\n\t\t\treturn -EINVAL;\n\n\t\tr = amdgpu_bo_list_get(fpriv, cs->in.bo_list_handle,\n\t\t\t\t       &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t} else if (!p->bo_list) {\n\t\t \n\t\tr = amdgpu_bo_list_create(p->adev, p->filp, NULL, 0,\n\t\t\t\t\t  &p->bo_list);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tmutex_lock(&p->bo_list->bo_list_mutex);\n\n\t \n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tbool userpage_invalidated = false;\n\t\tstruct amdgpu_bo *bo = e->bo;\n\t\tint i;\n\n\t\te->user_pages = kvmalloc_array(bo->tbo.ttm->num_pages,\n\t\t\t\t\tsizeof(struct page *),\n\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (!e->user_pages) {\n\t\t\tDRM_ERROR(\"kvmalloc_array failure\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tr = amdgpu_ttm_tt_get_user_pages(bo, e->user_pages, &e->range);\n\t\tif (r) {\n\t\t\tkvfree(e->user_pages);\n\t\t\te->user_pages = NULL;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tfor (i = 0; i < bo->tbo.ttm->num_pages; i++) {\n\t\t\tif (bo->tbo.ttm->pages[i] != e->user_pages[i]) {\n\t\t\t\tuserpage_invalidated = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\te->user_invalidated = userpage_invalidated;\n\t}\n\n\tdrm_exec_until_all_locked(&p->exec) {\n\t\tr = amdgpu_vm_lock_pd(&fpriv->vm, &p->exec, 1 + p->gang_size);\n\t\tdrm_exec_retry_on_contention(&p->exec);\n\t\tif (unlikely(r))\n\t\t\tgoto out_free_user_pages;\n\n\t\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t\t \n\t\t\tr = drm_exec_prepare_obj(&p->exec, &e->bo->tbo.base,\n\t\t\t\t\t\t 1 + p->gang_size);\n\t\t\tdrm_exec_retry_on_contention(&p->exec);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out_free_user_pages;\n\n\t\t\te->bo_va = amdgpu_vm_bo_find(vm, e->bo);\n\t\t}\n\n\t\tif (p->uf_bo) {\n\t\t\tr = drm_exec_prepare_obj(&p->exec, &p->uf_bo->tbo.base,\n\t\t\t\t\t\t 1 + p->gang_size);\n\t\t\tdrm_exec_retry_on_contention(&p->exec);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out_free_user_pages;\n\t\t}\n\t}\n\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct mm_struct *usermm;\n\n\t\tusermm = amdgpu_ttm_tt_get_usermm(e->bo->tbo.ttm);\n\t\tif (usermm && usermm != current->mm) {\n\t\t\tr = -EPERM;\n\t\t\tgoto out_free_user_pages;\n\t\t}\n\n\t\tif (amdgpu_ttm_tt_is_userptr(e->bo->tbo.ttm) &&\n\t\t    e->user_invalidated && e->user_pages) {\n\t\t\tamdgpu_bo_placement_from_domain(e->bo,\n\t\t\t\t\t\t\tAMDGPU_GEM_DOMAIN_CPU);\n\t\t\tr = ttm_bo_validate(&e->bo->tbo, &e->bo->placement,\n\t\t\t\t\t    &ctx);\n\t\t\tif (r)\n\t\t\t\tgoto out_free_user_pages;\n\n\t\t\tamdgpu_ttm_tt_set_user_pages(e->bo->tbo.ttm,\n\t\t\t\t\t\t     e->user_pages);\n\t\t}\n\n\t\tkvfree(e->user_pages);\n\t\te->user_pages = NULL;\n\t}\n\n\tamdgpu_cs_get_threshold_for_moves(p->adev, &p->bytes_moved_threshold,\n\t\t\t\t\t  &p->bytes_moved_vis_threshold);\n\tp->bytes_moved = 0;\n\tp->bytes_moved_vis = 0;\n\n\tr = amdgpu_vm_validate_pt_bos(p->adev, &fpriv->vm,\n\t\t\t\t      amdgpu_cs_bo_validate, p);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_vm_validate_pt_bos() failed.\\n\");\n\t\tgoto out_free_user_pages;\n\t}\n\n\tdrm_exec_for_each_locked_object(&p->exec, index, obj) {\n\t\tr = amdgpu_cs_bo_validate(p, gem_to_amdgpu_bo(obj));\n\t\tif (unlikely(r))\n\t\t\tgoto out_free_user_pages;\n\t}\n\n\tif (p->uf_bo) {\n\t\tr = amdgpu_ttm_alloc_gart(&p->uf_bo->tbo);\n\t\tif (unlikely(r))\n\t\t\tgoto out_free_user_pages;\n\n\t\tp->gang_leader->uf_addr += amdgpu_bo_gpu_offset(p->uf_bo);\n\t}\n\n\tamdgpu_cs_report_moved_bytes(p->adev, p->bytes_moved,\n\t\t\t\t     p->bytes_moved_vis);\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tamdgpu_job_set_resources(p->jobs[i], p->bo_list->gds_obj,\n\t\t\t\t\t p->bo_list->gws_obj,\n\t\t\t\t\t p->bo_list->oa_obj);\n\treturn 0;\n\nout_free_user_pages:\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tstruct amdgpu_bo *bo = e->bo;\n\n\t\tif (!e->user_pages)\n\t\t\tcontinue;\n\t\tamdgpu_ttm_tt_get_user_pages_done(bo->tbo.ttm, e->range);\n\t\tkvfree(e->user_pages);\n\t\te->user_pages = NULL;\n\t\te->range = NULL;\n\t}\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn r;\n}\n\nstatic void trace_amdgpu_cs_ibs(struct amdgpu_cs_parser *p)\n{\n\tint i, j;\n\n\tif (!trace_amdgpu_cs_enabled())\n\t\treturn;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct amdgpu_job *job = p->jobs[i];\n\n\t\tfor (j = 0; j < job->num_ibs; ++j)\n\t\t\ttrace_amdgpu_cs(p, job, &job->ibs[j]);\n\t}\n}\n\nstatic int amdgpu_cs_patch_ibs(struct amdgpu_cs_parser *p,\n\t\t\t       struct amdgpu_job *job)\n{\n\tstruct amdgpu_ring *ring = amdgpu_job_ring(job);\n\tunsigned int i;\n\tint r;\n\n\t \n\tif (!ring->funcs->parse_cs && !ring->funcs->patch_cs_in_place)\n\t\treturn 0;\n\n\tfor (i = 0; i < job->num_ibs; ++i) {\n\t\tstruct amdgpu_ib *ib = &job->ibs[i];\n\t\tstruct amdgpu_bo_va_mapping *m;\n\t\tstruct amdgpu_bo *aobj;\n\t\tuint64_t va_start;\n\t\tuint8_t *kptr;\n\n\t\tva_start = ib->gpu_addr & AMDGPU_GMC_HOLE_MASK;\n\t\tr = amdgpu_cs_find_mapping(p, va_start, &aobj, &m);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"IB va_start is invalid\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tif ((va_start + ib->length_dw * 4) >\n\t\t    (m->last + 1) * AMDGPU_GPU_PAGE_SIZE) {\n\t\t\tDRM_ERROR(\"IB va_start+ib_bytes is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tr = amdgpu_bo_kmap(aobj, (void **)&kptr);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tkptr += va_start - (m->start * AMDGPU_GPU_PAGE_SIZE);\n\n\t\tif (ring->funcs->parse_cs) {\n\t\t\tmemcpy(ib->ptr, kptr, ib->length_dw * 4);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\n\t\t\tr = amdgpu_ring_parse_cs(ring, p, job, ib);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\tib->ptr = (uint32_t *)kptr;\n\t\t\tr = amdgpu_ring_patch_cs_in_place(ring, p, job, ib);\n\t\t\tamdgpu_bo_kunmap(aobj);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_patch_jobs(struct amdgpu_cs_parser *p)\n{\n\tunsigned int i;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_cs_patch_ibs(p, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_cs_vm_handling(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *job = p->gang_leader;\n\tstruct amdgpu_device *adev = p->adev;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct amdgpu_bo_va *bo_va;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_vm_clear_freed(adev, vm, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_bo_update(adev, fpriv->prt_va, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, fpriv->prt_va->last_pt_update);\n\tif (r)\n\t\treturn r;\n\n\tif (fpriv->csa_va) {\n\t\tbo_va = fpriv->csa_va;\n\t\tBUG_ON(!bo_va);\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\tbo_va = e->bo_va;\n\t\tif (bo_va == NULL)\n\t\t\tcontinue;\n\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_vm_handle_moved(adev, vm);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_update_pdes(adev, vm, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, vm->last_update);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tjob = p->jobs[i];\n\n\t\tif (!job->vm)\n\t\t\tcontinue;\n\n\t\tjob->vm_pd_addr = amdgpu_gmc_pd_addr(vm->root.bo);\n\t}\n\n\tif (amdgpu_vm_debug) {\n\t\t \n\t\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t\tstruct amdgpu_bo *bo = e->bo;\n\n\t\t\t \n\t\t\tif (!bo)\n\t\t\t\tcontinue;\n\n\t\t\tamdgpu_vm_bo_invalidate(adev, bo, false);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_cs_sync_rings(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct drm_gpu_scheduler *sched;\n\tstruct drm_gem_object *obj;\n\tstruct dma_fence *fence;\n\tunsigned long index;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_ctx_wait_prev_fence(p->ctx, p->entities[p->gang_leader_idx]);\n\tif (r) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"amdgpu_ctx_wait_prev_fence failed.\\n\");\n\t\treturn r;\n\t}\n\n\tdrm_exec_for_each_locked_object(&p->exec, index, obj) {\n\t\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\n\t\tstruct dma_resv *resv = bo->tbo.base.resv;\n\t\tenum amdgpu_sync_mode sync_mode;\n\n\t\tsync_mode = amdgpu_bo_explicit_sync(bo) ?\n\t\t\tAMDGPU_SYNC_EXPLICIT : AMDGPU_SYNC_NE_OWNER;\n\t\tr = amdgpu_sync_resv(p->adev, &p->sync, resv, sync_mode,\n\t\t\t\t     &fpriv->vm);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tr = amdgpu_sync_push_to_job(&p->sync, p->jobs[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tsched = p->gang_leader->base.entity->rq->sched;\n\twhile ((fence = amdgpu_sync_get_fence(&p->sync))) {\n\t\tstruct drm_sched_fence *s_fence = to_drm_sched_fence(fence);\n\n\t\t \n\t\tif (!s_fence || s_fence->sched != sched) {\n\t\t\tdma_fence_put(fence);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = amdgpu_sync_fence(&p->gang_leader->explicit_sync, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void amdgpu_cs_post_dependencies(struct amdgpu_cs_parser *p)\n{\n\tint i;\n\n\tfor (i = 0; i < p->num_post_deps; ++i) {\n\t\tif (p->post_deps[i].chain && p->post_deps[i].point) {\n\t\t\tdrm_syncobj_add_point(p->post_deps[i].syncobj,\n\t\t\t\t\t      p->post_deps[i].chain,\n\t\t\t\t\t      p->fence, p->post_deps[i].point);\n\t\t\tp->post_deps[i].chain = NULL;\n\t\t} else {\n\t\t\tdrm_syncobj_replace_fence(p->post_deps[i].syncobj,\n\t\t\t\t\t\t  p->fence);\n\t\t}\n\t}\n}\n\nstatic int amdgpu_cs_submit(struct amdgpu_cs_parser *p,\n\t\t\t    union drm_amdgpu_cs *cs)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *leader = p->gang_leader;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct drm_gem_object *gobj;\n\tunsigned long index;\n\tunsigned int i;\n\tuint64_t seq;\n\tint r;\n\n\tfor (i = 0; i < p->gang_size; ++i)\n\t\tdrm_sched_job_arm(&p->jobs[i]->base);\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tif (p->jobs[i] == leader)\n\t\t\tcontinue;\n\n\t\tfence = &p->jobs[i]->base.s_fence->scheduled;\n\t\tdma_fence_get(fence);\n\t\tr = drm_sched_job_add_dependency(&leader->base, fence);\n\t\tif (r) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (p->gang_size > 1) {\n\t\tfor (i = 0; i < p->gang_size; ++i)\n\t\t\tamdgpu_job_set_gang_leader(p->jobs[i], leader);\n\t}\n\n\t \n\tmutex_lock(&p->adev->notifier_lock);\n\n\t \n\tr = 0;\n\tamdgpu_bo_list_for_each_userptr_entry(e, p->bo_list) {\n\t\tr |= !amdgpu_ttm_tt_get_user_pages_done(e->bo->tbo.ttm,\n\t\t\t\t\t\t\te->range);\n\t\te->range = NULL;\n\t}\n\tif (r) {\n\t\tr = -EAGAIN;\n\t\tmutex_unlock(&p->adev->notifier_lock);\n\t\treturn r;\n\t}\n\n\tp->fence = dma_fence_get(&leader->base.s_fence->finished);\n\tdrm_exec_for_each_locked_object(&p->exec, index, gobj) {\n\n\t\tttm_bo_move_to_lru_tail_unlocked(&gem_to_amdgpu_bo(gobj)->tbo);\n\n\t\t \n\t\tfor (i = 0; i < p->gang_size; ++i) {\n\t\t\tif (p->jobs[i] == leader)\n\t\t\t\tcontinue;\n\n\t\t\tdma_resv_add_fence(gobj->resv,\n\t\t\t\t\t   &p->jobs[i]->base.s_fence->finished,\n\t\t\t\t\t   DMA_RESV_USAGE_READ);\n\t\t}\n\n\t\t \n\t\tdma_resv_add_fence(gobj->resv, p->fence, DMA_RESV_USAGE_WRITE);\n\t}\n\n\tseq = amdgpu_ctx_add_fence(p->ctx, p->entities[p->gang_leader_idx],\n\t\t\t\t   p->fence);\n\tamdgpu_cs_post_dependencies(p);\n\n\tif ((leader->preamble_status & AMDGPU_PREAMBLE_IB_PRESENT) &&\n\t    !p->ctx->preamble_presented) {\n\t\tleader->preamble_status |= AMDGPU_PREAMBLE_IB_PRESENT_FIRST;\n\t\tp->ctx->preamble_presented = true;\n\t}\n\n\tcs->out.handle = seq;\n\tleader->uf_sequence = seq;\n\n\tamdgpu_vm_bo_trace_cs(&fpriv->vm, &p->exec.ticket);\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tamdgpu_job_free_resources(p->jobs[i]);\n\t\ttrace_amdgpu_cs_ioctl(p->jobs[i]);\n\t\tdrm_sched_entity_push_job(&p->jobs[i]->base);\n\t\tp->jobs[i] = NULL;\n\t}\n\n\tamdgpu_vm_move_to_lru_tail(p->adev, &fpriv->vm);\n\n\tmutex_unlock(&p->adev->notifier_lock);\n\tmutex_unlock(&p->bo_list->bo_list_mutex);\n\treturn 0;\n}\n\n \nstatic void amdgpu_cs_parser_fini(struct amdgpu_cs_parser *parser)\n{\n\tunsigned int i;\n\n\tamdgpu_sync_free(&parser->sync);\n\tdrm_exec_fini(&parser->exec);\n\n\tfor (i = 0; i < parser->num_post_deps; i++) {\n\t\tdrm_syncobj_put(parser->post_deps[i].syncobj);\n\t\tkfree(parser->post_deps[i].chain);\n\t}\n\tkfree(parser->post_deps);\n\n\tdma_fence_put(parser->fence);\n\n\tif (parser->ctx)\n\t\tamdgpu_ctx_put(parser->ctx);\n\tif (parser->bo_list)\n\t\tamdgpu_bo_list_put(parser->bo_list);\n\n\tfor (i = 0; i < parser->nchunks; i++)\n\t\tkvfree(parser->chunks[i].kdata);\n\tkvfree(parser->chunks);\n\tfor (i = 0; i < parser->gang_size; ++i) {\n\t\tif (parser->jobs[i])\n\t\t\tamdgpu_job_free(parser->jobs[i]);\n\t}\n\tamdgpu_bo_unref(&parser->uf_bo);\n}\n\nint amdgpu_cs_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_cs_parser parser;\n\tint r;\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn -EHWPOISON;\n\n\tif (!adev->accel_working)\n\t\treturn -EBUSY;\n\n\tr = amdgpu_cs_parser_init(&parser, adev, filp, data);\n\tif (r) {\n\t\tif (printk_ratelimit())\n\t\t\tDRM_ERROR(\"Failed to initialize parser %d!\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_cs_pass1(&parser, data);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_pass2(&parser);\n\tif (r)\n\t\tgoto error_fini;\n\n\tr = amdgpu_cs_parser_bos(&parser, data);\n\tif (r) {\n\t\tif (r == -ENOMEM)\n\t\t\tDRM_ERROR(\"Not enough memory for command submission!\\n\");\n\t\telse if (r != -ERESTARTSYS && r != -EAGAIN)\n\t\t\tDRM_DEBUG(\"Failed to process the buffer list %d!\\n\", r);\n\t\tgoto error_fini;\n\t}\n\n\tr = amdgpu_cs_patch_jobs(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_vm_handling(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tr = amdgpu_cs_sync_rings(&parser);\n\tif (r)\n\t\tgoto error_backoff;\n\n\ttrace_amdgpu_cs_ibs(&parser);\n\n\tr = amdgpu_cs_submit(&parser, data);\n\tif (r)\n\t\tgoto error_backoff;\n\n\tamdgpu_cs_parser_fini(&parser);\n\treturn 0;\n\nerror_backoff:\n\tmutex_unlock(&parser.bo_list->bo_list_mutex);\n\nerror_fini:\n\tamdgpu_cs_parser_fini(&parser);\n\treturn r;\n}\n\n \nint amdgpu_cs_wait_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *filp)\n{\n\tunion drm_amdgpu_wait_cs *wait = data;\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout);\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tlong r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, wait->in.ctx_id);\n\tif (ctx == NULL)\n\t\treturn -EINVAL;\n\n\tr = amdgpu_ctx_get_entity(ctx, wait->in.ip_type, wait->in.ip_instance,\n\t\t\t\t  wait->in.ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn r;\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, wait->in.handle);\n\tif (IS_ERR(fence))\n\t\tr = PTR_ERR(fence);\n\telse if (fence) {\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tif (r > 0 && fence->error)\n\t\t\tr = fence->error;\n\t\tdma_fence_put(fence);\n\t} else\n\t\tr = 1;\n\n\tamdgpu_ctx_put(ctx);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r == 0);\n\n\treturn 0;\n}\n\n \nstatic struct dma_fence *amdgpu_cs_get_fence(struct amdgpu_device *adev,\n\t\t\t\t\t     struct drm_file *filp,\n\t\t\t\t\t     struct drm_amdgpu_fence *user)\n{\n\tstruct drm_sched_entity *entity;\n\tstruct amdgpu_ctx *ctx;\n\tstruct dma_fence *fence;\n\tint r;\n\n\tctx = amdgpu_ctx_get(filp->driver_priv, user->ctx_id);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tr = amdgpu_ctx_get_entity(ctx, user->ip_type, user->ip_instance,\n\t\t\t\t  user->ring, &entity);\n\tif (r) {\n\t\tamdgpu_ctx_put(ctx);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tfence = amdgpu_ctx_get_fence(ctx, entity, user->seq_no);\n\tamdgpu_ctx_put(ctx);\n\n\treturn fence;\n}\n\nint amdgpu_cs_fence_to_handle_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_fence_to_handle *info = data;\n\tstruct dma_fence *fence;\n\tstruct drm_syncobj *syncobj;\n\tstruct sync_file *sync_file;\n\tint fd, r;\n\n\tfence = amdgpu_cs_get_fence(adev, filp, &info->in.fence);\n\tif (IS_ERR(fence))\n\t\treturn PTR_ERR(fence);\n\n\tif (!fence)\n\t\tfence = dma_fence_get_stub();\n\n\tswitch (info->in.what) {\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_handle(filp, syncobj, &info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ_FD:\n\t\tr = drm_syncobj_create(&syncobj, 0, fence);\n\t\tdma_fence_put(fence);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = drm_syncobj_get_fd(syncobj, (int *)&info->out.handle);\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn r;\n\n\tcase AMDGPU_FENCE_TO_HANDLE_GET_SYNC_FILE_FD:\n\t\tfd = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (fd < 0) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn fd;\n\t\t}\n\n\t\tsync_file = sync_file_create(fence);\n\t\tdma_fence_put(fence);\n\t\tif (!sync_file) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfd_install(fd, sync_file->file);\n\t\tinfo->out.handle = fd;\n\t\treturn 0;\n\n\tdefault:\n\t\tdma_fence_put(fence);\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tif (r > 0 && fence->error)\n\t\t\tr = fence->error;\n\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (r == 0)\n\t\t\tbreak;\n\t}\n\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\n\treturn 0;\n}\n\n \nstatic int amdgpu_cs_wait_any_fence(struct amdgpu_device *adev,\n\t\t\t\t    struct drm_file *filp,\n\t\t\t\t    union drm_amdgpu_wait_fences *wait,\n\t\t\t\t    struct drm_amdgpu_fence *fences)\n{\n\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\tuint32_t fence_count = wait->in.fence_count;\n\tuint32_t first = ~0;\n\tstruct dma_fence **array;\n\tunsigned int i;\n\tlong r;\n\n\t \n\tarray = kcalloc(fence_count, sizeof(struct dma_fence *), GFP_KERNEL);\n\n\tif (array == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence)) {\n\t\t\tr = PTR_ERR(fence);\n\t\t\tgoto err_free_fence_array;\n\t\t} else if (fence) {\n\t\t\tarray[i] = fence;\n\t\t} else {  \n\t\t\tr = 1;\n\t\t\tfirst = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = dma_fence_wait_any_timeout(array, fence_count, true, timeout,\n\t\t\t\t       &first);\n\tif (r < 0)\n\t\tgoto err_free_fence_array;\n\nout:\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\twait->out.first_signaled = first;\n\n\tif (first < fence_count && array[first])\n\t\tr = array[first]->error;\n\telse\n\t\tr = 0;\n\nerr_free_fence_array:\n\tfor (i = 0; i < fence_count; i++)\n\t\tdma_fence_put(array[i]);\n\tkfree(array);\n\n\treturn r;\n}\n\n \nint amdgpu_cs_wait_fences_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion drm_amdgpu_wait_fences *wait = data;\n\tuint32_t fence_count = wait->in.fence_count;\n\tstruct drm_amdgpu_fence *fences_user;\n\tstruct drm_amdgpu_fence *fences;\n\tint r;\n\n\t \n\tfences = kmalloc_array(fence_count, sizeof(struct drm_amdgpu_fence),\n\t\t\tGFP_KERNEL);\n\tif (fences == NULL)\n\t\treturn -ENOMEM;\n\n\tfences_user = u64_to_user_ptr(wait->in.fences);\n\tif (copy_from_user(fences, fences_user,\n\t\tsizeof(struct drm_amdgpu_fence) * fence_count)) {\n\t\tr = -EFAULT;\n\t\tgoto err_free_fences;\n\t}\n\n\tif (wait->in.wait_all)\n\t\tr = amdgpu_cs_wait_all_fences(adev, filp, wait, fences);\n\telse\n\t\tr = amdgpu_cs_wait_any_fence(adev, filp, wait, fences);\n\nerr_free_fences:\n\tkfree(fences);\n\n\treturn r;\n}\n\n \nint amdgpu_cs_find_mapping(struct amdgpu_cs_parser *parser,\n\t\t\t   uint64_t addr, struct amdgpu_bo **bo,\n\t\t\t   struct amdgpu_bo_va_mapping **map)\n{\n\tstruct amdgpu_fpriv *fpriv = parser->filp->driver_priv;\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_va_mapping *mapping;\n\tint r;\n\n\taddr /= AMDGPU_GPU_PAGE_SIZE;\n\n\tmapping = amdgpu_vm_bo_lookup_mapping(vm, addr);\n\tif (!mapping || !mapping->bo_va || !mapping->bo_va->base.bo)\n\t\treturn -EINVAL;\n\n\t*bo = mapping->bo_va->base.bo;\n\t*map = mapping;\n\n\t \n\tif (dma_resv_locking_ctx((*bo)->tbo.base.resv) != &parser->exec.ticket)\n\t\treturn -EINVAL;\n\n\tif (!((*bo)->flags & AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS)) {\n\t\t(*bo)->flags |= AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS;\n\t\tamdgpu_bo_placement_from_domain(*bo, (*bo)->allowed_domains);\n\t\tr = ttm_bo_validate(&(*bo)->tbo, &(*bo)->placement, &ctx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn amdgpu_ttm_alloc_gart(&(*bo)->tbo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}