{
  "module_name": "cz_ih.c",
  "hash_id": "468560c9a19a4a5ae2cb723ece9cbd0a595d71f80d90a71abe9ccf15350b1b4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/cz_ih.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_ih.h\"\n#include \"vid.h\"\n\n#include \"oss/oss_3_0_1_d.h\"\n#include \"oss/oss_3_0_1_sh_mask.h\"\n\n#include \"bif/bif_5_1_d.h\"\n#include \"bif/bif_5_1_sh_mask.h\"\n\n \n\nstatic void cz_ih_set_interrupt_funcs(struct amdgpu_device *adev);\n\n \nstatic void cz_ih_enable_interrupts(struct amdgpu_device *adev)\n{\n\tu32 ih_cntl = RREG32(mmIH_CNTL);\n\tu32 ih_rb_cntl = RREG32(mmIH_RB_CNTL);\n\n\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL, ENABLE_INTR, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_ENABLE, 1);\n\tWREG32(mmIH_CNTL, ih_cntl);\n\tWREG32(mmIH_RB_CNTL, ih_rb_cntl);\n\tadev->irq.ih.enabled = true;\n}\n\n \nstatic void cz_ih_disable_interrupts(struct amdgpu_device *adev)\n{\n\tu32 ih_rb_cntl = RREG32(mmIH_RB_CNTL);\n\tu32 ih_cntl = RREG32(mmIH_CNTL);\n\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_ENABLE, 0);\n\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL, ENABLE_INTR, 0);\n\tWREG32(mmIH_RB_CNTL, ih_rb_cntl);\n\tWREG32(mmIH_CNTL, ih_cntl);\n\t \n\tWREG32(mmIH_RB_RPTR, 0);\n\tWREG32(mmIH_RB_WPTR, 0);\n\tadev->irq.ih.enabled = false;\n\tadev->irq.ih.rptr = 0;\n}\n\n \nstatic int cz_ih_irq_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ih_ring *ih = &adev->irq.ih;\n\tu32 interrupt_cntl, ih_cntl, ih_rb_cntl;\n\tint rb_bufsz;\n\n\t \n\tcz_ih_disable_interrupts(adev);\n\n\t \n\tWREG32(mmINTERRUPT_CNTL2, adev->dummy_page_addr >> 8);\n\tinterrupt_cntl = RREG32(mmINTERRUPT_CNTL);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, INTERRUPT_CNTL, IH_DUMMY_RD_OVERRIDE, 0);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, INTERRUPT_CNTL, IH_REQ_NONSNOOP_EN, 0);\n\tWREG32(mmINTERRUPT_CNTL, interrupt_cntl);\n\n\t \n\tWREG32(mmIH_RB_BASE, adev->irq.ih.gpu_addr >> 8);\n\n\trb_bufsz = order_base_2(adev->irq.ih.ring_size / 4);\n\tih_rb_cntl = REG_SET_FIELD(0, IH_RB_CNTL, WPTR_OVERFLOW_ENABLE, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_SIZE, rb_bufsz);\n\n\t \n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, WPTR_WRITEBACK_ENABLE, 1);\n\n\t \n\tWREG32(mmIH_RB_WPTR_ADDR_LO, lower_32_bits(ih->wptr_addr));\n\tWREG32(mmIH_RB_WPTR_ADDR_HI, upper_32_bits(ih->wptr_addr) & 0xFF);\n\n\tWREG32(mmIH_RB_CNTL, ih_rb_cntl);\n\n\t \n\tWREG32(mmIH_RB_RPTR, 0);\n\tWREG32(mmIH_RB_WPTR, 0);\n\n\t \n\tih_cntl = RREG32(mmIH_CNTL);\n\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL, MC_VMID, 0);\n\n\tif (adev->irq.msi_enabled)\n\t\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL, RPTR_REARM, 1);\n\tWREG32(mmIH_CNTL, ih_cntl);\n\n\tpci_set_master(adev->pdev);\n\n\t \n\tcz_ih_enable_interrupts(adev);\n\n\treturn 0;\n}\n\n \nstatic void cz_ih_irq_disable(struct amdgpu_device *adev)\n{\n\tcz_ih_disable_interrupts(adev);\n\n\t \n\tmdelay(1);\n}\n\n \nstatic u32 cz_ih_get_wptr(struct amdgpu_device *adev,\n\t\t\t  struct amdgpu_ih_ring *ih)\n{\n\tu32 wptr, tmp;\n\n\twptr = le32_to_cpu(*ih->wptr_cpu);\n\n\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\tgoto out;\n\n\t \n\twptr = RREG32(mmIH_RB_WPTR);\n\n\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\tgoto out;\n\n\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);\n\n\t \n\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\twptr, ih->rptr, (wptr + 16) & ih->ptr_mask);\n\tih->rptr = (wptr + 16) & ih->ptr_mask;\n\ttmp = RREG32(mmIH_RB_CNTL);\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\n\tWREG32(mmIH_RB_CNTL, tmp);\n\n\nout:\n\treturn (wptr & ih->ptr_mask);\n}\n\n \nstatic void cz_ih_decode_iv(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_ih_ring *ih,\n\t\t\t    struct amdgpu_iv_entry *entry)\n{\n\t \n\tu32 ring_index = ih->rptr >> 2;\n\tuint32_t dw[4];\n\n\tdw[0] = le32_to_cpu(ih->ring[ring_index + 0]);\n\tdw[1] = le32_to_cpu(ih->ring[ring_index + 1]);\n\tdw[2] = le32_to_cpu(ih->ring[ring_index + 2]);\n\tdw[3] = le32_to_cpu(ih->ring[ring_index + 3]);\n\n\tentry->client_id = AMDGPU_IRQ_CLIENTID_LEGACY;\n\tentry->src_id = dw[0] & 0xff;\n\tentry->src_data[0] = dw[1] & 0xfffffff;\n\tentry->ring_id = dw[2] & 0xff;\n\tentry->vmid = (dw[2] >> 8) & 0xff;\n\tentry->pasid = (dw[2] >> 16) & 0xffff;\n\n\t \n\tih->rptr += 16;\n}\n\n \nstatic void cz_ih_set_rptr(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_ih_ring *ih)\n{\n\tWREG32(mmIH_RB_RPTR, ih->rptr);\n}\n\nstatic int cz_ih_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint ret;\n\n\tret = amdgpu_irq_add_domain(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tcz_ih_set_interrupt_funcs(adev);\n\n\treturn 0;\n}\n\nstatic int cz_ih_sw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih, 64 * 1024, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_init(adev);\n\n\treturn r;\n}\n\nstatic int cz_ih_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_fini_sw(adev);\n\tamdgpu_irq_remove_domain(adev);\n\n\treturn 0;\n}\n\nstatic int cz_ih_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = cz_ih_irq_init(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int cz_ih_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tcz_ih_irq_disable(adev);\n\n\treturn 0;\n}\n\nstatic int cz_ih_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn cz_ih_hw_fini(adev);\n}\n\nstatic int cz_ih_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn cz_ih_hw_init(adev);\n}\n\nstatic bool cz_ih_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 tmp = RREG32(mmSRBM_STATUS);\n\n\tif (REG_GET_FIELD(tmp, SRBM_STATUS, IH_BUSY))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int cz_ih_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tu32 tmp;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(mmSRBM_STATUS);\n\t\tif (!REG_GET_FIELD(tmp, SRBM_STATUS, IH_BUSY))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int cz_ih_soft_reset(void *handle)\n{\n\tu32 srbm_soft_reset = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 tmp = RREG32(mmSRBM_STATUS);\n\n\tif (tmp & SRBM_STATUS__IH_BUSY_MASK)\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET,\n\t\t\t\t\t\tSOFT_RESET_IH, 1);\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(adev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\t \n\t\tudelay(50);\n\t}\n\n\treturn 0;\n}\n\nstatic int cz_ih_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\t\n\treturn 0;\n}\n\nstatic int cz_ih_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\t\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs cz_ih_ip_funcs = {\n\t.name = \"cz_ih\",\n\t.early_init = cz_ih_early_init,\n\t.late_init = NULL,\n\t.sw_init = cz_ih_sw_init,\n\t.sw_fini = cz_ih_sw_fini,\n\t.hw_init = cz_ih_hw_init,\n\t.hw_fini = cz_ih_hw_fini,\n\t.suspend = cz_ih_suspend,\n\t.resume = cz_ih_resume,\n\t.is_idle = cz_ih_is_idle,\n\t.wait_for_idle = cz_ih_wait_for_idle,\n\t.soft_reset = cz_ih_soft_reset,\n\t.set_clockgating_state = cz_ih_set_clockgating_state,\n\t.set_powergating_state = cz_ih_set_powergating_state,\n};\n\nstatic const struct amdgpu_ih_funcs cz_ih_funcs = {\n\t.get_wptr = cz_ih_get_wptr,\n\t.decode_iv = cz_ih_decode_iv,\n\t.set_rptr = cz_ih_set_rptr\n};\n\nstatic void cz_ih_set_interrupt_funcs(struct amdgpu_device *adev)\n{\n\tadev->irq.ih_funcs = &cz_ih_funcs;\n}\n\nconst struct amdgpu_ip_block_version cz_ih_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_IH,\n\t.major = 3,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &cz_ih_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}