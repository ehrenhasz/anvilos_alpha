{
  "module_name": "gfx_v7_0.c",
  "hash_id": "11e1cb6f641579823e94985950f62fcc41e1d89cfbc261460e33a986f058e08e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_ih.h\"\n#include \"amdgpu_gfx.h\"\n#include \"cikd.h\"\n#include \"cik.h\"\n#include \"cik_structs.h\"\n#include \"atom.h\"\n#include \"amdgpu_ucode.h\"\n#include \"clearstate_ci.h\"\n\n#include \"dce/dce_8_0_d.h\"\n#include \"dce/dce_8_0_sh_mask.h\"\n\n#include \"bif/bif_4_1_d.h\"\n#include \"bif/bif_4_1_sh_mask.h\"\n\n#include \"gca/gfx_7_0_d.h\"\n#include \"gca/gfx_7_2_enum.h\"\n#include \"gca/gfx_7_2_sh_mask.h\"\n\n#include \"gmc/gmc_7_0_d.h\"\n#include \"gmc/gmc_7_0_sh_mask.h\"\n\n#include \"oss/oss_2_0_d.h\"\n#include \"oss/oss_2_0_sh_mask.h\"\n\n#define NUM_SIMD_PER_CU 0x4  \n\n#define GFX7_NUM_GFX_RINGS     1\n#define GFX7_MEC_HPD_SIZE      2048\n\nstatic void gfx_v7_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void gfx_v7_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic void gfx_v7_0_set_gds_init(struct amdgpu_device *adev);\n\nMODULE_FIRMWARE(\"amdgpu/bonaire_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/bonaire_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/bonaire_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/bonaire_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/bonaire_mec.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/hawaii_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/hawaii_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/hawaii_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/hawaii_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/hawaii_mec.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/kaveri_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/kaveri_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/kaveri_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/kaveri_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/kaveri_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/kaveri_mec2.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/kabini_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/kabini_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/kabini_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/kabini_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/kabini_mec.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/mullins_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/mullins_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/mullins_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/mullins_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/mullins_mec.bin\");\n\nstatic const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] = {\n\t{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},\n\t{mmGDS_VMID1_BASE, mmGDS_VMID1_SIZE, mmGDS_GWS_VMID1, mmGDS_OA_VMID1},\n\t{mmGDS_VMID2_BASE, mmGDS_VMID2_SIZE, mmGDS_GWS_VMID2, mmGDS_OA_VMID2},\n\t{mmGDS_VMID3_BASE, mmGDS_VMID3_SIZE, mmGDS_GWS_VMID3, mmGDS_OA_VMID3},\n\t{mmGDS_VMID4_BASE, mmGDS_VMID4_SIZE, mmGDS_GWS_VMID4, mmGDS_OA_VMID4},\n\t{mmGDS_VMID5_BASE, mmGDS_VMID5_SIZE, mmGDS_GWS_VMID5, mmGDS_OA_VMID5},\n\t{mmGDS_VMID6_BASE, mmGDS_VMID6_SIZE, mmGDS_GWS_VMID6, mmGDS_OA_VMID6},\n\t{mmGDS_VMID7_BASE, mmGDS_VMID7_SIZE, mmGDS_GWS_VMID7, mmGDS_OA_VMID7},\n\t{mmGDS_VMID8_BASE, mmGDS_VMID8_SIZE, mmGDS_GWS_VMID8, mmGDS_OA_VMID8},\n\t{mmGDS_VMID9_BASE, mmGDS_VMID9_SIZE, mmGDS_GWS_VMID9, mmGDS_OA_VMID9},\n\t{mmGDS_VMID10_BASE, mmGDS_VMID10_SIZE, mmGDS_GWS_VMID10, mmGDS_OA_VMID10},\n\t{mmGDS_VMID11_BASE, mmGDS_VMID11_SIZE, mmGDS_GWS_VMID11, mmGDS_OA_VMID11},\n\t{mmGDS_VMID12_BASE, mmGDS_VMID12_SIZE, mmGDS_GWS_VMID12, mmGDS_OA_VMID12},\n\t{mmGDS_VMID13_BASE, mmGDS_VMID13_SIZE, mmGDS_GWS_VMID13, mmGDS_OA_VMID13},\n\t{mmGDS_VMID14_BASE, mmGDS_VMID14_SIZE, mmGDS_GWS_VMID14, mmGDS_OA_VMID14},\n\t{mmGDS_VMID15_BASE, mmGDS_VMID15_SIZE, mmGDS_GWS_VMID15, mmGDS_OA_VMID15}\n};\n\nstatic const u32 spectre_rlc_save_restore_register_list[] = {\n\t(0x0e00 << 16) | (0xc12c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc140 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc150 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc15c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc168 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc170 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc178 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc204 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8228 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x829c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x869c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x98f8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc260 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c000 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c00c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8900 >> 2),\n\t0x00000000,\n\t0x3,\n\t(0x0e00 << 16) | (0xc130 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc134 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc208 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc264 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc268 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc26c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc270 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc274 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc278 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc27c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc280 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc284 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc288 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc28c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc290 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc294 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc298 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc29c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2ac  >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x301d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30238 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30250 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30254 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30258 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3025c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc99c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9834 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bf0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bcc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8b24 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30a04 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a10 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a14 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a2c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc704 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc708 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc768 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc770 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc774 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc778 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc77c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc780 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc784 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc788 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc78c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc798 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc79c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a0 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a4 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a8 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7ac >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7b0 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9100 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c010 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92ac >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92cc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c04 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c38 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c3c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xae00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9604 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac08 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac0c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac58 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac68 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac6c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac70 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac74 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac78 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac80 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac84 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac88 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac8c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x970c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9714 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9718 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x971c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88bc >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8980 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30938 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3093c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30940 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30904 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c210 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c214 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c218 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8904 >> 2),\n\t0x00000000,\n\t0x5,\n\t(0x0e00 << 16) | (0x8c28 >> 2),\n\t(0x0e00 << 16) | (0x8c2c >> 2),\n\t(0x0e00 << 16) | (0x8c30 >> 2),\n\t(0x0e00 << 16) | (0x8c34 >> 2),\n\t(0x0e00 << 16) | (0x9600 >> 2),\n};\n\nstatic const u32 kalindi_rlc_save_restore_register_list[] = {\n\t(0x0e00 << 16) | (0xc12c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc140 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc150 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc15c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc168 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc170 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc204 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8228 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x829c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x869c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x98f8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc260 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c000 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c00c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8900 >> 2),\n\t0x00000000,\n\t0x3,\n\t(0x0e00 << 16) | (0xc130 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc134 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc208 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc264 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc268 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc26c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc270 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc274 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc28c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc290 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc294 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc298 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2ac >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x301d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30238 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30250 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30254 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30258 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3025c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc99c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9834 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bf0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bcc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8b24 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30a04 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a10 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a14 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a2c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc704 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc708 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc768 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc770 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc774 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc798 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc79c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9100 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c010 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c04 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c38 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c3c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xae00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9604 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac08 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac0c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac58 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac68 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac6c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac70 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac74 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac78 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac80 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac84 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac88 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac8c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x970c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9714 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9718 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x971c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88bc >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8980 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30938 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3093c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30940 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30904 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3e1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c210 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c214 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c218 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8904 >> 2),\n\t0x00000000,\n\t0x5,\n\t(0x0e00 << 16) | (0x8c28 >> 2),\n\t(0x0e00 << 16) | (0x8c2c >> 2),\n\t(0x0e00 << 16) | (0x8c30 >> 2),\n\t(0x0e00 << 16) | (0x8c34 >> 2),\n\t(0x0e00 << 16) | (0x9600 >> 2),\n};\n\nstatic u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);\nstatic void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);\nstatic void gfx_v7_0_init_pg(struct amdgpu_device *adev);\nstatic void gfx_v7_0_get_cu_info(struct amdgpu_device *adev);\n\nstatic void gfx_v7_0_free_microcode(struct amdgpu_device *adev)\n{\n\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\tamdgpu_ucode_release(&adev->gfx.ce_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec2_fw);\n\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n}\n\n \n \nstatic int gfx_v7_0_init_microcode(struct amdgpu_device *adev)\n{\n\tconst char *chip_name;\n\tchar fw_name[30];\n\tint err;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\tchip_name = \"bonaire\";\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tchip_name = \"hawaii\";\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tchip_name = \"kaveri\";\n\t\tbreak;\n\tcase CHIP_KABINI:\n\t\tchip_name = \"kabini\";\n\t\tbreak;\n\tcase CHIP_MULLINS:\n\t\tchip_name = \"mullins\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ce.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.ce_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\tif (adev->asic_type == CHIP_KAVERI) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec2.bin\", chip_name);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec2_fw, fw_name);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.rlc_fw, fw_name);\n\tif (err)\n\t\tgoto out;\nout:\n\tif (err) {\n\t\tpr_err(\"gfx7: Failed to load firmware \\\"%s\\\"\\n\", fw_name);\n\t\tgfx_v7_0_free_microcode(adev);\n\t}\n\treturn err;\n}\n\n \nstatic void gfx_v7_0_tiling_mode_table_init(struct amdgpu_device *adev)\n{\n\tconst u32 num_tile_mode_states =\n\t\t\tARRAY_SIZE(adev->gfx.config.tile_mode_array);\n\tconst u32 num_secondary_tile_mode_states =\n\t\t\tARRAY_SIZE(adev->gfx.config.macrotile_mode_array);\n\tu32 reg_offset, split_equal_to_row_size;\n\tuint32_t *tile, *macrotile;\n\n\ttile = adev->gfx.config.tile_mode_array;\n\tmacrotile = adev->gfx.config.macrotile_mode_array;\n\n\tswitch (adev->gfx.config.mem_row_size_in_kb) {\n\tcase 1:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_1KB;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_2KB;\n\t\tbreak;\n\tcase 4:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_4KB;\n\t\tbreak;\n\t}\n\n\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\ttile[reg_offset] = 0;\n\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\tmacrotile[reg_offset] = 0;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[7] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[12] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[17] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[21] =  (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[23] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[30] = (TILE_SPLIT(split_equal_to_row_size));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING));\n\t\ttile[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[23] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_KAVERI:\n\tcase CHIP_MULLINS:\n\tdefault:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[7] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[12] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[15] = (ARRAY_MODE(ARRAY_3D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[17] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[18] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[19] = (ARRAY_MODE(ARRAY_1D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING));\n\t\ttile[20] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[21] = (ARRAY_MODE(ARRAY_3D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[22] = (ARRAY_MODE(ARRAY_PRT_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[23] = (TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[24] = (ARRAY_MODE(ARRAY_2D_TILED_THICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[25] = (ARRAY_MODE(ARRAY_2D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[26] = (ARRAY_MODE(ARRAY_3D_TILED_XTHICK) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THICK_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_1));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_8));\n\t\ttile[30] = (TILE_SPLIT(split_equal_to_row_size));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tif (reg_offset != 7)\n\t\t\t\tWREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);\n\t\tbreak;\n\t}\n}\n\n \nstatic void gfx_v7_0_select_se_sh(struct amdgpu_device *adev,\n\t\t\t\t  u32 se_num, u32 sh_num, u32 instance,\n\t\t\t\t  int xcc_id)\n{\n\tu32 data;\n\n\tif (instance == 0xffffffff)\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_INDEX, instance);\n\n\tif ((se_num == 0xffffffff) && (sh_num == 0xffffffff))\n\t\tdata |= GRBM_GFX_INDEX__SH_BROADCAST_WRITES_MASK |\n\t\t\tGRBM_GFX_INDEX__SE_BROADCAST_WRITES_MASK;\n\telse if (se_num == 0xffffffff)\n\t\tdata |= GRBM_GFX_INDEX__SE_BROADCAST_WRITES_MASK |\n\t\t\t(sh_num << GRBM_GFX_INDEX__SH_INDEX__SHIFT);\n\telse if (sh_num == 0xffffffff)\n\t\tdata |= GRBM_GFX_INDEX__SH_BROADCAST_WRITES_MASK |\n\t\t\t(se_num << GRBM_GFX_INDEX__SE_INDEX__SHIFT);\n\telse\n\t\tdata |= (sh_num << GRBM_GFX_INDEX__SH_INDEX__SHIFT) |\n\t\t\t(se_num << GRBM_GFX_INDEX__SE_INDEX__SHIFT);\n\tWREG32(mmGRBM_GFX_INDEX, data);\n}\n\n \nstatic u32 gfx_v7_0_get_rb_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata = RREG32(mmCC_RB_BACKEND_DISABLE);\n\tdata |= RREG32(mmGC_USER_RB_BACKEND_DISABLE);\n\n\tdata &= CC_RB_BACKEND_DISABLE__BACKEND_DISABLE_MASK;\n\tdata >>= GC_USER_RB_BACKEND_DISABLE__BACKEND_DISABLE__SHIFT;\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_backends_per_se /\n\t\t\t\t\t adev->gfx.config.max_sh_per_se);\n\n\treturn (~data) & mask;\n}\n\nstatic void\ngfx_v7_0_raster_config(struct amdgpu_device *adev, u32 *rconf, u32 *rconf1)\n{\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\t*rconf |= RB_MAP_PKR0(2) | RB_XSEL2(1) | SE_MAP(2) |\n\t\t\t  SE_XSEL(1) | SE_YSEL(1);\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\t*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |\n\t\t\t  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |\n\t\t\t  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |\n\t\t\t  SE_YSEL(3);\n\t\t*rconf1 |= SE_PAIR_MAP(2) | SE_PAIR_XSEL(3) |\n\t\t\t   SE_PAIR_YSEL(2);\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\t*rconf |= RB_MAP_PKR0(2);\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\t\t*rconf |= 0x0;\n\t\t*rconf1 |= 0x0;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unknown asic: 0x%x\\n\", adev->asic_type);\n\t\tbreak;\n\t}\n}\n\nstatic void\ngfx_v7_0_write_harvested_raster_configs(struct amdgpu_device *adev,\n\t\t\t\t\tu32 raster_config, u32 raster_config_1,\n\t\t\t\t\tunsigned rb_mask, unsigned num_rb)\n{\n\tunsigned sh_per_se = max_t(unsigned, adev->gfx.config.max_sh_per_se, 1);\n\tunsigned num_se = max_t(unsigned, adev->gfx.config.max_shader_engines, 1);\n\tunsigned rb_per_pkr = min_t(unsigned, num_rb / num_se / sh_per_se, 2);\n\tunsigned rb_per_se = num_rb / num_se;\n\tunsigned se_mask[4];\n\tunsigned se;\n\n\tse_mask[0] = ((1 << rb_per_se) - 1) & rb_mask;\n\tse_mask[1] = (se_mask[0] << rb_per_se) & rb_mask;\n\tse_mask[2] = (se_mask[1] << rb_per_se) & rb_mask;\n\tse_mask[3] = (se_mask[2] << rb_per_se) & rb_mask;\n\n\tWARN_ON(!(num_se == 1 || num_se == 2 || num_se == 4));\n\tWARN_ON(!(sh_per_se == 1 || sh_per_se == 2));\n\tWARN_ON(!(rb_per_pkr == 1 || rb_per_pkr == 2));\n\n\tif ((num_se > 2) && ((!se_mask[0] && !se_mask[1]) ||\n\t\t\t     (!se_mask[2] && !se_mask[3]))) {\n\t\traster_config_1 &= ~SE_PAIR_MAP_MASK;\n\n\t\tif (!se_mask[0] && !se_mask[1]) {\n\t\t\traster_config_1 |=\n\t\t\t\tSE_PAIR_MAP(RASTER_CONFIG_SE_PAIR_MAP_3);\n\t\t} else {\n\t\t\traster_config_1 |=\n\t\t\t\tSE_PAIR_MAP(RASTER_CONFIG_SE_PAIR_MAP_0);\n\t\t}\n\t}\n\n\tfor (se = 0; se < num_se; se++) {\n\t\tunsigned raster_config_se = raster_config;\n\t\tunsigned pkr0_mask = ((1 << rb_per_pkr) - 1) << (se * rb_per_se);\n\t\tunsigned pkr1_mask = pkr0_mask << rb_per_pkr;\n\t\tint idx = (se / 2) * 2;\n\n\t\tif ((num_se > 1) && (!se_mask[idx] || !se_mask[idx + 1])) {\n\t\t\traster_config_se &= ~SE_MAP_MASK;\n\n\t\t\tif (!se_mask[idx]) {\n\t\t\t\traster_config_se |= SE_MAP(RASTER_CONFIG_SE_MAP_3);\n\t\t\t} else {\n\t\t\t\traster_config_se |= SE_MAP(RASTER_CONFIG_SE_MAP_0);\n\t\t\t}\n\t\t}\n\n\t\tpkr0_mask &= rb_mask;\n\t\tpkr1_mask &= rb_mask;\n\t\tif (rb_per_se > 2 && (!pkr0_mask || !pkr1_mask)) {\n\t\t\traster_config_se &= ~PKR_MAP_MASK;\n\n\t\t\tif (!pkr0_mask) {\n\t\t\t\traster_config_se |= PKR_MAP(RASTER_CONFIG_PKR_MAP_3);\n\t\t\t} else {\n\t\t\t\traster_config_se |= PKR_MAP(RASTER_CONFIG_PKR_MAP_0);\n\t\t\t}\n\t\t}\n\n\t\tif (rb_per_se >= 2) {\n\t\t\tunsigned rb0_mask = 1 << (se * rb_per_se);\n\t\t\tunsigned rb1_mask = rb0_mask << 1;\n\n\t\t\trb0_mask &= rb_mask;\n\t\t\trb1_mask &= rb_mask;\n\t\t\tif (!rb0_mask || !rb1_mask) {\n\t\t\t\traster_config_se &= ~RB_MAP_PKR0_MASK;\n\n\t\t\t\tif (!rb0_mask) {\n\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\tRB_MAP_PKR0(RASTER_CONFIG_RB_MAP_3);\n\t\t\t\t} else {\n\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\tRB_MAP_PKR0(RASTER_CONFIG_RB_MAP_0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rb_per_se > 2) {\n\t\t\t\trb0_mask = 1 << (se * rb_per_se + rb_per_pkr);\n\t\t\t\trb1_mask = rb0_mask << 1;\n\t\t\t\trb0_mask &= rb_mask;\n\t\t\t\trb1_mask &= rb_mask;\n\t\t\t\tif (!rb0_mask || !rb1_mask) {\n\t\t\t\t\traster_config_se &= ~RB_MAP_PKR1_MASK;\n\n\t\t\t\t\tif (!rb0_mask) {\n\t\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\t\tRB_MAP_PKR1(RASTER_CONFIG_RB_MAP_3);\n\t\t\t\t\t} else {\n\t\t\t\t\t\traster_config_se |=\n\t\t\t\t\t\t\tRB_MAP_PKR1(RASTER_CONFIG_RB_MAP_0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tgfx_v7_0_select_se_sh(adev, se, 0xffffffff, 0xffffffff, 0);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG, raster_config_se);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG_1, raster_config_1);\n\t}\n\n\t \n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n}\n\n \nstatic void gfx_v7_0_setup_rb(struct amdgpu_device *adev)\n{\n\tint i, j;\n\tu32 data;\n\tu32 raster_config = 0, raster_config_1 = 0;\n\tu32 active_rbs = 0;\n\tu32 rb_bitmap_width_per_sh = adev->gfx.config.max_backends_per_se /\n\t\t\t\t\tadev->gfx.config.max_sh_per_se;\n\tunsigned num_rb_pipes;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v7_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tdata = gfx_v7_0_get_rb_active_bitmap(adev);\n\t\t\tactive_rbs |= data << ((i * adev->gfx.config.max_sh_per_se + j) *\n\t\t\t\t\t       rb_bitmap_width_per_sh);\n\t\t}\n\t}\n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\n\tadev->gfx.config.backend_enable_mask = active_rbs;\n\tadev->gfx.config.num_rbs = hweight32(active_rbs);\n\n\tnum_rb_pipes = min_t(unsigned, adev->gfx.config.max_backends_per_se *\n\t\t\t     adev->gfx.config.max_shader_engines, 16);\n\n\tgfx_v7_0_raster_config(adev, &raster_config, &raster_config_1);\n\n\tif (!adev->gfx.config.backend_enable_mask ||\n\t\t\tadev->gfx.config.num_rbs >= num_rb_pipes) {\n\t\tWREG32(mmPA_SC_RASTER_CONFIG, raster_config);\n\t\tWREG32(mmPA_SC_RASTER_CONFIG_1, raster_config_1);\n\t} else {\n\t\tgfx_v7_0_write_harvested_raster_configs(adev, raster_config, raster_config_1,\n\t\t\t\t\t\t\tadev->gfx.config.backend_enable_mask,\n\t\t\t\t\t\t\tnum_rb_pipes);\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v7_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tadev->gfx.config.rb_config[i][j].rb_backend_disable =\n\t\t\t\tRREG32(mmCC_RB_BACKEND_DISABLE);\n\t\t\tadev->gfx.config.rb_config[i][j].user_rb_backend_disable =\n\t\t\t\tRREG32(mmGC_USER_RB_BACKEND_DISABLE);\n\t\t\tadev->gfx.config.rb_config[i][j].raster_config =\n\t\t\t\tRREG32(mmPA_SC_RASTER_CONFIG);\n\t\t\tadev->gfx.config.rb_config[i][j].raster_config_1 =\n\t\t\t\tRREG32(mmPA_SC_RASTER_CONFIG_1);\n\t\t}\n\t}\n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n}\n\n#define DEFAULT_SH_MEM_BASES\t(0x6000)\n \nstatic void gfx_v7_0_init_compute_vmid(struct amdgpu_device *adev)\n{\n\tint i;\n\tuint32_t sh_mem_config;\n\tuint32_t sh_mem_bases;\n\n\t \n\tsh_mem_bases = DEFAULT_SH_MEM_BASES | (DEFAULT_SH_MEM_BASES << 16);\n\tsh_mem_config = SH_MEM_ALIGNMENT_MODE_UNALIGNED <<\n\t\t\tSH_MEM_CONFIG__ALIGNMENT_MODE__SHIFT;\n\tsh_mem_config |= MTYPE_NONCACHED << SH_MEM_CONFIG__DEFAULT_MTYPE__SHIFT;\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tcik_srbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tWREG32(mmSH_MEM_CONFIG, sh_mem_config);\n\t\tWREG32(mmSH_MEM_APE1_BASE, 1);\n\t\tWREG32(mmSH_MEM_APE1_LIMIT, 0);\n\t\tWREG32(mmSH_MEM_BASES, sh_mem_bases);\n\t}\n\tcik_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tWREG32(amdgpu_gds_reg_offset[i].mem_base, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].mem_size, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].gws, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[i].oa, 0);\n\t}\n}\n\nstatic void gfx_v7_0_init_gds_vmid(struct amdgpu_device *adev)\n{\n\tint vmid;\n\n\t \n\tfor (vmid = 1; vmid < AMDGPU_NUM_VMID; vmid++) {\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].mem_base, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].mem_size, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].gws, 0);\n\t\tWREG32(amdgpu_gds_reg_offset[vmid].oa, 0);\n\t}\n}\n\nstatic void gfx_v7_0_config_init(struct amdgpu_device *adev)\n{\n\tadev->gfx.config.double_offchip_lds_buf = 1;\n}\n\n \nstatic void gfx_v7_0_constants_init(struct amdgpu_device *adev)\n{\n\tu32 sh_mem_cfg, sh_static_mem_cfg, sh_mem_base;\n\tu32 tmp;\n\tint i;\n\n\tWREG32(mmGRBM_CNTL, (0xff << GRBM_CNTL__READ_TIMEOUT__SHIFT));\n\n\tWREG32(mmGB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmHDP_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmDMIF_ADDR_CALC, adev->gfx.config.gb_addr_config);\n\n\tgfx_v7_0_tiling_mode_table_init(adev);\n\n\tgfx_v7_0_setup_rb(adev);\n\tgfx_v7_0_get_cu_info(adev);\n\tgfx_v7_0_config_init(adev);\n\n\t \n\tWREG32(mmCP_MEQ_THRESHOLDS,\n\t       (0x30 << CP_MEQ_THRESHOLDS__MEQ1_START__SHIFT) |\n\t       (0x60 << CP_MEQ_THRESHOLDS__MEQ2_START__SHIFT));\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\t \n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\n\t \n\t \n\tsh_mem_cfg = REG_SET_FIELD(0, SH_MEM_CONFIG, ALIGNMENT_MODE,\n\t\t\t\t   SH_MEM_ALIGNMENT_MODE_UNALIGNED);\n\tsh_mem_cfg = REG_SET_FIELD(sh_mem_cfg, SH_MEM_CONFIG, DEFAULT_MTYPE,\n\t\t\t\t   MTYPE_NC);\n\tsh_mem_cfg = REG_SET_FIELD(sh_mem_cfg, SH_MEM_CONFIG, APE1_MTYPE,\n\t\t\t\t   MTYPE_UC);\n\tsh_mem_cfg = REG_SET_FIELD(sh_mem_cfg, SH_MEM_CONFIG, PRIVATE_ATC, 0);\n\n\tsh_static_mem_cfg = REG_SET_FIELD(0, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   SWIZZLE_ENABLE, 1);\n\tsh_static_mem_cfg = REG_SET_FIELD(sh_static_mem_cfg, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   ELEMENT_SIZE, 1);\n\tsh_static_mem_cfg = REG_SET_FIELD(sh_static_mem_cfg, SH_STATIC_MEM_CONFIG,\n\t\t\t\t   INDEX_STRIDE, 3);\n\tWREG32(mmSH_STATIC_MEM_CONFIG, sh_static_mem_cfg);\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->vm_manager.id_mgr[0].num_ids; i++) {\n\t\tif (i == 0)\n\t\t\tsh_mem_base = 0;\n\t\telse\n\t\t\tsh_mem_base = adev->gmc.shared_aperture_start >> 48;\n\t\tcik_srbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tWREG32(mmSH_MEM_CONFIG, sh_mem_cfg);\n\t\tWREG32(mmSH_MEM_APE1_BASE, 1);\n\t\tWREG32(mmSH_MEM_APE1_LIMIT, 0);\n\t\tWREG32(mmSH_MEM_BASES, sh_mem_base);\n\t}\n\tcik_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\tgfx_v7_0_init_compute_vmid(adev);\n\tgfx_v7_0_init_gds_vmid(adev);\n\n\tWREG32(mmSX_DEBUG_1, 0x20);\n\n\tWREG32(mmTA_CNTL_AUX, 0x00010000);\n\n\ttmp = RREG32(mmSPI_CONFIG_CNTL);\n\ttmp |= 0x03000000;\n\tWREG32(mmSPI_CONFIG_CNTL, tmp);\n\n\tWREG32(mmSQ_CONFIG, 1);\n\n\tWREG32(mmDB_DEBUG, 0);\n\n\ttmp = RREG32(mmDB_DEBUG2) & ~0xf00fffff;\n\ttmp |= 0x00000400;\n\tWREG32(mmDB_DEBUG2, tmp);\n\n\ttmp = RREG32(mmDB_DEBUG3) & ~0x0002021c;\n\ttmp |= 0x00020200;\n\tWREG32(mmDB_DEBUG3, tmp);\n\n\ttmp = RREG32(mmCB_HW_CONTROL) & ~0x00010000;\n\ttmp |= 0x00018208;\n\tWREG32(mmCB_HW_CONTROL, tmp);\n\n\tWREG32(mmSPI_CONFIG_CNTL_1, (4 << SPI_CONFIG_CNTL_1__VTX_DONE_DELAY__SHIFT));\n\n\tWREG32(mmPA_SC_FIFO_SIZE,\n\t\t((adev->gfx.config.sc_prim_fifo_size_frontend << PA_SC_FIFO_SIZE__SC_FRONTEND_PRIM_FIFO_SIZE__SHIFT) |\n\t\t(adev->gfx.config.sc_prim_fifo_size_backend << PA_SC_FIFO_SIZE__SC_BACKEND_PRIM_FIFO_SIZE__SHIFT) |\n\t\t(adev->gfx.config.sc_hiz_tile_fifo_size << PA_SC_FIFO_SIZE__SC_HIZ_TILE_FIFO_SIZE__SHIFT) |\n\t\t(adev->gfx.config.sc_earlyz_tile_fifo_size << PA_SC_FIFO_SIZE__SC_EARLYZ_TILE_FIFO_SIZE__SHIFT)));\n\n\tWREG32(mmVGT_NUM_INSTANCES, 1);\n\n\tWREG32(mmCP_PERFMON_CNTL, 0);\n\n\tWREG32(mmSQ_CONFIG, 0);\n\n\tWREG32(mmPA_SC_FORCE_EOV_MAX_CNTS,\n\t\t((4095 << PA_SC_FORCE_EOV_MAX_CNTS__FORCE_EOV_MAX_CLK_CNT__SHIFT) |\n\t\t(255 << PA_SC_FORCE_EOV_MAX_CNTS__FORCE_EOV_MAX_REZ_CNT__SHIFT)));\n\n\tWREG32(mmVGT_CACHE_INVALIDATION,\n\t\t(VC_AND_TC << VGT_CACHE_INVALIDATION__CACHE_INVALIDATION__SHIFT) |\n\t\t(ES_AND_GS_AUTO << VGT_CACHE_INVALIDATION__AUTO_INVLD_EN__SHIFT));\n\n\tWREG32(mmVGT_GS_VERTEX_REUSE, 16);\n\tWREG32(mmPA_SC_LINE_STIPPLE_STATE, 0);\n\n\tWREG32(mmPA_CL_ENHANCE, PA_CL_ENHANCE__CLIP_VTX_REORDER_ENA_MASK |\n\t\t\t(3 << PA_CL_ENHANCE__NUM_CLIP_SEQ__SHIFT));\n\tWREG32(mmPA_SC_ENHANCE, PA_SC_ENHANCE__ENABLE_PA_SC_OUT_OF_ORDER_MASK);\n\n\ttmp = RREG32(mmSPI_ARB_PRIORITY);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS0, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS1, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS2, 2);\n\ttmp = REG_SET_FIELD(tmp, SPI_ARB_PRIORITY, PIPE_ORDER_TS3, 2);\n\tWREG32(mmSPI_ARB_PRIORITY, tmp);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tudelay(50);\n}\n\n \nstatic int gfx_v7_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(mmSCRATCH_REG0, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\tamdgpu_ring_write(ring, mmSCRATCH_REG0 - PACKET3_SET_UCONFIG_REG_START);\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(mmSCRATCH_REG0);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\treturn r;\n}\n\n \nstatic void gfx_v7_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\n{\n\tu32 ref_and_mask;\n\tint usepfp = ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE ? 0 : 1;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) {\n\t\tswitch (ring->me) {\n\t\tcase 1:\n\t\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP2_MASK << ring->pipe;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP6_MASK << ring->pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tref_and_mask = GPU_HDP_FLUSH_DONE__CP0_MASK;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_OPERATION(1) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(usepfp)));    \n\tamdgpu_ring_write(ring, mmGPU_HDP_FLUSH_REQ);\n\tamdgpu_ring_write(ring, mmGPU_HDP_FLUSH_DONE);\n\tamdgpu_ring_write(ring, ref_and_mask);\n\tamdgpu_ring_write(ring, ref_and_mask);\n\tamdgpu_ring_write(ring, 0x20);  \n}\n\nstatic void gfx_v7_0_ring_emit_vgt_flush(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE, 0));\n\tamdgpu_ring_write(ring, EVENT_TYPE(VS_PARTIAL_FLUSH) |\n\t\tEVENT_INDEX(4));\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE, 0));\n\tamdgpu_ring_write(ring, EVENT_TYPE(VGT_FLUSH) |\n\t\tEVENT_INDEX(0));\n}\n\n \nstatic void gfx_v7_0_ring_emit_fence_gfx(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t\t u64 seq, unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, (upper_32_bits(addr) & 0xffff) |\n\t\t\t\tDATA_SEL(1) | INT_SEL(0));\n\tamdgpu_ring_write(ring, lower_32_bits(seq - 1));\n\tamdgpu_ring_write(ring, upper_32_bits(seq - 1));\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, (upper_32_bits(addr) & 0xffff) |\n\t\t\t\tDATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n}\n\n \nstatic void gfx_v7_0_ring_emit_fence_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t     u64 addr, u64 seq,\n\t\t\t\t\t     unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, 5));\n\tamdgpu_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));\n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n}\n\n \n \nstatic void gfx_v7_0_ring_emit_ib_gfx(struct amdgpu_ring *ring,\n\t\t\t\t\tstruct amdgpu_job *job,\n\t\t\t\t\tstruct amdgpu_ib *ib,\n\t\t\t\t\tuint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 header, control = 0;\n\n\t \n\tif (flags & AMDGPU_HAVE_CTX_SWITCH) {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n\n\tif (ib->flags & AMDGPU_IB_FLAG_CE)\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER_CONST, 2);\n\telse\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\n\tcontrol |= ib->length_dw | (vmid << 24);\n\n\tamdgpu_ring_write(ring, header);\n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v7_0_ring_emit_ib_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t\t  uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);\n\n\t \n\tif (ib->flags & AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID) {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tamdgpu_ring_write(ring, mmGDS_COMPUTE_MAX_WAVE_ID - PACKET3_SET_CONFIG_REG_START);\n\t\tamdgpu_ring_write(ring, ring->adev->gds.gds_compute_max_wave_id);\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t\t\t  (2 << 0) |\n#endif\n\t\t\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v7_ring_emit_cntxcntl(struct amdgpu_ring *ring, uint32_t flags)\n{\n\tuint32_t dw2 = 0;\n\n\tdw2 |= 0x80000000;  \n\tif (flags & AMDGPU_HAVE_CTX_SWITCH) {\n\t\tgfx_v7_0_ring_emit_vgt_flush(ring);\n\t\t \n\t\tdw2 |= 0x8001;\n\t\t \n\t\tdw2 |= 0x01000000;\n\t\t \n\t\tdw2 |= 0x10002;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, dw2);\n\tamdgpu_ring_write(ring, 0);\n}\n\n \nstatic int gfx_v7_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\tuint32_t tmp = 0;\n\tlong r;\n\n\tWREG32(mmSCRATCH_REG0, 0xCAFEDEAD);\n\tmemset(&ib, 0, sizeof(ib));\n\tr = amdgpu_ib_get(adev, NULL, 256, AMDGPU_IB_POOL_DIRECT, &ib);\n\tif (r)\n\t\treturn r;\n\n\tib.ptr[0] = PACKET3(PACKET3_SET_UCONFIG_REG, 1);\n\tib.ptr[1] = mmSCRATCH_REG0 - PACKET3_SET_UCONFIG_REG_START;\n\tib.ptr[2] = 0xDEADBEEF;\n\tib.length_dw = 3;\n\n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r)\n\t\tgoto error;\n\n\tr = dma_fence_wait_timeout(f, false, timeout);\n\tif (r == 0) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto error;\n\t} else if (r < 0) {\n\t\tgoto error;\n\t}\n\ttmp = RREG32(mmSCRATCH_REG0);\n\tif (tmp == 0xDEADBEEF)\n\t\tr = 0;\n\telse\n\t\tr = -EINVAL;\n\nerror:\n\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\n\treturn r;\n}\n\n \n \nstatic void gfx_v7_0_cp_gfx_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(mmCP_ME_CNTL, 0);\n\telse\n\t\tWREG32(mmCP_ME_CNTL, (CP_ME_CNTL__ME_HALT_MASK |\n\t\t\t\t      CP_ME_CNTL__PFP_HALT_MASK |\n\t\t\t\t      CP_ME_CNTL__CE_HALT_MASK));\n\tudelay(50);\n}\n\n \nstatic int gfx_v7_0_cp_gfx_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v1_0 *pfp_hdr;\n\tconst struct gfx_firmware_header_v1_0 *ce_hdr;\n\tconst struct gfx_firmware_header_v1_0 *me_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tif (!adev->gfx.me_fw || !adev->gfx.pfp_fw || !adev->gfx.ce_fw)\n\t\treturn -EINVAL;\n\n\tpfp_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.pfp_fw->data;\n\tce_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.ce_fw->data;\n\tme_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.me_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&pfp_hdr->header);\n\tamdgpu_ucode_print_gfx_hdr(&ce_hdr->header);\n\tamdgpu_ucode_print_gfx_hdr(&me_hdr->header);\n\tadev->gfx.pfp_fw_version = le32_to_cpu(pfp_hdr->header.ucode_version);\n\tadev->gfx.ce_fw_version = le32_to_cpu(ce_hdr->header.ucode_version);\n\tadev->gfx.me_fw_version = le32_to_cpu(me_hdr->header.ucode_version);\n\tadev->gfx.me_feature_version = le32_to_cpu(me_hdr->ucode_feature_version);\n\tadev->gfx.ce_feature_version = le32_to_cpu(ce_hdr->ucode_feature_version);\n\tadev->gfx.pfp_feature_version = le32_to_cpu(pfp_hdr->ucode_feature_version);\n\n\tgfx_v7_0_cp_gfx_enable(adev, false);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.pfp_fw->data +\n\t\t le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;\n\tWREG32(mmCP_PFP_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32(mmCP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32(mmCP_PFP_UCODE_ADDR, adev->gfx.pfp_fw_version);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.ce_fw->data +\n\t\t le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;\n\tWREG32(mmCP_CE_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32(mmCP_CE_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32(mmCP_CE_UCODE_ADDR, adev->gfx.ce_fw_version);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.me_fw->data +\n\t\t le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;\n\tWREG32(mmCP_ME_RAM_WADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32(mmCP_ME_RAM_DATA, le32_to_cpup(fw_data++));\n\tWREG32(mmCP_ME_RAM_WADDR, adev->gfx.me_fw_version);\n\n\treturn 0;\n}\n\n \nstatic int gfx_v7_0_cp_gfx_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.gfx_ring[0];\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint r, i;\n\n\t \n\tWREG32(mmCP_MAX_CONTEXT, adev->gfx.config.max_hw_contexts - 1);\n\tWREG32(mmCP_ENDIAN_SWAP, 0);\n\tWREG32(mmCP_DEVICE_ID, 1);\n\n\tgfx_v7_0_cp_gfx_enable(adev, true);\n\n\tr = amdgpu_ring_alloc(ring, gfx_v7_0_get_csb_size(adev) + 8);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_BASE, 2));\n\tamdgpu_ring_write(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));\n\tamdgpu_ring_write(ring, 0x8000);\n\tamdgpu_ring_write(ring, 0x8000);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, 0x80000000);\n\tamdgpu_ring_write(ring, 0x80000000);\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t\t\t  PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tamdgpu_ring_write(ring, ext->reg_index - PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tamdgpu_ring_write(ring, ext->extent[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tamdgpu_ring_write(ring, mmPA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tamdgpu_ring_write(ring, adev->gfx.config.rb_config[0][0].raster_config);\n\tamdgpu_ring_write(ring, adev->gfx.config.rb_config[0][0].raster_config_1);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tamdgpu_ring_write(ring, 0x00000316);\n\tamdgpu_ring_write(ring, 0x0000000e);  \n\tamdgpu_ring_write(ring, 0x00000010);  \n\n\tamdgpu_ring_commit(ring);\n\n\treturn 0;\n}\n\n \nstatic int gfx_v7_0_cp_gfx_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tu64 rb_addr, rptr_addr;\n\tint r;\n\n\tWREG32(mmCP_SEM_WAIT_TIMER, 0x0);\n\tif (adev->asic_type != CHIP_HAWAII)\n\t\tWREG32(mmCP_SEM_INCOMPLETE_TIMER_CNTL, 0x0);\n\n\t \n\tWREG32(mmCP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32(mmCP_RB_VMID, 0);\n\n\tWREG32(mmSCRATCH_ADDR, 0);\n\n\t \n\t \n\tring = &adev->gfx.gfx_ring[0];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(AMDGPU_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= 2 << CP_RB0_CNTL__BUF_SWAP__SHIFT;\n#endif\n\tWREG32(mmCP_RB0_CNTL, tmp);\n\n\t \n\tWREG32(mmCP_RB0_CNTL, tmp | CP_RB0_CNTL__RB_RPTR_WR_ENA_MASK);\n\tring->wptr = 0;\n\tWREG32(mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\n\t \n\trptr_addr = ring->rptr_gpu_addr;\n\tWREG32(mmCP_RB0_RPTR_ADDR, lower_32_bits(rptr_addr));\n\tWREG32(mmCP_RB0_RPTR_ADDR_HI, upper_32_bits(rptr_addr) & 0xFF);\n\n\t \n\tWREG32(mmSCRATCH_UMSK, 0);\n\n\tmdelay(1);\n\tWREG32(mmCP_RB0_CNTL, tmp);\n\n\trb_addr = ring->gpu_addr >> 8;\n\tWREG32(mmCP_RB0_BASE, rb_addr);\n\tWREG32(mmCP_RB0_BASE_HI, upper_32_bits(rb_addr));\n\n\t \n\tgfx_v7_0_cp_gfx_start(adev);\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic u64 gfx_v7_0_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\treturn *ring->rptr_cpu_addr;\n}\n\nstatic u64 gfx_v7_0_ring_get_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmCP_RB0_WPTR);\n}\n\nstatic void gfx_v7_0_ring_set_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWREG32(mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\t(void)RREG32(mmCP_RB0_WPTR);\n}\n\nstatic u64 gfx_v7_0_ring_get_wptr_compute(struct amdgpu_ring *ring)\n{\n\t \n\treturn *ring->wptr_cpu_addr;\n}\n\nstatic void gfx_v7_0_ring_set_wptr_compute(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\t*ring->wptr_cpu_addr = lower_32_bits(ring->wptr);\n\tWDOORBELL32(ring->doorbell_index, lower_32_bits(ring->wptr));\n}\n\n \nstatic void gfx_v7_0_cp_compute_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(mmCP_MEC_CNTL, 0);\n\telse\n\t\tWREG32(mmCP_MEC_CNTL, (CP_MEC_CNTL__MEC_ME1_HALT_MASK |\n\t\t\t\t       CP_MEC_CNTL__MEC_ME2_HALT_MASK));\n\tudelay(50);\n}\n\n \nstatic int gfx_v7_0_cp_compute_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v1_0 *mec_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tif (!adev->gfx.mec_fw)\n\t\treturn -EINVAL;\n\n\tmec_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\tamdgpu_ucode_print_gfx_hdr(&mec_hdr->header);\n\tadev->gfx.mec_fw_version = le32_to_cpu(mec_hdr->header.ucode_version);\n\tadev->gfx.mec_feature_version = le32_to_cpu(\n\t\t\t\t\tmec_hdr->ucode_feature_version);\n\n\tgfx_v7_0_cp_compute_enable(adev, false);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.mec_fw->data +\n\t\t le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(mec_hdr->header.ucode_size_bytes) / 4;\n\tWREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);\n\n\tif (adev->asic_type == CHIP_KAVERI) {\n\t\tconst struct gfx_firmware_header_v1_0 *mec2_hdr;\n\n\t\tif (!adev->gfx.mec2_fw)\n\t\t\treturn -EINVAL;\n\n\t\tmec2_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec2_fw->data;\n\t\tamdgpu_ucode_print_gfx_hdr(&mec2_hdr->header);\n\t\tadev->gfx.mec2_fw_version = le32_to_cpu(mec2_hdr->header.ucode_version);\n\t\tadev->gfx.mec2_feature_version = le32_to_cpu(\n\t\t\t\tmec2_hdr->ucode_feature_version);\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(adev->gfx.mec2_fw->data +\n\t\t\t le32_to_cpu(mec2_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(mec2_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(mmCP_MEC_ME2_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(mmCP_MEC_ME2_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(mmCP_MEC_ME2_UCODE_ADDR, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void gfx_v7_0_cp_compute_fini(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\n\t\tamdgpu_bo_free_kernel(&ring->mqd_obj, NULL, NULL);\n\t}\n}\n\nstatic void gfx_v7_0_mec_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.hpd_eop_obj, NULL, NULL);\n}\n\nstatic int gfx_v7_0_mec_init(struct amdgpu_device *adev)\n{\n\tint r;\n\tu32 *hpd;\n\tsize_t mec_hpd_size;\n\n\tbitmap_zero(adev->gfx.mec_bitmap[0].queue_bitmap, AMDGPU_MAX_COMPUTE_QUEUES);\n\n\t \n\tamdgpu_gfx_compute_queue_acquire(adev);\n\n\t \n\tmec_hpd_size = adev->gfx.mec.num_mec * adev->gfx.mec.num_pipe_per_mec\n\t\t* GFX7_MEC_HPD_SIZE * 2;\n\n\tr = amdgpu_bo_create_reserved(adev, mec_hpd_size, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.mec.hpd_eop_obj,\n\t\t\t\t      &adev->gfx.mec.hpd_eop_gpu_addr,\n\t\t\t\t      (void **)&hpd);\n\tif (r) {\n\t\tdev_warn(adev->dev, \"(%d) create, pin or map of HDP EOP bo failed\\n\", r);\n\t\tgfx_v7_0_mec_fini(adev);\n\t\treturn r;\n\t}\n\n\t \n\tmemset(hpd, 0, mec_hpd_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.mec.hpd_eop_obj);\n\tamdgpu_bo_unreserve(adev->gfx.mec.hpd_eop_obj);\n\n\treturn 0;\n}\n\nstruct hqd_registers {\n\tu32 cp_mqd_base_addr;\n\tu32 cp_mqd_base_addr_hi;\n\tu32 cp_hqd_active;\n\tu32 cp_hqd_vmid;\n\tu32 cp_hqd_persistent_state;\n\tu32 cp_hqd_pipe_priority;\n\tu32 cp_hqd_queue_priority;\n\tu32 cp_hqd_quantum;\n\tu32 cp_hqd_pq_base;\n\tu32 cp_hqd_pq_base_hi;\n\tu32 cp_hqd_pq_rptr;\n\tu32 cp_hqd_pq_rptr_report_addr;\n\tu32 cp_hqd_pq_rptr_report_addr_hi;\n\tu32 cp_hqd_pq_wptr_poll_addr;\n\tu32 cp_hqd_pq_wptr_poll_addr_hi;\n\tu32 cp_hqd_pq_doorbell_control;\n\tu32 cp_hqd_pq_wptr;\n\tu32 cp_hqd_pq_control;\n\tu32 cp_hqd_ib_base_addr;\n\tu32 cp_hqd_ib_base_addr_hi;\n\tu32 cp_hqd_ib_rptr;\n\tu32 cp_hqd_ib_control;\n\tu32 cp_hqd_iq_timer;\n\tu32 cp_hqd_iq_rptr;\n\tu32 cp_hqd_dequeue_request;\n\tu32 cp_hqd_dma_offload;\n\tu32 cp_hqd_sema_cmd;\n\tu32 cp_hqd_msg_type;\n\tu32 cp_hqd_atomic0_preop_lo;\n\tu32 cp_hqd_atomic0_preop_hi;\n\tu32 cp_hqd_atomic1_preop_lo;\n\tu32 cp_hqd_atomic1_preop_hi;\n\tu32 cp_hqd_hq_scheduler0;\n\tu32 cp_hqd_hq_scheduler1;\n\tu32 cp_mqd_control;\n};\n\nstatic void gfx_v7_0_compute_pipe_init(struct amdgpu_device *adev,\n\t\t\t\t       int mec, int pipe)\n{\n\tu64 eop_gpu_addr;\n\tu32 tmp;\n\tsize_t eop_offset = (mec * adev->gfx.mec.num_pipe_per_mec + pipe)\n\t\t\t    * GFX7_MEC_HPD_SIZE * 2;\n\n\tmutex_lock(&adev->srbm_mutex);\n\teop_gpu_addr = adev->gfx.mec.hpd_eop_gpu_addr + eop_offset;\n\n\tcik_srbm_select(adev, mec + 1, pipe, 0, 0);\n\n\t \n\tWREG32(mmCP_HPD_EOP_BASE_ADDR, eop_gpu_addr >> 8);\n\tWREG32(mmCP_HPD_EOP_BASE_ADDR_HI, upper_32_bits(eop_gpu_addr) >> 8);\n\n\t \n\tWREG32(mmCP_HPD_EOP_VMID, 0);\n\n\t \n\ttmp = RREG32(mmCP_HPD_EOP_CONTROL);\n\ttmp &= ~CP_HPD_EOP_CONTROL__EOP_SIZE_MASK;\n\ttmp |= order_base_2(GFX7_MEC_HPD_SIZE / 8);\n\tWREG32(mmCP_HPD_EOP_CONTROL, tmp);\n\n\tcik_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n}\n\nstatic int gfx_v7_0_mqd_deactivate(struct amdgpu_device *adev)\n{\n\tint i;\n\n\t \n\tif (RREG32(mmCP_HQD_ACTIVE) & 1) {\n\t\tWREG32(mmCP_HQD_DEQUEUE_REQUEST, 1);\n\t\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t\tif (!(RREG32(mmCP_HQD_ACTIVE) & 1))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tif (i == adev->usec_timeout)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tWREG32(mmCP_HQD_DEQUEUE_REQUEST, 0);\n\t\tWREG32(mmCP_HQD_PQ_RPTR, 0);\n\t\tWREG32(mmCP_HQD_PQ_WPTR, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_mqd_init(struct amdgpu_device *adev,\n\t\t\t     struct cik_mqd *mqd,\n\t\t\t     uint64_t mqd_gpu_addr,\n\t\t\t     struct amdgpu_ring *ring)\n{\n\tu64 hqd_gpu_addr;\n\tu64 wb_gpu_addr;\n\n\t \n\tmemset(mqd, 0, sizeof(struct cik_mqd));\n\n\tmqd->header = 0xC0310800;\n\tmqd->compute_static_thread_mgmt_se0 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se1 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se2 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se3 = 0xffffffff;\n\n\t \n\tmqd->cp_hqd_pq_doorbell_control =\n\t\tRREG32(mmCP_HQD_PQ_DOORBELL_CONTROL);\n\tif (ring->use_doorbell)\n\t\tmqd->cp_hqd_pq_doorbell_control |= CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_EN_MASK;\n\telse\n\t\tmqd->cp_hqd_pq_doorbell_control &= ~CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_EN_MASK;\n\n\t \n\tmqd->cp_mqd_base_addr_lo = mqd_gpu_addr & 0xfffffffc;\n\tmqd->cp_mqd_base_addr_hi = upper_32_bits(mqd_gpu_addr);\n\n\t \n\tmqd->cp_mqd_control = RREG32(mmCP_MQD_CONTROL);\n\tmqd->cp_mqd_control &= ~CP_MQD_CONTROL__VMID_MASK;\n\n\t \n\thqd_gpu_addr = ring->gpu_addr >> 8;\n\tmqd->cp_hqd_pq_base_lo = hqd_gpu_addr;\n\tmqd->cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);\n\n\t \n\tmqd->cp_hqd_pq_control = RREG32(mmCP_HQD_PQ_CONTROL);\n\tmqd->cp_hqd_pq_control &=\n\t\t~(CP_HQD_PQ_CONTROL__QUEUE_SIZE_MASK |\n\t\t\t\tCP_HQD_PQ_CONTROL__RPTR_BLOCK_SIZE_MASK);\n\n\tmqd->cp_hqd_pq_control |=\n\t\torder_base_2(ring->ring_size / 8);\n\tmqd->cp_hqd_pq_control |=\n\t\t(order_base_2(AMDGPU_GPU_PAGE_SIZE/8) << 8);\n#ifdef __BIG_ENDIAN\n\tmqd->cp_hqd_pq_control |=\n\t\t2 << CP_HQD_PQ_CONTROL__ENDIAN_SWAP__SHIFT;\n#endif\n\tmqd->cp_hqd_pq_control &=\n\t\t~(CP_HQD_PQ_CONTROL__UNORD_DISPATCH_MASK |\n\t\t\t\tCP_HQD_PQ_CONTROL__ROQ_PQ_IB_FLIP_MASK |\n\t\t\t\tCP_HQD_PQ_CONTROL__PQ_VOLATILE_MASK);\n\tmqd->cp_hqd_pq_control |=\n\t\tCP_HQD_PQ_CONTROL__PRIV_STATE_MASK |\n\t\tCP_HQD_PQ_CONTROL__KMD_QUEUE_MASK;  \n\n\t \n\twb_gpu_addr = ring->wptr_gpu_addr;\n\tmqd->cp_hqd_pq_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\twb_gpu_addr = ring->rptr_gpu_addr;\n\tmqd->cp_hqd_pq_rptr_report_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_rptr_report_addr_hi =\n\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\tif (ring->use_doorbell) {\n\t\tmqd->cp_hqd_pq_doorbell_control =\n\t\t\tRREG32(mmCP_HQD_PQ_DOORBELL_CONTROL);\n\t\tmqd->cp_hqd_pq_doorbell_control &=\n\t\t\t~CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET_MASK;\n\t\tmqd->cp_hqd_pq_doorbell_control |=\n\t\t\t(ring->doorbell_index <<\n\t\t\t CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT);\n\t\tmqd->cp_hqd_pq_doorbell_control |=\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_EN_MASK;\n\t\tmqd->cp_hqd_pq_doorbell_control &=\n\t\t\t~(CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_SOURCE_MASK |\n\t\t\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_HIT_MASK);\n\n\t} else {\n\t\tmqd->cp_hqd_pq_doorbell_control = 0;\n\t}\n\n\t \n\tring->wptr = 0;\n\tmqd->cp_hqd_pq_wptr = lower_32_bits(ring->wptr);\n\tmqd->cp_hqd_pq_rptr = RREG32(mmCP_HQD_PQ_RPTR);\n\n\t \n\tmqd->cp_hqd_vmid = 0;\n\n\t \n\tmqd->cp_hqd_ib_control = RREG32(mmCP_HQD_IB_CONTROL);\n\tmqd->cp_hqd_ib_base_addr_lo = RREG32(mmCP_HQD_IB_BASE_ADDR);\n\tmqd->cp_hqd_ib_base_addr_hi = RREG32(mmCP_HQD_IB_BASE_ADDR_HI);\n\tmqd->cp_hqd_ib_rptr = RREG32(mmCP_HQD_IB_RPTR);\n\tmqd->cp_hqd_persistent_state = RREG32(mmCP_HQD_PERSISTENT_STATE);\n\tmqd->cp_hqd_sema_cmd = RREG32(mmCP_HQD_SEMA_CMD);\n\tmqd->cp_hqd_msg_type = RREG32(mmCP_HQD_MSG_TYPE);\n\tmqd->cp_hqd_atomic0_preop_lo = RREG32(mmCP_HQD_ATOMIC0_PREOP_LO);\n\tmqd->cp_hqd_atomic0_preop_hi = RREG32(mmCP_HQD_ATOMIC0_PREOP_HI);\n\tmqd->cp_hqd_atomic1_preop_lo = RREG32(mmCP_HQD_ATOMIC1_PREOP_LO);\n\tmqd->cp_hqd_atomic1_preop_hi = RREG32(mmCP_HQD_ATOMIC1_PREOP_HI);\n\tmqd->cp_hqd_pq_rptr = RREG32(mmCP_HQD_PQ_RPTR);\n\tmqd->cp_hqd_quantum = RREG32(mmCP_HQD_QUANTUM);\n\tmqd->cp_hqd_pipe_priority = RREG32(mmCP_HQD_PIPE_PRIORITY);\n\tmqd->cp_hqd_queue_priority = RREG32(mmCP_HQD_QUEUE_PRIORITY);\n\tmqd->cp_hqd_iq_rptr = RREG32(mmCP_HQD_IQ_RPTR);\n\n\t \n\tmqd->cp_hqd_active = 1;\n}\n\nstatic int gfx_v7_0_mqd_commit(struct amdgpu_device *adev, struct cik_mqd *mqd)\n{\n\tuint32_t tmp;\n\tuint32_t mqd_reg;\n\tuint32_t *mqd_data;\n\n\t \n\tmqd_data = &mqd->cp_mqd_base_addr_lo;\n\n\t \n\ttmp = RREG32(mmCP_PQ_WPTR_POLL_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PQ_WPTR_POLL_CNTL, EN, 0);\n\tWREG32(mmCP_PQ_WPTR_POLL_CNTL, tmp);\n\n\t \n\tfor (mqd_reg = mmCP_HQD_VMID; mqd_reg <= mmCP_MQD_CONTROL; mqd_reg++)\n\t\tWREG32(mqd_reg, mqd_data[mqd_reg - mmCP_MQD_BASE_ADDR]);\n\n\t \n\tfor (mqd_reg = mmCP_MQD_BASE_ADDR; mqd_reg <= mmCP_HQD_ACTIVE; mqd_reg++)\n\t\tWREG32(mqd_reg, mqd_data[mqd_reg - mmCP_MQD_BASE_ADDR]);\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_compute_queue_init(struct amdgpu_device *adev, int ring_id)\n{\n\tint r;\n\tu64 mqd_gpu_addr;\n\tstruct cik_mqd *mqd;\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[ring_id];\n\n\tr = amdgpu_bo_create_reserved(adev, sizeof(struct cik_mqd), PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT, &ring->mqd_obj,\n\t\t\t\t      &mqd_gpu_addr, (void **)&mqd);\n\tif (r) {\n\t\tdev_warn(adev->dev, \"(%d) create MQD bo failed\\n\", r);\n\t\treturn r;\n\t}\n\n\tmutex_lock(&adev->srbm_mutex);\n\tcik_srbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\n\tgfx_v7_0_mqd_init(adev, mqd, mqd_gpu_addr, ring);\n\tgfx_v7_0_mqd_deactivate(adev);\n\tgfx_v7_0_mqd_commit(adev, mqd);\n\n\tcik_srbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\tamdgpu_bo_kunmap(ring->mqd_obj);\n\tamdgpu_bo_unreserve(ring->mqd_obj);\n\treturn 0;\n}\n\n \nstatic int gfx_v7_0_cp_compute_resume(struct amdgpu_device *adev)\n{\n\tint r, i, j;\n\tu32 tmp;\n\tstruct amdgpu_ring *ring;\n\n\t \n\ttmp = RREG32(mmCP_CPF_DEBUG);\n\ttmp |= (1 << 23);\n\tWREG32(mmCP_CPF_DEBUG, tmp);\n\n\t \n\tfor (i = 0; i < adev->gfx.mec.num_mec; i++)\n\t\tfor (j = 0; j < adev->gfx.mec.num_pipe_per_mec; j++)\n\t\t\tgfx_v7_0_compute_pipe_init(adev, i, j);\n\n\t \n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tr = gfx_v7_0_compute_queue_init(adev, i);\n\t\tif (r) {\n\t\t\tgfx_v7_0_cp_compute_fini(adev);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tgfx_v7_0_cp_compute_enable(adev, true);\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\t\tamdgpu_ring_test_helper(ring);\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_cp_enable(struct amdgpu_device *adev, bool enable)\n{\n\tgfx_v7_0_cp_gfx_enable(adev, enable);\n\tgfx_v7_0_cp_compute_enable(adev, enable);\n}\n\nstatic int gfx_v7_0_cp_load_microcode(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tr = gfx_v7_0_cp_gfx_load_microcode(adev);\n\tif (r)\n\t\treturn r;\n\tr = gfx_v7_0_cp_compute_load_microcode(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_enable_gui_idle_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 tmp = RREG32(mmCP_INT_CNTL_RING0);\n\n\tif (enable)\n\t\ttmp |= (CP_INT_CNTL_RING0__CNTX_BUSY_INT_ENABLE_MASK |\n\t\t\t\tCP_INT_CNTL_RING0__CNTX_EMPTY_INT_ENABLE_MASK);\n\telse\n\t\ttmp &= ~(CP_INT_CNTL_RING0__CNTX_BUSY_INT_ENABLE_MASK |\n\t\t\t\tCP_INT_CNTL_RING0__CNTX_EMPTY_INT_ENABLE_MASK);\n\tWREG32(mmCP_INT_CNTL_RING0, tmp);\n}\n\nstatic int gfx_v7_0_cp_resume(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, false);\n\n\tr = gfx_v7_0_cp_load_microcode(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v7_0_cp_gfx_resume(adev);\n\tif (r)\n\t\treturn r;\n\tr = gfx_v7_0_cp_compute_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n\n\treturn 0;\n}\n\n \nstatic void gfx_v7_0_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_MEM_SPACE(1) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |  \n\t\t\t\t WAIT_REG_MEM_ENGINE(usepfp)));    \n\tamdgpu_ring_write(ring, addr & 0xfffffffc);\n\tamdgpu_ring_write(ring, upper_32_bits(addr) & 0xffffffff);\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, 0xffffffff);\n\tamdgpu_ring_write(ring, 4);  \n\n\tif (usepfp) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\n \n \nstatic void gfx_v7_0_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned vmid, uint64_t pd_addr)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\n\tamdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring, (WAIT_REG_MEM_OPERATION(0) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(0) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(0)));  \n\tamdgpu_ring_write(ring, mmVM_INVALIDATE_REQUEST);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0x20);  \n\n\t \n\tif (usepfp) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tamdgpu_ring_write(ring, 0x0);\n\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\nstatic void gfx_v7_0_ring_emit_wreg(struct amdgpu_ring *ring,\n\t\t\t\t    uint32_t reg, uint32_t val)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\n \nstatic int gfx_v7_0_rlc_init(struct amdgpu_device *adev)\n{\n\tconst u32 *src_ptr;\n\tu32 dws;\n\tconst struct cs_section_def *cs_data;\n\tint r;\n\n\t \n\tif (adev->flags & AMD_IS_APU) {\n\t\tif (adev->asic_type == CHIP_KAVERI) {\n\t\t\tadev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;\n\t\t\tadev->gfx.rlc.reg_list_size =\n\t\t\t\t(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);\n\t\t} else {\n\t\t\tadev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;\n\t\t\tadev->gfx.rlc.reg_list_size =\n\t\t\t\t(u32)ARRAY_SIZE(kalindi_rlc_save_restore_register_list);\n\t\t}\n\t}\n\tadev->gfx.rlc.cs_data = ci_cs_data;\n\tadev->gfx.rlc.cp_table_size = ALIGN(CP_ME_TABLE_SIZE * 5 * 4, 2048);  \n\tadev->gfx.rlc.cp_table_size += 64 * 1024;  \n\n\tsrc_ptr = adev->gfx.rlc.reg_list;\n\tdws = adev->gfx.rlc.reg_list_size;\n\tdws += (5 * 16) + 48 + 48 + 64;\n\n\tcs_data = adev->gfx.rlc.cs_data;\n\n\tif (src_ptr) {\n\t\t \n\t\tr = amdgpu_gfx_rlc_init_sr(adev, dws);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (cs_data) {\n\t\t \n\t\tr = amdgpu_gfx_rlc_init_csb(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (adev->gfx.rlc.cp_table_size) {\n\t\tr = amdgpu_gfx_rlc_init_cpt(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (adev->gfx.rlc.funcs->update_spm_vmid)\n\t\tadev->gfx.rlc.funcs->update_spm_vmid(adev, 0xf);\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_enable_lbpw(struct amdgpu_device *adev, bool enable)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(mmRLC_LB_CNTL);\n\tif (enable)\n\t\ttmp |= RLC_LB_CNTL__LOAD_BALANCE_ENABLE_MASK;\n\telse\n\t\ttmp &= ~RLC_LB_CNTL__LOAD_BALANCE_ENABLE_MASK;\n\tWREG32(mmRLC_LB_CNTL, tmp);\n}\n\nstatic void gfx_v7_0_wait_for_rlc_serdes(struct amdgpu_device *adev)\n{\n\tu32 i, j, k;\n\tu32 mask;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tgfx_v7_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\t\t\tif (RREG32(mmRLC_SERDES_CU_MASTER_BUSY) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tmask = RLC_SERDES_NONCU_MASTER_BUSY__SE_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__GC_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC0_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC1_MASTER_BUSY_MASK;\n\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\tif ((RREG32(mmRLC_SERDES_NONCU_MASTER_BUSY) & mask) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v7_0_update_rlc(struct amdgpu_device *adev, u32 rlc)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(mmRLC_CNTL);\n\tif (tmp != rlc)\n\t\tWREG32(mmRLC_CNTL, rlc);\n}\n\nstatic u32 gfx_v7_0_halt_rlc(struct amdgpu_device *adev)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_CNTL);\n\n\tif (data & RLC_CNTL__RLC_ENABLE_F32_MASK) {\n\t\tu32 i;\n\n\t\tdata &= ~RLC_CNTL__RLC_ENABLE_F32_MASK;\n\t\tWREG32(mmRLC_CNTL, data);\n\n\t\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t\tif ((RREG32(mmRLC_GPM_STAT) & RLC_GPM_STAT__RLC_BUSY_MASK) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tgfx_v7_0_wait_for_rlc_serdes(adev);\n\t}\n\n\treturn orig;\n}\n\nstatic bool gfx_v7_0_is_rlc_enabled(struct amdgpu_device *adev)\n{\n\treturn true;\n}\n\nstatic void gfx_v7_0_set_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tu32 tmp, i, mask;\n\n\ttmp = 0x1 | (1 << 1);\n\tWREG32(mmRLC_GPR_REG2, tmp);\n\n\tmask = RLC_GPM_STAT__GFX_POWER_STATUS_MASK |\n\t\tRLC_GPM_STAT__GFX_CLOCK_STATUS_MASK;\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif ((RREG32(mmRLC_GPM_STAT) & mask) == mask)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif ((RREG32(mmRLC_GPR_REG2) & 0x1) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v7_0_unset_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tu32 tmp;\n\n\ttmp = 0x1 | (0 << 1);\n\tWREG32(mmRLC_GPR_REG2, tmp);\n}\n\n \nstatic void gfx_v7_0_rlc_stop(struct amdgpu_device *adev)\n{\n\tWREG32(mmRLC_CNTL, 0);\n\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, false);\n\n\tgfx_v7_0_wait_for_rlc_serdes(adev);\n}\n\n \nstatic void gfx_v7_0_rlc_start(struct amdgpu_device *adev)\n{\n\tWREG32(mmRLC_CNTL, RLC_CNTL__RLC_ENABLE_F32_MASK);\n\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n\n\tudelay(50);\n}\n\nstatic void gfx_v7_0_rlc_reset(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32(mmGRBM_SOFT_RESET);\n\n\ttmp |= GRBM_SOFT_RESET__SOFT_RESET_RLC_MASK;\n\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\tudelay(50);\n\ttmp &= ~GRBM_SOFT_RESET__SOFT_RESET_RLC_MASK;\n\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\tudelay(50);\n}\n\n \nstatic int gfx_v7_0_rlc_resume(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v1_0 *hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\tu32 tmp;\n\n\tif (!adev->gfx.rlc_fw)\n\t\treturn -EINVAL;\n\n\thdr = (const struct rlc_firmware_header_v1_0 *)adev->gfx.rlc_fw->data;\n\tamdgpu_ucode_print_rlc_hdr(&hdr->header);\n\tadev->gfx.rlc_fw_version = le32_to_cpu(hdr->header.ucode_version);\n\tadev->gfx.rlc_feature_version = le32_to_cpu(\n\t\t\t\t\thdr->ucode_feature_version);\n\n\tadev->gfx.rlc.funcs->stop(adev);\n\n\t \n\ttmp = RREG32(mmRLC_CGCG_CGLS_CTRL) & 0xfffffffc;\n\tWREG32(mmRLC_CGCG_CGLS_CTRL, tmp);\n\n\tadev->gfx.rlc.funcs->reset(adev);\n\n\tgfx_v7_0_init_pg(adev);\n\n\tWREG32(mmRLC_LB_CNTR_INIT, 0);\n\tWREG32(mmRLC_LB_CNTR_MAX, 0x00008000);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tWREG32(mmRLC_LB_INIT_CU_MASK, 0xffffffff);\n\tWREG32(mmRLC_LB_PARAMS, 0x00600408);\n\tWREG32(mmRLC_LB_CNTL, 0x80000004);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tWREG32(mmRLC_MC_CNTL, 0);\n\tWREG32(mmRLC_UCODE_CNTL, 0);\n\n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.rlc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\tWREG32(mmRLC_GPM_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32(mmRLC_GPM_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32(mmRLC_GPM_UCODE_ADDR, adev->gfx.rlc_fw_version);\n\n\t \n\tgfx_v7_0_enable_lbpw(adev, false);\n\n\tif (adev->asic_type == CHIP_BONAIRE)\n\t\tWREG32(mmRLC_DRIVER_CPDMA_STATUS, 0);\n\n\tadev->gfx.rlc.funcs->start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_update_spm_vmid(struct amdgpu_device *adev, unsigned vmid)\n{\n\tu32 data;\n\n\tamdgpu_gfx_off_ctrl(adev, false);\n\n\tdata = RREG32(mmRLC_SPM_VMID);\n\n\tdata &= ~RLC_SPM_VMID__RLC_SPM_VMID_MASK;\n\tdata |= (vmid & RLC_SPM_VMID__RLC_SPM_VMID_MASK) << RLC_SPM_VMID__RLC_SPM_VMID__SHIFT;\n\n\tWREG32(mmRLC_SPM_VMID, data);\n\n\tamdgpu_gfx_off_ctrl(adev, true);\n}\n\nstatic void gfx_v7_0_enable_cgcg(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data, orig, tmp, tmp2;\n\n\torig = data = RREG32(mmRLC_CGCG_CGLS_CTRL);\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)) {\n\t\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n\n\t\ttmp = gfx_v7_0_halt_rlc(adev);\n\n\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\t\tWREG32(mmRLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(mmRLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\ttmp2 = RLC_SERDES_WR_CTRL__BPM_ADDR_MASK |\n\t\t\tRLC_SERDES_WR_CTRL__CGCG_OVERRIDE_0_MASK |\n\t\t\tRLC_SERDES_WR_CTRL__CGLS_ENABLE_MASK;\n\t\tWREG32(mmRLC_SERDES_WR_CTRL, tmp2);\n\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\t\tgfx_v7_0_update_rlc(adev, tmp);\n\n\t\tdata |= RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK | RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_CGCG_CGLS_CTRL, data);\n\n\t} else {\n\t\tgfx_v7_0_enable_gui_idle_interrupt(adev, false);\n\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\t\tRREG32(mmCB_CGTT_SCLK_CTRL);\n\n\t\tdata &= ~(RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK | RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK);\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_CGCG_CGLS_CTRL, data);\n\n\t\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n\t}\n}\n\nstatic void gfx_v7_0_enable_mgcg(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data, orig, tmp = 0;\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG)) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) {\n\t\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CP_LS) {\n\t\t\t\torig = data = RREG32(mmCP_MEM_SLP_CNTL);\n\t\t\t\tdata |= CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(mmCP_MEM_SLP_CNTL, data);\n\t\t\t}\n\t\t}\n\n\t\torig = data = RREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= 0x00000001;\n\t\tdata &= 0xfffffffd;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\ttmp = gfx_v7_0_halt_rlc(adev);\n\n\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\t\tWREG32(mmRLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(mmRLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\tdata = RLC_SERDES_WR_CTRL__BPM_ADDR_MASK |\n\t\t\tRLC_SERDES_WR_CTRL__MGCG_OVERRIDE_0_MASK;\n\t\tWREG32(mmRLC_SERDES_WR_CTRL, data);\n\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\t\tgfx_v7_0_update_rlc(adev, tmp);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGTS) {\n\t\t\torig = data = RREG32(mmCGTS_SM_CTRL_REG);\n\t\t\tdata &= ~CGTS_SM_CTRL_REG__SM_MODE_MASK;\n\t\t\tdata |= (0x2 << CGTS_SM_CTRL_REG__SM_MODE__SHIFT);\n\t\t\tdata |= CGTS_SM_CTRL_REG__SM_MODE_ENABLE_MASK;\n\t\t\tdata &= ~CGTS_SM_CTRL_REG__OVERRIDE_MASK;\n\t\t\tif ((adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) &&\n\t\t\t    (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGTS_LS))\n\t\t\t\tdata &= ~CGTS_SM_CTRL_REG__LS_OVERRIDE_MASK;\n\t\t\tdata &= ~CGTS_SM_CTRL_REG__ON_MONITOR_ADD_MASK;\n\t\t\tdata |= CGTS_SM_CTRL_REG__ON_MONITOR_ADD_EN_MASK;\n\t\t\tdata |= (0x96 << CGTS_SM_CTRL_REG__ON_MONITOR_ADD__SHIFT);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32(mmCGTS_SM_CTRL_REG, data);\n\t\t}\n\t} else {\n\t\torig = data = RREG32(mmRLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= 0x00000003;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\tdata = RREG32(mmRLC_MEM_SLP_CNTL);\n\t\tif (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;\n\t\t\tWREG32(mmRLC_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\tdata = RREG32(mmCP_MEM_SLP_CNTL);\n\t\tif (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;\n\t\t\tWREG32(mmCP_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\torig = data = RREG32(mmCGTS_SM_CTRL_REG);\n\t\tdata |= CGTS_SM_CTRL_REG__OVERRIDE_MASK | CGTS_SM_CTRL_REG__LS_OVERRIDE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmCGTS_SM_CTRL_REG, data);\n\n\t\ttmp = gfx_v7_0_halt_rlc(adev);\n\n\t\tmutex_lock(&adev->grbm_idx_mutex);\n\t\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\t\tWREG32(mmRLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(mmRLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\tdata = RLC_SERDES_WR_CTRL__BPM_ADDR_MASK | RLC_SERDES_WR_CTRL__MGCG_OVERRIDE_1_MASK;\n\t\tWREG32(mmRLC_SERDES_WR_CTRL, data);\n\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\t\tgfx_v7_0_update_rlc(adev, tmp);\n\t}\n}\n\nstatic void gfx_v7_0_update_cg(struct amdgpu_device *adev,\n\t\t\t       bool enable)\n{\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, false);\n\t \n\tif (enable) {\n\t\tgfx_v7_0_enable_mgcg(adev, true);\n\t\tgfx_v7_0_enable_cgcg(adev, true);\n\t} else {\n\t\tgfx_v7_0_enable_cgcg(adev, false);\n\t\tgfx_v7_0_enable_mgcg(adev, false);\n\t}\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n}\n\nstatic void gfx_v7_0_enable_sclk_slowdown_on_pu(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS))\n\t\tdata |= RLC_PG_CNTL__SMU_CLK_SLOWDOWN_ON_PU_ENABLE_MASK;\n\telse\n\t\tdata &= ~RLC_PG_CNTL__SMU_CLK_SLOWDOWN_ON_PU_ENABLE_MASK;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\nstatic void gfx_v7_0_enable_sclk_slowdown_on_pd(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS))\n\t\tdata |= RLC_PG_CNTL__SMU_CLK_SLOWDOWN_ON_PD_ENABLE_MASK;\n\telse\n\t\tdata &= ~RLC_PG_CNTL__SMU_CLK_SLOWDOWN_ON_PD_ENABLE_MASK;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\nstatic void gfx_v7_0_enable_cp_pg(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_CP))\n\t\tdata &= ~0x8000;\n\telse\n\t\tdata |= 0x8000;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\nstatic void gfx_v7_0_enable_gds_pg(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GDS))\n\t\tdata &= ~0x2000;\n\telse\n\t\tdata |= 0x2000;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\nstatic int gfx_v7_0_cp_pg_table_num(struct amdgpu_device *adev)\n{\n\tif (adev->asic_type == CHIP_KAVERI)\n\t\treturn 5;\n\telse\n\t\treturn 4;\n}\n\nstatic void gfx_v7_0_enable_gfx_cgpg(struct amdgpu_device *adev,\n\t\t\t\t     bool enable)\n{\n\tu32 data, orig;\n\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)) {\n\t\torig = data = RREG32(mmRLC_PG_CNTL);\n\t\tdata |= RLC_PG_CNTL__GFX_POWER_GATING_ENABLE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_PG_CNTL, data);\n\n\t\torig = data = RREG32(mmRLC_AUTO_PG_CTRL);\n\t\tdata |= RLC_AUTO_PG_CTRL__AUTO_PG_EN_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_AUTO_PG_CTRL, data);\n\t} else {\n\t\torig = data = RREG32(mmRLC_PG_CNTL);\n\t\tdata &= ~RLC_PG_CNTL__GFX_POWER_GATING_ENABLE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_PG_CNTL, data);\n\n\t\torig = data = RREG32(mmRLC_AUTO_PG_CTRL);\n\t\tdata &= ~RLC_AUTO_PG_CTRL__AUTO_PG_EN_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmRLC_AUTO_PG_CTRL, data);\n\n\t\tdata = RREG32(mmDB_RENDER_CONTROL);\n\t}\n}\n\nstatic void gfx_v7_0_set_user_cu_inactive_bitmap(struct amdgpu_device *adev,\n\t\t\t\t\t\t u32 bitmap)\n{\n\tu32 data;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tdata = bitmap << GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;\n\tdata &= GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;\n\n\tWREG32(mmGC_USER_SHADER_ARRAY_CONFIG, data);\n}\n\nstatic u32 gfx_v7_0_get_cu_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata = RREG32(mmCC_GC_SHADER_ARRAY_CONFIG);\n\tdata |= RREG32(mmGC_USER_SHADER_ARRAY_CONFIG);\n\n\tdata &= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;\n\tdata >>= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_cu_per_sh);\n\n\treturn (~data) & mask;\n}\n\nstatic void gfx_v7_0_init_ao_cu_mask(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tWREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);\n\n\ttmp = RREG32(mmRLC_MAX_PG_CU);\n\ttmp &= ~RLC_MAX_PG_CU__MAX_POWERED_UP_CU_MASK;\n\ttmp |= (adev->gfx.cu_info.number << RLC_MAX_PG_CU__MAX_POWERED_UP_CU__SHIFT);\n\tWREG32(mmRLC_MAX_PG_CU, tmp);\n}\n\nstatic void gfx_v7_0_enable_gfx_static_mgpg(struct amdgpu_device *adev,\n\t\t\t\t\t    bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG))\n\t\tdata |= RLC_PG_CNTL__STATIC_PER_CU_PG_ENABLE_MASK;\n\telse\n\t\tdata &= ~RLC_PG_CNTL__STATIC_PER_CU_PG_ENABLE_MASK;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\nstatic void gfx_v7_0_enable_gfx_dynamic_mgpg(struct amdgpu_device *adev,\n\t\t\t\t\t     bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG))\n\t\tdata |= RLC_PG_CNTL__DYN_PER_CU_PG_ENABLE_MASK;\n\telse\n\t\tdata &= ~RLC_PG_CNTL__DYN_PER_CU_PG_ENABLE_MASK;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n}\n\n#define RLC_SAVE_AND_RESTORE_STARTING_OFFSET 0x90\n#define RLC_CLEAR_STATE_DESCRIPTOR_OFFSET    0x3D\n\nstatic void gfx_v7_0_init_gfx_cgpg(struct amdgpu_device *adev)\n{\n\tu32 data, orig;\n\tu32 i;\n\n\tif (adev->gfx.rlc.cs_data) {\n\t\tWREG32(mmRLC_GPM_SCRATCH_ADDR, RLC_CLEAR_STATE_DESCRIPTOR_OFFSET);\n\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, upper_32_bits(adev->gfx.rlc.clear_state_gpu_addr));\n\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, lower_32_bits(adev->gfx.rlc.clear_state_gpu_addr));\n\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, adev->gfx.rlc.clear_state_size);\n\t} else {\n\t\tWREG32(mmRLC_GPM_SCRATCH_ADDR, RLC_CLEAR_STATE_DESCRIPTOR_OFFSET);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, 0);\n\t}\n\tif (adev->gfx.rlc.reg_list) {\n\t\tWREG32(mmRLC_GPM_SCRATCH_ADDR, RLC_SAVE_AND_RESTORE_STARTING_OFFSET);\n\t\tfor (i = 0; i < adev->gfx.rlc.reg_list_size; i++)\n\t\t\tWREG32(mmRLC_GPM_SCRATCH_DATA, adev->gfx.rlc.reg_list[i]);\n\t}\n\n\torig = data = RREG32(mmRLC_PG_CNTL);\n\tdata |= RLC_PG_CNTL__GFX_POWER_GATING_SRC_MASK;\n\tif (orig != data)\n\t\tWREG32(mmRLC_PG_CNTL, data);\n\n\tWREG32(mmRLC_SAVE_AND_RESTORE_BASE, adev->gfx.rlc.save_restore_gpu_addr >> 8);\n\tWREG32(mmRLC_JUMP_TABLE_RESTORE, adev->gfx.rlc.cp_table_gpu_addr >> 8);\n\n\tdata = RREG32(mmCP_RB_WPTR_POLL_CNTL);\n\tdata &= ~CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT_MASK;\n\tdata |= (0x60 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);\n\tWREG32(mmCP_RB_WPTR_POLL_CNTL, data);\n\n\tdata = 0x10101010;\n\tWREG32(mmRLC_PG_DELAY, data);\n\n\tdata = RREG32(mmRLC_PG_DELAY_2);\n\tdata &= ~0xff;\n\tdata |= 0x3;\n\tWREG32(mmRLC_PG_DELAY_2, data);\n\n\tdata = RREG32(mmRLC_AUTO_PG_CTRL);\n\tdata &= ~RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD_MASK;\n\tdata |= (0x700 << RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD__SHIFT);\n\tWREG32(mmRLC_AUTO_PG_CTRL, data);\n\n}\n\nstatic void gfx_v7_0_update_gfx_pg(struct amdgpu_device *adev, bool enable)\n{\n\tgfx_v7_0_enable_gfx_cgpg(adev, enable);\n\tgfx_v7_0_enable_gfx_static_mgpg(adev, enable);\n\tgfx_v7_0_enable_gfx_dynamic_mgpg(adev, enable);\n}\n\nstatic u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (adev->gfx.rlc.cs_data == NULL)\n\t\treturn 0;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tcount += 4;\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nstatic void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev,\n\t\t\t\t    volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (adev->gfx.rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index - PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tbuffer[count++] = cpu_to_le32(mmPA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\tbuffer[count++] = cpu_to_le32(0x16000012);\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);  \n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);  \n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tbuffer[count++] = cpu_to_le32(0x3a00161a);\n\t\tbuffer[count++] = cpu_to_le32(0x0000002e);\n\t\tbreak;\n\tdefault:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic void gfx_v7_0_init_pg(struct amdgpu_device *adev)\n{\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |\n\t\t\t      AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t      AMD_PG_SUPPORT_GFX_DMG |\n\t\t\t      AMD_PG_SUPPORT_CP |\n\t\t\t      AMD_PG_SUPPORT_GDS |\n\t\t\t      AMD_PG_SUPPORT_RLC_SMU_HS)) {\n\t\tgfx_v7_0_enable_sclk_slowdown_on_pu(adev, true);\n\t\tgfx_v7_0_enable_sclk_slowdown_on_pd(adev, true);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) {\n\t\t\tgfx_v7_0_init_gfx_cgpg(adev);\n\t\t\tgfx_v7_0_enable_cp_pg(adev, true);\n\t\t\tgfx_v7_0_enable_gds_pg(adev, true);\n\t\t}\n\t\tgfx_v7_0_init_ao_cu_mask(adev);\n\t\tgfx_v7_0_update_gfx_pg(adev, true);\n\t}\n}\n\nstatic void gfx_v7_0_fini_pg(struct amdgpu_device *adev)\n{\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |\n\t\t\t      AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t      AMD_PG_SUPPORT_GFX_DMG |\n\t\t\t      AMD_PG_SUPPORT_CP |\n\t\t\t      AMD_PG_SUPPORT_GDS |\n\t\t\t      AMD_PG_SUPPORT_RLC_SMU_HS)) {\n\t\tgfx_v7_0_update_gfx_pg(adev, false);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) {\n\t\t\tgfx_v7_0_enable_cp_pg(adev, false);\n\t\t\tgfx_v7_0_enable_gds_pg(adev, false);\n\t\t}\n\t}\n}\n\n \nstatic uint64_t gfx_v7_0_get_gpu_clock_counter(struct amdgpu_device *adev)\n{\n\tuint64_t clock;\n\n\tmutex_lock(&adev->gfx.gpu_clock_mutex);\n\tWREG32(mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\tclock = (uint64_t)RREG32(mmRLC_GPU_CLOCK_COUNT_LSB) |\n\t\t((uint64_t)RREG32(mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\tmutex_unlock(&adev->gfx.gpu_clock_mutex);\n\treturn clock;\n}\n\nstatic void gfx_v7_0_ring_emit_gds_switch(struct amdgpu_ring *ring,\n\t\t\t\t\t  uint32_t vmid,\n\t\t\t\t\t  uint32_t gds_base, uint32_t gds_size,\n\t\t\t\t\t  uint32_t gws_base, uint32_t gws_size,\n\t\t\t\t\t  uint32_t oa_base, uint32_t oa_size)\n{\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].mem_base);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gds_base);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].mem_size);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gds_size);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].gws);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, gws_size << GDS_GWS_VMID0__SIZE__SHIFT | gws_base);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\tWRITE_DATA_DST_SEL(0)));\n\tamdgpu_ring_write(ring, amdgpu_gds_reg_offset[vmid].oa);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, (1 << (oa_size + oa_base)) - (1 << oa_base));\n}\n\nstatic void gfx_v7_0_ring_soft_recovery(struct amdgpu_ring *ring, unsigned vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t value = 0;\n\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CMD, 0x03);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, MODE, 0x01);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CHECK_VMID, 1);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, VM_ID, vmid);\n\tWREG32(mmSQ_CMD, value);\n}\n\nstatic uint32_t wave_read_ind(struct amdgpu_device *adev, uint32_t simd, uint32_t wave, uint32_t address)\n{\n\tWREG32(mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(address << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK));\n\treturn RREG32(mmSQ_IND_DATA);\n}\n\nstatic void wave_read_regs(struct amdgpu_device *adev, uint32_t simd,\n\t\t\t   uint32_t wave, uint32_t thread,\n\t\t\t   uint32_t regno, uint32_t num, uint32_t *out)\n{\n\tWREG32(mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(regno << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(thread << SQ_IND_INDEX__THREAD_ID__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK) |\n\t\t(SQ_IND_INDEX__AUTO_INCR_MASK));\n\twhile (num--)\n\t\t*(out++) = RREG32(mmSQ_IND_DATA);\n}\n\nstatic void gfx_v7_0_read_wave_data(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd, uint32_t wave, uint32_t *dst, int *no_fields)\n{\n\t \n\tdst[(*no_fields)++] = 0;\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_STATUS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_HW_ID);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW1);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_GPR_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_LDS_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TRAPSTS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_STS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TBA_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TBA_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TMA_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TMA_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_DBG0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_M0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_MODE);\n}\n\nstatic void gfx_v7_0_read_wave_sgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t     uint32_t wave, uint32_t start,\n\t\t\t\t     uint32_t size, uint32_t *dst)\n{\n\twave_read_regs(\n\t\tadev, simd, wave, 0,\n\t\tstart + SQIND_WAVE_SGPRS_OFFSET, size, dst);\n}\n\nstatic void gfx_v7_0_select_me_pipe_q(struct amdgpu_device *adev,\n\t\t\t\t  u32 me, u32 pipe, u32 q, u32 vm, u32 xcc_id)\n{\n\tcik_srbm_select(adev, me, pipe, q, vm);\n}\n\nstatic const struct amdgpu_gfx_funcs gfx_v7_0_gfx_funcs = {\n\t.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,\n\t.select_se_sh = &gfx_v7_0_select_se_sh,\n\t.read_wave_data = &gfx_v7_0_read_wave_data,\n\t.read_wave_sgprs = &gfx_v7_0_read_wave_sgprs,\n\t.select_me_pipe_q = &gfx_v7_0_select_me_pipe_q\n};\n\nstatic const struct amdgpu_rlc_funcs gfx_v7_0_rlc_funcs = {\n\t.is_rlc_enabled = gfx_v7_0_is_rlc_enabled,\n\t.set_safe_mode = gfx_v7_0_set_safe_mode,\n\t.unset_safe_mode = gfx_v7_0_unset_safe_mode,\n\t.init = gfx_v7_0_rlc_init,\n\t.get_csb_size = gfx_v7_0_get_csb_size,\n\t.get_csb_buffer = gfx_v7_0_get_csb_buffer,\n\t.get_cp_table_num = gfx_v7_0_cp_pg_table_num,\n\t.resume = gfx_v7_0_rlc_resume,\n\t.stop = gfx_v7_0_rlc_stop,\n\t.reset = gfx_v7_0_rlc_reset,\n\t.start = gfx_v7_0_rlc_start,\n\t.update_spm_vmid = gfx_v7_0_update_spm_vmid\n};\n\nstatic int gfx_v7_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->gfx.xcc_mask = 1;\n\tadev->gfx.num_gfx_rings = GFX7_NUM_GFX_RINGS;\n\tadev->gfx.num_compute_rings = min(amdgpu_gfx_get_num_kcq(adev),\n\t\t\t\t\t  AMDGPU_MAX_COMPUTE_RINGS);\n\tadev->gfx.funcs = &gfx_v7_0_gfx_funcs;\n\tadev->gfx.rlc.funcs = &gfx_v7_0_rlc_funcs;\n\tgfx_v7_0_set_ring_funcs(adev);\n\tgfx_v7_0_set_irq_funcs(adev);\n\tgfx_v7_0_set_gds_init(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_reg_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_inst_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_gpu_early_init(struct amdgpu_device *adev)\n{\n\tu32 gb_addr_config;\n\tu32 mc_arb_ramcfg;\n\tu32 dimm00_addr_map, dimm01_addr_map, dimm10_addr_map, dimm11_addr_map;\n\tu32 tmp;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_BONAIRE:\n\t\tadev->gfx.config.max_shader_engines = 2;\n\t\tadev->gfx.config.max_tile_pipes = 4;\n\t\tadev->gfx.config.max_cu_per_sh = 7;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_texture_channel_caches = 4;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tadev->gfx.config.max_shader_engines = 4;\n\t\tadev->gfx.config.max_tile_pipes = 16;\n\t\tadev->gfx.config.max_cu_per_sh = 11;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 4;\n\t\tadev->gfx.config.max_texture_channel_caches = 16;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 32;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tadev->gfx.config.max_shader_engines = 1;\n\t\tadev->gfx.config.max_tile_pipes = 4;\n\t\tadev->gfx.config.max_cu_per_sh = 8;\n\t\tadev->gfx.config.max_backends_per_se = 2;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_texture_channel_caches = 4;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 16;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tdefault:\n\t\tadev->gfx.config.max_shader_engines = 1;\n\t\tadev->gfx.config.max_tile_pipes = 2;\n\t\tadev->gfx.config.max_cu_per_sh = 2;\n\t\tadev->gfx.config.max_sh_per_se = 1;\n\t\tadev->gfx.config.max_backends_per_se = 1;\n\t\tadev->gfx.config.max_texture_channel_caches = 2;\n\t\tadev->gfx.config.max_gprs = 256;\n\t\tadev->gfx.config.max_gs_threads = 16;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\tadev->gfx.config.mc_arb_ramcfg = RREG32(mmMC_ARB_RAMCFG);\n\tmc_arb_ramcfg = adev->gfx.config.mc_arb_ramcfg;\n\n\tadev->gfx.config.num_banks = REG_GET_FIELD(mc_arb_ramcfg,\n\t\t\t\tMC_ARB_RAMCFG, NOOFBANK);\n\tadev->gfx.config.num_ranks = REG_GET_FIELD(mc_arb_ramcfg,\n\t\t\t\tMC_ARB_RAMCFG, NOOFRANKS);\n\n\tadev->gfx.config.num_tile_pipes = adev->gfx.config.max_tile_pipes;\n\tadev->gfx.config.mem_max_burst_length_bytes = 256;\n\tif (adev->flags & AMD_IS_APU) {\n\t\t \n\t\ttmp = RREG32(mmMC_FUS_DRAM0_BANK_ADDR_MAPPING);\n\t\tdimm00_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM0_BANK_ADDR_MAPPING, DIMM0ADDRMAP);\n\t\tdimm01_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM0_BANK_ADDR_MAPPING, DIMM1ADDRMAP);\n\n\t\ttmp = RREG32(mmMC_FUS_DRAM1_BANK_ADDR_MAPPING);\n\t\tdimm10_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM1_BANK_ADDR_MAPPING, DIMM0ADDRMAP);\n\t\tdimm11_addr_map = REG_GET_FIELD(tmp, MC_FUS_DRAM1_BANK_ADDR_MAPPING, DIMM1ADDRMAP);\n\n\t\t \n\t\tif ((dimm00_addr_map == 0) || (dimm00_addr_map == 3) || (dimm00_addr_map == 4) || (dimm00_addr_map > 12))\n\t\t\tdimm00_addr_map = 0;\n\t\tif ((dimm01_addr_map == 0) || (dimm01_addr_map == 3) || (dimm01_addr_map == 4) || (dimm01_addr_map > 12))\n\t\t\tdimm01_addr_map = 0;\n\t\tif ((dimm10_addr_map == 0) || (dimm10_addr_map == 3) || (dimm10_addr_map == 4) || (dimm10_addr_map > 12))\n\t\t\tdimm10_addr_map = 0;\n\t\tif ((dimm11_addr_map == 0) || (dimm11_addr_map == 3) || (dimm11_addr_map == 4) || (dimm11_addr_map > 12))\n\t\t\tdimm11_addr_map = 0;\n\n\t\t \n\t\t \n\t\tif ((dimm00_addr_map == 11) || (dimm01_addr_map == 11) || (dimm10_addr_map == 11) || (dimm11_addr_map == 11))\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 2;\n\t\telse\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 1;\n\t} else {\n\t\ttmp = (mc_arb_ramcfg & MC_ARB_RAMCFG__NOOFCOLS_MASK) >> MC_ARB_RAMCFG__NOOFCOLS__SHIFT;\n\t\tadev->gfx.config.mem_row_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;\n\t\tif (adev->gfx.config.mem_row_size_in_kb > 4)\n\t\t\tadev->gfx.config.mem_row_size_in_kb = 4;\n\t}\n\t \n\tadev->gfx.config.shader_engine_tile_size = 32;\n\tadev->gfx.config.num_gpus = 1;\n\tadev->gfx.config.multi_gpu_tile_size = 64;\n\n\t \n\tgb_addr_config &= ~GB_ADDR_CONFIG__ROW_SIZE_MASK;\n\tswitch (adev->gfx.config.mem_row_size_in_kb) {\n\tcase 1:\n\tdefault:\n\t\tgb_addr_config |= (0 << GB_ADDR_CONFIG__ROW_SIZE__SHIFT);\n\t\tbreak;\n\tcase 2:\n\t\tgb_addr_config |= (1 << GB_ADDR_CONFIG__ROW_SIZE__SHIFT);\n\t\tbreak;\n\tcase 4:\n\t\tgb_addr_config |= (2 << GB_ADDR_CONFIG__ROW_SIZE__SHIFT);\n\t\tbreak;\n\t}\n\tadev->gfx.config.gb_addr_config = gb_addr_config;\n}\n\nstatic int gfx_v7_0_compute_ring_init(struct amdgpu_device *adev, int ring_id,\n\t\t\t\t\tint mec, int pipe, int queue)\n{\n\tint r;\n\tunsigned irq_type;\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[ring_id];\n\n\t \n\tring->me = mec + 1;\n\tring->pipe = pipe;\n\tring->queue = queue;\n\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\tring->doorbell_index = adev->doorbell_index.mec_ring0 + ring_id;\n\tsprintf(ring->name, \"comp_%d.%d.%d\", ring->me, ring->pipe, ring->queue);\n\n\tirq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP\n\t\t+ ((ring->me - 1) * adev->gfx.mec.num_pipe_per_mec)\n\t\t+ ring->pipe;\n\n\t \n\tr = amdgpu_ring_init(adev, ring, 1024,\n\t\t\t     &adev->gfx.eop_irq, irq_type,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_sw_init(void *handle)\n{\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i, j, k, r, ring_id;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_KAVERI:\n\t\tadev->gfx.mec.num_mec = 2;\n\t\tbreak;\n\tcase CHIP_BONAIRE:\n\tcase CHIP_HAWAII:\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tdefault:\n\t\tadev->gfx.mec.num_mec = 1;\n\t\tbreak;\n\t}\n\tadev->gfx.mec.num_pipe_per_mec = 4;\n\tadev->gfx.mec.num_queue_per_pipe = 8;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 181, &adev->gfx.eop_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 184,\n\t\t\t      &adev->gfx.priv_reg_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 185,\n\t\t\t      &adev->gfx.priv_inst_irq);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v7_0_init_microcode(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to load gfx firmware!\\n\");\n\t\treturn r;\n\t}\n\n\tr = adev->gfx.rlc.funcs->init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tr = gfx_v7_0_mec_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init MEC BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\t\tring->ring_obj = NULL;\n\t\tsprintf(ring->name, \"gfx\");\n\t\tr = amdgpu_ring_init(adev, ring, 1024,\n\t\t\t\t     &adev->gfx.eop_irq,\n\t\t\t\t     AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP,\n\t\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tring_id = 0;\n\tfor (i = 0; i < adev->gfx.mec.num_mec; ++i) {\n\t\tfor (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {\n\t\t\t\tif (!amdgpu_gfx_is_mec_queue_enabled(adev, 0, i,\n\t\t\t\t\t\t\t\t     k, j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tr = gfx_v7_0_compute_ring_init(adev,\n\t\t\t\t\t\t\t\tring_id,\n\t\t\t\t\t\t\t\ti, k, j);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\n\t\t\t\tring_id++;\n\t\t\t}\n\t\t}\n\t}\n\n\tadev->gfx.ce_ram_size = 0x8000;\n\n\tgfx_v7_0_gpu_early_init(adev);\n\n\treturn r;\n}\n\nstatic int gfx_v7_0_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.gfx_ring[i]);\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.compute_ring[i]);\n\n\tgfx_v7_0_cp_compute_fini(adev);\n\tamdgpu_gfx_rlc_fini(adev);\n\tgfx_v7_0_mec_fini(adev);\n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.clear_state_obj,\n\t\t\t\t&adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cs_ptr);\n\tif (adev->gfx.rlc.cp_table_size) {\n\t\tamdgpu_bo_free_kernel(&adev->gfx.rlc.cp_table_obj,\n\t\t\t\t&adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cp_table_ptr);\n\t}\n\tgfx_v7_0_free_microcode(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tgfx_v7_0_constants_init(adev);\n\n\t \n\tadev->gfx.rlc.funcs->get_csb_buffer(adev, adev->gfx.rlc.cs_ptr);\n\t \n\tr = adev->gfx.rlc.funcs->resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v7_0_cp_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn r;\n}\n\nstatic int gfx_v7_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_put(adev, &adev->gfx.priv_reg_irq, 0);\n\tamdgpu_irq_put(adev, &adev->gfx.priv_inst_irq, 0);\n\tgfx_v7_0_cp_enable(adev, false);\n\tadev->gfx.rlc.funcs->stop(adev);\n\tgfx_v7_0_fini_pg(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn gfx_v7_0_hw_fini(adev);\n}\n\nstatic int gfx_v7_0_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn gfx_v7_0_hw_init(adev);\n}\n\nstatic bool gfx_v7_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (RREG32(mmGRBM_STATUS) & GRBM_STATUS__GUI_ACTIVE_MASK)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int gfx_v7_0_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tu32 tmp;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(mmGRBM_STATUS) & GRBM_STATUS__GUI_ACTIVE_MASK;\n\n\t\tif (!tmp)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int gfx_v7_0_soft_reset(void *handle)\n{\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\ttmp = RREG32(mmGRBM_STATUS);\n\tif (tmp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |\n\t\t   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |\n\t\t   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |\n\t\t   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |\n\t\t   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |\n\t\t   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK))\n\t\tgrbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_CP_MASK |\n\t\t\tGRBM_SOFT_RESET__SOFT_RESET_GFX_MASK;\n\n\tif (tmp & (GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK)) {\n\t\tgrbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_CP_MASK;\n\t\tsrbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;\n\t}\n\n\t \n\ttmp = RREG32(mmGRBM_STATUS2);\n\tif (tmp & GRBM_STATUS2__RLC_BUSY_MASK)\n\t\tgrbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_RLC_MASK;\n\n\t \n\ttmp = RREG32(mmSRBM_STATUS);\n\tif (tmp & SRBM_STATUS__GRBM_RQ_PENDING_MASK)\n\t\tsrbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;\n\n\tif (grbm_soft_reset || srbm_soft_reset) {\n\t\t \n\t\tgfx_v7_0_fini_pg(adev);\n\t\tgfx_v7_0_update_cg(adev, false);\n\n\t\t \n\t\tadev->gfx.rlc.funcs->stop(adev);\n\n\t\t \n\t\tWREG32(mmCP_ME_CNTL, CP_ME_CNTL__ME_HALT_MASK | CP_ME_CNTL__PFP_HALT_MASK | CP_ME_CNTL__CE_HALT_MASK);\n\n\t\t \n\t\tWREG32(mmCP_MEC_CNTL, CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK);\n\n\t\tif (grbm_soft_reset) {\n\t\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\t\t\ttmp |= grbm_soft_reset;\n\t\t\tdev_info(adev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\t\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\n\t\t\tudelay(50);\n\n\t\t\ttmp &= ~grbm_soft_reset;\n\t\t\tWREG32(mmGRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32(mmGRBM_SOFT_RESET);\n\t\t}\n\n\t\tif (srbm_soft_reset) {\n\t\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t\t\ttmp |= srbm_soft_reset;\n\t\t\tdev_info(adev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\t\tudelay(50);\n\n\t\t\ttmp &= ~srbm_soft_reset;\n\t\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t\t}\n\t\t \n\t\tudelay(50);\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v7_0_set_gfx_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t enum amdgpu_interrupt_state state)\n{\n\tu32 cp_int_cntl;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl &= ~CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl |= CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v7_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     int me, int pipe,\n\t\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tu32 mec_int_cntl, mec_int_cntl_reg;\n\n\t \n\n\tif (me == 1) {\n\t\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE0_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE1_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE2_INT_CNTL;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmec_int_cntl_reg = mmCP_ME1_PIPE3_INT_CNTL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"invalid me %d\\n\", me);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tmec_int_cntl = RREG32(mec_int_cntl_reg);\n\t\tmec_int_cntl &= ~CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tmec_int_cntl = RREG32(mec_int_cntl_reg);\n\t\tmec_int_cntl |= CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK;\n\t\tWREG32(mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v7_0_set_priv_reg_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t     struct amdgpu_irq_src *src,\n\t\t\t\t\t     unsigned type,\n\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tu32 cp_int_cntl;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl &= ~CP_INT_CNTL_RING0__PRIV_REG_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl |= CP_INT_CNTL_RING0__PRIV_REG_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_set_priv_inst_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t      struct amdgpu_irq_src *src,\n\t\t\t\t\t      unsigned type,\n\t\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tu32 cp_int_cntl;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl &= ~CP_INT_CNTL_RING0__PRIV_INSTR_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tcp_int_cntl = RREG32(mmCP_INT_CNTL_RING0);\n\t\tcp_int_cntl |= CP_INT_CNTL_RING0__PRIV_INSTR_INT_ENABLE_MASK;\n\t\tWREG32(mmCP_INT_CNTL_RING0, cp_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_set_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_irq_src *src,\n\t\t\t\t\t    unsigned type,\n\t\t\t\t\t    enum amdgpu_interrupt_state state)\n{\n\tswitch (type) {\n\tcase AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP:\n\t\tgfx_v7_0_set_gfx_eop_interrupt_state(adev, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 1, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE1_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 1, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE2_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 1, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE3_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 1, 3, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE0_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 2, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE1_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 2, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE2_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 2, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE3_EOP:\n\t\tgfx_v7_0_set_compute_eop_interrupt_state(adev, 2, 3, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v7_0_eop_irq(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_irq_src *source,\n\t\t\t    struct amdgpu_iv_entry *entry)\n{\n\tu8 me_id, pipe_id;\n\tstruct amdgpu_ring *ring;\n\tint i;\n\n\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tswitch (me_id) {\n\tcase 0:\n\t\tamdgpu_fence_process(&adev->gfx.gfx_ring[0]);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\tif ((ring->me == me_id) && (ring->pipe == pipe_id))\n\t\t\t\tamdgpu_fence_process(ring);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v7_0_fault(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tstruct amdgpu_ring *ring;\n\tu8 me_id, pipe_id;\n\tint i;\n\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tswitch (me_id) {\n\tcase 0:\n\t\tdrm_sched_fault(&adev->gfx.gfx_ring[0].sched);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\tif ((ring->me == me_id) && (ring->pipe == pipe_id))\n\t\t\t\tdrm_sched_fault(&ring->sched);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v7_0_priv_reg_irq(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal register access in command stream\\n\");\n\tgfx_v7_0_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v7_0_priv_inst_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal instruction in command stream\\n\");\n\t\n\tgfx_v7_0_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v7_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tbool gate = false;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (state == AMD_CG_STATE_GATE)\n\t\tgate = true;\n\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, false);\n\t \n\tif (gate) {\n\t\tgfx_v7_0_enable_mgcg(adev, true);\n\t\tgfx_v7_0_enable_cgcg(adev, true);\n\t} else {\n\t\tgfx_v7_0_enable_cgcg(adev, false);\n\t\tgfx_v7_0_enable_mgcg(adev, false);\n\t}\n\tgfx_v7_0_enable_gui_idle_interrupt(adev, true);\n\n\treturn 0;\n}\n\nstatic int gfx_v7_0_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\tbool gate = false;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (state == AMD_PG_STATE_GATE)\n\t\tgate = true;\n\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |\n\t\t\t      AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t      AMD_PG_SUPPORT_GFX_DMG |\n\t\t\t      AMD_PG_SUPPORT_CP |\n\t\t\t      AMD_PG_SUPPORT_GDS |\n\t\t\t      AMD_PG_SUPPORT_RLC_SMU_HS)) {\n\t\tgfx_v7_0_update_gfx_pg(adev, gate);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) {\n\t\t\tgfx_v7_0_enable_cp_pg(adev, gate);\n\t\t\tgfx_v7_0_enable_gds_pg(adev, gate);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v7_0_emit_mem_sync(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\tamdgpu_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA);   \n\tamdgpu_ring_write(ring, 0xffffffff);   \n\tamdgpu_ring_write(ring, 0);   \n\tamdgpu_ring_write(ring, 0x0000000A);  \n}\n\nstatic void gfx_v7_0_emit_mem_sync_compute(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_ACQUIRE_MEM, 5));\n\tamdgpu_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA);   \n\tamdgpu_ring_write(ring, 0xffffffff);\t \n\tamdgpu_ring_write(ring, 0xff);\t\t \n\tamdgpu_ring_write(ring, 0);\t\t \n\tamdgpu_ring_write(ring, 0);\t\t \n\tamdgpu_ring_write(ring, 0x0000000A);\t \n}\n\nstatic const struct amd_ip_funcs gfx_v7_0_ip_funcs = {\n\t.name = \"gfx_v7_0\",\n\t.early_init = gfx_v7_0_early_init,\n\t.late_init = gfx_v7_0_late_init,\n\t.sw_init = gfx_v7_0_sw_init,\n\t.sw_fini = gfx_v7_0_sw_fini,\n\t.hw_init = gfx_v7_0_hw_init,\n\t.hw_fini = gfx_v7_0_hw_fini,\n\t.suspend = gfx_v7_0_suspend,\n\t.resume = gfx_v7_0_resume,\n\t.is_idle = gfx_v7_0_is_idle,\n\t.wait_for_idle = gfx_v7_0_wait_for_idle,\n\t.soft_reset = gfx_v7_0_soft_reset,\n\t.set_clockgating_state = gfx_v7_0_set_clockgating_state,\n\t.set_powergating_state = gfx_v7_0_set_powergating_state,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v7_0_ring_funcs_gfx = {\n\t.type = AMDGPU_RING_TYPE_GFX,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = false,\n\t.get_rptr = gfx_v7_0_ring_get_rptr,\n\t.get_wptr = gfx_v7_0_ring_get_wptr_gfx,\n\t.set_wptr = gfx_v7_0_ring_set_wptr_gfx,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t12 + 12 + 12 +  \n\t\t7 + 4 +  \n\t\tCIK_FLUSH_GPU_TLB_NUM_WREG * 5 + 7 + 6 +  \n\t\t3 + 4 +  \n\t\t5,  \n\t.emit_ib_size = 4,  \n\t.emit_ib = gfx_v7_0_ring_emit_ib_gfx,\n\t.emit_fence = gfx_v7_0_ring_emit_fence_gfx,\n\t.emit_pipeline_sync = gfx_v7_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v7_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v7_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v7_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v7_0_ring_test_ring,\n\t.test_ib = gfx_v7_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_cntxcntl = gfx_v7_ring_emit_cntxcntl,\n\t.emit_wreg = gfx_v7_0_ring_emit_wreg,\n\t.soft_recovery = gfx_v7_0_ring_soft_recovery,\n\t.emit_mem_sync = gfx_v7_0_emit_mem_sync,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v7_0_ring_funcs_compute = {\n\t.type = AMDGPU_RING_TYPE_COMPUTE,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = false,\n\t.get_rptr = gfx_v7_0_ring_get_rptr,\n\t.get_wptr = gfx_v7_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v7_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tCIK_FLUSH_GPU_TLB_NUM_WREG * 5 + 7 +  \n\t\t7 + 7 + 7 +  \n\t\t7,  \n\t.emit_ib_size =\t7,  \n\t.emit_ib = gfx_v7_0_ring_emit_ib_compute,\n\t.emit_fence = gfx_v7_0_ring_emit_fence_compute,\n\t.emit_pipeline_sync = gfx_v7_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v7_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v7_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v7_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v7_0_ring_test_ring,\n\t.test_ib = gfx_v7_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_wreg = gfx_v7_0_ring_emit_wreg,\n\t.emit_mem_sync = gfx_v7_0_emit_mem_sync_compute,\n};\n\nstatic void gfx_v7_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tadev->gfx.gfx_ring[i].funcs = &gfx_v7_0_ring_funcs_gfx;\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tadev->gfx.compute_ring[i].funcs = &gfx_v7_0_ring_funcs_compute;\n}\n\nstatic const struct amdgpu_irq_src_funcs gfx_v7_0_eop_irq_funcs = {\n\t.set = gfx_v7_0_set_eop_interrupt_state,\n\t.process = gfx_v7_0_eop_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v7_0_priv_reg_irq_funcs = {\n\t.set = gfx_v7_0_set_priv_reg_fault_state,\n\t.process = gfx_v7_0_priv_reg_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v7_0_priv_inst_irq_funcs = {\n\t.set = gfx_v7_0_set_priv_inst_fault_state,\n\t.process = gfx_v7_0_priv_inst_irq,\n};\n\nstatic void gfx_v7_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.eop_irq.num_types = AMDGPU_CP_IRQ_LAST;\n\tadev->gfx.eop_irq.funcs = &gfx_v7_0_eop_irq_funcs;\n\n\tadev->gfx.priv_reg_irq.num_types = 1;\n\tadev->gfx.priv_reg_irq.funcs = &gfx_v7_0_priv_reg_irq_funcs;\n\n\tadev->gfx.priv_inst_irq.num_types = 1;\n\tadev->gfx.priv_inst_irq.funcs = &gfx_v7_0_priv_inst_irq_funcs;\n}\n\nstatic void gfx_v7_0_set_gds_init(struct amdgpu_device *adev)\n{\n\t \n\tadev->gds.gds_size = RREG32(mmGDS_VMID0_SIZE);\n\tadev->gds.gws_size = 64;\n\tadev->gds.oa_size = 16;\n\tadev->gds.gds_compute_max_wave_id = RREG32(mmGDS_COMPUTE_MAX_WAVE_ID);\n}\n\n\nstatic void gfx_v7_0_get_cu_info(struct amdgpu_device *adev)\n{\n\tint i, j, k, counter, active_cu_number = 0;\n\tu32 mask, bitmap, ao_bitmap, ao_cu_mask = 0;\n\tstruct amdgpu_cu_info *cu_info = &adev->gfx.cu_info;\n\tunsigned disable_masks[4 * 2];\n\tu32 ao_cu_num;\n\n\tif (adev->flags & AMD_IS_APU)\n\t\tao_cu_num = 2;\n\telse\n\t\tao_cu_num = adev->gfx.config.max_cu_per_sh;\n\n\tmemset(cu_info, 0, sizeof(*cu_info));\n\n\tamdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tao_bitmap = 0;\n\t\t\tcounter = 0;\n\t\t\tgfx_v7_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tif (i < 4 && j < 2)\n\t\t\t\tgfx_v7_0_set_user_cu_inactive_bitmap(\n\t\t\t\t\tadev, disable_masks[i * 2 + j]);\n\t\t\tbitmap = gfx_v7_0_get_cu_active_bitmap(adev);\n\t\t\tcu_info->bitmap[0][i][j] = bitmap;\n\n\t\t\tfor (k = 0; k < adev->gfx.config.max_cu_per_sh; k++) {\n\t\t\t\tif (bitmap & mask) {\n\t\t\t\t\tif (counter < ao_cu_num)\n\t\t\t\t\t\tao_bitmap |= mask;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\t\t\tactive_cu_number += counter;\n\t\t\tif (i < 2 && j < 2)\n\t\t\t\tao_cu_mask |= (ao_bitmap << (i * 16 + j * 8));\n\t\t\tcu_info->ao_cu_bitmap[i][j] = ao_bitmap;\n\t\t}\n\t}\n\tgfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tcu_info->number = active_cu_number;\n\tcu_info->ao_cu_mask = ao_cu_mask;\n\tcu_info->simd_per_cu = NUM_SIMD_PER_CU;\n\tcu_info->max_waves_per_simd = 10;\n\tcu_info->max_scratch_slots_per_cu = 32;\n\tcu_info->wave_front_size = 64;\n\tcu_info->lds_size = 64;\n}\n\nconst struct amdgpu_ip_block_version gfx_v7_1_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 7,\n\t.minor = 1,\n\t.rev = 0,\n\t.funcs = &gfx_v7_0_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version gfx_v7_2_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 7,\n\t.minor = 2,\n\t.rev = 0,\n\t.funcs = &gfx_v7_0_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version gfx_v7_3_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 7,\n\t.minor = 3,\n\t.rev = 0,\n\t.funcs = &gfx_v7_0_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}