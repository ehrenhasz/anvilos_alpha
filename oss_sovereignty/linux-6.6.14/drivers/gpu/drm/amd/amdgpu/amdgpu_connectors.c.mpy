{
  "module_name": "amdgpu_connectors.c",
  "hash_id": "135d09b0c57f58e886c4b492e27641665a5d3d182fb17d81f49b9266c216fd7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"atombios_encoders.h\"\n#include \"atombios_dp.h\"\n#include \"amdgpu_connectors.h\"\n#include \"amdgpu_i2c.h\"\n#include \"amdgpu_display.h\"\n\n#include <linux/pm_runtime.h>\n\nvoid amdgpu_connector_hotplug(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\t \n\tif (amdgpu_connector->hpd.hpd == AMDGPU_HPD_NONE)\n\t\treturn;\n\n\tamdgpu_display_hpd_set_polarity(adev, amdgpu_connector->hpd.hpd);\n\n\t \n\tif (connector->dpms != DRM_MODE_DPMS_ON)\n\t\treturn;\n\n\t \n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tstruct amdgpu_connector_atom_dig *dig_connector =\n\t\t\tamdgpu_connector->con_priv;\n\n\t\t \n\t\tif (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT)\n\t\t\treturn;\n\n\t\t \n\t\tdig_connector->dp_sink_type = amdgpu_atombios_dp_get_sinktype(amdgpu_connector);\n\t\t \n\t\tif (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT &&\n\t\t    amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd) &&\n\t\t    amdgpu_atombios_dp_needs_link_train(amdgpu_connector)) {\n\t\t\t \n\t\t\tif (amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tdrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\n\t\t\tdrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_connector_property_change_mode(struct drm_encoder *encoder)\n{\n\tstruct drm_crtc *crtc = encoder->crtc;\n\n\tif (crtc && crtc->enabled) {\n\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t crtc->x, crtc->y, crtc->primary->fb);\n\t}\n}\n\nint amdgpu_connector_get_monitor_bpc(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *dig_connector;\n\tint bpc = 8;\n\tunsigned mode_clock, max_tmds_clock;\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tif (amdgpu_connector->use_digital) {\n\t\t\tif (connector->display_info.is_hdmi) {\n\t\t\t\tif (connector->display_info.bpc)\n\t\t\t\t\tbpc = connector->display_info.bpc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tif (connector->display_info.is_hdmi) {\n\t\t\tif (connector->display_info.bpc)\n\t\t\t\tbpc = connector->display_info.bpc;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tdig_connector = amdgpu_connector->con_priv;\n\t\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) ||\n\t\t    connector->display_info.is_hdmi) {\n\t\t\tif (connector->display_info.bpc)\n\t\t\t\tbpc = connector->display_info.bpc;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tif (connector->display_info.bpc)\n\t\t\tbpc = connector->display_info.bpc;\n\t\telse {\n\t\t\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\t\t\tconnector->helper_private;\n\t\t\tstruct drm_encoder *encoder = connector_funcs->best_encoder(connector);\n\t\t\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\t\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\n\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_V13_6BIT_PER_COLOR)\n\t\t\t\tbpc = 6;\n\t\t\telse if (dig->lcd_misc & ATOM_PANEL_MISC_V13_8BIT_PER_COLOR)\n\t\t\t\tbpc = 8;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (connector->display_info.is_hdmi) {\n\t\t \n\t\tif (bpc > 12) {\n\t\t\tDRM_DEBUG(\"%s: HDMI deep color %d bpc unsupported. Using 12 bpc.\\n\",\n\t\t\t\t  connector->name, bpc);\n\t\t\tbpc = 12;\n\t\t}\n\n\t\t \n\t\tif (connector->display_info.max_tmds_clock > 0) {\n\t\t\t \n\t\t\tmode_clock = amdgpu_connector->pixelclock_for_modeset;\n\n\t\t\t \n\t\t\tmax_tmds_clock = connector->display_info.max_tmds_clock;\n\n\t\t\tDRM_DEBUG(\"%s: hdmi mode dotclock %d kHz, max tmds input clock %d kHz.\\n\",\n\t\t\t\t  connector->name, mode_clock, max_tmds_clock);\n\n\t\t\t \n\t\t\tif ((bpc == 12) && (mode_clock * 3/2 > max_tmds_clock)) {\n\t\t\t\tif ((connector->display_info.edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30) &&\n\t\t\t\t    (mode_clock * 5/4 <= max_tmds_clock))\n\t\t\t\t\tbpc = 10;\n\t\t\t\telse\n\t\t\t\t\tbpc = 8;\n\n\t\t\t\tDRM_DEBUG(\"%s: HDMI deep color 12 bpc exceeds max tmds clock. Using %d bpc.\\n\",\n\t\t\t\t\t  connector->name, bpc);\n\t\t\t}\n\n\t\t\tif ((bpc == 10) && (mode_clock * 5/4 > max_tmds_clock)) {\n\t\t\t\tbpc = 8;\n\t\t\t\tDRM_DEBUG(\"%s: HDMI deep color 10 bpc exceeds max tmds clock. Using %d bpc.\\n\",\n\t\t\t\t\t  connector->name, bpc);\n\t\t\t}\n\t\t} else if (bpc > 8) {\n\t\t\t \n\t\t\tDRM_DEBUG(\"%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\\n\",\n\t\t\t\t  connector->name);\n\t\t\tbpc = 8;\n\t\t}\n\t}\n\n\tif ((amdgpu_deep_color == 0) && (bpc > 8)) {\n\t\tDRM_DEBUG(\"%s: Deep color disabled. Set amdgpu module param deep_color=1 to enable.\\n\",\n\t\t\t  connector->name);\n\t\tbpc = 8;\n\t}\n\n\tDRM_DEBUG(\"%s: Display bpc=%d, returned bpc=%d\\n\",\n\t\t  connector->name, connector->display_info.bpc, bpc);\n\n\treturn bpc;\n}\n\nstatic void\namdgpu_connector_update_scratch_regs(struct drm_connector *connector,\n\t\t\t\t      enum drm_connector_status status)\n{\n\tstruct drm_encoder *best_encoder;\n\tstruct drm_encoder *encoder;\n\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\tbool connected;\n\n\tbest_encoder = connector_funcs->best_encoder(connector);\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif ((encoder == best_encoder) && (status == connector_status_connected))\n\t\t\tconnected = true;\n\t\telse\n\t\t\tconnected = false;\n\n\t\tamdgpu_atombios_encoder_set_bios_scratch_regs(connector, encoder, connected);\n\t}\n}\n\nstatic struct drm_encoder *\namdgpu_connector_find_encoder(struct drm_connector *connector,\n\t\t\t       int encoder_type)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif (encoder->encoder_type == encoder_type)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstruct edid *amdgpu_connector_edid(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct drm_property_blob *edid_blob = connector->edid_blob_ptr;\n\n\tif (amdgpu_connector->edid) {\n\t\treturn amdgpu_connector->edid;\n\t} else if (edid_blob) {\n\t\tstruct edid *edid = kmemdup(edid_blob->data, edid_blob->length, GFP_KERNEL);\n\t\tif (edid)\n\t\t\tamdgpu_connector->edid = edid;\n\t}\n\treturn amdgpu_connector->edid;\n}\n\nstatic struct edid *\namdgpu_connector_get_hardcoded_edid(struct amdgpu_device *adev)\n{\n\tstruct edid *edid;\n\n\tif (adev->mode_info.bios_hardcoded_edid) {\n\t\tedid = kmalloc(adev->mode_info.bios_hardcoded_edid_size, GFP_KERNEL);\n\t\tif (edid) {\n\t\t\tmemcpy((unsigned char *)edid,\n\t\t\t       (unsigned char *)adev->mode_info.bios_hardcoded_edid,\n\t\t\t       adev->mode_info.bios_hardcoded_edid_size);\n\t\t\treturn edid;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void amdgpu_connector_get_edid(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\tif (amdgpu_connector->edid)\n\t\treturn;\n\n\t \n\tif (amdgpu_connector->router.ddc_valid)\n\t\tamdgpu_i2c_router_select_ddc_port(amdgpu_connector);\n\n\tif ((amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t     ENCODER_OBJECT_ID_NONE) &&\n\t    amdgpu_connector->ddc_bus->has_aux) {\n\t\tamdgpu_connector->edid = drm_get_edid(connector,\n\t\t\t\t\t\t      &amdgpu_connector->ddc_bus->aux.ddc);\n\t} else if ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) ||\n\t\t   (connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\n\t\tstruct amdgpu_connector_atom_dig *dig = amdgpu_connector->con_priv;\n\n\t\tif ((dig->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT ||\n\t\t     dig->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) &&\n\t\t    amdgpu_connector->ddc_bus->has_aux)\n\t\t\tamdgpu_connector->edid = drm_get_edid(connector,\n\t\t\t\t\t\t\t      &amdgpu_connector->ddc_bus->aux.ddc);\n\t\telse if (amdgpu_connector->ddc_bus)\n\t\t\tamdgpu_connector->edid = drm_get_edid(connector,\n\t\t\t\t\t\t\t      &amdgpu_connector->ddc_bus->adapter);\n\t} else if (amdgpu_connector->ddc_bus) {\n\t\tamdgpu_connector->edid = drm_get_edid(connector,\n\t\t\t\t\t\t      &amdgpu_connector->ddc_bus->adapter);\n\t}\n\n\tif (!amdgpu_connector->edid) {\n\t\t \n\t\tif (((connector->connector_type == DRM_MODE_CONNECTOR_LVDS) ||\n\t\t     (connector->connector_type == DRM_MODE_CONNECTOR_eDP))) {\n\t\t\tamdgpu_connector->edid = amdgpu_connector_get_hardcoded_edid(adev);\n\t\t\tdrm_connector_update_edid_property(connector, amdgpu_connector->edid);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_connector_free_edid(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\tkfree(amdgpu_connector->edid);\n\tamdgpu_connector->edid = NULL;\n}\n\nstatic int amdgpu_connector_ddc_get_modes(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tint ret;\n\n\tif (amdgpu_connector->edid) {\n\t\tdrm_connector_update_edid_property(connector, amdgpu_connector->edid);\n\t\tret = drm_add_edid_modes(connector, amdgpu_connector->edid);\n\t\treturn ret;\n\t}\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic struct drm_encoder *\namdgpu_connector_best_single_encoder(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\n\t \n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void amdgpu_get_native_mode(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\n\tif (encoder == NULL)\n\t\treturn;\n\n\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\tif (!list_empty(&connector->probed_modes)) {\n\t\tstruct drm_display_mode *preferred_mode =\n\t\t\tlist_first_entry(&connector->probed_modes,\n\t\t\t\t\t struct drm_display_mode, head);\n\n\t\tamdgpu_encoder->native_mode = *preferred_mode;\n\t} else {\n\t\tamdgpu_encoder->native_mode.clock = 0;\n\t}\n}\n\nstatic struct drm_display_mode *\namdgpu_connector_lcd_native_mode(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\tif (native_mode->hdisplay != 0 &&\n\t    native_mode->vdisplay != 0 &&\n\t    native_mode->clock != 0) {\n\t\tmode = drm_mode_duplicate(dev, native_mode);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\n\t\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\t\tdrm_mode_set_name(mode);\n\n\t\tDRM_DEBUG_KMS(\"Adding native panel mode %s\\n\", mode->name);\n\t} else if (native_mode->hdisplay != 0 &&\n\t\t   native_mode->vdisplay != 0) {\n\t\t \n\t\t \n\t\tmode = drm_cvt_mode(dev, native_mode->hdisplay, native_mode->vdisplay, 60, true, false, false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\n\t\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\t\tDRM_DEBUG_KMS(\"Adding cvt approximation of native panel mode %s\\n\", mode->name);\n\t}\n\treturn mode;\n}\n\nstatic void amdgpu_connector_add_common_modes(struct drm_encoder *encoder,\n\t\t\t\t\t       struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\tint i;\n\tstatic const struct mode_size {\n\t\tint w;\n\t\tint h;\n\t} common_modes[17] = {\n\t\t{ 640,  480},\n\t\t{ 720,  480},\n\t\t{ 800,  600},\n\t\t{ 848,  480},\n\t\t{1024,  768},\n\t\t{1152,  768},\n\t\t{1280,  720},\n\t\t{1280,  800},\n\t\t{1280,  854},\n\t\t{1280,  960},\n\t\t{1280, 1024},\n\t\t{1440,  900},\n\t\t{1400, 1050},\n\t\t{1680, 1050},\n\t\t{1600, 1200},\n\t\t{1920, 1080},\n\t\t{1920, 1200}\n\t};\n\n\tfor (i = 0; i < 17; i++) {\n\t\tif (amdgpu_encoder->devices & (ATOM_DEVICE_TV_SUPPORT)) {\n\t\t\tif (common_modes[i].w > 1024 ||\n\t\t\t    common_modes[i].h > 768)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tif (common_modes[i].w > native_mode->hdisplay ||\n\t\t\t    common_modes[i].h > native_mode->vdisplay ||\n\t\t\t    (common_modes[i].w == native_mode->hdisplay &&\n\t\t\t     common_modes[i].h == native_mode->vdisplay))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (common_modes[i].w < 320 || common_modes[i].h < 200)\n\t\t\tcontinue;\n\n\t\tmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n}\n\nstatic int amdgpu_connector_set_property(struct drm_connector *connector,\n\t\t\t\t\t  struct drm_property *property,\n\t\t\t\t\t  uint64_t val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_encoder *encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\n\tif (property == adev->mode_info.coherent_mode_property) {\n\t\tstruct amdgpu_encoder_atom_dig *dig;\n\t\tbool new_coherent_mode;\n\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (!amdgpu_encoder->enc_priv)\n\t\t\treturn 0;\n\n\t\tdig = amdgpu_encoder->enc_priv;\n\t\tnew_coherent_mode = val ? true : false;\n\t\tif (dig->coherent_mode != new_coherent_mode) {\n\t\t\tdig->coherent_mode = new_coherent_mode;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.audio_property) {\n\t\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (amdgpu_connector->audio != val) {\n\t\t\tamdgpu_connector->audio = val;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.dither_property) {\n\t\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (amdgpu_connector->dither != val) {\n\t\t\tamdgpu_connector->dither = val;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.underscan_property) {\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (amdgpu_encoder->underscan_type != val) {\n\t\t\tamdgpu_encoder->underscan_type = val;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.underscan_hborder_property) {\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (amdgpu_encoder->underscan_hborder != val) {\n\t\t\tamdgpu_encoder->underscan_hborder = val;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.underscan_vborder_property) {\n\t\t \n\t\tencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tif (amdgpu_encoder->underscan_vborder != val) {\n\t\t\tamdgpu_encoder->underscan_vborder = val;\n\t\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t\t}\n\t}\n\n\tif (property == adev->mode_info.load_detect_property) {\n\t\tstruct amdgpu_connector *amdgpu_connector =\n\t\t\tto_amdgpu_connector(connector);\n\n\t\tif (val == 0)\n\t\t\tamdgpu_connector->dac_load_detect = false;\n\t\telse\n\t\t\tamdgpu_connector->dac_load_detect = true;\n\t}\n\n\tif (property == dev->mode_config.scaling_mode_property) {\n\t\tenum amdgpu_rmx_type rmx_type;\n\n\t\tif (connector->encoder) {\n\t\t\tamdgpu_encoder = to_amdgpu_encoder(connector->encoder);\n\t\t} else {\n\t\t\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\t\t\tamdgpu_encoder = to_amdgpu_encoder(connector_funcs->best_encoder(connector));\n\t\t}\n\n\t\tswitch (val) {\n\t\tdefault:\n\t\tcase DRM_MODE_SCALE_NONE:\n\t\t\trmx_type = RMX_OFF;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_CENTER:\n\t\t\trmx_type = RMX_CENTER;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_ASPECT:\n\t\t\trmx_type = RMX_ASPECT;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\t\trmx_type = RMX_FULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (amdgpu_encoder->rmx_type == rmx_type)\n\t\t\treturn 0;\n\n\t\tif ((rmx_type != DRM_MODE_SCALE_NONE) &&\n\t\t    (amdgpu_encoder->native_mode.clock == 0))\n\t\t\treturn 0;\n\n\t\tamdgpu_encoder->rmx_type = rmx_type;\n\n\t\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\t}\n\n\treturn 0;\n}\n\nstatic void\namdgpu_connector_fixup_lcd_native_mode(struct drm_encoder *encoder,\n\t\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct amdgpu_encoder *amdgpu_encoder =\tto_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\tstruct drm_display_mode *t, *mode;\n\n\t \n\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\n\t\tif (mode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tif (mode->hdisplay != native_mode->hdisplay ||\n\t\t\t    mode->vdisplay != native_mode->vdisplay)\n\t\t\t\tdrm_mode_copy(native_mode, mode);\n\t\t}\n\t}\n\n\t \n\tif (!native_mode->clock) {\n\t\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\n\t\t\tif (mode->hdisplay == native_mode->hdisplay &&\n\t\t\t    mode->vdisplay == native_mode->vdisplay) {\n\t\t\t\tdrm_mode_copy(native_mode, mode);\n\t\t\t\tdrm_mode_set_crtcinfo(native_mode, CRTC_INTERLACE_HALVE_V);\n\t\t\t\tDRM_DEBUG_KMS(\"Determined LVDS native mode details from EDID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!native_mode->clock) {\n\t\tDRM_DEBUG_KMS(\"No LVDS native mode details, disabling RMX\\n\");\n\t\tamdgpu_encoder->rmx_type = RMX_OFF;\n\t}\n}\n\nstatic int amdgpu_connector_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\tstruct drm_display_mode *mode;\n\n\tamdgpu_connector_get_edid(connector);\n\tret = amdgpu_connector_ddc_get_modes(connector);\n\tif (ret > 0) {\n\t\tencoder = amdgpu_connector_best_single_encoder(connector);\n\t\tif (encoder) {\n\t\t\tamdgpu_connector_fixup_lcd_native_mode(encoder, connector);\n\t\t\t \n\t\t\tamdgpu_connector_add_common_modes(encoder, connector);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tencoder = amdgpu_connector_best_single_encoder(connector);\n\tif (!encoder)\n\t\treturn 0;\n\n\t \n\tmode = amdgpu_connector_lcd_native_mode(encoder);\n\tif (mode) {\n\t\tret = 1;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\t \n\t\tconnector->display_info.width_mm = mode->width_mm;\n\t\tconnector->display_info.height_mm = mode->height_mm;\n\t\t \n\t\tamdgpu_connector_add_common_modes(encoder, connector);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status amdgpu_connector_lvds_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\n\tif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\n\t\treturn MODE_PANEL;\n\n\tif (encoder) {\n\t\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\t\t \n\t\tif ((mode->hdisplay > native_mode->hdisplay) ||\n\t\t    (mode->vdisplay > native_mode->vdisplay))\n\t\t\treturn MODE_PANEL;\n\n\t\t \n\t\tif (amdgpu_encoder->rmx_type == RMX_OFF) {\n\t\t\tif ((mode->hdisplay != native_mode->hdisplay) ||\n\t\t\t    (mode->vdisplay != native_mode->vdisplay))\n\t\t\t\treturn MODE_PANEL;\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\namdgpu_connector_lvds_detect(struct drm_connector *connector, bool force)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (encoder) {\n\t\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\t\t \n\t\tif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\n\t\t\tret = connector_status_connected;\n\n\t}\n\n\t \n\tamdgpu_connector_get_edid(connector);\n\tif (amdgpu_connector->edid)\n\t\tret = connector_status_connected;\n\t \n\n\tamdgpu_connector_update_scratch_regs(connector, ret);\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void amdgpu_connector_unregister(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\tif (amdgpu_connector->ddc_bus && amdgpu_connector->ddc_bus->has_aux) {\n\t\tdrm_dp_aux_unregister(&amdgpu_connector->ddc_bus->aux);\n\t\tamdgpu_connector->ddc_bus->has_aux = false;\n\t}\n}\n\nstatic void amdgpu_connector_destroy(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\tamdgpu_connector_free_edid(connector);\n\tkfree(amdgpu_connector->con_priv);\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tkfree(connector);\n}\n\nstatic int amdgpu_connector_set_lcd_property(struct drm_connector *connector,\n\t\t\t\t\t      struct drm_property *property,\n\t\t\t\t\t      uint64_t value)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\tenum amdgpu_rmx_type rmx_type;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\tif (property != dev->mode_config.scaling_mode_property)\n\t\treturn 0;\n\n\tif (connector->encoder)\n\t\tamdgpu_encoder = to_amdgpu_encoder(connector->encoder);\n\telse {\n\t\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\t\tamdgpu_encoder = to_amdgpu_encoder(connector_funcs->best_encoder(connector));\n\t}\n\n\tswitch (value) {\n\tcase DRM_MODE_SCALE_NONE:\n\t\trmx_type = RMX_OFF;\n\t\tbreak;\n\tcase DRM_MODE_SCALE_CENTER:\n\t\trmx_type = RMX_CENTER;\n\t\tbreak;\n\tcase DRM_MODE_SCALE_ASPECT:\n\t\trmx_type = RMX_ASPECT;\n\t\tbreak;\n\tdefault:\n\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\trmx_type = RMX_FULL;\n\t\tbreak;\n\t}\n\n\tif (amdgpu_encoder->rmx_type == rmx_type)\n\t\treturn 0;\n\n\tamdgpu_encoder->rmx_type = rmx_type;\n\n\tamdgpu_connector_property_change_mode(&amdgpu_encoder->base);\n\treturn 0;\n}\n\n\nstatic const struct drm_connector_helper_funcs amdgpu_connector_lvds_helper_funcs = {\n\t.get_modes = amdgpu_connector_lvds_get_modes,\n\t.mode_valid = amdgpu_connector_lvds_mode_valid,\n\t.best_encoder = amdgpu_connector_best_single_encoder,\n};\n\nstatic const struct drm_connector_funcs amdgpu_connector_lvds_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = amdgpu_connector_lvds_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.early_unregister = amdgpu_connector_unregister,\n\t.destroy = amdgpu_connector_destroy,\n\t.set_property = amdgpu_connector_set_lcd_property,\n};\n\nstatic int amdgpu_connector_vga_get_modes(struct drm_connector *connector)\n{\n\tint ret;\n\n\tamdgpu_connector_get_edid(connector);\n\tret = amdgpu_connector_ddc_get_modes(connector);\n\tamdgpu_get_native_mode(connector);\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status amdgpu_connector_vga_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\t \n\n\tif ((mode->clock / 10) > adev->clock.max_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\namdgpu_connector_vga_detect(struct drm_connector *connector, bool force)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct drm_encoder *encoder;\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tbool dret = false;\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tencoder = amdgpu_connector_best_single_encoder(connector);\n\tif (!encoder)\n\t\tret = connector_status_disconnected;\n\n\tif (amdgpu_connector->ddc_bus)\n\t\tdret = amdgpu_display_ddc_probe(amdgpu_connector, false);\n\tif (dret) {\n\t\tamdgpu_connector->detected_by_load = false;\n\t\tamdgpu_connector_free_edid(connector);\n\t\tamdgpu_connector_get_edid(connector);\n\n\t\tif (!amdgpu_connector->edid) {\n\t\t\tDRM_ERROR(\"%s: probed a monitor but no|invalid EDID\\n\",\n\t\t\t\t\tconnector->name);\n\t\t\tret = connector_status_connected;\n\t\t} else {\n\t\t\tamdgpu_connector->use_digital =\n\t\t\t\t!!(amdgpu_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\n\n\t\t\t \n\t\t\tif (amdgpu_connector->use_digital && amdgpu_connector->shared_ddc) {\n\t\t\t\tamdgpu_connector_free_edid(connector);\n\t\t\t\tret = connector_status_disconnected;\n\t\t\t} else {\n\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\t \n\t\tif (!force) {\n\t\t\t \n\t\t\tif (amdgpu_connector->detected_by_load)\n\t\t\t\tret = connector->status;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (amdgpu_connector->dac_load_detect && encoder) {\n\t\t\tencoder_funcs = encoder->helper_private;\n\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\tif (ret != connector_status_disconnected)\n\t\t\t\tamdgpu_connector->detected_by_load = true;\n\t\t}\n\t}\n\n\tamdgpu_connector_update_scratch_regs(connector, ret);\n\nout:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs amdgpu_connector_vga_helper_funcs = {\n\t.get_modes = amdgpu_connector_vga_get_modes,\n\t.mode_valid = amdgpu_connector_vga_mode_valid,\n\t.best_encoder = amdgpu_connector_best_single_encoder,\n};\n\nstatic const struct drm_connector_funcs amdgpu_connector_vga_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = amdgpu_connector_vga_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.early_unregister = amdgpu_connector_unregister,\n\t.destroy = amdgpu_connector_destroy,\n\t.set_property = amdgpu_connector_set_property,\n};\n\nstatic bool\namdgpu_connector_check_hpd_status_unchanged(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tenum drm_connector_status status;\n\n\tif (amdgpu_connector->hpd.hpd != AMDGPU_HPD_NONE) {\n\t\tif (amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd))\n\t\t\tstatus = connector_status_connected;\n\t\telse\n\t\t\tstatus = connector_status_disconnected;\n\t\tif (connector->status == status)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic enum drm_connector_status\namdgpu_connector_dvi_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tint r;\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tbool dret = false, broken_edid = false;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (amdgpu_connector->detected_hpd_without_ddc) {\n\t\tforce = true;\n\t\tamdgpu_connector->detected_hpd_without_ddc = false;\n\t}\n\n\tif (!force && amdgpu_connector_check_hpd_status_unchanged(connector)) {\n\t\tret = connector->status;\n\t\tgoto exit;\n\t}\n\n\tif (amdgpu_connector->ddc_bus) {\n\t\tdret = amdgpu_display_ddc_probe(amdgpu_connector, false);\n\n\t\t \n\t\tif (!dret && !force &&\n\t\t    amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\n\t\t\tDRM_DEBUG_KMS(\"hpd detected without ddc, retrying in 1 second\\n\");\n\t\t\tamdgpu_connector->detected_hpd_without_ddc = true;\n\t\t\tschedule_delayed_work(&adev->hotplug_work,\n\t\t\t\t\t      msecs_to_jiffies(1000));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (dret) {\n\t\tamdgpu_connector->detected_by_load = false;\n\t\tamdgpu_connector_free_edid(connector);\n\t\tamdgpu_connector_get_edid(connector);\n\n\t\tif (!amdgpu_connector->edid) {\n\t\t\tDRM_ERROR(\"%s: probed a monitor but no|invalid EDID\\n\",\n\t\t\t\t\tconnector->name);\n\t\t\tret = connector_status_connected;\n\t\t\tbroken_edid = true;  \n\t\t} else {\n\t\t\tamdgpu_connector->use_digital =\n\t\t\t\t!!(amdgpu_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\n\n\t\t\t \n\t\t\tif ((!amdgpu_connector->use_digital) && amdgpu_connector->shared_ddc) {\n\t\t\t\tamdgpu_connector_free_edid(connector);\n\t\t\t\tret = connector_status_disconnected;\n\t\t\t} else {\n\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (amdgpu_connector->shared_ddc && (ret == connector_status_connected)) {\n\t\t\t\tstruct drm_connector *list_connector;\n\t\t\t\tstruct drm_connector_list_iter iter;\n\t\t\t\tstruct amdgpu_connector *list_amdgpu_connector;\n\n\t\t\t\tdrm_connector_list_iter_begin(dev, &iter);\n\t\t\t\tdrm_for_each_connector_iter(list_connector,\n\t\t\t\t\t\t\t    &iter) {\n\t\t\t\t\tif (connector == list_connector)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tlist_amdgpu_connector = to_amdgpu_connector(list_connector);\n\t\t\t\t\tif (list_amdgpu_connector->shared_ddc &&\n\t\t\t\t\t    (list_amdgpu_connector->ddc_bus->rec.i2c_id ==\n\t\t\t\t\t     amdgpu_connector->ddc_bus->rec.i2c_id)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (list_connector->connector_type != DRM_MODE_CONNECTOR_VGA) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (!amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\n\t\t\t\t\t\t\t\tamdgpu_connector_free_edid(connector);\n\t\t\t\t\t\t\t\tret = connector_status_disconnected;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrm_connector_list_iter_end(&iter);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ret == connector_status_connected) && (amdgpu_connector->use_digital == true))\n\t\tgoto out;\n\n\t \n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_DVID) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))\n\t\tgoto out;\n\n\t \n\tif (!force) {\n\t\t \n\t\tif (amdgpu_connector->detected_by_load)\n\t\t\tret = connector->status;\n\t\tgoto out;\n\t}\n\n\t \n\tif (amdgpu_connector->dac_load_detect) {\n\t\tstruct drm_encoder *encoder;\n\n\t\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\t\tif (encoder->encoder_type != DRM_MODE_ENCODER_DAC &&\n\t\t\t    encoder->encoder_type != DRM_MODE_ENCODER_TVDAC)\n\t\t\t\tcontinue;\n\n\t\t\tencoder_funcs = encoder->helper_private;\n\t\t\tif (encoder_funcs->detect) {\n\t\t\t\tif (!broken_edid) {\n\t\t\t\t\tif (ret != connector_status_connected) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\t\t\t\tif (ret == connector_status_connected) {\n\t\t\t\t\t\t\tamdgpu_connector->use_digital = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret != connector_status_disconnected)\n\t\t\t\t\t\t\tamdgpu_connector->detected_by_load = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tenum drm_connector_status lret;\n\t\t\t\t\t \n\t\t\t\t\tamdgpu_connector->use_digital = true;\n\t\t\t\t\tlret = encoder_funcs->detect(encoder, connector);\n\t\t\t\t\tDRM_DEBUG_KMS(\"load_detect %x returned: %x\\n\",\n\t\t\t\t\t\t      encoder->encoder_type, lret);\n\t\t\t\t\tif (lret == connector_status_connected)\n\t\t\t\t\t\tamdgpu_connector->use_digital = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t \n\tamdgpu_connector_update_scratch_regs(connector, ret);\n\nexit:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct drm_encoder *\namdgpu_connector_dvi_encoder(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct drm_encoder *encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif (amdgpu_connector->use_digital == true) {\n\t\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\n\t\t\t\treturn encoder;\n\t\t} else {\n\t\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DAC ||\n\t\t\t    encoder->encoder_type == DRM_MODE_ENCODER_TVDAC)\n\t\t\t\treturn encoder;\n\t\t}\n\t}\n\n\t \n\n\t \n\t \n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void amdgpu_connector_dvi_force(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tif (connector->force == DRM_FORCE_ON)\n\t\tamdgpu_connector->use_digital = false;\n\tif (connector->force == DRM_FORCE_ON_DIGITAL)\n\t\tamdgpu_connector->use_digital = true;\n}\n\nstatic enum drm_mode_status amdgpu_connector_dvi_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\n\t \n\n\tif (amdgpu_connector->use_digital && (mode->clock > 165000)) {\n\t\tif ((amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I) ||\n\t\t    (amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D) ||\n\t\t    (amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_HDMI_TYPE_B)) {\n\t\t\treturn MODE_OK;\n\t\t} else if (connector->display_info.is_hdmi) {\n\t\t\t \n\t\t\tif (mode->clock > 340000)\n\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\telse\n\t\t\t\treturn MODE_OK;\n\t\t} else {\n\t\t\treturn MODE_CLOCK_HIGH;\n\t\t}\n\t}\n\n\t \n\tif ((mode->clock / 10) > adev->clock.max_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs amdgpu_connector_dvi_helper_funcs = {\n\t.get_modes = amdgpu_connector_vga_get_modes,\n\t.mode_valid = amdgpu_connector_dvi_mode_valid,\n\t.best_encoder = amdgpu_connector_dvi_encoder,\n};\n\nstatic const struct drm_connector_funcs amdgpu_connector_dvi_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = amdgpu_connector_dvi_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = amdgpu_connector_set_property,\n\t.early_unregister = amdgpu_connector_unregister,\n\t.destroy = amdgpu_connector_destroy,\n\t.force = amdgpu_connector_dvi_force,\n};\n\nstatic int amdgpu_connector_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\n\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\tint ret;\n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t\tif (!amdgpu_dig_connector->edp_on)\n\t\t\t\tamdgpu_atombios_encoder_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t\t\tamdgpu_connector_get_edid(connector);\n\t\t\tret = amdgpu_connector_ddc_get_modes(connector);\n\t\t\tif (!amdgpu_dig_connector->edp_on)\n\t\t\t\tamdgpu_atombios_encoder_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_OFF);\n\t\t} else {\n\t\t\t \n\t\t\tif (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t\t    ENCODER_OBJECT_ID_NONE) {\n\t\t\t\tif (encoder)\n\t\t\t\t\tamdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\n\t\t\t}\n\t\t\tamdgpu_connector_get_edid(connector);\n\t\t\tret = amdgpu_connector_ddc_get_modes(connector);\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tif (encoder) {\n\t\t\t\tamdgpu_connector_fixup_lcd_native_mode(encoder, connector);\n\t\t\t\t \n\t\t\t\tamdgpu_connector_add_common_modes(encoder, connector);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\t \n\t\tmode = amdgpu_connector_lcd_native_mode(encoder);\n\t\tif (mode) {\n\t\t\tret = 1;\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\t \n\t\t\tconnector->display_info.width_mm = mode->width_mm;\n\t\t\tconnector->display_info.height_mm = mode->height_mm;\n\t\t\t \n\t\t\tamdgpu_connector_add_common_modes(encoder, connector);\n\t\t}\n\t} else {\n\t\t \n\t\tif (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t\tENCODER_OBJECT_ID_NONE) {\n\t\t\tif (encoder)\n\t\t\t\tamdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\n\t\t}\n\t\tamdgpu_connector_get_edid(connector);\n\t\tret = amdgpu_connector_ddc_get_modes(connector);\n\n\t\tamdgpu_get_native_mode(connector);\n\t}\n\n\treturn ret;\n}\n\nu16 amdgpu_connector_encoder_get_dp_bridge_encoder_id(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\t\tswitch (amdgpu_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_TRAVIS:\n\t\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t\treturn amdgpu_encoder->encoder_id;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ENCODER_OBJECT_ID_NONE;\n}\n\nstatic bool amdgpu_connector_encoder_is_hbr2(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\tbool found = false;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\tif (amdgpu_encoder->caps & ATOM_ENCODER_CAP_RECORD_HBR2)\n\t\t\tfound = true;\n\t}\n\n\treturn found;\n}\n\nbool amdgpu_connector_is_dp12_capable(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tif ((adev->clock.default_dispclk >= 53900) &&\n\t    amdgpu_connector_encoder_is_hbr2(connector)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic enum drm_connector_status\namdgpu_connector_dp_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\n\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (!force && amdgpu_connector_check_hpd_status_unchanged(connector)) {\n\t\tret = connector->status;\n\t\tgoto out;\n\t}\n\n\tamdgpu_connector_free_edid(connector);\n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tif (encoder) {\n\t\t\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\t\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\t\t\t \n\t\t\tif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\n\t\t\t\tret = connector_status_connected;\n\t\t}\n\t\t \n\t\tamdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\n\t\tif (!amdgpu_dig_connector->edp_on)\n\t\t\tamdgpu_atombios_encoder_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t\tif (!amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\n\t\t\tret = connector_status_connected;\n\t\tif (!amdgpu_dig_connector->edp_on)\n\t\t\tamdgpu_atombios_encoder_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_OFF);\n\t} else if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t   ENCODER_OBJECT_ID_NONE) {\n\t\t \n\t\tamdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\n\t\t \n\t\tamdgpu_atombios_dp_get_dpcd(amdgpu_connector);\n\n\t\tif (encoder) {\n\t\t\t \n\t\t\tamdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\n\t\t\t \n\t\t\t \n\t\t\tif (amdgpu_display_ddc_probe(amdgpu_connector, true))\n\t\t\t\tret = connector_status_connected;\n\t\t\telse if (amdgpu_connector->dac_load_detect) {  \n\t\t\t\tconst struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\n\t\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tamdgpu_dig_connector->dp_sink_type =\n\t\t\tamdgpu_atombios_dp_get_sinktype(amdgpu_connector);\n\t\tif (amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\n\t\t\tret = connector_status_connected;\n\t\t\tif (amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)\n\t\t\t\tamdgpu_atombios_dp_get_dpcd(amdgpu_connector);\n\t\t} else {\n\t\t\tif (amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\n\t\t\t\tif (!amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\n\t\t\t\t\tret = connector_status_connected;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (amdgpu_display_ddc_probe(amdgpu_connector,\n\t\t\t\t\t\t\t     false))\n\t\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_connector_update_scratch_regs(connector, ret);\nout:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\tdrm_dp_set_subconnector_property(&amdgpu_connector->base,\n\t\t\t\t\t\t ret,\n\t\t\t\t\t\t amdgpu_dig_connector->dpcd,\n\t\t\t\t\t\t amdgpu_dig_connector->downstream_ports);\n\treturn ret;\n}\n\nstatic enum drm_mode_status amdgpu_connector_dp_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\n\n\t \n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\n\n\t\tif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\n\t\t\treturn MODE_PANEL;\n\n\t\tif (encoder) {\n\t\t\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\t\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\t\t\t \n\t\t\tif ((mode->hdisplay > native_mode->hdisplay) ||\n\t\t\t    (mode->vdisplay > native_mode->vdisplay))\n\t\t\t\treturn MODE_PANEL;\n\n\t\t\t \n\t\t\tif (amdgpu_encoder->rmx_type == RMX_OFF) {\n\t\t\t\tif ((mode->hdisplay != native_mode->hdisplay) ||\n\t\t\t\t    (mode->vdisplay != native_mode->vdisplay))\n\t\t\t\t\treturn MODE_PANEL;\n\t\t\t}\n\t\t}\n\t\treturn MODE_OK;\n\t} else {\n\t\tif ((amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\n\t\t\treturn amdgpu_atombios_dp_mode_valid_helper(connector, mode);\n\t\t} else {\n\t\t\tif (connector->display_info.is_hdmi) {\n\t\t\t\t \n\t\t\t\tif (mode->clock > 340000)\n\t\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\t} else {\n\t\t\t\tif (mode->clock > 165000)\n\t\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic int\namdgpu_connector_late_register(struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tint r = 0;\n\n\tif (amdgpu_connector->ddc_bus->has_aux) {\n\t\tamdgpu_connector->ddc_bus->aux.dev = amdgpu_connector->base.kdev;\n\t\tr = drm_dp_aux_register(&amdgpu_connector->ddc_bus->aux);\n\t}\n\n\treturn r;\n}\n\nstatic const struct drm_connector_helper_funcs amdgpu_connector_dp_helper_funcs = {\n\t.get_modes = amdgpu_connector_dp_get_modes,\n\t.mode_valid = amdgpu_connector_dp_mode_valid,\n\t.best_encoder = amdgpu_connector_dvi_encoder,\n};\n\nstatic const struct drm_connector_funcs amdgpu_connector_dp_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = amdgpu_connector_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = amdgpu_connector_set_property,\n\t.early_unregister = amdgpu_connector_unregister,\n\t.destroy = amdgpu_connector_destroy,\n\t.force = amdgpu_connector_dvi_force,\n\t.late_register = amdgpu_connector_late_register,\n};\n\nstatic const struct drm_connector_funcs amdgpu_connector_edp_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = amdgpu_connector_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = amdgpu_connector_set_lcd_property,\n\t.early_unregister = amdgpu_connector_unregister,\n\t.destroy = amdgpu_connector_destroy,\n\t.force = amdgpu_connector_dvi_force,\n\t.late_register = amdgpu_connector_late_register,\n};\n\nvoid\namdgpu_connector_add(struct amdgpu_device *adev,\n\t\t      uint32_t connector_id,\n\t\t      uint32_t supported_device,\n\t\t      int connector_type,\n\t\t      struct amdgpu_i2c_bus_rec *i2c_bus,\n\t\t      uint16_t connector_object_id,\n\t\t      struct amdgpu_hpd *hpd,\n\t\t      struct amdgpu_router *router)\n{\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\tstruct amdgpu_connector *amdgpu_connector;\n\tstruct amdgpu_connector_atom_dig *amdgpu_dig_connector;\n\tstruct drm_encoder *encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\tstruct i2c_adapter *ddc = NULL;\n\tuint32_t subpixel_order = SubPixelNone;\n\tbool shared_ddc = false;\n\tbool is_dp_bridge = false;\n\tbool has_aux = false;\n\n\tif (connector_type == DRM_MODE_CONNECTOR_Unknown)\n\t\treturn;\n\n\t \n\tdrm_connector_list_iter_begin(dev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\t\tamdgpu_connector = to_amdgpu_connector(connector);\n\t\tif (amdgpu_connector->connector_id == connector_id) {\n\t\t\tamdgpu_connector->devices |= supported_device;\n\t\t\tdrm_connector_list_iter_end(&iter);\n\t\t\treturn;\n\t\t}\n\t\tif (amdgpu_connector->ddc_bus && i2c_bus->valid) {\n\t\t\tif (amdgpu_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {\n\t\t\t\tamdgpu_connector->shared_ddc = true;\n\t\t\t\tshared_ddc = true;\n\t\t\t}\n\t\t\tif (amdgpu_connector->router_bus && router->ddc_valid &&\n\t\t\t    (amdgpu_connector->router.router_id == router->router_id)) {\n\t\t\t\tamdgpu_connector->shared_ddc = false;\n\t\t\t\tshared_ddc = false;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\t\tif (amdgpu_encoder->devices & supported_device) {\n\t\t\tswitch (amdgpu_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_TRAVIS:\n\t\t\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t\t\tis_dp_bridge = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_connector = kzalloc(sizeof(struct amdgpu_connector), GFP_KERNEL);\n\tif (!amdgpu_connector)\n\t\treturn;\n\n\tconnector = &amdgpu_connector->base;\n\n\tamdgpu_connector->connector_id = connector_id;\n\tamdgpu_connector->devices = supported_device;\n\tamdgpu_connector->shared_ddc = shared_ddc;\n\tamdgpu_connector->connector_object_id = connector_object_id;\n\tamdgpu_connector->hpd = *hpd;\n\n\tamdgpu_connector->router = *router;\n\tif (router->ddc_valid || router->cd_valid) {\n\t\tamdgpu_connector->router_bus = amdgpu_i2c_lookup(adev, &router->i2c_info);\n\t\tif (!amdgpu_connector->router_bus)\n\t\t\tDRM_ERROR(\"Failed to assign router i2c bus! Check dmesg for i2c errors.\\n\");\n\t}\n\n\tif (is_dp_bridge) {\n\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\tif (!amdgpu_dig_connector)\n\t\t\tgoto failed;\n\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\tif (i2c_bus->valid) {\n\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\tif (amdgpu_connector->ddc_bus) {\n\t\t\t\thas_aux = true;\n\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t} else {\n\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t}\n\t\t}\n\t\tswitch (connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_VGA:\n\t\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\tdefault:\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_dp_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base,\n\t\t\t\t\t\t &amdgpu_connector_dp_helper_funcs);\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tamdgpu_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVII:\n\t\tcase DRM_MODE_CONNECTOR_DVID:\n\t\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_dp_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base,\n\t\t\t\t\t\t &amdgpu_connector_dp_helper_funcs);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.underscan_property,\n\t\t\t\t\t\t      UNDERSCAN_OFF);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t      0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t      0);\n\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.dither_property,\n\t\t\t\t\t\t   AMDGPU_FMT_DITHER_DISABLE);\n\n\t\t\tif (amdgpu_audio != 0) {\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t   adev->mode_info.audio_property,\n\t\t\t\t\t\t\t   AMDGPU_AUDIO_AUTO);\n\t\t\t\tamdgpu_connector->audio = AMDGPU_AUDIO_AUTO;\n\t\t\t}\n\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII) {\n\t\t\t\tamdgpu_connector->dac_load_detect = true;\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t      adev->mode_info.load_detect_property,\n\t\t\t\t\t\t\t      1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_edp_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base,\n\t\t\t\t\t\t &amdgpu_connector_dp_helper_funcs);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_VGA:\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (!amdgpu_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_vga_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_vga_helper_funcs);\n\t\t\tamdgpu_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\t \n\t\t\tamdgpu_connector->hpd.hpd = AMDGPU_HPD_NONE;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (!amdgpu_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_vga_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_vga_helper_funcs);\n\t\t\tamdgpu_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\t \n\t\t\tamdgpu_connector->hpd.hpd = AMDGPU_HPD_NONE;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVII:\n\t\tcase DRM_MODE_CONNECTOR_DVID:\n\t\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!amdgpu_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (!amdgpu_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_dvi_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dvi_helper_funcs);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_property,\n\t\t\t\t\t\t   UNDERSCAN_OFF);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\n\t\t\tif (amdgpu_audio != 0) {\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t   adev->mode_info.audio_property,\n\t\t\t\t\t\t\t   AMDGPU_AUDIO_AUTO);\n\t\t\t\tamdgpu_connector->audio = AMDGPU_AUDIO_AUTO;\n\t\t\t}\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.dither_property,\n\t\t\t\t\t\t   AMDGPU_FMT_DITHER_DISABLE);\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII) {\n\t\t\t\tamdgpu_connector->dac_load_detect = true;\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t   adev->mode_info.load_detect_property,\n\t\t\t\t\t\t\t   1);\n\t\t\t}\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!amdgpu_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (!amdgpu_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_dvi_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dvi_helper_funcs);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_property,\n\t\t\t\t\t\t   UNDERSCAN_OFF);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tif (amdgpu_audio != 0) {\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t   adev->mode_info.audio_property,\n\t\t\t\t\t\t\t   AMDGPU_AUDIO_AUTO);\n\t\t\t\tamdgpu_connector->audio = AMDGPU_AUDIO_AUTO;\n\t\t\t}\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.dither_property,\n\t\t\t\t\t\t   AMDGPU_FMT_DITHER_DISABLE);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!amdgpu_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (amdgpu_connector->ddc_bus) {\n\t\t\t\t\thas_aux = true;\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t\t} else {\n\t\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_dp_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dp_helper_funcs);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      adev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_property,\n\t\t\t\t\t\t   UNDERSCAN_OFF);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t   0);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tif (amdgpu_audio != 0) {\n\t\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t\t   adev->mode_info.audio_property,\n\t\t\t\t\t\t\t   AMDGPU_AUDIO_AUTO);\n\t\t\t\tamdgpu_connector->audio = AMDGPU_AUDIO_AUTO;\n\t\t\t}\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t   adev->mode_info.dither_property,\n\t\t\t\t\t\t   AMDGPU_FMT_DITHER_DISABLE);\n\t\t\tconnector->interlace_allowed = true;\n\t\t\t \n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!amdgpu_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (amdgpu_connector->ddc_bus) {\n\t\t\t\t\thas_aux = true;\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t\t} else {\n\t\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_edp_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dp_helper_funcs);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\t\tamdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!amdgpu_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tamdgpu_connector->con_priv = amdgpu_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tamdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\n\t\t\t\tif (!amdgpu_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &amdgpu_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &amdgpu_connector->base,\n\t\t\t\t\t\t    &amdgpu_connector_lvds_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_lvds_helper_funcs);\n\t\t\tdrm_object_attach_property(&amdgpu_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (amdgpu_connector->hpd.hpd == AMDGPU_HPD_NONE) {\n\t\tif (i2c_bus->valid) {\n\t\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\t\t}\n\t} else\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tconnector->display_info.subpixel_order = subpixel_order;\n\n\tif (has_aux)\n\t\tamdgpu_atombios_dp_aux_init(amdgpu_connector);\n\n\tif (connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\tdrm_connector_attach_dp_subconnector_property(&amdgpu_connector->base);\n\t}\n\n\treturn;\n\nfailed:\n\tdrm_connector_cleanup(connector);\n\tkfree(connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}