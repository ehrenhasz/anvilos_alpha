{
  "module_name": "amdgpu_i2c.c",
  "hash_id": "cbc438c683dc0c6f835cc2802ced39eb7e38fa540805f9fb24135ff308da89c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_i2c.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#include <drm/drm_edid.h>\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_i2c.h\"\n#include \"amdgpu_atombios.h\"\n#include \"atom.h\"\n#include \"atombios_dp.h\"\n#include \"atombios_i2c.h\"\n\n \nstatic int amdgpu_i2c_pre_xfer(struct i2c_adapter *i2c_adap)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t temp;\n\n\tmutex_lock(&i2c->mutex);\n\n\t \n\tif (rec->hw_capable) {\n\t\ttemp = RREG32(rec->mask_clk_reg);\n\t\ttemp &= ~(1 << 16);\n\t\tWREG32(rec->mask_clk_reg, temp);\n\t}\n\n\t \n\ttemp = RREG32(rec->a_clk_reg) & ~rec->a_clk_mask;\n\tWREG32(rec->a_clk_reg, temp);\n\n\ttemp = RREG32(rec->a_data_reg) & ~rec->a_data_mask;\n\tWREG32(rec->a_data_reg, temp);\n\n\t \n\ttemp = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\n\tWREG32(rec->en_clk_reg, temp);\n\n\ttemp = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\n\tWREG32(rec->en_data_reg, temp);\n\n\t \n\ttemp = RREG32(rec->mask_clk_reg) | rec->mask_clk_mask;\n\tWREG32(rec->mask_clk_reg, temp);\n\ttemp = RREG32(rec->mask_clk_reg);\n\n\ttemp = RREG32(rec->mask_data_reg) | rec->mask_data_mask;\n\tWREG32(rec->mask_data_reg, temp);\n\ttemp = RREG32(rec->mask_data_reg);\n\n\treturn 0;\n}\n\nstatic void amdgpu_i2c_post_xfer(struct i2c_adapter *i2c_adap)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t temp;\n\n\t \n\ttemp = RREG32(rec->mask_clk_reg) & ~rec->mask_clk_mask;\n\tWREG32(rec->mask_clk_reg, temp);\n\ttemp = RREG32(rec->mask_clk_reg);\n\n\ttemp = RREG32(rec->mask_data_reg) & ~rec->mask_data_mask;\n\tWREG32(rec->mask_data_reg, temp);\n\ttemp = RREG32(rec->mask_data_reg);\n\n\tmutex_unlock(&i2c->mutex);\n}\n\nstatic int amdgpu_i2c_get_clock(void *i2c_priv)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_priv;\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->y_clk_reg);\n\tval &= rec->y_clk_mask;\n\n\treturn (val != 0);\n}\n\n\nstatic int amdgpu_i2c_get_data(void *i2c_priv)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_priv;\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->y_data_reg);\n\tval &= rec->y_data_mask;\n\n\treturn (val != 0);\n}\n\nstatic void amdgpu_i2c_set_clock(void *i2c_priv, int clock)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_priv;\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\n\tval |= clock ? 0 : rec->en_clk_mask;\n\tWREG32(rec->en_clk_reg, val);\n}\n\nstatic void amdgpu_i2c_set_data(void *i2c_priv, int data)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_priv;\n\tstruct amdgpu_device *adev = drm_to_adev(i2c->dev);\n\tstruct amdgpu_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\n\tval |= data ? 0 : rec->en_data_mask;\n\tWREG32(rec->en_data_reg, val);\n}\n\nstatic const struct i2c_algorithm amdgpu_atombios_i2c_algo = {\n\t.master_xfer = amdgpu_atombios_i2c_xfer,\n\t.functionality = amdgpu_atombios_i2c_func,\n};\n\nstruct amdgpu_i2c_chan *amdgpu_i2c_create(struct drm_device *dev,\n\t\t\t\t\t  const struct amdgpu_i2c_bus_rec *rec,\n\t\t\t\t\t  const char *name)\n{\n\tstruct amdgpu_i2c_chan *i2c;\n\tint ret;\n\n\t \n\tif (rec->mm_i2c && (amdgpu_hw_i2c == 0))\n\t\treturn NULL;\n\n\ti2c = kzalloc(sizeof(struct amdgpu_i2c_chan), GFP_KERNEL);\n\tif (i2c == NULL)\n\t\treturn NULL;\n\n\ti2c->rec = *rec;\n\ti2c->adapter.owner = THIS_MODULE;\n\ti2c->adapter.class = I2C_CLASS_DDC;\n\ti2c->adapter.dev.parent = dev->dev;\n\ti2c->dev = dev;\n\ti2c_set_adapdata(&i2c->adapter, i2c);\n\tmutex_init(&i2c->mutex);\n\tif (rec->hw_capable &&\n\t    amdgpu_hw_i2c) {\n\t\t \n\t\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t\t \"AMDGPU i2c hw bus %s\", name);\n\t\ti2c->adapter.algo = &amdgpu_atombios_i2c_algo;\n\t\tret = i2c_add_adapter(&i2c->adapter);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t} else {\n\t\t \n\t\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t\t \"AMDGPU i2c bit bus %s\", name);\n\t\ti2c->adapter.algo_data = &i2c->bit;\n\t\ti2c->bit.pre_xfer = amdgpu_i2c_pre_xfer;\n\t\ti2c->bit.post_xfer = amdgpu_i2c_post_xfer;\n\t\ti2c->bit.setsda = amdgpu_i2c_set_data;\n\t\ti2c->bit.setscl = amdgpu_i2c_set_clock;\n\t\ti2c->bit.getsda = amdgpu_i2c_get_data;\n\t\ti2c->bit.getscl = amdgpu_i2c_get_clock;\n\t\ti2c->bit.udelay = 10;\n\t\ti2c->bit.timeout = usecs_to_jiffies(2200);\t \n\t\ti2c->bit.data = i2c;\n\t\tret = i2c_bit_add_bus(&i2c->adapter);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to register bit i2c %s\\n\", name);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn i2c;\nout_free:\n\tkfree(i2c);\n\treturn NULL;\n\n}\n\nvoid amdgpu_i2c_destroy(struct amdgpu_i2c_chan *i2c)\n{\n\tif (!i2c)\n\t\treturn;\n\tWARN_ON(i2c->has_aux);\n\ti2c_del_adapter(&i2c->adapter);\n\tkfree(i2c);\n}\n\n \nvoid amdgpu_i2c_init(struct amdgpu_device *adev)\n{\n\tif (amdgpu_hw_i2c)\n\t\tDRM_INFO(\"hw_i2c forced on, you may experience display detection problems!\\n\");\n\n\tamdgpu_atombios_i2c_init(adev);\n}\n\n \nvoid amdgpu_i2c_fini(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < AMDGPU_MAX_I2C_BUS; i++) {\n\t\tif (adev->i2c_bus[i]) {\n\t\t\tamdgpu_i2c_destroy(adev->i2c_bus[i]);\n\t\t\tadev->i2c_bus[i] = NULL;\n\t\t}\n\t}\n}\n\n \nvoid amdgpu_i2c_add(struct amdgpu_device *adev,\n\t\t    const struct amdgpu_i2c_bus_rec *rec,\n\t\t    const char *name)\n{\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tint i;\n\n\tfor (i = 0; i < AMDGPU_MAX_I2C_BUS; i++) {\n\t\tif (!adev->i2c_bus[i]) {\n\t\t\tadev->i2c_bus[i] = amdgpu_i2c_create(dev, rec, name);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstruct amdgpu_i2c_chan *\namdgpu_i2c_lookup(struct amdgpu_device *adev,\n\t\t  const struct amdgpu_i2c_bus_rec *i2c_bus)\n{\n\tint i;\n\n\tfor (i = 0; i < AMDGPU_MAX_I2C_BUS; i++) {\n\t\tif (adev->i2c_bus[i] &&\n\t\t    (adev->i2c_bus[i]->rec.i2c_id == i2c_bus->i2c_id)) {\n\t\t\treturn adev->i2c_bus[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void amdgpu_i2c_get_byte(struct amdgpu_i2c_chan *i2c_bus,\n\t\t\t\t u8 slave_addr,\n\t\t\t\t u8 addr,\n\t\t\t\t u8 *val)\n{\n\tu8 out_buf[2];\n\tu8 in_buf[2];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = out_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = in_buf,\n\t\t}\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = 0;\n\n\tif (i2c_transfer(&i2c_bus->adapter, msgs, 2) == 2) {\n\t\t*val = in_buf[0];\n\t\tDRM_DEBUG(\"val = 0x%02x\\n\", *val);\n\t} else {\n\t\tDRM_DEBUG(\"i2c 0x%02x 0x%02x read failed\\n\",\n\t\t\t  addr, *val);\n\t}\n}\n\nstatic void amdgpu_i2c_put_byte(struct amdgpu_i2c_chan *i2c_bus,\n\t\t\t\t u8 slave_addr,\n\t\t\t\t u8 addr,\n\t\t\t\t u8 val)\n{\n\tuint8_t out_buf[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = slave_addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = val;\n\n\tif (i2c_transfer(&i2c_bus->adapter, &msg, 1) != 1)\n\t\tDRM_DEBUG(\"i2c 0x%02x 0x%02x write failed\\n\",\n\t\t\t  addr, val);\n}\n\n \nvoid\namdgpu_i2c_router_select_ddc_port(const struct amdgpu_connector *amdgpu_connector)\n{\n\tu8 val = 0;\n\n\tif (!amdgpu_connector->router.ddc_valid)\n\t\treturn;\n\n\tif (!amdgpu_connector->router_bus)\n\t\treturn;\n\n\tamdgpu_i2c_get_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x3, &val);\n\tval &= ~amdgpu_connector->router.ddc_mux_control_pin;\n\tamdgpu_i2c_put_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x3, val);\n\tamdgpu_i2c_get_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x1, &val);\n\tval &= ~amdgpu_connector->router.ddc_mux_control_pin;\n\tval |= amdgpu_connector->router.ddc_mux_state;\n\tamdgpu_i2c_put_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x1, val);\n}\n\n \nvoid\namdgpu_i2c_router_select_cd_port(const struct amdgpu_connector *amdgpu_connector)\n{\n\tu8 val;\n\n\tif (!amdgpu_connector->router.cd_valid)\n\t\treturn;\n\n\tif (!amdgpu_connector->router_bus)\n\t\treturn;\n\n\tamdgpu_i2c_get_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x3, &val);\n\tval &= ~amdgpu_connector->router.cd_mux_control_pin;\n\tamdgpu_i2c_put_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x3, val);\n\tamdgpu_i2c_get_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x1, &val);\n\tval &= ~amdgpu_connector->router.cd_mux_control_pin;\n\tval |= amdgpu_connector->router.cd_mux_state;\n\tamdgpu_i2c_put_byte(amdgpu_connector->router_bus,\n\t\t\t    amdgpu_connector->router.i2c_addr,\n\t\t\t    0x1, val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}