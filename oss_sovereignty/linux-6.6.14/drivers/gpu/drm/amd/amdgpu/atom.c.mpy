{
  "module_name": "atom.c",
  "hash_id": "3712d9c1876b40d3ea9a43cc9a7125e54417123ff3aa037fc4d43bc97ff8a18a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/atom.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <asm/unaligned.h>\n\n#include <drm/drm_util.h>\n\n#define ATOM_DEBUG\n\n#include \"atomfirmware.h\"\n#include \"atom.h\"\n#include \"atom-names.h\"\n#include \"atom-bits.h\"\n#include \"amdgpu.h\"\n\n#define ATOM_COND_ABOVE\t\t0\n#define ATOM_COND_ABOVEOREQUAL\t1\n#define ATOM_COND_ALWAYS\t2\n#define ATOM_COND_BELOW\t\t3\n#define ATOM_COND_BELOWOREQUAL\t4\n#define ATOM_COND_EQUAL\t\t5\n#define ATOM_COND_NOTEQUAL\t6\n\n#define ATOM_PORT_ATI\t0\n#define ATOM_PORT_PCI\t1\n#define ATOM_PORT_SYSIO\t2\n\n#define ATOM_UNIT_MICROSEC\t0\n#define ATOM_UNIT_MILLISEC\t1\n\n#define PLL_INDEX\t2\n#define PLL_DATA\t3\n\n#define ATOM_CMD_TIMEOUT_SEC\t20\n\ntypedef struct {\n\tstruct atom_context *ctx;\n\tuint32_t *ps, *ws;\n\tint ps_shift;\n\tuint16_t start;\n\tunsigned last_jump;\n\tunsigned long last_jump_jiffies;\n\tbool abort;\n} atom_exec_context;\n\nint amdgpu_atom_debug;\nstatic int amdgpu_atom_execute_table_locked(struct atom_context *ctx, int index, uint32_t *params);\nint amdgpu_atom_execute_table(struct atom_context *ctx, int index, uint32_t *params);\n\nstatic uint32_t atom_arg_mask[8] =\n\t{ 0xFFFFFFFF, 0xFFFF, 0xFFFF00, 0xFFFF0000, 0xFF, 0xFF00, 0xFF0000,\n\t  0xFF000000 };\nstatic int atom_arg_shift[8] = { 0, 0, 8, 16, 0, 8, 16, 24 };\n\nstatic int atom_dst_to_src[8][4] = {\n\t \n\t{0, 0, 0, 0},\n\t{1, 2, 3, 0},\n\t{1, 2, 3, 0},\n\t{1, 2, 3, 0},\n\t{4, 5, 6, 7},\n\t{4, 5, 6, 7},\n\t{4, 5, 6, 7},\n\t{4, 5, 6, 7},\n};\nstatic int atom_def_dst[8] = { 0, 0, 1, 2, 0, 1, 2, 3 };\n\nstatic int debug_depth;\n#ifdef ATOM_DEBUG\nstatic void debug_print_spaces(int n)\n{\n\twhile (n--)\n\t\tprintk(\"   \");\n}\n\n#define DEBUG(...) do if (amdgpu_atom_debug) { printk(KERN_DEBUG __VA_ARGS__); } while (0)\n#define SDEBUG(...) do if (amdgpu_atom_debug) { printk(KERN_DEBUG); debug_print_spaces(debug_depth); printk(__VA_ARGS__); } while (0)\n#else\n#define DEBUG(...) do { } while (0)\n#define SDEBUG(...) do { } while (0)\n#endif\n\nstatic uint32_t atom_iio_execute(struct atom_context *ctx, int base,\n\t\t\t\t uint32_t index, uint32_t data)\n{\n\tuint32_t temp = 0xCDCDCDCD;\n\n\twhile (1)\n\t\tswitch (CU8(base)) {\n\t\tcase ATOM_IIO_NOP:\n\t\t\tbase++;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_READ:\n\t\t\ttemp = ctx->card->reg_read(ctx->card, CU16(base + 1));\n\t\t\tbase += 3;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_WRITE:\n\t\t\tctx->card->reg_write(ctx->card, CU16(base + 1), temp);\n\t\t\tbase += 3;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_CLEAR:\n\t\t\ttemp &=\n\t\t\t    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\n\t\t\t      CU8(base + 2));\n\t\t\tbase += 3;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_SET:\n\t\t\ttemp |=\n\t\t\t    (0xFFFFFFFF >> (32 - CU8(base + 1))) << CU8(base +\n\t\t\t\t\t\t\t\t\t2);\n\t\t\tbase += 3;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_MOVE_INDEX:\n\t\t\ttemp &=\n\t\t\t    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\n\t\t\t      CU8(base + 3));\n\t\t\ttemp |=\n\t\t\t    ((index >> CU8(base + 2)) &\n\t\t\t     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +\n\t\t\t\t\t\t\t\t\t  3);\n\t\t\tbase += 4;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_MOVE_DATA:\n\t\t\ttemp &=\n\t\t\t    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\n\t\t\t      CU8(base + 3));\n\t\t\ttemp |=\n\t\t\t    ((data >> CU8(base + 2)) &\n\t\t\t     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +\n\t\t\t\t\t\t\t\t\t  3);\n\t\t\tbase += 4;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_MOVE_ATTR:\n\t\t\ttemp &=\n\t\t\t    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\n\t\t\t      CU8(base + 3));\n\t\t\ttemp |=\n\t\t\t    ((ctx->\n\t\t\t      io_attr >> CU8(base + 2)) & (0xFFFFFFFF >> (32 -\n\t\t\t\t\t\t\t\t\t  CU8\n\t\t\t\t\t\t\t\t\t  (base\n\t\t\t\t\t\t\t\t\t   +\n\t\t\t\t\t\t\t\t\t   1))))\n\t\t\t    << CU8(base + 3);\n\t\t\tbase += 4;\n\t\t\tbreak;\n\t\tcase ATOM_IIO_END:\n\t\t\treturn temp;\n\t\tdefault:\n\t\t\tpr_info(\"Unknown IIO opcode\\n\");\n\t\t\treturn 0;\n\t\t}\n}\n\nstatic uint32_t atom_get_src_int(atom_exec_context *ctx, uint8_t attr,\n\t\t\t\t int *ptr, uint32_t *saved, int print)\n{\n\tuint32_t idx, val = 0xCDCDCDCD, align, arg;\n\tstruct atom_context *gctx = ctx->ctx;\n\targ = attr & 7;\n\talign = (attr >> 3) & 7;\n\tswitch (arg) {\n\tcase ATOM_ARG_REG:\n\t\tidx = U16(*ptr);\n\t\t(*ptr) += 2;\n\t\tif (print)\n\t\t\tDEBUG(\"REG[0x%04X]\", idx);\n\t\tidx += gctx->reg_block;\n\t\tswitch (gctx->io_mode) {\n\t\tcase ATOM_IO_MM:\n\t\t\tval = gctx->card->reg_read(gctx->card, idx);\n\t\t\tbreak;\n\t\tcase ATOM_IO_PCI:\n\t\t\tpr_info(\"PCI registers are not implemented\\n\");\n\t\t\treturn 0;\n\t\tcase ATOM_IO_SYSIO:\n\t\t\tpr_info(\"SYSIO registers are not implemented\\n\");\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tif (!(gctx->io_mode & 0x80)) {\n\t\t\t\tpr_info(\"Bad IO mode\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!gctx->iio[gctx->io_mode & 0x7F]) {\n\t\t\t\tpr_info(\"Undefined indirect IO read method %d\\n\",\n\t\t\t\t\tgctx->io_mode & 0x7F);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tval =\n\t\t\t    atom_iio_execute(gctx,\n\t\t\t\t\t     gctx->iio[gctx->io_mode & 0x7F],\n\t\t\t\t\t     idx, 0);\n\t\t}\n\t\tbreak;\n\tcase ATOM_ARG_PS:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\t \n\t\tval = get_unaligned_le32((u32 *)&ctx->ps[idx]);\n\t\tif (print)\n\t\t\tDEBUG(\"PS[0x%02X,0x%04X]\", idx, val);\n\t\tbreak;\n\tcase ATOM_ARG_WS:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tif (print)\n\t\t\tDEBUG(\"WS[0x%02X]\", idx);\n\t\tswitch (idx) {\n\t\tcase ATOM_WS_QUOTIENT:\n\t\t\tval = gctx->divmul[0];\n\t\t\tbreak;\n\t\tcase ATOM_WS_REMAINDER:\n\t\t\tval = gctx->divmul[1];\n\t\t\tbreak;\n\t\tcase ATOM_WS_DATAPTR:\n\t\t\tval = gctx->data_block;\n\t\t\tbreak;\n\t\tcase ATOM_WS_SHIFT:\n\t\t\tval = gctx->shift;\n\t\t\tbreak;\n\t\tcase ATOM_WS_OR_MASK:\n\t\t\tval = 1 << gctx->shift;\n\t\t\tbreak;\n\t\tcase ATOM_WS_AND_MASK:\n\t\t\tval = ~(1 << gctx->shift);\n\t\t\tbreak;\n\t\tcase ATOM_WS_FB_WINDOW:\n\t\t\tval = gctx->fb_base;\n\t\t\tbreak;\n\t\tcase ATOM_WS_ATTRIBUTES:\n\t\t\tval = gctx->io_attr;\n\t\t\tbreak;\n\t\tcase ATOM_WS_REGPTR:\n\t\t\tval = gctx->reg_block;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = ctx->ws[idx];\n\t\t}\n\t\tbreak;\n\tcase ATOM_ARG_ID:\n\t\tidx = U16(*ptr);\n\t\t(*ptr) += 2;\n\t\tif (print) {\n\t\t\tif (gctx->data_block)\n\t\t\t\tDEBUG(\"ID[0x%04X+%04X]\", idx, gctx->data_block);\n\t\t\telse\n\t\t\t\tDEBUG(\"ID[0x%04X]\", idx);\n\t\t}\n\t\tval = U32(idx + gctx->data_block);\n\t\tbreak;\n\tcase ATOM_ARG_FB:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tif ((gctx->fb_base + (idx * 4)) > gctx->scratch_size_bytes) {\n\t\t\tDRM_ERROR(\"ATOM: fb read beyond scratch region: %d vs. %d\\n\",\n\t\t\t\t  gctx->fb_base + (idx * 4), gctx->scratch_size_bytes);\n\t\t\tval = 0;\n\t\t} else\n\t\t\tval = gctx->scratch[(gctx->fb_base / 4) + idx];\n\t\tif (print)\n\t\t\tDEBUG(\"FB[0x%02X]\", idx);\n\t\tbreak;\n\tcase ATOM_ARG_IMM:\n\t\tswitch (align) {\n\t\tcase ATOM_SRC_DWORD:\n\t\t\tval = U32(*ptr);\n\t\t\t(*ptr) += 4;\n\t\t\tif (print)\n\t\t\t\tDEBUG(\"IMM 0x%08X\\n\", val);\n\t\t\treturn val;\n\t\tcase ATOM_SRC_WORD0:\n\t\tcase ATOM_SRC_WORD8:\n\t\tcase ATOM_SRC_WORD16:\n\t\t\tval = U16(*ptr);\n\t\t\t(*ptr) += 2;\n\t\t\tif (print)\n\t\t\t\tDEBUG(\"IMM 0x%04X\\n\", val);\n\t\t\treturn val;\n\t\tcase ATOM_SRC_BYTE0:\n\t\tcase ATOM_SRC_BYTE8:\n\t\tcase ATOM_SRC_BYTE16:\n\t\tcase ATOM_SRC_BYTE24:\n\t\t\tval = U8(*ptr);\n\t\t\t(*ptr)++;\n\t\t\tif (print)\n\t\t\t\tDEBUG(\"IMM 0x%02X\\n\", val);\n\t\t\treturn val;\n\t\t}\n\t\treturn 0;\n\tcase ATOM_ARG_PLL:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tif (print)\n\t\t\tDEBUG(\"PLL[0x%02X]\", idx);\n\t\tval = gctx->card->pll_read(gctx->card, idx);\n\t\tbreak;\n\tcase ATOM_ARG_MC:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tif (print)\n\t\t\tDEBUG(\"MC[0x%02X]\", idx);\n\t\tval = gctx->card->mc_read(gctx->card, idx);\n\t\tbreak;\n\t}\n\tif (saved)\n\t\t*saved = val;\n\tval &= atom_arg_mask[align];\n\tval >>= atom_arg_shift[align];\n\tif (print)\n\t\tswitch (align) {\n\t\tcase ATOM_SRC_DWORD:\n\t\t\tDEBUG(\".[31:0] -> 0x%08X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_WORD0:\n\t\t\tDEBUG(\".[15:0] -> 0x%04X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_WORD8:\n\t\t\tDEBUG(\".[23:8] -> 0x%04X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_WORD16:\n\t\t\tDEBUG(\".[31:16] -> 0x%04X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_BYTE0:\n\t\t\tDEBUG(\".[7:0] -> 0x%02X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_BYTE8:\n\t\t\tDEBUG(\".[15:8] -> 0x%02X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_BYTE16:\n\t\t\tDEBUG(\".[23:16] -> 0x%02X\\n\", val);\n\t\t\tbreak;\n\t\tcase ATOM_SRC_BYTE24:\n\t\t\tDEBUG(\".[31:24] -> 0x%02X\\n\", val);\n\t\t\tbreak;\n\t\t}\n\treturn val;\n}\n\nstatic void atom_skip_src_int(atom_exec_context *ctx, uint8_t attr, int *ptr)\n{\n\tuint32_t align = (attr >> 3) & 7, arg = attr & 7;\n\tswitch (arg) {\n\tcase ATOM_ARG_REG:\n\tcase ATOM_ARG_ID:\n\t\t(*ptr) += 2;\n\t\tbreak;\n\tcase ATOM_ARG_PLL:\n\tcase ATOM_ARG_MC:\n\tcase ATOM_ARG_PS:\n\tcase ATOM_ARG_WS:\n\tcase ATOM_ARG_FB:\n\t\t(*ptr)++;\n\t\tbreak;\n\tcase ATOM_ARG_IMM:\n\t\tswitch (align) {\n\t\tcase ATOM_SRC_DWORD:\n\t\t\t(*ptr) += 4;\n\t\t\treturn;\n\t\tcase ATOM_SRC_WORD0:\n\t\tcase ATOM_SRC_WORD8:\n\t\tcase ATOM_SRC_WORD16:\n\t\t\t(*ptr) += 2;\n\t\t\treturn;\n\t\tcase ATOM_SRC_BYTE0:\n\t\tcase ATOM_SRC_BYTE8:\n\t\tcase ATOM_SRC_BYTE16:\n\t\tcase ATOM_SRC_BYTE24:\n\t\t\t(*ptr)++;\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic uint32_t atom_get_src(atom_exec_context *ctx, uint8_t attr, int *ptr)\n{\n\treturn atom_get_src_int(ctx, attr, ptr, NULL, 1);\n}\n\nstatic uint32_t atom_get_src_direct(atom_exec_context *ctx, uint8_t align, int *ptr)\n{\n\tuint32_t val = 0xCDCDCDCD;\n\n\tswitch (align) {\n\tcase ATOM_SRC_DWORD:\n\t\tval = U32(*ptr);\n\t\t(*ptr) += 4;\n\t\tbreak;\n\tcase ATOM_SRC_WORD0:\n\tcase ATOM_SRC_WORD8:\n\tcase ATOM_SRC_WORD16:\n\t\tval = U16(*ptr);\n\t\t(*ptr) += 2;\n\t\tbreak;\n\tcase ATOM_SRC_BYTE0:\n\tcase ATOM_SRC_BYTE8:\n\tcase ATOM_SRC_BYTE16:\n\tcase ATOM_SRC_BYTE24:\n\t\tval = U8(*ptr);\n\t\t(*ptr)++;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\nstatic uint32_t atom_get_dst(atom_exec_context *ctx, int arg, uint8_t attr,\n\t\t\t     int *ptr, uint32_t *saved, int print)\n{\n\treturn atom_get_src_int(ctx,\n\t\t\t\targ | atom_dst_to_src[(attr >> 3) &\n\t\t\t\t\t\t      7][(attr >> 6) & 3] << 3,\n\t\t\t\tptr, saved, print);\n}\n\nstatic void atom_skip_dst(atom_exec_context *ctx, int arg, uint8_t attr, int *ptr)\n{\n\tatom_skip_src_int(ctx,\n\t\t\t  arg | atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) &\n\t\t\t\t\t\t\t\t 3] << 3, ptr);\n}\n\nstatic void atom_put_dst(atom_exec_context *ctx, int arg, uint8_t attr,\n\t\t\t int *ptr, uint32_t val, uint32_t saved)\n{\n\tuint32_t align =\n\t    atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3], old_val =\n\t    val, idx;\n\tstruct atom_context *gctx = ctx->ctx;\n\told_val &= atom_arg_mask[align] >> atom_arg_shift[align];\n\tval <<= atom_arg_shift[align];\n\tval &= atom_arg_mask[align];\n\tsaved &= ~atom_arg_mask[align];\n\tval |= saved;\n\tswitch (arg) {\n\tcase ATOM_ARG_REG:\n\t\tidx = U16(*ptr);\n\t\t(*ptr) += 2;\n\t\tDEBUG(\"REG[0x%04X]\", idx);\n\t\tidx += gctx->reg_block;\n\t\tswitch (gctx->io_mode) {\n\t\tcase ATOM_IO_MM:\n\t\t\tif (idx == 0)\n\t\t\t\tgctx->card->reg_write(gctx->card, idx,\n\t\t\t\t\t\t      val << 2);\n\t\t\telse\n\t\t\t\tgctx->card->reg_write(gctx->card, idx, val);\n\t\t\tbreak;\n\t\tcase ATOM_IO_PCI:\n\t\t\tpr_info(\"PCI registers are not implemented\\n\");\n\t\t\treturn;\n\t\tcase ATOM_IO_SYSIO:\n\t\t\tpr_info(\"SYSIO registers are not implemented\\n\");\n\t\t\treturn;\n\t\tdefault:\n\t\t\tif (!(gctx->io_mode & 0x80)) {\n\t\t\t\tpr_info(\"Bad IO mode\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!gctx->iio[gctx->io_mode & 0xFF]) {\n\t\t\t\tpr_info(\"Undefined indirect IO write method %d\\n\",\n\t\t\t\t\tgctx->io_mode & 0x7F);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tatom_iio_execute(gctx, gctx->iio[gctx->io_mode & 0xFF],\n\t\t\t\t\t idx, val);\n\t\t}\n\t\tbreak;\n\tcase ATOM_ARG_PS:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tDEBUG(\"PS[0x%02X]\", idx);\n\t\tctx->ps[idx] = cpu_to_le32(val);\n\t\tbreak;\n\tcase ATOM_ARG_WS:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tDEBUG(\"WS[0x%02X]\", idx);\n\t\tswitch (idx) {\n\t\tcase ATOM_WS_QUOTIENT:\n\t\t\tgctx->divmul[0] = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_REMAINDER:\n\t\t\tgctx->divmul[1] = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_DATAPTR:\n\t\t\tgctx->data_block = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_SHIFT:\n\t\t\tgctx->shift = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_OR_MASK:\n\t\tcase ATOM_WS_AND_MASK:\n\t\t\tbreak;\n\t\tcase ATOM_WS_FB_WINDOW:\n\t\t\tgctx->fb_base = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_ATTRIBUTES:\n\t\t\tgctx->io_attr = val;\n\t\t\tbreak;\n\t\tcase ATOM_WS_REGPTR:\n\t\t\tgctx->reg_block = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctx->ws[idx] = val;\n\t\t}\n\t\tbreak;\n\tcase ATOM_ARG_FB:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tif ((gctx->fb_base + (idx * 4)) > gctx->scratch_size_bytes) {\n\t\t\tDRM_ERROR(\"ATOM: fb write beyond scratch region: %d vs. %d\\n\",\n\t\t\t\t  gctx->fb_base + (idx * 4), gctx->scratch_size_bytes);\n\t\t} else\n\t\t\tgctx->scratch[(gctx->fb_base / 4) + idx] = val;\n\t\tDEBUG(\"FB[0x%02X]\", idx);\n\t\tbreak;\n\tcase ATOM_ARG_PLL:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tDEBUG(\"PLL[0x%02X]\", idx);\n\t\tgctx->card->pll_write(gctx->card, idx, val);\n\t\tbreak;\n\tcase ATOM_ARG_MC:\n\t\tidx = U8(*ptr);\n\t\t(*ptr)++;\n\t\tDEBUG(\"MC[0x%02X]\", idx);\n\t\tgctx->card->mc_write(gctx->card, idx, val);\n\t\treturn;\n\t}\n\tswitch (align) {\n\tcase ATOM_SRC_DWORD:\n\t\tDEBUG(\".[31:0] <- 0x%08X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_WORD0:\n\t\tDEBUG(\".[15:0] <- 0x%04X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_WORD8:\n\t\tDEBUG(\".[23:8] <- 0x%04X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_WORD16:\n\t\tDEBUG(\".[31:16] <- 0x%04X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_BYTE0:\n\t\tDEBUG(\".[7:0] <- 0x%02X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_BYTE8:\n\t\tDEBUG(\".[15:8] <- 0x%02X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_BYTE16:\n\t\tDEBUG(\".[23:16] <- 0x%02X\\n\", old_val);\n\t\tbreak;\n\tcase ATOM_SRC_BYTE24:\n\t\tDEBUG(\".[31:24] <- 0x%02X\\n\", old_val);\n\t\tbreak;\n\t}\n}\n\nstatic void atom_op_add(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst += src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_and(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst &= src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_beep(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tprintk(\"ATOM BIOS beeped!\\n\");\n}\n\nstatic void atom_op_calltable(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tint idx = U8((*ptr)++);\n\tint r = 0;\n\n\tif (idx < ATOM_TABLE_NAMES_CNT)\n\t\tSDEBUG(\"   table: %d (%s)\\n\", idx, atom_table_names[idx]);\n\telse\n\t\tSDEBUG(\"   table: %d\\n\", idx);\n\tif (U16(ctx->ctx->cmd_table + 4 + 2 * idx))\n\t\tr = amdgpu_atom_execute_table_locked(ctx->ctx, idx, ctx->ps + ctx->ps_shift);\n\tif (r) {\n\t\tctx->abort = true;\n\t}\n}\n\nstatic void atom_op_clear(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t saved;\n\tint dptr = *ptr;\n\tattr &= 0x38;\n\tattr |= atom_def_dst[attr >> 3] << 6;\n\tatom_get_dst(ctx, arg, attr, ptr, &saved, 0);\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, 0, saved);\n}\n\nstatic void atom_op_compare(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tctx->ctx->cs_equal = (dst == src);\n\tctx->ctx->cs_above = (dst > src);\n\tSDEBUG(\"   result: %s %s\\n\", ctx->ctx->cs_equal ? \"EQ\" : \"NE\",\n\t       ctx->ctx->cs_above ? \"GT\" : \"LE\");\n}\n\nstatic void atom_op_delay(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tunsigned count = U8((*ptr)++);\n\tSDEBUG(\"   count: %d\\n\", count);\n\tif (arg == ATOM_UNIT_MICROSEC)\n\t\tudelay(count);\n\telse if (!drm_can_sleep())\n\t\tmdelay(count);\n\telse\n\t\tmsleep(count);\n}\n\nstatic void atom_op_div(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tif (src != 0) {\n\t\tctx->ctx->divmul[0] = dst / src;\n\t\tctx->ctx->divmul[1] = dst % src;\n\t} else {\n\t\tctx->ctx->divmul[0] = 0;\n\t\tctx->ctx->divmul[1] = 0;\n\t}\n}\n\nstatic void atom_op_div32(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint64_t val64;\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tif (src != 0) {\n\t\tval64 = dst;\n\t\tval64 |= ((uint64_t)ctx->ctx->divmul[1]) << 32;\n\t\tdo_div(val64, src);\n\t\tctx->ctx->divmul[0] = lower_32_bits(val64);\n\t\tctx->ctx->divmul[1] = upper_32_bits(val64);\n\t} else {\n\t\tctx->ctx->divmul[0] = 0;\n\t\tctx->ctx->divmul[1] = 0;\n\t}\n}\n\nstatic void atom_op_eot(atom_exec_context *ctx, int *ptr, int arg)\n{\n\t \n}\n\nstatic void atom_op_jump(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tint execute = 0, target = U16(*ptr);\n\tunsigned long cjiffies;\n\n\t(*ptr) += 2;\n\tswitch (arg) {\n\tcase ATOM_COND_ABOVE:\n\t\texecute = ctx->ctx->cs_above;\n\t\tbreak;\n\tcase ATOM_COND_ABOVEOREQUAL:\n\t\texecute = ctx->ctx->cs_above || ctx->ctx->cs_equal;\n\t\tbreak;\n\tcase ATOM_COND_ALWAYS:\n\t\texecute = 1;\n\t\tbreak;\n\tcase ATOM_COND_BELOW:\n\t\texecute = !(ctx->ctx->cs_above || ctx->ctx->cs_equal);\n\t\tbreak;\n\tcase ATOM_COND_BELOWOREQUAL:\n\t\texecute = !ctx->ctx->cs_above;\n\t\tbreak;\n\tcase ATOM_COND_EQUAL:\n\t\texecute = ctx->ctx->cs_equal;\n\t\tbreak;\n\tcase ATOM_COND_NOTEQUAL:\n\t\texecute = !ctx->ctx->cs_equal;\n\t\tbreak;\n\t}\n\tif (arg != ATOM_COND_ALWAYS)\n\t\tSDEBUG(\"   taken: %s\\n\", str_yes_no(execute));\n\tSDEBUG(\"   target: 0x%04X\\n\", target);\n\tif (execute) {\n\t\tif (ctx->last_jump == (ctx->start + target)) {\n\t\t\tcjiffies = jiffies;\n\t\t\tif (time_after(cjiffies, ctx->last_jump_jiffies)) {\n\t\t\t\tcjiffies -= ctx->last_jump_jiffies;\n\t\t\t\tif ((jiffies_to_msecs(cjiffies) > ATOM_CMD_TIMEOUT_SEC*1000)) {\n\t\t\t\t\tDRM_ERROR(\"atombios stuck in loop for more than %dsecs aborting\\n\",\n\t\t\t\t\t\t  ATOM_CMD_TIMEOUT_SEC);\n\t\t\t\t\tctx->abort = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctx->last_jump_jiffies = jiffies;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->last_jump = ctx->start + target;\n\t\t\tctx->last_jump_jiffies = jiffies;\n\t\t}\n\t\t*ptr = ctx->start + target;\n\t}\n}\n\nstatic void atom_op_mask(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, mask, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tmask = atom_get_src_direct(ctx, ((attr >> 3) & 7), ptr);\n\tSDEBUG(\"   mask: 0x%08x\", mask);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst &= mask;\n\tdst |= src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_move(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t src, saved;\n\tint dptr = *ptr;\n\tif (((attr >> 3) & 7) != ATOM_SRC_DWORD)\n\t\tatom_get_dst(ctx, arg, attr, ptr, &saved, 0);\n\telse {\n\t\tatom_skip_dst(ctx, arg, attr, ptr);\n\t\tsaved = 0xCDCDCDCD;\n\t}\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, src, saved);\n}\n\nstatic void atom_op_mul(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tctx->ctx->divmul[0] = dst * src;\n}\n\nstatic void atom_op_mul32(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint64_t val64;\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tval64 = (uint64_t)dst * (uint64_t)src;\n\tctx->ctx->divmul[0] = lower_32_bits(val64);\n\tctx->ctx->divmul[1] = upper_32_bits(val64);\n}\n\nstatic void atom_op_nop(atom_exec_context *ctx, int *ptr, int arg)\n{\n\t \n}\n\nstatic void atom_op_or(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst |= src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_postcard(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t val = U8((*ptr)++);\n\tSDEBUG(\"POST card output: 0x%02X\\n\", val);\n}\n\nstatic void atom_op_repeat(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tpr_info(\"unimplemented!\\n\");\n}\n\nstatic void atom_op_restorereg(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tpr_info(\"unimplemented!\\n\");\n}\n\nstatic void atom_op_savereg(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tpr_info(\"unimplemented!\\n\");\n}\n\nstatic void atom_op_setdatablock(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tint idx = U8(*ptr);\n\t(*ptr)++;\n\tSDEBUG(\"   block: %d\\n\", idx);\n\tif (!idx)\n\t\tctx->ctx->data_block = 0;\n\telse if (idx == 255)\n\t\tctx->ctx->data_block = ctx->start;\n\telse\n\t\tctx->ctx->data_block = U16(ctx->ctx->data_table + 4 + 2 * idx);\n\tSDEBUG(\"   base: 0x%04X\\n\", ctx->ctx->data_block);\n}\n\nstatic void atom_op_setfbbase(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tSDEBUG(\"   fb_base: \");\n\tctx->ctx->fb_base = atom_get_src(ctx, attr, ptr);\n}\n\nstatic void atom_op_setport(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tint port;\n\tswitch (arg) {\n\tcase ATOM_PORT_ATI:\n\t\tport = U16(*ptr);\n\t\tif (port < ATOM_IO_NAMES_CNT)\n\t\t\tSDEBUG(\"   port: %d (%s)\\n\", port, atom_io_names[port]);\n\t\telse\n\t\t\tSDEBUG(\"   port: %d\\n\", port);\n\t\tif (!port)\n\t\t\tctx->ctx->io_mode = ATOM_IO_MM;\n\t\telse\n\t\t\tctx->ctx->io_mode = ATOM_IO_IIO | port;\n\t\t(*ptr) += 2;\n\t\tbreak;\n\tcase ATOM_PORT_PCI:\n\t\tctx->ctx->io_mode = ATOM_IO_PCI;\n\t\t(*ptr)++;\n\t\tbreak;\n\tcase ATOM_PORT_SYSIO:\n\t\tctx->ctx->io_mode = ATOM_IO_SYSIO;\n\t\t(*ptr)++;\n\t\tbreak;\n\t}\n}\n\nstatic void atom_op_setregblock(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tctx->ctx->reg_block = U16(*ptr);\n\t(*ptr) += 2;\n\tSDEBUG(\"   base: 0x%04X\\n\", ctx->ctx->reg_block);\n}\n\nstatic void atom_op_shift_left(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++), shift;\n\tuint32_t saved, dst;\n\tint dptr = *ptr;\n\tattr &= 0x38;\n\tattr |= atom_def_dst[attr >> 3] << 6;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tshift = atom_get_src_direct(ctx, ATOM_SRC_BYTE0, ptr);\n\tSDEBUG(\"   shift: %d\\n\", shift);\n\tdst <<= shift;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_shift_right(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++), shift;\n\tuint32_t saved, dst;\n\tint dptr = *ptr;\n\tattr &= 0x38;\n\tattr |= atom_def_dst[attr >> 3] << 6;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tshift = atom_get_src_direct(ctx, ATOM_SRC_BYTE0, ptr);\n\tSDEBUG(\"   shift: %d\\n\", shift);\n\tdst >>= shift;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_shl(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++), shift;\n\tuint32_t saved, dst;\n\tint dptr = *ptr;\n\tuint32_t dst_align = atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3];\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\t \n\tdst = saved;\n\tshift = atom_get_src(ctx, attr, ptr);\n\tSDEBUG(\"   shift: %d\\n\", shift);\n\tdst <<= shift;\n\tdst &= atom_arg_mask[dst_align];\n\tdst >>= atom_arg_shift[dst_align];\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_shr(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++), shift;\n\tuint32_t saved, dst;\n\tint dptr = *ptr;\n\tuint32_t dst_align = atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3];\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\t \n\tdst = saved;\n\tshift = atom_get_src(ctx, attr, ptr);\n\tSDEBUG(\"   shift: %d\\n\", shift);\n\tdst >>= shift;\n\tdst &= atom_arg_mask[dst_align];\n\tdst >>= atom_arg_shift[dst_align];\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_sub(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst -= src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_switch(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t src, val, target;\n\tSDEBUG(\"   switch: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\twhile (U16(*ptr) != ATOM_CASE_END)\n\t\tif (U8(*ptr) == ATOM_CASE_MAGIC) {\n\t\t\t(*ptr)++;\n\t\t\tSDEBUG(\"   case: \");\n\t\t\tval =\n\t\t\t    atom_get_src(ctx, (attr & 0x38) | ATOM_ARG_IMM,\n\t\t\t\t\t ptr);\n\t\t\ttarget = U16(*ptr);\n\t\t\tif (val == src) {\n\t\t\t\tSDEBUG(\"   target: %04X\\n\", target);\n\t\t\t\t*ptr = ctx->start + target;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(*ptr) += 2;\n\t\t} else {\n\t\t\tpr_info(\"Bad case\\n\");\n\t\t\treturn;\n\t\t}\n\t(*ptr) += 2;\n}\n\nstatic void atom_op_test(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src;\n\tSDEBUG(\"   src1: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\n\tSDEBUG(\"   src2: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tctx->ctx->cs_equal = ((dst & src) == 0);\n\tSDEBUG(\"   result: %s\\n\", ctx->ctx->cs_equal ? \"EQ\" : \"NE\");\n}\n\nstatic void atom_op_xor(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t attr = U8((*ptr)++);\n\tuint32_t dst, src, saved;\n\tint dptr = *ptr;\n\tSDEBUG(\"   dst: \");\n\tdst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\n\tSDEBUG(\"   src: \");\n\tsrc = atom_get_src(ctx, attr, ptr);\n\tdst ^= src;\n\tSDEBUG(\"   dst: \");\n\tatom_put_dst(ctx, arg, attr, &dptr, dst, saved);\n}\n\nstatic void atom_op_debug(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint8_t val = U8((*ptr)++);\n\tSDEBUG(\"DEBUG output: 0x%02X\\n\", val);\n}\n\nstatic void atom_op_processds(atom_exec_context *ctx, int *ptr, int arg)\n{\n\tuint16_t val = U16(*ptr);\n\t(*ptr) += val + 2;\n\tSDEBUG(\"PROCESSDS output: 0x%02X\\n\", val);\n}\n\nstatic struct {\n\tvoid (*func) (atom_exec_context *, int *, int);\n\tint arg;\n} opcode_table[ATOM_OP_CNT] = {\n\t{\n\tNULL, 0}, {\n\tatom_op_move, ATOM_ARG_REG}, {\n\tatom_op_move, ATOM_ARG_PS}, {\n\tatom_op_move, ATOM_ARG_WS}, {\n\tatom_op_move, ATOM_ARG_FB}, {\n\tatom_op_move, ATOM_ARG_PLL}, {\n\tatom_op_move, ATOM_ARG_MC}, {\n\tatom_op_and, ATOM_ARG_REG}, {\n\tatom_op_and, ATOM_ARG_PS}, {\n\tatom_op_and, ATOM_ARG_WS}, {\n\tatom_op_and, ATOM_ARG_FB}, {\n\tatom_op_and, ATOM_ARG_PLL}, {\n\tatom_op_and, ATOM_ARG_MC}, {\n\tatom_op_or, ATOM_ARG_REG}, {\n\tatom_op_or, ATOM_ARG_PS}, {\n\tatom_op_or, ATOM_ARG_WS}, {\n\tatom_op_or, ATOM_ARG_FB}, {\n\tatom_op_or, ATOM_ARG_PLL}, {\n\tatom_op_or, ATOM_ARG_MC}, {\n\tatom_op_shift_left, ATOM_ARG_REG}, {\n\tatom_op_shift_left, ATOM_ARG_PS}, {\n\tatom_op_shift_left, ATOM_ARG_WS}, {\n\tatom_op_shift_left, ATOM_ARG_FB}, {\n\tatom_op_shift_left, ATOM_ARG_PLL}, {\n\tatom_op_shift_left, ATOM_ARG_MC}, {\n\tatom_op_shift_right, ATOM_ARG_REG}, {\n\tatom_op_shift_right, ATOM_ARG_PS}, {\n\tatom_op_shift_right, ATOM_ARG_WS}, {\n\tatom_op_shift_right, ATOM_ARG_FB}, {\n\tatom_op_shift_right, ATOM_ARG_PLL}, {\n\tatom_op_shift_right, ATOM_ARG_MC}, {\n\tatom_op_mul, ATOM_ARG_REG}, {\n\tatom_op_mul, ATOM_ARG_PS}, {\n\tatom_op_mul, ATOM_ARG_WS}, {\n\tatom_op_mul, ATOM_ARG_FB}, {\n\tatom_op_mul, ATOM_ARG_PLL}, {\n\tatom_op_mul, ATOM_ARG_MC}, {\n\tatom_op_div, ATOM_ARG_REG}, {\n\tatom_op_div, ATOM_ARG_PS}, {\n\tatom_op_div, ATOM_ARG_WS}, {\n\tatom_op_div, ATOM_ARG_FB}, {\n\tatom_op_div, ATOM_ARG_PLL}, {\n\tatom_op_div, ATOM_ARG_MC}, {\n\tatom_op_add, ATOM_ARG_REG}, {\n\tatom_op_add, ATOM_ARG_PS}, {\n\tatom_op_add, ATOM_ARG_WS}, {\n\tatom_op_add, ATOM_ARG_FB}, {\n\tatom_op_add, ATOM_ARG_PLL}, {\n\tatom_op_add, ATOM_ARG_MC}, {\n\tatom_op_sub, ATOM_ARG_REG}, {\n\tatom_op_sub, ATOM_ARG_PS}, {\n\tatom_op_sub, ATOM_ARG_WS}, {\n\tatom_op_sub, ATOM_ARG_FB}, {\n\tatom_op_sub, ATOM_ARG_PLL}, {\n\tatom_op_sub, ATOM_ARG_MC}, {\n\tatom_op_setport, ATOM_PORT_ATI}, {\n\tatom_op_setport, ATOM_PORT_PCI}, {\n\tatom_op_setport, ATOM_PORT_SYSIO}, {\n\tatom_op_setregblock, 0}, {\n\tatom_op_setfbbase, 0}, {\n\tatom_op_compare, ATOM_ARG_REG}, {\n\tatom_op_compare, ATOM_ARG_PS}, {\n\tatom_op_compare, ATOM_ARG_WS}, {\n\tatom_op_compare, ATOM_ARG_FB}, {\n\tatom_op_compare, ATOM_ARG_PLL}, {\n\tatom_op_compare, ATOM_ARG_MC}, {\n\tatom_op_switch, 0}, {\n\tatom_op_jump, ATOM_COND_ALWAYS}, {\n\tatom_op_jump, ATOM_COND_EQUAL}, {\n\tatom_op_jump, ATOM_COND_BELOW}, {\n\tatom_op_jump, ATOM_COND_ABOVE}, {\n\tatom_op_jump, ATOM_COND_BELOWOREQUAL}, {\n\tatom_op_jump, ATOM_COND_ABOVEOREQUAL}, {\n\tatom_op_jump, ATOM_COND_NOTEQUAL}, {\n\tatom_op_test, ATOM_ARG_REG}, {\n\tatom_op_test, ATOM_ARG_PS}, {\n\tatom_op_test, ATOM_ARG_WS}, {\n\tatom_op_test, ATOM_ARG_FB}, {\n\tatom_op_test, ATOM_ARG_PLL}, {\n\tatom_op_test, ATOM_ARG_MC}, {\n\tatom_op_delay, ATOM_UNIT_MILLISEC}, {\n\tatom_op_delay, ATOM_UNIT_MICROSEC}, {\n\tatom_op_calltable, 0}, {\n\tatom_op_repeat, 0}, {\n\tatom_op_clear, ATOM_ARG_REG}, {\n\tatom_op_clear, ATOM_ARG_PS}, {\n\tatom_op_clear, ATOM_ARG_WS}, {\n\tatom_op_clear, ATOM_ARG_FB}, {\n\tatom_op_clear, ATOM_ARG_PLL}, {\n\tatom_op_clear, ATOM_ARG_MC}, {\n\tatom_op_nop, 0}, {\n\tatom_op_eot, 0}, {\n\tatom_op_mask, ATOM_ARG_REG}, {\n\tatom_op_mask, ATOM_ARG_PS}, {\n\tatom_op_mask, ATOM_ARG_WS}, {\n\tatom_op_mask, ATOM_ARG_FB}, {\n\tatom_op_mask, ATOM_ARG_PLL}, {\n\tatom_op_mask, ATOM_ARG_MC}, {\n\tatom_op_postcard, 0}, {\n\tatom_op_beep, 0}, {\n\tatom_op_savereg, 0}, {\n\tatom_op_restorereg, 0}, {\n\tatom_op_setdatablock, 0}, {\n\tatom_op_xor, ATOM_ARG_REG}, {\n\tatom_op_xor, ATOM_ARG_PS}, {\n\tatom_op_xor, ATOM_ARG_WS}, {\n\tatom_op_xor, ATOM_ARG_FB}, {\n\tatom_op_xor, ATOM_ARG_PLL}, {\n\tatom_op_xor, ATOM_ARG_MC}, {\n\tatom_op_shl, ATOM_ARG_REG}, {\n\tatom_op_shl, ATOM_ARG_PS}, {\n\tatom_op_shl, ATOM_ARG_WS}, {\n\tatom_op_shl, ATOM_ARG_FB}, {\n\tatom_op_shl, ATOM_ARG_PLL}, {\n\tatom_op_shl, ATOM_ARG_MC}, {\n\tatom_op_shr, ATOM_ARG_REG}, {\n\tatom_op_shr, ATOM_ARG_PS}, {\n\tatom_op_shr, ATOM_ARG_WS}, {\n\tatom_op_shr, ATOM_ARG_FB}, {\n\tatom_op_shr, ATOM_ARG_PLL}, {\n\tatom_op_shr, ATOM_ARG_MC}, {\n\tatom_op_debug, 0}, {\n\tatom_op_processds, 0}, {\n\tatom_op_mul32, ATOM_ARG_PS}, {\n\tatom_op_mul32, ATOM_ARG_WS}, {\n\tatom_op_div32, ATOM_ARG_PS}, {\n\tatom_op_div32, ATOM_ARG_WS},\n};\n\nstatic int amdgpu_atom_execute_table_locked(struct atom_context *ctx, int index, uint32_t *params)\n{\n\tint base = CU16(ctx->cmd_table + 4 + 2 * index);\n\tint len, ws, ps, ptr;\n\tunsigned char op;\n\tatom_exec_context ectx;\n\tint ret = 0;\n\n\tif (!base)\n\t\treturn -EINVAL;\n\n\tlen = CU16(base + ATOM_CT_SIZE_PTR);\n\tws = CU8(base + ATOM_CT_WS_PTR);\n\tps = CU8(base + ATOM_CT_PS_PTR) & ATOM_CT_PS_MASK;\n\tptr = base + ATOM_CT_CODE_PTR;\n\n\tSDEBUG(\">> execute %04X (len %d, WS %d, PS %d)\\n\", base, len, ws, ps);\n\n\tectx.ctx = ctx;\n\tectx.ps_shift = ps / 4;\n\tectx.start = base;\n\tectx.ps = params;\n\tectx.abort = false;\n\tectx.last_jump = 0;\n\tif (ws)\n\t\tectx.ws = kcalloc(4, ws, GFP_KERNEL);\n\telse\n\t\tectx.ws = NULL;\n\n\tdebug_depth++;\n\twhile (1) {\n\t\top = CU8(ptr++);\n\t\tif (op < ATOM_OP_NAMES_CNT)\n\t\t\tSDEBUG(\"%s @ 0x%04X\\n\", atom_op_names[op], ptr - 1);\n\t\telse\n\t\t\tSDEBUG(\"[%d] @ 0x%04X\\n\", op, ptr - 1);\n\t\tif (ectx.abort) {\n\t\t\tDRM_ERROR(\"atombios stuck executing %04X (len %d, WS %d, PS %d) @ 0x%04X\\n\",\n\t\t\t\tbase, len, ws, ps, ptr - 1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (op < ATOM_OP_CNT && op > 0)\n\t\t\topcode_table[op].func(&ectx, &ptr,\n\t\t\t\t\t      opcode_table[op].arg);\n\t\telse\n\t\t\tbreak;\n\n\t\tif (op == ATOM_OP_EOT)\n\t\t\tbreak;\n\t}\n\tdebug_depth--;\n\tSDEBUG(\"<<\\n\");\n\nfree:\n\tif (ws)\n\t\tkfree(ectx.ws);\n\treturn ret;\n}\n\nint amdgpu_atom_execute_table(struct atom_context *ctx, int index, uint32_t *params)\n{\n\tint r;\n\n\tmutex_lock(&ctx->mutex);\n\t \n\tctx->data_block = 0;\n\t \n\tctx->reg_block = 0;\n\t \n\tctx->fb_base = 0;\n\t \n\tctx->io_mode = ATOM_IO_MM;\n\t \n\tctx->divmul[0] = 0;\n\tctx->divmul[1] = 0;\n\tr = amdgpu_atom_execute_table_locked(ctx, index, params);\n\tmutex_unlock(&ctx->mutex);\n\treturn r;\n}\n\nstatic int atom_iio_len[] = { 1, 2, 3, 3, 3, 3, 4, 4, 4, 3 };\n\nstatic void atom_index_iio(struct atom_context *ctx, int base)\n{\n\tctx->iio = kzalloc(2 * 256, GFP_KERNEL);\n\tif (!ctx->iio)\n\t\treturn;\n\twhile (CU8(base) == ATOM_IIO_START) {\n\t\tctx->iio[CU8(base + 1)] = base + 2;\n\t\tbase += 2;\n\t\twhile (CU8(base) != ATOM_IIO_END)\n\t\t\tbase += atom_iio_len[CU8(base)];\n\t\tbase += 3;\n\t}\n}\n\nstatic void atom_get_vbios_name(struct atom_context *ctx)\n{\n\tunsigned char *p_rom;\n\tunsigned char str_num;\n\tunsigned short off_to_vbios_str;\n\tunsigned char *c_ptr;\n\tint name_size;\n\tint i;\n\n\tconst char *na = \"--N/A--\";\n\tchar *back;\n\n\tp_rom = ctx->bios;\n\n\tstr_num = *(p_rom + OFFSET_TO_GET_ATOMBIOS_NUMBER_OF_STRINGS);\n\tif (str_num != 0) {\n\t\toff_to_vbios_str =\n\t\t\t*(unsigned short *)(p_rom + OFFSET_TO_GET_ATOMBIOS_STRING_START);\n\n\t\tc_ptr = (unsigned char *)(p_rom + off_to_vbios_str);\n\t} else {\n\t\t \n\t\tmemcpy(ctx->name, na, 7);\n\t\tctx->name[7] = 0;\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < str_num; i++) {\n\t\twhile (*c_ptr != 0)\n\t\t\tc_ptr++;\n\t\tc_ptr++;\n\t}\n\n\t \n\tc_ptr += 2;\n\n\tname_size = strnlen(c_ptr, STRLEN_LONG - 1);\n\tmemcpy(ctx->name, c_ptr, name_size);\n\tback = ctx->name + name_size;\n\twhile ((*--back) == ' ')\n\t\t;\n\t*(back + 1) = '\\0';\n}\n\nstatic void atom_get_vbios_date(struct atom_context *ctx)\n{\n\tunsigned char *p_rom;\n\tunsigned char *date_in_rom;\n\n\tp_rom = ctx->bios;\n\n\tdate_in_rom = p_rom + OFFSET_TO_VBIOS_DATE;\n\n\tctx->date[0] = '2';\n\tctx->date[1] = '0';\n\tctx->date[2] = date_in_rom[6];\n\tctx->date[3] = date_in_rom[7];\n\tctx->date[4] = '/';\n\tctx->date[5] = date_in_rom[0];\n\tctx->date[6] = date_in_rom[1];\n\tctx->date[7] = '/';\n\tctx->date[8] = date_in_rom[3];\n\tctx->date[9] = date_in_rom[4];\n\tctx->date[10] = ' ';\n\tctx->date[11] = date_in_rom[9];\n\tctx->date[12] = date_in_rom[10];\n\tctx->date[13] = date_in_rom[11];\n\tctx->date[14] = date_in_rom[12];\n\tctx->date[15] = date_in_rom[13];\n\tctx->date[16] = '\\0';\n}\n\nstatic unsigned char *atom_find_str_in_rom(struct atom_context *ctx, char *str, int start,\n\t\t\t\t\t   int end, int maxlen)\n{\n\tunsigned long str_off;\n\tunsigned char *p_rom;\n\tunsigned short str_len;\n\n\tstr_off = 0;\n\tstr_len = strnlen(str, maxlen);\n\tp_rom = ctx->bios;\n\n\tfor (; start <= end; ++start) {\n\t\tfor (str_off = 0; str_off < str_len; ++str_off) {\n\t\t\tif (str[str_off] != *(p_rom + start + str_off))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (str_off == str_len || str[str_off] == 0)\n\t\t\treturn p_rom + start;\n\t}\n\treturn NULL;\n}\n\nstatic void atom_get_vbios_pn(struct atom_context *ctx)\n{\n\tunsigned char *p_rom;\n\tunsigned short off_to_vbios_str;\n\tunsigned char *vbios_str;\n\tint count;\n\n\toff_to_vbios_str = 0;\n\tp_rom = ctx->bios;\n\n\tif (*(p_rom + OFFSET_TO_GET_ATOMBIOS_NUMBER_OF_STRINGS) != 0) {\n\t\toff_to_vbios_str =\n\t\t\t*(unsigned short *)(p_rom + OFFSET_TO_GET_ATOMBIOS_STRING_START);\n\n\t\tvbios_str = (unsigned char *)(p_rom + off_to_vbios_str);\n\t} else {\n\t\tvbios_str = p_rom + OFFSET_TO_VBIOS_PART_NUMBER;\n\t}\n\n\tif (*vbios_str == 0) {\n\t\tvbios_str = atom_find_str_in_rom(ctx, BIOS_ATOM_PREFIX, 3, 1024, 64);\n\t\tif (vbios_str == NULL)\n\t\t\tvbios_str += sizeof(BIOS_ATOM_PREFIX) - 1;\n\t}\n\tif (vbios_str != NULL && *vbios_str == 0)\n\t\tvbios_str++;\n\n\tif (vbios_str != NULL) {\n\t\tcount = 0;\n\t\twhile ((count < BIOS_STRING_LENGTH) && vbios_str[count] >= ' ' &&\n\t\t       vbios_str[count] <= 'z') {\n\t\t\tctx->vbios_pn[count] = vbios_str[count];\n\t\t\tcount++;\n\t\t}\n\n\t\tctx->vbios_pn[count] = 0;\n\t}\n\n\tpr_info(\"ATOM BIOS: %s\\n\", ctx->vbios_pn);\n}\n\nstatic void atom_get_vbios_version(struct atom_context *ctx)\n{\n\tunsigned char *vbios_ver;\n\n\t \n\tvbios_ver = atom_find_str_in_rom(ctx, BIOS_VERSION_PREFIX, 3, 1024, 64);\n\tif (vbios_ver != NULL) {\n\t\t \n\t\tvbios_ver += 18;\n\t\tmemcpy(ctx->vbios_ver_str, vbios_ver, STRLEN_NORMAL);\n\t} else {\n\t\tctx->vbios_ver_str[0] = '\\0';\n\t}\n}\n\nstruct atom_context *amdgpu_atom_parse(struct card_info *card, void *bios)\n{\n\tint base;\n\tstruct atom_context *ctx =\n\t    kzalloc(sizeof(struct atom_context), GFP_KERNEL);\n\tstruct _ATOM_ROM_HEADER *atom_rom_header;\n\tstruct _ATOM_MASTER_DATA_TABLE *master_table;\n\tstruct _ATOM_FIRMWARE_INFO *atom_fw_info;\n\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->card = card;\n\tctx->bios = bios;\n\n\tif (CU16(0) != ATOM_BIOS_MAGIC) {\n\t\tpr_info(\"Invalid BIOS magic\\n\");\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\tif (strncmp\n\t    (CSTR(ATOM_ATI_MAGIC_PTR), ATOM_ATI_MAGIC,\n\t     strlen(ATOM_ATI_MAGIC))) {\n\t\tpr_info(\"Invalid ATI magic\\n\");\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tbase = CU16(ATOM_ROM_TABLE_PTR);\n\tif (strncmp\n\t    (CSTR(base + ATOM_ROM_MAGIC_PTR), ATOM_ROM_MAGIC,\n\t     strlen(ATOM_ROM_MAGIC))) {\n\t\tpr_info(\"Invalid ATOM magic\\n\");\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tctx->cmd_table = CU16(base + ATOM_ROM_CMD_PTR);\n\tctx->data_table = CU16(base + ATOM_ROM_DATA_PTR);\n\tatom_index_iio(ctx, CU16(ctx->data_table + ATOM_DATA_IIO_PTR) + 4);\n\tif (!ctx->iio) {\n\t\tamdgpu_atom_destroy(ctx);\n\t\treturn NULL;\n\t}\n\n\tatom_rom_header = (struct _ATOM_ROM_HEADER *)CSTR(base);\n\tif (atom_rom_header->usMasterDataTableOffset != 0) {\n\t\tmaster_table = (struct _ATOM_MASTER_DATA_TABLE *)\n\t\t\t\tCSTR(atom_rom_header->usMasterDataTableOffset);\n\t\tif (master_table->ListOfDataTables.FirmwareInfo != 0) {\n\t\t\tatom_fw_info = (struct _ATOM_FIRMWARE_INFO *)\n\t\t\t\t\tCSTR(master_table->ListOfDataTables.FirmwareInfo);\n\t\t\tctx->version = atom_fw_info->ulFirmwareRevision;\n\t\t}\n\t}\n\n\tatom_get_vbios_name(ctx);\n\tatom_get_vbios_pn(ctx);\n\tatom_get_vbios_date(ctx);\n\tatom_get_vbios_version(ctx);\n\n\treturn ctx;\n}\n\nint amdgpu_atom_asic_init(struct atom_context *ctx)\n{\n\tint hwi = CU16(ctx->data_table + ATOM_DATA_FWI_PTR);\n\tuint32_t ps[16];\n\tint ret;\n\n\tmemset(ps, 0, 64);\n\n\tps[0] = cpu_to_le32(CU32(hwi + ATOM_FWI_DEFSCLK_PTR));\n\tps[1] = cpu_to_le32(CU32(hwi + ATOM_FWI_DEFMCLK_PTR));\n\tif (!ps[0] || !ps[1])\n\t\treturn 1;\n\n\tif (!CU16(ctx->cmd_table + 4 + 2 * ATOM_CMD_INIT))\n\t\treturn 1;\n\tret = amdgpu_atom_execute_table(ctx, ATOM_CMD_INIT, ps);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(ps, 0, 64);\n\n\treturn ret;\n}\n\nvoid amdgpu_atom_destroy(struct atom_context *ctx)\n{\n\tkfree(ctx->iio);\n\tkfree(ctx);\n}\n\nbool amdgpu_atom_parse_data_header(struct atom_context *ctx, int index,\n\t\t\t    uint16_t *size, uint8_t *frev, uint8_t *crev,\n\t\t\t    uint16_t *data_start)\n{\n\tint offset = index * 2 + 4;\n\tint idx = CU16(ctx->data_table + offset);\n\tu16 *mdt = (u16 *)(ctx->bios + ctx->data_table + 4);\n\n\tif (!mdt[index])\n\t\treturn false;\n\n\tif (size)\n\t\t*size = CU16(idx);\n\tif (frev)\n\t\t*frev = CU8(idx + 2);\n\tif (crev)\n\t\t*crev = CU8(idx + 3);\n\t*data_start = idx;\n\treturn true;\n}\n\nbool amdgpu_atom_parse_cmd_header(struct atom_context *ctx, int index, uint8_t *frev,\n\t\t\t   uint8_t *crev)\n{\n\tint offset = index * 2 + 4;\n\tint idx = CU16(ctx->cmd_table + offset);\n\tu16 *mct = (u16 *)(ctx->bios + ctx->cmd_table + 4);\n\n\tif (!mct[index])\n\t\treturn false;\n\n\tif (frev)\n\t\t*frev = CU8(idx + 2);\n\tif (crev)\n\t\t*crev = CU8(idx + 3);\n\treturn true;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}