{
  "module_name": "amdgpu_vm_cpu.c",
  "hash_id": "e7b1cc5c18c9baf6ece36364f3f176cd789cf739dc33c5d2fc105c4f2b06d23f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_vm_cpu.c",
  "human_readable_source": " \n\n#include \"amdgpu_vm.h\"\n#include \"amdgpu_object.h\"\n#include \"amdgpu_trace.h\"\n\n \nstatic int amdgpu_vm_cpu_map_table(struct amdgpu_bo_vm *table)\n{\n\ttable->bo.flags |= AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED;\n\treturn amdgpu_bo_kmap(&table->bo, NULL);\n}\n\n \nstatic int amdgpu_vm_cpu_prepare(struct amdgpu_vm_update_params *p,\n\t\t\t\t struct dma_resv *resv,\n\t\t\t\t enum amdgpu_sync_mode sync_mode)\n{\n\tif (!resv)\n\t\treturn 0;\n\n\treturn amdgpu_bo_sync_wait_resv(p->adev, resv, sync_mode, p->vm, true);\n}\n\n \nstatic int amdgpu_vm_cpu_update(struct amdgpu_vm_update_params *p,\n\t\t\t\tstruct amdgpu_bo_vm *vmbo, uint64_t pe,\n\t\t\t\tuint64_t addr, unsigned count, uint32_t incr,\n\t\t\t\tuint64_t flags)\n{\n\tunsigned int i;\n\tuint64_t value;\n\tlong r;\n\n\tr = dma_resv_wait_timeout(vmbo->bo.tbo.base.resv, DMA_RESV_USAGE_KERNEL,\n\t\t\t\t  true, MAX_SCHEDULE_TIMEOUT);\n\tif (r < 0)\n\t\treturn r;\n\n\tpe += (unsigned long)amdgpu_bo_kptr(&vmbo->bo);\n\n\ttrace_amdgpu_vm_set_ptes(pe, addr, count, incr, flags, p->immediate);\n\n\tfor (i = 0; i < count; i++) {\n\t\tvalue = p->pages_addr ?\n\t\t\tamdgpu_vm_map_gart(p->pages_addr, addr) :\n\t\t\taddr;\n\t\tamdgpu_gmc_set_pte_pde(p->adev, (void *)(uintptr_t)pe,\n\t\t\t\t       i, value, flags);\n\t\taddr += incr;\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_vm_cpu_commit(struct amdgpu_vm_update_params *p,\n\t\t\t\tstruct dma_fence **fence)\n{\n\t \n\tmb();\n\tamdgpu_device_flush_hdp(p->adev, NULL);\n\treturn 0;\n}\n\nconst struct amdgpu_vm_update_funcs amdgpu_vm_cpu_funcs = {\n\t.map_table = amdgpu_vm_cpu_map_table,\n\t.prepare = amdgpu_vm_cpu_prepare,\n\t.update = amdgpu_vm_cpu_update,\n\t.commit = amdgpu_vm_cpu_commit\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}