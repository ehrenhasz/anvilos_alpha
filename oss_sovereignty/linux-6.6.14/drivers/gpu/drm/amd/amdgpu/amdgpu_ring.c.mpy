{
  "module_name": "amdgpu_ring.c",
  "hash_id": "54cb892e5ff484b971d6ad692fc7422f63f50d3b63c344231ec2dac971fe81e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c",
  "human_readable_source": " \n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n\n \n\n \nunsigned int amdgpu_ring_max_ibs(enum amdgpu_ring_type type)\n{\n\tswitch (type) {\n\tcase AMDGPU_RING_TYPE_GFX:\n\t\t \n\t\treturn 192;\n\tcase AMDGPU_RING_TYPE_COMPUTE:\n\t\treturn 125;\n\tcase AMDGPU_RING_TYPE_VCN_JPEG:\n\t\treturn 16;\n\tdefault:\n\t\treturn 49;\n\t}\n}\n\n \nint amdgpu_ring_alloc(struct amdgpu_ring *ring, unsigned int ndw)\n{\n\t \n\tndw = (ndw + ring->funcs->align_mask) & ~ring->funcs->align_mask;\n\n\t \n\tif (WARN_ON_ONCE(ndw > ring->max_dw))\n\t\treturn -ENOMEM;\n\n\tring->count_dw = ndw;\n\tring->wptr_old = ring->wptr;\n\n\tif (ring->funcs->begin_use)\n\t\tring->funcs->begin_use(ring);\n\n\treturn 0;\n}\n\n \nvoid amdgpu_ring_insert_nop(struct amdgpu_ring *ring, uint32_t count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tamdgpu_ring_write(ring, ring->funcs->nop);\n}\n\n \nvoid amdgpu_ring_generic_pad_ib(struct amdgpu_ring *ring, struct amdgpu_ib *ib)\n{\n\twhile (ib->length_dw & ring->funcs->align_mask)\n\t\tib->ptr[ib->length_dw++] = ring->funcs->nop;\n}\n\n \nvoid amdgpu_ring_commit(struct amdgpu_ring *ring)\n{\n\tuint32_t count;\n\n\t \n\tcount = ring->funcs->align_mask + 1 -\n\t\t(ring->wptr & ring->funcs->align_mask);\n\tcount %= ring->funcs->align_mask + 1;\n\tring->funcs->insert_nop(ring, count);\n\n\tmb();\n\tamdgpu_ring_set_wptr(ring);\n\n\tif (ring->funcs->end_use)\n\t\tring->funcs->end_use(ring);\n}\n\n \nvoid amdgpu_ring_undo(struct amdgpu_ring *ring)\n{\n\tring->wptr = ring->wptr_old;\n\n\tif (ring->funcs->end_use)\n\t\tring->funcs->end_use(ring);\n}\n\n#define amdgpu_ring_get_gpu_addr(ring, offset)\t\t\t\t\\\n\t(ring->is_mes_queue ?\t\t\t\t\t\t\\\n\t (ring->mes_ctx->meta_data_gpu_addr + offset) :\t\t\t\\\n\t (ring->adev->wb.gpu_addr + offset * 4))\n\n#define amdgpu_ring_get_cpu_addr(ring, offset)\t\t\t\t\\\n\t(ring->is_mes_queue ?\t\t\t\t\t\t\\\n\t (void *)((uint8_t *)(ring->mes_ctx->meta_data_ptr) + offset) : \\\n\t (&ring->adev->wb.wb[offset]))\n\n \nint amdgpu_ring_init(struct amdgpu_device *adev, struct amdgpu_ring *ring,\n\t\t     unsigned int max_dw, struct amdgpu_irq_src *irq_src,\n\t\t     unsigned int irq_type, unsigned int hw_prio,\n\t\t     atomic_t *sched_score)\n{\n\tint r;\n\tint sched_hw_submission = amdgpu_sched_hw_submission;\n\tu32 *num_sched;\n\tu32 hw_ip;\n\tunsigned int max_ibs_dw;\n\n\t \n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tsched_hw_submission = max(sched_hw_submission, 256);\n\telse if (ring == &adev->sdma.instance[0].page)\n\t\tsched_hw_submission = 256;\n\n\tif (ring->adev == NULL) {\n\t\tif (adev->num_rings >= AMDGPU_MAX_RINGS)\n\t\t\treturn -EINVAL;\n\n\t\tring->adev = adev;\n\t\tring->num_hw_submission = sched_hw_submission;\n\t\tring->sched_score = sched_score;\n\t\tring->vmid_wait = dma_fence_get_stub();\n\n\t\tif (!ring->is_mes_queue) {\n\t\t\tring->idx = adev->num_rings++;\n\t\t\tadev->rings[ring->idx] = ring;\n\t\t}\n\n\t\tr = amdgpu_fence_driver_init_ring(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (ring->is_mes_queue) {\n\t\tring->rptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_RPTR_OFFS);\n\t\tring->wptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_WPTR_OFFS);\n\t\tring->fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_FENCE_OFFS);\n\t\tring->trail_fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_TRAIL_FENCE_OFFS);\n\t\tring->cond_exe_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_COND_EXE_OFFS);\n\t} else {\n\t\tr = amdgpu_device_wb_get(adev, &ring->rptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring rptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->wptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring wptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->trail_fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring trail_fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->cond_exe_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring cond_exec_polling wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tring->fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->fence_offs);\n\tring->fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->fence_offs);\n\n\tring->rptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->rptr_offs);\n\tring->rptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->rptr_offs);\n\n\tring->wptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->wptr_offs);\n\tring->wptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->wptr_offs);\n\n\tring->trail_fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->trail_fence_offs);\n\tring->trail_fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->trail_fence_offs);\n\n\tring->cond_exe_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->cond_exe_offs);\n\tring->cond_exe_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->cond_exe_offs);\n\n\t \n\t*ring->cond_exe_cpu_addr = 1;\n\n\tr = amdgpu_fence_driver_start_ring(ring, irq_src, irq_type);\n\tif (r) {\n\t\tdev_err(adev->dev, \"failed initializing fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tmax_ibs_dw = ring->funcs->emit_frame_size +\n\t\t     amdgpu_ring_max_ibs(ring->funcs->type) * ring->funcs->emit_ib_size;\n\tmax_ibs_dw = (max_ibs_dw + ring->funcs->align_mask) & ~ring->funcs->align_mask;\n\n\tif (WARN_ON(max_ibs_dw > max_dw))\n\t\tmax_dw = max_ibs_dw;\n\n\tring->ring_size = roundup_pow_of_two(max_dw * 4 * sched_hw_submission);\n\n\tring->buf_mask = (ring->ring_size / 4) - 1;\n\tring->ptr_mask = ring->funcs->support_64bit_ptrs ?\n\t\t0xffffffffffffffff : ring->buf_mask;\n\n\t \n\tif (ring->is_mes_queue) {\n\t\tint offset = 0;\n\n\t\tBUG_ON(ring->ring_size > PAGE_SIZE*4);\n\n\t\toffset = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\t\t AMDGPU_MES_CTX_RING_OFFS);\n\t\tring->gpu_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tring->ring = amdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\t\tamdgpu_ring_clear_ring(ring);\n\n\t} else if (ring->ring_obj == NULL) {\n\t\tr = amdgpu_bo_create_kernel(adev, ring->ring_size + ring->funcs->extra_dw, PAGE_SIZE,\n\t\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t    &ring->ring_obj,\n\t\t\t\t\t    &ring->gpu_addr,\n\t\t\t\t\t    (void **)&ring->ring);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring create failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\tring->max_dw = max_dw;\n\tring->hw_prio = hw_prio;\n\n\tif (!ring->no_scheduler) {\n\t\thw_ip = ring->funcs->type;\n\t\tnum_sched = &adev->gpu_sched[hw_ip][hw_prio].num_scheds;\n\t\tadev->gpu_sched[hw_ip][hw_prio].sched[(*num_sched)++] =\n\t\t\t&ring->sched;\n\t}\n\n\treturn 0;\n}\n\n \nvoid amdgpu_ring_fini(struct amdgpu_ring *ring)\n{\n\n\t \n\tif (!(ring->adev) ||\n\t    (!ring->is_mes_queue && !(ring->adev->rings[ring->idx])))\n\t\treturn;\n\n\tring->sched.ready = false;\n\n\tif (!ring->is_mes_queue) {\n\t\tamdgpu_device_wb_free(ring->adev, ring->rptr_offs);\n\t\tamdgpu_device_wb_free(ring->adev, ring->wptr_offs);\n\n\t\tamdgpu_device_wb_free(ring->adev, ring->cond_exe_offs);\n\t\tamdgpu_device_wb_free(ring->adev, ring->fence_offs);\n\n\t\tamdgpu_bo_free_kernel(&ring->ring_obj,\n\t\t\t\t      &ring->gpu_addr,\n\t\t\t\t      (void **)&ring->ring);\n\t} else {\n\t\tkfree(ring->fence_drv.fences);\n\t}\n\n\tdma_fence_put(ring->vmid_wait);\n\tring->vmid_wait = NULL;\n\tring->me = 0;\n\n\tif (!ring->is_mes_queue)\n\t\tring->adev->rings[ring->idx] = NULL;\n}\n\n \nvoid amdgpu_ring_emit_reg_write_reg_wait_helper(struct amdgpu_ring *ring,\n\t\t\t\t\t\tuint32_t reg0, uint32_t reg1,\n\t\t\t\t\t\tuint32_t ref, uint32_t mask)\n{\n\tamdgpu_ring_emit_wreg(ring, reg0, ref);\n\tamdgpu_ring_emit_reg_wait(ring, reg1, mask, mask);\n}\n\n \nbool amdgpu_ring_soft_recovery(struct amdgpu_ring *ring, unsigned int vmid,\n\t\t\t       struct dma_fence *fence)\n{\n\tunsigned long flags;\n\n\tktime_t deadline = ktime_add_us(ktime_get(), 10000);\n\n\tif (amdgpu_sriov_vf(ring->adev) || !ring->funcs->soft_recovery || !fence)\n\t\treturn false;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\tif (!dma_fence_is_signaled_locked(fence))\n\t\tdma_fence_set_error(fence, -ENODATA);\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\tatomic_inc(&ring->adev->gpu_reset_counter);\n\twhile (!dma_fence_is_signaled(fence) &&\n\t       ktime_to_ns(ktime_sub(deadline, ktime_get())) > 0)\n\t\tring->funcs->soft_recovery(ring, vmid);\n\n\treturn dma_fence_is_signaled(fence);\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\n \nstatic ssize_t amdgpu_debugfs_ring_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_ring *ring = file_inode(f)->i_private;\n\tint r, i;\n\tuint32_t value, result, early[3];\n\n\tif (*pos & 3 || size & 3)\n\t\treturn -EINVAL;\n\n\tresult = 0;\n\n\tif (*pos < 12) {\n\t\tearly[0] = amdgpu_ring_get_rptr(ring) & ring->buf_mask;\n\t\tearly[1] = amdgpu_ring_get_wptr(ring) & ring->buf_mask;\n\t\tearly[2] = ring->wptr & ring->buf_mask;\n\t\tfor (i = *pos / 4; i < 3 && size; i++) {\n\t\t\tr = put_user(early[i], (uint32_t *)buf);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tbuf += 4;\n\t\t\tresult += 4;\n\t\t\tsize -= 4;\n\t\t\t*pos += 4;\n\t\t}\n\t}\n\n\twhile (size) {\n\t\tif (*pos >= (ring->ring_size + 12))\n\t\t\treturn result;\n\n\t\tvalue = ring->ring[(*pos - 12)/4];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbuf += 4;\n\t\tresult += 4;\n\t\tsize -= 4;\n\t\t*pos += 4;\n\t}\n\n\treturn result;\n}\n\nstatic const struct file_operations amdgpu_debugfs_ring_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_ring_read,\n\t.llseek = default_llseek\n};\n\nstatic ssize_t amdgpu_debugfs_mqd_read(struct file *f, char __user *buf,\n\t\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct amdgpu_ring *ring = file_inode(f)->i_private;\n\tvolatile u32 *mqd;\n\tint r;\n\tuint32_t value, result;\n\n\tif (*pos & 3 || size & 3)\n\t\treturn -EINVAL;\n\n\tresult = 0;\n\n\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&mqd);\n\tif (r) {\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\treturn r;\n\t}\n\n\twhile (size) {\n\t\tif (*pos >= ring->mqd_size)\n\t\t\tgoto done;\n\n\t\tvalue = mqd[*pos/4];\n\t\tr = put_user(value, (uint32_t *)buf);\n\t\tif (r)\n\t\t\tgoto done;\n\t\tbuf += 4;\n\t\tresult += 4;\n\t\tsize -= 4;\n\t\t*pos += 4;\n\t}\n\ndone:\n\tamdgpu_bo_kunmap(ring->mqd_obj);\n\tmqd = NULL;\n\tamdgpu_bo_unreserve(ring->mqd_obj);\n\tif (r)\n\t\treturn r;\n\n\treturn result;\n}\n\nstatic const struct file_operations amdgpu_debugfs_mqd_fops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_debugfs_mqd_read,\n\t.llseek = default_llseek\n};\n\nstatic int amdgpu_debugfs_ring_error(void *data, u64 val)\n{\n\tstruct amdgpu_ring *ring = data;\n\n\tamdgpu_fence_driver_set_error(ring, val);\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE_SIGNED(amdgpu_debugfs_error_fops, NULL,\n\t\t\t\tamdgpu_debugfs_ring_error, \"%lld\\n\");\n\n#endif\n\nvoid amdgpu_debugfs_ring_init(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_ring *ring)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct drm_minor *minor = adev_to_drm(adev)->primary;\n\tstruct dentry *root = minor->debugfs_root;\n\tchar name[32];\n\n\tsprintf(name, \"amdgpu_ring_%s\", ring->name);\n\tdebugfs_create_file_size(name, S_IFREG | 0444, root, ring,\n\t\t\t\t &amdgpu_debugfs_ring_fops,\n\t\t\t\t ring->ring_size + 12);\n\n\tif (ring->mqd_obj) {\n\t\tsprintf(name, \"amdgpu_mqd_%s\", ring->name);\n\t\tdebugfs_create_file_size(name, S_IFREG | 0444, root, ring,\n\t\t\t\t\t &amdgpu_debugfs_mqd_fops,\n\t\t\t\t\t ring->mqd_size);\n\t}\n\n\tsprintf(name, \"amdgpu_error_%s\", ring->name);\n\tdebugfs_create_file(name, 0200, root, ring,\n\t\t\t    &amdgpu_debugfs_error_fops);\n\n#endif\n}\n\n \nint amdgpu_ring_test_helper(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tint r;\n\n\tr = amdgpu_ring_test_ring(ring);\n\tif (r)\n\t\tDRM_DEV_ERROR(adev->dev, \"ring %s test failed (%d)\\n\",\n\t\t\t      ring->name, r);\n\telse\n\t\tDRM_DEV_DEBUG(adev->dev, \"ring test on %s succeeded\\n\",\n\t\t\t      ring->name);\n\n\tring->sched.ready = !r;\n\treturn r;\n}\n\nstatic void amdgpu_ring_to_mqd_prop(struct amdgpu_ring *ring,\n\t\t\t\t    struct amdgpu_mqd_prop *prop)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tmemset(prop, 0, sizeof(*prop));\n\n\tprop->mqd_gpu_addr = ring->mqd_gpu_addr;\n\tprop->hqd_base_gpu_addr = ring->gpu_addr;\n\tprop->rptr_gpu_addr = ring->rptr_gpu_addr;\n\tprop->wptr_gpu_addr = ring->wptr_gpu_addr;\n\tprop->queue_size = ring->ring_size;\n\tprop->eop_gpu_addr = ring->eop_gpu_addr;\n\tprop->use_doorbell = ring->use_doorbell;\n\tprop->doorbell_index = ring->doorbell_index;\n\n\t \n\tprop->hqd_active = ring->funcs->type == AMDGPU_RING_TYPE_KIQ;\n\n\tif ((ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE &&\n\t     amdgpu_gfx_is_high_priority_compute_queue(adev, ring)) ||\n\t    (ring->funcs->type == AMDGPU_RING_TYPE_GFX &&\n\t     amdgpu_gfx_is_high_priority_graphics_queue(adev, ring))) {\n\t\tprop->hqd_pipe_priority = AMDGPU_GFX_PIPE_PRIO_HIGH;\n\t\tprop->hqd_queue_priority = AMDGPU_GFX_QUEUE_PRIORITY_MAXIMUM;\n\t}\n}\n\nint amdgpu_ring_init_mqd(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_mqd *mqd_mgr;\n\tstruct amdgpu_mqd_prop prop;\n\n\tamdgpu_ring_to_mqd_prop(ring, &prop);\n\n\tring->wptr = 0;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tmqd_mgr = &adev->mqds[AMDGPU_HW_IP_COMPUTE];\n\telse\n\t\tmqd_mgr = &adev->mqds[ring->funcs->type];\n\n\treturn mqd_mgr->init_mqd(adev, ring->mqd_ptr, &prop);\n}\n\nvoid amdgpu_ring_ib_begin(struct amdgpu_ring *ring)\n{\n\tif (ring->is_sw_ring)\n\t\tamdgpu_sw_ring_ib_begin(ring);\n}\n\nvoid amdgpu_ring_ib_end(struct amdgpu_ring *ring)\n{\n\tif (ring->is_sw_ring)\n\t\tamdgpu_sw_ring_ib_end(ring);\n}\n\nvoid amdgpu_ring_ib_on_emit_cntl(struct amdgpu_ring *ring)\n{\n\tif (ring->is_sw_ring)\n\t\tamdgpu_sw_ring_ib_mark_offset(ring, AMDGPU_MUX_OFFSET_TYPE_CONTROL);\n}\n\nvoid amdgpu_ring_ib_on_emit_ce(struct amdgpu_ring *ring)\n{\n\tif (ring->is_sw_ring)\n\t\tamdgpu_sw_ring_ib_mark_offset(ring, AMDGPU_MUX_OFFSET_TYPE_CE);\n}\n\nvoid amdgpu_ring_ib_on_emit_de(struct amdgpu_ring *ring)\n{\n\tif (ring->is_sw_ring)\n\t\tamdgpu_sw_ring_ib_mark_offset(ring, AMDGPU_MUX_OFFSET_TYPE_DE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}