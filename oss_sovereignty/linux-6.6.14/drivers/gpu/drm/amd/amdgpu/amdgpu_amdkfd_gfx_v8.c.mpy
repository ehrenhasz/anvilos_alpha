{
  "module_name": "amdgpu_amdkfd_gfx_v8.c",
  "hash_id": "247fbf6783e336b941809ca8470ae000d6e2ad7003a167b8377a473e8ef46eba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"gfx_v8_0.h\"\n#include \"gca/gfx_8_0_sh_mask.h\"\n#include \"gca/gfx_8_0_d.h\"\n#include \"gca/gfx_8_0_enum.h\"\n#include \"oss/oss_3_0_sh_mask.h\"\n#include \"oss/oss_3_0_d.h\"\n#include \"gmc/gmc_8_1_sh_mask.h\"\n#include \"gmc/gmc_8_1_d.h\"\n#include \"vi_structs.h\"\n#include \"vid.h\"\n\nenum hqd_dequeue_request_type {\n\tNO_ACTION = 0,\n\tDRAIN_PIPE,\n\tRESET_WAVES\n};\n\nstatic void lock_srbm(struct amdgpu_device *adev, uint32_t mec, uint32_t pipe,\n\t\t\tuint32_t queue, uint32_t vmid)\n{\n\tuint32_t value = PIPEID(pipe) | MEID(mec) | VMID(vmid) | QUEUEID(queue);\n\n\tmutex_lock(&adev->srbm_mutex);\n\tWREG32(mmSRBM_GFX_CNTL, value);\n}\n\nstatic void unlock_srbm(struct amdgpu_device *adev)\n{\n\tWREG32(mmSRBM_GFX_CNTL, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n}\n\nstatic void acquire_queue(struct amdgpu_device *adev, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id)\n{\n\tuint32_t mec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\tuint32_t pipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\tlock_srbm(adev, mec, pipe, queue_id, 0);\n}\n\nstatic void release_queue(struct amdgpu_device *adev)\n{\n\tunlock_srbm(adev);\n}\n\nstatic void kgd_program_sh_mem_settings(struct amdgpu_device *adev, uint32_t vmid,\n\t\t\t\t\tuint32_t sh_mem_config,\n\t\t\t\t\tuint32_t sh_mem_ape1_base,\n\t\t\t\t\tuint32_t sh_mem_ape1_limit,\n\t\t\t\t\tuint32_t sh_mem_bases, uint32_t inst)\n{\n\tlock_srbm(adev, 0, 0, 0, vmid);\n\n\tWREG32(mmSH_MEM_CONFIG, sh_mem_config);\n\tWREG32(mmSH_MEM_APE1_BASE, sh_mem_ape1_base);\n\tWREG32(mmSH_MEM_APE1_LIMIT, sh_mem_ape1_limit);\n\tWREG32(mmSH_MEM_BASES, sh_mem_bases);\n\n\tunlock_srbm(adev);\n}\n\nstatic int kgd_set_pasid_vmid_mapping(struct amdgpu_device *adev, u32 pasid,\n\t\t\t\t\tunsigned int vmid, uint32_t inst)\n{\n\t \n\tuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\n\t\t\tATC_VMID0_PASID_MAPPING__VALID_MASK;\n\n\tWREG32(mmATC_VMID0_PASID_MAPPING + vmid, pasid_mapping);\n\n\twhile (!(RREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS) & (1U << vmid)))\n\t\tcpu_relax();\n\tWREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS, 1U << vmid);\n\n\t \n\tWREG32(mmIH_VMID_0_LUT + vmid, pasid_mapping);\n\n\treturn 0;\n}\n\nstatic int kgd_init_interrupts(struct amdgpu_device *adev, uint32_t pipe_id,\n\t\t\t\tuint32_t inst)\n{\n\tuint32_t mec;\n\tuint32_t pipe;\n\n\tmec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\tpipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\tlock_srbm(adev, mec, pipe, 0, 0);\n\n\tWREG32(mmCPC_INT_CNTL, CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK |\n\t\t\tCP_INT_CNTL_RING0__OPCODE_ERROR_INT_ENABLE_MASK);\n\n\tunlock_srbm(adev);\n\n\treturn 0;\n}\n\nstatic inline uint32_t get_sdma_rlc_reg_offset(struct vi_sdma_mqd *m)\n{\n\tuint32_t retval;\n\n\tretval = m->sdma_engine_id * SDMA1_REGISTER_OFFSET +\n\t\tm->sdma_queue_id * KFD_VI_SDMA_QUEUE_OFFSET;\n\n\tpr_debug(\"RLC register offset for SDMA%d RLC%d: 0x%x\\n\",\n\t\t\tm->sdma_engine_id, m->sdma_queue_id, retval);\n\n\treturn retval;\n}\n\nstatic inline struct vi_mqd *get_mqd(void *mqd)\n{\n\treturn (struct vi_mqd *)mqd;\n}\n\nstatic inline struct vi_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct vi_sdma_mqd *)mqd;\n}\n\nstatic int kgd_hqd_load(struct amdgpu_device *adev, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tuint32_t __user *wptr, uint32_t wptr_shift,\n\t\t\tuint32_t wptr_mask, struct mm_struct *mm, uint32_t inst)\n{\n\tstruct vi_mqd *m;\n\tuint32_t *mqd_hqd;\n\tuint32_t reg, wptr_val, data;\n\tbool valid_wptr = false;\n\n\tm = get_mqd(mqd);\n\n\tacquire_queue(adev, pipe_id, queue_id);\n\n\t \n\tif (m->cp_hqd_vmid == 0) {\n\t\tuint32_t value, mec, pipe;\n\n\t\tmec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\t\tpipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\t\tpr_debug(\"kfd: set HIQ, mec:%d, pipe:%d, queue:%d.\\n\",\n\t\t\tmec, pipe, queue_id);\n\t\tvalue = RREG32(mmRLC_CP_SCHEDULERS);\n\t\tvalue = REG_SET_FIELD(value, RLC_CP_SCHEDULERS, scheduler1,\n\t\t\t((mec << 5) | (pipe << 3) | queue_id | 0x80));\n\t\tWREG32(mmRLC_CP_SCHEDULERS, value);\n\t}\n\n\t \n\tmqd_hqd = &m->cp_mqd_base_addr_lo;\n\n\tfor (reg = mmCP_MQD_BASE_ADDR; reg <= mmCP_HQD_EOP_CONTROL; reg++)\n\t\tWREG32(reg, mqd_hqd[reg - mmCP_MQD_BASE_ADDR]);\n\n\t \n\tif (adev->asic_type != CHIP_TONGA) {\n\t\tWREG32(mmCP_HQD_EOP_RPTR, m->cp_hqd_eop_rptr);\n\t\tWREG32(mmCP_HQD_EOP_WPTR, m->cp_hqd_eop_wptr);\n\t\tWREG32(mmCP_HQD_EOP_WPTR_MEM, m->cp_hqd_eop_wptr_mem);\n\t}\n\n\tfor (reg = mmCP_HQD_EOP_EVENTS; reg <= mmCP_HQD_ERROR; reg++)\n\t\tWREG32(reg, mqd_hqd[reg - mmCP_MQD_BASE_ADDR]);\n\n\t \n\tdata = REG_SET_FIELD(m->cp_hqd_pq_doorbell_control,\n\t\t\t     CP_HQD_PQ_DOORBELL_CONTROL, DOORBELL_EN, 1);\n\tWREG32(mmCP_HQD_PQ_DOORBELL_CONTROL, data);\n\n\t \n\trelease_queue(adev);\n\tvalid_wptr = read_user_wptr(mm, wptr, wptr_val);\n\tacquire_queue(adev, pipe_id, queue_id);\n\tif (valid_wptr)\n\t\tWREG32(mmCP_HQD_PQ_WPTR, (wptr_val << wptr_shift) & wptr_mask);\n\n\tdata = REG_SET_FIELD(m->cp_hqd_active, CP_HQD_ACTIVE, ACTIVE, 1);\n\tWREG32(mmCP_HQD_ACTIVE, data);\n\n\trelease_queue(adev);\n\n\treturn 0;\n}\n\nstatic int kgd_hqd_dump(struct amdgpu_device *adev,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tuint32_t (**dump)[2], uint32_t *n_regs, uint32_t inst)\n{\n\tuint32_t i = 0, reg;\n#define HQD_N_REGS (54+4)\n#define DUMP_REG(addr) do {\t\t\t\t\\\n\t\tif (WARN_ON_ONCE(i >= HQD_N_REGS))\t\\\n\t\t\tbreak;\t\t\t\t\\\n\t\t(*dump)[i][0] = (addr) << 2;\t\t\\\n\t\t(*dump)[i++][1] = RREG32(addr);\t\t\\\n\t} while (0)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tacquire_queue(adev, pipe_id, queue_id);\n\n\tDUMP_REG(mmCOMPUTE_STATIC_THREAD_MGMT_SE0);\n\tDUMP_REG(mmCOMPUTE_STATIC_THREAD_MGMT_SE1);\n\tDUMP_REG(mmCOMPUTE_STATIC_THREAD_MGMT_SE2);\n\tDUMP_REG(mmCOMPUTE_STATIC_THREAD_MGMT_SE3);\n\n\tfor (reg = mmCP_MQD_BASE_ADDR; reg <= mmCP_HQD_EOP_DONES; reg++)\n\t\tDUMP_REG(reg);\n\n\trelease_queue(adev);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_load(struct amdgpu_device *adev, void *mqd,\n\t\t\t     uint32_t __user *wptr, struct mm_struct *mm)\n{\n\tstruct vi_sdma_mqd *m;\n\tunsigned long end_jiffies;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t data;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(m);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tm->sdmax_rlcx_rb_cntl & (~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK));\n\n\tend_jiffies = msecs_to_jiffies(2000) + jiffies;\n\twhile (true) {\n\t\tdata = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (data & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_doorbell, SDMA0_RLC0_DOORBELL,\n\t\t\t     ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, data);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR,\n\t\t\t\tm->sdmax_rlcx_rb_rptr);\n\n\tif (read_user_wptr(mm, wptr, data))\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR, data);\n\telse\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR,\n\t\t       m->sdmax_rlcx_rb_rptr);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_VIRTUAL_ADDR,\n\t\t\t\tm->sdmax_rlcx_virtual_addr);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE, m->sdmax_rlcx_rb_base);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE_HI,\n\t\t\tm->sdmax_rlcx_rb_base_hi);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_LO,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_lo);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_HI,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_hi);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_rb_cntl, SDMA0_RLC0_RB_CNTL,\n\t\t\t     RB_ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, data);\n\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_dump(struct amdgpu_device *adev,\n\t\t\t     uint32_t engine_id, uint32_t queue_id,\n\t\t\t     uint32_t (**dump)[2], uint32_t *n_regs)\n{\n\tuint32_t sdma_offset = engine_id * SDMA1_REGISTER_OFFSET +\n\t\tqueue_id * KFD_VI_SDMA_QUEUE_OFFSET;\n\tuint32_t i = 0, reg;\n#undef HQD_N_REGS\n#define HQD_N_REGS (19+4+2+3+7)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (reg = mmSDMA0_RLC0_RB_CNTL; reg <= mmSDMA0_RLC0_DOORBELL; reg++)\n\t\tDUMP_REG(sdma_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_VIRTUAL_ADDR; reg <= mmSDMA0_RLC0_WATERMARK;\n\t     reg++)\n\t\tDUMP_REG(sdma_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_CSA_ADDR_LO; reg <= mmSDMA0_RLC0_CSA_ADDR_HI;\n\t     reg++)\n\t\tDUMP_REG(sdma_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_IB_SUB_REMAIN; reg <= mmSDMA0_RLC0_DUMMY_REG;\n\t     reg++)\n\t\tDUMP_REG(sdma_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_MIDCMD_DATA0; reg <= mmSDMA0_RLC0_MIDCMD_CNTL;\n\t     reg++)\n\t\tDUMP_REG(sdma_offset + reg);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nstatic bool kgd_hqd_is_occupied(struct amdgpu_device *adev,\n\t\t\t\tuint64_t queue_address, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id, uint32_t inst)\n{\n\tuint32_t act;\n\tbool retval = false;\n\tuint32_t low, high;\n\n\tacquire_queue(adev, pipe_id, queue_id);\n\tact = RREG32(mmCP_HQD_ACTIVE);\n\tif (act) {\n\t\tlow = lower_32_bits(queue_address >> 8);\n\t\thigh = upper_32_bits(queue_address >> 8);\n\n\t\tif (low == RREG32(mmCP_HQD_PQ_BASE) &&\n\t\t\t\thigh == RREG32(mmCP_HQD_PQ_BASE_HI))\n\t\t\tretval = true;\n\t}\n\trelease_queue(adev);\n\treturn retval;\n}\n\nstatic bool kgd_hqd_sdma_is_occupied(struct amdgpu_device *adev, void *mqd)\n{\n\tstruct vi_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t sdma_rlc_rb_cntl;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(m);\n\n\tsdma_rlc_rb_cntl = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\n\tif (sdma_rlc_rb_cntl & SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int kgd_hqd_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\tenum kfd_preempt_type reset_type,\n\t\t\t\tunsigned int utimeout, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id, uint32_t inst)\n{\n\tuint32_t temp;\n\tenum hqd_dequeue_request_type type;\n\tunsigned long flags, end_jiffies;\n\tint retry;\n\tstruct vi_mqd *m = get_mqd(mqd);\n\n\tif (amdgpu_in_reset(adev))\n\t\treturn -EIO;\n\n\tacquire_queue(adev, pipe_id, queue_id);\n\n\tif (m->cp_hqd_vmid == 0)\n\t\tWREG32_FIELD(RLC_CP_SCHEDULERS, scheduler1, 0);\n\n\tswitch (reset_type) {\n\tcase KFD_PREEMPT_TYPE_WAVEFRONT_DRAIN:\n\t\ttype = DRAIN_PIPE;\n\t\tbreak;\n\tcase KFD_PREEMPT_TYPE_WAVEFRONT_RESET:\n\t\ttype = RESET_WAVES;\n\t\tbreak;\n\tdefault:\n\t\ttype = DRAIN_PIPE;\n\t\tbreak;\n\t}\n\n\t \n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tretry = 5000;  \n\twhile (true) {\n\t\ttemp = RREG32(mmCP_HQD_IQ_TIMER);\n\t\tif (REG_GET_FIELD(temp, CP_HQD_IQ_TIMER, PROCESSING_IQ)) {\n\t\t\tpr_debug(\"HW is processing IQ\\n\");\n\t\t\tgoto loop;\n\t\t}\n\t\tif (REG_GET_FIELD(temp, CP_HQD_IQ_TIMER, ACTIVE)) {\n\t\t\tif (REG_GET_FIELD(temp, CP_HQD_IQ_TIMER, RETRY_TYPE)\n\t\t\t\t\t== 3)  \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (REG_GET_FIELD(temp, CP_HQD_IQ_TIMER, WAIT_TIME)\n\t\t\t\t\t>= 10)\n\t\t\t\tbreak;\n\t\t\tpr_debug(\"IQ timer is active\\n\");\n\t\t} else\n\t\t\tbreak;\nloop:\n\t\tif (!retry) {\n\t\t\tpr_err(\"CP HQD IQ timer status time out\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tndelay(100);\n\t\t--retry;\n\t}\n\tretry = 1000;\n\twhile (true) {\n\t\ttemp = RREG32(mmCP_HQD_DEQUEUE_REQUEST);\n\t\tif (!(temp & CP_HQD_DEQUEUE_REQUEST__IQ_REQ_PEND_MASK))\n\t\t\tbreak;\n\t\tpr_debug(\"Dequeue request is pending\\n\");\n\n\t\tif (!retry) {\n\t\t\tpr_err(\"CP HQD dequeue request time out\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tndelay(100);\n\t\t--retry;\n\t}\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\tWREG32(mmCP_HQD_DEQUEUE_REQUEST, type);\n\n\tend_jiffies = (utimeout * HZ / 1000) + jiffies;\n\twhile (true) {\n\t\ttemp = RREG32(mmCP_HQD_ACTIVE);\n\t\tif (!(temp & CP_HQD_ACTIVE__ACTIVE_MASK))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"cp queue preemption time out.\\n\");\n\t\t\trelease_queue(adev);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\trelease_queue(adev);\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\tunsigned int utimeout)\n{\n\tstruct vi_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t temp;\n\tunsigned long end_jiffies = (utimeout * HZ / 1000) + jiffies;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(m);\n\n\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\ttemp = temp & ~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK;\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, temp);\n\n\twhile (true) {\n\t\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (temp & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, 0);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tRREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL) |\n\t\tSDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK);\n\n\tm->sdmax_rlcx_rb_rptr = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR);\n\n\treturn 0;\n}\n\nstatic bool get_atc_vmid_pasid_mapping_info(struct amdgpu_device *adev,\n\t\t\t\t\tuint8_t vmid, uint16_t *p_pasid)\n{\n\tuint32_t value;\n\n\tvalue = RREG32(mmATC_VMID0_PASID_MAPPING + vmid);\n\t*p_pasid = value & ATC_VMID0_PASID_MAPPING__PASID_MASK;\n\n\treturn !!(value & ATC_VMID0_PASID_MAPPING__VALID_MASK);\n}\n\nstatic int kgd_wave_control_execute(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t gfx_index_val,\n\t\t\t\t\tuint32_t sq_cmd, uint32_t inst)\n{\n\tuint32_t data = 0;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tWREG32(mmGRBM_GFX_INDEX, gfx_index_val);\n\tWREG32(mmSQ_CMD, sq_cmd);\n\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tINSTANCE_BROADCAST_WRITES, 1);\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tSH_BROADCAST_WRITES, 1);\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tSE_BROADCAST_WRITES, 1);\n\n\tWREG32(mmGRBM_GFX_INDEX, data);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\nstatic void set_scratch_backing_va(struct amdgpu_device *adev,\n\t\t\t\t\tuint64_t va, uint32_t vmid)\n{\n\tlock_srbm(adev, 0, 0, 0, vmid);\n\tWREG32(mmSH_HIDDEN_PRIVATE_BASE_VMID, va);\n\tunlock_srbm(adev);\n}\n\nstatic void set_vm_context_page_table_base(struct amdgpu_device *adev,\n\t\tuint32_t vmid, uint64_t page_table_base)\n{\n\tif (!amdgpu_amdkfd_is_kfd_vmid(adev, vmid)) {\n\t\tpr_err(\"trying to set page table base for wrong VMID\\n\");\n\t\treturn;\n\t}\n\tWREG32(mmVM_CONTEXT8_PAGE_TABLE_BASE_ADDR + vmid - 8,\n\t\t\tlower_32_bits(page_table_base));\n}\n\nconst struct kfd2kgd_calls gfx_v8_kfd2kgd = {\n\t.program_sh_mem_settings = kgd_program_sh_mem_settings,\n\t.set_pasid_vmid_mapping = kgd_set_pasid_vmid_mapping,\n\t.init_interrupts = kgd_init_interrupts,\n\t.hqd_load = kgd_hqd_load,\n\t.hqd_sdma_load = kgd_hqd_sdma_load,\n\t.hqd_dump = kgd_hqd_dump,\n\t.hqd_sdma_dump = kgd_hqd_sdma_dump,\n\t.hqd_is_occupied = kgd_hqd_is_occupied,\n\t.hqd_sdma_is_occupied = kgd_hqd_sdma_is_occupied,\n\t.hqd_destroy = kgd_hqd_destroy,\n\t.hqd_sdma_destroy = kgd_hqd_sdma_destroy,\n\t.wave_control_execute = kgd_wave_control_execute,\n\t.get_atc_vmid_pasid_mapping_info =\n\t\t\tget_atc_vmid_pasid_mapping_info,\n\t.set_scratch_backing_va = set_scratch_backing_va,\n\t.set_vm_context_page_table_base = set_vm_context_page_table_base,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}