{
  "module_name": "atombios_i2c.c",
  "hash_id": "796bce7e4f82fe72dc566c90cbefe6cbbf054b222d8395895cc15c477e58d855",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/atombios_i2c.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"amdgpu_atombios.h\"\n#include \"atombios_i2c.h\"\n\n#define TARGET_HW_I2C_CLOCK 50\n\n \n#define ATOM_MAX_HW_I2C_WRITE 3\n#define ATOM_MAX_HW_I2C_READ  255\n\nstatic int amdgpu_atombios_i2c_process_i2c_ch(struct amdgpu_i2c_chan *chan,\n\t\t\t\t       u8 slave_addr, u8 flags,\n\t\t\t\t       u8 *buf, u8 num)\n{\n\tstruct drm_device *dev = chan->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tPROCESS_I2C_CHANNEL_TRANSACTION_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ProcessI2cChannelTransaction);\n\tunsigned char *base;\n\tu16 out = cpu_to_le16(0);\n\tint r = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tmutex_lock(&chan->mutex);\n\n\tbase = (unsigned char *)adev->mode_info.atom_context->scratch;\n\n\tif (flags & HW_I2C_WRITE) {\n\t\tif (num > ATOM_MAX_HW_I2C_WRITE) {\n\t\t\tDRM_ERROR(\"hw i2c: tried to write too many bytes (%d vs 3)\\n\", num);\n\t\t\tr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (buf == NULL)\n\t\t\targs.ucRegIndex = 0;\n\t\telse\n\t\t\targs.ucRegIndex = buf[0];\n\t\tif (num)\n\t\t\tnum--;\n\t\tif (num) {\n\t\t\tif (buf) {\n\t\t\t\tmemcpy(&out, &buf[1], num);\n\t\t\t} else {\n\t\t\t\tDRM_ERROR(\"hw i2c: missing buf with num > 1\\n\");\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\targs.lpI2CDataOut = cpu_to_le16(out);\n\t} else {\n\t\targs.ucRegIndex = 0;\n\t\targs.lpI2CDataOut = 0;\n\t}\n\n\targs.ucFlag = flags;\n\targs.ucI2CSpeed = TARGET_HW_I2C_CLOCK;\n\targs.ucTransBytes = num;\n\targs.ucSlaveAddr = slave_addr << 1;\n\targs.ucLineNumber = chan->rec.i2c_id;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t \n\tif (args.ucStatus != HW_ASSISTED_I2C_STATUS_SUCCESS) {\n\t\tDRM_DEBUG_KMS(\"hw_i2c error\\n\");\n\t\tr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (!(flags & HW_I2C_WRITE))\n\t\tamdgpu_atombios_copy_swap(buf, base, num, false);\n\ndone:\n\tmutex_unlock(&chan->mutex);\n\n\treturn r;\n}\n\nint amdgpu_atombios_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t      struct i2c_msg *msgs, int num)\n{\n\tstruct amdgpu_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct i2c_msg *p;\n\tint i, remaining, current_count, buffer_offset, max_bytes, ret;\n\tu8 flags;\n\n\t \n\tp = &msgs[0];\n\tif ((num == 1) && (p->len == 0)) {\n\t\tret = amdgpu_atombios_i2c_process_i2c_ch(i2c,\n\t\t\t\t\t\t  p->addr, HW_I2C_WRITE,\n\t\t\t\t\t\t  NULL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn num;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tp = &msgs[i];\n\t\tremaining = p->len;\n\t\tbuffer_offset = 0;\n\t\t \n\t\tif (p->flags & I2C_M_RD) {\n\t\t\tmax_bytes = ATOM_MAX_HW_I2C_READ;\n\t\t\tflags = HW_I2C_READ;\n\t\t} else {\n\t\t\tmax_bytes = ATOM_MAX_HW_I2C_WRITE;\n\t\t\tflags = HW_I2C_WRITE;\n\t\t}\n\t\twhile (remaining) {\n\t\t\tif (remaining > max_bytes)\n\t\t\t\tcurrent_count = max_bytes;\n\t\t\telse\n\t\t\t\tcurrent_count = remaining;\n\t\t\tret = amdgpu_atombios_i2c_process_i2c_ch(i2c,\n\t\t\t\t\t\t\t  p->addr, flags,\n\t\t\t\t\t\t\t  &p->buf[buffer_offset], current_count);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tremaining -= current_count;\n\t\t\tbuffer_offset += current_count;\n\t\t}\n\t}\n\n\treturn num;\n}\n\nu32 amdgpu_atombios_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nvoid amdgpu_atombios_i2c_channel_trans(struct amdgpu_device *adev, u8 slave_addr, u8 line_number, u8 offset, u8 data)\n{\n\tPROCESS_I2C_CHANNEL_TRANSACTION_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ProcessI2cChannelTransaction);\n\n\targs.ucRegIndex = offset;\n\targs.lpI2CDataOut = data;\n\targs.ucFlag = 1;\n\targs.ucI2CSpeed = TARGET_HW_I2C_CLOCK;\n\targs.ucTransBytes = 1;\n\targs.ucSlaveAddr = slave_addr;\n\targs.ucLineNumber = line_number;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}