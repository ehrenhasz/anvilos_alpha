{
  "module_name": "amdgpu_amdkfd.h",
  "hash_id": "4d912960fa42fc0e4d921c43c4f7ec9682926bdae0e06dfa87078854777a3b1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h",
  "human_readable_source": " \n\n \n\n#ifndef AMDGPU_AMDKFD_H_INCLUDED\n#define AMDGPU_AMDKFD_H_INCLUDED\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memremap.h>\n#include <kgd_kfd_interface.h>\n#include \"amdgpu_sync.h\"\n#include \"amdgpu_vm.h\"\n#include \"amdgpu_xcp.h\"\n\nextern uint64_t amdgpu_amdkfd_total_mem_size;\n\nenum TLB_FLUSH_TYPE {\n\tTLB_FLUSH_LEGACY = 0,\n\tTLB_FLUSH_LIGHTWEIGHT,\n\tTLB_FLUSH_HEAVYWEIGHT\n};\n\nstruct amdgpu_device;\n\nenum kfd_mem_attachment_type {\n\tKFD_MEM_ATT_SHARED,\t \n\tKFD_MEM_ATT_USERPTR,\t \n\tKFD_MEM_ATT_DMABUF,\t \n\tKFD_MEM_ATT_SG\t\t \n};\n\nstruct kfd_mem_attachment {\n\tstruct list_head list;\n\tenum kfd_mem_attachment_type type;\n\tbool is_mapped;\n\tstruct amdgpu_bo_va *bo_va;\n\tstruct amdgpu_device *adev;\n\tuint64_t va;\n\tuint64_t pte_flags;\n};\n\nstruct kgd_mem {\n\tstruct mutex lock;\n\tstruct amdgpu_bo *bo;\n\tstruct dma_buf *dmabuf;\n\tstruct hmm_range *range;\n\tstruct list_head attachments;\n\t \n\tstruct list_head validate_list;\n\tuint32_t domain;\n\tunsigned int mapped_to_gpu_memory;\n\tuint64_t va;\n\n\tuint32_t alloc_flags;\n\n\tuint32_t invalid;\n\tstruct amdkfd_process_info *process_info;\n\n\tstruct amdgpu_sync sync;\n\n\tbool aql_queue;\n\tbool is_imported;\n};\n\n \nstruct amdgpu_amdkfd_fence {\n\tstruct dma_fence base;\n\tstruct mm_struct *mm;\n\tspinlock_t lock;\n\tchar timeline_name[TASK_COMM_LEN];\n\tstruct svm_range_bo *svm_bo;\n};\n\nstruct amdgpu_kfd_dev {\n\tstruct kfd_dev *dev;\n\tint64_t vram_used[MAX_XCP];\n\tuint64_t vram_used_aligned[MAX_XCP];\n\tbool init_complete;\n\tstruct work_struct reset_work;\n\n\t \n\tstruct dev_pagemap pgmap;\n};\n\nenum kgd_engine_type {\n\tKGD_ENGINE_PFP = 1,\n\tKGD_ENGINE_ME,\n\tKGD_ENGINE_CE,\n\tKGD_ENGINE_MEC1,\n\tKGD_ENGINE_MEC2,\n\tKGD_ENGINE_RLC,\n\tKGD_ENGINE_SDMA1,\n\tKGD_ENGINE_SDMA2,\n\tKGD_ENGINE_MAX\n};\n\n\nstruct amdkfd_process_info {\n\t \n\tstruct list_head vm_list_head;\n\t \n\tstruct list_head kfd_bo_list;\n\t \n\tstruct list_head userptr_valid_list;\n\tstruct list_head userptr_inval_list;\n\t \n\tstruct mutex lock;\n\n\t \n\tunsigned int n_vms;\n\t \n\tstruct amdgpu_amdkfd_fence *eviction_fence;\n\n\t \n\tstruct mutex notifier_lock;\n\tuint32_t evicted_bos;\n\tstruct delayed_work restore_userptr_work;\n\tstruct pid *pid;\n\tbool block_mmu_notifications;\n};\n\nint amdgpu_amdkfd_init(void);\nvoid amdgpu_amdkfd_fini(void);\n\nvoid amdgpu_amdkfd_suspend(struct amdgpu_device *adev, bool run_pm);\nint amdgpu_amdkfd_resume(struct amdgpu_device *adev, bool run_pm);\nvoid amdgpu_amdkfd_interrupt(struct amdgpu_device *adev,\n\t\t\tconst void *ih_ring_entry);\nvoid amdgpu_amdkfd_device_probe(struct amdgpu_device *adev);\nvoid amdgpu_amdkfd_device_init(struct amdgpu_device *adev);\nvoid amdgpu_amdkfd_device_fini_sw(struct amdgpu_device *adev);\nint amdgpu_amdkfd_check_and_lock_kfd(struct amdgpu_device *adev);\nvoid amdgpu_amdkfd_unlock_kfd(struct amdgpu_device *adev);\nint amdgpu_amdkfd_submit_ib(struct amdgpu_device *adev,\n\t\t\t\tenum kgd_engine_type engine,\n\t\t\t\tuint32_t vmid, uint64_t gpu_addr,\n\t\t\t\tuint32_t *ib_cmd, uint32_t ib_len);\nvoid amdgpu_amdkfd_set_compute_idle(struct amdgpu_device *adev, bool idle);\nbool amdgpu_amdkfd_have_atomics_support(struct amdgpu_device *adev);\nint amdgpu_amdkfd_flush_gpu_tlb_vmid(struct amdgpu_device *adev,\n\t\t\t\tuint16_t vmid);\nint amdgpu_amdkfd_flush_gpu_tlb_pasid(struct amdgpu_device *adev,\n\t\t\t\tuint16_t pasid, enum TLB_FLUSH_TYPE flush_type,\n\t\t\t\tuint32_t inst);\n\nbool amdgpu_amdkfd_is_kfd_vmid(struct amdgpu_device *adev, u32 vmid);\n\nint amdgpu_amdkfd_pre_reset(struct amdgpu_device *adev);\n\nint amdgpu_amdkfd_post_reset(struct amdgpu_device *adev);\n\nvoid amdgpu_amdkfd_gpu_reset(struct amdgpu_device *adev);\n\nint amdgpu_queue_mask_bit_to_set_resource_bit(struct amdgpu_device *adev,\n\t\t\t\t\tint queue_bit);\n\nstruct amdgpu_amdkfd_fence *amdgpu_amdkfd_fence_create(u64 context,\n\t\t\t\tstruct mm_struct *mm,\n\t\t\t\tstruct svm_range_bo *svm_bo);\n#if defined(CONFIG_DEBUG_FS)\nint kfd_debugfs_kfd_mem_limits(struct seq_file *m, void *data);\n#endif\n#if IS_ENABLED(CONFIG_HSA_AMD)\nbool amdkfd_fence_check_mm(struct dma_fence *f, struct mm_struct *mm);\nstruct amdgpu_amdkfd_fence *to_amdgpu_amdkfd_fence(struct dma_fence *f);\nint amdgpu_amdkfd_remove_fence_on_pt_pd_bos(struct amdgpu_bo *bo);\nint amdgpu_amdkfd_evict_userptr(struct mmu_interval_notifier *mni,\n\t\t\t\tunsigned long cur_seq, struct kgd_mem *mem);\n#else\nstatic inline\nbool amdkfd_fence_check_mm(struct dma_fence *f, struct mm_struct *mm)\n{\n\treturn false;\n}\n\nstatic inline\nstruct amdgpu_amdkfd_fence *to_amdgpu_amdkfd_fence(struct dma_fence *f)\n{\n\treturn NULL;\n}\n\nstatic inline\nint amdgpu_amdkfd_remove_fence_on_pt_pd_bos(struct amdgpu_bo *bo)\n{\n\treturn 0;\n}\n\nstatic inline\nint amdgpu_amdkfd_evict_userptr(struct mmu_interval_notifier *mni,\n\t\t\t\tunsigned long cur_seq, struct kgd_mem *mem)\n{\n\treturn 0;\n}\n#endif\n \nint amdgpu_amdkfd_alloc_gtt_mem(struct amdgpu_device *adev, size_t size,\n\t\t\t\tvoid **mem_obj, uint64_t *gpu_addr,\n\t\t\t\tvoid **cpu_ptr, bool mqd_gfx9);\nvoid amdgpu_amdkfd_free_gtt_mem(struct amdgpu_device *adev, void *mem_obj);\nint amdgpu_amdkfd_alloc_gws(struct amdgpu_device *adev, size_t size,\n\t\t\t\tvoid **mem_obj);\nvoid amdgpu_amdkfd_free_gws(struct amdgpu_device *adev, void *mem_obj);\nint amdgpu_amdkfd_add_gws_to_process(void *info, void *gws, struct kgd_mem **mem);\nint amdgpu_amdkfd_remove_gws_from_process(void *info, void *mem);\nuint32_t amdgpu_amdkfd_get_fw_version(struct amdgpu_device *adev,\n\t\t\t\t      enum kgd_engine_type type);\nvoid amdgpu_amdkfd_get_local_mem_info(struct amdgpu_device *adev,\n\t\t\t\t      struct kfd_local_mem_info *mem_info,\n\t\t\t\t      struct amdgpu_xcp *xcp);\nuint64_t amdgpu_amdkfd_get_gpu_clock_counter(struct amdgpu_device *adev);\n\nuint32_t amdgpu_amdkfd_get_max_engine_clock_in_mhz(struct amdgpu_device *adev);\nvoid amdgpu_amdkfd_get_cu_info(struct amdgpu_device *adev,\n\t\t\t       struct kfd_cu_info *cu_info);\nint amdgpu_amdkfd_get_dmabuf_info(struct amdgpu_device *adev, int dma_buf_fd,\n\t\t\t\t  struct amdgpu_device **dmabuf_adev,\n\t\t\t\t  uint64_t *bo_size, void *metadata_buffer,\n\t\t\t\t  size_t buffer_size, uint32_t *metadata_size,\n\t\t\t\t  uint32_t *flags, int8_t *xcp_id);\nuint8_t amdgpu_amdkfd_get_xgmi_hops_count(struct amdgpu_device *dst,\n\t\t\t\t\t  struct amdgpu_device *src);\nint amdgpu_amdkfd_get_xgmi_bandwidth_mbytes(struct amdgpu_device *dst,\n\t\t\t\t\t    struct amdgpu_device *src,\n\t\t\t\t\t    bool is_min);\nint amdgpu_amdkfd_get_pcie_bandwidth_mbytes(struct amdgpu_device *adev, bool is_min);\nint amdgpu_amdkfd_send_close_event_drain_irq(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t *payload);\nint amdgpu_amdkfd_unmap_hiq(struct amdgpu_device *adev, u32 doorbell_off,\n\t\t\t\tu32 inst);\n\n \n#define read_user_wptr(mmptr, wptr, dst)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tbool valid = false;\t\t\t\t\t\\\n\t\tif ((mmptr) && (wptr)) {\t\t\t\t\\\n\t\t\tpagefault_disable();\t\t\t\t\\\n\t\t\tif ((mmptr) == current->mm) {\t\t\t\\\n\t\t\t\tvalid = !get_user((dst), (wptr));\t\\\n\t\t\t} else if (current->flags & PF_KTHREAD) {\t\\\n\t\t\t\tkthread_use_mm(mmptr);\t\t\t\\\n\t\t\t\tvalid = !get_user((dst), (wptr));\t\\\n\t\t\t\tkthread_unuse_mm(mmptr);\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tpagefault_enable();\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tvalid;\t\t\t\t\t\t\t\\\n\t})\n\n \n#define drm_priv_to_vm(drm_priv)\t\t\t\t\t\\\n\t(&((struct amdgpu_fpriv *)\t\t\t\t\t\\\n\t\t((struct drm_file *)(drm_priv))->driver_priv)->vm)\n\nint amdgpu_amdkfd_gpuvm_set_vm_pasid(struct amdgpu_device *adev,\n\t\t\t\t     struct amdgpu_vm *avm, u32 pasid);\nint amdgpu_amdkfd_gpuvm_acquire_process_vm(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_vm *avm,\n\t\t\t\t\tvoid **process_info,\n\t\t\t\t\tstruct dma_fence **ef);\nvoid amdgpu_amdkfd_gpuvm_release_process_vm(struct amdgpu_device *adev,\n\t\t\t\t\tvoid *drm_priv);\nuint64_t amdgpu_amdkfd_gpuvm_get_process_page_dir(void *drm_priv);\nsize_t amdgpu_amdkfd_get_available_memory(struct amdgpu_device *adev,\n\t\t\t\t\tuint8_t xcp_id);\nint amdgpu_amdkfd_gpuvm_alloc_memory_of_gpu(\n\t\tstruct amdgpu_device *adev, uint64_t va, uint64_t size,\n\t\tvoid *drm_priv, struct kgd_mem **mem,\n\t\tuint64_t *offset, uint32_t flags, bool criu_resume);\nint amdgpu_amdkfd_gpuvm_free_memory_of_gpu(\n\t\tstruct amdgpu_device *adev, struct kgd_mem *mem, void *drm_priv,\n\t\tuint64_t *size);\nint amdgpu_amdkfd_gpuvm_map_memory_to_gpu(struct amdgpu_device *adev,\n\t\t\t\t\t  struct kgd_mem *mem, void *drm_priv);\nint amdgpu_amdkfd_gpuvm_unmap_memory_from_gpu(\n\t\tstruct amdgpu_device *adev, struct kgd_mem *mem, void *drm_priv);\nint amdgpu_amdkfd_gpuvm_sync_memory(\n\t\tstruct amdgpu_device *adev, struct kgd_mem *mem, bool intr);\nint amdgpu_amdkfd_gpuvm_map_gtt_bo_to_kernel(struct kgd_mem *mem,\n\t\t\t\t\t     void **kptr, uint64_t *size);\nvoid amdgpu_amdkfd_gpuvm_unmap_gtt_bo_from_kernel(struct kgd_mem *mem);\n\nint amdgpu_amdkfd_map_gtt_bo_to_gart(struct amdgpu_device *adev, struct amdgpu_bo *bo);\n\nint amdgpu_amdkfd_gpuvm_restore_process_bos(void *process_info,\n\t\t\t\t\t    struct dma_fence **ef);\nint amdgpu_amdkfd_gpuvm_get_vm_fault_info(struct amdgpu_device *adev,\n\t\t\t\t\t      struct kfd_vm_fault_info *info);\nint amdgpu_amdkfd_gpuvm_import_dmabuf(struct amdgpu_device *adev,\n\t\t\t\t      struct dma_buf *dmabuf,\n\t\t\t\t      uint64_t va, void *drm_priv,\n\t\t\t\t      struct kgd_mem **mem, uint64_t *size,\n\t\t\t\t      uint64_t *mmap_offset);\nint amdgpu_amdkfd_gpuvm_export_dmabuf(struct kgd_mem *mem,\n\t\t\t\t      struct dma_buf **dmabuf);\nvoid amdgpu_amdkfd_debug_mem_fence(struct amdgpu_device *adev);\nint amdgpu_amdkfd_get_tile_config(struct amdgpu_device *adev,\n\t\t\t\tstruct tile_config *config);\nvoid amdgpu_amdkfd_ras_poison_consumption_handler(struct amdgpu_device *adev,\n\t\t\t\tbool reset);\nbool amdgpu_amdkfd_bo_mapped_to_dev(struct amdgpu_device *adev, struct kgd_mem *mem);\nvoid amdgpu_amdkfd_block_mmu_notifications(void *p);\nint amdgpu_amdkfd_criu_resume(void *p);\nbool amdgpu_amdkfd_ras_query_utcl2_poison_status(struct amdgpu_device *adev);\nint amdgpu_amdkfd_reserve_mem_limit(struct amdgpu_device *adev,\n\t\tuint64_t size, u32 alloc_flag, int8_t xcp_id);\nvoid amdgpu_amdkfd_unreserve_mem_limit(struct amdgpu_device *adev,\n\t\tuint64_t size, u32 alloc_flag, int8_t xcp_id);\n\nu64 amdgpu_amdkfd_xcp_memory_size(struct amdgpu_device *adev, int xcp_id);\n\n#define KFD_XCP_MEM_ID(adev, xcp_id) \\\n\t\t((adev)->xcp_mgr && (xcp_id) >= 0 ?\\\n\t\t(adev)->xcp_mgr->xcp[(xcp_id)].mem_id : -1)\n\n#define KFD_XCP_MEMORY_SIZE(adev, xcp_id) amdgpu_amdkfd_xcp_memory_size((adev), (xcp_id))\n\n\n#if IS_ENABLED(CONFIG_HSA_AMD)\nvoid amdgpu_amdkfd_gpuvm_init_mem_limits(void);\nvoid amdgpu_amdkfd_gpuvm_destroy_cb(struct amdgpu_device *adev,\n\t\t\t\tstruct amdgpu_vm *vm);\n\n \nvoid amdgpu_amdkfd_release_notify(struct amdgpu_bo *bo);\nvoid amdgpu_amdkfd_reserve_system_mem(uint64_t size);\n#else\nstatic inline\nvoid amdgpu_amdkfd_gpuvm_init_mem_limits(void)\n{\n}\n\nstatic inline\nvoid amdgpu_amdkfd_gpuvm_destroy_cb(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_vm *vm)\n{\n}\n\nstatic inline\nvoid amdgpu_amdkfd_release_notify(struct amdgpu_bo *bo)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_HSA_AMD_SVM)\nint kgd2kfd_init_zone_device(struct amdgpu_device *adev);\n#else\nstatic inline\nint kgd2kfd_init_zone_device(struct amdgpu_device *adev)\n{\n\treturn 0;\n}\n#endif\n\n \nint kgd2kfd_quiesce_mm(struct mm_struct *mm, uint32_t trigger);\nint kgd2kfd_resume_mm(struct mm_struct *mm);\nint kgd2kfd_schedule_evict_and_restore_process(struct mm_struct *mm,\n\t\t\t\t\t\tstruct dma_fence *fence);\n#if IS_ENABLED(CONFIG_HSA_AMD)\nint kgd2kfd_init(void);\nvoid kgd2kfd_exit(void);\nstruct kfd_dev *kgd2kfd_probe(struct amdgpu_device *adev, bool vf);\nbool kgd2kfd_device_init(struct kfd_dev *kfd,\n\t\t\t const struct kgd2kfd_shared_resources *gpu_resources);\nvoid kgd2kfd_device_exit(struct kfd_dev *kfd);\nvoid kgd2kfd_suspend(struct kfd_dev *kfd, bool run_pm);\nint kgd2kfd_resume(struct kfd_dev *kfd, bool run_pm);\nint kgd2kfd_pre_reset(struct kfd_dev *kfd);\nint kgd2kfd_post_reset(struct kfd_dev *kfd);\nvoid kgd2kfd_interrupt(struct kfd_dev *kfd, const void *ih_ring_entry);\nvoid kgd2kfd_set_sram_ecc_flag(struct kfd_dev *kfd);\nvoid kgd2kfd_smi_event_throttle(struct kfd_dev *kfd, uint64_t throttle_bitmask);\nint kgd2kfd_check_and_lock_kfd(void);\nvoid kgd2kfd_unlock_kfd(void);\n#else\nstatic inline int kgd2kfd_init(void)\n{\n\treturn -ENOENT;\n}\n\nstatic inline void kgd2kfd_exit(void)\n{\n}\n\nstatic inline\nstruct kfd_dev *kgd2kfd_probe(struct amdgpu_device *adev, bool vf)\n{\n\treturn NULL;\n}\n\nstatic inline\nbool kgd2kfd_device_init(struct kfd_dev *kfd,\n\t\t\t\tconst struct kgd2kfd_shared_resources *gpu_resources)\n{\n\treturn false;\n}\n\nstatic inline void kgd2kfd_device_exit(struct kfd_dev *kfd)\n{\n}\n\nstatic inline void kgd2kfd_suspend(struct kfd_dev *kfd, bool run_pm)\n{\n}\n\nstatic inline int kgd2kfd_resume(struct kfd_dev *kfd, bool run_pm)\n{\n\treturn 0;\n}\n\nstatic inline int kgd2kfd_pre_reset(struct kfd_dev *kfd)\n{\n\treturn 0;\n}\n\nstatic inline int kgd2kfd_post_reset(struct kfd_dev *kfd)\n{\n\treturn 0;\n}\n\nstatic inline\nvoid kgd2kfd_interrupt(struct kfd_dev *kfd, const void *ih_ring_entry)\n{\n}\n\nstatic inline\nvoid kgd2kfd_set_sram_ecc_flag(struct kfd_dev *kfd)\n{\n}\n\nstatic inline\nvoid kgd2kfd_smi_event_throttle(struct kfd_dev *kfd, uint64_t throttle_bitmask)\n{\n}\n\nstatic inline int kgd2kfd_check_and_lock_kfd(void)\n{\n\treturn 0;\n}\n\nstatic inline void kgd2kfd_unlock_kfd(void)\n{\n}\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}