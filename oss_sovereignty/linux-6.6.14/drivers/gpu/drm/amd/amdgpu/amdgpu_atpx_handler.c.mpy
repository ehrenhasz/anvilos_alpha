{
  "module_name": "amdgpu_atpx_handler.c",
  "hash_id": "115a10685d48378c317f924e86af66d3e24d113654f8afcb0e935a6cff6a3f52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c",
  "human_readable_source": "\n \n#include <linux/vga_switcheroo.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"amdgpu.h\"\n#include \"amd_acpi.h\"\n\n#define AMDGPU_PX_QUIRK_FORCE_ATPX  (1 << 0)\n\nstruct amdgpu_px_quirk {\n\tu32 chip_vendor;\n\tu32 chip_device;\n\tu32 subsys_vendor;\n\tu32 subsys_device;\n\tu32 px_quirk_flags;\n};\n\nstruct amdgpu_atpx_functions {\n\tbool px_params;\n\tbool power_cntl;\n\tbool disp_mux_cntl;\n\tbool i2c_mux_cntl;\n\tbool switch_start;\n\tbool switch_end;\n\tbool disp_connectors_mapping;\n\tbool disp_detection_ports;\n};\n\nstruct amdgpu_atpx {\n\tacpi_handle handle;\n\tstruct amdgpu_atpx_functions functions;\n\tbool is_hybrid;\n\tbool dgpu_req_power_for_displays;\n};\n\nstatic struct amdgpu_atpx_priv {\n\tbool atpx_detected;\n\tbool bridge_pm_usable;\n\tunsigned int quirks;\n\t \n\tacpi_handle dhandle;\n\tacpi_handle other_handle;\n\tstruct amdgpu_atpx atpx;\n} amdgpu_atpx_priv;\n\nstruct atpx_verify_interface {\n\tu16 size;\t\t \n\tu16 version;\t\t \n\tu32 function_bits;\t \n} __packed;\n\nstruct atpx_px_params {\n\tu16 size;\t\t \n\tu32 valid_flags;\t \n\tu32 flags;\t\t \n} __packed;\n\nstruct atpx_power_control {\n\tu16 size;\n\tu8 dgpu_state;\n} __packed;\n\nstruct atpx_mux {\n\tu16 size;\n\tu16 mux;\n} __packed;\n\nbool amdgpu_has_atpx(void)\n{\n\treturn amdgpu_atpx_priv.atpx_detected;\n}\n\nbool amdgpu_has_atpx_dgpu_power_cntl(void)\n{\n\treturn amdgpu_atpx_priv.atpx.functions.power_cntl;\n}\n\nbool amdgpu_is_atpx_hybrid(void)\n{\n\treturn amdgpu_atpx_priv.atpx.is_hybrid;\n}\n\nbool amdgpu_atpx_dgpu_req_power_for_displays(void)\n{\n\treturn amdgpu_atpx_priv.atpx.dgpu_req_power_for_displays;\n}\n\n#if defined(CONFIG_ACPI)\nvoid *amdgpu_atpx_get_dhandle(void)\n{\n\treturn amdgpu_atpx_priv.dhandle;\n}\n#endif\n\n \nstatic union acpi_object *amdgpu_atpx_call(acpi_handle handle, int function,\n\t\t\t\t\t   struct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atpx_arg_elements[2];\n\tstruct acpi_object_list atpx_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatpx_arg.count = 2;\n\tatpx_arg.pointer = &atpx_arg_elements[0];\n\n\tatpx_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatpx_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatpx_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatpx_arg_elements[1].buffer.length = params->length;\n\t\tatpx_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatpx_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatpx_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tpr_err(\"failed to evaluate ATPX got %s\\n\",\n\t\t       acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void amdgpu_atpx_parse_functions(struct amdgpu_atpx_functions *f, u32 mask)\n{\n\tf->px_params = mask & ATPX_GET_PX_PARAMETERS_SUPPORTED;\n\tf->power_cntl = mask & ATPX_POWER_CONTROL_SUPPORTED;\n\tf->disp_mux_cntl = mask & ATPX_DISPLAY_MUX_CONTROL_SUPPORTED;\n\tf->i2c_mux_cntl = mask & ATPX_I2C_MUX_CONTROL_SUPPORTED;\n\tf->switch_start = mask & ATPX_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION_SUPPORTED;\n\tf->switch_end = mask & ATPX_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION_SUPPORTED;\n\tf->disp_connectors_mapping = mask & ATPX_GET_DISPLAY_CONNECTORS_MAPPING_SUPPORTED;\n\tf->disp_detection_ports = mask & ATPX_GET_DISPLAY_DETECTION_PORTS_SUPPORTED;\n}\n\n \nstatic int amdgpu_atpx_validate(struct amdgpu_atpx *atpx)\n{\n\tu32 valid_bits = 0;\n\n\tif (atpx->functions.px_params) {\n\t\tunion acpi_object *info;\n\t\tstruct atpx_px_params output;\n\t\tsize_t size;\n\n\t\tinfo = amdgpu_atpx_call(atpx->handle, ATPX_FUNCTION_GET_PX_PARAMETERS, NULL);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\n\t\tmemset(&output, 0, sizeof(output));\n\n\t\tsize = *(u16 *) info->buffer.pointer;\n\t\tif (size < 10) {\n\t\t\tpr_err(\"ATPX buffer is too small: %zu\\n\", size);\n\t\t\tkfree(info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = min(sizeof(output), size);\n\n\t\tmemcpy(&output, info->buffer.pointer, size);\n\n\t\tvalid_bits = output.flags & output.valid_flags;\n\n\t\tkfree(info);\n\t}\n\n\t \n\tif (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {\n\t\tatpx->functions.i2c_mux_cntl = true;\n\t\tatpx->functions.disp_mux_cntl = true;\n\t}\n\t \n\tif (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |\n\t\t\t  ATPX_TV_SIGNAL_MUXED |\n\t\t\t  ATPX_DFP_SIGNAL_MUXED))\n\t\tatpx->functions.disp_mux_cntl = true;\n\n\n\t \n\tif (valid_bits & (ATPX_DYNAMIC_PX_SUPPORTED |\n\t\t\t  ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED))\n\t\tatpx->functions.power_cntl = true;\n\n\tatpx->is_hybrid = false;\n\tif (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {\n\t\tif (amdgpu_atpx_priv.quirks & AMDGPU_PX_QUIRK_FORCE_ATPX) {\n\t\t\tpr_warn(\"ATPX Hybrid Graphics, forcing to ATPX\\n\");\n\t\t\tatpx->functions.power_cntl = true;\n\t\t\tatpx->is_hybrid = false;\n\t\t} else {\n\t\t\tpr_notice(\"ATPX Hybrid Graphics\\n\");\n\t\t\t \n\t\t\tatpx->functions.power_cntl = !amdgpu_atpx_priv.bridge_pm_usable;\n\t\t\tatpx->is_hybrid = true;\n\t\t}\n\t}\n\n\tatpx->dgpu_req_power_for_displays = false;\n\tif (valid_bits & ATPX_DGPU_REQ_POWER_FOR_DISPLAYS)\n\t\tatpx->dgpu_req_power_for_displays = true;\n\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_verify_interface(struct amdgpu_atpx *atpx)\n{\n\tunion acpi_object *info;\n\tstruct atpx_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = amdgpu_atpx_call(atpx->handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 8) {\n\t\tpr_err(\"ATPX buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tpr_notice(\"ATPX version %u, functions 0x%08x\\n\",\n\t\t  output.version, output.function_bits);\n\n\tamdgpu_atpx_parse_functions(&atpx->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int amdgpu_atpx_set_discrete_state(struct amdgpu_atpx *atpx, u8 state)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_power_control input;\n\n\tif (atpx->functions.power_cntl) {\n\t\tinput.size = 3;\n\t\tinput.dgpu_state = state;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = amdgpu_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_POWER_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\n\t\t \n\t\tif (state == 0)\n\t\t\tmsleep(200);\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_switch_disp_mux(struct amdgpu_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.disp_mux_cntl) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = amdgpu_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_DISPLAY_MUX_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_switch_i2c_mux(struct amdgpu_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.i2c_mux_cntl) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = amdgpu_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_I2C_MUX_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_switch_start(struct amdgpu_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.switch_start) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = amdgpu_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_switch_end(struct amdgpu_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.switch_end) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = amdgpu_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_switchto(enum vga_switcheroo_client_id id)\n{\n\tu16 gpu_id;\n\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\tgpu_id = ATPX_INTEGRATED_GPU;\n\telse\n\t\tgpu_id = ATPX_DISCRETE_GPU;\n\n\tamdgpu_atpx_switch_start(&amdgpu_atpx_priv.atpx, gpu_id);\n\tamdgpu_atpx_switch_disp_mux(&amdgpu_atpx_priv.atpx, gpu_id);\n\tamdgpu_atpx_switch_i2c_mux(&amdgpu_atpx_priv.atpx, gpu_id);\n\tamdgpu_atpx_switch_end(&amdgpu_atpx_priv.atpx, gpu_id);\n\n\treturn 0;\n}\n\n \nstatic int amdgpu_atpx_power_state(enum vga_switcheroo_client_id id,\n\t\t\t\t   enum vga_switcheroo_state state)\n{\n\t \n\tif (id == VGA_SWITCHEROO_IGD)\n\t\treturn 0;\n\n\tamdgpu_atpx_set_discrete_state(&amdgpu_atpx_priv.atpx, state);\n\treturn 0;\n}\n\n \nstatic bool amdgpu_atpx_pci_probe_handle(struct pci_dev *pdev)\n{\n\tacpi_handle dhandle, atpx_handle;\n\tacpi_status status;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn false;\n\n\tstatus = acpi_get_handle(dhandle, \"ATPX\", &atpx_handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tamdgpu_atpx_priv.other_handle = dhandle;\n\t\treturn false;\n\t}\n\tamdgpu_atpx_priv.dhandle = dhandle;\n\tamdgpu_atpx_priv.atpx.handle = atpx_handle;\n\treturn true;\n}\n\n \nstatic int amdgpu_atpx_init(void)\n{\n\tint r;\n\n\t \n\tr = amdgpu_atpx_verify_interface(&amdgpu_atpx_priv.atpx);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_atpx_validate(&amdgpu_atpx_priv.atpx);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic enum vga_switcheroo_client_id amdgpu_atpx_get_client_id(struct pci_dev *pdev)\n{\n\tif (amdgpu_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))\n\t\treturn VGA_SWITCHEROO_IGD;\n\telse\n\t\treturn VGA_SWITCHEROO_DIS;\n}\n\nstatic const struct vga_switcheroo_handler amdgpu_atpx_handler = {\n\t.switchto = amdgpu_atpx_switchto,\n\t.power_state = amdgpu_atpx_power_state,\n\t.get_client_id = amdgpu_atpx_get_client_id,\n};\n\nstatic const struct amdgpu_px_quirk amdgpu_px_quirk_list[] = {\n\t \n\t{ 0x1002, 0x6900, 0x1002, 0x0124, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0x1002, 0x6900, 0x1028, 0x0812, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0x1002, 0x6900, 0x1028, 0x0813, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0x1002, 0x699f, 0x1028, 0x0814, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0x1002, 0x6900, 0x1025, 0x125A, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0x1002, 0x6900, 0x17AA, 0x3806, AMDGPU_PX_QUIRK_FORCE_ATPX },\n\t{ 0, 0, 0, 0, 0 },\n};\n\nstatic void amdgpu_atpx_get_quirks(struct pci_dev *pdev)\n{\n\tconst struct amdgpu_px_quirk *p = amdgpu_px_quirk_list;\n\n\t \n\twhile (p && p->chip_device != 0) {\n\t\tif (pdev->vendor == p->chip_vendor &&\n\t\t    pdev->device == p->chip_device &&\n\t\t    pdev->subsystem_vendor == p->subsys_vendor &&\n\t\t    pdev->subsystem_device == p->subsys_device) {\n\t\t\tamdgpu_atpx_priv.quirks |= p->px_quirk_flags;\n\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n}\n\n \nstatic bool amdgpu_atpx_detect(void)\n{\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\n\tstruct pci_dev *pdev = NULL;\n\tbool has_atpx = false;\n\tint vga_count = 0;\n\tbool d3_supported = false;\n\tstruct pci_dev *parent_pdev;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\thas_atpx |= amdgpu_atpx_pci_probe_handle(pdev);\n\n\t\tparent_pdev = pci_upstream_bridge(pdev);\n\t\td3_supported |= parent_pdev && parent_pdev->bridge_d3;\n\t\tamdgpu_atpx_get_quirks(pdev);\n\t}\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\thas_atpx |= amdgpu_atpx_pci_probe_handle(pdev);\n\n\t\tparent_pdev = pci_upstream_bridge(pdev);\n\t\td3_supported |= parent_pdev && parent_pdev->bridge_d3;\n\t\tamdgpu_atpx_get_quirks(pdev);\n\t}\n\n\tif (has_atpx && vga_count == 2) {\n\t\tacpi_get_name(amdgpu_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);\n\t\tpr_info(\"vga_switcheroo: detected switching method %s handle\\n\",\n\t\t\tacpi_method_name);\n\t\tamdgpu_atpx_priv.atpx_detected = true;\n\t\tamdgpu_atpx_priv.bridge_pm_usable = d3_supported;\n\t\tamdgpu_atpx_init();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid amdgpu_register_atpx_handler(void)\n{\n\tbool r;\n\tenum vga_switcheroo_handler_flags_t handler_flags = 0;\n\n\t \n\tr = amdgpu_atpx_detect();\n\tif (!r)\n\t\treturn;\n\n\tvga_switcheroo_register_handler(&amdgpu_atpx_handler, handler_flags);\n}\n\n \nvoid amdgpu_unregister_atpx_handler(void)\n{\n\tvga_switcheroo_unregister_handler();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}