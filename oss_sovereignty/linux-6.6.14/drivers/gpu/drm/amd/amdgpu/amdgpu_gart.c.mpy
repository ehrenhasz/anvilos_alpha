{
  "module_name": "amdgpu_gart.c",
  "hash_id": "e7286172649f0e381631973b45a73ef5597ccf61295a6be41f3f5c94b317f96c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include <drm/amdgpu_drm.h>\n#ifdef CONFIG_X86\n#include <asm/set_memory.h>\n#endif\n#include \"amdgpu.h\"\n#include <drm/drm_drv.h>\n#include <drm/ttm/ttm_tt.h>\n\n \n\n \n\n \nstatic int amdgpu_gart_dummy_page_init(struct amdgpu_device *adev)\n{\n\tstruct page *dummy_page = ttm_glob.dummy_read_page;\n\n\tif (adev->dummy_page_addr)\n\t\treturn 0;\n\tadev->dummy_page_addr = dma_map_page(&adev->pdev->dev, dummy_page, 0,\n\t\t\t\t\t     PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&adev->pdev->dev, adev->dummy_page_addr)) {\n\t\tdev_err(&adev->pdev->dev, \"Failed to DMA MAP the dummy page\\n\");\n\t\tadev->dummy_page_addr = 0;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nvoid amdgpu_gart_dummy_page_fini(struct amdgpu_device *adev)\n{\n\tif (!adev->dummy_page_addr)\n\t\treturn;\n\tdma_unmap_page(&adev->pdev->dev, adev->dummy_page_addr, PAGE_SIZE,\n\t\t       DMA_BIDIRECTIONAL);\n\tadev->dummy_page_addr = 0;\n}\n\n \nint amdgpu_gart_table_ram_alloc(struct amdgpu_device *adev)\n{\n\tunsigned int order = get_order(adev->gart.table_size);\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO;\n\tstruct amdgpu_bo *bo = NULL;\n\tstruct sg_table *sg = NULL;\n\tstruct amdgpu_bo_param bp;\n\tdma_addr_t dma_addr;\n\tstruct page *p;\n\tint ret;\n\n\tif (adev->gart.bo != NULL)\n\t\treturn 0;\n\n\tp = alloc_pages(gfp_flags, order);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t \n\tdma_addr = dma_map_page(&adev->pdev->dev, p, 0, adev->gart.table_size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&adev->pdev->dev, dma_addr)) {\n\t\tdev_err(&adev->pdev->dev, \"Failed to DMA MAP the GART BO page\\n\");\n\t\t__free_pages(p, order);\n\t\tp = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\tdev_info(adev->dev, \"%s dma_addr:%pad\\n\", __func__, &dma_addr);\n\t \n\tsg = kmalloc(sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tret = sg_alloc_table(sg, 1, GFP_KERNEL);\n\tif (ret)\n\t\tgoto error;\n\n\tsg_dma_address(sg->sgl) = dma_addr;\n\tsg->sgl->length = adev->gart.table_size;\n#ifdef CONFIG_NEED_SG_DMA_LENGTH\n\tsg->sgl->dma_length = adev->gart.table_size;\n#endif\n\t \n\tmemset(&bp, 0, sizeof(bp));\n\tbp.size = adev->gart.table_size;\n\tbp.byte_align = PAGE_SIZE;\n\tbp.domain = AMDGPU_GEM_DOMAIN_CPU;\n\tbp.type = ttm_bo_type_sg;\n\tbp.resv = NULL;\n\tbp.bo_ptr_size = sizeof(struct amdgpu_bo);\n\tbp.flags = 0;\n\tret = amdgpu_bo_create(adev, &bp, &bo);\n\tif (ret)\n\t\tgoto error;\n\n\tbo->tbo.sg = sg;\n\tbo->tbo.ttm->sg = sg;\n\tbo->allowed_domains = AMDGPU_GEM_DOMAIN_GTT;\n\tbo->preferred_domains = AMDGPU_GEM_DOMAIN_GTT;\n\n\tret = amdgpu_bo_reserve(bo, true);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"(%d) failed to reserve bo for GART system bo\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = amdgpu_bo_pin(bo, AMDGPU_GEM_DOMAIN_GTT);\n\tWARN(ret, \"Pinning the GART table failed\");\n\tif (ret)\n\t\tgoto error_resv;\n\n\tadev->gart.bo = bo;\n\tadev->gart.ptr = page_to_virt(p);\n\t \n\tret = amdgpu_ttm_alloc_gart(&adev->gart.bo->tbo);\n\tif (ret)\n\t\tamdgpu_gart_table_ram_free(adev);\n\tamdgpu_bo_unreserve(bo);\n\n\treturn 0;\n\nerror_resv:\n\tamdgpu_bo_unreserve(bo);\nerror:\n\tamdgpu_bo_unref(&bo);\n\tif (sg) {\n\t\tsg_free_table(sg);\n\t\tkfree(sg);\n\t}\n\t__free_pages(p, order);\n\treturn ret;\n}\n\n \nvoid amdgpu_gart_table_ram_free(struct amdgpu_device *adev)\n{\n\tunsigned int order = get_order(adev->gart.table_size);\n\tstruct sg_table *sg = adev->gart.bo->tbo.sg;\n\tstruct page *p;\n\tint ret;\n\n\tret = amdgpu_bo_reserve(adev->gart.bo, false);\n\tif (!ret) {\n\t\tamdgpu_bo_unpin(adev->gart.bo);\n\t\tamdgpu_bo_unreserve(adev->gart.bo);\n\t}\n\tamdgpu_bo_unref(&adev->gart.bo);\n\tsg_free_table(sg);\n\tkfree(sg);\n\tp = virt_to_page(adev->gart.ptr);\n\t__free_pages(p, order);\n\n\tadev->gart.ptr = NULL;\n}\n\n \nint amdgpu_gart_table_vram_alloc(struct amdgpu_device *adev)\n{\n\tif (adev->gart.bo != NULL)\n\t\treturn 0;\n\n\treturn amdgpu_bo_create_kernel(adev,  adev->gart.table_size, PAGE_SIZE,\n\t\t\t\t       AMDGPU_GEM_DOMAIN_VRAM, &adev->gart.bo,\n\t\t\t\t       NULL, (void *)&adev->gart.ptr);\n}\n\n \nvoid amdgpu_gart_table_vram_free(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gart.bo, NULL, (void *)&adev->gart.ptr);\n}\n\n \n \nvoid amdgpu_gart_unbind(struct amdgpu_device *adev, uint64_t offset,\n\t\t\tint pages)\n{\n\tunsigned t;\n\tunsigned p;\n\tint i, j;\n\tu64 page_base;\n\t \n\tuint64_t flags = 0;\n\tint idx;\n\n\tif (!adev->gart.ptr)\n\t\treturn;\n\n\tif (!drm_dev_enter(adev_to_drm(adev), &idx))\n\t\treturn;\n\n\tt = offset / AMDGPU_GPU_PAGE_SIZE;\n\tp = t / AMDGPU_GPU_PAGES_IN_CPU_PAGE;\n\tfor (i = 0; i < pages; i++, p++) {\n\t\tpage_base = adev->dummy_page_addr;\n\t\tif (!adev->gart.ptr)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < AMDGPU_GPU_PAGES_IN_CPU_PAGE; j++, t++) {\n\t\t\tamdgpu_gmc_set_pte_pde(adev, adev->gart.ptr,\n\t\t\t\t\t       t, page_base, flags);\n\t\t\tpage_base += AMDGPU_GPU_PAGE_SIZE;\n\t\t}\n\t}\n\tmb();\n\tamdgpu_device_flush_hdp(adev, NULL);\n\tfor_each_set_bit(i, adev->vmhubs_mask, AMDGPU_MAX_VMHUBS)\n\t\tamdgpu_gmc_flush_gpu_tlb(adev, 0, i, 0);\n\n\tdrm_dev_exit(idx);\n}\n\n \nvoid amdgpu_gart_map(struct amdgpu_device *adev, uint64_t offset,\n\t\t    int pages, dma_addr_t *dma_addr, uint64_t flags,\n\t\t    void *dst)\n{\n\tuint64_t page_base;\n\tunsigned i, j, t;\n\tint idx;\n\n\tif (!drm_dev_enter(adev_to_drm(adev), &idx))\n\t\treturn;\n\n\tt = offset / AMDGPU_GPU_PAGE_SIZE;\n\n\tfor (i = 0; i < pages; i++) {\n\t\tpage_base = dma_addr[i];\n\t\tfor (j = 0; j < AMDGPU_GPU_PAGES_IN_CPU_PAGE; j++, t++) {\n\t\t\tamdgpu_gmc_set_pte_pde(adev, dst, t, page_base, flags);\n\t\t\tpage_base += AMDGPU_GPU_PAGE_SIZE;\n\t\t}\n\t}\n\tdrm_dev_exit(idx);\n}\n\n \nvoid amdgpu_gart_bind(struct amdgpu_device *adev, uint64_t offset,\n\t\t     int pages, dma_addr_t *dma_addr,\n\t\t     uint64_t flags)\n{\n\tif (!adev->gart.ptr)\n\t\treturn;\n\n\tamdgpu_gart_map(adev, offset, pages, dma_addr, flags, adev->gart.ptr);\n}\n\n \nvoid amdgpu_gart_invalidate_tlb(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tif (!adev->gart.ptr)\n\t\treturn;\n\n\tmb();\n\tamdgpu_device_flush_hdp(adev, NULL);\n\tfor_each_set_bit(i, adev->vmhubs_mask, AMDGPU_MAX_VMHUBS)\n\t\tamdgpu_gmc_flush_gpu_tlb(adev, 0, i, 0);\n}\n\n \nint amdgpu_gart_init(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tif (adev->dummy_page_addr)\n\t\treturn 0;\n\n\t \n\tif (PAGE_SIZE < AMDGPU_GPU_PAGE_SIZE) {\n\t\tDRM_ERROR(\"Page size is smaller than GPU page size!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = amdgpu_gart_dummy_page_init(adev);\n\tif (r)\n\t\treturn r;\n\t \n\tadev->gart.num_cpu_pages = adev->gmc.gart_size / PAGE_SIZE;\n\tadev->gart.num_gpu_pages = adev->gmc.gart_size / AMDGPU_GPU_PAGE_SIZE;\n\tDRM_INFO(\"GART: num cpu pages %u, num gpu pages %u\\n\",\n\t\t adev->gart.num_cpu_pages, adev->gart.num_gpu_pages);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}