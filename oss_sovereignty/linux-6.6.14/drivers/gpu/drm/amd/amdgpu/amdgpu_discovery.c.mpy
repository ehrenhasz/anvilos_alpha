{
  "module_name": "amdgpu_discovery.c",
  "hash_id": "cb8c1491acd4764d6fa50d268f6ed74a0b4a59d09bf27679a2dc6a3dcb3b1274",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_discovery.h\"\n#include \"soc15_hw_ip.h\"\n#include \"discovery.h\"\n\n#include \"soc15.h\"\n#include \"gfx_v9_0.h\"\n#include \"gfx_v9_4_3.h\"\n#include \"gmc_v9_0.h\"\n#include \"df_v1_7.h\"\n#include \"df_v3_6.h\"\n#include \"df_v4_3.h\"\n#include \"nbio_v6_1.h\"\n#include \"nbio_v7_0.h\"\n#include \"nbio_v7_4.h\"\n#include \"nbio_v7_9.h\"\n#include \"hdp_v4_0.h\"\n#include \"vega10_ih.h\"\n#include \"vega20_ih.h\"\n#include \"sdma_v4_0.h\"\n#include \"sdma_v4_4_2.h\"\n#include \"uvd_v7_0.h\"\n#include \"vce_v4_0.h\"\n#include \"vcn_v1_0.h\"\n#include \"vcn_v2_5.h\"\n#include \"jpeg_v2_5.h\"\n#include \"smuio_v9_0.h\"\n#include \"gmc_v10_0.h\"\n#include \"gmc_v11_0.h\"\n#include \"gfxhub_v2_0.h\"\n#include \"mmhub_v2_0.h\"\n#include \"nbio_v2_3.h\"\n#include \"nbio_v4_3.h\"\n#include \"nbio_v7_2.h\"\n#include \"nbio_v7_7.h\"\n#include \"hdp_v5_0.h\"\n#include \"hdp_v5_2.h\"\n#include \"hdp_v6_0.h\"\n#include \"nv.h\"\n#include \"soc21.h\"\n#include \"navi10_ih.h\"\n#include \"ih_v6_0.h\"\n#include \"ih_v6_1.h\"\n#include \"gfx_v10_0.h\"\n#include \"gfx_v11_0.h\"\n#include \"sdma_v5_0.h\"\n#include \"sdma_v5_2.h\"\n#include \"sdma_v6_0.h\"\n#include \"lsdma_v6_0.h\"\n#include \"vcn_v2_0.h\"\n#include \"jpeg_v2_0.h\"\n#include \"vcn_v3_0.h\"\n#include \"jpeg_v3_0.h\"\n#include \"vcn_v4_0.h\"\n#include \"jpeg_v4_0.h\"\n#include \"vcn_v4_0_3.h\"\n#include \"jpeg_v4_0_3.h\"\n#include \"amdgpu_vkms.h\"\n#include \"mes_v10_1.h\"\n#include \"mes_v11_0.h\"\n#include \"smuio_v11_0.h\"\n#include \"smuio_v11_0_6.h\"\n#include \"smuio_v13_0.h\"\n#include \"smuio_v13_0_3.h\"\n#include \"smuio_v13_0_6.h\"\n\n#define FIRMWARE_IP_DISCOVERY \"amdgpu/ip_discovery.bin\"\nMODULE_FIRMWARE(FIRMWARE_IP_DISCOVERY);\n\n#define mmRCC_CONFIG_MEMSIZE\t0xde3\n#define mmMP0_SMN_C2PMSG_33\t0x16061\n#define mmMM_INDEX\t\t0x0\n#define mmMM_INDEX_HI\t\t0x6\n#define mmMM_DATA\t\t0x1\n\nstatic const char *hw_id_names[HW_ID_MAX] = {\n\t[MP1_HWID]\t\t= \"MP1\",\n\t[MP2_HWID]\t\t= \"MP2\",\n\t[THM_HWID]\t\t= \"THM\",\n\t[SMUIO_HWID]\t\t= \"SMUIO\",\n\t[FUSE_HWID]\t\t= \"FUSE\",\n\t[CLKA_HWID]\t\t= \"CLKA\",\n\t[PWR_HWID]\t\t= \"PWR\",\n\t[GC_HWID]\t\t= \"GC\",\n\t[UVD_HWID]\t\t= \"UVD\",\n\t[AUDIO_AZ_HWID]\t\t= \"AUDIO_AZ\",\n\t[ACP_HWID]\t\t= \"ACP\",\n\t[DCI_HWID]\t\t= \"DCI\",\n\t[DMU_HWID]\t\t= \"DMU\",\n\t[DCO_HWID]\t\t= \"DCO\",\n\t[DIO_HWID]\t\t= \"DIO\",\n\t[XDMA_HWID]\t\t= \"XDMA\",\n\t[DCEAZ_HWID]\t\t= \"DCEAZ\",\n\t[DAZ_HWID]\t\t= \"DAZ\",\n\t[SDPMUX_HWID]\t\t= \"SDPMUX\",\n\t[NTB_HWID]\t\t= \"NTB\",\n\t[IOHC_HWID]\t\t= \"IOHC\",\n\t[L2IMU_HWID]\t\t= \"L2IMU\",\n\t[VCE_HWID]\t\t= \"VCE\",\n\t[MMHUB_HWID]\t\t= \"MMHUB\",\n\t[ATHUB_HWID]\t\t= \"ATHUB\",\n\t[DBGU_NBIO_HWID]\t= \"DBGU_NBIO\",\n\t[DFX_HWID]\t\t= \"DFX\",\n\t[DBGU0_HWID]\t\t= \"DBGU0\",\n\t[DBGU1_HWID]\t\t= \"DBGU1\",\n\t[OSSSYS_HWID]\t\t= \"OSSSYS\",\n\t[HDP_HWID]\t\t= \"HDP\",\n\t[SDMA0_HWID]\t\t= \"SDMA0\",\n\t[SDMA1_HWID]\t\t= \"SDMA1\",\n\t[SDMA2_HWID]\t\t= \"SDMA2\",\n\t[SDMA3_HWID]\t\t= \"SDMA3\",\n\t[LSDMA_HWID]\t\t= \"LSDMA\",\n\t[ISP_HWID]\t\t= \"ISP\",\n\t[DBGU_IO_HWID]\t\t= \"DBGU_IO\",\n\t[DF_HWID]\t\t= \"DF\",\n\t[CLKB_HWID]\t\t= \"CLKB\",\n\t[FCH_HWID]\t\t= \"FCH\",\n\t[DFX_DAP_HWID]\t\t= \"DFX_DAP\",\n\t[L1IMU_PCIE_HWID]\t= \"L1IMU_PCIE\",\n\t[L1IMU_NBIF_HWID]\t= \"L1IMU_NBIF\",\n\t[L1IMU_IOAGR_HWID]\t= \"L1IMU_IOAGR\",\n\t[L1IMU3_HWID]\t\t= \"L1IMU3\",\n\t[L1IMU4_HWID]\t\t= \"L1IMU4\",\n\t[L1IMU5_HWID]\t\t= \"L1IMU5\",\n\t[L1IMU6_HWID]\t\t= \"L1IMU6\",\n\t[L1IMU7_HWID]\t\t= \"L1IMU7\",\n\t[L1IMU8_HWID]\t\t= \"L1IMU8\",\n\t[L1IMU9_HWID]\t\t= \"L1IMU9\",\n\t[L1IMU10_HWID]\t\t= \"L1IMU10\",\n\t[L1IMU11_HWID]\t\t= \"L1IMU11\",\n\t[L1IMU12_HWID]\t\t= \"L1IMU12\",\n\t[L1IMU13_HWID]\t\t= \"L1IMU13\",\n\t[L1IMU14_HWID]\t\t= \"L1IMU14\",\n\t[L1IMU15_HWID]\t\t= \"L1IMU15\",\n\t[WAFLC_HWID]\t\t= \"WAFLC\",\n\t[FCH_USB_PD_HWID]\t= \"FCH_USB_PD\",\n\t[PCIE_HWID]\t\t= \"PCIE\",\n\t[PCS_HWID]\t\t= \"PCS\",\n\t[DDCL_HWID]\t\t= \"DDCL\",\n\t[SST_HWID]\t\t= \"SST\",\n\t[IOAGR_HWID]\t\t= \"IOAGR\",\n\t[NBIF_HWID]\t\t= \"NBIF\",\n\t[IOAPIC_HWID]\t\t= \"IOAPIC\",\n\t[SYSTEMHUB_HWID]\t= \"SYSTEMHUB\",\n\t[NTBCCP_HWID]\t\t= \"NTBCCP\",\n\t[UMC_HWID]\t\t= \"UMC\",\n\t[SATA_HWID]\t\t= \"SATA\",\n\t[USB_HWID]\t\t= \"USB\",\n\t[CCXSEC_HWID]\t\t= \"CCXSEC\",\n\t[XGMI_HWID]\t\t= \"XGMI\",\n\t[XGBE_HWID]\t\t= \"XGBE\",\n\t[MP0_HWID]\t\t= \"MP0\",\n};\n\nstatic int hw_id_map[MAX_HWIP] = {\n\t[GC_HWIP]\t= GC_HWID,\n\t[HDP_HWIP]\t= HDP_HWID,\n\t[SDMA0_HWIP]\t= SDMA0_HWID,\n\t[SDMA1_HWIP]\t= SDMA1_HWID,\n\t[SDMA2_HWIP]    = SDMA2_HWID,\n\t[SDMA3_HWIP]    = SDMA3_HWID,\n\t[LSDMA_HWIP]    = LSDMA_HWID,\n\t[MMHUB_HWIP]\t= MMHUB_HWID,\n\t[ATHUB_HWIP]\t= ATHUB_HWID,\n\t[NBIO_HWIP]\t= NBIF_HWID,\n\t[MP0_HWIP]\t= MP0_HWID,\n\t[MP1_HWIP]\t= MP1_HWID,\n\t[UVD_HWIP]\t= UVD_HWID,\n\t[VCE_HWIP]\t= VCE_HWID,\n\t[DF_HWIP]\t= DF_HWID,\n\t[DCE_HWIP]\t= DMU_HWID,\n\t[OSSSYS_HWIP]\t= OSSSYS_HWID,\n\t[SMUIO_HWIP]\t= SMUIO_HWID,\n\t[PWR_HWIP]\t= PWR_HWID,\n\t[NBIF_HWIP]\t= NBIF_HWID,\n\t[THM_HWIP]\t= THM_HWID,\n\t[CLK_HWIP]\t= CLKA_HWID,\n\t[UMC_HWIP]\t= UMC_HWID,\n\t[XGMI_HWIP]\t= XGMI_HWID,\n\t[DCI_HWIP]\t= DCI_HWID,\n\t[PCIE_HWIP]\t= PCIE_HWID,\n};\n\nstatic int amdgpu_discovery_read_binary_from_sysmem(struct amdgpu_device *adev, uint8_t *binary)\n{\n\tu64 tmr_offset, tmr_size, pos;\n\tvoid *discv_regn;\n\tint ret;\n\n\tret = amdgpu_acpi_get_tmr_info(adev, &tmr_offset, &tmr_size);\n\tif (ret)\n\t\treturn ret;\n\n\tpos = tmr_offset + tmr_size - DISCOVERY_TMR_OFFSET;\n\n\t \n\tdiscv_regn = memremap(pos, adev->mman.discovery_tmr_size, MEMREMAP_WC);\n\tif (discv_regn) {\n\t\tmemcpy(binary, discv_regn, adev->mman.discovery_tmr_size);\n\t\tmemunmap(discv_regn);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int amdgpu_discovery_read_binary_from_mem(struct amdgpu_device *adev,\n\t\t\t\t\t\t uint8_t *binary)\n{\n\tuint64_t vram_size;\n\tu32 msg;\n\tint i, ret = 0;\n\n\t \n\tif (dev_is_removable(&adev->pdev->dev)) {\n\t\tfor (i = 0; i < 1000; i++) {\n\t\t\tmsg = RREG32(mmMP0_SMN_C2PMSG_33);\n\t\t\tif (msg & 0x80000000)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\t}\n\tvram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) << 20;\n\n\tif (vram_size) {\n\t\tuint64_t pos = vram_size - DISCOVERY_TMR_OFFSET;\n\t\tamdgpu_device_vram_access(adev, pos, (uint32_t *)binary,\n\t\t\t\t\t  adev->mman.discovery_tmr_size, false);\n\t} else {\n\t\tret = amdgpu_discovery_read_binary_from_sysmem(adev, binary);\n\t}\n\n\treturn ret;\n}\n\nstatic int amdgpu_discovery_read_binary_from_file(struct amdgpu_device *adev, uint8_t *binary)\n{\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tint r;\n\n\tswitch (amdgpu_discovery) {\n\tcase 2:\n\t\tfw_name = FIRMWARE_IP_DISCOVERY;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(adev->dev, \"amdgpu_discovery is not set properly\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = request_firmware(&fw, fw_name, adev->dev);\n\tif (r) {\n\t\tdev_err(adev->dev, \"can't load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\treturn r;\n\t}\n\n\tmemcpy((u8 *)binary, (u8 *)fw->data, fw->size);\n\trelease_firmware(fw);\n\n\treturn 0;\n}\n\nstatic uint16_t amdgpu_discovery_calculate_checksum(uint8_t *data, uint32_t size)\n{\n\tuint16_t checksum = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tchecksum += data[i];\n\n\treturn checksum;\n}\n\nstatic inline bool amdgpu_discovery_verify_checksum(uint8_t *data, uint32_t size,\n\t\t\t\t\t\t    uint16_t expected)\n{\n\treturn !!(amdgpu_discovery_calculate_checksum(data, size) == expected);\n}\n\nstatic inline bool amdgpu_discovery_verify_binary_signature(uint8_t *binary)\n{\n\tstruct binary_header *bhdr;\n\tbhdr = (struct binary_header *)binary;\n\n\treturn (le32_to_cpu(bhdr->binary_signature) == BINARY_SIGNATURE);\n}\n\nstatic void amdgpu_discovery_harvest_config_quirk(struct amdgpu_device *adev)\n{\n\t \n\tif ((adev->ip_versions[UVD_HWIP][1] == IP_VERSION(3, 0, 1)) &&\n\t\t(adev->ip_versions[GC_HWIP][0] == IP_VERSION(10, 3, 2))) {\n\t\tswitch (adev->pdev->revision) {\n\t\tcase 0xC1:\n\t\tcase 0xC2:\n\t\tcase 0xC3:\n\t\tcase 0xC5:\n\t\tcase 0xC7:\n\t\tcase 0xCF:\n\t\tcase 0xDF:\n\t\t\tadev->vcn.harvest_config |= AMDGPU_VCN_HARVEST_VCN1;\n\t\t\tadev->vcn.inst_mask &= ~AMDGPU_VCN_HARVEST_VCN1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int amdgpu_discovery_init(struct amdgpu_device *adev)\n{\n\tstruct table_info *info;\n\tstruct binary_header *bhdr;\n\tuint16_t offset;\n\tuint16_t size;\n\tuint16_t checksum;\n\tint r;\n\n\tadev->mman.discovery_tmr_size = DISCOVERY_TMR_SIZE;\n\tadev->mman.discovery_bin = kzalloc(adev->mman.discovery_tmr_size, GFP_KERNEL);\n\tif (!adev->mman.discovery_bin)\n\t\treturn -ENOMEM;\n\n\t \n\tif (amdgpu_discovery == 2) {\n\t\tdev_info(adev->dev, \"use ip discovery information from file\");\n\t\tr = amdgpu_discovery_read_binary_from_file(adev, adev->mman.discovery_bin);\n\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"failed to read ip discovery binary from file\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t} else {\n\t\tr = amdgpu_discovery_read_binary_from_mem(\n\t\t\tadev, adev->mman.discovery_bin);\n\t\tif (r)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (!amdgpu_discovery_verify_binary_signature(adev->mman.discovery_bin)) {\n\t\tdev_err(adev->dev,\n\t\t\t\"get invalid ip discovery binary signature\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\n\toffset = offsetof(struct binary_header, binary_checksum) +\n\t\tsizeof(bhdr->binary_checksum);\n\tsize = le16_to_cpu(bhdr->binary_size) - offset;\n\tchecksum = le16_to_cpu(bhdr->binary_checksum);\n\n\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t      size, checksum)) {\n\t\tdev_err(adev->dev, \"invalid ip discovery binary checksum\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo = &bhdr->table_list[IP_DISCOVERY];\n\toffset = le16_to_cpu(info->offset);\n\tchecksum = le16_to_cpu(info->checksum);\n\n\tif (offset) {\n\t\tstruct ip_discovery_header *ihdr =\n\t\t\t(struct ip_discovery_header *)(adev->mman.discovery_bin + offset);\n\t\tif (le32_to_cpu(ihdr->signature) != DISCOVERY_TABLE_SIGNATURE) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery data table signature\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t\t      le16_to_cpu(ihdr->size), checksum)) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery data table checksum\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo = &bhdr->table_list[GC];\n\toffset = le16_to_cpu(info->offset);\n\tchecksum = le16_to_cpu(info->checksum);\n\n\tif (offset) {\n\t\tstruct gpu_info_header *ghdr =\n\t\t\t(struct gpu_info_header *)(adev->mman.discovery_bin + offset);\n\n\t\tif (le32_to_cpu(ghdr->table_id) != GC_TABLE_ID) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery gc table id\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t\t      le32_to_cpu(ghdr->size), checksum)) {\n\t\t\tdev_err(adev->dev, \"invalid gc data table checksum\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo = &bhdr->table_list[HARVEST_INFO];\n\toffset = le16_to_cpu(info->offset);\n\tchecksum = le16_to_cpu(info->checksum);\n\n\tif (offset) {\n\t\tstruct harvest_info_header *hhdr =\n\t\t\t(struct harvest_info_header *)(adev->mman.discovery_bin + offset);\n\n\t\tif (le32_to_cpu(hhdr->signature) != HARVEST_TABLE_SIGNATURE) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery harvest table signature\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t\t      sizeof(struct harvest_table), checksum)) {\n\t\t\tdev_err(adev->dev, \"invalid harvest data table checksum\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo = &bhdr->table_list[VCN_INFO];\n\toffset = le16_to_cpu(info->offset);\n\tchecksum = le16_to_cpu(info->checksum);\n\n\tif (offset) {\n\t\tstruct vcn_info_header *vhdr =\n\t\t\t(struct vcn_info_header *)(adev->mman.discovery_bin + offset);\n\n\t\tif (le32_to_cpu(vhdr->table_id) != VCN_INFO_TABLE_ID) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery vcn table id\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t\t      le32_to_cpu(vhdr->size_bytes), checksum)) {\n\t\t\tdev_err(adev->dev, \"invalid vcn data table checksum\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo = &bhdr->table_list[MALL_INFO];\n\toffset = le16_to_cpu(info->offset);\n\tchecksum = le16_to_cpu(info->checksum);\n\n\tif (0 && offset) {\n\t\tstruct mall_info_header *mhdr =\n\t\t\t(struct mall_info_header *)(adev->mman.discovery_bin + offset);\n\n\t\tif (le32_to_cpu(mhdr->table_id) != MALL_INFO_TABLE_ID) {\n\t\t\tdev_err(adev->dev, \"invalid ip discovery mall table id\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!amdgpu_discovery_verify_checksum(adev->mman.discovery_bin + offset,\n\t\t\t\t\t\t      le32_to_cpu(mhdr->size_bytes), checksum)) {\n\t\t\tdev_err(adev->dev, \"invalid mall data table checksum\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tkfree(adev->mman.discovery_bin);\n\tadev->mman.discovery_bin = NULL;\n\n\treturn r;\n}\n\nstatic void amdgpu_discovery_sysfs_fini(struct amdgpu_device *adev);\n\nvoid amdgpu_discovery_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_discovery_sysfs_fini(adev);\n\tkfree(adev->mman.discovery_bin);\n\tadev->mman.discovery_bin = NULL;\n}\n\nstatic int amdgpu_discovery_validate_ip(const struct ip_v4 *ip)\n{\n\tif (ip->instance_number >= HWIP_MAX_INSTANCE) {\n\t\tDRM_ERROR(\"Unexpected instance_number (%d) from ip discovery blob\\n\",\n\t\t\t  ip->instance_number);\n\t\treturn -EINVAL;\n\t}\n\tif (le16_to_cpu(ip->hw_id) >= HW_ID_MAX) {\n\t\tDRM_ERROR(\"Unexpected hw_id (%d) from ip discovery blob\\n\",\n\t\t\t  le16_to_cpu(ip->hw_id));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void amdgpu_discovery_read_harvest_bit_per_ip(struct amdgpu_device *adev,\n\t\t\t\t\t\tuint32_t *vcn_harvest_count)\n{\n\tstruct binary_header *bhdr;\n\tstruct ip_discovery_header *ihdr;\n\tstruct die_header *dhdr;\n\tstruct ip_v4 *ip;\n\tuint16_t die_offset, ip_offset, num_dies, num_ips;\n\tint i, j;\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\tihdr = (struct ip_discovery_header *)(adev->mman.discovery_bin +\n\t\t\tle16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));\n\tnum_dies = le16_to_cpu(ihdr->num_dies);\n\n\t \n\tfor (i = 0; i < num_dies; i++) {\n\t\tdie_offset = le16_to_cpu(ihdr->die_info[i].die_offset);\n\t\tdhdr = (struct die_header *)(adev->mman.discovery_bin + die_offset);\n\t\tnum_ips = le16_to_cpu(dhdr->num_ips);\n\t\tip_offset = die_offset + sizeof(*dhdr);\n\n\t\tfor (j = 0; j < num_ips; j++) {\n\t\t\tip = (struct ip_v4 *)(adev->mman.discovery_bin + ip_offset);\n\n\t\t\tif (amdgpu_discovery_validate_ip(ip))\n\t\t\t\tgoto next_ip;\n\n\t\t\tif (le16_to_cpu(ip->variant) == 1) {\n\t\t\t\tswitch (le16_to_cpu(ip->hw_id)) {\n\t\t\t\tcase VCN_HWID:\n\t\t\t\t\t(*vcn_harvest_count)++;\n\t\t\t\t\tif (ip->instance_number == 0) {\n\t\t\t\t\t\tadev->vcn.harvest_config |= AMDGPU_VCN_HARVEST_VCN0;\n\t\t\t\t\t\tadev->vcn.inst_mask &=\n\t\t\t\t\t\t\t~AMDGPU_VCN_HARVEST_VCN0;\n\t\t\t\t\t\tadev->jpeg.inst_mask &=\n\t\t\t\t\t\t\t~AMDGPU_VCN_HARVEST_VCN0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadev->vcn.harvest_config |= AMDGPU_VCN_HARVEST_VCN1;\n\t\t\t\t\t\tadev->vcn.inst_mask &=\n\t\t\t\t\t\t\t~AMDGPU_VCN_HARVEST_VCN1;\n\t\t\t\t\t\tadev->jpeg.inst_mask &=\n\t\t\t\t\t\t\t~AMDGPU_VCN_HARVEST_VCN1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DMU_HWID:\n\t\t\t\t\tadev->harvest_ip_mask |= AMD_HARVEST_IP_DMU_MASK;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nnext_ip:\n\t\t\tif (ihdr->base_addr_64_bit)\n\t\t\t\tip_offset += struct_size(ip, base_address_64, ip->num_base_address);\n\t\t\telse\n\t\t\t\tip_offset += struct_size(ip, base_address, ip->num_base_address);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_discovery_read_from_harvest_table(struct amdgpu_device *adev,\n\t\t\t\t\t\t     uint32_t *vcn_harvest_count,\n\t\t\t\t\t\t     uint32_t *umc_harvest_count)\n{\n\tstruct binary_header *bhdr;\n\tstruct harvest_table *harvest_info;\n\tu16 offset;\n\tint i;\n\tuint32_t umc_harvest_config = 0;\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\toffset = le16_to_cpu(bhdr->table_list[HARVEST_INFO].offset);\n\n\tif (!offset) {\n\t\tdev_err(adev->dev, \"invalid harvest table offset\\n\");\n\t\treturn;\n\t}\n\n\tharvest_info = (struct harvest_table *)(adev->mman.discovery_bin + offset);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (le16_to_cpu(harvest_info->list[i].hw_id) == 0)\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(harvest_info->list[i].hw_id)) {\n\t\tcase VCN_HWID:\n\t\t\t(*vcn_harvest_count)++;\n\t\t\tadev->vcn.harvest_config |=\n\t\t\t\t(1 << harvest_info->list[i].number_instance);\n\t\t\tadev->jpeg.harvest_config |=\n\t\t\t\t(1 << harvest_info->list[i].number_instance);\n\n\t\t\tadev->vcn.inst_mask &=\n\t\t\t\t~(1U << harvest_info->list[i].number_instance);\n\t\t\tadev->jpeg.inst_mask &=\n\t\t\t\t~(1U << harvest_info->list[i].number_instance);\n\t\t\tbreak;\n\t\tcase DMU_HWID:\n\t\t\tadev->harvest_ip_mask |= AMD_HARVEST_IP_DMU_MASK;\n\t\t\tbreak;\n\t\tcase UMC_HWID:\n\t\t\tumc_harvest_config |=\n\t\t\t\t1 << (le16_to_cpu(harvest_info->list[i].number_instance));\n\t\t\t(*umc_harvest_count)++;\n\t\t\tbreak;\n\t\tcase GC_HWID:\n\t\t\tadev->gfx.xcc_mask &=\n\t\t\t\t~(1U << harvest_info->list[i].number_instance);\n\t\t\tbreak;\n\t\tcase SDMA0_HWID:\n\t\t\tadev->sdma.sdma_mask &=\n\t\t\t\t~(1U << harvest_info->list[i].number_instance);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tadev->umc.active_mask = ((1 << adev->umc.node_inst_num) - 1) &\n\t\t\t\t~umc_harvest_config;\n}\n\n \n\nstruct ip_hw_instance {\n\tstruct kobject kobj;  \n\n\tint hw_id;\n\tu8  num_instance;\n\tu8  major, minor, revision;\n\tu8  harvest;\n\n\tint num_base_addresses;\n\tu32 base_addr[];\n};\n\nstruct ip_hw_id {\n\tstruct kset hw_id_kset;   \n\tint hw_id;\n};\n\nstruct ip_die_entry {\n\tstruct kset ip_kset;      \n\tu16 num_ips;\n};\n\n \n\nstruct ip_hw_instance_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct ip_hw_instance *ip_hw_instance, char *buf);\n};\n\nstatic ssize_t hw_id_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->hw_id);\n}\n\nstatic ssize_t num_instance_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->num_instance);\n}\n\nstatic ssize_t major_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->major);\n}\n\nstatic ssize_t minor_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->minor);\n}\n\nstatic ssize_t revision_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->revision);\n}\n\nstatic ssize_t harvest_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%01X\\n\", ip_hw_instance->harvest);\n}\n\nstatic ssize_t num_base_addresses_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_hw_instance->num_base_addresses);\n}\n\nstatic ssize_t base_addr_show(struct ip_hw_instance *ip_hw_instance, char *buf)\n{\n\tssize_t res, at;\n\tint ii;\n\n\tfor (res = at = ii = 0; ii < ip_hw_instance->num_base_addresses; ii++) {\n\t\t \n\t\tif (at + 12 > PAGE_SIZE)\n\t\t\tbreak;\n\t\tres = sysfs_emit_at(buf, at, \"0x%08X\\n\",\n\t\t\t\t    ip_hw_instance->base_addr[ii]);\n\t\tif (res <= 0)\n\t\t\tbreak;\n\t\tat += res;\n\t}\n\n\treturn res < 0 ? res : at;\n}\n\nstatic struct ip_hw_instance_attr ip_hw_attr[] = {\n\t__ATTR_RO(hw_id),\n\t__ATTR_RO(num_instance),\n\t__ATTR_RO(major),\n\t__ATTR_RO(minor),\n\t__ATTR_RO(revision),\n\t__ATTR_RO(harvest),\n\t__ATTR_RO(num_base_addresses),\n\t__ATTR_RO(base_addr),\n};\n\nstatic struct attribute *ip_hw_instance_attrs[ARRAY_SIZE(ip_hw_attr) + 1];\nATTRIBUTE_GROUPS(ip_hw_instance);\n\n#define to_ip_hw_instance(x) container_of(x, struct ip_hw_instance, kobj)\n#define to_ip_hw_instance_attr(x) container_of(x, struct ip_hw_instance_attr, attr)\n\nstatic ssize_t ip_hw_instance_attr_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ip_hw_instance *ip_hw_instance = to_ip_hw_instance(kobj);\n\tstruct ip_hw_instance_attr *ip_hw_attr = to_ip_hw_instance_attr(attr);\n\n\tif (!ip_hw_attr->show)\n\t\treturn -EIO;\n\n\treturn ip_hw_attr->show(ip_hw_instance, buf);\n}\n\nstatic const struct sysfs_ops ip_hw_instance_sysfs_ops = {\n\t.show = ip_hw_instance_attr_show,\n};\n\nstatic void ip_hw_instance_release(struct kobject *kobj)\n{\n\tstruct ip_hw_instance *ip_hw_instance = to_ip_hw_instance(kobj);\n\n\tkfree(ip_hw_instance);\n}\n\nstatic const struct kobj_type ip_hw_instance_ktype = {\n\t.release = ip_hw_instance_release,\n\t.sysfs_ops = &ip_hw_instance_sysfs_ops,\n\t.default_groups = ip_hw_instance_groups,\n};\n\n \n\n#define to_ip_hw_id(x)  container_of(to_kset(x), struct ip_hw_id, hw_id_kset)\n\nstatic void ip_hw_id_release(struct kobject *kobj)\n{\n\tstruct ip_hw_id *ip_hw_id = to_ip_hw_id(kobj);\n\n\tif (!list_empty(&ip_hw_id->hw_id_kset.list))\n\t\tDRM_ERROR(\"ip_hw_id->hw_id_kset is not empty\");\n\tkfree(ip_hw_id);\n}\n\nstatic const struct kobj_type ip_hw_id_ktype = {\n\t.release = ip_hw_id_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\n \n\nstatic void die_kobj_release(struct kobject *kobj);\nstatic void ip_disc_release(struct kobject *kobj);\n\nstruct ip_die_entry_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct ip_die_entry *ip_die_entry, char *buf);\n};\n\n#define to_ip_die_entry_attr(x)  container_of(x, struct ip_die_entry_attribute, attr)\n\nstatic ssize_t num_ips_show(struct ip_die_entry *ip_die_entry, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ip_die_entry->num_ips);\n}\n\n \nstatic struct ip_die_entry_attribute num_ips_attr =\n\t__ATTR_RO(num_ips);\n\nstatic struct attribute *ip_die_entry_attrs[] = {\n\t&num_ips_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ip_die_entry);  \n\n#define to_ip_die_entry(x) container_of(to_kset(x), struct ip_die_entry, ip_kset)\n\nstatic ssize_t ip_die_entry_attr_show(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct ip_die_entry_attribute *ip_die_entry_attr = to_ip_die_entry_attr(attr);\n\tstruct ip_die_entry *ip_die_entry = to_ip_die_entry(kobj);\n\n\tif (!ip_die_entry_attr->show)\n\t\treturn -EIO;\n\n\treturn ip_die_entry_attr->show(ip_die_entry, buf);\n}\n\nstatic void ip_die_entry_release(struct kobject *kobj)\n{\n\tstruct ip_die_entry *ip_die_entry = to_ip_die_entry(kobj);\n\n\tif (!list_empty(&ip_die_entry->ip_kset.list))\n\t\tDRM_ERROR(\"ip_die_entry->ip_kset is not empty\");\n\tkfree(ip_die_entry);\n}\n\nstatic const struct sysfs_ops ip_die_entry_sysfs_ops = {\n\t.show = ip_die_entry_attr_show,\n};\n\nstatic const struct kobj_type ip_die_entry_ktype = {\n\t.release = ip_die_entry_release,\n\t.sysfs_ops = &ip_die_entry_sysfs_ops,\n\t.default_groups = ip_die_entry_groups,\n};\n\nstatic const struct kobj_type die_kobj_ktype = {\n\t.release = die_kobj_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic const struct kobj_type ip_discovery_ktype = {\n\t.release = ip_disc_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstruct ip_discovery_top {\n\tstruct kobject kobj;     \n\tstruct kset die_kset;    \n\tstruct amdgpu_device *adev;\n};\n\nstatic void die_kobj_release(struct kobject *kobj)\n{\n\tstruct ip_discovery_top *ip_top = container_of(to_kset(kobj),\n\t\t\t\t\t\t       struct ip_discovery_top,\n\t\t\t\t\t\t       die_kset);\n\tif (!list_empty(&ip_top->die_kset.list))\n\t\tDRM_ERROR(\"ip_top->die_kset is not empty\");\n}\n\nstatic void ip_disc_release(struct kobject *kobj)\n{\n\tstruct ip_discovery_top *ip_top = container_of(kobj, struct ip_discovery_top,\n\t\t\t\t\t\t       kobj);\n\tstruct amdgpu_device *adev = ip_top->adev;\n\n\tadev->ip_top = NULL;\n\tkfree(ip_top);\n}\n\nstatic uint8_t amdgpu_discovery_get_harvest_info(struct amdgpu_device *adev,\n\t\t\t\t\t\t uint16_t hw_id, uint8_t inst)\n{\n\tuint8_t harvest = 0;\n\n\t \n\tswitch (hw_id) {\n\tcase VCN_HWID:\n\t\tharvest = ((1 << inst) & adev->vcn.inst_mask) == 0;\n\t\tbreak;\n\tcase DMU_HWID:\n\t\tif (adev->harvest_ip_mask & AMD_HARVEST_IP_DMU_MASK)\n\t\t\tharvest = 0x1;\n\t\tbreak;\n\tcase UMC_HWID:\n\t\t \n\t\tbreak;\n\tcase GC_HWID:\n\t\tharvest = ((1 << inst) & adev->gfx.xcc_mask) == 0;\n\t\tbreak;\n\tcase SDMA0_HWID:\n\t\tharvest = ((1 << inst) & adev->sdma.sdma_mask) == 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn harvest;\n}\n\nstatic int amdgpu_discovery_sysfs_ips(struct amdgpu_device *adev,\n\t\t\t\t      struct ip_die_entry *ip_die_entry,\n\t\t\t\t      const size_t _ip_offset, const int num_ips,\n\t\t\t\t      bool reg_base_64)\n{\n\tint ii, jj, kk, res;\n\n\tDRM_DEBUG(\"num_ips:%d\", num_ips);\n\n\t \n\tfor (ii = 0; ii < HW_ID_MAX; ii++) {\n\t\tstruct ip_hw_id *ip_hw_id = NULL;\n\t\tsize_t ip_offset = _ip_offset;\n\n\t\tfor (jj = 0; jj < num_ips; jj++) {\n\t\t\tstruct ip_v4 *ip;\n\t\t\tstruct ip_hw_instance *ip_hw_instance;\n\n\t\t\tip = (struct ip_v4 *)(adev->mman.discovery_bin + ip_offset);\n\t\t\tif (amdgpu_discovery_validate_ip(ip) ||\n\t\t\t    le16_to_cpu(ip->hw_id) != ii)\n\t\t\t\tgoto next_ip;\n\n\t\t\tDRM_DEBUG(\"match:%d @ ip_offset:%zu\", ii, ip_offset);\n\n\t\t\t \n\t\t\tif (!ip_hw_id) {\n\t\t\t\tip_hw_id = kzalloc(sizeof(*ip_hw_id), GFP_KERNEL);\n\t\t\t\tif (!ip_hw_id)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tip_hw_id->hw_id = ii;\n\n\t\t\t\tkobject_set_name(&ip_hw_id->hw_id_kset.kobj, \"%d\", ii);\n\t\t\t\tip_hw_id->hw_id_kset.kobj.kset = &ip_die_entry->ip_kset;\n\t\t\t\tip_hw_id->hw_id_kset.kobj.ktype = &ip_hw_id_ktype;\n\t\t\t\tres = kset_register(&ip_hw_id->hw_id_kset);\n\t\t\t\tif (res) {\n\t\t\t\t\tDRM_ERROR(\"Couldn't register ip_hw_id kset\");\n\t\t\t\t\tkfree(ip_hw_id);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tif (hw_id_names[ii]) {\n\t\t\t\t\tres = sysfs_create_link(&ip_die_entry->ip_kset.kobj,\n\t\t\t\t\t\t\t\t&ip_hw_id->hw_id_kset.kobj,\n\t\t\t\t\t\t\t\thw_id_names[ii]);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tDRM_ERROR(\"Couldn't create IP link %s in IP Die:%s\\n\",\n\t\t\t\t\t\t\t  hw_id_names[ii],\n\t\t\t\t\t\t\t  kobject_name(&ip_die_entry->ip_kset.kobj));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tip_hw_instance = kzalloc(struct_size(ip_hw_instance,\n\t\t\t\t\t\t\t     base_addr,\n\t\t\t\t\t\t\t     ip->num_base_address),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!ip_hw_instance) {\n\t\t\t\tDRM_ERROR(\"no memory for ip_hw_instance\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tip_hw_instance->hw_id = le16_to_cpu(ip->hw_id);  \n\t\t\tip_hw_instance->num_instance = ip->instance_number;\n\t\t\tip_hw_instance->major = ip->major;\n\t\t\tip_hw_instance->minor = ip->minor;\n\t\t\tip_hw_instance->revision = ip->revision;\n\t\t\tip_hw_instance->harvest =\n\t\t\t\tamdgpu_discovery_get_harvest_info(\n\t\t\t\t\tadev, ip_hw_instance->hw_id,\n\t\t\t\t\tip_hw_instance->num_instance);\n\t\t\tip_hw_instance->num_base_addresses = ip->num_base_address;\n\n\t\t\tfor (kk = 0; kk < ip_hw_instance->num_base_addresses; kk++) {\n\t\t\t\tif (reg_base_64)\n\t\t\t\t\tip_hw_instance->base_addr[kk] =\n\t\t\t\t\t\tlower_32_bits(le64_to_cpu(ip->base_address_64[kk])) & 0x3FFFFFFF;\n\t\t\t\telse\n\t\t\t\t\tip_hw_instance->base_addr[kk] = ip->base_address[kk];\n\t\t\t}\n\n\t\t\tkobject_init(&ip_hw_instance->kobj, &ip_hw_instance_ktype);\n\t\t\tip_hw_instance->kobj.kset = &ip_hw_id->hw_id_kset;\n\t\t\tres = kobject_add(&ip_hw_instance->kobj, NULL,\n\t\t\t\t\t  \"%d\", ip_hw_instance->num_instance);\nnext_ip:\n\t\t\tif (reg_base_64)\n\t\t\t\tip_offset += struct_size(ip, base_address_64,\n\t\t\t\t\t\t\t ip->num_base_address);\n\t\t\telse\n\t\t\t\tip_offset += struct_size(ip, base_address,\n\t\t\t\t\t\t\t ip->num_base_address);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_sysfs_recurse(struct amdgpu_device *adev)\n{\n\tstruct binary_header *bhdr;\n\tstruct ip_discovery_header *ihdr;\n\tstruct die_header *dhdr;\n\tstruct kset *die_kset = &adev->ip_top->die_kset;\n\tu16 num_dies, die_offset, num_ips;\n\tsize_t ip_offset;\n\tint ii, res;\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\tihdr = (struct ip_discovery_header *)(adev->mman.discovery_bin +\n\t\t\t\t\t      le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));\n\tnum_dies = le16_to_cpu(ihdr->num_dies);\n\n\tDRM_DEBUG(\"number of dies: %d\\n\", num_dies);\n\n\tfor (ii = 0; ii < num_dies; ii++) {\n\t\tstruct ip_die_entry *ip_die_entry;\n\n\t\tdie_offset = le16_to_cpu(ihdr->die_info[ii].die_offset);\n\t\tdhdr = (struct die_header *)(adev->mman.discovery_bin + die_offset);\n\t\tnum_ips = le16_to_cpu(dhdr->num_ips);\n\t\tip_offset = die_offset + sizeof(*dhdr);\n\n\t\t \n\n\t\tip_die_entry = kzalloc(sizeof(*ip_die_entry), GFP_KERNEL);\n\t\tif (!ip_die_entry)\n\t\t\treturn -ENOMEM;\n\n\t\tip_die_entry->num_ips = num_ips;\n\n\t\tkobject_set_name(&ip_die_entry->ip_kset.kobj, \"%d\", le16_to_cpu(dhdr->die_id));\n\t\tip_die_entry->ip_kset.kobj.kset = die_kset;\n\t\tip_die_entry->ip_kset.kobj.ktype = &ip_die_entry_ktype;\n\t\tres = kset_register(&ip_die_entry->ip_kset);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Couldn't register ip_die_entry kset\");\n\t\t\tkfree(ip_die_entry);\n\t\t\treturn res;\n\t\t}\n\n\t\tamdgpu_discovery_sysfs_ips(adev, ip_die_entry, ip_offset, num_ips, !!ihdr->base_addr_64_bit);\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_sysfs_init(struct amdgpu_device *adev)\n{\n\tstruct kset *die_kset;\n\tint res, ii;\n\n\tif (!adev->mman.discovery_bin)\n\t\treturn -EINVAL;\n\n\tadev->ip_top = kzalloc(sizeof(*adev->ip_top), GFP_KERNEL);\n\tif (!adev->ip_top)\n\t\treturn -ENOMEM;\n\n\tadev->ip_top->adev = adev;\n\n\tres = kobject_init_and_add(&adev->ip_top->kobj, &ip_discovery_ktype,\n\t\t\t\t   &adev->dev->kobj, \"ip_discovery\");\n\tif (res) {\n\t\tDRM_ERROR(\"Couldn't init and add ip_discovery/\");\n\t\tgoto Err;\n\t}\n\n\tdie_kset = &adev->ip_top->die_kset;\n\tkobject_set_name(&die_kset->kobj, \"%s\", \"die\");\n\tdie_kset->kobj.parent = &adev->ip_top->kobj;\n\tdie_kset->kobj.ktype = &die_kobj_ktype;\n\tres = kset_register(&adev->ip_top->die_kset);\n\tif (res) {\n\t\tDRM_ERROR(\"Couldn't register die_kset\");\n\t\tgoto Err;\n\t}\n\n\tfor (ii = 0; ii < ARRAY_SIZE(ip_hw_attr); ii++)\n\t\tip_hw_instance_attrs[ii] = &ip_hw_attr[ii].attr;\n\tip_hw_instance_attrs[ii] = NULL;\n\n\tres = amdgpu_discovery_sysfs_recurse(adev);\n\n\treturn res;\nErr:\n\tkobject_put(&adev->ip_top->kobj);\n\treturn res;\n}\n\n \n\n#define list_to_kobj(el) container_of(el, struct kobject, entry)\n\nstatic void amdgpu_discovery_sysfs_ip_hw_free(struct ip_hw_id *ip_hw_id)\n{\n\tstruct list_head *el, *tmp;\n\tstruct kset *hw_id_kset;\n\n\thw_id_kset = &ip_hw_id->hw_id_kset;\n\tspin_lock(&hw_id_kset->list_lock);\n\tlist_for_each_prev_safe(el, tmp, &hw_id_kset->list) {\n\t\tlist_del_init(el);\n\t\tspin_unlock(&hw_id_kset->list_lock);\n\t\t \n\t\tkobject_put(list_to_kobj(el));\n\t\tspin_lock(&hw_id_kset->list_lock);\n\t}\n\tspin_unlock(&hw_id_kset->list_lock);\n\tkobject_put(&ip_hw_id->hw_id_kset.kobj);\n}\n\nstatic void amdgpu_discovery_sysfs_die_free(struct ip_die_entry *ip_die_entry)\n{\n\tstruct list_head *el, *tmp;\n\tstruct kset *ip_kset;\n\n\tip_kset = &ip_die_entry->ip_kset;\n\tspin_lock(&ip_kset->list_lock);\n\tlist_for_each_prev_safe(el, tmp, &ip_kset->list) {\n\t\tlist_del_init(el);\n\t\tspin_unlock(&ip_kset->list_lock);\n\t\tamdgpu_discovery_sysfs_ip_hw_free(to_ip_hw_id(list_to_kobj(el)));\n\t\tspin_lock(&ip_kset->list_lock);\n\t}\n\tspin_unlock(&ip_kset->list_lock);\n\tkobject_put(&ip_die_entry->ip_kset.kobj);\n}\n\nstatic void amdgpu_discovery_sysfs_fini(struct amdgpu_device *adev)\n{\n\tstruct list_head *el, *tmp;\n\tstruct kset *die_kset;\n\n\tdie_kset = &adev->ip_top->die_kset;\n\tspin_lock(&die_kset->list_lock);\n\tlist_for_each_prev_safe(el, tmp, &die_kset->list) {\n\t\tlist_del_init(el);\n\t\tspin_unlock(&die_kset->list_lock);\n\t\tamdgpu_discovery_sysfs_die_free(to_ip_die_entry(list_to_kobj(el)));\n\t\tspin_lock(&die_kset->list_lock);\n\t}\n\tspin_unlock(&die_kset->list_lock);\n\tkobject_put(&adev->ip_top->die_kset.kobj);\n\tkobject_put(&adev->ip_top->kobj);\n}\n\n \n\nstatic int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)\n{\n\tstruct binary_header *bhdr;\n\tstruct ip_discovery_header *ihdr;\n\tstruct die_header *dhdr;\n\tstruct ip_v4 *ip;\n\tuint16_t die_offset;\n\tuint16_t ip_offset;\n\tuint16_t num_dies;\n\tuint16_t num_ips;\n\tuint8_t num_base_address;\n\tint hw_ip;\n\tint i, j, k;\n\tint r;\n\n\tr = amdgpu_discovery_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu_discovery_init failed\\n\");\n\t\treturn r;\n\t}\n\n\tadev->gfx.xcc_mask = 0;\n\tadev->sdma.sdma_mask = 0;\n\tadev->vcn.inst_mask = 0;\n\tadev->jpeg.inst_mask = 0;\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\tihdr = (struct ip_discovery_header *)(adev->mman.discovery_bin +\n\t\t\tle16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));\n\tnum_dies = le16_to_cpu(ihdr->num_dies);\n\n\tDRM_DEBUG(\"number of dies: %d\\n\", num_dies);\n\n\tfor (i = 0; i < num_dies; i++) {\n\t\tdie_offset = le16_to_cpu(ihdr->die_info[i].die_offset);\n\t\tdhdr = (struct die_header *)(adev->mman.discovery_bin + die_offset);\n\t\tnum_ips = le16_to_cpu(dhdr->num_ips);\n\t\tip_offset = die_offset + sizeof(*dhdr);\n\n\t\tif (le16_to_cpu(dhdr->die_id) != i) {\n\t\t\tDRM_ERROR(\"invalid die id %d, expected %d\\n\",\n\t\t\t\t\tle16_to_cpu(dhdr->die_id), i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tDRM_DEBUG(\"number of hardware IPs on die%d: %d\\n\",\n\t\t\t\tle16_to_cpu(dhdr->die_id), num_ips);\n\n\t\tfor (j = 0; j < num_ips; j++) {\n\t\t\tip = (struct ip_v4 *)(adev->mman.discovery_bin + ip_offset);\n\n\t\t\tif (amdgpu_discovery_validate_ip(ip))\n\t\t\t\tgoto next_ip;\n\n\t\t\tnum_base_address = ip->num_base_address;\n\n\t\t\tDRM_DEBUG(\"%s(%d) #%d v%d.%d.%d:\\n\",\n\t\t\t\t  hw_id_names[le16_to_cpu(ip->hw_id)],\n\t\t\t\t  le16_to_cpu(ip->hw_id),\n\t\t\t\t  ip->instance_number,\n\t\t\t\t  ip->major, ip->minor,\n\t\t\t\t  ip->revision);\n\n\t\t\tif (le16_to_cpu(ip->hw_id) == VCN_HWID) {\n\t\t\t\t \n\t\t\t\tadev->vcn.vcn_config[adev->vcn.num_vcn_inst] =\n\t\t\t\t\tip->revision & 0xc0;\n\t\t\t\tip->revision &= ~0xc0;\n\t\t\t\tif (adev->vcn.num_vcn_inst <\n\t\t\t\t    AMDGPU_MAX_VCN_INSTANCES) {\n\t\t\t\t\tadev->vcn.num_vcn_inst++;\n\t\t\t\t\tadev->vcn.inst_mask |=\n\t\t\t\t\t\t(1U << ip->instance_number);\n\t\t\t\t\tadev->jpeg.inst_mask |=\n\t\t\t\t\t\t(1U << ip->instance_number);\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(adev->dev, \"Too many VCN instances: %d vs %d\\n\",\n\t\t\t\t\t\tadev->vcn.num_vcn_inst + 1,\n\t\t\t\t\t\tAMDGPU_MAX_VCN_INSTANCES);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(ip->hw_id) == SDMA0_HWID ||\n\t\t\t    le16_to_cpu(ip->hw_id) == SDMA1_HWID ||\n\t\t\t    le16_to_cpu(ip->hw_id) == SDMA2_HWID ||\n\t\t\t    le16_to_cpu(ip->hw_id) == SDMA3_HWID) {\n\t\t\t\tif (adev->sdma.num_instances <\n\t\t\t\t    AMDGPU_MAX_SDMA_INSTANCES) {\n\t\t\t\t\tadev->sdma.num_instances++;\n\t\t\t\t\tadev->sdma.sdma_mask |=\n\t\t\t\t\t\t(1U << ip->instance_number);\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(adev->dev, \"Too many SDMA instances: %d vs %d\\n\",\n\t\t\t\t\t\tadev->sdma.num_instances + 1,\n\t\t\t\t\t\tAMDGPU_MAX_SDMA_INSTANCES);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (le16_to_cpu(ip->hw_id) == UMC_HWID) {\n\t\t\t\tadev->gmc.num_umc++;\n\t\t\t\tadev->umc.node_inst_num++;\n\t\t\t}\n\n\t\t\tif (le16_to_cpu(ip->hw_id) == GC_HWID)\n\t\t\t\tadev->gfx.xcc_mask |=\n\t\t\t\t\t(1U << ip->instance_number);\n\n\t\t\tfor (k = 0; k < num_base_address; k++) {\n\t\t\t\t \n\t\t\t\tif (ihdr->base_addr_64_bit)\n\t\t\t\t\t \n\t\t\t\t\tip->base_address[k] =\n\t\t\t\t\t\tlower_32_bits(le64_to_cpu(ip->base_address_64[k])) & 0x3FFFFFFF;\n\t\t\t\telse\n\t\t\t\t\tip->base_address[k] = le32_to_cpu(ip->base_address[k]);\n\t\t\t\tDRM_DEBUG(\"\\t0x%08x\\n\", ip->base_address[k]);\n\t\t\t}\n\n\t\t\tfor (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {\n\t\t\t\tif (hw_id_map[hw_ip] == le16_to_cpu(ip->hw_id) &&\n\t\t\t\t    hw_id_map[hw_ip] != 0) {\n\t\t\t\t\tDRM_DEBUG(\"set register base offset for %s\\n\",\n\t\t\t\t\t\t\thw_id_names[le16_to_cpu(ip->hw_id)]);\n\t\t\t\t\tadev->reg_offset[hw_ip][ip->instance_number] =\n\t\t\t\t\t\tip->base_address;\n\t\t\t\t\t \n\t\t\t\t\tadev->ip_versions[hw_ip][ip->instance_number] =\n\t\t\t\t\t\tIP_VERSION(ip->major, ip->minor, ip->revision);\n\t\t\t\t}\n\t\t\t}\n\nnext_ip:\n\t\t\tif (ihdr->base_addr_64_bit)\n\t\t\t\tip_offset += struct_size(ip, base_address_64, ip->num_base_address);\n\t\t\telse\n\t\t\t\tip_offset += struct_size(ip, base_address, ip->num_base_address);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void amdgpu_discovery_harvest_ip(struct amdgpu_device *adev)\n{\n\tint vcn_harvest_count = 0;\n\tint umc_harvest_count = 0;\n\n\t \n\tif (adev->ip_versions[GC_HWIP][0] < IP_VERSION(10, 2, 0) &&\n\t    adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 3)) {\n\t\tif ((adev->pdev->device == 0x731E &&\n\t\t\t(adev->pdev->revision == 0xC6 ||\n\t\t\t adev->pdev->revision == 0xC7)) ||\n\t\t\t(adev->pdev->device == 0x7340 &&\n\t\t\t adev->pdev->revision == 0xC9) ||\n\t\t\t(adev->pdev->device == 0x7360 &&\n\t\t\t adev->pdev->revision == 0xC7))\n\t\t\tamdgpu_discovery_read_harvest_bit_per_ip(adev,\n\t\t\t\t&vcn_harvest_count);\n\t} else {\n\t\tamdgpu_discovery_read_from_harvest_table(adev,\n\t\t\t\t\t\t\t &vcn_harvest_count,\n\t\t\t\t\t\t\t &umc_harvest_count);\n\t}\n\n\tamdgpu_discovery_harvest_config_quirk(adev);\n\n\tif (vcn_harvest_count == adev->vcn.num_vcn_inst) {\n\t\tadev->harvest_ip_mask |= AMD_HARVEST_IP_VCN_MASK;\n\t\tadev->harvest_ip_mask |= AMD_HARVEST_IP_JPEG_MASK;\n\t}\n\n\tif (umc_harvest_count < adev->gmc.num_umc) {\n\t\tadev->gmc.num_umc -= umc_harvest_count;\n\t}\n}\n\nunion gc_info {\n\tstruct gc_info_v1_0 v1;\n\tstruct gc_info_v1_1 v1_1;\n\tstruct gc_info_v1_2 v1_2;\n\tstruct gc_info_v2_0 v2;\n\tstruct gc_info_v2_1 v2_1;\n};\n\nstatic int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)\n{\n\tstruct binary_header *bhdr;\n\tunion gc_info *gc_info;\n\tu16 offset;\n\n\tif (!adev->mman.discovery_bin) {\n\t\tDRM_ERROR(\"ip discovery uninitialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\toffset = le16_to_cpu(bhdr->table_list[GC].offset);\n\n\tif (!offset)\n\t\treturn 0;\n\n\tgc_info = (union gc_info *)(adev->mman.discovery_bin + offset);\n\n\tswitch (le16_to_cpu(gc_info->v1.header.version_major)) {\n\tcase 1:\n\t\tadev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->v1.gc_num_se);\n\t\tadev->gfx.config.max_cu_per_sh = 2 * (le32_to_cpu(gc_info->v1.gc_num_wgp0_per_sa) +\n\t\t\t\t\t\t      le32_to_cpu(gc_info->v1.gc_num_wgp1_per_sa));\n\t\tadev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->v1.gc_num_sa_per_se);\n\t\tadev->gfx.config.max_backends_per_se = le32_to_cpu(gc_info->v1.gc_num_rb_per_se);\n\t\tadev->gfx.config.max_texture_channel_caches = le32_to_cpu(gc_info->v1.gc_num_gl2c);\n\t\tadev->gfx.config.max_gprs = le32_to_cpu(gc_info->v1.gc_num_gprs);\n\t\tadev->gfx.config.max_gs_threads = le32_to_cpu(gc_info->v1.gc_num_max_gs_thds);\n\t\tadev->gfx.config.gs_vgt_table_depth = le32_to_cpu(gc_info->v1.gc_gs_table_depth);\n\t\tadev->gfx.config.gs_prim_buffer_depth = le32_to_cpu(gc_info->v1.gc_gsprim_buff_depth);\n\t\tadev->gfx.config.double_offchip_lds_buf = le32_to_cpu(gc_info->v1.gc_double_offchip_lds_buffer);\n\t\tadev->gfx.cu_info.wave_front_size = le32_to_cpu(gc_info->v1.gc_wave_size);\n\t\tadev->gfx.cu_info.max_waves_per_simd = le32_to_cpu(gc_info->v1.gc_max_waves_per_simd);\n\t\tadev->gfx.cu_info.max_scratch_slots_per_cu = le32_to_cpu(gc_info->v1.gc_max_scratch_slots_per_cu);\n\t\tadev->gfx.cu_info.lds_size = le32_to_cpu(gc_info->v1.gc_lds_size);\n\t\tadev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->v1.gc_num_sc_per_se) /\n\t\t\tle32_to_cpu(gc_info->v1.gc_num_sa_per_se);\n\t\tadev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->v1.gc_num_packer_per_sc);\n\t\tif (gc_info->v1.header.version_minor >= 1) {\n\t\t\tadev->gfx.config.gc_num_tcp_per_sa = le32_to_cpu(gc_info->v1_1.gc_num_tcp_per_sa);\n\t\t\tadev->gfx.config.gc_num_sdp_interface = le32_to_cpu(gc_info->v1_1.gc_num_sdp_interface);\n\t\t\tadev->gfx.config.gc_num_tcps = le32_to_cpu(gc_info->v1_1.gc_num_tcps);\n\t\t}\n\t\tif (gc_info->v1.header.version_minor >= 2) {\n\t\t\tadev->gfx.config.gc_num_tcp_per_wpg = le32_to_cpu(gc_info->v1_2.gc_num_tcp_per_wpg);\n\t\t\tadev->gfx.config.gc_tcp_l1_size = le32_to_cpu(gc_info->v1_2.gc_tcp_l1_size);\n\t\t\tadev->gfx.config.gc_num_sqc_per_wgp = le32_to_cpu(gc_info->v1_2.gc_num_sqc_per_wgp);\n\t\t\tadev->gfx.config.gc_l1_instruction_cache_size_per_sqc = le32_to_cpu(gc_info->v1_2.gc_l1_instruction_cache_size_per_sqc);\n\t\t\tadev->gfx.config.gc_l1_data_cache_size_per_sqc = le32_to_cpu(gc_info->v1_2.gc_l1_data_cache_size_per_sqc);\n\t\t\tadev->gfx.config.gc_gl1c_per_sa = le32_to_cpu(gc_info->v1_2.gc_gl1c_per_sa);\n\t\t\tadev->gfx.config.gc_gl1c_size_per_instance = le32_to_cpu(gc_info->v1_2.gc_gl1c_size_per_instance);\n\t\t\tadev->gfx.config.gc_gl2c_per_gpu = le32_to_cpu(gc_info->v1_2.gc_gl2c_per_gpu);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tadev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->v2.gc_num_se);\n\t\tadev->gfx.config.max_cu_per_sh = le32_to_cpu(gc_info->v2.gc_num_cu_per_sh);\n\t\tadev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->v2.gc_num_sh_per_se);\n\t\tadev->gfx.config.max_backends_per_se = le32_to_cpu(gc_info->v2.gc_num_rb_per_se);\n\t\tadev->gfx.config.max_texture_channel_caches = le32_to_cpu(gc_info->v2.gc_num_tccs);\n\t\tadev->gfx.config.max_gprs = le32_to_cpu(gc_info->v2.gc_num_gprs);\n\t\tadev->gfx.config.max_gs_threads = le32_to_cpu(gc_info->v2.gc_num_max_gs_thds);\n\t\tadev->gfx.config.gs_vgt_table_depth = le32_to_cpu(gc_info->v2.gc_gs_table_depth);\n\t\tadev->gfx.config.gs_prim_buffer_depth = le32_to_cpu(gc_info->v2.gc_gsprim_buff_depth);\n\t\tadev->gfx.config.double_offchip_lds_buf = le32_to_cpu(gc_info->v2.gc_double_offchip_lds_buffer);\n\t\tadev->gfx.cu_info.wave_front_size = le32_to_cpu(gc_info->v2.gc_wave_size);\n\t\tadev->gfx.cu_info.max_waves_per_simd = le32_to_cpu(gc_info->v2.gc_max_waves_per_simd);\n\t\tadev->gfx.cu_info.max_scratch_slots_per_cu = le32_to_cpu(gc_info->v2.gc_max_scratch_slots_per_cu);\n\t\tadev->gfx.cu_info.lds_size = le32_to_cpu(gc_info->v2.gc_lds_size);\n\t\tadev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->v2.gc_num_sc_per_se) /\n\t\t\tle32_to_cpu(gc_info->v2.gc_num_sh_per_se);\n\t\tadev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->v2.gc_num_packer_per_sc);\n\t\tif (gc_info->v2.header.version_minor == 1) {\n\t\t\tadev->gfx.config.gc_num_tcp_per_sa = le32_to_cpu(gc_info->v2_1.gc_num_tcp_per_sh);\n\t\t\tadev->gfx.config.gc_tcp_size_per_cu = le32_to_cpu(gc_info->v2_1.gc_tcp_size_per_cu);\n\t\t\tadev->gfx.config.gc_num_sdp_interface = le32_to_cpu(gc_info->v2_1.gc_num_sdp_interface);  \n\t\t\tadev->gfx.config.gc_num_cu_per_sqc = le32_to_cpu(gc_info->v2_1.gc_num_cu_per_sqc);\n\t\t\tadev->gfx.config.gc_l1_instruction_cache_size_per_sqc = le32_to_cpu(gc_info->v2_1.gc_instruction_cache_size_per_sqc);\n\t\t\tadev->gfx.config.gc_l1_data_cache_size_per_sqc = le32_to_cpu(gc_info->v2_1.gc_scalar_data_cache_size_per_sqc);\n\t\t\tadev->gfx.config.gc_tcc_size = le32_to_cpu(gc_info->v2_1.gc_tcc_size);  \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Unhandled GC info table %d.%d\\n\",\n\t\t\tle16_to_cpu(gc_info->v1.header.version_major),\n\t\t\tle16_to_cpu(gc_info->v1.header.version_minor));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nunion mall_info {\n\tstruct mall_info_v1_0 v1;\n\tstruct mall_info_v2_0 v2;\n};\n\nstatic int amdgpu_discovery_get_mall_info(struct amdgpu_device *adev)\n{\n\tstruct binary_header *bhdr;\n\tunion mall_info *mall_info;\n\tu32 u, mall_size_per_umc, m_s_present, half_use;\n\tu64 mall_size;\n\tu16 offset;\n\n\tif (!adev->mman.discovery_bin) {\n\t\tDRM_ERROR(\"ip discovery uninitialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\toffset = le16_to_cpu(bhdr->table_list[MALL_INFO].offset);\n\n\tif (!offset)\n\t\treturn 0;\n\n\tmall_info = (union mall_info *)(adev->mman.discovery_bin + offset);\n\n\tswitch (le16_to_cpu(mall_info->v1.header.version_major)) {\n\tcase 1:\n\t\tmall_size = 0;\n\t\tmall_size_per_umc = le32_to_cpu(mall_info->v1.mall_size_per_m);\n\t\tm_s_present = le32_to_cpu(mall_info->v1.m_s_present);\n\t\thalf_use = le32_to_cpu(mall_info->v1.m_half_use);\n\t\tfor (u = 0; u < adev->gmc.num_umc; u++) {\n\t\t\tif (m_s_present & (1 << u))\n\t\t\t\tmall_size += mall_size_per_umc * 2;\n\t\t\telse if (half_use & (1 << u))\n\t\t\t\tmall_size += mall_size_per_umc / 2;\n\t\t\telse\n\t\t\t\tmall_size += mall_size_per_umc;\n\t\t}\n\t\tadev->gmc.mall_size = mall_size;\n\t\tadev->gmc.m_half_use = half_use;\n\t\tbreak;\n\tcase 2:\n\t\tmall_size_per_umc = le32_to_cpu(mall_info->v2.mall_size_per_umc);\n\t\tadev->gmc.mall_size = mall_size_per_umc * adev->gmc.num_umc;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Unhandled MALL info table %d.%d\\n\",\n\t\t\tle16_to_cpu(mall_info->v1.header.version_major),\n\t\t\tle16_to_cpu(mall_info->v1.header.version_minor));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nunion vcn_info {\n\tstruct vcn_info_v1_0 v1;\n};\n\nstatic int amdgpu_discovery_get_vcn_info(struct amdgpu_device *adev)\n{\n\tstruct binary_header *bhdr;\n\tunion vcn_info *vcn_info;\n\tu16 offset;\n\tint v;\n\n\tif (!adev->mman.discovery_bin) {\n\t\tDRM_ERROR(\"ip discovery uninitialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (adev->vcn.num_vcn_inst > VCN_INFO_TABLE_MAX_NUM_INSTANCES) {\n\t\tdev_err(adev->dev, \"invalid vcn instances\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbhdr = (struct binary_header *)adev->mman.discovery_bin;\n\toffset = le16_to_cpu(bhdr->table_list[VCN_INFO].offset);\n\n\tif (!offset)\n\t\treturn 0;\n\n\tvcn_info = (union vcn_info *)(adev->mman.discovery_bin + offset);\n\n\tswitch (le16_to_cpu(vcn_info->v1.header.version_major)) {\n\tcase 1:\n\t\t \n\t\tfor (v = 0; v < adev->vcn.num_vcn_inst; v++) {\n\t\t\tadev->vcn.vcn_codec_disable_mask[v] =\n\t\t\t\tle32_to_cpu(vcn_info->v1.instance_info[v].fuse_data.all_bits);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Unhandled VCN info table %d.%d\\n\",\n\t\t\tle16_to_cpu(vcn_info->v1.header.version_major),\n\t\t\tle16_to_cpu(vcn_info->v1.header.version_minor));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_common_ip_blocks(struct amdgpu_device *adev)\n{\n\t \n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 4, 2):\n\tcase IP_VERSION(9, 4, 3):\n\t\tamdgpu_device_ip_block_add(adev, &vega10_common_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 1):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 3):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\tcase IP_VERSION(10, 3, 6):\n\tcase IP_VERSION(10, 3, 7):\n\t\tamdgpu_device_ip_block_add(adev, &nv_common_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\t\tamdgpu_device_ip_block_add(adev, &soc21_common_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add common ip block(GC_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[GC_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_gmc_ip_blocks(struct amdgpu_device *adev)\n{\n\t \n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 4, 2):\n\tcase IP_VERSION(9, 4, 3):\n\t\tamdgpu_device_ip_block_add(adev, &gmc_v9_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 1):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 3):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\tcase IP_VERSION(10, 3, 6):\n\tcase IP_VERSION(10, 3, 7):\n\t\tamdgpu_device_ip_block_add(adev, &gmc_v10_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\t\tamdgpu_device_ip_block_add(adev, &gmc_v11_0_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add gmc ip block(GC_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[GC_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_ih_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[OSSSYS_HWIP][0]) {\n\tcase IP_VERSION(4, 0, 0):\n\tcase IP_VERSION(4, 0, 1):\n\tcase IP_VERSION(4, 1, 0):\n\tcase IP_VERSION(4, 1, 1):\n\tcase IP_VERSION(4, 3, 0):\n\t\tamdgpu_device_ip_block_add(adev, &vega10_ih_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(4, 2, 0):\n\tcase IP_VERSION(4, 2, 1):\n\tcase IP_VERSION(4, 4, 0):\n\tcase IP_VERSION(4, 4, 2):\n\t\tamdgpu_device_ip_block_add(adev, &vega20_ih_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(5, 0, 0):\n\tcase IP_VERSION(5, 0, 1):\n\tcase IP_VERSION(5, 0, 2):\n\tcase IP_VERSION(5, 0, 3):\n\tcase IP_VERSION(5, 2, 0):\n\tcase IP_VERSION(5, 2, 1):\n\t\tamdgpu_device_ip_block_add(adev, &navi10_ih_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(6, 0, 0):\n\tcase IP_VERSION(6, 0, 1):\n\tcase IP_VERSION(6, 0, 2):\n\t\tamdgpu_device_ip_block_add(adev, &ih_v6_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(6, 1, 0):\n\t\tamdgpu_device_ip_block_add(adev, &ih_v6_1_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add ih ip block(OSSSYS_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[OSSSYS_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_psp_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 0):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v3_1_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(10, 0, 0):\n\tcase IP_VERSION(10, 0, 1):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v10_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 4):\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\tcase IP_VERSION(11, 5, 0):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v11_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 8):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v11_0_8_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(12, 0, 1):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v12_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 2):\n\tcase IP_VERSION(13, 0, 3):\n\tcase IP_VERSION(13, 0, 5):\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 7):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(13, 0, 10):\n\tcase IP_VERSION(13, 0, 11):\n\tcase IP_VERSION(14, 0, 0):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v13_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 4):\n\t\tamdgpu_device_ip_block_add(adev, &psp_v13_0_4_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add psp ip block(MP0_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[MP0_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_smu_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 0):\n\tcase IP_VERSION(10, 0, 0):\n\tcase IP_VERSION(10, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\t\tif (adev->asic_type == CHIP_ARCTURUS)\n\t\t\tamdgpu_device_ip_block_add(adev, &smu_v11_0_ip_block);\n\t\telse\n\t\t\tamdgpu_device_ip_block_add(adev, &pp_smu_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 8):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\tcase IP_VERSION(11, 5, 0):\n\t\tamdgpu_device_ip_block_add(adev, &smu_v11_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(12, 0, 0):\n\tcase IP_VERSION(12, 0, 1):\n\t\tamdgpu_device_ip_block_add(adev, &smu_v12_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 2):\n\tcase IP_VERSION(13, 0, 3):\n\tcase IP_VERSION(13, 0, 4):\n\tcase IP_VERSION(13, 0, 5):\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 7):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(13, 0, 10):\n\tcase IP_VERSION(13, 0, 11):\n\t\tamdgpu_device_ip_block_add(adev, &smu_v13_0_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add smu ip block(MP1_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[MP1_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#if defined(CONFIG_DRM_AMD_DC)\nstatic void amdgpu_discovery_set_sriov_display(struct amdgpu_device *adev)\n{\n\tamdgpu_device_set_sriov_virtual_display(adev);\n\tamdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);\n}\n#endif\n\nstatic int amdgpu_discovery_set_display_ip_blocks(struct amdgpu_device *adev)\n{\n\tif (adev->enable_virtual_display) {\n\t\tamdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);\n\t\treturn 0;\n\t}\n\n\tif (!amdgpu_device_has_dc_support(adev))\n\t\treturn 0;\n\n#if defined(CONFIG_DRM_AMD_DC)\n\tif (adev->ip_versions[DCE_HWIP][0]) {\n\t\tswitch (adev->ip_versions[DCE_HWIP][0]) {\n\t\tcase IP_VERSION(1, 0, 0):\n\t\tcase IP_VERSION(1, 0, 1):\n\t\tcase IP_VERSION(2, 0, 2):\n\t\tcase IP_VERSION(2, 0, 0):\n\t\tcase IP_VERSION(2, 0, 3):\n\t\tcase IP_VERSION(2, 1, 0):\n\t\tcase IP_VERSION(3, 0, 0):\n\t\tcase IP_VERSION(3, 0, 2):\n\t\tcase IP_VERSION(3, 0, 3):\n\t\tcase IP_VERSION(3, 0, 1):\n\t\tcase IP_VERSION(3, 1, 2):\n\t\tcase IP_VERSION(3, 1, 3):\n\t\tcase IP_VERSION(3, 1, 4):\n\t\tcase IP_VERSION(3, 1, 5):\n\t\tcase IP_VERSION(3, 1, 6):\n\t\tcase IP_VERSION(3, 2, 0):\n\t\tcase IP_VERSION(3, 2, 1):\n\t\t\tif (amdgpu_sriov_vf(adev))\n\t\t\t\tamdgpu_discovery_set_sriov_display(adev);\n\t\t\telse\n\t\t\t\tamdgpu_device_ip_block_add(adev, &dm_ip_block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Failed to add dm ip block(DCE_HWIP:0x%x)\\n\",\n\t\t\t\tadev->ip_versions[DCE_HWIP][0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (adev->ip_versions[DCI_HWIP][0]) {\n\t\tswitch (adev->ip_versions[DCI_HWIP][0]) {\n\t\tcase IP_VERSION(12, 0, 0):\n\t\tcase IP_VERSION(12, 0, 1):\n\t\tcase IP_VERSION(12, 1, 0):\n\t\t\tif (amdgpu_sriov_vf(adev))\n\t\t\t\tamdgpu_discovery_set_sriov_display(adev);\n\t\t\telse\n\t\t\t\tamdgpu_device_ip_block_add(adev, &dm_ip_block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Failed to add dm ip block(DCI_HWIP:0x%x)\\n\",\n\t\t\t\tadev->ip_versions[DCI_HWIP][0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_gc_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 4, 2):\n\t\tamdgpu_device_ip_block_add(adev, &gfx_v9_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 3):\n\t\tif (!amdgpu_exp_hw_support)\n\t\t\treturn -EINVAL;\n\t\tamdgpu_device_ip_block_add(adev, &gfx_v9_4_3_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 1):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\tcase IP_VERSION(10, 3, 6):\n\tcase IP_VERSION(10, 3, 3):\n\tcase IP_VERSION(10, 3, 7):\n\t\tamdgpu_device_ip_block_add(adev, &gfx_v10_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\t\tamdgpu_device_ip_block_add(adev, &gfx_v11_0_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add gfx ip block(GC_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[GC_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_sdma_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[SDMA0_HWIP][0]) {\n\tcase IP_VERSION(4, 0, 0):\n\tcase IP_VERSION(4, 0, 1):\n\tcase IP_VERSION(4, 1, 0):\n\tcase IP_VERSION(4, 1, 1):\n\tcase IP_VERSION(4, 1, 2):\n\tcase IP_VERSION(4, 2, 0):\n\tcase IP_VERSION(4, 2, 2):\n\tcase IP_VERSION(4, 4, 0):\n\t\tamdgpu_device_ip_block_add(adev, &sdma_v4_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(4, 4, 2):\n\t\tamdgpu_device_ip_block_add(adev, &sdma_v4_4_2_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(5, 0, 0):\n\tcase IP_VERSION(5, 0, 1):\n\tcase IP_VERSION(5, 0, 2):\n\tcase IP_VERSION(5, 0, 5):\n\t\tamdgpu_device_ip_block_add(adev, &sdma_v5_0_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(5, 2, 0):\n\tcase IP_VERSION(5, 2, 2):\n\tcase IP_VERSION(5, 2, 4):\n\tcase IP_VERSION(5, 2, 5):\n\tcase IP_VERSION(5, 2, 6):\n\tcase IP_VERSION(5, 2, 3):\n\tcase IP_VERSION(5, 2, 1):\n\tcase IP_VERSION(5, 2, 7):\n\t\tamdgpu_device_ip_block_add(adev, &sdma_v5_2_ip_block);\n\t\tbreak;\n\tcase IP_VERSION(6, 0, 0):\n\tcase IP_VERSION(6, 0, 1):\n\tcase IP_VERSION(6, 0, 2):\n\tcase IP_VERSION(6, 0, 3):\n\tcase IP_VERSION(6, 1, 0):\n\t\tamdgpu_device_ip_block_add(adev, &sdma_v6_0_ip_block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to add sdma ip block(SDMA0_HWIP:0x%x)\\n\",\n\t\t\tadev->ip_versions[SDMA0_HWIP][0]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_mm_ip_blocks(struct amdgpu_device *adev)\n{\n\tif (adev->ip_versions[VCE_HWIP][0]) {\n\t\tswitch (adev->ip_versions[UVD_HWIP][0]) {\n\t\tcase IP_VERSION(7, 0, 0):\n\t\tcase IP_VERSION(7, 2, 0):\n\t\t\t \n\t\t\tif (!(adev->asic_type == CHIP_VEGA20 && amdgpu_sriov_vf(adev)))\n\t\t\t\tamdgpu_device_ip_block_add(adev, &uvd_v7_0_ip_block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Failed to add uvd v7 ip block(UVD_HWIP:0x%x)\\n\",\n\t\t\t\tadev->ip_versions[UVD_HWIP][0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (adev->ip_versions[VCE_HWIP][0]) {\n\t\tcase IP_VERSION(4, 0, 0):\n\t\tcase IP_VERSION(4, 1, 0):\n\t\t\t \n\t\t\tif (!(adev->asic_type == CHIP_VEGA20 && amdgpu_sriov_vf(adev)))\n\t\t\t\tamdgpu_device_ip_block_add(adev, &vce_v4_0_ip_block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Failed to add VCE v4 ip block(VCE_HWIP:0x%x)\\n\",\n\t\t\t\tadev->ip_versions[VCE_HWIP][0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (adev->ip_versions[UVD_HWIP][0]) {\n\t\tcase IP_VERSION(1, 0, 0):\n\t\tcase IP_VERSION(1, 0, 1):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v1_0_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(2, 0, 0):\n\t\tcase IP_VERSION(2, 0, 2):\n\t\tcase IP_VERSION(2, 2, 0):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v2_0_ip_block);\n\t\t\tif (!amdgpu_sriov_vf(adev))\n\t\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v2_0_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(2, 0, 3):\n\t\t\tbreak;\n\t\tcase IP_VERSION(2, 5, 0):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v2_5_ip_block);\n\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v2_5_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(2, 6, 0):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v2_6_ip_block);\n\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v2_6_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(3, 0, 0):\n\t\tcase IP_VERSION(3, 0, 16):\n\t\tcase IP_VERSION(3, 1, 1):\n\t\tcase IP_VERSION(3, 1, 2):\n\t\tcase IP_VERSION(3, 0, 2):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v3_0_ip_block);\n\t\t\tif (!amdgpu_sriov_vf(adev))\n\t\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v3_0_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(3, 0, 33):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v3_0_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(4, 0, 0):\n\t\tcase IP_VERSION(4, 0, 2):\n\t\tcase IP_VERSION(4, 0, 4):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v4_0_ip_block);\n\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v4_0_ip_block);\n\t\t\tbreak;\n\t\tcase IP_VERSION(4, 0, 3):\n\t\t\tamdgpu_device_ip_block_add(adev, &vcn_v4_0_3_ip_block);\n\t\t\tamdgpu_device_ip_block_add(adev, &jpeg_v4_0_3_ip_block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Failed to add vcn/jpeg ip block(UVD_HWIP:0x%x)\\n\",\n\t\t\t\tadev->ip_versions[UVD_HWIP][0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_discovery_set_mes_ip_blocks(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 1):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 3):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\tcase IP_VERSION(10, 3, 6):\n\t\tif (amdgpu_mes) {\n\t\t\tamdgpu_device_ip_block_add(adev, &mes_v10_1_ip_block);\n\t\t\tadev->enable_mes = true;\n\t\t\tif (amdgpu_mes_kiq)\n\t\t\t\tadev->enable_mes_kiq = true;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\t\tamdgpu_device_ip_block_add(adev, &mes_v11_0_ip_block);\n\t\tadev->enable_mes = true;\n\t\tadev->enable_mes_kiq = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void amdgpu_discovery_init_soc_config(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 4, 3):\n\t\taqua_vanjaram_init_soc_config(adev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint amdgpu_discovery_set_ip_blocks(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_VEGA10:\n\t\tvega10_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 2;\n\t\tadev->gmc.num_umc = 4;\n\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[SDMA1_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(2, 1, 0);\n\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(6, 1, 0);\n\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(6, 0, 0);\n\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 0, 1);\n\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(7, 0, 0);\n\t\tadev->ip_versions[VCE_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[DCI_HWIP][0] = IP_VERSION(12, 0, 0);\n\t\tbreak;\n\tcase CHIP_VEGA12:\n\t\tvega10_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 2;\n\t\tadev->gmc.num_umc = 4;\n\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 3, 0);\n\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 3, 0);\n\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 0, 1);\n\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 0, 1);\n\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 0, 1);\n\t\tadev->ip_versions[SDMA1_HWIP][0] = IP_VERSION(4, 0, 1);\n\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(2, 5, 0);\n\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(6, 2, 0);\n\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(6, 1, 0);\n\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(9, 0, 0);\n\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(9, 0, 1);\n\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 2, 1);\n\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(7, 0, 0);\n\t\tadev->ip_versions[VCE_HWIP][0] = IP_VERSION(4, 0, 0);\n\t\tadev->ip_versions[DCI_HWIP][0] = IP_VERSION(12, 0, 1);\n\t\tbreak;\n\tcase CHIP_RAVEN:\n\t\tvega10_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 1;\n\t\tadev->vcn.num_vcn_inst = 1;\n\t\tadev->gmc.num_umc = 2;\n\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2) {\n\t\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 2, 0);\n\t\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 2, 0);\n\t\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 1, 1);\n\t\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 1, 1);\n\t\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 1, 1);\n\t\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(2, 1, 1);\n\t\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(7, 0, 1);\n\t\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(7, 5, 0);\n\t\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(10, 0, 1);\n\t\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(10, 0, 1);\n\t\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(10, 1, 0);\n\t\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(10, 0, 1);\n\t\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 2, 2);\n\t\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(1, 0, 1);\n\t\t\tadev->ip_versions[DCE_HWIP][0] = IP_VERSION(1, 0, 1);\n\t\t} else {\n\t\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 1, 0);\n\t\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 1, 0);\n\t\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 1, 0);\n\t\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 1, 0);\n\t\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 1, 0);\n\t\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(2, 1, 0);\n\t\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(7, 0, 0);\n\t\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(7, 0, 0);\n\t\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(10, 0, 0);\n\t\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(10, 0, 0);\n\t\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(10, 0, 0);\n\t\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(10, 0, 0);\n\t\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 1, 0);\n\t\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(1, 0, 0);\n\t\t\tadev->ip_versions[DCE_HWIP][0] = IP_VERSION(1, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase CHIP_VEGA20:\n\t\tvega20_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 2;\n\t\tadev->gmc.num_umc = 8;\n\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 4, 0);\n\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 4, 0);\n\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 2, 0);\n\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 2, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 2, 0);\n\t\tadev->ip_versions[SDMA1_HWIP][0] = IP_VERSION(4, 2, 0);\n\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(3, 6, 0);\n\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(7, 4, 0);\n\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(6, 1, 1);\n\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(11, 0, 2);\n\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(11, 0, 2);\n\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(11, 0, 2);\n\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(11, 0, 2);\n\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 4, 0);\n\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(7, 2, 0);\n\t\tadev->ip_versions[UVD_HWIP][1] = IP_VERSION(7, 2, 0);\n\t\tadev->ip_versions[VCE_HWIP][0] = IP_VERSION(4, 1, 0);\n\t\tadev->ip_versions[DCI_HWIP][0] = IP_VERSION(12, 1, 0);\n\t\tbreak;\n\tcase CHIP_ARCTURUS:\n\t\tarct_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 8;\n\t\tadev->vcn.num_vcn_inst = 2;\n\t\tadev->gmc.num_umc = 8;\n\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 4, 1);\n\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 4, 1);\n\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 2, 1);\n\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 2, 1);\n\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][0] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][1] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][2] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][3] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][4] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][5] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[SDMA1_HWIP][6] = IP_VERSION(4, 2, 2);\n\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(3, 6, 1);\n\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(7, 4, 1);\n\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(6, 1, 2);\n\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(11, 0, 4);\n\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(11, 0, 2);\n\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(11, 0, 3);\n\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(11, 0, 3);\n\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 4, 1);\n\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(2, 5, 0);\n\t\tadev->ip_versions[UVD_HWIP][1] = IP_VERSION(2, 5, 0);\n\t\tbreak;\n\tcase CHIP_ALDEBARAN:\n\t\taldebaran_reg_base_init(adev);\n\t\tadev->sdma.num_instances = 5;\n\t\tadev->vcn.num_vcn_inst = 2;\n\t\tadev->gmc.num_umc = 4;\n\t\tadev->ip_versions[MMHUB_HWIP][0] = IP_VERSION(9, 4, 2);\n\t\tadev->ip_versions[ATHUB_HWIP][0] = IP_VERSION(9, 4, 2);\n\t\tadev->ip_versions[OSSSYS_HWIP][0] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[HDP_HWIP][0] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][0] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][1] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][2] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][3] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[SDMA0_HWIP][4] = IP_VERSION(4, 4, 0);\n\t\tadev->ip_versions[DF_HWIP][0] = IP_VERSION(3, 6, 2);\n\t\tadev->ip_versions[NBIO_HWIP][0] = IP_VERSION(7, 4, 4);\n\t\tadev->ip_versions[UMC_HWIP][0] = IP_VERSION(6, 7, 0);\n\t\tadev->ip_versions[MP0_HWIP][0] = IP_VERSION(13, 0, 2);\n\t\tadev->ip_versions[MP1_HWIP][0] = IP_VERSION(13, 0, 2);\n\t\tadev->ip_versions[THM_HWIP][0] = IP_VERSION(13, 0, 2);\n\t\tadev->ip_versions[SMUIO_HWIP][0] = IP_VERSION(13, 0, 2);\n\t\tadev->ip_versions[GC_HWIP][0] = IP_VERSION(9, 4, 2);\n\t\tadev->ip_versions[UVD_HWIP][0] = IP_VERSION(2, 6, 0);\n\t\tadev->ip_versions[UVD_HWIP][1] = IP_VERSION(2, 6, 0);\n\t\tadev->ip_versions[XGMI_HWIP][0] = IP_VERSION(6, 1, 0);\n\t\tbreak;\n\tdefault:\n\t\tr = amdgpu_discovery_reg_base_init(adev);\n\t\tif (r)\n\t\t\treturn -EINVAL;\n\n\t\tamdgpu_discovery_harvest_ip(adev);\n\t\tamdgpu_discovery_get_gfx_info(adev);\n\t\tamdgpu_discovery_get_mall_info(adev);\n\t\tamdgpu_discovery_get_vcn_info(adev);\n\t\tbreak;\n\t}\n\n\tamdgpu_discovery_init_soc_config(adev);\n\tamdgpu_discovery_sysfs_init(adev);\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 4, 2):\n\tcase IP_VERSION(9, 4, 3):\n\t\tadev->family = AMDGPU_FAMILY_AI;\n\t\tbreak;\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\t\tadev->family = AMDGPU_FAMILY_RV;\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 1):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\t\tadev->family = AMDGPU_FAMILY_NV;\n\t\tbreak;\n\tcase IP_VERSION(10, 3, 1):\n\t\tadev->family = AMDGPU_FAMILY_VGH;\n\t\tadev->apu_flags |= AMD_APU_IS_VANGOGH;\n\t\tbreak;\n\tcase IP_VERSION(10, 3, 3):\n\t\tadev->family = AMDGPU_FAMILY_YC;\n\t\tbreak;\n\tcase IP_VERSION(10, 3, 6):\n\t\tadev->family = AMDGPU_FAMILY_GC_10_3_6;\n\t\tbreak;\n\tcase IP_VERSION(10, 3, 7):\n\t\tadev->family = AMDGPU_FAMILY_GC_10_3_7;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\t\tadev->family = AMDGPU_FAMILY_GC_11_0_0;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tadev->family = AMDGPU_FAMILY_GC_11_0_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 1, 4):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 3):\n\tcase IP_VERSION(10, 3, 6):\n\tcase IP_VERSION(10, 3, 7):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tadev->flags |= AMD_IS_APU;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adev->ip_versions[XGMI_HWIP][0] == IP_VERSION(4, 8, 0))\n\t\tadev->gmc.xgmi.supported = true;\n\n\t \n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(6, 1, 0):\n\tcase IP_VERSION(6, 2, 0):\n\t\tadev->nbio.funcs = &nbio_v6_1_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v6_1_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(7, 0, 0):\n\tcase IP_VERSION(7, 0, 1):\n\tcase IP_VERSION(2, 5, 0):\n\t\tadev->nbio.funcs = &nbio_v7_0_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v7_0_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(7, 4, 0):\n\tcase IP_VERSION(7, 4, 1):\n\tcase IP_VERSION(7, 4, 4):\n\t\tadev->nbio.funcs = &nbio_v7_4_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v7_4_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(7, 9, 0):\n\t\tadev->nbio.funcs = &nbio_v7_9_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v7_9_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(7, 2, 0):\n\tcase IP_VERSION(7, 2, 1):\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 0):\n\tcase IP_VERSION(7, 5, 1):\n\t\tadev->nbio.funcs = &nbio_v7_2_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v7_2_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(2, 1, 1):\n\tcase IP_VERSION(2, 3, 0):\n\tcase IP_VERSION(2, 3, 1):\n\tcase IP_VERSION(2, 3, 2):\n\tcase IP_VERSION(3, 3, 0):\n\tcase IP_VERSION(3, 3, 1):\n\tcase IP_VERSION(3, 3, 2):\n\tcase IP_VERSION(3, 3, 3):\n\t\tadev->nbio.funcs = &nbio_v2_3_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v2_3_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(4, 3, 0):\n\tcase IP_VERSION(4, 3, 1):\n\t\tif (amdgpu_sriov_vf(adev))\n\t\t\tadev->nbio.funcs = &nbio_v4_3_sriov_funcs;\n\t\telse\n\t\t\tadev->nbio.funcs = &nbio_v4_3_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v4_3_hdp_flush_reg;\n\t\tbreak;\n\tcase IP_VERSION(7, 7, 0):\n\tcase IP_VERSION(7, 7, 1):\n\t\tadev->nbio.funcs = &nbio_v7_7_funcs;\n\t\tadev->nbio.hdp_flush_reg = &nbio_v7_7_hdp_flush_reg;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[HDP_HWIP][0]) {\n\tcase IP_VERSION(4, 0, 0):\n\tcase IP_VERSION(4, 0, 1):\n\tcase IP_VERSION(4, 1, 0):\n\tcase IP_VERSION(4, 1, 1):\n\tcase IP_VERSION(4, 1, 2):\n\tcase IP_VERSION(4, 2, 0):\n\tcase IP_VERSION(4, 2, 1):\n\tcase IP_VERSION(4, 4, 0):\n\tcase IP_VERSION(4, 4, 2):\n\t\tadev->hdp.funcs = &hdp_v4_0_funcs;\n\t\tbreak;\n\tcase IP_VERSION(5, 0, 0):\n\tcase IP_VERSION(5, 0, 1):\n\tcase IP_VERSION(5, 0, 2):\n\tcase IP_VERSION(5, 0, 3):\n\tcase IP_VERSION(5, 0, 4):\n\tcase IP_VERSION(5, 2, 0):\n\t\tadev->hdp.funcs = &hdp_v5_0_funcs;\n\t\tbreak;\n\tcase IP_VERSION(5, 2, 1):\n\t\tadev->hdp.funcs = &hdp_v5_2_funcs;\n\t\tbreak;\n\tcase IP_VERSION(6, 0, 0):\n\tcase IP_VERSION(6, 0, 1):\n\tcase IP_VERSION(6, 1, 0):\n\t\tadev->hdp.funcs = &hdp_v6_0_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[DF_HWIP][0]) {\n\tcase IP_VERSION(3, 6, 0):\n\tcase IP_VERSION(3, 6, 1):\n\tcase IP_VERSION(3, 6, 2):\n\t\tadev->df.funcs = &df_v3_6_funcs;\n\t\tbreak;\n\tcase IP_VERSION(2, 1, 0):\n\tcase IP_VERSION(2, 1, 1):\n\tcase IP_VERSION(2, 5, 0):\n\tcase IP_VERSION(3, 5, 1):\n\tcase IP_VERSION(3, 5, 2):\n\t\tadev->df.funcs = &df_v1_7_funcs;\n\t\tbreak;\n\tcase IP_VERSION(4, 3, 0):\n\t\tadev->df.funcs = &df_v4_3_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[SMUIO_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 0):\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(10, 0, 0):\n\tcase IP_VERSION(10, 0, 1):\n\tcase IP_VERSION(10, 0, 2):\n\t\tadev->smuio.funcs = &smuio_v9_0_funcs;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 8):\n\t\tadev->smuio.funcs = &smuio_v11_0_funcs;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 6):\n\tcase IP_VERSION(11, 0, 10):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 5, 0):\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 9):\n\tcase IP_VERSION(13, 0, 10):\n\t\tadev->smuio.funcs = &smuio_v11_0_6_funcs;\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 2):\n\t\tadev->smuio.funcs = &smuio_v13_0_funcs;\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 3):\n\t\tadev->smuio.funcs = &smuio_v13_0_3_funcs;\n\t\tif (adev->smuio.funcs->get_pkg_type(adev) == AMDGPU_PKG_TYPE_APU) {\n\t\t\tadev->flags |= AMD_IS_APU;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(14, 0, 0):\n\t\tadev->smuio.funcs = &smuio_v13_0_6_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[LSDMA_HWIP][0]) {\n\tcase IP_VERSION(6, 0, 0):\n\tcase IP_VERSION(6, 0, 1):\n\tcase IP_VERSION(6, 0, 2):\n\tcase IP_VERSION(6, 0, 3):\n\t\tadev->lsdma.funcs = &lsdma_v6_0_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tr = amdgpu_discovery_set_common_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_discovery_set_gmc_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (amdgpu_sriov_vf(adev)) {\n\t\tr = amdgpu_discovery_set_psp_ip_blocks(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = amdgpu_discovery_set_ih_ip_blocks(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tr = amdgpu_discovery_set_ih_ip_blocks(adev);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (likely(adev->firmware.load_type == AMDGPU_FW_LOAD_PSP)) {\n\t\t\tr = amdgpu_discovery_set_psp_ip_blocks(adev);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (likely(adev->firmware.load_type == AMDGPU_FW_LOAD_PSP)) {\n\t\tr = amdgpu_discovery_set_smu_ip_blocks(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_discovery_set_display_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_discovery_set_gc_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_discovery_set_sdma_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\tif ((adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT &&\n\t     !amdgpu_sriov_vf(adev)) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO && amdgpu_dpm == 1)) {\n\t\tr = amdgpu_discovery_set_smu_ip_blocks(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_discovery_set_mm_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_discovery_set_mes_ip_blocks(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}