{
  "module_name": "amdgpu_ras_eeprom.c",
  "hash_id": "ff4d733332709680c2b2fc171bd10ea2e66744b291511987a2cb7a5a17331a73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c",
  "human_readable_source": " \n\n#include \"amdgpu_ras_eeprom.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_ras.h\"\n#include <linux/bits.h>\n#include \"atom.h\"\n#include \"amdgpu_eeprom.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n\n#include \"amdgpu_reset.h\"\n\n \n#define EEPROM_I2C_MADDR_0      0x0\n#define EEPROM_I2C_MADDR_4      0x40000\n\n \n#define RAS_TABLE_HEADER_SIZE   20\n#define RAS_TABLE_RECORD_SIZE   24\n\n \n#define RAS_TABLE_HDR_VAL       0x414d4452\n\n \n#define RAS_TABLE_HDR_BAD       0x42414447\n\n \n\n \n#define RAS_TBL_SIZE_BYTES      (256 * 1024)\n#define RAS_TABLE_START         0\n#define RAS_HDR_START           RAS_TABLE_START\n#define RAS_RECORD_START        (RAS_HDR_START + RAS_TABLE_HEADER_SIZE)\n#define RAS_MAX_RECORD_COUNT    ((RAS_TBL_SIZE_BYTES - RAS_TABLE_HEADER_SIZE) \\\n\t\t\t\t / RAS_TABLE_RECORD_SIZE)\n\n \n\n \n#define RAS_TABLE_V2_1_INFO_SIZE       256\n#define RAS_TABLE_V2_1_INFO_START      RAS_TABLE_HEADER_SIZE\n#define RAS_RECORD_START_V2_1          (RAS_HDR_START + RAS_TABLE_HEADER_SIZE + \\\n\t\t\t\t\tRAS_TABLE_V2_1_INFO_SIZE)\n#define RAS_MAX_RECORD_COUNT_V2_1      ((RAS_TBL_SIZE_BYTES - RAS_TABLE_HEADER_SIZE - \\\n\t\t\t\t\tRAS_TABLE_V2_1_INFO_SIZE) \\\n\t\t\t\t\t/ RAS_TABLE_RECORD_SIZE)\n\n \n#define RAS_INDEX_TO_OFFSET(_C, _N) ((_C)->ras_record_offset + \\\n\t\t\t\t     (_N) * RAS_TABLE_RECORD_SIZE)\n\n#define RAS_OFFSET_TO_INDEX(_C, _O) (((_O) - \\\n\t\t\t\t      (_C)->ras_record_offset) / RAS_TABLE_RECORD_SIZE)\n\n \n#define RAS_RI_TO_AI(_C, _I) (((_I) + (_C)->ras_fri) % \\\n\t\t\t      (_C)->ras_max_record_count)\n\n#define RAS_NUM_RECS(_tbl_hdr)  (((_tbl_hdr)->tbl_size - \\\n\t\t\t\t  RAS_TABLE_HEADER_SIZE) / RAS_TABLE_RECORD_SIZE)\n\n#define RAS_NUM_RECS_V2_1(_tbl_hdr)  (((_tbl_hdr)->tbl_size - \\\n\t\t\t\t       RAS_TABLE_HEADER_SIZE - \\\n\t\t\t\t       RAS_TABLE_V2_1_INFO_SIZE) / RAS_TABLE_RECORD_SIZE)\n\n#define to_amdgpu_device(x) (container_of(x, struct amdgpu_ras, eeprom_control))->adev\n\nstatic bool __is_ras_eeprom_supported(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 2):  \n\tcase IP_VERSION(11, 0, 7):  \n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 2):  \n\tcase IP_VERSION(13, 0, 10):\n\t\treturn true;\n\tcase IP_VERSION(13, 0, 6):\n\t\treturn (adev->gmc.is_app_apu) ? false : true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool __get_eeprom_i2c_addr(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct atom_context *atom_ctx = adev->mode_info.atom_context;\n\tu8 i2c_addr;\n\n\tif (!control)\n\t\treturn false;\n\n\tif (amdgpu_atomfirmware_ras_rom_addr(adev, &i2c_addr)) {\n\t\t \n\t\ti2c_addr = (i2c_addr & 0x0F) >> 1;\n\t\tcontrol->i2c_address = ((u32) i2c_addr) << 16;\n\n\t\treturn true;\n\t}\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 2):\n\t\t \n\t\tif (adev->asic_type == CHIP_VEGA20)\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_0;\n\t\telse if (strnstr(atom_ctx->vbios_pn,\n\t\t\t\t \"D342\",\n\t\t\t\t sizeof(atom_ctx->vbios_pn)))\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_0;\n\t\telse\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_4;\n\t\treturn true;\n\tcase IP_VERSION(11, 0, 7):\n\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_0;\n\t\treturn true;\n\tcase IP_VERSION(13, 0, 2):\n\t\tif (strnstr(atom_ctx->vbios_pn, \"D673\",\n\t\t\t    sizeof(atom_ctx->vbios_pn)))\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_4;\n\t\telse\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_0;\n\t\treturn true;\n\tcase IP_VERSION(13, 0, 0):\n\t\tif (strnstr(atom_ctx->vbios_pn, \"D707\",\n\t\t\t    sizeof(atom_ctx->vbios_pn)))\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_0;\n\t\telse\n\t\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_4;\n\t\treturn true;\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 10):\n\t\tcontrol->i2c_address = EEPROM_I2C_MADDR_4;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void\n__encode_table_header_to_buf(struct amdgpu_ras_eeprom_table_header *hdr,\n\t\t\t     unsigned char *buf)\n{\n\tu32 *pp = (uint32_t *)buf;\n\n\tpp[0] = cpu_to_le32(hdr->header);\n\tpp[1] = cpu_to_le32(hdr->version);\n\tpp[2] = cpu_to_le32(hdr->first_rec_offset);\n\tpp[3] = cpu_to_le32(hdr->tbl_size);\n\tpp[4] = cpu_to_le32(hdr->checksum);\n}\n\nstatic void\n__decode_table_header_from_buf(struct amdgpu_ras_eeprom_table_header *hdr,\n\t\t\t       unsigned char *buf)\n{\n\tu32 *pp = (uint32_t *)buf;\n\n\thdr->header\t      = le32_to_cpu(pp[0]);\n\thdr->version\t      = le32_to_cpu(pp[1]);\n\thdr->first_rec_offset = le32_to_cpu(pp[2]);\n\thdr->tbl_size\t      = le32_to_cpu(pp[3]);\n\thdr->checksum\t      = le32_to_cpu(pp[4]);\n}\n\nstatic int __write_table_header(struct amdgpu_ras_eeprom_control *control)\n{\n\tu8 buf[RAS_TABLE_HEADER_SIZE];\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tint res;\n\n\tmemset(buf, 0, sizeof(buf));\n\t__encode_table_header_to_buf(&control->tbl_hdr, buf);\n\n\t \n\tdown_read(&adev->reset_domain->sem);\n\tres = amdgpu_eeprom_write(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t  control->i2c_address +\n\t\t\t\t  control->ras_header_offset,\n\t\t\t\t  buf, RAS_TABLE_HEADER_SIZE);\n\tup_read(&adev->reset_domain->sem);\n\n\tif (res < 0) {\n\t\tDRM_ERROR(\"Failed to write EEPROM table header:%d\", res);\n\t} else if (res < RAS_TABLE_HEADER_SIZE) {\n\t\tDRM_ERROR(\"Short write:%d out of %d\\n\",\n\t\t\t  res, RAS_TABLE_HEADER_SIZE);\n\t\tres = -EIO;\n\t} else {\n\t\tres = 0;\n\t}\n\n\treturn res;\n}\n\nstatic void\n__encode_table_ras_info_to_buf(struct amdgpu_ras_eeprom_table_ras_info *rai,\n\t\t\t       unsigned char *buf)\n{\n\tu32 *pp = (uint32_t *)buf;\n\tu32 tmp;\n\n\ttmp = ((uint32_t)(rai->rma_status) & 0xFF) |\n\t      (((uint32_t)(rai->health_percent) << 8) & 0xFF00) |\n\t      (((uint32_t)(rai->ecc_page_threshold) << 16) & 0xFFFF0000);\n\tpp[0] = cpu_to_le32(tmp);\n}\n\nstatic void\n__decode_table_ras_info_from_buf(struct amdgpu_ras_eeprom_table_ras_info *rai,\n\t\t\t\t unsigned char *buf)\n{\n\tu32 *pp = (uint32_t *)buf;\n\tu32 tmp;\n\n\ttmp = le32_to_cpu(pp[0]);\n\trai->rma_status = tmp & 0xFF;\n\trai->health_percent = (tmp >> 8) & 0xFF;\n\trai->ecc_page_threshold = (tmp >> 16) & 0xFFFF;\n}\n\nstatic int __write_table_ras_info(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tu8 *buf;\n\tint res;\n\n\tbuf = kzalloc(RAS_TABLE_V2_1_INFO_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tDRM_ERROR(\"Failed to alloc buf to write table ras info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t__encode_table_ras_info_to_buf(&control->tbl_rai, buf);\n\n\t \n\tdown_read(&adev->reset_domain->sem);\n\tres = amdgpu_eeprom_write(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t  control->i2c_address +\n\t\t\t\t  control->ras_info_offset,\n\t\t\t\t  buf, RAS_TABLE_V2_1_INFO_SIZE);\n\tup_read(&adev->reset_domain->sem);\n\n\tif (res < 0) {\n\t\tDRM_ERROR(\"Failed to write EEPROM table ras info:%d\", res);\n\t} else if (res < RAS_TABLE_V2_1_INFO_SIZE) {\n\t\tDRM_ERROR(\"Short write:%d out of %d\\n\",\n\t\t\t  res, RAS_TABLE_V2_1_INFO_SIZE);\n\t\tres = -EIO;\n\t} else {\n\t\tres = 0;\n\t}\n\n\tkfree(buf);\n\n\treturn res;\n}\n\nstatic u8 __calc_hdr_byte_sum(const struct amdgpu_ras_eeprom_control *control)\n{\n\tint ii;\n\tu8  *pp, csum;\n\tsize_t sz;\n\n\t \n\tsz = sizeof(control->tbl_hdr) - sizeof(control->tbl_hdr.checksum);\n\tpp = (u8 *) &control->tbl_hdr;\n\tcsum = 0;\n\tfor (ii = 0; ii < sz; ii++, pp++)\n\t\tcsum += *pp;\n\n\treturn csum;\n}\n\nstatic u8 __calc_ras_info_byte_sum(const struct amdgpu_ras_eeprom_control *control)\n{\n\tint ii;\n\tu8  *pp, csum;\n\tsize_t sz;\n\n\tsz = sizeof(control->tbl_rai);\n\tpp = (u8 *) &control->tbl_rai;\n\tcsum = 0;\n\tfor (ii = 0; ii < sz; ii++, pp++)\n\t\tcsum += *pp;\n\n\treturn csum;\n}\n\nstatic int amdgpu_ras_eeprom_correct_header_tag(\n\tstruct amdgpu_ras_eeprom_control *control,\n\tuint32_t header)\n{\n\tstruct amdgpu_ras_eeprom_table_header *hdr = &control->tbl_hdr;\n\tu8 *hh;\n\tint res;\n\tu8 csum;\n\n\tcsum = -hdr->checksum;\n\n\thh = (void *) &hdr->header;\n\tcsum -= (hh[0] + hh[1] + hh[2] + hh[3]);\n\thh = (void *) &header;\n\tcsum += hh[0] + hh[1] + hh[2] + hh[3];\n\tcsum = -csum;\n\tmutex_lock(&control->ras_tbl_mutex);\n\thdr->header = header;\n\thdr->checksum = csum;\n\tres = __write_table_header(control);\n\tmutex_unlock(&control->ras_tbl_mutex);\n\n\treturn res;\n}\n\n \nint amdgpu_ras_eeprom_reset_table(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tstruct amdgpu_ras_eeprom_table_header *hdr = &control->tbl_hdr;\n\tstruct amdgpu_ras_eeprom_table_ras_info *rai = &control->tbl_rai;\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\tu8 csum;\n\tint res;\n\n\tmutex_lock(&control->ras_tbl_mutex);\n\n\thdr->header = RAS_TABLE_HDR_VAL;\n\tif (adev->umc.ras &&\n\t    adev->umc.ras->set_eeprom_table_version)\n\t\tadev->umc.ras->set_eeprom_table_version(hdr);\n\telse\n\t\thdr->version = RAS_TABLE_VER_V1;\n\n\tif (hdr->version == RAS_TABLE_VER_V2_1) {\n\t\thdr->first_rec_offset = RAS_RECORD_START_V2_1;\n\t\thdr->tbl_size = RAS_TABLE_HEADER_SIZE +\n\t\t\t\tRAS_TABLE_V2_1_INFO_SIZE;\n\t\trai->rma_status = GPU_HEALTH_USABLE;\n\t\t \n\t\trai->health_percent = 100;\n\t\t \n\t\trai->ecc_page_threshold = con->bad_page_cnt_threshold;\n\t} else {\n\t\thdr->first_rec_offset = RAS_RECORD_START;\n\t\thdr->tbl_size = RAS_TABLE_HEADER_SIZE;\n\t}\n\n\tcsum = __calc_hdr_byte_sum(control);\n\tif (hdr->version == RAS_TABLE_VER_V2_1)\n\t\tcsum += __calc_ras_info_byte_sum(control);\n\tcsum = -csum;\n\thdr->checksum = csum;\n\tres = __write_table_header(control);\n\tif (!res && hdr->version > RAS_TABLE_VER_V1)\n\t\tres = __write_table_ras_info(control);\n\n\tcontrol->ras_num_recs = 0;\n\tcontrol->ras_fri = 0;\n\n\tamdgpu_dpm_send_hbm_bad_pages_num(adev, control->ras_num_recs);\n\n\tcontrol->bad_channel_bitmap = 0;\n\tamdgpu_dpm_send_hbm_bad_channel_flag(adev, control->bad_channel_bitmap);\n\tcon->update_channel_flag = false;\n\n\tamdgpu_ras_debugfs_set_ret_size(control);\n\n\tmutex_unlock(&control->ras_tbl_mutex);\n\n\treturn res;\n}\n\nstatic void\n__encode_table_record_to_buf(struct amdgpu_ras_eeprom_control *control,\n\t\t\t     struct eeprom_table_record *record,\n\t\t\t     unsigned char *buf)\n{\n\t__le64 tmp = 0;\n\tint i = 0;\n\n\t \n\tbuf[i++] = record->err_type;\n\n\tbuf[i++] = record->bank;\n\n\ttmp = cpu_to_le64(record->ts);\n\tmemcpy(buf + i, &tmp, 8);\n\ti += 8;\n\n\ttmp = cpu_to_le64((record->offset & 0xffffffffffff));\n\tmemcpy(buf + i, &tmp, 6);\n\ti += 6;\n\n\tbuf[i++] = record->mem_channel;\n\tbuf[i++] = record->mcumc_id;\n\n\ttmp = cpu_to_le64((record->retired_page & 0xffffffffffff));\n\tmemcpy(buf + i, &tmp, 6);\n}\n\nstatic void\n__decode_table_record_from_buf(struct amdgpu_ras_eeprom_control *control,\n\t\t\t       struct eeprom_table_record *record,\n\t\t\t       unsigned char *buf)\n{\n\t__le64 tmp = 0;\n\tint i =  0;\n\n\t \n\trecord->err_type = buf[i++];\n\n\trecord->bank = buf[i++];\n\n\tmemcpy(&tmp, buf + i, 8);\n\trecord->ts = le64_to_cpu(tmp);\n\ti += 8;\n\n\tmemcpy(&tmp, buf + i, 6);\n\trecord->offset = (le64_to_cpu(tmp) & 0xffffffffffff);\n\ti += 6;\n\n\trecord->mem_channel = buf[i++];\n\trecord->mcumc_id = buf[i++];\n\n\tmemcpy(&tmp, buf + i,  6);\n\trecord->retired_page = (le64_to_cpu(tmp) & 0xffffffffffff);\n}\n\nbool amdgpu_ras_eeprom_check_err_threshold(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\n\tif (!__is_ras_eeprom_supported(adev) ||\n\t    !amdgpu_bad_page_threshold)\n\t\treturn false;\n\n\t \n\tif (!con)\n\t\treturn false;\n\telse\n\t\tif (!(con->features & BIT(AMDGPU_RAS_BLOCK__UMC)))\n\t\t\treturn false;\n\n\tif (con->eeprom_control.tbl_hdr.header == RAS_TABLE_HDR_BAD) {\n\t\tif (amdgpu_bad_page_threshold == -1) {\n\t\t\tdev_warn(adev->dev, \"RAS records:%d exceed threshold:%d\",\n\t\t\t\tcon->eeprom_control.ras_num_recs, con->bad_page_cnt_threshold);\n\t\t\tdev_warn(adev->dev,\n\t\t\t\t\"But GPU can be operated due to bad_page_threshold = -1.\\n\");\n\t\t\treturn false;\n\t\t} else {\n\t\t\tdev_warn(adev->dev, \"This GPU is in BAD status.\");\n\t\t\tdev_warn(adev->dev, \"Please retire it or set a larger \"\n\t\t\t\t \"threshold value when reloading driver.\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int __amdgpu_ras_eeprom_write(struct amdgpu_ras_eeprom_control *control,\n\t\t\t\t     u8 *buf, const u32 fri, const u32 num)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tu32 buf_size;\n\tint res;\n\n\t \n\tdown_read(&adev->reset_domain->sem);\n\tbuf_size = num * RAS_TABLE_RECORD_SIZE;\n\tres = amdgpu_eeprom_write(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t  control->i2c_address +\n\t\t\t\t  RAS_INDEX_TO_OFFSET(control, fri),\n\t\t\t\t  buf, buf_size);\n\tup_read(&adev->reset_domain->sem);\n\tif (res < 0) {\n\t\tDRM_ERROR(\"Writing %d EEPROM table records error:%d\",\n\t\t\t  num, res);\n\t} else if (res < buf_size) {\n\t\t \n\t\tDRM_ERROR(\"Wrote %d records out of %d\",\n\t\t\t  res / RAS_TABLE_RECORD_SIZE, num);\n\t\tres = -EIO;\n\t} else {\n\t\tres = 0;\n\t}\n\n\treturn res;\n}\n\nstatic int\namdgpu_ras_eeprom_append_table(struct amdgpu_ras_eeprom_control *control,\n\t\t\t       struct eeprom_table_record *record,\n\t\t\t       const u32 num)\n{\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(to_amdgpu_device(control));\n\tu32 a, b, i;\n\tu8 *buf, *pp;\n\tint res;\n\n\tbuf = kcalloc(num, RAS_TABLE_RECORD_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tpp = buf;\n\tfor (i = 0; i < num; i++, pp += RAS_TABLE_RECORD_SIZE) {\n\t\t__encode_table_record_to_buf(control, &record[i], pp);\n\n\t\t \n\t\tif (!(control->bad_channel_bitmap & (1 << record[i].mem_channel))) {\n\t\t\tcontrol->bad_channel_bitmap |= 1 << record[i].mem_channel;\n\t\t\tcon->update_channel_flag = true;\n\t\t}\n\t}\n\n\t \n\ta = control->ras_fri + control->ras_num_recs;\n\tb = a + num  - 1;\n\tif (b < control->ras_max_record_count) {\n\t\tres = __amdgpu_ras_eeprom_write(control, buf, a, num);\n\t} else if (a < control->ras_max_record_count) {\n\t\tu32 g0, g1;\n\n\t\tg0 = control->ras_max_record_count - a;\n\t\tg1 = b % control->ras_max_record_count + 1;\n\t\tres = __amdgpu_ras_eeprom_write(control, buf, a, g0);\n\t\tif (res)\n\t\t\tgoto Out;\n\t\tres = __amdgpu_ras_eeprom_write(control,\n\t\t\t\t\t\tbuf + g0 * RAS_TABLE_RECORD_SIZE,\n\t\t\t\t\t\t0, g1);\n\t\tif (res)\n\t\t\tgoto Out;\n\t\tif (g1 > control->ras_fri)\n\t\t\tcontrol->ras_fri = g1 % control->ras_max_record_count;\n\t} else {\n\t\ta %= control->ras_max_record_count;\n\t\tb %= control->ras_max_record_count;\n\n\t\tif (a <= b) {\n\t\t\t \n\t\t\tres = __amdgpu_ras_eeprom_write(control, buf, a, num);\n\t\t\tif (res)\n\t\t\t\tgoto Out;\n\t\t\tif (b >= control->ras_fri)\n\t\t\t\tcontrol->ras_fri = (b + 1) % control->ras_max_record_count;\n\t\t} else {\n\t\t\tu32 g0, g1;\n\n\t\t\t \n\t\t\tg0 = control->ras_max_record_count - a;\n\t\t\tg1 = b + 1;\n\t\t\tres = __amdgpu_ras_eeprom_write(control, buf, a, g0);\n\t\t\tif (res)\n\t\t\t\tgoto Out;\n\t\t\tres = __amdgpu_ras_eeprom_write(control,\n\t\t\t\t\t\t\tbuf + g0 * RAS_TABLE_RECORD_SIZE,\n\t\t\t\t\t\t\t0, g1);\n\t\t\tif (res)\n\t\t\t\tgoto Out;\n\t\t\tcontrol->ras_fri = g1 % control->ras_max_record_count;\n\t\t}\n\t}\n\tcontrol->ras_num_recs = 1 + (control->ras_max_record_count + b\n\t\t\t\t     - control->ras_fri)\n\t\t% control->ras_max_record_count;\nOut:\n\tkfree(buf);\n\treturn res;\n}\n\nstatic int\namdgpu_ras_eeprom_update_header(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tu8 *buf, *pp, csum;\n\tu32 buf_size;\n\tint res;\n\n\t \n\tif (amdgpu_bad_page_threshold != 0 &&\n\t    control->ras_num_recs >= ras->bad_page_cnt_threshold) {\n\t\tdev_warn(adev->dev,\n\t\t\t\"Saved bad pages %d reaches threshold value %d\\n\",\n\t\t\tcontrol->ras_num_recs, ras->bad_page_cnt_threshold);\n\t\tcontrol->tbl_hdr.header = RAS_TABLE_HDR_BAD;\n\t\tif (control->tbl_hdr.version == RAS_TABLE_VER_V2_1) {\n\t\t\tcontrol->tbl_rai.rma_status = GPU_RETIRED__ECC_REACH_THRESHOLD;\n\t\t\tcontrol->tbl_rai.health_percent = 0;\n\t\t}\n\t}\n\n\tif (control->tbl_hdr.version == RAS_TABLE_VER_V2_1)\n\t\tcontrol->tbl_hdr.tbl_size = RAS_TABLE_HEADER_SIZE +\n\t\t\t\t\t    RAS_TABLE_V2_1_INFO_SIZE +\n\t\t\t\t\t    control->ras_num_recs * RAS_TABLE_RECORD_SIZE;\n\telse\n\t\tcontrol->tbl_hdr.tbl_size = RAS_TABLE_HEADER_SIZE +\n\t\t\t\t\t    control->ras_num_recs * RAS_TABLE_RECORD_SIZE;\n\tcontrol->tbl_hdr.checksum = 0;\n\n\tbuf_size = control->ras_num_recs * RAS_TABLE_RECORD_SIZE;\n\tbuf = kcalloc(control->ras_num_recs, RAS_TABLE_RECORD_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tDRM_ERROR(\"allocating memory for table of size %d bytes failed\\n\",\n\t\t\t  control->tbl_hdr.tbl_size);\n\t\tres = -ENOMEM;\n\t\tgoto Out;\n\t}\n\n\tdown_read(&adev->reset_domain->sem);\n\tres = amdgpu_eeprom_read(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t control->i2c_address +\n\t\t\t\t control->ras_record_offset,\n\t\t\t\t buf, buf_size);\n\tup_read(&adev->reset_domain->sem);\n\tif (res < 0) {\n\t\tDRM_ERROR(\"EEPROM failed reading records:%d\\n\",\n\t\t\t  res);\n\t\tgoto Out;\n\t} else if (res < buf_size) {\n\t\tDRM_ERROR(\"EEPROM read %d out of %d bytes\\n\",\n\t\t\t  res, buf_size);\n\t\tres = -EIO;\n\t\tgoto Out;\n\t}\n\n\t \n\tif (amdgpu_bad_page_threshold != 0 &&\n\t    control->tbl_hdr.version == RAS_TABLE_VER_V2_1 &&\n\t    control->ras_num_recs < ras->bad_page_cnt_threshold)\n\t\tcontrol->tbl_rai.health_percent = ((ras->bad_page_cnt_threshold -\n\t\t\t\t\t\t   control->ras_num_recs) * 100) /\n\t\t\t\t\t\t   ras->bad_page_cnt_threshold;\n\n\t \n\tcsum = 0;\n\tfor (pp = buf; pp < buf + buf_size; pp++)\n\t\tcsum += *pp;\n\n\tcsum += __calc_hdr_byte_sum(control);\n\tif (control->tbl_hdr.version == RAS_TABLE_VER_V2_1)\n\t\tcsum += __calc_ras_info_byte_sum(control);\n\t \n\tcsum = -csum;\n\tcontrol->tbl_hdr.checksum = csum;\n\tres = __write_table_header(control);\n\tif (!res && control->tbl_hdr.version > RAS_TABLE_VER_V1)\n\t\tres = __write_table_ras_info(control);\nOut:\n\tkfree(buf);\n\treturn res;\n}\n\n \nint amdgpu_ras_eeprom_append(struct amdgpu_ras_eeprom_control *control,\n\t\t\t     struct eeprom_table_record *record,\n\t\t\t     const u32 num)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tint res;\n\n\tif (!__is_ras_eeprom_supported(adev))\n\t\treturn 0;\n\n\tif (num == 0) {\n\t\tDRM_ERROR(\"will not append 0 records\\n\");\n\t\treturn -EINVAL;\n\t} else if (num > control->ras_max_record_count) {\n\t\tDRM_ERROR(\"cannot append %d records than the size of table %d\\n\",\n\t\t\t  num, control->ras_max_record_count);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&control->ras_tbl_mutex);\n\n\tres = amdgpu_ras_eeprom_append_table(control, record, num);\n\tif (!res)\n\t\tres = amdgpu_ras_eeprom_update_header(control);\n\tif (!res)\n\t\tamdgpu_ras_debugfs_set_ret_size(control);\n\n\tmutex_unlock(&control->ras_tbl_mutex);\n\treturn res;\n}\n\n \nstatic int __amdgpu_ras_eeprom_read(struct amdgpu_ras_eeprom_control *control,\n\t\t\t\t    u8 *buf, const u32 fri, const u32 num)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tu32 buf_size;\n\tint res;\n\n\t \n\tdown_read(&adev->reset_domain->sem);\n\tbuf_size = num * RAS_TABLE_RECORD_SIZE;\n\tres = amdgpu_eeprom_read(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t control->i2c_address +\n\t\t\t\t RAS_INDEX_TO_OFFSET(control, fri),\n\t\t\t\t buf, buf_size);\n\tup_read(&adev->reset_domain->sem);\n\tif (res < 0) {\n\t\tDRM_ERROR(\"Reading %d EEPROM table records error:%d\",\n\t\t\t  num, res);\n\t} else if (res < buf_size) {\n\t\t \n\t\tDRM_ERROR(\"Read %d records out of %d\",\n\t\t\t  res / RAS_TABLE_RECORD_SIZE, num);\n\t\tres = -EIO;\n\t} else {\n\t\tres = 0;\n\t}\n\n\treturn res;\n}\n\n \nint amdgpu_ras_eeprom_read(struct amdgpu_ras_eeprom_control *control,\n\t\t\t   struct eeprom_table_record *record,\n\t\t\t   const u32 num)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\tint i, res;\n\tu8 *buf, *pp;\n\tu32 g0, g1;\n\n\tif (!__is_ras_eeprom_supported(adev))\n\t\treturn 0;\n\n\tif (num == 0) {\n\t\tDRM_ERROR(\"will not read 0 records\\n\");\n\t\treturn -EINVAL;\n\t} else if (num > control->ras_num_recs) {\n\t\tDRM_ERROR(\"too many records to read:%d available:%d\\n\",\n\t\t\t  num, control->ras_num_recs);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = kcalloc(num, RAS_TABLE_RECORD_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tg0 = control->ras_fri + num - 1;\n\tg1 = g0 % control->ras_max_record_count;\n\tif (g0 < control->ras_max_record_count) {\n\t\tg0 = num;\n\t\tg1 = 0;\n\t} else {\n\t\tg0 = control->ras_max_record_count - control->ras_fri;\n\t\tg1 += 1;\n\t}\n\n\tmutex_lock(&control->ras_tbl_mutex);\n\tres = __amdgpu_ras_eeprom_read(control, buf, control->ras_fri, g0);\n\tif (res)\n\t\tgoto Out;\n\tif (g1) {\n\t\tres = __amdgpu_ras_eeprom_read(control,\n\t\t\t\t\t       buf + g0 * RAS_TABLE_RECORD_SIZE,\n\t\t\t\t\t       0, g1);\n\t\tif (res)\n\t\t\tgoto Out;\n\t}\n\n\tres = 0;\n\n\t \n\tpp = buf;\n\tfor (i = 0; i < num; i++, pp += RAS_TABLE_RECORD_SIZE) {\n\t\t__decode_table_record_from_buf(control, &record[i], pp);\n\n\t\t \n\t\tif (!(control->bad_channel_bitmap & (1 << record[i].mem_channel))) {\n\t\t\tcontrol->bad_channel_bitmap |= 1 << record[i].mem_channel;\n\t\t\tcon->update_channel_flag = true;\n\t\t}\n\t}\nOut:\n\tkfree(buf);\n\tmutex_unlock(&control->ras_tbl_mutex);\n\n\treturn res;\n}\n\nuint32_t amdgpu_ras_eeprom_max_record_count(struct amdgpu_ras_eeprom_control *control)\n{\n\tif (control->tbl_hdr.version == RAS_TABLE_VER_V2_1)\n\t\treturn RAS_MAX_RECORD_COUNT_V2_1;\n\telse\n\t\treturn RAS_MAX_RECORD_COUNT;\n}\n\nstatic ssize_t\namdgpu_ras_debugfs_eeprom_size_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tstruct amdgpu_ras_eeprom_control *control = ras ? &ras->eeprom_control : NULL;\n\tu8 data[50];\n\tint res;\n\n\tif (!size)\n\t\treturn size;\n\n\tif (!ras || !control) {\n\t\tres = snprintf(data, sizeof(data), \"Not supported\\n\");\n\t} else {\n\t\tres = snprintf(data, sizeof(data), \"%d bytes or %d records\\n\",\n\t\t\t       RAS_TBL_SIZE_BYTES, control->ras_max_record_count);\n\t}\n\n\tif (*pos >= res)\n\t\treturn 0;\n\n\tres -= *pos;\n\tres = min_t(size_t, res, size);\n\n\tif (copy_to_user(buf, &data[*pos], res))\n\t\treturn -EFAULT;\n\n\t*pos += res;\n\n\treturn res;\n}\n\nconst struct file_operations amdgpu_ras_debugfs_eeprom_size_ops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_ras_debugfs_eeprom_size_read,\n\t.write = NULL,\n\t.llseek = default_llseek,\n};\n\nstatic const char *tbl_hdr_str = \" Signature    Version  FirstOffs       Size   Checksum\\n\";\nstatic const char *tbl_hdr_fmt = \"0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\\n\";\n#define tbl_hdr_fmt_size (5 * (2+8) + 4 + 1)\nstatic const char *rec_hdr_str = \"Index  Offset ErrType Bank/CU          TimeStamp      Offs/Addr MemChl MCUMCID    RetiredPage\\n\";\nstatic const char *rec_hdr_fmt = \"%5d 0x%05X %7s    0x%02X 0x%016llX 0x%012llX   0x%02X    0x%02X 0x%012llX\\n\";\n#define rec_hdr_fmt_size (5 + 1 + 7 + 1 + 7 + 1 + 7 + 1 + 18 + 1 + 14 + 1 + 6 + 1 + 7 + 1 + 14 + 1)\n\nstatic const char *record_err_type_str[AMDGPU_RAS_EEPROM_ERR_COUNT] = {\n\t\"ignore\",\n\t\"re\",\n\t\"ue\",\n};\n\nstatic loff_t amdgpu_ras_debugfs_table_size(struct amdgpu_ras_eeprom_control *control)\n{\n\treturn strlen(tbl_hdr_str) + tbl_hdr_fmt_size +\n\t\tstrlen(rec_hdr_str) + rec_hdr_fmt_size * control->ras_num_recs;\n}\n\nvoid amdgpu_ras_debugfs_set_ret_size(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_ras *ras = container_of(control, struct amdgpu_ras,\n\t\t\t\t\t      eeprom_control);\n\tstruct dentry *de = ras->de_ras_eeprom_table;\n\n\tif (de)\n\t\td_inode(de)->i_size = amdgpu_ras_debugfs_table_size(control);\n}\n\nstatic ssize_t amdgpu_ras_debugfs_table_read(struct file *f, char __user *buf,\n\t\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tstruct amdgpu_ras_eeprom_control *control = &ras->eeprom_control;\n\tconst size_t orig_size = size;\n\tint res = -EFAULT;\n\tsize_t data_len;\n\n\tmutex_lock(&control->ras_tbl_mutex);\n\n\t \n\tdata_len = strlen(tbl_hdr_str);\n\tif (*pos < data_len) {\n\t\tdata_len -= *pos;\n\t\tdata_len = min_t(size_t, data_len, size);\n\t\tif (copy_to_user(buf, &tbl_hdr_str[*pos], data_len))\n\t\t\tgoto Out;\n\t\tbuf += data_len;\n\t\tsize -= data_len;\n\t\t*pos += data_len;\n\t}\n\n\tdata_len = strlen(tbl_hdr_str) + tbl_hdr_fmt_size;\n\tif (*pos < data_len && size > 0) {\n\t\tu8 data[tbl_hdr_fmt_size + 1];\n\t\tloff_t lpos;\n\n\t\tsnprintf(data, sizeof(data), tbl_hdr_fmt,\n\t\t\t control->tbl_hdr.header,\n\t\t\t control->tbl_hdr.version,\n\t\t\t control->tbl_hdr.first_rec_offset,\n\t\t\t control->tbl_hdr.tbl_size,\n\t\t\t control->tbl_hdr.checksum);\n\n\t\tdata_len -= *pos;\n\t\tdata_len = min_t(size_t, data_len, size);\n\t\tlpos = *pos - strlen(tbl_hdr_str);\n\t\tif (copy_to_user(buf, &data[lpos], data_len))\n\t\t\tgoto Out;\n\t\tbuf += data_len;\n\t\tsize -= data_len;\n\t\t*pos += data_len;\n\t}\n\n\tdata_len = strlen(tbl_hdr_str) + tbl_hdr_fmt_size + strlen(rec_hdr_str);\n\tif (*pos < data_len && size > 0) {\n\t\tloff_t lpos;\n\n\t\tdata_len -= *pos;\n\t\tdata_len = min_t(size_t, data_len, size);\n\t\tlpos = *pos - strlen(tbl_hdr_str) - tbl_hdr_fmt_size;\n\t\tif (copy_to_user(buf, &rec_hdr_str[lpos], data_len))\n\t\t\tgoto Out;\n\t\tbuf += data_len;\n\t\tsize -= data_len;\n\t\t*pos += data_len;\n\t}\n\n\tdata_len = amdgpu_ras_debugfs_table_size(control);\n\tif (*pos < data_len && size > 0) {\n\t\tu8 dare[RAS_TABLE_RECORD_SIZE];\n\t\tu8 data[rec_hdr_fmt_size + 1];\n\t\tstruct eeprom_table_record record;\n\t\tint s, r;\n\n\t\t \n\t\ts = *pos - strlen(tbl_hdr_str) - tbl_hdr_fmt_size -\n\t\t\tstrlen(rec_hdr_str);\n\t\ts = s / rec_hdr_fmt_size;\n\t\tr = *pos - strlen(tbl_hdr_str) - tbl_hdr_fmt_size -\n\t\t\tstrlen(rec_hdr_str);\n\t\tr = r % rec_hdr_fmt_size;\n\n\t\tfor ( ; size > 0 && s < control->ras_num_recs; s++) {\n\t\t\tu32 ai = RAS_RI_TO_AI(control, s);\n\t\t\t \n\t\t\tres = __amdgpu_ras_eeprom_read(control, dare, ai, 1);\n\t\t\tif (res)\n\t\t\t\tgoto Out;\n\t\t\t__decode_table_record_from_buf(control, &record, dare);\n\t\t\tsnprintf(data, sizeof(data), rec_hdr_fmt,\n\t\t\t\t s,\n\t\t\t\t RAS_INDEX_TO_OFFSET(control, ai),\n\t\t\t\t record_err_type_str[record.err_type],\n\t\t\t\t record.bank,\n\t\t\t\t record.ts,\n\t\t\t\t record.offset,\n\t\t\t\t record.mem_channel,\n\t\t\t\t record.mcumc_id,\n\t\t\t\t record.retired_page);\n\n\t\t\tdata_len = min_t(size_t, rec_hdr_fmt_size - r, size);\n\t\t\tif (copy_to_user(buf, &data[r], data_len)) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tgoto Out;\n\t\t\t}\n\t\t\tbuf += data_len;\n\t\t\tsize -= data_len;\n\t\t\t*pos += data_len;\n\t\t\tr = 0;\n\t\t}\n\t}\n\tres = 0;\nOut:\n\tmutex_unlock(&control->ras_tbl_mutex);\n\treturn res < 0 ? res : orig_size - size;\n}\n\nstatic ssize_t\namdgpu_ras_debugfs_eeprom_table_read(struct file *f, char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tstruct amdgpu_ras_eeprom_control *control = ras ? &ras->eeprom_control : NULL;\n\tu8 data[81];\n\tint res;\n\n\tif (!size)\n\t\treturn size;\n\n\tif (!ras || !control) {\n\t\tres = snprintf(data, sizeof(data), \"Not supported\\n\");\n\t\tif (*pos >= res)\n\t\t\treturn 0;\n\n\t\tres -= *pos;\n\t\tres = min_t(size_t, res, size);\n\n\t\tif (copy_to_user(buf, &data[*pos], res))\n\t\t\treturn -EFAULT;\n\n\t\t*pos += res;\n\n\t\treturn res;\n\t} else {\n\t\treturn amdgpu_ras_debugfs_table_read(f, buf, size, pos);\n\t}\n}\n\nconst struct file_operations amdgpu_ras_debugfs_eeprom_table_ops = {\n\t.owner = THIS_MODULE,\n\t.read = amdgpu_ras_debugfs_eeprom_table_read,\n\t.write = NULL,\n\t.llseek = default_llseek,\n};\n\n \nstatic int __verify_ras_table_checksum(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tint buf_size, res;\n\tu8  csum, *buf, *pp;\n\n\tif (control->tbl_hdr.version == RAS_TABLE_VER_V2_1)\n\t\tbuf_size = RAS_TABLE_HEADER_SIZE +\n\t\t\t   RAS_TABLE_V2_1_INFO_SIZE +\n\t\t\t   control->ras_num_recs * RAS_TABLE_RECORD_SIZE;\n\telse\n\t\tbuf_size = RAS_TABLE_HEADER_SIZE +\n\t\t\t   control->ras_num_recs * RAS_TABLE_RECORD_SIZE;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf) {\n\t\tDRM_ERROR(\"Out of memory checking RAS table checksum.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = amdgpu_eeprom_read(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t control->i2c_address +\n\t\t\t\t control->ras_header_offset,\n\t\t\t\t buf, buf_size);\n\tif (res < buf_size) {\n\t\tDRM_ERROR(\"Partial read for checksum, res:%d\\n\", res);\n\t\t \n\t\tif (res >= 0)\n\t\t\tres = -EIO;\n\t\tgoto Out;\n\t}\n\n\tcsum = 0;\n\tfor (pp = buf; pp < buf + buf_size; pp++)\n\t\tcsum += *pp;\nOut:\n\tkfree(buf);\n\treturn res < 0 ? res : csum;\n}\n\nstatic int __read_table_ras_info(struct amdgpu_ras_eeprom_control *control)\n{\n\tstruct amdgpu_ras_eeprom_table_ras_info *rai = &control->tbl_rai;\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tunsigned char *buf;\n\tint res;\n\n\tbuf = kzalloc(RAS_TABLE_V2_1_INFO_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tDRM_ERROR(\"Failed to alloc buf to read EEPROM table ras info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tres = amdgpu_eeprom_read(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t control->i2c_address + control->ras_info_offset,\n\t\t\t\t buf, RAS_TABLE_V2_1_INFO_SIZE);\n\tif (res < RAS_TABLE_V2_1_INFO_SIZE) {\n\t\tDRM_ERROR(\"Failed to read EEPROM table ras info, res:%d\", res);\n\t\tres = res >= 0 ? -EIO : res;\n\t\tgoto Out;\n\t}\n\n\t__decode_table_ras_info_from_buf(rai, buf);\n\nOut:\n\tkfree(buf);\n\treturn res == RAS_TABLE_V2_1_INFO_SIZE ? 0 : res;\n}\n\nint amdgpu_ras_eeprom_init(struct amdgpu_ras_eeprom_control *control,\n\t\t\t   bool *exceed_err_limit)\n{\n\tstruct amdgpu_device *adev = to_amdgpu_device(control);\n\tunsigned char buf[RAS_TABLE_HEADER_SIZE] = { 0 };\n\tstruct amdgpu_ras_eeprom_table_header *hdr = &control->tbl_hdr;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tint res;\n\n\t*exceed_err_limit = false;\n\n\tif (!__is_ras_eeprom_supported(adev))\n\t\treturn 0;\n\n\t \n\tif (!adev->pm.ras_eeprom_i2c_bus || !adev->pm.ras_eeprom_i2c_bus->algo)\n\t\treturn -ENOENT;\n\n\tif (!__get_eeprom_i2c_addr(adev, control))\n\t\treturn -EINVAL;\n\n\tcontrol->ras_header_offset = RAS_HDR_START;\n\tcontrol->ras_info_offset = RAS_TABLE_V2_1_INFO_START;\n\tmutex_init(&control->ras_tbl_mutex);\n\n\t \n\tres = amdgpu_eeprom_read(adev->pm.ras_eeprom_i2c_bus,\n\t\t\t\t control->i2c_address + control->ras_header_offset,\n\t\t\t\t buf, RAS_TABLE_HEADER_SIZE);\n\tif (res < RAS_TABLE_HEADER_SIZE) {\n\t\tDRM_ERROR(\"Failed to read EEPROM table header, res:%d\", res);\n\t\treturn res >= 0 ? -EIO : res;\n\t}\n\n\t__decode_table_header_from_buf(hdr, buf);\n\n\tif (hdr->version == RAS_TABLE_VER_V2_1) {\n\t\tcontrol->ras_num_recs = RAS_NUM_RECS_V2_1(hdr);\n\t\tcontrol->ras_record_offset = RAS_RECORD_START_V2_1;\n\t\tcontrol->ras_max_record_count = RAS_MAX_RECORD_COUNT_V2_1;\n\t} else {\n\t\tcontrol->ras_num_recs = RAS_NUM_RECS(hdr);\n\t\tcontrol->ras_record_offset = RAS_RECORD_START;\n\t\tcontrol->ras_max_record_count = RAS_MAX_RECORD_COUNT;\n\t}\n\tcontrol->ras_fri = RAS_OFFSET_TO_INDEX(control, hdr->first_rec_offset);\n\n\tif (hdr->header == RAS_TABLE_HDR_VAL) {\n\t\tDRM_DEBUG_DRIVER(\"Found existing EEPROM table with %d records\",\n\t\t\t\t control->ras_num_recs);\n\n\t\tif (hdr->version == RAS_TABLE_VER_V2_1) {\n\t\t\tres = __read_table_ras_info(control);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = __verify_ras_table_checksum(control);\n\t\tif (res)\n\t\t\tDRM_ERROR(\"RAS table incorrect checksum or error:%d\\n\",\n\t\t\t\t  res);\n\n\t\t \n\t\tif (10 * control->ras_num_recs >= 9 * ras->bad_page_cnt_threshold)\n\t\t\tdev_warn(adev->dev, \"RAS records:%u exceeds 90%% of threshold:%d\",\n\t\t\t\t\tcontrol->ras_num_recs,\n\t\t\t\t\tras->bad_page_cnt_threshold);\n\t} else if (hdr->header == RAS_TABLE_HDR_BAD &&\n\t\t   amdgpu_bad_page_threshold != 0) {\n\t\tif (hdr->version == RAS_TABLE_VER_V2_1) {\n\t\t\tres = __read_table_ras_info(control);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = __verify_ras_table_checksum(control);\n\t\tif (res)\n\t\t\tDRM_ERROR(\"RAS Table incorrect checksum or error:%d\\n\",\n\t\t\t\t  res);\n\t\tif (ras->bad_page_cnt_threshold > control->ras_num_recs) {\n\t\t\t \n\t\t\tdev_info(adev->dev,\n\t\t\t\t \"records:%d threshold:%d, resetting \"\n\t\t\t\t \"RAS table header signature\",\n\t\t\t\t control->ras_num_recs,\n\t\t\t\t ras->bad_page_cnt_threshold);\n\t\t\tres = amdgpu_ras_eeprom_correct_header_tag(control,\n\t\t\t\t\t\t\t\t   RAS_TABLE_HDR_VAL);\n\t\t} else {\n\t\t\tdev_err(adev->dev, \"RAS records:%d exceed threshold:%d\",\n\t\t\t\tcontrol->ras_num_recs, ras->bad_page_cnt_threshold);\n\t\t\tif (amdgpu_bad_page_threshold == -1) {\n\t\t\t\tdev_warn(adev->dev, \"GPU will be initialized due to bad_page_threshold = -1.\");\n\t\t\t\tres = 0;\n\t\t\t} else {\n\t\t\t\t*exceed_err_limit = true;\n\t\t\t\tdev_err(adev->dev,\n\t\t\t\t\t\"RAS records:%d exceed threshold:%d, \"\n\t\t\t\t\t\"GPU will not be initialized. Replace this GPU or increase the threshold\",\n\t\t\t\t\tcontrol->ras_num_recs, ras->bad_page_cnt_threshold);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDRM_INFO(\"Creating a new EEPROM table\");\n\n\t\tres = amdgpu_ras_eeprom_reset_table(control);\n\t}\n\n\treturn res < 0 ? res : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}