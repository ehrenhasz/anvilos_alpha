{
  "module_name": "amdgpu_sdma.c",
  "hash_id": "64e2743526a64d1e850ed90cc648b9bb11351e5328a25967459881409d61fd7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_sdma.h\"\n#include \"amdgpu_ras.h\"\n\n#define AMDGPU_CSA_SDMA_SIZE 64\n \n#define AMDGPU_CSA_SDMA_OFFSET (4096 * 2)\n\n \n\nstruct amdgpu_sdma_instance *amdgpu_sdma_get_instance_from_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tint i;\n\n\tfor (i = 0; i < adev->sdma.num_instances; i++)\n\t\tif (ring == &adev->sdma.instance[i].ring ||\n\t\t    ring == &adev->sdma.instance[i].page)\n\t\t\treturn &adev->sdma.instance[i];\n\n\treturn NULL;\n}\n\nint amdgpu_sdma_get_index_from_ring(struct amdgpu_ring *ring, uint32_t *index)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tint i;\n\n\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\tif (ring == &adev->sdma.instance[i].ring ||\n\t\t\tring == &adev->sdma.instance[i].page) {\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nuint64_t amdgpu_sdma_get_csa_mc_addr(struct amdgpu_ring *ring,\n\t\t\t\t     unsigned int vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint64_t csa_mc_addr;\n\tuint32_t index = 0;\n\tint r;\n\n\t \n\tif (amdgpu_sriov_vf(adev) || vmid == 0 || !adev->gfx.mcbp)\n\t\treturn 0;\n\n\tif (ring->is_mes_queue) {\n\t\tuint32_t offset = 0;\n\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  sdma[ring->idx].sdma_meta_data);\n\t\tcsa_mc_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t} else {\n\t\tr = amdgpu_sdma_get_index_from_ring(ring, &index);\n\n\t\tif (r || index > 31)\n\t\t\tcsa_mc_addr = 0;\n\t\telse\n\t\t\tcsa_mc_addr = amdgpu_csa_vaddr(adev) +\n\t\t\t\tAMDGPU_CSA_SDMA_OFFSET +\n\t\t\t\tindex * AMDGPU_CSA_SDMA_SIZE;\n\t}\n\n\treturn csa_mc_addr;\n}\n\nint amdgpu_sdma_ras_late_init(struct amdgpu_device *adev,\n\t\t\t      struct ras_common_if *ras_block)\n{\n\tint r, i;\n\n\tr = amdgpu_ras_block_late_init(adev, ras_block);\n\tif (r)\n\t\treturn r;\n\n\tif (amdgpu_ras_is_supported(adev, ras_block->block)) {\n\t\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\t\tr = amdgpu_irq_get(adev, &adev->sdma.ecc_irq,\n\t\t\t\tAMDGPU_SDMA_IRQ_INSTANCE0 + i);\n\t\t\tif (r)\n\t\t\t\tgoto late_fini;\n\t\t}\n\t}\n\n\treturn 0;\n\nlate_fini:\n\tamdgpu_ras_block_late_fini(adev, ras_block);\n\treturn r;\n}\n\nint amdgpu_sdma_process_ras_data_cb(struct amdgpu_device *adev,\n\t\tvoid *err_data,\n\t\tstruct amdgpu_iv_entry *entry)\n{\n\tkgd2kfd_set_sram_ecc_flag(adev->kfd.dev);\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn AMDGPU_RAS_SUCCESS;\n\n\tamdgpu_ras_reset_gpu(adev);\n\n\treturn AMDGPU_RAS_SUCCESS;\n}\n\nint amdgpu_sdma_process_ecc_irq(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tstruct ras_common_if *ras_if = adev->sdma.ras_if;\n\tstruct ras_dispatch_if ih_data = {\n\t\t.entry = entry,\n\t};\n\n\tif (!ras_if)\n\t\treturn 0;\n\n\tih_data.head = *ras_if;\n\n\tamdgpu_ras_interrupt_dispatch(adev, &ih_data);\n\treturn 0;\n}\n\nstatic int amdgpu_sdma_init_inst_ctx(struct amdgpu_sdma_instance *sdma_inst)\n{\n\tuint16_t version_major;\n\tconst struct common_firmware_header *header = NULL;\n\tconst struct sdma_firmware_header_v1_0 *hdr;\n\tconst struct sdma_firmware_header_v2_0 *hdr_v2;\n\n\theader = (const struct common_firmware_header *)\n\t\tsdma_inst->fw->data;\n\tversion_major = le16_to_cpu(header->header_version_major);\n\n\tswitch (version_major) {\n\tcase 1:\n\t\thdr = (const struct sdma_firmware_header_v1_0 *)sdma_inst->fw->data;\n\t\tsdma_inst->fw_version = le32_to_cpu(hdr->header.ucode_version);\n\t\tsdma_inst->feature_version = le32_to_cpu(hdr->ucode_feature_version);\n\t\tbreak;\n\tcase 2:\n\t\thdr_v2 = (const struct sdma_firmware_header_v2_0 *)sdma_inst->fw->data;\n\t\tsdma_inst->fw_version = le32_to_cpu(hdr_v2->header.ucode_version);\n\t\tsdma_inst->feature_version = le32_to_cpu(hdr_v2->ucode_feature_version);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdma_inst->feature_version >= 20)\n\t\tsdma_inst->burst_nop = true;\n\n\treturn 0;\n}\n\nvoid amdgpu_sdma_destroy_inst_ctx(struct amdgpu_device *adev,\n\t\t\t\t  bool duplicate)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\tamdgpu_ucode_release(&adev->sdma.instance[i].fw);\n\t\tif (duplicate)\n\t\t\tbreak;\n\t}\n\n\tmemset((void *)adev->sdma.instance, 0,\n\t       sizeof(struct amdgpu_sdma_instance) * AMDGPU_MAX_SDMA_INSTANCES);\n}\n\nint amdgpu_sdma_init_microcode(struct amdgpu_device *adev,\n\t\t\t       u32 instance, bool duplicate)\n{\n\tstruct amdgpu_firmware_info *info = NULL;\n\tconst struct common_firmware_header *header = NULL;\n\tint err, i;\n\tconst struct sdma_firmware_header_v2_0 *sdma_hdr;\n\tuint16_t version_major;\n\tchar ucode_prefix[30];\n\tchar fw_name[40];\n\n\tamdgpu_ucode_ip_version_decode(adev, SDMA0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\tif (instance == 0)\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s.bin\", ucode_prefix);\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s%d.bin\", ucode_prefix, instance);\n\terr = amdgpu_ucode_request(adev, &adev->sdma.instance[instance].fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\theader = (const struct common_firmware_header *)\n\t\tadev->sdma.instance[instance].fw->data;\n\tversion_major = le16_to_cpu(header->header_version_major);\n\n\tif ((duplicate && instance) || (!duplicate && version_major > 1)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = amdgpu_sdma_init_inst_ctx(&adev->sdma.instance[instance]);\n\tif (err)\n\t\tgoto out;\n\n\tif (duplicate) {\n\t\tfor (i = 1; i < adev->sdma.num_instances; i++)\n\t\t\tmemcpy((void *)&adev->sdma.instance[i],\n\t\t\t       (void *)&adev->sdma.instance[0],\n\t\t\t       sizeof(struct amdgpu_sdma_instance));\n\t}\n\n\tDRM_DEBUG(\"psp_load == '%s'\\n\",\n\t\t  adev->firmware.load_type == AMDGPU_FW_LOAD_PSP ? \"true\" : \"false\");\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tswitch (version_major) {\n\t\tcase 1:\n\t\t\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\t\t\tif (!duplicate && (instance != i))\n\t\t\t\t\tcontinue;\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tif (adev->ip_versions[SDMA0_HWIP][0] == IP_VERSION(4, 4, 2) &&\n\t\t\t\t\t    adev->firmware.load_type == AMDGPU_FW_LOAD_PSP &&\n\t\t\t\t\t    adev->sdma.num_inst_per_aid == i) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SDMA0 + i];\n\t\t\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SDMA0 + i;\n\t\t\t\t\tinfo->fw = adev->sdma.instance[i].fw;\n\t\t\t\t\tadev->firmware.fw_size +=\n\t\t\t\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsdma_hdr = (const struct sdma_firmware_header_v2_0 *)\n\t\t\t\tadev->sdma.instance[0].fw->data;\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SDMA_UCODE_TH0];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SDMA_UCODE_TH0;\n\t\t\tinfo->fw = adev->sdma.instance[0].fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(le32_to_cpu(sdma_hdr->ctx_ucode_size_bytes), PAGE_SIZE);\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SDMA_UCODE_TH1];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SDMA_UCODE_TH1;\n\t\t\tinfo->fw = adev->sdma.instance[0].fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(le32_to_cpu(sdma_hdr->ctl_ucode_size_bytes), PAGE_SIZE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\nout:\n\tif (err)\n\t\tamdgpu_sdma_destroy_inst_ctx(adev, duplicate);\n\treturn err;\n}\n\nvoid amdgpu_sdma_unset_buffer_funcs_helper(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *sdma;\n\tint i;\n\n\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\tif (adev->sdma.has_page_queue) {\n\t\t\tsdma = &adev->sdma.instance[i].page;\n\t\t\tif (adev->mman.buffer_funcs_ring == sdma) {\n\t\t\t\tamdgpu_ttm_set_buffer_funcs_status(adev, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsdma = &adev->sdma.instance[i].ring;\n\t\tif (adev->mman.buffer_funcs_ring == sdma) {\n\t\t\tamdgpu_ttm_set_buffer_funcs_status(adev, false);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint amdgpu_sdma_ras_sw_init(struct amdgpu_device *adev)\n{\n\tint err = 0;\n\tstruct amdgpu_sdma_ras *ras = NULL;\n\n\t \n\tif (!adev->sdma.ras)\n\t\treturn 0;\n\n\tras = adev->sdma.ras;\n\n\terr = amdgpu_ras_register_ras_block(adev, &ras->ras_block);\n\tif (err) {\n\t\tdev_err(adev->dev, \"Failed to register sdma ras block!\\n\");\n\t\treturn err;\n\t}\n\n\tstrcpy(ras->ras_block.ras_comm.name, \"sdma\");\n\tras->ras_block.ras_comm.block = AMDGPU_RAS_BLOCK__SDMA;\n\tras->ras_block.ras_comm.type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE;\n\tadev->sdma.ras_if = &ras->ras_block.ras_comm;\n\n\t \n\tif (!ras->ras_block.ras_late_init)\n\t\tras->ras_block.ras_late_init = amdgpu_sdma_ras_late_init;\n\n\t \n\tif (!ras->ras_block.ras_cb)\n\t\tras->ras_block.ras_cb = amdgpu_sdma_process_ras_data_cb;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}