{
  "module_name": "jpeg_v2_5.c",
  "hash_id": "66c2b46541bd365c60e546f65b2e187bf46663a8c3026924e18f756ff009da66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_jpeg.h\"\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"jpeg_v2_0.h\"\n#include \"jpeg_v2_5.h\"\n\n#include \"vcn/vcn_2_5_offset.h\"\n#include \"vcn/vcn_2_5_sh_mask.h\"\n#include \"ivsrcid/vcn/irqsrcs_vcn_2_0.h\"\n\n#define mmUVD_JPEG_PITCH_INTERNAL_OFFSET\t\t\t0x401f\n\n#define JPEG25_MAX_HW_INSTANCES_ARCTURUS\t\t\t2\n\nstatic void jpeg_v2_5_set_dec_ring_funcs(struct amdgpu_device *adev);\nstatic void jpeg_v2_5_set_irq_funcs(struct amdgpu_device *adev);\nstatic int jpeg_v2_5_set_powergating_state(void *handle,\n\t\t\t\tenum amd_powergating_state state);\nstatic void jpeg_v2_5_set_ras_funcs(struct amdgpu_device *adev);\n\nstatic int amdgpu_ih_clientid_jpeg[] = {\n\tSOC15_IH_CLIENTID_VCN,\n\tSOC15_IH_CLIENTID_VCN1\n};\n\n \nstatic int jpeg_v2_5_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 harvest;\n\tint i;\n\n\tadev->jpeg.num_jpeg_rings = 1;\n\tadev->jpeg.num_jpeg_inst = JPEG25_MAX_HW_INSTANCES_ARCTURUS;\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; i++) {\n\t\tharvest = RREG32_SOC15(JPEG, i, mmCC_UVD_HARVESTING);\n\t\tif (harvest & CC_UVD_HARVESTING__UVD_DISABLE_MASK)\n\t\t\tadev->jpeg.harvest_config |= 1 << i;\n\t}\n\tif (adev->jpeg.harvest_config == (AMDGPU_JPEG_HARVEST_JPEG0 |\n\t\t\t\t\t AMDGPU_JPEG_HARVEST_JPEG1))\n\t\treturn -ENOENT;\n\n\tjpeg_v2_5_set_dec_ring_funcs(adev);\n\tjpeg_v2_5_set_irq_funcs(adev);\n\tjpeg_v2_5_set_ras_funcs(adev);\n\n\treturn 0;\n}\n\n \nstatic int jpeg_v2_5_sw_init(void *handle)\n{\n\tstruct amdgpu_ring *ring;\n\tint i, r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\t \n\t\tr = amdgpu_irq_add_id(adev, amdgpu_ih_clientid_jpeg[i],\n\t\t\t\tVCN_2_0__SRCID__JPEG_DECODE, &adev->jpeg.inst[i].irq);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\t \n\t\tr = amdgpu_irq_add_id(adev, amdgpu_ih_clientid_jpeg[i],\n\t\t\tVCN_2_6__SRCID_DJPEG0_POISON, &adev->jpeg.inst[i].ras_poison_irq);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\t \n\t\tr = amdgpu_irq_add_id(adev, amdgpu_ih_clientid_jpeg[i],\n\t\t\tVCN_2_6__SRCID_EJPEG0_POISON, &adev->jpeg.inst[i].ras_poison_irq);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_jpeg_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_jpeg_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tring = adev->jpeg.inst[i].ring_dec;\n\t\tring->use_doorbell = true;\n\t\tif (adev->ip_versions[UVD_HWIP][0] == IP_VERSION(2, 5, 0))\n\t\t\tring->vm_hub = AMDGPU_MMHUB1(0);\n\t\telse\n\t\t\tring->vm_hub = AMDGPU_MMHUB0(0);\n\t\tring->doorbell_index = (adev->doorbell_index.vcn.vcn_ring0_1 << 1) + 1 + 8 * i;\n\t\tsprintf(ring->name, \"jpeg_dec_%d\", i);\n\t\tr = amdgpu_ring_init(adev, ring, 512, &adev->jpeg.inst[i].irq,\n\t\t\t\t     0, AMDGPU_RING_PRIO_DEFAULT, NULL);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tadev->jpeg.internal.jpeg_pitch[0] = mmUVD_JPEG_PITCH_INTERNAL_OFFSET;\n\t\tadev->jpeg.inst[i].external.jpeg_pitch[0] = SOC15_REG_OFFSET(JPEG, i, mmUVD_JPEG_PITCH);\n\t}\n\n\tr = amdgpu_jpeg_ras_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic int jpeg_v2_5_sw_fini(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_jpeg_suspend(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_jpeg_sw_fini(adev);\n\n\treturn r;\n}\n\n \nstatic int jpeg_v2_5_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring;\n\tint i, r;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tring = adev->jpeg.inst[i].ring_dec;\n\t\tadev->nbio.funcs->vcn_doorbell_range(adev, ring->use_doorbell,\n\t\t\t(adev->doorbell_index.vcn.vcn_ring0_1 << 1) + 8 * i, i);\n\n\t\tr = amdgpu_ring_test_helper(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tDRM_INFO(\"JPEG decode initialized successfully.\\n\");\n\n\treturn 0;\n}\n\n \nstatic int jpeg_v2_5_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i;\n\n\tcancel_delayed_work_sync(&adev->vcn.idle_work);\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tif (adev->jpeg.cur_state != AMD_PG_STATE_GATE &&\n\t\t      RREG32_SOC15(JPEG, i, mmUVD_JRBC_STATUS))\n\t\t\tjpeg_v2_5_set_powergating_state(adev, AMD_PG_STATE_GATE);\n\n\t\tif (amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__JPEG))\n\t\t\tamdgpu_irq_put(adev, &adev->jpeg.inst[i].ras_poison_irq, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int jpeg_v2_5_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = jpeg_v2_5_hw_fini(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_jpeg_suspend(adev);\n\n\treturn r;\n}\n\n \nstatic int jpeg_v2_5_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_jpeg_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = jpeg_v2_5_hw_init(adev);\n\n\treturn r;\n}\n\nstatic void jpeg_v2_5_disable_clock_gating(struct amdgpu_device *adev, int inst)\n{\n\tuint32_t data;\n\n\tdata = RREG32_SOC15(JPEG, inst, mmJPEG_CGC_CTRL);\n\tif (adev->cg_flags & AMD_CG_SUPPORT_JPEG_MGCG)\n\t\tdata |= 1 << JPEG_CGC_CTRL__DYN_CLOCK_MODE__SHIFT;\n\telse\n\t\tdata &= ~JPEG_CGC_CTRL__DYN_CLOCK_MODE__SHIFT;\n\n\tdata |= 1 << JPEG_CGC_CTRL__CLK_GATE_DLY_TIMER__SHIFT;\n\tdata |= 4 << JPEG_CGC_CTRL__CLK_OFF_DELAY__SHIFT;\n\tWREG32_SOC15(JPEG, inst, mmJPEG_CGC_CTRL, data);\n\n\tdata = RREG32_SOC15(JPEG, inst, mmJPEG_CGC_GATE);\n\tdata &= ~(JPEG_CGC_GATE__JPEG_DEC_MASK\n\t\t| JPEG_CGC_GATE__JPEG2_DEC_MASK\n\t\t| JPEG_CGC_GATE__JMCIF_MASK\n\t\t| JPEG_CGC_GATE__JRBBM_MASK);\n\tWREG32_SOC15(JPEG, inst, mmJPEG_CGC_GATE, data);\n\n\tdata = RREG32_SOC15(JPEG, inst, mmJPEG_CGC_CTRL);\n\tdata &= ~(JPEG_CGC_CTRL__JPEG_DEC_MODE_MASK\n\t\t| JPEG_CGC_CTRL__JPEG2_DEC_MODE_MASK\n\t\t| JPEG_CGC_CTRL__JMCIF_MODE_MASK\n\t\t| JPEG_CGC_CTRL__JRBBM_MODE_MASK);\n\tWREG32_SOC15(JPEG, inst, mmJPEG_CGC_CTRL, data);\n}\n\nstatic void jpeg_v2_5_enable_clock_gating(struct amdgpu_device *adev, int inst)\n{\n\tuint32_t data;\n\n\tdata = RREG32_SOC15(JPEG, inst, mmJPEG_CGC_GATE);\n\tdata |= (JPEG_CGC_GATE__JPEG_DEC_MASK\n\t\t|JPEG_CGC_GATE__JPEG2_DEC_MASK\n\t\t|JPEG_CGC_GATE__JPEG_ENC_MASK\n\t\t|JPEG_CGC_GATE__JMCIF_MASK\n\t\t|JPEG_CGC_GATE__JRBBM_MASK);\n\tWREG32_SOC15(JPEG, inst, mmJPEG_CGC_GATE, data);\n}\n\n \nstatic int jpeg_v2_5_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tint i;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tring = adev->jpeg.inst[i].ring_dec;\n\t\t \n\t\tWREG32_P(SOC15_REG_OFFSET(JPEG, i, mmUVD_JPEG_POWER_STATUS), 0,\n\t\t\t~UVD_JPEG_POWER_STATUS__JPEG_POWER_STATUS_MASK);\n\n\t\t \n\t\tjpeg_v2_5_disable_clock_gating(adev, i);\n\n\t\t \n\t\tWREG32_SOC15(JPEG, i, mmJPEG_DEC_GFX8_ADDR_CONFIG,\n\t\t\tadev->gfx.config.gb_addr_config);\n\t\tWREG32_SOC15(JPEG, i, mmJPEG_DEC_GFX10_ADDR_CONFIG,\n\t\t\tadev->gfx.config.gb_addr_config);\n\n\t\t \n\t\tWREG32_P(SOC15_REG_OFFSET(JPEG, i, mmUVD_JMI_CNTL), 0,\n\t\t\t~UVD_JMI_CNTL__SOFT_RESET_MASK);\n\n\t\t \n\t\tWREG32_P(SOC15_REG_OFFSET(JPEG, i, mmJPEG_SYS_INT_EN),\n\t\t\tJPEG_SYS_INT_EN__DJRBC_MASK,\n\t\t\t~JPEG_SYS_INT_EN__DJRBC_MASK);\n\n\t\tWREG32_SOC15(JPEG, i, mmUVD_LMI_JRBC_RB_VMID, 0);\n\t\tWREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_CNTL, (0x00000001L | 0x00000002L));\n\t\tWREG32_SOC15(JPEG, i, mmUVD_LMI_JRBC_RB_64BIT_BAR_LOW,\n\t\t\tlower_32_bits(ring->gpu_addr));\n\t\tWREG32_SOC15(JPEG, i, mmUVD_LMI_JRBC_RB_64BIT_BAR_HIGH,\n\t\t\tupper_32_bits(ring->gpu_addr));\n\t\tWREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_RPTR, 0);\n\t\tWREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_WPTR, 0);\n\t\tWREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_CNTL, 0x00000002L);\n\t\tWREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_SIZE, ring->ring_size / 4);\n\t\tring->wptr = RREG32_SOC15(JPEG, i, mmUVD_JRBC_RB_WPTR);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int jpeg_v2_5_stop(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\t \n\t\tWREG32_P(SOC15_REG_OFFSET(JPEG, i, mmUVD_JMI_CNTL),\n\t\t\tUVD_JMI_CNTL__SOFT_RESET_MASK,\n\t\t\t~UVD_JMI_CNTL__SOFT_RESET_MASK);\n\n\t\tjpeg_v2_5_enable_clock_gating(adev, i);\n\n\t\t \n\t\tWREG32_P(SOC15_REG_OFFSET(JPEG, i, mmUVD_JPEG_POWER_STATUS),\n\t\t\tUVD_JPEG_POWER_STATUS__JPEG_POWER_STATUS_MASK,\n\t\t\t~UVD_JPEG_POWER_STATUS__JPEG_POWER_STATUS_MASK);\n\t}\n\n\treturn 0;\n}\n\n \nstatic uint64_t jpeg_v2_5_dec_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32_SOC15(JPEG, ring->me, mmUVD_JRBC_RB_RPTR);\n}\n\n \nstatic uint64_t jpeg_v2_5_dec_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->use_doorbell)\n\t\treturn *ring->wptr_cpu_addr;\n\telse\n\t\treturn RREG32_SOC15(JPEG, ring->me, mmUVD_JRBC_RB_WPTR);\n}\n\n \nstatic void jpeg_v2_5_dec_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->use_doorbell) {\n\t\t*ring->wptr_cpu_addr = lower_32_bits(ring->wptr);\n\t\tWDOORBELL32(ring->doorbell_index, lower_32_bits(ring->wptr));\n\t} else {\n\t\tWREG32_SOC15(JPEG, ring->me, mmUVD_JRBC_RB_WPTR, lower_32_bits(ring->wptr));\n\t}\n}\n\n \nstatic void jpeg_v2_6_dec_ring_insert_start(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKETJ(mmUVD_JRBC_EXTERNAL_REG_INTERNAL_OFFSET,\n\t\t0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x6aa04);  \n\n\tamdgpu_ring_write(ring, PACKETJ(JRBC_DEC_EXTERNAL_REG_WRITE_ADDR,\n\t\t0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x80000000 | (1 << (ring->me * 2 + 14)));\n}\n\n \nstatic void jpeg_v2_6_dec_ring_insert_end(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKETJ(mmUVD_JRBC_EXTERNAL_REG_INTERNAL_OFFSET,\n\t\t0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x6aa04);  \n\n\tamdgpu_ring_write(ring, PACKETJ(JRBC_DEC_EXTERNAL_REG_WRITE_ADDR,\n\t\t0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, (1 << (ring->me * 2 + 14)));\n}\n\nstatic bool jpeg_v2_5_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i, ret = 1;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tret &= (((RREG32_SOC15(JPEG, i, mmUVD_JRBC_STATUS) &\n\t\t\tUVD_JRBC_STATUS__RB_JOB_DONE_MASK) ==\n\t\t\tUVD_JRBC_STATUS__RB_JOB_DONE_MASK));\n\t}\n\n\treturn ret;\n}\n\nstatic int jpeg_v2_5_wait_for_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i, ret;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tret = SOC15_WAIT_ON_RREG(JPEG, i, mmUVD_JRBC_STATUS,\n\t\t\tUVD_JRBC_STATUS__RB_JOB_DONE_MASK,\n\t\t\tUVD_JRBC_STATUS__RB_JOB_DONE_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpeg_v2_5_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_CG_STATE_GATE);\n\tint i;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\tif (!jpeg_v2_5_is_idle(handle))\n\t\t\t\treturn -EBUSY;\n\t\t\tjpeg_v2_5_enable_clock_gating(adev, i);\n\t\t} else {\n\t\t\tjpeg_v2_5_disable_clock_gating(adev, i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpeg_v2_5_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint ret;\n\n\tif(state == adev->jpeg.cur_state)\n\t\treturn 0;\n\n\tif (state == AMD_PG_STATE_GATE)\n\t\tret = jpeg_v2_5_stop(adev);\n\telse\n\t\tret = jpeg_v2_5_start(adev);\n\n\tif(!ret)\n\t\tadev->jpeg.cur_state = state;\n\n\treturn ret;\n}\n\nstatic int jpeg_v2_5_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\treturn 0;\n}\n\nstatic int jpeg_v2_6_set_ras_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned int type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\treturn 0;\n}\n\nstatic int jpeg_v2_5_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tuint32_t ip_instance;\n\n\tswitch (entry->client_id) {\n\tcase SOC15_IH_CLIENTID_VCN:\n\t\tip_instance = 0;\n\t\tbreak;\n\tcase SOC15_IH_CLIENTID_VCN1:\n\t\tip_instance = 1;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unhandled client id: %d\\n\", entry->client_id);\n\t\treturn 0;\n\t}\n\n\tDRM_DEBUG(\"IH: JPEG TRAP\\n\");\n\n\tswitch (entry->src_id) {\n\tcase VCN_2_0__SRCID__JPEG_DECODE:\n\t\tamdgpu_fence_process(adev->jpeg.inst[ip_instance].ring_dec);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t  entry->src_id, entry->src_data[0]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs jpeg_v2_5_ip_funcs = {\n\t.name = \"jpeg_v2_5\",\n\t.early_init = jpeg_v2_5_early_init,\n\t.late_init = NULL,\n\t.sw_init = jpeg_v2_5_sw_init,\n\t.sw_fini = jpeg_v2_5_sw_fini,\n\t.hw_init = jpeg_v2_5_hw_init,\n\t.hw_fini = jpeg_v2_5_hw_fini,\n\t.suspend = jpeg_v2_5_suspend,\n\t.resume = jpeg_v2_5_resume,\n\t.is_idle = jpeg_v2_5_is_idle,\n\t.wait_for_idle = jpeg_v2_5_wait_for_idle,\n\t.check_soft_reset = NULL,\n\t.pre_soft_reset = NULL,\n\t.soft_reset = NULL,\n\t.post_soft_reset = NULL,\n\t.set_clockgating_state = jpeg_v2_5_set_clockgating_state,\n\t.set_powergating_state = jpeg_v2_5_set_powergating_state,\n};\n\nstatic const struct amd_ip_funcs jpeg_v2_6_ip_funcs = {\n\t.name = \"jpeg_v2_6\",\n\t.early_init = jpeg_v2_5_early_init,\n\t.late_init = NULL,\n\t.sw_init = jpeg_v2_5_sw_init,\n\t.sw_fini = jpeg_v2_5_sw_fini,\n\t.hw_init = jpeg_v2_5_hw_init,\n\t.hw_fini = jpeg_v2_5_hw_fini,\n\t.suspend = jpeg_v2_5_suspend,\n\t.resume = jpeg_v2_5_resume,\n\t.is_idle = jpeg_v2_5_is_idle,\n\t.wait_for_idle = jpeg_v2_5_wait_for_idle,\n\t.check_soft_reset = NULL,\n\t.pre_soft_reset = NULL,\n\t.soft_reset = NULL,\n\t.post_soft_reset = NULL,\n\t.set_clockgating_state = jpeg_v2_5_set_clockgating_state,\n\t.set_powergating_state = jpeg_v2_5_set_powergating_state,\n};\n\nstatic const struct amdgpu_ring_funcs jpeg_v2_5_dec_ring_vm_funcs = {\n\t.type = AMDGPU_RING_TYPE_VCN_JPEG,\n\t.align_mask = 0xf,\n\t.get_rptr = jpeg_v2_5_dec_ring_get_rptr,\n\t.get_wptr = jpeg_v2_5_dec_ring_get_wptr,\n\t.set_wptr = jpeg_v2_5_dec_ring_set_wptr,\n\t.emit_frame_size =\n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 6 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 8 +\n\t\t8 +  \n\t\t18 + 18 +  \n\t\t8 + 16,\n\t.emit_ib_size = 22,  \n\t.emit_ib = jpeg_v2_0_dec_ring_emit_ib,\n\t.emit_fence = jpeg_v2_0_dec_ring_emit_fence,\n\t.emit_vm_flush = jpeg_v2_0_dec_ring_emit_vm_flush,\n\t.test_ring = amdgpu_jpeg_dec_ring_test_ring,\n\t.test_ib = amdgpu_jpeg_dec_ring_test_ib,\n\t.insert_nop = jpeg_v2_0_dec_ring_nop,\n\t.insert_start = jpeg_v2_0_dec_ring_insert_start,\n\t.insert_end = jpeg_v2_0_dec_ring_insert_end,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_jpeg_ring_begin_use,\n\t.end_use = amdgpu_jpeg_ring_end_use,\n\t.emit_wreg = jpeg_v2_0_dec_ring_emit_wreg,\n\t.emit_reg_wait = jpeg_v2_0_dec_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = amdgpu_ring_emit_reg_write_reg_wait_helper,\n};\n\nstatic const struct amdgpu_ring_funcs jpeg_v2_6_dec_ring_vm_funcs = {\n\t.type = AMDGPU_RING_TYPE_VCN_JPEG,\n\t.align_mask = 0xf,\n\t.get_rptr = jpeg_v2_5_dec_ring_get_rptr,\n\t.get_wptr = jpeg_v2_5_dec_ring_get_wptr,\n\t.set_wptr = jpeg_v2_5_dec_ring_set_wptr,\n\t.emit_frame_size =\n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 6 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 8 +\n\t\t8 +  \n\t\t18 + 18 +  \n\t\t8 + 16,\n\t.emit_ib_size = 22,  \n\t.emit_ib = jpeg_v2_0_dec_ring_emit_ib,\n\t.emit_fence = jpeg_v2_0_dec_ring_emit_fence,\n\t.emit_vm_flush = jpeg_v2_0_dec_ring_emit_vm_flush,\n\t.test_ring = amdgpu_jpeg_dec_ring_test_ring,\n\t.test_ib = amdgpu_jpeg_dec_ring_test_ib,\n\t.insert_nop = jpeg_v2_0_dec_ring_nop,\n\t.insert_start = jpeg_v2_6_dec_ring_insert_start,\n\t.insert_end = jpeg_v2_6_dec_ring_insert_end,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_jpeg_ring_begin_use,\n\t.end_use = amdgpu_jpeg_ring_end_use,\n\t.emit_wreg = jpeg_v2_0_dec_ring_emit_wreg,\n\t.emit_reg_wait = jpeg_v2_0_dec_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = amdgpu_ring_emit_reg_write_reg_wait_helper,\n};\n\nstatic void jpeg_v2_5_set_dec_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\t\tif (adev->asic_type == CHIP_ARCTURUS)\n\t\t\tadev->jpeg.inst[i].ring_dec->funcs = &jpeg_v2_5_dec_ring_vm_funcs;\n\t\telse   \n\t\t\tadev->jpeg.inst[i].ring_dec->funcs = &jpeg_v2_6_dec_ring_vm_funcs;\n\t\tadev->jpeg.inst[i].ring_dec->me = i;\n\t\tDRM_INFO(\"JPEG(%d) JPEG decode is enabled in VM mode\\n\", i);\n\t}\n}\n\nstatic const struct amdgpu_irq_src_funcs jpeg_v2_5_irq_funcs = {\n\t.set = jpeg_v2_5_set_interrupt_state,\n\t.process = jpeg_v2_5_process_interrupt,\n};\n\nstatic const struct amdgpu_irq_src_funcs jpeg_v2_6_ras_irq_funcs = {\n\t.set = jpeg_v2_6_set_ras_interrupt_state,\n\t.process = amdgpu_jpeg_process_poison_irq,\n};\n\nstatic void jpeg_v2_5_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tadev->jpeg.inst[i].irq.num_types = 1;\n\t\tadev->jpeg.inst[i].irq.funcs = &jpeg_v2_5_irq_funcs;\n\n\t\tadev->jpeg.inst[i].ras_poison_irq.num_types = 1;\n\t\tadev->jpeg.inst[i].ras_poison_irq.funcs = &jpeg_v2_6_ras_irq_funcs;\n\t}\n}\n\nconst struct amdgpu_ip_block_version jpeg_v2_5_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_JPEG,\n\t\t.major = 2,\n\t\t.minor = 5,\n\t\t.rev = 0,\n\t\t.funcs = &jpeg_v2_5_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version jpeg_v2_6_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_JPEG,\n\t\t.major = 2,\n\t\t.minor = 6,\n\t\t.rev = 0,\n\t\t.funcs = &jpeg_v2_6_ip_funcs,\n};\n\nstatic uint32_t jpeg_v2_6_query_poison_by_instance(struct amdgpu_device *adev,\n\t\tuint32_t instance, uint32_t sub_block)\n{\n\tuint32_t poison_stat = 0, reg_value = 0;\n\n\tswitch (sub_block) {\n\tcase AMDGPU_JPEG_V2_6_JPEG0:\n\t\treg_value = RREG32_SOC15(JPEG, instance, mmUVD_RAS_JPEG0_STATUS);\n\t\tpoison_stat = REG_GET_FIELD(reg_value, UVD_RAS_JPEG0_STATUS, POISONED_PF);\n\t\tbreak;\n\tcase AMDGPU_JPEG_V2_6_JPEG1:\n\t\treg_value = RREG32_SOC15(JPEG, instance, mmUVD_RAS_JPEG1_STATUS);\n\t\tpoison_stat = REG_GET_FIELD(reg_value, UVD_RAS_JPEG1_STATUS, POISONED_PF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (poison_stat)\n\t\tdev_info(adev->dev, \"Poison detected in JPEG%d sub_block%d\\n\",\n\t\t\tinstance, sub_block);\n\n\treturn poison_stat;\n}\n\nstatic bool jpeg_v2_6_query_ras_poison_status(struct amdgpu_device *adev)\n{\n\tuint32_t inst = 0, sub = 0, poison_stat = 0;\n\n\tfor (inst = 0; inst < adev->jpeg.num_jpeg_inst; inst++)\n\t\tfor (sub = 0; sub < AMDGPU_JPEG_V2_6_MAX_SUB_BLOCK; sub++)\n\t\t\tpoison_stat +=\n\t\t\tjpeg_v2_6_query_poison_by_instance(adev, inst, sub);\n\n\treturn !!poison_stat;\n}\n\nconst struct amdgpu_ras_block_hw_ops jpeg_v2_6_ras_hw_ops = {\n\t.query_poison_status = jpeg_v2_6_query_ras_poison_status,\n};\n\nstatic struct amdgpu_jpeg_ras jpeg_v2_6_ras = {\n\t.ras_block = {\n\t\t.hw_ops = &jpeg_v2_6_ras_hw_ops,\n\t\t.ras_late_init = amdgpu_jpeg_ras_late_init,\n\t},\n};\n\nstatic void jpeg_v2_5_set_ras_funcs(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[JPEG_HWIP][0]) {\n\tcase IP_VERSION(2, 6, 0):\n\t\tadev->jpeg.ras = &jpeg_v2_6_ras;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}