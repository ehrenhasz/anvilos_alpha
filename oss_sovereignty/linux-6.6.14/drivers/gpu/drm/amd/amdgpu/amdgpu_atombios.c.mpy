{
  "module_name": "amdgpu_atombios.c",
  "hash_id": "1b15811ce56fd337884f4d0b4d73231e5d224b88ae8b4fc5dbccf68fa2a18e98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_i2c.h\"\n#include \"amdgpu_display.h\"\n\n#include \"atom.h\"\n#include \"atom-bits.h\"\n#include \"atombios_encoders.h\"\n#include \"bif/bif_4_1_d.h\"\n\nstatic void amdgpu_atombios_lookup_i2c_gpio_quirks(struct amdgpu_device *adev,\n\t\t\t\t\t  ATOM_GPIO_I2C_ASSIGMENT *gpio,\n\t\t\t\t\t  u8 index)\n{\n\n}\n\nstatic struct amdgpu_i2c_bus_rec amdgpu_atombios_get_bus_rec_for_i2c_gpio(ATOM_GPIO_I2C_ASSIGMENT *gpio)\n{\n\tstruct amdgpu_i2c_bus_rec i2c;\n\n\tmemset(&i2c, 0, sizeof(struct amdgpu_i2c_bus_rec));\n\n\ti2c.mask_clk_reg = le16_to_cpu(gpio->usClkMaskRegisterIndex);\n\ti2c.mask_data_reg = le16_to_cpu(gpio->usDataMaskRegisterIndex);\n\ti2c.en_clk_reg = le16_to_cpu(gpio->usClkEnRegisterIndex);\n\ti2c.en_data_reg = le16_to_cpu(gpio->usDataEnRegisterIndex);\n\ti2c.y_clk_reg = le16_to_cpu(gpio->usClkY_RegisterIndex);\n\ti2c.y_data_reg = le16_to_cpu(gpio->usDataY_RegisterIndex);\n\ti2c.a_clk_reg = le16_to_cpu(gpio->usClkA_RegisterIndex);\n\ti2c.a_data_reg = le16_to_cpu(gpio->usDataA_RegisterIndex);\n\ti2c.mask_clk_mask = (1 << gpio->ucClkMaskShift);\n\ti2c.mask_data_mask = (1 << gpio->ucDataMaskShift);\n\ti2c.en_clk_mask = (1 << gpio->ucClkEnShift);\n\ti2c.en_data_mask = (1 << gpio->ucDataEnShift);\n\ti2c.y_clk_mask = (1 << gpio->ucClkY_Shift);\n\ti2c.y_data_mask = (1 << gpio->ucDataY_Shift);\n\ti2c.a_clk_mask = (1 << gpio->ucClkA_Shift);\n\ti2c.a_data_mask = (1 << gpio->ucDataA_Shift);\n\n\tif (gpio->sucI2cId.sbfAccess.bfHW_Capable)\n\t\ti2c.hw_capable = true;\n\telse\n\t\ti2c.hw_capable = false;\n\n\tif (gpio->sucI2cId.ucAccess == 0xa0)\n\t\ti2c.mm_i2c = true;\n\telse\n\t\ti2c.mm_i2c = false;\n\n\ti2c.i2c_id = gpio->sucI2cId.ucAccess;\n\n\tif (i2c.mask_clk_reg)\n\t\ti2c.valid = true;\n\telse\n\t\ti2c.valid = false;\n\n\treturn i2c;\n}\n\nstruct amdgpu_i2c_bus_rec amdgpu_atombios_lookup_i2c_gpio(struct amdgpu_device *adev,\n\t\t\t\t\t\t\t  uint8_t id)\n{\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\tATOM_GPIO_I2C_ASSIGMENT *gpio;\n\tstruct amdgpu_i2c_bus_rec i2c;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\n\tstruct _ATOM_GPIO_I2C_INFO *i2c_info;\n\tuint16_t data_offset, size;\n\tint i, num_indices;\n\n\tmemset(&i2c, 0, sizeof(struct amdgpu_i2c_bus_rec));\n\ti2c.valid = false;\n\n\tif (amdgpu_atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\ti2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_I2C_ASSIGMENT);\n\n\t\tgpio = &i2c_info->asGPIO_Info[0];\n\t\tfor (i = 0; i < num_indices; i++) {\n\n\t\t\tamdgpu_atombios_lookup_i2c_gpio_quirks(adev, gpio, i);\n\n\t\t\tif (gpio->sucI2cId.ucAccess == id) {\n\t\t\t\ti2c = amdgpu_atombios_get_bus_rec_for_i2c_gpio(gpio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgpio = (ATOM_GPIO_I2C_ASSIGMENT *)\n\t\t\t\t((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\n\t\t}\n\t}\n\n\treturn i2c;\n}\n\nvoid amdgpu_atombios_i2c_init(struct amdgpu_device *adev)\n{\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\tATOM_GPIO_I2C_ASSIGMENT *gpio;\n\tstruct amdgpu_i2c_bus_rec i2c;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\n\tstruct _ATOM_GPIO_I2C_INFO *i2c_info;\n\tuint16_t data_offset, size;\n\tint i, num_indices;\n\tchar stmp[32];\n\n\tif (amdgpu_atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\ti2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_I2C_ASSIGMENT);\n\n\t\tgpio = &i2c_info->asGPIO_Info[0];\n\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\tamdgpu_atombios_lookup_i2c_gpio_quirks(adev, gpio, i);\n\n\t\t\ti2c = amdgpu_atombios_get_bus_rec_for_i2c_gpio(gpio);\n\n\t\t\tif (i2c.valid) {\n\t\t\t\tsprintf(stmp, \"0x%x\", i2c.i2c_id);\n\t\t\t\tadev->i2c_bus[i] = amdgpu_i2c_create(adev_to_drm(adev), &i2c, stmp);\n\t\t\t}\n\t\t\tgpio = (ATOM_GPIO_I2C_ASSIGMENT *)\n\t\t\t\t((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\n\t\t}\n\t}\n}\n\nstruct amdgpu_gpio_rec\namdgpu_atombios_lookup_gpio(struct amdgpu_device *adev,\n\t\t\t    u8 id)\n{\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\tstruct amdgpu_gpio_rec gpio;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_Pin_LUT);\n\tstruct _ATOM_GPIO_PIN_LUT *gpio_info;\n\tATOM_GPIO_PIN_ASSIGNMENT *pin;\n\tu16 data_offset, size;\n\tint i, num_indices;\n\n\tmemset(&gpio, 0, sizeof(struct amdgpu_gpio_rec));\n\tgpio.valid = false;\n\n\tif (amdgpu_atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\tgpio_info = (struct _ATOM_GPIO_PIN_LUT *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_PIN_ASSIGNMENT);\n\n\t\tpin = gpio_info->asGPIO_Pin;\n\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\tif (id == pin->ucGPIO_ID) {\n\t\t\t\tgpio.id = pin->ucGPIO_ID;\n\t\t\t\tgpio.reg = le16_to_cpu(pin->usGpioPin_AIndex);\n\t\t\t\tgpio.shift = pin->ucGpioPinBitShift;\n\t\t\t\tgpio.mask = (1 << pin->ucGpioPinBitShift);\n\t\t\t\tgpio.valid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpin = (ATOM_GPIO_PIN_ASSIGNMENT *)\n\t\t\t\t((u8 *)pin + sizeof(ATOM_GPIO_PIN_ASSIGNMENT));\n\t\t}\n\t}\n\n\treturn gpio;\n}\n\nstatic struct amdgpu_hpd\namdgpu_atombios_get_hpd_info_from_gpio(struct amdgpu_device *adev,\n\t\t\t\t       struct amdgpu_gpio_rec *gpio)\n{\n\tstruct amdgpu_hpd hpd;\n\tu32 reg;\n\n\tmemset(&hpd, 0, sizeof(struct amdgpu_hpd));\n\n\treg = amdgpu_display_hpd_get_gpio_reg(adev);\n\n\thpd.gpio = *gpio;\n\tif (gpio->reg == reg) {\n\t\tswitch(gpio->mask) {\n\t\tcase (1 << 0):\n\t\t\thpd.hpd = AMDGPU_HPD_1;\n\t\t\tbreak;\n\t\tcase (1 << 8):\n\t\t\thpd.hpd = AMDGPU_HPD_2;\n\t\t\tbreak;\n\t\tcase (1 << 16):\n\t\t\thpd.hpd = AMDGPU_HPD_3;\n\t\t\tbreak;\n\t\tcase (1 << 24):\n\t\t\thpd.hpd = AMDGPU_HPD_4;\n\t\t\tbreak;\n\t\tcase (1 << 26):\n\t\t\thpd.hpd = AMDGPU_HPD_5;\n\t\t\tbreak;\n\t\tcase (1 << 28):\n\t\t\thpd.hpd = AMDGPU_HPD_6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thpd.hpd = AMDGPU_HPD_NONE;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\thpd.hpd = AMDGPU_HPD_NONE;\n\treturn hpd;\n}\n\nstatic const int object_connector_convert[] = {\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_DVII,\n\tDRM_MODE_CONNECTOR_DVII,\n\tDRM_MODE_CONNECTOR_DVID,\n\tDRM_MODE_CONNECTOR_DVID,\n\tDRM_MODE_CONNECTOR_VGA,\n\tDRM_MODE_CONNECTOR_Composite,\n\tDRM_MODE_CONNECTOR_SVIDEO,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_9PinDIN,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_HDMIA,\n\tDRM_MODE_CONNECTOR_HDMIB,\n\tDRM_MODE_CONNECTOR_LVDS,\n\tDRM_MODE_CONNECTOR_9PinDIN,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_DisplayPort,\n\tDRM_MODE_CONNECTOR_eDP,\n\tDRM_MODE_CONNECTOR_Unknown\n};\n\nbool amdgpu_atombios_has_dce_engine_info(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tstruct atom_context *ctx = mode_info->atom_context;\n\tint index = GetIndexIntoMasterTable(DATA, Object_Header);\n\tu16 size, data_offset;\n\tu8 frev, crev;\n\tATOM_DISPLAY_OBJECT_PATH_TABLE *path_obj;\n\tATOM_OBJECT_HEADER *obj_header;\n\n\tif (!amdgpu_atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tif (crev < 2)\n\t\treturn false;\n\n\tobj_header = (ATOM_OBJECT_HEADER *) (ctx->bios + data_offset);\n\tpath_obj = (ATOM_DISPLAY_OBJECT_PATH_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usDisplayPathTableOffset));\n\n\tif (path_obj->ucNumOfDispPath)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool amdgpu_atombios_get_connector_info_from_object_table(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tstruct atom_context *ctx = mode_info->atom_context;\n\tint index = GetIndexIntoMasterTable(DATA, Object_Header);\n\tu16 size, data_offset;\n\tu8 frev, crev;\n\tATOM_CONNECTOR_OBJECT_TABLE *con_obj;\n\tATOM_ENCODER_OBJECT_TABLE *enc_obj;\n\tATOM_OBJECT_TABLE *router_obj;\n\tATOM_DISPLAY_OBJECT_PATH_TABLE *path_obj;\n\tATOM_OBJECT_HEADER *obj_header;\n\tint i, j, k, path_size, device_support;\n\tint connector_type;\n\tu16 conn_id, connector_object_id;\n\tstruct amdgpu_i2c_bus_rec ddc_bus;\n\tstruct amdgpu_router router;\n\tstruct amdgpu_gpio_rec gpio;\n\tstruct amdgpu_hpd hpd;\n\n\tif (!amdgpu_atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tif (crev < 2)\n\t\treturn false;\n\n\tobj_header = (ATOM_OBJECT_HEADER *) (ctx->bios + data_offset);\n\tpath_obj = (ATOM_DISPLAY_OBJECT_PATH_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usDisplayPathTableOffset));\n\tcon_obj = (ATOM_CONNECTOR_OBJECT_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usConnectorObjectTableOffset));\n\tenc_obj = (ATOM_ENCODER_OBJECT_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usEncoderObjectTableOffset));\n\trouter_obj = (ATOM_OBJECT_TABLE *)\n\t\t(ctx->bios + data_offset +\n\t\t le16_to_cpu(obj_header->usRouterObjectTableOffset));\n\tdevice_support = le16_to_cpu(obj_header->usDeviceSupport);\n\n\tpath_size = 0;\n\tfor (i = 0; i < path_obj->ucNumOfDispPath; i++) {\n\t\tuint8_t *addr = (uint8_t *) path_obj->asDispPath;\n\t\tATOM_DISPLAY_OBJECT_PATH *path;\n\t\taddr += path_size;\n\t\tpath = (ATOM_DISPLAY_OBJECT_PATH *) addr;\n\t\tpath_size += le16_to_cpu(path->usSize);\n\n\t\tif (device_support & le16_to_cpu(path->usDeviceTag)) {\n\t\t\tuint8_t con_obj_id =\n\t\t\t    (le16_to_cpu(path->usConnObjectId) & OBJECT_ID_MASK)\n\t\t\t    >> OBJECT_ID_SHIFT;\n\n\t\t\t \n\t\t\tif ((le16_to_cpu(path->usDeviceTag) ==\n\t\t\t     ATOM_DEVICE_TV1_SUPPORT) ||\n\t\t\t    (le16_to_cpu(path->usDeviceTag) ==\n\t\t\t     ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\tcontinue;\n\n\t\t\tif (con_obj_id >= ARRAY_SIZE(object_connector_convert)) {\n\t\t\t\tDRM_ERROR(\"invalid con_obj_id %d for device tag 0x%04x\\n\",\n\t\t\t\t\t  con_obj_id, le16_to_cpu(path->usDeviceTag));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconnector_type =\n\t\t\t\tobject_connector_convert[con_obj_id];\n\t\t\tconnector_object_id = con_obj_id;\n\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_Unknown)\n\t\t\t\tcontinue;\n\n\t\t\trouter.ddc_valid = false;\n\t\t\trouter.cd_valid = false;\n\t\t\tfor (j = 0; j < ((le16_to_cpu(path->usSize) - 8) / 2); j++) {\n\t\t\t\tuint8_t grph_obj_type =\n\t\t\t\t    (le16_to_cpu(path->usGraphicObjIds[j]) &\n\t\t\t\t     OBJECT_TYPE_MASK) >> OBJECT_TYPE_SHIFT;\n\n\t\t\t\tif (grph_obj_type == GRAPH_OBJECT_TYPE_ENCODER) {\n\t\t\t\t\tfor (k = 0; k < enc_obj->ucNumberOfObjects; k++) {\n\t\t\t\t\t\tu16 encoder_obj = le16_to_cpu(enc_obj->asObjects[k].usObjectID);\n\t\t\t\t\t\tif (le16_to_cpu(path->usGraphicObjIds[j]) == encoder_obj) {\n\t\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(enc_obj->asObjects[k].usRecordOffset));\n\t\t\t\t\t\t\tATOM_ENCODER_CAP_RECORD *cap_record;\n\t\t\t\t\t\t\tu16 caps = 0;\n\n\t\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\t\tcase ATOM_ENCODER_CAP_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tcap_record =(ATOM_ENCODER_CAP_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\tcaps = le16_to_cpu(cap_record->usEncoderCap);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trecord = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t\t((char *)record + record->ucRecordSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tamdgpu_display_add_encoder(adev, encoder_obj,\n\t\t\t\t\t\t\t\t\t\t    le16_to_cpu(path->usDeviceTag),\n\t\t\t\t\t\t\t\t\t\t    caps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (grph_obj_type == GRAPH_OBJECT_TYPE_ROUTER) {\n\t\t\t\t\tfor (k = 0; k < router_obj->ucNumberOfObjects; k++) {\n\t\t\t\t\t\tu16 router_obj_id = le16_to_cpu(router_obj->asObjects[k].usObjectID);\n\t\t\t\t\t\tif (le16_to_cpu(path->usGraphicObjIds[j]) == router_obj_id) {\n\t\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(router_obj->asObjects[k].usRecordOffset));\n\t\t\t\t\t\t\tATOM_I2C_RECORD *i2c_record;\n\t\t\t\t\t\t\tATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\n\t\t\t\t\t\t\tATOM_ROUTER_DDC_PATH_SELECT_RECORD *ddc_path;\n\t\t\t\t\t\t\tATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *cd_path;\n\t\t\t\t\t\t\tATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *router_src_dst_table =\n\t\t\t\t\t\t\t\t(ATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(router_obj->asObjects[k].usSrcDstTableOffset));\n\t\t\t\t\t\t\tu8 *num_dst_objs = (u8 *)\n\t\t\t\t\t\t\t\t((u8 *)router_src_dst_table + 1 +\n\t\t\t\t\t\t\t\t (router_src_dst_table->ucNumberOfSrc * 2));\n\t\t\t\t\t\t\tu16 *dst_objs = (u16 *)(num_dst_objs + 1);\n\t\t\t\t\t\t\tint enum_id;\n\n\t\t\t\t\t\t\trouter.router_id = router_obj_id;\n\t\t\t\t\t\t\tfor (enum_id = 0; enum_id < (*num_dst_objs); enum_id++) {\n\t\t\t\t\t\t\t\tif (le16_to_cpu(path->usConnObjectId) ==\n\t\t\t\t\t\t\t\t    le16_to_cpu(dst_objs[enum_id]))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\t\tcase ATOM_I2C_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\ti2c_record =\n\t\t\t\t\t\t\t\t\t\t(ATOM_I2C_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\ti2c_config =\n\t\t\t\t\t\t\t\t\t\t(ATOM_I2C_ID_CONFIG_ACCESS *)\n\t\t\t\t\t\t\t\t\t\t&i2c_record->sucI2cId;\n\t\t\t\t\t\t\t\t\trouter.i2c_info =\n\t\t\t\t\t\t\t\t\t\tamdgpu_atombios_lookup_i2c_gpio(adev,\n\t\t\t\t\t\t\t\t\t\t\t\t       i2c_config->\n\t\t\t\t\t\t\t\t\t\t\t\t       ucAccess);\n\t\t\t\t\t\t\t\t\trouter.i2c_addr = i2c_record->ucI2CAddr >> 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase ATOM_ROUTER_DDC_PATH_SELECT_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tddc_path = (ATOM_ROUTER_DDC_PATH_SELECT_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\trouter.ddc_valid = true;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_type = ddc_path->ucMuxType;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_control_pin = ddc_path->ucMuxControlPin;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_state = ddc_path->ucMuxState[enum_id];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tcd_path = (ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\trouter.cd_valid = true;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_type = cd_path->ucMuxType;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_control_pin = cd_path->ucMuxControlPin;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_state = cd_path->ucMuxState[enum_id];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trecord = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t\t((char *)record + record->ucRecordSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tddc_bus.valid = false;\n\t\t\thpd.hpd = AMDGPU_HPD_NONE;\n\t\t\tif ((le16_to_cpu(path->usDeviceTag) &\n\t\t\t     (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) == 0) {\n\t\t\t\tfor (j = 0; j < con_obj->ucNumberOfObjects; j++) {\n\t\t\t\t\tif (le16_to_cpu(path->usConnObjectId) ==\n\t\t\t\t\t    le16_to_cpu(con_obj->asObjects[j].\n\t\t\t\t\t\t\tusObjectID)) {\n\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t    *record =\n\t\t\t\t\t\t    (ATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t     *)\n\t\t\t\t\t\t    (ctx->bios + data_offset +\n\t\t\t\t\t\t     le16_to_cpu(con_obj->\n\t\t\t\t\t\t\t\t asObjects[j].\n\t\t\t\t\t\t\t\t usRecordOffset));\n\t\t\t\t\t\tATOM_I2C_RECORD *i2c_record;\n\t\t\t\t\t\tATOM_HPD_INT_RECORD *hpd_record;\n\t\t\t\t\t\tATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\n\n\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\tcase ATOM_I2C_RECORD_TYPE:\n\t\t\t\t\t\t\t\ti2c_record =\n\t\t\t\t\t\t\t\t    (ATOM_I2C_RECORD *)\n\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\ti2c_config =\n\t\t\t\t\t\t\t\t\t(ATOM_I2C_ID_CONFIG_ACCESS *)\n\t\t\t\t\t\t\t\t\t&i2c_record->sucI2cId;\n\t\t\t\t\t\t\t\tddc_bus = amdgpu_atombios_lookup_i2c_gpio(adev,\n\t\t\t\t\t\t\t\t\t\t\t\t i2c_config->\n\t\t\t\t\t\t\t\t\t\t\t\t ucAccess);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ATOM_HPD_INT_RECORD_TYPE:\n\t\t\t\t\t\t\t\thpd_record =\n\t\t\t\t\t\t\t\t\t(ATOM_HPD_INT_RECORD *)\n\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\tgpio = amdgpu_atombios_lookup_gpio(adev,\n\t\t\t\t\t\t\t\t\t\t\t  hpd_record->ucHPDIntGPIOID);\n\t\t\t\t\t\t\t\thpd = amdgpu_atombios_get_hpd_info_from_gpio(adev, &gpio);\n\t\t\t\t\t\t\t\thpd.plugged_state = hpd_record->ucPlugged_PinState;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trecord =\n\t\t\t\t\t\t\t    (ATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t\t     *) ((char *)record\n\t\t\t\t\t\t\t\t +\n\t\t\t\t\t\t\t\t record->\n\t\t\t\t\t\t\t\t ucRecordSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tddc_bus.hpd = hpd.hpd;\n\n\t\t\tconn_id = le16_to_cpu(path->usConnObjectId);\n\n\t\t\tamdgpu_display_add_connector(adev,\n\t\t\t\t\t\t      conn_id,\n\t\t\t\t\t\t      le16_to_cpu(path->usDeviceTag),\n\t\t\t\t\t\t      connector_type, &ddc_bus,\n\t\t\t\t\t\t      connector_object_id,\n\t\t\t\t\t\t      &hpd,\n\t\t\t\t\t\t      &router);\n\n\t\t}\n\t}\n\n\tamdgpu_link_encoder_connector(adev_to_drm(adev));\n\n\treturn true;\n}\n\nunion firmware_info {\n\tATOM_FIRMWARE_INFO info;\n\tATOM_FIRMWARE_INFO_V1_2 info_12;\n\tATOM_FIRMWARE_INFO_V1_3 info_13;\n\tATOM_FIRMWARE_INFO_V1_4 info_14;\n\tATOM_FIRMWARE_INFO_V2_1 info_21;\n\tATOM_FIRMWARE_INFO_V2_2 info_22;\n};\n\nint amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\n\tuint8_t frev, crev;\n\tuint16_t data_offset;\n\tint ret = -EINVAL;\n\n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tint i;\n\t\tstruct amdgpu_pll *ppll = &adev->clock.ppll[0];\n\t\tstruct amdgpu_pll *spll = &adev->clock.spll;\n\t\tstruct amdgpu_pll *mpll = &adev->clock.mpll;\n\t\tunion firmware_info *firmware_info =\n\t\t\t(union firmware_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tdata_offset);\n\t\t \n\t\tppll->reference_freq =\n\t\t    le16_to_cpu(firmware_info->info.usReferenceClock);\n\t\tppll->reference_div = 0;\n\n\t\tppll->pll_out_min =\n\t\t\tle32_to_cpu(firmware_info->info_12.ulMinPixelClockPLL_Output);\n\t\tppll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxPixelClockPLL_Output);\n\n\t\tppll->lcd_pll_out_min =\n\t\t\tle16_to_cpu(firmware_info->info_14.usLcdMinPixelClockPLL_Output) * 100;\n\t\tif (ppll->lcd_pll_out_min == 0)\n\t\t\tppll->lcd_pll_out_min = ppll->pll_out_min;\n\t\tppll->lcd_pll_out_max =\n\t\t\tle16_to_cpu(firmware_info->info_14.usLcdMaxPixelClockPLL_Output) * 100;\n\t\tif (ppll->lcd_pll_out_max == 0)\n\t\t\tppll->lcd_pll_out_max = ppll->pll_out_max;\n\n\t\tif (ppll->pll_out_min == 0)\n\t\t\tppll->pll_out_min = 64800;\n\n\t\tppll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinPixelClockPLL_Input);\n\t\tppll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxPixelClockPLL_Input);\n\n\t\tppll->min_post_div = 2;\n\t\tppll->max_post_div = 0x7f;\n\t\tppll->min_frac_feedback_div = 0;\n\t\tppll->max_frac_feedback_div = 9;\n\t\tppll->min_ref_div = 2;\n\t\tppll->max_ref_div = 0x3ff;\n\t\tppll->min_feedback_div = 4;\n\t\tppll->max_feedback_div = 0xfff;\n\t\tppll->best_vco = 0;\n\n\t\tfor (i = 1; i < AMDGPU_MAX_PPLL; i++)\n\t\t\tadev->clock.ppll[i] = *ppll;\n\n\t\t \n\t\tspll->reference_freq =\n\t\t\tle16_to_cpu(firmware_info->info_21.usCoreReferenceClock);\n\t\tspll->reference_div = 0;\n\n\t\tspll->pll_out_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinEngineClockPLL_Output);\n\t\tspll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxEngineClockPLL_Output);\n\n\t\t \n\t\tif (spll->pll_out_min == 0)\n\t\t\tspll->pll_out_min = 64800;\n\n\t\tspll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinEngineClockPLL_Input);\n\t\tspll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxEngineClockPLL_Input);\n\n\t\tspll->min_post_div = 1;\n\t\tspll->max_post_div = 1;\n\t\tspll->min_ref_div = 2;\n\t\tspll->max_ref_div = 0xff;\n\t\tspll->min_feedback_div = 4;\n\t\tspll->max_feedback_div = 0xff;\n\t\tspll->best_vco = 0;\n\n\t\t \n\t\tmpll->reference_freq =\n\t\t\tle16_to_cpu(firmware_info->info_21.usMemoryReferenceClock);\n\t\tmpll->reference_div = 0;\n\n\t\tmpll->pll_out_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Output);\n\t\tmpll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxMemoryClockPLL_Output);\n\n\t\t \n\t\tif (mpll->pll_out_min == 0)\n\t\t\tmpll->pll_out_min = 64800;\n\n\t\tmpll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Input);\n\t\tmpll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxMemoryClockPLL_Input);\n\n\t\tadev->clock.default_sclk =\n\t\t    le32_to_cpu(firmware_info->info.ulDefaultEngineClock);\n\t\tadev->clock.default_mclk =\n\t\t    le32_to_cpu(firmware_info->info.ulDefaultMemoryClock);\n\n\t\tmpll->min_post_div = 1;\n\t\tmpll->max_post_div = 1;\n\t\tmpll->min_ref_div = 2;\n\t\tmpll->max_ref_div = 0xff;\n\t\tmpll->min_feedback_div = 4;\n\t\tmpll->max_feedback_div = 0xff;\n\t\tmpll->best_vco = 0;\n\n\t\t \n\t\tadev->clock.default_dispclk =\n\t\t\tle32_to_cpu(firmware_info->info_21.ulDefaultDispEngineClkFreq);\n\t\t \n\t\tif (adev->clock.default_dispclk < 53900) {\n\t\t\tDRM_DEBUG(\"Changing default dispclk from %dMhz to 600Mhz\\n\",\n\t\t\t\t  adev->clock.default_dispclk / 100);\n\t\t\tadev->clock.default_dispclk = 60000;\n\t\t} else if (adev->clock.default_dispclk <= 60000) {\n\t\t\tDRM_DEBUG(\"Changing default dispclk from %dMhz to 625Mhz\\n\",\n\t\t\t\t  adev->clock.default_dispclk / 100);\n\t\t\tadev->clock.default_dispclk = 62500;\n\t\t}\n\t\tadev->clock.dp_extclk =\n\t\t\tle16_to_cpu(firmware_info->info_21.usUniphyDPModeExtClkFreq);\n\t\tadev->clock.current_dispclk = adev->clock.default_dispclk;\n\n\t\tadev->clock.max_pixel_clock = le16_to_cpu(firmware_info->info.usMaxPixelClock);\n\t\tif (adev->clock.max_pixel_clock == 0)\n\t\t\tadev->clock.max_pixel_clock = 40000;\n\n\t\t \n\t\tadev->mode_info.firmware_flags =\n\t\t\tle16_to_cpu(firmware_info->info.usFirmwareCapability.susAccess);\n\n\t\tret = 0;\n\t}\n\n\tadev->pm.current_sclk = adev->clock.default_sclk;\n\tadev->pm.current_mclk = adev->clock.default_mclk;\n\n\treturn ret;\n}\n\nunion gfx_info {\n\tATOM_GFX_INFO_V2_1 info;\n};\n\nint amdgpu_atombios_get_gfx_info(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, GFX_Info);\n\tuint8_t frev, crev;\n\tuint16_t data_offset;\n\tint ret = -EINVAL;\n\n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tunion gfx_info *gfx_info = (union gfx_info *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\n\t\tadev->gfx.config.max_shader_engines = gfx_info->info.max_shader_engines;\n\t\tadev->gfx.config.max_tile_pipes = gfx_info->info.max_tile_pipes;\n\t\tadev->gfx.config.max_cu_per_sh = gfx_info->info.max_cu_per_sh;\n\t\tadev->gfx.config.max_sh_per_se = gfx_info->info.max_sh_per_se;\n\t\tadev->gfx.config.max_backends_per_se = gfx_info->info.max_backends_per_se;\n\t\tadev->gfx.config.max_texture_channel_caches =\n\t\t\tgfx_info->info.max_texture_channel_caches;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V6 info_6;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_7 info_7;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_8 info_8;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_9 info_9;\n};\n\n \nint amdgpu_atombios_get_vram_width(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tu16 data_offset, size;\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\n\t \n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\t\tswitch (crev) {\n\t\tcase 8:\n\t\tcase 9:\n\t\t\treturn igp_info->info_8.ucUMAChannelNumber * 64;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void amdgpu_atombios_get_igp_ss_overrides(struct amdgpu_device *adev,\n\t\t\t\t\t\t struct amdgpu_atom_ss *ss,\n\t\t\t\t\t\t int id)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tu16 data_offset, size;\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 percentage = 0, rate = 0;\n\n\t \n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\t\tswitch (crev) {\n\t\tcase 6:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_9.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_9.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_9.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_9.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_9.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_9.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tif (percentage)\n\t\t\tss->percentage = percentage;\n\t\tif (rate)\n\t\t\tss->rate = rate;\n\t}\n}\n\nunion asic_ss_info {\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO info;\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO_V2 info_2;\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO_V3 info_3;\n};\n\nunion asic_ss_assignment {\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT v1;\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT_V2 v2;\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT_V3 v3;\n};\n\nbool amdgpu_atombios_get_asic_ss_info(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_atom_ss *ss,\n\t\t\t\t      int id, u32 clock)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);\n\tuint16_t data_offset, size;\n\tunion asic_ss_info *ss_info;\n\tunion asic_ss_assignment *ss_assign;\n\tuint8_t frev, crev;\n\tint i, num_indices;\n\n\tif (id == ASIC_INTERNAL_MEMORY_SS) {\n\t\tif (!(adev->mode_info.firmware_flags & ATOM_BIOS_INFO_MEMORY_CLOCK_SS_SUPPORT))\n\t\t\treturn false;\n\t}\n\tif (id == ASIC_INTERNAL_ENGINE_SS) {\n\t\tif (!(adev->mode_info.firmware_flags & ATOM_BIOS_INFO_ENGINE_CLOCK_SS_SUPPORT))\n\t\t\treturn false;\n\t}\n\n\tmemset(ss, 0, sizeof(struct amdgpu_atom_ss));\n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\n\t\tss_info =\n\t\t\t(union asic_ss_info *)(mode_info->atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT);\n\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v1.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v1.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v1.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v1.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v1.usSpreadRateInKhz);\n\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_2.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v2.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v2.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v2.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v2.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v2.usSpreadRateIn10Hz);\n\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\tif ((crev == 2) &&\n\t\t\t\t\t    ((id == ASIC_INTERNAL_ENGINE_SS) ||\n\t\t\t\t\t     (id == ASIC_INTERNAL_MEMORY_SS)))\n\t\t\t\t\t\tss->rate /= 100;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_3.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v3.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v3.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v3.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v3.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v3.usSpreadRateIn10Hz);\n\t\t\t\t\tif (ss_assign->v3.ucSpreadSpectrumMode &\n\t\t\t\t\t    SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK)\n\t\t\t\t\t\tss->percentage_divider = 1000;\n\t\t\t\t\telse\n\t\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\tif ((id == ASIC_INTERNAL_ENGINE_SS) ||\n\t\t\t\t\t    (id == ASIC_INTERNAL_MEMORY_SS))\n\t\t\t\t\t\tss->rate /= 100;\n\t\t\t\t\tif (adev->flags & AMD_IS_APU)\n\t\t\t\t\t\tamdgpu_atombios_get_igp_ss_overrides(adev, ss, id);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unsupported ASIC_InternalSS_Info table: %d %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nunion get_clock_dividers {\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS v1;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V2 v2;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V3 v3;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V4 v4;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V5 v5;\n\tstruct _COMPUTE_GPU_CLOCK_INPUT_PARAMETERS_V1_6 v6_in;\n\tstruct _COMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 v6_out;\n};\n\nint amdgpu_atombios_get_clock_dividers(struct amdgpu_device *adev,\n\t\t\t\t       u8 clock_type,\n\t\t\t\t       u32 clock,\n\t\t\t\t       bool strobe_mode,\n\t\t\t\t       struct atom_clock_dividers *dividers)\n{\n\tunion get_clock_dividers args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL);\n\tu8 frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\tmemset(dividers, 0, sizeof(struct atom_clock_dividers));\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t \n\t\tif (clock_type == COMPUTE_ENGINE_PLL_PARAM) {\n\t\t\targs.v3.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\n\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\tdividers->post_div = args.v3.ucPostDiv;\n\t\t\tdividers->enable_post_div = (args.v3.ucCntlFlag &\n\t\t\t\t\t\t     ATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\n\t\t\tdividers->enable_dithen = (args.v3.ucCntlFlag &\n\t\t\t\t\t\t   ATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\n\t\t\tdividers->whole_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDiv);\n\t\t\tdividers->frac_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDivFrac);\n\t\t\tdividers->ref_div = args.v3.ucRefDiv;\n\t\t\tdividers->vco_mode = (args.v3.ucCntlFlag &\n\t\t\t\t\t      ATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (adev->asic_type >= CHIP_TAHITI)\n\t\t\t\treturn -EINVAL;\n\t\t\targs.v5.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\n\t\t\tif (strobe_mode)\n\t\t\t\targs.v5.ucInputFlag = ATOM_PLL_INPUT_FLAG_PLL_STROBE_MODE_EN;\n\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\tdividers->post_div = args.v5.ucPostDiv;\n\t\t\tdividers->enable_post_div = (args.v5.ucCntlFlag &\n\t\t\t\t\t\t     ATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\n\t\t\tdividers->enable_dithen = (args.v5.ucCntlFlag &\n\t\t\t\t\t\t   ATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\n\t\t\tdividers->whole_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDiv);\n\t\t\tdividers->frac_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDivFrac);\n\t\t\tdividers->ref_div = args.v5.ucRefDiv;\n\t\t\tdividers->vco_mode = (args.v5.ucCntlFlag &\n\t\t\t\t\t      ATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\targs.v4.ulClock = cpu_to_le32(clock);\t \n\n\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\tdividers->post_divider = dividers->post_div = args.v4.ucPostDiv;\n\t\tdividers->real_clock = le32_to_cpu(args.v4.ulClock);\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\t \n\t\targs.v6_in.ulClock.ulComputeClockFlag = clock_type;\n\t\targs.v6_in.ulClock.ulClockFreq = cpu_to_le32(clock);\t \n\n\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\tdividers->whole_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDiv);\n\t\tdividers->frac_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDivFrac);\n\t\tdividers->ref_div = args.v6_out.ucPllRefDiv;\n\t\tdividers->post_div = args.v6_out.ucPllPostDiv;\n\t\tdividers->flags = args.v6_out.ucPllCntlFlag;\n\t\tdividers->real_clock = le32_to_cpu(args.v6_out.ulClock.ulClock);\n\t\tdividers->post_divider = args.v6_out.ulClock.ucPostDiv;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_DRM_AMDGPU_SI\nint amdgpu_atombios_get_memory_pll_dividers(struct amdgpu_device *adev,\n\t\t\t\t\t    u32 clock,\n\t\t\t\t\t    bool strobe_mode,\n\t\t\t\t\t    struct atom_mpll_param *mpll_param)\n{\n\tCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_1 args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam);\n\tu8 frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\tmemset(mpll_param, 0, sizeof(struct atom_mpll_param));\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (frev) {\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\t \n\t\t\targs.ulClock = cpu_to_le32(clock);\t \n\t\t\targs.ucInputFlag = 0;\n\t\t\tif (strobe_mode)\n\t\t\t\targs.ucInputFlag |= MPLL_INPUT_FLAG_STROBE_MODE_EN;\n\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\tmpll_param->clkfrac = le16_to_cpu(args.ulFbDiv.usFbDivFrac);\n\t\t\tmpll_param->clkf = le16_to_cpu(args.ulFbDiv.usFbDiv);\n\t\t\tmpll_param->post_div = args.ucPostDiv;\n\t\t\tmpll_param->dll_speed = args.ucDllSpeed;\n\t\t\tmpll_param->bwcntl = args.ucBWCntl;\n\t\t\tmpll_param->vco_mode =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_VCO_MODE_MASK);\n\t\t\tmpll_param->yclk_sel =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_BYPASS_DQ_PLL) ? 1 : 0;\n\t\t\tmpll_param->qdr =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_QDR_ENABLE) ? 1 : 0;\n\t\t\tmpll_param->half_rate =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_AD_HALF_RATE) ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid amdgpu_atombios_set_engine_dram_timings(struct amdgpu_device *adev,\n\t\t\t\t\t     u32 eng_clock, u32 mem_clock)\n{\n\tSET_ENGINE_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\n\tu32 tmp;\n\n\tmemset(&args, 0, sizeof(args));\n\n\ttmp = eng_clock & SET_CLOCK_FREQ_MASK;\n\ttmp |= (COMPUTE_ENGINE_PLL_PARAM << 24);\n\n\targs.ulTargetEngineClock = cpu_to_le32(tmp);\n\tif (mem_clock)\n\t\targs.sReserved.ulClock = cpu_to_le32(mem_clock & SET_CLOCK_FREQ_MASK);\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_get_default_voltages(struct amdgpu_device *adev,\n\t\t\t\t\t  u16 *vddc, u16 *vddci, u16 *mvdd)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\n\tu8 frev, crev;\n\tu16 data_offset;\n\tunion firmware_info *firmware_info;\n\n\t*vddc = 0;\n\t*vddci = 0;\n\t*mvdd = 0;\n\n\tif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tfirmware_info =\n\t\t\t(union firmware_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tdata_offset);\n\t\t*vddc = le16_to_cpu(firmware_info->info_14.usBootUpVDDCVoltage);\n\t\tif ((frev == 2) && (crev >= 2)) {\n\t\t\t*vddci = le16_to_cpu(firmware_info->info_22.usBootUpVDDCIVoltage);\n\t\t\t*mvdd = le16_to_cpu(firmware_info->info_22.usBootUpMVDDCVoltage);\n\t\t}\n\t}\n}\n\nunion set_voltage {\n\tstruct _SET_VOLTAGE_PS_ALLOCATION alloc;\n\tstruct _SET_VOLTAGE_PARAMETERS v1;\n\tstruct _SET_VOLTAGE_PARAMETERS_V2 v2;\n\tstruct _SET_VOLTAGE_PARAMETERS_V1_3 v3;\n};\n\nint amdgpu_atombios_get_max_vddc(struct amdgpu_device *adev, u8 voltage_type,\n\t\t\t     u16 voltage_id, u16 *voltage)\n{\n\tunion set_voltage args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\n\tu8 frev, crev;\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 1:\n\t\treturn -EINVAL;\n\tcase 2:\n\t\targs.v2.ucVoltageType = SET_VOLTAGE_GET_MAX_VOLTAGE;\n\t\targs.v2.ucVoltageMode = 0;\n\t\targs.v2.usVoltageLevel = 0;\n\n\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*voltage = le16_to_cpu(args.v2.usVoltageLevel);\n\t\tbreak;\n\tcase 3:\n\t\targs.v3.ucVoltageType = voltage_type;\n\t\targs.v3.ucVoltageMode = ATOM_GET_VOLTAGE_LEVEL;\n\t\targs.v3.usVoltageLevel = cpu_to_le16(voltage_id);\n\n\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*voltage = le16_to_cpu(args.v3.usVoltageLevel);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_atombios_get_leakage_vddc_based_on_leakage_idx(struct amdgpu_device *adev,\n\t\t\t\t\t\t      u16 *voltage,\n\t\t\t\t\t\t      u16 leakage_idx)\n{\n\treturn amdgpu_atombios_get_max_vddc(adev, VOLTAGE_TYPE_VDDC, leakage_idx, voltage);\n}\n\nunion voltage_object_info {\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO v1;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V2 v2;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V3_1 v3;\n};\n\nunion voltage_object {\n\tstruct _ATOM_VOLTAGE_OBJECT v1;\n\tstruct _ATOM_VOLTAGE_OBJECT_V2 v2;\n\tunion _ATOM_VOLTAGE_OBJECT_V3 v3;\n};\n\n\nstatic ATOM_VOLTAGE_OBJECT_V3 *amdgpu_atombios_lookup_voltage_object_v3(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *v3,\n\t\t\t\t\t\t\t\t\tu8 voltage_type, u8 voltage_mode)\n{\n\tu32 size = le16_to_cpu(v3->sHeader.usStructureSize);\n\tu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V3_1, asVoltageObj[0]);\n\tu8 *start = (u8 *)v3;\n\n\twhile (offset < size) {\n\t\tATOM_VOLTAGE_OBJECT_V3 *vo = (ATOM_VOLTAGE_OBJECT_V3 *)(start + offset);\n\t\tif ((vo->asGpioVoltageObj.sHeader.ucVoltageType == voltage_type) &&\n\t\t    (vo->asGpioVoltageObj.sHeader.ucVoltageMode == voltage_mode))\n\t\t\treturn vo;\n\t\toffset += le16_to_cpu(vo->asGpioVoltageObj.sHeader.usSize);\n\t}\n\treturn NULL;\n}\n\nint amdgpu_atombios_get_svi2_info(struct amdgpu_device *adev,\n\t\t\t      u8 voltage_type,\n\t\t\t      u8 *svd_gpio_id, u8 *svc_gpio_id)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(adev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tamdgpu_atombios_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t      voltage_type,\n\t\t\t\t\t\t\t\t      VOLTAGE_OBJ_SVID2);\n\t\t\t\tif (voltage_object) {\n\t\t\t\t\t*svd_gpio_id = voltage_object->v3.asSVID2Obj.ucSVDGpioId;\n\t\t\t\t\t*svc_gpio_id = voltage_object->v3.asSVID2Obj.ucSVCGpioId;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nbool\namdgpu_atombios_is_voltage_gpio(struct amdgpu_device *adev,\n\t\t\t\tu8 voltage_type, u8 voltage_mode)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(adev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tif (amdgpu_atombios_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t  voltage_type, voltage_mode))\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint amdgpu_atombios_get_voltage_table(struct amdgpu_device *adev,\n\t\t\t\t      u8 voltage_type, u8 voltage_mode,\n\t\t\t\t      struct atom_voltage_table *voltage_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tint i;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(adev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tamdgpu_atombios_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t      voltage_type, voltage_mode);\n\t\t\t\tif (voltage_object) {\n\t\t\t\t\tATOM_GPIO_VOLTAGE_OBJECT_V3 *gpio =\n\t\t\t\t\t\t&voltage_object->v3.asGpioVoltageObj;\n\t\t\t\t\tVOLTAGE_LUT_ENTRY_V2 *lut;\n\t\t\t\t\tif (gpio->ucGpioEntryNum > MAX_VOLTAGE_ENTRIES)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tlut = &gpio->asVolGpioLut[0];\n\t\t\t\t\tfor (i = 0; i < gpio->ucGpioEntryNum; i++) {\n\t\t\t\t\t\tvoltage_table->entries[i].value =\n\t\t\t\t\t\t\tle16_to_cpu(lut->usVoltageValue);\n\t\t\t\t\t\tvoltage_table->entries[i].smio_low =\n\t\t\t\t\t\t\tle32_to_cpu(lut->ulVoltageId);\n\t\t\t\t\t\tlut = (VOLTAGE_LUT_ENTRY_V2 *)\n\t\t\t\t\t\t\t((u8 *)lut + sizeof(VOLTAGE_LUT_ENTRY_V2));\n\t\t\t\t\t}\n\t\t\t\t\tvoltage_table->mask_low = le32_to_cpu(gpio->ulGpioMaskVal);\n\t\t\t\t\tvoltage_table->count = gpio->ucGpioEntryNum;\n\t\t\t\t\tvoltage_table->phase_delay = gpio->ucPhaseDelay;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nunion vram_info {\n\tstruct _ATOM_VRAM_INFO_V3 v1_3;\n\tstruct _ATOM_VRAM_INFO_V4 v1_4;\n\tstruct _ATOM_VRAM_INFO_HEADER_V2_1 v2_1;\n};\n\n#define MEM_ID_MASK           0xff000000\n#define MEM_ID_SHIFT          24\n#define CLOCK_RANGE_MASK      0x00ffffff\n#define CLOCK_RANGE_SHIFT     0\n#define LOW_NIBBLE_MASK       0xf\n#define DATA_EQU_PREV         0\n#define DATA_FROM_TABLE       4\n\nint amdgpu_atombios_init_mc_reg_table(struct amdgpu_device *adev,\n\t\t\t\t      u8 module_index,\n\t\t\t\t      struct atom_mc_reg_table *reg_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\n\tu8 frev, crev, num_entries, t_mem_id, num_ranges = 0;\n\tu32 i = 0, j;\n\tu16 data_offset, size;\n\tunion vram_info *vram_info;\n\n\tmemset(reg_table, 0, sizeof(struct atom_mc_reg_table));\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvram_info = (union vram_info *)\n\t\t\t(adev->mode_info.atom_context->bios + data_offset);\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tDRM_ERROR(\"old table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_INIT_REG_BLOCK *reg_block =\n\t\t\t\t\t\t(ATOM_INIT_REG_BLOCK *)\n\t\t\t\t\t\t((u8 *)vram_info + le16_to_cpu(vram_info->v2_1.usMemClkPatchTblOffset));\n\t\t\t\t\tATOM_MEMORY_SETTING_DATA_BLOCK *reg_data =\n\t\t\t\t\t\t(ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t((u8 *)reg_block + (2 * sizeof(u16)) +\n\t\t\t\t\t\t le16_to_cpu(reg_block->usRegIndexTblSize));\n\t\t\t\t\tATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\n\t\t\t\t\tnum_entries = (u8)((le16_to_cpu(reg_block->usRegIndexTblSize)) /\n\t\t\t\t\t\t\t   sizeof(ATOM_INIT_REG_INDEX_FORMAT)) - 1;\n\t\t\t\t\tif (num_entries > VBIOS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\twhile (i < num_entries) {\n\t\t\t\t\t\tif (format->ucPreRegDataLength & ACCESS_PLACEHOLDER)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treg_table->mc_reg_address[i].s1 =\n\t\t\t\t\t\t\t(u16)(le16_to_cpu(format->usRegIndex));\n\t\t\t\t\t\treg_table->mc_reg_address[i].pre_reg_data =\n\t\t\t\t\t\t\t(u8)(format->ucPreRegDataLength);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tformat = (ATOM_INIT_REG_INDEX_FORMAT *)\n\t\t\t\t\t\t\t((u8 *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\n\t\t\t\t\t}\n\t\t\t\t\treg_table->last = i;\n\t\t\t\t\twhile ((le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK) &&\n\t\t\t\t\t       (num_ranges < VBIOS_MAX_AC_TIMING_ENTRIES)) {\n\t\t\t\t\t\tt_mem_id = (u8)((le32_to_cpu(*(u32 *)reg_data) & MEM_ID_MASK)\n\t\t\t\t\t\t\t\t>> MEM_ID_SHIFT);\n\t\t\t\t\t\tif (module_index == t_mem_id) {\n\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mclk_max =\n\t\t\t\t\t\t\t\t(u32)((le32_to_cpu(*(u32 *)reg_data) & CLOCK_RANGE_MASK)\n\t\t\t\t\t\t\t\t      >> CLOCK_RANGE_SHIFT);\n\t\t\t\t\t\t\tfor (i = 0, j = 1; i < reg_table->last; i++) {\n\t\t\t\t\t\t\t\tif ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\t(u32)le32_to_cpu(*((u32 *)reg_data + j));\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t} else if ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_EQU_PREV) {\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum_ranges++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t\t((u8 *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize));\n\t\t\t\t\t}\n\t\t\t\t\tif (le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\treg_table->num_entries = num_ranges;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nbool amdgpu_atombios_has_gpu_virtualization_table(struct amdgpu_device *adev)\n{\n\tint index = GetIndexIntoMasterTable(DATA, GPUVirtualizationInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t\t  &frev, &crev, &data_offset))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid amdgpu_atombios_scratch_regs_lock(struct amdgpu_device *adev, bool lock)\n{\n\tuint32_t bios_6_scratch;\n\n\tbios_6_scratch = RREG32(adev->bios_scratch_reg_offset + 6);\n\n\tif (lock) {\n\t\tbios_6_scratch |= ATOM_S6_CRITICAL_STATE;\n\t\tbios_6_scratch &= ~ATOM_S6_ACC_MODE;\n\t} else {\n\t\tbios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;\n\t\tbios_6_scratch |= ATOM_S6_ACC_MODE;\n\t}\n\n\tWREG32(adev->bios_scratch_reg_offset + 6, bios_6_scratch);\n}\n\nstatic void amdgpu_atombios_scratch_regs_init(struct amdgpu_device *adev)\n{\n\tuint32_t bios_2_scratch, bios_6_scratch;\n\n\tadev->bios_scratch_reg_offset = mmBIOS_SCRATCH_0;\n\n\tbios_2_scratch = RREG32(adev->bios_scratch_reg_offset + 2);\n\tbios_6_scratch = RREG32(adev->bios_scratch_reg_offset + 6);\n\n\t \n\tbios_2_scratch &= ~ATOM_S2_VRI_BRIGHT_ENABLE;\n\n\t \n\tbios_6_scratch |= ATOM_S6_ACC_BLOCK_DISPLAY_SWITCH;\n\n\t \n\tbios_2_scratch &= ~ATOM_S2_DEVICE_DPMS_STATE;\n\n\tWREG32(adev->bios_scratch_reg_offset + 2, bios_2_scratch);\n\tWREG32(adev->bios_scratch_reg_offset + 6, bios_6_scratch);\n}\n\nvoid amdgpu_atombios_scratch_regs_engine_hung(struct amdgpu_device *adev,\n\t\t\t\t\t      bool hung)\n{\n\tu32 tmp = RREG32(adev->bios_scratch_reg_offset + 3);\n\n\tif (hung)\n\t\ttmp |= ATOM_S3_ASIC_GUI_ENGINE_HUNG;\n\telse\n\t\ttmp &= ~ATOM_S3_ASIC_GUI_ENGINE_HUNG;\n\n\tWREG32(adev->bios_scratch_reg_offset + 3, tmp);\n}\n\nvoid amdgpu_atombios_scratch_regs_set_backlight_level(struct amdgpu_device *adev,\n\t\t\t\t\t\t      u32 backlight_level)\n{\n\tu32 tmp = RREG32(adev->bios_scratch_reg_offset + 2);\n\n\ttmp &= ~ATOM_S2_CURRENT_BL_LEVEL_MASK;\n\ttmp |= (backlight_level << ATOM_S2_CURRENT_BL_LEVEL_SHIFT) &\n\t\tATOM_S2_CURRENT_BL_LEVEL_MASK;\n\n\tWREG32(adev->bios_scratch_reg_offset + 2, tmp);\n}\n\nbool amdgpu_atombios_scratch_need_asic_init(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32(adev->bios_scratch_reg_offset + 7);\n\n\tif (tmp & ATOM_S7_ASIC_INIT_COMPLETE_MASK)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n \nvoid amdgpu_atombios_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)\n{\n#ifdef __BIG_ENDIAN\n\tu32 src_tmp[5], dst_tmp[5];\n\tint i;\n\tu8 align_num_bytes = ALIGN(num_bytes, 4);\n\n\tif (to_le) {\n\t\tmemcpy(src_tmp, src, num_bytes);\n\t\tfor (i = 0; i < align_num_bytes / 4; i++)\n\t\t\tdst_tmp[i] = cpu_to_le32(src_tmp[i]);\n\t\tmemcpy(dst, dst_tmp, align_num_bytes);\n\t} else {\n\t\tmemcpy(src_tmp, src, align_num_bytes);\n\t\tfor (i = 0; i < align_num_bytes / 4; i++)\n\t\t\tdst_tmp[i] = le32_to_cpu(src_tmp[i]);\n\t\tmemcpy(dst, dst_tmp, num_bytes);\n\t}\n#else\n\tmemcpy(dst, src, num_bytes);\n#endif\n}\n\nstatic int amdgpu_atombios_allocate_fb_scratch(struct amdgpu_device *adev)\n{\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_UsageByFirmware);\n\tuint16_t data_offset;\n\tint usage_bytes = 0;\n\tstruct _ATOM_VRAM_USAGE_BY_FIRMWARE *firmware_usage;\n\tu64 start_addr;\n\tu64 size;\n\n\tif (amdgpu_atom_parse_data_header(ctx, index, NULL, NULL, NULL, &data_offset)) {\n\t\tfirmware_usage = (struct _ATOM_VRAM_USAGE_BY_FIRMWARE *)(ctx->bios + data_offset);\n\n\t\tDRM_DEBUG(\"atom firmware requested %08x %dkb\\n\",\n\t\t\t  le32_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].ulStartAddrUsedByFirmware),\n\t\t\t  le16_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].usFirmwareUseInKb));\n\n\t\tstart_addr = firmware_usage->asFirmwareVramReserveInfo[0].ulStartAddrUsedByFirmware;\n\t\tsize = firmware_usage->asFirmwareVramReserveInfo[0].usFirmwareUseInKb;\n\n\t\tif ((uint32_t)(start_addr & ATOM_VRAM_OPERATION_FLAGS_MASK) ==\n\t\t\t(uint32_t)(ATOM_VRAM_BLOCK_SRIOV_MSG_SHARE_RESERVATION <<\n\t\t\tATOM_VRAM_OPERATION_FLAGS_SHIFT)) {\n\t\t\t \n\t\t\tadev->mman.fw_vram_usage_start_offset = (start_addr &\n\t\t\t\t(~ATOM_VRAM_OPERATION_FLAGS_MASK)) << 10;\n\t\t\tadev->mman.fw_vram_usage_size = size << 10;\n\t\t\t \n\t\t\tusage_bytes = 0;\n\t\t} else {\n\t\t\tusage_bytes = le16_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].usFirmwareUseInKb) * 1024;\n\t\t}\n\t}\n\tctx->scratch_size_bytes = 0;\n\tif (usage_bytes == 0)\n\t\tusage_bytes = 20 * 1024;\n\t \n\tctx->scratch = kzalloc(usage_bytes, GFP_KERNEL);\n\tif (!ctx->scratch)\n\t\treturn -ENOMEM;\n\tctx->scratch_size_bytes = usage_bytes;\n\treturn 0;\n}\n\n \n \n\n \nstatic uint32_t cail_pll_read(struct card_info *info, uint32_t reg)\n{\n\treturn 0;\n}\n\n \nstatic void cail_pll_write(struct card_info *info, uint32_t reg, uint32_t val)\n{\n\n}\n\n \nstatic uint32_t cail_mc_read(struct card_info *info, uint32_t reg)\n{\n\treturn 0;\n}\n\n \nstatic void cail_mc_write(struct card_info *info, uint32_t reg, uint32_t val)\n{\n\n}\n\n \nstatic void cail_reg_write(struct card_info *info, uint32_t reg, uint32_t val)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(info->dev);\n\n\tWREG32(reg, val);\n}\n\n \nstatic uint32_t cail_reg_read(struct card_info *info, uint32_t reg)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(info->dev);\n\tuint32_t r;\n\n\tr = RREG32(reg);\n\treturn r;\n}\n\nstatic ssize_t amdgpu_atombios_get_vbios_version(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\n\treturn sysfs_emit(buf, \"%s\\n\", ctx->vbios_pn);\n}\n\nstatic DEVICE_ATTR(vbios_version, 0444, amdgpu_atombios_get_vbios_version,\n\t\t   NULL);\n\nstatic struct attribute *amdgpu_vbios_version_attrs[] = {\n\t&dev_attr_vbios_version.attr,\n\tNULL\n};\n\nconst struct attribute_group amdgpu_vbios_version_attr_group = {\n\t.attrs = amdgpu_vbios_version_attrs\n};\n\nint amdgpu_atombios_sysfs_init(struct amdgpu_device *adev)\n{\n\tif (adev->mode_info.atom_context)\n\t\treturn devm_device_add_group(adev->dev,\n\t\t\t\t\t     &amdgpu_vbios_version_attr_group);\n\n\treturn 0;\n}\n\n \nvoid amdgpu_atombios_fini(struct amdgpu_device *adev)\n{\n\tif (adev->mode_info.atom_context) {\n\t\tkfree(adev->mode_info.atom_context->scratch);\n\t\tkfree(adev->mode_info.atom_context->iio);\n\t}\n\tkfree(adev->mode_info.atom_context);\n\tadev->mode_info.atom_context = NULL;\n\tkfree(adev->mode_info.atom_card_info);\n\tadev->mode_info.atom_card_info = NULL;\n}\n\n \nint amdgpu_atombios_init(struct amdgpu_device *adev)\n{\n\tstruct card_info *atom_card_info =\n\t    kzalloc(sizeof(struct card_info), GFP_KERNEL);\n\n\tif (!atom_card_info)\n\t\treturn -ENOMEM;\n\n\tadev->mode_info.atom_card_info = atom_card_info;\n\tatom_card_info->dev = adev_to_drm(adev);\n\tatom_card_info->reg_read = cail_reg_read;\n\tatom_card_info->reg_write = cail_reg_write;\n\tatom_card_info->mc_read = cail_mc_read;\n\tatom_card_info->mc_write = cail_mc_write;\n\tatom_card_info->pll_read = cail_pll_read;\n\tatom_card_info->pll_write = cail_pll_write;\n\n\tadev->mode_info.atom_context = amdgpu_atom_parse(atom_card_info, adev->bios);\n\tif (!adev->mode_info.atom_context) {\n\t\tamdgpu_atombios_fini(adev);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&adev->mode_info.atom_context->mutex);\n\tif (adev->is_atom_fw) {\n\t\tamdgpu_atomfirmware_scratch_regs_init(adev);\n\t\tamdgpu_atomfirmware_allocate_fb_scratch(adev);\n\t\t \n\t\tadev->mode_info.firmware_flags =\n\t\t\tamdgpu_atomfirmware_query_firmware_capability(adev);\n\t} else {\n\t\tamdgpu_atombios_scratch_regs_init(adev);\n\t\tamdgpu_atombios_allocate_fb_scratch(adev);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_atombios_get_data_table(struct amdgpu_device *adev,\n\t\t\t\t   uint32_t table,\n\t\t\t\t   uint16_t *size,\n\t\t\t\t   uint8_t *frev,\n\t\t\t\t   uint8_t *crev,\n\t\t\t\t   uint8_t **addr)\n{\n\tuint16_t data_start;\n\n\tif (!amdgpu_atom_parse_data_header(adev->mode_info.atom_context, table,\n\t\t\t\t\t   size, frev, crev, &data_start))\n\t\treturn -EINVAL;\n\n\t*addr = (uint8_t *)adev->mode_info.atom_context->bios + data_start;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}