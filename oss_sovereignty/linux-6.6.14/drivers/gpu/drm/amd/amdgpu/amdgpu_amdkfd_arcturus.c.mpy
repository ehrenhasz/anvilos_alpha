{
  "module_name": "amdgpu_amdkfd_arcturus.c",
  "hash_id": "201069ac61de0e65533669ffa03084c1de87edc8161abd39206688e3ac35e69e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_arcturus.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/fdtable.h>\n#include <linux/uaccess.h>\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_amdkfd_arcturus.h\"\n#include \"amdgpu_reset.h\"\n#include \"sdma0/sdma0_4_2_2_offset.h\"\n#include \"sdma0/sdma0_4_2_2_sh_mask.h\"\n#include \"sdma1/sdma1_4_2_2_offset.h\"\n#include \"sdma1/sdma1_4_2_2_sh_mask.h\"\n#include \"sdma2/sdma2_4_2_2_offset.h\"\n#include \"sdma2/sdma2_4_2_2_sh_mask.h\"\n#include \"sdma3/sdma3_4_2_2_offset.h\"\n#include \"sdma3/sdma3_4_2_2_sh_mask.h\"\n#include \"sdma4/sdma4_4_2_2_offset.h\"\n#include \"sdma4/sdma4_4_2_2_sh_mask.h\"\n#include \"sdma5/sdma5_4_2_2_offset.h\"\n#include \"sdma5/sdma5_4_2_2_sh_mask.h\"\n#include \"sdma6/sdma6_4_2_2_offset.h\"\n#include \"sdma6/sdma6_4_2_2_sh_mask.h\"\n#include \"sdma7/sdma7_4_2_2_offset.h\"\n#include \"sdma7/sdma7_4_2_2_sh_mask.h\"\n#include \"v9_structs.h\"\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"amdgpu_amdkfd_gfx_v9.h\"\n#include \"gfxhub_v1_0.h\"\n#include \"mmhub_v9_4.h\"\n#include \"gc/gc_9_0_offset.h\"\n#include \"gc/gc_9_0_sh_mask.h\"\n\n#define HQD_N_REGS 56\n#define DUMP_REG(addr) do {\t\t\t\t\\\n\t\tif (WARN_ON_ONCE(i >= HQD_N_REGS))\t\\\n\t\t\tbreak;\t\t\t\t\\\n\t\t(*dump)[i][0] = (addr) << 2;\t\t\\\n\t\t(*dump)[i++][1] = RREG32(addr);\t\t\\\n\t} while (0)\n\nstatic inline struct v9_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct v9_sdma_mqd *)mqd;\n}\n\nstatic uint32_t get_sdma_rlc_reg_offset(struct amdgpu_device *adev,\n\t\t\t\tunsigned int engine_id,\n\t\t\t\tunsigned int queue_id)\n{\n\tuint32_t sdma_engine_reg_base = 0;\n\tuint32_t sdma_rlc_reg_offset;\n\n\tswitch (engine_id) {\n\tdefault:\n\t\tdev_warn(adev->dev,\n\t\t\t \"Invalid sdma engine id (%d), using engine id 0\\n\",\n\t\t\t engine_id);\n\t\tfallthrough;\n\tcase 0:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA0, 0,\n\t\t\t\tmmSDMA0_RLC0_RB_CNTL) - mmSDMA0_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 1:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA1, 0,\n\t\t\t\tmmSDMA1_RLC0_RB_CNTL) - mmSDMA1_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 2:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA2, 0,\n\t\t\t\tmmSDMA2_RLC0_RB_CNTL) - mmSDMA2_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 3:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA3, 0,\n\t\t\t\tmmSDMA3_RLC0_RB_CNTL) - mmSDMA3_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 4:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA4, 0,\n\t\t\t\tmmSDMA4_RLC0_RB_CNTL) - mmSDMA4_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 5:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA5, 0,\n\t\t\t\tmmSDMA5_RLC0_RB_CNTL) - mmSDMA5_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 6:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA6, 0,\n\t\t\t\tmmSDMA6_RLC0_RB_CNTL) - mmSDMA6_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 7:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA7, 0,\n\t\t\t\tmmSDMA7_RLC0_RB_CNTL) - mmSDMA7_RLC0_RB_CNTL;\n\t\tbreak;\n\t}\n\n\tsdma_rlc_reg_offset = sdma_engine_reg_base\n\t\t+ queue_id * (mmSDMA0_RLC1_RB_CNTL - mmSDMA0_RLC0_RB_CNTL);\n\n\tpr_debug(\"RLC register offset for SDMA%d RLC%d: 0x%x\\n\", engine_id,\n\t\t\tqueue_id, sdma_rlc_reg_offset);\n\n\treturn sdma_rlc_reg_offset;\n}\n\nint kgd_arcturus_hqd_sdma_load(struct amdgpu_device *adev, void *mqd,\n\t\t\t     uint32_t __user *wptr, struct mm_struct *mm)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tunsigned long end_jiffies;\n\tuint32_t data;\n\tuint64_t data64;\n\tuint64_t __user *wptr64 = (uint64_t __user *)wptr;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tm->sdmax_rlcx_rb_cntl & (~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK));\n\n\tend_jiffies = msecs_to_jiffies(2000) + jiffies;\n\twhile (true) {\n\t\tdata = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (data & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL_OFFSET,\n\t       m->sdmax_rlcx_doorbell_offset);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_doorbell, SDMA0_RLC0_DOORBELL,\n\t\t\t     ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, data);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR,\n\t\t\t\tm->sdmax_rlcx_rb_rptr);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_HI,\n\t\t\t\tm->sdmax_rlcx_rb_rptr_hi);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_MINOR_PTR_UPDATE, 1);\n\tif (read_user_wptr(mm, wptr64, data64)) {\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR,\n\t\t       lower_32_bits(data64));\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR_HI,\n\t\t       upper_32_bits(data64));\n\t} else {\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR,\n\t\t       m->sdmax_rlcx_rb_rptr);\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR_HI,\n\t\t       m->sdmax_rlcx_rb_rptr_hi);\n\t}\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_MINOR_PTR_UPDATE, 0);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE, m->sdmax_rlcx_rb_base);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE_HI,\n\t\t\tm->sdmax_rlcx_rb_base_hi);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_LO,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_lo);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_HI,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_hi);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_rb_cntl, SDMA0_RLC0_RB_CNTL,\n\t\t\t     RB_ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, data);\n\n\treturn 0;\n}\n\nint kgd_arcturus_hqd_sdma_dump(struct amdgpu_device *adev,\n\t\t\t     uint32_t engine_id, uint32_t queue_id,\n\t\t\t     uint32_t (**dump)[2], uint32_t *n_regs)\n{\n\tuint32_t sdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev,\n\t\t\tengine_id, queue_id);\n\tuint32_t i = 0, reg;\n#undef HQD_N_REGS\n#define HQD_N_REGS (19+6+7+10)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (reg = mmSDMA0_RLC0_RB_CNTL; reg <= mmSDMA0_RLC0_DOORBELL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_STATUS; reg <= mmSDMA0_RLC0_CSA_ADDR_HI; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_IB_SUB_REMAIN;\n\t     reg <= mmSDMA0_RLC0_MINOR_PTR_UPDATE; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_MIDCMD_DATA0;\n\t     reg <= mmSDMA0_RLC0_MIDCMD_CNTL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nbool kgd_arcturus_hqd_sdma_is_occupied(struct amdgpu_device *adev,\n\t\t\t\tvoid *mqd)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t sdma_rlc_rb_cntl;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\tsdma_rlc_rb_cntl = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\n\tif (sdma_rlc_rb_cntl & SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nint kgd_arcturus_hqd_sdma_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\tunsigned int utimeout)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t temp;\n\tunsigned long end_jiffies = (utimeout * HZ / 1000) + jiffies;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\ttemp = temp & ~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK;\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, temp);\n\n\twhile (true) {\n\t\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (temp & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, 0);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tRREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL) |\n\t\tSDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK);\n\n\tm->sdmax_rlcx_rb_rptr = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR);\n\tm->sdmax_rlcx_rb_rptr_hi =\n\t\tRREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_HI);\n\n\treturn 0;\n}\n\n \nstatic int suspend_resume_compute_scheduler(struct amdgpu_device *adev, bool suspend)\n{\n\tint i, r = 0;\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[i];\n\n\t\tif (!(ring && ring->sched.thread))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (suspend) {\n\t\t\tdrm_sched_stop(&ring->sched, NULL);\n\t\t\tr = amdgpu_fence_wait_empty(ring);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tdrm_sched_start(&ring->sched, false);\n\t\t}\n\t}\n\nout:\n\t \n\tif (!suspend || r)\n\t\treturn r;\n\n\treturn amdgpu_device_ip_wait_for_idle(adev, AMD_IP_BLOCK_TYPE_GFX);\n}\n\nstatic void set_barrier_auto_waitcnt(struct amdgpu_device *adev, bool enable_waitcnt)\n{\n\tuint32_t data;\n\n\tWRITE_ONCE(adev->barrier_has_auto_waitcnt, enable_waitcnt);\n\n\tif (!down_read_trylock(&adev->reset_domain->sem))\n\t\treturn;\n\n\tamdgpu_amdkfd_suspend(adev, false);\n\n\tif (suspend_resume_compute_scheduler(adev, true))\n\t\tgoto out;\n\n\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmSQ_CONFIG));\n\tdata = REG_SET_FIELD(data, SQ_CONFIG, DISABLE_BARRIER_WAITCNT,\n\t\t\t\t\t\t!enable_waitcnt);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSQ_CONFIG), data);\n\nout:\n\tsuspend_resume_compute_scheduler(adev, false);\n\n\tamdgpu_amdkfd_resume(adev, false);\n\n\tup_read(&adev->reset_domain->sem);\n}\n\n \nstatic uint32_t kgd_arcturus_enable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\tbool restore_dbg_registers,\n\t\t\t\tuint32_t vmid)\n{\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tset_barrier_auto_waitcnt(adev, true);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), 0);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, false);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\n \nstatic uint32_t kgd_arcturus_disable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\t\tbool keep_trap_enabled,\n\t\t\t\t\tuint32_t vmid)\n{\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tset_barrier_auto_waitcnt(adev, false);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), 0);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, false);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\nconst struct kfd2kgd_calls arcturus_kfd2kgd = {\n\t.program_sh_mem_settings = kgd_gfx_v9_program_sh_mem_settings,\n\t.set_pasid_vmid_mapping = kgd_gfx_v9_set_pasid_vmid_mapping,\n\t.init_interrupts = kgd_gfx_v9_init_interrupts,\n\t.hqd_load = kgd_gfx_v9_hqd_load,\n\t.hiq_mqd_load = kgd_gfx_v9_hiq_mqd_load,\n\t.hqd_sdma_load = kgd_arcturus_hqd_sdma_load,\n\t.hqd_dump = kgd_gfx_v9_hqd_dump,\n\t.hqd_sdma_dump = kgd_arcturus_hqd_sdma_dump,\n\t.hqd_is_occupied = kgd_gfx_v9_hqd_is_occupied,\n\t.hqd_sdma_is_occupied = kgd_arcturus_hqd_sdma_is_occupied,\n\t.hqd_destroy = kgd_gfx_v9_hqd_destroy,\n\t.hqd_sdma_destroy = kgd_arcturus_hqd_sdma_destroy,\n\t.wave_control_execute = kgd_gfx_v9_wave_control_execute,\n\t.get_atc_vmid_pasid_mapping_info =\n\t\t\t\tkgd_gfx_v9_get_atc_vmid_pasid_mapping_info,\n\t.set_vm_context_page_table_base =\n\t\t\t\tkgd_gfx_v9_set_vm_context_page_table_base,\n\t.enable_debug_trap = kgd_arcturus_enable_debug_trap,\n\t.disable_debug_trap = kgd_arcturus_disable_debug_trap,\n\t.validate_trap_override_request = kgd_gfx_v9_validate_trap_override_request,\n\t.set_wave_launch_trap_override = kgd_gfx_v9_set_wave_launch_trap_override,\n\t.set_wave_launch_mode = kgd_gfx_v9_set_wave_launch_mode,\n\t.set_address_watch = kgd_gfx_v9_set_address_watch,\n\t.clear_address_watch = kgd_gfx_v9_clear_address_watch,\n\t.get_iq_wait_times = kgd_gfx_v9_get_iq_wait_times,\n\t.build_grace_period_packet_info = kgd_gfx_v9_build_grace_period_packet_info,\n\t.get_cu_occupancy = kgd_gfx_v9_get_cu_occupancy,\n\t.program_trap_handler_settings = kgd_gfx_v9_program_trap_handler_settings\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}