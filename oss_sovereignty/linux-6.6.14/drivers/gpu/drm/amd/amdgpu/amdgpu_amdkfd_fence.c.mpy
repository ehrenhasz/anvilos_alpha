{
  "module_name": "amdgpu_amdkfd_fence.c",
  "hash_id": "a53a5e910597463eb0d7b60b5acc4e9b1baa34f6fed3a0b0d85c6bd315ef5a43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_fence.c",
  "human_readable_source": " \n\n#include <linux/dma-fence.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/stacktrace.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include \"amdgpu_amdkfd.h\"\n#include \"kfd_svm.h\"\n\nstatic const struct dma_fence_ops amdkfd_fence_ops;\nstatic atomic_t fence_seq = ATOMIC_INIT(0);\n\n \n\nstruct amdgpu_amdkfd_fence *amdgpu_amdkfd_fence_create(u64 context,\n\t\t\t\tstruct mm_struct *mm,\n\t\t\t\tstruct svm_range_bo *svm_bo)\n{\n\tstruct amdgpu_amdkfd_fence *fence;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (fence == NULL)\n\t\treturn NULL;\n\n\t \n\tmmgrab(mm);\n\tfence->mm = mm;\n\tget_task_comm(fence->timeline_name, current);\n\tspin_lock_init(&fence->lock);\n\tfence->svm_bo = svm_bo;\n\tdma_fence_init(&fence->base, &amdkfd_fence_ops, &fence->lock,\n\t\t   context, atomic_inc_return(&fence_seq));\n\n\treturn fence;\n}\n\nstruct amdgpu_amdkfd_fence *to_amdgpu_amdkfd_fence(struct dma_fence *f)\n{\n\tstruct amdgpu_amdkfd_fence *fence;\n\n\tif (!f)\n\t\treturn NULL;\n\n\tfence = container_of(f, struct amdgpu_amdkfd_fence, base);\n\tif (fence && f->ops == &amdkfd_fence_ops)\n\t\treturn fence;\n\n\treturn NULL;\n}\n\nstatic const char *amdkfd_fence_get_driver_name(struct dma_fence *f)\n{\n\treturn \"amdgpu_amdkfd_fence\";\n}\n\nstatic const char *amdkfd_fence_get_timeline_name(struct dma_fence *f)\n{\n\tstruct amdgpu_amdkfd_fence *fence = to_amdgpu_amdkfd_fence(f);\n\n\treturn fence->timeline_name;\n}\n\n \nstatic bool amdkfd_fence_enable_signaling(struct dma_fence *f)\n{\n\tstruct amdgpu_amdkfd_fence *fence = to_amdgpu_amdkfd_fence(f);\n\n\tif (!fence)\n\t\treturn false;\n\n\tif (dma_fence_is_signaled(f))\n\t\treturn true;\n\n\tif (!fence->svm_bo) {\n\t\tif (!kgd2kfd_schedule_evict_and_restore_process(fence->mm, f))\n\t\t\treturn true;\n\t} else {\n\t\tif (!svm_range_schedule_evict_svm_bo(fence))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void amdkfd_fence_release(struct dma_fence *f)\n{\n\tstruct amdgpu_amdkfd_fence *fence = to_amdgpu_amdkfd_fence(f);\n\n\t \n\tif (WARN_ON(!fence))\n\t\treturn;  \n\n\tmmdrop(fence->mm);\n\tkfree_rcu(f, rcu);\n}\n\n \nbool amdkfd_fence_check_mm(struct dma_fence *f, struct mm_struct *mm)\n{\n\tstruct amdgpu_amdkfd_fence *fence = to_amdgpu_amdkfd_fence(f);\n\n\tif (!fence)\n\t\treturn false;\n\telse if (fence->mm == mm  && !fence->svm_bo)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct dma_fence_ops amdkfd_fence_ops = {\n\t.get_driver_name = amdkfd_fence_get_driver_name,\n\t.get_timeline_name = amdkfd_fence_get_timeline_name,\n\t.enable_signaling = amdkfd_fence_enable_signaling,\n\t.release = amdkfd_fence_release,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}