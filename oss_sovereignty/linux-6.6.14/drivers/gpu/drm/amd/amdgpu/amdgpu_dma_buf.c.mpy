{
  "module_name": "amdgpu_dma_buf.c",
  "hash_id": "eebf893f09819365d260447c36596770fbef5dfab09a5d198ee16635d016e66b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_dma_buf.c",
  "human_readable_source": " \n\n \n\n#include \"amdgpu.h\"\n#include \"amdgpu_display.h\"\n#include \"amdgpu_gem.h\"\n#include \"amdgpu_dma_buf.h\"\n#include \"amdgpu_xgmi.h\"\n#include <drm/amdgpu_drm.h>\n#include <drm/ttm/ttm_tt.h>\n#include <linux/dma-buf.h>\n#include <linux/dma-fence-array.h>\n#include <linux/pci-p2pdma.h>\n#include <linux/pm_runtime.h>\n\n \nstatic int amdgpu_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t struct dma_buf_attachment *attach)\n{\n\tstruct drm_gem_object *obj = dmabuf->priv;\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tint r;\n\n\tif (pci_p2pdma_distance(adev->pdev, attach->dev, false) < 0)\n\t\tattach->peer2peer = false;\n\n\tr = pm_runtime_get_sync(adev_to_drm(adev)->dev);\n\tif (r < 0)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\treturn r;\n}\n\n \nstatic void amdgpu_dma_buf_detach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attach)\n{\n\tstruct drm_gem_object *obj = dmabuf->priv;\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\n\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n}\n\n \nstatic int amdgpu_dma_buf_pin(struct dma_buf_attachment *attach)\n{\n\tstruct drm_gem_object *obj = attach->dmabuf->priv;\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\n\t \n\treturn amdgpu_bo_pin(bo, AMDGPU_GEM_DOMAIN_GTT);\n}\n\n \nstatic void amdgpu_dma_buf_unpin(struct dma_buf_attachment *attach)\n{\n\tstruct drm_gem_object *obj = attach->dmabuf->priv;\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\n\tamdgpu_bo_unpin(bo);\n}\n\n \nstatic struct sg_table *amdgpu_dma_buf_map(struct dma_buf_attachment *attach,\n\t\t\t\t\t   enum dma_data_direction dir)\n{\n\tstruct dma_buf *dma_buf = attach->dmabuf;\n\tstruct drm_gem_object *obj = dma_buf->priv;\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct sg_table *sgt;\n\tlong r;\n\n\tif (!bo->tbo.pin_count) {\n\t\t \n\t\tstruct ttm_operation_ctx ctx = { false, false };\n\t\tunsigned int domains = AMDGPU_GEM_DOMAIN_GTT;\n\n\t\tif (bo->preferred_domains & AMDGPU_GEM_DOMAIN_VRAM &&\n\t\t    attach->peer2peer) {\n\t\t\tbo->flags |= AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED;\n\t\t\tdomains |= AMDGPU_GEM_DOMAIN_VRAM;\n\t\t}\n\t\tamdgpu_bo_placement_from_domain(bo, domains);\n\t\tr = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\t\tif (r)\n\t\t\treturn ERR_PTR(r);\n\n\t} else if (!(amdgpu_mem_type_to_domain(bo->tbo.resource->mem_type) &\n\t\t     AMDGPU_GEM_DOMAIN_GTT)) {\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tswitch (bo->tbo.resource->mem_type) {\n\tcase TTM_PL_TT:\n\t\tsgt = drm_prime_pages_to_sg(obj->dev,\n\t\t\t\t\t    bo->tbo.ttm->pages,\n\t\t\t\t\t    bo->tbo.ttm->num_pages);\n\t\tif (IS_ERR(sgt))\n\t\t\treturn sgt;\n\n\t\tif (dma_map_sgtable(attach->dev, sgt, dir,\n\t\t\t\t    DMA_ATTR_SKIP_CPU_SYNC))\n\t\t\tgoto error_free;\n\t\tbreak;\n\n\tcase TTM_PL_VRAM:\n\t\tr = amdgpu_vram_mgr_alloc_sgt(adev, bo->tbo.resource, 0,\n\t\t\t\t\t      bo->tbo.base.size, attach->dev,\n\t\t\t\t\t      dir, &sgt);\n\t\tif (r)\n\t\t\treturn ERR_PTR(r);\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn sgt;\n\nerror_free:\n\tsg_free_table(sgt);\n\tkfree(sgt);\n\treturn ERR_PTR(-EBUSY);\n}\n\n \nstatic void amdgpu_dma_buf_unmap(struct dma_buf_attachment *attach,\n\t\t\t\t struct sg_table *sgt,\n\t\t\t\t enum dma_data_direction dir)\n{\n\tif (sgt->sgl->page_link) {\n\t\tdma_unmap_sgtable(attach->dev, sgt, dir, 0);\n\t\tsg_free_table(sgt);\n\t\tkfree(sgt);\n\t} else {\n\t\tamdgpu_vram_mgr_free_sgt(attach->dev, dir, sgt);\n\t}\n}\n\n \nstatic int amdgpu_dma_buf_begin_cpu_access(struct dma_buf *dma_buf,\n\t\t\t\t\t   enum dma_data_direction direction)\n{\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(dma_buf->priv);\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct ttm_operation_ctx ctx = { true, false };\n\tu32 domain = amdgpu_display_supported_domains(adev, bo->flags);\n\tint ret;\n\tbool reads = (direction == DMA_BIDIRECTIONAL ||\n\t\t      direction == DMA_FROM_DEVICE);\n\n\tif (!reads || !(domain & AMDGPU_GEM_DOMAIN_GTT))\n\t\treturn 0;\n\n\t \n\tret = amdgpu_bo_reserve(bo, false);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tif (!bo->tbo.pin_count &&\n\t    (bo->allowed_domains & AMDGPU_GEM_DOMAIN_GTT)) {\n\t\tamdgpu_bo_placement_from_domain(bo, AMDGPU_GEM_DOMAIN_GTT);\n\t\tret = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);\n\t}\n\n\tamdgpu_bo_unreserve(bo);\n\treturn ret;\n}\n\nconst struct dma_buf_ops amdgpu_dmabuf_ops = {\n\t.attach = amdgpu_dma_buf_attach,\n\t.detach = amdgpu_dma_buf_detach,\n\t.pin = amdgpu_dma_buf_pin,\n\t.unpin = amdgpu_dma_buf_unpin,\n\t.map_dma_buf = amdgpu_dma_buf_map,\n\t.unmap_dma_buf = amdgpu_dma_buf_unmap,\n\t.release = drm_gem_dmabuf_release,\n\t.begin_cpu_access = amdgpu_dma_buf_begin_cpu_access,\n\t.mmap = drm_gem_dmabuf_mmap,\n\t.vmap = drm_gem_dmabuf_vmap,\n\t.vunmap = drm_gem_dmabuf_vunmap,\n};\n\n \nstruct dma_buf *amdgpu_gem_prime_export(struct drm_gem_object *gobj,\n\t\t\t\t\tint flags)\n{\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(gobj);\n\tstruct dma_buf *buf;\n\n\tif (amdgpu_ttm_tt_get_usermm(bo->tbo.ttm) ||\n\t    bo->flags & AMDGPU_GEM_CREATE_VM_ALWAYS_VALID)\n\t\treturn ERR_PTR(-EPERM);\n\n\tbuf = drm_gem_prime_export(gobj, flags);\n\tif (!IS_ERR(buf))\n\t\tbuf->ops = &amdgpu_dmabuf_ops;\n\n\treturn buf;\n}\n\n \nstatic struct drm_gem_object *\namdgpu_dma_buf_create_obj(struct drm_device *dev, struct dma_buf *dma_buf)\n{\n\tstruct dma_resv *resv = dma_buf->resv;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_gem_object *gobj;\n\tstruct amdgpu_bo *bo;\n\tuint64_t flags = 0;\n\tint ret;\n\n\tdma_resv_lock(resv, NULL);\n\n\tif (dma_buf->ops == &amdgpu_dmabuf_ops) {\n\t\tstruct amdgpu_bo *other = gem_to_amdgpu_bo(dma_buf->priv);\n\n\t\tflags |= other->flags & (AMDGPU_GEM_CREATE_CPU_GTT_USWC |\n\t\t\t\t\t AMDGPU_GEM_CREATE_COHERENT |\n\t\t\t\t\t AMDGPU_GEM_CREATE_UNCACHED);\n\t}\n\n\tret = amdgpu_gem_object_create(adev, dma_buf->size, PAGE_SIZE,\n\t\t\t\t       AMDGPU_GEM_DOMAIN_CPU, flags,\n\t\t\t\t       ttm_bo_type_sg, resv, &gobj, 0);\n\tif (ret)\n\t\tgoto error;\n\n\tbo = gem_to_amdgpu_bo(gobj);\n\tbo->allowed_domains = AMDGPU_GEM_DOMAIN_GTT;\n\tbo->preferred_domains = AMDGPU_GEM_DOMAIN_GTT;\n\n\tdma_resv_unlock(resv);\n\treturn gobj;\n\nerror:\n\tdma_resv_unlock(resv);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void\namdgpu_dma_buf_move_notify(struct dma_buf_attachment *attach)\n{\n\tstruct drm_gem_object *obj = attach->importer_priv;\n\tstruct ww_acquire_ctx *ticket = dma_resv_locking_ctx(obj->resv);\n\tstruct amdgpu_bo *bo = gem_to_amdgpu_bo(obj);\n\tstruct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\tstruct ttm_operation_ctx ctx = { false, false };\n\tstruct ttm_placement placement = {};\n\tstruct amdgpu_vm_bo_base *bo_base;\n\tint r;\n\n\tif (!bo->tbo.resource || bo->tbo.resource->mem_type == TTM_PL_SYSTEM)\n\t\treturn;\n\n\tr = ttm_bo_validate(&bo->tbo, &placement, &ctx);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to invalidate DMA-buf import (%d))\\n\", r);\n\t\treturn;\n\t}\n\n\tfor (bo_base = bo->vm_bo; bo_base; bo_base = bo_base->next) {\n\t\tstruct amdgpu_vm *vm = bo_base->vm;\n\t\tstruct dma_resv *resv = vm->root.bo->tbo.base.resv;\n\n\t\tif (ticket) {\n\t\t\t \n\t\t\tr = dma_resv_lock(resv, ticket);\n\t\t\tif (r)\n\t\t\t\tcontinue;\n\n\t\t} else {\n\t\t\t \n\t\t\tif (!dma_resv_trylock(resv))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tr = dma_resv_reserve_fences(resv, 2);\n\t\tif (!r)\n\t\t\tr = amdgpu_vm_clear_freed(adev, vm, NULL);\n\t\tif (!r)\n\t\t\tr = amdgpu_vm_handle_moved(adev, vm);\n\n\t\tif (r && r != -EBUSY)\n\t\t\tDRM_ERROR(\"Failed to invalidate VM page tables (%d))\\n\",\n\t\t\t\t  r);\n\n\t\tdma_resv_unlock(resv);\n\t}\n}\n\nstatic const struct dma_buf_attach_ops amdgpu_dma_buf_attach_ops = {\n\t.allow_peer2peer = true,\n\t.move_notify = amdgpu_dma_buf_move_notify\n};\n\n \nstruct drm_gem_object *amdgpu_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t       struct dma_buf *dma_buf)\n{\n\tstruct dma_buf_attachment *attach;\n\tstruct drm_gem_object *obj;\n\n\tif (dma_buf->ops == &amdgpu_dmabuf_ops) {\n\t\tobj = dma_buf->priv;\n\t\tif (obj->dev == dev) {\n\t\t\t \n\t\t\tdrm_gem_object_get(obj);\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tobj = amdgpu_dma_buf_create_obj(dev, dma_buf);\n\tif (IS_ERR(obj))\n\t\treturn obj;\n\n\tattach = dma_buf_dynamic_attach(dma_buf, dev->dev,\n\t\t\t\t\t&amdgpu_dma_buf_attach_ops, obj);\n\tif (IS_ERR(attach)) {\n\t\tdrm_gem_object_put(obj);\n\t\treturn ERR_CAST(attach);\n\t}\n\n\tget_dma_buf(dma_buf);\n\tobj->import_attach = attach;\n\treturn obj;\n}\n\n \nbool amdgpu_dmabuf_is_xgmi_accessible(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_bo *bo)\n{\n\tstruct drm_gem_object *obj = &bo->tbo.base;\n\tstruct drm_gem_object *gobj;\n\n\tif (obj->import_attach) {\n\t\tstruct dma_buf *dma_buf = obj->import_attach->dmabuf;\n\n\t\tif (dma_buf->ops != &amdgpu_dmabuf_ops)\n\t\t\t \n\t\t\treturn false;\n\n\t\tgobj = dma_buf->priv;\n\t\tbo = gem_to_amdgpu_bo(gobj);\n\t}\n\n\tif (amdgpu_xgmi_same_hive(adev, amdgpu_ttm_adev(bo->tbo.bdev)) &&\n\t\t\t(bo->preferred_domains & AMDGPU_GEM_DOMAIN_VRAM))\n\t\treturn true;\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}