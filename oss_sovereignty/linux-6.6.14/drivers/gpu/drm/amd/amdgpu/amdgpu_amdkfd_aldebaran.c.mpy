{
  "module_name": "amdgpu_amdkfd_aldebaran.c",
  "hash_id": "2aaf4fd3deae677ca176fa33ab7f7a3986cd5999209f2ef8d2603f4affeaac81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_aldebaran.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_amdkfd_arcturus.h\"\n#include \"amdgpu_amdkfd_gfx_v9.h\"\n#include \"amdgpu_amdkfd_aldebaran.h\"\n#include \"gc/gc_9_4_2_offset.h\"\n#include \"gc/gc_9_4_2_sh_mask.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\n \nuint32_t kgd_aldebaran_enable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\t\t    bool restore_dbg_registers,\n\t\t\t\t\t    uint32_t vmid)\n{\n\tuint32_t data = 0;\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, 1);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_EN, 0);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_REPLACE, 0);\n\n\treturn data;\n}\n\n \nstatic uint32_t kgd_aldebaran_disable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool keep_trap_enabled,\n\t\t\t\t\t\tuint32_t vmid)\n{\n\tuint32_t data = 0;\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, keep_trap_enabled);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_EN, 0);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_REPLACE, 0);\n\n\treturn data;\n}\n\nstatic int kgd_aldebaran_validate_trap_override_request(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tuint32_t trap_override,\n\t\t\t\t\t\t\tuint32_t *trap_mask_supported)\n{\n\t*trap_mask_supported &= KFD_DBG_TRAP_MASK_FP_INVALID |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INPUT_DENORMAL |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_OVERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_UNDERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INEXACT |\n\t\t\t\tKFD_DBG_TRAP_MASK_INT_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_ADDRESS_WATCH |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_MEMORY_VIOLATION;\n\n\tif (trap_override != KFD_DBG_TRAP_OVERRIDE_OR &&\n\t\t\ttrap_override != KFD_DBG_TRAP_OVERRIDE_REPLACE)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nstatic uint32_t kgd_aldebaran_set_wave_launch_trap_override(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t vmid,\n\t\t\t\t\tuint32_t trap_override,\n\t\t\t\t\tuint32_t trap_mask_bits,\n\t\t\t\t\tuint32_t trap_mask_request,\n\t\t\t\t\tuint32_t *trap_mask_prev,\n\t\t\t\t\tuint32_t kfd_dbg_trap_cntl_prev)\n\n{\n\tuint32_t data = 0;\n\n\t*trap_mask_prev = REG_GET_FIELD(kfd_dbg_trap_cntl_prev, SPI_GDBG_PER_VMID_CNTL, EXCP_EN);\n\ttrap_mask_bits = (trap_mask_bits & trap_mask_request) |\n\t\t(*trap_mask_prev & ~trap_mask_request);\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, 1);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_EN, trap_mask_bits);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_REPLACE, trap_override);\n\n\treturn data;\n}\n\nuint32_t kgd_aldebaran_set_wave_launch_mode(struct amdgpu_device *adev,\n\t\t\t\t\tuint8_t wave_launch_mode,\n\t\t\t\t\tuint32_t vmid)\n{\n\tuint32_t data = 0;\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, LAUNCH_MODE, wave_launch_mode);\n\n\treturn data;\n}\n\n#define TCP_WATCH_STRIDE (regTCP_WATCH1_ADDR_H - regTCP_WATCH0_ADDR_H)\nstatic uint32_t kgd_gfx_aldebaran_set_address_watch(\n\t\t\t\t\tstruct amdgpu_device *adev,\n\t\t\t\t\tuint64_t watch_address,\n\t\t\t\t\tuint32_t watch_address_mask,\n\t\t\t\t\tuint32_t watch_id,\n\t\t\t\t\tuint32_t watch_mode,\n\t\t\t\t\tuint32_t debug_vmid,\n\t\t\t\t\tuint32_t inst)\n{\n\tuint32_t watch_address_high;\n\tuint32_t watch_address_low;\n\tuint32_t watch_address_cntl;\n\n\twatch_address_cntl = 0;\n\twatch_address_low = lower_32_bits(watch_address);\n\twatch_address_high = upper_32_bits(watch_address) & 0xffff;\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMODE,\n\t\t\twatch_mode);\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMASK,\n\t\t\twatch_address_mask >> 6);\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tVALID,\n\t\t\t1);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, regTCP_WATCH0_ADDR_H) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_high);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, regTCP_WATCH0_ADDR_L) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_low);\n\n\treturn watch_address_cntl;\n}\n\nconst struct kfd2kgd_calls aldebaran_kfd2kgd = {\n\t.program_sh_mem_settings = kgd_gfx_v9_program_sh_mem_settings,\n\t.set_pasid_vmid_mapping = kgd_gfx_v9_set_pasid_vmid_mapping,\n\t.init_interrupts = kgd_gfx_v9_init_interrupts,\n\t.hqd_load = kgd_gfx_v9_hqd_load,\n\t.hiq_mqd_load = kgd_gfx_v9_hiq_mqd_load,\n\t.hqd_sdma_load = kgd_arcturus_hqd_sdma_load,\n\t.hqd_dump = kgd_gfx_v9_hqd_dump,\n\t.hqd_sdma_dump = kgd_arcturus_hqd_sdma_dump,\n\t.hqd_is_occupied = kgd_gfx_v9_hqd_is_occupied,\n\t.hqd_sdma_is_occupied = kgd_arcturus_hqd_sdma_is_occupied,\n\t.hqd_destroy = kgd_gfx_v9_hqd_destroy,\n\t.hqd_sdma_destroy = kgd_arcturus_hqd_sdma_destroy,\n\t.wave_control_execute = kgd_gfx_v9_wave_control_execute,\n\t.get_atc_vmid_pasid_mapping_info =\n\t\t\t\tkgd_gfx_v9_get_atc_vmid_pasid_mapping_info,\n\t.set_vm_context_page_table_base = kgd_gfx_v9_set_vm_context_page_table_base,\n\t.get_cu_occupancy = kgd_gfx_v9_get_cu_occupancy,\n\t.enable_debug_trap = kgd_aldebaran_enable_debug_trap,\n\t.disable_debug_trap = kgd_aldebaran_disable_debug_trap,\n\t.validate_trap_override_request = kgd_aldebaran_validate_trap_override_request,\n\t.set_wave_launch_trap_override = kgd_aldebaran_set_wave_launch_trap_override,\n\t.set_wave_launch_mode = kgd_aldebaran_set_wave_launch_mode,\n\t.set_address_watch = kgd_gfx_aldebaran_set_address_watch,\n\t.clear_address_watch = kgd_gfx_v9_clear_address_watch,\n\t.get_iq_wait_times = kgd_gfx_v9_get_iq_wait_times,\n\t.build_grace_period_packet_info = kgd_gfx_v9_build_grace_period_packet_info,\n\t.program_trap_handler_settings = kgd_gfx_v9_program_trap_handler_settings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}