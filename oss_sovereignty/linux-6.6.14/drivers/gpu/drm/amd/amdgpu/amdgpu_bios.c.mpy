{
  "module_name": "amdgpu_bios.c",
  "hash_id": "85eccb0edf0becaac85232d7fa1e85ffd92d4a8e915a7d434233529b2cb24191",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"atom.h\"\n\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n \n\n#define AMD_VBIOS_SIGNATURE \" 761295520\"\n#define AMD_VBIOS_SIGNATURE_OFFSET 0x30\n#define AMD_VBIOS_SIGNATURE_SIZE sizeof(AMD_VBIOS_SIGNATURE)\n#define AMD_VBIOS_SIGNATURE_END (AMD_VBIOS_SIGNATURE_OFFSET + AMD_VBIOS_SIGNATURE_SIZE)\n#define AMD_IS_VALID_VBIOS(p) ((p)[0] == 0x55 && (p)[1] == 0xAA)\n#define AMD_VBIOS_LENGTH(p) ((p)[2] << 9)\n\n \nstatic bool check_atom_bios(uint8_t *bios, size_t size)\n{\n\tuint16_t tmp, bios_header_start;\n\n\tif (!bios || size < 0x49) {\n\t\tDRM_INFO(\"vbios mem is null or mem size is wrong\\n\");\n\t\treturn false;\n\t}\n\n\tif (!AMD_IS_VALID_VBIOS(bios)) {\n\t\tDRM_INFO(\"BIOS signature incorrect %x %x\\n\", bios[0], bios[1]);\n\t\treturn false;\n\t}\n\n\tbios_header_start = bios[0x48] | (bios[0x49] << 8);\n\tif (!bios_header_start) {\n\t\tDRM_INFO(\"Can't locate bios header\\n\");\n\t\treturn false;\n\t}\n\n\ttmp = bios_header_start + 4;\n\tif (size < tmp) {\n\t\tDRM_INFO(\"BIOS header is broken\\n\");\n\t\treturn false;\n\t}\n\n\tif (!memcmp(bios + tmp, \"ATOM\", 4) ||\n\t    !memcmp(bios + tmp, \"MOTA\", 4)) {\n\t\tDRM_DEBUG(\"ATOMBIOS detected\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool igp_read_bios_from_vram(struct amdgpu_device *adev)\n{\n\tuint8_t __iomem *bios;\n\tresource_size_t vram_base;\n\tresource_size_t size = 256 * 1024;  \n\n\tif (!(adev->flags & AMD_IS_APU))\n\t\tif (amdgpu_device_need_post(adev))\n\t\t\treturn false;\n\n\t \n\tif (pci_resource_len(adev->pdev, 0) == 0)\n\t\treturn false;\n\n\tadev->bios = NULL;\n\tvram_base = pci_resource_start(adev->pdev, 0);\n\tbios = ioremap_wc(vram_base, size);\n\tif (!bios)\n\t\treturn false;\n\n\tadev->bios = kmalloc(size, GFP_KERNEL);\n\tif (!adev->bios) {\n\t\tiounmap(bios);\n\t\treturn false;\n\t}\n\tadev->bios_size = size;\n\tmemcpy_fromio(adev->bios, bios, size);\n\tiounmap(bios);\n\n\tif (!check_atom_bios(adev->bios, size)) {\n\t\tkfree(adev->bios);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool amdgpu_read_bios(struct amdgpu_device *adev)\n{\n\tuint8_t __iomem *bios;\n\tsize_t size;\n\n\tadev->bios = NULL;\n\t \n\tbios = pci_map_rom(adev->pdev, &size);\n\tif (!bios)\n\t\treturn false;\n\n\tadev->bios = kzalloc(size, GFP_KERNEL);\n\tif (adev->bios == NULL) {\n\t\tpci_unmap_rom(adev->pdev, bios);\n\t\treturn false;\n\t}\n\tadev->bios_size = size;\n\tmemcpy_fromio(adev->bios, bios, size);\n\tpci_unmap_rom(adev->pdev, bios);\n\n\tif (!check_atom_bios(adev->bios, size)) {\n\t\tkfree(adev->bios);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool amdgpu_read_bios_from_rom(struct amdgpu_device *adev)\n{\n\tu8 header[AMD_VBIOS_SIGNATURE_END+1] = {0};\n\tint len;\n\n\tif (!adev->asic_funcs || !adev->asic_funcs->read_bios_from_rom)\n\t\treturn false;\n\n\t \n\tif (amdgpu_asic_read_bios_from_rom(adev, &header[0], sizeof(header)) == false)\n\t\treturn false;\n\theader[AMD_VBIOS_SIGNATURE_END] = 0;\n\n\tif ((!AMD_IS_VALID_VBIOS(header)) ||\n\t\tmemcmp((char *)&header[AMD_VBIOS_SIGNATURE_OFFSET],\n\t\t       AMD_VBIOS_SIGNATURE,\n\t\t       strlen(AMD_VBIOS_SIGNATURE)) != 0)\n\t\treturn false;\n\n\t \n\tlen = AMD_VBIOS_LENGTH(header);\n\tlen = ALIGN(len, 4);\n\tadev->bios = kmalloc(len, GFP_KERNEL);\n\tif (!adev->bios) {\n\t\tDRM_ERROR(\"no memory to allocate for BIOS\\n\");\n\t\treturn false;\n\t}\n\tadev->bios_size = len;\n\n\t \n\tamdgpu_asic_read_bios_from_rom(adev, adev->bios, len);\n\n\tif (!check_atom_bios(adev->bios, len)) {\n\t\tkfree(adev->bios);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool amdgpu_read_platform_bios(struct amdgpu_device *adev)\n{\n\tphys_addr_t rom = adev->pdev->rom;\n\tsize_t romlen = adev->pdev->romlen;\n\tvoid __iomem *bios;\n\n\tadev->bios = NULL;\n\n\tif (!rom || romlen == 0)\n\t\treturn false;\n\n\tadev->bios = kzalloc(romlen, GFP_KERNEL);\n\tif (!adev->bios)\n\t\treturn false;\n\n\tbios = ioremap(rom, romlen);\n\tif (!bios)\n\t\tgoto free_bios;\n\n\tmemcpy_fromio(adev->bios, bios, romlen);\n\tiounmap(bios);\n\n\tif (!check_atom_bios(adev->bios, romlen))\n\t\tgoto free_bios;\n\n\tadev->bios_size = romlen;\n\n\treturn true;\nfree_bios:\n\tkfree(adev->bios);\n\treturn false;\n}\n\n#ifdef CONFIG_ACPI\n \n \n#define ATRM_BIOS_PAGE 4096\n \nstatic int amdgpu_atrm_call(acpi_handle atrm_handle, uint8_t *bios,\n\t\t\t    int offset, int len)\n{\n\tacpi_status status;\n\tunion acpi_object atrm_arg_elements[2], *obj;\n\tstruct acpi_object_list atrm_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\n\n\tatrm_arg.count = 2;\n\tatrm_arg.pointer = &atrm_arg_elements[0];\n\n\tatrm_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatrm_arg_elements[0].integer.value = offset;\n\n\tatrm_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\tatrm_arg_elements[1].integer.value = len;\n\n\tstatus = acpi_evaluate_object(atrm_handle, NULL, &atrm_arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tDRM_ERROR(\"failed to evaluate ATRM got %s\\n\", acpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\n\tobj = (union acpi_object *)buffer.pointer;\n\tmemcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);\n\tlen = obj->buffer.length;\n\tkfree(buffer.pointer);\n\treturn len;\n}\n\nstatic bool amdgpu_atrm_get_bios(struct amdgpu_device *adev)\n{\n\tint ret;\n\tint size = 256 * 1024;\n\tint i;\n\tstruct pci_dev *pdev = NULL;\n\tacpi_handle dhandle, atrm_handle;\n\tacpi_status status;\n\tbool found = false;\n\n\t \n\tif (adev->flags & AMD_IS_APU)\n\t\treturn false;\n\n\t \n\tif (dev_is_removable(&adev->pdev->dev))\n\t\treturn false;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\tif (!dhandle)\n\t\t\tcontinue;\n\n\t\tstatus = acpi_get_handle(dhandle, \"ATRM\", &atrm_handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\t\tif (!dhandle)\n\t\t\t\tcontinue;\n\n\t\t\tstatus = acpi_get_handle(dhandle, \"ATRM\", &atrm_handle);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn false;\n\tpci_dev_put(pdev);\n\n\tadev->bios = kmalloc(size, GFP_KERNEL);\n\tif (!adev->bios) {\n\t\tdev_err(adev->dev, \"Unable to allocate bios\\n\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < size / ATRM_BIOS_PAGE; i++) {\n\t\tret = amdgpu_atrm_call(atrm_handle,\n\t\t\t\t       adev->bios,\n\t\t\t\t       (i * ATRM_BIOS_PAGE),\n\t\t\t\t       ATRM_BIOS_PAGE);\n\t\tif (ret < ATRM_BIOS_PAGE)\n\t\t\tbreak;\n\t}\n\n\tif (!check_atom_bios(adev->bios, size)) {\n\t\tkfree(adev->bios);\n\t\treturn false;\n\t}\n\tadev->bios_size = size;\n\treturn true;\n}\n#else\nstatic inline bool amdgpu_atrm_get_bios(struct amdgpu_device *adev)\n{\n\treturn false;\n}\n#endif\n\nstatic bool amdgpu_read_disabled_bios(struct amdgpu_device *adev)\n{\n\tif (adev->flags & AMD_IS_APU)\n\t\treturn igp_read_bios_from_vram(adev);\n\telse\n\t\treturn (!adev->asic_funcs || !adev->asic_funcs->read_disabled_bios) ?\n\t\t\tfalse : amdgpu_asic_read_disabled_bios(adev);\n}\n\n#ifdef CONFIG_ACPI\nstatic bool amdgpu_acpi_vfct_bios(struct amdgpu_device *adev)\n{\n\tstruct acpi_table_header *hdr;\n\tacpi_size tbl_size;\n\tUEFI_ACPI_VFCT *vfct;\n\tunsigned int offset;\n\n\tif (!ACPI_SUCCESS(acpi_get_table(\"VFCT\", 1, &hdr)))\n\t\treturn false;\n\ttbl_size = hdr->length;\n\tif (tbl_size < sizeof(UEFI_ACPI_VFCT)) {\n\t\tdev_info(adev->dev, \"ACPI VFCT table present but broken (too short #1),skipping\\n\");\n\t\treturn false;\n\t}\n\n\tvfct = (UEFI_ACPI_VFCT *)hdr;\n\toffset = vfct->VBIOSImageOffset;\n\n\twhile (offset < tbl_size) {\n\t\tGOP_VBIOS_CONTENT *vbios = (GOP_VBIOS_CONTENT *)((char *)hdr + offset);\n\t\tVFCT_IMAGE_HEADER *vhdr = &vbios->VbiosHeader;\n\n\t\toffset += sizeof(VFCT_IMAGE_HEADER);\n\t\tif (offset > tbl_size) {\n\t\t\tdev_info(adev->dev, \"ACPI VFCT image header truncated,skipping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\toffset += vhdr->ImageLength;\n\t\tif (offset > tbl_size) {\n\t\t\tdev_info(adev->dev, \"ACPI VFCT image truncated,skipping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (vhdr->ImageLength &&\n\t\t    vhdr->PCIBus == adev->pdev->bus->number &&\n\t\t    vhdr->PCIDevice == PCI_SLOT(adev->pdev->devfn) &&\n\t\t    vhdr->PCIFunction == PCI_FUNC(adev->pdev->devfn) &&\n\t\t    vhdr->VendorID == adev->pdev->vendor &&\n\t\t    vhdr->DeviceID == adev->pdev->device) {\n\t\t\tadev->bios = kmemdup(&vbios->VbiosContent,\n\t\t\t\t\t     vhdr->ImageLength,\n\t\t\t\t\t     GFP_KERNEL);\n\n\t\t\tif (!check_atom_bios(adev->bios, vhdr->ImageLength)) {\n\t\t\t\tkfree(adev->bios);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tadev->bios_size = vhdr->ImageLength;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdev_info(adev->dev, \"ACPI VFCT table present but broken (too short #2),skipping\\n\");\n\treturn false;\n}\n#else\nstatic inline bool amdgpu_acpi_vfct_bios(struct amdgpu_device *adev)\n{\n\treturn false;\n}\n#endif\n\nbool amdgpu_get_bios(struct amdgpu_device *adev)\n{\n\tif (amdgpu_atrm_get_bios(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from ATRM\\n\");\n\t\tgoto success;\n\t}\n\n\tif (amdgpu_acpi_vfct_bios(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from VFCT\\n\");\n\t\tgoto success;\n\t}\n\n\tif (igp_read_bios_from_vram(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from VRAM BAR\\n\");\n\t\tgoto success;\n\t}\n\n\tif (amdgpu_read_bios(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from ROM BAR\\n\");\n\t\tgoto success;\n\t}\n\n\tif (amdgpu_read_bios_from_rom(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from ROM\\n\");\n\t\tgoto success;\n\t}\n\n\tif (amdgpu_read_disabled_bios(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from disabled ROM BAR\\n\");\n\t\tgoto success;\n\t}\n\n\tif (amdgpu_read_platform_bios(adev)) {\n\t\tdev_info(adev->dev, \"Fetched VBIOS from platform\\n\");\n\t\tgoto success;\n\t}\n\n\tdev_err(adev->dev, \"Unable to locate a BIOS ROM\\n\");\n\treturn false;\n\nsuccess:\n\tadev->is_atom_fw = adev->asic_type >= CHIP_VEGA10;\n\treturn true;\n}\n\n \nbool amdgpu_soc15_read_bios_from_rom(struct amdgpu_device *adev,\n\t\t\t\t     u8 *bios, u32 length_bytes)\n{\n\tu32 *dw_ptr;\n\tu32 i, length_dw;\n\tu32 rom_offset;\n\tu32 rom_index_offset;\n\tu32 rom_data_offset;\n\n\tif (bios == NULL)\n\t\treturn false;\n\tif (length_bytes == 0)\n\t\treturn false;\n\t \n\tif (adev->flags & AMD_IS_APU)\n\t\treturn false;\n\tif (!adev->smuio.funcs ||\n\t    !adev->smuio.funcs->get_rom_index_offset ||\n\t    !adev->smuio.funcs->get_rom_data_offset)\n\t\treturn false;\n\n\tdw_ptr = (u32 *)bios;\n\tlength_dw = ALIGN(length_bytes, 4) / 4;\n\n\trom_index_offset =\n\t\tadev->smuio.funcs->get_rom_index_offset(adev);\n\trom_data_offset =\n\t\tadev->smuio.funcs->get_rom_data_offset(adev);\n\n\tif (adev->nbio.funcs &&\n\t    adev->nbio.funcs->get_rom_offset) {\n\t\trom_offset = adev->nbio.funcs->get_rom_offset(adev);\n\t\trom_offset = rom_offset << 17;\n\t} else {\n\t\trom_offset = 0;\n\t}\n\n\t \n\tWREG32(rom_index_offset, rom_offset);\n\t \n\tfor (i = 0; i < length_dw; i++)\n\t\tdw_ptr[i] = RREG32(rom_data_offset);\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}