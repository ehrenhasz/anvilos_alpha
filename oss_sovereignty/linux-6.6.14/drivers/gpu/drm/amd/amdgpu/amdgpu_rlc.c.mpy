{
  "module_name": "amdgpu_rlc.c",
  "hash_id": "798e9765a63e544cbecf5a6aba4507e9807052ab7f90ff102793dc9aff08bd41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_rlc.c",
  "human_readable_source": " \n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"amdgpu_rlc.h\"\n\n \nvoid amdgpu_gfx_rlc_enter_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tif (adev->gfx.rlc.in_safe_mode[xcc_id])\n\t\treturn;\n\n\t \n\tif (!adev->gfx.rlc.funcs->is_rlc_enabled(adev))\n\t\treturn;\n\n\tif (adev->cg_flags &\n\t    (AMD_CG_SUPPORT_GFX_CGCG | AMD_CG_SUPPORT_GFX_MGCG |\n\t     AMD_CG_SUPPORT_GFX_3D_CGCG)) {\n\t\tadev->gfx.rlc.funcs->set_safe_mode(adev, xcc_id);\n\t\tadev->gfx.rlc.in_safe_mode[xcc_id] = true;\n\t}\n}\n\n \nvoid amdgpu_gfx_rlc_exit_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tif (!(adev->gfx.rlc.in_safe_mode[xcc_id]))\n\t\treturn;\n\n\t \n\tif (!adev->gfx.rlc.funcs->is_rlc_enabled(adev))\n\t\treturn;\n\n\tif (adev->cg_flags &\n\t    (AMD_CG_SUPPORT_GFX_CGCG | AMD_CG_SUPPORT_GFX_MGCG |\n\t     AMD_CG_SUPPORT_GFX_3D_CGCG)) {\n\t\tadev->gfx.rlc.funcs->unset_safe_mode(adev, xcc_id);\n\t\tadev->gfx.rlc.in_safe_mode[xcc_id] = false;\n\t}\n}\n\n \nint amdgpu_gfx_rlc_init_sr(struct amdgpu_device *adev, u32 dws)\n{\n\tconst u32 *src_ptr;\n\tvolatile u32 *dst_ptr;\n\tu32 i;\n\tint r;\n\n\t \n\tr = amdgpu_bo_create_reserved(adev, dws * 4, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.rlc.save_restore_obj,\n\t\t\t\t      &adev->gfx.rlc.save_restore_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.rlc.sr_ptr);\n\tif (r) {\n\t\tdev_warn(adev->dev, \"(%d) create RLC sr bo failed\\n\", r);\n\t\tamdgpu_gfx_rlc_fini(adev);\n\t\treturn r;\n\t}\n\n\t \n\tsrc_ptr = adev->gfx.rlc.reg_list;\n\tdst_ptr = adev->gfx.rlc.sr_ptr;\n\tfor (i = 0; i < adev->gfx.rlc.reg_list_size; i++)\n\t\tdst_ptr[i] = cpu_to_le32(src_ptr[i]);\n\tamdgpu_bo_kunmap(adev->gfx.rlc.save_restore_obj);\n\tamdgpu_bo_unreserve(adev->gfx.rlc.save_restore_obj);\n\n\treturn 0;\n}\n\n \nint amdgpu_gfx_rlc_init_csb(struct amdgpu_device *adev)\n{\n\tu32 dws;\n\tint r;\n\n\t \n\tadev->gfx.rlc.clear_state_size = dws = adev->gfx.rlc.funcs->get_csb_size(adev);\n\tr = amdgpu_bo_create_kernel(adev, dws * 4, PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.rlc.clear_state_obj,\n\t\t\t\t      &adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.rlc.cs_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create rlc csb bo\\n\", r);\n\t\tamdgpu_gfx_rlc_fini(adev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nint amdgpu_gfx_rlc_init_cpt(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tr = amdgpu_bo_create_reserved(adev, adev->gfx.rlc.cp_table_size,\n\t\t\t\t      PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.rlc.cp_table_obj,\n\t\t\t\t      &adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.rlc.cp_table_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create cp table bo\\n\", r);\n\t\tamdgpu_gfx_rlc_fini(adev);\n\t\treturn r;\n\t}\n\n\t \n\tamdgpu_gfx_rlc_setup_cp_table(adev);\n\tamdgpu_bo_kunmap(adev->gfx.rlc.cp_table_obj);\n\tamdgpu_bo_unreserve(adev->gfx.rlc.cp_table_obj);\n\n\treturn 0;\n}\n\n \nvoid amdgpu_gfx_rlc_setup_cp_table(struct amdgpu_device *adev)\n{\n\tconst __le32 *fw_data;\n\tvolatile u32 *dst_ptr;\n\tint me, i, max_me;\n\tu32 bo_offset = 0;\n\tu32 table_offset, table_size;\n\n\tmax_me = adev->gfx.rlc.funcs->get_cp_table_num(adev);\n\n\t \n\tdst_ptr = adev->gfx.rlc.cp_table_ptr;\n\tfor (me = 0; me < max_me; me++) {\n\t\tif (me == 0) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)adev->gfx.ce_fw->data;\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(adev->gfx.ce_fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t} else if (me == 1) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)adev->gfx.pfp_fw->data;\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(adev->gfx.pfp_fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t} else if (me == 2) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)adev->gfx.me_fw->data;\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(adev->gfx.me_fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t} else if (me == 3) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(adev->gfx.mec_fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t} else  if (me == 4) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)adev->gfx.mec2_fw->data;\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(adev->gfx.mec2_fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t}\n\n\t\tfor (i = 0; i < table_size; i ++) {\n\t\t\tdst_ptr[bo_offset + i] =\n\t\t\t\tcpu_to_le32(le32_to_cpu(fw_data[table_offset + i]));\n\t\t}\n\n\t\tbo_offset += table_size;\n\t}\n}\n\n \nvoid amdgpu_gfx_rlc_fini(struct amdgpu_device *adev)\n{\n\t \n\tif (adev->gfx.rlc.save_restore_obj) {\n\t\tamdgpu_bo_free_kernel(&adev->gfx.rlc.save_restore_obj,\n\t\t\t\t      &adev->gfx.rlc.save_restore_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.rlc.sr_ptr);\n\t}\n\n\t \n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.clear_state_obj,\n\t\t\t      &adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t      (void **)&adev->gfx.rlc.cs_ptr);\n\n\t \n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.cp_table_obj,\n\t\t\t      &adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t      (void **)&adev->gfx.rlc.cp_table_ptr);\n}\n\nstatic int amdgpu_gfx_rlc_init_microcode_v2_0(struct amdgpu_device *adev)\n{\n\tconst struct common_firmware_header *common_hdr;\n\tconst struct rlc_firmware_header_v2_0 *rlc_hdr;\n\tstruct amdgpu_firmware_info *info;\n\tunsigned int *tmp;\n\tunsigned int i;\n\n\trlc_hdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\n\tadev->gfx.rlc_fw_version = le32_to_cpu(rlc_hdr->header.ucode_version);\n\tadev->gfx.rlc_feature_version = le32_to_cpu(rlc_hdr->ucode_feature_version);\n\tadev->gfx.rlc.save_and_restore_offset =\n\t\tle32_to_cpu(rlc_hdr->save_and_restore_offset);\n\tadev->gfx.rlc.clear_state_descriptor_offset =\n\t\tle32_to_cpu(rlc_hdr->clear_state_descriptor_offset);\n\tadev->gfx.rlc.avail_scratch_ram_locations =\n\t\tle32_to_cpu(rlc_hdr->avail_scratch_ram_locations);\n\tadev->gfx.rlc.reg_restore_list_size =\n\t\tle32_to_cpu(rlc_hdr->reg_restore_list_size);\n\tadev->gfx.rlc.reg_list_format_start =\n\t\tle32_to_cpu(rlc_hdr->reg_list_format_start);\n\tadev->gfx.rlc.reg_list_format_separate_start =\n\t\tle32_to_cpu(rlc_hdr->reg_list_format_separate_start);\n\tadev->gfx.rlc.starting_offsets_start =\n\t\tle32_to_cpu(rlc_hdr->starting_offsets_start);\n\tadev->gfx.rlc.reg_list_format_size_bytes =\n\t\tle32_to_cpu(rlc_hdr->reg_list_format_size_bytes);\n\tadev->gfx.rlc.reg_list_size_bytes =\n\t\tle32_to_cpu(rlc_hdr->reg_list_size_bytes);\n\tadev->gfx.rlc.register_list_format =\n\t\tkmalloc(adev->gfx.rlc.reg_list_format_size_bytes +\n\t\t\tadev->gfx.rlc.reg_list_size_bytes, GFP_KERNEL);\n\tif (!adev->gfx.rlc.register_list_format) {\n\t\tdev_err(adev->dev, \"failed to allocate memory for rlc register_list_format\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttmp = (unsigned int *)((uintptr_t)rlc_hdr +\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_format_array_offset_bytes));\n\tfor (i = 0 ; i < (rlc_hdr->reg_list_format_size_bytes >> 2); i++)\n\t\tadev->gfx.rlc.register_list_format[i] = le32_to_cpu(tmp[i]);\n\n\tadev->gfx.rlc.register_restore = adev->gfx.rlc.register_list_format + i;\n\n\ttmp = (unsigned int *)((uintptr_t)rlc_hdr +\n\t\t\tle32_to_cpu(rlc_hdr->reg_list_array_offset_bytes));\n\tfor (i = 0 ; i < (rlc_hdr->reg_list_size_bytes >> 2); i++)\n\t\tadev->gfx.rlc.register_restore[i] = le32_to_cpu(tmp[i]);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_G];\n\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_G;\n\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\tif (info->fw) {\n\t\t\tcommon_hdr = (const struct common_firmware_header *)info->fw->data;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(le32_to_cpu(common_hdr->ucode_size_bytes), PAGE_SIZE);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void amdgpu_gfx_rlc_init_microcode_v2_1(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_1 *rlc_hdr;\n\tstruct amdgpu_firmware_info *info;\n\n\trlc_hdr = (const struct rlc_firmware_header_v2_1 *)adev->gfx.rlc_fw->data;\n\tadev->gfx.rlc_srlc_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_cntl_ucode_ver);\n\tadev->gfx.rlc_srlc_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_cntl_feature_ver);\n\tadev->gfx.rlc.save_restore_list_cntl_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_cntl_size_bytes);\n\tadev->gfx.rlc.save_restore_list_cntl = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_cntl_offset_bytes);\n\tadev->gfx.rlc_srlg_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_gpm_ucode_ver);\n\tadev->gfx.rlc_srlg_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_gpm_feature_ver);\n\tadev->gfx.rlc.save_restore_list_gpm_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_gpm_size_bytes);\n\tadev->gfx.rlc.save_restore_list_gpm = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_gpm_offset_bytes);\n\tadev->gfx.rlc_srls_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_srm_ucode_ver);\n\tadev->gfx.rlc_srls_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_srm_feature_ver);\n\tadev->gfx.rlc.save_restore_list_srm_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_srm_size_bytes);\n\tadev->gfx.rlc.save_restore_list_srm = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_srm_offset_bytes);\n\tadev->gfx.rlc.reg_list_format_direct_reg_list_length =\n\t\tle32_to_cpu(rlc_hdr->reg_list_format_direct_reg_list_length);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tif (adev->gfx.rlc.save_restore_list_cntl_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.save_restore_list_cntl_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.save_restore_list_gpm_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.save_restore_list_gpm_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.save_restore_list_srm_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.save_restore_list_srm_size_bytes, PAGE_SIZE);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_gfx_rlc_init_microcode_v2_2(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_2 *rlc_hdr;\n\tstruct amdgpu_firmware_info *info;\n\n\trlc_hdr = (const struct rlc_firmware_header_v2_2 *)adev->gfx.rlc_fw->data;\n\tadev->gfx.rlc.rlc_iram_ucode_size_bytes = le32_to_cpu(rlc_hdr->rlc_iram_ucode_size_bytes);\n\tadev->gfx.rlc.rlc_iram_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->rlc_iram_ucode_offset_bytes);\n\tadev->gfx.rlc.rlc_dram_ucode_size_bytes = le32_to_cpu(rlc_hdr->rlc_dram_ucode_size_bytes);\n\tadev->gfx.rlc.rlc_dram_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->rlc_dram_ucode_offset_bytes);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tif (adev->gfx.rlc.rlc_iram_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_IRAM];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_IRAM;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.rlc_iram_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.rlc_dram_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_DRAM];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_DRAM;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.rlc_dram_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_gfx_rlc_init_microcode_v2_3(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_3 *rlc_hdr;\n\tstruct amdgpu_firmware_info *info;\n\n\trlc_hdr = (const struct rlc_firmware_header_v2_3 *)adev->gfx.rlc_fw->data;\n\tadev->gfx.rlcp_ucode_version = le32_to_cpu(rlc_hdr->rlcp_ucode_version);\n\tadev->gfx.rlcp_ucode_feature_version = le32_to_cpu(rlc_hdr->rlcp_ucode_feature_version);\n\tadev->gfx.rlc.rlcp_ucode_size_bytes = le32_to_cpu(rlc_hdr->rlcp_ucode_size_bytes);\n\tadev->gfx.rlc.rlcp_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->rlcp_ucode_offset_bytes);\n\n\tadev->gfx.rlcv_ucode_version = le32_to_cpu(rlc_hdr->rlcv_ucode_version);\n\tadev->gfx.rlcv_ucode_feature_version = le32_to_cpu(rlc_hdr->rlcv_ucode_feature_version);\n\tadev->gfx.rlc.rlcv_ucode_size_bytes = le32_to_cpu(rlc_hdr->rlcv_ucode_size_bytes);\n\tadev->gfx.rlc.rlcv_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->rlcv_ucode_offset_bytes);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tif (adev->gfx.rlc.rlcp_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_P];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_P;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.rlcp_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.rlcv_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_V];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_RLC_V;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.rlcv_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\t}\n}\n\nstatic void amdgpu_gfx_rlc_init_microcode_v2_4(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_4 *rlc_hdr;\n\tstruct amdgpu_firmware_info *info;\n\n\trlc_hdr = (const struct rlc_firmware_header_v2_4 *)adev->gfx.rlc_fw->data;\n\tadev->gfx.rlc.global_tap_delays_ucode_size_bytes = le32_to_cpu(rlc_hdr->global_tap_delays_ucode_size_bytes);\n\tadev->gfx.rlc.global_tap_delays_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->global_tap_delays_ucode_offset_bytes);\n\tadev->gfx.rlc.se0_tap_delays_ucode_size_bytes = le32_to_cpu(rlc_hdr->se0_tap_delays_ucode_size_bytes);\n\tadev->gfx.rlc.se0_tap_delays_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->se0_tap_delays_ucode_offset_bytes);\n\tadev->gfx.rlc.se1_tap_delays_ucode_size_bytes = le32_to_cpu(rlc_hdr->se1_tap_delays_ucode_size_bytes);\n\tadev->gfx.rlc.se1_tap_delays_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->se1_tap_delays_ucode_offset_bytes);\n\tadev->gfx.rlc.se2_tap_delays_ucode_size_bytes = le32_to_cpu(rlc_hdr->se2_tap_delays_ucode_size_bytes);\n\tadev->gfx.rlc.se2_tap_delays_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->se2_tap_delays_ucode_offset_bytes);\n\tadev->gfx.rlc.se3_tap_delays_ucode_size_bytes = le32_to_cpu(rlc_hdr->se3_tap_delays_ucode_size_bytes);\n\tadev->gfx.rlc.se3_tap_delays_ucode = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->se3_tap_delays_ucode_offset_bytes);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tif (adev->gfx.rlc.global_tap_delays_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_GLOBAL_TAP_DELAYS];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_GLOBAL_TAP_DELAYS;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.global_tap_delays_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.se0_tap_delays_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SE0_TAP_DELAYS];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SE0_TAP_DELAYS;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.se0_tap_delays_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.se1_tap_delays_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SE1_TAP_DELAYS];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SE1_TAP_DELAYS;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.se1_tap_delays_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.se2_tap_delays_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SE2_TAP_DELAYS];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SE2_TAP_DELAYS;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.se2_tap_delays_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\n\t\tif (adev->gfx.rlc.se3_tap_delays_ucode_size_bytes) {\n\t\t\tinfo = &adev->firmware.ucode[AMDGPU_UCODE_ID_SE3_TAP_DELAYS];\n\t\t\tinfo->ucode_id = AMDGPU_UCODE_ID_SE3_TAP_DELAYS;\n\t\t\tinfo->fw = adev->gfx.rlc_fw;\n\t\t\tadev->firmware.fw_size +=\n\t\t\t\tALIGN(adev->gfx.rlc.se3_tap_delays_ucode_size_bytes, PAGE_SIZE);\n\t\t}\n\t}\n}\n\nint amdgpu_gfx_rlc_init_microcode(struct amdgpu_device *adev,\n\t\t\t\t  uint16_t version_major,\n\t\t\t\t  uint16_t version_minor)\n{\n\tint err;\n\n\tif (version_major < 2) {\n\t\t \n\t\tdev_err(adev->dev, \"unsupported rlc fw hdr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (version_major == 2 && version_minor == 1)\n\t\tadev->gfx.rlc.is_rlc_v2_1 = true;\n\n\tif (version_minor >= 0) {\n\t\terr = amdgpu_gfx_rlc_init_microcode_v2_0(adev);\n\t\tif (err) {\n\t\t\tdev_err(adev->dev, \"fail to init rlc v2_0 microcode\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (version_minor >= 1)\n\t\tamdgpu_gfx_rlc_init_microcode_v2_1(adev);\n\tif (version_minor >= 2)\n\t\tamdgpu_gfx_rlc_init_microcode_v2_2(adev);\n\tif (version_minor == 3)\n\t\tamdgpu_gfx_rlc_init_microcode_v2_3(adev);\n\tif (version_minor == 4)\n\t\tamdgpu_gfx_rlc_init_microcode_v2_4(adev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}