{
  "module_name": "amdgpu_amdkfd_gc_9_4_3.c",
  "hash_id": "38a1b1773795ca5cb6ac415de3d362ed625e6dca3867cc3900ced708603d118f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gc_9_4_3.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_amdkfd_gfx_v9.h\"\n#include \"amdgpu_amdkfd_aldebaran.h\"\n#include \"gc/gc_9_4_3_offset.h\"\n#include \"gc/gc_9_4_3_sh_mask.h\"\n#include \"athub/athub_1_8_0_offset.h\"\n#include \"athub/athub_1_8_0_sh_mask.h\"\n#include \"oss/osssys_4_4_2_offset.h\"\n#include \"oss/osssys_4_4_2_sh_mask.h\"\n#include \"v9_structs.h\"\n#include \"soc15.h\"\n#include \"sdma/sdma_4_4_2_offset.h\"\n#include \"sdma/sdma_4_4_2_sh_mask.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\nstatic inline struct v9_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct v9_sdma_mqd *)mqd;\n}\n\nstatic uint32_t get_sdma_rlc_reg_offset(struct amdgpu_device *adev,\n\t\t\t\t\tunsigned int engine_id,\n\t\t\t\t\tunsigned int queue_id)\n{\n\tuint32_t sdma_engine_reg_base =\n\t\tSOC15_REG_OFFSET(SDMA0, GET_INST(SDMA0, engine_id),\n\t\t\t\t regSDMA_RLC0_RB_CNTL) -\n\t\tregSDMA_RLC0_RB_CNTL;\n\tuint32_t retval = sdma_engine_reg_base +\n\t\t  queue_id * (regSDMA_RLC1_RB_CNTL - regSDMA_RLC0_RB_CNTL);\n\n\tpr_debug(\"RLC register offset for SDMA%d RLC%d: 0x%x\\n\", engine_id,\n\t\t\t\t\t\t\tqueue_id, retval);\n\treturn retval;\n}\n\nstatic int kgd_gfx_v9_4_3_hqd_sdma_load(struct amdgpu_device *adev, void *mqd,\n\t\t\t\t uint32_t __user *wptr, struct mm_struct *mm)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tunsigned long end_jiffies;\n\tuint32_t data;\n\tuint64_t data64;\n\tuint64_t __user *wptr64 = (uint64_t __user *)wptr;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t\t\tm->sdma_queue_id);\n\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL,\n\t\tm->sdmax_rlcx_rb_cntl & (~SDMA_RLC0_RB_CNTL__RB_ENABLE_MASK));\n\n\tend_jiffies = msecs_to_jiffies(2000) + jiffies;\n\twhile (true) {\n\t\tdata = RREG32(sdma_rlc_reg_offset + regSDMA_RLC0_CONTEXT_STATUS);\n\t\tif (data & SDMA_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_DOORBELL_OFFSET,\n\t\tm->sdmax_rlcx_doorbell_offset);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_doorbell, SDMA_RLC0_DOORBELL,\n\t\t\t\tENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_DOORBELL, data);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR,\n\t\t\t\t\tm->sdmax_rlcx_rb_rptr);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR_HI,\n\t\t\t\t\tm->sdmax_rlcx_rb_rptr_hi);\n\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_MINOR_PTR_UPDATE, 1);\n\tif (read_user_wptr(mm, wptr64, data64)) {\n\t\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_WPTR,\n\t\t\tlower_32_bits(data64));\n\t\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_WPTR_HI,\n\t\t\tupper_32_bits(data64));\n\t} else {\n\t\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_WPTR,\n\t\t\tm->sdmax_rlcx_rb_rptr);\n\t\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_WPTR_HI,\n\t\t\tm->sdmax_rlcx_rb_rptr_hi);\n\t}\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_MINOR_PTR_UPDATE, 0);\n\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_BASE, m->sdmax_rlcx_rb_base);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_BASE_HI,\n\t\t\tm->sdmax_rlcx_rb_base_hi);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR_ADDR_LO,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_lo);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR_ADDR_HI,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_hi);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_rb_cntl, SDMA_RLC0_RB_CNTL,\n\t\t\t\tRB_ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL, data);\n\n\treturn 0;\n}\n\nstatic int kgd_gfx_v9_4_3_hqd_sdma_dump(struct amdgpu_device *adev,\n\t\t\t\t uint32_t engine_id, uint32_t queue_id,\n\t\t\t\t uint32_t (**dump)[2], uint32_t *n_regs)\n{\n\tuint32_t sdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev,\n\t\t\t\t\t\t\tengine_id, queue_id);\n\tuint32_t i = 0, reg;\n#undef HQD_N_REGS\n#define HQD_N_REGS (19+6+7+12)\n#define DUMP_REG(addr) do {\t\t\t\t\\\n\t\tif (WARN_ON_ONCE(i >= HQD_N_REGS))      \\\n\t\t\tbreak;\t\t\t\t\\\n\t\t(*dump)[i][0] = (addr) << 2;            \\\n\t\t(*dump)[i++][1] = RREG32(addr);         \\\n\t} while (0)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (reg = regSDMA_RLC0_RB_CNTL; reg <= regSDMA_RLC0_DOORBELL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = regSDMA_RLC0_STATUS; reg <= regSDMA_RLC0_CSA_ADDR_HI; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = regSDMA_RLC0_IB_SUB_REMAIN;\n\t     reg <= regSDMA_RLC0_MINOR_PTR_UPDATE; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = regSDMA_RLC0_MIDCMD_DATA0;\n\t     reg <= regSDMA_RLC0_MIDCMD_CNTL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nstatic bool kgd_gfx_v9_4_3_hqd_sdma_is_occupied(struct amdgpu_device *adev, void *mqd)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t sdma_rlc_rb_cntl;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t\t\tm->sdma_queue_id);\n\n\tsdma_rlc_rb_cntl = RREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL);\n\n\tif (sdma_rlc_rb_cntl & SDMA_RLC0_RB_CNTL__RB_ENABLE_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int kgd_gfx_v9_4_3_hqd_sdma_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\t    unsigned int utimeout)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t temp;\n\tunsigned long end_jiffies = (utimeout * HZ / 1000) + jiffies;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t\t\tm->sdma_queue_id);\n\n\ttemp = RREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL);\n\ttemp = temp & ~SDMA_RLC0_RB_CNTL__RB_ENABLE_MASK;\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL, temp);\n\n\twhile (true) {\n\t\ttemp = RREG32(sdma_rlc_reg_offset + regSDMA_RLC0_CONTEXT_STATUS);\n\t\tif (temp & SDMA_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_DOORBELL, 0);\n\tWREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL,\n\t\tRREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_CNTL) |\n\t\tSDMA_RLC0_RB_CNTL__RB_ENABLE_MASK);\n\n\tm->sdmax_rlcx_rb_rptr =\n\t\t\tRREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR);\n\tm->sdmax_rlcx_rb_rptr_hi =\n\t\t\tRREG32(sdma_rlc_reg_offset + regSDMA_RLC0_RB_RPTR_HI);\n\n\treturn 0;\n}\n\nstatic int kgd_gfx_v9_4_3_set_pasid_vmid_mapping(struct amdgpu_device *adev,\n\t\t\tu32 pasid, unsigned int vmid, uint32_t xcc_inst)\n{\n\tunsigned long timeout;\n\tunsigned int reg;\n\tunsigned int phy_inst = GET_INST(GC, xcc_inst);\n\t \n\tunsigned int aid = phy_inst / 2;\n\n\t \n\tuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\n\t\t\tATC_VMID0_PASID_MAPPING__VALID_MASK;\n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0,\n\t\tregATC_VMID0_PASID_MAPPING) + vmid, pasid_mapping);\n\n\ttimeout = jiffies + msecs_to_jiffies(10);\n\twhile (!(RREG32(SOC15_REG_OFFSET(ATHUB, 0,\n\t\t\tregATC_VMID_PASID_MAPPING_UPDATE_STATUS)) &\n\t\t\t(1U << vmid))) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tpr_err(\"Fail to program VMID-PASID mapping\\n\");\n\t\t\treturn -ETIME;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0,\n\t\tregATC_VMID_PASID_MAPPING_UPDATE_STATUS),\n\t\t1U << vmid);\n\n\treg = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_LUT_INDEX));\n\t \n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_LUT_INDEX),\n\t\taid * 4 + (phy_inst % 2) + 1);\n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_0_LUT) + vmid,\n\t\tpasid_mapping);\n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_LUT_INDEX),\n\t\taid * 4);\n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_0_LUT_MM) + vmid,\n\t\tpasid_mapping);\n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, regIH_VMID_LUT_INDEX), reg);\n\n\treturn 0;\n}\n\nstatic inline struct v9_mqd *get_mqd(void *mqd)\n{\n\treturn (struct v9_mqd *)mqd;\n}\n\nstatic int kgd_gfx_v9_4_3_hqd_load(struct amdgpu_device *adev, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tuint32_t __user *wptr, uint32_t wptr_shift,\n\t\t\tuint32_t wptr_mask, struct mm_struct *mm, uint32_t inst)\n{\n\tstruct v9_mqd *m;\n\tuint32_t *mqd_hqd;\n\tuint32_t reg, hqd_base, hqd_end, data;\n\n\tm = get_mqd(mqd);\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\n\t \n\tmqd_hqd = &m->cp_mqd_base_addr_lo;\n\thqd_base = SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_MQD_BASE_ADDR);\n\thqd_end = SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_AQL_DISPATCH_ID_HI);\n\n\tfor (reg = hqd_base; reg <= hqd_end; reg++)\n\t\tWREG32_RLC(reg, mqd_hqd[reg - hqd_base]);\n\n\n\t \n\tdata = REG_SET_FIELD(m->cp_hqd_pq_doorbell_control,\n\t\t\t     CP_HQD_PQ_DOORBELL_CONTROL, DOORBELL_EN, 1);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_PQ_DOORBELL_CONTROL),\n\t\t\t\tdata);\n\n\tif (wptr) {\n\t\t \n\t\tuint32_t queue_size =\n\t\t\t2 << REG_GET_FIELD(m->cp_hqd_pq_control,\n\t\t\t\t\t   CP_HQD_PQ_CONTROL, QUEUE_SIZE);\n\t\tuint64_t guessed_wptr = m->cp_hqd_pq_rptr & (queue_size - 1);\n\n\t\tif ((m->cp_hqd_pq_wptr_lo & (queue_size - 1)) < guessed_wptr)\n\t\t\tguessed_wptr += queue_size;\n\t\tguessed_wptr += m->cp_hqd_pq_wptr_lo & ~(queue_size - 1);\n\t\tguessed_wptr += (uint64_t)m->cp_hqd_pq_wptr_hi << 32;\n\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_PQ_WPTR_LO),\n\t\t       lower_32_bits(guessed_wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_PQ_WPTR_HI),\n\t\t       upper_32_bits(guessed_wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_PQ_WPTR_POLL_ADDR),\n\t\t       lower_32_bits((uintptr_t)wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst),\n\t\t\tregCP_HQD_PQ_WPTR_POLL_ADDR_HI),\n\t\t\tupper_32_bits((uintptr_t)wptr));\n\t\tWREG32(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_PQ_WPTR_POLL_CNTL1),\n\t\t       (uint32_t)kgd_gfx_v9_get_queue_mask(adev, pipe_id,\n\t\t\t       queue_id));\n\t}\n\n\t \n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_EOP_RPTR),\n\t       REG_SET_FIELD(m->cp_hqd_eop_rptr,\n\t\t\t     CP_HQD_EOP_RPTR, INIT_FETCHER, 1));\n\n\tdata = REG_SET_FIELD(m->cp_hqd_active, CP_HQD_ACTIVE, ACTIVE, 1);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), regCP_HQD_ACTIVE), data);\n\n\tkgd_gfx_v9_release_queue(adev, inst);\n\n\treturn 0;\n}\n\n \nstatic uint32_t kgd_gfx_v9_4_3_disable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool keep_trap_enabled,\n\t\t\t\t\t\tuint32_t vmid)\n{\n\tuint32_t data = 0;\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, 1);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_EN, 0);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_REPLACE, 0);\n\n\treturn data;\n}\n\nstatic int kgd_gfx_v9_4_3_validate_trap_override_request(\n\t\t\t\tstruct amdgpu_device *adev,\n\t\t\t\tuint32_t trap_override,\n\t\t\t\tuint32_t *trap_mask_supported)\n{\n\t*trap_mask_supported &= KFD_DBG_TRAP_MASK_FP_INVALID |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INPUT_DENORMAL |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_OVERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_UNDERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INEXACT |\n\t\t\t\tKFD_DBG_TRAP_MASK_INT_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_ADDRESS_WATCH |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_MEMORY_VIOLATION |\n\t\t\t\tKFD_DBG_TRAP_MASK_TRAP_ON_WAVE_START |\n\t\t\t\tKFD_DBG_TRAP_MASK_TRAP_ON_WAVE_END;\n\n\tif (trap_override != KFD_DBG_TRAP_OVERRIDE_OR &&\n\t\t\ttrap_override != KFD_DBG_TRAP_OVERRIDE_REPLACE)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic uint32_t trap_mask_map_sw_to_hw(uint32_t mask)\n{\n\tuint32_t trap_on_start = (mask & KFD_DBG_TRAP_MASK_TRAP_ON_WAVE_START) ? 1 : 0;\n\tuint32_t trap_on_end = (mask & KFD_DBG_TRAP_MASK_TRAP_ON_WAVE_END) ? 1 : 0;\n\tuint32_t excp_en = mask & (KFD_DBG_TRAP_MASK_FP_INVALID |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INPUT_DENORMAL |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_OVERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_UNDERFLOW |\n\t\t\t\tKFD_DBG_TRAP_MASK_FP_INEXACT |\n\t\t\t\tKFD_DBG_TRAP_MASK_INT_DIVIDE_BY_ZERO |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_ADDRESS_WATCH |\n\t\t\t\tKFD_DBG_TRAP_MASK_DBG_MEMORY_VIOLATION);\n\tuint32_t ret;\n\n\tret = REG_SET_FIELD(0, SPI_GDBG_PER_VMID_CNTL, EXCP_EN, excp_en);\n\tret = REG_SET_FIELD(ret, SPI_GDBG_PER_VMID_CNTL, TRAP_ON_START, trap_on_start);\n\tret = REG_SET_FIELD(ret, SPI_GDBG_PER_VMID_CNTL, TRAP_ON_END, trap_on_end);\n\n\treturn ret;\n}\n\nstatic uint32_t trap_mask_map_hw_to_sw(uint32_t mask)\n{\n\tuint32_t ret = REG_GET_FIELD(mask, SPI_GDBG_PER_VMID_CNTL, EXCP_EN);\n\n\tif (REG_GET_FIELD(mask, SPI_GDBG_PER_VMID_CNTL, TRAP_ON_START))\n\t\tret |= KFD_DBG_TRAP_MASK_TRAP_ON_WAVE_START;\n\n\tif (REG_GET_FIELD(mask, SPI_GDBG_PER_VMID_CNTL, TRAP_ON_END))\n\t\tret |= KFD_DBG_TRAP_MASK_TRAP_ON_WAVE_END;\n\n\treturn ret;\n}\n\n \nstatic uint32_t kgd_gfx_v9_4_3_set_wave_launch_trap_override(\n\t\t\t\tstruct amdgpu_device *adev,\n\t\t\t\tuint32_t vmid,\n\t\t\t\tuint32_t trap_override,\n\t\t\t\tuint32_t trap_mask_bits,\n\t\t\t\tuint32_t trap_mask_request,\n\t\t\t\tuint32_t *trap_mask_prev,\n\t\t\t\tuint32_t kfd_dbg_trap_cntl_prev)\n\n{\n\tuint32_t data = 0;\n\n\t*trap_mask_prev = trap_mask_map_hw_to_sw(kfd_dbg_trap_cntl_prev);\n\n\tdata = (trap_mask_bits & trap_mask_request) |\n\t       (*trap_mask_prev & ~trap_mask_request);\n\tdata = trap_mask_map_sw_to_hw(data);\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, 1);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, EXCP_REPLACE, trap_override);\n\n\treturn data;\n}\n\n#define TCP_WATCH_STRIDE (regTCP_WATCH1_ADDR_H - regTCP_WATCH0_ADDR_H)\nstatic uint32_t kgd_gfx_v9_4_3_set_address_watch(\n\t\t\t\tstruct amdgpu_device *adev,\n\t\t\t\tuint64_t watch_address,\n\t\t\t\tuint32_t watch_address_mask,\n\t\t\t\tuint32_t watch_id,\n\t\t\t\tuint32_t watch_mode,\n\t\t\t\tuint32_t debug_vmid,\n\t\t\t\tuint32_t inst)\n{\n\tuint32_t watch_address_high;\n\tuint32_t watch_address_low;\n\tuint32_t watch_address_cntl;\n\n\twatch_address_cntl = 0;\n\twatch_address_low = lower_32_bits(watch_address);\n\twatch_address_high = upper_32_bits(watch_address) & 0xffff;\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMODE,\n\t\t\twatch_mode);\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMASK,\n\t\t\twatch_address_mask >> 7);\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tVALID,\n\t\t\t1);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, GET_INST(GC, inst),\n\t\t\tregTCP_WATCH0_ADDR_H) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_high);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, GET_INST(GC, inst),\n\t\t\tregTCP_WATCH0_ADDR_L) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_low);\n\n\treturn watch_address_cntl;\n}\n\nstatic uint32_t kgd_gfx_v9_4_3_clear_address_watch(struct amdgpu_device *adev,\n\t\t\t\tuint32_t watch_id)\n{\n\treturn 0;\n}\n\nconst struct kfd2kgd_calls gc_9_4_3_kfd2kgd = {\n\t.program_sh_mem_settings = kgd_gfx_v9_program_sh_mem_settings,\n\t.set_pasid_vmid_mapping = kgd_gfx_v9_4_3_set_pasid_vmid_mapping,\n\t.init_interrupts = kgd_gfx_v9_init_interrupts,\n\t.hqd_load = kgd_gfx_v9_4_3_hqd_load,\n\t.hiq_mqd_load = kgd_gfx_v9_hiq_mqd_load,\n\t.hqd_sdma_load = kgd_gfx_v9_4_3_hqd_sdma_load,\n\t.hqd_dump = kgd_gfx_v9_hqd_dump,\n\t.hqd_sdma_dump = kgd_gfx_v9_4_3_hqd_sdma_dump,\n\t.hqd_is_occupied = kgd_gfx_v9_hqd_is_occupied,\n\t.hqd_sdma_is_occupied = kgd_gfx_v9_4_3_hqd_sdma_is_occupied,\n\t.hqd_destroy = kgd_gfx_v9_hqd_destroy,\n\t.hqd_sdma_destroy = kgd_gfx_v9_4_3_hqd_sdma_destroy,\n\t.wave_control_execute = kgd_gfx_v9_wave_control_execute,\n\t.get_atc_vmid_pasid_mapping_info =\n\t\t\t\tkgd_gfx_v9_get_atc_vmid_pasid_mapping_info,\n\t.set_vm_context_page_table_base =\n\t\t\t\tkgd_gfx_v9_set_vm_context_page_table_base,\n\t.get_cu_occupancy = kgd_gfx_v9_get_cu_occupancy,\n\t.program_trap_handler_settings =\n\t\t\t\tkgd_gfx_v9_program_trap_handler_settings,\n\t.build_grace_period_packet_info =\n\t\t\t\tkgd_gfx_v9_build_grace_period_packet_info,\n\t.get_iq_wait_times = kgd_gfx_v9_get_iq_wait_times,\n\t.enable_debug_trap = kgd_aldebaran_enable_debug_trap,\n\t.disable_debug_trap = kgd_gfx_v9_4_3_disable_debug_trap,\n\t.validate_trap_override_request =\n\t\t\tkgd_gfx_v9_4_3_validate_trap_override_request,\n\t.set_wave_launch_trap_override =\n\t\t\tkgd_gfx_v9_4_3_set_wave_launch_trap_override,\n\t.set_wave_launch_mode = kgd_aldebaran_set_wave_launch_mode,\n\t.set_address_watch = kgd_gfx_v9_4_3_set_address_watch,\n\t.clear_address_watch = kgd_gfx_v9_4_3_clear_address_watch\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}