{
  "module_name": "nbio_v4_3.c",
  "hash_id": "f36eb9003b53d051f216b512e2d98648ad480a5f098afad8abef9c110ca3a346",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/nbio_v4_3.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"nbio_v4_3.h\"\n\n#include \"nbio/nbio_4_3_0_offset.h\"\n#include \"nbio/nbio_4_3_0_sh_mask.h\"\n#include \"ivsrcid/nbio/irqsrcs_nbif_7_4.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\nstatic void nbio_v4_3_remap_hdp_registers(struct amdgpu_device *adev)\n{\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_MEM_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL);\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_REG_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL);\n}\n\nstatic u32 nbio_v4_3_get_rev_id(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0);\n\n\ttmp &= RCC_STRAP0_RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0_MASK;\n\ttmp >>= RCC_STRAP0_RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0__SHIFT;\n\n\treturn tmp;\n}\n\nstatic void nbio_v4_3_mc_access_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN,\n\t\t\t     BIF_BX0_BIF_FB_EN__FB_READ_EN_MASK |\n\t\t\t     BIF_BX0_BIF_FB_EN__FB_WRITE_EN_MASK);\n\telse\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN, 0);\n}\n\nstatic u32 nbio_v4_3_get_memsize(struct amdgpu_device *adev)\n{\n\treturn RREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF0_RCC_CONFIG_MEMSIZE);\n}\n\nstatic void nbio_v4_3_sdma_doorbell_range(struct amdgpu_device *adev, int instance,\n\t\t\t\t\t  bool use_doorbell, int doorbell_index,\n\t\t\t\t\t  int doorbell_size)\n{\n\tif (instance == 0) {\n\t\tu32 doorbell_range = RREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_2_CTRL);\n\n\t\tif (use_doorbell) {\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_ENABLE,\n\t\t\t\t\t\t       0x1);\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_AWID,\n\t\t\t\t\t\t       0xe);\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_RANGE_OFFSET,\n\t\t\t\t\t\t       doorbell_index);\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_RANGE_SIZE,\n\t\t\t\t\t\t       doorbell_size);\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_AWADDR_31_28_VALUE,\n\t\t\t\t\t\t       0x3);\n\t\t} else\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t       S2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\t\t\t\t       S2A_DOORBELL_PORT2_RANGE_SIZE,\n\t\t\t\t\t\t       0);\n\n\t\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_2_CTRL, doorbell_range);\n\t}\n}\n\nstatic void nbio_v4_3_vcn_doorbell_range(struct amdgpu_device *adev, bool use_doorbell,\n\t\t\t\t\t int doorbell_index, int instance)\n{\n\tu32 doorbell_range;\n\n\tif (instance)\n\t\tdoorbell_range = RREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_5_CTRL);\n\telse\n\t\tdoorbell_range = RREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_4_CTRL);\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_ENABLE,\n\t\t\t\t\t       0x1);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_AWID,\n\t\t\t\t\t       instance ? 0x7 : 0x4);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_RANGE_OFFSET,\n\t\t\t\t\t       doorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_RANGE_SIZE,\n\t\t\t\t\t       8);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_AWADDR_31_28_VALUE,\n\t\t\t\t\t       instance ? 0x7 : 0x4);\n\t} else\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       S2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\t\t       S2A_DOORBELL_PORT4_RANGE_SIZE,\n\t\t\t\t\t       0);\n\n\tif (instance)\n\t\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_5_CTRL, doorbell_range);\n\telse\n\t\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_4_CTRL, doorbell_range);\n}\n\nstatic void nbio_v4_3_gc_doorbell_init(struct amdgpu_device *adev)\n{\n\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_0_CTRL, 0x30000007);\n\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_3_CTRL, 0x3000000d);\n}\n\nstatic void nbio_v4_3_enable_doorbell_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tWREG32_FIELD15_PREREG(NBIO, 0, RCC_DEV0_EPF0_RCC_DOORBELL_APER_EN,\n\t\t\tBIF_DOORBELL_APER_EN, enable ? 1 : 0);\n}\n\nstatic void nbio_v4_3_enable_doorbell_selfring_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tbool enable)\n{\n\tu32 tmp = 0;\n\n\tif (enable) {\n\t\ttmp = REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_EN, 1) |\n\t\t      REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_MODE, 1) |\n\t\t      REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_SIZE, 0);\n\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_LOW,\n\t\t\t     lower_32_bits(adev->doorbell.base));\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_HIGH,\n\t\t\t     upper_32_bits(adev->doorbell.base));\n\t}\n\n\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t     tmp);\n}\n\nstatic void nbio_v4_3_ih_doorbell_range(struct amdgpu_device *adev,\n\t\t\t\t\tbool use_doorbell, int doorbell_index)\n{\n\tu32 ih_doorbell_range = RREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_1_CTRL);\n\n\tif (use_doorbell) {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_ENABLE,\n\t\t\t\t\t\t  0x1);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_AWID,\n\t\t\t\t\t\t  0x0);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_RANGE_OFFSET,\n\t\t\t\t\t\t  doorbell_index);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_RANGE_SIZE,\n\t\t\t\t\t\t  2);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_AWADDR_31_28_VALUE,\n\t\t\t\t\t\t  0x0);\n\t} else\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\t\t  S2A_DOORBELL_PORT1_RANGE_SIZE,\n\t\t\t\t\t\t  0);\n\n\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_1_CTRL, ih_doorbell_range);\n}\n\nstatic void nbio_v4_3_ih_control(struct amdgpu_device *adev)\n{\n\tu32 interrupt_cntl;\n\n\t \n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL2, adev->dummy_page_addr >> 8);\n\n\tinterrupt_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL,\n\t\t\t\t       IH_DUMMY_RD_OVERRIDE, 0);\n\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL,\n\t\t\t\t       IH_REQ_NONSNOOP_EN, 0);\n\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL, interrupt_cntl);\n}\n\nstatic void nbio_v4_3_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tuint32_t def, data;\n\n\tif (enable && !(adev->cg_flags & AMD_CG_SUPPORT_BIF_MGCG))\n\t\treturn;\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regCPM_CONTROL);\n\tif (enable) {\n\t\tdata |= (CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_LCNT_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_REGS_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_PRBS_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__REFCLK_REGS_GATE_ENABLE_MASK);\n\t} else {\n\t\tdata &= ~(CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_LCNT_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_REGS_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_PRBS_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__REFCLK_REGS_GATE_ENABLE_MASK);\n\t}\n\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regCPM_CONTROL, data);\n}\n\nstatic void nbio_v4_3_update_medium_grain_light_sleep(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t def, data;\n\n\tif (enable && !(adev->cg_flags & AMD_CG_SUPPORT_BIF_LS))\n\t\treturn;\n\n\t \n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_CNTL2);\n\tif (enable) {\n\t\tdata |= PCIE_CNTL2__SLV_MEM_LS_EN_MASK;\n\t} else {\n\t\tdata &= ~PCIE_CNTL2__SLV_MEM_LS_EN_MASK;\n\t}\n\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_CNTL2, data);\n}\n\nstatic void nbio_v4_3_get_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t    u64 *flags)\n{\n\tint data;\n\n\t \n\tdata = RREG32_SOC15(NBIO, 0, regCPM_CONTROL);\n\tif (data & CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_MGCG;\n\n\t \n\tdata = RREG32_SOC15(NBIO, 0, regPCIE_CNTL2);\n\tif (data & PCIE_CNTL2__SLV_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_LS;\n}\n\nstatic u32 nbio_v4_3_get_hdp_flush_req_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_REQ);\n}\n\nstatic u32 nbio_v4_3_get_hdp_flush_done_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_DONE);\n}\n\nstatic u32 nbio_v4_3_get_pcie_index_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_RSMU_INDEX);\n}\n\nstatic u32 nbio_v4_3_get_pcie_data_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_RSMU_DATA);\n}\n\nconst struct nbio_hdp_flush_reg nbio_v4_3_hdp_flush_reg = {\n\t.ref_and_mask_cp0 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP0_MASK,\n\t.ref_and_mask_cp1 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP1_MASK,\n\t.ref_and_mask_cp2 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP2_MASK,\n\t.ref_and_mask_cp3 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP3_MASK,\n\t.ref_and_mask_cp4 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP4_MASK,\n\t.ref_and_mask_cp5 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP5_MASK,\n\t.ref_and_mask_cp6 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP6_MASK,\n\t.ref_and_mask_cp7 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP7_MASK,\n\t.ref_and_mask_cp8 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP8_MASK,\n\t.ref_and_mask_cp9 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__CP9_MASK,\n\t.ref_and_mask_sdma0 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__SDMA0_MASK,\n\t.ref_and_mask_sdma1 = BIF_BX_PF_GPU_HDP_FLUSH_DONE__SDMA1_MASK,\n};\n\nstatic void nbio_v4_3_init_registers(struct amdgpu_device *adev)\n{\n\tif (adev->ip_versions[NBIO_HWIP][0] == IP_VERSION(4, 3, 0)) {\n\t\tuint32_t data;\n\n\t\tdata = RREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF2_STRAP2);\n\t\tdata &= ~RCC_DEV0_EPF2_STRAP2__STRAP_NO_SOFT_RESET_DEV0_F2_MASK;\n\t\tWREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF2_STRAP2, data);\n\t}\n\tif (amdgpu_sriov_vf(adev))\n\t\tadev->rmmio_remap.reg_offset = SOC15_REG_OFFSET(NBIO, 0,\n\t\t\tregBIF_BX_DEV0_EPF0_VF0_HDP_MEM_COHERENCY_FLUSH_CNTL) << 2;\n}\n\nstatic u32 nbio_v4_3_get_rom_offset(struct amdgpu_device *adev)\n{\n\tu32 data, rom_offset;\n\n\tdata = RREG32_SOC15(NBIO, 0, regREGS_ROM_OFFSET_CTRL);\n\trom_offset = REG_GET_FIELD(data, REGS_ROM_OFFSET_CTRL, ROM_OFFSET);\n\n\treturn rom_offset;\n}\n\n#ifdef CONFIG_PCIEASPM\nstatic void nbio_v4_3_program_ltr(struct amdgpu_device *adev)\n{\n\tuint32_t def, data;\n\n\tdef = RREG32_SOC15(NBIO, 0, regRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL);\n\tdata = 0x35EB;\n\tdata &= ~EP_PCIE_TX_LTR_CNTL__LTR_PRIV_MSG_DIS_IN_PM_NON_D0_MASK;\n\tdata &= ~EP_PCIE_TX_LTR_CNTL__LTR_PRIV_RST_LTR_IN_DL_DOWN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP2);\n\tdata &= ~RCC_BIF_STRAP2__STRAP_LTR_IN_ASPML1_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP2, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2);\n\tif (adev->pdev->ltr_path)\n\t\tdata |= BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;\n\telse\n\t\tdata &= ~BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2, data);\n}\n#endif\n\nstatic void nbio_v4_3_program_aspm(struct amdgpu_device *adev)\n{\n#ifdef CONFIG_PCIEASPM\n\tuint32_t def, data;\n\n\tif (!(adev->ip_versions[PCIE_HWIP][0] == IP_VERSION(7, 4, 0)) &&\n\t      !(adev->ip_versions[PCIE_HWIP][0] == IP_VERSION(7, 6, 0)))\n\t\treturn;\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL);\n\tdata &= ~PCIE_LC_CNTL__LC_L1_INACTIVITY_MASK;\n\tdata &= ~PCIE_LC_CNTL__LC_L0S_INACTIVITY_MASK;\n\tdata |= PCIE_LC_CNTL__LC_PMI_TO_L1_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL7);\n\tdata |= PCIE_LC_CNTL7__LC_NBIF_ASPM_INPUT_EN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL7, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL3);\n\tdata |= PCIE_LC_CNTL3__LC_DSC_DONT_ENTER_L23_AFTER_PME_ACK_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL3, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP3);\n\tdata &= ~RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER_MASK;\n\tdata &= ~RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP3, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP5);\n\tdata &= ~RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP5, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2);\n\tdata &= ~BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_DEVICE_CNTL2, data);\n\n\tWREG32_SOC15(NBIO, 0, regBIF_CFG_DEV0_EPF0_PCIE_LTR_CAP, 0x10011001);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPSWUSP0_PCIE_LC_CNTL2);\n\tdata |= PSWUSP0_PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L1_MASK |\n\t\tPSWUSP0_PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L23_MASK;\n\tdata &= ~PSWUSP0_PCIE_LC_CNTL2__LC_RCV_L0_TO_RCV_L0S_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPSWUSP0_PCIE_LC_CNTL2, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL4);\n\tdata |= PCIE_LC_CNTL4__LC_L1_POWERDOWN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL4, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_RXRECOVER_RXSTANDBY_CNTL);\n\tdata |= PCIE_LC_RXRECOVER_RXSTANDBY_CNTL__LC_RX_L0S_STANDBY_EN_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_RXRECOVER_RXSTANDBY_CNTL, data);\n\n\tnbio_v4_3_program_ltr(adev);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP3);\n\tdata |= 0x5DE0 << RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER__SHIFT;\n\tdata |= 0x0010 << RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER__SHIFT;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP3, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP5);\n\tdata |= 0x0010 << RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER__SHIFT;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_BIF_STRAP5, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL);\n\tdata |= 0x0 << PCIE_LC_CNTL__LC_L0S_INACTIVITY__SHIFT;\n\tdata |= 0x9 << PCIE_LC_CNTL__LC_L1_INACTIVITY__SHIFT;\n\tdata &= ~PCIE_LC_CNTL__LC_PMI_TO_L1_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL, data);\n\n\tdef = data = RREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL3);\n\tdata &= ~PCIE_LC_CNTL3__LC_DSC_DONT_ENTER_L23_AFTER_PME_ACK_MASK;\n\tif (def != data)\n\t\tWREG32_SOC15(NBIO, 0, regPCIE_LC_CNTL3, data);\n#endif\n}\n\nconst struct amdgpu_nbio_funcs nbio_v4_3_funcs = {\n\t.get_hdp_flush_req_offset = nbio_v4_3_get_hdp_flush_req_offset,\n\t.get_hdp_flush_done_offset = nbio_v4_3_get_hdp_flush_done_offset,\n\t.get_pcie_index_offset = nbio_v4_3_get_pcie_index_offset,\n\t.get_pcie_data_offset = nbio_v4_3_get_pcie_data_offset,\n\t.get_rev_id = nbio_v4_3_get_rev_id,\n\t.mc_access_enable = nbio_v4_3_mc_access_enable,\n\t.get_memsize = nbio_v4_3_get_memsize,\n\t.sdma_doorbell_range = nbio_v4_3_sdma_doorbell_range,\n\t.vcn_doorbell_range = nbio_v4_3_vcn_doorbell_range,\n\t.gc_doorbell_init = nbio_v4_3_gc_doorbell_init,\n\t.enable_doorbell_aperture = nbio_v4_3_enable_doorbell_aperture,\n\t.enable_doorbell_selfring_aperture = nbio_v4_3_enable_doorbell_selfring_aperture,\n\t.ih_doorbell_range = nbio_v4_3_ih_doorbell_range,\n\t.update_medium_grain_clock_gating = nbio_v4_3_update_medium_grain_clock_gating,\n\t.update_medium_grain_light_sleep = nbio_v4_3_update_medium_grain_light_sleep,\n\t.get_clockgating_state = nbio_v4_3_get_clockgating_state,\n\t.ih_control = nbio_v4_3_ih_control,\n\t.init_registers = nbio_v4_3_init_registers,\n\t.remap_hdp_registers = nbio_v4_3_remap_hdp_registers,\n\t.get_rom_offset = nbio_v4_3_get_rom_offset,\n\t.program_aspm = nbio_v4_3_program_aspm,\n};\n\n\nstatic void nbio_v4_3_sriov_ih_doorbell_range(struct amdgpu_device *adev,\n\t\t\t\t\tbool use_doorbell, int doorbell_index)\n{\n}\n\nstatic void nbio_v4_3_sriov_sdma_doorbell_range(struct amdgpu_device *adev, int instance,\n\t\t\t\t\t  bool use_doorbell, int doorbell_index,\n\t\t\t\t\t  int doorbell_size)\n{\n}\n\nstatic void nbio_v4_3_sriov_vcn_doorbell_range(struct amdgpu_device *adev, bool use_doorbell,\n\t\t\t\t\t int doorbell_index, int instance)\n{\n}\n\nstatic void nbio_v4_3_sriov_gc_doorbell_init(struct amdgpu_device *adev)\n{\n}\n\nconst struct amdgpu_nbio_funcs nbio_v4_3_sriov_funcs = {\n\t.get_hdp_flush_req_offset = nbio_v4_3_get_hdp_flush_req_offset,\n\t.get_hdp_flush_done_offset = nbio_v4_3_get_hdp_flush_done_offset,\n\t.get_pcie_index_offset = nbio_v4_3_get_pcie_index_offset,\n\t.get_pcie_data_offset = nbio_v4_3_get_pcie_data_offset,\n\t.get_rev_id = nbio_v4_3_get_rev_id,\n\t.mc_access_enable = nbio_v4_3_mc_access_enable,\n\t.get_memsize = nbio_v4_3_get_memsize,\n\t.sdma_doorbell_range = nbio_v4_3_sriov_sdma_doorbell_range,\n\t.vcn_doorbell_range = nbio_v4_3_sriov_vcn_doorbell_range,\n\t.gc_doorbell_init = nbio_v4_3_sriov_gc_doorbell_init,\n\t.enable_doorbell_aperture = nbio_v4_3_enable_doorbell_aperture,\n\t.enable_doorbell_selfring_aperture = nbio_v4_3_enable_doorbell_selfring_aperture,\n\t.ih_doorbell_range = nbio_v4_3_sriov_ih_doorbell_range,\n\t.update_medium_grain_clock_gating = nbio_v4_3_update_medium_grain_clock_gating,\n\t.update_medium_grain_light_sleep = nbio_v4_3_update_medium_grain_light_sleep,\n\t.get_clockgating_state = nbio_v4_3_get_clockgating_state,\n\t.ih_control = nbio_v4_3_ih_control,\n\t.init_registers = nbio_v4_3_init_registers,\n\t.remap_hdp_registers = nbio_v4_3_remap_hdp_registers,\n\t.get_rom_offset = nbio_v4_3_get_rom_offset,\n};\n\nstatic int nbio_v4_3_set_ras_err_event_athub_irq_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t       struct amdgpu_irq_src *src,\n\t\t\t\t\t\t       unsigned type,\n\t\t\t\t\t\t       enum amdgpu_interrupt_state state)\n{\n\t \n\tuint32_t bif_doorbell_int_cntl;\n\n\tbif_doorbell_int_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL);\n\tbif_doorbell_int_cntl = REG_SET_FIELD(bif_doorbell_int_cntl,\n\t\t\t\t\t      BIF_BX0_BIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t      RAS_ATHUB_ERR_EVENT_INTERRUPT_DISABLE,\n\t\t\t\t\t      (state == AMDGPU_IRQ_STATE_ENABLE) ? 0 : 1);\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL, bif_doorbell_int_cntl);\n\n\treturn 0;\n}\n\nstatic int nbio_v4_3_process_err_event_athub_irq(struct amdgpu_device *adev,\n\t\t\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs nbio_v4_3_ras_err_event_athub_irq_funcs = {\n\t.set = nbio_v4_3_set_ras_err_event_athub_irq_state,\n\t.process = nbio_v4_3_process_err_event_athub_irq,\n};\n\nstatic void nbio_v4_3_handle_ras_err_event_athub_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_int_cntl;\n\n\tbif_doorbell_int_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL);\n\tif (REG_GET_FIELD(bif_doorbell_int_cntl,\n\t\t\t  BIF_DOORBELL_INT_CNTL,\n\t\t\t  RAS_ATHUB_ERR_EVENT_INTERRUPT_STATUS)) {\n\t\t \n\t\tbif_doorbell_int_cntl = REG_SET_FIELD(bif_doorbell_int_cntl,\n\t\t\t\t\t\tBIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_ATHUB_ERR_EVENT_INTERRUPT_CLEAR, 1);\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL, bif_doorbell_int_cntl);\n\t\tamdgpu_ras_global_ras_isr(adev);\n\t}\n}\n\nstatic int nbio_v4_3_init_ras_err_event_athub_interrupt(struct amdgpu_device *adev)\n{\n\n\tint r;\n\n\t \n\tadev->nbio.ras_err_event_athub_irq.funcs =\n\t\t&nbio_v4_3_ras_err_event_athub_irq_funcs;\n\tadev->nbio.ras_err_event_athub_irq.num_types = 1;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC21_IH_CLIENTID_BIF,\n\t\t\t      NBIF_7_4__SRCID__ERREVENT_ATHUB_INTERRUPT,\n\t\t\t      &adev->nbio.ras_err_event_athub_irq);\n\n\treturn r;\n}\n\nstruct amdgpu_nbio_ras nbio_v4_3_ras = {\n\t.handle_ras_err_event_athub_intr_no_bifring = nbio_v4_3_handle_ras_err_event_athub_intr_no_bifring,\n\t.init_ras_err_event_athub_interrupt = nbio_v4_3_init_ras_err_event_athub_interrupt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}