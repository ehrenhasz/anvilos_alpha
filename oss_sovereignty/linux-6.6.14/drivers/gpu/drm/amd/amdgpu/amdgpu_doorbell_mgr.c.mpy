{
  "module_name": "amdgpu_doorbell_mgr.c",
  "hash_id": "ae0d5b7beb2dca52816ea456d35a0b15c5283ddda9b810c35d40c24cade260bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_doorbell_mgr.c",
  "human_readable_source": "\n \n\n#include \"amdgpu.h\"\n\n \nu32 amdgpu_mm_rdoorbell(struct amdgpu_device *adev, u32 index)\n{\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn 0;\n\n\tif (index < adev->doorbell.num_kernel_doorbells)\n\t\treturn readl(adev->doorbell.cpu_addr + index);\n\n\tDRM_ERROR(\"reading beyond doorbell aperture: 0x%08x!\\n\", index);\n\treturn 0;\n}\n\n \nvoid amdgpu_mm_wdoorbell(struct amdgpu_device *adev, u32 index, u32 v)\n{\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn;\n\n\tif (index < adev->doorbell.num_kernel_doorbells)\n\t\twritel(v, adev->doorbell.cpu_addr + index);\n\telse\n\t\tDRM_ERROR(\"writing beyond doorbell aperture: 0x%08x!\\n\", index);\n}\n\n \nu64 amdgpu_mm_rdoorbell64(struct amdgpu_device *adev, u32 index)\n{\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn 0;\n\n\tif (index < adev->doorbell.num_kernel_doorbells)\n\t\treturn atomic64_read((atomic64_t *)(adev->doorbell.cpu_addr + index));\n\n\tDRM_ERROR(\"reading beyond doorbell aperture: 0x%08x!\\n\", index);\n\treturn 0;\n}\n\n \nvoid amdgpu_mm_wdoorbell64(struct amdgpu_device *adev, u32 index, u64 v)\n{\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn;\n\n\tif (index < adev->doorbell.num_kernel_doorbells)\n\t\tatomic64_set((atomic64_t *)(adev->doorbell.cpu_addr + index), v);\n\telse\n\t\tDRM_ERROR(\"writing beyond doorbell aperture: 0x%08x!\\n\", index);\n}\n\n \nuint32_t amdgpu_doorbell_index_on_bar(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_bo *db_bo,\n\t\t\t\t      uint32_t doorbell_index,\n\t\t\t\t      uint32_t db_size)\n{\n\tint db_bo_offset;\n\n\tdb_bo_offset = amdgpu_bo_gpu_offset_no_check(db_bo);\n\n\t \n\treturn db_bo_offset / sizeof(u32) + doorbell_index *\n\t       DIV_ROUND_UP(db_size, 4);\n}\n\n \nint amdgpu_doorbell_create_kernel_doorbells(struct amdgpu_device *adev)\n{\n\tint r;\n\tint size;\n\n\t \n\tif (adev->doorbell.num_kernel_doorbells == 0)\n\t\treturn 0;\n\n\t \n\tsize = ALIGN(adev->doorbell.num_kernel_doorbells * sizeof(u32), PAGE_SIZE);\n\n\t \n\tadev->mes.db_start_dw_offset = size / sizeof(u32);\n\tsize += PAGE_SIZE;\n\n\tr = amdgpu_bo_create_kernel(adev,\n\t\t\t\t    size,\n\t\t\t\t    PAGE_SIZE,\n\t\t\t\t    AMDGPU_GEM_DOMAIN_DOORBELL,\n\t\t\t\t    &adev->doorbell.kernel_doorbells,\n\t\t\t\t    NULL,\n\t\t\t\t    (void **)&adev->doorbell.cpu_addr);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to allocate kernel doorbells, err=%d\\n\", r);\n\t\treturn r;\n\t}\n\n\tadev->doorbell.num_kernel_doorbells = size / sizeof(u32);\n\treturn 0;\n}\n\n \n \nint amdgpu_doorbell_init(struct amdgpu_device *adev)\n{\n\n\t \n\tif (adev->asic_type < CHIP_BONAIRE) {\n\t\tadev->doorbell.base = 0;\n\t\tadev->doorbell.size = 0;\n\t\tadev->doorbell.num_kernel_doorbells = 0;\n\t\treturn 0;\n\t}\n\n\tif (pci_resource_flags(adev->pdev, 2) & IORESOURCE_UNSET)\n\t\treturn -EINVAL;\n\n\tamdgpu_asic_init_doorbell_index(adev);\n\n\t \n\tadev->doorbell.base = pci_resource_start(adev->pdev, 2);\n\tadev->doorbell.size = pci_resource_len(adev->pdev, 2);\n\n\tadev->doorbell.num_kernel_doorbells =\n\t\tmin_t(u32, adev->doorbell.size / sizeof(u32),\n\t\t      adev->doorbell_index.max_assignment + 1);\n\tif (adev->doorbell.num_kernel_doorbells == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (adev->asic_type >= CHIP_VEGA10)\n\t\tadev->doorbell.num_kernel_doorbells += 0x400;\n\n\treturn 0;\n}\n\n \nvoid amdgpu_doorbell_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->doorbell.kernel_doorbells,\n\t\t\t      NULL,\n\t\t\t      (void **)&adev->doorbell.cpu_addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}