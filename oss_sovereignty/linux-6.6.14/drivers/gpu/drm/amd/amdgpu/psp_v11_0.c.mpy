{
  "module_name": "psp_v11_0.c",
  "hash_id": "b413ef818cff9c02ac29750e37467fde5df515cfa957978ac7faed8bf301c970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/psp_v11_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <drm/drm_drv.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_ucode.h\"\n#include \"soc15_common.h\"\n#include \"psp_v11_0.h\"\n\n#include \"mp/mp_11_0_offset.h\"\n#include \"mp/mp_11_0_sh_mask.h\"\n#include \"gc/gc_9_0_offset.h\"\n#include \"sdma0/sdma0_4_0_offset.h\"\n#include \"nbio/nbio_7_4_offset.h\"\n\n#include \"oss/osssys_4_0_offset.h\"\n#include \"oss/osssys_4_0_sh_mask.h\"\n\nMODULE_FIRMWARE(\"amdgpu/vega20_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi10_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi10_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi10_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi14_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi14_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi14_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi12_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi12_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi12_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi12_cap.bin\");\nMODULE_FIRMWARE(\"amdgpu/arcturus_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/arcturus_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/arcturus_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/sienna_cichlid_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/sienna_cichlid_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/sienna_cichlid_cap.bin\");\nMODULE_FIRMWARE(\"amdgpu/navy_flounder_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/navy_flounder_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/vangogh_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/vangogh_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/dimgrey_cavefish_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/dimgrey_cavefish_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/beige_goby_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/beige_goby_ta.bin\");\n\n \n#define smnMP1_FIRMWARE_FLAGS\t\t0x3010024\n \n#define mmRLC_GPM_UCODE_ADDR_NV10\t0x5b61\n#define mmRLC_GPM_UCODE_DATA_NV10\t0x5b62\n#define mmSDMA0_UCODE_ADDR_NV10\t\t0x5880\n#define mmSDMA0_UCODE_DATA_NV10\t\t0x5881\n \n#define MEM_TRAIN_SEND_MSG_TIMEOUT_US\t3000000\n\n \n#define USBC_PD_POLLING_LIMIT_S 240\n\n \n#define GFX_CMD_USB_PD_USE_LFB 0x480\n\nstatic int psp_v11_0_init_microcode(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar ucode_prefix[30];\n\tint err = 0;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tamdgpu_ucode_ip_version_decode(adev, MP0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 4):\n\t\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_asd_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tadev->psp.securedisplay_context.context.bin_desc.size_bytes = 0;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 9):\n\t\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_asd_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tadev->psp.securedisplay_context.context.bin_desc.size_bytes = 0;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\t\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tcase IP_VERSION(11, 5, 0):\n\t\terr = psp_init_asd_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_toc_microcode(psp, ucode_prefix);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn err;\n}\n\nstatic int psp_v11_0_wait_for_bootloader(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tint ret;\n\tint retry_loop;\n\n\tfor (retry_loop = 0; retry_loop < 10; retry_loop++) {\n\t\t \n\t\tret = psp_wait_for(psp,\n\t\t\t\t   SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t\t   0x80000000,\n\t\t\t\t   0x80000000,\n\t\t\t\t   false);\n\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic bool psp_v11_0_is_sos_alive(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t sol_reg;\n\n\tsol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);\n\n\treturn sol_reg != 0x0;\n}\n\nstatic int psp_v11_0_bootloader_load_component(struct psp_context  \t*psp,\n\t\t\t\t\t       struct psp_bin_desc \t*bin_desc,\n\t\t\t\t\t       enum psp_bootloader_cmd  bl_cmd)\n{\n\tint ret;\n\tuint32_t psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v11_0_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v11_0_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpsp_copy_fw(psp, bin_desc->start_addr, bin_desc->size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = bl_cmd;\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\tret = psp_v11_0_wait_for_bootloader(psp);\n\n\treturn ret;\n}\n\nstatic int psp_v11_0_bootloader_load_kdb(struct psp_context *psp)\n{\n\treturn psp_v11_0_bootloader_load_component(psp, &psp->kdb, PSP_BL__LOAD_KEY_DATABASE);\n}\n\nstatic int psp_v11_0_bootloader_load_spl(struct psp_context *psp)\n{\n\treturn psp_v11_0_bootloader_load_component(psp, &psp->spl, PSP_BL__LOAD_TOS_SPL_TABLE);\n}\n\nstatic int psp_v11_0_bootloader_load_sysdrv(struct psp_context *psp)\n{\n\treturn psp_v11_0_bootloader_load_component(psp, &psp->sys, PSP_BL__LOAD_SYSDRV);\n}\n\nstatic int psp_v11_0_bootloader_load_sos(struct psp_context *psp)\n{\n\tint ret;\n\tunsigned int psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v11_0_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v11_0_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpsp_copy_fw(psp, psp->sos.start_addr, psp->sos.size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = PSP_BL__LOAD_SOSDRV;\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\t \n\tmdelay(20);\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_81),\n\t\t\t   RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81),\n\t\t\t   0, true);\n\n\treturn ret;\n}\n\nstatic int psp_v11_0_ring_stop(struct psp_context *psp,\n\t\t\t      enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101,\n\t\t\t\t     GFX_CTRL_CMD_ID_DESTROY_GPCOM_RING);\n\telse\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64,\n\t\t\t\t     GFX_CTRL_CMD_ID_DESTROY_RINGS);\n\n\t \n\tmdelay(20);\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\telse\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\n\treturn ret;\n}\n\nstatic int psp_v11_0_ring_create(struct psp_context *psp,\n\t\t\t\tenum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tunsigned int psp_ring_reg = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tring->ring_wptr = 0;\n\t\tret = psp_v11_0_ring_stop(psp, ring_type);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"psp_v11_0_ring_stop_sriov failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_102, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_103, psp_ring_reg);\n\n\t\t \n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101,\n\t\t\t\t\t     GFX_CTRL_CMD_ID_INIT_GPCOM_RING);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\n\t} else {\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to wait for sOS ready for ring creation\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_69, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_70, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring->ring_size;\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_71, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring_type;\n\t\tpsp_ring_reg = psp_ring_reg << 16;\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64, psp_ring_reg);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\t}\n\n\treturn ret;\n}\n\n\nstatic int psp_v11_0_ring_destroy(struct psp_context *psp,\n\t\t\t\t enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tret = psp_v11_0_ring_stop(psp, ring_type);\n\tif (ret)\n\t\tDRM_ERROR(\"Fail to stop psp ring\\n\");\n\n\tamdgpu_bo_free_kernel(&adev->firmware.rbuf,\n\t\t\t      &ring->ring_mem_mc_addr,\n\t\t\t      (void **)&ring->ring_mem);\n\n\treturn ret;\n}\n\nstatic int psp_v11_0_mode1_reset(struct psp_context *psp)\n{\n\tint ret;\n\tuint32_t offset;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\toffset = SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64);\n\n\tret = psp_wait_for(psp, offset, 0x80000000, 0x8000FFFF, false);\n\n\tif (ret) {\n\t\tDRM_INFO(\"psp is not working correctly before mode1 reset!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tWREG32(offset, GFX_CTRL_CMD_ID_MODE1_RST);\n\n\tmsleep(500);\n\n\toffset = SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_33);\n\n\tret = psp_wait_for(psp, offset, 0x80000000, 0x80000000, false);\n\n\tif (ret) {\n\t\tDRM_INFO(\"psp mode 1 reset failed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_INFO(\"psp mode1 reset succeed \\n\");\n\n\treturn 0;\n}\n\nstatic int psp_v11_0_memory_training_send_msg(struct psp_context *psp, int msg)\n{\n\tint ret;\n\tint i;\n\tuint32_t data_32;\n\tint max_wait;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tdata_32 = (psp->mem_train_ctx.c2p_train_data_offset >> 20);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36, data_32);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35, msg);\n\n\tmax_wait = MEM_TRAIN_SEND_MSG_TIMEOUT_US / adev->usec_timeout;\n\tfor (i = 0; i < max_wait; i++) {\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\tif (i < max_wait)\n\t\tret = 0;\n\telse\n\t\tret = -ETIME;\n\n\tDRM_DEBUG(\"training %s %s, cost %d @ %d ms\\n\",\n\t\t  (msg == PSP_BL__DRAM_SHORT_TRAIN) ? \"short\" : \"long\",\n\t\t  (ret == 0) ? \"succeed\" : \"failed\",\n\t\t  i, adev->usec_timeout/1000);\n\treturn ret;\n}\n\n \nstatic int psp_v11_0_memory_training(struct psp_context *psp, uint32_t ops)\n{\n\tstruct psp_memory_training_context *ctx = &psp->mem_train_ctx;\n\tuint32_t *pcache = (uint32_t *)ctx->sys_cache;\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t p2c_header[4];\n\tuint32_t sz;\n\tvoid *buf;\n\tint ret, idx;\n\n\tif (ctx->init == PSP_MEM_TRAIN_NOT_SUPPORT) {\n\t\tDRM_DEBUG(\"Memory training is not supported.\\n\");\n\t\treturn 0;\n\t} else if (ctx->init != PSP_MEM_TRAIN_INIT_SUCCESS) {\n\t\tDRM_ERROR(\"Memory training initialization failure.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (psp_v11_0_is_sos_alive(psp)) {\n\t\tDRM_DEBUG(\"SOS is alive, skip memory training.\\n\");\n\t\treturn 0;\n\t}\n\n\tamdgpu_device_vram_access(adev, ctx->p2c_train_data_offset, p2c_header, sizeof(p2c_header), false);\n\tDRM_DEBUG(\"sys_cache[%08x,%08x,%08x,%08x] p2c_header[%08x,%08x,%08x,%08x]\\n\",\n\t\t  pcache[0], pcache[1], pcache[2], pcache[3],\n\t\t  p2c_header[0], p2c_header[1], p2c_header[2], p2c_header[3]);\n\n\tif (ops & PSP_MEM_TRAIN_SEND_SHORT_MSG) {\n\t\tDRM_DEBUG(\"Short training depends on restore.\\n\");\n\t\tops |= PSP_MEM_TRAIN_RESTORE;\n\t}\n\n\tif ((ops & PSP_MEM_TRAIN_RESTORE) &&\n\t    pcache[0] != MEM_TRAIN_SYSTEM_SIGNATURE) {\n\t\tDRM_DEBUG(\"sys_cache[0] is invalid, restore depends on save.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tif (p2c_header[0] == MEM_TRAIN_SYSTEM_SIGNATURE &&\n\t    !(pcache[0] == MEM_TRAIN_SYSTEM_SIGNATURE &&\n\t      pcache[3] == p2c_header[3])) {\n\t\tDRM_DEBUG(\"sys_cache is invalid or out-of-date, need save training data to sys_cache.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tif ((ops & PSP_MEM_TRAIN_SAVE) &&\n\t    p2c_header[0] != MEM_TRAIN_SYSTEM_SIGNATURE) {\n\t\tDRM_DEBUG(\"p2c_header[0] is invalid, save depends on long training.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SEND_LONG_MSG;\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SEND_LONG_MSG) {\n\t\tops &= ~PSP_MEM_TRAIN_SEND_SHORT_MSG;\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tDRM_DEBUG(\"Memory training ops:%x.\\n\", ops);\n\n\tif (ops & PSP_MEM_TRAIN_SEND_LONG_MSG) {\n\t\t \n\t\tsz = GDDR6_MEM_TRAINING_ENCROACHED_SIZE;\n\n\t\tif (adev->gmc.visible_vram_size < sz || !adev->mman.aper_base_kaddr) {\n\t\t\tDRM_ERROR(\"visible_vram_size %llx or aper_base_kaddr %p is not initialized.\\n\",\n\t\t\t\t  adev->gmc.visible_vram_size,\n\t\t\t\t  adev->mman.aper_base_kaddr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf = vmalloc(sz);\n\t\tif (!buf) {\n\t\t\tDRM_ERROR(\"failed to allocate system memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (drm_dev_enter(adev_to_drm(adev), &idx)) {\n\t\t\tmemcpy_fromio(buf, adev->mman.aper_base_kaddr, sz);\n\t\t\tret = psp_v11_0_memory_training_send_msg(psp, PSP_BL__DRAM_LONG_TRAIN);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"Send long training msg failed.\\n\");\n\t\t\t\tvfree(buf);\n\t\t\t\tdrm_dev_exit(idx);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tmemcpy_toio(adev->mman.aper_base_kaddr, buf, sz);\n\t\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\t\t\tvfree(buf);\n\t\t\tdrm_dev_exit(idx);\n\t\t} else {\n\t\t\tvfree(buf);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SAVE) {\n\t\tamdgpu_device_vram_access(psp->adev, ctx->p2c_train_data_offset, ctx->sys_cache, ctx->train_data_size, false);\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_RESTORE) {\n\t\tamdgpu_device_vram_access(psp->adev, ctx->c2p_train_data_offset, ctx->sys_cache, ctx->train_data_size, true);\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SEND_SHORT_MSG) {\n\t\tret = psp_v11_0_memory_training_send_msg(psp, (amdgpu_force_long_training > 0) ?\n\t\t\t\t\t\t\t PSP_BL__DRAM_LONG_TRAIN : PSP_BL__DRAM_SHORT_TRAIN);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"send training msg failed.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tctx->training_cnt++;\n\treturn 0;\n}\n\nstatic uint32_t psp_v11_0_ring_get_wptr(struct psp_context *psp)\n{\n\tuint32_t data;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tdata = psp->km_ring.ring_wptr;\n\telse\n\t\tdata = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_67);\n\n\treturn data;\n}\n\nstatic void psp_v11_0_ring_set_wptr(struct psp_context *psp, uint32_t value)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_102, value);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101, GFX_CTRL_CMD_ID_CONSUME_CMD);\n\t\tpsp->km_ring.ring_wptr = value;\n\t} else\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_67, value);\n}\n\nstatic int psp_v11_0_load_usbc_pd_fw(struct psp_context *psp, uint64_t fw_pri_mc_addr)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t reg_status;\n\tint ret, i = 0;\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36, (fw_pri_mc_addr >> 20));\n\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t     0x80000000, 0x80000000, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35, (GFX_CMD_USB_PD_USE_LFB << 16));\n\n\t \n\tdo {\n\t\tmsleep(1000);\n\t\treg_status = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35);\n\n\t\tif (reg_status & 0x80000000)\n\t\t\tgoto done;\n\n\t} while (++i < USBC_PD_POLLING_LIMIT_S);\n\n\treturn -ETIME;\ndone:\n\n\tif ((reg_status & 0xFFFF) != 0) {\n\t\tDRM_ERROR(\"Address load failed - MP0_SMN_C2PMSG_35.Bits [15:0] = 0x%04x\\n\",\n\t\t\t\treg_status & 0xFFFF);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_v11_0_read_usbc_pd_fw(struct psp_context *psp, uint32_t *fw_ver)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35, C2PMSG_CMD_GFX_USB_PD_FW_VER);\n\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t\t     0x80000000, 0x80000000, false);\n\tif (!ret)\n\t\t*fw_ver = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36);\n\n\treturn ret;\n}\n\nstatic const struct psp_funcs psp_v11_0_funcs = {\n\t.init_microcode = psp_v11_0_init_microcode,\n\t.bootloader_load_kdb = psp_v11_0_bootloader_load_kdb,\n\t.bootloader_load_spl = psp_v11_0_bootloader_load_spl,\n\t.bootloader_load_sysdrv = psp_v11_0_bootloader_load_sysdrv,\n\t.bootloader_load_sos = psp_v11_0_bootloader_load_sos,\n\t.ring_create = psp_v11_0_ring_create,\n\t.ring_stop = psp_v11_0_ring_stop,\n\t.ring_destroy = psp_v11_0_ring_destroy,\n\t.mode1_reset = psp_v11_0_mode1_reset,\n\t.mem_training = psp_v11_0_memory_training,\n\t.ring_get_wptr = psp_v11_0_ring_get_wptr,\n\t.ring_set_wptr = psp_v11_0_ring_set_wptr,\n\t.load_usbc_pd_fw = psp_v11_0_load_usbc_pd_fw,\n\t.read_usbc_pd_fw = psp_v11_0_read_usbc_pd_fw\n};\n\nvoid psp_v11_0_set_psp_funcs(struct psp_context *psp)\n{\n\tpsp->funcs = &psp_v11_0_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}