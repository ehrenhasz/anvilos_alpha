{
  "module_name": "smu_v11_0_i2c.c",
  "hash_id": "abe4e1bfbce1ce671c454e74cf50284e270afb35233c07ddb027a611fe513594",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/smu_v11_0_i2c.c",
  "human_readable_source": " \n\n#include \"smuio/smuio_11_0_0_offset.h\"\n#include \"smuio/smuio_11_0_0_sh_mask.h\"\n\n#include \"smu_v11_0_i2c.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_dpm.h\"\n#include \"soc15_common.h\"\n#include <drm/drm_fixed.h>\n#include <drm/drm_drv.h>\n#include \"amdgpu_amdkfd.h\"\n#include <linux/i2c.h>\n#include <linux/pci.h>\n\n \n#define I2C_OK                0\n#define I2C_NAK_7B_ADDR_NOACK 1\n#define I2C_NAK_TXDATA_NOACK  2\n#define I2C_TIMEOUT           4\n#define I2C_SW_TIMEOUT        8\n#define I2C_ABORT             0x10\n\n#define I2C_X_RESTART         BIT(31)\n\nstatic void smu_v11_0_i2c_set_clock_gating(struct i2c_adapter *control, bool en)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t reg = RREG32_SOC15(SMUIO, 0, mmSMUIO_PWRMGT);\n\n\treg = REG_SET_FIELD(reg, SMUIO_PWRMGT, i2c_clk_gate_en, en ? 1 : 0);\n\tWREG32_SOC15(SMUIO, 0, mmSMUIO_PWRMGT, reg);\n}\n\n \n#define I2C_SPEED_MODE_FAST     2\n#define T_I2C_POLL_US           25\n#define I2C_MAX_T_POLL_COUNT    1000\n\nstatic int smu_v11_0_i2c_enable(struct i2c_adapter *control, bool enable)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE, enable ? 1 : 0);\n\n\tif (!enable) {\n\t\tint ii;\n\n\t\tfor (ii = I2C_MAX_T_POLL_COUNT; ii > 0; ii--) {\n\t\t\tu32 en_stat = RREG32_SOC15(SMUIO,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   mmCKSVII2C_IC_ENABLE_STATUS);\n\t\t\tif (REG_GET_FIELD(en_stat, CKSVII2C_IC_ENABLE_STATUS, IC_EN))\n\t\t\t\tudelay(T_I2C_POLL_US);\n\t\t\telse\n\t\t\t\treturn I2C_OK;\n\t\t}\n\n\t\treturn I2C_ABORT;\n\t}\n\n\treturn I2C_OK;\n}\n\nstatic void smu_v11_0_i2c_clear_status(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\t \n\t{\n\t\tRREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_CLR_INTR);\n\n\t}  \n}\n\nstatic void smu_v11_0_i2c_configure(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t reg = 0;\n\n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_SLAVE_DISABLE, 1);\n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_RESTART_EN, 1);\n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_10BITADDR_MASTER, 0);\n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_10BITADDR_SLAVE, 0);\n\t \n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_MAX_SPEED_MODE,\n\t\t\t    I2C_SPEED_MODE_FAST);\n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_CON, IC_MASTER_MODE, 1);\n\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_CON, reg);\n}\n\nstatic void smu_v11_0_i2c_set_clock(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\t \n\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_FS_SPKLEN, 2);\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_SS_SCL_HCNT, 120);\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_SS_SCL_LCNT, 130);\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_SDA_HOLD, 20);\n}\n\nstatic void smu_v11_0_i2c_set_address(struct i2c_adapter *control, u16 address)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\t \n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_TAR, address & 0x3FF);\n}\n\nstatic uint32_t smu_v11_0_i2c_poll_tx_status(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t ret = I2C_OK;\n\tuint32_t reg, reg_c_tx_abrt_source;\n\n\t \n\tunsigned long  timeout_counter = jiffies + msecs_to_jiffies(20);\n\n\tdo {\n\t\tif (time_after(jiffies, timeout_counter)) {\n\t\t\tret |= I2C_SW_TIMEOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\treg = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_STATUS);\n\n\t} while (REG_GET_FIELD(reg, CKSVII2C_IC_STATUS, TFE) == 0);\n\n\tif (ret != I2C_OK)\n\t\treturn ret;\n\n\t \n\treg = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_INTR_STAT);\n\n\tif (REG_GET_FIELD(reg, CKSVII2C_IC_INTR_STAT, R_TX_ABRT) == 1) {\n\t\treg_c_tx_abrt_source = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_TX_ABRT_SOURCE);\n\t\tDRM_INFO(\"TX was terminated, IC_TX_ABRT_SOURCE val is:%x\", reg_c_tx_abrt_source);\n\n\t\t \n\t\tif (REG_GET_FIELD(reg_c_tx_abrt_source,\n\t\t\t\t  CKSVII2C_IC_TX_ABRT_SOURCE,\n\t\t\t\t  ABRT_TXDATA_NOACK) == 1) {\n\n\t\t\tret |= I2C_NAK_TXDATA_NOACK;\n\n\t\t} else if (REG_GET_FIELD(reg_c_tx_abrt_source,\n\t\t\t\t\t CKSVII2C_IC_TX_ABRT_SOURCE,\n\t\t\t\t\t ABRT_7B_ADDR_NOACK) == 1) {\n\n\t\t\tret |= I2C_NAK_7B_ADDR_NOACK;\n\t\t} else {\n\t\t\tret |= I2C_ABORT;\n\t\t}\n\n\t\tsmu_v11_0_i2c_clear_status(control);\n\t}\n\n\treturn ret;\n}\n\nstatic uint32_t smu_v11_0_i2c_poll_rx_status(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t ret = I2C_OK;\n\tuint32_t reg_ic_status, reg_c_tx_abrt_source;\n\n\treg_c_tx_abrt_source = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_TX_ABRT_SOURCE);\n\n\t \n\tif (REG_GET_FIELD(reg_c_tx_abrt_source,\n\t\t\t  CKSVII2C_IC_TX_ABRT_SOURCE,\n\t\t\t  ABRT_7B_ADDR_NOACK) == 1) {\n\t\tret |= I2C_NAK_7B_ADDR_NOACK;\n\n\t\tsmu_v11_0_i2c_clear_status(control);\n\t} else {   \n\t\t \n\t\tunsigned long  timeout_counter = jiffies + msecs_to_jiffies(20);\n\n\t\tdo {\n\t\t\tif (time_after(jiffies, timeout_counter)) {\n\t\t\t\tret |= I2C_SW_TIMEOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treg_ic_status = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_STATUS);\n\n\t\t} while (REG_GET_FIELD(reg_ic_status, CKSVII2C_IC_STATUS, RFNE) == 0);\n\t}\n\n\treturn ret;\n}\n\n \nstatic uint32_t smu_v11_0_i2c_transmit(struct i2c_adapter *control,\n\t\t\t\t       u16 address, u8 *data,\n\t\t\t\t       u32 numbytes, u32 i2c_flag)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tu32 bytes_sent, reg, ret = I2C_OK;\n\tunsigned long  timeout_counter;\n\n\tbytes_sent = 0;\n\n\tDRM_DEBUG_DRIVER(\"I2C_Transmit(), address = %x, bytes = %d , data: \",\n\t\t\t address, numbytes);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER)) {\n\t\tprint_hex_dump(KERN_INFO, \"data: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 1, data, numbytes, false);\n\t}\n\n\t \n\tsmu_v11_0_i2c_set_address(control, address);\n\t \n\tsmu_v11_0_i2c_enable(control, true);\n\n\t \n\tsmu_v11_0_i2c_clear_status(control);\n\n\ttimeout_counter = jiffies + msecs_to_jiffies(20);\n\n\twhile (numbytes > 0) {\n\t\treg = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_STATUS);\n\t\tif (!REG_GET_FIELD(reg, CKSVII2C_IC_STATUS, TFNF)) {\n\t\t\t \n\t\t\tif (time_after(jiffies, timeout_counter)) {\n\t\t\t\tret |= I2C_SW_TIMEOUT;\n\t\t\t\tgoto Err;\n\t\t\t}\n\t\t} else {\n\t\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD, DAT,\n\t\t\t\t\t    data[bytes_sent]);\n\n\t\t\t \n\t\t\tif (numbytes == 1 && i2c_flag & I2C_M_STOP)\n\t\t\t\treg = REG_SET_FIELD(reg,\n\t\t\t\t\t\t    CKSVII2C_IC_DATA_CMD,\n\t\t\t\t\t\t    STOP, 1);\n\n\t\t\tif (bytes_sent == 0 && i2c_flag & I2C_X_RESTART)\n\t\t\t\treg = REG_SET_FIELD(reg,\n\t\t\t\t\t\t    CKSVII2C_IC_DATA_CMD,\n\t\t\t\t\t\t    RESTART, 1);\n\n\t\t\t \n\t\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD, CMD, 0);\n\t\t\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_DATA_CMD, reg);\n\n\t\t\t \n\t\t\tbytes_sent++;\n\t\t\tnumbytes--;\n\t\t}\n\t}\n\n\tret = smu_v11_0_i2c_poll_tx_status(control);\nErr:\n\t \n\tif (ret != I2C_OK) {\n\t\tif (ret & I2C_SW_TIMEOUT)\n\t\t\tDRM_ERROR(\"TIMEOUT ERROR !!!\");\n\n\t\tif (ret & I2C_NAK_7B_ADDR_NOACK)\n\t\t\tDRM_ERROR(\"Received I2C_NAK_7B_ADDR_NOACK !!!\");\n\n\n\t\tif (ret & I2C_NAK_TXDATA_NOACK)\n\t\t\tDRM_ERROR(\"Received I2C_NAK_TXDATA_NOACK !!!\");\n\t}\n\n\treturn ret;\n}\n\n\n \nstatic uint32_t smu_v11_0_i2c_receive(struct i2c_adapter *control,\n\t\t\t\t      u16 address, u8 *data,\n\t\t\t\t      u32 numbytes, u32 i2c_flag)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t bytes_received, ret = I2C_OK;\n\n\tbytes_received = 0;\n\n\t \n\tsmu_v11_0_i2c_set_address(control, address);\n\n\t \n\tsmu_v11_0_i2c_enable(control, true);\n\n\twhile (numbytes > 0) {\n\t\tuint32_t reg = 0;\n\n\t\tsmu_v11_0_i2c_clear_status(control);\n\n\t\t \n\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD, DAT, 0);\n\t\t \n\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD, CMD, 1);\n\n\t\t \n\t\tif (numbytes == 1 && i2c_flag & I2C_M_STOP)\n\t\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD,\n\t\t\t\t\t    STOP, 1);\n\n\t\tif (bytes_received == 0 && i2c_flag & I2C_X_RESTART)\n\t\t\treg = REG_SET_FIELD(reg, CKSVII2C_IC_DATA_CMD,\n\t\t\t\t\t    RESTART, 1);\n\n\t\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_DATA_CMD, reg);\n\n\t\tret = smu_v11_0_i2c_poll_rx_status(control);\n\n\t\t \n\t\tif (ret != I2C_OK) {\n\t\t\tif (ret & I2C_SW_TIMEOUT)\n\t\t\t\tDRM_ERROR(\"TIMEOUT ERROR !!!\");\n\n\t\t\tif (ret & I2C_NAK_7B_ADDR_NOACK)\n\t\t\t\tDRM_ERROR(\"Received I2C_NAK_7B_ADDR_NOACK !!!\");\n\n\t\t\tif (ret & I2C_NAK_TXDATA_NOACK)\n\t\t\t\tDRM_ERROR(\"Received I2C_NAK_TXDATA_NOACK !!!\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\treg = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_DATA_CMD);\n\t\tdata[bytes_received] = REG_GET_FIELD(reg, CKSVII2C_IC_DATA_CMD, DAT);\n\n\t\t \n\t\tbytes_received++;\n\t\tnumbytes--;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"I2C_Receive(), address = %x, bytes = %d, data :\",\n\t\t  (uint16_t)address, bytes_received);\n\n\tif (drm_debug_enabled(DRM_UT_DRIVER)) {\n\t\tprint_hex_dump(KERN_INFO, \"data: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 1, data, bytes_received, false);\n\t}\n\n\treturn ret;\n}\n\nstatic void smu_v11_0_i2c_abort(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tuint32_t reg = 0;\n\n\t \n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_ENABLE, ENABLE, 1);\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE, reg);\n\n\t \n\treg = REG_SET_FIELD(reg, CKSVII2C_IC_ENABLE, ABORT, 1);\n\tWREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE, reg);\n\n\tDRM_DEBUG_DRIVER(\"I2C_Abort() Done.\");\n}\n\nstatic bool smu_v11_0_i2c_activity_done(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\tconst uint32_t IDLE_TIMEOUT = 1024;\n\tuint32_t timeout_count = 0;\n\tuint32_t reg_ic_enable, reg_ic_enable_status, reg_ic_clr_activity;\n\n\treg_ic_enable_status = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE_STATUS);\n\treg_ic_enable = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE);\n\n\tif ((REG_GET_FIELD(reg_ic_enable, CKSVII2C_IC_ENABLE, ENABLE) == 0) &&\n\t    (REG_GET_FIELD(reg_ic_enable_status, CKSVII2C_IC_ENABLE_STATUS, IC_EN) == 1)) {\n\t\t \n\t\tsmu_v11_0_i2c_abort(control);\n\t} else if (REG_GET_FIELD(reg_ic_enable, CKSVII2C_IC_ENABLE, ENABLE) == 0) {\n\t\t \n\t\treturn true;\n\t}\n\n\t \n\tdo {\n\t\treg_ic_clr_activity = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_CLR_ACTIVITY);\n\n\t\tif (REG_GET_FIELD(reg_ic_clr_activity,\n\t\t    CKSVII2C_IC_CLR_ACTIVITY, CLR_ACTIVITY) == 0)\n\t\t\treturn true;\n\n\t\t++timeout_count;\n\n\t} while (timeout_count < IDLE_TIMEOUT);\n\n\treturn false;\n}\n\nstatic void smu_v11_0_i2c_init(struct i2c_adapter *control)\n{\n\tint res;\n\n\t \n\tsmu_v11_0_i2c_set_clock_gating(control, false);\n\n\tif (!smu_v11_0_i2c_activity_done(control))\n\t\tDRM_WARN(\"I2C busy !\");\n\n\t \n\tres = smu_v11_0_i2c_enable(control, false);\n\tif (res != I2C_OK)\n\t\tsmu_v11_0_i2c_abort(control);\n\n\t \n\tsmu_v11_0_i2c_configure(control);\n\n\t \n\tsmu_v11_0_i2c_set_clock(control);\n\n}\n\nstatic void smu_v11_0_i2c_fini(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tu32 status, enable, en_stat;\n\tint res;\n\n\tres = smu_v11_0_i2c_enable(control, false);\n\tif (res != I2C_OK) {\n\t\tstatus  = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_STATUS);\n\t\tenable  = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE);\n\t\ten_stat = RREG32_SOC15(SMUIO, 0, mmCKSVII2C_IC_ENABLE_STATUS);\n\n\t\t \n\t\tDRM_DEBUG_DRIVER(\"Aborting from fini: status:0x%08x \"\n\t\t\t\t \"enable:0x%08x enable_stat:0x%08x\",\n\t\t\t\t status, enable, en_stat);\n\t\tsmu_v11_0_i2c_abort(control);\n\t}\n\n\t \n\n\t \n\t \n\n}\n\nstatic bool smu_v11_0_i2c_bus_lock(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\t \n\tif (!amdgpu_dpm_smu_i2c_bus_access(adev, true))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool smu_v11_0_i2c_bus_unlock(struct i2c_adapter *control)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(control);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\t \n\tif (!amdgpu_dpm_smu_i2c_bus_access(adev, false))\n\t\treturn true;\n\n\treturn false;\n}\n\n \n\nstatic uint32_t smu_v11_0_i2c_read_data(struct i2c_adapter *control,\n\t\t\t\t\tstruct i2c_msg *msg, uint32_t i2c_flag)\n{\n\tuint32_t  ret;\n\n\tret = smu_v11_0_i2c_receive(control, msg->addr, msg->buf, msg->len, i2c_flag);\n\n\tif (ret != I2C_OK)\n\t\tDRM_ERROR(\"ReadData() - I2C error occurred :%x\", ret);\n\n\treturn ret;\n}\n\nstatic uint32_t smu_v11_0_i2c_write_data(struct i2c_adapter *control,\n\t\t\t\t\tstruct i2c_msg *msg, uint32_t i2c_flag)\n{\n\tuint32_t  ret;\n\n\tret = smu_v11_0_i2c_transmit(control, msg->addr, msg->buf, msg->len, i2c_flag);\n\n\tif (ret != I2C_OK)\n\t\tDRM_ERROR(\"WriteI2CData() - I2C error occurred :%x\", ret);\n\n\treturn ret;\n\n}\n\nstatic void lock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\tmutex_lock(&smu_i2c->mutex);\n\tif (!smu_v11_0_i2c_bus_lock(i2c))\n\t\tDRM_ERROR(\"Failed to lock the bus from SMU\");\n\telse\n\t\tadev->pm.bus_locked = true;\n}\n\nstatic int trylock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\tWARN_ONCE(1, \"This operation not supposed to run in atomic context!\");\n\treturn false;\n}\n\nstatic void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\n\tif (!smu_v11_0_i2c_bus_unlock(i2c))\n\t\tDRM_ERROR(\"Failed to unlock the bus from SMU\");\n\telse\n\t\tadev->pm.bus_locked = false;\n\tmutex_unlock(&smu_i2c->mutex);\n}\n\nstatic const struct i2c_lock_operations smu_v11_0_i2c_i2c_lock_ops = {\n\t.lock_bus = lock_bus,\n\t.trylock_bus = trylock_bus,\n\t.unlock_bus = unlock_bus,\n};\n\nstatic int smu_v11_0_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t      struct i2c_msg *msg, int num)\n{\n\tint i, ret;\n\tu16 addr, dir;\n\n\tsmu_v11_0_i2c_init(i2c_adap);\n\n\t \n\tif (num > 0) {\n\t\taddr = msg[0].addr;\n\t\tdir  = msg[0].flags & I2C_M_RD;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tu32 i2c_flag = 0;\n\n\t\tif (msg[i].addr != addr || (msg[i].flags ^ dir) & I2C_M_RD) {\n\t\t\taddr = msg[i].addr;\n\t\t\tdir  = msg[i].flags & I2C_M_RD;\n\t\t\ti2c_flag |= I2C_X_RESTART;\n\t\t}\n\n\t\tif (i == num - 1) {\n\t\t\t \n\t\t\ti2c_flag |= I2C_M_STOP;\n\t\t}\n\n\t\tif (msg[i].flags & I2C_M_RD)\n\t\t\tret = smu_v11_0_i2c_read_data(i2c_adap,\n\t\t\t\t\t\t      msg + i,\n\t\t\t\t\t\t      i2c_flag);\n\t\telse\n\t\t\tret = smu_v11_0_i2c_write_data(i2c_adap,\n\t\t\t\t\t\t       msg + i,\n\t\t\t\t\t\t       i2c_flag);\n\n\t\tif (ret != I2C_OK) {\n\t\t\tnum = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsmu_v11_0_i2c_fini(i2c_adap);\n\treturn num;\n}\n\nstatic u32 smu_v11_0_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm smu_v11_0_i2c_algo = {\n\t.master_xfer = smu_v11_0_i2c_xfer,\n\t.functionality = smu_v11_0_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks smu_v11_0_i2c_control_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nint smu_v11_0_i2c_control_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[0];\n\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\tint res;\n\n\tsmu_i2c->adev = adev;\n\tsmu_i2c->port = 0;\n\tmutex_init(&smu_i2c->mutex);\n\tcontrol->owner = THIS_MODULE;\n\tcontrol->class = I2C_CLASS_HWMON;\n\tcontrol->dev.parent = &adev->pdev->dev;\n\tcontrol->algo = &smu_v11_0_i2c_algo;\n\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU 0\");\n\tcontrol->lock_ops = &smu_v11_0_i2c_i2c_lock_ops;\n\tcontrol->quirks = &smu_v11_0_i2c_control_quirks;\n\ti2c_set_adapdata(control, smu_i2c);\n\n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\n\tres = i2c_add_adapter(control);\n\tif (res)\n\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\n\treturn res;\n}\n\nvoid smu_v11_0_i2c_control_fini(struct amdgpu_device *adev)\n{\n\tstruct i2c_adapter *control = adev->pm.ras_eeprom_i2c_bus;\n\n\ti2c_del_adapter(control);\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\n \n#if 0\n#define I2C_TARGET_ADDR 0xA0\n\nbool smu_v11_0_i2c_test_bus(struct i2c_adapter *control)\n{\n\n\tuint32_t ret = I2C_OK;\n\tuint8_t data[6] = {0xf, 0, 0xde, 0xad, 0xbe, 0xef};\n\n\n\tDRM_INFO(\"Begin\");\n\n\tif (!smu_v11_0_i2c_bus_lock(control)) {\n\t\tDRM_ERROR(\"Failed to lock the bus!.\");\n\t\treturn false;\n\t}\n\n\tsmu_v11_0_i2c_init(control);\n\n\t \n\tret = smu_v11_0_i2c_write_data(control, I2C_TARGET_ADDR, data, 6);\n\n\tret = smu_v11_0_i2c_read_data(control, I2C_TARGET_ADDR, data, 6);\n\n\tsmu_v11_0_i2c_fini(control);\n\n\tsmu_v11_0_i2c_bus_unlock(control);\n\n\n\tDRM_INFO(\"End\");\n\treturn true;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}