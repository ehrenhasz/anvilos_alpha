{
  "module_name": "amdgpu_fru_eeprom.c",
  "hash_id": "ad421ab1d4d60c729a2adc31d3b0fa6f592c30fd361e61c569c1ce049fc7e8e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_fru_eeprom.c",
  "human_readable_source": " \n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_i2c.h\"\n#include \"smu_v11_0_i2c.h\"\n#include \"atom.h\"\n#include \"amdgpu_fru_eeprom.h\"\n#include \"amdgpu_eeprom.h\"\n\n#define FRU_EEPROM_MADDR_6      0x60000\n#define FRU_EEPROM_MADDR_8      0x80000\n\nstatic bool is_fru_eeprom_supported(struct amdgpu_device *adev, u32 *fru_addr)\n{\n\t \n\tstruct atom_context *atom_ctx = adev->mode_info.atom_context;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn false;\n\n\t \n\tif (fru_addr)\n\t\t*fru_addr = FRU_EEPROM_MADDR_8;\n\n\t \n\tswitch (adev->asic_type) {\n\tcase CHIP_VEGA20:\n\t\t \n\t\tif (strnstr(atom_ctx->vbios_pn, \"D161\",\n\t\t\t    sizeof(atom_ctx->vbios_pn)) ||\n\t\t    strnstr(atom_ctx->vbios_pn, \"D163\",\n\t\t\t    sizeof(atom_ctx->vbios_pn))) {\n\t\t\tif (fru_addr)\n\t\t\t\t*fru_addr = FRU_EEPROM_MADDR_6;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\tcase CHIP_ALDEBARAN:\n\t\t \n\t\tif (!strnstr(atom_ctx->vbios_pn, \"D673\",\n\t\t\t     sizeof(atom_ctx->vbios_pn)))\n\t\t\tif (fru_addr)\n\t\t\t\t*fru_addr = FRU_EEPROM_MADDR_6;\n\t\treturn true;\n\tcase CHIP_SIENNA_CICHLID:\n\t\tif (strnstr(atom_ctx->vbios_pn, \"D603\",\n\t\t\t    sizeof(atom_ctx->vbios_pn))) {\n\t\t\tif (strnstr(atom_ctx->vbios_pn, \"D603GLXE\",\n\t\t\t\t    sizeof(atom_ctx->vbios_pn))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (fru_addr)\n\t\t\t\t*fru_addr = FRU_EEPROM_MADDR_6;\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint amdgpu_fru_get_product_info(struct amdgpu_device *adev)\n{\n\tunsigned char buf[8], *pia;\n\tu32 addr, fru_addr;\n\tint size, len;\n\tu8 csum;\n\n\tif (!is_fru_eeprom_supported(adev, &fru_addr))\n\t\treturn 0;\n\n\t \n\tif (!adev->pm.fru_eeprom_i2c_bus || !adev->pm.fru_eeprom_i2c_bus->algo) {\n\t\tDRM_WARN(\"Cannot access FRU, EEPROM accessor not initialized\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tlen = amdgpu_eeprom_read(adev->pm.fru_eeprom_i2c_bus, fru_addr, buf,\n\t\t\t\t sizeof(buf));\n\tif (len != 8) {\n\t\tDRM_ERROR(\"Couldn't read the IPMI Common Header: %d\", len);\n\t\treturn len < 0 ? len : -EIO;\n\t}\n\n\tif (buf[0] != 1) {\n\t\tDRM_ERROR(\"Bad IPMI Common Header version: 0x%02x\", buf[0]);\n\t\treturn -EIO;\n\t}\n\n\tfor (csum = 0; len > 0; len--)\n\t\tcsum += buf[len - 1];\n\tif (csum) {\n\t\tDRM_ERROR(\"Bad IPMI Common Header checksum: 0x%02x\", csum);\n\t\treturn -EIO;\n\t}\n\n\t \n\taddr = buf[4] * 8;\n\tif (!addr)\n\t\treturn 0;\n\n\t \n\taddr += fru_addr;\n\n\t \n\tlen = amdgpu_eeprom_read(adev->pm.fru_eeprom_i2c_bus, addr, buf, 3);\n\tif (len != 3) {\n\t\tDRM_ERROR(\"Couldn't read the Product Info Area header: %d\", len);\n\t\treturn len < 0 ? len : -EIO;\n\t}\n\n\tif (buf[0] != 1) {\n\t\tDRM_ERROR(\"Bad IPMI Product Info Area version: 0x%02x\", buf[0]);\n\t\treturn -EIO;\n\t}\n\n\tsize = buf[1] * 8;\n\tpia = kzalloc(size, GFP_KERNEL);\n\tif (!pia)\n\t\treturn -ENOMEM;\n\n\t \n\tlen = amdgpu_eeprom_read(adev->pm.fru_eeprom_i2c_bus, addr, pia, size);\n\tif (len != size) {\n\t\tkfree(pia);\n\t\tDRM_ERROR(\"Couldn't read the Product Info Area: %d\", len);\n\t\treturn len < 0 ? len : -EIO;\n\t}\n\n\tfor (csum = 0; size > 0; size--)\n\t\tcsum += pia[size - 1];\n\tif (csum) {\n\t\tDRM_ERROR(\"Bad Product Info Area checksum: 0x%02x\", csum);\n\t\tkfree(pia);\n\t\treturn -EIO;\n\t}\n\n\t \n\taddr = 3 + 1 + (pia[3] & 0x3F);\n\tif (addr + 1 >= len)\n\t\tgoto Out;\n\tmemcpy(adev->product_name, pia + addr + 1,\n\t       min_t(size_t,\n\t\t     sizeof(adev->product_name),\n\t\t     pia[addr] & 0x3F));\n\tadev->product_name[sizeof(adev->product_name) - 1] = '\\0';\n\n\t \n\taddr += 1 + (pia[addr] & 0x3F);\n\tif (addr + 1 >= len)\n\t\tgoto Out;\n\tmemcpy(adev->product_number, pia + addr + 1,\n\t       min_t(size_t,\n\t\t     sizeof(adev->product_number),\n\t\t     pia[addr] & 0x3F));\n\tadev->product_number[sizeof(adev->product_number) - 1] = '\\0';\n\n\t \n\taddr += 1 + (pia[addr] & 0x3F);\n\n\t \n\taddr += 1 + (pia[addr] & 0x3F);\n\tif (addr + 1 >= len)\n\t\tgoto Out;\n\tmemcpy(adev->serial, pia + addr + 1, min_t(size_t,\n\t\t\t\t\t\t   sizeof(adev->serial),\n\t\t\t\t\t\t   pia[addr] & 0x3F));\n\tadev->serial[sizeof(adev->serial) - 1] = '\\0';\nOut:\n\tkfree(pia);\n\treturn 0;\n}\n\n \n\nstatic ssize_t amdgpu_fru_product_name_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", adev->product_name);\n}\n\nstatic DEVICE_ATTR(product_name, 0444, amdgpu_fru_product_name_show, NULL);\n\n \n\nstatic ssize_t amdgpu_fru_product_number_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", adev->product_number);\n}\n\nstatic DEVICE_ATTR(product_number, 0444, amdgpu_fru_product_number_show, NULL);\n\n \n\nstatic ssize_t amdgpu_fru_serial_number_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", adev->serial);\n}\n\nstatic DEVICE_ATTR(serial_number, 0444, amdgpu_fru_serial_number_show, NULL);\n\nstatic const struct attribute *amdgpu_fru_attributes[] = {\n\t&dev_attr_product_name.attr,\n\t&dev_attr_product_number.attr,\n\t&dev_attr_serial_number.attr,\n\tNULL\n};\n\nint amdgpu_fru_sysfs_init(struct amdgpu_device *adev)\n{\n\tif (!is_fru_eeprom_supported(adev, NULL))\n\t\treturn 0;\n\n\treturn sysfs_create_files(&adev->dev->kobj, amdgpu_fru_attributes);\n}\n\nvoid amdgpu_fru_sysfs_fini(struct amdgpu_device *adev)\n{\n\tif (!is_fru_eeprom_supported(adev, NULL))\n\t\treturn;\n\n\tsysfs_remove_files(&adev->dev->kobj, amdgpu_fru_attributes);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}