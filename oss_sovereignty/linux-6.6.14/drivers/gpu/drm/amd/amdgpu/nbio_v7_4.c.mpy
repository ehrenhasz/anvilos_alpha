{
  "module_name": "nbio_v7_4.c",
  "hash_id": "209d1028a4eca4ed2294e93b1475b1bac882738ddad5b776f90ccf1616decc6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/nbio_v7_4.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"nbio_v7_4.h\"\n#include \"amdgpu_ras.h\"\n\n#include \"nbio/nbio_7_4_offset.h\"\n#include \"nbio/nbio_7_4_sh_mask.h\"\n#include \"nbio/nbio_7_4_0_smn.h\"\n#include \"ivsrcid/nbio/irqsrcs_nbif_7_4.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\n#define smnPCIE_LC_CNTL\t\t0x11140280\n#define smnPCIE_LC_CNTL3\t0x111402d4\n#define smnPCIE_LC_CNTL6\t0x111402ec\n#define smnPCIE_LC_CNTL7\t0x111402f0\n#define smnNBIF_MGCG_CTRL_LCLK\t0x1013a21c\n#define smnRCC_BIF_STRAP3\t0x1012348c\n#define RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER_MASK\t0x0000FFFFL\n#define RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER_MASK\t0xFFFF0000L\n#define smnRCC_BIF_STRAP5\t0x10123494\n#define RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER_MASK\t0x0000FFFFL\n#define smnBIF_CFG_DEV0_EPF0_DEVICE_CNTL2\t0x1014008c\n#define BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK\t\t\t0x0400L\n#define smnBIF_CFG_DEV0_EPF0_PCIE_LTR_CAP\t0x10140324\n#define smnPSWUSP0_PCIE_LC_CNTL2\t\t0x111402c4\n#define smnRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL\t0x10123538\n#define smnRCC_BIF_STRAP2\t0x10123488\n#define RCC_BIF_STRAP2__STRAP_LTR_IN_ASPML1_DIS_MASK\t0x00004000L\n#define RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER__SHIFT\t0x0\n#define RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER__SHIFT\t0x10\n#define RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER__SHIFT\t0x0\n\n \n#define GPU_HDP_FLUSH_DONE__RSVD_ENG0_MASK\t0x00001000L  \n#define GPU_HDP_FLUSH_DONE__RSVD_ENG1_MASK\t0x00002000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG2_MASK\t0x00004000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG3_MASK\t0x00008000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG4_MASK\t0x00010000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG5_MASK\t0x00020000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG6_MASK\t0x00040000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG7_MASK\t0x00080000L\n#define GPU_HDP_FLUSH_DONE__RSVD_ENG8_MASK\t0x00100000L\n\n#define mmBIF_MMSCH1_DOORBELL_RANGE                     0x01dc\n#define mmBIF_MMSCH1_DOORBELL_RANGE_BASE_IDX            2\n \n#define BIF_MMSCH1_DOORBELL_RANGE__OFFSET__SHIFT        0x2\n#define BIF_MMSCH1_DOORBELL_RANGE__SIZE__SHIFT          0x10\n#define BIF_MMSCH1_DOORBELL_RANGE__OFFSET_MASK          0x00000FFCL\n#define BIF_MMSCH1_DOORBELL_RANGE__SIZE_MASK            0x001F0000L\n\n#define BIF_MMSCH1_DOORBELL_RANGE__OFFSET_MASK          0x00000FFCL\n#define BIF_MMSCH1_DOORBELL_RANGE__SIZE_MASK            0x001F0000L\n\n#define mmBIF_MMSCH1_DOORBELL_RANGE_ALDE                0x01d8\n#define mmBIF_MMSCH1_DOORBELL_RANGE_ALDE_BASE_IDX       2\n \n#define BIF_MMSCH1_DOORBELL_RANGE_ALDE__OFFSET__SHIFT   0x2\n#define BIF_MMSCH1_DOORBELL_RANGE_ALDE__SIZE__SHIFT     0x10\n#define BIF_MMSCH1_DOORBELL_RANGE_ALDE__OFFSET_MASK     0x00000FFCL\n#define BIF_MMSCH1_DOORBELL_RANGE_ALDE__SIZE_MASK       0x001F0000L\n\n#define mmRCC_DEV0_EPF0_STRAP0_ALDE\t\t\t0x0015\n#define mmRCC_DEV0_EPF0_STRAP0_ALDE_BASE_IDX\t\t2\n\n#define mmBIF_DOORBELL_INT_CNTL_ALDE \t\t\t0x00fe\n#define mmBIF_DOORBELL_INT_CNTL_ALDE_BASE_IDX \t\t2\n#define BIF_DOORBELL_INT_CNTL_ALDE__DOORBELL_INTERRUPT_DISABLE__SHIFT\t0x18\n#define BIF_DOORBELL_INT_CNTL_ALDE__DOORBELL_INTERRUPT_DISABLE_MASK\t0x01000000L\n\n#define mmBIF_INTR_CNTL_ALDE \t\t\t\t0x0101\n#define mmBIF_INTR_CNTL_ALDE_BASE_IDX \t\t\t2\n\nstatic void nbio_v7_4_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\tvoid *ras_error_status);\n\nstatic void nbio_v7_4_remap_hdp_registers(struct amdgpu_device *adev)\n{\n\tWREG32_SOC15(NBIO, 0, mmREMAP_HDP_MEM_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL);\n\tWREG32_SOC15(NBIO, 0, mmREMAP_HDP_REG_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL);\n}\n\nstatic u32 nbio_v7_4_get_rev_id(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\ttmp = RREG32_SOC15(NBIO, 0, mmRCC_DEV0_EPF0_STRAP0_ALDE);\n\telse\n\t\ttmp = RREG32_SOC15(NBIO, 0, mmRCC_DEV0_EPF0_STRAP0);\n\n\ttmp &= RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0_MASK;\n\ttmp >>= RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0__SHIFT;\n\n\treturn tmp;\n}\n\nstatic void nbio_v7_4_mc_access_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_SOC15(NBIO, 0, mmBIF_FB_EN,\n\t\t\tBIF_FB_EN__FB_READ_EN_MASK | BIF_FB_EN__FB_WRITE_EN_MASK);\n\telse\n\t\tWREG32_SOC15(NBIO, 0, mmBIF_FB_EN, 0);\n}\n\nstatic u32 nbio_v7_4_get_memsize(struct amdgpu_device *adev)\n{\n\treturn RREG32_SOC15(NBIO, 0, mmRCC_CONFIG_MEMSIZE);\n}\n\nstatic void nbio_v7_4_sdma_doorbell_range(struct amdgpu_device *adev, int instance,\n\t\t\tbool use_doorbell, int doorbell_index, int doorbell_size)\n{\n\tu32 reg, doorbell_range;\n\n\tif (instance < 2) {\n\t\treg = instance +\n\t\t\tSOC15_REG_OFFSET(NBIO, 0, mmBIF_SDMA0_DOORBELL_RANGE);\n\t} else {\n\t\t \n\t\tif (adev->asic_type == CHIP_ALDEBARAN && instance == 4)\n\t\t\treg = instance + 0x4 + 0x1 +\n\t\t\t\tSOC15_REG_OFFSET(NBIO, 0,\n\t\t\t\t\t\t mmBIF_SDMA0_DOORBELL_RANGE);\n\t\telse\n\t\t\treg = instance + 0x4 +\n\t\t\t\tSOC15_REG_OFFSET(NBIO, 0,\n\t\t\t\t\t\t mmBIF_SDMA0_DOORBELL_RANGE);\n\t}\n\n\tdoorbell_range = RREG32(reg);\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range, BIF_SDMA0_DOORBELL_RANGE, OFFSET, doorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range, BIF_SDMA0_DOORBELL_RANGE, SIZE, doorbell_size);\n\t} else\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range, BIF_SDMA0_DOORBELL_RANGE, SIZE, 0);\n\n\tWREG32(reg, doorbell_range);\n}\n\nstatic void nbio_v7_4_vcn_doorbell_range(struct amdgpu_device *adev, bool use_doorbell,\n\t\t\t\t\t int doorbell_index, int instance)\n{\n\tu32 reg;\n\tu32 doorbell_range;\n\n\tif (instance) {\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\treg = SOC15_REG_OFFSET(NBIO, 0, mmBIF_MMSCH1_DOORBELL_RANGE_ALDE);\n\t\telse\n\t\t\treg = SOC15_REG_OFFSET(NBIO, 0, mmBIF_MMSCH1_DOORBELL_RANGE);\n\t} else\n\t\treg = SOC15_REG_OFFSET(NBIO, 0, mmBIF_MMSCH0_DOORBELL_RANGE);\n\n\tdoorbell_range = RREG32(reg);\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       BIF_MMSCH0_DOORBELL_RANGE, OFFSET,\n\t\t\t\t\t       doorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       BIF_MMSCH0_DOORBELL_RANGE, SIZE, 8);\n\t} else\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       BIF_MMSCH0_DOORBELL_RANGE, SIZE, 0);\n\n\tWREG32(reg, doorbell_range);\n}\n\nstatic void nbio_v7_4_enable_doorbell_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tWREG32_FIELD15(NBIO, 0, RCC_DOORBELL_APER_EN, BIF_DOORBELL_APER_EN, enable ? 1 : 0);\n}\n\nstatic void nbio_v7_4_enable_doorbell_selfring_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tbool enable)\n{\n\tu32 tmp = 0;\n\n\tif (enable) {\n\t\ttmp = REG_SET_FIELD(tmp, DOORBELL_SELFRING_GPA_APER_CNTL, DOORBELL_SELFRING_GPA_APER_EN, 1) |\n\t\t      REG_SET_FIELD(tmp, DOORBELL_SELFRING_GPA_APER_CNTL, DOORBELL_SELFRING_GPA_APER_MODE, 1) |\n\t\t      REG_SET_FIELD(tmp, DOORBELL_SELFRING_GPA_APER_CNTL, DOORBELL_SELFRING_GPA_APER_SIZE, 0);\n\n\t\tWREG32_SOC15(NBIO, 0, mmDOORBELL_SELFRING_GPA_APER_BASE_LOW,\n\t\t\t     lower_32_bits(adev->doorbell.base));\n\t\tWREG32_SOC15(NBIO, 0, mmDOORBELL_SELFRING_GPA_APER_BASE_HIGH,\n\t\t\t     upper_32_bits(adev->doorbell.base));\n\t}\n\n\tWREG32_SOC15(NBIO, 0, mmDOORBELL_SELFRING_GPA_APER_CNTL, tmp);\n}\n\nstatic void nbio_v7_4_ih_doorbell_range(struct amdgpu_device *adev,\n\t\t\t\t\tbool use_doorbell, int doorbell_index)\n{\n\tu32 ih_doorbell_range = RREG32_SOC15(NBIO, 0 , mmBIF_IH_DOORBELL_RANGE);\n\n\tif (use_doorbell) {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range, BIF_IH_DOORBELL_RANGE, OFFSET, doorbell_index);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range, BIF_IH_DOORBELL_RANGE, SIZE, 8);\n\t} else\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range, BIF_IH_DOORBELL_RANGE, SIZE, 0);\n\n\tWREG32_SOC15(NBIO, 0, mmBIF_IH_DOORBELL_RANGE, ih_doorbell_range);\n}\n\n\nstatic void nbio_v7_4_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\t \n}\n\nstatic void nbio_v7_4_update_medium_grain_light_sleep(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t def, data;\n\n\tdef = data = RREG32_PCIE(smnPCIE_CNTL2);\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_BIF_LS)) {\n\t\tdata |= (PCIE_CNTL2__SLV_MEM_LS_EN_MASK |\n\t\t\t PCIE_CNTL2__MST_MEM_LS_EN_MASK |\n\t\t\t PCIE_CNTL2__REPLAY_MEM_LS_EN_MASK);\n\t} else {\n\t\tdata &= ~(PCIE_CNTL2__SLV_MEM_LS_EN_MASK |\n\t\t\t  PCIE_CNTL2__MST_MEM_LS_EN_MASK |\n\t\t\t  PCIE_CNTL2__REPLAY_MEM_LS_EN_MASK);\n\t}\n\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_CNTL2, data);\n}\n\nstatic void nbio_v7_4_get_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t    u64 *flags)\n{\n\tint data;\n\n\t \n\tdata = RREG32_PCIE(smnCPM_CONTROL);\n\tif (data & CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_MGCG;\n\n\t \n\tdata = RREG32_PCIE(smnPCIE_CNTL2);\n\tif (data & PCIE_CNTL2__SLV_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_LS;\n}\n\nstatic void nbio_v7_4_ih_control(struct amdgpu_device *adev)\n{\n\tu32 interrupt_cntl;\n\n\t \n\tWREG32_SOC15(NBIO, 0, mmINTERRUPT_CNTL2, adev->dummy_page_addr >> 8);\n\tinterrupt_cntl = RREG32_SOC15(NBIO, 0, mmINTERRUPT_CNTL);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, INTERRUPT_CNTL, IH_DUMMY_RD_OVERRIDE, 0);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, INTERRUPT_CNTL, IH_REQ_NONSNOOP_EN, 0);\n\tWREG32_SOC15(NBIO, 0, mmINTERRUPT_CNTL, interrupt_cntl);\n}\n\nstatic u32 nbio_v7_4_get_hdp_flush_req_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, mmGPU_HDP_FLUSH_REQ);\n}\n\nstatic u32 nbio_v7_4_get_hdp_flush_done_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, mmGPU_HDP_FLUSH_DONE);\n}\n\nstatic u32 nbio_v7_4_get_pcie_index_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, mmPCIE_INDEX2);\n}\n\nstatic u32 nbio_v7_4_get_pcie_data_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, mmPCIE_DATA2);\n}\n\nconst struct nbio_hdp_flush_reg nbio_v7_4_hdp_flush_reg = {\n\t.ref_and_mask_cp0 = GPU_HDP_FLUSH_DONE__CP0_MASK,\n\t.ref_and_mask_cp1 = GPU_HDP_FLUSH_DONE__CP1_MASK,\n\t.ref_and_mask_cp2 = GPU_HDP_FLUSH_DONE__CP2_MASK,\n\t.ref_and_mask_cp3 = GPU_HDP_FLUSH_DONE__CP3_MASK,\n\t.ref_and_mask_cp4 = GPU_HDP_FLUSH_DONE__CP4_MASK,\n\t.ref_and_mask_cp5 = GPU_HDP_FLUSH_DONE__CP5_MASK,\n\t.ref_and_mask_cp6 = GPU_HDP_FLUSH_DONE__CP6_MASK,\n\t.ref_and_mask_cp7 = GPU_HDP_FLUSH_DONE__CP7_MASK,\n\t.ref_and_mask_cp8 = GPU_HDP_FLUSH_DONE__CP8_MASK,\n\t.ref_and_mask_cp9 = GPU_HDP_FLUSH_DONE__CP9_MASK,\n\t.ref_and_mask_sdma0 = GPU_HDP_FLUSH_DONE__SDMA0_MASK,\n\t.ref_and_mask_sdma1 = GPU_HDP_FLUSH_DONE__SDMA1_MASK,\n};\n\nstatic void nbio_v7_4_init_registers(struct amdgpu_device *adev)\n{\n\tuint32_t baco_cntl;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tadev->rmmio_remap.reg_offset = SOC15_REG_OFFSET(NBIO, 0,\n\t\t\tmmBIF_BX_DEV0_EPF0_VF0_HDP_MEM_COHERENCY_FLUSH_CNTL) << 2;\n\n\tif (adev->ip_versions[NBIO_HWIP][0] == IP_VERSION(7, 4, 4) &&\n\t    !amdgpu_sriov_vf(adev)) {\n\t\tbaco_cntl = RREG32_SOC15(NBIO, 0, mmBACO_CNTL);\n\t\tif (baco_cntl &\n\t\t    (BACO_CNTL__BACO_DUMMY_EN_MASK | BACO_CNTL__BACO_EN_MASK)) {\n\t\t\tbaco_cntl &= ~(BACO_CNTL__BACO_DUMMY_EN_MASK |\n\t\t\t\t       BACO_CNTL__BACO_EN_MASK);\n\t\t\tdev_dbg(adev->dev, \"Unsetting baco dummy mode %x\",\n\t\t\t\tbaco_cntl);\n\t\t\tWREG32_SOC15(NBIO, 0, mmBACO_CNTL, baco_cntl);\n\t\t}\n\t}\n}\n\nstatic void nbio_v7_4_handle_ras_controller_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_intr_cntl;\n\tstruct ras_manager *obj = amdgpu_ras_find_obj(adev, adev->nbio.ras_if);\n\tstruct ras_err_data err_data = {0, 0, 0, NULL};\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE);\n\telse\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL);\n\n\tif (REG_GET_FIELD(bif_doorbell_intr_cntl,\n\t\tBIF_DOORBELL_INT_CNTL, RAS_CNTLR_INTERRUPT_STATUS)) {\n\t\t \n\t\tbif_doorbell_intr_cntl = REG_SET_FIELD(bif_doorbell_intr_cntl,\n\t\t\t\t\t\tBIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_CNTLR_INTERRUPT_CLEAR, 1);\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE, bif_doorbell_intr_cntl);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL, bif_doorbell_intr_cntl);\n\n\t\tif (!ras->disable_ras_err_cnt_harvest) {\n\t\t\t \n\t\t\tnbio_v7_4_query_ras_error_count(adev, &err_data);\n\n\t\t\t \n\t\t\tobj->err_data.ue_count += err_data.ue_count;\n\t\t\tobj->err_data.ce_count += err_data.ce_count;\n\n\t\t\tif (err_data.ce_count)\n\t\t\t\tdev_info(adev->dev, \"%ld correctable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block, \"\n\t\t\t\t\t\t\"no user action is needed.\\n\",\n\t\t\t\t\t\tobj->err_data.ce_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\n\t\t\tif (err_data.ue_count)\n\t\t\t\tdev_info(adev->dev, \"%ld uncorrectable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block\\n\",\n\t\t\t\t\t\tobj->err_data.ue_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\t\t}\n\n\t\tdev_info(adev->dev, \"RAS controller interrupt triggered \"\n\t\t\t\t\t\"by NBIF error\\n\");\n\n\t\t \n\t\tamdgpu_ras_reset_gpu(adev);\n\t}\n}\n\nstatic void nbio_v7_4_handle_ras_err_event_athub_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_intr_cntl;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE);\n\telse\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL);\n\n\tif (REG_GET_FIELD(bif_doorbell_intr_cntl,\n\t\tBIF_DOORBELL_INT_CNTL, RAS_ATHUB_ERR_EVENT_INTERRUPT_STATUS)) {\n\t\t \n\t\tbif_doorbell_intr_cntl = REG_SET_FIELD(bif_doorbell_intr_cntl,\n\t\t\t\t\t\tBIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_ATHUB_ERR_EVENT_INTERRUPT_CLEAR, 1);\n\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE, bif_doorbell_intr_cntl);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL, bif_doorbell_intr_cntl);\n\n\t\tamdgpu_ras_global_ras_isr(adev);\n\t}\n}\n\n\nstatic int nbio_v7_4_set_ras_controller_irq_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t  struct amdgpu_irq_src *src,\n\t\t\t\t\t\t  unsigned type,\n\t\t\t\t\t\t  enum amdgpu_interrupt_state state)\n{\n\t \n\tuint32_t bif_intr_cntl;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tbif_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL_ALDE);\n\telse\n\t\tbif_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL);\n\n\tif (state == AMDGPU_IRQ_STATE_ENABLE) {\n\t\t \n\t\tbif_intr_cntl = REG_SET_FIELD(bif_intr_cntl,\n\t\t\t\t\t      BIF_INTR_CNTL,\n\t\t\t\t\t      RAS_INTR_VEC_SEL, 0);\n\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL_ALDE, bif_intr_cntl);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL, bif_intr_cntl);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int nbio_v7_4_process_ras_controller_irq(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\t\tstruct amdgpu_iv_entry *entry)\n{\n\t \n\treturn 0;\n}\n\nstatic int nbio_v7_4_set_ras_err_event_athub_irq_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t       struct amdgpu_irq_src *src,\n\t\t\t\t\t\t       unsigned type,\n\t\t\t\t\t\t       enum amdgpu_interrupt_state state)\n{\n\t \n\tuint32_t bif_intr_cntl;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tbif_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL_ALDE);\n\telse\n\t\tbif_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL);\n\n\tif (state == AMDGPU_IRQ_STATE_ENABLE) {\n\t\t \n\t\tbif_intr_cntl = REG_SET_FIELD(bif_intr_cntl,\n\t\t\t\t\t      BIF_INTR_CNTL,\n\t\t\t\t\t      RAS_INTR_VEC_SEL, 0);\n\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL_ALDE, bif_intr_cntl);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_INTR_CNTL, bif_intr_cntl);\n\t}\n\n\treturn 0;\n}\n\nstatic int nbio_v7_4_process_err_event_athub_irq(struct amdgpu_device *adev,\n\t\t\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs nbio_v7_4_ras_controller_irq_funcs = {\n\t.set = nbio_v7_4_set_ras_controller_irq_state,\n\t.process = nbio_v7_4_process_ras_controller_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs nbio_v7_4_ras_err_event_athub_irq_funcs = {\n\t.set = nbio_v7_4_set_ras_err_event_athub_irq_state,\n\t.process = nbio_v7_4_process_err_event_athub_irq,\n};\n\nstatic int nbio_v7_4_init_ras_controller_interrupt (struct amdgpu_device *adev)\n{\n\tint r;\n\n\t \n\tadev->nbio.ras_controller_irq.funcs =\n\t\t&nbio_v7_4_ras_controller_irq_funcs;\n\tadev->nbio.ras_controller_irq.num_types = 1;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_BIF,\n\t\t\t      NBIF_7_4__SRCID__RAS_CONTROLLER_INTERRUPT,\n\t\t\t      &adev->nbio.ras_controller_irq);\n\n\treturn r;\n}\n\nstatic int nbio_v7_4_init_ras_err_event_athub_interrupt (struct amdgpu_device *adev)\n{\n\n\tint r;\n\n\t \n\tadev->nbio.ras_err_event_athub_irq.funcs =\n\t\t&nbio_v7_4_ras_err_event_athub_irq_funcs;\n\tadev->nbio.ras_err_event_athub_irq.num_types = 1;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_BIF,\n\t\t\t      NBIF_7_4__SRCID__ERREVENT_ATHUB_INTERRUPT,\n\t\t\t      &adev->nbio.ras_err_event_athub_irq);\n\n\treturn r;\n}\n\n#define smnPARITY_ERROR_STATUS_UNCORR_GRP2\t    0x13a20030\n#define smnPARITY_ERROR_STATUS_UNCORR_GRP2_ALDE\t0x13b20030\n#define smnRAS_GLOBAL_STATUS_LO_ALDE            0x13b20020\n\nstatic void nbio_v7_4_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\tvoid *ras_error_status)\n{\n\tuint32_t global_sts, central_sts, int_eoi, parity_sts;\n\tuint32_t corr, fatal, non_fatal;\n\tstruct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tglobal_sts = RREG32_PCIE(smnRAS_GLOBAL_STATUS_LO_ALDE);\n\telse\n\t\tglobal_sts = RREG32_PCIE(smnRAS_GLOBAL_STATUS_LO);\n\n\tcorr = REG_GET_FIELD(global_sts, RAS_GLOBAL_STATUS_LO, ParityErrCorr);\n\tfatal = REG_GET_FIELD(global_sts, RAS_GLOBAL_STATUS_LO, ParityErrFatal);\n\tnon_fatal = REG_GET_FIELD(global_sts, RAS_GLOBAL_STATUS_LO,\n\t\t\t\tParityErrNonFatal);\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tparity_sts = RREG32_PCIE(smnPARITY_ERROR_STATUS_UNCORR_GRP2_ALDE);\n\telse\n\t\tparity_sts = RREG32_PCIE(smnPARITY_ERROR_STATUS_UNCORR_GRP2);\n\n\tif (corr)\n\t\terr_data->ce_count++;\n\tif (fatal)\n\t\terr_data->ue_count++;\n\n\tif (corr || fatal || non_fatal) {\n\t\tcentral_sts = RREG32_PCIE(smnBIFL_RAS_CENTRAL_STATUS);\n\n\t\t \n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_PCIE(smnRAS_GLOBAL_STATUS_LO_ALDE, global_sts);\n\t\telse\n\t\t\tWREG32_PCIE(smnRAS_GLOBAL_STATUS_LO, global_sts);\n\n\t\tif (fatal)\n\t\t{\n\t\t\t \n\t\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\t\tWREG32_PCIE(smnPARITY_ERROR_STATUS_UNCORR_GRP2_ALDE, parity_sts);\n\t\t\telse\n\t\t\t\tWREG32_PCIE(smnPARITY_ERROR_STATUS_UNCORR_GRP2, parity_sts);\n\t\t}\n\n\t\tif (REG_GET_FIELD(central_sts, BIFL_RAS_CENTRAL_STATUS,\n\t\t\t\tBIFL_RasContller_Intr_Recv)) {\n\t\t\t \n\t\t\tWREG32_PCIE(smnBIFL_RAS_CENTRAL_STATUS, central_sts);\n\t\t\tint_eoi = RREG32_PCIE(smnIOHC_INTERRUPT_EOI);\n\t\t\tint_eoi = REG_SET_FIELD(int_eoi,\n\t\t\t\t\tIOHC_INTERRUPT_EOI, SMI_EOI, 1);\n\t\t\tWREG32_PCIE(smnIOHC_INTERRUPT_EOI, int_eoi);\n\t\t}\n\t}\n}\n\nstatic void nbio_v7_4_enable_doorbell_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tWREG32_FIELD15(NBIO, 0, BIF_DOORBELL_INT_CNTL_ALDE,\n\t\t       DOORBELL_INTERRUPT_DISABLE, enable ? 0 : 1);\n\telse\n\t\tWREG32_FIELD15(NBIO, 0, BIF_DOORBELL_INT_CNTL,\n\t\t       DOORBELL_INTERRUPT_DISABLE, enable ? 0 : 1);\n}\n\nconst struct amdgpu_ras_block_hw_ops nbio_v7_4_ras_hw_ops = {\n\t.query_ras_error_count = nbio_v7_4_query_ras_error_count,\n};\n\nstruct amdgpu_nbio_ras nbio_v7_4_ras = {\n\t.ras_block = {\n\t\t.ras_comm = {\n\t\t\t.name = \"pcie_bif\",\n\t\t\t.block = AMDGPU_RAS_BLOCK__PCIE_BIF,\n\t\t\t.type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE,\n\t\t},\n\t\t.hw_ops = &nbio_v7_4_ras_hw_ops,\n\t\t.ras_late_init = amdgpu_nbio_ras_late_init,\n\t},\n\t.handle_ras_controller_intr_no_bifring = nbio_v7_4_handle_ras_controller_intr_no_bifring,\n\t.handle_ras_err_event_athub_intr_no_bifring = nbio_v7_4_handle_ras_err_event_athub_intr_no_bifring,\n\t.init_ras_controller_interrupt = nbio_v7_4_init_ras_controller_interrupt,\n\t.init_ras_err_event_athub_interrupt = nbio_v7_4_init_ras_err_event_athub_interrupt,\n};\n\n\n#ifdef CONFIG_PCIEASPM\nstatic void nbio_v7_4_program_ltr(struct amdgpu_device *adev)\n{\n\tuint32_t def, data;\n\n\tWREG32_PCIE(smnRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL, 0x75EB);\n\n\tdef = data = RREG32_PCIE(smnRCC_BIF_STRAP2);\n\tdata &= ~RCC_BIF_STRAP2__STRAP_LTR_IN_ASPML1_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_BIF_STRAP2, data);\n\n\tdef = data = RREG32_PCIE(smnRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL);\n\tdata &= ~EP_PCIE_TX_LTR_CNTL__LTR_PRIV_MSG_DIS_IN_PM_NON_D0_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_EP_DEV0_0_EP_PCIE_TX_LTR_CNTL, data);\n\n\tdef = data = RREG32_PCIE(smnBIF_CFG_DEV0_EPF0_DEVICE_CNTL2);\n\tdata |= BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnBIF_CFG_DEV0_EPF0_DEVICE_CNTL2, data);\n}\n#endif\n\nstatic void nbio_v7_4_program_aspm(struct amdgpu_device *adev)\n{\n#ifdef CONFIG_PCIEASPM\n\tuint32_t def, data;\n\n\tif (adev->ip_versions[NBIO_HWIP][0] == IP_VERSION(7, 4, 4))\n\t\treturn;\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL);\n\tdata &= ~PCIE_LC_CNTL__LC_L1_INACTIVITY_MASK;\n\tdata &= ~PCIE_LC_CNTL__LC_L0S_INACTIVITY_MASK;\n\tdata |= PCIE_LC_CNTL__LC_PMI_TO_L1_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL, data);\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL7);\n\tdata |= PCIE_LC_CNTL7__LC_NBIF_ASPM_INPUT_EN_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL7, data);\n\n\tdef = data = RREG32_PCIE(smnNBIF_MGCG_CTRL_LCLK);\n\tdata |= NBIF_MGCG_CTRL_LCLK__NBIF_MGCG_REG_DIS_LCLK_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnNBIF_MGCG_CTRL_LCLK, data);\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL3);\n\tdata |= PCIE_LC_CNTL3__LC_DSC_DONT_ENTER_L23_AFTER_PME_ACK_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL3, data);\n\n\tdef = data = RREG32_PCIE(smnRCC_BIF_STRAP3);\n\tdata &= ~RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER_MASK;\n\tdata &= ~RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_BIF_STRAP3, data);\n\n\tdef = data = RREG32_PCIE(smnRCC_BIF_STRAP5);\n\tdata &= ~RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_BIF_STRAP5, data);\n\n\tdef = data = RREG32_PCIE(smnBIF_CFG_DEV0_EPF0_DEVICE_CNTL2);\n\tdata &= ~BIF_CFG_DEV0_EPF0_DEVICE_CNTL2__LTR_EN_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnBIF_CFG_DEV0_EPF0_DEVICE_CNTL2, data);\n\n\tWREG32_PCIE(smnBIF_CFG_DEV0_EPF0_PCIE_LTR_CAP, 0x10011001);\n\n\tdef = data = RREG32_PCIE(smnPSWUSP0_PCIE_LC_CNTL2);\n\tdata |= PSWUSP0_PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L1_MASK |\n\t\tPSWUSP0_PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L23_MASK;\n\tdata &= ~PSWUSP0_PCIE_LC_CNTL2__LC_RCV_L0_TO_RCV_L0S_DIS_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPSWUSP0_PCIE_LC_CNTL2, data);\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL6);\n\tdata |= PCIE_LC_CNTL6__LC_L1_POWERDOWN_MASK |\n\t\tPCIE_LC_CNTL6__LC_RX_L0S_STANDBY_EN_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL6, data);\n\n\t \n\tif (adev->pdev->ltr_path)\n\t\tnbio_v7_4_program_ltr(adev);\n\n\tdef = data = RREG32_PCIE(smnRCC_BIF_STRAP3);\n\tdata |= 0x5DE0 << RCC_BIF_STRAP3__STRAP_VLINK_ASPM_IDLE_TIMER__SHIFT;\n\tdata |= 0x0010 << RCC_BIF_STRAP3__STRAP_VLINK_PM_L1_ENTRY_TIMER__SHIFT;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_BIF_STRAP3, data);\n\n\tdef = data = RREG32_PCIE(smnRCC_BIF_STRAP5);\n\tdata |= 0x0010 << RCC_BIF_STRAP5__STRAP_VLINK_LDN_ENTRY_TIMER__SHIFT;\n\tif (def != data)\n\t\tWREG32_PCIE(smnRCC_BIF_STRAP5, data);\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL);\n\tdata &= ~PCIE_LC_CNTL__LC_L0S_INACTIVITY_MASK;\n\tdata |= 0x9 << PCIE_LC_CNTL__LC_L1_INACTIVITY__SHIFT;\n\tdata |= 0x1 << PCIE_LC_CNTL__LC_PMI_TO_L1_DIS__SHIFT;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL, data);\n\n\tdef = data = RREG32_PCIE(smnPCIE_LC_CNTL3);\n\tdata &= ~PCIE_LC_CNTL3__LC_DSC_DONT_ENTER_L23_AFTER_PME_ACK_MASK;\n\tif (def != data)\n\t\tWREG32_PCIE(smnPCIE_LC_CNTL3, data);\n#endif\n}\n\nconst struct amdgpu_nbio_funcs nbio_v7_4_funcs = {\n\t.get_hdp_flush_req_offset = nbio_v7_4_get_hdp_flush_req_offset,\n\t.get_hdp_flush_done_offset = nbio_v7_4_get_hdp_flush_done_offset,\n\t.get_pcie_index_offset = nbio_v7_4_get_pcie_index_offset,\n\t.get_pcie_data_offset = nbio_v7_4_get_pcie_data_offset,\n\t.get_rev_id = nbio_v7_4_get_rev_id,\n\t.mc_access_enable = nbio_v7_4_mc_access_enable,\n\t.get_memsize = nbio_v7_4_get_memsize,\n\t.sdma_doorbell_range = nbio_v7_4_sdma_doorbell_range,\n\t.vcn_doorbell_range = nbio_v7_4_vcn_doorbell_range,\n\t.enable_doorbell_aperture = nbio_v7_4_enable_doorbell_aperture,\n\t.enable_doorbell_selfring_aperture = nbio_v7_4_enable_doorbell_selfring_aperture,\n\t.ih_doorbell_range = nbio_v7_4_ih_doorbell_range,\n\t.enable_doorbell_interrupt = nbio_v7_4_enable_doorbell_interrupt,\n\t.update_medium_grain_clock_gating = nbio_v7_4_update_medium_grain_clock_gating,\n\t.update_medium_grain_light_sleep = nbio_v7_4_update_medium_grain_light_sleep,\n\t.get_clockgating_state = nbio_v7_4_get_clockgating_state,\n\t.ih_control = nbio_v7_4_ih_control,\n\t.init_registers = nbio_v7_4_init_registers,\n\t.remap_hdp_registers = nbio_v7_4_remap_hdp_registers,\n\t.program_aspm =  nbio_v7_4_program_aspm,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}