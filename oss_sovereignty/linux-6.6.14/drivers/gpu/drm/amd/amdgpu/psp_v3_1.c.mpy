{
  "module_name": "psp_v3_1.c",
  "hash_id": "9d2697005ad2f34bdb3ff14a57ab9cb95bb68909a70e4f87d5e08bbb1d880f43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/psp_v3_1.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ucode.h\"\n#include \"soc15_common.h\"\n#include \"psp_v3_1.h\"\n\n#include \"mp/mp_9_0_offset.h\"\n#include \"mp/mp_9_0_sh_mask.h\"\n#include \"gc/gc_9_0_offset.h\"\n#include \"sdma0/sdma0_4_0_offset.h\"\n#include \"nbio/nbio_6_1_offset.h\"\n\n#include \"oss/osssys_4_0_offset.h\"\n#include \"oss/osssys_4_0_sh_mask.h\"\n\nMODULE_FIRMWARE(\"amdgpu/vega10_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_asd.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_cap.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_asd.bin\");\n\n\n#define smnMP1_FIRMWARE_FLAGS 0x3010028\n\nstatic int psp_v3_1_ring_stop(struct psp_context *psp,\n\t\t\t      enum psp_ring_type ring_type);\n\nstatic int psp_v3_1_init_microcode(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar ucode_prefix[30];\n\tint err = 0;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tamdgpu_ucode_ip_version_decode(adev, MP0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\tif (err)\n\t\treturn err;\n\n\terr = psp_init_asd_microcode(psp, ucode_prefix);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int psp_v3_1_bootloader_load_sysdrv(struct psp_context *psp)\n{\n\tint ret;\n\tuint32_t psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t sol_reg;\n\n\t \n\tsol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);\n\tif (sol_reg)\n\t\treturn 0;\n\n\t \n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t   0x80000000, 0x80000000, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpsp_copy_fw(psp, psp->sys.start_addr, psp->sys.size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = PSP_BL__LOAD_SYSDRV;\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\t \n\tmdelay(20);\n\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t   0x80000000, 0x80000000, false);\n\n\treturn ret;\n}\n\nstatic int psp_v3_1_bootloader_load_sos(struct psp_context *psp)\n{\n\tint ret;\n\tunsigned int psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t sol_reg;\n\n\t \n\tsol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);\n\tif (sol_reg)\n\t\treturn 0;\n\n\t \n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_35),\n\t\t\t   0x80000000, 0x80000000, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpsp_copy_fw(psp, psp->sos.start_addr, psp->sos.size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = PSP_BL__LOAD_SOSDRV;\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\t \n\tmdelay(20);\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_81),\n\t\t\t   RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81),\n\t\t\t   0, true);\n\treturn ret;\n}\n\nstatic void psp_v3_1_reroute_ih(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t tmp;\n\n\t \n\ttmp = REG_SET_FIELD(0, IH_CLIENT_CFG_DATA, CREDIT_RETURN_ADDR, 0x1244b);\n\ttmp = REG_SET_FIELD(tmp, IH_CLIENT_CFG_DATA, CLIENT_TYPE, 1);\n\ttmp = REG_SET_FIELD(tmp, IH_CLIENT_CFG_DATA, RING_ID, 1);\n\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_69, 3);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_70, tmp);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64, GFX_CTRL_CMD_ID_GBR_IH_SET);\n\n\tmdelay(20);\n\tpsp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t     0x80000000, 0x8000FFFF, false);\n\n\t \n\ttmp = REG_SET_FIELD(0, IH_CLIENT_CFG_DATA, CREDIT_RETURN_ADDR, 0x1216b);\n\ttmp = REG_SET_FIELD(tmp, IH_CLIENT_CFG_DATA, RING_ID, 1);\n\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_69, 4);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_70, tmp);\n\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64, GFX_CTRL_CMD_ID_GBR_IH_SET);\n\n\tmdelay(20);\n\tpsp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t     0x80000000, 0x8000FFFF, false);\n}\n\nstatic int psp_v3_1_ring_create(struct psp_context *psp,\n\t\t\t\tenum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tunsigned int psp_ring_reg = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tpsp_v3_1_reroute_ih(psp);\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tring->ring_wptr = 0;\n\t\tret = psp_v3_1_ring_stop(psp, ring_type);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"psp_v3_1_ring_stop_sriov failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_102, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_103, psp_ring_reg);\n\t\t \n\t\t \n\t\tpsp_ring_reg = ring_type;\n\t\tpsp_ring_reg = psp_ring_reg << 16;\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101, psp_ring_reg);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0,\n\t\t\t\t\tmmMP0_SMN_C2PMSG_101), 0x80000000,\n\t\t\t\t\t0x8000FFFF, false);\n\t} else {\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_69, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_70, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring->ring_size;\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_71, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring_type;\n\t\tpsp_ring_reg = psp_ring_reg << 16;\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64, psp_ring_reg);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0,\n\t\t\t\t\tmmMP0_SMN_C2PMSG_64), 0x80000000,\n\t\t\t\t\t0x8000FFFF, false);\n\n\t}\n\treturn ret;\n}\n\nstatic int psp_v3_1_ring_stop(struct psp_context *psp,\n\t\t\t      enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101,\n\t\t\t\t     GFX_CTRL_CMD_ID_DESTROY_GPCOM_RING);\n\telse\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_64,\n\t\t\t\t     GFX_CTRL_CMD_ID_DESTROY_RINGS);\n\n\t \n\tmdelay(20);\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\telse\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\n\treturn ret;\n}\n\nstatic int psp_v3_1_ring_destroy(struct psp_context *psp,\n\t\t\t\t enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tret = psp_v3_1_ring_stop(psp, ring_type);\n\tif (ret)\n\t\tDRM_ERROR(\"Fail to stop psp ring\\n\");\n\n\tamdgpu_bo_free_kernel(&adev->firmware.rbuf,\n\t\t\t      &ring->ring_mem_mc_addr,\n\t\t\t      (void **)&ring->ring_mem);\n\n\treturn ret;\n}\n\nstatic bool psp_v3_1_smu_reload_quirk(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t reg;\n\n\treg = RREG32_PCIE(smnMP1_FIRMWARE_FLAGS | 0x03b00000);\n\treturn (reg & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) ? true : false;\n}\n\nstatic int psp_v3_1_mode1_reset(struct psp_context *psp)\n{\n\tint ret;\n\tuint32_t offset;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\toffset = SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_64);\n\n\tret = psp_wait_for(psp, offset, 0x80000000, 0x8000FFFF, false);\n\n\tif (ret) {\n\t\tDRM_INFO(\"psp is not working correctly before mode1 reset!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tWREG32(offset, GFX_CTRL_CMD_ID_MODE1_RST);\n\n\tmsleep(500);\n\n\toffset = SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_33);\n\n\tret = psp_wait_for(psp, offset, 0x80000000, 0x80000000, false);\n\n\tif (ret) {\n\t\tDRM_INFO(\"psp mode 1 reset failed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_INFO(\"psp mode1 reset succeed \\n\");\n\n\treturn 0;\n}\n\nstatic uint32_t psp_v3_1_ring_get_wptr(struct psp_context *psp)\n{\n\tuint32_t data;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tdata = psp->km_ring.ring_wptr;\n\telse\n\t\tdata = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_67);\n\treturn data;\n}\n\nstatic void psp_v3_1_ring_set_wptr(struct psp_context *psp, uint32_t value)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_102, value);\n\t\t \n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_101,\n\t\t\tGFX_CTRL_CMD_ID_CONSUME_CMD);\n\t\tpsp->km_ring.ring_wptr = value;\n\t} else\n\t\tWREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_67, value);\n}\n\nstatic const struct psp_funcs psp_v3_1_funcs = {\n\t.init_microcode = psp_v3_1_init_microcode,\n\t.bootloader_load_sysdrv = psp_v3_1_bootloader_load_sysdrv,\n\t.bootloader_load_sos = psp_v3_1_bootloader_load_sos,\n\t.ring_create = psp_v3_1_ring_create,\n\t.ring_stop = psp_v3_1_ring_stop,\n\t.ring_destroy = psp_v3_1_ring_destroy,\n\t.smu_reload_quirk = psp_v3_1_smu_reload_quirk,\n\t.mode1_reset = psp_v3_1_mode1_reset,\n\t.ring_get_wptr = psp_v3_1_ring_get_wptr,\n\t.ring_set_wptr = psp_v3_1_ring_set_wptr,\n};\n\nvoid psp_v3_1_set_psp_funcs(struct psp_context *psp)\n{\n\tpsp->funcs = &psp_v3_1_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}