{
  "module_name": "uvd_v6_0.c",
  "hash_id": "6f08efc7c9a05d3d63b3b206f2607cc3be397b74d41824fb7ff458983cbfafb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_uvd.h\"\n#include \"vid.h\"\n#include \"uvd/uvd_6_0_d.h\"\n#include \"uvd/uvd_6_0_sh_mask.h\"\n#include \"oss/oss_2_0_d.h\"\n#include \"oss/oss_2_0_sh_mask.h\"\n#include \"smu/smu_7_1_3_d.h\"\n#include \"smu/smu_7_1_3_sh_mask.h\"\n#include \"bif/bif_5_1_d.h\"\n#include \"gmc/gmc_8_1_d.h\"\n#include \"vi.h\"\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n\n \n#define FW_1_130_16 ((1 << 24) | (130 << 16) | (16 << 8))\n\nstatic void uvd_v6_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void uvd_v6_0_set_enc_ring_funcs(struct amdgpu_device *adev);\n\nstatic void uvd_v6_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic int uvd_v6_0_start(struct amdgpu_device *adev);\nstatic void uvd_v6_0_stop(struct amdgpu_device *adev);\nstatic void uvd_v6_0_set_sw_clock_gating(struct amdgpu_device *adev);\nstatic int uvd_v6_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state);\nstatic void uvd_v6_0_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable);\n\n \nstatic inline bool uvd_v6_0_enc_support(struct amdgpu_device *adev)\n{\n\treturn ((adev->asic_type >= CHIP_POLARIS10) &&\n\t\t\t(adev->asic_type <= CHIP_VEGAM) &&\n\t\t\t(!adev->uvd.fw_version || adev->uvd.fw_version >= FW_1_130_16));\n}\n\n \nstatic uint64_t uvd_v6_0_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_RPTR);\n}\n\n \nstatic uint64_t uvd_v6_0_enc_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring == &adev->uvd.inst->ring_enc[0])\n\t\treturn RREG32(mmUVD_RB_RPTR);\n\telse\n\t\treturn RREG32(mmUVD_RB_RPTR2);\n}\n \nstatic uint64_t uvd_v6_0_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_WPTR);\n}\n\n \nstatic uint64_t uvd_v6_0_enc_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring == &adev->uvd.inst->ring_enc[0])\n\t\treturn RREG32(mmUVD_RB_WPTR);\n\telse\n\t\treturn RREG32(mmUVD_RB_WPTR2);\n}\n\n \nstatic void uvd_v6_0_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n}\n\n \nstatic void uvd_v6_0_enc_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring == &adev->uvd.inst->ring_enc[0])\n\t\tWREG32(mmUVD_RB_WPTR,\n\t\t\tlower_32_bits(ring->wptr));\n\telse\n\t\tWREG32(mmUVD_RB_WPTR2,\n\t\t\tlower_32_bits(ring->wptr));\n}\n\n \nstatic int uvd_v6_0_enc_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t rptr;\n\tunsigned i;\n\tint r;\n\n\tr = amdgpu_ring_alloc(ring, 16);\n\tif (r)\n\t\treturn r;\n\n\trptr = amdgpu_ring_get_rptr(ring);\n\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_END);\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (amdgpu_ring_get_rptr(ring) != rptr)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\n \nstatic int uvd_v6_0_enc_get_create_msg(struct amdgpu_ring *ring, uint32_t handle,\n\t\t\t\t       struct amdgpu_bo *bo,\n\t\t\t\t       struct dma_fence **fence)\n{\n\tconst unsigned ib_size_dw = 16;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tstruct dma_fence *f = NULL;\n\tuint64_t addr;\n\tint i, r;\n\n\tr = amdgpu_job_alloc_with_ib(ring->adev, NULL, NULL, ib_size_dw * 4,\n\t\t\t\t     AMDGPU_IB_POOL_DIRECT, &job);\n\tif (r)\n\t\treturn r;\n\n\tib = &job->ibs[0];\n\taddr = amdgpu_bo_gpu_offset(bo);\n\n\tib->length_dw = 0;\n\tib->ptr[ib->length_dw++] = 0x00000018;\n\tib->ptr[ib->length_dw++] = 0x00000001;  \n\tib->ptr[ib->length_dw++] = handle;\n\tib->ptr[ib->length_dw++] = 0x00010000;\n\tib->ptr[ib->length_dw++] = upper_32_bits(addr);\n\tib->ptr[ib->length_dw++] = addr;\n\n\tib->ptr[ib->length_dw++] = 0x00000014;\n\tib->ptr[ib->length_dw++] = 0x00000002;  \n\tib->ptr[ib->length_dw++] = 0x0000001c;\n\tib->ptr[ib->length_dw++] = 0x00000001;\n\tib->ptr[ib->length_dw++] = 0x00000000;\n\n\tib->ptr[ib->length_dw++] = 0x00000008;\n\tib->ptr[ib->length_dw++] = 0x08000001;  \n\n\tfor (i = ib->length_dw; i < ib_size_dw; ++i)\n\t\tib->ptr[i] = 0x0;\n\n\tr = amdgpu_job_submit_direct(job, ring, &f);\n\tif (r)\n\t\tgoto err;\n\n\tif (fence)\n\t\t*fence = dma_fence_get(f);\n\tdma_fence_put(f);\n\treturn 0;\n\nerr:\n\tamdgpu_job_free(job);\n\treturn r;\n}\n\n \nstatic int uvd_v6_0_enc_get_destroy_msg(struct amdgpu_ring *ring,\n\t\t\t\t\tuint32_t handle,\n\t\t\t\t\tstruct amdgpu_bo *bo,\n\t\t\t\t\tstruct dma_fence **fence)\n{\n\tconst unsigned ib_size_dw = 16;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tstruct dma_fence *f = NULL;\n\tuint64_t addr;\n\tint i, r;\n\n\tr = amdgpu_job_alloc_with_ib(ring->adev, NULL, NULL, ib_size_dw * 4,\n\t\t\t\t     AMDGPU_IB_POOL_DIRECT, &job);\n\tif (r)\n\t\treturn r;\n\n\tib = &job->ibs[0];\n\taddr = amdgpu_bo_gpu_offset(bo);\n\n\tib->length_dw = 0;\n\tib->ptr[ib->length_dw++] = 0x00000018;\n\tib->ptr[ib->length_dw++] = 0x00000001;  \n\tib->ptr[ib->length_dw++] = handle;\n\tib->ptr[ib->length_dw++] = 0x00010000;\n\tib->ptr[ib->length_dw++] = upper_32_bits(addr);\n\tib->ptr[ib->length_dw++] = addr;\n\n\tib->ptr[ib->length_dw++] = 0x00000014;\n\tib->ptr[ib->length_dw++] = 0x00000002;  \n\tib->ptr[ib->length_dw++] = 0x0000001c;\n\tib->ptr[ib->length_dw++] = 0x00000001;\n\tib->ptr[ib->length_dw++] = 0x00000000;\n\n\tib->ptr[ib->length_dw++] = 0x00000008;\n\tib->ptr[ib->length_dw++] = 0x08000002;  \n\n\tfor (i = ib->length_dw; i < ib_size_dw; ++i)\n\t\tib->ptr[i] = 0x0;\n\n\tr = amdgpu_job_submit_direct(job, ring, &f);\n\tif (r)\n\t\tgoto err;\n\n\tif (fence)\n\t\t*fence = dma_fence_get(f);\n\tdma_fence_put(f);\n\treturn 0;\n\nerr:\n\tamdgpu_job_free(job);\n\treturn r;\n}\n\n \nstatic int uvd_v6_0_enc_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct dma_fence *fence = NULL;\n\tstruct amdgpu_bo *bo = ring->adev->uvd.ib_bo;\n\tlong r;\n\n\tr = uvd_v6_0_enc_get_create_msg(ring, 1, bo, NULL);\n\tif (r)\n\t\tgoto error;\n\n\tr = uvd_v6_0_enc_get_destroy_msg(ring, 1, bo, &fence);\n\tif (r)\n\t\tgoto error;\n\n\tr = dma_fence_wait_timeout(fence, false, timeout);\n\tif (r == 0)\n\t\tr = -ETIMEDOUT;\n\telse if (r > 0)\n\t\tr = 0;\n\nerror:\n\tdma_fence_put(fence);\n\treturn r;\n}\n\nstatic int uvd_v6_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tadev->uvd.num_uvd_inst = 1;\n\n\tif (!(adev->flags & AMD_IS_APU) &&\n\t    (RREG32_SMC(ixCC_HARVEST_FUSES) & CC_HARVEST_FUSES__UVD_DISABLE_MASK))\n\t\treturn -ENOENT;\n\n\tuvd_v6_0_set_ring_funcs(adev);\n\n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tadev->uvd.num_enc_rings = 2;\n\t\tuvd_v6_0_set_enc_ring_funcs(adev);\n\t}\n\n\tuvd_v6_0_set_irq_funcs(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v6_0_sw_init(void *handle)\n{\n\tstruct amdgpu_ring *ring;\n\tint i, r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_UVD_SYSTEM_MESSAGE, &adev->uvd.inst->irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i) {\n\t\t\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, i + VISLANDS30_IV_SRCID_UVD_ENC_GEN_PURP, &adev->uvd.inst->irq);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = amdgpu_uvd_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (!uvd_v6_0_enc_support(adev)) {\n\t\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i)\n\t\t\tadev->uvd.inst->ring_enc[i].funcs = NULL;\n\n\t\tadev->uvd.inst->irq.num_types = 1;\n\t\tadev->uvd.num_enc_rings = 0;\n\n\t\tDRM_INFO(\"UVD ENC is disabled\\n\");\n\t}\n\n\tring = &adev->uvd.inst->ring;\n\tsprintf(ring->name, \"uvd\");\n\tr = amdgpu_ring_init(adev, ring, 512, &adev->uvd.inst->irq, 0,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i) {\n\t\t\tring = &adev->uvd.inst->ring_enc[i];\n\t\t\tsprintf(ring->name, \"uvd_enc%d\", i);\n\t\t\tr = amdgpu_ring_init(adev, ring, 512,\n\t\t\t\t\t     &adev->uvd.inst->irq, 0,\n\t\t\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = amdgpu_uvd_entity_init(adev);\n\n\treturn r;\n}\n\nstatic int uvd_v6_0_sw_fini(void *handle)\n{\n\tint i, r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_suspend(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i)\n\t\t\tamdgpu_ring_fini(&adev->uvd.inst->ring_enc[i]);\n\t}\n\n\treturn amdgpu_uvd_sw_fini(adev);\n}\n\n \nstatic int uvd_v6_0_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t tmp;\n\tint i, r;\n\n\tamdgpu_asic_set_uvd_clocks(adev, 10000, 10000);\n\tuvd_v6_0_set_clockgating_state(adev, AMD_CG_STATE_UNGATE);\n\tuvd_v6_0_enable_mgcg(adev, true);\n\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\tgoto done;\n\n\tr = amdgpu_ring_alloc(ring, 10);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: ring failed to lock UVD ring (%d).\\n\", r);\n\t\tgoto done;\n\t}\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\t \n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_TIMEOUT_STATUS, 0));\n\tamdgpu_ring_write(ring, 0x8);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_CNTL, 0));\n\tamdgpu_ring_write(ring, 3);\n\n\tamdgpu_ring_commit(ring);\n\n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i) {\n\t\t\tring = &adev->uvd.inst->ring_enc[i];\n\t\t\tr = amdgpu_ring_test_helper(ring);\n\t\t\tif (r)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tif (!r) {\n\t\tif (uvd_v6_0_enc_support(adev))\n\t\t\tDRM_INFO(\"UVD and UVD ENC initialized successfully.\\n\");\n\t\telse\n\t\t\tDRM_INFO(\"UVD initialized successfully.\\n\");\n\t}\n\n\treturn r;\n}\n\n \nstatic int uvd_v6_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (RREG32(mmUVD_STATUS) != 0)\n\t\tuvd_v6_0_stop(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v6_0_suspend(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (adev->pm.dpm_enabled) {\n\t\tamdgpu_dpm_enable_uvd(adev, false);\n\t} else {\n\t\tamdgpu_asic_set_uvd_clocks(adev, 0, 0);\n\t\t \n\t\tamdgpu_device_ip_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_PG_STATE_GATE);\n\t\tamdgpu_device_ip_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_CG_STATE_GATE);\n\t}\n\n\tr = uvd_v6_0_hw_fini(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn amdgpu_uvd_suspend(adev);\n}\n\nstatic int uvd_v6_0_resume(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn uvd_v6_0_hw_init(adev);\n}\n\n \nstatic void uvd_v6_0_mc_resume(struct amdgpu_device *adev)\n{\n\tuint64_t offset;\n\tuint32_t size;\n\n\t \n\tWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_LOW,\n\t\t\tlower_32_bits(adev->uvd.inst->gpu_addr));\n\tWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_HIGH,\n\t\t\tupper_32_bits(adev->uvd.inst->gpu_addr));\n\n\toffset = AMDGPU_UVD_FIRMWARE_OFFSET;\n\tsize = AMDGPU_UVD_FIRMWARE_SIZE(adev);\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET0, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE0, size);\n\n\toffset += size;\n\tsize = AMDGPU_UVD_HEAP_SIZE;\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET1, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE1, size);\n\n\toffset += size;\n\tsize = AMDGPU_UVD_STACK_SIZE +\n\t       (AMDGPU_UVD_SESSION_SIZE * adev->uvd.max_handles);\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET2, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE2, size);\n\n\tWREG32(mmUVD_UDEC_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DBW_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\n\tWREG32(mmUVD_GP_SCRATCH4, adev->uvd.max_handles);\n}\n\n#if 0\nstatic void cz_set_uvd_clock_gating_branches(struct amdgpu_device *adev,\n\t\tbool enable)\n{\n\tu32 data, data1;\n\n\tdata = RREG32(mmUVD_CGC_GATE);\n\tdata1 = RREG32(mmUVD_SUVD_CGC_GATE);\n\tif (enable) {\n\t\tdata |= UVD_CGC_GATE__SYS_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MASK |\n\t\t\t\tUVD_CGC_GATE__MPEG2_MASK |\n\t\t\t\tUVD_CGC_GATE__RBC_MASK |\n\t\t\t\tUVD_CGC_GATE__LMI_MC_MASK |\n\t\t\t\tUVD_CGC_GATE__IDCT_MASK |\n\t\t\t\tUVD_CGC_GATE__MPRD_MASK |\n\t\t\t\tUVD_CGC_GATE__MPC_MASK |\n\t\t\t\tUVD_CGC_GATE__LBSI_MASK |\n\t\t\t\tUVD_CGC_GATE__LRBBM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_RE_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_CM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_IT_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_DB_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MP_MASK |\n\t\t\t\tUVD_CGC_GATE__WCB_MASK |\n\t\t\t\tUVD_CGC_GATE__VCPU_MASK |\n\t\t\t\tUVD_CGC_GATE__SCPU_MASK;\n\t\tdata1 |= UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SRE_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SRE_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_HEVC_MASK;\n\t} else {\n\t\tdata &= ~(UVD_CGC_GATE__SYS_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MASK |\n\t\t\t\tUVD_CGC_GATE__MPEG2_MASK |\n\t\t\t\tUVD_CGC_GATE__RBC_MASK |\n\t\t\t\tUVD_CGC_GATE__LMI_MC_MASK |\n\t\t\t\tUVD_CGC_GATE__LMI_UMC_MASK |\n\t\t\t\tUVD_CGC_GATE__IDCT_MASK |\n\t\t\t\tUVD_CGC_GATE__MPRD_MASK |\n\t\t\t\tUVD_CGC_GATE__MPC_MASK |\n\t\t\t\tUVD_CGC_GATE__LBSI_MASK |\n\t\t\t\tUVD_CGC_GATE__LRBBM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_RE_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_CM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_IT_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_DB_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MP_MASK |\n\t\t\t\tUVD_CGC_GATE__WCB_MASK |\n\t\t\t\tUVD_CGC_GATE__VCPU_MASK |\n\t\t\t\tUVD_CGC_GATE__SCPU_MASK);\n\t\tdata1 &= ~(UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SRE_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SRE_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_HEVC_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_H264_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_HEVC_MASK);\n\t}\n\tWREG32(mmUVD_CGC_GATE, data);\n\tWREG32(mmUVD_SUVD_CGC_GATE, data1);\n}\n#endif\n\n \nstatic int uvd_v6_0_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t rb_bufsz, tmp;\n\tuint32_t lmi_swap_cntl;\n\tuint32_t mp_swap_cntl;\n\tint i, j, r;\n\n\t \n\tWREG32_P(mmUVD_POWER_STATUS, 0, ~UVD_POWER_STATUS__UVD_PG_MODE_MASK);\n\n\t \n\tlmi_swap_cntl = 0;\n\tmp_swap_cntl = 0;\n\n\tuvd_v6_0_mc_resume(adev);\n\n\t \n\tWREG32_FIELD(UVD_MASTINT_EN, VCPU_EN, 0);\n\n\t \n\tWREG32_FIELD(UVD_LMI_CTRL2, STALL_ARB_UMC, 1);\n\tmdelay(1);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET,\n\t\tUVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LBSI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__RBC_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__CSM_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__CXW_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__TAP_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32_FIELD(SRBM_SOFT_RESET, SOFT_RESET_UVD, 0);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_LMI_CTRL,\n\t\t(0x40 << UVD_LMI_CTRL__WRITE_CLEAN_TIMER__SHIFT) |\n\t\tUVD_LMI_CTRL__WRITE_CLEAN_TIMER_EN_MASK |\n\t\tUVD_LMI_CTRL__DATA_COHERENCY_EN_MASK |\n\t\tUVD_LMI_CTRL__VCPU_DATA_COHERENCY_EN_MASK |\n\t\tUVD_LMI_CTRL__REQ_MODE_MASK |\n\t\tUVD_LMI_CTRL__DISABLE_ON_FWV_FAIL_MASK);\n\n#ifdef __BIG_ENDIAN\n\t \n\tlmi_swap_cntl = 0xa;\n\tmp_swap_cntl = 0;\n#endif\n\tWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\n\tWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\n\n\tWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\n\tWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\n\tWREG32(mmUVD_MPC_SET_ALU, 0);\n\tWREG32(mmUVD_MPC_SET_MUX, 0x88);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_VCPU_CNTL, UVD_VCPU_CNTL__CLK_EN_MASK);\n\n\t \n\tWREG32_FIELD(UVD_LMI_CTRL2, STALL_ARB_UMC, 0);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, 0);\n\tmdelay(10);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR(\"UVD not responding, trying to reset the VCPU!!!\\n\");\n\t\tWREG32_FIELD(UVD_SOFT_RESET, VCPU_SOFT_RESET, 1);\n\t\tmdelay(10);\n\t\tWREG32_FIELD(UVD_SOFT_RESET, VCPU_SOFT_RESET, 0);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\tif (r) {\n\t\tDRM_ERROR(\"UVD not responding, giving up!!!\\n\");\n\t\treturn r;\n\t}\n\t \n\tWREG32_P(mmUVD_MASTINT_EN,\n\t\t(UVD_MASTINT_EN__VCPU_EN_MASK|UVD_MASTINT_EN__SYS_EN_MASK),\n\t\t~(UVD_MASTINT_EN__VCPU_EN_MASK|UVD_MASTINT_EN__SYS_EN_MASK));\n\n\t \n\tWREG32_P(mmUVD_STATUS, 0, ~(2 << UVD_STATUS__VCPU_REPORT__SHIFT));\n\n\t \n\trb_bufsz = order_base_2(ring->ring_size);\n\ttmp = REG_SET_FIELD(0, UVD_RBC_RB_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_BLKSZ, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_FETCH, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_WPTR_POLL_EN, 0);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_UPDATE, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_RPTR_WR_EN, 1);\n\tWREG32(mmUVD_RBC_RB_CNTL, tmp);\n\n\t \n\tWREG32(mmUVD_RBC_RB_WPTR_CNTL, 0);\n\n\t \n\tWREG32(mmUVD_RBC_RB_RPTR_ADDR, (upper_32_bits(ring->gpu_addr) >> 2));\n\n\t \n\tWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_LOW,\n\t\t\tlower_32_bits(ring->gpu_addr));\n\tWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_HIGH,\n\t\t\tupper_32_bits(ring->gpu_addr));\n\n\t \n\tWREG32(mmUVD_RBC_RB_RPTR, 0);\n\n\tring->wptr = RREG32(mmUVD_RBC_RB_RPTR);\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n\n\tWREG32_FIELD(UVD_RBC_RB_CNTL, RB_NO_FETCH, 0);\n\n\tif (uvd_v6_0_enc_support(adev)) {\n\t\tring = &adev->uvd.inst->ring_enc[0];\n\t\tWREG32(mmUVD_RB_RPTR, lower_32_bits(ring->wptr));\n\t\tWREG32(mmUVD_RB_WPTR, lower_32_bits(ring->wptr));\n\t\tWREG32(mmUVD_RB_BASE_LO, ring->gpu_addr);\n\t\tWREG32(mmUVD_RB_BASE_HI, upper_32_bits(ring->gpu_addr));\n\t\tWREG32(mmUVD_RB_SIZE, ring->ring_size / 4);\n\n\t\tring = &adev->uvd.inst->ring_enc[1];\n\t\tWREG32(mmUVD_RB_RPTR2, lower_32_bits(ring->wptr));\n\t\tWREG32(mmUVD_RB_WPTR2, lower_32_bits(ring->wptr));\n\t\tWREG32(mmUVD_RB_BASE_LO2, ring->gpu_addr);\n\t\tWREG32(mmUVD_RB_BASE_HI2, upper_32_bits(ring->gpu_addr));\n\t\tWREG32(mmUVD_RB_SIZE2, ring->ring_size / 4);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void uvd_v6_0_stop(struct amdgpu_device *adev)\n{\n\t \n\tWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\tmdelay(1);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_VCPU_CNTL, 0x0);\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\n\n\tWREG32(mmUVD_STATUS, 0);\n}\n\n \nstatic void uvd_v6_0_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\n\t\t\t\t     unsigned flags)\n{\n\tWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, addr & 0xffffffff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr) & 0xff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 2);\n}\n\n \nstatic void uvd_v6_0_enc_ring_emit_fence(struct amdgpu_ring *ring, u64 addr,\n\t\t\tu64 seq, unsigned flags)\n{\n\tWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_FENCE);\n\tamdgpu_ring_write(ring, addr);\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_TRAP);\n}\n\n \nstatic void uvd_v6_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\n{\n\t \n}\n\n \nstatic int uvd_v6_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(mmUVD_CONTEXT_ID, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(mmUVD_CONTEXT_ID);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\n \nstatic void uvd_v6_0_ring_emit_ib(struct amdgpu_ring *ring,\n\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t  uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_VMID, 0));\n\tamdgpu_ring_write(ring, vmid);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_LOW, 0));\n\tamdgpu_ring_write(ring, lower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_HIGH, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_SIZE, 0));\n\tamdgpu_ring_write(ring, ib->length_dw);\n}\n\n \nstatic void uvd_v6_0_enc_ring_emit_ib(struct amdgpu_ring *ring,\n\t\t\t\t\tstruct amdgpu_job *job,\n\t\t\t\t\tstruct amdgpu_ib *ib,\n\t\t\t\t\tuint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_IB_VM);\n\tamdgpu_ring_write(ring, vmid);\n\tamdgpu_ring_write(ring, lower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, ib->length_dw);\n}\n\nstatic void uvd_v6_0_ring_emit_wreg(struct amdgpu_ring *ring,\n\t\t\t\t    uint32_t reg, uint32_t val)\n{\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, reg << 2);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, val);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0x8);\n}\n\nstatic void uvd_v6_0_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned vmid, uint64_t pd_addr)\n{\n\tamdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, mmVM_INVALIDATE_REQUEST << 2);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GP_SCRATCH8, 0));\n\tamdgpu_ring_write(ring, 1 << vmid);  \n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0xC);\n}\n\nstatic void uvd_v6_0_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GP_SCRATCH8, 0));\n\tamdgpu_ring_write(ring, 0xffffffff);  \n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GP_SCRATCH9, 0));\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0xE);\n}\n\nstatic void uvd_v6_0_ring_insert_nop(struct amdgpu_ring *ring, uint32_t count)\n{\n\tint i;\n\n\tWARN_ON(ring->wptr % 2 || count % 2);\n\n\tfor (i = 0; i < count / 2; i++) {\n\t\tamdgpu_ring_write(ring, PACKET0(mmUVD_NO_OP, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\nstatic void uvd_v6_0_enc_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_WAIT_GE);\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, seq);\n}\n\nstatic void uvd_v6_0_enc_ring_insert_end(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_END);\n}\n\nstatic void uvd_v6_0_enc_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\t    unsigned int vmid, uint64_t pd_addr)\n{\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_UPDATE_PTB);\n\tamdgpu_ring_write(ring, vmid);\n\tamdgpu_ring_write(ring, pd_addr >> 12);\n\n\tamdgpu_ring_write(ring, HEVC_ENC_CMD_FLUSH_TLB);\n\tamdgpu_ring_write(ring, vmid);\n}\n\nstatic bool uvd_v6_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);\n}\n\nstatic int uvd_v6_0_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (uvd_v6_0_is_idle(handle))\n\t\t\treturn 0;\n\t}\n\treturn -ETIMEDOUT;\n}\n\n#define AMDGPU_UVD_STATUS_BUSY_MASK    0xfd\nstatic bool uvd_v6_0_check_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 srbm_soft_reset = 0;\n\tu32 tmp = RREG32(mmSRBM_STATUS);\n\n\tif (REG_GET_FIELD(tmp, SRBM_STATUS, UVD_RQ_PENDING) ||\n\t    REG_GET_FIELD(tmp, SRBM_STATUS, UVD_BUSY) ||\n\t    (RREG32(mmUVD_STATUS) & AMDGPU_UVD_STATUS_BUSY_MASK))\n\t\tsrbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET, SOFT_RESET_UVD, 1);\n\n\tif (srbm_soft_reset) {\n\t\tadev->uvd.inst->srbm_soft_reset = srbm_soft_reset;\n\t\treturn true;\n\t} else {\n\t\tadev->uvd.inst->srbm_soft_reset = 0;\n\t\treturn false;\n\t}\n}\n\nstatic int uvd_v6_0_pre_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!adev->uvd.inst->srbm_soft_reset)\n\t\treturn 0;\n\n\tuvd_v6_0_stop(adev);\n\treturn 0;\n}\n\nstatic int uvd_v6_0_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 srbm_soft_reset;\n\n\tif (!adev->uvd.inst->srbm_soft_reset)\n\t\treturn 0;\n\tsrbm_soft_reset = adev->uvd.inst->srbm_soft_reset;\n\n\tif (srbm_soft_reset) {\n\t\tu32 tmp;\n\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(adev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(mmSRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(mmSRBM_SOFT_RESET);\n\n\t\t \n\t\tudelay(50);\n\t}\n\n\treturn 0;\n}\n\nstatic int uvd_v6_0_post_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!adev->uvd.inst->srbm_soft_reset)\n\t\treturn 0;\n\n\tmdelay(5);\n\n\treturn uvd_v6_0_start(adev);\n}\n\nstatic int uvd_v6_0_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\t \n\treturn 0;\n}\n\nstatic int uvd_v6_0_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tbool int_handled = true;\n\tDRM_DEBUG(\"IH: UVD TRAP\\n\");\n\n\tswitch (entry->src_id) {\n\tcase 124:\n\t\tamdgpu_fence_process(&adev->uvd.inst->ring);\n\t\tbreak;\n\tcase 119:\n\t\tif (likely(uvd_v6_0_enc_support(adev)))\n\t\t\tamdgpu_fence_process(&adev->uvd.inst->ring_enc[0]);\n\t\telse\n\t\t\tint_handled = false;\n\t\tbreak;\n\tcase 120:\n\t\tif (likely(uvd_v6_0_enc_support(adev)))\n\t\t\tamdgpu_fence_process(&adev->uvd.inst->ring_enc[1]);\n\t\telse\n\t\t\tint_handled = false;\n\t\tbreak;\n\t}\n\n\tif (!int_handled)\n\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t  entry->src_id, entry->src_data[0]);\n\n\treturn 0;\n}\n\nstatic void uvd_v6_0_enable_clock_gating(struct amdgpu_device *adev, bool enable)\n{\n\tuint32_t data1, data3;\n\n\tdata1 = RREG32(mmUVD_SUVD_CGC_GATE);\n\tdata3 = RREG32(mmUVD_CGC_GATE);\n\n\tdata1 |= UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SDB_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SRE_H264_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SRE_HEVC_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SIT_H264_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SIT_HEVC_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SCM_H264_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SCM_HEVC_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SDB_H264_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SDB_HEVC_MASK;\n\n\tif (enable) {\n\t\tdata3 |= (UVD_CGC_GATE__SYS_MASK       |\n\t\t\tUVD_CGC_GATE__UDEC_MASK      |\n\t\t\tUVD_CGC_GATE__MPEG2_MASK     |\n\t\t\tUVD_CGC_GATE__RBC_MASK       |\n\t\t\tUVD_CGC_GATE__LMI_MC_MASK    |\n\t\t\tUVD_CGC_GATE__LMI_UMC_MASK   |\n\t\t\tUVD_CGC_GATE__IDCT_MASK      |\n\t\t\tUVD_CGC_GATE__MPRD_MASK      |\n\t\t\tUVD_CGC_GATE__MPC_MASK       |\n\t\t\tUVD_CGC_GATE__LBSI_MASK      |\n\t\t\tUVD_CGC_GATE__LRBBM_MASK     |\n\t\t\tUVD_CGC_GATE__UDEC_RE_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_CM_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_IT_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_DB_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_MP_MASK   |\n\t\t\tUVD_CGC_GATE__WCB_MASK       |\n\t\t\tUVD_CGC_GATE__JPEG_MASK      |\n\t\t\tUVD_CGC_GATE__SCPU_MASK      |\n\t\t\tUVD_CGC_GATE__JPEG2_MASK);\n\t\t \n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\n\t\t\tdata3 |= UVD_CGC_GATE__VCPU_MASK;\n\n\t\tdata3 &= ~UVD_CGC_GATE__REGS_MASK;\n\t} else {\n\t\tdata3 = 0;\n\t}\n\n\tWREG32(mmUVD_SUVD_CGC_GATE, data1);\n\tWREG32(mmUVD_CGC_GATE, data3);\n}\n\nstatic void uvd_v6_0_set_sw_clock_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data, data2;\n\n\tdata = RREG32(mmUVD_CGC_CTRL);\n\tdata2 = RREG32(mmUVD_SUVD_CGC_CTRL);\n\n\n\tdata &= ~(UVD_CGC_CTRL__CLK_OFF_DELAY_MASK |\n\t\t  UVD_CGC_CTRL__CLK_GATE_DLY_TIMER_MASK);\n\n\n\tdata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK |\n\t\t(1 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_GATE_DLY_TIMER)) |\n\t\t(4 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_OFF_DELAY));\n\n\tdata &= ~(UVD_CGC_CTRL__UDEC_RE_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_CM_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_IT_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_DB_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_MP_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__SYS_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPEG2_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__REGS_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__RBC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LMI_MC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LMI_UMC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__IDCT_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPRD_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LBSI_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LRBBM_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__WCB_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__VCPU_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__JPEG_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__SCPU_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__JPEG2_MODE_MASK);\n\tdata2 &= ~(UVD_SUVD_CGC_CTRL__SRE_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SIT_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SMP_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SCM_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SDB_MODE_MASK);\n\n\tWREG32(mmUVD_CGC_CTRL, data);\n\tWREG32(mmUVD_SUVD_CGC_CTRL, data2);\n}\n\n#if 0\nstatic void uvd_v6_0_set_hw_clock_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data, data1, cgc_flags, suvd_flags;\n\n\tdata = RREG32(mmUVD_CGC_GATE);\n\tdata1 = RREG32(mmUVD_SUVD_CGC_GATE);\n\n\tcgc_flags = UVD_CGC_GATE__SYS_MASK |\n\t\tUVD_CGC_GATE__UDEC_MASK |\n\t\tUVD_CGC_GATE__MPEG2_MASK |\n\t\tUVD_CGC_GATE__RBC_MASK |\n\t\tUVD_CGC_GATE__LMI_MC_MASK |\n\t\tUVD_CGC_GATE__IDCT_MASK |\n\t\tUVD_CGC_GATE__MPRD_MASK |\n\t\tUVD_CGC_GATE__MPC_MASK |\n\t\tUVD_CGC_GATE__LBSI_MASK |\n\t\tUVD_CGC_GATE__LRBBM_MASK |\n\t\tUVD_CGC_GATE__UDEC_RE_MASK |\n\t\tUVD_CGC_GATE__UDEC_CM_MASK |\n\t\tUVD_CGC_GATE__UDEC_IT_MASK |\n\t\tUVD_CGC_GATE__UDEC_DB_MASK |\n\t\tUVD_CGC_GATE__UDEC_MP_MASK |\n\t\tUVD_CGC_GATE__WCB_MASK |\n\t\tUVD_CGC_GATE__VCPU_MASK |\n\t\tUVD_CGC_GATE__SCPU_MASK |\n\t\tUVD_CGC_GATE__JPEG_MASK |\n\t\tUVD_CGC_GATE__JPEG2_MASK;\n\n\tsuvd_flags = UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_MASK;\n\n\tdata |= cgc_flags;\n\tdata1 |= suvd_flags;\n\n\tWREG32(mmUVD_CGC_GATE, data);\n\tWREG32(mmUVD_SUVD_CGC_GATE, data1);\n}\n#endif\n\nstatic void uvd_v6_0_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_UVD_MGCG)) {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata |= 0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t} else {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata &= ~0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata &= ~UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t}\n}\n\nstatic int uvd_v6_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_CG_STATE_GATE);\n\n\tif (enable) {\n\t\t \n\t\tif (uvd_v6_0_wait_for_idle(handle))\n\t\t\treturn -EBUSY;\n\t\tuvd_v6_0_enable_clock_gating(adev, true);\n\t\t \n \n\t} else {\n\t\t \n\t\tuvd_v6_0_enable_clock_gating(adev, false);\n\t}\n\tuvd_v6_0_set_sw_clock_gating(adev);\n\treturn 0;\n}\n\nstatic int uvd_v6_0_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\t \n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint ret = 0;\n\n\tWREG32(mmUVD_POWER_STATUS, UVD_POWER_STATUS__UVD_PG_EN_MASK);\n\n\tif (state == AMD_PG_STATE_GATE) {\n\t\tuvd_v6_0_stop(adev);\n\t} else {\n\t\tret = uvd_v6_0_start(adev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void uvd_v6_0_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint data;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tif (adev->flags & AMD_IS_APU)\n\t\tdata = RREG32_SMC(ixCURRENT_PG_STATUS_APU);\n\telse\n\t\tdata = RREG32_SMC(ixCURRENT_PG_STATUS);\n\n\tif (data & CURRENT_PG_STATUS__UVD_PG_STATUS_MASK) {\n\t\tDRM_INFO(\"Cannot get clockgating state when UVD is powergated.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tdata = RREG32(mmUVD_CGC_CTRL);\n\tif (data & UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_UVD_MGCG;\n\nout:\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nstatic const struct amd_ip_funcs uvd_v6_0_ip_funcs = {\n\t.name = \"uvd_v6_0\",\n\t.early_init = uvd_v6_0_early_init,\n\t.late_init = NULL,\n\t.sw_init = uvd_v6_0_sw_init,\n\t.sw_fini = uvd_v6_0_sw_fini,\n\t.hw_init = uvd_v6_0_hw_init,\n\t.hw_fini = uvd_v6_0_hw_fini,\n\t.suspend = uvd_v6_0_suspend,\n\t.resume = uvd_v6_0_resume,\n\t.is_idle = uvd_v6_0_is_idle,\n\t.wait_for_idle = uvd_v6_0_wait_for_idle,\n\t.check_soft_reset = uvd_v6_0_check_soft_reset,\n\t.pre_soft_reset = uvd_v6_0_pre_soft_reset,\n\t.soft_reset = uvd_v6_0_soft_reset,\n\t.post_soft_reset = uvd_v6_0_post_soft_reset,\n\t.set_clockgating_state = uvd_v6_0_set_clockgating_state,\n\t.set_powergating_state = uvd_v6_0_set_powergating_state,\n\t.get_clockgating_state = uvd_v6_0_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ring_funcs uvd_v6_0_ring_phys_funcs = {\n\t.type = AMDGPU_RING_TYPE_UVD,\n\t.align_mask = 0xf,\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.get_rptr = uvd_v6_0_ring_get_rptr,\n\t.get_wptr = uvd_v6_0_ring_get_wptr,\n\t.set_wptr = uvd_v6_0_ring_set_wptr,\n\t.parse_cs = amdgpu_uvd_ring_parse_cs,\n\t.emit_frame_size =\n\t\t6 +  \n\t\t10 +  \n\t\t14,  \n\t.emit_ib_size = 8,  \n\t.emit_ib = uvd_v6_0_ring_emit_ib,\n\t.emit_fence = uvd_v6_0_ring_emit_fence,\n\t.emit_hdp_flush = uvd_v6_0_ring_emit_hdp_flush,\n\t.test_ring = uvd_v6_0_ring_test_ring,\n\t.test_ib = amdgpu_uvd_ring_test_ib,\n\t.insert_nop = uvd_v6_0_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_uvd_ring_begin_use,\n\t.end_use = amdgpu_uvd_ring_end_use,\n\t.emit_wreg = uvd_v6_0_ring_emit_wreg,\n};\n\nstatic const struct amdgpu_ring_funcs uvd_v6_0_ring_vm_funcs = {\n\t.type = AMDGPU_RING_TYPE_UVD,\n\t.align_mask = 0xf,\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.get_rptr = uvd_v6_0_ring_get_rptr,\n\t.get_wptr = uvd_v6_0_ring_get_wptr,\n\t.set_wptr = uvd_v6_0_ring_set_wptr,\n\t.emit_frame_size =\n\t\t6 +  \n\t\t10 +  \n\t\tVI_FLUSH_GPU_TLB_NUM_WREG * 6 + 8 +  \n\t\t14 + 14,  \n\t.emit_ib_size = 8,  \n\t.emit_ib = uvd_v6_0_ring_emit_ib,\n\t.emit_fence = uvd_v6_0_ring_emit_fence,\n\t.emit_vm_flush = uvd_v6_0_ring_emit_vm_flush,\n\t.emit_pipeline_sync = uvd_v6_0_ring_emit_pipeline_sync,\n\t.emit_hdp_flush = uvd_v6_0_ring_emit_hdp_flush,\n\t.test_ring = uvd_v6_0_ring_test_ring,\n\t.test_ib = amdgpu_uvd_ring_test_ib,\n\t.insert_nop = uvd_v6_0_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_uvd_ring_begin_use,\n\t.end_use = amdgpu_uvd_ring_end_use,\n\t.emit_wreg = uvd_v6_0_ring_emit_wreg,\n};\n\nstatic const struct amdgpu_ring_funcs uvd_v6_0_enc_ring_vm_funcs = {\n\t.type = AMDGPU_RING_TYPE_UVD_ENC,\n\t.align_mask = 0x3f,\n\t.nop = HEVC_ENC_CMD_NO_OP,\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.get_rptr = uvd_v6_0_enc_ring_get_rptr,\n\t.get_wptr = uvd_v6_0_enc_ring_get_wptr,\n\t.set_wptr = uvd_v6_0_enc_ring_set_wptr,\n\t.emit_frame_size =\n\t\t4 +  \n\t\t5 +  \n\t\t5 + 5 +  \n\t\t1,  \n\t.emit_ib_size = 5,  \n\t.emit_ib = uvd_v6_0_enc_ring_emit_ib,\n\t.emit_fence = uvd_v6_0_enc_ring_emit_fence,\n\t.emit_vm_flush = uvd_v6_0_enc_ring_emit_vm_flush,\n\t.emit_pipeline_sync = uvd_v6_0_enc_ring_emit_pipeline_sync,\n\t.test_ring = uvd_v6_0_enc_ring_test_ring,\n\t.test_ib = uvd_v6_0_enc_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.insert_end = uvd_v6_0_enc_ring_insert_end,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_uvd_ring_begin_use,\n\t.end_use = amdgpu_uvd_ring_end_use,\n};\n\nstatic void uvd_v6_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tif (adev->asic_type >= CHIP_POLARIS10) {\n\t\tadev->uvd.inst->ring.funcs = &uvd_v6_0_ring_vm_funcs;\n\t\tDRM_INFO(\"UVD is enabled in VM mode\\n\");\n\t} else {\n\t\tadev->uvd.inst->ring.funcs = &uvd_v6_0_ring_phys_funcs;\n\t\tDRM_INFO(\"UVD is enabled in physical mode\\n\");\n\t}\n}\n\nstatic void uvd_v6_0_set_enc_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->uvd.num_enc_rings; ++i)\n\t\tadev->uvd.inst->ring_enc[i].funcs = &uvd_v6_0_enc_ring_vm_funcs;\n\n\tDRM_INFO(\"UVD ENC is enabled in VM mode\\n\");\n}\n\nstatic const struct amdgpu_irq_src_funcs uvd_v6_0_irq_funcs = {\n\t.set = uvd_v6_0_set_interrupt_state,\n\t.process = uvd_v6_0_process_interrupt,\n};\n\nstatic void uvd_v6_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tif (uvd_v6_0_enc_support(adev))\n\t\tadev->uvd.inst->irq.num_types = adev->uvd.num_enc_rings + 1;\n\telse\n\t\tadev->uvd.inst->irq.num_types = 1;\n\n\tadev->uvd.inst->irq.funcs = &uvd_v6_0_irq_funcs;\n}\n\nconst struct amdgpu_ip_block_version uvd_v6_0_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_UVD,\n\t\t.major = 6,\n\t\t.minor = 0,\n\t\t.rev = 0,\n\t\t.funcs = &uvd_v6_0_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version uvd_v6_2_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_UVD,\n\t\t.major = 6,\n\t\t.minor = 2,\n\t\t.rev = 0,\n\t\t.funcs = &uvd_v6_0_ip_funcs,\n};\n\nconst struct amdgpu_ip_block_version uvd_v6_3_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_UVD,\n\t\t.major = 6,\n\t\t.minor = 3,\n\t\t.rev = 0,\n\t\t.funcs = &uvd_v6_0_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}