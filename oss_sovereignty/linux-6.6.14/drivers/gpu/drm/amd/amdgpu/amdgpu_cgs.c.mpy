{
  "module_name": "amdgpu_cgs.c",
  "hash_id": "000a1ccc1be68025d4540f45b43682ebb0e2c76eb89e4d5e1a1afcdc2de3454b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c",
  "human_readable_source": " \n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/firmware.h>\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"amdgpu_ucode.h\"\n\nstruct amdgpu_cgs_device {\n\tstruct cgs_device base;\n\tstruct amdgpu_device *adev;\n};\n\n#define CGS_FUNC_ADEV\t\t\t\t\t\t\t\\\n\tstruct amdgpu_device *adev =\t\t\t\t\t\\\n\t\t((struct amdgpu_cgs_device *)cgs_device)->adev\n\n\nstatic uint32_t amdgpu_cgs_read_register(struct cgs_device *cgs_device, unsigned int offset)\n{\n\tCGS_FUNC_ADEV;\n\treturn RREG32(offset);\n}\n\nstatic void amdgpu_cgs_write_register(struct cgs_device *cgs_device, unsigned int offset,\n\t\t\t\t      uint32_t value)\n{\n\tCGS_FUNC_ADEV;\n\tWREG32(offset, value);\n}\n\nstatic uint32_t amdgpu_cgs_read_ind_register(struct cgs_device *cgs_device,\n\t\t\t\t\t     enum cgs_ind_reg space,\n\t\t\t\t\t     unsigned int index)\n{\n\tCGS_FUNC_ADEV;\n\tswitch (space) {\n\tcase CGS_IND_REG__PCIE:\n\t\treturn RREG32_PCIE(index);\n\tcase CGS_IND_REG__SMC:\n\t\treturn RREG32_SMC(index);\n\tcase CGS_IND_REG__UVD_CTX:\n\t\treturn RREG32_UVD_CTX(index);\n\tcase CGS_IND_REG__DIDT:\n\t\treturn RREG32_DIDT(index);\n\tcase CGS_IND_REG_GC_CAC:\n\t\treturn RREG32_GC_CAC(index);\n\tcase CGS_IND_REG_SE_CAC:\n\t\treturn RREG32_SE_CAC(index);\n\tcase CGS_IND_REG__AUDIO_ENDPT:\n\t\tDRM_ERROR(\"audio endpt register access not implemented.\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n\tWARN(1, \"Invalid indirect register space\");\n\treturn 0;\n}\n\nstatic void amdgpu_cgs_write_ind_register(struct cgs_device *cgs_device,\n\t\t\t\t\t  enum cgs_ind_reg space,\n\t\t\t\t\t  unsigned int index, uint32_t value)\n{\n\tCGS_FUNC_ADEV;\n\tswitch (space) {\n\tcase CGS_IND_REG__PCIE:\n\t\treturn WREG32_PCIE(index, value);\n\tcase CGS_IND_REG__SMC:\n\t\treturn WREG32_SMC(index, value);\n\tcase CGS_IND_REG__UVD_CTX:\n\t\treturn WREG32_UVD_CTX(index, value);\n\tcase CGS_IND_REG__DIDT:\n\t\treturn WREG32_DIDT(index, value);\n\tcase CGS_IND_REG_GC_CAC:\n\t\treturn WREG32_GC_CAC(index, value);\n\tcase CGS_IND_REG_SE_CAC:\n\t\treturn WREG32_SE_CAC(index, value);\n\tcase CGS_IND_REG__AUDIO_ENDPT:\n\t\tDRM_ERROR(\"audio endpt register access not implemented.\\n\");\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tWARN(1, \"Invalid indirect register space\");\n}\n\nstatic uint32_t fw_type_convert(struct cgs_device *cgs_device, uint32_t fw_type)\n{\n\tCGS_FUNC_ADEV;\n\tenum AMDGPU_UCODE_ID result = AMDGPU_UCODE_ID_MAXIMUM;\n\n\tswitch (fw_type) {\n\tcase CGS_UCODE_ID_SDMA0:\n\t\tresult = AMDGPU_UCODE_ID_SDMA0;\n\t\tbreak;\n\tcase CGS_UCODE_ID_SDMA1:\n\t\tresult = AMDGPU_UCODE_ID_SDMA1;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_CE:\n\t\tresult = AMDGPU_UCODE_ID_CP_CE;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_PFP:\n\t\tresult = AMDGPU_UCODE_ID_CP_PFP;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_ME:\n\t\tresult = AMDGPU_UCODE_ID_CP_ME;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_MEC:\n\tcase CGS_UCODE_ID_CP_MEC_JT1:\n\t\tresult = AMDGPU_UCODE_ID_CP_MEC1;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_MEC_JT2:\n\t\t \n\t\tif (adev->asic_type >= CHIP_TOPAZ)\n\t\t\tresult = AMDGPU_UCODE_ID_CP_MEC1;\n\t\telse\n\t\t\tresult = AMDGPU_UCODE_ID_CP_MEC2;\n\t\tbreak;\n\tcase CGS_UCODE_ID_RLC_G:\n\t\tresult = AMDGPU_UCODE_ID_RLC_G;\n\t\tbreak;\n\tcase CGS_UCODE_ID_STORAGE:\n\t\tresult = AMDGPU_UCODE_ID_STORAGE;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Firmware type not supported\\n\");\n\t}\n\treturn result;\n}\n\nstatic uint16_t amdgpu_get_firmware_version(struct cgs_device *cgs_device,\n\t\t\t\t\tenum cgs_ucode_id type)\n{\n\tCGS_FUNC_ADEV;\n\tuint16_t fw_version = 0;\n\n\tswitch (type) {\n\tcase CGS_UCODE_ID_SDMA0:\n\t\tfw_version = adev->sdma.instance[0].fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_SDMA1:\n\t\tfw_version = adev->sdma.instance[1].fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_CE:\n\t\tfw_version = adev->gfx.ce_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_PFP:\n\t\tfw_version = adev->gfx.pfp_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_ME:\n\t\tfw_version = adev->gfx.me_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_MEC:\n\t\tfw_version = adev->gfx.mec_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_MEC_JT1:\n\t\tfw_version = adev->gfx.mec_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_CP_MEC_JT2:\n\t\tfw_version = adev->gfx.mec_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_RLC_G:\n\t\tfw_version = adev->gfx.rlc_fw_version;\n\t\tbreak;\n\tcase CGS_UCODE_ID_STORAGE:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"firmware type %d do not have version\\n\", type);\n\t\tbreak;\n\t}\n\treturn fw_version;\n}\n\nstatic int amdgpu_cgs_get_firmware_info(struct cgs_device *cgs_device,\n\t\t\t\t\tenum cgs_ucode_id type,\n\t\t\t\t\tstruct cgs_firmware_info *info)\n{\n\tCGS_FUNC_ADEV;\n\n\tif (type != CGS_UCODE_ID_SMU && type != CGS_UCODE_ID_SMU_SK) {\n\t\tuint64_t gpu_addr;\n\t\tuint32_t data_size;\n\t\tconst struct gfx_firmware_header_v1_0 *header;\n\t\tenum AMDGPU_UCODE_ID id;\n\t\tstruct amdgpu_firmware_info *ucode;\n\n\t\tid = fw_type_convert(cgs_device, type);\n\t\tucode = &adev->firmware.ucode[id];\n\t\tif (ucode->fw == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tgpu_addr  = ucode->mc_addr;\n\t\theader = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\n\t\tdata_size = le32_to_cpu(header->header.ucode_size_bytes);\n\n\t\tif ((type == CGS_UCODE_ID_CP_MEC_JT1) ||\n\t\t    (type == CGS_UCODE_ID_CP_MEC_JT2)) {\n\t\t\tgpu_addr += ALIGN(le32_to_cpu(header->header.ucode_size_bytes), PAGE_SIZE);\n\t\t\tdata_size = le32_to_cpu(header->jt_size) << 2;\n\t\t}\n\n\t\tinfo->kptr = ucode->kaddr;\n\t\tinfo->image_size = data_size;\n\t\tinfo->mc_addr = gpu_addr;\n\t\tinfo->version = (uint16_t)le32_to_cpu(header->header.ucode_version);\n\n\t\tif (type == CGS_UCODE_ID_CP_MEC)\n\t\t\tinfo->image_size = le32_to_cpu(header->jt_offset) << 2;\n\n\t\tinfo->fw_version = amdgpu_get_firmware_version(cgs_device, type);\n\t\tinfo->feature_version = (uint16_t)le32_to_cpu(header->ucode_feature_version);\n\t} else {\n\t\tchar fw_name[30] = {0};\n\t\tint err = 0;\n\t\tuint32_t ucode_size;\n\t\tuint32_t ucode_start_address;\n\t\tconst uint8_t *src;\n\t\tconst struct smc_firmware_header_v1_0 *hdr;\n\t\tconst struct common_firmware_header *header;\n\t\tstruct amdgpu_firmware_info *ucode = NULL;\n\n\t\tif (!adev->pm.fw) {\n\t\t\tswitch (adev->asic_type) {\n\t\t\tcase CHIP_TAHITI:\n\t\t\t\tstrcpy(fw_name, \"radeon/tahiti_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_PITCAIRN:\n\t\t\t\tif ((adev->pdev->revision == 0x81) &&\n\t\t\t\t    ((adev->pdev->device == 0x6810) ||\n\t\t\t\t    (adev->pdev->device == 0x6811))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/pitcairn_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/pitcairn_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VERDE:\n\t\t\t\tif (((adev->pdev->device == 0x6820) &&\n\t\t\t\t\t((adev->pdev->revision == 0x81) ||\n\t\t\t\t\t(adev->pdev->revision == 0x83))) ||\n\t\t\t\t    ((adev->pdev->device == 0x6821) &&\n\t\t\t\t\t((adev->pdev->revision == 0x83) ||\n\t\t\t\t\t(adev->pdev->revision == 0x87))) ||\n\t\t\t\t    ((adev->pdev->revision == 0x87) &&\n\t\t\t\t\t((adev->pdev->device == 0x6823) ||\n\t\t\t\t\t(adev->pdev->device == 0x682b)))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/verde_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/verde_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_OLAND:\n\t\t\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t\t\t((adev->pdev->device == 0x6600) ||\n\t\t\t\t\t(adev->pdev->device == 0x6604) ||\n\t\t\t\t\t(adev->pdev->device == 0x6605) ||\n\t\t\t\t\t(adev->pdev->device == 0x6610))) ||\n\t\t\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t\t\t(adev->pdev->device == 0x6610))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/oland_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/oland_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_HAINAN:\n\t\t\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t\t\t(adev->pdev->device == 0x6660)) ||\n\t\t\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t\t\t((adev->pdev->device == 0x6660) ||\n\t\t\t\t\t(adev->pdev->device == 0x6663) ||\n\t\t\t\t\t(adev->pdev->device == 0x6665) ||\n\t\t\t\t\t (adev->pdev->device == 0x6667)))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/hainan_k_smc.bin\");\n\t\t\t\t} else if ((adev->pdev->revision == 0xc3) &&\n\t\t\t\t\t (adev->pdev->device == 0x6665)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/banks_k_2_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/hainan_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_BONAIRE:\n\t\t\t\tif ((adev->pdev->revision == 0x80) ||\n\t\t\t\t\t(adev->pdev->revision == 0x81) ||\n\t\t\t\t\t(adev->pdev->device == 0x665f)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/bonaire_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_HAWAII:\n\t\t\t\tif (adev->pdev->revision == 0x80) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/hawaii_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_TOPAZ:\n\t\t\t\tif (((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0x81)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0x83)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6907) && (adev->pdev->revision == 0x87)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0xD1)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0xD3))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/topaz_k_smc.bin\");\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/topaz_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_TONGA:\n\t\t\t\tif (((adev->pdev->device == 0x6939) && (adev->pdev->revision == 0xf1)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6938) && (adev->pdev->revision == 0xf1))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/tonga_k_smc.bin\");\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/tonga_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_FIJI:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/fiji_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS11:\n\t\t\t\tif (type == CGS_UCODE_ID_SMU) {\n\t\t\t\t\tif (ASICID_IS_P21(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_k_smc.bin\");\n\t\t\t\t\t} else if (ASICID_IS_P31(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_smc.bin\");\n\t\t\t\t\t}\n\t\t\t\t} else if (type == CGS_UCODE_ID_SMU_SK) {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS10:\n\t\t\t\tif (type == CGS_UCODE_ID_SMU) {\n\t\t\t\t\tif (ASICID_IS_P20(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_k_smc.bin\");\n\t\t\t\t\t} else if (ASICID_IS_P30(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_smc.bin\");\n\t\t\t\t\t}\n\t\t\t\t} else if (type == CGS_UCODE_ID_SMU_SK) {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS12:\n\t\t\t\tif (ASICID_IS_P23(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris12_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGAM:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vegam_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA10:\n\t\t\t\tif ((adev->pdev->device == 0x687f) &&\n\t\t\t\t\t((adev->pdev->revision == 0xc0) ||\n\t\t\t\t\t(adev->pdev->revision == 0xc1) ||\n\t\t\t\t\t(adev->pdev->revision == 0xc3)))\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/vega10_acg_smc.bin\");\n\t\t\t\telse\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/vega10_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA12:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vega12_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA20:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vega20_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"SMC firmware not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = amdgpu_ucode_request(adev, &adev->pm.fw, fw_name);\n\t\t\tif (err) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware \\\"%s\\\"\", fw_name);\n\t\t\t\tamdgpu_ucode_release(&adev->pm.fw);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\t\t\tucode = &adev->firmware.ucode[AMDGPU_UCODE_ID_SMC];\n\t\t\t\tucode->ucode_id = AMDGPU_UCODE_ID_SMC;\n\t\t\t\tucode->fw = adev->pm.fw;\n\t\t\t\theader = (const struct common_firmware_header *)ucode->fw->data;\n\t\t\t\tadev->firmware.fw_size +=\n\t\t\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t\t\t}\n\t\t}\n\n\t\thdr = (const struct smc_firmware_header_v1_0 *)\tadev->pm.fw->data;\n\t\tamdgpu_ucode_print_smc_hdr(&hdr->header);\n\t\tadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\n\t\tucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\n\t\tsrc = (const uint8_t *)(adev->pm.fw->data +\n\t\t       le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\n\t\tinfo->version = adev->pm.fw_version;\n\t\tinfo->image_size = ucode_size;\n\t\tinfo->ucode_start_address = ucode_start_address;\n\t\tinfo->kptr = (void *)src;\n\t}\n\treturn 0;\n}\n\nstatic const struct cgs_ops amdgpu_cgs_ops = {\n\t.read_register = amdgpu_cgs_read_register,\n\t.write_register = amdgpu_cgs_write_register,\n\t.read_ind_register = amdgpu_cgs_read_ind_register,\n\t.write_ind_register = amdgpu_cgs_write_ind_register,\n\t.get_firmware_info = amdgpu_cgs_get_firmware_info,\n};\n\nstruct cgs_device *amdgpu_cgs_create_device(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_cgs_device *cgs_device =\n\t\tkmalloc(sizeof(*cgs_device), GFP_KERNEL);\n\n\tif (!cgs_device) {\n\t\tDRM_ERROR(\"Couldn't allocate CGS device structure\\n\");\n\t\treturn NULL;\n\t}\n\n\tcgs_device->base.ops = &amdgpu_cgs_ops;\n\tcgs_device->adev = adev;\n\n\treturn (struct cgs_device *)cgs_device;\n}\n\nvoid amdgpu_cgs_destroy_device(struct cgs_device *cgs_device)\n{\n\tkfree(cgs_device);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}