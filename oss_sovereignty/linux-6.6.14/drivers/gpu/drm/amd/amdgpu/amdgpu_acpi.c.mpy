{
  "module_name": "amdgpu_acpi.c",
  "hash_id": "27d7f411b49f6d7a8f52ff596f0edc3c12f8059c4fea535a1027f4d6a99c9591",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/slab.h>\n#include <linux/xarray.h>\n#include <linux/power_supply.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <acpi/video.h>\n#include <acpi/actbl.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_pm.h\"\n#include \"amdgpu_display.h\"\n#include \"amd_acpi.h\"\n#include \"atom.h\"\n\n \nstatic const guid_t amd_xcc_dsm_guid = GUID_INIT(0x8267f5d5, 0xa556, 0x44f2,\n\t\t\t\t\t\t 0xb8, 0xb4, 0x45, 0x56, 0x2e,\n\t\t\t\t\t\t 0x8c, 0x5b, 0xec);\n\n#define AMD_XCC_HID_START 3000\n#define AMD_XCC_DSM_GET_NUM_FUNCS 0\n#define AMD_XCC_DSM_GET_SUPP_MODE 1\n#define AMD_XCC_DSM_GET_XCP_MODE 2\n#define AMD_XCC_DSM_GET_VF_XCC_MAPPING 4\n#define AMD_XCC_DSM_GET_TMR_INFO 5\n#define AMD_XCC_DSM_NUM_FUNCS 5\n\n#define AMD_XCC_MAX_HID 24\n\nstruct xarray numa_info_xa;\n\n \nstruct amdgpu_acpi_xcc_info {\n\tstruct list_head list;\n\tstruct amdgpu_numa_info *numa_info;\n\tuint8_t xcp_node;\n\tuint8_t phy_id;\n\tacpi_handle handle;\n};\n\nstruct amdgpu_acpi_dev_info {\n\tstruct list_head list;\n\tstruct list_head xcc_list;\n\tuint16_t bdf;\n\tuint16_t supp_xcp_mode;\n\tuint16_t xcp_mode;\n\tuint16_t mem_mode;\n\tuint64_t tmr_base;\n\tuint64_t tmr_size;\n};\n\nstruct list_head amdgpu_acpi_dev_list;\n\nstruct amdgpu_atif_notification_cfg {\n\tbool enabled;\n\tint command_code;\n};\n\nstruct amdgpu_atif_notifications {\n\tbool thermal_state;\n\tbool forced_power_state;\n\tbool system_power_state;\n\tbool brightness_change;\n\tbool dgpu_display_event;\n\tbool gpu_package_power_limit;\n};\n\nstruct amdgpu_atif_functions {\n\tbool system_params;\n\tbool sbios_requests;\n\tbool temperature_change;\n\tbool query_backlight_transfer_characteristics;\n\tbool ready_to_undock;\n\tbool external_gpu_information;\n};\n\nstruct amdgpu_atif {\n\tacpi_handle handle;\n\n\tstruct amdgpu_atif_notifications notifications;\n\tstruct amdgpu_atif_functions functions;\n\tstruct amdgpu_atif_notification_cfg notification_cfg;\n\tstruct backlight_device *bd;\n\tstruct amdgpu_dm_backlight_caps backlight_caps;\n};\n\nstruct amdgpu_atcs_functions {\n\tbool get_ext_state;\n\tbool pcie_perf_req;\n\tbool pcie_dev_rdy;\n\tbool pcie_bus_width;\n\tbool power_shift_control;\n};\n\nstruct amdgpu_atcs {\n\tacpi_handle handle;\n\n\tstruct amdgpu_atcs_functions functions;\n};\n\nstatic struct amdgpu_acpi_priv {\n\tstruct amdgpu_atif atif;\n\tstruct amdgpu_atcs atcs;\n} amdgpu_acpi_priv;\n\n \n \nstatic union acpi_object *amdgpu_atif_call(struct amdgpu_atif *atif,\n\t\t\t\t\t   int function,\n\t\t\t\t\t   struct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atif_arg_elements[2];\n\tstruct acpi_object_list atif_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatif_arg.count = 2;\n\tatif_arg.pointer = &atif_arg_elements[0];\n\n\tatif_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatif_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatif_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatif_arg_elements[1].buffer.length = params->length;\n\t\tatif_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatif_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatif_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(atif->handle, NULL, &atif_arg,\n\t\t\t\t      &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tDRM_DEBUG_DRIVER(\"failed to evaluate ATIF got %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void amdgpu_atif_parse_notification(struct amdgpu_atif_notifications *n, u32 mask)\n{\n\tn->thermal_state = mask & ATIF_THERMAL_STATE_CHANGE_REQUEST_SUPPORTED;\n\tn->forced_power_state = mask & ATIF_FORCED_POWER_STATE_CHANGE_REQUEST_SUPPORTED;\n\tn->system_power_state = mask & ATIF_SYSTEM_POWER_SOURCE_CHANGE_REQUEST_SUPPORTED;\n\tn->brightness_change = mask & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST_SUPPORTED;\n\tn->dgpu_display_event = mask & ATIF_DGPU_DISPLAY_EVENT_SUPPORTED;\n\tn->gpu_package_power_limit = mask & ATIF_GPU_PACKAGE_POWER_LIMIT_REQUEST_SUPPORTED;\n}\n\n \nstatic void amdgpu_atif_parse_functions(struct amdgpu_atif_functions *f, u32 mask)\n{\n\tf->system_params = mask & ATIF_GET_SYSTEM_PARAMETERS_SUPPORTED;\n\tf->sbios_requests = mask & ATIF_GET_SYSTEM_BIOS_REQUESTS_SUPPORTED;\n\tf->temperature_change = mask & ATIF_TEMPERATURE_CHANGE_NOTIFICATION_SUPPORTED;\n\tf->query_backlight_transfer_characteristics =\n\t\tmask & ATIF_QUERY_BACKLIGHT_TRANSFER_CHARACTERISTICS_SUPPORTED;\n\tf->ready_to_undock = mask & ATIF_READY_TO_UNDOCK_NOTIFICATION_SUPPORTED;\n\tf->external_gpu_information = mask & ATIF_GET_EXTERNAL_GPU_INFORMATION_SUPPORTED;\n}\n\n \nstatic int amdgpu_atif_verify_interface(struct amdgpu_atif *atif)\n{\n\tunion acpi_object *info;\n\tstruct atif_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = amdgpu_atif_call(atif, ATIF_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 12) {\n\t\tDRM_INFO(\"ATIF buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tDRM_DEBUG_DRIVER(\"ATIF version %u\\n\", output.version);\n\n\tamdgpu_atif_parse_notification(&atif->notifications, output.notification_mask);\n\tamdgpu_atif_parse_functions(&atif->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int amdgpu_atif_get_notification_params(struct amdgpu_atif *atif)\n{\n\tunion acpi_object *info;\n\tstruct amdgpu_atif_notification_cfg *n = &atif->notification_cfg;\n\tstruct atif_system_params params;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = amdgpu_atif_call(atif, ATIF_FUNCTION_GET_SYSTEM_PARAMETERS,\n\t\t\t\tNULL);\n\tif (!info) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 10) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tsize = min(sizeof(params), size);\n\tmemcpy(&params, info->buffer.pointer, size);\n\n\tDRM_DEBUG_DRIVER(\"SYSTEM_PARAMS: mask = %#x, flags = %#x\\n\",\n\t\t\tparams.flags, params.valid_mask);\n\tparams.flags = params.flags & params.valid_mask;\n\n\tif ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_NONE) {\n\t\tn->enabled = false;\n\t\tn->command_code = 0;\n\t} else if ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_81) {\n\t\tn->enabled = true;\n\t\tn->command_code = 0x81;\n\t} else {\n\t\tif (size < 11) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->enabled = true;\n\t\tn->command_code = params.command_code;\n\t}\n\nout:\n\tDRM_DEBUG_DRIVER(\"Notification %s, command code = %#x\\n\",\n\t\t\t(n->enabled ? \"enabled\" : \"disabled\"),\n\t\t\tn->command_code);\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int amdgpu_atif_query_backlight_caps(struct amdgpu_atif *atif)\n{\n\tunion acpi_object *info;\n\tstruct atif_qbtc_output characteristics;\n\tstruct atif_qbtc_arguments arguments;\n\tstruct acpi_buffer params;\n\tsize_t size;\n\tint err = 0;\n\n\targuments.size = sizeof(arguments);\n\targuments.requested_display = ATIF_QBTC_REQUEST_LCD1;\n\n\tparams.length = sizeof(arguments);\n\tparams.pointer = (void *)&arguments;\n\n\tinfo = amdgpu_atif_call(atif,\n\t\tATIF_FUNCTION_QUERY_BRIGHTNESS_TRANSFER_CHARACTERISTICS,\n\t\t&params);\n\tif (!info) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 10) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemset(&characteristics, 0, sizeof(characteristics));\n\tsize = min(sizeof(characteristics), size);\n\tmemcpy(&characteristics, info->buffer.pointer, size);\n\n\tatif->backlight_caps.caps_valid = true;\n\tatif->backlight_caps.min_input_signal =\n\t\t\tcharacteristics.min_input_signal;\n\tatif->backlight_caps.max_input_signal =\n\t\t\tcharacteristics.max_input_signal;\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int amdgpu_atif_get_sbios_requests(struct amdgpu_atif *atif,\n\t\t\t\t\t  struct atif_sbios_requests *req)\n{\n\tunion acpi_object *info;\n\tsize_t size;\n\tint count = 0;\n\n\tinfo = amdgpu_atif_call(atif, ATIF_FUNCTION_GET_SYSTEM_BIOS_REQUESTS,\n\t\t\t\tNULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tsize = *(u16 *)info->buffer.pointer;\n\tif (size < 0xd) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemset(req, 0, sizeof(*req));\n\n\tsize = min(sizeof(*req), size);\n\tmemcpy(req, info->buffer.pointer, size);\n\tDRM_DEBUG_DRIVER(\"SBIOS pending requests: %#x\\n\", req->pending);\n\n\tcount = hweight32(req->pending);\n\nout:\n\tkfree(info);\n\treturn count;\n}\n\n \nstatic int amdgpu_atif_handler(struct amdgpu_device *adev,\n\t\t\t       struct acpi_bus_event *event)\n{\n\tstruct amdgpu_atif *atif = &amdgpu_acpi_priv.atif;\n\tint count;\n\n\tDRM_DEBUG_DRIVER(\"event, device_class = %s, type = %#x\\n\",\n\t\t\tevent->device_class, event->type);\n\n\tif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (!atif->notification_cfg.enabled ||\n\t    event->type != atif->notification_cfg.command_code) {\n\t\t \n\t\tif (event->type == ACPI_VIDEO_NOTIFY_PROBE)\n\t\t\treturn NOTIFY_BAD;\n\t\telse\n\t\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (atif->functions.sbios_requests) {\n\t\tstruct atif_sbios_requests req;\n\n\t\t \n\t\tcount = amdgpu_atif_get_sbios_requests(atif, &req);\n\n\t\tif (count <= 0)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tDRM_DEBUG_DRIVER(\"ATIF: %d pending SBIOS requests\\n\", count);\n\n\t\tif (req.pending & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST) {\n\t\t\tif (atif->bd) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"Changing brightness to %d\\n\",\n\t\t\t\t\t\t req.backlight_level);\n\t\t\t\t \n\t\t\t\tbacklight_device_set_brightness(atif->bd, req.backlight_level);\n\t\t\t}\n\t\t}\n\n\t\tif (req.pending & ATIF_DGPU_DISPLAY_EVENT) {\n\t\t\tif (adev->flags & AMD_IS_PX) {\n\t\t\t\tpm_runtime_get_sync(adev_to_drm(adev)->dev);\n\t\t\t\t \n\t\t\t\tdrm_helper_hpd_irq_event(adev_to_drm(adev));\n\t\t\t\tpm_runtime_mark_last_busy(adev_to_drm(adev)->dev);\n\t\t\t\tpm_runtime_put_autosuspend(adev_to_drm(adev)->dev);\n\t\t\t}\n\t\t}\n\t\t \n\t}\n\n\t \n\treturn NOTIFY_BAD;\n}\n\n \n \nstatic union acpi_object *amdgpu_atcs_call(struct amdgpu_atcs *atcs,\n\t\t\t\t\t   int function,\n\t\t\t\t\t   struct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atcs_arg_elements[2];\n\tstruct acpi_object_list atcs_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatcs_arg.count = 2;\n\tatcs_arg.pointer = &atcs_arg_elements[0];\n\n\tatcs_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatcs_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatcs_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatcs_arg_elements[1].buffer.length = params->length;\n\t\tatcs_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatcs_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatcs_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(atcs->handle, NULL, &atcs_arg, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tDRM_DEBUG_DRIVER(\"failed to evaluate ATCS got %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void amdgpu_atcs_parse_functions(struct amdgpu_atcs_functions *f, u32 mask)\n{\n\tf->get_ext_state = mask & ATCS_GET_EXTERNAL_STATE_SUPPORTED;\n\tf->pcie_perf_req = mask & ATCS_PCIE_PERFORMANCE_REQUEST_SUPPORTED;\n\tf->pcie_dev_rdy = mask & ATCS_PCIE_DEVICE_READY_NOTIFICATION_SUPPORTED;\n\tf->pcie_bus_width = mask & ATCS_SET_PCIE_BUS_WIDTH_SUPPORTED;\n\tf->power_shift_control = mask & ATCS_SET_POWER_SHIFT_CONTROL_SUPPORTED;\n}\n\n \nstatic int amdgpu_atcs_verify_interface(struct amdgpu_atcs *atcs)\n{\n\tunion acpi_object *info;\n\tstruct atcs_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = amdgpu_atcs_call(atcs, ATCS_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 8) {\n\t\tDRM_INFO(\"ATCS buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tDRM_DEBUG_DRIVER(\"ATCS version %u\\n\", output.version);\n\n\tamdgpu_atcs_parse_functions(&atcs->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nbool amdgpu_acpi_is_pcie_performance_request_supported(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_atcs *atcs = &amdgpu_acpi_priv.atcs;\n\n\tif (atcs->functions.pcie_perf_req && atcs->functions.pcie_dev_rdy)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nbool amdgpu_acpi_is_power_shift_control_supported(void)\n{\n\treturn amdgpu_acpi_priv.atcs.functions.power_shift_control;\n}\n\n \nint amdgpu_acpi_pcie_notify_device_ready(struct amdgpu_device *adev)\n{\n\tunion acpi_object *info;\n\tstruct amdgpu_atcs *atcs = &amdgpu_acpi_priv.atcs;\n\n\tif (!atcs->functions.pcie_dev_rdy)\n\t\treturn -EINVAL;\n\n\tinfo = amdgpu_atcs_call(atcs, ATCS_FUNCTION_PCIE_DEVICE_READY_NOTIFICATION, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tkfree(info);\n\n\treturn 0;\n}\n\n \nint amdgpu_acpi_pcie_performance_request(struct amdgpu_device *adev,\n\t\t\t\t\t u8 perf_req, bool advertise)\n{\n\tunion acpi_object *info;\n\tstruct amdgpu_atcs *atcs = &amdgpu_acpi_priv.atcs;\n\tstruct atcs_pref_req_input atcs_input;\n\tstruct atcs_pref_req_output atcs_output;\n\tstruct acpi_buffer params;\n\tsize_t size;\n\tu32 retry = 3;\n\n\tif (amdgpu_acpi_pcie_notify_device_ready(adev))\n\t\treturn -EINVAL;\n\n\tif (!atcs->functions.pcie_perf_req)\n\t\treturn -EINVAL;\n\n\tatcs_input.size = sizeof(struct atcs_pref_req_input);\n\t \n\tatcs_input.client_id = pci_dev_id(adev->pdev);\n\tatcs_input.valid_flags_mask = ATCS_VALID_FLAGS_MASK;\n\tatcs_input.flags = ATCS_WAIT_FOR_COMPLETION;\n\tif (advertise)\n\t\tatcs_input.flags |= ATCS_ADVERTISE_CAPS;\n\tatcs_input.req_type = ATCS_PCIE_LINK_SPEED;\n\tatcs_input.perf_req = perf_req;\n\n\tparams.length = sizeof(struct atcs_pref_req_input);\n\tparams.pointer = &atcs_input;\n\n\twhile (retry--) {\n\t\tinfo = amdgpu_atcs_call(atcs, ATCS_FUNCTION_PCIE_PERFORMANCE_REQUEST, &params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\n\t\tmemset(&atcs_output, 0, sizeof(atcs_output));\n\n\t\tsize = *(u16 *) info->buffer.pointer;\n\t\tif (size < 3) {\n\t\t\tDRM_INFO(\"ATCS buffer is too small: %zu\\n\", size);\n\t\t\tkfree(info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = min(sizeof(atcs_output), size);\n\n\t\tmemcpy(&atcs_output, info->buffer.pointer, size);\n\n\t\tkfree(info);\n\n\t\tswitch (atcs_output.ret_val) {\n\t\tcase ATCS_REQUEST_REFUSED:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\tcase ATCS_REQUEST_COMPLETE:\n\t\t\treturn 0;\n\t\tcase ATCS_REQUEST_IN_PROGRESS:\n\t\t\tudelay(10);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint amdgpu_acpi_power_shift_control(struct amdgpu_device *adev,\n\t\t\t\t    u8 dev_state, bool drv_state)\n{\n\tunion acpi_object *info;\n\tstruct amdgpu_atcs *atcs = &amdgpu_acpi_priv.atcs;\n\tstruct atcs_pwr_shift_input atcs_input;\n\tstruct acpi_buffer params;\n\n\tif (!amdgpu_acpi_is_power_shift_control_supported())\n\t\treturn -EINVAL;\n\n\tatcs_input.size = sizeof(struct atcs_pwr_shift_input);\n\t \n\tatcs_input.dgpu_id = pci_dev_id(adev->pdev);\n\tatcs_input.dev_acpi_state = dev_state;\n\tatcs_input.drv_state = drv_state;\n\n\tparams.length = sizeof(struct atcs_pwr_shift_input);\n\tparams.pointer = &atcs_input;\n\n\tinfo = amdgpu_atcs_call(atcs, ATCS_FUNCTION_POWER_SHIFT_CONTROL, &params);\n\tif (!info) {\n\t\tDRM_ERROR(\"ATCS PSC update failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint amdgpu_acpi_smart_shift_update(struct drm_device *dev, enum amdgpu_ss ss_state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint r;\n\n\tif (!amdgpu_device_supports_smart_shift(dev))\n\t\treturn 0;\n\n\tswitch (ss_state) {\n\t \n\tcase AMDGPU_SS_DRV_LOAD:\n\t\tr = amdgpu_acpi_power_shift_control(adev,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DEV_STATE_D0,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DRV_STATE_OPR);\n\t\tbreak;\n\tcase AMDGPU_SS_DEV_D0:\n\t\tr = amdgpu_acpi_power_shift_control(adev,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DEV_STATE_D0,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DRV_STATE_OPR);\n\t\tbreak;\n\tcase AMDGPU_SS_DEV_D3:\n\t\tr = amdgpu_acpi_power_shift_control(adev,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DEV_STATE_D3_HOT,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DRV_STATE_NOT_OPR);\n\t\tbreak;\n\tcase AMDGPU_SS_DRV_UNLOAD:\n\t\tr = amdgpu_acpi_power_shift_control(adev,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DEV_STATE_D0,\n\t\t\t\t\t\t    AMDGPU_ATCS_PSC_DRV_STATE_NOT_OPR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn r;\n}\n\n#ifdef CONFIG_ACPI_NUMA\nstatic inline uint64_t amdgpu_acpi_get_numa_size(int nid)\n{\n\t \n\tint zone_type;\n\tuint64_t managed_pages = 0;\n\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages +=\n\t\t\tzone_managed_pages(&pgdat->node_zones[zone_type]);\n\treturn managed_pages * PAGE_SIZE;\n}\n\nstatic struct amdgpu_numa_info *amdgpu_acpi_get_numa_info(uint32_t pxm)\n{\n\tstruct amdgpu_numa_info *numa_info;\n\tint nid;\n\n\tnuma_info = xa_load(&numa_info_xa, pxm);\n\n\tif (!numa_info) {\n\t\tstruct sysinfo info;\n\n\t\tnuma_info = kzalloc(sizeof(*numa_info), GFP_KERNEL);\n\t\tif (!numa_info)\n\t\t\treturn NULL;\n\n\t\tnid = pxm_to_node(pxm);\n\t\tnuma_info->pxm = pxm;\n\t\tnuma_info->nid = nid;\n\n\t\tif (numa_info->nid == NUMA_NO_NODE) {\n\t\t\tsi_meminfo(&info);\n\t\t\tnuma_info->size = info.totalram * info.mem_unit;\n\t\t} else {\n\t\t\tnuma_info->size = amdgpu_acpi_get_numa_size(nid);\n\t\t}\n\t\txa_store(&numa_info_xa, numa_info->pxm, numa_info, GFP_KERNEL);\n\t}\n\n\treturn numa_info;\n}\n#endif\n\n \nstatic acpi_status amdgpu_acpi_get_node_id(acpi_handle handle,\n\t\t\t\t    struct amdgpu_numa_info **numa_info)\n{\n#ifdef CONFIG_ACPI_NUMA\n\tu64 pxm;\n\tacpi_status status;\n\n\tif (!numa_info)\n\t\treturn_ACPI_STATUS(AE_ERROR);\n\n\tstatus = acpi_evaluate_integer(handle, \"_PXM\", NULL, &pxm);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\t*numa_info = amdgpu_acpi_get_numa_info(pxm);\n\n\tif (!*numa_info)\n\t\treturn_ACPI_STATUS(AE_ERROR);\n\n\treturn_ACPI_STATUS(AE_OK);\n#else\n\treturn_ACPI_STATUS(AE_NOT_EXIST);\n#endif\n}\n\nstatic struct amdgpu_acpi_dev_info *amdgpu_acpi_get_dev(u16 bdf)\n{\n\tstruct amdgpu_acpi_dev_info *acpi_dev;\n\n\tif (list_empty(&amdgpu_acpi_dev_list))\n\t\treturn NULL;\n\n\tlist_for_each_entry(acpi_dev, &amdgpu_acpi_dev_list, list)\n\t\tif (acpi_dev->bdf == bdf)\n\t\t\treturn acpi_dev;\n\n\treturn NULL;\n}\n\nstatic int amdgpu_acpi_dev_init(struct amdgpu_acpi_dev_info **dev_info,\n\t\t\t\tstruct amdgpu_acpi_xcc_info *xcc_info, u16 bdf)\n{\n\tstruct amdgpu_acpi_dev_info *tmp;\n\tunion acpi_object *obj;\n\tint ret = -ENOENT;\n\n\t*dev_info = NULL;\n\ttmp = kzalloc(sizeof(struct amdgpu_acpi_dev_info), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tmp->xcc_list);\n\tINIT_LIST_HEAD(&tmp->list);\n\ttmp->bdf = bdf;\n\n\tobj = acpi_evaluate_dsm_typed(xcc_info->handle, &amd_xcc_dsm_guid, 0,\n\t\t\t\t      AMD_XCC_DSM_GET_SUPP_MODE, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\n\tif (!obj) {\n\t\tacpi_handle_debug(xcc_info->handle,\n\t\t\t\t  \"_DSM function %d evaluation failed\",\n\t\t\t\t  AMD_XCC_DSM_GET_SUPP_MODE);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttmp->supp_xcp_mode = obj->integer.value & 0xFFFF;\n\tACPI_FREE(obj);\n\n\tobj = acpi_evaluate_dsm_typed(xcc_info->handle, &amd_xcc_dsm_guid, 0,\n\t\t\t\t      AMD_XCC_DSM_GET_XCP_MODE, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\n\tif (!obj) {\n\t\tacpi_handle_debug(xcc_info->handle,\n\t\t\t\t  \"_DSM function %d evaluation failed\",\n\t\t\t\t  AMD_XCC_DSM_GET_XCP_MODE);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttmp->xcp_mode = obj->integer.value & 0xFFFF;\n\ttmp->mem_mode = (obj->integer.value >> 32) & 0xFFFF;\n\tACPI_FREE(obj);\n\n\t \n\tobj = acpi_evaluate_dsm_typed(xcc_info->handle, &amd_xcc_dsm_guid, 0,\n\t\t\t\t      AMD_XCC_DSM_GET_TMR_INFO, NULL,\n\t\t\t\t      ACPI_TYPE_PACKAGE);\n\n\tif (!obj || obj->package.count < 2) {\n\t\tacpi_handle_debug(xcc_info->handle,\n\t\t\t\t  \"_DSM function %d evaluation failed\",\n\t\t\t\t  AMD_XCC_DSM_GET_TMR_INFO);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttmp->tmr_base = obj->package.elements[0].integer.value;\n\ttmp->tmr_size = obj->package.elements[1].integer.value;\n\tACPI_FREE(obj);\n\n\tDRM_DEBUG_DRIVER(\n\t\t\"New dev(%x): Supported xcp mode: %x curr xcp_mode : %x mem mode : %x, tmr base: %llx tmr size: %llx  \",\n\t\ttmp->bdf, tmp->supp_xcp_mode, tmp->xcp_mode, tmp->mem_mode,\n\t\ttmp->tmr_base, tmp->tmr_size);\n\tlist_add_tail(&tmp->list, &amdgpu_acpi_dev_list);\n\t*dev_info = tmp;\n\n\treturn 0;\n\nout:\n\tif (obj)\n\t\tACPI_FREE(obj);\n\tkfree(tmp);\n\n\treturn ret;\n}\n\nstatic int amdgpu_acpi_get_xcc_info(struct amdgpu_acpi_xcc_info *xcc_info,\n\t\t\t\t    u16 *bdf)\n{\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint ret = -ENOENT;\n\n\tobj = acpi_evaluate_dsm_typed(xcc_info->handle, &amd_xcc_dsm_guid, 0,\n\t\t\t\t      AMD_XCC_DSM_GET_NUM_FUNCS, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\n\tif (!obj || obj->integer.value != AMD_XCC_DSM_NUM_FUNCS)\n\t\tgoto out;\n\tACPI_FREE(obj);\n\n\t \n\tobj = acpi_evaluate_dsm_typed(xcc_info->handle, &amd_xcc_dsm_guid, 0,\n\t\t\t\t      AMD_XCC_DSM_GET_VF_XCC_MAPPING, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\n\tif (!obj) {\n\t\tacpi_handle_debug(xcc_info->handle,\n\t\t\t\t  \"_DSM function %d evaluation failed\",\n\t\t\t\t  AMD_XCC_DSM_GET_VF_XCC_MAPPING);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\txcc_info->phy_id = (obj->integer.value >> 32) & 0xFF;\n\t \n\txcc_info->xcp_node = (obj->integer.value >> 40) & 0xFF;\n\t \n\t*bdf = (obj->integer.value >> 48) & 0xFFFF;\n\tACPI_FREE(obj);\n\tobj = NULL;\n\n\tstatus =\n\t\tamdgpu_acpi_get_node_id(xcc_info->handle, &xcc_info->numa_info);\n\n\t \n\tif (ACPI_SUCCESS(status))\n\t\tret = 0;\nout:\n\tif (obj)\n\t\tACPI_FREE(obj);\n\n\treturn ret;\n}\n\nstatic int amdgpu_acpi_enumerate_xcc(void)\n{\n\tstruct amdgpu_acpi_dev_info *dev_info = NULL;\n\tstruct amdgpu_acpi_xcc_info *xcc_info;\n\tstruct acpi_device *acpi_dev;\n\tchar hid[ACPI_ID_LEN];\n\tint ret, id;\n\tu16 bdf;\n\n\tINIT_LIST_HEAD(&amdgpu_acpi_dev_list);\n\txa_init(&numa_info_xa);\n\n\tfor (id = 0; id < AMD_XCC_MAX_HID; id++) {\n\t\tsprintf(hid, \"%s%d\", \"AMD\", AMD_XCC_HID_START + id);\n\t\tacpi_dev = acpi_dev_get_first_match_dev(hid, NULL, -1);\n\t\t \n\t\tif (!acpi_dev) {\n\t\t\tDRM_DEBUG_DRIVER(\"No matching acpi device found for %s\",\n\t\t\t\t\t hid);\n\t\t\tbreak;\n\t\t}\n\n\t\txcc_info = kzalloc(sizeof(struct amdgpu_acpi_xcc_info),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!xcc_info) {\n\t\t\tDRM_ERROR(\"Failed to allocate memory for xcc info\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&xcc_info->list);\n\t\txcc_info->handle = acpi_device_handle(acpi_dev);\n\t\tacpi_dev_put(acpi_dev);\n\n\t\tret = amdgpu_acpi_get_xcc_info(xcc_info, &bdf);\n\t\tif (ret) {\n\t\t\tkfree(xcc_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_info = amdgpu_acpi_get_dev(bdf);\n\n\t\tif (!dev_info)\n\t\t\tret = amdgpu_acpi_dev_init(&dev_info, xcc_info, bdf);\n\n\t\tif (ret == -ENOMEM)\n\t\t\treturn ret;\n\n\t\tif (!dev_info) {\n\t\t\tkfree(xcc_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&xcc_info->list, &dev_info->xcc_list);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_acpi_get_tmr_info(struct amdgpu_device *adev, u64 *tmr_offset,\n\t\t\t     u64 *tmr_size)\n{\n\tstruct amdgpu_acpi_dev_info *dev_info;\n\tu16 bdf;\n\n\tif (!tmr_offset || !tmr_size)\n\t\treturn -EINVAL;\n\n\tbdf = pci_dev_id(adev->pdev);\n\tdev_info = amdgpu_acpi_get_dev(bdf);\n\tif (!dev_info)\n\t\treturn -ENOENT;\n\n\t*tmr_offset = dev_info->tmr_base;\n\t*tmr_size = dev_info->tmr_size;\n\n\treturn 0;\n}\n\nint amdgpu_acpi_get_mem_info(struct amdgpu_device *adev, int xcc_id,\n\t\t\t     struct amdgpu_numa_info *numa_info)\n{\n\tstruct amdgpu_acpi_dev_info *dev_info;\n\tstruct amdgpu_acpi_xcc_info *xcc_info;\n\tu16 bdf;\n\n\tif (!numa_info)\n\t\treturn -EINVAL;\n\n\tbdf = pci_dev_id(adev->pdev);\n\tdev_info = amdgpu_acpi_get_dev(bdf);\n\tif (!dev_info)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(xcc_info, &dev_info->xcc_list, list) {\n\t\tif (xcc_info->phy_id == xcc_id) {\n\t\t\tmemcpy(numa_info, xcc_info->numa_info,\n\t\t\t       sizeof(*numa_info));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int amdgpu_acpi_event(struct notifier_block *nb,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tstruct amdgpu_device *adev = container_of(nb, struct amdgpu_device, acpi_nb);\n\tstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\n\n\tif (strcmp(entry->device_class, ACPI_AC_CLASS) == 0) {\n\t\tif (power_supply_is_system_supplied() > 0)\n\t\t\tDRM_DEBUG_DRIVER(\"pm: AC\\n\");\n\t\telse\n\t\t\tDRM_DEBUG_DRIVER(\"pm: DC\\n\");\n\n\t\tamdgpu_pm_acpi_event_handler(adev);\n\t}\n\n\t \n\treturn amdgpu_atif_handler(adev, entry);\n}\n\n \n \nint amdgpu_acpi_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_atif *atif = &amdgpu_acpi_priv.atif;\n\n\tif (atif->notifications.brightness_change) {\n\t\tif (adev->dc_enabled) {\n#if defined(CONFIG_DRM_AMD_DC)\n\t\t\tstruct amdgpu_display_manager *dm = &adev->dm;\n\n\t\t\tif (dm->backlight_dev[0])\n\t\t\t\tatif->bd = dm->backlight_dev[0];\n#endif\n\t\t} else {\n\t\t\tstruct drm_encoder *tmp;\n\n\t\t\t \n\t\t\tlist_for_each_entry(tmp, &adev_to_drm(adev)->mode_config.encoder_list,\n\t\t\t\t\t    head) {\n\t\t\t\tstruct amdgpu_encoder *enc = to_amdgpu_encoder(tmp);\n\n\t\t\t\tif ((enc->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\n\t\t\t\t    enc->enc_priv) {\n\t\t\t\t\tstruct amdgpu_encoder_atom_dig *dig = enc->enc_priv;\n\n\t\t\t\t\tif (dig->bl_dev) {\n\t\t\t\t\t\tatif->bd = dig->bl_dev;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tadev->acpi_nb.notifier_call = amdgpu_acpi_event;\n\tregister_acpi_notifier(&adev->acpi_nb);\n\n\treturn 0;\n}\n\nvoid amdgpu_acpi_get_backlight_caps(struct amdgpu_dm_backlight_caps *caps)\n{\n\tstruct amdgpu_atif *atif = &amdgpu_acpi_priv.atif;\n\n\tcaps->caps_valid = atif->backlight_caps.caps_valid;\n\tcaps->min_input_signal = atif->backlight_caps.min_input_signal;\n\tcaps->max_input_signal = atif->backlight_caps.max_input_signal;\n}\n\n \nvoid amdgpu_acpi_fini(struct amdgpu_device *adev)\n{\n\tunregister_acpi_notifier(&adev->acpi_nb);\n}\n\n \nstatic bool amdgpu_atif_pci_probe_handle(struct pci_dev *pdev)\n{\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\n\tacpi_handle dhandle, atif_handle;\n\tacpi_status status;\n\tint ret;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn false;\n\n\tstatus = acpi_get_handle(dhandle, \"ATIF\", &atif_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tamdgpu_acpi_priv.atif.handle = atif_handle;\n\tacpi_get_name(amdgpu_acpi_priv.atif.handle, ACPI_FULL_PATHNAME, &buffer);\n\tDRM_DEBUG_DRIVER(\"Found ATIF handle %s\\n\", acpi_method_name);\n\tret = amdgpu_atif_verify_interface(&amdgpu_acpi_priv.atif);\n\tif (ret) {\n\t\tamdgpu_acpi_priv.atif.handle = 0;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool amdgpu_atcs_pci_probe_handle(struct pci_dev *pdev)\n{\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = { sizeof(acpi_method_name), acpi_method_name };\n\tacpi_handle dhandle, atcs_handle;\n\tacpi_status status;\n\tint ret;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn false;\n\n\tstatus = acpi_get_handle(dhandle, \"ATCS\", &atcs_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tamdgpu_acpi_priv.atcs.handle = atcs_handle;\n\tacpi_get_name(amdgpu_acpi_priv.atcs.handle, ACPI_FULL_PATHNAME, &buffer);\n\tDRM_DEBUG_DRIVER(\"Found ATCS handle %s\\n\", acpi_method_name);\n\tret = amdgpu_atcs_verify_interface(&amdgpu_acpi_priv.atcs);\n\tif (ret) {\n\t\tamdgpu_acpi_priv.atcs.handle = 0;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\n \nbool amdgpu_acpi_should_gpu_reset(struct amdgpu_device *adev)\n{\n\tif ((adev->flags & AMD_IS_APU) &&\n\t    adev->gfx.imu.funcs)  \n\t\treturn false;\n\n\tif ((adev->flags & AMD_IS_APU) &&\n\t    amdgpu_acpi_is_s3_active(adev))\n\t\treturn false;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn false;\n\n#if IS_ENABLED(CONFIG_SUSPEND)\n\treturn pm_suspend_target_state != PM_SUSPEND_TO_IDLE;\n#else\n\treturn true;\n#endif\n}\n\n \nvoid amdgpu_acpi_detect(void)\n{\n\tstruct amdgpu_atif *atif = &amdgpu_acpi_priv.atif;\n\tstruct amdgpu_atcs *atcs = &amdgpu_acpi_priv.atcs;\n\tstruct pci_dev *pdev = NULL;\n\tint ret;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tif (!atif->handle)\n\t\t\tamdgpu_atif_pci_probe_handle(pdev);\n\t\tif (!atcs->handle)\n\t\t\tamdgpu_atcs_pci_probe_handle(pdev);\n\t}\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\tif (!atif->handle)\n\t\t\tamdgpu_atif_pci_probe_handle(pdev);\n\t\tif (!atcs->handle)\n\t\t\tamdgpu_atcs_pci_probe_handle(pdev);\n\t}\n\n\tif (atif->functions.sbios_requests && !atif->functions.system_params) {\n\t\t \n\t\tatif->functions.system_params = true;\n\t}\n\n\tif (atif->functions.system_params) {\n\t\tret = amdgpu_atif_get_notification_params(atif);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_DRIVER(\"Call to GET_SYSTEM_PARAMS failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t \n\t\t\tatif->notification_cfg.enabled = false;\n\t\t}\n\t}\n\n\tif (atif->functions.query_backlight_transfer_characteristics) {\n\t\tret = amdgpu_atif_query_backlight_caps(atif);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_DRIVER(\"Call to QUERY_BACKLIGHT_TRANSFER_CHARACTERISTICS failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\tatif->backlight_caps.caps_valid = false;\n\t\t}\n\t} else {\n\t\tatif->backlight_caps.caps_valid = false;\n\t}\n\n\tamdgpu_acpi_enumerate_xcc();\n}\n\nvoid amdgpu_acpi_release(void)\n{\n\tstruct amdgpu_acpi_dev_info *dev_info, *dev_tmp;\n\tstruct amdgpu_acpi_xcc_info *xcc_info, *xcc_tmp;\n\tstruct amdgpu_numa_info *numa_info;\n\tunsigned long index;\n\n\txa_for_each(&numa_info_xa, index, numa_info) {\n\t\tkfree(numa_info);\n\t\txa_erase(&numa_info_xa, index);\n\t}\n\n\tif (list_empty(&amdgpu_acpi_dev_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(dev_info, dev_tmp, &amdgpu_acpi_dev_list,\n\t\t\t\t list) {\n\t\tlist_for_each_entry_safe(xcc_info, xcc_tmp, &dev_info->xcc_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&xcc_info->list);\n\t\t\tkfree(xcc_info);\n\t\t}\n\n\t\tlist_del(&dev_info->list);\n\t\tkfree(dev_info);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_SUSPEND)\n \nbool amdgpu_acpi_is_s3_active(struct amdgpu_device *adev)\n{\n\treturn !(adev->flags & AMD_IS_APU) ||\n\t\t(pm_suspend_target_state == PM_SUSPEND_MEM);\n}\n\n \nbool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev)\n{\n\tif (!(adev->flags & AMD_IS_APU) ||\n\t    (pm_suspend_target_state != PM_SUSPEND_TO_IDLE))\n\t\treturn false;\n\n\tif (adev->asic_type < CHIP_RAVEN)\n\t\treturn false;\n\n\t \n\tif (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)) {\n\t\tdev_err_once(adev->dev,\n\t\t\t      \"Power consumption will be higher as BIOS has not been configured for suspend-to-idle.\\n\"\n\t\t\t      \"To use suspend-to-idle change the sleep mode in BIOS setup.\\n\");\n\t\treturn false;\n\t}\n\n#if !IS_ENABLED(CONFIG_AMD_PMC)\n\tdev_err_once(adev->dev,\n\t\t      \"Power consumption will be higher as the kernel has not been compiled with CONFIG_AMD_PMC.\\n\");\n\treturn false;\n#else\n\treturn true;\n#endif  \n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}