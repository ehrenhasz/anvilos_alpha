{
  "module_name": "amdgpu_amdkfd_gfx_v9.c",
  "hash_id": "b73edb4f1871a40a9296a0cb10fa3842b3307f419504a10e45761ddaa7f20a05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v9.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"gc/gc_9_0_offset.h\"\n#include \"gc/gc_9_0_sh_mask.h\"\n#include \"vega10_enum.h\"\n#include \"sdma0/sdma0_4_0_offset.h\"\n#include \"sdma0/sdma0_4_0_sh_mask.h\"\n#include \"sdma1/sdma1_4_0_offset.h\"\n#include \"sdma1/sdma1_4_0_sh_mask.h\"\n#include \"athub/athub_1_0_offset.h\"\n#include \"athub/athub_1_0_sh_mask.h\"\n#include \"oss/osssys_4_0_offset.h\"\n#include \"oss/osssys_4_0_sh_mask.h\"\n#include \"soc15_common.h\"\n#include \"v9_structs.h\"\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"gfx_v9_0.h\"\n#include \"amdgpu_amdkfd_gfx_v9.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\nenum hqd_dequeue_request_type {\n\tNO_ACTION = 0,\n\tDRAIN_PIPE,\n\tRESET_WAVES,\n\tSAVE_WAVES\n};\n\nstatic void kgd_gfx_v9_lock_srbm(struct amdgpu_device *adev, uint32_t mec, uint32_t pipe,\n\t\t\tuint32_t queue, uint32_t vmid, uint32_t inst)\n{\n\tmutex_lock(&adev->srbm_mutex);\n\tsoc15_grbm_select(adev, mec, pipe, queue, vmid, GET_INST(GC, inst));\n}\n\nstatic void kgd_gfx_v9_unlock_srbm(struct amdgpu_device *adev, uint32_t inst)\n{\n\tsoc15_grbm_select(adev, 0, 0, 0, 0, GET_INST(GC, inst));\n\tmutex_unlock(&adev->srbm_mutex);\n}\n\nvoid kgd_gfx_v9_acquire_queue(struct amdgpu_device *adev, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id, uint32_t inst)\n{\n\tuint32_t mec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\tuint32_t pipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\tkgd_gfx_v9_lock_srbm(adev, mec, pipe, queue_id, 0, inst);\n}\n\nuint64_t kgd_gfx_v9_get_queue_mask(struct amdgpu_device *adev,\n\t\t\t       uint32_t pipe_id, uint32_t queue_id)\n{\n\tunsigned int bit = pipe_id * adev->gfx.mec.num_queue_per_pipe +\n\t\t\tqueue_id;\n\n\treturn 1ull << bit;\n}\n\nvoid kgd_gfx_v9_release_queue(struct amdgpu_device *adev, uint32_t inst)\n{\n\tkgd_gfx_v9_unlock_srbm(adev, inst);\n}\n\nvoid kgd_gfx_v9_program_sh_mem_settings(struct amdgpu_device *adev, uint32_t vmid,\n\t\t\t\t\tuint32_t sh_mem_config,\n\t\t\t\t\tuint32_t sh_mem_ape1_base,\n\t\t\t\t\tuint32_t sh_mem_ape1_limit,\n\t\t\t\t\tuint32_t sh_mem_bases, uint32_t inst)\n{\n\tkgd_gfx_v9_lock_srbm(adev, 0, 0, 0, vmid, inst);\n\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmSH_MEM_CONFIG), sh_mem_config);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmSH_MEM_BASES), sh_mem_bases);\n\t \n\n\tkgd_gfx_v9_unlock_srbm(adev, inst);\n}\n\nint kgd_gfx_v9_set_pasid_vmid_mapping(struct amdgpu_device *adev, u32 pasid,\n\t\t\t\t\tunsigned int vmid, uint32_t inst)\n{\n\t \n\tuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\n\t\t\tATC_VMID0_PASID_MAPPING__VALID_MASK;\n\n\t \n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0, mmATC_VMID0_PASID_MAPPING) + vmid,\n\t       pasid_mapping);\n\n\twhile (!(RREG32(SOC15_REG_OFFSET(\n\t\t\t\tATHUB, 0,\n\t\t\t\tmmATC_VMID_PASID_MAPPING_UPDATE_STATUS)) &\n\t\t (1U << vmid)))\n\t\tcpu_relax();\n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0,\n\t\t\t\tmmATC_VMID_PASID_MAPPING_UPDATE_STATUS),\n\t       1U << vmid);\n\n\t \n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_VMID_0_LUT) + vmid,\n\t       pasid_mapping);\n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0, mmATC_VMID16_PASID_MAPPING) + vmid,\n\t       pasid_mapping);\n\n\twhile (!(RREG32(SOC15_REG_OFFSET(\n\t\t\t\tATHUB, 0,\n\t\t\t\tmmATC_VMID_PASID_MAPPING_UPDATE_STATUS)) &\n\t\t (1U << (vmid + 16))))\n\t\tcpu_relax();\n\n\tWREG32(SOC15_REG_OFFSET(ATHUB, 0,\n\t\t\t\tmmATC_VMID_PASID_MAPPING_UPDATE_STATUS),\n\t       1U << (vmid + 16));\n\n\t \n\tWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_VMID_0_LUT_MM) + vmid,\n\t       pasid_mapping);\n\treturn 0;\n}\n\n \n\nint kgd_gfx_v9_init_interrupts(struct amdgpu_device *adev, uint32_t pipe_id,\n\t\t\t\tuint32_t inst)\n{\n\tuint32_t mec;\n\tuint32_t pipe;\n\n\tmec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\tpipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\tkgd_gfx_v9_lock_srbm(adev, mec, pipe, 0, 0, inst);\n\n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmCPC_INT_CNTL,\n\t\tCP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK |\n\t\tCP_INT_CNTL_RING0__OPCODE_ERROR_INT_ENABLE_MASK);\n\n\tkgd_gfx_v9_unlock_srbm(adev, inst);\n\n\treturn 0;\n}\n\nstatic uint32_t get_sdma_rlc_reg_offset(struct amdgpu_device *adev,\n\t\t\t\tunsigned int engine_id,\n\t\t\t\tunsigned int queue_id)\n{\n\tuint32_t sdma_engine_reg_base = 0;\n\tuint32_t sdma_rlc_reg_offset;\n\n\tswitch (engine_id) {\n\tdefault:\n\t\tdev_warn(adev->dev,\n\t\t\t \"Invalid sdma engine id (%d), using engine id 0\\n\",\n\t\t\t engine_id);\n\t\tfallthrough;\n\tcase 0:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA0, 0,\n\t\t\t\tmmSDMA0_RLC0_RB_CNTL) - mmSDMA0_RLC0_RB_CNTL;\n\t\tbreak;\n\tcase 1:\n\t\tsdma_engine_reg_base = SOC15_REG_OFFSET(SDMA1, 0,\n\t\t\t\tmmSDMA1_RLC0_RB_CNTL) - mmSDMA0_RLC0_RB_CNTL;\n\t\tbreak;\n\t}\n\n\tsdma_rlc_reg_offset = sdma_engine_reg_base\n\t\t+ queue_id * (mmSDMA0_RLC1_RB_CNTL - mmSDMA0_RLC0_RB_CNTL);\n\n\tpr_debug(\"RLC register offset for SDMA%d RLC%d: 0x%x\\n\", engine_id,\n\t\t queue_id, sdma_rlc_reg_offset);\n\n\treturn sdma_rlc_reg_offset;\n}\n\nstatic inline struct v9_mqd *get_mqd(void *mqd)\n{\n\treturn (struct v9_mqd *)mqd;\n}\n\nstatic inline struct v9_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct v9_sdma_mqd *)mqd;\n}\n\nint kgd_gfx_v9_hqd_load(struct amdgpu_device *adev, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tuint32_t __user *wptr, uint32_t wptr_shift,\n\t\t\tuint32_t wptr_mask, struct mm_struct *mm,\n\t\t\tuint32_t inst)\n{\n\tstruct v9_mqd *m;\n\tuint32_t *mqd_hqd;\n\tuint32_t reg, hqd_base, data;\n\n\tm = get_mqd(mqd);\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\n\t \n\tmqd_hqd = &m->cp_mqd_base_addr_lo;\n\thqd_base = SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_MQD_BASE_ADDR);\n\n\tfor (reg = hqd_base;\n\t     reg <= SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_HI); reg++)\n\t\tWREG32_RLC(reg, mqd_hqd[reg - hqd_base]);\n\n\n\t \n\tdata = REG_SET_FIELD(m->cp_hqd_pq_doorbell_control,\n\t\t\t     CP_HQD_PQ_DOORBELL_CONTROL, DOORBELL_EN, 1);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_DOORBELL_CONTROL),\n\t\t\t\t\tdata);\n\n\tif (wptr) {\n\t\t \n\t\tuint32_t queue_size =\n\t\t\t2 << REG_GET_FIELD(m->cp_hqd_pq_control,\n\t\t\t\t\t   CP_HQD_PQ_CONTROL, QUEUE_SIZE);\n\t\tuint64_t guessed_wptr = m->cp_hqd_pq_rptr & (queue_size - 1);\n\n\t\tif ((m->cp_hqd_pq_wptr_lo & (queue_size - 1)) < guessed_wptr)\n\t\t\tguessed_wptr += queue_size;\n\t\tguessed_wptr += m->cp_hqd_pq_wptr_lo & ~(queue_size - 1);\n\t\tguessed_wptr += (uint64_t)m->cp_hqd_pq_wptr_hi << 32;\n\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_LO),\n\t\t       lower_32_bits(guessed_wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_HI),\n\t\t       upper_32_bits(guessed_wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_POLL_ADDR),\n\t\t       lower_32_bits((uintptr_t)wptr));\n\t\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_POLL_ADDR_HI),\n\t\t       upper_32_bits((uintptr_t)wptr));\n\t\tWREG32_SOC15(GC, GET_INST(GC, inst), mmCP_PQ_WPTR_POLL_CNTL1,\n\t\t       (uint32_t)kgd_gfx_v9_get_queue_mask(adev, pipe_id, queue_id));\n\t}\n\n\t \n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_EOP_RPTR),\n\t       REG_SET_FIELD(m->cp_hqd_eop_rptr,\n\t\t\t     CP_HQD_EOP_RPTR, INIT_FETCHER, 1));\n\n\tdata = REG_SET_FIELD(m->cp_hqd_active, CP_HQD_ACTIVE, ACTIVE, 1);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_ACTIVE), data);\n\n\tkgd_gfx_v9_release_queue(adev, inst);\n\n\treturn 0;\n}\n\nint kgd_gfx_v9_hiq_mqd_load(struct amdgpu_device *adev, void *mqd,\n\t\t\t    uint32_t pipe_id, uint32_t queue_id,\n\t\t\t    uint32_t doorbell_off, uint32_t inst)\n{\n\tstruct amdgpu_ring *kiq_ring = &adev->gfx.kiq[inst].ring;\n\tstruct v9_mqd *m;\n\tuint32_t mec, pipe;\n\tint r;\n\n\tm = get_mqd(mqd);\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\n\tmec = (pipe_id / adev->gfx.mec.num_pipe_per_mec) + 1;\n\tpipe = (pipe_id % adev->gfx.mec.num_pipe_per_mec);\n\n\tpr_debug(\"kfd: set HIQ, mec:%d, pipe:%d, queue:%d.\\n\",\n\t\t mec, pipe, queue_id);\n\n\tspin_lock(&adev->gfx.kiq[inst].ring_lock);\n\tr = amdgpu_ring_alloc(kiq_ring, 7);\n\tif (r) {\n\t\tpr_err(\"Failed to alloc KIQ (%d).\\n\", r);\n\t\tgoto out_unlock;\n\t}\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\t  PACKET3_MAP_QUEUES_QUEUE_SEL(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_VMID(m->cp_hqd_vmid) |  \n\t\t\t  PACKET3_MAP_QUEUES_QUEUE(queue_id) |\n\t\t\t  PACKET3_MAP_QUEUES_PIPE(pipe) |\n\t\t\t  PACKET3_MAP_QUEUES_ME((mec - 1)) |\n\t\t\t  PACKET3_MAP_QUEUES_QUEUE_TYPE(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_ALLOC_FORMAT(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_ENGINE_SEL(1) |  \n\t\t\t  PACKET3_MAP_QUEUES_NUM_QUEUES(1));  \n\tamdgpu_ring_write(kiq_ring,\n\t\t\t  PACKET3_MAP_QUEUES_DOORBELL_OFFSET(doorbell_off));\n\tamdgpu_ring_write(kiq_ring, m->cp_mqd_base_addr_lo);\n\tamdgpu_ring_write(kiq_ring, m->cp_mqd_base_addr_hi);\n\tamdgpu_ring_write(kiq_ring, m->cp_hqd_pq_wptr_poll_addr_lo);\n\tamdgpu_ring_write(kiq_ring, m->cp_hqd_pq_wptr_poll_addr_hi);\n\tamdgpu_ring_commit(kiq_ring);\n\nout_unlock:\n\tspin_unlock(&adev->gfx.kiq[inst].ring_lock);\n\tkgd_gfx_v9_release_queue(adev, inst);\n\n\treturn r;\n}\n\nint kgd_gfx_v9_hqd_dump(struct amdgpu_device *adev,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tuint32_t (**dump)[2], uint32_t *n_regs, uint32_t inst)\n{\n\tuint32_t i = 0, reg;\n#define HQD_N_REGS 56\n#define DUMP_REG(addr) do {\t\t\t\t\\\n\t\tif (WARN_ON_ONCE(i >= HQD_N_REGS))\t\\\n\t\t\tbreak;\t\t\t\t\\\n\t\t(*dump)[i][0] = (addr) << 2;\t\t\\\n\t\t(*dump)[i++][1] = RREG32(addr);\t\t\\\n\t} while (0)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\n\tfor (reg = SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_MQD_BASE_ADDR);\n\t     reg <= SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_PQ_WPTR_HI); reg++)\n\t\tDUMP_REG(reg);\n\n\tkgd_gfx_v9_release_queue(adev, inst);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_load(struct amdgpu_device *adev, void *mqd,\n\t\t\t     uint32_t __user *wptr, struct mm_struct *mm)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tunsigned long end_jiffies;\n\tuint32_t data;\n\tuint64_t data64;\n\tuint64_t __user *wptr64 = (uint64_t __user *)wptr;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tm->sdmax_rlcx_rb_cntl & (~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK));\n\n\tend_jiffies = msecs_to_jiffies(2000) + jiffies;\n\twhile (true) {\n\t\tdata = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (data & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL_OFFSET,\n\t       m->sdmax_rlcx_doorbell_offset);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_doorbell, SDMA0_RLC0_DOORBELL,\n\t\t\t     ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, data);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR,\n\t\t\t\tm->sdmax_rlcx_rb_rptr);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_HI,\n\t\t\t\tm->sdmax_rlcx_rb_rptr_hi);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_MINOR_PTR_UPDATE, 1);\n\tif (read_user_wptr(mm, wptr64, data64)) {\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR,\n\t\t       lower_32_bits(data64));\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR_HI,\n\t\t       upper_32_bits(data64));\n\t} else {\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR,\n\t\t       m->sdmax_rlcx_rb_rptr);\n\t\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_WPTR_HI,\n\t\t       m->sdmax_rlcx_rb_rptr_hi);\n\t}\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_MINOR_PTR_UPDATE, 0);\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE, m->sdmax_rlcx_rb_base);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_BASE_HI,\n\t\t\tm->sdmax_rlcx_rb_base_hi);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_LO,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_lo);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_ADDR_HI,\n\t\t\tm->sdmax_rlcx_rb_rptr_addr_hi);\n\n\tdata = REG_SET_FIELD(m->sdmax_rlcx_rb_cntl, SDMA0_RLC0_RB_CNTL,\n\t\t\t     RB_ENABLE, 1);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, data);\n\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_dump(struct amdgpu_device *adev,\n\t\t\t     uint32_t engine_id, uint32_t queue_id,\n\t\t\t     uint32_t (**dump)[2], uint32_t *n_regs)\n{\n\tuint32_t sdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev,\n\t\t\tengine_id, queue_id);\n\tuint32_t i = 0, reg;\n#undef HQD_N_REGS\n#define HQD_N_REGS (19+6+7+10)\n\n\t*dump = kmalloc_array(HQD_N_REGS * 2, sizeof(uint32_t), GFP_KERNEL);\n\tif (*dump == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (reg = mmSDMA0_RLC0_RB_CNTL; reg <= mmSDMA0_RLC0_DOORBELL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_STATUS; reg <= mmSDMA0_RLC0_CSA_ADDR_HI; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_IB_SUB_REMAIN;\n\t     reg <= mmSDMA0_RLC0_MINOR_PTR_UPDATE; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\tfor (reg = mmSDMA0_RLC0_MIDCMD_DATA0;\n\t     reg <= mmSDMA0_RLC0_MIDCMD_CNTL; reg++)\n\t\tDUMP_REG(sdma_rlc_reg_offset + reg);\n\n\tWARN_ON_ONCE(i != HQD_N_REGS);\n\t*n_regs = i;\n\n\treturn 0;\n}\n\nbool kgd_gfx_v9_hqd_is_occupied(struct amdgpu_device *adev,\n\t\t\t\tuint64_t queue_address, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id, uint32_t inst)\n{\n\tuint32_t act;\n\tbool retval = false;\n\tuint32_t low, high;\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\tact = RREG32_SOC15(GC, GET_INST(GC, inst), mmCP_HQD_ACTIVE);\n\tif (act) {\n\t\tlow = lower_32_bits(queue_address >> 8);\n\t\thigh = upper_32_bits(queue_address >> 8);\n\n\t\tif (low == RREG32_SOC15(GC, GET_INST(GC, inst), mmCP_HQD_PQ_BASE) &&\n\t\t   high == RREG32_SOC15(GC, GET_INST(GC, inst), mmCP_HQD_PQ_BASE_HI))\n\t\t\tretval = true;\n\t}\n\tkgd_gfx_v9_release_queue(adev, inst);\n\treturn retval;\n}\n\nstatic bool kgd_hqd_sdma_is_occupied(struct amdgpu_device *adev, void *mqd)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t sdma_rlc_rb_cntl;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\tsdma_rlc_rb_cntl = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\n\tif (sdma_rlc_rb_cntl & SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nint kgd_gfx_v9_hqd_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\tenum kfd_preempt_type reset_type,\n\t\t\t\tunsigned int utimeout, uint32_t pipe_id,\n\t\t\t\tuint32_t queue_id, uint32_t inst)\n{\n\tenum hqd_dequeue_request_type type;\n\tunsigned long end_jiffies;\n\tuint32_t temp;\n\tstruct v9_mqd *m = get_mqd(mqd);\n\n\tif (amdgpu_in_reset(adev))\n\t\treturn -EIO;\n\n\tkgd_gfx_v9_acquire_queue(adev, pipe_id, queue_id, inst);\n\n\tif (m->cp_hqd_vmid == 0)\n\t\tWREG32_FIELD15_RLC(GC, GET_INST(GC, inst), RLC_CP_SCHEDULERS, scheduler1, 0);\n\n\tswitch (reset_type) {\n\tcase KFD_PREEMPT_TYPE_WAVEFRONT_DRAIN:\n\t\ttype = DRAIN_PIPE;\n\t\tbreak;\n\tcase KFD_PREEMPT_TYPE_WAVEFRONT_RESET:\n\t\ttype = RESET_WAVES;\n\t\tbreak;\n\tcase KFD_PREEMPT_TYPE_WAVEFRONT_SAVE:\n\t\ttype = SAVE_WAVES;\n\t\tbreak;\n\tdefault:\n\t\ttype = DRAIN_PIPE;\n\t\tbreak;\n\t}\n\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, GET_INST(GC, inst), mmCP_HQD_DEQUEUE_REQUEST), type);\n\n\tend_jiffies = (utimeout * HZ / 1000) + jiffies;\n\twhile (true) {\n\t\ttemp = RREG32_SOC15(GC, GET_INST(GC, inst), mmCP_HQD_ACTIVE);\n\t\tif (!(temp & CP_HQD_ACTIVE__ACTIVE_MASK))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"cp queue preemption time out.\\n\");\n\t\t\tkgd_gfx_v9_release_queue(adev, inst);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tkgd_gfx_v9_release_queue(adev, inst);\n\treturn 0;\n}\n\nstatic int kgd_hqd_sdma_destroy(struct amdgpu_device *adev, void *mqd,\n\t\t\t\tunsigned int utimeout)\n{\n\tstruct v9_sdma_mqd *m;\n\tuint32_t sdma_rlc_reg_offset;\n\tuint32_t temp;\n\tunsigned long end_jiffies = (utimeout * HZ / 1000) + jiffies;\n\n\tm = get_sdma_mqd(mqd);\n\tsdma_rlc_reg_offset = get_sdma_rlc_reg_offset(adev, m->sdma_engine_id,\n\t\t\t\t\t    m->sdma_queue_id);\n\n\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL);\n\ttemp = temp & ~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK;\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL, temp);\n\n\twhile (true) {\n\t\ttemp = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_CONTEXT_STATUS);\n\t\tif (temp & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, end_jiffies)) {\n\t\t\tpr_err(\"SDMA RLC not idle in %s\\n\", __func__);\n\t\t\treturn -ETIME;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_DOORBELL, 0);\n\tWREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL,\n\t\tRREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_CNTL) |\n\t\tSDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK);\n\n\tm->sdmax_rlcx_rb_rptr = RREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR);\n\tm->sdmax_rlcx_rb_rptr_hi =\n\t\tRREG32(sdma_rlc_reg_offset + mmSDMA0_RLC0_RB_RPTR_HI);\n\n\treturn 0;\n}\n\nbool kgd_gfx_v9_get_atc_vmid_pasid_mapping_info(struct amdgpu_device *adev,\n\t\t\t\t\tuint8_t vmid, uint16_t *p_pasid)\n{\n\tuint32_t value;\n\n\tvalue = RREG32(SOC15_REG_OFFSET(ATHUB, 0, mmATC_VMID0_PASID_MAPPING)\n\t\t     + vmid);\n\t*p_pasid = value & ATC_VMID0_PASID_MAPPING__PASID_MASK;\n\n\treturn !!(value & ATC_VMID0_PASID_MAPPING__VALID_MASK);\n}\n\nint kgd_gfx_v9_wave_control_execute(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t gfx_index_val,\n\t\t\t\t\tuint32_t sq_cmd, uint32_t inst)\n{\n\tuint32_t data = 0;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tWREG32_SOC15_RLC_SHADOW(GC, GET_INST(GC, inst), mmGRBM_GFX_INDEX, gfx_index_val);\n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmSQ_CMD, sq_cmd);\n\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tINSTANCE_BROADCAST_WRITES, 1);\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tSH_BROADCAST_WRITES, 1);\n\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\n\t\tSE_BROADCAST_WRITES, 1);\n\n\tWREG32_SOC15_RLC_SHADOW(GC, GET_INST(GC, inst), mmGRBM_GFX_INDEX, data);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\n \n#define KGD_GFX_V9_WAVE_LAUNCH_SPI_DRAIN_LATENCY\t3\nvoid kgd_gfx_v9_set_wave_launch_stall(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t vmid,\n\t\t\t\t\tbool stall)\n{\n\tint i;\n\tuint32_t data = RREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL));\n\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 1))\n\t\tdata = REG_SET_FIELD(data, SPI_GDBG_WAVE_CNTL, STALL_VMID,\n\t\t\t\t\t\t\tstall ? 1 << vmid : 0);\n\telse\n\t\tdata = REG_SET_FIELD(data, SPI_GDBG_WAVE_CNTL, STALL_RA,\n\t\t\t\t\t\t\tstall ? 1 : 0);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL), data);\n\n\tif (!stall)\n\t\treturn;\n\n\tfor (i = 0; i < KGD_GFX_V9_WAVE_LAUNCH_SPI_DRAIN_LATENCY; i++)\n\t\tRREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL));\n}\n\n \nuint32_t kgd_gfx_v9_enable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\tbool restore_dbg_registers,\n\t\t\t\tuint32_t vmid)\n{\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), 0);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, false);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\n \nuint32_t kgd_gfx_v9_disable_debug_trap(struct amdgpu_device *adev,\n\t\t\t\t\tbool keep_trap_enabled,\n\t\t\t\t\tuint32_t vmid)\n{\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), 0);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, false);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\nint kgd_gfx_v9_validate_trap_override_request(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t trap_override,\n\t\t\t\t\tuint32_t *trap_mask_supported)\n{\n\t*trap_mask_supported &= KFD_DBG_TRAP_MASK_DBG_ADDRESS_WATCH;\n\n\t \n\tif (trap_override != KFD_DBG_TRAP_OVERRIDE_OR)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nuint32_t kgd_gfx_v9_set_wave_launch_trap_override(struct amdgpu_device *adev,\n\t\t\t\t\t     uint32_t vmid,\n\t\t\t\t\t     uint32_t trap_override,\n\t\t\t\t\t     uint32_t trap_mask_bits,\n\t\t\t\t\t     uint32_t trap_mask_request,\n\t\t\t\t\t     uint32_t *trap_mask_prev,\n\t\t\t\t\t     uint32_t kfd_dbg_cntl_prev)\n{\n\tuint32_t data, wave_cntl_prev;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\twave_cntl_prev = RREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL));\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK));\n\t*trap_mask_prev = REG_GET_FIELD(data, SPI_GDBG_TRAP_MASK, EXCP_EN);\n\n\ttrap_mask_bits = (trap_mask_bits & trap_mask_request) |\n\t\t(*trap_mask_prev & ~trap_mask_request);\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_TRAP_MASK, EXCP_EN, trap_mask_bits);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_TRAP_MASK, REPLACE, trap_override);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), data);\n\n\t \n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL), wave_cntl_prev);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\nuint32_t kgd_gfx_v9_set_wave_launch_mode(struct amdgpu_device *adev,\n\t\t\t\t\tuint8_t wave_launch_mode,\n\t\t\t\t\tuint32_t vmid)\n{\n\tuint32_t data = 0;\n\tbool is_mode_set = !!wave_launch_mode;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, true);\n\n\tdata = REG_SET_FIELD(data, SPI_GDBG_WAVE_CNTL2,\n\t\tVMID_MASK, is_mode_set ? 1 << vmid : 0);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_WAVE_CNTL2,\n\t\tMODE, is_mode_set ? wave_launch_mode : 0);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_WAVE_CNTL2), data);\n\n\tkgd_gfx_v9_set_wave_launch_stall(adev, vmid, false);\n\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn 0;\n}\n\n#define TCP_WATCH_STRIDE (mmTCP_WATCH1_ADDR_H - mmTCP_WATCH0_ADDR_H)\nuint32_t kgd_gfx_v9_set_address_watch(struct amdgpu_device *adev,\n\t\t\t\t\tuint64_t watch_address,\n\t\t\t\t\tuint32_t watch_address_mask,\n\t\t\t\t\tuint32_t watch_id,\n\t\t\t\t\tuint32_t watch_mode,\n\t\t\t\t\tuint32_t debug_vmid,\n\t\t\t\t\tuint32_t inst)\n{\n\tuint32_t watch_address_high;\n\tuint32_t watch_address_low;\n\tuint32_t watch_address_cntl;\n\n\twatch_address_cntl = 0;\n\n\twatch_address_low = lower_32_bits(watch_address);\n\twatch_address_high = upper_32_bits(watch_address) & 0xffff;\n\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tVMID,\n\t\t\tdebug_vmid);\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMODE,\n\t\t\twatch_mode);\n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tMASK,\n\t\t\twatch_address_mask >> 6);\n\n\t \n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tVALID,\n\t\t\t0);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, mmTCP_WATCH0_CNTL) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_cntl);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, mmTCP_WATCH0_ADDR_H) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_high);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, mmTCP_WATCH0_ADDR_L) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_low);\n\n\t \n\twatch_address_cntl = REG_SET_FIELD(watch_address_cntl,\n\t\t\tTCP_WATCH0_CNTL,\n\t\t\tVALID,\n\t\t\t1);\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, mmTCP_WATCH0_CNTL) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_cntl);\n\n\treturn 0;\n}\n\nuint32_t kgd_gfx_v9_clear_address_watch(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t watch_id)\n{\n\tuint32_t watch_address_cntl;\n\n\twatch_address_cntl = 0;\n\n\tWREG32_RLC((SOC15_REG_OFFSET(GC, 0, mmTCP_WATCH0_CNTL) +\n\t\t\t(watch_id * TCP_WATCH_STRIDE)),\n\t\t\twatch_address_cntl);\n\n\treturn 0;\n}\n\n \nvoid kgd_gfx_v9_get_iq_wait_times(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t *wait_times,\n\t\t\t\t\tuint32_t inst)\n\n{\n\t*wait_times = RREG32(SOC15_REG_OFFSET(GC, GET_INST(GC, inst),\n\t\t\tmmCP_IQ_WAIT_TIME2));\n}\n\nvoid kgd_gfx_v9_set_vm_context_page_table_base(struct amdgpu_device *adev,\n\t\t\tuint32_t vmid, uint64_t page_table_base)\n{\n\tif (!amdgpu_amdkfd_is_kfd_vmid(adev, vmid)) {\n\t\tpr_err(\"trying to set page table base for wrong VMID %u\\n\",\n\t\t       vmid);\n\t\treturn;\n\t}\n\n\tadev->mmhub.funcs->setup_vm_pt_regs(adev, vmid, page_table_base);\n\n\tadev->gfxhub.funcs->setup_vm_pt_regs(adev, vmid, page_table_base);\n}\n\nstatic void lock_spi_csq_mutexes(struct amdgpu_device *adev)\n{\n\tmutex_lock(&adev->srbm_mutex);\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n}\n\nstatic void unlock_spi_csq_mutexes(struct amdgpu_device *adev)\n{\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\tmutex_unlock(&adev->srbm_mutex);\n}\n\n \nstatic void get_wave_count(struct amdgpu_device *adev, int queue_idx,\n\t\tint *wave_cnt, int *vmid, uint32_t inst)\n{\n\tint pipe_idx;\n\tint queue_slot;\n\tunsigned int reg_val;\n\n\t \n\t*vmid = 0xFF;\n\t*wave_cnt = 0;\n\tpipe_idx = queue_idx / adev->gfx.mec.num_queue_per_pipe;\n\tqueue_slot = queue_idx % adev->gfx.mec.num_queue_per_pipe;\n\tsoc15_grbm_select(adev, 1, pipe_idx, queue_slot, 0, inst);\n\treg_val = RREG32_SOC15_IP(GC, SOC15_REG_OFFSET(GC, inst, mmSPI_CSQ_WF_ACTIVE_COUNT_0) +\n\t\t\t queue_slot);\n\t*wave_cnt = reg_val & SPI_CSQ_WF_ACTIVE_COUNT_0__COUNT_MASK;\n\tif (*wave_cnt != 0)\n\t\t*vmid = (RREG32_SOC15(GC, inst, mmCP_HQD_VMID) &\n\t\t\t CP_HQD_VMID__VMID_MASK) >> CP_HQD_VMID__VMID__SHIFT;\n}\n\n \nvoid kgd_gfx_v9_get_cu_occupancy(struct amdgpu_device *adev, int pasid,\n\t\tint *pasid_wave_cnt, int *max_waves_per_cu, uint32_t inst)\n{\n\tint qidx;\n\tint vmid;\n\tint se_idx;\n\tint sh_idx;\n\tint se_cnt;\n\tint sh_cnt;\n\tint wave_cnt;\n\tint queue_map;\n\tint pasid_tmp;\n\tint max_queue_cnt;\n\tint vmid_wave_cnt = 0;\n\tDECLARE_BITMAP(cp_queue_bitmap, KGD_MAX_QUEUES);\n\n\tlock_spi_csq_mutexes(adev);\n\tsoc15_grbm_select(adev, 1, 0, 0, 0, inst);\n\n\t \n\tbitmap_complement(cp_queue_bitmap, adev->gfx.mec_bitmap[0].queue_bitmap,\n\t\t\t  KGD_MAX_QUEUES);\n\tmax_queue_cnt = adev->gfx.mec.num_pipe_per_mec *\n\t\t\tadev->gfx.mec.num_queue_per_pipe;\n\tsh_cnt = adev->gfx.config.max_sh_per_se;\n\tse_cnt = adev->gfx.config.max_shader_engines;\n\tfor (se_idx = 0; se_idx < se_cnt; se_idx++) {\n\t\tfor (sh_idx = 0; sh_idx < sh_cnt; sh_idx++) {\n\n\t\t\tamdgpu_gfx_select_se_sh(adev, se_idx, sh_idx, 0xffffffff, inst);\n\t\t\tqueue_map = RREG32_SOC15(GC, inst, mmSPI_CSQ_WF_ACTIVE_STATUS);\n\n\t\t\t \n\t\t\tfor (qidx = 0; qidx < max_queue_cnt; qidx++) {\n\n\t\t\t\t \n\t\t\t\tif (!test_bit(qidx, cp_queue_bitmap))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!(queue_map & (1 << qidx)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tget_wave_count(adev, qidx, &wave_cnt, &vmid,\n\t\t\t\t\t\tinst);\n\t\t\t\tif (wave_cnt != 0) {\n\t\t\t\t\tpasid_tmp =\n\t\t\t\t\t  RREG32(SOC15_REG_OFFSET(OSSSYS, inst,\n\t\t\t\t\t\t mmIH_VMID_0_LUT) + vmid);\n\t\t\t\t\tif (pasid_tmp == pasid)\n\t\t\t\t\t\tvmid_wave_cnt += wave_cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, inst);\n\tsoc15_grbm_select(adev, 0, 0, 0, 0, inst);\n\tunlock_spi_csq_mutexes(adev);\n\n\t \n\t*pasid_wave_cnt = vmid_wave_cnt;\n\t*max_waves_per_cu = adev->gfx.cu_info.simd_per_cu *\n\t\t\t\tadev->gfx.cu_info.max_waves_per_simd;\n}\n\nvoid kgd_gfx_v9_build_grace_period_packet_info(struct amdgpu_device *adev,\n\t\tuint32_t wait_times,\n\t\tuint32_t grace_period,\n\t\tuint32_t *reg_offset,\n\t\tuint32_t *reg_data)\n{\n\t*reg_data = wait_times;\n\n\t \n\tif (grace_period == 0)\n\t\tgrace_period = 1;\n\n\t*reg_data = REG_SET_FIELD(*reg_data,\n\t\t\tCP_IQ_WAIT_TIME2,\n\t\t\tSCH_WAVE,\n\t\t\tgrace_period);\n\n\t*reg_offset = SOC15_REG_OFFSET(GC, 0, mmCP_IQ_WAIT_TIME2);\n}\n\nvoid kgd_gfx_v9_program_trap_handler_settings(struct amdgpu_device *adev,\n\t\tuint32_t vmid, uint64_t tba_addr, uint64_t tma_addr, uint32_t inst)\n{\n\tkgd_gfx_v9_lock_srbm(adev, 0, 0, 0, vmid, inst);\n\n\t \n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmSQ_SHADER_TBA_LO,\n\t\t\tlower_32_bits(tba_addr >> 8));\n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmSQ_SHADER_TBA_HI,\n\t\t\tupper_32_bits(tba_addr >> 8));\n\n\t \n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmSQ_SHADER_TMA_LO,\n\t\t\tlower_32_bits(tma_addr >> 8));\n\tWREG32_SOC15(GC, GET_INST(GC, inst), mmSQ_SHADER_TMA_HI,\n\t\t\tupper_32_bits(tma_addr >> 8));\n\n\tkgd_gfx_v9_unlock_srbm(adev, inst);\n}\n\nconst struct kfd2kgd_calls gfx_v9_kfd2kgd = {\n\t.program_sh_mem_settings = kgd_gfx_v9_program_sh_mem_settings,\n\t.set_pasid_vmid_mapping = kgd_gfx_v9_set_pasid_vmid_mapping,\n\t.init_interrupts = kgd_gfx_v9_init_interrupts,\n\t.hqd_load = kgd_gfx_v9_hqd_load,\n\t.hiq_mqd_load = kgd_gfx_v9_hiq_mqd_load,\n\t.hqd_sdma_load = kgd_hqd_sdma_load,\n\t.hqd_dump = kgd_gfx_v9_hqd_dump,\n\t.hqd_sdma_dump = kgd_hqd_sdma_dump,\n\t.hqd_is_occupied = kgd_gfx_v9_hqd_is_occupied,\n\t.hqd_sdma_is_occupied = kgd_hqd_sdma_is_occupied,\n\t.hqd_destroy = kgd_gfx_v9_hqd_destroy,\n\t.hqd_sdma_destroy = kgd_hqd_sdma_destroy,\n\t.wave_control_execute = kgd_gfx_v9_wave_control_execute,\n\t.get_atc_vmid_pasid_mapping_info =\n\t\t\tkgd_gfx_v9_get_atc_vmid_pasid_mapping_info,\n\t.set_vm_context_page_table_base = kgd_gfx_v9_set_vm_context_page_table_base,\n\t.enable_debug_trap = kgd_gfx_v9_enable_debug_trap,\n\t.disable_debug_trap = kgd_gfx_v9_disable_debug_trap,\n\t.validate_trap_override_request = kgd_gfx_v9_validate_trap_override_request,\n\t.set_wave_launch_trap_override = kgd_gfx_v9_set_wave_launch_trap_override,\n\t.set_wave_launch_mode = kgd_gfx_v9_set_wave_launch_mode,\n\t.set_address_watch = kgd_gfx_v9_set_address_watch,\n\t.clear_address_watch = kgd_gfx_v9_clear_address_watch,\n\t.get_iq_wait_times = kgd_gfx_v9_get_iq_wait_times,\n\t.build_grace_period_packet_info = kgd_gfx_v9_build_grace_period_packet_info,\n\t.get_cu_occupancy = kgd_gfx_v9_get_cu_occupancy,\n\t.program_trap_handler_settings = kgd_gfx_v9_program_trap_handler_settings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}