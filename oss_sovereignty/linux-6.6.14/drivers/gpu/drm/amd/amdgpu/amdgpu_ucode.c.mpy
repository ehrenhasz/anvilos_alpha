{
  "module_name": "amdgpu_ucode.c",
  "hash_id": "8853ab3dc3633164e99656115226a4e8a1898b10cb6dbe4577b10e74c78bd988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_ucode.h\"\n\nstatic void amdgpu_ucode_print_common_hdr(const struct common_firmware_header *hdr)\n{\n\tDRM_DEBUG(\"size_bytes: %u\\n\", le32_to_cpu(hdr->size_bytes));\n\tDRM_DEBUG(\"header_size_bytes: %u\\n\", le32_to_cpu(hdr->header_size_bytes));\n\tDRM_DEBUG(\"header_version_major: %u\\n\", le16_to_cpu(hdr->header_version_major));\n\tDRM_DEBUG(\"header_version_minor: %u\\n\", le16_to_cpu(hdr->header_version_minor));\n\tDRM_DEBUG(\"ip_version_major: %u\\n\", le16_to_cpu(hdr->ip_version_major));\n\tDRM_DEBUG(\"ip_version_minor: %u\\n\", le16_to_cpu(hdr->ip_version_minor));\n\tDRM_DEBUG(\"ucode_version: 0x%08x\\n\", le32_to_cpu(hdr->ucode_version));\n\tDRM_DEBUG(\"ucode_size_bytes: %u\\n\", le32_to_cpu(hdr->ucode_size_bytes));\n\tDRM_DEBUG(\"ucode_array_offset_bytes: %u\\n\",\n\t\t  le32_to_cpu(hdr->ucode_array_offset_bytes));\n\tDRM_DEBUG(\"crc32: 0x%08x\\n\", le32_to_cpu(hdr->crc32));\n}\n\nvoid amdgpu_ucode_print_mc_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\n\tDRM_DEBUG(\"MC\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct mc_firmware_header_v1_0 *mc_hdr =\n\t\t\tcontainer_of(hdr, struct mc_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"io_debug_size_bytes: %u\\n\",\n\t\t\t  le32_to_cpu(mc_hdr->io_debug_size_bytes));\n\t\tDRM_DEBUG(\"io_debug_array_offset_bytes: %u\\n\",\n\t\t\t  le32_to_cpu(mc_hdr->io_debug_array_offset_bytes));\n\t} else {\n\t\tDRM_ERROR(\"Unknown MC ucode version: %u.%u\\n\", version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_smc_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\tconst struct smc_firmware_header_v1_0 *v1_0_hdr;\n\tconst struct smc_firmware_header_v2_0 *v2_0_hdr;\n\tconst struct smc_firmware_header_v2_1 *v2_1_hdr;\n\n\tDRM_DEBUG(\"SMC\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tv1_0_hdr = container_of(hdr, struct smc_firmware_header_v1_0, header);\n\t\tDRM_DEBUG(\"ucode_start_addr: %u\\n\", le32_to_cpu(v1_0_hdr->ucode_start_addr));\n\t} else if (version_major == 2) {\n\t\tswitch (version_minor) {\n\t\tcase 0:\n\t\t\tv2_0_hdr = container_of(hdr, struct smc_firmware_header_v2_0, v1_0.header);\n\t\t\tDRM_DEBUG(\"ppt_offset_bytes: %u\\n\", le32_to_cpu(v2_0_hdr->ppt_offset_bytes));\n\t\t\tDRM_DEBUG(\"ppt_size_bytes: %u\\n\", le32_to_cpu(v2_0_hdr->ppt_size_bytes));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tv2_1_hdr = container_of(hdr, struct smc_firmware_header_v2_1, v1_0.header);\n\t\t\tDRM_DEBUG(\"pptable_count: %u\\n\", le32_to_cpu(v2_1_hdr->pptable_count));\n\t\t\tDRM_DEBUG(\"pptable_entry_offset: %u\\n\", le32_to_cpu(v2_1_hdr->pptable_entry_offset));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tDRM_ERROR(\"Unknown SMC ucode version: %u.%u\\n\", version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_gfx_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\n\tDRM_DEBUG(\"GFX\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct gfx_firmware_header_v1_0 *gfx_hdr =\n\t\t\tcontainer_of(hdr, struct gfx_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(gfx_hdr->ucode_feature_version));\n\t\tDRM_DEBUG(\"jt_offset: %u\\n\", le32_to_cpu(gfx_hdr->jt_offset));\n\t\tDRM_DEBUG(\"jt_size: %u\\n\", le32_to_cpu(gfx_hdr->jt_size));\n\t} else if (version_major == 2) {\n\t\tconst struct gfx_firmware_header_v2_0 *gfx_hdr =\n\t\t\tcontainer_of(hdr, struct gfx_firmware_header_v2_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(gfx_hdr->ucode_feature_version));\n\t} else {\n\t\tDRM_ERROR(\"Unknown GFX ucode version: %u.%u\\n\", version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_rlc_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\n\tDRM_DEBUG(\"RLC\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct rlc_firmware_header_v1_0 *rlc_hdr =\n\t\t\tcontainer_of(hdr, struct rlc_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(rlc_hdr->ucode_feature_version));\n\t\tDRM_DEBUG(\"save_and_restore_offset: %u\\n\",\n\t\t\t  le32_to_cpu(rlc_hdr->save_and_restore_offset));\n\t\tDRM_DEBUG(\"clear_state_descriptor_offset: %u\\n\",\n\t\t\t  le32_to_cpu(rlc_hdr->clear_state_descriptor_offset));\n\t\tDRM_DEBUG(\"avail_scratch_ram_locations: %u\\n\",\n\t\t\t  le32_to_cpu(rlc_hdr->avail_scratch_ram_locations));\n\t\tDRM_DEBUG(\"master_pkt_description_offset: %u\\n\",\n\t\t\t  le32_to_cpu(rlc_hdr->master_pkt_description_offset));\n\t} else if (version_major == 2) {\n\t\tconst struct rlc_firmware_header_v2_0 *rlc_hdr =\n\t\t\tcontainer_of(hdr, struct rlc_firmware_header_v2_0, header);\n\t\tconst struct rlc_firmware_header_v2_1 *rlc_hdr_v2_1 =\n\t\t\tcontainer_of(rlc_hdr, struct rlc_firmware_header_v2_1, v2_0);\n\t\tconst struct rlc_firmware_header_v2_2 *rlc_hdr_v2_2 =\n\t\t\tcontainer_of(rlc_hdr_v2_1, struct rlc_firmware_header_v2_2, v2_1);\n\t\tconst struct rlc_firmware_header_v2_3 *rlc_hdr_v2_3 =\n\t\t\tcontainer_of(rlc_hdr_v2_2, struct rlc_firmware_header_v2_3, v2_2);\n\t\tconst struct rlc_firmware_header_v2_4 *rlc_hdr_v2_4 =\n\t\t\tcontainer_of(rlc_hdr_v2_3, struct rlc_firmware_header_v2_4, v2_3);\n\n\t\tswitch (version_minor) {\n\t\tcase 0:\n\t\t\t \n\t\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->ucode_feature_version));\n\t\t\tDRM_DEBUG(\"jt_offset: %u\\n\", le32_to_cpu(rlc_hdr->jt_offset));\n\t\t\tDRM_DEBUG(\"jt_size: %u\\n\", le32_to_cpu(rlc_hdr->jt_size));\n\t\t\tDRM_DEBUG(\"save_and_restore_offset: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->save_and_restore_offset));\n\t\t\tDRM_DEBUG(\"clear_state_descriptor_offset: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->clear_state_descriptor_offset));\n\t\t\tDRM_DEBUG(\"avail_scratch_ram_locations: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->avail_scratch_ram_locations));\n\t\t\tDRM_DEBUG(\"reg_restore_list_size: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_restore_list_size));\n\t\t\tDRM_DEBUG(\"reg_list_format_start: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_start));\n\t\t\tDRM_DEBUG(\"reg_list_format_separate_start: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_separate_start));\n\t\t\tDRM_DEBUG(\"starting_offsets_start: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->starting_offsets_start));\n\t\t\tDRM_DEBUG(\"reg_list_format_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_size_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_format_array_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_array_offset_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_size_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_array_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_array_offset_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_format_separate_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_separate_size_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_format_separate_array_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_format_separate_array_offset_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_separate_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_separate_size_bytes));\n\t\t\tDRM_DEBUG(\"reg_list_separate_array_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr->reg_list_separate_array_offset_bytes));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tDRM_DEBUG(\"reg_list_format_direct_reg_list_length: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->reg_list_format_direct_reg_list_length));\n\t\t\tDRM_DEBUG(\"save_restore_list_cntl_ucode_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_cntl_ucode_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_cntl_feature_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_cntl_feature_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_cntl_size_bytes %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_cntl_size_bytes));\n\t\t\tDRM_DEBUG(\"save_restore_list_cntl_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_cntl_offset_bytes));\n\t\t\tDRM_DEBUG(\"save_restore_list_gpm_ucode_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_gpm_ucode_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_gpm_feature_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_gpm_feature_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_gpm_size_bytes %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_gpm_size_bytes));\n\t\t\tDRM_DEBUG(\"save_restore_list_gpm_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_gpm_offset_bytes));\n\t\t\tDRM_DEBUG(\"save_restore_list_srm_ucode_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_srm_ucode_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_srm_feature_ver: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_srm_feature_ver));\n\t\t\tDRM_DEBUG(\"save_restore_list_srm_size_bytes %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_srm_size_bytes));\n\t\t\tDRM_DEBUG(\"save_restore_list_srm_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_1->save_restore_list_srm_offset_bytes));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tDRM_DEBUG(\"rlc_iram_ucode_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_2->rlc_iram_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"rlc_iram_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_2->rlc_iram_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"rlc_dram_ucode_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_2->rlc_dram_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"rlc_dram_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_2->rlc_dram_ucode_offset_bytes));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tDRM_DEBUG(\"rlcp_ucode_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcp_ucode_version));\n\t\t\tDRM_DEBUG(\"rlcp_ucode_feature_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcp_ucode_feature_version));\n\t\t\tDRM_DEBUG(\"rlcp_ucode_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcp_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"rlcp_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcp_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"rlcv_ucode_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcv_ucode_version));\n\t\t\tDRM_DEBUG(\"rlcv_ucode_feature_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcv_ucode_feature_version));\n\t\t\tDRM_DEBUG(\"rlcv_ucode_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcv_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"rlcv_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_3->rlcv_ucode_offset_bytes));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\tDRM_DEBUG(\"global_tap_delays_ucode_size_bytes :%u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->global_tap_delays_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"global_tap_delays_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->global_tap_delays_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"se0_tap_delays_ucode_size_bytes :%u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se0_tap_delays_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"se0_tap_delays_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se0_tap_delays_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"se1_tap_delays_ucode_size_bytes :%u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se1_tap_delays_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"se1_tap_delays_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se1_tap_delays_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"se2_tap_delays_ucode_size_bytes :%u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se2_tap_delays_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"se2_tap_delays_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se2_tap_delays_ucode_offset_bytes));\n\t\t\tDRM_DEBUG(\"se3_tap_delays_ucode_size_bytes :%u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se3_tap_delays_ucode_size_bytes));\n\t\t\tDRM_DEBUG(\"se3_tap_delays_ucode_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(rlc_hdr_v2_4->se3_tap_delays_ucode_offset_bytes));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown RLC v2 ucode: v2.%u\\n\", version_minor);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDRM_ERROR(\"Unknown RLC ucode version: %u.%u\\n\", version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_sdma_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\n\tDRM_DEBUG(\"SDMA\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct sdma_firmware_header_v1_0 *sdma_hdr =\n\t\t\tcontainer_of(hdr, struct sdma_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(sdma_hdr->ucode_feature_version));\n\t\tDRM_DEBUG(\"ucode_change_version: %u\\n\",\n\t\t\t  le32_to_cpu(sdma_hdr->ucode_change_version));\n\t\tDRM_DEBUG(\"jt_offset: %u\\n\", le32_to_cpu(sdma_hdr->jt_offset));\n\t\tDRM_DEBUG(\"jt_size: %u\\n\", le32_to_cpu(sdma_hdr->jt_size));\n\t\tif (version_minor >= 1) {\n\t\t\tconst struct sdma_firmware_header_v1_1 *sdma_v1_1_hdr =\n\t\t\t\tcontainer_of(sdma_hdr, struct sdma_firmware_header_v1_1, v1_0);\n\t\t\tDRM_DEBUG(\"digest_size: %u\\n\", le32_to_cpu(sdma_v1_1_hdr->digest_size));\n\t\t}\n\t} else if (version_major == 2) {\n\t\tconst struct sdma_firmware_header_v2_0 *sdma_hdr =\n\t\t\tcontainer_of(hdr, struct sdma_firmware_header_v2_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(sdma_hdr->ucode_feature_version));\n\t\tDRM_DEBUG(\"ctx_jt_offset: %u\\n\", le32_to_cpu(sdma_hdr->ctx_jt_offset));\n\t\tDRM_DEBUG(\"ctx_jt_size: %u\\n\", le32_to_cpu(sdma_hdr->ctx_jt_size));\n\t\tDRM_DEBUG(\"ctl_ucode_offset: %u\\n\", le32_to_cpu(sdma_hdr->ctl_ucode_offset));\n\t\tDRM_DEBUG(\"ctl_jt_offset: %u\\n\", le32_to_cpu(sdma_hdr->ctl_jt_offset));\n\t\tDRM_DEBUG(\"ctl_jt_size: %u\\n\", le32_to_cpu(sdma_hdr->ctl_jt_size));\n\t} else {\n\t\tDRM_ERROR(\"Unknown SDMA ucode version: %u.%u\\n\",\n\t\t\t  version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_psp_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\tuint32_t fw_index;\n\tconst struct psp_fw_bin_desc *desc;\n\n\tDRM_DEBUG(\"PSP\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct psp_firmware_header_v1_0 *psp_hdr =\n\t\t\tcontainer_of(hdr, struct psp_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"ucode_feature_version: %u\\n\",\n\t\t\t  le32_to_cpu(psp_hdr->sos.fw_version));\n\t\tDRM_DEBUG(\"sos_offset_bytes: %u\\n\",\n\t\t\t  le32_to_cpu(psp_hdr->sos.offset_bytes));\n\t\tDRM_DEBUG(\"sos_size_bytes: %u\\n\",\n\t\t\t  le32_to_cpu(psp_hdr->sos.size_bytes));\n\t\tif (version_minor == 1) {\n\t\t\tconst struct psp_firmware_header_v1_1 *psp_hdr_v1_1 =\n\t\t\t\tcontainer_of(psp_hdr, struct psp_firmware_header_v1_1, v1_0);\n\t\t\tDRM_DEBUG(\"toc_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->toc.fw_version));\n\t\t\tDRM_DEBUG(\"toc_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->toc.offset_bytes));\n\t\t\tDRM_DEBUG(\"toc_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->toc.size_bytes));\n\t\t\tDRM_DEBUG(\"kdb_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->kdb.fw_version));\n\t\t\tDRM_DEBUG(\"kdb_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->kdb.offset_bytes));\n\t\t\tDRM_DEBUG(\"kdb_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_1->kdb.size_bytes));\n\t\t}\n\t\tif (version_minor == 2) {\n\t\t\tconst struct psp_firmware_header_v1_2 *psp_hdr_v1_2 =\n\t\t\t\tcontainer_of(psp_hdr, struct psp_firmware_header_v1_2, v1_0);\n\t\t\tDRM_DEBUG(\"kdb_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_2->kdb.fw_version));\n\t\t\tDRM_DEBUG(\"kdb_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_2->kdb.offset_bytes));\n\t\t\tDRM_DEBUG(\"kdb_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_2->kdb.size_bytes));\n\t\t}\n\t\tif (version_minor == 3) {\n\t\t\tconst struct psp_firmware_header_v1_1 *psp_hdr_v1_1 =\n\t\t\t\tcontainer_of(psp_hdr, struct psp_firmware_header_v1_1, v1_0);\n\t\t\tconst struct psp_firmware_header_v1_3 *psp_hdr_v1_3 =\n\t\t\t\tcontainer_of(psp_hdr_v1_1, struct psp_firmware_header_v1_3, v1_1);\n\t\t\tDRM_DEBUG(\"toc_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.toc.fw_version));\n\t\t\tDRM_DEBUG(\"toc_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.toc.offset_bytes));\n\t\t\tDRM_DEBUG(\"toc_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.toc.size_bytes));\n\t\t\tDRM_DEBUG(\"kdb_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.kdb.fw_version));\n\t\t\tDRM_DEBUG(\"kdb_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.kdb.offset_bytes));\n\t\t\tDRM_DEBUG(\"kdb_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->v1_1.kdb.size_bytes));\n\t\t\tDRM_DEBUG(\"spl_header_version: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->spl.fw_version));\n\t\t\tDRM_DEBUG(\"spl_offset_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->spl.offset_bytes));\n\t\t\tDRM_DEBUG(\"spl_size_bytes: %u\\n\",\n\t\t\t\t  le32_to_cpu(psp_hdr_v1_3->spl.size_bytes));\n\t\t}\n\t} else if (version_major == 2) {\n\t\tconst struct psp_firmware_header_v2_0 *psp_hdr_v2_0 =\n\t\t\t container_of(hdr, struct psp_firmware_header_v2_0, header);\n\t\tfor (fw_index = 0; fw_index < le32_to_cpu(psp_hdr_v2_0->psp_fw_bin_count); fw_index++) {\n\t\t\tdesc = &(psp_hdr_v2_0->psp_fw_bin[fw_index]);\n\t\t\tswitch (desc->fw_type) {\n\t\t\tcase PSP_FW_TYPE_PSP_SOS:\n\t\t\t\tDRM_DEBUG(\"psp_sos_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_sos_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_SYS_DRV:\n\t\t\t\tDRM_DEBUG(\"psp_sys_drv_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_sys_drv_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_KDB:\n\t\t\t\tDRM_DEBUG(\"psp_kdb_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_kdb_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_TOC:\n\t\t\t\tDRM_DEBUG(\"psp_toc_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_toc_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_SPL:\n\t\t\t\tDRM_DEBUG(\"psp_spl_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_spl_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_RL:\n\t\t\t\tDRM_DEBUG(\"psp_rl_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_rl_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_SOC_DRV:\n\t\t\t\tDRM_DEBUG(\"psp_soc_drv_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_soc_drv_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_INTF_DRV:\n\t\t\t\tDRM_DEBUG(\"psp_intf_drv_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_intf_drv_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_DBG_DRV:\n\t\t\t\tDRM_DEBUG(\"psp_dbg_drv_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_dbg_drv_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tcase PSP_FW_TYPE_PSP_RAS_DRV:\n\t\t\t\tDRM_DEBUG(\"psp_ras_drv_version: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->fw_version));\n\t\t\t\tDRM_DEBUG(\"psp_ras_drv_size_bytes: %u\\n\",\n\t\t\t\t\t  le32_to_cpu(desc->size_bytes));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unsupported PSP fw type: %d\\n\", desc->fw_type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDRM_ERROR(\"Unknown PSP ucode version: %u.%u\\n\",\n\t\t\t  version_major, version_minor);\n\t}\n}\n\nvoid amdgpu_ucode_print_gpu_info_hdr(const struct common_firmware_header *hdr)\n{\n\tuint16_t version_major = le16_to_cpu(hdr->header_version_major);\n\tuint16_t version_minor = le16_to_cpu(hdr->header_version_minor);\n\n\tDRM_DEBUG(\"GPU_INFO\\n\");\n\tamdgpu_ucode_print_common_hdr(hdr);\n\n\tif (version_major == 1) {\n\t\tconst struct gpu_info_firmware_header_v1_0 *gpu_info_hdr =\n\t\t\tcontainer_of(hdr, struct gpu_info_firmware_header_v1_0, header);\n\n\t\tDRM_DEBUG(\"version_major: %u\\n\",\n\t\t\t  le16_to_cpu(gpu_info_hdr->version_major));\n\t\tDRM_DEBUG(\"version_minor: %u\\n\",\n\t\t\t  le16_to_cpu(gpu_info_hdr->version_minor));\n\t} else {\n\t\tDRM_ERROR(\"Unknown gpu_info ucode version: %u.%u\\n\", version_major, version_minor);\n\t}\n}\n\nstatic int amdgpu_ucode_validate(const struct firmware *fw)\n{\n\tconst struct common_firmware_header *hdr =\n\t\t(const struct common_firmware_header *)fw->data;\n\n\tif (fw->size == le32_to_cpu(hdr->size_bytes))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nbool amdgpu_ucode_hdr_version(union amdgpu_firmware_header *hdr,\n\t\t\t\tuint16_t hdr_major, uint16_t hdr_minor)\n{\n\tif ((hdr->common.header_version_major == hdr_major) &&\n\t\t(hdr->common.header_version_minor == hdr_minor))\n\t\treturn true;\n\treturn false;\n}\n\nenum amdgpu_firmware_load_type\namdgpu_ucode_get_load_type(struct amdgpu_device *adev, int load_type)\n{\n\tswitch (adev->asic_type) {\n#ifdef CONFIG_DRM_AMDGPU_SI\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n\tcase CHIP_HAINAN:\n\t\treturn AMDGPU_FW_LOAD_DIRECT;\n#endif\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\tcase CHIP_BONAIRE:\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_HAWAII:\n\tcase CHIP_MULLINS:\n\t\treturn AMDGPU_FW_LOAD_DIRECT;\n#endif\n\tcase CHIP_TOPAZ:\n\tcase CHIP_TONGA:\n\tcase CHIP_FIJI:\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\t\treturn AMDGPU_FW_LOAD_SMU;\n\tcase CHIP_CYAN_SKILLFISH:\n\t\tif (!(load_type &&\n\t\t      adev->apu_flags & AMD_APU_IS_CYAN_SKILLFISH2))\n\t\t\treturn AMDGPU_FW_LOAD_DIRECT;\n\t\telse\n\t\t\treturn AMDGPU_FW_LOAD_PSP;\n\tdefault:\n\t\tif (!load_type)\n\t\t\treturn AMDGPU_FW_LOAD_DIRECT;\n\t\telse\n\t\t\treturn AMDGPU_FW_LOAD_PSP;\n\t}\n}\n\nconst char *amdgpu_ucode_name(enum AMDGPU_UCODE_ID ucode_id)\n{\n\tswitch (ucode_id) {\n\tcase AMDGPU_UCODE_ID_SDMA0:\n\t\treturn \"SDMA0\";\n\tcase AMDGPU_UCODE_ID_SDMA1:\n\t\treturn \"SDMA1\";\n\tcase AMDGPU_UCODE_ID_SDMA2:\n\t\treturn \"SDMA2\";\n\tcase AMDGPU_UCODE_ID_SDMA3:\n\t\treturn \"SDMA3\";\n\tcase AMDGPU_UCODE_ID_SDMA4:\n\t\treturn \"SDMA4\";\n\tcase AMDGPU_UCODE_ID_SDMA5:\n\t\treturn \"SDMA5\";\n\tcase AMDGPU_UCODE_ID_SDMA6:\n\t\treturn \"SDMA6\";\n\tcase AMDGPU_UCODE_ID_SDMA7:\n\t\treturn \"SDMA7\";\n\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH0:\n\t\treturn \"SDMA_CTX\";\n\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH1:\n\t\treturn \"SDMA_CTL\";\n\tcase AMDGPU_UCODE_ID_CP_CE:\n\t\treturn \"CP_CE\";\n\tcase AMDGPU_UCODE_ID_CP_PFP:\n\t\treturn \"CP_PFP\";\n\tcase AMDGPU_UCODE_ID_CP_ME:\n\t\treturn \"CP_ME\";\n\tcase AMDGPU_UCODE_ID_CP_MEC1:\n\t\treturn \"CP_MEC1\";\n\tcase AMDGPU_UCODE_ID_CP_MEC1_JT:\n\t\treturn \"CP_MEC1_JT\";\n\tcase AMDGPU_UCODE_ID_CP_MEC2:\n\t\treturn \"CP_MEC2\";\n\tcase AMDGPU_UCODE_ID_CP_MEC2_JT:\n\t\treturn \"CP_MEC2_JT\";\n\tcase AMDGPU_UCODE_ID_CP_MES:\n\t\treturn \"CP_MES\";\n\tcase AMDGPU_UCODE_ID_CP_MES_DATA:\n\t\treturn \"CP_MES_DATA\";\n\tcase AMDGPU_UCODE_ID_CP_MES1:\n\t\treturn \"CP_MES_KIQ\";\n\tcase AMDGPU_UCODE_ID_CP_MES1_DATA:\n\t\treturn \"CP_MES_KIQ_DATA\";\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL:\n\t\treturn \"RLC_RESTORE_LIST_CNTL\";\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM:\n\t\treturn \"RLC_RESTORE_LIST_GPM_MEM\";\n\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM:\n\t\treturn \"RLC_RESTORE_LIST_SRM_MEM\";\n\tcase AMDGPU_UCODE_ID_RLC_IRAM:\n\t\treturn \"RLC_IRAM\";\n\tcase AMDGPU_UCODE_ID_RLC_DRAM:\n\t\treturn \"RLC_DRAM\";\n\tcase AMDGPU_UCODE_ID_RLC_G:\n\t\treturn \"RLC_G\";\n\tcase AMDGPU_UCODE_ID_RLC_P:\n\t\treturn \"RLC_P\";\n\tcase AMDGPU_UCODE_ID_RLC_V:\n\t\treturn \"RLC_V\";\n\tcase AMDGPU_UCODE_ID_GLOBAL_TAP_DELAYS:\n\t\treturn \"GLOBAL_TAP_DELAYS\";\n\tcase AMDGPU_UCODE_ID_SE0_TAP_DELAYS:\n\t\treturn \"SE0_TAP_DELAYS\";\n\tcase AMDGPU_UCODE_ID_SE1_TAP_DELAYS:\n\t\treturn \"SE1_TAP_DELAYS\";\n\tcase AMDGPU_UCODE_ID_SE2_TAP_DELAYS:\n\t\treturn \"SE2_TAP_DELAYS\";\n\tcase AMDGPU_UCODE_ID_SE3_TAP_DELAYS:\n\t\treturn \"SE3_TAP_DELAYS\";\n\tcase AMDGPU_UCODE_ID_IMU_I:\n\t\treturn \"IMU_I\";\n\tcase AMDGPU_UCODE_ID_IMU_D:\n\t\treturn \"IMU_D\";\n\tcase AMDGPU_UCODE_ID_STORAGE:\n\t\treturn \"STORAGE\";\n\tcase AMDGPU_UCODE_ID_SMC:\n\t\treturn \"SMC\";\n\tcase AMDGPU_UCODE_ID_PPTABLE:\n\t\treturn \"PPTABLE\";\n\tcase AMDGPU_UCODE_ID_UVD:\n\t\treturn \"UVD\";\n\tcase AMDGPU_UCODE_ID_UVD1:\n\t\treturn \"UVD1\";\n\tcase AMDGPU_UCODE_ID_VCE:\n\t\treturn \"VCE\";\n\tcase AMDGPU_UCODE_ID_VCN:\n\t\treturn \"VCN\";\n\tcase AMDGPU_UCODE_ID_VCN1:\n\t\treturn \"VCN1\";\n\tcase AMDGPU_UCODE_ID_DMCU_ERAM:\n\t\treturn \"DMCU_ERAM\";\n\tcase AMDGPU_UCODE_ID_DMCU_INTV:\n\t\treturn \"DMCU_INTV\";\n\tcase AMDGPU_UCODE_ID_VCN0_RAM:\n\t\treturn \"VCN0_RAM\";\n\tcase AMDGPU_UCODE_ID_VCN1_RAM:\n\t\treturn \"VCN1_RAM\";\n\tcase AMDGPU_UCODE_ID_DMCUB:\n\t\treturn \"DMCUB\";\n\tcase AMDGPU_UCODE_ID_CAP:\n\t\treturn \"CAP\";\n\tdefault:\n\t\treturn \"UNKNOWN UCODE\";\n\t}\n}\n\n#define FW_VERSION_ATTR(name, mode, field)\t\t\t\t\\\nstatic ssize_t show_##name(struct device *dev,\t\t\t\t\\\n\t\t\t  struct device_attribute *attr,\t\t\\\n\t\t\t  char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\t\t\t\\\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"0x%08x\\n\", adev->field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, mode, show_##name, NULL)\n\nFW_VERSION_ATTR(vce_fw_version, 0444, vce.fw_version);\nFW_VERSION_ATTR(uvd_fw_version, 0444, uvd.fw_version);\nFW_VERSION_ATTR(mc_fw_version, 0444, gmc.fw_version);\nFW_VERSION_ATTR(me_fw_version, 0444, gfx.me_fw_version);\nFW_VERSION_ATTR(pfp_fw_version, 0444, gfx.pfp_fw_version);\nFW_VERSION_ATTR(ce_fw_version, 0444, gfx.ce_fw_version);\nFW_VERSION_ATTR(rlc_fw_version, 0444, gfx.rlc_fw_version);\nFW_VERSION_ATTR(rlc_srlc_fw_version, 0444, gfx.rlc_srlc_fw_version);\nFW_VERSION_ATTR(rlc_srlg_fw_version, 0444, gfx.rlc_srlg_fw_version);\nFW_VERSION_ATTR(rlc_srls_fw_version, 0444, gfx.rlc_srls_fw_version);\nFW_VERSION_ATTR(mec_fw_version, 0444, gfx.mec_fw_version);\nFW_VERSION_ATTR(mec2_fw_version, 0444, gfx.mec2_fw_version);\nFW_VERSION_ATTR(imu_fw_version, 0444, gfx.imu_fw_version);\nFW_VERSION_ATTR(sos_fw_version, 0444, psp.sos.fw_version);\nFW_VERSION_ATTR(asd_fw_version, 0444, psp.asd_context.bin_desc.fw_version);\nFW_VERSION_ATTR(ta_ras_fw_version, 0444, psp.ras_context.context.bin_desc.fw_version);\nFW_VERSION_ATTR(ta_xgmi_fw_version, 0444, psp.xgmi_context.context.bin_desc.fw_version);\nFW_VERSION_ATTR(smc_fw_version, 0444, pm.fw_version);\nFW_VERSION_ATTR(sdma_fw_version, 0444, sdma.instance[0].fw_version);\nFW_VERSION_ATTR(sdma2_fw_version, 0444, sdma.instance[1].fw_version);\nFW_VERSION_ATTR(vcn_fw_version, 0444, vcn.fw_version);\nFW_VERSION_ATTR(dmcu_fw_version, 0444, dm.dmcu_fw_version);\nFW_VERSION_ATTR(mes_fw_version, 0444, mes.sched_version & AMDGPU_MES_VERSION_MASK);\nFW_VERSION_ATTR(mes_kiq_fw_version, 0444, mes.kiq_version & AMDGPU_MES_VERSION_MASK);\n\nstatic struct attribute *fw_attrs[] = {\n\t&dev_attr_vce_fw_version.attr, &dev_attr_uvd_fw_version.attr,\n\t&dev_attr_mc_fw_version.attr, &dev_attr_me_fw_version.attr,\n\t&dev_attr_pfp_fw_version.attr, &dev_attr_ce_fw_version.attr,\n\t&dev_attr_rlc_fw_version.attr, &dev_attr_rlc_srlc_fw_version.attr,\n\t&dev_attr_rlc_srlg_fw_version.attr, &dev_attr_rlc_srls_fw_version.attr,\n\t&dev_attr_mec_fw_version.attr, &dev_attr_mec2_fw_version.attr,\n\t&dev_attr_sos_fw_version.attr, &dev_attr_asd_fw_version.attr,\n\t&dev_attr_ta_ras_fw_version.attr, &dev_attr_ta_xgmi_fw_version.attr,\n\t&dev_attr_smc_fw_version.attr, &dev_attr_sdma_fw_version.attr,\n\t&dev_attr_sdma2_fw_version.attr, &dev_attr_vcn_fw_version.attr,\n\t&dev_attr_dmcu_fw_version.attr, &dev_attr_imu_fw_version.attr,\n\t&dev_attr_mes_fw_version.attr, &dev_attr_mes_kiq_fw_version.attr,\n\tNULL\n};\n\nstatic const struct attribute_group fw_attr_group = {\n\t.name = \"fw_version\",\n\t.attrs = fw_attrs\n};\n\nint amdgpu_ucode_sysfs_init(struct amdgpu_device *adev)\n{\n\treturn sysfs_create_group(&adev->dev->kobj, &fw_attr_group);\n}\n\nvoid amdgpu_ucode_sysfs_fini(struct amdgpu_device *adev)\n{\n\tsysfs_remove_group(&adev->dev->kobj, &fw_attr_group);\n}\n\nstatic int amdgpu_ucode_init_single_fw(struct amdgpu_device *adev,\n\t\t\t\t       struct amdgpu_firmware_info *ucode,\n\t\t\t\t       uint64_t mc_addr, void *kptr)\n{\n\tconst struct common_firmware_header *header = NULL;\n\tconst struct gfx_firmware_header_v1_0 *cp_hdr = NULL;\n\tconst struct gfx_firmware_header_v2_0 *cpv2_hdr = NULL;\n\tconst struct dmcu_firmware_header_v1_0 *dmcu_hdr = NULL;\n\tconst struct dmcub_firmware_header_v1_0 *dmcub_hdr = NULL;\n\tconst struct mes_firmware_header_v1_0 *mes_hdr = NULL;\n\tconst struct sdma_firmware_header_v2_0 *sdma_hdr = NULL;\n\tconst struct imu_firmware_header_v1_0 *imu_hdr = NULL;\n\tu8 *ucode_addr;\n\n\tif (!ucode->fw)\n\t\treturn 0;\n\n\tucode->mc_addr = mc_addr;\n\tucode->kaddr = kptr;\n\n\tif (ucode->ucode_id == AMDGPU_UCODE_ID_STORAGE)\n\t\treturn 0;\n\n\theader = (const struct common_firmware_header *)ucode->fw->data;\n\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\n\tcpv2_hdr = (const struct gfx_firmware_header_v2_0 *)ucode->fw->data;\n\tdmcu_hdr = (const struct dmcu_firmware_header_v1_0 *)ucode->fw->data;\n\tdmcub_hdr = (const struct dmcub_firmware_header_v1_0 *)ucode->fw->data;\n\tmes_hdr = (const struct mes_firmware_header_v1_0 *)ucode->fw->data;\n\tsdma_hdr = (const struct sdma_firmware_header_v2_0 *)ucode->fw->data;\n\timu_hdr = (const struct imu_firmware_header_v1_0 *)ucode->fw->data;\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tswitch (ucode->ucode_id) {\n\t\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH0:\n\t\t\tucode->ucode_size = le32_to_cpu(sdma_hdr->ctx_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(sdma_hdr->header.ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_SDMA_UCODE_TH1:\n\t\t\tucode->ucode_size = le32_to_cpu(sdma_hdr->ctl_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(sdma_hdr->ctl_ucode_offset);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MEC1:\n\t\tcase AMDGPU_UCODE_ID_CP_MEC2:\n\t\t\tucode->ucode_size = le32_to_cpu(header->ucode_size_bytes) -\n\t\t\t\tle32_to_cpu(cp_hdr->jt_size) * 4;\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MEC1_JT:\n\t\tcase AMDGPU_UCODE_ID_CP_MEC2_JT:\n\t\t\tucode->ucode_size = le32_to_cpu(cp_hdr->jt_size) * 4;\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes) +\n\t\t\t\tle32_to_cpu(cp_hdr->jt_offset) * 4;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL:\n\t\t\tucode->ucode_size = adev->gfx.rlc.save_restore_list_cntl_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.save_restore_list_cntl;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM:\n\t\t\tucode->ucode_size = adev->gfx.rlc.save_restore_list_gpm_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.save_restore_list_gpm;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM:\n\t\t\tucode->ucode_size = adev->gfx.rlc.save_restore_list_srm_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.save_restore_list_srm;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_IRAM:\n\t\t\tucode->ucode_size = adev->gfx.rlc.rlc_iram_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.rlc_iram_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_DRAM:\n\t\t\tucode->ucode_size = adev->gfx.rlc.rlc_dram_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.rlc_dram_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_P:\n\t\t\tucode->ucode_size = adev->gfx.rlc.rlcp_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.rlcp_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_RLC_V:\n\t\t\tucode->ucode_size = adev->gfx.rlc.rlcv_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.rlcv_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_GLOBAL_TAP_DELAYS:\n\t\t\tucode->ucode_size = adev->gfx.rlc.global_tap_delays_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.global_tap_delays_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_SE0_TAP_DELAYS:\n\t\t\tucode->ucode_size = adev->gfx.rlc.se0_tap_delays_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.se0_tap_delays_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_SE1_TAP_DELAYS:\n\t\t\tucode->ucode_size = adev->gfx.rlc.se1_tap_delays_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.se1_tap_delays_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_SE2_TAP_DELAYS:\n\t\t\tucode->ucode_size = adev->gfx.rlc.se2_tap_delays_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.se2_tap_delays_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_SE3_TAP_DELAYS:\n\t\t\tucode->ucode_size = adev->gfx.rlc.se3_tap_delays_ucode_size_bytes;\n\t\t\tucode_addr = adev->gfx.rlc.se3_tap_delays_ucode;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MES:\n\t\t\tucode->ucode_size = le32_to_cpu(mes_hdr->mes_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MES_DATA:\n\t\t\tucode->ucode_size = le32_to_cpu(mes_hdr->mes_ucode_data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MES1:\n\t\t\tucode->ucode_size = le32_to_cpu(mes_hdr->mes_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_MES1_DATA:\n\t\t\tucode->ucode_size = le32_to_cpu(mes_hdr->mes_ucode_data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_DMCU_ERAM:\n\t\t\tucode->ucode_size = le32_to_cpu(header->ucode_size_bytes) -\n\t\t\t\tle32_to_cpu(dmcu_hdr->intv_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_DMCU_INTV:\n\t\t\tucode->ucode_size = le32_to_cpu(dmcu_hdr->intv_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes) +\n\t\t\t\tle32_to_cpu(dmcu_hdr->intv_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_DMCUB:\n\t\t\tucode->ucode_size = le32_to_cpu(dmcub_hdr->inst_const_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_PPTABLE:\n\t\t\tucode->ucode_size = ucode->fw->size;\n\t\t\tucode_addr = (u8 *)ucode->fw->data;\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_IMU_I:\n\t\t\tucode->ucode_size = le32_to_cpu(imu_hdr->imu_iram_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(imu_hdr->header.ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_IMU_D:\n\t\t\tucode->ucode_size = le32_to_cpu(imu_hdr->imu_dram_ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(imu_hdr->header.ucode_array_offset_bytes) +\n\t\t\t\tle32_to_cpu(imu_hdr->imu_iram_ucode_size_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_PFP:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P0_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P1_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_ME:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P0_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P1_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_MEC:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P0_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P1_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P2_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P3_STACK:\n\t\t\tucode->ucode_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tucode->ucode_size = le32_to_cpu(header->ucode_size_bytes);\n\t\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tucode->ucode_size = le32_to_cpu(header->ucode_size_bytes);\n\t\tucode_addr = (u8 *)ucode->fw->data +\n\t\t\tle32_to_cpu(header->ucode_array_offset_bytes);\n\t}\n\n\tmemcpy(ucode->kaddr, ucode_addr, ucode->ucode_size);\n\n\treturn 0;\n}\n\nstatic int amdgpu_ucode_patch_jt(struct amdgpu_firmware_info *ucode,\n\t\t\t\tuint64_t mc_addr, void *kptr)\n{\n\tconst struct gfx_firmware_header_v1_0 *header = NULL;\n\tconst struct common_firmware_header *comm_hdr = NULL;\n\tuint8_t *src_addr = NULL;\n\tuint8_t *dst_addr = NULL;\n\n\tif (!ucode->fw)\n\t\treturn 0;\n\n\tcomm_hdr = (const struct common_firmware_header *)ucode->fw->data;\n\theader = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\n\tdst_addr = ucode->kaddr +\n\t\t\t   ALIGN(le32_to_cpu(comm_hdr->ucode_size_bytes),\n\t\t\t   PAGE_SIZE);\n\tsrc_addr = (uint8_t *)ucode->fw->data +\n\t\t\t   le32_to_cpu(comm_hdr->ucode_array_offset_bytes) +\n\t\t\t   (le32_to_cpu(header->jt_offset) * 4);\n\tmemcpy(dst_addr, src_addr, le32_to_cpu(header->jt_size) * 4);\n\n\treturn 0;\n}\n\nint amdgpu_ucode_create_bo(struct amdgpu_device *adev)\n{\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_DIRECT) {\n\t\tamdgpu_bo_create_kernel(adev, adev->firmware.fw_size, PAGE_SIZE,\n\t\t\tamdgpu_sriov_vf(adev) ? AMDGPU_GEM_DOMAIN_VRAM : AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t&adev->firmware.fw_buf,\n\t\t\t&adev->firmware.fw_buf_mc,\n\t\t\t&adev->firmware.fw_buf_ptr);\n\t\tif (!adev->firmware.fw_buf) {\n\t\t\tdev_err(adev->dev, \"failed to create kernel buffer for firmware.fw_buf\\n\");\n\t\t\treturn -ENOMEM;\n\t\t} else if (amdgpu_sriov_vf(adev)) {\n\t\t\tmemset(adev->firmware.fw_buf_ptr, 0, adev->firmware.fw_size);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid amdgpu_ucode_free_bo(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->firmware.fw_buf,\n\t\t&adev->firmware.fw_buf_mc,\n\t\t&adev->firmware.fw_buf_ptr);\n}\n\nint amdgpu_ucode_init_bo(struct amdgpu_device *adev)\n{\n\tuint64_t fw_offset = 0;\n\tint i;\n\tstruct amdgpu_firmware_info *ucode = NULL;\n\n  \n\tif (!amdgpu_sriov_vf(adev) && (amdgpu_in_reset(adev) || adev->in_suspend))\n\t\treturn 0;\n\t \n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\tif (amdgpu_sriov_vf(adev))\n\t\t\tadev->firmware.max_ucodes = AMDGPU_UCODE_ID_MAXIMUM - 3;\n\t\telse\n\t\t\tadev->firmware.max_ucodes = AMDGPU_UCODE_ID_MAXIMUM - 4;\n\t} else {\n\t\tadev->firmware.max_ucodes = AMDGPU_UCODE_ID_MAXIMUM;\n\t}\n\n\tfor (i = 0; i < adev->firmware.max_ucodes; i++) {\n\t\tucode = &adev->firmware.ucode[i];\n\t\tif (ucode->fw) {\n\t\t\tamdgpu_ucode_init_single_fw(adev, ucode, adev->firmware.fw_buf_mc + fw_offset,\n\t\t\t\t\t\t    adev->firmware.fw_buf_ptr + fw_offset);\n\t\t\tif (i == AMDGPU_UCODE_ID_CP_MEC1 &&\n\t\t\t    adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\t\t\tconst struct gfx_firmware_header_v1_0 *cp_hdr;\n\n\t\t\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\n\t\t\t\tamdgpu_ucode_patch_jt(ucode,  adev->firmware.fw_buf_mc + fw_offset,\n\t\t\t\t\t\t    adev->firmware.fw_buf_ptr + fw_offset);\n\t\t\t\tfw_offset += ALIGN(le32_to_cpu(cp_hdr->jt_size) << 2, PAGE_SIZE);\n\t\t\t}\n\t\t\tfw_offset += ALIGN(ucode->ucode_size, PAGE_SIZE);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char *amdgpu_ucode_legacy_naming(struct amdgpu_device *adev, int block_type)\n{\n\tif (block_type == MP0_HWIP) {\n\t\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\t\tcase IP_VERSION(9, 0, 0):\n\t\t\tswitch (adev->asic_type) {\n\t\t\tcase CHIP_VEGA10:\n\t\t\t\treturn \"vega10\";\n\t\t\tcase CHIP_VEGA12:\n\t\t\t\treturn \"vega12\";\n\t\t\tdefault:\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\tcase IP_VERSION(10, 0, 0):\n\t\tcase IP_VERSION(10, 0, 1):\n\t\t\tif (adev->asic_type == CHIP_RAVEN) {\n\t\t\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\t\t\treturn \"raven2\";\n\t\t\t\telse if (adev->apu_flags & AMD_APU_IS_PICASSO)\n\t\t\t\t\treturn \"picasso\";\n\t\t\t\treturn \"raven\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IP_VERSION(11, 0, 0):\n\t\t\treturn \"navi10\";\n\t\tcase IP_VERSION(11, 0, 2):\n\t\t\treturn \"vega20\";\n\t\tcase IP_VERSION(11, 0, 3):\n\t\t\treturn \"renoir\";\n\t\tcase IP_VERSION(11, 0, 4):\n\t\t\treturn \"arcturus\";\n\t\tcase IP_VERSION(11, 0, 5):\n\t\t\treturn \"navi14\";\n\t\tcase IP_VERSION(11, 0, 7):\n\t\t\treturn \"sienna_cichlid\";\n\t\tcase IP_VERSION(11, 0, 9):\n\t\t\treturn \"navi12\";\n\t\tcase IP_VERSION(11, 0, 11):\n\t\t\treturn \"navy_flounder\";\n\t\tcase IP_VERSION(11, 0, 12):\n\t\t\treturn \"dimgrey_cavefish\";\n\t\tcase IP_VERSION(11, 0, 13):\n\t\t\treturn \"beige_goby\";\n\t\tcase IP_VERSION(11, 5, 0):\n\t\t\treturn \"vangogh\";\n\t\tcase IP_VERSION(12, 0, 1):\n\t\t\treturn \"green_sardine\";\n\t\tcase IP_VERSION(13, 0, 2):\n\t\t\treturn \"aldebaran\";\n\t\tcase IP_VERSION(13, 0, 1):\n\t\tcase IP_VERSION(13, 0, 3):\n\t\t\treturn \"yellow_carp\";\n\t\t}\n\t} else if (block_type == MP1_HWIP) {\n\t\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\t\tcase IP_VERSION(9, 0, 0):\n\t\tcase IP_VERSION(10, 0, 0):\n\t\tcase IP_VERSION(10, 0, 1):\n\t\tcase IP_VERSION(11, 0, 2):\n\t\t\tif (adev->asic_type == CHIP_ARCTURUS)\n\t\t\t\treturn \"arcturus_smc\";\n\t\t\treturn NULL;\n\t\tcase IP_VERSION(11, 0, 0):\n\t\t\treturn \"navi10_smc\";\n\t\tcase IP_VERSION(11, 0, 5):\n\t\t\treturn \"navi14_smc\";\n\t\tcase IP_VERSION(11, 0, 9):\n\t\t\treturn \"navi12_smc\";\n\t\tcase IP_VERSION(11, 0, 7):\n\t\t\treturn \"sienna_cichlid_smc\";\n\t\tcase IP_VERSION(11, 0, 11):\n\t\t\treturn \"navy_flounder_smc\";\n\t\tcase IP_VERSION(11, 0, 12):\n\t\t\treturn \"dimgrey_cavefish_smc\";\n\t\tcase IP_VERSION(11, 0, 13):\n\t\t\treturn \"beige_goby_smc\";\n\t\tcase IP_VERSION(13, 0, 2):\n\t\t\treturn \"aldebaran_smc\";\n\t\t}\n\t} else if (block_type == SDMA0_HWIP) {\n\t\tswitch (adev->ip_versions[SDMA0_HWIP][0]) {\n\t\tcase IP_VERSION(4, 0, 0):\n\t\t\treturn \"vega10_sdma\";\n\t\tcase IP_VERSION(4, 0, 1):\n\t\t\treturn \"vega12_sdma\";\n\t\tcase IP_VERSION(4, 1, 0):\n\t\tcase IP_VERSION(4, 1, 1):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\t\treturn \"raven2_sdma\";\n\t\t\telse if (adev->apu_flags & AMD_APU_IS_PICASSO)\n\t\t\t\treturn \"picasso_sdma\";\n\t\t\treturn \"raven_sdma\";\n\t\tcase IP_VERSION(4, 1, 2):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RENOIR)\n\t\t\t\treturn \"renoir_sdma\";\n\t\t\treturn \"green_sardine_sdma\";\n\t\tcase IP_VERSION(4, 2, 0):\n\t\t\treturn \"vega20_sdma\";\n\t\tcase IP_VERSION(4, 2, 2):\n\t\t\treturn \"arcturus_sdma\";\n\t\tcase IP_VERSION(4, 4, 0):\n\t\t\treturn \"aldebaran_sdma\";\n\t\tcase IP_VERSION(5, 0, 0):\n\t\t\treturn \"navi10_sdma\";\n\t\tcase IP_VERSION(5, 0, 1):\n\t\t\treturn \"cyan_skillfish2_sdma\";\n\t\tcase IP_VERSION(5, 0, 2):\n\t\t\treturn \"navi14_sdma\";\n\t\tcase IP_VERSION(5, 0, 5):\n\t\t\treturn \"navi12_sdma\";\n\t\tcase IP_VERSION(5, 2, 0):\n\t\t\treturn \"sienna_cichlid_sdma\";\n\t\tcase IP_VERSION(5, 2, 2):\n\t\t\treturn \"navy_flounder_sdma\";\n\t\tcase IP_VERSION(5, 2, 4):\n\t\t\treturn \"dimgrey_cavefish_sdma\";\n\t\tcase IP_VERSION(5, 2, 5):\n\t\t\treturn \"beige_goby_sdma\";\n\t\tcase IP_VERSION(5, 2, 3):\n\t\t\treturn \"yellow_carp_sdma\";\n\t\tcase IP_VERSION(5, 2, 1):\n\t\t\treturn \"vangogh_sdma\";\n\t\t}\n\t} else if (block_type == UVD_HWIP) {\n\t\tswitch (adev->ip_versions[UVD_HWIP][0]) {\n\t\tcase IP_VERSION(1, 0, 0):\n\t\tcase IP_VERSION(1, 0, 1):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\t\treturn \"raven2_vcn\";\n\t\t\telse if (adev->apu_flags & AMD_APU_IS_PICASSO)\n\t\t\t\treturn \"picasso_vcn\";\n\t\t\treturn \"raven_vcn\";\n\t\tcase IP_VERSION(2, 5, 0):\n\t\t\treturn \"arcturus_vcn\";\n\t\tcase IP_VERSION(2, 2, 0):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RENOIR)\n\t\t\t\treturn \"renoir_vcn\";\n\t\t\treturn \"green_sardine_vcn\";\n\t\tcase IP_VERSION(2, 6, 0):\n\t\t\treturn \"aldebaran_vcn\";\n\t\tcase IP_VERSION(2, 0, 0):\n\t\t\treturn \"navi10_vcn\";\n\t\tcase IP_VERSION(2, 0, 2):\n\t\t\tif (adev->asic_type == CHIP_NAVI12)\n\t\t\t\treturn \"navi12_vcn\";\n\t\t\treturn \"navi14_vcn\";\n\t\tcase IP_VERSION(3, 0, 0):\n\t\tcase IP_VERSION(3, 0, 64):\n\t\tcase IP_VERSION(3, 0, 192):\n\t\t\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(10, 3, 0))\n\t\t\t\treturn \"sienna_cichlid_vcn\";\n\t\t\treturn \"navy_flounder_vcn\";\n\t\tcase IP_VERSION(3, 0, 2):\n\t\t\treturn \"vangogh_vcn\";\n\t\tcase IP_VERSION(3, 0, 16):\n\t\t\treturn \"dimgrey_cavefish_vcn\";\n\t\tcase IP_VERSION(3, 0, 33):\n\t\t\treturn \"beige_goby_vcn\";\n\t\tcase IP_VERSION(3, 1, 1):\n\t\t\treturn \"yellow_carp_vcn\";\n\t\t}\n\t} else if (block_type == GC_HWIP) {\n\t\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\t\tcase IP_VERSION(9, 0, 1):\n\t\t\treturn \"vega10\";\n\t\tcase IP_VERSION(9, 2, 1):\n\t\t\treturn \"vega12\";\n\t\tcase IP_VERSION(9, 4, 0):\n\t\t\treturn \"vega20\";\n\t\tcase IP_VERSION(9, 2, 2):\n\t\tcase IP_VERSION(9, 1, 0):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\t\treturn \"raven2\";\n\t\t\telse if (adev->apu_flags & AMD_APU_IS_PICASSO)\n\t\t\t\treturn \"picasso\";\n\t\t\treturn \"raven\";\n\t\tcase IP_VERSION(9, 4, 1):\n\t\t\treturn \"arcturus\";\n\t\tcase IP_VERSION(9, 3, 0):\n\t\t\tif (adev->apu_flags & AMD_APU_IS_RENOIR)\n\t\t\t\treturn \"renoir\";\n\t\t\treturn \"green_sardine\";\n\t\tcase IP_VERSION(9, 4, 2):\n\t\t\treturn \"aldebaran\";\n\t\tcase IP_VERSION(10, 1, 10):\n\t\t\treturn \"navi10\";\n\t\tcase IP_VERSION(10, 1, 1):\n\t\t\treturn \"navi14\";\n\t\tcase IP_VERSION(10, 1, 2):\n\t\t\treturn \"navi12\";\n\t\tcase IP_VERSION(10, 3, 0):\n\t\t\treturn \"sienna_cichlid\";\n\t\tcase IP_VERSION(10, 3, 2):\n\t\t\treturn \"navy_flounder\";\n\t\tcase IP_VERSION(10, 3, 1):\n\t\t\treturn \"vangogh\";\n\t\tcase IP_VERSION(10, 3, 4):\n\t\t\treturn \"dimgrey_cavefish\";\n\t\tcase IP_VERSION(10, 3, 5):\n\t\t\treturn \"beige_goby\";\n\t\tcase IP_VERSION(10, 3, 3):\n\t\t\treturn \"yellow_carp\";\n\t\tcase IP_VERSION(10, 1, 3):\n\t\tcase IP_VERSION(10, 1, 4):\n\t\t\treturn \"cyan_skillfish2\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid amdgpu_ucode_ip_version_decode(struct amdgpu_device *adev, int block_type, char *ucode_prefix, int len)\n{\n\tint maj, min, rev;\n\tchar *ip_name;\n\tconst char *legacy;\n\tuint32_t version = adev->ip_versions[block_type][0];\n\n\tlegacy = amdgpu_ucode_legacy_naming(adev, block_type);\n\tif (legacy) {\n\t\tsnprintf(ucode_prefix, len, \"%s\", legacy);\n\t\treturn;\n\t}\n\n\tswitch (block_type) {\n\tcase GC_HWIP:\n\t\tip_name = \"gc\";\n\t\tbreak;\n\tcase SDMA0_HWIP:\n\t\tip_name = \"sdma\";\n\t\tbreak;\n\tcase MP0_HWIP:\n\t\tip_name = \"psp\";\n\t\tbreak;\n\tcase MP1_HWIP:\n\t\tip_name = \"smu\";\n\t\tbreak;\n\tcase UVD_HWIP:\n\t\tip_name = \"vcn\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tmaj = IP_VERSION_MAJ(version);\n\tmin = IP_VERSION_MIN(version);\n\trev = IP_VERSION_REV(version);\n\n\tsnprintf(ucode_prefix, len, \"%s_%d_%d_%d\", ip_name, maj, min, rev);\n}\n\n \nint amdgpu_ucode_request(struct amdgpu_device *adev, const struct firmware **fw,\n\t\t\t const char *fw_name)\n{\n\tint err = request_firmware(fw, fw_name, adev->dev);\n\n\tif (err)\n\t\treturn -ENODEV;\n\terr = amdgpu_ucode_validate(*fw);\n\tif (err)\n\t\tdev_dbg(adev->dev, \"\\\"%s\\\" failed to validate\\n\", fw_name);\n\n\treturn err;\n}\n\n \nvoid amdgpu_ucode_release(const struct firmware **fw)\n{\n\trelease_firmware(*fw);\n\t*fw = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}