{
  "module_name": "amdgpu_amdkfd.c",
  "hash_id": "20c0e7bb6a2de75ff92d437dc851fbc104c37e8874aeae705313dd3024f45d1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c",
  "human_readable_source": "\n \n\n#include \"amdgpu_amdkfd.h\"\n#include \"amd_pcie.h\"\n#include \"amd_shared.h\"\n\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"amdgpu_dma_buf.h\"\n#include <linux/module.h>\n#include <linux/dma-buf.h>\n#include \"amdgpu_xgmi.h\"\n#include <uapi/linux/kfd_ioctl.h>\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_umc.h\"\n#include \"amdgpu_reset.h\"\n\n \nuint64_t amdgpu_amdkfd_total_mem_size;\n\nstatic bool kfd_initialized;\n\nint amdgpu_amdkfd_init(void)\n{\n\tstruct sysinfo si;\n\tint ret;\n\n\tsi_meminfo(&si);\n\tamdgpu_amdkfd_total_mem_size = si.freeram - si.freehigh;\n\tamdgpu_amdkfd_total_mem_size *= si.mem_unit;\n\n\tret = kgd2kfd_init();\n\tkfd_initialized = !ret;\n\n\treturn ret;\n}\n\nvoid amdgpu_amdkfd_fini(void)\n{\n\tif (kfd_initialized) {\n\t\tkgd2kfd_exit();\n\t\tkfd_initialized = false;\n\t}\n}\n\nvoid amdgpu_amdkfd_device_probe(struct amdgpu_device *adev)\n{\n\tbool vf = amdgpu_sriov_vf(adev);\n\n\tif (!kfd_initialized)\n\t\treturn;\n\n\tadev->kfd.dev = kgd2kfd_probe(adev, vf);\n}\n\n \nstatic void amdgpu_doorbell_get_kfd_info(struct amdgpu_device *adev,\n\t\t\t\t\t phys_addr_t *aperture_base,\n\t\t\t\t\t size_t *aperture_size,\n\t\t\t\t\t size_t *start_offset)\n{\n\t \n\tif (adev->enable_mes) {\n\t\t \n\t\t*aperture_base = adev->doorbell.base;\n\t\t*aperture_size = 0;\n\t\t*start_offset = 0;\n\t} else if (adev->doorbell.size > adev->doorbell.num_kernel_doorbells *\n\t\t\t\t\t\tsizeof(u32)) {\n\t\t*aperture_base = adev->doorbell.base;\n\t\t*aperture_size = adev->doorbell.size;\n\t\t*start_offset = adev->doorbell.num_kernel_doorbells * sizeof(u32);\n\t} else {\n\t\t*aperture_base = 0;\n\t\t*aperture_size = 0;\n\t\t*start_offset = 0;\n\t}\n}\n\n\nstatic void amdgpu_amdkfd_reset_work(struct work_struct *work)\n{\n\tstruct amdgpu_device *adev = container_of(work, struct amdgpu_device,\n\t\t\t\t\t\t  kfd.reset_work);\n\n\tstruct amdgpu_reset_context reset_context;\n\n\tmemset(&reset_context, 0, sizeof(reset_context));\n\n\treset_context.method = AMD_RESET_METHOD_NONE;\n\treset_context.reset_req_dev = adev;\n\tclear_bit(AMDGPU_NEED_FULL_RESET, &reset_context.flags);\n\n\tamdgpu_device_gpu_recover(adev, NULL, &reset_context);\n}\n\nvoid amdgpu_amdkfd_device_init(struct amdgpu_device *adev)\n{\n\tint i;\n\tint last_valid_bit;\n\n\tamdgpu_amdkfd_gpuvm_init_mem_limits();\n\n\tif (adev->kfd.dev) {\n\t\tstruct kgd2kfd_shared_resources gpu_resources = {\n\t\t\t.compute_vmid_bitmap =\n\t\t\t\t((1 << AMDGPU_NUM_VMID) - 1) -\n\t\t\t\t((1 << adev->vm_manager.first_kfd_vmid) - 1),\n\t\t\t.num_pipe_per_mec = adev->gfx.mec.num_pipe_per_mec,\n\t\t\t.num_queue_per_pipe = adev->gfx.mec.num_queue_per_pipe,\n\t\t\t.gpuvm_size = min(adev->vm_manager.max_pfn\n\t\t\t\t\t  << AMDGPU_GPU_PAGE_SHIFT,\n\t\t\t\t\t  AMDGPU_GMC_HOLE_START),\n\t\t\t.drm_render_minor = adev_to_drm(adev)->render->index,\n\t\t\t.sdma_doorbell_idx = adev->doorbell_index.sdma_engine,\n\t\t\t.enable_mes = adev->enable_mes,\n\t\t};\n\n\t\t \n\t\tbitmap_complement(gpu_resources.cp_queue_bitmap,\n\t\t\t\t  adev->gfx.mec_bitmap[0].queue_bitmap,\n\t\t\t\t  KGD_MAX_QUEUES);\n\n\t\t \n\t\tlast_valid_bit = 1  \n\t\t\t\t* adev->gfx.mec.num_pipe_per_mec\n\t\t\t\t* adev->gfx.mec.num_queue_per_pipe;\n\t\tfor (i = last_valid_bit; i < KGD_MAX_QUEUES; ++i)\n\t\t\tclear_bit(i, gpu_resources.cp_queue_bitmap);\n\n\t\tamdgpu_doorbell_get_kfd_info(adev,\n\t\t\t\t&gpu_resources.doorbell_physical_address,\n\t\t\t\t&gpu_resources.doorbell_aperture_size,\n\t\t\t\t&gpu_resources.doorbell_start_offset);\n\n\t\t \n\t\tif (adev->asic_type >= CHIP_VEGA10) {\n\t\t\tgpu_resources.non_cp_doorbells_start =\n\t\t\t\t\tadev->doorbell_index.first_non_cp;\n\t\t\tgpu_resources.non_cp_doorbells_end =\n\t\t\t\t\tadev->doorbell_index.last_non_cp;\n\t\t}\n\n\t\tadev->kfd.init_complete = kgd2kfd_device_init(adev->kfd.dev,\n\t\t\t\t\t\t\t&gpu_resources);\n\n\t\tamdgpu_amdkfd_total_mem_size += adev->gmc.real_vram_size;\n\n\t\tINIT_WORK(&adev->kfd.reset_work, amdgpu_amdkfd_reset_work);\n\t}\n}\n\nvoid amdgpu_amdkfd_device_fini_sw(struct amdgpu_device *adev)\n{\n\tif (adev->kfd.dev) {\n\t\tkgd2kfd_device_exit(adev->kfd.dev);\n\t\tadev->kfd.dev = NULL;\n\t\tamdgpu_amdkfd_total_mem_size -= adev->gmc.real_vram_size;\n\t}\n}\n\nvoid amdgpu_amdkfd_interrupt(struct amdgpu_device *adev,\n\t\tconst void *ih_ring_entry)\n{\n\tif (adev->kfd.dev)\n\t\tkgd2kfd_interrupt(adev->kfd.dev, ih_ring_entry);\n}\n\nvoid amdgpu_amdkfd_suspend(struct amdgpu_device *adev, bool run_pm)\n{\n\tif (adev->kfd.dev)\n\t\tkgd2kfd_suspend(adev->kfd.dev, run_pm);\n}\n\nint amdgpu_amdkfd_resume(struct amdgpu_device *adev, bool run_pm)\n{\n\tint r = 0;\n\n\tif (adev->kfd.dev)\n\t\tr = kgd2kfd_resume(adev->kfd.dev, run_pm);\n\n\treturn r;\n}\n\nint amdgpu_amdkfd_pre_reset(struct amdgpu_device *adev)\n{\n\tint r = 0;\n\n\tif (adev->kfd.dev)\n\t\tr = kgd2kfd_pre_reset(adev->kfd.dev);\n\n\treturn r;\n}\n\nint amdgpu_amdkfd_post_reset(struct amdgpu_device *adev)\n{\n\tint r = 0;\n\n\tif (adev->kfd.dev)\n\t\tr = kgd2kfd_post_reset(adev->kfd.dev);\n\n\treturn r;\n}\n\nvoid amdgpu_amdkfd_gpu_reset(struct amdgpu_device *adev)\n{\n\tif (amdgpu_device_should_recover_gpu(adev))\n\t\tamdgpu_reset_domain_schedule(adev->reset_domain,\n\t\t\t\t\t     &adev->kfd.reset_work);\n}\n\nint amdgpu_amdkfd_alloc_gtt_mem(struct amdgpu_device *adev, size_t size,\n\t\t\t\tvoid **mem_obj, uint64_t *gpu_addr,\n\t\t\t\tvoid **cpu_ptr, bool cp_mqd_gfx9)\n{\n\tstruct amdgpu_bo *bo = NULL;\n\tstruct amdgpu_bo_param bp;\n\tint r;\n\tvoid *cpu_ptr_tmp = NULL;\n\n\tmemset(&bp, 0, sizeof(bp));\n\tbp.size = size;\n\tbp.byte_align = PAGE_SIZE;\n\tbp.domain = AMDGPU_GEM_DOMAIN_GTT;\n\tbp.flags = AMDGPU_GEM_CREATE_CPU_GTT_USWC;\n\tbp.type = ttm_bo_type_kernel;\n\tbp.resv = NULL;\n\tbp.bo_ptr_size = sizeof(struct amdgpu_bo);\n\n\tif (cp_mqd_gfx9)\n\t\tbp.flags |= AMDGPU_GEM_CREATE_CP_MQD_GFX9;\n\n\tr = amdgpu_bo_create(adev, &bp, &bo);\n\tif (r) {\n\t\tdev_err(adev->dev,\n\t\t\t\"failed to allocate BO for amdkfd (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tr = amdgpu_bo_reserve(bo, true);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to reserve bo for amdkfd\\n\", r);\n\t\tgoto allocate_mem_reserve_bo_failed;\n\t}\n\n\tr = amdgpu_bo_pin(bo, AMDGPU_GEM_DOMAIN_GTT);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to pin bo for amdkfd\\n\", r);\n\t\tgoto allocate_mem_pin_bo_failed;\n\t}\n\n\tr = amdgpu_ttm_alloc_gart(&bo->tbo);\n\tif (r) {\n\t\tdev_err(adev->dev, \"%p bind failed\\n\", bo);\n\t\tgoto allocate_mem_kmap_bo_failed;\n\t}\n\n\tr = amdgpu_bo_kmap(bo, &cpu_ptr_tmp);\n\tif (r) {\n\t\tdev_err(adev->dev,\n\t\t\t\"(%d) failed to map bo to kernel for amdkfd\\n\", r);\n\t\tgoto allocate_mem_kmap_bo_failed;\n\t}\n\n\t*mem_obj = bo;\n\t*gpu_addr = amdgpu_bo_gpu_offset(bo);\n\t*cpu_ptr = cpu_ptr_tmp;\n\n\tamdgpu_bo_unreserve(bo);\n\n\treturn 0;\n\nallocate_mem_kmap_bo_failed:\n\tamdgpu_bo_unpin(bo);\nallocate_mem_pin_bo_failed:\n\tamdgpu_bo_unreserve(bo);\nallocate_mem_reserve_bo_failed:\n\tamdgpu_bo_unref(&bo);\n\n\treturn r;\n}\n\nvoid amdgpu_amdkfd_free_gtt_mem(struct amdgpu_device *adev, void *mem_obj)\n{\n\tstruct amdgpu_bo *bo = (struct amdgpu_bo *) mem_obj;\n\n\tamdgpu_bo_reserve(bo, true);\n\tamdgpu_bo_kunmap(bo);\n\tamdgpu_bo_unpin(bo);\n\tamdgpu_bo_unreserve(bo);\n\tamdgpu_bo_unref(&(bo));\n}\n\nint amdgpu_amdkfd_alloc_gws(struct amdgpu_device *adev, size_t size,\n\t\t\t\tvoid **mem_obj)\n{\n\tstruct amdgpu_bo *bo = NULL;\n\tstruct amdgpu_bo_user *ubo;\n\tstruct amdgpu_bo_param bp;\n\tint r;\n\n\tmemset(&bp, 0, sizeof(bp));\n\tbp.size = size;\n\tbp.byte_align = 1;\n\tbp.domain = AMDGPU_GEM_DOMAIN_GWS;\n\tbp.flags = AMDGPU_GEM_CREATE_NO_CPU_ACCESS;\n\tbp.type = ttm_bo_type_device;\n\tbp.resv = NULL;\n\tbp.bo_ptr_size = sizeof(struct amdgpu_bo);\n\n\tr = amdgpu_bo_create_user(adev, &bp, &ubo);\n\tif (r) {\n\t\tdev_err(adev->dev,\n\t\t\t\"failed to allocate gws BO for amdkfd (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tbo = &ubo->bo;\n\t*mem_obj = bo;\n\treturn 0;\n}\n\nvoid amdgpu_amdkfd_free_gws(struct amdgpu_device *adev, void *mem_obj)\n{\n\tstruct amdgpu_bo *bo = (struct amdgpu_bo *)mem_obj;\n\n\tamdgpu_bo_unref(&bo);\n}\n\nuint32_t amdgpu_amdkfd_get_fw_version(struct amdgpu_device *adev,\n\t\t\t\t      enum kgd_engine_type type)\n{\n\tswitch (type) {\n\tcase KGD_ENGINE_PFP:\n\t\treturn adev->gfx.pfp_fw_version;\n\n\tcase KGD_ENGINE_ME:\n\t\treturn adev->gfx.me_fw_version;\n\n\tcase KGD_ENGINE_CE:\n\t\treturn adev->gfx.ce_fw_version;\n\n\tcase KGD_ENGINE_MEC1:\n\t\treturn adev->gfx.mec_fw_version;\n\n\tcase KGD_ENGINE_MEC2:\n\t\treturn adev->gfx.mec2_fw_version;\n\n\tcase KGD_ENGINE_RLC:\n\t\treturn adev->gfx.rlc_fw_version;\n\n\tcase KGD_ENGINE_SDMA1:\n\t\treturn adev->sdma.instance[0].fw_version;\n\n\tcase KGD_ENGINE_SDMA2:\n\t\treturn adev->sdma.instance[1].fw_version;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nvoid amdgpu_amdkfd_get_local_mem_info(struct amdgpu_device *adev,\n\t\t\t\t      struct kfd_local_mem_info *mem_info,\n\t\t\t\t      struct amdgpu_xcp *xcp)\n{\n\tmemset(mem_info, 0, sizeof(*mem_info));\n\n\tif (xcp) {\n\t\tif (adev->gmc.real_vram_size == adev->gmc.visible_vram_size)\n\t\t\tmem_info->local_mem_size_public =\n\t\t\t\t\tKFD_XCP_MEMORY_SIZE(adev, xcp->id);\n\t\telse\n\t\t\tmem_info->local_mem_size_private =\n\t\t\t\t\tKFD_XCP_MEMORY_SIZE(adev, xcp->id);\n\t} else {\n\t\tmem_info->local_mem_size_public = adev->gmc.visible_vram_size;\n\t\tmem_info->local_mem_size_private = adev->gmc.real_vram_size -\n\t\t\t\t\t\tadev->gmc.visible_vram_size;\n\t}\n\tmem_info->vram_width = adev->gmc.vram_width;\n\n\tpr_debug(\"Address base: %pap public 0x%llx private 0x%llx\\n\",\n\t\t\t&adev->gmc.aper_base,\n\t\t\tmem_info->local_mem_size_public,\n\t\t\tmem_info->local_mem_size_private);\n\n\tif (adev->pm.dpm_enabled) {\n\t\tif (amdgpu_emu_mode == 1)\n\t\t\tmem_info->mem_clk_max = 0;\n\t\telse\n\t\t\tmem_info->mem_clk_max = amdgpu_dpm_get_mclk(adev, false) / 100;\n\t} else\n\t\tmem_info->mem_clk_max = 100;\n}\n\nuint64_t amdgpu_amdkfd_get_gpu_clock_counter(struct amdgpu_device *adev)\n{\n\tif (adev->gfx.funcs->get_gpu_clock_counter)\n\t\treturn adev->gfx.funcs->get_gpu_clock_counter(adev);\n\treturn 0;\n}\n\nuint32_t amdgpu_amdkfd_get_max_engine_clock_in_mhz(struct amdgpu_device *adev)\n{\n\t \n\tif (adev->pm.dpm_enabled)\n\t\treturn amdgpu_dpm_get_sclk(adev, false) / 100;\n\telse\n\t\treturn 100;\n}\n\nvoid amdgpu_amdkfd_get_cu_info(struct amdgpu_device *adev, struct kfd_cu_info *cu_info)\n{\n\tstruct amdgpu_cu_info acu_info = adev->gfx.cu_info;\n\n\tmemset(cu_info, 0, sizeof(*cu_info));\n\tif (sizeof(cu_info->cu_bitmap) != sizeof(acu_info.bitmap))\n\t\treturn;\n\n\tcu_info->cu_active_number = acu_info.number;\n\tcu_info->cu_ao_mask = acu_info.ao_cu_mask;\n\tmemcpy(&cu_info->cu_bitmap[0], &acu_info.bitmap[0],\n\t       sizeof(cu_info->cu_bitmap));\n\tcu_info->num_shader_engines = adev->gfx.config.max_shader_engines;\n\tcu_info->num_shader_arrays_per_engine = adev->gfx.config.max_sh_per_se;\n\tcu_info->num_cu_per_sh = adev->gfx.config.max_cu_per_sh;\n\tcu_info->simd_per_cu = acu_info.simd_per_cu;\n\tcu_info->max_waves_per_simd = acu_info.max_waves_per_simd;\n\tcu_info->wave_front_size = acu_info.wave_front_size;\n\tcu_info->max_scratch_slots_per_cu = acu_info.max_scratch_slots_per_cu;\n\tcu_info->lds_size = acu_info.lds_size;\n}\n\nint amdgpu_amdkfd_get_dmabuf_info(struct amdgpu_device *adev, int dma_buf_fd,\n\t\t\t\t  struct amdgpu_device **dmabuf_adev,\n\t\t\t\t  uint64_t *bo_size, void *metadata_buffer,\n\t\t\t\t  size_t buffer_size, uint32_t *metadata_size,\n\t\t\t\t  uint32_t *flags, int8_t *xcp_id)\n{\n\tstruct dma_buf *dma_buf;\n\tstruct drm_gem_object *obj;\n\tstruct amdgpu_bo *bo;\n\tuint64_t metadata_flags;\n\tint r = -EINVAL;\n\n\tdma_buf = dma_buf_get(dma_buf_fd);\n\tif (IS_ERR(dma_buf))\n\t\treturn PTR_ERR(dma_buf);\n\n\tif (dma_buf->ops != &amdgpu_dmabuf_ops)\n\t\t \n\t\tgoto out_put;\n\n\tobj = dma_buf->priv;\n\tif (obj->dev->driver != adev_to_drm(adev)->driver)\n\t\t \n\t\tgoto out_put;\n\n\tadev = drm_to_adev(obj->dev);\n\tbo = gem_to_amdgpu_bo(obj);\n\tif (!(bo->preferred_domains & (AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT)))\n\t\t \n\t\tgoto out_put;\n\n\tr = 0;\n\tif (dmabuf_adev)\n\t\t*dmabuf_adev = adev;\n\tif (bo_size)\n\t\t*bo_size = amdgpu_bo_size(bo);\n\tif (metadata_buffer)\n\t\tr = amdgpu_bo_get_metadata(bo, metadata_buffer, buffer_size,\n\t\t\t\t\t   metadata_size, &metadata_flags);\n\tif (flags) {\n\t\t*flags = (bo->preferred_domains & AMDGPU_GEM_DOMAIN_VRAM) ?\n\t\t\t\tKFD_IOC_ALLOC_MEM_FLAGS_VRAM\n\t\t\t\t: KFD_IOC_ALLOC_MEM_FLAGS_GTT;\n\n\t\tif (bo->flags & AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED)\n\t\t\t*flags |= KFD_IOC_ALLOC_MEM_FLAGS_PUBLIC;\n\t}\n\tif (xcp_id)\n\t\t*xcp_id = bo->xcp_id;\n\nout_put:\n\tdma_buf_put(dma_buf);\n\treturn r;\n}\n\nuint8_t amdgpu_amdkfd_get_xgmi_hops_count(struct amdgpu_device *dst,\n\t\t\t\t\t  struct amdgpu_device *src)\n{\n\tstruct amdgpu_device *peer_adev = src;\n\tstruct amdgpu_device *adev = dst;\n\tint ret = amdgpu_xgmi_get_hops_count(adev, peer_adev);\n\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"amdgpu: failed to get  xgmi hops count between node %d and %d. ret = %d\\n\",\n\t\t\tadev->gmc.xgmi.physical_node_id,\n\t\t\tpeer_adev->gmc.xgmi.physical_node_id, ret);\n\t\tret = 0;\n\t}\n\treturn  (uint8_t)ret;\n}\n\nint amdgpu_amdkfd_get_xgmi_bandwidth_mbytes(struct amdgpu_device *dst,\n\t\t\t\t\t    struct amdgpu_device *src,\n\t\t\t\t\t    bool is_min)\n{\n\tstruct amdgpu_device *adev = dst, *peer_adev;\n\tint num_links;\n\n\tif (adev->asic_type != CHIP_ALDEBARAN)\n\t\treturn 0;\n\n\tif (src)\n\t\tpeer_adev = src;\n\n\t \n\tnum_links = is_min ? 1 : amdgpu_xgmi_get_num_links(adev, peer_adev);\n\tif (num_links < 0) {\n\t\tDRM_ERROR(\"amdgpu: failed to get xgmi num links between node %d and %d. ret = %d\\n\",\n\t\t\tadev->gmc.xgmi.physical_node_id,\n\t\t\tpeer_adev->gmc.xgmi.physical_node_id, num_links);\n\t\tnum_links = 0;\n\t}\n\n\t \n\treturn (num_links * 16 * 25000)/BITS_PER_BYTE;\n}\n\nint amdgpu_amdkfd_get_pcie_bandwidth_mbytes(struct amdgpu_device *adev, bool is_min)\n{\n\tint num_lanes_shift = (is_min ? ffs(adev->pm.pcie_mlw_mask) :\n\t\t\t\t\t\t\tfls(adev->pm.pcie_mlw_mask)) - 1;\n\tint gen_speed_shift = (is_min ? ffs(adev->pm.pcie_gen_mask &\n\t\t\t\t\t\tCAIL_PCIE_LINK_SPEED_SUPPORT_MASK) :\n\t\t\t\t\tfls(adev->pm.pcie_gen_mask &\n\t\t\t\t\t\tCAIL_PCIE_LINK_SPEED_SUPPORT_MASK)) - 1;\n\tuint32_t num_lanes_mask = 1 << num_lanes_shift;\n\tuint32_t gen_speed_mask = 1 << gen_speed_shift;\n\tint num_lanes_factor = 0, gen_speed_mbits_factor = 0;\n\n\tswitch (num_lanes_mask) {\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X1:\n\t\tnum_lanes_factor = 1;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X2:\n\t\tnum_lanes_factor = 2;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X4:\n\t\tnum_lanes_factor = 4;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X8:\n\t\tnum_lanes_factor = 8;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X12:\n\t\tnum_lanes_factor = 12;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X16:\n\t\tnum_lanes_factor = 16;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_WIDTH_SUPPORT_X32:\n\t\tnum_lanes_factor = 32;\n\t\tbreak;\n\t}\n\n\tswitch (gen_speed_mask) {\n\tcase CAIL_PCIE_LINK_SPEED_SUPPORT_GEN1:\n\t\tgen_speed_mbits_factor = 2500;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2:\n\t\tgen_speed_mbits_factor = 5000;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3:\n\t\tgen_speed_mbits_factor = 8000;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4:\n\t\tgen_speed_mbits_factor = 16000;\n\t\tbreak;\n\tcase CAIL_PCIE_LINK_SPEED_SUPPORT_GEN5:\n\t\tgen_speed_mbits_factor = 32000;\n\t\tbreak;\n\t}\n\n\treturn (num_lanes_factor * gen_speed_mbits_factor)/BITS_PER_BYTE;\n}\n\nint amdgpu_amdkfd_submit_ib(struct amdgpu_device *adev,\n\t\t\t\tenum kgd_engine_type engine,\n\t\t\t\tuint32_t vmid, uint64_t gpu_addr,\n\t\t\t\tuint32_t *ib_cmd, uint32_t ib_len)\n{\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tstruct amdgpu_ring *ring;\n\tstruct dma_fence *f = NULL;\n\tint ret;\n\n\tswitch (engine) {\n\tcase KGD_ENGINE_MEC1:\n\t\tring = &adev->gfx.compute_ring[0];\n\t\tbreak;\n\tcase KGD_ENGINE_SDMA1:\n\t\tring = &adev->sdma.instance[0].ring;\n\t\tbreak;\n\tcase KGD_ENGINE_SDMA2:\n\t\tring = &adev->sdma.instance[1].ring;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid engine in IB submission: %d\\n\", engine);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = amdgpu_job_alloc(adev, NULL, NULL, NULL, 1, &job);\n\tif (ret)\n\t\tgoto err;\n\n\tib = &job->ibs[0];\n\tmemset(ib, 0, sizeof(struct amdgpu_ib));\n\n\tib->gpu_addr = gpu_addr;\n\tib->ptr = ib_cmd;\n\tib->length_dw = ib_len;\n\t \n\tjob->vmid = vmid;\n\tjob->num_ibs = 1;\n\n\tret = amdgpu_ib_schedule(ring, 1, ib, job, &f);\n\n\tif (ret) {\n\t\tDRM_ERROR(\"amdgpu: failed to schedule IB.\\n\");\n\t\tgoto err_ib_sched;\n\t}\n\n\t \n\tdma_fence_put(f);\n\tret = dma_fence_wait(f, false);\n\nerr_ib_sched:\n\tamdgpu_job_free(job);\nerr:\n\treturn ret;\n}\n\nvoid amdgpu_amdkfd_set_compute_idle(struct amdgpu_device *adev, bool idle)\n{\n\t \n\tif (IP_VERSION_MAJ(adev->ip_versions[GC_HWIP][0]) == 11) {\n\t\tpr_debug(\"GFXOFF is %s\\n\", idle ? \"enabled\" : \"disabled\");\n\t\tamdgpu_gfx_off_ctrl(adev, idle);\n\t}\n\tamdgpu_dpm_switch_power_profile(adev,\n\t\t\t\t\tPP_SMC_POWER_PROFILE_COMPUTE,\n\t\t\t\t\t!idle);\n}\n\nbool amdgpu_amdkfd_is_kfd_vmid(struct amdgpu_device *adev, u32 vmid)\n{\n\tif (adev->kfd.dev)\n\t\treturn vmid >= adev->vm_manager.first_kfd_vmid;\n\n\treturn false;\n}\n\nint amdgpu_amdkfd_flush_gpu_tlb_vmid(struct amdgpu_device *adev,\n\t\t\t\t     uint16_t vmid)\n{\n\tif (adev->family == AMDGPU_FAMILY_AI) {\n\t\tint i;\n\n\t\tfor_each_set_bit(i, adev->vmhubs_mask, AMDGPU_MAX_VMHUBS)\n\t\t\tamdgpu_gmc_flush_gpu_tlb(adev, vmid, i, 0);\n\t} else {\n\t\tamdgpu_gmc_flush_gpu_tlb(adev, vmid, AMDGPU_GFXHUB(0), 0);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_amdkfd_flush_gpu_tlb_pasid(struct amdgpu_device *adev,\n\t\t\t\t      uint16_t pasid,\n\t\t\t\t      enum TLB_FLUSH_TYPE flush_type,\n\t\t\t\t      uint32_t inst)\n{\n\tbool all_hub = false;\n\n\tif (adev->family == AMDGPU_FAMILY_AI ||\n\t    adev->family == AMDGPU_FAMILY_RV)\n\t\tall_hub = true;\n\n\treturn amdgpu_gmc_flush_gpu_tlb_pasid(adev, pasid, flush_type, all_hub, inst);\n}\n\nbool amdgpu_amdkfd_have_atomics_support(struct amdgpu_device *adev)\n{\n\treturn adev->have_atomics_support;\n}\n\nvoid amdgpu_amdkfd_debug_mem_fence(struct amdgpu_device *adev)\n{\n\tamdgpu_device_flush_hdp(adev, NULL);\n}\n\nvoid amdgpu_amdkfd_ras_poison_consumption_handler(struct amdgpu_device *adev, bool reset)\n{\n\tamdgpu_umc_poison_handler(adev, reset);\n}\n\nint amdgpu_amdkfd_send_close_event_drain_irq(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t *payload)\n{\n\tint ret;\n\n\t \n\tret = amdgpu_ih_wait_on_checkpoint_process_ts(adev, &adev->irq.ih);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tamdgpu_amdkfd_interrupt(adev, payload);\n\n\treturn 0;\n}\n\nbool amdgpu_amdkfd_ras_query_utcl2_poison_status(struct amdgpu_device *adev)\n{\n\tif (adev->gfx.ras && adev->gfx.ras->query_utcl2_poison_status)\n\t\treturn adev->gfx.ras->query_utcl2_poison_status(adev);\n\telse\n\t\treturn false;\n}\n\nint amdgpu_amdkfd_check_and_lock_kfd(struct amdgpu_device *adev)\n{\n\treturn kgd2kfd_check_and_lock_kfd();\n}\n\nvoid amdgpu_amdkfd_unlock_kfd(struct amdgpu_device *adev)\n{\n\tkgd2kfd_unlock_kfd();\n}\n\n\nu64 amdgpu_amdkfd_xcp_memory_size(struct amdgpu_device *adev, int xcp_id)\n{\n\tu64 tmp;\n\ts8 mem_id = KFD_XCP_MEM_ID(adev, xcp_id);\n\n\tif (adev->gmc.num_mem_partitions && xcp_id >= 0 && mem_id >= 0) {\n\t\ttmp = adev->gmc.mem_partitions[mem_id].size;\n\t\tdo_div(tmp, adev->xcp_mgr->num_xcp_per_mem_partition);\n\t\treturn ALIGN_DOWN(tmp, PAGE_SIZE);\n\t} else {\n\t\treturn adev->gmc.real_vram_size;\n\t}\n}\n\nint amdgpu_amdkfd_unmap_hiq(struct amdgpu_device *adev, u32 doorbell_off,\n\t\t\t    u32 inst)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[inst];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tstruct amdgpu_ring_funcs *ring_funcs;\n\tstruct amdgpu_ring *ring;\n\tint r = 0;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)\n\t\treturn -EINVAL;\n\n\tring_funcs = kzalloc(sizeof(*ring_funcs), GFP_KERNEL);\n\tif (!ring_funcs)\n\t\treturn -ENOMEM;\n\n\tring = kzalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring) {\n\t\tr = -ENOMEM;\n\t\tgoto free_ring_funcs;\n\t}\n\n\tring_funcs->type = AMDGPU_RING_TYPE_COMPUTE;\n\tring->doorbell_index = doorbell_off;\n\tring->funcs = ring_funcs;\n\n\tspin_lock(&kiq->ring_lock);\n\n\tif (amdgpu_ring_alloc(kiq_ring, kiq->pmf->unmap_queues_size)) {\n\t\tspin_unlock(&kiq->ring_lock);\n\t\tr = -ENOMEM;\n\t\tgoto free_ring;\n\t}\n\n\tkiq->pmf->kiq_unmap_queues(kiq_ring, ring, RESET_QUEUES, 0, 0);\n\n\tif (kiq_ring->sched.ready && !adev->job_hang)\n\t\tr = amdgpu_ring_test_helper(kiq_ring);\n\n\tspin_unlock(&kiq->ring_lock);\n\nfree_ring:\n\tkfree(ring);\n\nfree_ring_funcs:\n\tkfree(ring_funcs);\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}