{
  "module_name": "nbio_v7_2.c",
  "hash_id": "c14893fafb98777e8a85a73be330afd9c3726af0ff34724c1a682304a63e6af4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/nbio_v7_2.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"nbio_v7_2.h\"\n\n#include \"nbio/nbio_7_2_0_offset.h\"\n#include \"nbio/nbio_7_2_0_sh_mask.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\n#define regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0_YC\t\t\t\t0x0015\n#define regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0_YC_BASE_IDX\t\t2\n#define regBIF_BX0_BIF_FB_EN_YC\t\t\t\t\t\t\t\t0x0100\n#define regBIF_BX0_BIF_FB_EN_YC_BASE_IDX\t\t\t\t\t2\n#define regBIF1_PCIE_MST_CTRL_3\t\t\t\t\t\t\t\t0x4601c6\n#define regBIF1_PCIE_MST_CTRL_3_BASE_IDX\t\t\t\t\t5\n#define BIF1_PCIE_MST_CTRL_3__CI_SWUS_MAX_READ_REQUEST_SIZE_MODE__SHIFT \\\n\t\t\t0x1b\n#define BIF1_PCIE_MST_CTRL_3__CI_SWUS_MAX_READ_REQUEST_SIZE_PRIV__SHIFT \\\n\t\t\t0x1c\n#define BIF1_PCIE_MST_CTRL_3__CI_SWUS_MAX_READ_REQUEST_SIZE_MODE_MASK \\\n\t\t\t0x08000000L\n#define BIF1_PCIE_MST_CTRL_3__CI_SWUS_MAX_READ_REQUEST_SIZE_PRIV_MASK \\\n\t\t\t0x30000000L\n#define regBIF1_PCIE_TX_POWER_CTRL_1\t\t\t\t\t\t0x460187\n#define regBIF1_PCIE_TX_POWER_CTRL_1_BASE_IDX\t\t\t\t5\n#define BIF1_PCIE_TX_POWER_CTRL_1__MST_MEM_LS_EN_MASK\t\t0x00000001L\n#define BIF1_PCIE_TX_POWER_CTRL_1__REPLAY_MEM_LS_EN_MASK\t0x00000008L\n\nstatic void nbio_v7_2_remap_hdp_registers(struct amdgpu_device *adev)\n{\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_MEM_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL);\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_REG_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL);\n}\n\nstatic u32 nbio_v7_2_get_rev_id(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(7, 2, 1):\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 0):\n\t\ttmp = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0_YC);\n\t\tbreak;\n\tdefault:\n\t\ttmp = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0);\n\t\tbreak;\n\t}\n\n\ttmp &= RCC_STRAP0_RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0_MASK;\n\ttmp >>= RCC_STRAP0_RCC_DEV0_EPF0_STRAP0__STRAP_ATI_REV_ID_DEV0_F0__SHIFT;\n\n\treturn tmp;\n}\n\nstatic void nbio_v7_2_mc_access_enable(struct amdgpu_device *adev, bool enable)\n{\n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(7, 2, 1):\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 0):\n\t\tif (enable)\n\t\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN_YC,\n\t\t\t\tBIF_BX0_BIF_FB_EN__FB_READ_EN_MASK |\n\t\t\t\tBIF_BX0_BIF_FB_EN__FB_WRITE_EN_MASK);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN_YC, 0);\n\tbreak;\n\tdefault:\n\t\tif (enable)\n\t\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN,\n\t\t\t\tBIF_BX0_BIF_FB_EN__FB_READ_EN_MASK |\n\t\t\t\tBIF_BX0_BIF_FB_EN__FB_WRITE_EN_MASK);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN, 0);\n\t\tbreak;\n\t}\n}\n\nstatic u32 nbio_v7_2_get_memsize(struct amdgpu_device *adev)\n{\n\treturn RREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF0_0_RCC_CONFIG_MEMSIZE);\n}\n\nstatic void nbio_v7_2_sdma_doorbell_range(struct amdgpu_device *adev, int instance,\n\t\t\t\t\t  bool use_doorbell, int doorbell_index,\n\t\t\t\t\t  int doorbell_size)\n{\n\tu32 reg = SOC15_REG_OFFSET(NBIO, 0, regGDC0_BIF_SDMA0_DOORBELL_RANGE);\n\tu32 doorbell_range = RREG32_PCIE_PORT(reg);\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       GDC0_BIF_SDMA0_DOORBELL_RANGE,\n\t\t\t\t\t       OFFSET, doorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       GDC0_BIF_SDMA0_DOORBELL_RANGE,\n\t\t\t\t\t       SIZE, doorbell_size);\n\t} else {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t       GDC0_BIF_SDMA0_DOORBELL_RANGE,\n\t\t\t\t\t       SIZE, 0);\n\t}\n\n\tWREG32_PCIE_PORT(reg, doorbell_range);\n}\n\nstatic void nbio_v7_2_vcn_doorbell_range(struct amdgpu_device *adev, bool use_doorbell,\n\t\t\t\t\t int doorbell_index, int instance)\n{\n\tu32 reg = SOC15_REG_OFFSET(NBIO, 0, regGDC0_BIF_VCN0_DOORBELL_RANGE);\n\tu32 doorbell_range = RREG32_PCIE_PORT(reg);\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t\tGDC0_BIF_VCN0_DOORBELL_RANGE, OFFSET,\n\t\t\t\t\t\t\tdoorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t\tGDC0_BIF_VCN0_DOORBELL_RANGE, SIZE, 8);\n\t} else {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\t\t\tGDC0_BIF_VCN0_DOORBELL_RANGE, SIZE, 0);\n\t}\n\n\tWREG32_PCIE_PORT(reg, doorbell_range);\n}\n\nstatic void nbio_v7_2_enable_doorbell_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 reg;\n\n\treg = RREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF0_0_RCC_DOORBELL_APER_EN);\n\treg = REG_SET_FIELD(reg, RCC_DEV0_EPF0_0_RCC_DOORBELL_APER_EN,\n\t\t\t    BIF_DOORBELL_APER_EN, enable ? 1 : 0);\n\n\tWREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF0_0_RCC_DOORBELL_APER_EN, reg);\n}\n\nstatic void nbio_v7_2_enable_doorbell_selfring_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tbool enable)\n{\n\tu32 tmp = 0;\n\n\tif (enable) {\n\t\ttmp = REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\tDOORBELL_SELFRING_GPA_APER_EN, 1) |\n\t\t\tREG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\tDOORBELL_SELFRING_GPA_APER_MODE, 1) |\n\t\t\tREG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\tDOORBELL_SELFRING_GPA_APER_SIZE, 0);\n\n\t\tWREG32_SOC15(NBIO, 0,\n\t\t\tregBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_LOW,\n\t\t\tlower_32_bits(adev->doorbell.base));\n\t\tWREG32_SOC15(NBIO, 0,\n\t\t\tregBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_HIGH,\n\t\t\tupper_32_bits(adev->doorbell.base));\n\t}\n\n\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\ttmp);\n}\n\n\nstatic void nbio_v7_2_ih_doorbell_range(struct amdgpu_device *adev,\n\t\t\t\t\tbool use_doorbell, int doorbell_index)\n{\n\tu32 ih_doorbell_range = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regGDC0_BIF_IH_DOORBELL_RANGE));\n\n\tif (use_doorbell) {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  GDC0_BIF_IH_DOORBELL_RANGE, OFFSET,\n\t\t\t\t\t\t  doorbell_index);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  GDC0_BIF_IH_DOORBELL_RANGE, SIZE,\n\t\t\t\t\t\t  2);\n\t} else {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\t\t\t  GDC0_BIF_IH_DOORBELL_RANGE, SIZE,\n\t\t\t\t\t\t  0);\n\t}\n\n\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regGDC0_BIF_IH_DOORBELL_RANGE),\n\t\t\t ih_doorbell_range);\n}\n\nstatic void nbio_v7_2_ih_control(struct amdgpu_device *adev)\n{\n\tu32 interrupt_cntl;\n\n\t \n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL2,\n\t\t     adev->dummy_page_addr >> 8);\n\n\tinterrupt_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL,\n\t\t\t\t       IH_DUMMY_RD_OVERRIDE, 0);\n\n\t \n\tinterrupt_cntl = REG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL,\n\t\t\t\t       IH_REQ_NONSNOOP_EN, 0);\n\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL, interrupt_cntl);\n}\n\nstatic void nbio_v7_2_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tuint32_t def, data;\n\n\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regCPM_CONTROL));\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_BIF_MGCG)) {\n\t\tdata |= (CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_LCNT_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_REGS_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__TXCLK_PRBS_GATE_ENABLE_MASK |\n\t\t\t CPM_CONTROL__REFCLK_REGS_GATE_ENABLE_MASK);\n\t} else {\n\t\tdata &= ~(CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_DYN_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_LCNT_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_REGS_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__TXCLK_PRBS_GATE_ENABLE_MASK |\n\t\t\t  CPM_CONTROL__REFCLK_REGS_GATE_ENABLE_MASK);\n\t}\n\n\tif (def != data)\n\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regCPM_CONTROL), data);\n}\n\nstatic void nbio_v7_2_update_medium_grain_light_sleep(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t def, data;\n\n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(7, 2, 1):\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 0):\n\t\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CNTL2));\n\t\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_BIF_LS))\n\t\t\tdata |= PCIE_CNTL2__SLV_MEM_LS_EN_MASK;\n\t\telse\n\t\t\tdata &= ~PCIE_CNTL2__SLV_MEM_LS_EN_MASK;\n\n\t\tif (def != data)\n\t\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CNTL2), data);\n\n\t\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0,\n\t\t\tregBIF1_PCIE_TX_POWER_CTRL_1));\n\t\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_BIF_LS))\n\t\t\tdata |= (BIF1_PCIE_TX_POWER_CTRL_1__MST_MEM_LS_EN_MASK |\n\t\t\t\tBIF1_PCIE_TX_POWER_CTRL_1__REPLAY_MEM_LS_EN_MASK);\n\t\telse\n\t\t\tdata &= ~(BIF1_PCIE_TX_POWER_CTRL_1__MST_MEM_LS_EN_MASK |\n\t\t\t\tBIF1_PCIE_TX_POWER_CTRL_1__REPLAY_MEM_LS_EN_MASK);\n\n\t\tif (def != data)\n\t\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regBIF1_PCIE_TX_POWER_CTRL_1),\n\t\t\t\tdata);\n\t\tbreak;\n\tdefault:\n\t\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CNTL2));\n\t\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_BIF_LS))\n\t\t\tdata |= (PCIE_CNTL2__SLV_MEM_LS_EN_MASK |\n\t\t\t\t PCIE_CNTL2__MST_MEM_LS_EN_MASK |\n\t\t\t\t PCIE_CNTL2__REPLAY_MEM_LS_EN_MASK);\n\t\telse\n\t\t\tdata &= ~(PCIE_CNTL2__SLV_MEM_LS_EN_MASK |\n\t\t\t\t  PCIE_CNTL2__MST_MEM_LS_EN_MASK |\n\t\t\t\t  PCIE_CNTL2__REPLAY_MEM_LS_EN_MASK);\n\n\t\tif (def != data)\n\t\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CNTL2), data);\n\t\tbreak;\n\t}\n}\n\nstatic void nbio_v7_2_get_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t    u64 *flags)\n{\n\tint data;\n\n\t \n\tdata = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regCPM_CONTROL));\n\tif (data & CPM_CONTROL__LCLK_DYN_GATE_ENABLE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_MGCG;\n\n\t \n\tdata = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CNTL2));\n\tif (data & PCIE_CNTL2__SLV_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_BIF_LS;\n}\n\nstatic u32 nbio_v7_2_get_hdp_flush_req_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_REQ);\n}\n\nstatic u32 nbio_v7_2_get_hdp_flush_done_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_DONE);\n}\n\nstatic u32 nbio_v7_2_get_pcie_index_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX0_PCIE_INDEX2);\n}\n\nstatic u32 nbio_v7_2_get_pcie_data_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX0_PCIE_DATA2);\n}\n\nstatic u32 nbio_v7_2_get_pcie_port_index_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_RSMU_INDEX);\n}\n\nstatic u32 nbio_v7_2_get_pcie_port_data_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_RSMU_DATA);\n}\n\nconst struct nbio_hdp_flush_reg nbio_v7_2_hdp_flush_reg = {\n\t.ref_and_mask_cp0 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP0_MASK,\n\t.ref_and_mask_cp1 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP1_MASK,\n\t.ref_and_mask_cp2 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP2_MASK,\n\t.ref_and_mask_cp3 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP3_MASK,\n\t.ref_and_mask_cp4 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP4_MASK,\n\t.ref_and_mask_cp5 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP5_MASK,\n\t.ref_and_mask_cp6 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP6_MASK,\n\t.ref_and_mask_cp7 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP7_MASK,\n\t.ref_and_mask_cp8 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP8_MASK,\n\t.ref_and_mask_cp9 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP9_MASK,\n\t.ref_and_mask_sdma0 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__SDMA0_MASK,\n\t.ref_and_mask_sdma1 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__SDMA1_MASK,\n};\n\nstatic void nbio_v7_2_init_registers(struct amdgpu_device *adev)\n{\n\tuint32_t def, data;\n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(7, 2, 1):\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 0):\n\t\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regBIF1_PCIE_MST_CTRL_3));\n\t\tdata = REG_SET_FIELD(data, BIF1_PCIE_MST_CTRL_3,\n\t\t\tCI_SWUS_MAX_READ_REQUEST_SIZE_MODE, 1);\n\t\tdata = REG_SET_FIELD(data, BIF1_PCIE_MST_CTRL_3,\n\t\t\tCI_SWUS_MAX_READ_REQUEST_SIZE_PRIV, 1);\n\n\t\tif (def != data)\n\t\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regBIF1_PCIE_MST_CTRL_3), data);\n\t\tbreak;\n\tdefault:\n\t\tdef = data = RREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CONFIG_CNTL));\n\t\tdata = REG_SET_FIELD(data, PCIE_CONFIG_CNTL,\n\t\t\tCI_SWUS_MAX_READ_REQUEST_SIZE_MODE, 1);\n\t\tdata = REG_SET_FIELD(data, PCIE_CONFIG_CNTL,\n\t\t\tCI_SWUS_MAX_READ_REQUEST_SIZE_PRIV, 1);\n\n\t\tif (def != data)\n\t\t\tWREG32_PCIE_PORT(SOC15_REG_OFFSET(NBIO, 0, regPCIE_CONFIG_CNTL), data);\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[NBIO_HWIP][0]) {\n\tcase IP_VERSION(7, 3, 0):\n\tcase IP_VERSION(7, 5, 1):\n\t\tdata = RREG32_SOC15(NBIO, 0, regRCC_DEV2_EPF0_STRAP2);\n\t\tdata &= ~RCC_DEV2_EPF0_STRAP2__STRAP_NO_SOFT_RESET_DEV2_F0_MASK;\n\t\tWREG32_SOC15(NBIO, 0, regRCC_DEV2_EPF0_STRAP2, data);\n\t\tbreak;\n\t}\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tadev->rmmio_remap.reg_offset = SOC15_REG_OFFSET(NBIO, 0,\n\t\t\tregBIF_BX_PF0_HDP_MEM_COHERENCY_FLUSH_CNTL) << 2;\n}\n\nconst struct amdgpu_nbio_funcs nbio_v7_2_funcs = {\n\t.get_hdp_flush_req_offset = nbio_v7_2_get_hdp_flush_req_offset,\n\t.get_hdp_flush_done_offset = nbio_v7_2_get_hdp_flush_done_offset,\n\t.get_pcie_index_offset = nbio_v7_2_get_pcie_index_offset,\n\t.get_pcie_data_offset = nbio_v7_2_get_pcie_data_offset,\n\t.get_pcie_port_index_offset = nbio_v7_2_get_pcie_port_index_offset,\n\t.get_pcie_port_data_offset = nbio_v7_2_get_pcie_port_data_offset,\n\t.get_rev_id = nbio_v7_2_get_rev_id,\n\t.mc_access_enable = nbio_v7_2_mc_access_enable,\n\t.get_memsize = nbio_v7_2_get_memsize,\n\t.sdma_doorbell_range = nbio_v7_2_sdma_doorbell_range,\n\t.vcn_doorbell_range = nbio_v7_2_vcn_doorbell_range,\n\t.enable_doorbell_aperture = nbio_v7_2_enable_doorbell_aperture,\n\t.enable_doorbell_selfring_aperture = nbio_v7_2_enable_doorbell_selfring_aperture,\n\t.ih_doorbell_range = nbio_v7_2_ih_doorbell_range,\n\t.update_medium_grain_clock_gating = nbio_v7_2_update_medium_grain_clock_gating,\n\t.update_medium_grain_light_sleep = nbio_v7_2_update_medium_grain_light_sleep,\n\t.get_clockgating_state = nbio_v7_2_get_clockgating_state,\n\t.ih_control = nbio_v7_2_ih_control,\n\t.init_registers = nbio_v7_2_init_registers,\n\t.remap_hdp_registers = nbio_v7_2_remap_hdp_registers,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}