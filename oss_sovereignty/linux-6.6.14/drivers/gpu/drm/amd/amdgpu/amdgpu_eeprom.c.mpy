{
  "module_name": "amdgpu_eeprom.c",
  "hash_id": "96071344bf2b7be5a09efca9aae341ce1d076656838ea9ddb644a0d7367cc900",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_eeprom.c",
  "human_readable_source": " \n\n#include \"amdgpu_eeprom.h\"\n#include \"amdgpu.h\"\n\n \n#define EEPROM_PAGE_BITS   8\n#define EEPROM_PAGE_SIZE   (1U << EEPROM_PAGE_BITS)\n#define EEPROM_PAGE_MASK   (EEPROM_PAGE_SIZE - 1)\n\n#define EEPROM_OFFSET_SIZE 2\n\n \n#define MAKE_I2C_ADDR(_aa) ((0xA << 3) | (((_aa) >> 16) & 0xF))\n\nstatic int __amdgpu_eeprom_xfer(struct i2c_adapter *i2c_adap, u32 eeprom_addr,\n\t\t\t\tu8 *eeprom_buf, u16 buf_size, bool read)\n{\n\tu8 eeprom_offset_buf[EEPROM_OFFSET_SIZE];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.flags = 0,\n\t\t\t.len = EEPROM_OFFSET_SIZE,\n\t\t\t.buf = eeprom_offset_buf,\n\t\t},\n\t\t{\n\t\t\t.flags = read ? I2C_M_RD : 0,\n\t\t},\n\t};\n\tconst u8 *p = eeprom_buf;\n\tint r;\n\tu16 len;\n\n\tfor (r = 0; buf_size > 0;\n\t      buf_size -= len, eeprom_addr += len, eeprom_buf += len) {\n\t\t \n\t\tmsgs[0].addr = MAKE_I2C_ADDR(eeprom_addr);\n\t\tmsgs[1].addr = msgs[0].addr;\n\t\tmsgs[0].buf[0] = (eeprom_addr >> 8) & 0xff;\n\t\tmsgs[0].buf[1] = eeprom_addr & 0xff;\n\n\t\tif (!read) {\n\t\t\t \n\t\t\tlen = min(EEPROM_PAGE_SIZE - (eeprom_addr &\n\t\t\t\t\t\t      EEPROM_PAGE_MASK),\n\t\t\t\t  (u32)buf_size);\n\t\t} else {\n\t\t\t \n\t\t\tlen = buf_size;\n\t\t}\n\t\tmsgs[1].len = len;\n\t\tmsgs[1].buf = eeprom_buf;\n\n\t\t \n\t\tr = i2c_transfer(i2c_adap, msgs, ARRAY_SIZE(msgs));\n\t\tif (r != ARRAY_SIZE(msgs))\n\t\t\tbreak;\n\n\t\tif (!read) {\n\t\t\t \n\t\t\tmsleep(10);\n\t\t}\n\t}\n\n\treturn r < 0 ? r : eeprom_buf - p;\n}\n\n \nstatic int amdgpu_eeprom_xfer(struct i2c_adapter *i2c_adap, u32 eeprom_addr,\n\t\t\t      u8 *eeprom_buf, u16 buf_size, bool read)\n{\n\tconst struct i2c_adapter_quirks *quirks = i2c_adap->quirks;\n\tu16 limit;\n\tu16 ps;  \n\tint res = 0, r;\n\n\tif (!quirks)\n\t\tlimit = 0;\n\telse if (read)\n\t\tlimit = quirks->max_read_len;\n\telse\n\t\tlimit = quirks->max_write_len;\n\n\tif (limit == 0) {\n\t\treturn __amdgpu_eeprom_xfer(i2c_adap, eeprom_addr,\n\t\t\t\t\t    eeprom_buf, buf_size, read);\n\t} else if (limit <= EEPROM_OFFSET_SIZE) {\n\t\tdev_err_ratelimited(&i2c_adap->dev,\n\t\t\t\t    \"maddr:0x%04X size:0x%02X:quirk max_%s_len must be > %d\",\n\t\t\t\t    eeprom_addr, buf_size,\n\t\t\t\t    read ? \"read\" : \"write\", EEPROM_OFFSET_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlimit -= EEPROM_OFFSET_SIZE;\n\tfor ( ; buf_size > 0;\n\t      buf_size -= ps, eeprom_addr += ps, eeprom_buf += ps) {\n\t\tps = min(limit, buf_size);\n\n\t\tr = __amdgpu_eeprom_xfer(i2c_adap, eeprom_addr,\n\t\t\t\t\t eeprom_buf, ps, read);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tres += r;\n\t}\n\n\treturn res;\n}\n\nint amdgpu_eeprom_read(struct i2c_adapter *i2c_adap,\n\t\t       u32 eeprom_addr, u8 *eeprom_buf,\n\t\t       u16 bytes)\n{\n\treturn amdgpu_eeprom_xfer(i2c_adap, eeprom_addr, eeprom_buf, bytes,\n\t\t\t\t  true);\n}\n\nint amdgpu_eeprom_write(struct i2c_adapter *i2c_adap,\n\t\t\tu32 eeprom_addr, u8 *eeprom_buf,\n\t\t\tu16 bytes)\n{\n\treturn amdgpu_eeprom_xfer(i2c_adap, eeprom_addr, eeprom_buf, bytes,\n\t\t\t\t  false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}