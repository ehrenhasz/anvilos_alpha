{
  "module_name": "smu_v13_0_10.c",
  "hash_id": "32cfb121a5176cf92558867e91530f4ba1100cf25f2f38e75ac29be4926f3aee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/smu_v13_0_10.c",
  "human_readable_source": " \n\n#include \"smu_v13_0_10.h\"\n#include \"amdgpu_reset.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_job.h\"\n#include \"amdgpu_ring.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_psp.h\"\n\nstatic bool smu_v13_0_10_is_mode2_default(struct amdgpu_reset_control *reset_ctl)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\tif (adev->pm.fw_version >= 0x00502005 && !amdgpu_sriov_vf(adev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct amdgpu_reset_handler *\nsmu_v13_0_10_get_reset_handler(struct amdgpu_reset_control *reset_ctl,\n\t\t\t    struct amdgpu_reset_context *reset_context)\n{\n\tstruct amdgpu_reset_handler *handler;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tif (reset_context->method != AMD_RESET_METHOD_NONE) {\n\t\tlist_for_each_entry(handler, &reset_ctl->reset_handlers,\n\t\t\t\t     handler_list) {\n\t\t\tif (handler->reset_method == reset_context->method)\n\t\t\t\treturn handler;\n\t\t}\n\t}\n\n\tif (smu_v13_0_10_is_mode2_default(reset_ctl) &&\n\t\tamdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_MODE2) {\n\t\tlist_for_each_entry (handler, &reset_ctl->reset_handlers,\n\t\t\t\t     handler_list) {\n\t\t\tif (handler->reset_method == AMD_RESET_METHOD_MODE2)\n\t\t\t\treturn handler;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int smu_v13_0_10_mode2_suspend_ip(struct amdgpu_device *adev)\n{\n\tint r, i;\n\n\tamdgpu_device_set_pg_state(adev, AMD_PG_STATE_UNGATE);\n\tamdgpu_device_set_cg_state(adev, AMD_CG_STATE_UNGATE);\n\n\tfor (i = adev->num_ip_blocks - 1; i >= 0; i--) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_MES))\n\t\t\tcontinue;\n\n\t\tr = adev->ip_blocks[i].version->funcs->suspend(adev);\n\n\t\tif (r) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"suspend of IP block <%s> failed %d\\n\",\n\t\t\t\tadev->ip_blocks[i].version->funcs->name, r);\n\t\t\treturn r;\n\t\t}\n\t\tadev->ip_blocks[i].status.hw = false;\n\t}\n\n\treturn r;\n}\n\nstatic int\nsmu_v13_0_10_mode2_prepare_hwcontext(struct amdgpu_reset_control *reset_ctl,\n\t\t\t\t  struct amdgpu_reset_context *reset_context)\n{\n\tint r = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\tr = smu_v13_0_10_mode2_suspend_ip(adev);\n\n\treturn r;\n}\n\nstatic int smu_v13_0_10_mode2_reset(struct amdgpu_device *adev)\n{\n\treturn amdgpu_dpm_mode2_reset(adev);\n}\n\nstatic void smu_v13_0_10_async_reset(struct work_struct *work)\n{\n\tstruct amdgpu_reset_handler *handler;\n\tstruct amdgpu_reset_control *reset_ctl =\n\t\tcontainer_of(work, struct amdgpu_reset_control, reset_work);\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tlist_for_each_entry(handler, &reset_ctl->reset_handlers,\n\t\t\t     handler_list) {\n\t\tif (handler->reset_method == reset_ctl->active_reset) {\n\t\t\tdev_dbg(adev->dev, \"Resetting device\\n\");\n\t\t\thandler->do_reset(adev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nstatic int\nsmu_v13_0_10_mode2_perform_reset(struct amdgpu_reset_control *reset_ctl,\n\t\t\t      struct amdgpu_reset_context *reset_context)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\tint r;\n\n\tr = smu_v13_0_10_mode2_reset(adev);\n\tif (r) {\n\t\tdev_err(adev->dev,\n\t\t\t\"ASIC reset failed with error, %d \", r);\n\t}\n\treturn r;\n}\n\nstatic int smu_v13_0_10_mode2_restore_ip(struct amdgpu_device *adev)\n{\n\tint i, r;\n\tstruct psp_context *psp = &adev->psp;\n\tstruct amdgpu_firmware_info *ucode;\n\tstruct amdgpu_firmware_info *ucode_list[2];\n\tint ucode_count = 0;\n\n\tfor (i = 0; i < adev->firmware.max_ucodes; i++) {\n\t\tucode = &adev->firmware.ucode[i];\n\n\t\tswitch (ucode->ucode_id) {\n\t\tcase AMDGPU_UCODE_ID_IMU_I:\n\t\tcase AMDGPU_UCODE_ID_IMU_D:\n\t\t\tucode_list[ucode_count++] = ucode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tr = psp_load_fw_list(psp, ucode_list, ucode_count);\n\tif (r) {\n\t\tdev_err(adev->dev, \"IMU ucode load failed after mode2 reset\\n\");\n\t\treturn r;\n\t}\n\n\tr = psp_rlc_autoload_start(psp);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to start rlc autoload after mode2 reset\\n\");\n\t\treturn r;\n\t}\n\n\tamdgpu_dpm_enable_gfx_features(adev);\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_MES ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA))\n\t\t\tcontinue;\n\t\tr = adev->ip_blocks[i].version->funcs->resume(adev);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"resume of IP block <%s> failed %d\\n\",\n\t\t\t\tadev->ip_blocks[i].version->funcs->name, r);\n\t\t\treturn r;\n\t\t}\n\n\t\tadev->ip_blocks[i].status.hw = true;\n\t}\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_MES ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA))\n\t\t\tcontinue;\n\n\t\tif (adev->ip_blocks[i].version->funcs->late_init) {\n\t\t\tr = adev->ip_blocks[i].version->funcs->late_init(\n\t\t\t\t(void *)adev);\n\t\t\tif (r) {\n\t\t\t\tdev_err(adev->dev,\n\t\t\t\t\t\"late_init of IP block <%s> failed %d after reset\\n\",\n\t\t\t\t\tadev->ip_blocks[i].version->funcs->name,\n\t\t\t\t\tr);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\tadev->ip_blocks[i].status.late_initialized = true;\n\t}\n\n\tamdgpu_device_set_cg_state(adev, AMD_CG_STATE_GATE);\n\tamdgpu_device_set_pg_state(adev, AMD_PG_STATE_GATE);\n\n\treturn r;\n}\n\nstatic int\nsmu_v13_0_10_mode2_restore_hwcontext(struct amdgpu_reset_control *reset_ctl,\n\t\t\t\t  struct amdgpu_reset_context *reset_context)\n{\n\tint r;\n\tstruct amdgpu_device *tmp_adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tdev_info(tmp_adev->dev,\n\t\t\t\"GPU reset succeeded, trying to resume\\n\");\n\tr = smu_v13_0_10_mode2_restore_ip(tmp_adev);\n\tif (r)\n\t\tgoto end;\n\n\tamdgpu_register_gpu_instance(tmp_adev);\n\n\t \n\tamdgpu_ras_resume(tmp_adev);\n\n\tamdgpu_irq_gpu_reset_resume_helper(tmp_adev);\n\n\tr = amdgpu_ib_ring_tests(tmp_adev);\n\tif (r) {\n\t\tdev_err(tmp_adev->dev,\n\t\t\t\"ib ring test failed (%d).\\n\", r);\n\t\tr = -EAGAIN;\n\t\tgoto end;\n\t}\n\nend:\n\tif (r)\n\t\treturn -EAGAIN;\n\telse\n\t\treturn r;\n}\n\nstatic struct amdgpu_reset_handler smu_v13_0_10_mode2_handler = {\n\t.reset_method\t\t= AMD_RESET_METHOD_MODE2,\n\t.prepare_env\t\t= NULL,\n\t.prepare_hwcontext\t= smu_v13_0_10_mode2_prepare_hwcontext,\n\t.perform_reset\t\t= smu_v13_0_10_mode2_perform_reset,\n\t.restore_hwcontext\t= smu_v13_0_10_mode2_restore_hwcontext,\n\t.restore_env\t\t= NULL,\n\t.do_reset\t\t= smu_v13_0_10_mode2_reset,\n};\n\nint smu_v13_0_10_reset_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_reset_control *reset_ctl;\n\n\treset_ctl = kzalloc(sizeof(*reset_ctl), GFP_KERNEL);\n\tif (!reset_ctl)\n\t\treturn -ENOMEM;\n\n\treset_ctl->handle = adev;\n\treset_ctl->async_reset = smu_v13_0_10_async_reset;\n\treset_ctl->active_reset = AMD_RESET_METHOD_NONE;\n\treset_ctl->get_reset_handler = smu_v13_0_10_get_reset_handler;\n\n\tINIT_LIST_HEAD(&reset_ctl->reset_handlers);\n\tINIT_WORK(&reset_ctl->reset_work, reset_ctl->async_reset);\n\t \n\tamdgpu_reset_add_handler(reset_ctl, &smu_v13_0_10_mode2_handler);\n\n\tadev->reset_cntl = reset_ctl;\n\n\treturn 0;\n}\n\nint smu_v13_0_10_reset_fini(struct amdgpu_device *adev)\n{\n\tkfree(adev->reset_cntl);\n\tadev->reset_cntl = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}