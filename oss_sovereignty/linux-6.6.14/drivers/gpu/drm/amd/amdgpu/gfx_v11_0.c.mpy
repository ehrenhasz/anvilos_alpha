{
  "module_name": "gfx_v11_0.c",
  "hash_id": "66785bdcbb0aa1687b77d06a8b8470ac2140a7ebf68dad28a5c4cf519979eedc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c",
  "human_readable_source": " \n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_smu.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"imu_v11_0.h\"\n#include \"soc21.h\"\n#include \"nvd.h\"\n\n#include \"gc/gc_11_0_0_offset.h\"\n#include \"gc/gc_11_0_0_sh_mask.h\"\n#include \"smuio/smuio_13_0_6_offset.h\"\n#include \"smuio/smuio_13_0_6_sh_mask.h\"\n#include \"navi10_enum.h\"\n#include \"ivsrcid/gfx/irqsrcs_gfx_11_0_0.h\"\n\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"clearstate_gfx11.h\"\n#include \"v11_structs.h\"\n#include \"gfx_v11_0.h\"\n#include \"gfx_v11_0_3.h\"\n#include \"nbio_v4_3.h\"\n#include \"mes_v11_0.h\"\n\n#define GFX11_NUM_GFX_RINGS\t\t1\n#define GFX11_MEC_HPD_SIZE\t2048\n\n#define RLCG_UCODE_LOADING_START_ADDRESS\t0x00002000L\n#define RLC_PG_DELAY_3_DEFAULT_GC_11_0_1\t0x1388\n\n#define regCGTT_WD_CLK_CTRL\t\t0x5086\n#define regCGTT_WD_CLK_CTRL_BASE_IDX\t1\n#define regRLC_RLCS_BOOTLOAD_STATUS_gc_11_0_1\t0x4e7e\n#define regRLC_RLCS_BOOTLOAD_STATUS_gc_11_0_1_BASE_IDX\t1\n\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_0_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_0_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_0_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_0_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_0_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_1_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_1_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_1_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_1_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_2_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_2_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_2_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_2_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_3_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_3_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_3_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_3_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_4_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_4_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_4_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/gc_11_0_4_rlc.bin\");\n\nstatic const struct soc15_reg_golden golden_settings_gc_11_0[] = {\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regTCP_CNTL, 0x20000000, 0x20000000)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_11_0_1[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regCGTT_GS_NGG_CLK_CTRL, 0x9fff8fff, 0x00000010),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regCGTT_WD_CLK_CTRL, 0xffff8fff, 0x00000010),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regCPF_GCR_CNTL, 0x0007ffff, 0x0000c200),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regGL2C_CTRL3, 0xffff001b, 0x00f01988),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regPA_CL_ENHANCE, 0xf0ffffff, 0x00880007),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regPA_SC_ENHANCE_3, 0xfffffffd, 0x00000008),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regPA_SC_VRS_SURFACE_CNTL_1, 0xfff891ff, 0x55480100),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regTA_CNTL_AUX, 0xf7f7ffff, 0x01030000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, regTCP_CNTL2, 0xfcffffff, 0x0000000a)\n};\n\n#define DEFAULT_SH_MEM_CONFIG \\\n\t((SH_MEM_ADDRESS_MODE_64 << SH_MEM_CONFIG__ADDRESS_MODE__SHIFT) | \\\n\t (SH_MEM_ALIGNMENT_MODE_UNALIGNED << SH_MEM_CONFIG__ALIGNMENT_MODE__SHIFT) | \\\n\t (3 << SH_MEM_CONFIG__INITIAL_INST_PREFETCH__SHIFT))\n\nstatic void gfx_v11_0_disable_gpa_mode(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_gds_init(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_rlc_funcs(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_mqd_funcs(struct amdgpu_device *adev);\nstatic void gfx_v11_0_set_imu_funcs(struct amdgpu_device *adev);\nstatic int gfx_v11_0_get_cu_info(struct amdgpu_device *adev,\n                                 struct amdgpu_cu_info *cu_info);\nstatic uint64_t gfx_v11_0_get_gpu_clock_counter(struct amdgpu_device *adev);\nstatic void gfx_v11_0_select_se_sh(struct amdgpu_device *adev, u32 se_num,\n\t\t\t\t   u32 sh_num, u32 instance, int xcc_id);\nstatic u32 gfx_v11_0_get_wgp_active_bitmap_per_sh(struct amdgpu_device *adev);\n\nstatic void gfx_v11_0_ring_emit_de_meta(struct amdgpu_ring *ring, bool resume);\nstatic void gfx_v11_0_ring_emit_frame_cntl(struct amdgpu_ring *ring, bool start, bool secure);\nstatic void gfx_v11_0_ring_emit_wreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t     uint32_t val);\nstatic int gfx_v11_0_wait_for_rlc_autoload_complete(struct amdgpu_device *adev);\nstatic void gfx_v11_0_ring_invalidate_tlbs(struct amdgpu_ring *ring,\n\t\t\t\t\t   uint16_t pasid, uint32_t flush_type,\n\t\t\t\t\t   bool all_hub, uint8_t dst_sel);\nstatic void gfx_v11_0_set_safe_mode(struct amdgpu_device *adev, int xcc_id);\nstatic void gfx_v11_0_unset_safe_mode(struct amdgpu_device *adev, int xcc_id);\nstatic void gfx_v11_0_update_perf_clk(struct amdgpu_device *adev,\n\t\t\t\t      bool enable);\n\nstatic void gfx11_kiq_set_resources(struct amdgpu_ring *kiq_ring, uint64_t queue_mask)\n{\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_SET_RESOURCES, 6));\n\tamdgpu_ring_write(kiq_ring, PACKET3_SET_RESOURCES_VMID_MASK(0) |\n\t\t\t  PACKET3_SET_RESOURCES_QUEUE_TYPE(0));\t \n\tamdgpu_ring_write(kiq_ring, lower_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring, upper_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n}\n\nstatic void gfx11_kiq_map_queues(struct amdgpu_ring *kiq_ring,\n\t\t\t\t struct amdgpu_ring *ring)\n{\n\tuint64_t mqd_addr = amdgpu_bo_gpu_offset(ring->mqd_obj);\n\tuint64_t wptr_addr = ring->wptr_gpu_addr;\n\tuint32_t me = 0, eng_sel = 0;\n\n\tswitch (ring->funcs->type) {\n\tcase AMDGPU_RING_TYPE_COMPUTE:\n\t\tme = 1;\n\t\teng_sel = 0;\n\t\tbreak;\n\tcase AMDGPU_RING_TYPE_GFX:\n\t\tme = 0;\n\t\teng_sel = 4;\n\t\tbreak;\n\tcase AMDGPU_RING_TYPE_MES:\n\t\tme = 2;\n\t\teng_sel = 5;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));\n\t \n\tamdgpu_ring_write(kiq_ring,  \n\t\t\t  PACKET3_MAP_QUEUES_QUEUE_SEL(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_VMID(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_QUEUE(ring->queue) |\n\t\t\t  PACKET3_MAP_QUEUES_PIPE(ring->pipe) |\n\t\t\t  PACKET3_MAP_QUEUES_ME((me)) |\n\t\t\t  PACKET3_MAP_QUEUES_QUEUE_TYPE(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_ALLOC_FORMAT(0) |  \n\t\t\t  PACKET3_MAP_QUEUES_ENGINE_SEL(eng_sel) |\n\t\t\t  PACKET3_MAP_QUEUES_NUM_QUEUES(1));  \n\tamdgpu_ring_write(kiq_ring, PACKET3_MAP_QUEUES_DOORBELL_OFFSET(ring->doorbell_index));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(mqd_addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(mqd_addr));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(wptr_addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(wptr_addr));\n}\n\nstatic void gfx11_kiq_unmap_queues(struct amdgpu_ring *kiq_ring,\n\t\t\t\t   struct amdgpu_ring *ring,\n\t\t\t\t   enum amdgpu_unmap_queues_action action,\n\t\t\t\t   u64 gpu_addr, u64 seq)\n{\n\tstruct amdgpu_device *adev = kiq_ring->adev;\n\tuint32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;\n\n\tif (adev->enable_mes && !adev->gfx.kiq[0].ring.sched.ready) {\n\t\tamdgpu_mes_unmap_legacy_queue(adev, ring, action, gpu_addr, seq);\n\t\treturn;\n\t}\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_UNMAP_QUEUES, 4));\n\tamdgpu_ring_write(kiq_ring,  \n\t\t\t  PACKET3_UNMAP_QUEUES_ACTION(action) |\n\t\t\t  PACKET3_UNMAP_QUEUES_QUEUE_SEL(0) |\n\t\t\t  PACKET3_UNMAP_QUEUES_ENGINE_SEL(eng_sel) |\n\t\t\t  PACKET3_UNMAP_QUEUES_NUM_QUEUES(1));\n\tamdgpu_ring_write(kiq_ring,\n\t\t  PACKET3_UNMAP_QUEUES_DOORBELL_OFFSET0(ring->doorbell_index));\n\n\tif (action == PREEMPT_QUEUES_NO_UNMAP) {\n\t\tamdgpu_ring_write(kiq_ring, lower_32_bits(gpu_addr));\n\t\tamdgpu_ring_write(kiq_ring, upper_32_bits(gpu_addr));\n\t\tamdgpu_ring_write(kiq_ring, seq);\n\t} else {\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t}\n}\n\nstatic void gfx11_kiq_query_status(struct amdgpu_ring *kiq_ring,\n\t\t\t\t   struct amdgpu_ring *ring,\n\t\t\t\t   u64 addr,\n\t\t\t\t   u64 seq)\n{\n\tuint32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_QUERY_STATUS, 5));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\t  PACKET3_QUERY_STATUS_CONTEXT_ID(0) |\n\t\t\t  PACKET3_QUERY_STATUS_INTERRUPT_SEL(0) |\n\t\t\t  PACKET3_QUERY_STATUS_COMMAND(2));\n\tamdgpu_ring_write(kiq_ring,  \n\t\t\t  PACKET3_QUERY_STATUS_DOORBELL_OFFSET(ring->doorbell_index) |\n\t\t\t  PACKET3_QUERY_STATUS_ENG_SEL(eng_sel));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(addr));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(seq));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(seq));\n}\n\nstatic void gfx11_kiq_invalidate_tlbs(struct amdgpu_ring *kiq_ring,\n\t\t\t\tuint16_t pasid, uint32_t flush_type,\n\t\t\t\tbool all_hub)\n{\n\tgfx_v11_0_ring_invalidate_tlbs(kiq_ring, pasid, flush_type, all_hub, 1);\n}\n\nstatic const struct kiq_pm4_funcs gfx_v11_0_kiq_pm4_funcs = {\n\t.kiq_set_resources = gfx11_kiq_set_resources,\n\t.kiq_map_queues = gfx11_kiq_map_queues,\n\t.kiq_unmap_queues = gfx11_kiq_unmap_queues,\n\t.kiq_query_status = gfx11_kiq_query_status,\n\t.kiq_invalidate_tlbs = gfx11_kiq_invalidate_tlbs,\n\t.set_resources_size = 8,\n\t.map_queues_size = 7,\n\t.unmap_queues_size = 6,\n\t.query_status_size = 7,\n\t.invalidate_tlbs_size = 2,\n};\n\nstatic void gfx_v11_0_set_kiq_pm4_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.kiq[0].pmf = &gfx_v11_0_kiq_pm4_funcs;\n}\n\nstatic void gfx_v11_0_init_golden_registers(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_11_0_1,\n\t\t\t\t\t\t(const u32)ARRAY_SIZE(golden_settings_gc_11_0_1));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsoc15_program_register_sequence(adev,\n\t\t\t\t\tgolden_settings_gc_11_0,\n\t\t\t\t\t(const u32)ARRAY_SIZE(golden_settings_gc_11_0));\n\n}\n\nstatic void gfx_v11_0_write_data_to_reg(struct amdgpu_ring *ring, int eng_sel,\n\t\t\t\t       bool wc, uint32_t reg, uint32_t val)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, WRITE_DATA_ENGINE_SEL(eng_sel) |\n\t\t\t  WRITE_DATA_DST_SEL(0) | (wc ? WR_CONFIRM : 0));\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void gfx_v11_0_wait_reg_mem(struct amdgpu_ring *ring, int eng_sel,\n\t\t\t\t  int mem_space, int opt, uint32_t addr0,\n\t\t\t\t  uint32_t addr1, uint32_t ref, uint32_t mask,\n\t\t\t\t  uint32_t inv)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring,\n\t\t\t   \n\t\t\t  (WAIT_REG_MEM_MEM_SPACE(mem_space) |\n\t\t\t   WAIT_REG_MEM_OPERATION(opt) |  \n\t\t\t   WAIT_REG_MEM_FUNCTION(3) |   \n\t\t\t   WAIT_REG_MEM_ENGINE(eng_sel)));\n\n\tif (mem_space)\n\t\tBUG_ON(addr0 & 0x3);  \n\tamdgpu_ring_write(ring, addr0);\n\tamdgpu_ring_write(ring, addr1);\n\tamdgpu_ring_write(ring, ref);\n\tamdgpu_ring_write(ring, mask);\n\tamdgpu_ring_write(ring, inv);  \n}\n\nstatic int gfx_v11_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t scratch = SOC15_REG_OFFSET(GC, 0, regSCRATCH_REG0);\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 5);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring %d (%d).\\n\",\n\t\t\t  ring->idx, r);\n\t\treturn r;\n\t}\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ) {\n\t\tgfx_v11_0_ring_emit_wreg(ring, scratch, 0xDEADBEEF);\n\t} else {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\t\tamdgpu_ring_write(ring, scratch -\n\t\t\t\t  PACKET3_SET_UCONFIG_REG_START);\n\t\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\t}\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tif (amdgpu_emu_mode == 1)\n\t\t\tmsleep(1);\n\t\telse\n\t\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\treturn r;\n}\n\nstatic int gfx_v11_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\tunsigned index;\n\tuint64_t gpu_addr;\n\tvolatile uint32_t *cpu_ptr;\n\tlong r;\n\n\t \n\tif (adev->enable_mes_kiq &&\n\t    ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\treturn 0;\n\n\tmemset(&ib, 0, sizeof(ib));\n\n\tif (ring->is_mes_queue) {\n\t\tuint32_t padding, offset;\n\n\t\toffset = amdgpu_mes_ctx_get_offs(ring, AMDGPU_MES_CTX_IB_OFFS);\n\t\tpadding = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\t\t\t  AMDGPU_MES_CTX_PADDING_OFFS);\n\n\t\tib.gpu_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tib.ptr = amdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\n\t\tgpu_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, padding);\n\t\tcpu_ptr = amdgpu_mes_ctx_get_offs_cpu_addr(ring, padding);\n\t\t*cpu_ptr = cpu_to_le32(0xCAFEDEAD);\n\t} else {\n\t\tr = amdgpu_device_wb_get(adev, &index);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tgpu_addr = adev->wb.gpu_addr + (index * 4);\n\t\tadev->wb.wb[index] = cpu_to_le32(0xCAFEDEAD);\n\t\tcpu_ptr = &adev->wb.wb[index];\n\n\t\tr = amdgpu_ib_get(adev, NULL, 20, AMDGPU_IB_POOL_DIRECT, &ib);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"amdgpu: failed to get ib (%ld).\\n\", r);\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tib.ptr[0] = PACKET3(PACKET3_WRITE_DATA, 3);\n\tib.ptr[1] = WRITE_DATA_DST_SEL(5) | WR_CONFIRM;\n\tib.ptr[2] = lower_32_bits(gpu_addr);\n\tib.ptr[3] = upper_32_bits(gpu_addr);\n\tib.ptr[4] = 0xDEADBEEF;\n\tib.length_dw = 5;\n\n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r)\n\t\tgoto err2;\n\n\tr = dma_fence_wait_timeout(f, false, timeout);\n\tif (r == 0) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto err2;\n\t} else if (r < 0) {\n\t\tgoto err2;\n\t}\n\n\tif (le32_to_cpu(*cpu_ptr) == 0xDEADBEEF)\n\t\tr = 0;\n\telse\n\t\tr = -EINVAL;\nerr2:\n\tif (!ring->is_mes_queue)\n\t\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\nerr1:\n\tif (!ring->is_mes_queue)\n\t\tamdgpu_device_wb_free(adev, index);\n\treturn r;\n}\n\nstatic void gfx_v11_0_free_microcode(struct amdgpu_device *adev)\n{\n\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\n\tkfree(adev->gfx.rlc.register_list_format);\n}\n\nstatic int gfx_v11_0_init_toc_microcode(struct amdgpu_device *adev, const char *ucode_prefix)\n{\n\tconst struct psp_firmware_header_v1_0 *toc_hdr;\n\tint err = 0;\n\tchar fw_name[40];\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_toc.bin\", ucode_prefix);\n\terr = amdgpu_ucode_request(adev, &adev->psp.toc_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\ttoc_hdr = (const struct psp_firmware_header_v1_0 *)adev->psp.toc_fw->data;\n\tadev->psp.toc.fw_version = le32_to_cpu(toc_hdr->header.ucode_version);\n\tadev->psp.toc.feature_version = le32_to_cpu(toc_hdr->sos.fw_version);\n\tadev->psp.toc.size_bytes = le32_to_cpu(toc_hdr->header.ucode_size_bytes);\n\tadev->psp.toc.start_addr = (uint8_t *)toc_hdr +\n\t\t\t\tle32_to_cpu(toc_hdr->header.ucode_array_offset_bytes);\n\treturn 0;\nout:\n\tamdgpu_ucode_release(&adev->psp.toc_fw);\n\treturn err;\n}\n\nstatic void gfx_v11_0_check_fw_cp_gfx_shadow(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\t\tif ((adev->gfx.me_fw_version >= 1505) &&\n\t\t    (adev->gfx.pfp_fw_version >= 1600) &&\n\t\t    (adev->gfx.mec_fw_version >= 512)) {\n\t\t\tif (amdgpu_sriov_vf(adev))\n\t\t\t\tadev->gfx.cp_gfx_shadow = true;\n\t\t\telse\n\t\t\t\tadev->gfx.cp_gfx_shadow = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tadev->gfx.cp_gfx_shadow = false;\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v11_0_init_microcode(struct amdgpu_device *adev)\n{\n\tchar fw_name[40];\n\tchar ucode_prefix[30];\n\tint err;\n\tconst struct rlc_firmware_header_v2_0 *rlc_hdr;\n\tuint16_t version_major;\n\tuint16_t version_minor;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tamdgpu_ucode_ip_version_decode(adev, GC_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp.bin\", ucode_prefix);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\t \n\tadev->gfx.rs64_enable = amdgpu_ucode_hdr_version(\n\t\t\t\t(union amdgpu_firmware_header *)\n\t\t\t\tadev->gfx.pfp_fw->data, 2, 0);\n\tif (adev->gfx.rs64_enable) {\n\t\tdev_info(adev->dev, \"CP RS64 enable\\n\");\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_PFP);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_PFP_P0_STACK);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_PFP_P1_STACK);\n\t} else {\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_PFP);\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me.bin\", ucode_prefix);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tif (adev->gfx.rs64_enable) {\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_ME);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_ME_P0_STACK);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_ME_P1_STACK);\n\t} else {\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_ME);\n\t}\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", ucode_prefix);\n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.rlc_fw, fw_name);\n\t\tif (err)\n\t\t\tgoto out;\n\t\trlc_hdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\t\tversion_major = le16_to_cpu(rlc_hdr->header.header_version_major);\n\t\tversion_minor = le16_to_cpu(rlc_hdr->header.header_version_minor);\n\t\terr = amdgpu_gfx_rlc_init_microcode(adev, version_major, version_minor);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", ucode_prefix);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tif (adev->gfx.rs64_enable) {\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_MEC);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_MEC_P0_STACK);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_MEC_P1_STACK);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_MEC_P2_STACK);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_RS64_MEC_P3_STACK);\n\t} else {\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC1);\n\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC1_JT);\n\t}\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO)\n\t\terr = gfx_v11_0_init_toc_microcode(adev, ucode_prefix);\n\n\t \n\tadev->gfx.mec2_fw = NULL;\n\n\tgfx_v11_0_check_fw_cp_gfx_shadow(adev);\nout:\n\tif (err) {\n\t\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\t}\n\n\treturn err;\n}\n\nstatic u32 gfx_v11_0_get_csb_size(struct amdgpu_device *adev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = gfx11_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tcount += 3;\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nstatic void gfx_v11_0_get_csb_buffer(struct amdgpu_device *adev,\n\t\t\t\t    volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint ctx_reg_offset;\n\n\tif (adev->gfx.rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index -\n\t\t\t\t\t\tPACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tctx_reg_offset =\n\t\tSOC15_REG_OFFSET(GC, 0, regPA_SC_TILE_STEERING_OVERRIDE) - PACKET3_SET_CONTEXT_REG_START;\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, 1));\n\tbuffer[count++] = cpu_to_le32(ctx_reg_offset);\n\tbuffer[count++] = cpu_to_le32(adev->gfx.config.pa_sc_tile_steering_override);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic void gfx_v11_0_rlc_fini(struct amdgpu_device *adev)\n{\n\t \n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.clear_state_obj,\n\t\t\t&adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t(void **)&adev->gfx.rlc.cs_ptr);\n\n\t \n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.cp_table_obj,\n\t\t\t&adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t(void **)&adev->gfx.rlc.cp_table_ptr);\n}\n\nstatic void gfx_v11_0_init_rlcg_reg_access_ctrl(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_rlcg_reg_access_ctrl *reg_access_ctrl;\n\n\treg_access_ctrl = &adev->gfx.rlc.reg_access_ctrl[0];\n\treg_access_ctrl->scratch_reg0 = SOC15_REG_OFFSET(GC, 0, regSCRATCH_REG0);\n\treg_access_ctrl->scratch_reg1 = SOC15_REG_OFFSET(GC, 0, regSCRATCH_REG1);\n\treg_access_ctrl->scratch_reg2 = SOC15_REG_OFFSET(GC, 0, regSCRATCH_REG2);\n\treg_access_ctrl->scratch_reg3 = SOC15_REG_OFFSET(GC, 0, regSCRATCH_REG3);\n\treg_access_ctrl->grbm_cntl = SOC15_REG_OFFSET(GC, 0, regGRBM_GFX_CNTL);\n\treg_access_ctrl->grbm_idx = SOC15_REG_OFFSET(GC, 0, regGRBM_GFX_INDEX);\n\treg_access_ctrl->spare_int = SOC15_REG_OFFSET(GC, 0, regRLC_SPARE_INT_0);\n\tadev->gfx.rlc.rlcg_reg_access_supported = true;\n}\n\nstatic int gfx_v11_0_rlc_init(struct amdgpu_device *adev)\n{\n\tconst struct cs_section_def *cs_data;\n\tint r;\n\n\tadev->gfx.rlc.cs_data = gfx11_cs_data;\n\n\tcs_data = adev->gfx.rlc.cs_data;\n\n\tif (cs_data) {\n\t\t \n\t\tr = amdgpu_gfx_rlc_init_csb(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (adev->gfx.rlc.funcs->update_spm_vmid)\n\t\tadev->gfx.rlc.funcs->update_spm_vmid(adev, 0xf);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_mec_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.hpd_eop_obj, NULL, NULL);\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.mec_fw_obj, NULL, NULL);\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.mec_fw_data_obj, NULL, NULL);\n}\n\nstatic void gfx_v11_0_me_init(struct amdgpu_device *adev)\n{\n\tbitmap_zero(adev->gfx.me.queue_bitmap, AMDGPU_MAX_GFX_QUEUES);\n\n\tamdgpu_gfx_graphics_queue_acquire(adev);\n}\n\nstatic int gfx_v11_0_mec_init(struct amdgpu_device *adev)\n{\n\tint r;\n\tu32 *hpd;\n\tsize_t mec_hpd_size;\n\n\tbitmap_zero(adev->gfx.mec_bitmap[0].queue_bitmap, AMDGPU_MAX_COMPUTE_QUEUES);\n\n\t \n\tamdgpu_gfx_compute_queue_acquire(adev);\n\tmec_hpd_size = adev->gfx.num_compute_rings * GFX11_MEC_HPD_SIZE;\n\n\tif (mec_hpd_size) {\n\t\tr = amdgpu_bo_create_reserved(adev, mec_hpd_size, PAGE_SIZE,\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_obj,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_gpu_addr,\n\t\t\t\t\t      (void **)&hpd);\n\t\tif (r) {\n\t\t\tdev_warn(adev->dev, \"(%d) create HDP EOP bo failed\\n\", r);\n\t\t\tgfx_v11_0_mec_fini(adev);\n\t\t\treturn r;\n\t\t}\n\n\t\tmemset(hpd, 0, mec_hpd_size);\n\n\t\tamdgpu_bo_kunmap(adev->gfx.mec.hpd_eop_obj);\n\t\tamdgpu_bo_unreserve(adev->gfx.mec.hpd_eop_obj);\n\t}\n\n\treturn 0;\n}\n\nstatic uint32_t wave_read_ind(struct amdgpu_device *adev, uint32_t wave, uint32_t address)\n{\n\tWREG32_SOC15(GC, 0, regSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(address << SQ_IND_INDEX__INDEX__SHIFT));\n\treturn RREG32_SOC15(GC, 0, regSQ_IND_DATA);\n}\n\nstatic void wave_read_regs(struct amdgpu_device *adev, uint32_t wave,\n\t\t\t   uint32_t thread, uint32_t regno,\n\t\t\t   uint32_t num, uint32_t *out)\n{\n\tWREG32_SOC15(GC, 0, regSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(regno << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(thread << SQ_IND_INDEX__WORKITEM_ID__SHIFT) |\n\t\t(SQ_IND_INDEX__AUTO_INCR_MASK));\n\twhile (num--)\n\t\t*(out++) = RREG32_SOC15(GC, 0, regSQ_IND_DATA);\n}\n\nstatic void gfx_v11_0_read_wave_data(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd, uint32_t wave, uint32_t *dst, int *no_fields)\n{\n\t \n\tWARN_ON(simd != 0);\n\n\t \n\tdst[(*no_fields)++] = 3;\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_STATUS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_PC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_PC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_EXEC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_EXEC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_HW_ID1);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_HW_ID2);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_GPR_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_LDS_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_TRAPSTS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_IB_STS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_IB_STS2);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_IB_DBG1);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_M0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, wave, ixSQ_WAVE_MODE);\n}\n\nstatic void gfx_v11_0_read_wave_sgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t     uint32_t wave, uint32_t start,\n\t\t\t\t     uint32_t size, uint32_t *dst)\n{\n\tWARN_ON(simd != 0);\n\n\twave_read_regs(\n\t\tadev, wave, 0, start + SQIND_WAVE_SGPRS_OFFSET, size,\n\t\tdst);\n}\n\nstatic void gfx_v11_0_read_wave_vgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t      uint32_t wave, uint32_t thread,\n\t\t\t\t      uint32_t start, uint32_t size,\n\t\t\t\t      uint32_t *dst)\n{\n\twave_read_regs(\n\t\tadev, wave, thread,\n\t\tstart + SQIND_WAVE_VGPRS_OFFSET, size, dst);\n}\n\nstatic void gfx_v11_0_select_me_pipe_q(struct amdgpu_device *adev,\n\t\t\t\t\tu32 me, u32 pipe, u32 q, u32 vm, u32 xcc_id)\n{\n\tsoc21_grbm_select(adev, me, pipe, q, vm);\n}\n\n \n#define MQD_SHADOW_BASE_SIZE      73728\n#define MQD_SHADOW_BASE_ALIGNMENT 256\n#define MQD_FWWORKAREA_SIZE       484\n#define MQD_FWWORKAREA_ALIGNMENT  256\n\nstatic int gfx_v11_0_get_gfx_shadow_info(struct amdgpu_device *adev,\n\t\t\t\t\t struct amdgpu_gfx_shadow_info *shadow_info)\n{\n\tif (adev->gfx.cp_gfx_shadow) {\n\t\tshadow_info->shadow_size = MQD_SHADOW_BASE_SIZE;\n\t\tshadow_info->shadow_alignment = MQD_SHADOW_BASE_ALIGNMENT;\n\t\tshadow_info->csa_size = MQD_FWWORKAREA_SIZE;\n\t\tshadow_info->csa_alignment = MQD_FWWORKAREA_ALIGNMENT;\n\t\treturn 0;\n\t} else {\n\t\tmemset(shadow_info, 0, sizeof(struct amdgpu_gfx_shadow_info));\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic const struct amdgpu_gfx_funcs gfx_v11_0_gfx_funcs = {\n\t.get_gpu_clock_counter = &gfx_v11_0_get_gpu_clock_counter,\n\t.select_se_sh = &gfx_v11_0_select_se_sh,\n\t.read_wave_data = &gfx_v11_0_read_wave_data,\n\t.read_wave_sgprs = &gfx_v11_0_read_wave_sgprs,\n\t.read_wave_vgprs = &gfx_v11_0_read_wave_vgprs,\n\t.select_me_pipe_q = &gfx_v11_0_select_me_pipe_q,\n\t.update_perfmon_mgcg = &gfx_v11_0_update_perf_clk,\n\t.get_gfx_shadow_info = &gfx_v11_0_get_gfx_shadow_info,\n};\n\nstatic int gfx_v11_0_gpu_early_init(struct amdgpu_device *adev)\n{\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 3):\n\t\tadev->gfx.ras = &gfx_v11_0_3_ras;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x80;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x300;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_gfx_ring_init(struct amdgpu_device *adev, int ring_id,\n\t\t\t\t   int me, int pipe, int queue)\n{\n\tint r;\n\tstruct amdgpu_ring *ring;\n\tunsigned int irq_type;\n\n\tring = &adev->gfx.gfx_ring[ring_id];\n\n\tring->me = me;\n\tring->pipe = pipe;\n\tring->queue = queue;\n\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\n\tif (!ring_id)\n\t\tring->doorbell_index = adev->doorbell_index.gfx_ring0 << 1;\n\telse\n\t\tring->doorbell_index = adev->doorbell_index.gfx_ring1 << 1;\n\tring->vm_hub = AMDGPU_GFXHUB(0);\n\tsprintf(ring->name, \"gfx_%d.%d.%d\", ring->me, ring->pipe, ring->queue);\n\n\tirq_type = AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP + ring->pipe;\n\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq, irq_type,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int gfx_v11_0_compute_ring_init(struct amdgpu_device *adev, int ring_id,\n\t\t\t\t       int mec, int pipe, int queue)\n{\n\tint r;\n\tunsigned irq_type;\n\tstruct amdgpu_ring *ring;\n\tunsigned int hw_prio;\n\n\tring = &adev->gfx.compute_ring[ring_id];\n\n\t \n\tring->me = mec + 1;\n\tring->pipe = pipe;\n\tring->queue = queue;\n\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\tring->doorbell_index = (adev->doorbell_index.mec_ring0 + ring_id) << 1;\n\tring->eop_gpu_addr = adev->gfx.mec.hpd_eop_gpu_addr\n\t\t\t\t+ (ring_id * GFX11_MEC_HPD_SIZE);\n\tring->vm_hub = AMDGPU_GFXHUB(0);\n\tsprintf(ring->name, \"comp_%d.%d.%d\", ring->me, ring->pipe, ring->queue);\n\n\tirq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP\n\t\t+ ((ring->me - 1) * adev->gfx.mec.num_pipe_per_mec)\n\t\t+ ring->pipe;\n\thw_prio = amdgpu_gfx_is_high_priority_compute_queue(adev, ring) ?\n\t\t\tAMDGPU_GFX_PIPE_PRIO_HIGH : AMDGPU_GFX_PIPE_PRIO_NORMAL;\n\t \n\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq, irq_type,\n\t\t\t     hw_prio, NULL);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic struct {\n\tSOC21_FIRMWARE_ID\tid;\n\tunsigned int\t\toffset;\n\tunsigned int\t\tsize;\n} rlc_autoload_info[SOC21_FIRMWARE_ID_MAX];\n\nstatic void gfx_v11_0_parse_rlc_toc(struct amdgpu_device *adev, void *rlc_toc)\n{\n\tRLC_TABLE_OF_CONTENT *ucode = rlc_toc;\n\n\twhile (ucode && (ucode->id > SOC21_FIRMWARE_ID_INVALID) &&\n\t\t\t(ucode->id < SOC21_FIRMWARE_ID_MAX)) {\n\t\trlc_autoload_info[ucode->id].id = ucode->id;\n\t\trlc_autoload_info[ucode->id].offset = ucode->offset * 4;\n\t\trlc_autoload_info[ucode->id].size = ucode->size * 4;\n\n\t\tucode++;\n\t}\n}\n\nstatic uint32_t gfx_v11_0_calc_toc_total_size(struct amdgpu_device *adev)\n{\n\tuint32_t total_size = 0;\n\tSOC21_FIRMWARE_ID id;\n\n\tgfx_v11_0_parse_rlc_toc(adev, adev->psp.toc.start_addr);\n\n\tfor (id = SOC21_FIRMWARE_ID_RLC_G_UCODE; id < SOC21_FIRMWARE_ID_MAX; id++)\n\t\ttotal_size += rlc_autoload_info[id].size;\n\n\t \n\tif (total_size < rlc_autoload_info[SOC21_FIRMWARE_ID_MAX-1].offset)\n\t\ttotal_size = rlc_autoload_info[SOC21_FIRMWARE_ID_MAX-1].offset +\n\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_MAX-1].size;\n\n\treturn total_size;\n}\n\nstatic int gfx_v11_0_rlc_autoload_buffer_init(struct amdgpu_device *adev)\n{\n\tint r;\n\tuint32_t total_size;\n\n\ttotal_size = gfx_v11_0_calc_toc_total_size(adev);\n\n\tr = amdgpu_bo_create_reserved(adev, total_size, 64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.rlc.rlc_autoload_bo,\n\t\t\t\t      &adev->gfx.rlc.rlc_autoload_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.rlc.rlc_autoload_ptr);\n\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create fw autoload bo\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_rlc_backdoor_autoload_copy_ucode(struct amdgpu_device *adev,\n\t\t\t\t\t      SOC21_FIRMWARE_ID id,\n\t\t\t    \t\t      const void *fw_data,\n\t\t\t\t\t      uint32_t fw_size,\n\t\t\t\t\t      uint32_t *fw_autoload_mask)\n{\n\tuint32_t toc_offset;\n\tuint32_t toc_fw_size;\n\tchar *ptr = adev->gfx.rlc.rlc_autoload_ptr;\n\n\tif (id <= SOC21_FIRMWARE_ID_INVALID || id >= SOC21_FIRMWARE_ID_MAX)\n\t\treturn;\n\n\ttoc_offset = rlc_autoload_info[id].offset;\n\ttoc_fw_size = rlc_autoload_info[id].size;\n\n\tif (fw_size == 0)\n\t\tfw_size = toc_fw_size;\n\n\tif (fw_size > toc_fw_size)\n\t\tfw_size = toc_fw_size;\n\n\tmemcpy(ptr + toc_offset, fw_data, fw_size);\n\n\tif (fw_size < toc_fw_size)\n\t\tmemset(ptr + toc_offset + fw_size, 0, toc_fw_size - fw_size);\n\n\tif ((id != SOC21_FIRMWARE_ID_RS64_PFP) && (id != SOC21_FIRMWARE_ID_RS64_ME))\n\t\t*(uint64_t *)fw_autoload_mask |= 1ULL << id;\n}\n\nstatic void gfx_v11_0_rlc_backdoor_autoload_copy_toc_ucode(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tuint32_t *fw_autoload_mask)\n{\n\tvoid *data;\n\tuint32_t size;\n\tuint64_t *toc_ptr;\n\n\t*(uint64_t *)fw_autoload_mask |= 0x1;\n\n\tDRM_DEBUG(\"rlc autoload enabled fw: 0x%llx\\n\", *(uint64_t *)fw_autoload_mask);\n\n\tdata = adev->psp.toc.start_addr;\n\tsize = rlc_autoload_info[SOC21_FIRMWARE_ID_RLC_TOC].size;\n\n\ttoc_ptr = (uint64_t *)data + size / 8 - 1;\n\t*toc_ptr = *(uint64_t *)fw_autoload_mask;\n\n\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RLC_TOC,\n\t\t\t\t\tdata, size, fw_autoload_mask);\n}\n\nstatic void gfx_v11_0_rlc_backdoor_autoload_copy_gfx_ucode(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tuint32_t *fw_autoload_mask)\n{\n\tconst __le32 *fw_data;\n\tuint32_t fw_size;\n\tconst struct gfx_firmware_header_v1_0 *cp_hdr;\n\tconst struct gfx_firmware_header_v2_0 *cpv2_hdr;\n\tconst struct rlc_firmware_header_v2_0 *rlc_hdr;\n\tconst struct rlc_firmware_header_v2_2 *rlcv22_hdr;\n\tuint16_t version_major, version_minor;\n\n\tif (adev->gfx.rs64_enable) {\n\t\t \n\t\tcpv2_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.pfp_fw->data;\n\t\t \n\t\tfw_data = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->ucode_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_PFP,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t \n\t\tfw_data = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_PFP_P0_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_PFP_P1_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t \n\t\tcpv2_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.me_fw->data;\n\t\t \n\t\tfw_data = (const __le32 *)(adev->gfx.me_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->ucode_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_ME,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t \n\t\tfw_data = (const __le32 *)(adev->gfx.me_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_ME_P0_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_ME_P1_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t \n\t\tcpv2_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\t \n\t\tfw_data = (const __le32 *) (adev->gfx.mec_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->ucode_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->ucode_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_MEC,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t \n\t\tfw_data = (const __le32 *) (adev->gfx.mec_fw->data +\n\t\t\tle32_to_cpu(cpv2_hdr->data_offset_bytes));\n\t\tfw_size = le32_to_cpu(cpv2_hdr->data_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_MEC_P0_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_MEC_P1_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_MEC_P2_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RS64_MEC_P3_STACK,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t} else {\n\t\t \n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.pfp_fw->data;\n\t\tfw_data = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\t\t\tle32_to_cpu(cp_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_CP_PFP,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\n\t\t \n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.me_fw->data;\n\t\tfw_data = (const __le32 *)(adev->gfx.me_fw->data +\n\t\t\t\tle32_to_cpu(cp_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes);\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_CP_ME,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\n\t\t \n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\tfw_data = (const __le32 *) (adev->gfx.mec_fw->data +\n\t\t\t\tle32_to_cpu(cp_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes) -\n\t\t\tcp_hdr->jt_size * 4;\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_CP_MEC,\n\t\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t}\n\n\t \n\trlc_hdr = (const struct rlc_firmware_header_v2_0 *)\n\t\tadev->gfx.rlc_fw->data;\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\tle32_to_cpu(rlc_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(rlc_hdr->header.ucode_size_bytes);\n\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RLC_G_UCODE,\n\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\n\tversion_major = le16_to_cpu(rlc_hdr->header.header_version_major);\n\tversion_minor = le16_to_cpu(rlc_hdr->header.header_version_minor);\n\tif (version_major == 2) {\n\t\tif (version_minor >= 2) {\n\t\t\trlcv22_hdr = (const struct rlc_firmware_header_v2_2 *)adev->gfx.rlc_fw->data;\n\n\t\t\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\t\t\tle32_to_cpu(rlcv22_hdr->rlc_iram_ucode_offset_bytes));\n\t\t\tfw_size = le32_to_cpu(rlcv22_hdr->rlc_iram_ucode_size_bytes);\n\t\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RLX6_UCODE,\n\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\n\t\t\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\t\t\tle32_to_cpu(rlcv22_hdr->rlc_dram_ucode_offset_bytes));\n\t\t\tfw_size = le32_to_cpu(rlcv22_hdr->rlc_dram_ucode_size_bytes);\n\t\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev, SOC21_FIRMWARE_ID_RLX6_DRAM_BOOT,\n\t\t\t\t\tfw_data, fw_size, fw_autoload_mask);\n\t\t}\n\t}\n}\n\nstatic void gfx_v11_0_rlc_backdoor_autoload_copy_sdma_ucode(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tuint32_t *fw_autoload_mask)\n{\n\tconst __le32 *fw_data;\n\tuint32_t fw_size;\n\tconst struct sdma_firmware_header_v2_0 *sdma_hdr;\n\n\tsdma_hdr = (const struct sdma_firmware_header_v2_0 *)\n\t\tadev->sdma.instance[0].fw->data;\n\tfw_data = (const __le32 *) (adev->sdma.instance[0].fw->data +\n\t\t\tle32_to_cpu(sdma_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(sdma_hdr->ctx_ucode_size_bytes);\n\n\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev,\n\t\t\tSOC21_FIRMWARE_ID_SDMA_UCODE_TH0, fw_data, fw_size, fw_autoload_mask);\n\n\tfw_data = (const __le32 *) (adev->sdma.instance[0].fw->data +\n\t\t\tle32_to_cpu(sdma_hdr->ctl_ucode_offset));\n\tfw_size = le32_to_cpu(sdma_hdr->ctl_ucode_size_bytes);\n\n\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev,\n\t\t\tSOC21_FIRMWARE_ID_SDMA_UCODE_TH1, fw_data, fw_size, fw_autoload_mask);\n}\n\nstatic void gfx_v11_0_rlc_backdoor_autoload_copy_mes_ucode(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tuint32_t *fw_autoload_mask)\n{\n\tconst __le32 *fw_data;\n\tunsigned fw_size;\n\tconst struct mes_firmware_header_v1_0 *mes_hdr;\n\tint pipe, ucode_id, data_id;\n\n\tfor (pipe = 0; pipe < 2; pipe++) {\n\t\tif (pipe==0) {\n\t\t\tucode_id = SOC21_FIRMWARE_ID_RS64_MES_P0;\n\t\t\tdata_id  = SOC21_FIRMWARE_ID_RS64_MES_P0_STACK;\n\t\t} else {\n\t\t\tucode_id = SOC21_FIRMWARE_ID_RS64_MES_P1;\n\t\t\tdata_id  = SOC21_FIRMWARE_ID_RS64_MES_P1_STACK;\n\t\t}\n\n\t\tmes_hdr = (const struct mes_firmware_header_v1_0 *)\n\t\t\tadev->mes.fw[pipe]->data;\n\n\t\tfw_data = (const __le32 *)(adev->mes.fw[pipe]->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_offset_bytes));\n\t\tfw_size = le32_to_cpu(mes_hdr->mes_ucode_size_bytes);\n\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev,\n\t\t\t\tucode_id, fw_data, fw_size, fw_autoload_mask);\n\n\t\tfw_data = (const __le32 *)(adev->mes.fw[pipe]->data +\n\t\t\t\tle32_to_cpu(mes_hdr->mes_ucode_data_offset_bytes));\n\t\tfw_size = le32_to_cpu(mes_hdr->mes_ucode_data_size_bytes);\n\n\t\tgfx_v11_0_rlc_backdoor_autoload_copy_ucode(adev,\n\t\t\t\tdata_id, fw_data, fw_size, fw_autoload_mask);\n\t}\n}\n\nstatic int gfx_v11_0_rlc_backdoor_autoload_enable(struct amdgpu_device *adev)\n{\n\tuint32_t rlc_g_offset, rlc_g_size;\n\tuint64_t gpu_addr;\n\tuint32_t autoload_fw_id[2];\n\n\tmemset(autoload_fw_id, 0, sizeof(uint32_t) * 2);\n\n\t \n\tgfx_v11_0_rlc_backdoor_autoload_copy_sdma_ucode(adev, autoload_fw_id);\n\tgfx_v11_0_rlc_backdoor_autoload_copy_gfx_ucode(adev, autoload_fw_id);\n\tgfx_v11_0_rlc_backdoor_autoload_copy_mes_ucode(adev, autoload_fw_id);\n\tgfx_v11_0_rlc_backdoor_autoload_copy_toc_ucode(adev, autoload_fw_id);\n\n\trlc_g_offset = rlc_autoload_info[SOC21_FIRMWARE_ID_RLC_G_UCODE].offset;\n\trlc_g_size = rlc_autoload_info[SOC21_FIRMWARE_ID_RLC_G_UCODE].size;\n\tgpu_addr = adev->gfx.rlc.rlc_autoload_gpu_addr + rlc_g_offset;\n\n\tWREG32_SOC15(GC, 0, regGFX_IMU_RLC_BOOTLOADER_ADDR_HI, upper_32_bits(gpu_addr));\n\tWREG32_SOC15(GC, 0, regGFX_IMU_RLC_BOOTLOADER_ADDR_LO, lower_32_bits(gpu_addr));\n\n\tWREG32_SOC15(GC, 0, regGFX_IMU_RLC_BOOTLOADER_SIZE, rlc_g_size);\n\n\t \n\tif (adev->gfx.imu.funcs->load_microcode)\n\t\tadev->gfx.imu.funcs->load_microcode(adev);\n\t \n\tif (adev->gfx.imu.funcs->setup_imu)\n\t\tadev->gfx.imu.funcs->setup_imu(adev);\n\tif (adev->gfx.imu.funcs->start_imu)\n\t\tadev->gfx.imu.funcs->start_imu(adev);\n\n\t \n\tgfx_v11_0_disable_gpa_mode(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_sw_init(void *handle)\n{\n\tint i, j, k, r, ring_id = 0;\n\tstruct amdgpu_kiq *kiq;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->gfxhub.funcs->init(adev);\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\t\tadev->gfx.me.num_me = 1;\n\t\tadev->gfx.me.num_pipe_per_me = 1;\n\t\tadev->gfx.me.num_queue_per_pipe = 1;\n\t\tadev->gfx.mec.num_mec = 2;\n\t\tadev->gfx.mec.num_pipe_per_mec = 4;\n\t\tadev->gfx.mec.num_queue_per_pipe = 4;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tadev->gfx.me.num_me = 1;\n\t\tadev->gfx.me.num_pipe_per_me = 1;\n\t\tadev->gfx.me.num_queue_per_pipe = 1;\n\t\tadev->gfx.mec.num_mec = 1;\n\t\tadev->gfx.mec.num_pipe_per_mec = 4;\n\t\tadev->gfx.mec.num_queue_per_pipe = 4;\n\t\tbreak;\n\tdefault:\n\t\tadev->gfx.me.num_me = 1;\n\t\tadev->gfx.me.num_pipe_per_me = 1;\n\t\tadev->gfx.me.num_queue_per_pipe = 1;\n\t\tadev->gfx.mec.num_mec = 1;\n\t\tadev->gfx.mec.num_pipe_per_mec = 4;\n\t\tadev->gfx.mec.num_queue_per_pipe = 8;\n\t\tbreak;\n\t}\n\n\t \n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(11, 0, 3) &&\n\t\tamdgpu_sriov_is_pp_one_vf(adev))\n\t\tadev->cg_flags = AMD_CG_SUPPORT_GFX_CGCG;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC21_IH_CLIENTID_GRBM_CP,\n\t\t\t      GFX_11_0_0__SRCID__CP_EOP_INTERRUPT,\n\t\t\t      &adev->gfx.eop_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC21_IH_CLIENTID_GRBM_CP,\n\t\t\t      GFX_11_0_0__SRCID__CP_PRIV_REG_FAULT,\n\t\t\t      &adev->gfx.priv_reg_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC21_IH_CLIENTID_GRBM_CP,\n\t\t\t      GFX_11_0_0__SRCID__CP_PRIV_INSTR_FAULT,\n\t\t\t      &adev->gfx.priv_inst_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC21_IH_CLIENTID_GFX,\n\t\t\t\t  GFX_11_0_0__SRCID__RLC_GC_FED_INTERRUPT,\n\t\t\t\t  &adev->gfx.rlc_gc_fed_irq);\n\tif (r)\n\t\treturn r;\n\n\tadev->gfx.gfx_current_status = AMDGPU_GFX_NORMAL_MODE;\n\n\tif (adev->gfx.imu.funcs) {\n\t\tif (adev->gfx.imu.funcs->init_microcode) {\n\t\t\tr = adev->gfx.imu.funcs->init_microcode(adev);\n\t\t\tif (r)\n\t\t\t\tDRM_ERROR(\"Failed to load imu firmware!\\n\");\n\t\t}\n\t}\n\n\tgfx_v11_0_me_init(adev);\n\n\tr = gfx_v11_0_rlc_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tr = gfx_v11_0_mec_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init MEC BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.me.num_me; i++) {\n\t\tfor (j = 0; j < adev->gfx.me.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.me.num_pipe_per_me; k++) {\n\t\t\t\tif (!amdgpu_gfx_is_me_queue_enabled(adev, i, k, j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tr = gfx_v11_0_gfx_ring_init(adev, ring_id,\n\t\t\t\t\t\t\t    i, k, j);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\t\t\t\tring_id++;\n\t\t\t}\n\t\t}\n\t}\n\n\tring_id = 0;\n\t \n\tfor (i = 0; i < adev->gfx.mec.num_mec; ++i) {\n\t\tfor (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {\n\t\t\t\tif (!amdgpu_gfx_is_mec_queue_enabled(adev, 0, i,\n\t\t\t\t\t\t\t\t     k, j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tr = gfx_v11_0_compute_ring_init(adev, ring_id,\n\t\t\t\t\t\t\t\ti, k, j);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\n\t\t\t\tring_id++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!adev->enable_mes_kiq) {\n\t\tr = amdgpu_gfx_kiq_init(adev, GFX11_MEC_HPD_SIZE, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to init KIQ BOs!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tkiq = &adev->gfx.kiq[0];\n\t\tr = amdgpu_gfx_kiq_init_ring(adev, &kiq->ring, &kiq->irq, 0);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_gfx_mqd_sw_init(adev, sizeof(struct v11_compute_mqd), 0);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) {\n\t\tr = gfx_v11_0_rlc_autoload_buffer_init(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = gfx_v11_0_gpu_early_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (amdgpu_gfx_ras_sw_init(adev)) {\n\t\tdev_err(adev->dev, \"Failed to initialize gfx ras block!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_pfp_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.pfp.pfp_fw_obj,\n\t\t\t      &adev->gfx.pfp.pfp_fw_gpu_addr,\n\t\t\t      (void **)&adev->gfx.pfp.pfp_fw_ptr);\n\n\tamdgpu_bo_free_kernel(&adev->gfx.pfp.pfp_fw_data_obj,\n\t\t\t      &adev->gfx.pfp.pfp_fw_data_gpu_addr,\n\t\t\t      (void **)&adev->gfx.pfp.pfp_fw_data_ptr);\n}\n\nstatic void gfx_v11_0_me_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.me.me_fw_obj,\n\t\t\t      &adev->gfx.me.me_fw_gpu_addr,\n\t\t\t      (void **)&adev->gfx.me.me_fw_ptr);\n\n\tamdgpu_bo_free_kernel(&adev->gfx.me.me_fw_data_obj,\n\t\t\t       &adev->gfx.me.me_fw_data_gpu_addr,\n\t\t\t       (void **)&adev->gfx.me.me_fw_data_ptr);\n}\n\nstatic void gfx_v11_0_rlc_autoload_buffer_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.rlc_autoload_bo,\n\t\t\t&adev->gfx.rlc.rlc_autoload_gpu_addr,\n\t\t\t(void **)&adev->gfx.rlc.rlc_autoload_ptr);\n}\n\nstatic int gfx_v11_0_sw_fini(void *handle)\n{\n\tint i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.gfx_ring[i]);\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.compute_ring[i]);\n\n\tamdgpu_gfx_mqd_sw_fini(adev, 0);\n\n\tif (!adev->enable_mes_kiq) {\n\t\tamdgpu_gfx_kiq_free_ring(&adev->gfx.kiq[0].ring);\n\t\tamdgpu_gfx_kiq_fini(adev, 0);\n\t}\n\n\tgfx_v11_0_pfp_fini(adev);\n\tgfx_v11_0_me_fini(adev);\n\tgfx_v11_0_rlc_fini(adev);\n\tgfx_v11_0_mec_fini(adev);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO)\n\t\tgfx_v11_0_rlc_autoload_buffer_fini(adev);\n\n\tgfx_v11_0_free_microcode(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_select_se_sh(struct amdgpu_device *adev, u32 se_num,\n\t\t\t\t   u32 sh_num, u32 instance, int xcc_id)\n{\n\tu32 data;\n\n\tif (instance == 0xffffffff)\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX,\n\t\t\t\t     INSTANCE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_INDEX,\n\t\t\t\t     instance);\n\n\tif (se_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_BROADCAST_WRITES,\n\t\t\t\t     1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_INDEX, se_num);\n\n\tif (sh_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SA_BROADCAST_WRITES,\n\t\t\t\t     1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SA_INDEX, sh_num);\n\n\tWREG32_SOC15(GC, 0, regGRBM_GFX_INDEX, data);\n}\n\nstatic u32 gfx_v11_0_get_sa_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 gc_disabled_sa_mask, gc_user_disabled_sa_mask, sa_mask;\n\n\tgc_disabled_sa_mask = RREG32_SOC15(GC, 0, regCC_GC_SA_UNIT_DISABLE);\n\tgc_disabled_sa_mask = REG_GET_FIELD(gc_disabled_sa_mask,\n\t\t\t\t\t   CC_GC_SA_UNIT_DISABLE,\n\t\t\t\t\t   SA_DISABLE);\n\tgc_user_disabled_sa_mask = RREG32_SOC15(GC, 0, regGC_USER_SA_UNIT_DISABLE);\n\tgc_user_disabled_sa_mask = REG_GET_FIELD(gc_user_disabled_sa_mask,\n\t\t\t\t\t\t GC_USER_SA_UNIT_DISABLE,\n\t\t\t\t\t\t SA_DISABLE);\n\tsa_mask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_sh_per_se *\n\t\t\t\t\t    adev->gfx.config.max_shader_engines);\n\n\treturn sa_mask & (~(gc_disabled_sa_mask | gc_user_disabled_sa_mask));\n}\n\nstatic u32 gfx_v11_0_get_rb_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 gc_disabled_rb_mask, gc_user_disabled_rb_mask;\n\tu32 rb_mask;\n\n\tgc_disabled_rb_mask = RREG32_SOC15(GC, 0, regCC_RB_BACKEND_DISABLE);\n\tgc_disabled_rb_mask = REG_GET_FIELD(gc_disabled_rb_mask,\n\t\t\t\t\t    CC_RB_BACKEND_DISABLE,\n\t\t\t\t\t    BACKEND_DISABLE);\n\tgc_user_disabled_rb_mask = RREG32_SOC15(GC, 0, regGC_USER_RB_BACKEND_DISABLE);\n\tgc_user_disabled_rb_mask = REG_GET_FIELD(gc_user_disabled_rb_mask,\n\t\t\t\t\t\t GC_USER_RB_BACKEND_DISABLE,\n\t\t\t\t\t\t BACKEND_DISABLE);\n\trb_mask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_backends_per_se *\n\t\t\t\t\t    adev->gfx.config.max_shader_engines);\n\n\treturn rb_mask & (~(gc_disabled_rb_mask | gc_user_disabled_rb_mask));\n}\n\nstatic void gfx_v11_0_setup_rb(struct amdgpu_device *adev)\n{\n\tu32 rb_bitmap_width_per_sa;\n\tu32 max_sa;\n\tu32 active_sa_bitmap;\n\tu32 global_active_rb_bitmap;\n\tu32 active_rb_bitmap = 0;\n\tu32 i;\n\n\t \n\tactive_sa_bitmap = gfx_v11_0_get_sa_active_bitmap(adev);\n\t \n\tglobal_active_rb_bitmap = gfx_v11_0_get_rb_active_bitmap(adev);\n\n\t \n\tmax_sa = adev->gfx.config.max_shader_engines *\n\t\t adev->gfx.config.max_sh_per_se;\n\trb_bitmap_width_per_sa = adev->gfx.config.max_backends_per_se /\n\t\t\t\t adev->gfx.config.max_sh_per_se;\n\tfor (i = 0; i < max_sa; i++) {\n\t\tif (active_sa_bitmap & (1 << i))\n\t\t\tactive_rb_bitmap |= (0x3 << (i * rb_bitmap_width_per_sa));\n\t}\n\n\tactive_rb_bitmap |= global_active_rb_bitmap;\n\tadev->gfx.config.backend_enable_mask = active_rb_bitmap;\n\tadev->gfx.config.num_rbs = hweight32(active_rb_bitmap);\n}\n\n#define DEFAULT_SH_MEM_BASES\t(0x6000)\n#define LDS_APP_BASE           0x1\n#define SCRATCH_APP_BASE       0x2\n\nstatic void gfx_v11_0_init_compute_vmid(struct amdgpu_device *adev)\n{\n\tint i;\n\tuint32_t sh_mem_bases;\n\tuint32_t data;\n\n\t \n\tsh_mem_bases = (LDS_APP_BASE << SH_MEM_BASES__SHARED_BASE__SHIFT) |\n\t\t\tSCRATCH_APP_BASE;\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tsoc21_grbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tWREG32_SOC15(GC, 0, regSH_MEM_CONFIG, DEFAULT_SH_MEM_CONFIG);\n\t\tWREG32_SOC15(GC, 0, regSH_MEM_BASES, sh_mem_bases);\n\n\t\t \n\t\tdata = RREG32_SOC15(GC, 0, regSPI_GDBG_PER_VMID_CNTL);\n\t\tdata = REG_SET_FIELD(data, SPI_GDBG_PER_VMID_CNTL, TRAP_EN, 1);\n\t\tWREG32_SOC15(GC, 0, regSPI_GDBG_PER_VMID_CNTL, data);\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_VMID0_BASE, 2 * i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_VMID0_SIZE, 2 * i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_GWS_VMID0, i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_OA_VMID0, i, 0);\n\t}\n}\n\nstatic void gfx_v11_0_init_gds_vmid(struct amdgpu_device *adev)\n{\n\tint vmid;\n\n\t \n\tfor (vmid = 1; vmid < 16; vmid++) {\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_VMID0_BASE, 2 * vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_VMID0_SIZE, 2 * vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_GWS_VMID0, vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, regGDS_OA_VMID0, vmid, 0);\n\t}\n}\n\nstatic void gfx_v11_0_tcp_harvest(struct amdgpu_device *adev)\n{\n\t \n}\n\nstatic void gfx_v11_0_get_tcc_info(struct amdgpu_device *adev)\n{\n\t \n\tuint32_t tcc_disable = RREG32_SOC15(GC, 0, regCGTS_TCC_DISABLE) |\n\t\t\t       RREG32_SOC15(GC, 0, regCGTS_USER_TCC_DISABLE);\n\n\tadev->gfx.config.tcc_disabled_mask =\n\t\tREG_GET_FIELD(tcc_disable, CGTS_TCC_DISABLE, TCC_DISABLE) |\n\t\t(REG_GET_FIELD(tcc_disable, CGTS_TCC_DISABLE, HI_TCC_DISABLE) << 16);\n}\n\nstatic void gfx_v11_0_constants_init(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\tWREG32_FIELD15_PREREG(GC, 0, GRBM_CNTL, READ_TIMEOUT, 0xff);\n\n\tgfx_v11_0_setup_rb(adev);\n\tgfx_v11_0_get_cu_info(adev, &adev->gfx.cu_info);\n\tgfx_v11_0_get_tcc_info(adev);\n\tadev->gfx.config.pa_sc_tile_steering_override = 0;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regTA_CNTL2);\n\tadev->gfx.config.ta_cntl2_truncate_coord_mode =\n\t\tREG_GET_FIELD(tmp, TA_CNTL2, TRUNCATE_COORD_MODE);\n\n\t \n\t \n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->vm_manager.id_mgr[AMDGPU_GFXHUB(0)].num_ids; i++) {\n\t\tsoc21_grbm_select(adev, 0, 0, 0, i);\n\t\t \n\t\tWREG32_SOC15(GC, 0, regSH_MEM_CONFIG, DEFAULT_SH_MEM_CONFIG);\n\t\tif (i != 0) {\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_BASES, PRIVATE_BASE,\n\t\t\t\t(adev->gmc.private_aperture_start >> 48));\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_BASES, SHARED_BASE,\n\t\t\t\t(adev->gmc.shared_aperture_start >> 48));\n\t\t\tWREG32_SOC15(GC, 0, regSH_MEM_BASES, tmp);\n\t\t}\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\tmutex_unlock(&adev->srbm_mutex);\n\n\tgfx_v11_0_init_compute_vmid(adev);\n\tgfx_v11_0_init_gds_vmid(adev);\n}\n\nstatic void gfx_v11_0_enable_gui_idle_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 tmp;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn;\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_INT_CNTL_RING0);\n\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_BUSY_INT_ENABLE,\n\t\t\t    enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_EMPTY_INT_ENABLE,\n\t\t\t    enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CMP_BUSY_INT_ENABLE,\n\t\t\t    enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, GFX_IDLE_INT_ENABLE,\n\t\t\t    enable ? 1 : 0);\n\n\tWREG32_SOC15(GC, 0, regCP_INT_CNTL_RING0, tmp);\n}\n\nstatic int gfx_v11_0_init_csb(struct amdgpu_device *adev)\n{\n\tadev->gfx.rlc.funcs->get_csb_buffer(adev, adev->gfx.rlc.cs_ptr);\n\n\tWREG32_SOC15(GC, 0, regRLC_CSIB_ADDR_HI,\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr >> 32);\n\tWREG32_SOC15(GC, 0, regRLC_CSIB_ADDR_LO,\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr & 0xfffffffc);\n\tWREG32_SOC15(GC, 0, regRLC_CSIB_LENGTH, adev->gfx.rlc.clear_state_size);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_rlc_stop(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32_SOC15(GC, 0, regRLC_CNTL);\n\n\ttmp = REG_SET_FIELD(tmp, RLC_CNTL, RLC_ENABLE_F32, 0);\n\tWREG32_SOC15(GC, 0, regRLC_CNTL, tmp);\n}\n\nstatic void gfx_v11_0_rlc_reset(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD15_PREREG(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 1);\n\tudelay(50);\n\tWREG32_FIELD15_PREREG(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 0);\n\tudelay(50);\n}\n\nstatic void gfx_v11_0_rlc_smu_handshake_cntl(struct amdgpu_device *adev,\n\t\t\t\t\t     bool enable)\n{\n\tuint32_t rlc_pg_cntl;\n\n\trlc_pg_cntl = RREG32_SOC15(GC, 0, regRLC_PG_CNTL);\n\n\tif (!enable) {\n\t\t \n\t\trlc_pg_cntl |= RLC_PG_CNTL__SMU_HANDSHAKE_DISABLE_MASK;\n\t} else\n\t\trlc_pg_cntl &= ~RLC_PG_CNTL__SMU_HANDSHAKE_DISABLE_MASK;\n\tWREG32_SOC15(GC, 0, regRLC_PG_CNTL, rlc_pg_cntl);\n}\n\nstatic void gfx_v11_0_rlc_start(struct amdgpu_device *adev)\n{\n\t \n\tif (!(amdgpu_pp_feature_mask & PP_GFXOFF_MASK))\n\t\tgfx_v11_0_rlc_smu_handshake_cntl(adev, false);\n\n\tWREG32_FIELD15_PREREG(GC, 0, RLC_CNTL, RLC_ENABLE_F32, 1);\n\tudelay(50);\n}\n\nstatic void gfx_v11_0_rlc_enable_srm(struct amdgpu_device *adev)\n{\n\tuint32_t tmp;\n\n\t \n\ttmp = RREG32(SOC15_REG_OFFSET(GC, 0, regRLC_SRM_CNTL));\n\ttmp |= RLC_SRM_CNTL__AUTO_INCR_ADDR_MASK;\n\ttmp |= RLC_SRM_CNTL__SRM_ENABLE_MASK;\n\tWREG32(SOC15_REG_OFFSET(GC, 0, regRLC_SRM_CNTL), tmp);\n}\n\nstatic void gfx_v11_0_load_rlcg_microcode(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_0 *hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\thdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\t   le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, regRLC_GPM_UCODE_ADDR,\n\t\t     RLCG_UCODE_LOADING_START_ADDRESS);\n\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32_SOC15(GC, 0, regRLC_GPM_UCODE_DATA,\n\t\t\t     le32_to_cpup(fw_data++));\n\n\tWREG32_SOC15(GC, 0, regRLC_GPM_UCODE_ADDR, adev->gfx.rlc_fw_version);\n}\n\nstatic void gfx_v11_0_load_rlc_iram_dram_microcode(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_2 *hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\tu32 tmp;\n\n\thdr = (const struct rlc_firmware_header_v2_2 *)adev->gfx.rlc_fw->data;\n\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\tle32_to_cpu(hdr->rlc_iram_ucode_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->rlc_iram_ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, regRLC_LX6_IRAM_ADDR, 0);\n\n\tfor (i = 0; i < fw_size; i++) {\n\t\tif ((amdgpu_emu_mode == 1) && (i % 100 == 99))\n\t\t\tmsleep(1);\n\t\tWREG32_SOC15(GC, 0, regRLC_LX6_IRAM_DATA,\n\t\t\t\tle32_to_cpup(fw_data++));\n\t}\n\n\tWREG32_SOC15(GC, 0, regRLC_LX6_IRAM_ADDR, adev->gfx.rlc_fw_version);\n\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\tle32_to_cpu(hdr->rlc_dram_ucode_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->rlc_dram_ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, regRLC_LX6_DRAM_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++) {\n\t\tif ((amdgpu_emu_mode == 1) && (i % 100 == 99))\n\t\t\tmsleep(1);\n\t\tWREG32_SOC15(GC, 0, regRLC_LX6_DRAM_DATA,\n\t\t\t\tle32_to_cpup(fw_data++));\n\t}\n\n\tWREG32_SOC15(GC, 0, regRLC_LX6_IRAM_ADDR, adev->gfx.rlc_fw_version);\n\n\ttmp = RREG32_SOC15(GC, 0, regRLC_LX6_CNTL);\n\ttmp = REG_SET_FIELD(tmp, RLC_LX6_CNTL, PDEBUG_ENABLE, 1);\n\ttmp = REG_SET_FIELD(tmp, RLC_LX6_CNTL, BRESET, 0);\n\tWREG32_SOC15(GC, 0, regRLC_LX6_CNTL, tmp);\n}\n\nstatic void gfx_v11_0_load_rlcp_rlcv_microcode(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_3 *hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\tu32 tmp;\n\n\thdr = (const struct rlc_firmware_header_v2_3 *)adev->gfx.rlc_fw->data;\n\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\tle32_to_cpu(hdr->rlcp_ucode_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->rlcp_ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, regRLC_PACE_UCODE_ADDR, 0);\n\n\tfor (i = 0; i < fw_size; i++) {\n\t\tif ((amdgpu_emu_mode == 1) && (i % 100 == 99))\n\t\t\tmsleep(1);\n\t\tWREG32_SOC15(GC, 0, regRLC_PACE_UCODE_DATA,\n\t\t\t\tle32_to_cpup(fw_data++));\n\t}\n\n\tWREG32_SOC15(GC, 0, regRLC_PACE_UCODE_ADDR, adev->gfx.rlc_fw_version);\n\n\ttmp = RREG32_SOC15(GC, 0, regRLC_GPM_THREAD_ENABLE);\n\ttmp = REG_SET_FIELD(tmp, RLC_GPM_THREAD_ENABLE, THREAD1_ENABLE, 1);\n\tWREG32_SOC15(GC, 0, regRLC_GPM_THREAD_ENABLE, tmp);\n\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\tle32_to_cpu(hdr->rlcv_ucode_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->rlcv_ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, regRLC_GPU_IOV_UCODE_ADDR, 0);\n\n\tfor (i = 0; i < fw_size; i++) {\n\t\tif ((amdgpu_emu_mode == 1) && (i % 100 == 99))\n\t\t\tmsleep(1);\n\t\tWREG32_SOC15(GC, 0, regRLC_GPU_IOV_UCODE_DATA,\n\t\t\t\tle32_to_cpup(fw_data++));\n\t}\n\n\tWREG32_SOC15(GC, 0, regRLC_GPU_IOV_UCODE_ADDR, adev->gfx.rlc_fw_version);\n\n\ttmp = RREG32_SOC15(GC, 0, regRLC_GPU_IOV_F32_CNTL);\n\ttmp = REG_SET_FIELD(tmp, RLC_GPU_IOV_F32_CNTL, ENABLE, 1);\n\tWREG32_SOC15(GC, 0, regRLC_GPU_IOV_F32_CNTL, tmp);\n}\n\nstatic int gfx_v11_0_rlc_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_0 *hdr;\n\tuint16_t version_major;\n\tuint16_t version_minor;\n\n\tif (!adev->gfx.rlc_fw)\n\t\treturn -EINVAL;\n\n\thdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\tamdgpu_ucode_print_rlc_hdr(&hdr->header);\n\n\tversion_major = le16_to_cpu(hdr->header.header_version_major);\n\tversion_minor = le16_to_cpu(hdr->header.header_version_minor);\n\n\tif (version_major == 2) {\n\t\tgfx_v11_0_load_rlcg_microcode(adev);\n\t\tif (amdgpu_dpm == 1) {\n\t\t\tif (version_minor >= 2)\n\t\t\t\tgfx_v11_0_load_rlc_iram_dram_microcode(adev);\n\t\t\tif (version_minor == 3)\n\t\t\t\tgfx_v11_0_load_rlcp_rlcv_microcode(adev);\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int gfx_v11_0_rlc_resume(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tgfx_v11_0_init_csb(adev);\n\n\t\tif (!amdgpu_sriov_vf(adev))  \n\t\t\tgfx_v11_0_rlc_enable_srm(adev);\n\t} else {\n\t\tif (amdgpu_sriov_vf(adev)) {\n\t\t\tgfx_v11_0_init_csb(adev);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadev->gfx.rlc.funcs->stop(adev);\n\n\t\t \n\t\tWREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL, 0);\n\n\t\t \n\t\tWREG32_SOC15(GC, 0, regRLC_PG_CNTL, 0);\n\n\t\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {\n\t\t\t \n\t\t\tr = gfx_v11_0_rlc_load_microcode(adev);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\n\t\tgfx_v11_0_init_csb(adev);\n\n\t\tadev->gfx.rlc.funcs->start(adev);\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_me_cache(struct amdgpu_device *adev, uint64_t addr)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tint i;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_OP_CNTL, INVALIDATE_CACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_ME_IC_OP_CNTL,\n\t\t\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (amdgpu_emu_mode == 1)\n\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, EXE_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, ADDRESS_CLAMP, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL, tmp);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_LO,\n\t\t\tlower_32_bits(addr) & 0xFFFFF000);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_HI,\n\t\t\tupper_32_bits(addr));\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_pfp_cache(struct amdgpu_device *adev, uint64_t addr)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tint i;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_OP_CNTL, INVALIDATE_CACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,\n\t\t\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (amdgpu_emu_mode == 1)\n\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, EXE_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, ADDRESS_CLAMP, 1);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL, tmp);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_LO,\n\t\t\tlower_32_bits(addr) & 0xFFFFF000);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_HI,\n\t\t\tupper_32_bits(addr));\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_mec_cache(struct amdgpu_device *adev, uint64_t addr)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tint i;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_OP_CNTL, INVALIDATE_CACHE, 1);\n\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_CPC_IC_OP_CNTL,\n\t\t\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (amdgpu_emu_mode == 1)\n\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, EXE_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, ADDRESS_CLAMP, 1);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL, tmp);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_LO,\n\t\t\tlower_32_bits(addr) & 0xFFFFF000);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_HI,\n\t\t\tupper_32_bits(addr));\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_pfp_cache_rs64(struct amdgpu_device *adev, uint64_t addr, uint64_t addr2)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tunsigned i, pipe_id;\n\tconst struct gfx_firmware_header_v2_0 *pfp_hdr;\n\n\tpfp_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.pfp_fw->data;\n\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_LO,\n\t\tlower_32_bits(addr));\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_HI,\n\t\tupper_32_bits(addr));\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, EXE_DISABLE, 0);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,\n\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_OP_CNTL, PRIME_ICACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL, tmp);\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,\n\t\t\tICACHE_PRIMED))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to prime instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (pipe_id = 0; pipe_id < adev->gfx.me.num_pipe_per_me; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START,\n\t\t\t(pfp_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(pfp_hdr->ucode_start_addr_lo >> 2));\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START_HI,\n\t\t\tpfp_hdr->ucode_start_addr_hi >> 2);\n\n\t\t \n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE0_RESET, 1);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE1_RESET, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\t \n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE0_RESET, 0);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE1_RESET, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_LO,\n\t\t\tlower_32_bits(addr2));\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_HI,\n\t\t\tupper_32_bits(addr2));\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL, tmp);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL, tmp);\n\n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL,\n\t\t\tINVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate RS64 data cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_me_cache_rs64(struct amdgpu_device *adev, uint64_t addr, uint64_t addr2)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tunsigned i, pipe_id;\n\tconst struct gfx_firmware_header_v2_0 *me_hdr;\n\n\tme_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.me_fw->data;\n\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_LO,\n\t\tlower_32_bits(addr));\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_HI,\n\t\tupper_32_bits(addr));\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, EXE_DISABLE, 0);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_ME_IC_OP_CNTL,\n\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_OP_CNTL, PRIME_ICACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_ME_IC_OP_CNTL,\n\t\t\tICACHE_PRIMED))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to prime instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (pipe_id = 0; pipe_id < adev->gfx.me.num_pipe_per_me; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START,\n\t\t\t(me_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(me_hdr->ucode_start_addr_lo >> 2) );\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START_HI,\n\t\t\tme_hdr->ucode_start_addr_hi>>2);\n\n\t\t \n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE0_RESET, 1);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE1_RESET, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\t \n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE0_RESET, 0);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE1_RESET, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE1_LO,\n\t\t\tlower_32_bits(addr2));\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE1_HI,\n\t\t\tupper_32_bits(addr2));\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL, tmp);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL, tmp);\n\n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL,\n\t\t\tINVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate RS64 data cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_config_mec_cache_rs64(struct amdgpu_device *adev, uint64_t addr, uint64_t addr2)\n{\n\tuint32_t usec_timeout = 50000;   \n\tuint32_t tmp;\n\tunsigned i;\n\tconst struct gfx_firmware_header_v2_0 *mec_hdr;\n\n\tmec_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.mec_fw->data;\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, EXE_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL, tmp);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_MEC_DC_BASE_CNTL, tmp);\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->gfx.mec.num_pipe_per_mec; i++) {\n\t\tsoc21_grbm_select(adev, 1, i, 0, 0);\n\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_MDBASE_LO, addr2);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_MDBASE_HI,\n\t\t     upper_32_bits(addr2));\n\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START,\n\t\t\t\t\tmec_hdr->ucode_start_addr_lo >> 2 |\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi << 30);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START_HI,\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi >> 2);\n\n\t\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_LO, addr);\n\t\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_HI,\n\t\t     upper_32_bits(addr));\n\t}\n\tmutex_unlock(&adev->srbm_mutex);\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_MEC_DC_OP_CNTL,\n\t\t\t\t       INVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_OP_CNTL, INVALIDATE_CACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_CPC_IC_OP_CNTL,\n\t\t\t\t       INVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_config_gfx_rs64(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v2_0 *pfp_hdr;\n\tconst struct gfx_firmware_header_v2_0 *me_hdr;\n\tconst struct gfx_firmware_header_v2_0 *mec_hdr;\n\tuint32_t pipe_id, tmp;\n\n\tmec_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.mec_fw->data;\n\tme_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.me_fw->data;\n\tpfp_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.pfp_fw->data;\n\n\t \n\tfor (pipe_id = 0; pipe_id < 2; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START,\n\t\t\t(pfp_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(pfp_hdr->ucode_start_addr_lo >> 2));\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START_HI,\n\t\t\tpfp_hdr->ucode_start_addr_hi >> 2);\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_PIPE0_RESET, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_PIPE1_RESET, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t \n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_PIPE0_RESET, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_PIPE1_RESET, 0);\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t \n\tfor (pipe_id = 0; pipe_id < 2; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START,\n\t\t\t(me_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(me_hdr->ucode_start_addr_lo >> 2) );\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START_HI,\n\t\t\tme_hdr->ucode_start_addr_hi>>2);\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_PIPE0_RESET, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_PIPE1_RESET, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t \n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_PIPE0_RESET, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_PIPE1_RESET, 0);\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t \n\tfor (pipe_id = 0; pipe_id < 4; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 1, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START,\n\t\t\t\t\tmec_hdr->ucode_start_addr_lo >> 2 |\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi << 30);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START_HI,\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi >> 2);\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE0_RESET, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE1_RESET, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE2_RESET, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE3_RESET, 1);\n\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL, tmp);\n\n\t \n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE0_RESET, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE1_RESET, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE2_RESET, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_RS64_CNTL, MEC_PIPE3_RESET, 0);\n\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL, tmp);\n}\n\nstatic int gfx_v11_0_wait_for_rlc_autoload_complete(struct amdgpu_device *adev)\n{\n\tuint32_t cp_status;\n\tuint32_t bootload_status;\n\tint i, r;\n\tuint64_t addr, addr2;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tcp_status = RREG32_SOC15(GC, 0, regCP_STAT);\n\n\t\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(11, 0, 1) ||\n\t\t\t\tadev->ip_versions[GC_HWIP][0] == IP_VERSION(11, 0, 4))\n\t\t\tbootload_status = RREG32_SOC15(GC, 0,\n\t\t\t\t\tregRLC_RLCS_BOOTLOAD_STATUS_gc_11_0_1);\n\t\telse\n\t\t\tbootload_status = RREG32_SOC15(GC, 0, regRLC_RLCS_BOOTLOAD_STATUS);\n\n\t\tif ((cp_status == 0) &&\n\t\t    (REG_GET_FIELD(bootload_status,\n\t\t\tRLC_RLCS_BOOTLOAD_STATUS, BOOTLOAD_COMPLETE) == 1)) {\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout) {\n\t\tdev_err(adev->dev, \"rlc autoload: gc ucode autoload timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) {\n\t\tif (adev->gfx.rs64_enable) {\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_ME].offset;\n\t\t\taddr2 = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_ME_P0_STACK].offset;\n\t\t\tr = gfx_v11_0_config_me_cache_rs64(adev, addr, addr2);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_PFP].offset;\n\t\t\taddr2 = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_PFP_P0_STACK].offset;\n\t\t\tr = gfx_v11_0_config_pfp_cache_rs64(adev, addr, addr2);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_MEC].offset;\n\t\t\taddr2 = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_RS64_MEC_P0_STACK].offset;\n\t\t\tr = gfx_v11_0_config_mec_cache_rs64(adev, addr, addr2);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_CP_ME].offset;\n\t\t\tr = gfx_v11_0_config_me_cache(adev, addr);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_CP_PFP].offset;\n\t\t\tr = gfx_v11_0_config_pfp_cache(adev, addr);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\taddr = adev->gfx.rlc.rlc_autoload_gpu_addr +\n\t\t\t\trlc_autoload_info[SOC21_FIRMWARE_ID_CP_MEC].offset;\n\t\t\tr = gfx_v11_0_config_mec_cache(adev, addr);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_enable(struct amdgpu_device *adev, bool enable)\n{\n\tint i;\n\tu32 tmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_HALT, enable ? 0 : 1);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_HALT, enable ? 0 : 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (RREG32_SOC15(GC, 0, regCP_STAT) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tDRM_ERROR(\"failed to %s cp gfx\\n\", enable ? \"unhalt\" : \"halt\");\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_load_pfp_microcode(struct amdgpu_device *adev)\n{\n\tint r;\n\tconst struct gfx_firmware_header_v1_0 *pfp_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tpfp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\tadev->gfx.pfp_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&pfp_hdr->header);\n\n\tfw_data = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\tle32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes);\n\n\tr = amdgpu_bo_create_reserved(adev, pfp_hdr->header.ucode_size_bytes,\n\t\t\t\t      PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_obj,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.pfp.pfp_fw_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create pfp fw bo\\n\", r);\n\t\tgfx_v11_0_pfp_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.pfp.pfp_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.pfp.pfp_fw_obj);\n\n\tgfx_v11_0_config_pfp_cache(adev, adev->gfx.pfp.pfp_fw_gpu_addr);\n\n\tWREG32_SOC15(GC, 0, regCP_HYP_PFP_UCODE_ADDR, 0);\n\n\tfor (i = 0; i < pfp_hdr->jt_size; i++)\n\t\tWREG32_SOC15(GC, 0, regCP_HYP_PFP_UCODE_DATA,\n\t\t\t     le32_to_cpup(fw_data + pfp_hdr->jt_offset + i));\n\n\tWREG32_SOC15(GC, 0, regCP_HYP_PFP_UCODE_ADDR, adev->gfx.pfp_fw_version);\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_load_pfp_microcode_rs64(struct amdgpu_device *adev)\n{\n\tint r;\n\tconst struct gfx_firmware_header_v2_0 *pfp_hdr;\n\tconst __le32 *fw_ucode, *fw_data;\n\tunsigned i, pipe_id, fw_ucode_size, fw_data_size;\n\tuint32_t tmp;\n\tuint32_t usec_timeout = 50000;   \n\n\tpfp_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.pfp_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&pfp_hdr->header);\n\n\t \n\tfw_ucode = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\tle32_to_cpu(pfp_hdr->ucode_offset_bytes));\n\tfw_ucode_size = le32_to_cpu(pfp_hdr->ucode_size_bytes);\n\t \n\tfw_data = (const __le32 *)(adev->gfx.pfp_fw->data +\n\t\tle32_to_cpu(pfp_hdr->data_offset_bytes));\n\tfw_data_size = le32_to_cpu(pfp_hdr->data_size_bytes);\n\n\t \n\tr = amdgpu_bo_create_reserved(adev, fw_ucode_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_obj,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.pfp.pfp_fw_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create pfp ucode fw bo\\n\", r);\n\t\tgfx_v11_0_pfp_fini(adev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_bo_create_reserved(adev, fw_data_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_data_obj,\n\t\t\t\t      &adev->gfx.pfp.pfp_fw_data_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.pfp.pfp_fw_data_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create pfp data fw bo\\n\", r);\n\t\tgfx_v11_0_pfp_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size);\n\tmemcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.pfp.pfp_fw_obj);\n\tamdgpu_bo_kunmap(adev->gfx.pfp.pfp_fw_data_obj);\n\tamdgpu_bo_unreserve(adev->gfx.pfp.pfp_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.pfp.pfp_fw_data_obj);\n\n\tif (amdgpu_emu_mode == 1)\n\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_LO,\n\t\tlower_32_bits(adev->gfx.pfp.pfp_fw_gpu_addr));\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_HI,\n\t\tupper_32_bits(adev->gfx.pfp.pfp_fw_gpu_addr));\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_BASE_CNTL, EXE_DISABLE, 0);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_BASE_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,\n\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_PFP_IC_OP_CNTL, PRIME_ICACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL, tmp);\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_PFP_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_PFP_IC_OP_CNTL,\n\t\t\tICACHE_PRIMED))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to prime instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (pipe_id = 0; pipe_id < adev->gfx.me.num_pipe_per_me; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START,\n\t\t\t(pfp_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(pfp_hdr->ucode_start_addr_lo >> 2) );\n\t\tWREG32_SOC15(GC, 0, regCP_PFP_PRGRM_CNTR_START_HI,\n\t\t\tpfp_hdr->ucode_start_addr_hi>>2);\n\n\t\t \n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE0_RESET, 1);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE1_RESET, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\t \n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE0_RESET, 0);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tPFP_PIPE1_RESET, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_LO,\n\t\t\tlower_32_bits(adev->gfx.pfp.pfp_fw_data_gpu_addr));\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE0_HI,\n\t\t\tupper_32_bits(adev->gfx.pfp.pfp_fw_data_gpu_addr));\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL, tmp);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL, tmp);\n\n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL,\n\t\t\tINVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate RS64 data cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_load_me_microcode(struct amdgpu_device *adev)\n{\n\tint r;\n\tconst struct gfx_firmware_header_v1_0 *me_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tme_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\tadev->gfx.me_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&me_hdr->header);\n\n\tfw_data = (const __le32 *)(adev->gfx.me_fw->data +\n\t\tle32_to_cpu(me_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes);\n\n\tr = amdgpu_bo_create_reserved(adev, me_hdr->header.ucode_size_bytes,\n\t\t\t\t      PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.me.me_fw_obj,\n\t\t\t\t      &adev->gfx.me.me_fw_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.me.me_fw_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create me fw bo\\n\", r);\n\t\tgfx_v11_0_me_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.me.me_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.me.me_fw_obj);\n\n\tgfx_v11_0_config_me_cache(adev, adev->gfx.me.me_fw_gpu_addr);\n\n\tWREG32_SOC15(GC, 0, regCP_HYP_ME_UCODE_ADDR, 0);\n\n\tfor (i = 0; i < me_hdr->jt_size; i++)\n\t\tWREG32_SOC15(GC, 0, regCP_HYP_ME_UCODE_DATA,\n\t\t\t     le32_to_cpup(fw_data + me_hdr->jt_offset + i));\n\n\tWREG32_SOC15(GC, 0, regCP_HYP_ME_UCODE_ADDR, adev->gfx.me_fw_version);\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_load_me_microcode_rs64(struct amdgpu_device *adev)\n{\n\tint r;\n\tconst struct gfx_firmware_header_v2_0 *me_hdr;\n\tconst __le32 *fw_ucode, *fw_data;\n\tunsigned i, pipe_id, fw_ucode_size, fw_data_size;\n\tuint32_t tmp;\n\tuint32_t usec_timeout = 50000;   \n\n\tme_hdr = (const struct gfx_firmware_header_v2_0 *)\n\t\tadev->gfx.me_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&me_hdr->header);\n\n\t \n\tfw_ucode = (const __le32 *)(adev->gfx.me_fw->data +\n\t\tle32_to_cpu(me_hdr->ucode_offset_bytes));\n\tfw_ucode_size = le32_to_cpu(me_hdr->ucode_size_bytes);\n\t \n\tfw_data = (const __le32 *)(adev->gfx.me_fw->data +\n\t\tle32_to_cpu(me_hdr->data_offset_bytes));\n\tfw_data_size = le32_to_cpu(me_hdr->data_size_bytes);\n\n\t \n\tr = amdgpu_bo_create_reserved(adev, fw_ucode_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.me.me_fw_obj,\n\t\t\t\t      &adev->gfx.me.me_fw_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.me.me_fw_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create me ucode bo\\n\", r);\n\t\tgfx_v11_0_me_fini(adev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_bo_create_reserved(adev, fw_data_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.me.me_fw_data_obj,\n\t\t\t\t      &adev->gfx.me.me_fw_data_gpu_addr,\n\t\t\t\t      (void **)&adev->gfx.me.me_fw_data_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create me data bo\\n\", r);\n\t\tgfx_v11_0_pfp_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size);\n\tmemcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.me.me_fw_obj);\n\tamdgpu_bo_kunmap(adev->gfx.me.me_fw_data_obj);\n\tamdgpu_bo_unreserve(adev->gfx.me.me_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.me.me_fw_data_obj);\n\n\tif (amdgpu_emu_mode == 1)\n\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_LO,\n\t\tlower_32_bits(adev->gfx.me.me_fw_gpu_addr));\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_HI,\n\t\tupper_32_bits(adev->gfx.me.me_fw_gpu_addr));\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_BASE_CNTL, EXE_DISABLE, 0);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_BASE_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_ME_IC_OP_CNTL,\n\t\t\tINVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_IC_OP_CNTL, PRIME_ICACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_ME_IC_OP_CNTL,\n\t\t\tICACHE_PRIMED))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to prime instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (pipe_id = 0; pipe_id < adev->gfx.me.num_pipe_per_me; pipe_id++) {\n\t\tsoc21_grbm_select(adev, 0, pipe_id, 0, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START,\n\t\t\t(me_hdr->ucode_start_addr_hi << 30) |\n\t\t\t(me_hdr->ucode_start_addr_lo >> 2) );\n\t\tWREG32_SOC15(GC, 0, regCP_ME_PRGRM_CNTR_START_HI,\n\t\t\tme_hdr->ucode_start_addr_hi>>2);\n\n\t\t \n\t\ttmp = RREG32_SOC15(GC, 0, regCP_ME_CNTL);\n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE0_RESET, 1);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE1_RESET, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\t \n\t\tif (pipe_id == 0)\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE0_RESET, 0);\n\t\telse\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL,\n\t\t\t\t\tME_PIPE1_RESET, 0);\n\t\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, tmp);\n\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE1_LO,\n\t\t\tlower_32_bits(adev->gfx.me.me_fw_data_gpu_addr));\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE1_HI,\n\t\t\tupper_32_bits(adev->gfx.me.me_fw_data_gpu_addr));\n\t}\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_BASE_CNTL, tmp);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL, tmp);\n\n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_RS64_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_GFX_RS64_DC_OP_CNTL,\n\t\t\tINVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate RS64 data cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_load_microcode(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tif (!adev->gfx.me_fw || !adev->gfx.pfp_fw)\n\t\treturn -EINVAL;\n\n\tgfx_v11_0_cp_gfx_enable(adev, false);\n\n\tif (adev->gfx.rs64_enable)\n\t\tr = gfx_v11_0_cp_gfx_load_pfp_microcode_rs64(adev);\n\telse\n\t\tr = gfx_v11_0_cp_gfx_load_pfp_microcode(adev);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to load pfp fw\\n\", r);\n\t\treturn r;\n\t}\n\n\tif (adev->gfx.rs64_enable)\n\t\tr = gfx_v11_0_cp_gfx_load_me_microcode_rs64(adev);\n\telse\n\t\tr = gfx_v11_0_cp_gfx_load_me_microcode(adev);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to load me fw\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_gfx_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint r, i;\n\tint ctx_reg_offset;\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_MAX_CONTEXT,\n\t\t     adev->gfx.config.max_hw_contexts - 1);\n\tWREG32_SOC15(GC, 0, regCP_DEVICE_ID, 1);\n\n\tif (!amdgpu_async_gfx_ring)\n\t\tgfx_v11_0_cp_gfx_enable(adev, true);\n\n\tring = &adev->gfx.gfx_ring[0];\n\tr = amdgpu_ring_alloc(ring, gfx_v11_0_get_csb_size(adev));\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, 0x80000000);\n\tamdgpu_ring_write(ring, 0x80000000);\n\n\tfor (sect = gfx11_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t\t\t  PACKET3(PACKET3_SET_CONTEXT_REG,\n\t\t\t\t\t\t\t  ext->reg_count));\n\t\t\t\tamdgpu_ring_write(ring, ext->reg_index -\n\t\t\t\t\t\t  PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tamdgpu_ring_write(ring, ext->extent[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tctx_reg_offset =\n\t\tSOC15_REG_OFFSET(GC, 0, regPA_SC_TILE_STEERING_OVERRIDE) - PACKET3_SET_CONTEXT_REG_START;\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 1));\n\tamdgpu_ring_write(ring, ctx_reg_offset);\n\tamdgpu_ring_write(ring, adev->gfx.config.pa_sc_tile_steering_override);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_commit(ring);\n\n\t \n\tif (adev->gfx.num_gfx_rings > 1) {\n\t\t \n\t\tring = &adev->gfx.gfx_ring[1];\n\t\tr = amdgpu_ring_alloc(ring, 2);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring (%d).\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\n\t\tamdgpu_ring_commit(ring);\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v11_0_cp_gfx_switch_pipe(struct amdgpu_device *adev,\n\t\t\t\t\t CP_PIPE_ID pipe)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_SOC15(GC, 0, regGRBM_GFX_CNTL);\n\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, PIPEID, pipe);\n\n\tWREG32_SOC15(GC, 0, regGRBM_GFX_CNTL, tmp);\n}\n\nstatic void gfx_v11_0_cp_gfx_set_doorbell(struct amdgpu_device *adev,\n\t\t\t\t\t  struct amdgpu_ring *ring)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_RB_DOORBELL_CONTROL);\n\tif (ring->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_OFFSET, ring->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 0);\n\t}\n\tWREG32_SOC15(GC, 0, regCP_RB_DOORBELL_CONTROL, tmp);\n\n\ttmp = REG_SET_FIELD(0, CP_RB_DOORBELL_RANGE_LOWER,\n\t\t\t    DOORBELL_RANGE_LOWER, ring->doorbell_index);\n\tWREG32_SOC15(GC, 0, regCP_RB_DOORBELL_RANGE_LOWER, tmp);\n\n\tWREG32_SOC15(GC, 0, regCP_RB_DOORBELL_RANGE_UPPER,\n\t\t     CP_RB_DOORBELL_RANGE_UPPER__DOORBELL_RANGE_UPPER_MASK);\n}\n\nstatic int gfx_v11_0_cp_gfx_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tu64 rb_addr, rptr_addr, wptr_gpu_addr;\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_RB_VMID, 0);\n\n\t \n\tmutex_lock(&adev->srbm_mutex);\n\tgfx_v11_0_cp_gfx_switch_pipe(adev, PIPE_ID0);\n\n\t \n\tring = &adev->gfx.gfx_ring[0];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = REG_SET_FIELD(0, CP_RB0_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, RB_BLKSZ, rb_bufsz - 2);\n\tWREG32_SOC15(GC, 0, regCP_RB0_CNTL, tmp);\n\n\t \n\tring->wptr = 0;\n\tWREG32_SOC15(GC, 0, regCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\tWREG32_SOC15(GC, 0, regCP_RB0_WPTR_HI, upper_32_bits(ring->wptr));\n\n\t \n\trptr_addr = ring->rptr_gpu_addr;\n\tWREG32_SOC15(GC, 0, regCP_RB0_RPTR_ADDR, lower_32_bits(rptr_addr));\n\tWREG32_SOC15(GC, 0, regCP_RB0_RPTR_ADDR_HI, upper_32_bits(rptr_addr) &\n\t\t     CP_RB_RPTR_ADDR_HI__RB_RPTR_ADDR_HI_MASK);\n\n\twptr_gpu_addr = ring->wptr_gpu_addr;\n\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_ADDR_LO,\n\t\t     lower_32_bits(wptr_gpu_addr));\n\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_ADDR_HI,\n\t\t     upper_32_bits(wptr_gpu_addr));\n\n\tmdelay(1);\n\tWREG32_SOC15(GC, 0, regCP_RB0_CNTL, tmp);\n\n\trb_addr = ring->gpu_addr >> 8;\n\tWREG32_SOC15(GC, 0, regCP_RB0_BASE, rb_addr);\n\tWREG32_SOC15(GC, 0, regCP_RB0_BASE_HI, upper_32_bits(rb_addr));\n\n\tWREG32_SOC15(GC, 0, regCP_RB_ACTIVE, 1);\n\n\tgfx_v11_0_cp_gfx_set_doorbell(adev, ring);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tif (adev->gfx.num_gfx_rings > 1) {\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tgfx_v11_0_cp_gfx_switch_pipe(adev, PIPE_ID1);\n\t\t \n\t\tring = &adev->gfx.gfx_ring[1];\n\t\trb_bufsz = order_base_2(ring->ring_size / 8);\n\t\ttmp = REG_SET_FIELD(0, CP_RB1_CNTL, RB_BUFSZ, rb_bufsz);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB1_CNTL, RB_BLKSZ, rb_bufsz - 2);\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_CNTL, tmp);\n\t\t \n\t\tring->wptr = 0;\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_WPTR, lower_32_bits(ring->wptr));\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_WPTR_HI, upper_32_bits(ring->wptr));\n\t\t \n\t\trptr_addr = ring->rptr_gpu_addr;\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_RPTR_ADDR, lower_32_bits(rptr_addr));\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_RPTR_ADDR_HI, upper_32_bits(rptr_addr) &\n\t\t\t     CP_RB1_RPTR_ADDR_HI__RB_RPTR_ADDR_HI_MASK);\n\t\twptr_gpu_addr = ring->wptr_gpu_addr;\n\t\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_ADDR_LO,\n\t\t\t     lower_32_bits(wptr_gpu_addr));\n\t\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_ADDR_HI,\n\t\t\t     upper_32_bits(wptr_gpu_addr));\n\n\t\tmdelay(1);\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_CNTL, tmp);\n\n\t\trb_addr = ring->gpu_addr >> 8;\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_BASE, rb_addr);\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_BASE_HI, upper_32_bits(rb_addr));\n\t\tWREG32_SOC15(GC, 0, regCP_RB1_ACTIVE, 1);\n\n\t\tgfx_v11_0_cp_gfx_set_doorbell(adev, ring);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t}\n\t \n\tmutex_lock(&adev->srbm_mutex);\n\tgfx_v11_0_cp_gfx_switch_pipe(adev, PIPE_ID0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tgfx_v11_0_cp_gfx_start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_cp_compute_enable(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data;\n\n\tif (adev->gfx.rs64_enable) {\n\t\tdata = RREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_INVALIDATE_ICACHE,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE0_RESET,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE1_RESET,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE2_RESET,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE3_RESET,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE0_ACTIVE,\n\t\t\t\t\t\t\t enable ? 1 : 0);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE1_ACTIVE,\n\t\t\t\t                         enable ? 1 : 0);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE2_ACTIVE,\n\t\t\t\t\t\t\t enable ? 1 : 0);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_PIPE3_ACTIVE,\n\t\t\t\t\t\t\t enable ? 1 : 0);\n\t\tdata = REG_SET_FIELD(data, CP_MEC_RS64_CNTL, MEC_HALT,\n\t\t\t\t\t\t\t enable ? 0 : 1);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL, data);\n\t} else {\n\t\tdata = RREG32_SOC15(GC, 0, regCP_MEC_CNTL);\n\n\t\tif (enable) {\n\t\t\tdata = REG_SET_FIELD(data, CP_MEC_CNTL, MEC_ME1_HALT, 0);\n\t\t\tif (!adev->enable_mes_kiq)\n\t\t\t\tdata = REG_SET_FIELD(data, CP_MEC_CNTL,\n\t\t\t\t\t\t     MEC_ME2_HALT, 0);\n\t\t} else {\n\t\t\tdata = REG_SET_FIELD(data, CP_MEC_CNTL, MEC_ME1_HALT, 1);\n\t\t\tdata = REG_SET_FIELD(data, CP_MEC_CNTL, MEC_ME2_HALT, 1);\n\t\t}\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_CNTL, data);\n\t}\n\n\tudelay(50);\n}\n\nstatic int gfx_v11_0_cp_compute_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v1_0 *mec_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\tu32 *fw = NULL;\n\tint r;\n\n\tif (!adev->gfx.mec_fw)\n\t\treturn -EINVAL;\n\n\tgfx_v11_0_cp_compute_enable(adev, false);\n\n\tmec_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\tamdgpu_ucode_print_gfx_hdr(&mec_hdr->header);\n\n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.mec_fw->data +\n\t\t le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(mec_hdr->header.ucode_size_bytes);\n\n\tr = amdgpu_bo_create_reserved(adev, mec_hdr->header.ucode_size_bytes,\n\t\t\t\t\t  PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t  &adev->gfx.mec.mec_fw_obj,\n\t\t\t\t\t  &adev->gfx.mec.mec_fw_gpu_addr,\n\t\t\t\t\t  (void **)&fw);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create mec fw bo\\n\", r);\n\t\tgfx_v11_0_mec_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(fw, fw_data, fw_size);\n\t\n\tamdgpu_bo_kunmap(adev->gfx.mec.mec_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.mec.mec_fw_obj);\n\n\tgfx_v11_0_config_mec_cache(adev, adev->gfx.mec.mec_fw_gpu_addr);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_MEC_ME1_UCODE_ADDR, 0);\n\n\tfor (i = 0; i < mec_hdr->jt_size; i++)\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_ME1_UCODE_DATA,\n\t\t\t     le32_to_cpup(fw_data + mec_hdr->jt_offset + i));\n\n\tWREG32_SOC15(GC, 0, regCP_MEC_ME1_UCODE_ADDR, adev->gfx.mec_fw_version);\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_compute_load_microcode_rs64(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v2_0 *mec_hdr;\n\tconst __le32 *fw_ucode, *fw_data;\n\tu32 tmp, fw_ucode_size, fw_data_size;\n\tu32 i, usec_timeout = 50000;  \n\tu32 *fw_ucode_ptr, *fw_data_ptr;\n\tint r;\n\n\tif (!adev->gfx.mec_fw)\n\t\treturn -EINVAL;\n\n\tgfx_v11_0_cp_compute_enable(adev, false);\n\n\tmec_hdr = (const struct gfx_firmware_header_v2_0 *)adev->gfx.mec_fw->data;\n\tamdgpu_ucode_print_gfx_hdr(&mec_hdr->header);\n\n\tfw_ucode = (const __le32 *) (adev->gfx.mec_fw->data +\n\t\t\t\tle32_to_cpu(mec_hdr->ucode_offset_bytes));\n\tfw_ucode_size = le32_to_cpu(mec_hdr->ucode_size_bytes);\n\n\tfw_data = (const __le32 *) (adev->gfx.mec_fw->data +\n\t\t\t\tle32_to_cpu(mec_hdr->data_offset_bytes));\n\tfw_data_size = le32_to_cpu(mec_hdr->data_size_bytes);\n\n\tr = amdgpu_bo_create_reserved(adev, fw_ucode_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.mec.mec_fw_obj,\n\t\t\t\t      &adev->gfx.mec.mec_fw_gpu_addr,\n\t\t\t\t      (void **)&fw_ucode_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create mec fw ucode bo\\n\", r);\n\t\tgfx_v11_0_mec_fini(adev);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_bo_create_reserved(adev, fw_data_size,\n\t\t\t\t      64 * 1024,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.mec.mec_fw_data_obj,\n\t\t\t\t      &adev->gfx.mec.mec_fw_data_gpu_addr,\n\t\t\t\t      (void **)&fw_data_ptr);\n\tif (r) {\n\t\tdev_err(adev->dev, \"(%d) failed to create mec fw ucode bo\\n\", r);\n\t\tgfx_v11_0_mec_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size);\n\tmemcpy(fw_data_ptr, fw_data, fw_data_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.mec.mec_fw_obj);\n\tamdgpu_bo_kunmap(adev->gfx.mec.mec_fw_data_obj);\n\tamdgpu_bo_unreserve(adev->gfx.mec.mec_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.mec.mec_fw_data_obj);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, EXE_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_CNTL, tmp);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_BASE_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, regCP_MEC_DC_BASE_CNTL, tmp);\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->gfx.mec.num_pipe_per_mec; i++) {\n\t\tsoc21_grbm_select(adev, 1, i, 0, 0);\n\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_MDBASE_LO, adev->gfx.mec.mec_fw_data_gpu_addr);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_MDBASE_HI,\n\t\t     upper_32_bits(adev->gfx.mec.mec_fw_data_gpu_addr));\n\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START,\n\t\t\t\t\tmec_hdr->ucode_start_addr_lo >> 2 |\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi << 30);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_PRGRM_CNTR_START_HI,\n\t\t\t\t\tmec_hdr->ucode_start_addr_hi >> 2);\n\n\t\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_LO, adev->gfx.mec.mec_fw_gpu_addr);\n\t\tWREG32_SOC15(GC, 0, regCP_CPC_IC_BASE_HI,\n\t\t     upper_32_bits(adev->gfx.mec.mec_fw_gpu_addr));\n\t}\n\tmutex_unlock(&adev->srbm_mutex);\n\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_MEC_DC_OP_CNTL, INVALIDATE_DCACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_DC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_MEC_DC_OP_CNTL,\n\t\t\t\t       INVALIDATE_DCACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_OP_CNTL, INVALIDATE_CACHE, 1);\n\tWREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL, tmp);\n\n\t \n\tfor (i = 0; i < usec_timeout; i++) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_CPC_IC_OP_CNTL);\n\t\tif (1 == REG_GET_FIELD(tmp, CP_CPC_IC_OP_CNTL,\n\t\t\t\t       INVALIDATE_CACHE_COMPLETE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= usec_timeout) {\n\t\tdev_err(adev->dev, \"failed to invalidate instruction cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_kiq_setting(struct amdgpu_ring *ring)\n{\n\tuint32_t tmp;\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regRLC_CP_SCHEDULERS);\n\ttmp &= 0xffffff00;\n\ttmp |= (ring->me << 5) | (ring->pipe << 3) | (ring->queue);\n\tWREG32_SOC15(GC, 0, regRLC_CP_SCHEDULERS, tmp);\n\ttmp |= 0x80;\n\tWREG32_SOC15(GC, 0, regRLC_CP_SCHEDULERS, tmp);\n}\n\nstatic void gfx_v11_0_cp_set_doorbell_range(struct amdgpu_device *adev)\n{\n\t \n\tWREG32_SOC15(GC, 0, regCP_RB_DOORBELL_RANGE_LOWER,\n\t\t     (adev->doorbell_index.gfx_ring0 * 2) << 2);\n\tWREG32_SOC15(GC, 0, regCP_RB_DOORBELL_RANGE_UPPER,\n\t\t     (adev->doorbell_index.gfx_userqueue_end * 2) << 2);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_MEC_DOORBELL_RANGE_LOWER,\n\t\t     (adev->doorbell_index.kiq * 2) << 2);\n\tWREG32_SOC15(GC, 0, regCP_MEC_DOORBELL_RANGE_UPPER,\n\t\t     (adev->doorbell_index.userqueue_end * 2) << 2);\n}\n\nstatic int gfx_v11_0_gfx_mqd_init(struct amdgpu_device *adev, void *m,\n\t\t\t\t  struct amdgpu_mqd_prop *prop)\n{\n\tstruct v11_gfx_mqd *mqd = m;\n\tuint64_t hqd_gpu_addr, wb_gpu_addr;\n\tuint32_t tmp;\n\tuint32_t rb_bufsz;\n\n\t \n\tmqd->cp_gfx_hqd_wptr = 0;\n\tmqd->cp_gfx_hqd_wptr_hi = 0;\n\n\t \n\tmqd->cp_mqd_base_addr = prop->mqd_gpu_addr & 0xfffffffc;\n\tmqd->cp_mqd_base_addr_hi = upper_32_bits(prop->mqd_gpu_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_MQD_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_MQD_CONTROL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_MQD_CONTROL, PRIV_STATE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_MQD_CONTROL, CACHE_POLICY, 0);\n\tmqd->cp_gfx_mqd_control = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_HQD_VMID);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_VMID, VMID, 0);\n\tmqd->cp_gfx_hqd_vmid = 0;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_HQD_QUEUE_PRIORITY);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_QUEUE_PRIORITY, PRIORITY_LEVEL, 0);\n\tmqd->cp_gfx_hqd_queue_priority = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_HQD_QUANTUM);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_QUANTUM, QUANTUM_EN, 1);\n\tmqd->cp_gfx_hqd_quantum = tmp;\n\n\t \n\thqd_gpu_addr = prop->hqd_base_gpu_addr >> 8;\n\tmqd->cp_gfx_hqd_base = hqd_gpu_addr;\n\tmqd->cp_gfx_hqd_base_hi = upper_32_bits(hqd_gpu_addr);\n\n\t \n\twb_gpu_addr = prop->rptr_gpu_addr;\n\tmqd->cp_gfx_hqd_rptr_addr = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_gfx_hqd_rptr_addr_hi =\n\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\twb_gpu_addr = prop->wptr_gpu_addr;\n\tmqd->cp_rb_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_rb_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\trb_bufsz = order_base_2(prop->queue_size / 4) - 1;\n\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_HQD_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_CNTL, RB_BLKSZ, rb_bufsz - 2);\n#ifdef __BIG_ENDIAN\n\ttmp = REG_SET_FIELD(tmp, CP_GFX_HQD_CNTL, BUF_SWAP, 1);\n#endif\n\tmqd->cp_gfx_hqd_cntl = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_RB_DOORBELL_CONTROL);\n\tif (prop->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_OFFSET, prop->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t} else\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 0);\n\tmqd->cp_rb_doorbell_control = tmp;\n\n\t \n\tmqd->cp_gfx_hqd_rptr = RREG32_SOC15(GC, 0, regCP_GFX_HQD_RPTR);\n\n\t \n\tmqd->cp_gfx_hqd_active = 1;\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_gfx_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v11_gfx_mqd *mqd = ring->mqd_ptr;\n\tint mqd_idx = ring - &adev->gfx.gfx_ring[0];\n\n\tif (!amdgpu_in_reset(adev) && !adev->in_suspend) {\n\t\tmemset((void *)mqd, 0, sizeof(*mqd));\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc21_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tamdgpu_ring_init_mqd(ring);\n\t\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t\tif (adev->gfx.me.mqd_backup[mqd_idx])\n\t\t\tmemcpy_fromio(adev->gfx.me.mqd_backup[mqd_idx], mqd, sizeof(*mqd));\n\t} else {\n\t\t \n\t\tif (adev->gfx.me.mqd_backup[mqd_idx])\n\t\t\tmemcpy_toio(mqd, adev->gfx.me.mqd_backup[mqd_idx], sizeof(*mqd));\n\t\t \n\t\tring->wptr = 0;\n\t\t*ring->wptr_cpu_addr = 0;\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_cp_async_gfx_ring_resume(struct amdgpu_device *adev)\n{\n\tint r, i;\n\tstruct amdgpu_ring *ring;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\n\t\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\treturn r;\n\n\t\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);\n\t\tif (!r) {\n\t\t\tr = gfx_v11_0_gfx_init_queue(ring);\n\t\t\tamdgpu_bo_kunmap(ring->mqd_obj);\n\t\t\tring->mqd_ptr = NULL;\n\t\t}\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_gfx_enable_kgq(adev, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn gfx_v11_0_cp_gfx_start(adev);\n}\n\nstatic int gfx_v11_0_compute_mqd_init(struct amdgpu_device *adev, void *m,\n\t\t\t\t      struct amdgpu_mqd_prop *prop)\n{\n\tstruct v11_compute_mqd *mqd = m;\n\tuint64_t hqd_gpu_addr, wb_gpu_addr, eop_base_addr;\n\tuint32_t tmp;\n\n\tmqd->header = 0xC0310800;\n\tmqd->compute_pipelinestat_enable = 0x00000001;\n\tmqd->compute_static_thread_mgmt_se0 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se1 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se2 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se3 = 0xffffffff;\n\tmqd->compute_misc_reserved = 0x00000007;\n\n\teop_base_addr = prop->eop_gpu_addr >> 8;\n\tmqd->cp_hqd_eop_base_addr_lo = eop_base_addr;\n\tmqd->cp_hqd_eop_base_addr_hi = upper_32_bits(eop_base_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_EOP_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_EOP_CONTROL, EOP_SIZE,\n\t\t\t(order_base_2(GFX11_MEC_HPD_SIZE / 4) - 1));\n\n\tmqd->cp_hqd_eop_control = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_PQ_DOORBELL_CONTROL);\n\n\tif (prop->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_OFFSET, prop->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_SOURCE, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_HIT, 0);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 0);\n\t}\n\n\tmqd->cp_hqd_pq_doorbell_control = tmp;\n\n\t \n\tmqd->cp_hqd_dequeue_request = 0;\n\tmqd->cp_hqd_pq_rptr = 0;\n\tmqd->cp_hqd_pq_wptr_lo = 0;\n\tmqd->cp_hqd_pq_wptr_hi = 0;\n\n\t \n\tmqd->cp_mqd_base_addr_lo = prop->mqd_gpu_addr & 0xfffffffc;\n\tmqd->cp_mqd_base_addr_hi = upper_32_bits(prop->mqd_gpu_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_MQD_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_MQD_CONTROL, VMID, 0);\n\tmqd->cp_mqd_control = tmp;\n\n\t \n\thqd_gpu_addr = prop->hqd_base_gpu_addr >> 8;\n\tmqd->cp_hqd_pq_base_lo = hqd_gpu_addr;\n\tmqd->cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_PQ_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, QUEUE_SIZE,\n\t\t\t    (order_base_2(prop->queue_size / 4) - 1));\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, RPTR_BLOCK_SIZE,\n\t\t\t    (order_base_2(AMDGPU_GPU_PAGE_SIZE / 4) - 1));\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, UNORD_DISPATCH, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, TUNNEL_DISPATCH, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, PRIV_STATE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, KMD_QUEUE, 1);\n\tmqd->cp_hqd_pq_control = tmp;\n\n\t \n\twb_gpu_addr = prop->rptr_gpu_addr;\n\tmqd->cp_hqd_pq_rptr_report_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_rptr_report_addr_hi =\n\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\twb_gpu_addr = prop->wptr_gpu_addr;\n\tmqd->cp_hqd_pq_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\n\ttmp = 0;\n\t \n\tif (prop->use_doorbell) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_PQ_DOORBELL_CONTROL);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\tDOORBELL_OFFSET, prop->doorbell_index);\n\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_SOURCE, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_HIT, 0);\n\t}\n\n\tmqd->cp_hqd_pq_doorbell_control = tmp;\n\n\t \n\tmqd->cp_hqd_pq_rptr = RREG32_SOC15(GC, 0, regCP_HQD_PQ_RPTR);\n\n\t \n\tmqd->cp_hqd_vmid = 0;\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_PERSISTENT_STATE);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PERSISTENT_STATE, PRELOAD_SIZE, 0x55);\n\tmqd->cp_hqd_persistent_state = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, regCP_HQD_IB_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_IB_CONTROL, MIN_IB_AVAIL_SIZE, 3);\n\tmqd->cp_hqd_ib_control = tmp;\n\n\t \n\tmqd->cp_hqd_pipe_priority = prop->hqd_pipe_priority;\n\tmqd->cp_hqd_queue_priority = prop->hqd_queue_priority;\n\n\tmqd->cp_hqd_active = prop->hqd_active;\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_kiq_init_register(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v11_compute_mqd *mqd = ring->mqd_ptr;\n\tint j;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_ACTIVE, 0);\n\n\t \n\tWREG32_FIELD15_PREREG(GC, 0, CP_PQ_WPTR_POLL_CNTL, EN, 0);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_EOP_BASE_ADDR,\n\t       mqd->cp_hqd_eop_base_addr_lo);\n\tWREG32_SOC15(GC, 0, regCP_HQD_EOP_BASE_ADDR_HI,\n\t       mqd->cp_hqd_eop_base_addr_hi);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_EOP_CONTROL,\n\t       mqd->cp_hqd_eop_control);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_DOORBELL_CONTROL,\n\t       mqd->cp_hqd_pq_doorbell_control);\n\n\t \n\tif (RREG32_SOC15(GC, 0, regCP_HQD_ACTIVE) & 1) {\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_DEQUEUE_REQUEST, 1);\n\t\tfor (j = 0; j < adev->usec_timeout; j++) {\n\t\t\tif (!(RREG32_SOC15(GC, 0, regCP_HQD_ACTIVE) & 1))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_DEQUEUE_REQUEST,\n\t\t       mqd->cp_hqd_dequeue_request);\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_RPTR,\n\t\t       mqd->cp_hqd_pq_rptr);\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_LO,\n\t\t       mqd->cp_hqd_pq_wptr_lo);\n\t\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_HI,\n\t\t       mqd->cp_hqd_pq_wptr_hi);\n\t}\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_MQD_BASE_ADDR,\n\t       mqd->cp_mqd_base_addr_lo);\n\tWREG32_SOC15(GC, 0, regCP_MQD_BASE_ADDR_HI,\n\t       mqd->cp_mqd_base_addr_hi);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_MQD_CONTROL,\n\t       mqd->cp_mqd_control);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_BASE,\n\t       mqd->cp_hqd_pq_base_lo);\n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_BASE_HI,\n\t       mqd->cp_hqd_pq_base_hi);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_CONTROL,\n\t       mqd->cp_hqd_pq_control);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_RPTR_REPORT_ADDR,\n\t\tmqd->cp_hqd_pq_rptr_report_addr_lo);\n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_RPTR_REPORT_ADDR_HI,\n\t\tmqd->cp_hqd_pq_rptr_report_addr_hi);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_POLL_ADDR,\n\t       mqd->cp_hqd_pq_wptr_poll_addr_lo);\n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_POLL_ADDR_HI,\n\t       mqd->cp_hqd_pq_wptr_poll_addr_hi);\n\n\t \n\tif (ring->use_doorbell) {\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_DOORBELL_RANGE_LOWER,\n\t\t\t(adev->doorbell_index.kiq * 2) << 2);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_DOORBELL_RANGE_UPPER,\n\t\t\t(adev->doorbell_index.userqueue_end * 2) << 2);\n\t}\n\n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_DOORBELL_CONTROL,\n\t       mqd->cp_hqd_pq_doorbell_control);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_LO,\n\t       mqd->cp_hqd_pq_wptr_lo);\n\tWREG32_SOC15(GC, 0, regCP_HQD_PQ_WPTR_HI,\n\t       mqd->cp_hqd_pq_wptr_hi);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_VMID, mqd->cp_hqd_vmid);\n\n\tWREG32_SOC15(GC, 0, regCP_HQD_PERSISTENT_STATE,\n\t       mqd->cp_hqd_persistent_state);\n\n\t \n\tWREG32_SOC15(GC, 0, regCP_HQD_ACTIVE,\n\t       mqd->cp_hqd_active);\n\n\tif (ring->use_doorbell)\n\t\tWREG32_FIELD15_PREREG(GC, 0, CP_PQ_STATUS, DOORBELL_ENABLE, 1);\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_kiq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v11_compute_mqd *mqd = ring->mqd_ptr;\n\n\tgfx_v11_0_kiq_setting(ring);\n\n\tif (amdgpu_in_reset(adev)) {  \n\t\t \n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy_toio(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(*mqd));\n\n\t\t \n\t\tring->wptr = 0;\n\t\tamdgpu_ring_clear_ring(ring);\n\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc21_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tgfx_v11_0_kiq_init_register(ring);\n\t\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t} else {\n\t\tmemset((void *)mqd, 0, sizeof(*mqd));\n\t\tif (amdgpu_sriov_vf(adev) && adev->in_suspend)\n\t\t\tamdgpu_ring_clear_ring(ring);\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc21_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tamdgpu_ring_init_mqd(ring);\n\t\tgfx_v11_0_kiq_init_register(ring);\n\t\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy_fromio(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(*mqd));\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_kcq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v11_compute_mqd *mqd = ring->mqd_ptr;\n\tint mqd_idx = ring - &adev->gfx.compute_ring[0];\n\n\tif (!amdgpu_in_reset(adev) && !adev->in_suspend) {\n\t\tmemset((void *)mqd, 0, sizeof(*mqd));\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc21_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);\n\t\tamdgpu_ring_init_mqd(ring);\n\t\tsoc21_grbm_select(adev, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy_fromio(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(*mqd));\n\t} else {\n\t\t \n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy_toio(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(*mqd));\n\t\t \n\t\tring->wptr = 0;\n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, 0);\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_kiq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tint r;\n\n\tring = &adev->gfx.kiq[0].ring;\n\n\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);\n\tif (unlikely(r != 0)) {\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\treturn r;\n\t}\n\n\tgfx_v11_0_kiq_init_queue(ring);\n\tamdgpu_bo_kunmap(ring->mqd_obj);\n\tring->mqd_ptr = NULL;\n\tamdgpu_bo_unreserve(ring->mqd_obj);\n\tring->sched.ready = true;\n\treturn 0;\n}\n\nstatic int gfx_v11_0_kcq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = NULL;\n\tint r = 0, i;\n\n\tif (!amdgpu_async_gfx_ring)\n\t\tgfx_v11_0_cp_compute_enable(adev, true);\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\n\t\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tgoto done;\n\t\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);\n\t\tif (!r) {\n\t\t\tr = gfx_v11_0_kcq_init_queue(ring);\n\t\t\tamdgpu_bo_kunmap(ring->mqd_obj);\n\t\t\tring->mqd_ptr = NULL;\n\t\t}\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\tif (r)\n\t\t\tgoto done;\n\t}\n\n\tr = amdgpu_gfx_enable_kcq(adev, 0);\ndone:\n\treturn r;\n}\n\nstatic int gfx_v11_0_cp_resume(struct amdgpu_device *adev)\n{\n\tint r, i;\n\tstruct amdgpu_ring *ring;\n\n\tif (!(adev->flags & AMD_IS_APU))\n\t\tgfx_v11_0_enable_gui_idle_interrupt(adev, false);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {\n\t\t \n\t\tr = gfx_v11_0_cp_gfx_load_microcode(adev);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (adev->gfx.rs64_enable)\n\t\t\tr = gfx_v11_0_cp_compute_load_microcode_rs64(adev);\n\t\telse\n\t\t\tr = gfx_v11_0_cp_compute_load_microcode(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tgfx_v11_0_cp_set_doorbell_range(adev);\n\n\tif (amdgpu_async_gfx_ring) {\n\t\tgfx_v11_0_cp_compute_enable(adev, true);\n\t\tgfx_v11_0_cp_gfx_enable(adev, true);\n\t}\n\n\tif (adev->enable_mes_kiq && adev->mes.kiq_hw_init)\n\t\tr = amdgpu_mes_kiq_hw_init(adev);\n\telse\n\t\tr = gfx_v11_0_kiq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v11_0_kcq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (!amdgpu_async_gfx_ring) {\n\t\tr = gfx_v11_0_cp_gfx_resume(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tr = gfx_v11_0_cp_async_gfx_ring_resume(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\t\tr = amdgpu_ring_test_helper(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\t\tr = amdgpu_ring_test_helper(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_cp_enable(struct amdgpu_device *adev, bool enable)\n{\n\tgfx_v11_0_cp_gfx_enable(adev, enable);\n\tgfx_v11_0_cp_compute_enable(adev, enable);\n}\n\nstatic int gfx_v11_0_gfxhub_enable(struct amdgpu_device *adev)\n{\n\tint r;\n\tbool value;\n\n\tr = adev->gfxhub.funcs->gart_enable(adev);\n\tif (r)\n\t\treturn r;\n\n\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\n\tvalue = (amdgpu_vm_fault_stop == AMDGPU_VM_FAULT_STOP_ALWAYS) ?\n\t\tfalse : true;\n\n\tadev->gfxhub.funcs->set_fault_enable_default(adev, value);\n\tamdgpu_gmc_flush_gpu_tlb(adev, 0, AMDGPU_GFXHUB(0), 0);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_select_cp_fw_arch(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\t \n\tif (adev->gfx.rs64_enable) {\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_GFX_CNTL);\n\t\ttmp = REG_SET_FIELD(tmp, CP_GFX_CNTL, ENGINE_SEL, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_GFX_CNTL, tmp);\n\n\t\ttmp = RREG32_SOC15(GC, 0, regCP_MEC_ISA_CNTL);\n\t\ttmp = REG_SET_FIELD(tmp, CP_MEC_ISA_CNTL, ISA_MODE, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_MEC_ISA_CNTL, tmp);\n\t}\n\n\tif (amdgpu_emu_mode == 1)\n\t\tmsleep(100);\n}\n\nstatic int get_gb_addr_config(struct amdgpu_device * adev)\n{\n\tu32 gb_addr_config;\n\n\tgb_addr_config = RREG32_SOC15(GC, 0, regGB_ADDR_CONFIG);\n\tif (gb_addr_config == 0)\n\t\treturn -EINVAL;\n\n\tadev->gfx.config.gb_addr_config_fields.num_pkrs =\n\t\t1 << REG_GET_FIELD(gb_addr_config, GB_ADDR_CONFIG, NUM_PKRS);\n\n\tadev->gfx.config.gb_addr_config = gb_addr_config;\n\n\tadev->gfx.config.gb_addr_config_fields.num_pipes = 1 <<\n\t\t\tREG_GET_FIELD(adev->gfx.config.gb_addr_config,\n\t\t\t\t      GB_ADDR_CONFIG, NUM_PIPES);\n\n\tadev->gfx.config.max_tile_pipes =\n\t\tadev->gfx.config.gb_addr_config_fields.num_pipes;\n\n\tadev->gfx.config.gb_addr_config_fields.max_compress_frags = 1 <<\n\t\t\tREG_GET_FIELD(adev->gfx.config.gb_addr_config,\n\t\t\t\t      GB_ADDR_CONFIG, MAX_COMPRESSED_FRAGS);\n\tadev->gfx.config.gb_addr_config_fields.num_rb_per_se = 1 <<\n\t\t\tREG_GET_FIELD(adev->gfx.config.gb_addr_config,\n\t\t\t\t      GB_ADDR_CONFIG, NUM_RB_PER_SE);\n\tadev->gfx.config.gb_addr_config_fields.num_se = 1 <<\n\t\t\tREG_GET_FIELD(adev->gfx.config.gb_addr_config,\n\t\t\t\t      GB_ADDR_CONFIG, NUM_SHADER_ENGINES);\n\tadev->gfx.config.gb_addr_config_fields.pipe_interleave_size = 1 << (8 +\n\t\t\tREG_GET_FIELD(adev->gfx.config.gb_addr_config,\n\t\t\t\t      GB_ADDR_CONFIG, PIPE_INTERLEAVE_SIZE));\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_disable_gpa_mode(struct amdgpu_device *adev)\n{\n\tuint32_t data;\n\n\tdata = RREG32_SOC15(GC, 0, regCPC_PSP_DEBUG);\n\tdata |= CPC_PSP_DEBUG__GPA_OVERRIDE_MASK;\n\tWREG32_SOC15(GC, 0, regCPC_PSP_DEBUG, data);\n\n\tdata = RREG32_SOC15(GC, 0, regCPG_PSP_DEBUG);\n\tdata |= CPG_PSP_DEBUG__GPA_OVERRIDE_MASK;\n\tWREG32_SOC15(GC, 0, regCPG_PSP_DEBUG, data);\n}\n\nstatic int gfx_v11_0_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) {\n\t\tif (adev->gfx.imu.funcs) {\n\t\t\t \n\t\t\tif (adev->gfx.imu.funcs->program_rlc_ram)\n\t\t\t\tadev->gfx.imu.funcs->program_rlc_ram(adev);\n\t\t}\n\t\t \n\t\tr = gfx_v11_0_rlc_backdoor_autoload_enable(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {\n\t\t\tif (adev->gfx.imu.funcs && (amdgpu_dpm > 0)) {\n\t\t\t\tif (adev->gfx.imu.funcs->load_microcode)\n\t\t\t\t\tadev->gfx.imu.funcs->load_microcode(adev);\n\t\t\t\tif (adev->gfx.imu.funcs->setup_imu)\n\t\t\t\t\tadev->gfx.imu.funcs->setup_imu(adev);\n\t\t\t\tif (adev->gfx.imu.funcs->start_imu)\n\t\t\t\t\tadev->gfx.imu.funcs->start_imu(adev);\n\t\t\t}\n\n\t\t\t \n\t\t\tgfx_v11_0_disable_gpa_mode(adev);\n\t\t}\n\t}\n\n\tif ((adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP)) {\n\t\tr = gfx_v11_0_wait_for_rlc_autoload_complete(adev);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) failed to wait rlc autoload complete\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tadev->gfx.is_poweron = true;\n\n\tif(get_gb_addr_config(adev))\n\t\tDRM_WARN(\"Invalid gb_addr_config !\\n\");\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP &&\n\t    adev->gfx.rs64_enable)\n\t\tgfx_v11_0_config_gfx_rs64(adev);\n\n\tr = gfx_v11_0_gfxhub_enable(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (!amdgpu_emu_mode)\n\t\tgfx_v11_0_init_golden_registers(adev);\n\n\tif ((adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO && amdgpu_dpm == 1)) {\n\t\t \n\t\tif (!(adev->flags & AMD_IS_APU)) {\n\t\t\tr = amdgpu_pm_load_smu_firmware(adev, NULL);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tgfx_v11_0_constants_init(adev);\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP)\n\t\tgfx_v11_0_select_cp_fw_arch(adev);\n\n\tif (adev->nbio.funcs->gc_doorbell_init)\n\t\tadev->nbio.funcs->gc_doorbell_init(adev);\n\n\tr = gfx_v11_0_rlc_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tgfx_v11_0_tcp_harvest(adev);\n\n\tr = gfx_v11_0_cp_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn r;\n}\n\nstatic int gfx_v11_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_put(adev, &adev->gfx.priv_reg_irq, 0);\n\tamdgpu_irq_put(adev, &adev->gfx.priv_inst_irq, 0);\n\n\tif (!adev->no_hw_access) {\n\t\tif (amdgpu_async_gfx_ring) {\n\t\t\tif (amdgpu_gfx_disable_kgq(adev, 0))\n\t\t\t\tDRM_ERROR(\"KGQ disable failed\\n\");\n\t\t}\n\n\t\tif (amdgpu_gfx_disable_kcq(adev, 0))\n\t\t\tDRM_ERROR(\"KCQ disable failed\\n\");\n\n\t\tamdgpu_mes_kiq_hw_fini(adev);\n\t}\n\n\tif (amdgpu_sriov_vf(adev))\n\t\t \n\t\treturn 0;\n\n\tgfx_v11_0_cp_enable(adev, false);\n\tgfx_v11_0_enable_gui_idle_interrupt(adev, false);\n\n\tadev->gfxhub.funcs->gart_disable(adev);\n\n\tadev->gfx.is_poweron = false;\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_suspend(void *handle)\n{\n\treturn gfx_v11_0_hw_fini(handle);\n}\n\nstatic int gfx_v11_0_resume(void *handle)\n{\n\treturn gfx_v11_0_hw_init(handle);\n}\n\nstatic bool gfx_v11_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (REG_GET_FIELD(RREG32_SOC15(GC, 0, regGRBM_STATUS),\n\t\t\t\tGRBM_STATUS, GUI_ACTIVE))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int gfx_v11_0_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tu32 tmp;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32_SOC15(GC, 0, regGRBM_STATUS) &\n\t\t\tGRBM_STATUS__GUI_ACTIVE_MASK;\n\n\t\tif (!REG_GET_FIELD(tmp, GRBM_STATUS, GUI_ACTIVE))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int gfx_v11_0_soft_reset(void *handle)\n{\n\tu32 grbm_soft_reset = 0;\n\tu32 tmp;\n\tint i, j, k;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_INT_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CMP_BUSY_INT_ENABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_BUSY_INT_ENABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_EMPTY_INT_ENABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, GFX_IDLE_INT_ENABLE, 0);\n\tWREG32_SOC15(GC, 0, regCP_INT_CNTL, tmp);\n\n\tgfx_v11_0_set_safe_mode(adev, 0);\n\n\tfor (i = 0; i < adev->gfx.mec.num_mec; ++i) {\n\t\tfor (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {\n\t\t\t\ttmp = RREG32_SOC15(GC, 0, regGRBM_GFX_CNTL);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, MEID, i);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, QUEUEID, j);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, PIPEID, k);\n\t\t\t\tWREG32_SOC15(GC, 0, regGRBM_GFX_CNTL, tmp);\n\n\t\t\t\tWREG32_SOC15(GC, 0, regCP_HQD_DEQUEUE_REQUEST, 0x2);\n\t\t\t\tWREG32_SOC15(GC, 0, regSPI_COMPUTE_QUEUE_RESET, 0x1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < adev->gfx.me.num_me; ++i) {\n\t\tfor (j = 0; j < adev->gfx.me.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.me.num_pipe_per_me; k++) {\n\t\t\t\ttmp = RREG32_SOC15(GC, 0, regGRBM_GFX_CNTL);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, MEID, i);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, QUEUEID, j);\n\t\t\t\ttmp = REG_SET_FIELD(tmp, GRBM_GFX_CNTL, PIPEID, k);\n\t\t\t\tWREG32_SOC15(GC, 0, regGRBM_GFX_CNTL, tmp);\n\n\t\t\t\tWREG32_SOC15(GC, 0, regCP_GFX_HQD_DEQUEUE_REQUEST, 0x1);\n\t\t\t}\n\t\t}\n\t}\n\n\tWREG32_SOC15(GC, 0, regCP_VMID_RESET, 0xfffffffe);\n\n\t\n\t\n\tRREG32_SOC15(GC, 0, regCP_VMID_RESET);\n\tRREG32_SOC15(GC, 0, regCP_VMID_RESET);\n\tRREG32_SOC15(GC, 0, regCP_VMID_RESET);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!RREG32_SOC15(GC, 0, regCP_HQD_ACTIVE) &&\n\t\t    !RREG32_SOC15(GC, 0, regCP_GFX_HQD_ACTIVE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i >= adev->usec_timeout) {\n\t\tprintk(\"Failed to wait all pipes clean\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgrbm_soft_reset = RREG32_SOC15(GC, 0, regGRBM_SOFT_RESET);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CP, 1);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_GFX, 1);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPF, 1);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPC, 1);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPG, 1);\n\tWREG32_SOC15(GC, 0, regGRBM_SOFT_RESET, grbm_soft_reset);\n\t \n\tgrbm_soft_reset = RREG32_SOC15(GC, 0, regGRBM_SOFT_RESET);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CP, 0);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_GFX, 0);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPF, 0);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPC, 0);\n\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset, GRBM_SOFT_RESET,\n\t\t\t\t\tSOFT_RESET_CPG, 0);\n\tWREG32_SOC15(GC, 0, regGRBM_SOFT_RESET, grbm_soft_reset);\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_SOFT_RESET_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_SOFT_RESET_CNTL, CMP_HQD_REG_RESET, 0x1);\n\tWREG32_SOC15(GC, 0, regCP_SOFT_RESET_CNTL, tmp);\n\n\tWREG32_SOC15(GC, 0, regCP_ME_CNTL, 0x0);\n\tWREG32_SOC15(GC, 0, regCP_MEC_RS64_CNTL, 0x0);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!RREG32_SOC15(GC, 0, regCP_VMID_RESET))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i >= adev->usec_timeout) {\n\t\tprintk(\"Failed to wait CP_VMID_RESET to 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = RREG32_SOC15(GC, 0, regCP_INT_CNTL);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CMP_BUSY_INT_ENABLE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_BUSY_INT_ENABLE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, CNTX_EMPTY_INT_ENABLE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL, GFX_IDLE_INT_ENABLE, 1);\n\tWREG32_SOC15(GC, 0, regCP_INT_CNTL, tmp);\n\n\tgfx_v11_0_unset_safe_mode(adev, 0);\n\n\treturn gfx_v11_0_cp_resume(adev);\n}\n\nstatic bool gfx_v11_0_check_soft_reset(void *handle)\n{\n\tint i, r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring;\n\tlong tmo = msecs_to_jiffies(1000);\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\t\tr = amdgpu_ring_test_ib(ring, tmo);\n\t\tif (r)\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\t\tr = amdgpu_ring_test_ib(ring, tmo);\n\t\tif (r)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int gfx_v11_0_post_soft_reset(void *handle)\n{\n\t \n\treturn amdgpu_mes_resume((struct amdgpu_device *)handle);\n}\n\nstatic uint64_t gfx_v11_0_get_gpu_clock_counter(struct amdgpu_device *adev)\n{\n\tuint64_t clock;\n\tuint64_t clock_counter_lo, clock_counter_hi_pre, clock_counter_hi_after;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tamdgpu_gfx_off_ctrl(adev, false);\n\t\tmutex_lock(&adev->gfx.gpu_clock_mutex);\n\t\tclock_counter_hi_pre = (uint64_t)RREG32_SOC15(GC, 0, regCP_MES_MTIME_HI);\n\t\tclock_counter_lo = (uint64_t)RREG32_SOC15(GC, 0, regCP_MES_MTIME_LO);\n\t\tclock_counter_hi_after = (uint64_t)RREG32_SOC15(GC, 0, regCP_MES_MTIME_HI);\n\t\tif (clock_counter_hi_pre != clock_counter_hi_after)\n\t\t\tclock_counter_lo = (uint64_t)RREG32_SOC15(GC, 0, regCP_MES_MTIME_LO);\n\t\tmutex_unlock(&adev->gfx.gpu_clock_mutex);\n\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t} else {\n\t\tpreempt_disable();\n\t\tclock_counter_hi_pre = (uint64_t)RREG32_SOC15(SMUIO, 0, regGOLDEN_TSC_COUNT_UPPER);\n\t\tclock_counter_lo = (uint64_t)RREG32_SOC15(SMUIO, 0, regGOLDEN_TSC_COUNT_LOWER);\n\t\tclock_counter_hi_after = (uint64_t)RREG32_SOC15(SMUIO, 0, regGOLDEN_TSC_COUNT_UPPER);\n\t\tif (clock_counter_hi_pre != clock_counter_hi_after)\n\t\t\tclock_counter_lo = (uint64_t)RREG32_SOC15(SMUIO, 0, regGOLDEN_TSC_COUNT_LOWER);\n\t\tpreempt_enable();\n\t}\n\tclock = clock_counter_lo | (clock_counter_hi_after << 32ULL);\n\n\treturn clock;\n}\n\nstatic void gfx_v11_0_ring_emit_gds_switch(struct amdgpu_ring *ring,\n\t\t\t\t\t   uint32_t vmid,\n\t\t\t\t\t   uint32_t gds_base, uint32_t gds_size,\n\t\t\t\t\t   uint32_t gws_base, uint32_t gws_size,\n\t\t\t\t\t   uint32_t oa_base, uint32_t oa_size)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\tgfx_v11_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t    SOC15_REG_OFFSET(GC, 0, regGDS_VMID0_BASE) + 2 * vmid,\n\t\t\t\t    gds_base);\n\n\t \n\tgfx_v11_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t    SOC15_REG_OFFSET(GC, 0, regGDS_VMID0_SIZE) + 2 * vmid,\n\t\t\t\t    gds_size);\n\n\t \n\tgfx_v11_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t    SOC15_REG_OFFSET(GC, 0, regGDS_GWS_VMID0) + vmid,\n\t\t\t\t    gws_size << GDS_GWS_VMID0__SIZE__SHIFT | gws_base);\n\n\t \n\tgfx_v11_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t    SOC15_REG_OFFSET(GC, 0, regGDS_OA_VMID0) + vmid,\n\t\t\t\t    (1 << (oa_size + oa_base)) - (1 << oa_base));\n}\n\nstatic int gfx_v11_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->gfx.funcs = &gfx_v11_0_gfx_funcs;\n\n\tadev->gfx.num_gfx_rings = GFX11_NUM_GFX_RINGS;\n\tadev->gfx.num_compute_rings = min(amdgpu_gfx_get_num_kcq(adev),\n\t\t\t\t\t  AMDGPU_MAX_COMPUTE_RINGS);\n\n\tgfx_v11_0_set_kiq_pm4_funcs(adev);\n\tgfx_v11_0_set_ring_funcs(adev);\n\tgfx_v11_0_set_irq_funcs(adev);\n\tgfx_v11_0_set_gds_init(adev);\n\tgfx_v11_0_set_rlc_funcs(adev);\n\tgfx_v11_0_set_mqd_funcs(adev);\n\tgfx_v11_0_set_imu_funcs(adev);\n\n\tgfx_v11_0_init_rlcg_reg_access_ctrl(adev);\n\n\treturn gfx_v11_0_init_microcode(adev);\n}\n\nstatic int gfx_v11_0_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_reg_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_inst_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic bool gfx_v11_0_is_rlc_enabled(struct amdgpu_device *adev)\n{\n\tuint32_t rlc_cntl;\n\n\t \n\trlc_cntl = RREG32_SOC15(GC, 0, regRLC_CNTL);\n\treturn (REG_GET_FIELD(rlc_cntl, RLC_CNTL, RLC_ENABLE_F32)) ? true : false;\n}\n\nstatic void gfx_v11_0_set_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tuint32_t data;\n\tunsigned i;\n\n\tdata = RLC_SAFE_MODE__CMD_MASK;\n\tdata |= (1 << RLC_SAFE_MODE__MESSAGE__SHIFT);\n\n\tWREG32_SOC15(GC, 0, regRLC_SAFE_MODE, data);\n\n\t \n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!REG_GET_FIELD(RREG32_SOC15(GC, 0, regRLC_SAFE_MODE),\n\t\t\t\t   RLC_SAFE_MODE, CMD))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v11_0_unset_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tWREG32_SOC15(GC, 0, regRLC_SAFE_MODE, RLC_SAFE_MODE__CMD_MASK);\n}\n\nstatic void gfx_v11_0_update_perf_clk(struct amdgpu_device *adev,\n\t\t\t\t      bool enable)\n{\n\tuint32_t def, data;\n\n\tif (!(adev->cg_flags & AMD_CG_SUPPORT_GFX_PERF_CLK))\n\t\treturn;\n\n\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\tif (enable)\n\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__PERFMON_CLOCK_STATE_MASK;\n\telse\n\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__PERFMON_CLOCK_STATE_MASK;\n\n\tif (def != data)\n\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n}\n\nstatic void gfx_v11_0_update_sram_fgcg(struct amdgpu_device *adev,\n\t\t\t\t       bool enable)\n{\n\tuint32_t def, data;\n\n\tif (!(adev->cg_flags & AMD_CG_SUPPORT_GFX_FGCG))\n\t\treturn;\n\n\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\tif (enable)\n\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_FGCG_OVERRIDE_MASK;\n\telse\n\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__GFXIP_FGCG_OVERRIDE_MASK;\n\n\tif (def != data)\n\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n}\n\nstatic void gfx_v11_0_update_repeater_fgcg(struct amdgpu_device *adev,\n\t\t\t\t\t   bool enable)\n{\n\tuint32_t def, data;\n\n\tif (!(adev->cg_flags & AMD_CG_SUPPORT_REPEATER_FGCG))\n\t\treturn;\n\n\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\tif (enable)\n\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_REPEATER_FGCG_OVERRIDE_MASK;\n\telse\n\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__GFXIP_REPEATER_FGCG_OVERRIDE_MASK;\n\n\tif (def != data)\n\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n}\n\nstatic void gfx_v11_0_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tuint32_t data, def;\n\n\tif (!(adev->cg_flags & (AMD_CG_SUPPORT_GFX_MGCG | AMD_CG_SUPPORT_GFX_MGLS)))\n\t\treturn;\n\n\t \n\tif (enable) {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG) {\n\t\t\t \n\t\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\t\t\tdata &= ~(RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t\t  RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK);\n\n\t\t\tif (def != data)\n\t\t\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n\t\t}\n\t} else {\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG) {\n\t\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\t\t\tdata |= (RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t\t RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t\t RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK);\n\n\t\t\tif (def != data)\n\t\t\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n\t\t}\n\t}\n}\n\nstatic void gfx_v11_0_update_coarse_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tuint32_t def, data;\n\n\tif (!(adev->cg_flags &\n\t      (AMD_CG_SUPPORT_GFX_CGCG |\n\t      AMD_CG_SUPPORT_GFX_CGLS |\n\t      AMD_CG_SUPPORT_GFX_3D_CGCG |\n\t      AMD_CG_SUPPORT_GFX_3D_CGLS)))\n\t\treturn;\n\n\tif (enable) {\n\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\n\t\t \n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)\n\t\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGCG_OVERRIDE_MASK;\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)\n\t\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGLS_OVERRIDE_MASK;\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG ||\n\t\t    adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS)\n\t\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_GFX3D_CG_OVERRIDE_MASK;\n\n\t\t \n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG) {\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD_MASK;\n\t\t\tdata |= (0x36 << RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |\n\t\t\t\t RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;\n\t\t}\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS) {\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL__CGLS_REP_COMPANSAT_DELAY_MASK;\n\t\t\tdata |= (0x000F << RLC_CGCG_CGLS_CTRL__CGLS_REP_COMPANSAT_DELAY__SHIFT) |\n\t\t\t\t RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\t\t}\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL, data);\n\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL_3D);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG) {\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD_MASK;\n\t\t\tdata |= (0x36 << RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |\n\t\t\t\t RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK;\n\t\t}\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS) {\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL_3D__CGLS_REP_COMPANSAT_DELAY_MASK;\n\t\t\tdata |= (0xf << RLC_CGCG_CGLS_CTRL_3D__CGLS_REP_COMPANSAT_DELAY__SHIFT) |\n\t\t\t\t RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK;\n\t\t}\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL_3D, data);\n\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_CNTL);\n\n\t\tdata &= ~(CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY_MASK | CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT_MASK);\n\t\tdata |= (0x0100 << CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY__SHIFT) |\n\t\t\t(0x0090 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regCP_RB_WPTR_POLL_CNTL, data);\n\n\t\tdata = RREG32_SOC15(GC, 0, regCP_INT_CNTL);\n\t\tdata = REG_SET_FIELD(data, CP_INT_CNTL, CNTX_BUSY_INT_ENABLE, 1);\n\t\tdata = REG_SET_FIELD(data, CP_INT_CNTL, CNTX_EMPTY_INT_ENABLE, 1);\n\t\tdata = REG_SET_FIELD(data, CP_INT_CNTL, CMP_BUSY_INT_ENABLE, 1);\n\t\tdata = REG_SET_FIELD(data, CP_INT_CNTL, GFX_IDLE_INT_ENABLE, 1);\n\t\tWREG32_SOC15(GC, 0, regCP_INT_CNTL, data);\n\n\t\tdata = RREG32_SOC15(GC, 0, regSDMA0_RLC_CGCG_CTRL);\n\t\tdata = REG_SET_FIELD(data, SDMA0_RLC_CGCG_CTRL, CGCG_INT_ENABLE, 1);\n\t\tWREG32_SOC15(GC, 0, regSDMA0_RLC_CGCG_CTRL, data);\n\n\t\t \n\t\tif (adev->sdma.num_instances > 1) {\n\t\t\tdata = RREG32_SOC15(GC, 0, regSDMA1_RLC_CGCG_CTRL);\n\t\t\tdata = REG_SET_FIELD(data, SDMA1_RLC_CGCG_CTRL, CGCG_INT_ENABLE, 1);\n\t\t\tWREG32_SOC15(GC, 0, regSDMA1_RLC_CGCG_CTRL, data);\n\t\t}\n\t} else {\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL, data);\n\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL_3D);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG)\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK;\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS)\n\t\t\tdata &= ~RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK;\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL_3D, data);\n\n\t\tdata = RREG32_SOC15(GC, 0, regSDMA0_RLC_CGCG_CTRL);\n\t\tdata &= ~SDMA0_RLC_CGCG_CTRL__CGCG_INT_ENABLE_MASK;\n\t\tWREG32_SOC15(GC, 0, regSDMA0_RLC_CGCG_CTRL, data);\n\n\t\t \n\t\tif (adev->sdma.num_instances > 1) {\n\t\t\tdata = RREG32_SOC15(GC, 0, regSDMA1_RLC_CGCG_CTRL);\n\t\t\tdata &= ~SDMA1_RLC_CGCG_CTRL__CGCG_INT_ENABLE_MASK;\n\t\t\tWREG32_SOC15(GC, 0, regSDMA1_RLC_CGCG_CTRL, data);\n\t\t}\n\t}\n}\n\nstatic int gfx_v11_0_update_gfx_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t    bool enable)\n{\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\tgfx_v11_0_update_coarse_grain_clock_gating(adev, enable);\n\n\tgfx_v11_0_update_medium_grain_clock_gating(adev, enable);\n\n\tgfx_v11_0_update_repeater_fgcg(adev, enable);\n\n\tgfx_v11_0_update_sram_fgcg(adev, enable);\n\n\tgfx_v11_0_update_perf_clk(adev, enable);\n\n\tif (adev->cg_flags &\n\t    (AMD_CG_SUPPORT_GFX_MGCG |\n\t     AMD_CG_SUPPORT_GFX_CGLS |\n\t     AMD_CG_SUPPORT_GFX_CGCG |\n\t     AMD_CG_SUPPORT_GFX_3D_CGCG |\n\t     AMD_CG_SUPPORT_GFX_3D_CGLS))\n\t        gfx_v11_0_enable_gui_idle_interrupt(adev, enable);\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_update_spm_vmid(struct amdgpu_device *adev, unsigned vmid)\n{\n\tu32 reg, data;\n\n\tamdgpu_gfx_off_ctrl(adev, false);\n\n\treg = SOC15_REG_OFFSET(GC, 0, regRLC_SPM_MC_CNTL);\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tdata = RREG32_NO_KIQ(reg);\n\telse\n\t\tdata = RREG32(reg);\n\n\tdata &= ~RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK;\n\tdata |= (vmid & RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK) << RLC_SPM_MC_CNTL__RLC_SPM_VMID__SHIFT;\n\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tWREG32_SOC15_NO_KIQ(GC, 0, regRLC_SPM_MC_CNTL, data);\n\telse\n\t\tWREG32_SOC15(GC, 0, regRLC_SPM_MC_CNTL, data);\n\n\tamdgpu_gfx_off_ctrl(adev, true);\n}\n\nstatic const struct amdgpu_rlc_funcs gfx_v11_0_rlc_funcs = {\n\t.is_rlc_enabled = gfx_v11_0_is_rlc_enabled,\n\t.set_safe_mode = gfx_v11_0_set_safe_mode,\n\t.unset_safe_mode = gfx_v11_0_unset_safe_mode,\n\t.init = gfx_v11_0_rlc_init,\n\t.get_csb_size = gfx_v11_0_get_csb_size,\n\t.get_csb_buffer = gfx_v11_0_get_csb_buffer,\n\t.resume = gfx_v11_0_rlc_resume,\n\t.stop = gfx_v11_0_rlc_stop,\n\t.reset = gfx_v11_0_rlc_reset,\n\t.start = gfx_v11_0_rlc_start,\n\t.update_spm_vmid = gfx_v11_0_update_spm_vmid,\n};\n\nstatic void gfx_v11_cntl_power_gating(struct amdgpu_device *adev, bool enable)\n{\n\tu32 data = RREG32_SOC15(GC, 0, regRLC_PG_CNTL);\n\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG))\n\t\tdata |= RLC_PG_CNTL__GFX_POWER_GATING_ENABLE_MASK;\n\telse\n\t\tdata &= ~RLC_PG_CNTL__GFX_POWER_GATING_ENABLE_MASK;\n\n\tWREG32_SOC15(GC, 0, regRLC_PG_CNTL, data);\n\n\t\n\tif (enable && (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)) {\n\t\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\t\tcase IP_VERSION(11, 0, 1):\n\t\tcase IP_VERSION(11, 0, 4):\n\t\t\tWREG32_SOC15(GC, 0, regRLC_PG_DELAY_3, RLC_PG_DELAY_3_DEFAULT_GC_11_0_1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void gfx_v11_cntl_pg(struct amdgpu_device *adev, bool enable)\n{\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\tgfx_v11_cntl_power_gating(adev, enable);\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic int gfx_v11_0_set_powergating_state(void *handle,\n\t\t\t\t\t   enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_PG_STATE_GATE);\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\t\tamdgpu_gfx_off_ctrl(adev, enable);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 4):\n\t\tif (!enable)\n\t\t\tamdgpu_gfx_off_ctrl(adev, false);\n\n\t\tgfx_v11_cntl_pg(adev, enable);\n\n\t\tif (enable)\n\t\t\tamdgpu_gfx_off_ctrl(adev, true);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (amdgpu_sriov_vf(adev))\n\t        return 0;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 1):\n\tcase IP_VERSION(11, 0, 2):\n\tcase IP_VERSION(11, 0, 3):\n\tcase IP_VERSION(11, 0, 4):\n\t        gfx_v11_0_update_gfx_clock_gating(adev,\n\t                        state ==  AMD_CG_STATE_GATE);\n\t        break;\n\tdefault:\n\t        break;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint data;\n\n\t \n\tdata = RREG32_SOC15(GC, 0, regRLC_CGTT_MGCG_OVERRIDE);\n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_MGCG;\n\n\t \n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__GFXIP_REPEATER_FGCG_OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_REPEATER_FGCG;\n\n\t \n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__GFXIP_FGCG_OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_FGCG;\n\n\t \n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__PERFMON_CLOCK_STATE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_PERF_CLK;\n\n\t \n\tdata = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL);\n\tif (data & RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGCG;\n\n\t \n\tif (data & RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGLS;\n\n\t \n\tdata = RREG32_SOC15(GC, 0, regRLC_CGCG_CGLS_CTRL_3D);\n\tif (data & RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_3D_CGCG;\n\n\t \n\tif (data & RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_3D_CGLS;\n}\n\nstatic u64 gfx_v11_0_ring_get_rptr_gfx(struct amdgpu_ring *ring)\n{\n\t \n\treturn *(uint32_t *)ring->rptr_cpu_addr;\n}\n\nstatic u64 gfx_v11_0_ring_get_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tu64 wptr;\n\n\t \n\tif (ring->use_doorbell) {\n\t\twptr = atomic64_read((atomic64_t *)ring->wptr_cpu_addr);\n\t} else {\n\t\twptr = RREG32_SOC15(GC, 0, regCP_RB0_WPTR);\n\t\twptr += (u64)RREG32_SOC15(GC, 0, regCP_RB0_WPTR_HI) << 32;\n\t}\n\n\treturn wptr;\n}\n\nstatic void gfx_v11_0_ring_set_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t *wptr_saved;\n\tuint32_t *is_queue_unmap;\n\tuint64_t aggregated_db_index;\n\tuint32_t mqd_size = adev->mqds[AMDGPU_HW_IP_GFX].mqd_size;\n\tuint64_t wptr_tmp;\n\n\tif (ring->is_mes_queue) {\n\t\twptr_saved = (uint32_t *)(ring->mqd_ptr + mqd_size);\n\t\tis_queue_unmap = (uint32_t *)(ring->mqd_ptr + mqd_size +\n\t\t\t\t\t      sizeof(uint32_t));\n\t\taggregated_db_index =\n\t\t\tamdgpu_mes_get_aggregated_doorbell_index(adev,\n\t\t\t\t\t\t\t\t ring->hw_prio);\n\n\t\twptr_tmp = ring->wptr & ring->buf_mask;\n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, wptr_tmp);\n\t\t*wptr_saved = wptr_tmp;\n\t\t \n\t\tif (*is_queue_unmap) {\n\t\t\tWDOORBELL64(aggregated_db_index, wptr_tmp);\n\t\t\tWDOORBELL64(ring->doorbell_index, wptr_tmp);\n\t\t} else {\n\t\t\tWDOORBELL64(ring->doorbell_index, wptr_tmp);\n\n\t\t\tif (*is_queue_unmap)\n\t\t\t\tWDOORBELL64(aggregated_db_index, wptr_tmp);\n\t\t}\n\t} else {\n\t\tif (ring->use_doorbell) {\n\t\t\t \n\t\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr,\n\t\t\t\t     ring->wptr);\n\t\t\tWDOORBELL64(ring->doorbell_index, ring->wptr);\n\t\t} else {\n\t\t\tWREG32_SOC15(GC, 0, regCP_RB0_WPTR,\n\t\t\t\t     lower_32_bits(ring->wptr));\n\t\t\tWREG32_SOC15(GC, 0, regCP_RB0_WPTR_HI,\n\t\t\t\t     upper_32_bits(ring->wptr));\n\t\t}\n\t}\n}\n\nstatic u64 gfx_v11_0_ring_get_rptr_compute(struct amdgpu_ring *ring)\n{\n\t \n\treturn *(uint32_t *)ring->rptr_cpu_addr;\n}\n\nstatic u64 gfx_v11_0_ring_get_wptr_compute(struct amdgpu_ring *ring)\n{\n\tu64 wptr;\n\n\t \n\tif (ring->use_doorbell)\n\t\twptr = atomic64_read((atomic64_t *)ring->wptr_cpu_addr);\n\telse\n\t\tBUG();\n\treturn wptr;\n}\n\nstatic void gfx_v11_0_ring_set_wptr_compute(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t *wptr_saved;\n\tuint32_t *is_queue_unmap;\n\tuint64_t aggregated_db_index;\n\tuint32_t mqd_size = adev->mqds[AMDGPU_HW_IP_COMPUTE].mqd_size;\n\tuint64_t wptr_tmp;\n\n\tif (ring->is_mes_queue) {\n\t\twptr_saved = (uint32_t *)(ring->mqd_ptr + mqd_size);\n\t\tis_queue_unmap = (uint32_t *)(ring->mqd_ptr + mqd_size +\n\t\t\t\t\t      sizeof(uint32_t));\n\t\taggregated_db_index =\n\t\t\tamdgpu_mes_get_aggregated_doorbell_index(adev,\n\t\t\t\t\t\t\t\t ring->hw_prio);\n\n\t\twptr_tmp = ring->wptr & ring->buf_mask;\n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, wptr_tmp);\n\t\t*wptr_saved = wptr_tmp;\n\t\t \n\t\tif (*is_queue_unmap) {\n\t\t\tWDOORBELL64(aggregated_db_index, wptr_tmp);\n\t\t\tWDOORBELL64(ring->doorbell_index, wptr_tmp);\n\t\t} else {\n\t\t\tWDOORBELL64(ring->doorbell_index, wptr_tmp);\n\n\t\t\tif (*is_queue_unmap)\n\t\t\t\tWDOORBELL64(aggregated_db_index, wptr_tmp);\n\t\t}\n\t} else {\n\t\t \n\t\tif (ring->use_doorbell) {\n\t\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr,\n\t\t\t\t     ring->wptr);\n\t\t\tWDOORBELL64(ring->doorbell_index, ring->wptr);\n\t\t} else {\n\t\t\tBUG();  \n\t\t}\n\t}\n}\n\nstatic void gfx_v11_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tu32 ref_and_mask, reg_mem_engine;\n\tconst struct nbio_hdp_flush_reg *nbio_hf_reg = adev->nbio.hdp_flush_reg;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) {\n\t\tswitch (ring->me) {\n\t\tcase 1:\n\t\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp2 << ring->pipe;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp6 << ring->pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\treg_mem_engine = 0;\n\t} else {\n\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp0;\n\t\treg_mem_engine = 1;  \n\t}\n\n\tgfx_v11_0_wait_reg_mem(ring, reg_mem_engine, 0, 1,\n\t\t\t       adev->nbio.funcs->get_hdp_flush_req_offset(adev),\n\t\t\t       adev->nbio.funcs->get_hdp_flush_done_offset(adev),\n\t\t\t       ref_and_mask, ref_and_mask, 0x20);\n}\n\nstatic void gfx_v11_0_ring_emit_ib_gfx(struct amdgpu_ring *ring,\n\t\t\t\t       struct amdgpu_job *job,\n\t\t\t\t       struct amdgpu_ib *ib,\n\t\t\t\t       uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 header, control = 0;\n\n\tBUG_ON(ib->flags & AMDGPU_IB_FLAG_CE);\n\n\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\n\tcontrol |= ib->length_dw | (vmid << 24);\n\n\tif (ring->adev->gfx.mcbp && (ib->flags & AMDGPU_IB_FLAG_PREEMPT)) {\n\t\tcontrol |= INDIRECT_BUFFER_PRE_ENB(1);\n\n\t\tif (flags & AMDGPU_IB_PREEMPTED)\n\t\t\tcontrol |= INDIRECT_BUFFER_PRE_RESUME(1);\n\n\t\tif (vmid)\n\t\t\tgfx_v11_0_ring_emit_de_meta(ring,\n\t\t\t\t    (!amdgpu_sriov_vf(ring->adev) && flags & AMDGPU_IB_PREEMPTED) ? true : false);\n\t}\n\n\tif (ring->is_mes_queue)\n\t\t \n\t\tcontrol |= 0x400000;\n\n\tamdgpu_ring_write(ring, header);\n\tBUG_ON(ib->gpu_addr & 0x3);  \n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t(2 << 0) |\n#endif\n\t\tlower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v11_0_ring_emit_ib_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t   struct amdgpu_job *job,\n\t\t\t\t\t   struct amdgpu_ib *ib,\n\t\t\t\t\t   uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);\n\n\tif (ring->is_mes_queue)\n\t\t \n\t\tcontrol |= 0x40000000;\n\n\t \n\tif (ib->flags & AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID) {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tamdgpu_ring_write(ring, regGDS_COMPUTE_MAX_WAVE_ID);\n\t\tamdgpu_ring_write(ring, ring->adev->gds.gds_compute_max_wave_id);\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tBUG_ON(ib->gpu_addr & 0x3);  \n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t\t(2 << 0) |\n#endif\n\t\t\t\tlower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v11_0_ring_emit_fence(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t     u64 seq, unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, 6));\n\tamdgpu_ring_write(ring, (PACKET3_RELEASE_MEM_GCR_SEQ |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GL2_WB |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GL2_INV |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GL2_US |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GL1_INV |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GLV_INV |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GLM_INV |\n\t\t\t\t PACKET3_RELEASE_MEM_GCR_GLM_WB |\n\t\t\t\t PACKET3_RELEASE_MEM_CACHE_POLICY(3) |\n\t\t\t\t PACKET3_RELEASE_MEM_EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t PACKET3_RELEASE_MEM_EVENT_INDEX(5)));\n\tamdgpu_ring_write(ring, (PACKET3_RELEASE_MEM_DATA_SEL(write64bit ? 2 : 1) |\n\t\t\t\t PACKET3_RELEASE_MEM_INT_SEL(int_sel ? 2 : 0)));\n\n\t \n\tif (write64bit)\n\t\tBUG_ON(addr & 0x7);\n\telse\n\t\tBUG_ON(addr & 0x3);\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n\tamdgpu_ring_write(ring, ring->is_mes_queue ?\n\t\t\t (ring->hw_queue_id | AMDGPU_FENCE_MES_QUEUE_FLAG) : 0);\n}\n\nstatic void gfx_v11_0_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tgfx_v11_0_wait_reg_mem(ring, usepfp, 1, 0, lower_32_bits(addr),\n\t\t\t       upper_32_bits(addr), seq, 0xffffffff, 4);\n}\n\nstatic void gfx_v11_0_ring_invalidate_tlbs(struct amdgpu_ring *ring,\n\t\t\t\t   uint16_t pasid, uint32_t flush_type,\n\t\t\t\t   bool all_hub, uint8_t dst_sel)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_INVALIDATE_TLBS, 0));\n\tamdgpu_ring_write(ring,\n\t\t\t  PACKET3_INVALIDATE_TLBS_DST_SEL(dst_sel) |\n\t\t\t  PACKET3_INVALIDATE_TLBS_ALL_HUB(all_hub) |\n\t\t\t  PACKET3_INVALIDATE_TLBS_PASID(pasid) |\n\t\t\t  PACKET3_INVALIDATE_TLBS_FLUSH_TYPE(flush_type));\n}\n\nstatic void gfx_v11_0_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\t unsigned vmid, uint64_t pd_addr)\n{\n\tif (ring->is_mes_queue)\n\t\tgfx_v11_0_ring_invalidate_tlbs(ring, 0, 0, false, 0);\n\telse\n\t\tamdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\t \n\tif (ring->funcs->type == AMDGPU_RING_TYPE_GFX) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tamdgpu_ring_write(ring, 0x0);\n\t}\n}\n\nstatic void gfx_v11_0_ring_emit_fence_kiq(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t\t  u64 seq, unsigned int flags)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\tBUG_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t WRITE_DATA_DST_SEL(5) | WR_CONFIRM));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\n\tif (flags & AMDGPU_FENCE_FLAG_INT) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\t\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t\t WRITE_DATA_DST_SEL(0) | WR_CONFIRM));\n\t\tamdgpu_ring_write(ring, SOC15_REG_OFFSET(GC, 0, regCPC_INT_STATUS));\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring, 0x20000000);  \n\t}\n}\n\nstatic void gfx_v11_0_ring_emit_cntxcntl(struct amdgpu_ring *ring,\n\t\t\t\t\t uint32_t flags)\n{\n\tuint32_t dw2 = 0;\n\n\tdw2 |= 0x80000000;  \n\tif (flags & AMDGPU_HAVE_CTX_SWITCH) {\n\t\t \n\t\tdw2 |= 0x8001;\n\t\t \n\t\tdw2 |= 0x01000000;\n\t\t \n\t\tdw2 |= 0x10002;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, dw2);\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic void gfx_v11_0_ring_emit_gfx_shadow(struct amdgpu_ring *ring,\n\t\t\t\t\t   u64 shadow_va, u64 csa_va,\n\t\t\t\t\t   u64 gds_va, bool init_shadow,\n\t\t\t\t\t   int vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (!adev->gfx.cp_gfx_shadow)\n\t\treturn;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_Q_PREEMPTION_MODE, 7));\n\tamdgpu_ring_write(ring, lower_32_bits(shadow_va));\n\tamdgpu_ring_write(ring, upper_32_bits(shadow_va));\n\tamdgpu_ring_write(ring, lower_32_bits(gds_va));\n\tamdgpu_ring_write(ring, upper_32_bits(gds_va));\n\tamdgpu_ring_write(ring, lower_32_bits(csa_va));\n\tamdgpu_ring_write(ring, upper_32_bits(csa_va));\n\tamdgpu_ring_write(ring, shadow_va ?\n\t\t\t  PACKET3_SET_Q_PREEMPTION_MODE_IB_VMID(vmid) : 0);\n\tamdgpu_ring_write(ring, init_shadow ?\n\t\t\t  PACKET3_SET_Q_PREEMPTION_MODE_INIT_SHADOW_MEM : 0);\n}\n\nstatic unsigned gfx_v11_0_ring_emit_init_cond_exec(struct amdgpu_ring *ring)\n{\n\tunsigned ret;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COND_EXEC, 3));\n\tamdgpu_ring_write(ring, lower_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, 0);  \n\tret = ring->wptr & ring->buf_mask;\n\tamdgpu_ring_write(ring, 0x55aa55aa);  \n\n\treturn ret;\n}\n\nstatic void gfx_v11_0_ring_emit_patch_cond_exec(struct amdgpu_ring *ring, unsigned offset)\n{\n\tunsigned cur;\n\tBUG_ON(offset > ring->buf_mask);\n\tBUG_ON(ring->ring[offset] != 0x55aa55aa);\n\n\tcur = (ring->wptr - 1) & ring->buf_mask;\n\tif (likely(cur > offset))\n\t\tring->ring[offset] = cur - offset;\n\telse\n\t\tring->ring[offset] = (ring->buf_mask + 1) - offset + cur;\n}\n\nstatic int gfx_v11_0_ring_preempt_ib(struct amdgpu_ring *ring)\n{\n\tint i, r = 0;\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[0];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tunsigned long flags;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&kiq->ring_lock, flags);\n\n\tif (amdgpu_ring_alloc(kiq_ring, kiq->pmf->unmap_queues_size)) {\n\t\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tamdgpu_ring_set_preempt_cond_exec(ring, false);\n\n\t \n\tkiq->pmf->kiq_unmap_queues(kiq_ring, ring, PREEMPT_QUEUES_NO_UNMAP,\n\t\t\t\t   ring->trail_fence_gpu_addr,\n\t\t\t\t   ++ring->trail_seq);\n\tamdgpu_ring_commit(kiq_ring);\n\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\n\t \n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (ring->trail_seq ==\n\t\t    le32_to_cpu(*(ring->trail_fence_cpu_addr)))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout) {\n\t\tr = -EINVAL;\n\t\tDRM_ERROR(\"ring %d failed to preempt ib\\n\", ring->idx);\n\t}\n\n\t \n\tamdgpu_ring_set_preempt_cond_exec(ring, true);\n\treturn r;\n}\n\nstatic void gfx_v11_0_ring_emit_de_meta(struct amdgpu_ring *ring, bool resume)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v10_de_ib_state de_payload = {0};\n\tuint64_t offset, gds_addr, de_payload_gpu_addr;\n\tvoid *de_payload_cpu_addr;\n\tint cnt;\n\n\tif (ring->is_mes_queue) {\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  gfx[0].gfx_meta_data) +\n\t\t\toffsetof(struct v10_gfx_meta_data, de_payload);\n\t\tde_payload_gpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tde_payload_cpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  gfx[0].gds_backup) +\n\t\t\toffsetof(struct v10_gfx_meta_data, de_payload);\n\t\tgds_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t} else {\n\t\toffset = offsetof(struct v10_gfx_meta_data, de_payload);\n\t\tde_payload_gpu_addr = amdgpu_csa_vaddr(ring->adev) + offset;\n\t\tde_payload_cpu_addr = adev->virt.csa_cpu_addr + offset;\n\n\t\tgds_addr = ALIGN(amdgpu_csa_vaddr(ring->adev) +\n\t\t\t\t AMDGPU_CSA_SIZE - adev->gds.gds_size,\n\t\t\t\t PAGE_SIZE);\n\t}\n\n\tde_payload.gds_backup_addrlo = lower_32_bits(gds_addr);\n\tde_payload.gds_backup_addrhi = upper_32_bits(gds_addr);\n\n\tcnt = (sizeof(de_payload) >> 2) + 4 - 2;\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, cnt));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\t WRITE_DATA_DST_SEL(8) |\n\t\t\t\t WR_CONFIRM) |\n\t\t\t\t WRITE_DATA_CACHE_POLICY(0));\n\tamdgpu_ring_write(ring, lower_32_bits(de_payload_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(de_payload_gpu_addr));\n\n\tif (resume)\n\t\tamdgpu_ring_write_multiple(ring, de_payload_cpu_addr,\n\t\t\t\t\t   sizeof(de_payload) >> 2);\n\telse\n\t\tamdgpu_ring_write_multiple(ring, (void *)&de_payload,\n\t\t\t\t\t   sizeof(de_payload) >> 2);\n}\n\nstatic void gfx_v11_0_ring_emit_frame_cntl(struct amdgpu_ring *ring, bool start,\n\t\t\t\t    bool secure)\n{\n\tuint32_t v = secure ? FRAME_TMZ : 0;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_FRAME_CONTROL, 0));\n\tamdgpu_ring_write(ring, v | FRAME_CMD(start ? 0 : 1));\n}\n\nstatic void gfx_v11_0_ring_emit_rreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t     uint32_t reg_val_offs)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COPY_DATA, 4));\n\tamdgpu_ring_write(ring, 0 |\t \n\t\t\t\t(5 << 8) |\t \n\t\t\t\t(1 << 20));\t \n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, lower_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n\tamdgpu_ring_write(ring, upper_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n}\n\nstatic void gfx_v11_0_ring_emit_wreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t   uint32_t val)\n{\n\tuint32_t cmd = 0;\n\n\tswitch (ring->funcs->type) {\n\tcase AMDGPU_RING_TYPE_GFX:\n\t\tcmd = WRITE_DATA_ENGINE_SEL(1) | WR_CONFIRM;\n\t\tbreak;\n\tcase AMDGPU_RING_TYPE_KIQ:\n\t\tcmd = (1 << 16);  \n\t\tbreak;\n\tdefault:\n\t\tcmd = WR_CONFIRM;\n\t\tbreak;\n\t}\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, cmd);\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void gfx_v11_0_ring_emit_reg_wait(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t\tuint32_t val, uint32_t mask)\n{\n\tgfx_v11_0_wait_reg_mem(ring, 0, 0, 0, reg, 0, val, mask, 0x20);\n}\n\nstatic void gfx_v11_0_ring_emit_reg_write_reg_wait(struct amdgpu_ring *ring,\n\t\t\t\t\t\t   uint32_t reg0, uint32_t reg1,\n\t\t\t\t\t\t   uint32_t ref, uint32_t mask)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\n\tgfx_v11_0_wait_reg_mem(ring, usepfp, 0, 1, reg0, reg1,\n\t\t\t       ref, mask, 0x20);\n}\n\nstatic void gfx_v11_0_ring_soft_recovery(struct amdgpu_ring *ring,\n\t\t\t\t\t unsigned vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t value = 0;\n\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CMD, 0x03);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, MODE, 0x01);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CHECK_VMID, 1);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, VM_ID, vmid);\n\tWREG32_SOC15(GC, 0, regSQ_CMD, value);\n}\n\nstatic void\ngfx_v11_0_set_gfx_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t      uint32_t me, uint32_t pipe,\n\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tuint32_t cp_int_cntl, cp_int_cntl_reg;\n\n\tif (!me) {\n\t\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tcp_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_INT_CNTL_RING0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcp_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_INT_CNTL_RING1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"invalid me %d\\n\", me);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tcp_int_cntl = RREG32_SOC15_IP(GC, cp_int_cntl_reg);\n\t\tcp_int_cntl = REG_SET_FIELD(cp_int_cntl, CP_INT_CNTL_RING0,\n\t\t\t\t\t    TIME_STAMP_INT_ENABLE, 0);\n\t\tcp_int_cntl = REG_SET_FIELD(cp_int_cntl, CP_INT_CNTL_RING0,\n\t\t\t\t\t    GENERIC0_INT_ENABLE, 0);\n\t\tWREG32_SOC15_IP(GC, cp_int_cntl_reg, cp_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tcp_int_cntl = RREG32_SOC15_IP(GC, cp_int_cntl_reg);\n\t\tcp_int_cntl = REG_SET_FIELD(cp_int_cntl, CP_INT_CNTL_RING0,\n\t\t\t\t\t    TIME_STAMP_INT_ENABLE, 1);\n\t\tcp_int_cntl = REG_SET_FIELD(cp_int_cntl, CP_INT_CNTL_RING0,\n\t\t\t\t\t    GENERIC0_INT_ENABLE, 1);\n\t\tWREG32_SOC15_IP(GC, cp_int_cntl_reg, cp_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v11_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     int me, int pipe,\n\t\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tu32 mec_int_cntl, mec_int_cntl_reg;\n\n\t \n\n\tif (me == 1) {\n\t\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_ME1_PIPE0_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_ME1_PIPE1_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_ME1_PIPE2_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, regCP_ME1_PIPE3_INT_CNTL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"invalid me %d\\n\", me);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tmec_int_cntl = RREG32_SOC15_IP(GC, mec_int_cntl_reg);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     TIME_STAMP_INT_ENABLE, 0);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     GENERIC0_INT_ENABLE, 0);\n\t\tWREG32_SOC15_IP(GC, mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tmec_int_cntl = RREG32_SOC15_IP(GC, mec_int_cntl_reg);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     TIME_STAMP_INT_ENABLE, 1);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     GENERIC0_INT_ENABLE, 1);\n\t\tWREG32_SOC15_IP(GC, mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v11_0_set_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_irq_src *src,\n\t\t\t\t\t    unsigned type,\n\t\t\t\t\t    enum amdgpu_interrupt_state state)\n{\n\tswitch (type) {\n\tcase AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP:\n\t\tgfx_v11_0_set_gfx_eop_interrupt_state(adev, 0, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_GFX_ME0_PIPE1_EOP:\n\t\tgfx_v11_0_set_gfx_eop_interrupt_state(adev, 0, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP:\n\t\tgfx_v11_0_set_compute_eop_interrupt_state(adev, 1, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE1_EOP:\n\t\tgfx_v11_0_set_compute_eop_interrupt_state(adev, 1, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE2_EOP:\n\t\tgfx_v11_0_set_compute_eop_interrupt_state(adev, 1, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE3_EOP:\n\t\tgfx_v11_0_set_compute_eop_interrupt_state(adev, 1, 3, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v11_0_eop_irq(struct amdgpu_device *adev,\n\t\t\t     struct amdgpu_irq_src *source,\n\t\t\t     struct amdgpu_iv_entry *entry)\n{\n\tint i;\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\tuint32_t mes_queue_id = entry->src_data[0];\n\n\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\n\tif (adev->enable_mes && (mes_queue_id & AMDGPU_FENCE_MES_QUEUE_FLAG)) {\n\t\tstruct amdgpu_mes_queue *queue;\n\n\t\tmes_queue_id &= AMDGPU_FENCE_MES_QUEUE_ID_MASK;\n\n\t\tspin_lock(&adev->mes.queue_id_lock);\n\t\tqueue = idr_find(&adev->mes.queue_id_idr, mes_queue_id);\n\t\tif (queue) {\n\t\t\tDRM_DEBUG(\"process mes queue id = %d\\n\", mes_queue_id);\n\t\t\tamdgpu_fence_process(queue->ring);\n\t\t}\n\t\tspin_unlock(&adev->mes.queue_id_lock);\n\t} else {\n\t\tme_id = (entry->ring_id & 0x0c) >> 2;\n\t\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\t\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\t\tswitch (me_id) {\n\t\tcase 0:\n\t\t\tif (pipe_id == 0)\n\t\t\t\tamdgpu_fence_process(&adev->gfx.gfx_ring[0]);\n\t\t\telse\n\t\t\t\tamdgpu_fence_process(&adev->gfx.gfx_ring[1]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\t\t \n\t\t\t\tif ((ring->me == me_id) &&\n\t\t\t\t    (ring->pipe == pipe_id) &&\n\t\t\t\t    (ring->queue == queue_id))\n\t\t\t\t\tamdgpu_fence_process(ring);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_set_priv_reg_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t\t      unsigned type,\n\t\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15_PREREG(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t       PRIV_REG_INT_ENABLE,\n\t\t\t       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v11_0_set_priv_inst_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t       struct amdgpu_irq_src *source,\n\t\t\t\t\t       unsigned type,\n\t\t\t\t\t       enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15_PREREG(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t       PRIV_INSTR_INT_ENABLE,\n\t\t\t       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v11_0_handle_priv_fault(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_iv_entry *entry)\n{\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\tint i;\n\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\tswitch (me_id) {\n\tcase 0:\n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\t\tring = &adev->gfx.gfx_ring[i];\n\t\t\t \n\t\t\tif (ring->me == me_id && ring->pipe == pipe_id)\n\t\t\t\tdrm_sched_fault(&ring->sched);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\tif (ring->me == me_id && ring->pipe == pipe_id &&\n\t\t\t    ring->queue == queue_id)\n\t\t\t\tdrm_sched_fault(&ring->sched);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v11_0_priv_reg_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal register access in command stream\\n\");\n\tgfx_v11_0_handle_priv_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v11_0_priv_inst_irq(struct amdgpu_device *adev,\n\t\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal instruction in command stream\\n\");\n\tgfx_v11_0_handle_priv_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v11_0_rlc_gc_fed_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tif (adev->gfx.ras && adev->gfx.ras->rlc_gc_fed_irq)\n\t\treturn adev->gfx.ras->rlc_gc_fed_irq(adev, source, entry);\n\n\treturn 0;\n}\n\n#if 0\nstatic int gfx_v11_0_kiq_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t     struct amdgpu_irq_src *src,\n\t\t\t\t\t     unsigned int type,\n\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tuint32_t tmp, target;\n\tstruct amdgpu_ring *ring = &(adev->gfx.kiq[0].ring);\n\n\ttarget = SOC15_REG_OFFSET(GC, 0, regCP_ME1_PIPE0_INT_CNTL);\n\ttarget += ring->pipe;\n\n\tswitch (type) {\n\tcase AMDGPU_CP_KIQ_IRQ_DRIVER0:\n\t\tif (state == AMDGPU_IRQ_STATE_DISABLE) {\n\t\t\ttmp = RREG32_SOC15(GC, 0, regCPC_INT_CNTL);\n\t\t\ttmp = REG_SET_FIELD(tmp, CPC_INT_CNTL,\n\t\t\t\t\t    GENERIC2_INT_ENABLE, 0);\n\t\t\tWREG32_SOC15(GC, 0, regCPC_INT_CNTL, tmp);\n\n\t\t\ttmp = RREG32_SOC15_IP(GC, target);\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t    GENERIC2_INT_ENABLE, 0);\n\t\t\tWREG32_SOC15_IP(GC, target, tmp);\n\t\t} else {\n\t\t\ttmp = RREG32_SOC15(GC, 0, regCPC_INT_CNTL);\n\t\t\ttmp = REG_SET_FIELD(tmp, CPC_INT_CNTL,\n\t\t\t\t\t    GENERIC2_INT_ENABLE, 1);\n\t\t\tWREG32_SOC15(GC, 0, regCPC_INT_CNTL, tmp);\n\n\t\t\ttmp = RREG32_SOC15_IP(GC, target);\n\t\t\ttmp = REG_SET_FIELD(tmp, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t    GENERIC2_INT_ENABLE, 1);\n\t\t\tWREG32_SOC15_IP(GC, target, tmp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();  \n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void gfx_v11_0_emit_mem_sync(struct amdgpu_ring *ring)\n{\n\tconst unsigned int gcr_cntl =\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GL2_INV(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GL2_WB(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GLM_INV(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GLM_WB(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GL1_INV(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GLV_INV(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GLK_INV(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_GCR_CNTL_GLI_INV(1);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_ACQUIRE_MEM, 6));\n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0xffffffff);   \n\tamdgpu_ring_write(ring, 0xffffff);   \n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0);   \n\tamdgpu_ring_write(ring, 0x0000000A);  \n\tamdgpu_ring_write(ring, gcr_cntl);  \n}\n\nstatic const struct amd_ip_funcs gfx_v11_0_ip_funcs = {\n\t.name = \"gfx_v11_0\",\n\t.early_init = gfx_v11_0_early_init,\n\t.late_init = gfx_v11_0_late_init,\n\t.sw_init = gfx_v11_0_sw_init,\n\t.sw_fini = gfx_v11_0_sw_fini,\n\t.hw_init = gfx_v11_0_hw_init,\n\t.hw_fini = gfx_v11_0_hw_fini,\n\t.suspend = gfx_v11_0_suspend,\n\t.resume = gfx_v11_0_resume,\n\t.is_idle = gfx_v11_0_is_idle,\n\t.wait_for_idle = gfx_v11_0_wait_for_idle,\n\t.soft_reset = gfx_v11_0_soft_reset,\n\t.check_soft_reset = gfx_v11_0_check_soft_reset,\n\t.post_soft_reset = gfx_v11_0_post_soft_reset,\n\t.set_clockgating_state = gfx_v11_0_set_clockgating_state,\n\t.set_powergating_state = gfx_v11_0_set_powergating_state,\n\t.get_clockgating_state = gfx_v11_0_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v11_0_ring_funcs_gfx = {\n\t.type = AMDGPU_RING_TYPE_GFX,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.secure_submission_supported = true,\n\t.get_rptr = gfx_v11_0_ring_get_rptr_gfx,\n\t.get_wptr = gfx_v11_0_ring_get_wptr_gfx,\n\t.set_wptr = gfx_v11_0_ring_set_wptr_gfx,\n\t.emit_frame_size =  \n\t\t5 +  \n\t\t9 +  \n\t\t7 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 +  \n\t\t20 +  \n\t\t5 +  \n\t\t7 +  \n\t\t4 +  \n\t\t31 +  \n\t\t3 +  \n\t\t5 +  \n\t\t8 + 8 +  \n\t\t8,  \n\t.emit_ib_size =\t4,  \n\t.emit_ib = gfx_v11_0_ring_emit_ib_gfx,\n\t.emit_fence = gfx_v11_0_ring_emit_fence,\n\t.emit_pipeline_sync = gfx_v11_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v11_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v11_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v11_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v11_0_ring_test_ring,\n\t.test_ib = gfx_v11_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_cntxcntl = gfx_v11_0_ring_emit_cntxcntl,\n\t.emit_gfx_shadow = gfx_v11_0_ring_emit_gfx_shadow,\n\t.init_cond_exec = gfx_v11_0_ring_emit_init_cond_exec,\n\t.patch_cond_exec = gfx_v11_0_ring_emit_patch_cond_exec,\n\t.preempt_ib = gfx_v11_0_ring_preempt_ib,\n\t.emit_frame_cntl = gfx_v11_0_ring_emit_frame_cntl,\n\t.emit_wreg = gfx_v11_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v11_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v11_0_ring_emit_reg_write_reg_wait,\n\t.soft_recovery = gfx_v11_0_ring_soft_recovery,\n\t.emit_mem_sync = gfx_v11_0_emit_mem_sync,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v11_0_ring_funcs_compute = {\n\t.type = AMDGPU_RING_TYPE_COMPUTE,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.get_rptr = gfx_v11_0_ring_get_rptr_compute,\n\t.get_wptr = gfx_v11_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v11_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 + 8 + 8 +  \n\t\t8,  \n\t.emit_ib_size =\t7,  \n\t.emit_ib = gfx_v11_0_ring_emit_ib_compute,\n\t.emit_fence = gfx_v11_0_ring_emit_fence,\n\t.emit_pipeline_sync = gfx_v11_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v11_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v11_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v11_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v11_0_ring_test_ring,\n\t.test_ib = gfx_v11_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_wreg = gfx_v11_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v11_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v11_0_ring_emit_reg_write_reg_wait,\n\t.emit_mem_sync = gfx_v11_0_emit_mem_sync,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v11_0_ring_funcs_kiq = {\n\t.type = AMDGPU_RING_TYPE_KIQ,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.get_rptr = gfx_v11_0_ring_get_rptr_compute,\n\t.get_wptr = gfx_v11_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v11_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 + 8 + 8,  \n\t.emit_ib_size =\t7,  \n\t.emit_ib = gfx_v11_0_ring_emit_ib_compute,\n\t.emit_fence = gfx_v11_0_ring_emit_fence_kiq,\n\t.test_ring = gfx_v11_0_ring_test_ring,\n\t.test_ib = gfx_v11_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_rreg = gfx_v11_0_ring_emit_rreg,\n\t.emit_wreg = gfx_v11_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v11_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v11_0_ring_emit_reg_write_reg_wait,\n};\n\nstatic void gfx_v11_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tadev->gfx.kiq[0].ring.funcs = &gfx_v11_0_ring_funcs_kiq;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tadev->gfx.gfx_ring[i].funcs = &gfx_v11_0_ring_funcs_gfx;\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tadev->gfx.compute_ring[i].funcs = &gfx_v11_0_ring_funcs_compute;\n}\n\nstatic const struct amdgpu_irq_src_funcs gfx_v11_0_eop_irq_funcs = {\n\t.set = gfx_v11_0_set_eop_interrupt_state,\n\t.process = gfx_v11_0_eop_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v11_0_priv_reg_irq_funcs = {\n\t.set = gfx_v11_0_set_priv_reg_fault_state,\n\t.process = gfx_v11_0_priv_reg_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v11_0_priv_inst_irq_funcs = {\n\t.set = gfx_v11_0_set_priv_inst_fault_state,\n\t.process = gfx_v11_0_priv_inst_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v11_0_rlc_gc_fed_irq_funcs = {\n\t.process = gfx_v11_0_rlc_gc_fed_irq,\n};\n\nstatic void gfx_v11_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.eop_irq.num_types = AMDGPU_CP_IRQ_LAST;\n\tadev->gfx.eop_irq.funcs = &gfx_v11_0_eop_irq_funcs;\n\n\tadev->gfx.priv_reg_irq.num_types = 1;\n\tadev->gfx.priv_reg_irq.funcs = &gfx_v11_0_priv_reg_irq_funcs;\n\n\tadev->gfx.priv_inst_irq.num_types = 1;\n\tadev->gfx.priv_inst_irq.funcs = &gfx_v11_0_priv_inst_irq_funcs;\n\n\tadev->gfx.rlc_gc_fed_irq.num_types = 1;  \n\tadev->gfx.rlc_gc_fed_irq.funcs = &gfx_v11_0_rlc_gc_fed_irq_funcs;\n\n}\n\nstatic void gfx_v11_0_set_imu_funcs(struct amdgpu_device *adev)\n{\n\tif (adev->flags & AMD_IS_APU)\n\t\tadev->gfx.imu.mode = MISSION_MODE;\n\telse\n\t\tadev->gfx.imu.mode = DEBUG_MODE;\n\n\tadev->gfx.imu.funcs = &gfx_v11_0_imu_funcs;\n}\n\nstatic void gfx_v11_0_set_rlc_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.rlc.funcs = &gfx_v11_0_rlc_funcs;\n}\n\nstatic void gfx_v11_0_set_gds_init(struct amdgpu_device *adev)\n{\n\tunsigned total_cu = adev->gfx.config.max_cu_per_sh *\n\t\t\t    adev->gfx.config.max_sh_per_se *\n\t\t\t    adev->gfx.config.max_shader_engines;\n\n\tadev->gds.gds_size = 0x1000;\n\tadev->gds.gds_compute_max_wave_id = total_cu * 32 - 1;\n\tadev->gds.gws_size = 64;\n\tadev->gds.oa_size = 16;\n}\n\nstatic void gfx_v11_0_set_mqd_funcs(struct amdgpu_device *adev)\n{\n\t \n\tadev->mqds[AMDGPU_HW_IP_GFX].mqd_size =\n\t\tsizeof(struct v11_gfx_mqd);\n\tadev->mqds[AMDGPU_HW_IP_GFX].init_mqd =\n\t\tgfx_v11_0_gfx_mqd_init;\n\t \n\tadev->mqds[AMDGPU_HW_IP_COMPUTE].mqd_size =\n\t\tsizeof(struct v11_compute_mqd);\n\tadev->mqds[AMDGPU_HW_IP_COMPUTE].init_mqd =\n\t\tgfx_v11_0_compute_mqd_init;\n}\n\nstatic void gfx_v11_0_set_user_wgp_inactive_bitmap_per_sh(struct amdgpu_device *adev,\n\t\t\t\t\t\t\t  u32 bitmap)\n{\n\tu32 data;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tdata = bitmap << GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_WGPS__SHIFT;\n\tdata &= GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_WGPS_MASK;\n\n\tWREG32_SOC15(GC, 0, regGC_USER_SHADER_ARRAY_CONFIG, data);\n}\n\nstatic u32 gfx_v11_0_get_wgp_active_bitmap_per_sh(struct amdgpu_device *adev)\n{\n\tu32 data, wgp_bitmask;\n\tdata = RREG32_SOC15(GC, 0, regCC_GC_SHADER_ARRAY_CONFIG);\n\tdata |= RREG32_SOC15(GC, 0, regGC_USER_SHADER_ARRAY_CONFIG);\n\n\tdata &= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_WGPS_MASK;\n\tdata >>= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_WGPS__SHIFT;\n\n\twgp_bitmask =\n\t\tamdgpu_gfx_create_bitmask(adev->gfx.config.max_cu_per_sh >> 1);\n\n\treturn (~data) & wgp_bitmask;\n}\n\nstatic u32 gfx_v11_0_get_cu_active_bitmap_per_sh(struct amdgpu_device *adev)\n{\n\tu32 wgp_idx, wgp_active_bitmap;\n\tu32 cu_bitmap_per_wgp, cu_active_bitmap;\n\n\twgp_active_bitmap = gfx_v11_0_get_wgp_active_bitmap_per_sh(adev);\n\tcu_active_bitmap = 0;\n\n\tfor (wgp_idx = 0; wgp_idx < 16; wgp_idx++) {\n\t\t \n\t\tcu_bitmap_per_wgp = 3 << (2 * wgp_idx);\n\t\tif (wgp_active_bitmap & (1 << wgp_idx))\n\t\t\tcu_active_bitmap |= cu_bitmap_per_wgp;\n\t}\n\n\treturn cu_active_bitmap;\n}\n\nstatic int gfx_v11_0_get_cu_info(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_cu_info *cu_info)\n{\n\tint i, j, k, counter, active_cu_number = 0;\n\tu32 mask, bitmap;\n\tunsigned disable_masks[8 * 2];\n\n\tif (!adev || !cu_info)\n\t\treturn -EINVAL;\n\n\tamdgpu_gfx_parse_disable_cu(disable_masks, 8, 2);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tcounter = 0;\n\t\t\tgfx_v11_0_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tif (i < 8 && j < 2)\n\t\t\t\tgfx_v11_0_set_user_wgp_inactive_bitmap_per_sh(\n\t\t\t\t\tadev, disable_masks[i * 2 + j]);\n\t\t\tbitmap = gfx_v11_0_get_cu_active_bitmap_per_sh(adev);\n\n\t\t\t \n\t\t\tcu_info->bitmap[0][i % 4][j + (i / 4) * 2] = bitmap;\n\n\t\t\tfor (k = 0; k < adev->gfx.config.max_cu_per_sh; k++) {\n\t\t\t\tif (bitmap & mask)\n\t\t\t\t\tcounter++;\n\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\t\t\tactive_cu_number += counter;\n\t\t}\n\t}\n\tgfx_v11_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tcu_info->number = active_cu_number;\n\tcu_info->simd_per_cu = NUM_SIMD_PER_CU;\n\n\treturn 0;\n}\n\nconst struct amdgpu_ip_block_version gfx_v11_0_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 11,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &gfx_v11_0_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}