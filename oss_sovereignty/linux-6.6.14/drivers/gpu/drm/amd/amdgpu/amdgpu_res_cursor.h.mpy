{
  "module_name": "amdgpu_res_cursor.h",
  "hash_id": "d305cb4a9170115ba51b353cd0c1f243ad58fb46be57adda0e4bf81efe08a9ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_res_cursor.h",
  "human_readable_source": "\n \n\n#ifndef __AMDGPU_RES_CURSOR_H__\n#define __AMDGPU_RES_CURSOR_H__\n\n#include <drm/drm_mm.h>\n#include <drm/ttm/ttm_resource.h>\n#include <drm/ttm/ttm_range_manager.h>\n\n#include \"amdgpu_vram_mgr.h\"\n\n \nstruct amdgpu_res_cursor {\n\tuint64_t\t\tstart;\n\tuint64_t\t\tsize;\n\tuint64_t\t\tremaining;\n\tvoid\t\t\t*node;\n\tuint32_t\t\tmem_type;\n};\n\n \nstatic inline void amdgpu_res_first(struct ttm_resource *res,\n\t\t\t\t    uint64_t start, uint64_t size,\n\t\t\t\t    struct amdgpu_res_cursor *cur)\n{\n\tstruct drm_buddy_block *block;\n\tstruct list_head *head, *next;\n\tstruct drm_mm_node *node;\n\n\tif (!res)\n\t\tgoto fallback;\n\n\tBUG_ON(start + size > res->size);\n\n\tcur->mem_type = res->mem_type;\n\n\tswitch (cur->mem_type) {\n\tcase TTM_PL_VRAM:\n\t\thead = &to_amdgpu_vram_mgr_resource(res)->blocks;\n\n\t\tblock = list_first_entry_or_null(head,\n\t\t\t\t\t\t struct drm_buddy_block,\n\t\t\t\t\t\t link);\n\t\tif (!block)\n\t\t\tgoto fallback;\n\n\t\twhile (start >= amdgpu_vram_mgr_block_size(block)) {\n\t\t\tstart -= amdgpu_vram_mgr_block_size(block);\n\n\t\t\tnext = block->link.next;\n\t\t\tif (next != head)\n\t\t\t\tblock = list_entry(next, struct drm_buddy_block, link);\n\t\t}\n\n\t\tcur->start = amdgpu_vram_mgr_block_start(block) + start;\n\t\tcur->size = min(amdgpu_vram_mgr_block_size(block) - start, size);\n\t\tcur->remaining = size;\n\t\tcur->node = block;\n\t\tbreak;\n\tcase TTM_PL_TT:\n\tcase AMDGPU_PL_DOORBELL:\n\t\tnode = to_ttm_range_mgr_node(res)->mm_nodes;\n\t\twhile (start >= node->size << PAGE_SHIFT)\n\t\t\tstart -= node++->size << PAGE_SHIFT;\n\n\t\tcur->start = (node->start << PAGE_SHIFT) + start;\n\t\tcur->size = min((node->size << PAGE_SHIFT) - start, size);\n\t\tcur->remaining = size;\n\t\tcur->node = node;\n\t\tbreak;\n\tdefault:\n\t\tgoto fallback;\n\t}\n\n\treturn;\n\nfallback:\n\tcur->start = start;\n\tcur->size = size;\n\tcur->remaining = size;\n\tcur->node = NULL;\n\tWARN_ON(res && start + size > res->size);\n\treturn;\n}\n\n \nstatic inline void amdgpu_res_next(struct amdgpu_res_cursor *cur, uint64_t size)\n{\n\tstruct drm_buddy_block *block;\n\tstruct drm_mm_node *node;\n\tstruct list_head *next;\n\n\tBUG_ON(size > cur->remaining);\n\n\tcur->remaining -= size;\n\tif (!cur->remaining)\n\t\treturn;\n\n\tcur->size -= size;\n\tif (cur->size) {\n\t\tcur->start += size;\n\t\treturn;\n\t}\n\n\tswitch (cur->mem_type) {\n\tcase TTM_PL_VRAM:\n\t\tblock = cur->node;\n\n\t\tnext = block->link.next;\n\t\tblock = list_entry(next, struct drm_buddy_block, link);\n\n\t\tcur->node = block;\n\t\tcur->start = amdgpu_vram_mgr_block_start(block);\n\t\tcur->size = min(amdgpu_vram_mgr_block_size(block), cur->remaining);\n\t\tbreak;\n\tcase TTM_PL_TT:\n\tcase AMDGPU_PL_DOORBELL:\n\t\tnode = cur->node;\n\n\t\tcur->node = ++node;\n\t\tcur->start = node->start << PAGE_SHIFT;\n\t\tcur->size = min(node->size << PAGE_SHIFT, cur->remaining);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}