{
  "module_name": "amdgpu_gfx.c",
  "hash_id": "4c6aa8a4210fc2747509abf5feb0f96ac09107de010d6bd00a92ba0a3258212e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"amdgpu_rlc.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_xcp.h\"\n\n \n#define GFX_OFF_DELAY_ENABLE         msecs_to_jiffies(100)\n\n#define GFX_OFF_NO_DELAY 0\n\n \n\nint amdgpu_gfx_mec_queue_to_bit(struct amdgpu_device *adev, int mec,\n\t\t\t\tint pipe, int queue)\n{\n\tint bit = 0;\n\n\tbit += mec * adev->gfx.mec.num_pipe_per_mec\n\t\t* adev->gfx.mec.num_queue_per_pipe;\n\tbit += pipe * adev->gfx.mec.num_queue_per_pipe;\n\tbit += queue;\n\n\treturn bit;\n}\n\nvoid amdgpu_queue_mask_bit_to_mec_queue(struct amdgpu_device *adev, int bit,\n\t\t\t\t int *mec, int *pipe, int *queue)\n{\n\t*queue = bit % adev->gfx.mec.num_queue_per_pipe;\n\t*pipe = (bit / adev->gfx.mec.num_queue_per_pipe)\n\t\t% adev->gfx.mec.num_pipe_per_mec;\n\t*mec = (bit / adev->gfx.mec.num_queue_per_pipe)\n\t       / adev->gfx.mec.num_pipe_per_mec;\n\n}\n\nbool amdgpu_gfx_is_mec_queue_enabled(struct amdgpu_device *adev,\n\t\t\t\t     int xcc_id, int mec, int pipe, int queue)\n{\n\treturn test_bit(amdgpu_gfx_mec_queue_to_bit(adev, mec, pipe, queue),\n\t\t\tadev->gfx.mec_bitmap[xcc_id].queue_bitmap);\n}\n\nint amdgpu_gfx_me_queue_to_bit(struct amdgpu_device *adev,\n\t\t\t       int me, int pipe, int queue)\n{\n\tint bit = 0;\n\n\tbit += me * adev->gfx.me.num_pipe_per_me\n\t\t* adev->gfx.me.num_queue_per_pipe;\n\tbit += pipe * adev->gfx.me.num_queue_per_pipe;\n\tbit += queue;\n\n\treturn bit;\n}\n\nvoid amdgpu_gfx_bit_to_me_queue(struct amdgpu_device *adev, int bit,\n\t\t\t\tint *me, int *pipe, int *queue)\n{\n\t*queue = bit % adev->gfx.me.num_queue_per_pipe;\n\t*pipe = (bit / adev->gfx.me.num_queue_per_pipe)\n\t\t% adev->gfx.me.num_pipe_per_me;\n\t*me = (bit / adev->gfx.me.num_queue_per_pipe)\n\t\t/ adev->gfx.me.num_pipe_per_me;\n}\n\nbool amdgpu_gfx_is_me_queue_enabled(struct amdgpu_device *adev,\n\t\t\t\t    int me, int pipe, int queue)\n{\n\treturn test_bit(amdgpu_gfx_me_queue_to_bit(adev, me, pipe, queue),\n\t\t\tadev->gfx.me.queue_bitmap);\n}\n\n \nvoid amdgpu_gfx_parse_disable_cu(unsigned int *mask, unsigned int max_se, unsigned int max_sh)\n{\n\tunsigned int se, sh, cu;\n\tconst char *p;\n\n\tmemset(mask, 0, sizeof(*mask) * max_se * max_sh);\n\n\tif (!amdgpu_disable_cu || !*amdgpu_disable_cu)\n\t\treturn;\n\n\tp = amdgpu_disable_cu;\n\tfor (;;) {\n\t\tchar *next;\n\t\tint ret = sscanf(p, \"%u.%u.%u\", &se, &sh, &cu);\n\n\t\tif (ret < 3) {\n\t\t\tDRM_ERROR(\"amdgpu: could not parse disable_cu\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (se < max_se && sh < max_sh && cu < 16) {\n\t\t\tDRM_INFO(\"amdgpu: disabling CU %u.%u.%u\\n\", se, sh, cu);\n\t\t\tmask[se * max_sh + sh] |= 1u << cu;\n\t\t} else {\n\t\t\tDRM_ERROR(\"amdgpu: disable_cu %u.%u.%u is out of range\\n\",\n\t\t\t\t  se, sh, cu);\n\t\t}\n\n\t\tnext = strchr(p, ',');\n\t\tif (!next)\n\t\t\tbreak;\n\t\tp = next + 1;\n\t}\n}\n\nstatic bool amdgpu_gfx_is_graphics_multipipe_capable(struct amdgpu_device *adev)\n{\n\treturn amdgpu_async_gfx_ring && adev->gfx.me.num_pipe_per_me > 1;\n}\n\nstatic bool amdgpu_gfx_is_compute_multipipe_capable(struct amdgpu_device *adev)\n{\n\tif (amdgpu_compute_multipipe != -1) {\n\t\tDRM_INFO(\"amdgpu: forcing compute pipe policy %d\\n\",\n\t\t\t amdgpu_compute_multipipe);\n\t\treturn amdgpu_compute_multipipe == 1;\n\t}\n\n\tif (adev->ip_versions[GC_HWIP][0] > IP_VERSION(9, 0, 0))\n\t\treturn true;\n\n\t \n\tif (adev->asic_type == CHIP_POLARIS11)\n\t\treturn false;\n\n\treturn adev->gfx.mec.num_mec > 1;\n}\n\nbool amdgpu_gfx_is_high_priority_graphics_queue(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amdgpu_ring *ring)\n{\n\tint queue = ring->queue;\n\tint pipe = ring->pipe;\n\n\t \n\tif (amdgpu_gfx_is_graphics_multipipe_capable(adev) &&\n\t    adev->gfx.num_gfx_rings > 1 && pipe == 1 && queue == 0) {\n\t\tint me = ring->me;\n\t\tint bit;\n\n\t\tbit = amdgpu_gfx_me_queue_to_bit(adev, me, pipe, queue);\n\t\tif (ring == &adev->gfx.gfx_ring[bit])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool amdgpu_gfx_is_high_priority_compute_queue(struct amdgpu_device *adev,\n\t\t\t\t\t       struct amdgpu_ring *ring)\n{\n\t \n\tif (adev->gfx.num_compute_rings > 1 &&\n\t    ring == &adev->gfx.compute_ring[0])\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid amdgpu_gfx_compute_queue_acquire(struct amdgpu_device *adev)\n{\n\tint i, j, queue, pipe;\n\tbool multipipe_policy = amdgpu_gfx_is_compute_multipipe_capable(adev);\n\tint max_queues_per_mec = min(adev->gfx.mec.num_pipe_per_mec *\n\t\t\t\t     adev->gfx.mec.num_queue_per_pipe,\n\t\t\t\t     adev->gfx.num_compute_rings);\n\tint num_xcc = adev->gfx.xcc_mask ? NUM_XCC(adev->gfx.xcc_mask) : 1;\n\n\tif (multipipe_policy) {\n\t\t \n\t\tfor (j = 0; j < num_xcc; j++) {\n\t\t\tfor (i = 0; i < max_queues_per_mec; i++) {\n\t\t\t\tpipe = i % adev->gfx.mec.num_pipe_per_mec;\n\t\t\t\tqueue = (i / adev->gfx.mec.num_pipe_per_mec) %\n\t\t\t\t\t adev->gfx.mec.num_queue_per_pipe;\n\n\t\t\t\tset_bit(pipe * adev->gfx.mec.num_queue_per_pipe + queue,\n\t\t\t\t\tadev->gfx.mec_bitmap[j].queue_bitmap);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (j = 0; j < num_xcc; j++) {\n\t\t\tfor (i = 0; i < max_queues_per_mec; ++i)\n\t\t\t\tset_bit(i, adev->gfx.mec_bitmap[j].queue_bitmap);\n\t\t}\n\t}\n\n\tfor (j = 0; j < num_xcc; j++) {\n\t\tdev_dbg(adev->dev, \"mec queue bitmap weight=%d\\n\",\n\t\t\tbitmap_weight(adev->gfx.mec_bitmap[j].queue_bitmap, AMDGPU_MAX_COMPUTE_QUEUES));\n\t}\n}\n\nvoid amdgpu_gfx_graphics_queue_acquire(struct amdgpu_device *adev)\n{\n\tint i, queue, pipe;\n\tbool multipipe_policy = amdgpu_gfx_is_graphics_multipipe_capable(adev);\n\tint max_queues_per_me = adev->gfx.me.num_pipe_per_me *\n\t\t\t\t\tadev->gfx.me.num_queue_per_pipe;\n\n\tif (multipipe_policy) {\n\t\t \n\t\tfor (i = 0; i < max_queues_per_me; i++) {\n\t\t\tpipe = i % adev->gfx.me.num_pipe_per_me;\n\t\t\tqueue = (i / adev->gfx.me.num_pipe_per_me) %\n\t\t\t\tadev->gfx.me.num_queue_per_pipe;\n\n\t\t\tset_bit(pipe * adev->gfx.me.num_queue_per_pipe + queue,\n\t\t\t\tadev->gfx.me.queue_bitmap);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < max_queues_per_me; ++i)\n\t\t\tset_bit(i, adev->gfx.me.queue_bitmap);\n\t}\n\n\t \n\tadev->gfx.num_gfx_rings =\n\t\tbitmap_weight(adev->gfx.me.queue_bitmap, AMDGPU_MAX_GFX_QUEUES);\n}\n\nstatic int amdgpu_gfx_kiq_acquire(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_ring *ring, int xcc_id)\n{\n\tint queue_bit;\n\tint mec, pipe, queue;\n\n\tqueue_bit = adev->gfx.mec.num_mec\n\t\t    * adev->gfx.mec.num_pipe_per_mec\n\t\t    * adev->gfx.mec.num_queue_per_pipe;\n\n\twhile (--queue_bit >= 0) {\n\t\tif (test_bit(queue_bit, adev->gfx.mec_bitmap[xcc_id].queue_bitmap))\n\t\t\tcontinue;\n\n\t\tamdgpu_queue_mask_bit_to_mec_queue(adev, queue_bit, &mec, &pipe, &queue);\n\n\t\t \n\t\tif ((mec == 1 && pipe > 1) || queue != 0)\n\t\t\tcontinue;\n\n\t\tring->me = mec + 1;\n\t\tring->pipe = pipe;\n\t\tring->queue = queue;\n\n\t\treturn 0;\n\t}\n\n\tdev_err(adev->dev, \"Failed to find a queue for KIQ\\n\");\n\treturn -EINVAL;\n}\n\nint amdgpu_gfx_kiq_init_ring(struct amdgpu_device *adev,\n\t\t\t     struct amdgpu_ring *ring,\n\t\t\t     struct amdgpu_irq_src *irq, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tint r = 0;\n\n\tspin_lock_init(&kiq->ring_lock);\n\n\tring->adev = NULL;\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\tring->xcc_id = xcc_id;\n\tring->vm_hub = AMDGPU_GFXHUB(xcc_id);\n\tring->doorbell_index =\n\t\t(adev->doorbell_index.kiq +\n\t\t xcc_id * adev->doorbell_index.xcc_doorbell_range)\n\t\t<< 1;\n\n\tr = amdgpu_gfx_kiq_acquire(adev, ring, xcc_id);\n\tif (r)\n\t\treturn r;\n\n\tring->eop_gpu_addr = kiq->eop_gpu_addr;\n\tring->no_scheduler = true;\n\tsprintf(ring->name, \"kiq_%d.%d.%d.%d\", xcc_id, ring->me, ring->pipe, ring->queue);\n\tr = amdgpu_ring_init(adev, ring, 1024, irq, AMDGPU_CP_KIQ_IRQ_DRIVER0,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\tdev_warn(adev->dev, \"(%d) failed to init kiq ring\\n\", r);\n\n\treturn r;\n}\n\nvoid amdgpu_gfx_kiq_free_ring(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_fini(ring);\n}\n\nvoid amdgpu_gfx_kiq_fini(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\n\tamdgpu_bo_free_kernel(&kiq->eop_obj, &kiq->eop_gpu_addr, NULL);\n}\n\nint amdgpu_gfx_kiq_init(struct amdgpu_device *adev,\n\t\t\tunsigned int hpd_size, int xcc_id)\n{\n\tint r;\n\tu32 *hpd;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\n\tr = amdgpu_bo_create_kernel(adev, hpd_size, PAGE_SIZE,\n\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT, &kiq->eop_obj,\n\t\t\t\t    &kiq->eop_gpu_addr, (void **)&hpd);\n\tif (r) {\n\t\tdev_warn(adev->dev, \"failed to create KIQ bo (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tmemset(hpd, 0, hpd_size);\n\n\tr = amdgpu_bo_reserve(kiq->eop_obj, true);\n\tif (unlikely(r != 0))\n\t\tdev_warn(adev->dev, \"(%d) reserve kiq eop bo failed\\n\", r);\n\tamdgpu_bo_kunmap(kiq->eop_obj);\n\tamdgpu_bo_unreserve(kiq->eop_obj);\n\n\treturn 0;\n}\n\n \nint amdgpu_gfx_mqd_sw_init(struct amdgpu_device *adev,\n\t\t\t   unsigned int mqd_size, int xcc_id)\n{\n\tint r, i, j;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tstruct amdgpu_ring *ring = &kiq->ring;\n\tu32 domain = AMDGPU_GEM_DOMAIN_GTT;\n\n#if !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)\n\t \n\tif (adev->ip_versions[GC_HWIP][0] >= IP_VERSION(10, 0, 0))\n\t\tdomain |= AMDGPU_GEM_DOMAIN_VRAM;\n#endif\n\n\t \n\tif (!adev->enable_mes_kiq && !ring->mqd_obj) {\n\t\t \n\t\tr = amdgpu_bo_create_kernel(adev, mqd_size, PAGE_SIZE,\n\t\t\t\t\t    AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t    &ring->mqd_obj,\n\t\t\t\t\t    &ring->mqd_gpu_addr,\n\t\t\t\t\t    &ring->mqd_ptr);\n\t\tif (r) {\n\t\t\tdev_warn(adev->dev, \"failed to create ring mqd ob (%d)\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tkiq->mqd_backup = kmalloc(mqd_size, GFP_KERNEL);\n\t\tif (!kiq->mqd_backup) {\n\t\t\tdev_warn(adev->dev,\n\t\t\t\t \"no memory to create MQD backup for ring %s\\n\", ring->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (adev->asic_type >= CHIP_NAVI10 && amdgpu_async_gfx_ring) {\n\t\t \n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\t\tring = &adev->gfx.gfx_ring[i];\n\t\t\tif (!ring->mqd_obj) {\n\t\t\t\tr = amdgpu_bo_create_kernel(adev, mqd_size, PAGE_SIZE,\n\t\t\t\t\t\t\t    domain, &ring->mqd_obj,\n\t\t\t\t\t\t\t    &ring->mqd_gpu_addr, &ring->mqd_ptr);\n\t\t\t\tif (r) {\n\t\t\t\t\tdev_warn(adev->dev, \"failed to create ring mqd bo (%d)\", r);\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\n\t\t\t\tring->mqd_size = mqd_size;\n\t\t\t\t \n\t\t\t\tadev->gfx.me.mqd_backup[i] = kmalloc(mqd_size, GFP_KERNEL);\n\t\t\t\tif (!adev->gfx.me.mqd_backup[i]) {\n\t\t\t\t\tdev_warn(adev->dev, \"no memory to create MQD backup for ring %s\\n\", ring->name);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tj = i + xcc_id * adev->gfx.num_compute_rings;\n\t\tring = &adev->gfx.compute_ring[j];\n\t\tif (!ring->mqd_obj) {\n\t\t\tr = amdgpu_bo_create_kernel(adev, mqd_size, PAGE_SIZE,\n\t\t\t\t\t\t    domain, &ring->mqd_obj,\n\t\t\t\t\t\t    &ring->mqd_gpu_addr, &ring->mqd_ptr);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(adev->dev, \"failed to create ring mqd bo (%d)\", r);\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tring->mqd_size = mqd_size;\n\t\t\t \n\t\t\tadev->gfx.mec.mqd_backup[j] = kmalloc(mqd_size, GFP_KERNEL);\n\t\t\tif (!adev->gfx.mec.mqd_backup[j]) {\n\t\t\t\tdev_warn(adev->dev, \"no memory to create MQD backup for ring %s\\n\", ring->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid amdgpu_gfx_mqd_sw_fini(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_ring *ring = NULL;\n\tint i, j;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\n\tif (adev->asic_type >= CHIP_NAVI10 && amdgpu_async_gfx_ring) {\n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\t\tring = &adev->gfx.gfx_ring[i];\n\t\t\tkfree(adev->gfx.me.mqd_backup[i]);\n\t\t\tamdgpu_bo_free_kernel(&ring->mqd_obj,\n\t\t\t\t\t      &ring->mqd_gpu_addr,\n\t\t\t\t\t      &ring->mqd_ptr);\n\t\t}\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tj = i + xcc_id * adev->gfx.num_compute_rings;\n\t\tring = &adev->gfx.compute_ring[j];\n\t\tkfree(adev->gfx.mec.mqd_backup[j]);\n\t\tamdgpu_bo_free_kernel(&ring->mqd_obj,\n\t\t\t\t      &ring->mqd_gpu_addr,\n\t\t\t\t      &ring->mqd_ptr);\n\t}\n\n\tring = &kiq->ring;\n\tkfree(kiq->mqd_backup);\n\tamdgpu_bo_free_kernel(&ring->mqd_obj,\n\t\t\t      &ring->mqd_gpu_addr,\n\t\t\t      &ring->mqd_ptr);\n}\n\nint amdgpu_gfx_disable_kcq(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tint i, r = 0;\n\tint j;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)\n\t\treturn -EINVAL;\n\n\tspin_lock(&kiq->ring_lock);\n\tif (amdgpu_ring_alloc(kiq_ring, kiq->pmf->unmap_queues_size *\n\t\t\t\t\tadev->gfx.num_compute_rings)) {\n\t\tspin_unlock(&kiq->ring_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tj = i + xcc_id * adev->gfx.num_compute_rings;\n\t\tkiq->pmf->kiq_unmap_queues(kiq_ring,\n\t\t\t\t\t   &adev->gfx.compute_ring[j],\n\t\t\t\t\t   RESET_QUEUES, 0, 0);\n\t}\n\n\tif (kiq_ring->sched.ready && !adev->job_hang)\n\t\tr = amdgpu_ring_test_helper(kiq_ring);\n\tspin_unlock(&kiq->ring_lock);\n\n\treturn r;\n}\n\nint amdgpu_gfx_disable_kgq(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tint i, r = 0;\n\tint j;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)\n\t\treturn -EINVAL;\n\n\tspin_lock(&kiq->ring_lock);\n\tif (amdgpu_gfx_is_master_xcc(adev, xcc_id)) {\n\t\tif (amdgpu_ring_alloc(kiq_ring, kiq->pmf->unmap_queues_size *\n\t\t\t\t\t\tadev->gfx.num_gfx_rings)) {\n\t\t\tspin_unlock(&kiq->ring_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\t\tj = i + xcc_id * adev->gfx.num_gfx_rings;\n\t\t\tkiq->pmf->kiq_unmap_queues(kiq_ring,\n\t\t\t\t\t\t   &adev->gfx.gfx_ring[j],\n\t\t\t\t\t\t   PREEMPT_QUEUES, 0, 0);\n\t\t}\n\t}\n\n\tif (adev->gfx.kiq[0].ring.sched.ready && !adev->job_hang)\n\t\tr = amdgpu_ring_test_helper(kiq_ring);\n\tspin_unlock(&kiq->ring_lock);\n\n\treturn r;\n}\n\nint amdgpu_queue_mask_bit_to_set_resource_bit(struct amdgpu_device *adev,\n\t\t\t\t\tint queue_bit)\n{\n\tint mec, pipe, queue;\n\tint set_resource_bit = 0;\n\n\tamdgpu_queue_mask_bit_to_mec_queue(adev, queue_bit, &mec, &pipe, &queue);\n\n\tset_resource_bit = mec * 4 * 8 + pipe * 8 + queue;\n\n\treturn set_resource_bit;\n}\n\nint amdgpu_gfx_enable_kcq(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tuint64_t queue_mask = 0;\n\tint r, i, j;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_map_queues || !kiq->pmf->kiq_set_resources)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < AMDGPU_MAX_COMPUTE_QUEUES; ++i) {\n\t\tif (!test_bit(i, adev->gfx.mec_bitmap[xcc_id].queue_bitmap))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON(i > (sizeof(queue_mask)*8))) {\n\t\t\tDRM_ERROR(\"Invalid KCQ enabled: %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tqueue_mask |= (1ull << amdgpu_queue_mask_bit_to_set_resource_bit(adev, i));\n\t}\n\n\tDRM_INFO(\"kiq ring mec %d pipe %d q %d\\n\", kiq_ring->me, kiq_ring->pipe,\n\t\t\t\t\t\t\tkiq_ring->queue);\n\tamdgpu_device_flush_hdp(adev, NULL);\n\n\tspin_lock(&kiq->ring_lock);\n\tr = amdgpu_ring_alloc(kiq_ring, kiq->pmf->map_queues_size *\n\t\t\t\t\tadev->gfx.num_compute_rings +\n\t\t\t\t\tkiq->pmf->set_resources_size);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock KIQ (%d).\\n\", r);\n\t\tspin_unlock(&kiq->ring_lock);\n\t\treturn r;\n\t}\n\n\tif (adev->enable_mes)\n\t\tqueue_mask = ~0ULL;\n\n\tkiq->pmf->kiq_set_resources(kiq_ring, queue_mask);\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tj = i + xcc_id * adev->gfx.num_compute_rings;\n\t\t\tkiq->pmf->kiq_map_queues(kiq_ring,\n\t\t\t\t\t\t &adev->gfx.compute_ring[j]);\n\t}\n\n\tr = amdgpu_ring_test_helper(kiq_ring);\n\tspin_unlock(&kiq->ring_lock);\n\tif (r)\n\t\tDRM_ERROR(\"KCQ enable failed\\n\");\n\n\treturn r;\n}\n\nint amdgpu_gfx_enable_kgq(struct amdgpu_device *adev, int xcc_id)\n{\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[xcc_id];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tint r, i, j;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_map_queues)\n\t\treturn -EINVAL;\n\n\tamdgpu_device_flush_hdp(adev, NULL);\n\n\tspin_lock(&kiq->ring_lock);\n\t \n\tif (amdgpu_gfx_is_master_xcc(adev, xcc_id)) {\n\t\tr = amdgpu_ring_alloc(kiq_ring, kiq->pmf->map_queues_size *\n\t\t\t\t\t\tadev->gfx.num_gfx_rings);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to lock KIQ (%d).\\n\", r);\n\t\t\tspin_unlock(&kiq->ring_lock);\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\t\tj = i + xcc_id * adev->gfx.num_gfx_rings;\n\t\t\tkiq->pmf->kiq_map_queues(kiq_ring,\n\t\t\t\t\t\t &adev->gfx.gfx_ring[j]);\n\t\t}\n\t}\n\n\tr = amdgpu_ring_test_helper(kiq_ring);\n\tspin_unlock(&kiq->ring_lock);\n\tif (r)\n\t\tDRM_ERROR(\"KCQ enable failed\\n\");\n\n\treturn r;\n}\n\n \n\nvoid amdgpu_gfx_off_ctrl(struct amdgpu_device *adev, bool enable)\n{\n\tunsigned long delay = GFX_OFF_DELAY_ENABLE;\n\n\tif (!(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\treturn;\n\n\tmutex_lock(&adev->gfx.gfx_off_mutex);\n\n\tif (enable) {\n\t\t \n\t\tif (WARN_ON_ONCE(adev->gfx.gfx_off_req_count == 0))\n\t\t\tgoto unlock;\n\n\t\tadev->gfx.gfx_off_req_count--;\n\n\t\tif (adev->gfx.gfx_off_req_count == 0 &&\n\t\t    !adev->gfx.gfx_off_state) {\n\t\t\tschedule_delayed_work(&adev->gfx.gfx_off_delay_work,\n\t\t\t\t\t      delay);\n\t\t}\n\t} else {\n\t\tif (adev->gfx.gfx_off_req_count == 0) {\n\t\t\tcancel_delayed_work_sync(&adev->gfx.gfx_off_delay_work);\n\n\t\t\tif (adev->gfx.gfx_off_state &&\n\t\t\t    !amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_GFX, false)) {\n\t\t\t\tadev->gfx.gfx_off_state = false;\n\n\t\t\t\tif (adev->gfx.funcs->init_spm_golden) {\n\t\t\t\t\tdev_dbg(adev->dev,\n\t\t\t\t\t\t\"GFXOFF is disabled, re-init SPM golden settings\\n\");\n\t\t\t\t\tamdgpu_gfx_init_spm_golden(adev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadev->gfx.gfx_off_req_count++;\n\t}\n\nunlock:\n\tmutex_unlock(&adev->gfx.gfx_off_mutex);\n}\n\nint amdgpu_set_gfx_off_residency(struct amdgpu_device *adev, bool value)\n{\n\tint r = 0;\n\n\tmutex_lock(&adev->gfx.gfx_off_mutex);\n\n\tr = amdgpu_dpm_set_residency_gfxoff(adev, value);\n\n\tmutex_unlock(&adev->gfx.gfx_off_mutex);\n\n\treturn r;\n}\n\nint amdgpu_get_gfx_off_residency(struct amdgpu_device *adev, u32 *value)\n{\n\tint r = 0;\n\n\tmutex_lock(&adev->gfx.gfx_off_mutex);\n\n\tr = amdgpu_dpm_get_residency_gfxoff(adev, value);\n\n\tmutex_unlock(&adev->gfx.gfx_off_mutex);\n\n\treturn r;\n}\n\nint amdgpu_get_gfx_off_entrycount(struct amdgpu_device *adev, u64 *value)\n{\n\tint r = 0;\n\n\tmutex_lock(&adev->gfx.gfx_off_mutex);\n\n\tr = amdgpu_dpm_get_entrycount_gfxoff(adev, value);\n\n\tmutex_unlock(&adev->gfx.gfx_off_mutex);\n\n\treturn r;\n}\n\nint amdgpu_get_gfx_off_status(struct amdgpu_device *adev, uint32_t *value)\n{\n\n\tint r = 0;\n\n\tmutex_lock(&adev->gfx.gfx_off_mutex);\n\n\tr = amdgpu_dpm_get_status_gfxoff(adev, value);\n\n\tmutex_unlock(&adev->gfx.gfx_off_mutex);\n\n\treturn r;\n}\n\nint amdgpu_gfx_ras_late_init(struct amdgpu_device *adev, struct ras_common_if *ras_block)\n{\n\tint r;\n\n\tif (amdgpu_ras_is_supported(adev, ras_block->block)) {\n\t\tif (!amdgpu_persistent_edc_harvesting_supported(adev))\n\t\t\tamdgpu_ras_reset_error_status(adev, AMDGPU_RAS_BLOCK__GFX);\n\n\t\tr = amdgpu_ras_block_late_init(adev, ras_block);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tif (adev->gfx.cp_ecc_error_irq.funcs) {\n\t\t\tr = amdgpu_irq_get(adev, &adev->gfx.cp_ecc_error_irq, 0);\n\t\t\tif (r)\n\t\t\t\tgoto late_fini;\n\t\t}\n\t} else {\n\t\tamdgpu_ras_feature_enable_on_boot(adev, ras_block, 0);\n\t}\n\n\treturn 0;\nlate_fini:\n\tamdgpu_ras_block_late_fini(adev, ras_block);\n\treturn r;\n}\n\nint amdgpu_gfx_ras_sw_init(struct amdgpu_device *adev)\n{\n\tint err = 0;\n\tstruct amdgpu_gfx_ras *ras = NULL;\n\n\t \n\tif (!adev->gfx.ras)\n\t\treturn 0;\n\n\tras = adev->gfx.ras;\n\n\terr = amdgpu_ras_register_ras_block(adev, &ras->ras_block);\n\tif (err) {\n\t\tdev_err(adev->dev, \"Failed to register gfx ras block!\\n\");\n\t\treturn err;\n\t}\n\n\tstrcpy(ras->ras_block.ras_comm.name, \"gfx\");\n\tras->ras_block.ras_comm.block = AMDGPU_RAS_BLOCK__GFX;\n\tras->ras_block.ras_comm.type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE;\n\tadev->gfx.ras_if = &ras->ras_block.ras_comm;\n\n\t \n\tif (!ras->ras_block.ras_late_init)\n\t\tras->ras_block.ras_late_init = amdgpu_gfx_ras_late_init;\n\n\t \n\tif (!ras->ras_block.ras_cb)\n\t\tras->ras_block.ras_cb = amdgpu_gfx_process_ras_data_cb;\n\n\treturn 0;\n}\n\nint amdgpu_gfx_poison_consumption_handler(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amdgpu_iv_entry *entry)\n{\n\tif (adev->gfx.ras && adev->gfx.ras->poison_consumption_handler)\n\t\treturn adev->gfx.ras->poison_consumption_handler(adev, entry);\n\n\treturn 0;\n}\n\nint amdgpu_gfx_process_ras_data_cb(struct amdgpu_device *adev,\n\t\tvoid *err_data,\n\t\tstruct amdgpu_iv_entry *entry)\n{\n\t \n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX)) {\n\t\tkgd2kfd_set_sram_ecc_flag(adev->kfd.dev);\n\t\tif (adev->gfx.ras && adev->gfx.ras->ras_block.hw_ops &&\n\t\t    adev->gfx.ras->ras_block.hw_ops->query_ras_error_count)\n\t\t\tadev->gfx.ras->ras_block.hw_ops->query_ras_error_count(adev, err_data);\n\t\tamdgpu_ras_reset_gpu(adev);\n\t}\n\treturn AMDGPU_RAS_SUCCESS;\n}\n\nint amdgpu_gfx_cp_ecc_error_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tstruct ras_common_if *ras_if = adev->gfx.ras_if;\n\tstruct ras_dispatch_if ih_data = {\n\t\t.entry = entry,\n\t};\n\n\tif (!ras_if)\n\t\treturn 0;\n\n\tih_data.head = *ras_if;\n\n\tDRM_ERROR(\"CP ECC ERROR IRQ\\n\");\n\tamdgpu_ras_interrupt_dispatch(adev, &ih_data);\n\treturn 0;\n}\n\nvoid amdgpu_gfx_ras_error_func(struct amdgpu_device *adev,\n\t\tvoid *ras_error_status,\n\t\tvoid (*func)(struct amdgpu_device *adev, void *ras_error_status,\n\t\t\t\tint xcc_id))\n{\n\tint i;\n\tint num_xcc = adev->gfx.xcc_mask ? NUM_XCC(adev->gfx.xcc_mask) : 1;\n\tuint32_t xcc_mask = GENMASK(num_xcc - 1, 0);\n\tstruct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;\n\n\tif (err_data) {\n\t\terr_data->ue_count = 0;\n\t\terr_data->ce_count = 0;\n\t}\n\n\tfor_each_inst(i, xcc_mask)\n\t\tfunc(adev, ras_error_status, i);\n}\n\nuint32_t amdgpu_kiq_rreg(struct amdgpu_device *adev, uint32_t reg)\n{\n\tsigned long r, cnt = 0;\n\tunsigned long flags;\n\tuint32_t seq, reg_val_offs = 0, value = 0;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[0];\n\tstruct amdgpu_ring *ring = &kiq->ring;\n\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn 0;\n\n\tif (adev->mes.ring.sched.ready)\n\t\treturn amdgpu_mes_rreg(adev, reg);\n\n\tBUG_ON(!ring->funcs->emit_rreg);\n\n\tspin_lock_irqsave(&kiq->ring_lock, flags);\n\tif (amdgpu_device_wb_get(adev, &reg_val_offs)) {\n\t\tpr_err(\"critical bug! too many kiq readers\\n\");\n\t\tgoto failed_unlock;\n\t}\n\tamdgpu_ring_alloc(ring, 32);\n\tamdgpu_ring_emit_rreg(ring, reg, reg_val_offs);\n\tr = amdgpu_fence_emit_polling(ring, &seq, MAX_KIQ_REG_WAIT);\n\tif (r)\n\t\tgoto failed_undo;\n\n\tamdgpu_ring_commit(ring);\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\n\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\n\t \n\tif (r < 1 && (amdgpu_in_reset(adev) || in_interrupt()))\n\t\tgoto failed_kiq_read;\n\n\tmight_sleep();\n\twhile (r < 1 && cnt++ < MAX_KIQ_REG_TRY) {\n\t\tmsleep(MAX_KIQ_REG_BAILOUT_INTERVAL);\n\t\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\t}\n\n\tif (cnt > MAX_KIQ_REG_TRY)\n\t\tgoto failed_kiq_read;\n\n\tmb();\n\tvalue = adev->wb.wb[reg_val_offs];\n\tamdgpu_device_wb_free(adev, reg_val_offs);\n\treturn value;\n\nfailed_undo:\n\tamdgpu_ring_undo(ring);\nfailed_unlock:\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\nfailed_kiq_read:\n\tif (reg_val_offs)\n\t\tamdgpu_device_wb_free(adev, reg_val_offs);\n\tdev_err(adev->dev, \"failed to read reg:%x\\n\", reg);\n\treturn ~0;\n}\n\nvoid amdgpu_kiq_wreg(struct amdgpu_device *adev, uint32_t reg, uint32_t v)\n{\n\tsigned long r, cnt = 0;\n\tunsigned long flags;\n\tuint32_t seq;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[0];\n\tstruct amdgpu_ring *ring = &kiq->ring;\n\n\tBUG_ON(!ring->funcs->emit_wreg);\n\n\tif (amdgpu_device_skip_hw_access(adev))\n\t\treturn;\n\n\tif (adev->mes.ring.sched.ready) {\n\t\tamdgpu_mes_wreg(adev, reg, v);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&kiq->ring_lock, flags);\n\tamdgpu_ring_alloc(ring, 32);\n\tamdgpu_ring_emit_wreg(ring, reg, v);\n\tr = amdgpu_fence_emit_polling(ring, &seq, MAX_KIQ_REG_WAIT);\n\tif (r)\n\t\tgoto failed_undo;\n\n\tamdgpu_ring_commit(ring);\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\n\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\n\t \n\tif (r < 1 && (amdgpu_in_reset(adev) || in_interrupt()))\n\t\tgoto failed_kiq_write;\n\n\tmight_sleep();\n\twhile (r < 1 && cnt++ < MAX_KIQ_REG_TRY) {\n\n\t\tmsleep(MAX_KIQ_REG_BAILOUT_INTERVAL);\n\t\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\t}\n\n\tif (cnt > MAX_KIQ_REG_TRY)\n\t\tgoto failed_kiq_write;\n\n\treturn;\n\nfailed_undo:\n\tamdgpu_ring_undo(ring);\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\nfailed_kiq_write:\n\tdev_err(adev->dev, \"failed to write reg:%x\\n\", reg);\n}\n\nint amdgpu_gfx_get_num_kcq(struct amdgpu_device *adev)\n{\n\tif (amdgpu_num_kcq == -1) {\n\t\treturn 8;\n\t} else if (amdgpu_num_kcq > 8 || amdgpu_num_kcq < 0) {\n\t\tdev_warn(adev->dev, \"set kernel compute queue number to 8 due to invalid parameter provided by user\\n\");\n\t\treturn 8;\n\t}\n\treturn amdgpu_num_kcq;\n}\n\nvoid amdgpu_gfx_cp_init_microcode(struct amdgpu_device *adev,\n\t\t\t\t  uint32_t ucode_id)\n{\n\tconst struct gfx_firmware_header_v1_0 *cp_hdr;\n\tconst struct gfx_firmware_header_v2_0 *cp_hdr_v2_0;\n\tstruct amdgpu_firmware_info *info = NULL;\n\tconst struct firmware *ucode_fw;\n\tunsigned int fw_size;\n\n\tswitch (ucode_id) {\n\tcase AMDGPU_UCODE_ID_CP_PFP:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.pfp_fw->data;\n\t\tadev->gfx.pfp_fw_version =\n\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\tadev->gfx.pfp_feature_version =\n\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\tucode_fw = adev->gfx.pfp_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.pfp_fw->data;\n\t\tadev->gfx.pfp_fw_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->header.ucode_version);\n\t\tadev->gfx.pfp_feature_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->ucode_feature_version);\n\t\tucode_fw = adev->gfx.pfp_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P0_STACK:\n\tcase AMDGPU_UCODE_ID_CP_RS64_PFP_P1_STACK:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.pfp_fw->data;\n\t\tucode_fw = adev->gfx.pfp_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->data_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_ME:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.me_fw->data;\n\t\tadev->gfx.me_fw_version =\n\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\tadev->gfx.me_feature_version =\n\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\tucode_fw = adev->gfx.me_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.me_fw->data;\n\t\tadev->gfx.me_fw_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->header.ucode_version);\n\t\tadev->gfx.me_feature_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->ucode_feature_version);\n\t\tucode_fw = adev->gfx.me_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P0_STACK:\n\tcase AMDGPU_UCODE_ID_CP_RS64_ME_P1_STACK:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.me_fw->data;\n\t\tucode_fw = adev->gfx.me_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->data_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_CE:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.ce_fw->data;\n\t\tadev->gfx.ce_fw_version =\n\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\tadev->gfx.ce_feature_version =\n\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\tucode_fw = adev->gfx.ce_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC1:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\tadev->gfx.mec_fw_version =\n\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\tadev->gfx.mec_feature_version =\n\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\tucode_fw = adev->gfx.mec_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes) -\n\t\t\t  le32_to_cpu(cp_hdr->jt_size) * 4;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC1_JT:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\tucode_fw = adev->gfx.mec_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->jt_size) * 4;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC2:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.mec2_fw->data;\n\t\tadev->gfx.mec2_fw_version =\n\t\t\tle32_to_cpu(cp_hdr->header.ucode_version);\n\t\tadev->gfx.mec2_feature_version =\n\t\t\tle32_to_cpu(cp_hdr->ucode_feature_version);\n\t\tucode_fw = adev->gfx.mec2_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->header.ucode_size_bytes) -\n\t\t\t  le32_to_cpu(cp_hdr->jt_size) * 4;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_MEC2_JT:\n\t\tcp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\t\tadev->gfx.mec2_fw->data;\n\t\tucode_fw = adev->gfx.mec2_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr->jt_size) * 4;\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\tadev->gfx.mec_fw_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->header.ucode_version);\n\t\tadev->gfx.mec_feature_version =\n\t\t\tle32_to_cpu(cp_hdr_v2_0->ucode_feature_version);\n\t\tucode_fw = adev->gfx.mec_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->ucode_size_bytes);\n\t\tbreak;\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P0_STACK:\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P1_STACK:\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P2_STACK:\n\tcase AMDGPU_UCODE_ID_CP_RS64_MEC_P3_STACK:\n\t\tcp_hdr_v2_0 = (const struct gfx_firmware_header_v2_0 *)\n\t\t\tadev->gfx.mec_fw->data;\n\t\tucode_fw = adev->gfx.mec_fw;\n\t\tfw_size = le32_to_cpu(cp_hdr_v2_0->data_size_bytes);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tinfo = &adev->firmware.ucode[ucode_id];\n\t\tinfo->ucode_id = ucode_id;\n\t\tinfo->fw = ucode_fw;\n\t\tadev->firmware.fw_size += ALIGN(fw_size, PAGE_SIZE);\n\t}\n}\n\nbool amdgpu_gfx_is_master_xcc(struct amdgpu_device *adev, int xcc_id)\n{\n\treturn !(xcc_id % (adev->gfx.num_xcc_per_xcp ?\n\t\t\tadev->gfx.num_xcc_per_xcp : 1));\n}\n\nstatic ssize_t amdgpu_gfx_get_current_compute_partition(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *addr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tint mode;\n\n\tmode = amdgpu_xcp_query_partition_mode(adev->xcp_mgr,\n\t\t\t\t\t       AMDGPU_XCP_FL_NONE);\n\n\treturn sysfs_emit(buf, \"%s\\n\", amdgpu_gfx_compute_mode_desc(mode));\n}\n\nstatic ssize_t amdgpu_gfx_set_compute_partition(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *addr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tenum amdgpu_gfx_partition mode;\n\tint ret = 0, num_xcc;\n\n\tnum_xcc = NUM_XCC(adev->gfx.xcc_mask);\n\tif (num_xcc % 2 != 0)\n\t\treturn -EINVAL;\n\n\tif (!strncasecmp(\"SPX\", buf, strlen(\"SPX\"))) {\n\t\tmode = AMDGPU_SPX_PARTITION_MODE;\n\t} else if (!strncasecmp(\"DPX\", buf, strlen(\"DPX\"))) {\n\t\t \n\t\tif (num_xcc%4)\n\t\t\treturn -EINVAL;\n\t\tmode = AMDGPU_DPX_PARTITION_MODE;\n\t} else if (!strncasecmp(\"TPX\", buf, strlen(\"TPX\"))) {\n\t\tif (num_xcc != 6)\n\t\t\treturn -EINVAL;\n\t\tmode = AMDGPU_TPX_PARTITION_MODE;\n\t} else if (!strncasecmp(\"QPX\", buf, strlen(\"QPX\"))) {\n\t\tif (num_xcc != 8)\n\t\t\treturn -EINVAL;\n\t\tmode = AMDGPU_QPX_PARTITION_MODE;\n\t} else if (!strncasecmp(\"CPX\", buf, strlen(\"CPX\"))) {\n\t\tmode = AMDGPU_CPX_PARTITION_MODE;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = amdgpu_xcp_switch_partition_mode(adev->xcp_mgr, mode);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t amdgpu_gfx_get_available_compute_partition(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *addr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tchar *supported_partition;\n\n\t \n\tswitch (NUM_XCC(adev->gfx.xcc_mask)) {\n\tcase 8:\n\t\tsupported_partition = \"SPX, DPX, QPX, CPX\";\n\t\tbreak;\n\tcase 6:\n\t\tsupported_partition = \"SPX, TPX, CPX\";\n\t\tbreak;\n\tcase 4:\n\t\tsupported_partition = \"SPX, DPX, CPX\";\n\t\tbreak;\n\t \n\tcase 2:\n\t\tsupported_partition = \"SPX, CPX\";\n\t\tbreak;\n\tdefault:\n\t\tsupported_partition = \"Not supported\";\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", supported_partition);\n}\n\nstatic DEVICE_ATTR(current_compute_partition, 0644,\n\t\t   amdgpu_gfx_get_current_compute_partition,\n\t\t   amdgpu_gfx_set_compute_partition);\n\nstatic DEVICE_ATTR(available_compute_partition, 0444,\n\t\t   amdgpu_gfx_get_available_compute_partition, NULL);\n\nint amdgpu_gfx_sysfs_init(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tr = device_create_file(adev->dev, &dev_attr_current_compute_partition);\n\tif (r)\n\t\treturn r;\n\n\tr = device_create_file(adev->dev, &dev_attr_available_compute_partition);\n\n\treturn r;\n}\n\nvoid amdgpu_gfx_sysfs_fini(struct amdgpu_device *adev)\n{\n\tdevice_remove_file(adev->dev, &dev_attr_current_compute_partition);\n\tdevice_remove_file(adev->dev, &dev_attr_available_compute_partition);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}