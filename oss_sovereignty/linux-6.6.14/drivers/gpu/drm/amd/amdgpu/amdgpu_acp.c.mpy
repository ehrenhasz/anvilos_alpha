{
  "module_name": "amdgpu_acp.c",
  "hash_id": "66228b057e86127fb3c789c63fc7eb8353dff3076ec3483a0dd67a0d0030b845",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c",
  "human_readable_source": " \n\n#include <linux/irqdomain.h>\n#include <linux/pci.h>\n#include <linux/pm_domain.h>\n#include <linux/platform_device.h>\n#include <sound/designware_i2s.h>\n#include <sound/pcm.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"amdgpu_acp.h\"\n\n#include \"acp_gfx_if.h\"\n\n#define ST_JADEITE 1\n#define ACP_TILE_ON_MASK\t\t\t0x03\n#define ACP_TILE_OFF_MASK\t\t\t0x02\n#define ACP_TILE_ON_RETAIN_REG_MASK\t\t0x1f\n#define ACP_TILE_OFF_RETAIN_REG_MASK\t\t0x20\n\n#define ACP_TILE_P1_MASK\t\t\t0x3e\n#define ACP_TILE_P2_MASK\t\t\t0x3d\n#define ACP_TILE_DSP0_MASK\t\t\t0x3b\n#define ACP_TILE_DSP1_MASK\t\t\t0x37\n\n#define ACP_TILE_DSP2_MASK\t\t\t0x2f\n\n#define ACP_DMA_REGS_END\t\t\t0x146c0\n#define ACP_I2S_PLAY_REGS_START\t\t\t0x14840\n#define ACP_I2S_PLAY_REGS_END\t\t\t0x148b4\n#define ACP_I2S_CAP_REGS_START\t\t\t0x148b8\n#define ACP_I2S_CAP_REGS_END\t\t\t0x1496c\n\n#define ACP_I2S_COMP1_CAP_REG_OFFSET\t\t0xac\n#define ACP_I2S_COMP2_CAP_REG_OFFSET\t\t0xa8\n#define ACP_I2S_COMP1_PLAY_REG_OFFSET\t\t0x6c\n#define ACP_I2S_COMP2_PLAY_REG_OFFSET\t\t0x68\n#define ACP_BT_PLAY_REGS_START\t\t\t0x14970\n#define ACP_BT_PLAY_REGS_END\t\t\t0x14a24\n#define ACP_BT_COMP1_REG_OFFSET\t\t\t0xac\n#define ACP_BT_COMP2_REG_OFFSET\t\t\t0xa8\n\n#define mmACP_PGFSM_RETAIN_REG\t\t\t0x51c9\n#define mmACP_PGFSM_CONFIG_REG\t\t\t0x51ca\n#define mmACP_PGFSM_READ_REG_0\t\t\t0x51cc\n\n#define mmACP_MEM_SHUT_DOWN_REQ_LO\t\t0x51f8\n#define mmACP_MEM_SHUT_DOWN_REQ_HI\t\t0x51f9\n#define mmACP_MEM_SHUT_DOWN_STS_LO\t\t0x51fa\n#define mmACP_MEM_SHUT_DOWN_STS_HI\t\t0x51fb\n\n#define mmACP_CONTROL\t\t\t\t0x5131\n#define mmACP_STATUS\t\t\t\t0x5133\n#define mmACP_SOFT_RESET\t\t\t0x5134\n#define ACP_CONTROL__ClkEn_MASK\t\t\t0x1\n#define ACP_SOFT_RESET__SoftResetAud_MASK\t0x100\n#define ACP_SOFT_RESET__SoftResetAudDone_MASK\t0x1000000\n#define ACP_CLOCK_EN_TIME_OUT_VALUE\t\t0x000000FF\n#define ACP_SOFT_RESET_DONE_TIME_OUT_VALUE\t0x000000FF\n\n#define ACP_TIMEOUT_LOOP\t\t\t0x000000FF\n#define ACP_DEVS\t\t\t\t4\n#define ACP_SRC_ID\t\t\t\t162\n\nstatic unsigned long acp_machine_id;\n\nenum {\n\tACP_TILE_P1 = 0,\n\tACP_TILE_P2,\n\tACP_TILE_DSP0,\n\tACP_TILE_DSP1,\n\tACP_TILE_DSP2,\n};\n\nstatic int acp_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->acp.parent = adev->dev;\n\n\tadev->acp.cgs_device =\n\t\tamdgpu_cgs_create_device(adev);\n\tif (!adev->acp.cgs_device)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int acp_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->acp.cgs_device)\n\t\tamdgpu_cgs_destroy_device(adev->acp.cgs_device);\n\n\treturn 0;\n}\n\nstruct acp_pm_domain {\n\tvoid *adev;\n\tstruct generic_pm_domain gpd;\n};\n\nstatic int acp_poweroff(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tadev = apd->adev;\n\t \n\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\treturn 0;\n}\n\nstatic int acp_poweron(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tadev = apd->adev;\n\t \n\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\treturn 0;\n}\n\nstatic int acp_genpd_add_device(struct device *dev, void *data)\n{\n\tstruct generic_pm_domain *gpd = data;\n\tint ret;\n\n\tret = pm_genpd_add_device(gpd, dev);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add dev to genpd %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int acp_genpd_remove_device(struct device *dev, void *data)\n{\n\tint ret;\n\n\tret = pm_genpd_remove_device(dev);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to remove dev from genpd %d\\n\", ret);\n\n\t \n\treturn 0;\n}\n\nstatic int acp_quirk_cb(const struct dmi_system_id *id)\n{\n\tacp_machine_id = ST_JADEITE;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id acp_quirk_table[] = {\n\t{\n\t\t.callback = acp_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"AMD\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"Jadeite\"),\n\t\t}\n\t},\n\t{\n\t\t.callback = acp_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"IP3 Technology CO.,Ltd.\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"ASN1D\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = acp_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"Standard\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"ASN10\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nstatic int acp_hw_init(void *handle)\n{\n\tint r;\n\tu64 acp_base;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct i2s_platform_data *i2s_pdata = NULL;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tconst struct amdgpu_ip_block *ip_block =\n\t\tamdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\n\n\tif (!ip_block)\n\t\treturn -EINVAL;\n\n\tr = amd_acp_hw_init(adev->acp.cgs_device,\n\t\t\t    ip_block->version->major, ip_block->version->minor);\n\t \n\tif (r == -ENODEV) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t\treturn 0;\n\t} else if (r) {\n\t\treturn r;\n\t}\n\n\tif (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)\n\t\treturn -EINVAL;\n\n\tacp_base = adev->rmmio_base;\n\tadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\n\tif (!adev->acp.acp_genpd)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_genpd->gpd.name = \"ACP_AUDIO\";\n\tadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\n\tadev->acp.acp_genpd->gpd.power_on = acp_poweron;\n\tadev->acp.acp_genpd->adev = adev;\n\n\tpm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\n\tdmi_check_system(acp_quirk_table);\n\tswitch (acp_machine_id) {\n\tcase ST_JADEITE:\n\t{\n\t\tadev->acp.acp_cell = kcalloc(2, sizeof(struct mfd_cell),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!adev->acp.acp_cell) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tadev->acp.acp_res = kcalloc(3, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!adev->acp.acp_res) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\ti2s_pdata = kcalloc(1, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\t\tif (!i2s_pdata) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\t\t      DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\ti2s_pdata[0].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\t\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\t\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\t\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\t\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\t\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[0].start = acp_base;\n\t\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\t\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play_cap\";\n\t\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_CAP_REGS_START;\n\t\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\t\tadev->acp.acp_res[2].name = \"acp2x_dma_irq\";\n\t\tadev->acp.acp_res[2].flags = IORESOURCE_IRQ;\n\t\tadev->acp.acp_res[2].start = amdgpu_irq_create_mapping(adev, 162);\n\t\tadev->acp.acp_res[2].end = adev->acp.acp_res[2].start;\n\n\t\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\t\tadev->acp.acp_cell[0].num_resources = 3;\n\t\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\t\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\t\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\t\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\t\tadev->acp.acp_cell[1].num_resources = 1;\n\t\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\t\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\t\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\t\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell, 2);\n\t\tif (r)\n\t\t\tgoto failure;\n\t\tr = device_for_each_child(adev->acp.parent, &adev->acp.acp_genpd->gpd,\n\t\t\t\t\t  acp_genpd_add_device);\n\t\tif (r)\n\t\t\tgoto failure;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n\t\t\t\t\t     GFP_KERNEL);\n\n\t\tif (!adev->acp.acp_cell) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!adev->acp.acp_res) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\t\tif (!i2s_pdata) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tswitch (adev->asic_type) {\n\t\tcase CHIP_STONEY:\n\t\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t\t}\n\t\ti2s_pdata[0].cap = DWC_I2S_PLAY;\n\t\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\t\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\n\t\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\n\t\tswitch (adev->asic_type) {\n\t\tcase CHIP_STONEY:\n\t\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\t\tDW_I2S_QUIRK_COMP_PARAM1 |\n\t\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\t\tDW_I2S_QUIRK_COMP_PARAM1;\n\t\t}\n\n\t\ti2s_pdata[1].cap = DWC_I2S_RECORD;\n\t\ti2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\t\ti2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\t\ti2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\t\ti2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t\tswitch (adev->asic_type) {\n\t\tcase CHIP_STONEY:\n\t\t\ti2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\t\ti2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\t\ti2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;\n\t\ti2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;\n\n\t\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\t\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[0].start = acp_base;\n\t\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\t\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play\";\n\t\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\n\t\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\n\n\t\tadev->acp.acp_res[2].name = \"acp2x_dw_i2s_cap\";\n\t\tadev->acp.acp_res[2].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\n\t\tadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\t\tadev->acp.acp_res[3].name = \"acp2x_dw_bt_i2s_play_cap\";\n\t\tadev->acp.acp_res[3].flags = IORESOURCE_MEM;\n\t\tadev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;\n\t\tadev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;\n\n\t\tadev->acp.acp_res[4].name = \"acp2x_dma_irq\";\n\t\tadev->acp.acp_res[4].flags = IORESOURCE_IRQ;\n\t\tadev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);\n\t\tadev->acp.acp_res[4].end = adev->acp.acp_res[4].start;\n\n\t\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\t\tadev->acp.acp_cell[0].num_resources = 5;\n\t\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\t\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\t\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\t\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\t\tadev->acp.acp_cell[1].num_resources = 1;\n\t\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\t\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\t\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\n\t\tadev->acp.acp_cell[2].name = \"designware-i2s\";\n\t\tadev->acp.acp_cell[2].num_resources = 1;\n\t\tadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\n\t\tadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\n\t\tadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\n\n\t\tadev->acp.acp_cell[3].name = \"designware-i2s\";\n\t\tadev->acp.acp_cell[3].num_resources = 1;\n\t\tadev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];\n\t\tadev->acp.acp_cell[3].platform_data = &i2s_pdata[2];\n\t\tadev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);\n\n\t\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell, ACP_DEVS);\n\t\tif (r)\n\t\t\tgoto failure;\n\n\t\tr = device_for_each_child(adev->acp.parent, &adev->acp.acp_genpd->gpd,\n\t\t\t\t\t  acp_genpd_add_device);\n\t\tif (r)\n\t\t\tgoto failure;\n\t}\n\n\t \n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t \n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t \n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\treturn 0;\n\nfailure:\n\tkfree(i2s_pdata);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_cell);\n\tkfree(adev->acp.acp_genpd);\n\treturn r;\n}\n\n \nstatic int acp_hw_fini(void *handle)\n{\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tif (!adev->acp.acp_genpd) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\t\treturn 0;\n\t}\n\n\t \n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t \n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval &= ~ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tdevice_for_each_child(adev->acp.parent, NULL,\n\t\t\t      acp_genpd_remove_device);\n\n\tmfd_remove_devices(adev->acp.parent);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_genpd);\n\tkfree(adev->acp.acp_cell);\n\n\treturn 0;\n}\n\nstatic int acp_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\treturn 0;\n}\n\nstatic int acp_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\treturn 0;\n}\n\nstatic int acp_early_init(void *handle)\n{\n\treturn 0;\n}\n\nstatic bool acp_is_idle(void *handle)\n{\n\treturn true;\n}\n\nstatic int acp_wait_for_idle(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_soft_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_set_clockgating_state(void *handle,\n\t\t\t\t     enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int acp_set_powergating_state(void *handle,\n\t\t\t\t     enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_PG_STATE_GATE);\n\n\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, enable);\n\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs acp_ip_funcs = {\n\t.name = \"acp_ip\",\n\t.early_init = acp_early_init,\n\t.late_init = NULL,\n\t.sw_init = acp_sw_init,\n\t.sw_fini = acp_sw_fini,\n\t.hw_init = acp_hw_init,\n\t.hw_fini = acp_hw_fini,\n\t.suspend = acp_suspend,\n\t.resume = acp_resume,\n\t.is_idle = acp_is_idle,\n\t.wait_for_idle = acp_wait_for_idle,\n\t.soft_reset = acp_soft_reset,\n\t.set_clockgating_state = acp_set_clockgating_state,\n\t.set_powergating_state = acp_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version acp_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_ACP,\n\t.major = 2,\n\t.minor = 2,\n\t.rev = 0,\n\t.funcs = &acp_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}