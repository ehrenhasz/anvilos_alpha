{
  "module_name": "jpeg_v1_0.c",
  "hash_id": "bf3818e855a036e704a059dc0a8096186260eccd459735d8e1bf9d5d4d9293c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/jpeg_v1_0.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_jpeg.h\"\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"vcn_v1_0.h\"\n#include \"jpeg_v1_0.h\"\n\n#include \"vcn/vcn_1_0_offset.h\"\n#include \"vcn/vcn_1_0_sh_mask.h\"\n\nstatic void jpeg_v1_0_set_dec_ring_funcs(struct amdgpu_device *adev);\nstatic void jpeg_v1_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic void jpeg_v1_0_ring_begin_use(struct amdgpu_ring *ring);\n\nstatic void jpeg_v1_0_decode_ring_patch_wreg(struct amdgpu_ring *ring, uint32_t *ptr, uint32_t reg_offset, uint32_t val)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tring->ring[(*ptr)++] = PACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0);\n\tif (((reg_offset >= 0x1f800) && (reg_offset <= 0x21fff)) ||\n\t\t((reg_offset >= 0x1e000) && (reg_offset <= 0x1e1ff))) {\n\t\tring->ring[(*ptr)++] = 0;\n\t\tring->ring[(*ptr)++] = PACKETJ((reg_offset >> 2), 0, 0, PACKETJ_TYPE0);\n\t} else {\n\t\tring->ring[(*ptr)++] = reg_offset;\n\t\tring->ring[(*ptr)++] = PACKETJ(0, 0, 0, PACKETJ_TYPE0);\n\t}\n\tring->ring[(*ptr)++] = val;\n}\n\nstatic void jpeg_v1_0_decode_ring_set_patch_ring(struct amdgpu_ring *ring, uint32_t ptr)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tuint32_t reg, reg_offset, val, mask, i;\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_LOW);\n\treg_offset = (reg << 2);\n\tval = lower_32_bits(ring->gpu_addr);\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_HIGH);\n\treg_offset = (reg << 2);\n\tval = upper_32_bits(ring->gpu_addr);\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n\n\t\n\tfor (i = 0; i <= 2; i++) {\n\t\tring->ring[ptr++] = PACKETJ(0, 0, 0, PACKETJ_TYPE2);\n\t\tring->ring[ptr++] = 0;\n\t}\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_CNTL);\n\treg_offset = (reg << 2);\n\tval = 0x13;\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_REF_DATA);\n\treg_offset = (reg << 2);\n\tval = 0x1;\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_CNTL);\n\treg_offset = (reg << 2);\n\tval = 0x1;\n\tmask = 0x1;\n\n\tring->ring[ptr++] = PACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_COND_RD_TIMER), 0, 0, PACKETJ_TYPE0);\n\tring->ring[ptr++] = 0x01400200;\n\tring->ring[ptr++] = PACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_REF_DATA), 0, 0, PACKETJ_TYPE0);\n\tring->ring[ptr++] = val;\n\tring->ring[ptr++] = PACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0);\n\tif (((reg_offset >= 0x1f800) && (reg_offset <= 0x21fff)) ||\n\t\t((reg_offset >= 0x1e000) && (reg_offset <= 0x1e1ff))) {\n\t\tring->ring[ptr++] = 0;\n\t\tring->ring[ptr++] = PACKETJ((reg_offset >> 2), 0, 0, PACKETJ_TYPE3);\n\t} else {\n\t\tring->ring[ptr++] = reg_offset;\n\t\tring->ring[ptr++] = PACKETJ(0, 0, 0, PACKETJ_TYPE3);\n\t}\n\tring->ring[ptr++] = mask;\n\n\t\n\tfor (i = 0; i <= 12; i++) {\n\t\tring->ring[ptr++] = PACKETJ(0, 0, 0, PACKETJ_TYPE6);\n\t\tring->ring[ptr++] = 0;\n\t}\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_RPTR);\n\treg_offset = (reg << 2);\n\tval = 0;\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n\n\t\n\treg = SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_CNTL);\n\treg_offset = (reg << 2);\n\tval = 0x12;\n\tjpeg_v1_0_decode_ring_patch_wreg(ring, &ptr, reg_offset, val);\n}\n\n \nstatic uint64_t jpeg_v1_0_decode_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_RPTR);\n}\n\n \nstatic uint64_t jpeg_v1_0_decode_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_WPTR);\n}\n\n \nstatic void jpeg_v1_0_decode_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_WPTR, lower_32_bits(ring->wptr));\n}\n\n \nstatic void jpeg_v1_0_decode_ring_insert_start(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x68e04);\n\n\tamdgpu_ring_write(ring, PACKETJ(0, 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x80010000);\n}\n\n \nstatic void jpeg_v1_0_decode_ring_insert_end(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x68e04);\n\n\tamdgpu_ring_write(ring, PACKETJ(0, 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x00010000);\n}\n\n \nstatic void jpeg_v1_0_decode_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\n\t\t\t\t     unsigned flags)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JPEG_GPCOM_DATA0), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, seq);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JPEG_GPCOM_DATA1), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, seq);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_WR_64BIT_BAR_LOW), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_WR_64BIT_BAR_HIGH), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JPEG_GPCOM_CMD), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x8);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JPEG_GPCOM_CMD), 0, PACKETJ_CONDITION_CHECK0, PACKETJ_TYPE4));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_COND_RD_TIMER), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x01400200);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_REF_DATA), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, seq);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_LOW), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_HIGH), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(0, 0, PACKETJ_CONDITION_CHECK3, PACKETJ_TYPE2));\n\tamdgpu_ring_write(ring, 0xffffffff);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x3fbc);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(0, 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x1);\n\n\t \n\tamdgpu_ring_write(ring, PACKETJ(0, 0, 0, PACKETJ_TYPE7));\n\tamdgpu_ring_write(ring, 0);\n}\n\n \nstatic void jpeg_v1_0_decode_ring_emit_ib(struct amdgpu_ring *ring,\n\t\t\t\t\tstruct amdgpu_job *job,\n\t\t\t\t\tstruct amdgpu_ib *ib,\n\t\t\t\t\tuint32_t flags)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_IB_VMID), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, (vmid | (vmid << 4)));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JPEG_VMID), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, (vmid | (vmid << 4)));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_IB_64BIT_BAR_LOW), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, lower_32_bits(ib->gpu_addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_IB_64BIT_BAR_HIGH), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_IB_SIZE), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, ib->length_dw);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_LOW), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, lower_32_bits(ring->gpu_addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_LMI_JRBC_RB_MEM_RD_64BIT_BAR_HIGH), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, upper_32_bits(ring->gpu_addr));\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(0, 0, PACKETJ_CONDITION_CHECK0, PACKETJ_TYPE2));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_COND_RD_TIMER), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x01400200);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_REF_DATA), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x2);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_STATUS), 0, PACKETJ_CONDITION_CHECK3, PACKETJ_TYPE3));\n\tamdgpu_ring_write(ring, 0x2);\n}\n\nstatic void jpeg_v1_0_decode_ring_emit_reg_wait(struct amdgpu_ring *ring,\n\t\t\t\t\t    uint32_t reg, uint32_t val,\n\t\t\t\t\t    uint32_t mask)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t reg_offset = (reg << 2);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_COND_RD_TIMER), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, 0x01400200);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_RB_REF_DATA), 0, 0, PACKETJ_TYPE0));\n\tamdgpu_ring_write(ring, val);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0));\n\tif (((reg_offset >= 0x1f800) && (reg_offset <= 0x21fff)) ||\n\t\t((reg_offset >= 0x1e000) && (reg_offset <= 0x1e1ff))) {\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring,\n\t\t\tPACKETJ((reg_offset >> 2), 0, 0, PACKETJ_TYPE3));\n\t} else {\n\t\tamdgpu_ring_write(ring, reg_offset);\n\t\tamdgpu_ring_write(ring,\n\t\t\tPACKETJ(0, 0, 0, PACKETJ_TYPE3));\n\t}\n\tamdgpu_ring_write(ring, mask);\n}\n\nstatic void jpeg_v1_0_decode_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\tunsigned vmid, uint64_t pd_addr)\n{\n\tstruct amdgpu_vmhub *hub = &ring->adev->vmhub[ring->vm_hub];\n\tuint32_t data0, data1, mask;\n\n\tpd_addr = amdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\t \n\tdata0 = hub->ctx0_ptb_addr_lo32 + vmid * hub->ctx_addr_distance;\n\tdata1 = lower_32_bits(pd_addr);\n\tmask = 0xffffffff;\n\tjpeg_v1_0_decode_ring_emit_reg_wait(ring, data0, data1, mask);\n}\n\nstatic void jpeg_v1_0_decode_ring_emit_wreg(struct amdgpu_ring *ring,\n\t\t\t\t\tuint32_t reg, uint32_t val)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t reg_offset = (reg << 2);\n\n\tamdgpu_ring_write(ring,\n\t\tPACKETJ(SOC15_REG_OFFSET(JPEG, 0, mmUVD_JRBC_EXTERNAL_REG_BASE), 0, 0, PACKETJ_TYPE0));\n\tif (((reg_offset >= 0x1f800) && (reg_offset <= 0x21fff)) ||\n\t\t\t((reg_offset >= 0x1e000) && (reg_offset <= 0x1e1ff))) {\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring,\n\t\t\tPACKETJ((reg_offset >> 2), 0, 0, PACKETJ_TYPE0));\n\t} else {\n\t\tamdgpu_ring_write(ring, reg_offset);\n\t\tamdgpu_ring_write(ring,\n\t\t\tPACKETJ(0, 0, 0, PACKETJ_TYPE0));\n\t}\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void jpeg_v1_0_decode_ring_nop(struct amdgpu_ring *ring, uint32_t count)\n{\n\tint i;\n\n\tWARN_ON(ring->wptr % 2 || count % 2);\n\n\tfor (i = 0; i < count / 2; i++) {\n\t\tamdgpu_ring_write(ring, PACKETJ(0, 0, 0, PACKETJ_TYPE6));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\nstatic int jpeg_v1_0_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\treturn 0;\n}\n\nstatic int jpeg_v1_0_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tDRM_DEBUG(\"IH: JPEG decode TRAP\\n\");\n\n\tswitch (entry->src_id) {\n\tcase 126:\n\t\tamdgpu_fence_process(adev->jpeg.inst->ring_dec);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t  entry->src_id, entry->src_data[0]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint jpeg_v1_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->jpeg.num_jpeg_inst = 1;\n\tadev->jpeg.num_jpeg_rings = 1;\n\n\tjpeg_v1_0_set_dec_ring_funcs(adev);\n\tjpeg_v1_0_set_irq_funcs(adev);\n\n\treturn 0;\n}\n\n \nint jpeg_v1_0_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring;\n\tint r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_VCN, 126, &adev->jpeg.inst->irq);\n\tif (r)\n\t\treturn r;\n\n\tring = adev->jpeg.inst->ring_dec;\n\tring->vm_hub = AMDGPU_MMHUB0(0);\n\tsprintf(ring->name, \"jpeg_dec\");\n\tr = amdgpu_ring_init(adev, ring, 512, &adev->jpeg.inst->irq,\n\t\t\t     0, AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\n\tadev->jpeg.internal.jpeg_pitch[0] = adev->jpeg.inst->external.jpeg_pitch[0] =\n\t\tSOC15_REG_OFFSET(JPEG, 0, mmUVD_JPEG_PITCH);\n\n\treturn 0;\n}\n\n \nvoid jpeg_v1_0_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_ring_fini(adev->jpeg.inst->ring_dec);\n}\n\n \nvoid jpeg_v1_0_start(struct amdgpu_device *adev, int mode)\n{\n\tstruct amdgpu_ring *ring = adev->jpeg.inst->ring_dec;\n\n\tif (mode == 0) {\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_LMI_JRBC_RB_VMID, 0);\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_CNTL, UVD_JRBC_RB_CNTL__RB_NO_FETCH_MASK |\n\t\t\t\tUVD_JRBC_RB_CNTL__RB_RPTR_WR_EN_MASK);\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_LMI_JRBC_RB_64BIT_BAR_LOW, lower_32_bits(ring->gpu_addr));\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_LMI_JRBC_RB_64BIT_BAR_HIGH, upper_32_bits(ring->gpu_addr));\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_RPTR, 0);\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_WPTR, 0);\n\t\tWREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_CNTL, UVD_JRBC_RB_CNTL__RB_RPTR_WR_EN_MASK);\n\t}\n\n\t \n\tring->wptr = RREG32_SOC15(JPEG, 0, mmUVD_JRBC_RB_WPTR);\n\n\t \n\tjpeg_v1_0_decode_ring_set_patch_ring(ring,\n\t\t(ring->wptr + ring->max_dw * amdgpu_sched_hw_submission));\n}\n\nstatic const struct amdgpu_ring_funcs jpeg_v1_0_decode_ring_vm_funcs = {\n\t.type = AMDGPU_RING_TYPE_VCN_JPEG,\n\t.align_mask = 0xf,\n\t.nop = PACKET0(0x81ff, 0),\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.extra_dw = 64,\n\t.get_rptr = jpeg_v1_0_decode_ring_get_rptr,\n\t.get_wptr = jpeg_v1_0_decode_ring_get_wptr,\n\t.set_wptr = jpeg_v1_0_decode_ring_set_wptr,\n\t.emit_frame_size =\n\t\t6 + 6 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 6 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 8 +\n\t\t8 +  \n\t\t26 + 26 +  \n\t\t6,\n\t.emit_ib_size = 22,  \n\t.emit_ib = jpeg_v1_0_decode_ring_emit_ib,\n\t.emit_fence = jpeg_v1_0_decode_ring_emit_fence,\n\t.emit_vm_flush = jpeg_v1_0_decode_ring_emit_vm_flush,\n\t.test_ring = amdgpu_jpeg_dec_ring_test_ring,\n\t.test_ib = amdgpu_jpeg_dec_ring_test_ib,\n\t.insert_nop = jpeg_v1_0_decode_ring_nop,\n\t.insert_start = jpeg_v1_0_decode_ring_insert_start,\n\t.insert_end = jpeg_v1_0_decode_ring_insert_end,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = jpeg_v1_0_ring_begin_use,\n\t.end_use = vcn_v1_0_ring_end_use,\n\t.emit_wreg = jpeg_v1_0_decode_ring_emit_wreg,\n\t.emit_reg_wait = jpeg_v1_0_decode_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = amdgpu_ring_emit_reg_write_reg_wait_helper,\n};\n\nstatic void jpeg_v1_0_set_dec_ring_funcs(struct amdgpu_device *adev)\n{\n\tadev->jpeg.inst->ring_dec->funcs = &jpeg_v1_0_decode_ring_vm_funcs;\n\tDRM_INFO(\"JPEG decode is enabled in VM mode\\n\");\n}\n\nstatic const struct amdgpu_irq_src_funcs jpeg_v1_0_irq_funcs = {\n\t.set = jpeg_v1_0_set_interrupt_state,\n\t.process = jpeg_v1_0_process_interrupt,\n};\n\nstatic void jpeg_v1_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->jpeg.inst->irq.funcs = &jpeg_v1_0_irq_funcs;\n}\n\nstatic void jpeg_v1_0_ring_begin_use(struct amdgpu_ring *ring)\n{\n\tstruct\tamdgpu_device *adev = ring->adev;\n\tbool\tset_clocks = !cancel_delayed_work_sync(&adev->vcn.idle_work);\n\tint\t\tcnt = 0;\n\n\tmutex_lock(&adev->vcn.vcn1_jpeg1_workaround);\n\n\tif (amdgpu_fence_wait_empty(&adev->vcn.inst->ring_dec))\n\t\tDRM_ERROR(\"JPEG dec: vcn dec ring may not be empty\\n\");\n\n\tfor (cnt = 0; cnt < adev->vcn.num_enc_rings; cnt++) {\n\t\tif (amdgpu_fence_wait_empty(&adev->vcn.inst->ring_enc[cnt]))\n\t\t\tDRM_ERROR(\"JPEG dec: vcn enc ring[%d] may not be empty\\n\", cnt);\n\t}\n\n\tvcn_v1_0_set_pg_for_begin_use(ring, set_clocks);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}