{
  "module_name": "amdgpu_jpeg.c",
  "hash_id": "504ab27eb224b5f578ef62d07aad9a505e226be49331bd1f4d874d3a6de05ae7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_jpeg.h\"\n#include \"amdgpu_pm.h\"\n#include \"soc15d.h\"\n#include \"soc15_common.h\"\n\n#define JPEG_IDLE_TIMEOUT\tmsecs_to_jiffies(1000)\n\nstatic void amdgpu_jpeg_idle_work_handler(struct work_struct *work);\n\nint amdgpu_jpeg_sw_init(struct amdgpu_device *adev)\n{\n\tINIT_DELAYED_WORK(&adev->jpeg.idle_work, amdgpu_jpeg_idle_work_handler);\n\tmutex_init(&adev->jpeg.jpeg_pg_lock);\n\tatomic_set(&adev->jpeg.total_submission_cnt, 0);\n\n\treturn 0;\n}\n\nint amdgpu_jpeg_sw_fini(struct amdgpu_device *adev)\n{\n\tint i, j;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < adev->jpeg.num_jpeg_rings; ++j)\n\t\t\tamdgpu_ring_fini(&adev->jpeg.inst[i].ring_dec[j]);\n\t}\n\n\tmutex_destroy(&adev->jpeg.jpeg_pg_lock);\n\n\treturn 0;\n}\n\nint amdgpu_jpeg_suspend(struct amdgpu_device *adev)\n{\n\tcancel_delayed_work_sync(&adev->jpeg.idle_work);\n\n\treturn 0;\n}\n\nint amdgpu_jpeg_resume(struct amdgpu_device *adev)\n{\n\treturn 0;\n}\n\nstatic void amdgpu_jpeg_idle_work_handler(struct work_struct *work)\n{\n\tstruct amdgpu_device *adev =\n\t\tcontainer_of(work, struct amdgpu_device, jpeg.idle_work.work);\n\tunsigned int fences = 0;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < adev->jpeg.num_jpeg_rings; ++j)\n\t\t\tfences += amdgpu_fence_count_emitted(&adev->jpeg.inst[i].ring_dec[j]);\n\t}\n\n\tif (!fences && !atomic_read(&adev->jpeg.total_submission_cnt))\n\t\tamdgpu_device_ip_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_JPEG,\n\t\t\t\t\t\t       AMD_PG_STATE_GATE);\n\telse\n\t\tschedule_delayed_work(&adev->jpeg.idle_work, JPEG_IDLE_TIMEOUT);\n}\n\nvoid amdgpu_jpeg_ring_begin_use(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tatomic_inc(&adev->jpeg.total_submission_cnt);\n\tcancel_delayed_work_sync(&adev->jpeg.idle_work);\n\n\tmutex_lock(&adev->jpeg.jpeg_pg_lock);\n\tamdgpu_device_ip_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_JPEG,\n\t\t\t\t\t\t       AMD_PG_STATE_UNGATE);\n\tmutex_unlock(&adev->jpeg.jpeg_pg_lock);\n}\n\nvoid amdgpu_jpeg_ring_end_use(struct amdgpu_ring *ring)\n{\n\tatomic_dec(&ring->adev->jpeg.total_submission_cnt);\n\tschedule_delayed_work(&ring->adev->jpeg.idle_work, JPEG_IDLE_TIMEOUT);\n}\n\nint amdgpu_jpeg_dec_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tWREG32(adev->jpeg.inst[ring->me].external.jpeg_pitch[ring->pipe], 0xCAFEDEAD);\n\t \n\tRREG32(adev->jpeg.inst[ring->me].external.jpeg_pitch[ring->pipe]);\n\n\tamdgpu_ring_write(ring, PACKET0(adev->jpeg.internal.jpeg_pitch[ring->pipe], 0));\n\tamdgpu_ring_write(ring, 0xABADCAFE);\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(adev->jpeg.inst[ring->me].external.jpeg_pitch[ring->pipe]);\n\t\tif (tmp == 0xABADCAFE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\nstatic int amdgpu_jpeg_dec_set_reg(struct amdgpu_ring *ring, uint32_t handle,\n\t\tstruct dma_fence **fence)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_job *job;\n\tstruct amdgpu_ib *ib;\n\tstruct dma_fence *f = NULL;\n\tconst unsigned ib_size_dw = 16;\n\tint i, r;\n\n\tr = amdgpu_job_alloc_with_ib(ring->adev, NULL, NULL, ib_size_dw * 4,\n\t\t\t\t     AMDGPU_IB_POOL_DIRECT, &job);\n\tif (r)\n\t\treturn r;\n\n\tib = &job->ibs[0];\n\n\tib->ptr[0] = PACKETJ(adev->jpeg.internal.jpeg_pitch[ring->pipe], 0, 0, PACKETJ_TYPE0);\n\tib->ptr[1] = 0xDEADBEEF;\n\tfor (i = 2; i < 16; i += 2) {\n\t\tib->ptr[i] = PACKETJ(0, 0, 0, PACKETJ_TYPE6);\n\t\tib->ptr[i+1] = 0;\n\t}\n\tib->length_dw = 16;\n\n\tr = amdgpu_job_submit_direct(job, ring, &f);\n\tif (r)\n\t\tgoto err;\n\n\tif (fence)\n\t\t*fence = dma_fence_get(f);\n\tdma_fence_put(f);\n\n\treturn 0;\n\nerr:\n\tamdgpu_job_free(job);\n\treturn r;\n}\n\nint amdgpu_jpeg_dec_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tstruct dma_fence *fence = NULL;\n\tlong r = 0;\n\n\tr = amdgpu_jpeg_dec_set_reg(ring, 1, &fence);\n\tif (r)\n\t\tgoto error;\n\n\tr = dma_fence_wait_timeout(fence, false, timeout);\n\tif (r == 0) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto error;\n\t} else if (r < 0) {\n\t\tgoto error;\n\t} else {\n\t\tr = 0;\n\t}\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\t\ttmp = RREG32(adev->jpeg.inst[ring->me].external.jpeg_pitch[ring->pipe]);\n\t\t\tif (tmp == 0xDEADBEEF)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tif (i >= adev->usec_timeout)\n\t\t\tr = -ETIMEDOUT;\n\t}\n\n\tdma_fence_put(fence);\nerror:\n\treturn r;\n}\n\nint amdgpu_jpeg_process_poison_irq(struct amdgpu_device *adev,\n\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\tstruct amdgpu_iv_entry *entry)\n{\n\tstruct ras_common_if *ras_if = adev->jpeg.ras_if;\n\tstruct ras_dispatch_if ih_data = {\n\t\t.entry = entry,\n\t};\n\n\tif (!ras_if)\n\t\treturn 0;\n\n\tih_data.head = *ras_if;\n\tamdgpu_ras_interrupt_dispatch(adev, &ih_data);\n\n\treturn 0;\n}\n\nint amdgpu_jpeg_ras_late_init(struct amdgpu_device *adev, struct ras_common_if *ras_block)\n{\n\tint r, i;\n\n\tr = amdgpu_ras_block_late_init(adev, ras_block);\n\tif (r)\n\t\treturn r;\n\n\tif (amdgpu_ras_is_supported(adev, ras_block->block)) {\n\t\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; ++i) {\n\t\t\tif (adev->jpeg.harvest_config & (1 << i) ||\n\t\t\t    !adev->jpeg.inst[i].ras_poison_irq.funcs)\n\t\t\t\tcontinue;\n\n\t\t\tr = amdgpu_irq_get(adev, &adev->jpeg.inst[i].ras_poison_irq, 0);\n\t\t\tif (r)\n\t\t\t\tgoto late_fini;\n\t\t}\n\t}\n\treturn 0;\n\nlate_fini:\n\tamdgpu_ras_block_late_fini(adev, ras_block);\n\treturn r;\n}\n\nint amdgpu_jpeg_ras_sw_init(struct amdgpu_device *adev)\n{\n\tint err;\n\tstruct amdgpu_jpeg_ras *ras;\n\n\tif (!adev->jpeg.ras)\n\t\treturn 0;\n\n\tras = adev->jpeg.ras;\n\terr = amdgpu_ras_register_ras_block(adev, &ras->ras_block);\n\tif (err) {\n\t\tdev_err(adev->dev, \"Failed to register jpeg ras block!\\n\");\n\t\treturn err;\n\t}\n\n\tstrcpy(ras->ras_block.ras_comm.name, \"jpeg\");\n\tras->ras_block.ras_comm.block = AMDGPU_RAS_BLOCK__JPEG;\n\tras->ras_block.ras_comm.type = AMDGPU_RAS_ERROR__POISON;\n\tadev->jpeg.ras_if = &ras->ras_block.ras_comm;\n\n\tif (!ras->ras_block.ras_late_init)\n\t\tras->ras_block.ras_late_init = amdgpu_jpeg_ras_late_init;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}