{
  "module_name": "amdgpu_pll.c",
  "hash_id": "9ec458f7ac86f4113b0696fc97acb4ff4f19ff852fdad84c4f4d313cf97e3e55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_pll.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"atombios_encoders.h\"\n#include \"amdgpu_pll.h\"\n#include <asm/div64.h>\n#include <linux/gcd.h>\n\n \nstatic void amdgpu_pll_reduce_ratio(unsigned *nom, unsigned *den,\n\t\t\t\t    unsigned nom_min, unsigned den_min)\n{\n\tunsigned tmp;\n\n\t \n\ttmp = gcd(*nom, *den);\n\t*nom /= tmp;\n\t*den /= tmp;\n\n\t \n\tif (*nom < nom_min) {\n\t\ttmp = DIV_ROUND_UP(nom_min, *nom);\n\t\t*nom *= tmp;\n\t\t*den *= tmp;\n\t}\n\n\t \n\tif (*den < den_min) {\n\t\ttmp = DIV_ROUND_UP(den_min, *den);\n\t\t*nom *= tmp;\n\t\t*den *= tmp;\n\t}\n}\n\n \nstatic void amdgpu_pll_get_fb_ref_div(struct amdgpu_device *adev, unsigned int nom,\n\t\t\t\t      unsigned int den, unsigned int post_div,\n\t\t\t\t      unsigned int fb_div_max, unsigned int ref_div_max,\n\t\t\t\t      unsigned int *fb_div, unsigned int *ref_div)\n{\n\n\t \n\tif (adev->family == AMDGPU_FAMILY_SI)\n\t\tref_div_max = min(100 / post_div, ref_div_max);\n\telse\n\t\tref_div_max = min(128 / post_div, ref_div_max);\n\n\t \n\t*ref_div = min(max(DIV_ROUND_CLOSEST(den, post_div), 1u), ref_div_max);\n\t*fb_div = DIV_ROUND_CLOSEST(nom * *ref_div * post_div, den);\n\n\t \n\tif (*fb_div > fb_div_max) {\n\t\t*ref_div = DIV_ROUND_CLOSEST(*ref_div * fb_div_max, *fb_div);\n\t\t*fb_div = fb_div_max;\n\t}\n}\n\n \nvoid amdgpu_pll_compute(struct amdgpu_device *adev,\n\t\t\tstruct amdgpu_pll *pll,\n\t\t\tu32 freq,\n\t\t\tu32 *dot_clock_p,\n\t\t\tu32 *fb_div_p,\n\t\t\tu32 *frac_fb_div_p,\n\t\t\tu32 *ref_div_p,\n\t\t\tu32 *post_div_p)\n{\n\tunsigned target_clock = pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV ?\n\t\tfreq : freq / 10;\n\n\tunsigned fb_div_min, fb_div_max, fb_div;\n\tunsigned post_div_min, post_div_max, post_div;\n\tunsigned ref_div_min, ref_div_max, ref_div;\n\tunsigned post_div_best, diff_best;\n\tunsigned nom, den;\n\n\t \n\tfb_div_min = pll->min_feedback_div;\n\tfb_div_max = pll->max_feedback_div;\n\n\tif (pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV) {\n\t\tfb_div_min *= 10;\n\t\tfb_div_max *= 10;\n\t}\n\n\t \n\tif (pll->flags & AMDGPU_PLL_USE_REF_DIV)\n\t\tref_div_min = pll->reference_div;\n\telse\n\t\tref_div_min = pll->min_ref_div;\n\n\tif (pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV &&\n\t    pll->flags & AMDGPU_PLL_USE_REF_DIV)\n\t\tref_div_max = pll->reference_div;\n\telse\n\t\tref_div_max = pll->max_ref_div;\n\n\t \n\tif (pll->flags & AMDGPU_PLL_USE_POST_DIV) {\n\t\tpost_div_min = pll->post_div;\n\t\tpost_div_max = pll->post_div;\n\t} else {\n\t\tunsigned vco_min, vco_max;\n\n\t\tif (pll->flags & AMDGPU_PLL_IS_LCD) {\n\t\t\tvco_min = pll->lcd_pll_out_min;\n\t\t\tvco_max = pll->lcd_pll_out_max;\n\t\t} else {\n\t\t\tvco_min = pll->pll_out_min;\n\t\t\tvco_max = pll->pll_out_max;\n\t\t}\n\n\t\tif (pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV) {\n\t\t\tvco_min *= 10;\n\t\t\tvco_max *= 10;\n\t\t}\n\n\t\tpost_div_min = vco_min / target_clock;\n\t\tif ((target_clock * post_div_min) < vco_min)\n\t\t\t++post_div_min;\n\t\tif (post_div_min < pll->min_post_div)\n\t\t\tpost_div_min = pll->min_post_div;\n\n\t\tpost_div_max = vco_max / target_clock;\n\t\tif ((target_clock * post_div_max) > vco_max)\n\t\t\t--post_div_max;\n\t\tif (post_div_max > pll->max_post_div)\n\t\t\tpost_div_max = pll->max_post_div;\n\t}\n\n\t \n\tnom = target_clock;\n\tden = pll->reference_freq;\n\n\t \n\tamdgpu_pll_reduce_ratio(&nom, &den, fb_div_min, post_div_min);\n\n\t \n\tif (pll->flags & AMDGPU_PLL_PREFER_MINM_OVER_MAXP)\n\t\tpost_div_best = post_div_min;\n\telse\n\t\tpost_div_best = post_div_max;\n\tdiff_best = ~0;\n\n\tfor (post_div = post_div_min; post_div <= post_div_max; ++post_div) {\n\t\tunsigned diff;\n\t\tamdgpu_pll_get_fb_ref_div(adev, nom, den, post_div, fb_div_max,\n\t\t\t\t\t  ref_div_max, &fb_div, &ref_div);\n\t\tdiff = abs(target_clock - (pll->reference_freq * fb_div) /\n\t\t\t(ref_div * post_div));\n\n\t\tif (diff < diff_best || (diff == diff_best &&\n\t\t    !(pll->flags & AMDGPU_PLL_PREFER_MINM_OVER_MAXP))) {\n\n\t\t\tpost_div_best = post_div;\n\t\t\tdiff_best = diff;\n\t\t}\n\t}\n\tpost_div = post_div_best;\n\n\t \n\tamdgpu_pll_get_fb_ref_div(adev, nom, den, post_div, fb_div_max, ref_div_max,\n\t\t\t\t  &fb_div, &ref_div);\n\n\t \n\t \n\tamdgpu_pll_reduce_ratio(&fb_div, &ref_div, fb_div_min, ref_div_min);\n\n\t \n\tif (pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV && (fb_div % 10)) {\n\t\tfb_div_min = max(fb_div_min, (9 - (fb_div % 10)) * 20 + 60);\n\t\tif (fb_div < fb_div_min) {\n\t\t\tunsigned tmp = DIV_ROUND_UP(fb_div_min, fb_div);\n\t\t\tfb_div *= tmp;\n\t\t\tref_div *= tmp;\n\t\t}\n\t}\n\n\t \n\tif (pll->flags & AMDGPU_PLL_USE_FRAC_FB_DIV) {\n\t\t*fb_div_p = fb_div / 10;\n\t\t*frac_fb_div_p = fb_div % 10;\n\t} else {\n\t\t*fb_div_p = fb_div;\n\t\t*frac_fb_div_p = 0;\n\t}\n\n\t*dot_clock_p = ((pll->reference_freq * *fb_div_p * 10) +\n\t\t\t(pll->reference_freq * *frac_fb_div_p)) /\n\t\t       (ref_div * post_div * 10);\n\t*ref_div_p = ref_div;\n\t*post_div_p = post_div;\n\n\tDRM_DEBUG_KMS(\"%d - %d, pll dividers - fb: %d.%d ref: %d, post %d\\n\",\n\t\t      freq, *dot_clock_p * 10, *fb_div_p, *frac_fb_div_p,\n\t\t      ref_div, post_div);\n}\n\n \nu32 amdgpu_pll_get_use_mask(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc *test_crtc;\n\tstruct amdgpu_crtc *test_amdgpu_crtc;\n\tu32 pll_in_use = 0;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\n\t\ttest_amdgpu_crtc = to_amdgpu_crtc(test_crtc);\n\t\tif (test_amdgpu_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\tpll_in_use |= (1 << test_amdgpu_crtc->pll_id);\n\t}\n\treturn pll_in_use;\n}\n\n \nint amdgpu_pll_get_shared_dp_ppll(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc *test_crtc;\n\tstruct amdgpu_crtc *test_amdgpu_crtc;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\t\ttest_amdgpu_crtc = to_amdgpu_crtc(test_crtc);\n\t\tif (test_amdgpu_crtc->encoder &&\n\t\t    ENCODER_MODE_IS_DP(amdgpu_atombios_encoder_get_encoder_mode(test_amdgpu_crtc->encoder))) {\n\t\t\t \n\t\t\tif (test_amdgpu_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\t\treturn test_amdgpu_crtc->pll_id;\n\t\t}\n\t}\n\treturn ATOM_PPLL_INVALID;\n}\n\n \nint amdgpu_pll_get_shared_nondp_ppll(struct drm_crtc *crtc)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc *test_crtc;\n\tstruct amdgpu_crtc *test_amdgpu_crtc;\n\tu32 adjusted_clock, test_adjusted_clock;\n\n\tadjusted_clock = amdgpu_crtc->adjusted_clock;\n\n\tif (adjusted_clock == 0)\n\t\treturn ATOM_PPLL_INVALID;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\t\ttest_amdgpu_crtc = to_amdgpu_crtc(test_crtc);\n\t\tif (test_amdgpu_crtc->encoder &&\n\t\t    !ENCODER_MODE_IS_DP(amdgpu_atombios_encoder_get_encoder_mode(test_amdgpu_crtc->encoder))) {\n\t\t\t \n\t\t\tif (test_amdgpu_crtc->connector == amdgpu_crtc->connector) {\n\t\t\t\t \n\t\t\t\tif (test_amdgpu_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\t\t\treturn test_amdgpu_crtc->pll_id;\n\t\t\t}\n\t\t\t \n\t\t\ttest_adjusted_clock = test_amdgpu_crtc->adjusted_clock;\n\t\t\tif ((crtc->mode.clock == test_crtc->mode.clock) &&\n\t\t\t    (adjusted_clock == test_adjusted_clock) &&\n\t\t\t    (amdgpu_crtc->ss_enabled == test_amdgpu_crtc->ss_enabled) &&\n\t\t\t    (test_amdgpu_crtc->pll_id != ATOM_PPLL_INVALID))\n\t\t\t\treturn test_amdgpu_crtc->pll_id;\n\t\t}\n\t}\n\treturn ATOM_PPLL_INVALID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}