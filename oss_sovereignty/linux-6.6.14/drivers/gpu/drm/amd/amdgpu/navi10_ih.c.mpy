{
  "module_name": "navi10_ih.c",
  "hash_id": "0e5b5eabc223efe613aee285bec734d21ee5658ba8b7f235d7882226f144b130",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/navi10_ih.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_ih.h\"\n\n#include \"oss/osssys_5_0_0_offset.h\"\n#include \"oss/osssys_5_0_0_sh_mask.h\"\n\n#include \"soc15_common.h\"\n#include \"navi10_ih.h\"\n\n#define MAX_REARM_RETRY 10\n\n#define mmIH_CHICKEN_Sienna_Cichlid                 0x018d\n#define mmIH_CHICKEN_Sienna_Cichlid_BASE_IDX        0\n\nstatic void navi10_ih_set_interrupt_funcs(struct amdgpu_device *adev);\n\n \nstatic void navi10_ih_init_register_offset(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (adev->irq.ih.ring_size) {\n\t\tih_regs = &adev->irq.ih.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR);\n\t\tih_regs->ih_rb_wptr_addr_lo = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_LO);\n\t\tih_regs->ih_rb_wptr_addr_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_HI);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL;\n\t}\n\n\tif (adev->irq.ih1.ring_size) {\n\t\tih_regs = &adev->irq.ih1.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_RING1);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI_RING1);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL_RING1);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_RING1);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR_RING1);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR_RING1);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL_RING1;\n\t}\n\n\tif (adev->irq.ih2.ring_size) {\n\t\tih_regs = &adev->irq.ih2.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_RING2);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI_RING2);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL_RING2);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_RING2);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR_RING2);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR_RING2);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL_RING2;\n\t}\n}\n\n \nstatic void\nforce_update_wptr_for_self_int(struct amdgpu_device *adev,\n\t\t\t       u32 threshold, u32 timeout, bool enabled)\n{\n\tu32 ih_cntl, ih_rb_cntl;\n\n\tif (adev->ip_versions[OSSSYS_HWIP][0] < IP_VERSION(5, 0, 3))\n\t\treturn;\n\n\tih_cntl = RREG32_SOC15(OSSSYS, 0, mmIH_CNTL2);\n\tih_rb_cntl = RREG32_SOC15(OSSSYS, 0, mmIH_RB_CNTL_RING1);\n\n\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL2,\n\t\t\t\tSELF_IV_FORCE_WPTR_UPDATE_TIMEOUT, timeout);\n\tih_cntl = REG_SET_FIELD(ih_cntl, IH_CNTL2,\n\t\t\t\tSELF_IV_FORCE_WPTR_UPDATE_ENABLE, enabled);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL_RING1,\n\t\t\t\t   RB_USED_INT_THRESHOLD, threshold);\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_sriov_reg_indirect_ih(adev)) {\n\t\tif (psp_reg_program(&adev->psp, PSP_REG_IH_RB_CNTL_RING1, ih_rb_cntl))\n\t\t\treturn;\n\t} else {\n\t\tWREG32_SOC15(OSSSYS, 0, mmIH_RB_CNTL_RING1, ih_rb_cntl);\n\t}\n\n\tih_rb_cntl = RREG32_SOC15(OSSSYS, 0, mmIH_RB_CNTL_RING2);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL_RING2,\n\t\t\t\t   RB_USED_INT_THRESHOLD, threshold);\n\tif (amdgpu_sriov_vf(adev) && amdgpu_sriov_reg_indirect_ih(adev)) {\n\t\tif (psp_reg_program(&adev->psp, PSP_REG_IH_RB_CNTL_RING2, ih_rb_cntl))\n\t\t\treturn;\n\t} else {\n\t\tWREG32_SOC15(OSSSYS, 0, mmIH_RB_CNTL_RING2, ih_rb_cntl);\n\t}\n\n\tWREG32_SOC15(OSSSYS, 0, mmIH_CNTL2, ih_cntl);\n}\n\n \nstatic int navi10_ih_toggle_ring_interrupts(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_ih_ring *ih,\n\t\t\t\t\t    bool enable)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\tuint32_t tmp;\n\n\tih_regs = &ih->ih_regs;\n\n\ttmp = RREG32(ih_regs->ih_rb_cntl);\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_ENABLE, (enable ? 1 : 0));\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_GPU_TS_ENABLE, 1);\n\t \n\tif (ih == &adev->irq.ih)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, ENABLE_INTR, (enable ? 1 : 0));\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_sriov_reg_indirect_ih(adev)) {\n\t\tif (psp_reg_program(&adev->psp, ih_regs->psp_reg_id, tmp))\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\tWREG32(ih_regs->ih_rb_cntl, tmp);\n\t}\n\n\tif (enable) {\n\t\tih->enabled = true;\n\t} else {\n\t\t \n\t\tWREG32(ih_regs->ih_rb_rptr, 0);\n\t\tWREG32(ih_regs->ih_rb_wptr, 0);\n\t\tih->enabled = false;\n\t\tih->rptr = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int navi10_ih_toggle_interrupts(struct amdgpu_device *adev, bool enable)\n{\n\tstruct amdgpu_ih_ring *ih[] = {&adev->irq.ih, &adev->irq.ih1, &adev->irq.ih2};\n\tint i;\n\tint r;\n\n\tfor (i = 0; i < ARRAY_SIZE(ih); i++) {\n\t\tif (ih[i]->ring_size) {\n\t\t\tr = navi10_ih_toggle_ring_interrupts(adev, ih[i], enable);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic uint32_t navi10_ih_rb_cntl(struct amdgpu_ih_ring *ih, uint32_t ih_rb_cntl)\n{\n\tint rb_bufsz = order_base_2(ih->ring_size / 4);\n\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   MC_SPACE, ih->use_bus_addr ? 1 : 4);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_OVERFLOW_CLEAR, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_OVERFLOW_ENABLE, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_SIZE, rb_bufsz);\n\t \n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_WRITEBACK_ENABLE, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_SNOOP, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_RO, 0);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_VMID, 0);\n\n\treturn ih_rb_cntl;\n}\n\nstatic uint32_t navi10_ih_doorbell_rptr(struct amdgpu_ih_ring *ih)\n{\n\tu32 ih_doorbell_rtpr = 0;\n\n\tif (ih->use_doorbell) {\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR, OFFSET,\n\t\t\t\t\t\t ih->doorbell_index);\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR,\n\t\t\t\t\t\t ENABLE, 1);\n\t} else {\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR,\n\t\t\t\t\t\t ENABLE, 0);\n\t}\n\treturn ih_doorbell_rtpr;\n}\n\n \nstatic int navi10_ih_enable_ring(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_ih_ring *ih)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\tuint32_t tmp;\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\tWREG32(ih_regs->ih_rb_base, ih->gpu_addr >> 8);\n\tWREG32(ih_regs->ih_rb_base_hi, (ih->gpu_addr >> 40) & 0xff);\n\n\ttmp = RREG32(ih_regs->ih_rb_cntl);\n\ttmp = navi10_ih_rb_cntl(ih, tmp);\n\tif (ih == &adev->irq.ih)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RPTR_REARM, !!adev->irq.msi_enabled);\n\tif (ih == &adev->irq.ih1)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_FULL_DRAIN_ENABLE, 1);\n\n\tif (amdgpu_sriov_vf(adev) && amdgpu_sriov_reg_indirect_ih(adev)) {\n\t\tif (psp_reg_program(&adev->psp, ih_regs->psp_reg_id, tmp)) {\n\t\t\tDRM_ERROR(\"PSP program IH_RB_CNTL failed!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tWREG32(ih_regs->ih_rb_cntl, tmp);\n\t}\n\n\tif (ih == &adev->irq.ih) {\n\t\t \n\t\tWREG32(ih_regs->ih_rb_wptr_addr_lo, lower_32_bits(ih->wptr_addr));\n\t\tWREG32(ih_regs->ih_rb_wptr_addr_hi, upper_32_bits(ih->wptr_addr) & 0xFFFF);\n\t}\n\n\t \n\tWREG32(ih_regs->ih_rb_wptr, 0);\n\tWREG32(ih_regs->ih_rb_rptr, 0);\n\n\tWREG32(ih_regs->ih_doorbell_rptr, navi10_ih_doorbell_rptr(ih));\n\n\treturn 0;\n}\n\n \nstatic int navi10_ih_irq_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ih_ring *ih[] = {&adev->irq.ih, &adev->irq.ih1, &adev->irq.ih2};\n\tu32 ih_chicken;\n\tint ret;\n\tint i;\n\n\t \n\tret = navi10_ih_toggle_interrupts(adev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tadev->nbio.funcs->ih_control(adev);\n\n\tif (unlikely(adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT)) {\n\t\tif (ih[0]->use_bus_addr) {\n\t\t\tswitch (adev->ip_versions[OSSSYS_HWIP][0]) {\n\t\t\tcase IP_VERSION(5, 0, 3):\n\t\t\tcase IP_VERSION(5, 2, 0):\n\t\t\tcase IP_VERSION(5, 2, 1):\n\t\t\t\tih_chicken = RREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN_Sienna_Cichlid);\n\t\t\t\tih_chicken = REG_SET_FIELD(ih_chicken,\n\t\t\t\t\t\tIH_CHICKEN, MC_SPACE_GPA_ENABLE, 1);\n\t\t\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN_Sienna_Cichlid, ih_chicken);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tih_chicken = RREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN);\n\t\t\t\tih_chicken = REG_SET_FIELD(ih_chicken,\n\t\t\t\t\t\tIH_CHICKEN, MC_SPACE_GPA_ENABLE, 1);\n\t\t\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN, ih_chicken);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ih); i++) {\n\t\tif (ih[i]->ring_size) {\n\t\t\tret = navi10_ih_enable_ring(adev, ih[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tadev->nbio.funcs->ih_doorbell_range(adev, ih[0]->use_doorbell,\n\t\t\t\t\t    ih[0]->doorbell_index);\n\n\tpci_set_master(adev->pdev);\n\n\t \n\tret = navi10_ih_toggle_interrupts(adev, true);\n\tif (ret)\n\t\treturn ret;\n\t \n\tforce_update_wptr_for_self_int(adev, 0, 8, true);\n\n\tif (adev->irq.ih_soft.ring_size)\n\t\tadev->irq.ih_soft.enabled = true;\n\n\treturn 0;\n}\n\n \nstatic void navi10_ih_irq_disable(struct amdgpu_device *adev)\n{\n\tforce_update_wptr_for_self_int(adev, 0, 8, false);\n\tnavi10_ih_toggle_interrupts(adev, false);\n\n\t \n\tmdelay(1);\n}\n\n \nstatic u32 navi10_ih_get_wptr(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_ih_ring *ih)\n{\n\tu32 wptr, tmp;\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (ih == &adev->irq.ih || ih == &adev->irq.ih_soft) {\n\t\t \n\t\twptr = le32_to_cpu(*ih->wptr_cpu);\n\n\t\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\t\tgoto out;\n\t}\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\twptr = RREG32_NO_KIQ(ih_regs->ih_rb_wptr);\n\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\tgoto out;\n\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);\n\n\t \n\ttmp = (wptr + 32) & ih->ptr_mask;\n\tdev_warn(adev->dev, \"IH ring buffer overflow \"\n\t\t \"(0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t wptr, ih->rptr, tmp);\n\tih->rptr = tmp;\n\n\ttmp = RREG32_NO_KIQ(ih_regs->ih_rb_cntl);\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\n\tWREG32_NO_KIQ(ih_regs->ih_rb_cntl, tmp);\nout:\n\treturn (wptr & ih->ptr_mask);\n}\n\n \nstatic void navi10_ih_irq_rearm(struct amdgpu_device *adev,\n\t\t\t       struct amdgpu_ih_ring *ih)\n{\n\tuint32_t v = 0;\n\tuint32_t i = 0;\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\tfor (i = 0; i < MAX_REARM_RETRY; i++) {\n\t\tv = RREG32_NO_KIQ(ih_regs->ih_rb_rptr);\n\t\tif ((v < ih->ring_size) && (v != ih->rptr))\n\t\t\tWDOORBELL32(ih->doorbell_index, ih->rptr);\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void navi10_ih_set_rptr(struct amdgpu_device *adev,\n\t\t\t       struct amdgpu_ih_ring *ih)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (ih == &adev->irq.ih_soft)\n\t\treturn;\n\n\tif (ih->use_doorbell) {\n\t\t \n\t\t*ih->rptr_cpu = ih->rptr;\n\t\tWDOORBELL32(ih->doorbell_index, ih->rptr);\n\n\t\tif (amdgpu_sriov_vf(adev))\n\t\t\tnavi10_ih_irq_rearm(adev, ih);\n\t} else {\n\t\tih_regs = &ih->ih_regs;\n\t\tWREG32(ih_regs->ih_rb_rptr, ih->rptr);\n\t}\n}\n\n \nstatic int navi10_ih_self_irq(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tswitch (entry->ring_id) {\n\tcase 1:\n\t\tschedule_work(&adev->irq.ih1_work);\n\t\tbreak;\n\tcase 2:\n\t\tschedule_work(&adev->irq.ih2_work);\n\t\tbreak;\n\tdefault: break;\n\t}\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs navi10_ih_self_irq_funcs = {\n\t.process = navi10_ih_self_irq,\n};\n\nstatic void navi10_ih_set_self_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->irq.self_irq.num_types = 0;\n\tadev->irq.self_irq.funcs = &navi10_ih_self_irq_funcs;\n}\n\nstatic int navi10_ih_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tnavi10_ih_set_interrupt_funcs(adev);\n\tnavi10_ih_set_self_irq_funcs(adev);\n\treturn 0;\n}\n\nstatic int navi10_ih_sw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool use_bus_addr;\n\n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_IH, 0,\n\t\t\t\t&adev->irq.self_irq);\n\n\tif (r)\n\t\treturn r;\n\n\t \n\tif ((adev->flags & AMD_IS_APU) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP))\n\t\tuse_bus_addr = false;\n\telse\n\t\tuse_bus_addr = true;\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih, IH_RING_SIZE, use_bus_addr);\n\tif (r)\n\t\treturn r;\n\n\tadev->irq.ih.use_doorbell = true;\n\tadev->irq.ih.doorbell_index = adev->doorbell_index.ih << 1;\n\n\tadev->irq.ih1.ring_size = 0;\n\tadev->irq.ih2.ring_size = 0;\n\n\t \n\tnavi10_ih_init_register_offset(adev);\n\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih_soft, IH_SW_RING_SIZE, true);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_init(adev);\n\n\treturn r;\n}\n\nstatic int navi10_ih_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_fini_sw(adev);\n\n\treturn 0;\n}\n\nstatic int navi10_ih_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn navi10_ih_irq_init(adev);\n}\n\nstatic int navi10_ih_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tnavi10_ih_irq_disable(adev);\n\n\treturn 0;\n}\n\nstatic int navi10_ih_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn navi10_ih_hw_fini(adev);\n}\n\nstatic int navi10_ih_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn navi10_ih_hw_init(adev);\n}\n\nstatic bool navi10_ih_is_idle(void *handle)\n{\n\t \n\treturn true;\n}\n\nstatic int navi10_ih_wait_for_idle(void *handle)\n{\n\t \n\treturn -ETIMEDOUT;\n}\n\nstatic int navi10_ih_soft_reset(void *handle)\n{\n\t \n\treturn 0;\n}\n\nstatic void navi10_ih_update_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tuint32_t data, def, field_val;\n\n\tif (adev->cg_flags & AMD_CG_SUPPORT_IH_CG) {\n\t\tdef = data = RREG32_SOC15(OSSSYS, 0, mmIH_CLK_CTRL);\n\t\tfield_val = enable ? 0 : 1;\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     DBUS_MUX_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     OSSSYS_SHARE_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     LIMIT_SMN_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     DYN_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     REG_CLK_SOFT_OVERRIDE, field_val);\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CLK_CTRL, data);\n\t}\n\n\treturn;\n}\n\nstatic int navi10_ih_set_clockgating_state(void *handle,\n\t\t\t\t\t   enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tnavi10_ih_update_clockgating_state(adev,\n\t\t\t\tstate == AMD_CG_STATE_GATE);\n\treturn 0;\n}\n\nstatic int navi10_ih_set_powergating_state(void *handle,\n\t\t\t\t\t   enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\nstatic void navi10_ih_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!RREG32_SOC15(OSSSYS, 0, mmIH_CLK_CTRL))\n\t\t*flags |= AMD_CG_SUPPORT_IH_CG;\n\n\treturn;\n}\n\nstatic const struct amd_ip_funcs navi10_ih_ip_funcs = {\n\t.name = \"navi10_ih\",\n\t.early_init = navi10_ih_early_init,\n\t.late_init = NULL,\n\t.sw_init = navi10_ih_sw_init,\n\t.sw_fini = navi10_ih_sw_fini,\n\t.hw_init = navi10_ih_hw_init,\n\t.hw_fini = navi10_ih_hw_fini,\n\t.suspend = navi10_ih_suspend,\n\t.resume = navi10_ih_resume,\n\t.is_idle = navi10_ih_is_idle,\n\t.wait_for_idle = navi10_ih_wait_for_idle,\n\t.soft_reset = navi10_ih_soft_reset,\n\t.set_clockgating_state = navi10_ih_set_clockgating_state,\n\t.set_powergating_state = navi10_ih_set_powergating_state,\n\t.get_clockgating_state = navi10_ih_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ih_funcs navi10_ih_funcs = {\n\t.get_wptr = navi10_ih_get_wptr,\n\t.decode_iv = amdgpu_ih_decode_iv_helper,\n\t.decode_iv_ts = amdgpu_ih_decode_iv_ts_helper,\n\t.set_rptr = navi10_ih_set_rptr\n};\n\nstatic void navi10_ih_set_interrupt_funcs(struct amdgpu_device *adev)\n{\n\tif (adev->irq.ih_funcs == NULL)\n\t\tadev->irq.ih_funcs = &navi10_ih_funcs;\n}\n\nconst struct amdgpu_ip_block_version navi10_ih_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_IH,\n\t.major = 5,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &navi10_ih_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}