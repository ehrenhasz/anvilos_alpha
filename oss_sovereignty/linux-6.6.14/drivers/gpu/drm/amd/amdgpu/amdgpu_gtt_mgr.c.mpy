{
  "module_name": "amdgpu_gtt_mgr.c",
  "hash_id": "cb512cdeb93322ade293e1b19c3417d916116ff82f6e3abb2a609e263a118156",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_gtt_mgr.c",
  "human_readable_source": " \n\n#include <drm/ttm/ttm_range_manager.h>\n\n#include \"amdgpu.h\"\n\nstatic inline struct amdgpu_gtt_mgr *\nto_gtt_mgr(struct ttm_resource_manager *man)\n{\n\treturn container_of(man, struct amdgpu_gtt_mgr, manager);\n}\n\n \nstatic ssize_t amdgpu_mem_info_gtt_total_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tstruct ttm_resource_manager *man;\n\n\tman = ttm_manager_type(&adev->mman.bdev, TTM_PL_TT);\n\treturn sysfs_emit(buf, \"%llu\\n\", man->size);\n}\n\n \nstatic ssize_t amdgpu_mem_info_gtt_used_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(ddev);\n\tstruct ttm_resource_manager *man = &adev->mman.gtt_mgr.manager;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", ttm_resource_manager_usage(man));\n}\n\nstatic DEVICE_ATTR(mem_info_gtt_total, S_IRUGO,\n\t           amdgpu_mem_info_gtt_total_show, NULL);\nstatic DEVICE_ATTR(mem_info_gtt_used, S_IRUGO,\n\t           amdgpu_mem_info_gtt_used_show, NULL);\n\nstatic struct attribute *amdgpu_gtt_mgr_attributes[] = {\n\t&dev_attr_mem_info_gtt_total.attr,\n\t&dev_attr_mem_info_gtt_used.attr,\n\tNULL\n};\n\nconst struct attribute_group amdgpu_gtt_mgr_attr_group = {\n\t.attrs = amdgpu_gtt_mgr_attributes\n};\n\n \nbool amdgpu_gtt_mgr_has_gart_addr(struct ttm_resource *res)\n{\n\tstruct ttm_range_mgr_node *node = to_ttm_range_mgr_node(res);\n\n\treturn drm_mm_node_allocated(&node->mm_nodes[0]);\n}\n\n \nstatic int amdgpu_gtt_mgr_new(struct ttm_resource_manager *man,\n\t\t\t      struct ttm_buffer_object *tbo,\n\t\t\t      const struct ttm_place *place,\n\t\t\t      struct ttm_resource **res)\n{\n\tstruct amdgpu_gtt_mgr *mgr = to_gtt_mgr(man);\n\tuint32_t num_pages = PFN_UP(tbo->base.size);\n\tstruct ttm_range_mgr_node *node;\n\tint r;\n\n\tnode = kzalloc(struct_size(node, mm_nodes, 1), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tttm_resource_init(tbo, place, &node->base);\n\tif (!(place->flags & TTM_PL_FLAG_TEMPORARY) &&\n\t    ttm_resource_manager_usage(man) > man->size) {\n\t\tr = -ENOSPC;\n\t\tgoto err_free;\n\t}\n\n\tif (place->lpfn) {\n\t\tspin_lock(&mgr->lock);\n\t\tr = drm_mm_insert_node_in_range(&mgr->mm, &node->mm_nodes[0],\n\t\t\t\t\t\tnum_pages, tbo->page_alignment,\n\t\t\t\t\t\t0, place->fpfn, place->lpfn,\n\t\t\t\t\t\tDRM_MM_INSERT_BEST);\n\t\tspin_unlock(&mgr->lock);\n\t\tif (unlikely(r))\n\t\t\tgoto err_free;\n\n\t\tnode->base.start = node->mm_nodes[0].start;\n\t} else {\n\t\tnode->mm_nodes[0].start = 0;\n\t\tnode->mm_nodes[0].size = PFN_UP(node->base.size);\n\t\tnode->base.start = AMDGPU_BO_INVALID_OFFSET;\n\t}\n\n\t*res = &node->base;\n\treturn 0;\n\nerr_free:\n\tttm_resource_fini(man, &node->base);\n\tkfree(node);\n\treturn r;\n}\n\n \nstatic void amdgpu_gtt_mgr_del(struct ttm_resource_manager *man,\n\t\t\t       struct ttm_resource *res)\n{\n\tstruct ttm_range_mgr_node *node = to_ttm_range_mgr_node(res);\n\tstruct amdgpu_gtt_mgr *mgr = to_gtt_mgr(man);\n\n\tspin_lock(&mgr->lock);\n\tif (drm_mm_node_allocated(&node->mm_nodes[0]))\n\t\tdrm_mm_remove_node(&node->mm_nodes[0]);\n\tspin_unlock(&mgr->lock);\n\n\tttm_resource_fini(man, res);\n\tkfree(node);\n}\n\n \nvoid amdgpu_gtt_mgr_recover(struct amdgpu_gtt_mgr *mgr)\n{\n\tstruct ttm_range_mgr_node *node;\n\tstruct drm_mm_node *mm_node;\n\tstruct amdgpu_device *adev;\n\n\tadev = container_of(mgr, typeof(*adev), mman.gtt_mgr);\n\tspin_lock(&mgr->lock);\n\tdrm_mm_for_each_node(mm_node, &mgr->mm) {\n\t\tnode = container_of(mm_node, typeof(*node), mm_nodes[0]);\n\t\tamdgpu_ttm_recover_gart(node->base.bo);\n\t}\n\tspin_unlock(&mgr->lock);\n\n\tamdgpu_gart_invalidate_tlb(adev);\n}\n\n \nstatic bool amdgpu_gtt_mgr_intersects(struct ttm_resource_manager *man,\n\t\t\t\t      struct ttm_resource *res,\n\t\t\t\t      const struct ttm_place *place,\n\t\t\t\t      size_t size)\n{\n\treturn !place->lpfn || amdgpu_gtt_mgr_has_gart_addr(res);\n}\n\n \nstatic bool amdgpu_gtt_mgr_compatible(struct ttm_resource_manager *man,\n\t\t\t\t      struct ttm_resource *res,\n\t\t\t\t      const struct ttm_place *place,\n\t\t\t\t      size_t size)\n{\n\treturn !place->lpfn || amdgpu_gtt_mgr_has_gart_addr(res);\n}\n\n \nstatic void amdgpu_gtt_mgr_debug(struct ttm_resource_manager *man,\n\t\t\t\t struct drm_printer *printer)\n{\n\tstruct amdgpu_gtt_mgr *mgr = to_gtt_mgr(man);\n\n\tspin_lock(&mgr->lock);\n\tdrm_mm_print(&mgr->mm, printer);\n\tspin_unlock(&mgr->lock);\n}\n\nstatic const struct ttm_resource_manager_func amdgpu_gtt_mgr_func = {\n\t.alloc = amdgpu_gtt_mgr_new,\n\t.free = amdgpu_gtt_mgr_del,\n\t.intersects = amdgpu_gtt_mgr_intersects,\n\t.compatible = amdgpu_gtt_mgr_compatible,\n\t.debug = amdgpu_gtt_mgr_debug\n};\n\n \nint amdgpu_gtt_mgr_init(struct amdgpu_device *adev, uint64_t gtt_size)\n{\n\tstruct amdgpu_gtt_mgr *mgr = &adev->mman.gtt_mgr;\n\tstruct ttm_resource_manager *man = &mgr->manager;\n\tuint64_t start, size;\n\n\tman->use_tt = true;\n\tman->func = &amdgpu_gtt_mgr_func;\n\n\tttm_resource_manager_init(man, &adev->mman.bdev, gtt_size);\n\n\tstart = AMDGPU_GTT_MAX_TRANSFER_SIZE * AMDGPU_GTT_NUM_TRANSFER_WINDOWS;\n\tsize = (adev->gmc.gart_size >> PAGE_SHIFT) - start;\n\tdrm_mm_init(&mgr->mm, start, size);\n\tspin_lock_init(&mgr->lock);\n\n\tttm_set_driver_manager(&adev->mman.bdev, TTM_PL_TT, &mgr->manager);\n\tttm_resource_manager_set_used(man, true);\n\treturn 0;\n}\n\n \nvoid amdgpu_gtt_mgr_fini(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_gtt_mgr *mgr = &adev->mman.gtt_mgr;\n\tstruct ttm_resource_manager *man = &mgr->manager;\n\tint ret;\n\n\tttm_resource_manager_set_used(man, false);\n\n\tret = ttm_resource_manager_evict_all(&adev->mman.bdev, man);\n\tif (ret)\n\t\treturn;\n\n\tspin_lock(&mgr->lock);\n\tdrm_mm_takedown(&mgr->mm);\n\tspin_unlock(&mgr->lock);\n\n\tttm_resource_manager_cleanup(man);\n\tttm_set_driver_manager(&adev->mman.bdev, TTM_PL_TT, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}