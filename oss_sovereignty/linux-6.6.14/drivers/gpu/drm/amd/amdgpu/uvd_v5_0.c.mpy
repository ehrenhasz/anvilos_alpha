{
  "module_name": "uvd_v5_0.c",
  "hash_id": "ab253e34c1c30b9eb5d141f4097b73d6619d0b9acc0370b1fa54a886d498fc9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_uvd.h\"\n#include \"vid.h\"\n#include \"uvd/uvd_5_0_d.h\"\n#include \"uvd/uvd_5_0_sh_mask.h\"\n#include \"oss/oss_2_0_d.h\"\n#include \"oss/oss_2_0_sh_mask.h\"\n#include \"bif/bif_5_0_d.h\"\n#include \"vi.h\"\n#include \"smu/smu_7_1_2_d.h\"\n#include \"smu/smu_7_1_2_sh_mask.h\"\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n\nstatic void uvd_v5_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void uvd_v5_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic int uvd_v5_0_start(struct amdgpu_device *adev);\nstatic void uvd_v5_0_stop(struct amdgpu_device *adev);\nstatic int uvd_v5_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state);\nstatic void uvd_v5_0_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable);\n \nstatic uint64_t uvd_v5_0_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_RPTR);\n}\n\n \nstatic uint64_t uvd_v5_0_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_WPTR);\n}\n\n \nstatic void uvd_v5_0_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n}\n\nstatic int uvd_v5_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tadev->uvd.num_uvd_inst = 1;\n\n\tuvd_v5_0_set_ring_funcs(adev);\n\tuvd_v5_0_set_irq_funcs(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v5_0_sw_init(void *handle)\n{\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, VISLANDS30_IV_SRCID_UVD_SYSTEM_MESSAGE, &adev->uvd.inst->irq);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tring = &adev->uvd.inst->ring;\n\tsprintf(ring->name, \"uvd\");\n\tr = amdgpu_ring_init(adev, ring, 512, &adev->uvd.inst->irq, 0,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_entity_init(adev);\n\n\treturn r;\n}\n\nstatic int uvd_v5_0_sw_fini(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_suspend(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn amdgpu_uvd_sw_fini(adev);\n}\n\n \nstatic int uvd_v5_0_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t tmp;\n\tint r;\n\n\tamdgpu_asic_set_uvd_clocks(adev, 10000, 10000);\n\tuvd_v5_0_set_clockgating_state(adev, AMD_CG_STATE_UNGATE);\n\tuvd_v5_0_enable_mgcg(adev, true);\n\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\tgoto done;\n\n\tr = amdgpu_ring_alloc(ring, 10);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: ring failed to lock UVD ring (%d).\\n\", r);\n\t\tgoto done;\n\t}\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\t \n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_TIMEOUT_STATUS, 0));\n\tamdgpu_ring_write(ring, 0x8);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_CNTL, 0));\n\tamdgpu_ring_write(ring, 3);\n\n\tamdgpu_ring_commit(ring);\n\ndone:\n\tif (!r)\n\t\tDRM_INFO(\"UVD initialized successfully.\\n\");\n\n\treturn r;\n\n}\n\n \nstatic int uvd_v5_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (RREG32(mmUVD_STATUS) != 0)\n\t\tuvd_v5_0_stop(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v5_0_suspend(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (adev->pm.dpm_enabled) {\n\t\tamdgpu_dpm_enable_uvd(adev, false);\n\t} else {\n\t\tamdgpu_asic_set_uvd_clocks(adev, 0, 0);\n\t\t \n\t\tamdgpu_device_ip_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_PG_STATE_GATE);\n\t\tamdgpu_device_ip_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_CG_STATE_GATE);\n\t}\n\n\tr = uvd_v5_0_hw_fini(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn amdgpu_uvd_suspend(adev);\n}\n\nstatic int uvd_v5_0_resume(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn uvd_v5_0_hw_init(adev);\n}\n\n \nstatic void uvd_v5_0_mc_resume(struct amdgpu_device *adev)\n{\n\tuint64_t offset;\n\tuint32_t size;\n\n\t \n\tWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_LOW,\n\t\t\tlower_32_bits(adev->uvd.inst->gpu_addr));\n\tWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_HIGH,\n\t\t\tupper_32_bits(adev->uvd.inst->gpu_addr));\n\n\toffset = AMDGPU_UVD_FIRMWARE_OFFSET;\n\tsize = AMDGPU_UVD_FIRMWARE_SIZE(adev);\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET0, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE0, size);\n\n\toffset += size;\n\tsize = AMDGPU_UVD_HEAP_SIZE;\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET1, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE1, size);\n\n\toffset += size;\n\tsize = AMDGPU_UVD_STACK_SIZE +\n\t       (AMDGPU_UVD_SESSION_SIZE * adev->uvd.max_handles);\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET2, offset >> 3);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE2, size);\n\n\tWREG32(mmUVD_UDEC_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DBW_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n}\n\n \nstatic int uvd_v5_0_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t rb_bufsz, tmp;\n\tuint32_t lmi_swap_cntl;\n\tuint32_t mp_swap_cntl;\n\tint i, j, r;\n\n\t \n\tWREG32_P(mmUVD_POWER_STATUS, 0, ~(1 << 2));\n\n\t \n\tlmi_swap_cntl = 0;\n\tmp_swap_cntl = 0;\n\n\tuvd_v5_0_mc_resume(adev);\n\n\t \n\tWREG32_P(mmUVD_MASTINT_EN, 0, ~(1 << 1));\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\tmdelay(1);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK | UVD_SOFT_RESET__LBSI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__RBC_SOFT_RESET_MASK | UVD_SOFT_RESET__CSM_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__CXW_SOFT_RESET_MASK | UVD_SOFT_RESET__TAP_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32_P(mmSRBM_SOFT_RESET, 0, ~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_LMI_CTRL, 0x40 | (1 << 8) | (1 << 13) |\n\t\t\t     (1 << 21) | (1 << 9) | (1 << 20));\n\n#ifdef __BIG_ENDIAN\n\t \n\tlmi_swap_cntl = 0xa;\n\tmp_swap_cntl = 0;\n#endif\n\tWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\n\tWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\n\n\tWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\n\tWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\n\tWREG32(mmUVD_MPC_SET_ALU, 0);\n\tWREG32(mmUVD_MPC_SET_MUX, 0x88);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_VCPU_CNTL,  1 << 9);\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, 0);\n\tmdelay(10);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR(\"UVD not responding, trying to reset the VCPU!!!\\n\");\n\t\tWREG32_P(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK,\n\t\t\t\t~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\t\tmdelay(10);\n\t\tWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\tif (r) {\n\t\tDRM_ERROR(\"UVD not responding, giving up!!!\\n\");\n\t\treturn r;\n\t}\n\t \n\tWREG32_P(mmUVD_MASTINT_EN, 3 << 1, ~(3 << 1));\n\n\t \n\tWREG32_P(mmUVD_STATUS, 0, ~(2 << 1));\n\n\trb_bufsz = order_base_2(ring->ring_size);\n\ttmp = 0;\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_BLKSZ, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_FETCH, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_WPTR_POLL_EN, 0);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_UPDATE, 1);\n\ttmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_RPTR_WR_EN, 1);\n\t \n\tWREG32(mmUVD_RBC_RB_CNTL, tmp);\n\n\t \n\tWREG32(mmUVD_RBC_RB_WPTR_CNTL, 0);\n\n\t \n\tWREG32(mmUVD_RBC_RB_RPTR_ADDR, (upper_32_bits(ring->gpu_addr) >> 2));\n\n\t \n\tWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_LOW,\n\t\t\tlower_32_bits(ring->gpu_addr));\n\tWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_HIGH,\n\t\t\tupper_32_bits(ring->gpu_addr));\n\n\t \n\tWREG32(mmUVD_RBC_RB_RPTR, 0);\n\n\tring->wptr = RREG32(mmUVD_RBC_RB_RPTR);\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n\n\tWREG32_P(mmUVD_RBC_RB_CNTL, 0, ~UVD_RBC_RB_CNTL__RB_NO_FETCH_MASK);\n\n\treturn 0;\n}\n\n \nstatic void uvd_v5_0_stop(struct amdgpu_device *adev)\n{\n\t \n\tWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\tmdelay(1);\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_VCPU_CNTL, 0x0);\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\n\n\tWREG32(mmUVD_STATUS, 0);\n}\n\n \nstatic void uvd_v5_0_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\n\t\t\t\t     unsigned flags)\n{\n\tWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, addr & 0xffffffff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr) & 0xff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 2);\n}\n\n \nstatic int uvd_v5_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(mmUVD_CONTEXT_ID, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(mmUVD_CONTEXT_ID);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\n \nstatic void uvd_v5_0_ring_emit_ib(struct amdgpu_ring *ring,\n\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t  uint32_t flags)\n{\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_LOW, 0));\n\tamdgpu_ring_write(ring, lower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_HIGH, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_SIZE, 0));\n\tamdgpu_ring_write(ring, ib->length_dw);\n}\n\nstatic void uvd_v5_0_ring_insert_nop(struct amdgpu_ring *ring, uint32_t count)\n{\n\tint i;\n\n\tWARN_ON(ring->wptr % 2 || count % 2);\n\n\tfor (i = 0; i < count / 2; i++) {\n\t\tamdgpu_ring_write(ring, PACKET0(mmUVD_NO_OP, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\nstatic bool uvd_v5_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);\n}\n\nstatic int uvd_v5_0_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))\n\t\t\treturn 0;\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int uvd_v5_0_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tuvd_v5_0_stop(adev);\n\n\tWREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,\n\t\t\t~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\n\tmdelay(5);\n\n\treturn uvd_v5_0_start(adev);\n}\n\nstatic int uvd_v5_0_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\t\n\treturn 0;\n}\n\nstatic int uvd_v5_0_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tDRM_DEBUG(\"IH: UVD TRAP\\n\");\n\tamdgpu_fence_process(&adev->uvd.inst->ring);\n\treturn 0;\n}\n\nstatic void uvd_v5_0_enable_clock_gating(struct amdgpu_device *adev, bool enable)\n{\n\tuint32_t data1, data3, suvd_flags;\n\n\tdata1 = RREG32(mmUVD_SUVD_CGC_GATE);\n\tdata3 = RREG32(mmUVD_CGC_GATE);\n\n\tsuvd_flags = UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t     UVD_SUVD_CGC_GATE__SDB_MASK;\n\n\tif (enable) {\n\t\tdata3 |= (UVD_CGC_GATE__SYS_MASK     |\n\t\t\tUVD_CGC_GATE__UDEC_MASK      |\n\t\t\tUVD_CGC_GATE__MPEG2_MASK     |\n\t\t\tUVD_CGC_GATE__RBC_MASK       |\n\t\t\tUVD_CGC_GATE__LMI_MC_MASK    |\n\t\t\tUVD_CGC_GATE__IDCT_MASK      |\n\t\t\tUVD_CGC_GATE__MPRD_MASK      |\n\t\t\tUVD_CGC_GATE__MPC_MASK       |\n\t\t\tUVD_CGC_GATE__LBSI_MASK      |\n\t\t\tUVD_CGC_GATE__LRBBM_MASK     |\n\t\t\tUVD_CGC_GATE__UDEC_RE_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_CM_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_IT_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_DB_MASK   |\n\t\t\tUVD_CGC_GATE__UDEC_MP_MASK   |\n\t\t\tUVD_CGC_GATE__WCB_MASK       |\n\t\t\tUVD_CGC_GATE__JPEG_MASK      |\n\t\t\tUVD_CGC_GATE__SCPU_MASK);\n\t\t \n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\n\t\t\tdata3 |= UVD_CGC_GATE__VCPU_MASK;\n\t\tdata3 &= ~UVD_CGC_GATE__REGS_MASK;\n\t\tdata1 |= suvd_flags;\n\t} else {\n\t\tdata3 = 0;\n\t\tdata1 = 0;\n\t}\n\n\tWREG32(mmUVD_SUVD_CGC_GATE, data1);\n\tWREG32(mmUVD_CGC_GATE, data3);\n}\n\nstatic void uvd_v5_0_set_sw_clock_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data, data2;\n\n\tdata = RREG32(mmUVD_CGC_CTRL);\n\tdata2 = RREG32(mmUVD_SUVD_CGC_CTRL);\n\n\n\tdata &= ~(UVD_CGC_CTRL__CLK_OFF_DELAY_MASK |\n\t\t  UVD_CGC_CTRL__CLK_GATE_DLY_TIMER_MASK);\n\n\n\tdata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK |\n\t\t(1 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_GATE_DLY_TIMER)) |\n\t\t(4 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_OFF_DELAY));\n\n\tdata &= ~(UVD_CGC_CTRL__UDEC_RE_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_CM_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_IT_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_DB_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_MP_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__SYS_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__UDEC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPEG2_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__REGS_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__RBC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LMI_MC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LMI_UMC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__IDCT_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPRD_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__MPC_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LBSI_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__LRBBM_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__WCB_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__VCPU_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__JPEG_MODE_MASK |\n\t\t\tUVD_CGC_CTRL__SCPU_MODE_MASK);\n\tdata2 &= ~(UVD_SUVD_CGC_CTRL__SRE_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SIT_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SMP_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SCM_MODE_MASK |\n\t\t\tUVD_SUVD_CGC_CTRL__SDB_MODE_MASK);\n\n\tWREG32(mmUVD_CGC_CTRL, data);\n\tWREG32(mmUVD_SUVD_CGC_CTRL, data2);\n}\n\n#if 0\nstatic void uvd_v5_0_set_hw_clock_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data, data1, cgc_flags, suvd_flags;\n\n\tdata = RREG32(mmUVD_CGC_GATE);\n\tdata1 = RREG32(mmUVD_SUVD_CGC_GATE);\n\n\tcgc_flags = UVD_CGC_GATE__SYS_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MASK |\n\t\t\t\tUVD_CGC_GATE__MPEG2_MASK |\n\t\t\t\tUVD_CGC_GATE__RBC_MASK |\n\t\t\t\tUVD_CGC_GATE__LMI_MC_MASK |\n\t\t\t\tUVD_CGC_GATE__IDCT_MASK |\n\t\t\t\tUVD_CGC_GATE__MPRD_MASK |\n\t\t\t\tUVD_CGC_GATE__MPC_MASK |\n\t\t\t\tUVD_CGC_GATE__LBSI_MASK |\n\t\t\t\tUVD_CGC_GATE__LRBBM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_RE_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_CM_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_IT_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_DB_MASK |\n\t\t\t\tUVD_CGC_GATE__UDEC_MP_MASK |\n\t\t\t\tUVD_CGC_GATE__WCB_MASK |\n\t\t\t\tUVD_CGC_GATE__VCPU_MASK |\n\t\t\t\tUVD_CGC_GATE__SCPU_MASK;\n\n\tsuvd_flags = UVD_SUVD_CGC_GATE__SRE_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SIT_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SMP_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SCM_MASK |\n\t\t\t\tUVD_SUVD_CGC_GATE__SDB_MASK;\n\n\tdata |= cgc_flags;\n\tdata1 |= suvd_flags;\n\n\tWREG32(mmUVD_CGC_GATE, data);\n\tWREG32(mmUVD_SUVD_CGC_GATE, data1);\n}\n#endif\n\nstatic void uvd_v5_0_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_UVD_MGCG)) {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata |= 0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t} else {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata &= ~0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata &= ~UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t}\n}\n\nstatic int uvd_v5_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_CG_STATE_GATE);\n\n\tif (enable) {\n\t\t \n\t\tif (uvd_v5_0_wait_for_idle(handle))\n\t\t\treturn -EBUSY;\n\t\tuvd_v5_0_enable_clock_gating(adev, true);\n\n\t\t \n \n\t} else {\n\t\tuvd_v5_0_enable_clock_gating(adev, false);\n\t}\n\n\tuvd_v5_0_set_sw_clock_gating(adev);\n\treturn 0;\n}\n\nstatic int uvd_v5_0_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\t \n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint ret = 0;\n\n\tif (state == AMD_PG_STATE_GATE) {\n\t\tuvd_v5_0_stop(adev);\n\t} else {\n\t\tret = uvd_v5_0_start(adev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void uvd_v5_0_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint data;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tif (RREG32_SMC(ixCURRENT_PG_STATUS) &\n\t\t\t\tCURRENT_PG_STATUS__UVD_PG_STATUS_MASK) {\n\t\tDRM_INFO(\"Cannot get clockgating state when UVD is powergated.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tdata = RREG32(mmUVD_CGC_CTRL);\n\tif (data & UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_UVD_MGCG;\n\nout:\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nstatic const struct amd_ip_funcs uvd_v5_0_ip_funcs = {\n\t.name = \"uvd_v5_0\",\n\t.early_init = uvd_v5_0_early_init,\n\t.late_init = NULL,\n\t.sw_init = uvd_v5_0_sw_init,\n\t.sw_fini = uvd_v5_0_sw_fini,\n\t.hw_init = uvd_v5_0_hw_init,\n\t.hw_fini = uvd_v5_0_hw_fini,\n\t.suspend = uvd_v5_0_suspend,\n\t.resume = uvd_v5_0_resume,\n\t.is_idle = uvd_v5_0_is_idle,\n\t.wait_for_idle = uvd_v5_0_wait_for_idle,\n\t.soft_reset = uvd_v5_0_soft_reset,\n\t.set_clockgating_state = uvd_v5_0_set_clockgating_state,\n\t.set_powergating_state = uvd_v5_0_set_powergating_state,\n\t.get_clockgating_state = uvd_v5_0_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ring_funcs uvd_v5_0_ring_funcs = {\n\t.type = AMDGPU_RING_TYPE_UVD,\n\t.align_mask = 0xf,\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.get_rptr = uvd_v5_0_ring_get_rptr,\n\t.get_wptr = uvd_v5_0_ring_get_wptr,\n\t.set_wptr = uvd_v5_0_ring_set_wptr,\n\t.parse_cs = amdgpu_uvd_ring_parse_cs,\n\t.emit_frame_size =\n\t\t14,  \n\t.emit_ib_size = 6,  \n\t.emit_ib = uvd_v5_0_ring_emit_ib,\n\t.emit_fence = uvd_v5_0_ring_emit_fence,\n\t.test_ring = uvd_v5_0_ring_test_ring,\n\t.test_ib = amdgpu_uvd_ring_test_ib,\n\t.insert_nop = uvd_v5_0_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_uvd_ring_begin_use,\n\t.end_use = amdgpu_uvd_ring_end_use,\n};\n\nstatic void uvd_v5_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tadev->uvd.inst->ring.funcs = &uvd_v5_0_ring_funcs;\n}\n\nstatic const struct amdgpu_irq_src_funcs uvd_v5_0_irq_funcs = {\n\t.set = uvd_v5_0_set_interrupt_state,\n\t.process = uvd_v5_0_process_interrupt,\n};\n\nstatic void uvd_v5_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->uvd.inst->irq.num_types = 1;\n\tadev->uvd.inst->irq.funcs = &uvd_v5_0_irq_funcs;\n}\n\nconst struct amdgpu_ip_block_version uvd_v5_0_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_UVD,\n\t\t.major = 5,\n\t\t.minor = 0,\n\t\t.rev = 0,\n\t\t.funcs = &uvd_v5_0_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}