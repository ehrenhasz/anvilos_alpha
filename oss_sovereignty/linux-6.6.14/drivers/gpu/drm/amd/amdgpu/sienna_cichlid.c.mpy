{
  "module_name": "sienna_cichlid.c",
  "hash_id": "e30572370d517a1a0f55e716f131e05ad14ef8fb58b904992c9a01cd0db43d3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/sienna_cichlid.c",
  "human_readable_source": " \n\n#include \"sienna_cichlid.h\"\n#include \"amdgpu_reset.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_job.h\"\n#include \"amdgpu_ring.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_xgmi.h\"\n\nstatic bool sienna_cichlid_is_mode2_default(struct amdgpu_reset_control *reset_ctl)\n{\n#if 0\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7) &&\n\t    adev->pm.fw_version >= 0x3a5500 && !amdgpu_sriov_vf(adev))\n\t\treturn true;\n#endif\n\treturn amdgpu_reset_method == AMD_RESET_METHOD_MODE2;\n}\n\nstatic struct amdgpu_reset_handler *\nsienna_cichlid_get_reset_handler(struct amdgpu_reset_control *reset_ctl,\n\t\t\t    struct amdgpu_reset_context *reset_context)\n{\n\tstruct amdgpu_reset_handler *handler;\n\n\tif (reset_context->method != AMD_RESET_METHOD_NONE) {\n\t\tlist_for_each_entry(handler, &reset_ctl->reset_handlers,\n\t\t\t\t     handler_list) {\n\t\t\tif (handler->reset_method == reset_context->method)\n\t\t\t\treturn handler;\n\t\t}\n\t}\n\n\tif (sienna_cichlid_is_mode2_default(reset_ctl)) {\n\t\tlist_for_each_entry (handler, &reset_ctl->reset_handlers,\n\t\t\t\t     handler_list) {\n\t\t\tif (handler->reset_method == AMD_RESET_METHOD_MODE2)\n\t\t\t\treturn handler;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int sienna_cichlid_mode2_suspend_ip(struct amdgpu_device *adev)\n{\n\tint r, i;\n\n\tamdgpu_device_set_pg_state(adev, AMD_PG_STATE_UNGATE);\n\tamdgpu_device_set_cg_state(adev, AMD_CG_STATE_UNGATE);\n\n\tfor (i = adev->num_ip_blocks - 1; i >= 0; i--) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA))\n\t\t\tcontinue;\n\n\t\tr = adev->ip_blocks[i].version->funcs->suspend(adev);\n\n\t\tif (r) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"suspend of IP block <%s> failed %d\\n\",\n\t\t\t\tadev->ip_blocks[i].version->funcs->name, r);\n\t\t\treturn r;\n\t\t}\n\t\tadev->ip_blocks[i].status.hw = false;\n\t}\n\n\treturn r;\n}\n\nstatic int\nsienna_cichlid_mode2_prepare_hwcontext(struct amdgpu_reset_control *reset_ctl,\n\t\t\t\t  struct amdgpu_reset_context *reset_context)\n{\n\tint r = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tif (adev->gfxhub.funcs->mode2_save_regs)\n\t\t\tadev->gfxhub.funcs->mode2_save_regs(adev);\n\t\tif (adev->gfxhub.funcs->halt)\n\t\t\tadev->gfxhub.funcs->halt(adev);\n\t\tr = sienna_cichlid_mode2_suspend_ip(adev);\n\t}\n\n\treturn r;\n}\n\nstatic void sienna_cichlid_async_reset(struct work_struct *work)\n{\n\tstruct amdgpu_reset_handler *handler;\n\tstruct amdgpu_reset_control *reset_ctl =\n\t\tcontainer_of(work, struct amdgpu_reset_control, reset_work);\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tlist_for_each_entry(handler, &reset_ctl->reset_handlers,\n\t\t\t     handler_list) {\n\t\tif (handler->reset_method == reset_ctl->active_reset) {\n\t\t\tdev_dbg(adev->dev, \"Resetting device\\n\");\n\t\t\thandler->do_reset(adev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int sienna_cichlid_mode2_reset(struct amdgpu_device *adev)\n{\n\t \n\tpci_clear_master(adev->pdev);\n\treturn amdgpu_dpm_mode2_reset(adev);\n}\n\nstatic int\nsienna_cichlid_mode2_perform_reset(struct amdgpu_reset_control *reset_ctl,\n\t\t\t      struct amdgpu_reset_context *reset_context)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)reset_ctl->handle;\n\tint r;\n\n\tr = sienna_cichlid_mode2_reset(adev);\n\tif (r) {\n\t\tdev_err(adev->dev,\n\t\t\t\"ASIC reset failed with error, %d \", r);\n\t}\n\treturn r;\n}\n\nstatic int sienna_cichlid_mode2_restore_ip(struct amdgpu_device *adev)\n{\n\tint i, r;\n\tstruct psp_context *psp = &adev->psp;\n\n\tr = psp_rlc_autoload_start(psp);\n\tif (r) {\n\t\tdev_err(adev->dev, \"Failed to start rlc autoload\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tif (adev->gfxhub.funcs->mode2_restore_regs)\n\t\tadev->gfxhub.funcs->mode2_restore_regs(adev);\n\tadev->gfxhub.funcs->init(adev);\n\tr = adev->gfxhub.funcs->gart_enable(adev);\n\tif (r) {\n\t\tdev_err(adev->dev, \"GFXHUB gart reenable failed after reset\\n\");\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++) {\n\t\tif (adev->ip_blocks[i].version->type == AMD_IP_BLOCK_TYPE_IH) {\n\t\t\tr = adev->ip_blocks[i].version->funcs->resume(adev);\n\t\t\tif (r) {\n\t\t\t\tdev_err(adev->dev,\n\t\t\t\t\t\"resume of IP block <%s> failed %d\\n\",\n\t\t\t\t\tadev->ip_blocks[i].version->funcs->name, r);\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tadev->ip_blocks[i].status.hw = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA))\n\t\t\tcontinue;\n\t\tr = adev->ip_blocks[i].version->funcs->resume(adev);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"resume of IP block <%s> failed %d\\n\",\n\t\t\t\tadev->ip_blocks[i].version->funcs->name, r);\n\t\t\treturn r;\n\t\t}\n\n\t\tadev->ip_blocks[i].status.hw = true;\n\t}\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++) {\n\t\tif (!(adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_GFX ||\n\t\t      adev->ip_blocks[i].version->type ==\n\t\t\t      AMD_IP_BLOCK_TYPE_SDMA))\n\t\t\tcontinue;\n\n\t\tif (adev->ip_blocks[i].version->funcs->late_init) {\n\t\t\tr = adev->ip_blocks[i].version->funcs->late_init(\n\t\t\t\t(void *)adev);\n\t\t\tif (r) {\n\t\t\t\tdev_err(adev->dev,\n\t\t\t\t\t\"late_init of IP block <%s> failed %d after reset\\n\",\n\t\t\t\t\tadev->ip_blocks[i].version->funcs->name,\n\t\t\t\t\tr);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\tadev->ip_blocks[i].status.late_initialized = true;\n\t}\n\n\tamdgpu_device_set_cg_state(adev, AMD_CG_STATE_GATE);\n\tamdgpu_device_set_pg_state(adev, AMD_PG_STATE_GATE);\n\n\treturn r;\n}\n\nstatic int\nsienna_cichlid_mode2_restore_hwcontext(struct amdgpu_reset_control *reset_ctl,\n\t\t\t\t  struct amdgpu_reset_context *reset_context)\n{\n\tint r;\n\tstruct amdgpu_device *tmp_adev = (struct amdgpu_device *)reset_ctl->handle;\n\n\tdev_info(tmp_adev->dev,\n\t\t\t\"GPU reset succeeded, trying to resume\\n\");\n\tr = sienna_cichlid_mode2_restore_ip(tmp_adev);\n\tif (r)\n\t\tgoto end;\n\n\t \n\tamdgpu_register_gpu_instance(tmp_adev);\n\n\t \n\tamdgpu_ras_resume(tmp_adev);\n\n\tamdgpu_irq_gpu_reset_resume_helper(tmp_adev);\n\n\tr = amdgpu_ib_ring_tests(tmp_adev);\n\tif (r) {\n\t\tdev_err(tmp_adev->dev,\n\t\t\t\"ib ring test failed (%d).\\n\", r);\n\t\tr = -EAGAIN;\n\t\tgoto end;\n\t}\n\nend:\n\tif (r)\n\t\treturn -EAGAIN;\n\telse\n\t\treturn r;\n}\n\nstatic struct amdgpu_reset_handler sienna_cichlid_mode2_handler = {\n\t.reset_method\t\t= AMD_RESET_METHOD_MODE2,\n\t.prepare_env\t\t= NULL,\n\t.prepare_hwcontext\t= sienna_cichlid_mode2_prepare_hwcontext,\n\t.perform_reset\t\t= sienna_cichlid_mode2_perform_reset,\n\t.restore_hwcontext\t= sienna_cichlid_mode2_restore_hwcontext,\n\t.restore_env\t\t= NULL,\n\t.do_reset\t\t= sienna_cichlid_mode2_reset,\n};\n\nint sienna_cichlid_reset_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_reset_control *reset_ctl;\n\n\treset_ctl = kzalloc(sizeof(*reset_ctl), GFP_KERNEL);\n\tif (!reset_ctl)\n\t\treturn -ENOMEM;\n\n\treset_ctl->handle = adev;\n\treset_ctl->async_reset = sienna_cichlid_async_reset;\n\treset_ctl->active_reset = AMD_RESET_METHOD_NONE;\n\treset_ctl->get_reset_handler = sienna_cichlid_get_reset_handler;\n\n\tINIT_LIST_HEAD(&reset_ctl->reset_handlers);\n\tINIT_WORK(&reset_ctl->reset_work, reset_ctl->async_reset);\n\t \n\tamdgpu_reset_add_handler(reset_ctl, &sienna_cichlid_mode2_handler);\n\n\tadev->reset_cntl = reset_ctl;\n\n\treturn 0;\n}\n\nint sienna_cichlid_reset_fini(struct amdgpu_device *adev)\n{\n\tkfree(adev->reset_cntl);\n\tadev->reset_cntl = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}