{
  "module_name": "amdgpu_kms.c",
  "hash_id": "50077d196db2b4bad53dcf01ebe6a1454a71c3eba1115ed241eafffd3468daba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_helper.h>\n#include \"amdgpu_uvd.h\"\n#include \"amdgpu_vce.h\"\n#include \"atom.h\"\n\n#include <linux/vga_switcheroo.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_gem.h\"\n#include \"amdgpu_display.h\"\n#include \"amdgpu_ras.h\"\n#include \"amd_pcie.h\"\n\nvoid amdgpu_unregister_gpu_instance(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_gpu_instance *gpu_instance;\n\tint i;\n\n\tmutex_lock(&mgpu_info.mutex);\n\n\tfor (i = 0; i < mgpu_info.num_gpu; i++) {\n\t\tgpu_instance = &(mgpu_info.gpu_ins[i]);\n\t\tif (gpu_instance->adev == adev) {\n\t\t\tmgpu_info.gpu_ins[i] =\n\t\t\t\tmgpu_info.gpu_ins[mgpu_info.num_gpu - 1];\n\t\t\tmgpu_info.num_gpu--;\n\t\t\tif (adev->flags & AMD_IS_APU)\n\t\t\t\tmgpu_info.num_apu--;\n\t\t\telse\n\t\t\t\tmgpu_info.num_dgpu--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&mgpu_info.mutex);\n}\n\n \nvoid amdgpu_driver_unload_kms(struct drm_device *dev)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tif (adev == NULL)\n\t\treturn;\n\n\tamdgpu_unregister_gpu_instance(adev);\n\n\tif (adev->rmmio == NULL)\n\t\treturn;\n\n\tif (amdgpu_acpi_smart_shift_update(dev, AMDGPU_SS_DRV_UNLOAD))\n\t\tDRM_WARN(\"smart shift update failed\\n\");\n\n\tamdgpu_acpi_fini(adev);\n\tamdgpu_device_fini_hw(adev);\n}\n\nvoid amdgpu_register_gpu_instance(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_gpu_instance *gpu_instance;\n\n\tmutex_lock(&mgpu_info.mutex);\n\n\tif (mgpu_info.num_gpu >= MAX_GPU_INSTANCE) {\n\t\tDRM_ERROR(\"Cannot register more gpu instance\\n\");\n\t\tmutex_unlock(&mgpu_info.mutex);\n\t\treturn;\n\t}\n\n\tgpu_instance = &(mgpu_info.gpu_ins[mgpu_info.num_gpu]);\n\tgpu_instance->adev = adev;\n\tgpu_instance->mgpu_fan_enabled = 0;\n\n\tmgpu_info.num_gpu++;\n\tif (adev->flags & AMD_IS_APU)\n\t\tmgpu_info.num_apu++;\n\telse\n\t\tmgpu_info.num_dgpu++;\n\n\tmutex_unlock(&mgpu_info.mutex);\n}\n\n \nint amdgpu_driver_load_kms(struct amdgpu_device *adev, unsigned long flags)\n{\n\tstruct drm_device *dev;\n\tint r, acpi_status;\n\n\tdev = adev_to_drm(adev);\n\n\t \n\tr = amdgpu_device_init(adev, flags);\n\tif (r) {\n\t\tdev_err(dev->dev, \"Fatal error during GPU init\\n\");\n\t\tgoto out;\n\t}\n\n\tadev->pm.rpm_mode = AMDGPU_RUNPM_NONE;\n\tif (amdgpu_device_supports_px(dev) &&\n\t    (amdgpu_runtime_pm != 0)) {  \n\t\tadev->pm.rpm_mode = AMDGPU_RUNPM_PX;\n\t\tdev_info(adev->dev, \"Using ATPX for runtime pm\\n\");\n\t} else if (amdgpu_device_supports_boco(dev) &&\n\t\t   (amdgpu_runtime_pm != 0)) {  \n\t\tadev->pm.rpm_mode = AMDGPU_RUNPM_BOCO;\n\t\tdev_info(adev->dev, \"Using BOCO for runtime pm\\n\");\n\t} else if (amdgpu_device_supports_baco(dev) &&\n\t\t   (amdgpu_runtime_pm != 0)) {\n\t\tswitch (adev->asic_type) {\n\t\tcase CHIP_VEGA20:\n\t\tcase CHIP_ARCTURUS:\n\t\t\t \n\t\t\tif (amdgpu_runtime_pm > 0)\n\t\t\t\tadev->pm.rpm_mode = AMDGPU_RUNPM_BACO;\n\t\t\tbreak;\n\t\tcase CHIP_VEGA10:\n\t\t\t \n\t\t\tif (!adev->gmc.noretry)\n\t\t\t\tadev->pm.rpm_mode = AMDGPU_RUNPM_BACO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tadev->pm.rpm_mode = AMDGPU_RUNPM_BACO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (adev->pm.rpm_mode == AMDGPU_RUNPM_BACO)\n\t\t\tdev_info(adev->dev, \"Using BACO for runtime pm\\n\");\n\t}\n\n\t \n\n\tacpi_status = amdgpu_acpi_init(adev);\n\tif (acpi_status)\n\t\tdev_dbg(dev->dev, \"Error during ACPI methods call\\n\");\n\n\tif (amdgpu_acpi_smart_shift_update(dev, AMDGPU_SS_DRV_LOAD))\n\t\tDRM_WARN(\"smart shift update failed\\n\");\n\nout:\n\tif (r)\n\t\tamdgpu_driver_unload_kms(dev);\n\n\treturn r;\n}\n\nstatic int amdgpu_firmware_info(struct drm_amdgpu_info_firmware *fw_info,\n\t\t\t\tstruct drm_amdgpu_query_fw *query_fw,\n\t\t\t\tstruct amdgpu_device *adev)\n{\n\tswitch (query_fw->fw_type) {\n\tcase AMDGPU_INFO_FW_VCE:\n\t\tfw_info->ver = adev->vce.fw_version;\n\t\tfw_info->feature = adev->vce.fb_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_UVD:\n\t\tfw_info->ver = adev->uvd.fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_VCN:\n\t\tfw_info->ver = adev->vcn.fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GMC:\n\t\tfw_info->ver = adev->gmc.fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_ME:\n\t\tfw_info->ver = adev->gfx.me_fw_version;\n\t\tfw_info->feature = adev->gfx.me_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_PFP:\n\t\tfw_info->ver = adev->gfx.pfp_fw_version;\n\t\tfw_info->feature = adev->gfx.pfp_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_CE:\n\t\tfw_info->ver = adev->gfx.ce_fw_version;\n\t\tfw_info->feature = adev->gfx.ce_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLC:\n\t\tfw_info->ver = adev->gfx.rlc_fw_version;\n\t\tfw_info->feature = adev->gfx.rlc_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_CNTL:\n\t\tfw_info->ver = adev->gfx.rlc_srlc_fw_version;\n\t\tfw_info->feature = adev->gfx.rlc_srlc_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_GPM_MEM:\n\t\tfw_info->ver = adev->gfx.rlc_srlg_fw_version;\n\t\tfw_info->feature = adev->gfx.rlc_srlg_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_SRM_MEM:\n\t\tfw_info->ver = adev->gfx.rlc_srls_fw_version;\n\t\tfw_info->feature = adev->gfx.rlc_srls_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLCP:\n\t\tfw_info->ver = adev->gfx.rlcp_ucode_version;\n\t\tfw_info->feature = adev->gfx.rlcp_ucode_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_RLCV:\n\t\tfw_info->ver = adev->gfx.rlcv_ucode_version;\n\t\tfw_info->feature = adev->gfx.rlcv_ucode_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_GFX_MEC:\n\t\tif (query_fw->index == 0) {\n\t\t\tfw_info->ver = adev->gfx.mec_fw_version;\n\t\t\tfw_info->feature = adev->gfx.mec_feature_version;\n\t\t} else if (query_fw->index == 1) {\n\t\t\tfw_info->ver = adev->gfx.mec2_fw_version;\n\t\t\tfw_info->feature = adev->gfx.mec2_feature_version;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_SMC:\n\t\tfw_info->ver = adev->pm.fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_TA:\n\t\tswitch (query_fw->index) {\n\t\tcase TA_FW_TYPE_PSP_XGMI:\n\t\t\tfw_info->ver = adev->psp.xgmi_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature = adev->psp.xgmi_context.context\n\t\t\t\t\t\t   .bin_desc.feature_version;\n\t\t\tbreak;\n\t\tcase TA_FW_TYPE_PSP_RAS:\n\t\t\tfw_info->ver = adev->psp.ras_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature = adev->psp.ras_context.context\n\t\t\t\t\t\t   .bin_desc.feature_version;\n\t\t\tbreak;\n\t\tcase TA_FW_TYPE_PSP_HDCP:\n\t\t\tfw_info->ver = adev->psp.hdcp_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature = adev->psp.hdcp_context.context\n\t\t\t\t\t\t   .bin_desc.feature_version;\n\t\t\tbreak;\n\t\tcase TA_FW_TYPE_PSP_DTM:\n\t\t\tfw_info->ver = adev->psp.dtm_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature = adev->psp.dtm_context.context\n\t\t\t\t\t\t   .bin_desc.feature_version;\n\t\t\tbreak;\n\t\tcase TA_FW_TYPE_PSP_RAP:\n\t\t\tfw_info->ver = adev->psp.rap_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature = adev->psp.rap_context.context\n\t\t\t\t\t\t   .bin_desc.feature_version;\n\t\t\tbreak;\n\t\tcase TA_FW_TYPE_PSP_SECUREDISPLAY:\n\t\t\tfw_info->ver = adev->psp.securedisplay_context.context.bin_desc.fw_version;\n\t\t\tfw_info->feature =\n\t\t\t\tadev->psp.securedisplay_context.context.bin_desc\n\t\t\t\t\t.feature_version;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_SDMA:\n\t\tif (query_fw->index >= adev->sdma.num_instances)\n\t\t\treturn -EINVAL;\n\t\tfw_info->ver = adev->sdma.instance[query_fw->index].fw_version;\n\t\tfw_info->feature = adev->sdma.instance[query_fw->index].feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_SOS:\n\t\tfw_info->ver = adev->psp.sos.fw_version;\n\t\tfw_info->feature = adev->psp.sos.feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_ASD:\n\t\tfw_info->ver = adev->psp.asd_context.bin_desc.fw_version;\n\t\tfw_info->feature = adev->psp.asd_context.bin_desc.feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_DMCU:\n\t\tfw_info->ver = adev->dm.dmcu_fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_DMCUB:\n\t\tfw_info->ver = adev->dm.dmcub_fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_TOC:\n\t\tfw_info->ver = adev->psp.toc.fw_version;\n\t\tfw_info->feature = adev->psp.toc.feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_CAP:\n\t\tfw_info->ver = adev->psp.cap_fw_version;\n\t\tfw_info->feature = adev->psp.cap_feature_version;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_MES_KIQ:\n\t\tfw_info->ver = adev->mes.kiq_version & AMDGPU_MES_VERSION_MASK;\n\t\tfw_info->feature = (adev->mes.kiq_version & AMDGPU_MES_FEAT_VERSION_MASK)\n\t\t\t\t\t>> AMDGPU_MES_FEAT_VERSION_SHIFT;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_MES:\n\t\tfw_info->ver = adev->mes.sched_version & AMDGPU_MES_VERSION_MASK;\n\t\tfw_info->feature = (adev->mes.sched_version & AMDGPU_MES_FEAT_VERSION_MASK)\n\t\t\t\t\t>> AMDGPU_MES_FEAT_VERSION_SHIFT;\n\t\tbreak;\n\tcase AMDGPU_INFO_FW_IMU:\n\t\tfw_info->ver = adev->gfx.imu_fw_version;\n\t\tfw_info->feature = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_hw_ip_info(struct amdgpu_device *adev,\n\t\t\t     struct drm_amdgpu_info *info,\n\t\t\t     struct drm_amdgpu_info_hw_ip *result)\n{\n\tuint32_t ib_start_alignment = 0;\n\tuint32_t ib_size_alignment = 0;\n\tenum amd_ip_block_type type;\n\tunsigned int num_rings = 0;\n\tunsigned int i, j;\n\n\tif (info->query_hw_ip.ip_instance >= AMDGPU_HW_IP_INSTANCE_MAX_COUNT)\n\t\treturn -EINVAL;\n\n\tswitch (info->query_hw_ip.type) {\n\tcase AMDGPU_HW_IP_GFX:\n\t\ttype = AMD_IP_BLOCK_TYPE_GFX;\n\t\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\t\tif (adev->gfx.gfx_ring[i].sched.ready)\n\t\t\t\t++num_rings;\n\t\tib_start_alignment = 32;\n\t\tib_size_alignment = 32;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_COMPUTE:\n\t\ttype = AMD_IP_BLOCK_TYPE_GFX;\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\t\tif (adev->gfx.compute_ring[i].sched.ready)\n\t\t\t\t++num_rings;\n\t\tib_start_alignment = 32;\n\t\tib_size_alignment = 32;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_DMA:\n\t\ttype = AMD_IP_BLOCK_TYPE_SDMA;\n\t\tfor (i = 0; i < adev->sdma.num_instances; i++)\n\t\t\tif (adev->sdma.instance[i].ring.sched.ready)\n\t\t\t\t++num_rings;\n\t\tib_start_alignment = 256;\n\t\tib_size_alignment = 4;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_UVD:\n\t\ttype = AMD_IP_BLOCK_TYPE_UVD;\n\t\tfor (i = 0; i < adev->uvd.num_uvd_inst; i++) {\n\t\t\tif (adev->uvd.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tif (adev->uvd.inst[i].ring.sched.ready)\n\t\t\t\t++num_rings;\n\t\t}\n\t\tib_start_alignment = 64;\n\t\tib_size_alignment = 64;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_VCE:\n\t\ttype = AMD_IP_BLOCK_TYPE_VCE;\n\t\tfor (i = 0; i < adev->vce.num_rings; i++)\n\t\t\tif (adev->vce.ring[i].sched.ready)\n\t\t\t\t++num_rings;\n\t\tib_start_alignment = 4;\n\t\tib_size_alignment = 1;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_UVD_ENC:\n\t\ttype = AMD_IP_BLOCK_TYPE_UVD;\n\t\tfor (i = 0; i < adev->uvd.num_uvd_inst; i++) {\n\t\t\tif (adev->uvd.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < adev->uvd.num_enc_rings; j++)\n\t\t\t\tif (adev->uvd.inst[i].ring_enc[j].sched.ready)\n\t\t\t\t\t++num_rings;\n\t\t}\n\t\tib_start_alignment = 64;\n\t\tib_size_alignment = 64;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_VCN_DEC:\n\t\ttype = AMD_IP_BLOCK_TYPE_VCN;\n\t\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tif (adev->vcn.inst[i].ring_dec.sched.ready)\n\t\t\t\t++num_rings;\n\t\t}\n\t\tib_start_alignment = 16;\n\t\tib_size_alignment = 16;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_VCN_ENC:\n\t\ttype = AMD_IP_BLOCK_TYPE_VCN;\n\t\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < adev->vcn.num_enc_rings; j++)\n\t\t\t\tif (adev->vcn.inst[i].ring_enc[j].sched.ready)\n\t\t\t\t\t++num_rings;\n\t\t}\n\t\tib_start_alignment = 64;\n\t\tib_size_alignment = 1;\n\t\tbreak;\n\tcase AMDGPU_HW_IP_VCN_JPEG:\n\t\ttype = (amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_JPEG)) ?\n\t\t\tAMD_IP_BLOCK_TYPE_JPEG : AMD_IP_BLOCK_TYPE_VCN;\n\n\t\tfor (i = 0; i < adev->jpeg.num_jpeg_inst; i++) {\n\t\t\tif (adev->jpeg.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < adev->jpeg.num_jpeg_rings; j++)\n\t\t\t\tif (adev->jpeg.inst[i].ring_dec[j].sched.ready)\n\t\t\t\t\t++num_rings;\n\t\t}\n\t\tib_start_alignment = 16;\n\t\tib_size_alignment = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < adev->num_ip_blocks; i++)\n\t\tif (adev->ip_blocks[i].version->type == type &&\n\t\t    adev->ip_blocks[i].status.valid)\n\t\t\tbreak;\n\n\tif (i == adev->num_ip_blocks)\n\t\treturn 0;\n\n\tnum_rings = min(amdgpu_ctx_num_entities[info->query_hw_ip.type],\n\t\t\tnum_rings);\n\n\tresult->hw_ip_version_major = adev->ip_blocks[i].version->major;\n\tresult->hw_ip_version_minor = adev->ip_blocks[i].version->minor;\n\n\tif (adev->asic_type >= CHIP_VEGA10) {\n\t\tswitch (type) {\n\t\tcase AMD_IP_BLOCK_TYPE_GFX:\n\t\t\tresult->ip_discovery_version = adev->ip_versions[GC_HWIP][0];\n\t\t\tbreak;\n\t\tcase AMD_IP_BLOCK_TYPE_SDMA:\n\t\t\tresult->ip_discovery_version = adev->ip_versions[SDMA0_HWIP][0];\n\t\t\tbreak;\n\t\tcase AMD_IP_BLOCK_TYPE_UVD:\n\t\tcase AMD_IP_BLOCK_TYPE_VCN:\n\t\tcase AMD_IP_BLOCK_TYPE_JPEG:\n\t\t\tresult->ip_discovery_version = adev->ip_versions[UVD_HWIP][0];\n\t\t\tbreak;\n\t\tcase AMD_IP_BLOCK_TYPE_VCE:\n\t\t\tresult->ip_discovery_version = adev->ip_versions[VCE_HWIP][0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult->ip_discovery_version = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tresult->ip_discovery_version = 0;\n\t}\n\tresult->capabilities_flags = 0;\n\tresult->available_rings = (1 << num_rings) - 1;\n\tresult->ib_start_alignment = ib_start_alignment;\n\tresult->ib_size_alignment = ib_size_alignment;\n\treturn 0;\n}\n\n \n \nint amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_amdgpu_info *info = data;\n\tstruct amdgpu_mode_info *minfo = &adev->mode_info;\n\tvoid __user *out = (void __user *)(uintptr_t)info->return_pointer;\n\tuint32_t size = info->return_size;\n\tstruct drm_crtc *crtc;\n\tuint32_t ui32 = 0;\n\tuint64_t ui64 = 0;\n\tint i, found;\n\tint ui32_size = sizeof(ui32);\n\n\tif (!info->return_size || !info->return_pointer)\n\t\treturn -EINVAL;\n\n\tswitch (info->query) {\n\tcase AMDGPU_INFO_ACCEL_WORKING:\n\t\tui32 = adev->accel_working;\n\t\treturn copy_to_user(out, &ui32, min(size, 4u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_CRTC_FROM_ID:\n\t\tfor (i = 0, found = 0; i < adev->mode_info.num_crtc; i++) {\n\t\t\tcrtc = (struct drm_crtc *)minfo->crtcs[i];\n\t\t\tif (crtc && crtc->base.id == info->mode_crtc.id) {\n\t\t\t\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\n\t\t\t\tui32 = amdgpu_crtc->crtc_id;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tDRM_DEBUG_KMS(\"unknown crtc id %d\\n\", info->mode_crtc.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn copy_to_user(out, &ui32, min(size, 4u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_HW_IP_INFO: {\n\t\tstruct drm_amdgpu_info_hw_ip ip = {};\n\t\tint ret;\n\n\t\tret = amdgpu_hw_ip_info(adev, info, &ip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = copy_to_user(out, &ip, min_t(size_t, size, sizeof(ip)));\n\t\treturn ret ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_HW_IP_COUNT: {\n\t\tenum amd_ip_block_type type;\n\t\tuint32_t count = 0;\n\n\t\tswitch (info->query_hw_ip.type) {\n\t\tcase AMDGPU_HW_IP_GFX:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_GFX;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_COMPUTE:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_GFX;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_DMA:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_SDMA;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_UVD:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_UVD;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_VCE:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_VCE;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_UVD_ENC:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_UVD;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_VCN_DEC:\n\t\tcase AMDGPU_HW_IP_VCN_ENC:\n\t\t\ttype = AMD_IP_BLOCK_TYPE_VCN;\n\t\t\tbreak;\n\t\tcase AMDGPU_HW_IP_VCN_JPEG:\n\t\t\ttype = (amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_JPEG)) ?\n\t\t\t\tAMD_IP_BLOCK_TYPE_JPEG : AMD_IP_BLOCK_TYPE_VCN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < adev->num_ip_blocks; i++)\n\t\t\tif (adev->ip_blocks[i].version->type == type &&\n\t\t\t    adev->ip_blocks[i].status.valid &&\n\t\t\t    count < AMDGPU_HW_IP_INSTANCE_MAX_COUNT)\n\t\t\t\tcount++;\n\n\t\treturn copy_to_user(out, &count, min(size, 4u)) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_TIMESTAMP:\n\t\tui64 = amdgpu_gfx_get_gpu_clock_counter(adev);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_FW_VERSION: {\n\t\tstruct drm_amdgpu_info_firmware fw_info;\n\t\tint ret;\n\n\t\t \n\t\tif (info->query_fw.ip_instance != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = amdgpu_firmware_info(&fw_info, &info->query_fw, adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn copy_to_user(out, &fw_info,\n\t\t\t\t    min((size_t)size, sizeof(fw_info))) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_NUM_BYTES_MOVED:\n\t\tui64 = atomic64_read(&adev->num_bytes_moved);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_NUM_EVICTIONS:\n\t\tui64 = atomic64_read(&adev->num_evictions);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_NUM_VRAM_CPU_PAGE_FAULTS:\n\t\tui64 = atomic64_read(&adev->num_vram_cpu_page_faults);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_VRAM_USAGE:\n\t\tui64 = ttm_resource_manager_usage(&adev->mman.vram_mgr.manager);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_VIS_VRAM_USAGE:\n\t\tui64 = amdgpu_vram_mgr_vis_usage(&adev->mman.vram_mgr);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_GTT_USAGE:\n\t\tui64 = ttm_resource_manager_usage(&adev->mman.gtt_mgr.manager);\n\t\treturn copy_to_user(out, &ui64, min(size, 8u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_GDS_CONFIG: {\n\t\tstruct drm_amdgpu_info_gds gds_info;\n\n\t\tmemset(&gds_info, 0, sizeof(gds_info));\n\t\tgds_info.compute_partition_size = adev->gds.gds_size;\n\t\tgds_info.gds_total_size = adev->gds.gds_size;\n\t\tgds_info.gws_per_compute_partition = adev->gds.gws_size;\n\t\tgds_info.oa_per_compute_partition = adev->gds.oa_size;\n\t\treturn copy_to_user(out, &gds_info,\n\t\t\t\t    min((size_t)size, sizeof(gds_info))) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_VRAM_GTT: {\n\t\tstruct drm_amdgpu_info_vram_gtt vram_gtt;\n\n\t\tvram_gtt.vram_size = adev->gmc.real_vram_size -\n\t\t\tatomic64_read(&adev->vram_pin_size) -\n\t\t\tAMDGPU_VM_RESERVED_VRAM;\n\t\tvram_gtt.vram_cpu_accessible_size =\n\t\t\tmin(adev->gmc.visible_vram_size -\n\t\t\t    atomic64_read(&adev->visible_pin_size),\n\t\t\t    vram_gtt.vram_size);\n\t\tvram_gtt.gtt_size = ttm_manager_type(&adev->mman.bdev, TTM_PL_TT)->size;\n\t\tvram_gtt.gtt_size -= atomic64_read(&adev->gart_pin_size);\n\t\treturn copy_to_user(out, &vram_gtt,\n\t\t\t\t    min((size_t)size, sizeof(vram_gtt))) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_MEMORY: {\n\t\tstruct drm_amdgpu_memory_info mem;\n\t\tstruct ttm_resource_manager *gtt_man =\n\t\t\t&adev->mman.gtt_mgr.manager;\n\t\tstruct ttm_resource_manager *vram_man =\n\t\t\t&adev->mman.vram_mgr.manager;\n\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.vram.total_heap_size = adev->gmc.real_vram_size;\n\t\tmem.vram.usable_heap_size = adev->gmc.real_vram_size -\n\t\t\tatomic64_read(&adev->vram_pin_size) -\n\t\t\tAMDGPU_VM_RESERVED_VRAM;\n\t\tmem.vram.heap_usage =\n\t\t\tttm_resource_manager_usage(vram_man);\n\t\tmem.vram.max_allocation = mem.vram.usable_heap_size * 3 / 4;\n\n\t\tmem.cpu_accessible_vram.total_heap_size =\n\t\t\tadev->gmc.visible_vram_size;\n\t\tmem.cpu_accessible_vram.usable_heap_size =\n\t\t\tmin(adev->gmc.visible_vram_size -\n\t\t\t    atomic64_read(&adev->visible_pin_size),\n\t\t\t    mem.vram.usable_heap_size);\n\t\tmem.cpu_accessible_vram.heap_usage =\n\t\t\tamdgpu_vram_mgr_vis_usage(&adev->mman.vram_mgr);\n\t\tmem.cpu_accessible_vram.max_allocation =\n\t\t\tmem.cpu_accessible_vram.usable_heap_size * 3 / 4;\n\n\t\tmem.gtt.total_heap_size = gtt_man->size;\n\t\tmem.gtt.usable_heap_size = mem.gtt.total_heap_size -\n\t\t\tatomic64_read(&adev->gart_pin_size);\n\t\tmem.gtt.heap_usage = ttm_resource_manager_usage(gtt_man);\n\t\tmem.gtt.max_allocation = mem.gtt.usable_heap_size * 3 / 4;\n\n\t\treturn copy_to_user(out, &mem,\n\t\t\t\t    min((size_t)size, sizeof(mem)))\n\t\t\t\t    ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_READ_MMR_REG: {\n\t\tunsigned int n, alloc_size;\n\t\tuint32_t *regs;\n\t\tunsigned int se_num = (info->read_mmr_reg.instance >>\n\t\t\t\t   AMDGPU_INFO_MMR_SE_INDEX_SHIFT) &\n\t\t\t\t  AMDGPU_INFO_MMR_SE_INDEX_MASK;\n\t\tunsigned int sh_num = (info->read_mmr_reg.instance >>\n\t\t\t\t   AMDGPU_INFO_MMR_SH_INDEX_SHIFT) &\n\t\t\t\t  AMDGPU_INFO_MMR_SH_INDEX_MASK;\n\n\t\t \n\t\tif (se_num == AMDGPU_INFO_MMR_SE_INDEX_MASK)\n\t\t\tse_num = 0xffffffff;\n\t\telse if (se_num >= AMDGPU_GFX_MAX_SE)\n\t\t\treturn -EINVAL;\n\t\tif (sh_num == AMDGPU_INFO_MMR_SH_INDEX_MASK)\n\t\t\tsh_num = 0xffffffff;\n\t\telse if (sh_num >= AMDGPU_GFX_MAX_SH_PER_SE)\n\t\t\treturn -EINVAL;\n\n\t\tif (info->read_mmr_reg.count > 128)\n\t\t\treturn -EINVAL;\n\n\t\tregs = kmalloc_array(info->read_mmr_reg.count, sizeof(*regs), GFP_KERNEL);\n\t\tif (!regs)\n\t\t\treturn -ENOMEM;\n\t\talloc_size = info->read_mmr_reg.count * sizeof(*regs);\n\n\t\tamdgpu_gfx_off_ctrl(adev, false);\n\t\tfor (i = 0; i < info->read_mmr_reg.count; i++) {\n\t\t\tif (amdgpu_asic_read_register(adev, se_num, sh_num,\n\t\t\t\t\t\t      info->read_mmr_reg.dword_offset + i,\n\t\t\t\t\t\t      &regs[i])) {\n\t\t\t\tDRM_DEBUG_KMS(\"unallowed offset %#x\\n\",\n\t\t\t\t\t      info->read_mmr_reg.dword_offset + i);\n\t\t\t\tkfree(regs);\n\t\t\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t\tn = copy_to_user(out, regs, min(size, alloc_size));\n\t\tkfree(regs);\n\t\treturn n ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_DEV_INFO: {\n\t\tstruct drm_amdgpu_info_device *dev_info;\n\t\tuint64_t vm_size;\n\t\tuint32_t pcie_gen_mask;\n\t\tint ret;\n\n\t\tdev_info = kzalloc(sizeof(*dev_info), GFP_KERNEL);\n\t\tif (!dev_info)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_info->device_id = adev->pdev->device;\n\t\tdev_info->chip_rev = adev->rev_id;\n\t\tdev_info->external_rev = adev->external_rev_id;\n\t\tdev_info->pci_rev = adev->pdev->revision;\n\t\tdev_info->family = adev->family;\n\t\tdev_info->num_shader_engines = adev->gfx.config.max_shader_engines;\n\t\tdev_info->num_shader_arrays_per_engine = adev->gfx.config.max_sh_per_se;\n\t\t \n\t\tdev_info->gpu_counter_freq = amdgpu_asic_get_xclk(adev) * 10;\n\t\tif (adev->pm.dpm_enabled) {\n\t\t\tdev_info->max_engine_clock = amdgpu_dpm_get_sclk(adev, false) * 10;\n\t\t\tdev_info->max_memory_clock = amdgpu_dpm_get_mclk(adev, false) * 10;\n\t\t\tdev_info->min_engine_clock = amdgpu_dpm_get_sclk(adev, true) * 10;\n\t\t\tdev_info->min_memory_clock = amdgpu_dpm_get_mclk(adev, true) * 10;\n\t\t} else {\n\t\t\tdev_info->max_engine_clock =\n\t\t\t\tdev_info->min_engine_clock =\n\t\t\t\t\tadev->clock.default_sclk * 10;\n\t\t\tdev_info->max_memory_clock =\n\t\t\t\tdev_info->min_memory_clock =\n\t\t\t\t\tadev->clock.default_mclk * 10;\n\t\t}\n\t\tdev_info->enabled_rb_pipes_mask = adev->gfx.config.backend_enable_mask;\n\t\tdev_info->num_rb_pipes = adev->gfx.config.max_backends_per_se *\n\t\t\tadev->gfx.config.max_shader_engines;\n\t\tdev_info->num_hw_gfx_contexts = adev->gfx.config.max_hw_contexts;\n\t\tdev_info->ids_flags = 0;\n\t\tif (adev->flags & AMD_IS_APU)\n\t\t\tdev_info->ids_flags |= AMDGPU_IDS_FLAGS_FUSION;\n\t\tif (adev->gfx.mcbp)\n\t\t\tdev_info->ids_flags |= AMDGPU_IDS_FLAGS_PREEMPTION;\n\t\tif (amdgpu_is_tmz(adev))\n\t\t\tdev_info->ids_flags |= AMDGPU_IDS_FLAGS_TMZ;\n\t\tif (adev->gfx.config.ta_cntl2_truncate_coord_mode)\n\t\t\tdev_info->ids_flags |= AMDGPU_IDS_FLAGS_CONFORMANT_TRUNC_COORD;\n\n\t\tvm_size = adev->vm_manager.max_pfn * AMDGPU_GPU_PAGE_SIZE;\n\t\tvm_size -= AMDGPU_VA_RESERVED_SIZE;\n\n\t\t \n\t\tif (adev->vce.fw_version &&\n\t\t    adev->vce.fw_version < AMDGPU_VCE_FW_53_45)\n\t\t\tvm_size = min(vm_size, 1ULL << 40);\n\n\t\tdev_info->virtual_address_offset = AMDGPU_VA_RESERVED_SIZE;\n\t\tdev_info->virtual_address_max =\n\t\t\tmin(vm_size, AMDGPU_GMC_HOLE_START);\n\n\t\tif (vm_size > AMDGPU_GMC_HOLE_START) {\n\t\t\tdev_info->high_va_offset = AMDGPU_GMC_HOLE_END;\n\t\t\tdev_info->high_va_max = AMDGPU_GMC_HOLE_END | vm_size;\n\t\t}\n\t\tdev_info->virtual_address_alignment = max_t(u32, PAGE_SIZE, AMDGPU_GPU_PAGE_SIZE);\n\t\tdev_info->pte_fragment_size = (1 << adev->vm_manager.fragment_size) * AMDGPU_GPU_PAGE_SIZE;\n\t\tdev_info->gart_page_size = max_t(u32, PAGE_SIZE, AMDGPU_GPU_PAGE_SIZE);\n\t\tdev_info->cu_active_number = adev->gfx.cu_info.number;\n\t\tdev_info->cu_ao_mask = adev->gfx.cu_info.ao_cu_mask;\n\t\tdev_info->ce_ram_size = adev->gfx.ce_ram_size;\n\t\tmemcpy(&dev_info->cu_ao_bitmap[0], &adev->gfx.cu_info.ao_cu_bitmap[0],\n\t\t       sizeof(adev->gfx.cu_info.ao_cu_bitmap));\n\t\tmemcpy(&dev_info->cu_bitmap[0], &adev->gfx.cu_info.bitmap[0],\n\t\t       sizeof(dev_info->cu_bitmap));\n\t\tdev_info->vram_type = adev->gmc.vram_type;\n\t\tdev_info->vram_bit_width = adev->gmc.vram_width;\n\t\tdev_info->vce_harvest_config = adev->vce.harvest_config;\n\t\tdev_info->gc_double_offchip_lds_buf =\n\t\t\tadev->gfx.config.double_offchip_lds_buf;\n\t\tdev_info->wave_front_size = adev->gfx.cu_info.wave_front_size;\n\t\tdev_info->num_shader_visible_vgprs = adev->gfx.config.max_gprs;\n\t\tdev_info->num_cu_per_sh = adev->gfx.config.max_cu_per_sh;\n\t\tdev_info->num_tcc_blocks = adev->gfx.config.max_texture_channel_caches;\n\t\tdev_info->gs_vgt_table_depth = adev->gfx.config.gs_vgt_table_depth;\n\t\tdev_info->gs_prim_buffer_depth = adev->gfx.config.gs_prim_buffer_depth;\n\t\tdev_info->max_gs_waves_per_vgt = adev->gfx.config.max_gs_threads;\n\n\t\tif (adev->family >= AMDGPU_FAMILY_NV)\n\t\t\tdev_info->pa_sc_tile_steering_override =\n\t\t\t\tadev->gfx.config.pa_sc_tile_steering_override;\n\n\t\tdev_info->tcc_disabled_mask = adev->gfx.config.tcc_disabled_mask;\n\n\t\t \n\t\tpcie_gen_mask = adev->pm.pcie_gen_mask & (adev->pm.pcie_gen_mask >> 16);\n\t\tdev_info->pcie_gen = fls(pcie_gen_mask);\n\t\tdev_info->pcie_num_lanes =\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X32 ? 32 :\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X16 ? 16 :\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X12 ? 12 :\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X8 ? 8 :\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X4 ? 4 :\n\t\t\tadev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X2 ? 2 : 1;\n\n\t\tdev_info->tcp_cache_size = adev->gfx.config.gc_tcp_l1_size;\n\t\tdev_info->num_sqc_per_wgp = adev->gfx.config.gc_num_sqc_per_wgp;\n\t\tdev_info->sqc_data_cache_size = adev->gfx.config.gc_l1_data_cache_size_per_sqc;\n\t\tdev_info->sqc_inst_cache_size = adev->gfx.config.gc_l1_instruction_cache_size_per_sqc;\n\t\tdev_info->gl1c_cache_size = adev->gfx.config.gc_gl1c_size_per_instance *\n\t\t\t\t\t    adev->gfx.config.gc_gl1c_per_sa;\n\t\tdev_info->gl2c_cache_size = adev->gfx.config.gc_gl2c_per_gpu;\n\t\tdev_info->mall_size = adev->gmc.mall_size;\n\n\n\t\tif (adev->gfx.funcs->get_gfx_shadow_info) {\n\t\t\tstruct amdgpu_gfx_shadow_info shadow_info;\n\n\t\t\tret = amdgpu_gfx_get_gfx_shadow_info(adev, &shadow_info);\n\t\t\tif (!ret) {\n\t\t\t\tdev_info->shadow_size = shadow_info.shadow_size;\n\t\t\t\tdev_info->shadow_alignment = shadow_info.shadow_alignment;\n\t\t\t\tdev_info->csa_size = shadow_info.csa_size;\n\t\t\t\tdev_info->csa_alignment = shadow_info.csa_alignment;\n\t\t\t}\n\t\t}\n\n\t\tret = copy_to_user(out, dev_info,\n\t\t\t\t   min((size_t)size, sizeof(*dev_info))) ? -EFAULT : 0;\n\t\tkfree(dev_info);\n\t\treturn ret;\n\t}\n\tcase AMDGPU_INFO_VCE_CLOCK_TABLE: {\n\t\tunsigned int i;\n\t\tstruct drm_amdgpu_info_vce_clock_table vce_clk_table = {};\n\t\tstruct amd_vce_state *vce_state;\n\n\t\tfor (i = 0; i < AMDGPU_VCE_CLOCK_TABLE_ENTRIES; i++) {\n\t\t\tvce_state = amdgpu_dpm_get_vce_clock_state(adev, i);\n\t\t\tif (vce_state) {\n\t\t\t\tvce_clk_table.entries[i].sclk = vce_state->sclk;\n\t\t\t\tvce_clk_table.entries[i].mclk = vce_state->mclk;\n\t\t\t\tvce_clk_table.entries[i].eclk = vce_state->evclk;\n\t\t\t\tvce_clk_table.num_valid_entries++;\n\t\t\t}\n\t\t}\n\n\t\treturn copy_to_user(out, &vce_clk_table,\n\t\t\t\t    min((size_t)size, sizeof(vce_clk_table))) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_VBIOS: {\n\t\tuint32_t bios_size = adev->bios_size;\n\n\t\tswitch (info->vbios_info.type) {\n\t\tcase AMDGPU_INFO_VBIOS_SIZE:\n\t\t\treturn copy_to_user(out, &bios_size,\n\t\t\t\t\tmin((size_t)size, sizeof(bios_size)))\n\t\t\t\t\t? -EFAULT : 0;\n\t\tcase AMDGPU_INFO_VBIOS_IMAGE: {\n\t\t\tuint8_t *bios;\n\t\t\tuint32_t bios_offset = info->vbios_info.offset;\n\n\t\t\tif (bios_offset >= bios_size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbios = adev->bios + bios_offset;\n\t\t\treturn copy_to_user(out, bios,\n\t\t\t\t\t    min((size_t)size, (size_t)(bios_size - bios_offset)))\n\t\t\t\t\t? -EFAULT : 0;\n\t\t}\n\t\tcase AMDGPU_INFO_VBIOS_INFO: {\n\t\t\tstruct drm_amdgpu_info_vbios vbios_info = {};\n\t\t\tstruct atom_context *atom_context;\n\n\t\t\tatom_context = adev->mode_info.atom_context;\n\t\t\tif (atom_context) {\n\t\t\t\tmemcpy(vbios_info.name, atom_context->name,\n\t\t\t\t       sizeof(atom_context->name));\n\t\t\t\tmemcpy(vbios_info.vbios_pn, atom_context->vbios_pn,\n\t\t\t\t       sizeof(atom_context->vbios_pn));\n\t\t\t\tvbios_info.version = atom_context->version;\n\t\t\t\tmemcpy(vbios_info.vbios_ver_str, atom_context->vbios_ver_str,\n\t\t\t\t       sizeof(atom_context->vbios_ver_str));\n\t\t\t\tmemcpy(vbios_info.date, atom_context->date,\n\t\t\t\t       sizeof(atom_context->date));\n\t\t\t}\n\n\t\t\treturn copy_to_user(out, &vbios_info,\n\t\t\t\t\t\tmin((size_t)size, sizeof(vbios_info))) ? -EFAULT : 0;\n\t\t}\n\t\tdefault:\n\t\t\tDRM_DEBUG_KMS(\"Invalid request %d\\n\",\n\t\t\t\t\tinfo->vbios_info.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase AMDGPU_INFO_NUM_HANDLES: {\n\t\tstruct drm_amdgpu_info_num_handles handle;\n\n\t\tswitch (info->query_hw_ip.type) {\n\t\tcase AMDGPU_HW_IP_UVD:\n\t\t\t \n\t\t\tif (adev->asic_type < CHIP_POLARIS10) {\n\t\t\t\thandle.uvd_max_handles = adev->uvd.max_handles;\n\t\t\t\thandle.uvd_used_handles = amdgpu_uvd_used_handles(adev);\n\n\t\t\t\treturn copy_to_user(out, &handle,\n\t\t\t\t\tmin((size_t)size, sizeof(handle))) ? -EFAULT : 0;\n\t\t\t} else {\n\t\t\t\treturn -ENODATA;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase AMDGPU_INFO_SENSOR: {\n\t\tif (!adev->pm.dpm_enabled)\n\t\t\treturn -ENOENT;\n\n\t\tswitch (info->sensor_info.type) {\n\t\tcase AMDGPU_INFO_SENSOR_GFX_SCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GFX_SCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_GFX_MCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GFX_MCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_GPU_TEMP:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GPU_TEMP,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_GPU_LOAD:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GPU_LOAD,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_GPU_AVG_POWER:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GPU_AVG_POWER,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\t \n\t\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t\t   AMDGPU_PP_SENSOR_GPU_INPUT_POWER,\n\t\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tui32 >>= 8;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_VDDNB:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_VDDNB,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_VDDGFX:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_VDDGFX,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_STABLE_PSTATE_GFX_SCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_STABLE_PSTATE_GFX_MCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_PEAK_PSTATE_GFX_SCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_PEAK_PSTATE_SCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_SENSOR_PEAK_PSTATE_GFX_MCLK:\n\t\t\t \n\t\t\tif (amdgpu_dpm_read_sensor(adev,\n\t\t\t\t\t\t   AMDGPU_PP_SENSOR_PEAK_PSTATE_MCLK,\n\t\t\t\t\t\t   (void *)&ui32, &ui32_size)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tui32 /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG_KMS(\"Invalid request %d\\n\",\n\t\t\t\t      info->sensor_info.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn copy_to_user(out, &ui32, min(size, 4u)) ? -EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_VRAM_LOST_COUNTER:\n\t\tui32 = atomic_read(&adev->vram_lost_counter);\n\t\treturn copy_to_user(out, &ui32, min(size, 4u)) ? -EFAULT : 0;\n\tcase AMDGPU_INFO_RAS_ENABLED_FEATURES: {\n\t\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\t\tuint64_t ras_mask;\n\n\t\tif (!ras)\n\t\t\treturn -EINVAL;\n\t\tras_mask = (uint64_t)adev->ras_enabled << 32 | ras->features;\n\n\t\treturn copy_to_user(out, &ras_mask,\n\t\t\t\tmin_t(u64, size, sizeof(ras_mask))) ?\n\t\t\t-EFAULT : 0;\n\t}\n\tcase AMDGPU_INFO_VIDEO_CAPS: {\n\t\tconst struct amdgpu_video_codecs *codecs;\n\t\tstruct drm_amdgpu_info_video_caps *caps;\n\t\tint r;\n\n\t\tif (!adev->asic_funcs->query_video_codecs)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info->video_cap.type) {\n\t\tcase AMDGPU_INFO_VIDEO_CAPS_DECODE:\n\t\t\tr = amdgpu_asic_query_video_codecs(adev, false, &codecs);\n\t\t\tif (r)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase AMDGPU_INFO_VIDEO_CAPS_ENCODE:\n\t\t\tr = amdgpu_asic_query_video_codecs(adev, true, &codecs);\n\t\t\tif (r)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG_KMS(\"Invalid request %d\\n\",\n\t\t\t\t      info->video_cap.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\t\tif (!caps)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < codecs->codec_count; i++) {\n\t\t\tint idx = codecs->codec_array[i].codec_type;\n\n\t\t\tswitch (idx) {\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_MPEG2:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_MPEG4:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_VC1:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_MPEG4_AVC:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_HEVC:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_JPEG:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_VP9:\n\t\t\tcase AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_AV1:\n\t\t\t\tcaps->codec_info[idx].valid = 1;\n\t\t\t\tcaps->codec_info[idx].max_width =\n\t\t\t\t\tcodecs->codec_array[i].max_width;\n\t\t\t\tcaps->codec_info[idx].max_height =\n\t\t\t\t\tcodecs->codec_array[i].max_height;\n\t\t\t\tcaps->codec_info[idx].max_pixels_per_frame =\n\t\t\t\t\tcodecs->codec_array[i].max_pixels_per_frame;\n\t\t\t\tcaps->codec_info[idx].max_level =\n\t\t\t\t\tcodecs->codec_array[i].max_level;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr = copy_to_user(out, caps,\n\t\t\t\t min((size_t)size, sizeof(*caps))) ? -EFAULT : 0;\n\t\tkfree(caps);\n\t\treturn r;\n\t}\n\tcase AMDGPU_INFO_MAX_IBS: {\n\t\tuint32_t max_ibs[AMDGPU_HW_IP_NUM];\n\n\t\tfor (i = 0; i < AMDGPU_HW_IP_NUM; ++i)\n\t\t\tmax_ibs[i] = amdgpu_ring_max_ibs(i);\n\n\t\treturn copy_to_user(out, max_ibs,\n\t\t\t\t    min((size_t)size, sizeof(max_ibs))) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Invalid request %d\\n\", info->query);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \n \nvoid amdgpu_driver_lastclose_kms(struct drm_device *dev)\n{\n\tdrm_fb_helper_lastclose(dev);\n\tvga_switcheroo_process_delayed_switch();\n}\n\n \nint amdgpu_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_fpriv *fpriv;\n\tint r, pasid;\n\n\t \n\tflush_delayed_work(&adev->delayed_init_work);\n\n\n\tif (amdgpu_ras_intr_triggered()) {\n\t\tDRM_ERROR(\"RAS Intr triggered, device disabled!!\");\n\t\treturn -EHWPOISON;\n\t}\n\n\tfile_priv->driver_priv = NULL;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0)\n\t\tgoto pm_put;\n\n\tfpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);\n\tif (unlikely(!fpriv)) {\n\t\tr = -ENOMEM;\n\t\tgoto out_suspend;\n\t}\n\n\tpasid = amdgpu_pasid_alloc(16);\n\tif (pasid < 0) {\n\t\tdev_warn(adev->dev, \"No more PASIDs available!\");\n\t\tpasid = 0;\n\t}\n\n\tr = amdgpu_xcp_open_device(adev, fpriv, file_priv);\n\tif (r)\n\t\tgoto error_pasid;\n\n\tr = amdgpu_vm_init(adev, &fpriv->vm, fpriv->xcp_id);\n\tif (r)\n\t\tgoto error_pasid;\n\n\tr = amdgpu_vm_set_pasid(adev, &fpriv->vm, pasid);\n\tif (r)\n\t\tgoto error_vm;\n\n\tfpriv->prt_va = amdgpu_vm_bo_add(adev, &fpriv->vm, NULL);\n\tif (!fpriv->prt_va) {\n\t\tr = -ENOMEM;\n\t\tgoto error_vm;\n\t}\n\n\tif (adev->gfx.mcbp) {\n\t\tuint64_t csa_addr = amdgpu_csa_vaddr(adev) & AMDGPU_GMC_HOLE_MASK;\n\n\t\tr = amdgpu_map_static_csa(adev, &fpriv->vm, adev->virt.csa_obj,\n\t\t\t\t\t\t&fpriv->csa_va, csa_addr, AMDGPU_CSA_SIZE);\n\t\tif (r)\n\t\t\tgoto error_vm;\n\t}\n\n\tmutex_init(&fpriv->bo_list_lock);\n\tidr_init_base(&fpriv->bo_list_handles, 1);\n\n\tamdgpu_ctx_mgr_init(&fpriv->ctx_mgr, adev);\n\n\tfile_priv->driver_priv = fpriv;\n\tgoto out_suspend;\n\nerror_vm:\n\tamdgpu_vm_fini(adev, &fpriv->vm);\n\nerror_pasid:\n\tif (pasid) {\n\t\tamdgpu_pasid_free(pasid);\n\t\tamdgpu_vm_set_pasid(adev, &fpriv->vm, 0);\n\t}\n\n\tkfree(fpriv);\n\nout_suspend:\n\tpm_runtime_mark_last_busy(dev->dev);\npm_put:\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn r;\n}\n\n \nvoid amdgpu_driver_postclose_kms(struct drm_device *dev,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_fpriv *fpriv = file_priv->driver_priv;\n\tstruct amdgpu_bo_list *list;\n\tstruct amdgpu_bo *pd;\n\tu32 pasid;\n\tint handle;\n\n\tif (!fpriv)\n\t\treturn;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tif (amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_UVD) != NULL)\n\t\tamdgpu_uvd_free_handles(adev, file_priv);\n\tif (amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_VCE) != NULL)\n\t\tamdgpu_vce_free_handles(adev, file_priv);\n\n\tif (fpriv->csa_va) {\n\t\tuint64_t csa_addr = amdgpu_csa_vaddr(adev) & AMDGPU_GMC_HOLE_MASK;\n\n\t\tWARN_ON(amdgpu_unmap_static_csa(adev, &fpriv->vm, adev->virt.csa_obj,\n\t\t\t\t\t\tfpriv->csa_va, csa_addr));\n\t\tfpriv->csa_va = NULL;\n\t}\n\n\tpasid = fpriv->vm.pasid;\n\tpd = amdgpu_bo_ref(fpriv->vm.root.bo);\n\tif (!WARN_ON(amdgpu_bo_reserve(pd, true))) {\n\t\tamdgpu_vm_bo_del(adev, fpriv->prt_va);\n\t\tamdgpu_bo_unreserve(pd);\n\t}\n\n\tamdgpu_ctx_mgr_fini(&fpriv->ctx_mgr);\n\tamdgpu_vm_fini(adev, &fpriv->vm);\n\n\tif (pasid)\n\t\tamdgpu_pasid_free_delayed(pd->tbo.base.resv, pasid);\n\tamdgpu_bo_unref(&pd);\n\n\tidr_for_each_entry(&fpriv->bo_list_handles, list, handle)\n\t\tamdgpu_bo_list_put(list);\n\n\tidr_destroy(&fpriv->bo_list_handles);\n\tmutex_destroy(&fpriv->bo_list_lock);\n\n\tkfree(fpriv);\n\tfile_priv->driver_priv = NULL;\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n}\n\n\nvoid amdgpu_driver_release_kms(struct drm_device *dev)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tamdgpu_device_fini_sw(adev);\n\tpci_set_drvdata(adev->pdev, NULL);\n}\n\n \n \nu32 amdgpu_get_vblank_counter_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint vpos, hpos, stat;\n\tu32 count;\n\n\tif (pipe >= adev->mode_info.num_crtc) {\n\t\tDRM_ERROR(\"Invalid crtc %u\\n\", pipe);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (adev->mode_info.crtcs[pipe]) {\n\t\t \n\t\tdo {\n\t\t\tcount = amdgpu_display_vblank_get_counter(adev, pipe);\n\t\t\t \n\t\t\tstat = amdgpu_display_get_crtc_scanoutpos(\n\t\t\t\tdev, pipe, GET_DISTANCE_TO_VBLANKSTART,\n\t\t\t\t&vpos, &hpos, NULL, NULL,\n\t\t\t\t&adev->mode_info.crtcs[pipe]->base.hwmode);\n\t\t} while (count != amdgpu_display_vblank_get_counter(adev, pipe));\n\n\t\tif (((stat & (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE)) !=\n\t\t    (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE))) {\n\t\t\tDRM_DEBUG_VBL(\"Query failed! stat %d\\n\", stat);\n\t\t} else {\n\t\t\tDRM_DEBUG_VBL(\"crtc %d: dist from vblank start %d\\n\",\n\t\t\t\t      pipe, vpos);\n\n\t\t\t \n\t\t\tif (vpos >= 0)\n\t\t\t\tcount++;\n\t\t}\n\t} else {\n\t\t \n\t\tcount = amdgpu_display_vblank_get_counter(adev, pipe);\n\t\tDRM_DEBUG_VBL(\"NULL mode info! Returned count may be wrong.\\n\");\n\t}\n\n\treturn count;\n}\n\n \nint amdgpu_enable_vblank_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint idx = amdgpu_display_crtc_idx_to_irq_type(adev, pipe);\n\n\treturn amdgpu_irq_get(adev, &adev->crtc_irq, idx);\n}\n\n \nvoid amdgpu_disable_vblank_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint idx = amdgpu_display_crtc_idx_to_irq_type(adev, pipe);\n\n\tamdgpu_irq_put(adev, &adev->crtc_irq, idx);\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\nstatic int amdgpu_debugfs_firmware_info_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_device *adev = m->private;\n\tstruct drm_amdgpu_info_firmware fw_info;\n\tstruct drm_amdgpu_query_fw query_fw;\n\tstruct atom_context *ctx = adev->mode_info.atom_context;\n\tuint8_t smu_program, smu_major, smu_minor, smu_debug;\n\tint ret, i;\n\n\tstatic const char *ta_fw_name[TA_FW_TYPE_MAX_INDEX] = {\n#define TA_FW_NAME(type)[TA_FW_TYPE_PSP_##type] = #type\n\t\tTA_FW_NAME(XGMI),\n\t\tTA_FW_NAME(RAS),\n\t\tTA_FW_NAME(HDCP),\n\t\tTA_FW_NAME(DTM),\n\t\tTA_FW_NAME(RAP),\n\t\tTA_FW_NAME(SECUREDISPLAY),\n#undef TA_FW_NAME\n\t};\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_VCE;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"VCE feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_UVD;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"UVD feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GMC;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"MC feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_ME;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"ME feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_PFP;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"PFP feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_CE;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"CE feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLC;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLC feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_CNTL;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLC SRLC feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_GPM_MEM;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLC SRLG feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLC_RESTORE_LIST_SRM_MEM;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLC SRLS feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLCP;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLCP feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_RLCV;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"RLCV feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_GFX_MEC;\n\tquery_fw.index = 0;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"MEC feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tif (adev->gfx.mec2_fw) {\n\t\tquery_fw.index = 1;\n\t\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tseq_printf(m, \"MEC2 feature version: %u, firmware version: 0x%08x\\n\",\n\t\t\t   fw_info.feature, fw_info.ver);\n\t}\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_IMU;\n\tquery_fw.index = 0;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"IMU feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_SOS;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"SOS feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_ASD;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"ASD feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\tquery_fw.fw_type = AMDGPU_INFO_FW_TA;\n\tfor (i = TA_FW_TYPE_PSP_XGMI; i < TA_FW_TYPE_MAX_INDEX; i++) {\n\t\tquery_fw.index = i;\n\t\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"TA %s feature version: 0x%08x, firmware version: 0x%08x\\n\",\n\t\t\t   ta_fw_name[i], fw_info.feature, fw_info.ver);\n\t}\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_SMC;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tsmu_program = (fw_info.ver >> 24) & 0xff;\n\tsmu_major = (fw_info.ver >> 16) & 0xff;\n\tsmu_minor = (fw_info.ver >> 8) & 0xff;\n\tsmu_debug = (fw_info.ver >> 0) & 0xff;\n\tseq_printf(m, \"SMC feature version: %u, program: %d, firmware version: 0x%08x (%d.%d.%d)\\n\",\n\t\t   fw_info.feature, smu_program, fw_info.ver, smu_major, smu_minor, smu_debug);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_SDMA;\n\tfor (i = 0; i < adev->sdma.num_instances; i++) {\n\t\tquery_fw.index = i;\n\t\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tseq_printf(m, \"SDMA%d feature version: %u, firmware version: 0x%08x\\n\",\n\t\t\t   i, fw_info.feature, fw_info.ver);\n\t}\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_VCN;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"VCN feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_DMCU;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"DMCU feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_DMCUB;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"DMCUB feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_TOC;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"TOC feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tif (adev->psp.cap_fw) {\n\t\tquery_fw.fw_type = AMDGPU_INFO_FW_CAP;\n\t\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tseq_printf(m, \"CAP feature version: %u, firmware version: 0x%08x\\n\",\n\t\t\t\tfw_info.feature, fw_info.ver);\n\t}\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_MES_KIQ;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"MES_KIQ feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\t \n\tquery_fw.fw_type = AMDGPU_INFO_FW_MES;\n\tret = amdgpu_firmware_info(&fw_info, &query_fw, adev);\n\tif (ret)\n\t\treturn ret;\n\tseq_printf(m, \"MES feature version: %u, firmware version: 0x%08x\\n\",\n\t\t   fw_info.feature, fw_info.ver);\n\n\tseq_printf(m, \"VBIOS version: %s\\n\", ctx->vbios_pn);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(amdgpu_debugfs_firmware_info);\n\n#endif\n\nvoid amdgpu_debugfs_firmware_init(struct amdgpu_device *adev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct drm_minor *minor = adev_to_drm(adev)->primary;\n\tstruct dentry *root = minor->debugfs_root;\n\n\tdebugfs_create_file(\"amdgpu_firmware_info\", 0444, root,\n\t\t\t    adev, &amdgpu_debugfs_firmware_info_fops);\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}