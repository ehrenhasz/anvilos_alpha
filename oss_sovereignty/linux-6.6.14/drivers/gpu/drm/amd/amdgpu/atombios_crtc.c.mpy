{
  "module_name": "atombios_crtc.c",
  "hash_id": "8dc78c4f375e1a5bbc79597883d2c6165fb62af734b7d2755d3872403620a4e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/atombios_crtc.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_fixed.h>\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"atom-bits.h\"\n#include \"atombios_encoders.h\"\n#include \"atombios_crtc.h\"\n#include \"amdgpu_atombios.h\"\n#include \"amdgpu_pll.h\"\n#include \"amdgpu_connectors.h\"\n\nvoid amdgpu_atombios_crtc_overscan_setup(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tSET_CRTC_OVERSCAN_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_OverScan);\n\tint a1, a2;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = amdgpu_crtc->crtc_id;\n\n\tswitch (amdgpu_crtc->rmx_type) {\n\tcase RMX_CENTER:\n\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\tbreak;\n\tcase RMX_ASPECT:\n\t\ta1 = mode->crtc_vdisplay * adjusted_mode->crtc_hdisplay;\n\t\ta2 = adjusted_mode->crtc_vdisplay * mode->crtc_hdisplay;\n\n\t\tif (a1 > a2) {\n\t\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t} else if (a2 > a1) {\n\t\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t}\n\t\tbreak;\n\tcase RMX_FULL:\n\tdefault:\n\t\targs.usOverscanRight = cpu_to_le16(amdgpu_crtc->h_border);\n\t\targs.usOverscanLeft = cpu_to_le16(amdgpu_crtc->h_border);\n\t\targs.usOverscanBottom = cpu_to_le16(amdgpu_crtc->v_border);\n\t\targs.usOverscanTop = cpu_to_le16(amdgpu_crtc->v_border);\n\t\tbreak;\n\t}\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_scaler_setup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tENABLE_SCALER_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableScaler);\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucScaler = amdgpu_crtc->crtc_id;\n\n\tswitch (amdgpu_crtc->rmx_type) {\n\tcase RMX_FULL:\n\t\targs.ucEnable = ATOM_SCALER_EXPANSION;\n\t\tbreak;\n\tcase RMX_CENTER:\n\t\targs.ucEnable = ATOM_SCALER_CENTER;\n\t\tbreak;\n\tcase RMX_ASPECT:\n\t\targs.ucEnable = ATOM_SCALER_EXPANSION;\n\t\tbreak;\n\tdefault:\n\t\targs.ucEnable = ATOM_SCALER_DISABLE;\n\t\tbreak;\n\t}\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_lock(struct drm_crtc *crtc, int lock)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint index =\n\t    GetIndexIntoMasterTable(COMMAND, UpdateCRTC_DoubleBufferRegisters);\n\tENABLE_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = amdgpu_crtc->crtc_id;\n\targs.ucEnable = lock;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_enable(struct drm_crtc *crtc, int state)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableCRTC);\n\tENABLE_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = amdgpu_crtc->crtc_id;\n\targs.ucEnable = state;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_blank(struct drm_crtc *crtc, int state)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint index = GetIndexIntoMasterTable(COMMAND, BlankCRTC);\n\tBLANK_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = amdgpu_crtc->crtc_id;\n\targs.ucBlanking = state;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_powergate(struct drm_crtc *crtc, int state)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);\n\tENABLE_DISP_POWER_GATING_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucDispPipeId = amdgpu_crtc->crtc_id;\n\targs.ucEnable = state;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_powergate_init(struct amdgpu_device *adev)\n{\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);\n\tENABLE_DISP_POWER_GATING_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucEnable = ATOM_INIT;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid amdgpu_atombios_crtc_set_dtd_timing(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tSET_CRTC_USING_DTD_TIMING_PARAMETERS args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_UsingDTDTiming);\n\tu16 misc = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.usH_Size = cpu_to_le16(mode->crtc_hdisplay - (amdgpu_crtc->h_border * 2));\n\targs.usH_Blanking_Time =\n\t\tcpu_to_le16(mode->crtc_hblank_end - mode->crtc_hdisplay + (amdgpu_crtc->h_border * 2));\n\targs.usV_Size = cpu_to_le16(mode->crtc_vdisplay - (amdgpu_crtc->v_border * 2));\n\targs.usV_Blanking_Time =\n\t\tcpu_to_le16(mode->crtc_vblank_end - mode->crtc_vdisplay + (amdgpu_crtc->v_border * 2));\n\targs.usH_SyncOffset =\n\t\tcpu_to_le16(mode->crtc_hsync_start - mode->crtc_hdisplay + amdgpu_crtc->h_border);\n\targs.usH_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_hsync_end - mode->crtc_hsync_start);\n\targs.usV_SyncOffset =\n\t\tcpu_to_le16(mode->crtc_vsync_start - mode->crtc_vdisplay + amdgpu_crtc->v_border);\n\targs.usV_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_vsync_end - mode->crtc_vsync_start);\n\targs.ucH_Border = amdgpu_crtc->h_border;\n\targs.ucV_Border = amdgpu_crtc->v_border;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tmisc |= ATOM_VSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tmisc |= ATOM_HSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_CSYNC)\n\t\tmisc |= ATOM_COMPOSITESYNC;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tmisc |= ATOM_INTERLACE;\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;\n\n\targs.susModeMiscInfo.usAccess = cpu_to_le16(misc);\n\targs.ucCRTC = amdgpu_crtc->crtc_id;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion atom_enable_ss {\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_PS_ALLOCATION v1;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V2 v2;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V3 v3;\n};\n\nstatic void amdgpu_atombios_crtc_program_ss(struct amdgpu_device *adev,\n\t\t\t\t     int enable,\n\t\t\t\t     int pll_id,\n\t\t\t\t     int crtc_id,\n\t\t\t\t     struct amdgpu_atom_ss *ss)\n{\n\tunsigned i;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableSpreadSpectrumOnPPLL);\n\tunion atom_enable_ss args;\n\n\tif (enable) {\n\t\t \n\t\tif (ss->percentage == 0)\n\t\t\treturn;\n\t\tif (ss->type & ATOM_EXTERNAL_SS_MASK)\n\t\t\treturn;\n\t} else {\n\t\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\t\tif (adev->mode_info.crtcs[i] &&\n\t\t\t    adev->mode_info.crtcs[i]->enabled &&\n\t\t\t    i != crtc_id &&\n\t\t\t    pll_id == adev->mode_info.crtcs[i]->pll_id) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.v3.usSpreadSpectrumAmountFrac = cpu_to_le16(0);\n\targs.v3.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\tswitch (pll_id) {\n\tcase ATOM_PPLL1:\n\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P1PLL;\n\t\tbreak;\n\tcase ATOM_PPLL2:\n\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P2PLL;\n\t\tbreak;\n\tcase ATOM_DCPLL:\n\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_DCPLL;\n\t\tbreak;\n\tcase ATOM_PPLL_INVALID:\n\t\treturn;\n\t}\n\targs.v3.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\n\targs.v3.usSpreadSpectrumStep = cpu_to_le16(ss->step);\n\targs.v3.ucEnable = enable;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion adjust_pixel_clock {\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION v1;\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 v3;\n};\n\nstatic u32 amdgpu_atombios_crtc_adjust_pll(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_encoder *encoder = amdgpu_crtc->encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_connector *connector = amdgpu_get_connector_for_encoder(encoder);\n\tu32 adjusted_clock = mode->clock;\n\tint encoder_mode = amdgpu_atombios_encoder_get_encoder_mode(encoder);\n\tu32 dp_clock = mode->clock;\n\tu32 clock = mode->clock;\n\tint bpc = amdgpu_crtc->bpc;\n\tbool is_duallink = amdgpu_dig_monitor_is_duallink(encoder, mode->clock);\n\tunion adjust_pixel_clock args;\n\tu8 frev, crev;\n\tint index;\n\n\tamdgpu_crtc->pll_flags = AMDGPU_PLL_USE_FRAC_FB_DIV;\n\n\tif ((amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\n\t    (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)) {\n\t\tif (connector) {\n\t\t\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\t\t\tstruct amdgpu_connector_atom_dig *dig_connector =\n\t\t\t\tamdgpu_connector->con_priv;\n\n\t\t\tdp_clock = dig_connector->dp_clock;\n\t\t}\n\t}\n\n\t \n\tif (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\tif (amdgpu_crtc->ss_enabled) {\n\t\t\tif (amdgpu_crtc->ss.refdiv) {\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_REF_DIV;\n\t\t\t\tamdgpu_crtc->pll_reference_div = amdgpu_crtc->ss.refdiv;\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_FRAC_FB_DIV;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (amdgpu_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1)\n\t\tadjusted_clock = mode->clock * 2;\n\tif (amdgpu_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_PREFER_CLOSEST_LOWER;\n\tif (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_IS_LCD;\n\n\n\t \n\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\tswitch (bpc) {\n\t\tcase 8:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tclock = (clock * 5) / 4;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tclock = (clock * 3) / 2;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tclock = clock * 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tindex = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn adjusted_clock;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\targs.v1.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v1.ucTransmitterID = amdgpu_encoder->encoder_id;\n\t\t\targs.v1.ucEncodeMode = encoder_mode;\n\t\t\tif (amdgpu_crtc->ss_enabled && amdgpu_crtc->ss.percentage)\n\t\t\t\targs.v1.ucConfig |=\n\t\t\t\t\tADJUST_DISPLAY_CONFIG_SS_ENABLE;\n\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\t\t\t   index, (uint32_t *)&args);\n\t\t\tadjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\targs.v3.sInput.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v3.sInput.ucTransmitterID = amdgpu_encoder->encoder_id;\n\t\t\targs.v3.sInput.ucEncodeMode = encoder_mode;\n\t\t\targs.v3.sInput.ucDispPllConfig = 0;\n\t\t\tif (amdgpu_crtc->ss_enabled && amdgpu_crtc->ss.percentage)\n\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\tDISPPLL_CONFIG_SS_ENABLE;\n\t\t\tif (ENCODER_MODE_IS_DP(encoder_mode)) {\n\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\tDISPPLL_CONFIG_COHERENT_MODE;\n\t\t\t\t \n\t\t\t\targs.v3.sInput.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t} else if (amdgpu_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\tDISPPLL_CONFIG_COHERENT_MODE;\n\t\t\t\tif (is_duallink)\n\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\tDISPPLL_CONFIG_DUAL_LINK;\n\t\t\t}\n\t\t\tif (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) !=\n\t\t\t    ENCODER_OBJECT_ID_NONE)\n\t\t\t\targs.v3.sInput.ucExtTransmitterID =\n\t\t\t\t\tamdgpu_encoder_get_dp_bridge_encoder_id(encoder);\n\t\t\telse\n\t\t\t\targs.v3.sInput.ucExtTransmitterID = 0;\n\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context,\n\t\t\t\t\t   index, (uint32_t *)&args);\n\t\t\tadjusted_clock = le32_to_cpu(args.v3.sOutput.ulDispPllFreq) * 10;\n\t\t\tif (args.v3.sOutput.ucRefDiv) {\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_FRAC_FB_DIV;\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_REF_DIV;\n\t\t\t\tamdgpu_crtc->pll_reference_div = args.v3.sOutput.ucRefDiv;\n\t\t\t}\n\t\t\tif (args.v3.sOutput.ucPostDiv) {\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_FRAC_FB_DIV;\n\t\t\t\tamdgpu_crtc->pll_flags |= AMDGPU_PLL_USE_POST_DIV;\n\t\t\t\tamdgpu_crtc->pll_post_div = args.v3.sOutput.ucPostDiv;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn adjusted_clock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn adjusted_clock;\n\t}\n\n\treturn adjusted_clock;\n}\n\nunion set_pixel_clock {\n\tSET_PIXEL_CLOCK_PS_ALLOCATION base;\n\tPIXEL_CLOCK_PARAMETERS v1;\n\tPIXEL_CLOCK_PARAMETERS_V2 v2;\n\tPIXEL_CLOCK_PARAMETERS_V3 v3;\n\tPIXEL_CLOCK_PARAMETERS_V5 v5;\n\tPIXEL_CLOCK_PARAMETERS_V6 v6;\n\tPIXEL_CLOCK_PARAMETERS_V7 v7;\n};\n\n \nvoid amdgpu_atombios_crtc_set_disp_eng_pll(struct amdgpu_device *adev,\n\t\t\t\t\t   u32 dispclk)\n{\n\tu8 frev, crev;\n\tint index;\n\tunion set_pixel_clock args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tindex = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 5:\n\t\t\t \n\t\t\targs.v5.ucCRTC = ATOM_CRTC_INVALID;\n\t\t\targs.v5.usPixelClock = cpu_to_le16(dispclk);\n\t\t\targs.v5.ucPpll = ATOM_DCPLL;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t \n\t\t\targs.v6.ulDispEngClkFreq = cpu_to_le32(dispclk);\n\t\t\tif (adev->asic_type == CHIP_TAHITI ||\n\t\t\t    adev->asic_type == CHIP_PITCAIRN ||\n\t\t\t    adev->asic_type == CHIP_VERDE ||\n\t\t\t    adev->asic_type == CHIP_OLAND)\n\t\t\t\targs.v6.ucPpll = ATOM_PPLL0;\n\t\t\telse\n\t\t\t\targs.v6.ucPpll = ATOM_EXT_PLL1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion set_dce_clock {\n\tSET_DCE_CLOCK_PS_ALLOCATION_V1_1 v1_1;\n\tSET_DCE_CLOCK_PS_ALLOCATION_V2_1 v2_1;\n};\n\nu32 amdgpu_atombios_crtc_set_dce_clock(struct amdgpu_device *adev,\n\t\t\t\t       u32 freq, u8 clk_type, u8 clk_src)\n{\n\tu8 frev, crev;\n\tint index;\n\tunion set_dce_clock args;\n\tu32 ret_freq = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tindex = GetIndexIntoMasterTable(COMMAND, SetDCEClock);\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn 0;\n\n\tswitch (frev) {\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\targs.v2_1.asParam.ulDCEClkFreq = cpu_to_le32(freq);  \n\t\t\targs.v2_1.asParam.ucDCEClkType = clk_type;\n\t\t\targs.v2_1.asParam.ucDCEClkSrc = clk_src;\n\t\t\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\tret_freq = le32_to_cpu(args.v2_1.asParam.ulDCEClkFreq) * 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn 0;\n\t}\n\n\treturn ret_freq;\n}\n\nstatic bool is_pixel_clock_source_from_pll(u32 encoder_mode, int pll_id)\n{\n\tif (ENCODER_MODE_IS_DP(encoder_mode)) {\n\t\tif (pll_id < ATOM_EXT_PLL1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nvoid amdgpu_atombios_crtc_program_pll(struct drm_crtc *crtc,\n\t\t\t\t      u32 crtc_id,\n\t\t\t\t      int pll_id,\n\t\t\t\t      u32 encoder_mode,\n\t\t\t\t      u32 encoder_id,\n\t\t\t\t      u32 clock,\n\t\t\t\t      u32 ref_div,\n\t\t\t\t      u32 fb_div,\n\t\t\t\t      u32 frac_fb_div,\n\t\t\t\t      u32 post_div,\n\t\t\t\t      int bpc,\n\t\t\t\t      bool ss_enabled,\n\t\t\t\t      struct amdgpu_atom_ss *ss)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tu8 frev, crev;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\n\tunion set_pixel_clock args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tif (clock == ATOM_DISABLE)\n\t\t\t\treturn;\n\t\t\targs.v1.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v1.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v1.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v1.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v1.ucPostDiv = post_div;\n\t\t\targs.v1.ucPpll = pll_id;\n\t\t\targs.v1.ucCRTC = crtc_id;\n\t\t\targs.v1.ucRefDivSrc = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targs.v2.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v2.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v2.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v2.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v2.ucPostDiv = post_div;\n\t\t\targs.v2.ucPpll = pll_id;\n\t\t\targs.v2.ucCRTC = crtc_id;\n\t\t\targs.v2.ucRefDivSrc = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\targs.v3.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v3.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v3.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v3.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v3.ucPostDiv = post_div;\n\t\t\targs.v3.ucPpll = pll_id;\n\t\t\tif (crtc_id == ATOM_CRTC2)\n\t\t\t\targs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC2;\n\t\t\telse\n\t\t\t\targs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC1;\n\t\t\tif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\n\t\t\t\targs.v3.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;\n\t\t\targs.v3.ucTransmitterId = encoder_id;\n\t\t\targs.v3.ucEncoderMode = encoder_mode;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\targs.v5.ucCRTC = crtc_id;\n\t\t\targs.v5.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v5.ucRefDiv = ref_div;\n\t\t\targs.v5.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\n\t\t\targs.v5.ucPostDiv = post_div;\n\t\t\targs.v5.ucMiscInfo = 0;  \n\t\t\tif ((ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK)) &&\n\t\t\t    (pll_id < ATOM_EXT_PLL1))\n\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_REF_DIV_SRC;\n\t\t\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\t\t\tswitch (bpc) {\n\t\t\t\tcase 8:\n\t\t\t\tdefault:\n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_24BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\t \n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_32BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\t \n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_30BPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.v5.ucTransmitterID = encoder_id;\n\t\t\targs.v5.ucEncoderMode = encoder_mode;\n\t\t\targs.v5.ucPpll = pll_id;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\targs.v6.ulDispEngClkFreq = cpu_to_le32(crtc_id << 24 | clock / 10);\n\t\t\targs.v6.ucRefDiv = ref_div;\n\t\t\targs.v6.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v6.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\n\t\t\targs.v6.ucPostDiv = post_div;\n\t\t\targs.v6.ucMiscInfo = 0;  \n\t\t\tif ((ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK)) &&\n\t\t\t    (pll_id < ATOM_EXT_PLL1) &&\n\t\t\t    !is_pixel_clock_source_from_pll(encoder_mode, pll_id))\n\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_REF_DIV_SRC;\n\t\t\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\t\t\tswitch (bpc) {\n\t\t\t\tcase 8:\n\t\t\t\tdefault:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_24BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_48BPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.v6.ucTransmitterID = encoder_id;\n\t\t\targs.v6.ucEncoderMode = encoder_mode;\n\t\t\targs.v6.ucPpll = pll_id;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\targs.v7.ulPixelClock = cpu_to_le32(clock * 10);  \n\t\t\targs.v7.ucMiscInfo = 0;\n\t\t\tif ((encoder_mode == ATOM_ENCODER_MODE_DVI) &&\n\t\t\t    (clock > 165000))\n\t\t\t\targs.v7.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_DVI_DUALLINK_EN;\n\t\t\targs.v7.ucCRTC = crtc_id;\n\t\t\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\t\t\tswitch (bpc) {\n\t\t\t\tcase 8:\n\t\t\t\tdefault:\n\t\t\t\t\targs.v7.ucDeepColorRatio = PIXEL_CLOCK_V7_DEEPCOLOR_RATIO_DIS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\targs.v7.ucDeepColorRatio = PIXEL_CLOCK_V7_DEEPCOLOR_RATIO_5_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\targs.v7.ucDeepColorRatio = PIXEL_CLOCK_V7_DEEPCOLOR_RATIO_3_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\targs.v7.ucDeepColorRatio = PIXEL_CLOCK_V7_DEEPCOLOR_RATIO_2_1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.v7.ucTransmitterID = encoder_id;\n\t\t\targs.v7.ucEncoderMode = encoder_mode;\n\t\t\targs.v7.ucPpll = pll_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nint amdgpu_atombios_crtc_prepare_pll(struct drm_crtc *crtc,\n\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_encoder *amdgpu_encoder =\n\t\tto_amdgpu_encoder(amdgpu_crtc->encoder);\n\tint encoder_mode = amdgpu_atombios_encoder_get_encoder_mode(amdgpu_crtc->encoder);\n\n\tamdgpu_crtc->bpc = 8;\n\tamdgpu_crtc->ss_enabled = false;\n\n\tif ((amdgpu_encoder->active_device & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\n\t    (amdgpu_encoder_get_dp_bridge_encoder_id(amdgpu_crtc->encoder) != ENCODER_OBJECT_ID_NONE)) {\n\t\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\t\tstruct drm_connector *connector =\n\t\t\tamdgpu_get_connector_for_encoder(amdgpu_crtc->encoder);\n\t\tstruct amdgpu_connector *amdgpu_connector =\n\t\t\tto_amdgpu_connector(connector);\n\t\tstruct amdgpu_connector_atom_dig *dig_connector =\n\t\t\tamdgpu_connector->con_priv;\n\t\tint dp_clock;\n\n\t\t \n\t\tamdgpu_connector->pixelclock_for_modeset = mode->clock;\n\t\tamdgpu_crtc->bpc = amdgpu_connector_get_monitor_bpc(connector);\n\n\t\tswitch (encoder_mode) {\n\t\tcase ATOM_ENCODER_MODE_DP_MST:\n\t\tcase ATOM_ENCODER_MODE_DP:\n\t\t\t \n\t\t\tdp_clock = dig_connector->dp_clock / 10;\n\t\t\tamdgpu_crtc->ss_enabled =\n\t\t\t\tamdgpu_atombios_get_asic_ss_info(adev, &amdgpu_crtc->ss,\n\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_DP,\n\t\t\t\t\t\t\t\t dp_clock);\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_LVDS:\n\t\t\tamdgpu_crtc->ss_enabled =\n\t\t\t\tamdgpu_atombios_get_asic_ss_info(adev,\n\t\t\t\t\t\t\t\t &amdgpu_crtc->ss,\n\t\t\t\t\t\t\t\t dig->lcd_ss_id,\n\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_DVI:\n\t\t\tamdgpu_crtc->ss_enabled =\n\t\t\t\tamdgpu_atombios_get_asic_ss_info(adev,\n\t\t\t\t\t\t\t\t &amdgpu_crtc->ss,\n\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_TMDS,\n\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_HDMI:\n\t\t\tamdgpu_crtc->ss_enabled =\n\t\t\t\tamdgpu_atombios_get_asic_ss_info(adev,\n\t\t\t\t\t\t\t\t &amdgpu_crtc->ss,\n\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_HDMI,\n\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tamdgpu_crtc->adjusted_clock = amdgpu_atombios_crtc_adjust_pll(crtc, mode);\n\n\treturn 0;\n}\n\nvoid amdgpu_atombios_crtc_set_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_encoder *amdgpu_encoder =\n\t\tto_amdgpu_encoder(amdgpu_crtc->encoder);\n\tu32 pll_clock = mode->clock;\n\tu32 clock = mode->clock;\n\tu32 ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;\n\tstruct amdgpu_pll *pll;\n\tint encoder_mode = amdgpu_atombios_encoder_get_encoder_mode(amdgpu_crtc->encoder);\n\n\t \n\tif ((encoder_mode == ATOM_ENCODER_MODE_HDMI) &&\n\t    (amdgpu_crtc->bpc > 8))\n\t\tclock = amdgpu_crtc->adjusted_clock;\n\n\tswitch (amdgpu_crtc->pll_id) {\n\tcase ATOM_PPLL1:\n\t\tpll = &adev->clock.ppll[0];\n\t\tbreak;\n\tcase ATOM_PPLL2:\n\t\tpll = &adev->clock.ppll[1];\n\t\tbreak;\n\tcase ATOM_PPLL0:\n\tcase ATOM_PPLL_INVALID:\n\tdefault:\n\t\tpll = &adev->clock.ppll[2];\n\t\tbreak;\n\t}\n\n\t \n\tpll->flags = amdgpu_crtc->pll_flags;\n\tpll->reference_div = amdgpu_crtc->pll_reference_div;\n\tpll->post_div = amdgpu_crtc->pll_post_div;\n\n\tamdgpu_pll_compute(adev, pll, amdgpu_crtc->adjusted_clock, &pll_clock,\n\t\t\t    &fb_div, &frac_fb_div, &ref_div, &post_div);\n\n\tamdgpu_atombios_crtc_program_ss(adev, ATOM_DISABLE, amdgpu_crtc->pll_id,\n\t\t\t\t amdgpu_crtc->crtc_id, &amdgpu_crtc->ss);\n\n\tamdgpu_atombios_crtc_program_pll(crtc, amdgpu_crtc->crtc_id, amdgpu_crtc->pll_id,\n\t\t\t\t  encoder_mode, amdgpu_encoder->encoder_id, clock,\n\t\t\t\t  ref_div, fb_div, frac_fb_div, post_div,\n\t\t\t\t  amdgpu_crtc->bpc, amdgpu_crtc->ss_enabled, &amdgpu_crtc->ss);\n\n\tif (amdgpu_crtc->ss_enabled) {\n\t\t \n\t\tu32 step_size;\n\t\tu32 amount = (((fb_div * 10) + frac_fb_div) *\n\t\t\t      (u32)amdgpu_crtc->ss.percentage) /\n\t\t\t(100 * (u32)amdgpu_crtc->ss.percentage_divider);\n\t\tamdgpu_crtc->ss.amount = (amount / 10) & ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK;\n\t\tamdgpu_crtc->ss.amount |= ((amount - (amount / 10)) << ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &\n\t\t\tATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK;\n\t\tif (amdgpu_crtc->ss.type & ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD)\n\t\t\tstep_size = (4 * amount * ref_div * ((u32)amdgpu_crtc->ss.rate * 2048)) /\n\t\t\t\t(125 * 25 * pll->reference_freq / 100);\n\t\telse\n\t\t\tstep_size = (2 * amount * ref_div * ((u32)amdgpu_crtc->ss.rate * 2048)) /\n\t\t\t\t(125 * 25 * pll->reference_freq / 100);\n\t\tamdgpu_crtc->ss.step = step_size;\n\n\t\tamdgpu_atombios_crtc_program_ss(adev, ATOM_ENABLE, amdgpu_crtc->pll_id,\n\t\t\t\t\t amdgpu_crtc->crtc_id, &amdgpu_crtc->ss);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}