{
  "module_name": "hdp_v4_0.c",
  "hash_id": "a3c5799c722807f52de90ae0a9d292f00da9c59c6e02cff2c3273662cf61f88f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/hdp_v4_0.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"hdp_v4_0.h\"\n#include \"amdgpu_ras.h\"\n\n#include \"hdp/hdp_4_0_offset.h\"\n#include \"hdp/hdp_4_0_sh_mask.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\n \n#define mmHDP_MEM_POWER_CTRL    0x00d4\n#define HDP_MEM_POWER_CTRL__IPH_MEM_POWER_CTRL_EN_MASK  0x00000001L\n#define HDP_MEM_POWER_CTRL__IPH_MEM_POWER_LS_EN_MASK    0x00000002L\n#define HDP_MEM_POWER_CTRL__RC_MEM_POWER_CTRL_EN_MASK   0x00010000L\n#define HDP_MEM_POWER_CTRL__RC_MEM_POWER_LS_EN_MASK     0x00020000L\n#define mmHDP_MEM_POWER_CTRL_BASE_IDX   0\n\nstatic void hdp_v4_0_flush_hdp(struct amdgpu_device *adev,\n\t\t\t\tstruct amdgpu_ring *ring)\n{\n\tif (!ring || !ring->funcs->emit_wreg)\n\t\tWREG32_NO_KIQ((adev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL) >> 2, 0);\n\telse\n\t\tamdgpu_ring_emit_wreg(ring, (adev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL) >> 2, 0);\n}\n\nstatic void hdp_v4_0_invalidate_hdp(struct amdgpu_device *adev,\n\t\t\t\t    struct amdgpu_ring *ring)\n{\n\tif (adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 4, 0) ||\n\t    adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 4, 2))\n\t\treturn;\n\n\tif (!ring || !ring->funcs->emit_wreg)\n\t\tWREG32_SOC15_NO_KIQ(HDP, 0, mmHDP_READ_CACHE_INVALIDATE, 1);\n\telse\n\t\tamdgpu_ring_emit_wreg(ring, SOC15_REG_OFFSET(\n\t\t\tHDP, 0, mmHDP_READ_CACHE_INVALIDATE), 1);\n}\n\nstatic void hdp_v4_0_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\t   void *ras_error_status)\n{\n\tstruct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;\n\n\terr_data->ue_count = 0;\n\terr_data->ce_count = 0;\n\n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__HDP))\n\t\treturn;\n\n\t \n\terr_data->ue_count += RREG32_SOC15(HDP, 0, mmHDP_EDC_CNT);\n};\n\nstatic void hdp_v4_0_reset_ras_error_count(struct amdgpu_device *adev)\n{\n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__HDP))\n\t\treturn;\n\n\tif (adev->ip_versions[HDP_HWIP][0] >= IP_VERSION(4, 4, 0))\n\t\tWREG32_SOC15(HDP, 0, mmHDP_EDC_CNT, 0);\n\telse\n\t\t \n\t\tRREG32_SOC15(HDP, 0, mmHDP_EDC_CNT);\n}\n\nstatic void hdp_v4_0_update_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t bool enable)\n{\n\tuint32_t def, data;\n\n\tif (adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 0, 0) ||\n\t    adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 0, 1) ||\n\t    adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 1, 1) ||\n\t    adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 1, 0)) {\n\t\tdef = data = RREG32(SOC15_REG_OFFSET(HDP, 0, mmHDP_MEM_POWER_LS));\n\n\t\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_HDP_LS))\n\t\t\tdata |= HDP_MEM_POWER_LS__LS_ENABLE_MASK;\n\t\telse\n\t\t\tdata &= ~HDP_MEM_POWER_LS__LS_ENABLE_MASK;\n\n\t\tif (def != data)\n\t\t\tWREG32(SOC15_REG_OFFSET(HDP, 0, mmHDP_MEM_POWER_LS), data);\n\t} else {\n\t\tdef = data = RREG32(SOC15_REG_OFFSET(HDP, 0, mmHDP_MEM_POWER_CTRL));\n\n\t\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_HDP_LS))\n\t\t\tdata |= HDP_MEM_POWER_CTRL__IPH_MEM_POWER_CTRL_EN_MASK |\n\t\t\t\tHDP_MEM_POWER_CTRL__IPH_MEM_POWER_LS_EN_MASK |\n\t\t\t\tHDP_MEM_POWER_CTRL__RC_MEM_POWER_CTRL_EN_MASK |\n\t\t\t\tHDP_MEM_POWER_CTRL__RC_MEM_POWER_LS_EN_MASK;\n\t\telse\n\t\t\tdata &= ~(HDP_MEM_POWER_CTRL__IPH_MEM_POWER_CTRL_EN_MASK |\n\t\t\t\t  HDP_MEM_POWER_CTRL__IPH_MEM_POWER_LS_EN_MASK |\n\t\t\t\t  HDP_MEM_POWER_CTRL__RC_MEM_POWER_CTRL_EN_MASK |\n\t\t\t\t  HDP_MEM_POWER_CTRL__RC_MEM_POWER_LS_EN_MASK);\n\n\t\tif (def != data)\n\t\t\tWREG32(SOC15_REG_OFFSET(HDP, 0, mmHDP_MEM_POWER_CTRL), data);\n\t}\n}\n\nstatic void hdp_v4_0_get_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t    u64 *flags)\n{\n\tint data;\n\n\t \n\tdata = RREG32(SOC15_REG_OFFSET(HDP, 0, mmHDP_MEM_POWER_LS));\n\tif (data & HDP_MEM_POWER_LS__LS_ENABLE_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_HDP_LS;\n}\n\nstatic void hdp_v4_0_init_registers(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[HDP_HWIP][0]) {\n\tcase IP_VERSION(4, 2, 1):\n\t\tWREG32_FIELD15(HDP, 0, HDP_MMHUB_CNTL, HDP_MMHUB_GCC, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWREG32_FIELD15(HDP, 0, HDP_MISC_CNTL, FLUSH_INVALIDATE_CACHE, 1);\n\n\tif (adev->ip_versions[HDP_HWIP][0] == IP_VERSION(4, 4, 0))\n\t\tWREG32_FIELD15(HDP, 0, HDP_MISC_CNTL, READ_BUFFER_WATERMARK, 2);\n\n\tWREG32_SOC15(HDP, 0, mmHDP_NONSURFACE_BASE, (adev->gmc.vram_start >> 8));\n\tWREG32_SOC15(HDP, 0, mmHDP_NONSURFACE_BASE_HI, (adev->gmc.vram_start >> 40));\n}\n\nstruct amdgpu_ras_block_hw_ops hdp_v4_0_ras_hw_ops = {\n\t.query_ras_error_count = hdp_v4_0_query_ras_error_count,\n\t.reset_ras_error_count = hdp_v4_0_reset_ras_error_count,\n};\n\nstruct amdgpu_hdp_ras hdp_v4_0_ras = {\n\t.ras_block = {\n\t\t.hw_ops = &hdp_v4_0_ras_hw_ops,\n\t},\n};\n\nconst struct amdgpu_hdp_funcs hdp_v4_0_funcs = {\n\t.flush_hdp = hdp_v4_0_flush_hdp,\n\t.invalidate_hdp = hdp_v4_0_invalidate_hdp,\n\t.update_clock_gating = hdp_v4_0_update_clock_gating,\n\t.get_clock_gating_state = hdp_v4_0_get_clockgating_state,\n\t.init_registers = hdp_v4_0_init_registers,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}