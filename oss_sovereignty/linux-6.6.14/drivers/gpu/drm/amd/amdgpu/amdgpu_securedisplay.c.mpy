{
  "module_name": "amdgpu_securedisplay.c",
  "hash_id": "106f80695a451ea8aa4524803edfdf371b5f5499e3472b55b8673ccead2a0ef0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_securedisplay.c",
  "human_readable_source": " \n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_securedisplay.h\"\n\n \n\nvoid psp_securedisplay_parse_resp_status(struct psp_context *psp,\n\tenum ta_securedisplay_status status)\n{\n\tswitch (status) {\n\tcase TA_SECUREDISPLAY_STATUS__SUCCESS:\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__GENERIC_FAILURE:\n\t\tdev_err(psp->adev->dev, \"Secure display: Generic Failure.\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__INVALID_PARAMETER:\n\t\tdev_err(psp->adev->dev, \"Secure display: Invalid Parameter.\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__NULL_POINTER:\n\t\tdev_err(psp->adev->dev, \"Secure display: Null Pointer.\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__I2C_WRITE_ERROR:\n\t\tdev_err(psp->adev->dev, \"Secure display: Failed to write to I2C.\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__READ_DIO_SCRATCH_ERROR:\n\t\tdev_err(psp->adev->dev, \"Secure display: Failed to Read DIO Scratch Register.\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__READ_CRC_ERROR:\n\t\tdev_err(psp->adev->dev, \"Secure display: Failed to Read CRC\");\n\t\tbreak;\n\tcase TA_SECUREDISPLAY_STATUS__I2C_INIT_ERROR:\n\t\tdev_err(psp->adev->dev, \"Secure display: Failed to initialize I2C.\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(psp->adev->dev, \"Secure display: Failed to parse status: %d\\n\", status);\n\t}\n}\n\nvoid psp_prep_securedisplay_cmd_buf(struct psp_context *psp, struct ta_securedisplay_cmd **cmd,\n\tenum ta_securedisplay_command command_id)\n{\n\t*cmd = (struct ta_securedisplay_cmd *)psp->securedisplay_context.context.mem_context.shared_buf;\n\tmemset(*cmd, 0, sizeof(struct ta_securedisplay_cmd));\n\t(*cmd)->status = TA_SECUREDISPLAY_STATUS__GENERIC_FAILURE;\n\t(*cmd)->cmd_id = command_id;\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic ssize_t amdgpu_securedisplay_debugfs_write(struct file *f, const char __user *buf,\n\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)file_inode(f)->i_private;\n\tstruct psp_context *psp = &adev->psp;\n\tstruct ta_securedisplay_cmd *securedisplay_cmd;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tuint32_t phy_id;\n\tuint32_t op;\n\tchar str[64];\n\tint ret;\n\n\tif (*pos || size > sizeof(str) - 1)\n\t\treturn -EINVAL;\n\n\tmemset(str,  0, sizeof(str));\n\tret = copy_from_user(str, buf, size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tif (size < 3)\n\t\tsscanf(str, \"%u \", &op);\n\telse\n\t\tsscanf(str, \"%u %u\", &op, &phy_id);\n\n\tswitch (op) {\n\tcase 1:\n\t\tmutex_lock(&psp->securedisplay_context.mutex);\n\t\tpsp_prep_securedisplay_cmd_buf(psp, &securedisplay_cmd,\n\t\t\tTA_SECUREDISPLAY_COMMAND__QUERY_TA);\n\t\tret = psp_securedisplay_invoke(psp, TA_SECUREDISPLAY_COMMAND__QUERY_TA);\n\t\tif (!ret) {\n\t\t\tif (securedisplay_cmd->status == TA_SECUREDISPLAY_STATUS__SUCCESS)\n\t\t\t\tdev_info(adev->dev, \"SECUREDISPLAY: query securedisplay TA ret is 0x%X\\n\",\n\t\t\t\t\tsecuredisplay_cmd->securedisplay_out_message.query_ta.query_cmd_ret);\n\t\t\telse\n\t\t\t\tpsp_securedisplay_parse_resp_status(psp, securedisplay_cmd->status);\n\t\t}\n\t\tmutex_unlock(&psp->securedisplay_context.mutex);\n\t\tbreak;\n\tcase 2:\n\t\tmutex_lock(&psp->securedisplay_context.mutex);\n\t\tpsp_prep_securedisplay_cmd_buf(psp, &securedisplay_cmd,\n\t\t\tTA_SECUREDISPLAY_COMMAND__SEND_ROI_CRC);\n\t\tsecuredisplay_cmd->securedisplay_in_message.send_roi_crc.phy_id = phy_id;\n\t\tret = psp_securedisplay_invoke(psp, TA_SECUREDISPLAY_COMMAND__SEND_ROI_CRC);\n\t\tif (!ret) {\n\t\t\tif (securedisplay_cmd->status == TA_SECUREDISPLAY_STATUS__SUCCESS) {\n\t\t\t\tdev_info(adev->dev, \"SECUREDISPLAY: I2C buffer out put is: %*ph\\n\",\n\t\t\t\t\t TA_SECUREDISPLAY_I2C_BUFFER_SIZE,\n\t\t\t\t\t securedisplay_cmd->securedisplay_out_message.send_roi_crc.i2c_buf);\n\t\t\t} else {\n\t\t\t\tpsp_securedisplay_parse_resp_status(psp, securedisplay_cmd->status);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&psp->securedisplay_context.mutex);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adev->dev, \"Invalid input: %s\\n\", str);\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn size;\n}\n\nstatic const struct file_operations amdgpu_securedisplay_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.read = NULL,\n\t.write = amdgpu_securedisplay_debugfs_write,\n\t.llseek = default_llseek\n};\n\n#endif\n\nvoid amdgpu_securedisplay_debugfs_init(struct amdgpu_device *adev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\n\tif (!adev->psp.securedisplay_context.context.initialized)\n\t\treturn;\n\n\tdebugfs_create_file(\"securedisplay_test\", S_IWUSR, adev_to_drm(adev)->primary->debugfs_root,\n\t\t\t\tadev, &amdgpu_securedisplay_debugfs_ops);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}