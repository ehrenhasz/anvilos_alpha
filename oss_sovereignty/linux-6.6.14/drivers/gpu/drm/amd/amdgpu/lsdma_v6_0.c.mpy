{
  "module_name": "lsdma_v6_0.c",
  "hash_id": "0607d8fdee7ea1767becbd8de52b2d72df6ab6ca1bc1156c4679aebc9da2785f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/lsdma_v6_0.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include \"amdgpu.h\"\n#include \"lsdma_v6_0.h\"\n#include \"amdgpu_lsdma.h\"\n\n#include \"lsdma/lsdma_6_0_0_offset.h\"\n#include \"lsdma/lsdma_6_0_0_sh_mask.h\"\n\nstatic int lsdma_v6_0_wait_pio_status(struct amdgpu_device *adev)\n{\n\treturn amdgpu_lsdma_wait_for(adev, SOC15_REG_OFFSET(LSDMA, 0, regLSDMA_PIO_STATUS),\n\t\t\tLSDMA_PIO_STATUS__PIO_IDLE_MASK | LSDMA_PIO_STATUS__PIO_FIFO_EMPTY_MASK,\n\t\t\tLSDMA_PIO_STATUS__PIO_IDLE_MASK | LSDMA_PIO_STATUS__PIO_FIFO_EMPTY_MASK);\n}\n\nstatic int lsdma_v6_0_copy_mem(struct amdgpu_device *adev,\n\t\t\t       uint64_t src_addr,\n\t\t\t       uint64_t dst_addr,\n\t\t\t       uint64_t size)\n{\n\tint ret;\n\tuint32_t tmp;\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_SRC_ADDR_LO, lower_32_bits(src_addr));\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_SRC_ADDR_HI, upper_32_bits(src_addr));\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_DST_ADDR_LO, lower_32_bits(dst_addr));\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_DST_ADDR_HI, upper_32_bits(dst_addr));\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_CONTROL, 0x0);\n\n\ttmp = RREG32_SOC15(LSDMA, 0, regLSDMA_PIO_COMMAND);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, BYTE_COUNT, size);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, SRC_LOCATION, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, DST_LOCATION, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, SRC_ADDR_INC, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, DST_ADDR_INC, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, OVERLAP_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, CONSTANT_FILL, 0);\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_COMMAND, tmp);\n\n\tret = lsdma_v6_0_wait_pio_status(adev);\n\tif (ret)\n\t\tdev_err(adev->dev, \"LSDMA PIO failed to copy memory!\\n\");\n\n\treturn ret;\n}\n\nstatic int lsdma_v6_0_fill_mem(struct amdgpu_device *adev,\n\t\t\t       uint64_t dst_addr,\n\t\t\t       uint32_t data,\n\t\t\t       uint64_t size)\n{\n\tint ret;\n\tuint32_t tmp;\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_CONSTFILL_DATA, data);\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_DST_ADDR_LO, lower_32_bits(dst_addr));\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_DST_ADDR_HI, upper_32_bits(dst_addr));\n\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_CONTROL, 0x0);\n\n\ttmp = RREG32_SOC15(LSDMA, 0, regLSDMA_PIO_COMMAND);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, BYTE_COUNT, size);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, SRC_LOCATION, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, DST_LOCATION, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, SRC_ADDR_INC, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, DST_ADDR_INC, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, OVERLAP_DISABLE, 0);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_PIO_COMMAND, CONSTANT_FILL, 1);\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_PIO_COMMAND, tmp);\n\n\tret = lsdma_v6_0_wait_pio_status(adev);\n\tif (ret)\n\t\tdev_err(adev->dev, \"LSDMA PIO failed to fill memory!\\n\");\n\n\treturn ret;\n}\n\nstatic void lsdma_v6_0_update_memory_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t bool enable)\n{\n\tuint32_t tmp;\n\n\ttmp = RREG32_SOC15(LSDMA, 0, regLSDMA_MEM_POWER_CTRL);\n\ttmp = REG_SET_FIELD(tmp, LSDMA_MEM_POWER_CTRL, MEM_POWER_CTRL_EN, 0);\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_MEM_POWER_CTRL, tmp);\n\n\ttmp = REG_SET_FIELD(tmp, LSDMA_MEM_POWER_CTRL, MEM_POWER_CTRL_EN, enable);\n\tWREG32_SOC15(LSDMA, 0, regLSDMA_MEM_POWER_CTRL, tmp);\n}\n\nconst struct amdgpu_lsdma_funcs lsdma_v6_0_funcs = {\n\t.copy_mem = lsdma_v6_0_copy_mem,\n\t.fill_mem = lsdma_v6_0_fill_mem,\n\t.update_memory_power_gating = lsdma_v6_0_update_memory_power_gating\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}