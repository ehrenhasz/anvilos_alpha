{
  "module_name": "amdgpu_psp_ta.c",
  "hash_id": "70a1e5d2347632bc75ae5150e5ed8fbe01da977ff5433aba87341e9091e9fdac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_psp_ta.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_psp_ta.h\"\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic ssize_t ta_if_load_debugfs_write(struct file *fp, const char *buf,\n\t\t\t\t\t    size_t len, loff_t *off);\nstatic ssize_t ta_if_unload_debugfs_write(struct file *fp, const char *buf,\n\t\t\t\t\t    size_t len, loff_t *off);\nstatic ssize_t ta_if_invoke_debugfs_write(struct file *fp, const char *buf,\n\t\t\t\t\t    size_t len, loff_t *off);\n\nstatic uint32_t get_bin_version(const uint8_t *bin)\n{\n\tconst struct common_firmware_header *hdr =\n\t\t\t     (const struct common_firmware_header *)bin;\n\n\treturn hdr->ucode_version;\n}\n\nstatic int prep_ta_mem_context(struct ta_mem_context *mem_context,\n\t\t\t\t\t     uint8_t *shared_buf,\n\t\t\t\t\t     uint32_t shared_buf_len)\n{\n\tif (mem_context->shared_mem_size < shared_buf_len)\n\t\treturn -EINVAL;\n\tmemset(mem_context->shared_buf, 0, mem_context->shared_mem_size);\n\tmemcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len);\n\n\treturn 0;\n}\n\nstatic bool is_ta_type_valid(enum ta_type_id ta_type)\n{\n\tswitch (ta_type) {\n\tcase TA_TYPE_RAS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct ta_funcs ras_ta_funcs = {\n\t.fn_ta_initialize = psp_ras_initialize,\n\t.fn_ta_invoke    = psp_ras_invoke,\n\t.fn_ta_terminate = psp_ras_terminate\n};\n\nstatic void set_ta_context_funcs(struct psp_context *psp,\n\t\t\t\t\t\t      enum ta_type_id ta_type,\n\t\t\t\t\t\t      struct ta_context **pcontext)\n{\n\tswitch (ta_type) {\n\tcase TA_TYPE_RAS:\n\t\t*pcontext = &psp->ras_context.context;\n\t\tpsp->ta_funcs = &ras_ta_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct file_operations ta_load_debugfs_fops = {\n\t.write  = ta_if_load_debugfs_write,\n\t.llseek = default_llseek,\n\t.owner  = THIS_MODULE\n};\n\nstatic const struct file_operations ta_unload_debugfs_fops = {\n\t.write  = ta_if_unload_debugfs_write,\n\t.llseek = default_llseek,\n\t.owner  = THIS_MODULE\n};\n\nstatic const struct file_operations ta_invoke_debugfs_fops = {\n\t.write  = ta_if_invoke_debugfs_write,\n\t.llseek = default_llseek,\n\t.owner  = THIS_MODULE\n};\n\n \n\nstatic ssize_t ta_if_load_debugfs_write(struct file *fp, const char *buf, size_t len, loff_t *off)\n{\n\tuint32_t ta_type    = 0;\n\tuint32_t ta_bin_len = 0;\n\tuint8_t  *ta_bin    = NULL;\n\tuint32_t copy_pos   = 0;\n\tint      ret        = 0;\n\n\tstruct amdgpu_device *adev    = (struct amdgpu_device *)file_inode(fp)->i_private;\n\tstruct psp_context   *psp     = &adev->psp;\n\tstruct ta_context    *context = NULL;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = copy_from_user((void *)&ta_type, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret || (!is_ta_type_valid(ta_type)))\n\t\treturn -EFAULT;\n\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&ta_bin_len, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tcopy_pos += sizeof(uint32_t);\n\n\tta_bin = kzalloc(ta_bin_len, GFP_KERNEL);\n\tif (!ta_bin)\n\t\treturn -ENOMEM;\n\tif (copy_from_user((void *)ta_bin, &buf[copy_pos], ta_bin_len)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_bin;\n\t}\n\n\t \n\tset_ta_context_funcs(psp, ta_type, &context);\n\n\tif (!psp->ta_funcs || !psp->ta_funcs->fn_ta_terminate) {\n\t\tdev_err(adev->dev, \"Unsupported function to terminate TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_bin;\n\t}\n\n\t \n\tif (!context->mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &context->mem_context);\n\t\tif (ret) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_bin;\n\t\t}\n\t}\n\n\tret = psp_fn_ta_terminate(psp);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to unload embedded TA (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\t \n\tcontext->ta_type                     = ta_type;\n\tcontext->bin_desc.fw_version         = get_bin_version(ta_bin);\n\tcontext->bin_desc.size_bytes         = ta_bin_len;\n\tcontext->bin_desc.start_addr         = ta_bin;\n\n\tif (!psp->ta_funcs->fn_ta_initialize) {\n\t\tdev_err(adev->dev, \"Unsupported function to initialize TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\tret = psp_fn_ta_initialize(psp);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev, \"Failed to load TA via debugfs (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\tif (copy_to_user((char *)buf, (void *)&context->session_id, sizeof(uint32_t)))\n\t\tret = -EFAULT;\n\nerr_free_ta_shared_buf:\n\t \n\tif (ret && context->mem_context.shared_buf)\n\t\tpsp_ta_free_shared_buf(&context->mem_context);\nerr_free_bin:\n\tkfree(ta_bin);\n\n\treturn ret;\n}\n\nstatic ssize_t ta_if_unload_debugfs_write(struct file *fp, const char *buf, size_t len, loff_t *off)\n{\n\tuint32_t ta_type    = 0;\n\tuint32_t ta_id      = 0;\n\tuint32_t copy_pos   = 0;\n\tint      ret        = 0;\n\n\tstruct amdgpu_device *adev    = (struct amdgpu_device *)file_inode(fp)->i_private;\n\tstruct psp_context   *psp     = &adev->psp;\n\tstruct ta_context    *context = NULL;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = copy_from_user((void *)&ta_type, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret || (!is_ta_type_valid(ta_type)))\n\t\treturn -EFAULT;\n\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&ta_id, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tset_ta_context_funcs(psp, ta_type, &context);\n\tcontext->session_id = ta_id;\n\n\tif (!psp->ta_funcs || !psp->ta_funcs->fn_ta_terminate) {\n\t\tdev_err(adev->dev, \"Unsupported function to terminate TA\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = psp_fn_ta_terminate(psp);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev, \"Failed to unload TA via debugfs (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (context->mem_context.shared_buf)\n\t\tpsp_ta_free_shared_buf(&context->mem_context);\n\n\treturn ret;\n}\n\nstatic ssize_t ta_if_invoke_debugfs_write(struct file *fp, const char *buf, size_t len, loff_t *off)\n{\n\tuint32_t ta_type        = 0;\n\tuint32_t ta_id          = 0;\n\tuint32_t cmd_id         = 0;\n\tuint32_t shared_buf_len = 0;\n\tuint8_t *shared_buf     = NULL;\n\tuint32_t copy_pos       = 0;\n\tint      ret            = 0;\n\n\tstruct amdgpu_device *adev    = (struct amdgpu_device *)file_inode(fp)->i_private;\n\tstruct psp_context   *psp     = &adev->psp;\n\tstruct ta_context    *context = NULL;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = copy_from_user((void *)&ta_type, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&ta_id, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&cmd_id, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&shared_buf_len, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tshared_buf = kzalloc(shared_buf_len, GFP_KERNEL);\n\tif (!shared_buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user((void *)shared_buf, &buf[copy_pos], shared_buf_len)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tset_ta_context_funcs(psp, ta_type, &context);\n\n\tif (!context->initialized) {\n\t\tdev_err(adev->dev, \"TA is not initialized\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tif (!psp->ta_funcs || !psp->ta_funcs->fn_ta_invoke) {\n\t\tdev_err(adev->dev, \"Unsupported function to invoke TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tcontext->session_id = ta_id;\n\n\tret = prep_ta_mem_context(&context->mem_context, shared_buf, shared_buf_len);\n\tif (ret)\n\t\tgoto err_free_shared_buf;\n\n\tret = psp_fn_ta_invoke(psp, cmd_id);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev, \"Failed to invoke TA via debugfs (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_shared_buf;\n\t\t}\n\t}\n\n\tif (copy_to_user((char *)buf, context->mem_context.shared_buf, shared_buf_len))\n\t\tret = -EFAULT;\n\nerr_free_shared_buf:\n\tkfree(shared_buf);\n\n\treturn ret;\n}\n\nvoid amdgpu_ta_if_debugfs_init(struct amdgpu_device *adev)\n{\n\tstruct drm_minor *minor = adev_to_drm(adev)->primary;\n\n\tstruct dentry *dir = debugfs_create_dir(\"ta_if\", minor->debugfs_root);\n\n\tdebugfs_create_file(\"ta_load\", 0200, dir, adev,\n\t\t\t\t     &ta_load_debugfs_fops);\n\n\tdebugfs_create_file(\"ta_unload\", 0200, dir,\n\t\t\t\t     adev, &ta_unload_debugfs_fops);\n\n\tdebugfs_create_file(\"ta_invoke\", 0200, dir,\n\t\t\t\t     adev, &ta_invoke_debugfs_fops);\n}\n\n#else\nvoid amdgpu_ta_if_debugfs_init(struct amdgpu_device *adev)\n{\n\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}