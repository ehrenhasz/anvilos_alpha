{
  "module_name": "uvd_v4_2.c",
  "hash_id": "79522fa0123ede4589695fdcda9dc9e38d873ee684a9d4008d4644b14cf5d756",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_uvd.h\"\n#include \"cikd.h\"\n\n#include \"uvd/uvd_4_2_d.h\"\n#include \"uvd/uvd_4_2_sh_mask.h\"\n\n#include \"oss/oss_2_0_d.h\"\n#include \"oss/oss_2_0_sh_mask.h\"\n\n#include \"bif/bif_4_1_d.h\"\n\n#include \"smu/smu_7_0_1_d.h\"\n#include \"smu/smu_7_0_1_sh_mask.h\"\n\nstatic void uvd_v4_2_mc_resume(struct amdgpu_device *adev);\nstatic void uvd_v4_2_set_ring_funcs(struct amdgpu_device *adev);\nstatic void uvd_v4_2_set_irq_funcs(struct amdgpu_device *adev);\nstatic int uvd_v4_2_start(struct amdgpu_device *adev);\nstatic void uvd_v4_2_stop(struct amdgpu_device *adev);\nstatic int uvd_v4_2_set_clockgating_state(void *handle,\n\t\t\t\tenum amd_clockgating_state state);\nstatic void uvd_v4_2_set_dcm(struct amdgpu_device *adev,\n\t\t\t     bool sw_mode);\n \nstatic uint64_t uvd_v4_2_ring_get_rptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_RPTR);\n}\n\n \nstatic uint64_t uvd_v4_2_ring_get_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\treturn RREG32(mmUVD_RBC_RB_WPTR);\n}\n\n \nstatic void uvd_v4_2_ring_set_wptr(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n}\n\nstatic int uvd_v4_2_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tadev->uvd.num_uvd_inst = 1;\n\n\tuvd_v4_2_set_ring_funcs(adev);\n\tuvd_v4_2_set_irq_funcs(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v4_2_sw_init(void *handle)\n{\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 124, &adev->uvd.inst->irq);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tring = &adev->uvd.inst->ring;\n\tsprintf(ring->name, \"uvd\");\n\tr = amdgpu_ring_init(adev, ring, 512, &adev->uvd.inst->irq, 0,\n\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_uvd_entity_init(adev);\n\n\treturn r;\n}\n\nstatic int uvd_v4_2_sw_fini(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_suspend(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn amdgpu_uvd_sw_fini(adev);\n}\n\nstatic void uvd_v4_2_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable);\n \nstatic int uvd_v4_2_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t tmp;\n\tint r;\n\n\tuvd_v4_2_enable_mgcg(adev, true);\n\tamdgpu_asic_set_uvd_clocks(adev, 10000, 10000);\n\n\tr = amdgpu_ring_test_helper(ring);\n\tif (r)\n\t\tgoto done;\n\n\tr = amdgpu_ring_alloc(ring, 10);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: ring failed to lock UVD ring (%d).\\n\", r);\n\t\tgoto done;\n\t}\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(mmUVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0xFFFFF);\n\n\t \n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_TIMEOUT_STATUS, 0));\n\tamdgpu_ring_write(ring, 0x8);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_CNTL, 0));\n\tamdgpu_ring_write(ring, 3);\n\n\tamdgpu_ring_commit(ring);\n\ndone:\n\tif (!r)\n\t\tDRM_INFO(\"UVD initialized successfully.\\n\");\n\n\treturn r;\n}\n\n \nstatic int uvd_v4_2_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (RREG32(mmUVD_STATUS) != 0)\n\t\tuvd_v4_2_stop(adev);\n\n\treturn 0;\n}\n\nstatic int uvd_v4_2_suspend(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\tcancel_delayed_work_sync(&adev->uvd.idle_work);\n\n\tif (adev->pm.dpm_enabled) {\n\t\tamdgpu_dpm_enable_uvd(adev, false);\n\t} else {\n\t\tamdgpu_asic_set_uvd_clocks(adev, 0, 0);\n\t\t \n\t\tamdgpu_device_ip_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_PG_STATE_GATE);\n\t\tamdgpu_device_ip_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\n\t\t\t\t\t\t       AMD_CG_STATE_GATE);\n\t}\n\n\tr = uvd_v4_2_hw_fini(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn amdgpu_uvd_suspend(adev);\n}\n\nstatic int uvd_v4_2_resume(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = amdgpu_uvd_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn uvd_v4_2_hw_init(adev);\n}\n\n \nstatic int uvd_v4_2_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->uvd.inst->ring;\n\tuint32_t rb_bufsz;\n\tint i, j, r;\n\tu32 tmp;\n\t \n\tu32 lmi_swap_cntl = 0;\n\tu32 mp_swap_cntl = 0;\n\n\t \n\tWREG32_P(mmUVD_STATUS, 1<<2, ~(1<<2));\n\n\tuvd_v4_2_set_dcm(adev, true);\n\tWREG32(mmUVD_CGC_GATE, 0);\n\n\t \n\tWREG32_P(mmSRBM_SOFT_RESET, 0, ~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\n\tmdelay(5);\n\n\t \n\tWREG32(mmUVD_VCPU_CNTL,  1 << 9);\n\n\t \n\tWREG32_P(mmUVD_MASTINT_EN, 0, ~(1 << 1));\n\n#ifdef __BIG_ENDIAN\n\t \n\tlmi_swap_cntl = 0xa;\n\tmp_swap_cntl = 0;\n#endif\n\tWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\n\tWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\n\t \n\tWREG32(mmUVD_LMI_CTRL, 0x203108);\n\n\ttmp = RREG32(mmUVD_MPC_CNTL);\n\tWREG32(mmUVD_MPC_CNTL, tmp | 0x10);\n\n\tWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\n\tWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\n\tWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\n\tWREG32(mmUVD_MPC_SET_ALU, 0);\n\tWREG32(mmUVD_MPC_SET_MUX, 0x88);\n\n\tuvd_v4_2_mc_resume(adev);\n\n\ttmp = RREG32_UVD_CTX(ixUVD_LMI_CACHE_CTRL);\n\tWREG32_UVD_CTX(ixUVD_LMI_CACHE_CTRL, tmp & (~0x10));\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\n\n\tWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__LMI_SOFT_RESET_MASK);\n\n\tWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\n\n\tWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\n\tmdelay(10);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR(\"UVD not responding, trying to reset the VCPU!!!\\n\");\n\t\tWREG32_P(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK,\n\t\t\t\t~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\t\tmdelay(10);\n\t\tWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\tif (r) {\n\t\tDRM_ERROR(\"UVD not responding, giving up!!!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tWREG32_P(mmUVD_MASTINT_EN, 3<<1, ~(3 << 1));\n\n\tWREG32_P(mmUVD_STATUS, 0, ~(1<<2));\n\n\t \n\tWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\n\n\t \n\tWREG32(mmUVD_RBC_RB_WPTR_CNTL, 0);\n\n\t \n\tWREG32(mmUVD_LMI_EXT40_ADDR, upper_32_bits(ring->gpu_addr) |\n\t\t\t\t   (0x7 << 16) | (0x1 << 31));\n\n\t \n\tWREG32(mmUVD_RBC_RB_RPTR, 0x0);\n\n\tring->wptr = RREG32(mmUVD_RBC_RB_RPTR);\n\tWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\n\n\t \n\tWREG32(mmUVD_RBC_RB_BASE, ring->gpu_addr);\n\n\t \n\trb_bufsz = order_base_2(ring->ring_size);\n\trb_bufsz = (0x1 << 8) | rb_bufsz;\n\tWREG32_P(mmUVD_RBC_RB_CNTL, rb_bufsz, ~0x11f1f);\n\n\treturn 0;\n}\n\n \nstatic void uvd_v4_2_stop(struct amdgpu_device *adev)\n{\n\tuint32_t i, j;\n\tuint32_t status;\n\n\tWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\t\tif (status & 2)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_LMI_STATUS);\n\t\t\tif (status & 0xf)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\t\tif (status & 0xf)\n\t\t\tbreak;\n\t}\n\n\t \n\tWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(mmUVD_LMI_STATUS);\n\t\t\tif (status & 0x240)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\t\tif (status & 0x240)\n\t\t\tbreak;\n\t}\n\n\tWREG32_P(0x3D49, 0, ~(1 << 2));\n\n\tWREG32_P(mmUVD_VCPU_CNTL, 0, ~(1 << 9));\n\n\t \n\tWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK |\n\t\tUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\n\n\tWREG32(mmUVD_STATUS, 0);\n\n\tuvd_v4_2_set_dcm(adev, false);\n}\n\n \nstatic void uvd_v4_2_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\n\t\t\t\t     unsigned flags)\n{\n\tWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, seq);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, addr & 0xffffffff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, upper_32_bits(addr) & 0xff);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\n\tamdgpu_ring_write(ring, 2);\n}\n\n \nstatic int uvd_v4_2_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(mmUVD_CONTEXT_ID, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(mmUVD_CONTEXT_ID);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\treturn r;\n}\n\n \nstatic void uvd_v4_2_ring_emit_ib(struct amdgpu_ring *ring,\n\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t  uint32_t flags)\n{\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_BASE, 0));\n\tamdgpu_ring_write(ring, ib->gpu_addr);\n\tamdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_SIZE, 0));\n\tamdgpu_ring_write(ring, ib->length_dw);\n}\n\nstatic void uvd_v4_2_ring_insert_nop(struct amdgpu_ring *ring, uint32_t count)\n{\n\tint i;\n\n\tWARN_ON(ring->wptr % 2 || count % 2);\n\n\tfor (i = 0; i < count / 2; i++) {\n\t\tamdgpu_ring_write(ring, PACKET0(mmUVD_NO_OP, 0));\n\t\tamdgpu_ring_write(ring, 0);\n\t}\n}\n\n \nstatic void uvd_v4_2_mc_resume(struct amdgpu_device *adev)\n{\n\tuint64_t addr;\n\tuint32_t size;\n\n\t \n\taddr = (adev->uvd.inst->gpu_addr + AMDGPU_UVD_FIRMWARE_OFFSET) >> 3;\n\tsize = AMDGPU_UVD_FIRMWARE_SIZE(adev) >> 3;\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET0, addr);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE0, size);\n\n\taddr += size;\n\tsize = AMDGPU_UVD_HEAP_SIZE >> 3;\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET1, addr);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE1, size);\n\n\taddr += size;\n\tsize = (AMDGPU_UVD_STACK_SIZE +\n\t       (AMDGPU_UVD_SESSION_SIZE * adev->uvd.max_handles)) >> 3;\n\tWREG32(mmUVD_VCPU_CACHE_OFFSET2, addr);\n\tWREG32(mmUVD_VCPU_CACHE_SIZE2, size);\n\n\t \n\taddr = (adev->uvd.inst->gpu_addr >> 28) & 0xF;\n\tWREG32(mmUVD_LMI_ADDR_EXT, (addr << 12) | (addr << 0));\n\n\t \n\taddr = (adev->uvd.inst->gpu_addr >> 32) & 0xFF;\n\tWREG32(mmUVD_LMI_EXT40_ADDR, addr | (0x9 << 16) | (0x1 << 31));\n\n\tWREG32(mmUVD_UDEC_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n\tWREG32(mmUVD_UDEC_DBW_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\n}\n\nstatic void uvd_v4_2_enable_mgcg(struct amdgpu_device *adev,\n\t\t\t\t bool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_UVD_MGCG)) {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata |= 0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t} else {\n\t\tdata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\n\t\tdata &= ~0xfff;\n\t\tWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(mmUVD_CGC_CTRL);\n\t\tdata &= ~UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\n\t\tif (orig != data)\n\t\t\tWREG32(mmUVD_CGC_CTRL, data);\n\t}\n}\n\nstatic void uvd_v4_2_set_dcm(struct amdgpu_device *adev,\n\t\t\t     bool sw_mode)\n{\n\tu32 tmp, tmp2;\n\n\tWREG32_FIELD(UVD_CGC_GATE, REGS, 0);\n\n\ttmp = RREG32(mmUVD_CGC_CTRL);\n\ttmp &= ~(UVD_CGC_CTRL__CLK_OFF_DELAY_MASK | UVD_CGC_CTRL__CLK_GATE_DLY_TIMER_MASK);\n\ttmp |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK |\n\t\t(1 << UVD_CGC_CTRL__CLK_GATE_DLY_TIMER__SHIFT) |\n\t\t(4 << UVD_CGC_CTRL__CLK_OFF_DELAY__SHIFT);\n\n\tif (sw_mode) {\n\t\ttmp &= ~0x7ffff800;\n\t\ttmp2 = UVD_CGC_CTRL2__DYN_OCLK_RAMP_EN_MASK |\n\t\t\tUVD_CGC_CTRL2__DYN_RCLK_RAMP_EN_MASK |\n\t\t\t(7 << UVD_CGC_CTRL2__GATER_DIV_ID__SHIFT);\n\t} else {\n\t\ttmp |= 0x7ffff800;\n\t\ttmp2 = 0;\n\t}\n\n\tWREG32(mmUVD_CGC_CTRL, tmp);\n\tWREG32_UVD_CTX(ixUVD_CGC_CTRL2, tmp2);\n}\n\nstatic bool uvd_v4_2_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);\n}\n\nstatic int uvd_v4_2_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))\n\t\t\treturn 0;\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int uvd_v4_2_soft_reset(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tuvd_v4_2_stop(adev);\n\n\tWREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,\n\t\t\t~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\n\tmdelay(5);\n\n\treturn uvd_v4_2_start(adev);\n}\n\nstatic int uvd_v4_2_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\tunsigned type,\n\t\t\t\t\tenum amdgpu_interrupt_state state)\n{\n\t\n\treturn 0;\n}\n\nstatic int uvd_v4_2_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tDRM_DEBUG(\"IH: UVD TRAP\\n\");\n\tamdgpu_fence_process(&adev->uvd.inst->ring);\n\treturn 0;\n}\n\nstatic int uvd_v4_2_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int uvd_v4_2_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\t \n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (state == AMD_PG_STATE_GATE) {\n\t\tuvd_v4_2_stop(adev);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD && !adev->pm.dpm_enabled) {\n\t\t\tif (!(RREG32_SMC(ixCURRENT_PG_STATUS) &\n\t\t\t\tCURRENT_PG_STATUS__UVD_PG_STATUS_MASK)) {\n\t\t\t\tWREG32(mmUVD_PGFSM_CONFIG, (UVD_PGFSM_CONFIG__UVD_PGFSM_FSM_ADDR_MASK   |\n\t\t\t\t\t\t\tUVD_PGFSM_CONFIG__UVD_PGFSM_POWER_DOWN_MASK |\n\t\t\t\t\t\t\tUVD_PGFSM_CONFIG__UVD_PGFSM_P1_SELECT_MASK));\n\t\t\t\tmdelay(20);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD && !adev->pm.dpm_enabled) {\n\t\t\tif (RREG32_SMC(ixCURRENT_PG_STATUS) &\n\t\t\t\tCURRENT_PG_STATUS__UVD_PG_STATUS_MASK) {\n\t\t\t\tWREG32(mmUVD_PGFSM_CONFIG, (UVD_PGFSM_CONFIG__UVD_PGFSM_FSM_ADDR_MASK   |\n\t\t\t\t\t\tUVD_PGFSM_CONFIG__UVD_PGFSM_POWER_UP_MASK |\n\t\t\t\t\t\tUVD_PGFSM_CONFIG__UVD_PGFSM_P1_SELECT_MASK));\n\t\t\t\tmdelay(30);\n\t\t\t}\n\t\t}\n\t\treturn uvd_v4_2_start(adev);\n\t}\n}\n\nstatic const struct amd_ip_funcs uvd_v4_2_ip_funcs = {\n\t.name = \"uvd_v4_2\",\n\t.early_init = uvd_v4_2_early_init,\n\t.late_init = NULL,\n\t.sw_init = uvd_v4_2_sw_init,\n\t.sw_fini = uvd_v4_2_sw_fini,\n\t.hw_init = uvd_v4_2_hw_init,\n\t.hw_fini = uvd_v4_2_hw_fini,\n\t.suspend = uvd_v4_2_suspend,\n\t.resume = uvd_v4_2_resume,\n\t.is_idle = uvd_v4_2_is_idle,\n\t.wait_for_idle = uvd_v4_2_wait_for_idle,\n\t.soft_reset = uvd_v4_2_soft_reset,\n\t.set_clockgating_state = uvd_v4_2_set_clockgating_state,\n\t.set_powergating_state = uvd_v4_2_set_powergating_state,\n};\n\nstatic const struct amdgpu_ring_funcs uvd_v4_2_ring_funcs = {\n\t.type = AMDGPU_RING_TYPE_UVD,\n\t.align_mask = 0xf,\n\t.support_64bit_ptrs = false,\n\t.no_user_fence = true,\n\t.get_rptr = uvd_v4_2_ring_get_rptr,\n\t.get_wptr = uvd_v4_2_ring_get_wptr,\n\t.set_wptr = uvd_v4_2_ring_set_wptr,\n\t.parse_cs = amdgpu_uvd_ring_parse_cs,\n\t.emit_frame_size =\n\t\t14,  \n\t.emit_ib_size = 4,  \n\t.emit_ib = uvd_v4_2_ring_emit_ib,\n\t.emit_fence = uvd_v4_2_ring_emit_fence,\n\t.test_ring = uvd_v4_2_ring_test_ring,\n\t.test_ib = amdgpu_uvd_ring_test_ib,\n\t.insert_nop = uvd_v4_2_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.begin_use = amdgpu_uvd_ring_begin_use,\n\t.end_use = amdgpu_uvd_ring_end_use,\n};\n\nstatic void uvd_v4_2_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tadev->uvd.inst->ring.funcs = &uvd_v4_2_ring_funcs;\n}\n\nstatic const struct amdgpu_irq_src_funcs uvd_v4_2_irq_funcs = {\n\t.set = uvd_v4_2_set_interrupt_state,\n\t.process = uvd_v4_2_process_interrupt,\n};\n\nstatic void uvd_v4_2_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->uvd.inst->irq.num_types = 1;\n\tadev->uvd.inst->irq.funcs = &uvd_v4_2_irq_funcs;\n}\n\nconst struct amdgpu_ip_block_version uvd_v4_2_ip_block =\n{\n\t\t.type = AMD_IP_BLOCK_TYPE_UVD,\n\t\t.major = 4,\n\t\t.minor = 2,\n\t\t.rev = 0,\n\t\t.funcs = &uvd_v4_2_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}