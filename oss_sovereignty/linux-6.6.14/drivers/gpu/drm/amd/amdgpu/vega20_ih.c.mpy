{
  "module_name": "vega20_ih.c",
  "hash_id": "7d8b29ebd89649b171101ef35be5b5396a0a00503eceed65d5d7b448b5353ee0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/vega20_ih.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_ih.h\"\n#include \"soc15.h\"\n\n#include \"oss/osssys_4_2_0_offset.h\"\n#include \"oss/osssys_4_2_0_sh_mask.h\"\n\n#include \"soc15_common.h\"\n#include \"vega20_ih.h\"\n\n#define MAX_REARM_RETRY 10\n\n#define mmIH_CHICKEN_ALDEBARAN\t\t\t0x18d\n#define mmIH_CHICKEN_ALDEBARAN_BASE_IDX\t\t0\n\n#define mmIH_RETRY_INT_CAM_CNTL_ALDEBARAN\t\t0x00ea\n#define mmIH_RETRY_INT_CAM_CNTL_ALDEBARAN_BASE_IDX\t0\n#define IH_RETRY_INT_CAM_CNTL_ALDEBARAN__ENABLE__SHIFT\t0x10\n#define IH_RETRY_INT_CAM_CNTL_ALDEBARAN__ENABLE_MASK\t0x00010000L\n\nstatic void vega20_ih_set_interrupt_funcs(struct amdgpu_device *adev);\n\n \nstatic void vega20_ih_init_register_offset(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (adev->irq.ih.ring_size) {\n\t\tih_regs = &adev->irq.ih.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR);\n\t\tih_regs->ih_rb_wptr_addr_lo = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_LO);\n\t\tih_regs->ih_rb_wptr_addr_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_HI);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL;\n\t}\n\n\tif (adev->irq.ih1.ring_size) {\n\t\tih_regs = &adev->irq.ih1.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_RING1);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI_RING1);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL_RING1);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_RING1);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR_RING1);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR_RING1);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL_RING1;\n\t}\n\n\tif (adev->irq.ih2.ring_size) {\n\t\tih_regs = &adev->irq.ih2.ih_regs;\n\t\tih_regs->ih_rb_base = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_RING2);\n\t\tih_regs->ih_rb_base_hi = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI_RING2);\n\t\tih_regs->ih_rb_cntl = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL_RING2);\n\t\tih_regs->ih_rb_wptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_RING2);\n\t\tih_regs->ih_rb_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR_RING2);\n\t\tih_regs->ih_doorbell_rptr = SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR_RING2);\n\t\tih_regs->psp_reg_id = PSP_REG_IH_RB_CNTL_RING2;\n\t}\n}\n\n \nstatic int vega20_ih_toggle_ring_interrupts(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_ih_ring *ih,\n\t\t\t\t\t    bool enable)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\tuint32_t tmp;\n\n\tih_regs = &ih->ih_regs;\n\n\ttmp = RREG32(ih_regs->ih_rb_cntl);\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_ENABLE, (enable ? 1 : 0));\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_GPU_TS_ENABLE, 1);\n\n\t \n\tif (ih == &adev->irq.ih)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, ENABLE_INTR, (enable ? 1 : 0));\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tif (psp_reg_program(&adev->psp, ih_regs->psp_reg_id, tmp)) {\n\t\t\tdev_err(adev->dev, \"PSP program IH_RB_CNTL failed!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tWREG32(ih_regs->ih_rb_cntl, tmp);\n\t}\n\n\tif (enable) {\n\t\tih->enabled = true;\n\t} else {\n\t\t \n\t\tWREG32(ih_regs->ih_rb_rptr, 0);\n\t\tWREG32(ih_regs->ih_rb_wptr, 0);\n\t\tih->enabled = false;\n\t\tih->rptr = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vega20_ih_toggle_interrupts(struct amdgpu_device *adev, bool enable)\n{\n\tstruct amdgpu_ih_ring *ih[] = {&adev->irq.ih, &adev->irq.ih1, &adev->irq.ih2};\n\tint i;\n\tint r;\n\n\tfor (i = 0; i < ARRAY_SIZE(ih); i++) {\n\t\tif (ih[i]->ring_size) {\n\t\t\tr = vega20_ih_toggle_ring_interrupts(adev, ih[i], enable);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic uint32_t vega20_ih_rb_cntl(struct amdgpu_ih_ring *ih, uint32_t ih_rb_cntl)\n{\n\tint rb_bufsz = order_base_2(ih->ring_size / 4);\n\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   MC_SPACE, ih->use_bus_addr ? 1 : 4);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_OVERFLOW_CLEAR, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_OVERFLOW_ENABLE, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_SIZE, rb_bufsz);\n\t \n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL,\n\t\t\t\t   WPTR_WRITEBACK_ENABLE, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_SNOOP, 1);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_RO, 0);\n\tih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_VMID, 0);\n\n\treturn ih_rb_cntl;\n}\n\nstatic uint32_t vega20_ih_doorbell_rptr(struct amdgpu_ih_ring *ih)\n{\n\tu32 ih_doorbell_rtpr = 0;\n\n\tif (ih->use_doorbell) {\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR, OFFSET,\n\t\t\t\t\t\t ih->doorbell_index);\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR,\n\t\t\t\t\t\t ENABLE, 1);\n\t} else {\n\t\tih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr,\n\t\t\t\t\t\t IH_DOORBELL_RPTR,\n\t\t\t\t\t\t ENABLE, 0);\n\t}\n\treturn ih_doorbell_rtpr;\n}\n\n \nstatic int vega20_ih_enable_ring(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_ih_ring *ih)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\tuint32_t tmp;\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\tWREG32(ih_regs->ih_rb_base, ih->gpu_addr >> 8);\n\tWREG32(ih_regs->ih_rb_base_hi, (ih->gpu_addr >> 40) & 0xff);\n\n\ttmp = RREG32(ih_regs->ih_rb_cntl);\n\ttmp = vega20_ih_rb_cntl(ih, tmp);\n\tif (ih == &adev->irq.ih)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RPTR_REARM, !!adev->irq.msi_enabled);\n\tif (ih == &adev->irq.ih1)\n\t\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, RB_FULL_DRAIN_ENABLE, 1);\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tif (psp_reg_program(&adev->psp, ih_regs->psp_reg_id, tmp)) {\n\t\t\tdev_err(adev->dev, \"PSP program IH_RB_CNTL failed!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tWREG32(ih_regs->ih_rb_cntl, tmp);\n\t}\n\n\tif (ih == &adev->irq.ih) {\n\t\t \n\t\tWREG32(ih_regs->ih_rb_wptr_addr_lo, lower_32_bits(ih->wptr_addr));\n\t\tWREG32(ih_regs->ih_rb_wptr_addr_hi, upper_32_bits(ih->wptr_addr) & 0xFFFF);\n\t}\n\n\t \n\tWREG32(ih_regs->ih_rb_wptr, 0);\n\tWREG32(ih_regs->ih_rb_rptr, 0);\n\n\tWREG32(ih_regs->ih_doorbell_rptr, vega20_ih_doorbell_rptr(ih));\n\n\treturn 0;\n}\n\nstatic uint32_t vega20_setup_retry_doorbell(u32 doorbell_index)\n{\n\tu32 val = 0;\n\n\tval = REG_SET_FIELD(val, IH_DOORBELL_RPTR, OFFSET, doorbell_index);\n\tval = REG_SET_FIELD(val, IH_DOORBELL_RPTR, ENABLE, 1);\n\n\treturn val;\n}\n\n \nstatic int vega20_ih_irq_init(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ih_ring *ih[] = {&adev->irq.ih, &adev->irq.ih1, &adev->irq.ih2};\n\tu32 ih_chicken;\n\tint ret;\n\tint i;\n\n\t \n\tret = vega20_ih_toggle_interrupts(adev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tadev->nbio.funcs->ih_control(adev);\n\n\tif ((adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 2, 1)) &&\n\t    adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {\n\t\tih_chicken = RREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN);\n\t\tif (adev->irq.ih.use_bus_addr) {\n\t\t\tih_chicken = REG_SET_FIELD(ih_chicken, IH_CHICKEN,\n\t\t\t\t\t\t   MC_SPACE_GPA_ENABLE, 1);\n\t\t}\n\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN, ih_chicken);\n\t}\n\n\t \n\tif ((adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 4, 0)) ||\n\t    (adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 4, 2))) {\n\t\tih_chicken = RREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN_ALDEBARAN);\n\t\tif (adev->irq.ih.use_bus_addr) {\n\t\t\tih_chicken = REG_SET_FIELD(ih_chicken, IH_CHICKEN,\n\t\t\t\t\t\t   MC_SPACE_GPA_ENABLE, 1);\n\t\t}\n\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CHICKEN_ALDEBARAN, ih_chicken);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ih); i++) {\n\t\tif (ih[i]->ring_size) {\n\t\t\tret = vega20_ih_enable_ring(adev, ih[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\tadev->nbio.funcs->ih_doorbell_range(adev, adev->irq.ih.use_doorbell,\n\t\t\t\t\t\t    adev->irq.ih.doorbell_index);\n\n\tpci_set_master(adev->pdev);\n\n\t \n\tadev->irq.retry_cam_doorbell_index = (adev->doorbell_index.ih + 3) << 1;\n\tWREG32_SOC15(OSSSYS, 0, mmIH_DOORBELL_RETRY_CAM,\n\t\tvega20_setup_retry_doorbell(adev->irq.retry_cam_doorbell_index));\n\n\t \n\tif (adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 4, 0) ||\n\t    adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 4, 2))\n\t\tWREG32_FIELD15(OSSSYS, 0, IH_RETRY_INT_CAM_CNTL_ALDEBARAN,\n\t\t\t       ENABLE, 1);\n\telse\n\t\tWREG32_FIELD15(OSSSYS, 0, IH_RETRY_INT_CAM_CNTL, ENABLE, 1);\n\n\tadev->irq.retry_cam_enabled = true;\n\n\t \n\tret = vega20_ih_toggle_interrupts(adev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adev->irq.ih_soft.ring_size)\n\t\tadev->irq.ih_soft.enabled = true;\n\n\treturn 0;\n}\n\n \nstatic void vega20_ih_irq_disable(struct amdgpu_device *adev)\n{\n\tvega20_ih_toggle_interrupts(adev, false);\n\n\t \n\tmdelay(1);\n}\n\n \nstatic u32 vega20_ih_get_wptr(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_ih_ring *ih)\n{\n\tu32 wptr, tmp;\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (ih == &adev->irq.ih || ih == &adev->irq.ih_soft) {\n\t\t \n\t\twptr = le32_to_cpu(*ih->wptr_cpu);\n\n\t\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\t\tgoto out;\n\t}\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\twptr = RREG32_NO_KIQ(ih_regs->ih_rb_wptr);\n\tif (!REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW))\n\t\tgoto out;\n\n\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);\n\n\t \n\ttmp = (wptr + 32) & ih->ptr_mask;\n\tdev_warn(adev->dev, \"IH ring buffer overflow \"\n\t\t \"(0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t wptr, ih->rptr, tmp);\n\tih->rptr = tmp;\n\n\ttmp = RREG32_NO_KIQ(ih_regs->ih_rb_cntl);\n\ttmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\n\tWREG32_NO_KIQ(ih_regs->ih_rb_cntl, tmp);\n\nout:\n\treturn (wptr & ih->ptr_mask);\n}\n\n \nstatic void vega20_ih_irq_rearm(struct amdgpu_device *adev,\n\t\t\t       struct amdgpu_ih_ring *ih)\n{\n\tuint32_t v = 0;\n\tuint32_t i = 0;\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tih_regs = &ih->ih_regs;\n\n\t \n\tfor (i = 0; i < MAX_REARM_RETRY; i++) {\n\t\tv = RREG32_NO_KIQ(ih_regs->ih_rb_rptr);\n\t\tif ((v < ih->ring_size) && (v != ih->rptr))\n\t\t\tWDOORBELL32(ih->doorbell_index, ih->rptr);\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void vega20_ih_set_rptr(struct amdgpu_device *adev,\n\t\t\t       struct amdgpu_ih_ring *ih)\n{\n\tstruct amdgpu_ih_regs *ih_regs;\n\n\tif (ih == &adev->irq.ih_soft)\n\t\treturn;\n\n\tif (ih->use_doorbell) {\n\t\t \n\t\t*ih->rptr_cpu = ih->rptr;\n\t\tWDOORBELL32(ih->doorbell_index, ih->rptr);\n\n\t\tif (amdgpu_sriov_vf(adev))\n\t\t\tvega20_ih_irq_rearm(adev, ih);\n\t} else {\n\t\tih_regs = &ih->ih_regs;\n\t\tWREG32(ih_regs->ih_rb_rptr, ih->rptr);\n\t}\n}\n\n \nstatic int vega20_ih_self_irq(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tswitch (entry->ring_id) {\n\tcase 1:\n\t\tschedule_work(&adev->irq.ih1_work);\n\t\tbreak;\n\tcase 2:\n\t\tschedule_work(&adev->irq.ih2_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs vega20_ih_self_irq_funcs = {\n\t.process = vega20_ih_self_irq,\n};\n\nstatic void vega20_ih_set_self_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->irq.self_irq.num_types = 0;\n\tadev->irq.self_irq.funcs = &vega20_ih_self_irq_funcs;\n}\n\nstatic int vega20_ih_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tvega20_ih_set_interrupt_funcs(adev);\n\tvega20_ih_set_self_irq_funcs(adev);\n\treturn 0;\n}\n\nstatic int vega20_ih_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool use_bus_addr = true;\n\tint r;\n\n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_IH, 0,\n\t\t\t      &adev->irq.self_irq);\n\tif (r)\n\t\treturn r;\n\n\tif ((adev->flags & AMD_IS_APU) &&\n\t    (adev->ip_versions[OSSSYS_HWIP][0] == IP_VERSION(4, 4, 2)))\n\t\tuse_bus_addr = false;\n\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih, IH_RING_SIZE, use_bus_addr);\n\tif (r)\n\t\treturn r;\n\n\tadev->irq.ih.use_doorbell = true;\n\tadev->irq.ih.doorbell_index = adev->doorbell_index.ih << 1;\n\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih1, PAGE_SIZE, use_bus_addr);\n\tif (r)\n\t\treturn r;\n\n\tadev->irq.ih1.use_doorbell = true;\n\tadev->irq.ih1.doorbell_index = (adev->doorbell_index.ih + 1) << 1;\n\n\tif (adev->ip_versions[OSSSYS_HWIP][0] != IP_VERSION(4, 4, 2)) {\n\t\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih2, PAGE_SIZE, true);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tadev->irq.ih2.use_doorbell = true;\n\t\tadev->irq.ih2.doorbell_index = (adev->doorbell_index.ih + 2) << 1;\n\t}\n\n\t \n\tvega20_ih_init_register_offset(adev);\n\n\tr = amdgpu_ih_ring_init(adev, &adev->irq.ih_soft, IH_SW_RING_SIZE, use_bus_addr);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_init(adev);\n\n\treturn r;\n}\n\nstatic int vega20_ih_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_irq_fini_sw(adev);\n\n\treturn 0;\n}\n\nstatic int vega20_ih_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tr = vega20_ih_irq_init(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int vega20_ih_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tvega20_ih_irq_disable(adev);\n\n\treturn 0;\n}\n\nstatic int vega20_ih_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn vega20_ih_hw_fini(adev);\n}\n\nstatic int vega20_ih_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\treturn vega20_ih_hw_init(adev);\n}\n\nstatic bool vega20_ih_is_idle(void *handle)\n{\n\t \n\treturn true;\n}\n\nstatic int vega20_ih_wait_for_idle(void *handle)\n{\n\t \n\treturn -ETIMEDOUT;\n}\n\nstatic int vega20_ih_soft_reset(void *handle)\n{\n\t \n\n\treturn 0;\n}\n\nstatic void vega20_ih_update_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tuint32_t data, def, field_val;\n\n\tif (adev->cg_flags & AMD_CG_SUPPORT_IH_CG) {\n\t\tdef = data = RREG32_SOC15(OSSSYS, 0, mmIH_CLK_CTRL);\n\t\tfield_val = enable ? 0 : 1;\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     IH_RETRY_INT_CAM_MEM_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     IH_BUFFER_MEM_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     DBUS_MUX_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     OSSSYS_SHARE_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     LIMIT_SMN_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     DYN_CLK_SOFT_OVERRIDE, field_val);\n\t\tdata = REG_SET_FIELD(data, IH_CLK_CTRL,\n\t\t\t\t     REG_CLK_SOFT_OVERRIDE, field_val);\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(OSSSYS, 0, mmIH_CLK_CTRL, data);\n\t}\n}\n\nstatic int vega20_ih_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tvega20_ih_update_clockgating_state(adev,\n\t\t\t\tstate == AMD_CG_STATE_GATE);\n\treturn 0;\n\n}\n\nstatic int vega20_ih_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\nconst struct amd_ip_funcs vega20_ih_ip_funcs = {\n\t.name = \"vega20_ih\",\n\t.early_init = vega20_ih_early_init,\n\t.late_init = NULL,\n\t.sw_init = vega20_ih_sw_init,\n\t.sw_fini = vega20_ih_sw_fini,\n\t.hw_init = vega20_ih_hw_init,\n\t.hw_fini = vega20_ih_hw_fini,\n\t.suspend = vega20_ih_suspend,\n\t.resume = vega20_ih_resume,\n\t.is_idle = vega20_ih_is_idle,\n\t.wait_for_idle = vega20_ih_wait_for_idle,\n\t.soft_reset = vega20_ih_soft_reset,\n\t.set_clockgating_state = vega20_ih_set_clockgating_state,\n\t.set_powergating_state = vega20_ih_set_powergating_state,\n};\n\nstatic const struct amdgpu_ih_funcs vega20_ih_funcs = {\n\t.get_wptr = vega20_ih_get_wptr,\n\t.decode_iv = amdgpu_ih_decode_iv_helper,\n\t.decode_iv_ts = amdgpu_ih_decode_iv_ts_helper,\n\t.set_rptr = vega20_ih_set_rptr\n};\n\nstatic void vega20_ih_set_interrupt_funcs(struct amdgpu_device *adev)\n{\n\tadev->irq.ih_funcs = &vega20_ih_funcs;\n}\n\nconst struct amdgpu_ip_block_version vega20_ih_ip_block = {\n\t.type = AMD_IP_BLOCK_TYPE_IH,\n\t.major = 4,\n\t.minor = 2,\n\t.rev = 0,\n\t.funcs = &vega20_ih_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}