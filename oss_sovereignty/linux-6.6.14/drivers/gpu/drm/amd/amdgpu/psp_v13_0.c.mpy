{
  "module_name": "psp_v13_0.c",
  "hash_id": "9508e468c436f1a139d3764be7d18b9f63efdd7c27569dd2d566e73970a1f641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/psp_v13_0.c",
  "human_readable_source": " \n#include <drm/drm_drv.h>\n#include <linux/vmalloc.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ucode.h\"\n#include \"soc15_common.h\"\n#include \"psp_v13_0.h\"\n\n#include \"mp/mp_13_0_2_offset.h\"\n#include \"mp/mp_13_0_2_sh_mask.h\"\n\nMODULE_FIRMWARE(\"amdgpu/aldebaran_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_cap.bin\");\nMODULE_FIRMWARE(\"amdgpu/yellow_carp_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/yellow_carp_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_5_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_5_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_8_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_8_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_0_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_0_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_7_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_7_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_10_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_10_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_11_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_11_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_6_sos.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_6_ta.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_14_0_0_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_14_0_0_ta.bin\");\n\n \n#define USBC_PD_POLLING_LIMIT_S 240\n\n \n#define GFX_CMD_USB_PD_USE_LFB 0x480\n\n \n#define PSP_VMBX_POLLING_LIMIT 3000\n\n \n#define MBOX_READY_MASK 0x80000000\n#define MBOX_STATUS_MASK 0x0000FFFF\n#define MBOX_COMMAND_MASK 0x00FF0000\n#define MBOX_READY_FLAG 0x80000000\n#define C2PMSG_CMD_SPI_UPDATE_ROM_IMAGE_ADDR_LO 0x2\n#define C2PMSG_CMD_SPI_UPDATE_ROM_IMAGE_ADDR_HI 0x3\n#define C2PMSG_CMD_SPI_UPDATE_FLASH_IMAGE 0x4\n\n \n#define MEM_TRAIN_SEND_MSG_TIMEOUT_US\t3000000\n\nstatic int psp_v13_0_init_microcode(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar ucode_prefix[30];\n\tint err = 0;\n\n\tamdgpu_ucode_ip_version_decode(adev, MP0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 2):\n\t\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tif (!amdgpu_sriov_vf(adev)) {\n\t\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 3):\n\tcase IP_VERSION(13, 0, 5):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(13, 0, 11):\n\tcase IP_VERSION(14, 0, 0):\n\t\terr = psp_init_toc_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 6):\n\tcase IP_VERSION(13, 0, 7):\n\tcase IP_VERSION(13, 0, 10):\n\t\terr = psp_init_sos_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\nstatic bool psp_v13_0_is_sos_alive(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t sol_reg;\n\n\tsol_reg = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_81);\n\n\treturn sol_reg != 0x0;\n}\n\nstatic int psp_v13_0_wait_for_vmbx_ready(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint retry_loop, ret;\n\n\tfor (retry_loop = 0; retry_loop < PSP_VMBX_POLLING_LIMIT; retry_loop++) {\n\t\t \n\t\tret = psp_wait_for(\n\t\t\tpsp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_33),\n\t\t\t0x80000000, 0xffffffff, false);\n\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_warn(adev->dev, \"Bootloader wait timed out\");\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_wait_for_bootloader(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint retry_loop, retry_cnt, ret;\n\n\tretry_cnt =\n\t\t(adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 6)) ?\n\t\t\tPSP_VMBX_POLLING_LIMIT :\n\t\t\t10;\n\t \n\tfor (retry_loop = 0; retry_loop < retry_cnt; retry_loop++) {\n\t\tret = psp_wait_for(\n\t\t\tpsp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_35),\n\t\t\t0x80000000, 0xffffffff, false);\n\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_wait_for_bootloader_steady_state(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 6)) {\n\t\tpsp_v13_0_wait_for_vmbx_ready(psp);\n\n\t\treturn psp_v13_0_wait_for_bootloader(psp);\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_v13_0_bootloader_load_component(struct psp_context  \t*psp,\n\t\t\t\t\t       struct psp_bin_desc \t*bin_desc,\n\t\t\t\t\t       enum psp_bootloader_cmd  bl_cmd)\n{\n\tint ret;\n\tuint32_t psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v13_0_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v13_0_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\n\t \n\tmemcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = bl_cmd;\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\tret = psp_v13_0_wait_for_bootloader(psp);\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_bootloader_load_kdb(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->kdb, PSP_BL__LOAD_KEY_DATABASE);\n}\n\nstatic int psp_v13_0_bootloader_load_spl(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->kdb, PSP_BL__LOAD_TOS_SPL_TABLE);\n}\n\nstatic int psp_v13_0_bootloader_load_sysdrv(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->sys, PSP_BL__LOAD_SYSDRV);\n}\n\nstatic int psp_v13_0_bootloader_load_soc_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->soc_drv, PSP_BL__LOAD_SOCDRV);\n}\n\nstatic int psp_v13_0_bootloader_load_intf_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->intf_drv, PSP_BL__LOAD_INTFDRV);\n}\n\nstatic int psp_v13_0_bootloader_load_dbg_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->dbg_drv, PSP_BL__LOAD_DBGDRV);\n}\n\nstatic int psp_v13_0_bootloader_load_ras_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_bootloader_load_component(psp, &psp->ras_drv, PSP_BL__LOAD_RASDRV);\n}\n\n\nstatic int psp_v13_0_bootloader_load_sos(struct psp_context *psp)\n{\n\tint ret;\n\tunsigned int psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v13_0_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v13_0_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\n\t \n\tmemcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = PSP_BL__LOAD_SOSDRV;\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\t \n\tmdelay(20);\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_81),\n\t\t\t   RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_81),\n\t\t\t   0, true);\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_ring_stop(struct psp_context *psp,\n\t\t\t       enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_DESTROY_GPCOM_RING);\n\t\t \n\t\tmdelay(20);\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t} else {\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_64,\n\t\t\t     GFX_CTRL_CMD_ID_DESTROY_RINGS);\n\t\t \n\t\tmdelay(20);\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_ring_create(struct psp_context *psp,\n\t\t\t\t enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tunsigned int psp_ring_reg = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tret = psp_v13_0_ring_stop(psp, ring_type);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"psp_v13_0_ring_stop_sriov failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_103, psp_ring_reg);\n\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_INIT_GPCOM_RING);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\n\t} else {\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to wait for trust OS ready for ring creation\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_69, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_70, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring->ring_size;\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_71, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring_type;\n\t\tpsp_ring_reg = psp_ring_reg << 16;\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_64, psp_ring_reg);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_ring_destroy(struct psp_context *psp,\n\t\t\t\t  enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tret = psp_v13_0_ring_stop(psp, ring_type);\n\tif (ret)\n\t\tDRM_ERROR(\"Fail to stop psp ring\\n\");\n\n\tamdgpu_bo_free_kernel(&adev->firmware.rbuf,\n\t\t\t      &ring->ring_mem_mc_addr,\n\t\t\t      (void **)&ring->ring_mem);\n\n\treturn ret;\n}\n\nstatic uint32_t psp_v13_0_ring_get_wptr(struct psp_context *psp)\n{\n\tuint32_t data;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tdata = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102);\n\telse\n\t\tdata = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67);\n\n\treturn data;\n}\n\nstatic void psp_v13_0_ring_set_wptr(struct psp_context *psp, uint32_t value)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102, value);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_CONSUME_CMD);\n\t} else\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67, value);\n}\n\nstatic int psp_v13_0_memory_training_send_msg(struct psp_context *psp, int msg)\n{\n\tint ret;\n\tint i;\n\tuint32_t data_32;\n\tint max_wait;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tdata_32 = (psp->mem_train_ctx.c2p_train_data_offset >> 20);\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36, data_32);\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35, msg);\n\n\tmax_wait = MEM_TRAIN_SEND_MSG_TIMEOUT_US / adev->usec_timeout;\n\tfor (i = 0; i < max_wait; i++) {\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_35),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\tif (i < max_wait)\n\t\tret = 0;\n\telse\n\t\tret = -ETIME;\n\n\tdev_dbg(adev->dev, \"training %s %s, cost %d @ %d ms\\n\",\n\t\t  (msg == PSP_BL__DRAM_SHORT_TRAIN) ? \"short\" : \"long\",\n\t\t  (ret == 0) ? \"succeed\" : \"failed\",\n\t\t  i, adev->usec_timeout/1000);\n\treturn ret;\n}\n\n\nstatic int psp_v13_0_memory_training(struct psp_context *psp, uint32_t ops)\n{\n\tstruct psp_memory_training_context *ctx = &psp->mem_train_ctx;\n\tuint32_t *pcache = (uint32_t *)ctx->sys_cache;\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t p2c_header[4];\n\tuint32_t sz;\n\tvoid *buf;\n\tint ret, idx;\n\n\tif (ctx->init == PSP_MEM_TRAIN_NOT_SUPPORT) {\n\t\tdev_dbg(adev->dev, \"Memory training is not supported.\\n\");\n\t\treturn 0;\n\t} else if (ctx->init != PSP_MEM_TRAIN_INIT_SUCCESS) {\n\t\tdev_err(adev->dev, \"Memory training initialization failure.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (psp_v13_0_is_sos_alive(psp)) {\n\t\tdev_dbg(adev->dev, \"SOS is alive, skip memory training.\\n\");\n\t\treturn 0;\n\t}\n\n\tamdgpu_device_vram_access(adev, ctx->p2c_train_data_offset, p2c_header, sizeof(p2c_header), false);\n\tdev_dbg(adev->dev, \"sys_cache[%08x,%08x,%08x,%08x] p2c_header[%08x,%08x,%08x,%08x]\\n\",\n\t\t  pcache[0], pcache[1], pcache[2], pcache[3],\n\t\t  p2c_header[0], p2c_header[1], p2c_header[2], p2c_header[3]);\n\n\tif (ops & PSP_MEM_TRAIN_SEND_SHORT_MSG) {\n\t\tdev_dbg(adev->dev, \"Short training depends on restore.\\n\");\n\t\tops |= PSP_MEM_TRAIN_RESTORE;\n\t}\n\n\tif ((ops & PSP_MEM_TRAIN_RESTORE) &&\n\t    pcache[0] != MEM_TRAIN_SYSTEM_SIGNATURE) {\n\t\tdev_dbg(adev->dev, \"sys_cache[0] is invalid, restore depends on save.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tif (p2c_header[0] == MEM_TRAIN_SYSTEM_SIGNATURE &&\n\t    !(pcache[0] == MEM_TRAIN_SYSTEM_SIGNATURE &&\n\t      pcache[3] == p2c_header[3])) {\n\t\tdev_dbg(adev->dev, \"sys_cache is invalid or out-of-date, need save training data to sys_cache.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tif ((ops & PSP_MEM_TRAIN_SAVE) &&\n\t    p2c_header[0] != MEM_TRAIN_SYSTEM_SIGNATURE) {\n\t\tdev_dbg(adev->dev, \"p2c_header[0] is invalid, save depends on long training.\\n\");\n\t\tops |= PSP_MEM_TRAIN_SEND_LONG_MSG;\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SEND_LONG_MSG) {\n\t\tops &= ~PSP_MEM_TRAIN_SEND_SHORT_MSG;\n\t\tops |= PSP_MEM_TRAIN_SAVE;\n\t}\n\n\tdev_dbg(adev->dev, \"Memory training ops:%x.\\n\", ops);\n\n\tif (ops & PSP_MEM_TRAIN_SEND_LONG_MSG) {\n\t\t \n\t\tsz = GDDR6_MEM_TRAINING_ENCROACHED_SIZE;\n\n\t\tif (adev->gmc.visible_vram_size < sz || !adev->mman.aper_base_kaddr) {\n\t\t\tdev_err(adev->dev, \"visible_vram_size %llx or aper_base_kaddr %p is not initialized.\\n\",\n\t\t\t\t  adev->gmc.visible_vram_size,\n\t\t\t\t  adev->mman.aper_base_kaddr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf = vmalloc(sz);\n\t\tif (!buf) {\n\t\t\tdev_err(adev->dev, \"failed to allocate system memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (drm_dev_enter(adev_to_drm(adev), &idx)) {\n\t\t\tmemcpy_fromio(buf, adev->mman.aper_base_kaddr, sz);\n\t\t\tret = psp_v13_0_memory_training_send_msg(psp, PSP_BL__DRAM_LONG_TRAIN);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"Send long training msg failed.\\n\");\n\t\t\t\tvfree(buf);\n\t\t\t\tdrm_dev_exit(idx);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tmemcpy_toio(adev->mman.aper_base_kaddr, buf, sz);\n\t\t\tadev->hdp.funcs->flush_hdp(adev, NULL);\n\t\t\tvfree(buf);\n\t\t\tdrm_dev_exit(idx);\n\t\t} else {\n\t\t\tvfree(buf);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SAVE) {\n\t\tamdgpu_device_vram_access(psp->adev, ctx->p2c_train_data_offset, ctx->sys_cache, ctx->train_data_size, false);\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_RESTORE) {\n\t\tamdgpu_device_vram_access(psp->adev, ctx->c2p_train_data_offset, ctx->sys_cache, ctx->train_data_size, true);\n\t}\n\n\tif (ops & PSP_MEM_TRAIN_SEND_SHORT_MSG) {\n\t\tret = psp_v13_0_memory_training_send_msg(psp, (amdgpu_force_long_training > 0) ?\n\t\t\t\t\t\t\t PSP_BL__DRAM_LONG_TRAIN : PSP_BL__DRAM_SHORT_TRAIN);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"send training msg failed.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tctx->training_cnt++;\n\treturn 0;\n}\n\nstatic int psp_v13_0_load_usbc_pd_fw(struct psp_context *psp, uint64_t fw_pri_mc_addr)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t reg_status;\n\tint ret, i = 0;\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36, (fw_pri_mc_addr >> 20));\n\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_35),\n\t\t\t     0x80000000, 0x80000000, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35, (GFX_CMD_USB_PD_USE_LFB << 16));\n\n\t \n\tdo {\n\t\tmsleep(1000);\n\t\treg_status = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35);\n\n\t\tif (reg_status & 0x80000000)\n\t\t\tgoto done;\n\n\t} while (++i < USBC_PD_POLLING_LIMIT_S);\n\n\treturn -ETIME;\ndone:\n\n\tif ((reg_status & 0xFFFF) != 0) {\n\t\tDRM_ERROR(\"Address load failed - MP0_SMN_C2PMSG_35.Bits [15:0] = %04x\\n\",\n\t\t\t\treg_status & 0xFFFF);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_v13_0_read_usbc_pd_fw(struct psp_context *psp, uint32_t *fw_ver)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35, C2PMSG_CMD_GFX_USB_PD_FW_VER);\n\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_35),\n\t\t\t\t     0x80000000, 0x80000000, false);\n\tif (!ret)\n\t\t*fw_ver = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36);\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_exec_spi_cmd(struct psp_context *psp, int cmd)\n{\n\tuint32_t reg_status = 0, reg_val = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\n\t \n\treg_val |= (cmd << 16);\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_115,  reg_val);\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_73, 1);\n\n\tif (cmd == C2PMSG_CMD_SPI_UPDATE_FLASH_IMAGE)\n\t\tret = psp_wait_for_spirom_update(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_115),\n\t\t\t\t\t\t MBOX_READY_FLAG, MBOX_READY_MASK, PSP_SPIROM_UPDATE_TIMEOUT);\n\telse\n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_115),\n\t\t\t\t   MBOX_READY_FLAG, MBOX_READY_MASK, false);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"SPI cmd %x timed out, ret = %d\", cmd, ret);\n\t\treturn ret;\n\t}\n\n\treg_status = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_115);\n\tif ((reg_status & 0xFFFF) != 0) {\n\t\tdev_err(adev->dev, \"SPI cmd %x failed, fail status = %04x\\n\",\n\t\t\t\tcmd, reg_status & 0xFFFF);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_v13_0_update_spirom(struct psp_context *psp,\n\t\t\t\t   uint64_t fw_pri_mc_addr)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tint ret;\n\n\t \n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_115),\n\t\t\t   MBOX_READY_FLAG, MBOX_READY_MASK, false);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"PSP Not ready to start processing, ret = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_116, lower_32_bits(fw_pri_mc_addr));\n\n\tret = psp_v13_0_exec_spi_cmd(psp, C2PMSG_CMD_SPI_UPDATE_ROM_IMAGE_ADDR_LO);\n\tif (ret)\n\t\treturn ret;\n\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_116, upper_32_bits(fw_pri_mc_addr));\n\n\tret = psp_v13_0_exec_spi_cmd(psp, C2PMSG_CMD_SPI_UPDATE_ROM_IMAGE_ADDR_HI);\n\tif (ret)\n\t\treturn ret;\n\n\tpsp->vbflash_done = true;\n\n\tret = psp_v13_0_exec_spi_cmd(psp, C2PMSG_CMD_SPI_UPDATE_FLASH_IMAGE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int psp_v13_0_vbflash_status(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\treturn RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_115);\n}\n\nstatic int psp_v13_0_fatal_error_recovery_quirk(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (adev->ip_versions[MP0_HWIP][0] == IP_VERSION(13, 0, 10)) {\n\t\tuint32_t  reg_data;\n\t\t \n\t\treg_data = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67, reg_data + 0x10);\n\n\t\t \n\t\tmsleep(1000);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct psp_funcs psp_v13_0_funcs = {\n\t.init_microcode = psp_v13_0_init_microcode,\n\t.wait_for_bootloader = psp_v13_0_wait_for_bootloader_steady_state,\n\t.bootloader_load_kdb = psp_v13_0_bootloader_load_kdb,\n\t.bootloader_load_spl = psp_v13_0_bootloader_load_spl,\n\t.bootloader_load_sysdrv = psp_v13_0_bootloader_load_sysdrv,\n\t.bootloader_load_soc_drv = psp_v13_0_bootloader_load_soc_drv,\n\t.bootloader_load_intf_drv = psp_v13_0_bootloader_load_intf_drv,\n\t.bootloader_load_dbg_drv = psp_v13_0_bootloader_load_dbg_drv,\n\t.bootloader_load_ras_drv = psp_v13_0_bootloader_load_ras_drv,\n\t.bootloader_load_sos = psp_v13_0_bootloader_load_sos,\n\t.ring_create = psp_v13_0_ring_create,\n\t.ring_stop = psp_v13_0_ring_stop,\n\t.ring_destroy = psp_v13_0_ring_destroy,\n\t.ring_get_wptr = psp_v13_0_ring_get_wptr,\n\t.ring_set_wptr = psp_v13_0_ring_set_wptr,\n\t.mem_training = psp_v13_0_memory_training,\n\t.load_usbc_pd_fw = psp_v13_0_load_usbc_pd_fw,\n\t.read_usbc_pd_fw = psp_v13_0_read_usbc_pd_fw,\n\t.update_spirom = psp_v13_0_update_spirom,\n\t.vbflash_stat = psp_v13_0_vbflash_status,\n\t.fatal_error_recovery_quirk = psp_v13_0_fatal_error_recovery_quirk,\n};\n\nvoid psp_v13_0_set_psp_funcs(struct psp_context *psp)\n{\n\tpsp->funcs = &psp_v13_0_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}