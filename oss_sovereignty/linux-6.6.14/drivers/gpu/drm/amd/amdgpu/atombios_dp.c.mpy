{
  "module_name": "atombios_dp.c",
  "hash_id": "c3d3f8b8ad558dba619d1a43fdc853e9da8c791f58a96e9879fbf801ab8f70f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/atombios_dp.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include <drm/display/drm_dp_helper.h>\n\n#include \"amdgpu.h\"\n\n#include \"atom.h\"\n#include \"atom-bits.h\"\n#include \"atombios_encoders.h\"\n#include \"atombios_dp.h\"\n#include \"amdgpu_connectors.h\"\n#include \"amdgpu_atombios.h\"\n\n \n#define DP_LINK_CONFIGURATION_SIZE 9\n#define DP_DPCD_SIZE DP_RECEIVER_CAP_SIZE\n\nstatic char *voltage_names[] = {\n\t\"0.4V\", \"0.6V\", \"0.8V\", \"1.2V\"\n};\nstatic char *pre_emph_names[] = {\n\t\"0dB\", \"3.5dB\", \"6dB\", \"9.5dB\"\n};\n\n \n\nunion aux_channel_transaction {\n\tPROCESS_AUX_CHANNEL_TRANSACTION_PS_ALLOCATION v1;\n\tPROCESS_AUX_CHANNEL_TRANSACTION_PARAMETERS_V2 v2;\n};\n\nstatic int amdgpu_atombios_dp_process_aux_ch(struct amdgpu_i2c_chan *chan,\n\t\t\t\t      u8 *send, int send_bytes,\n\t\t\t\t      u8 *recv, int recv_size,\n\t\t\t\t      u8 delay, u8 *ack)\n{\n\tstruct drm_device *dev = chan->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion aux_channel_transaction args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ProcessAuxChannelTransaction);\n\tunsigned char *base;\n\tint recv_bytes;\n\tint r = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tmutex_lock(&chan->mutex);\n\n\tbase = (unsigned char *)(adev->mode_info.atom_context->scratch + 1);\n\n\tamdgpu_atombios_copy_swap(base, send, send_bytes, true);\n\n\targs.v2.lpAuxRequest = cpu_to_le16((u16)(0 + 4));\n\targs.v2.lpDataOut = cpu_to_le16((u16)(16 + 4));\n\targs.v2.ucDataOutLen = 0;\n\targs.v2.ucChannelID = chan->rec.i2c_id;\n\targs.v2.ucDelay = delay / 10;\n\targs.v2.ucHPD_ID = chan->rec.hpd;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t*ack = args.v2.ucReplyStatus;\n\n\t \n\tif (args.v2.ucReplyStatus == 1) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\t \n\tif (args.v2.ucReplyStatus == 2) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch flags not zero\\n\");\n\t\tr = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif (args.v2.ucReplyStatus == 3) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch error\\n\");\n\t\tr = -EIO;\n\t\tgoto done;\n\t}\n\n\trecv_bytes = args.v1.ucDataOutLen;\n\tif (recv_bytes > recv_size)\n\t\trecv_bytes = recv_size;\n\n\tif (recv && recv_size)\n\t\tamdgpu_atombios_copy_swap(recv, base + 16, recv_bytes, false);\n\n\tr = recv_bytes;\ndone:\n\tmutex_unlock(&chan->mutex);\n\n\treturn r;\n}\n\n#define BARE_ADDRESS_SIZE 3\n#define HEADER_SIZE (BARE_ADDRESS_SIZE + 1)\n\nstatic ssize_t\namdgpu_atombios_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct amdgpu_i2c_chan *chan =\n\t\tcontainer_of(aux, struct amdgpu_i2c_chan, aux);\n\tint ret;\n\tu8 tx_buf[20];\n\tsize_t tx_size;\n\tu8 ack, delay = 0;\n\n\tif (WARN_ON(msg->size > 16))\n\t\treturn -E2BIG;\n\n\ttx_buf[0] = msg->address & 0xff;\n\ttx_buf[1] = msg->address >> 8;\n\ttx_buf[2] = (msg->request << 4) |\n\t\t((msg->address >> 16) & 0xf);\n\ttx_buf[3] = msg->size ? (msg->size - 1) : 0;\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\t\t \n\t\ttx_size = HEADER_SIZE + msg->size;\n\t\tif (msg->size == 0)\n\t\t\ttx_buf[3] |= BARE_ADDRESS_SIZE << 4;\n\t\telse\n\t\t\ttx_buf[3] |= tx_size << 4;\n\t\tmemcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size);\n\t\tret = amdgpu_atombios_dp_process_aux_ch(chan,\n\t\t\t\t\t\t tx_buf, tx_size, NULL, 0, delay, &ack);\n\t\tif (ret >= 0)\n\t\t\t \n\t\t\tret = msg->size;\n\t\tbreak;\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\t \n\t\ttx_size = HEADER_SIZE;\n\t\tif (msg->size == 0)\n\t\t\ttx_buf[3] |= BARE_ADDRESS_SIZE << 4;\n\t\telse\n\t\t\ttx_buf[3] |= tx_size << 4;\n\t\tret = amdgpu_atombios_dp_process_aux_ch(chan,\n\t\t\t\t\t\t tx_buf, tx_size, msg->buffer, msg->size, delay, &ack);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tmsg->reply = ack >> 4;\n\n\treturn ret;\n}\n\nvoid amdgpu_atombios_dp_aux_init(struct amdgpu_connector *amdgpu_connector)\n{\n\tamdgpu_connector->ddc_bus->rec.hpd = amdgpu_connector->hpd.hpd;\n\tamdgpu_connector->ddc_bus->aux.transfer = amdgpu_atombios_dp_aux_transfer;\n\tamdgpu_connector->ddc_bus->aux.drm_dev = amdgpu_connector->base.dev;\n\n\tdrm_dp_aux_init(&amdgpu_connector->ddc_bus->aux);\n\tamdgpu_connector->ddc_bus->has_aux = true;\n}\n\n \n\n#define DP_VOLTAGE_MAX         DP_TRAIN_VOLTAGE_SWING_LEVEL_3\n#define DP_PRE_EMPHASIS_MAX    DP_TRAIN_PRE_EMPH_LEVEL_3\n\nstatic void amdgpu_atombios_dp_get_adjust_train(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t\tint lane_count,\n\t\t\t\t\t\tu8 train_set[4])\n{\n\tu8 v = 0;\n\tu8 p = 0;\n\tint lane;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tu8 this_v = drm_dp_get_adjust_request_voltage(link_status, lane);\n\t\tu8 this_p = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);\n\n\t\tDRM_DEBUG_KMS(\"requested signal parameters: lane %d voltage %s pre_emph %s\\n\",\n\t\t\t  lane,\n\t\t\t  voltage_names[this_v >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\n\t\t\t  pre_emph_names[this_p >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\n\n\t\tif (this_v > v)\n\t\t\tv = this_v;\n\t\tif (this_p > p)\n\t\t\tp = this_p;\n\t}\n\n\tif (v >= DP_VOLTAGE_MAX)\n\t\tv |= DP_TRAIN_MAX_SWING_REACHED;\n\n\tif (p >= DP_PRE_EMPHASIS_MAX)\n\t\tp |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\tDRM_DEBUG_KMS(\"using signal parameters: voltage %s pre_emph %s\\n\",\n\t\t  voltage_names[(v & DP_TRAIN_VOLTAGE_SWING_MASK) >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\n\t\t  pre_emph_names[(p & DP_TRAIN_PRE_EMPHASIS_MASK) >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\n\n\tfor (lane = 0; lane < 4; lane++)\n\t\ttrain_set[lane] = v | p;\n}\n\n \n \nstatic unsigned amdgpu_atombios_dp_convert_bpc_to_bpp(int bpc)\n{\n\tif (bpc == 0)\n\t\treturn 24;\n\telse\n\t\treturn bpc * 3;\n}\n\n \n\nstatic int amdgpu_atombios_dp_get_dp_link_config(struct drm_connector *connector,\n\t\t\t\t\t\t const u8 dpcd[DP_DPCD_SIZE],\n\t\t\t\t\t\t unsigned pix_clock,\n\t\t\t\t\t\t unsigned *dp_lanes, unsigned *dp_rate)\n{\n\tunsigned bpp =\n\t\tamdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));\n\tstatic const unsigned link_rates[3] = { 162000, 270000, 540000 };\n\tunsigned max_link_rate = drm_dp_max_link_rate(dpcd);\n\tunsigned max_lane_num = drm_dp_max_lane_count(dpcd);\n\tunsigned lane_num, i, max_pix_clock;\n\n\tif (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==\n\t    ENCODER_OBJECT_ID_NUTMEG) {\n\t\tfor (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {\n\t\t\tmax_pix_clock = (lane_num * 270000 * 8) / bpp;\n\t\t\tif (max_pix_clock >= pix_clock) {\n\t\t\t\t*dp_lanes = lane_num;\n\t\t\t\t*dp_rate = 270000;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(link_rates) && link_rates[i] <= max_link_rate; i++) {\n\t\t\tfor (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {\n\t\t\t\tmax_pix_clock = (lane_num * link_rates[i] * 8) / bpp;\n\t\t\t\tif (max_pix_clock >= pix_clock) {\n\t\t\t\t\t*dp_lanes = lane_num;\n\t\t\t\t\t*dp_rate = link_rates[i];\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u8 amdgpu_atombios_dp_encoder_service(struct amdgpu_device *adev,\n\t\t\t\t      int action, int dp_clock,\n\t\t\t\t      u8 ucconfig, u8 lane_num)\n{\n\tDP_ENCODER_SERVICE_PARAMETERS args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DPEncoderService);\n\n\tmemset(&args, 0, sizeof(args));\n\targs.ucLinkClock = dp_clock / 10;\n\targs.ucConfig = ucconfig;\n\targs.ucAction = action;\n\targs.ucLaneNum = lane_num;\n\targs.ucStatus = 0;\n\n\tamdgpu_atom_execute_table(adev->mode_info.atom_context, index, (uint32_t *)&args);\n\treturn args.ucStatus;\n}\n\nu8 amdgpu_atombios_dp_get_sinktype(struct amdgpu_connector *amdgpu_connector)\n{\n\tstruct drm_device *dev = amdgpu_connector->base.dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\treturn amdgpu_atombios_dp_encoder_service(adev, ATOM_DP_ACTION_GET_SINK_TYPE, 0,\n\t\t\t\t\t   amdgpu_connector->ddc_bus->rec.i2c_id, 0);\n}\n\nstatic void amdgpu_atombios_dp_probe_oui(struct amdgpu_connector *amdgpu_connector)\n{\n\tstruct amdgpu_connector_atom_dig *dig_connector = amdgpu_connector->con_priv;\n\tu8 buf[3];\n\n\tif (!(dig_connector->dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))\n\t\treturn;\n\n\tif (drm_dp_dpcd_read(&amdgpu_connector->ddc_bus->aux, DP_SINK_OUI, buf, 3) == 3)\n\t\tDRM_DEBUG_KMS(\"Sink OUI: %02hx%02hx%02hx\\n\",\n\t\t\t      buf[0], buf[1], buf[2]);\n\n\tif (drm_dp_dpcd_read(&amdgpu_connector->ddc_bus->aux, DP_BRANCH_OUI, buf, 3) == 3)\n\t\tDRM_DEBUG_KMS(\"Branch OUI: %02hx%02hx%02hx\\n\",\n\t\t\t      buf[0], buf[1], buf[2]);\n}\n\nstatic void amdgpu_atombios_dp_ds_ports(struct amdgpu_connector *amdgpu_connector)\n{\n\tstruct amdgpu_connector_atom_dig *dig_connector = amdgpu_connector->con_priv;\n\tint ret;\n\n\tif (dig_connector->dpcd[DP_DPCD_REV] > 0x10) {\n\t\tret = drm_dp_dpcd_read(&amdgpu_connector->ddc_bus->aux,\n\t\t\t\t       DP_DOWNSTREAM_PORT_0,\n\t\t\t\t       dig_connector->downstream_ports,\n\t\t\t\t       DP_MAX_DOWNSTREAM_PORTS);\n\t\tif (ret)\n\t\t\tmemset(dig_connector->downstream_ports, 0,\n\t\t\t       DP_MAX_DOWNSTREAM_PORTS);\n\t}\n}\n\nint amdgpu_atombios_dp_get_dpcd(struct amdgpu_connector *amdgpu_connector)\n{\n\tstruct amdgpu_connector_atom_dig *dig_connector = amdgpu_connector->con_priv;\n\tu8 msg[DP_DPCD_SIZE];\n\tint ret;\n\n\tret = drm_dp_dpcd_read(&amdgpu_connector->ddc_bus->aux, DP_DPCD_REV,\n\t\t\t       msg, DP_DPCD_SIZE);\n\tif (ret == DP_DPCD_SIZE) {\n\t\tmemcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE);\n\n\t\tDRM_DEBUG_KMS(\"DPCD: %*ph\\n\", (int)sizeof(dig_connector->dpcd),\n\t\t\t      dig_connector->dpcd);\n\n\t\tamdgpu_atombios_dp_probe_oui(amdgpu_connector);\n\t\tamdgpu_atombios_dp_ds_ports(amdgpu_connector);\n\t\treturn 0;\n\t}\n\n\tdig_connector->dpcd[0] = 0;\n\treturn -EINVAL;\n}\n\nint amdgpu_atombios_dp_get_panel_mode(struct drm_encoder *encoder,\n\t\t\t       struct drm_connector *connector)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tint panel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\n\tu16 dp_bridge = amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector);\n\tu8 tmp;\n\n\tif (!amdgpu_connector->con_priv)\n\t\treturn panel_mode;\n\n\tif (dp_bridge != ENCODER_OBJECT_ID_NONE) {\n\t\t \n\t\tif (drm_dp_dpcd_readb(&amdgpu_connector->ddc_bus->aux,\n\t\t\t\t      DP_EDP_CONFIGURATION_CAP, &tmp) == 1) {\n\t\t\tif (tmp & 1)\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\n\t\t\telse if ((dp_bridge == ENCODER_OBJECT_ID_NUTMEG) ||\n\t\t\t\t (dp_bridge == ENCODER_OBJECT_ID_TRAVIS))\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP1_MODE;\n\t\t\telse\n\t\t\t\tpanel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\n\t\t}\n\t} else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t \n\t\tif (drm_dp_dpcd_readb(&amdgpu_connector->ddc_bus->aux,\n\t\t\t\t      DP_EDP_CONFIGURATION_CAP, &tmp) == 1) {\n\t\t\tif (tmp & 1)\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\n\t\t}\n\t}\n\n\treturn panel_mode;\n}\n\nvoid amdgpu_atombios_dp_set_link_config(struct drm_connector *connector,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *dig_connector;\n\tint ret;\n\n\tif (!amdgpu_connector->con_priv)\n\t\treturn;\n\tdig_connector = amdgpu_connector->con_priv;\n\n\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\n\t\tret = amdgpu_atombios_dp_get_dp_link_config(connector, dig_connector->dpcd,\n\t\t\t\t\t\t\t    mode->clock,\n\t\t\t\t\t\t\t    &dig_connector->dp_lane_count,\n\t\t\t\t\t\t\t    &dig_connector->dp_clock);\n\t\tif (ret) {\n\t\t\tdig_connector->dp_clock = 0;\n\t\t\tdig_connector->dp_lane_count = 0;\n\t\t}\n\t}\n}\n\nint amdgpu_atombios_dp_mode_valid_helper(struct drm_connector *connector,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *dig_connector;\n\tunsigned dp_lanes, dp_clock;\n\tint ret;\n\n\tif (!amdgpu_connector->con_priv)\n\t\treturn MODE_CLOCK_HIGH;\n\tdig_connector = amdgpu_connector->con_priv;\n\n\tret = amdgpu_atombios_dp_get_dp_link_config(connector, dig_connector->dpcd,\n\t\t\t\t\t\t    mode->clock, &dp_lanes, &dp_clock);\n\tif (ret)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif ((dp_clock == 540000) &&\n\t    (!amdgpu_connector_is_dp12_capable(connector)))\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nbool amdgpu_atombios_dp_needs_link_train(struct amdgpu_connector *amdgpu_connector)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tstruct amdgpu_connector_atom_dig *dig = amdgpu_connector->con_priv;\n\n\tif (drm_dp_dpcd_read_link_status(&amdgpu_connector->ddc_bus->aux, link_status)\n\t    <= 0)\n\t\treturn false;\n\tif (drm_dp_channel_eq_ok(link_status, dig->dp_lane_count))\n\t\treturn false;\n\treturn true;\n}\n\nvoid amdgpu_atombios_dp_set_rx_power_state(struct drm_connector *connector,\n\t\t\t\t    u8 power_state)\n{\n\tstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\n\tstruct amdgpu_connector_atom_dig *dig_connector;\n\n\tif (!amdgpu_connector->con_priv)\n\t\treturn;\n\n\tdig_connector = amdgpu_connector->con_priv;\n\n\t \n\tif (dig_connector->dpcd[0] >= 0x11) {\n\t\tdrm_dp_dpcd_writeb(&amdgpu_connector->ddc_bus->aux,\n\t\t\t\t   DP_SET_POWER, power_state);\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\nstruct amdgpu_atombios_dp_link_train_info {\n\tstruct amdgpu_device *adev;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint dp_clock;\n\tint dp_lane_count;\n\tbool tp3_supported;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\tu8 train_set[4];\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tu8 tries;\n\tstruct drm_dp_aux *aux;\n};\n\nstatic void\namdgpu_atombios_dp_update_vs_emph(struct amdgpu_atombios_dp_link_train_info *dp_info)\n{\n\t \n\tamdgpu_atombios_encoder_setup_dig_transmitter(dp_info->encoder,\n\t\t\t\t\t       ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH,\n\t\t\t\t\t       0, dp_info->train_set[0]);  \n\n\t \n\tdrm_dp_dpcd_write(dp_info->aux, DP_TRAINING_LANE0_SET,\n\t\t\t  dp_info->train_set, dp_info->dp_lane_count);\n}\n\nstatic void\namdgpu_atombios_dp_set_tp(struct amdgpu_atombios_dp_link_train_info *dp_info, int tp)\n{\n\tint rtp = 0;\n\n\t \n\tswitch (tp) {\n\tcase DP_TRAINING_PATTERN_1:\n\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_3:\n\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN3;\n\t\t\tbreak;\n\t}\n\tamdgpu_atombios_encoder_setup_dig_encoder(dp_info->encoder, rtp, 0);\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_TRAINING_PATTERN_SET, tp);\n}\n\nstatic int\namdgpu_atombios_dp_link_train_init(struct amdgpu_atombios_dp_link_train_info *dp_info)\n{\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(dp_info->encoder);\n\tstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\n\tu8 tmp;\n\n\t \n\tamdgpu_atombios_dp_set_rx_power_state(dp_info->connector, DP_SET_POWER_D0);\n\n\t \n\tif (dp_info->dpcd[3] & 0x1)\n\t\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t\t   DP_DOWNSPREAD_CTRL, DP_SPREAD_AMP_0_5);\n\telse\n\t\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t\t   DP_DOWNSPREAD_CTRL, 0);\n\n\tif (dig->panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)\n\t\tdrm_dp_dpcd_writeb(dp_info->aux, DP_EDP_CONFIGURATION_SET, 1);\n\n\t \n\ttmp = dp_info->dp_lane_count;\n\tif (drm_dp_enhanced_frame_cap(dp_info->dpcd))\n\t\ttmp |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_LANE_COUNT_SET, tmp);\n\n\t \n\ttmp = drm_dp_link_rate_to_bw_code(dp_info->dp_clock);\n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_LINK_BW_SET, tmp);\n\n\t \n\tamdgpu_atombios_encoder_setup_dig_encoder(dp_info->encoder,\n\t\t\t\t\t   ATOM_ENCODER_CMD_DP_LINK_TRAINING_START, 0);\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t   DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\treturn 0;\n}\n\nstatic int\namdgpu_atombios_dp_link_train_finish(struct amdgpu_atombios_dp_link_train_info *dp_info)\n{\n\tudelay(400);\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t   DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\t \n\tamdgpu_atombios_encoder_setup_dig_encoder(dp_info->encoder,\n\t\t\t\t\t   ATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE, 0);\n\n\treturn 0;\n}\n\nstatic int\namdgpu_atombios_dp_link_train_cr(struct amdgpu_atombios_dp_link_train_info *dp_info)\n{\n\tbool clock_recovery;\n\tu8 voltage;\n\tint i;\n\n\tamdgpu_atombios_dp_set_tp(dp_info, DP_TRAINING_PATTERN_1);\n\tmemset(dp_info->train_set, 0, 4);\n\tamdgpu_atombios_dp_update_vs_emph(dp_info);\n\n\tudelay(400);\n\n\t \n\tclock_recovery = false;\n\tdp_info->tries = 0;\n\tvoltage = 0xff;\n\twhile (1) {\n\t\tdrm_dp_link_train_clock_recovery_delay(dp_info->aux, dp_info->dpcd);\n\n\t\tif (drm_dp_dpcd_read_link_status(dp_info->aux,\n\t\t\t\t\t\t dp_info->link_status) <= 0) {\n\t\t\tDRM_ERROR(\"displayport link status failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_clock_recovery_ok(dp_info->link_status, dp_info->dp_lane_count)) {\n\t\t\tclock_recovery = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < dp_info->dp_lane_count; i++) {\n\t\t\tif ((dp_info->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == dp_info->dp_lane_count) {\n\t\t\tDRM_ERROR(\"clock recovery reached max voltage\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {\n\t\t\t++dp_info->tries;\n\t\t\tif (dp_info->tries == 5) {\n\t\t\t\tDRM_ERROR(\"clock recovery tried 5 times\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tdp_info->tries = 0;\n\n\t\tvoltage = dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\n\n\t\t \n\t\tamdgpu_atombios_dp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count,\n\t\t\t\t\t     dp_info->train_set);\n\n\t\tamdgpu_atombios_dp_update_vs_emph(dp_info);\n\t}\n\tif (!clock_recovery) {\n\t\tDRM_ERROR(\"clock recovery failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"clock recovery at voltage %d pre-emphasis %d\\n\",\n\t\t\t  dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\n\t\t\t  (dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK) >>\n\t\t\t  DP_TRAIN_PRE_EMPHASIS_SHIFT);\n\t\treturn 0;\n\t}\n}\n\nstatic int\namdgpu_atombios_dp_link_train_ce(struct amdgpu_atombios_dp_link_train_info *dp_info)\n{\n\tbool channel_eq;\n\n\tif (dp_info->tp3_supported)\n\t\tamdgpu_atombios_dp_set_tp(dp_info, DP_TRAINING_PATTERN_3);\n\telse\n\t\tamdgpu_atombios_dp_set_tp(dp_info, DP_TRAINING_PATTERN_2);\n\n\t \n\tdp_info->tries = 0;\n\tchannel_eq = false;\n\twhile (1) {\n\t\tdrm_dp_link_train_channel_eq_delay(dp_info->aux, dp_info->dpcd);\n\n\t\tif (drm_dp_dpcd_read_link_status(dp_info->aux,\n\t\t\t\t\t\t dp_info->link_status) <= 0) {\n\t\t\tDRM_ERROR(\"displayport link status failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_channel_eq_ok(dp_info->link_status, dp_info->dp_lane_count)) {\n\t\t\tchannel_eq = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dp_info->tries > 5) {\n\t\t\tDRM_ERROR(\"channel eq failed: 5 tries\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tamdgpu_atombios_dp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count,\n\t\t\t\t\t     dp_info->train_set);\n\n\t\tamdgpu_atombios_dp_update_vs_emph(dp_info);\n\t\tdp_info->tries++;\n\t}\n\n\tif (!channel_eq) {\n\t\tDRM_ERROR(\"channel eq failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"channel eq at voltage %d pre-emphasis %d\\n\",\n\t\t\t  dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\n\t\t\t  (dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK)\n\t\t\t  >> DP_TRAIN_PRE_EMPHASIS_SHIFT);\n\t\treturn 0;\n\t}\n}\n\nvoid amdgpu_atombios_dp_link_train(struct drm_encoder *encoder,\n\t\t\t    struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct amdgpu_connector *amdgpu_connector;\n\tstruct amdgpu_connector_atom_dig *dig_connector;\n\tstruct amdgpu_atombios_dp_link_train_info dp_info;\n\tu8 tmp;\n\n\tif (!amdgpu_encoder->enc_priv)\n\t\treturn;\n\n\tamdgpu_connector = to_amdgpu_connector(connector);\n\tif (!amdgpu_connector->con_priv)\n\t\treturn;\n\tdig_connector = amdgpu_connector->con_priv;\n\n\tif ((dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT) &&\n\t    (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_eDP))\n\t\treturn;\n\n\tif (drm_dp_dpcd_readb(&amdgpu_connector->ddc_bus->aux, DP_MAX_LANE_COUNT, &tmp)\n\t    == 1) {\n\t\tif (tmp & DP_TPS3_SUPPORTED)\n\t\t\tdp_info.tp3_supported = true;\n\t\telse\n\t\t\tdp_info.tp3_supported = false;\n\t} else {\n\t\tdp_info.tp3_supported = false;\n\t}\n\n\tmemcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE);\n\tdp_info.adev = adev;\n\tdp_info.encoder = encoder;\n\tdp_info.connector = connector;\n\tdp_info.dp_lane_count = dig_connector->dp_lane_count;\n\tdp_info.dp_clock = dig_connector->dp_clock;\n\tdp_info.aux = &amdgpu_connector->ddc_bus->aux;\n\n\tif (amdgpu_atombios_dp_link_train_init(&dp_info))\n\t\tgoto done;\n\tif (amdgpu_atombios_dp_link_train_cr(&dp_info))\n\t\tgoto done;\n\tif (amdgpu_atombios_dp_link_train_ce(&dp_info))\n\t\tgoto done;\ndone:\n\tif (amdgpu_atombios_dp_link_train_finish(&dp_info))\n\t\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}