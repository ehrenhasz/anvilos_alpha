{
  "module_name": "amdgpu_vkms.c",
  "hash_id": "66617139790132fca93dc51416b44540c4ed77b3ab954dddda071602536076c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c",
  "human_readable_source": "\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"amdgpu.h\"\n#ifdef CONFIG_DRM_AMDGPU_SI\n#include \"dce_v6_0.h\"\n#endif\n#ifdef CONFIG_DRM_AMDGPU_CIK\n#include \"dce_v8_0.h\"\n#endif\n#include \"dce_v10_0.h\"\n#include \"dce_v11_0.h\"\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n#include \"amdgpu_vkms.h\"\n#include \"amdgpu_display.h\"\n#include \"atom.h\"\n#include \"amdgpu_irq.h\"\n\n \n\nstatic const u32 amdgpu_vkms_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic enum hrtimer_restart amdgpu_vkms_vblank_simulate(struct hrtimer *timer)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = container_of(timer, struct amdgpu_crtc, vblank_timer);\n\tstruct drm_crtc *crtc = &amdgpu_crtc->base;\n\tstruct amdgpu_vkms_output *output = drm_crtc_to_amdgpu_vkms_output(crtc);\n\tu64 ret_overrun;\n\tbool ret;\n\n\tret_overrun = hrtimer_forward_now(&amdgpu_crtc->vblank_timer,\n\t\t\t\t\t  output->period_ns);\n\tif (ret_overrun != 1)\n\t\tDRM_WARN(\"%s: vblank timer overrun\\n\", __func__);\n\n\tret = drm_crtc_handle_vblank(crtc);\n\t \n\tif (!ret)\n\t\treturn HRTIMER_NORESTART;\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int amdgpu_vkms_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct amdgpu_vkms_output *out = drm_crtc_to_amdgpu_vkms_output(crtc);\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\n\tdrm_calc_timestamping_constants(crtc, &crtc->mode);\n\n\tout->period_ns = ktime_set(0, vblank->framedur_ns);\n\thrtimer_start(&amdgpu_crtc->vblank_timer, out->period_ns, HRTIMER_MODE_REL);\n\n\treturn 0;\n}\n\nstatic void amdgpu_vkms_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\n\thrtimer_try_to_cancel(&amdgpu_crtc->vblank_timer);\n}\n\nstatic bool amdgpu_vkms_get_vblank_timestamp(struct drm_crtc *crtc,\n\t\t\t\t\t     int *max_error,\n\t\t\t\t\t     ktime_t *vblank_time,\n\t\t\t\t\t     bool in_vblank_irq)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct amdgpu_vkms_output *output = drm_crtc_to_amdgpu_vkms_output(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\n\tif (!READ_ONCE(vblank->enabled)) {\n\t\t*vblank_time = ktime_get();\n\t\treturn true;\n\t}\n\n\t*vblank_time = READ_ONCE(amdgpu_crtc->vblank_timer.node.expires);\n\n\tif (WARN_ON(*vblank_time == vblank->time))\n\t\treturn true;\n\n\t \n\t*vblank_time -= output->period_ns;\n\n\treturn true;\n}\n\nstatic const struct drm_crtc_funcs amdgpu_vkms_crtc_funcs = {\n\t.set_config             = drm_atomic_helper_set_config,\n\t.destroy                = drm_crtc_cleanup,\n\t.page_flip              = drm_atomic_helper_page_flip,\n\t.reset                  = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t\t= amdgpu_vkms_enable_vblank,\n\t.disable_vblank\t\t= amdgpu_vkms_disable_vblank,\n\t.get_vblank_timestamp\t= amdgpu_vkms_get_vblank_timestamp,\n};\n\nstatic void amdgpu_vkms_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void amdgpu_vkms_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_off(crtc);\n}\n\nstatic void amdgpu_vkms_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tunsigned long flags;\n\tif (crtc->state->event) {\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\n\t\tif (drm_crtc_vblank_get(crtc) != 0)\n\t\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\telse\n\t\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs amdgpu_vkms_crtc_helper_funcs = {\n\t.atomic_flush\t= amdgpu_vkms_crtc_atomic_flush,\n\t.atomic_enable\t= amdgpu_vkms_crtc_atomic_enable,\n\t.atomic_disable\t= amdgpu_vkms_crtc_atomic_disable,\n};\n\nstatic int amdgpu_vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t  struct drm_plane *primary, struct drm_plane *cursor)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tint ret;\n\n\tret = drm_crtc_init_with_planes(dev, crtc, primary, cursor,\n\t\t\t\t\t&amdgpu_vkms_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init CRTC\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &amdgpu_vkms_crtc_helper_funcs);\n\n\tamdgpu_crtc->crtc_id = drm_crtc_index(crtc);\n\tadev->mode_info.crtcs[drm_crtc_index(crtc)] = amdgpu_crtc;\n\n\tamdgpu_crtc->pll_id = ATOM_PPLL_INVALID;\n\tamdgpu_crtc->encoder = NULL;\n\tamdgpu_crtc->connector = NULL;\n\tamdgpu_crtc->vsync_timer_enabled = AMDGPU_IRQ_STATE_DISABLE;\n\n\thrtimer_init(&amdgpu_crtc->vblank_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tamdgpu_crtc->vblank_timer.function = &amdgpu_vkms_vblank_simulate;\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_funcs amdgpu_vkms_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int amdgpu_vkms_conn_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode = NULL;\n\tunsigned i;\n\tstatic const struct mode_size {\n\t\tint w;\n\t\tint h;\n\t} common_modes[] = {\n\t\t{ 640,  480},\n\t\t{ 720,  480},\n\t\t{ 800,  600},\n\t\t{ 848,  480},\n\t\t{1024,  768},\n\t\t{1152,  768},\n\t\t{1280,  720},\n\t\t{1280,  800},\n\t\t{1280,  854},\n\t\t{1280,  960},\n\t\t{1280, 1024},\n\t\t{1440,  900},\n\t\t{1400, 1050},\n\t\t{1680, 1050},\n\t\t{1600, 1200},\n\t\t{1920, 1080},\n\t\t{1920, 1200},\n\t\t{2560, 1440},\n\t\t{4096, 3112},\n\t\t{3656, 2664},\n\t\t{3840, 2160},\n\t\t{4096, 2160},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(common_modes); i++) {\n\t\tmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);\n\t\tif (!mode)\n\t\t\tcontinue;\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\tdrm_set_preferred_mode(connector, XRES_DEF, YRES_DEF);\n\n\treturn ARRAY_SIZE(common_modes);\n}\n\nstatic const struct drm_connector_helper_funcs amdgpu_vkms_conn_helper_funcs = {\n\t.get_modes    = amdgpu_vkms_conn_get_modes,\n};\n\nstatic const struct drm_plane_funcs amdgpu_vkms_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic void amdgpu_vkms_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_atomic_state *old_state)\n{\n\treturn;\n}\n\nstatic int amdgpu_vkms_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (!new_plane_state->fb || WARN_ON(!new_plane_state->crtc))\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (!new_plane_state->visible)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_prepare_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *new_state)\n{\n\tstruct amdgpu_framebuffer *afb;\n\tstruct drm_gem_object *obj;\n\tstruct amdgpu_device *adev;\n\tstruct amdgpu_bo *rbo;\n\tuint32_t domain;\n\tint r;\n\n\tif (!new_state->fb) {\n\t\tDRM_DEBUG_KMS(\"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\tafb = to_amdgpu_framebuffer(new_state->fb);\n\tobj = new_state->fb->obj[0];\n\trbo = gem_to_amdgpu_bo(obj);\n\tadev = amdgpu_ttm_adev(rbo->tbo.bdev);\n\n\tr = amdgpu_bo_reserve(rbo, true);\n\tif (r) {\n\t\tdev_err(adev->dev, \"fail to reserve bo (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = dma_resv_reserve_fences(rbo->tbo.base.resv, 1);\n\tif (r) {\n\t\tdev_err(adev->dev, \"allocating fence slot failed (%d)\\n\", r);\n\t\tgoto error_unlock;\n\t}\n\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdomain = amdgpu_display_supported_domains(adev, rbo->flags);\n\telse\n\t\tdomain = AMDGPU_GEM_DOMAIN_VRAM;\n\n\tr = amdgpu_bo_pin(rbo, domain);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to pin framebuffer with error %d\\n\", r);\n\t\tgoto error_unlock;\n\t}\n\n\tr = amdgpu_ttm_alloc_gart(&rbo->tbo);\n\tif (unlikely(r != 0)) {\n\t\tDRM_ERROR(\"%p bind failed\\n\", rbo);\n\t\tgoto error_unpin;\n\t}\n\n\tamdgpu_bo_unreserve(rbo);\n\n\tafb->address = amdgpu_bo_gpu_offset(rbo);\n\n\tamdgpu_bo_ref(rbo);\n\n\treturn 0;\n\nerror_unpin:\n\tamdgpu_bo_unpin(rbo);\n\nerror_unlock:\n\tamdgpu_bo_unreserve(rbo);\n\treturn r;\n}\n\nstatic void amdgpu_vkms_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t   struct drm_plane_state *old_state)\n{\n\tstruct amdgpu_bo *rbo;\n\tint r;\n\n\tif (!old_state->fb)\n\t\treturn;\n\n\trbo = gem_to_amdgpu_bo(old_state->fb->obj[0]);\n\tr = amdgpu_bo_reserve(rbo, false);\n\tif (unlikely(r)) {\n\t\tDRM_ERROR(\"failed to reserve rbo before unpin\\n\");\n\t\treturn;\n\t}\n\n\tamdgpu_bo_unpin(rbo);\n\tamdgpu_bo_unreserve(rbo);\n\tamdgpu_bo_unref(&rbo);\n}\n\nstatic const struct drm_plane_helper_funcs amdgpu_vkms_primary_helper_funcs = {\n\t.atomic_update\t\t= amdgpu_vkms_plane_atomic_update,\n\t.atomic_check\t\t= amdgpu_vkms_plane_atomic_check,\n\t.prepare_fb\t\t= amdgpu_vkms_prepare_fb,\n\t.cleanup_fb\t\t= amdgpu_vkms_cleanup_fb,\n};\n\nstatic struct drm_plane *amdgpu_vkms_plane_init(struct drm_device *dev,\n\t\t\t\t\t\tenum drm_plane_type type,\n\t\t\t\t\t\tint index)\n{\n\tstruct drm_plane *plane;\n\tint ret;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = drm_universal_plane_init(dev, plane, 1 << index,\n\t\t\t\t       &amdgpu_vkms_plane_funcs,\n\t\t\t\t       amdgpu_vkms_formats,\n\t\t\t\t       ARRAY_SIZE(amdgpu_vkms_formats),\n\t\t\t\t       NULL, type, NULL);\n\tif (ret) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_plane_helper_add(plane, &amdgpu_vkms_primary_helper_funcs);\n\n\treturn plane;\n}\n\nstatic int amdgpu_vkms_output_init(struct drm_device *dev, struct\n\t\t\t\t   amdgpu_vkms_output *output, int index)\n{\n\tstruct drm_connector *connector = &output->connector;\n\tstruct drm_encoder *encoder = &output->encoder;\n\tstruct drm_crtc *crtc = &output->crtc.base;\n\tstruct drm_plane *primary, *cursor = NULL;\n\tint ret;\n\n\tprimary = amdgpu_vkms_plane_init(dev, DRM_PLANE_TYPE_PRIMARY, index);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\n\tret = amdgpu_vkms_crtc_init(dev, crtc, primary, cursor);\n\tif (ret)\n\t\tgoto err_crtc;\n\n\tret = drm_connector_init(dev, connector, &amdgpu_vkms_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init connector\\n\");\n\t\tgoto err_connector;\n\t}\n\n\tdrm_connector_helper_add(connector, &amdgpu_vkms_conn_helper_funcs);\n\n\tret = drm_simple_encoder_init(dev, encoder, DRM_MODE_ENCODER_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init encoder\\n\");\n\t\tgoto err_encoder;\n\t}\n\tencoder->possible_crtcs = 1 << index;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to attach connector to encoder\\n\");\n\t\tgoto err_attach;\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n\nerr_attach:\n\tdrm_encoder_cleanup(encoder);\n\nerr_encoder:\n\tdrm_connector_cleanup(connector);\n\nerr_connector:\n\tdrm_crtc_cleanup(crtc);\n\nerr_crtc:\n\tdrm_plane_cleanup(primary);\n\n\treturn ret;\n}\n\nconst struct drm_mode_config_funcs amdgpu_vkms_mode_funcs = {\n\t.fb_create = amdgpu_display_user_framebuffer_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int amdgpu_vkms_sw_init(void *handle)\n{\n\tint r, i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->amdgpu_vkms_output = kcalloc(adev->mode_info.num_crtc,\n\t\tsizeof(struct amdgpu_vkms_output), GFP_KERNEL);\n\tif (!adev->amdgpu_vkms_output)\n\t\treturn -ENOMEM;\n\n\tadev_to_drm(adev)->max_vblank_count = 0;\n\n\tadev_to_drm(adev)->mode_config.funcs = &amdgpu_vkms_mode_funcs;\n\n\tadev_to_drm(adev)->mode_config.max_width = XRES_MAX;\n\tadev_to_drm(adev)->mode_config.max_height = YRES_MAX;\n\n\tadev_to_drm(adev)->mode_config.preferred_depth = 24;\n\tadev_to_drm(adev)->mode_config.prefer_shadow = 1;\n\n\tadev_to_drm(adev)->mode_config.fb_modifiers_not_supported = true;\n\n\tr = amdgpu_display_modeset_create_props(adev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\tr = amdgpu_vkms_output_init(adev_to_drm(adev), &adev->amdgpu_vkms_output[i], i);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = drm_vblank_init(adev_to_drm(adev), adev->mode_info.num_crtc);\n\tif (r)\n\t\treturn r;\n\n\tdrm_kms_helper_poll_init(adev_to_drm(adev));\n\n\tadev->mode_info.mode_config_initialized = true;\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint i = 0;\n\n\tfor (i = 0; i < adev->mode_info.num_crtc; i++)\n\t\tif (adev->mode_info.crtcs[i])\n\t\t\thrtimer_cancel(&adev->mode_info.crtcs[i]->vblank_timer);\n\n\tdrm_kms_helper_poll_fini(adev_to_drm(adev));\n\tdrm_mode_config_cleanup(adev_to_drm(adev));\n\n\tadev->mode_info.mode_config_initialized = false;\n\n\tkfree(adev->mode_info.bios_hardcoded_edid);\n\tkfree(adev->amdgpu_vkms_output);\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tswitch (adev->asic_type) {\n#ifdef CONFIG_DRM_AMDGPU_SI\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n\t\tdce_v6_0_disable_dce(adev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\tcase CHIP_BONAIRE:\n\tcase CHIP_HAWAII:\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\t\tdce_v8_0_disable_dce(adev);\n\t\tbreak;\n#endif\n\tcase CHIP_FIJI:\n\tcase CHIP_TONGA:\n\t\tdce_v10_0_disable_dce(adev);\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_VEGAM:\n\t\tdce_v11_0_disable_dce(adev);\n\t\tbreak;\n\tcase CHIP_TOPAZ:\n#ifdef CONFIG_DRM_AMDGPU_SI\n\tcase CHIP_HAINAN:\n#endif\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_hw_fini(void *handle)\n{\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = drm_mode_config_helper_suspend(adev_to_drm(adev));\n\tif (r)\n\t\treturn r;\n\treturn amdgpu_vkms_hw_fini(handle);\n}\n\nstatic int amdgpu_vkms_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_vkms_hw_init(handle);\n\tif (r)\n\t\treturn r;\n\treturn drm_mode_config_helper_resume(adev_to_drm(adev));\n}\n\nstatic bool amdgpu_vkms_is_idle(void *handle)\n{\n\treturn true;\n}\n\nstatic int amdgpu_vkms_wait_for_idle(void *handle)\n{\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_soft_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int amdgpu_vkms_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs amdgpu_vkms_ip_funcs = {\n\t.name = \"amdgpu_vkms\",\n\t.early_init = NULL,\n\t.late_init = NULL,\n\t.sw_init = amdgpu_vkms_sw_init,\n\t.sw_fini = amdgpu_vkms_sw_fini,\n\t.hw_init = amdgpu_vkms_hw_init,\n\t.hw_fini = amdgpu_vkms_hw_fini,\n\t.suspend = amdgpu_vkms_suspend,\n\t.resume = amdgpu_vkms_resume,\n\t.is_idle = amdgpu_vkms_is_idle,\n\t.wait_for_idle = amdgpu_vkms_wait_for_idle,\n\t.soft_reset = amdgpu_vkms_soft_reset,\n\t.set_clockgating_state = amdgpu_vkms_set_clockgating_state,\n\t.set_powergating_state = amdgpu_vkms_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version amdgpu_vkms_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_DCE,\n\t.major = 1,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &amdgpu_vkms_ip_funcs,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}