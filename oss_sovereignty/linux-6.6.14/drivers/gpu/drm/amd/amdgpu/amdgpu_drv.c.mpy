{
  "module_name": "amdgpu_drv.c",
  "hash_id": "700d07c17b12b0a25bdc17b1bd1d25e1d21575819b5dd4be645b4fb4f587a7a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c",
  "human_readable_source": " \n\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_pciids.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <linux/cc_platform.h>\n#include <linux/dynamic_debug.h>\n#include <linux/module.h>\n#include <linux/mmu_notifier.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <linux/vga_switcheroo.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_dma_buf.h\"\n#include \"amdgpu_drv.h\"\n#include \"amdgpu_fdinfo.h\"\n#include \"amdgpu_irq.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu_reset.h\"\n#include \"amdgpu_sched.h\"\n#include \"amdgpu_xgmi.h\"\n#include \"../amdxcp/amdgpu_xcp_drv.h\"\n\n \n#define KMS_DRIVER_MAJOR\t3\n#define KMS_DRIVER_MINOR\t54\n#define KMS_DRIVER_PATCHLEVEL\t0\n\nunsigned int amdgpu_vram_limit = UINT_MAX;\nint amdgpu_vis_vram_limit;\nint amdgpu_gart_size = -1;  \nint amdgpu_gtt_size = -1;  \nint amdgpu_moverate = -1;  \nint amdgpu_audio = -1;\nint amdgpu_disp_priority;\nint amdgpu_hw_i2c;\nint amdgpu_pcie_gen2 = -1;\nint amdgpu_msi = -1;\nchar amdgpu_lockup_timeout[AMDGPU_MAX_TIMEOUT_PARAM_LENGTH];\nint amdgpu_dpm = -1;\nint amdgpu_fw_load_type = -1;\nint amdgpu_aspm = -1;\nint amdgpu_runtime_pm = -1;\nuint amdgpu_ip_block_mask = 0xffffffff;\nint amdgpu_bapm = -1;\nint amdgpu_deep_color;\nint amdgpu_vm_size = -1;\nint amdgpu_vm_fragment_size = -1;\nint amdgpu_vm_block_size = -1;\nint amdgpu_vm_fault_stop;\nint amdgpu_vm_debug;\nint amdgpu_vm_update_mode = -1;\nint amdgpu_exp_hw_support;\nint amdgpu_dc = -1;\nint amdgpu_sched_jobs = 32;\nint amdgpu_sched_hw_submission = 2;\nuint amdgpu_pcie_gen_cap;\nuint amdgpu_pcie_lane_cap;\nu64 amdgpu_cg_mask = 0xffffffffffffffff;\nuint amdgpu_pg_mask = 0xffffffff;\nuint amdgpu_sdma_phase_quantum = 32;\nchar *amdgpu_disable_cu;\nchar *amdgpu_virtual_display;\nbool enforce_isolation;\n \nuint amdgpu_pp_feature_mask = 0xfff7bfff;\nuint amdgpu_force_long_training;\nint amdgpu_lbpw = -1;\nint amdgpu_compute_multipipe = -1;\nint amdgpu_gpu_recovery = -1;  \nint amdgpu_emu_mode;\nuint amdgpu_smu_memory_pool_size;\nint amdgpu_smu_pptable_id = -1;\n \nuint amdgpu_dc_feature_mask = 2;\nuint amdgpu_dc_debug_mask;\nuint amdgpu_dc_visual_confirm;\nint amdgpu_async_gfx_ring = 1;\nint amdgpu_mcbp = -1;\nint amdgpu_discovery = -1;\nint amdgpu_mes;\nint amdgpu_mes_kiq;\nint amdgpu_noretry = -1;\nint amdgpu_force_asic_type = -1;\nint amdgpu_tmz = -1;  \nint amdgpu_reset_method = -1;  \nint amdgpu_num_kcq = -1;\nint amdgpu_smartshift_bias;\nint amdgpu_use_xgmi_p2p = 1;\nint amdgpu_vcnfw_log;\nint amdgpu_sg_display = -1;  \nint amdgpu_user_partt_mode = AMDGPU_AUTO_COMPUTE_PARTITION_MODE;\n\nstatic void amdgpu_drv_delayed_reset_work_handler(struct work_struct *work);\n\nDECLARE_DYNDBG_CLASSMAP(drm_debug_classes, DD_CLASS_TYPE_DISJOINT_BITS, 0,\n\t\t\t\"DRM_UT_CORE\",\n\t\t\t\"DRM_UT_DRIVER\",\n\t\t\t\"DRM_UT_KMS\",\n\t\t\t\"DRM_UT_PRIME\",\n\t\t\t\"DRM_UT_ATOMIC\",\n\t\t\t\"DRM_UT_VBL\",\n\t\t\t\"DRM_UT_STATE\",\n\t\t\t\"DRM_UT_LEASE\",\n\t\t\t\"DRM_UT_DP\",\n\t\t\t\"DRM_UT_DRMRES\");\n\nstruct amdgpu_mgpu_info mgpu_info = {\n\t.mutex = __MUTEX_INITIALIZER(mgpu_info.mutex),\n\t.delayed_reset_work = __DELAYED_WORK_INITIALIZER(\n\t\t\tmgpu_info.delayed_reset_work,\n\t\t\tamdgpu_drv_delayed_reset_work_handler, 0),\n};\nint amdgpu_ras_enable = -1;\nuint amdgpu_ras_mask = 0xffffffff;\nint amdgpu_bad_page_threshold = -1;\nstruct amdgpu_watchdog_timer amdgpu_watchdog_timer = {\n\t.timeout_fatal_disable = false,\n\t.period = 0x0,  \n};\n\n \nMODULE_PARM_DESC(vramlimit, \"Restrict VRAM for testing, in megabytes\");\nmodule_param_named(vramlimit, amdgpu_vram_limit, int, 0600);\n\n \nMODULE_PARM_DESC(vis_vramlimit, \"Restrict visible VRAM for testing, in megabytes\");\nmodule_param_named(vis_vramlimit, amdgpu_vis_vram_limit, int, 0444);\n\n \nMODULE_PARM_DESC(gartsize, \"Size of kernel GART to setup in megabytes (32, 64, etc., -1=auto)\");\nmodule_param_named(gartsize, amdgpu_gart_size, uint, 0600);\n\n \nMODULE_PARM_DESC(gttsize, \"Size of the GTT userspace domain in megabytes (-1 = auto)\");\nmodule_param_named(gttsize, amdgpu_gtt_size, int, 0600);\n\n \nMODULE_PARM_DESC(moverate, \"Maximum buffer migration rate in MB/s. (32, 64, etc., -1=auto, 0=1=disabled)\");\nmodule_param_named(moverate, amdgpu_moverate, int, 0600);\n\n \nMODULE_PARM_DESC(audio, \"Audio enable (-1 = auto, 0 = disable, 1 = enable)\");\nmodule_param_named(audio, amdgpu_audio, int, 0444);\n\n \nMODULE_PARM_DESC(disp_priority, \"Display Priority (0 = auto, 1 = normal, 2 = high)\");\nmodule_param_named(disp_priority, amdgpu_disp_priority, int, 0444);\n\n \nMODULE_PARM_DESC(hw_i2c, \"hw i2c engine enable (0 = disable)\");\nmodule_param_named(hw_i2c, amdgpu_hw_i2c, int, 0444);\n\n \nMODULE_PARM_DESC(pcie_gen2, \"PCIE Gen2 mode (-1 = auto, 0 = disable, 1 = enable)\");\nmodule_param_named(pcie_gen2, amdgpu_pcie_gen2, int, 0444);\n\n \nMODULE_PARM_DESC(msi, \"MSI support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(msi, amdgpu_msi, int, 0444);\n\n \nMODULE_PARM_DESC(lockup_timeout, \"GPU lockup timeout in ms (default: for bare metal 10000 for non-compute jobs and 60000 for compute jobs; \"\n\t\t\"for passthrough or sriov, 10000 for all jobs. 0: keep default value. negative: infinity timeout), format: for bare metal [Non-Compute] or [GFX,Compute,SDMA,Video]; \"\n\t\t\"for passthrough or sriov [all jobs] or [GFX,Compute,SDMA,Video].\");\nmodule_param_string(lockup_timeout, amdgpu_lockup_timeout, sizeof(amdgpu_lockup_timeout), 0444);\n\n \nMODULE_PARM_DESC(dpm, \"DPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(dpm, amdgpu_dpm, int, 0444);\n\n \nMODULE_PARM_DESC(fw_load_type, \"firmware loading type (3 = rlc backdoor autoload if supported, 2 = smu load if supported, 1 = psp load, 0 = force direct if supported, -1 = auto)\");\nmodule_param_named(fw_load_type, amdgpu_fw_load_type, int, 0444);\n\n \nMODULE_PARM_DESC(aspm, \"ASPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(aspm, amdgpu_aspm, int, 0444);\n\n \nMODULE_PARM_DESC(runpm, \"PX runtime pm (2 = force enable with BAMACO, 1 = force enable with BACO, 0 = disable, -1 = auto, -2 = autowith displays)\");\nmodule_param_named(runpm, amdgpu_runtime_pm, int, 0444);\n\n \nMODULE_PARM_DESC(ip_block_mask, \"IP Block Mask (all blocks enabled (default))\");\nmodule_param_named(ip_block_mask, amdgpu_ip_block_mask, uint, 0444);\n\n \nMODULE_PARM_DESC(bapm, \"BAPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(bapm, amdgpu_bapm, int, 0444);\n\n \nMODULE_PARM_DESC(deep_color, \"Deep Color support (1 = enable, 0 = disable (default))\");\nmodule_param_named(deep_color, amdgpu_deep_color, int, 0444);\n\n \nMODULE_PARM_DESC(vm_size, \"VM address space size in gigabytes (default 64GB)\");\nmodule_param_named(vm_size, amdgpu_vm_size, int, 0444);\n\n \nMODULE_PARM_DESC(vm_fragment_size, \"VM fragment size in bits (4, 5, etc. 4 = 64K (default), Max 9 = 2M)\");\nmodule_param_named(vm_fragment_size, amdgpu_vm_fragment_size, int, 0444);\n\n \nMODULE_PARM_DESC(vm_block_size, \"VM page table size in bits (default depending on vm_size)\");\nmodule_param_named(vm_block_size, amdgpu_vm_block_size, int, 0444);\n\n \nMODULE_PARM_DESC(vm_fault_stop, \"Stop on VM fault (0 = never (default), 1 = print first, 2 = always)\");\nmodule_param_named(vm_fault_stop, amdgpu_vm_fault_stop, int, 0444);\n\n \nMODULE_PARM_DESC(vm_debug, \"Debug VM handling (0 = disabled (default), 1 = enabled)\");\nmodule_param_named(vm_debug, amdgpu_vm_debug, int, 0644);\n\n \nMODULE_PARM_DESC(vm_update_mode, \"VM update using CPU (0 = never (default except for large BAR(LB)), 1 = Graphics only, 2 = Compute only (default for LB), 3 = Both\");\nmodule_param_named(vm_update_mode, amdgpu_vm_update_mode, int, 0444);\n\n \nMODULE_PARM_DESC(exp_hw_support, \"experimental hw support (1 = enable, 0 = disable (default))\");\nmodule_param_named(exp_hw_support, amdgpu_exp_hw_support, int, 0444);\n\n \nMODULE_PARM_DESC(dc, \"Display Core driver (1 = enable, 0 = disable, -1 = auto (default))\");\nmodule_param_named(dc, amdgpu_dc, int, 0444);\n\n \nMODULE_PARM_DESC(sched_jobs, \"the max number of jobs supported in the sw queue (default 32)\");\nmodule_param_named(sched_jobs, amdgpu_sched_jobs, int, 0444);\n\n \nMODULE_PARM_DESC(sched_hw_submission, \"the max number of HW submissions (default 2)\");\nmodule_param_named(sched_hw_submission, amdgpu_sched_hw_submission, int, 0444);\n\n \nMODULE_PARM_DESC(ppfeaturemask, \"all power features enabled (default))\");\nmodule_param_named(ppfeaturemask, amdgpu_pp_feature_mask, hexint, 0444);\n\n \nMODULE_PARM_DESC(forcelongtraining, \"force memory long training\");\nmodule_param_named(forcelongtraining, amdgpu_force_long_training, uint, 0444);\n\n \nMODULE_PARM_DESC(pcie_gen_cap, \"PCIE Gen Caps (0: autodetect (default))\");\nmodule_param_named(pcie_gen_cap, amdgpu_pcie_gen_cap, uint, 0444);\n\n \nMODULE_PARM_DESC(pcie_lane_cap, \"PCIE Lane Caps (0: autodetect (default))\");\nmodule_param_named(pcie_lane_cap, amdgpu_pcie_lane_cap, uint, 0444);\n\n \nMODULE_PARM_DESC(cg_mask, \"Clockgating flags mask (0 = disable clock gating)\");\nmodule_param_named(cg_mask, amdgpu_cg_mask, ullong, 0444);\n\n \nMODULE_PARM_DESC(pg_mask, \"Powergating flags mask (0 = disable power gating)\");\nmodule_param_named(pg_mask, amdgpu_pg_mask, uint, 0444);\n\n \nMODULE_PARM_DESC(sdma_phase_quantum, \"SDMA context switch phase quantum (x 1K GPU clock cycles, 0 = no change (default 32))\");\nmodule_param_named(sdma_phase_quantum, amdgpu_sdma_phase_quantum, uint, 0444);\n\n \nMODULE_PARM_DESC(disable_cu, \"Disable CUs (se.sh.cu,...)\");\nmodule_param_named(disable_cu, amdgpu_disable_cu, charp, 0444);\n\n \nMODULE_PARM_DESC(virtual_display,\n\t\t \"Enable virtual display feature (the virtual_display will be set like xxxx:xx:xx.x,x;xxxx:xx:xx.x,x)\");\nmodule_param_named(virtual_display, amdgpu_virtual_display, charp, 0444);\n\n \nMODULE_PARM_DESC(lbpw, \"Load Balancing Per Watt (LBPW) support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(lbpw, amdgpu_lbpw, int, 0444);\n\nMODULE_PARM_DESC(compute_multipipe, \"Force compute queues to be spread across pipes (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(compute_multipipe, amdgpu_compute_multipipe, int, 0444);\n\n \nMODULE_PARM_DESC(gpu_recovery, \"Enable GPU recovery mechanism, (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(gpu_recovery, amdgpu_gpu_recovery, int, 0444);\n\n \nMODULE_PARM_DESC(emu_mode, \"Emulation mode, (1 = enable, 0 = disable)\");\nmodule_param_named(emu_mode, amdgpu_emu_mode, int, 0444);\n\n \nMODULE_PARM_DESC(ras_enable, \"Enable RAS features on the GPU (0 = disable, 1 = enable, -1 = auto (default))\");\nmodule_param_named(ras_enable, amdgpu_ras_enable, int, 0444);\n\n \nMODULE_PARM_DESC(ras_mask, \"Mask of RAS features to enable (default 0xffffffff), only valid when ras_enable == 1\");\nmodule_param_named(ras_mask, amdgpu_ras_mask, uint, 0444);\n\n \nMODULE_PARM_DESC(timeout_fatal_disable, \"disable watchdog timeout fatal error (false = default)\");\nmodule_param_named(timeout_fatal_disable, amdgpu_watchdog_timer.timeout_fatal_disable, bool, 0644);\n\n \nMODULE_PARM_DESC(timeout_period, \"watchdog timeout period (0 = timeout disabled, 1 ~ 0x23 = timeout maxcycles = (1 << period)\");\nmodule_param_named(timeout_period, amdgpu_watchdog_timer.period, uint, 0644);\n\n \n#ifdef CONFIG_DRM_AMDGPU_SI\n\n#if IS_ENABLED(CONFIG_DRM_RADEON) || IS_ENABLED(CONFIG_DRM_RADEON_MODULE)\nint amdgpu_si_support = 0;\nMODULE_PARM_DESC(si_support, \"SI support (1 = enabled, 0 = disabled (default))\");\n#else\nint amdgpu_si_support = 1;\nMODULE_PARM_DESC(si_support, \"SI support (1 = enabled (default), 0 = disabled)\");\n#endif\n\nmodule_param_named(si_support, amdgpu_si_support, int, 0444);\n#endif\n\n \n#ifdef CONFIG_DRM_AMDGPU_CIK\n\n#if IS_ENABLED(CONFIG_DRM_RADEON) || IS_ENABLED(CONFIG_DRM_RADEON_MODULE)\nint amdgpu_cik_support = 0;\nMODULE_PARM_DESC(cik_support, \"CIK support (1 = enabled, 0 = disabled (default))\");\n#else\nint amdgpu_cik_support = 1;\nMODULE_PARM_DESC(cik_support, \"CIK support (1 = enabled (default), 0 = disabled)\");\n#endif\n\nmodule_param_named(cik_support, amdgpu_cik_support, int, 0444);\n#endif\n\n \nMODULE_PARM_DESC(smu_memory_pool_size,\n\t\"reserve gtt for smu debug usage, 0 = disable,0x1 = 256Mbyte, 0x2 = 512Mbyte, 0x4 = 1 Gbyte, 0x8 = 2GByte\");\nmodule_param_named(smu_memory_pool_size, amdgpu_smu_memory_pool_size, uint, 0444);\n\n \nMODULE_PARM_DESC(async_gfx_ring,\n\t\"Asynchronous GFX rings that could be configured with either different priorities (HP3D ring and LP3D ring), or equal priorities (0 = disabled, 1 = enabled (default))\");\nmodule_param_named(async_gfx_ring, amdgpu_async_gfx_ring, int, 0444);\n\n \nMODULE_PARM_DESC(mcbp,\n\t\"Enable Mid-command buffer preemption (0 = disabled, 1 = enabled), -1 = auto (default)\");\nmodule_param_named(mcbp, amdgpu_mcbp, int, 0444);\n\n \nMODULE_PARM_DESC(discovery,\n\t\"Allow driver to discover hardware IPs from IP Discovery table at the top of VRAM\");\nmodule_param_named(discovery, amdgpu_discovery, int, 0444);\n\n \nMODULE_PARM_DESC(mes,\n\t\"Enable Micro Engine Scheduler (0 = disabled (default), 1 = enabled)\");\nmodule_param_named(mes, amdgpu_mes, int, 0444);\n\n \nMODULE_PARM_DESC(mes_kiq,\n\t\"Enable Micro Engine Scheduler KIQ (0 = disabled (default), 1 = enabled)\");\nmodule_param_named(mes_kiq, amdgpu_mes_kiq, int, 0444);\n\n \nMODULE_PARM_DESC(noretry,\n\t\"Disable retry faults (0 = retry enabled, 1 = retry disabled, -1 auto (default))\");\nmodule_param_named(noretry, amdgpu_noretry, int, 0644);\n\n \nMODULE_PARM_DESC(force_asic_type,\n\t\"A non negative value used to specify the asic type for all supported GPUs\");\nmodule_param_named(force_asic_type, amdgpu_force_asic_type, int, 0444);\n\n \nMODULE_PARM_DESC(use_xgmi_p2p,\n\t\"Enable XGMI P2P interface (0 = disable; 1 = enable (default))\");\nmodule_param_named(use_xgmi_p2p, amdgpu_use_xgmi_p2p, int, 0444);\n\n\n#ifdef CONFIG_HSA_AMD\n \nint sched_policy = KFD_SCHED_POLICY_HWS;\nmodule_param(sched_policy, int, 0444);\nMODULE_PARM_DESC(sched_policy,\n\t\"Scheduling policy (0 = HWS (Default), 1 = HWS without over-subscription, 2 = Non-HWS (Used for debugging only)\");\n\n \nint hws_max_conc_proc = -1;\nmodule_param(hws_max_conc_proc, int, 0444);\nMODULE_PARM_DESC(hws_max_conc_proc,\n\t\"Max # processes HWS can execute concurrently when sched_policy=0 (0 = no concurrency, #VMIDs for KFD = Maximum(default))\");\n\n \nint cwsr_enable = 1;\nmodule_param(cwsr_enable, int, 0444);\nMODULE_PARM_DESC(cwsr_enable, \"CWSR enable (0 = Off, 1 = On (Default))\");\n\n \nint max_num_of_queues_per_device = KFD_MAX_NUM_OF_QUEUES_PER_DEVICE_DEFAULT;\nmodule_param(max_num_of_queues_per_device, int, 0444);\nMODULE_PARM_DESC(max_num_of_queues_per_device,\n\t\"Maximum number of supported queues per device (1 = Minimum, 4096 = default)\");\n\n \nint send_sigterm;\nmodule_param(send_sigterm, int, 0444);\nMODULE_PARM_DESC(send_sigterm,\n\t\"Send sigterm to HSA process on unhandled exception (0 = disable, 1 = enable)\");\n\n \nint debug_largebar;\nmodule_param(debug_largebar, int, 0444);\nMODULE_PARM_DESC(debug_largebar,\n\t\"Debug large-bar flag used to simulate large-bar capability on non-large bar machine (0 = disable, 1 = enable)\");\n\n \nint halt_if_hws_hang;\nmodule_param(halt_if_hws_hang, int, 0644);\nMODULE_PARM_DESC(halt_if_hws_hang, \"Halt if HWS hang is detected (0 = off (default), 1 = on)\");\n\n \nbool hws_gws_support;\nmodule_param(hws_gws_support, bool, 0444);\nMODULE_PARM_DESC(hws_gws_support, \"Assume MEC2 FW supports GWS barriers (false = rely on FW version check (Default), true = force supported)\");\n\n \nint queue_preemption_timeout_ms = 9000;\nmodule_param(queue_preemption_timeout_ms, int, 0644);\nMODULE_PARM_DESC(queue_preemption_timeout_ms, \"queue preemption timeout in ms (1 = Minimum, 9000 = default)\");\n\n \nbool debug_evictions;\nmodule_param(debug_evictions, bool, 0644);\nMODULE_PARM_DESC(debug_evictions, \"enable eviction debug messages (false = default)\");\n\n \nbool no_system_mem_limit;\nmodule_param(no_system_mem_limit, bool, 0644);\nMODULE_PARM_DESC(no_system_mem_limit, \"disable system memory limit (false = default)\");\n\n \nint amdgpu_no_queue_eviction_on_vm_fault;\nMODULE_PARM_DESC(no_queue_eviction_on_vm_fault, \"No queue eviction on VM fault (0 = queue eviction, 1 = no queue eviction)\");\nmodule_param_named(no_queue_eviction_on_vm_fault, amdgpu_no_queue_eviction_on_vm_fault, int, 0444);\n#endif\n\n \nint amdgpu_mtype_local;\nMODULE_PARM_DESC(mtype_local, \"MTYPE for local memory (0 = MTYPE_RW (default), 1 = MTYPE_NC, 2 = MTYPE_CC)\");\nmodule_param_named(mtype_local, amdgpu_mtype_local, int, 0444);\n\n \n#ifdef CONFIG_HSA_AMD_P2P\nbool pcie_p2p = true;\nmodule_param(pcie_p2p, bool, 0444);\nMODULE_PARM_DESC(pcie_p2p, \"Enable PCIe P2P (requires large-BAR). (N = off, Y = on(default))\");\n#endif\n\n \nMODULE_PARM_DESC(dcfeaturemask, \"all stable DC features enabled (default))\");\nmodule_param_named(dcfeaturemask, amdgpu_dc_feature_mask, uint, 0444);\n\n \nMODULE_PARM_DESC(dcdebugmask, \"all debug options disabled (default))\");\nmodule_param_named(dcdebugmask, amdgpu_dc_debug_mask, uint, 0444);\n\nMODULE_PARM_DESC(visualconfirm, \"Visual confirm (0 = off (default), 1 = MPO, 5 = PSR)\");\nmodule_param_named(visualconfirm, amdgpu_dc_visual_confirm, uint, 0444);\n\n \nuint amdgpu_dm_abm_level;\nMODULE_PARM_DESC(abmlevel, \"ABM level (0 = off (default), 1-4 = backlight reduction level) \");\nmodule_param_named(abmlevel, amdgpu_dm_abm_level, uint, 0444);\n\nint amdgpu_backlight = -1;\nMODULE_PARM_DESC(backlight, \"Backlight control (0 = pwm, 1 = aux, -1 auto (default))\");\nmodule_param_named(backlight, amdgpu_backlight, bint, 0444);\n\n \nMODULE_PARM_DESC(tmz, \"Enable TMZ feature (-1 = auto (default), 0 = off, 1 = on)\");\nmodule_param_named(tmz, amdgpu_tmz, int, 0444);\n\n \nMODULE_PARM_DESC(reset_method, \"GPU reset method (-1 = auto (default), 0 = legacy, 1 = mode0, 2 = mode1, 3 = mode2, 4 = baco/bamaco)\");\nmodule_param_named(reset_method, amdgpu_reset_method, int, 0444);\n\n \nMODULE_PARM_DESC(bad_page_threshold, \"Bad page threshold(-1 = ignore threshold (default value), 0 = disable bad page retirement, -2 = driver sets threshold)\");\nmodule_param_named(bad_page_threshold, amdgpu_bad_page_threshold, int, 0444);\n\nMODULE_PARM_DESC(num_kcq, \"number of kernel compute queue user want to setup (8 if set to greater than 8 or less than 0, only affect gfx 8+)\");\nmodule_param_named(num_kcq, amdgpu_num_kcq, int, 0444);\n\n \nMODULE_PARM_DESC(vcnfw_log, \"Enable vcnfw log(0 = disable (default value), 1 = enable)\");\nmodule_param_named(vcnfw_log, amdgpu_vcnfw_log, int, 0444);\n\n \nMODULE_PARM_DESC(sg_display, \"S/G Display (-1 = auto (default), 0 = disable)\");\nmodule_param_named(sg_display, amdgpu_sg_display, int, 0444);\n\n \nMODULE_PARM_DESC(smu_pptable_id,\n\t\"specify pptable id to be used (-1 = auto(default) value, 0 = use pptable from vbios, > 0 = soft pptable id)\");\nmodule_param_named(smu_pptable_id, amdgpu_smu_pptable_id, int, 0444);\n\n \nMODULE_PARM_DESC(\n\tuser_partt_mode,\n\t\"specify partition mode to be used (-2 = AMDGPU_AUTO_COMPUTE_PARTITION_MODE(default value) \\\n\t\t\t\t\t\t0 = AMDGPU_SPX_PARTITION_MODE, \\\n\t\t\t\t\t\t1 = AMDGPU_DPX_PARTITION_MODE, \\\n\t\t\t\t\t\t2 = AMDGPU_TPX_PARTITION_MODE, \\\n\t\t\t\t\t\t3 = AMDGPU_QPX_PARTITION_MODE, \\\n\t\t\t\t\t\t4 = AMDGPU_CPX_PARTITION_MODE)\");\nmodule_param_named(user_partt_mode, amdgpu_user_partt_mode, uint, 0444);\n\n\n/**\n * DOC: enforce_isolation (bool)\n * enforce process isolation between graphics and compute via using the same reserved vmid.\n */\nmodule_param(enforce_isolation, bool, 0444);\nMODULE_PARM_DESC(enforce_isolation, \"enforce process isolation between graphics and compute . enforce_isolation = on\");\n\n/* These devices are not supported by amdgpu.\n * They are supported by the mach64, r128, radeon drivers\n */\nstatic const u16 amdgpu_unsupported_pciidlist[] = {\n\t/* mach64 */\n\t0x4354,\n\t0x4358,\n\t0x4554,\n\t0x4742,\n\t0x4744,\n\t0x4749,\n\t0x474C,\n\t0x474D,\n\t0x474E,\n\t0x474F,\n\t0x4750,\n\t0x4751,\n\t0x4752,\n\t0x4753,\n\t0x4754,\n\t0x4755,\n\t0x4756,\n\t0x4757,\n\t0x4758,\n\t0x4759,\n\t0x475A,\n\t0x4C42,\n\t0x4C44,\n\t0x4C47,\n\t0x4C49,\n\t0x4C4D,\n\t0x4C4E,\n\t0x4C50,\n\t0x4C51,\n\t0x4C52,\n\t0x4C53,\n\t0x5654,\n\t0x5655,\n\t0x5656,\n\t/* r128 */\n\t0x4c45,\n\t0x4c46,\n\t0x4d46,\n\t0x4d4c,\n\t0x5041,\n\t0x5042,\n\t0x5043,\n\t0x5044,\n\t0x5045,\n\t0x5046,\n\t0x5047,\n\t0x5048,\n\t0x5049,\n\t0x504A,\n\t0x504B,\n\t0x504C,\n\t0x504D,\n\t0x504E,\n\t0x504F,\n\t0x5050,\n\t0x5051,\n\t0x5052,\n\t0x5053,\n\t0x5054,\n\t0x5055,\n\t0x5056,\n\t0x5057,\n\t0x5058,\n\t0x5245,\n\t0x5246,\n\t0x5247,\n\t0x524b,\n\t0x524c,\n\t0x534d,\n\t0x5446,\n\t0x544C,\n\t0x5452,\n\t/* radeon */\n\t0x3150,\n\t0x3151,\n\t0x3152,\n\t0x3154,\n\t0x3155,\n\t0x3E50,\n\t0x3E54,\n\t0x4136,\n\t0x4137,\n\t0x4144,\n\t0x4145,\n\t0x4146,\n\t0x4147,\n\t0x4148,\n\t0x4149,\n\t0x414A,\n\t0x414B,\n\t0x4150,\n\t0x4151,\n\t0x4152,\n\t0x4153,\n\t0x4154,\n\t0x4155,\n\t0x4156,\n\t0x4237,\n\t0x4242,\n\t0x4336,\n\t0x4337,\n\t0x4437,\n\t0x4966,\n\t0x4967,\n\t0x4A48,\n\t0x4A49,\n\t0x4A4A,\n\t0x4A4B,\n\t0x4A4C,\n\t0x4A4D,\n\t0x4A4E,\n\t0x4A4F,\n\t0x4A50,\n\t0x4A54,\n\t0x4B48,\n\t0x4B49,\n\t0x4B4A,\n\t0x4B4B,\n\t0x4B4C,\n\t0x4C57,\n\t0x4C58,\n\t0x4C59,\n\t0x4C5A,\n\t0x4C64,\n\t0x4C66,\n\t0x4C67,\n\t0x4E44,\n\t0x4E45,\n\t0x4E46,\n\t0x4E47,\n\t0x4E48,\n\t0x4E49,\n\t0x4E4A,\n\t0x4E4B,\n\t0x4E50,\n\t0x4E51,\n\t0x4E52,\n\t0x4E53,\n\t0x4E54,\n\t0x4E56,\n\t0x5144,\n\t0x5145,\n\t0x5146,\n\t0x5147,\n\t0x5148,\n\t0x514C,\n\t0x514D,\n\t0x5157,\n\t0x5158,\n\t0x5159,\n\t0x515A,\n\t0x515E,\n\t0x5460,\n\t0x5462,\n\t0x5464,\n\t0x5548,\n\t0x5549,\n\t0x554A,\n\t0x554B,\n\t0x554C,\n\t0x554D,\n\t0x554E,\n\t0x554F,\n\t0x5550,\n\t0x5551,\n\t0x5552,\n\t0x5554,\n\t0x564A,\n\t0x564B,\n\t0x564F,\n\t0x5652,\n\t0x5653,\n\t0x5657,\n\t0x5834,\n\t0x5835,\n\t0x5954,\n\t0x5955,\n\t0x5974,\n\t0x5975,\n\t0x5960,\n\t0x5961,\n\t0x5962,\n\t0x5964,\n\t0x5965,\n\t0x5969,\n\t0x5a41,\n\t0x5a42,\n\t0x5a61,\n\t0x5a62,\n\t0x5b60,\n\t0x5b62,\n\t0x5b63,\n\t0x5b64,\n\t0x5b65,\n\t0x5c61,\n\t0x5c63,\n\t0x5d48,\n\t0x5d49,\n\t0x5d4a,\n\t0x5d4c,\n\t0x5d4d,\n\t0x5d4e,\n\t0x5d4f,\n\t0x5d50,\n\t0x5d52,\n\t0x5d57,\n\t0x5e48,\n\t0x5e4a,\n\t0x5e4b,\n\t0x5e4c,\n\t0x5e4d,\n\t0x5e4f,\n\t0x6700,\n\t0x6701,\n\t0x6702,\n\t0x6703,\n\t0x6704,\n\t0x6705,\n\t0x6706,\n\t0x6707,\n\t0x6708,\n\t0x6709,\n\t0x6718,\n\t0x6719,\n\t0x671c,\n\t0x671d,\n\t0x671f,\n\t0x6720,\n\t0x6721,\n\t0x6722,\n\t0x6723,\n\t0x6724,\n\t0x6725,\n\t0x6726,\n\t0x6727,\n\t0x6728,\n\t0x6729,\n\t0x6738,\n\t0x6739,\n\t0x673e,\n\t0x6740,\n\t0x6741,\n\t0x6742,\n\t0x6743,\n\t0x6744,\n\t0x6745,\n\t0x6746,\n\t0x6747,\n\t0x6748,\n\t0x6749,\n\t0x674A,\n\t0x6750,\n\t0x6751,\n\t0x6758,\n\t0x6759,\n\t0x675B,\n\t0x675D,\n\t0x675F,\n\t0x6760,\n\t0x6761,\n\t0x6762,\n\t0x6763,\n\t0x6764,\n\t0x6765,\n\t0x6766,\n\t0x6767,\n\t0x6768,\n\t0x6770,\n\t0x6771,\n\t0x6772,\n\t0x6778,\n\t0x6779,\n\t0x677B,\n\t0x6840,\n\t0x6841,\n\t0x6842,\n\t0x6843,\n\t0x6849,\n\t0x684C,\n\t0x6850,\n\t0x6858,\n\t0x6859,\n\t0x6880,\n\t0x6888,\n\t0x6889,\n\t0x688A,\n\t0x688C,\n\t0x688D,\n\t0x6898,\n\t0x6899,\n\t0x689b,\n\t0x689c,\n\t0x689d,\n\t0x689e,\n\t0x68a0,\n\t0x68a1,\n\t0x68a8,\n\t0x68a9,\n\t0x68b0,\n\t0x68b8,\n\t0x68b9,\n\t0x68ba,\n\t0x68be,\n\t0x68bf,\n\t0x68c0,\n\t0x68c1,\n\t0x68c7,\n\t0x68c8,\n\t0x68c9,\n\t0x68d8,\n\t0x68d9,\n\t0x68da,\n\t0x68de,\n\t0x68e0,\n\t0x68e1,\n\t0x68e4,\n\t0x68e5,\n\t0x68e8,\n\t0x68e9,\n\t0x68f1,\n\t0x68f2,\n\t0x68f8,\n\t0x68f9,\n\t0x68fa,\n\t0x68fe,\n\t0x7100,\n\t0x7101,\n\t0x7102,\n\t0x7103,\n\t0x7104,\n\t0x7105,\n\t0x7106,\n\t0x7108,\n\t0x7109,\n\t0x710A,\n\t0x710B,\n\t0x710C,\n\t0x710E,\n\t0x710F,\n\t0x7140,\n\t0x7141,\n\t0x7142,\n\t0x7143,\n\t0x7144,\n\t0x7145,\n\t0x7146,\n\t0x7147,\n\t0x7149,\n\t0x714A,\n\t0x714B,\n\t0x714C,\n\t0x714D,\n\t0x714E,\n\t0x714F,\n\t0x7151,\n\t0x7152,\n\t0x7153,\n\t0x715E,\n\t0x715F,\n\t0x7180,\n\t0x7181,\n\t0x7183,\n\t0x7186,\n\t0x7187,\n\t0x7188,\n\t0x718A,\n\t0x718B,\n\t0x718C,\n\t0x718D,\n\t0x718F,\n\t0x7193,\n\t0x7196,\n\t0x719B,\n\t0x719F,\n\t0x71C0,\n\t0x71C1,\n\t0x71C2,\n\t0x71C3,\n\t0x71C4,\n\t0x71C5,\n\t0x71C6,\n\t0x71C7,\n\t0x71CD,\n\t0x71CE,\n\t0x71D2,\n\t0x71D4,\n\t0x71D5,\n\t0x71D6,\n\t0x71DA,\n\t0x71DE,\n\t0x7200,\n\t0x7210,\n\t0x7211,\n\t0x7240,\n\t0x7243,\n\t0x7244,\n\t0x7245,\n\t0x7246,\n\t0x7247,\n\t0x7248,\n\t0x7249,\n\t0x724A,\n\t0x724B,\n\t0x724C,\n\t0x724D,\n\t0x724E,\n\t0x724F,\n\t0x7280,\n\t0x7281,\n\t0x7283,\n\t0x7284,\n\t0x7287,\n\t0x7288,\n\t0x7289,\n\t0x728B,\n\t0x728C,\n\t0x7290,\n\t0x7291,\n\t0x7293,\n\t0x7297,\n\t0x7834,\n\t0x7835,\n\t0x791e,\n\t0x791f,\n\t0x793f,\n\t0x7941,\n\t0x7942,\n\t0x796c,\n\t0x796d,\n\t0x796e,\n\t0x796f,\n\t0x9400,\n\t0x9401,\n\t0x9402,\n\t0x9403,\n\t0x9405,\n\t0x940A,\n\t0x940B,\n\t0x940F,\n\t0x94A0,\n\t0x94A1,\n\t0x94A3,\n\t0x94B1,\n\t0x94B3,\n\t0x94B4,\n\t0x94B5,\n\t0x94B9,\n\t0x9440,\n\t0x9441,\n\t0x9442,\n\t0x9443,\n\t0x9444,\n\t0x9446,\n\t0x944A,\n\t0x944B,\n\t0x944C,\n\t0x944E,\n\t0x9450,\n\t0x9452,\n\t0x9456,\n\t0x945A,\n\t0x945B,\n\t0x945E,\n\t0x9460,\n\t0x9462,\n\t0x946A,\n\t0x946B,\n\t0x947A,\n\t0x947B,\n\t0x9480,\n\t0x9487,\n\t0x9488,\n\t0x9489,\n\t0x948A,\n\t0x948F,\n\t0x9490,\n\t0x9491,\n\t0x9495,\n\t0x9498,\n\t0x949C,\n\t0x949E,\n\t0x949F,\n\t0x94C0,\n\t0x94C1,\n\t0x94C3,\n\t0x94C4,\n\t0x94C5,\n\t0x94C6,\n\t0x94C7,\n\t0x94C8,\n\t0x94C9,\n\t0x94CB,\n\t0x94CC,\n\t0x94CD,\n\t0x9500,\n\t0x9501,\n\t0x9504,\n\t0x9505,\n\t0x9506,\n\t0x9507,\n\t0x9508,\n\t0x9509,\n\t0x950F,\n\t0x9511,\n\t0x9515,\n\t0x9517,\n\t0x9519,\n\t0x9540,\n\t0x9541,\n\t0x9542,\n\t0x954E,\n\t0x954F,\n\t0x9552,\n\t0x9553,\n\t0x9555,\n\t0x9557,\n\t0x955f,\n\t0x9580,\n\t0x9581,\n\t0x9583,\n\t0x9586,\n\t0x9587,\n\t0x9588,\n\t0x9589,\n\t0x958A,\n\t0x958B,\n\t0x958C,\n\t0x958D,\n\t0x958E,\n\t0x958F,\n\t0x9590,\n\t0x9591,\n\t0x9593,\n\t0x9595,\n\t0x9596,\n\t0x9597,\n\t0x9598,\n\t0x9599,\n\t0x959B,\n\t0x95C0,\n\t0x95C2,\n\t0x95C4,\n\t0x95C5,\n\t0x95C6,\n\t0x95C7,\n\t0x95C9,\n\t0x95CC,\n\t0x95CD,\n\t0x95CE,\n\t0x95CF,\n\t0x9610,\n\t0x9611,\n\t0x9612,\n\t0x9613,\n\t0x9614,\n\t0x9615,\n\t0x9616,\n\t0x9640,\n\t0x9641,\n\t0x9642,\n\t0x9643,\n\t0x9644,\n\t0x9645,\n\t0x9647,\n\t0x9648,\n\t0x9649,\n\t0x964a,\n\t0x964b,\n\t0x964c,\n\t0x964e,\n\t0x964f,\n\t0x9710,\n\t0x9711,\n\t0x9712,\n\t0x9713,\n\t0x9714,\n\t0x9715,\n\t0x9802,\n\t0x9803,\n\t0x9804,\n\t0x9805,\n\t0x9806,\n\t0x9807,\n\t0x9808,\n\t0x9809,\n\t0x980A,\n\t0x9900,\n\t0x9901,\n\t0x9903,\n\t0x9904,\n\t0x9905,\n\t0x9906,\n\t0x9907,\n\t0x9908,\n\t0x9909,\n\t0x990A,\n\t0x990B,\n\t0x990C,\n\t0x990D,\n\t0x990E,\n\t0x990F,\n\t0x9910,\n\t0x9913,\n\t0x9917,\n\t0x9918,\n\t0x9919,\n\t0x9990,\n\t0x9991,\n\t0x9992,\n\t0x9993,\n\t0x9994,\n\t0x9995,\n\t0x9996,\n\t0x9997,\n\t0x9998,\n\t0x9999,\n\t0x999A,\n\t0x999B,\n\t0x999C,\n\t0x999D,\n\t0x99A0,\n\t0x99A2,\n\t0x99A4,\n\t/* radeon secondary ids */\n\t0x3171,\n\t0x3e70,\n\t0x4164,\n\t0x4165,\n\t0x4166,\n\t0x4168,\n\t0x4170,\n\t0x4171,\n\t0x4172,\n\t0x4173,\n\t0x496e,\n\t0x4a69,\n\t0x4a6a,\n\t0x4a6b,\n\t0x4a70,\n\t0x4a74,\n\t0x4b69,\n\t0x4b6b,\n\t0x4b6c,\n\t0x4c6e,\n\t0x4e64,\n\t0x4e65,\n\t0x4e66,\n\t0x4e67,\n\t0x4e68,\n\t0x4e69,\n\t0x4e6a,\n\t0x4e71,\n\t0x4f73,\n\t0x5569,\n\t0x556b,\n\t0x556d,\n\t0x556f,\n\t0x5571,\n\t0x5854,\n\t0x5874,\n\t0x5940,\n\t0x5941,\n\t0x5b70,\n\t0x5b72,\n\t0x5b73,\n\t0x5b74,\n\t0x5b75,\n\t0x5d44,\n\t0x5d45,\n\t0x5d6d,\n\t0x5d6f,\n\t0x5d72,\n\t0x5d77,\n\t0x5e6b,\n\t0x5e6d,\n\t0x7120,\n\t0x7124,\n\t0x7129,\n\t0x712e,\n\t0x712f,\n\t0x7162,\n\t0x7163,\n\t0x7166,\n\t0x7167,\n\t0x7172,\n\t0x7173,\n\t0x71a0,\n\t0x71a1,\n\t0x71a3,\n\t0x71a7,\n\t0x71bb,\n\t0x71e0,\n\t0x71e1,\n\t0x71e2,\n\t0x71e6,\n\t0x71e7,\n\t0x71f2,\n\t0x7269,\n\t0x726b,\n\t0x726e,\n\t0x72a0,\n\t0x72a8,\n\t0x72b1,\n\t0x72b3,\n\t0x793f,\n};\n\nstatic const struct pci_device_id pciidlist[] = {\n#ifdef CONFIG_DRM_AMDGPU_SI\n\t{0x1002, 0x6780, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6784, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6788, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x678A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6790, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6791, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6792, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6798, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6799, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x679A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x679B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x679E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x679F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI},\n\t{0x1002, 0x6800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6806, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6808, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6809, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6810, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6811, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6816, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6817, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6818, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6819, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN},\n\t{0x1002, 0x6600, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6601, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6602, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6603, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6604, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6605, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6606, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6607, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6608, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND},\n\t{0x1002, 0x6610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND},\n\t{0x1002, 0x6611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND},\n\t{0x1002, 0x6613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND},\n\t{0x1002, 0x6617, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6620, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6621, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6623, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|AMD_IS_MOBILITY},\n\t{0x1002, 0x6631, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND},\n\t{0x1002, 0x6820, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6821, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6822, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6823, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6824, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6825, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6826, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6827, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6828, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x6829, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x682A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x682B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x682C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x682D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x682F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x6837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x6838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x6839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x683B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x683D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x683F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE},\n\t{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6665, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n\t{0x1002, 0x6667, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n\t{0x1002, 0x666F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|AMD_IS_MOBILITY},\n#endif\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\t/* Kaveri */\n\t{0x1002, 0x1304, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x1305, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1306, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x1307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1309, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x130F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1313, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1315, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1316, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x1317, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x1318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x131B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x131C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t{0x1002, 0x131D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|AMD_IS_APU},\n\t/* Bonaire */\n\t{0x1002, 0x6640, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6641, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|AMD_IS_MOBILITY},\n\t{0x1002, 0x6649, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x6650, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x6651, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t{0x1002, 0x665f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE},\n\t/* Hawaii */\n\t{0x1002, 0x67A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67A8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67A9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67AA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67B0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67B1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67B8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67BA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t{0x1002, 0x67BE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII},\n\t/* Kabini */\n\t{0x1002, 0x9830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x9832, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9833, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x9834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x9836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x9838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x983a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x983b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x983c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x983d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x983e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t{0x1002, 0x983f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|AMD_IS_APU},\n\t/* mullins */\n\t{0x1002, 0x9850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9851, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9852, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9853, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9854, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9855, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9856, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9857, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9858, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x9859, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n\t{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},\n#endif\n\t/* topaz */\n\t{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},\n\t{0x1002, 0x6901, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},\n\t{0x1002, 0x6902, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},\n\t{0x1002, 0x6903, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},\n\t{0x1002, 0x6907, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},\n\t/* tonga */\n\t{0x1002, 0x6920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6921, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6928, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6929, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x692B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x692F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6930, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6938, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t{0x1002, 0x6939, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TONGA},\n\t/* fiji */\n\t{0x1002, 0x7300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_FIJI},\n\t{0x1002, 0x730F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_FIJI},\n\t/* carrizo */\n\t{0x1002, 0x9870, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CARRIZO|AMD_IS_APU},\n\t{0x1002, 0x9874, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CARRIZO|AMD_IS_APU},\n\t{0x1002, 0x9875, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CARRIZO|AMD_IS_APU},\n\t{0x1002, 0x9876, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CARRIZO|AMD_IS_APU},\n\t{0x1002, 0x9877, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CARRIZO|AMD_IS_APU},\n\t/* stoney */\n\t{0x1002, 0x98E4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_STONEY|AMD_IS_APU},\n\t/* Polaris11 */\n\t{0x1002, 0x67E0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67E3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67E8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67EB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67EF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67FF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67E1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67E7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t{0x1002, 0x67E9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS11},\n\t/* Polaris10 */\n\t{0x1002, 0x67C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67D0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67DF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67C9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67CA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67CC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x67CF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t{0x1002, 0x6FDF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS10},\n\t/* Polaris12 */\n\t{0x1002, 0x6980, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6981, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6985, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6986, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6987, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6995, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x6997, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t{0x1002, 0x699F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},\n\t/* VEGAM */\n\t{0x1002, 0x694C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGAM},\n\t{0x1002, 0x694E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGAM},\n\t{0x1002, 0x694F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGAM},\n\t/* Vega 10 */\n\t{0x1002, 0x6860, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6861, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6862, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6863, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6864, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6867, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6868, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x6869, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x686f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t{0x1002, 0x687f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA10},\n\t/* Vega 12 */\n\t{0x1002, 0x69A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA12},\n\t{0x1002, 0x69A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA12},\n\t{0x1002, 0x69A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA12},\n\t{0x1002, 0x69A3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA12},\n\t{0x1002, 0x69AF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA12},\n\t/* Vega 20 */\n\t{0x1002, 0x66A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66A3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66A4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66A7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t{0x1002, 0x66AF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VEGA20},\n\t/* Raven */\n\t{0x1002, 0x15dd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RAVEN|AMD_IS_APU},\n\t{0x1002, 0x15d8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RAVEN|AMD_IS_APU},\n\t/* Arcturus */\n\t{0x1002, 0x738C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARCTURUS},\n\t{0x1002, 0x7388, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARCTURUS},\n\t{0x1002, 0x738E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARCTURUS},\n\t{0x1002, 0x7390, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARCTURUS},\n\t/* Navi10 */\n\t{0x1002, 0x7310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x7312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x7318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x7319, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x731A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x731B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x731E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t{0x1002, 0x731F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI10},\n\t/* Navi14 */\n\t{0x1002, 0x7340, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI14},\n\t{0x1002, 0x7341, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI14},\n\t{0x1002, 0x7347, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI14},\n\t{0x1002, 0x734F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI14},\n\n\t/* Renoir */\n\t{0x1002, 0x15E7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RENOIR|AMD_IS_APU},\n\t{0x1002, 0x1636, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RENOIR|AMD_IS_APU},\n\t{0x1002, 0x1638, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RENOIR|AMD_IS_APU},\n\t{0x1002, 0x164C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RENOIR|AMD_IS_APU},\n\n\t/* Navi12 */\n\t{0x1002, 0x7360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI12},\n\t{0x1002, 0x7362, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVI12},\n\n\t/* Sienna_Cichlid */\n\t{0x1002, 0x73A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73A9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73AB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73AC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73AD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73AE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73AF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\t{0x1002, 0x73BF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SIENNA_CICHLID},\n\n\t/* Yellow Carp */\n\t{0x1002, 0x164D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_YELLOW_CARP|AMD_IS_APU},\n\t{0x1002, 0x1681, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_YELLOW_CARP|AMD_IS_APU},\n\n\t/* Navy_Flounder */\n\t{0x1002, 0x73C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73C3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\t{0x1002, 0x73DF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_NAVY_FLOUNDER},\n\n\t/* DIMGREY_CAVEFISH */\n\t{0x1002, 0x73E0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73E1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73E2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73E3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73E8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73E9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73EA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73EB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73EC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73ED, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73EF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\t{0x1002, 0x73FF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_DIMGREY_CAVEFISH},\n\n\t/* Aldebaran */\n\t{0x1002, 0x7408, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ALDEBARAN},\n\t{0x1002, 0x740C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ALDEBARAN},\n\t{0x1002, 0x740F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ALDEBARAN},\n\t{0x1002, 0x7410, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ALDEBARAN},\n\n\t/* CYAN_SKILLFISH */\n\t{0x1002, 0x13FE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYAN_SKILLFISH|AMD_IS_APU},\n\t{0x1002, 0x143F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYAN_SKILLFISH|AMD_IS_APU},\n\n\t/* BEIGE_GOBY */\n\t{0x1002, 0x7420, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\t{0x1002, 0x7421, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\t{0x1002, 0x7422, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\t{0x1002, 0x7423, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\t{0x1002, 0x7424, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\t{0x1002, 0x743F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BEIGE_GOBY},\n\n\t{ PCI_DEVICE(0x1002, PCI_ANY_ID),\n\t  .class = PCI_CLASS_DISPLAY_VGA << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = CHIP_IP_DISCOVERY },\n\n\t{ PCI_DEVICE(0x1002, PCI_ANY_ID),\n\t  .class = PCI_CLASS_DISPLAY_OTHER << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = CHIP_IP_DISCOVERY },\n\n\t{ PCI_DEVICE(0x1002, PCI_ANY_ID),\n\t  .class = PCI_CLASS_ACCELERATOR_PROCESSING << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = CHIP_IP_DISCOVERY },\n\n\t{0, 0, 0}\n};\n\nMODULE_DEVICE_TABLE(pci, pciidlist);\n\nstatic const struct drm_driver amdgpu_kms_driver;\n\nstatic void amdgpu_get_secondary_funcs(struct amdgpu_device *adev)\n{\n\tstruct pci_dev *p = NULL;\n\tint i;\n\n\t/* 0 - GPU\n\t * 1 - audio\n\t * 2 - USB\n\t * 3 - UCSI\n\t */\n\tfor (i = 1; i < 4; i++) {\n\t\tp = pci_get_domain_bus_and_slot(pci_domain_nr(adev->pdev->bus),\n\t\t\t\t\t\tadev->pdev->bus->number, i);\n\t\tif (p) {\n\t\t\tpm_runtime_get_sync(&p->dev);\n\t\t\tpm_runtime_mark_last_busy(&p->dev);\n\t\t\tpm_runtime_put_autosuspend(&p->dev);\n\t\t\tpci_dev_put(p);\n\t\t}\n\t}\n}\n\nstatic int amdgpu_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct drm_device *ddev;\n\tstruct amdgpu_device *adev;\n\tunsigned long flags = ent->driver_data;\n\tint ret, retry = 0, i;\n\tbool supports_atomic = false;\n\n\t/* skip devices which are owned by radeon */\n\tfor (i = 0; i < ARRAY_SIZE(amdgpu_unsupported_pciidlist); i++) {\n\t\tif (amdgpu_unsupported_pciidlist[i] == pdev->device)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (amdgpu_aspm == -1 && !pcie_aspm_enabled(pdev))\n\t\tamdgpu_aspm = 0;\n\n\tif (amdgpu_virtual_display ||\n\t    amdgpu_device_asic_has_dc_support(flags & AMD_ASIC_MASK))\n\t\tsupports_atomic = true;\n\n\tif ((flags & AMD_EXP_HW_SUPPORT) && !amdgpu_exp_hw_support) {\n\t\tDRM_INFO(\"This hardware requires experimental hardware support.\\n\"\n\t\t\t \"See modparam exp_hw_support\\n\");\n\t\treturn -ENODEV;\n\t}\n\t/* differentiate between P10 and P11 asics with the same DID */\n\tif (pdev->device == 0x67FF &&\n\t    (pdev->revision == 0xE3 ||\n\t     pdev->revision == 0xE7 ||\n\t     pdev->revision == 0xF3 ||\n\t     pdev->revision == 0xF7)) {\n\t\tflags &= ~AMD_ASIC_MASK;\n\t\tflags |= CHIP_POLARIS10;\n\t}\n\n\t/* Due to hardware bugs, S/G Display on raven requires a 1:1 IOMMU mapping,\n\t * however, SME requires an indirect IOMMU mapping because the encryption\n\t * bit is beyond the DMA mask of the chip.\n\t */\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT) &&\n\t    ((flags & AMD_ASIC_MASK) == CHIP_RAVEN)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"SME is not compatible with RAVEN\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n#ifdef CONFIG_DRM_AMDGPU_SI\n\tif (!amdgpu_si_support) {\n\t\tswitch (flags & AMD_ASIC_MASK) {\n\t\tcase CHIP_TAHITI:\n\t\tcase CHIP_PITCAIRN:\n\t\tcase CHIP_VERDE:\n\t\tcase CHIP_OLAND:\n\t\tcase CHIP_HAINAN:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"SI support provided by radeon.\\n\");\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Use radeon.si_support=0 amdgpu.si_support=1 to override.\\n\"\n\t\t\t\t);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n#ifdef CONFIG_DRM_AMDGPU_CIK\n\tif (!amdgpu_cik_support) {\n\t\tswitch (flags & AMD_ASIC_MASK) {\n\t\tcase CHIP_KAVERI:\n\t\tcase CHIP_BONAIRE:\n\t\tcase CHIP_HAWAII:\n\t\tcase CHIP_KABINI:\n\t\tcase CHIP_MULLINS:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"CIK support provided by radeon.\\n\");\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Use radeon.cik_support=0 amdgpu.cik_support=1 to override.\\n\"\n\t\t\t\t);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\tadev = devm_drm_dev_alloc(&pdev->dev, &amdgpu_kms_driver, typeof(*adev), ddev);\n\tif (IS_ERR(adev))\n\t\treturn PTR_ERR(adev);\n\n\tadev->dev  = &pdev->dev;\n\tadev->pdev = pdev;\n\tddev = adev_to_drm(adev);\n\n\tif (!supports_atomic)\n\t\tddev->driver_features &= ~DRIVER_ATOMIC;\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_drvdata(pdev, ddev);\n\n\tret = amdgpu_driver_load_kms(adev, flags);\n\tif (ret)\n\t\tgoto err_pci;\n\nretry_init:\n\tret = drm_dev_register(ddev, flags);\n\tif (ret == -EAGAIN && ++retry <= 3) {\n\t\tDRM_INFO(\"retry init %d\\n\", retry);\n\t\t/* Don't request EX mode too frequently which is attacking */\n\t\tmsleep(5000);\n\t\tgoto retry_init;\n\t} else if (ret) {\n\t\tgoto err_pci;\n\t}\n\n\tret = amdgpu_xcp_dev_register(adev, ent);\n\tif (ret)\n\t\tgoto err_pci;\n\n\t/*\n\t * 1. don't init fbdev on hw without DCE\n\t * 2. don't init fbdev if there are no connectors\n\t */\n\tif (adev->mode_info.mode_config_initialized &&\n\t    !list_empty(&adev_to_drm(adev)->mode_config.connector_list)) {\n\t\t/* select 8 bpp console on low vram cards */\n\t\tif (adev->gmc.real_vram_size <= (32*1024*1024))\n\t\t\tdrm_fbdev_generic_setup(adev_to_drm(adev), 8);\n\t\telse\n\t\t\tdrm_fbdev_generic_setup(adev_to_drm(adev), 32);\n\t}\n\n\tret = amdgpu_debugfs_init(adev);\n\tif (ret)\n\t\tDRM_ERROR(\"Creating debugfs files failed (%d).\\n\", ret);\n\n\tif (adev->pm.rpm_mode != AMDGPU_RUNPM_NONE) {\n\t\t/* only need to skip on ATPX */\n\t\tif (amdgpu_device_supports_px(ddev))\n\t\t\tdev_pm_set_driver_flags(ddev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\t\t/* we want direct complete for BOCO */\n\t\tif (amdgpu_device_supports_boco(ddev))\n\t\t\tdev_pm_set_driver_flags(ddev->dev, DPM_FLAG_SMART_PREPARE |\n\t\t\t\t\t\tDPM_FLAG_SMART_SUSPEND |\n\t\t\t\t\t\tDPM_FLAG_MAY_SKIP_RESUME);\n\t\tpm_runtime_use_autosuspend(ddev->dev);\n\t\tpm_runtime_set_autosuspend_delay(ddev->dev, 5000);\n\n\t\tpm_runtime_allow(ddev->dev);\n\n\t\tpm_runtime_mark_last_busy(ddev->dev);\n\t\tpm_runtime_put_autosuspend(ddev->dev);\n\n\t\tpci_wake_from_d3(pdev, TRUE);\n\n\t\tpci_wake_from_d3(pdev, TRUE);\n\n\t\t/*\n\t\t * For runpm implemented via BACO, PMFW will handle the\n\t\t * timing for BACO in and out:\n\t\t *   - put ASIC into BACO state only when both video and\n\t\t *     audio functions are in D3 state.\n\t\t *   - pull ASIC out of BACO state when either video or\n\t\t *     audio function is in D0 state.\n\t\t * Also, at startup, PMFW assumes both functions are in\n\t\t * D0 state.\n\t\t *\n\t\t * So if snd driver was loaded prior to amdgpu driver\n\t\t * and audio function was put into D3 state, there will\n\t\t * be no PMFW-aware D-state transition(D0->D3) on runpm\n\t\t * suspend. Thus the BACO will be not correctly kicked in.\n\t\t *\n\t\t * Via amdgpu_get_secondary_funcs(), the audio dev is put\n\t\t * into D0 state. Then there will be a PMFW-aware D-state\n\t\t * transition(D0->D3) on runpm suspend.\n\t\t */\n\t\tif (amdgpu_device_supports_baco(ddev) &&\n\t\t    !(adev->flags & AMD_IS_APU) &&\n\t\t    (adev->asic_type >= CHIP_NAVI10))\n\t\t\tamdgpu_get_secondary_funcs(adev);\n\t}\n\n\treturn 0;\n\nerr_pci:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void\namdgpu_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tamdgpu_xcp_dev_unplug(adev);\n\tdrm_dev_unplug(dev);\n\n\tif (adev->pm.rpm_mode != AMDGPU_RUNPM_NONE) {\n\t\tpm_runtime_get_sync(dev->dev);\n\t\tpm_runtime_forbid(dev->dev);\n\t}\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 2) &&\n\t    !amdgpu_sriov_vf(adev)) {\n\t\tbool need_to_reset_gpu = false;\n\n\t\tif (adev->gmc.xgmi.num_physical_nodes > 1) {\n\t\t\tstruct amdgpu_hive_info *hive;\n\n\t\t\thive = amdgpu_get_xgmi_hive(adev);\n\t\t\tif (hive->device_remove_count == 0)\n\t\t\t\tneed_to_reset_gpu = true;\n\t\t\thive->device_remove_count++;\n\t\t\tamdgpu_put_xgmi_hive(hive);\n\t\t} else {\n\t\t\tneed_to_reset_gpu = true;\n\t\t}\n\n\t\t/* Workaround for ASICs need to reset SMU.\n\t\t * Called only when the first device is removed.\n\t\t */\n\t\tif (need_to_reset_gpu) {\n\t\t\tstruct amdgpu_reset_context reset_context;\n\n\t\t\tadev->shutdown = true;\n\t\t\tmemset(&reset_context, 0, sizeof(reset_context));\n\t\t\treset_context.method = AMD_RESET_METHOD_NONE;\n\t\t\treset_context.reset_req_dev = adev;\n\t\t\tset_bit(AMDGPU_NEED_FULL_RESET, &reset_context.flags);\n\t\t\tset_bit(AMDGPU_RESET_FOR_DEVICE_REMOVE, &reset_context.flags);\n\t\t\tamdgpu_device_gpu_recover(adev, NULL, &reset_context);\n\t\t}\n\t}\n\n\tamdgpu_driver_unload_kms(dev);\n\n\t/*\n\t * Flush any in flight DMA operations from device.\n\t * Clear the Bus Master Enable bit and then wait on the PCIe Device\n\t * StatusTransactions Pending bit.\n\t */\n\tpci_disable_device(pdev);\n\tpci_wait_for_pending_transaction(pdev);\n}\n\nstatic void\namdgpu_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn;\n\n\t/* if we are running in a VM, make sure the device\n\t * torn down properly on reboot/shutdown.\n\t * unfortunately we can't detect certain\n\t * hypervisors so just do this all the time.\n\t */\n\tif (!amdgpu_passthrough(adev))\n\t\tadev->mp1_state = PP_MP1_STATE_UNLOAD;\n\tamdgpu_device_ip_suspend(adev);\n\tadev->mp1_state = PP_MP1_STATE_NONE;\n}\n\n/**\n * amdgpu_drv_delayed_reset_work_handler - work handler for reset\n *\n * @work: work_struct.\n */\nstatic void amdgpu_drv_delayed_reset_work_handler(struct work_struct *work)\n{\n\tstruct list_head device_list;\n\tstruct amdgpu_device *adev;\n\tint i, r;\n\tstruct amdgpu_reset_context reset_context;\n\n\tmemset(&reset_context, 0, sizeof(reset_context));\n\n\tmutex_lock(&mgpu_info.mutex);\n\tif (mgpu_info.pending_reset == true) {\n\t\tmutex_unlock(&mgpu_info.mutex);\n\t\treturn;\n\t}\n\tmgpu_info.pending_reset = true;\n\tmutex_unlock(&mgpu_info.mutex);\n\n\t/* Use a common context, just need to make sure full reset is done */\n\treset_context.method = AMD_RESET_METHOD_NONE;\n\tset_bit(AMDGPU_NEED_FULL_RESET, &reset_context.flags);\n\n\tfor (i = 0; i < mgpu_info.num_dgpu; i++) {\n\t\tadev = mgpu_info.gpu_ins[i].adev;\n\t\treset_context.reset_req_dev = adev;\n\t\tr = amdgpu_device_pre_asic_reset(adev, &reset_context);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"GPU pre asic reset failed with err, %d for drm dev, %s \",\n\t\t\t\tr, adev_to_drm(adev)->unique);\n\t\t}\n\t\tif (!queue_work(system_unbound_wq, &adev->xgmi_reset_work))\n\t\t\tr = -EALREADY;\n\t}\n\tfor (i = 0; i < mgpu_info.num_dgpu; i++) {\n\t\tadev = mgpu_info.gpu_ins[i].adev;\n\t\tflush_work(&adev->xgmi_reset_work);\n\t\tadev->gmc.xgmi.pending_reset = false;\n\t}\n\n\t/* reset function will rebuild the xgmi hive info , clear it now */\n\tfor (i = 0; i < mgpu_info.num_dgpu; i++)\n\t\tamdgpu_xgmi_remove_device(mgpu_info.gpu_ins[i].adev);\n\n\tINIT_LIST_HEAD(&device_list);\n\n\tfor (i = 0; i < mgpu_info.num_dgpu; i++)\n\t\tlist_add_tail(&mgpu_info.gpu_ins[i].adev->reset_list, &device_list);\n\n\t/* unregister the GPU first, reset function will add them back */\n\tlist_for_each_entry(adev, &device_list, reset_list)\n\t\tamdgpu_unregister_gpu_instance(adev);\n\n\t/* Use a common context, just need to make sure full reset is done */\n\tset_bit(AMDGPU_SKIP_HW_RESET, &reset_context.flags);\n\tr = amdgpu_do_asic_reset(&device_list, &reset_context);\n\n\tif (r) {\n\t\tDRM_ERROR(\"reinit gpus failure\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < mgpu_info.num_dgpu; i++) {\n\t\tadev = mgpu_info.gpu_ins[i].adev;\n\t\tif (!adev->kfd.init_complete)\n\t\t\tamdgpu_amdkfd_device_init(adev);\n\t\tamdgpu_ttm_set_buffer_funcs_status(adev, true);\n\t}\n}\n\nstatic int amdgpu_pmops_prepare(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\n\t/* Return a positive number here so\n\t * DPM_FLAG_SMART_SUSPEND works properly\n\t */\n\tif (amdgpu_device_supports_boco(drm_dev))\n\t\treturn pm_runtime_suspended(dev);\n\n\t/* if we will not support s3 or s2i for the device\n\t *  then skip suspend\n\t */\n\tif (!amdgpu_acpi_is_s0ix_active(adev) &&\n\t    !amdgpu_acpi_is_s3_active(adev))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void amdgpu_pmops_complete(struct device *dev)\n{\n\t/* nothing to do */\n}\n\nstatic int amdgpu_pmops_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\n\tif (amdgpu_acpi_is_s0ix_active(adev))\n\t\tadev->in_s0ix = true;\n\telse if (amdgpu_acpi_is_s3_active(adev))\n\t\tadev->in_s3 = true;\n\tif (!adev->in_s0ix && !adev->in_s3)\n\t\treturn 0;\n\treturn amdgpu_device_suspend(drm_dev, true);\n}\n\nstatic int amdgpu_pmops_suspend_noirq(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\n\tif (amdgpu_acpi_should_gpu_reset(adev))\n\t\treturn amdgpu_asic_reset(adev);\n\n\treturn 0;\n}\n\nstatic int amdgpu_pmops_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\tint r;\n\n\tif (!adev->in_s0ix && !adev->in_s3)\n\t\treturn 0;\n\n\t/* Avoids registers access if device is physically gone */\n\tif (!pci_device_is_present(adev->pdev))\n\t\tadev->no_hw_access = true;\n\n\tr = amdgpu_device_resume(drm_dev, true);\n\tif (amdgpu_acpi_is_s0ix_active(adev))\n\t\tadev->in_s0ix = false;\n\telse\n\t\tadev->in_s3 = false;\n\treturn r;\n}\n\nstatic int amdgpu_pmops_freeze(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\tint r;\n\n\tadev->in_s4 = true;\n\tr = amdgpu_device_suspend(drm_dev, true);\n\tadev->in_s4 = false;\n\tif (r)\n\t\treturn r;\n\n\tif (amdgpu_acpi_should_gpu_reset(adev))\n\t\treturn amdgpu_asic_reset(adev);\n\treturn 0;\n}\n\nstatic int amdgpu_pmops_thaw(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn amdgpu_device_resume(drm_dev, true);\n}\n\nstatic int amdgpu_pmops_poweroff(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn amdgpu_device_suspend(drm_dev, true);\n}\n\nstatic int amdgpu_pmops_restore(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn amdgpu_device_resume(drm_dev, true);\n}\n\nstatic int amdgpu_runtime_idle_check_display(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\n\tif (adev->mode_info.num_crtc) {\n\t\tstruct drm_connector *list_connector;\n\t\tstruct drm_connector_list_iter iter;\n\t\tint ret = 0;\n\n\t\tif (amdgpu_runtime_pm != -2) {\n\t\t\t/* XXX: Return busy if any displays are connected to avoid\n\t\t\t * possible display wakeups after runtime resume due to\n\t\t\t * hotplug events in case any displays were connected while\n\t\t\t * the GPU was in suspend.  Remove this once that is fixed.\n\t\t\t */\n\t\t\tmutex_lock(&drm_dev->mode_config.mutex);\n\t\t\tdrm_connector_list_iter_begin(drm_dev, &iter);\n\t\t\tdrm_for_each_connector_iter(list_connector, &iter) {\n\t\t\t\tif (list_connector->status == connector_status_connected) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrm_connector_list_iter_end(&iter);\n\t\t\tmutex_unlock(&drm_dev->mode_config.mutex);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (adev->dc_enabled) {\n\t\t\tstruct drm_crtc *crtc;\n\n\t\t\tdrm_for_each_crtc(crtc, drm_dev) {\n\t\t\t\tdrm_modeset_lock(&crtc->mutex, NULL);\n\t\t\t\tif (crtc->state->active)\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tdrm_modeset_unlock(&crtc->mutex);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_lock(&drm_dev->mode_config.mutex);\n\t\t\tdrm_modeset_lock(&drm_dev->mode_config.connection_mutex, NULL);\n\n\t\t\tdrm_connector_list_iter_begin(drm_dev, &iter);\n\t\t\tdrm_for_each_connector_iter(list_connector, &iter) {\n\t\t\t\tif (list_connector->dpms ==  DRM_MODE_DPMS_ON) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdrm_connector_list_iter_end(&iter);\n\n\t\t\tdrm_modeset_unlock(&drm_dev->mode_config.connection_mutex);\n\t\t\tmutex_unlock(&drm_dev->mode_config.mutex);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int amdgpu_pmops_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\tint ret, i;\n\n\tif (adev->pm.rpm_mode == AMDGPU_RUNPM_NONE) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tret = amdgpu_runtime_idle_check_display(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t/* wait for all rings to drain before suspending */\n\tfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\n\t\tstruct amdgpu_ring *ring = adev->rings[i];\n\n\t\tif (ring && ring->sched.ready) {\n\t\t\tret = amdgpu_fence_wait_empty(ring);\n\t\t\tif (ret)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tadev->in_runpm = true;\n\tif (amdgpu_device_supports_px(drm_dev))\n\t\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\n\t/*\n\t * By setting mp1_state as PP_MP1_STATE_UNLOAD, MP1 will do some\n\t * proper cleanups and put itself into a state ready for PNP. That\n\t * can address some random resuming failure observed on BOCO capable\n\t * platforms.\n\t * TODO: this may be also needed for PX capable platform.\n\t */\n\tif (amdgpu_device_supports_boco(drm_dev))\n\t\tadev->mp1_state = PP_MP1_STATE_UNLOAD;\n\n\tret = amdgpu_device_suspend(drm_dev, false);\n\tif (ret) {\n\t\tadev->in_runpm = false;\n\t\tif (amdgpu_device_supports_boco(drm_dev))\n\t\t\tadev->mp1_state = PP_MP1_STATE_NONE;\n\t\treturn ret;\n\t}\n\n\tif (amdgpu_device_supports_boco(drm_dev))\n\t\tadev->mp1_state = PP_MP1_STATE_NONE;\n\n\tif (amdgpu_device_supports_px(drm_dev)) {\n\t\t/* Only need to handle PCI state in the driver for ATPX\n\t\t * PCI core handles it for _PR3.\n\t\t */\n\t\tamdgpu_device_cache_pci_state(pdev);\n\t\tpci_disable_device(pdev);\n\t\tpci_ignore_hotplug(pdev);\n\t\tpci_set_power_state(pdev, PCI_D3cold);\n\t\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_DYNAMIC_OFF;\n\t} else if (amdgpu_device_supports_boco(drm_dev)) {\n\t\t/* nothing to do */\n\t} else if (amdgpu_device_supports_baco(drm_dev)) {\n\t\tamdgpu_device_baco_enter(drm_dev);\n\t}\n\n\tdev_dbg(&pdev->dev, \"asic/device is runtime suspended\\n\");\n\n\treturn 0;\n}\n\nstatic int amdgpu_pmops_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\tint ret;\n\n\tif (adev->pm.rpm_mode == AMDGPU_RUNPM_NONE)\n\t\treturn -EINVAL;\n\n\t/* Avoids registers access if device is physically gone */\n\tif (!pci_device_is_present(adev->pdev))\n\t\tadev->no_hw_access = true;\n\n\tif (amdgpu_device_supports_px(drm_dev)) {\n\t\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\n\t\t/* Only need to handle PCI state in the driver for ATPX\n\t\t * PCI core handles it for _PR3.\n\t\t */\n\t\tpci_set_power_state(pdev, PCI_D0);\n\t\tamdgpu_device_load_pci_state(pdev);\n\t\tret = pci_enable_device(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpci_set_master(pdev);\n\t} else if (amdgpu_device_supports_boco(drm_dev)) {\n\t\t/* Only need to handle PCI state in the driver for ATPX\n\t\t * PCI core handles it for _PR3.\n\t\t */\n\t\tpci_set_master(pdev);\n\t} else if (amdgpu_device_supports_baco(drm_dev)) {\n\t\tamdgpu_device_baco_exit(drm_dev);\n\t}\n\tret = amdgpu_device_resume(drm_dev, false);\n\tif (ret) {\n\t\tif (amdgpu_device_supports_px(drm_dev))\n\t\t\tpci_disable_device(pdev);\n\t\treturn ret;\n\t}\n\n\tif (amdgpu_device_supports_px(drm_dev))\n\t\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_ON;\n\tadev->in_runpm = false;\n\treturn 0;\n}\n\nstatic int amdgpu_pmops_runtime_idle(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\t/* we don't want the main rpm_idle to call suspend - we want to autosuspend */\n\tint ret = 1;\n\n\tif (adev->pm.rpm_mode == AMDGPU_RUNPM_NONE) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tret = amdgpu_runtime_idle_check_display(dev);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_autosuspend(dev);\n\treturn ret;\n}\n\nlong amdgpu_drm_ioctl(struct file *filp,\n\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tlong ret;\n\n\tdev = file_priv->minor->dev;\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = drm_ioctl(filp, cmd, arg);\n\n\tpm_runtime_mark_last_busy(dev->dev);\nout:\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops amdgpu_pm_ops = {\n\t.prepare = amdgpu_pmops_prepare,\n\t.complete = amdgpu_pmops_complete,\n\t.suspend = amdgpu_pmops_suspend,\n\t.suspend_noirq = amdgpu_pmops_suspend_noirq,\n\t.resume = amdgpu_pmops_resume,\n\t.freeze = amdgpu_pmops_freeze,\n\t.thaw = amdgpu_pmops_thaw,\n\t.poweroff = amdgpu_pmops_poweroff,\n\t.restore = amdgpu_pmops_restore,\n\t.runtime_suspend = amdgpu_pmops_runtime_suspend,\n\t.runtime_resume = amdgpu_pmops_runtime_resume,\n\t.runtime_idle = amdgpu_pmops_runtime_idle,\n};\n\nstatic int amdgpu_flush(struct file *f, fl_owner_t id)\n{\n\tstruct drm_file *file_priv = f->private_data;\n\tstruct amdgpu_fpriv *fpriv = file_priv->driver_priv;\n\tlong timeout = MAX_WAIT_SCHED_ENTITY_Q_EMPTY;\n\n\ttimeout = amdgpu_ctx_mgr_entity_flush(&fpriv->ctx_mgr, timeout);\n\ttimeout = amdgpu_vm_wait_idle(&fpriv->vm, timeout);\n\n\treturn timeout >= 0 ? 0 : timeout;\n}\n\nstatic const struct file_operations amdgpu_driver_kms_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.flush = amdgpu_flush,\n\t.release = drm_release,\n\t.unlocked_ioctl = amdgpu_drm_ioctl,\n\t.mmap = drm_gem_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = amdgpu_kms_compat_ioctl,\n#endif\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = drm_show_fdinfo,\n#endif\n};\n\nint amdgpu_file_to_fpriv(struct file *filp, struct amdgpu_fpriv **fpriv)\n{\n\tstruct drm_file *file;\n\n\tif (!filp)\n\t\treturn -EINVAL;\n\n\tif (filp->f_op != &amdgpu_driver_kms_fops)\n\t\treturn -EINVAL;\n\n\tfile = filp->private_data;\n\t*fpriv = file->driver_priv;\n\treturn 0;\n}\n\nconst struct drm_ioctl_desc amdgpu_ioctls_kms[] = {\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_CREATE, amdgpu_gem_create_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_CTX, amdgpu_ctx_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_VM, amdgpu_vm_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_SCHED, amdgpu_sched_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_BO_LIST, amdgpu_bo_list_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_FENCE_TO_HANDLE, amdgpu_cs_fence_to_handle_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\t/* KMS */\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_MMAP, amdgpu_gem_mmap_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_WAIT_IDLE, amdgpu_gem_wait_idle_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_CS, amdgpu_cs_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_INFO, amdgpu_info_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_WAIT_CS, amdgpu_cs_wait_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_WAIT_FENCES, amdgpu_cs_wait_fences_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_METADATA, amdgpu_gem_metadata_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_VA, amdgpu_gem_va_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_OP, amdgpu_gem_op_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(AMDGPU_GEM_USERPTR, amdgpu_gem_userptr_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n};\n\nstatic const struct drm_driver amdgpu_kms_driver = {\n\t.driver_features =\n\t    DRIVER_ATOMIC |\n\t    DRIVER_GEM |\n\t    DRIVER_RENDER | DRIVER_MODESET | DRIVER_SYNCOBJ |\n\t    DRIVER_SYNCOBJ_TIMELINE,\n\t.open = amdgpu_driver_open_kms,\n\t.postclose = amdgpu_driver_postclose_kms,\n\t.lastclose = amdgpu_driver_lastclose_kms,\n\t.ioctls = amdgpu_ioctls_kms,\n\t.num_ioctls = ARRAY_SIZE(amdgpu_ioctls_kms),\n\t.dumb_create = amdgpu_mode_dumb_create,\n\t.dumb_map_offset = amdgpu_mode_dumb_mmap,\n\t.fops = &amdgpu_driver_kms_fops,\n\t.release = &amdgpu_driver_release_kms,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = amdgpu_show_fdinfo,\n#endif\n\n\t.gem_prime_import = amdgpu_gem_prime_import,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = KMS_DRIVER_MAJOR,\n\t.minor = KMS_DRIVER_MINOR,\n\t.patchlevel = KMS_DRIVER_PATCHLEVEL,\n};\n\nconst struct drm_driver amdgpu_partition_driver = {\n\t.driver_features =\n\t    DRIVER_GEM | DRIVER_RENDER | DRIVER_SYNCOBJ |\n\t    DRIVER_SYNCOBJ_TIMELINE,\n\t.open = amdgpu_driver_open_kms,\n\t.postclose = amdgpu_driver_postclose_kms,\n\t.lastclose = amdgpu_driver_lastclose_kms,\n\t.ioctls = amdgpu_ioctls_kms,\n\t.num_ioctls = ARRAY_SIZE(amdgpu_ioctls_kms),\n\t.dumb_create = amdgpu_mode_dumb_create,\n\t.dumb_map_offset = amdgpu_mode_dumb_mmap,\n\t.fops = &amdgpu_driver_kms_fops,\n\t.release = &amdgpu_driver_release_kms,\n\n\t.gem_prime_import = amdgpu_gem_prime_import,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = KMS_DRIVER_MAJOR,\n\t.minor = KMS_DRIVER_MINOR,\n\t.patchlevel = KMS_DRIVER_PATCHLEVEL,\n};\n\nstatic struct pci_error_handlers amdgpu_pci_err_handler = {\n\t.error_detected\t= amdgpu_pci_error_detected,\n\t.mmio_enabled\t= amdgpu_pci_mmio_enabled,\n\t.slot_reset\t= amdgpu_pci_slot_reset,\n\t.resume\t\t= amdgpu_pci_resume,\n};\n\nstatic const struct attribute_group *amdgpu_sysfs_groups[] = {\n\t&amdgpu_vram_mgr_attr_group,\n\t&amdgpu_gtt_mgr_attr_group,\n\t&amdgpu_flash_attr_group,\n\tNULL,\n};\n\nstatic struct pci_driver amdgpu_kms_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pciidlist,\n\t.probe = amdgpu_pci_probe,\n\t.remove = amdgpu_pci_remove,\n\t.shutdown = amdgpu_pci_shutdown,\n\t.driver.pm = &amdgpu_pm_ops,\n\t.err_handler = &amdgpu_pci_err_handler,\n\t.dev_groups = amdgpu_sysfs_groups,\n};\n\nstatic int __init amdgpu_init(void)\n{\n\tint r;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -EINVAL;\n\n\tr = amdgpu_sync_init();\n\tif (r)\n\t\tgoto error_sync;\n\n\tr = amdgpu_fence_slab_init();\n\tif (r)\n\t\tgoto error_fence;\n\n\tDRM_INFO(\"amdgpu kernel modesetting enabled.\\n\");\n\tamdgpu_register_atpx_handler();\n\tamdgpu_acpi_detect();\n\n\t/* Ignore KFD init failures. Normal when CONFIG_HSA_AMD is not set. */\n\tamdgpu_amdkfd_init();\n\n\t/* let modprobe override vga console setting */\n\treturn pci_register_driver(&amdgpu_kms_pci_driver);\n\nerror_fence:\n\tamdgpu_sync_fini();\n\nerror_sync:\n\treturn r;\n}\n\nstatic void __exit amdgpu_exit(void)\n{\n\tamdgpu_amdkfd_fini();\n\tpci_unregister_driver(&amdgpu_kms_pci_driver);\n\tamdgpu_unregister_atpx_handler();\n\tamdgpu_acpi_release();\n\tamdgpu_sync_fini();\n\tamdgpu_fence_slab_fini();\n\tmmu_notifier_synchronize();\n\tamdgpu_xcp_drv_release();\n}\n\nmodule_init(amdgpu_init);\nmodule_exit(amdgpu_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}