{
  "module_name": "psp_v13_0_4.c",
  "hash_id": "ae64a2197121e19082682480abce1f81b0d747fa2c5e765115178f76b0fddc8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/psp_v13_0_4.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_psp.h\"\n#include \"amdgpu_ucode.h\"\n#include \"soc15_common.h\"\n#include \"psp_v13_0_4.h\"\n\n#include \"mp/mp_13_0_4_offset.h\"\n#include \"mp/mp_13_0_4_sh_mask.h\"\n\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_4_toc.bin\");\nMODULE_FIRMWARE(\"amdgpu/psp_13_0_4_ta.bin\");\n\nstatic int psp_v13_0_4_init_microcode(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tchar ucode_prefix[30];\n\tint err = 0;\n\n\tamdgpu_ucode_ip_version_decode(adev, MP0_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tswitch (adev->ip_versions[MP0_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 4):\n\t\terr = psp_init_toc_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = psp_init_ta_microcode(psp, ucode_prefix);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\nstatic bool psp_v13_0_4_is_sos_alive(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\tuint32_t sol_reg;\n\n\tsol_reg = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_81);\n\n\treturn sol_reg != 0x0;\n}\n\nstatic int psp_v13_0_4_wait_for_bootloader(struct psp_context *psp)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tint ret;\n\tint retry_loop;\n\n\tfor (retry_loop = 0; retry_loop < 10; retry_loop++) {\n\t\t \n\t\tret = psp_wait_for(psp,\n\t\t\t\t   SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_35),\n\t\t\t\t   0x80000000,\n\t\t\t\t   0x80000000,\n\t\t\t\t   false);\n\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_4_bootloader_load_component(struct psp_context  \t*psp,\n\t\t\t\t\t       struct psp_bin_desc \t*bin_desc,\n\t\t\t\t\t       enum psp_bootloader_cmd  bl_cmd)\n{\n\tint ret;\n\tuint32_t psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v13_0_4_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v13_0_4_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\n\t \n\tmemcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = bl_cmd;\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\tret = psp_v13_0_4_wait_for_bootloader(psp);\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_4_bootloader_load_kdb(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->kdb, PSP_BL__LOAD_KEY_DATABASE);\n}\n\nstatic int psp_v13_0_4_bootloader_load_spl(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->kdb, PSP_BL__LOAD_TOS_SPL_TABLE);\n}\n\nstatic int psp_v13_0_4_bootloader_load_sysdrv(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->sys, PSP_BL__LOAD_SYSDRV);\n}\n\nstatic int psp_v13_0_4_bootloader_load_soc_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->soc_drv, PSP_BL__LOAD_SOCDRV);\n}\n\nstatic int psp_v13_0_4_bootloader_load_intf_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->intf_drv, PSP_BL__LOAD_INTFDRV);\n}\n\nstatic int psp_v13_0_4_bootloader_load_dbg_drv(struct psp_context *psp)\n{\n\treturn psp_v13_0_4_bootloader_load_component(psp, &psp->dbg_drv, PSP_BL__LOAD_DBGDRV);\n}\n\nstatic int psp_v13_0_4_bootloader_load_sos(struct psp_context *psp)\n{\n\tint ret;\n\tunsigned int psp_gfxdrv_command_reg = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\t \n\tif (psp_v13_0_4_is_sos_alive(psp))\n\t\treturn 0;\n\n\tret = psp_v13_0_4_wait_for_bootloader(psp);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(psp->fw_pri_buf, 0, PSP_1_MEG);\n\n\t \n\tmemcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes);\n\n\t \n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_36,\n\t       (uint32_t)(psp->fw_pri_mc_addr >> 20));\n\tpsp_gfxdrv_command_reg = PSP_BL__LOAD_SOSDRV;\n\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_35,\n\t       psp_gfxdrv_command_reg);\n\n\t \n\tmdelay(20);\n\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_81),\n\t\t\t   RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_81),\n\t\t\t   0, true);\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_4_ring_stop(struct psp_context *psp,\n\t\t\t       enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_DESTROY_GPCOM_RING);\n\t\t \n\t\tmdelay(20);\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t} else {\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_64,\n\t\t\t     GFX_CTRL_CMD_ID_DESTROY_RINGS);\n\t\t \n\t\tmdelay(20);\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_4_ring_create(struct psp_context *psp,\n\t\t\t\t enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tunsigned int psp_ring_reg = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tret = psp_v13_0_4_ring_stop(psp, ring_type);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"psp_v13_0_ring_stop_sriov failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_103, psp_ring_reg);\n\n\t\t \n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_INIT_GPCOM_RING);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_101),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\n\t} else {\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x80000000, false);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to wait for trust OS ready for ring creation\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tpsp_ring_reg = lower_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_69, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = upper_32_bits(ring->ring_mem_mc_addr);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_70, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring->ring_size;\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_71, psp_ring_reg);\n\t\t \n\t\tpsp_ring_reg = ring_type;\n\t\tpsp_ring_reg = psp_ring_reg << 16;\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_64, psp_ring_reg);\n\n\t\t \n\t\tmdelay(20);\n\n\t\t \n\t\tret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, regMP0_SMN_C2PMSG_64),\n\t\t\t\t   0x80000000, 0x8000FFFF, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int psp_v13_0_4_ring_destroy(struct psp_context *psp,\n\t\t\t\t  enum psp_ring_type ring_type)\n{\n\tint ret = 0;\n\tstruct psp_ring *ring = &psp->km_ring;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tret = psp_v13_0_4_ring_stop(psp, ring_type);\n\tif (ret)\n\t\tDRM_ERROR(\"Fail to stop psp ring\\n\");\n\n\tamdgpu_bo_free_kernel(&adev->firmware.rbuf,\n\t\t\t      &ring->ring_mem_mc_addr,\n\t\t\t      (void **)&ring->ring_mem);\n\n\treturn ret;\n}\n\nstatic uint32_t psp_v13_0_4_ring_get_wptr(struct psp_context *psp)\n{\n\tuint32_t data;\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\tdata = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102);\n\telse\n\t\tdata = RREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67);\n\n\treturn data;\n}\n\nstatic void psp_v13_0_4_ring_set_wptr(struct psp_context *psp, uint32_t value)\n{\n\tstruct amdgpu_device *adev = psp->adev;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_102, value);\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_101,\n\t\t\t     GFX_CTRL_CMD_ID_CONSUME_CMD);\n\t} else\n\t\tWREG32_SOC15(MP0, 0, regMP0_SMN_C2PMSG_67, value);\n}\n\nstatic const struct psp_funcs psp_v13_0_4_funcs = {\n\t.init_microcode = psp_v13_0_4_init_microcode,\n\t.bootloader_load_kdb = psp_v13_0_4_bootloader_load_kdb,\n\t.bootloader_load_spl = psp_v13_0_4_bootloader_load_spl,\n\t.bootloader_load_sysdrv = psp_v13_0_4_bootloader_load_sysdrv,\n\t.bootloader_load_soc_drv = psp_v13_0_4_bootloader_load_soc_drv,\n\t.bootloader_load_intf_drv = psp_v13_0_4_bootloader_load_intf_drv,\n\t.bootloader_load_dbg_drv = psp_v13_0_4_bootloader_load_dbg_drv,\n\t.bootloader_load_sos = psp_v13_0_4_bootloader_load_sos,\n\t.ring_create = psp_v13_0_4_ring_create,\n\t.ring_stop = psp_v13_0_4_ring_stop,\n\t.ring_destroy = psp_v13_0_4_ring_destroy,\n\t.ring_get_wptr = psp_v13_0_4_ring_get_wptr,\n\t.ring_set_wptr = psp_v13_0_4_ring_set_wptr,\n};\n\nvoid psp_v13_0_4_set_psp_funcs(struct psp_context *psp)\n{\n\tpsp->funcs = &psp_v13_0_4_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}