{
  "module_name": "nbio_v7_9.c",
  "hash_id": "11af4f297729206864322da9968125c940e02757107b2d5854463cdcb99094be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/nbio_v7_9.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"nbio_v7_9.h\"\n#include \"amdgpu_ras.h\"\n\n#include \"nbio/nbio_7_9_0_offset.h\"\n#include \"nbio/nbio_7_9_0_sh_mask.h\"\n#include \"ivsrcid/nbio/irqsrcs_nbif_7_4.h\"\n#include <uapi/linux/kfd_ioctl.h>\n\n#define NPS_MODE_MASK 0x000000FFL\n\n \n#define smnPCIEP_NAK_COUNTER 0x1A340218\n\n#define smnPCIE_PERF_CNTL_TXCLK3\t\t0x1A38021c\n#define smnPCIE_PERF_CNTL_TXCLK7\t\t0x1A380888\n#define smnPCIE_PERF_COUNT_CNTL\t\t\t0x1A380200\n#define smnPCIE_PERF_COUNT0_TXCLK3\t\t0x1A380220\n#define smnPCIE_PERF_COUNT0_TXCLK7\t\t0x1A38088C\n#define smnPCIE_PERF_COUNT0_UPVAL_TXCLK3\t0x1A3808F8\n#define smnPCIE_PERF_COUNT0_UPVAL_TXCLK7\t0x1A380918\n\n\nstatic void nbio_v7_9_remap_hdp_registers(struct amdgpu_device *adev)\n{\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_MEM_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL);\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_REMAP_HDP_REG_FLUSH_CNTL,\n\t\tadev->rmmio_remap.reg_offset + KFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL);\n}\n\nstatic u32 nbio_v7_9_get_rev_id(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_SOC15(NBIO, 0, regRCC_STRAP0_RCC_DEV0_EPF0_STRAP0);\n\ttmp = REG_GET_FIELD(tmp, RCC_STRAP0_RCC_DEV0_EPF0_STRAP0, STRAP_ATI_REV_ID_DEV0_F0);\n\n\treturn tmp;\n}\n\nstatic void nbio_v7_9_mc_access_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN,\n\t\t\tBIF_BX0_BIF_FB_EN__FB_READ_EN_MASK | BIF_BX0_BIF_FB_EN__FB_WRITE_EN_MASK);\n\telse\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_FB_EN, 0);\n}\n\nstatic u32 nbio_v7_9_get_memsize(struct amdgpu_device *adev)\n{\n\treturn RREG32_SOC15(NBIO, 0, regRCC_DEV0_EPF0_RCC_CONFIG_MEMSIZE);\n}\n\nstatic void nbio_v7_9_sdma_doorbell_range(struct amdgpu_device *adev, int instance,\n\t\t\tbool use_doorbell, int doorbell_index, int doorbell_size)\n{\n\tu32 doorbell_range = 0, doorbell_ctrl = 0;\n\tint aid_id, dev_inst;\n\n\tdev_inst = GET_INST(SDMA0, instance);\n\taid_id = adev->sdma.instance[instance].aid_id;\n\n\tif (use_doorbell == false)\n\t\treturn;\n\n\tdoorbell_range =\n\t\tREG_SET_FIELD(doorbell_range, DOORBELL0_CTRL_ENTRY_0,\n\t\t\tBIF_DOORBELL0_RANGE_OFFSET_ENTRY, doorbell_index);\n\tdoorbell_range =\n\t\tREG_SET_FIELD(doorbell_range, DOORBELL0_CTRL_ENTRY_0,\n\t\t\tBIF_DOORBELL0_RANGE_SIZE_ENTRY, doorbell_size);\n\tdoorbell_ctrl =\n\t\tREG_SET_FIELD(doorbell_ctrl, S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\tS2A_DOORBELL_PORT1_ENABLE, 1);\n\tdoorbell_ctrl =\n\t\tREG_SET_FIELD(doorbell_ctrl, S2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\tS2A_DOORBELL_PORT1_RANGE_SIZE, doorbell_size);\n\n\tswitch (dev_inst % adev->sdma.num_inst_per_aid) {\n\tcase 0:\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_1,\n\t\t\t4 * aid_id, doorbell_range);\n\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0xe);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0xe);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE,\n\t\t\t\t\t0x1);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\taid_id, doorbell_ctrl);\n\t\tbreak;\n\tcase 1:\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_2,\n\t\t\t4 * aid_id, doorbell_range);\n\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0x8);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0x8);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE,\n\t\t\t\t\t0x2);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_2_CTRL,\n\t\t\taid_id, doorbell_ctrl);\n\t\tbreak;\n\tcase 2:\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_3,\n\t\t\t4 * aid_id, doorbell_range);\n\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0x9);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0x9);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE,\n\t\t\t\t\t0x8);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_5_CTRL,\n\t\t\taid_id, doorbell_ctrl);\n\t\tbreak;\n\tcase 3:\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_4,\n\t\t\t4 * aid_id, doorbell_range);\n\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0xa);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0xa);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE,\n\t\t\t\t\t0x9);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_6_CTRL,\n\t\t\taid_id, doorbell_ctrl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic void nbio_v7_9_vcn_doorbell_range(struct amdgpu_device *adev, bool use_doorbell,\n\t\t\t\t\t int doorbell_index, int instance)\n{\n\tu32 doorbell_range = 0, doorbell_ctrl = 0;\n\tu32 aid_id = instance;\n\n\tif (use_doorbell) {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_OFFSET_ENTRY,\n\t\t\t\tdoorbell_index);\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_SIZE_ENTRY,\n\t\t\t\t0x9);\n\t\tif (aid_id)\n\t\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\t\tDOORBELL0_FENCE_ENABLE_ENTRY,\n\t\t\t\t\t0x4);\n\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_ENABLE, 1);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0x4);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0x4);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_SIZE, 0x9);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE, 0x4);\n\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_17,\n\t\t\t\t\taid_id, doorbell_range);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\taid_id, doorbell_ctrl);\n\t} else {\n\t\tdoorbell_range = REG_SET_FIELD(doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_SIZE_ENTRY, 0);\n\t\tdoorbell_ctrl = REG_SET_FIELD(doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_SIZE, 0);\n\n\t\tWREG32_SOC15_OFFSET(NBIO, 0, regDOORBELL0_CTRL_ENTRY_17,\n\t\t\t\t\taid_id, doorbell_range);\n\t\tWREG32_SOC15_EXT(NBIO, aid_id, regS2A_DOORBELL_ENTRY_4_CTRL,\n\t\t\t\taid_id, doorbell_ctrl);\n\t}\n}\n\nstatic void nbio_v7_9_enable_doorbell_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\t \n\tWREG32_SOC15(NBIO, 0, regBIFC_DOORBELL_ACCESS_EN_PF, 0xfffff);\n\tWREG32_FIELD15_PREREG(NBIO, 0, RCC_DEV0_EPF0_RCC_DOORBELL_APER_EN,\n\t\t\tBIF_DOORBELL_APER_EN, enable ? 1 : 0);\n}\n\nstatic void nbio_v7_9_enable_doorbell_selfring_aperture(struct amdgpu_device *adev,\n\t\t\t\t\t\t\tbool enable)\n{\n\tu32 tmp = 0;\n\n\tif (enable) {\n\t\ttmp = REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_EN, 1) |\n\t\t      REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_MODE, 1) |\n\t\t      REG_SET_FIELD(tmp, BIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL,\n\t\t\t\t    DOORBELL_SELFRING_GPA_APER_SIZE, 0);\n\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_LOW,\n\t\t\t     lower_32_bits(adev->doorbell.base));\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_BASE_HIGH,\n\t\t\t     upper_32_bits(adev->doorbell.base));\n\t}\n\n\tWREG32_SOC15(NBIO, 0, regBIF_BX_PF0_DOORBELL_SELFRING_GPA_APER_CNTL, tmp);\n}\n\nstatic void nbio_v7_9_ih_doorbell_range(struct amdgpu_device *adev,\n\t\t\t\t\tbool use_doorbell, int doorbell_index)\n{\n\tu32 ih_doorbell_range = 0, ih_doorbell_ctrl = 0;\n\n\tif (use_doorbell) {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_OFFSET_ENTRY,\n\t\t\t\tdoorbell_index);\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_SIZE_ENTRY,\n\t\t\t\t0x8);\n\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_ENABLE, 1);\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_AWID, 0);\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_OFFSET, 0);\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_SIZE, 0x8);\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_AWADDR_31_28_VALUE, 0);\n\t} else {\n\t\tih_doorbell_range = REG_SET_FIELD(ih_doorbell_range,\n\t\t\t\tDOORBELL0_CTRL_ENTRY_0,\n\t\t\t\tBIF_DOORBELL0_RANGE_SIZE_ENTRY, 0);\n\t\tih_doorbell_ctrl = REG_SET_FIELD(ih_doorbell_ctrl,\n\t\t\t\tS2A_DOORBELL_ENTRY_1_CTRL,\n\t\t\t\tS2A_DOORBELL_PORT1_RANGE_SIZE, 0);\n\t}\n\n\tWREG32_SOC15(NBIO, 0, regDOORBELL0_CTRL_ENTRY_0, ih_doorbell_range);\n\tWREG32_SOC15(NBIO, 0, regS2A_DOORBELL_ENTRY_3_CTRL, ih_doorbell_ctrl);\n}\n\n\nstatic void nbio_v7_9_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n}\n\nstatic void nbio_v7_9_update_medium_grain_light_sleep(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n}\n\nstatic void nbio_v7_9_get_clockgating_state(struct amdgpu_device *adev,\n\t\t\t\t\t    u64 *flags)\n{\n}\n\nstatic void nbio_v7_9_ih_control(struct amdgpu_device *adev)\n{\n\tu32 interrupt_cntl;\n\n\t \n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL2, adev->dummy_page_addr >> 8);\n\tinterrupt_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl =\n\t\tREG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL, IH_DUMMY_RD_OVERRIDE, 0);\n\t \n\tinterrupt_cntl =\n\t\tREG_SET_FIELD(interrupt_cntl, BIF_BX0_INTERRUPT_CNTL, IH_REQ_NONSNOOP_EN, 0);\n\tWREG32_SOC15(NBIO, 0, regBIF_BX0_INTERRUPT_CNTL, interrupt_cntl);\n}\n\nstatic u32 nbio_v7_9_get_hdp_flush_req_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_REQ);\n}\n\nstatic u32 nbio_v7_9_get_hdp_flush_done_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX_PF0_GPU_HDP_FLUSH_DONE);\n}\n\nstatic u32 nbio_v7_9_get_pcie_index_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX0_PCIE_INDEX2);\n}\n\nstatic u32 nbio_v7_9_get_pcie_data_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX0_PCIE_DATA2);\n}\n\nstatic u32 nbio_v7_9_get_pcie_index_hi_offset(struct amdgpu_device *adev)\n{\n\treturn SOC15_REG_OFFSET(NBIO, 0, regBIF_BX0_PCIE_INDEX2_HI);\n}\n\nconst struct nbio_hdp_flush_reg nbio_v7_9_hdp_flush_reg = {\n\t.ref_and_mask_cp0 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP0_MASK,\n\t.ref_and_mask_cp1 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP1_MASK,\n\t.ref_and_mask_cp2 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP2_MASK,\n\t.ref_and_mask_cp3 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP3_MASK,\n\t.ref_and_mask_cp4 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP4_MASK,\n\t.ref_and_mask_cp5 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP5_MASK,\n\t.ref_and_mask_cp6 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP6_MASK,\n\t.ref_and_mask_cp7 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP7_MASK,\n\t.ref_and_mask_cp8 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP8_MASK,\n\t.ref_and_mask_cp9 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__CP9_MASK,\n\t.ref_and_mask_sdma0 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__SDMA0_MASK,\n\t.ref_and_mask_sdma1 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__SDMA1_MASK,\n\t.ref_and_mask_sdma2 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG0_MASK,\n\t.ref_and_mask_sdma3 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG1_MASK,\n\t.ref_and_mask_sdma4 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG2_MASK,\n\t.ref_and_mask_sdma5 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG3_MASK,\n\t.ref_and_mask_sdma6 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG4_MASK,\n\t.ref_and_mask_sdma7 = BIF_BX_PF0_GPU_HDP_FLUSH_DONE__RSVD_ENG5_MASK,\n};\n\nstatic void nbio_v7_9_enable_doorbell_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tWREG32_FIELD15_PREREG(NBIO, 0, BIF_BX0_BIF_DOORBELL_INT_CNTL,\n\t\t\t      DOORBELL_INTERRUPT_DISABLE, enable ? 0 : 1);\n}\n\nstatic int nbio_v7_9_get_compute_partition_mode(struct amdgpu_device *adev)\n{\n\tu32 tmp, px;\n\n\ttmp = RREG32_SOC15(NBIO, 0, regBIF_BX_PF0_PARTITION_COMPUTE_STATUS);\n\tpx = REG_GET_FIELD(tmp, BIF_BX_PF0_PARTITION_COMPUTE_STATUS,\n\t\t\t   PARTITION_MODE);\n\n\treturn px;\n}\n\nstatic u32 nbio_v7_9_get_memory_partition_mode(struct amdgpu_device *adev,\n\t\t\t\t\t       u32 *supp_modes)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_SOC15(NBIO, 0, regBIF_BX_PF0_PARTITION_MEM_STATUS);\n\ttmp = REG_GET_FIELD(tmp, BIF_BX_PF0_PARTITION_MEM_STATUS, NPS_MODE);\n\n\tif (supp_modes) {\n\t\t*supp_modes =\n\t\t\tRREG32_SOC15(NBIO, 0, regBIF_BX_PF0_PARTITION_MEM_CAP);\n\t}\n\n\treturn ffs(tmp);\n}\n\nstatic void nbio_v7_9_init_registers(struct amdgpu_device *adev)\n{\n\tu32 inst_mask;\n\tint i;\n\n\tWREG32_SOC15(NBIO, 0, regXCC_DOORBELL_FENCE,\n\t\t0xff & ~(adev->gfx.xcc_mask));\n\n\tWREG32_SOC15(NBIO, 0, regBIFC_GFX_INT_MONITOR_MASK, 0x7ff);\n\n\tinst_mask = adev->aid_mask & ~1U;\n\tfor_each_inst(i, inst_mask) {\n\t\tWREG32_SOC15_EXT(NBIO, i, regXCC_DOORBELL_FENCE, i,\n\t\t\tXCC_DOORBELL_FENCE__SHUB_SLV_MODE_MASK);\n\n\t}\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tu32 baco_cntl;\n\t\tfor_each_inst(i, adev->aid_mask) {\n\t\t\tbaco_cntl = RREG32_SOC15(NBIO, i, regBIF_BX0_BACO_CNTL);\n\t\t\tif (baco_cntl & (BIF_BX0_BACO_CNTL__BACO_DUMMY_EN_MASK |\n\t\t\t\t\t BIF_BX0_BACO_CNTL__BACO_EN_MASK)) {\n\t\t\t\tbaco_cntl &= ~(\n\t\t\t\t\tBIF_BX0_BACO_CNTL__BACO_DUMMY_EN_MASK |\n\t\t\t\t\tBIF_BX0_BACO_CNTL__BACO_EN_MASK);\n\t\t\t\tdev_dbg(adev->dev,\n\t\t\t\t\t\"Unsetting baco dummy mode %x\",\n\t\t\t\t\tbaco_cntl);\n\t\t\t\tWREG32_SOC15(NBIO, i, regBIF_BX0_BACO_CNTL,\n\t\t\t\t\t     baco_cntl);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic u64 nbio_v7_9_get_pcie_replay_count(struct amdgpu_device *adev)\n{\n\tu32 val, nak_r, nak_g;\n\n\tif (adev->flags & AMD_IS_APU)\n\t\treturn 0;\n\n\t \n\tval = RREG32_PCIE(smnPCIEP_NAK_COUNTER);\n\tnak_r = val & 0xFFFF;\n\tnak_g = val >> 16;\n\n\t \n\treturn (nak_r + nak_g);\n}\n\nstatic void nbio_v7_9_get_pcie_usage(struct amdgpu_device *adev, uint64_t *count0,\n\t\t\t\t     uint64_t *count1)\n{\n\tuint32_t perfctrrx = 0;\n\tuint32_t perfctrtx = 0;\n\n\t \n\tif (adev->flags & AMD_IS_APU)\n\t\treturn;\n\n\t \n\t \n\t \n\t \n\t \n\tperfctrrx = REG_SET_FIELD(perfctrrx, PCIE_PERF_CNTL_TXCLK3, EVENT0_SEL, 40);\n\tperfctrtx = REG_SET_FIELD(perfctrtx, PCIE_PERF_CNTL_TXCLK7, EVENT0_SEL, 2);\n\n\t \n\tWREG32_PCIE(smnPCIE_PERF_CNTL_TXCLK3, perfctrrx);\n\tWREG32_PCIE(smnPCIE_PERF_CNTL_TXCLK7, perfctrtx);\n\n\t \n\tWREG32_PCIE(smnPCIE_PERF_COUNT_CNTL, 0x00000006);\n\n\t \n\tWREG32_PCIE(smnPCIE_PERF_COUNT_CNTL, 0x00000001);\n\n\tmsleep(1000);\n\n\t \n\tWREG32_PCIE(smnPCIE_PERF_COUNT_CNTL, 0x00000006);\n\n\t \n\t*count0 = RREG32_PCIE(smnPCIE_PERF_COUNT0_TXCLK3) |\n\t\t  ((uint64_t)RREG32_PCIE(smnPCIE_PERF_COUNT0_UPVAL_TXCLK3) << 32);\n\t*count1 = RREG32_PCIE(smnPCIE_PERF_COUNT0_TXCLK7) |\n\t\t  ((uint64_t)RREG32_PCIE(smnPCIE_PERF_COUNT0_UPVAL_TXCLK7) << 32);\n}\n\nconst struct amdgpu_nbio_funcs nbio_v7_9_funcs = {\n\t.get_hdp_flush_req_offset = nbio_v7_9_get_hdp_flush_req_offset,\n\t.get_hdp_flush_done_offset = nbio_v7_9_get_hdp_flush_done_offset,\n\t.get_pcie_index_offset = nbio_v7_9_get_pcie_index_offset,\n\t.get_pcie_data_offset = nbio_v7_9_get_pcie_data_offset,\n\t.get_pcie_index_hi_offset = nbio_v7_9_get_pcie_index_hi_offset,\n\t.get_rev_id = nbio_v7_9_get_rev_id,\n\t.mc_access_enable = nbio_v7_9_mc_access_enable,\n\t.get_memsize = nbio_v7_9_get_memsize,\n\t.sdma_doorbell_range = nbio_v7_9_sdma_doorbell_range,\n\t.vcn_doorbell_range = nbio_v7_9_vcn_doorbell_range,\n\t.enable_doorbell_aperture = nbio_v7_9_enable_doorbell_aperture,\n\t.enable_doorbell_selfring_aperture = nbio_v7_9_enable_doorbell_selfring_aperture,\n\t.ih_doorbell_range = nbio_v7_9_ih_doorbell_range,\n\t.enable_doorbell_interrupt = nbio_v7_9_enable_doorbell_interrupt,\n\t.update_medium_grain_clock_gating = nbio_v7_9_update_medium_grain_clock_gating,\n\t.update_medium_grain_light_sleep = nbio_v7_9_update_medium_grain_light_sleep,\n\t.get_clockgating_state = nbio_v7_9_get_clockgating_state,\n\t.ih_control = nbio_v7_9_ih_control,\n\t.remap_hdp_registers = nbio_v7_9_remap_hdp_registers,\n\t.get_compute_partition_mode = nbio_v7_9_get_compute_partition_mode,\n\t.get_memory_partition_mode = nbio_v7_9_get_memory_partition_mode,\n\t.init_registers = nbio_v7_9_init_registers,\n\t.get_pcie_replay_count = nbio_v7_9_get_pcie_replay_count,\n\t.get_pcie_usage = nbio_v7_9_get_pcie_usage,\n};\n\nstatic void nbio_v7_9_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\tvoid *ras_error_status)\n{\n\treturn;\n}\n\nstatic void nbio_v7_9_handle_ras_controller_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_intr_cntl;\n\tstruct ras_manager *obj = amdgpu_ras_find_obj(adev, adev->nbio.ras_if);\n\tstruct ras_err_data err_data = {0, 0, 0, NULL};\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\n\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL);\n\n\tif (REG_GET_FIELD(bif_doorbell_intr_cntl,\n\t\tBIF_BX0_BIF_DOORBELL_INT_CNTL, RAS_CNTLR_INTERRUPT_STATUS)) {\n\t\t \n\t\tbif_doorbell_intr_cntl = REG_SET_FIELD(bif_doorbell_intr_cntl,\n\t\t\t\t\t\tBIF_BX0_BIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_CNTLR_INTERRUPT_CLEAR, 1);\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL, bif_doorbell_intr_cntl);\n\n\t\tif (!ras->disable_ras_err_cnt_harvest) {\n\t\t\t \n\t\t\tnbio_v7_9_query_ras_error_count(adev, &err_data);\n\n\t\t\t \n\t\t\tobj->err_data.ue_count += err_data.ue_count;\n\t\t\tobj->err_data.ce_count += err_data.ce_count;\n\n\t\t\tif (err_data.ce_count)\n\t\t\t\tdev_info(adev->dev, \"%ld correctable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block, \"\n\t\t\t\t\t\t\"no user action is needed.\\n\",\n\t\t\t\t\t\tobj->err_data.ce_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\n\t\t\tif (err_data.ue_count)\n\t\t\t\tdev_info(adev->dev, \"%ld uncorrectable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block\\n\",\n\t\t\t\t\t\tobj->err_data.ue_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\t\t}\n\n\t\tdev_info(adev->dev, \"RAS controller interrupt triggered \"\n\t\t\t\t\t\"by NBIF error\\n\");\n\t}\n}\n\nstatic void nbio_v7_9_handle_ras_err_event_athub_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_intr_cntl;\n\n\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL);\n\n\tif (REG_GET_FIELD(bif_doorbell_intr_cntl,\n\t\tBIF_BX0_BIF_DOORBELL_INT_CNTL, RAS_ATHUB_ERR_EVENT_INTERRUPT_STATUS)) {\n\t\t \n\t\tbif_doorbell_intr_cntl = REG_SET_FIELD(bif_doorbell_intr_cntl,\n\t\t\t\t\t\tBIF_BX0_BIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_ATHUB_ERR_EVENT_INTERRUPT_CLEAR, 1);\n\n\t\tWREG32_SOC15(NBIO, 0, regBIF_BX0_BIF_DOORBELL_INT_CNTL, bif_doorbell_intr_cntl);\n\n\t\tamdgpu_ras_global_ras_isr(adev);\n\t}\n}\n\nstatic int nbio_v7_9_set_ras_controller_irq_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t  struct amdgpu_irq_src *src,\n\t\t\t\t\t\t  unsigned type,\n\t\t\t\t\t\t  enum amdgpu_interrupt_state state)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int nbio_v7_9_process_ras_controller_irq(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amdgpu_irq_src *source,\n\t\t\t\t\t\tstruct amdgpu_iv_entry *entry)\n{\n\t \n\treturn 0;\n}\n\nstatic int nbio_v7_9_set_ras_err_event_athub_irq_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t       struct amdgpu_irq_src *src,\n\t\t\t\t\t\t       unsigned type,\n\t\t\t\t\t\t       enum amdgpu_interrupt_state state)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int nbio_v7_9_process_err_event_athub_irq(struct amdgpu_device *adev,\n\t\t\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs nbio_v7_9_ras_controller_irq_funcs = {\n\t.set = nbio_v7_9_set_ras_controller_irq_state,\n\t.process = nbio_v7_9_process_ras_controller_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs nbio_v7_9_ras_err_event_athub_irq_funcs = {\n\t.set = nbio_v7_9_set_ras_err_event_athub_irq_state,\n\t.process = nbio_v7_9_process_err_event_athub_irq,\n};\n\nstatic int nbio_v7_9_init_ras_controller_interrupt (struct amdgpu_device *adev)\n{\n\tint r;\n\n\t \n\tadev->nbio.ras_controller_irq.funcs =\n\t\t&nbio_v7_9_ras_controller_irq_funcs;\n\tadev->nbio.ras_controller_irq.num_types = 1;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_BIF,\n\t\t\t      NBIF_7_4__SRCID__RAS_CONTROLLER_INTERRUPT,\n\t\t\t      &adev->nbio.ras_controller_irq);\n\n\treturn r;\n}\n\nstatic int nbio_v7_9_init_ras_err_event_athub_interrupt (struct amdgpu_device *adev)\n{\n\n\tint r;\n\n\t \n\tadev->nbio.ras_err_event_athub_irq.funcs =\n\t\t&nbio_v7_9_ras_err_event_athub_irq_funcs;\n\tadev->nbio.ras_err_event_athub_irq.num_types = 1;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_BIF,\n\t\t\t      NBIF_7_4__SRCID__ERREVENT_ATHUB_INTERRUPT,\n\t\t\t      &adev->nbio.ras_err_event_athub_irq);\n\n\treturn r;\n}\n\nconst struct amdgpu_ras_block_hw_ops nbio_v7_9_ras_hw_ops = {\n\t.query_ras_error_count = nbio_v7_9_query_ras_error_count,\n};\n\nstruct amdgpu_nbio_ras nbio_v7_9_ras = {\n\t.ras_block = {\n\t\t.ras_comm = {\n\t\t\t.name = \"pcie_bif\",\n\t\t\t.block = AMDGPU_RAS_BLOCK__PCIE_BIF,\n\t\t\t.type = AMDGPU_RAS_ERROR__MULTI_UNCORRECTABLE,\n\t\t},\n\t\t.hw_ops = &nbio_v7_9_ras_hw_ops,\n\t\t.ras_late_init = amdgpu_nbio_ras_late_init,\n\t},\n\t.handle_ras_controller_intr_no_bifring = nbio_v7_9_handle_ras_controller_intr_no_bifring,\n\t.handle_ras_err_event_athub_intr_no_bifring = nbio_v7_9_handle_ras_err_event_athub_intr_no_bifring,\n\t.init_ras_controller_interrupt = nbio_v7_9_init_ras_controller_interrupt,\n\t.init_ras_err_event_athub_interrupt = nbio_v7_9_init_ras_err_event_athub_interrupt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}