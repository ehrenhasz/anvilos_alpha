{
  "module_name": "gfx_v9_0.c",
  "hash_id": "5409694439296450461a528938894106299b8dea66814ac832e42ffa31fd4b68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_gfx.h\"\n#include \"soc15.h\"\n#include \"soc15d.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_pm.h\"\n\n#include \"gc/gc_9_0_offset.h\"\n#include \"gc/gc_9_0_sh_mask.h\"\n\n#include \"vega10_enum.h\"\n\n#include \"soc15_common.h\"\n#include \"clearstate_gfx9.h\"\n#include \"v9_structs.h\"\n\n#include \"ivsrcid/gfx/irqsrcs_gfx_9_0.h\"\n\n#include \"amdgpu_ras.h\"\n\n#include \"amdgpu_ring_mux.h\"\n#include \"gfx_v9_4.h\"\n#include \"gfx_v9_0.h\"\n#include \"gfx_v9_4_2.h\"\n\n#include \"asic_reg/pwr/pwr_10_0_offset.h\"\n#include \"asic_reg/pwr/pwr_10_0_sh_mask.h\"\n#include \"asic_reg/gc/gc_9_0_default.h\"\n\n#define GFX9_NUM_GFX_RINGS     1\n#define GFX9_NUM_SW_GFX_RINGS  2\n#define GFX9_MEC_HPD_SIZE 4096\n#define RLCG_UCODE_LOADING_START_ADDRESS 0x00002000L\n#define RLC_SAVE_RESTORE_ADDR_STARTING_OFFSET 0x00000000L\n\n#define mmGCEA_PROBE_MAP                        0x070c\n#define mmGCEA_PROBE_MAP_BASE_IDX               0\n\nMODULE_FIRMWARE(\"amdgpu/vega10_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega10_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/vega12_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega12_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/vega20_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/vega20_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/raven_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/picasso_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/picasso_rlc_am4.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/raven2_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven2_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven2_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven2_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven2_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven2_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/raven_kicker_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/arcturus_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/arcturus_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/renoir_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/renoir_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/renoir_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/renoir_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/renoir_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/green_sardine_ce.bin\");\nMODULE_FIRMWARE(\"amdgpu/green_sardine_pfp.bin\");\nMODULE_FIRMWARE(\"amdgpu/green_sardine_me.bin\");\nMODULE_FIRMWARE(\"amdgpu/green_sardine_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/green_sardine_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/green_sardine_rlc.bin\");\n\nMODULE_FIRMWARE(\"amdgpu/aldebaran_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_mec2.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_rlc.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_sjt_mec.bin\");\nMODULE_FIRMWARE(\"amdgpu/aldebaran_sjt_mec2.bin\");\n\n#define mmTCP_CHAN_STEER_0_ARCT\t\t\t\t\t\t\t\t0x0b03\n#define mmTCP_CHAN_STEER_0_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n#define mmTCP_CHAN_STEER_1_ARCT\t\t\t\t\t\t\t\t0x0b04\n#define mmTCP_CHAN_STEER_1_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n#define mmTCP_CHAN_STEER_2_ARCT\t\t\t\t\t\t\t\t0x0b09\n#define mmTCP_CHAN_STEER_2_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n#define mmTCP_CHAN_STEER_3_ARCT\t\t\t\t\t\t\t\t0x0b0a\n#define mmTCP_CHAN_STEER_3_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n#define mmTCP_CHAN_STEER_4_ARCT\t\t\t\t\t\t\t\t0x0b0b\n#define mmTCP_CHAN_STEER_4_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n#define mmTCP_CHAN_STEER_5_ARCT\t\t\t\t\t\t\t\t0x0b0c\n#define mmTCP_CHAN_STEER_5_ARCT_BASE_IDX\t\t\t\t\t\t\t0\n\n#define mmGOLDEN_TSC_COUNT_UPPER_Renoir                0x0025\n#define mmGOLDEN_TSC_COUNT_UPPER_Renoir_BASE_IDX       1\n#define mmGOLDEN_TSC_COUNT_LOWER_Renoir                0x0026\n#define mmGOLDEN_TSC_COUNT_LOWER_Renoir_BASE_IDX       1\n\nenum ta_ras_gfx_subblock {\n\t \n\tTA_RAS_BLOCK__GFX_CPC_INDEX_START = 0,\n\tTA_RAS_BLOCK__GFX_CPC_SCRATCH = TA_RAS_BLOCK__GFX_CPC_INDEX_START,\n\tTA_RAS_BLOCK__GFX_CPC_UCODE,\n\tTA_RAS_BLOCK__GFX_DC_STATE_ME1,\n\tTA_RAS_BLOCK__GFX_DC_CSINVOC_ME1,\n\tTA_RAS_BLOCK__GFX_DC_RESTORE_ME1,\n\tTA_RAS_BLOCK__GFX_DC_STATE_ME2,\n\tTA_RAS_BLOCK__GFX_DC_CSINVOC_ME2,\n\tTA_RAS_BLOCK__GFX_DC_RESTORE_ME2,\n\tTA_RAS_BLOCK__GFX_CPC_INDEX_END = TA_RAS_BLOCK__GFX_DC_RESTORE_ME2,\n\t \n\tTA_RAS_BLOCK__GFX_CPF_INDEX_START,\n\tTA_RAS_BLOCK__GFX_CPF_ROQ_ME2 = TA_RAS_BLOCK__GFX_CPF_INDEX_START,\n\tTA_RAS_BLOCK__GFX_CPF_ROQ_ME1,\n\tTA_RAS_BLOCK__GFX_CPF_TAG,\n\tTA_RAS_BLOCK__GFX_CPF_INDEX_END = TA_RAS_BLOCK__GFX_CPF_TAG,\n\t \n\tTA_RAS_BLOCK__GFX_CPG_INDEX_START,\n\tTA_RAS_BLOCK__GFX_CPG_DMA_ROQ = TA_RAS_BLOCK__GFX_CPG_INDEX_START,\n\tTA_RAS_BLOCK__GFX_CPG_DMA_TAG,\n\tTA_RAS_BLOCK__GFX_CPG_TAG,\n\tTA_RAS_BLOCK__GFX_CPG_INDEX_END = TA_RAS_BLOCK__GFX_CPG_TAG,\n\t \n\tTA_RAS_BLOCK__GFX_GDS_INDEX_START,\n\tTA_RAS_BLOCK__GFX_GDS_MEM = TA_RAS_BLOCK__GFX_GDS_INDEX_START,\n\tTA_RAS_BLOCK__GFX_GDS_INPUT_QUEUE,\n\tTA_RAS_BLOCK__GFX_GDS_OA_PHY_CMD_RAM_MEM,\n\tTA_RAS_BLOCK__GFX_GDS_OA_PHY_DATA_RAM_MEM,\n\tTA_RAS_BLOCK__GFX_GDS_OA_PIPE_MEM,\n\tTA_RAS_BLOCK__GFX_GDS_INDEX_END = TA_RAS_BLOCK__GFX_GDS_OA_PIPE_MEM,\n\t \n\tTA_RAS_BLOCK__GFX_SPI_SR_MEM,\n\t \n\tTA_RAS_BLOCK__GFX_SQ_INDEX_START,\n\tTA_RAS_BLOCK__GFX_SQ_SGPR = TA_RAS_BLOCK__GFX_SQ_INDEX_START,\n\tTA_RAS_BLOCK__GFX_SQ_LDS_D,\n\tTA_RAS_BLOCK__GFX_SQ_LDS_I,\n\tTA_RAS_BLOCK__GFX_SQ_VGPR,  \n\tTA_RAS_BLOCK__GFX_SQ_INDEX_END = TA_RAS_BLOCK__GFX_SQ_VGPR,\n\t \n\tTA_RAS_BLOCK__GFX_SQC_INDEX_START,\n\t \n\tTA_RAS_BLOCK__GFX_SQC_INDEX0_START = TA_RAS_BLOCK__GFX_SQC_INDEX_START,\n\tTA_RAS_BLOCK__GFX_SQC_INST_UTCL1_LFIFO =\n\t\tTA_RAS_BLOCK__GFX_SQC_INDEX0_START,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU0_WRITE_DATA_BUF,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU0_UTCL1_LFIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU1_WRITE_DATA_BUF,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU1_UTCL1_LFIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU2_WRITE_DATA_BUF,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_CU2_UTCL1_LFIFO,\n\tTA_RAS_BLOCK__GFX_SQC_INDEX0_END =\n\t\tTA_RAS_BLOCK__GFX_SQC_DATA_CU2_UTCL1_LFIFO,\n\t \n\tTA_RAS_BLOCK__GFX_SQC_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKA_TAG_RAM =\n\t\tTA_RAS_BLOCK__GFX_SQC_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKA_UTCL1_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKA_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKA_BANK_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_TAG_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_HIT_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_DIRTY_BIT_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_BANK_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_INDEX1_END =\n\t\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKA_BANK_RAM,\n\t \n\tTA_RAS_BLOCK__GFX_SQC_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKB_TAG_RAM =\n\t\tTA_RAS_BLOCK__GFX_SQC_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKB_UTCL1_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKB_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_INST_BANKB_BANK_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_TAG_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_HIT_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_MISS_FIFO,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_DIRTY_BIT_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_BANK_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_INDEX2_END =\n\t\tTA_RAS_BLOCK__GFX_SQC_DATA_BANKB_BANK_RAM,\n\tTA_RAS_BLOCK__GFX_SQC_INDEX_END = TA_RAS_BLOCK__GFX_SQC_INDEX2_END,\n\t \n\tTA_RAS_BLOCK__GFX_TA_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TA_FS_DFIFO = TA_RAS_BLOCK__GFX_TA_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TA_FS_AFIFO,\n\tTA_RAS_BLOCK__GFX_TA_FL_LFIFO,\n\tTA_RAS_BLOCK__GFX_TA_FX_LFIFO,\n\tTA_RAS_BLOCK__GFX_TA_FS_CFIFO,\n\tTA_RAS_BLOCK__GFX_TA_INDEX_END = TA_RAS_BLOCK__GFX_TA_FS_CFIFO,\n\t \n\tTA_RAS_BLOCK__GFX_TCA_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TCA_HOLE_FIFO = TA_RAS_BLOCK__GFX_TCA_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TCA_REQ_FIFO,\n\tTA_RAS_BLOCK__GFX_TCA_INDEX_END = TA_RAS_BLOCK__GFX_TCA_REQ_FIFO,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX_START,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX0_START = TA_RAS_BLOCK__GFX_TCC_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DATA = TA_RAS_BLOCK__GFX_TCC_INDEX0_START,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_0_1,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_1_0,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_1_1,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DIRTY_BANK_0,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_DIRTY_BANK_1,\n\tTA_RAS_BLOCK__GFX_TCC_HIGH_RATE_TAG,\n\tTA_RAS_BLOCK__GFX_TCC_LOW_RATE_TAG,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX0_END = TA_RAS_BLOCK__GFX_TCC_LOW_RATE_TAG,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_TCC_IN_USE_DEC = TA_RAS_BLOCK__GFX_TCC_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_TCC_IN_USE_TRANSFER,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX1_END =\n\t\tTA_RAS_BLOCK__GFX_TCC_IN_USE_TRANSFER,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_TCC_RETURN_DATA = TA_RAS_BLOCK__GFX_TCC_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_TCC_RETURN_CONTROL,\n\tTA_RAS_BLOCK__GFX_TCC_UC_ATOMIC_FIFO,\n\tTA_RAS_BLOCK__GFX_TCC_WRITE_RETURN,\n\tTA_RAS_BLOCK__GFX_TCC_WRITE_CACHE_READ,\n\tTA_RAS_BLOCK__GFX_TCC_SRC_FIFO,\n\tTA_RAS_BLOCK__GFX_TCC_SRC_FIFO_NEXT_RAM,\n\tTA_RAS_BLOCK__GFX_TCC_CACHE_TAG_PROBE_FIFO,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX2_END =\n\t\tTA_RAS_BLOCK__GFX_TCC_CACHE_TAG_PROBE_FIFO,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX3_START,\n\tTA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO = TA_RAS_BLOCK__GFX_TCC_INDEX3_START,\n\tTA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO_NEXT_RAM,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX3_END =\n\t\tTA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO_NEXT_RAM,\n\t \n\tTA_RAS_BLOCK__GFX_TCC_INDEX4_START,\n\tTA_RAS_BLOCK__GFX_TCC_WRRET_TAG_WRITE_RETURN =\n\t\tTA_RAS_BLOCK__GFX_TCC_INDEX4_START,\n\tTA_RAS_BLOCK__GFX_TCC_ATOMIC_RETURN_BUFFER,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX4_END =\n\t\tTA_RAS_BLOCK__GFX_TCC_ATOMIC_RETURN_BUFFER,\n\tTA_RAS_BLOCK__GFX_TCC_INDEX_END = TA_RAS_BLOCK__GFX_TCC_INDEX4_END,\n\t \n\tTA_RAS_BLOCK__GFX_TCI_WRITE_RAM,\n\t \n\tTA_RAS_BLOCK__GFX_TCP_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TCP_CACHE_RAM = TA_RAS_BLOCK__GFX_TCP_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TCP_LFIFO_RAM,\n\tTA_RAS_BLOCK__GFX_TCP_CMD_FIFO,\n\tTA_RAS_BLOCK__GFX_TCP_VM_FIFO,\n\tTA_RAS_BLOCK__GFX_TCP_DB_RAM,\n\tTA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO0,\n\tTA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO1,\n\tTA_RAS_BLOCK__GFX_TCP_INDEX_END = TA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO1,\n\t \n\tTA_RAS_BLOCK__GFX_TD_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TD_SS_FIFO_LO = TA_RAS_BLOCK__GFX_TD_INDEX_START,\n\tTA_RAS_BLOCK__GFX_TD_SS_FIFO_HI,\n\tTA_RAS_BLOCK__GFX_TD_CS_FIFO,\n\tTA_RAS_BLOCK__GFX_TD_INDEX_END = TA_RAS_BLOCK__GFX_TD_CS_FIFO,\n\t \n\tTA_RAS_BLOCK__GFX_EA_INDEX_START,\n\t \n\tTA_RAS_BLOCK__GFX_EA_INDEX0_START = TA_RAS_BLOCK__GFX_EA_INDEX_START,\n\tTA_RAS_BLOCK__GFX_EA_DRAMRD_CMDMEM = TA_RAS_BLOCK__GFX_EA_INDEX0_START,\n\tTA_RAS_BLOCK__GFX_EA_DRAMWR_CMDMEM,\n\tTA_RAS_BLOCK__GFX_EA_DRAMWR_DATAMEM,\n\tTA_RAS_BLOCK__GFX_EA_RRET_TAGMEM,\n\tTA_RAS_BLOCK__GFX_EA_WRET_TAGMEM,\n\tTA_RAS_BLOCK__GFX_EA_GMIRD_CMDMEM,\n\tTA_RAS_BLOCK__GFX_EA_GMIWR_CMDMEM,\n\tTA_RAS_BLOCK__GFX_EA_GMIWR_DATAMEM,\n\tTA_RAS_BLOCK__GFX_EA_INDEX0_END = TA_RAS_BLOCK__GFX_EA_GMIWR_DATAMEM,\n\t \n\tTA_RAS_BLOCK__GFX_EA_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_EA_DRAMRD_PAGEMEM = TA_RAS_BLOCK__GFX_EA_INDEX1_START,\n\tTA_RAS_BLOCK__GFX_EA_DRAMWR_PAGEMEM,\n\tTA_RAS_BLOCK__GFX_EA_IORD_CMDMEM,\n\tTA_RAS_BLOCK__GFX_EA_IOWR_CMDMEM,\n\tTA_RAS_BLOCK__GFX_EA_IOWR_DATAMEM,\n\tTA_RAS_BLOCK__GFX_EA_GMIRD_PAGEMEM,\n\tTA_RAS_BLOCK__GFX_EA_GMIWR_PAGEMEM,\n\tTA_RAS_BLOCK__GFX_EA_INDEX1_END = TA_RAS_BLOCK__GFX_EA_GMIWR_PAGEMEM,\n\t \n\tTA_RAS_BLOCK__GFX_EA_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_EA_MAM_D0MEM = TA_RAS_BLOCK__GFX_EA_INDEX2_START,\n\tTA_RAS_BLOCK__GFX_EA_MAM_D1MEM,\n\tTA_RAS_BLOCK__GFX_EA_MAM_D2MEM,\n\tTA_RAS_BLOCK__GFX_EA_MAM_D3MEM,\n\tTA_RAS_BLOCK__GFX_EA_INDEX2_END = TA_RAS_BLOCK__GFX_EA_MAM_D3MEM,\n\tTA_RAS_BLOCK__GFX_EA_INDEX_END = TA_RAS_BLOCK__GFX_EA_INDEX2_END,\n\t \n\tTA_RAS_BLOCK__UTC_VML2_BANK_CACHE,\n\t \n\tTA_RAS_BLOCK__UTC_VML2_WALKER,\n\t \n\tTA_RAS_BLOCK__UTC_ATCL2_CACHE_2M_BANK,\n\t \n\tTA_RAS_BLOCK__UTC_ATCL2_CACHE_4K_BANK,\n\tTA_RAS_BLOCK__GFX_MAX\n};\n\nstruct ras_gfx_subblock {\n\tunsigned char *name;\n\tint ta_subblock;\n\tint hw_supported_error_type;\n\tint sw_supported_error_type;\n};\n\n#define AMDGPU_RAS_SUB_BLOCK(subblock, a, b, c, d, e, f, g, h)                             \\\n\t[AMDGPU_RAS_BLOCK__##subblock] = {                                     \\\n\t\t#subblock,                                                     \\\n\t\tTA_RAS_BLOCK__##subblock,                                      \\\n\t\t((a) | ((b) << 1) | ((c) << 2) | ((d) << 3)),                  \\\n\t\t(((e) << 1) | ((f) << 3) | (g) | ((h) << 2)),                  \\\n\t}\n\nstatic const struct ras_gfx_subblock ras_gfx_subblocks[] = {\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPC_SCRATCH, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPC_UCODE, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_STATE_ME1, 1, 0, 0, 1, 0, 0, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_CSINVOC_ME1, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_RESTORE_ME1, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_STATE_ME2, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_CSINVOC_ME2, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_DC_RESTORE_ME2, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPF_ROQ_ME2, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPF_ROQ_ME1, 1, 0, 0, 1, 0, 0, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPF_TAG, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPG_DMA_ROQ, 1, 0, 0, 1, 0, 0, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPG_DMA_TAG, 0, 1, 1, 1, 0, 1, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_CPG_TAG, 0, 1, 1, 1, 1, 1, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_GDS_MEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_GDS_INPUT_QUEUE, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PHY_CMD_RAM_MEM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PHY_DATA_RAM_MEM, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PIPE_MEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SPI_SR_MEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQ_SGPR, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQ_LDS_D, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQ_LDS_I, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQ_VGPR, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU0_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU0_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU1_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU1_UTCL1_LFIFO, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU2_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU2_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_TAG_RAM, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_UTCL1_MISS_FIFO, 1, 0, 0, 1, 0,\n\t\t\t     0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_TAG_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_HIT_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_DIRTY_BIT_RAM, 1, 0, 0, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_TAG_RAM, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_UTCL1_MISS_FIFO, 1, 0, 0, 1, 0,\n\t\t\t     0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_TAG_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_HIT_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_DIRTY_BIT_RAM, 1, 0, 0, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_DFIFO, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_AFIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TA_FL_LFIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TA_FX_LFIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_CFIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCA_HOLE_FIFO, 1, 0, 0, 1, 0, 1, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCA_REQ_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_0_1, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_1_0, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_1_1, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t     1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DIRTY_BANK_0, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DIRTY_BANK_1, 0, 1, 1, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_HIGH_RATE_TAG, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_LOW_RATE_TAG, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_IN_USE_DEC, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_IN_USE_TRANSFER, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_RETURN_DATA, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_RETURN_CONTROL, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_UC_ATOMIC_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRITE_RETURN, 1, 0, 0, 1, 0, 1, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRITE_CACHE_READ, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_SRC_FIFO, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_SRC_FIFO_NEXT_RAM, 1, 0, 0, 1, 0, 0, 1, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_TAG_PROBE_FIFO, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_LATENCY_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_LATENCY_FIFO_NEXT_RAM, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRRET_TAG_WRITE_RETURN, 1, 0, 0, 1, 0, 0,\n\t\t\t     0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCC_ATOMIC_RETURN_BUFFER, 1, 0, 0, 1, 0, 0, 0,\n\t\t\t     0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCI_WRITE_RAM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_CACHE_RAM, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_LFIFO_RAM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_CMD_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_VM_FIFO, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_DB_RAM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_UTCL1_LFIFO0, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TCP_UTCL1_LFIFO1, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TD_SS_FIFO_LO, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TD_SS_FIFO_HI, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_TD_CS_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMRD_CMDMEM, 0, 1, 1, 1, 1, 0, 0, 1),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_DATAMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_RRET_TAGMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_WRET_TAGMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIRD_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_DATAMEM, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMRD_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_IORD_CMDMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_IOWR_CMDMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_IOWR_DATAMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIRD_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D0MEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D1MEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D2MEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D3MEM, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(UTC_VML2_BANK_CACHE, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(UTC_VML2_WALKER, 0, 1, 1, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(UTC_ATCL2_CACHE_2M_BANK, 1, 0, 0, 1, 0, 0, 0, 0),\n\tAMDGPU_RAS_SUB_BLOCK(UTC_ATCL2_CACHE_4K_BANK, 0, 1, 1, 1, 0, 0, 0, 0),\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_0[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000400),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG3, 0x80000000, 0x80000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSH_MEM_CONFIG, 0x00001000, 0x00001000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_0, 0x0007ffff, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_1, 0x0007ffff, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_0, 0x01ffffff, 0x00ffff87),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_1, 0x01ffffff, 0x00ffff8f),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSQC_CONFIG, 0x03000000, 0x020a2000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x4a2c0e68),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0xb5d3f197),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000003ff),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_0_vg10[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0x0000f000, 0x00012107),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x2a114042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x2a114042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0x00008000, 0x00048000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00020000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0x0000000f, 0x01000107),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x00001800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x08000000, 0x08000080)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_0_vg20[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0x0f000080, 0x04000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0x0f000000, 0x0a000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xf3e777ff, 0x22014042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xf3e777ff, 0x22014042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0x00003e00, 0x00000400),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xff840000, 0x04040000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00030000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0xffff010f, 0x01000107),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0x000b0000, 0x000b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01000000, 0x01000000)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_1[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000420),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00003120),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000000ff),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x08000000, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_1_rv1[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x24000042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x24000042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04048000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_MODE_CNTL_1, 0x06000000, 0x06000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00020000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x00000800)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_1_rv2[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0xff7fffff, 0x04000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0xff7fffff, 0x0a000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x7f0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0xff8fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x7f8fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x26013041),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x26013041),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x3f8fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0xff0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0xff0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0xff0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0xff0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0xff0fffff, 0x08000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00000010),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x01000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x3f8fffff, 0x08000080),\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_1_rn[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0xff7fffff, 0x0a000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000400),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xf3e777ff, 0x24000042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xf3e777ff, 0x24000042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00003120),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGCEA_PROBE_MAP, 0xffffffff, 0x0000cccc),\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_x_common[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_SD_CNTL, 0xffffffff, 0x000001ff),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGRBM_CAM_INDEX, 0xffffffff, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGRBM_CAM_DATA, 0xffffffff, 0x2544c382)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_2_1[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000420),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSH_MEM_CONFIG, 0x00001000, 0x00001000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_0, 0x0007ffff, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_1, 0x0007ffff, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_0, 0x01ffffff, 0x0000ff87),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_1, 0x01ffffff, 0x0000ff8f),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSQC_CONFIG, 0x03000000, 0x020a2000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x4a2c0e68),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0xb5d3f197),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000003ff)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_2_1_vg12[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0x00000080, 0x04000080),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0x0f000000, 0x0a000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x24104041),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x24104041),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0xffff03ff, 0x01000107),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x76325410),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x01000000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)\n};\n\nstatic const struct soc15_reg_golden golden_settings_gc_9_4_1_arct[] =\n{\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x2a114042),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x10b0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_0_ARCT, 0x3fffffff, 0x346f0a4e),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_1_ARCT, 0x3fffffff, 0x1c642ca),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_2_ARCT, 0x3fffffff, 0x26f45098),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_3_ARCT, 0x3fffffff, 0x2ebd9fe3),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_4_ARCT, 0x3fffffff, 0xb90f5b1),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_5_ARCT, 0x3ff, 0x135),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSQ_CONFIG, 0xffffffff, 0x011A0000),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmSQ_FIFO_SIZES, 0xffffffff, 0x00000f00),\n\tSOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_UTCL1_CNTL1, 0x30000000, 0x30000000)\n};\n\nstatic const struct soc15_reg_rlcg rlcg_access_gc_9_0[] = {\n\t{SOC15_REG_ENTRY(GC, 0, mmGRBM_GFX_INDEX)},\n\t{SOC15_REG_ENTRY(GC, 0, mmSQ_IND_INDEX)},\n};\n\nstatic const u32 GFX_RLC_SRM_INDEX_CNTL_ADDR_OFFSETS[] =\n{\n\tmmRLC_SRM_INDEX_CNTL_ADDR_0 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_1 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_2 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_3 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_4 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_5 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_6 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n\tmmRLC_SRM_INDEX_CNTL_ADDR_7 - mmRLC_SRM_INDEX_CNTL_ADDR_0,\n};\n\nstatic const u32 GFX_RLC_SRM_INDEX_CNTL_DATA_OFFSETS[] =\n{\n\tmmRLC_SRM_INDEX_CNTL_DATA_0 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_1 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_2 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_3 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_4 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_5 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_6 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n\tmmRLC_SRM_INDEX_CNTL_DATA_7 - mmRLC_SRM_INDEX_CNTL_DATA_0,\n};\n\n#define VEGA10_GB_ADDR_CONFIG_GOLDEN 0x2a114042\n#define VEGA12_GB_ADDR_CONFIG_GOLDEN 0x24104041\n#define RAVEN_GB_ADDR_CONFIG_GOLDEN 0x24000042\n#define RAVEN2_GB_ADDR_CONFIG_GOLDEN 0x26013041\n\nstatic void gfx_v9_0_set_ring_funcs(struct amdgpu_device *adev);\nstatic void gfx_v9_0_set_irq_funcs(struct amdgpu_device *adev);\nstatic void gfx_v9_0_set_gds_init(struct amdgpu_device *adev);\nstatic void gfx_v9_0_set_rlc_funcs(struct amdgpu_device *adev);\nstatic int gfx_v9_0_get_cu_info(struct amdgpu_device *adev,\n\t\t\t\tstruct amdgpu_cu_info *cu_info);\nstatic uint64_t gfx_v9_0_get_gpu_clock_counter(struct amdgpu_device *adev);\nstatic void gfx_v9_0_ring_emit_de_meta(struct amdgpu_ring *ring, bool resume, bool usegds);\nstatic u64 gfx_v9_0_ring_get_rptr_compute(struct amdgpu_ring *ring);\nstatic void gfx_v9_0_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\t  void *ras_error_status);\nstatic int gfx_v9_0_ras_error_inject(struct amdgpu_device *adev,\n\t\t\t\t     void *inject_if, uint32_t instance_mask);\nstatic void gfx_v9_0_reset_ras_error_count(struct amdgpu_device *adev);\nstatic void gfx_v9_0_update_spm_vmid_internal(struct amdgpu_device *adev,\n\t\t\t\t\t      unsigned int vmid);\n\nstatic void gfx_v9_0_kiq_set_resources(struct amdgpu_ring *kiq_ring,\n\t\t\t\tuint64_t queue_mask)\n{\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_SET_RESOURCES, 6));\n\tamdgpu_ring_write(kiq_ring,\n\t\tPACKET3_SET_RESOURCES_VMID_MASK(0) |\n\t\t \n\t\tPACKET3_SET_RESOURCES_QUEUE_TYPE(0));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\tlower_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring,\n\t\t\tupper_32_bits(queue_mask));\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n\tamdgpu_ring_write(kiq_ring, 0);\t \n}\n\nstatic void gfx_v9_0_kiq_map_queues(struct amdgpu_ring *kiq_ring,\n\t\t\t\t struct amdgpu_ring *ring)\n{\n\tuint64_t mqd_addr = amdgpu_bo_gpu_offset(ring->mqd_obj);\n\tuint64_t wptr_addr = ring->wptr_gpu_addr;\n\tuint32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));\n\t \n\tamdgpu_ring_write(kiq_ring,  \n\t\t\t PACKET3_MAP_QUEUES_QUEUE_SEL(0) |  \n\t\t\t PACKET3_MAP_QUEUES_VMID(0) |  \n\t\t\t PACKET3_MAP_QUEUES_QUEUE(ring->queue) |\n\t\t\t PACKET3_MAP_QUEUES_PIPE(ring->pipe) |\n\t\t\t PACKET3_MAP_QUEUES_ME((ring->me == 1 ? 0 : 1)) |\n\t\t\t  \n\t\t\t PACKET3_MAP_QUEUES_QUEUE_TYPE(0) |\n\t\t\t  \n\t\t\t PACKET3_MAP_QUEUES_ALLOC_FORMAT(0) |\n\t\t\t PACKET3_MAP_QUEUES_ENGINE_SEL(eng_sel) |\n\t\t\t  \n\t\t\t PACKET3_MAP_QUEUES_NUM_QUEUES(1));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\tPACKET3_MAP_QUEUES_DOORBELL_OFFSET(ring->doorbell_index));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(mqd_addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(mqd_addr));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(wptr_addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(wptr_addr));\n}\n\nstatic void gfx_v9_0_kiq_unmap_queues(struct amdgpu_ring *kiq_ring,\n\t\t\t\t   struct amdgpu_ring *ring,\n\t\t\t\t   enum amdgpu_unmap_queues_action action,\n\t\t\t\t   u64 gpu_addr, u64 seq)\n{\n\tuint32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_UNMAP_QUEUES, 4));\n\tamdgpu_ring_write(kiq_ring,  \n\t\t\t  PACKET3_UNMAP_QUEUES_ACTION(action) |\n\t\t\t  PACKET3_UNMAP_QUEUES_QUEUE_SEL(0) |\n\t\t\t  PACKET3_UNMAP_QUEUES_ENGINE_SEL(eng_sel) |\n\t\t\t  PACKET3_UNMAP_QUEUES_NUM_QUEUES(1));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\tPACKET3_UNMAP_QUEUES_DOORBELL_OFFSET0(ring->doorbell_index));\n\n\tif (action == PREEMPT_QUEUES_NO_UNMAP) {\n\t\tamdgpu_ring_write(kiq_ring, lower_32_bits(ring->wptr & ring->buf_mask));\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\n\t} else {\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t\tamdgpu_ring_write(kiq_ring, 0);\n\t}\n}\n\nstatic void gfx_v9_0_kiq_query_status(struct amdgpu_ring *kiq_ring,\n\t\t\t\t   struct amdgpu_ring *ring,\n\t\t\t\t   u64 addr,\n\t\t\t\t   u64 seq)\n{\n\tuint32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;\n\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_QUERY_STATUS, 5));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\t  PACKET3_QUERY_STATUS_CONTEXT_ID(0) |\n\t\t\t  PACKET3_QUERY_STATUS_INTERRUPT_SEL(0) |\n\t\t\t  PACKET3_QUERY_STATUS_COMMAND(2));\n\t \n\tamdgpu_ring_write(kiq_ring,\n\t\t\tPACKET3_QUERY_STATUS_DOORBELL_OFFSET(ring->doorbell_index) |\n\t\t\tPACKET3_QUERY_STATUS_ENG_SEL(eng_sel));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(addr));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(addr));\n\tamdgpu_ring_write(kiq_ring, lower_32_bits(seq));\n\tamdgpu_ring_write(kiq_ring, upper_32_bits(seq));\n}\n\nstatic void gfx_v9_0_kiq_invalidate_tlbs(struct amdgpu_ring *kiq_ring,\n\t\t\t\tuint16_t pasid, uint32_t flush_type,\n\t\t\t\tbool all_hub)\n{\n\tamdgpu_ring_write(kiq_ring, PACKET3(PACKET3_INVALIDATE_TLBS, 0));\n\tamdgpu_ring_write(kiq_ring,\n\t\t\tPACKET3_INVALIDATE_TLBS_DST_SEL(1) |\n\t\t\tPACKET3_INVALIDATE_TLBS_ALL_HUB(all_hub) |\n\t\t\tPACKET3_INVALIDATE_TLBS_PASID(pasid) |\n\t\t\tPACKET3_INVALIDATE_TLBS_FLUSH_TYPE(flush_type));\n}\n\nstatic const struct kiq_pm4_funcs gfx_v9_0_kiq_pm4_funcs = {\n\t.kiq_set_resources = gfx_v9_0_kiq_set_resources,\n\t.kiq_map_queues = gfx_v9_0_kiq_map_queues,\n\t.kiq_unmap_queues = gfx_v9_0_kiq_unmap_queues,\n\t.kiq_query_status = gfx_v9_0_kiq_query_status,\n\t.kiq_invalidate_tlbs = gfx_v9_0_kiq_invalidate_tlbs,\n\t.set_resources_size = 8,\n\t.map_queues_size = 7,\n\t.unmap_queues_size = 6,\n\t.query_status_size = 7,\n\t.invalidate_tlbs_size = 2,\n};\n\nstatic void gfx_v9_0_set_kiq_pm4_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.kiq[0].pmf = &gfx_v9_0_kiq_pm4_funcs;\n}\n\nstatic void gfx_v9_0_init_golden_registers(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_0,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_0));\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_0_vg10,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_0_vg10));\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 1):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_2_1,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_2_1));\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_2_1_vg12,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_2_1_vg12));\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 0):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_0,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_0));\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_0_vg20,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_0_vg20));\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 1):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_4_1_arct,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_4_1_arct));\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\t\tsoc15_program_register_sequence(adev, golden_settings_gc_9_1,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_1));\n\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_gc_9_1_rv2,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_1_rv2));\n\t\telse\n\t\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\t\tgolden_settings_gc_9_1_rv1,\n\t\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_1_rv1));\n\t\tbreak;\n\t case IP_VERSION(9, 3, 0):\n\t\tsoc15_program_register_sequence(adev,\n\t\t\t\t\t\tgolden_settings_gc_9_1_rn,\n\t\t\t\t\t\tARRAY_SIZE(golden_settings_gc_9_1_rn));\n\t\treturn;  \n\tcase IP_VERSION(9, 4, 2):\n\t\tgfx_v9_4_2_init_golden_registers(adev,\n\t\t\t\t\t\t adev->smuio.funcs->get_die_id(adev));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 1)) &&\n\t    (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 2)))\n\t\tsoc15_program_register_sequence(adev, golden_settings_gc_9_x_common,\n\t\t\t\t\t\t(const u32)ARRAY_SIZE(golden_settings_gc_9_x_common));\n}\n\nstatic void gfx_v9_0_write_data_to_reg(struct amdgpu_ring *ring, int eng_sel,\n\t\t\t\t       bool wc, uint32_t reg, uint32_t val)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, WRITE_DATA_ENGINE_SEL(eng_sel) |\n\t\t\t\tWRITE_DATA_DST_SEL(0) |\n\t\t\t\t(wc ? WR_CONFIRM : 0));\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void gfx_v9_0_wait_reg_mem(struct amdgpu_ring *ring, int eng_sel,\n\t\t\t\t  int mem_space, int opt, uint32_t addr0,\n\t\t\t\t  uint32_t addr1, uint32_t ref, uint32_t mask,\n\t\t\t\t  uint32_t inv)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tamdgpu_ring_write(ring,\n\t\t\t\t  \n\t\t\t\t (WAIT_REG_MEM_MEM_SPACE(mem_space) |\n\t\t\t\t WAIT_REG_MEM_OPERATION(opt) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(eng_sel)));\n\n\tif (mem_space)\n\t\tBUG_ON(addr0 & 0x3);  \n\tamdgpu_ring_write(ring, addr0);\n\tamdgpu_ring_write(ring, addr1);\n\tamdgpu_ring_write(ring, ref);\n\tamdgpu_ring_write(ring, mask);\n\tamdgpu_ring_write(ring, inv);  \n}\n\nstatic int gfx_v9_0_ring_test_ring(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t scratch = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG0);\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = amdgpu_ring_alloc(ring, 3);\n\tif (r)\n\t\treturn r;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\tamdgpu_ring_write(ring, scratch - PACKET3_SET_UCONFIG_REG_START);\n\tamdgpu_ring_write(ring, 0xDEADBEEF);\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\treturn r;\n}\n\nstatic int gfx_v9_0_ring_test_ib(struct amdgpu_ring *ring, long timeout)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\n\tunsigned index;\n\tuint64_t gpu_addr;\n\tuint32_t tmp;\n\tlong r;\n\n\tr = amdgpu_device_wb_get(adev, &index);\n\tif (r)\n\t\treturn r;\n\n\tgpu_addr = adev->wb.gpu_addr + (index * 4);\n\tadev->wb.wb[index] = cpu_to_le32(0xCAFEDEAD);\n\tmemset(&ib, 0, sizeof(ib));\n\n\tr = amdgpu_ib_get(adev, NULL, 20, AMDGPU_IB_POOL_DIRECT, &ib);\n\tif (r)\n\t\tgoto err1;\n\n\tib.ptr[0] = PACKET3(PACKET3_WRITE_DATA, 3);\n\tib.ptr[1] = WRITE_DATA_DST_SEL(5) | WR_CONFIRM;\n\tib.ptr[2] = lower_32_bits(gpu_addr);\n\tib.ptr[3] = upper_32_bits(gpu_addr);\n\tib.ptr[4] = 0xDEADBEEF;\n\tib.length_dw = 5;\n\n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r)\n\t\tgoto err2;\n\n\tr = dma_fence_wait_timeout(f, false, timeout);\n\tif (r == 0) {\n\t\tr = -ETIMEDOUT;\n\t\tgoto err2;\n\t} else if (r < 0) {\n\t\tgoto err2;\n\t}\n\n\ttmp = adev->wb.wb[index];\n\tif (tmp == 0xDEADBEEF)\n\t\tr = 0;\n\telse\n\t\tr = -EINVAL;\n\nerr2:\n\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\nerr1:\n\tamdgpu_device_wb_free(adev, index);\n\treturn r;\n}\n\n\nstatic void gfx_v9_0_free_microcode(struct amdgpu_device *adev)\n{\n\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\tamdgpu_ucode_release(&adev->gfx.ce_fw);\n\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\tamdgpu_ucode_release(&adev->gfx.mec2_fw);\n\n\tkfree(adev->gfx.rlc.register_list_format);\n}\n\nstatic void gfx_v9_0_check_fw_write_wait(struct amdgpu_device *adev)\n{\n\tadev->gfx.me_fw_write_wait = false;\n\tadev->gfx.mec_fw_write_wait = false;\n\n\tif ((adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 1)) &&\n\t    ((adev->gfx.mec_fw_version < 0x000001a5) ||\n\t    (adev->gfx.mec_feature_version < 46) ||\n\t    (adev->gfx.pfp_fw_version < 0x000000b7) ||\n\t    (adev->gfx.pfp_feature_version < 46)))\n\t\tDRM_WARN_ONCE(\"CP firmware version too old, please update!\");\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\t\tif ((adev->gfx.me_fw_version >= 0x0000009c) &&\n\t\t    (adev->gfx.me_feature_version >= 42) &&\n\t\t    (adev->gfx.pfp_fw_version >=  0x000000b1) &&\n\t\t    (adev->gfx.pfp_feature_version >= 42))\n\t\t\tadev->gfx.me_fw_write_wait = true;\n\n\t\tif ((adev->gfx.mec_fw_version >=  0x00000193) &&\n\t\t    (adev->gfx.mec_feature_version >= 42))\n\t\t\tadev->gfx.mec_fw_write_wait = true;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 1):\n\t\tif ((adev->gfx.me_fw_version >= 0x0000009c) &&\n\t\t    (adev->gfx.me_feature_version >= 44) &&\n\t\t    (adev->gfx.pfp_fw_version >=  0x000000b2) &&\n\t\t    (adev->gfx.pfp_feature_version >= 44))\n\t\t\tadev->gfx.me_fw_write_wait = true;\n\n\t\tif ((adev->gfx.mec_fw_version >=  0x00000196) &&\n\t\t    (adev->gfx.mec_feature_version >= 44))\n\t\t\tadev->gfx.mec_fw_write_wait = true;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 0):\n\t\tif ((adev->gfx.me_fw_version >= 0x0000009c) &&\n\t\t    (adev->gfx.me_feature_version >= 44) &&\n\t\t    (adev->gfx.pfp_fw_version >=  0x000000b2) &&\n\t\t    (adev->gfx.pfp_feature_version >= 44))\n\t\t\tadev->gfx.me_fw_write_wait = true;\n\n\t\tif ((adev->gfx.mec_fw_version >=  0x00000197) &&\n\t\t    (adev->gfx.mec_feature_version >= 44))\n\t\t\tadev->gfx.mec_fw_write_wait = true;\n\t\tbreak;\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 2):\n\t\tif ((adev->gfx.me_fw_version >= 0x0000009c) &&\n\t\t    (adev->gfx.me_feature_version >= 42) &&\n\t\t    (adev->gfx.pfp_fw_version >=  0x000000b1) &&\n\t\t    (adev->gfx.pfp_feature_version >= 42))\n\t\t\tadev->gfx.me_fw_write_wait = true;\n\n\t\tif ((adev->gfx.mec_fw_version >=  0x00000192) &&\n\t\t    (adev->gfx.mec_feature_version >= 42))\n\t\t\tadev->gfx.mec_fw_write_wait = true;\n\t\tbreak;\n\tdefault:\n\t\tadev->gfx.me_fw_write_wait = true;\n\t\tadev->gfx.mec_fw_write_wait = true;\n\t\tbreak;\n\t}\n}\n\nstruct amdgpu_gfxoff_quirk {\n\tu16 chip_vendor;\n\tu16 chip_device;\n\tu16 subsys_vendor;\n\tu16 subsys_device;\n\tu8 revision;\n};\n\nstatic const struct amdgpu_gfxoff_quirk amdgpu_gfxoff_quirk_list[] = {\n\t \n\t{ 0x1002, 0x15dd, 0x1002, 0x15dd, 0xc8 },\n\t \n\t{ 0x1002, 0x15dd, 0x103c, 0x83e7, 0xd3 },\n\t \n\t{ 0x1002, 0x15dd, 0x1002, 0x15dd, 0xc6 },\n\t \n\t{ 0x1002, 0x69af, 0x106b, 0x019a, 0xc0 },\n\t{ 0, 0, 0, 0, 0 },\n};\n\nstatic bool gfx_v9_0_should_disable_gfxoff(struct pci_dev *pdev)\n{\n\tconst struct amdgpu_gfxoff_quirk *p = amdgpu_gfxoff_quirk_list;\n\n\twhile (p && p->chip_device != 0) {\n\t\tif (pdev->vendor == p->chip_vendor &&\n\t\t    pdev->device == p->chip_device &&\n\t\t    pdev->subsystem_vendor == p->subsys_vendor &&\n\t\t    pdev->subsystem_device == p->subsys_device &&\n\t\t    pdev->revision == p->revision) {\n\t\t\treturn true;\n\t\t}\n\t\t++p;\n\t}\n\treturn false;\n}\n\nstatic bool is_raven_kicker(struct amdgpu_device *adev)\n{\n\tif (adev->pm.fw_version >= 0x41e2b)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool check_if_enlarge_doorbell_range(struct amdgpu_device *adev)\n{\n\tif ((adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 3, 0)) &&\n\t    (adev->gfx.me_fw_version >= 0x000000a5) &&\n\t    (adev->gfx.me_feature_version >= 52))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void gfx_v9_0_check_if_need_gfxoff(struct amdgpu_device *adev)\n{\n\tif (gfx_v9_0_should_disable_gfxoff(adev->pdev))\n\t\tadev->pm.pp_feature &= ~PP_GFXOFF_MASK;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\t\tif (!((adev->apu_flags & AMD_APU_IS_RAVEN2) ||\n\t\t      (adev->apu_flags & AMD_APU_IS_PICASSO)) &&\n\t\t    ((!is_raven_kicker(adev) &&\n\t\t      adev->gfx.rlc_fw_version < 531) ||\n\t\t     (adev->gfx.rlc_feature_version < 1) ||\n\t\t     !adev->gfx.rlc.is_rlc_v2_1))\n\t\t\tadev->pm.pp_feature &= ~PP_GFXOFF_MASK;\n\n\t\tif (adev->pm.pp_feature & PP_GFXOFF_MASK)\n\t\t\tadev->pg_flags |= AMD_PG_SUPPORT_GFX_PG |\n\t\t\t\tAMD_PG_SUPPORT_CP |\n\t\t\t\tAMD_PG_SUPPORT_RLC_SMU_HS;\n\t\tbreak;\n\tcase IP_VERSION(9, 3, 0):\n\t\tif (adev->pm.pp_feature & PP_GFXOFF_MASK)\n\t\t\tadev->pg_flags |= AMD_PG_SUPPORT_GFX_PG |\n\t\t\t\tAMD_PG_SUPPORT_CP |\n\t\t\t\tAMD_PG_SUPPORT_RLC_SMU_HS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v9_0_init_cp_gfx_microcode(struct amdgpu_device *adev,\n\t\t\t\t\t  char *chip_name)\n{\n\tchar fw_name[30];\n\tint err;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_pfp.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.pfp_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_PFP);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_me.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.me_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_ME);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_ce.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.ce_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_CE);\n\nout:\n\tif (err) {\n\t\tamdgpu_ucode_release(&adev->gfx.pfp_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.me_fw);\n\t\tamdgpu_ucode_release(&adev->gfx.ce_fw);\n\t}\n\treturn err;\n}\n\nstatic int gfx_v9_0_init_rlc_microcode(struct amdgpu_device *adev,\n\t\t\t\t       char *chip_name)\n{\n\tchar fw_name[30];\n\tint err;\n\tconst struct rlc_firmware_header_v2_0 *rlc_hdr;\n\tuint16_t version_major;\n\tuint16_t version_minor;\n\tuint32_t smu_version;\n\n\t \n\tif (!strcmp(chip_name, \"picasso\") &&\n\t\t(((adev->pdev->revision >= 0xC8) && (adev->pdev->revision <= 0xCF)) ||\n\t\t((adev->pdev->revision >= 0xD8) && (adev->pdev->revision <= 0xDF))))\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc_am4.bin\", chip_name);\n\telse if (!strcmp(chip_name, \"raven\") && (amdgpu_pm_load_smu_firmware(adev, &smu_version) == 0) &&\n\t\t(smu_version >= 0x41e2b))\n\t\t \n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_kicker_rlc.bin\", chip_name);\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->gfx.rlc_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\trlc_hdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\n\tversion_major = le16_to_cpu(rlc_hdr->header.header_version_major);\n\tversion_minor = le16_to_cpu(rlc_hdr->header.header_version_minor);\n\terr = amdgpu_gfx_rlc_init_microcode(adev, version_major, version_minor);\nout:\n\tif (err)\n\t\tamdgpu_ucode_release(&adev->gfx.rlc_fw);\n\n\treturn err;\n}\n\nstatic bool gfx_v9_0_load_mec2_fw_bin_support(struct amdgpu_device *adev)\n{\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 2) ||\n\t    adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 1) ||\n\t    adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 3, 0))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int gfx_v9_0_init_cp_compute_microcode(struct amdgpu_device *adev,\n\t\t\t\t\t      char *chip_name)\n{\n\tchar fw_name[30];\n\tint err;\n\n\tif (amdgpu_sriov_vf(adev) && (adev->asic_type == CHIP_ALDEBARAN))\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_sjt_mec.bin\", chip_name);\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name);\n\n\terr = amdgpu_ucode_request(adev, &adev->gfx.mec_fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC1);\n\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC1_JT);\n\n\tif (gfx_v9_0_load_mec2_fw_bin_support(adev)) {\n\t\tif (amdgpu_sriov_vf(adev) && (adev->asic_type == CHIP_ALDEBARAN))\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_sjt_mec2.bin\", chip_name);\n\t\telse\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec2.bin\", chip_name);\n\n\t\t \n\t\terr = amdgpu_ucode_request(adev, &adev->gfx.mec2_fw, fw_name);\n\t\tif (!err) {\n\t\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC2);\n\t\t\tamdgpu_gfx_cp_init_microcode(adev, AMDGPU_UCODE_ID_CP_MEC2_JT);\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tamdgpu_ucode_release(&adev->gfx.mec2_fw);\n\t\t}\n\t} else {\n\t\tadev->gfx.mec2_fw_version = adev->gfx.mec_fw_version;\n\t\tadev->gfx.mec2_feature_version = adev->gfx.mec_feature_version;\n\t}\n\n\tgfx_v9_0_check_if_need_gfxoff(adev);\n\tgfx_v9_0_check_fw_write_wait(adev);\n\nout:\n\tif (err)\n\t\tamdgpu_ucode_release(&adev->gfx.mec_fw);\n\treturn err;\n}\n\nstatic int gfx_v9_0_init_microcode(struct amdgpu_device *adev)\n{\n\tchar ucode_prefix[30];\n\tint r;\n\n\tDRM_DEBUG(\"\\n\");\n\tamdgpu_ucode_ip_version_decode(adev, GC_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\t \n\tif (adev->gfx.num_gfx_rings) {\n\t\tr = gfx_v9_0_init_cp_gfx_microcode(adev, ucode_prefix);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = gfx_v9_0_init_rlc_microcode(adev, ucode_prefix);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v9_0_init_cp_compute_microcode(adev, ucode_prefix);\n\tif (r)\n\t\treturn r;\n\n\treturn r;\n}\n\nstatic u32 gfx_v9_0_get_csb_size(struct amdgpu_device *adev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = gfx9_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nstatic void gfx_v9_0_get_csb_buffer(struct amdgpu_device *adev,\n\t\t\t\t    volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (adev->gfx.rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = adev->gfx.rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index -\n\t\t\t\t\t\tPACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic void gfx_v9_0_init_always_on_cu_mask(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_cu_info *cu_info = &adev->gfx.cu_info;\n\tuint32_t pg_always_on_cu_num = 2;\n\tuint32_t always_on_cu_num;\n\tuint32_t i, j, k;\n\tuint32_t mask, cu_bitmap, counter;\n\n\tif (adev->flags & AMD_IS_APU)\n\t\talways_on_cu_num = 4;\n\telse if (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 2, 1))\n\t\talways_on_cu_num = 8;\n\telse\n\t\talways_on_cu_num = 12;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tcu_bitmap = 0;\n\t\t\tcounter = 0;\n\t\t\tamdgpu_gfx_select_se_sh(adev, i, j, 0xffffffff, 0);\n\n\t\t\tfor (k = 0; k < adev->gfx.config.max_cu_per_sh; k ++) {\n\t\t\t\tif (cu_info->bitmap[0][i][j] & mask) {\n\t\t\t\t\tif (counter == pg_always_on_cu_num)\n\t\t\t\t\t\tWREG32_SOC15(GC, 0, mmRLC_PG_ALWAYS_ON_CU_MASK, cu_bitmap);\n\t\t\t\t\tif (counter < always_on_cu_num)\n\t\t\t\t\t\tcu_bitmap |= mask;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_LB_ALWAYS_ACTIVE_CU_MASK, cu_bitmap);\n\t\t\tcu_info->ao_cu_bitmap[i][j] = cu_bitmap;\n\t\t}\n\t}\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n}\n\nstatic void gfx_v9_0_init_lbpw(struct amdgpu_device *adev)\n{\n\tuint32_t data;\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_1, 0x0000007F);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_2, 0x0333A5A7);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_3, 0x00000077);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_4, (0x30 | 0x40 << 8 | 0x02FA << 16));\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTR_INIT, 0x00000000);\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTR_MAX, 0x00000500);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\t \n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_INIT_CU_MASK, 0xffffffff);\n\n\t \n\tdata = REG_SET_FIELD(0, RLC_LB_PARAMS, FIFO_SAMPLES, 0x0003);\n\tdata |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLES, 0x0010);\n\tdata |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLE_INTERVAL, 0x033F);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_PARAMS, data);\n\n\t \n\tdata = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7);\n\tdata &= 0x0000FFFF;\n\tdata |= 0x00C00000;\n\tWREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7, data);\n\n\t \n\n\t \n\tdata = RLC_LB_CNTL__LB_CNT_SPIM_ACTIVE_MASK;\n\tdata |= REG_SET_FIELD(data, RLC_LB_CNTL, CU_MASK_USED_OFF_HYST, 0x09);\n\tdata |= REG_SET_FIELD(data, RLC_LB_CNTL, RESERVED, 0x80000);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTL, data);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tgfx_v9_0_init_always_on_cu_mask(adev);\n}\n\nstatic void gfx_v9_4_init_lbpw(struct amdgpu_device *adev)\n{\n\tuint32_t data;\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_1, 0x0000007F);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_2, 0x033388F8);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_3, 0x00000077);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_4, (0x10 | 0x27 << 8 | 0x02FA << 16));\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTR_INIT, 0x00000000);\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTR_MAX, 0x00000800);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\t \n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_INIT_CU_MASK, 0xffffffff);\n\n\t \n\tdata = REG_SET_FIELD(0, RLC_LB_PARAMS, FIFO_SAMPLES, 0x0003);\n\tdata |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLES, 0x0010);\n\tdata |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLE_INTERVAL, 0x033F);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_PARAMS, data);\n\n\t \n\tdata = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7);\n\tdata &= 0x0000FFFF;\n\tdata |= 0x00C00000;\n\tWREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7, data);\n\n\t \n\n\t \n\tdata = RLC_LB_CNTL__LB_CNT_SPIM_ACTIVE_MASK;\n\tdata |= REG_SET_FIELD(data, RLC_LB_CNTL, CU_MASK_USED_OFF_HYST, 0x09);\n\tdata |= REG_SET_FIELD(data, RLC_LB_CNTL, RESERVED, 0x80000);\n\tWREG32_SOC15(GC, 0, mmRLC_LB_CNTL, data);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tgfx_v9_0_init_always_on_cu_mask(adev);\n}\n\nstatic void gfx_v9_0_enable_lbpw(struct amdgpu_device *adev, bool enable)\n{\n\tWREG32_FIELD15(GC, 0, RLC_LB_CNTL, LOAD_BALANCE_ENABLE, enable ? 1 : 0);\n}\n\nstatic int gfx_v9_0_cp_jump_table_num(struct amdgpu_device *adev)\n{\n\tif (gfx_v9_0_load_mec2_fw_bin_support(adev))\n\t\treturn 5;\n\telse\n\t\treturn 4;\n}\n\nstatic void gfx_v9_0_init_rlcg_reg_access_ctrl(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_rlcg_reg_access_ctrl *reg_access_ctrl;\n\n\treg_access_ctrl = &adev->gfx.rlc.reg_access_ctrl[0];\n\treg_access_ctrl->scratch_reg0 = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG0);\n\treg_access_ctrl->scratch_reg1 = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG1);\n\treg_access_ctrl->scratch_reg2 = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG2);\n\treg_access_ctrl->scratch_reg3 = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG3);\n\treg_access_ctrl->grbm_cntl = SOC15_REG_OFFSET(GC, 0, mmGRBM_GFX_CNTL);\n\treg_access_ctrl->grbm_idx = SOC15_REG_OFFSET(GC, 0, mmGRBM_GFX_INDEX);\n\treg_access_ctrl->spare_int = SOC15_REG_OFFSET(GC, 0, mmRLC_SPARE_INT);\n\tadev->gfx.rlc.rlcg_reg_access_supported = true;\n}\n\nstatic int gfx_v9_0_rlc_init(struct amdgpu_device *adev)\n{\n\tconst struct cs_section_def *cs_data;\n\tint r;\n\n\tadev->gfx.rlc.cs_data = gfx9_cs_data;\n\n\tcs_data = adev->gfx.rlc.cs_data;\n\n\tif (cs_data) {\n\t\t \n\t\tr = amdgpu_gfx_rlc_init_csb(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (adev->flags & AMD_IS_APU) {\n\t\t \n\t\tadev->gfx.rlc.cp_table_size = ALIGN(96 * 5 * 4, 2048) + (64 * 1024);  \n\t\tr = amdgpu_gfx_rlc_init_cpt(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v9_0_mec_fini(struct amdgpu_device *adev)\n{\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.hpd_eop_obj, NULL, NULL);\n\tamdgpu_bo_free_kernel(&adev->gfx.mec.mec_fw_obj, NULL, NULL);\n}\n\nstatic int gfx_v9_0_mec_init(struct amdgpu_device *adev)\n{\n\tint r;\n\tu32 *hpd;\n\tconst __le32 *fw_data;\n\tunsigned fw_size;\n\tu32 *fw;\n\tsize_t mec_hpd_size;\n\n\tconst struct gfx_firmware_header_v1_0 *mec_hdr;\n\n\tbitmap_zero(adev->gfx.mec_bitmap[0].queue_bitmap, AMDGPU_MAX_COMPUTE_QUEUES);\n\n\t \n\tamdgpu_gfx_compute_queue_acquire(adev);\n\tmec_hpd_size = adev->gfx.num_compute_rings * GFX9_MEC_HPD_SIZE;\n\tif (mec_hpd_size) {\n\t\tr = amdgpu_bo_create_reserved(adev, mec_hpd_size, PAGE_SIZE,\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM |\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_obj,\n\t\t\t\t\t      &adev->gfx.mec.hpd_eop_gpu_addr,\n\t\t\t\t\t      (void **)&hpd);\n\t\tif (r) {\n\t\t\tdev_warn(adev->dev, \"(%d) create HDP EOP bo failed\\n\", r);\n\t\t\tgfx_v9_0_mec_fini(adev);\n\t\t\treturn r;\n\t\t}\n\n\t\tmemset(hpd, 0, mec_hpd_size);\n\n\t\tamdgpu_bo_kunmap(adev->gfx.mec.hpd_eop_obj);\n\t\tamdgpu_bo_unreserve(adev->gfx.mec.hpd_eop_obj);\n\t}\n\n\tmec_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.mec_fw->data +\n\t\t le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(mec_hdr->header.ucode_size_bytes);\n\n\tr = amdgpu_bo_create_reserved(adev, mec_hdr->header.ucode_size_bytes,\n\t\t\t\t      PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t      &adev->gfx.mec.mec_fw_obj,\n\t\t\t\t      &adev->gfx.mec.mec_fw_gpu_addr,\n\t\t\t\t      (void **)&fw);\n\tif (r) {\n\t\tdev_warn(adev->dev, \"(%d) create mec firmware bo failed\\n\", r);\n\t\tgfx_v9_0_mec_fini(adev);\n\t\treturn r;\n\t}\n\n\tmemcpy(fw, fw_data, fw_size);\n\n\tamdgpu_bo_kunmap(adev->gfx.mec.mec_fw_obj);\n\tamdgpu_bo_unreserve(adev->gfx.mec.mec_fw_obj);\n\n\treturn 0;\n}\n\nstatic uint32_t wave_read_ind(struct amdgpu_device *adev, uint32_t simd, uint32_t wave, uint32_t address)\n{\n\tWREG32_SOC15_RLC(GC, 0, mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(address << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK));\n\treturn RREG32_SOC15(GC, 0, mmSQ_IND_DATA);\n}\n\nstatic void wave_read_regs(struct amdgpu_device *adev, uint32_t simd,\n\t\t\t   uint32_t wave, uint32_t thread,\n\t\t\t   uint32_t regno, uint32_t num, uint32_t *out)\n{\n\tWREG32_SOC15_RLC(GC, 0, mmSQ_IND_INDEX,\n\t\t(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |\n\t\t(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |\n\t\t(regno << SQ_IND_INDEX__INDEX__SHIFT) |\n\t\t(thread << SQ_IND_INDEX__THREAD_ID__SHIFT) |\n\t\t(SQ_IND_INDEX__FORCE_READ_MASK) |\n\t\t(SQ_IND_INDEX__AUTO_INCR_MASK));\n\twhile (num--)\n\t\t*(out++) = RREG32_SOC15(GC, 0, mmSQ_IND_DATA);\n}\n\nstatic void gfx_v9_0_read_wave_data(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd, uint32_t wave, uint32_t *dst, int *no_fields)\n{\n\t \n\tdst[(*no_fields)++] = 1;\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_STATUS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_PC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_LO);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_EXEC_HI);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_HW_ID);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_INST_DW1);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_GPR_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_LDS_ALLOC);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_TRAPSTS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_STS);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_IB_DBG0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_M0);\n\tdst[(*no_fields)++] = wave_read_ind(adev, simd, wave, ixSQ_WAVE_MODE);\n}\n\nstatic void gfx_v9_0_read_wave_sgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t     uint32_t wave, uint32_t start,\n\t\t\t\t     uint32_t size, uint32_t *dst)\n{\n\twave_read_regs(\n\t\tadev, simd, wave, 0,\n\t\tstart + SQIND_WAVE_SGPRS_OFFSET, size, dst);\n}\n\nstatic void gfx_v9_0_read_wave_vgprs(struct amdgpu_device *adev, uint32_t xcc_id, uint32_t simd,\n\t\t\t\t     uint32_t wave, uint32_t thread,\n\t\t\t\t     uint32_t start, uint32_t size,\n\t\t\t\t     uint32_t *dst)\n{\n\twave_read_regs(\n\t\tadev, simd, wave, thread,\n\t\tstart + SQIND_WAVE_VGPRS_OFFSET, size, dst);\n}\n\nstatic void gfx_v9_0_select_me_pipe_q(struct amdgpu_device *adev,\n\t\t\t\t  u32 me, u32 pipe, u32 q, u32 vm, u32 xcc_id)\n{\n\tsoc15_grbm_select(adev, me, pipe, q, vm, 0);\n}\n\nstatic const struct amdgpu_gfx_funcs gfx_v9_0_gfx_funcs = {\n        .get_gpu_clock_counter = &gfx_v9_0_get_gpu_clock_counter,\n        .select_se_sh = &gfx_v9_0_select_se_sh,\n        .read_wave_data = &gfx_v9_0_read_wave_data,\n        .read_wave_sgprs = &gfx_v9_0_read_wave_sgprs,\n        .read_wave_vgprs = &gfx_v9_0_read_wave_vgprs,\n        .select_me_pipe_q = &gfx_v9_0_select_me_pipe_q,\n};\n\nconst struct amdgpu_ras_block_hw_ops  gfx_v9_0_ras_ops = {\n\t\t.ras_error_inject = &gfx_v9_0_ras_error_inject,\n\t\t.query_ras_error_count = &gfx_v9_0_query_ras_error_count,\n\t\t.reset_ras_error_count = &gfx_v9_0_reset_ras_error_count,\n};\n\nstatic struct amdgpu_gfx_ras gfx_v9_0_ras = {\n\t.ras_block = {\n\t\t.hw_ops = &gfx_v9_0_ras_ops,\n\t},\n};\n\nstatic int gfx_v9_0_gpu_early_init(struct amdgpu_device *adev)\n{\n\tu32 gb_addr_config;\n\tint err;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = VEGA10_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 1):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = VEGA12_GB_ADDR_CONFIG_GOLDEN;\n\t\tDRM_INFO(\"fix gfx.config for vega12\\n\");\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 0):\n\t\tadev->gfx.ras = &gfx_v9_0_ras;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);\n\t\tgb_addr_config &= ~0xf3e777ff;\n\t\tgb_addr_config |= 0x22014042;\n\t\t \n\t\terr = amdgpu_atomfirmware_get_gfx_info(adev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\tgb_addr_config = RAVEN2_GB_ADDR_CONFIG_GOLDEN;\n\t\telse\n\t\t\tgb_addr_config = RAVEN_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 1):\n\t\tadev->gfx.ras = &gfx_v9_4_ras;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);\n\t\tgb_addr_config &= ~0xf3e777ff;\n\t\tgb_addr_config |= 0x22014042;\n\t\tbreak;\n\tcase IP_VERSION(9, 3, 0):\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x80;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);\n\t\tgb_addr_config &= ~0xf3e777ff;\n\t\tgb_addr_config |= 0x22010042;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 2):\n\t\tadev->gfx.ras = &gfx_v9_4_2_ras;\n\t\tadev->gfx.config.max_hw_contexts = 8;\n\t\tadev->gfx.config.sc_prim_fifo_size_frontend = 0x20;\n\t\tadev->gfx.config.sc_prim_fifo_size_backend = 0x100;\n\t\tadev->gfx.config.sc_hiz_tile_fifo_size = 0x30;\n\t\tadev->gfx.config.sc_earlyz_tile_fifo_size = 0x4C0;\n\t\tgb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);\n\t\tgb_addr_config &= ~0xf3e777ff;\n\t\tgb_addr_config |= 0x22014042;\n\t\t \n\t\terr = amdgpu_atomfirmware_get_gfx_info(adev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tadev->gfx.config.gb_addr_config = gb_addr_config;\n\n\tadev->gfx.config.gb_addr_config_fields.num_pipes = 1 <<\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tNUM_PIPES);\n\n\tadev->gfx.config.max_tile_pipes =\n\t\tadev->gfx.config.gb_addr_config_fields.num_pipes;\n\n\tadev->gfx.config.gb_addr_config_fields.num_banks = 1 <<\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tNUM_BANKS);\n\tadev->gfx.config.gb_addr_config_fields.max_compress_frags = 1 <<\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tMAX_COMPRESSED_FRAGS);\n\tadev->gfx.config.gb_addr_config_fields.num_rb_per_se = 1 <<\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tNUM_RB_PER_SE);\n\tadev->gfx.config.gb_addr_config_fields.num_se = 1 <<\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tNUM_SHADER_ENGINES);\n\tadev->gfx.config.gb_addr_config_fields.pipe_interleave_size = 1 << (8 +\n\t\t\tREG_GET_FIELD(\n\t\t\t\t\tadev->gfx.config.gb_addr_config,\n\t\t\t\t\tGB_ADDR_CONFIG,\n\t\t\t\t\tPIPE_INTERLEAVE_SIZE));\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_compute_ring_init(struct amdgpu_device *adev, int ring_id,\n\t\t\t\t      int mec, int pipe, int queue)\n{\n\tunsigned irq_type;\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[ring_id];\n\tunsigned int hw_prio;\n\n\tring = &adev->gfx.compute_ring[ring_id];\n\n\t \n\tring->me = mec + 1;\n\tring->pipe = pipe;\n\tring->queue = queue;\n\n\tring->ring_obj = NULL;\n\tring->use_doorbell = true;\n\tring->doorbell_index = (adev->doorbell_index.mec_ring0 + ring_id) << 1;\n\tring->eop_gpu_addr = adev->gfx.mec.hpd_eop_gpu_addr\n\t\t\t\t+ (ring_id * GFX9_MEC_HPD_SIZE);\n\tring->vm_hub = AMDGPU_GFXHUB(0);\n\tsprintf(ring->name, \"comp_%d.%d.%d\", ring->me, ring->pipe, ring->queue);\n\n\tirq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP\n\t\t+ ((ring->me - 1) * adev->gfx.mec.num_pipe_per_mec)\n\t\t+ ring->pipe;\n\thw_prio = amdgpu_gfx_is_high_priority_compute_queue(adev, ring) ?\n\t\t\tAMDGPU_RING_PRIO_2 : AMDGPU_RING_PRIO_DEFAULT;\n\t \n\treturn amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq, irq_type,\n\t\t\t\thw_prio, NULL);\n}\n\nstatic int gfx_v9_0_sw_init(void *handle)\n{\n\tint i, j, k, r, ring_id;\n\tstruct amdgpu_ring *ring;\n\tstruct amdgpu_kiq *kiq;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tunsigned int hw_prio;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 2):\n\t\tadev->gfx.mec.num_mec = 2;\n\t\tbreak;\n\tdefault:\n\t\tadev->gfx.mec.num_mec = 1;\n\t\tbreak;\n\t}\n\n\tadev->gfx.mec.num_pipe_per_mec = 4;\n\tadev->gfx.mec.num_queue_per_pipe = 8;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_EOP_INTERRUPT, &adev->gfx.eop_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_PRIV_REG_FAULT,\n\t\t\t      &adev->gfx.priv_reg_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_PRIV_INSTR_FAULT,\n\t\t\t      &adev->gfx.priv_inst_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_ECC_ERROR,\n\t\t\t      &adev->gfx.cp_ecc_error_irq);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_FUE_ERROR,\n\t\t\t      &adev->gfx.cp_ecc_error_irq);\n\tif (r)\n\t\treturn r;\n\n\tadev->gfx.gfx_current_status = AMDGPU_GFX_NORMAL_MODE;\n\n\tif (adev->gfx.rlc.funcs) {\n\t\tif (adev->gfx.rlc.funcs->init) {\n\t\t\tr = adev->gfx.rlc.funcs->init(adev);\n\t\t\tif (r) {\n\t\t\t\tdev_err(adev->dev, \"Failed to init rlc BOs!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\tr = gfx_v9_0_mec_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init MEC BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++) {\n\t\tring = &adev->gfx.gfx_ring[i];\n\t\tring->ring_obj = NULL;\n\t\tif (!i)\n\t\t\tsprintf(ring->name, \"gfx\");\n\t\telse\n\t\t\tsprintf(ring->name, \"gfx_%d\", i);\n\t\tring->use_doorbell = true;\n\t\tring->doorbell_index = adev->doorbell_index.gfx_ring0 << 1;\n\n\t\t \n\t\tring->no_scheduler = true;\n\t\tring->vm_hub = AMDGPU_GFXHUB(0);\n\t\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq,\n\t\t\t\t     AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP,\n\t\t\t\t     AMDGPU_RING_PRIO_DEFAULT, NULL);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (adev->gfx.num_gfx_rings) {\n\t\tfor (i = 0; i < GFX9_NUM_SW_GFX_RINGS; i++) {\n\t\t\tring = &adev->gfx.sw_gfx_ring[i];\n\t\t\tring->ring_obj = NULL;\n\t\t\tsprintf(ring->name, amdgpu_sw_ring_name(i));\n\t\t\tring->use_doorbell = true;\n\t\t\tring->doorbell_index = adev->doorbell_index.gfx_ring0 << 1;\n\t\t\tring->is_sw_ring = true;\n\t\t\thw_prio = amdgpu_sw_ring_priority(i);\n\t\t\tring->vm_hub = AMDGPU_GFXHUB(0);\n\t\t\tr = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq,\n\t\t\t\t\t     AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP, hw_prio,\n\t\t\t\t\t     NULL);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tring->wptr = 0;\n\t\t}\n\n\t\t \n\t\tr = amdgpu_ring_mux_init(&adev->gfx.muxer, &adev->gfx.gfx_ring[0],\n\t\t\t\t\t GFX9_NUM_SW_GFX_RINGS);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"amdgpu_ring_mux_init failed(%d)\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tfor (i = 0; i < GFX9_NUM_SW_GFX_RINGS; i++) {\n\t\t\tr = amdgpu_ring_mux_add_sw_ring(&adev->gfx.muxer,\n\t\t\t\t\t\t\t&adev->gfx.sw_gfx_ring[i]);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"amdgpu_ring_mux_add_sw_ring failed(%d)\\n\", r);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tring_id = 0;\n\tfor (i = 0; i < adev->gfx.mec.num_mec; ++i) {\n\t\tfor (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) {\n\t\t\tfor (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) {\n\t\t\t\tif (!amdgpu_gfx_is_mec_queue_enabled(adev, 0, i,\n\t\t\t\t\t\t\t\t     k, j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tr = gfx_v9_0_compute_ring_init(adev,\n\t\t\t\t\t\t\t       ring_id,\n\t\t\t\t\t\t\t       i, k, j);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\n\t\t\t\tring_id++;\n\t\t\t}\n\t\t}\n\t}\n\n\tr = amdgpu_gfx_kiq_init(adev, GFX9_MEC_HPD_SIZE, 0);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init KIQ BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tkiq = &adev->gfx.kiq[0];\n\tr = amdgpu_gfx_kiq_init_ring(adev, &kiq->ring, &kiq->irq, 0);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = amdgpu_gfx_mqd_sw_init(adev, sizeof(struct v9_mqd_allocation), 0);\n\tif (r)\n\t\treturn r;\n\n\tadev->gfx.ce_ram_size = 0x8000;\n\n\tr = gfx_v9_0_gpu_early_init(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (amdgpu_gfx_ras_sw_init(adev)) {\n\t\tdev_err(adev->dev, \"Failed to initialize gfx ras block!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int gfx_v9_0_sw_fini(void *handle)\n{\n\tint i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->gfx.num_gfx_rings) {\n\t\tfor (i = 0; i < GFX9_NUM_SW_GFX_RINGS; i++)\n\t\t\tamdgpu_ring_fini(&adev->gfx.sw_gfx_ring[i]);\n\t\tamdgpu_ring_mux_fini(&adev->gfx.muxer);\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.gfx_ring[i]);\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tamdgpu_ring_fini(&adev->gfx.compute_ring[i]);\n\n\tamdgpu_gfx_mqd_sw_fini(adev, 0);\n\tamdgpu_gfx_kiq_free_ring(&adev->gfx.kiq[0].ring);\n\tamdgpu_gfx_kiq_fini(adev, 0);\n\n\tgfx_v9_0_mec_fini(adev);\n\tamdgpu_bo_free_kernel(&adev->gfx.rlc.clear_state_obj,\n\t\t\t\t&adev->gfx.rlc.clear_state_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cs_ptr);\n\tif (adev->flags & AMD_IS_APU) {\n\t\tamdgpu_bo_free_kernel(&adev->gfx.rlc.cp_table_obj,\n\t\t\t\t&adev->gfx.rlc.cp_table_gpu_addr,\n\t\t\t\t(void **)&adev->gfx.rlc.cp_table_ptr);\n\t}\n\tgfx_v9_0_free_microcode(adev);\n\n\treturn 0;\n}\n\n\nstatic void gfx_v9_0_tiling_mode_table_init(struct amdgpu_device *adev)\n{\n\t \n}\n\nvoid gfx_v9_0_select_se_sh(struct amdgpu_device *adev, u32 se_num, u32 sh_num,\n\t\t\t   u32 instance, int xcc_id)\n{\n\tu32 data;\n\n\tif (instance == 0xffffffff)\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_INDEX, instance);\n\n\tif (se_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_INDEX, se_num);\n\n\tif (sh_num == 0xffffffff)\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_BROADCAST_WRITES, 1);\n\telse\n\t\tdata = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_INDEX, sh_num);\n\n\tWREG32_SOC15_RLC_SHADOW(GC, 0, mmGRBM_GFX_INDEX, data);\n}\n\nstatic u32 gfx_v9_0_get_rb_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata = RREG32_SOC15(GC, 0, mmCC_RB_BACKEND_DISABLE);\n\tdata |= RREG32_SOC15(GC, 0, mmGC_USER_RB_BACKEND_DISABLE);\n\n\tdata &= CC_RB_BACKEND_DISABLE__BACKEND_DISABLE_MASK;\n\tdata >>= GC_USER_RB_BACKEND_DISABLE__BACKEND_DISABLE__SHIFT;\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_backends_per_se /\n\t\t\t\t\t adev->gfx.config.max_sh_per_se);\n\n\treturn (~data) & mask;\n}\n\nstatic void gfx_v9_0_setup_rb(struct amdgpu_device *adev)\n{\n\tint i, j;\n\tu32 data;\n\tu32 active_rbs = 0;\n\tu32 rb_bitmap_width_per_sh = adev->gfx.config.max_backends_per_se /\n\t\t\t\t\tadev->gfx.config.max_sh_per_se;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tamdgpu_gfx_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tdata = gfx_v9_0_get_rb_active_bitmap(adev);\n\t\t\tactive_rbs |= data << ((i * adev->gfx.config.max_sh_per_se + j) *\n\t\t\t\t\t       rb_bitmap_width_per_sh);\n\t\t}\n\t}\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tadev->gfx.config.backend_enable_mask = active_rbs;\n\tadev->gfx.config.num_rbs = hweight32(active_rbs);\n}\n\nstatic void gfx_v9_0_debug_trap_config_init(struct amdgpu_device *adev,\n\t\t\t\tuint32_t first_vmid,\n\t\t\t\tuint32_t last_vmid)\n{\n\tuint32_t data;\n\tuint32_t trap_config_vmid_mask = 0;\n\tint i;\n\n\t \n\tfor (i = first_vmid; i < last_vmid; i++)\n\t\ttrap_config_vmid_mask |= (1 << i);\n\n\tdata = REG_SET_FIELD(0, SPI_GDBG_TRAP_CONFIG,\n\t\t\tVMID_SEL, trap_config_vmid_mask);\n\tdata = REG_SET_FIELD(data, SPI_GDBG_TRAP_CONFIG,\n\t\t\tTRAP_EN, 1);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_CONFIG), data);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_MASK), 0);\n\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_DATA0), 0);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmSPI_GDBG_TRAP_DATA1), 0);\n}\n\n#define DEFAULT_SH_MEM_BASES\t(0x6000)\nstatic void gfx_v9_0_init_compute_vmid(struct amdgpu_device *adev)\n{\n\tint i;\n\tuint32_t sh_mem_config;\n\tuint32_t sh_mem_bases;\n\n\t \n\tsh_mem_bases = DEFAULT_SH_MEM_BASES | (DEFAULT_SH_MEM_BASES << 16);\n\n\tsh_mem_config = SH_MEM_ADDRESS_MODE_64 |\n\t\t\tSH_MEM_ALIGNMENT_MODE_UNALIGNED <<\n\t\t\tSH_MEM_CONFIG__ALIGNMENT_MODE__SHIFT;\n\n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tsoc15_grbm_select(adev, 0, 0, 0, i, 0);\n\t\t \n\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, sh_mem_config);\n\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, sh_mem_bases);\n\t}\n\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\tmutex_unlock(&adev->srbm_mutex);\n\n\t \n\tfor (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) {\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_BASE, 2 * i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_SIZE, 2 * i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_GWS_VMID0, i, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_OA_VMID0, i, 0);\n\t}\n}\n\nstatic void gfx_v9_0_init_gds_vmid(struct amdgpu_device *adev)\n{\n\tint vmid;\n\n\t \n\tfor (vmid = 1; vmid < AMDGPU_NUM_VMID; vmid++) {\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_BASE, 2 * vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_SIZE, 2 * vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_GWS_VMID0, vmid, 0);\n\t\tWREG32_SOC15_OFFSET(GC, 0, mmGDS_OA_VMID0, vmid, 0);\n\t}\n}\n\nstatic void gfx_v9_0_init_sq_config(struct amdgpu_device *adev)\n{\n\tuint32_t tmp;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 4, 1):\n\t\ttmp = RREG32_SOC15(GC, 0, mmSQ_CONFIG);\n\t\ttmp = REG_SET_FIELD(tmp, SQ_CONFIG, DISABLE_BARRIER_WAITCNT,\n\t\t\t\t!READ_ONCE(adev->barrier_has_auto_waitcnt));\n\t\tWREG32_SOC15(GC, 0, mmSQ_CONFIG, tmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v9_0_constants_init(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\tint i;\n\n\tWREG32_FIELD15_RLC(GC, 0, GRBM_CNTL, READ_TIMEOUT, 0xff);\n\n\tgfx_v9_0_tiling_mode_table_init(adev);\n\n\tif (adev->gfx.num_gfx_rings)\n\t\tgfx_v9_0_setup_rb(adev);\n\tgfx_v9_0_get_cu_info(adev, &adev->gfx.cu_info);\n\tadev->gfx.config.db_debug2 = RREG32_SOC15(GC, 0, mmDB_DEBUG2);\n\n\t \n\t \n\tmutex_lock(&adev->srbm_mutex);\n\tfor (i = 0; i < adev->vm_manager.id_mgr[AMDGPU_GFXHUB(0)].num_ids; i++) {\n\t\tsoc15_grbm_select(adev, 0, 0, 0, i, 0);\n\t\t \n\t\tif (i == 0) {\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_CONFIG, ALIGNMENT_MODE,\n\t\t\t\t\t    SH_MEM_ALIGNMENT_MODE_UNALIGNED);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, RETRY_DISABLE,\n\t\t\t\t\t    !!adev->gmc.noretry);\n\t\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, tmp);\n\t\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, 0);\n\t\t} else {\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_CONFIG, ALIGNMENT_MODE,\n\t\t\t\t\t    SH_MEM_ALIGNMENT_MODE_UNALIGNED);\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_CONFIG, RETRY_DISABLE,\n\t\t\t\t\t    !!adev->gmc.noretry);\n\t\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, tmp);\n\t\t\ttmp = REG_SET_FIELD(0, SH_MEM_BASES, PRIVATE_BASE,\n\t\t\t\t(adev->gmc.private_aperture_start >> 48));\n\t\t\ttmp = REG_SET_FIELD(tmp, SH_MEM_BASES, SHARED_BASE,\n\t\t\t\t(adev->gmc.shared_aperture_start >> 48));\n\t\t\tWREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, tmp);\n\t\t}\n\t}\n\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\n\tmutex_unlock(&adev->srbm_mutex);\n\n\tgfx_v9_0_init_compute_vmid(adev);\n\tgfx_v9_0_init_gds_vmid(adev);\n\tgfx_v9_0_init_sq_config(adev);\n}\n\nstatic void gfx_v9_0_wait_for_rlc_serdes(struct amdgpu_device *adev)\n{\n\tu32 i, j, k;\n\tu32 mask;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tamdgpu_gfx_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\t\t\tif (RREG32_SOC15(GC, 0, mmRLC_SERDES_CU_MASTER_BUSY) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tif (k == adev->usec_timeout) {\n\t\t\t\tamdgpu_gfx_select_se_sh(adev, 0xffffffff,\n\t\t\t\t\t\t      0xffffffff, 0xffffffff, 0);\n\t\t\t\tmutex_unlock(&adev->grbm_idx_mutex);\n\t\t\t\tDRM_INFO(\"Timeout wait for RLC serdes %u,%u\\n\",\n\t\t\t\t\t i, j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tmask = RLC_SERDES_NONCU_MASTER_BUSY__SE_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__GC_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC0_MASTER_BUSY_MASK |\n\t\tRLC_SERDES_NONCU_MASTER_BUSY__TC1_MASTER_BUSY_MASK;\n\tfor (k = 0; k < adev->usec_timeout; k++) {\n\t\tif ((RREG32_SOC15(GC, 0, mmRLC_SERDES_NONCU_MASTER_BUSY) & mask) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v9_0_enable_gui_idle_interrupt(struct amdgpu_device *adev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 tmp;\n\n\t \n\n\ttmp= RREG32_SOC15(GC, 0, mmCP_INT_CNTL_RING0);\n\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_BUSY_INT_ENABLE, enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CNTX_EMPTY_INT_ENABLE, enable ? 1 : 0);\n\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, CMP_BUSY_INT_ENABLE, enable ? 1 : 0);\n\tif(adev->gfx.num_gfx_rings)\n\t\ttmp = REG_SET_FIELD(tmp, CP_INT_CNTL_RING0, GFX_IDLE_INT_ENABLE, enable ? 1 : 0);\n\n\tWREG32_SOC15(GC, 0, mmCP_INT_CNTL_RING0, tmp);\n}\n\nstatic void gfx_v9_0_init_csb(struct amdgpu_device *adev)\n{\n\tadev->gfx.rlc.funcs->get_csb_buffer(adev, adev->gfx.rlc.cs_ptr);\n\t \n\tWREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_ADDR_HI),\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr >> 32);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_ADDR_LO),\n\t\t\tadev->gfx.rlc.clear_state_gpu_addr & 0xfffffffc);\n\tWREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_LENGTH),\n\t\t\tadev->gfx.rlc.clear_state_size);\n}\n\nstatic void gfx_v9_1_parse_ind_reg_list(int *register_list_format,\n\t\t\t\tint indirect_offset,\n\t\t\t\tint list_size,\n\t\t\t\tint *unique_indirect_regs,\n\t\t\t\tint unique_indirect_reg_count,\n\t\t\t\tint *indirect_start_offsets,\n\t\t\t\tint *indirect_start_offsets_count,\n\t\t\t\tint max_start_offsets_count)\n{\n\tint idx;\n\n\tfor (; indirect_offset < list_size; indirect_offset++) {\n\t\tWARN_ON(*indirect_start_offsets_count >= max_start_offsets_count);\n\t\tindirect_start_offsets[*indirect_start_offsets_count] = indirect_offset;\n\t\t*indirect_start_offsets_count = *indirect_start_offsets_count + 1;\n\n\t\twhile (register_list_format[indirect_offset] != 0xFFFFFFFF) {\n\t\t\tindirect_offset += 2;\n\n\t\t\t \n\t\t\tfor (idx = 0; idx < unique_indirect_reg_count; idx++) {\n\t\t\t\tif (unique_indirect_regs[idx] ==\n\t\t\t\t\tregister_list_format[indirect_offset] ||\n\t\t\t\t\t!unique_indirect_regs[idx])\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBUG_ON(idx >= unique_indirect_reg_count);\n\n\t\t\tif (!unique_indirect_regs[idx])\n\t\t\t\tunique_indirect_regs[idx] = register_list_format[indirect_offset];\n\n\t\t\tindirect_offset++;\n\t\t}\n\t}\n}\n\nstatic int gfx_v9_1_init_rlc_save_restore_list(struct amdgpu_device *adev)\n{\n\tint unique_indirect_regs[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\tint unique_indirect_reg_count = 0;\n\n\tint indirect_start_offsets[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\tint indirect_start_offsets_count = 0;\n\n\tint list_size = 0;\n\tint i = 0, j = 0;\n\tu32 tmp = 0;\n\n\tu32 *register_list_format =\n\t\tkmemdup(adev->gfx.rlc.register_list_format,\n\t\t\tadev->gfx.rlc.reg_list_format_size_bytes, GFP_KERNEL);\n\tif (!register_list_format)\n\t\treturn -ENOMEM;\n\n\t \n\tunique_indirect_reg_count = ARRAY_SIZE(unique_indirect_regs);\n\tgfx_v9_1_parse_ind_reg_list(register_list_format,\n\t\t\t\t    adev->gfx.rlc.reg_list_format_direct_reg_list_length,\n\t\t\t\t    adev->gfx.rlc.reg_list_format_size_bytes >> 2,\n\t\t\t\t    unique_indirect_regs,\n\t\t\t\t    unique_indirect_reg_count,\n\t\t\t\t    indirect_start_offsets,\n\t\t\t\t    &indirect_start_offsets_count,\n\t\t\t\t    ARRAY_SIZE(indirect_start_offsets));\n\n\t \n\ttmp = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_CNTL));\n\ttmp |= RLC_SRM_CNTL__AUTO_INCR_ADDR_MASK;\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_CNTL), tmp);\n\n\t \n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_ARAM_ADDR),\n\t\tRLC_SAVE_RESTORE_ADDR_STARTING_OFFSET);\n\tfor (i = 0; i < adev->gfx.rlc.reg_list_size_bytes >> 2; i++)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_ARAM_DATA),\n\t\t\tadev->gfx.rlc.register_restore[i]);\n\n\t \n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),\n\t\tadev->gfx.rlc.reg_list_format_start);\n\n\t \n\tfor (i = 0; i < adev->gfx.rlc.reg_list_format_direct_reg_list_length; i++)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA),\n\t\t\tregister_list_format[i]);\n\n\t \n\twhile (i < (adev->gfx.rlc.reg_list_format_size_bytes >> 2)) {\n\t\tif (register_list_format[i] == 0xFFFFFFFF) {\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, register_list_format[i++]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, register_list_format[i++]);\n\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, register_list_format[i++]);\n\n\t\tfor (j = 0; j < unique_indirect_reg_count; j++) {\n\t\t\tif (register_list_format[i] == unique_indirect_regs[j]) {\n\t\t\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tBUG_ON(j >= unique_indirect_reg_count);\n\n\t\ti++;\n\t}\n\n\t \n\tlist_size = adev->gfx.rlc.reg_list_size_bytes >> 2;\n\tlist_size = list_size >> 1;\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),\n\t\tadev->gfx.rlc.reg_restore_list_size);\n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA), list_size);\n\n\t \n\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),\n\t\tadev->gfx.rlc.starting_offsets_start);\n\tfor (i = 0; i < ARRAY_SIZE(indirect_start_offsets); i++)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA),\n\t\t       indirect_start_offsets[i]);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(unique_indirect_regs); i++) {\n\t\tif (unique_indirect_regs[i] != 0) {\n\t\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_INDEX_CNTL_ADDR_0)\n\t\t\t       + GFX_RLC_SRM_INDEX_CNTL_ADDR_OFFSETS[i],\n\t\t\t       unique_indirect_regs[i] & 0x3FFFF);\n\n\t\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_INDEX_CNTL_DATA_0)\n\t\t\t       + GFX_RLC_SRM_INDEX_CNTL_DATA_OFFSETS[i],\n\t\t\t       unique_indirect_regs[i] >> 20);\n\t\t}\n\t}\n\n\tkfree(register_list_format);\n\treturn 0;\n}\n\nstatic void gfx_v9_0_enable_save_restore_machine(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD15(GC, 0, RLC_SRM_CNTL, SRM_ENABLE, 1);\n}\n\nstatic void pwr_10_0_gfxip_control_over_cgpg(struct amdgpu_device *adev,\n\t\t\t\t\t     bool enable)\n{\n\tuint32_t data = 0;\n\tuint32_t default_data = 0;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS));\n\tif (enable) {\n\t\t \n\t\tdata |= PWR_MISC_CNTL_STATUS__PWR_GFX_RLC_CGPG_EN_MASK;\n\t\tif(default_data != data)\n\t\t\tWREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);\n\n\t\t \n\t\tdata &= ~PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS_MASK;\n\t\tdata |= (2 << PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS__SHIFT);\n\t\tif(default_data != data)\n\t\t\tWREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);\n\t} else {\n\t\t \n\t\tdata &= ~PWR_MISC_CNTL_STATUS__PWR_GFX_RLC_CGPG_EN_MASK;\n\t\tif(default_data != data)\n\t\t\tWREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);\n\t}\n}\n\nstatic void gfx_v9_0_init_gfx_power_gating(struct amdgpu_device *adev)\n{\n\tuint32_t data = 0;\n\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |\n\t\t\t      AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t      AMD_PG_SUPPORT_GFX_DMG)) {\n\t\t \n\t\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmCP_RB_WPTR_POLL_CNTL));\n\t\tdata &= ~CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT_MASK;\n\t\tdata |= (0x60 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmCP_RB_WPTR_POLL_CNTL), data);\n\n\t\t \n\t\tdata = 0;\n\t\tdata |= (0x10 << RLC_PG_DELAY__POWER_UP_DELAY__SHIFT);\n\t\tdata |= (0x10 << RLC_PG_DELAY__POWER_DOWN_DELAY__SHIFT);\n\t\tdata |= (0x10 << RLC_PG_DELAY__CMD_PROPAGATE_DELAY__SHIFT);\n\t\tdata |= (0x40 << RLC_PG_DELAY__MEM_SLEEP_DELAY__SHIFT);\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY), data);\n\n\t\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_2));\n\t\tdata &= ~RLC_PG_DELAY_2__SERDES_CMD_DELAY_MASK;\n\t\tdata |= (0x4 << RLC_PG_DELAY_2__SERDES_CMD_DELAY__SHIFT);\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_2), data);\n\n\t\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_3));\n\t\tdata &= ~RLC_PG_DELAY_3__CGCG_ACTIVE_BEFORE_CGPG_MASK;\n\t\tdata |= (0xff << RLC_PG_DELAY_3__CGCG_ACTIVE_BEFORE_CGPG__SHIFT);\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_3), data);\n\n\t\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_AUTO_PG_CTRL));\n\t\tdata &= ~RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD_MASK;\n\n\t\t \n\t\tdata |= (0x55f0 << RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD__SHIFT);\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_AUTO_PG_CTRL), data);\n\t\tif (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 3, 0))\n\t\t\tpwr_10_0_gfxip_control_over_cgpg(adev, true);\n\t}\n}\n\nstatic void gfx_v9_0_enable_sck_slow_down_on_power_up(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tuint32_t data = 0;\n\tuint32_t default_data = 0;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     SMU_CLK_SLOWDOWN_ON_PU_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif (default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_enable_sck_slow_down_on_power_down(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tuint32_t data = 0;\n\tuint32_t default_data = 0;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     SMU_CLK_SLOWDOWN_ON_PD_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_enable_cp_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\tbool enable)\n{\n\tuint32_t data = 0;\n\tuint32_t default_data = 0;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     CP_PG_DISABLE,\n\t\t\t     enable ? 0 : 1);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_enable_gfx_cg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tuint32_t data, default_data;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     GFX_POWER_GATING_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_enable_gfx_pipeline_powergating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tuint32_t data, default_data;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     GFX_PIPELINE_PG_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n\n\tif (!enable)\n\t\t \n\t\tdata = RREG32(SOC15_REG_OFFSET(GC, 0, mmDB_RENDER_CONTROL));\n}\n\nstatic void gfx_v9_0_enable_gfx_static_mg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t       bool enable)\n{\n\tuint32_t data, default_data;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     STATIC_PER_CU_PG_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_enable_gfx_dynamic_mg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tuint32_t data, default_data;\n\n\tdefault_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));\n\tdata = REG_SET_FIELD(data, RLC_PG_CNTL,\n\t\t\t     DYN_PER_CU_PG_ENABLE,\n\t\t\t     enable ? 1 : 0);\n\tif(default_data != data)\n\t\tWREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);\n}\n\nstatic void gfx_v9_0_init_pg(struct amdgpu_device *adev)\n{\n\tgfx_v9_0_init_csb(adev);\n\n\t \n\tif (adev->gfx.rlc.is_rlc_v2_1) {\n\t\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 2, 1) ||\n\t\t    (adev->apu_flags & AMD_APU_IS_RAVEN2))\n\t\t\tgfx_v9_1_init_rlc_save_restore_list(adev);\n\t\tgfx_v9_0_enable_save_restore_machine(adev);\n\t}\n\n\tif (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |\n\t\t\t      AMD_PG_SUPPORT_GFX_SMG |\n\t\t\t      AMD_PG_SUPPORT_GFX_DMG |\n\t\t\t      AMD_PG_SUPPORT_CP |\n\t\t\t      AMD_PG_SUPPORT_GDS |\n\t\t\t      AMD_PG_SUPPORT_RLC_SMU_HS)) {\n\t\tWREG32_SOC15(GC, 0, mmRLC_JUMP_TABLE_RESTORE,\n\t\t\t     adev->gfx.rlc.cp_table_gpu_addr >> 8);\n\t\tgfx_v9_0_init_gfx_power_gating(adev);\n\t}\n}\n\nstatic void gfx_v9_0_rlc_stop(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD15(GC, 0, RLC_CNTL, RLC_ENABLE_F32, 0);\n\tgfx_v9_0_enable_gui_idle_interrupt(adev, false);\n\tgfx_v9_0_wait_for_rlc_serdes(adev);\n}\n\nstatic void gfx_v9_0_rlc_reset(struct amdgpu_device *adev)\n{\n\tWREG32_FIELD15(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 1);\n\tudelay(50);\n\tWREG32_FIELD15(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 0);\n\tudelay(50);\n}\n\nstatic void gfx_v9_0_rlc_start(struct amdgpu_device *adev)\n{\n#ifdef AMDGPU_RLC_DEBUG_RETRY\n\tu32 rlc_ucode_ver;\n#endif\n\n\tWREG32_FIELD15(GC, 0, RLC_CNTL, RLC_ENABLE_F32, 1);\n\tudelay(50);\n\n\t \n\tif (!(adev->flags & AMD_IS_APU)) {\n\t\tgfx_v9_0_enable_gui_idle_interrupt(adev, true);\n\t\tudelay(50);\n\t}\n\n#ifdef AMDGPU_RLC_DEBUG_RETRY\n\t \n\trlc_ucode_ver = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_6);\n\tif(rlc_ucode_ver == 0x108) {\n\t\tDRM_INFO(\"Using rlc debug ucode. mmRLC_GPM_GENERAL_6 ==0x08%x / fw_ver == %i \\n\",\n\t\t\t\trlc_ucode_ver, adev->gfx.rlc_fw_version);\n\t\t \n\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_TIMER_INT_3, 0x9C4);\n\t\t \n\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_12, 0x100);\n\t}\n#endif\n}\n\nstatic int gfx_v9_0_rlc_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct rlc_firmware_header_v2_0 *hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tif (!adev->gfx.rlc_fw)\n\t\treturn -EINVAL;\n\n\thdr = (const struct rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;\n\tamdgpu_ucode_print_rlc_hdr(&hdr->header);\n\n\tfw_data = (const __le32 *)(adev->gfx.rlc_fw->data +\n\t\t\t   le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\n\tWREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_ADDR,\n\t\t\tRLCG_UCODE_LOADING_START_ADDRESS);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_ADDR, adev->gfx.rlc_fw_version);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_rlc_resume(struct amdgpu_device *adev)\n{\n\tint r;\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tgfx_v9_0_init_csb(adev);\n\t\treturn 0;\n\t}\n\n\tadev->gfx.rlc.funcs->stop(adev);\n\n\t \n\tWREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, 0);\n\n\tgfx_v9_0_init_pg(adev);\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\t \n\t\tr = gfx_v9_0_rlc_load_microcode(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\t\tgfx_v9_0_init_lbpw(adev);\n\t\tif (amdgpu_lbpw == 0)\n\t\t\tgfx_v9_0_enable_lbpw(adev, false);\n\t\telse\n\t\t\tgfx_v9_0_enable_lbpw(adev, true);\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 0):\n\t\tgfx_v9_4_init_lbpw(adev);\n\t\tif (amdgpu_lbpw > 0)\n\t\t\tgfx_v9_0_enable_lbpw(adev, true);\n\t\telse\n\t\t\tgfx_v9_0_enable_lbpw(adev, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tgfx_v9_0_update_spm_vmid_internal(adev, 0xf);\n\n\tadev->gfx.rlc.funcs->start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v9_0_cp_gfx_enable(struct amdgpu_device *adev, bool enable)\n{\n\tu32 tmp = RREG32_SOC15(GC, 0, mmCP_ME_CNTL);\n\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, ME_HALT, enable ? 0 : 1);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, PFP_HALT, enable ? 0 : 1);\n\ttmp = REG_SET_FIELD(tmp, CP_ME_CNTL, CE_HALT, enable ? 0 : 1);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_ME_CNTL, tmp);\n\tudelay(50);\n}\n\nstatic int gfx_v9_0_cp_gfx_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v1_0 *pfp_hdr;\n\tconst struct gfx_firmware_header_v1_0 *ce_hdr;\n\tconst struct gfx_firmware_header_v1_0 *me_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i, fw_size;\n\n\tif (!adev->gfx.me_fw || !adev->gfx.pfp_fw || !adev->gfx.ce_fw)\n\t\treturn -EINVAL;\n\n\tpfp_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\tadev->gfx.pfp_fw->data;\n\tce_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\tadev->gfx.ce_fw->data;\n\tme_hdr = (const struct gfx_firmware_header_v1_0 *)\n\t\tadev->gfx.me_fw->data;\n\n\tamdgpu_ucode_print_gfx_hdr(&pfp_hdr->header);\n\tamdgpu_ucode_print_gfx_hdr(&ce_hdr->header);\n\tamdgpu_ucode_print_gfx_hdr(&me_hdr->header);\n\n\tgfx_v9_0_cp_gfx_enable(adev, false);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.pfp_fw->data +\n\t\t le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;\n\tWREG32_SOC15(GC, 0, mmCP_PFP_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32_SOC15(GC, 0, mmCP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32_SOC15(GC, 0, mmCP_PFP_UCODE_ADDR, adev->gfx.pfp_fw_version);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.ce_fw->data +\n\t\t le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;\n\tWREG32_SOC15(GC, 0, mmCP_CE_UCODE_ADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32_SOC15(GC, 0, mmCP_CE_UCODE_DATA, le32_to_cpup(fw_data++));\n\tWREG32_SOC15(GC, 0, mmCP_CE_UCODE_ADDR, adev->gfx.ce_fw_version);\n\n\t \n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.me_fw->data +\n\t\t le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));\n\tfw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;\n\tWREG32_SOC15(GC, 0, mmCP_ME_RAM_WADDR, 0);\n\tfor (i = 0; i < fw_size; i++)\n\t\tWREG32_SOC15(GC, 0, mmCP_ME_RAM_DATA, le32_to_cpup(fw_data++));\n\tWREG32_SOC15(GC, 0, mmCP_ME_RAM_WADDR, adev->gfx.me_fw_version);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_cp_gfx_start(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.gfx_ring[0];\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\tint r, i, tmp;\n\n\t \n\tWREG32_SOC15(GC, 0, mmCP_MAX_CONTEXT, adev->gfx.config.max_hw_contexts - 1);\n\tWREG32_SOC15(GC, 0, mmCP_DEVICE_ID, 1);\n\n\tgfx_v9_0_cp_gfx_enable(adev, true);\n\n\tr = amdgpu_ring_alloc(ring, gfx_v9_0_get_csb_size(adev) + 4 + 3);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, 0x80000000);\n\tamdgpu_ring_write(ring, 0x80000000);\n\n\tfor (sect = gfx9_cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       PACKET3(PACKET3_SET_CONTEXT_REG,\n\t\t\t\t\t       ext->reg_count));\n\t\t\t\tamdgpu_ring_write(ring,\n\t\t\t\t       ext->reg_index - PACKET3_SET_CONTEXT_REG_START);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tamdgpu_ring_write(ring, ext->extent[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tamdgpu_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_BASE, 2));\n\tamdgpu_ring_write(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));\n\tamdgpu_ring_write(ring, 0x8000);\n\tamdgpu_ring_write(ring, 0x8000);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG,1));\n\ttmp = (PACKET3_SET_UCONFIG_REG_INDEX_TYPE |\n\t\t(SOC15_REG_OFFSET(GC, 0, mmVGT_INDEX_TYPE) - PACKET3_SET_UCONFIG_REG_START));\n\tamdgpu_ring_write(ring, tmp);\n\tamdgpu_ring_write(ring, 0);\n\n\tamdgpu_ring_commit(ring);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_cp_gfx_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tu64 rb_addr, rptr_addr, wptr_gpu_addr;\n\n\t \n\tWREG32_SOC15(GC, 0, mmCP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32_SOC15(GC, 0, mmCP_RB_VMID, 0);\n\n\t \n\tring = &adev->gfx.gfx_ring[0];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = REG_SET_FIELD(0, CP_RB0_CNTL, RB_BUFSZ, rb_bufsz);\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, RB_BLKSZ, rb_bufsz - 2);\n#ifdef __BIG_ENDIAN\n\ttmp = REG_SET_FIELD(tmp, CP_RB0_CNTL, BUF_SWAP, 1);\n#endif\n\tWREG32_SOC15(GC, 0, mmCP_RB0_CNTL, tmp);\n\n\t \n\tring->wptr = 0;\n\tWREG32_SOC15(GC, 0, mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\tWREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI, upper_32_bits(ring->wptr));\n\n\t \n\trptr_addr = ring->rptr_gpu_addr;\n\tWREG32_SOC15(GC, 0, mmCP_RB0_RPTR_ADDR, lower_32_bits(rptr_addr));\n\tWREG32_SOC15(GC, 0, mmCP_RB0_RPTR_ADDR_HI, upper_32_bits(rptr_addr) & CP_RB_RPTR_ADDR_HI__RB_RPTR_ADDR_HI_MASK);\n\n\twptr_gpu_addr = ring->wptr_gpu_addr;\n\tWREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_ADDR_LO, lower_32_bits(wptr_gpu_addr));\n\tWREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_ADDR_HI, upper_32_bits(wptr_gpu_addr));\n\n\tmdelay(1);\n\tWREG32_SOC15(GC, 0, mmCP_RB0_CNTL, tmp);\n\n\trb_addr = ring->gpu_addr >> 8;\n\tWREG32_SOC15(GC, 0, mmCP_RB0_BASE, rb_addr);\n\tWREG32_SOC15(GC, 0, mmCP_RB0_BASE_HI, upper_32_bits(rb_addr));\n\n\ttmp = RREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_CONTROL);\n\tif (ring->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_OFFSET, ring->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_RB_DOORBELL_CONTROL, DOORBELL_EN, 0);\n\t}\n\tWREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_CONTROL, tmp);\n\n\ttmp = REG_SET_FIELD(0, CP_RB_DOORBELL_RANGE_LOWER,\n\t\t\tDOORBELL_RANGE_LOWER, ring->doorbell_index);\n\tWREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_RANGE_LOWER, tmp);\n\n\tWREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_RANGE_UPPER,\n\t\t       CP_RB_DOORBELL_RANGE_UPPER__DOORBELL_RANGE_UPPER_MASK);\n\n\n\t \n\tgfx_v9_0_cp_gfx_start(adev);\n\n\treturn 0;\n}\n\nstatic void gfx_v9_0_cp_compute_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable) {\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_MEC_CNTL, 0);\n\t} else {\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_MEC_CNTL,\n\t\t\t(CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK));\n\t\tadev->gfx.kiq[0].ring.sched.ready = false;\n\t}\n\tudelay(50);\n}\n\nstatic int gfx_v9_0_cp_compute_load_microcode(struct amdgpu_device *adev)\n{\n\tconst struct gfx_firmware_header_v1_0 *mec_hdr;\n\tconst __le32 *fw_data;\n\tunsigned i;\n\tu32 tmp;\n\n\tif (!adev->gfx.mec_fw)\n\t\treturn -EINVAL;\n\n\tgfx_v9_0_cp_compute_enable(adev, false);\n\n\tmec_hdr = (const struct gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;\n\tamdgpu_ucode_print_gfx_hdr(&mec_hdr->header);\n\n\tfw_data = (const __le32 *)\n\t\t(adev->gfx.mec_fw->data +\n\t\t le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));\n\ttmp = 0;\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\n\tWREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_CNTL, tmp);\n\n\tWREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_LO,\n\t\tadev->gfx.mec.mec_fw_gpu_addr & 0xFFFFF000);\n\tWREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_HI,\n\t\tupper_32_bits(adev->gfx.mec.mec_fw_gpu_addr));\n\n\t \n\tWREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_ADDR,\n\t\t\t mec_hdr->jt_offset);\n\tfor (i = 0; i < mec_hdr->jt_size; i++)\n\t\tWREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_DATA,\n\t\t\tle32_to_cpup(fw_data + mec_hdr->jt_offset + i));\n\n\tWREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_ADDR,\n\t\t\tadev->gfx.mec_fw_version);\n\t \n\n\treturn 0;\n}\n\n \nstatic void gfx_v9_0_kiq_setting(struct amdgpu_ring *ring)\n{\n\tuint32_t tmp;\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmRLC_CP_SCHEDULERS);\n\ttmp &= 0xffffff00;\n\ttmp |= (ring->me << 5) | (ring->pipe << 3) | (ring->queue);\n\tWREG32_SOC15_RLC(GC, 0, mmRLC_CP_SCHEDULERS, tmp);\n\ttmp |= 0x80;\n\tWREG32_SOC15_RLC(GC, 0, mmRLC_CP_SCHEDULERS, tmp);\n}\n\nstatic void gfx_v9_0_mqd_set_priority(struct amdgpu_ring *ring, struct v9_mqd *mqd)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) {\n\t\tif (amdgpu_gfx_is_high_priority_compute_queue(adev, ring)) {\n\t\t\tmqd->cp_hqd_pipe_priority = AMDGPU_GFX_PIPE_PRIO_HIGH;\n\t\t\tmqd->cp_hqd_queue_priority =\n\t\t\t\tAMDGPU_GFX_QUEUE_PRIORITY_MAXIMUM;\n\t\t}\n\t}\n}\n\nstatic int gfx_v9_0_mqd_init(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_mqd *mqd = ring->mqd_ptr;\n\tuint64_t hqd_gpu_addr, wb_gpu_addr, eop_base_addr;\n\tuint32_t tmp;\n\n\tmqd->header = 0xC0310800;\n\tmqd->compute_pipelinestat_enable = 0x00000001;\n\tmqd->compute_static_thread_mgmt_se0 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se1 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se2 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se3 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se4 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se5 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se6 = 0xffffffff;\n\tmqd->compute_static_thread_mgmt_se7 = 0xffffffff;\n\tmqd->compute_misc_reserved = 0x00000003;\n\n\tmqd->dynamic_cu_mask_addr_lo =\n\t\tlower_32_bits(ring->mqd_gpu_addr\n\t\t\t      + offsetof(struct v9_mqd_allocation, dynamic_cu_mask));\n\tmqd->dynamic_cu_mask_addr_hi =\n\t\tupper_32_bits(ring->mqd_gpu_addr\n\t\t\t      + offsetof(struct v9_mqd_allocation, dynamic_cu_mask));\n\n\teop_base_addr = ring->eop_gpu_addr >> 8;\n\tmqd->cp_hqd_eop_base_addr_lo = eop_base_addr;\n\tmqd->cp_hqd_eop_base_addr_hi = upper_32_bits(eop_base_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmCP_HQD_EOP_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_EOP_CONTROL, EOP_SIZE,\n\t\t\t(order_base_2(GFX9_MEC_HPD_SIZE / 4) - 1));\n\n\tmqd->cp_hqd_eop_control = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL);\n\n\tif (ring->use_doorbell) {\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_OFFSET, ring->doorbell_index);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_EN, 1);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_SOURCE, 0);\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t    DOORBELL_HIT, 0);\n\t} else {\n\t\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t\t\t\t DOORBELL_EN, 0);\n\t}\n\n\tmqd->cp_hqd_pq_doorbell_control = tmp;\n\n\t \n\tring->wptr = 0;\n\tmqd->cp_hqd_dequeue_request = 0;\n\tmqd->cp_hqd_pq_rptr = 0;\n\tmqd->cp_hqd_pq_wptr_lo = 0;\n\tmqd->cp_hqd_pq_wptr_hi = 0;\n\n\t \n\tmqd->cp_mqd_base_addr_lo = ring->mqd_gpu_addr & 0xfffffffc;\n\tmqd->cp_mqd_base_addr_hi = upper_32_bits(ring->mqd_gpu_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmCP_MQD_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_MQD_CONTROL, VMID, 0);\n\tmqd->cp_mqd_control = tmp;\n\n\t \n\thqd_gpu_addr = ring->gpu_addr >> 8;\n\tmqd->cp_hqd_pq_base_lo = hqd_gpu_addr;\n\tmqd->cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, QUEUE_SIZE,\n\t\t\t    (order_base_2(ring->ring_size / 4) - 1));\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, RPTR_BLOCK_SIZE,\n\t\t\t(order_base_2(AMDGPU_GPU_PAGE_SIZE / 4) - 1));\n#ifdef __BIG_ENDIAN\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, ENDIAN_SWAP, 1);\n#endif\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, UNORD_DISPATCH, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, ROQ_PQ_IB_FLIP, 0);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, PRIV_STATE, 1);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PQ_CONTROL, KMD_QUEUE, 1);\n\tmqd->cp_hqd_pq_control = tmp;\n\n\t \n\twb_gpu_addr = ring->rptr_gpu_addr;\n\tmqd->cp_hqd_pq_rptr_report_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_rptr_report_addr_hi =\n\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\twb_gpu_addr = ring->wptr_gpu_addr;\n\tmqd->cp_hqd_pq_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;\n\tmqd->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\n\t \n\tring->wptr = 0;\n\tmqd->cp_hqd_pq_rptr = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_RPTR);\n\n\t \n\tmqd->cp_hqd_vmid = 0;\n\n\ttmp = RREG32_SOC15(GC, 0, mmCP_HQD_PERSISTENT_STATE);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_PERSISTENT_STATE, PRELOAD_SIZE, 0x53);\n\tmqd->cp_hqd_persistent_state = tmp;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmCP_HQD_IB_CONTROL);\n\ttmp = REG_SET_FIELD(tmp, CP_HQD_IB_CONTROL, MIN_IB_AVAIL_SIZE, 3);\n\tmqd->cp_hqd_ib_control = tmp;\n\n\t \n\tgfx_v9_0_mqd_set_priority(ring, mqd);\n\tmqd->cp_hqd_quantum = RREG32_SOC15(GC, 0, mmCP_HQD_QUANTUM);\n\n\t \n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tmqd->cp_hqd_active = 1;\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kiq_init_register(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_mqd *mqd = ring->mqd_ptr;\n\tint j;\n\n\t \n\tWREG32_FIELD15(GC, 0, CP_PQ_WPTR_POLL_CNTL, EN, 0);\n\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_BASE_ADDR,\n\t       mqd->cp_hqd_eop_base_addr_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_BASE_ADDR_HI,\n\t       mqd->cp_hqd_eop_base_addr_hi);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_CONTROL,\n\t       mqd->cp_hqd_eop_control);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL,\n\t       mqd->cp_hqd_pq_doorbell_control);\n\n\t \n\tif (RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1) {\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST, 1);\n\t\tfor (j = 0; j < adev->usec_timeout; j++) {\n\t\t\tif (!(RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST,\n\t\t       mqd->cp_hqd_dequeue_request);\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR,\n\t\t       mqd->cp_hqd_pq_rptr);\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO,\n\t\t       mqd->cp_hqd_pq_wptr_lo);\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI,\n\t\t       mqd->cp_hqd_pq_wptr_hi);\n\t}\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_MQD_BASE_ADDR,\n\t       mqd->cp_mqd_base_addr_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_MQD_BASE_ADDR_HI,\n\t       mqd->cp_mqd_base_addr_hi);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_MQD_CONTROL,\n\t       mqd->cp_mqd_control);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_BASE,\n\t       mqd->cp_hqd_pq_base_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_BASE_HI,\n\t       mqd->cp_hqd_pq_base_hi);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_CONTROL,\n\t       mqd->cp_hqd_pq_control);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR_REPORT_ADDR,\n\t\t\t\tmqd->cp_hqd_pq_rptr_report_addr_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR_REPORT_ADDR_HI,\n\t\t\t\tmqd->cp_hqd_pq_rptr_report_addr_hi);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_POLL_ADDR,\n\t       mqd->cp_hqd_pq_wptr_poll_addr_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_POLL_ADDR_HI,\n\t       mqd->cp_hqd_pq_wptr_poll_addr_hi);\n\n\t \n\tif (ring->use_doorbell) {\n\t\tWREG32_SOC15(GC, 0, mmCP_MEC_DOORBELL_RANGE_LOWER,\n\t\t\t\t\t(adev->doorbell_index.kiq * 2) << 2);\n\t\t \n\t\tif (check_if_enlarge_doorbell_range(adev))\n\t\t\tWREG32_SOC15(GC, 0, mmCP_MEC_DOORBELL_RANGE_UPPER,\n\t\t\t\t\t(adev->doorbell.size - 4));\n\t\telse\n\t\t\tWREG32_SOC15(GC, 0, mmCP_MEC_DOORBELL_RANGE_UPPER,\n\t\t\t\t\t(adev->doorbell_index.userqueue_end * 2) << 2);\n\t}\n\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL,\n\t       mqd->cp_hqd_pq_doorbell_control);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO,\n\t       mqd->cp_hqd_pq_wptr_lo);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI,\n\t       mqd->cp_hqd_pq_wptr_hi);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_VMID, mqd->cp_hqd_vmid);\n\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PERSISTENT_STATE,\n\t       mqd->cp_hqd_persistent_state);\n\n\t \n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_ACTIVE,\n\t       mqd->cp_hqd_active);\n\n\tif (ring->use_doorbell)\n\t\tWREG32_FIELD15(GC, 0, CP_PQ_STATUS, DOORBELL_ENABLE, 1);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kiq_fini_register(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tint j;\n\n\t \n\tif (RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1) {\n\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST, 1);\n\n\t\tfor (j = 0; j < adev->usec_timeout; j++) {\n\t\t\tif (!(RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tif (j == AMDGPU_MAX_USEC_TIMEOUT) {\n\t\t\tDRM_DEBUG(\"KIQ dequeue request failed.\\n\");\n\n\t\t\t \n\t\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_ACTIVE, 0);\n\t\t}\n\n\t\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST,\n\t\t      0);\n\t}\n\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_IQ_TIMER, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_IB_CONTROL, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PERSISTENT_STATE, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL, 0x40000000);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI, 0);\n\tWREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO, 0);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kiq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_mqd *mqd = ring->mqd_ptr;\n\tstruct v9_mqd *tmp_mqd;\n\n\tgfx_v9_0_kiq_setting(ring);\n\n\t \n\ttmp_mqd = (struct v9_mqd *)adev->gfx.kiq[0].mqd_backup;\n\tif (amdgpu_in_reset(adev) && tmp_mqd->cp_hqd_pq_control){\n\t\t \n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct v9_mqd_allocation));\n\n\t\t \n\t\tring->wptr = 0;\n\t\tamdgpu_ring_clear_ring(ring);\n\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0, 0);\n\t\tgfx_v9_0_kiq_init_register(ring);\n\t\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t} else {\n\t\tmemset((void *)mqd, 0, sizeof(struct v9_mqd_allocation));\n\t\t((struct v9_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;\n\t\t((struct v9_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;\n\t\tif (amdgpu_sriov_vf(adev) && adev->in_suspend)\n\t\t\tamdgpu_ring_clear_ring(ring);\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0, 0);\n\t\tgfx_v9_0_mqd_init(ring);\n\t\tgfx_v9_0_kiq_init_register(ring);\n\t\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.kiq[0].mqd_backup)\n\t\t\tmemcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct v9_mqd_allocation));\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kcq_init_queue(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_mqd *mqd = ring->mqd_ptr;\n\tint mqd_idx = ring - &adev->gfx.compute_ring[0];\n\tstruct v9_mqd *tmp_mqd;\n\n\t \n\ttmp_mqd = (struct v9_mqd *)adev->gfx.mec.mqd_backup[mqd_idx];\n\n\tif (!tmp_mqd->cp_hqd_pq_control ||\n\t    (!amdgpu_in_reset(adev) && !adev->in_suspend)) {\n\t\tmemset((void *)mqd, 0, sizeof(struct v9_mqd_allocation));\n\t\t((struct v9_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;\n\t\t((struct v9_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0, 0);\n\t\tgfx_v9_0_mqd_init(ring);\n\t\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation));\n\t} else {\n\t\t \n\t\tif (adev->gfx.mec.mqd_backup[mqd_idx])\n\t\t\tmemcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation));\n\t\t \n\t\tring->wptr = 0;\n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, 0);\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kiq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring;\n\tint r;\n\n\tring = &adev->gfx.kiq[0].ring;\n\n\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);\n\tif (unlikely(r != 0)) {\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\treturn r;\n\t}\n\n\tgfx_v9_0_kiq_init_queue(ring);\n\tamdgpu_bo_kunmap(ring->mqd_obj);\n\tring->mqd_ptr = NULL;\n\tamdgpu_bo_unreserve(ring->mqd_obj);\n\treturn 0;\n}\n\nstatic int gfx_v9_0_kcq_resume(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = NULL;\n\tint r = 0, i;\n\n\tgfx_v9_0_cp_compute_enable(adev, true);\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\n\t\tr = amdgpu_bo_reserve(ring->mqd_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tgoto done;\n\t\tr = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);\n\t\tif (!r) {\n\t\t\tr = gfx_v9_0_kcq_init_queue(ring);\n\t\t\tamdgpu_bo_kunmap(ring->mqd_obj);\n\t\t\tring->mqd_ptr = NULL;\n\t\t}\n\t\tamdgpu_bo_unreserve(ring->mqd_obj);\n\t\tif (r)\n\t\t\tgoto done;\n\t}\n\n\tr = amdgpu_gfx_enable_kcq(adev, 0);\ndone:\n\treturn r;\n}\n\nstatic int gfx_v9_0_cp_resume(struct amdgpu_device *adev)\n{\n\tint r, i;\n\tstruct amdgpu_ring *ring;\n\n\tif (!(adev->flags & AMD_IS_APU))\n\t\tgfx_v9_0_enable_gui_idle_interrupt(adev, false);\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\tif (adev->gfx.num_gfx_rings) {\n\t\t\t \n\t\t\tr = gfx_v9_0_cp_gfx_load_microcode(adev);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\n\t\tr = gfx_v9_0_cp_compute_load_microcode(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = gfx_v9_0_kiq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (adev->gfx.num_gfx_rings) {\n\t\tr = gfx_v9_0_cp_gfx_resume(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = gfx_v9_0_kcq_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (adev->gfx.num_gfx_rings) {\n\t\tring = &adev->gfx.gfx_ring[0];\n\t\tr = amdgpu_ring_test_helper(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\tring = &adev->gfx.compute_ring[i];\n\t\tamdgpu_ring_test_helper(ring);\n\t}\n\n\tgfx_v9_0_enable_gui_idle_interrupt(adev, true);\n\n\treturn 0;\n}\n\nstatic void gfx_v9_0_init_tcp_config(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tif (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 1) &&\n\t    adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 2))\n\t\treturn;\n\n\ttmp = RREG32_SOC15(GC, 0, mmTCP_ADDR_CONFIG);\n\ttmp = REG_SET_FIELD(tmp, TCP_ADDR_CONFIG, ENABLE64KHASH,\n\t\t\t\tadev->df.hash_status.hash_64k);\n\ttmp = REG_SET_FIELD(tmp, TCP_ADDR_CONFIG, ENABLE2MHASH,\n\t\t\t\tadev->df.hash_status.hash_2m);\n\ttmp = REG_SET_FIELD(tmp, TCP_ADDR_CONFIG, ENABLE1GHASH,\n\t\t\t\tadev->df.hash_status.hash_1g);\n\tWREG32_SOC15(GC, 0, mmTCP_ADDR_CONFIG, tmp);\n}\n\nstatic void gfx_v9_0_cp_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (adev->gfx.num_gfx_rings)\n\t\tgfx_v9_0_cp_gfx_enable(adev, enable);\n\tgfx_v9_0_cp_compute_enable(adev, enable);\n}\n\nstatic int gfx_v9_0_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\tgfx_v9_0_init_golden_registers(adev);\n\n\tgfx_v9_0_constants_init(adev);\n\n\tgfx_v9_0_init_tcp_config(adev);\n\n\tr = adev->gfx.rlc.funcs->resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v9_0_cp_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 2))\n\t\tgfx_v9_4_2_set_power_brake_sequence(adev);\n\n\treturn r;\n}\n\nstatic int gfx_v9_0_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\tamdgpu_irq_put(adev, &adev->gfx.cp_ecc_error_irq, 0);\n\tamdgpu_irq_put(adev, &adev->gfx.priv_reg_irq, 0);\n\tamdgpu_irq_put(adev, &adev->gfx.priv_inst_irq, 0);\n\n\t \n\tif (!amdgpu_ras_intr_triggered())\n\t\t \n\t\tamdgpu_gfx_disable_kcq(adev, 0);\n\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tgfx_v9_0_cp_gfx_enable(adev, false);\n\t\t \n\t\tWREG32_FIELD15(GC, 0, CP_PQ_WPTR_POLL_CNTL, EN, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!amdgpu_in_reset(adev) && !adev->in_suspend) {\n\t\tmutex_lock(&adev->srbm_mutex);\n\t\tsoc15_grbm_select(adev, adev->gfx.kiq[0].ring.me,\n\t\t\t\tadev->gfx.kiq[0].ring.pipe,\n\t\t\t\tadev->gfx.kiq[0].ring.queue, 0, 0);\n\t\tgfx_v9_0_kiq_fini_register(&adev->gfx.kiq[0].ring);\n\t\tsoc15_grbm_select(adev, 0, 0, 0, 0, 0);\n\t\tmutex_unlock(&adev->srbm_mutex);\n\t}\n\n\tgfx_v9_0_cp_enable(adev, false);\n\n\t \n\tif ((adev->gmc.xgmi.connected_to_cpu && amdgpu_in_reset(adev)) ||\n\t    (adev->ip_versions[GC_HWIP][0] >= IP_VERSION(9, 4, 2))) {\n\t\tdev_dbg(adev->dev, \"Skipping RLC halt\\n\");\n\t\treturn 0;\n\t}\n\n\tadev->gfx.rlc.funcs->stop(adev);\n\treturn 0;\n}\n\nstatic int gfx_v9_0_suspend(void *handle)\n{\n\treturn gfx_v9_0_hw_fini(handle);\n}\n\nstatic int gfx_v9_0_resume(void *handle)\n{\n\treturn gfx_v9_0_hw_init(handle);\n}\n\nstatic bool gfx_v9_0_is_idle(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (REG_GET_FIELD(RREG32_SOC15(GC, 0, mmGRBM_STATUS),\n\t\t\t\tGRBM_STATUS, GUI_ACTIVE))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int gfx_v9_0_wait_for_idle(void *handle)\n{\n\tunsigned i;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (gfx_v9_0_is_idle(handle))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int gfx_v9_0_soft_reset(void *handle)\n{\n\tu32 grbm_soft_reset = 0;\n\tu32 tmp;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmGRBM_STATUS);\n\tif (tmp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |\n\t\t   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |\n\t\t   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |\n\t\t   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |\n\t\t   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |\n\t\t   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK)) {\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_CP, 1);\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_GFX, 1);\n\t}\n\n\tif (tmp & (GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK)) {\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_CP, 1);\n\t}\n\n\t \n\ttmp = RREG32_SOC15(GC, 0, mmGRBM_STATUS2);\n\tif (REG_GET_FIELD(tmp, GRBM_STATUS2, RLC_BUSY))\n\t\tgrbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,\n\t\t\t\t\t\tGRBM_SOFT_RESET, SOFT_RESET_RLC, 1);\n\n\n\tif (grbm_soft_reset) {\n\t\t \n\t\tadev->gfx.rlc.funcs->stop(adev);\n\n\t\tif (adev->gfx.num_gfx_rings)\n\t\t\t \n\t\t\tgfx_v9_0_cp_gfx_enable(adev, false);\n\n\t\t \n\t\tgfx_v9_0_cp_compute_enable(adev, false);\n\n\t\tif (grbm_soft_reset) {\n\t\t\ttmp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);\n\t\t\ttmp |= grbm_soft_reset;\n\t\t\tdev_info(adev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\t\tWREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);\n\n\t\t\tudelay(50);\n\n\t\t\ttmp &= ~grbm_soft_reset;\n\t\t\tWREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET, tmp);\n\t\t\ttmp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);\n\t\t}\n\n\t\t \n\t\tudelay(50);\n\t}\n\treturn 0;\n}\n\nstatic uint64_t gfx_v9_0_kiq_read_clock(struct amdgpu_device *adev)\n{\n\tsigned long r, cnt = 0;\n\tunsigned long flags;\n\tuint32_t seq, reg_val_offs = 0;\n\tuint64_t value = 0;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[0];\n\tstruct amdgpu_ring *ring = &kiq->ring;\n\n\tBUG_ON(!ring->funcs->emit_rreg);\n\n\tspin_lock_irqsave(&kiq->ring_lock, flags);\n\tif (amdgpu_device_wb_get(adev, &reg_val_offs)) {\n\t\tpr_err(\"critical bug! too many kiq readers\\n\");\n\t\tgoto failed_unlock;\n\t}\n\tamdgpu_ring_alloc(ring, 32);\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COPY_DATA, 4));\n\tamdgpu_ring_write(ring, 9 |\t \n\t\t\t\t(5 << 8) |\t \n\t\t\t\t(1 << 16) |\t \n\t\t\t\t(1 << 20));\t \n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, lower_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n\tamdgpu_ring_write(ring, upper_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n\tr = amdgpu_fence_emit_polling(ring, &seq, MAX_KIQ_REG_WAIT);\n\tif (r)\n\t\tgoto failed_undo;\n\n\tamdgpu_ring_commit(ring);\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\n\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\n\t \n\tif (r < 1 && (amdgpu_in_reset(adev)))\n\t\tgoto failed_kiq_read;\n\n\tmight_sleep();\n\twhile (r < 1 && cnt++ < MAX_KIQ_REG_TRY) {\n\t\tmsleep(MAX_KIQ_REG_BAILOUT_INTERVAL);\n\t\tr = amdgpu_fence_wait_polling(ring, seq, MAX_KIQ_REG_WAIT);\n\t}\n\n\tif (cnt > MAX_KIQ_REG_TRY)\n\t\tgoto failed_kiq_read;\n\n\tmb();\n\tvalue = (uint64_t)adev->wb.wb[reg_val_offs] |\n\t\t(uint64_t)adev->wb.wb[reg_val_offs + 1 ] << 32ULL;\n\tamdgpu_device_wb_free(adev, reg_val_offs);\n\treturn value;\n\nfailed_undo:\n\tamdgpu_ring_undo(ring);\nfailed_unlock:\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\nfailed_kiq_read:\n\tif (reg_val_offs)\n\t\tamdgpu_device_wb_free(adev, reg_val_offs);\n\tpr_err(\"failed to read gpu clock\\n\");\n\treturn ~0;\n}\n\nstatic uint64_t gfx_v9_0_get_gpu_clock_counter(struct amdgpu_device *adev)\n{\n\tuint64_t clock, clock_lo, clock_hi, hi_check;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 3, 0):\n\t\tpreempt_disable();\n\t\tclock_hi = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_UPPER_Renoir);\n\t\tclock_lo = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_LOWER_Renoir);\n\t\thi_check = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_UPPER_Renoir);\n\t\t \n\t\tif (hi_check != clock_hi) {\n\t\t\tclock_lo = RREG32_SOC15_NO_KIQ(SMUIO, 0, mmGOLDEN_TSC_COUNT_LOWER_Renoir);\n\t\t\tclock_hi = hi_check;\n\t\t}\n\t\tpreempt_enable();\n\t\tclock = clock_lo | (clock_hi << 32ULL);\n\t\tbreak;\n\tdefault:\n\t\tamdgpu_gfx_off_ctrl(adev, false);\n\t\tmutex_lock(&adev->gfx.gpu_clock_mutex);\n\t\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 0, 1) && amdgpu_sriov_runtime(adev)) {\n\t\t\tclock = gfx_v9_0_kiq_read_clock(adev);\n\t\t} else {\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\t\t\tclock = (uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_LSB) |\n\t\t\t\t((uint64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\t\t}\n\t\tmutex_unlock(&adev->gfx.gpu_clock_mutex);\n\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t\tbreak;\n\t}\n\treturn clock;\n}\n\nstatic void gfx_v9_0_ring_emit_gds_switch(struct amdgpu_ring *ring,\n\t\t\t\t\t  uint32_t vmid,\n\t\t\t\t\t  uint32_t gds_base, uint32_t gds_size,\n\t\t\t\t\t  uint32_t gws_base, uint32_t gws_size,\n\t\t\t\t\t  uint32_t oa_base, uint32_t oa_size)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\tgfx_v9_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t   SOC15_REG_OFFSET(GC, 0, mmGDS_VMID0_BASE) + 2 * vmid,\n\t\t\t\t   gds_base);\n\n\t \n\tgfx_v9_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t   SOC15_REG_OFFSET(GC, 0, mmGDS_VMID0_SIZE) + 2 * vmid,\n\t\t\t\t   gds_size);\n\n\t \n\tgfx_v9_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t   SOC15_REG_OFFSET(GC, 0, mmGDS_GWS_VMID0) + vmid,\n\t\t\t\t   gws_size << GDS_GWS_VMID0__SIZE__SHIFT | gws_base);\n\n\t \n\tgfx_v9_0_write_data_to_reg(ring, 0, false,\n\t\t\t\t   SOC15_REG_OFFSET(GC, 0, mmGDS_OA_VMID0) + vmid,\n\t\t\t\t   (1 << (oa_size + oa_base)) - (1 << oa_base));\n}\n\nstatic const u32 vgpr_init_compute_shader[] =\n{\n\t0xb07c0000, 0xbe8000ff,\n\t0x000000f8, 0xbf110800,\n\t0x7e000280, 0x7e020280,\n\t0x7e040280, 0x7e060280,\n\t0x7e080280, 0x7e0a0280,\n\t0x7e0c0280, 0x7e0e0280,\n\t0x80808800, 0xbe803200,\n\t0xbf84fff5, 0xbf9c0000,\n\t0xd28c0001, 0x0001007f,\n\t0xd28d0001, 0x0002027e,\n\t0x10020288, 0xb8810904,\n\t0xb7814000, 0xd1196a01,\n\t0x00000301, 0xbe800087,\n\t0xbefc00c1, 0xd89c4000,\n\t0x00020201, 0xd89cc080,\n\t0x00040401, 0x320202ff,\n\t0x00000800, 0x80808100,\n\t0xbf84fff8, 0x7e020280,\n\t0xbf810000, 0x00000000,\n};\n\nstatic const u32 sgpr_init_compute_shader[] =\n{\n\t0xb07c0000, 0xbe8000ff,\n\t0x0000005f, 0xbee50080,\n\t0xbe812c65, 0xbe822c65,\n\t0xbe832c65, 0xbe842c65,\n\t0xbe852c65, 0xb77c0005,\n\t0x80808500, 0xbf84fff8,\n\t0xbe800080, 0xbf810000,\n};\n\nstatic const u32 vgpr_init_compute_shader_arcturus[] = {\n\t0xd3d94000, 0x18000080, 0xd3d94001, 0x18000080, 0xd3d94002, 0x18000080,\n\t0xd3d94003, 0x18000080, 0xd3d94004, 0x18000080, 0xd3d94005, 0x18000080,\n\t0xd3d94006, 0x18000080, 0xd3d94007, 0x18000080, 0xd3d94008, 0x18000080,\n\t0xd3d94009, 0x18000080, 0xd3d9400a, 0x18000080, 0xd3d9400b, 0x18000080,\n\t0xd3d9400c, 0x18000080, 0xd3d9400d, 0x18000080, 0xd3d9400e, 0x18000080,\n\t0xd3d9400f, 0x18000080, 0xd3d94010, 0x18000080, 0xd3d94011, 0x18000080,\n\t0xd3d94012, 0x18000080, 0xd3d94013, 0x18000080, 0xd3d94014, 0x18000080,\n\t0xd3d94015, 0x18000080, 0xd3d94016, 0x18000080, 0xd3d94017, 0x18000080,\n\t0xd3d94018, 0x18000080, 0xd3d94019, 0x18000080, 0xd3d9401a, 0x18000080,\n\t0xd3d9401b, 0x18000080, 0xd3d9401c, 0x18000080, 0xd3d9401d, 0x18000080,\n\t0xd3d9401e, 0x18000080, 0xd3d9401f, 0x18000080, 0xd3d94020, 0x18000080,\n\t0xd3d94021, 0x18000080, 0xd3d94022, 0x18000080, 0xd3d94023, 0x18000080,\n\t0xd3d94024, 0x18000080, 0xd3d94025, 0x18000080, 0xd3d94026, 0x18000080,\n\t0xd3d94027, 0x18000080, 0xd3d94028, 0x18000080, 0xd3d94029, 0x18000080,\n\t0xd3d9402a, 0x18000080, 0xd3d9402b, 0x18000080, 0xd3d9402c, 0x18000080,\n\t0xd3d9402d, 0x18000080, 0xd3d9402e, 0x18000080, 0xd3d9402f, 0x18000080,\n\t0xd3d94030, 0x18000080, 0xd3d94031, 0x18000080, 0xd3d94032, 0x18000080,\n\t0xd3d94033, 0x18000080, 0xd3d94034, 0x18000080, 0xd3d94035, 0x18000080,\n\t0xd3d94036, 0x18000080, 0xd3d94037, 0x18000080, 0xd3d94038, 0x18000080,\n\t0xd3d94039, 0x18000080, 0xd3d9403a, 0x18000080, 0xd3d9403b, 0x18000080,\n\t0xd3d9403c, 0x18000080, 0xd3d9403d, 0x18000080, 0xd3d9403e, 0x18000080,\n\t0xd3d9403f, 0x18000080, 0xd3d94040, 0x18000080, 0xd3d94041, 0x18000080,\n\t0xd3d94042, 0x18000080, 0xd3d94043, 0x18000080, 0xd3d94044, 0x18000080,\n\t0xd3d94045, 0x18000080, 0xd3d94046, 0x18000080, 0xd3d94047, 0x18000080,\n\t0xd3d94048, 0x18000080, 0xd3d94049, 0x18000080, 0xd3d9404a, 0x18000080,\n\t0xd3d9404b, 0x18000080, 0xd3d9404c, 0x18000080, 0xd3d9404d, 0x18000080,\n\t0xd3d9404e, 0x18000080, 0xd3d9404f, 0x18000080, 0xd3d94050, 0x18000080,\n\t0xd3d94051, 0x18000080, 0xd3d94052, 0x18000080, 0xd3d94053, 0x18000080,\n\t0xd3d94054, 0x18000080, 0xd3d94055, 0x18000080, 0xd3d94056, 0x18000080,\n\t0xd3d94057, 0x18000080, 0xd3d94058, 0x18000080, 0xd3d94059, 0x18000080,\n\t0xd3d9405a, 0x18000080, 0xd3d9405b, 0x18000080, 0xd3d9405c, 0x18000080,\n\t0xd3d9405d, 0x18000080, 0xd3d9405e, 0x18000080, 0xd3d9405f, 0x18000080,\n\t0xd3d94060, 0x18000080, 0xd3d94061, 0x18000080, 0xd3d94062, 0x18000080,\n\t0xd3d94063, 0x18000080, 0xd3d94064, 0x18000080, 0xd3d94065, 0x18000080,\n\t0xd3d94066, 0x18000080, 0xd3d94067, 0x18000080, 0xd3d94068, 0x18000080,\n\t0xd3d94069, 0x18000080, 0xd3d9406a, 0x18000080, 0xd3d9406b, 0x18000080,\n\t0xd3d9406c, 0x18000080, 0xd3d9406d, 0x18000080, 0xd3d9406e, 0x18000080,\n\t0xd3d9406f, 0x18000080, 0xd3d94070, 0x18000080, 0xd3d94071, 0x18000080,\n\t0xd3d94072, 0x18000080, 0xd3d94073, 0x18000080, 0xd3d94074, 0x18000080,\n\t0xd3d94075, 0x18000080, 0xd3d94076, 0x18000080, 0xd3d94077, 0x18000080,\n\t0xd3d94078, 0x18000080, 0xd3d94079, 0x18000080, 0xd3d9407a, 0x18000080,\n\t0xd3d9407b, 0x18000080, 0xd3d9407c, 0x18000080, 0xd3d9407d, 0x18000080,\n\t0xd3d9407e, 0x18000080, 0xd3d9407f, 0x18000080, 0xd3d94080, 0x18000080,\n\t0xd3d94081, 0x18000080, 0xd3d94082, 0x18000080, 0xd3d94083, 0x18000080,\n\t0xd3d94084, 0x18000080, 0xd3d94085, 0x18000080, 0xd3d94086, 0x18000080,\n\t0xd3d94087, 0x18000080, 0xd3d94088, 0x18000080, 0xd3d94089, 0x18000080,\n\t0xd3d9408a, 0x18000080, 0xd3d9408b, 0x18000080, 0xd3d9408c, 0x18000080,\n\t0xd3d9408d, 0x18000080, 0xd3d9408e, 0x18000080, 0xd3d9408f, 0x18000080,\n\t0xd3d94090, 0x18000080, 0xd3d94091, 0x18000080, 0xd3d94092, 0x18000080,\n\t0xd3d94093, 0x18000080, 0xd3d94094, 0x18000080, 0xd3d94095, 0x18000080,\n\t0xd3d94096, 0x18000080, 0xd3d94097, 0x18000080, 0xd3d94098, 0x18000080,\n\t0xd3d94099, 0x18000080, 0xd3d9409a, 0x18000080, 0xd3d9409b, 0x18000080,\n\t0xd3d9409c, 0x18000080, 0xd3d9409d, 0x18000080, 0xd3d9409e, 0x18000080,\n\t0xd3d9409f, 0x18000080, 0xd3d940a0, 0x18000080, 0xd3d940a1, 0x18000080,\n\t0xd3d940a2, 0x18000080, 0xd3d940a3, 0x18000080, 0xd3d940a4, 0x18000080,\n\t0xd3d940a5, 0x18000080, 0xd3d940a6, 0x18000080, 0xd3d940a7, 0x18000080,\n\t0xd3d940a8, 0x18000080, 0xd3d940a9, 0x18000080, 0xd3d940aa, 0x18000080,\n\t0xd3d940ab, 0x18000080, 0xd3d940ac, 0x18000080, 0xd3d940ad, 0x18000080,\n\t0xd3d940ae, 0x18000080, 0xd3d940af, 0x18000080, 0xd3d940b0, 0x18000080,\n\t0xd3d940b1, 0x18000080, 0xd3d940b2, 0x18000080, 0xd3d940b3, 0x18000080,\n\t0xd3d940b4, 0x18000080, 0xd3d940b5, 0x18000080, 0xd3d940b6, 0x18000080,\n\t0xd3d940b7, 0x18000080, 0xd3d940b8, 0x18000080, 0xd3d940b9, 0x18000080,\n\t0xd3d940ba, 0x18000080, 0xd3d940bb, 0x18000080, 0xd3d940bc, 0x18000080,\n\t0xd3d940bd, 0x18000080, 0xd3d940be, 0x18000080, 0xd3d940bf, 0x18000080,\n\t0xd3d940c0, 0x18000080, 0xd3d940c1, 0x18000080, 0xd3d940c2, 0x18000080,\n\t0xd3d940c3, 0x18000080, 0xd3d940c4, 0x18000080, 0xd3d940c5, 0x18000080,\n\t0xd3d940c6, 0x18000080, 0xd3d940c7, 0x18000080, 0xd3d940c8, 0x18000080,\n\t0xd3d940c9, 0x18000080, 0xd3d940ca, 0x18000080, 0xd3d940cb, 0x18000080,\n\t0xd3d940cc, 0x18000080, 0xd3d940cd, 0x18000080, 0xd3d940ce, 0x18000080,\n\t0xd3d940cf, 0x18000080, 0xd3d940d0, 0x18000080, 0xd3d940d1, 0x18000080,\n\t0xd3d940d2, 0x18000080, 0xd3d940d3, 0x18000080, 0xd3d940d4, 0x18000080,\n\t0xd3d940d5, 0x18000080, 0xd3d940d6, 0x18000080, 0xd3d940d7, 0x18000080,\n\t0xd3d940d8, 0x18000080, 0xd3d940d9, 0x18000080, 0xd3d940da, 0x18000080,\n\t0xd3d940db, 0x18000080, 0xd3d940dc, 0x18000080, 0xd3d940dd, 0x18000080,\n\t0xd3d940de, 0x18000080, 0xd3d940df, 0x18000080, 0xd3d940e0, 0x18000080,\n\t0xd3d940e1, 0x18000080, 0xd3d940e2, 0x18000080, 0xd3d940e3, 0x18000080,\n\t0xd3d940e4, 0x18000080, 0xd3d940e5, 0x18000080, 0xd3d940e6, 0x18000080,\n\t0xd3d940e7, 0x18000080, 0xd3d940e8, 0x18000080, 0xd3d940e9, 0x18000080,\n\t0xd3d940ea, 0x18000080, 0xd3d940eb, 0x18000080, 0xd3d940ec, 0x18000080,\n\t0xd3d940ed, 0x18000080, 0xd3d940ee, 0x18000080, 0xd3d940ef, 0x18000080,\n\t0xd3d940f0, 0x18000080, 0xd3d940f1, 0x18000080, 0xd3d940f2, 0x18000080,\n\t0xd3d940f3, 0x18000080, 0xd3d940f4, 0x18000080, 0xd3d940f5, 0x18000080,\n\t0xd3d940f6, 0x18000080, 0xd3d940f7, 0x18000080, 0xd3d940f8, 0x18000080,\n\t0xd3d940f9, 0x18000080, 0xd3d940fa, 0x18000080, 0xd3d940fb, 0x18000080,\n\t0xd3d940fc, 0x18000080, 0xd3d940fd, 0x18000080, 0xd3d940fe, 0x18000080,\n\t0xd3d940ff, 0x18000080, 0xb07c0000, 0xbe8a00ff, 0x000000f8, 0xbf11080a,\n\t0x7e000280, 0x7e020280, 0x7e040280, 0x7e060280, 0x7e080280, 0x7e0a0280,\n\t0x7e0c0280, 0x7e0e0280, 0x808a880a, 0xbe80320a, 0xbf84fff5, 0xbf9c0000,\n\t0xd28c0001, 0x0001007f, 0xd28d0001, 0x0002027e, 0x10020288, 0xb88b0904,\n\t0xb78b4000, 0xd1196a01, 0x00001701, 0xbe8a0087, 0xbefc00c1, 0xd89c4000,\n\t0x00020201, 0xd89cc080, 0x00040401, 0x320202ff, 0x00000800, 0x808a810a,\n\t0xbf84fff8, 0xbf810000,\n};\n\n \nstatic const struct soc15_reg_entry vgpr_init_regs[] = {\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 4 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x3f },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x400000 },   \n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0xffffffff },\n};\n\nstatic const struct soc15_reg_entry vgpr_init_regs_arcturus[] = {\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 4 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0xbf },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x400000 },   \n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0xffffffff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0xffffffff },\n};\n\nstatic const struct soc15_reg_entry sgpr1_init_regs[] = {\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 8 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x240 },  \n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x0 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0x000000ff },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0x000000ff },\n};\n\nstatic const struct soc15_reg_entry sgpr2_init_regs[] = {\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 8 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x240 },  \n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x0 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0x0000ff00 },\n   { SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0x0000ff00 },\n};\n\nstatic const struct soc15_reg_entry gfx_v9_0_edc_counter_regs[] = {\n   { SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_SCRATCH_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_UCODE_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_TAG_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_TAG_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmDC_EDC_CSINVOC_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmDC_EDC_RESTORE_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmDC_EDC_STATE_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_GRBM_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_DED), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmSPI_EDC_CNT), 0, 4, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT), 0, 4, 6},\n   { SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_DED_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_INFO), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_SEC_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT), 0, 1, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTCP_ATC_EDC_GATCL1_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2), 0, 4, 6},\n   { SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT), 0, 4, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT), 0, 1, 1},\n   { SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT), 0, 1, 32},\n   { SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2), 0, 1, 32},\n   { SOC15_REG_ENTRY(GC, 0, mmTCI_EDC_CNT), 0, 1, 72},\n   { SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2), 0, 1, 16},\n   { SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT), 0, 1, 2},\n   { SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3), 0, 4, 6},\n};\n\nstatic int gfx_v9_0_do_edc_gds_workarounds(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[0];\n\tint i, r;\n\n\t \n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\treturn 0;\n\n\tr = amdgpu_ring_alloc(ring, 7);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: GDS workarounds failed to lock ring %s (%d).\\n\",\n\t\t\tring->name, r);\n\t\treturn r;\n\t}\n\n\tWREG32_SOC15(GC, 0, mmGDS_VMID0_BASE, 0x00000000);\n\tWREG32_SOC15(GC, 0, mmGDS_VMID0_SIZE, adev->gds.gds_size);\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_DMA_DATA, 5));\n\tamdgpu_ring_write(ring, (PACKET3_DMA_DATA_CP_SYNC |\n\t\t\t\tPACKET3_DMA_DATA_DST_SEL(1) |\n\t\t\t\tPACKET3_DMA_DATA_SRC_SEL(2) |\n\t\t\t\tPACKET3_DMA_DATA_ENGINE(0)));\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, PACKET3_DMA_DATA_CMD_RAW_WAIT |\n\t\t\t\tadev->gds.gds_size);\n\n\tamdgpu_ring_commit(ring);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (ring->wptr == gfx_v9_0_ring_get_rptr_compute(ring))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout)\n\t\tr = -ETIMEDOUT;\n\n\tWREG32_SOC15(GC, 0, mmGDS_VMID0_SIZE, 0x00000000);\n\n\treturn r;\n}\n\nstatic int gfx_v9_0_do_edc_gpr_workarounds(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ring *ring = &adev->gfx.compute_ring[0];\n\tstruct amdgpu_ib ib;\n\tstruct dma_fence *f = NULL;\n\tint r, i;\n\tunsigned total_size, vgpr_offset, sgpr_offset;\n\tu64 gpu_addr;\n\n\tint compute_dim_x = adev->gfx.config.max_shader_engines *\n\t\t\t\t\t\tadev->gfx.config.max_cu_per_sh *\n\t\t\t\t\t\tadev->gfx.config.max_sh_per_se;\n\tint sgpr_work_group_size = 5;\n\tint gpr_reg_size = adev->gfx.config.max_shader_engines + 6;\n\tint vgpr_init_shader_size;\n\tconst u32 *vgpr_init_shader_ptr;\n\tconst struct soc15_reg_entry *vgpr_init_regs_ptr;\n\n\t \n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\treturn 0;\n\n\t \n\tif (!ring->sched.ready)\n\t\treturn 0;\n\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 1)) {\n\t\tvgpr_init_shader_ptr = vgpr_init_compute_shader_arcturus;\n\t\tvgpr_init_shader_size = sizeof(vgpr_init_compute_shader_arcturus);\n\t\tvgpr_init_regs_ptr = vgpr_init_regs_arcturus;\n\t} else {\n\t\tvgpr_init_shader_ptr = vgpr_init_compute_shader;\n\t\tvgpr_init_shader_size = sizeof(vgpr_init_compute_shader);\n\t\tvgpr_init_regs_ptr = vgpr_init_regs;\n\t}\n\n\ttotal_size =\n\t\t(gpr_reg_size * 3 + 4 + 5 + 2) * 4;  \n\ttotal_size +=\n\t\t(gpr_reg_size * 3 + 4 + 5 + 2) * 4;  \n\ttotal_size +=\n\t\t(gpr_reg_size * 3 + 4 + 5 + 2) * 4;  \n\ttotal_size = ALIGN(total_size, 256);\n\tvgpr_offset = total_size;\n\ttotal_size += ALIGN(vgpr_init_shader_size, 256);\n\tsgpr_offset = total_size;\n\ttotal_size += sizeof(sgpr_init_compute_shader);\n\n\t \n\tmemset(&ib, 0, sizeof(ib));\n\tr = amdgpu_ib_get(adev, NULL, total_size,\n\t\t\t\t\tAMDGPU_IB_POOL_DIRECT, &ib);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: failed to get ib (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tfor (i = 0; i < vgpr_init_shader_size/sizeof(u32); i++)\n\t\tib.ptr[i + (vgpr_offset / 4)] = vgpr_init_shader_ptr[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(sgpr_init_compute_shader); i++)\n\t\tib.ptr[i + (sgpr_offset / 4)] = sgpr_init_compute_shader[i];\n\n\t \n\tib.length_dw = 0;\n\n\t \n\t \n\tfor (i = 0; i < gpr_reg_size; i++) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(vgpr_init_regs_ptr[i])\n\t\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = vgpr_init_regs_ptr[i].reg_value;\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)vgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)\n\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = compute_dim_x * 2;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\t \n\tfor (i = 0; i < gpr_reg_size; i++) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(sgpr1_init_regs[i])\n\t\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = sgpr1_init_regs[i].reg_value;\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)\n\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = compute_dim_x / 2 * sgpr_work_group_size;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\t \n\tfor (i = 0; i < gpr_reg_size; i++) {\n\t\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);\n\t\tib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(sgpr2_init_regs[i])\n\t\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\t\tib.ptr[ib.length_dw++] = sgpr2_init_regs[i].reg_value;\n\t}\n\t \n\tgpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;\n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);\n\tib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)\n\t\t\t\t\t\t\t- PACKET3_SET_SH_REG_START;\n\tib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);\n\tib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_DIRECT, 3);\n\tib.ptr[ib.length_dw++] = compute_dim_x / 2 * sgpr_work_group_size;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] = 1;  \n\tib.ptr[ib.length_dw++] =\n\t\tREG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);\n\n\t \n\tib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);\n\tib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);\n\n\t \n\tr = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: ib submit failed (%d).\\n\", r);\n\t\tgoto fail;\n\t}\n\n\t \n\tr = dma_fence_wait(f, false);\n\tif (r) {\n\t\tDRM_ERROR(\"amdgpu: fence wait failed (%d).\\n\", r);\n\t\tgoto fail;\n\t}\n\nfail:\n\tamdgpu_ib_free(adev, &ib, NULL);\n\tdma_fence_put(f);\n\n\treturn r;\n}\n\nstatic int gfx_v9_0_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->gfx.funcs = &gfx_v9_0_gfx_funcs;\n\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 1) ||\n\t    adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 2))\n\t\tadev->gfx.num_gfx_rings = 0;\n\telse\n\t\tadev->gfx.num_gfx_rings = GFX9_NUM_GFX_RINGS;\n\tadev->gfx.xcc_mask = 1;\n\tadev->gfx.num_compute_rings = min(amdgpu_gfx_get_num_kcq(adev),\n\t\t\t\t\t  AMDGPU_MAX_COMPUTE_RINGS);\n\tgfx_v9_0_set_kiq_pm4_funcs(adev);\n\tgfx_v9_0_set_ring_funcs(adev);\n\tgfx_v9_0_set_irq_funcs(adev);\n\tgfx_v9_0_set_gds_init(adev);\n\tgfx_v9_0_set_rlc_funcs(adev);\n\n\t \n\tgfx_v9_0_init_rlcg_reg_access_ctrl(adev);\n\n\treturn gfx_v9_0_init_microcode(adev);\n}\n\nstatic int gfx_v9_0_ecc_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\t \n\tif ((!adev->in_suspend) &&\n\t    (adev->gds.gds_size)) {\n\t\tr = gfx_v9_0_do_edc_gds_workarounds(adev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 2))\n\t\tr = gfx_v9_4_2_do_edc_gpr_workarounds(adev);\n\telse\n\t\tr = gfx_v9_0_do_edc_gpr_workarounds(adev);\n\n\tif (r)\n\t\treturn r;\n\n\tif (adev->gfx.ras &&\n\t    adev->gfx.ras->enable_watchdog_timer)\n\t\tadev->gfx.ras->enable_watchdog_timer(adev);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_reg_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_irq_get(adev, &adev->gfx.priv_inst_irq, 0);\n\tif (r)\n\t\treturn r;\n\n\tr = gfx_v9_0_ecc_late_init(handle);\n\tif (r)\n\t\treturn r;\n\n\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 2))\n\t\tgfx_v9_4_2_debug_trap_config_init(adev,\n\t\t\tadev->vm_manager.first_kfd_vmid, AMDGPU_NUM_VMID);\n\telse\n\t\tgfx_v9_0_debug_trap_config_init(adev,\n\t\t\tadev->vm_manager.first_kfd_vmid, AMDGPU_NUM_VMID);\n\n\treturn 0;\n}\n\nstatic bool gfx_v9_0_is_rlc_enabled(struct amdgpu_device *adev)\n{\n\tuint32_t rlc_setting;\n\n\t \n\trlc_setting = RREG32_SOC15(GC, 0, mmRLC_CNTL);\n\tif (!(rlc_setting & RLC_CNTL__RLC_ENABLE_F32_MASK))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void gfx_v9_0_set_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tuint32_t data;\n\tunsigned i;\n\n\tdata = RLC_SAFE_MODE__CMD_MASK;\n\tdata |= (1 << RLC_SAFE_MODE__MESSAGE__SHIFT);\n\tWREG32_SOC15(GC, 0, mmRLC_SAFE_MODE, data);\n\n\t \n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (!REG_GET_FIELD(RREG32_SOC15(GC, 0, mmRLC_SAFE_MODE), RLC_SAFE_MODE, CMD))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void gfx_v9_0_unset_safe_mode(struct amdgpu_device *adev, int xcc_id)\n{\n\tuint32_t data;\n\n\tdata = RLC_SAFE_MODE__CMD_MASK;\n\tWREG32_SOC15(GC, 0, mmRLC_SAFE_MODE, data);\n}\n\nstatic void gfx_v9_0_update_gfx_cg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) && enable) {\n\t\tgfx_v9_0_enable_gfx_cg_power_gating(adev, true);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)\n\t\t\tgfx_v9_0_enable_gfx_pipeline_powergating(adev, true);\n\t} else {\n\t\tgfx_v9_0_enable_gfx_cg_power_gating(adev, false);\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)\n\t\t\tgfx_v9_0_enable_gfx_pipeline_powergating(adev, false);\n\t}\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic void gfx_v9_0_update_gfx_mg_power_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\tbool enable)\n{\n\t \n\t \n\n\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG) && enable)\n\t\tgfx_v9_0_enable_gfx_static_mg_power_gating(adev, true);\n\telse\n\t\tgfx_v9_0_enable_gfx_static_mg_power_gating(adev, false);\n\n\tif ((adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG) && enable)\n\t\tgfx_v9_0_enable_gfx_dynamic_mg_power_gating(adev, true);\n\telse\n\t\tgfx_v9_0_enable_gfx_dynamic_mg_power_gating(adev, false);\n\n\t \n}\n\nstatic void gfx_v9_0_update_medium_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t data, def;\n\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\t \n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG)) {\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);\n\n\t\tif (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 2, 1))\n\t\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__CPF_CGTT_SCLK_OVERRIDE_MASK;\n\n\t\tdata &= ~(RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t  RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK |\n\t\t\t  RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGLS_OVERRIDE_MASK);\n\n\t\t \n\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK;\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) {\n\t\t\t \n\t\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_RLC_LS) {\n\t\t\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL);\n\t\t\t\tdata |= RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;\n\t\t\t\tif (def != data)\n\t\t\t\t\tWREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL, data);\n\t\t\t}\n\t\t\t \n\t\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CP_LS) {\n\t\t\t\tdef = data = RREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL);\n\t\t\t\tdata |= CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;\n\t\t\t\tif (def != data)\n\t\t\t\t\tWREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL, data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);\n\n\t\tif (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 2, 1))\n\t\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__CPF_CGTT_SCLK_OVERRIDE_MASK;\n\n\t\tdata |= (RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |\n\t\t\t RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK |\n\t\t\t RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGLS_OVERRIDE_MASK);\n\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tdata = RREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL);\n\t\tif (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\t \n\t\tdata = RREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL);\n\t\tif (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK) {\n\t\t\tdata &= ~CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;\n\t\t\tWREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL, data);\n\t\t}\n\t}\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic void gfx_v9_0_update_3d_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t   bool enable)\n{\n\tuint32_t data, def;\n\n\tif (!adev->gfx.num_gfx_rings)\n\t\treturn;\n\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\t \n\tif (enable) {\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);\n\t\t \n\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_GFX3D_CG_OVERRIDE_MASK;\n\t\t \n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tdef = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D);\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG)\n\t\t\tdata = (0x36 << RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |\n\t\t\t\tRLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK;\n\t\telse\n\t\t\tdata = 0x0 << RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD__SHIFT;\n\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS)\n\t\t\tdata |= (0x000F << RLC_CGCG_CGLS_CTRL_3D__CGLS_REP_COMPANSAT_DELAY__SHIFT) |\n\t\t\t\tRLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK;\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D, data);\n\n\t\t \n\t\tdef = RREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL);\n\t\tdata = (0x0100 << CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY__SHIFT) |\n\t\t\t(0x0090 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL, data);\n\t} else {\n\t\t \n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D);\n\t\t \n\t\tdata &= ~(RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK |\n\t\t\t  RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK);\n\t\t \n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D, data);\n\t}\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic void gfx_v9_0_update_coarse_grain_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t\t      bool enable)\n{\n\tuint32_t def, data;\n\n\tamdgpu_gfx_rlc_enter_safe_mode(adev, 0);\n\n\tif (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)) {\n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);\n\t\t \n\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGCG_OVERRIDE_MASK;\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)\n\t\t\tdata &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGLS_OVERRIDE_MASK;\n\t\telse\n\t\t\tdata |= RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGLS_OVERRIDE_MASK;\n\t\t \n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\t \n\t\tdef = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL);\n\n\t\tif (adev->ip_versions[GC_HWIP][0] == IP_VERSION(9, 4, 1))\n\t\t\tdata = (0x2000 << RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |\n\t\t\t\tRLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;\n\t\telse\n\t\t\tdata = (0x36 << RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |\n\t\t\t\tRLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;\n\t\tif (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)\n\t\t\tdata |= (0x000F << RLC_CGCG_CGLS_CTRL__CGLS_REP_COMPANSAT_DELAY__SHIFT) |\n\t\t\t\tRLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, data);\n\n\t\t \n\t\tdef = RREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL);\n\t\tdata = (0x0100 << CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY__SHIFT) |\n\t\t\t(0x0090 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);\n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL, data);\n\t} else {\n\t\tdef = data = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL);\n\t\t \n\t\tdata &= ~(RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK | RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK);\n\t\t \n\t\tif (def != data)\n\t\t\tWREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, data);\n\t}\n\n\tamdgpu_gfx_rlc_exit_safe_mode(adev, 0);\n}\n\nstatic int gfx_v9_0_update_gfx_clock_gating(struct amdgpu_device *adev,\n\t\t\t\t\t    bool enable)\n{\n\tif (enable) {\n\t\t \n\t\tgfx_v9_0_update_medium_grain_clock_gating(adev, enable);\n\t\t \n\t\tgfx_v9_0_update_3d_clock_gating(adev, enable);\n\t\t \n\t\tgfx_v9_0_update_coarse_grain_clock_gating(adev, enable);\n\t} else {\n\t\t \n\t\tgfx_v9_0_update_coarse_grain_clock_gating(adev, enable);\n\t\t \n\t\tgfx_v9_0_update_3d_clock_gating(adev, enable);\n\t\t \n\t\tgfx_v9_0_update_medium_grain_clock_gating(adev, enable);\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v9_0_update_spm_vmid_internal(struct amdgpu_device *adev,\n\t\t\t\t\t      unsigned int vmid)\n{\n\tu32 reg, data;\n\n\treg = SOC15_REG_OFFSET(GC, 0, mmRLC_SPM_MC_CNTL);\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tdata = RREG32_NO_KIQ(reg);\n\telse\n\t\tdata = RREG32_SOC15(GC, 0, mmRLC_SPM_MC_CNTL);\n\n\tdata &= ~RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK;\n\tdata |= (vmid & RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK) << RLC_SPM_MC_CNTL__RLC_SPM_VMID__SHIFT;\n\n\tif (amdgpu_sriov_is_pp_one_vf(adev))\n\t\tWREG32_SOC15_NO_KIQ(GC, 0, mmRLC_SPM_MC_CNTL, data);\n\telse\n\t\tWREG32_SOC15(GC, 0, mmRLC_SPM_MC_CNTL, data);\n}\n\nstatic void gfx_v9_0_update_spm_vmid(struct amdgpu_device *adev, unsigned int vmid)\n{\n\tamdgpu_gfx_off_ctrl(adev, false);\n\n\tgfx_v9_0_update_spm_vmid_internal(adev, vmid);\n\n\tamdgpu_gfx_off_ctrl(adev, true);\n}\n\nstatic bool gfx_v9_0_check_rlcg_range(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t offset,\n\t\t\t\t\tstruct soc15_reg_rlcg *entries, int arr_size)\n{\n\tint i;\n\tuint32_t reg;\n\n\tif (!entries)\n\t\treturn false;\n\n\tfor (i = 0; i < arr_size; i++) {\n\t\tconst struct soc15_reg_rlcg *entry;\n\n\t\tentry = &entries[i];\n\t\treg = adev->reg_offset[entry->hwip][entry->instance][entry->segment] + entry->reg;\n\t\tif (offset == reg)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool gfx_v9_0_is_rlcg_access_range(struct amdgpu_device *adev, u32 offset)\n{\n\treturn gfx_v9_0_check_rlcg_range(adev, offset,\n\t\t\t\t\t(void *)rlcg_access_gc_9_0,\n\t\t\t\t\tARRAY_SIZE(rlcg_access_gc_9_0));\n}\n\nstatic const struct amdgpu_rlc_funcs gfx_v9_0_rlc_funcs = {\n\t.is_rlc_enabled = gfx_v9_0_is_rlc_enabled,\n\t.set_safe_mode = gfx_v9_0_set_safe_mode,\n\t.unset_safe_mode = gfx_v9_0_unset_safe_mode,\n\t.init = gfx_v9_0_rlc_init,\n\t.get_csb_size = gfx_v9_0_get_csb_size,\n\t.get_csb_buffer = gfx_v9_0_get_csb_buffer,\n\t.get_cp_table_num = gfx_v9_0_cp_jump_table_num,\n\t.resume = gfx_v9_0_rlc_resume,\n\t.stop = gfx_v9_0_rlc_stop,\n\t.reset = gfx_v9_0_rlc_reset,\n\t.start = gfx_v9_0_rlc_start,\n\t.update_spm_vmid = gfx_v9_0_update_spm_vmid,\n\t.is_rlcg_access_range = gfx_v9_0_is_rlcg_access_range,\n};\n\nstatic int gfx_v9_0_set_powergating_state(void *handle,\n\t\t\t\t\t  enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = (state == AMD_PG_STATE_GATE);\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 3, 0):\n\t\tif (!enable)\n\t\t\tamdgpu_gfx_off_ctrl(adev, false);\n\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS) {\n\t\t\tgfx_v9_0_enable_sck_slow_down_on_power_up(adev, true);\n\t\t\tgfx_v9_0_enable_sck_slow_down_on_power_down(adev, true);\n\t\t} else {\n\t\t\tgfx_v9_0_enable_sck_slow_down_on_power_up(adev, false);\n\t\t\tgfx_v9_0_enable_sck_slow_down_on_power_down(adev, false);\n\t\t}\n\n\t\tif (adev->pg_flags & AMD_PG_SUPPORT_CP)\n\t\t\tgfx_v9_0_enable_cp_power_gating(adev, true);\n\t\telse\n\t\t\tgfx_v9_0_enable_cp_power_gating(adev, false);\n\n\t\t \n\t\tgfx_v9_0_update_gfx_cg_power_gating(adev, enable);\n\n\t\t \n\t\tgfx_v9_0_update_gfx_mg_power_gating(adev, enable);\n\n\t\tif (enable)\n\t\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 1):\n\t\tamdgpu_gfx_off_ctrl(adev, enable);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 2):\n\t\tgfx_v9_0_update_gfx_clock_gating(adev,\n\t\t\t\t\t\t state == AMD_CG_STATE_GATE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v9_0_get_clockgating_state(void *handle, u64 *flags)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint data;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\t*flags = 0;\n\n\t \n\tdata = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE));\n\tif (!(data & RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK))\n\t\t*flags |= AMD_CG_SUPPORT_GFX_MGCG;\n\n\t \n\tdata = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGCG_CGLS_CTRL));\n\tif (data & RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGCG;\n\n\t \n\tif (data & RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CGLS;\n\n\t \n\tdata = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_MEM_SLP_CNTL));\n\tif (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_RLC_LS | AMD_CG_SUPPORT_GFX_MGLS;\n\n\t \n\tdata = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmCP_MEM_SLP_CNTL));\n\tif (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK)\n\t\t*flags |= AMD_CG_SUPPORT_GFX_CP_LS | AMD_CG_SUPPORT_GFX_MGLS;\n\n\tif (adev->ip_versions[GC_HWIP][0] != IP_VERSION(9, 4, 1)) {\n\t\t \n\t\tdata = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D));\n\t\tif (data & RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK)\n\t\t\t*flags |= AMD_CG_SUPPORT_GFX_3D_CGCG;\n\n\t\t \n\t\tif (data & RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK)\n\t\t\t*flags |= AMD_CG_SUPPORT_GFX_3D_CGLS;\n\t}\n}\n\nstatic u64 gfx_v9_0_ring_get_rptr_gfx(struct amdgpu_ring *ring)\n{\n\treturn *ring->rptr_cpu_addr;  \n}\n\nstatic u64 gfx_v9_0_ring_get_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tu64 wptr;\n\n\t \n\tif (ring->use_doorbell) {\n\t\twptr = atomic64_read((atomic64_t *)ring->wptr_cpu_addr);\n\t} else {\n\t\twptr = RREG32_SOC15(GC, 0, mmCP_RB0_WPTR);\n\t\twptr += (u64)RREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI) << 32;\n\t}\n\n\treturn wptr;\n}\n\nstatic void gfx_v9_0_ring_set_wptr_gfx(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tif (ring->use_doorbell) {\n\t\t \n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, ring->wptr);\n\t\tWDOORBELL64(ring->doorbell_index, ring->wptr);\n\t} else {\n\t\tWREG32_SOC15(GC, 0, mmCP_RB0_WPTR, lower_32_bits(ring->wptr));\n\t\tWREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI, upper_32_bits(ring->wptr));\n\t}\n}\n\nstatic void gfx_v9_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tu32 ref_and_mask, reg_mem_engine;\n\tconst struct nbio_hdp_flush_reg *nbio_hf_reg = adev->nbio.hdp_flush_reg;\n\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) {\n\t\tswitch (ring->me) {\n\t\tcase 1:\n\t\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp2 << ring->pipe;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp6 << ring->pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\treg_mem_engine = 0;\n\t} else {\n\t\tref_and_mask = nbio_hf_reg->ref_and_mask_cp0;\n\t\treg_mem_engine = 1;  \n\t}\n\n\tgfx_v9_0_wait_reg_mem(ring, reg_mem_engine, 0, 1,\n\t\t\t      adev->nbio.funcs->get_hdp_flush_req_offset(adev),\n\t\t\t      adev->nbio.funcs->get_hdp_flush_done_offset(adev),\n\t\t\t      ref_and_mask, ref_and_mask, 0x20);\n}\n\nstatic void gfx_v9_0_ring_emit_ib_gfx(struct amdgpu_ring *ring,\n\t\t\t\t\tstruct amdgpu_job *job,\n\t\t\t\t\tstruct amdgpu_ib *ib,\n\t\t\t\t\tuint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 header, control = 0;\n\n\tif (ib->flags & AMDGPU_IB_FLAG_CE)\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER_CONST, 2);\n\telse\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\n\tcontrol |= ib->length_dw | (vmid << 24);\n\n\tif (ib->flags & AMDGPU_IB_FLAG_PREEMPT) {\n\t\tcontrol |= INDIRECT_BUFFER_PRE_ENB(1);\n\n\t\tif (flags & AMDGPU_IB_PREEMPTED)\n\t\t\tcontrol |= INDIRECT_BUFFER_PRE_RESUME(1);\n\n\t\tif (!(ib->flags & AMDGPU_IB_FLAG_CE) && vmid)\n\t\t\tgfx_v9_0_ring_emit_de_meta(ring,\n\t\t\t\t\t\t   (!amdgpu_sriov_vf(ring->adev) &&\n\t\t\t\t\t\t   flags & AMDGPU_IB_PREEMPTED) ?\n\t\t\t\t\t\t   true : false,\n\t\t\t\t\t\t   job->gds_size > 0 && job->gds_base != 0);\n\t}\n\n\tamdgpu_ring_write(ring, header);\n\tBUG_ON(ib->gpu_addr & 0x3);  \n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t(2 << 0) |\n#endif\n\t\tlower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_ib_on_emit_cntl(ring);\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v9_0_ring_patch_cntl(struct amdgpu_ring *ring,\n\t\t\t\t     unsigned offset)\n{\n\tu32 control = ring->ring[offset];\n\n\tcontrol |= INDIRECT_BUFFER_PRE_RESUME(1);\n\tring->ring[offset] = control;\n}\n\nstatic void gfx_v9_0_ring_patch_ce_meta(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned offset)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tvoid *ce_payload_cpu_addr;\n\tuint64_t payload_offset, payload_size;\n\n\tpayload_size = sizeof(struct v9_ce_ib_state);\n\n\tif (ring->is_mes_queue) {\n\t\tpayload_offset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t\t  gfx[0].gfx_meta_data) +\n\t\t\toffsetof(struct v9_gfx_meta_data, ce_payload);\n\t\tce_payload_cpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_cpu_addr(ring, payload_offset);\n\t} else {\n\t\tpayload_offset = offsetof(struct v9_gfx_meta_data, ce_payload);\n\t\tce_payload_cpu_addr = adev->virt.csa_cpu_addr + payload_offset;\n\t}\n\n\tif (offset + (payload_size >> 2) <= ring->buf_mask + 1) {\n\t\tmemcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, payload_size);\n\t} else {\n\t\tmemcpy((void *)&ring->ring[offset], ce_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset) << 2);\n\t\tpayload_size -= (ring->buf_mask + 1 - offset) << 2;\n\t\tmemcpy((void *)&ring->ring[0],\n\t\t       ce_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size);\n\t}\n}\n\nstatic void gfx_v9_0_ring_patch_de_meta(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned offset)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tvoid *de_payload_cpu_addr;\n\tuint64_t payload_offset, payload_size;\n\n\tpayload_size = sizeof(struct v9_de_ib_state);\n\n\tif (ring->is_mes_queue) {\n\t\tpayload_offset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t\t  gfx[0].gfx_meta_data) +\n\t\t\toffsetof(struct v9_gfx_meta_data, de_payload);\n\t\tde_payload_cpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_cpu_addr(ring, payload_offset);\n\t} else {\n\t\tpayload_offset = offsetof(struct v9_gfx_meta_data, de_payload);\n\t\tde_payload_cpu_addr = adev->virt.csa_cpu_addr + payload_offset;\n\t}\n\n\t((struct v9_de_ib_state *)de_payload_cpu_addr)->ib_completion_status =\n\t\tIB_COMPLETION_STATUS_PREEMPTED;\n\n\tif (offset + (payload_size >> 2) <= ring->buf_mask + 1) {\n\t\tmemcpy((void *)&ring->ring[offset], de_payload_cpu_addr, payload_size);\n\t} else {\n\t\tmemcpy((void *)&ring->ring[offset], de_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset) << 2);\n\t\tpayload_size -= (ring->buf_mask + 1 - offset) << 2;\n\t\tmemcpy((void *)&ring->ring[0],\n\t\t       de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size);\n\t}\n}\n\nstatic void gfx_v9_0_ring_emit_ib_compute(struct amdgpu_ring *ring,\n\t\t\t\t\t  struct amdgpu_job *job,\n\t\t\t\t\t  struct amdgpu_ib *ib,\n\t\t\t\t\t  uint32_t flags)\n{\n\tunsigned vmid = AMDGPU_JOB_GET_VMID(job);\n\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);\n\n\t \n\tif (ib->flags & AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID) {\n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tamdgpu_ring_write(ring, mmGDS_COMPUTE_MAX_WAVE_ID);\n\t\tamdgpu_ring_write(ring, ring->adev->gds.gds_compute_max_wave_id);\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tBUG_ON(ib->gpu_addr & 0x3);  \n\tamdgpu_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t\t(2 << 0) |\n#endif\n\t\t\t\tlower_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\n\tamdgpu_ring_write(ring, control);\n}\n\nstatic void gfx_v9_0_ring_emit_fence(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t     u64 seq, unsigned flags)\n{\n\tbool write64bit = flags & AMDGPU_FENCE_FLAG_64BIT;\n\tbool int_sel = flags & AMDGPU_FENCE_FLAG_INT;\n\tbool writeback = flags & AMDGPU_FENCE_FLAG_TC_WB_ONLY;\n\tbool exec = flags & AMDGPU_FENCE_FLAG_EXEC;\n\tuint32_t dw2 = 0;\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, 6));\n\n\tif (writeback) {\n\t\tdw2 = EOP_TC_NC_ACTION_EN;\n\t} else {\n\t\tdw2 = EOP_TCL1_ACTION_EN | EOP_TC_ACTION_EN |\n\t\t\t\tEOP_TC_MD_ACTION_EN;\n\t}\n\tdw2 |= EOP_TC_WB_ACTION_EN | EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\tEVENT_INDEX(5);\n\tif (exec)\n\t\tdw2 |= EOP_EXEC;\n\n\tamdgpu_ring_write(ring, dw2);\n\tamdgpu_ring_write(ring, DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));\n\n\t \n\tif (write64bit)\n\t\tBUG_ON(addr & 0x7);\n\telse\n\t\tBUG_ON(addr & 0x3);\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\tamdgpu_ring_write(ring, upper_32_bits(seq));\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic void gfx_v9_0_ring_emit_pipeline_sync(struct amdgpu_ring *ring)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\tuint32_t seq = ring->fence_drv.sync_seq;\n\tuint64_t addr = ring->fence_drv.gpu_addr;\n\n\tgfx_v9_0_wait_reg_mem(ring, usepfp, 1, 0,\n\t\t\t      lower_32_bits(addr), upper_32_bits(addr),\n\t\t\t      seq, 0xffffffff, 4);\n}\n\nstatic void gfx_v9_0_ring_emit_vm_flush(struct amdgpu_ring *ring,\n\t\t\t\t\tunsigned vmid, uint64_t pd_addr)\n{\n\tamdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);\n\n\t \n\tif (ring->funcs->type == AMDGPU_RING_TYPE_GFX) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tamdgpu_ring_write(ring, 0x0);\n\t}\n}\n\nstatic u64 gfx_v9_0_ring_get_rptr_compute(struct amdgpu_ring *ring)\n{\n\treturn *ring->rptr_cpu_addr;  \n}\n\nstatic u64 gfx_v9_0_ring_get_wptr_compute(struct amdgpu_ring *ring)\n{\n\tu64 wptr;\n\n\t \n\tif (ring->use_doorbell)\n\t\twptr = atomic64_read((atomic64_t *)ring->wptr_cpu_addr);\n\telse\n\t\tBUG();\n\treturn wptr;\n}\n\nstatic void gfx_v9_0_ring_set_wptr_compute(struct amdgpu_ring *ring)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\tif (ring->use_doorbell) {\n\t\tatomic64_set((atomic64_t *)ring->wptr_cpu_addr, ring->wptr);\n\t\tWDOORBELL64(ring->doorbell_index, ring->wptr);\n\t} else{\n\t\tBUG();  \n\t}\n}\n\nstatic void gfx_v9_0_ring_emit_fence_kiq(struct amdgpu_ring *ring, u64 addr,\n\t\t\t\t\t u64 seq, unsigned int flags)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\t \n\tBUG_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t WRITE_DATA_DST_SEL(5) | WR_CONFIRM));\n\tamdgpu_ring_write(ring, lower_32_bits(addr));\n\tamdgpu_ring_write(ring, upper_32_bits(addr));\n\tamdgpu_ring_write(ring, lower_32_bits(seq));\n\n\tif (flags & AMDGPU_FENCE_FLAG_INT) {\n\t\t \n\t\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\t\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(0) |\n\t\t\t\t\t WRITE_DATA_DST_SEL(0) | WR_CONFIRM));\n\t\tamdgpu_ring_write(ring, SOC15_REG_OFFSET(GC, 0, mmCPC_INT_STATUS));\n\t\tamdgpu_ring_write(ring, 0);\n\t\tamdgpu_ring_write(ring, 0x20000000);  \n\t}\n}\n\nstatic void gfx_v9_ring_emit_sb(struct amdgpu_ring *ring)\n{\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic void gfx_v9_0_ring_emit_ce_meta(struct amdgpu_ring *ring, bool resume)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_ce_ib_state ce_payload = {0};\n\tuint64_t offset, ce_payload_gpu_addr;\n\tvoid *ce_payload_cpu_addr;\n\tint cnt;\n\n\tcnt = (sizeof(ce_payload) >> 2) + 4 - 2;\n\n\tif (ring->is_mes_queue) {\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  gfx[0].gfx_meta_data) +\n\t\t\toffsetof(struct v9_gfx_meta_data, ce_payload);\n\t\tce_payload_gpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tce_payload_cpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\t} else {\n\t\toffset = offsetof(struct v9_gfx_meta_data, ce_payload);\n\t\tce_payload_gpu_addr = amdgpu_csa_vaddr(ring->adev) + offset;\n\t\tce_payload_cpu_addr = adev->virt.csa_cpu_addr + offset;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, cnt));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(2) |\n\t\t\t\t WRITE_DATA_DST_SEL(8) |\n\t\t\t\t WR_CONFIRM) |\n\t\t\t\t WRITE_DATA_CACHE_POLICY(0));\n\tamdgpu_ring_write(ring, lower_32_bits(ce_payload_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ce_payload_gpu_addr));\n\n\tamdgpu_ring_ib_on_emit_ce(ring);\n\n\tif (resume)\n\t\tamdgpu_ring_write_multiple(ring, ce_payload_cpu_addr,\n\t\t\t\t\t   sizeof(ce_payload) >> 2);\n\telse\n\t\tamdgpu_ring_write_multiple(ring, (void *)&ce_payload,\n\t\t\t\t\t   sizeof(ce_payload) >> 2);\n}\n\nstatic int gfx_v9_0_ring_preempt_ib(struct amdgpu_ring *ring)\n{\n\tint i, r = 0;\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct amdgpu_kiq *kiq = &adev->gfx.kiq[0];\n\tstruct amdgpu_ring *kiq_ring = &kiq->ring;\n\tunsigned long flags;\n\n\tif (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&kiq->ring_lock, flags);\n\n\tif (amdgpu_ring_alloc(kiq_ring, kiq->pmf->unmap_queues_size)) {\n\t\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tamdgpu_ring_set_preempt_cond_exec(ring, false);\n\n\tring->trail_seq += 1;\n\tamdgpu_ring_alloc(ring, 13);\n\tgfx_v9_0_ring_emit_fence(ring, ring->trail_fence_gpu_addr,\n\t\t\t\t ring->trail_seq, AMDGPU_FENCE_FLAG_EXEC | AMDGPU_FENCE_FLAG_INT);\n\n\t \n\tkiq->pmf->kiq_unmap_queues(kiq_ring, ring, PREEMPT_QUEUES_NO_UNMAP,\n\t\t\t\t   ring->trail_fence_gpu_addr,\n\t\t\t\t   ring->trail_seq);\n\n\tamdgpu_ring_commit(kiq_ring);\n\tspin_unlock_irqrestore(&kiq->ring_lock, flags);\n\n\t \n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (ring->trail_seq ==\n\t\t\tle32_to_cpu(*ring->trail_fence_cpu_addr))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= adev->usec_timeout) {\n\t\tr = -EINVAL;\n\t\tDRM_WARN(\"ring %d timeout to preempt ib\\n\", ring->idx);\n\t}\n\n\t \n\tamdgpu_ring_emit_wreg(ring,\n\t\t\t      SOC15_REG_OFFSET(GC, 0, mmCP_VMID_PREEMPT),\n\t\t\t      0x0);\n\tamdgpu_ring_commit(ring);\n\n\t \n\tamdgpu_ring_set_preempt_cond_exec(ring, true);\n\treturn r;\n}\n\nstatic void gfx_v9_0_ring_emit_de_meta(struct amdgpu_ring *ring, bool resume, bool usegds)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tstruct v9_de_ib_state de_payload = {0};\n\tuint64_t offset, gds_addr, de_payload_gpu_addr;\n\tvoid *de_payload_cpu_addr;\n\tint cnt;\n\n\tif (ring->is_mes_queue) {\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  gfx[0].gfx_meta_data) +\n\t\t\toffsetof(struct v9_gfx_meta_data, de_payload);\n\t\tde_payload_gpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tde_payload_cpu_addr =\n\t\t\tamdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\n\t\toffset = offsetof(struct amdgpu_mes_ctx_meta_data,\n\t\t\t\t  gfx[0].gds_backup) +\n\t\t\toffsetof(struct v9_gfx_meta_data, de_payload);\n\t\tgds_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t} else {\n\t\toffset = offsetof(struct v9_gfx_meta_data, de_payload);\n\t\tde_payload_gpu_addr = amdgpu_csa_vaddr(ring->adev) + offset;\n\t\tde_payload_cpu_addr = adev->virt.csa_cpu_addr + offset;\n\n\t\tgds_addr = ALIGN(amdgpu_csa_vaddr(ring->adev) +\n\t\t\t\t AMDGPU_CSA_SIZE - adev->gds.gds_size,\n\t\t\t\t PAGE_SIZE);\n\t}\n\n\tif (usegds) {\n\t\tde_payload.gds_backup_addrlo = lower_32_bits(gds_addr);\n\t\tde_payload.gds_backup_addrhi = upper_32_bits(gds_addr);\n\t}\n\n\tcnt = (sizeof(de_payload) >> 2) + 4 - 2;\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, cnt));\n\tamdgpu_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\t WRITE_DATA_DST_SEL(8) |\n\t\t\t\t WR_CONFIRM) |\n\t\t\t\t WRITE_DATA_CACHE_POLICY(0));\n\tamdgpu_ring_write(ring, lower_32_bits(de_payload_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(de_payload_gpu_addr));\n\n\tamdgpu_ring_ib_on_emit_de(ring);\n\tif (resume)\n\t\tamdgpu_ring_write_multiple(ring, de_payload_cpu_addr,\n\t\t\t\t\t   sizeof(de_payload) >> 2);\n\telse\n\t\tamdgpu_ring_write_multiple(ring, (void *)&de_payload,\n\t\t\t\t\t   sizeof(de_payload) >> 2);\n}\n\nstatic void gfx_v9_0_ring_emit_frame_cntl(struct amdgpu_ring *ring, bool start,\n\t\t\t\t   bool secure)\n{\n\tuint32_t v = secure ? FRAME_TMZ : 0;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_FRAME_CONTROL, 0));\n\tamdgpu_ring_write(ring, v | FRAME_CMD(start ? 0 : 1));\n}\n\nstatic void gfx_v9_ring_emit_cntxcntl(struct amdgpu_ring *ring, uint32_t flags)\n{\n\tuint32_t dw2 = 0;\n\n\tgfx_v9_0_ring_emit_ce_meta(ring,\n\t\t\t\t   (!amdgpu_sriov_vf(ring->adev) &&\n\t\t\t\t   flags & AMDGPU_IB_PREEMPTED) ? true : false);\n\n\tdw2 |= 0x80000000;  \n\tif (flags & AMDGPU_HAVE_CTX_SWITCH) {\n\t\t \n\t\tdw2 |= 0x8001;\n\t\t \n\t\tdw2 |= 0x01000000;\n\t\t \n\t\tdw2 |= 0x10002;\n\n\t\t \n\t\tif (AMDGPU_PREAMBLE_IB_PRESENT & flags)\n\t\t\tdw2 |= 0x10000000;\n\t} else {\n\t\t \n\t\tif (AMDGPU_PREAMBLE_IB_PRESENT_FIRST & flags)\n\t\t\tdw2 |= 0x10000000;\n\t}\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tamdgpu_ring_write(ring, dw2);\n\tamdgpu_ring_write(ring, 0);\n}\n\nstatic unsigned gfx_v9_0_ring_emit_init_cond_exec(struct amdgpu_ring *ring)\n{\n\tunsigned ret;\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COND_EXEC, 3));\n\tamdgpu_ring_write(ring, lower_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, upper_32_bits(ring->cond_exe_gpu_addr));\n\tamdgpu_ring_write(ring, 0);  \n\tret = ring->wptr & ring->buf_mask;\n\tamdgpu_ring_write(ring, 0x55aa55aa);  \n\treturn ret;\n}\n\nstatic void gfx_v9_0_ring_emit_patch_cond_exec(struct amdgpu_ring *ring, unsigned offset)\n{\n\tunsigned cur;\n\tBUG_ON(offset > ring->buf_mask);\n\tBUG_ON(ring->ring[offset] != 0x55aa55aa);\n\n\tcur = (ring->wptr - 1) & ring->buf_mask;\n\tif (likely(cur > offset))\n\t\tring->ring[offset] = cur - offset;\n\telse\n\t\tring->ring[offset] = (ring->ring_size>>2) - offset + cur;\n}\n\nstatic void gfx_v9_0_ring_emit_rreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t    uint32_t reg_val_offs)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_COPY_DATA, 4));\n\tamdgpu_ring_write(ring, 0 |\t \n\t\t\t\t(5 << 8) |\t \n\t\t\t\t(1 << 20));\t \n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, lower_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n\tamdgpu_ring_write(ring, upper_32_bits(adev->wb.gpu_addr +\n\t\t\t\treg_val_offs * 4));\n}\n\nstatic void gfx_v9_0_ring_emit_wreg(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t    uint32_t val)\n{\n\tuint32_t cmd = 0;\n\n\tswitch (ring->funcs->type) {\n\tcase AMDGPU_RING_TYPE_GFX:\n\t\tcmd = WRITE_DATA_ENGINE_SEL(1) | WR_CONFIRM;\n\t\tbreak;\n\tcase AMDGPU_RING_TYPE_KIQ:\n\t\tcmd = (1 << 16);  \n\t\tbreak;\n\tdefault:\n\t\tcmd = WR_CONFIRM;\n\t\tbreak;\n\t}\n\tamdgpu_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tamdgpu_ring_write(ring, cmd);\n\tamdgpu_ring_write(ring, reg);\n\tamdgpu_ring_write(ring, 0);\n\tamdgpu_ring_write(ring, val);\n}\n\nstatic void gfx_v9_0_ring_emit_reg_wait(struct amdgpu_ring *ring, uint32_t reg,\n\t\t\t\t\tuint32_t val, uint32_t mask)\n{\n\tgfx_v9_0_wait_reg_mem(ring, 0, 0, 0, reg, 0, val, mask, 0x20);\n}\n\nstatic void gfx_v9_0_ring_emit_reg_write_reg_wait(struct amdgpu_ring *ring,\n\t\t\t\t\t\t  uint32_t reg0, uint32_t reg1,\n\t\t\t\t\t\t  uint32_t ref, uint32_t mask)\n{\n\tint usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);\n\tstruct amdgpu_device *adev = ring->adev;\n\tbool fw_version_ok = (ring->funcs->type == AMDGPU_RING_TYPE_GFX) ?\n\t\tadev->gfx.me_fw_write_wait : adev->gfx.mec_fw_write_wait;\n\n\tif (fw_version_ok)\n\t\tgfx_v9_0_wait_reg_mem(ring, usepfp, 0, 1, reg0, reg1,\n\t\t\t\t      ref, mask, 0x20);\n\telse\n\t\tamdgpu_ring_emit_reg_write_reg_wait_helper(ring, reg0, reg1,\n\t\t\t\t\t\t\t   ref, mask);\n}\n\nstatic void gfx_v9_0_ring_soft_recovery(struct amdgpu_ring *ring, unsigned vmid)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t value = 0;\n\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CMD, 0x03);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, MODE, 0x01);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, CHECK_VMID, 1);\n\tvalue = REG_SET_FIELD(value, SQ_CMD, VM_ID, vmid);\n\tWREG32_SOC15(GC, 0, mmSQ_CMD, value);\n}\n\nstatic void gfx_v9_0_set_gfx_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t       TIME_STAMP_INT_ENABLE,\n\t\t\t       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v9_0_set_compute_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     int me, int pipe,\n\t\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tu32 mec_int_cntl, mec_int_cntl_reg;\n\n\t \n\n\tif (me == 1) {\n\t\tswitch (pipe) {\n\t\tcase 0:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE0_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE1_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE2_INT_CNTL);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmec_int_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE3_INT_CNTL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"invalid me %d\\n\", me);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tmec_int_cntl = RREG32_SOC15_IP(GC,mec_int_cntl_reg);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     TIME_STAMP_INT_ENABLE, 0);\n\t\tWREG32_SOC15_IP(GC, mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tmec_int_cntl = RREG32_SOC15_IP(GC, mec_int_cntl_reg);\n\t\tmec_int_cntl = REG_SET_FIELD(mec_int_cntl, CP_ME1_PIPE0_INT_CNTL,\n\t\t\t\t\t     TIME_STAMP_INT_ENABLE, 1);\n\t\tWREG32_SOC15_IP(GC, mec_int_cntl_reg, mec_int_cntl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v9_0_set_priv_reg_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t     struct amdgpu_irq_src *source,\n\t\t\t\t\t     unsigned type,\n\t\t\t\t\t     enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t       PRIV_REG_INT_ENABLE,\n\t\t\t       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_set_priv_inst_fault_state(struct amdgpu_device *adev,\n\t\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t\t      unsigned type,\n\t\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t       PRIV_INSTR_INT_ENABLE,\n\t\t\t       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define ENABLE_ECC_ON_ME_PIPE(me, pipe)\t\t\t\t\\\n\tWREG32_FIELD15(GC, 0, CP_ME##me##_PIPE##pipe##_INT_CNTL,\\\n\t\t\tCP_ECC_ERROR_INT_ENABLE, 1)\n\n#define DISABLE_ECC_ON_ME_PIPE(me, pipe)\t\t\t\\\n\tWREG32_FIELD15(GC, 0, CP_ME##me##_PIPE##pipe##_INT_CNTL,\\\n\t\t\tCP_ECC_ERROR_INT_ENABLE, 0)\n\nstatic int gfx_v9_0_set_cp_ecc_error_state(struct amdgpu_device *adev,\n\t\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t\t      unsigned type,\n\t\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\tWREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t\tCP_ECC_ERROR_INT_ENABLE, 0);\n\t\tDISABLE_ECC_ON_ME_PIPE(1, 0);\n\t\tDISABLE_ECC_ON_ME_PIPE(1, 1);\n\t\tDISABLE_ECC_ON_ME_PIPE(1, 2);\n\t\tDISABLE_ECC_ON_ME_PIPE(1, 3);\n\t\tbreak;\n\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\tWREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,\n\t\t\t\tCP_ECC_ERROR_INT_ENABLE, 1);\n\t\tENABLE_ECC_ON_ME_PIPE(1, 0);\n\t\tENABLE_ECC_ON_ME_PIPE(1, 1);\n\t\tENABLE_ECC_ON_ME_PIPE(1, 2);\n\t\tENABLE_ECC_ON_ME_PIPE(1, 3);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int gfx_v9_0_set_eop_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_irq_src *src,\n\t\t\t\t\t    unsigned type,\n\t\t\t\t\t    enum amdgpu_interrupt_state state)\n{\n\tswitch (type) {\n\tcase AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP:\n\t\tgfx_v9_0_set_gfx_eop_interrupt_state(adev, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 1, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE1_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 1, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE2_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 1, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE3_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 1, 3, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE0_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 2, 0, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE1_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 2, 1, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE2_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 2, 2, state);\n\t\tbreak;\n\tcase AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE3_EOP:\n\t\tgfx_v9_0_set_compute_eop_interrupt_state(adev, 2, 3, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gfx_v9_0_eop_irq(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_irq_src *source,\n\t\t\t    struct amdgpu_iv_entry *entry)\n{\n\tint i;\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\n\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\tswitch (me_id) {\n\tcase 0:\n\t\tif (adev->gfx.num_gfx_rings &&\n\t\t    !amdgpu_mcbp_handle_trailing_fence_irq(&adev->gfx.muxer)) {\n\t\t\t \n\t\t\tfor (i = 0; i < GFX9_NUM_SW_GFX_RINGS; i++)\n\t\t\t\tamdgpu_fence_process(&adev->gfx.sw_gfx_ring[i]);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\t \n\t\t\tif ((ring->me == me_id) && (ring->pipe == pipe_id) && (ring->queue == queue_id))\n\t\t\t\tamdgpu_fence_process(ring);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void gfx_v9_0_fault(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tu8 me_id, pipe_id, queue_id;\n\tstruct amdgpu_ring *ring;\n\tint i;\n\n\tme_id = (entry->ring_id & 0x0c) >> 2;\n\tpipe_id = (entry->ring_id & 0x03) >> 0;\n\tqueue_id = (entry->ring_id & 0x70) >> 4;\n\n\tswitch (me_id) {\n\tcase 0:\n\t\tdrm_sched_fault(&adev->gfx.gfx_ring[0].sched);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tfor (i = 0; i < adev->gfx.num_compute_rings; i++) {\n\t\t\tring = &adev->gfx.compute_ring[i];\n\t\t\tif (ring->me == me_id && ring->pipe == pipe_id &&\n\t\t\t    ring->queue == queue_id)\n\t\t\t\tdrm_sched_fault(&ring->sched);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int gfx_v9_0_priv_reg_irq(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal register access in command stream\\n\");\n\tgfx_v9_0_fault(adev, entry);\n\treturn 0;\n}\n\nstatic int gfx_v9_0_priv_inst_irq(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_irq_src *source,\n\t\t\t\t  struct amdgpu_iv_entry *entry)\n{\n\tDRM_ERROR(\"Illegal instruction in command stream\\n\");\n\tgfx_v9_0_fault(adev, entry);\n\treturn 0;\n}\n\n\nstatic const struct soc15_ras_field_entry gfx_v9_0_ras_fields[] = {\n\t{ \"CPC_SCRATCH\", SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_SCRATCH_CNT),\n\t  SOC15_REG_FIELD(CPC_EDC_SCRATCH_CNT, SEC_COUNT),\n\t  SOC15_REG_FIELD(CPC_EDC_SCRATCH_CNT, DED_COUNT)\n\t},\n\t{ \"CPC_UCODE\", SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_UCODE_CNT),\n\t  SOC15_REG_FIELD(CPC_EDC_UCODE_CNT, SEC_COUNT),\n\t  SOC15_REG_FIELD(CPC_EDC_UCODE_CNT, DED_COUNT)\n\t},\n\t{ \"CPF_ROQ_ME1\", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT),\n\t  SOC15_REG_FIELD(CPF_EDC_ROQ_CNT, COUNT_ME1),\n\t  0, 0\n\t},\n\t{ \"CPF_ROQ_ME2\", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT),\n\t  SOC15_REG_FIELD(CPF_EDC_ROQ_CNT, COUNT_ME2),\n\t  0, 0\n\t},\n\t{ \"CPF_TAG\", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_TAG_CNT),\n\t  SOC15_REG_FIELD(CPF_EDC_TAG_CNT, SEC_COUNT),\n\t  SOC15_REG_FIELD(CPF_EDC_TAG_CNT, DED_COUNT)\n\t},\n\t{ \"CPG_DMA_ROQ\", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT),\n\t  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, ROQ_COUNT),\n\t  0, 0\n\t},\n\t{ \"CPG_DMA_TAG\", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT),\n\t  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, TAG_SEC_COUNT),\n\t  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, TAG_DED_COUNT)\n\t},\n\t{ \"CPG_TAG\", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_TAG_CNT),\n\t  SOC15_REG_FIELD(CPG_EDC_TAG_CNT, SEC_COUNT),\n\t  SOC15_REG_FIELD(CPG_EDC_TAG_CNT, DED_COUNT)\n\t},\n\t{ \"DC_CSINVOC\", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_CSINVOC_CNT),\n\t  SOC15_REG_FIELD(DC_EDC_CSINVOC_CNT, COUNT_ME1),\n\t  0, 0\n\t},\n\t{ \"DC_RESTORE\", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_RESTORE_CNT),\n\t  SOC15_REG_FIELD(DC_EDC_RESTORE_CNT, COUNT_ME1),\n\t  0, 0\n\t},\n\t{ \"DC_STATE\", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_STATE_CNT),\n\t  SOC15_REG_FIELD(DC_EDC_STATE_CNT, COUNT_ME1),\n\t  0, 0\n\t},\n\t{ \"GDS_MEM\", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_MEM_DED)\n\t},\n\t{ \"GDS_INPUT_QUEUE\", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_INPUT_QUEUE_SED),\n\t  0, 0\n\t},\n\t{ \"GDS_ME0_CS_PIPE_MEM\", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, ME0_CS_PIPE_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, ME0_CS_PIPE_MEM_DED)\n\t},\n\t{ \"GDS_OA_PHY_PHY_CMD_RAM_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_CMD_RAM_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_CMD_RAM_MEM_DED)\n\t},\n\t{ \"GDS_OA_PHY_PHY_DATA_RAM_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_DATA_RAM_MEM_SED),\n\t  0, 0\n\t},\n\t{ \"GDS_OA_PIPE_ME1_PIPE0_PIPE_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE0_PIPE_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE0_PIPE_MEM_DED)\n\t},\n\t{ \"GDS_OA_PIPE_ME1_PIPE1_PIPE_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE1_PIPE_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE1_PIPE_MEM_DED)\n\t},\n\t{ \"GDS_OA_PIPE_ME1_PIPE2_PIPE_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE2_PIPE_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE2_PIPE_MEM_DED)\n\t},\n\t{ \"GDS_OA_PIPE_ME1_PIPE3_PIPE_MEM\",\n\t  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE3_PIPE_MEM_SEC),\n\t  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE3_PIPE_MEM_DED)\n\t},\n\t{ \"SPI_SR_MEM\", SOC15_REG_ENTRY(GC, 0, mmSPI_EDC_CNT),\n\t  SOC15_REG_FIELD(SPI_EDC_CNT, SPI_SR_MEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TA_FS_DFIFO\", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_DFIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_DFIFO_DED_COUNT)\n\t},\n\t{ \"TA_FS_AFIFO\", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_AFIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TA_FL_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FL_LFIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TA_FX_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FX_LFIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TA_FS_CFIFO\", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),\n\t  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_CFIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCA_HOLE_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT),\n\t  SOC15_REG_FIELD(TCA_EDC_CNT, HOLE_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCA_REQ_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT),\n\t  SOC15_REG_FIELD(TCA_EDC_CNT, REQ_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_CACHE_DATA\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DATA_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DATA_DED_COUNT)\n\t},\n\t{ \"TCC_CACHE_DIRTY\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DIRTY_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DIRTY_DED_COUNT)\n\t},\n\t{ \"TCC_HIGH_RATE_TAG\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, HIGH_RATE_TAG_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, HIGH_RATE_TAG_DED_COUNT)\n\t},\n\t{ \"TCC_LOW_RATE_TAG\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, LOW_RATE_TAG_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, LOW_RATE_TAG_DED_COUNT)\n\t},\n\t{ \"TCC_SRC_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, SRC_FIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, SRC_FIFO_DED_COUNT)\n\t},\n\t{ \"TCC_IN_USE_DEC\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, IN_USE_DEC_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_IN_USE_TRANSFER\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, IN_USE_TRANSFER_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_LATENCY_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, LATENCY_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_RETURN_DATA\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, RETURN_DATA_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_RETURN_CONTROL\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, RETURN_CONTROL_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_UC_ATOMIC_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT, UC_ATOMIC_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_WRITE_RETURN\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, WRITE_RETURN_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_WRITE_CACHE_READ\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, WRITE_CACHE_READ_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_SRC_FIFO_NEXT_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, SRC_FIFO_NEXT_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_LATENCY_FIFO_NEXT_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, LATENCY_FIFO_NEXT_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_CACHE_TAG_PROBE_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, CACHE_TAG_PROBE_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_WRRET_TAG_WRITE_RETURN\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, WRRET_TAG_WRITE_RETURN_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCC_ATOMIC_RETURN_BUFFER\", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),\n\t  SOC15_REG_FIELD(TCC_EDC_CNT2, ATOMIC_RETURN_BUFFER_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCI_WRITE_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCI_EDC_CNT),\n\t  SOC15_REG_FIELD(TCI_EDC_CNT, WRITE_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCP_CACHE_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CACHE_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CACHE_RAM_DED_COUNT)\n\t},\n\t{ \"TCP_LFIFO_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, LFIFO_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, LFIFO_RAM_DED_COUNT)\n\t},\n\t{ \"TCP_CMD_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CMD_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCP_VM_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, VM_FIFO_SEC_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCP_DB_RAM\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, DB_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"TCP_UTCL1_LFIFO0\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO0_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO0_DED_COUNT)\n\t},\n\t{ \"TCP_UTCL1_LFIFO1\", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO1_SEC_COUNT),\n\t  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO1_DED_COUNT)\n\t},\n\t{ \"TD_SS_FIFO_LO\", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),\n\t  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_LO_SEC_COUNT),\n\t  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_LO_DED_COUNT)\n\t},\n\t{ \"TD_SS_FIFO_HI\", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),\n\t  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_HI_SEC_COUNT),\n\t  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_HI_DED_COUNT)\n\t},\n\t{ \"TD_CS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),\n\t  SOC15_REG_FIELD(TD_EDC_CNT, CS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQ_LDS_D\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_D_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_D_DED_COUNT)\n\t},\n\t{ \"SQ_LDS_I\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_I_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_I_DED_COUNT)\n\t},\n\t{ \"SQ_SGPR\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, SGPR_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, SGPR_DED_COUNT)\n\t},\n\t{ \"SQ_VGPR0\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR0_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR0_DED_COUNT)\n\t},\n\t{ \"SQ_VGPR1\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR1_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR1_DED_COUNT)\n\t},\n\t{ \"SQ_VGPR2\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR2_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR2_DED_COUNT)\n\t},\n\t{ \"SQ_VGPR3\", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR3_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR3_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU0_WRITE_DATA_BUF\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_WRITE_DATA_BUF_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_WRITE_DATA_BUF_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU0_UTCL1_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_UTCL1_LFIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_UTCL1_LFIFO_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU1_WRITE_DATA_BUF\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_WRITE_DATA_BUF_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_WRITE_DATA_BUF_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU1_UTCL1_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_UTCL1_LFIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_UTCL1_LFIFO_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU2_WRITE_DATA_BUF\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_WRITE_DATA_BUF_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_WRITE_DATA_BUF_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_CU2_UTCL1_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_UTCL1_LFIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_UTCL1_LFIFO_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKA_TAG_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_TAG_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_TAG_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKA_BANK_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_BANK_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_BANK_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_BANKA_TAG_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_TAG_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_TAG_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_BANKA_BANK_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_BANK_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_BANK_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKA_UTCL1_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_UTCL1_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_INST_BANKA_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKA_HIT_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_HIT_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKA_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKA_DIRTY_BIT_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_DIRTY_BIT_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_INST_UTCL1_LFIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_UTCL1_LFIFO_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_UTCL1_LFIFO_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKB_TAG_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_TAG_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_TAG_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKB_BANK_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_BANK_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_BANK_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_BANKB_TAG_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_TAG_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_TAG_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_DATA_BANKB_BANK_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_BANK_RAM_SEC_COUNT),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_BANK_RAM_DED_COUNT)\n\t},\n\t{ \"SQC_INST_BANKB_UTCL1_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_UTCL1_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_INST_BANKB_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKB_HIT_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_HIT_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKB_MISS_FIFO\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_MISS_FIFO_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"SQC_DATA_BANKB_DIRTY_BIT_RAM\", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),\n\t  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_DIRTY_BIT_RAM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"EA_DRAMRD_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_CMDMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_CMDMEM_DED_COUNT)\n\t},\n\t{ \"EA_DRAMWR_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_CMDMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_CMDMEM_DED_COUNT)\n\t},\n\t{ \"EA_DRAMWR_DATAMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_DATAMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_DATAMEM_DED_COUNT)\n\t},\n\t{ \"EA_RRET_TAGMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, RRET_TAGMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, RRET_TAGMEM_DED_COUNT)\n\t},\n\t{ \"EA_WRET_TAGMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, WRET_TAGMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, WRET_TAGMEM_DED_COUNT)\n\t},\n\t{ \"EA_DRAMRD_PAGEMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_PAGEMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"EA_DRAMWR_PAGEMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_PAGEMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"EA_IORD_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, IORD_CMDMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"EA_IOWR_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, IOWR_CMDMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"EA_IOWR_DATAMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT, IOWR_DATAMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"GMIRD_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_CMDMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_CMDMEM_DED_COUNT)\n\t},\n\t{ \"GMIWR_CMDMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_CMDMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_CMDMEM_DED_COUNT)\n\t},\n\t{ \"GMIWR_DATAMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_DATAMEM_SEC_COUNT),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_DATAMEM_DED_COUNT)\n\t},\n\t{ \"GMIRD_PAGEMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_PAGEMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"GMIWR_PAGEMEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_PAGEMEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"MAM_D0MEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D0MEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"MAM_D1MEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D1MEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"MAM_D2MEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D2MEM_SED_COUNT),\n\t  0, 0\n\t},\n\t{ \"MAM_D3MEM\", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),\n\t  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D3MEM_SED_COUNT),\n\t  0, 0\n\t}\n};\n\nstatic int gfx_v9_0_ras_error_inject(struct amdgpu_device *adev,\n\t\t\t\t     void *inject_if, uint32_t instance_mask)\n{\n\tstruct ras_inject_if *info = (struct ras_inject_if *)inject_if;\n\tint ret;\n\tstruct ta_ras_trigger_error_input block_info = { 0 };\n\n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\treturn -EINVAL;\n\n\tif (info->head.sub_block_index >= ARRAY_SIZE(ras_gfx_subblocks))\n\t\treturn -EINVAL;\n\n\tif (!ras_gfx_subblocks[info->head.sub_block_index].name)\n\t\treturn -EPERM;\n\n\tif (!(ras_gfx_subblocks[info->head.sub_block_index].hw_supported_error_type &\n\t      info->head.type)) {\n\t\tDRM_ERROR(\"GFX Subblock %s, hardware do not support type 0x%x\\n\",\n\t\t\tras_gfx_subblocks[info->head.sub_block_index].name,\n\t\t\tinfo->head.type);\n\t\treturn -EPERM;\n\t}\n\n\tif (!(ras_gfx_subblocks[info->head.sub_block_index].sw_supported_error_type &\n\t      info->head.type)) {\n\t\tDRM_ERROR(\"GFX Subblock %s, driver do not support type 0x%x\\n\",\n\t\t\tras_gfx_subblocks[info->head.sub_block_index].name,\n\t\t\tinfo->head.type);\n\t\treturn -EPERM;\n\t}\n\n\tblock_info.block_id = amdgpu_ras_block_to_ta(info->head.block);\n\tblock_info.sub_block_index =\n\t\tras_gfx_subblocks[info->head.sub_block_index].ta_subblock;\n\tblock_info.inject_error_type = amdgpu_ras_error_to_ta(info->head.type);\n\tblock_info.address = info->address;\n\tblock_info.value = info->value;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tret = psp_ras_trigger_error(&adev->psp, &block_info, instance_mask);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\treturn ret;\n}\n\nstatic const char *vml2_mems[] = {\n\t\"UTC_VML2_BANK_CACHE_0_BIGK_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_0_BIGK_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_0_4K_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_0_4K_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_1_BIGK_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_1_BIGK_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_1_4K_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_1_4K_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_2_BIGK_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_2_BIGK_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_2_4K_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_2_4K_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_3_BIGK_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_3_BIGK_MEM1\",\n\t\"UTC_VML2_BANK_CACHE_3_4K_MEM0\",\n\t\"UTC_VML2_BANK_CACHE_3_4K_MEM1\",\n};\n\nstatic const char *vml2_walker_mems[] = {\n\t\"UTC_VML2_CACHE_PDE0_MEM0\",\n\t\"UTC_VML2_CACHE_PDE0_MEM1\",\n\t\"UTC_VML2_CACHE_PDE1_MEM0\",\n\t\"UTC_VML2_CACHE_PDE1_MEM1\",\n\t\"UTC_VML2_CACHE_PDE2_MEM0\",\n\t\"UTC_VML2_CACHE_PDE2_MEM1\",\n\t\"UTC_VML2_RDIF_LOG_FIFO\",\n};\n\nstatic const char *atc_l2_cache_2m_mems[] = {\n\t\"UTC_ATCL2_CACHE_2M_BANK0_WAY0_MEM\",\n\t\"UTC_ATCL2_CACHE_2M_BANK0_WAY1_MEM\",\n\t\"UTC_ATCL2_CACHE_2M_BANK1_WAY0_MEM\",\n\t\"UTC_ATCL2_CACHE_2M_BANK1_WAY1_MEM\",\n};\n\nstatic const char *atc_l2_cache_4k_mems[] = {\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM0\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM1\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM2\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM3\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM4\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM5\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM6\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM7\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM0\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM1\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM2\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM3\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM4\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM5\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM6\",\n\t\"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM7\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM0\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM1\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM2\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM3\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM4\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM5\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM6\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM7\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM0\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM1\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM2\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM3\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM4\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM5\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM6\",\n\t\"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM7\",\n};\n\nstatic int gfx_v9_0_query_utc_edc_status(struct amdgpu_device *adev,\n\t\t\t\t\t struct ras_err_data *err_data)\n{\n\tuint32_t i, data;\n\tuint32_t sec_count, ded_count;\n\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(vml2_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, i);\n\t\tdata = RREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT);\n\n\t\tsec_count = REG_GET_FIELD(data, VM_L2_MEM_ECC_CNT, SEC_COUNT);\n\t\tif (sec_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"SEC %d\\n\", i, vml2_mems[i], sec_count);\n\t\t\terr_data->ce_count += sec_count;\n\t\t}\n\n\t\tded_count = REG_GET_FIELD(data, VM_L2_MEM_ECC_CNT, DED_COUNT);\n\t\tif (ded_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"DED %d\\n\", i, vml2_mems[i], ded_count);\n\t\t\terr_data->ue_count += ded_count;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vml2_walker_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, i);\n\t\tdata = RREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT);\n\n\t\tsec_count = REG_GET_FIELD(data, VM_L2_WALKER_MEM_ECC_CNT,\n\t\t\t\t\t\tSEC_COUNT);\n\t\tif (sec_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"SEC %d\\n\", i, vml2_walker_mems[i], sec_count);\n\t\t\terr_data->ce_count += sec_count;\n\t\t}\n\n\t\tded_count = REG_GET_FIELD(data, VM_L2_WALKER_MEM_ECC_CNT,\n\t\t\t\t\t\tDED_COUNT);\n\t\tif (ded_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"DED %d\\n\", i, vml2_walker_mems[i], ded_count);\n\t\t\terr_data->ue_count += ded_count;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(atc_l2_cache_2m_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, i);\n\t\tdata = RREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT);\n\n\t\tsec_count = (data & 0x00006000L) >> 0xd;\n\t\tif (sec_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"SEC %d\\n\", i, atc_l2_cache_2m_mems[i],\n\t\t\t\tsec_count);\n\t\t\terr_data->ce_count += sec_count;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(atc_l2_cache_4k_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, i);\n\t\tdata = RREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT);\n\n\t\tsec_count = (data & 0x00006000L) >> 0xd;\n\t\tif (sec_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"SEC %d\\n\", i, atc_l2_cache_4k_mems[i],\n\t\t\t\tsec_count);\n\t\t\terr_data->ce_count += sec_count;\n\t\t}\n\n\t\tded_count = (data & 0x00018000L) >> 0xf;\n\t\tif (ded_count) {\n\t\t\tdev_info(adev->dev, \"Instance[%d]: SubBlock %s, \"\n\t\t\t\t\"DED %d\\n\", i, atc_l2_cache_4k_mems[i],\n\t\t\t\tded_count);\n\t\t\terr_data->ue_count += ded_count;\n\t\t}\n\t}\n\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);\n\n\treturn 0;\n}\n\nstatic int gfx_v9_0_ras_error_count(struct amdgpu_device *adev,\n\tconst struct soc15_reg_entry *reg,\n\tuint32_t se_id, uint32_t inst_id, uint32_t value,\n\tuint32_t *sec_count, uint32_t *ded_count)\n{\n\tuint32_t i;\n\tuint32_t sec_cnt, ded_cnt;\n\n\tfor (i = 0; i < ARRAY_SIZE(gfx_v9_0_ras_fields); i++) {\n\t\tif(gfx_v9_0_ras_fields[i].reg_offset != reg->reg_offset ||\n\t\t\tgfx_v9_0_ras_fields[i].seg != reg->seg ||\n\t\t\tgfx_v9_0_ras_fields[i].inst != reg->inst)\n\t\t\tcontinue;\n\n\t\tsec_cnt = (value &\n\t\t\t\tgfx_v9_0_ras_fields[i].sec_count_mask) >>\n\t\t\t\tgfx_v9_0_ras_fields[i].sec_count_shift;\n\t\tif (sec_cnt) {\n\t\t\tdev_info(adev->dev, \"GFX SubBlock %s, \"\n\t\t\t\t\"Instance[%d][%d], SEC %d\\n\",\n\t\t\t\tgfx_v9_0_ras_fields[i].name,\n\t\t\t\tse_id, inst_id,\n\t\t\t\tsec_cnt);\n\t\t\t*sec_count += sec_cnt;\n\t\t}\n\n\t\tded_cnt = (value &\n\t\t\t\tgfx_v9_0_ras_fields[i].ded_count_mask) >>\n\t\t\t\tgfx_v9_0_ras_fields[i].ded_count_shift;\n\t\tif (ded_cnt) {\n\t\t\tdev_info(adev->dev, \"GFX SubBlock %s, \"\n\t\t\t\t\"Instance[%d][%d], DED %d\\n\",\n\t\t\t\tgfx_v9_0_ras_fields[i].name,\n\t\t\t\tse_id, inst_id,\n\t\t\t\tded_cnt);\n\t\t\t*ded_count += ded_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void gfx_v9_0_reset_ras_error_count(struct amdgpu_device *adev)\n{\n\tint i, j, k;\n\n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\treturn;\n\n\t \n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < ARRAY_SIZE(gfx_v9_0_edc_counter_regs); i++) {\n\t\tfor (j = 0; j < gfx_v9_0_edc_counter_regs[i].se_num; j++) {\n\t\t\tfor (k = 0; k < gfx_v9_0_edc_counter_regs[i].instance; k++) {\n\t\t\t\tamdgpu_gfx_select_se_sh(adev, j, 0x0, k, 0);\n\t\t\t\tRREG32(SOC15_REG_ENTRY_OFFSET(gfx_v9_0_edc_counter_regs[i]));\n\t\t\t}\n\t\t}\n\t}\n\tWREG32_SOC15(GC, 0, mmGRBM_GFX_INDEX, 0xe0000000);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT, 0);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(vml2_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, i);\n\t\tRREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vml2_walker_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, i);\n\t\tRREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(atc_l2_cache_2m_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, i);\n\t\tRREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(atc_l2_cache_4k_mems); i++) {\n\t\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, i);\n\t\tRREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT);\n\t}\n\n\tWREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);\n\tWREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);\n}\n\nstatic void gfx_v9_0_query_ras_error_count(struct amdgpu_device *adev,\n\t\t\t\t\t  void *ras_error_status)\n{\n\tstruct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;\n\tuint32_t sec_count = 0, ded_count = 0;\n\tuint32_t i, j, k;\n\tuint32_t reg_value;\n\n\tif (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))\n\t\treturn;\n\n\terr_data->ue_count = 0;\n\terr_data->ce_count = 0;\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(gfx_v9_0_edc_counter_regs); i++) {\n\t\tfor (j = 0; j < gfx_v9_0_edc_counter_regs[i].se_num; j++) {\n\t\t\tfor (k = 0; k < gfx_v9_0_edc_counter_regs[i].instance; k++) {\n\t\t\t\tamdgpu_gfx_select_se_sh(adev, j, 0, k, 0);\n\t\t\t\treg_value =\n\t\t\t\t\tRREG32(SOC15_REG_ENTRY_OFFSET(gfx_v9_0_edc_counter_regs[i]));\n\t\t\t\tif (reg_value)\n\t\t\t\t\tgfx_v9_0_ras_error_count(adev,\n\t\t\t\t\t\t&gfx_v9_0_edc_counter_regs[i],\n\t\t\t\t\t\tj, k, reg_value,\n\t\t\t\t\t\t&sec_count, &ded_count);\n\t\t\t}\n\t\t}\n\t}\n\n\terr_data->ce_count += sec_count;\n\terr_data->ue_count += ded_count;\n\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tgfx_v9_0_query_utc_edc_status(adev, err_data);\n}\n\nstatic void gfx_v9_0_emit_mem_sync(struct amdgpu_ring *ring)\n{\n\tconst unsigned int cp_coher_cntl =\n\t\t\tPACKET3_ACQUIRE_MEM_CP_COHER_CNTL_SH_ICACHE_ACTION_ENA(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_CP_COHER_CNTL_SH_KCACHE_ACTION_ENA(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TC_ACTION_ENA(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TCL1_ACTION_ENA(1) |\n\t\t\tPACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TC_WB_ACTION_ENA(1);\n\n\t \n\tamdgpu_ring_write(ring, PACKET3(PACKET3_ACQUIRE_MEM, 5));\n\tamdgpu_ring_write(ring, cp_coher_cntl);  \n\tamdgpu_ring_write(ring, 0xffffffff);   \n\tamdgpu_ring_write(ring, 0xffffff);   \n\tamdgpu_ring_write(ring, 0);  \n\tamdgpu_ring_write(ring, 0);   \n\tamdgpu_ring_write(ring, 0x0000000A);  \n}\n\nstatic void gfx_v9_0_emit_wave_limit_cs(struct amdgpu_ring *ring,\n\t\t\t\t\tuint32_t pipe, bool enable)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t val;\n\tuint32_t wcl_cs_reg;\n\n\t \n\tval = enable ? 0x1 : mmSPI_WCL_PIPE_PERCENT_CS0_DEFAULT;\n\n\tswitch (pipe) {\n\tcase 0:\n\t\twcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS0);\n\t\tbreak;\n\tcase 1:\n\t\twcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS1);\n\t\tbreak;\n\tcase 2:\n\t\twcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS2);\n\t\tbreak;\n\tcase 3:\n\t\twcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS3);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"invalid pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tamdgpu_ring_emit_wreg(ring, wcl_cs_reg, val);\n\n}\nstatic void gfx_v9_0_emit_wave_limit(struct amdgpu_ring *ring, bool enable)\n{\n\tstruct amdgpu_device *adev = ring->adev;\n\tuint32_t val;\n\tint i;\n\n\n\t \n\tval = enable ? 0x1f : mmSPI_WCL_PIPE_PERCENT_GFX_DEFAULT;\n\tamdgpu_ring_emit_wreg(ring,\n\t\t\t      SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_GFX),\n\t\t\t      val);\n\n\t \n\tfor (i = 0; i < adev->gfx.mec.num_pipe_per_mec; i++) {\n\t\tif (i != ring->pipe)\n\t\t\tgfx_v9_0_emit_wave_limit_cs(ring, i, enable);\n\n\t}\n}\n\nstatic const struct amd_ip_funcs gfx_v9_0_ip_funcs = {\n\t.name = \"gfx_v9_0\",\n\t.early_init = gfx_v9_0_early_init,\n\t.late_init = gfx_v9_0_late_init,\n\t.sw_init = gfx_v9_0_sw_init,\n\t.sw_fini = gfx_v9_0_sw_fini,\n\t.hw_init = gfx_v9_0_hw_init,\n\t.hw_fini = gfx_v9_0_hw_fini,\n\t.suspend = gfx_v9_0_suspend,\n\t.resume = gfx_v9_0_resume,\n\t.is_idle = gfx_v9_0_is_idle,\n\t.wait_for_idle = gfx_v9_0_wait_for_idle,\n\t.soft_reset = gfx_v9_0_soft_reset,\n\t.set_clockgating_state = gfx_v9_0_set_clockgating_state,\n\t.set_powergating_state = gfx_v9_0_set_powergating_state,\n\t.get_clockgating_state = gfx_v9_0_get_clockgating_state,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v9_0_ring_funcs_gfx = {\n\t.type = AMDGPU_RING_TYPE_GFX,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.secure_submission_supported = true,\n\t.get_rptr = gfx_v9_0_ring_get_rptr_gfx,\n\t.get_wptr = gfx_v9_0_ring_get_wptr_gfx,\n\t.set_wptr = gfx_v9_0_ring_set_wptr_gfx,\n\t.emit_frame_size =  \n\t\t5 +   \n\t\t7 +   \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 +   \n\t\t20 +  \n\t\t4 +  \n\t\t5 +  \n\t\t7 +\t  \n\t\t4 +\t  \n\t\t14 +  \n\t\t31 +  \n\t\t3 +  \n\t\t5 +  \n\t\t8 + 8 +  \n\t\t2 +  \n\t\t7,  \n\t.emit_ib_size =\t4,  \n\t.emit_ib = gfx_v9_0_ring_emit_ib_gfx,\n\t.emit_fence = gfx_v9_0_ring_emit_fence,\n\t.emit_pipeline_sync = gfx_v9_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v9_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v9_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v9_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v9_0_ring_test_ring,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_switch_buffer = gfx_v9_ring_emit_sb,\n\t.emit_cntxcntl = gfx_v9_ring_emit_cntxcntl,\n\t.init_cond_exec = gfx_v9_0_ring_emit_init_cond_exec,\n\t.patch_cond_exec = gfx_v9_0_ring_emit_patch_cond_exec,\n\t.preempt_ib = gfx_v9_0_ring_preempt_ib,\n\t.emit_frame_cntl = gfx_v9_0_ring_emit_frame_cntl,\n\t.emit_wreg = gfx_v9_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v9_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v9_0_ring_emit_reg_write_reg_wait,\n\t.soft_recovery = gfx_v9_0_ring_soft_recovery,\n\t.emit_mem_sync = gfx_v9_0_emit_mem_sync,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v9_0_sw_ring_funcs_gfx = {\n\t.type = AMDGPU_RING_TYPE_GFX,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.secure_submission_supported = true,\n\t.get_rptr = amdgpu_sw_ring_get_rptr_gfx,\n\t.get_wptr = amdgpu_sw_ring_get_wptr_gfx,\n\t.set_wptr = amdgpu_sw_ring_set_wptr_gfx,\n\t.emit_frame_size =  \n\t\t5 +   \n\t\t7 +   \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 +   \n\t\t20 +  \n\t\t4 +  \n\t\t5 +  \n\t\t7 +\t  \n\t\t4 +\t  \n\t\t14 +  \n\t\t31 +  \n\t\t3 +  \n\t\t5 +  \n\t\t8 + 8 +  \n\t\t2 +  \n\t\t7,  \n\t.emit_ib_size =\t4,  \n\t.emit_ib = gfx_v9_0_ring_emit_ib_gfx,\n\t.emit_fence = gfx_v9_0_ring_emit_fence,\n\t.emit_pipeline_sync = gfx_v9_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v9_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v9_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v9_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v9_0_ring_test_ring,\n\t.test_ib = gfx_v9_0_ring_test_ib,\n\t.insert_nop = amdgpu_sw_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_switch_buffer = gfx_v9_ring_emit_sb,\n\t.emit_cntxcntl = gfx_v9_ring_emit_cntxcntl,\n\t.init_cond_exec = gfx_v9_0_ring_emit_init_cond_exec,\n\t.patch_cond_exec = gfx_v9_0_ring_emit_patch_cond_exec,\n\t.emit_frame_cntl = gfx_v9_0_ring_emit_frame_cntl,\n\t.emit_wreg = gfx_v9_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v9_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v9_0_ring_emit_reg_write_reg_wait,\n\t.soft_recovery = gfx_v9_0_ring_soft_recovery,\n\t.emit_mem_sync = gfx_v9_0_emit_mem_sync,\n\t.patch_cntl = gfx_v9_0_ring_patch_cntl,\n\t.patch_de = gfx_v9_0_ring_patch_de_meta,\n\t.patch_ce = gfx_v9_0_ring_patch_ce_meta,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v9_0_ring_funcs_compute = {\n\t.type = AMDGPU_RING_TYPE_COMPUTE,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.get_rptr = gfx_v9_0_ring_get_rptr_compute,\n\t.get_wptr = gfx_v9_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v9_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 + 8 + 8 +  \n\t\t7 +  \n\t\t5 +  \n\t\t15,  \n\t.emit_ib_size =\t7,  \n\t.emit_ib = gfx_v9_0_ring_emit_ib_compute,\n\t.emit_fence = gfx_v9_0_ring_emit_fence,\n\t.emit_pipeline_sync = gfx_v9_0_ring_emit_pipeline_sync,\n\t.emit_vm_flush = gfx_v9_0_ring_emit_vm_flush,\n\t.emit_gds_switch = gfx_v9_0_ring_emit_gds_switch,\n\t.emit_hdp_flush = gfx_v9_0_ring_emit_hdp_flush,\n\t.test_ring = gfx_v9_0_ring_test_ring,\n\t.test_ib = gfx_v9_0_ring_test_ib,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_wreg = gfx_v9_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v9_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v9_0_ring_emit_reg_write_reg_wait,\n\t.emit_mem_sync = gfx_v9_0_emit_mem_sync,\n\t.emit_wave_limit = gfx_v9_0_emit_wave_limit,\n};\n\nstatic const struct amdgpu_ring_funcs gfx_v9_0_ring_funcs_kiq = {\n\t.type = AMDGPU_RING_TYPE_KIQ,\n\t.align_mask = 0xff,\n\t.nop = PACKET3(PACKET3_NOP, 0x3FFF),\n\t.support_64bit_ptrs = true,\n\t.get_rptr = gfx_v9_0_ring_get_rptr_compute,\n\t.get_wptr = gfx_v9_0_ring_get_wptr_compute,\n\t.set_wptr = gfx_v9_0_ring_set_wptr_compute,\n\t.emit_frame_size =\n\t\t20 +  \n\t\t7 +  \n\t\t5 +  \n\t\t7 +  \n\t\tSOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +\n\t\tSOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +\n\t\t2 +  \n\t\t8 + 8 + 8,  \n\t.emit_ib_size =\t7,  \n\t.emit_fence = gfx_v9_0_ring_emit_fence_kiq,\n\t.test_ring = gfx_v9_0_ring_test_ring,\n\t.insert_nop = amdgpu_ring_insert_nop,\n\t.pad_ib = amdgpu_ring_generic_pad_ib,\n\t.emit_rreg = gfx_v9_0_ring_emit_rreg,\n\t.emit_wreg = gfx_v9_0_ring_emit_wreg,\n\t.emit_reg_wait = gfx_v9_0_ring_emit_reg_wait,\n\t.emit_reg_write_reg_wait = gfx_v9_0_ring_emit_reg_write_reg_wait,\n};\n\nstatic void gfx_v9_0_set_ring_funcs(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tadev->gfx.kiq[0].ring.funcs = &gfx_v9_0_ring_funcs_kiq;\n\n\tfor (i = 0; i < adev->gfx.num_gfx_rings; i++)\n\t\tadev->gfx.gfx_ring[i].funcs = &gfx_v9_0_ring_funcs_gfx;\n\n\tif (adev->gfx.num_gfx_rings) {\n\t\tfor (i = 0; i < GFX9_NUM_SW_GFX_RINGS; i++)\n\t\t\tadev->gfx.sw_gfx_ring[i].funcs = &gfx_v9_0_sw_ring_funcs_gfx;\n\t}\n\n\tfor (i = 0; i < adev->gfx.num_compute_rings; i++)\n\t\tadev->gfx.compute_ring[i].funcs = &gfx_v9_0_ring_funcs_compute;\n}\n\nstatic const struct amdgpu_irq_src_funcs gfx_v9_0_eop_irq_funcs = {\n\t.set = gfx_v9_0_set_eop_interrupt_state,\n\t.process = gfx_v9_0_eop_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v9_0_priv_reg_irq_funcs = {\n\t.set = gfx_v9_0_set_priv_reg_fault_state,\n\t.process = gfx_v9_0_priv_reg_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v9_0_priv_inst_irq_funcs = {\n\t.set = gfx_v9_0_set_priv_inst_fault_state,\n\t.process = gfx_v9_0_priv_inst_irq,\n};\n\nstatic const struct amdgpu_irq_src_funcs gfx_v9_0_cp_ecc_error_irq_funcs = {\n\t.set = gfx_v9_0_set_cp_ecc_error_state,\n\t.process = amdgpu_gfx_cp_ecc_error_irq,\n};\n\n\nstatic void gfx_v9_0_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->gfx.eop_irq.num_types = AMDGPU_CP_IRQ_LAST;\n\tadev->gfx.eop_irq.funcs = &gfx_v9_0_eop_irq_funcs;\n\n\tadev->gfx.priv_reg_irq.num_types = 1;\n\tadev->gfx.priv_reg_irq.funcs = &gfx_v9_0_priv_reg_irq_funcs;\n\n\tadev->gfx.priv_inst_irq.num_types = 1;\n\tadev->gfx.priv_inst_irq.funcs = &gfx_v9_0_priv_inst_irq_funcs;\n\n\tadev->gfx.cp_ecc_error_irq.num_types = 2;  \n\tadev->gfx.cp_ecc_error_irq.funcs = &gfx_v9_0_cp_ecc_error_irq_funcs;\n}\n\nstatic void gfx_v9_0_set_rlc_funcs(struct amdgpu_device *adev)\n{\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 4, 1):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 2):\n\t\tadev->gfx.rlc.funcs = &gfx_v9_0_rlc_funcs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gfx_v9_0_set_gds_init(struct amdgpu_device *adev)\n{\n\t \n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 4, 0):\n\t\tadev->gds.gds_size = 0x10000;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 4, 1):\n\t\tadev->gds.gds_size = 0x1000;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 2):\n\t\t \n\t\tadev->gds.gds_size = 0;\n\t\tbreak;\n\tdefault:\n\t\tadev->gds.gds_size = 0x10000;\n\t\tbreak;\n\t}\n\n\tswitch (adev->ip_versions[GC_HWIP][0]) {\n\tcase IP_VERSION(9, 0, 1):\n\tcase IP_VERSION(9, 4, 0):\n\t\tadev->gds.gds_compute_max_wave_id = 0x7ff;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 1):\n\t\tadev->gds.gds_compute_max_wave_id = 0x27f;\n\t\tbreak;\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 1, 0):\n\t\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t\tadev->gds.gds_compute_max_wave_id = 0x77;  \n\t\telse\n\t\t\tadev->gds.gds_compute_max_wave_id = 0x15f;  \n\t\tbreak;\n\tcase IP_VERSION(9, 4, 1):\n\t\tadev->gds.gds_compute_max_wave_id = 0xfff;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 2):\n\t\t \n\t\tadev->gds.gds_compute_max_wave_id = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tadev->gds.gds_compute_max_wave_id = 0x7ff;\n\t\tbreak;\n\t}\n\n\tadev->gds.gws_size = 64;\n\tadev->gds.oa_size = 16;\n}\n\nstatic void gfx_v9_0_set_user_cu_inactive_bitmap(struct amdgpu_device *adev,\n\t\t\t\t\t\t u32 bitmap)\n{\n\tu32 data;\n\n\tif (!bitmap)\n\t\treturn;\n\n\tdata = bitmap << GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;\n\tdata &= GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;\n\n\tWREG32_SOC15(GC, 0, mmGC_USER_SHADER_ARRAY_CONFIG, data);\n}\n\nstatic u32 gfx_v9_0_get_cu_active_bitmap(struct amdgpu_device *adev)\n{\n\tu32 data, mask;\n\n\tdata = RREG32_SOC15(GC, 0, mmCC_GC_SHADER_ARRAY_CONFIG);\n\tdata |= RREG32_SOC15(GC, 0, mmGC_USER_SHADER_ARRAY_CONFIG);\n\n\tdata &= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;\n\tdata >>= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;\n\n\tmask = amdgpu_gfx_create_bitmask(adev->gfx.config.max_cu_per_sh);\n\n\treturn (~data) & mask;\n}\n\nstatic int gfx_v9_0_get_cu_info(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_cu_info *cu_info)\n{\n\tint i, j, k, counter, active_cu_number = 0;\n\tu32 mask, bitmap, ao_bitmap, ao_cu_mask = 0;\n\tunsigned disable_masks[4 * 4];\n\n\tif (!adev || !cu_info)\n\t\treturn -EINVAL;\n\n\t \n\tif (adev->gfx.config.max_shader_engines *\n\t\tadev->gfx.config.max_sh_per_se > 16)\n\t\treturn -EINVAL;\n\n\tamdgpu_gfx_parse_disable_cu(disable_masks,\n\t\t\t\t    adev->gfx.config.max_shader_engines,\n\t\t\t\t    adev->gfx.config.max_sh_per_se);\n\n\tmutex_lock(&adev->grbm_idx_mutex);\n\tfor (i = 0; i < adev->gfx.config.max_shader_engines; i++) {\n\t\tfor (j = 0; j < adev->gfx.config.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tao_bitmap = 0;\n\t\t\tcounter = 0;\n\t\t\tamdgpu_gfx_select_se_sh(adev, i, j, 0xffffffff, 0);\n\t\t\tgfx_v9_0_set_user_cu_inactive_bitmap(\n\t\t\t\tadev, disable_masks[i * adev->gfx.config.max_sh_per_se + j]);\n\t\t\tbitmap = gfx_v9_0_get_cu_active_bitmap(adev);\n\n\t\t\t \n\t\t\tcu_info->bitmap[0][i % 4][j + i / 4] = bitmap;\n\n\t\t\tfor (k = 0; k < adev->gfx.config.max_cu_per_sh; k ++) {\n\t\t\t\tif (bitmap & mask) {\n\t\t\t\t\tif (counter < adev->gfx.config.max_cu_per_sh)\n\t\t\t\t\t\tao_bitmap |= mask;\n\t\t\t\t\tcounter ++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\t\t\tactive_cu_number += counter;\n\t\t\tif (i < 2 && j < 2)\n\t\t\t\tao_cu_mask |= (ao_bitmap << (i * 16 + j * 8));\n\t\t\tcu_info->ao_cu_bitmap[i % 4][j + i / 4] = ao_bitmap;\n\t\t}\n\t}\n\tamdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff, 0);\n\tmutex_unlock(&adev->grbm_idx_mutex);\n\n\tcu_info->number = active_cu_number;\n\tcu_info->ao_cu_mask = ao_cu_mask;\n\tcu_info->simd_per_cu = NUM_SIMD_PER_CU;\n\n\treturn 0;\n}\n\nconst struct amdgpu_ip_block_version gfx_v9_0_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_GFX,\n\t.major = 9,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &gfx_v9_0_ip_funcs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}