{
  "module_name": "amdgpu_bo_list.c",
  "hash_id": "2df6d4340532f0bd2f65ad72b1219d7aa80cb413a2c1dd3b37a270a42770f21e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c",
  "human_readable_source": " \n \n\n#include <linux/sort.h>\n#include <linux/uaccess.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_trace.h\"\n\n#define AMDGPU_BO_LIST_MAX_PRIORITY\t32u\n#define AMDGPU_BO_LIST_NUM_BUCKETS\t(AMDGPU_BO_LIST_MAX_PRIORITY + 1)\n\nstatic void amdgpu_bo_list_free_rcu(struct rcu_head *rcu)\n{\n\tstruct amdgpu_bo_list *list = container_of(rcu, struct amdgpu_bo_list,\n\t\t\t\t\t\t   rhead);\n\tmutex_destroy(&list->bo_list_mutex);\n\tkvfree(list);\n}\n\nstatic void amdgpu_bo_list_free(struct kref *ref)\n{\n\tstruct amdgpu_bo_list *list = container_of(ref, struct amdgpu_bo_list,\n\t\t\t\t\t\t   refcount);\n\tstruct amdgpu_bo_list_entry *e;\n\n\tamdgpu_bo_list_for_each_entry(e, list)\n\t\tamdgpu_bo_unref(&e->bo);\n\tcall_rcu(&list->rhead, amdgpu_bo_list_free_rcu);\n}\n\nstatic int amdgpu_bo_list_entry_cmp(const void *_a, const void *_b)\n{\n\tconst struct amdgpu_bo_list_entry *a = _a, *b = _b;\n\n\tif (a->priority > b->priority)\n\t\treturn 1;\n\tif (a->priority < b->priority)\n\t\treturn -1;\n\treturn 0;\n}\n\nint amdgpu_bo_list_create(struct amdgpu_device *adev, struct drm_file *filp,\n\t\t\t  struct drm_amdgpu_bo_list_entry *info,\n\t\t\t  size_t num_entries, struct amdgpu_bo_list **result)\n{\n\tunsigned last_entry = 0, first_userptr = num_entries;\n\tstruct amdgpu_bo_list_entry *array;\n\tstruct amdgpu_bo_list *list;\n\tuint64_t total_size = 0;\n\tsize_t size;\n\tunsigned i;\n\tint r;\n\n\tif (num_entries > (SIZE_MAX - sizeof(struct amdgpu_bo_list))\n\t\t\t\t/ sizeof(struct amdgpu_bo_list_entry))\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct amdgpu_bo_list);\n\tsize += num_entries * sizeof(struct amdgpu_bo_list_entry);\n\tlist = kvmalloc(size, GFP_KERNEL);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tkref_init(&list->refcount);\n\tlist->gds_obj = NULL;\n\tlist->gws_obj = NULL;\n\tlist->oa_obj = NULL;\n\n\tarray = amdgpu_bo_list_array_entry(list, 0);\n\tmemset(array, 0, num_entries * sizeof(struct amdgpu_bo_list_entry));\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tstruct amdgpu_bo_list_entry *entry;\n\t\tstruct drm_gem_object *gobj;\n\t\tstruct amdgpu_bo *bo;\n\t\tstruct mm_struct *usermm;\n\n\t\tgobj = drm_gem_object_lookup(filp, info[i].bo_handle);\n\t\tif (!gobj) {\n\t\t\tr = -ENOENT;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tbo = amdgpu_bo_ref(gem_to_amdgpu_bo(gobj));\n\t\tdrm_gem_object_put(gobj);\n\n\t\tusermm = amdgpu_ttm_tt_get_usermm(bo->tbo.ttm);\n\t\tif (usermm) {\n\t\t\tif (usermm != current->mm) {\n\t\t\t\tamdgpu_bo_unref(&bo);\n\t\t\t\tr = -EPERM;\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t\tentry = &array[--first_userptr];\n\t\t} else {\n\t\t\tentry = &array[last_entry++];\n\t\t}\n\n\t\tentry->priority = min(info[i].bo_priority,\n\t\t\t\t      AMDGPU_BO_LIST_MAX_PRIORITY);\n\t\tentry->bo = bo;\n\n\t\tif (bo->preferred_domains == AMDGPU_GEM_DOMAIN_GDS)\n\t\t\tlist->gds_obj = bo;\n\t\tif (bo->preferred_domains == AMDGPU_GEM_DOMAIN_GWS)\n\t\t\tlist->gws_obj = bo;\n\t\tif (bo->preferred_domains == AMDGPU_GEM_DOMAIN_OA)\n\t\t\tlist->oa_obj = bo;\n\n\t\ttotal_size += amdgpu_bo_size(bo);\n\t\ttrace_amdgpu_bo_list_set(list, bo);\n\t}\n\n\tlist->first_userptr = first_userptr;\n\tlist->num_entries = num_entries;\n\tsort(array, last_entry, sizeof(struct amdgpu_bo_list_entry),\n\t     amdgpu_bo_list_entry_cmp, NULL);\n\n\ttrace_amdgpu_cs_bo_status(list->num_entries, total_size);\n\n\tmutex_init(&list->bo_list_mutex);\n\t*result = list;\n\treturn 0;\n\nerror_free:\n\tfor (i = 0; i < last_entry; ++i)\n\t\tamdgpu_bo_unref(&array[i].bo);\n\tfor (i = first_userptr; i < num_entries; ++i)\n\t\tamdgpu_bo_unref(&array[i].bo);\n\tkvfree(list);\n\treturn r;\n\n}\n\nstatic void amdgpu_bo_list_destroy(struct amdgpu_fpriv *fpriv, int id)\n{\n\tstruct amdgpu_bo_list *list;\n\n\tmutex_lock(&fpriv->bo_list_lock);\n\tlist = idr_remove(&fpriv->bo_list_handles, id);\n\tmutex_unlock(&fpriv->bo_list_lock);\n\tif (list)\n\t\tkref_put(&list->refcount, amdgpu_bo_list_free);\n}\n\nint amdgpu_bo_list_get(struct amdgpu_fpriv *fpriv, int id,\n\t\t       struct amdgpu_bo_list **result)\n{\n\trcu_read_lock();\n\t*result = idr_find(&fpriv->bo_list_handles, id);\n\n\tif (*result && kref_get_unless_zero(&(*result)->refcount)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\trcu_read_unlock();\n\t*result = NULL;\n\treturn -ENOENT;\n}\n\nvoid amdgpu_bo_list_put(struct amdgpu_bo_list *list)\n{\n\tkref_put(&list->refcount, amdgpu_bo_list_free);\n}\n\nint amdgpu_bo_create_list_entry_array(struct drm_amdgpu_bo_list_in *in,\n\t\t\t\t      struct drm_amdgpu_bo_list_entry **info_param)\n{\n\tconst void __user *uptr = u64_to_user_ptr(in->bo_info_ptr);\n\tconst uint32_t info_size = sizeof(struct drm_amdgpu_bo_list_entry);\n\tstruct drm_amdgpu_bo_list_entry *info;\n\tint r;\n\n\tinfo = kvmalloc_array(in->bo_number, info_size, GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\tr = -EFAULT;\n\tif (likely(info_size == in->bo_info_size)) {\n\t\tunsigned long bytes = in->bo_number *\n\t\t\tin->bo_info_size;\n\n\t\tif (copy_from_user(info, uptr, bytes))\n\t\t\tgoto error_free;\n\n\t} else {\n\t\tunsigned long bytes = min(in->bo_info_size, info_size);\n\t\tunsigned i;\n\n\t\tmemset(info, 0, in->bo_number * info_size);\n\t\tfor (i = 0; i < in->bo_number; ++i) {\n\t\t\tif (copy_from_user(&info[i], uptr, bytes))\n\t\t\t\tgoto error_free;\n\n\t\t\tuptr += in->bo_info_size;\n\t\t}\n\t}\n\n\t*info_param = info;\n\treturn 0;\n\nerror_free:\n\tkvfree(info);\n\treturn r;\n}\n\nint amdgpu_bo_list_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_fpriv *fpriv = filp->driver_priv;\n\tunion drm_amdgpu_bo_list *args = data;\n\tuint32_t handle = args->in.list_handle;\n\tstruct drm_amdgpu_bo_list_entry *info = NULL;\n\tstruct amdgpu_bo_list *list, *old;\n\tint r;\n\n\tr = amdgpu_bo_create_list_entry_array(&args->in, &info);\n\tif (r)\n\t\treturn r;\n\n\tswitch (args->in.operation) {\n\tcase AMDGPU_BO_LIST_OP_CREATE:\n\t\tr = amdgpu_bo_list_create(adev, filp, info, args->in.bo_number,\n\t\t\t\t\t  &list);\n\t\tif (r)\n\t\t\tgoto error_free;\n\n\t\tmutex_lock(&fpriv->bo_list_lock);\n\t\tr = idr_alloc(&fpriv->bo_list_handles, list, 1, 0, GFP_KERNEL);\n\t\tmutex_unlock(&fpriv->bo_list_lock);\n\t\tif (r < 0) {\n\t\t\tgoto error_put_list;\n\t\t}\n\n\t\thandle = r;\n\t\tbreak;\n\n\tcase AMDGPU_BO_LIST_OP_DESTROY:\n\t\tamdgpu_bo_list_destroy(fpriv, handle);\n\t\thandle = 0;\n\t\tbreak;\n\n\tcase AMDGPU_BO_LIST_OP_UPDATE:\n\t\tr = amdgpu_bo_list_create(adev, filp, info, args->in.bo_number,\n\t\t\t\t\t  &list);\n\t\tif (r)\n\t\t\tgoto error_free;\n\n\t\tmutex_lock(&fpriv->bo_list_lock);\n\t\told = idr_replace(&fpriv->bo_list_handles, list, handle);\n\t\tmutex_unlock(&fpriv->bo_list_lock);\n\n\t\tif (IS_ERR(old)) {\n\t\t\tr = PTR_ERR(old);\n\t\t\tgoto error_put_list;\n\t\t}\n\n\t\tamdgpu_bo_list_put(old);\n\t\tbreak;\n\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto error_free;\n\t}\n\n\tmemset(args, 0, sizeof(*args));\n\targs->out.list_handle = handle;\n\tkvfree(info);\n\n\treturn 0;\n\nerror_put_list:\n\tamdgpu_bo_list_put(list);\n\nerror_free:\n\tkvfree(info);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}