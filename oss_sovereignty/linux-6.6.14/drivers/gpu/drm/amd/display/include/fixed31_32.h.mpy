{
  "module_name": "fixed31_32.h",
  "hash_id": "b2701ac9372e0df3c4d41603e5a640e585f8b5667e41be5062189ba9fb5dab65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/include/fixed31_32.h",
  "human_readable_source": " \n\n#ifndef __DAL_FIXED31_32_H__\n#define __DAL_FIXED31_32_H__\n\n#ifndef LLONG_MAX\n#define LLONG_MAX 9223372036854775807ll\n#endif\n#ifndef LLONG_MIN\n#define LLONG_MIN (-LLONG_MAX - 1ll)\n#endif\n\n#define FIXED31_32_BITS_PER_FRACTIONAL_PART 32\n#ifndef LLONG_MIN\n#define LLONG_MIN (1LL<<63)\n#endif\n#ifndef LLONG_MAX\n#define LLONG_MAX (-1LL>>1)\n#endif\n\n \n\nstruct fixed31_32 {\n\tlong long value;\n};\n\n\n \n\nstatic const struct fixed31_32 dc_fixpt_zero = { 0 };\nstatic const struct fixed31_32 dc_fixpt_epsilon = { 1LL };\nstatic const struct fixed31_32 dc_fixpt_half = { 0x80000000LL };\nstatic const struct fixed31_32 dc_fixpt_one = { 0x100000000LL };\n\n \n\n \nstruct fixed31_32 dc_fixpt_from_fraction(long long numerator, long long denominator);\n\n \nstatic inline struct fixed31_32 dc_fixpt_from_int(int arg)\n{\n\tstruct fixed31_32 res;\n\n\tres.value = (long long) arg << FIXED31_32_BITS_PER_FRACTIONAL_PART;\n\n\treturn res;\n}\n\n \n\n \nstatic inline struct fixed31_32 dc_fixpt_neg(struct fixed31_32 arg)\n{\n\tstruct fixed31_32 res;\n\n\tres.value = -arg.value;\n\n\treturn res;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_abs(struct fixed31_32 arg)\n{\n\tif (arg.value < 0)\n\t\treturn dc_fixpt_neg(arg);\n\telse\n\t\treturn arg;\n}\n\n \n\n \nstatic inline bool dc_fixpt_lt(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\treturn arg1.value < arg2.value;\n}\n\n \nstatic inline bool dc_fixpt_le(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\treturn arg1.value <= arg2.value;\n}\n\n \nstatic inline bool dc_fixpt_eq(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\treturn arg1.value == arg2.value;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_min(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tif (arg1.value <= arg2.value)\n\t\treturn arg1;\n\telse\n\t\treturn arg2;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_max(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tif (arg1.value <= arg2.value)\n\t\treturn arg2;\n\telse\n\t\treturn arg1;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_clamp(\n\tstruct fixed31_32 arg,\n\tstruct fixed31_32 min_value,\n\tstruct fixed31_32 max_value)\n{\n\tif (dc_fixpt_le(arg, min_value))\n\t\treturn min_value;\n\telse if (dc_fixpt_le(max_value, arg))\n\t\treturn max_value;\n\telse\n\t\treturn arg;\n}\n\n \n\n \nstatic inline struct fixed31_32 dc_fixpt_shl(struct fixed31_32 arg, unsigned char shift)\n{\n\tASSERT(((arg.value >= 0) && (arg.value <= LLONG_MAX >> shift)) ||\n\t\t((arg.value < 0) && (arg.value >= ~(LLONG_MAX >> shift))));\n\n\targ.value = arg.value << shift;\n\n\treturn arg;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_shr(struct fixed31_32 arg, unsigned char shift)\n{\n\tbool negative = arg.value < 0;\n\n\tif (negative)\n\t\targ.value = -arg.value;\n\targ.value = arg.value >> shift;\n\tif (negative)\n\t\targ.value = -arg.value;\n\treturn arg;\n}\n\n \n\n \nstatic inline struct fixed31_32 dc_fixpt_add(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tstruct fixed31_32 res;\n\n\tASSERT(((arg1.value >= 0) && (LLONG_MAX - arg1.value >= arg2.value)) ||\n\t\t((arg1.value < 0) && (LLONG_MIN - arg1.value <= arg2.value)));\n\n\tres.value = arg1.value + arg2.value;\n\n\treturn res;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_add_int(struct fixed31_32 arg1, int arg2)\n{\n\treturn dc_fixpt_add(arg1, dc_fixpt_from_int(arg2));\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_sub(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tstruct fixed31_32 res;\n\n\tASSERT(((arg2.value >= 0) && (LLONG_MIN + arg2.value <= arg1.value)) ||\n\t\t((arg2.value < 0) && (LLONG_MAX + arg2.value >= arg1.value)));\n\n\tres.value = arg1.value - arg2.value;\n\n\treturn res;\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_sub_int(struct fixed31_32 arg1, int arg2)\n{\n\treturn dc_fixpt_sub(arg1, dc_fixpt_from_int(arg2));\n}\n\n\n \n\n \nstruct fixed31_32 dc_fixpt_mul(struct fixed31_32 arg1, struct fixed31_32 arg2);\n\n\n \nstatic inline struct fixed31_32 dc_fixpt_mul_int(struct fixed31_32 arg1, int arg2)\n{\n\treturn dc_fixpt_mul(arg1, dc_fixpt_from_int(arg2));\n}\n\n \nstruct fixed31_32 dc_fixpt_sqr(struct fixed31_32 arg);\n\n \nstatic inline struct fixed31_32 dc_fixpt_div_int(struct fixed31_32 arg1, long long arg2)\n{\n\treturn dc_fixpt_from_fraction(arg1.value, dc_fixpt_from_int((int)arg2).value);\n}\n\n \nstatic inline struct fixed31_32 dc_fixpt_div(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\treturn dc_fixpt_from_fraction(arg1.value, arg2.value);\n}\n\n \n\n \nstruct fixed31_32 dc_fixpt_recip(struct fixed31_32 arg);\n\n \n\n \nstruct fixed31_32 dc_fixpt_sinc(struct fixed31_32 arg);\n\n \nstruct fixed31_32 dc_fixpt_sin(struct fixed31_32 arg);\n\n \nstruct fixed31_32 dc_fixpt_cos(struct fixed31_32 arg);\n\n \n\n \nstruct fixed31_32 dc_fixpt_exp(struct fixed31_32 arg);\n\n \nstruct fixed31_32 dc_fixpt_log(struct fixed31_32 arg);\n\n \n\n \nstatic inline struct fixed31_32 dc_fixpt_pow(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tif (arg1.value == 0)\n\t\treturn arg2.value == 0 ? dc_fixpt_one : dc_fixpt_zero;\n\n\treturn dc_fixpt_exp(\n\t\tdc_fixpt_mul(\n\t\t\tdc_fixpt_log(arg1),\n\t\t\targ2));\n}\n\n \n\n \nstatic inline int dc_fixpt_floor(struct fixed31_32 arg)\n{\n\tunsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;\n\n\tif (arg.value >= 0)\n\t\treturn (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n\telse\n\t\treturn -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n}\n\n \nstatic inline int dc_fixpt_round(struct fixed31_32 arg)\n{\n\tunsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;\n\n\tconst long long summand = dc_fixpt_half.value;\n\n\tASSERT(LLONG_MAX - (long long)arg_value >= summand);\n\n\targ_value += summand;\n\n\tif (arg.value >= 0)\n\t\treturn (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n\telse\n\t\treturn -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n}\n\n \nstatic inline int dc_fixpt_ceil(struct fixed31_32 arg)\n{\n\tunsigned long long arg_value = arg.value > 0 ? arg.value : -arg.value;\n\n\tconst long long summand = dc_fixpt_one.value -\n\t\tdc_fixpt_epsilon.value;\n\n\tASSERT(LLONG_MAX - (long long)arg_value >= summand);\n\n\targ_value += summand;\n\n\tif (arg.value >= 0)\n\t\treturn (int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n\telse\n\t\treturn -(int)(arg_value >> FIXED31_32_BITS_PER_FRACTIONAL_PART);\n}\n\n \n\nunsigned int dc_fixpt_u4d19(struct fixed31_32 arg);\n\nunsigned int dc_fixpt_u3d19(struct fixed31_32 arg);\n\nunsigned int dc_fixpt_u2d19(struct fixed31_32 arg);\n\nunsigned int dc_fixpt_u0d19(struct fixed31_32 arg);\n\nunsigned int dc_fixpt_clamp_u0d14(struct fixed31_32 arg);\n\nunsigned int dc_fixpt_clamp_u0d10(struct fixed31_32 arg);\n\nint dc_fixpt_s4d19(struct fixed31_32 arg);\n\nstatic inline struct fixed31_32 dc_fixpt_truncate(struct fixed31_32 arg, unsigned int frac_bits)\n{\n\tbool negative = arg.value < 0;\n\n\tif (frac_bits >= FIXED31_32_BITS_PER_FRACTIONAL_PART) {\n\t\tASSERT(frac_bits == FIXED31_32_BITS_PER_FRACTIONAL_PART);\n\t\treturn arg;\n\t}\n\n\tif (negative)\n\t\targ.value = -arg.value;\n\targ.value &= (~0ULL) << (FIXED31_32_BITS_PER_FRACTIONAL_PART - frac_bits);\n\tif (negative)\n\t\targ.value = -arg.value;\n\treturn arg;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}