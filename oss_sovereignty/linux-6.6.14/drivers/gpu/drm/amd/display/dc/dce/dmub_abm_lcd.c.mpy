{
  "module_name": "dmub_abm_lcd.c",
  "hash_id": "d77235bdcf2aaef37e20b0eb51cee6df56e48868c545e973ab542a884ceca5b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c",
  "human_readable_source": " \n\n#include \"dmub_abm.h\"\n#include \"dmub_abm_lcd.h\"\n#include \"dce_abm.h\"\n#include \"dc.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dmub/dmub_srv.h\"\n#include \"core_types.h\"\n#include \"dm_services.h\"\n#include \"reg_helper.h\"\n#include \"fixed31_32.h\"\n\n#ifdef _WIN32\n#include \"atombios.h\"\n#else\n#include \"atom.h\"\n#endif\n\n#define TO_DMUB_ABM(abm)\\\n\tcontainer_of(abm, struct dce_abm, base)\n\n#define REG(reg) \\\n\t(dce_abm->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdce_abm->abm_shift->field_name, dce_abm->abm_mask->field_name\n\n#define CTX \\\n\tdce_abm->base.ctx\n\n#define DISABLE_ABM_IMMEDIATELY 255\n\n\n\nstatic void dmub_abm_enable_fractional_pwm(struct dc_context *dc)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint32_t fractional_pwm = (dc->dc->config.disable_fractional_pwm == false) ? 1 : 0;\n\tuint32_t edp_id_count = dc->dc_edp_id_count;\n\tint i;\n\tuint8_t panel_mask = 0;\n\n\tfor (i = 0; i < edp_id_count; i++)\n\t\tpanel_mask |= 0x01 << i;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_pwm_frac.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_pwm_frac.header.sub_type = DMUB_CMD__ABM_SET_PWM_FRAC;\n\tcmd.abm_set_pwm_frac.abm_set_pwm_frac_data.fractional_pwm = fractional_pwm;\n\tcmd.abm_set_pwm_frac.abm_set_pwm_frac_data.version = DMUB_CMD_ABM_CONTROL_VERSION_1;\n\tcmd.abm_set_pwm_frac.abm_set_pwm_frac_data.panel_mask = panel_mask;\n\tcmd.abm_set_pwm_frac.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_pwm_frac_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nvoid dmub_abm_init(struct abm *abm, uint32_t backlight)\n{\n\tstruct dce_abm *dce_abm = TO_DMUB_ABM(abm);\n\n\tREG_WRITE(DC_ABM1_HG_SAMPLE_RATE, 0x3);\n\tREG_WRITE(DC_ABM1_HG_SAMPLE_RATE, 0x1);\n\tREG_WRITE(DC_ABM1_LS_SAMPLE_RATE, 0x3);\n\tREG_WRITE(DC_ABM1_LS_SAMPLE_RATE, 0x1);\n\tREG_WRITE(BL1_PWM_BL_UPDATE_SAMPLE_RATE, 0x1);\n\n\tREG_SET_3(DC_ABM1_HG_MISC_CTRL, 0,\n\t\t\tABM1_HG_NUM_OF_BINS_SEL, 0,\n\t\t\tABM1_HG_VMAX_SEL, 1,\n\t\t\tABM1_HG_BIN_BITWIDTH_SIZE_SEL, 0);\n\n\tREG_SET_3(DC_ABM1_IPCSC_COEFF_SEL, 0,\n\t\t\tABM1_IPCSC_COEFF_SEL_R, 2,\n\t\t\tABM1_IPCSC_COEFF_SEL_G, 4,\n\t\t\tABM1_IPCSC_COEFF_SEL_B, 2);\n\n\tREG_UPDATE(BL1_PWM_CURRENT_ABM_LEVEL,\n\t\t\tBL1_PWM_CURRENT_ABM_LEVEL, backlight);\n\n\tREG_UPDATE(BL1_PWM_TARGET_ABM_LEVEL,\n\t\t\tBL1_PWM_TARGET_ABM_LEVEL, backlight);\n\n\tREG_UPDATE(BL1_PWM_USER_LEVEL,\n\t\t\tBL1_PWM_USER_LEVEL, backlight);\n\n\tREG_UPDATE_2(DC_ABM1_LS_MIN_MAX_PIXEL_VALUE_THRES,\n\t\t\tABM1_LS_MIN_PIXEL_VALUE_THRES, 0,\n\t\t\tABM1_LS_MAX_PIXEL_VALUE_THRES, 1000);\n\n\tREG_SET_3(DC_ABM1_HGLS_REG_READ_PROGRESS, 0,\n\t\t\tABM1_HG_REG_READ_MISSED_FRAME_CLEAR, 1,\n\t\t\tABM1_LS_REG_READ_MISSED_FRAME_CLEAR, 1,\n\t\t\tABM1_BL_REG_READ_MISSED_FRAME_CLEAR, 1);\n\n\tdmub_abm_enable_fractional_pwm(abm->ctx);\n}\n\nunsigned int dmub_abm_get_current_backlight(struct abm *abm)\n{\n\tstruct dce_abm *dce_abm = TO_DMUB_ABM(abm);\n\tunsigned int backlight = REG_READ(BL1_PWM_CURRENT_ABM_LEVEL);\n\n\t \n\treturn backlight;\n}\n\nunsigned int dmub_abm_get_target_backlight(struct abm *abm)\n{\n\tstruct dce_abm *dce_abm = TO_DMUB_ABM(abm);\n\tunsigned int backlight = REG_READ(BL1_PWM_TARGET_ABM_LEVEL);\n\n\t \n\treturn backlight;\n}\n\nbool dmub_abm_set_level(struct abm *abm, uint32_t level, uint8_t panel_mask)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_level.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_level.header.sub_type = DMUB_CMD__ABM_SET_LEVEL;\n\tcmd.abm_set_level.abm_set_level_data.level = level;\n\tcmd.abm_set_level.abm_set_level_data.version = DMUB_CMD_ABM_CONTROL_VERSION_1;\n\tcmd.abm_set_level.abm_set_level_data.panel_mask = panel_mask;\n\tcmd.abm_set_level.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_level_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nvoid dmub_abm_init_config(struct abm *abm,\n\tconst char *src,\n\tunsigned int bytes,\n\tunsigned int inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\tuint8_t panel_mask = 0x01 << inst;\n\n\t\n\tdmub_flush_buffer_mem(&dc->dmub_srv->dmub->scratch_mem_fb);\n\n\t\n\tmemcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)src, bytes);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\t\n\tcmd.abm_init_config.header.type = DMUB_CMD__ABM;\n\tcmd.abm_init_config.header.sub_type = DMUB_CMD__ABM_INIT_CONFIG;\n\tcmd.abm_init_config.abm_init_config_data.src.quad_part = dc->dmub_srv->dmub->scratch_mem_fb.gpu_addr;\n\tcmd.abm_init_config.abm_init_config_data.bytes = bytes;\n\tcmd.abm_init_config.abm_init_config_data.version = DMUB_CMD_ABM_CONTROL_VERSION_1;\n\tcmd.abm_init_config.abm_init_config_data.panel_mask = panel_mask;\n\n\tcmd.abm_init_config.header.payload_bytes = sizeof(struct dmub_cmd_abm_init_config_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n}\n\nbool dmub_abm_set_pause(struct abm *abm, bool pause, unsigned int panel_inst, unsigned int stream_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\tuint8_t panel_mask = 0x01 << panel_inst;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_pause.header.type = DMUB_CMD__ABM;\n\tcmd.abm_pause.header.sub_type = DMUB_CMD__ABM_PAUSE;\n\tcmd.abm_pause.abm_pause_data.enable = pause;\n\tcmd.abm_pause.abm_pause_data.panel_mask = panel_mask;\n\tcmd.abm_set_level.header.payload_bytes = sizeof(struct dmub_cmd_abm_pause_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n\n \nbool dmub_abm_save_restore(\n\t\tstruct dc_context *dc,\n\t\tunsigned int panel_inst,\n\t\tstruct abm_save_restore *pData)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint8_t panel_mask = 0x01 << panel_inst;\n\tunsigned int bytes = sizeof(struct abm_save_restore);\n\n\t\n\tdmub_flush_buffer_mem(&dc->dmub_srv->dmub->scratch_mem_fb);\n\n\t\n\tmemcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)pData, bytes);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_save_restore.header.type = DMUB_CMD__ABM;\n\tcmd.abm_save_restore.header.sub_type = DMUB_CMD__ABM_SAVE_RESTORE;\n\n\tcmd.abm_save_restore.abm_init_config_data.src.quad_part = dc->dmub_srv->dmub->scratch_mem_fb.gpu_addr;\n\tcmd.abm_save_restore.abm_init_config_data.bytes = bytes;\n\tcmd.abm_save_restore.abm_init_config_data.version = DMUB_CMD_ABM_CONTROL_VERSION_1;\n\tcmd.abm_save_restore.abm_init_config_data.panel_mask = panel_mask;\n\n\tcmd.abm_save_restore.header.payload_bytes = sizeof(struct dmub_rb_cmd_abm_save_restore);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t\n\tmemcpy((void *)pData, dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, bytes);\n\n\treturn true;\n}\n\nbool dmub_abm_set_pipe(struct abm *abm,\n\t\tuint32_t otg_inst,\n\t\tuint32_t option,\n\t\tuint32_t panel_inst,\n\t\tuint32_t pwrseq_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\tuint32_t ramping_boundary = 0xFFFF;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_pipe.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_pipe.header.sub_type = DMUB_CMD__ABM_SET_PIPE;\n\tcmd.abm_set_pipe.abm_set_pipe_data.otg_inst = otg_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.pwrseq_inst = pwrseq_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.set_pipe_option = option;\n\tcmd.abm_set_pipe.abm_set_pipe_data.panel_inst = panel_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.ramping_boundary = ramping_boundary;\n\tcmd.abm_set_pipe.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_pipe_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nbool dmub_abm_set_backlight_level(struct abm *abm,\n\t\tunsigned int backlight_pwm_u16_16,\n\t\tunsigned int frame_ramp,\n\t\tunsigned int panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_backlight.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_backlight.header.sub_type = DMUB_CMD__ABM_SET_BACKLIGHT;\n\tcmd.abm_set_backlight.abm_set_backlight_data.frame_ramp = frame_ramp;\n\tcmd.abm_set_backlight.abm_set_backlight_data.backlight_user_level = backlight_pwm_u16_16;\n\tcmd.abm_set_backlight.abm_set_backlight_data.version = DMUB_CMD_ABM_CONTROL_VERSION_1;\n\tcmd.abm_set_backlight.abm_set_backlight_data.panel_mask = (0x01 << panel_inst);\n\tcmd.abm_set_backlight.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_backlight_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}