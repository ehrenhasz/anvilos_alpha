{
  "module_name": "dcn20_dpp_cm.c",
  "hash_id": "1d17a1ee1beb88dda6ab1583fd99811ac759e8c19fc109b3b78e5d9c7c62a0bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dpp_cm.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"core_types.h\"\n\n#include \"reg_helper.h\"\n#include \"dcn20_dpp.h\"\n#include \"basics/conversion.h\"\n\n#include \"dcn10/dcn10_cm_common.h\"\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define IND_REG(index) \\\n\t(index)\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\n\nstatic void dpp2_enable_cm_block(\n\t\tstruct dpp *dpp_base)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tunsigned int cm_bypass_mode = 0;\n\t\n\tif (dpp_base->ctx->dc->debug.cm_in_bypass)\n\t\tcm_bypass_mode = 1;\n\n\tREG_UPDATE(CM_CONTROL, CM_BYPASS, cm_bypass_mode);\n}\n\n\nstatic bool dpp2_degamma_ram_inuse(\n\t\tstruct dpp *dpp_base,\n\t\tbool *ram_a_inuse)\n{\n\tbool ret = false;\n\tuint32_t status_reg = 0;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_GET(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_CONFIG_STATUS,\n\t\t\t&status_reg);\n\n\tif (status_reg == 3) {\n\t\t*ram_a_inuse = true;\n\t\tret = true;\n\t} else if (status_reg == 4) {\n\t\t*ram_a_inuse = false;\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nstatic void dpp2_program_degamma_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num,\n\t\tbool is_ram_a)\n{\n\tuint32_t i;\n\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tREG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,\n\t\t\t\tCM_DGAM_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,\n\t\t\t\t\tis_ram_a == true ? 0:1);\n\n\tREG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);\n\tfor (i = 0 ; i < num; i++) {\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_red_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_green_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);\n\n\t}\n\n}\n\nvoid dpp2_set_degamma_pwl(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tbool is_ram_a = true;\n\n\tdpp1_power_on_degamma_lut(dpp_base, true);\n\tdpp2_enable_cm_block(dpp_base);\n\tdpp2_degamma_ram_inuse(dpp_base, &is_ram_a);\n\tif (is_ram_a == true)\n\t\tdpp1_program_degamma_lutb_settings(dpp_base, params);\n\telse\n\t\tdpp1_program_degamma_luta_settings(dpp_base, params);\n\n\tdpp2_program_degamma_lut(dpp_base, params->rgb_resulted, params->hw_points_num, !is_ram_a);\n\tdpp1_degamma_ram_select(dpp_base, !is_ram_a);\n}\n\nvoid dpp2_set_degamma(\n\t\tstruct dpp *dpp_base,\n\t\tenum ipp_degamma_mode mode)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tdpp2_enable_cm_block(dpp_base);\n\n\tswitch (mode) {\n\tcase IPP_DEGAMMA_MODE_BYPASS:\n\t\t \n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);\n\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_HW_sRGB:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);\n\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_HW_xvYCC:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);\n\t\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_USER_PWL:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\nstatic void program_gamut_remap(\n\t\tstruct dcn20_dpp *dpp,\n\t\tconst uint16_t *regval,\n\t\tenum dcn20_gamut_remap_select select)\n{\n\tuint32_t cur_select = 0;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (regval == NULL || select == DCN2_GAMUT_REMAP_BYPASS) {\n\t\tREG_SET(CM_GAMUT_REMAP_CONTROL, 0,\n\t\t\t\tCM_GAMUT_REMAP_MODE, 0);\n\t\treturn;\n\t}\n\n\t \n\tIX_REG_GET(CM_TEST_DEBUG_INDEX, CM_TEST_DEBUG_DATA,\n\t\t\t\t\tCM_TEST_DEBUG_DATA_STATUS_IDX,\n\t\t\t\t\tCM_TEST_DEBUG_DATA_GAMUT_REMAP_MODE, &cur_select);\n\n\t \n\tif (cur_select != DCN2_GAMUT_REMAP_COEF_A)\n\t\tselect = DCN2_GAMUT_REMAP_COEF_A;\n\telse\n\t\tselect = DCN2_GAMUT_REMAP_COEF_B;\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_GAMUT_REMAP_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_GAMUT_REMAP_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_GAMUT_REMAP_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_GAMUT_REMAP_C12;\n\n\tif (select == DCN2_GAMUT_REMAP_COEF_A) {\n\t\tgam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);\n\t} else {\n\t\tgam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_B_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_B_C33_C34);\n\t}\n\n\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\n\tREG_SET(\n\t\t\tCM_GAMUT_REMAP_CONTROL, 0,\n\t\t\tCM_GAMUT_REMAP_MODE, select);\n\n}\n\nvoid dpp2_cm_set_gamut_remap(\n\tstruct dpp *dpp_base,\n\tconst struct dpp_grph_csc_adjustment *adjust)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tint i = 0;\n\n\tif (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)\n\t\t \n\t\tprogram_gamut_remap(dpp, NULL, DCN2_GAMUT_REMAP_BYPASS);\n\telse {\n\t\tstruct fixed31_32 arr_matrix[12];\n\t\tuint16_t arr_reg_val[12];\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tarr_matrix[i] = adjust->temperature_matrix[i];\n\n\t\tconvert_float_matrix(\n\t\t\tarr_reg_val, arr_matrix, 12);\n\n\t\tprogram_gamut_remap(dpp, arr_reg_val, DCN2_GAMUT_REMAP_COEF_A);\n\t}\n}\n\nvoid dpp2_program_input_csc(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_color_space color_space,\n\t\tenum dcn20_input_csc_select input_select,\n\t\tconst struct out_csc_color_matrix *tbl_entry)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tint i;\n\tint arr_size = sizeof(dpp_input_csc_matrix)/sizeof(struct dpp_input_csc_matrix);\n\tconst uint16_t *regval = NULL;\n\tuint32_t cur_select = 0;\n\tenum dcn20_input_csc_select select;\n\tstruct color_matrices_reg icsc_regs;\n\n\tif (input_select == DCN2_ICSC_SELECT_BYPASS) {\n\t\tREG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);\n\t\treturn;\n\t}\n\n\tif (tbl_entry == NULL) {\n\t\tfor (i = 0; i < arr_size; i++)\n\t\t\tif (dpp_input_csc_matrix[i].color_space == color_space) {\n\t\t\t\tregval = dpp_input_csc_matrix[i].regval;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (regval == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tregval = tbl_entry->regval;\n\t}\n\n\t \n\tIX_REG_GET(CM_TEST_DEBUG_INDEX, CM_TEST_DEBUG_DATA,\n\t\t\t\t\tCM_TEST_DEBUG_DATA_STATUS_IDX,\n\t\t\t\t\tCM_TEST_DEBUG_DATA_ICSC_MODE, &cur_select);\n\n\tif (cur_select != DCN2_ICSC_SELECT_ICSC_A)\n\t\tselect = DCN2_ICSC_SELECT_ICSC_A;\n\telse\n\t\tselect = DCN2_ICSC_SELECT_ICSC_B;\n\n\ticsc_regs.shifts.csc_c11 = dpp->tf_shift->CM_ICSC_C11;\n\ticsc_regs.masks.csc_c11  = dpp->tf_mask->CM_ICSC_C11;\n\ticsc_regs.shifts.csc_c12 = dpp->tf_shift->CM_ICSC_C12;\n\ticsc_regs.masks.csc_c12 = dpp->tf_mask->CM_ICSC_C12;\n\n\tif (select == DCN2_ICSC_SELECT_ICSC_A) {\n\n\t\ticsc_regs.csc_c11_c12 = REG(CM_ICSC_C11_C12);\n\t\ticsc_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);\n\n\t} else {\n\n\t\ticsc_regs.csc_c11_c12 = REG(CM_ICSC_B_C11_C12);\n\t\ticsc_regs.csc_c33_c34 = REG(CM_ICSC_B_C33_C34);\n\n\t}\n\n\tcm_helper_program_color_matrices(\n\t\t\tdpp->base.ctx,\n\t\t\tregval,\n\t\t\t&icsc_regs);\n\n\tREG_SET(CM_ICSC_CONTROL, 0,\n\t\t\t\tCM_ICSC_MODE, select);\n}\n\nstatic void dpp20_power_on_blnd_lut(\n\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_SET(CM_MEM_PWR_CTRL, 0,\n\t\t\tBLNDGAM_MEM_PWR_FORCE, power_on == true ? 0:1);\n\n}\n\nstatic void dpp20_configure_blnd_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_UPDATE(CM_BLNDGAM_LUT_WRITE_EN_MASK,\n\t\t\tCM_BLNDGAM_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_BLNDGAM_LUT_WRITE_EN_MASK,\n\t\t\tCM_BLNDGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);\n\tREG_SET(CM_BLNDGAM_LUT_INDEX, 0, CM_BLNDGAM_LUT_INDEX, 0);\n}\n\nstatic void dpp20_program_blnd_pwl(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num)\n{\n\tuint32_t i;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tfor (i = 0 ; i < num; i++) {\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].green_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0,\n\t\t\t\tCM_BLNDGAM_LUT_DATA, rgb[i].delta_red_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0,\n\t\t\t\tCM_BLNDGAM_LUT_DATA, rgb[i].delta_green_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0,\n\t\t\t\tCM_BLNDGAM_LUT_DATA, rgb[i].delta_blue_reg);\n\n\t}\n\n}\n\nstatic void dcn20_dpp_cm_get_reg_field(\n\t\tstruct dcn20_dpp *dpp,\n\t\tstruct xfer_func_reg *reg)\n{\n\treg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_B;\n\treg->masks.field_region_end = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B;\n\treg->masks.field_region_linear_slope = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B;\n\treg->shifts.exp_region_start = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n}\n\n \nstatic void dpp20_program_blnd_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdcn20_dpp_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_BLNDGAM_RAMA_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_BLNDGAM_RAMA_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_BLNDGAM_RAMA_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_BLNDGAM_RAMA_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_BLNDGAM_RAMA_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_BLNDGAM_RAMA_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_BLNDGAM_RAMA_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_BLNDGAM_RAMA_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_BLNDGAM_RAMA_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_BLNDGAM_RAMA_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_BLNDGAM_RAMA_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_BLNDGAM_RAMA_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_BLNDGAM_RAMA_REGION_0_1);\n\tgam_regs.region_end = REG(CM_BLNDGAM_RAMA_REGION_32_33);\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\n \nstatic void dpp20_program_blnd_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdcn20_dpp_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_BLNDGAM_RAMB_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_BLNDGAM_RAMB_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_BLNDGAM_RAMB_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_BLNDGAM_RAMB_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_BLNDGAM_RAMB_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_BLNDGAM_RAMB_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_BLNDGAM_RAMB_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_BLNDGAM_RAMB_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_BLNDGAM_RAMB_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_BLNDGAM_RAMB_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_BLNDGAM_RAMB_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_BLNDGAM_RAMB_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_BLNDGAM_RAMB_REGION_0_1);\n\tgam_regs.region_end = REG(CM_BLNDGAM_RAMB_REGION_32_33);\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\nstatic enum dc_lut_mode dpp20_get_blndgam_current(struct dpp *dpp_base)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t state_mode;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_GET(CM_BLNDGAM_LUT_WRITE_EN_MASK, CM_BLNDGAM_CONFIG_STATUS, &state_mode);\n\n\tswitch (state_mode) {\n\tcase 0:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\tcase 1:\n\t\tmode = LUT_RAM_A;\n\t\tbreak;\n\tcase 2:\n\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nbool dpp20_program_blnd_lut(\n\tstruct dpp *dpp_base, const struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tif (params == NULL) {\n\t\tREG_SET(CM_BLNDGAM_CONTROL, 0, CM_BLNDGAM_LUT_MODE, 0);\n\t\treturn false;\n\t}\n\tcurrent_mode = dpp20_get_blndgam_current(dpp_base);\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)\n\t\tnext_mode = LUT_RAM_B;\n\telse\n\t\tnext_mode = LUT_RAM_A;\n\n\tdpp20_power_on_blnd_lut(dpp_base, true);\n\tdpp20_configure_blnd_lut(dpp_base, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_A)\n\t\tdpp20_program_blnd_luta_settings(dpp_base, params);\n\telse\n\t\tdpp20_program_blnd_lutb_settings(dpp_base, params);\n\n\tdpp20_program_blnd_pwl(\n\t\t\tdpp_base, params->rgb_resulted, params->hw_points_num);\n\n\tREG_SET(CM_BLNDGAM_CONTROL, 0, CM_BLNDGAM_LUT_MODE,\n\t\t\tnext_mode == LUT_RAM_A ? 1:2);\n\n\treturn true;\n}\n\n\nstatic void dpp20_program_shaper_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num)\n{\n\tuint32_t i, red, green, blue;\n\tuint32_t  red_delta, green_delta, blue_delta;\n\tuint32_t  red_value, green_value, blue_value;\n\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tfor (i = 0 ; i < num; i++) {\n\n\t\tred   = rgb[i].red_reg;\n\t\tgreen = rgb[i].green_reg;\n\t\tblue  = rgb[i].blue_reg;\n\n\t\tred_delta   = rgb[i].delta_red_reg;\n\t\tgreen_delta = rgb[i].delta_green_reg;\n\t\tblue_delta  = rgb[i].delta_blue_reg;\n\n\t\tred_value   = ((red_delta   & 0x3ff) << 14) | (red   & 0x3fff);\n\t\tgreen_value = ((green_delta & 0x3ff) << 14) | (green & 0x3fff);\n\t\tblue_value  = ((blue_delta  & 0x3ff) << 14) | (blue  & 0x3fff);\n\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, red_value);\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, green_value);\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, blue_value);\n\t}\n\n}\n\nstatic enum dc_lut_mode dpp20_get_shaper_current(struct dpp *dpp_base)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t state_mode;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_GET(CM_SHAPER_LUT_WRITE_EN_MASK, CM_SHAPER_CONFIG_STATUS, &state_mode);\n\n\tswitch (state_mode) {\n\tcase 0:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\tcase 1:\n\t\tmode = LUT_RAM_A;\n\t\tbreak;\n\tcase 2:\n\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic void dpp20_configure_shaper_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_UPDATE(CM_SHAPER_LUT_WRITE_EN_MASK,\n\t\t\tCM_SHAPER_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_SHAPER_LUT_WRITE_EN_MASK,\n\t\t\tCM_SHAPER_LUT_WRITE_SEL, is_ram_a == true ? 0:1);\n\tREG_SET(CM_SHAPER_LUT_INDEX, 0, CM_SHAPER_LUT_INDEX, 0);\n}\n\n \n\nstatic void dpp20_program_shaper_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tconst struct gamma_curve *curve;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_B, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_B, params->corner_points[0].blue.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_B, 0);\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_G, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_G, params->corner_points[0].green.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_G, 0);\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_R, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_R, params->corner_points[0].red.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_R, 0);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_B, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_B, params->corner_points[1].blue.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_B, params->corner_points[1].blue.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_G, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_G, params->corner_points[1].green.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_G, params->corner_points[1].green.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_R, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_R, params->corner_points[1].red.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_R, params->corner_points[1].red.custom_float_y);\n\n\tcurve = params->arr_curve_points;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_0_1, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_2_3, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_4_5, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_6_7, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_8_9, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_10_11, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_12_13, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_14_15, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_16_17, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_18_19, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_20_21, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_22_23, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_24_25, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_26_27, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_28_29, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_30_31, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_32_33, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);\n}\n\n \nstatic void dpp20_program_shaper_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tconst struct gamma_curve *curve;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_B, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_B, params->corner_points[0].blue.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_B, 0);\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_G, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_G, params->corner_points[0].green.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_G, 0);\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_R, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_R, params->corner_points[0].red.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_R, 0);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_B, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_B, params->corner_points[1].blue.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_B, params->corner_points[1].blue.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_G, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_G, params->corner_points[1].green.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_G, params->corner_points[1].green.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_R, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_R, params->corner_points[1].red.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_R, params->corner_points[1].red.custom_float_y);\n\n\tcurve = params->arr_curve_points;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_0_1, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_2_3, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_4_5, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_6_7, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_8_9, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_10_11, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_12_13, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_14_15, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_16_17, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_18_19, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_20_21, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_22_23, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_24_25, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_26_27, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_28_29, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_30_31, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_32_33, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);\n\n}\n\n\nbool dpp20_program_shaper(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tif (params == NULL) {\n\t\tREG_SET(CM_SHAPER_CONTROL, 0, CM_SHAPER_LUT_MODE, 0);\n\t\treturn false;\n\t}\n\tcurrent_mode = dpp20_get_shaper_current(dpp_base);\n\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)\n\t\tnext_mode = LUT_RAM_B;\n\telse\n\t\tnext_mode = LUT_RAM_A;\n\n\tdpp20_configure_shaper_lut(dpp_base, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_A)\n\t\tdpp20_program_shaper_luta_settings(dpp_base, params);\n\telse\n\t\tdpp20_program_shaper_lutb_settings(dpp_base, params);\n\n\tdpp20_program_shaper_lut(\n\t\t\tdpp_base, params->rgb_resulted, params->hw_points_num);\n\n\tREG_SET(CM_SHAPER_CONTROL, 0, CM_SHAPER_LUT_MODE, next_mode == LUT_RAM_A ? 1:2);\n\n\treturn true;\n\n}\n\nstatic enum dc_lut_mode get3dlut_config(\n\t\t\tstruct dpp *dpp_base,\n\t\t\tbool *is_17x17x17,\n\t\t\tbool *is_12bits_color_channel)\n{\n\tuint32_t i_mode, i_enable_10bits, lut_size;\n\tenum dc_lut_mode mode;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_GET_2(CM_3DLUT_READ_WRITE_CONTROL,\n\t\t\tCM_3DLUT_CONFIG_STATUS, &i_mode,\n\t\t\tCM_3DLUT_30BIT_EN, &i_enable_10bits);\n\n\tswitch (i_mode) {\n\tcase 0:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\tcase 1:\n\t\tmode = LUT_RAM_A;\n\t\tbreak;\n\tcase 2:\n\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\tif (i_enable_10bits > 0)\n\t\t*is_12bits_color_channel = false;\n\telse\n\t\t*is_12bits_color_channel = true;\n\n\tREG_GET(CM_3DLUT_MODE, CM_3DLUT_SIZE, &lut_size);\n\n\tif (lut_size == 0)\n\t\t*is_17x17x17 = true;\n\telse\n\t\t*is_17x17x17 = false;\n\n\treturn mode;\n}\n \nstatic void dpp20_set_3dlut_mode(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_lut_mode mode,\n\t\tbool is_color_channel_12bits,\n\t\tbool is_lut_size17x17x17)\n{\n\tuint32_t lut_mode;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tif (mode == LUT_BYPASS)\n\t\tlut_mode = 0;\n\telse if (mode == LUT_RAM_A)\n\t\tlut_mode = 1;\n\telse\n\t\tlut_mode = 2;\n\n\tREG_UPDATE_2(CM_3DLUT_MODE,\n\t\t\tCM_3DLUT_MODE, lut_mode,\n\t\t\tCM_3DLUT_SIZE, is_lut_size17x17x17 == true ? 0 : 1);\n}\n\nstatic void dpp20_select_3dlut_ram(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_lut_mode mode,\n\t\tbool is_color_channel_12bits)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_UPDATE_2(CM_3DLUT_READ_WRITE_CONTROL,\n\t\t\tCM_3DLUT_RAM_SEL, mode == LUT_RAM_A ? 0 : 1,\n\t\t\tCM_3DLUT_30BIT_EN,\n\t\t\tis_color_channel_12bits == true ? 0:1);\n}\n\n\n\nstatic void dpp20_set3dlut_ram12(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_rgb *lut,\n\t\tuint32_t entries)\n{\n\tuint32_t i, red, green, blue, red1, green1, blue1;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tfor (i = 0 ; i < entries; i += 2) {\n\t\tred   = lut[i].red<<4;\n\t\tgreen = lut[i].green<<4;\n\t\tblue  = lut[i].blue<<4;\n\t\tred1   = lut[i+1].red<<4;\n\t\tgreen1 = lut[i+1].green<<4;\n\t\tblue1  = lut[i+1].blue<<4;\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, red,\n\t\t\t\tCM_3DLUT_DATA1, red1);\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, green,\n\t\t\t\tCM_3DLUT_DATA1, green1);\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, blue,\n\t\t\t\tCM_3DLUT_DATA1, blue1);\n\n\t}\n}\n\n \nstatic void dpp20_set3dlut_ram10(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_rgb *lut,\n\t\tuint32_t entries)\n{\n\tuint32_t i, red, green, blue, value;\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tred   = lut[i].red;\n\t\tgreen = lut[i].green;\n\t\tblue  = lut[i].blue;\n\n\t\tvalue = (red<<20) | (green<<10) | blue;\n\n\t\tREG_SET(CM_3DLUT_DATA_30BIT, 0, CM_3DLUT_DATA_30BIT, value);\n\t}\n\n}\n\n\nstatic void dpp20_select_3dlut_ram_mask(\n\t\tstruct dpp *dpp_base,\n\t\tuint32_t ram_selection_mask)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_UPDATE(CM_3DLUT_READ_WRITE_CONTROL, CM_3DLUT_WRITE_EN_MASK,\n\t\t\tram_selection_mask);\n\tREG_SET(CM_3DLUT_INDEX, 0, CM_3DLUT_INDEX, 0);\n}\n\nbool dpp20_program_3dlut(\n\t\tstruct dpp *dpp_base,\n\t\tstruct tetrahedral_params *params)\n{\n\tenum dc_lut_mode mode;\n\tbool is_17x17x17;\n\tbool is_12bits_color_channel;\n\tstruct dc_rgb *lut0;\n\tstruct dc_rgb *lut1;\n\tstruct dc_rgb *lut2;\n\tstruct dc_rgb *lut3;\n\tint lut_size0;\n\tint lut_size;\n\n\tif (params == NULL) {\n\t\tdpp20_set_3dlut_mode(dpp_base, LUT_BYPASS, false, false);\n\t\treturn false;\n\t}\n\tmode = get3dlut_config(dpp_base, &is_17x17x17, &is_12bits_color_channel);\n\n\tif (mode == LUT_BYPASS || mode == LUT_RAM_B)\n\t\tmode = LUT_RAM_A;\n\telse\n\t\tmode = LUT_RAM_B;\n\n\tis_17x17x17 = !params->use_tetrahedral_9;\n\tis_12bits_color_channel = params->use_12bits;\n\tif (is_17x17x17) {\n\t\tlut0 = params->tetrahedral_17.lut0;\n\t\tlut1 = params->tetrahedral_17.lut1;\n\t\tlut2 = params->tetrahedral_17.lut2;\n\t\tlut3 = params->tetrahedral_17.lut3;\n\t\tlut_size0 = sizeof(params->tetrahedral_17.lut0)/\n\t\t\t\t\tsizeof(params->tetrahedral_17.lut0[0]);\n\t\tlut_size  = sizeof(params->tetrahedral_17.lut1)/\n\t\t\t\t\tsizeof(params->tetrahedral_17.lut1[0]);\n\t} else {\n\t\tlut0 = params->tetrahedral_9.lut0;\n\t\tlut1 = params->tetrahedral_9.lut1;\n\t\tlut2 = params->tetrahedral_9.lut2;\n\t\tlut3 = params->tetrahedral_9.lut3;\n\t\tlut_size0 = sizeof(params->tetrahedral_9.lut0)/\n\t\t\t\tsizeof(params->tetrahedral_9.lut0[0]);\n\t\tlut_size  = sizeof(params->tetrahedral_9.lut1)/\n\t\t\t\tsizeof(params->tetrahedral_9.lut1[0]);\n\t\t}\n\n\tdpp20_select_3dlut_ram(dpp_base, mode,\n\t\t\t\tis_12bits_color_channel);\n\tdpp20_select_3dlut_ram_mask(dpp_base, 0x1);\n\tif (is_12bits_color_channel)\n\t\tdpp20_set3dlut_ram12(dpp_base, lut0, lut_size0);\n\telse\n\t\tdpp20_set3dlut_ram10(dpp_base, lut0, lut_size0);\n\n\tdpp20_select_3dlut_ram_mask(dpp_base, 0x2);\n\tif (is_12bits_color_channel)\n\t\tdpp20_set3dlut_ram12(dpp_base, lut1, lut_size);\n\telse\n\t\tdpp20_set3dlut_ram10(dpp_base, lut1, lut_size);\n\n\tdpp20_select_3dlut_ram_mask(dpp_base, 0x4);\n\tif (is_12bits_color_channel)\n\t\tdpp20_set3dlut_ram12(dpp_base, lut2, lut_size);\n\telse\n\t\tdpp20_set3dlut_ram10(dpp_base, lut2, lut_size);\n\n\tdpp20_select_3dlut_ram_mask(dpp_base, 0x8);\n\tif (is_12bits_color_channel)\n\t\tdpp20_set3dlut_ram12(dpp_base, lut3, lut_size);\n\telse\n\t\tdpp20_set3dlut_ram10(dpp_base, lut3, lut_size);\n\n\n\tdpp20_set_3dlut_mode(dpp_base, mode, is_12bits_color_channel,\n\t\t\t\t\tis_17x17x17);\n\n\treturn true;\n}\n\nvoid dpp2_set_hdr_multiplier(\n\t\tstruct dpp *dpp_base,\n\t\tuint32_t multiplier)\n{\n\tstruct dcn20_dpp *dpp = TO_DCN20_DPP(dpp_base);\n\n\tREG_UPDATE(CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, multiplier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}