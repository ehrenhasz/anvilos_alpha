{
  "module_name": "dce_clk_mgr.c",
  "hash_id": "614845e494af2f85764e3a62c5e3e09cac0813c07b9322dd38c9f11a2774e038",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"dce_clk_mgr.h\"\n\n#include \"reg_helper.h\"\n#include \"dmcu.h\"\n#include \"core_types.h\"\n#include \"dal_asic_id.h\"\n\n#define TO_DCE_CLK_MGR(clocks)\\\n\tcontainer_of(clocks, struct dce_clk_mgr, base)\n\n#define REG(reg) \\\n\t(clk_mgr_dce->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr_dce->clk_mgr_shift->field_name, clk_mgr_dce->clk_mgr_mask->field_name\n\n#define CTX \\\n\tclk_mgr_dce->base.ctx\n#define DC_LOGGER \\\n\tclk_mgr->ctx->logger\n\n \nstatic const struct state_dependent_clocks dce80_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000},\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 } };\n\nstatic const struct state_dependent_clocks dce110_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000 },\n \n{ .display_clk_khz = 467000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 643000, .pixel_clk_khz = 400000 } };\n\nstatic const struct state_dependent_clocks dce112_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 389189, .pixel_clk_khz = 346672 },\n \n{ .display_clk_khz = 459000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 667000, .pixel_clk_khz = 600000 },\n \n{ .display_clk_khz = 1132000, .pixel_clk_khz = 600000 } };\n\nstatic const struct state_dependent_clocks dce120_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 460000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 670000, .pixel_clk_khz = 600000 },\n \n{ .display_clk_khz = 1133000, .pixel_clk_khz = 600000 } };\n\nint dentist_get_divider_from_did(int did)\n{\n\tif (did < DENTIST_BASE_DID_1)\n\t\tdid = DENTIST_BASE_DID_1;\n\tif (did > DENTIST_MAX_DID)\n\t\tdid = DENTIST_MAX_DID;\n\n\tif (did < DENTIST_BASE_DID_2) {\n\t\treturn DENTIST_DIVIDER_RANGE_1_START + DENTIST_DIVIDER_RANGE_1_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_1);\n\t} else if (did < DENTIST_BASE_DID_3) {\n\t\treturn DENTIST_DIVIDER_RANGE_2_START + DENTIST_DIVIDER_RANGE_2_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_2);\n\t} else if (did < DENTIST_BASE_DID_4) {\n\t\treturn DENTIST_DIVIDER_RANGE_3_START + DENTIST_DIVIDER_RANGE_3_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_3);\n\t} else {\n\t\treturn DENTIST_DIVIDER_RANGE_4_START + DENTIST_DIVIDER_RANGE_4_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_4);\n\t}\n}\n\n \nstatic int clk_mgr_adjust_dp_ref_freq_for_ss(struct dce_clk_mgr *clk_mgr_dce, int dp_ref_clk_khz)\n{\n\tif (clk_mgr_dce->ss_on_dprefclk && clk_mgr_dce->dprefclk_ss_divider != 0) {\n\t\tstruct fixed31_32 ss_percentage = dc_fixpt_div_int(\n\t\t\t\tdc_fixpt_from_fraction(clk_mgr_dce->dprefclk_ss_percentage,\n\t\t\t\t\t\t\tclk_mgr_dce->dprefclk_ss_divider), 200);\n\t\tstruct fixed31_32 adj_dp_ref_clk_khz;\n\n\t\tss_percentage = dc_fixpt_sub(dc_fixpt_one, ss_percentage);\n\t\tadj_dp_ref_clk_khz = dc_fixpt_mul_int(ss_percentage, dp_ref_clk_khz);\n\t\tdp_ref_clk_khz = dc_fixpt_floor(adj_dp_ref_clk_khz);\n\t}\n\treturn dp_ref_clk_khz;\n}\n\nstatic int dce_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tint dprefclk_wdivider;\n\tint dprefclk_src_sel;\n\tint dp_ref_clk_khz = 600000;\n\tint target_div;\n\n\t \n\tREG_GET(DPREFCLK_CNTL, DPREFCLK_SRC_SEL, &dprefclk_src_sel);\n\tASSERT(dprefclk_src_sel == 0);\n\n\t \n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DPREFCLK_WDIVIDER, &dprefclk_wdivider);\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dprefclk_wdivider);\n\n\t \n\tdp_ref_clk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr_dce->dentist_vco_freq_khz) / target_div;\n\n\treturn clk_mgr_adjust_dp_ref_freq_for_ss(clk_mgr_dce, dp_ref_clk_khz);\n}\n\nint dce12_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\n\treturn clk_mgr_adjust_dp_ref_freq_for_ss(clk_mgr_dce, clk_mgr_dce->dprefclk_khz);\n}\n\n \nstatic uint32_t get_max_pixel_clock_for_all_paths(struct dc_state *context)\n{\n\tuint32_t max_pix_clk = 0;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pipe_ctx->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10 > max_pix_clk)\n\t\t\tmax_pix_clk = pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;\n\n\t\t \n\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal) &&\n\t\t\t\tpipe_ctx->stream_res.pix_clk_params.requested_sym_clk > max_pix_clk)\n\t\t\tmax_pix_clk = pipe_ctx->stream_res.pix_clk_params.requested_sym_clk;\n\t}\n\n\treturn max_pix_clk;\n}\n\nstatic enum dm_pp_clocks_state dce_get_required_clocks_state(\n\tstruct clk_mgr *clk_mgr,\n\tstruct dc_state *context)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tint i;\n\tenum dm_pp_clocks_state low_req_clk;\n\tint max_pix_clk = get_max_pixel_clock_for_all_paths(context);\n\n\t \n\tfor (i = clk_mgr_dce->max_clks_state; i >= DM_PP_CLOCKS_STATE_ULTRA_LOW; i--)\n\t\tif (context->bw_ctx.bw.dce.dispclk_khz >\n\t\t\t\tclk_mgr_dce->max_clks_by_state[i].display_clk_khz\n\t\t\t|| max_pix_clk >\n\t\t\t\tclk_mgr_dce->max_clks_by_state[i].pixel_clk_khz)\n\t\t\tbreak;\n\n\tlow_req_clk = i + 1;\n\tif (low_req_clk > clk_mgr_dce->max_clks_state) {\n\t\t \n\t\tif (clk_mgr_dce->max_clks_by_state[clk_mgr_dce->max_clks_state].display_clk_khz\n\t\t\t\t< context->bw_ctx.bw.dce.dispclk_khz)\n\t\t\tlow_req_clk = DM_PP_CLOCKS_STATE_INVALID;\n\t\telse\n\t\t\tlow_req_clk = clk_mgr_dce->max_clks_state;\n\t}\n\n\treturn low_req_clk;\n}\n\nstatic int dce_set_clock(\n\tstruct clk_mgr *clk_mgr,\n\tint requested_clk_khz)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct bp_pixel_clock_parameters pxl_clk_params = { 0 };\n\tstruct dc_bios *bp = clk_mgr->ctx->dc_bios;\n\tint actual_clock = requested_clk_khz;\n\tstruct dmcu *dmcu = clk_mgr_dce->base.ctx->dc->res_pool->dmcu;\n\n\t \n\tif (requested_clk_khz > 0)\n\t\trequested_clk_khz = max(requested_clk_khz,\n\t\t\t\tclk_mgr_dce->dentist_vco_freq_khz / 64);\n\n\t \n\tpxl_clk_params.target_pixel_clock_100hz = requested_clk_khz * 10;\n\tpxl_clk_params.pll_id = CLOCK_SOURCE_ID_DFS;\n\n\tif (clk_mgr_dce->dfs_bypass_active)\n\t\tpxl_clk_params.flags.SET_DISPCLK_DFS_BYPASS = true;\n\n\tbp->funcs->program_display_engine_pll(bp, &pxl_clk_params);\n\n\tif (clk_mgr_dce->dfs_bypass_active) {\n\t\t \n\t\tclk_mgr_dce->dfs_bypass_disp_clk =\n\t\t\tpxl_clk_params.dfs_bypass_display_clock;\n\t\tactual_clock = pxl_clk_params.dfs_bypass_display_clock;\n\t}\n\n\t \n\tif (requested_clk_khz == 0)\n\t\tclk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\n\tif (dmcu && dmcu->funcs->is_dmcu_initialized(dmcu))\n\t\tdmcu->funcs->set_psr_wait_loop(dmcu, actual_clock / 1000 / 7);\n\n\treturn actual_clock;\n}\n\nint dce112_set_clock(struct clk_mgr *clk_mgr, int requested_clk_khz)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct bp_set_dce_clock_parameters dce_clk_params;\n\tstruct dc_bios *bp = clk_mgr->ctx->dc_bios;\n\tstruct dc *core_dc = clk_mgr->ctx->dc;\n\tstruct dmcu *dmcu = core_dc->res_pool->dmcu;\n\tint actual_clock = requested_clk_khz;\n\t \n\tmemset(&dce_clk_params, 0, sizeof(dce_clk_params));\n\n\t \n\tif (requested_clk_khz > 0)\n\t\trequested_clk_khz = max(requested_clk_khz,\n\t\t\t\tclk_mgr_dce->dentist_vco_freq_khz / 62);\n\n\tdce_clk_params.target_clock_frequency = requested_clk_khz;\n\tdce_clk_params.pll_id = CLOCK_SOURCE_ID_DFS;\n\tdce_clk_params.clock_type = DCECLOCK_TYPE_DISPLAY_CLOCK;\n\n\tbp->funcs->set_dce_clock(bp, &dce_clk_params);\n\tactual_clock = dce_clk_params.target_clock_frequency;\n\n\t \n\tif (requested_clk_khz == 0)\n\t\tclk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\n\t \n\t \n\tdce_clk_params.target_clock_frequency = 0;\n\tdce_clk_params.clock_type = DCECLOCK_TYPE_DPREFCLK;\n\n\tif (!((clk_mgr->ctx->asic_id.chip_family == FAMILY_AI) &&\n\t       ASICREV_IS_VEGA20_P(clk_mgr->ctx->asic_id.hw_internal_rev)))\n\t\tdce_clk_params.flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK =\n\t\t\t(dce_clk_params.pll_id ==\n\t\t\t\t\tCLOCK_SOURCE_COMBO_DISPLAY_PLL0);\n\telse\n\t\tdce_clk_params.flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK = false;\n\n\tbp->funcs->set_dce_clock(bp, &dce_clk_params);\n\n\tif (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {\n\t\tif (dmcu && dmcu->funcs->is_dmcu_initialized(dmcu)) {\n\t\t\tif (clk_mgr_dce->dfs_bypass_disp_clk != actual_clock)\n\t\t\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\t\t\t\tactual_clock / 1000 / 7);\n\t\t}\n\t}\n\n\tclk_mgr_dce->dfs_bypass_disp_clk = actual_clock;\n\treturn actual_clock;\n}\n\nstatic void dce_clock_read_integrated_info(struct dce_clk_mgr *clk_mgr_dce)\n{\n\tstruct dc_debug_options *debug = &clk_mgr_dce->base.ctx->dc->debug;\n\tstruct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;\n\tstruct integrated_info info = { { { 0 } } };\n\tstruct dc_firmware_info fw_info = { { 0 } };\n\tint i;\n\n\tif (bp->integrated_info)\n\t\tinfo = *bp->integrated_info;\n\n\tclk_mgr_dce->dentist_vco_freq_khz = info.dentist_vco_freq;\n\tif (clk_mgr_dce->dentist_vco_freq_khz == 0) {\n\t\tbp->funcs->get_firmware_info(bp, &fw_info);\n\t\tclk_mgr_dce->dentist_vco_freq_khz =\n\t\t\tfw_info.smu_gpu_pll_output_freq;\n\t\tif (clk_mgr_dce->dentist_vco_freq_khz == 0)\n\t\t\tclk_mgr_dce->dentist_vco_freq_khz = 3600000;\n\t}\n\n\t \n\tfor (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\tenum dm_pp_clocks_state clk_state = DM_PP_CLOCKS_STATE_INVALID;\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_ULTRA_LOW;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_LOW;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_PERFORMANCE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_INVALID;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (info.disp_clk_voltage[i].max_supported_clk >= 100000)\n\t\t\tclk_mgr_dce->max_clks_by_state[clk_state].display_clk_khz =\n\t\t\t\tinfo.disp_clk_voltage[i].max_supported_clk;\n\t}\n\n\tif (!debug->disable_dfs_bypass && bp->integrated_info)\n\t\tif (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)\n\t\t\tclk_mgr_dce->dfs_bypass_enabled = true;\n}\n\nvoid dce_clock_read_ss_info(struct dce_clk_mgr *clk_mgr_dce)\n{\n\tstruct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;\n\tint ss_info_num = bp->funcs->get_ss_entry_number(\n\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL);\n\n\tif (ss_info_num) {\n\t\tstruct spread_spectrum_info info = { { 0 } };\n\t\tenum bp_result result = bp->funcs->get_spread_spectrum_info(\n\t\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL, 0, &info);\n\n\t\t \n\t\tif (result == BP_RESULT_OK &&\n\t\t\t\tinfo.spread_spectrum_percentage != 0) {\n\t\t\tclk_mgr_dce->ss_on_dprefclk = true;\n\t\t\tclk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;\n\n\t\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t\t \n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage =\n\t\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresult = bp->funcs->get_spread_spectrum_info(\n\t\t\t\tbp, AS_SIGNAL_TYPE_DISPLAY_PORT, 0, &info);\n\n\t\t \n\t\tif (result == BP_RESULT_OK &&\n\t\t\t\tinfo.spread_spectrum_percentage != 0) {\n\t\t\tclk_mgr_dce->ss_on_dprefclk = true;\n\t\t\tclk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;\n\n\t\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t\t \n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage =\n\t\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t\t}\n\t\t\tif (clk_mgr_dce->base.ctx->dc->debug.ignore_dpref_ss)\n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage = 0;\n\t\t}\n\t}\n}\n\n \nvoid dce121_clock_patch_xgmi_ss_info(struct clk_mgr *clk_mgr)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tenum bp_result result;\n\tstruct spread_spectrum_info info = { { 0 } };\n\tstruct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;\n\n\tclk_mgr_dce->xgmi_enabled = false;\n\n\tresult = bp->funcs->get_spread_spectrum_info(bp, AS_SIGNAL_TYPE_XGMI,\n\t\t\t\t\t\t     0, &info);\n\tif (result == BP_RESULT_OK && info.spread_spectrum_percentage != 0) {\n\t\tclk_mgr_dce->xgmi_enabled = true;\n\t\tclk_mgr_dce->ss_on_dprefclk = true;\n\t\tclk_mgr_dce->dprefclk_ss_divider =\n\t\t\t\tinfo.spread_percentage_divider;\n\n\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t \n\t\t\tclk_mgr_dce->dprefclk_ss_percentage =\n\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t}\n\t}\n}\n\nvoid dce110_fill_display_configs(\n\tconst struct dc_state *context,\n\tstruct dm_pp_display_configuration *pp_display_cfg)\n{\n\tint j;\n\tint num_cfgs = 0;\n\n\tfor (j = 0; j < context->stream_count; j++) {\n\t\tint k;\n\n\t\tconst struct dc_stream_state *stream = context->streams[j];\n\t\tstruct dm_pp_single_disp_config *cfg =\n\t\t\t&pp_display_cfg->disp_configs[num_cfgs];\n\t\tconst struct pipe_ctx *pipe_ctx = NULL;\n\n\t\tfor (k = 0; k < MAX_PIPES; k++)\n\t\t\tif (stream == context->res_ctx.pipe_ctx[k].stream) {\n\t\t\t\tpipe_ctx = &context->res_ctx.pipe_ctx[k];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tASSERT(pipe_ctx != NULL);\n\n\t\t \n\t\tif (stream->dpms_off)\n\t\t\tcontinue;\n\n\t\tnum_cfgs++;\n\t\tcfg->signal = pipe_ctx->stream->signal;\n\t\tcfg->pipe_idx = pipe_ctx->stream_res.tg->inst;\n\t\tcfg->src_height = stream->src.height;\n\t\tcfg->src_width = stream->src.width;\n\t\tcfg->ddi_channel_mapping =\n\t\t\tstream->link->ddi_channel_mapping.raw;\n\t\tcfg->transmitter =\n\t\t\tstream->link->link_enc->transmitter;\n\t\tcfg->link_settings.lane_count =\n\t\t\tstream->link->cur_link_settings.lane_count;\n\t\tcfg->link_settings.link_rate =\n\t\t\tstream->link->cur_link_settings.link_rate;\n\t\tcfg->link_settings.link_spread =\n\t\t\tstream->link->cur_link_settings.link_spread;\n\t\tcfg->sym_clock = stream->phy_pix_clk;\n\t\t \n\t\tcfg->v_refresh = stream->timing.pix_clk_100hz * 100;\n\t\tcfg->v_refresh /= stream->timing.h_total;\n\t\tcfg->v_refresh = (cfg->v_refresh + stream->timing.v_total / 2)\n\t\t\t\t\t\t\t/ stream->timing.v_total;\n\t}\n\n\tpp_display_cfg->display_count = num_cfgs;\n}\n\nstatic uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)\n{\n\tuint8_t j;\n\tuint32_t min_vertical_blank_time = -1;\n\n\tfor (j = 0; j < context->stream_count; j++) {\n\t\tstruct dc_stream_state *stream = context->streams[j];\n\t\tuint32_t vertical_blank_in_pixels = 0;\n\t\tuint32_t vertical_blank_time = 0;\n\n\t\tvertical_blank_in_pixels = stream->timing.h_total *\n\t\t\t(stream->timing.v_total\n\t\t\t - stream->timing.v_addressable);\n\n\t\tvertical_blank_time = vertical_blank_in_pixels\n\t\t\t* 10000 / stream->timing.pix_clk_100hz;\n\n\t\tif (min_vertical_blank_time > vertical_blank_time)\n\t\t\tmin_vertical_blank_time = vertical_blank_time;\n\t}\n\n\treturn min_vertical_blank_time;\n}\n\nstatic int determine_sclk_from_bounding_box(\n\t\tconst struct dc *dc,\n\t\tint required_sclk)\n{\n\tint i;\n\n\t \n\tif (dc->sclk_lvls.num_levels == 0)\n\t\treturn required_sclk;\n\n\tfor (i = 0; i < dc->sclk_lvls.num_levels; i++) {\n\t\tif (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)\n\t\t\treturn dc->sclk_lvls.clocks_in_khz[i];\n\t}\n\t \n\tASSERT(0);\n\treturn dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];\n}\n\nstatic void dce_pplib_apply_display_requirements(\n\tstruct dc *dc,\n\tstruct dc_state *context)\n{\n\tstruct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;\n\n\tpp_display_cfg->avail_mclk_switch_time_us = dce110_get_min_vblank_time_us(context);\n\n\tdce110_fill_display_configs(context, pp_display_cfg);\n\n\tif (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)\n\t\tdm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);\n}\n\nstatic void dce11_pplib_apply_display_requirements(\n\tstruct dc *dc,\n\tstruct dc_state *context)\n{\n\tstruct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;\n\n\tpp_display_cfg->all_displays_in_sync =\n\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync;\n\tpp_display_cfg->nb_pstate_switch_disable =\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable == false;\n\tpp_display_cfg->cpu_cc6_disable =\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable == false;\n\tpp_display_cfg->cpu_pstate_disable =\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable == false;\n\tpp_display_cfg->cpu_pstate_separation_time =\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us;\n\n\tpp_display_cfg->min_memory_clock_khz = context->bw_ctx.bw.dce.yclk_khz\n\t\t/ MEMORY_TYPE_MULTIPLIER_CZ;\n\n\tpp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(\n\t\t\tdc,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz);\n\n\t \n\tpp_display_cfg->min_dcfclock_khz = (context->stream_count > 4) ?\n\t\t\tpp_display_cfg->min_engine_clock_khz : 0;\n\n\tpp_display_cfg->min_engine_clock_deep_sleep_khz\n\t\t\t= context->bw_ctx.bw.dce.sclk_deep_sleep_khz;\n\n\tpp_display_cfg->avail_mclk_switch_time_us =\n\t\t\t\t\t\tdce110_get_min_vblank_time_us(context);\n\t \n\tpp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;\n\n\tpp_display_cfg->disp_clk_khz = dc->res_pool->clk_mgr->clks.dispclk_khz;\n\n\tdce110_fill_display_configs(context, pp_display_cfg);\n\n\t \n\tif (pp_display_cfg->display_count == 1) {\n\t\tconst struct dc_crtc_timing *timing =\n\t\t\t&context->streams[0]->timing;\n\n\t\tpp_display_cfg->crtc_index =\n\t\t\tpp_display_cfg->disp_configs[0].pipe_idx;\n\t\tpp_display_cfg->line_time_in_us = timing->h_total * 10000 / timing->pix_clk_100hz;\n\t}\n\n\tif (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)\n\t\tdm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);\n}\n\nstatic void dce_update_clocks(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr->clks.dispclk_khz)) {\n\t\tpatched_disp_clk = dce_set_clock(clk_mgr, patched_disp_clk);\n\t\tclk_mgr->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);\n}\n\nstatic void dce11_update_clocks(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr->clks.dispclk_khz)) {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = dce_set_clock(clk_mgr, patched_disp_clk);\n\t\tclk_mgr->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);\n}\n\nstatic void dce112_update_clocks(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr->clks.dispclk_khz)) {\n\t\tpatched_disp_clk = dce112_set_clock(clk_mgr, patched_disp_clk);\n\t\tclk_mgr->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);\n}\n\nstatic void dce12_update_clocks(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);\n\tstruct dm_pp_clock_for_voltage_req clock_voltage_req = {0};\n\tint max_pix_clk = get_max_pixel_clock_for_all_paths(context);\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr->clks.dispclk_khz)) {\n\t\tclock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_DISPLAY_CLK;\n\t\t \n\t\tif (clk_mgr_dce->xgmi_enabled)\n\t\t\tpatched_disp_clk = clk_mgr_adjust_dp_ref_freq_for_ss(\n\t\t\t\t\tclk_mgr_dce, patched_disp_clk);\n\t\tclock_voltage_req.clocks_in_khz = patched_disp_clk;\n\t\tclk_mgr->clks.dispclk_khz = dce112_set_clock(clk_mgr, patched_disp_clk);\n\n\t\tdm_pp_apply_clock_for_voltage_request(clk_mgr->ctx, &clock_voltage_req);\n\t}\n\n\tif (should_set_clock(safe_to_lower, max_pix_clk, clk_mgr->clks.phyclk_khz)) {\n\t\tclock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_DISPLAYPHYCLK;\n\t\tclock_voltage_req.clocks_in_khz = max_pix_clk;\n\t\tclk_mgr->clks.phyclk_khz = max_pix_clk;\n\n\t\tdm_pp_apply_clock_for_voltage_request(clk_mgr->ctx, &clock_voltage_req);\n\t}\n\tdce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);\n}\n\nstatic const struct clk_mgr_funcs dce120_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = dce12_update_clocks\n};\n\nstatic const struct clk_mgr_funcs dce112_funcs = {\n\t.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,\n\t.update_clocks = dce112_update_clocks\n};\n\nstatic const struct clk_mgr_funcs dce110_funcs = {\n\t.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,\n\t.update_clocks = dce11_update_clocks,\n};\n\nstatic const struct clk_mgr_funcs dce_funcs = {\n\t.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,\n\t.update_clocks = dce_update_clocks\n};\n\nstatic void dce_clk_mgr_construct(\n\tstruct dce_clk_mgr *clk_mgr_dce,\n\tstruct dc_context *ctx,\n\tconst struct clk_mgr_registers *regs,\n\tconst struct clk_mgr_shift *clk_shift,\n\tconst struct clk_mgr_mask *clk_mask)\n{\n\tstruct clk_mgr *base = &clk_mgr_dce->base;\n\tstruct dm_pp_static_clock_info static_clk_info = {0};\n\n\tbase->ctx = ctx;\n\tbase->funcs = &dce_funcs;\n\n\tclk_mgr_dce->regs = regs;\n\tclk_mgr_dce->clk_mgr_shift = clk_shift;\n\tclk_mgr_dce->clk_mgr_mask = clk_mask;\n\n\tclk_mgr_dce->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr_dce->dprefclk_ss_percentage = 0;\n\tclk_mgr_dce->dprefclk_ss_divider = 1000;\n\tclk_mgr_dce->ss_on_dprefclk = false;\n\n\n\tif (dm_pp_get_static_clocks(ctx, &static_clk_info))\n\t\tclk_mgr_dce->max_clks_state = static_clk_info.max_clocks_state;\n\telse\n\t\tclk_mgr_dce->max_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\tclk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_INVALID;\n\n\tdce_clock_read_integrated_info(clk_mgr_dce);\n\tdce_clock_read_ss_info(clk_mgr_dce);\n}\n\nstruct clk_mgr *dce_clk_mgr_create(\n\tstruct dc_context *ctx,\n\tconst struct clk_mgr_registers *regs,\n\tconst struct clk_mgr_shift *clk_shift,\n\tconst struct clk_mgr_mask *clk_mask)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);\n\n\tif (clk_mgr_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tmemcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state));\n\n\tdce_clk_mgr_construct(\n\t\tclk_mgr_dce, ctx, regs, clk_shift, clk_mask);\n\n\treturn &clk_mgr_dce->base;\n}\n\nstruct clk_mgr *dce110_clk_mgr_create(\n\tstruct dc_context *ctx,\n\tconst struct clk_mgr_registers *regs,\n\tconst struct clk_mgr_shift *clk_shift,\n\tconst struct clk_mgr_mask *clk_mask)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);\n\n\tif (clk_mgr_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tmemcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state));\n\n\tdce_clk_mgr_construct(\n\t\tclk_mgr_dce, ctx, regs, clk_shift, clk_mask);\n\n\tclk_mgr_dce->base.funcs = &dce110_funcs;\n\n\treturn &clk_mgr_dce->base;\n}\n\nstruct clk_mgr *dce112_clk_mgr_create(\n\tstruct dc_context *ctx,\n\tconst struct clk_mgr_registers *regs,\n\tconst struct clk_mgr_shift *clk_shift,\n\tconst struct clk_mgr_mask *clk_mask)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);\n\n\tif (clk_mgr_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tmemcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state));\n\n\tdce_clk_mgr_construct(\n\t\tclk_mgr_dce, ctx, regs, clk_shift, clk_mask);\n\n\tclk_mgr_dce->base.funcs = &dce112_funcs;\n\n\treturn &clk_mgr_dce->base;\n}\n\nstruct clk_mgr *dce120_clk_mgr_create(struct dc_context *ctx)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);\n\n\tif (clk_mgr_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tmemcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state));\n\n\tdce_clk_mgr_construct(\n\t\tclk_mgr_dce, ctx, NULL, NULL, NULL);\n\n\tclk_mgr_dce->dprefclk_khz = 600000;\n\tclk_mgr_dce->base.funcs = &dce120_funcs;\n\n\treturn &clk_mgr_dce->base;\n}\n\nstruct clk_mgr *dce121_clk_mgr_create(struct dc_context *ctx)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce),\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\tif (clk_mgr_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tmemcpy(clk_mgr_dce->max_clks_by_state, dce120_max_clks_by_state,\n\t       sizeof(dce120_max_clks_by_state));\n\n\tdce_clk_mgr_construct(clk_mgr_dce, ctx, NULL, NULL, NULL);\n\n\tclk_mgr_dce->dprefclk_khz = 625000;\n\tclk_mgr_dce->base.funcs = &dce120_funcs;\n\n\treturn &clk_mgr_dce->base;\n}\n\nvoid dce_clk_mgr_destroy(struct clk_mgr **clk_mgr)\n{\n\tstruct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(*clk_mgr);\n\n\tkfree(clk_mgr_dce);\n\t*clk_mgr = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}