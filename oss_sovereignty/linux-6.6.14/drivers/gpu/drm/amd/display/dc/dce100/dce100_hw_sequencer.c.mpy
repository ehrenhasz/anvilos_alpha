{
  "module_name": "dce100_hw_sequencer.c",
  "hash_id": "5d758c517d74e24b56113e212634e31cda3a0797cd6886c6f98ed3dc8713a770",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c",
  "human_readable_source": " \n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"core_types.h\"\n#include \"clk_mgr.h\"\n#include \"dce100_hw_sequencer.h\"\n#include \"resource.h\"\n\n#include \"dce110/dce110_hw_sequencer.h\"\n\n \n#include \"dce/dce_10_0_d.h\"\n#include \"dce/dce_10_0_sh_mask.h\"\n\nstruct dce100_hw_seq_reg_offsets {\n\tuint32_t blnd;\n\tuint32_t crtc;\n};\n\nstatic const struct dce100_hw_seq_reg_offsets reg_offsets[] = {\n{\n\t.crtc = (mmCRTC0_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC1_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC2_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC3_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC4_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC5_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n}\n};\n\n#define HW_REG_CRTC(reg, id)\\\n\t(reg + reg_offsets[id].crtc)\n\n \n \n\nbool dce100_enable_display_power_gating(\n\tstruct dc *dc,\n\tuint8_t controller_id,\n\tstruct dc_bios *dcb,\n\tenum pipe_gating_control power_gating)\n{\n\tenum bp_result bp_result = BP_RESULT_OK;\n\tenum bp_pipe_control_action cntl;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tif (power_gating == PIPE_GATING_CONTROL_INIT)\n\t\tcntl = ASIC_PIPE_INIT;\n\telse if (power_gating == PIPE_GATING_CONTROL_ENABLE)\n\t\tcntl = ASIC_PIPE_ENABLE;\n\telse\n\t\tcntl = ASIC_PIPE_DISABLE;\n\n\tif (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0)){\n\n\t\tbp_result = dcb->funcs->enable_disp_power_gating(\n\t\t\t\t\t\tdcb, controller_id + 1, cntl);\n\n\t\t \n\t\tdm_write_reg(ctx,\n\t\t\tHW_REG_CRTC(mmMASTER_UPDATE_MODE, controller_id),\n\t\t\t0);\n\t}\n\n\tif (bp_result == BP_RESULT_OK)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid dce100_prepare_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tdce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\tfalse);\n}\n\nvoid dce100_optimize_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tdce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\ttrue);\n}\n\n \n\nvoid dce100_hw_sequencer_construct(struct dc *dc)\n{\n\tdce110_hw_sequencer_construct(dc);\n\n\tdc->hwseq->funcs.enable_display_power_gating = dce100_enable_display_power_gating;\n\tdc->hwss.prepare_bandwidth = dce100_prepare_bandwidth;\n\tdc->hwss.optimize_bandwidth = dce100_optimize_bandwidth;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}