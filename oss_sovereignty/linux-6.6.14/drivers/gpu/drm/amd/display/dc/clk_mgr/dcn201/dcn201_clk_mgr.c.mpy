{
  "module_name": "dcn201_clk_mgr.c",
  "hash_id": "81a0ac72bb5e2b877a59dcd73a42a13abdead6ee41a6324fface454ba663dcb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn201/dcn201_clk_mgr.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n#include \"dcn201_clk_mgr.h\"\n#include \"dcn20/dcn20_clk_mgr.h\"\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dm_helpers.h\"\n#include \"dm_services.h\"\n\n#include \"cyan_skillfish_ip_offset.h\"\n#include \"dcn/dcn_2_0_3_offset.h\"\n#include \"dcn/dcn_2_0_3_sh_mask.h\"\n#include \"clk/clk_11_0_1_offset.h\"\n#include \"clk/clk_11_0_1_sh_mask.h\"\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#define BASE_INNER(seg) DMU_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define CLK_BASE_INNER(seg) \\\n\tCLK_BASE__INST0_SEG ## seg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\n#define CTX \\\n\tclk_mgr->base.ctx\n#define DC_LOGGER \\\n\tclk_mgr->base.ctx->logger\n\nstatic const struct clk_mgr_registers clk_mgr_regs = {\n\t\tCLK_COMMON_REG_LIST_DCN_201()\n};\n\nstatic const struct clk_mgr_shift clk_mgr_shift = {\n\tCLK_COMMON_MASK_SH_LIST_DCN201_BASE(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask clk_mgr_mask = {\n\tCLK_COMMON_MASK_SH_LIST_DCN201_BASE(_MASK)\n};\n\nstatic void dcn201_init_clocks(struct clk_mgr *clk_mgr)\n{\n\tmemset(&(clk_mgr->clks), 0, sizeof(struct dc_clocks));\n\tclk_mgr->clks.p_state_change_support = true;\n\tclk_mgr->clks.prev_p_state_change_support = true;\n\tclk_mgr->clks.max_supported_dppclk_khz = 1200000;\n\tclk_mgr->clks.max_supported_dispclk_khz = 1200000;\n}\n\nstatic void dcn201_update_clocks(struct clk_mgr *clk_mgr_base,\n\tstruct dc_state *context,\n\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool dpp_clock_lowered = false;\n\tbool force_reset = false;\n\tbool p_state_change_support;\n\tint total_plane_count;\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\tif (clk_mgr_base->clks.dispclk_khz == 0 ||\n\t    dc->debug.force_clock_mode & 0x1) {\n\t\tforce_reset = true;\n\n\t\tdcn2_read_clocks_from_hw_dentist(clk_mgr_base);\n\t}\n\n\tclk_mgr_helper_get_active_display_cnt(dc, context);\n\n\tif (should_set_clock(safe_to_lower, new_clocks->phyclk_khz, clk_mgr_base->clks.phyclk_khz))\n\t\tclk_mgr_base->clks.phyclk_khz = new_clocks->phyclk_khz;\n\n\tif (dc->debug.force_min_dcfclk_mhz > 0)\n\t\tnew_clocks->dcfclk_khz = (new_clocks->dcfclk_khz > (dc->debug.force_min_dcfclk_mhz * 1000)) ?\n\t\tnew_clocks->dcfclk_khz : (dc->debug.force_min_dcfclk_mhz * 1000);\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz))\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\n\tif (should_set_clock(safe_to_lower,\n\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz))\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->socclk_khz, clk_mgr_base->clks.socclk_khz))\n\t\tclk_mgr_base->clks.socclk_khz = new_clocks->socclk_khz;\n\n\ttotal_plane_count = clk_mgr_helper_get_active_plane_cnt(dc, context);\n\tp_state_change_support = new_clocks->p_state_change_support || (total_plane_count == 0);\n\tif (should_update_pstate_support(safe_to_lower, p_state_change_support, clk_mgr_base->clks.p_state_change_support)) {\n\t\tclk_mgr_base->clks.prev_p_state_change_support = clk_mgr_base->clks.p_state_change_support;\n\t\tclk_mgr_base->clks.p_state_change_support = p_state_change_support;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dramclk_khz, clk_mgr_base->clks.dramclk_khz))\n\t\tclk_mgr_base->clks.dramclk_khz = new_clocks->dramclk_khz;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr->base.clks.dppclk_khz)) {\n\t\tif (clk_mgr->base.clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\t\tclk_mgr->base.clks.dppclk_khz = new_clocks->dppclk_khz;\n\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (dc->config.forced_clocks == false || (force_reset && safe_to_lower)) {\n\t\tif (dpp_clock_lowered) {\n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t} else {\n\t\t\tif (update_dppclk || update_dispclk)\n\t\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t}\n\t}\n}\n\nstatic struct clk_mgr_funcs dcn201_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = dcn201_update_clocks,\n\t.init_clocks = dcn201_init_clocks,\n\t.get_clock = dcn2_get_clock,\n};\n\nvoid dcn201_clk_mgr_construct(struct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct dc_debug_options *debug = &ctx->dc->debug;\n\tstruct dc_bios *bp = ctx->dc_bios;\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn201_funcs;\n\tclk_mgr->regs = &clk_mgr_regs;\n\tclk_mgr->clk_mgr_shift = &clk_mgr_shift;\n\tclk_mgr->clk_mgr_mask = &clk_mgr_mask;\n\n\tclk_mgr->dccg = dccg;\n\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\n\tclk_mgr->base.dprefclk_khz = REG_READ(CLK4_CLK2_CURRENT_CNT);\n\tclk_mgr->base.dprefclk_khz *= 100;\n\n\tif (clk_mgr->base.dprefclk_khz == 0)\n\t\tclk_mgr->base.dprefclk_khz = 600000;\n\n\tREG_GET(CLK4_CLK_PLL_REQ, FbMult_int, &clk_mgr->base.dentist_vco_freq_khz);\n\tclk_mgr->base.dentist_vco_freq_khz *= 100000;\n\n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 3000000;\n\n\tif (!debug->disable_dfs_bypass && bp->integrated_info)\n\t\tif (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)\n\t\t\tclk_mgr->dfs_bypass_enabled = true;\n\n\tdce_clock_read_ss_info(clk_mgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}