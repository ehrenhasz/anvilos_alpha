{
  "module_name": "command_table.c",
  "hash_id": "034da23fc14589d36e11b9d932e541b75095d4e5b55b04ffc432af29c19868b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/bios/command_table.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"amdgpu.h\"\n#include \"atom.h\"\n\n#include \"include/bios_parser_interface.h\"\n\n#include \"command_table.h\"\n#include \"command_table_helper.h\"\n#include \"bios_parser_helper.h\"\n#include \"bios_parser_types_internal.h\"\n\n#define EXEC_BIOS_CMD_TABLE(command, params)\\\n\t(amdgpu_atom_execute_table(((struct amdgpu_device *)bp->base.ctx->driver_context)->mode_info.atom_context, \\\n\t\tGetIndexIntoMasterTable(COMMAND, command), \\\n\t\t(uint32_t *)&params) == 0)\n\n#define BIOS_CMD_TABLE_REVISION(command, frev, crev)\\\n\tamdgpu_atom_parse_cmd_header(((struct amdgpu_device *)bp->base.ctx->driver_context)->mode_info.atom_context, \\\n\t\tGetIndexIntoMasterTable(COMMAND, command), &frev, &crev)\n\n#define BIOS_CMD_TABLE_PARA_REVISION(command)\\\n\tbios_cmd_table_para_revision(bp->base.ctx->driver_context, \\\n\t\tGetIndexIntoMasterTable(COMMAND, command))\n\nstatic void init_dig_encoder_control(struct bios_parser *bp);\nstatic void init_transmitter_control(struct bios_parser *bp);\nstatic void init_set_pixel_clock(struct bios_parser *bp);\nstatic void init_enable_spread_spectrum_on_ppll(struct bios_parser *bp);\nstatic void init_adjust_display_pll(struct bios_parser *bp);\nstatic void init_dac_encoder_control(struct bios_parser *bp);\nstatic void init_dac_output_control(struct bios_parser *bp);\nstatic void init_set_crtc_timing(struct bios_parser *bp);\nstatic void init_enable_crtc(struct bios_parser *bp);\nstatic void init_enable_crtc_mem_req(struct bios_parser *bp);\nstatic void init_external_encoder_control(struct bios_parser *bp);\nstatic void init_enable_disp_power_gating(struct bios_parser *bp);\nstatic void init_program_clock(struct bios_parser *bp);\nstatic void init_set_dce_clock(struct bios_parser *bp);\n\nvoid dal_bios_parser_init_cmd_tbl(struct bios_parser *bp)\n{\n\tinit_dig_encoder_control(bp);\n\tinit_transmitter_control(bp);\n\tinit_set_pixel_clock(bp);\n\tinit_enable_spread_spectrum_on_ppll(bp);\n\tinit_adjust_display_pll(bp);\n\tinit_dac_encoder_control(bp);\n\tinit_dac_output_control(bp);\n\tinit_set_crtc_timing(bp);\n\tinit_enable_crtc(bp);\n\tinit_enable_crtc_mem_req(bp);\n\tinit_program_clock(bp);\n\tinit_external_encoder_control(bp);\n\tinit_enable_disp_power_gating(bp);\n\tinit_set_dce_clock(bp);\n}\n\nstatic uint32_t bios_cmd_table_para_revision(void *dev,\n\t\t\t\t\t     uint32_t index)\n{\n\tstruct amdgpu_device *adev = dev;\n\tuint8_t frev, crev;\n\n\tif (amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context,\n\t\t\t\t\tindex,\n\t\t\t\t\t&frev, &crev))\n\t\treturn crev;\n\telse\n\t\treturn 0;\n}\n\n \nstatic enum bp_result encoder_control_digx_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic enum bp_result encoder_control_digx_v4(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic enum bp_result encoder_control_digx_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic void init_encoder_control_dig_v1(struct bios_parser *bp);\n\nstatic void init_dig_encoder_control(struct bios_parser *bp)\n{\n\tuint32_t version =\n\t\tBIOS_CMD_TABLE_PARA_REVISION(DIGxEncoderControl);\n\n\tswitch (version) {\n\tcase 2:\n\t\tbp->cmd_tbl.dig_encoder_control = encoder_control_digx_v3;\n\t\tbreak;\n\tcase 4:\n\t\tbp->cmd_tbl.dig_encoder_control = encoder_control_digx_v4;\n\t\tbreak;\n\n\tcase 5:\n\t\tbp->cmd_tbl.dig_encoder_control = encoder_control_digx_v5;\n\t\tbreak;\n\n\tdefault:\n\t\tinit_encoder_control_dig_v1(bp);\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result encoder_control_dig_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\nstatic enum bp_result encoder_control_dig1_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\nstatic enum bp_result encoder_control_dig2_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic void init_encoder_control_dig_v1(struct bios_parser *bp)\n{\n\tstruct cmd_tbl *cmd_tbl = &bp->cmd_tbl;\n\n\tif (1 == BIOS_CMD_TABLE_PARA_REVISION(DIG1EncoderControl))\n\t\tcmd_tbl->encoder_control_dig1 = encoder_control_dig1_v1;\n\telse\n\t\tcmd_tbl->encoder_control_dig1 = NULL;\n\n\tif (1 == BIOS_CMD_TABLE_PARA_REVISION(DIG2EncoderControl))\n\t\tcmd_tbl->encoder_control_dig2 = encoder_control_dig2_v1;\n\telse\n\t\tcmd_tbl->encoder_control_dig2 = NULL;\n\n\tcmd_tbl->dig_encoder_control = encoder_control_dig_v1;\n}\n\nstatic enum bp_result encoder_control_dig_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tstruct cmd_tbl *cmd_tbl = &bp->cmd_tbl;\n\n\tif (cntl != NULL)\n\t\tswitch (cntl->engine_id) {\n\t\tcase ENGINE_ID_DIGA:\n\t\t\tif (cmd_tbl->encoder_control_dig1 != NULL)\n\t\t\t\tresult =\n\t\t\t\t\tcmd_tbl->encoder_control_dig1(bp, cntl);\n\t\t\tbreak;\n\t\tcase ENGINE_ID_DIGB:\n\t\t\tif (cmd_tbl->encoder_control_dig2 != NULL)\n\t\t\t\tresult =\n\t\t\t\t\tcmd_tbl->encoder_control_dig2(bp, cntl);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_dig1_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V2 params = {0};\n\n\tbp->cmd_helper->assign_control_parameter(bp->cmd_helper, cntl, &params);\n\n\tif (EXEC_BIOS_CMD_TABLE(DIG1EncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_dig2_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V2 params = {0};\n\n\tbp->cmd_helper->assign_control_parameter(bp->cmd_helper, cntl, &params);\n\n\tif (EXEC_BIOS_CMD_TABLE(DIG2EncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_digx_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V3 params = {0};\n\n\tif (LANE_COUNT_FOUR < cntl->lanes_number)\n\t\tparams.acConfig.ucDPLinkRate = 1;  \n\telse\n\t\tparams.acConfig.ucDPLinkRate = 0;  \n\n\tparams.acConfig.ucDigSel = (uint8_t)(cntl->engine_id);\n\n\t \n\tparams.ucAction = bp->cmd_helper->encoder_action_to_atom(cntl->action);\n\tparams.usPixelClock = cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\tparams.ucEncoderMode =\n\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tcntl->signal,\n\t\t\t\t\tcntl->enable_dp_audio);\n\tparams.ucLaneNum = (uint8_t)(cntl->lanes_number);\n\n\tswitch (cntl->color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tparams.ucBitPerColor = PANEL_8BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tparams.ucBitPerColor = PANEL_10BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tparams.ucBitPerColor = PANEL_12BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tparams.ucBitPerColor = PANEL_16BIT_PER_COLOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(DIGxEncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_digx_v4(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V4 params = {0};\n\n\tif (LANE_COUNT_FOUR < cntl->lanes_number)\n\t\tparams.acConfig.ucDPLinkRate = 1;  \n\telse\n\t\tparams.acConfig.ucDPLinkRate = 0;  \n\n\tparams.acConfig.ucDigSel = (uint8_t)(cntl->engine_id);\n\n\t \n\tparams.ucAction = bp->cmd_helper->encoder_action_to_atom(cntl->action);\n\tparams.usPixelClock = cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\tparams.ucEncoderMode =\n\t\t\t(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tcntl->signal,\n\t\t\t\t\tcntl->enable_dp_audio));\n\tparams.ucLaneNum = (uint8_t)(cntl->lanes_number);\n\n\tswitch (cntl->color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tparams.ucBitPerColor = PANEL_8BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tparams.ucBitPerColor = PANEL_10BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tparams.ucBitPerColor = PANEL_12BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tparams.ucBitPerColor = PANEL_16BIT_PER_COLOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(DIGxEncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_digx_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tENCODER_STREAM_SETUP_PARAMETERS_V5 params = {0};\n\n\tparams.ucDigId = (uint8_t)(cntl->engine_id);\n\tparams.ucAction = bp->cmd_helper->encoder_action_to_atom(cntl->action);\n\n\tparams.ulPixelClock = cntl->pixel_clock / 10;\n\tparams.ucDigMode =\n\t\t\t(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tcntl->signal,\n\t\t\t\t\tcntl->enable_dp_audio));\n\tparams.ucLaneNum = (uint8_t)(cntl->lanes_number);\n\n\tswitch (cntl->color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tparams.ucBitPerColor = PANEL_8BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tparams.ucBitPerColor = PANEL_10BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tparams.ucBitPerColor = PANEL_12BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tparams.ucBitPerColor = PANEL_16BIT_PER_COLOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\tswitch (cntl->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tparams.ulPixelClock =\n\t\t\t\t(params.ulPixelClock * 30) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tparams.ulPixelClock =\n\t\t\t\t(params.ulPixelClock * 36) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tparams.ulPixelClock =\n\t\t\t\t(params.ulPixelClock * 48) / 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(DIGxEncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result transmitter_control_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\nstatic enum bp_result transmitter_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\nstatic enum bp_result transmitter_control_v4(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\nstatic enum bp_result transmitter_control_v1_5(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\nstatic enum bp_result transmitter_control_v1_6(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\n\nstatic void init_transmitter_control(struct bios_parser *bp)\n{\n\tuint8_t frev;\n\tuint8_t crev;\n\n\tif (BIOS_CMD_TABLE_REVISION(UNIPHYTransmitterControl,\n\t\t\tfrev, crev) == false)\n\t\tBREAK_TO_DEBUGGER();\n\tswitch (crev) {\n\tcase 2:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v2;\n\t\tbreak;\n\tcase 3:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v3;\n\t\tbreak;\n\tcase 4:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v4;\n\t\tbreak;\n\tcase 5:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v1_5;\n\t\tbreak;\n\tcase 6:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v1_6;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have transmitter_control for v%d\\n\", crev);\n\t\tbp->cmd_tbl.transmitter_control = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result transmitter_control_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V2 params;\n\tenum connector_id connector_id =\n\t\tdal_graphics_object_id_get_connector_id(cntl->connector_obj_id);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (cntl->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\tcase TRANSMITTER_UNIPHY_B:\n\tcase TRANSMITTER_UNIPHY_C:\n\tcase TRANSMITTER_UNIPHY_D:\n\tcase TRANSMITTER_UNIPHY_E:\n\tcase TRANSMITTER_UNIPHY_F:\n\tcase TRANSMITTER_TRAVIS_LCD:\n\t\tbreak;\n\tdefault:\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tswitch (cntl->action) {\n\tcase TRANSMITTER_CONTROL_INIT:\n\t\tif ((CONNECTOR_ID_DUAL_LINK_DVII == connector_id) ||\n\t\t\t\t(CONNECTOR_ID_DUAL_LINK_DVID == connector_id))\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t \n\t\tparams.usInitInfo =\n\t\t\t\tcpu_to_le16((uint8_t)cntl->connector_obj_id.id);\n\t\tbreak;\n\tcase TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:\n\t\t \n\t\tparams.asMode.ucLaneSel = (uint8_t)cntl->lane_select;\n\t\tparams.asMode.ucLaneSet = (uint8_t)cntl->lane_settings;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (LANE_COUNT_FOUR < cntl->lanes_number) {\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 20));\n\t\t} else\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\t\tbreak;\n\t}\n\n\t \n\n\tparams.acConfig.fCoherentMode = cntl->coherent;\n\n\tif ((TRANSMITTER_UNIPHY_B == cntl->transmitter)\n\t\t\t|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)\n\t\t\t|| (TRANSMITTER_UNIPHY_F == cntl->transmitter))\n\t\t \n\t\tparams.acConfig.ucLinkSel = 1;\n\n\tif (ENGINE_ID_DIGB == cntl->engine_id)\n\t\t \n\t\tparams.acConfig.ucEncoderSel = 1;\n\n\tif (CONNECTOR_ID_DISPLAY_PORT == connector_id ||\n\t    CONNECTOR_ID_USBC == connector_id)\n\t\t \n\t\tparams.acConfig.fDPConnector = 1;\n\n\t \n\tparams.acConfig.ucTransmitterSel =\n\t\t\t(uint8_t)bp->cmd_helper->transmitter_bp_to_atom(\n\t\t\t\t\tcntl->transmitter);\n\n\tparams.ucAction = (uint8_t)cntl->action;\n\n\tif (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result transmitter_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V3 params;\n\tuint32_t pll_id;\n\tenum connector_id conn_id =\n\t\t\tdal_graphics_object_id_get_connector_id(cntl->connector_obj_id);\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\tbool dual_link_conn = (CONNECTOR_ID_DUAL_LINK_DVII == conn_id)\n\t\t\t\t\t|| (CONNECTOR_ID_DUAL_LINK_DVID == conn_id);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (cntl->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\tcase TRANSMITTER_UNIPHY_B:\n\tcase TRANSMITTER_UNIPHY_C:\n\tcase TRANSMITTER_UNIPHY_D:\n\tcase TRANSMITTER_UNIPHY_E:\n\tcase TRANSMITTER_UNIPHY_F:\n\tcase TRANSMITTER_TRAVIS_LCD:\n\t\tbreak;\n\tdefault:\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tif (!cmd->clock_source_id_to_atom(cntl->pll_id, &pll_id))\n\t\treturn BP_RESULT_BADINPUT;\n\n\t \n\tswitch (cntl->action) {\n\tcase TRANSMITTER_CONTROL_INIT:\n\t\tif (dual_link_conn) {\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\t\t}\n\n\t\t \n\t\tparams.usInitInfo =\n\t\t\t\tcpu_to_le16((uint8_t)(cntl->connector_obj_id.id));\n\t\tbreak;\n\tcase TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:\n\t\t \n\t\tparams.asMode.ucLaneSel = (uint8_t)cntl->lane_select;\n\t\tparams.asMode.ucLaneSet = (uint8_t)cntl->lane_settings;\n\t\tbreak;\n\tdefault:\n\t\tif (dual_link_conn && cntl->multi_path)\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t \n\t\tif (LANE_COUNT_FOUR < cntl->lanes_number) {\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 20));\n\t\t} else {\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\n\tparams.acConfig.fCoherentMode = cntl->coherent;\n\n\tif ((TRANSMITTER_UNIPHY_B == cntl->transmitter)\n\t\t|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)\n\t\t|| (TRANSMITTER_UNIPHY_F == cntl->transmitter))\n\t\t \n\t\tparams.acConfig.ucLinkSel = 1;\n\n\tif (ENGINE_ID_DIGB == cntl->engine_id)\n\t\t \n\t\tparams.acConfig.ucEncoderSel = 1;\n\n\t \n\tparams.acConfig.ucTransmitterSel =\n\t\t\t(uint8_t)cmd->transmitter_bp_to_atom(cntl->transmitter);\n\n\tparams.ucLaneNum = (uint8_t)cntl->lanes_number;\n\n\tparams.acConfig.ucRefClkSource = (uint8_t)pll_id;\n\n\tparams.ucAction = (uint8_t)cntl->action;\n\n\tif (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result transmitter_control_v4(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V4 params;\n\tuint32_t ref_clk_src_id;\n\tenum connector_id conn_id =\n\t\t\tdal_graphics_object_id_get_connector_id(cntl->connector_obj_id);\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (cntl->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\tcase TRANSMITTER_UNIPHY_B:\n\tcase TRANSMITTER_UNIPHY_C:\n\tcase TRANSMITTER_UNIPHY_D:\n\tcase TRANSMITTER_UNIPHY_E:\n\tcase TRANSMITTER_UNIPHY_F:\n\tcase TRANSMITTER_TRAVIS_LCD:\n\t\tbreak;\n\tdefault:\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tif (!cmd->clock_source_id_to_ref_clk_src(cntl->pll_id, &ref_clk_src_id))\n\t\treturn BP_RESULT_BADINPUT;\n\n\tswitch (cntl->action) {\n\tcase TRANSMITTER_CONTROL_INIT:\n\t{\n\t\tif ((CONNECTOR_ID_DUAL_LINK_DVII == conn_id) ||\n\t\t\t\t(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t \n\t\tparams.usInitInfo =\n\t\t\t\tcpu_to_le16((uint8_t)(cntl->connector_obj_id.id));\n\t}\n\tbreak;\n\tcase TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:\n\t\t \n\t\tparams.asMode.ucLaneSel = (uint8_t)(cntl->lane_select);\n\t\tparams.asMode.ucLaneSet = (uint8_t)(cntl->lane_settings);\n\t\tbreak;\n\tdefault:\n\t\tif ((CONNECTOR_ID_DUAL_LINK_DVII == conn_id) ||\n\t\t\t\t(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))\n\t\t\t \n\t\t\tparams.acConfig.fDualLinkConnector = 1;\n\n\t\t \n\t\tif (LANE_COUNT_FOUR < cntl->lanes_number)\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 20));\n\t\telse {\n\t\t\t \n\t\t\tparams.usPixelClock =\n\t\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\n\tparams.acConfig.fCoherentMode = cntl->coherent;\n\n\tif ((TRANSMITTER_UNIPHY_B == cntl->transmitter)\n\t\t|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)\n\t\t|| (TRANSMITTER_UNIPHY_F == cntl->transmitter))\n\t\t \n\t\tparams.acConfig.ucLinkSel = 1;\n\n\tif (ENGINE_ID_DIGB == cntl->engine_id)\n\t\t \n\t\tparams.acConfig.ucEncoderSel = 1;\n\n\t \n\tparams.acConfig.ucTransmitterSel =\n\t\t(uint8_t)(cmd->transmitter_bp_to_atom(cntl->transmitter));\n\tparams.ucLaneNum = (uint8_t)(cntl->lanes_number);\n\tparams.acConfig.ucRefClkSource = (uint8_t)(ref_clk_src_id);\n\tparams.ucAction = (uint8_t)(cntl->action);\n\n\tif (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result transmitter_control_v1_5(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V1_5 params;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.ucPhyId = cmd->phy_id_to_atom(cntl->transmitter);\n\tparams.ucAction = (uint8_t)cntl->action;\n\tparams.ucLaneNum = (uint8_t)cntl->lanes_number;\n\tparams.ucConnObjId = (uint8_t)cntl->connector_obj_id.id;\n\n\tparams.ucDigMode =\n\t\tcmd->signal_type_to_atom_dig_mode(cntl->signal);\n\tparams.asConfig.ucPhyClkSrcId =\n\t\tcmd->clock_source_id_to_atom_phy_clk_src_id(cntl->pll_id);\n\t \n\tparams.asConfig.ucCoherentMode = cntl->coherent;\n\tparams.asConfig.ucHPDSel =\n\t\tcmd->hpd_sel_to_atom(cntl->hpd_sel);\n\tparams.ucDigEncoderSel =\n\t\tcmd->dig_encoder_sel_to_atom(cntl->engine_id);\n\tparams.ucDPLaneSet = (uint8_t) cntl->lane_settings;\n\tparams.usSymClock = cpu_to_le16((uint16_t) (cntl->pixel_clock / 10));\n\t \n\tif  (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tswitch (cntl->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tparams.usSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.usSymClock) * 30) / 24);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tparams.usSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.usSymClock) * 36) / 24);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tparams.usSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.usSymClock) * 48) / 24);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result transmitter_control_v1_6(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V1_6 params;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.ucPhyId = cmd->phy_id_to_atom(cntl->transmitter);\n\tparams.ucAction = (uint8_t)cntl->action;\n\n\tif (cntl->action == TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS)\n\t\tparams.ucDPLaneSet = (uint8_t)cntl->lane_settings;\n\telse\n\t\tparams.ucDigMode = cmd->signal_type_to_atom_dig_mode(cntl->signal);\n\n\tparams.ucLaneNum = (uint8_t)cntl->lanes_number;\n\tparams.ucHPDSel = cmd->hpd_sel_to_atom(cntl->hpd_sel);\n\tparams.ucDigEncoderSel = cmd->dig_encoder_sel_to_atom(cntl->engine_id);\n\tparams.ucConnObjId = (uint8_t)cntl->connector_obj_id.id;\n\tparams.ulSymClock = cntl->pixel_clock/10;\n\n\t \n\tswitch (cntl->signal) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tswitch (cntl->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tparams.ulSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.ulSymClock) * 30) / 24);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tparams.ulSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.ulSymClock) * 36) / 24);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tparams.ulSymClock =\n\t\t\t\tcpu_to_le16((le16_to_cpu(params.ulSymClock) * 48) / 24);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))\n\t\tresult = BP_RESULT_OK;\n\treturn result;\n}\n\n \n\nstatic enum bp_result set_pixel_clock_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\nstatic enum bp_result set_pixel_clock_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\nstatic enum bp_result set_pixel_clock_v6(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\nstatic enum bp_result set_pixel_clock_v7(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\n\nstatic void init_set_pixel_clock(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(SetPixelClock)) {\n\tcase 3:\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_v3;\n\t\tbreak;\n\tcase 5:\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_v5;\n\t\tbreak;\n\tcase 6:\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_v6;\n\t\tbreak;\n\tcase 7:\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_v7;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have set_pixel_clock for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(SetPixelClock));\n\t\tbp->cmd_tbl.set_pixel_clock = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result set_pixel_clock_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tPIXEL_CLOCK_PARAMETERS_V3 *params;\n\tSET_PIXEL_CLOCK_PS_ALLOCATION allocation;\n\n\tmemset(&allocation, 0, sizeof(allocation));\n\n\tif (CLOCK_SOURCE_ID_PLL1 == bp_params->pll_id)\n\t\tallocation.sPCLKInput.ucPpll = ATOM_PPLL1;\n\telse if (CLOCK_SOURCE_ID_PLL2 == bp_params->pll_id)\n\t\tallocation.sPCLKInput.ucPpll = ATOM_PPLL2;\n\telse\n\t\treturn BP_RESULT_BADINPUT;\n\n\tallocation.sPCLKInput.usRefDiv =\n\t\t\tcpu_to_le16((uint16_t)bp_params->reference_divider);\n\tallocation.sPCLKInput.usFbDiv =\n\t\t\tcpu_to_le16((uint16_t)bp_params->feedback_divider);\n\tallocation.sPCLKInput.ucFracFbDiv =\n\t\t\t(uint8_t)bp_params->fractional_feedback_divider;\n\tallocation.sPCLKInput.ucPostDiv =\n\t\t\t(uint8_t)bp_params->pixel_clock_post_divider;\n\n\t \n\tallocation.sPCLKInput.usPixelClock =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->target_pixel_clock_100hz / 100));\n\n\tparams = (PIXEL_CLOCK_PARAMETERS_V3 *)&allocation.sPCLKInput;\n\tparams->ucTransmitterId =\n\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\t\t\tbp_params->encoder_object_id));\n\tparams->ucEncoderMode =\n\t\t\t(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tbp_params->signal_type, false));\n\n\tif (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)\n\t\tparams->ucMiscInfo |= PIXEL_CLOCK_MISC_FORCE_PROG_PPLL;\n\n\tif (bp_params->flags.USE_E_CLOCK_AS_SOURCE_FOR_D_CLOCK)\n\t\tparams->ucMiscInfo |= PIXEL_CLOCK_MISC_USE_ENGINE_FOR_DISPCLK;\n\n\tif (CONTROLLER_ID_D1 != bp_params->controller_id)\n\t\tparams->ucMiscInfo |= PIXEL_CLOCK_MISC_CRTC_SEL_CRTC2;\n\n\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, allocation))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n#ifndef SET_PIXEL_CLOCK_PS_ALLOCATION_V5\n \ntypedef struct _SET_PIXEL_CLOCK_PS_ALLOCATION_V5 {\n\tPIXEL_CLOCK_PARAMETERS_V5 sPCLKInput;\n\t \n\tENABLE_SPREAD_SPECTRUM_ON_PPLL sReserved;\n} SET_PIXEL_CLOCK_PS_ALLOCATION_V5;\n#endif\n\n#ifndef SET_PIXEL_CLOCK_PS_ALLOCATION_V6\n \ntypedef struct _SET_PIXEL_CLOCK_PS_ALLOCATION_V6 {\n\tPIXEL_CLOCK_PARAMETERS_V6 sPCLKInput;\n\t \n\tENABLE_SPREAD_SPECTRUM_ON_PPLL sReserved;\n} SET_PIXEL_CLOCK_PS_ALLOCATION_V6;\n#endif\n\nstatic enum bp_result set_pixel_clock_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tSET_PIXEL_CLOCK_PS_ALLOCATION_V5 clk;\n\tuint8_t controller_id;\n\tuint32_t pll_id;\n\n\tmemset(&clk, 0, sizeof(clk));\n\n\tif (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)\n\t\t\t&& bp->cmd_helper->controller_id_to_atom(\n\t\t\t\t\tbp_params->controller_id, &controller_id)) {\n\t\tclk.sPCLKInput.ucCRTC = controller_id;\n\t\tclk.sPCLKInput.ucPpll = (uint8_t)pll_id;\n\t\tclk.sPCLKInput.ucRefDiv =\n\t\t\t\t(uint8_t)(bp_params->reference_divider);\n\t\tclk.sPCLKInput.usFbDiv =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->feedback_divider));\n\t\tclk.sPCLKInput.ulFbDivDecFrac =\n\t\t\t\tcpu_to_le32(bp_params->fractional_feedback_divider);\n\t\tclk.sPCLKInput.ucPostDiv =\n\t\t\t\t(uint8_t)(bp_params->pixel_clock_post_divider);\n\t\tclk.sPCLKInput.ucTransmitterID =\n\t\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\t\t\t\tbp_params->encoder_object_id));\n\t\tclk.sPCLKInput.ucEncoderMode =\n\t\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\t\tbp_params->signal_type, false);\n\n\t\t \n\t\tclk.sPCLKInput.usPixelClock =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->target_pixel_clock_100hz / 100));\n\n\t\tif (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)\n\t\t\tclk.sPCLKInput.ucMiscInfo |=\n\t\t\t\t\tPIXEL_CLOCK_MISC_FORCE_PROG_PPLL;\n\n\t\tif (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)\n\t\t\tclk.sPCLKInput.ucMiscInfo |=\n\t\t\t\t\tPIXEL_CLOCK_MISC_REF_DIV_SRC;\n\n\t\t \n\t\tif (bp_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\t\tswitch (bp_params->color_depth) {\n\t\t\tcase TRANSMITTER_COLOR_DEPTH_30:\n\t\t\t\t \n\t\t\t\tclk.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_32BPP;\n\t\t\t\tbreak;\n\t\t\tcase TRANSMITTER_COLOR_DEPTH_36:\n\t\t\t\t \n\t\t\t\tclk.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_30BPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, clk))\n\t\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result set_pixel_clock_v6(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tSET_PIXEL_CLOCK_PS_ALLOCATION_V6 clk;\n\tuint8_t controller_id;\n\tuint32_t pll_id;\n\n\tmemset(&clk, 0, sizeof(clk));\n\n\tif (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)\n\t\t\t&& bp->cmd_helper->controller_id_to_atom(\n\t\t\t\t\tbp_params->controller_id, &controller_id)) {\n\t\t \n\t\tclk.sPCLKInput.ulCrtcPclkFreq.ucCRTC = controller_id;\n\t\tclk.sPCLKInput.ucPpll = (uint8_t) pll_id;\n\t\tclk.sPCLKInput.ucRefDiv =\n\t\t\t\t(uint8_t) bp_params->reference_divider;\n\t\tclk.sPCLKInput.usFbDiv =\n\t\t\t\tcpu_to_le16((uint16_t) bp_params->feedback_divider);\n\t\tclk.sPCLKInput.ulFbDivDecFrac =\n\t\t\t\tcpu_to_le32(bp_params->fractional_feedback_divider);\n\t\tclk.sPCLKInput.ucPostDiv =\n\t\t\t\t(uint8_t) bp_params->pixel_clock_post_divider;\n\t\tclk.sPCLKInput.ucTransmitterID =\n\t\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\t\t\t\tbp_params->encoder_object_id));\n\t\tclk.sPCLKInput.ucEncoderMode =\n\t\t\t\t(uint8_t) bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\t\tbp_params->signal_type, false);\n\n\t\t \n\t\tclk.sPCLKInput.ulCrtcPclkFreq.ulPixelClock =\n\t\t\t\tcpu_to_le32(bp_params->target_pixel_clock_100hz / 100);\n\n\t\tif (bp_params->flags.FORCE_PROGRAMMING_OF_PLL) {\n\t\t\tclk.sPCLKInput.ucMiscInfo |=\n\t\t\t\t\tPIXEL_CLOCK_V6_MISC_FORCE_PROG_PPLL;\n\t\t}\n\n\t\tif (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC) {\n\t\t\tclk.sPCLKInput.ucMiscInfo |=\n\t\t\t\t\tPIXEL_CLOCK_V6_MISC_REF_DIV_SRC;\n\t\t}\n\n\t\t \n\t\tif (bp_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\t\tswitch (bp_params->color_depth) {\n\t\t\tcase TRANSMITTER_COLOR_DEPTH_30:\n\t\t\t\tclk.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6;\n\t\t\t\tbreak;\n\t\t\tcase TRANSMITTER_COLOR_DEPTH_36:\n\t\t\t\tclk.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6;\n\t\t\t\tbreak;\n\t\t\tcase TRANSMITTER_COLOR_DEPTH_48:\n\t\t\t\tclk.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_48BPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, clk))\n\t\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result set_pixel_clock_v7(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tPIXEL_CLOCK_PARAMETERS_V7 clk;\n\tuint8_t controller_id;\n\tuint32_t pll_id;\n\n\tmemset(&clk, 0, sizeof(clk));\n\n\tif (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)\n\t\t\t&& bp->cmd_helper->controller_id_to_atom(bp_params->controller_id, &controller_id)) {\n\t\t \n\t\tclk.ucCRTC = controller_id;\n\t\tclk.ucPpll = (uint8_t) pll_id;\n\t\tclk.ucTransmitterID = bp->cmd_helper->encoder_id_to_atom(dal_graphics_object_id_get_encoder_id(bp_params->encoder_object_id));\n\t\tclk.ucEncoderMode = (uint8_t) bp->cmd_helper->encoder_mode_bp_to_atom(bp_params->signal_type, false);\n\n\t\tclk.ulPixelClock = cpu_to_le32(bp_params->target_pixel_clock_100hz);\n\n\t\tclk.ucDeepColorRatio = (uint8_t) bp->cmd_helper->transmitter_color_depth_to_atom(bp_params->color_depth);\n\n\t\tif (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_FORCE_PROG_PPLL;\n\n\t\tif (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC;\n\n\t\tif (bp_params->flags.PROGRAM_PHY_PLL_ONLY)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_PROG_PHYPLL;\n\n\t\tif (bp_params->flags.SUPPORT_YUV_420)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_YUV420_MODE;\n\n\t\tif (bp_params->flags.SET_XTALIN_REF_SRC)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_XTALIN;\n\n\t\tif (bp_params->flags.SET_GENLOCK_REF_DIV_SRC)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_GENLK;\n\n\t\tif (bp_params->signal_type == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\tclk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_DVI_DUALLINK_EN;\n\n\t\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, clk))\n\t\t\tresult = BP_RESULT_OK;\n\t}\n\treturn result;\n}\n\n \nstatic enum bp_result enable_spread_spectrum_on_ppll_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable);\nstatic enum bp_result enable_spread_spectrum_on_ppll_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable);\nstatic enum bp_result enable_spread_spectrum_on_ppll_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable);\n\nstatic void init_enable_spread_spectrum_on_ppll(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(EnableSpreadSpectrumOnPPLL)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_spread_spectrum_on_ppll =\n\t\t\t\tenable_spread_spectrum_on_ppll_v1;\n\t\tbreak;\n\tcase 2:\n\t\tbp->cmd_tbl.enable_spread_spectrum_on_ppll =\n\t\t\t\tenable_spread_spectrum_on_ppll_v2;\n\t\tbreak;\n\tcase 3:\n\t\tbp->cmd_tbl.enable_spread_spectrum_on_ppll =\n\t\t\t\tenable_spread_spectrum_on_ppll_v3;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have enable_spread_spectrum_on_ppll for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(EnableSpreadSpectrumOnPPLL));\n\t\tbp->cmd_tbl.enable_spread_spectrum_on_ppll = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result enable_spread_spectrum_on_ppll_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif ((enable == true) && (bp_params->percentage > 0))\n\t\tparams.ucEnable = ATOM_ENABLE;\n\telse\n\t\tparams.ucEnable = ATOM_DISABLE;\n\n\tparams.usSpreadSpectrumPercentage =\n\t\t\tcpu_to_le16((uint16_t)bp_params->percentage);\n\tparams.ucSpreadSpectrumStep =\n\t\t\t(uint8_t)bp_params->ver1.step;\n\tparams.ucSpreadSpectrumDelay =\n\t\t\t(uint8_t)bp_params->ver1.delay;\n\t \n\tparams.ucSpreadSpectrumRange =\n\t\t\t(uint8_t)(bp_params->ver1.range / 10000);\n\n\tif (bp_params->flags.EXTERNAL_SS)\n\t\tparams.ucSpreadSpectrumType |= ATOM_EXTERNAL_SS_MASK;\n\n\tif (bp_params->flags.CENTER_SPREAD)\n\t\tparams.ucSpreadSpectrumType |= ATOM_SS_CENTRE_SPREAD_MODE;\n\n\tif (bp_params->pll_id == CLOCK_SOURCE_ID_PLL1)\n\t\tparams.ucPpll = ATOM_PPLL1;\n\telse if (bp_params->pll_id == CLOCK_SOURCE_ID_PLL2)\n\t\tparams.ucPpll = ATOM_PPLL2;\n\telse\n\t\tBREAK_TO_DEBUGGER();  \n\n\tif (EXEC_BIOS_CMD_TABLE(EnableSpreadSpectrumOnPPLL, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result enable_spread_spectrum_on_ppll_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V2 params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (bp_params->pll_id == CLOCK_SOURCE_ID_PLL1)\n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V2_P1PLL;\n\telse if (bp_params->pll_id == CLOCK_SOURCE_ID_PLL2)\n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V2_P2PLL;\n\telse\n\t\tBREAK_TO_DEBUGGER();  \n\n\tif ((enable == true) && (bp_params->percentage > 0)) {\n\t\tparams.ucEnable = ATOM_ENABLE;\n\n\t\tparams.usSpreadSpectrumPercentage =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->percentage));\n\t\tparams.usSpreadSpectrumStep =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));\n\n\t\tif (bp_params->flags.EXTERNAL_SS)\n\t\t\tparams.ucSpreadSpectrumType |=\n\t\t\t\t\tATOM_PPLL_SS_TYPE_V2_EXT_SPREAD;\n\n\t\tif (bp_params->flags.CENTER_SPREAD)\n\t\t\tparams.ucSpreadSpectrumType |=\n\t\t\t\t\tATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD;\n\n\t\t \n\t\tparams.usSpreadSpectrumAmount = cpu_to_le16((uint16_t)(\n\t\t\t\t((bp_params->ds.feedback_amount <<\n\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V2_FBDIV_SHIFT) &\n\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK) |\n\t\t\t\t\t\t((bp_params->ds.nfrac_amount <<\n\t\t\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &\n\t\t\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK)));\n\t} else\n\t\tparams.ucEnable = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(EnableSpreadSpectrumOnPPLL, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result enable_spread_spectrum_on_ppll_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V3 params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (bp_params->pll_id) {\n\tcase CLOCK_SOURCE_ID_PLL0:\n\t\t \n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V3_DCPLL;\n\t\tbreak;\n\tcase CLOCK_SOURCE_ID_PLL1:\n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V3_P1PLL;\n\t\tbreak;\n\n\tcase CLOCK_SOURCE_ID_PLL2:\n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V3_P2PLL;\n\t\tbreak;\n\n\tcase CLOCK_SOURCE_ID_DCPLL:\n\t\tparams.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V3_DCPLL;\n\t\tbreak;\n\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\t \n\t\treturn result;\n\t}\n\n\tif (enable == true) {\n\t\tparams.ucEnable = ATOM_ENABLE;\n\n\t\tparams.usSpreadSpectrumAmountFrac =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->ds_frac_amount));\n\t\tparams.usSpreadSpectrumStep =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));\n\n\t\tif (bp_params->flags.EXTERNAL_SS)\n\t\t\tparams.ucSpreadSpectrumType |=\n\t\t\t\t\tATOM_PPLL_SS_TYPE_V3_EXT_SPREAD;\n\t\tif (bp_params->flags.CENTER_SPREAD)\n\t\t\tparams.ucSpreadSpectrumType |=\n\t\t\t\t\tATOM_PPLL_SS_TYPE_V3_CENTRE_SPREAD;\n\n\t\t \n\t\tparams.usSpreadSpectrumAmount = cpu_to_le16((uint16_t)(\n\t\t\t\t((bp_params->ds.feedback_amount <<\n\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V3_FBDIV_SHIFT) &\n\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V3_FBDIV_MASK) |\n\t\t\t\t\t\t((bp_params->ds.nfrac_amount <<\n\t\t\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V3_NFRAC_SHIFT) &\n\t\t\t\t\t\t\t\tATOM_PPLL_SS_AMOUNT_V3_NFRAC_MASK)));\n\t} else\n\t\tparams.ucEnable = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(EnableSpreadSpectrumOnPPLL, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result adjust_display_pll_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_adjust_pixel_clock_parameters *bp_params);\nstatic enum bp_result adjust_display_pll_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_adjust_pixel_clock_parameters *bp_params);\n\nstatic void init_adjust_display_pll(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(AdjustDisplayPll)) {\n\tcase 2:\n\t\tbp->cmd_tbl.adjust_display_pll = adjust_display_pll_v2;\n\t\tbreak;\n\tcase 3:\n\t\tbp->cmd_tbl.adjust_display_pll = adjust_display_pll_v3;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have adjust_display_pll for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(AdjustDisplayPll));\n\t\tbp->cmd_tbl.adjust_display_pll = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result adjust_display_pll_v2(\n\tstruct bios_parser *bp,\n\tstruct bp_adjust_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION params = { 0 };\n\n\t \n\tuint32_t pixel_clock_10KHz_in = bp_params->pixel_clock / 10;\n\n\tparams.usPixelClock = cpu_to_le16((uint16_t)(pixel_clock_10KHz_in));\n\tparams.ucTransmitterID =\n\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\t\t\tbp_params->encoder_object_id));\n\tparams.ucEncodeMode =\n\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tbp_params->signal_type, false);\n\n\tif (EXEC_BIOS_CMD_TABLE(AdjustDisplayPll, params)) {\n\t\t \n\t\tuint64_t pixel_clk_10_khz_out =\n\t\t\t\t(uint64_t)le16_to_cpu(params.usPixelClock);\n\t\tuint64_t pixel_clk = (uint64_t)bp_params->pixel_clock;\n\n\t\tif (pixel_clock_10KHz_in != 0) {\n\t\t\tbp_params->adjusted_pixel_clock =\n\t\t\t\t\tdiv_u64(pixel_clk * pixel_clk_10_khz_out,\n\t\t\t\t\t\t\tpixel_clock_10KHz_in);\n\t\t} else {\n\t\t\tbp_params->adjusted_pixel_clock = 0;\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\n\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result adjust_display_pll_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_adjust_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 params;\n\tuint32_t pixel_clk_10_kHz_in = bp_params->pixel_clock / 10;\n\n\tmemset(&params, 0, sizeof(params));\n\n\t \n\tparams.sInput.usPixelClock = cpu_to_le16((uint16_t)pixel_clk_10_kHz_in);\n\tparams.sInput.ucTransmitterID =\n\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\t\t\tbp_params->encoder_object_id));\n\tparams.sInput.ucEncodeMode =\n\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tbp_params->signal_type, false);\n\n\tif (bp_params->ss_enable == true)\n\t\tparams.sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;\n\n\tif (bp_params->signal_type == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\tparams.sInput.ucDispPllConfig |= DISPPLL_CONFIG_DUAL_LINK;\n\n\tif (EXEC_BIOS_CMD_TABLE(AdjustDisplayPll, params)) {\n\t\t \n\t\tuint64_t pixel_clk_10_khz_out =\n\t\t\t\t(uint64_t)le32_to_cpu(params.sOutput.ulDispPllFreq);\n\t\tuint64_t pixel_clk = (uint64_t)bp_params->pixel_clock;\n\n\t\tif (pixel_clk_10_kHz_in != 0) {\n\t\t\tbp_params->adjusted_pixel_clock =\n\t\t\t\t\tdiv_u64(pixel_clk * pixel_clk_10_khz_out,\n\t\t\t\t\t\t\tpixel_clk_10_kHz_in);\n\t\t} else {\n\t\t\tbp_params->adjusted_pixel_clock = 0;\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\n\t\tbp_params->reference_divider = params.sOutput.ucRefDiv;\n\t\tbp_params->pixel_clock_post_divider = params.sOutput.ucPostDiv;\n\n\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result dac1_encoder_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable,\n\tuint32_t pixel_clock,\n\tuint8_t dac_standard);\nstatic enum bp_result dac2_encoder_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable,\n\tuint32_t pixel_clock,\n\tuint8_t dac_standard);\n\nstatic void init_dac_encoder_control(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(DAC1EncoderControl)) {\n\tcase 1:\n\t\tbp->cmd_tbl.dac1_encoder_control = dac1_encoder_control_v1;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.dac1_encoder_control = NULL;\n\t\tbreak;\n\t}\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(DAC2EncoderControl)) {\n\tcase 1:\n\t\tbp->cmd_tbl.dac2_encoder_control = dac2_encoder_control_v1;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.dac2_encoder_control = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic void dac_encoder_control_prepare_params(\n\tDAC_ENCODER_CONTROL_PS_ALLOCATION *params,\n\tbool enable,\n\tuint32_t pixel_clock,\n\tuint8_t dac_standard)\n{\n\tparams->ucDacStandard = dac_standard;\n\tif (enable)\n\t\tparams->ucAction = ATOM_ENABLE;\n\telse\n\t\tparams->ucAction = ATOM_DISABLE;\n\n\t \n\tparams->usPixelClock = cpu_to_le16((uint16_t)(pixel_clock / 10));\n}\n\nstatic enum bp_result dac1_encoder_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable,\n\tuint32_t pixel_clock,\n\tuint8_t dac_standard)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDAC_ENCODER_CONTROL_PS_ALLOCATION params;\n\n\tdac_encoder_control_prepare_params(\n\t\t&params,\n\t\tenable,\n\t\tpixel_clock,\n\t\tdac_standard);\n\n\tif (EXEC_BIOS_CMD_TABLE(DAC1EncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result dac2_encoder_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable,\n\tuint32_t pixel_clock,\n\tuint8_t dac_standard)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDAC_ENCODER_CONTROL_PS_ALLOCATION params;\n\n\tdac_encoder_control_prepare_params(\n\t\t&params,\n\t\tenable,\n\t\tpixel_clock,\n\t\tdac_standard);\n\n\tif (EXEC_BIOS_CMD_TABLE(DAC2EncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \nstatic enum bp_result dac1_output_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable);\nstatic enum bp_result dac2_output_control_v1(\n\tstruct bios_parser *bp,\n\tbool enable);\n\nstatic void init_dac_output_control(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(DAC1OutputControl)) {\n\tcase 1:\n\t\tbp->cmd_tbl.dac1_output_control = dac1_output_control_v1;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.dac1_output_control = NULL;\n\t\tbreak;\n\t}\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(DAC2OutputControl)) {\n\tcase 1:\n\t\tbp->cmd_tbl.dac2_output_control = dac2_output_control_v1;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.dac2_output_control = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result dac1_output_control_v1(\n\tstruct bios_parser *bp, bool enable)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION params;\n\n\tif (enable)\n\t\tparams.ucAction = ATOM_ENABLE;\n\telse\n\t\tparams.ucAction = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(DAC1OutputControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result dac2_output_control_v1(\n\tstruct bios_parser *bp, bool enable)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION params;\n\n\tif (enable)\n\t\tparams.ucAction = ATOM_ENABLE;\n\telse\n\t\tparams.ucAction = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(DAC2OutputControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result set_crtc_using_dtd_timing_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params);\nstatic enum bp_result set_crtc_timing_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params);\n\nstatic void init_set_crtc_timing(struct bios_parser *bp)\n{\n\tuint32_t dtd_version =\n\t\t\tBIOS_CMD_TABLE_PARA_REVISION(SetCRTC_UsingDTDTiming);\n\tif (dtd_version > 2)\n\t\tswitch (dtd_version) {\n\t\tcase 3:\n\t\t\tbp->cmd_tbl.set_crtc_timing =\n\t\t\t\t\tset_crtc_using_dtd_timing_v3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdm_output_to_console(\"Don't have set_crtc_timing for dtd v%d\\n\",\n\t\t\t\t dtd_version);\n\t\t\tbp->cmd_tbl.set_crtc_timing = NULL;\n\t\t\tbreak;\n\t\t}\n\telse\n\t\tswitch (BIOS_CMD_TABLE_PARA_REVISION(SetCRTC_Timing)) {\n\t\tcase 1:\n\t\t\tbp->cmd_tbl.set_crtc_timing = set_crtc_timing_v1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdm_output_to_console(\"Don't have set_crtc_timing for v%d\\n\",\n\t\t\t\t BIOS_CMD_TABLE_PARA_REVISION(SetCRTC_Timing));\n\t\t\tbp->cmd_tbl.set_crtc_timing = NULL;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic enum bp_result set_crtc_timing_v1(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tSET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION params = {0};\n\tuint8_t atom_controller_id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(\n\t\t\tbp_params->controller_id, &atom_controller_id))\n\t\tparams.ucCRTC = atom_controller_id;\n\n\tparams.usH_Total = cpu_to_le16((uint16_t)(bp_params->h_total));\n\tparams.usH_Disp = cpu_to_le16((uint16_t)(bp_params->h_addressable));\n\tparams.usH_SyncStart = cpu_to_le16((uint16_t)(bp_params->h_sync_start));\n\tparams.usH_SyncWidth = cpu_to_le16((uint16_t)(bp_params->h_sync_width));\n\tparams.usV_Total = cpu_to_le16((uint16_t)(bp_params->v_total));\n\tparams.usV_Disp = cpu_to_le16((uint16_t)(bp_params->v_addressable));\n\tparams.usV_SyncStart =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_sync_start));\n\tparams.usV_SyncWidth =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_sync_width));\n\n\t \n\tparams.ucOverscanRight = (uint8_t)bp_params->h_overscan_right;\n\tparams.ucOverscanLeft = (uint8_t)bp_params->h_overscan_left;\n\tparams.ucOverscanBottom = (uint8_t)bp_params->v_overscan_bottom;\n\tparams.ucOverscanTop = (uint8_t)bp_params->v_overscan_top;\n\n\tif (0 == bp_params->flags.HSYNC_POSITIVE_POLARITY)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);\n\n\tif (0 == bp_params->flags.VSYNC_POSITIVE_POLARITY)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);\n\n\tif (bp_params->flags.INTERLACE) {\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);\n\n\t\t \n\t\t \n\t\tparams.usV_SyncStart =\n\t\t\t\tcpu_to_le16((uint16_t)(bp_params->v_sync_start + 1));\n\t}\n\n\tif (bp_params->flags.HORZ_COUNT_BY_TWO)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);\n\n\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_Timing, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result set_crtc_using_dtd_timing_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tSET_CRTC_USING_DTD_TIMING_PARAMETERS params = {0};\n\tuint8_t atom_controller_id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(\n\t\t\tbp_params->controller_id, &atom_controller_id))\n\t\tparams.ucCRTC = atom_controller_id;\n\n\t \n\tparams.usH_Size = cpu_to_le16((uint16_t)bp_params->h_addressable);\n\t \n\tparams.usH_Blanking_Time =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->h_total - bp_params->h_addressable));\n\t \n\tparams.usV_Size = cpu_to_le16((uint16_t)bp_params->v_addressable);\n\t \n\tparams.usV_Blanking_Time =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_total - bp_params->v_addressable));\n\t \n\tparams.usH_SyncOffset =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->h_sync_start - bp_params->h_addressable));\n\tparams.usH_SyncWidth = cpu_to_le16((uint16_t)bp_params->h_sync_width);\n\t \n\tparams.usV_SyncOffset =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_sync_start - bp_params->v_addressable));\n\tparams.usV_SyncWidth = cpu_to_le16((uint16_t)bp_params->v_sync_width);\n\n\t \n\n\tif (0 == bp_params->flags.HSYNC_POSITIVE_POLARITY)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);\n\n\tif (0 == bp_params->flags.VSYNC_POSITIVE_POLARITY)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);\n\n\tif (bp_params->flags.INTERLACE)\t{\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);\n\n\t\t \n\t\t{\n\t\t\t \n\t\t\tle16_add_cpu(&params.usV_SyncOffset, 1);\n\t\t}\n\t}\n\n\tif (bp_params->flags.HORZ_COUNT_BY_TWO)\n\t\tparams.susModeMiscInfo.usAccess =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);\n\n\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_UsingDTDTiming, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result enable_crtc_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable);\n\nstatic void init_enable_crtc(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(EnableCRTC)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_crtc = enable_crtc_v1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have enable_crtc for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(EnableCRTC));\n\t\tbp->cmd_tbl.enable_crtc = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result enable_crtc_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable)\n{\n\tbool result = BP_RESULT_FAILURE;\n\tENABLE_CRTC_PARAMETERS params = {0};\n\tuint8_t id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(controller_id, &id))\n\t\tparams.ucCRTC = id;\n\telse\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (enable)\n\t\tparams.ucEnable = ATOM_ENABLE;\n\telse\n\t\tparams.ucEnable = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(EnableCRTC, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result enable_crtc_mem_req_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable);\n\nstatic void init_enable_crtc_mem_req(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(EnableCRTCMemReq)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_crtc_mem_req = enable_crtc_mem_req_v1;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.enable_crtc_mem_req = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result enable_crtc_mem_req_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable)\n{\n\tbool result = BP_RESULT_BADINPUT;\n\tENABLE_CRTC_PARAMETERS params = {0};\n\tuint8_t id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(controller_id, &id)) {\n\t\tparams.ucCRTC = id;\n\n\t\tif (enable)\n\t\t\tparams.ucEnable = ATOM_ENABLE;\n\t\telse\n\t\t\tparams.ucEnable = ATOM_DISABLE;\n\n\t\tif (EXEC_BIOS_CMD_TABLE(EnableCRTCMemReq, params))\n\t\t\tresult = BP_RESULT_OK;\n\t\telse\n\t\t\tresult = BP_RESULT_FAILURE;\n\t}\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result program_clock_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\nstatic enum bp_result program_clock_v6(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\n\nstatic void init_program_clock(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(SetPixelClock)) {\n\tcase 5:\n\t\tbp->cmd_tbl.program_clock = program_clock_v5;\n\t\tbreak;\n\tcase 6:\n\t\tbp->cmd_tbl.program_clock = program_clock_v6;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have program_clock for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(SetPixelClock));\n\t\tbp->cmd_tbl.program_clock = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result program_clock_v5(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tSET_PIXEL_CLOCK_PS_ALLOCATION_V5 params;\n\tuint32_t atom_pll_id;\n\n\tmemset(&params, 0, sizeof(params));\n\tif (!bp->cmd_helper->clock_source_id_to_atom(\n\t\t\tbp_params->pll_id, &atom_pll_id)) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\t \n\tparams.sPCLKInput.ucPpll = (uint8_t) atom_pll_id;\n\tparams.sPCLKInput.usPixelClock =\n\t\t\tcpu_to_le16((uint16_t) (bp_params->target_pixel_clock_100hz / 100));\n\tparams.sPCLKInput.ucCRTC = (uint8_t) ATOM_CRTC_INVALID;\n\n\tif (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)\n\t\tparams.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;\n\n\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result program_clock_v6(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tSET_PIXEL_CLOCK_PS_ALLOCATION_V6 params;\n\tuint32_t atom_pll_id;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!bp->cmd_helper->clock_source_id_to_atom(\n\t\t\tbp_params->pll_id, &atom_pll_id)) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\t \n\tparams.sPCLKInput.ucPpll = (uint8_t)atom_pll_id;\n\tparams.sPCLKInput.ulDispEngClkFreq =\n\t\t\tcpu_to_le32(bp_params->target_pixel_clock_100hz / 100);\n\n\tif (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)\n\t\tparams.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;\n\n\tif (bp_params->flags.SET_DISPCLK_DFS_BYPASS)\n\t\tparams.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_DPREFCLK_BYPASS;\n\n\tif (EXEC_BIOS_CMD_TABLE(SetPixelClock, params)) {\n\t\t \n\t\tbp_params->dfs_bypass_display_clock =\n\t\t\t\t(uint32_t)(le32_to_cpu(params.sPCLKInput.ulDispEngClkFreq) * 10);\n\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result external_encoder_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_external_encoder_control *cntl);\n\nstatic void init_external_encoder_control(\n\tstruct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(ExternalEncoderControl)) {\n\tcase 3:\n\t\tbp->cmd_tbl.external_encoder_control =\n\t\t\t\texternal_encoder_control_v3;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.external_encoder_control = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result external_encoder_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_external_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\t \n\tEXTERNAL_ENCODER_CONTROL_PS_ALLOCATION_V3 params;\n\tEXTERNAL_ENCODER_CONTROL_PARAMETERS_V3 *cntl_params;\n\tstruct graphics_object_id encoder;\n\tbool is_input_signal_dp = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tcntl_params = &params.sExtEncoder;\n\n\tencoder = cntl->encoder_id;\n\n\t \n\tswitch (dal_graphics_object_id_get_encoder_id(encoder)) {\n\tcase ENCODER_ID_EXTERNAL_NUTMEG:\n\tcase ENCODER_ID_EXTERNAL_TRAVIS:\n\t\tis_input_signal_dp = true;\n\t\tbreak;\n\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\t \n\tcntl_params->ucConfig = (uint8_t)((encoder.enum_id - 1) << 4);\n\n\tswitch (cntl->action) {\n\tcase EXTERNAL_ENCODER_CONTROL_INIT:\n\t\t \n\t\tcntl_params->usConnectorId =\n\t\t\t\tcpu_to_le16((uint16_t)cntl->connector_obj_id.id);\n\t\tbreak;\n\tcase EXTERNAL_ENCODER_CONTROL_SETUP:\n\t\t \n\t\tcntl_params->usPixelClock =\n\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\t\t \n\t\tcntl_params->ucEncoderMode =\n\t\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\t\tcntl->signal, false);\n\n\t\tif (is_input_signal_dp) {\n\t\t\t \n\t\t\tif (LINK_RATE_HIGH == cntl->link_rate)\n\t\t\t\tcntl_params->ucConfig |= 1;\n\t\t\t \n\t\t\tcntl_params->ucBitPerColor =\n\t\t\t\t\t(uint8_t)(cntl->color_depth);\n\t\t}\n\t\t \n\t\tcntl_params->ucLaneNum = (uint8_t)(cntl->lanes_number);\n\t\tbreak;\n\tcase EXTERNAL_ENCODER_CONTROL_ENABLE:\n\t\tcntl_params->usPixelClock =\n\t\t\t\tcpu_to_le16((uint16_t)(cntl->pixel_clock / 10));\n\t\tcntl_params->ucEncoderMode =\n\t\t\t\t(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\t\tcntl->signal, false);\n\t\tcntl_params->ucLaneNum = (uint8_t)cntl->lanes_number;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcntl_params->ucAction = (uint8_t)cntl->action;\n\n\tif (EXEC_BIOS_CMD_TABLE(ExternalEncoderControl, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result enable_disp_power_gating_v2_1(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action);\n\nstatic void init_enable_disp_power_gating(\n\tstruct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(EnableDispPowerGating)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_disp_power_gating =\n\t\t\t\tenable_disp_power_gating_v2_1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't enable_disp_power_gating enable_crtc for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(EnableDispPowerGating));\n\t\tbp->cmd_tbl.enable_disp_power_gating = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result enable_disp_power_gating_v2_1(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tENABLE_DISP_POWER_GATING_PS_ALLOCATION params = {0};\n\tuint8_t atom_crtc_id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(crtc_id, &atom_crtc_id))\n\t\tparams.ucDispPipeId = atom_crtc_id;\n\telse\n\t\treturn BP_RESULT_BADINPUT;\n\n\tparams.ucEnable =\n\t\t\tbp->cmd_helper->disp_power_gating_action_to_atom(action);\n\n\tif (EXEC_BIOS_CMD_TABLE(EnableDispPowerGating, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \nstatic enum bp_result set_dce_clock_v2_1(\n\tstruct bios_parser *bp,\n\tstruct bp_set_dce_clock_parameters *bp_params);\n\nstatic void init_set_dce_clock(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(SetDCEClock)) {\n\tcase 1:\n\t\tbp->cmd_tbl.set_dce_clock = set_dce_clock_v2_1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have set_dce_clock for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(SetDCEClock));\n\t\tbp->cmd_tbl.set_dce_clock = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result set_dce_clock_v2_1(\n\tstruct bios_parser *bp,\n\tstruct bp_set_dce_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tSET_DCE_CLOCK_PS_ALLOCATION_V2_1 params;\n\tuint32_t atom_pll_id;\n\tuint32_t atom_clock_type;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!cmd->clock_source_id_to_atom(bp_params->pll_id, &atom_pll_id) ||\n\t\t\t!cmd->dc_clock_type_to_atom(bp_params->clock_type, &atom_clock_type))\n\t\treturn BP_RESULT_BADINPUT;\n\n\tparams.asParam.ucDCEClkSrc  = atom_pll_id;\n\tparams.asParam.ucDCEClkType = atom_clock_type;\n\n\tif (bp_params->clock_type == DCECLOCK_TYPE_DPREFCLK) {\n\t\tif (bp_params->flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENLK;\n\n\t\tif (bp_params->flags.USE_PCIE_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_PCIE;\n\n\t\tif (bp_params->flags.USE_XTALIN_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_XTALIN;\n\n\t\tif (bp_params->flags.USE_GENERICA_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENERICA;\n\t}\n\telse\n\t\t \n\t\t \n\t\tparams.asParam.ulDCEClkFreq = cpu_to_le32(bp_params->target_clock_frequency / 10);\n\n\tif (EXEC_BIOS_CMD_TABLE(SetDCEClock, params)) {\n\t\t \n\t\tbp_params->target_clock_frequency = le32_to_cpu(params.asParam.ulDCEClkFreq) * 10;\n\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}