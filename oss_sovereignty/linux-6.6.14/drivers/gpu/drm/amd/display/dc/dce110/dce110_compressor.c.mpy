{
  "module_name": "dce110_compressor.c",
  "hash_id": "21209bf807569be4feca4c4067d1d825548e6edfa13f405967412db23695b1ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n#include \"gmc/gmc_8_2_d.h\"\n\n#include \"include/logger_interface.h\"\n\n#include \"dce110_compressor.h\"\n\n#define DC_LOGGER \\\n\t\tcp110->base.ctx->logger\n#define DCP_REG(reg)\\\n\t(reg + cp110->offsets.dcp_offset)\n#define DMIF_REG(reg)\\\n\t(reg + cp110->offsets.dmif_offset)\n\nstatic const struct dce110_compressor_reg_offsets reg_offsets[] = {\n{\n\t.dcp_offset = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG0_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n},\n{\n\t.dcp_offset = (mmDCP1_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG1_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n},\n{\n\t.dcp_offset = (mmDCP2_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG2_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n}\n};\n\nstatic uint32_t align_to_chunks_number_per_line(uint32_t pixels)\n{\n\treturn 256 * ((pixels + 255) / 256);\n}\n\nstatic void reset_lb_on_vblank(struct compressor *compressor, uint32_t crtc_inst)\n{\n\tuint32_t value;\n\tuint32_t frame_count;\n\tuint32_t status_pos;\n\tuint32_t retry = 0;\n\tstruct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);\n\n\tcp110->offsets = reg_offsets[crtc_inst];\n\n\tstatus_pos = dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_POSITION));\n\n\n\t \n\tif (status_pos != dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_POSITION))) {\n\t\t \n\t\tvalue = dm_read_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL));\n\t\tset_reg_field_value(value, 3, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);\n\t\tset_reg_field_value(value, 1, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);\n\t\tdm_write_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL), value);\n\n\t\tframe_count = dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_FRAME_COUNT));\n\n\n\t\tfor (retry = 10000; retry > 0; retry--) {\n\t\t\tif (frame_count != dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_FRAME_COUNT)))\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\t\tif (!retry)\n\t\t\tdm_error(\"Frame count did not increase for 100ms.\\n\");\n\n\t\t \n\t\tvalue = dm_read_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL));\n\t\tset_reg_field_value(value, 2, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);\n\t\tset_reg_field_value(value, 0, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);\n\t\tdm_write_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL), value);\n\t}\n}\n\nstatic void wait_for_fbc_state_changed(\n\tstruct dce110_compressor *cp110,\n\tbool enabled)\n{\n\tuint32_t counter = 0;\n\tuint32_t addr = mmFBC_STATUS;\n\tuint32_t value;\n\n\twhile (counter < 1000) {\n\t\tvalue = dm_read_reg(cp110->base.ctx, addr);\n\t\tif (get_reg_field_value(\n\t\t\tvalue,\n\t\t\tFBC_STATUS,\n\t\t\tFBC_ENABLE_STATUS) == enabled)\n\t\t\tbreak;\n\t\tudelay(100);\n\t\tcounter++;\n\t}\n\n\tif (counter == 1000) {\n\t\tDC_LOG_WARNING(\"%s: wait counter exceeded, changes to HW not applied\",\n\t\t\t__func__);\n\t} else {\n\t\tDC_LOG_SYNC(\"FBC status changed to %d\", enabled);\n\t}\n\n\n}\n\nvoid dce110_compressor_power_up_fbc(struct compressor *compressor)\n{\n\tuint32_t value;\n\tuint32_t addr;\n\n\taddr = mmFBC_CNTL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\tset_reg_field_value(value, 1, FBC_CNTL, FBC_EN);\n\tset_reg_field_value(value, 2, FBC_CNTL, FBC_COHERENCY_MODE);\n\tif (compressor->options.bits.CLK_GATING_DISABLED == 1) {\n\t\t \n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tFBC_CNTL,\n\t\t\tFBC_COMP_CLK_GATE_EN);\n\t}\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\taddr = mmFBC_COMP_MODE;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_RLE_EN);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_DPCM4_RGB_EN);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_IND_EN);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\taddr = mmFBC_COMP_CNTL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 1, FBC_COMP_CNTL, FBC_DEPTH_RGB08_EN);\n\tdm_write_reg(compressor->ctx, addr, value);\n\t \n\t \n\t \n\t \n\tset_reg_field_value(value, 0xF, FBC_COMP_CNTL, FBC_MIN_COMPRESSION);\n\tdm_write_reg(compressor->ctx, addr, value);\n\tcompressor->min_compress_ratio = FBC_COMPRESS_RATIO_1TO1;\n\n\tvalue = 0;\n\tdm_write_reg(compressor->ctx, mmFBC_IND_LUT0, value);\n\n\tvalue = 0xFFFFFF;\n\tdm_write_reg(compressor->ctx, mmFBC_IND_LUT1, value);\n}\n\nvoid dce110_compressor_enable_fbc(\n\tstruct compressor *compressor,\n\tstruct compr_addr_and_pitch_params *params)\n{\n\tstruct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);\n\n\tif (compressor->options.bits.FBC_SUPPORT &&\n\t\t(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL))) {\n\n\t\tuint32_t addr;\n\t\tuint32_t value, misc_value;\n\n\t\taddr = mmFBC_CNTL;\n\t\tvalue = dm_read_reg(compressor->ctx, addr);\n\t\tset_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\t \n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tparams->inst,\n\t\t\tFBC_CNTL, FBC_SRC_SEL);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\n\t\t \n\t\tcompressor->is_enabled = true;\n\t\t \n\t\tcompressor->attached_inst = params->inst + CONTROLLER_ID_D0;\n\n\t\t \n\t\tset_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\n\t\t \n\t\tmisc_value = dm_read_reg(compressor->ctx, mmFBC_MISC);\n\n\t\tset_reg_field_value(misc_value, 1,\n\t\t\t\tFBC_MISC, FBC_INVALIDATE_ON_ERROR);\n\t\tset_reg_field_value(misc_value, 1,\n\t\t\t\tFBC_MISC, FBC_DECOMPRESS_ERROR_CLEAR);\n\t\tset_reg_field_value(misc_value, 0x14,\n\t\t\t\tFBC_MISC, FBC_SLOW_REQ_INTERVAL);\n\n\t\tdm_write_reg(compressor->ctx, mmFBC_MISC, misc_value);\n\n\t\t \n\t\tset_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\n\t\twait_for_fbc_state_changed(cp110, true);\n\t}\n}\n\nvoid dce110_compressor_disable_fbc(struct compressor *compressor)\n{\n\tstruct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);\n\tuint32_t crtc_inst = 0;\n\n\tif (compressor->options.bits.FBC_SUPPORT) {\n\t\tif (dce110_compressor_is_fbc_enabled_in_hw(compressor, &crtc_inst)) {\n\t\t\tuint32_t reg_data;\n\t\t\t \n\t\t\treg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);\n\t\t\tset_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\t\tdm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);\n\n\t\t\t \n\t\t\tcompressor->attached_inst = 0;\n\t\t\tcompressor->is_enabled = false;\n\n\t\t\twait_for_fbc_state_changed(cp110, false);\n\t\t}\n\n\t\t \n\t\tif (crtc_inst > CONTROLLER_ID_UNDEFINED && crtc_inst < CONTROLLER_ID_D3)\n\t\t\treset_lb_on_vblank(compressor,\n\t\t\t\t\tcrtc_inst - CONTROLLER_ID_D0);\n\t}\n}\n\nbool dce110_compressor_is_fbc_enabled_in_hw(\n\tstruct compressor *compressor,\n\tuint32_t *inst)\n{\n\t \n\tuint32_t value;\n\n\tvalue = dm_read_reg(compressor->ctx, mmFBC_STATUS);\n\tif (get_reg_field_value(value, FBC_STATUS, FBC_ENABLE_STATUS)) {\n\t\tif (inst != NULL)\n\t\t\t*inst = compressor->attached_inst;\n\t\treturn true;\n\t}\n\n\tvalue = dm_read_reg(compressor->ctx, mmFBC_MISC);\n\tif (get_reg_field_value(value, FBC_MISC, FBC_STOP_ON_HFLIP_EVENT)) {\n\t\tvalue = dm_read_reg(compressor->ctx, mmFBC_CNTL);\n\n\t\tif (get_reg_field_value(value, FBC_CNTL, FBC_GRPH_COMP_EN)) {\n\t\t\tif (inst != NULL)\n\t\t\t\t*inst =\n\t\t\t\t\tcompressor->attached_inst;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nvoid dce110_compressor_program_compressed_surface_address_and_pitch(\n\tstruct compressor *compressor,\n\tstruct compr_addr_and_pitch_params *params)\n{\n\tstruct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);\n\tuint32_t value = 0;\n\tuint32_t fbc_pitch = 0;\n\tuint32_t compressed_surf_address_low_part =\n\t\tcompressor->compr_surface_address.addr.low_part;\n\n\tcp110->offsets = reg_offsets[params->inst];\n\n\t \n\tdm_write_reg(\n\t\tcompressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),\n\t\t0);\n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS), 0);\n\n\t \n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),\n\t\tcompressor->compr_surface_address.addr.high_part);\n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS),\n\t\tcompressed_surf_address_low_part);\n\n\tfbc_pitch = align_to_chunks_number_per_line(params->source_view_width);\n\n\tif (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)\n\t\tfbc_pitch = fbc_pitch / 8;\n\telse\n\t\tDC_LOG_WARNING(\"%s: Unexpected DCE11 compression ratio\",\n\t\t\t__func__);\n\n\t \n\tdm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), 0);\n\n\t \n\tset_reg_field_value(\n\t\tvalue,\n\t\tfbc_pitch,\n\t\tGRPH_COMPRESS_PITCH,\n\t\tGRPH_COMPRESS_PITCH);\n\tdm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), value);\n\n}\n\nvoid dce110_compressor_set_fbc_invalidation_triggers(\n\tstruct compressor *compressor,\n\tuint32_t fbc_trigger)\n{\n\t \n\tuint32_t addr = mmFBC_CLIENT_REGION_MASK;\n\tuint32_t value = dm_read_reg(compressor->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tFBC_CLIENT_REGION_MASK,\n\t\tFBC_MEMORY_REGION_MASK);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmFBC_IDLE_FORCE_CLEAR_MASK;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tfbc_trigger,\n\t\tFBC_IDLE_FORCE_CLEAR_MASK,\n\t\tFBC_IDLE_FORCE_CLEAR_MASK);\n\tdm_write_reg(compressor->ctx, addr, value);\n}\n\nstruct compressor *dce110_compressor_create(struct dc_context *ctx)\n{\n\tstruct dce110_compressor *cp110 =\n\t\tkzalloc(sizeof(struct dce110_compressor), GFP_KERNEL);\n\n\tif (!cp110)\n\t\treturn NULL;\n\n\tdce110_compressor_construct(cp110, ctx);\n\treturn &cp110->base;\n}\n\nvoid dce110_compressor_destroy(struct compressor **compressor)\n{\n\tkfree(TO_DCE110_COMPRESSOR(*compressor));\n\t*compressor = NULL;\n}\n\nvoid get_max_support_fbc_buffersize(unsigned int *max_x, unsigned int *max_y)\n{\n\t*max_x = FBC_MAX_X;\n\t*max_y = FBC_MAX_Y;\n\n\t \n}\n\nstatic const struct compressor_funcs dce110_compressor_funcs = {\n\t.power_up_fbc = dce110_compressor_power_up_fbc,\n\t.enable_fbc = dce110_compressor_enable_fbc,\n\t.disable_fbc = dce110_compressor_disable_fbc,\n\t.set_fbc_invalidation_triggers = dce110_compressor_set_fbc_invalidation_triggers,\n\t.surface_address_and_pitch = dce110_compressor_program_compressed_surface_address_and_pitch,\n\t.is_fbc_enabled_in_hw = dce110_compressor_is_fbc_enabled_in_hw\n};\n\n\nvoid dce110_compressor_construct(struct dce110_compressor *compressor,\n\tstruct dc_context *ctx)\n{\n\n\tcompressor->base.options.raw = 0;\n\tcompressor->base.options.bits.FBC_SUPPORT = true;\n\n\t \n\tcompressor->base.lpt_channels_num = 1;\n\tcompressor->base.options.bits.DUMMY_BACKEND = false;\n\n\t \n\n\n\tcompressor->base.options.bits.CLK_GATING_DISABLED = false;\n\n\tcompressor->base.ctx = ctx;\n\tcompressor->base.embedded_panel_h_size = 0;\n\tcompressor->base.embedded_panel_v_size = 0;\n\tcompressor->base.memory_bus_width = ctx->asic_id.vram_width;\n\tcompressor->base.allocated_size = 0;\n\tcompressor->base.preferred_requested_size = 0;\n\tcompressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;\n\tcompressor->base.banks_num = 0;\n\tcompressor->base.raw_size = 0;\n\tcompressor->base.channel_interleave_size = 0;\n\tcompressor->base.dram_channels_num = 0;\n\tcompressor->base.lpt_channels_num = 0;\n\tcompressor->base.attached_inst = CONTROLLER_ID_UNDEFINED;\n\tcompressor->base.is_enabled = false;\n\tcompressor->base.funcs = &dce110_compressor_funcs;\n\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}