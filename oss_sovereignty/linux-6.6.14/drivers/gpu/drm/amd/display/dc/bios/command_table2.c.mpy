{
  "module_name": "command_table2.c",
  "hash_id": "95190229898017d63dcab4b4563f63704104e7be00ea753dc133f87839fd7109",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/bios/command_table2.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"ObjectID.h\"\n\n#include \"atomfirmware.h\"\n#include \"atom.h\"\n#include \"include/bios_parser_interface.h\"\n\n#include \"command_table2.h\"\n#include \"command_table_helper2.h\"\n#include \"bios_parser_helper.h\"\n#include \"bios_parser_types_internal2.h\"\n#include \"amdgpu.h\"\n\n#include \"dc_dmub_srv.h\"\n#include \"dc.h\"\n\n#define DC_LOGGER \\\n\tbp->base.ctx->logger\n\n#define GET_INDEX_INTO_MASTER_TABLE(MasterOrData, FieldName)\\\n\t(offsetof(struct atom_master_list_of_##MasterOrData##_functions_v2_1, FieldName) / sizeof(uint16_t))\n\n#define EXEC_BIOS_CMD_TABLE(fname, params)\\\n\t(amdgpu_atom_execute_table(((struct amdgpu_device *)bp->base.ctx->driver_context)->mode_info.atom_context, \\\n\t\tGET_INDEX_INTO_MASTER_TABLE(command, fname), \\\n\t\t(uint32_t *)&params) == 0)\n\n#define BIOS_CMD_TABLE_REVISION(fname, frev, crev)\\\n\tamdgpu_atom_parse_cmd_header(((struct amdgpu_device *)bp->base.ctx->driver_context)->mode_info.atom_context, \\\n\t\tGET_INDEX_INTO_MASTER_TABLE(command, fname), &frev, &crev)\n\n#define BIOS_CMD_TABLE_PARA_REVISION(fname)\\\n\tbios_cmd_table_para_revision(bp->base.ctx->driver_context, \\\n\t\t\tGET_INDEX_INTO_MASTER_TABLE(command, fname))\n\n\n\nstatic uint32_t bios_cmd_table_para_revision(void *dev,\n\t\t\t\t\t     uint32_t index)\n{\n\tstruct amdgpu_device *adev = dev;\n\tuint8_t frev, crev;\n\n\tif (amdgpu_atom_parse_cmd_header(adev->mode_info.atom_context,\n\t\t\t\t\tindex,\n\t\t\t\t\t&frev, &crev))\n\t\treturn crev;\n\telse\n\t\treturn 0;\n}\n\n \n\nstatic enum bp_result encoder_control_digx_v1_5(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic enum bp_result encoder_control_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl);\n\nstatic void init_dig_encoder_control(struct bios_parser *bp)\n{\n\tuint32_t version =\n\t\tBIOS_CMD_TABLE_PARA_REVISION(digxencodercontrol);\n\n\tswitch (version) {\n\tcase 5:\n\t\tbp->cmd_tbl.dig_encoder_control = encoder_control_digx_v1_5;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have dig_encoder_control for v%d\\n\", version);\n\t\tbp->cmd_tbl.dig_encoder_control = encoder_control_fallback;\n\t\tbreak;\n\t}\n}\n\nstatic void encoder_control_dmcub(\n\t\tstruct dc_dmub_srv *dmcub,\n\t\tstruct dig_encoder_stream_setup_parameters_v1_5 *dig)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.digx_encoder_control.header.type = DMUB_CMD__VBIOS;\n\tcmd.digx_encoder_control.header.sub_type =\n\t\tDMUB_CMD__VBIOS_DIGX_ENCODER_CONTROL;\n\tcmd.digx_encoder_control.header.payload_bytes =\n\t\tsizeof(cmd.digx_encoder_control) -\n\t\tsizeof(cmd.digx_encoder_control.header);\n\tcmd.digx_encoder_control.encoder_control.dig.stream_param = *dig;\n\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result encoder_control_digx_v1_5(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tstruct dig_encoder_stream_setup_parameters_v1_5 params = {0};\n\n\tparams.digid = (uint8_t)(cntl->engine_id);\n\tparams.action = bp->cmd_helper->encoder_action_to_atom(cntl->action);\n\n\tparams.pclk_10khz = cntl->pixel_clock / 10;\n\tparams.digmode =\n\t\t\t(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\t\tcntl->signal,\n\t\t\t\t\tcntl->enable_dp_audio));\n\tparams.lanenum = (uint8_t)(cntl->lanes_number);\n\n\tswitch (cntl->color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tparams.bitpercolor = PANEL_8BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tparams.bitpercolor = PANEL_10BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tparams.bitpercolor = PANEL_12BIT_PER_COLOR;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tparams.bitpercolor = PANEL_16BIT_PER_COLOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\tswitch (cntl->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tparams.pclk_10khz =\n\t\t\t\t(params.pclk_10khz * 30) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tparams.pclk_10khz =\n\t\t\t\t(params.pclk_10khz * 36) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tparams.pclk_10khz =\n\t\t\t\t(params.pclk_10khz * 48) / 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\tencoder_control_dmcub(bp->base.ctx->dmub_srv, &params);\n\t\treturn BP_RESULT_OK;\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(digxencodercontrol, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result encoder_control_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_encoder_control *cntl)\n{\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\treturn encoder_control_digx_v1_5(bp, cntl);\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\n \n\nstatic enum bp_result transmitter_control_v1_6(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\n\nstatic enum bp_result transmitter_control_v1_7(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\n\nstatic enum bp_result transmitter_control_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl);\n\nstatic void init_transmitter_control(struct bios_parser *bp)\n{\n\tuint8_t frev;\n\tuint8_t crev;\n\n\tBIOS_CMD_TABLE_REVISION(dig1transmittercontrol, frev, crev);\n\n\tswitch (crev) {\n\tcase 6:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v1_6;\n\t\tbreak;\n\tcase 7:\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_v1_7;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have transmitter_control for v%d\\n\", crev);\n\t\tbp->cmd_tbl.transmitter_control = transmitter_control_fallback;\n\t\tbreak;\n\t}\n}\n\nstatic void transmitter_control_dmcub(\n\t\tstruct dc_dmub_srv *dmcub,\n\t\tstruct dig_transmitter_control_parameters_v1_6 *dig)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.dig1_transmitter_control.header.type = DMUB_CMD__VBIOS;\n\tcmd.dig1_transmitter_control.header.sub_type =\n\t\tDMUB_CMD__VBIOS_DIG1_TRANSMITTER_CONTROL;\n\tcmd.dig1_transmitter_control.header.payload_bytes =\n\t\tsizeof(cmd.dig1_transmitter_control) -\n\t\tsizeof(cmd.dig1_transmitter_control.header);\n\tcmd.dig1_transmitter_control.transmitter_control.dig = *dig;\n\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result transmitter_control_v1_6(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\tstruct dig_transmitter_control_ps_allocation_v1_6 ps = { { 0 } };\n\n\tps.param.phyid = cmd->phy_id_to_atom(cntl->transmitter);\n\tps.param.action = (uint8_t)cntl->action;\n\n\tif (cntl->action == TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS)\n\t\tps.param.mode_laneset.dplaneset = (uint8_t)cntl->lane_settings;\n\telse\n\t\tps.param.mode_laneset.digmode =\n\t\t\t\tcmd->signal_type_to_atom_dig_mode(cntl->signal);\n\n\tps.param.lanenum = (uint8_t)cntl->lanes_number;\n\tps.param.hpdsel = cmd->hpd_sel_to_atom(cntl->hpd_sel);\n\tps.param.digfe_sel = cmd->dig_encoder_sel_to_atom(cntl->engine_id);\n\tps.param.connobj_id = (uint8_t)cntl->connector_obj_id.id;\n\tps.param.symclk_10khz = cntl->pixel_clock/10;\n\n\n\tif (cntl->action == TRANSMITTER_CONTROL_ENABLE ||\n\t\tcntl->action == TRANSMITTER_CONTROL_ACTIAVATE ||\n\t\tcntl->action == TRANSMITTER_CONTROL_DEACTIVATE) {\n\t\tDC_LOG_BIOS(\"%s:ps.param.symclk_10khz = %d\\n\",\\\n\t\t__func__, ps.param.symclk_10khz);\n\t}\n\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\ttransmitter_control_dmcub(bp->base.ctx->dmub_srv, &ps.param);\n\t\treturn BP_RESULT_OK;\n\t}\n\n \n\tif (EXEC_BIOS_CMD_TABLE(dig1transmittercontrol, ps))\n\t\tresult = BP_RESULT_OK;\n\treturn result;\n}\n\nstatic void transmitter_control_dmcub_v1_7(\n\t\tstruct dc_dmub_srv *dmcub,\n\t\tstruct dmub_dig_transmitter_control_data_v1_7 *dig)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.dig1_transmitter_control.header.type = DMUB_CMD__VBIOS;\n\tcmd.dig1_transmitter_control.header.sub_type =\n\t\tDMUB_CMD__VBIOS_DIG1_TRANSMITTER_CONTROL;\n\tcmd.dig1_transmitter_control.header.payload_bytes =\n\t\tsizeof(cmd.dig1_transmitter_control) -\n\t\tsizeof(cmd.dig1_transmitter_control.header);\n\tcmd.dig1_transmitter_control.transmitter_control.dig_v1_7 = *dig;\n\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result transmitter_control_v1_7(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\tstruct dmub_dig_transmitter_control_data_v1_7 dig_v1_7 = {0};\n\n\tuint8_t hpo_instance = (uint8_t)cntl->hpo_engine_id - ENGINE_ID_HPO_0;\n\n\tif (dc_is_dp_signal(cntl->signal))\n\t\thpo_instance = (uint8_t)cntl->hpo_engine_id - ENGINE_ID_HPO_DP_0;\n\n\tdig_v1_7.phyid = cmd->phy_id_to_atom(cntl->transmitter);\n\tdig_v1_7.action = (uint8_t)cntl->action;\n\n\tif (cntl->action == TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS)\n\t\tdig_v1_7.mode_laneset.dplaneset = (uint8_t)cntl->lane_settings;\n\telse\n\t\tdig_v1_7.mode_laneset.digmode =\n\t\t\t\tcmd->signal_type_to_atom_dig_mode(cntl->signal);\n\n\tdig_v1_7.lanenum = (uint8_t)cntl->lanes_number;\n\tdig_v1_7.hpdsel = cmd->hpd_sel_to_atom(cntl->hpd_sel);\n\tdig_v1_7.digfe_sel = cmd->dig_encoder_sel_to_atom(cntl->engine_id);\n\tdig_v1_7.connobj_id = (uint8_t)cntl->connector_obj_id.id;\n\tdig_v1_7.HPO_instance = hpo_instance;\n\tdig_v1_7.symclk_units.symclk_10khz = cntl->pixel_clock/10;\n\n\tif (cntl->action == TRANSMITTER_CONTROL_ENABLE ||\n\t\tcntl->action == TRANSMITTER_CONTROL_ACTIAVATE ||\n\t\tcntl->action == TRANSMITTER_CONTROL_DEACTIVATE) {\n\t\t\tDC_LOG_BIOS(\"%s:dig_v1_7.symclk_units.symclk_10khz = %d\\n\",\n\t\t\t__func__, dig_v1_7.symclk_units.symclk_10khz);\n\t}\n\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t\tbp->base.ctx->dc->debug.dmub_command_table) {\n\t\ttransmitter_control_dmcub_v1_7(bp->base.ctx->dmub_srv, &dig_v1_7);\n\t\treturn BP_RESULT_OK;\n\t}\n\n \n\tif (EXEC_BIOS_CMD_TABLE(dig1transmittercontrol, dig_v1_7))\n\t\tresult = BP_RESULT_OK;\n\treturn result;\n}\n\nstatic enum bp_result transmitter_control_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_transmitter_control *cntl)\n{\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\treturn transmitter_control_v1_7(bp, cntl);\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\n \n\nstatic enum bp_result set_pixel_clock_v7(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\n\nstatic enum bp_result set_pixel_clock_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params);\n\nstatic void init_set_pixel_clock(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(setpixelclock)) {\n\tcase 7:\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_v7;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have set_pixel_clock for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(setpixelclock));\n\t\tbp->cmd_tbl.set_pixel_clock = set_pixel_clock_fallback;\n\t\tbreak;\n\t}\n}\n\nstatic void set_pixel_clock_dmcub(\n\t\tstruct dc_dmub_srv *dmcub,\n\t\tstruct set_pixel_clock_parameter_v1_7 *clk)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.set_pixel_clock.header.type = DMUB_CMD__VBIOS;\n\tcmd.set_pixel_clock.header.sub_type = DMUB_CMD__VBIOS_SET_PIXEL_CLOCK;\n\tcmd.set_pixel_clock.header.payload_bytes =\n\t\tsizeof(cmd.set_pixel_clock) -\n\t\tsizeof(cmd.set_pixel_clock.header);\n\tcmd.set_pixel_clock.pixel_clock.clk = *clk;\n\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result set_pixel_clock_v7(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tstruct set_pixel_clock_parameter_v1_7 clk;\n\tuint8_t controller_id;\n\tuint32_t pll_id;\n\n\tmemset(&clk, 0, sizeof(clk));\n\n\tif (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)\n\t\t\t&& bp->cmd_helper->controller_id_to_atom(bp_params->\n\t\t\t\t\tcontroller_id, &controller_id)) {\n\t\t \n\t\tclk.crtc_id = controller_id;\n\t\tclk.pll_id = (uint8_t) pll_id;\n\t\tclk.encoderobjid =\n\t\t\tbp->cmd_helper->encoder_id_to_atom(\n\t\t\t\tdal_graphics_object_id_get_encoder_id(\n\t\t\t\t\tbp_params->encoder_object_id));\n\n\t\tclk.encoder_mode = (uint8_t) bp->\n\t\t\tcmd_helper->encoder_mode_bp_to_atom(\n\t\t\t\tbp_params->signal_type, false);\n\n\t\tclk.pixclk_100hz = cpu_to_le32(bp_params->target_pixel_clock_100hz);\n\n\t\tclk.deep_color_ratio =\n\t\t\t(uint8_t) bp->cmd_helper->\n\t\t\t\ttransmitter_color_depth_to_atom(\n\t\t\t\t\tbp_params->color_depth);\n\n\t\tDC_LOG_BIOS(\"%s:program display clock = %d, tg = %d, pll = %d, \"\\\n\t\t\t\t\"colorDepth = %d\\n\", __func__,\n\t\t\t\tbp_params->target_pixel_clock_100hz, (int)controller_id,\n\t\t\t\tpll_id, bp_params->color_depth);\n\n\t\tif (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_FORCE_PROG_PPLL;\n\n\t\tif (bp_params->flags.PROGRAM_PHY_PLL_ONLY)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_PROG_PHYPLL;\n\n\t\tif (bp_params->flags.SUPPORT_YUV_420)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_YUV420_MODE;\n\n\t\tif (bp_params->flags.SET_XTALIN_REF_SRC)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_XTALIN;\n\n\t\tif (bp_params->flags.SET_GENLOCK_REF_DIV_SRC)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_GENLK;\n\n\t\tif (bp_params->signal_type == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\tclk.miscinfo |= PIXEL_CLOCK_V7_MISC_DVI_DUALLINK_EN;\n\n\t\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\t\tset_pixel_clock_dmcub(bp->base.ctx->dmub_srv, &clk);\n\t\t\treturn BP_RESULT_OK;\n\t\t}\n\n\t\tif (EXEC_BIOS_CMD_TABLE(setpixelclock, clk))\n\t\t\tresult = BP_RESULT_OK;\n\t}\n\treturn result;\n}\n\nstatic enum bp_result set_pixel_clock_fallback(\n\tstruct bios_parser *bp,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\treturn set_pixel_clock_v7(bp, bp_params);\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\n \n\nstatic enum bp_result set_crtc_using_dtd_timing_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params);\n\nstatic void init_set_crtc_timing(struct bios_parser *bp)\n{\n\tuint32_t dtd_version =\n\t\t\tBIOS_CMD_TABLE_PARA_REVISION(setcrtc_usingdtdtiming);\n\n\tswitch (dtd_version) {\n\tcase 3:\n\t\tbp->cmd_tbl.set_crtc_timing =\n\t\t\tset_crtc_using_dtd_timing_v3;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have set_crtc_timing for v%d\\n\", dtd_version);\n\t\tbp->cmd_tbl.set_crtc_timing = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result set_crtc_using_dtd_timing_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_hw_crtc_timing_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\tstruct set_crtc_using_dtd_timing_parameters params = {0};\n\tuint8_t atom_controller_id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(\n\t\t\tbp_params->controller_id, &atom_controller_id))\n\t\tparams.crtc_id = atom_controller_id;\n\n\t \n\tparams.h_size = cpu_to_le16((uint16_t)bp_params->h_addressable);\n\t \n\tparams.h_blanking_time =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->h_total -\n\t\t\t\t\tbp_params->h_addressable));\n\t \n\tparams.v_size = cpu_to_le16((uint16_t)bp_params->v_addressable);\n\t \n\tparams.v_blanking_time =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_total -\n\t\t\t\t\tbp_params->v_addressable));\n\t \n\tparams.h_syncoffset =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->h_sync_start -\n\t\t\t\t\tbp_params->h_addressable));\n\tparams.h_syncwidth = cpu_to_le16((uint16_t)bp_params->h_sync_width);\n\t \n\tparams.v_syncoffset =\n\t\t\tcpu_to_le16((uint16_t)(bp_params->v_sync_start -\n\t\t\t\t\tbp_params->v_addressable));\n\tparams.v_syncwidth = cpu_to_le16((uint16_t)bp_params->v_sync_width);\n\n\t \n\n\tif (bp_params->flags.HSYNC_POSITIVE_POLARITY == 0)\n\t\tparams.modemiscinfo =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |\n\t\t\t\t\t\tATOM_HSYNC_POLARITY);\n\n\tif (bp_params->flags.VSYNC_POSITIVE_POLARITY == 0)\n\t\tparams.modemiscinfo =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |\n\t\t\t\t\t\tATOM_VSYNC_POLARITY);\n\n\tif (bp_params->flags.INTERLACE)\t{\n\t\tparams.modemiscinfo =\n\t\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |\n\t\t\t\t\t\tATOM_INTERLACE);\n\n\t\t \n\t\t{\n\t\t\t \n\t\t\tle16_add_cpu(&params.v_syncoffset, 1);\n\t\t}\n\t}\n\n\tif (bp_params->flags.HORZ_COUNT_BY_TWO)\n\t\tparams.modemiscinfo =\n\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |\n\t\t\t\t\t0x100);  \n\n\tif (EXEC_BIOS_CMD_TABLE(setcrtc_usingdtdtiming, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\nstatic enum bp_result enable_crtc_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable);\n\nstatic void init_enable_crtc(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(enablecrtc)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_crtc = enable_crtc_v1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have enable_crtc for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(enablecrtc));\n\t\tbp->cmd_tbl.enable_crtc = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result enable_crtc_v1(\n\tstruct bios_parser *bp,\n\tenum controller_id controller_id,\n\tbool enable)\n{\n\tbool result = BP_RESULT_FAILURE;\n\tstruct enable_crtc_parameters params = {0};\n\tuint8_t id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(controller_id, &id))\n\t\tparams.crtc_id = id;\n\telse\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (enable)\n\t\tparams.enable = ATOM_ENABLE;\n\telse\n\t\tparams.enable = ATOM_DISABLE;\n\n\tif (EXEC_BIOS_CMD_TABLE(enablecrtc, params))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\n \n\n\n\n \n\nstatic enum bp_result external_encoder_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_external_encoder_control *cntl);\n\nstatic void init_external_encoder_control(\n\tstruct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(externalencodercontrol)) {\n\tcase 3:\n\t\tbp->cmd_tbl.external_encoder_control =\n\t\t\t\texternal_encoder_control_v3;\n\t\tbreak;\n\tdefault:\n\t\tbp->cmd_tbl.external_encoder_control = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result external_encoder_control_v3(\n\tstruct bios_parser *bp,\n\tstruct bp_external_encoder_control *cntl)\n{\n\t \n\treturn BP_RESULT_OK;\n}\n\n \n\nstatic enum bp_result enable_disp_power_gating_v2_1(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action);\n\nstatic enum bp_result enable_disp_power_gating_fallback(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action);\n\nstatic void init_enable_disp_power_gating(\n\tstruct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(enabledisppowergating)) {\n\tcase 1:\n\t\tbp->cmd_tbl.enable_disp_power_gating =\n\t\t\t\tenable_disp_power_gating_v2_1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't enable_disp_power_gating enable_crtc for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(enabledisppowergating));\n\t\tbp->cmd_tbl.enable_disp_power_gating = enable_disp_power_gating_fallback;\n\t\tbreak;\n\t}\n}\n\nstatic void enable_disp_power_gating_dmcub(\n\tstruct dc_dmub_srv *dmcub,\n\tstruct enable_disp_power_gating_parameters_v2_1 *pwr)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.enable_disp_power_gating.header.type = DMUB_CMD__VBIOS;\n\tcmd.enable_disp_power_gating.header.sub_type =\n\t\tDMUB_CMD__VBIOS_ENABLE_DISP_POWER_GATING;\n\tcmd.enable_disp_power_gating.header.payload_bytes =\n\t\tsizeof(cmd.enable_disp_power_gating) -\n\t\tsizeof(cmd.enable_disp_power_gating.header);\n\tcmd.enable_disp_power_gating.power_gating.pwr = *pwr;\n\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result enable_disp_power_gating_v2_1(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\n\tstruct enable_disp_power_gating_ps_allocation ps = { { 0 } };\n\tuint8_t atom_crtc_id;\n\n\tif (bp->cmd_helper->controller_id_to_atom(crtc_id, &atom_crtc_id))\n\t\tps.param.disp_pipe_id = atom_crtc_id;\n\telse\n\t\treturn BP_RESULT_BADINPUT;\n\n\tps.param.enable =\n\t\tbp->cmd_helper->disp_power_gating_action_to_atom(action);\n\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\tenable_disp_power_gating_dmcub(bp->base.ctx->dmub_srv,\n\t\t\t\t\t       &ps.param);\n\t\treturn BP_RESULT_OK;\n\t}\n\n\tif (EXEC_BIOS_CMD_TABLE(enabledisppowergating, ps.param))\n\t\tresult = BP_RESULT_OK;\n\n\treturn result;\n}\n\nstatic enum bp_result enable_disp_power_gating_fallback(\n\tstruct bios_parser *bp,\n\tenum controller_id crtc_id,\n\tenum bp_pipe_control_action action)\n{\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\treturn enable_disp_power_gating_v2_1(bp, crtc_id, action);\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\n \n\nstatic enum bp_result set_dce_clock_v2_1(\n\tstruct bios_parser *bp,\n\tstruct bp_set_dce_clock_parameters *bp_params);\n\nstatic void init_set_dce_clock(struct bios_parser *bp)\n{\n\tswitch (BIOS_CMD_TABLE_PARA_REVISION(setdceclock)) {\n\tcase 1:\n\t\tbp->cmd_tbl.set_dce_clock = set_dce_clock_v2_1;\n\t\tbreak;\n\tdefault:\n\t\tdm_output_to_console(\"Don't have set_dce_clock for v%d\\n\",\n\t\t\t BIOS_CMD_TABLE_PARA_REVISION(setdceclock));\n\t\tbp->cmd_tbl.set_dce_clock = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic enum bp_result set_dce_clock_v2_1(\n\tstruct bios_parser *bp,\n\tstruct bp_set_dce_clock_parameters *bp_params)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tstruct set_dce_clock_ps_allocation_v2_1 params;\n\tuint32_t atom_pll_id;\n\tuint32_t atom_clock_type;\n\tconst struct command_table_helper *cmd = bp->cmd_helper;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!cmd->clock_source_id_to_atom(bp_params->pll_id, &atom_pll_id) ||\n\t\t\t!cmd->dc_clock_type_to_atom(bp_params->clock_type,\n\t\t\t\t\t&atom_clock_type))\n\t\treturn BP_RESULT_BADINPUT;\n\n\tparams.param.dceclksrc  = atom_pll_id;\n\tparams.param.dceclktype = atom_clock_type;\n\n\tif (bp_params->clock_type == DCECLOCK_TYPE_DPREFCLK) {\n\t\tif (bp_params->flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.param.dceclkflag |=\n\t\t\t\t\tDCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENLK;\n\n\t\tif (bp_params->flags.USE_PCIE_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.param.dceclkflag |=\n\t\t\t\t\tDCE_CLOCK_FLAG_PLL_REFCLK_SRC_PCIE;\n\n\t\tif (bp_params->flags.USE_XTALIN_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.param.dceclkflag |=\n\t\t\t\t\tDCE_CLOCK_FLAG_PLL_REFCLK_SRC_XTALIN;\n\n\t\tif (bp_params->flags.USE_GENERICA_AS_SOURCE_FOR_DPREFCLK)\n\t\t\tparams.param.dceclkflag |=\n\t\t\t\t\tDCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENERICA;\n\t} else\n\t\t \n\t\tparams.param.dceclk_10khz = cpu_to_le32(\n\t\t\t\tbp_params->target_clock_frequency / 10);\n\tDC_LOG_BIOS(\"%s:target_clock_frequency = %d\"\\\n\t\t\t\"clock_type = %d \\n\", __func__,\\\n\t\t\tbp_params->target_clock_frequency,\\\n\t\t\tbp_params->clock_type);\n\n\tif (EXEC_BIOS_CMD_TABLE(setdceclock, params)) {\n\t\t \n\t\tbp_params->target_clock_frequency = le32_to_cpu(\n\t\t\t\tparams.param.dceclk_10khz) * 10;\n\t\tresult = BP_RESULT_OK;\n\t}\n\n\treturn result;\n}\n\n\n \n\nstatic unsigned int get_smu_clock_info_v3_1(struct bios_parser *bp, uint8_t id);\n\nstatic void init_get_smu_clock_info(struct bios_parser *bp)\n{\n\t \n\tbp->cmd_tbl.get_smu_clock_info = get_smu_clock_info_v3_1;\n\n}\n\nstatic unsigned int get_smu_clock_info_v3_1(struct bios_parser *bp, uint8_t id)\n{\n\tstruct atom_get_smu_clock_info_parameters_v3_1 smu_input = {0};\n\tstruct atom_get_smu_clock_info_output_parameters_v3_1 smu_output;\n\n\tsmu_input.command = GET_SMU_CLOCK_INFO_V3_1_GET_PLLVCO_FREQ;\n\tsmu_input.syspll_id = id;\n\n\t \n\tif (EXEC_BIOS_CMD_TABLE(getsmuclockinfo, smu_input)) {\n\t\tmemmove(&smu_output, &smu_input, sizeof(\n\t\t\tstruct atom_get_smu_clock_info_parameters_v3_1));\n\t\treturn smu_output.atom_smu_outputclkfreq.syspllvcofreq_10khz;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic enum bp_result enable_lvtma_control(\n\tstruct bios_parser *bp,\n\tuint8_t uc_pwr_on,\n\tuint8_t pwrseq_instance,\n\tuint8_t bypass_panel_control_wait);\n\nstatic void init_enable_lvtma_control(struct bios_parser *bp)\n{\n\t \n\tbp->cmd_tbl.enable_lvtma_control = enable_lvtma_control;\n\n}\n\nstatic void enable_lvtma_control_dmcub(\n\tstruct dc_dmub_srv *dmcub,\n\tuint8_t uc_pwr_on,\n\tuint8_t pwrseq_instance,\n\tuint8_t bypass_panel_control_wait)\n{\n\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.lvtma_control.header.type = DMUB_CMD__VBIOS;\n\tcmd.lvtma_control.header.sub_type =\n\t\t\tDMUB_CMD__VBIOS_LVTMA_CONTROL;\n\tcmd.lvtma_control.data.uc_pwr_action =\n\t\t\tuc_pwr_on;\n\tcmd.lvtma_control.data.pwrseq_inst =\n\t\t\tpwrseq_instance;\n\tcmd.lvtma_control.data.bypass_panel_control_wait =\n\t\t\tbypass_panel_control_wait;\n\tdm_execute_dmub_cmd(dmcub->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic enum bp_result enable_lvtma_control(\n\tstruct bios_parser *bp,\n\tuint8_t uc_pwr_on,\n\tuint8_t pwrseq_instance,\n\tuint8_t bypass_panel_control_wait)\n{\n\tenum bp_result result = BP_RESULT_FAILURE;\n\n\tif (bp->base.ctx->dc->ctx->dmub_srv &&\n\t    bp->base.ctx->dc->debug.dmub_command_table) {\n\t\tenable_lvtma_control_dmcub(bp->base.ctx->dmub_srv,\n\t\t\t\tuc_pwr_on,\n\t\t\t\tpwrseq_instance,\n\t\t\t\tbypass_panel_control_wait);\n\t\treturn BP_RESULT_OK;\n\t}\n\treturn result;\n}\n\nvoid dal_firmware_parser_init_cmd_tbl(struct bios_parser *bp)\n{\n\tinit_dig_encoder_control(bp);\n\tinit_transmitter_control(bp);\n\tinit_set_pixel_clock(bp);\n\n\tinit_set_crtc_timing(bp);\n\n\tinit_enable_crtc(bp);\n\n\tinit_external_encoder_control(bp);\n\tinit_enable_disp_power_gating(bp);\n\tinit_set_dce_clock(bp);\n\tinit_get_smu_clock_info(bp);\n\n\tinit_enable_lvtma_control(bp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}