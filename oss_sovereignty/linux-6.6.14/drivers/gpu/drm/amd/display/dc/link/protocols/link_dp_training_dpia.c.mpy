{
  "module_name": "link_dp_training_dpia.c",
  "hash_id": "e57d7dda09587323058f4e21356810b6ab6ee4fc1759855ccc6ee317f84a6326",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_dpia.c",
  "human_readable_source": " \n\n \n#include \"link_dp_training_dpia.h\"\n#include \"dc.h\"\n#include \"inc/core_status.h\"\n#include \"dpcd_defs.h\"\n\n#include \"link_dp_dpia.h\"\n#include \"link_hwss.h\"\n#include \"dm_helpers.h\"\n#include \"dmub/inc/dmub_cmd.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_phy.h\"\n#include \"link_dp_training_8b_10b.h\"\n#include \"link_dp_capability.h\"\n#include \"dc_dmub_srv.h\"\n#define DC_LOGGER \\\n\tlink->ctx->logger\n\n \n#define DPIA_CLK_SYNC_DELAY 16000\n\n \n#define DPIA_DEBUG_EXTENDED_AUX_RD_INTERVAL_US 60000000\n\n#define TRAINING_AUX_RD_INTERVAL 100 \n\n \nenum dpia_set_config_type {\n\tDPIA_SET_CFG_SET_LINK = 0x01,\n\tDPIA_SET_CFG_SET_PHY_TEST_MODE = 0x05,\n\tDPIA_SET_CFG_SET_TRAINING = 0x18,\n\tDPIA_SET_CFG_SET_VSPE = 0x19\n};\n\n \nenum dpia_set_config_ts {\n\tDPIA_TS_DPRX_DONE = 0x00,  \n\tDPIA_TS_TPS1 = 0x01,\n\tDPIA_TS_TPS2 = 0x02,\n\tDPIA_TS_TPS3 = 0x03,\n\tDPIA_TS_TPS4 = 0x07,\n\tDPIA_TS_UFP_DONE = 0xff  \n};\n\n \nunion dpia_set_config_data {\n\tstruct {\n\t\tuint8_t mode : 1;\n\t\tuint8_t reserved : 7;\n\t} set_link;\n\tstruct {\n\t\tuint8_t stage;\n\t} set_training;\n\tstruct {\n\t\tuint8_t swing : 2;\n\t\tuint8_t max_swing_reached : 1;\n\t\tuint8_t pre_emph : 2;\n\t\tuint8_t max_pre_emph_reached : 1;\n\t\tuint8_t reserved : 2;\n\t} set_vspe;\n\tuint8_t raw;\n};\n\n\n \nstatic enum link_training_result dpia_configure_link(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tconst struct dc_link_settings *link_setting,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum dc_status status;\n\tbool fec_enable;\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n DPIA(%d) configuring\\n - LTTPR mode(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\tlt_settings->lttpr_mode);\n\n\tdp_decide_training_settings(\n\t\tlink,\n\t\tlink_setting,\n\t\tlt_settings);\n\n\tdp_get_lttpr_mode_override(link, &lt_settings->lttpr_mode);\n\n\tstatus = dpcd_configure_channel_coding(link, lt_settings);\n\tif (status != DC_OK && link->is_hpd_pending)\n\t\treturn LINK_TRAINING_ABORT;\n\n\t \n\tstatus = dpcd_configure_lttpr_mode(link, lt_settings);\n\tif (status != DC_OK && link->is_hpd_pending)\n\t\treturn LINK_TRAINING_ABORT;\n\n\t \n\tstatus = dpcd_set_link_settings(link, lt_settings);\n\tif (status != DC_OK && link->is_hpd_pending)\n\t\treturn LINK_TRAINING_ABORT;\n\n\tif (link->preferred_training_settings.fec_enable != NULL)\n\t\tfec_enable = *link->preferred_training_settings.fec_enable;\n\telse\n\t\tfec_enable = true;\n\tstatus = dp_set_fec_ready(link, link_res, fec_enable);\n\tif (status != DC_OK && link->is_hpd_pending)\n\t\treturn LINK_TRAINING_ABORT;\n\n\treturn LINK_TRAINING_SUCCESS;\n}\n\nstatic enum dc_status core_link_send_set_config(\n\tstruct dc_link *link,\n\tuint8_t msg_type,\n\tuint8_t msg_data)\n{\n\tstruct set_config_cmd_payload payload;\n\tenum set_config_status set_config_result = SET_CONFIG_PENDING;\n\n\t \n\tpayload.msg_type = msg_type;\n\tpayload.msg_data = msg_data;\n\n\tif (!link->ddc->ddc_pin && !link->aux_access_disabled &&\n\t\t\t(dm_helpers_dmub_set_config_sync(link->ctx,\n\t\t\tlink, &payload, &set_config_result) == -1)) {\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\t \n\treturn (set_config_result == SET_CONFIG_ACK_RECEIVED) ? DC_OK : DC_ERROR_UNEXPECTED;\n}\n\n \nstatic uint8_t dpia_build_set_config_data(\n\t\tenum dpia_set_config_type type,\n\t\tstruct dc_link *link,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tunion dpia_set_config_data data;\n\n\tdata.raw = 0;\n\n\tswitch (type) {\n\tcase DPIA_SET_CFG_SET_LINK:\n\t\tdata.set_link.mode = lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT ? 1 : 0;\n\t\tbreak;\n\tcase DPIA_SET_CFG_SET_PHY_TEST_MODE:\n\t\tbreak;\n\tcase DPIA_SET_CFG_SET_VSPE:\n\t\t \n\t\tdata.set_vspe.swing = lt_settings->hw_lane_settings[0].VOLTAGE_SWING;\n\t\tdata.set_vspe.pre_emph = lt_settings->hw_lane_settings[0].PRE_EMPHASIS;\n\t\tdata.set_vspe.max_swing_reached =\n\t\t\t\tlt_settings->hw_lane_settings[0].VOLTAGE_SWING == VOLTAGE_SWING_MAX_LEVEL ? 1 : 0;\n\t\tdata.set_vspe.max_pre_emph_reached =\n\t\t\t\tlt_settings->hw_lane_settings[0].PRE_EMPHASIS == PRE_EMPHASIS_MAX_LEVEL ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(false);  \n\t\tbreak;\n\t}\n\n\treturn data.raw;\n}\n\n \nstatic enum dc_status convert_trng_ptn_to_trng_stg(enum dc_dp_training_pattern tps, enum dpia_set_config_ts *ts)\n{\n\tenum dc_status status = DC_OK;\n\n\tswitch (tps) {\n\tcase DP_TRAINING_PATTERN_SEQUENCE_1:\n\t\t*ts = DPIA_TS_TPS1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_2:\n\t\t*ts = DPIA_TS_TPS2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_3:\n\t\t*ts = DPIA_TS_TPS3;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_4:\n\t\t*ts = DPIA_TS_TPS4;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_VIDEOIDLE:\n\t\t*ts = DPIA_TS_DPRX_DONE;\n\t\tbreak;\n\tdefault:  \n\t\tASSERT(false);\n\t\t*ts = DPIA_TS_DPRX_DONE;\n\t\tstatus = DC_UNSUPPORTED_VALUE;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic enum dc_status dpcd_set_lt_pattern(\n\tstruct dc_link *link,\n\tenum dc_dp_training_pattern pattern,\n\tuint32_t hop)\n{\n\tunion dpcd_training_pattern dpcd_pattern = {0};\n\tuint32_t dpcd_tps_offset = DP_TRAINING_PATTERN_SET;\n\tenum dc_status status;\n\n\tif (hop != DPRX)\n\t\tdpcd_tps_offset = DP_TRAINING_PATTERN_SET_PHY_REPEATER1 +\n\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (hop - 1));\n\n\t \n\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET =\n\t\tdp_training_pattern_to_dpcd_training_pattern(link, pattern);\n\n\tdpcd_pattern.v1_4.SCRAMBLING_DISABLE =\n\t\tdp_initialize_scrambling_data_symbols(link, pattern);\n\n\tif (hop != DPRX) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n LTTPR Repeater ID: %d\\n 0x%X pattern = %x\\n\",\n\t\t\t__func__,\n\t\t\thop,\n\t\t\tdpcd_tps_offset,\n\t\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n\t} else {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n 0x%X pattern = %x\\n\",\n\t\t\t__func__,\n\t\t\tdpcd_tps_offset,\n\t\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n\t}\n\n\tstatus = core_link_write_dpcd(\n\t\t\tlink,\n\t\t\tdpcd_tps_offset,\n\t\t\t&dpcd_pattern.raw,\n\t\t\tsizeof(dpcd_pattern.raw));\n\n\treturn status;\n}\n\n \nstatic enum link_training_result dpia_training_cr_non_transparent(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tenum link_training_result result = LINK_TRAINING_CR_FAIL_LANE0;\n\tuint8_t repeater_cnt = 0;  \n\tenum dc_status status;\n\tuint32_t retries_cr = 0;  \n\tuint32_t retry_count = 0;\n\tuint32_t wait_time_microsec = TRAINING_AUX_RD_INTERVAL;  \n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\tuint8_t set_cfg_data;\n\tenum dpia_set_config_ts ts;\n\n\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\t \n\twhile ((retries_cr < LINK_TRAINING_MAX_RETRY_COUNT) &&\n\t\t\t(retry_count < LINK_TRAINING_MAX_CR_RETRY)) {\n\n\t\t \n\t\tif (hop == repeater_cnt) {\n\t\t\t \n\t\t\tset_cfg_data = dpia_build_set_config_data(\n\t\t\t\t\tDPIA_SET_CFG_SET_LINK,\n\t\t\t\t\tlink,\n\t\t\t\t\tlt_settings);\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_LINK,\n\t\t\t\t\tset_cfg_data);\n\t\t\t \n\t\t\tif (status == DC_OK)\n\t\t\t\tresult = LINK_TRAINING_SUCCESS;\n\t\t\telse\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (retry_count == 0) {\n\t\t\tstatus = convert_trng_ptn_to_trng_stg(lt_settings->pattern_for_cr, &ts);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_TRAINING,\n\t\t\t\t\tts);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = dpcd_set_lt_pattern(link, lt_settings->pattern_for_cr, hop);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (hop == repeater_cnt - 1) {\n\t\t\tset_cfg_data = dpia_build_set_config_data(\n\t\t\t\t\tDPIA_SET_CFG_SET_VSPE,\n\t\t\t\t\tlink,\n\t\t\t\t\tlt_settings);\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_VSPE,\n\t\t\t\t\tset_cfg_data);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstatus = dpcd_set_lane_settings(link, lt_settings, hop);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdp_wait_for_training_aux_rd_interval(link, wait_time_microsec);\n\n\t\t \n\t\tstatus = dp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\thop);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dp_is_cr_done(lane_count, dpcd_lane_status)) {\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Clock recovery OK\\n\", __func__);\n\t\t\tresult = LINK_TRAINING_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = dp_get_cr_failure(lane_count, dpcd_lane_status);\n\n\t\tif (dp_is_max_vs_reached(lt_settings))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((lt_settings->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET ==\n\t\t\t\tdpcd_lane_adjust[0].bits.VOLTAGE_SWING_LANE)\n\t\t\t\t&& (lt_settings->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET ==\n\t\t\t\t\t\tdpcd_lane_adjust[0].bits.PRE_EMPHASIS_LANE))\n\t\t\tretries_cr++;\n\t\telse\n\t\t\tretries_cr = 0;\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings,\n\t\t\t\tlt_settings->dpcd_lane_settings);\n\t\tretry_count++;\n\t}\n\n\t \n\tif (link->is_hpd_pending)\n\t\tresult = LINK_TRAINING_ABORT;\n\n\tDC_LOG_HW_LINK_TRAINING(\n\t\t\"%s\\n DPIA(%d) clock recovery\\n -hop(%d)\\n - result(%d)\\n - retries(%d)\\n - status(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\thop,\n\t\tresult,\n\t\tretry_count,\n\t\tstatus);\n\n\treturn result;\n}\n\n \nstatic enum link_training_result dpia_training_cr_transparent(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum link_training_result result = LINK_TRAINING_CR_FAIL_LANE0;\n\tenum dc_status status;\n\tuint32_t retries_cr = 0;  \n\tuint32_t retry_count = 0;\n\tuint32_t wait_time_microsec = lt_settings->cr_pattern_time;\n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\n\t \n\twhile ((retries_cr < LINK_TRAINING_MAX_RETRY_COUNT) &&\n\t\t\t(retry_count < LINK_TRAINING_MAX_CR_RETRY)) {\n\n\t\t \n\t\tif (retry_count == 0) {\n\t\t\tstatus = dpcd_set_lt_pattern(link, lt_settings->pattern_for_cr, DPRX);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp_wait_for_training_aux_rd_interval(link, wait_time_microsec);\n\n\t\t \n\t\tstatus = dp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\tDPRX);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dp_is_cr_done(lane_count, dpcd_lane_status)) {\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Clock recovery OK\\n\", __func__);\n\t\t\tresult = LINK_TRAINING_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = dp_get_cr_failure(lane_count, dpcd_lane_status);\n\n\t\tif (dp_is_max_vs_reached(lt_settings))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((lt_settings->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET ==\n\t\t\t\tdpcd_lane_adjust[0].bits.VOLTAGE_SWING_LANE)\n\t\t\t\t&& (lt_settings->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET ==\n\t\t\t\t\t\tdpcd_lane_adjust[0].bits.PRE_EMPHASIS_LANE))\n\t\t\tretries_cr++;\n\t\telse\n\t\t\tretries_cr = 0;\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t\tretry_count++;\n\t}\n\n\t \n\tif (link->is_hpd_pending)\n\t\tresult = LINK_TRAINING_ABORT;\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n DPIA(%d) clock recovery\\n -hop(%d)\\n - result(%d)\\n - retries(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\tDPRX,\n\t\tresult,\n\t\tretry_count);\n\n\treturn result;\n}\n\n \nstatic enum link_training_result dpia_training_cr_phase(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tenum link_training_result result = LINK_TRAINING_CR_FAIL_LANE0;\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT)\n\t\tresult = dpia_training_cr_non_transparent(link, link_res, lt_settings, hop);\n\telse\n\t\tresult = dpia_training_cr_transparent(link, link_res, lt_settings);\n\n\treturn result;\n}\n\n \nstatic uint32_t dpia_get_eq_aux_rd_interval(\n\t\tconst struct dc_link *link,\n\t\tconst struct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tuint32_t wait_time_microsec;\n\n\tif (hop == DPRX)\n\t\twait_time_microsec = lt_settings->eq_pattern_time;\n\telse\n\t\twait_time_microsec =\n\t\t\t\tdp_translate_training_aux_read_interval(\n\t\t\t\t\tlink->dpcd_caps.lttpr_caps.aux_rd_interval[hop - 1]);\n\n\t \n\tif (link->dc->debug.dpia_debug.bits.extend_aux_rd_interval)\n\t\twait_time_microsec = DPIA_DEBUG_EXTENDED_AUX_RD_INTERVAL_US;\n\n\treturn wait_time_microsec;\n}\n\n \nstatic enum link_training_result dpia_training_eq_non_transparent(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tenum link_training_result result = LINK_TRAINING_EQ_FAIL_EQ;\n\tuint8_t repeater_cnt = 0;  \n\tuint32_t retries_eq = 0;\n\tenum dc_status status;\n\tenum dc_dp_training_pattern tr_pattern;\n\tuint32_t wait_time_microsec;\n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\tuint8_t set_cfg_data;\n\tenum dpia_set_config_ts ts;\n\n\t \n\tif (hop == DPRX)\n\t\ttr_pattern = lt_settings->pattern_for_eq;\n\telse\n\t\ttr_pattern = DP_TRAINING_PATTERN_SEQUENCE_4;\n\n\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\tfor (retries_eq = 0; retries_eq < LINK_TRAINING_MAX_RETRY_COUNT; retries_eq++) {\n\n\t\t \n\t\tif (hop == repeater_cnt) {\n\t\t\tresult = LINK_TRAINING_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (retries_eq == 0) {\n\t\t\tstatus = convert_trng_ptn_to_trng_stg(tr_pattern, &ts);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_TRAINING,\n\t\t\t\t\tts);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = dpcd_set_lt_pattern(link, tr_pattern, hop);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (hop == repeater_cnt - 1) {\n\t\t\tset_cfg_data = dpia_build_set_config_data(\n\t\t\t\t\tDPIA_SET_CFG_SET_VSPE,\n\t\t\t\t\tlink,\n\t\t\t\t\tlt_settings);\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_VSPE,\n\t\t\t\t\tset_cfg_data);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstatus = dpcd_set_lane_settings(link, lt_settings, hop);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (hop == DPRX && retries_eq == 1)\n\t\t\twait_time_microsec = max(wait_time_microsec, (uint32_t) DPIA_CLK_SYNC_DELAY);\n\t\telse\n\t\t\twait_time_microsec = dpia_get_eq_aux_rd_interval(link, lt_settings, hop);\n\n\t\tdp_wait_for_training_aux_rd_interval(link, wait_time_microsec);\n\n\t\t \n\t\tstatus = dp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\thop);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!dp_is_cr_done(lane_count, dpcd_lane_status)) {\n\t\t\tresult = LINK_TRAINING_EQ_FAIL_CR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dp_is_ch_eq_done(lane_count, dpcd_lane_status) &&\n\t\t\t\tdp_is_symbol_locked(link->cur_link_settings.lane_count, dpcd_lane_status) &&\n\t\t\t\tdp_is_interlane_aligned(dpcd_lane_status_updated)) {\n\t\t\tresult =  LINK_TRAINING_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t}\n\n\t \n\tif (link->is_hpd_pending)\n\t\tresult = LINK_TRAINING_ABORT;\n\n\tDC_LOG_HW_LINK_TRAINING(\n\t\t\"%s\\n DPIA(%d) equalization\\n - hop(%d)\\n - result(%d)\\n - retries(%d)\\n - status(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\thop,\n\t\tresult,\n\t\tretries_eq,\n\t\tstatus);\n\n\treturn result;\n}\n\n \nstatic enum link_training_result dpia_training_eq_transparent(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum link_training_result result = LINK_TRAINING_EQ_FAIL_EQ;\n\tuint32_t retries_eq = 0;\n\tenum dc_status status;\n\tenum dc_dp_training_pattern tr_pattern = lt_settings->pattern_for_eq;\n\tuint32_t wait_time_microsec;\n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\n\twait_time_microsec = dpia_get_eq_aux_rd_interval(link, lt_settings, DPRX);\n\n\tfor (retries_eq = 0; retries_eq < LINK_TRAINING_MAX_RETRY_COUNT; retries_eq++) {\n\n\t\tif (retries_eq == 0) {\n\t\t\tstatus = dpcd_set_lt_pattern(link, tr_pattern, DPRX);\n\t\t\tif (status != DC_OK) {\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp_wait_for_training_aux_rd_interval(link, wait_time_microsec);\n\n\t\t \n\t\tstatus = dp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\tDPRX);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!dp_is_cr_done(lane_count, dpcd_lane_status)) {\n\t\t\tresult = LINK_TRAINING_EQ_FAIL_CR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dp_is_ch_eq_done(lane_count, dpcd_lane_status) &&\n\t\t\t\tdp_is_symbol_locked(link->cur_link_settings.lane_count, dpcd_lane_status)) {\n\t\t\t \n\t\t\tif (dp_is_interlane_aligned(dpcd_lane_status_updated) || (link->is_automated && retries_eq)) {\n\t\t\t\tresult =  LINK_TRAINING_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t}\n\n\t \n\tif (link->is_hpd_pending)\n\t\tresult = LINK_TRAINING_ABORT;\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n DPIA(%d) equalization\\n - hop(%d)\\n - result(%d)\\n - retries(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\tDPRX,\n\t\tresult,\n\t\tretries_eq);\n\n\treturn result;\n}\n\n \nstatic enum link_training_result dpia_training_eq_phase(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tenum link_training_result result;\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT)\n\t\tresult = dpia_training_eq_non_transparent(link, link_res, lt_settings, hop);\n\telse\n\t\tresult = dpia_training_eq_transparent(link, link_res, lt_settings);\n\n\treturn result;\n}\n\n \nstatic enum dc_status dpcd_clear_lt_pattern(\n\tstruct dc_link *link,\n\tuint32_t hop)\n{\n\tunion dpcd_training_pattern dpcd_pattern = {0};\n\tuint32_t dpcd_tps_offset = DP_TRAINING_PATTERN_SET;\n\tenum dc_status status;\n\n\tif (hop != DPRX)\n\t\tdpcd_tps_offset = DP_TRAINING_PATTERN_SET_PHY_REPEATER1 +\n\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (hop - 1));\n\n\tstatus = core_link_write_dpcd(\n\t\t\tlink,\n\t\t\tdpcd_tps_offset,\n\t\t\t&dpcd_pattern.raw,\n\t\t\tsizeof(dpcd_pattern.raw));\n\n\treturn status;\n}\n\n \nstatic enum link_training_result dpia_training_end(\n\t\tstruct dc_link *link,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tenum link_training_result result = LINK_TRAINING_SUCCESS;\n\tuint8_t repeater_cnt = 0;  \n\tenum dc_status status;\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT) {\n\n\t\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\t\tif (hop == repeater_cnt) {  \n\t\t\t \n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_TRAINING,\n\t\t\t\t\tDPIA_TS_UFP_DONE);\n\t\t\tif (status != DC_OK)\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t} else {  \n\t\t\t \n\t\t\tstatus = dpcd_clear_lt_pattern(link, hop);\n\t\t\tif (status != DC_OK)\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t}\n\n\t\t \n\t\tif (hop == DPRX && result != LINK_TRAINING_ABORT) {\n\t\t\tstatus = core_link_send_set_config(\n\t\t\t\t\tlink,\n\t\t\t\t\tDPIA_SET_CFG_SET_TRAINING,\n\t\t\t\t\tDPIA_TS_DPRX_DONE);\n\t\t\tif (status != DC_OK)\n\t\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t}\n\n\t} else {  \n\n\t\t \n\t\tstatus = dpcd_clear_lt_pattern(link, hop);\n\t\tif (status != DC_OK)\n\t\t\tresult = LINK_TRAINING_ABORT;\n\n\t}\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n DPIA(%d) end\\n - hop(%d)\\n - result(%d)\\n - LTTPR mode(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\thop,\n\t\tresult,\n\t\tlt_settings->lttpr_mode);\n\n\treturn result;\n}\n\n \nstatic void dpia_training_abort(\n\t\tstruct dc_link *link,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t hop)\n{\n\tuint8_t data = 0;\n\tuint32_t dpcd_tps_offset = DP_TRAINING_PATTERN_SET;\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n DPIA(%d) aborting\\n - LTTPR mode(%d)\\n - HPD(%d)\\n\",\n\t\t__func__,\n\t\tlink->link_id.enum_id - ENUM_ID_1,\n\t\tlt_settings->lttpr_mode,\n\t\tlink->is_hpd_pending);\n\n\t \n\tif (link->is_hpd_pending)\n\t\treturn;\n\n\tif (hop != DPRX)\n\t\tdpcd_tps_offset = DP_TRAINING_PATTERN_SET_PHY_REPEATER1 +\n\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (hop - 1));\n\n\tcore_link_write_dpcd(link, dpcd_tps_offset, &data, 1);\n\tcore_link_write_dpcd(link, DP_LINK_BW_SET, &data, 1);\n\tcore_link_write_dpcd(link, DP_LANE_COUNT_SET, &data, 1);\n\tcore_link_send_set_config(link, DPIA_SET_CFG_SET_LINK, data);\n}\n\nenum link_training_result dpia_perform_link_training(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tconst struct dc_link_settings *link_setting,\n\tbool skip_video_pattern)\n{\n\tenum link_training_result result;\n\tstruct link_training_settings lt_settings = {0};\n\tuint8_t repeater_cnt = 0;  \n\tint8_t repeater_id;  \n\n\tstruct dc_link_settings link_settings = *link_setting; \n\n\tlt_settings.lttpr_mode = dp_decide_lttpr_mode(link, &link_settings);\n\n\t \n\tresult = dpia_configure_link(link, link_res, link_setting, &lt_settings);\n\tif (result != LINK_TRAINING_SUCCESS)\n\t\treturn result;\n\n\tif (lt_settings.lttpr_mode == LTTPR_MODE_NON_TRANSPARENT)\n\t\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\t \n\tfor (repeater_id = repeater_cnt; repeater_id >= 0; repeater_id--) {\n\t\t \n\t\tresult = dpia_training_cr_phase(link, link_res, &lt_settings, repeater_id);\n\t\tif (result != LINK_TRAINING_SUCCESS)\n\t\t\tbreak;\n\n\t\t \n\t\tresult = dpia_training_eq_phase(link, link_res, &lt_settings, repeater_id);\n\t\tif (result != LINK_TRAINING_SUCCESS)\n\t\t\tbreak;\n\n\t\t \n\t\tresult = dpia_training_end(link, &lt_settings, repeater_id);\n\t\tif (result != LINK_TRAINING_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (result == LINK_TRAINING_SUCCESS) {\n\t\tfsleep(5000);\n\t\tif (!link->is_automated)\n\t\t\tresult = dp_check_link_loss_status(link, &lt_settings);\n\t} else if (result == LINK_TRAINING_ABORT)\n\t\tdpia_training_abort(link, &lt_settings, repeater_id);\n\telse\n\t\tdpia_training_end(link, &lt_settings, repeater_id);\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}