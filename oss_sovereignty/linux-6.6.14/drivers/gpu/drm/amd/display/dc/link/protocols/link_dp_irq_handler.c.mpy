{
  "module_name": "link_dp_irq_handler.c",
  "hash_id": "bb21cc1e45e606cde7db59d91a9d9e317a7a411455f4ee49356afd66a1095510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_irq_handler.c",
  "human_readable_source": " \n\n \n\n#include \"link_dp_irq_handler.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_training.h\"\n#include \"link_dp_capability.h\"\n#include \"link_edp_panel_control.h\"\n#include \"link/accessories/link_dp_trace.h\"\n#include \"link/link_dpms.h\"\n#include \"dm_helpers.h\"\n\n#define DC_LOGGER_INIT(logger)\n\nbool dp_parse_link_loss_status(\n\tstruct dc_link *link,\n\tunion hpd_irq_data *hpd_irq_dpcd_data)\n{\n\tuint8_t irq_reg_rx_power_state = 0;\n\tenum dc_status dpcd_result = DC_ERROR_UNEXPECTED;\n\tunion lane_status lane_status;\n\tuint32_t lane;\n\tbool sink_status_changed;\n\tbool return_code;\n\n\tsink_status_changed = false;\n\treturn_code = false;\n\n\tif (link->cur_link_settings.lane_count == 0)\n\t\treturn return_code;\n\n\t \n\n\t \n\tfor (lane = 0; lane < link->cur_link_settings.lane_count; lane++) {\n\t\t \n\t\tlane_status.raw = dp_get_nibble_at_index(\n\t\t\t&hpd_irq_dpcd_data->bytes.lane01_status.raw,\n\t\t\tlane);\n\n\t\tif (!lane_status.bits.CHANNEL_EQ_DONE_0 ||\n\t\t\t!lane_status.bits.CR_DONE_0 ||\n\t\t\t!lane_status.bits.SYMBOL_LOCKED_0) {\n\t\t\t \n\t\t\tsink_status_changed = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (link_dp_get_encoding_format(&link->cur_link_settings) == DP_128b_132b_ENCODING &&\n\t\t\t(!hpd_irq_dpcd_data->bytes.lane_status_updated.bits.EQ_INTERLANE_ALIGN_DONE_128b_132b ||\n\t\t\t !hpd_irq_dpcd_data->bytes.lane_status_updated.bits.CDS_INTERLANE_ALIGN_DONE_128b_132b)) {\n\t\tsink_status_changed = true;\n\t} else if (!hpd_irq_dpcd_data->bytes.lane_status_updated.bits.INTERLANE_ALIGN_DONE) {\n\t\tsink_status_changed = true;\n\t}\n\n\tif (sink_status_changed) {\n\n\t\tDC_LOG_HW_HPD_IRQ(\"%s: Link Status changed.\\n\", __func__);\n\n\t\treturn_code = true;\n\n\t\t \n\t\tdpcd_result = core_link_read_dpcd(link,\n\t\t\tDP_SET_POWER,\n\t\t\t&irq_reg_rx_power_state,\n\t\t\tsizeof(irq_reg_rx_power_state));\n\n\t\tif (dpcd_result != DC_OK) {\n\t\t\tDC_LOG_HW_HPD_IRQ(\"%s: DPCD read failed to obtain power state.\\n\",\n\t\t\t\t__func__);\n\t\t} else {\n\t\t\tif (irq_reg_rx_power_state != DP_SET_POWER_D0)\n\t\t\t\treturn_code = false;\n\t\t}\n\t}\n\n\treturn return_code;\n}\n\nstatic bool handle_hpd_irq_psr_sink(struct dc_link *link)\n{\n\tunion dpcd_psr_configuration psr_configuration;\n\n\tif (!link->psr_settings.psr_feature_enabled)\n\t\treturn false;\n\n\tdm_helpers_dp_read_dpcd(\n\t\tlink->ctx,\n\t\tlink,\n\t\t368, \n\t\t&psr_configuration.raw,\n\t\tsizeof(psr_configuration.raw));\n\n\tif (psr_configuration.bits.ENABLE) {\n\t\tunsigned char dpcdbuf[3] = {0};\n\t\tunion psr_error_status psr_error_status;\n\t\tunion psr_sink_psr_status psr_sink_psr_status;\n\n\t\tdm_helpers_dp_read_dpcd(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\t0x2006,  \n\t\t\t(unsigned char *) dpcdbuf,\n\t\t\tsizeof(dpcdbuf));\n\n\t\t \n\t\tpsr_error_status.raw = dpcdbuf[0];\n\t\t \n\t\tpsr_sink_psr_status.raw = dpcdbuf[2];\n\n\t\tif (psr_error_status.bits.LINK_CRC_ERROR ||\n\t\t\t\tpsr_error_status.bits.RFB_STORAGE_ERROR ||\n\t\t\t\tpsr_error_status.bits.VSC_SDP_ERROR) {\n\t\t\tbool allow_active;\n\n\t\t\t \n\t\t\tdm_helpers_dp_write_dpcd(\n\t\t\t\tlink->ctx,\n\t\t\t\tlink,\n\t\t\t\t8198, \n\t\t\t\t&psr_error_status.raw,\n\t\t\t\tsizeof(psr_error_status.raw));\n\n\t\t\t \n\t\t\tif (link->psr_settings.psr_allow_active) {\n\t\t\t\tallow_active = false;\n\t\t\t\tedp_set_psr_allow_active(link, &allow_active, true, false, NULL);\n\t\t\t\tallow_active = true;\n\t\t\t\tedp_set_psr_allow_active(link, &allow_active, true, false, NULL);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (psr_sink_psr_status.bits.SINK_SELF_REFRESH_STATUS ==\n\t\t\t\tPSR_SINK_STATE_ACTIVE_DISPLAY_FROM_SINK_RFB){\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool handle_hpd_irq_replay_sink(struct dc_link *link)\n{\n\tunion dpcd_replay_configuration replay_configuration;\n\t \n\tunion psr_error_status replay_error_status;\n\n\tif (!link->replay_settings.replay_feature_enabled)\n\t\treturn false;\n\n\tdm_helpers_dp_read_dpcd(\n\t\tlink->ctx,\n\t\tlink,\n\t\tDP_SINK_PR_REPLAY_STATUS,\n\t\t&replay_configuration.raw,\n\t\tsizeof(replay_configuration.raw));\n\n\tdm_helpers_dp_read_dpcd(\n\t\tlink->ctx,\n\t\tlink,\n\t\tDP_PSR_ERROR_STATUS,\n\t\t&replay_error_status.raw,\n\t\tsizeof(replay_error_status.raw));\n\n\tlink->replay_settings.config.replay_error_status.bits.LINK_CRC_ERROR =\n\t\treplay_error_status.bits.LINK_CRC_ERROR;\n\tlink->replay_settings.config.replay_error_status.bits.DESYNC_ERROR =\n\t\treplay_configuration.bits.DESYNC_ERROR_STATUS;\n\tlink->replay_settings.config.replay_error_status.bits.STATE_TRANSITION_ERROR =\n\t\treplay_configuration.bits.STATE_TRANSITION_ERROR_STATUS;\n\n\tif (link->replay_settings.config.replay_error_status.bits.LINK_CRC_ERROR ||\n\t\tlink->replay_settings.config.replay_error_status.bits.DESYNC_ERROR ||\n\t\tlink->replay_settings.config.replay_error_status.bits.STATE_TRANSITION_ERROR) {\n\t\tbool allow_active;\n\n\t\t \n\t\tdm_helpers_dp_write_dpcd(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\tDP_SINK_PR_REPLAY_STATUS,\n\t\t\t&replay_configuration.raw,\n\t\t\tsizeof(replay_configuration.raw));\n\n\t\t \n\t\tdm_helpers_dp_write_dpcd(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\tDP_PSR_ERROR_STATUS, \n\t\t\t&replay_error_status.raw,\n\t\t\tsizeof(replay_error_status.raw));\n\n\t\t \n\t\tif (link->replay_settings.replay_allow_active) {\n\t\t\tallow_active = false;\n\t\t\tedp_set_replay_allow_active(link, &allow_active, true, false, NULL);\n\t\t\tallow_active = true;\n\t\t\tedp_set_replay_allow_active(link, &allow_active, true, false, NULL);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dp_handle_link_loss(struct dc_link *link)\n{\n\tstruct pipe_ctx *pipes[MAX_PIPES];\n\tstruct dc_state *state = link->dc->current_state;\n\tuint8_t count;\n\tint i;\n\n\tlink_get_master_pipes_with_dpms_on(link, state, &count, pipes);\n\n\tfor (i = 0; i < count; i++)\n\t\tlink_set_dpms_off(pipes[i]);\n\n\tfor (i = count - 1; i >= 0; i--) {\n\t\t\n\t\tif (link->is_automated) {\n\t\t\tpipes[i]->link_config.dp_link_settings.lane_count =\n\t\t\t\t\tlink->verified_link_cap.lane_count;\n\t\t\tpipes[i]->link_config.dp_link_settings.link_rate =\n\t\t\t\t\tlink->verified_link_cap.link_rate;\n\t\t\tpipes[i]->link_config.dp_link_settings.link_spread =\n\t\t\t\t\tlink->verified_link_cap.link_spread;\n\t\t}\n\t\tlink_set_dpms_on(link->dc->current_state, pipes[i]);\n\t}\n}\n\nstatic void read_dpcd204h_on_irq_hpd(struct dc_link *link, union hpd_irq_data *irq_data)\n{\n\tenum dc_status retval;\n\tunion lane_align_status_updated dpcd_lane_status_updated;\n\n\tretval = core_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_LANE_ALIGN_STATUS_UPDATED,\n\t\t\t&dpcd_lane_status_updated.raw,\n\t\t\tsizeof(union lane_align_status_updated));\n\n\tif (retval == DC_OK) {\n\t\tirq_data->bytes.lane_status_updated.bits.EQ_INTERLANE_ALIGN_DONE_128b_132b =\n\t\t\t\tdpcd_lane_status_updated.bits.EQ_INTERLANE_ALIGN_DONE_128b_132b;\n\t\tirq_data->bytes.lane_status_updated.bits.CDS_INTERLANE_ALIGN_DONE_128b_132b =\n\t\t\t\tdpcd_lane_status_updated.bits.CDS_INTERLANE_ALIGN_DONE_128b_132b;\n\t}\n}\n\nenum dc_status dp_read_hpd_rx_irq_data(\n\tstruct dc_link *link,\n\tunion hpd_irq_data *irq_data)\n{\n\tstatic enum dc_status retval;\n\n\t \n\tif (link->dpcd_caps.dpcd_rev.raw < DPCD_REV_14)\n\t\tretval = core_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_SINK_COUNT,\n\t\t\tirq_data->raw,\n\t\t\tsizeof(union hpd_irq_data));\n\telse {\n\t\t \n\n\t\tuint8_t tmp[DP_SINK_STATUS_ESI - DP_SINK_COUNT_ESI + 1];\n\n\t\tretval = core_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_SINK_COUNT_ESI,\n\t\t\ttmp,\n\t\t\tsizeof(tmp));\n\n\t\tif (retval != DC_OK)\n\t\t\treturn retval;\n\n\t\tirq_data->bytes.sink_cnt.raw = tmp[DP_SINK_COUNT_ESI - DP_SINK_COUNT_ESI];\n\t\tirq_data->bytes.device_service_irq.raw = tmp[DP_DEVICE_SERVICE_IRQ_VECTOR_ESI0 - DP_SINK_COUNT_ESI];\n\t\tirq_data->bytes.lane01_status.raw = tmp[DP_LANE0_1_STATUS_ESI - DP_SINK_COUNT_ESI];\n\t\tirq_data->bytes.lane23_status.raw = tmp[DP_LANE2_3_STATUS_ESI - DP_SINK_COUNT_ESI];\n\t\tirq_data->bytes.lane_status_updated.raw = tmp[DP_LANE_ALIGN_STATUS_UPDATED_ESI - DP_SINK_COUNT_ESI];\n\t\tirq_data->bytes.sink_status.raw = tmp[DP_SINK_STATUS_ESI - DP_SINK_COUNT_ESI];\n\n\t\t \n\t\tif (link->wa_flags.read_dpcd204h_on_irq_hpd)\n\t\t\tread_dpcd204h_on_irq_hpd(link, irq_data);\n\t}\n\n\treturn retval;\n}\n\n \nbool dp_should_allow_hpd_rx_irq(const struct dc_link *link)\n{\n\t \n\n\tif ((link->cur_link_settings.lane_count != LANE_COUNT_UNKNOWN) ||\n\t\tis_dp_branch_device(link))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool dp_handle_hpd_rx_irq(struct dc_link *link,\n\t\tunion hpd_irq_data *out_hpd_irq_dpcd_data, bool *out_link_loss,\n\t\tbool defer_handling, bool *has_left_work)\n{\n\tunion hpd_irq_data hpd_irq_dpcd_data = {0};\n\tunion device_service_irq device_service_clear = {0};\n\tenum dc_status result;\n\tbool status = false;\n\n\tif (out_link_loss)\n\t\t*out_link_loss = false;\n\n\tif (has_left_work)\n\t\t*has_left_work = false;\n\t \n\n\tDC_LOG_HW_HPD_IRQ(\"%s: Got short pulse HPD on link %d\\n\",\n\t\t__func__, link->link_index);\n\n\n\t  \n\tresult = dp_read_hpd_rx_irq_data(link, &hpd_irq_dpcd_data);\n\tif (out_hpd_irq_dpcd_data)\n\t\t*out_hpd_irq_dpcd_data = hpd_irq_dpcd_data;\n\n\tif (result != DC_OK) {\n\t\tDC_LOG_HW_HPD_IRQ(\"%s: DPCD read failed to obtain irq data\\n\",\n\t\t\t__func__);\n\t\treturn false;\n\t}\n\n\tif (hpd_irq_dpcd_data.bytes.device_service_irq.bits.AUTOMATED_TEST) {\n\t\t \n\t\tlink->is_automated = true;\n\t\tdevice_service_clear.bits.AUTOMATED_TEST = 1;\n\t\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_DEVICE_SERVICE_IRQ_VECTOR,\n\t\t\t&device_service_clear.raw,\n\t\t\tsizeof(device_service_clear.raw));\n\t\tdevice_service_clear.raw = 0;\n\t\tif (defer_handling && has_left_work)\n\t\t\t*has_left_work = true;\n\t\telse\n\t\t\tdc_link_dp_handle_automated_test(link);\n\t\treturn false;\n\t}\n\n\tif (!dp_should_allow_hpd_rx_irq(link)) {\n\t\tDC_LOG_HW_HPD_IRQ(\"%s: skipping HPD handling on %d\\n\",\n\t\t\t__func__, link->link_index);\n\t\treturn false;\n\t}\n\n\tif (handle_hpd_irq_psr_sink(link))\n\t\t \n\t\treturn true;\n\n\tif (handle_hpd_irq_replay_sink(link))\n\t\t \n\t\treturn true;\n\n\t \n\n\tif (hpd_irq_dpcd_data.bytes.device_service_irq.bits.UP_REQ_MSG_RDY) {\n\t\tif (defer_handling && has_left_work)\n\t\t\t*has_left_work = true;\n\t\treturn true;\n\t}\n\n\t \n\tif (hpd_irq_dpcd_data.bytes.device_service_irq.bits.DOWN_REP_MSG_RDY) {\n\t\tif (defer_handling && has_left_work)\n\t\t\t*has_left_work = true;\n\t\treturn false;\n\t}\n\n\t \n\tif ((link->connector_signal != SIGNAL_TYPE_EDP) &&\n\t\t\tdp_parse_link_loss_status(\n\t\t\t\t\tlink,\n\t\t\t\t\t&hpd_irq_dpcd_data)) {\n\t\t \n\t\tCONN_DATA_LINK_LOSS(link,\n\t\t\t\t\thpd_irq_dpcd_data.raw,\n\t\t\t\t\tsizeof(hpd_irq_dpcd_data),\n\t\t\t\t\t\"Status: \");\n\n\t\tif (defer_handling && has_left_work)\n\t\t\t*has_left_work = true;\n\t\telse\n\t\t\tdp_handle_link_loss(link);\n\n\t\tstatus = false;\n\t\tif (out_link_loss)\n\t\t\t*out_link_loss = true;\n\n\t\tdp_trace_link_loss_increment(link);\n\t}\n\n\tif (link->type == dc_connection_sst_branch &&\n\t\thpd_irq_dpcd_data.bytes.sink_cnt.bits.SINK_COUNT\n\t\t\t!= link->dpcd_sink_count)\n\t\tstatus = true;\n\n\t \n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}