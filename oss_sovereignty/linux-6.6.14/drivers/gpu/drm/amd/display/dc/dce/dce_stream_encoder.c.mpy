{
  "module_name": "dce_stream_encoder.c",
  "hash_id": "1cdd3346c94c5ac5187fa76520c6dc92b9398448e139d415aa01b6bcb8669aba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_stream_encoder.c",
  "human_readable_source": " \n\n#include \"dc_bios_types.h\"\n#include \"dce_stream_encoder.h\"\n#include \"reg_helper.h\"\n#include \"hw_shared.h\"\n\n#define DC_LOGGER \\\n\t\tenc110->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc110->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc110->se_shift->field_name, enc110->se_mask->field_name\n\n#define VBI_LINE_0 0\n#define DP_BLANK_MAX_RETRY 20\n#define HDMI_CLOCK_CHANNEL_RATE_MORE_340M 340000\n\n#ifndef TMDS_CNTL__TMDS_PIXEL_ENCODING_MASK\n\t#define TMDS_CNTL__TMDS_PIXEL_ENCODING_MASK       0x00000010L\n\t#define TMDS_CNTL__TMDS_COLOR_FORMAT_MASK         0x00000300L\n\t#define\tTMDS_CNTL__TMDS_PIXEL_ENCODING__SHIFT     0x00000004\n\t#define\tTMDS_CNTL__TMDS_COLOR_FORMAT__SHIFT       0x00000008\n#endif\n\nenum {\n\tDP_MST_UPDATE_MAX_RETRY = 50\n};\n\n#define DCE110_SE(audio)\\\n\tcontainer_of(audio, struct dce110_stream_encoder, base)\n\n#define CTX \\\n\tenc110->base.ctx\n\nstatic void dce110_update_generic_info_packet(\n\tstruct dce110_stream_encoder *enc110,\n\tuint32_t packet_index,\n\tconst struct dc_info_packet *info_packet)\n{\n\t \n\tuint32_t max_retries = 50;\n\n\t \n\tif (REG(AFMT_CNTL))\n\t\tREG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, 1);\n\n\tif (REG(AFMT_VBI_PACKET_CONTROL1)) {\n\t\tif (packet_index >= 8)\n\t\t\tASSERT(0);\n\n\t\t \n \n\n\t\t \n\t\tREG_WAIT(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT,\n\t\t\t\t0, 10, max_retries);\n\n\t\t \n\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT_CLR, 1);\n\t}\n\t \n\t{\n\t\tREG_READ(AFMT_VBI_PACKET_CONTROL);\n\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL,\n\t\t\t\tAFMT_GENERIC_INDEX, packet_index);\n\t}\n\n\t \n\t{\n\t\tREG_SET_4(AFMT_GENERIC_HDR, 0,\n\t\t\t\tAFMT_GENERIC_HB0, info_packet->hb0,\n\t\t\t\tAFMT_GENERIC_HB1, info_packet->hb1,\n\t\t\t\tAFMT_GENERIC_HB2, info_packet->hb2,\n\t\t\t\tAFMT_GENERIC_HB3, info_packet->hb3);\n\t}\n\n\t \n\t{\n\t\tconst uint32_t *content =\n\t\t\t(const uint32_t *) &info_packet->sb[0];\n\n\t\tREG_WRITE(AFMT_GENERIC_0, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_1, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_2, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_3, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_4, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_5, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_6, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_7, *content);\n\t}\n\n\tif (!REG(AFMT_VBI_PACKET_CONTROL1)) {\n\t\t \n\t\tREG_UPDATE_2(AFMT_VBI_PACKET_CONTROL,\n\t\t\tAFMT_GENERIC0_UPDATE, (packet_index == 0),\n\t\t\tAFMT_GENERIC2_UPDATE, (packet_index == 2));\n\t}\n\n\tif (REG(AFMT_VBI_PACKET_CONTROL1)) {\n\t\tswitch (packet_index) {\n\t\tcase 0:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC0_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC1_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC2_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC3_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC4_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC5_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC6_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL1,\n\t\t\t\t\tAFMT_GENERIC7_FRAME_UPDATE, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void dce110_update_hdmi_info_packet(\n\tstruct dce110_stream_encoder *enc110,\n\tuint32_t packet_index,\n\tconst struct dc_info_packet *info_packet)\n{\n\tuint32_t cont, send, line;\n\n\tif (info_packet->valid) {\n\t\tdce110_update_generic_info_packet(\n\t\t\tenc110,\n\t\t\tpacket_index,\n\t\t\tinfo_packet);\n\n\t\t \n\t\tcont = 1;\n\t\t \n\t\tsend = 1;\n\t\t \n\t\tline = 2;\n\t} else {\n\t\tcont = 0;\n\t\tsend = 0;\n\t\tline = 0;\n\t}\n\n\t \n\tswitch (packet_index) {\n\tcase 0:\n\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC0_CONT, cont,\n\t\t\t\tHDMI_GENERIC0_SEND, send,\n\t\t\t\tHDMI_GENERIC0_LINE, line);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC1_CONT, cont,\n\t\t\t\tHDMI_GENERIC1_SEND, send,\n\t\t\t\tHDMI_GENERIC1_LINE, line);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL1,\n\t\t\t\tHDMI_GENERIC0_CONT, cont,\n\t\t\t\tHDMI_GENERIC0_SEND, send,\n\t\t\t\tHDMI_GENERIC0_LINE, line);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL1,\n\t\t\t\tHDMI_GENERIC1_CONT, cont,\n\t\t\t\tHDMI_GENERIC1_SEND, send,\n\t\t\t\tHDMI_GENERIC1_LINE, line);\n\t\tbreak;\n\tcase 4:\n\t\tif (REG(HDMI_GENERIC_PACKET_CONTROL2))\n\t\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL2,\n\t\t\t\t\tHDMI_GENERIC0_CONT, cont,\n\t\t\t\t\tHDMI_GENERIC0_SEND, send,\n\t\t\t\t\tHDMI_GENERIC0_LINE, line);\n\t\tbreak;\n\tcase 5:\n\t\tif (REG(HDMI_GENERIC_PACKET_CONTROL2))\n\t\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL2,\n\t\t\t\t\tHDMI_GENERIC1_CONT, cont,\n\t\t\t\t\tHDMI_GENERIC1_SEND, send,\n\t\t\t\t\tHDMI_GENERIC1_LINE, line);\n\t\tbreak;\n\tcase 6:\n\t\tif (REG(HDMI_GENERIC_PACKET_CONTROL3))\n\t\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL3,\n\t\t\t\t\tHDMI_GENERIC0_CONT, cont,\n\t\t\t\t\tHDMI_GENERIC0_SEND, send,\n\t\t\t\t\tHDMI_GENERIC0_LINE, line);\n\t\tbreak;\n\tcase 7:\n\t\tif (REG(HDMI_GENERIC_PACKET_CONTROL3))\n\t\t\tREG_UPDATE_3(HDMI_GENERIC_PACKET_CONTROL3,\n\t\t\t\t\tHDMI_GENERIC1_CONT, cont,\n\t\t\t\t\tHDMI_GENERIC1_SEND, send,\n\t\t\t\t\tHDMI_GENERIC1_LINE, line);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDC_LOG_WARNING(\n\t\t\t\"Invalid HW packet index: %s()\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n}\n\n \nstatic void dce110_stream_encoder_dp_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tenum dc_color_space output_color_space,\n\tbool use_vsc_sdp_for_colorimetry,\n\tuint32_t enable_sdp_splitting)\n{\n\tuint32_t h_active_start;\n\tuint32_t v_active_start;\n\tuint32_t misc0 = 0;\n\tuint32_t misc1 = 0;\n\tuint32_t h_blank;\n\tuint32_t h_back_porch;\n\tuint8_t synchronous_clock = 0;  \n\tuint8_t colorimetry_bpc;\n\tuint8_t dynamic_range_rgb = 0;  \n\tuint8_t dynamic_range_ycbcr = 1;  \n\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tstruct dc_crtc_timing hw_crtc_timing = *crtc_timing;\n\tif (hw_crtc_timing.flags.INTERLACE) {\n\t\t \n\t\thw_crtc_timing.v_total /= 2;\n\t\thw_crtc_timing.v_border_top /= 2;\n\t\thw_crtc_timing.v_addressable /= 2;\n\t\thw_crtc_timing.v_border_bottom /= 2;\n\t\thw_crtc_timing.v_front_porch /= 2;\n\t\thw_crtc_timing.v_sync_width /= 2;\n\t}\n\t \n\tswitch (hw_crtc_timing.pixel_encoding) {\n\tcase PIXEL_ENCODING_YCBCR422:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_ENCODING,\n\t\t\t\tDP_PIXEL_ENCODING_TYPE_YCBCR422);\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR444:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_ENCODING,\n\t\t\t\tDP_PIXEL_ENCODING_TYPE_YCBCR444);\n\n\t\tif (hw_crtc_timing.flags.Y_ONLY)\n\t\t\tif (hw_crtc_timing.display_color_depth != COLOR_DEPTH_666)\n\t\t\t\t \n\t\t\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_ENCODING,\n\t\t\t\t\t\tDP_PIXEL_ENCODING_TYPE_Y_ONLY);\n\t\t \n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR420:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_ENCODING,\n\t\t\t\tDP_PIXEL_ENCODING_TYPE_YCBCR420);\n\t\tif (enc110->se_mask->DP_VID_M_DOUBLE_VALUE_EN)\n\t\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_M_DOUBLE_VALUE_EN, 1);\n\n\t\tif (enc110->se_mask->DP_VID_N_MUL)\n\t\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_N_MUL, 1);\n\t\tbreak;\n\tdefault:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_ENCODING,\n\t\t\t\tDP_PIXEL_ENCODING_TYPE_RGB444);\n\t\tbreak;\n\t}\n\n\tif (REG(DP_MSA_MISC))\n\t\tmisc1 = REG_READ(DP_MSA_MISC);\n\n\t \n\n\tswitch (hw_crtc_timing.display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_COMPONENT_DEPTH,\n\t\t\t\t0);\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_COMPONENT_DEPTH,\n\t\t\t\tDP_COMPONENT_PIXEL_DEPTH_8BPC);\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_COMPONENT_DEPTH,\n\t\t\t\tDP_COMPONENT_PIXEL_DEPTH_10BPC);\n\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_COMPONENT_DEPTH,\n\t\t\t\tDP_COMPONENT_PIXEL_DEPTH_12BPC);\n\t\tbreak;\n\tdefault:\n\t\tREG_UPDATE(DP_PIXEL_FORMAT, DP_COMPONENT_DEPTH,\n\t\t\t\tDP_COMPONENT_PIXEL_DEPTH_6BPC);\n\t\tbreak;\n\t}\n\n\t \n\n\n\tswitch (hw_crtc_timing.display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tcolorimetry_bpc = 0;\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tcolorimetry_bpc = 1;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tcolorimetry_bpc = 2;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tcolorimetry_bpc = 3;\n\t\tbreak;\n\tdefault:\n\t\tcolorimetry_bpc = 0;\n\t\tbreak;\n\t}\n\n\tmisc0 = misc0 | synchronous_clock;\n\tmisc0 = colorimetry_bpc << 5;\n\n\tif (REG(DP_MSA_TIMING_PARAM1)) {\n\t\tswitch (output_color_space) {\n\t\tcase COLOR_SPACE_SRGB:\n\t\t\tmisc0 = misc0 | 0x0;\n\t\t\tmisc1 = misc1 & ~0x80;  \n\t\t\tdynamic_range_rgb = 0;  \n\t\t\tbreak;\n\t\tcase COLOR_SPACE_SRGB_LIMITED:\n\t\t\tmisc0 = misc0 | 0x8;  \n\t\t\tmisc1 = misc1 & ~0x80;  \n\t\t\tdynamic_range_rgb = 1;  \n\t\t\tbreak;\n\t\tcase COLOR_SPACE_YCBCR601:\n\t\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\t\t\tmisc0 = misc0 | 0x8;  \n\t\t\tmisc1 = misc1 & ~0x80;  \n\t\t\tdynamic_range_ycbcr = 0;  \n\t\t\tif (hw_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\t\t\tmisc0 = misc0 | 0x2;  \n\t\t\telse if (hw_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR444)\n\t\t\t\tmisc0 = misc0 | 0x4;  \n\t\t\tbreak;\n\t\tcase COLOR_SPACE_YCBCR709:\n\t\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\t\tcase COLOR_SPACE_YCBCR709_BLACK:\n\t\t\tmisc0 = misc0 | 0x18;  \n\t\t\tmisc1 = misc1 & ~0x80;  \n\t\t\tdynamic_range_ycbcr = 1;  \n\t\t\tif (hw_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\t\t\tmisc0 = misc0 | 0x2;  \n\t\t\telse if (hw_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR444)\n\t\t\t\tmisc0 = misc0 | 0x4;  \n\t\t\tbreak;\n\t\tcase COLOR_SPACE_2020_RGB_LIMITEDRANGE:\n\t\t\tdynamic_range_rgb = 1;  \n\t\t\tbreak;\n\t\tcase COLOR_SPACE_2020_RGB_FULLRANGE:\n\t\tcase COLOR_SPACE_2020_YCBCR:\n\t\tcase COLOR_SPACE_XR_RGB:\n\t\tcase COLOR_SPACE_MSREF_SCRGB:\n\t\tcase COLOR_SPACE_ADOBERGB:\n\t\tcase COLOR_SPACE_DCIP3:\n\t\tcase COLOR_SPACE_XV_YCC_709:\n\t\tcase COLOR_SPACE_XV_YCC_601:\n\t\tcase COLOR_SPACE_DISPLAYNATIVE:\n\t\tcase COLOR_SPACE_DOLBYVISION:\n\t\tcase COLOR_SPACE_APPCTRL:\n\t\tcase COLOR_SPACE_CUSTOMPOINTS:\n\t\tcase COLOR_SPACE_UNKNOWN:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tif (enc110->se_mask->DP_DYN_RANGE && enc110->se_mask->DP_YCBCR_RANGE)\n\t\t\tREG_UPDATE_2(\n\t\t\t\tDP_PIXEL_FORMAT,\n\t\t\t\tDP_DYN_RANGE, dynamic_range_rgb,\n\t\t\t\tDP_YCBCR_RANGE, dynamic_range_ycbcr);\n\n\t\tif (REG(DP_MSA_COLORIMETRY))\n\t\t\tREG_SET(DP_MSA_COLORIMETRY, 0, DP_MSA_MISC0, misc0);\n\n\t\tif (REG(DP_MSA_MISC))\n\t\t\tREG_WRITE(DP_MSA_MISC, misc1);    \n\n\t \n\t\tif (REG(DP_MSA_TIMING_PARAM1))\n\t\t\tREG_SET_2(DP_MSA_TIMING_PARAM1, 0,\n\t\t\t\t\tDP_MSA_HTOTAL, hw_crtc_timing.h_total,\n\t\t\t\t\tDP_MSA_VTOTAL, hw_crtc_timing.v_total);\n\n\t\t \n\n\t\th_blank = hw_crtc_timing.h_total - hw_crtc_timing.h_border_left -\n\t\t\t\thw_crtc_timing.h_addressable - hw_crtc_timing.h_border_right;\n\n\t\th_back_porch = h_blank - hw_crtc_timing.h_front_porch -\n\t\t\t\thw_crtc_timing.h_sync_width;\n\n\t\t \n\t\th_active_start = hw_crtc_timing.h_sync_width + h_back_porch;\n\n\n\t\tv_active_start = hw_crtc_timing.v_total - hw_crtc_timing.v_border_top -\n\t\t\t\thw_crtc_timing.v_addressable - hw_crtc_timing.v_border_bottom -\n\t\t\t\thw_crtc_timing.v_front_porch;\n\n\n\t\t \n\t\tif (REG(DP_MSA_TIMING_PARAM2))\n\t\t\tREG_SET_2(DP_MSA_TIMING_PARAM2, 0,\n\t\t\t\tDP_MSA_HSTART, h_active_start,\n\t\t\t\tDP_MSA_VSTART, v_active_start);\n\n\t\tif (REG(DP_MSA_TIMING_PARAM3))\n\t\t\tREG_SET_4(DP_MSA_TIMING_PARAM3, 0,\n\t\t\t\t\tDP_MSA_HSYNCWIDTH,\n\t\t\t\t\thw_crtc_timing.h_sync_width,\n\t\t\t\t\tDP_MSA_HSYNCPOLARITY,\n\t\t\t\t\t!hw_crtc_timing.flags.HSYNC_POSITIVE_POLARITY,\n\t\t\t\t\tDP_MSA_VSYNCWIDTH,\n\t\t\t\t\thw_crtc_timing.v_sync_width,\n\t\t\t\t\tDP_MSA_VSYNCPOLARITY,\n\t\t\t\t\t!hw_crtc_timing.flags.VSYNC_POSITIVE_POLARITY);\n\n\t\t \n\t\tif (REG(DP_MSA_TIMING_PARAM4))\n\t\t\tREG_SET_2(DP_MSA_TIMING_PARAM4, 0,\n\t\t\t\tDP_MSA_HWIDTH, hw_crtc_timing.h_border_left +\n\t\t\t\thw_crtc_timing.h_addressable + hw_crtc_timing.h_border_right,\n\t\t\t\tDP_MSA_VHEIGHT, hw_crtc_timing.v_border_top +\n\t\t\t\thw_crtc_timing.v_addressable + hw_crtc_timing.v_border_bottom);\n\t}\n}\n\nstatic void dce110_stream_encoder_set_stream_attribute_helper(\n\t\tstruct dce110_stream_encoder *enc110,\n\t\tstruct dc_crtc_timing *crtc_timing)\n{\n\tif (enc110->regs->TMDS_CNTL) {\n\t\tswitch (crtc_timing->pixel_encoding) {\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\t\tREG_UPDATE(TMDS_CNTL, TMDS_PIXEL_ENCODING, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tREG_UPDATE(TMDS_CNTL, TMDS_PIXEL_ENCODING, 0);\n\t\t\tbreak;\n\t\t}\n\t\tREG_UPDATE(TMDS_CNTL, TMDS_COLOR_FORMAT, 0);\n\t} else if (enc110->regs->DIG_FE_CNTL) {\n\t\tswitch (crtc_timing->pixel_encoding) {\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\t\tREG_UPDATE(DIG_FE_CNTL, TMDS_PIXEL_ENCODING, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tREG_UPDATE(DIG_FE_CNTL, TMDS_PIXEL_ENCODING, 0);\n\t\t\tbreak;\n\t\t}\n\t\tREG_UPDATE(DIG_FE_CNTL, TMDS_COLOR_FORMAT, 0);\n\t}\n\n}\n\n \nstatic void dce110_stream_encoder_hdmi_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tint actual_pix_clk_khz,\n\tbool enable_audio)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tstruct bp_encoder_control cntl = {0};\n\n\tcntl.action = ENCODER_CONTROL_SETUP;\n\tcntl.engine_id = enc110->base.id;\n\tcntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;\n\tcntl.enable_dp_audio = enable_audio;\n\tcntl.pixel_clock = actual_pix_clk_khz;\n\tcntl.lanes_number = LANE_COUNT_FOUR;\n\tcntl.color_depth = crtc_timing->display_color_depth;\n\n\tif (enc110->base.bp->funcs->encoder_control(\n\t\t\tenc110->base.bp, &cntl) != BP_RESULT_OK)\n\t\treturn;\n\n\tdce110_stream_encoder_set_stream_attribute_helper(enc110, crtc_timing);\n\n\t \n\tif (!enc110->se_mask->HDMI_DATA_SCRAMBLE_EN) {\n\t\tREG_UPDATE_3(HDMI_CONTROL,\n\t\t\tHDMI_PACKET_GEN_VERSION, 1,\n\t\t\tHDMI_KEEPOUT_MODE, 1,\n\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n\t} else if (enc110->regs->DIG_FE_CNTL) {\n\t\tREG_UPDATE_5(HDMI_CONTROL,\n\t\t\tHDMI_PACKET_GEN_VERSION, 1,\n\t\t\tHDMI_KEEPOUT_MODE, 1,\n\t\t\tHDMI_DEEP_COLOR_ENABLE, 0,\n\t\t\tHDMI_DATA_SCRAMBLE_EN, 0,\n\t\t\tHDMI_CLOCK_CHANNEL_RATE, 0);\n\t}\n\n\tswitch (crtc_timing->display_color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tREG_UPDATE(HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 0);\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 1,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n\t\t} else {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 1,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\t\t}\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 2,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n\t\t} else {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 2,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\t\t}\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 3,\n\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (enc110->se_mask->HDMI_DATA_SCRAMBLE_EN) {\n\t\tif (actual_pix_clk_khz >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {\n\t\t\t \n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\tHDMI_DATA_SCRAMBLE_EN, 1,\n\t\t\t\tHDMI_CLOCK_CHANNEL_RATE, 1);\n\t\t} else if (crtc_timing->flags.LTE_340MCSC_SCRAMBLE) {\n\n\t\t\t \n\n\t\t\t \n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\tHDMI_DATA_SCRAMBLE_EN, 1,\n\t\t\t\tHDMI_CLOCK_CHANNEL_RATE, 0);\n\t\t}\n\t}\n\n\tREG_UPDATE_3(HDMI_VBI_PACKET_CONTROL,\n\t\tHDMI_GC_CONT, 1,\n\t\tHDMI_GC_SEND, 1,\n\t\tHDMI_NULL_SEND, 1);\n\n\tREG_UPDATE(HDMI_VBI_PACKET_CONTROL, HDMI_ACP_SEND, 0);\n\n\t \n\tREG_UPDATE(HDMI_INFOFRAME_CONTROL0, HDMI_AUDIO_INFO_SEND, 1);\n\n\tREG_UPDATE(AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);\n\n\tREG_UPDATE(HDMI_INFOFRAME_CONTROL1, HDMI_AUDIO_INFO_LINE,\n\t\t\t\tVBI_LINE_0 + 2);\n\n\tREG_UPDATE(HDMI_GC, HDMI_GC_AVMUTE, 0);\n\n}\n\n \nstatic void dce110_stream_encoder_dvi_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tbool is_dual_link)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tstruct bp_encoder_control cntl = {0};\n\n\tcntl.action = ENCODER_CONTROL_SETUP;\n\tcntl.engine_id = enc110->base.id;\n\tcntl.signal = is_dual_link ?\n\t\t\tSIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;\n\tcntl.enable_dp_audio = false;\n\tcntl.pixel_clock = crtc_timing->pix_clk_100hz / 10;\n\tcntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;\n\n\tif (enc110->base.bp->funcs->encoder_control(\n\t\t\tenc110->base.bp, &cntl) != BP_RESULT_OK)\n\t\treturn;\n\n\tASSERT(crtc_timing->pixel_encoding == PIXEL_ENCODING_RGB);\n\tASSERT(crtc_timing->display_color_depth == COLOR_DEPTH_888);\n\tdce110_stream_encoder_set_stream_attribute_helper(enc110, crtc_timing);\n}\n\n \nstatic void dce110_stream_encoder_lvds_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tstruct bp_encoder_control cntl = {0};\n\n\tcntl.action = ENCODER_CONTROL_SETUP;\n\tcntl.engine_id = enc110->base.id;\n\tcntl.signal = SIGNAL_TYPE_LVDS;\n\tcntl.enable_dp_audio = false;\n\tcntl.pixel_clock = crtc_timing->pix_clk_100hz / 10;\n\tcntl.lanes_number = LANE_COUNT_FOUR;\n\n\tif (enc110->base.bp->funcs->encoder_control(\n\t\t\tenc110->base.bp, &cntl) != BP_RESULT_OK)\n\t\treturn;\n\n\tASSERT(crtc_timing->pixel_encoding == PIXEL_ENCODING_RGB);\n}\n\nstatic void dce110_stream_encoder_set_throttled_vcp_size(\n\tstruct stream_encoder *enc,\n\tstruct fixed31_32 avg_time_slots_per_mtp)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tuint32_t x = dc_fixpt_floor(\n\t\tavg_time_slots_per_mtp);\n\tuint32_t y = dc_fixpt_ceil(\n\t\tdc_fixpt_shl(\n\t\t\tdc_fixpt_sub_int(\n\t\t\t\tavg_time_slots_per_mtp,\n\t\t\t\tx),\n\t\t\t26));\n\n\t{\n\t\tREG_SET_2(DP_MSE_RATE_CNTL, 0,\n\t\t\tDP_MSE_RATE_X, x,\n\t\t\tDP_MSE_RATE_Y, y);\n\t}\n\n\t \n\t \n\t \n\tREG_WAIT(DP_MSE_RATE_UPDATE, DP_MSE_RATE_UPDATE_PENDING,\n\t\t\t0,\n\t\t\t10, DP_MST_UPDATE_MAX_RETRY);\n}\n\nstatic void dce110_stream_encoder_update_hdmi_info_packets(\n\tstruct stream_encoder *enc,\n\tconst struct encoder_info_frame *info_frame)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tif (enc110->se_mask->HDMI_AVI_INFO_CONT &&\n\t\t\tenc110->se_mask->HDMI_AVI_INFO_SEND) {\n\n\t\tif (info_frame->avi.valid) {\n\t\t\tconst uint32_t *content =\n\t\t\t\t(const uint32_t *) &info_frame->avi.sb[0];\n\t\t\t \n\t\t\tif (REG(AFMT_CNTL))\n\t\t\t\tREG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, 1);\n\n\t\t\tREG_WRITE(AFMT_AVI_INFO0, content[0]);\n\n\t\t\tREG_WRITE(AFMT_AVI_INFO1, content[1]);\n\n\t\t\tREG_WRITE(AFMT_AVI_INFO2, content[2]);\n\n\t\t\tREG_WRITE(AFMT_AVI_INFO3, content[3]);\n\n\t\t\tREG_UPDATE(AFMT_AVI_INFO3, AFMT_AVI_INFO_VERSION,\n\t\t\t\t\t\tinfo_frame->avi.hb1);\n\n\t\t\tREG_UPDATE_2(HDMI_INFOFRAME_CONTROL0,\n\t\t\t\t\tHDMI_AVI_INFO_SEND, 1,\n\t\t\t\t\tHDMI_AVI_INFO_CONT, 1);\n\n\t\t\tREG_UPDATE(HDMI_INFOFRAME_CONTROL1, HDMI_AVI_INFO_LINE,\n\t\t\t\t\t\t\tVBI_LINE_0 + 2);\n\n\t\t} else {\n\t\t\tREG_UPDATE_2(HDMI_INFOFRAME_CONTROL0,\n\t\t\t\tHDMI_AVI_INFO_SEND, 0,\n\t\t\t\tHDMI_AVI_INFO_CONT, 0);\n\t\t}\n\t}\n\n\tif (enc110->se_mask->HDMI_AVI_INFO_CONT &&\n\t\t\tenc110->se_mask->HDMI_AVI_INFO_SEND) {\n\t\tdce110_update_hdmi_info_packet(enc110, 0, &info_frame->vendor);\n\t\tdce110_update_hdmi_info_packet(enc110, 1, &info_frame->gamut);\n\t\tdce110_update_hdmi_info_packet(enc110, 2, &info_frame->spd);\n\t\tdce110_update_hdmi_info_packet(enc110, 3, &info_frame->hdrsmd);\n\t}\n\n\tif (enc110->se_mask->HDMI_DB_DISABLE) {\n\t\t \n\t\tif (REG(HDMI_DB_CONTROL))\n\t\t\tREG_UPDATE(HDMI_DB_CONTROL, HDMI_DB_DISABLE, 1);\n\n\t\tdce110_update_hdmi_info_packet(enc110, 0, &info_frame->avi);\n\t\tdce110_update_hdmi_info_packet(enc110, 1, &info_frame->vendor);\n\t\tdce110_update_hdmi_info_packet(enc110, 2, &info_frame->gamut);\n\t\tdce110_update_hdmi_info_packet(enc110, 3, &info_frame->spd);\n\t\tdce110_update_hdmi_info_packet(enc110, 4, &info_frame->hdrsmd);\n\t}\n}\n\nstatic void dce110_stream_encoder_stop_hdmi_info_packets(\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\t \n\tREG_SET_6(HDMI_GENERIC_PACKET_CONTROL0, 0,\n\t\tHDMI_GENERIC1_CONT, 0,\n\t\tHDMI_GENERIC1_LINE, 0,\n\t\tHDMI_GENERIC1_SEND, 0,\n\t\tHDMI_GENERIC0_CONT, 0,\n\t\tHDMI_GENERIC0_LINE, 0,\n\t\tHDMI_GENERIC0_SEND, 0);\n\n\t \n\tREG_SET_6(HDMI_GENERIC_PACKET_CONTROL1, 0,\n\t\tHDMI_GENERIC0_CONT, 0,\n\t\tHDMI_GENERIC0_LINE, 0,\n\t\tHDMI_GENERIC0_SEND, 0,\n\t\tHDMI_GENERIC1_CONT, 0,\n\t\tHDMI_GENERIC1_LINE, 0,\n\t\tHDMI_GENERIC1_SEND, 0);\n\n\t \n\tif (REG(HDMI_GENERIC_PACKET_CONTROL2))\n\t\tREG_SET_6(HDMI_GENERIC_PACKET_CONTROL2, 0,\n\t\t\tHDMI_GENERIC0_CONT, 0,\n\t\t\tHDMI_GENERIC0_LINE, 0,\n\t\t\tHDMI_GENERIC0_SEND, 0,\n\t\t\tHDMI_GENERIC1_CONT, 0,\n\t\t\tHDMI_GENERIC1_LINE, 0,\n\t\t\tHDMI_GENERIC1_SEND, 0);\n\n\tif (REG(HDMI_GENERIC_PACKET_CONTROL3))\n\t\tREG_SET_6(HDMI_GENERIC_PACKET_CONTROL3, 0,\n\t\t\tHDMI_GENERIC0_CONT, 0,\n\t\t\tHDMI_GENERIC0_LINE, 0,\n\t\t\tHDMI_GENERIC0_SEND, 0,\n\t\t\tHDMI_GENERIC1_CONT, 0,\n\t\t\tHDMI_GENERIC1_LINE, 0,\n\t\t\tHDMI_GENERIC1_SEND, 0);\n}\n\nstatic void dce110_stream_encoder_update_dp_info_packets(\n\tstruct stream_encoder *enc,\n\tconst struct encoder_info_frame *info_frame)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tuint32_t value = 0;\n\n\tif (info_frame->vsc.valid)\n\t\tdce110_update_generic_info_packet(\n\t\t\t\t\tenc110,\n\t\t\t\t\t0,   \n\t\t\t\t\t&info_frame->vsc);\n\n\tif (info_frame->spd.valid)\n\t\tdce110_update_generic_info_packet(\n\t\t\t\tenc110,\n\t\t\t\t2,   \n\t\t\t\t&info_frame->spd);\n\n\tif (info_frame->hdrsmd.valid)\n\t\tdce110_update_generic_info_packet(\n\t\t\t\tenc110,\n\t\t\t\t3,   \n\t\t\t\t&info_frame->hdrsmd);\n\n\t \n\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_GSP0_ENABLE, info_frame->vsc.valid);\n\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_GSP2_ENABLE, info_frame->spd.valid);\n\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_GSP3_ENABLE, info_frame->hdrsmd.valid);\n\n\t \n\tvalue = REG_READ(DP_SEC_CNTL);\n\tif (value)\n\t\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);\n}\n\nstatic void dce110_stream_encoder_stop_dp_info_packets(\n\tstruct stream_encoder *enc)\n{\n\t \n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tuint32_t value = 0;\n\n\tif (enc110->se_mask->DP_SEC_AVI_ENABLE) {\n\t\tREG_SET_7(DP_SEC_CNTL, 0,\n\t\t\tDP_SEC_GSP0_ENABLE, 0,\n\t\t\tDP_SEC_GSP1_ENABLE, 0,\n\t\t\tDP_SEC_GSP2_ENABLE, 0,\n\t\t\tDP_SEC_GSP3_ENABLE, 0,\n\t\t\tDP_SEC_AVI_ENABLE, 0,\n\t\t\tDP_SEC_MPG_ENABLE, 0,\n\t\t\tDP_SEC_STREAM_ENABLE, 0);\n\t}\n\n\t \n\tvalue = REG_READ(DP_SEC_CNTL);\n\tif (value)\n\t\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);\n\n}\n\nstatic void dce110_stream_encoder_dp_blank(\n\tstruct dc_link *link,\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tuint32_t  reg1 = 0;\n\tuint32_t max_retries = DP_BLANK_MAX_RETRY * 10;\n\n\t \n\tREG_GET(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, &reg1);\n\tif ((reg1 & 0x1) == 0)\n\t\t \n\t\treturn;\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_DIS_DEFER, 2);\n\t \n\tmax_retries = DP_BLANK_MAX_RETRY * 150;\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, 0);\n\n\t \n\n\tREG_WAIT(DP_VID_STREAM_CNTL, DP_VID_STREAM_STATUS,\n\t\t\t0,\n\t\t\t10, max_retries);\n\n\t \n\n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, true);\n}\n\n \nstatic void dce110_stream_encoder_dp_unblank(\n\tstruct dc_link *link,\n\tstruct stream_encoder *enc,\n\tconst struct encoder_unblank_param *param)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tif (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {\n\t\tuint32_t n_vid = 0x8000;\n\t\tuint32_t m_vid;\n\n\t\t \n\n\t\tuint64_t m_vid_l = n_vid;\n\n\t\tm_vid_l *= param->timing.pix_clk_100hz / 10;\n\t\tm_vid_l = div_u64(m_vid_l,\n\t\t\tparam->link_settings.link_rate\n\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ);\n\n\t\tm_vid = (uint32_t) m_vid_l;\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 0);\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_N, DP_VID_N, n_vid);\n\n\t\tREG_UPDATE(DP_VID_M, DP_VID_M, m_vid);\n\n\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 1);\n\t}\n\n\t \n\n\tREG_UPDATE(DIG_FE_CNTL, DIG_START, 1);\n\n\t \n\n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);\n\n\t \n\tudelay(100);\n\n\t \n\n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, true);\n}\n\nstatic void dce110_stream_encoder_set_avmute(\n\tstruct stream_encoder *enc,\n\tbool enable)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tunsigned int value = enable ? 1 : 0;\n\n\tREG_UPDATE(HDMI_GC, HDMI_GC_AVMUTE, value);\n}\n\n\nstatic void dce110_reset_hdmi_stream_attribute(\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tif (enc110->se_mask->HDMI_DATA_SCRAMBLE_EN)\n\t\tREG_UPDATE_5(HDMI_CONTROL,\n\t\t\tHDMI_PACKET_GEN_VERSION, 1,\n\t\t\tHDMI_KEEPOUT_MODE, 1,\n\t\t\tHDMI_DEEP_COLOR_ENABLE, 0,\n\t\t\tHDMI_DATA_SCRAMBLE_EN, 0,\n\t\t\tHDMI_CLOCK_CHANNEL_RATE, 0);\n\telse\n\t\tREG_UPDATE_3(HDMI_CONTROL,\n\t\t\tHDMI_PACKET_GEN_VERSION, 1,\n\t\t\tHDMI_KEEPOUT_MODE, 1,\n\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n}\n\n#define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000\n#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1\n\n#include \"include/audio_types.h\"\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n\nstatic const struct audio_clock_info audio_clock_info_table[16] = {\n\t{2517, 4576, 28125, 7007, 31250, 6864, 28125},\n\t{2518, 4576, 28125, 7007, 31250, 6864, 28125},\n\t{2520, 4096, 25200, 6272, 28000, 6144, 25200},\n\t{2700, 4096, 27000, 6272, 30000, 6144, 27000},\n\t{2702, 4096, 27027, 6272, 30030, 6144, 27027},\n\t{2703, 4096, 27027, 6272, 30030, 6144, 27027},\n\t{5400, 4096, 54000, 6272, 60000, 6144, 54000},\n\t{5405, 4096, 54054, 6272, 60060, 6144, 54054},\n\t{7417, 11648, 210937, 17836, 234375, 11648, 140625},\n\t{7425, 4096, 74250, 6272, 82500, 6144, 74250},\n\t{14835, 11648, 421875, 8918, 234375, 5824, 140625},\n\t{14850, 4096, 148500, 6272, 165000, 6144, 148500},\n\t{29670, 5824, 421875, 4459, 234375, 5824, 281250},\n\t{29700, 3072, 222750, 4704, 247500, 5120, 247500},\n\t{59340, 5824, 843750, 8918, 937500, 5824, 562500},\n\t{59400, 3072, 445500, 9408, 990000, 6144, 594000}\n};\n\nstatic const struct audio_clock_info audio_clock_info_table_36bpc[14] = {\n\t{2517,  9152,  84375,  7007,  48875,  9152,  56250},\n\t{2518,  9152,  84375,  7007,  48875,  9152,  56250},\n\t{2520,  4096,  37800,  6272,  42000,  6144,  37800},\n\t{2700,  4096,  40500,  6272,  45000,  6144,  40500},\n\t{2702,  8192,  81081,  6272,  45045,  8192,  54054},\n\t{2703,  8192,  81081,  6272,  45045,  8192,  54054},\n\t{5400,  4096,  81000,  6272,  90000,  6144,  81000},\n\t{5405,  4096,  81081,  6272,  90090,  6144,  81081},\n\t{7417, 11648, 316406, 17836, 351562, 11648, 210937},\n\t{7425, 4096, 111375,  6272, 123750,  6144, 111375},\n\t{14835, 11648, 632812, 17836, 703125, 11648, 421875},\n\t{14850, 4096, 222750,  6272, 247500,  6144, 222750},\n\t{29670, 5824, 632812,  8918, 703125,  5824, 421875},\n\t{29700, 4096, 445500,  4704, 371250,  5120, 371250}\n};\n\nstatic const struct audio_clock_info audio_clock_info_table_48bpc[14] = {\n\t{2517,  4576,  56250,  7007,  62500,  6864,  56250},\n\t{2518,  4576,  56250,  7007,  62500,  6864,  56250},\n\t{2520,  4096,  50400,  6272,  56000,  6144,  50400},\n\t{2700,  4096,  54000,  6272,  60000,  6144,  54000},\n\t{2702,  4096,  54054,  6267,  60060,  8192,  54054},\n\t{2703,  4096,  54054,  6272,  60060,  8192,  54054},\n\t{5400,  4096, 108000,  6272, 120000,  6144, 108000},\n\t{5405,  4096, 108108,  6272, 120120,  6144, 108108},\n\t{7417, 11648, 421875, 17836, 468750, 11648, 281250},\n\t{7425,  4096, 148500,  6272, 165000,  6144, 148500},\n\t{14835, 11648, 843750,  8918, 468750, 11648, 281250},\n\t{14850, 4096, 297000,  6272, 330000,  6144, 297000},\n\t{29670, 5824, 843750,  4459, 468750,  5824, 562500},\n\t{29700, 3072, 445500,  4704, 495000,  5120, 495000}\n\n\n};\n\nstatic union audio_cea_channels speakers_to_channels(\n\tstruct audio_speaker_flags speaker_flags)\n{\n\tunion audio_cea_channels cea_channels = {0};\n\n\t \n\tcea_channels.channels.FL = speaker_flags.FL_FR;\n\tcea_channels.channels.FR = speaker_flags.FL_FR;\n\tcea_channels.channels.LFE = speaker_flags.LFE;\n\tcea_channels.channels.FC = speaker_flags.FC;\n\n\t \n\tif (speaker_flags.RL_RR) {\n\t\tcea_channels.channels.RL_RC = speaker_flags.RL_RR;\n\t\tcea_channels.channels.RR = speaker_flags.RL_RR;\n\t\tcea_channels.channels.RC_RLC_FLC = speaker_flags.RC;\n\t} else {\n\t\tcea_channels.channels.RL_RC = speaker_flags.RC;\n\t}\n\n\t \n\tif (speaker_flags.FLC_FRC) {\n\t\tcea_channels.channels.RC_RLC_FLC = speaker_flags.FLC_FRC;\n\t\tcea_channels.channels.RRC_FRC = speaker_flags.FLC_FRC;\n\t} else {\n\t\tcea_channels.channels.RC_RLC_FLC = speaker_flags.RLC_RRC;\n\t\tcea_channels.channels.RRC_FRC = speaker_flags.RLC_RRC;\n\t}\n\n\treturn cea_channels;\n}\n\nstatic uint32_t calc_max_audio_packets_per_line(\n\tconst struct audio_crtc_info *crtc_info)\n{\n\tuint32_t max_packets_per_line;\n\n\tmax_packets_per_line =\n\t\tcrtc_info->h_total - crtc_info->h_active;\n\n\tif (crtc_info->pixel_repetition)\n\t\tmax_packets_per_line *= crtc_info->pixel_repetition;\n\n\t \n\tmax_packets_per_line -= 58;\n\t \n\tmax_packets_per_line -= 16;\n\t \n\tmax_packets_per_line /= 32;\n\n\treturn max_packets_per_line;\n}\n\nstatic void get_audio_clock_info(\n\tenum dc_color_depth color_depth,\n\tuint32_t crtc_pixel_clock_100Hz,\n\tuint32_t actual_pixel_clock_100Hz,\n\tstruct audio_clock_info *audio_clock_info)\n{\n\tconst struct audio_clock_info *clock_info;\n\tuint32_t index;\n\tuint32_t crtc_pixel_clock_in_10khz = crtc_pixel_clock_100Hz / 100;\n\tuint32_t audio_array_size;\n\n\tswitch (color_depth) {\n\tcase COLOR_DEPTH_161616:\n\t\tclock_info = audio_clock_info_table_48bpc;\n\t\taudio_array_size = ARRAY_SIZE(\n\t\t\t\taudio_clock_info_table_48bpc);\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tclock_info = audio_clock_info_table_36bpc;\n\t\taudio_array_size = ARRAY_SIZE(\n\t\t\t\taudio_clock_info_table_36bpc);\n\t\tbreak;\n\tdefault:\n\t\tclock_info = audio_clock_info_table;\n\t\taudio_array_size = ARRAY_SIZE(\n\t\t\t\taudio_clock_info_table);\n\t\tbreak;\n\t}\n\n\tif (clock_info != NULL) {\n\t\t \n\t\tfor (index = 0; index < audio_array_size; index++) {\n\t\t\tif (clock_info[index].pixel_clock_in_10khz >\n\t\t\t\tcrtc_pixel_clock_in_10khz)\n\t\t\t\tbreak;   \n\t\t\telse if (clock_info[index].pixel_clock_in_10khz ==\n\t\t\t\t\tcrtc_pixel_clock_in_10khz) {\n\t\t\t\t \n\t\t\t\t*audio_clock_info = clock_info[index];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (actual_pixel_clock_100Hz == 0)\n\t\tactual_pixel_clock_100Hz = crtc_pixel_clock_100Hz;\n\n\t \n\taudio_clock_info->pixel_clock_in_10khz =\n\t\t\tactual_pixel_clock_100Hz / 100;\n\taudio_clock_info->cts_32khz = actual_pixel_clock_100Hz / 10;\n\taudio_clock_info->cts_44khz = actual_pixel_clock_100Hz / 10;\n\taudio_clock_info->cts_48khz = actual_pixel_clock_100Hz / 10;\n\n\taudio_clock_info->n_32khz = 4096;\n\taudio_clock_info->n_44khz = 6272;\n\taudio_clock_info->n_48khz = 6144;\n}\n\nstatic void dce110_se_audio_setup(\n\tstruct stream_encoder *enc,\n\tunsigned int az_inst,\n\tstruct audio_info *audio_info)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tuint32_t channels = 0;\n\n\tASSERT(audio_info);\n\tif (audio_info == NULL)\n\t\t \n\t\treturn;\n\n\tchannels = speakers_to_channels(audio_info->flags.speaker_flags).all;\n\n\t \n\tREG_SET(AFMT_AUDIO_SRC_CONTROL, 0, AFMT_AUDIO_SRC_SELECT, az_inst);\n\n\t \n\tREG_UPDATE(AFMT_AUDIO_PACKET_CONTROL2, AFMT_AUDIO_CHANNEL_ENABLE, channels);\n}\n\nstatic void dce110_se_setup_hdmi_audio(\n\tstruct stream_encoder *enc,\n\tconst struct audio_crtc_info *crtc_info)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tstruct audio_clock_info audio_clock_info = {0};\n\tuint32_t max_packets_per_line;\n\n\t \n\tmax_packets_per_line = calc_max_audio_packets_per_line(crtc_info);\n\n\t \n\tREG_UPDATE_2(HDMI_AUDIO_PACKET_CONTROL,\n\t\t\tHDMI_AUDIO_PACKETS_PER_LINE, max_packets_per_line,\n\t\t\tHDMI_AUDIO_DELAY_EN, 1);\n\n\t \n\tREG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);\n\n\t \n\tREG_UPDATE_2(AFMT_AUDIO_PACKET_CONTROL2,\n\t\t\tAFMT_AUDIO_LAYOUT_OVRD, 0,\n\t\t\tAFMT_60958_OSF_OVRD, 0);\n\n\t \n\tREG_UPDATE_3(HDMI_ACR_PACKET_CONTROL,\n\t\t\tHDMI_ACR_AUTO_SEND, 1,\n\t\t\tHDMI_ACR_SOURCE, 0,\n\t\t\tHDMI_ACR_AUDIO_PRIORITY, 0);\n\n\t \n\tget_audio_clock_info(crtc_info->color_depth,\n\t\t\t     crtc_info->requested_pixel_clock_100Hz,\n\t\t\t     crtc_info->calculated_pixel_clock_100Hz,\n\t\t\t     &audio_clock_info);\n\tDC_LOG_HW_AUDIO(\n\t\t\t\"\\n%s:Input::requested_pixel_clock_100Hz = %d\"\t\\\n\t\t\t\"calculated_pixel_clock_100Hz = %d \\n\", __func__,\t\\\n\t\t\tcrtc_info->requested_pixel_clock_100Hz,\t\t\\\n\t\t\tcrtc_info->calculated_pixel_clock_100Hz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_32_0, HDMI_ACR_CTS_32, audio_clock_info.cts_32khz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_32_1, HDMI_ACR_N_32, audio_clock_info.n_32khz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_44_0, HDMI_ACR_CTS_44, audio_clock_info.cts_44khz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_44_1, HDMI_ACR_N_44, audio_clock_info.n_44khz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_48_0, HDMI_ACR_CTS_48, audio_clock_info.cts_48khz);\n\n\t \n\tREG_UPDATE(HDMI_ACR_48_1, HDMI_ACR_N_48, audio_clock_info.n_48khz);\n\n\t \n\n\t \n\tREG_UPDATE_2(AFMT_60958_0,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_L, 1,\n\t\t\tAFMT_60958_CS_CLOCK_ACCURACY, 0);\n\n\t \n\tREG_UPDATE(AFMT_60958_1, AFMT_60958_CS_CHANNEL_NUMBER_R, 2);\n\n\t \n\tREG_UPDATE_6(AFMT_60958_2,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_2, 3,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_3, 4,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_4, 5,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_5, 6,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_6, 7,\n\t\t\tAFMT_60958_CS_CHANNEL_NUMBER_7, 8);\n}\n\nstatic void dce110_se_setup_dp_audio(\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\t \n\n\t \n\tREG_SET(DP_SEC_AUD_N, 0,\n\t\t\tDP_SEC_AUD_N, DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT);\n\n\t \n\tREG_SET(DP_SEC_TIMESTAMP, 0, DP_SEC_TIMESTAMP_MODE,\n\t\t\tDP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC);\n\n\t \n\n\t \n\tREG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);\n\n\t \n\t \n\tREG_UPDATE_2(AFMT_AUDIO_PACKET_CONTROL2,\n\t\t\tAFMT_AUDIO_LAYOUT_OVRD, 0,\n\t\t\tAFMT_60958_OSF_OVRD, 0);\n\n\t \n\tREG_UPDATE(AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);\n\n\t \n\tREG_UPDATE(AFMT_60958_0, AFMT_60958_CS_CLOCK_ACCURACY, 0);\n}\n\nstatic void dce110_se_enable_audio_clock(\n\tstruct stream_encoder *enc,\n\tbool enable)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tif (REG(AFMT_CNTL) == 0)\n\t\treturn;    \n\n\tREG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, !!enable);\n\n\t \n}\n\nstatic void dce110_se_enable_dp_audio(\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\t \n\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_ASP_ENABLE, 1);\n\n\t \n\tREG_UPDATE_2(DP_SEC_CNTL,\n\t\t\tDP_SEC_ATP_ENABLE, 1,\n\t\t\tDP_SEC_AIP_ENABLE, 1);\n\n\t \n\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);\n}\n\nstatic void dce110_se_disable_dp_audio(\n\tstruct stream_encoder *enc)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tuint32_t value = 0;\n\n\t \n\tREG_UPDATE_5(DP_SEC_CNTL,\n\t\t\tDP_SEC_ASP_ENABLE, 0,\n\t\t\tDP_SEC_ATP_ENABLE, 0,\n\t\t\tDP_SEC_AIP_ENABLE, 0,\n\t\t\tDP_SEC_ACM_ENABLE, 0,\n\t\t\tDP_SEC_STREAM_ENABLE, 0);\n\n\t \n\tvalue = REG_READ(DP_SEC_CNTL);\n\tif (value != 0)\n\t\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);\n\n}\n\nvoid dce110_se_audio_mute_control(\n\tstruct stream_encoder *enc,\n\tbool mute)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND, !mute);\n}\n\nvoid dce110_se_dp_audio_setup(\n\tstruct stream_encoder *enc,\n\tunsigned int az_inst,\n\tstruct audio_info *info)\n{\n\tdce110_se_audio_setup(enc, az_inst, info);\n}\n\nvoid dce110_se_dp_audio_enable(\n\tstruct stream_encoder *enc)\n{\n\tdce110_se_enable_audio_clock(enc, true);\n\tdce110_se_setup_dp_audio(enc);\n\tdce110_se_enable_dp_audio(enc);\n}\n\nvoid dce110_se_dp_audio_disable(\n\tstruct stream_encoder *enc)\n{\n\tdce110_se_disable_dp_audio(enc);\n\tdce110_se_enable_audio_clock(enc, false);\n}\n\nvoid dce110_se_hdmi_audio_setup(\n\tstruct stream_encoder *enc,\n\tunsigned int az_inst,\n\tstruct audio_info *info,\n\tstruct audio_crtc_info *audio_crtc_info)\n{\n\tdce110_se_enable_audio_clock(enc, true);\n\tdce110_se_setup_hdmi_audio(enc, audio_crtc_info);\n\tdce110_se_audio_setup(enc, az_inst, info);\n}\n\nvoid dce110_se_hdmi_audio_disable(\n\tstruct stream_encoder *enc)\n{\n\tdce110_se_enable_audio_clock(enc, false);\n}\n\n\nstatic void setup_stereo_sync(\n\tstruct stream_encoder *enc,\n\tint tg_inst, bool enable)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\tREG_UPDATE(DIG_FE_CNTL, DIG_STEREOSYNC_SELECT, tg_inst);\n\tREG_UPDATE(DIG_FE_CNTL, DIG_STEREOSYNC_GATE_EN, !enable);\n}\n\nstatic void dig_connect_to_otg(\n\tstruct stream_encoder *enc,\n\tint tg_inst)\n{\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(DIG_FE_CNTL, DIG_SOURCE_SELECT, tg_inst);\n}\n\nstatic unsigned int dig_source_otg(\n\tstruct stream_encoder *enc)\n{\n\tuint32_t tg_inst = 0;\n\tstruct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);\n\n\tREG_GET(DIG_FE_CNTL, DIG_SOURCE_SELECT, &tg_inst);\n\n\treturn tg_inst;\n}\n\nstatic const struct stream_encoder_funcs dce110_str_enc_funcs = {\n\t.dp_set_stream_attribute =\n\t\tdce110_stream_encoder_dp_set_stream_attribute,\n\t.hdmi_set_stream_attribute =\n\t\tdce110_stream_encoder_hdmi_set_stream_attribute,\n\t.dvi_set_stream_attribute =\n\t\tdce110_stream_encoder_dvi_set_stream_attribute,\n\t.lvds_set_stream_attribute =\n\t\tdce110_stream_encoder_lvds_set_stream_attribute,\n\t.set_throttled_vcp_size =\n\t\tdce110_stream_encoder_set_throttled_vcp_size,\n\t.update_hdmi_info_packets =\n\t\tdce110_stream_encoder_update_hdmi_info_packets,\n\t.stop_hdmi_info_packets =\n\t\tdce110_stream_encoder_stop_hdmi_info_packets,\n\t.update_dp_info_packets =\n\t\tdce110_stream_encoder_update_dp_info_packets,\n\t.stop_dp_info_packets =\n\t\tdce110_stream_encoder_stop_dp_info_packets,\n\t.dp_blank =\n\t\tdce110_stream_encoder_dp_blank,\n\t.dp_unblank =\n\t\tdce110_stream_encoder_dp_unblank,\n\t.audio_mute_control = dce110_se_audio_mute_control,\n\n\t.dp_audio_setup = dce110_se_dp_audio_setup,\n\t.dp_audio_enable = dce110_se_dp_audio_enable,\n\t.dp_audio_disable = dce110_se_dp_audio_disable,\n\n\t.hdmi_audio_setup = dce110_se_hdmi_audio_setup,\n\t.hdmi_audio_disable = dce110_se_hdmi_audio_disable,\n\t.setup_stereo_sync  = setup_stereo_sync,\n\t.set_avmute = dce110_stream_encoder_set_avmute,\n\t.dig_connect_to_otg  = dig_connect_to_otg,\n\t.hdmi_reset_stream_attribute = dce110_reset_hdmi_stream_attribute,\n\t.dig_source_otg = dig_source_otg,\n};\n\nvoid dce110_stream_encoder_construct(\n\tstruct dce110_stream_encoder *enc110,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bp,\n\tenum engine_id eng_id,\n\tconst struct dce110_stream_enc_registers *regs,\n\tconst struct dce_stream_encoder_shift *se_shift,\n\tconst struct dce_stream_encoder_mask *se_mask)\n{\n\tenc110->base.funcs = &dce110_str_enc_funcs;\n\tenc110->base.ctx = ctx;\n\tenc110->base.id = eng_id;\n\tenc110->base.bp = bp;\n\tenc110->regs = regs;\n\tenc110->se_shift = se_shift;\n\tenc110->se_mask = se_mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}