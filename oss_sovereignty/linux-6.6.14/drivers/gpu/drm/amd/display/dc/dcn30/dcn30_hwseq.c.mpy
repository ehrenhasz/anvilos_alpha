{
  "module_name": "dcn30_hwseq.c",
  "hash_id": "11d6414c24d61744f821e104e7b63cb3e8fe723f3ee848285b663a473869af5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_hwseq.c",
  "human_readable_source": " \n\n\n#include \"dm_services.h\"\n#include \"dm_helpers.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dcn30_hwseq.h\"\n#include \"dccg.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dcn30_mpc.h\"\n#include \"dcn30_dpp.h\"\n#include \"dcn10/dcn10_cm_common.h\"\n#include \"dcn30_cm_common.h\"\n#include \"reg_helper.h\"\n#include \"abm.h\"\n#include \"clk_mgr.h\"\n#include \"hubp.h\"\n#include \"dchubbub.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"mcif_wb.h\"\n#include \"dc_dmub_srv.h\"\n#include \"link_hwss.h\"\n#include \"dpcd_defs.h\"\n#include \"../dcn20/dcn20_hwseq.h\"\n#include \"dcn30_resource.h\"\n#include \"link.h\"\n\n\n\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nbool dcn30_set_blend_lut(\n\tstruct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tbool result = true;\n\tstruct pwl_params *blend_lut = NULL;\n\n\tif (plane_state->blend_tf) {\n\t\tif (plane_state->blend_tf->type == TF_TYPE_HWPWL)\n\t\t\tblend_lut = &plane_state->blend_tf->pwl;\n\t\telse if (plane_state->blend_tf->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm3_helper_translate_curve_to_hw_format(\n\t\t\t\t\tplane_state->blend_tf, &dpp_base->regamma_params, false);\n\t\t\tblend_lut = &dpp_base->regamma_params;\n\t\t}\n\t}\n\tresult = dpp_base->funcs->dpp_program_blnd_lut(dpp_base, blend_lut);\n\n\treturn result;\n}\n\nstatic bool dcn30_set_mpc_shaper_3dlut(struct pipe_ctx *pipe_ctx,\n\t\t\t\t       const struct dc_stream_state *stream)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tbool result = false;\n\tint acquired_rmu = 0;\n\tint mpcc_id_projected = 0;\n\n\tconst struct pwl_params *shaper_lut = NULL;\n\t\n\tif (stream->func_shaper) {\n\t\tif (stream->func_shaper->type == TF_TYPE_HWPWL) {\n\t\t\tshaper_lut = &stream->func_shaper->pwl;\n\t\t} else if (stream->func_shaper->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm_helper_translate_curve_to_hw_format(stream->ctx, stream->func_shaper,\n\t\t\t\t\t\t\t       &dpp_base->shaper_params, true);\n\t\t\tshaper_lut = &dpp_base->shaper_params;\n\t\t}\n\t}\n\n\tif (stream->lut3d_func &&\n\t    stream->lut3d_func->state.bits.initialized == 1 &&\n\t    stream->lut3d_func->state.bits.rmu_idx_valid == 1) {\n\t\tif (stream->lut3d_func->state.bits.rmu_mux_num == 0)\n\t\t\tmpcc_id_projected = stream->lut3d_func->state.bits.mpc_rmu0_mux;\n\t\telse if (stream->lut3d_func->state.bits.rmu_mux_num == 1)\n\t\t\tmpcc_id_projected = stream->lut3d_func->state.bits.mpc_rmu1_mux;\n\t\telse if (stream->lut3d_func->state.bits.rmu_mux_num == 2)\n\t\t\tmpcc_id_projected = stream->lut3d_func->state.bits.mpc_rmu2_mux;\n\t\tif (mpcc_id_projected != mpcc_id)\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t \n\t\tacquired_rmu = mpc->funcs->acquire_rmu(mpc, mpcc_id,\n\t\t\t\t\t\t       stream->lut3d_func->state.bits.rmu_mux_num);\n\t\tif (acquired_rmu != stream->lut3d_func->state.bits.rmu_mux_num)\n\t\t\tBREAK_TO_DEBUGGER();\n\n\t\tresult = mpc->funcs->program_3dlut(mpc, &stream->lut3d_func->lut_3d,\n\t\t\t\t\t\t   stream->lut3d_func->state.bits.rmu_mux_num);\n\t\tresult = mpc->funcs->program_shaper(mpc, shaper_lut,\n\t\t\t\t\t\t    stream->lut3d_func->state.bits.rmu_mux_num);\n\t} else {\n\t\t\n\t\tmpc->funcs->release_rmu(mpc, mpcc_id);\n\t}\n\n\treturn result;\n}\n\nbool dcn30_set_input_transfer_func(struct dc *dc,\n\t\t\t\tstruct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_plane_state *plane_state)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tenum dc_transfer_func_predefined tf;\n\tbool result = true;\n\tstruct pwl_params *params = NULL;\n\n\tif (dpp_base == NULL || plane_state == NULL)\n\t\treturn false;\n\n\ttf = TRANSFER_FUNCTION_UNITY;\n\n\tif (plane_state->in_transfer_func &&\n\t\tplane_state->in_transfer_func->type == TF_TYPE_PREDEFINED)\n\t\ttf = plane_state->in_transfer_func->tf;\n\n\tdpp_base->funcs->dpp_set_pre_degam(dpp_base, tf);\n\n\tif (plane_state->in_transfer_func) {\n\t\tif (plane_state->in_transfer_func->type == TF_TYPE_HWPWL)\n\t\t\tparams = &plane_state->in_transfer_func->pwl;\n\t\telse if (plane_state->in_transfer_func->type == TF_TYPE_DISTRIBUTED_POINTS &&\n\t\t\tcm3_helper_translate_curve_to_hw_format(plane_state->in_transfer_func,\n\t\t\t\t\t&dpp_base->degamma_params, false))\n\t\t\tparams = &dpp_base->degamma_params;\n\t}\n\n\tresult = dpp_base->funcs->dpp_program_gamcor_lut(dpp_base, params);\n\n\tif (pipe_ctx->stream_res.opp && pipe_ctx->stream_res.opp->ctx) {\n\t\tif (dpp_base->funcs->dpp_program_blnd_lut)\n\t\t\thws->funcs.set_blend_lut(pipe_ctx, plane_state);\n\t\tif (dpp_base->funcs->dpp_program_shaper_lut &&\n\t\t\t\tdpp_base->funcs->dpp_program_3dlut)\n\t\t\thws->funcs.set_shaper_3dlut(pipe_ctx, plane_state);\n\t}\n\n\treturn result;\n}\n\nbool dcn30_set_output_transfer_func(struct dc *dc,\n\t\t\t\tstruct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_stream_state *stream)\n{\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tstruct pwl_params *params = NULL;\n\tbool ret = false;\n\n\t \n\tif (pipe_ctx->top_pipe == NULL) {\n\t\t \n\t\tret = dcn30_set_mpc_shaper_3dlut(pipe_ctx, stream);\n\t\tif (ret == false && mpc->funcs->set_output_gamma && stream->out_transfer_func) {\n\t\t\tif (stream->out_transfer_func->type == TF_TYPE_HWPWL)\n\t\t\t\tparams = &stream->out_transfer_func->pwl;\n\t\t\telse if (pipe_ctx->stream->out_transfer_func->type ==\n\t\t\t\t\tTF_TYPE_DISTRIBUTED_POINTS &&\n\t\t\t\t\tcm3_helper_translate_curve_to_hw_format(\n\t\t\t\t\tstream->out_transfer_func,\n\t\t\t\t\t&mpc->blender_params, false))\n\t\t\t\tparams = &mpc->blender_params;\n\t\t\t  \n\t\t\tif (stream->out_transfer_func->type == TF_TYPE_PREDEFINED)\n\t\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t}\n\n\tmpc->funcs->set_output_gamma(mpc, mpcc_id, params);\n\treturn ret;\n}\n\nstatic void dcn30_set_writeback(\n\t\tstruct dc *dc,\n\t\tstruct dc_writeback_info *wb_info,\n\t\tstruct dc_state *context)\n{\n\tstruct mcif_wb *mcif_wb;\n\tstruct mcif_buf_params *mcif_buf_params;\n\n\tASSERT(wb_info->dwb_pipe_inst < MAX_DWB_PIPES);\n\tASSERT(wb_info->wb_enabled);\n\tASSERT(wb_info->mpcc_inst >= 0);\n\tASSERT(wb_info->mpcc_inst < dc->res_pool->mpcc_count);\n\tmcif_wb = dc->res_pool->mcif_wb[wb_info->dwb_pipe_inst];\n\tmcif_buf_params = &wb_info->mcif_buf_params;\n\n\t \n\tdc->res_pool->mpc->funcs->set_dwb_mux(dc->res_pool->mpc,\n\t\t\twb_info->dwb_pipe_inst, wb_info->mpcc_inst);\n\t \n\tmcif_wb->funcs->config_mcif_buf(mcif_wb, mcif_buf_params, wb_info->dwb_params.dest_height);\n\tmcif_wb->funcs->config_mcif_arb(mcif_wb, &context->bw_ctx.bw.dcn.bw_writeback.mcif_wb_arb[wb_info->dwb_pipe_inst]);\n}\n\nvoid dcn30_update_writeback(\n\t\tstruct dc *dc,\n\t\tstruct dc_writeback_info *wb_info,\n\t\tstruct dc_state *context)\n{\n\tstruct dwbc *dwb;\n\tdwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];\n\tDC_LOG_DWB(\"%s dwb_pipe_inst = %d, mpcc_inst = %d\",\\\n\t\t__func__, wb_info->dwb_pipe_inst,\\\n\t\twb_info->mpcc_inst);\n\n\tdcn30_set_writeback(dc, wb_info, context);\n\n\t \n\tdwb->funcs->update(dwb, &wb_info->dwb_params);\n}\n\nbool dcn30_mmhubbub_warmup(\n\tstruct dc *dc,\n\tunsigned int num_dwb,\n\tstruct dc_writeback_info *wb_info)\n{\n\tstruct dwbc *dwb;\n\tstruct mcif_wb *mcif_wb;\n\tstruct mcif_warmup_params warmup_params = {0};\n\tunsigned int  i, i_buf;\n\t \n\tfor (i = 0; i < num_dwb; i++) {\n\t\tdwb = dc->res_pool->dwbc[wb_info[i].dwb_pipe_inst];\n\t\tif (dwb->dwb_is_efc_transition || dwb->dwb_is_drc) {\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (wb_info->mcif_warmup_params.p_vmid == 0)\n\t\treturn false;\n\n\t \n\tif (wb_info->mcif_warmup_params.start_address.quad_part != 0 &&\n\t\twb_info->mcif_warmup_params.region_size != 0) {\n\t\t \n\t\tmcif_wb = dc->res_pool->mcif_wb[0];\n\t\t \n\t\twarmup_params.start_address.quad_part = wb_info->mcif_warmup_params.start_address.quad_part;\n\t\twarmup_params.address_increment =  wb_info->mcif_warmup_params.region_size;\n\t\twarmup_params.region_size = wb_info->mcif_warmup_params.region_size;\n\t\twarmup_params.p_vmid = wb_info->mcif_warmup_params.p_vmid;\n\n\t\tif (warmup_params.address_increment == 0)\n\t\t\twarmup_params.address_increment = dc->dml.soc.vmm_page_size_bytes;\n\n\t\tmcif_wb->funcs->warmup_mcif(mcif_wb, &warmup_params);\n\t\treturn true;\n\t}\n\t \n\tfor (i = 0; i < num_dwb; i++) {\n\t\tdwb = dc->res_pool->dwbc[wb_info[i].dwb_pipe_inst];\n\t\tmcif_wb = dc->res_pool->mcif_wb[wb_info[i].dwb_pipe_inst];\n\t\t \n\t\tif (wb_info[i].mcif_buf_params.p_vmid == 0)\n\t\t\treturn false;\n\n\t\t \n\t\tfor (i_buf = 0; i_buf < MCIF_BUF_COUNT; i_buf++) {\n\t\t\twarmup_params.start_address.quad_part = wb_info[i].mcif_buf_params.luma_address[i_buf];\n\t\t\twarmup_params.address_increment = dc->dml.soc.vmm_page_size_bytes;\n\t\t\twarmup_params.region_size = wb_info[i].mcif_buf_params.luma_pitch * wb_info[i].dwb_params.dest_height;\n\t\t\twarmup_params.p_vmid = wb_info[i].mcif_buf_params.p_vmid;\n\t\t\tmcif_wb->funcs->warmup_mcif(mcif_wb, &warmup_params);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dcn30_enable_writeback(\n\t\tstruct dc *dc,\n\t\tstruct dc_writeback_info *wb_info,\n\t\tstruct dc_state *context)\n{\n\tstruct dwbc *dwb;\n\tstruct mcif_wb *mcif_wb;\n\n\tdwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];\n\tmcif_wb = dc->res_pool->mcif_wb[wb_info->dwb_pipe_inst];\n\n\tDC_LOG_DWB(\"%s dwb_pipe_inst = %d, mpcc_inst = %d\",\\\n\t\t__func__, wb_info->dwb_pipe_inst,\\\n\t\twb_info->mpcc_inst);\n\t \n\tdcn30_set_writeback(dc, wb_info, context);\n\n\t \n\tmcif_wb->funcs->enable_mcif(mcif_wb);\n\t \n\tdwb->funcs->enable(dwb, &wb_info->dwb_params);\n}\n\nvoid dcn30_disable_writeback(\n\t\tstruct dc *dc,\n\t\tunsigned int dwb_pipe_inst)\n{\n\tstruct dwbc *dwb;\n\tstruct mcif_wb *mcif_wb;\n\n\tASSERT(dwb_pipe_inst < MAX_DWB_PIPES);\n\tdwb = dc->res_pool->dwbc[dwb_pipe_inst];\n\tmcif_wb = dc->res_pool->mcif_wb[dwb_pipe_inst];\n\tDC_LOG_DWB(\"%s dwb_pipe_inst = %d\",\\\n\t\t__func__, dwb_pipe_inst);\n\n\t \n\tdwb->funcs->disable(dwb);\n\t \n\tmcif_wb->funcs->disable_mcif(mcif_wb);\n\t \n\tdc->res_pool->mpc->funcs->disable_dwb_mux(dc->res_pool->mpc, dwb_pipe_inst);\n}\n\nvoid dcn30_program_all_writeback_pipes_in_tree(\n\t\tstruct dc *dc,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct dc_state *context)\n{\n\tstruct dc_writeback_info wb_info;\n\tstruct dwbc *dwb;\n\tstruct dc_stream_status *stream_status = NULL;\n\tint i_wb, i_pipe, i_stream;\n\tDC_LOG_DWB(\"%s\", __func__);\n\n\tASSERT(stream);\n\tfor (i_stream = 0; i_stream < context->stream_count; i_stream++) {\n\t\tif (context->streams[i_stream] == stream) {\n\t\t\tstream_status = &context->stream_status[i_stream];\n\t\t\tbreak;\n\t\t}\n\t}\n\tASSERT(stream_status);\n\n\tASSERT(stream->num_wb_info <= dc->res_pool->res_cap->num_dwb);\n\t \n\tfor (i_wb = 0; i_wb < stream->num_wb_info; i_wb++) {\n\n\t\t \n\t\twb_info = stream->writeback_info[i_wb];\n\t\tif (wb_info.wb_enabled) {\n\n\t\t\t \n\t\t\twb_info.mpcc_inst = -1;\n\t\t\tfor (i_pipe = 0; i_pipe < dc->res_pool->pipe_count; i_pipe++) {\n\t\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i_pipe];\n\n\t\t\t\tif (!pipe_ctx->plane_state)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (pipe_ctx->plane_state == wb_info.writeback_source_plane) {\n\t\t\t\t\twb_info.mpcc_inst = pipe_ctx->plane_res.mpcc_inst;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wb_info.mpcc_inst == -1) {\n\t\t\t\t \n\t\t\t\tdc->hwss.disable_writeback(dc, wb_info.dwb_pipe_inst);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tASSERT(wb_info.dwb_pipe_inst < dc->res_pool->res_cap->num_dwb);\n\t\t\tdwb = dc->res_pool->dwbc[wb_info.dwb_pipe_inst];\n\t\t\tif (dwb->funcs->is_enabled(dwb)) {\n\t\t\t\t \n\t\t\t\tdc->hwss.update_writeback(dc, &wb_info, context);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdc->hwss.enable_writeback(dc, &wb_info, context);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdc->hwss.disable_writeback(dc, wb_info.dwb_pipe_inst);\n\t\t}\n\t}\n}\n\nvoid dcn30_init_hw(struct dc *dc)\n{\n\tstruct abm **abms = dc->res_pool->multiple_abms;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tint i;\n\tint edp_num;\n\tuint32_t backlight = MAX_BACKLIGHT_LEVEL;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\t\n\tif (res_pool->dccg->funcs->dccg_init)\n\t\tres_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb)) {\n\t\thws->funcs.bios_golden_init(dc);\n\t\thws->funcs.disable_vga(dc->hwseq);\n\t}\n\n\tif (dc->debug.enable_mem_low_power.bits.dmcu) {\n\t\t\n\t\tif (dc->debug.disable_dmcu || dc->config.disable_dmcu) {\n\t\t\tREG_UPDATE(DMU_MEM_PWR_CNTL, DMCU_ERAM_MEM_PWR_FORCE, 3);\n\t\t}\n\t}\n\n\t\n\tif (dc->debug.enable_mem_low_power.bits.optc) {\n\t\t\n\t\tREG_SET_2(ODM_MEM_PWR_CTRL3, 0, ODM_MEM_UNASSIGNED_PWR_MODE, 3, ODM_MEM_VBLANK_PWR_MODE, 1);\n\t}\n\n\tif (dc->debug.enable_mem_low_power.bits.vga) {\n\t\t\n\t\tREG_UPDATE(MMHUBBUB_MEM_PWR_CNTL, VGA_MEM_PWR_FORCE, 1);\n\t}\n\n\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\n\t\tif (res_pool->dccg && res_pool->hubbub) {\n\n\t\t\t(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,\n\t\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,\n\t\t\t\t\t&res_pool->ref_clocks.dccg_ref_clock_inKhz);\n\n\t\t\t(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,\n\t\t\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz,\n\t\t\t\t\t&res_pool->ref_clocks.dchub_ref_clock_inKhz);\n\t\t} else {\n\t\t\t\n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t}\n\t} else\n\t\tASSERT_CRITICAL(false);\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tlink->link_status.link_active = true;\n\t\t\tif (link->link_enc->funcs->fec_is_active &&\n\t\t\t\t\tlink->link_enc->funcs->fec_is_active(link->link_enc))\n\t\t\t\tlink->fec_state = dc_link_fec_enabled;\n\t\t}\n\t}\n\n\t \n\tdc->link_srv->blank_all_dp_displays(dc);\n\n\tif (hws->funcs.enable_power_gating_plane)\n\t\thws->funcs.enable_power_gating_plane(dc->hwseq, true);\n\n\t \n\tif (dcb->funcs->is_accelerated_mode(dcb) || !dc->config.seamless_boot_edp_requested) {\n\t\thws->funcs.init_pipes(dc, dc->current_state);\n\t\tif (dc->res_pool->hubbub->funcs->allow_self_refresh_control)\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,\n\t\t\t\t\t!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);\n\t}\n\n\t \n\tif (!dc->config.seamless_boot_edp_requested) {\n\t\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\t\tstruct dc_link *edp_link = NULL;\n\n\t\tdc_get_edp_links(dc, edp_links, &edp_num);\n\t\tif (edp_num)\n\t\t\tedp_link = edp_links[0];\n\t\tif (edp_link && edp_link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\tedp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc) &&\n\t\t\t\tdc->hwss.edp_backlight_control &&\n\t\t\t\tdc->hwss.power_down &&\n\t\t\t\tdc->hwss.edp_power_control) {\n\t\t\tdc->hwss.edp_backlight_control(edp_link, false);\n\t\t\tdc->hwss.power_down(dc);\n\t\t\tdc->hwss.edp_power_control(edp_link, false);\n\t\t} else {\n\t\t\tfor (i = 0; i < dc->link_count; i++) {\n\t\t\t\tstruct dc_link *link = dc->links[i];\n\n\t\t\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc) &&\n\t\t\t\t\t\tdc->hwss.power_down) {\n\t\t\t\t\tdc->hwss.power_down(dc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < res_pool->audio_count; i++) {\n\t\tstruct audio *audio = res_pool->audios[i];\n\n\t\taudio->funcs->hw_init(audio);\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (link->panel_cntl)\n\t\t\tbacklight = link->panel_cntl->funcs->hw_init(link->panel_cntl);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (abms[i] != NULL)\n\t\t\tabms[i]->funcs->abm_init(abms[i], backlight);\n\t}\n\n\t \n\tREG_WRITE(DIO_MEM_PWR_CTRL, 0);\n\n\tif (!dc->debug.disable_clock_gate) {\n\t\t \n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);\n\n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);\n\n\t\tREG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);\n\t}\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb) && dc->res_pool->hubbub->funcs->init_watermarks)\n\t\tdc->res_pool->hubbub->funcs->init_watermarks(dc->res_pool->hubbub);\n\n\tif (dc->clk_mgr->funcs->notify_wm_ranges)\n\t\tdc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);\n\n\t\n\tif (dc->clk_mgr->funcs->set_hard_max_memclk && !dc->clk_mgr->dc_mode_softmax_enabled)\n\t\tdc->clk_mgr->funcs->set_hard_max_memclk(dc->clk_mgr);\n\n\tif (dc->res_pool->hubbub->funcs->force_pstate_change_control)\n\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control(\n\t\t\t\tdc->res_pool->hubbub, false, false);\n\tif (dc->res_pool->hubbub->funcs->init_crb)\n\t\tdc->res_pool->hubbub->funcs->init_crb(dc->res_pool->hubbub);\n\n\t\n\tdc_dmub_srv_query_caps_cmd(dc->ctx->dmub_srv);\n\tdc->caps.dmub_caps.psr = dc->ctx->dmub_srv->dmub->feature_caps.psr;\n\tdc->caps.dmub_caps.mclk_sw = dc->ctx->dmub_srv->dmub->feature_caps.fw_assisted_mclk_switch;\n}\n\nvoid dcn30_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tif (pipe_ctx == NULL)\n\t\treturn;\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal) && pipe_ctx->stream_res.stream_enc != NULL)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->set_avmute(\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\tenable);\n}\n\nvoid dcn30_update_info_frame(struct pipe_ctx *pipe_ctx)\n{\n\tbool is_hdmi_tmds;\n\tbool is_dp;\n\n\tASSERT(pipe_ctx->stream);\n\n\tif (pipe_ctx->stream_res.stream_enc == NULL)\n\t\treturn;   \n\n\tis_hdmi_tmds = dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal);\n\tis_dp = dc_is_dp_signal(pipe_ctx->stream->signal);\n\n\tif (!is_hdmi_tmds && !is_dp)\n\t\treturn;\n\n\tif (is_hdmi_tmds)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\telse {\n\t\tif (pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num)\n\t\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num(\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\t}\n}\n\nvoid dcn30_program_dmdata_engine(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state    *stream     = pipe_ctx->stream;\n\tstruct hubp               *hubp       = pipe_ctx->plane_res.hubp;\n\tbool                       enable     = false;\n\tstruct stream_encoder     *stream_enc = pipe_ctx->stream_res.stream_enc;\n\tenum dynamic_metadata_mode mode       = dc_is_dp_signal(stream->signal)\n\t\t\t\t\t\t\t? dmdata_dp\n\t\t\t\t\t\t\t: dmdata_hdmi;\n\n\t \n\tif (pipe_ctx->stream->dmdata_address.quad_part != 0) {\n\t\tpipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;\n\t\tenable = true;\n\t}\n\n\tif (!hubp)\n\t\treturn;\n\n\tif (!stream_enc || !stream_enc->funcs->set_dynamic_metadata)\n\t\treturn;\n\n\tstream_enc->funcs->set_dynamic_metadata(stream_enc, enable,\n\t\t\t\t\t\t\thubp->inst, mode);\n}\n\nbool dcn30_apply_idle_power_optimizations(struct dc *dc, bool enable)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint32_t tmr_delay = 0, tmr_scale = 0;\n\tstruct dc_cursor_attributes cursor_attr;\n\tbool cursor_cache_enable = false;\n\tstruct dc_stream_state *stream = NULL;\n\tstruct dc_plane_state *plane = NULL;\n\n\tif (!dc->ctx->dmub_srv)\n\t\treturn false;\n\n\tif (enable) {\n\t\tif (dc->current_state) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\t\t\tif (dc->current_state->stream_status[i].plane_count)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == dc->current_state->stream_count) {\n\t\t\t\t \n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_NO_DF_REQ;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream = dc->current_state->streams[0];\n\t\t\tplane = (stream ? dc->current_state->stream_status[0].plane_states[0] : NULL);\n\n\t\t\tif (stream && plane) {\n\t\t\t\tcursor_cache_enable = stream->cursor_position.enable &&\n\t\t\t\t\t\tplane->address.grph.cursor_cache_addr.quad_part;\n\t\t\t\tcursor_attr = stream->cursor_attributes;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dc->current_state->stream_count == 1 &&\n\t\t\t\t\tstream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED &&\n\t\t\t\t\tdc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\t\t\tplane->format <= SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F &&\n\t\t\t\t\tplane->format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888 &&\n\t\t\t\t\tplane->address.page_table_base.quad_part == 0 &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall(dc, plane,\n\t\t\t\t\t\t\tcursor_cache_enable ? &cursor_attr : NULL)) {\n\t\t\t\tunsigned int v_total = stream->adjust.v_total_max ?\n\t\t\t\t\t\tstream->adjust.v_total_max : stream->timing.v_total;\n\t\t\t\tunsigned int refresh_hz = div_u64((unsigned long long) stream->timing.pix_clk_100hz *\n\t\t\t\t\t\t100LL, (v_total * stream->timing.h_total));\n\n\t\t\t\t \n\t\t\t\tunsigned int denom = refresh_hz * 6528;\n\t\t\t\tunsigned int stutter_period = dc->current_state->perf_params.stutter_period_us;\n\n\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\tdenom) - 64LL;\n\n\t\t\t\t \n\t\t\t\tif (stutter_period > 100000/refresh_hz)\n\t\t\t\t\treturn false;\n\n\t\t\t\t \n\t\t\t\twhile (tmr_delay & ~0x3F) {\n\t\t\t\t\ttmr_scale++;\n\n\t\t\t\t\tif (tmr_scale > 3) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tASSERT(false);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdenom *= 2;\n\t\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\t\tdenom) - 64LL;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (cursor_cache_enable) {\n\t\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_COPY_CURSOR;\n\t\t\t\t\tcmd.mall.header.payload_bytes =\n\t\t\t\t\t\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\t\tswitch (cursor_attr.color_format) {\n\t\t\t\t\tcase CURSOR_MODE_MONO:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 32;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 64;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcmd.mall.cursor_copy_src.quad_part = cursor_attr.address.quad_part;\n\t\t\t\t\tcmd.mall.cursor_copy_dst.quad_part =\n\t\t\t\t\t\t\t(plane->address.grph.cursor_cache_addr.quad_part + 2047) & ~2047;\n\t\t\t\t\tcmd.mall.cursor_width = cursor_attr.width;\n\t\t\t\t\tcmd.mall.cursor_height = cursor_attr.height;\n\t\t\t\t\tcmd.mall.cursor_pitch = cursor_attr.pitch;\n\n\t\t\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t\t\t\t\t \n\t\t\t\t\tcursor_attr.address.quad_part = cmd.mall.cursor_copy_dst.quad_part;\n\t\t\t\t\tdc_stream_set_cursor_attributes(stream, &cursor_attr);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_ALLOW;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\t\t\t\tcmd.mall.tmr_delay = tmr_delay;\n\t\t\t\tcmd.mall.tmr_scale = tmr_scale;\n\t\t\t\tcmd.mall.debug_bits = dc->debug.mall_error_as_fatal;\n\n\t\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.mall.header.type = DMUB_CMD__MALL;\n\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_DISALLOW;\n\tcmd.mall.header.payload_bytes =\n\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nbool dcn30_does_plane_fit_in_mall(struct dc *dc, struct dc_plane_state *plane, struct dc_cursor_attributes *cursor_attr)\n{\n\t \n\tunsigned int surface_size = plane->plane_size.surface_pitch * plane->plane_size.surface_size.height *\n\t\t\t(plane->format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616 ? 8 : 4);\n\tunsigned int mall_size = dc->caps.mall_size_total;\n\tunsigned int cursor_size = 0;\n\n\tif (dc->debug.mall_size_override)\n\t\tmall_size = 1024 * 1024 * dc->debug.mall_size_override;\n\n\tif (cursor_attr) {\n\t\tcursor_size = dc->caps.max_cursor_size * dc->caps.max_cursor_size;\n\n\t\tswitch (cursor_attr->color_format) {\n\t\tcase CURSOR_MODE_MONO:\n\t\t\tcursor_size /= 2;\n\t\t\tbreak;\n\t\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\t\tcursor_size *= 4;\n\t\t\tbreak;\n\n\t\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\t\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\t\tcursor_size *= 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (surface_size + cursor_size) < mall_size;\n}\n\nvoid dcn30_hardware_release(struct dc *dc)\n{\n\tbool subvp_in_use = false;\n\tuint32_t i;\n\n\tdc_dmub_srv_p_state_delegate(dc, false, NULL);\n\tdc_dmub_setup_subvp_dmub_command(dc, dc->current_state, false);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\tsubvp_in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (dc->current_state)\n\t\tif ((!dc->clk_mgr->clks.p_state_change_support || subvp_in_use ||\n\t\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) &&\n\t\t\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control)\n\t\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control(\n\t\t\t\t\tdc->res_pool->hubbub, true, true);\n}\n\nvoid dcn30_set_disp_pattern_generator(const struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tenum controller_dp_test_pattern test_pattern,\n\t\tenum controller_dp_color_space color_space,\n\t\tenum dc_color_depth color_depth,\n\t\tconst struct tg_color *solid_color,\n\t\tint width, int height, int offset)\n{\n\tpipe_ctx->stream_res.opp->funcs->opp_set_disp_pattern_generator(pipe_ctx->stream_res.opp, test_pattern,\n\t\t\tcolor_space, color_depth, solid_color, width, height, offset);\n}\n\nvoid dcn30_prepare_bandwidth(struct dc *dc,\n\tstruct dc_state *context)\n{\n\tbool p_state_change_support = context->bw_ctx.bw.dcn.clk.p_state_change_support;\n\t \n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching || dc->clk_mgr->clks.fw_based_mclk_switching) {\n\t\tdc->optimized_required = true;\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = false;\n\t}\n\n\tif (dc->clk_mgr->dc_mode_softmax_enabled)\n\t\tif (dc->clk_mgr->clks.dramclk_khz <= dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000 &&\n\t\t\t\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz > dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000)\n\t\t\tdc->clk_mgr->funcs->set_max_memclk(dc->clk_mgr, dc->clk_mgr->bw_params->clk_table.entries[dc->clk_mgr->bw_params->clk_table.num_entries - 1].memclk_mhz);\n\n\tdcn20_prepare_bandwidth(dc, context);\n\t \n\tif (!context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching)\n\t\tdc_dmub_srv_p_state_delegate(dc, false, context);\n\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching || dc->clk_mgr->clks.fw_based_mclk_switching) {\n\t\t \n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = p_state_change_support;\n\t}\n}\n\nvoid dcn30_set_static_screen_control(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, const struct dc_static_screen_params *params)\n{\n\tunsigned int i;\n\tunsigned int triggers = 0;\n\n\tif (params->triggers.surface_update)\n\t\ttriggers |= 0x100;\n\tif (params->triggers.cursor_update)\n\t\ttriggers |= 0x8;\n\tif (params->triggers.force_trigger)\n\t\ttriggers |= 0x1;\n\n\tfor (i = 0; i < num_pipes; i++)\n\t\tpipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(pipe_ctx[i]->stream_res.tg,\n\t\t\t\t\ttriggers, params->num_frames);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}