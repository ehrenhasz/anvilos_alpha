{
  "module_name": "dcn10_optc.c",
  "hash_id": "3bf98ee5542fb44c99e7f41c5c19194b5888a25f19f7d9fa42e4c3477c29eea3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_optc.c",
  "human_readable_source": " \n\n\n#include \"reg_helper.h\"\n#include \"dcn10_optc.h\"\n#include \"dc.h\"\n#include \"dc_trace.h\"\n\n#define REG(reg)\\\n\toptc1->tg_regs->reg\n\n#define CTX \\\n\toptc1->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\toptc1->tg_shift->field_name, optc1->tg_mask->field_name\n\n#define STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN 0x100\n\n \nstatic void apply_front_porch_workaround(struct dc_crtc_timing *timing)\n{\n\tif (timing->flags.INTERLACE == 1) {\n\t\tif (timing->v_front_porch < 2)\n\t\t\ttiming->v_front_porch = 2;\n\t} else {\n\t\tif (timing->v_front_porch < 1)\n\t\t\ttiming->v_front_porch = 1;\n\t}\n}\n\nvoid optc1_program_global_sync(\n\t\tstruct timing_generator *optc,\n\t\tint vready_offset,\n\t\tint vstartup_start,\n\t\tint vupdate_offset,\n\t\tint vupdate_width)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\toptc1->vready_offset = vready_offset;\n\toptc1->vstartup_start = vstartup_start;\n\toptc1->vupdate_offset = vupdate_offset;\n\toptc1->vupdate_width = vupdate_width;\n\n\tif (optc1->vstartup_start == 0) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tREG_SET(OTG_VSTARTUP_PARAM, 0,\n\t\tVSTARTUP_START, optc1->vstartup_start);\n\n\tREG_SET_2(OTG_VUPDATE_PARAM, 0,\n\t\t\tVUPDATE_OFFSET, optc1->vupdate_offset,\n\t\t\tVUPDATE_WIDTH, optc1->vupdate_width);\n\n\tREG_SET(OTG_VREADY_PARAM, 0,\n\t\t\tVREADY_OFFSET, optc1->vready_offset);\n}\n\nstatic void optc1_disable_stereo(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_STEREO_CONTROL, 0,\n\t\tOTG_STEREO_EN, 0);\n\n\tREG_SET_2(OTG_3D_STRUCTURE_CONTROL, 0,\n\t\tOTG_3D_STRUCTURE_EN, 0,\n\t\tOTG_3D_STRUCTURE_STEREO_SEL_OVR, 0);\n}\n\nvoid optc1_setup_vertical_interrupt0(\n\t\tstruct timing_generator *optc,\n\t\tuint32_t start_line,\n\t\tuint32_t end_line)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET_2(OTG_VERTICAL_INTERRUPT0_POSITION, 0,\n\t\t\tOTG_VERTICAL_INTERRUPT0_LINE_START, start_line,\n\t\t\tOTG_VERTICAL_INTERRUPT0_LINE_END, end_line);\n}\n\nvoid optc1_setup_vertical_interrupt1(\n\t\tstruct timing_generator *optc,\n\t\tuint32_t start_line)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_VERTICAL_INTERRUPT1_POSITION, 0,\n\t\t\t\tOTG_VERTICAL_INTERRUPT1_LINE_START, start_line);\n}\n\nvoid optc1_setup_vertical_interrupt2(\n\t\tstruct timing_generator *optc,\n\t\tuint32_t start_line)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_VERTICAL_INTERRUPT2_POSITION, 0,\n\t\t\tOTG_VERTICAL_INTERRUPT2_LINE_START, start_line);\n}\n\n \nvoid optc1_program_timing(\n\tstruct timing_generator *optc,\n\tconst struct dc_crtc_timing *dc_crtc_timing,\n\tint vready_offset,\n\tint vstartup_start,\n\tint vupdate_offset,\n\tint vupdate_width,\n\tconst enum signal_type signal,\n\tbool use_vbios)\n{\n\tstruct dc_crtc_timing patched_crtc_timing;\n\tuint32_t asic_blank_end;\n\tuint32_t asic_blank_start;\n\tuint32_t v_total;\n\tuint32_t v_sync_end;\n\tuint32_t h_sync_polarity, v_sync_polarity;\n\tuint32_t start_point = 0;\n\tuint32_t field_num = 0;\n\tenum h_timing_div_mode h_div = H_TIMING_NO_DIV;\n\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\toptc1->signal = signal;\n\toptc1->vready_offset = vready_offset;\n\toptc1->vstartup_start = vstartup_start;\n\toptc1->vupdate_offset = vupdate_offset;\n\toptc1->vupdate_width = vupdate_width;\n\tpatched_crtc_timing = *dc_crtc_timing;\n\tapply_front_porch_workaround(&patched_crtc_timing);\n\toptc1->orginal_patched_timing = patched_crtc_timing;\n\n\t \n\n\t \n\tREG_SET(OTG_H_TOTAL, 0,\n\t\t\tOTG_H_TOTAL,  patched_crtc_timing.h_total - 1);\n\n\t \n\tREG_UPDATE_2(OTG_H_SYNC_A,\n\t\t\tOTG_H_SYNC_A_START, 0,\n\t\t\tOTG_H_SYNC_A_END, patched_crtc_timing.h_sync_width);\n\n\t \n\tasic_blank_start = patched_crtc_timing.h_total -\n\t\t\tpatched_crtc_timing.h_front_porch;\n\n\t \n\tasic_blank_end = asic_blank_start -\n\t\t\tpatched_crtc_timing.h_border_right -\n\t\t\tpatched_crtc_timing.h_addressable -\n\t\t\tpatched_crtc_timing.h_border_left;\n\n\tREG_UPDATE_2(OTG_H_BLANK_START_END,\n\t\t\tOTG_H_BLANK_START, asic_blank_start,\n\t\t\tOTG_H_BLANK_END, asic_blank_end);\n\n\t \n\th_sync_polarity = patched_crtc_timing.flags.HSYNC_POSITIVE_POLARITY ?\n\t\t\t0 : 1;\n\n\tREG_UPDATE(OTG_H_SYNC_A_CNTL,\n\t\t\tOTG_H_SYNC_A_POL, h_sync_polarity);\n\n\tv_total = patched_crtc_timing.v_total - 1;\n\n\tREG_SET(OTG_V_TOTAL, 0,\n\t\t\tOTG_V_TOTAL, v_total);\n\n\t \n\toptc->funcs->set_vtotal_min_max(optc, v_total, v_total);\n\n\t \n\tv_sync_end = patched_crtc_timing.v_sync_width;\n\n\tREG_UPDATE_2(OTG_V_SYNC_A,\n\t\t\tOTG_V_SYNC_A_START, 0,\n\t\t\tOTG_V_SYNC_A_END, v_sync_end);\n\n\t \n\tasic_blank_start = patched_crtc_timing.v_total -\n\t\t\tpatched_crtc_timing.v_front_porch;\n\n\t \n\tasic_blank_end = asic_blank_start -\n\t\t\tpatched_crtc_timing.v_border_bottom -\n\t\t\tpatched_crtc_timing.v_addressable -\n\t\t\tpatched_crtc_timing.v_border_top;\n\n\tREG_UPDATE_2(OTG_V_BLANK_START_END,\n\t\t\tOTG_V_BLANK_START, asic_blank_start,\n\t\t\tOTG_V_BLANK_END, asic_blank_end);\n\n\t \n\tv_sync_polarity = patched_crtc_timing.flags.VSYNC_POSITIVE_POLARITY ?\n\t\t\t0 : 1;\n\n\tREG_UPDATE(OTG_V_SYNC_A_CNTL,\n\t\tOTG_V_SYNC_A_POL, v_sync_polarity);\n\n\tif (optc1->signal == SIGNAL_TYPE_DISPLAY_PORT ||\n\t\t\toptc1->signal == SIGNAL_TYPE_DISPLAY_PORT_MST ||\n\t\t\toptc1->signal == SIGNAL_TYPE_EDP) {\n\t\tstart_point = 1;\n\t\tif (patched_crtc_timing.flags.INTERLACE == 1)\n\t\t\tfield_num = 1;\n\t}\n\n\t \n\tif (REG(OTG_INTERLACE_CONTROL)) {\n\t\tif (patched_crtc_timing.flags.INTERLACE == 1)\n\t\t\tREG_UPDATE(OTG_INTERLACE_CONTROL,\n\t\t\t\t\tOTG_INTERLACE_ENABLE, 1);\n\t\telse\n\t\t\tREG_UPDATE(OTG_INTERLACE_CONTROL,\n\t\t\t\t\tOTG_INTERLACE_ENABLE, 0);\n\t}\n\n\t \n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 0);\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL,\n\t\t\tOTG_START_POINT_CNTL, start_point,\n\t\t\tOTG_FIELD_NUMBER_CNTL, field_num);\n\n\toptc->funcs->program_global_sync(optc,\n\t\t\tvready_offset,\n\t\t\tvstartup_start,\n\t\t\tvupdate_offset,\n\t\t\tvupdate_width);\n\n\toptc->funcs->set_vtg_params(optc, dc_crtc_timing, true);\n\n\t \n\n\t \n\n\tif (optc1_is_two_pixels_per_containter(&patched_crtc_timing) || optc1->opp_count == 2)\n\t\th_div = H_TIMING_DIV_BY2;\n\n\tif (REG(OPTC_DATA_FORMAT_CONTROL) && optc1->tg_mask->OPTC_DATA_FORMAT != 0) {\n\t\tuint32_t data_fmt = 0;\n\n\t\tif (patched_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\t\tdata_fmt = 1;\n\t\telse if (patched_crtc_timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\tdata_fmt = 2;\n\n\t\tREG_UPDATE(OPTC_DATA_FORMAT_CONTROL, OPTC_DATA_FORMAT, data_fmt);\n\t}\n\n\tif (optc1->tg_mask->OTG_H_TIMING_DIV_MODE != 0) {\n\t\tif (optc1->opp_count == 4)\n\t\t\th_div = H_TIMING_DIV_BY4;\n\n\t\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\tOTG_H_TIMING_DIV_MODE, h_div);\n\t} else {\n\t\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\tOTG_H_TIMING_DIV_BY2, h_div);\n\t}\n}\n\n \nvoid optc1_set_vtg_params(struct timing_generator *optc,\n\t\tconst struct dc_crtc_timing *dc_crtc_timing, bool program_fp2)\n{\n\tstruct dc_crtc_timing patched_crtc_timing;\n\tuint32_t asic_blank_end;\n\tuint32_t v_init;\n\tuint32_t v_fp2 = 0;\n\tint32_t vertical_line_start;\n\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tpatched_crtc_timing = *dc_crtc_timing;\n\tapply_front_porch_workaround(&patched_crtc_timing);\n\n\t \n\tv_init = patched_crtc_timing.v_total - patched_crtc_timing.v_front_porch;\n\n\t \n\tasic_blank_end = v_init -\n\t\t\tpatched_crtc_timing.v_border_bottom -\n\t\t\tpatched_crtc_timing.v_addressable -\n\t\t\tpatched_crtc_timing.v_border_top;\n\n\t \n\tvertical_line_start = asic_blank_end - optc1->vstartup_start + 1;\n\tif (vertical_line_start < 0)\n\t\tv_fp2 = -vertical_line_start;\n\n\t \n\tif (REG(OTG_INTERLACE_CONTROL)) {\n\t\tif (patched_crtc_timing.flags.INTERLACE == 1) {\n\t\t\tv_init = v_init / 2;\n\t\t\tif ((optc1->vstartup_start/2)*2 > asic_blank_end)\n\t\t\t\tv_fp2 = v_fp2 / 2;\n\t\t}\n\t}\n\n\tif (program_fp2)\n\t\tREG_UPDATE_2(CONTROL,\n\t\t\t\tVTG0_FP2, v_fp2,\n\t\t\t\tVTG0_VCOUNT_INIT, v_init);\n\telse\n\t\tREG_UPDATE(CONTROL, VTG0_VCOUNT_INIT, v_init);\n}\n\nvoid optc1_set_blank_data_double_buffer(struct timing_generator *optc, bool enable)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tuint32_t blank_data_double_buffer_enable = enable ? 1 : 0;\n\n\tREG_UPDATE(OTG_DOUBLE_BUFFER_CONTROL,\n\t\t\tOTG_BLANK_DATA_DOUBLE_BUFFER_EN, blank_data_double_buffer_enable);\n}\n\n \nvoid optc1_set_timing_double_buffer(struct timing_generator *optc, bool enable)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t mode = enable ? 2 : 0;\n\n\tREG_UPDATE(OTG_DOUBLE_BUFFER_CONTROL,\n\t\t   OTG_RANGE_TIMING_DBUF_UPDATE_MODE, mode);\n}\n\n \nstatic void optc1_unblank_crtc(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE_2(OTG_BLANK_CONTROL,\n\t\t\tOTG_BLANK_DATA_EN, 0,\n\t\t\tOTG_BLANK_DE_MODE, 0);\n\n\t \n\toptc1_clear_optc_underflow(optc);\n}\n\n \n\nstatic void optc1_blank_crtc(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE_2(OTG_BLANK_CONTROL,\n\t\t\tOTG_BLANK_DATA_EN, 1,\n\t\t\tOTG_BLANK_DE_MODE, 0);\n\n\toptc1_set_blank_data_double_buffer(optc, false);\n}\n\nvoid optc1_set_blank(struct timing_generator *optc,\n\t\tbool enable_blanking)\n{\n\tif (enable_blanking)\n\t\toptc1_blank_crtc(optc);\n\telse\n\t\toptc1_unblank_crtc(optc);\n}\n\nbool optc1_is_blanked(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t blank_en;\n\tuint32_t blank_state;\n\n\tREG_GET_2(OTG_BLANK_CONTROL,\n\t\t\tOTG_BLANK_DATA_EN, &blank_en,\n\t\t\tOTG_CURRENT_BLANK_STATE, &blank_state);\n\n\treturn blank_en && blank_state;\n}\n\nvoid optc1_enable_optc_clock(struct timing_generator *optc, bool enable)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tif (enable) {\n\t\tREG_UPDATE_2(OPTC_INPUT_CLOCK_CONTROL,\n\t\t\t\tOPTC_INPUT_CLK_EN, 1,\n\t\t\t\tOPTC_INPUT_CLK_GATE_DIS, 1);\n\n\t\tREG_WAIT(OPTC_INPUT_CLOCK_CONTROL,\n\t\t\t\tOPTC_INPUT_CLK_ON, 1,\n\t\t\t\t1, 1000);\n\n\t\t \n\t\tREG_UPDATE_2(OTG_CLOCK_CONTROL,\n\t\t\t\tOTG_CLOCK_EN, 1,\n\t\t\t\tOTG_CLOCK_GATE_DIS, 1);\n\t\tREG_WAIT(OTG_CLOCK_CONTROL,\n\t\t\t\tOTG_CLOCK_ON, 1,\n\t\t\t\t1, 1000);\n\t} else  {\n\n\t\t \n\t\tif (optc->funcs->is_optc_underflow_occurred(optc) == true)\n\t\t\toptc->funcs->clear_optc_underflow(optc);\n\n\t\tREG_UPDATE_2(OTG_CLOCK_CONTROL,\n\t\t\t\tOTG_CLOCK_GATE_DIS, 0,\n\t\t\t\tOTG_CLOCK_EN, 0);\n\n\t\tREG_UPDATE_2(OPTC_INPUT_CLOCK_CONTROL,\n\t\t\t\tOPTC_INPUT_CLK_GATE_DIS, 0,\n\t\t\t\tOPTC_INPUT_CLK_EN, 0);\n\t}\n}\n\n \nstatic bool optc1_enable_crtc(struct timing_generator *optc)\n{\n\t \n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE(OPTC_DATA_SOURCE_SELECT,\n\t\t\tOPTC_SRC_SEL, optc->inst);\n\n\t \n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 1);\n\n\tREG_SEQ_START();\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL,\n\t\t\tOTG_DISABLE_POINT_CNTL, 3,\n\t\t\tOTG_MASTER_EN, 1);\n\n\tREG_SEQ_SUBMIT();\n\tREG_SEQ_WAIT_DONE();\n\n\treturn true;\n}\n\n \nbool optc1_disable_crtc(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL,\n\t\t\tOTG_DISABLE_POINT_CNTL, 3,\n\t\t\tOTG_MASTER_EN, 0);\n\n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 0);\n\n\t \n\tREG_WAIT(OTG_CLOCK_CONTROL,\n\t\t\tOTG_BUSY, 0,\n\t\t\t1, 100000);\n\n\treturn true;\n}\n\n\nvoid optc1_program_blank_color(\n\t\tstruct timing_generator *optc,\n\t\tconst struct tg_color *black_color)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET_3(OTG_BLACK_COLOR, 0,\n\t\t\tOTG_BLACK_COLOR_B_CB, black_color->color_b_cb,\n\t\t\tOTG_BLACK_COLOR_G_Y, black_color->color_g_y,\n\t\t\tOTG_BLACK_COLOR_R_CR, black_color->color_r_cr);\n}\n\nbool optc1_validate_timing(\n\tstruct timing_generator *optc,\n\tconst struct dc_crtc_timing *timing)\n{\n\tuint32_t v_blank;\n\tuint32_t h_blank;\n\tuint32_t min_v_blank;\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tASSERT(timing != NULL);\n\n\tv_blank = (timing->v_total - timing->v_addressable -\n\t\t\t\t\ttiming->v_border_top - timing->v_border_bottom);\n\n\th_blank = (timing->h_total - timing->h_addressable -\n\t\ttiming->h_border_right -\n\t\ttiming->h_border_left);\n\n\tif (timing->timing_3d_format != TIMING_3D_FORMAT_NONE &&\n\t\ttiming->timing_3d_format != TIMING_3D_FORMAT_HW_FRAME_PACKING &&\n\t\ttiming->timing_3d_format != TIMING_3D_FORMAT_TOP_AND_BOTTOM &&\n\t\ttiming->timing_3d_format != TIMING_3D_FORMAT_SIDE_BY_SIDE &&\n\t\ttiming->timing_3d_format != TIMING_3D_FORMAT_FRAME_ALTERNATE &&\n\t\ttiming->timing_3d_format != TIMING_3D_FORMAT_INBAND_FA)\n\t\treturn false;\n\n\t \n\tif (timing->flags.INTERLACE == 1)\n\t\treturn false;\n\n\t \n\tif (timing->h_total > optc1->max_h_total ||\n\t\ttiming->v_total > optc1->max_v_total)\n\t\treturn false;\n\n\n\tif (h_blank < optc1->min_h_blank)\n\t\treturn false;\n\n\tif (timing->h_sync_width  < optc1->min_h_sync_width ||\n\t\t timing->v_sync_width  < optc1->min_v_sync_width)\n\t\treturn false;\n\n\tmin_v_blank = timing->flags.INTERLACE?optc1->min_v_blank_interlace:optc1->min_v_blank;\n\n\tif (v_blank < min_v_blank)\n\t\treturn false;\n\n\treturn true;\n\n}\n\n \nuint32_t optc1_get_vblank_counter(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t frame_count;\n\n\tREG_GET(OTG_STATUS_FRAME_COUNT,\n\t\tOTG_FRAME_COUNT, &frame_count);\n\n\treturn frame_count;\n}\n\nvoid optc1_lock(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_GLOBAL_CONTROL0, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK_SEL, optc->inst);\n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, 1);\n\n\tREG_WAIT(OTG_MASTER_UPDATE_LOCK,\n\t\t\tUPDATE_LOCK_STATUS, 1,\n\t\t\t1, 10);\n\n\tTRACE_OPTC_LOCK_UNLOCK_STATE(optc1, optc->inst, true);\n}\n\nvoid optc1_unlock(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, 0);\n\n\tTRACE_OPTC_LOCK_UNLOCK_STATE(optc1, optc->inst, false);\n}\n\nvoid optc1_get_position(struct timing_generator *optc,\n\t\tstruct crtc_position *position)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET_2(OTG_STATUS_POSITION,\n\t\t\tOTG_HORZ_COUNT, &position->horizontal_count,\n\t\t\tOTG_VERT_COUNT, &position->vertical_count);\n\n\tREG_GET(OTG_NOM_VERT_POSITION,\n\t\t\tOTG_VERT_COUNT_NOM, &position->nominal_vcount);\n}\n\nbool optc1_is_counter_moving(struct timing_generator *optc)\n{\n\tstruct crtc_position position1, position2;\n\n\toptc->funcs->get_position(optc, &position1);\n\toptc->funcs->get_position(optc, &position2);\n\n\tif (position1.horizontal_count == position2.horizontal_count &&\n\t\tposition1.vertical_count == position2.vertical_count)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nbool optc1_did_triggered_reset_occur(\n\tstruct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t occurred_force, occurred_vsync;\n\n\tREG_GET(OTG_FORCE_COUNT_NOW_CNTL,\n\t\tOTG_FORCE_COUNT_NOW_OCCURRED, &occurred_force);\n\n\tREG_GET(OTG_VERT_SYNC_CONTROL,\n\t\tOTG_FORCE_VSYNC_NEXT_LINE_OCCURRED, &occurred_vsync);\n\n\treturn occurred_vsync != 0 || occurred_force != 0;\n}\n\nvoid optc1_disable_reset_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_WRITE(OTG_TRIGA_CNTL, 0);\n\n\tREG_SET(OTG_FORCE_COUNT_NOW_CNTL, 0,\n\t\tOTG_FORCE_COUNT_NOW_CLEAR, 1);\n\n\tREG_SET(OTG_VERT_SYNC_CONTROL, 0,\n\t\tOTG_FORCE_VSYNC_NEXT_LINE_CLEAR, 1);\n}\n\nvoid optc1_enable_reset_trigger(struct timing_generator *optc, int source_tg_inst)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t falling_edge;\n\n\tREG_GET(OTG_V_SYNC_A_CNTL,\n\t\t\tOTG_V_SYNC_A_POL, &falling_edge);\n\n\tif (falling_edge)\n\t\tREG_SET_3(OTG_TRIGA_CNTL, 0,\n\t\t\t\t \n\t\t\t\tOTG_TRIGA_SOURCE_SELECT, 20,\n\t\t\t\tOTG_TRIGA_SOURCE_PIPE_SELECT, source_tg_inst,\n\t\t\t\t \n\t\t\t\tOTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 1);\n\telse\n\t\tREG_SET_3(OTG_TRIGA_CNTL, 0,\n\t\t\t\t \n\t\t\t\tOTG_TRIGA_SOURCE_SELECT, 20,\n\t\t\t\tOTG_TRIGA_SOURCE_PIPE_SELECT, source_tg_inst,\n\t\t\t\t \n\t\t\t\tOTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1);\n\n\tREG_SET(OTG_FORCE_COUNT_NOW_CNTL, 0,\n\t\t\t \n\t\t\tOTG_FORCE_COUNT_NOW_MODE, 2);\n}\n\nvoid optc1_enable_crtc_reset(\n\t\tstruct timing_generator *optc,\n\t\tint source_tg_inst,\n\t\tstruct crtc_trigger_info *crtc_tp)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t falling_edge = 0;\n\tuint32_t rising_edge = 0;\n\n\tswitch (crtc_tp->event) {\n\n\tcase CRTC_EVENT_VSYNC_RISING:\n\t\trising_edge = 1;\n\t\tbreak;\n\n\tcase CRTC_EVENT_VSYNC_FALLING:\n\t\tfalling_edge = 1;\n\t\tbreak;\n\t}\n\n\tREG_SET_4(OTG_TRIGA_CNTL, 0,\n\t\t  \n\t\t  OTG_TRIGA_SOURCE_SELECT, 20,\n\t\t  OTG_TRIGA_SOURCE_PIPE_SELECT, source_tg_inst,\n\t\t   \n\t\t  OTG_TRIGA_RISING_EDGE_DETECT_CNTL, rising_edge,\n\t\t  OTG_TRIGA_FALLING_EDGE_DETECT_CNTL, falling_edge);\n\n\tswitch (crtc_tp->delay) {\n\tcase TRIGGER_DELAY_NEXT_LINE:\n\t\tREG_SET(OTG_VERT_SYNC_CONTROL, 0,\n\t\t\t\tOTG_AUTO_FORCE_VSYNC_MODE, 1);\n\t\tbreak;\n\tcase TRIGGER_DELAY_NEXT_PIXEL:\n\t\tREG_SET(OTG_FORCE_COUNT_NOW_CNTL, 0,\n\t\t\t \n\t\t\tOTG_FORCE_COUNT_NOW_MODE, 2);\n\t\tbreak;\n\t}\n}\n\nvoid optc1_wait_for_state(struct timing_generator *optc,\n\t\tenum crtc_state state)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tswitch (state) {\n\tcase CRTC_STATE_VBLANK:\n\t\tREG_WAIT(OTG_STATUS,\n\t\t\t\tOTG_V_BLANK, 1,\n\t\t\t\t1, 100000);  \n\t\tbreak;\n\n\tcase CRTC_STATE_VACTIVE:\n\t\tREG_WAIT(OTG_STATUS,\n\t\t\t\tOTG_V_ACTIVE_DISP, 1,\n\t\t\t\t1, 100000);  \n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid optc1_set_early_control(\n\tstruct timing_generator *optc,\n\tuint32_t early_cntl)\n{\n\t \n}\n\n\nvoid optc1_set_static_screen_control(\n\tstruct timing_generator *optc,\n\tuint32_t event_triggers,\n\tuint32_t num_frames)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t\n\tif (num_frames > 0xFF)\n\t\tnum_frames = 0xFF;\n\n\t \n\tif ((event_triggers & STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN)\n\t\t\t!= 0)\n\t\tevent_triggers = event_triggers &\n\t\t~STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN;\n\n\tREG_SET_2(OTG_STATIC_SCREEN_CONTROL, 0,\n\t\t\tOTG_STATIC_SCREEN_EVENT_MASK, event_triggers,\n\t\t\tOTG_STATIC_SCREEN_FRAME_COUNT, num_frames);\n}\n\nstatic void optc1_setup_manual_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_GLOBAL_CONTROL2, 0,\n\t\t\tMANUAL_FLOW_CONTROL_SEL, optc->inst);\n\n\tREG_SET_8(OTG_TRIGA_CNTL, 0,\n\t\t\tOTG_TRIGA_SOURCE_SELECT, 22,\n\t\t\tOTG_TRIGA_SOURCE_PIPE_SELECT, optc->inst,\n\t\t\tOTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1,\n\t\t\tOTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 0,\n\t\t\tOTG_TRIGA_POLARITY_SELECT, 0,\n\t\t\tOTG_TRIGA_FREQUENCY_SELECT, 0,\n\t\t\tOTG_TRIGA_DELAY, 0,\n\t\t\tOTG_TRIGA_CLEAR, 1);\n}\n\nstatic void optc1_program_manual_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_MANUAL_FLOW_CONTROL, 0,\n\t\t\tMANUAL_FLOW_CONTROL, 1);\n\n\tREG_SET(OTG_MANUAL_FLOW_CONTROL, 0,\n\t\t\tMANUAL_FLOW_CONTROL, 0);\n}\n\n \nvoid optc1_set_drr(\n\tstruct timing_generator *optc,\n\tconst struct drr_params *params)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tif (params != NULL &&\n\t\tparams->vertical_total_max > 0 &&\n\t\tparams->vertical_total_min > 0) {\n\n\t\tif (params->vertical_total_mid != 0) {\n\n\t\t\tREG_SET(OTG_V_TOTAL_MID, 0,\n\t\t\t\tOTG_V_TOTAL_MID, params->vertical_total_mid - 1);\n\n\t\t\tREG_UPDATE_2(OTG_V_TOTAL_CONTROL,\n\t\t\t\t\tOTG_VTOTAL_MID_REPLACING_MAX_EN, 1,\n\t\t\t\t\tOTG_VTOTAL_MID_FRAME_NUM,\n\t\t\t\t\t(uint8_t)params->vertical_total_mid_frame_num);\n\n\t\t}\n\n\t\toptc->funcs->set_vtotal_min_max(optc, params->vertical_total_min - 1, params->vertical_total_max - 1);\n\n\t\tREG_UPDATE_5(OTG_V_TOTAL_CONTROL,\n\t\t\t\tOTG_V_TOTAL_MIN_SEL, 1,\n\t\t\t\tOTG_V_TOTAL_MAX_SEL, 1,\n\t\t\t\tOTG_FORCE_LOCK_ON_EVENT, 0,\n\t\t\t\tOTG_SET_V_TOTAL_MIN_MASK_EN, 0,\n\t\t\t\tOTG_SET_V_TOTAL_MIN_MASK, 0);\n\t}\n\n\t\n\toptc->funcs->setup_manual_trigger(optc);\n}\n\nvoid optc1_set_vtotal_min_max(struct timing_generator *optc, int vtotal_min, int vtotal_max)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_V_TOTAL_MAX, 0,\n\t\tOTG_V_TOTAL_MAX, vtotal_max);\n\n\tREG_SET(OTG_V_TOTAL_MIN, 0,\n\t\tOTG_V_TOTAL_MIN, vtotal_min);\n}\n\nstatic void optc1_set_test_pattern(\n\tstruct timing_generator *optc,\n\t \n\tenum controller_dp_test_pattern test_pattern,\n\tenum dc_color_depth color_depth)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tenum test_pattern_color_format bit_depth;\n\tenum test_pattern_dyn_range dyn_range;\n\tenum test_pattern_mode mode;\n\tuint32_t pattern_mask;\n\tuint32_t pattern_data;\n\t \n\tuint32_t src_bpc = 16;\n\t \n\tuint32_t dst_bpc;\n\tuint32_t index;\n\t \n\tuint16_t src_color[6] = {0xFFFF, 0xFFFF, 0xFFFF, 0x0000,\n\t\t\t\t\t\t0x0000, 0x0000};\n\t \n\tuint16_t dst_color[6];\n\tuint32_t inc_base;\n\n\t \n\tswitch (color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_6;\n\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;\n\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_10;\n\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_12;\n\tbreak;\n\tdefault:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;\n\tbreak;\n\t}\n\n\tswitch (test_pattern) {\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORSQUARES:\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA:\n\t{\n\t\tdyn_range = (test_pattern ==\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA ?\n\t\t\t\tTEST_PATTERN_DYN_RANGE_CEA :\n\t\t\t\tTEST_PATTERN_DYN_RANGE_VESA);\n\t\tmode = TEST_PATTERN_MODE_COLORSQUARES_RGB;\n\n\t\tREG_UPDATE_2(OTG_TEST_PATTERN_PARAMETERS,\n\t\t\t\tOTG_TEST_PATTERN_VRES, 6,\n\t\t\t\tOTG_TEST_PATTERN_HRES, 6);\n\n\t\tREG_UPDATE_4(OTG_TEST_PATTERN_CONTROL,\n\t\t\t\tOTG_TEST_PATTERN_EN, 1,\n\t\t\t\tOTG_TEST_PATTERN_MODE, mode,\n\t\t\t\tOTG_TEST_PATTERN_DYNAMIC_RANGE, dyn_range,\n\t\t\t\tOTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);\n\t}\n\tbreak;\n\n\tcase CONTROLLER_DP_TEST_PATTERN_VERTICALBARS:\n\tcase CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS:\n\t{\n\t\tmode = (test_pattern ==\n\t\t\tCONTROLLER_DP_TEST_PATTERN_VERTICALBARS ?\n\t\t\tTEST_PATTERN_MODE_VERTICALBARS :\n\t\t\tTEST_PATTERN_MODE_HORIZONTALBARS);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t\tdst_bpc = 6;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t\tdst_bpc = 10;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (index = 0; index < 6; index++) {\n\t\t\t \n\t\t\tdst_color[index] =\n\t\t\t\tsrc_color[index] >> (src_bpc - dst_bpc);\n\t\t \n\t\t\tdst_color[index] <<= (16 - dst_bpc);\n\t\t}\n\n\t\tREG_WRITE(OTG_TEST_PATTERN_PARAMETERS, 0);\n\n\t\t \n\n\t\t \n\t\tpattern_data = 0;\n\t\tfor (index = 0; index < 6; index++) {\n\t\t\t \n\t\t\tpattern_mask = (1 << index);\n\n\t\t\t \n\t\t\tREG_SET_2(OTG_TEST_PATTERN_COLOR, 0,\n\t\t\t\t\tOTG_TEST_PATTERN_MASK, pattern_mask,\n\t\t\t\t\tOTG_TEST_PATTERN_DATA, pattern_data);\n\n\t\t\t \n\t\t\tpattern_data = dst_color[index];\n\t\t}\n\t\t \n\t\tREG_SET_2(OTG_TEST_PATTERN_COLOR, 0,\n\t\t\t\tOTG_TEST_PATTERN_MASK, pattern_mask,\n\t\t\t\tOTG_TEST_PATTERN_DATA, pattern_data);\n\n\t\t \n\t\tREG_UPDATE_4(OTG_TEST_PATTERN_CONTROL,\n\t\t\t\tOTG_TEST_PATTERN_EN, 1,\n\t\t\t\tOTG_TEST_PATTERN_MODE, mode,\n\t\t\t\tOTG_TEST_PATTERN_DYNAMIC_RANGE, 0,\n\t\t\t\tOTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);\n\t}\n\tbreak;\n\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORRAMP:\n\t{\n\t\tmode = (bit_depth ==\n\t\t\tTEST_PATTERN_COLOR_FORMAT_BPC_10 ?\n\t\t\tTEST_PATTERN_MODE_DUALRAMP_RGB :\n\t\t\tTEST_PATTERN_MODE_SINGLERAMP_RGB);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t\tdst_bpc = 6;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t\tdst_bpc = 10;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\t}\n\n\t\t \n\t\tinc_base = (src_bpc - dst_bpc);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t{\n\t\t\tREG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,\n\t\t\t\t\tOTG_TEST_PATTERN_INC0, inc_base,\n\t\t\t\t\tOTG_TEST_PATTERN_INC1, 0,\n\t\t\t\t\tOTG_TEST_PATTERN_HRES, 6,\n\t\t\t\t\tOTG_TEST_PATTERN_VRES, 6,\n\t\t\t\t\tOTG_TEST_PATTERN_RAMP0_OFFSET, 0);\n\t\t}\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t{\n\t\t\tREG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,\n\t\t\t\t\tOTG_TEST_PATTERN_INC0, inc_base,\n\t\t\t\t\tOTG_TEST_PATTERN_INC1, 0,\n\t\t\t\t\tOTG_TEST_PATTERN_HRES, 8,\n\t\t\t\t\tOTG_TEST_PATTERN_VRES, 6,\n\t\t\t\t\tOTG_TEST_PATTERN_RAMP0_OFFSET, 0);\n\t\t}\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t{\n\t\t\tREG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,\n\t\t\t\t\tOTG_TEST_PATTERN_INC0, inc_base,\n\t\t\t\t\tOTG_TEST_PATTERN_INC1, inc_base + 2,\n\t\t\t\t\tOTG_TEST_PATTERN_HRES, 8,\n\t\t\t\t\tOTG_TEST_PATTERN_VRES, 5,\n\t\t\t\t\tOTG_TEST_PATTERN_RAMP0_OFFSET, 384 << 6);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\tbreak;\n\t\t}\n\n\t\tREG_WRITE(OTG_TEST_PATTERN_COLOR, 0);\n\n\t\t \n\t\tREG_WRITE(OTG_TEST_PATTERN_CONTROL, 0);\n\n\t\tREG_SET_4(OTG_TEST_PATTERN_CONTROL, 0,\n\t\t\t\tOTG_TEST_PATTERN_EN, 1,\n\t\t\t\tOTG_TEST_PATTERN_MODE, mode,\n\t\t\t\tOTG_TEST_PATTERN_DYNAMIC_RANGE, 0,\n\t\t\t\tOTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);\n\t}\n\tbreak;\n\tcase CONTROLLER_DP_TEST_PATTERN_VIDEOMODE:\n\t{\n\t\tREG_WRITE(OTG_TEST_PATTERN_CONTROL, 0);\n\t\tREG_WRITE(OTG_TEST_PATTERN_COLOR, 0);\n\t\tREG_WRITE(OTG_TEST_PATTERN_PARAMETERS, 0);\n\t}\n\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n}\n\nvoid optc1_get_crtc_scanoutpos(\n\tstruct timing_generator *optc,\n\tuint32_t *v_blank_start,\n\tuint32_t *v_blank_end,\n\tuint32_t *h_position,\n\tuint32_t *v_position)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tstruct crtc_position position;\n\n\tREG_GET_2(OTG_V_BLANK_START_END,\n\t\t\tOTG_V_BLANK_START, v_blank_start,\n\t\t\tOTG_V_BLANK_END, v_blank_end);\n\n\toptc1_get_position(optc, &position);\n\n\t*h_position = position.horizontal_count;\n\t*v_position = position.vertical_count;\n}\n\nstatic void optc1_enable_stereo(struct timing_generator *optc,\n\tconst struct dc_crtc_timing *timing, struct crtc_stereo_flags *flags)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tif (flags) {\n\t\tuint32_t stereo_en;\n\t\tstereo_en = flags->FRAME_PACKED == 0 ? 1 : 0;\n\n\t\tif (flags->PROGRAM_STEREO)\n\t\t\tREG_UPDATE_3(OTG_STEREO_CONTROL,\n\t\t\t\tOTG_STEREO_EN, stereo_en,\n\t\t\t\tOTG_STEREO_SYNC_OUTPUT_LINE_NUM, 0,\n\t\t\t\tOTG_STEREO_SYNC_OUTPUT_POLARITY, flags->RIGHT_EYE_POLARITY == 0 ? 0 : 1);\n\n\t\tif (flags->PROGRAM_POLARITY)\n\t\t\tREG_UPDATE(OTG_STEREO_CONTROL,\n\t\t\t\tOTG_STEREO_EYE_FLAG_POLARITY,\n\t\t\t\tflags->RIGHT_EYE_POLARITY == 0 ? 0 : 1);\n\n\t\tif (flags->DISABLE_STEREO_DP_SYNC)\n\t\t\tREG_UPDATE(OTG_STEREO_CONTROL,\n\t\t\t\tOTG_DISABLE_STEREOSYNC_OUTPUT_FOR_DP, 1);\n\n\t\tif (flags->PROGRAM_STEREO)\n\t\t\tREG_UPDATE_2(OTG_3D_STRUCTURE_CONTROL,\n\t\t\t\tOTG_3D_STRUCTURE_EN, flags->FRAME_PACKED,\n\t\t\t\tOTG_3D_STRUCTURE_STEREO_SEL_OVR, flags->FRAME_PACKED);\n\n\t}\n}\n\nvoid optc1_program_stereo(struct timing_generator *optc,\n\tconst struct dc_crtc_timing *timing, struct crtc_stereo_flags *flags)\n{\n\tif (flags->PROGRAM_STEREO)\n\t\toptc1_enable_stereo(optc, timing, flags);\n\telse\n\t\toptc1_disable_stereo(optc);\n}\n\n\nbool optc1_is_stereo_left_eye(struct timing_generator *optc)\n{\n\tbool ret = false;\n\tuint32_t left_eye = 0;\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET(OTG_STEREO_STATUS,\n\t\tOTG_STEREO_CURRENT_EYE, &left_eye);\n\tif (left_eye == 1)\n\t\tret = true;\n\telse\n\t\tret = false;\n\n\treturn ret;\n}\n\nbool optc1_get_hw_timing(struct timing_generator *tg,\n\t\tstruct dc_crtc_timing *hw_crtc_timing)\n{\n\tstruct dcn_otg_state s = {0};\n\n\tif (tg == NULL || hw_crtc_timing == NULL)\n\t\treturn false;\n\n\toptc1_read_otg_state(DCN10TG_FROM_TG(tg), &s);\n\n\thw_crtc_timing->h_total = s.h_total + 1;\n\thw_crtc_timing->h_addressable = s.h_total - ((s.h_total - s.h_blank_start) + s.h_blank_end);\n\thw_crtc_timing->h_front_porch = s.h_total + 1 - s.h_blank_start;\n\thw_crtc_timing->h_sync_width = s.h_sync_a_end - s.h_sync_a_start;\n\n\thw_crtc_timing->v_total = s.v_total + 1;\n\thw_crtc_timing->v_addressable = s.v_total - ((s.v_total - s.v_blank_start) + s.v_blank_end);\n\thw_crtc_timing->v_front_porch = s.v_total + 1 - s.v_blank_start;\n\thw_crtc_timing->v_sync_width = s.v_sync_a_end - s.v_sync_a_start;\n\n\treturn true;\n}\n\n\nvoid optc1_read_otg_state(struct optc *optc1,\n\t\tstruct dcn_otg_state *s)\n{\n\tREG_GET(OTG_CONTROL,\n\t\t\tOTG_MASTER_EN, &s->otg_enabled);\n\n\tREG_GET_2(OTG_V_BLANK_START_END,\n\t\t\tOTG_V_BLANK_START, &s->v_blank_start,\n\t\t\tOTG_V_BLANK_END, &s->v_blank_end);\n\n\tREG_GET(OTG_V_SYNC_A_CNTL,\n\t\t\tOTG_V_SYNC_A_POL, &s->v_sync_a_pol);\n\n\tREG_GET(OTG_V_TOTAL,\n\t\t\tOTG_V_TOTAL, &s->v_total);\n\n\tREG_GET(OTG_V_TOTAL_MAX,\n\t\t\tOTG_V_TOTAL_MAX, &s->v_total_max);\n\n\tREG_GET(OTG_V_TOTAL_MIN,\n\t\t\tOTG_V_TOTAL_MIN, &s->v_total_min);\n\n\tREG_GET(OTG_V_TOTAL_CONTROL,\n\t\t\tOTG_V_TOTAL_MAX_SEL, &s->v_total_max_sel);\n\n\tREG_GET(OTG_V_TOTAL_CONTROL,\n\t\t\tOTG_V_TOTAL_MIN_SEL, &s->v_total_min_sel);\n\n\tREG_GET_2(OTG_V_SYNC_A,\n\t\t\tOTG_V_SYNC_A_START, &s->v_sync_a_start,\n\t\t\tOTG_V_SYNC_A_END, &s->v_sync_a_end);\n\n\tREG_GET_2(OTG_H_BLANK_START_END,\n\t\t\tOTG_H_BLANK_START, &s->h_blank_start,\n\t\t\tOTG_H_BLANK_END, &s->h_blank_end);\n\n\tREG_GET_2(OTG_H_SYNC_A,\n\t\t\tOTG_H_SYNC_A_START, &s->h_sync_a_start,\n\t\t\tOTG_H_SYNC_A_END, &s->h_sync_a_end);\n\n\tREG_GET(OTG_H_SYNC_A_CNTL,\n\t\t\tOTG_H_SYNC_A_POL, &s->h_sync_a_pol);\n\n\tREG_GET(OTG_H_TOTAL,\n\t\t\tOTG_H_TOTAL, &s->h_total);\n\n\tREG_GET(OPTC_INPUT_GLOBAL_CONTROL,\n\t\t\tOPTC_UNDERFLOW_OCCURRED_STATUS, &s->underflow_occurred_status);\n\n\tREG_GET(OTG_VERTICAL_INTERRUPT1_CONTROL,\n\t\t\tOTG_VERTICAL_INTERRUPT1_INT_ENABLE, &s->vertical_interrupt1_en);\n\n\tREG_GET(OTG_VERTICAL_INTERRUPT1_POSITION,\n\t\t\t\tOTG_VERTICAL_INTERRUPT1_LINE_START, &s->vertical_interrupt1_line);\n\n\tREG_GET(OTG_VERTICAL_INTERRUPT2_CONTROL,\n\t\t\tOTG_VERTICAL_INTERRUPT2_INT_ENABLE, &s->vertical_interrupt2_en);\n\n\tREG_GET(OTG_VERTICAL_INTERRUPT2_POSITION,\n\t\t\tOTG_VERTICAL_INTERRUPT2_LINE_START, &s->vertical_interrupt2_line);\n}\n\nbool optc1_get_otg_active_size(struct timing_generator *optc,\n\t\tuint32_t *otg_active_width,\n\t\tuint32_t *otg_active_height)\n{\n\tuint32_t otg_enabled;\n\tuint32_t v_blank_start;\n\tuint32_t v_blank_end;\n\tuint32_t h_blank_start;\n\tuint32_t h_blank_end;\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\n\tREG_GET(OTG_CONTROL,\n\t\t\tOTG_MASTER_EN, &otg_enabled);\n\n\tif (otg_enabled == 0)\n\t\treturn false;\n\n\tREG_GET_2(OTG_V_BLANK_START_END,\n\t\t\tOTG_V_BLANK_START, &v_blank_start,\n\t\t\tOTG_V_BLANK_END, &v_blank_end);\n\n\tREG_GET_2(OTG_H_BLANK_START_END,\n\t\t\tOTG_H_BLANK_START, &h_blank_start,\n\t\t\tOTG_H_BLANK_END, &h_blank_end);\n\n\t*otg_active_width = v_blank_start - v_blank_end;\n\t*otg_active_height = h_blank_start - h_blank_end;\n\treturn true;\n}\n\nvoid optc1_clear_optc_underflow(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE(OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_CLEAR, 1);\n}\n\nvoid optc1_tg_init(struct timing_generator *optc)\n{\n\toptc1_set_blank_data_double_buffer(optc, true);\n\toptc1_set_timing_double_buffer(optc, true);\n\toptc1_clear_optc_underflow(optc);\n}\n\nbool optc1_is_tg_enabled(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t otg_enabled = 0;\n\n\tREG_GET(OTG_CONTROL, OTG_MASTER_EN, &otg_enabled);\n\n\treturn (otg_enabled != 0);\n\n}\n\nbool optc1_is_optc_underflow_occurred(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t underflow_occurred = 0;\n\n\tREG_GET(OPTC_INPUT_GLOBAL_CONTROL,\n\t\t\tOPTC_UNDERFLOW_OCCURRED_STATUS,\n\t\t\t&underflow_occurred);\n\n\treturn (underflow_occurred == 1);\n}\n\nbool optc1_configure_crc(struct timing_generator *optc,\n\t\t\t  const struct crc_params *params)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tif (!optc1_is_tg_enabled(optc))\n\t\treturn false;\n\n\tREG_WRITE(OTG_CRC_CNTL, 0);\n\n\tif (!params->enable)\n\t\treturn true;\n\n\t \n\t \n\tREG_UPDATE_2(OTG_CRC0_WINDOWA_X_CONTROL,\n\t\t\tOTG_CRC0_WINDOWA_X_START, params->windowa_x_start,\n\t\t\tOTG_CRC0_WINDOWA_X_END, params->windowa_x_end);\n\n\t \n\tREG_UPDATE_2(OTG_CRC0_WINDOWA_Y_CONTROL,\n\t\t\tOTG_CRC0_WINDOWA_Y_START, params->windowa_y_start,\n\t\t\tOTG_CRC0_WINDOWA_Y_END, params->windowa_y_end);\n\n\t \n\tREG_UPDATE_2(OTG_CRC0_WINDOWB_X_CONTROL,\n\t\t\tOTG_CRC0_WINDOWB_X_START, params->windowb_x_start,\n\t\t\tOTG_CRC0_WINDOWB_X_END, params->windowb_x_end);\n\n\t \n\tREG_UPDATE_2(OTG_CRC0_WINDOWB_Y_CONTROL,\n\t\t\tOTG_CRC0_WINDOWB_Y_START, params->windowb_y_start,\n\t\t\tOTG_CRC0_WINDOWB_Y_END, params->windowb_y_end);\n\n\t \n\tREG_UPDATE_3(OTG_CRC_CNTL,\n\t\t\tOTG_CRC_CONT_EN, params->continuous_mode ? 1 : 0,\n\t\t\tOTG_CRC0_SELECT, params->selection,\n\t\t\tOTG_CRC_EN, 1);\n\n\treturn true;\n}\n\n \nbool optc1_get_crc(struct timing_generator *optc,\n\t\t   uint32_t *r_cr, uint32_t *g_y, uint32_t *b_cb)\n{\n\tuint32_t field = 0;\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET(OTG_CRC_CNTL, OTG_CRC_EN, &field);\n\n\t \n\tif (!field)\n\t\treturn false;\n\n\t \n\tREG_GET_2(OTG_CRC0_DATA_RG,\n\t\t  CRC0_R_CR, r_cr,\n\t\t  CRC0_G_Y, g_y);\n\n\t \n\tREG_GET(OTG_CRC0_DATA_B,\n\t\tCRC0_B_CB, b_cb);\n\n\treturn true;\n}\n\nstatic const struct timing_generator_funcs dcn10_tg_funcs = {\n\t\t.validate_timing = optc1_validate_timing,\n\t\t.program_timing = optc1_program_timing,\n\t\t.setup_vertical_interrupt0 = optc1_setup_vertical_interrupt0,\n\t\t.setup_vertical_interrupt1 = optc1_setup_vertical_interrupt1,\n\t\t.setup_vertical_interrupt2 = optc1_setup_vertical_interrupt2,\n\t\t.program_global_sync = optc1_program_global_sync,\n\t\t.enable_crtc = optc1_enable_crtc,\n\t\t.disable_crtc = optc1_disable_crtc,\n\t\t \n\t\t.is_counter_moving = optc1_is_counter_moving,\n\t\t.get_position = optc1_get_position,\n\t\t.get_frame_count = optc1_get_vblank_counter,\n\t\t.get_scanoutpos = optc1_get_crtc_scanoutpos,\n\t\t.get_otg_active_size = optc1_get_otg_active_size,\n\t\t.set_early_control = optc1_set_early_control,\n\t\t \n\t\t.wait_for_state = optc1_wait_for_state,\n\t\t.set_blank = optc1_set_blank,\n\t\t.is_blanked = optc1_is_blanked,\n\t\t.set_blank_color = optc1_program_blank_color,\n\t\t.did_triggered_reset_occur = optc1_did_triggered_reset_occur,\n\t\t.enable_reset_trigger = optc1_enable_reset_trigger,\n\t\t.enable_crtc_reset = optc1_enable_crtc_reset,\n\t\t.disable_reset_trigger = optc1_disable_reset_trigger,\n\t\t.lock = optc1_lock,\n\t\t.unlock = optc1_unlock,\n\t\t.enable_optc_clock = optc1_enable_optc_clock,\n\t\t.set_drr = optc1_set_drr,\n\t\t.get_last_used_drr_vtotal = NULL,\n\t\t.set_vtotal_min_max = optc1_set_vtotal_min_max,\n\t\t.set_static_screen_control = optc1_set_static_screen_control,\n\t\t.set_test_pattern = optc1_set_test_pattern,\n\t\t.program_stereo = optc1_program_stereo,\n\t\t.is_stereo_left_eye = optc1_is_stereo_left_eye,\n\t\t.set_blank_data_double_buffer = optc1_set_blank_data_double_buffer,\n\t\t.tg_init = optc1_tg_init,\n\t\t.is_tg_enabled = optc1_is_tg_enabled,\n\t\t.is_optc_underflow_occurred = optc1_is_optc_underflow_occurred,\n\t\t.clear_optc_underflow = optc1_clear_optc_underflow,\n\t\t.get_crc = optc1_get_crc,\n\t\t.configure_crc = optc1_configure_crc,\n\t\t.set_vtg_params = optc1_set_vtg_params,\n\t\t.program_manual_trigger = optc1_program_manual_trigger,\n\t\t.setup_manual_trigger = optc1_setup_manual_trigger,\n\t\t.get_hw_timing = optc1_get_hw_timing,\n};\n\nvoid dcn10_timing_generator_init(struct optc *optc1)\n{\n\toptc1->base.funcs = &dcn10_tg_funcs;\n\n\toptc1->max_h_total = optc1->tg_mask->OTG_H_TOTAL + 1;\n\toptc1->max_v_total = optc1->tg_mask->OTG_V_TOTAL + 1;\n\n\toptc1->min_h_blank = 32;\n\toptc1->min_v_blank = 3;\n\toptc1->min_v_blank_interlace = 5;\n\toptc1->min_h_sync_width = 4;\n\toptc1->min_v_sync_width = 1;\n}\n\n \nbool optc1_is_two_pixels_per_containter(const struct dc_crtc_timing *timing)\n{\n\tbool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;\n\n\ttwo_pix = two_pix || (timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422\n\t\t\t&& !timing->dsc_cfg.ycbcr422_simple);\n\treturn two_pix;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}