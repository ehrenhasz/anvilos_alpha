{
  "module_name": "dmub_replay.c",
  "hash_id": "2086dbe4d98a3fc262b3df2c739629e6edf188b9aaa5d9f96d9432aedebe90de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dmub_replay.c",
  "human_readable_source": " \n\n#include \"dc.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dmub/dmub_srv.h\"\n#include \"core_types.h\"\n#include \"dmub_replay.h\"\n\n#define DC_TRACE_LEVEL_MESSAGE(...)  \n\n#define MAX_PIPES 6\n\n \nstatic void dmub_replay_get_state(struct dmub_replay *dmub, enum replay_state *state, uint8_t panel_inst)\n{\n\tstruct dmub_srv *srv = dmub->ctx->dmub_srv->dmub;\n\t \n\tuint32_t retry_count = 0;\n\tenum dmub_status status;\n\n\tdo {\n\t\t\n\t\tstatus = dmub_srv_send_gpint_command(srv, DMUB_GPINT__GET_REPLAY_STATE, panel_inst, 30);\n\n\t\tif (status == DMUB_STATUS_OK) {\n\t\t\t\n\t\t\tdmub_srv_get_gpint_response(srv, (uint32_t *)state);\n\t\t} else\n\t\t\t\n\t\t\t*state = REPLAY_STATE_INVALID;\n\t} while (++retry_count <= 1000 && *state == REPLAY_STATE_INVALID);\n\n\t\n\tif (retry_count >= 1000 && *state == REPLAY_STATE_INVALID) {\n\t\tASSERT(0);\n\t\t \n\t}\n}\n\n \nstatic void dmub_replay_enable(struct dmub_replay *dmub, bool enable, bool wait, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\tuint32_t retry_count;\n\tenum replay_state state = REPLAY_STATE_0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.replay_enable.header.type = DMUB_CMD__REPLAY;\n\tcmd.replay_enable.data.panel_inst = panel_inst;\n\n\tcmd.replay_enable.header.sub_type = DMUB_CMD__REPLAY_ENABLE;\n\tif (enable)\n\t\tcmd.replay_enable.data.enable = REPLAY_ENABLE;\n\telse\n\t\tcmd.replay_enable.data.enable = REPLAY_DISABLE;\n\n\tcmd.replay_enable.header.payload_bytes = sizeof(struct dmub_rb_cmd_replay_enable_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t \n\tif (wait) {\n\t\tfor (retry_count = 0; retry_count <= 1000; retry_count++) {\n\t\t\tdmub_replay_get_state(dmub, &state, panel_inst);\n\n\t\t\tif (enable) {\n\t\t\t\tif (state != REPLAY_STATE_0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (state == REPLAY_STATE_0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfsleep(500);\n\t\t}\n\n\t\t \n\t\tif (retry_count >= 1000)\n\t\t\tASSERT(0);\n\t}\n\n}\n\n \nstatic void dmub_replay_set_power_opt(struct dmub_replay *dmub, unsigned int power_opt, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.replay_set_power_opt.header.type = DMUB_CMD__REPLAY;\n\tcmd.replay_set_power_opt.header.sub_type = DMUB_CMD__SET_REPLAY_POWER_OPT;\n\tcmd.replay_set_power_opt.header.payload_bytes = sizeof(struct dmub_cmd_replay_set_power_opt_data);\n\tcmd.replay_set_power_opt.replay_set_power_opt_data.power_opt = power_opt;\n\tcmd.replay_set_power_opt.replay_set_power_opt_data.panel_inst = panel_inst;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic bool dmub_replay_copy_settings(struct dmub_replay *dmub,\n\tstruct dc_link *link,\n\tstruct replay_context *replay_context,\n\tuint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\tstruct dmub_cmd_replay_copy_settings_data *copy_settings_data\n\t\t= &cmd.replay_copy_settings.replay_copy_settings_data;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tstruct resource_context *res_ctx = &link->ctx->dc->current_state->res_ctx;\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (res_ctx &&\n\t\t\tres_ctx->pipe_ctx[i].stream &&\n\t\t\tres_ctx->pipe_ctx[i].stream->link &&\n\t\t\tres_ctx->pipe_ctx[i].stream->link == link &&\n\t\t\tres_ctx->pipe_ctx[i].stream->link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\tpipe_ctx = &res_ctx->pipe_ctx[i];\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pipe_ctx)\n\t\treturn false;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.replay_copy_settings.header.type = DMUB_CMD__REPLAY;\n\tcmd.replay_copy_settings.header.sub_type = DMUB_CMD__REPLAY_COPY_SETTINGS;\n\tcmd.replay_copy_settings.header.payload_bytes = sizeof(struct dmub_cmd_replay_copy_settings_data);\n\n\t\n\tcopy_settings_data->aux_inst\t\t\t\t= replay_context->aux_inst;\n\tcopy_settings_data->digbe_inst\t\t\t\t= replay_context->digbe_inst;\n\tcopy_settings_data->digfe_inst\t\t\t\t= replay_context->digfe_inst;\n\n\tif (pipe_ctx->plane_res.dpp)\n\t\tcopy_settings_data->dpp_inst\t\t\t= pipe_ctx->plane_res.dpp->inst;\n\telse\n\t\tcopy_settings_data->dpp_inst\t\t\t= 0;\n\tif (pipe_ctx->stream_res.tg)\n\t\tcopy_settings_data->otg_inst\t\t\t= pipe_ctx->stream_res.tg->inst;\n\telse\n\t\tcopy_settings_data->otg_inst\t\t\t= 0;\n\n\tcopy_settings_data->dpphy_inst\t\t\t\t= link->link_enc->transmitter;\n\n\t\n\tcopy_settings_data->line_time_in_ns\t\t\t= replay_context->line_time_in_ns;\n\tcopy_settings_data->panel_inst\t\t\t\t= panel_inst;\n\tcopy_settings_data->debug.u32All\t\t\t= link->replay_settings.config.debug_flags;\n\tcopy_settings_data->pixel_deviation_per_line\t\t= link->dpcd_caps.pr_info.pixel_deviation_per_line;\n\tcopy_settings_data->max_deviation_line\t\t\t= link->dpcd_caps.pr_info.max_deviation_line;\n\tcopy_settings_data->smu_optimizations_en\t\t= link->replay_settings.replay_smu_opt_enable;\n\tcopy_settings_data->replay_timing_sync_supported = link->replay_settings.config.replay_timing_sync_supported;\n\n\tcopy_settings_data->flags.u32All = 0;\n\tcopy_settings_data->flags.bitfields.fec_enable_status = (link->fec_state == dc_link_fec_enabled);\n\tcopy_settings_data->flags.bitfields.dsc_enable_status = (pipe_ctx->stream->timing.flags.DSC == 1);\n\t\n\tif (((link->dpcd_caps.fec_cap.bits.FEC_CAPABLE &&\n\t\t!link->dc->debug.disable_fec) &&\n\t\t(link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT &&\n\t\t!link->panel_config.dsc.disable_dsc_edp &&\n\t\tlink->dc->caps.edp_dsc_support)) &&\n\t\tlink->dpcd_caps.sink_dev_id == DP_DEVICE_ID_38EC11  )\n\t\tcopy_settings_data->flags.bitfields.force_wakeup_by_tps3 = 1;\n\telse\n\t\tcopy_settings_data->flags.bitfields.force_wakeup_by_tps3 = 0;\n\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n \nstatic void dmub_replay_set_coasting_vtotal(struct dmub_replay *dmub,\n\t\tuint16_t coasting_vtotal,\n\t\tuint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.replay_set_coasting_vtotal.header.type = DMUB_CMD__REPLAY;\n\tcmd.replay_set_coasting_vtotal.header.sub_type = DMUB_CMD__REPLAY_SET_COASTING_VTOTAL;\n\tcmd.replay_set_coasting_vtotal.header.payload_bytes = sizeof(struct dmub_cmd_replay_set_coasting_vtotal_data);\n\tcmd.replay_set_coasting_vtotal.replay_set_coasting_vtotal_data.coasting_vtotal = coasting_vtotal;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic void dmub_replay_residency(struct dmub_replay *dmub, uint8_t panel_inst,\n\tuint32_t *residency, const bool is_start, const bool is_alpm)\n{\n\tstruct dmub_srv *srv = dmub->ctx->dmub_srv->dmub;\n\tuint16_t param = (uint16_t)(panel_inst << 8);\n\n\tif (is_alpm)\n\t\tparam |= REPLAY_RESIDENCY_MODE_ALPM;\n\n\tif (is_start)\n\t\tparam |= REPLAY_RESIDENCY_ENABLE;\n\n\t\n\tdmub_srv_send_gpint_command(srv, DMUB_GPINT__REPLAY_RESIDENCY, param, 30);\n\n\tif (!is_start)\n\t\tdmub_srv_get_gpint_response(srv, residency);\n\telse\n\t\t*residency = 0;\n}\n\nstatic const struct dmub_replay_funcs replay_funcs = {\n\t.replay_copy_settings\t\t= dmub_replay_copy_settings,\n\t.replay_enable\t\t\t= dmub_replay_enable,\n\t.replay_get_state\t\t= dmub_replay_get_state,\n\t.replay_set_power_opt\t\t= dmub_replay_set_power_opt,\n\t.replay_set_coasting_vtotal\t= dmub_replay_set_coasting_vtotal,\n\t.replay_residency\t\t= dmub_replay_residency,\n};\n\n \nstatic void dmub_replay_construct(struct dmub_replay *replay, struct dc_context *ctx)\n{\n\treplay->ctx = ctx;\n\treplay->funcs = &replay_funcs;\n}\n\n \nstruct dmub_replay *dmub_replay_create(struct dc_context *ctx)\n{\n\tstruct dmub_replay *replay = kzalloc(sizeof(struct dmub_replay), GFP_KERNEL);\n\n\tif (replay == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdmub_replay_construct(replay, ctx);\n\n\treturn replay;\n}\n\n \nvoid dmub_replay_destroy(struct dmub_replay **dmub)\n{\n\tkfree(*dmub);\n\t*dmub = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}