{
  "module_name": "dcn20_optc.c",
  "hash_id": "c88a6ce6efae8cb445ad08da5a4d4e1211ce287d8ee83a968ca8de0e083cde27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"dcn20_optc.h\"\n#include \"dc.h\"\n\n#define REG(reg)\\\n\toptc1->tg_regs->reg\n\n#define CTX \\\n\toptc1->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\toptc1->tg_shift->field_name, optc1->tg_mask->field_name\n\n \nbool optc2_enable_crtc(struct timing_generator *optc)\n{\n\t \n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE(OPTC_DATA_SOURCE_SELECT,\n\t\t\tOPTC_SEG0_SRC_SEL, optc->inst);\n\n\t \n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 1);\n\n\tREG_SEQ_START();\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL,\n\t\t\tOTG_DISABLE_POINT_CNTL, 3,\n\t\t\tOTG_MASTER_EN, 1);\n\n\tREG_SEQ_SUBMIT();\n\tREG_SEQ_WAIT_DONE();\n\n\treturn true;\n}\n\n \nvoid optc2_set_gsl(struct timing_generator *optc,\n\t\t   const struct gsl_params *params)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n \n\tREG_UPDATE_5(OTG_GSL_CONTROL,\n\t\tOTG_GSL0_EN, params->gsl0_en,\n\t\tOTG_GSL1_EN, params->gsl1_en,\n\t\tOTG_GSL2_EN, params->gsl2_en,\n\t\tOTG_GSL_MASTER_EN, params->gsl_master_en,\n\t\tOTG_GSL_MASTER_MODE, params->gsl_master_mode);\n}\n\n\nvoid optc2_set_gsl_source_select(\n\t\tstruct timing_generator *optc,\n\t\tint group_idx,\n\t\tuint32_t gsl_ready_signal)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tswitch (group_idx) {\n\tcase 1:\n\t\tREG_UPDATE(GSL_SOURCE_SELECT, GSL0_READY_SOURCE_SEL, gsl_ready_signal);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE(GSL_SOURCE_SELECT, GSL1_READY_SOURCE_SEL, gsl_ready_signal);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE(GSL_SOURCE_SELECT, GSL2_READY_SOURCE_SEL, gsl_ready_signal);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid optc2_set_dsc_config(struct timing_generator *optc,\n\t\t\t\t\tenum optc_dsc_mode dsc_mode,\n\t\t\t\t\tuint32_t dsc_bytes_per_pixel,\n\t\t\t\t\tuint32_t dsc_slice_width)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE(OPTC_DATA_FORMAT_CONTROL,\n\t\tOPTC_DSC_MODE, dsc_mode);\n\n\tREG_SET(OPTC_BYTES_PER_PIXEL, 0,\n\t\tOPTC_DSC_BYTES_PER_PIXEL, dsc_bytes_per_pixel);\n\n\tREG_UPDATE(OPTC_WIDTH_CONTROL,\n\t\tOPTC_DSC_SLICE_WIDTH, dsc_slice_width);\n}\n\n \nvoid optc2_get_dsc_status(struct timing_generator *optc,\n\t\t\t\t\tuint32_t *dsc_mode)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET(OPTC_DATA_FORMAT_CONTROL,\n\t\tOPTC_DSC_MODE, dsc_mode);\n}\n\n\n \nbool optc2_is_two_pixels_per_containter(const struct dc_crtc_timing *timing)\n{\n\treturn optc1_is_two_pixels_per_containter(timing);\n}\n\nvoid optc2_set_odm_bypass(struct timing_generator *optc,\n\t\tconst struct dc_crtc_timing *dc_crtc_timing)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t h_div_2 = 0;\n\n\tREG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,\n\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, 0,\n\t\t\tOPTC_SEG0_SRC_SEL, optc->inst,\n\t\t\tOPTC_SEG1_SRC_SEL, 0xf);\n\tREG_WRITE(OTG_H_TIMING_CNTL, 0);\n\n\th_div_2 = optc2_is_two_pixels_per_containter(dc_crtc_timing);\n\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\t\tOTG_H_TIMING_DIV_BY2, h_div_2);\n\tREG_SET(OPTC_MEMORY_CONFIG, 0,\n\t\t\tOPTC_MEM_SEL, 0);\n\toptc1->opp_count = 1;\n}\n\nvoid optc2_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_cnt,\n\t\tstruct dc_crtc_timing *timing)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tint mpcc_hactive = (timing->h_addressable + timing->h_border_left + timing->h_border_right)\n\t\t\t/ opp_cnt;\n\tuint32_t memory_mask;\n\n\tASSERT(opp_cnt == 2);\n\n\t \n\n\t \n\tmemory_mask = 0x3 << (opp_id[0] * 2) | 0x3 << (opp_id[1] * 2);\n\n\tif (REG(OPTC_MEMORY_CONFIG))\n\t\tREG_SET(OPTC_MEMORY_CONFIG, 0,\n\t\t\tOPTC_MEM_SEL, memory_mask);\n\n\tREG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,\n\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, 1,\n\t\t\tOPTC_SEG0_SRC_SEL, opp_id[0],\n\t\t\tOPTC_SEG1_SRC_SEL, opp_id[1]);\n\n\tREG_UPDATE(OPTC_WIDTH_CONTROL,\n\t\t\tOPTC_SEGMENT_WIDTH, mpcc_hactive);\n\n\tREG_SET(OTG_H_TIMING_CNTL, 0, OTG_H_TIMING_DIV_BY2, 1);\n\toptc1->opp_count = opp_cnt;\n}\n\nvoid optc2_get_optc_source(struct timing_generator *optc,\n\t\tuint32_t *num_of_src_opp,\n\t\tuint32_t *src_opp_id_0,\n\t\tuint32_t *src_opp_id_1)\n{\n\tuint32_t num_of_input_segments;\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET_3(OPTC_DATA_SOURCE_SELECT,\n\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, &num_of_input_segments,\n\t\t\tOPTC_SEG0_SRC_SEL, src_opp_id_0,\n\t\t\tOPTC_SEG1_SRC_SEL, src_opp_id_1);\n\n\tif (num_of_input_segments == 1)\n\t\t*num_of_src_opp = 2;\n\telse\n\t\t*num_of_src_opp = 1;\n\n\t \n\tif (*src_opp_id_1 == 0xf)\n\t\t*num_of_src_opp = 1;\n}\n\nstatic void optc2_set_dwb_source(struct timing_generator *optc,\n\t\t\t\t uint32_t dwb_pipe_inst)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tif (dwb_pipe_inst == 0)\n\t\tREG_UPDATE(DWB_SOURCE_SELECT,\n\t\t\t\tOPTC_DWB0_SOURCE_SELECT, optc->inst);\n\telse if (dwb_pipe_inst == 1)\n\t\tREG_UPDATE(DWB_SOURCE_SELECT,\n\t\t\t\tOPTC_DWB1_SOURCE_SELECT, optc->inst);\n}\n\nstatic void optc2_align_vblanks(\n\tstruct timing_generator *optc_master,\n\tstruct timing_generator *optc_slave,\n\tuint32_t master_pixel_clock_100Hz,\n\tuint32_t slave_pixel_clock_100Hz,\n\tuint8_t master_clock_divider,\n\tuint8_t slave_clock_divider)\n{\n\t \n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc_slave);\n\n\tuint32_t master_v_active = 0;\n\tuint32_t master_h_total = 0;\n\tuint32_t slave_h_total = 0;\n\tuint64_t L, XY;\n\tuint32_t X, Y, p = 10000;\n\tuint32_t master_update_lock;\n\n\t \n\tREG_UPDATE(OTG_CONTROL, OTG_MASTER_EN, 0);\n\t \n\tREG_WAIT(OTG_CONTROL,\n\t\t\t OTG_CURRENT_MASTER_EN_STATE,\n\t\t\t 0, 10, 5000);\n\n\tREG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &slave_h_total);\n\n\t \n\tREG_SET(OTG_GLOBAL_CONTROL0, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK_SEL, optc_master->inst);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_master);\n\n\t \n\tREG_GET(OTG_MASTER_UPDATE_LOCK,\n\t\t\tOTG_MASTER_UPDATE_LOCK, &master_update_lock);\n\t \n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, 0);\n\n\tREG_GET(OTG_V_BLANK_START_END,\n\t\t\tOTG_V_BLANK_START, &master_v_active);\n\tREG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &master_h_total);\n\n\t \n\tL = (uint64_t)p * slave_h_total * master_pixel_clock_100Hz;\n\tL = div_u64(L, master_h_total);\n\tL = div_u64(L, slave_pixel_clock_100Hz);\n\tXY = div_u64(L, p);\n\tY = master_v_active - XY - 1;\n\tX = div_u64(((XY + 1) * p - L) * master_h_total, p * master_clock_divider);\n\n\t \n\tREG_UPDATE(OTG_GLOBAL_CONTROL1,\n\t\t\t   MASTER_UPDATE_LOCK_DB_EN, 1);\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL1,\n\t\t\t\t MASTER_UPDATE_LOCK_DB_X,\n\t\t\t\t X,\n\t\t\t\t MASTER_UPDATE_LOCK_DB_Y,\n\t\t\t\t Y);\n\n\t \n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, 1);\n\tREG_WAIT(OTG_MASTER_UPDATE_LOCK,\n\t\t\t UPDATE_LOCK_STATUS, 1, 1, 10);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_slave);\n\n\t \n\tREG_UPDATE(OTG_CONTROL,\n\t\t\t   OTG_MASTER_EN, 1);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_master);\n\n\t \n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, 0);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_slave);\n\n\t \n\tREG_WAIT(OTG_CONTROL,\n\t\t\t OTG_CURRENT_MASTER_EN_STATE,\n\t\t\t 1, 10, 5000);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_master);\n\n\t \n\tREG_UPDATE(OTG_GLOBAL_CONTROL1,\n\t\t\t   MASTER_UPDATE_LOCK_DB_EN, 0);\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL1,\n\t\t\t\t MASTER_UPDATE_LOCK_DB_X,\n\t\t\t\t 0,\n\t\t\t\t MASTER_UPDATE_LOCK_DB_Y,\n\t\t\t\t 0);\n\n\t \n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK, master_update_lock);\n\n\t \n\toptc1 = DCN10TG_FROM_TG(optc_slave);\n\t \n\tREG_SET(OTG_GLOBAL_CONTROL0, 0,\n\t\t\tOTG_MASTER_UPDATE_LOCK_SEL, optc_slave->inst);\n\n}\n\nvoid optc2_triplebuffer_lock(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_GLOBAL_CONTROL0, 0,\n\t\tOTG_MASTER_UPDATE_LOCK_SEL, optc->inst);\n\n\tREG_SET(OTG_VUPDATE_KEEPOUT, 0,\n\t\tOTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, 1);\n\n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\tOTG_MASTER_UPDATE_LOCK, 1);\n\n\tREG_WAIT(OTG_MASTER_UPDATE_LOCK,\n\t\t\tUPDATE_LOCK_STATUS, 1,\n\t\t\t1, 10);\n}\n\nvoid optc2_triplebuffer_unlock(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_MASTER_UPDATE_LOCK, 0,\n\t\tOTG_MASTER_UPDATE_LOCK, 0);\n\n\tREG_SET(OTG_VUPDATE_KEEPOUT, 0,\n\t\tOTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, 0);\n\n}\n\nvoid optc2_lock_doublebuffer_enable(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t v_blank_start = 0;\n\tuint32_t h_blank_start = 0;\n\n\tREG_UPDATE(OTG_GLOBAL_CONTROL1, MASTER_UPDATE_LOCK_DB_EN, 1);\n\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1,\n\t\t\tDIG_UPDATE_LOCATION, 20);\n\n\tREG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START, &v_blank_start);\n\n\tREG_GET(OTG_H_BLANK_START_END, OTG_H_BLANK_START, &h_blank_start);\n\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL1,\n\t\t\tMASTER_UPDATE_LOCK_DB_X,\n\t\t\t(h_blank_start - 200 - 1) / optc1->opp_count,\n\t\t\tMASTER_UPDATE_LOCK_DB_Y,\n\t\t\tv_blank_start - 1);\n\n\tREG_SET_3(OTG_VUPDATE_KEEPOUT, 0,\n\t\tMASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_START_OFFSET, 0,\n\t\tMASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_END_OFFSET, 100,\n\t\tOTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, 1);\n}\n\nvoid optc2_lock_doublebuffer_disable(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL1,\n\t\t\t\tMASTER_UPDATE_LOCK_DB_X,\n\t\t\t\t0,\n\t\t\t\tMASTER_UPDATE_LOCK_DB_Y,\n\t\t\t\t0);\n\n\tREG_UPDATE_2(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0,\n\t\t\t\tDIG_UPDATE_LOCATION, 0);\n\n\tREG_UPDATE(OTG_GLOBAL_CONTROL1, MASTER_UPDATE_LOCK_DB_EN, 0);\n}\n\nvoid optc2_setup_manual_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE_4(OTG_V_TOTAL_CONTROL,\n\t\t\t\t OTG_V_TOTAL_MIN_SEL, 1,\n\t\t\t\t OTG_V_TOTAL_MAX_SEL, 1,\n\t\t\t\t OTG_FORCE_LOCK_ON_EVENT, 0,\n\t\t\t\t OTG_SET_V_TOTAL_MIN_MASK, (1 << 1));  \n\n\tREG_SET_8(OTG_TRIGA_CNTL, 0,\n\t\t\tOTG_TRIGA_SOURCE_SELECT, 21,\n\t\t\tOTG_TRIGA_SOURCE_PIPE_SELECT, optc->inst,\n\t\t\tOTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1,\n\t\t\tOTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 0,\n\t\t\tOTG_TRIGA_POLARITY_SELECT, 0,\n\t\t\tOTG_TRIGA_FREQUENCY_SELECT, 0,\n\t\t\tOTG_TRIGA_DELAY, 0,\n\t\t\tOTG_TRIGA_CLEAR, 1);\n}\n\nvoid optc2_program_manual_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET(OTG_TRIGA_MANUAL_TRIG, 0,\n\t\t\tOTG_TRIGA_MANUAL_TRIG, 1);\n}\n\nbool optc2_configure_crc(struct timing_generator *optc,\n\t\t\t  const struct crc_params *params)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_SET_2(OTG_CRC_CNTL2, 0,\n\t\t\tOTG_CRC_DSC_MODE, params->dsc_mode,\n\t\t\tOTG_CRC_DATA_STREAM_COMBINE_MODE, params->odm_mode);\n\n\treturn optc1_configure_crc(optc, params);\n}\n\n\nvoid optc2_get_last_used_drr_vtotal(struct timing_generator *optc, uint32_t *refresh_rate)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_GET(OTG_DRR_CONTROL, OTG_V_TOTAL_LAST_USED_BY_DRR, refresh_rate);\n}\n\nstatic struct timing_generator_funcs dcn20_tg_funcs = {\n\t\t.validate_timing = optc1_validate_timing,\n\t\t.program_timing = optc1_program_timing,\n\t\t.setup_vertical_interrupt0 = optc1_setup_vertical_interrupt0,\n\t\t.setup_vertical_interrupt1 = optc1_setup_vertical_interrupt1,\n\t\t.setup_vertical_interrupt2 = optc1_setup_vertical_interrupt2,\n\t\t.program_global_sync = optc1_program_global_sync,\n\t\t.enable_crtc = optc2_enable_crtc,\n\t\t.disable_crtc = optc1_disable_crtc,\n\t\t \n\t\t.is_counter_moving = optc1_is_counter_moving,\n\t\t.get_position = optc1_get_position,\n\t\t.get_frame_count = optc1_get_vblank_counter,\n\t\t.get_scanoutpos = optc1_get_crtc_scanoutpos,\n\t\t.get_otg_active_size = optc1_get_otg_active_size,\n\t\t.set_early_control = optc1_set_early_control,\n\t\t \n\t\t.wait_for_state = optc1_wait_for_state,\n\t\t.set_blank = optc1_set_blank,\n\t\t.is_blanked = optc1_is_blanked,\n\t\t.set_blank_color = optc1_program_blank_color,\n\t\t.enable_reset_trigger = optc1_enable_reset_trigger,\n\t\t.enable_crtc_reset = optc1_enable_crtc_reset,\n\t\t.did_triggered_reset_occur = optc1_did_triggered_reset_occur,\n\t\t.triplebuffer_lock = optc2_triplebuffer_lock,\n\t\t.triplebuffer_unlock = optc2_triplebuffer_unlock,\n\t\t.disable_reset_trigger = optc1_disable_reset_trigger,\n\t\t.lock = optc1_lock,\n\t\t.unlock = optc1_unlock,\n\t\t.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,\n\t\t.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,\n\t\t.enable_optc_clock = optc1_enable_optc_clock,\n\t\t.set_drr = optc1_set_drr,\n\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,\n\t\t.set_vtotal_min_max = optc1_set_vtotal_min_max,\n\t\t.set_static_screen_control = optc1_set_static_screen_control,\n\t\t.program_stereo = optc1_program_stereo,\n\t\t.is_stereo_left_eye = optc1_is_stereo_left_eye,\n\t\t.set_blank_data_double_buffer = optc1_set_blank_data_double_buffer,\n\t\t.tg_init = optc1_tg_init,\n\t\t.is_tg_enabled = optc1_is_tg_enabled,\n\t\t.is_optc_underflow_occurred = optc1_is_optc_underflow_occurred,\n\t\t.clear_optc_underflow = optc1_clear_optc_underflow,\n\t\t.setup_global_swap_lock = NULL,\n\t\t.get_crc = optc1_get_crc,\n\t\t.configure_crc = optc2_configure_crc,\n\t\t.set_dsc_config = optc2_set_dsc_config,\n\t\t.get_dsc_status = optc2_get_dsc_status,\n\t\t.set_dwb_source = optc2_set_dwb_source,\n\t\t.set_odm_bypass = optc2_set_odm_bypass,\n\t\t.set_odm_combine = optc2_set_odm_combine,\n\t\t.get_optc_source = optc2_get_optc_source,\n\t\t.set_gsl = optc2_set_gsl,\n\t\t.set_gsl_source_select = optc2_set_gsl_source_select,\n\t\t.set_vtg_params = optc1_set_vtg_params,\n\t\t.program_manual_trigger = optc2_program_manual_trigger,\n\t\t.setup_manual_trigger = optc2_setup_manual_trigger,\n\t\t.get_hw_timing = optc1_get_hw_timing,\n\t\t.align_vblanks = optc2_align_vblanks,\n};\n\nvoid dcn20_timing_generator_init(struct optc *optc1)\n{\n\toptc1->base.funcs = &dcn20_tg_funcs;\n\n\toptc1->max_h_total = optc1->tg_mask->OTG_H_TOTAL + 1;\n\toptc1->max_v_total = optc1->tg_mask->OTG_V_TOTAL + 1;\n\n\toptc1->min_h_blank = 32;\n\toptc1->min_v_blank = 3;\n\toptc1->min_v_blank_interlace = 5;\n\toptc1->min_h_sync_width = 4;\n\toptc1->min_v_sync_width = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}