{
  "module_name": "dcn32_optc.c",
  "hash_id": "e8ae67fffe0b02c1a417635e94824e3ca0f858911f4951d2d8c4564719dafb2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_optc.c",
  "human_readable_source": " \n\n#include \"dcn32_optc.h\"\n\n#include \"dcn30/dcn30_optc.h\"\n#include \"dcn31/dcn31_optc.h\"\n#include \"reg_helper.h\"\n#include \"dc.h\"\n#include \"dcn_calc_math.h\"\n#include \"dc_dmub_srv.h\"\n\n#define REG(reg)\\\n\toptc1->tg_regs->reg\n\n#define CTX \\\n\toptc1->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\toptc1->tg_shift->field_name, optc1->tg_mask->field_name\n\nstatic void optc32_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_cnt,\n\t\tstruct dc_crtc_timing *timing)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tuint32_t memory_mask = 0;\n\tint h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;\n\tint mpcc_hactive = h_active / opp_cnt;\n\t \n\tint odm_mem_count = (h_active + 2047) / 2048;\n\n\t \n\tif (opp_cnt == 4) {\n\t\tif (odm_mem_count <= 2)\n\t\t\tmemory_mask = 0x3;\n\t\telse if (odm_mem_count <= 4)\n\t\t\tmemory_mask = 0xf;\n\t\telse\n\t\t\tmemory_mask = 0x3f;\n\t} else {\n\t\tif (odm_mem_count <= 2)\n\t\t\tmemory_mask = 0x1 << (opp_id[0] * 2) | 0x1 << (opp_id[1] * 2);\n\t\telse if (odm_mem_count <= 4)\n\t\t\tmemory_mask = 0x3 << (opp_id[0] * 2) | 0x3 << (opp_id[1] * 2);\n\t\telse\n\t\t\tmemory_mask = 0x77;\n\t}\n\n\tREG_SET(OPTC_MEMORY_CONFIG, 0,\n\t\tOPTC_MEM_SEL, memory_mask);\n\n\tif (opp_cnt == 2) {\n\t\tREG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,\n\t\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, 1,\n\t\t\t\tOPTC_SEG0_SRC_SEL, opp_id[0],\n\t\t\t\tOPTC_SEG1_SRC_SEL, opp_id[1]);\n\t} else if (opp_cnt == 4) {\n\t\tREG_SET_5(OPTC_DATA_SOURCE_SELECT, 0,\n\t\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, 3,\n\t\t\t\tOPTC_SEG0_SRC_SEL, opp_id[0],\n\t\t\t\tOPTC_SEG1_SRC_SEL, opp_id[1],\n\t\t\t\tOPTC_SEG2_SRC_SEL, opp_id[2],\n\t\t\t\tOPTC_SEG3_SRC_SEL, opp_id[3]);\n\t}\n\n\tREG_UPDATE(OPTC_WIDTH_CONTROL,\n\t\t\tOPTC_SEGMENT_WIDTH, mpcc_hactive);\n\n\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\t\tOTG_H_TIMING_DIV_MODE, opp_cnt - 1);\n\toptc1->opp_count = opp_cnt;\n}\n\nvoid optc32_set_h_timing_div_manual_mode(struct timing_generator *optc, bool manual_mode)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\t\tOTG_H_TIMING_DIV_MODE_MANUAL, manual_mode ? 1 : 0);\n}\n \nstatic bool optc32_enable_crtc(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE(OPTC_DATA_SOURCE_SELECT,\n\t\t\tOPTC_SEG0_SRC_SEL, optc->inst);\n\n\t \n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 1);\n\n\tREG_SEQ_START();\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL,\n\t\t\tOTG_DISABLE_POINT_CNTL, 2,\n\t\t\tOTG_MASTER_EN, 1);\n\n\tREG_SEQ_SUBMIT();\n\tREG_SEQ_WAIT_DONE();\n\n\treturn true;\n}\n\n \nstatic bool optc32_disable_crtc(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE(OTG_CONTROL,\n\t\t\tOTG_MASTER_EN, 0);\n\n\tREG_UPDATE(CONTROL,\n\t\t\tVTG0_ENABLE, 0);\n\n\t \n\tREG_WAIT(OTG_CLOCK_CONTROL,\n\t\t\tOTG_BUSY, 0,\n\t\t\t1, 150000);\n\n\treturn true;\n}\n\nstatic void optc32_phantom_crtc_post_enable(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\t \n\tREG_UPDATE_2(OTG_CONTROL, OTG_DISABLE_POINT_CNTL, 0, OTG_MASTER_EN, 0);\n\n\t \n\tREG_WAIT(OTG_CLOCK_CONTROL, OTG_BUSY, 0, 1, 100000);\n}\n\nstatic void optc32_disable_phantom_otg(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tREG_UPDATE(OTG_CONTROL, OTG_MASTER_EN, 0);\n}\n\nstatic void optc32_set_odm_bypass(struct timing_generator *optc,\n\t\tconst struct dc_crtc_timing *dc_crtc_timing)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tenum h_timing_div_mode h_div = H_TIMING_NO_DIV;\n\n\tREG_SET_5(OPTC_DATA_SOURCE_SELECT, 0,\n\t\t\tOPTC_NUM_OF_INPUT_SEGMENT, 0,\n\t\t\tOPTC_SEG0_SRC_SEL, optc->inst,\n\t\t\tOPTC_SEG1_SRC_SEL, 0xf,\n\t\t\tOPTC_SEG2_SRC_SEL, 0xf,\n\t\t\tOPTC_SEG3_SRC_SEL, 0xf\n\t\t\t);\n\n\th_div = optc1_is_two_pixels_per_containter(dc_crtc_timing);\n\tREG_UPDATE(OTG_H_TIMING_CNTL,\n\t\t\tOTG_H_TIMING_DIV_MODE, h_div);\n\n\tREG_SET(OPTC_MEMORY_CONFIG, 0,\n\t\t\tOPTC_MEM_SEL, 0);\n\toptc1->opp_count = 1;\n}\n\nstatic void optc32_setup_manual_trigger(struct timing_generator *optc)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tstruct dc *dc = optc->ctx->dc;\n\n\tif (dc->caps.dmub_caps.mclk_sw && !dc->debug.disable_fams)\n\t\tdc_dmub_srv_set_drr_manual_trigger_cmd(dc, optc->inst);\n\telse {\n\t\t \n\t\tREG_UPDATE_4(OTG_V_TOTAL_CONTROL,\n\t\t\t\tOTG_V_TOTAL_MIN_SEL, 1,\n\t\t\t\tOTG_V_TOTAL_MAX_SEL, 1,\n\t\t\t\tOTG_FORCE_LOCK_ON_EVENT, 0,\n\t\t\t\tOTG_SET_V_TOTAL_MIN_MASK, (1 << 1));  \n\n\t\t\n\t\toptc->funcs->setup_manual_trigger(optc);\n\t}\n}\n\nstatic void optc32_set_drr(\n\tstruct timing_generator *optc,\n\tconst struct drr_params *params)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\n\tif (params != NULL &&\n\t\tparams->vertical_total_max > 0 &&\n\t\tparams->vertical_total_min > 0) {\n\n\t\tif (params->vertical_total_mid != 0) {\n\n\t\t\tREG_SET(OTG_V_TOTAL_MID, 0,\n\t\t\t\tOTG_V_TOTAL_MID, params->vertical_total_mid - 1);\n\n\t\t\tREG_UPDATE_2(OTG_V_TOTAL_CONTROL,\n\t\t\t\t\tOTG_VTOTAL_MID_REPLACING_MAX_EN, 1,\n\t\t\t\t\tOTG_VTOTAL_MID_FRAME_NUM,\n\t\t\t\t\t(uint8_t)params->vertical_total_mid_frame_num);\n\n\t\t}\n\n\t\toptc->funcs->set_vtotal_min_max(optc, params->vertical_total_min - 1, params->vertical_total_max - 1);\n\t}\n\n\toptc32_setup_manual_trigger(optc);\n}\n\nstatic struct timing_generator_funcs dcn32_tg_funcs = {\n\t\t.validate_timing = optc1_validate_timing,\n\t\t.program_timing = optc1_program_timing,\n\t\t.setup_vertical_interrupt0 = optc1_setup_vertical_interrupt0,\n\t\t.setup_vertical_interrupt1 = optc1_setup_vertical_interrupt1,\n\t\t.setup_vertical_interrupt2 = optc1_setup_vertical_interrupt2,\n\t\t.program_global_sync = optc1_program_global_sync,\n\t\t.enable_crtc = optc32_enable_crtc,\n\t\t.disable_crtc = optc32_disable_crtc,\n\t\t.phantom_crtc_post_enable = optc32_phantom_crtc_post_enable,\n\t\t.disable_phantom_crtc = optc32_disable_phantom_otg,\n\t\t \n\t\t.is_counter_moving = optc1_is_counter_moving,\n\t\t.get_position = optc1_get_position,\n\t\t.get_frame_count = optc1_get_vblank_counter,\n\t\t.get_scanoutpos = optc1_get_crtc_scanoutpos,\n\t\t.get_otg_active_size = optc1_get_otg_active_size,\n\t\t.set_early_control = optc1_set_early_control,\n\t\t \n\t\t.wait_for_state = optc1_wait_for_state,\n\t\t.set_blank_color = optc3_program_blank_color,\n\t\t.did_triggered_reset_occur = optc1_did_triggered_reset_occur,\n\t\t.triplebuffer_lock = optc3_triplebuffer_lock,\n\t\t.triplebuffer_unlock = optc2_triplebuffer_unlock,\n\t\t.enable_reset_trigger = optc1_enable_reset_trigger,\n\t\t.enable_crtc_reset = optc1_enable_crtc_reset,\n\t\t.disable_reset_trigger = optc1_disable_reset_trigger,\n\t\t.lock = optc3_lock,\n\t\t.unlock = optc1_unlock,\n\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,\n\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,\n\t\t.enable_optc_clock = optc1_enable_optc_clock,\n\t\t.set_drr = optc32_set_drr,\n\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,\n\t\t.set_vtotal_min_max = optc3_set_vtotal_min_max,\n\t\t.set_static_screen_control = optc1_set_static_screen_control,\n\t\t.program_stereo = optc1_program_stereo,\n\t\t.is_stereo_left_eye = optc1_is_stereo_left_eye,\n\t\t.tg_init = optc3_tg_init,\n\t\t.is_tg_enabled = optc1_is_tg_enabled,\n\t\t.is_optc_underflow_occurred = optc1_is_optc_underflow_occurred,\n\t\t.clear_optc_underflow = optc1_clear_optc_underflow,\n\t\t.setup_global_swap_lock = NULL,\n\t\t.get_crc = optc1_get_crc,\n\t\t.configure_crc = optc1_configure_crc,\n\t\t.set_dsc_config = optc3_set_dsc_config,\n\t\t.get_dsc_status = optc2_get_dsc_status,\n\t\t.set_dwb_source = NULL,\n\t\t.set_odm_bypass = optc32_set_odm_bypass,\n\t\t.set_odm_combine = optc32_set_odm_combine,\n\t\t.set_h_timing_div_manual_mode = optc32_set_h_timing_div_manual_mode,\n\t\t.get_optc_source = optc2_get_optc_source,\n\t\t.set_out_mux = optc3_set_out_mux,\n\t\t.set_drr_trigger_window = optc3_set_drr_trigger_window,\n\t\t.set_vtotal_change_limit = optc3_set_vtotal_change_limit,\n\t\t.set_gsl = optc2_set_gsl,\n\t\t.set_gsl_source_select = optc2_set_gsl_source_select,\n\t\t.set_vtg_params = optc1_set_vtg_params,\n\t\t.program_manual_trigger = optc2_program_manual_trigger,\n\t\t.setup_manual_trigger = optc2_setup_manual_trigger,\n\t\t.get_hw_timing = optc1_get_hw_timing,\n};\n\nvoid dcn32_timing_generator_init(struct optc *optc1)\n{\n\toptc1->base.funcs = &dcn32_tg_funcs;\n\n\toptc1->max_h_total = optc1->tg_mask->OTG_H_TOTAL + 1;\n\toptc1->max_v_total = optc1->tg_mask->OTG_V_TOTAL + 1;\n\n\toptc1->min_h_blank = 32;\n\toptc1->min_v_blank = 3;\n\toptc1->min_v_blank_interlace = 5;\n\toptc1->min_h_sync_width = 4;\n\toptc1->min_v_sync_width = 1;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}