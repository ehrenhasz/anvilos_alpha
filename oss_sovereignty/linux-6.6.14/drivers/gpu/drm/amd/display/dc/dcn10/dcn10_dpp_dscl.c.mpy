{
  "module_name": "dcn10_dpp_dscl.c",
  "hash_id": "93a5d291feae6d314218d51b3990602cfca22c4a9a2394e423e6a6995b718c23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"core_types.h\"\n\n#include \"reg_helper.h\"\n#include \"dcn10_dpp.h\"\n#include \"basics/conversion.h\"\n\n\n#define NUM_PHASES    64\n#define HORZ_MAX_TAPS 8\n#define VERT_MAX_TAPS 8\n\n#define BLACK_OFFSET_RGB_Y 0x0\n#define BLACK_OFFSET_CBCR  0x8000\n\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\nenum dcn10_coef_filter_type_sel {\n\tSCL_COEF_LUMA_VERT_FILTER = 0,\n\tSCL_COEF_LUMA_HORZ_FILTER = 1,\n\tSCL_COEF_CHROMA_VERT_FILTER = 2,\n\tSCL_COEF_CHROMA_HORZ_FILTER = 3,\n\tSCL_COEF_ALPHA_VERT_FILTER = 4,\n\tSCL_COEF_ALPHA_HORZ_FILTER = 5\n};\n\nenum dscl_autocal_mode {\n\tAUTOCAL_MODE_OFF = 0,\n\n\t \n\tAUTOCAL_MODE_AUTOSCALE = 1,\n\t \n\tAUTOCAL_MODE_AUTOCENTER = 2,\n\t \n\tAUTOCAL_MODE_AUTOREPLICATE = 3\n};\n\nenum dscl_mode_sel {\n\tDSCL_MODE_SCALING_444_BYPASS = 0,\n\tDSCL_MODE_SCALING_444_RGB_ENABLE = 1,\n\tDSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,\n\tDSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,\n\tDSCL_MODE_SCALING_420_LUMA_BYPASS = 4,\n\tDSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,\n\tDSCL_MODE_DSCL_BYPASS = 6\n};\n\nstatic int dpp1_dscl_get_pixel_depth_val(enum lb_pixel_depth depth)\n{\n\tif (depth == LB_PIXEL_DEPTH_30BPP)\n\t\treturn 0;  \n\telse if (depth == LB_PIXEL_DEPTH_24BPP)\n\t\treturn 1;  \n\telse if (depth == LB_PIXEL_DEPTH_18BPP)\n\t\treturn 2;  \n\telse if (depth == LB_PIXEL_DEPTH_36BPP)\n\t\treturn 3;  \n\telse {\n\t\tASSERT(0);\n\t\treturn -1;  \n\t}\n}\n\nstatic bool dpp1_dscl_is_video_format(enum pixel_format format)\n{\n\tif (format >= PIXEL_FORMAT_VIDEO_BEGIN\n\t\t\t&& format <= PIXEL_FORMAT_VIDEO_END)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool dpp1_dscl_is_420_format(enum pixel_format format)\n{\n\tif (format == PIXEL_FORMAT_420BPP8 ||\n\t\t\tformat == PIXEL_FORMAT_420BPP10)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic enum dscl_mode_sel dpp1_dscl_get_dscl_mode(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct scaler_data *data,\n\t\tbool dbg_always_scale)\n{\n\tconst long long one = dc_fixpt_one.value;\n\n\tif (dpp_base->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {\n\t\t \n\t\tif (data->format == PIXEL_FORMAT_FP16)\n\t\t\treturn DSCL_MODE_DSCL_BYPASS;\n\t}\n\n\tif (data->ratios.horz.value == one\n\t\t\t&& data->ratios.vert.value == one\n\t\t\t&& data->ratios.horz_c.value == one\n\t\t\t&& data->ratios.vert_c.value == one\n\t\t\t&& !dbg_always_scale)\n\t\treturn DSCL_MODE_SCALING_444_BYPASS;\n\n\tif (!dpp1_dscl_is_420_format(data->format)) {\n\t\tif (dpp1_dscl_is_video_format(data->format))\n\t\t\treturn DSCL_MODE_SCALING_444_YCBCR_ENABLE;\n\t\telse\n\t\t\treturn DSCL_MODE_SCALING_444_RGB_ENABLE;\n\t}\n\tif (data->ratios.horz.value == one && data->ratios.vert.value == one)\n\t\treturn DSCL_MODE_SCALING_420_LUMA_BYPASS;\n\tif (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)\n\t\treturn DSCL_MODE_SCALING_420_CHROMA_BYPASS;\n\n\treturn DSCL_MODE_SCALING_420_YCBCR_ENABLE;\n}\n\nstatic void dpp1_power_on_dscl(\n\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tif (dpp->tf_regs->DSCL_MEM_PWR_CTRL) {\n\t\tif (power_on) {\n\t\t\tREG_UPDATE(DSCL_MEM_PWR_CTRL, LUT_MEM_PWR_FORCE, 0);\n\t\t\tREG_WAIT(DSCL_MEM_PWR_STATUS, LUT_MEM_PWR_STATE, 0, 1, 5);\n\t\t} else {\n\t\t\tif (dpp->base.ctx->dc->debug.enable_mem_low_power.bits.dscl) {\n\t\t\t\tdpp->base.ctx->dc->optimized_required = true;\n\t\t\t\tdpp->base.deferred_reg_writes.bits.disable_dscl = true;\n\t\t\t} else {\n\t\t\t\tREG_UPDATE(DSCL_MEM_PWR_CTRL, LUT_MEM_PWR_FORCE, 3);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic void dpp1_dscl_set_lb(\n\tstruct dcn10_dpp *dpp,\n\tconst struct line_buffer_params *lb_params,\n\tenum lb_memory_config mem_size_config)\n{\n\tuint32_t max_partitions = 63;  \n\n\t \n\tif (dpp->base.caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {\n\t\t \n\t\tuint32_t pixel_depth = dpp1_dscl_get_pixel_depth_val(lb_params->depth);\n\t\tuint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;\n\n\t\tREG_SET_7(LB_DATA_FORMAT, 0,\n\t\t\tPIXEL_DEPTH, pixel_depth,  \n\t\t\tPIXEL_EXPAN_MODE, lb_params->pixel_expan_mode,  \n\t\t\tPIXEL_REDUCE_MODE, 1,  \n\t\t\tDYNAMIC_PIXEL_DEPTH, dyn_pix_depth,  \n\t\t\tDITHER_EN, 0,  \n\t\t\tINTERLEAVE_EN, lb_params->interleave_en,  \n\t\t\tLB_DATA_FORMAT__ALPHA_EN, lb_params->alpha_en);  \n\t} else {\n\t\t \n\t\tREG_SET_2(LB_DATA_FORMAT, 0,\n\t\t\tINTERLEAVE_EN, lb_params->interleave_en,  \n\t\t\tLB_DATA_FORMAT__ALPHA_EN, lb_params->alpha_en);  \n\t}\n\n\tif (dpp->base.caps->max_lb_partitions == 31)\n\t\tmax_partitions = 31;\n\n\tREG_SET_2(LB_MEMORY_CTRL, 0,\n\t\tMEMORY_CONFIG, mem_size_config,\n\t\tLB_MAX_PARTITIONS, max_partitions);\n}\n\nstatic const uint16_t *dpp1_dscl_get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)\n{\n\tif (taps == 8)\n\t\treturn get_filter_8tap_64p(ratio);\n\telse if (taps == 7)\n\t\treturn get_filter_7tap_64p(ratio);\n\telse if (taps == 6)\n\t\treturn get_filter_6tap_64p(ratio);\n\telse if (taps == 5)\n\t\treturn get_filter_5tap_64p(ratio);\n\telse if (taps == 4)\n\t\treturn get_filter_4tap_64p(ratio);\n\telse if (taps == 3)\n\t\treturn get_filter_3tap_64p(ratio);\n\telse if (taps == 2)\n\t\treturn get_filter_2tap_64p();\n\telse if (taps == 1)\n\t\treturn NULL;\n\telse {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n}\n\nstatic void dpp1_dscl_set_scaler_filter(\n\t\tstruct dcn10_dpp *dpp,\n\t\tuint32_t taps,\n\t\tenum dcn10_coef_filter_type_sel filter_type,\n\t\tconst uint16_t *filter)\n{\n\tconst int tap_pairs = (taps + 1) / 2;\n\tint phase;\n\tint pair;\n\tuint16_t odd_coef, even_coef;\n\n\tREG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,\n\t\tSCL_COEF_RAM_TAP_PAIR_IDX, 0,\n\t\tSCL_COEF_RAM_PHASE, 0,\n\t\tSCL_COEF_RAM_FILTER_TYPE, filter_type);\n\n\tfor (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {\n\t\tfor (pair = 0; pair < tap_pairs; pair++) {\n\t\t\teven_coef = filter[phase * taps + 2 * pair];\n\t\t\tif ((pair * 2 + 1) < taps)\n\t\t\t\todd_coef = filter[phase * taps + 2 * pair + 1];\n\t\t\telse\n\t\t\t\todd_coef = 0;\n\n\t\t\tREG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,\n\t\t\t\t \n\t\t\t\tSCL_COEF_RAM_EVEN_TAP_COEF, even_coef,\n\t\t\t\t \n\t\t\t\tSCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,\n\t\t\t\t \n\t\t\t\tSCL_COEF_RAM_ODD_TAP_COEF, odd_coef,\n\t\t\t\t \n\t\t\t\tSCL_COEF_RAM_ODD_TAP_COEF_EN, 1);\n\t\t}\n\t}\n\n}\n\nstatic void dpp1_dscl_set_scl_filter(\n\t\tstruct dcn10_dpp *dpp,\n\t\tconst struct scaler_data *scl_data,\n\t\tbool chroma_coef_mode)\n{\n\tbool h_2tap_hardcode_coef_en = false;\n\tbool v_2tap_hardcode_coef_en = false;\n\tbool h_2tap_sharp_en = false;\n\tbool v_2tap_sharp_en = false;\n\tuint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;\n\tuint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;\n\tbool coef_ram_current;\n\tconst uint16_t *filter_h = NULL;\n\tconst uint16_t *filter_v = NULL;\n\tconst uint16_t *filter_h_c = NULL;\n\tconst uint16_t *filter_v_c = NULL;\n\n\th_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3\n\t\t\t\t\t&& scl_data->taps.h_taps_c < 3\n\t\t&& (scl_data->taps.h_taps > 1 && scl_data->taps.h_taps_c > 1);\n\tv_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3\n\t\t\t\t\t&& scl_data->taps.v_taps_c < 3\n\t\t&& (scl_data->taps.v_taps > 1 && scl_data->taps.v_taps_c > 1);\n\n\th_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;\n\tv_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;\n\n\tREG_UPDATE_6(DSCL_2TAP_CONTROL,\n\t\tSCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,\n\t\tSCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,\n\t\tSCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,\n\t\tSCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,\n\t\tSCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,\n\t\tSCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);\n\n\tif (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {\n\t\tbool filter_updated = false;\n\n\t\tfilter_h = dpp1_dscl_get_filter_coeffs_64p(\n\t\t\t\tscl_data->taps.h_taps, scl_data->ratios.horz);\n\t\tfilter_v = dpp1_dscl_get_filter_coeffs_64p(\n\t\t\t\tscl_data->taps.v_taps, scl_data->ratios.vert);\n\n\t\tfilter_updated = (filter_h && (filter_h != dpp->filter_h))\n\t\t\t\t|| (filter_v && (filter_v != dpp->filter_v));\n\n\t\tif (chroma_coef_mode) {\n\t\t\tfilter_h_c = dpp1_dscl_get_filter_coeffs_64p(\n\t\t\t\t\tscl_data->taps.h_taps_c, scl_data->ratios.horz_c);\n\t\t\tfilter_v_c = dpp1_dscl_get_filter_coeffs_64p(\n\t\t\t\t\tscl_data->taps.v_taps_c, scl_data->ratios.vert_c);\n\t\t\tfilter_updated = filter_updated || (filter_h_c && (filter_h_c != dpp->filter_h_c))\n\t\t\t\t\t\t\t|| (filter_v_c && (filter_v_c != dpp->filter_v_c));\n\t\t}\n\n\t\tif (filter_updated) {\n\t\t\tuint32_t scl_mode = REG_READ(SCL_MODE);\n\n\t\t\tif (!h_2tap_hardcode_coef_en && filter_h) {\n\t\t\t\tdpp1_dscl_set_scaler_filter(\n\t\t\t\t\tdpp, scl_data->taps.h_taps,\n\t\t\t\t\tSCL_COEF_LUMA_HORZ_FILTER, filter_h);\n\t\t\t}\n\t\t\tdpp->filter_h = filter_h;\n\t\t\tif (!v_2tap_hardcode_coef_en && filter_v) {\n\t\t\t\tdpp1_dscl_set_scaler_filter(\n\t\t\t\t\tdpp, scl_data->taps.v_taps,\n\t\t\t\t\tSCL_COEF_LUMA_VERT_FILTER, filter_v);\n\t\t\t}\n\t\t\tdpp->filter_v = filter_v;\n\t\t\tif (chroma_coef_mode) {\n\t\t\t\tif (!h_2tap_hardcode_coef_en && filter_h_c) {\n\t\t\t\t\tdpp1_dscl_set_scaler_filter(\n\t\t\t\t\t\tdpp, scl_data->taps.h_taps_c,\n\t\t\t\t\t\tSCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);\n\t\t\t\t}\n\t\t\t\tif (!v_2tap_hardcode_coef_en && filter_v_c) {\n\t\t\t\t\tdpp1_dscl_set_scaler_filter(\n\t\t\t\t\t\tdpp, scl_data->taps.v_taps_c,\n\t\t\t\t\t\tSCL_COEF_CHROMA_VERT_FILTER, filter_v_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpp->filter_h_c = filter_h_c;\n\t\t\tdpp->filter_v_c = filter_v_c;\n\n\t\t\tcoef_ram_current = get_reg_field_value_ex(\n\t\t\t\tscl_mode, dpp->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,\n\t\t\t\tdpp->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);\n\n\t\t\t \n\t\t\tREG_SET_2(SCL_MODE, scl_mode,\n\t\t\t\t\tSCL_COEF_RAM_SELECT, !coef_ram_current,\n\t\t\t\t\tSCL_CHROMA_COEF_MODE, chroma_coef_mode);\n\t\t}\n\t}\n}\n\nstatic int dpp1_dscl_get_lb_depth_bpc(enum lb_pixel_depth depth)\n{\n\tif (depth == LB_PIXEL_DEPTH_30BPP)\n\t\treturn 10;\n\telse if (depth == LB_PIXEL_DEPTH_24BPP)\n\t\treturn 8;\n\telse if (depth == LB_PIXEL_DEPTH_18BPP)\n\t\treturn 6;\n\telse if (depth == LB_PIXEL_DEPTH_36BPP)\n\t\treturn 12;\n\telse {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn -1;  \n\t}\n}\n\nvoid dpp1_dscl_calc_lb_num_partitions(\n\t\tconst struct scaler_data *scl_data,\n\t\tenum lb_memory_config lb_config,\n\t\tint *num_part_y,\n\t\tint *num_part_c)\n{\n\tint lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a,\n\tlb_bpc, memory_line_size_y, memory_line_size_c, memory_line_size_a;\n\n\tint line_size = scl_data->viewport.width < scl_data->recout.width ?\n\t\t\tscl_data->viewport.width : scl_data->recout.width;\n\tint line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?\n\t\t\tscl_data->viewport_c.width : scl_data->recout.width;\n\n\tif (line_size == 0)\n\t\tline_size = 1;\n\n\tif (line_size_c == 0)\n\t\tline_size_c = 1;\n\n\n\tlb_bpc = dpp1_dscl_get_lb_depth_bpc(scl_data->lb_params.depth);\n\tmemory_line_size_y = (line_size * lb_bpc + 71) / 72;  \n\tmemory_line_size_c = (line_size_c * lb_bpc + 71) / 72;  \n\tmemory_line_size_a = (line_size + 5) / 6;  \n\n\tif (lb_config == LB_MEMORY_CONFIG_1) {\n\t\tlb_memory_size = 816;\n\t\tlb_memory_size_c = 816;\n\t\tlb_memory_size_a = 984;\n\t} else if (lb_config == LB_MEMORY_CONFIG_2) {\n\t\tlb_memory_size = 1088;\n\t\tlb_memory_size_c = 1088;\n\t\tlb_memory_size_a = 1312;\n\t} else if (lb_config == LB_MEMORY_CONFIG_3) {\n\t\t \n\t\tlb_memory_size = 816 + 1088 + 848 + 848 + 848;\n\t\tlb_memory_size_c = 816 + 1088;\n\t\tlb_memory_size_a = 984 + 1312 + 456;\n\t} else {\n\t\tlb_memory_size = 816 + 1088 + 848;\n\t\tlb_memory_size_c = 816 + 1088 + 848;\n\t\tlb_memory_size_a = 984 + 1312 + 456;\n\t}\n\t*num_part_y = lb_memory_size / memory_line_size_y;\n\t*num_part_c = lb_memory_size_c / memory_line_size_c;\n\tnum_partitions_a = lb_memory_size_a / memory_line_size_a;\n\n\tif (scl_data->lb_params.alpha_en\n\t\t\t&& (num_partitions_a < *num_part_y))\n\t\t*num_part_y = num_partitions_a;\n\n\tif (*num_part_y > 64)\n\t\t*num_part_y = 64;\n\tif (*num_part_c > 64)\n\t\t*num_part_c = 64;\n\n}\n\nbool dpp1_dscl_is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)\n{\n\tif (ceil_vratio > 2)\n\t\treturn vtaps <= (num_partitions - ceil_vratio + 2);\n\telse\n\t\treturn vtaps <= num_partitions;\n}\n\n \nstatic enum lb_memory_config dpp1_dscl_find_lb_memory_config(struct dcn10_dpp *dpp,\n\t\tconst struct scaler_data *scl_data)\n{\n\tint num_part_y, num_part_c;\n\tint vtaps = scl_data->taps.v_taps;\n\tint vtaps_c = scl_data->taps.v_taps_c;\n\tint ceil_vratio = dc_fixpt_ceil(scl_data->ratios.vert);\n\tint ceil_vratio_c = dc_fixpt_ceil(scl_data->ratios.vert_c);\n\n\tif (dpp->base.ctx->dc->debug.use_max_lb) {\n\t\tif (scl_data->format == PIXEL_FORMAT_420BPP8\n\t\t\t\t|| scl_data->format == PIXEL_FORMAT_420BPP10)\n\t\t\treturn LB_MEMORY_CONFIG_3;\n\t\treturn LB_MEMORY_CONFIG_0;\n\t}\n\n\tdpp->base.caps->dscl_calc_lb_num_partitions(\n\t\t\tscl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);\n\n\tif (dpp1_dscl_is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)\n\t\t\t&& dpp1_dscl_is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))\n\t\treturn LB_MEMORY_CONFIG_1;\n\n\tdpp->base.caps->dscl_calc_lb_num_partitions(\n\t\t\tscl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);\n\n\tif (dpp1_dscl_is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)\n\t\t\t&& dpp1_dscl_is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))\n\t\treturn LB_MEMORY_CONFIG_2;\n\n\tif (scl_data->format == PIXEL_FORMAT_420BPP8\n\t\t\t|| scl_data->format == PIXEL_FORMAT_420BPP10) {\n\t\tdpp->base.caps->dscl_calc_lb_num_partitions(\n\t\t\t\tscl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);\n\n\t\tif (dpp1_dscl_is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)\n\t\t\t\t&& dpp1_dscl_is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))\n\t\t\treturn LB_MEMORY_CONFIG_3;\n\t}\n\n\tdpp->base.caps->dscl_calc_lb_num_partitions(\n\t\t\tscl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);\n\n\t \n\tASSERT(dpp1_dscl_is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)\n\t\t\t&& dpp1_dscl_is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));\n\n\treturn LB_MEMORY_CONFIG_0;\n}\n\n\nstatic void dpp1_dscl_set_manual_ratio_init(\n\t\tstruct dcn10_dpp *dpp, const struct scaler_data *data)\n{\n\tuint32_t init_frac = 0;\n\tuint32_t init_int = 0;\n\n\tREG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_H_SCALE_RATIO, dc_fixpt_u3d19(data->ratios.horz) << 5);\n\n\tREG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_V_SCALE_RATIO, dc_fixpt_u3d19(data->ratios.vert) << 5);\n\n\tREG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,\n\t\t\tSCL_H_SCALE_RATIO_C, dc_fixpt_u3d19(data->ratios.horz_c) << 5);\n\n\tREG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,\n\t\t\tSCL_V_SCALE_RATIO_C, dc_fixpt_u3d19(data->ratios.vert_c) << 5);\n\n\t \n\tinit_frac = dc_fixpt_u0d19(data->inits.h) << 5;\n\tinit_int = dc_fixpt_floor(data->inits.h);\n\tREG_SET_2(SCL_HORZ_FILTER_INIT, 0,\n\t\tSCL_H_INIT_FRAC, init_frac,\n\t\tSCL_H_INIT_INT, init_int);\n\n\tinit_frac = dc_fixpt_u0d19(data->inits.h_c) << 5;\n\tinit_int = dc_fixpt_floor(data->inits.h_c);\n\tREG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,\n\t\tSCL_H_INIT_FRAC_C, init_frac,\n\t\tSCL_H_INIT_INT_C, init_int);\n\n\tinit_frac = dc_fixpt_u0d19(data->inits.v) << 5;\n\tinit_int = dc_fixpt_floor(data->inits.v);\n\tREG_SET_2(SCL_VERT_FILTER_INIT, 0,\n\t\tSCL_V_INIT_FRAC, init_frac,\n\t\tSCL_V_INIT_INT, init_int);\n\n\tif (REG(SCL_VERT_FILTER_INIT_BOT)) {\n\t\tstruct fixed31_32 bot = dc_fixpt_add(data->inits.v, data->ratios.vert);\n\n\t\tinit_frac = dc_fixpt_u0d19(bot) << 5;\n\t\tinit_int = dc_fixpt_floor(bot);\n\t\tREG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,\n\t\t\tSCL_V_INIT_FRAC_BOT, init_frac,\n\t\t\tSCL_V_INIT_INT_BOT, init_int);\n\t}\n\n\tinit_frac = dc_fixpt_u0d19(data->inits.v_c) << 5;\n\tinit_int = dc_fixpt_floor(data->inits.v_c);\n\tREG_SET_2(SCL_VERT_FILTER_INIT_C, 0,\n\t\tSCL_V_INIT_FRAC_C, init_frac,\n\t\tSCL_V_INIT_INT_C, init_int);\n\n\tif (REG(SCL_VERT_FILTER_INIT_BOT_C)) {\n\t\tstruct fixed31_32 bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);\n\n\t\tinit_frac = dc_fixpt_u0d19(bot) << 5;\n\t\tinit_int = dc_fixpt_floor(bot);\n\t\tREG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,\n\t\t\tSCL_V_INIT_FRAC_BOT_C, init_frac,\n\t\t\tSCL_V_INIT_INT_BOT_C, init_int);\n\t}\n}\n\n \nstatic void dpp1_dscl_set_recout(struct dcn10_dpp *dpp,\n\t\t\t\t const struct rect *recout)\n{\n\tREG_SET_2(RECOUT_START, 0,\n\t\t   \n\t\t  RECOUT_START_X, recout->x,\n\t\t   \n\t\t  RECOUT_START_Y, recout->y);\n\n\tREG_SET_2(RECOUT_SIZE, 0,\n\t\t   \n\t\t  RECOUT_WIDTH, recout->width,\n\t\t   \n\t\t  RECOUT_HEIGHT, recout->height);\n}\n\n \nvoid dpp1_dscl_set_scaler_manual_scale(struct dpp *dpp_base,\n\t\t\t\t       const struct scaler_data *scl_data)\n{\n\tenum lb_memory_config lb_config;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tenum dscl_mode_sel dscl_mode = dpp1_dscl_get_dscl_mode(\n\t\t\tdpp_base, scl_data, dpp_base->ctx->dc->debug.always_scale);\n\tbool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN\n\t\t\t\t&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;\n\n\tif (memcmp(&dpp->scl_data, scl_data, sizeof(*scl_data)) == 0)\n\t\treturn;\n\n\tPERF_TRACE();\n\n\tdpp->scl_data = *scl_data;\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.dscl) {\n\t\tif (dscl_mode != DSCL_MODE_DSCL_BYPASS)\n\t\t\tdpp1_power_on_dscl(dpp_base, true);\n\t}\n\n\t \n\tREG_SET_3(DSCL_AUTOCAL, 0,\n\t\tAUTOCAL_MODE, AUTOCAL_MODE_OFF,\n\t\tAUTOCAL_NUM_PIPE, 0,\n\t\tAUTOCAL_PIPE_ID, 0);\n\n\t \n\tREG_SET(DSCL_CONTROL, 0,\n\t\tSCL_BOUNDARY_MODE, 0);\n\n\t \n\tdpp1_dscl_set_recout(dpp, &scl_data->recout);\n\n\t \n\tREG_SET_2(MPC_SIZE, 0,\n\t\t \n\t\t\t MPC_WIDTH, scl_data->h_active,\n\t\t \n\t\t\t MPC_HEIGHT, scl_data->v_active);\n\n\t \n\tREG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);\n\n\tif (dscl_mode == DSCL_MODE_DSCL_BYPASS) {\n\t\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.dscl)\n\t\t\tdpp1_power_on_dscl(dpp_base, false);\n\t\treturn;\n\t}\n\n\t \n\tlb_config =  dpp1_dscl_find_lb_memory_config(dpp, scl_data);\n\tdpp1_dscl_set_lb(dpp, &scl_data->lb_params, lb_config);\n\n\tif (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)\n\t\treturn;\n\n\t \n\tif (REG(SCL_BLACK_OFFSET)) {\n\t\tif (ycbcr)\n\t\t\tREG_SET_2(SCL_BLACK_OFFSET, 0,\n\t\t\t\t\tSCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,\n\t\t\t\t\tSCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);\n\t\telse\n\n\t\t\tREG_SET_2(SCL_BLACK_OFFSET, 0,\n\t\t\t\t\tSCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,\n\t\t\t\t\tSCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);\n\t}\n\n\t \n\tdpp1_dscl_set_manual_ratio_init(dpp, scl_data);\n\n\t \n\tREG_SET_4(SCL_TAP_CONTROL, 0,\n\t\tSCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,\n\t\tSCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,\n\t\tSCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,\n\t\tSCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);\n\n\tdpp1_dscl_set_scl_filter(dpp, scl_data, ycbcr);\n\tPERF_TRACE();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}