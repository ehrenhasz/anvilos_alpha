{
  "module_name": "dce_i2c_sw.c",
  "hash_id": "dfd1855cc4e748af6c5a3c972adc4149d872c03f5b0a9809121c116f9ed549d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_sw.c",
  "human_readable_source": " \n\n#include \"dce_i2c.h\"\n#include \"dce_i2c_sw.h\"\n#include \"include/gpio_service_interface.h\"\n#define SCL false\n#define SDA true\n\nvoid dce_i2c_sw_construct(\n\tstruct dce_i2c_sw *dce_i2c_sw,\n\tstruct dc_context *ctx)\n{\n\tdce_i2c_sw->ctx = ctx;\n}\n\nstatic inline bool read_bit_from_ddc(\n\tstruct ddc *ddc,\n\tbool data_nor_clock)\n{\n\tuint32_t value = 0;\n\n\tif (data_nor_clock)\n\t\tdal_gpio_get_value(ddc->pin_data, &value);\n\telse\n\t\tdal_gpio_get_value(ddc->pin_clock, &value);\n\n\treturn (value != 0);\n}\n\nstatic inline void write_bit_to_ddc(\n\tstruct ddc *ddc,\n\tbool data_nor_clock,\n\tbool bit)\n{\n\tuint32_t value = bit ? 1 : 0;\n\n\tif (data_nor_clock)\n\t\tdal_gpio_set_value(ddc->pin_data, value);\n\telse\n\t\tdal_gpio_set_value(ddc->pin_clock, value);\n}\n\nstatic void release_engine_dce_sw(\n\tstruct resource_pool *pool,\n\tstruct dce_i2c_sw *dce_i2c_sw)\n{\n\tdal_ddc_close(dce_i2c_sw->ddc);\n\tdce_i2c_sw->ddc = NULL;\n}\n\nstatic bool wait_for_scl_high_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc,\n\tuint16_t clock_delay_div_4)\n{\n\tuint32_t scl_retry = 0;\n\tuint32_t scl_retry_max = I2C_SW_TIMEOUT_DELAY / clock_delay_div_4;\n\n\tudelay(clock_delay_div_4);\n\n\tdo {\n\t\tif (read_bit_from_ddc(ddc, SCL))\n\t\t\treturn true;\n\n\t\tudelay(clock_delay_div_4);\n\n\t\t++scl_retry;\n\t} while (scl_retry <= scl_retry_max);\n\n\treturn false;\n}\nstatic bool write_byte_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4,\n\tuint8_t byte)\n{\n\tint32_t shift = 7;\n\tbool ack;\n\n\t \n\n\tdo {\n\t\tudelay(clock_delay_div_4);\n\n\t\twrite_bit_to_ddc(ddc_handle, SDA, (byte >> shift) & 1);\n\n\t\tudelay(clock_delay_div_4);\n\n\t\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\t\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\t\treturn false;\n\n\t\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\t\t--shift;\n\t} while (shift >= 0);\n\n\t \n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SDA, true);\n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\treturn false;\n\n\t \n\n\tack = !read_bit_from_ddc(ddc_handle, SDA);\n\n\tudelay(clock_delay_div_4 << 1);\n\n\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\tudelay(clock_delay_div_4 << 1);\n\n\treturn ack;\n}\n\nstatic bool read_byte_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4,\n\tuint8_t *byte,\n\tbool more)\n{\n\tint32_t shift = 7;\n\n\tuint8_t data = 0;\n\n\t \n\n\tdo {\n\t\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\t\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\t\treturn false;\n\n\t\tif (read_bit_from_ddc(ddc_handle, SDA))\n\t\t\tdata |= (1 << shift);\n\n\t\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\t\tudelay(clock_delay_div_4 << 1);\n\n\t\t--shift;\n\t} while (shift >= 0);\n\n\t \n\n\t*byte = data;\n\n\tudelay(clock_delay_div_4);\n\n\t \n\n\twrite_bit_to_ddc(ddc_handle, SDA, !more);\n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\treturn false;\n\n\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SDA, true);\n\n\tudelay(clock_delay_div_4);\n\n\treturn true;\n}\nstatic bool stop_sync_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4)\n{\n\tuint32_t retry = 0;\n\n\t \n\n\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SDA, false);\n\n\tudelay(clock_delay_div_4);\n\n\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\treturn false;\n\n\twrite_bit_to_ddc(ddc_handle, SDA, true);\n\n\tdo {\n\t\tudelay(clock_delay_div_4);\n\n\t\tif (read_bit_from_ddc(ddc_handle, SDA))\n\t\t\treturn true;\n\n\t\t++retry;\n\t} while (retry <= 2);\n\n\treturn false;\n}\nstatic bool i2c_write_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4,\n\tuint8_t address,\n\tuint32_t length,\n\tconst uint8_t *data)\n{\n\tuint32_t i = 0;\n\n\tif (!write_byte_sw(ctx, ddc_handle, clock_delay_div_4, address))\n\t\treturn false;\n\n\twhile (i < length) {\n\t\tif (!write_byte_sw(ctx, ddc_handle, clock_delay_div_4, data[i]))\n\t\t\treturn false;\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\nstatic bool i2c_read_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4,\n\tuint8_t address,\n\tuint32_t length,\n\tuint8_t *data)\n{\n\tuint32_t i = 0;\n\n\tif (!write_byte_sw(ctx, ddc_handle, clock_delay_div_4, address))\n\t\treturn false;\n\n\twhile (i < length) {\n\t\tif (!read_byte_sw(ctx, ddc_handle, clock_delay_div_4, data + i,\n\t\t\ti < length - 1))\n\t\t\treturn false;\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\n\n\nstatic bool start_sync_sw(\n\tstruct dc_context *ctx,\n\tstruct ddc *ddc_handle,\n\tuint16_t clock_delay_div_4)\n{\n\tuint32_t retry = 0;\n\n\t \n\n\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\tudelay(clock_delay_div_4);\n\n\tdo {\n\t\twrite_bit_to_ddc(ddc_handle, SDA, true);\n\n\t\tif (!read_bit_from_ddc(ddc_handle, SDA)) {\n\t\t\t++retry;\n\t\t\tcontinue;\n\t\t}\n\n\t\tudelay(clock_delay_div_4);\n\n\t\twrite_bit_to_ddc(ddc_handle, SCL, true);\n\n\t\tif (!wait_for_scl_high_sw(ctx, ddc_handle, clock_delay_div_4))\n\t\t\tbreak;\n\n\t\twrite_bit_to_ddc(ddc_handle, SDA, false);\n\n\t\tudelay(clock_delay_div_4);\n\n\t\twrite_bit_to_ddc(ddc_handle, SCL, false);\n\n\t\tudelay(clock_delay_div_4);\n\n\t\treturn true;\n\t} while (retry <= I2C_SW_RETRIES);\n\n\treturn false;\n}\n\nstatic void dce_i2c_sw_engine_set_speed(\n\tstruct dce_i2c_sw *engine,\n\tuint32_t speed)\n{\n\tASSERT(speed);\n\n\tengine->speed = speed ? speed : DCE_I2C_DEFAULT_I2C_SW_SPEED;\n\n\tengine->clock_delay = 1000 / engine->speed;\n\n\tif (engine->clock_delay < 12)\n\t\tengine->clock_delay = 12;\n}\n\nstatic bool dce_i2c_sw_engine_acquire_engine(\n\tstruct dce_i2c_sw *engine,\n\tstruct ddc *ddc)\n{\n\tenum gpio_result result;\n\n\tresult = dal_ddc_open(ddc, GPIO_MODE_FAST_OUTPUT,\n\t\tGPIO_DDC_CONFIG_TYPE_MODE_I2C);\n\n\tif (result != GPIO_RESULT_OK)\n\t\treturn false;\n\n\tengine->ddc = ddc;\n\n\treturn true;\n}\n\nbool dce_i2c_engine_acquire_sw(\n\tstruct dce_i2c_sw *dce_i2c_sw,\n\tstruct ddc *ddc_handle)\n{\n\tuint32_t counter = 0;\n\tbool result;\n\n\tdo {\n\n\t\tresult = dce_i2c_sw_engine_acquire_engine(\n\t\t\t\tdce_i2c_sw, ddc_handle);\n\n\t\tif (result)\n\t\t\tbreak;\n\n\t\t \n\n\t\tudelay(10);\n\n\t\t++counter;\n\t} while (counter < 2);\n\n\treturn result;\n}\n\nstatic void dce_i2c_sw_engine_submit_channel_request(struct dce_i2c_sw *engine,\n\t\t\t\t\t\t     struct i2c_request_transaction_data *req)\n{\n\tstruct ddc *ddc = engine->ddc;\n\tuint16_t clock_delay_div_4 = engine->clock_delay >> 2;\n\n\t \n\n\tbool result = start_sync_sw(engine->ctx, ddc, clock_delay_div_4);\n\n\t \n\n\tif (result) {\n\t\tswitch (req->action) {\n\t\tcase DCE_I2C_TRANSACTION_ACTION_I2C_WRITE:\n\t\tcase DCE_I2C_TRANSACTION_ACTION_I2C_WRITE_MOT:\n\t\t\tresult = i2c_write_sw(engine->ctx, ddc, clock_delay_div_4,\n\t\t\t\treq->address, req->length, req->data);\n\t\tbreak;\n\t\tcase DCE_I2C_TRANSACTION_ACTION_I2C_READ:\n\t\tcase DCE_I2C_TRANSACTION_ACTION_I2C_READ_MOT:\n\t\t\tresult = i2c_read_sw(engine->ctx, ddc, clock_delay_div_4,\n\t\t\t\treq->address, req->length, req->data);\n\t\tbreak;\n\t\tdefault:\n\t\t\tresult = false;\n\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif (!result ||\n\t\t(req->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||\n\t\t(req->action == DCE_I2C_TRANSACTION_ACTION_I2C_READ))\n\t\tif (!stop_sync_sw(engine->ctx, ddc, clock_delay_div_4))\n\t\t\tresult = false;\n\n\treq->status = result ?\n\t\tI2C_CHANNEL_OPERATION_SUCCEEDED :\n\t\tI2C_CHANNEL_OPERATION_FAILED;\n}\n\nstatic bool dce_i2c_sw_engine_submit_payload(struct dce_i2c_sw *engine,\n\t\t\t\t\t     struct i2c_payload *payload,\n\t\t\t\t\t     bool middle_of_transaction)\n{\n\tstruct i2c_request_transaction_data request;\n\n\tif (!payload->write)\n\t\trequest.action = middle_of_transaction ?\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_READ_MOT :\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_READ;\n\telse\n\t\trequest.action = middle_of_transaction ?\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_WRITE_MOT :\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_WRITE;\n\n\trequest.address = (uint8_t) ((payload->address << 1) | !payload->write);\n\trequest.length = payload->length;\n\trequest.data = payload->data;\n\n\tdce_i2c_sw_engine_submit_channel_request(engine, &request);\n\n\tif ((request.status == I2C_CHANNEL_OPERATION_ENGINE_BUSY) ||\n\t\t(request.status == I2C_CHANNEL_OPERATION_FAILED))\n\t\treturn false;\n\n\treturn true;\n}\nbool dce_i2c_submit_command_sw(\n\tstruct resource_pool *pool,\n\tstruct ddc *ddc,\n\tstruct i2c_command *cmd,\n\tstruct dce_i2c_sw *dce_i2c_sw)\n{\n\tuint8_t index_of_payload = 0;\n\tbool result;\n\n\tdce_i2c_sw_engine_set_speed(dce_i2c_sw, cmd->speed);\n\n\tresult = true;\n\n\twhile (index_of_payload < cmd->number_of_payloads) {\n\t\tbool mot = (index_of_payload != cmd->number_of_payloads - 1);\n\n\t\tstruct i2c_payload *payload = cmd->payloads + index_of_payload;\n\n\t\tif (!dce_i2c_sw_engine_submit_payload(\n\t\t\tdce_i2c_sw, payload, mot)) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t++index_of_payload;\n\t}\n\n\trelease_engine_dce_sw(pool, dce_i2c_sw);\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}