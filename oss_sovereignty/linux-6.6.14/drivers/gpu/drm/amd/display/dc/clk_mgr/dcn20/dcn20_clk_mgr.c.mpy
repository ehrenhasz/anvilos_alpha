{
  "module_name": "dcn20_clk_mgr.c",
  "hash_id": "f3fb7206417cddb26c812757756d480e1626c690e11e77cce50c9838acbe7b62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn20/dcn20_clk_mgr.c",
  "human_readable_source": " \n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dcn20_clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n\n#include \"navi10_ip_offset.h\"\n#include \"dcn/dcn_2_0_0_offset.h\"\n#include \"dcn/dcn_2_0_0_sh_mask.h\"\n#include \"clk/clk_11_0_0_offset.h\"\n#include \"clk/clk_11_0_0_sh_mask.h\"\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#define BASE_INNER(seg) DCN_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define CLK_BASE_INNER(seg) \\\n\tCLK_BASE__INST0_SEG ## seg\n\n\nstatic const struct clk_mgr_registers clk_mgr_regs = {\n\tCLK_REG_LIST_NV10()\n};\n\nstatic const struct clk_mgr_shift clk_mgr_shift = {\n\tCLK_MASK_SH_LIST_NV10(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask clk_mgr_mask = {\n\tCLK_MASK_SH_LIST_NV10(_MASK)\n};\n\nuint32_t dentist_get_did_from_divider(int divider)\n{\n\tuint32_t divider_id;\n\n\t \n\tif (divider < DENTIST_DIVIDER_RANGE_2_START) {\n\t\tif (divider < DENTIST_DIVIDER_RANGE_1_START)\n\t\t\tdivider_id = DENTIST_BASE_DID_1;\n\t\telse\n\t\t\tdivider_id = DENTIST_BASE_DID_1\n\t\t\t\t+ (divider - DENTIST_DIVIDER_RANGE_1_START)\n\t\t\t\t\t/ DENTIST_DIVIDER_RANGE_1_STEP;\n\t} else if (divider < DENTIST_DIVIDER_RANGE_3_START) {\n\t\tdivider_id = DENTIST_BASE_DID_2\n\t\t\t\t+ (divider - DENTIST_DIVIDER_RANGE_2_START)\n\t\t\t\t\t/ DENTIST_DIVIDER_RANGE_2_STEP;\n\t} else if (divider < DENTIST_DIVIDER_RANGE_4_START) {\n\t\tdivider_id = DENTIST_BASE_DID_3\n\t\t\t\t+ (divider - DENTIST_DIVIDER_RANGE_3_START)\n\t\t\t\t\t/ DENTIST_DIVIDER_RANGE_3_STEP;\n\t} else {\n\t\tdivider_id = DENTIST_BASE_DID_4\n\t\t\t\t+ (divider - DENTIST_DIVIDER_RANGE_4_START)\n\t\t\t\t\t/ DENTIST_DIVIDER_RANGE_4_STEP;\n\t\tif (divider_id > DENTIST_MAX_DID)\n\t\t\tdivider_id = DENTIST_MAX_DID;\n\t}\n\n\treturn divider_id;\n}\n\nvoid dcn20_update_clocks_update_dpp_dto(struct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context, bool safe_to_lower)\n{\n\tint i;\n\n\tclk_mgr->dccg->ref_dppclk = clk_mgr->base.clks.dppclk_khz;\n\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\tint dpp_inst, dppclk_khz, prev_dppclk_khz;\n\n\t\t \n\t\tdpp_inst = i;\n\t\tdppclk_khz = context->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz;\n\n\t\tprev_dppclk_khz = clk_mgr->dccg->pipe_dppclk_khz[i];\n\n\t\tif (safe_to_lower || prev_dppclk_khz < dppclk_khz)\n\t\t\tclk_mgr->dccg->funcs->update_dpp_dto(\n\t\t\t\t\t\t\tclk_mgr->dccg, dpp_inst, dppclk_khz);\n\t}\n}\n\nvoid dcn20_update_clocks_update_dentist(struct clk_mgr_internal *clk_mgr, struct dc_state *context)\n{\n\tint dpp_divider = 0;\n\tint disp_divider = 0;\n\tuint32_t dppclk_wdivider = 0;\n\tuint32_t dispclk_wdivider = 0;\n\tuint32_t current_dispclk_wdivider;\n\tuint32_t i;\n\n\tif (clk_mgr->base.clks.dppclk_khz == 0 || clk_mgr->base.clks.dispclk_khz == 0)\n\t\treturn;\n\n\tdpp_divider = DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr->base.dentist_vco_freq_khz / clk_mgr->base.clks.dppclk_khz;\n\tdisp_divider = DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr->base.dentist_vco_freq_khz / clk_mgr->base.clks.dispclk_khz;\n\n\tdppclk_wdivider = dentist_get_did_from_divider(dpp_divider);\n\tdispclk_wdivider = dentist_get_did_from_divider(disp_divider);\n\n\tREG_GET(DENTIST_DISPCLK_CNTL,\n\t\t\tDENTIST_DISPCLK_WDIVIDER, &current_dispclk_wdivider);\n\n\t \n\tif (current_dispclk_wdivider == 127 && dispclk_wdivider != 127) {\n\t\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\tuint32_t fifo_level;\n\t\t\tstruct dccg *dccg = clk_mgr->base.ctx->dc->res_pool->dccg;\n\t\t\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\t\t\tint32_t N;\n\t\t\tint32_t j;\n\n\t\t\tif (!resource_is_pipe_type(pipe_ctx, OTG_MASTER))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!stream_enc->funcs->get_fifo_cal_average_level)\n\t\t\t\tcontinue;\n\t\t\tfifo_level = stream_enc->funcs->get_fifo_cal_average_level(\n\t\t\t\t\tstream_enc);\n\t\t\tN = fifo_level / 4;\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(\n\t\t\t\t\tdccg,\n\t\t\t\t\ttrue);\n\t\t\tfor (j = 0; j < N - 4; j++)\n\t\t\t\tdccg->funcs->otg_drop_pixel(\n\t\t\t\t\t\tdccg,\n\t\t\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(\n\t\t\t\t\tdccg,\n\t\t\t\t\tfalse);\n\t\t}\n\t} else if (dispclk_wdivider == 127 && current_dispclk_wdivider != 127) {\n\t\tREG_UPDATE(DENTIST_DISPCLK_CNTL,\n\t\t\t\tDENTIST_DISPCLK_WDIVIDER, 126);\n\t\tREG_WAIT(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, 1, 50, 2000);\n\t\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\tstruct dccg *dccg = clk_mgr->base.ctx->dc->res_pool->dccg;\n\t\t\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\t\t\tuint32_t fifo_level;\n\t\t\tint32_t N;\n\t\t\tint32_t j;\n\n\t\t\tif (!resource_is_pipe_type(pipe_ctx, OTG_MASTER))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!stream_enc->funcs->get_fifo_cal_average_level)\n\t\t\t\tcontinue;\n\t\t\tfifo_level = stream_enc->funcs->get_fifo_cal_average_level(\n\t\t\t\t\tstream_enc);\n\t\t\tN = fifo_level / 4;\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(dccg, true);\n\t\t\tfor (j = 0; j < 12 - N; j++)\n\t\t\t\tdccg->funcs->otg_add_pixel(dccg,\n\t\t\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(dccg, false);\n\t\t}\n\t}\n\n\tREG_UPDATE(DENTIST_DISPCLK_CNTL,\n\t\t\tDENTIST_DISPCLK_WDIVIDER, dispclk_wdivider);\n\tREG_WAIT(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, 1, 50, 2000);\n\tREG_UPDATE(DENTIST_DISPCLK_CNTL,\n\t\t\tDENTIST_DPPCLK_WDIVIDER, dppclk_wdivider);\n\tREG_WAIT(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_CHG_DONE, 1, 5, 100);\n}\n\n\nvoid dcn2_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tstruct pp_smu_funcs_nv *pp_smu = NULL;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool enter_display_off = false;\n\tbool dpp_clock_lowered = false;\n\tstruct dmcu *dmcu = clk_mgr_base->ctx->dc->res_pool->dmcu;\n\tbool force_reset = false;\n\tbool p_state_change_support;\n\tint total_plane_count;\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\tif (clk_mgr_base->clks.dispclk_khz == 0 ||\n\t\tdc->debug.force_clock_mode & 0x1) {\n\t\t\n\t\tforce_reset = true;\n\n\t\tdcn2_read_clocks_from_hw_dentist(clk_mgr_base);\n\n\t\t\n\t}\n\tdisplay_count = clk_mgr_helper_get_active_display_cnt(dc, context);\n\tif (dc->res_pool->pp_smu)\n\t\tpp_smu = &dc->res_pool->pp_smu->nv_funcs;\n\n\tif (display_count == 0)\n\t\tenter_display_off = true;\n\n\tif (enter_display_off == safe_to_lower) {\n\t\tif (pp_smu && pp_smu->set_display_count)\n\t\t\tpp_smu->set_display_count(&pp_smu->pp_smu, display_count);\n\t}\n\n\tif (dc->debug.force_min_dcfclk_mhz > 0)\n\t\tnew_clocks->dcfclk_khz = (new_clocks->dcfclk_khz > (dc->debug.force_min_dcfclk_mhz * 1000)) ?\n\t\t\t\tnew_clocks->dcfclk_khz : (dc->debug.force_min_dcfclk_mhz * 1000);\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\tif (pp_smu && pp_smu->set_hard_min_dcfclk_by_freq)\n\t\t\tpp_smu->set_hard_min_dcfclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_khz));\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\tif (pp_smu && pp_smu->set_min_deep_sleep_dcfclk)\n\t\t\tpp_smu->set_min_deep_sleep_dcfclk(&pp_smu->pp_smu, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_deep_sleep_khz));\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->socclk_khz, clk_mgr_base->clks.socclk_khz)) {\n\t\tclk_mgr_base->clks.socclk_khz = new_clocks->socclk_khz;\n\t\tif (pp_smu && pp_smu->set_hard_min_socclk_by_freq)\n\t\t\tpp_smu->set_hard_min_socclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(clk_mgr_base->clks.socclk_khz));\n\t}\n\n\ttotal_plane_count = clk_mgr_helper_get_active_plane_cnt(dc, context);\n\tp_state_change_support = new_clocks->p_state_change_support || (total_plane_count == 0);\n\tif (should_update_pstate_support(safe_to_lower, p_state_change_support, clk_mgr_base->clks.p_state_change_support)) {\n\t\tclk_mgr_base->clks.prev_p_state_change_support = clk_mgr_base->clks.p_state_change_support;\n\t\tclk_mgr_base->clks.p_state_change_support = p_state_change_support;\n\t\tif (pp_smu && pp_smu->set_pstate_handshake_support)\n\t\t\tpp_smu->set_pstate_handshake_support(&pp_smu->pp_smu, clk_mgr_base->clks.p_state_change_support);\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dramclk_khz, clk_mgr_base->clks.dramclk_khz)) {\n\t\tclk_mgr_base->clks.dramclk_khz = new_clocks->dramclk_khz;\n\t\tif (pp_smu && pp_smu->set_hard_min_uclk_by_freq)\n\t\t\tpp_smu->set_hard_min_uclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(clk_mgr_base->clks.dramclk_khz));\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr->base.clks.dppclk_khz)) {\n\t\tif (clk_mgr->base.clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\t\tclk_mgr->base.clks.dppclk_khz = new_clocks->dppclk_khz;\n\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (update_dppclk || update_dispclk) {\n\t\tnew_clocks->disp_dpp_voltage_level_khz = new_clocks->dppclk_khz;\n\n\t\tif (update_dispclk)\n\t\t\tnew_clocks->disp_dpp_voltage_level_khz = new_clocks->dispclk_khz > new_clocks->dppclk_khz ? new_clocks->dispclk_khz : new_clocks->dppclk_khz;\n\n\t\tclk_mgr_base->clks.disp_dpp_voltage_level_khz = new_clocks->disp_dpp_voltage_level_khz;\n\t\tif (pp_smu && pp_smu->set_voltage_by_freq)\n\t\t\tpp_smu->set_voltage_by_freq(&pp_smu->pp_smu, PP_SMU_NV_DISPCLK, khz_to_mhz_ceil(clk_mgr_base->clks.disp_dpp_voltage_level_khz));\n\t}\n\n\tif (dc->config.forced_clocks == false || (force_reset && safe_to_lower)) {\n\t\tif (dpp_clock_lowered) {\n\t\t\t\n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t} else {\n\t\t\t\n\t\t\tif (update_dppclk || update_dispclk)\n\t\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t\t\n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t}\n\t}\n\n\tif (update_dispclk &&\n\t\t\tdmcu && dmcu->funcs->is_dmcu_initialized(dmcu)) {\n\t\t \n\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\tclk_mgr_base->clks.dispclk_khz / 1000 / 7);\n\t}\n}\n\nvoid dcn2_update_clocks_fpga(struct clk_mgr *clk_mgr,\n\t\tstruct dc_state *context,\n\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr_int = TO_CLK_MGR_INTERNAL(clk_mgr);\n\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\t \n\tint fclk_adj = new_clocks->fclk_khz > 1200000 ? new_clocks->fclk_khz : 1200000;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->phyclk_khz, clk_mgr->clks.phyclk_khz)) {\n\t\tclk_mgr->clks.phyclk_khz = new_clocks->phyclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr->clks.dcfclk_khz)) {\n\t\tclk_mgr->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->socclk_khz, clk_mgr->clks.socclk_khz)) {\n\t\tclk_mgr->clks.socclk_khz = new_clocks->socclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dramclk_khz, clk_mgr->clks.dramclk_khz)) {\n\t\tclk_mgr->clks.dramclk_khz = new_clocks->dramclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr->clks.dppclk_khz)) {\n\t\tclk_mgr->clks.dppclk_khz = new_clocks->dppclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, fclk_adj, clk_mgr->clks.fclk_khz)) {\n\t\tclk_mgr->clks.fclk_khz = fclk_adj;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr->clks.dispclk_khz)) {\n\t\tclk_mgr->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t}\n\n\t \n\tif (clk_mgr->clks.fclk_khz > clk_mgr->clks.dppclk_khz)\n\t\tclk_mgr->clks.dppclk_khz = clk_mgr->clks.fclk_khz;\n\tif (clk_mgr->clks.dppclk_khz > clk_mgr->clks.fclk_khz)\n\t\tclk_mgr->clks.fclk_khz = clk_mgr->clks.dppclk_khz;\n\n\t\n\tclk_mgr_int->dccg->ref_dppclk = clk_mgr->clks.fclk_khz;\n\n\t \n\tclk_mgr->clks.dtbclk_en = false;\n\tdm_set_dcn_clocks(clk_mgr->ctx, &clk_mgr->clks);\n}\n\nvoid dcn2_init_clocks(struct clk_mgr *clk_mgr)\n{\n\tmemset(&(clk_mgr->clks), 0, sizeof(struct dc_clocks));\n\t\n\tclk_mgr->clks.p_state_change_support = true;\n\tclk_mgr->clks.prev_p_state_change_support = true;\n}\n\nstatic void dcn2_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct pp_smu_funcs_nv *pp_smu = NULL;\n\n\tif (clk_mgr->pp_smu) {\n\t\tpp_smu = &clk_mgr->pp_smu->nv_funcs;\n\n\t\tif (pp_smu->set_pme_wa_enable)\n\t\t\tpp_smu->set_pme_wa_enable(&pp_smu->pp_smu);\n\t}\n}\n\n\nvoid dcn2_read_clocks_from_hw_dentist(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tuint32_t dispclk_wdivider;\n\tuint32_t dppclk_wdivider;\n\tint disp_divider;\n\tint dpp_divider;\n\n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, &dispclk_wdivider);\n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, &dppclk_wdivider);\n\n\tdisp_divider = dentist_get_divider_from_did(dispclk_wdivider);\n\tdpp_divider = dentist_get_divider_from_did(dppclk_wdivider);\n\n\tif (disp_divider && dpp_divider) {\n\t\t \n\t\tclk_mgr_base->clks.dispclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / disp_divider;\n\n\t\tclk_mgr_base->clks.dppclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / dpp_divider;\n\t}\n}\n\nvoid dcn2_get_clock(struct clk_mgr *clk_mgr,\n\t\tstruct dc_state *context,\n\t\t\tenum dc_clock_type clock_type,\n\t\t\tstruct dc_clock_config *clock_cfg)\n{\n\n\tif (clock_type == DC_CLOCK_TYPE_DISPCLK) {\n\t\tclock_cfg->max_clock_khz = context->bw_ctx.bw.dcn.clk.max_supported_dispclk_khz;\n\t\tclock_cfg->min_clock_khz = DCN_MINIMUM_DISPCLK_Khz;\n\t\tclock_cfg->current_clock_khz = clk_mgr->clks.dispclk_khz;\n\t\tclock_cfg->bw_requirequired_clock_khz = context->bw_ctx.bw.dcn.clk.bw_dispclk_khz;\n\t}\n\tif (clock_type == DC_CLOCK_TYPE_DPPCLK) {\n\t\tclock_cfg->max_clock_khz = context->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz;\n\t\tclock_cfg->min_clock_khz = DCN_MINIMUM_DPPCLK_Khz;\n\t\tclock_cfg->current_clock_khz = clk_mgr->clks.dppclk_khz;\n\t\tclock_cfg->bw_requirequired_clock_khz = context->bw_ctx.bw.dcn.clk.bw_dppclk_khz;\n\t}\n}\n\nstatic bool dcn2_are_clock_states_equal(struct dc_clocks *a,\n\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->disp_dpp_voltage_level_khz != b->disp_dpp_voltage_level_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->socclk_khz != b->socclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\telse if (a->dramclk_khz != b->dramclk_khz)\n\t\treturn false;\n\telse if (a->p_state_change_support != b->p_state_change_support)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void dcn2_notify_link_rate_change(struct clk_mgr *clk_mgr_base, struct dc_link *link)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int i, max_phyclk_req = 0;\n\tstruct pp_smu_funcs_nv *pp_smu = NULL;\n\n\tif (!clk_mgr->pp_smu || !clk_mgr->pp_smu->nv_funcs.set_voltage_by_freq)\n\t\treturn;\n\n\tpp_smu = &clk_mgr->pp_smu->nv_funcs;\n\n\tclk_mgr->cur_phyclk_req_table[link->link_index] = link->cur_link_settings.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;\n\n\tfor (i = 0; i < MAX_PIPES * 2; i++) {\n\t\tif (clk_mgr->cur_phyclk_req_table[i] > max_phyclk_req)\n\t\t\tmax_phyclk_req = clk_mgr->cur_phyclk_req_table[i];\n\t}\n\n\tif (max_phyclk_req != clk_mgr_base->clks.phyclk_khz) {\n\t\tclk_mgr_base->clks.phyclk_khz = max_phyclk_req;\n\t\tpp_smu->set_voltage_by_freq(&pp_smu->pp_smu, PP_SMU_NV_PHYCLK, khz_to_mhz_ceil(clk_mgr_base->clks.phyclk_khz));\n\t}\n}\n\nstatic struct clk_mgr_funcs dcn2_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = dcn2_update_clocks,\n\t.init_clocks = dcn2_init_clocks,\n\t.enable_pme_wa = dcn2_enable_pme_wa,\n\t.get_clock = dcn2_get_clock,\n\t.are_clock_states_equal = dcn2_are_clock_states_equal,\n\t.notify_link_rate_change = dcn2_notify_link_rate_change,\n};\n\n\nvoid dcn20_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tint dprefclk_did;\n\tint target_div;\n\tuint32_t pll_req_reg;\n\tstruct fixed31_32 pll_req;\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->pp_smu = pp_smu;\n\tclk_mgr->base.funcs = &dcn2_funcs;\n\tclk_mgr->regs = &clk_mgr_regs;\n\tclk_mgr->clk_mgr_shift = &clk_mgr_shift;\n\tclk_mgr->clk_mgr_mask = &clk_mgr_mask;\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\n\tclk_mgr->base.dprefclk_khz = 700000; \n\n\t \n\tdprefclk_did = REG_READ(CLK3_CLK2_DFS_CNTL);\n\t \n\ttarget_div = dentist_get_divider_from_did(dprefclk_did);\n\t \n\tpll_req_reg = REG_READ(CLK3_CLK_PLL_REQ);\n\n\t \n\n\tpll_req = dc_fixpt_from_int(pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_int);\n\tpll_req.value |= pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_frac;\n\n\t \n\tpll_req = dc_fixpt_mul_int(pll_req, 100000);\n\n\t \n\tclk_mgr->base.dentist_vco_freq_khz = dc_fixpt_floor(pll_req);\n\n\t \n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 3850000;\n\n\t \n\tclk_mgr->base.dprefclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\t\n\t\n\t\n\tclk_mgr->dfs_bypass_enabled = false;\n\n\tdce_clock_read_ss_info(clk_mgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}