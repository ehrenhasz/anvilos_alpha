{
  "module_name": "dc_surface.c",
  "hash_id": "9e380eeff9b5c1e5321ecf1b7f1fc4572a865a8e8325abf2fdccf43b383314ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_surface.c",
  "human_readable_source": " \n\n \n#include \"dm_services.h\"\n#include \"dc.h\"\n\n \n#include \"core_types.h\"\n#include \"transform.h\"\n#include \"dpp.h\"\n\n \nstatic void dc_plane_construct(struct dc_context *ctx, struct dc_plane_state *plane_state)\n{\n\tplane_state->ctx = ctx;\n\n\tplane_state->gamma_correction = dc_create_gamma();\n\tif (plane_state->gamma_correction != NULL)\n\t\tplane_state->gamma_correction->is_identity = true;\n\n\tplane_state->in_transfer_func = dc_create_transfer_func();\n\tif (plane_state->in_transfer_func != NULL) {\n\t\tplane_state->in_transfer_func->type = TF_TYPE_BYPASS;\n\t}\n\tplane_state->in_shaper_func = dc_create_transfer_func();\n\tif (plane_state->in_shaper_func != NULL) {\n\t\tplane_state->in_shaper_func->type = TF_TYPE_BYPASS;\n\t}\n\n\tplane_state->lut3d_func = dc_create_3dlut_func();\n\n\tplane_state->blend_tf = dc_create_transfer_func();\n\tif (plane_state->blend_tf != NULL) {\n\t\tplane_state->blend_tf->type = TF_TYPE_BYPASS;\n\t}\n\n\tplane_state->pre_multiplied_alpha = true;\n\n}\n\nstatic void dc_plane_destruct(struct dc_plane_state *plane_state)\n{\n\tif (plane_state->gamma_correction != NULL) {\n\t\tdc_gamma_release(&plane_state->gamma_correction);\n\t}\n\tif (plane_state->in_transfer_func != NULL) {\n\t\tdc_transfer_func_release(\n\t\t\t\tplane_state->in_transfer_func);\n\t\tplane_state->in_transfer_func = NULL;\n\t}\n\tif (plane_state->in_shaper_func != NULL) {\n\t\tdc_transfer_func_release(\n\t\t\t\tplane_state->in_shaper_func);\n\t\tplane_state->in_shaper_func = NULL;\n\t}\n\tif (plane_state->lut3d_func != NULL) {\n\t\tdc_3dlut_func_release(\n\t\t\t\tplane_state->lut3d_func);\n\t\tplane_state->lut3d_func = NULL;\n\t}\n\tif (plane_state->blend_tf != NULL) {\n\t\tdc_transfer_func_release(\n\t\t\t\tplane_state->blend_tf);\n\t\tplane_state->blend_tf = NULL;\n\t}\n\n}\n\n \nvoid enable_surface_flip_reporting(struct dc_plane_state *plane_state,\n\t\tuint32_t controller_id)\n{\n\tplane_state->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;\n\t \n}\n\nstruct dc_plane_state *dc_create_plane_state(struct dc *dc)\n{\n\tstruct dc_plane_state *plane_state = kvzalloc(sizeof(*plane_state),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (NULL == plane_state)\n\t\treturn NULL;\n\n\tkref_init(&plane_state->refcount);\n\tdc_plane_construct(dc->ctx, plane_state);\n\n\treturn plane_state;\n}\n\n \nconst struct dc_plane_status *dc_plane_get_status(\n\t\tconst struct dc_plane_state *plane_state)\n{\n\tconst struct dc_plane_status *plane_status;\n\tstruct dc  *dc;\n\tint i;\n\n\tif (!plane_state ||\n\t\t!plane_state->ctx ||\n\t\t!plane_state->ctx->dc) {\n\t\tASSERT(0);\n\t\treturn NULL;  \n\t}\n\n\tplane_status = &plane_state->status;\n\tdc = plane_state->ctx->dc;\n\n\tif (dc->current_state == NULL)\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->plane_state != plane_state)\n\t\t\tcontinue;\n\n\t\tpipe_ctx->plane_state->status.is_flip_pending = false;\n\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->plane_state != plane_state)\n\t\t\tcontinue;\n\n\t\tdc->hwss.update_pending_status(pipe_ctx);\n\t}\n\n\treturn plane_status;\n}\n\nvoid dc_plane_state_retain(struct dc_plane_state *plane_state)\n{\n\tkref_get(&plane_state->refcount);\n}\n\nstatic void dc_plane_state_free(struct kref *kref)\n{\n\tstruct dc_plane_state *plane_state = container_of(kref, struct dc_plane_state, refcount);\n\tdc_plane_destruct(plane_state);\n\tkvfree(plane_state);\n}\n\nvoid dc_plane_state_release(struct dc_plane_state *plane_state)\n{\n\tkref_put(&plane_state->refcount, dc_plane_state_free);\n}\n\nvoid dc_gamma_retain(struct dc_gamma *gamma)\n{\n\tkref_get(&gamma->refcount);\n}\n\nstatic void dc_gamma_free(struct kref *kref)\n{\n\tstruct dc_gamma *gamma = container_of(kref, struct dc_gamma, refcount);\n\tkvfree(gamma);\n}\n\nvoid dc_gamma_release(struct dc_gamma **gamma)\n{\n\tkref_put(&(*gamma)->refcount, dc_gamma_free);\n\t*gamma = NULL;\n}\n\nstruct dc_gamma *dc_create_gamma(void)\n{\n\tstruct dc_gamma *gamma = kvzalloc(sizeof(*gamma), GFP_KERNEL);\n\n\tif (gamma == NULL)\n\t\tgoto alloc_fail;\n\n\tkref_init(&gamma->refcount);\n\treturn gamma;\n\nalloc_fail:\n\treturn NULL;\n}\n\nvoid dc_transfer_func_retain(struct dc_transfer_func *tf)\n{\n\tkref_get(&tf->refcount);\n}\n\nstatic void dc_transfer_func_free(struct kref *kref)\n{\n\tstruct dc_transfer_func *tf = container_of(kref, struct dc_transfer_func, refcount);\n\tkvfree(tf);\n}\n\nvoid dc_transfer_func_release(struct dc_transfer_func *tf)\n{\n\tkref_put(&tf->refcount, dc_transfer_func_free);\n}\n\nstruct dc_transfer_func *dc_create_transfer_func(void)\n{\n\tstruct dc_transfer_func *tf = kvzalloc(sizeof(*tf), GFP_KERNEL);\n\n\tif (tf == NULL)\n\t\tgoto alloc_fail;\n\n\tkref_init(&tf->refcount);\n\n\treturn tf;\n\nalloc_fail:\n\treturn NULL;\n}\n\nstatic void dc_3dlut_func_free(struct kref *kref)\n{\n\tstruct dc_3dlut *lut = container_of(kref, struct dc_3dlut, refcount);\n\n\tkvfree(lut);\n}\n\nstruct dc_3dlut *dc_create_3dlut_func(void)\n{\n\tstruct dc_3dlut *lut = kvzalloc(sizeof(*lut), GFP_KERNEL);\n\n\tif (lut == NULL)\n\t\tgoto alloc_fail;\n\n\tkref_init(&lut->refcount);\n\tlut->state.raw = 0;\n\n\treturn lut;\n\nalloc_fail:\n\treturn NULL;\n\n}\n\nvoid dc_3dlut_func_release(struct dc_3dlut *lut)\n{\n\tkref_put(&lut->refcount, dc_3dlut_func_free);\n}\n\nvoid dc_3dlut_func_retain(struct dc_3dlut *lut)\n{\n\tkref_get(&lut->refcount);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}