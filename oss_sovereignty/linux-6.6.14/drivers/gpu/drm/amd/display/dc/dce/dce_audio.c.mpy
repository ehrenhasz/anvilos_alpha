{
  "module_name": "dce_audio.c",
  "hash_id": "e4437d8a0e46205f4ccfb85181e26d7e7c95620b45529349a472190128ccfeeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_audio.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"dce_audio.h\"\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#define DCE_AUD(audio)\\\n\tcontainer_of(audio, struct dce_audio, base)\n\n#define CTX \\\n\taud->base.ctx\n\n#define DC_LOGGER_INIT()\n\n#define REG(reg)\\\n\t(aud->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\taud->shifts->field_name, aud->masks->field_name\n\n#define IX_REG(reg)\\\n\tix ## reg\n\n#define AZ_REG_READ(reg_name) \\\n\t\tread_indirect_azalia_reg(audio, IX_REG(reg_name))\n\n#define AZ_REG_WRITE(reg_name, value) \\\n\t\twrite_indirect_azalia_reg(audio, IX_REG(reg_name), value)\n\nstatic void write_indirect_azalia_reg(struct audio *audio,\n\tuint32_t reg_index,\n\tuint32_t reg_data)\n{\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\t \n\tREG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX, 0,\n\t\t\tAZALIA_ENDPOINT_REG_INDEX, reg_index);\n\n\t \n\tREG_SET(AZALIA_F0_CODEC_ENDPOINT_DATA, 0,\n\t\t\tAZALIA_ENDPOINT_REG_DATA, reg_data);\n}\n\nstatic uint32_t read_indirect_azalia_reg(struct audio *audio, uint32_t reg_index)\n{\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\tuint32_t value = 0;\n\n\t \n\tREG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX, 0,\n\t\t\tAZALIA_ENDPOINT_REG_INDEX, reg_index);\n\n\t \n\tvalue = REG_READ(AZALIA_F0_CODEC_ENDPOINT_DATA);\n\n\treturn value;\n}\n\nstatic bool is_audio_format_supported(\n\tconst struct audio_info *audio_info,\n\tenum audio_format_code audio_format_code,\n\tuint32_t *format_index)\n{\n\tuint32_t index;\n\tuint32_t max_channe_index = 0;\n\tbool found = false;\n\n\tif (audio_info == NULL)\n\t\treturn found;\n\n\t \n\tfor (index = 0; index < audio_info->mode_count; index++) {\n\t\tif (audio_info->modes[index].format_code == audio_format_code) {\n\t\t\tif (found) {\n\t\t\t\t \n\t\t\t\tif (audio_info->modes[index].channel_count >\n\t\taudio_info->modes[max_channe_index].channel_count) {\n\t\t\t\t\tmax_channe_index = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfound = true;\n\t\t\t\tmax_channe_index = index;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (found && format_index != NULL)\n\t\t*format_index = max_channe_index;\n\n\treturn found;\n}\n\n \nstatic void check_audio_bandwidth_hdmi(\n\tconst struct audio_crtc_info *crtc_info,\n\tuint32_t channel_count,\n\tunion audio_sample_rates *sample_rates)\n{\n\tuint32_t samples;\n\tuint32_t  h_blank;\n\tbool limit_freq_to_48_khz = false;\n\tbool limit_freq_to_88_2_khz = false;\n\tbool limit_freq_to_96_khz = false;\n\tbool limit_freq_to_174_4_khz = false;\n\tif (!crtc_info)\n\t\treturn;\n\n\t \n\tif (channel_count > 2) {\n\n\t\t \n\t\tif ((crtc_info->requested_pixel_clock_100Hz <= 270000) &&\n\t\t(crtc_info->v_active <= 576) &&\n\t\t!(crtc_info->interlaced) &&\n\t\t!(crtc_info->pixel_repetition == 2 ||\n\t\tcrtc_info->pixel_repetition == 4)) {\n\t\t\tlimit_freq_to_48_khz = true;\n\n\t\t} else if ((crtc_info->requested_pixel_clock_100Hz <= 270000) &&\n\t\t\t\t(crtc_info->v_active <= 576) &&\n\t\t\t\t(crtc_info->interlaced) &&\n\t\t\t\t(crtc_info->pixel_repetition == 2)) {\n\t\t\tlimit_freq_to_88_2_khz = true;\n\n\t\t} else if ((crtc_info->requested_pixel_clock_100Hz <= 540000) &&\n\t\t\t\t(crtc_info->v_active <= 576) &&\n\t\t\t\t!(crtc_info->interlaced)) {\n\t\t\tlimit_freq_to_174_4_khz = true;\n\t\t}\n\t}\n\n\t \n\th_blank = crtc_info->h_total - crtc_info->h_active;\n\n\tif (crtc_info->pixel_repetition)\n\t\th_blank *= crtc_info->pixel_repetition;\n\n\t \n\th_blank -= 58;\n\t \n\th_blank -= 16;\n\n\tsamples = h_blank * 10;\n\t \n\tsamples /= 32;\n\tsamples *= crtc_info->v_active;\n\t \n\tsamples *= crtc_info->refresh_rate;\n\t \n\tsamples /= 10;\n\n\t \n\n\tswitch (crtc_info->color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tsamples *= 4;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tsamples *= 5;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tsamples *= 6;\n\t\tbreak;\n\tdefault:\n\t\tsamples *= 4;\n\t\tbreak;\n\t}\n\n\tsamples /= 4;\n\n\t \n\tif (samples < 88200)\n\t\tlimit_freq_to_48_khz = true;\n\telse if (samples < 96000)\n\t\tlimit_freq_to_88_2_khz = true;\n\telse if (samples < 176400)\n\t\tlimit_freq_to_96_khz = true;\n\telse if (samples < 192000)\n\t\tlimit_freq_to_174_4_khz = true;\n\n\tif (sample_rates != NULL) {\n\t\t \n\t\tif (limit_freq_to_174_4_khz)\n\t\t\tsample_rates->rate.RATE_192 = 0;\n\n\t\tif (limit_freq_to_96_khz) {\n\t\t\tsample_rates->rate.RATE_192 = 0;\n\t\t\tsample_rates->rate.RATE_176_4 = 0;\n\t\t}\n\t\tif (limit_freq_to_88_2_khz) {\n\t\t\tsample_rates->rate.RATE_192 = 0;\n\t\t\tsample_rates->rate.RATE_176_4 = 0;\n\t\t\tsample_rates->rate.RATE_96 = 0;\n\t\t}\n\t\tif (limit_freq_to_48_khz) {\n\t\t\tsample_rates->rate.RATE_192 = 0;\n\t\t\tsample_rates->rate.RATE_176_4 = 0;\n\t\t\tsample_rates->rate.RATE_96 = 0;\n\t\t\tsample_rates->rate.RATE_88_2 = 0;\n\t\t}\n\t}\n}\n\n \nstatic void check_audio_bandwidth_dpsst(\n\tconst struct audio_crtc_info *crtc_info,\n\tuint32_t channel_count,\n\tunion audio_sample_rates *sample_rates)\n{\n\t \n}\n\n \nstatic void check_audio_bandwidth_dpmst(\n\tconst struct audio_crtc_info *crtc_info,\n\tuint32_t channel_count,\n\tunion audio_sample_rates *sample_rates)\n{\n\t \n}\n\nstatic void check_audio_bandwidth(\n\tconst struct audio_crtc_info *crtc_info,\n\tuint32_t channel_count,\n\tenum signal_type signal,\n\tunion audio_sample_rates *sample_rates)\n{\n\tswitch (signal) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tcheck_audio_bandwidth_hdmi(\n\t\t\tcrtc_info, channel_count, sample_rates);\n\t\tbreak;\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\tcheck_audio_bandwidth_dpsst(\n\t\t\tcrtc_info, channel_count, sample_rates);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tcheck_audio_bandwidth_dpmst(\n\t\t\tcrtc_info, channel_count, sample_rates);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void set_high_bit_rate_capable(\n\tstruct audio *audio,\n\tbool capable)\n{\n\tuint32_t value = 0;\n\n\t \n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);\n\n\tset_reg_field_value(value, capable,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,\n\t\tHBR_CAPABLE);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR, value);\n}\n\n \nstatic void set_video_latency(\n\tstruct audio *audio,\n\tint latency_in_ms)\n{\n\tuint32_t value = 0;\n\n\tif ((latency_in_ms < 0) || (latency_in_ms > 255))\n\t\treturn;\n\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);\n\n\tset_reg_field_value(value, latency_in_ms,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,\n\t\tVIDEO_LIPSYNC);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,\n\t\tvalue);\n}\n\n \nstatic void set_audio_latency(\n\tstruct audio *audio,\n\tint latency_in_ms)\n{\n\tuint32_t value = 0;\n\n\tif (latency_in_ms < 0)\n\t\tlatency_in_ms = 0;\n\n\tif (latency_in_ms > 255)\n\t\tlatency_in_ms = 255;\n\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);\n\n\tset_reg_field_value(value, latency_in_ms,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,\n\t\tAUDIO_LIPSYNC);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,\n\t\tvalue);\n}\n\nvoid dce_aud_az_enable(struct audio *audio)\n{\n\tuint32_t value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tDC_LOGGER_INIT();\n\n\tset_reg_field_value(value, 1,\n\t\t\t    AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\t    CLOCK_GATING_DISABLE);\n\tset_reg_field_value(value, 1,\n\t\t\t    AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\t    AUDIO_ENABLED);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\tset_reg_field_value(value, 0,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\n\tDC_LOG_HW_AUDIO(\"\\n\\t========= AUDIO:dce_aud_az_enable: index: %u  data: 0x%x\\n\",\n\t\t\taudio->inst, value);\n}\n\nvoid dce_aud_az_disable(struct audio *audio)\n{\n\tuint32_t value;\n\tDC_LOGGER_INIT();\n\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tset_reg_field_value(value, 1,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\n\tset_reg_field_value(value, 0,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\tAUDIO_ENABLED);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\n\tset_reg_field_value(value, 0,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tDC_LOG_HW_AUDIO(\"\\n\\t========= AUDIO:dce_aud_az_disable: index: %u  data: 0x%x\\n\",\n\t\t\taudio->inst, value);\n}\n\nvoid dce_aud_az_configure(\n\tstruct audio *audio,\n\tenum signal_type signal,\n\tconst struct audio_crtc_info *crtc_info,\n\tconst struct audio_info *audio_info)\n{\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\tuint32_t speakers = audio_info->flags.info.ALLSPEAKERS;\n\tuint32_t value;\n\tuint32_t field = 0;\n\tenum audio_format_code audio_format_code;\n\tuint32_t format_index;\n\tuint32_t index;\n\tbool is_ac3_supported = false;\n\tunion audio_sample_rates sample_rate;\n\tuint32_t strlen = 0;\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tset_reg_field_value(value, 1,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\n\t \n\t \n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);\n\n\tset_reg_field_value(value,\n\t\tspeakers,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\tSPEAKER_ALLOCATION);\n\n\t \n\tset_reg_field_value(value,\n\t\t0,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\tLFE_PLAYBACK_LEVEL);\n\t \n\n\n\tset_reg_field_value(value,\n\t\t0,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\tHDMI_CONNECTION);\n\n\tset_reg_field_value(value,\n\t\t0,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\tDP_CONNECTION);\n\n\tfield = get_reg_field_value(value,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\t\tEXTRA_CONNECTION_INFO);\n\n\tfield &= ~0x1;\n\n\tset_reg_field_value(value,\n\t\tfield,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\tEXTRA_CONNECTION_INFO);\n\n\t \n\tswitch (signal) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tset_reg_field_value(value,\n\t\t\t1,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\t\tHDMI_CONNECTION);\n\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tset_reg_field_value(value,\n\t\t\t1,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,\n\t\t\tDP_CONNECTION);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, value);\n\n\t \n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_ACP_DATA);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\taudio_info->flags.info.SUPPORT_AI,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_ACP_DATA,\n\t\tSUPPORTS_AI);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_ACP_DATA, value);\n\n\t \n\t \n\tfor (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;\n\t\t\tformat_index++) {\n\t\taudio_format_code =\n\t\t\t(AUDIO_FORMAT_CODE_FIRST + format_index);\n\n\t\t \n\t\tif (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||\n\t\t\taudio_format_code == AUDIO_FORMAT_CODE_DST)\n\t\t\tcontinue;\n\n\t\tvalue = 0;\n\n\t\t \n\t\tif (is_audio_format_supported(\n\t\t\t\taudio_info, audio_format_code, &index)) {\n\t\t\tconst struct audio_mode *audio_mode =\n\t\t\t\t\t&audio_info->modes[index];\n\t\t\tunion audio_sample_rates sample_rates =\n\t\t\t\t\taudio_mode->sample_rates;\n\t\t\tuint8_t byte2 = audio_mode->max_bit_rate;\n\t\t\tuint8_t channel_count = audio_mode->channel_count;\n\n\t\t\t \n\t\t\tswitch (audio_format_code) {\n\t\t\tcase AUDIO_FORMAT_CODE_LINEARPCM: {\n\n\t\t\t\tcheck_audio_bandwidth(\n\t\t\t\t\tcrtc_info,\n\t\t\t\t\tchannel_count,\n\t\t\t\t\tsignal,\n\t\t\t\t\t&sample_rates);\n\n\t\t\t\tbyte2 = audio_mode->sample_size;\n\n\t\t\t\tset_reg_field_value(value,\n\t\t\t\t\t\tsample_rates.all,\n\t\t\t\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,\n\t\t\t\t\t\tSUPPORTED_FREQUENCIES_STEREO);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIO_FORMAT_CODE_AC3:\n\t\t\t\tis_ac3_supported = true;\n\t\t\t\tbreak;\n\t\t\tcase AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:\n\t\t\tcase AUDIO_FORMAT_CODE_DTS_HD:\n\t\t\tcase AUDIO_FORMAT_CODE_MAT_MLP:\n\t\t\tcase AUDIO_FORMAT_CODE_DST:\n\t\t\tcase AUDIO_FORMAT_CODE_WMAPRO:\n\t\t\t\tbyte2 = audio_mode->vendor_specific;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tset_reg_field_value(value,\n\t\t\t\t\tchannel_count - 1,\n\t\t\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,\n\t\t\t\t\tMAX_CHANNELS);\n\n\t\t\tset_reg_field_value(value,\n\t\t\t\t\tsample_rates.all,\n\t\t\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,\n\t\t\t\t\tSUPPORTED_FREQUENCIES);\n\n\t\t\tset_reg_field_value(value,\n\t\t\t\t\tbyte2,\n\t\t\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,\n\t\t\t\t\tDESCRIPTOR_BYTE_2);\n\t\t}  \n\n\t\tAZ_REG_WRITE(\n\t\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 + format_index,\n\t\t\t\tvalue);\n\t}  \n\n\tif (is_ac3_supported)\n\t\t \n\t\tREG_WRITE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,\n\t\t\t\t0x05);\n\n\t \n\tsample_rate.all = 0;\n\tsample_rate.rate.RATE_192 = 1;\n\n\tcheck_audio_bandwidth(\n\t\tcrtc_info,\n\t\t8,\n\t\tsignal,\n\t\t&sample_rate);\n\n\tset_high_bit_rate_capable(audio, sample_rate.rate.RATE_192);\n\n\t \n\tset_video_latency(audio, audio_info->video_latency);\n\tset_audio_latency(audio, audio_info->audio_latency);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->manufacture_id,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,\n\t\tMANUFACTURER_ID);\n\n\tset_reg_field_value(value, audio_info->product_id,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,\n\t\tPRODUCT_ID);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,\n\t\tvalue);\n\n\tvalue = 0;\n\n\t \n\twhile (audio_info->display_name[strlen++] != '\\0') {\n\t\tif (strlen >=\n\t\tMAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)\n\t\t\tbreak;\n\t\t}\n\tset_reg_field_value(value, strlen,\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,\n\t\tSINK_DESCRIPTION_LEN);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,\n\t\tvalue);\n\tDC_LOG_HW_AUDIO(\"\\n\\tAUDIO:az_configure: index: %u data, 0x%x, displayName %s: \\n\",\n\t\taudio->inst, value, audio_info->display_name);\n\n\t \n\n\tvalue = 0;\n\n\tset_reg_field_value(value, audio_info->port_id[0],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,\n\t\tPORT_ID0);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->port_id[1],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,\n\t\tPORT_ID1);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3, value);\n\n\t \n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->display_name[0],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,\n\t\tDESCRIPTION0);\n\n\tset_reg_field_value(value, audio_info->display_name[1],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,\n\t\tDESCRIPTION1);\n\n\tset_reg_field_value(value, audio_info->display_name[2],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,\n\t\tDESCRIPTION2);\n\n\tset_reg_field_value(value, audio_info->display_name[3],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,\n\t\tDESCRIPTION3);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->display_name[4],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,\n\t\tDESCRIPTION4);\n\n\tset_reg_field_value(value, audio_info->display_name[5],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,\n\t\tDESCRIPTION5);\n\n\tset_reg_field_value(value, audio_info->display_name[6],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,\n\t\tDESCRIPTION6);\n\n\tset_reg_field_value(value, audio_info->display_name[7],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,\n\t\tDESCRIPTION7);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->display_name[8],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,\n\t\tDESCRIPTION8);\n\n\tset_reg_field_value(value, audio_info->display_name[9],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,\n\t\tDESCRIPTION9);\n\n\tset_reg_field_value(value, audio_info->display_name[10],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,\n\t\tDESCRIPTION10);\n\n\tset_reg_field_value(value, audio_info->display_name[11],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,\n\t\tDESCRIPTION11);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->display_name[12],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,\n\t\tDESCRIPTION12);\n\n\tset_reg_field_value(value, audio_info->display_name[13],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,\n\t\tDESCRIPTION13);\n\n\tset_reg_field_value(value, audio_info->display_name[14],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,\n\t\tDESCRIPTION14);\n\n\tset_reg_field_value(value, audio_info->display_name[15],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,\n\t\tDESCRIPTION15);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, audio_info->display_name[16],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,\n\t\tDESCRIPTION16);\n\n\tset_reg_field_value(value, audio_info->display_name[17],\n\t\tAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,\n\t\tDESCRIPTION17);\n\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8, value);\n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tset_reg_field_value(value, 0,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n}\n\n \n\n \nstatic void get_azalia_clock_info_hdmi(\n\tuint32_t crtc_pixel_clock_100hz,\n\tuint32_t actual_pixel_clock_100Hz,\n\tstruct azalia_clock_info *azalia_clock_info)\n{\n\t \n\tazalia_clock_info->audio_dto_phase =\n\t\t\t24 * 10000;\n\n\t \n\tazalia_clock_info->audio_dto_module =\n\t\t\tactual_pixel_clock_100Hz;\n}\n\nstatic void get_azalia_clock_info_dp(\n\tuint32_t requested_pixel_clock_100Hz,\n\tconst struct audio_pll_info *pll_info,\n\tstruct azalia_clock_info *azalia_clock_info)\n{\n\t \n\n\t \n\tazalia_clock_info->audio_dto_phase = 24 * 10000;\n\n\t \n\tazalia_clock_info->audio_dto_module =\n\t\tpll_info->dp_dto_source_clock_in_khz * 10;\n}\n\nvoid dce_aud_wall_dto_setup(\n\tstruct audio *audio,\n\tenum signal_type signal,\n\tconst struct audio_crtc_info *crtc_info,\n\tconst struct audio_pll_info *pll_info)\n{\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\tstruct azalia_clock_info clock_info = { 0 };\n\n\tif (dc_is_hdmi_tmds_signal(signal)) {\n\t\tuint32_t src_sel;\n\n\t\t \n\n\t\t \n\t\tget_azalia_clock_info_hdmi(\n\t\t\tcrtc_info->requested_pixel_clock_100Hz,\n\t\t\tcrtc_info->calculated_pixel_clock_100Hz,\n\t\t\t&clock_info);\n\n\t\tDC_LOG_HW_AUDIO(\"\\n%s:Input::requested_pixel_clock_100Hz = %d\"\\\n\t\t\t\t\"calculated_pixel_clock_100Hz =%d\\n\"\\\n\t\t\t\t\"audio_dto_module = %d audio_dto_phase =%d \\n\\n\", __func__,\\\n\t\t\t\tcrtc_info->requested_pixel_clock_100Hz,\\\n\t\t\t\tcrtc_info->calculated_pixel_clock_100Hz,\\\n\t\t\t\tclock_info.audio_dto_module,\\\n\t\t\t\tclock_info.audio_dto_phase);\n\n\t\t \n\t\tsrc_sel = pll_info->dto_source - DTO_SOURCE_ID0;\n\t\tREG_UPDATE_2(DCCG_AUDIO_DTO_SOURCE,\n\t\t\tDCCG_AUDIO_DTO0_SOURCE_SEL, src_sel,\n\t\t\tDCCG_AUDIO_DTO_SEL, 0);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO0_MODULE,\n\t\t\tDCCG_AUDIO_DTO0_MODULE, clock_info.audio_dto_module);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO0_PHASE,\n\t\t\tDCCG_AUDIO_DTO0_PHASE, clock_info.audio_dto_phase);\n\t} else {\n\t\t \n\t\tget_azalia_clock_info_dp(\n\t\t\tcrtc_info->requested_pixel_clock_100Hz,\n\t\t\tpll_info,\n\t\t\t&clock_info);\n\n\t\t \n\n\t\tREG_UPDATE(DCCG_AUDIO_DTO_SOURCE,\n\t\t\t\tDCCG_AUDIO_DTO_SEL, 1);\n\n\t\t\t \n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO1_MODULE,\n\t\t\t\tDCCG_AUDIO_DTO1_MODULE, clock_info.audio_dto_module);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO1_PHASE,\n\t\t\t\tDCCG_AUDIO_DTO1_PHASE, clock_info.audio_dto_phase);\n\n\t\tREG_UPDATE(DCCG_AUDIO_DTO_SOURCE,\n\t\t\t\tDCCG_AUDIO_DTO2_USE_512FBR_DTO, 1);\n\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_aud_wall_dto_setup(\n\tstruct audio *audio,\n\tenum signal_type signal,\n\tconst struct audio_crtc_info *crtc_info,\n\tconst struct audio_pll_info *pll_info)\n{\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\tstruct azalia_clock_info clock_info = { 0 };\n\n\tif (dc_is_hdmi_signal(signal)) {\n\t\tuint32_t src_sel;\n\n\t\t \n\n\t\t \n\t\tget_azalia_clock_info_hdmi(\n\t\t\tcrtc_info->requested_pixel_clock_100Hz,\n\t\t\tcrtc_info->calculated_pixel_clock_100Hz,\n\t\t\t&clock_info);\n\n\t\tDC_LOG_HW_AUDIO(\"\\n%s:Input::requested_pixel_clock_100Hz = %d\"\\\n\t\t\t\t\"calculated_pixel_clock_100Hz =%d\\n\"\\\n\t\t\t\t\"audio_dto_module = %d audio_dto_phase =%d \\n\\n\", __func__,\\\n\t\t\t\tcrtc_info->requested_pixel_clock_100Hz,\\\n\t\t\t\tcrtc_info->calculated_pixel_clock_100Hz,\\\n\t\t\t\tclock_info.audio_dto_module,\\\n\t\t\t\tclock_info.audio_dto_phase);\n\n\t\t \n\t\tsrc_sel = pll_info->dto_source - DTO_SOURCE_ID0;\n\t\tREG_UPDATE_2(DCCG_AUDIO_DTO_SOURCE,\n\t\t\tDCCG_AUDIO_DTO0_SOURCE_SEL, src_sel,\n\t\t\tDCCG_AUDIO_DTO_SEL, 0);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO0_MODULE,\n\t\t\tDCCG_AUDIO_DTO0_MODULE, clock_info.audio_dto_module);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO0_PHASE,\n\t\t\tDCCG_AUDIO_DTO0_PHASE, clock_info.audio_dto_phase);\n\t} else {\n\t\t \n\t\tget_azalia_clock_info_dp(\n\t\t\tcrtc_info->requested_pixel_clock_100Hz,\n\t\t\tpll_info,\n\t\t\t&clock_info);\n\n\t\t \n\n\t\tREG_UPDATE(DCCG_AUDIO_DTO_SOURCE,\n\t\t\t\tDCCG_AUDIO_DTO_SEL, 1);\n\n\t\t\t \n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO1_MODULE,\n\t\t\t\tDCCG_AUDIO_DTO1_MODULE, clock_info.audio_dto_module);\n\n\t\t \n\t\tREG_UPDATE(DCCG_AUDIO_DTO1_PHASE,\n\t\t\t\tDCCG_AUDIO_DTO1_PHASE, clock_info.audio_dto_phase);\n\n\t\t \n\n\t}\n}\n#endif\n\nstatic bool dce_aud_endpoint_valid(struct audio *audio)\n{\n\tuint32_t value;\n\tuint32_t port_connectivity;\n\n\tvalue = AZ_REG_READ(\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_CONFIGURATION_DEFAULT);\n\n\tport_connectivity = get_reg_field_value(value,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_CONFIGURATION_DEFAULT,\n\t\t\tPORT_CONNECTIVITY);\n\n\treturn !(port_connectivity == 1);\n}\n\n \nvoid dce_aud_hw_init(\n\t\tstruct audio *audio)\n{\n\tuint32_t value;\n\tstruct dce_audio *aud = DCE_AUD(audio);\n\n\t \n\tif (audio->inst != 0)\n\t\treturn;\n\n\t \n\t \n\tvalue = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);\n\tset_reg_field_value(value, 1,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n\tREG_UPDATE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,\n\t\t\tAUDIO_RATE_CAPABILITIES, 0x70);\n\n\t \n\tREG_UPDATE_2(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,\n\t\t\tCLKSTOP, 1,\n\t\t\tEPSS, 1);\n\tset_reg_field_value(value, 0,\n\t\t\tAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tCLOCK_GATING_DISABLE);\n\tAZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);\n}\n\nstatic const struct audio_funcs funcs = {\n\t.endpoint_valid = dce_aud_endpoint_valid,\n\t.hw_init = dce_aud_hw_init,\n\t.wall_dto_setup = dce_aud_wall_dto_setup,\n\t.az_enable = dce_aud_az_enable,\n\t.az_disable = dce_aud_az_disable,\n\t.az_configure = dce_aud_az_configure,\n\t.destroy = dce_aud_destroy,\n};\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic const struct audio_funcs dce60_funcs = {\n\t.endpoint_valid = dce_aud_endpoint_valid,\n\t.hw_init = dce_aud_hw_init,\n\t.wall_dto_setup = dce60_aud_wall_dto_setup,\n\t.az_enable = dce_aud_az_enable,\n\t.az_disable = dce_aud_az_disable,\n\t.az_configure = dce_aud_az_configure,\n\t.destroy = dce_aud_destroy,\n};\n#endif\n\nvoid dce_aud_destroy(struct audio **audio)\n{\n\tstruct dce_audio *aud = DCE_AUD(*audio);\n\n\tkfree(aud);\n\t*audio = NULL;\n}\n\nstruct audio *dce_audio_create(\n\t\tstruct dc_context *ctx,\n\t\tunsigned int inst,\n\t\tconst struct dce_audio_registers *reg,\n\t\tconst struct dce_audio_shift *shifts,\n\t\tconst struct dce_audio_mask *masks\n\t\t)\n{\n\tstruct dce_audio *audio = kzalloc(sizeof(*audio), GFP_KERNEL);\n\n\tif (audio == NULL) {\n\t\tASSERT_CRITICAL(audio);\n\t\treturn NULL;\n\t}\n\n\taudio->base.ctx = ctx;\n\taudio->base.inst = inst;\n\taudio->base.funcs = &funcs;\n\n\taudio->regs = reg;\n\taudio->shifts = shifts;\n\taudio->masks = masks;\n\treturn &audio->base;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstruct audio *dce60_audio_create(\n\t\tstruct dc_context *ctx,\n\t\tunsigned int inst,\n\t\tconst struct dce_audio_registers *reg,\n\t\tconst struct dce_audio_shift *shifts,\n\t\tconst struct dce_audio_mask *masks\n\t\t)\n{\n\tstruct dce_audio *audio = kzalloc(sizeof(*audio), GFP_KERNEL);\n\n\tif (audio == NULL) {\n\t\tASSERT_CRITICAL(audio);\n\t\treturn NULL;\n\t}\n\n\taudio->base.ctx = ctx;\n\taudio->base.inst = inst;\n\taudio->base.funcs = &dce60_funcs;\n\n\taudio->regs = reg;\n\taudio->shifts = shifts;\n\taudio->masks = masks;\n\treturn &audio->base;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}