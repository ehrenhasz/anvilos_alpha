{
  "module_name": "dce112_compressor.c",
  "hash_id": "1efa05426e3f5c966ac3e9433e488f0c9d32e7e02da71fbc631d8580207f19c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce112/dce112_compressor.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"dce/dce_11_2_d.h\"\n#include \"dce/dce_11_2_sh_mask.h\"\n#include \"gmc/gmc_8_1_sh_mask.h\"\n#include \"gmc/gmc_8_1_d.h\"\n\n#include \"include/logger_interface.h\"\n\n#include \"dce112_compressor.h\"\n#define DC_LOGGER \\\n\t\tcp110->base.ctx->logger\n#define DCP_REG(reg)\\\n\t(reg + cp110->offsets.dcp_offset)\n#define DMIF_REG(reg)\\\n\t(reg + cp110->offsets.dmif_offset)\n\nstatic const struct dce112_compressor_reg_offsets reg_offsets[] = {\n{\n\t.dcp_offset = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG0_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n},\n{\n\t.dcp_offset = (mmDCP1_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG1_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n},\n{\n\t.dcp_offset = (mmDCP2_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n\t.dmif_offset =\n\t\t(mmDMIF_PG2_DPG_PIPE_DPM_CONTROL\n\t\t\t- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),\n}\n};\n\nstatic const uint32_t dce11_one_lpt_channel_max_resolution = 2560 * 1600;\n\nenum fbc_idle_force {\n\t \n\tFBC_IDLE_FORCE_DISPLAY_REGISTER_UPDATE = 0x00000001,\n\n\t \n\tFBC_IDLE_FORCE_GRPH_COMP_EN = 0x00000002,\n\t \n\tFBC_IDLE_FORCE_SRC_SEL_CHANGE = 0x00000004,\n\t \n\tFBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE = 0x00000008,\n\t \n\tFBC_IDLE_FORCE_ALPHA_COMP_EN = 0x00000010,\n\t \n\tFBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN = 0x00000020,\n\t \n\tFBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF = 0x00000040,\n\n\t \n\tFBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION0 = 0x01000000,\n\t \n\tFBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION1 = 0x02000000,\n\t \n\tFBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION2 = 0x04000000,\n\t \n\tFBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION3 = 0x08000000,\n\n\t \n\tFBC_IDLE_FORCE_MEMORY_WRITE_OTHER_THAN_MCIF = 0x10000000,\n\t \n\tFBC_IDLE_FORCE_CG_STATIC_SCREEN_IS_INACTIVE = 0x20000000,\n};\n\nstatic uint32_t lpt_size_alignment(struct dce112_compressor *cp110)\n{\n\t \n\treturn cp110->base.raw_size * cp110->base.banks_num *\n\t\tcp110->base.dram_channels_num;\n}\n\nstatic uint32_t lpt_memory_control_config(struct dce112_compressor *cp110,\n\tuint32_t lpt_control)\n{\n\t \n\tif (cp110->base.options.bits.LPT_MC_CONFIG == 1) {\n\t\t \n\t\tswitch (cp110->base.dram_channels_num) {\n\t\tcase 2:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t1,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_PIPES);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t0,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_PIPES);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDC_LOG_WARNING(\n\t\t\t\t\"%s: Invalid LPT NUM_PIPES!!!\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (cp110->base.banks_num) {\n\t\tcase 16:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t3,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_BANKS);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t2,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_BANKS);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t1,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_BANKS);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t0,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_NUM_BANKS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDC_LOG_WARNING(\n\t\t\t\t\"%s: Invalid LPT NUM_BANKS!!!\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (cp110->base.channel_interleave_size) {\n\t\tcase 256:  \n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t0,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);\n\t\t\tbreak;\n\t\tcase 512:  \n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t1,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDC_LOG_WARNING(\n\t\t\t\t\"%s: Invalid LPT INTERLEAVE_SIZE!!!\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (cp110->base.raw_size) {\n\t\tcase 4096:  \n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t2,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_ROW_SIZE);\n\t\t\tbreak;\n\t\tcase 2048:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t1,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_ROW_SIZE);\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\tset_reg_field_value(\n\t\t\t\tlpt_control,\n\t\t\t\t0,\n\t\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\t\tLOW_POWER_TILING_ROW_SIZE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDC_LOG_WARNING(\n\t\t\t\t\"%s: Invalid LPT ROW_SIZE!!!\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDC_LOG_WARNING(\n\t\t\t\"%s: LPT MC Configuration is not provided\",\n\t\t\t__func__);\n\t}\n\n\treturn lpt_control;\n}\n\nstatic bool is_source_bigger_than_epanel_size(\n\tstruct dce112_compressor *cp110,\n\tuint32_t source_view_width,\n\tuint32_t source_view_height)\n{\n\tif (cp110->base.embedded_panel_h_size != 0 &&\n\t\tcp110->base.embedded_panel_v_size != 0 &&\n\t\t((source_view_width * source_view_height) >\n\t\t(cp110->base.embedded_panel_h_size *\n\t\t\tcp110->base.embedded_panel_v_size)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic uint32_t align_to_chunks_number_per_line(\n\tstruct dce112_compressor *cp110,\n\tuint32_t pixels)\n{\n\treturn 256 * ((pixels + 255) / 256);\n}\n\nstatic void wait_for_fbc_state_changed(\n\tstruct dce112_compressor *cp110,\n\tbool enabled)\n{\n\tuint8_t counter = 0;\n\tuint32_t addr = mmFBC_STATUS;\n\tuint32_t value;\n\n\twhile (counter < 10) {\n\t\tvalue = dm_read_reg(cp110->base.ctx, addr);\n\t\tif (get_reg_field_value(\n\t\t\tvalue,\n\t\t\tFBC_STATUS,\n\t\t\tFBC_ENABLE_STATUS) == enabled)\n\t\t\tbreak;\n\t\tudelay(10);\n\t\tcounter++;\n\t}\n\n\tif (counter == 10) {\n\t\tDC_LOG_WARNING(\n\t\t\t\"%s: wait counter exceeded, changes to HW not applied\",\n\t\t\t__func__);\n\t}\n}\n\nvoid dce112_compressor_power_up_fbc(struct compressor *compressor)\n{\n\tuint32_t value;\n\tuint32_t addr;\n\n\taddr = mmFBC_CNTL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\tset_reg_field_value(value, 1, FBC_CNTL, FBC_EN);\n\tset_reg_field_value(value, 2, FBC_CNTL, FBC_COHERENCY_MODE);\n\tif (compressor->options.bits.CLK_GATING_DISABLED == 1) {\n\t\t \n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tFBC_CNTL,\n\t\t\tFBC_COMP_CLK_GATE_EN);\n\t}\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\taddr = mmFBC_COMP_MODE;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_RLE_EN);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_DPCM4_RGB_EN);\n\tset_reg_field_value(value, 1, FBC_COMP_MODE, FBC_IND_EN);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\taddr = mmFBC_COMP_CNTL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(value, 1, FBC_COMP_CNTL, FBC_DEPTH_RGB08_EN);\n\tdm_write_reg(compressor->ctx, addr, value);\n\t \n\t \n\t \n\t \n\tset_reg_field_value(value, 0xF, FBC_COMP_CNTL, FBC_MIN_COMPRESSION);\n\tdm_write_reg(compressor->ctx, addr, value);\n\tcompressor->min_compress_ratio = FBC_COMPRESS_RATIO_1TO1;\n\n\tvalue = 0;\n\tdm_write_reg(compressor->ctx, mmFBC_IND_LUT0, value);\n\n\tvalue = 0xFFFFFF;\n\tdm_write_reg(compressor->ctx, mmFBC_IND_LUT1, value);\n}\n\nvoid dce112_compressor_enable_fbc(\n\tstruct compressor *compressor,\n\tuint32_t paths_num,\n\tstruct compr_addr_and_pitch_params *params)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\n\tif (compressor->options.bits.FBC_SUPPORT &&\n\t\t(compressor->options.bits.DUMMY_BACKEND == 0) &&\n\t\t(!dce112_compressor_is_fbc_enabled_in_hw(compressor, NULL)) &&\n\t\t(!is_source_bigger_than_epanel_size(\n\t\t\tcp110,\n\t\t\tparams->source_view_width,\n\t\t\tparams->source_view_height))) {\n\n\t\tuint32_t addr;\n\t\tuint32_t value;\n\n\t\t \n\t\tif (compressor->options.bits.LPT_SUPPORT && (paths_num < 2) &&\n\t\t\t(params->source_view_width *\n\t\t\t\tparams->source_view_height <=\n\t\t\t\tdce11_one_lpt_channel_max_resolution)) {\n\t\t\tdce112_compressor_enable_lpt(compressor);\n\t\t}\n\n\t\taddr = mmFBC_CNTL;\n\t\tvalue = dm_read_reg(compressor->ctx, addr);\n\t\tset_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tparams->inst,\n\t\t\tFBC_CNTL, FBC_SRC_SEL);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\n\t\t \n\t\tcompressor->is_enabled = true;\n\t\tcompressor->attached_inst = params->inst;\n\t\tcp110->offsets = reg_offsets[params->inst];\n\n\t\t \n\t\tset_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\t\tset_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tdm_write_reg(compressor->ctx, addr, value);\n\n\t\twait_for_fbc_state_changed(cp110, true);\n\t}\n}\n\nvoid dce112_compressor_disable_fbc(struct compressor *compressor)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\n\tif (compressor->options.bits.FBC_SUPPORT &&\n\t\tdce112_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {\n\t\tuint32_t reg_data;\n\t\t \n\t\treg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);\n\t\tset_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);\n\t\tdm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);\n\n\t\t \n\t\tcompressor->attached_inst = 0;\n\t\tcompressor->is_enabled = false;\n\n\t\t \n\t\tif (compressor->options.bits.LPT_SUPPORT)\n\t\t\tdce112_compressor_disable_lpt(compressor);\n\n\t\twait_for_fbc_state_changed(cp110, false);\n\t}\n}\n\nbool dce112_compressor_is_fbc_enabled_in_hw(\n\tstruct compressor *compressor,\n\tuint32_t *inst)\n{\n\t \n\tuint32_t value;\n\n\tvalue = dm_read_reg(compressor->ctx, mmFBC_STATUS);\n\tif (get_reg_field_value(value, FBC_STATUS, FBC_ENABLE_STATUS)) {\n\t\tif (inst != NULL)\n\t\t\t*inst = compressor->attached_inst;\n\t\treturn true;\n\t}\n\n\tvalue = dm_read_reg(compressor->ctx, mmFBC_MISC);\n\tif (get_reg_field_value(value, FBC_MISC, FBC_STOP_ON_HFLIP_EVENT)) {\n\t\tvalue = dm_read_reg(compressor->ctx, mmFBC_CNTL);\n\n\t\tif (get_reg_field_value(value, FBC_CNTL, FBC_GRPH_COMP_EN)) {\n\t\t\tif (inst != NULL)\n\t\t\t\t*inst =\n\t\t\t\t\tcompressor->attached_inst;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool dce112_compressor_is_lpt_enabled_in_hw(struct compressor *compressor)\n{\n\t \n\tuint32_t value = dm_read_reg(compressor->ctx,\n\t\tmmLOW_POWER_TILING_CONTROL);\n\n\treturn get_reg_field_value(\n\t\tvalue,\n\t\tLOW_POWER_TILING_CONTROL,\n\t\tLOW_POWER_TILING_ENABLE);\n}\n\nvoid dce112_compressor_program_compressed_surface_address_and_pitch(\n\tstruct compressor *compressor,\n\tstruct compr_addr_and_pitch_params *params)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\tuint32_t value = 0;\n\tuint32_t fbc_pitch = 0;\n\tuint32_t compressed_surf_address_low_part =\n\t\tcompressor->compr_surface_address.addr.low_part;\n\n\t \n\tdm_write_reg(\n\t\tcompressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),\n\t\t0);\n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS), 0);\n\n\tif (compressor->options.bits.LPT_SUPPORT) {\n\t\tuint32_t lpt_alignment = lpt_size_alignment(cp110);\n\n\t\tif (lpt_alignment != 0) {\n\t\t\tcompressed_surf_address_low_part =\n\t\t\t\t((compressed_surf_address_low_part\n\t\t\t\t\t+ (lpt_alignment - 1)) / lpt_alignment)\n\t\t\t\t\t* lpt_alignment;\n\t\t}\n\t}\n\n\t \n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),\n\t\tcompressor->compr_surface_address.addr.high_part);\n\tdm_write_reg(compressor->ctx,\n\t\tDCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS),\n\t\tcompressed_surf_address_low_part);\n\n\tfbc_pitch = align_to_chunks_number_per_line(\n\t\tcp110,\n\t\tparams->source_view_width);\n\n\tif (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)\n\t\tfbc_pitch = fbc_pitch / 8;\n\telse\n\t\tDC_LOG_WARNING(\n\t\t\t\"%s: Unexpected DCE11 compression ratio\",\n\t\t\t__func__);\n\n\t \n\tdm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), 0);\n\n\t \n\tset_reg_field_value(\n\t\tvalue,\n\t\tfbc_pitch,\n\t\tGRPH_COMPRESS_PITCH,\n\t\tGRPH_COMPRESS_PITCH);\n\tdm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), value);\n\n}\n\nvoid dce112_compressor_disable_lpt(struct compressor *compressor)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\tuint32_t value;\n\tuint32_t addr;\n\tuint32_t inx;\n\n\t \n\tfor (inx = 0; inx < 3; inx++) {\n\t\tvalue =\n\t\t\tdm_read_reg(\n\t\t\t\tcompressor->ctx,\n\t\t\t\tDMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tDPG_PIPE_STUTTER_CONTROL_NONLPTCH,\n\t\t\tSTUTTER_ENABLE_NONLPTCH);\n\t\tdm_write_reg(\n\t\t\tcompressor->ctx,\n\t\t\tDMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH),\n\t\t\tvalue);\n\t}\n\t \n\taddr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,\n\t\tSTUTTER_ENABLE_NONLPTCH);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmLOW_POWER_TILING_CONTROL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tLOW_POWER_TILING_CONTROL,\n\t\tLOW_POWER_TILING_ENABLE);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmGMCON_LPT_TARGET;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0xFFFFFFFF,\n\t\tGMCON_LPT_TARGET,\n\t\tSTCTRL_LPT_TARGET);\n\tdm_write_reg(compressor->ctx, mmGMCON_LPT_TARGET, value);\n}\n\nvoid dce112_compressor_enable_lpt(struct compressor *compressor)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\tuint32_t value;\n\tuint32_t addr;\n\tuint32_t value_control;\n\tuint32_t channels;\n\n\t \n\tvalue = dm_read_reg(compressor->ctx,\n\t\tDMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tDPG_PIPE_STUTTER_CONTROL_NONLPTCH,\n\t\tSTUTTER_ENABLE_NONLPTCH);\n\tdm_write_reg(compressor->ctx,\n\t\tDMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH), value);\n\n\t \n\taddr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,\n\t\tSTUTTER_ENABLE_NONLPTCH);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmLOW_POWER_TILING_CONTROL;\n\tvalue_control = dm_read_reg(compressor->ctx, addr);\n\tchannels = get_reg_field_value(value_control,\n\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\tLOW_POWER_TILING_MODE);\n\n\taddr = mmGMCON_LPT_TARGET;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tchannels + 1,  \n\t\tGMCON_LPT_TARGET,\n\t\tSTCTRL_LPT_TARGET);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmLOW_POWER_TILING_CONTROL;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tLOW_POWER_TILING_CONTROL,\n\t\tLOW_POWER_TILING_ENABLE);\n\tdm_write_reg(compressor->ctx, addr, value);\n}\n\nvoid dce112_compressor_program_lpt_control(\n\tstruct compressor *compressor,\n\tstruct compr_addr_and_pitch_params *params)\n{\n\tstruct dce112_compressor *cp110 = TO_DCE112_COMPRESSOR(compressor);\n\tuint32_t rows_per_channel;\n\tuint32_t lpt_alignment;\n\tuint32_t source_view_width;\n\tuint32_t source_view_height;\n\tuint32_t lpt_control = 0;\n\n\tif (!compressor->options.bits.LPT_SUPPORT)\n\t\treturn;\n\n\tlpt_control = dm_read_reg(compressor->ctx,\n\t\tmmLOW_POWER_TILING_CONTROL);\n\n\t \n\tswitch (compressor->lpt_channels_num) {\n\t \n\tcase 1:\n\t\t \n\t\tset_reg_field_value(\n\t\t\tlpt_control,\n\t\t\t0,\n\t\t\tLOW_POWER_TILING_CONTROL,\n\t\t\tLOW_POWER_TILING_MODE);\n\t\tbreak;\n\tdefault:\n\t\tDC_LOG_WARNING(\n\t\t\t\"%s: Invalid selected DRAM channels for LPT!!!\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\tlpt_control = lpt_memory_control_config(cp110, lpt_control);\n\n\t \n\trows_per_channel = 0;\n\tlpt_alignment = lpt_size_alignment(cp110);\n\tsource_view_width =\n\t\talign_to_chunks_number_per_line(\n\t\t\tcp110,\n\t\t\tparams->source_view_width);\n\tsource_view_height = (params->source_view_height + 1) & (~0x1);\n\n\tif (lpt_alignment != 0) {\n\t\trows_per_channel = source_view_width * source_view_height * 4;\n\t\trows_per_channel =\n\t\t\t(rows_per_channel % lpt_alignment) ?\n\t\t\t\t(rows_per_channel / lpt_alignment + 1) :\n\t\t\t\trows_per_channel / lpt_alignment;\n\t}\n\n\tset_reg_field_value(\n\t\tlpt_control,\n\t\trows_per_channel,\n\t\tLOW_POWER_TILING_CONTROL,\n\t\tLOW_POWER_TILING_ROWS_PER_CHAN);\n\n\tdm_write_reg(compressor->ctx,\n\t\tmmLOW_POWER_TILING_CONTROL, lpt_control);\n}\n\n \n\nvoid dce112_compressor_set_fbc_invalidation_triggers(\n\tstruct compressor *compressor,\n\tuint32_t fbc_trigger)\n{\n\t \n\tuint32_t addr = mmFBC_CLIENT_REGION_MASK;\n\tuint32_t value = dm_read_reg(compressor->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tFBC_CLIENT_REGION_MASK,\n\t\tFBC_MEMORY_REGION_MASK);\n\tdm_write_reg(compressor->ctx, addr, value);\n\n\t \n\taddr = mmFBC_IDLE_FORCE_CLEAR_MASK;\n\tvalue = dm_read_reg(compressor->ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tfbc_trigger |\n\t\tFBC_IDLE_FORCE_GRPH_COMP_EN |\n\t\tFBC_IDLE_FORCE_SRC_SEL_CHANGE |\n\t\tFBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE |\n\t\tFBC_IDLE_FORCE_ALPHA_COMP_EN |\n\t\tFBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN |\n\t\tFBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF,\n\t\tFBC_IDLE_FORCE_CLEAR_MASK,\n\t\tFBC_IDLE_FORCE_CLEAR_MASK);\n\tdm_write_reg(compressor->ctx, addr, value);\n}\n\nvoid dce112_compressor_construct(struct dce112_compressor *compressor,\n\tstruct dc_context *ctx)\n{\n\tstruct dc_bios *bp = ctx->dc_bios;\n\tstruct embedded_panel_info panel_info;\n\n\tcompressor->base.options.raw = 0;\n\tcompressor->base.options.bits.FBC_SUPPORT = true;\n\tcompressor->base.options.bits.LPT_SUPPORT = true;\n\t  \n\tcompressor->base.lpt_channels_num = 1;\n\tcompressor->base.options.bits.DUMMY_BACKEND = false;\n\n\t \n\tif (compressor->base.memory_bus_width == 64)\n\t\tcompressor->base.options.bits.LPT_SUPPORT = false;\n\n\tcompressor->base.options.bits.CLK_GATING_DISABLED = false;\n\n\tcompressor->base.ctx = ctx;\n\tcompressor->base.embedded_panel_h_size = 0;\n\tcompressor->base.embedded_panel_v_size = 0;\n\tcompressor->base.memory_bus_width = ctx->asic_id.vram_width;\n\tcompressor->base.allocated_size = 0;\n\tcompressor->base.preferred_requested_size = 0;\n\tcompressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;\n\tcompressor->base.banks_num = 0;\n\tcompressor->base.raw_size = 0;\n\tcompressor->base.channel_interleave_size = 0;\n\tcompressor->base.dram_channels_num = 0;\n\tcompressor->base.lpt_channels_num = 0;\n\tcompressor->base.attached_inst = 0;\n\tcompressor->base.is_enabled = false;\n\n\tif (BP_RESULT_OK ==\n\t\t\tbp->funcs->get_embedded_panel_info(bp, &panel_info)) {\n\t\tcompressor->base.embedded_panel_h_size =\n\t\t\tpanel_info.lcd_timing.horizontal_addressable;\n\t\tcompressor->base.embedded_panel_v_size =\n\t\t\tpanel_info.lcd_timing.vertical_addressable;\n\t}\n}\n\nstruct compressor *dce112_compressor_create(struct dc_context *ctx)\n{\n\tstruct dce112_compressor *cp110 =\n\t\tkzalloc(sizeof(struct dce112_compressor), GFP_KERNEL);\n\n\tif (!cp110)\n\t\treturn NULL;\n\n\tdce112_compressor_construct(cp110, ctx);\n\treturn &cp110->base;\n}\n\nvoid dce112_compressor_destroy(struct compressor **compressor)\n{\n\tkfree(TO_DCE112_COMPRESSOR(*compressor));\n\t*compressor = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}