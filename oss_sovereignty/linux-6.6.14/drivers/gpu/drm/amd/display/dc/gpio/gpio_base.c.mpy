{
  "module_name": "gpio_base.c",
  "hash_id": "dc44dd4221ec250c0e7b5dcf8a7da20f1ec9291b4f7499252ba63c75dbfb4b18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/gpio/gpio_base.c",
  "human_readable_source": " \n\n \n\n#include \"dm_services.h\"\n\n#include \"include/gpio_interface.h\"\n#include \"include/gpio_service_interface.h\"\n#include \"hw_gpio.h\"\n#include \"hw_translate.h\"\n#include \"hw_factory.h\"\n#include \"gpio_service.h\"\n\n \n\n \n\n \n\nenum gpio_result dal_gpio_open(\n\tstruct gpio *gpio,\n\tenum gpio_mode mode)\n{\n\treturn dal_gpio_open_ex(gpio, mode);\n}\n\nenum gpio_result dal_gpio_open_ex(\n\tstruct gpio *gpio,\n\tenum gpio_mode mode)\n{\n\tif (gpio->pin) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_ALREADY_OPENED;\n\t}\n\n\t\n\tif (!gpio->hw_container.ddc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n\tgpio->mode = mode;\n\n\treturn dal_gpio_service_open(gpio);\n}\n\nenum gpio_result dal_gpio_get_value(\n\tconst struct gpio *gpio,\n\tuint32_t *value)\n{\n\tif (!gpio->pin) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_NULL_HANDLE;\n\t}\n\n\treturn gpio->pin->funcs->get_value(gpio->pin, value);\n}\n\nenum gpio_result dal_gpio_set_value(\n\tconst struct gpio *gpio,\n\tuint32_t value)\n{\n\tif (!gpio->pin) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_NULL_HANDLE;\n\t}\n\n\treturn gpio->pin->funcs->set_value(gpio->pin, value);\n}\n\nenum gpio_mode dal_gpio_get_mode(\n\tconst struct gpio *gpio)\n{\n\treturn gpio->mode;\n}\n\nenum gpio_result dal_gpio_lock_pin(\n\tstruct gpio *gpio)\n{\n\treturn dal_gpio_service_lock(gpio->service, gpio->id, gpio->en);\n}\n\nenum gpio_result dal_gpio_unlock_pin(\n\tstruct gpio *gpio)\n{\n\treturn dal_gpio_service_unlock(gpio->service, gpio->id, gpio->en);\n}\n\nenum gpio_result dal_gpio_change_mode(\n\tstruct gpio *gpio,\n\tenum gpio_mode mode)\n{\n\tif (!gpio->pin) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_NULL_HANDLE;\n\t}\n\n\treturn gpio->pin->funcs->change_mode(gpio->pin, mode);\n}\n\nenum gpio_id dal_gpio_get_id(\n\tconst struct gpio *gpio)\n{\n\treturn gpio->id;\n}\n\nuint32_t dal_gpio_get_enum(\n\tconst struct gpio *gpio)\n{\n\treturn gpio->en;\n}\n\nenum gpio_result dal_gpio_set_config(\n\tstruct gpio *gpio,\n\tconst struct gpio_config_data *config_data)\n{\n\tif (!gpio->pin) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn GPIO_RESULT_NULL_HANDLE;\n\t}\n\n\treturn gpio->pin->funcs->set_config(gpio->pin, config_data);\n}\n\nenum gpio_result dal_gpio_get_pin_info(\n\tconst struct gpio *gpio,\n\tstruct gpio_pin_info *pin_info)\n{\n\treturn gpio->service->translate.funcs->id_to_offset(\n\t\tgpio->id, gpio->en, pin_info) ?\n\t\tGPIO_RESULT_OK : GPIO_RESULT_INVALID_DATA;\n}\n\nenum sync_source dal_gpio_get_sync_source(\n\tconst struct gpio *gpio)\n{\n\tswitch (gpio->id) {\n\tcase GPIO_ID_GENERIC:\n\t\tswitch (gpio->en) {\n\t\tcase GPIO_GENERIC_A:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_A;\n\t\tcase GPIO_GENERIC_B:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_B;\n\t\tcase GPIO_GENERIC_C:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_C;\n\t\tcase GPIO_GENERIC_D:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_D;\n\t\tcase GPIO_GENERIC_E:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_E;\n\t\tcase GPIO_GENERIC_F:\n\t\t\treturn SYNC_SOURCE_IO_GENERIC_F;\n\t\tdefault:\n\t\t\treturn SYNC_SOURCE_NONE;\n\t\t}\n\tbreak;\n\tcase GPIO_ID_SYNC:\n\t\tswitch (gpio->en) {\n\t\tcase GPIO_SYNC_HSYNC_A:\n\t\t\treturn SYNC_SOURCE_IO_HSYNC_A;\n\t\tcase GPIO_SYNC_VSYNC_A:\n\t\t\treturn SYNC_SOURCE_IO_VSYNC_A;\n\t\tcase GPIO_SYNC_HSYNC_B:\n\t\t\treturn SYNC_SOURCE_IO_HSYNC_B;\n\t\tcase GPIO_SYNC_VSYNC_B:\n\t\t\treturn SYNC_SOURCE_IO_VSYNC_B;\n\t\tdefault:\n\t\t\treturn SYNC_SOURCE_NONE;\n\t\t}\n\tbreak;\n\tcase GPIO_ID_HPD:\n\t\tswitch (gpio->en) {\n\t\tcase GPIO_HPD_1:\n\t\t\treturn SYNC_SOURCE_IO_HPD1;\n\t\tcase GPIO_HPD_2:\n\t\t\treturn SYNC_SOURCE_IO_HPD2;\n\t\tdefault:\n\t\t\treturn SYNC_SOURCE_NONE;\n\t\t}\n\tbreak;\n\tcase GPIO_ID_GSL:\n\t\tswitch (gpio->en) {\n\t\tcase GPIO_GSL_GENLOCK_CLOCK:\n\t\t\treturn SYNC_SOURCE_GSL_IO_GENLOCK_CLOCK;\n\t\tcase GPIO_GSL_GENLOCK_VSYNC:\n\t\t\treturn SYNC_SOURCE_GSL_IO_GENLOCK_VSYNC;\n\t\tcase GPIO_GSL_SWAPLOCK_A:\n\t\t\treturn SYNC_SOURCE_GSL_IO_SWAPLOCK_A;\n\t\tcase GPIO_GSL_SWAPLOCK_B:\n\t\t\treturn SYNC_SOURCE_GSL_IO_SWAPLOCK_B;\n\t\tdefault:\n\t\t\treturn SYNC_SOURCE_NONE;\n\t\t}\n\tbreak;\n\tdefault:\n\t\treturn SYNC_SOURCE_NONE;\n\t}\n}\n\nenum gpio_pin_output_state dal_gpio_get_output_state(\n\tconst struct gpio *gpio)\n{\n\treturn gpio->output_state;\n}\n\nstruct hw_ddc *dal_gpio_get_ddc(struct gpio *gpio)\n{\n\treturn gpio->hw_container.ddc;\n}\n\nstruct hw_hpd *dal_gpio_get_hpd(struct gpio *gpio)\n{\n\treturn gpio->hw_container.hpd;\n}\n\nstruct hw_generic *dal_gpio_get_generic(struct gpio *gpio)\n{\n\treturn gpio->hw_container.generic;\n}\n\nvoid dal_gpio_close(\n\tstruct gpio *gpio)\n{\n\tif (!gpio)\n\t\treturn;\n\n\tdal_gpio_service_close(gpio->service, &gpio->pin);\n\n\tgpio->mode = GPIO_MODE_UNKNOWN;\n}\n\n \n\nstruct gpio *dal_gpio_create(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en,\n\tenum gpio_pin_output_state output_state)\n{\n\tstruct gpio *gpio = kzalloc(sizeof(struct gpio), GFP_KERNEL);\n\n\tif (!gpio) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn NULL;\n\t}\n\n\tgpio->service = service;\n\tgpio->pin = NULL;\n\tgpio->id = id;\n\tgpio->en = en;\n\tgpio->mode = GPIO_MODE_UNKNOWN;\n\tgpio->output_state = output_state;\n\n\t\n\tswitch (gpio->id) {\n\tcase GPIO_ID_DDC_DATA:\n\t\tgpio->service->factory.funcs->init_ddc_data(&gpio->hw_container.ddc, service->ctx, id, en);\n\t\tbreak;\n\tcase GPIO_ID_DDC_CLOCK:\n\t\tgpio->service->factory.funcs->init_ddc_data(&gpio->hw_container.ddc, service->ctx, id, en);\n\t\tbreak;\n\tcase GPIO_ID_GENERIC:\n\t\tgpio->service->factory.funcs->init_generic(&gpio->hw_container.generic, service->ctx, id, en);\n\t\tbreak;\n\tcase GPIO_ID_HPD:\n\t\tgpio->service->factory.funcs->init_hpd(&gpio->hw_container.hpd, service->ctx, id, en);\n\t\tbreak;\n\t\n\tcase GPIO_ID_SYNC:\n\t\tbreak;\n\tcase GPIO_ID_GSL:\n\t\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tgpio->pin = NULL;\n\t}\n\n\treturn gpio;\n}\n\nvoid dal_gpio_destroy(\n\tstruct gpio **gpio)\n{\n\tif (!gpio || !*gpio) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tswitch ((*gpio)->id) {\n\tcase GPIO_ID_DDC_DATA:\n\t\tkfree((*gpio)->hw_container.ddc);\n\t\t(*gpio)->hw_container.ddc = NULL;\n\t\tbreak;\n\tcase GPIO_ID_DDC_CLOCK:\n\t\t\n\t\tkfree((*gpio)->hw_container.ddc);\n\t\t(*gpio)->hw_container.ddc = NULL;\n\t\tbreak;\n\tcase GPIO_ID_GENERIC:\n\t\tkfree((*gpio)->hw_container.generic);\n\t\t(*gpio)->hw_container.generic = NULL;\n\t\tbreak;\n\tcase GPIO_ID_HPD:\n\t\tkfree((*gpio)->hw_container.hpd);\n\t\t(*gpio)->hw_container.hpd = NULL;\n\t\tbreak;\n\t\n\tcase GPIO_ID_SYNC:\n\t\tbreak;\n\tcase GPIO_ID_GSL:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(*gpio);\n\n\t*gpio = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}