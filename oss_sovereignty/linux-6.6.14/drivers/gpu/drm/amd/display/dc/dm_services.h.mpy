{
  "module_name": "dm_services.h",
  "hash_id": "8ea6c51db7e318caf5e2d9ee754fbfc2a3b56b6bc31677ea7042529df6dd3bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dm_services.h",
  "human_readable_source": " \n\n \n\n#ifndef __DM_SERVICES_H__\n\n#define __DM_SERVICES_H__\n\n \n#include \"dm_services_types.h\"\n#include \"logger_interface.h\"\n#include \"link_service_types.h\"\n\n#undef DEPRECATED\n\nstruct dmub_srv;\nstruct dc_dmub_srv;\nunion dmub_rb_cmd;\n\nirq_handler_idx dm_register_interrupt(\n\tstruct dc_context *ctx,\n\tstruct dc_interrupt_params *int_params,\n\tinterrupt_handler ih,\n\tvoid *handler_args);\n\n \nuint32_t dm_read_reg_func(const struct dc_context *ctx, uint32_t address,\n\t\t\t  const char *func_name);\n\n \n \n\nvoid dm_write_reg_func(const struct dc_context *ctx, uint32_t address,\n\t\t       uint32_t value, const char *func_name);\n\n#define dm_read_reg(ctx, address)\t\\\n\tdm_read_reg_func(ctx, address, __func__)\n\n#define dm_write_reg(ctx, address, value)\t\\\n\tdm_write_reg_func(ctx, address, value, __func__)\n\nstatic inline uint32_t dm_read_index_reg(\n\tconst struct dc_context *ctx,\n\tenum cgs_ind_reg addr_space,\n\tuint32_t index)\n{\n\treturn cgs_read_ind_register(ctx->cgs_device, addr_space, index);\n}\n\nstatic inline void dm_write_index_reg(\n\tconst struct dc_context *ctx,\n\tenum cgs_ind_reg addr_space,\n\tuint32_t index,\n\tuint32_t value)\n{\n\tcgs_write_ind_register(ctx->cgs_device, addr_space, index, value);\n}\n\nstatic inline uint32_t get_reg_field_value_ex(\n\tuint32_t reg_value,\n\tuint32_t mask,\n\tuint8_t shift)\n{\n\treturn (mask & reg_value) >> shift;\n}\n\n#define get_reg_field_value(reg_value, reg_name, reg_field)\\\n\tget_reg_field_value_ex(\\\n\t\t(reg_value),\\\n\t\treg_name ## __ ## reg_field ## _MASK,\\\n\t\treg_name ## __ ## reg_field ## __SHIFT)\n\nstatic inline uint32_t set_reg_field_value_ex(\n\tuint32_t reg_value,\n\tuint32_t value,\n\tuint32_t mask,\n\tuint8_t shift)\n{\n\tASSERT(mask != 0);\n\treturn (reg_value & ~mask) | (mask & (value << shift));\n}\n\n#define set_reg_field_value(reg_value, value, reg_name, reg_field)\\\n\t(reg_value) = set_reg_field_value_ex(\\\n\t\t(reg_value),\\\n\t\t(value),\\\n\t\treg_name ## __ ## reg_field ## _MASK,\\\n\t\treg_name ## __ ## reg_field ## __SHIFT)\n\nuint32_t generic_reg_set_ex(const struct dc_context *ctx,\n\t\tuint32_t addr, uint32_t reg_val, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1, ...);\n\nuint32_t generic_reg_update_ex(const struct dc_context *ctx,\n\t\tuint32_t addr, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1, ...);\n\nstruct dc_dmub_srv *dc_dmub_srv_create(struct dc *dc, struct dmub_srv *dmub);\nvoid dc_dmub_srv_destroy(struct dc_dmub_srv **dmub_srv);\n\nvoid reg_sequence_start_gather(const struct dc_context *ctx);\nvoid reg_sequence_start_execute(const struct dc_context *ctx);\nvoid reg_sequence_wait_done(const struct dc_context *ctx);\n\n#define FD(reg_field)\treg_field ## __SHIFT, \\\n\t\t\t\t\t\treg_field ## _MASK\n\n \nvoid generic_reg_wait(const struct dc_context *ctx,\n\tuint32_t addr, uint32_t mask, uint32_t shift, uint32_t condition_value,\n\tunsigned int delay_between_poll_us, unsigned int time_out_num_tries,\n\tconst char *func_name, int line);\n\nunsigned int snprintf_count(char *pBuf, unsigned int bufSize, char *fmt, ...);\n\n \n#define dm_write_reg_soc15(ctx, reg, inst_offset, value)\t\\\n\t\tdm_write_reg_func(ctx, reg + DCE_BASE.instance[0].segment[reg##_BASE_IDX] + inst_offset, value, __func__)\n\n#define dm_read_reg_soc15(ctx, reg, inst_offset)\t\\\n\t\tdm_read_reg_func(ctx, reg + DCE_BASE.instance[0].segment[reg##_BASE_IDX] + inst_offset, __func__)\n\n#define generic_reg_update_soc15(ctx, inst_offset, reg_name, n, ...)\\\n\t\tgeneric_reg_update_ex(ctx, DCE_BASE.instance[0].segment[mm##reg_name##_BASE_IDX] +  mm##reg_name + inst_offset, \\\n\t\tn, __VA_ARGS__)\n\n#define generic_reg_set_soc15(ctx, inst_offset, reg_name, n, ...)\\\n\t\tgeneric_reg_set_ex(ctx, DCE_BASE.instance[0].segment[mm##reg_name##_BASE_IDX] + mm##reg_name + inst_offset, 0, \\\n\t\tn, __VA_ARGS__)\n\n#define get_reg_field_value_soc15(reg_value, block, reg_num, reg_name, reg_field)\\\n\tget_reg_field_value_ex(\\\n\t\t(reg_value),\\\n\t\tblock ## reg_num ## _ ## reg_name ## __ ## reg_field ## _MASK,\\\n\t\tblock ## reg_num ## _ ## reg_name ## __ ## reg_field ## __SHIFT)\n\n#define set_reg_field_value_soc15(reg_value, value, block, reg_num, reg_name, reg_field)\\\n\t(reg_value) = set_reg_field_value_ex(\\\n\t\t(reg_value),\\\n\t\t(value),\\\n\t\tblock ## reg_num ## _ ## reg_name ## __ ## reg_field ## _MASK,\\\n\t\tblock ## reg_num ## _ ## reg_name ## __ ## reg_field ## __SHIFT)\n\n \n\n \nbool dm_pp_get_clock_levels_by_type(\n\tconst struct dc_context *ctx,\n\tenum dm_pp_clock_type clk_type,\n\tstruct dm_pp_clock_levels *clk_level_info);\n\nbool dm_pp_get_clock_levels_by_type_with_latency(\n\tconst struct dc_context *ctx,\n\tenum dm_pp_clock_type clk_type,\n\tstruct dm_pp_clock_levels_with_latency *clk_level_info);\n\nbool dm_pp_get_clock_levels_by_type_with_voltage(\n\tconst struct dc_context *ctx,\n\tenum dm_pp_clock_type clk_type,\n\tstruct dm_pp_clock_levels_with_voltage *clk_level_info);\n\nbool dm_pp_notify_wm_clock_changes(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges);\n\nvoid dm_pp_get_funcs(struct dc_context *ctx,\n\t\tstruct pp_smu_funcs *funcs);\n\n \nbool dm_pp_apply_display_requirements(\n\tconst struct dc_context *ctx,\n\tconst struct dm_pp_display_configuration *pp_display_cfg);\n\nbool dm_pp_apply_power_level_change_request(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_power_level_change_request *level_change_req);\n\nbool dm_pp_apply_clock_for_voltage_request(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_clock_for_voltage_req *clock_for_voltage_req);\n\nbool dm_pp_get_static_clocks(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_static_clock_info *static_clk_info);\n\n \n\nstruct persistent_data_flag {\n\tbool save_per_link;\n\tbool save_per_edid;\n};\n\nbool dm_query_extended_brightness_caps\n\t(struct dc_context *ctx, enum dm_acpi_display_type display,\n\t\t\tstruct dm_acpi_atif_backlight_caps *pCaps);\n\nbool dm_dmcu_set_pipe(struct dc_context *ctx, unsigned int controller_id);\n\n \n#define dm_log_to_buffer(buffer, size, fmt, args)\\\n\tvsnprintf(buffer, size, fmt, args)\n\nstatic inline unsigned long long dm_get_timestamp(struct dc_context *ctx)\n{\n\treturn ktime_get_raw_ns();\n}\n\nunsigned long long dm_get_elapse_time_in_ns(struct dc_context *ctx,\n\t\tunsigned long long current_time_stamp,\n\t\tunsigned long long last_time_stamp);\n\n \nvoid dm_perf_trace_timestamp(const char *func_name, unsigned int line, struct dc_context *ctx);\n\n#define PERF_TRACE()\tdm_perf_trace_timestamp(__func__, __LINE__, CTX)\n#define PERF_TRACE_CTX(__CTX)\tdm_perf_trace_timestamp(__func__, __LINE__, __CTX)\n\n \nbool dm_execute_dmub_cmd(const struct dc_context *ctx, union dmub_rb_cmd *cmd, enum dm_dmub_wait_type wait_type);\nbool dm_execute_dmub_cmd_list(const struct dc_context *ctx, unsigned int count, union dmub_rb_cmd *cmd, enum dm_dmub_wait_type wait_type);\n\n \n\nvoid dm_dtn_log_begin(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx);\nvoid dm_dtn_log_append_v(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx,\n\tconst char *msg, ...);\nvoid dm_dtn_log_end(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx);\n\nchar *dce_version_to_string(const int version);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}