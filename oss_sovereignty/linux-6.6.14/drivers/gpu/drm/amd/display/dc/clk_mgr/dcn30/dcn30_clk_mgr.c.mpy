{
  "module_name": "dcn30_clk_mgr.c",
  "hash_id": "ec5c88ed1f4ae82af44d631a46d0922962ad6dbb8a3f0f0fe50146a3253c497e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr.c",
  "human_readable_source": " \n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n#include \"dcn30_clk_mgr_smu_msg.h\"\n#include \"dcn20/dcn20_clk_mgr.h\"\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dcn30/dcn30_clk_mgr.h\"\n#include \"dml/dcn30/dcn30_fpu.h\"\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n#include \"atomfirmware.h\"\n#include \"sienna_cichlid_ip_offset.h\"\n#include \"dcn/dcn_3_0_0_offset.h\"\n#include \"dcn/dcn_3_0_0_sh_mask.h\"\n#include \"nbio/nbio_7_4_offset.h\"\n#include \"dpcs/dpcs_3_0_0_offset.h\"\n#include \"dpcs/dpcs_3_0_0_sh_mask.h\"\n#include \"mmhub/mmhub_2_0_0_offset.h\"\n#include \"mmhub/mmhub_2_0_0_sh_mask.h\"\n#include \"dcn30_smu11_driver_if.h\"\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#define BASE_INNER(seg) DCN_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#undef CLK_SRI\n#define CLK_SRI(reg_name, block, inst)\\\n\t.reg_name = mm ## block ## _ ## reg_name\n\nstatic const struct clk_mgr_registers clk_mgr_regs = {\n\tCLK_REG_LIST_DCN3()\n};\n\nstatic const struct clk_mgr_shift clk_mgr_shift = {\n\tCLK_COMMON_MASK_SH_LIST_DCN20_BASE(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask clk_mgr_mask = {\n\tCLK_COMMON_MASK_SH_LIST_DCN20_BASE(_MASK)\n};\n\n\n \nstatic void dcn3_init_single_clock(struct clk_mgr_internal *clk_mgr, uint32_t clk, unsigned int *entry_0, unsigned int *num_levels)\n{\n\tunsigned int i;\n\tchar *entry_i = (char *)entry_0;\n\tuint32_t ret = dcn30_smu_get_dpm_freq_by_index(clk_mgr, clk, 0xFF);\n\n\tif (ret & (1 << 31))\n\t\t \n\t\t*num_levels = 2;\n\telse\n\t\t \n\t\t \n\t\t*num_levels = ret & 0xFF;\n\n\t \n\tfor (i = 0; i < *num_levels; i++) {\n\t\t*((unsigned int *)entry_i) = (dcn30_smu_get_dpm_freq_by_index(clk_mgr, clk, i) & 0xFFFF);\n\t\tentry_i += sizeof(clk_mgr->base.bw_params->clk_table.entries[0]);\n\t}\n}\n\nstatic void dcn3_build_wm_range_table(struct clk_mgr_internal *clk_mgr)\n{\n\tDC_FP_START();\n\tdcn3_fpu_build_wm_range_table(&clk_mgr->base);\n\tDC_FP_END();\n}\n\nvoid dcn3_init_clocks(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int num_levels;\n\n\tmemset(&(clk_mgr_base->clks), 0, sizeof(struct dc_clocks));\n\tclk_mgr_base->clks.p_state_change_support = true;\n\tclk_mgr_base->clks.prev_p_state_change_support = true;\n\tclk_mgr->smu_present = false;\n\n\tif (!clk_mgr_base->bw_params)\n\t\treturn;\n\n\tif (!clk_mgr_base->force_smu_not_present && dcn30_smu_get_smu_version(clk_mgr, &clk_mgr->smu_ver))\n\t\tclk_mgr->smu_present = true;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t\n\tdcn30_smu_check_driver_if_version(clk_mgr);\n\tdcn30_smu_check_msg_header_version(clk_mgr);\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_DCEFCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dcfclk_mhz,\n\t\t\t&num_levels);\n\tdcn30_smu_set_min_deep_sleep_dcef_clk(clk_mgr, 0);\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_DTBCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dtbclk_mhz,\n\t\t\t&num_levels);\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_SOCCLK,\n\t\t\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].socclk_mhz,\n\t\t\t\t\t&num_levels);\n\t\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_DISPCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dispclk_mhz,\n\t\t\t&num_levels);\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_PIXCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dppclk_mhz,\n\t\t\t&num_levels);\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_PHYCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].phyclk_mhz,\n\t\t\t&num_levels);\n\n\t \n\tclk_mgr_base->funcs->get_memclk_states_from_smu(clk_mgr_base);\n\n\t \n\tDC_FP_START();\n\tdcn3_build_wm_range_table(clk_mgr);\n\tDC_FP_END();\n}\n\nstatic int dcn30_get_vco_frequency_from_reg(struct clk_mgr_internal *clk_mgr)\n{\n\t \n\tstruct fixed31_32 pll_req;\n\t \n\tuint32_t pll_req_reg = REG_READ(CLK0_CLK_PLL_REQ);\n\n\t \n\tpll_req = dc_fixpt_from_int(pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_int);\n\tpll_req.value |= pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_frac;\n\n\t \n\tpll_req = dc_fixpt_mul_int(pll_req, clk_mgr->dfs_ref_freq_khz);\n\n\treturn dc_fixpt_floor(pll_req);\n}\n\nstatic void dcn3_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool enter_display_off = false;\n\tbool dpp_clock_lowered = false;\n\tbool update_pstate_unsupported_clk = false;\n\tstruct dmcu *dmcu = clk_mgr_base->ctx->dc->res_pool->dmcu;\n\tbool force_reset = false;\n\tbool update_uclk = false;\n\tbool p_state_change_support;\n\n\tif (dc->work_arounds.skip_clock_update || !clk_mgr->smu_present)\n\t\treturn;\n\n\tif (clk_mgr_base->clks.dispclk_khz == 0 ||\n\t\t\t(dc->debug.force_clock_mode & 0x1)) {\n\t\t \n\t\tforce_reset = true;\n\n\t\tdcn2_read_clocks_from_hw_dentist(clk_mgr_base);\n\n\t\t \n\t}\n\tdisplay_count = clk_mgr_helper_get_active_display_cnt(dc, context);\n\n\tif (display_count == 0)\n\t\tenter_display_off = true;\n\n\tif (enter_display_off == safe_to_lower)\n\t\tdcn30_smu_set_num_of_displays(clk_mgr, display_count);\n\n\tif (dc->debug.force_min_dcfclk_mhz > 0)\n\t\tnew_clocks->dcfclk_khz = (new_clocks->dcfclk_khz > (dc->debug.force_min_dcfclk_mhz * 1000)) ?\n\t\t\t\tnew_clocks->dcfclk_khz : (dc->debug.force_min_dcfclk_mhz * 1000);\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DCEFCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_khz));\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\tdcn30_smu_set_min_deep_sleep_dcef_clk(clk_mgr, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_deep_sleep_khz));\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->socclk_khz, clk_mgr_base->clks.socclk_khz))\n\t\t \n\t\tclk_mgr_base->clks.socclk_khz = new_clocks->socclk_khz;\n\n\tclk_mgr_base->clks.prev_p_state_change_support = clk_mgr_base->clks.p_state_change_support;\n\tp_state_change_support = new_clocks->p_state_change_support;\n\n\t\n\tif (dc->clk_mgr->dc_mode_softmax_enabled && safe_to_lower && !p_state_change_support) {\n\t\tif ((new_clocks->dramclk_khz <= dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000) !=\n\t\t\t\t(clk_mgr_base->clks.dramclk_khz <= dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000))\n\t\t\tupdate_pstate_unsupported_clk = true;\n\t}\n\n\tif (should_update_pstate_support(safe_to_lower, p_state_change_support, clk_mgr_base->clks.p_state_change_support) ||\n\t\t\tupdate_pstate_unsupported_clk) {\n\t\tclk_mgr_base->clks.p_state_change_support = p_state_change_support;\n\n\t\t \n\t\tif (!clk_mgr_base->clks.p_state_change_support) {\n\t\t\tif (dc->clk_mgr->dc_mode_softmax_enabled &&\n\t\t\t\tnew_clocks->dramclk_khz <= dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000)\n\t\t\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tdc->clk_mgr->bw_params->dc_mode_softmax_memclk);\n\t\t\telse\n\t\t\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[clk_mgr_base->bw_params->clk_table.num_entries - 1].memclk_mhz);\n\t\t}\n\t}\n\n\t \n\tif (should_set_clock(safe_to_lower, new_clocks->dramclk_khz, clk_mgr_base->clks.dramclk_khz)) {\n\t\tclk_mgr_base->clks.dramclk_khz = new_clocks->dramclk_khz;\n\t\tupdate_uclk = true;\n\t}\n\n\t \n\tif (clk_mgr_base->clks.p_state_change_support &&\n\t\t\t(update_uclk || !clk_mgr_base->clks.prev_p_state_change_support))\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dramclk_khz));\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr_base->clks.dppclk_khz)) {\n\t\tif (clk_mgr_base->clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\n\t\tclk_mgr_base->clks.dppclk_khz = new_clocks->dppclk_khz;\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_PIXCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dppclk_khz));\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DISPCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dispclk_khz));\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (dc->config.forced_clocks == false || (force_reset && safe_to_lower)) {\n\t\tif (dpp_clock_lowered) {\n\t\t\t \n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t} else {\n\t\t\t \n\t\t\tif (update_dppclk || update_dispclk)\n\t\t\t\tdcn20_update_clocks_update_dentist(clk_mgr, context);\n\t\t\t \n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t}\n\t}\n\n\tif (update_dispclk && dmcu && dmcu->funcs->is_dmcu_initialized(dmcu))\n\t\t \n\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\t\tclk_mgr_base->clks.dispclk_khz / 1000 / 7);\n}\n\n\nstatic void dcn3_notify_wm_ranges(struct clk_mgr *clk_mgr_base)\n{\n\tunsigned int i;\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tWatermarksExternal_t *table = (WatermarksExternal_t *) clk_mgr->wm_range_table;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (!table)\n\t\t\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\t \n\tfor (i = 0; i < WM_SET_COUNT; i++)\n\t\tif (clk_mgr->base.bw_params->wm_table.nv_entries[i].valid) {\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].MinClock = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.min_dcfclk;\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].MaxClock = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.max_dcfclk;\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].MinUclk = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.min_uclk;\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].MaxUclk = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.max_uclk;\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].WmSetting = i;\n\t\t\ttable->Watermarks.WatermarkRow[WM_DCEFCLK][i].Flags = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.wm_type;\n\t\t}\n\n\tdcn30_smu_set_dram_addr_high(clk_mgr, clk_mgr->wm_range_table_addr >> 32);\n\tdcn30_smu_set_dram_addr_low(clk_mgr, clk_mgr->wm_range_table_addr & 0xFFFFFFFF);\n\tdcn30_smu_transfer_wm_table_dram_2_smu(clk_mgr);\n}\n\n \nstatic void dcn3_set_hard_min_memclk(struct clk_mgr *clk_mgr_base, bool current_mode)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (current_mode) {\n\t\tif (clk_mgr_base->clks.p_state_change_support)\n\t\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tkhz_to_mhz_ceil(clk_mgr_base->clks.dramclk_khz));\n\t\telse\n\t\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[clk_mgr_base->bw_params->clk_table.num_entries - 1].memclk_mhz);\n\t} else {\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[0].memclk_mhz);\n\t}\n}\n\n \nstatic void dcn3_set_hard_max_memclk(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_set_hard_max_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\tclk_mgr_base->bw_params->clk_table.entries[clk_mgr_base->bw_params->clk_table.num_entries - 1].memclk_mhz);\n}\n\nstatic void dcn3_set_max_memclk(struct clk_mgr *clk_mgr_base, unsigned int memclk_mhz)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_set_hard_max_by_freq(clk_mgr, PPCLK_UCLK, memclk_mhz);\n}\nstatic void dcn3_set_min_memclk(struct clk_mgr *clk_mgr_base, unsigned int memclk_mhz)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK, memclk_mhz);\n}\n\n \nstatic void dcn3_get_memclk_states_from_smu(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int num_levels;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t \n\tdcn3_init_single_clock(clk_mgr, PPCLK_UCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].memclk_mhz,\n\t\t\t&num_levels);\n\tclk_mgr_base->bw_params->clk_table.num_entries = num_levels ? num_levels : 1;\n\n\tclk_mgr_base->bw_params->dc_mode_softmax_memclk = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_UCLK);\n\n\t \n\tDC_FP_START();\n\tclk_mgr_base->ctx->dc->res_pool->funcs->update_bw_bounding_box(\n\t\t\tclk_mgr->base.ctx->dc, clk_mgr_base->bw_params);\n\tDC_FP_END();\n}\n\nstatic bool dcn3_is_smu_present(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\treturn clk_mgr->smu_present;\n}\n\nstatic bool dcn3_are_clock_states_equal(struct dc_clocks *a,\n\t\t\t\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\telse if (a->dramclk_khz != b->dramclk_khz)\n\t\treturn false;\n\telse if (a->p_state_change_support != b->p_state_change_support)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void dcn3_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_set_pme_workaround(clk_mgr);\n}\n\n \nstatic void dcn30_notify_link_rate_change(struct clk_mgr *clk_mgr_base, struct dc_link *link)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int i, max_phyclk_req = clk_mgr_base->bw_params->clk_table.entries[0].phyclk_mhz * 1000;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t \n\n\tclk_mgr->cur_phyclk_req_table[link->link_index] = link->cur_link_settings.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;\n\n\tfor (i = 0; i < MAX_PIPES * 2; i++) {\n\t\tif (clk_mgr->cur_phyclk_req_table[i] > max_phyclk_req)\n\t\t\tmax_phyclk_req = clk_mgr->cur_phyclk_req_table[i];\n\t}\n\n\tif (max_phyclk_req != clk_mgr_base->clks.phyclk_khz) {\n\t\tclk_mgr_base->clks.phyclk_khz = max_phyclk_req;\n\t\tdcn30_smu_set_hard_min_by_freq(clk_mgr, PPCLK_PHYCLK, khz_to_mhz_ceil(clk_mgr_base->clks.phyclk_khz));\n\t}\n}\n\nstatic struct clk_mgr_funcs dcn3_funcs = {\n\t\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t\t.update_clocks = dcn3_update_clocks,\n\t\t.init_clocks = dcn3_init_clocks,\n\t\t.notify_wm_ranges = dcn3_notify_wm_ranges,\n\t\t.set_hard_min_memclk = dcn3_set_hard_min_memclk,\n\t\t.set_hard_max_memclk = dcn3_set_hard_max_memclk,\n\t\t.set_max_memclk = dcn3_set_max_memclk,\n\t\t.set_min_memclk = dcn3_set_min_memclk,\n\t\t.get_memclk_states_from_smu = dcn3_get_memclk_states_from_smu,\n\t\t.are_clock_states_equal = dcn3_are_clock_states_equal,\n\t\t.enable_pme_wa = dcn3_enable_pme_wa,\n\t\t.notify_link_rate_change = dcn30_notify_link_rate_change,\n\t\t.is_smu_present = dcn3_is_smu_present\n};\n\nstatic void dcn3_init_clocks_fpga(struct clk_mgr *clk_mgr)\n{\n\tdcn2_init_clocks(clk_mgr);\n\n \n}\n\nstruct clk_mgr_funcs dcn3_fpga_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = dcn2_update_clocks_fpga,\n\t.init_clocks = dcn3_init_clocks_fpga,\n};\n\n \nvoid dcn3_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct clk_state_registers_and_bypass s = { 0 };\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn3_funcs;\n\tclk_mgr->regs = &clk_mgr_regs;\n\tclk_mgr->clk_mgr_shift = &clk_mgr_shift;\n\tclk_mgr->clk_mgr_mask = &clk_mgr_mask;\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->dfs_ref_freq_khz = 100000;\n\n\tclk_mgr->base.dprefclk_khz = 730000; \n\n\t \n\tclk_mgr->base.dentist_vco_freq_khz = dcn30_get_vco_frequency_from_reg(clk_mgr);\n\n\t \n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 3650000;\n\t \n\t \n\n\t \n\t\n\tif (s.dprefclk != 0)\n\t\tclk_mgr->base.dprefclk_khz = s.dprefclk * 1000;\n\n\tclk_mgr->dfs_bypass_enabled = false;\n\n\tclk_mgr->smu_present = false;\n\n\tdce_clock_read_ss_info(clk_mgr);\n\n\tclk_mgr->base.bw_params = kzalloc(sizeof(*clk_mgr->base.bw_params), GFP_KERNEL);\n\n\t \n\tclk_mgr->wm_range_table = dm_helpers_allocate_gpu_mem(clk_mgr->base.ctx,\n\t\t\tDC_MEM_ALLOC_TYPE_GART, sizeof(WatermarksExternal_t),\n\t\t\t&clk_mgr->wm_range_table_addr);\n}\n\nvoid dcn3_clk_mgr_destroy(struct clk_mgr_internal *clk_mgr)\n{\n\tkfree(clk_mgr->base.bw_params);\n\n\tif (clk_mgr->wm_range_table)\n\t\tdm_helpers_free_gpu_mem(clk_mgr->base.ctx, DC_MEM_ALLOC_TYPE_GART,\n\t\t\t\tclk_mgr->wm_range_table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}