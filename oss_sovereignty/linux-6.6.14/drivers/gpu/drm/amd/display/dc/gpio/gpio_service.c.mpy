{
  "module_name": "gpio_service.c",
  "hash_id": "efbbbbe0e47e4e5da3a1b40b3f82abc149aaa8bc98d41d57f2a69bea192be016",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/gpio/gpio_service.c",
  "human_readable_source": " \n\n \n\n#include \"dm_services.h\"\n#include \"include/gpio_interface.h\"\n#include \"include/gpio_service_interface.h\"\n#include \"hw_translate.h\"\n#include \"hw_factory.h\"\n\n \n\n#include \"gpio_service.h\"\n\n \n\n#include \"hw_gpio.h\"\n\n \n\nstruct gpio_service *dal_gpio_service_create(\n\tenum dce_version dce_version,\n\tenum dce_environment dce_environment,\n\tstruct dc_context *ctx)\n{\n\tstruct gpio_service *service;\n\tuint32_t index_of_id;\n\n\tservice = kzalloc(sizeof(struct gpio_service), GFP_KERNEL);\n\n\tif (!service) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tif (!dal_hw_translate_init(&service->translate, dce_version,\n\t\t\tdce_environment)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto failure_1;\n\t}\n\n\tif (!dal_hw_factory_init(&service->factory, dce_version,\n\t\t\tdce_environment)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto failure_1;\n\t}\n\n\t \n\t{\n\t\tindex_of_id = 0;\n\t\tservice->ctx = ctx;\n\n\t\tdo {\n\t\t\tuint32_t number_of_bits =\n\t\t\t\tservice->factory.number_of_pins[index_of_id];\n\t\t\tuint32_t i = 0;\n\n\t\t\tif (number_of_bits)  {\n\t\t\t\tservice->busyness[index_of_id] =\n\t\t\t\t\tkcalloc(number_of_bits, sizeof(char),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\t\t\tif (!service->busyness[index_of_id]) {\n\t\t\t\t\tBREAK_TO_DEBUGGER();\n\t\t\t\t\tgoto failure_2;\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tservice->busyness[index_of_id][i] = 0;\n\t\t\t\t\t++i;\n\t\t\t\t} while (i < number_of_bits);\n\t\t\t} else {\n\t\t\t\tservice->busyness[index_of_id] = NULL;\n\t\t\t}\n\n\t\t\t++index_of_id;\n\t\t} while (index_of_id < GPIO_ID_COUNT);\n\t}\n\n\treturn service;\n\nfailure_2:\n\twhile (index_of_id) {\n\t\t--index_of_id;\n\t\tkfree(service->busyness[index_of_id]);\n\t}\n\nfailure_1:\n\tkfree(service);\n\n\treturn NULL;\n}\n\nstruct gpio *dal_gpio_service_create_irq(\n\tstruct gpio_service *service,\n\tuint32_t offset,\n\tuint32_t mask)\n{\n\tenum gpio_id id;\n\tuint32_t en;\n\n\tif (!service->translate.funcs->offset_to_id(offset, mask, &id, &en)) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn NULL;\n\t}\n\n\treturn dal_gpio_create_irq(service, id, en);\n}\n\nstruct gpio *dal_gpio_service_create_generic_mux(\n\tstruct gpio_service *service,\n\tuint32_t offset,\n\tuint32_t mask)\n{\n\tenum gpio_id id;\n\tuint32_t en;\n\tstruct gpio *generic;\n\n\tif (!service->translate.funcs->offset_to_id(offset, mask, &id, &en)) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn NULL;\n\t}\n\n\tgeneric = dal_gpio_create(\n\t\tservice, id, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);\n\n\treturn generic;\n}\n\nvoid dal_gpio_destroy_generic_mux(\n\tstruct gpio **mux)\n{\n\tif (!mux || !*mux) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tdal_gpio_destroy(mux);\n\tkfree(*mux);\n\n\t*mux = NULL;\n}\n\nstruct gpio_pin_info dal_gpio_get_generic_pin_info(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tstruct gpio_pin_info pin;\n\n\tif (service->translate.funcs->id_to_offset) {\n\t\tservice->translate.funcs->id_to_offset(id, en, &pin);\n\t} else {\n\t\tpin.mask = 0xFFFFFFFF;\n\t\tpin.offset = 0xFFFFFFFF;\n\t}\n\n\treturn pin;\n}\n\nvoid dal_gpio_service_destroy(\n\tstruct gpio_service **ptr)\n{\n\tif (!ptr || !*ptr) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t \n\t{\n\t\tuint32_t index_of_id = 0;\n\n\t\tdo {\n\t\t\tkfree((*ptr)->busyness[index_of_id]);\n\n\t\t\t++index_of_id;\n\t\t} while (index_of_id < GPIO_ID_COUNT);\n\t}\n\n\tkfree(*ptr);\n\n\t*ptr = NULL;\n}\n\nenum gpio_result dal_mux_setup_config(\n\tstruct gpio *mux,\n\tstruct gpio_generic_mux_config *config)\n{\n\tstruct gpio_config_data config_data;\n\n\tif (!config)\n\t\treturn GPIO_RESULT_INVALID_DATA;\n\n\tconfig_data.config.generic_mux = *config;\n\tconfig_data.type = GPIO_CONFIG_TYPE_GENERIC_MUX;\n\n\treturn dal_gpio_set_config(mux, &config_data);\n}\n\n \n\nstatic bool is_pin_busy(\n\tconst struct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\treturn service->busyness[id][en];\n}\n\nstatic void set_pin_busy(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tservice->busyness[id][en] = true;\n}\n\nstatic void set_pin_free(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tservice->busyness[id][en] = false;\n}\n\nenum gpio_result dal_gpio_service_lock(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tif (!service->busyness[id]) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_OPEN_FAILED;\n\t}\n\n\tset_pin_busy(service, id, en);\n\treturn GPIO_RESULT_OK;\n}\n\nenum gpio_result dal_gpio_service_unlock(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tif (!service->busyness[id]) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_OPEN_FAILED;\n\t}\n\n\tset_pin_free(service, id, en);\n\treturn GPIO_RESULT_OK;\n}\n\nenum gpio_result dal_gpio_service_open(\n\tstruct gpio *gpio)\n{\n\tstruct gpio_service *service = gpio->service;\n\tenum gpio_id id = gpio->id;\n\tuint32_t en = gpio->en;\n\tenum gpio_mode mode = gpio->mode;\n\n\tstruct hw_gpio_pin **pin = &gpio->pin;\n\n\n\tif (!service->busyness[id]) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_OPEN_FAILED;\n\t}\n\n\tif (is_pin_busy(service, id, en)) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_DEVICE_BUSY;\n\t}\n\n\tswitch (id) {\n\tcase GPIO_ID_DDC_DATA:\n\t\t*pin = service->factory.funcs->get_ddc_pin(gpio);\n\t\tservice->factory.funcs->define_ddc_registers(*pin, en);\n\tbreak;\n\tcase GPIO_ID_DDC_CLOCK:\n\t\t*pin = service->factory.funcs->get_ddc_pin(gpio);\n\t\tservice->factory.funcs->define_ddc_registers(*pin, en);\n\tbreak;\n\tcase GPIO_ID_GENERIC:\n\t\t*pin = service->factory.funcs->get_generic_pin(gpio);\n\t\tservice->factory.funcs->define_generic_registers(*pin, en);\n\tbreak;\n\tcase GPIO_ID_HPD:\n\t\t*pin = service->factory.funcs->get_hpd_pin(gpio);\n\t\tservice->factory.funcs->define_hpd_registers(*pin, en);\n\tbreak;\n\n\t\n\tcase GPIO_ID_SYNC:\n\tcase GPIO_ID_GSL:\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n\n\tif (!*pin) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n\n\tif (!(*pin)->funcs->open(*pin, mode)) {\n\t\tASSERT_CRITICAL(false);\n\t\tdal_gpio_service_close(service, pin);\n\t\treturn GPIO_RESULT_OPEN_FAILED;\n\t}\n\n\tset_pin_busy(service, id, en);\n\treturn GPIO_RESULT_OK;\n}\n\nvoid dal_gpio_service_close(\n\tstruct gpio_service *service,\n\tstruct hw_gpio_pin **ptr)\n{\n\tstruct hw_gpio_pin *pin;\n\n\tif (!ptr) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tpin = *ptr;\n\n\tif (pin) {\n\t\tset_pin_free(service, pin->id, pin->en);\n\n\t\tpin->funcs->close(pin);\n\n\t\t*ptr = NULL;\n\t}\n}\n\nenum dc_irq_source dal_irq_get_source(\n\tconst struct gpio *irq)\n{\n\tenum gpio_id id = dal_gpio_get_id(irq);\n\n\tswitch (id) {\n\tcase GPIO_ID_HPD:\n\t\treturn (enum dc_irq_source)(DC_IRQ_SOURCE_HPD1 +\n\t\t\tdal_gpio_get_enum(irq));\n\tcase GPIO_ID_GPIO_PAD:\n\t\treturn (enum dc_irq_source)(DC_IRQ_SOURCE_GPIOPAD0 +\n\t\t\tdal_gpio_get_enum(irq));\n\tdefault:\n\t\treturn DC_IRQ_SOURCE_INVALID;\n\t}\n}\n\nenum dc_irq_source dal_irq_get_rx_source(\n\tconst struct gpio *irq)\n{\n\tenum gpio_id id = dal_gpio_get_id(irq);\n\n\tswitch (id) {\n\tcase GPIO_ID_HPD:\n\t\treturn (enum dc_irq_source)(DC_IRQ_SOURCE_HPD1RX +\n\t\t\tdal_gpio_get_enum(irq));\n\tdefault:\n\t\treturn DC_IRQ_SOURCE_INVALID;\n\t}\n}\n\nenum gpio_result dal_irq_setup_hpd_filter(\n\tstruct gpio *irq,\n\tstruct gpio_hpd_config *config)\n{\n\tstruct gpio_config_data config_data;\n\n\tif (!config)\n\t\treturn GPIO_RESULT_INVALID_DATA;\n\n\tconfig_data.type = GPIO_CONFIG_TYPE_HPD;\n\tconfig_data.config.hpd = *config;\n\n\treturn dal_gpio_set_config(irq, &config_data);\n}\n\n \n\nstruct gpio *dal_gpio_create_irq(\n\tstruct gpio_service *service,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tstruct gpio *irq;\n\n\tswitch (id) {\n\tcase GPIO_ID_HPD:\n\tcase GPIO_ID_GPIO_PAD:\n\tbreak;\n\tdefault:\n\t\tid = GPIO_ID_HPD;\n\t\tASSERT_CRITICAL(false);\n\t\treturn NULL;\n\t}\n\n\tirq = dal_gpio_create(\n\t\tservice, id, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);\n\n\tif (irq)\n\t\treturn irq;\n\n\tASSERT_CRITICAL(false);\n\treturn NULL;\n}\n\nvoid dal_gpio_destroy_irq(\n\tstruct gpio **irq)\n{\n\tif (!irq || !*irq) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tdal_gpio_destroy(irq);\n\tkfree(*irq);\n\n\t*irq = NULL;\n}\n\nstruct ddc *dal_gpio_create_ddc(\n\tstruct gpio_service *service,\n\tuint32_t offset,\n\tuint32_t mask,\n\tstruct gpio_ddc_hw_info *info)\n{\n\tenum gpio_id id;\n\tuint32_t en;\n\tstruct ddc *ddc;\n\n\tif (!service->translate.funcs->offset_to_id(offset, mask, &id, &en))\n\t\treturn NULL;\n\n\tddc = kzalloc(sizeof(struct ddc), GFP_KERNEL);\n\n\tif (!ddc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tddc->pin_data = dal_gpio_create(\n\t\tservice, GPIO_ID_DDC_DATA, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);\n\n\tif (!ddc->pin_data) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto failure_1;\n\t}\n\n\tddc->pin_clock = dal_gpio_create(\n\t\tservice, GPIO_ID_DDC_CLOCK, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);\n\n\tif (!ddc->pin_clock) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto failure_2;\n\t}\n\n\tddc->hw_info = *info;\n\n\tddc->ctx = service->ctx;\n\n\treturn ddc;\n\nfailure_2:\n\tdal_gpio_destroy(&ddc->pin_data);\n\nfailure_1:\n\tkfree(ddc);\n\n\treturn NULL;\n}\n\nvoid dal_gpio_destroy_ddc(\n\tstruct ddc **ddc)\n{\n\tif (!ddc || !*ddc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tdal_ddc_close(*ddc);\n\tdal_gpio_destroy(&(*ddc)->pin_data);\n\tdal_gpio_destroy(&(*ddc)->pin_clock);\n\tkfree(*ddc);\n\n\t*ddc = NULL;\n}\n\nenum gpio_result dal_ddc_open(\n\tstruct ddc *ddc,\n\tenum gpio_mode mode,\n\tenum gpio_ddc_config_type config_type)\n{\n\tenum gpio_result result;\n\n\tstruct gpio_config_data config_data;\n\tstruct hw_gpio *hw_data;\n\tstruct hw_gpio *hw_clock;\n\n\tresult = dal_gpio_open_ex(ddc->pin_data, mode);\n\n\tif (result != GPIO_RESULT_OK) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn result;\n\t}\n\n\tresult = dal_gpio_open_ex(ddc->pin_clock, mode);\n\n\tif (result != GPIO_RESULT_OK) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto failure;\n\t}\n\n\t \n\n\tif (mode == GPIO_MODE_INPUT)\n\t\t \n\t\tconfig_data.type = GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE;\n\telse\n\t\tconfig_data.type = GPIO_CONFIG_TYPE_DDC;\n\n\tconfig_data.config.ddc.type = config_type;\n\n\thw_data = FROM_HW_GPIO_PIN(ddc->pin_data->pin);\n\thw_clock = FROM_HW_GPIO_PIN(ddc->pin_clock->pin);\n\n\tconfig_data.config.ddc.data_en_bit_present = hw_data->store.en != 0;\n\tconfig_data.config.ddc.clock_en_bit_present = hw_clock->store.en != 0;\n\n\tresult = dal_gpio_set_config(ddc->pin_data, &config_data);\n\n\tif (result == GPIO_RESULT_OK)\n\t\treturn result;\n\n\tBREAK_TO_DEBUGGER();\n\n\tdal_gpio_close(ddc->pin_clock);\n\nfailure:\n\tdal_gpio_close(ddc->pin_data);\n\n\treturn result;\n}\n\nenum gpio_result dal_ddc_change_mode(\n\tstruct ddc *ddc,\n\tenum gpio_mode mode)\n{\n\tenum gpio_result result;\n\n\tenum gpio_mode original_mode =\n\t\tdal_gpio_get_mode(ddc->pin_data);\n\n\tresult = dal_gpio_change_mode(ddc->pin_data, mode);\n\n\t \n\n\tif (result != GPIO_RESULT_OK)\n\t\tgoto failure;\n\n\tresult = dal_gpio_change_mode(ddc->pin_clock, mode);\n\n\tif (result == GPIO_RESULT_OK)\n\t\treturn result;\n\n\tdal_gpio_change_mode(ddc->pin_clock, original_mode);\n\nfailure:\n\tdal_gpio_change_mode(ddc->pin_data, original_mode);\n\n\treturn result;\n}\n\nenum gpio_ddc_line dal_ddc_get_line(\n\tconst struct ddc *ddc)\n{\n\treturn (enum gpio_ddc_line)dal_gpio_get_enum(ddc->pin_data);\n}\n\nenum gpio_result dal_ddc_set_config(\n\tstruct ddc *ddc,\n\tenum gpio_ddc_config_type config_type)\n{\n\tstruct gpio_config_data config_data;\n\n\tconfig_data.type = GPIO_CONFIG_TYPE_DDC;\n\n\tconfig_data.config.ddc.type = config_type;\n\tconfig_data.config.ddc.data_en_bit_present = false;\n\tconfig_data.config.ddc.clock_en_bit_present = false;\n\n\treturn dal_gpio_set_config(ddc->pin_data, &config_data);\n}\n\nvoid dal_ddc_close(\n\tstruct ddc *ddc)\n{\n\tif (ddc != NULL) {\n\t\tdal_gpio_close(ddc->pin_clock);\n\t\tdal_gpio_close(ddc->pin_data);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}