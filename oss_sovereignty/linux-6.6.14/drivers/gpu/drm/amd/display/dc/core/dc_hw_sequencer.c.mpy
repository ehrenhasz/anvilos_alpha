{
  "module_name": "dc_hw_sequencer.c",
  "hash_id": "e79beee0209710be606f16918d9c85ba321b30717225c2785553a544d6a973f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n#include \"timing_generator.h\"\n#include \"hw_sequencer.h\"\n#include \"hw_sequencer_private.h\"\n#include \"basics/dc_common.h\"\n\n#define NUM_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))\n\n \nenum black_color_format {\n\tBLACK_COLOR_FORMAT_RGB_FULLRANGE = 0,\n\tBLACK_COLOR_FORMAT_RGB_LIMITED,\n\tBLACK_COLOR_FORMAT_YUV_TV,\n\tBLACK_COLOR_FORMAT_YUV_CV,\n\tBLACK_COLOR_FORMAT_YUV_SUPER_AA,\n\tBLACK_COLOR_FORMAT_DEBUG,\n};\n\nenum dc_color_space_type {\n\tCOLOR_SPACE_RGB_TYPE,\n\tCOLOR_SPACE_RGB_LIMITED_TYPE,\n\tCOLOR_SPACE_YCBCR601_TYPE,\n\tCOLOR_SPACE_YCBCR709_TYPE,\n\tCOLOR_SPACE_YCBCR2020_TYPE,\n\tCOLOR_SPACE_YCBCR601_LIMITED_TYPE,\n\tCOLOR_SPACE_YCBCR709_LIMITED_TYPE,\n\tCOLOR_SPACE_YCBCR709_BLACK_TYPE,\n};\n\nstatic const struct tg_color black_color_format[] = {\n\t \n\t{0, 0, 0},\n\t \n\t{0x40, 0x40, 0x40},\n\t \n\t{0x200, 0x40, 0x200},\n\t \n\t{0x1f4, 0x40, 0x1f4},\n\t \n\t{0x1a2, 0x20, 0x1a2},\n\t \n\t{0xff, 0xff, 0},\n};\n\nstruct out_csc_color_matrix_type {\n\tenum dc_color_space_type color_space_type;\n\tuint16_t regval[12];\n};\n\nstatic const struct out_csc_color_matrix_type output_csc_matrix[] = {\n\t{ COLOR_SPACE_RGB_TYPE,\n\t\t{ 0x2000, 0,      0,      0,\n\t\t  0,      0x2000, 0,      0,\n\t\t  0,      0,      0x2000, 0} },\n\t{ COLOR_SPACE_RGB_LIMITED_TYPE,\n\t\t{ 0x1B67, 0,      0,      0x201,\n\t\t  0,      0x1B67, 0,      0x201,\n\t\t  0,      0,      0x1B67, 0x201} },\n\t{ COLOR_SPACE_YCBCR601_TYPE,\n\t\t{ 0xE04,  0xF444, 0xFDB9, 0x1004,\n\t\t  0x831,  0x1016, 0x320,  0x201,\n\t\t  0xFB45, 0xF6B7, 0xE04,  0x1004} },\n\t{ COLOR_SPACE_YCBCR709_TYPE,\n\t\t{ 0xE04,  0xF345, 0xFEB7, 0x1004,\n\t\t  0x5D3,  0x1399, 0x1FA,  0x201,\n\t\t  0xFCCA, 0xF533, 0xE04,  0x1004} },\n\t \n\t{ COLOR_SPACE_YCBCR601_LIMITED_TYPE,\n\t\t{ 0xE00,  0xF447, 0xFDB9, 0x1000,\n\t\t  0x991,  0x12C9, 0x3A6,  0x200,\n\t\t  0xFB47, 0xF6B9, 0xE00,  0x1000} },\n\t{ COLOR_SPACE_YCBCR709_LIMITED_TYPE,\n\t\t{ 0xE00, 0xF349, 0xFEB7, 0x1000,\n\t\t  0x6CE, 0x16E3, 0x24F,  0x200,\n\t\t  0xFCCB, 0xF535, 0xE00, 0x1000} },\n\t{ COLOR_SPACE_YCBCR2020_TYPE,\n\t\t{ 0x1000, 0xF149, 0xFEB7, 0x1004,\n\t\t  0x0868, 0x15B2, 0x01E6, 0x201,\n\t\t  0xFB88, 0xF478, 0x1000, 0x1004} },\n\t{ COLOR_SPACE_YCBCR709_BLACK_TYPE,\n\t\t{ 0x0000, 0x0000, 0x0000, 0x1000,\n\t\t  0x0000, 0x0000, 0x0000, 0x0200,\n\t\t  0x0000, 0x0000, 0x0000, 0x1000} },\n};\n\nstatic bool is_rgb_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_SRGB\t\t\t||\n\t\tcolor_space == COLOR_SPACE_XR_RGB\t\t||\n\t\tcolor_space == COLOR_SPACE_MSREF_SCRGB\t\t||\n\t\tcolor_space == COLOR_SPACE_2020_RGB_FULLRANGE\t||\n\t\tcolor_space == COLOR_SPACE_ADOBERGB\t\t||\n\t\tcolor_space == COLOR_SPACE_DCIP3\t||\n\t\tcolor_space == COLOR_SPACE_DOLBYVISION)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_rgb_limited_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_SRGB_LIMITED\t\t||\n\t\tcolor_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_ycbcr601_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_YCBCR601\t||\n\t\tcolor_space == COLOR_SPACE_XV_YCC_601)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_ycbcr601_limited_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_YCBCR601_LIMITED)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_ycbcr709_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_YCBCR709\t||\n\t\tcolor_space == COLOR_SPACE_XV_YCC_709)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_ycbcr2020_type(\n\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_2020_YCBCR)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic bool is_ycbcr709_limited_type(\n\t\tenum dc_color_space color_space)\n{\n\tbool ret = false;\n\n\tif (color_space == COLOR_SPACE_YCBCR709_LIMITED)\n\t\tret = true;\n\treturn ret;\n}\n\nstatic enum dc_color_space_type get_color_space_type(enum dc_color_space color_space)\n{\n\tenum dc_color_space_type type = COLOR_SPACE_RGB_TYPE;\n\n\tif (is_rgb_type(color_space))\n\t\ttype = COLOR_SPACE_RGB_TYPE;\n\telse if (is_rgb_limited_type(color_space))\n\t\ttype = COLOR_SPACE_RGB_LIMITED_TYPE;\n\telse if (is_ycbcr601_type(color_space))\n\t\ttype = COLOR_SPACE_YCBCR601_TYPE;\n\telse if (is_ycbcr709_type(color_space))\n\t\ttype = COLOR_SPACE_YCBCR709_TYPE;\n\telse if (is_ycbcr601_limited_type(color_space))\n\t\ttype = COLOR_SPACE_YCBCR601_LIMITED_TYPE;\n\telse if (is_ycbcr709_limited_type(color_space))\n\t\ttype = COLOR_SPACE_YCBCR709_LIMITED_TYPE;\n\telse if (is_ycbcr2020_type(color_space))\n\t\ttype = COLOR_SPACE_YCBCR2020_TYPE;\n\telse if (color_space == COLOR_SPACE_YCBCR709)\n\t\ttype = COLOR_SPACE_YCBCR709_BLACK_TYPE;\n\telse if (color_space == COLOR_SPACE_YCBCR709_BLACK)\n\t\ttype = COLOR_SPACE_YCBCR709_BLACK_TYPE;\n\treturn type;\n}\n\nconst uint16_t *find_color_matrix(enum dc_color_space color_space,\n\t\t\t\t\t\t\tuint32_t *array_size)\n{\n\tint i;\n\tenum dc_color_space_type type;\n\tconst uint16_t *val = NULL;\n\tint arr_size = NUM_ELEMENTS(output_csc_matrix);\n\n\ttype = get_color_space_type(color_space);\n\tfor (i = 0; i < arr_size; i++)\n\t\tif (output_csc_matrix[i].color_space_type == type) {\n\t\t\tval = output_csc_matrix[i].regval;\n\t\t\t*array_size = 12;\n\t\t\tbreak;\n\t\t}\n\n\treturn val;\n}\n\n\nvoid color_space_to_black_color(\n\tconst struct dc *dc,\n\tenum dc_color_space colorspace,\n\tstruct tg_color *black_color)\n{\n\tswitch (colorspace) {\n\tcase COLOR_SPACE_YCBCR601:\n\tcase COLOR_SPACE_YCBCR709:\n\tcase COLOR_SPACE_YCBCR709_BLACK:\n\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\tcase COLOR_SPACE_2020_YCBCR:\n\t\t*black_color = black_color_format[BLACK_COLOR_FORMAT_YUV_CV];\n\t\tbreak;\n\n\tcase COLOR_SPACE_SRGB_LIMITED:\n\t\t*black_color =\n\t\t\tblack_color_format[BLACK_COLOR_FORMAT_RGB_LIMITED];\n\t\tbreak;\n\n\t \n\tcase COLOR_SPACE_UNKNOWN:\n\tcase COLOR_SPACE_SRGB:\n\tcase COLOR_SPACE_XR_RGB:\n\tcase COLOR_SPACE_MSREF_SCRGB:\n\tcase COLOR_SPACE_XV_YCC_709:\n\tcase COLOR_SPACE_XV_YCC_601:\n\tcase COLOR_SPACE_2020_RGB_FULLRANGE:\n\tcase COLOR_SPACE_2020_RGB_LIMITEDRANGE:\n\tcase COLOR_SPACE_ADOBERGB:\n\tcase COLOR_SPACE_DCIP3:\n\tcase COLOR_SPACE_DISPLAYNATIVE:\n\tcase COLOR_SPACE_DOLBYVISION:\n\tcase COLOR_SPACE_APPCTRL:\n\tcase COLOR_SPACE_CUSTOMPOINTS:\n\t\t \n\t\t*black_color =\n\t\t\tblack_color_format[BLACK_COLOR_FORMAT_RGB_FULLRANGE];\n\t\t \n\t\tbreak;\n\t}\n}\n\nbool hwss_wait_for_blank_complete(\n\t\tstruct timing_generator *tg)\n{\n\tint counter;\n\n\t \n\tif (!tg->funcs->is_blanked)\n\t\treturn true;\n\tfor (counter = 0; counter < 100; counter++) {\n\t\tif (tg->funcs->is_blanked(tg))\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\tif (counter == 100) {\n\t\tdm_error(\"DC: failed to blank crtc!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid get_mpctree_visual_confirm_color(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tconst struct tg_color pipe_colors[6] = {\n\t\t\t{MAX_TG_COLOR_VALUE, 0, 0},  \n\t\t\t{MAX_TG_COLOR_VALUE, MAX_TG_COLOR_VALUE / 4, 0},  \n\t\t\t{MAX_TG_COLOR_VALUE, MAX_TG_COLOR_VALUE, 0},  \n\t\t\t{0, MAX_TG_COLOR_VALUE, 0},  \n\t\t\t{0, 0, MAX_TG_COLOR_VALUE},  \n\t\t\t{MAX_TG_COLOR_VALUE / 2, 0, MAX_TG_COLOR_VALUE / 2},  \n\t};\n\n\tstruct pipe_ctx *top_pipe = pipe_ctx;\n\n\twhile (top_pipe->top_pipe)\n\t\ttop_pipe = top_pipe->top_pipe;\n\n\t*color = pipe_colors[top_pipe->pipe_idx];\n}\n\nvoid get_surface_visual_confirm_color(\n\t\tconst struct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tuint32_t color_value = MAX_TG_COLOR_VALUE;\n\n\tswitch (pipe_ctx->plane_res.scl_data.format) {\n\tcase PIXEL_FORMAT_ARGB8888:\n\t\t \n\t\tcolor->color_r_cr = color_value;\n\t\tif (pipe_ctx->plane_state->layer_index > 0) {\n\t\t\t \n\t\t\tcolor->color_b_cb = color_value;\n\t\t\tcolor->color_g_y = color_value * 0.5;\n\t\t}\n\t\tbreak;\n\n\tcase PIXEL_FORMAT_ARGB2101010:\n\t\t \n\t\tcolor->color_b_cb = color_value;\n\t\tif (pipe_ctx->plane_state->layer_index > 0) {\n\t\t\t \n\t\t\tcolor->color_g_y = color_value;\n\t\t}\n\t\tbreak;\n\tcase PIXEL_FORMAT_420BPP8:\n\t\t \n\t\tcolor->color_g_y = color_value;\n\t\tbreak;\n\tcase PIXEL_FORMAT_420BPP10:\n\t\t \n\t\tcolor->color_g_y = color_value;\n\t\tcolor->color_r_cr = color_value;\n\t\tbreak;\n\tcase PIXEL_FORMAT_FP16:\n\t\t \n\t\tcolor->color_r_cr = color_value;\n\t\tcolor->color_b_cb = color_value;\n\t\tcolor->color_g_y = color_value;\n\t\tif (pipe_ctx->plane_state->layer_index > 0) {\n\t\t\t \n\t\t\tcolor->color_g_y = 0.22 * color_value;\n\t\t\tcolor->color_b_cb = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid get_hdr_visual_confirm_color(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tuint32_t color_value = MAX_TG_COLOR_VALUE;\n\tbool is_sdr = false;\n\n\t \n\tstruct pipe_ctx *top_pipe_ctx  = pipe_ctx;\n\n\twhile (top_pipe_ctx->top_pipe != NULL)\n\t\ttop_pipe_ctx = top_pipe_ctx->top_pipe;\n\n\tswitch (top_pipe_ctx->plane_res.scl_data.format) {\n\tcase PIXEL_FORMAT_ARGB2101010:\n\t\tif (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {\n\t\t\t \n\t\t\tcolor->color_r_cr = color_value;\n\t\t} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {\n\t\t\t \n\t\t\tcolor->color_r_cr = color_value;\n\t\t\tcolor->color_b_cb = color_value;\n\t\t} else\n\t\t\tis_sdr = true;\n\t\tbreak;\n\tcase PIXEL_FORMAT_FP16:\n\t\tif (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {\n\t\t\t \n\t\t\tcolor->color_b_cb = color_value;\n\t\t} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {\n\t\t\t \n\t\t\tcolor->color_g_y = color_value;\n\t\t} else\n\t\t\tis_sdr = true;\n\t\tbreak;\n\tdefault:\n\t\tis_sdr = true;\n\t\tbreak;\n\t}\n\n\tif (is_sdr) {\n\t\t \n\t\tcolor->color_r_cr = color_value/2;\n\t\tcolor->color_b_cb = color_value/2;\n\t\tcolor->color_g_y = color_value/2;\n\t}\n}\n\nvoid get_subvp_visual_confirm_color(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tuint32_t color_value = MAX_TG_COLOR_VALUE;\n\tbool enable_subvp = false;\n\tint i;\n\n\tif (!dc->ctx || !dc->ctx->dmub_srv || !pipe_ctx || !context)\n\t\treturn;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.paired_stream &&\n\t\t    pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t \n\t\t\tcolor->color_g_y = 0;\n\t\t\tcolor->color_b_cb = 0;\n\t\t\tcolor->color_r_cr = color_value;\n\t\t\tenable_subvp = true;\n\n\t\t\tif (pipe_ctx->stream == pipe->stream)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (enable_subvp && pipe_ctx->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\tcolor->color_r_cr = 0;\n\t\tif (pipe_ctx->stream->allow_freesync == 1) {\n\t\t\t \n\t\t\tcolor->color_b_cb = 0;\n\t\t\tcolor->color_g_y = color_value;\n\t\t} else {\n\t\t\t \n\t\t\tcolor->color_g_y = 0;\n\t\t\tcolor->color_b_cb = color_value;\n\t\t}\n\t}\n}\n\nvoid hwss_build_fast_sequence(struct dc *dc,\n\t\tstruct dc_dmub_cmd *dc_dmub_cmd,\n\t\tunsigned int dmub_cmd_count,\n\t\tstruct block_sequence block_sequence[],\n\t\tint *num_steps,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_plane_state *plane = pipe_ctx->plane_state;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct pipe_ctx *current_pipe = NULL;\n\tstruct pipe_ctx *current_mpc_pipe = NULL;\n\tunsigned int i = 0;\n\n\t*num_steps = 0;  \n\n\tif (!plane || !stream)\n\t\treturn;\n\n\tif (dc->hwss.subvp_pipe_control_lock_fast) {\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.dc = dc;\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.lock = true;\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.pipe_ctx = pipe_ctx;\n\t\tblock_sequence[*num_steps].func = DMUB_SUBVP_PIPE_CONTROL_LOCK_FAST;\n\t\t(*num_steps)++;\n\t}\n\tif (dc->hwss.pipe_control_lock) {\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.dc = dc;\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.lock = true;\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.pipe_ctx = pipe_ctx;\n\t\tblock_sequence[*num_steps].func = OPTC_PIPE_CONTROL_LOCK;\n\t\t(*num_steps)++;\n\t}\n\n\tfor (i = 0; i < dmub_cmd_count; i++) {\n\t\tblock_sequence[*num_steps].params.send_dmcub_cmd_params.ctx = dc->ctx;\n\t\tblock_sequence[*num_steps].params.send_dmcub_cmd_params.cmd = &(dc_dmub_cmd[i].dmub_cmd);\n\t\tblock_sequence[*num_steps].params.send_dmcub_cmd_params.wait_type = dc_dmub_cmd[i].wait_type;\n\t\tblock_sequence[*num_steps].func = DMUB_SEND_DMCUB_CMD;\n\t\t(*num_steps)++;\n\t}\n\n\tcurrent_pipe = pipe_ctx;\n\twhile (current_pipe) {\n\t\tcurrent_mpc_pipe = current_pipe;\n\t\twhile (current_mpc_pipe) {\n\t\t\tif (dc->hwss.set_flip_control_gsl && current_mpc_pipe->plane_state && current_mpc_pipe->plane_state->update_flags.raw) {\n\t\t\t\tblock_sequence[*num_steps].params.set_flip_control_gsl_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].params.set_flip_control_gsl_params.flip_immediate = current_mpc_pipe->plane_state->flip_immediate;\n\t\t\t\tblock_sequence[*num_steps].func = HUBP_SET_FLIP_CONTROL_GSL;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tif (dc->hwss.program_triplebuffer && dc->debug.enable_tri_buf && current_mpc_pipe->plane_state->update_flags.raw) {\n\t\t\t\tblock_sequence[*num_steps].params.program_triplebuffer_params.dc = dc;\n\t\t\t\tblock_sequence[*num_steps].params.program_triplebuffer_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].params.program_triplebuffer_params.enableTripleBuffer = current_mpc_pipe->plane_state->triplebuffer_flips;\n\t\t\t\tblock_sequence[*num_steps].func = HUBP_PROGRAM_TRIPLEBUFFER;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tif (dc->hwss.update_plane_addr && current_mpc_pipe->plane_state->update_flags.bits.addr_update) {\n\t\t\t\tblock_sequence[*num_steps].params.update_plane_addr_params.dc = dc;\n\t\t\t\tblock_sequence[*num_steps].params.update_plane_addr_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].func = HUBP_UPDATE_PLANE_ADDR;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\n\t\t\tif (hws->funcs.set_input_transfer_func && current_mpc_pipe->plane_state->update_flags.bits.gamma_change) {\n\t\t\t\tblock_sequence[*num_steps].params.set_input_transfer_func_params.dc = dc;\n\t\t\t\tblock_sequence[*num_steps].params.set_input_transfer_func_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].params.set_input_transfer_func_params.plane_state = current_mpc_pipe->plane_state;\n\t\t\t\tblock_sequence[*num_steps].func = DPP_SET_INPUT_TRANSFER_FUNC;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\n\t\t\tif (dc->hwss.program_gamut_remap && current_mpc_pipe->plane_state->update_flags.bits.gamut_remap_change) {\n\t\t\t\tblock_sequence[*num_steps].params.program_gamut_remap_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].func = DPP_PROGRAM_GAMUT_REMAP;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tif (current_mpc_pipe->plane_state->update_flags.bits.input_csc_change) {\n\t\t\t\tblock_sequence[*num_steps].params.setup_dpp_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].func = DPP_SETUP_DPP;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tif (current_mpc_pipe->plane_state->update_flags.bits.coeff_reduction_change) {\n\t\t\t\tblock_sequence[*num_steps].params.program_bias_and_scale_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].func = DPP_PROGRAM_BIAS_AND_SCALE;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tif (hws->funcs.set_output_transfer_func && current_mpc_pipe->stream->update_flags.bits.out_tf) {\n\t\t\t\tblock_sequence[*num_steps].params.set_output_transfer_func_params.dc = dc;\n\t\t\t\tblock_sequence[*num_steps].params.set_output_transfer_func_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].params.set_output_transfer_func_params.stream = current_mpc_pipe->stream;\n\t\t\t\tblock_sequence[*num_steps].func = DPP_SET_OUTPUT_TRANSFER_FUNC;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\n\t\t\tif (current_mpc_pipe->stream->update_flags.bits.out_csc) {\n\t\t\t\tblock_sequence[*num_steps].params.power_on_mpc_mem_pwr_params.mpc = dc->res_pool->mpc;\n\t\t\t\tblock_sequence[*num_steps].params.power_on_mpc_mem_pwr_params.mpcc_id = current_mpc_pipe->plane_res.hubp->inst;\n\t\t\t\tblock_sequence[*num_steps].params.power_on_mpc_mem_pwr_params.power_on = true;\n\t\t\t\tblock_sequence[*num_steps].func = MPC_POWER_ON_MPC_MEM_PWR;\n\t\t\t\t(*num_steps)++;\n\n\t\t\t\tif (current_mpc_pipe->stream->csc_color_matrix.enable_adjustment == true) {\n\t\t\t\t\tblock_sequence[*num_steps].params.set_output_csc_params.mpc = dc->res_pool->mpc;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_output_csc_params.opp_id = current_mpc_pipe->stream_res.opp->inst;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_output_csc_params.regval = current_mpc_pipe->stream->csc_color_matrix.matrix;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_output_csc_params.ocsc_mode = MPC_OUTPUT_CSC_COEF_A;\n\t\t\t\t\tblock_sequence[*num_steps].func = MPC_SET_OUTPUT_CSC;\n\t\t\t\t\t(*num_steps)++;\n\t\t\t\t} else {\n\t\t\t\t\tblock_sequence[*num_steps].params.set_ocsc_default_params.mpc = dc->res_pool->mpc;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_ocsc_default_params.opp_id = current_mpc_pipe->stream_res.opp->inst;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_ocsc_default_params.color_space = current_mpc_pipe->stream->output_color_space;\n\t\t\t\t\tblock_sequence[*num_steps].params.set_ocsc_default_params.ocsc_mode = MPC_OUTPUT_CSC_COEF_A;\n\t\t\t\t\tblock_sequence[*num_steps].func = MPC_SET_OCSC_DEFAULT;\n\t\t\t\t\t(*num_steps)++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent_mpc_pipe = current_mpc_pipe->bottom_pipe;\n\t\t}\n\t\tcurrent_pipe = current_pipe->next_odm_pipe;\n\t}\n\n\tif (dc->hwss.pipe_control_lock) {\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.dc = dc;\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.lock = false;\n\t\tblock_sequence[*num_steps].params.pipe_control_lock_params.pipe_ctx = pipe_ctx;\n\t\tblock_sequence[*num_steps].func = OPTC_PIPE_CONTROL_LOCK;\n\t\t(*num_steps)++;\n\t}\n\tif (dc->hwss.subvp_pipe_control_lock_fast) {\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.dc = dc;\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.lock = false;\n\t\tblock_sequence[*num_steps].params.subvp_pipe_control_lock_fast_params.pipe_ctx = pipe_ctx;\n\t\tblock_sequence[*num_steps].func = DMUB_SUBVP_PIPE_CONTROL_LOCK_FAST;\n\t\t(*num_steps)++;\n\t}\n\n\tcurrent_pipe = pipe_ctx;\n\twhile (current_pipe) {\n\t\tcurrent_mpc_pipe = current_pipe;\n\n\t\twhile (current_mpc_pipe) {\n\t\t\tif (!current_mpc_pipe->bottom_pipe && !current_mpc_pipe->next_odm_pipe &&\n\t\t\t\t\tcurrent_mpc_pipe->stream && current_mpc_pipe->plane_state &&\n\t\t\t\t\tcurrent_mpc_pipe->plane_state->update_flags.bits.addr_update &&\n\t\t\t\t\t!current_mpc_pipe->plane_state->skip_manual_trigger) {\n\t\t\t\tblock_sequence[*num_steps].params.program_manual_trigger_params.pipe_ctx = current_mpc_pipe;\n\t\t\t\tblock_sequence[*num_steps].func = OPTC_PROGRAM_MANUAL_TRIGGER;\n\t\t\t\t(*num_steps)++;\n\t\t\t}\n\t\t\tcurrent_mpc_pipe = current_mpc_pipe->bottom_pipe;\n\t\t}\n\t\tcurrent_pipe = current_pipe->next_odm_pipe;\n\t}\n}\n\nvoid hwss_execute_sequence(struct dc *dc,\n\t\tstruct block_sequence block_sequence[],\n\t\tint num_steps)\n{\n\tunsigned int i;\n\tunion block_sequence_params *params;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tfor (i = 0; i < num_steps; i++) {\n\t\tparams = &(block_sequence[i].params);\n\t\tswitch (block_sequence[i].func) {\n\n\t\tcase DMUB_SUBVP_PIPE_CONTROL_LOCK_FAST:\n\t\t\tdc->hwss.subvp_pipe_control_lock_fast(params);\n\t\t\tbreak;\n\t\tcase OPTC_PIPE_CONTROL_LOCK:\n\t\t\tdc->hwss.pipe_control_lock(params->pipe_control_lock_params.dc,\n\t\t\t\t\tparams->pipe_control_lock_params.pipe_ctx,\n\t\t\t\t\tparams->pipe_control_lock_params.lock);\n\t\t\tbreak;\n\t\tcase HUBP_SET_FLIP_CONTROL_GSL:\n\t\t\tdc->hwss.set_flip_control_gsl(params->set_flip_control_gsl_params.pipe_ctx,\n\t\t\t\t\tparams->set_flip_control_gsl_params.flip_immediate);\n\t\t\tbreak;\n\t\tcase HUBP_PROGRAM_TRIPLEBUFFER:\n\t\t\tdc->hwss.program_triplebuffer(params->program_triplebuffer_params.dc,\n\t\t\t\t\tparams->program_triplebuffer_params.pipe_ctx,\n\t\t\t\t\tparams->program_triplebuffer_params.enableTripleBuffer);\n\t\t\tbreak;\n\t\tcase HUBP_UPDATE_PLANE_ADDR:\n\t\t\tdc->hwss.update_plane_addr(params->update_plane_addr_params.dc,\n\t\t\t\t\tparams->update_plane_addr_params.pipe_ctx);\n\t\t\tbreak;\n\t\tcase DPP_SET_INPUT_TRANSFER_FUNC:\n\t\t\thws->funcs.set_input_transfer_func(params->set_input_transfer_func_params.dc,\n\t\t\t\t\tparams->set_input_transfer_func_params.pipe_ctx,\n\t\t\t\t\tparams->set_input_transfer_func_params.plane_state);\n\t\t\tbreak;\n\t\tcase DPP_PROGRAM_GAMUT_REMAP:\n\t\t\tdc->hwss.program_gamut_remap(params->program_gamut_remap_params.pipe_ctx);\n\t\t\tbreak;\n\t\tcase DPP_SETUP_DPP:\n\t\t\thwss_setup_dpp(params);\n\t\t\tbreak;\n\t\tcase DPP_PROGRAM_BIAS_AND_SCALE:\n\t\t\thwss_program_bias_and_scale(params);\n\t\t\tbreak;\n\t\tcase OPTC_PROGRAM_MANUAL_TRIGGER:\n\t\t\thwss_program_manual_trigger(params);\n\t\t\tbreak;\n\t\tcase DPP_SET_OUTPUT_TRANSFER_FUNC:\n\t\t\thws->funcs.set_output_transfer_func(params->set_output_transfer_func_params.dc,\n\t\t\t\t\tparams->set_output_transfer_func_params.pipe_ctx,\n\t\t\t\t\tparams->set_output_transfer_func_params.stream);\n\t\t\tbreak;\n\t\tcase MPC_UPDATE_VISUAL_CONFIRM:\n\t\t\tdc->hwss.update_visual_confirm_color(params->update_visual_confirm_params.dc,\n\t\t\t\t\tparams->update_visual_confirm_params.pipe_ctx,\n\t\t\t\t\tparams->update_visual_confirm_params.mpcc_id);\n\t\t\tbreak;\n\t\tcase MPC_POWER_ON_MPC_MEM_PWR:\n\t\t\thwss_power_on_mpc_mem_pwr(params);\n\t\t\tbreak;\n\t\tcase MPC_SET_OUTPUT_CSC:\n\t\t\thwss_set_output_csc(params);\n\t\t\tbreak;\n\t\tcase MPC_SET_OCSC_DEFAULT:\n\t\t\thwss_set_ocsc_default(params);\n\t\t\tbreak;\n\t\tcase DMUB_SEND_DMCUB_CMD:\n\t\t\thwss_send_dmcub_cmd(params);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(false);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid hwss_send_dmcub_cmd(union block_sequence_params *params)\n{\n\tstruct dc_context *ctx = params->send_dmcub_cmd_params.ctx;\n\tunion dmub_rb_cmd *cmd = params->send_dmcub_cmd_params.cmd;\n\tenum dm_dmub_wait_type wait_type = params->send_dmcub_cmd_params.wait_type;\n\n\tdm_execute_dmub_cmd(ctx, cmd, wait_type);\n}\n\nvoid hwss_program_manual_trigger(union block_sequence_params *params)\n{\n\tstruct pipe_ctx *pipe_ctx = params->program_manual_trigger_params.pipe_ctx;\n\n\tif (pipe_ctx->stream_res.tg->funcs->program_manual_trigger)\n\t\tpipe_ctx->stream_res.tg->funcs->program_manual_trigger(pipe_ctx->stream_res.tg);\n}\n\nvoid hwss_setup_dpp(union block_sequence_params *params)\n{\n\tstruct pipe_ctx *pipe_ctx = params->setup_dpp_params.pipe_ctx;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\n\tif (dpp && dpp->funcs->dpp_setup) {\n\t\t \n\t\tdpp->funcs->dpp_setup(dpp,\n\t\t\t\tplane_state->format,\n\t\t\t\tEXPANSION_MODE_ZERO,\n\t\t\t\tplane_state->input_csc_color_matrix,\n\t\t\t\tplane_state->color_space,\n\t\t\t\tNULL);\n\t}\n}\n\nvoid hwss_program_bias_and_scale(union block_sequence_params *params)\n{\n\tstruct pipe_ctx *pipe_ctx = params->program_bias_and_scale_params.pipe_ctx;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct dc_bias_and_scale bns_params = {0};\n\n\t \n\tbuild_prescale_params(&bns_params, plane_state);\n\tif (dpp->funcs->dpp_program_bias_and_scale)\n\t\tdpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);\n}\n\nvoid hwss_power_on_mpc_mem_pwr(union block_sequence_params *params)\n{\n\tstruct mpc *mpc = params->power_on_mpc_mem_pwr_params.mpc;\n\tint mpcc_id = params->power_on_mpc_mem_pwr_params.mpcc_id;\n\tbool power_on = params->power_on_mpc_mem_pwr_params.power_on;\n\n\tif (mpc->funcs->power_on_mpc_mem_pwr)\n\t\tmpc->funcs->power_on_mpc_mem_pwr(mpc, mpcc_id, power_on);\n}\n\nvoid hwss_set_output_csc(union block_sequence_params *params)\n{\n\tstruct mpc *mpc = params->set_output_csc_params.mpc;\n\tint opp_id = params->set_output_csc_params.opp_id;\n\tconst uint16_t *matrix = params->set_output_csc_params.regval;\n\tenum mpc_output_csc_mode ocsc_mode = params->set_output_csc_params.ocsc_mode;\n\n\tif (mpc->funcs->set_output_csc != NULL)\n\t\tmpc->funcs->set_output_csc(mpc,\n\t\t\t\topp_id,\n\t\t\t\tmatrix,\n\t\t\t\tocsc_mode);\n}\n\nvoid hwss_set_ocsc_default(union block_sequence_params *params)\n{\n\tstruct mpc *mpc = params->set_ocsc_default_params.mpc;\n\tint opp_id = params->set_ocsc_default_params.opp_id;\n\tenum dc_color_space colorspace = params->set_ocsc_default_params.color_space;\n\tenum mpc_output_csc_mode ocsc_mode = params->set_ocsc_default_params.ocsc_mode;\n\n\tif (mpc->funcs->set_ocsc_default != NULL)\n\t\tmpc->funcs->set_ocsc_default(mpc,\n\t\t\t\topp_id,\n\t\t\t\tcolorspace,\n\t\t\t\tocsc_mode);\n}\n\nvoid get_mclk_switch_visual_confirm_color(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tuint32_t color_value = MAX_TG_COLOR_VALUE;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\n\tif (!dc->ctx || !dc->ctx->dmub_srv || !pipe_ctx || !vba || !context)\n\t\treturn;\n\n\tif (vba->DRAMClockChangeSupport[vba->VoltageLevel][vba->maxMpcComb] !=\n\t\t\tdm_dram_clock_change_unsupported) {\n\t\t \n\t\tif (!pipe_ctx->has_vactive_margin) {\n\t\t\t \n\t\t\tcolor->color_r_cr = color_value;\n\t\t\tcolor->color_g_y = color_value;\n\n\t\t\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\t\t\t \n\t\t\t\tcolor->color_r_cr = 0;\n\t\t\t\tcolor->color_g_y  = color_value;\n\t\t\t\tcolor->color_b_cb = color_value;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tcolor->color_r_cr = color_value;\n\t\t\tcolor->color_b_cb = color_value;\n\t\t}\n\t\t \n\t\tget_subvp_visual_confirm_color(dc, context, pipe_ctx, color);\n\t}\n}\n\nvoid get_surface_tile_visual_confirm_color(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct tg_color *color)\n{\n\tuint32_t color_value = MAX_TG_COLOR_VALUE;\n\t \n\tstruct pipe_ctx *bottom_pipe_ctx  = pipe_ctx;\n\n\twhile (bottom_pipe_ctx->bottom_pipe != NULL)\n\t\tbottom_pipe_ctx = bottom_pipe_ctx->bottom_pipe;\n\n\tswitch (bottom_pipe_ctx->plane_state->tiling_info.gfx9.swizzle) {\n\tcase DC_SW_LINEAR:\n\t\t \n\t\tcolor->color_r_cr = color_value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}