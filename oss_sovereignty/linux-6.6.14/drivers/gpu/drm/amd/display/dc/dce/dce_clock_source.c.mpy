{
  "module_name": "dce_clock_source.c",
  "hash_id": "f323ffc3d9e64ca8f8ec769cbb2f52e33967bf8c836b4eaf9361da447de4b840",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n\n#include \"dc_types.h\"\n#include \"core_types.h\"\n\n#include \"include/grph_object_id.h\"\n#include \"include/logger_interface.h\"\n\n#include \"dce_clock_source.h\"\n#include \"clk_mgr.h\"\n\n#include \"reg_helper.h\"\n\n#define REG(reg)\\\n\t(clk_src->regs->reg)\n\n#define CTX \\\n\tclk_src->base.ctx\n\n#define DC_LOGGER_INIT()\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_src->cs_shift->field_name, clk_src->cs_mask->field_name\n\n#define FRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM 6\n#define CALC_PLL_CLK_SRC_ERR_TOLERANCE 1\n#define MAX_PLL_CALC_ERROR 0xFFFFFFFF\n\n#define NUM_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))\n\nstatic const struct spread_spectrum_data *get_ss_data_entry(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tenum signal_type signal,\n\t\tuint32_t pix_clk_khz)\n{\n\n\tuint32_t entrys_num;\n\tuint32_t i;\n\tstruct spread_spectrum_data *ss_parm = NULL;\n\tstruct spread_spectrum_data *ret = NULL;\n\n\tswitch (signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\tss_parm = clk_src->dvi_ss_params;\n\t\tentrys_num = clk_src->dvi_ss_params_cnt;\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tss_parm = clk_src->hdmi_ss_params;\n\t\tentrys_num = clk_src->hdmi_ss_params_cnt;\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_LVDS:\n\t\tss_parm = clk_src->lvds_ss_params;\n\t\tentrys_num = clk_src->lvds_ss_params_cnt;\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_VIRTUAL:\n\t\tss_parm = clk_src->dp_ss_params;\n\t\tentrys_num = clk_src->dp_ss_params_cnt;\n\t\tbreak;\n\n\tdefault:\n\t\tss_parm = NULL;\n\t\tentrys_num = 0;\n\t\tbreak;\n\t}\n\n\tif (ss_parm == NULL)\n\t\treturn ret;\n\n\tfor (i = 0; i < entrys_num; ++i, ++ss_parm) {\n\t\tif (ss_parm->freq_range_khz >= pix_clk_khz) {\n\t\t\tret = ss_parm;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool calculate_fb_and_fractional_fb_divider(\n\t\tstruct calc_pll_clock_source *calc_pll_cs,\n\t\tuint32_t target_pix_clk_100hz,\n\t\tuint32_t ref_divider,\n\t\tuint32_t post_divider,\n\t\tuint32_t *feedback_divider_param,\n\t\tuint32_t *fract_feedback_divider_param)\n{\n\tuint64_t feedback_divider;\n\n\tfeedback_divider =\n\t\t(uint64_t)target_pix_clk_100hz * ref_divider * post_divider;\n\tfeedback_divider *= 10;\n\t \n\tfeedback_divider *= (uint64_t)(calc_pll_cs->fract_fb_divider_factor);\n\tfeedback_divider = div_u64(feedback_divider, calc_pll_cs->ref_freq_khz * 10ull);\n\n \n\n\tfeedback_divider += 5ULL *\n\t\t\t    calc_pll_cs->fract_fb_divider_precision_factor;\n\tfeedback_divider =\n\t\tdiv_u64(feedback_divider,\n\t\t\tcalc_pll_cs->fract_fb_divider_precision_factor * 10);\n\tfeedback_divider *= (uint64_t)\n\t\t\t(calc_pll_cs->fract_fb_divider_precision_factor);\n\n\t*feedback_divider_param =\n\t\tdiv_u64_rem(\n\t\t\tfeedback_divider,\n\t\t\tcalc_pll_cs->fract_fb_divider_factor,\n\t\t\tfract_feedback_divider_param);\n\n\tif (*feedback_divider_param != 0)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool calc_fb_divider_checking_tolerance(\n\t\tstruct calc_pll_clock_source *calc_pll_cs,\n\t\tstruct pll_settings *pll_settings,\n\t\tuint32_t ref_divider,\n\t\tuint32_t post_divider,\n\t\tuint32_t tolerance)\n{\n\tuint32_t feedback_divider;\n\tuint32_t fract_feedback_divider;\n\tuint32_t actual_calculated_clock_100hz;\n\tuint32_t abs_err;\n\tuint64_t actual_calc_clk_100hz;\n\n\tcalculate_fb_and_fractional_fb_divider(\n\t\t\tcalc_pll_cs,\n\t\t\tpll_settings->adjusted_pix_clk_100hz,\n\t\t\tref_divider,\n\t\t\tpost_divider,\n\t\t\t&feedback_divider,\n\t\t\t&fract_feedback_divider);\n\n\t \n\tactual_calc_clk_100hz = (uint64_t)feedback_divider *\n\t\t\t\t\tcalc_pll_cs->fract_fb_divider_factor +\n\t\t\t\t\t\t\tfract_feedback_divider;\n\tactual_calc_clk_100hz *= calc_pll_cs->ref_freq_khz * 10;\n\tactual_calc_clk_100hz =\n\t\tdiv_u64(actual_calc_clk_100hz,\n\t\t\tref_divider * post_divider *\n\t\t\t\tcalc_pll_cs->fract_fb_divider_factor);\n\n\tactual_calculated_clock_100hz = (uint32_t)(actual_calc_clk_100hz);\n\n\tabs_err = (actual_calculated_clock_100hz >\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz)\n\t\t\t? actual_calculated_clock_100hz -\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz\n\t\t\t: pll_settings->adjusted_pix_clk_100hz -\n\t\t\t\t\t\tactual_calculated_clock_100hz;\n\n\tif (abs_err <= tolerance) {\n\t\t \n\t\tpll_settings->reference_freq = calc_pll_cs->ref_freq_khz;\n\t\tpll_settings->reference_divider = ref_divider;\n\t\tpll_settings->feedback_divider = feedback_divider;\n\t\tpll_settings->fract_feedback_divider = fract_feedback_divider;\n\t\tpll_settings->pix_clk_post_divider = post_divider;\n\t\tpll_settings->calculated_pix_clk_100hz =\n\t\t\tactual_calculated_clock_100hz;\n\t\tpll_settings->vco_freq =\n\t\t\tdiv_u64((u64)actual_calculated_clock_100hz * post_divider, 10);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool calc_pll_dividers_in_range(\n\t\tstruct calc_pll_clock_source *calc_pll_cs,\n\t\tstruct pll_settings *pll_settings,\n\t\tuint32_t min_ref_divider,\n\t\tuint32_t max_ref_divider,\n\t\tuint32_t min_post_divider,\n\t\tuint32_t max_post_divider,\n\t\tuint32_t err_tolerance)\n{\n\tuint32_t ref_divider;\n\tuint32_t post_divider;\n\tuint32_t tolerance;\n\n \n\ttolerance = (pll_settings->adjusted_pix_clk_100hz * err_tolerance) /\n\t\t\t\t\t\t\t\t\t100000;\n\tif (tolerance < CALC_PLL_CLK_SRC_ERR_TOLERANCE)\n\t\ttolerance = CALC_PLL_CLK_SRC_ERR_TOLERANCE;\n\n\tfor (\n\t\t\tpost_divider = max_post_divider;\n\t\t\tpost_divider >= min_post_divider;\n\t\t\t--post_divider) {\n\t\tfor (\n\t\t\t\tref_divider = min_ref_divider;\n\t\t\t\tref_divider <= max_ref_divider;\n\t\t\t\t++ref_divider) {\n\t\t\tif (calc_fb_divider_checking_tolerance(\n\t\t\t\t\tcalc_pll_cs,\n\t\t\t\t\tpll_settings,\n\t\t\t\t\tref_divider,\n\t\t\t\t\tpost_divider,\n\t\t\t\t\ttolerance)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic uint32_t calculate_pixel_clock_pll_dividers(\n\t\tstruct calc_pll_clock_source *calc_pll_cs,\n\t\tstruct pll_settings *pll_settings)\n{\n\tuint32_t err_tolerance;\n\tuint32_t min_post_divider;\n\tuint32_t max_post_divider;\n\tuint32_t min_ref_divider;\n\tuint32_t max_ref_divider;\n\n\tif (pll_settings->adjusted_pix_clk_100hz == 0) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s Bad requested pixel clock\", __func__);\n\t\treturn MAX_PLL_CALC_ERROR;\n\t}\n\n \n\tif (pll_settings->pix_clk_post_divider) {\n\t\tmin_post_divider = pll_settings->pix_clk_post_divider;\n\t\tmax_post_divider = pll_settings->pix_clk_post_divider;\n\t} else {\n\t\tmin_post_divider = calc_pll_cs->min_pix_clock_pll_post_divider;\n\t\tif (min_post_divider * pll_settings->adjusted_pix_clk_100hz <\n\t\t\t\t\t\tcalc_pll_cs->min_vco_khz * 10) {\n\t\t\tmin_post_divider = calc_pll_cs->min_vco_khz * 10 /\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz;\n\t\t\tif ((min_post_divider *\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz) <\n\t\t\t\t\t\tcalc_pll_cs->min_vco_khz * 10)\n\t\t\t\tmin_post_divider++;\n\t\t}\n\n\t\tmax_post_divider = calc_pll_cs->max_pix_clock_pll_post_divider;\n\t\tif (max_post_divider * pll_settings->adjusted_pix_clk_100hz\n\t\t\t\t> calc_pll_cs->max_vco_khz * 10)\n\t\t\tmax_post_divider = calc_pll_cs->max_vco_khz * 10 /\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz;\n\t}\n\n \n\n\tif (pll_settings->reference_divider) {\n\t\tmin_ref_divider = pll_settings->reference_divider;\n\t\tmax_ref_divider = pll_settings->reference_divider;\n\t} else {\n\t\tmin_ref_divider = ((calc_pll_cs->ref_freq_khz\n\t\t\t\t/ calc_pll_cs->max_pll_input_freq_khz)\n\t\t\t\t> calc_pll_cs->min_pll_ref_divider)\n\t\t\t? calc_pll_cs->ref_freq_khz\n\t\t\t\t\t/ calc_pll_cs->max_pll_input_freq_khz\n\t\t\t: calc_pll_cs->min_pll_ref_divider;\n\n\t\tmax_ref_divider = ((calc_pll_cs->ref_freq_khz\n\t\t\t\t/ calc_pll_cs->min_pll_input_freq_khz)\n\t\t\t\t< calc_pll_cs->max_pll_ref_divider)\n\t\t\t? calc_pll_cs->ref_freq_khz /\n\t\t\t\t\tcalc_pll_cs->min_pll_input_freq_khz\n\t\t\t: calc_pll_cs->max_pll_ref_divider;\n\t}\n\n \n\n\tif (min_post_divider > max_post_divider) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s Post divider range is invalid\", __func__);\n\t\treturn MAX_PLL_CALC_ERROR;\n\t}\n\n\tif (min_ref_divider > max_ref_divider) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s Reference divider range is invalid\", __func__);\n\t\treturn MAX_PLL_CALC_ERROR;\n\t}\n\n \n\terr_tolerance = MAX_PLL_CALC_ERROR;\n\n\twhile (!calc_pll_dividers_in_range(\n\t\t\tcalc_pll_cs,\n\t\t\tpll_settings,\n\t\t\tmin_ref_divider,\n\t\t\tmax_ref_divider,\n\t\t\tmin_post_divider,\n\t\t\tmax_post_divider,\n\t\t\terr_tolerance))\n\t\terr_tolerance += (err_tolerance > 10)\n\t\t\t\t? (err_tolerance / 10)\n\t\t\t\t: 1;\n\n\treturn err_tolerance;\n}\n\nstatic bool pll_adjust_pix_clk(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tstruct pll_settings *pll_settings)\n{\n\tuint32_t actual_pix_clk_100hz = 0;\n\tuint32_t requested_clk_100hz = 0;\n\tstruct bp_adjust_pixel_clock_parameters bp_adjust_pixel_clock_params = {\n\t\t\t\t\t\t\t0 };\n\tenum bp_result bp_result;\n\tswitch (pix_clk_params->signal_type) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A: {\n\t\trequested_clk_100hz = pix_clk_params->requested_pix_clk_100hz;\n\t\tif (pix_clk_params->pixel_encoding != PIXEL_ENCODING_YCBCR422) {\n\t\t\tswitch (pix_clk_params->color_depth) {\n\t\t\tcase COLOR_DEPTH_101010:\n\t\t\t\trequested_clk_100hz = (requested_clk_100hz * 5) >> 2;\n\t\t\t\tbreak;  \n\t\t\tcase COLOR_DEPTH_121212:\n\t\t\t\trequested_clk_100hz = (requested_clk_100hz * 6) >> 2;\n\t\t\t\tbreak;  \n\t\t\tcase COLOR_DEPTH_161616:\n\t\t\t\trequested_clk_100hz = requested_clk_100hz * 2;\n\t\t\t\tbreak;  \n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tactual_pix_clk_100hz = requested_clk_100hz;\n\t}\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\tcase SIGNAL_TYPE_EDP:\n\t\trequested_clk_100hz = pix_clk_params->requested_sym_clk * 10;\n\t\tactual_pix_clk_100hz = pix_clk_params->requested_pix_clk_100hz;\n\t\tbreak;\n\n\tdefault:\n\t\trequested_clk_100hz = pix_clk_params->requested_pix_clk_100hz;\n\t\tactual_pix_clk_100hz = pix_clk_params->requested_pix_clk_100hz;\n\t\tbreak;\n\t}\n\n\tbp_adjust_pixel_clock_params.pixel_clock = requested_clk_100hz / 10;\n\tbp_adjust_pixel_clock_params.\n\t\tencoder_object_id = pix_clk_params->encoder_object_id;\n\tbp_adjust_pixel_clock_params.signal_type = pix_clk_params->signal_type;\n\tbp_adjust_pixel_clock_params.\n\t\tss_enable = pix_clk_params->flags.ENABLE_SS;\n\tbp_result = clk_src->bios->funcs->adjust_pixel_clock(\n\t\t\tclk_src->bios, &bp_adjust_pixel_clock_params);\n\tif (bp_result == BP_RESULT_OK) {\n\t\tpll_settings->actual_pix_clk_100hz = actual_pix_clk_100hz;\n\t\tpll_settings->adjusted_pix_clk_100hz =\n\t\t\tbp_adjust_pixel_clock_params.adjusted_pixel_clock * 10;\n\t\tpll_settings->reference_divider =\n\t\t\tbp_adjust_pixel_clock_params.reference_divider;\n\t\tpll_settings->pix_clk_post_divider =\n\t\t\tbp_adjust_pixel_clock_params.pixel_clock_post_divider;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\nstatic uint32_t dce110_get_pix_clk_dividers_helper (\n\t\tstruct dce110_clk_src *clk_src,\n\t\tstruct pll_settings *pll_settings,\n\t\tstruct pixel_clk_params *pix_clk_params)\n{\n\tuint32_t field = 0;\n\tuint32_t pll_calc_error = MAX_PLL_CALC_ERROR;\n\tDC_LOGGER_INIT();\n\t \n\tREG_GET(PLL_CNTL, PLL_REF_DIV_SRC, &field);\n\tpll_settings->use_external_clk = (field > 1);\n\n\t \n\tif ((pix_clk_params->flags.ENABLE_SS) ||\n\t\t\t(dc_is_dp_signal(pix_clk_params->signal_type))) {\n\n\t\tconst struct spread_spectrum_data *ss_data = get_ss_data_entry(\n\t\t\t\t\tclk_src,\n\t\t\t\t\tpix_clk_params->signal_type,\n\t\t\t\t\tpll_settings->adjusted_pix_clk_100hz / 10);\n\n\t\tif (NULL != ss_data)\n\t\t\tpll_settings->ss_percentage = ss_data->percentage;\n\t}\n\n\t \n\tif (!pll_adjust_pix_clk(clk_src, pix_clk_params, pll_settings)) {\n\t\t \n\t\tDC_LOG_ERROR(\n\t\t\t\"%s: Failed to adjust pixel clock!!\", __func__);\n\t\tpll_settings->actual_pix_clk_100hz =\n\t\t\t\tpix_clk_params->requested_pix_clk_100hz;\n\t\tpll_settings->adjusted_pix_clk_100hz =\n\t\t\t\tpix_clk_params->requested_pix_clk_100hz;\n\n\t\tif (dc_is_dp_signal(pix_clk_params->signal_type))\n\t\t\tpll_settings->adjusted_pix_clk_100hz = 1000000;\n\t}\n\n\t \n\tif (pix_clk_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\t \n\t\tpll_calc_error =\n\t\t\tcalculate_pixel_clock_pll_dividers(\n\t\t\t\t\t&clk_src->calc_pll_hdmi,\n\t\t\t\t\tpll_settings);\n\telse\n\t\t \n\t\tpll_calc_error =\n\t\t\tcalculate_pixel_clock_pll_dividers(\n\t\t\t\t\t&clk_src->calc_pll,\n\t\t\t\t\tpll_settings);\n\n\treturn pll_calc_error;\n}\n\nstatic void dce112_get_pix_clk_dividers_helper (\n\t\tstruct dce110_clk_src *clk_src,\n\t\tstruct pll_settings *pll_settings,\n\t\tstruct pixel_clk_params *pix_clk_params)\n{\n\tuint32_t actual_pixel_clock_100hz;\n\n\tactual_pixel_clock_100hz = pix_clk_params->requested_pix_clk_100hz;\n\t \n\tif (pix_clk_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tswitch (pix_clk_params->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tactual_pixel_clock_100hz = (actual_pixel_clock_100hz * 5) >> 2;\n\t\t\tactual_pixel_clock_100hz -= actual_pixel_clock_100hz % 10;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tactual_pixel_clock_100hz = (actual_pixel_clock_100hz * 6) >> 2;\n\t\t\tactual_pixel_clock_100hz -= actual_pixel_clock_100hz % 10;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tactual_pixel_clock_100hz = actual_pixel_clock_100hz * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpll_settings->actual_pix_clk_100hz = actual_pixel_clock_100hz;\n\tpll_settings->adjusted_pix_clk_100hz = actual_pixel_clock_100hz;\n\tpll_settings->calculated_pix_clk_100hz = pix_clk_params->requested_pix_clk_100hz;\n}\n\nstatic uint32_t dce110_get_pix_clk_dividers(\n\t\tstruct clock_source *cs,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(cs);\n\tuint32_t pll_calc_error = MAX_PLL_CALC_ERROR;\n\tDC_LOGGER_INIT();\n\n\tif (pix_clk_params == NULL || pll_settings == NULL\n\t\t\t|| pix_clk_params->requested_pix_clk_100hz == 0) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s: Invalid parameters!!\\n\", __func__);\n\t\treturn pll_calc_error;\n\t}\n\n\tmemset(pll_settings, 0, sizeof(*pll_settings));\n\n\tif (cs->id == CLOCK_SOURCE_ID_DP_DTO ||\n\t\t\tcs->id == CLOCK_SOURCE_ID_EXTERNAL) {\n\t\tpll_settings->adjusted_pix_clk_100hz = clk_src->ext_clk_khz * 10;\n\t\tpll_settings->calculated_pix_clk_100hz = clk_src->ext_clk_khz * 10;\n\t\tpll_settings->actual_pix_clk_100hz =\n\t\t\t\t\tpix_clk_params->requested_pix_clk_100hz;\n\t\treturn 0;\n\t}\n\n\tpll_calc_error = dce110_get_pix_clk_dividers_helper(clk_src,\n\t\t\tpll_settings, pix_clk_params);\n\n\treturn pll_calc_error;\n}\n\nstatic uint32_t dce112_get_pix_clk_dividers(\n\t\tstruct clock_source *cs,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(cs);\n\tDC_LOGGER_INIT();\n\n\tif (pix_clk_params == NULL || pll_settings == NULL\n\t\t\t|| pix_clk_params->requested_pix_clk_100hz == 0) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s: Invalid parameters!!\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmemset(pll_settings, 0, sizeof(*pll_settings));\n\n\tif (cs->id == CLOCK_SOURCE_ID_DP_DTO ||\n\t\t\tcs->id == CLOCK_SOURCE_ID_EXTERNAL) {\n\t\tpll_settings->adjusted_pix_clk_100hz = clk_src->ext_clk_khz * 10;\n\t\tpll_settings->calculated_pix_clk_100hz = clk_src->ext_clk_khz * 10;\n\t\tpll_settings->actual_pix_clk_100hz =\n\t\t\t\t\tpix_clk_params->requested_pix_clk_100hz;\n\t\treturn -1;\n\t}\n\n\tdce112_get_pix_clk_dividers_helper(clk_src,\n\t\t\tpll_settings, pix_clk_params);\n\n\treturn 0;\n}\n\nstatic bool disable_spread_spectrum(struct dce110_clk_src *clk_src)\n{\n\tenum bp_result result;\n\tstruct bp_spread_spectrum_parameters bp_ss_params = {0};\n\n\tbp_ss_params.pll_id = clk_src->base.id;\n\n\t \n\tresult = clk_src->bios->funcs->enable_spread_spectrum_on_ppll(\n\t\t\tclk_src->bios,\n\t\t\t&bp_ss_params,\n\t\t\tfalse);\n\n\treturn result == BP_RESULT_OK;\n}\n\nstatic bool calculate_ss(\n\t\tconst struct pll_settings *pll_settings,\n\t\tconst struct spread_spectrum_data *ss_data,\n\t\tstruct delta_sigma_data *ds_data)\n{\n\tstruct fixed31_32 fb_div;\n\tstruct fixed31_32 ss_amount;\n\tstruct fixed31_32 ss_nslip_amount;\n\tstruct fixed31_32 ss_ds_frac_amount;\n\tstruct fixed31_32 ss_step_size;\n\tstruct fixed31_32 modulation_time;\n\n\tif (ds_data == NULL)\n\t\treturn false;\n\tif (ss_data == NULL)\n\t\treturn false;\n\tif (ss_data->percentage == 0)\n\t\treturn false;\n\tif (pll_settings == NULL)\n\t\treturn false;\n\n\tmemset(ds_data, 0, sizeof(struct delta_sigma_data));\n\n\t \n\t \n\tfb_div  = dc_fixpt_from_fraction(\n\t\tpll_settings->fract_feedback_divider, 1000000);\n\tfb_div = dc_fixpt_add_int(fb_div, pll_settings->feedback_divider);\n\n\tds_data->ds_frac_amount = 0;\n\t \n\tss_amount = dc_fixpt_mul(\n\t\tfb_div, dc_fixpt_from_fraction(ss_data->percentage,\n\t\t\t\t\t100 * ss_data->percentage_divider));\n\tds_data->feedback_amount = dc_fixpt_floor(ss_amount);\n\n\tss_nslip_amount = dc_fixpt_sub(ss_amount,\n\t\tdc_fixpt_from_int(ds_data->feedback_amount));\n\tss_nslip_amount = dc_fixpt_mul_int(ss_nslip_amount, 10);\n\tds_data->nfrac_amount = dc_fixpt_floor(ss_nslip_amount);\n\n\tss_ds_frac_amount = dc_fixpt_sub(ss_nslip_amount,\n\t\tdc_fixpt_from_int(ds_data->nfrac_amount));\n\tss_ds_frac_amount = dc_fixpt_mul_int(ss_ds_frac_amount, 65536);\n\tds_data->ds_frac_amount = dc_fixpt_floor(ss_ds_frac_amount);\n\n\t \n\tmodulation_time = dc_fixpt_from_fraction(\n\t\tpll_settings->reference_freq * 1000,\n\t\tpll_settings->reference_divider * ss_data->modulation_freq_hz);\n\n\tif (ss_data->flags.CENTER_SPREAD)\n\t\tmodulation_time = dc_fixpt_div_int(modulation_time, 4);\n\telse\n\t\tmodulation_time = dc_fixpt_div_int(modulation_time, 2);\n\n\tss_step_size = dc_fixpt_div(ss_amount, modulation_time);\n\t \n\tss_step_size = dc_fixpt_mul_int(ss_step_size, 65536 * 10);\n\tds_data->ds_frac_size =  dc_fixpt_floor(ss_step_size);\n\n\treturn true;\n}\n\nstatic bool enable_spread_spectrum(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tenum signal_type signal, struct pll_settings *pll_settings)\n{\n\tstruct bp_spread_spectrum_parameters bp_params = {0};\n\tstruct delta_sigma_data d_s_data;\n\tconst struct spread_spectrum_data *ss_data = NULL;\n\n\tss_data = get_ss_data_entry(\n\t\t\tclk_src,\n\t\t\tsignal,\n\t\t\tpll_settings->calculated_pix_clk_100hz / 10);\n\n \n \n\tif (ss_data != NULL && pll_settings->ss_percentage != 0) {\n\t\tif (calculate_ss(pll_settings, ss_data, &d_s_data)) {\n\t\t\tbp_params.ds.feedback_amount =\n\t\t\t\t\td_s_data.feedback_amount;\n\t\t\tbp_params.ds.nfrac_amount =\n\t\t\t\t\td_s_data.nfrac_amount;\n\t\t\tbp_params.ds.ds_frac_size = d_s_data.ds_frac_size;\n\t\t\tbp_params.ds_frac_amount =\n\t\t\t\t\td_s_data.ds_frac_amount;\n\t\t\tbp_params.flags.DS_TYPE = 1;\n\t\t\tbp_params.pll_id = clk_src->base.id;\n\t\t\tbp_params.percentage = ss_data->percentage;\n\t\t\tif (ss_data->flags.CENTER_SPREAD)\n\t\t\t\tbp_params.flags.CENTER_SPREAD = 1;\n\t\t\tif (ss_data->flags.EXTERNAL_SS)\n\t\t\t\tbp_params.flags.EXTERNAL_SS = 1;\n\n\t\t\tif (BP_RESULT_OK !=\n\t\t\t\tclk_src->bios->funcs->\n\t\t\t\t\tenable_spread_spectrum_on_ppll(\n\t\t\t\t\t\t\tclk_src->bios,\n\t\t\t\t\t\t\t&bp_params,\n\t\t\t\t\t\t\ttrue))\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void dce110_program_pixel_clk_resync(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tenum signal_type signal_type,\n\t\tenum dc_color_depth colordepth)\n{\n\tREG_UPDATE(RESYNC_CNTL,\n\t\t\tDCCG_DEEP_COLOR_CNTL1, 0);\n\t \n\tif (signal_type != SIGNAL_TYPE_HDMI_TYPE_A)\n\t\treturn;\n\n\tswitch (colordepth) {\n\tcase COLOR_DEPTH_888:\n\t\tREG_UPDATE(RESYNC_CNTL,\n\t\t\t\tDCCG_DEEP_COLOR_CNTL1, 0);\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tREG_UPDATE(RESYNC_CNTL,\n\t\t\t\tDCCG_DEEP_COLOR_CNTL1, 1);\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tREG_UPDATE(RESYNC_CNTL,\n\t\t\t\tDCCG_DEEP_COLOR_CNTL1, 2);\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tREG_UPDATE(RESYNC_CNTL,\n\t\t\t\tDCCG_DEEP_COLOR_CNTL1, 3);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dce112_program_pixel_clk_resync(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tenum signal_type signal_type,\n\t\tenum dc_color_depth colordepth,\n\t\tbool enable_ycbcr420)\n{\n\tuint32_t deep_color_cntl = 0;\n\tuint32_t double_rate_enable = 0;\n\n\t \n\tif (signal_type == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tdouble_rate_enable = enable_ycbcr420 ? 1 : 0;\n\n\t\tswitch (colordepth) {\n\t\tcase COLOR_DEPTH_888:\n\t\t\tdeep_color_cntl = 0;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tdeep_color_cntl = 1;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tdeep_color_cntl = 2;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tdeep_color_cntl = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (clk_src->cs_mask->PHYPLLA_PIXCLK_DOUBLE_RATE_ENABLE)\n\t\tREG_UPDATE_2(PIXCLK_RESYNC_CNTL,\n\t\t\t\tPHYPLLA_DCCG_DEEP_COLOR_CNTL, deep_color_cntl,\n\t\t\t\tPHYPLLA_PIXCLK_DOUBLE_RATE_ENABLE, double_rate_enable);\n\telse\n\t\tREG_UPDATE(PIXCLK_RESYNC_CNTL,\n\t\t\t\tPHYPLLA_DCCG_DEEP_COLOR_CNTL, deep_color_cntl);\n\n}\n\nstatic bool dce110_program_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tenum dp_link_encoding encoding,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tstruct bp_pixel_clock_parameters bp_pc_params = {0};\n\n\t \n\tif (clock_source->id != CLOCK_SOURCE_ID_EXTERNAL &&\n\t\t\t!dc_is_dp_signal(pix_clk_params->signal_type) &&\n\t\t\tclock_source->ctx->dce_version <= DCE_VERSION_11_0)\n\t\tdisable_spread_spectrum(clk_src);\n\n\t \n\tbp_pc_params.controller_id = pix_clk_params->controller_id;\n\tbp_pc_params.pll_id = clock_source->id;\n\tbp_pc_params.target_pixel_clock_100hz = pll_settings->actual_pix_clk_100hz;\n\tbp_pc_params.encoder_object_id = pix_clk_params->encoder_object_id;\n\tbp_pc_params.signal_type = pix_clk_params->signal_type;\n\n\tbp_pc_params.reference_divider = pll_settings->reference_divider;\n\tbp_pc_params.feedback_divider = pll_settings->feedback_divider;\n\tbp_pc_params.fractional_feedback_divider =\n\t\t\tpll_settings->fract_feedback_divider;\n\tbp_pc_params.pixel_clock_post_divider =\n\t\t\tpll_settings->pix_clk_post_divider;\n\tbp_pc_params.flags.SET_EXTERNAL_REF_DIV_SRC =\n\t\t\t\t\tpll_settings->use_external_clk;\n\n\tswitch (pix_clk_params->color_depth) {\n\tcase COLOR_DEPTH_101010:\n\t\tbp_pc_params.color_depth = TRANSMITTER_COLOR_DEPTH_30;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbp_pc_params.color_depth = TRANSMITTER_COLOR_DEPTH_36;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tbp_pc_params.color_depth = TRANSMITTER_COLOR_DEPTH_48;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (clk_src->bios->funcs->set_pixel_clock(\n\t\t\tclk_src->bios, &bp_pc_params) != BP_RESULT_OK)\n\t\treturn false;\n\t \n\tif (clock_source->id != CLOCK_SOURCE_ID_EXTERNAL\n\t\t\t&& !dc_is_dp_signal(pix_clk_params->signal_type)) {\n\n\t\tif (pix_clk_params->flags.ENABLE_SS)\n\t\t\tif (!enable_spread_spectrum(clk_src,\n\t\t\t\t\t\t\tpix_clk_params->signal_type,\n\t\t\t\t\t\t\tpll_settings))\n\t\t\t\treturn false;\n\n\t\t \n\t\tdce110_program_pixel_clk_resync(clk_src,\n\t\t\t\t\tpix_clk_params->signal_type,\n\t\t\t\t\tpix_clk_params->color_depth);\n\t}\n\n\treturn true;\n}\n\nstatic bool dce112_program_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tenum dp_link_encoding encoding,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tstruct bp_pixel_clock_parameters bp_pc_params = {0};\n\n\t \n\tif (clock_source->id != CLOCK_SOURCE_ID_EXTERNAL &&\n\t\t\t!dc_is_dp_signal(pix_clk_params->signal_type) &&\n\t\t\tclock_source->ctx->dce_version <= DCE_VERSION_11_0)\n\t\tdisable_spread_spectrum(clk_src);\n\n\t \n\tbp_pc_params.controller_id = pix_clk_params->controller_id;\n\tbp_pc_params.pll_id = clock_source->id;\n\tbp_pc_params.target_pixel_clock_100hz = pll_settings->actual_pix_clk_100hz;\n\tbp_pc_params.encoder_object_id = pix_clk_params->encoder_object_id;\n\tbp_pc_params.signal_type = pix_clk_params->signal_type;\n\n\tif (clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {\n\t\tbp_pc_params.flags.SET_GENLOCK_REF_DIV_SRC =\n\t\t\t\t\t\tpll_settings->use_external_clk;\n\t\tbp_pc_params.flags.SET_XTALIN_REF_SRC =\n\t\t\t\t\t\t!pll_settings->use_external_clk;\n\t\tif (pix_clk_params->flags.SUPPORT_YCBCR420) {\n\t\t\tbp_pc_params.flags.SUPPORT_YUV_420 = 1;\n\t\t}\n\t}\n\tif (clk_src->bios->funcs->set_pixel_clock(\n\t\t\tclk_src->bios, &bp_pc_params) != BP_RESULT_OK)\n\t\treturn false;\n\t \n\tif (clock_source->id != CLOCK_SOURCE_ID_DP_DTO)\n\t\tdce112_program_pixel_clk_resync(clk_src,\n\t\t\t\t\tpix_clk_params->signal_type,\n\t\t\t\t\tpix_clk_params->color_depth,\n\t\t\t\t\tpix_clk_params->flags.SUPPORT_YCBCR420);\n\n\treturn true;\n}\n\nstatic bool dcn31_program_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tenum dp_link_encoding encoding,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tunsigned int inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;\n\tunsigned int dp_dto_ref_khz = clock_source->ctx->dc->clk_mgr->dprefclk_khz;\n\tconst struct pixel_rate_range_table_entry *e =\n\t\t\tlook_up_in_video_optimized_rate_tlb(pix_clk_params->requested_pix_clk_100hz / 10);\n\tstruct bp_pixel_clock_parameters bp_pc_params = {0};\n\tenum transmitter_color_depth bp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_24;\n\t\n\tif (dc_is_dp_signal(pix_clk_params->signal_type) || dc_is_virtual_signal(pix_clk_params->signal_type)) {\n\t\tif (e) {\n\t\t\t \n\t\t\tREG_WRITE(PHASE[inst], e->target_pixel_rate_khz * e->mult_factor);\n\t\t\tREG_WRITE(MODULO[inst], dp_dto_ref_khz * e->div_factor);\n\t\t} else {\n\t\t\t \n\t\t\tREG_WRITE(PHASE[inst], pll_settings->actual_pix_clk_100hz * 100);\n\t\t\tREG_WRITE(MODULO[inst], dp_dto_ref_khz * 1000);\n\t\t}\n\t\t \n\t\tif (clk_src->cs_mask->PIPE0_DTO_SRC_SEL)\n\t\t\tif (encoding == DP_128b_132b_ENCODING)\n\t\t\t\tREG_UPDATE_2(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\t\tDP_DTO0_ENABLE, 1,\n\t\t\t\t\t\tPIPE0_DTO_SRC_SEL, 2);\n\t\t\telse\n\t\t\t\tREG_UPDATE_2(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\t\tDP_DTO0_ENABLE, 1,\n\t\t\t\t\t\tPIPE0_DTO_SRC_SEL, 1);\n\t\telse\n\t\t\tREG_UPDATE(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\tDP_DTO0_ENABLE, 1);\n\t} else {\n\n\t\tif (clk_src->cs_mask->PIPE0_DTO_SRC_SEL)\n\t\t\tREG_UPDATE(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\tPIPE0_DTO_SRC_SEL, 0);\n\n\t\t \n\t\tbp_pc_params.controller_id = pix_clk_params->controller_id;\n\t\tbp_pc_params.pll_id = clock_source->id;\n\t\tbp_pc_params.target_pixel_clock_100hz = pll_settings->actual_pix_clk_100hz;\n\t\tbp_pc_params.encoder_object_id = pix_clk_params->encoder_object_id;\n\t\tbp_pc_params.signal_type = pix_clk_params->signal_type;\n\n\t\t\n\t\tif (pix_clk_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\t\tswitch (pix_clk_params->color_depth) {\n\t\t\tcase COLOR_DEPTH_888:\n\t\t\t\tbp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_24;\n\t\t\t\tbreak;\n\t\t\tcase COLOR_DEPTH_101010:\n\t\t\t\tbp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_30;\n\t\t\t\tbreak;\n\t\t\tcase COLOR_DEPTH_121212:\n\t\t\t\tbp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_36;\n\t\t\t\tbreak;\n\t\t\tcase COLOR_DEPTH_161616:\n\t\t\t\tbp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_48;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbp_pc_colour_depth = TRANSMITTER_COLOR_DEPTH_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp_pc_params.color_depth = bp_pc_colour_depth;\n\t\t}\n\n\t\tif (clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {\n\t\t\tbp_pc_params.flags.SET_GENLOCK_REF_DIV_SRC =\n\t\t\t\t\t\t\tpll_settings->use_external_clk;\n\t\t\tbp_pc_params.flags.SET_XTALIN_REF_SRC =\n\t\t\t\t\t\t\t!pll_settings->use_external_clk;\n\t\t\tif (pix_clk_params->flags.SUPPORT_YCBCR420) {\n\t\t\t\tbp_pc_params.flags.SUPPORT_YUV_420 = 1;\n\t\t\t}\n\t\t}\n\t\tif (clk_src->bios->funcs->set_pixel_clock(\n\t\t\t\tclk_src->bios, &bp_pc_params) != BP_RESULT_OK)\n\t\t\treturn false;\n\t\t \n\t\tif (clock_source->id != CLOCK_SOURCE_ID_DP_DTO)\n\t\t\tdce112_program_pixel_clk_resync(clk_src,\n\t\t\t\t\t\tpix_clk_params->signal_type,\n\t\t\t\t\t\tpix_clk_params->color_depth,\n\t\t\t\t\t\tpix_clk_params->flags.SUPPORT_YCBCR420);\n\t}\n\n\treturn true;\n}\n\nstatic bool dce110_clock_source_power_down(\n\t\tstruct clock_source *clk_src)\n{\n\tstruct dce110_clk_src *dce110_clk_src = TO_DCE110_CLK_SRC(clk_src);\n\tenum bp_result bp_result;\n\tstruct bp_pixel_clock_parameters bp_pixel_clock_params = {0};\n\n\tif (clk_src->dp_clk_src)\n\t\treturn true;\n\n\t \n\tbp_pixel_clock_params.controller_id = CONTROLLER_ID_UNDEFINED;\n\tbp_pixel_clock_params.pll_id = clk_src->id;\n\tbp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;\n\n\t \n\tbp_result = dce110_clk_src->bios->funcs->set_pixel_clock(\n\t\t\tdce110_clk_src->bios,\n\t\t\t&bp_pixel_clock_params);\n\n\treturn bp_result == BP_RESULT_OK;\n}\n\nstatic bool get_pixel_clk_frequency_100hz(\n\t\tconst struct clock_source *clock_source,\n\t\tunsigned int inst,\n\t\tunsigned int *pixel_clk_khz)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tunsigned int clock_hz = 0;\n\tunsigned int modulo_hz = 0;\n\n\tif (clock_source->id == CLOCK_SOURCE_ID_DP_DTO) {\n\t\tclock_hz = REG_READ(PHASE[inst]);\n\n\t\tif (clock_source->ctx->dc->hwss.enable_vblanks_synchronization &&\n\t\t\tclock_source->ctx->dc->config.vblank_alignment_max_frame_time_diff > 0) {\n\t\t\t \n\t\t\tmodulo_hz = REG_READ(MODULO[inst]);\n\t\t\tif (modulo_hz)\n\t\t\t\t*pixel_clk_khz = div_u64((uint64_t)clock_hz*\n\t\t\t\t\tclock_source->ctx->dc->clk_mgr->dprefclk_khz*10,\n\t\t\t\t\tmodulo_hz);\n\t\t\telse\n\t\t\t\t*pixel_clk_khz = 0;\n\t\t} else {\n\t\t\t \n\t\t\t*pixel_clk_khz = clock_hz / 100;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nconst struct pixel_rate_range_table_entry video_optimized_pixel_rates[] = {\n\t\n\t{25170, 25180, 25200, 1000, 1001},\t\n\t{59340, 59350, 59400, 1000, 1001},\t\n\t{74170, 74180, 74250, 1000, 1001},\t\n\t{89910, 90000, 90000, 1000, 1001},\t\n\t{125870, 125880, 126000, 1000, 1001},\t\n\t{148350, 148360, 148500, 1000, 1001},\t\n\t{167830, 167840, 168000, 1000, 1001},\t\n\t{222520, 222530, 222750, 1000, 1001},\t\n\t{257140, 257150, 257400, 1000, 1001},\t\n\t{296700, 296710, 297000, 1000, 1001},\t\n\t{342850, 342860, 343200, 1000, 1001},\t\n\t{395600, 395610, 396000, 1000, 1001},\t\n\t{409090, 409100, 409500, 1000, 1001},\t\n\t{445050, 445060, 445500, 1000, 1001},\t\n\t{467530, 467540, 468000, 1000, 1001},\t\n\t{519230, 519240, 519750, 1000, 1001},\t\n\t{525970, 525980, 526500, 1000, 1001},\t\n\t{545450, 545460, 546000, 1000, 1001},\t\n\t{593400, 593410, 594000, 1000, 1001},\t\n\t{623370, 623380, 624000, 1000, 1001},\t\n\t{692300, 692310, 693000, 1000, 1001},\t\n\t{701290, 701300, 702000, 1000, 1001},\t\n\t{791200, 791210, 792000, 1000, 1001},\t\n\t{890100, 890110, 891000, 1000, 1001},\t\n\t{1186810, 1186820, 1188000, 1000, 1001},\n\n\t\n\t{27020, 27030, 27000, 1001, 1000}, \n\t{54050, 54060, 54000, 1001, 1000}, \n\t{108100, 108110, 108000, 1001, 1000},\n};\n\nconst struct pixel_rate_range_table_entry *look_up_in_video_optimized_rate_tlb(\n\t\tunsigned int pixel_rate_khz)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_ELEMENTS(video_optimized_pixel_rates); i++) {\n\t\tconst struct pixel_rate_range_table_entry *e = &video_optimized_pixel_rates[i];\n\n\t\tif (e->range_min_khz <= pixel_rate_khz && pixel_rate_khz <= e->range_max_khz) {\n\t\t\treturn e;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic bool dcn20_program_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tenum dp_link_encoding encoding,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tunsigned int inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;\n\n\tdce112_program_pix_clk(clock_source, pix_clk_params, encoding, pll_settings);\n\n\tif (clock_source->ctx->dc->hwss.enable_vblanks_synchronization &&\n\t\t\tclock_source->ctx->dc->config.vblank_alignment_max_frame_time_diff > 0) {\n\t\t \n\t\tREG_WRITE(MODULO[inst],\n\t\t\tclock_source->ctx->dc->clk_mgr->dprefclk_khz*1000);\n\t}\n\treturn true;\n}\n\nstatic bool dcn20_override_dp_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tunsigned int inst,\n\t\tunsigned int pixel_clk,\n\t\tunsigned int ref_clk)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\n\tREG_UPDATE(PIXEL_RATE_CNTL[inst], DP_DTO0_ENABLE, 0);\n\tREG_WRITE(PHASE[inst], pixel_clk);\n\tREG_WRITE(MODULO[inst], ref_clk);\n\tREG_UPDATE(PIXEL_RATE_CNTL[inst], DP_DTO0_ENABLE, 1);\n\treturn true;\n}\n\nstatic const struct clock_source_funcs dcn20_clk_src_funcs = {\n\t.cs_power_down = dce110_clock_source_power_down,\n\t.program_pix_clk = dcn20_program_pix_clk,\n\t.get_pix_clk_dividers = dce112_get_pix_clk_dividers,\n\t.get_pixel_clk_frequency_100hz = get_pixel_clk_frequency_100hz,\n\t.override_dp_pix_clk = dcn20_override_dp_pix_clk\n};\n\nstatic bool dcn3_program_pix_clk(\n\t\tstruct clock_source *clock_source,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tenum dp_link_encoding encoding,\n\t\tstruct pll_settings *pll_settings)\n{\n\tstruct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(clock_source);\n\tunsigned int inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;\n\tunsigned int dp_dto_ref_khz = clock_source->ctx->dc->clk_mgr->dprefclk_khz;\n\tconst struct pixel_rate_range_table_entry *e =\n\t\t\tlook_up_in_video_optimized_rate_tlb(pix_clk_params->requested_pix_clk_100hz / 10);\n\n\t\n\tif (dc_is_dp_signal(pix_clk_params->signal_type)) {\n\t\tif (e) {\n\t\t\t \n\t\t\tREG_WRITE(PHASE[inst], e->target_pixel_rate_khz * e->mult_factor);\n\t\t\tREG_WRITE(MODULO[inst], dp_dto_ref_khz * e->div_factor);\n\t\t} else {\n\t\t\t \n\t\t\tREG_WRITE(PHASE[inst], pll_settings->actual_pix_clk_100hz * 100);\n\t\t\tREG_WRITE(MODULO[inst], dp_dto_ref_khz * 1000);\n\t\t}\n\t\t \n\t\tif (clk_src->cs_mask->PIPE0_DTO_SRC_SEL)\n\t\t\tREG_UPDATE_2(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\tDP_DTO0_ENABLE, 1,\n\t\t\t\t\tPIPE0_DTO_SRC_SEL, 1);\n\t\telse\n\t\t\tREG_UPDATE(PIXEL_RATE_CNTL[inst],\n\t\t\t\t\tDP_DTO0_ENABLE, 1);\n\t} else\n\t\t\n\t\tdce112_program_pix_clk(clock_source, pix_clk_params, encoding, pll_settings);\n\n\treturn true;\n}\n\nstatic uint32_t dcn3_get_pix_clk_dividers(\n\t\tstruct clock_source *cs,\n\t\tstruct pixel_clk_params *pix_clk_params,\n\t\tstruct pll_settings *pll_settings)\n{\n\tunsigned long long actual_pix_clk_100Hz = pix_clk_params ? pix_clk_params->requested_pix_clk_100hz : 0;\n\n\tDC_LOGGER_INIT();\n\n\tif (pix_clk_params == NULL || pll_settings == NULL\n\t\t\t|| pix_clk_params->requested_pix_clk_100hz == 0) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"%s: Invalid parameters!!\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmemset(pll_settings, 0, sizeof(*pll_settings));\n\t \n\tif (pix_clk_params->signal_type == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tswitch (pix_clk_params->color_depth) {\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tactual_pix_clk_100Hz = (actual_pix_clk_100Hz * 5) >> 2;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tactual_pix_clk_100Hz = (actual_pix_clk_100Hz * 6) >> 2;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tactual_pix_clk_100Hz = actual_pix_clk_100Hz * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpll_settings->actual_pix_clk_100hz = (unsigned int) actual_pix_clk_100Hz;\n\tpll_settings->adjusted_pix_clk_100hz = (unsigned int) actual_pix_clk_100Hz;\n\tpll_settings->calculated_pix_clk_100hz = (unsigned int) actual_pix_clk_100Hz;\n\n\treturn 0;\n}\n\nstatic const struct clock_source_funcs dcn3_clk_src_funcs = {\n\t.cs_power_down = dce110_clock_source_power_down,\n\t.program_pix_clk = dcn3_program_pix_clk,\n\t.get_pix_clk_dividers = dcn3_get_pix_clk_dividers,\n\t.get_pixel_clk_frequency_100hz = get_pixel_clk_frequency_100hz\n};\n\nstatic const struct clock_source_funcs dcn31_clk_src_funcs = {\n\t.cs_power_down = dce110_clock_source_power_down,\n\t.program_pix_clk = dcn31_program_pix_clk,\n\t.get_pix_clk_dividers = dcn3_get_pix_clk_dividers,\n\t.get_pixel_clk_frequency_100hz = get_pixel_clk_frequency_100hz\n};\n\n \n \n \n\nstatic const struct clock_source_funcs dce112_clk_src_funcs = {\n\t.cs_power_down = dce110_clock_source_power_down,\n\t.program_pix_clk = dce112_program_pix_clk,\n\t.get_pix_clk_dividers = dce112_get_pix_clk_dividers,\n\t.get_pixel_clk_frequency_100hz = get_pixel_clk_frequency_100hz\n};\nstatic const struct clock_source_funcs dce110_clk_src_funcs = {\n\t.cs_power_down = dce110_clock_source_power_down,\n\t.program_pix_clk = dce110_program_pix_clk,\n\t.get_pix_clk_dividers = dce110_get_pix_clk_dividers,\n\t.get_pixel_clk_frequency_100hz = get_pixel_clk_frequency_100hz\n};\n\n\nstatic void get_ss_info_from_atombios(\n\t\tstruct dce110_clk_src *clk_src,\n\t\tenum as_signal_type as_signal,\n\t\tstruct spread_spectrum_data *spread_spectrum_data[],\n\t\tuint32_t *ss_entries_num)\n{\n\tenum bp_result bp_result = BP_RESULT_FAILURE;\n\tstruct spread_spectrum_info *ss_info;\n\tstruct spread_spectrum_data *ss_data;\n\tstruct spread_spectrum_info *ss_info_cur;\n\tstruct spread_spectrum_data *ss_data_cur;\n\tuint32_t i;\n\tDC_LOGGER_INIT();\n\tif (ss_entries_num == NULL) {\n\t\tDC_LOG_SYNC(\n\t\t\t\"Invalid entry !!!\\n\");\n\t\treturn;\n\t}\n\tif (spread_spectrum_data == NULL) {\n\t\tDC_LOG_SYNC(\n\t\t\t\"Invalid array pointer!!!\\n\");\n\t\treturn;\n\t}\n\n\tspread_spectrum_data[0] = NULL;\n\t*ss_entries_num = 0;\n\n\t*ss_entries_num = clk_src->bios->funcs->get_ss_entry_number(\n\t\t\tclk_src->bios,\n\t\t\tas_signal);\n\n\tif (*ss_entries_num == 0)\n\t\treturn;\n\n\tss_info = kcalloc(*ss_entries_num,\n\t\t\t  sizeof(struct spread_spectrum_info),\n\t\t\t  GFP_KERNEL);\n\tss_info_cur = ss_info;\n\tif (ss_info == NULL)\n\t\treturn;\n\n\tss_data = kcalloc(*ss_entries_num,\n\t\t\t  sizeof(struct spread_spectrum_data),\n\t\t\t  GFP_KERNEL);\n\tif (ss_data == NULL)\n\t\tgoto out_free_info;\n\n\tfor (i = 0, ss_info_cur = ss_info;\n\t\ti < (*ss_entries_num);\n\t\t++i, ++ss_info_cur) {\n\n\t\tbp_result = clk_src->bios->funcs->get_spread_spectrum_info(\n\t\t\t\tclk_src->bios,\n\t\t\t\tas_signal,\n\t\t\t\ti,\n\t\t\t\tss_info_cur);\n\n\t\tif (bp_result != BP_RESULT_OK)\n\t\t\tgoto out_free_data;\n\t}\n\n\tfor (i = 0, ss_info_cur = ss_info, ss_data_cur = ss_data;\n\t\ti < (*ss_entries_num);\n\t\t++i, ++ss_info_cur, ++ss_data_cur) {\n\n\t\tif (ss_info_cur->type.STEP_AND_DELAY_INFO != false) {\n\t\t\tDC_LOG_SYNC(\n\t\t\t\t\"Invalid ATOMBIOS SS Table!!!\\n\");\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\t \n\t\tif (as_signal == AS_SIGNAL_TYPE_HDMI\n\t\t\t\t&& ss_info_cur->spread_spectrum_percentage > 6){\n\t\t\t \n\t\t\tDC_LOG_SYNC(\n\t\t\t\t\"Invalid SS percentage \");\n\t\t\tDC_LOG_SYNC(\n\t\t\t\t\"for HDMI in ATOMBIOS info Table!!!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (ss_info_cur->spread_percentage_divider == 1000) {\n\t\t\t \n\t\t\tss_info_cur->spread_spectrum_percentage /= 10;\n\t\t\tss_info_cur->spread_percentage_divider = 100;\n\t\t}\n\n\t\tss_data_cur->freq_range_khz = ss_info_cur->target_clock_range;\n\t\tss_data_cur->percentage =\n\t\t\t\tss_info_cur->spread_spectrum_percentage;\n\t\tss_data_cur->percentage_divider =\n\t\t\t\tss_info_cur->spread_percentage_divider;\n\t\tss_data_cur->modulation_freq_hz =\n\t\t\t\tss_info_cur->spread_spectrum_range;\n\n\t\tif (ss_info_cur->type.CENTER_MODE)\n\t\t\tss_data_cur->flags.CENTER_SPREAD = 1;\n\n\t\tif (ss_info_cur->type.EXTERNAL)\n\t\t\tss_data_cur->flags.EXTERNAL_SS = 1;\n\n\t}\n\n\t*spread_spectrum_data = ss_data;\n\tkfree(ss_info);\n\treturn;\n\nout_free_data:\n\tkfree(ss_data);\n\t*ss_entries_num = 0;\nout_free_info:\n\tkfree(ss_info);\n}\n\nstatic void ss_info_from_atombios_create(\n\tstruct dce110_clk_src *clk_src)\n{\n\tget_ss_info_from_atombios(\n\t\tclk_src,\n\t\tAS_SIGNAL_TYPE_DISPLAY_PORT,\n\t\t&clk_src->dp_ss_params,\n\t\t&clk_src->dp_ss_params_cnt);\n\tget_ss_info_from_atombios(\n\t\tclk_src,\n\t\tAS_SIGNAL_TYPE_HDMI,\n\t\t&clk_src->hdmi_ss_params,\n\t\t&clk_src->hdmi_ss_params_cnt);\n\tget_ss_info_from_atombios(\n\t\tclk_src,\n\t\tAS_SIGNAL_TYPE_DVI,\n\t\t&clk_src->dvi_ss_params,\n\t\t&clk_src->dvi_ss_params_cnt);\n\tget_ss_info_from_atombios(\n\t\tclk_src,\n\t\tAS_SIGNAL_TYPE_LVDS,\n\t\t&clk_src->lvds_ss_params,\n\t\t&clk_src->lvds_ss_params_cnt);\n}\n\nstatic bool calc_pll_max_vco_construct(\n\t\t\tstruct calc_pll_clock_source *calc_pll_cs,\n\t\t\tstruct calc_pll_clock_source_init_data *init_data)\n{\n\tuint32_t i;\n\tstruct dc_firmware_info *fw_info;\n\tif (calc_pll_cs == NULL ||\n\t\t\tinit_data == NULL ||\n\t\t\tinit_data->bp == NULL)\n\t\treturn false;\n\n\tif (!init_data->bp->fw_info_valid)\n\t\treturn false;\n\n\tfw_info = &init_data->bp->fw_info;\n\tcalc_pll_cs->ctx = init_data->ctx;\n\tcalc_pll_cs->ref_freq_khz = fw_info->pll_info.crystal_frequency;\n\tcalc_pll_cs->min_vco_khz =\n\t\t\tfw_info->pll_info.min_output_pxl_clk_pll_frequency;\n\tcalc_pll_cs->max_vco_khz =\n\t\t\tfw_info->pll_info.max_output_pxl_clk_pll_frequency;\n\n\tif (init_data->max_override_input_pxl_clk_pll_freq_khz != 0)\n\t\tcalc_pll_cs->max_pll_input_freq_khz =\n\t\t\tinit_data->max_override_input_pxl_clk_pll_freq_khz;\n\telse\n\t\tcalc_pll_cs->max_pll_input_freq_khz =\n\t\t\tfw_info->pll_info.max_input_pxl_clk_pll_frequency;\n\n\tif (init_data->min_override_input_pxl_clk_pll_freq_khz != 0)\n\t\tcalc_pll_cs->min_pll_input_freq_khz =\n\t\t\tinit_data->min_override_input_pxl_clk_pll_freq_khz;\n\telse\n\t\tcalc_pll_cs->min_pll_input_freq_khz =\n\t\t\tfw_info->pll_info.min_input_pxl_clk_pll_frequency;\n\n\tcalc_pll_cs->min_pix_clock_pll_post_divider =\n\t\t\tinit_data->min_pix_clk_pll_post_divider;\n\tcalc_pll_cs->max_pix_clock_pll_post_divider =\n\t\t\tinit_data->max_pix_clk_pll_post_divider;\n\tcalc_pll_cs->min_pll_ref_divider =\n\t\t\tinit_data->min_pll_ref_divider;\n\tcalc_pll_cs->max_pll_ref_divider =\n\t\t\tinit_data->max_pll_ref_divider;\n\n\tif (init_data->num_fract_fb_divider_decimal_point == 0 ||\n\t\tinit_data->num_fract_fb_divider_decimal_point_precision >\n\t\t\t\tinit_data->num_fract_fb_divider_decimal_point) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"The dec point num or precision is incorrect!\");\n\t\treturn false;\n\t}\n\tif (init_data->num_fract_fb_divider_decimal_point_precision == 0) {\n\t\tDC_LOG_ERROR(\n\t\t\t\"Incorrect fract feedback divider precision num!\");\n\t\treturn false;\n\t}\n\n\tcalc_pll_cs->fract_fb_divider_decimal_points_num =\n\t\t\t\tinit_data->num_fract_fb_divider_decimal_point;\n\tcalc_pll_cs->fract_fb_divider_precision =\n\t\t\tinit_data->num_fract_fb_divider_decimal_point_precision;\n\tcalc_pll_cs->fract_fb_divider_factor = 1;\n\tfor (i = 0; i < calc_pll_cs->fract_fb_divider_decimal_points_num; ++i)\n\t\tcalc_pll_cs->fract_fb_divider_factor *= 10;\n\n\tcalc_pll_cs->fract_fb_divider_precision_factor = 1;\n\tfor (\n\t\ti = 0;\n\t\ti < (calc_pll_cs->fract_fb_divider_decimal_points_num -\n\t\t\t\tcalc_pll_cs->fract_fb_divider_precision);\n\t\t++i)\n\t\tcalc_pll_cs->fract_fb_divider_precision_factor *= 10;\n\n\treturn true;\n}\n\nbool dce110_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tstruct calc_pll_clock_source_init_data calc_pll_cs_init_data_hdmi;\n\tstruct calc_pll_clock_source_init_data calc_pll_cs_init_data;\n\n\tclk_src->base.ctx = ctx;\n\tclk_src->bios = bios;\n\tclk_src->base.id = id;\n\tclk_src->base.funcs = &dce110_clk_src_funcs;\n\n\tclk_src->regs = regs;\n\tclk_src->cs_shift = cs_shift;\n\tclk_src->cs_mask = cs_mask;\n\n\tif (!clk_src->bios->fw_info_valid) {\n\t\tASSERT_CRITICAL(false);\n\t\tgoto unexpected_failure;\n\t}\n\n\tclk_src->ext_clk_khz = clk_src->bios->fw_info.external_clock_source_frequency_for_dp;\n\n\t \n\tcalc_pll_cs_init_data.bp = bios;\n\tcalc_pll_cs_init_data.min_pix_clk_pll_post_divider = 1;\n\tcalc_pll_cs_init_data.max_pix_clk_pll_post_divider =\n\t\t\tclk_src->cs_mask->PLL_POST_DIV_PIXCLK;\n\tcalc_pll_cs_init_data.min_pll_ref_divider =\t1;\n\tcalc_pll_cs_init_data.max_pll_ref_divider =\tclk_src->cs_mask->PLL_REF_DIV;\n\t \n\tcalc_pll_cs_init_data.min_override_input_pxl_clk_pll_freq_khz =\t0;\n\t \n\tcalc_pll_cs_init_data.max_override_input_pxl_clk_pll_freq_khz =\t0;\n\t \n\tcalc_pll_cs_init_data.num_fract_fb_divider_decimal_point =\n\t\t\tFRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM;\n\t \n\tcalc_pll_cs_init_data.num_fract_fb_divider_decimal_point_precision =\n\t\t\tFRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM;\n\tcalc_pll_cs_init_data.ctx =\tctx;\n\n\t \n\tcalc_pll_cs_init_data_hdmi.bp = bios;\n\tcalc_pll_cs_init_data_hdmi.min_pix_clk_pll_post_divider = 1;\n\tcalc_pll_cs_init_data_hdmi.max_pix_clk_pll_post_divider =\n\t\t\tclk_src->cs_mask->PLL_POST_DIV_PIXCLK;\n\tcalc_pll_cs_init_data_hdmi.min_pll_ref_divider = 1;\n\tcalc_pll_cs_init_data_hdmi.max_pll_ref_divider = clk_src->cs_mask->PLL_REF_DIV;\n\t \n\tcalc_pll_cs_init_data_hdmi.min_override_input_pxl_clk_pll_freq_khz = 13500;\n\t \n\tcalc_pll_cs_init_data_hdmi.max_override_input_pxl_clk_pll_freq_khz = 27000;\n\t \n\tcalc_pll_cs_init_data_hdmi.num_fract_fb_divider_decimal_point =\n\t\t\tFRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM;\n\t \n\tcalc_pll_cs_init_data_hdmi.num_fract_fb_divider_decimal_point_precision =\n\t\t\tFRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM;\n\tcalc_pll_cs_init_data_hdmi.ctx = ctx;\n\n\tclk_src->ref_freq_khz = clk_src->bios->fw_info.pll_info.crystal_frequency;\n\n\tif (clk_src->base.id == CLOCK_SOURCE_ID_EXTERNAL)\n\t\treturn true;\n\n\t \n\tss_info_from_atombios_create(clk_src);\n\n\tif (!calc_pll_max_vco_construct(\n\t\t\t&clk_src->calc_pll,\n\t\t\t&calc_pll_cs_init_data)) {\n\t\tASSERT_CRITICAL(false);\n\t\tgoto unexpected_failure;\n\t}\n\n\n\tcalc_pll_cs_init_data_hdmi.\n\t\t\tmin_override_input_pxl_clk_pll_freq_khz = clk_src->ref_freq_khz/2;\n\tcalc_pll_cs_init_data_hdmi.\n\t\t\tmax_override_input_pxl_clk_pll_freq_khz = clk_src->ref_freq_khz;\n\n\n\tif (!calc_pll_max_vco_construct(\n\t\t\t&clk_src->calc_pll_hdmi, &calc_pll_cs_init_data_hdmi)) {\n\t\tASSERT_CRITICAL(false);\n\t\tgoto unexpected_failure;\n\t}\n\n\treturn true;\n\nunexpected_failure:\n\treturn false;\n}\n\nbool dce112_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tclk_src->base.ctx = ctx;\n\tclk_src->bios = bios;\n\tclk_src->base.id = id;\n\tclk_src->base.funcs = &dce112_clk_src_funcs;\n\n\tclk_src->regs = regs;\n\tclk_src->cs_shift = cs_shift;\n\tclk_src->cs_mask = cs_mask;\n\n\tif (!clk_src->bios->fw_info_valid) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn false;\n\t}\n\n\tclk_src->ext_clk_khz = clk_src->bios->fw_info.external_clock_source_frequency_for_dp;\n\n\treturn true;\n}\n\nbool dcn20_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tbool ret = dce112_clk_src_construct(clk_src, ctx, bios, id, regs, cs_shift, cs_mask);\n\n\tclk_src->base.funcs = &dcn20_clk_src_funcs;\n\n\treturn ret;\n}\n\nbool dcn3_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tbool ret = dce112_clk_src_construct(clk_src, ctx, bios, id, regs, cs_shift, cs_mask);\n\n\tclk_src->base.funcs = &dcn3_clk_src_funcs;\n\n\treturn ret;\n}\n\nbool dcn31_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tbool ret = dce112_clk_src_construct(clk_src, ctx, bios, id, regs, cs_shift, cs_mask);\n\n\tclk_src->base.funcs = &dcn31_clk_src_funcs;\n\n\treturn ret;\n}\n\nbool dcn301_clk_src_construct(\n\tstruct dce110_clk_src *clk_src,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tconst struct dce110_clk_src_shift *cs_shift,\n\tconst struct dce110_clk_src_mask *cs_mask)\n{\n\tbool ret = dce112_clk_src_construct(clk_src, ctx, bios, id, regs, cs_shift, cs_mask);\n\n\tclk_src->base.funcs = &dcn3_clk_src_funcs;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}