{
  "module_name": "rv1_clk_mgr.c",
  "hash_id": "556e3d62eaf70ac46eb806c42ea066d94013ae3a89e8e98cbdf261552ccb849f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn10/rv1_clk_mgr.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"clk_mgr_internal.h\"\n#include \"rv1_clk_mgr.h\"\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dce112/dce112_clk_mgr.h\"\n#include \"rv1_clk_mgr_vbios_smu.h\"\n#include \"rv1_clk_mgr_clk.h\"\n\nstatic void rv1_init_clocks(struct clk_mgr *clk_mgr)\n{\n\tmemset(&(clk_mgr->clks), 0, sizeof(struct dc_clocks));\n}\n\nstatic int rv1_determine_dppclk_threshold(struct clk_mgr_internal *clk_mgr, struct dc_clocks *new_clocks)\n{\n\tbool request_dpp_div = new_clocks->dispclk_khz > new_clocks->dppclk_khz;\n\tbool dispclk_increase = new_clocks->dispclk_khz > clk_mgr->base.clks.dispclk_khz;\n\tint disp_clk_threshold = new_clocks->max_supported_dppclk_khz;\n\tbool cur_dpp_div = clk_mgr->base.clks.dispclk_khz > clk_mgr->base.clks.dppclk_khz;\n\n\t \n\tif (dispclk_increase) {\n\t\t \n\t\tif (cur_dpp_div)\n\t\t\treturn new_clocks->dispclk_khz;\n\n\t\t \n\t\tif (new_clocks->dispclk_khz <= disp_clk_threshold)\n\t\t\treturn new_clocks->dispclk_khz;\n\n\t\t \n\t\tif (!request_dpp_div)\n\t\t\treturn new_clocks->dispclk_khz;\n\n\t} else {\n\t\t \n\n\t\t \n\t\tif (!cur_dpp_div)\n\t\t\treturn new_clocks->dispclk_khz;\n\n\t\t \n\t\tif (clk_mgr->base.clks.dispclk_khz <= disp_clk_threshold)\n\t\t\treturn new_clocks->dispclk_khz;\n\n\t\t \n\t\tif (request_dpp_div)\n\t\t\treturn new_clocks->dispclk_khz;\n\t}\n\n\treturn disp_clk_threshold;\n}\n\nstatic void ramp_up_dispclk_with_dpp(\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc *dc,\n\t\tstruct dc_clocks *new_clocks,\n\t\tbool safe_to_lower)\n{\n\tint i;\n\tint dispclk_to_dpp_threshold = rv1_determine_dppclk_threshold(clk_mgr, new_clocks);\n\tbool request_dpp_div = new_clocks->dispclk_khz > new_clocks->dppclk_khz;\n\n\t \n\tif (!safe_to_lower)\n\t\trequest_dpp_div = false;\n\n\t \n\n\tclk_mgr->funcs->set_dispclk(clk_mgr, dispclk_to_dpp_threshold);\n\tclk_mgr->funcs->set_dprefclk(clk_mgr);\n\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx->plane_state)\n\t\t\tcontinue;\n\n\t\tpipe_ctx->plane_res.dpp->funcs->dpp_dppclk_control(\n\t\t\t\tpipe_ctx->plane_res.dpp,\n\t\t\t\trequest_dpp_div,\n\t\t\t\ttrue);\n\t}\n\n\t \n\tif (dispclk_to_dpp_threshold != new_clocks->dispclk_khz) {\n\t\tclk_mgr->funcs->set_dispclk(clk_mgr, new_clocks->dispclk_khz);\n\t\tclk_mgr->funcs->set_dprefclk(clk_mgr);\n\t}\n\n\n\tclk_mgr->base.clks.dispclk_khz = new_clocks->dispclk_khz;\n\tclk_mgr->base.clks.dppclk_khz = new_clocks->dppclk_khz;\n\tclk_mgr->base.clks.max_supported_dppclk_khz = new_clocks->max_supported_dppclk_khz;\n}\n\nstatic void rv1_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tstruct dc_debug_options *debug = &dc->debug;\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct pp_smu_funcs_rv *pp_smu = NULL;\n\tbool send_request_to_increase = false;\n\tbool send_request_to_lower = false;\n\tint display_count;\n\n\tbool enter_display_off = false;\n\n\tASSERT(clk_mgr->pp_smu);\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\tpp_smu = &clk_mgr->pp_smu->rv_funcs;\n\n\tdisplay_count = clk_mgr_helper_get_active_display_cnt(dc, context);\n\n\tif (display_count == 0)\n\t\tenter_display_off = true;\n\n\tif (enter_display_off == safe_to_lower) {\n\t\t \n\t\tif (pp_smu->set_display_count)\n\t\t\tpp_smu->set_display_count(&pp_smu->pp_smu, display_count);\n\t}\n\n\tif (new_clocks->dispclk_khz > clk_mgr_base->clks.dispclk_khz\n\t\t\t|| new_clocks->phyclk_khz > clk_mgr_base->clks.phyclk_khz\n\t\t\t|| new_clocks->fclk_khz > clk_mgr_base->clks.fclk_khz\n\t\t\t|| new_clocks->dcfclk_khz > clk_mgr_base->clks.dcfclk_khz)\n\t\tsend_request_to_increase = true;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->phyclk_khz, clk_mgr_base->clks.phyclk_khz)) {\n\t\tclk_mgr_base->clks.phyclk_khz = new_clocks->phyclk_khz;\n\t\tsend_request_to_lower = true;\n\t}\n\n\t\n\tif (debug->force_fclk_khz != 0)\n\t\tnew_clocks->fclk_khz = debug->force_fclk_khz;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->fclk_khz, clk_mgr_base->clks.fclk_khz)) {\n\t\tclk_mgr_base->clks.fclk_khz = new_clocks->fclk_khz;\n\t\tsend_request_to_lower = true;\n\t}\n\n\t\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\tsend_request_to_lower = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\tsend_request_to_lower = true;\n\t}\n\n\t \n\tif (send_request_to_increase) {\n\t\t \n\t\tif (pp_smu->set_hard_min_fclk_by_freq &&\n\t\t\t\tpp_smu->set_hard_min_dcfclk_by_freq &&\n\t\t\t\tpp_smu->set_min_deep_sleep_dcfclk) {\n\t\t\tpp_smu->set_hard_min_fclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->fclk_khz));\n\t\t\tpp_smu->set_hard_min_dcfclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->dcfclk_khz));\n\t\t\tpp_smu->set_min_deep_sleep_dcfclk(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->dcfclk_deep_sleep_khz));\n\t\t}\n\t}\n\n\t \n\t \n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)\n\t\t\t|| new_clocks->dispclk_khz == clk_mgr_base->clks.dispclk_khz) {\n\t\tramp_up_dispclk_with_dpp(clk_mgr, dc, new_clocks, safe_to_lower);\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t\tsend_request_to_lower = true;\n\t}\n\n\tif (!send_request_to_increase && send_request_to_lower) {\n\t\t \n\t\tif (pp_smu->set_hard_min_fclk_by_freq &&\n\t\t\t\tpp_smu->set_hard_min_dcfclk_by_freq &&\n\t\t\t\tpp_smu->set_min_deep_sleep_dcfclk) {\n\t\t\tpp_smu->set_hard_min_fclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->fclk_khz));\n\t\t\tpp_smu->set_hard_min_dcfclk_by_freq(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->dcfclk_khz));\n\t\t\tpp_smu->set_min_deep_sleep_dcfclk(&pp_smu->pp_smu, khz_to_mhz_ceil(new_clocks->dcfclk_deep_sleep_khz));\n\t\t}\n\t}\n}\n\nstatic void rv1_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct pp_smu_funcs_rv *pp_smu = NULL;\n\n\tif (clk_mgr->pp_smu) {\n\t\tpp_smu = &clk_mgr->pp_smu->rv_funcs;\n\n\t\tif (pp_smu->set_pme_wa_enable)\n\t\t\tpp_smu->set_pme_wa_enable(&pp_smu->pp_smu);\n\t}\n}\n\nstatic struct clk_mgr_funcs rv1_clk_funcs = {\n\t.init_clocks = rv1_init_clocks,\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = rv1_update_clocks,\n\t.enable_pme_wa = rv1_enable_pme_wa,\n};\n\nstatic struct clk_mgr_internal_funcs rv1_clk_internal_funcs = {\n\t.set_dispclk = rv1_vbios_smu_set_dispclk,\n\t.set_dprefclk = dce112_set_dprefclk\n};\n\nvoid rv1_clk_mgr_construct(struct dc_context *ctx, struct clk_mgr_internal *clk_mgr, struct pp_smu_funcs *pp_smu)\n{\n\tstruct dc_debug_options *debug = &ctx->dc->debug;\n\tstruct dc_bios *bp = ctx->dc_bios;\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->pp_smu = pp_smu;\n\tclk_mgr->base.funcs = &rv1_clk_funcs;\n\tclk_mgr->funcs = &rv1_clk_internal_funcs;\n\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->base.dprefclk_khz = 600000;\n\n\tif (bp->integrated_info)\n\t\tclk_mgr->base.dentist_vco_freq_khz = bp->integrated_info->dentist_vco_freq;\n\tif (bp->fw_info_valid && clk_mgr->base.dentist_vco_freq_khz == 0) {\n\t\tclk_mgr->base.dentist_vco_freq_khz = bp->fw_info.smu_gpu_pll_output_freq;\n\t\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\t\tclk_mgr->base.dentist_vco_freq_khz = 3600000;\n\t}\n\n\tif (!debug->disable_dfs_bypass && bp->integrated_info)\n\t\tif (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)\n\t\t\tclk_mgr->dfs_bypass_enabled = true;\n\n\tdce_clock_read_ss_info(clk_mgr);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}