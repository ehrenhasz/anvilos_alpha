{
  "module_name": "display_mode_vba_util_32.c",
  "hash_id": "2686b7b13d7ca6a444a524ae77deab87dbb3801b6c9128273b325276a000c1db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn32/display_mode_vba_util_32.c",
  "human_readable_source": " \n#include \"display_mode_vba_util_32.h\"\n#include \"../dml_inline_defs.h\"\n#include \"display_mode_vba_32.h\"\n#include \"../display_mode_lib.h\"\n\n#define DCN32_MAX_FMT_420_BUFFER_WIDTH 4096\n\nunsigned int dml32_dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble BPP,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output)\n{\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tunsigned int rcModelSize = 8192;\n\n\t\n\tunsigned int pixelsPerClock, lstall, D, initalXmitDelay, w, s, ix, wx, p, l0, a, ax, L,\n\tDelay, pixels;\n\n\tif (pixelFormat == dm_420)\n\t\tpixelsPerClock = 2;\n\telse if (pixelFormat == dm_n422)\n\t\tpixelsPerClock = 2;\n\t\n\telse\n\t\tpixelsPerClock = 1;\n\n\t\n\tinitalXmitDelay = dml_round(rcModelSize / 2.0 / BPP / pixelsPerClock);\n\n\t\n\tif (bpc == 8)\n\t\tD = 81;\n\telse if (bpc == 10)\n\t\tD = 89;\n\telse\n\t\tD = 113;\n\n\t\n\tw = sliceWidth / pixelsPerClock;\n\n\t\n\tif (pixelFormat == dm_420 || pixelFormat == dm_444 || pixelFormat == dm_n422)\n\t\ts = 0;\n\telse\n\t\ts = 1;\n\n\t\n\tix = initalXmitDelay + 45;\n\twx = (w + 2) / 3;\n\tp = 3 * wx - w;\n\tl0 = ix / w;\n\ta = ix + p * l0;\n\tax = (a + 2) / 3 + D + 6 + 1;\n\tL = (ax + wx - 1) / wx;\n\tif ((ix % w) == 0 && p != 0)\n\t\tlstall = 1;\n\telse\n\t\tlstall = 0;\n\tDelay = L * wx * (numSlices - 1) + ax + s + lstall + 22;\n\n\t\n\tpixels = Delay * 3 * pixelsPerClock;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: bpc: %d\\n\", __func__, bpc);\n\tdml_print(\"DML::%s: BPP: %f\\n\", __func__, BPP);\n\tdml_print(\"DML::%s: sliceWidth: %d\\n\", __func__, sliceWidth);\n\tdml_print(\"DML::%s: numSlices: %d\\n\", __func__, numSlices);\n\tdml_print(\"DML::%s: pixelFormat: %d\\n\", __func__, pixelFormat);\n\tdml_print(\"DML::%s: Output: %d\\n\", __func__, Output);\n\tdml_print(\"DML::%s: pixels: %d\\n\", __func__, pixels);\n#endif\n\n\treturn pixels;\n}\n\nunsigned int dml32_dscComputeDelay(enum output_format_class pixelFormat, enum output_encoder_class Output)\n{\n\tunsigned int Delay = 0;\n\n\tif (pixelFormat == dm_420) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 13;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else if (pixelFormat == dm_n422 || (pixelFormat != dm_444)) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 5;\n\t\t\n\t\tDelay = Delay + 25;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 10;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t}\n\n\treturn Delay;\n}\n\n\nbool IsVertical(enum dm_rotation_angle Scan)\n{\n\tbool is_vert = false;\n\n\tif (Scan == dm_rotation_90 || Scan == dm_rotation_90m || Scan == dm_rotation_270 || Scan == dm_rotation_270m)\n\t\tis_vert = true;\n\telse\n\t\tis_vert = false;\n\treturn is_vert;\n}\n\nvoid dml32_CalculateSinglePipeDPPCLKAndSCLThroughput(\n\t\tdouble HRatio,\n\t\tdouble HRatioChroma,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tdouble MaxDCHUBToPSCLThroughput,\n\t\tdouble MaxPSCLToLBThroughput,\n\t\tdouble PixelClock,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int HTaps,\n\t\tunsigned int HTapsChroma,\n\t\tunsigned int VTaps,\n\t\tunsigned int VTapsChroma,\n\n\t\t \n\t\tdouble *PSCL_THROUGHPUT,\n\t\tdouble *PSCL_THROUGHPUT_CHROMA,\n\t\tdouble *DPPCLKUsingSingleDPP)\n{\n\tdouble DPPCLKUsingSingleDPPLuma;\n\tdouble DPPCLKUsingSingleDPPChroma;\n\n\tif (HRatio > 1) {\n\t\t*PSCL_THROUGHPUT = dml_min(MaxDCHUBToPSCLThroughput, MaxPSCLToLBThroughput * HRatio /\n\t\t\t\tdml_ceil((double) HTaps / 6.0, 1.0));\n\t} else {\n\t\t*PSCL_THROUGHPUT = dml_min(MaxDCHUBToPSCLThroughput, MaxPSCLToLBThroughput);\n\t}\n\n\tDPPCLKUsingSingleDPPLuma = PixelClock * dml_max3(VTaps / 6 * dml_min(1, HRatio), HRatio * VRatio /\n\t\t\t*PSCL_THROUGHPUT, 1);\n\n\tif ((HTaps > 6 || VTaps > 6) && DPPCLKUsingSingleDPPLuma < 2 * PixelClock)\n\t\tDPPCLKUsingSingleDPPLuma = 2 * PixelClock;\n\n\tif ((SourcePixelFormat != dm_420_8 && SourcePixelFormat != dm_420_10 && SourcePixelFormat != dm_420_12 &&\n\t\t\tSourcePixelFormat != dm_rgbe_alpha)) {\n\t\t*PSCL_THROUGHPUT_CHROMA = 0;\n\t\t*DPPCLKUsingSingleDPP = DPPCLKUsingSingleDPPLuma;\n\t} else {\n\t\tif (HRatioChroma > 1) {\n\t\t\t*PSCL_THROUGHPUT_CHROMA = dml_min(MaxDCHUBToPSCLThroughput, MaxPSCLToLBThroughput *\n\t\t\t\t\tHRatioChroma / dml_ceil((double) HTapsChroma / 6.0, 1.0));\n\t\t} else {\n\t\t\t*PSCL_THROUGHPUT_CHROMA = dml_min(MaxDCHUBToPSCLThroughput, MaxPSCLToLBThroughput);\n\t\t}\n\t\tDPPCLKUsingSingleDPPChroma = PixelClock * dml_max3(VTapsChroma / 6 * dml_min(1, HRatioChroma),\n\t\t\t\tHRatioChroma * VRatioChroma / *PSCL_THROUGHPUT_CHROMA, 1);\n\t\tif ((HTapsChroma > 6 || VTapsChroma > 6) && DPPCLKUsingSingleDPPChroma < 2 * PixelClock)\n\t\t\tDPPCLKUsingSingleDPPChroma = 2 * PixelClock;\n\t\t*DPPCLKUsingSingleDPP = dml_max(DPPCLKUsingSingleDPPLuma, DPPCLKUsingSingleDPPChroma);\n\t}\n}\n\nvoid dml32_CalculateBytePerPixelAndBlockSizes(\n\t\tenum source_format_class SourcePixelFormat,\n\t\tenum dm_swizzle_mode SurfaceTiling,\n\n\t\t \n\t\tunsigned int *BytePerPixelY,\n\t\tunsigned int *BytePerPixelC,\n\t\tdouble  *BytePerPixelDETY,\n\t\tdouble  *BytePerPixelDETC,\n\t\tunsigned int *BlockHeight256BytesY,\n\t\tunsigned int *BlockHeight256BytesC,\n\t\tunsigned int *BlockWidth256BytesY,\n\t\tunsigned int *BlockWidth256BytesC,\n\t\tunsigned int *MacroTileHeightY,\n\t\tunsigned int *MacroTileHeightC,\n\t\tunsigned int *MacroTileWidthY,\n\t\tunsigned int *MacroTileWidthC)\n{\n\tif (SourcePixelFormat == dm_444_64) {\n\t\t*BytePerPixelDETY = 8;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 8;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_32 || SourcePixelFormat == dm_rgbe) {\n\t\t*BytePerPixelDETY = 4;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 4;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_16) {\n\t\t*BytePerPixelDETY = 2;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_8) {\n\t\t*BytePerPixelDETY = 1;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 1;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*BytePerPixelDETY = 4;\n\t\t*BytePerPixelDETC = 1;\n\t\t*BytePerPixelY = 4;\n\t\t*BytePerPixelC = 1;\n\t} else if (SourcePixelFormat == dm_420_8) {\n\t\t*BytePerPixelDETY = 1;\n\t\t*BytePerPixelDETC = 2;\n\t\t*BytePerPixelY = 1;\n\t\t*BytePerPixelC = 2;\n\t} else if (SourcePixelFormat == dm_420_12) {\n\t\t*BytePerPixelDETY = 2;\n\t\t*BytePerPixelDETC = 4;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 4;\n\t} else {\n\t\t*BytePerPixelDETY = 4.0 / 3;\n\t\t*BytePerPixelDETC = 8.0 / 3;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 4;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: SourcePixelFormat = %d\\n\", __func__, SourcePixelFormat);\n\tdml_print(\"DML::%s: BytePerPixelDETY = %f\\n\", __func__, *BytePerPixelDETY);\n\tdml_print(\"DML::%s: BytePerPixelDETC = %f\\n\", __func__, *BytePerPixelDETC);\n\tdml_print(\"DML::%s: BytePerPixelY    = %d\\n\", __func__, *BytePerPixelY);\n\tdml_print(\"DML::%s: BytePerPixelC    = %d\\n\", __func__, *BytePerPixelC);\n#endif\n\tif ((SourcePixelFormat == dm_444_64 || SourcePixelFormat == dm_444_32\n\t\t\t|| SourcePixelFormat == dm_444_16\n\t\t\t|| SourcePixelFormat == dm_444_8\n\t\t\t|| SourcePixelFormat == dm_mono_16\n\t\t\t|| SourcePixelFormat == dm_mono_8\n\t\t\t|| SourcePixelFormat == dm_rgbe)) {\n\t\tif (SurfaceTiling == dm_sw_linear)\n\t\t\t*BlockHeight256BytesY = 1;\n\t\telse if (SourcePixelFormat == dm_444_64)\n\t\t\t*BlockHeight256BytesY = 4;\n\t\telse if (SourcePixelFormat == dm_444_8)\n\t\t\t*BlockHeight256BytesY = 16;\n\t\telse\n\t\t\t*BlockHeight256BytesY = 8;\n\n\t\t*BlockWidth256BytesY = 256U / *BytePerPixelY / *BlockHeight256BytesY;\n\t\t*BlockHeight256BytesC = 0;\n\t\t*BlockWidth256BytesC = 0;\n\t} else {\n\t\tif (SurfaceTiling == dm_sw_linear) {\n\t\t\t*BlockHeight256BytesY = 1;\n\t\t\t*BlockHeight256BytesC = 1;\n\t\t} else if (SourcePixelFormat == dm_rgbe_alpha) {\n\t\t\t*BlockHeight256BytesY = 8;\n\t\t\t*BlockHeight256BytesC = 16;\n\t\t} else if (SourcePixelFormat == dm_420_8) {\n\t\t\t*BlockHeight256BytesY = 16;\n\t\t\t*BlockHeight256BytesC = 8;\n\t\t} else {\n\t\t\t*BlockHeight256BytesY = 8;\n\t\t\t*BlockHeight256BytesC = 8;\n\t\t}\n\t\t*BlockWidth256BytesY = 256U / *BytePerPixelY / *BlockHeight256BytesY;\n\t\t*BlockWidth256BytesC = 256U / *BytePerPixelC / *BlockHeight256BytesC;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: BlockWidth256BytesY  = %d\\n\", __func__, *BlockWidth256BytesY);\n\tdml_print(\"DML::%s: BlockHeight256BytesY = %d\\n\", __func__, *BlockHeight256BytesY);\n\tdml_print(\"DML::%s: BlockWidth256BytesC  = %d\\n\", __func__, *BlockWidth256BytesC);\n\tdml_print(\"DML::%s: BlockHeight256BytesC = %d\\n\", __func__, *BlockHeight256BytesC);\n#endif\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\t*MacroTileHeightY = *BlockHeight256BytesY;\n\t\t*MacroTileWidthY = 256 / *BytePerPixelY / *MacroTileHeightY;\n\t\t*MacroTileHeightC = *BlockHeight256BytesC;\n\t\tif (*MacroTileHeightC == 0)\n\t\t\t*MacroTileWidthC = 0;\n\t\telse\n\t\t\t*MacroTileWidthC = 256 / *BytePerPixelC / *MacroTileHeightC;\n\t} else if (SurfaceTiling == dm_sw_64kb_d || SurfaceTiling == dm_sw_64kb_d_t ||\n\t\t\tSurfaceTiling == dm_sw_64kb_d_x || SurfaceTiling == dm_sw_64kb_r_x) {\n\t\t*MacroTileHeightY = 16 * *BlockHeight256BytesY;\n\t\t*MacroTileWidthY = 65536 / *BytePerPixelY / *MacroTileHeightY;\n\t\t*MacroTileHeightC = 16 * *BlockHeight256BytesC;\n\t\tif (*MacroTileHeightC == 0)\n\t\t\t*MacroTileWidthC = 0;\n\t\telse\n\t\t\t*MacroTileWidthC = 65536 / *BytePerPixelC / *MacroTileHeightC;\n\t} else {\n\t\t*MacroTileHeightY = 32 * *BlockHeight256BytesY;\n\t\t*MacroTileWidthY = 65536 * 4 / *BytePerPixelY / *MacroTileHeightY;\n\t\t*MacroTileHeightC = 32 * *BlockHeight256BytesC;\n\t\tif (*MacroTileHeightC == 0)\n\t\t\t*MacroTileWidthC = 0;\n\t\telse\n\t\t\t*MacroTileWidthC = 65536 * 4 / *BytePerPixelC / *MacroTileHeightC;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: MacroTileWidthY  = %d\\n\", __func__, *MacroTileWidthY);\n\tdml_print(\"DML::%s: MacroTileHeightY = %d\\n\", __func__, *MacroTileHeightY);\n\tdml_print(\"DML::%s: MacroTileWidthC  = %d\\n\", __func__, *MacroTileWidthC);\n\tdml_print(\"DML::%s: MacroTileHeightC = %d\\n\", __func__, *MacroTileHeightC);\n#endif\n} \n\nvoid dml32_CalculateSwathAndDETConfiguration(\n\t\tunsigned int DETSizeOverride[],\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],\n\t\tunsigned int ConfigReturnBufferSizeInKByte,\n\t\tunsigned int MaxTotalDETInKByte,\n\t\tunsigned int MinCompressedBufferSizeInKByte,\n\t\tdouble ForceSingleDPP,\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int nomDETInKByte,\n\t\tenum unbounded_requesting_policy UseUnboundedRequestingFinal,\n\t\tbool DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment,\n\t\tunsigned int PixelChunkSizeKBytes,\n\t\tunsigned int ROBSizeKBytes,\n\t\tunsigned int CompressedBufferSegmentSizeInkByteFinal,\n\t\tenum output_encoder_class Output[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble MaximumSwathWidthLuma[],\n\t\tdouble MaximumSwathWidthChroma[],\n\t\tenum dm_rotation_angle SourceRotation[],\n\t\tbool ViewportStationary[],\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum dm_swizzle_mode SurfaceTiling[],\n\t\tunsigned int ViewportWidth[],\n\t\tunsigned int ViewportHeight[],\n\t\tunsigned int ViewportXStart[],\n\t\tunsigned int ViewportYStart[],\n\t\tunsigned int ViewportXStartC[],\n\t\tunsigned int ViewportYStartC[],\n\t\tunsigned int SurfaceWidthY[],\n\t\tunsigned int SurfaceWidthC[],\n\t\tunsigned int SurfaceHeightY[],\n\t\tunsigned int SurfaceHeightC[],\n\t\tunsigned int Read256BytesBlockHeightY[],\n\t\tunsigned int Read256BytesBlockHeightC[],\n\t\tunsigned int Read256BytesBlockWidthY[],\n\t\tunsigned int Read256BytesBlockWidthC[],\n\t\tenum odm_combine_mode ODMMode[],\n\t\tunsigned int BlendingAndTiming[],\n\t\tunsigned int BytePerPixY[],\n\t\tunsigned int BytePerPixC[],\n\t\tdouble BytePerPixDETY[],\n\t\tdouble BytePerPixDETC[],\n\t\tunsigned int HActive[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tunsigned int DPPPerSurface[],\n\n\t\t \n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tdouble SwathWidth[],\n\t\tdouble SwathWidthChroma[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tunsigned int DETBufferSizeInKByte[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tbool *UnboundedRequestEnabled,\n\t\tunsigned int *CompressedBufferSizeInkByte,\n\t\tunsigned int *CompBufReservedSpaceKBytes,\n\t\tbool *CompBufReservedSpaceNeedAdjustment,\n\t\tbool ViewportSizeSupportPerSurface[],\n\t\tbool *ViewportSizeSupport)\n{\n\tunsigned int MaximumSwathHeightY[DC__NUM_DPP__MAX];\n\tunsigned int MaximumSwathHeightC[DC__NUM_DPP__MAX];\n\tunsigned int RoundedUpMaxSwathSizeBytesY[DC__NUM_DPP__MAX];\n\tunsigned int RoundedUpMaxSwathSizeBytesC[DC__NUM_DPP__MAX];\n\tunsigned int RoundedUpSwathSizeBytesY;\n\tunsigned int RoundedUpSwathSizeBytesC;\n\tdouble SwathWidthdoubleDPP[DC__NUM_DPP__MAX];\n\tdouble SwathWidthdoubleDPPChroma[DC__NUM_DPP__MAX];\n\tunsigned int k;\n\tunsigned int TotalActiveDPP = 0;\n\tbool NoChromaSurfaces = true;\n\tunsigned int DETBufferSizeInKByteForSwathCalculation;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ForceSingleDPP = %d\\n\", __func__, ForceSingleDPP);\n\tdml_print(\"DML::%s: ROBSizeKBytes = %d\\n\", __func__, ROBSizeKBytes);\n\tdml_print(\"DML::%s: PixelChunkSizeKBytes = %d\\n\", __func__, PixelChunkSizeKBytes);\n#endif\n\tdml32_CalculateSwathWidth(ForceSingleDPP,\n\t\t\tNumberOfActiveSurfaces,\n\t\t\tSourcePixelFormat,\n\t\t\tSourceRotation,\n\t\t\tViewportStationary,\n\t\t\tViewportWidth,\n\t\t\tViewportHeight,\n\t\t\tViewportXStart,\n\t\t\tViewportYStart,\n\t\t\tViewportXStartC,\n\t\t\tViewportYStartC,\n\t\t\tSurfaceWidthY,\n\t\t\tSurfaceWidthC,\n\t\t\tSurfaceHeightY,\n\t\t\tSurfaceHeightC,\n\t\t\tODMMode,\n\t\t\tBytePerPixY,\n\t\t\tBytePerPixC,\n\t\t\tRead256BytesBlockHeightY,\n\t\t\tRead256BytesBlockHeightC,\n\t\t\tRead256BytesBlockWidthY,\n\t\t\tRead256BytesBlockWidthC,\n\t\t\tBlendingAndTiming,\n\t\t\tHActive,\n\t\t\tHRatio,\n\t\t\tDPPPerSurface,\n\n\t\t\t \n\t\t\tSwathWidthdoubleDPP,\n\t\t\tSwathWidthdoubleDPPChroma,\n\t\t\tSwathWidth,\n\t\t\tSwathWidthChroma,\n\t\t\tMaximumSwathHeightY,\n\t\t\tMaximumSwathHeightC,\n\t\t\tswath_width_luma_ub,\n\t\t\tswath_width_chroma_ub);\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tRoundedUpMaxSwathSizeBytesY[k] = swath_width_luma_ub[k] * BytePerPixDETY[k] * MaximumSwathHeightY[k];\n\t\tRoundedUpMaxSwathSizeBytesC[k] = swath_width_chroma_ub[k] * BytePerPixDETC[k] * MaximumSwathHeightC[k];\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d DPPPerSurface = %d\\n\", __func__, k, DPPPerSurface[k]);\n\t\tdml_print(\"DML::%s: k=%0d swath_width_luma_ub = %d\\n\", __func__, k, swath_width_luma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%0d BytePerPixDETY = %f\\n\", __func__, k, BytePerPixDETY[k]);\n\t\tdml_print(\"DML::%s: k=%0d MaximumSwathHeightY = %d\\n\", __func__, k, MaximumSwathHeightY[k]);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesY = %d\\n\", __func__, k,\n\t\t\t\tRoundedUpMaxSwathSizeBytesY[k]);\n\t\tdml_print(\"DML::%s: k=%0d swath_width_chroma_ub = %d\\n\", __func__, k, swath_width_chroma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%0d BytePerPixDETC = %f\\n\", __func__, k, BytePerPixDETC[k]);\n\t\tdml_print(\"DML::%s: k=%0d MaximumSwathHeightC = %d\\n\", __func__, k, MaximumSwathHeightC[k]);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesC = %d\\n\", __func__, k,\n\t\t\t\tRoundedUpMaxSwathSizeBytesC[k]);\n#endif\n\n\t\tif (SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesY[k] = dml_ceil((unsigned int) RoundedUpMaxSwathSizeBytesY[k], 256);\n\t\t\tRoundedUpMaxSwathSizeBytesC[k] = dml_ceil((unsigned int) RoundedUpMaxSwathSizeBytesC[k], 256);\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tTotalActiveDPP = TotalActiveDPP + (ForceSingleDPP ? 1 : DPPPerSurface[k]);\n\t\tif (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 ||\n\t\t\t\tSourcePixelFormat[k] == dm_420_12 || SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\tNoChromaSurfaces = false;\n\t\t}\n\t}\n\n\t\n\t*CompBufReservedSpaceKBytes = PixelChunkSizeKBytes * 2;\n\n\t\n\t\n\t\n\t*CompBufReservedSpaceNeedAdjustment = ((int) ROBSizeKBytes - (int) *CompBufReservedSpaceKBytes) > (int) (RoundedUpMaxSwathSizeBytesY[0]/512);\n\n\tif (*CompBufReservedSpaceNeedAdjustment == 1) {\n\t\t*CompBufReservedSpaceKBytes = ROBSizeKBytes - RoundedUpMaxSwathSizeBytesY[0]/512;\n\t}\n\n\t#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: CompBufReservedSpaceKBytes          = %d\\n\",  __func__, *CompBufReservedSpaceKBytes);\n\t\tdml_print(\"DML::%s: CompBufReservedSpaceNeedAdjustment  = %d\\n\",  __func__, *CompBufReservedSpaceNeedAdjustment);\n\t#endif\n\n\t*UnboundedRequestEnabled = dml32_UnboundedRequest(UseUnboundedRequestingFinal, TotalActiveDPP, NoChromaSurfaces, Output[0], SurfaceTiling[0], *CompBufReservedSpaceNeedAdjustment, DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment);\n\n\tdml32_CalculateDETBufferSize(DETSizeOverride,\n\t\t\tUseMALLForPStateChange,\n\t\t\tForceSingleDPP,\n\t\t\tNumberOfActiveSurfaces,\n\t\t\t*UnboundedRequestEnabled,\n\t\t\tnomDETInKByte,\n\t\t\tMaxTotalDETInKByte,\n\t\t\tConfigReturnBufferSizeInKByte,\n\t\t\tMinCompressedBufferSizeInKByte,\n\t\t\tCompressedBufferSegmentSizeInkByteFinal,\n\t\t\tSourcePixelFormat,\n\t\t\tReadBandwidthLuma,\n\t\t\tReadBandwidthChroma,\n\t\t\tRoundedUpMaxSwathSizeBytesY,\n\t\t\tRoundedUpMaxSwathSizeBytesC,\n\t\t\tDPPPerSurface,\n\n\t\t\t \n\t\t\tDETBufferSizeInKByte,    \n\t\t\tCompressedBufferSizeInkByte);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: TotalActiveDPP = %d\\n\", __func__, TotalActiveDPP);\n\tdml_print(\"DML::%s: nomDETInKByte = %d\\n\", __func__, nomDETInKByte);\n\tdml_print(\"DML::%s: ConfigReturnBufferSizeInKByte = %d\\n\", __func__, ConfigReturnBufferSizeInKByte);\n\tdml_print(\"DML::%s: UseUnboundedRequestingFinal = %d\\n\", __func__, UseUnboundedRequestingFinal);\n\tdml_print(\"DML::%s: UnboundedRequestEnabled = %d\\n\", __func__, *UnboundedRequestEnabled);\n\tdml_print(\"DML::%s: CompressedBufferSizeInkByte = %d\\n\", __func__, *CompressedBufferSizeInkByte);\n#endif\n\n\t*ViewportSizeSupport = true;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\n\t\tDETBufferSizeInKByteForSwathCalculation = (UseMALLForPStateChange[k] ==\n\t\t\t\tdm_use_mall_pstate_change_phantom_pipe ? 1024 : DETBufferSizeInKByte[k]);\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d DETBufferSizeInKByteForSwathCalculation = %d\\n\", __func__, k,\n\t\t\t\tDETBufferSizeInKByteForSwathCalculation);\n#endif\n\n\t\tif (RoundedUpMaxSwathSizeBytesY[k] + RoundedUpMaxSwathSizeBytesC[k] <=\n\t\t\t\tDETBufferSizeInKByteForSwathCalculation * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY[k];\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC[k];\n\t\t} else if (RoundedUpMaxSwathSizeBytesY[k] >= 1.5 * RoundedUpMaxSwathSizeBytesC[k] &&\n\t\t\t\tRoundedUpMaxSwathSizeBytesY[k] / 2 + RoundedUpMaxSwathSizeBytesC[k] <=\n\t\t\t\tDETBufferSizeInKByteForSwathCalculation * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k] / 2;\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY[k] / 2;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC[k];\n\t\t} else if (RoundedUpMaxSwathSizeBytesY[k] < 1.5 * RoundedUpMaxSwathSizeBytesC[k] &&\n\t\t\t\tRoundedUpMaxSwathSizeBytesY[k] + RoundedUpMaxSwathSizeBytesC[k] / 2 <=\n\t\t\t\tDETBufferSizeInKByteForSwathCalculation * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k] / 2;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY[k];\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC[k] / 2;\n\t\t} else {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k] / 2;\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k] / 2;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY[k] / 2;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC[k] / 2;\n\t\t}\n\n\t\tif ((RoundedUpMaxSwathSizeBytesY[k] / 2 + RoundedUpMaxSwathSizeBytesC[k] / 2 >\n\t\t\t\tDETBufferSizeInKByteForSwathCalculation * 1024 / 2)\n\t\t\t\t|| SwathWidth[k] > MaximumSwathWidthLuma[k] || (SwathHeightC[k] > 0 &&\n\t\t\t\t\t\tSwathWidthChroma[k] > MaximumSwathWidthChroma[k])) {\n\t\t\t*ViewportSizeSupport = false;\n\t\t\tViewportSizeSupportPerSurface[k] = false;\n\t\t} else {\n\t\t\tViewportSizeSupportPerSurface[k] = true;\n\t\t}\n\n\t\tif (SwathHeightC[k] == 0) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d All DET for plane0\\n\", __func__, k);\n#endif\n\t\t\tDETBufferSizeY[k] = DETBufferSizeInKByte[k] * 1024;\n\t\t\tDETBufferSizeC[k] = 0;\n\t\t} else if (RoundedUpSwathSizeBytesY <= 1.5 * RoundedUpSwathSizeBytesC) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d Half DET for plane0, half for plane1\\n\", __func__, k);\n#endif\n\t\t\tDETBufferSizeY[k] = DETBufferSizeInKByte[k] * 1024 / 2;\n\t\t\tDETBufferSizeC[k] = DETBufferSizeInKByte[k] * 1024 / 2;\n\t\t} else {\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d 2/3 DET for plane0, 1/3 for plane1\\n\", __func__, k);\n#endif\n\t\t\tDETBufferSizeY[k] = dml_floor(DETBufferSizeInKByte[k] * 1024 * 2 / 3, 1024);\n\t\t\tDETBufferSizeC[k] = DETBufferSizeInKByte[k] * 1024 - DETBufferSizeY[k];\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d SwathHeightY = %d\\n\", __func__, k, SwathHeightY[k]);\n\t\tdml_print(\"DML::%s: k=%0d SwathHeightC = %d\\n\", __func__, k, SwathHeightC[k]);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesY = %d\\n\", __func__,\n\t\t\t\tk, RoundedUpMaxSwathSizeBytesY[k]);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesC = %d\\n\", __func__,\n\t\t\t\tk, RoundedUpMaxSwathSizeBytesC[k]);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpSwathSizeBytesY = %d\\n\", __func__, k, RoundedUpSwathSizeBytesY);\n\t\tdml_print(\"DML::%s: k=%0d RoundedUpSwathSizeBytesC = %d\\n\", __func__, k, RoundedUpSwathSizeBytesC);\n\t\tdml_print(\"DML::%s: k=%0d DETBufferSizeInKByte = %d\\n\", __func__, k, DETBufferSizeInKByte[k]);\n\t\tdml_print(\"DML::%s: k=%0d DETBufferSizeY = %d\\n\", __func__, k, DETBufferSizeY[k]);\n\t\tdml_print(\"DML::%s: k=%0d DETBufferSizeC = %d\\n\", __func__, k, DETBufferSizeC[k]);\n\t\tdml_print(\"DML::%s: k=%0d ViewportSizeSupportPerSurface = %d\\n\", __func__, k,\n\t\t\t\tViewportSizeSupportPerSurface[k]);\n#endif\n\n\t}\n} \n\nvoid dml32_CalculateSwathWidth(\n\t\tbool\t\t\t\tForceSingleDPP,\n\t\tunsigned int\t\t\tNumberOfActiveSurfaces,\n\t\tenum source_format_class\tSourcePixelFormat[],\n\t\tenum dm_rotation_angle\t\tSourceRotation[],\n\t\tbool\t\t\t\tViewportStationary[],\n\t\tunsigned int\t\t\tViewportWidth[],\n\t\tunsigned int\t\t\tViewportHeight[],\n\t\tunsigned int\t\t\tViewportXStart[],\n\t\tunsigned int\t\t\tViewportYStart[],\n\t\tunsigned int\t\t\tViewportXStartC[],\n\t\tunsigned int\t\t\tViewportYStartC[],\n\t\tunsigned int\t\t\tSurfaceWidthY[],\n\t\tunsigned int\t\t\tSurfaceWidthC[],\n\t\tunsigned int\t\t\tSurfaceHeightY[],\n\t\tunsigned int\t\t\tSurfaceHeightC[],\n\t\tenum odm_combine_mode\t\tODMMode[],\n\t\tunsigned int\t\t\tBytePerPixY[],\n\t\tunsigned int\t\t\tBytePerPixC[],\n\t\tunsigned int\t\t\tRead256BytesBlockHeightY[],\n\t\tunsigned int\t\t\tRead256BytesBlockHeightC[],\n\t\tunsigned int\t\t\tRead256BytesBlockWidthY[],\n\t\tunsigned int\t\t\tRead256BytesBlockWidthC[],\n\t\tunsigned int\t\t\tBlendingAndTiming[],\n\t\tunsigned int\t\t\tHActive[],\n\t\tdouble\t\t\t\tHRatio[],\n\t\tunsigned int\t\t\tDPPPerSurface[],\n\n\t\t \n\t\tdouble\t\t\t\tSwathWidthdoubleDPPY[],\n\t\tdouble\t\t\t\tSwathWidthdoubleDPPC[],\n\t\tdouble\t\t\t\tSwathWidthY[], \n\t\tdouble\t\t\t\tSwathWidthC[], \n\t\tunsigned int\t\t\tMaximumSwathHeightY[],\n\t\tunsigned int\t\t\tMaximumSwathHeightC[],\n\t\tunsigned int\t\t\tswath_width_luma_ub[], \n\t\tunsigned int\t\t\tswath_width_chroma_ub[]) \n{\n\tunsigned int k, j;\n\tenum odm_combine_mode MainSurfaceODMMode;\n\n\tunsigned int surface_width_ub_l;\n\tunsigned int surface_height_ub_l;\n\tunsigned int surface_width_ub_c = 0;\n\tunsigned int surface_height_ub_c = 0;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ForceSingleDPP = %d\\n\", __func__, ForceSingleDPP);\n\tdml_print(\"DML::%s: NumberOfActiveSurfaces = %d\\n\", __func__, NumberOfActiveSurfaces);\n#endif\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (!IsVertical(SourceRotation[k]))\n\t\t\tSwathWidthdoubleDPPY[k] = ViewportWidth[k];\n\t\telse\n\t\t\tSwathWidthdoubleDPPY[k] = ViewportHeight[k];\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d ViewportWidth=%d\\n\", __func__, k, ViewportWidth[k]);\n\t\tdml_print(\"DML::%s: k=%d ViewportHeight=%d\\n\", __func__, k, ViewportHeight[k]);\n#endif\n\n\t\tMainSurfaceODMMode = ODMMode[k];\n\t\tfor (j = 0; j < NumberOfActiveSurfaces; ++j) {\n\t\t\tif (BlendingAndTiming[k] == j)\n\t\t\t\tMainSurfaceODMMode = ODMMode[j];\n\t\t}\n\n\t\tif (ForceSingleDPP) {\n\t\t\tSwathWidthY[k] = SwathWidthdoubleDPPY[k];\n\t\t} else {\n\t\t\tif (MainSurfaceODMMode == dm_odm_combine_mode_4to1) {\n\t\t\t\tSwathWidthY[k] = dml_min(SwathWidthdoubleDPPY[k],\n\t\t\t\t\t\tdml_round(HActive[k] / 4.0 * HRatio[k]));\n\t\t\t} else if (MainSurfaceODMMode == dm_odm_combine_mode_2to1) {\n\t\t\t\tSwathWidthY[k] = dml_min(SwathWidthdoubleDPPY[k],\n\t\t\t\t\t\tdml_round(HActive[k] / 2.0 * HRatio[k]));\n\t\t\t} else if (DPPPerSurface[k] == 2) {\n\t\t\t\tSwathWidthY[k] = SwathWidthdoubleDPPY[k] / 2;\n\t\t\t} else {\n\t\t\t\tSwathWidthY[k] = SwathWidthdoubleDPPY[k];\n\t\t\t}\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d HActive=%d\\n\", __func__, k, HActive[k]);\n\t\tdml_print(\"DML::%s: k=%d HRatio=%f\\n\", __func__, k, HRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d MainSurfaceODMMode=%d\\n\", __func__, k, MainSurfaceODMMode);\n\t\tdml_print(\"DML::%s: k=%d SwathWidthdoubleDPPY=%d\\n\", __func__, k, SwathWidthdoubleDPPY[k]);\n\t\tdml_print(\"DML::%s: k=%d SwathWidthY=%d\\n\", __func__, k, SwathWidthY[k]);\n#endif\n\n\t\tif (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 ||\n\t\t\t\tSourcePixelFormat[k] == dm_420_12) {\n\t\t\tSwathWidthC[k] = SwathWidthY[k] / 2;\n\t\t\tSwathWidthdoubleDPPC[k] = SwathWidthdoubleDPPY[k] / 2;\n\t\t} else {\n\t\t\tSwathWidthC[k] = SwathWidthY[k];\n\t\t\tSwathWidthdoubleDPPC[k] = SwathWidthdoubleDPPY[k];\n\t\t}\n\n\t\tif (ForceSingleDPP == true) {\n\t\t\tSwathWidthY[k] = SwathWidthdoubleDPPY[k];\n\t\t\tSwathWidthC[k] = SwathWidthdoubleDPPC[k];\n\t\t}\n\n\t\tsurface_width_ub_l  = dml_ceil(SurfaceWidthY[k], Read256BytesBlockWidthY[k]);\n\t\tsurface_height_ub_l = dml_ceil(SurfaceHeightY[k], Read256BytesBlockHeightY[k]);\n\n\t\tif (!IsVertical(SourceRotation[k])) {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockHeightY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockHeightC[k];\n\t\t\tif (ViewportStationary[k] && DPPPerSurface[k] == 1) {\n\t\t\t\tswath_width_luma_ub[k] = dml_min(surface_width_ub_l,\n\t\t\t\t\t\tdml_floor(ViewportXStart[k] +\n\t\t\t\t\t\t\t\tSwathWidthY[k] +\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k] - 1,\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k]) -\n\t\t\t\t\t\t\t\tdml_floor(ViewportXStart[k],\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k]));\n\t\t\t} else {\n\t\t\t\tswath_width_luma_ub[k] = dml_min(surface_width_ub_l,\n\t\t\t\t\t\tdml_ceil(SwathWidthY[k] - 1,\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k]) +\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k]);\n\t\t\t}\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tsurface_width_ub_c  = dml_ceil(SurfaceWidthC[k], Read256BytesBlockWidthC[k]);\n\t\t\t\tif (ViewportStationary[k] && DPPPerSurface[k] == 1) {\n\t\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_width_ub_c,\n\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k] + SwathWidthC[k] +\n\t\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k] - 1,\n\t\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]) -\n\t\t\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k],\n\t\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]));\n\t\t\t\t} else {\n\t\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_width_ub_c,\n\t\t\t\t\t\t\tdml_ceil(SwathWidthC[k] - 1,\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]) +\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockWidthY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockWidthC[k];\n\n\t\t\tif (ViewportStationary[k] && DPPPerSurface[k] == 1) {\n\t\t\t\tswath_width_luma_ub[k] = dml_min(surface_height_ub_l, dml_floor(ViewportYStart[k] +\n\t\t\t\t\t\tSwathWidthY[k] + Read256BytesBlockHeightY[k] - 1,\n\t\t\t\t\t\tRead256BytesBlockHeightY[k]) -\n\t\t\t\t\t\tdml_floor(ViewportYStart[k], Read256BytesBlockHeightY[k]));\n\t\t\t} else {\n\t\t\t\tswath_width_luma_ub[k] = dml_min(surface_height_ub_l, dml_ceil(SwathWidthY[k] - 1,\n\t\t\t\t\t\tRead256BytesBlockHeightY[k]) + Read256BytesBlockHeightY[k]);\n\t\t\t}\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tsurface_height_ub_c = dml_ceil(SurfaceHeightC[k], Read256BytesBlockHeightC[k]);\n\t\t\t\tif (ViewportStationary[k] && DPPPerSurface[k] == 1) {\n\t\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_height_ub_c,\n\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k] + SwathWidthC[k] +\n\t\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k] - 1,\n\t\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]) -\n\t\t\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k],\n\t\t\t\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]));\n\t\t\t\t} else {\n\t\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_height_ub_c,\n\t\t\t\t\t\t\tdml_ceil(SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) +\n\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d surface_width_ub_l=%0d\\n\", __func__, k, surface_width_ub_l);\n\t\tdml_print(\"DML::%s: k=%d surface_height_ub_l=%0d\\n\", __func__, k, surface_height_ub_l);\n\t\tdml_print(\"DML::%s: k=%d surface_width_ub_c=%0d\\n\", __func__, k, surface_width_ub_c);\n\t\tdml_print(\"DML::%s: k=%d surface_height_ub_c=%0d\\n\", __func__, k, surface_height_ub_c);\n\t\tdml_print(\"DML::%s: k=%d Read256BytesBlockWidthY=%0d\\n\", __func__, k, Read256BytesBlockWidthY[k]);\n\t\tdml_print(\"DML::%s: k=%d Read256BytesBlockHeightY=%0d\\n\", __func__, k, Read256BytesBlockHeightY[k]);\n\t\tdml_print(\"DML::%s: k=%d Read256BytesBlockWidthC=%0d\\n\", __func__, k, Read256BytesBlockWidthC[k]);\n\t\tdml_print(\"DML::%s: k=%d Read256BytesBlockHeightC=%0d\\n\", __func__, k, Read256BytesBlockHeightC[k]);\n\t\tdml_print(\"DML::%s: k=%d ViewportStationary=%0d\\n\", __func__, k, ViewportStationary[k]);\n\t\tdml_print(\"DML::%s: k=%d DPPPerSurface=%0d\\n\", __func__, k, DPPPerSurface[k]);\n\t\tdml_print(\"DML::%s: k=%d swath_width_luma_ub=%0d\\n\", __func__, k, swath_width_luma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d swath_width_chroma_ub=%0d\\n\", __func__, k, swath_width_chroma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d MaximumSwathHeightY=%0d\\n\", __func__, k, MaximumSwathHeightY[k]);\n\t\tdml_print(\"DML::%s: k=%d MaximumSwathHeightC=%0d\\n\", __func__, k, MaximumSwathHeightC[k]);\n#endif\n\n\t}\n} \n\nbool dml32_UnboundedRequest(enum unbounded_requesting_policy UseUnboundedRequestingFinal,\n\t\t\tunsigned int TotalNumberOfActiveDPP,\n\t\t\tbool NoChroma,\n\t\t\tenum output_encoder_class Output,\n\t\t\tenum dm_swizzle_mode SurfaceTiling,\n\t\t\tbool CompBufReservedSpaceNeedAdjustment,\n\t\t\tbool DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment)\n{\n\tbool ret_val = false;\n\n\tret_val = (UseUnboundedRequestingFinal != dm_unbounded_requesting_disable &&\n\t\t\tTotalNumberOfActiveDPP == 1 && NoChroma);\n\tif (UseUnboundedRequestingFinal == dm_unbounded_requesting_edp_only && Output != dm_edp)\n\t\tret_val = false;\n\n\tif (SurfaceTiling == dm_sw_linear)\n\t\tret_val = false;\n\n\tif (CompBufReservedSpaceNeedAdjustment == 1 && DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment)\n\t\tret_val = false;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: CompBufReservedSpaceNeedAdjustment  = %d\\n\",  __func__, CompBufReservedSpaceNeedAdjustment);\n\tdml_print(\"DML::%s: DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment  = %d\\n\",  __func__, DisableUnboundRequestIfCompBufReservedSpaceNeedAdjustment);\n\tdml_print(\"DML::%s: ret_val = %d\\n\",  __func__, ret_val);\n#endif\n\n\treturn (ret_val);\n}\n\nvoid dml32_CalculateDETBufferSize(\n\t\tunsigned int DETSizeOverride[],\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],\n\t\tbool ForceSingleDPP,\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tbool UnboundedRequestEnabled,\n\t\tunsigned int nomDETInKByte,\n\t\tunsigned int MaxTotalDETInKByte,\n\t\tunsigned int ConfigReturnBufferSizeInKByte,\n\t\tunsigned int MinCompressedBufferSizeInKByte,\n\t\tunsigned int CompressedBufferSegmentSizeInkByteFinal,\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tunsigned int RoundedUpMaxSwathSizeBytesY[],\n\t\tunsigned int RoundedUpMaxSwathSizeBytesC[],\n\t\tunsigned int DPPPerSurface[],\n\t\t \n\t\tunsigned int DETBufferSizeInKByte[],\n\t\tunsigned int *CompressedBufferSizeInkByte)\n{\n\tunsigned int DETBufferSizePoolInKByte;\n\tunsigned int NextDETBufferPieceInKByte;\n\tbool DETPieceAssignedToThisSurfaceAlready[DC__NUM_DPP__MAX];\n\tbool NextPotentialSurfaceToAssignDETPieceFound;\n\tunsigned int NextSurfaceToAssignDETPiece;\n\tdouble TotalBandwidth;\n\tdouble BandwidthOfSurfacesNotAssignedDETPiece;\n\tunsigned int max_minDET;\n\tunsigned int minDET;\n\tunsigned int minDET_pipe;\n\tunsigned int j, k;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ForceSingleDPP = %d\\n\", __func__, ForceSingleDPP);\n\tdml_print(\"DML::%s: nomDETInKByte = %d\\n\", __func__, nomDETInKByte);\n\tdml_print(\"DML::%s: NumberOfActiveSurfaces = %d\\n\", __func__, NumberOfActiveSurfaces);\n\tdml_print(\"DML::%s: UnboundedRequestEnabled = %d\\n\", __func__, UnboundedRequestEnabled);\n\tdml_print(\"DML::%s: MaxTotalDETInKByte = %d\\n\", __func__, MaxTotalDETInKByte);\n\tdml_print(\"DML::%s: ConfigReturnBufferSizeInKByte = %d\\n\", __func__, ConfigReturnBufferSizeInKByte);\n\tdml_print(\"DML::%s: MinCompressedBufferSizeInKByte = %d\\n\", __func__, MinCompressedBufferSizeInKByte);\n\tdml_print(\"DML::%s: CompressedBufferSegmentSizeInkByteFinal = %d\\n\", __func__,\n\t\t\tCompressedBufferSegmentSizeInkByteFinal);\n#endif\n\n\t\n\tif (UnboundedRequestEnabled) {\n\t\tif (DETSizeOverride[0] > 0) {\n\t\t\tDETBufferSizeInKByte[0] = DETSizeOverride[0];\n\t\t} else {\n\t\t\tDETBufferSizeInKByte[0] = dml_max(nomDETInKByte, dml_ceil(2.0 *\n\t\t\t\t\t((double) RoundedUpMaxSwathSizeBytesY[0] +\n\t\t\t\t\t\t\t(double) RoundedUpMaxSwathSizeBytesC[0]) / 1024.0, 64.0));\n\t\t}\n\t\t*CompressedBufferSizeInkByte = ConfigReturnBufferSizeInKByte - DETBufferSizeInKByte[0];\n\t} else {\n\t\tDETBufferSizePoolInKByte = MaxTotalDETInKByte;\n\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\tDETBufferSizeInKByte[k] = nomDETInKByte;\n\t\t\tif (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 ||\n\t\t\t\t\tSourcePixelFormat[k] == dm_420_12) {\n\t\t\t\tmax_minDET = nomDETInKByte - 64;\n\t\t\t} else {\n\t\t\t\tmax_minDET = nomDETInKByte;\n\t\t\t}\n\t\t\tminDET = 128;\n\t\t\tminDET_pipe = 0;\n\n\t\t\t\n\t\t\twhile (minDET <= max_minDET && minDET_pipe == 0) {\n\t\t\t\tif (2.0 * ((double) RoundedUpMaxSwathSizeBytesY[k] +\n\t\t\t\t\t\t(double) RoundedUpMaxSwathSizeBytesC[k]) / 1024.0 <= minDET)\n\t\t\t\t\tminDET_pipe = minDET;\n\t\t\t\tminDET = minDET + 64;\n\t\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d minDET        = %d\\n\", __func__, k, minDET);\n\t\t\tdml_print(\"DML::%s: k=%0d max_minDET    = %d\\n\", __func__, k, max_minDET);\n\t\t\tdml_print(\"DML::%s: k=%0d minDET_pipe   = %d\\n\", __func__, k, minDET_pipe);\n\t\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesY = %d\\n\", __func__, k,\n\t\t\t\t\tRoundedUpMaxSwathSizeBytesY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d RoundedUpMaxSwathSizeBytesC = %d\\n\", __func__, k,\n\t\t\t\t\tRoundedUpMaxSwathSizeBytesC[k]);\n#endif\n\n\t\t\tif (minDET_pipe == 0) {\n\t\t\t\tminDET_pipe = dml_max(128, dml_ceil(((double)RoundedUpMaxSwathSizeBytesY[k] +\n\t\t\t\t\t\t(double)RoundedUpMaxSwathSizeBytesC[k]) / 1024.0, 64));\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: k=%0d minDET_pipe = %d (assume each plane take half DET)\\n\",\n\t\t\t\t\t\t__func__, k, minDET_pipe);\n#endif\n\t\t\t}\n\n\t\t\tif (UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\t\tDETBufferSizeInKByte[k] = 0;\n\t\t\t} else if (DETSizeOverride[k] > 0) {\n\t\t\t\tDETBufferSizeInKByte[k] = DETSizeOverride[k];\n\t\t\t\tDETBufferSizePoolInKByte = DETBufferSizePoolInKByte -\n\t\t\t\t\t\t(ForceSingleDPP ? 1 : DPPPerSurface[k]) * DETSizeOverride[k];\n\t\t\t} else if ((ForceSingleDPP ? 1 : DPPPerSurface[k]) * minDET_pipe <= DETBufferSizePoolInKByte) {\n\t\t\t\tDETBufferSizeInKByte[k] = minDET_pipe;\n\t\t\t\tDETBufferSizePoolInKByte = DETBufferSizePoolInKByte -\n\t\t\t\t\t\t(ForceSingleDPP ? 1 : DPPPerSurface[k]) * minDET_pipe;\n\t\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%d DPPPerSurface = %d\\n\", __func__, k, DPPPerSurface[k]);\n\t\t\tdml_print(\"DML::%s: k=%d DETSizeOverride = %d\\n\", __func__, k, DETSizeOverride[k]);\n\t\t\tdml_print(\"DML::%s: k=%d DETBufferSizeInKByte = %d\\n\", __func__, k, DETBufferSizeInKByte[k]);\n\t\t\tdml_print(\"DML::%s: DETBufferSizePoolInKByte = %d\\n\", __func__, DETBufferSizePoolInKByte);\n#endif\n\t\t}\n\n\t\tTotalBandwidth = 0;\n\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe)\n\t\t\t\tTotalBandwidth = TotalBandwidth + ReadBandwidthLuma[k] + ReadBandwidthChroma[k];\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: --- Before bandwidth adjustment ---\\n\", __func__);\n\t\tfor (uint k = 0; k < NumberOfActiveSurfaces; ++k)\n\t\t\tdml_print(\"DML::%s: k=%d DETBufferSizeInKByte   = %d\\n\", __func__, k, DETBufferSizeInKByte[k]);\n\t\tdml_print(\"DML::%s: --- DET allocation with bandwidth ---\\n\", __func__);\n\t\tdml_print(\"DML::%s: TotalBandwidth = %f\\n\", __func__, TotalBandwidth);\n#endif\n\t\tBandwidthOfSurfacesNotAssignedDETPiece = TotalBandwidth;\n\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\n\t\t\tif (UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\t\tDETPieceAssignedToThisSurfaceAlready[k] = true;\n\t\t\t} else if (DETSizeOverride[k] > 0 || (((double) (ForceSingleDPP ? 1 : DPPPerSurface[k]) *\n\t\t\t\t\t(double) DETBufferSizeInKByte[k] / (double) MaxTotalDETInKByte) >=\n\t\t\t\t\t((ReadBandwidthLuma[k] + ReadBandwidthChroma[k]) / TotalBandwidth))) {\n\t\t\t\tDETPieceAssignedToThisSurfaceAlready[k] = true;\n\t\t\t\tBandwidthOfSurfacesNotAssignedDETPiece = BandwidthOfSurfacesNotAssignedDETPiece -\n\t\t\t\t\t\tReadBandwidthLuma[k] - ReadBandwidthChroma[k];\n\t\t\t} else {\n\t\t\t\tDETPieceAssignedToThisSurfaceAlready[k] = false;\n\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%d DETPieceAssignedToThisSurfaceAlready = %d\\n\", __func__, k,\n\t\t\t\t\tDETPieceAssignedToThisSurfaceAlready[k]);\n\t\t\tdml_print(\"DML::%s: k=%d BandwidthOfSurfacesNotAssignedDETPiece = %f\\n\", __func__, k,\n\t\t\t\t\tBandwidthOfSurfacesNotAssignedDETPiece);\n#endif\n\t\t}\n\n\t\tfor (j = 0; j < NumberOfActiveSurfaces; ++j) {\n\t\t\tNextPotentialSurfaceToAssignDETPieceFound = false;\n\t\t\tNextSurfaceToAssignDETPiece = 0;\n\n\t\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, ReadBandwidthLuma[k] = %f\\n\", __func__, j, k,\n\t\t\t\t\t\tReadBandwidthLuma[k]);\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, ReadBandwidthChroma[k] = %f\\n\", __func__, j, k,\n\t\t\t\t\t\tReadBandwidthChroma[k]);\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, ReadBandwidthLuma[Next] = %f\\n\", __func__, j, k,\n\t\t\t\t\t\tReadBandwidthLuma[NextSurfaceToAssignDETPiece]);\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, ReadBandwidthChroma[Next] = %f\\n\", __func__, j, k,\n\t\t\t\t\t\tReadBandwidthChroma[NextSurfaceToAssignDETPiece]);\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, NextSurfaceToAssignDETPiece = %d\\n\", __func__, j, k,\n\t\t\t\t\t\tNextSurfaceToAssignDETPiece);\n#endif\n\t\t\t\tif (!DETPieceAssignedToThisSurfaceAlready[k] &&\n\t\t\t\t\t\t(!NextPotentialSurfaceToAssignDETPieceFound ||\n\t\t\t\t\t\tReadBandwidthLuma[k] + ReadBandwidthChroma[k] <\n\t\t\t\t\t\tReadBandwidthLuma[NextSurfaceToAssignDETPiece] +\n\t\t\t\t\t\tReadBandwidthChroma[NextSurfaceToAssignDETPiece])) {\n\t\t\t\t\tNextSurfaceToAssignDETPiece = k;\n\t\t\t\t\tNextPotentialSurfaceToAssignDETPieceFound = true;\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, DETPieceAssignedToThisSurfaceAlready = %d\\n\",\n\t\t\t\t\t\t__func__, j, k, DETPieceAssignedToThisSurfaceAlready[k]);\n\t\t\t\tdml_print(\"DML::%s: j=%d k=%d, NextPotentialSurfaceToAssignDETPieceFound = %d\\n\",\n\t\t\t\t\t\t__func__, j, k, NextPotentialSurfaceToAssignDETPieceFound);\n#endif\n\t\t\t}\n\n\t\t\tif (NextPotentialSurfaceToAssignDETPieceFound) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\n\t\t\t\tNextDETBufferPieceInKByte = dml_min(\n\t\t\t\t\tdml_round((double) DETBufferSizePoolInKByte *\n\t\t\t\t\t\t(ReadBandwidthLuma[NextSurfaceToAssignDETPiece] +\n\t\t\t\t\t\tReadBandwidthChroma[NextSurfaceToAssignDETPiece]) /\n\t\t\t\t\t\tBandwidthOfSurfacesNotAssignedDETPiece /\n\t\t\t\t\t\t((ForceSingleDPP ? 1 :\n\t\t\t\t\t\t\t\tDPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0)) *\n\t\t\t\t\t\t(ForceSingleDPP ? 1 :\n\t\t\t\t\t\t\t\tDPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0,\n\t\t\t\t\t\tdml_floor((double) DETBufferSizePoolInKByte,\n\t\t\t\t\t\t(ForceSingleDPP ? 1 :\n\t\t\t\t\t\t\t\tDPPPerSurface[NextSurfaceToAssignDETPiece]) * 64.0));\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (NextDETBufferPieceInKByte > nomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k])) {\n\t\t\t\t\tif (DETBufferSizeInKByte[NextSurfaceToAssignDETPiece] <\n\t\t\t\t\t\t\tnomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k])) {\n\t\t\t\t\t\tNextDETBufferPieceInKByte = nomDETInKByte * (ForceSingleDPP ? 1 : DPPPerSurface[k]) -\n\t\t\t\t\t\t\t\tDETBufferSizeInKByte[NextSurfaceToAssignDETPiece];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tNextDETBufferPieceInKByte = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: j=%0d, DETBufferSizePoolInKByte = %d\\n\", __func__, j,\n\t\t\t\t\tDETBufferSizePoolInKByte);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, NextSurfaceToAssignDETPiece = %d\\n\", __func__, j,\n\t\t\t\t\tNextSurfaceToAssignDETPiece);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, ReadBandwidthLuma[%0d] = %f\\n\", __func__, j,\n\t\t\t\t\tNextSurfaceToAssignDETPiece, ReadBandwidthLuma[NextSurfaceToAssignDETPiece]);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, ReadBandwidthChroma[%0d] = %f\\n\", __func__, j,\n\t\t\t\t\tNextSurfaceToAssignDETPiece, ReadBandwidthChroma[NextSurfaceToAssignDETPiece]);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, BandwidthOfSurfacesNotAssignedDETPiece = %f\\n\",\n\t\t\t\t\t__func__, j, BandwidthOfSurfacesNotAssignedDETPiece);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, NextDETBufferPieceInKByte = %d\\n\", __func__, j,\n\t\t\t\t\tNextDETBufferPieceInKByte);\n\t\t\t\tdml_print(\"DML::%s: j=%0d, DETBufferSizeInKByte[%0d] increases from %0d \",\n\t\t\t\t\t__func__, j, NextSurfaceToAssignDETPiece,\n\t\t\t\t\tDETBufferSizeInKByte[NextSurfaceToAssignDETPiece]);\n#endif\n\n\t\t\t\tDETBufferSizeInKByte[NextSurfaceToAssignDETPiece] =\n\t\t\t\t\t\tDETBufferSizeInKByte[NextSurfaceToAssignDETPiece]\n\t\t\t\t\t\t+ NextDETBufferPieceInKByte\n\t\t\t\t\t\t/ (ForceSingleDPP ? 1 : DPPPerSurface[NextSurfaceToAssignDETPiece]);\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"to %0d\\n\", DETBufferSizeInKByte[NextSurfaceToAssignDETPiece]);\n#endif\n\n\t\t\t\tDETBufferSizePoolInKByte = DETBufferSizePoolInKByte - NextDETBufferPieceInKByte;\n\t\t\t\tDETPieceAssignedToThisSurfaceAlready[NextSurfaceToAssignDETPiece] = true;\n\t\t\t\tBandwidthOfSurfacesNotAssignedDETPiece = BandwidthOfSurfacesNotAssignedDETPiece -\n\t\t\t\t\t\t(ReadBandwidthLuma[NextSurfaceToAssignDETPiece] +\n\t\t\t\t\t\t\t\tReadBandwidthChroma[NextSurfaceToAssignDETPiece]);\n\t\t\t}\n\t\t}\n\t\t*CompressedBufferSizeInkByte = MinCompressedBufferSizeInKByte;\n\t}\n\t*CompressedBufferSizeInkByte = *CompressedBufferSizeInkByte * CompressedBufferSegmentSizeInkByteFinal / 64;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: --- After bandwidth adjustment ---\\n\", __func__);\n\tdml_print(\"DML::%s: CompressedBufferSizeInkByte = %d\\n\", __func__, *CompressedBufferSizeInkByte);\n\tfor (uint k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tdml_print(\"DML::%s: k=%d DETBufferSizeInKByte = %d (TotalReadBandWidth=%f)\\n\",\n\t\t\t\t__func__, k, DETBufferSizeInKByte[k], ReadBandwidthLuma[k] + ReadBandwidthChroma[k]);\n\t}\n#endif\n} \n\nvoid dml32_CalculateODMMode(\n\t\tunsigned int MaximumPixelsPerLinePerDSCUnit,\n\t\tunsigned int HActive,\n\t\tenum output_format_class OutFormat,\n\t\tenum output_encoder_class Output,\n\t\tenum odm_combine_policy ODMUse,\n\t\tdouble StateDispclk,\n\t\tdouble MaxDispclk,\n\t\tbool DSCEnable,\n\t\tunsigned int TotalNumberOfActiveDPP,\n\t\tunsigned int MaxNumDPP,\n\t\tdouble PixelClock,\n\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,\n\t\tdouble DISPCLKRampingMargin,\n\t\tdouble DISPCLKDPPCLKVCOSpeed,\n\t\tunsigned int NumberOfDSCSlices,\n\n\t\t \n\t\tbool *TotalAvailablePipesSupport,\n\t\tunsigned int *NumberOfDPP,\n\t\tenum odm_combine_mode *ODMMode,\n\t\tdouble *RequiredDISPCLKPerSurface)\n{\n\n\tdouble SurfaceRequiredDISPCLKWithoutODMCombine;\n\tdouble SurfaceRequiredDISPCLKWithODMCombineTwoToOne;\n\tdouble SurfaceRequiredDISPCLKWithODMCombineFourToOne;\n\n\tSurfaceRequiredDISPCLKWithoutODMCombine = dml32_CalculateRequiredDispclk(dm_odm_combine_mode_disabled,\n\t\t\tPixelClock, DISPCLKDPPCLKDSCCLKDownSpreading, DISPCLKRampingMargin, DISPCLKDPPCLKVCOSpeed,\n\t\t\tMaxDispclk);\n\tSurfaceRequiredDISPCLKWithODMCombineTwoToOne = dml32_CalculateRequiredDispclk(dm_odm_combine_mode_2to1,\n\t\t\tPixelClock, DISPCLKDPPCLKDSCCLKDownSpreading, DISPCLKRampingMargin, DISPCLKDPPCLKVCOSpeed,\n\t\t\tMaxDispclk);\n\tSurfaceRequiredDISPCLKWithODMCombineFourToOne = dml32_CalculateRequiredDispclk(dm_odm_combine_mode_4to1,\n\t\t\tPixelClock, DISPCLKDPPCLKDSCCLKDownSpreading, DISPCLKRampingMargin, DISPCLKDPPCLKVCOSpeed,\n\t\t\tMaxDispclk);\n\t*TotalAvailablePipesSupport = true;\n\t*ODMMode = dm_odm_combine_mode_disabled; \n\n\tif (ODMUse == dm_odm_combine_policy_none)\n\t\t*ODMMode = dm_odm_combine_mode_disabled;\n\n\t*RequiredDISPCLKPerSurface = SurfaceRequiredDISPCLKWithoutODMCombine;\n\t*NumberOfDPP = 0;\n\n\t\n\t\n\n\tif (!(Output == dm_hdmi || Output == dm_dp || Output == dm_edp) && (ODMUse == dm_odm_combine_policy_4to1 ||\n\t\t\t((SurfaceRequiredDISPCLKWithODMCombineTwoToOne > StateDispclk ||\n\t\t\t\t\t(DSCEnable && (HActive > 2 * MaximumPixelsPerLinePerDSCUnit))\n\t\t\t\t\t|| NumberOfDSCSlices > 8)))) {\n\t\tif (TotalNumberOfActiveDPP + 4 <= MaxNumDPP) {\n\t\t\t*ODMMode = dm_odm_combine_mode_4to1;\n\t\t\t*RequiredDISPCLKPerSurface = SurfaceRequiredDISPCLKWithODMCombineFourToOne;\n\t\t\t*NumberOfDPP = 4;\n\t\t} else {\n\t\t\t*TotalAvailablePipesSupport = false;\n\t\t}\n\t} else if (Output != dm_hdmi && (ODMUse == dm_odm_combine_policy_2to1 ||\n\t\t\t(((SurfaceRequiredDISPCLKWithoutODMCombine > StateDispclk &&\n\t\t\t\t\tSurfaceRequiredDISPCLKWithODMCombineTwoToOne <= StateDispclk) ||\n\t\t\t\t\t(DSCEnable && (HActive > MaximumPixelsPerLinePerDSCUnit))\n\t\t\t\t\t|| (NumberOfDSCSlices <= 8 && NumberOfDSCSlices > 4))))) {\n\t\tif (TotalNumberOfActiveDPP + 2 <= MaxNumDPP) {\n\t\t\t*ODMMode = dm_odm_combine_mode_2to1;\n\t\t\t*RequiredDISPCLKPerSurface = SurfaceRequiredDISPCLKWithODMCombineTwoToOne;\n\t\t\t*NumberOfDPP = 2;\n\t\t} else {\n\t\t\t*TotalAvailablePipesSupport = false;\n\t\t}\n\t} else {\n\t\tif (TotalNumberOfActiveDPP + 1 <= MaxNumDPP)\n\t\t\t*NumberOfDPP = 1;\n\t\telse\n\t\t\t*TotalAvailablePipesSupport = false;\n\t}\n\tif (OutFormat == dm_420 && HActive > DCN32_MAX_FMT_420_BUFFER_WIDTH &&\n\t\t\tODMUse != dm_odm_combine_policy_4to1) {\n\t\tif (HActive > DCN32_MAX_FMT_420_BUFFER_WIDTH * 4) {\n\t\t\t*ODMMode = dm_odm_combine_mode_disabled;\n\t\t\t*NumberOfDPP = 0;\n\t\t\t*TotalAvailablePipesSupport = false;\n\t\t} else if (HActive > DCN32_MAX_FMT_420_BUFFER_WIDTH * 2 ||\n\t\t\t\t*ODMMode == dm_odm_combine_mode_4to1) {\n\t\t\t*ODMMode = dm_odm_combine_mode_4to1;\n\t\t\t*RequiredDISPCLKPerSurface = SurfaceRequiredDISPCLKWithODMCombineFourToOne;\n\t\t\t*NumberOfDPP = 4;\n\t\t} else {\n\t\t\t*ODMMode = dm_odm_combine_mode_2to1;\n\t\t\t*RequiredDISPCLKPerSurface = SurfaceRequiredDISPCLKWithODMCombineTwoToOne;\n\t\t\t*NumberOfDPP = 2;\n\t\t}\n\t}\n\tif (Output == dm_hdmi && OutFormat == dm_420 &&\n\t\t\tHActive > DCN32_MAX_FMT_420_BUFFER_WIDTH) {\n\t\t*ODMMode = dm_odm_combine_mode_disabled;\n\t\t*NumberOfDPP = 0;\n\t\t*TotalAvailablePipesSupport = false;\n\t}\n}\n\ndouble dml32_CalculateRequiredDispclk(\n\t\tenum odm_combine_mode ODMMode,\n\t\tdouble PixelClock,\n\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,\n\t\tdouble DISPCLKRampingMargin,\n\t\tdouble DISPCLKDPPCLKVCOSpeed,\n\t\tdouble MaxDispclk)\n{\n\tdouble RequiredDispclk = 0.;\n\tdouble PixelClockAfterODM;\n\tdouble DISPCLKWithRampingRoundedToDFSGranularity;\n\tdouble DISPCLKWithoutRampingRoundedToDFSGranularity;\n\tdouble MaxDispclkRoundedDownToDFSGranularity;\n\n\tif (ODMMode == dm_odm_combine_mode_4to1)\n\t\tPixelClockAfterODM = PixelClock / 4;\n\telse if (ODMMode == dm_odm_combine_mode_2to1)\n\t\tPixelClockAfterODM = PixelClock / 2;\n\telse\n\t\tPixelClockAfterODM = PixelClock;\n\n\n\tDISPCLKWithRampingRoundedToDFSGranularity = dml32_RoundToDFSGranularity(\n\t\t\tPixelClockAfterODM * (1 + DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t* (1 + DISPCLKRampingMargin / 100), 1, DISPCLKDPPCLKVCOSpeed);\n\n\tDISPCLKWithoutRampingRoundedToDFSGranularity = dml32_RoundToDFSGranularity(\n\t\t\tPixelClockAfterODM * (1 + DISPCLKDPPCLKDSCCLKDownSpreading / 100), 1, DISPCLKDPPCLKVCOSpeed);\n\n\tMaxDispclkRoundedDownToDFSGranularity = dml32_RoundToDFSGranularity(MaxDispclk, 0, DISPCLKDPPCLKVCOSpeed);\n\n\tif (DISPCLKWithoutRampingRoundedToDFSGranularity > MaxDispclkRoundedDownToDFSGranularity)\n\t\tRequiredDispclk = DISPCLKWithoutRampingRoundedToDFSGranularity;\n\telse if (DISPCLKWithRampingRoundedToDFSGranularity > MaxDispclkRoundedDownToDFSGranularity)\n\t\tRequiredDispclk = MaxDispclkRoundedDownToDFSGranularity;\n\telse\n\t\tRequiredDispclk = DISPCLKWithRampingRoundedToDFSGranularity;\n\n\treturn RequiredDispclk;\n}\n\ndouble dml32_RoundToDFSGranularity(double Clock, bool round_up, double VCOSpeed)\n{\n\tif (Clock <= 0.0)\n\t\treturn 0.0;\n\n\tif (round_up)\n\t\treturn VCOSpeed * 4.0 / dml_floor(VCOSpeed * 4.0 / Clock, 1.0);\n\telse\n\t\treturn VCOSpeed * 4.0 / dml_ceil(VCOSpeed * 4.0 / Clock, 1.0);\n}\n\nvoid dml32_CalculateOutputLink(\n\t\tdouble PHYCLKPerState,\n\t\tdouble PHYCLKD18PerState,\n\t\tdouble PHYCLKD32PerState,\n\t\tdouble Downspreading,\n\t\tbool IsMainSurfaceUsingTheIndicatedTiming,\n\t\tenum output_encoder_class Output,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int HTotal,\n\t\tunsigned int HActive,\n\t\tdouble PixelClockBackEnd,\n\t\tdouble ForcedOutputLinkBPP,\n\t\tunsigned int DSCInputBitPerComponent,\n\t\tunsigned int NumberOfDSCSlices,\n\t\tdouble AudioSampleRate,\n\t\tunsigned int AudioSampleLayout,\n\t\tenum odm_combine_mode ODMModeNoDSC,\n\t\tenum odm_combine_mode ODMModeDSC,\n\t\tbool DSCEnable,\n\t\tunsigned int OutputLinkDPLanes,\n\t\tenum dm_output_link_dp_rate OutputLinkDPRate,\n\n\t\t \n\t\tbool *RequiresDSC,\n\t\tdouble *RequiresFEC,\n\t\tdouble  *OutBpp,\n\t\tenum dm_output_type *OutputType,\n\t\tenum dm_output_rate *OutputRate,\n\t\tunsigned int *RequiredSlots)\n{\n\tbool LinkDSCEnable;\n\tunsigned int dummy;\n\t*RequiresDSC = false;\n\t*RequiresFEC = false;\n\t*OutBpp = 0;\n\t*OutputType = dm_output_type_unknown;\n\t*OutputRate = dm_output_rate_unknown;\n\n\tif (IsMainSurfaceUsingTheIndicatedTiming) {\n\t\tif (Output == dm_hdmi) {\n\t\t\t*RequiresDSC = false;\n\t\t\t*RequiresFEC = false;\n\t\t\t*OutBpp = dml32_TruncToValidBPP(dml_min(600, PHYCLKPerState) * 10, 3, HTotal, HActive,\n\t\t\t\t\tPixelClockBackEnd, ForcedOutputLinkBPP, false, Output, OutputFormat,\n\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\tODMModeNoDSC, ODMModeDSC, &dummy);\n\t\t\t\n\t\t\t*OutputType = dm_output_type_hdmi;\n\n\t\t} else if (Output == dm_dp || Output == dm_dp2p0 || Output == dm_edp) {\n\t\t\tif (DSCEnable == true) {\n\t\t\t\t*RequiresDSC = true;\n\t\t\t\tLinkDSCEnable = true;\n\t\t\t\tif (Output == dm_dp || Output == dm_dp2p0)\n\t\t\t\t\t*RequiresFEC = true;\n\t\t\t\telse\n\t\t\t\t\t*RequiresFEC = false;\n\t\t\t} else {\n\t\t\t\t*RequiresDSC = false;\n\t\t\t\tLinkDSCEnable = false;\n\t\t\t\tif (Output == dm_dp2p0)\n\t\t\t\t\t*RequiresFEC = true;\n\t\t\t\telse\n\t\t\t\t\t*RequiresFEC = false;\n\t\t\t}\n\t\t\tif (Output == dm_dp2p0) {\n\t\t\t\t*OutBpp = 0;\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_uhbr10) &&\n\t\t\t\t\t\tPHYCLKD32PerState >= 10000 / 32) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 10000,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output, OutputFormat,\n\t\t\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate,\n\t\t\t\t\t\t\tAudioSampleLayout, ODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\tif (*OutBpp == 0 && PHYCLKD32PerState < 13500 / 32 && DSCEnable == true &&\n\t\t\t\t\t\t\tForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 10000,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = dm_output_type_dp2p0;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_uhbr10;\n\t\t\t\t}\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_uhbr13p5) &&\n\t\t\t\t\t\t*OutBpp == 0 && PHYCLKD32PerState >= 13500 / 32) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 13500,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output, OutputFormat,\n\t\t\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate,\n\t\t\t\t\t\t\tAudioSampleLayout, ODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\n\t\t\t\t\tif (*OutBpp == 0 && PHYCLKD32PerState < 20000 / 32 && DSCEnable == true &&\n\t\t\t\t\t\t\tForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 13500,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = dm_output_type_dp2p0;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_uhbr13p5;\n\t\t\t\t}\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_uhbr20) &&\n\t\t\t\t\t\t*OutBpp == 0 && PHYCLKD32PerState >= 20000 / 32) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 20000,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output, OutputFormat,\n\t\t\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate,\n\t\t\t\t\t\t\tAudioSampleLayout, ODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\tif (*OutBpp == 0 && DSCEnable == true && ForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 20000,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = dm_output_type_dp2p0;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_uhbr20;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*OutBpp = 0;\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_hbr) &&\n\t\t\t\t\t\tPHYCLKPerState >= 270) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 2700,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output, OutputFormat,\n\t\t\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate,\n\t\t\t\t\t\t\tAudioSampleLayout, ODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\tif (*OutBpp == 0 && PHYCLKPerState < 540 && DSCEnable == true &&\n\t\t\t\t\t\t\tForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\tif (Output == dm_dp)\n\t\t\t\t\t\t\t*RequiresFEC = true;\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 2700,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = (Output == dm_dp) ? dm_output_type_dp : dm_output_type_edp;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_hbr;\n\t\t\t\t}\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_hbr2) &&\n\t\t\t\t\t\t*OutBpp == 0 && PHYCLKPerState >= 540) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 5400,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output, OutputFormat,\n\t\t\t\t\t\t\tDSCInputBitPerComponent, NumberOfDSCSlices, AudioSampleRate,\n\t\t\t\t\t\t\tAudioSampleLayout, ODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\n\t\t\t\t\tif (*OutBpp == 0 && PHYCLKPerState < 810 && DSCEnable == true &&\n\t\t\t\t\t\t\tForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\tif (Output == dm_dp)\n\t\t\t\t\t\t\t*RequiresFEC = true;\n\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 5400,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = (Output == dm_dp) ? dm_output_type_dp : dm_output_type_edp;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_hbr2;\n\t\t\t\t}\n\t\t\t\tif ((OutputLinkDPRate == dm_dp_rate_na || OutputLinkDPRate == dm_dp_rate_hbr3) && *OutBpp == 0 && PHYCLKPerState >= 810) {\n\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 8100,\n\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent, NumberOfDSCSlices,\n\t\t\t\t\t\t\tAudioSampleRate, AudioSampleLayout, ODMModeNoDSC, ODMModeDSC,\n\t\t\t\t\t\t\tRequiredSlots);\n\n\t\t\t\t\tif (*OutBpp == 0 && DSCEnable == true && ForcedOutputLinkBPP == 0) {\n\t\t\t\t\t\t*RequiresDSC = true;\n\t\t\t\t\t\tLinkDSCEnable = true;\n\t\t\t\t\t\tif (Output == dm_dp)\n\t\t\t\t\t\t\t*RequiresFEC = true;\n\n\t\t\t\t\t\t*OutBpp = dml32_TruncToValidBPP((1 - Downspreading / 100) * 8100,\n\t\t\t\t\t\t\t\tOutputLinkDPLanes, HTotal, HActive, PixelClockBackEnd,\n\t\t\t\t\t\t\t\tForcedOutputLinkBPP, LinkDSCEnable, Output,\n\t\t\t\t\t\t\t\tOutputFormat, DSCInputBitPerComponent,\n\t\t\t\t\t\t\t\tNumberOfDSCSlices, AudioSampleRate, AudioSampleLayout,\n\t\t\t\t\t\t\t\tODMModeNoDSC, ODMModeDSC, RequiredSlots);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t*OutputType = (Output == dm_dp) ? dm_output_type_dp : dm_output_type_edp;\n\t\t\t\t\t*OutputRate = dm_output_rate_dp_rate_hbr3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dml32_CalculateDPPCLK(\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,\n\t\tdouble DISPCLKDPPCLKVCOSpeed,\n\t\tdouble DPPCLKUsingSingleDPP[],\n\t\tunsigned int DPPPerSurface[],\n\n\t\t \n\t\tdouble *GlobalDPPCLK,\n\t\tdouble Dppclk[])\n{\n\tunsigned int k;\n\t*GlobalDPPCLK = 0;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tDppclk[k] = DPPCLKUsingSingleDPP[k] / DPPPerSurface[k] * (1 + DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t*GlobalDPPCLK = dml_max(*GlobalDPPCLK, Dppclk[k]);\n\t}\n\t*GlobalDPPCLK = dml32_RoundToDFSGranularity(*GlobalDPPCLK, 1, DISPCLKDPPCLKVCOSpeed);\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k)\n\t\tDppclk[k] = *GlobalDPPCLK / 255 * dml_ceil(Dppclk[k] * 255.0 / *GlobalDPPCLK, 1.0);\n}\n\ndouble dml32_TruncToValidBPP(\n\t\tdouble LinkBitRate,\n\t\tunsigned int Lanes,\n\t\tunsigned int HTotal,\n\t\tunsigned int HActive,\n\t\tdouble PixelClock,\n\t\tdouble DesiredBPP,\n\t\tbool DSCEnable,\n\t\tenum output_encoder_class Output,\n\t\tenum output_format_class Format,\n\t\tunsigned int DSCInputBitPerComponent,\n\t\tunsigned int DSCSlices,\n\t\tunsigned int AudioRate,\n\t\tunsigned int AudioLayout,\n\t\tenum odm_combine_mode ODMModeNoDSC,\n\t\tenum odm_combine_mode ODMModeDSC,\n\t\t \n\t\tunsigned int *RequiredSlots)\n{\n\tdouble    MaxLinkBPP;\n\tunsigned int   MinDSCBPP;\n\tdouble    MaxDSCBPP;\n\tunsigned int   NonDSCBPP0;\n\tunsigned int   NonDSCBPP1;\n\tunsigned int   NonDSCBPP2;\n\n\tif (Format == dm_420) {\n\t\tNonDSCBPP0 = 12;\n\t\tNonDSCBPP1 = 15;\n\t\tNonDSCBPP2 = 18;\n\t\tMinDSCBPP = 6;\n\t\tMaxDSCBPP = 1.5 * DSCInputBitPerComponent - 1 / 16;\n\t} else if (Format == dm_444) {\n\t\tNonDSCBPP0 = 24;\n\t\tNonDSCBPP1 = 30;\n\t\tNonDSCBPP2 = 36;\n\t\tMinDSCBPP = 8;\n\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16;\n\t} else {\n\t\tif (Output == dm_hdmi) {\n\t\t\tNonDSCBPP0 = 24;\n\t\t\tNonDSCBPP1 = 24;\n\t\t\tNonDSCBPP2 = 24;\n\t\t} else {\n\t\t\tNonDSCBPP0 = 16;\n\t\t\tNonDSCBPP1 = 20;\n\t\t\tNonDSCBPP2 = 24;\n\t\t}\n\t\tif (Format == dm_n422) {\n\t\t\tMinDSCBPP = 7;\n\t\t\tMaxDSCBPP = 2 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t} else {\n\t\t\tMinDSCBPP = 8;\n\t\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t}\n\t}\n\tif (Output == dm_dp2p0) {\n\t\tMaxLinkBPP = LinkBitRate * Lanes / PixelClock * 128 / 132 * 383 / 384 * 65536 / 65540;\n\t} else if (DSCEnable && Output == dm_dp) {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock * (1 - 2.4 / 100);\n\t} else {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock;\n\t}\n\n\tif (DSCEnable) {\n\t\tif (ODMModeDSC == dm_odm_combine_mode_4to1)\n\t\t\tMaxLinkBPP = dml_min(MaxLinkBPP, 16);\n\t\telse if (ODMModeDSC == dm_odm_combine_mode_2to1)\n\t\t\tMaxLinkBPP = dml_min(MaxLinkBPP, 32);\n\t\telse if (ODMModeDSC == dm_odm_split_mode_1to2)\n\t\t\tMaxLinkBPP = 2 * MaxLinkBPP;\n\t} else {\n\t\tif (ODMModeNoDSC == dm_odm_combine_mode_4to1)\n\t\t\tMaxLinkBPP = dml_min(MaxLinkBPP, 16);\n\t\telse if (ODMModeNoDSC == dm_odm_combine_mode_2to1)\n\t\t\tMaxLinkBPP = dml_min(MaxLinkBPP, 32);\n\t\telse if (ODMModeNoDSC == dm_odm_split_mode_1to2)\n\t\t\tMaxLinkBPP = 2 * MaxLinkBPP;\n\t}\n\n\tif (DesiredBPP == 0) {\n\t\tif (DSCEnable) {\n\t\t\tif (MaxLinkBPP < MinDSCBPP)\n\t\t\t\treturn BPP_INVALID;\n\t\t\telse if (MaxLinkBPP >= MaxDSCBPP)\n\t\t\t\treturn MaxDSCBPP;\n\t\t\telse\n\t\t\t\treturn dml_floor(16.0 * MaxLinkBPP, 1.0) / 16.0;\n\t\t} else {\n\t\t\tif (MaxLinkBPP >= NonDSCBPP2)\n\t\t\t\treturn NonDSCBPP2;\n\t\t\telse if (MaxLinkBPP >= NonDSCBPP1)\n\t\t\t\treturn NonDSCBPP1;\n\t\t\telse if (MaxLinkBPP >= NonDSCBPP0)\n\t\t\t\treturn 16.0;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t}\n\t} else {\n\t\tif (!((DSCEnable == false && (DesiredBPP == NonDSCBPP2 || DesiredBPP == NonDSCBPP1 ||\n\t\t\t\tDesiredBPP <= NonDSCBPP0)) ||\n\t\t\t\t(DSCEnable && DesiredBPP >= MinDSCBPP && DesiredBPP <= MaxDSCBPP)))\n\t\t\treturn BPP_INVALID;\n\t\telse\n\t\t\treturn DesiredBPP;\n\t}\n\n\t*RequiredSlots = dml_ceil(DesiredBPP / MaxLinkBPP * 64, 1);\n\n\treturn BPP_INVALID;\n} \n\ndouble dml32_RequiredDTBCLK(\n\t\tbool              DSCEnable,\n\t\tdouble               PixelClock,\n\t\tenum output_format_class  OutputFormat,\n\t\tdouble               OutputBpp,\n\t\tunsigned int              DSCSlices,\n\t\tunsigned int                 HTotal,\n\t\tunsigned int                 HActive,\n\t\tunsigned int              AudioRate,\n\t\tunsigned int              AudioLayout)\n{\n\tdouble PixelWordRate;\n\tdouble HCActive;\n\tdouble HCBlank;\n\tdouble AverageTribyteRate;\n\tdouble HActiveTribyteRate;\n\n\tif (DSCEnable != true)\n\t\treturn dml_max(PixelClock / 4.0 * OutputBpp / 24.0, 25.0);\n\n\tPixelWordRate = PixelClock /  (OutputFormat == dm_444 ? 1 : 2);\n\tHCActive = dml_ceil(DSCSlices * dml_ceil(OutputBpp *\n\t\t\tdml_ceil(HActive / DSCSlices, 1) / 8.0, 1) / 3.0, 1);\n\tHCBlank = 64 + 32 *\n\t\t\tdml_ceil(AudioRate *  (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock * 1000), 1);\n\tAverageTribyteRate = PixelWordRate * (HCActive + HCBlank) / HTotal;\n\tHActiveTribyteRate = PixelWordRate * HCActive / HActive;\n\treturn dml_max4(PixelWordRate / 4.0, AverageTribyteRate / 4.0, HActiveTribyteRate / 4.0, 25.0) * 1.002;\n}\n\nunsigned int dml32_DSCDelayRequirement(bool DSCEnabled,\n\t\tenum odm_combine_mode ODMMode,\n\t\tunsigned int DSCInputBitPerComponent,\n\t\tdouble OutputBpp,\n\t\tunsigned int HActive,\n\t\tunsigned int HTotal,\n\t\tunsigned int NumberOfDSCSlices,\n\t\tenum output_format_class  OutputFormat,\n\t\tenum output_encoder_class Output,\n\t\tdouble PixelClock,\n\t\tdouble PixelClockBackEnd,\n\t\tdouble dsc_delay_factor_wa)\n{\n\tunsigned int DSCDelayRequirement_val;\n\n\tif (DSCEnabled == true && OutputBpp != 0) {\n\t\tif (ODMMode == dm_odm_combine_mode_4to1) {\n\t\t\tDSCDelayRequirement_val = 4 * (dml32_dscceComputeDelay(DSCInputBitPerComponent, OutputBpp,\n\t\t\t\t\tdml_ceil(HActive / NumberOfDSCSlices, 1), NumberOfDSCSlices / 4,\n\t\t\t\t\tOutputFormat, Output) + dml32_dscComputeDelay(OutputFormat, Output));\n\t\t} else if (ODMMode == dm_odm_combine_mode_2to1) {\n\t\t\tDSCDelayRequirement_val = 2 * (dml32_dscceComputeDelay(DSCInputBitPerComponent, OutputBpp,\n\t\t\t\t\tdml_ceil(HActive / NumberOfDSCSlices, 1), NumberOfDSCSlices / 2,\n\t\t\t\t\tOutputFormat, Output) + dml32_dscComputeDelay(OutputFormat, Output));\n\t\t} else {\n\t\t\tDSCDelayRequirement_val = dml32_dscceComputeDelay(DSCInputBitPerComponent, OutputBpp,\n\t\t\t\t\tdml_ceil(HActive / NumberOfDSCSlices, 1), NumberOfDSCSlices,\n\t\t\t\t\tOutputFormat, Output) + dml32_dscComputeDelay(OutputFormat, Output);\n\t\t}\n\n\t\tDSCDelayRequirement_val = DSCDelayRequirement_val + (HTotal - HActive) *\n\t\t\t\tdml_ceil((double)DSCDelayRequirement_val / HActive, 1);\n\n\t\tDSCDelayRequirement_val = DSCDelayRequirement_val * PixelClock / PixelClockBackEnd;\n\n\t} else {\n\t\tDSCDelayRequirement_val = 0;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DSCEnabled              = %d\\n\", __func__, DSCEnabled);\n\tdml_print(\"DML::%s: OutputBpp               = %f\\n\", __func__, OutputBpp);\n\tdml_print(\"DML::%s: HActive                 = %d\\n\", __func__, HActive);\n\tdml_print(\"DML::%s: OutputFormat            = %d\\n\", __func__, OutputFormat);\n\tdml_print(\"DML::%s: DSCInputBitPerComponent = %d\\n\", __func__, DSCInputBitPerComponent);\n\tdml_print(\"DML::%s: NumberOfDSCSlices       = %d\\n\", __func__, NumberOfDSCSlices);\n\tdml_print(\"DML::%s: DSCDelayRequirement_val = %d\\n\", __func__, DSCDelayRequirement_val);\n#endif\n\n\treturn dml_ceil(DSCDelayRequirement_val * dsc_delay_factor_wa, 1);\n}\n\nvoid dml32_CalculateSurfaceSizeInMall(\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int MALLAllocatedForDCN,\n\t\tenum dm_use_mall_for_static_screen_mode UseMALLForStaticScreen[],\n\t\tenum dm_use_mall_for_pstate_change_mode UsesMALLForPStateChange[],\n\t\tbool DCCEnable[],\n\t\tbool ViewportStationary[],\n\t\tunsigned int ViewportXStartY[],\n\t\tunsigned int ViewportYStartY[],\n\t\tunsigned int ViewportXStartC[],\n\t\tunsigned int ViewportYStartC[],\n\t\tunsigned int ViewportWidthY[],\n\t\tunsigned int ViewportHeightY[],\n\t\tunsigned int BytesPerPixelY[],\n\t\tunsigned int ViewportWidthC[],\n\t\tunsigned int ViewportHeightC[],\n\t\tunsigned int BytesPerPixelC[],\n\t\tunsigned int SurfaceWidthY[],\n\t\tunsigned int SurfaceWidthC[],\n\t\tunsigned int SurfaceHeightY[],\n\t\tunsigned int SurfaceHeightC[],\n\t\tunsigned int Read256BytesBlockWidthY[],\n\t\tunsigned int Read256BytesBlockWidthC[],\n\t\tunsigned int Read256BytesBlockHeightY[],\n\t\tunsigned int Read256BytesBlockHeightC[],\n\t\tunsigned int ReadBlockWidthY[],\n\t\tunsigned int ReadBlockWidthC[],\n\t\tunsigned int ReadBlockHeightY[],\n\t\tunsigned int ReadBlockHeightC[],\n\t\tunsigned int DCCMetaPitchY[],\n\t\tunsigned int DCCMetaPitchC[],\n\n\t\t \n\t\tunsigned int    SurfaceSizeInMALL[],\n\t\tbool *ExceededMALLSize)\n{\n\tunsigned int k;\n\tunsigned int TotalSurfaceSizeInMALLForSS = 0;\n\tunsigned int TotalSurfaceSizeInMALLForSubVP = 0;\n\tunsigned int MALLAllocatedForDCNInBytes = MALLAllocatedForDCN * 1024 * 1024;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (ViewportStationary[k]) {\n\t\t\tSurfaceSizeInMALL[k] = dml_min(dml_ceil(SurfaceWidthY[k], ReadBlockWidthY[k]),\n\t\t\t\t\tdml_floor(ViewportXStartY[k] + ViewportWidthY[k] + ReadBlockWidthY[k] - 1,\n\t\t\t\t\t\tReadBlockWidthY[k]) - dml_floor(ViewportXStartY[k],\n\t\t\t\t\t\tReadBlockWidthY[k])) * dml_min(dml_ceil(SurfaceHeightY[k],\n\t\t\t\t\t\tReadBlockHeightY[k]), dml_floor(ViewportYStartY[k] +\n\t\t\t\t\t\tViewportHeightY[k] + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -\n\t\t\t\t\t\tdml_floor(ViewportYStartY[k], ReadBlockHeightY[k])) * BytesPerPixelY[k];\n\n\t\t\tif (ReadBlockWidthC[k] > 0) {\n\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\tdml_min(dml_ceil(SurfaceWidthC[k], ReadBlockWidthC[k]),\n\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k] + ViewportWidthC[k] +\n\t\t\t\t\t\t\tReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -\n\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k], ReadBlockWidthC[k])) *\n\t\t\t\t\t\t\tdml_min(dml_ceil(SurfaceHeightC[k], ReadBlockHeightC[k]),\n\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k] + ViewportHeightC[k] +\n\t\t\t\t\t\t\tReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -\n\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k], ReadBlockHeightC[k])) *\n\t\t\t\t\t\t\tBytesPerPixelC[k];\n\t\t\t}\n\t\t\tif (DCCEnable[k] == true) {\n\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\t(dml_min(dml_ceil(DCCMetaPitchY[k], 8 * Read256BytesBlockWidthY[k]),\n\t\t\t\t\t\t\tdml_floor(ViewportXStartY[k] + ViewportWidthY[k] + 8 *\n\t\t\t\t\t\t\tRead256BytesBlockWidthY[k] - 1, 8 * Read256BytesBlockWidthY[k])\n\t\t\t\t\t\t\t- dml_floor(ViewportXStartY[k], 8 * Read256BytesBlockWidthY[k]))\n\t\t\t\t\t\t\t* dml_min(dml_ceil(SurfaceHeightY[k], 8 *\n\t\t\t\t\t\t\tRead256BytesBlockHeightY[k]), dml_floor(ViewportYStartY[k] +\n\t\t\t\t\t\t\tViewportHeightY[k] + 8 * Read256BytesBlockHeightY[k] - 1, 8 *\n\t\t\t\t\t\t\tRead256BytesBlockHeightY[k]) - dml_floor(ViewportYStartY[k], 8 *\n\t\t\t\t\t\t\tRead256BytesBlockHeightY[k])) * BytesPerPixelY[k] / 256) + (64 * 1024);\n\t\t\t\tif (Read256BytesBlockWidthC[k] > 0) {\n\t\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\t\tdml_min(dml_ceil(DCCMetaPitchC[k], 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]),\n\t\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k] + ViewportWidthC[k] + 8\n\t\t\t\t\t\t\t\t* Read256BytesBlockWidthC[k] - 1, 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]) -\n\t\t\t\t\t\t\t\tdml_floor(ViewportXStartC[k], 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k])) *\n\t\t\t\t\t\t\t\tdml_min(dml_ceil(SurfaceHeightC[k], 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]),\n\t\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k] + ViewportHeightC[k] +\n\t\t\t\t\t\t\t\t8 * Read256BytesBlockHeightC[k] - 1, 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]) -\n\t\t\t\t\t\t\t\tdml_floor(ViewportYStartC[k], 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k])) *\n\t\t\t\t\t\t\t\tBytesPerPixelC[k] / 256;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSurfaceSizeInMALL[k] = dml_ceil(dml_min(SurfaceWidthY[k], ViewportWidthY[k] +\n\t\t\t\t\tReadBlockWidthY[k] - 1), ReadBlockWidthY[k]) *\n\t\t\t\t\tdml_ceil(dml_min(SurfaceHeightY[k], ViewportHeightY[k] +\n\t\t\t\t\t\t\tReadBlockHeightY[k] - 1), ReadBlockHeightY[k]) *\n\t\t\t\t\t\t\tBytesPerPixelY[k];\n\t\t\tif (ReadBlockWidthC[k] > 0) {\n\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\tdml_ceil(dml_min(SurfaceWidthC[k], ViewportWidthC[k] +\n\t\t\t\t\t\t\t\tReadBlockWidthC[k] - 1), ReadBlockWidthC[k]) *\n\t\t\t\t\t\tdml_ceil(dml_min(SurfaceHeightC[k], ViewportHeightC[k] +\n\t\t\t\t\t\t\t\tReadBlockHeightC[k] - 1), ReadBlockHeightC[k]) *\n\t\t\t\t\t\t\t\tBytesPerPixelC[k];\n\t\t\t}\n\t\t\tif (DCCEnable[k] == true) {\n\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\t(dml_ceil(dml_min(DCCMetaPitchY[k], ViewportWidthY[k] + 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k] - 1), 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockWidthY[k]) *\n\t\t\t\t\t\tdml_ceil(dml_min(SurfaceHeightY[k], ViewportHeightY[k] + 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockHeightY[k] - 1), 8 *\n\t\t\t\t\t\t\t\tRead256BytesBlockHeightY[k]) * BytesPerPixelY[k] / 256) + (64 * 1024);\n\n\t\t\t\tif (Read256BytesBlockWidthC[k] > 0) {\n\t\t\t\t\tSurfaceSizeInMALL[k] = SurfaceSizeInMALL[k] +\n\t\t\t\t\t\t\tdml_ceil(dml_min(DCCMetaPitchC[k], ViewportWidthC[k] + 8 *\n\t\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k] - 1), 8 *\n\t\t\t\t\t\t\t\t\tRead256BytesBlockWidthC[k]) *\n\t\t\t\t\t\t\tdml_ceil(dml_min(SurfaceHeightC[k], ViewportHeightC[k] + 8 *\n\t\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k] - 1), 8 *\n\t\t\t\t\t\t\t\t\tRead256BytesBlockHeightC[k]) *\n\t\t\t\t\t\t\t\t\tBytesPerPixelC[k] / 256;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t \n\t\tif (UsesMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe)\n\t\t\tTotalSurfaceSizeInMALLForSubVP = TotalSurfaceSizeInMALLForSubVP + SurfaceSizeInMALL[k];\n\t\telse if (UseMALLForStaticScreen[k] == dm_use_mall_static_screen_enable)\n\t\t\tTotalSurfaceSizeInMALLForSS = TotalSurfaceSizeInMALLForSS + SurfaceSizeInMALL[k];\n\t}\n\t*ExceededMALLSize =  (TotalSurfaceSizeInMALLForSS > MALLAllocatedForDCNInBytes) ||\n\t\t\t\t\t\t\t(TotalSurfaceSizeInMALLForSubVP > MALLAllocatedForDCNInBytes);\n} \n\nvoid dml32_CalculateVMRowAndSwath(\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tDmlPipe myPipe[],\n\t\tunsigned int SurfaceSizeInMALL[],\n\t\tunsigned int PTEBufferSizeInRequestsLuma,\n\t\tunsigned int PTEBufferSizeInRequestsChroma,\n\t\tunsigned int DCCMetaBufferSizeBytes,\n\t\tenum dm_use_mall_for_static_screen_mode UseMALLForStaticScreen[],\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],\n\t\tunsigned int MALLAllocatedForDCN,\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int GPUVMMinPageSizeKBytes[],\n\t\tunsigned int HostVMMinPageSize,\n\n\t\t \n\t\tbool PTEBufferSizeNotExceeded[],\n\t\tbool DCCMetaBufferSizeNotExceeded[],\n\t\tunsigned int dpte_row_width_luma_ub[],\n\t\tunsigned int dpte_row_width_chroma_ub[],\n\t\tunsigned int dpte_row_height_luma[],\n\t\tunsigned int dpte_row_height_chroma[],\n\t\tunsigned int dpte_row_height_linear_luma[],     \n\t\tunsigned int dpte_row_height_linear_chroma[],   \n\t\tunsigned int meta_req_width[],\n\t\tunsigned int meta_req_width_chroma[],\n\t\tunsigned int meta_req_height[],\n\t\tunsigned int meta_req_height_chroma[],\n\t\tunsigned int meta_row_width[],\n\t\tunsigned int meta_row_width_chroma[],\n\t\tunsigned int meta_row_height[],\n\t\tunsigned int meta_row_height_chroma[],\n\t\tunsigned int vm_group_bytes[],\n\t\tunsigned int dpte_group_bytes[],\n\t\tunsigned int PixelPTEReqWidthY[],\n\t\tunsigned int PixelPTEReqHeightY[],\n\t\tunsigned int PTERequestSizeY[],\n\t\tunsigned int PixelPTEReqWidthC[],\n\t\tunsigned int PixelPTEReqHeightC[],\n\t\tunsigned int PTERequestSizeC[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int meta_pte_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tunsigned int meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble PrefetchSourceLinesY[],\n\t\tdouble PrefetchSourceLinesC[],\n\t\tdouble VInitPreFillY[],\n\t\tdouble VInitPreFillC[],\n\t\tunsigned int MaxNumSwathY[],\n\t\tunsigned int MaxNumSwathC[],\n\t\tdouble meta_row_bw[],\n\t\tdouble dpte_row_bw[],\n\t\tdouble PixelPTEBytesPerRow[],\n\t\tdouble PDEAndMetaPTEBytesFrame[],\n\t\tdouble MetaRowByte[],\n\t\tbool use_one_row_for_frame[],\n\t\tbool use_one_row_for_frame_flip[],\n\t\tbool UsesMALLForStaticScreen[],\n\t\tbool PTE_BUFFER_MODE[],\n\t\tunsigned int BIGK_FRAGMENT_SIZE[])\n{\n\tunsigned int k;\n\tunsigned int PTEBufferSizeInRequestsForLuma[DC__NUM_DPP__MAX];\n\tunsigned int PTEBufferSizeInRequestsForChroma[DC__NUM_DPP__MAX];\n\tunsigned int PDEAndMetaPTEBytesFrameY;\n\tunsigned int PDEAndMetaPTEBytesFrameC;\n\tunsigned int MetaRowByteY[DC__NUM_DPP__MAX];\n\tunsigned int MetaRowByteC[DC__NUM_DPP__MAX];\n\tunsigned int PixelPTEBytesPerRowY[DC__NUM_DPP__MAX];\n\tunsigned int PixelPTEBytesPerRowC[DC__NUM_DPP__MAX];\n\tunsigned int PixelPTEBytesPerRowY_one_row_per_frame[DC__NUM_DPP__MAX];\n\tunsigned int PixelPTEBytesPerRowC_one_row_per_frame[DC__NUM_DPP__MAX];\n\tunsigned int dpte_row_width_luma_ub_one_row_per_frame[DC__NUM_DPP__MAX];\n\tunsigned int dpte_row_height_luma_one_row_per_frame[DC__NUM_DPP__MAX];\n\tunsigned int dpte_row_width_chroma_ub_one_row_per_frame[DC__NUM_DPP__MAX];\n\tunsigned int dpte_row_height_chroma_one_row_per_frame[DC__NUM_DPP__MAX];\n\tbool one_row_per_frame_fits_in_buffer[DC__NUM_DPP__MAX];\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (HostVMEnable == true) {\n\t\t\tvm_group_bytes[k] = 512;\n\t\t\tdpte_group_bytes[k] = 512;\n\t\t} else if (GPUVMEnable == true) {\n\t\t\tvm_group_bytes[k] = 2048;\n\t\t\tif (GPUVMMinPageSizeKBytes[k] >= 64 && IsVertical(myPipe[k].SourceRotation))\n\t\t\t\tdpte_group_bytes[k] = 512;\n\t\t\telse\n\t\t\t\tdpte_group_bytes[k] = 2048;\n\t\t} else {\n\t\t\tvm_group_bytes[k] = 0;\n\t\t\tdpte_group_bytes[k] = 0;\n\t\t}\n\n\t\tif (myPipe[k].SourcePixelFormat == dm_420_8 || myPipe[k].SourcePixelFormat == dm_420_10 ||\n\t\t\t\tmyPipe[k].SourcePixelFormat == dm_420_12 ||\n\t\t\t\tmyPipe[k].SourcePixelFormat == dm_rgbe_alpha) {\n\t\t\tif ((myPipe[k].SourcePixelFormat == dm_420_10 || myPipe[k].SourcePixelFormat == dm_420_12) &&\n\t\t\t\t\t!IsVertical(myPipe[k].SourceRotation)) {\n\t\t\t\tPTEBufferSizeInRequestsForLuma[k] =\n\t\t\t\t\t\t(PTEBufferSizeInRequestsLuma + PTEBufferSizeInRequestsChroma) / 2;\n\t\t\t\tPTEBufferSizeInRequestsForChroma[k] = PTEBufferSizeInRequestsForLuma[k];\n\t\t\t} else {\n\t\t\t\tPTEBufferSizeInRequestsForLuma[k] = PTEBufferSizeInRequestsLuma;\n\t\t\t\tPTEBufferSizeInRequestsForChroma[k] = PTEBufferSizeInRequestsChroma;\n\t\t\t}\n\n\t\t\tPDEAndMetaPTEBytesFrameC = dml32_CalculateVMAndRowBytes(\n\t\t\t\t\tmyPipe[k].ViewportStationary,\n\t\t\t\t\tmyPipe[k].DCCEnable,\n\t\t\t\t\tmyPipe[k].DPPPerSurface,\n\t\t\t\t\tmyPipe[k].BlockHeight256BytesC,\n\t\t\t\t\tmyPipe[k].BlockWidth256BytesC,\n\t\t\t\t\tmyPipe[k].SourcePixelFormat,\n\t\t\t\t\tmyPipe[k].SurfaceTiling,\n\t\t\t\t\tmyPipe[k].BytePerPixelC,\n\t\t\t\t\tmyPipe[k].SourceRotation,\n\t\t\t\t\tSwathWidthC[k],\n\t\t\t\t\tmyPipe[k].ViewportHeightChroma,\n\t\t\t\t\tmyPipe[k].ViewportXStartC,\n\t\t\t\t\tmyPipe[k].ViewportYStartC,\n\t\t\t\t\tGPUVMEnable,\n\t\t\t\t\tHostVMEnable,\n\t\t\t\t\tHostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\tGPUVMMaxPageTableLevels,\n\t\t\t\t\tGPUVMMinPageSizeKBytes[k],\n\t\t\t\t\tHostVMMinPageSize,\n\t\t\t\t\tPTEBufferSizeInRequestsForChroma[k],\n\t\t\t\t\tmyPipe[k].PitchC,\n\t\t\t\t\tmyPipe[k].DCCMetaPitchC,\n\t\t\t\t\tmyPipe[k].BlockWidthC,\n\t\t\t\t\tmyPipe[k].BlockHeightC,\n\n\t\t\t\t\t \n\t\t\t\t\t&MetaRowByteC[k],\n\t\t\t\t\t&PixelPTEBytesPerRowC[k],\n\t\t\t\t\t&dpte_row_width_chroma_ub[k],\n\t\t\t\t\t&dpte_row_height_chroma[k],\n\t\t\t\t\t&dpte_row_height_linear_chroma[k],\n\t\t\t\t\t&PixelPTEBytesPerRowC_one_row_per_frame[k],\n\t\t\t\t\t&dpte_row_width_chroma_ub_one_row_per_frame[k],\n\t\t\t\t\t&dpte_row_height_chroma_one_row_per_frame[k],\n\t\t\t\t\t&meta_req_width_chroma[k],\n\t\t\t\t\t&meta_req_height_chroma[k],\n\t\t\t\t\t&meta_row_width_chroma[k],\n\t\t\t\t\t&meta_row_height_chroma[k],\n\t\t\t\t\t&PixelPTEReqWidthC[k],\n\t\t\t\t\t&PixelPTEReqHeightC[k],\n\t\t\t\t\t&PTERequestSizeC[k],\n\t\t\t\t\t&dpde0_bytes_per_frame_ub_c[k],\n\t\t\t\t\t&meta_pte_bytes_per_frame_ub_c[k]);\n\n\t\t\tPrefetchSourceLinesC[k] = dml32_CalculatePrefetchSourceLines(\n\t\t\t\t\tmyPipe[k].VRatioChroma,\n\t\t\t\t\tmyPipe[k].VTapsChroma,\n\t\t\t\t\tmyPipe[k].InterlaceEnable,\n\t\t\t\t\tmyPipe[k].ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\tmyPipe[k].SwathHeightC,\n\t\t\t\t\tmyPipe[k].SourceRotation,\n\t\t\t\t\tmyPipe[k].ViewportStationary,\n\t\t\t\t\tSwathWidthC[k],\n\t\t\t\t\tmyPipe[k].ViewportHeightChroma,\n\t\t\t\t\tmyPipe[k].ViewportXStartC,\n\t\t\t\t\tmyPipe[k].ViewportYStartC,\n\n\t\t\t\t\t \n\t\t\t\t\t&VInitPreFillC[k],\n\t\t\t\t\t&MaxNumSwathC[k]);\n\t\t} else {\n\t\t\tPTEBufferSizeInRequestsForLuma[k] = PTEBufferSizeInRequestsLuma + PTEBufferSizeInRequestsChroma;\n\t\t\tPTEBufferSizeInRequestsForChroma[k] = 0;\n\t\t\tPixelPTEBytesPerRowC[k] = 0;\n\t\t\tPDEAndMetaPTEBytesFrameC = 0;\n\t\t\tMetaRowByteC[k] = 0;\n\t\t\tMaxNumSwathC[k] = 0;\n\t\t\tPrefetchSourceLinesC[k] = 0;\n\t\t\tdpte_row_height_chroma_one_row_per_frame[k] = 0;\n\t\t\tdpte_row_width_chroma_ub_one_row_per_frame[k] = 0;\n\t\t\tPixelPTEBytesPerRowC_one_row_per_frame[k] = 0;\n\t\t}\n\n\t\tPDEAndMetaPTEBytesFrameY = dml32_CalculateVMAndRowBytes(\n\t\t\t\tmyPipe[k].ViewportStationary,\n\t\t\t\tmyPipe[k].DCCEnable,\n\t\t\t\tmyPipe[k].DPPPerSurface,\n\t\t\t\tmyPipe[k].BlockHeight256BytesY,\n\t\t\t\tmyPipe[k].BlockWidth256BytesY,\n\t\t\t\tmyPipe[k].SourcePixelFormat,\n\t\t\t\tmyPipe[k].SurfaceTiling,\n\t\t\t\tmyPipe[k].BytePerPixelY,\n\t\t\t\tmyPipe[k].SourceRotation,\n\t\t\t\tSwathWidthY[k],\n\t\t\t\tmyPipe[k].ViewportHeight,\n\t\t\t\tmyPipe[k].ViewportXStart,\n\t\t\t\tmyPipe[k].ViewportYStart,\n\t\t\t\tGPUVMEnable,\n\t\t\t\tHostVMEnable,\n\t\t\t\tHostVMMaxNonCachedPageTableLevels,\n\t\t\t\tGPUVMMaxPageTableLevels,\n\t\t\t\tGPUVMMinPageSizeKBytes[k],\n\t\t\t\tHostVMMinPageSize,\n\t\t\t\tPTEBufferSizeInRequestsForLuma[k],\n\t\t\t\tmyPipe[k].PitchY,\n\t\t\t\tmyPipe[k].DCCMetaPitchY,\n\t\t\t\tmyPipe[k].BlockWidthY,\n\t\t\t\tmyPipe[k].BlockHeightY,\n\n\t\t\t\t \n\t\t\t\t&MetaRowByteY[k],\n\t\t\t\t&PixelPTEBytesPerRowY[k],\n\t\t\t\t&dpte_row_width_luma_ub[k],\n\t\t\t\t&dpte_row_height_luma[k],\n\t\t\t\t&dpte_row_height_linear_luma[k],\n\t\t\t\t&PixelPTEBytesPerRowY_one_row_per_frame[k],\n\t\t\t\t&dpte_row_width_luma_ub_one_row_per_frame[k],\n\t\t\t\t&dpte_row_height_luma_one_row_per_frame[k],\n\t\t\t\t&meta_req_width[k],\n\t\t\t\t&meta_req_height[k],\n\t\t\t\t&meta_row_width[k],\n\t\t\t\t&meta_row_height[k],\n\t\t\t\t&PixelPTEReqWidthY[k],\n\t\t\t\t&PixelPTEReqHeightY[k],\n\t\t\t\t&PTERequestSizeY[k],\n\t\t\t\t&dpde0_bytes_per_frame_ub_l[k],\n\t\t\t\t&meta_pte_bytes_per_frame_ub_l[k]);\n\n\t\tPrefetchSourceLinesY[k] = dml32_CalculatePrefetchSourceLines(\n\t\t\t\tmyPipe[k].VRatio,\n\t\t\t\tmyPipe[k].VTaps,\n\t\t\t\tmyPipe[k].InterlaceEnable,\n\t\t\t\tmyPipe[k].ProgressiveToInterlaceUnitInOPP,\n\t\t\t\tmyPipe[k].SwathHeightY,\n\t\t\t\tmyPipe[k].SourceRotation,\n\t\t\t\tmyPipe[k].ViewportStationary,\n\t\t\t\tSwathWidthY[k],\n\t\t\t\tmyPipe[k].ViewportHeight,\n\t\t\t\tmyPipe[k].ViewportXStart,\n\t\t\t\tmyPipe[k].ViewportYStart,\n\n\t\t\t\t \n\t\t\t\t&VInitPreFillY[k],\n\t\t\t\t&MaxNumSwathY[k]);\n\n\t\tPDEAndMetaPTEBytesFrame[k] = PDEAndMetaPTEBytesFrameY + PDEAndMetaPTEBytesFrameC;\n\t\tMetaRowByte[k] = MetaRowByteY[k] + MetaRowByteC[k];\n\n\t\tif (PixelPTEBytesPerRowY[k] <= 64 * PTEBufferSizeInRequestsForLuma[k] &&\n\t\t\t\tPixelPTEBytesPerRowC[k] <= 64 * PTEBufferSizeInRequestsForChroma[k]) {\n\t\t\tPTEBufferSizeNotExceeded[k] = true;\n\t\t} else {\n\t\t\tPTEBufferSizeNotExceeded[k] = false;\n\t\t}\n\n\t\tone_row_per_frame_fits_in_buffer[k] = (PixelPTEBytesPerRowY_one_row_per_frame[k] <= 64 * 2 *\n\t\t\tPTEBufferSizeInRequestsForLuma[k] &&\n\t\t\tPixelPTEBytesPerRowC_one_row_per_frame[k] <= 64 * 2 * PTEBufferSizeInRequestsForChroma[k]);\n\t}\n\n\tdml32_CalculateMALLUseForStaticScreen(\n\t\t\tNumberOfActiveSurfaces,\n\t\t\tMALLAllocatedForDCN,\n\t\t\tUseMALLForStaticScreen,   \n\t\t\tSurfaceSizeInMALL,\n\t\t\tone_row_per_frame_fits_in_buffer,\n\t\t\t \n\t\t\tUsesMALLForStaticScreen); \n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tPTE_BUFFER_MODE[k] = myPipe[k].FORCE_ONE_ROW_FOR_FRAME || UsesMALLForStaticScreen[k] ||\n\t\t\t\t(UseMALLForPStateChange[k] == dm_use_mall_pstate_change_sub_viewport) ||\n\t\t\t\t(UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) ||\n\t\t\t\t(GPUVMMinPageSizeKBytes[k] > 64);\n\t\tBIGK_FRAGMENT_SIZE[k] = dml_log2(GPUVMMinPageSizeKBytes[k] * 1024) - 12;\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, SurfaceSizeInMALL = %d\\n\",  __func__, k, SurfaceSizeInMALL[k]);\n\t\tdml_print(\"DML::%s: k=%d, UsesMALLForStaticScreen = %d\\n\",  __func__, k, UsesMALLForStaticScreen[k]);\n#endif\n\t\tuse_one_row_for_frame[k] = myPipe[k].FORCE_ONE_ROW_FOR_FRAME || UsesMALLForStaticScreen[k] ||\n\t\t\t\t(UseMALLForPStateChange[k] == dm_use_mall_pstate_change_sub_viewport) ||\n\t\t\t\t(UseMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) ||\n\t\t\t\t(GPUVMMinPageSizeKBytes[k] > 64 && IsVertical(myPipe[k].SourceRotation));\n\n\t\tuse_one_row_for_frame_flip[k] = use_one_row_for_frame[k] &&\n\t\t\t\t!(UseMALLForPStateChange[k] == dm_use_mall_pstate_change_full_frame);\n\n\t\tif (use_one_row_for_frame[k]) {\n\t\t\tdpte_row_height_luma[k] = dpte_row_height_luma_one_row_per_frame[k];\n\t\t\tdpte_row_width_luma_ub[k] = dpte_row_width_luma_ub_one_row_per_frame[k];\n\t\t\tPixelPTEBytesPerRowY[k] = PixelPTEBytesPerRowY_one_row_per_frame[k];\n\t\t\tdpte_row_height_chroma[k] = dpte_row_height_chroma_one_row_per_frame[k];\n\t\t\tdpte_row_width_chroma_ub[k] = dpte_row_width_chroma_ub_one_row_per_frame[k];\n\t\t\tPixelPTEBytesPerRowC[k] = PixelPTEBytesPerRowC_one_row_per_frame[k];\n\t\t\tPTEBufferSizeNotExceeded[k] = one_row_per_frame_fits_in_buffer[k];\n\t\t}\n\n\t\tif (MetaRowByte[k] <= DCCMetaBufferSizeBytes)\n\t\t\tDCCMetaBufferSizeNotExceeded[k] = true;\n\t\telse\n\t\t\tDCCMetaBufferSizeNotExceeded[k] = false;\n\n\t\tPixelPTEBytesPerRow[k] = PixelPTEBytesPerRowY[k] + PixelPTEBytesPerRowC[k];\n\t\tif (use_one_row_for_frame[k])\n\t\t\tPixelPTEBytesPerRow[k] = PixelPTEBytesPerRow[k] / 2;\n\n\t\tdml32_CalculateRowBandwidth(\n\t\t\t\tGPUVMEnable,\n\t\t\t\tmyPipe[k].SourcePixelFormat,\n\t\t\t\tmyPipe[k].VRatio,\n\t\t\t\tmyPipe[k].VRatioChroma,\n\t\t\t\tmyPipe[k].DCCEnable,\n\t\t\t\tmyPipe[k].HTotal / myPipe[k].PixelClock,\n\t\t\t\tMetaRowByteY[k], MetaRowByteC[k],\n\t\t\t\tmeta_row_height[k],\n\t\t\t\tmeta_row_height_chroma[k],\n\t\t\t\tPixelPTEBytesPerRowY[k],\n\t\t\t\tPixelPTEBytesPerRowC[k],\n\t\t\t\tdpte_row_height_luma[k],\n\t\t\t\tdpte_row_height_chroma[k],\n\n\t\t\t\t \n\t\t\t\t&meta_row_bw[k],\n\t\t\t\t&dpte_row_bw[k]);\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, use_one_row_for_frame        = %d\\n\",  __func__, k, use_one_row_for_frame[k]);\n\t\tdml_print(\"DML::%s: k=%d, use_one_row_for_frame_flip   = %d\\n\",\n\t\t\t\t__func__, k, use_one_row_for_frame_flip[k]);\n\t\tdml_print(\"DML::%s: k=%d, UseMALLForPStateChange       = %d\\n\",\n\t\t\t\t__func__, k, UseMALLForPStateChange[k]);\n\t\tdml_print(\"DML::%s: k=%d, dpte_row_height_luma         = %d\\n\",  __func__, k, dpte_row_height_luma[k]);\n\t\tdml_print(\"DML::%s: k=%d, dpte_row_width_luma_ub       = %d\\n\",\n\t\t\t\t__func__, k, dpte_row_width_luma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d, PixelPTEBytesPerRowY         = %d\\n\",  __func__, k, PixelPTEBytesPerRowY[k]);\n\t\tdml_print(\"DML::%s: k=%d, dpte_row_height_chroma       = %d\\n\",\n\t\t\t\t__func__, k, dpte_row_height_chroma[k]);\n\t\tdml_print(\"DML::%s: k=%d, dpte_row_width_chroma_ub     = %d\\n\",\n\t\t\t\t__func__, k, dpte_row_width_chroma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d, PixelPTEBytesPerRowC         = %d\\n\",  __func__, k, PixelPTEBytesPerRowC[k]);\n\t\tdml_print(\"DML::%s: k=%d, PixelPTEBytesPerRow          = %d\\n\",  __func__, k, PixelPTEBytesPerRow[k]);\n\t\tdml_print(\"DML::%s: k=%d, PTEBufferSizeNotExceeded     = %d\\n\",\n\t\t\t\t__func__, k, PTEBufferSizeNotExceeded[k]);\n\t\tdml_print(\"DML::%s: k=%d, PTE_BUFFER_MODE              = %d\\n\", __func__, k, PTE_BUFFER_MODE[k]);\n\t\tdml_print(\"DML::%s: k=%d, BIGK_FRAGMENT_SIZE           = %d\\n\", __func__, k, BIGK_FRAGMENT_SIZE[k]);\n#endif\n\t}\n} \n\nunsigned int dml32_CalculateVMAndRowBytes(\n\t\tbool ViewportStationary,\n\t\tbool DCCEnable,\n\t\tunsigned int NumberOfDPPs,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum dm_rotation_angle SourceRotation,\n\t\tdouble SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tunsigned int    ViewportXStart,\n\t\tunsigned int    ViewportYStart,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int GPUVMMinPageSizeKBytes,\n\t\tunsigned int HostVMMinPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int MacroTileWidth,\n\t\tunsigned int MacroTileHeight,\n\n\t\t \n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tunsigned int    *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *dpte_row_height_linear,\n\t\tunsigned int    *PixelPTEBytesPerRow_one_row_per_frame,\n\t\tunsigned int    *dpte_row_width_ub_one_row_per_frame,\n\t\tunsigned int    *dpte_row_height_one_row_per_frame,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tunsigned int    *DPDE0BytesFrame,\n\t\tunsigned int    *MetaPTEBytesFrame)\n{\n\tunsigned int MPDEBytesFrame;\n\tunsigned int DCCMetaSurfaceBytes;\n\tunsigned int ExtraDPDEBytesFrame;\n\tunsigned int PDEAndMetaPTEBytesFrame;\n\tunsigned int HostVMDynamicLevels = 0;\n\tunsigned int    MacroTileSizeBytes;\n\tunsigned int    vp_height_meta_ub;\n\tunsigned int    vp_height_dpte_ub;\n\tunsigned int PixelPTEReqWidth_linear = 0; \n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tif (HostVMMinPageSize < 2048)\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\telse if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576)\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\telse\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t}\n\n\t*MetaRequestHeight = 8 * BlockHeight256Bytes;\n\t*MetaRequestWidth = 8 * BlockWidth256Bytes;\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\t*meta_row_height = 32;\n\t\t*meta_row_width = dml_floor(ViewportXStart + SwathWidth + *MetaRequestWidth - 1, *MetaRequestWidth)\n\t\t\t\t- dml_floor(ViewportXStart, *MetaRequestWidth);\n\t} else if (!IsVertical(SourceRotation)) {\n\t\t*meta_row_height = *MetaRequestHeight;\n\t\tif (ViewportStationary && NumberOfDPPs == 1) {\n\t\t\t*meta_row_width = dml_floor(ViewportXStart + SwathWidth + *MetaRequestWidth - 1,\n\t\t\t\t\t*MetaRequestWidth) - dml_floor(ViewportXStart, *MetaRequestWidth);\n\t\t} else {\n\t\t\t*meta_row_width = dml_ceil(SwathWidth - 1, *MetaRequestWidth) + *MetaRequestWidth;\n\t\t}\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestHeight * BytePerPixel / 256.0;\n\t} else {\n\t\t*meta_row_height = *MetaRequestWidth;\n\t\tif (ViewportStationary && NumberOfDPPs == 1) {\n\t\t\t*meta_row_width = dml_floor(ViewportYStart + ViewportHeight + *MetaRequestHeight - 1,\n\t\t\t\t\t*MetaRequestHeight) - dml_floor(ViewportYStart, *MetaRequestHeight);\n\t\t} else {\n\t\t\t*meta_row_width = dml_ceil(SwathWidth - 1, *MetaRequestHeight) + *MetaRequestHeight;\n\t\t}\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestWidth * BytePerPixel / 256.0;\n\t}\n\n\tif (ViewportStationary && (NumberOfDPPs == 1 || !IsVertical(SourceRotation))) {\n\t\tvp_height_meta_ub = dml_floor(ViewportYStart + ViewportHeight + 64 * BlockHeight256Bytes - 1,\n\t\t\t\t64 * BlockHeight256Bytes) - dml_floor(ViewportYStart, 64 * BlockHeight256Bytes);\n\t} else if (!IsVertical(SourceRotation)) {\n\t\tvp_height_meta_ub = dml_ceil(ViewportHeight - 1, 64 * BlockHeight256Bytes) + 64 * BlockHeight256Bytes;\n\t} else {\n\t\tvp_height_meta_ub = dml_ceil(SwathWidth - 1, 64 * BlockHeight256Bytes) + 64 * BlockHeight256Bytes;\n\t}\n\n\tDCCMetaSurfaceBytes = DCCMetaPitch * vp_height_meta_ub * BytePerPixel / 256.0;\n\n\tif (GPUVMEnable == true) {\n\t\t*MetaPTEBytesFrame = (dml_ceil((double) (DCCMetaSurfaceBytes - 4.0 * 1024.0) /\n\t\t\t\t(8 * 4.0 * 1024), 1) + 1) * 64;\n\t\tMPDEBytesFrame = 128 * (GPUVMMaxPageTableLevels - 1);\n\t} else {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t}\n\n\tif (DCCEnable != true) {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t\t*MetaRowByte = 0;\n\t}\n\n\tMacroTileSizeBytes = MacroTileWidth * BytePerPixel * MacroTileHeight;\n\n\tif (GPUVMEnable == true && GPUVMMaxPageTableLevels > 1) {\n\t\tif (ViewportStationary && (NumberOfDPPs == 1 || !IsVertical(SourceRotation))) {\n\t\t\tvp_height_dpte_ub = dml_floor(ViewportYStart + ViewportHeight +\n\t\t\t\t\tMacroTileHeight - 1, MacroTileHeight) -\n\t\t\t\t\tdml_floor(ViewportYStart, MacroTileHeight);\n\t\t} else if (!IsVertical(SourceRotation)) {\n\t\t\tvp_height_dpte_ub = dml_ceil(ViewportHeight - 1, MacroTileHeight) + MacroTileHeight;\n\t\t} else {\n\t\t\tvp_height_dpte_ub = dml_ceil(SwathWidth - 1, MacroTileHeight) + MacroTileHeight;\n\t\t}\n\t\t*DPDE0BytesFrame = 64 * (dml_ceil((Pitch * vp_height_dpte_ub * BytePerPixel - MacroTileSizeBytes) /\n\t\t\t\t(8 * 2097152), 1) + 1);\n\t\tExtraDPDEBytesFrame = 128 * (GPUVMMaxPageTableLevels - 2);\n\t} else {\n\t\t*DPDE0BytesFrame = 0;\n\t\tExtraDPDEBytesFrame = 0;\n\t\tvp_height_dpte_ub = 0;\n\t}\n\n\tPDEAndMetaPTEBytesFrame = *MetaPTEBytesFrame + MPDEBytesFrame + *DPDE0BytesFrame + ExtraDPDEBytesFrame;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DCCEnable = %d\\n\", __func__, DCCEnable);\n\tdml_print(\"DML::%s: GPUVMEnable = %d\\n\", __func__, GPUVMEnable);\n\tdml_print(\"DML::%s: SwModeLinear = %d\\n\", __func__, SurfaceTiling == dm_sw_linear);\n\tdml_print(\"DML::%s: BytePerPixel = %d\\n\", __func__, BytePerPixel);\n\tdml_print(\"DML::%s: GPUVMMaxPageTableLevels = %d\\n\", __func__, GPUVMMaxPageTableLevels);\n\tdml_print(\"DML::%s: BlockHeight256Bytes = %d\\n\", __func__, BlockHeight256Bytes);\n\tdml_print(\"DML::%s: BlockWidth256Bytes = %d\\n\", __func__, BlockWidth256Bytes);\n\tdml_print(\"DML::%s: MacroTileHeight = %d\\n\", __func__, MacroTileHeight);\n\tdml_print(\"DML::%s: MacroTileWidth = %d\\n\", __func__, MacroTileWidth);\n\tdml_print(\"DML::%s: MetaPTEBytesFrame = %d\\n\", __func__, *MetaPTEBytesFrame);\n\tdml_print(\"DML::%s: MPDEBytesFrame = %d\\n\", __func__, MPDEBytesFrame);\n\tdml_print(\"DML::%s: DPDE0BytesFrame = %d\\n\", __func__, *DPDE0BytesFrame);\n\tdml_print(\"DML::%s: ExtraDPDEBytesFrame= %d\\n\", __func__, ExtraDPDEBytesFrame);\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n\tdml_print(\"DML::%s: ViewportHeight = %d\\n\", __func__, ViewportHeight);\n\tdml_print(\"DML::%s: SwathWidth = %d\\n\", __func__, SwathWidth);\n\tdml_print(\"DML::%s: vp_height_dpte_ub = %d\\n\", __func__, vp_height_dpte_ub);\n#endif\n\n\tif (HostVMEnable == true)\n\t\tPDEAndMetaPTEBytesFrame = PDEAndMetaPTEBytesFrame * (1 + 8 * HostVMDynamicLevels);\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\t*PixelPTEReqHeight = 1;\n\t\t*PixelPTEReqWidth = GPUVMMinPageSizeKBytes * 1024 * 8 / BytePerPixel;\n\t\tPixelPTEReqWidth_linear = GPUVMMinPageSizeKBytes * 1024 * 8 / BytePerPixel;\n\t\t*PTERequestSize = 64;\n\t} else if (GPUVMMinPageSizeKBytes == 4) {\n\t\t*PixelPTEReqHeight = 16 * BlockHeight256Bytes;\n\t\t*PixelPTEReqWidth = 16 * BlockWidth256Bytes;\n\t\t*PTERequestSize = 128;\n\t} else {\n\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t*PixelPTEReqWidth = 8 *  1024 * GPUVMMinPageSizeKBytes / (MacroTileHeight * BytePerPixel);\n\t\t*PTERequestSize = 64;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: GPUVMMinPageSizeKBytes = %d\\n\", __func__, GPUVMMinPageSizeKBytes);\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d (after HostVM factor)\\n\", __func__, PDEAndMetaPTEBytesFrame);\n\tdml_print(\"DML::%s: PixelPTEReqHeight = %d\\n\", __func__, *PixelPTEReqHeight);\n\tdml_print(\"DML::%s: PixelPTEReqWidth = %d\\n\", __func__, *PixelPTEReqWidth);\n\tdml_print(\"DML::%s: PixelPTEReqWidth_linear = %d\\n\", __func__, PixelPTEReqWidth_linear);\n\tdml_print(\"DML::%s: PTERequestSize = %d\\n\", __func__, *PTERequestSize);\n\tdml_print(\"DML::%s: Pitch = %d\\n\", __func__, Pitch);\n#endif\n\n\t*dpte_row_height_one_row_per_frame = vp_height_dpte_ub;\n\t*dpte_row_width_ub_one_row_per_frame = (dml_ceil(((double)Pitch * (double)*dpte_row_height_one_row_per_frame /\n\t\t\t(double) *PixelPTEReqHeight - 1) / (double) *PixelPTEReqWidth, 1) + 1) *\n\t\t\t\t\t(double) *PixelPTEReqWidth;\n\t*PixelPTEBytesPerRow_one_row_per_frame = *dpte_row_width_ub_one_row_per_frame / *PixelPTEReqWidth *\n\t\t\t*PTERequestSize;\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\t*dpte_row_height = dml_min(128, 1 << (unsigned int) dml_floor(dml_log2(PTEBufferSizeInRequests *\n\t\t\t\t*PixelPTEReqWidth / Pitch), 1));\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: dpte_row_height = %d (1)\\n\", __func__,\n\t\t\t\tPTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch);\n\t\tdml_print(\"DML::%s: dpte_row_height = %f (2)\\n\", __func__,\n\t\t\t\tdml_log2(PTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch));\n\t\tdml_print(\"DML::%s: dpte_row_height = %f (3)\\n\", __func__,\n\t\t\t\tdml_floor(dml_log2(PTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch), 1));\n\t\tdml_print(\"DML::%s: dpte_row_height = %d (4)\\n\", __func__,\n\t\t\t\t1 << (unsigned int) dml_floor(dml_log2(PTEBufferSizeInRequests *\n\t\t\t\t\t\t*PixelPTEReqWidth / Pitch), 1));\n\t\tdml_print(\"DML::%s: dpte_row_height = %d\\n\", __func__, *dpte_row_height);\n#endif\n\t\t*dpte_row_width_ub = dml_ceil(((double) Pitch * (double) *dpte_row_height - 1),\n\t\t\t\t(double) *PixelPTEReqWidth) + *PixelPTEReqWidth;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / (double)*PixelPTEReqWidth * (double)*PTERequestSize;\n\n\t\t\n\t\t*dpte_row_height_linear = 1 << (unsigned int) dml_floor(dml_log2(PTEBufferSizeInRequests *\n\t\t\t\tPixelPTEReqWidth_linear / Pitch), 1);\n\t\tif (*dpte_row_height_linear > 128)\n\t\t\t*dpte_row_height_linear = 128;\n\n\t} else if (!IsVertical(SourceRotation)) {\n\t\t*dpte_row_height = *PixelPTEReqHeight;\n\n\t\tif (GPUVMMinPageSizeKBytes > 64) {\n\t\t\t*dpte_row_width_ub = (dml_ceil((Pitch * *dpte_row_height / *PixelPTEReqHeight - 1) /\n\t\t\t\t\t*PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t} else if (ViewportStationary && (NumberOfDPPs == 1)) {\n\t\t\t*dpte_row_width_ub = dml_floor(ViewportXStart + SwathWidth +\n\t\t\t\t\t*PixelPTEReqWidth - 1, *PixelPTEReqWidth) -\n\t\t\t\t\tdml_floor(ViewportXStart, *PixelPTEReqWidth);\n\t\t} else {\n\t\t\t*dpte_row_width_ub = (dml_ceil((SwathWidth - 1) / *PixelPTEReqWidth, 1) + 1) *\n\t\t\t\t\t*PixelPTEReqWidth;\n\t\t}\n\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t} else {\n\t\t*dpte_row_height = dml_min(*PixelPTEReqWidth, MacroTileWidth);\n\n\t\tif (ViewportStationary && (NumberOfDPPs == 1)) {\n\t\t\t*dpte_row_width_ub = dml_floor(ViewportYStart + ViewportHeight + *PixelPTEReqHeight - 1,\n\t\t\t\t\t*PixelPTEReqHeight) - dml_floor(ViewportYStart, *PixelPTEReqHeight);\n\t\t} else {\n\t\t\t*dpte_row_width_ub = (dml_ceil((SwathWidth - 1) / *PixelPTEReqHeight, 1) + 1)\n\t\t\t\t\t* *PixelPTEReqHeight;\n\t\t}\n\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqHeight * *PTERequestSize;\n\t}\n\n\tif (GPUVMEnable != true)\n\t\t*PixelPTEBytesPerRow = 0;\n\tif (HostVMEnable == true)\n\t\t*PixelPTEBytesPerRow = *PixelPTEBytesPerRow * (1 + 8 * HostVMDynamicLevels);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: GPUVMMinPageSizeKBytes = %d\\n\", __func__, GPUVMMinPageSizeKBytes);\n\tdml_print(\"DML::%s: dpte_row_height = %d\\n\", __func__, *dpte_row_height);\n\tdml_print(\"DML::%s: dpte_row_height_linear = %d\\n\", __func__, *dpte_row_height_linear);\n\tdml_print(\"DML::%s: dpte_row_width_ub = %d\\n\", __func__, *dpte_row_width_ub);\n\tdml_print(\"DML::%s: PixelPTEBytesPerRow = %d\\n\", __func__, *PixelPTEBytesPerRow);\n\tdml_print(\"DML::%s: PTEBufferSizeInRequests = %d\\n\", __func__, PTEBufferSizeInRequests);\n\tdml_print(\"DML::%s: dpte_row_height_one_row_per_frame = %d\\n\", __func__, *dpte_row_height_one_row_per_frame);\n\tdml_print(\"DML::%s: dpte_row_width_ub_one_row_per_frame = %d\\n\",\n\t\t\t__func__, *dpte_row_width_ub_one_row_per_frame);\n\tdml_print(\"DML::%s: PixelPTEBytesPerRow_one_row_per_frame = %d\\n\",\n\t\t\t__func__, *PixelPTEBytesPerRow_one_row_per_frame);\n\tdml_print(\"DML: vm_bytes = meta_pte_bytes_per_frame (per_pipe) = MetaPTEBytesFrame = : %i\\n\",\n\t\t\t*MetaPTEBytesFrame);\n#endif\n\n\treturn PDEAndMetaPTEBytesFrame;\n} \n\ndouble dml32_CalculatePrefetchSourceLines(\n\t\tdouble VRatio,\n\t\tunsigned int VTaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tenum dm_rotation_angle SourceRotation,\n\t\tbool ViewportStationary,\n\t\tdouble SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tunsigned int ViewportXStart,\n\t\tunsigned int ViewportYStart,\n\n\t\t \n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath)\n{\n\n\tunsigned int vp_start_rot;\n\tunsigned int sw0_tmp;\n\tunsigned int MaxPartialSwath;\n\tdouble numLines;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VRatio = %f\\n\", __func__, VRatio);\n\tdml_print(\"DML::%s: VTaps = %d\\n\", __func__, VTaps);\n\tdml_print(\"DML::%s: ViewportXStart = %d\\n\", __func__, ViewportXStart);\n\tdml_print(\"DML::%s: ViewportYStart = %d\\n\", __func__, ViewportYStart);\n\tdml_print(\"DML::%s: ViewportStationary = %d\\n\", __func__, ViewportStationary);\n\tdml_print(\"DML::%s: SwathHeight = %d\\n\", __func__, SwathHeight);\n#endif\n\tif (ProgressiveToInterlaceUnitInOPP)\n\t\t*VInitPreFill = dml_floor((VRatio + (double) VTaps + 1) / 2.0, 1);\n\telse\n\t\t*VInitPreFill = dml_floor((VRatio + (double) VTaps + 1 + Interlace * 0.5 * VRatio) / 2.0, 1);\n\n\tif (ViewportStationary) {\n\t\tif (SourceRotation == dm_rotation_180 || SourceRotation == dm_rotation_180m) {\n\t\t\tvp_start_rot = SwathHeight -\n\t\t\t\t\t(((unsigned int) (ViewportYStart + ViewportHeight - 1) % SwathHeight) + 1);\n\t\t} else if (SourceRotation == dm_rotation_270 || SourceRotation == dm_rotation_90m) {\n\t\t\tvp_start_rot = ViewportXStart;\n\t\t} else if (SourceRotation == dm_rotation_90 || SourceRotation == dm_rotation_270m) {\n\t\t\tvp_start_rot = SwathHeight -\n\t\t\t\t\t(((unsigned int)(ViewportYStart + SwathWidth - 1) % SwathHeight) + 1);\n\t\t} else {\n\t\t\tvp_start_rot = ViewportYStart;\n\t\t}\n\t\tsw0_tmp = SwathHeight - (vp_start_rot % SwathHeight);\n\t\tif (sw0_tmp < *VInitPreFill)\n\t\t\t*MaxNumSwath = dml_ceil((*VInitPreFill - sw0_tmp) / SwathHeight, 1) + 1;\n\t\telse\n\t\t\t*MaxNumSwath = 1;\n\t\tMaxPartialSwath = dml_max(1, (unsigned int) (vp_start_rot + *VInitPreFill - 1) % SwathHeight);\n\t} else {\n\t\t*MaxNumSwath = dml_ceil((*VInitPreFill - 1.0) / SwathHeight, 1) + 1;\n\t\tif (*VInitPreFill > 1)\n\t\t\tMaxPartialSwath = dml_max(1, (unsigned int) (*VInitPreFill - 2) % SwathHeight);\n\t\telse\n\t\t\tMaxPartialSwath = dml_max(1, (unsigned int) (*VInitPreFill + SwathHeight - 2) % SwathHeight);\n\t}\n\tnumLines = *MaxNumSwath * SwathHeight + MaxPartialSwath;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: vp_start_rot = %d\\n\", __func__, vp_start_rot);\n\tdml_print(\"DML::%s: VInitPreFill = %d\\n\", __func__, *VInitPreFill);\n\tdml_print(\"DML::%s: MaxPartialSwath = %d\\n\", __func__, MaxPartialSwath);\n\tdml_print(\"DML::%s: MaxNumSwath = %d\\n\", __func__, *MaxNumSwath);\n\tdml_print(\"DML::%s: Prefetch source lines = %3.2f\\n\", __func__, numLines);\n#endif\n\treturn numLines;\n\n} \n\nvoid dml32_CalculateMALLUseForStaticScreen(\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int MALLAllocatedForDCNFinal,\n\t\tenum dm_use_mall_for_static_screen_mode *UseMALLForStaticScreen,\n\t\tunsigned int SurfaceSizeInMALL[],\n\t\tbool one_row_per_frame_fits_in_buffer[],\n\n\t\t \n\t\tbool UsesMALLForStaticScreen[])\n{\n\tunsigned int k;\n\tunsigned int SurfaceToAddToMALL;\n\tbool CanAddAnotherSurfaceToMALL;\n\tunsigned int TotalSurfaceSizeInMALL;\n\n\tTotalSurfaceSizeInMALL = 0;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tUsesMALLForStaticScreen[k] = (UseMALLForStaticScreen[k] == dm_use_mall_static_screen_enable);\n\t\tif (UsesMALLForStaticScreen[k])\n\t\t\tTotalSurfaceSizeInMALL = TotalSurfaceSizeInMALL + SurfaceSizeInMALL[k];\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, UsesMALLForStaticScreen = %d\\n\",  __func__, k, UsesMALLForStaticScreen[k]);\n\t\tdml_print(\"DML::%s: k=%d, TotalSurfaceSizeInMALL = %d\\n\",  __func__, k, TotalSurfaceSizeInMALL);\n#endif\n\t}\n\n\tSurfaceToAddToMALL = 0;\n\tCanAddAnotherSurfaceToMALL = true;\n\twhile (CanAddAnotherSurfaceToMALL) {\n\t\tCanAddAnotherSurfaceToMALL = false;\n\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\tif (TotalSurfaceSizeInMALL + SurfaceSizeInMALL[k] <= MALLAllocatedForDCNFinal * 1024 * 1024 &&\n\t\t\t\t\t!UsesMALLForStaticScreen[k] &&\n\t\t\t\t\tUseMALLForStaticScreen[k] != dm_use_mall_static_screen_disable &&\n\t\t\t\t\tone_row_per_frame_fits_in_buffer[k] &&\n\t\t\t\t\t(!CanAddAnotherSurfaceToMALL ||\n\t\t\t\t\tSurfaceSizeInMALL[k] < SurfaceSizeInMALL[SurfaceToAddToMALL])) {\n\t\t\t\tCanAddAnotherSurfaceToMALL = true;\n\t\t\t\tSurfaceToAddToMALL = k;\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: k=%d, UseMALLForStaticScreen = %d (dis, en, optimize)\\n\",\n\t\t\t\t\t\t__func__, k, UseMALLForStaticScreen[k]);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (CanAddAnotherSurfaceToMALL) {\n\t\t\tUsesMALLForStaticScreen[SurfaceToAddToMALL] = true;\n\t\t\tTotalSurfaceSizeInMALL = TotalSurfaceSizeInMALL + SurfaceSizeInMALL[SurfaceToAddToMALL];\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: SurfaceToAddToMALL       = %d\\n\",  __func__, SurfaceToAddToMALL);\n\t\t\tdml_print(\"DML::%s: TotalSurfaceSizeInMALL   = %d\\n\",  __func__, TotalSurfaceSizeInMALL);\n#endif\n\n\t\t}\n\t}\n}\n\nvoid dml32_CalculateRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\t \n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw)\n{\n\tif (DCCEnable != true) {\n\t\t*meta_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 ||\n\t\t\tSourcePixelFormat == dm_rgbe_alpha) {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime) + VRatioChroma *\n\t\t\t\tMetaRowByteChroma / (meta_row_height_chroma * LineTime);\n\t} else {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime);\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*dpte_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 ||\n\t\t\tSourcePixelFormat == dm_rgbe_alpha) {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime) +\n\t\t\t\tVRatioChroma * PixelPTEBytesPerRowChroma / (dpte_row_height_chroma * LineTime);\n\t} else {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime);\n\t}\n}\n\ndouble dml32_CalculateUrgentLatency(\n\t\tdouble UrgentLatencyPixelDataOnly,\n\t\tdouble UrgentLatencyPixelMixedWithVMData,\n\t\tdouble UrgentLatencyVMDataOnly,\n\t\tbool   DoUrgentLatencyAdjustment,\n\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,\n\t\tdouble UrgentLatencyAdjustmentFabricClockReference,\n\t\tdouble FabricClock)\n{\n\tdouble   ret;\n\n\tret = dml_max3(UrgentLatencyPixelDataOnly, UrgentLatencyPixelMixedWithVMData, UrgentLatencyVMDataOnly);\n\tif (DoUrgentLatencyAdjustment == true) {\n\t\tret = ret + UrgentLatencyAdjustmentFabricClockComponent *\n\t\t\t\t(UrgentLatencyAdjustmentFabricClockReference / FabricClock - 1);\n\t}\n\treturn ret;\n}\n\nvoid dml32_CalculateUrgentBurstFactor(\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange,\n\t\tunsigned int    swath_width_luma_ub,\n\t\tunsigned int    swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble  LineTime,\n\t\tdouble  UrgentLatency,\n\t\tdouble  CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble  VRatio,\n\t\tdouble  VRatioC,\n\t\tdouble  BytePerPixelInDETY,\n\t\tdouble  BytePerPixelInDETC,\n\t\tunsigned int    DETBufferSizeY,\n\t\tunsigned int    DETBufferSizeC,\n\t\t \n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tbool   *NotEnoughUrgentLatencyHiding)\n{\n\tdouble       LinesInDETLuma;\n\tdouble       LinesInDETChroma;\n\tunsigned int LinesInCursorBuffer;\n\tdouble       CursorBufferSizeInTime;\n\tdouble       DETBufferSizeInTimeLuma;\n\tdouble       DETBufferSizeInTimeChroma;\n\n\t*NotEnoughUrgentLatencyHiding = 0;\n\n\tif (CursorWidth > 0) {\n\t\tLinesInCursorBuffer = 1 << (unsigned int) dml_floor(dml_log2(CursorBufferSize * 1024.0 /\n\t\t\t\t(CursorWidth * CursorBPP / 8.0)), 1.0);\n\t\tif (VRatio > 0) {\n\t\t\tCursorBufferSizeInTime = LinesInCursorBuffer * LineTime / VRatio;\n\t\t\tif (CursorBufferSizeInTime - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorCursor = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorCursor = CursorBufferSizeInTime /\n\t\t\t\t\t\t(CursorBufferSizeInTime - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorCursor = 1;\n\t\t}\n\t}\n\n\tLinesInDETLuma = (UseMALLForPStateChange == dm_use_mall_pstate_change_phantom_pipe ? 1024*1024 :\n\t\t\tDETBufferSizeY) / BytePerPixelInDETY / swath_width_luma_ub;\n\n\tif (VRatio > 0) {\n\t\tDETBufferSizeInTimeLuma = dml_floor(LinesInDETLuma, SwathHeightY) * LineTime / VRatio;\n\t\tif (DETBufferSizeInTimeLuma - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t*UrgentBurstFactorLuma = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorLuma = DETBufferSizeInTimeLuma / (DETBufferSizeInTimeLuma - UrgentLatency);\n\t\t}\n\t} else {\n\t\t*UrgentBurstFactorLuma = 1;\n\t}\n\n\tif (BytePerPixelInDETC > 0) {\n\t\tLinesInDETChroma = (UseMALLForPStateChange == dm_use_mall_pstate_change_phantom_pipe ?\n\t\t\t\t\t1024 * 1024 : DETBufferSizeC) / BytePerPixelInDETC\n\t\t\t\t\t/ swath_width_chroma_ub;\n\n\t\tif (VRatio > 0) {\n\t\t\tDETBufferSizeInTimeChroma = dml_floor(LinesInDETChroma, SwathHeightC) * LineTime / VRatio;\n\t\t\tif (DETBufferSizeInTimeChroma - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorChroma = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorChroma = DETBufferSizeInTimeChroma\n\t\t\t\t\t\t/ (DETBufferSizeInTimeChroma - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorChroma = 1;\n\t\t}\n\t}\n} \n\nvoid dml32_CalculateDCFCLKDeepSleep(\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int BytePerPixelY[],\n\t\tunsigned int BytePerPixelC[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerSurface[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble Dppclk[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tunsigned int ReturnBusWidth,\n\n\t\t \n\t\tdouble *DCFClkDeepSleep)\n{\n\tunsigned int k;\n\tdouble   DisplayPipeLineDeliveryTimeLuma;\n\tdouble   DisplayPipeLineDeliveryTimeChroma;\n\tdouble   DCFClkDeepSleepPerSurface[DC__NUM_DPP__MAX];\n\tdouble ReadBandwidth = 0.0;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerSurface[k] / HRatio[k]\n\t\t\t\t\t/ PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] / PSCL_THROUGHPUT[k] / Dppclk[k];\n\t\t}\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] *\n\t\t\t\t\t\tDPPPerSurface[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] / PSCL_THROUGHPUT_CHROMA[k]\n\t\t\t\t\t\t/ Dppclk[k];\n\t\t\t}\n\t\t}\n\n\t\tif (BytePerPixelC[k] > 0) {\n\t\t\tDCFClkDeepSleepPerSurface[k] = dml_max(__DML_MIN_DCFCLK_FACTOR__ * SwathWidthY[k] *\n\t\t\t\t\tBytePerPixelY[k] / 32.0 / DisplayPipeLineDeliveryTimeLuma,\n\t\t\t\t\t__DML_MIN_DCFCLK_FACTOR__ * SwathWidthC[k] * BytePerPixelC[k] /\n\t\t\t\t\t32.0 / DisplayPipeLineDeliveryTimeChroma);\n\t\t} else {\n\t\t\tDCFClkDeepSleepPerSurface[k] = __DML_MIN_DCFCLK_FACTOR__ * SwathWidthY[k] * BytePerPixelY[k] /\n\t\t\t\t\t64.0 / DisplayPipeLineDeliveryTimeLuma;\n\t\t}\n\t\tDCFClkDeepSleepPerSurface[k] = dml_max(DCFClkDeepSleepPerSurface[k], PixelClock[k] / 16);\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n\t\tdml_print(\"DML::%s: k=%d, DCFClkDeepSleepPerSurface = %f\\n\", __func__, k, DCFClkDeepSleepPerSurface[k]);\n#endif\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k)\n\t\tReadBandwidth = ReadBandwidth + ReadBandwidthLuma[k] + ReadBandwidthChroma[k];\n\n\t*DCFClkDeepSleep = dml_max(8.0, __DML_MIN_DCFCLK_FACTOR__ * ReadBandwidth / (double) ReturnBusWidth);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: __DML_MIN_DCFCLK_FACTOR__ = %f\\n\", __func__, __DML_MIN_DCFCLK_FACTOR__);\n\tdml_print(\"DML::%s: ReadBandwidth = %f\\n\", __func__, ReadBandwidth);\n\tdml_print(\"DML::%s: ReturnBusWidth = %d\\n\", __func__, ReturnBusWidth);\n\tdml_print(\"DML::%s: DCFClkDeepSleep = %f\\n\", __func__, *DCFClkDeepSleep);\n#endif\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k)\n\t\t*DCFClkDeepSleep = dml_max(*DCFClkDeepSleep, DCFClkDeepSleepPerSurface[k]);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DCFClkDeepSleep = %f (final)\\n\", __func__, *DCFClkDeepSleep);\n#endif\n} \n\ndouble dml32_CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackVTaps,\n\t\tunsigned int         WritebackDestinationWidth,\n\t\tunsigned int         WritebackDestinationHeight,\n\t\tunsigned int         WritebackSourceHeight,\n\t\tunsigned int HTotal)\n{\n\tdouble CalculateWriteBackDelay;\n\tdouble Line_length;\n\tdouble Output_lines_last_notclamped;\n\tdouble WritebackVInit;\n\n\tWritebackVInit = (WritebackVRatio + WritebackVTaps + 1) / 2;\n\tLine_length = dml_max((double) WritebackDestinationWidth,\n\t\t\tdml_ceil((double)WritebackDestinationWidth / 6.0, 1.0) * WritebackVTaps);\n\tOutput_lines_last_notclamped = WritebackDestinationHeight - 1 -\n\t\t\tdml_ceil(((double)WritebackSourceHeight -\n\t\t\t\t\t(double) WritebackVInit) / (double)WritebackVRatio, 1.0);\n\tif (Output_lines_last_notclamped < 0) {\n\t\tCalculateWriteBackDelay = 0;\n\t} else {\n\t\tCalculateWriteBackDelay = Output_lines_last_notclamped * Line_length +\n\t\t\t\t(HTotal - WritebackDestinationWidth) + 80;\n\t}\n\treturn CalculateWriteBackDelay;\n}\n\nvoid dml32_UseMinimumDCFCLK(\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],\n\t\tbool DRRDisplay[],\n\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int MaxPrefetchMode,\n\t\tdouble DRAMClockChangeLatencyFinal,\n\t\tdouble FCLKChangeLatency,\n\t\tdouble SREnterPlusExitTime,\n\t\tunsigned int ReturnBusWidth,\n\t\tunsigned int RoundTripPingLatencyCycles,\n\t\tunsigned int ReorderingBytes,\n\t\tunsigned int PixelChunkSizeInKByte,\n\t\tunsigned int MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tdouble HostVMMinPageSize,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tbool DynamicMetadataVMEnabled,\n\t\tbool ImmediateFlipRequirement,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation,\n\t\tdouble PercentOfIdealSDPPortBWReceivedAfterUrgLatency,\n\t\tunsigned int VTotal[],\n\t\tunsigned int VActive[],\n\t\tunsigned int DynamicMetadataTransmittedBytes[],\n\t\tunsigned int DynamicMetadataLinesBeforeActiveRequired[],\n\t\tbool Interlace[],\n\t\tdouble RequiredDPPCLKPerSurface[][2][DC__NUM_DPP__MAX],\n\t\tdouble RequiredDISPCLK[][2],\n\t\tdouble UrgLatency[],\n\t\tunsigned int NoOfDPP[][2][DC__NUM_DPP__MAX],\n\t\tdouble ProjectedDCFClkDeepSleep[][2],\n\t\tdouble MaximumVStartup[][2][DC__NUM_DPP__MAX],\n\t\tunsigned int TotalNumberOfActiveDPP[][2],\n\t\tunsigned int TotalNumberOfDCCActiveDPP[][2],\n\t\tunsigned int dpte_group_bytes[],\n\t\tdouble PrefetchLinesY[][2][DC__NUM_DPP__MAX],\n\t\tdouble PrefetchLinesC[][2][DC__NUM_DPP__MAX],\n\t\tunsigned int swath_width_luma_ub_all_states[][2][DC__NUM_DPP__MAX],\n\t\tunsigned int swath_width_chroma_ub_all_states[][2][DC__NUM_DPP__MAX],\n\t\tunsigned int BytePerPixelY[],\n\t\tunsigned int BytePerPixelC[],\n\t\tunsigned int HTotal[],\n\t\tdouble PixelClock[],\n\t\tdouble PDEAndMetaPTEBytesPerFrame[][2][DC__NUM_DPP__MAX],\n\t\tdouble DPTEBytesPerRow[][2][DC__NUM_DPP__MAX],\n\t\tdouble MetaRowBytes[][2][DC__NUM_DPP__MAX],\n\t\tbool DynamicMetadataEnable[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble DCFCLKPerState[],\n\t\t \n\t\tdouble DCFCLKState[][2])\n{\n\tunsigned int i, j, k;\n\tunsigned int     dummy1;\n\tdouble dummy2, dummy3;\n\tdouble   NormalEfficiency;\n\tdouble   TotalMaxPrefetchFlipDPTERowBandwidth[DC__VOLTAGE_STATES][2];\n\n\tNormalEfficiency = PercentOfIdealSDPPortBWReceivedAfterUrgLatency / 100.0;\n\tfor  (i = 0; i < DC__VOLTAGE_STATES; ++i) {\n\t\tfor  (j = 0; j <= 1; ++j) {\n\t\t\tdouble PixelDCFCLKCyclesRequiredInPrefetch[DC__NUM_DPP__MAX];\n\t\t\tdouble PrefetchPixelLinesTime[DC__NUM_DPP__MAX];\n\t\t\tdouble DCFCLKRequiredForPeakBandwidthPerSurface[DC__NUM_DPP__MAX];\n\t\t\tdouble DynamicMetadataVMExtraLatency[DC__NUM_DPP__MAX];\n\t\t\tdouble MinimumTWait = 0.0;\n\t\t\tdouble DPTEBandwidth;\n\t\t\tdouble DCFCLKRequiredForAverageBandwidth;\n\t\t\tunsigned int ExtraLatencyBytes;\n\t\t\tdouble ExtraLatencyCycles;\n\t\t\tdouble DCFCLKRequiredForPeakBandwidth;\n\t\t\tunsigned int NoOfDPPState[DC__NUM_DPP__MAX];\n\t\t\tdouble MinimumTvmPlus2Tr0;\n\n\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = 0;\n\t\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = TotalMaxPrefetchFlipDPTERowBandwidth[i][j]\n\t\t\t\t\t\t+ NoOfDPP[i][j][k] * DPTEBytesPerRow[i][j][k]\n\t\t\t\t\t\t\t\t/ (15.75 * HTotal[k] / PixelClock[k]);\n\t\t\t}\n\n\t\t\tfor (k = 0; k <= NumberOfActiveSurfaces - 1; ++k)\n\t\t\t\tNoOfDPPState[k] = NoOfDPP[i][j][k];\n\n\t\t\tDPTEBandwidth = TotalMaxPrefetchFlipDPTERowBandwidth[i][j];\n\t\t\tDCFCLKRequiredForAverageBandwidth = dml_max(ProjectedDCFClkDeepSleep[i][j], DPTEBandwidth / NormalEfficiency / ReturnBusWidth);\n\n\t\t\tExtraLatencyBytes = dml32_CalculateExtraLatencyBytes(ReorderingBytes,\n\t\t\t\t\tTotalNumberOfActiveDPP[i][j], PixelChunkSizeInKByte,\n\t\t\t\t\tTotalNumberOfDCCActiveDPP[i][j], MetaChunkSize, GPUVMEnable, HostVMEnable,\n\t\t\t\t\tNumberOfActiveSurfaces, NoOfDPPState, dpte_group_bytes, 1, HostVMMinPageSize,\n\t\t\t\t\tHostVMMaxNonCachedPageTableLevels);\n\t\t\tExtraLatencyCycles = RoundTripPingLatencyCycles + __DML_ARB_TO_RET_DELAY__\n\t\t\t\t\t+ ExtraLatencyBytes / NormalEfficiency / ReturnBusWidth;\n\t\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\t\tdouble DCFCLKCyclesRequiredInPrefetch;\n\t\t\t\tdouble PrefetchTime;\n\n\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k] = (PrefetchLinesY[i][j][k]\n\t\t\t\t\t\t* swath_width_luma_ub_all_states[i][j][k] * BytePerPixelY[k]\n\t\t\t\t\t\t+ PrefetchLinesC[i][j][k] * swath_width_chroma_ub_all_states[i][j][k]\n\t\t\t\t\t\t\t\t* BytePerPixelC[k]) / NormalEfficiency\n\t\t\t\t\t\t/ ReturnBusWidth;\n\t\t\t\tDCFCLKCyclesRequiredInPrefetch = 2 * ExtraLatencyCycles / NoOfDPPState[k]\n\t\t\t\t\t\t+ PDEAndMetaPTEBytesPerFrame[i][j][k] / NormalEfficiency\n\t\t\t\t\t\t\t\t/ NormalEfficiency / ReturnBusWidth\n\t\t\t\t\t\t\t\t* (GPUVMMaxPageTableLevels > 2 ? 1 : 0)\n\t\t\t\t\t\t+ 2 * DPTEBytesPerRow[i][j][k] / NormalEfficiency / NormalEfficiency\n\t\t\t\t\t\t\t\t/ ReturnBusWidth\n\t\t\t\t\t\t+ 2 * MetaRowBytes[i][j][k] / NormalEfficiency / ReturnBusWidth\n\t\t\t\t\t\t+ PixelDCFCLKCyclesRequiredInPrefetch[k];\n\t\t\t\tPrefetchPixelLinesTime[k] = dml_max(PrefetchLinesY[i][j][k], PrefetchLinesC[i][j][k])\n\t\t\t\t\t\t* HTotal[k] / PixelClock[k];\n\t\t\t\tDynamicMetadataVMExtraLatency[k] = (GPUVMEnable == true &&\n\t\t\t\t\t\tDynamicMetadataEnable[k] == true && DynamicMetadataVMEnabled == true) ?\n\t\t\t\t\t\tUrgLatency[i] * GPUVMMaxPageTableLevels *\n\t\t\t\t\t\t(HostVMEnable == true ? HostVMMaxNonCachedPageTableLevels + 1 : 1) : 0;\n\n\t\t\t\tMinimumTWait = dml32_CalculateTWait(MaxPrefetchMode,\n\t\t\t\t\t\tUseMALLForPStateChange[k],\n\t\t\t\t\t\tSynchronizeDRRDisplaysForUCLKPStateChangeFinal,\n\t\t\t\t\t\tDRRDisplay[k],\n\t\t\t\t\t\tDRAMClockChangeLatencyFinal,\n\t\t\t\t\t\tFCLKChangeLatency,\n\t\t\t\t\t\tUrgLatency[i],\n\t\t\t\t\t\tSREnterPlusExitTime);\n\n\t\t\t\tPrefetchTime = (MaximumVStartup[i][j][k] - 1) * HTotal[k] / PixelClock[k] -\n\t\t\t\t\t\tMinimumTWait - UrgLatency[i] *\n\t\t\t\t\t\t((GPUVMMaxPageTableLevels <= 2 ? GPUVMMaxPageTableLevels :\n\t\t\t\t\t\tGPUVMMaxPageTableLevels - 2) *  (HostVMEnable == true ?\n\t\t\t\t\t\tHostVMMaxNonCachedPageTableLevels + 1 : 1) - 1) -\n\t\t\t\t\t\tDynamicMetadataVMExtraLatency[k];\n\n\t\t\t\tif (PrefetchTime > 0) {\n\t\t\t\t\tdouble ExpectedVRatioPrefetch;\n\n\t\t\t\t\tExpectedVRatioPrefetch = PrefetchPixelLinesTime[k] / (PrefetchTime *\n\t\t\t\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k] /\n\t\t\t\t\t\t\tDCFCLKCyclesRequiredInPrefetch);\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] = NoOfDPPState[k] *\n\t\t\t\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k] /\n\t\t\t\t\t\t\tPrefetchPixelLinesTime[k] *\n\t\t\t\t\t\t\tdml_max(1.0, ExpectedVRatioPrefetch) *\n\t\t\t\t\t\t\tdml_max(1.0, ExpectedVRatioPrefetch / 4);\n\t\t\t\t\tif (HostVMEnable == true || ImmediateFlipRequirement == true) {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] =\n\t\t\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] +\n\t\t\t\t\t\t\t\tNoOfDPPState[k] * DPTEBandwidth / NormalEfficiency /\n\t\t\t\t\t\t\t\tNormalEfficiency / ReturnBusWidth;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] = DCFCLKPerState[i];\n\t\t\t\t}\n\t\t\t\tif (DynamicMetadataEnable[k] == true) {\n\t\t\t\t\tdouble TSetupPipe;\n\t\t\t\t\tdouble TdmbfPipe;\n\t\t\t\t\tdouble TdmsksPipe;\n\t\t\t\t\tdouble TdmecPipe;\n\t\t\t\t\tdouble AllowedTimeForUrgentExtraLatency;\n\n\t\t\t\t\tdml32_CalculateVUpdateAndDynamicMetadataParameters(\n\t\t\t\t\t\t\tMaxInterDCNTileRepeaters,\n\t\t\t\t\t\t\tRequiredDPPCLKPerSurface[i][j][k],\n\t\t\t\t\t\t\tRequiredDISPCLK[i][j],\n\t\t\t\t\t\t\tProjectedDCFClkDeepSleep[i][j],\n\t\t\t\t\t\t\tPixelClock[k],\n\t\t\t\t\t\t\tHTotal[k],\n\t\t\t\t\t\t\tVTotal[k] - VActive[k],\n\t\t\t\t\t\t\tDynamicMetadataTransmittedBytes[k],\n\t\t\t\t\t\t\tDynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\t\t\tInterlace[k],\n\t\t\t\t\t\t\tProgressiveToInterlaceUnitInOPP,\n\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t&TSetupPipe,\n\t\t\t\t\t\t\t&TdmbfPipe,\n\t\t\t\t\t\t\t&TdmecPipe,\n\t\t\t\t\t\t\t&TdmsksPipe,\n\t\t\t\t\t\t\t&dummy1,\n\t\t\t\t\t\t\t&dummy2,\n\t\t\t\t\t\t\t&dummy3);\n\t\t\t\t\tAllowedTimeForUrgentExtraLatency = MaximumVStartup[i][j][k] * HTotal[k] /\n\t\t\t\t\t\t\tPixelClock[k] - MinimumTWait - TSetupPipe - TdmbfPipe -\n\t\t\t\t\t\t\tTdmecPipe - TdmsksPipe - DynamicMetadataVMExtraLatency[k];\n\t\t\t\t\tif (AllowedTimeForUrgentExtraLatency > 0)\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] =\n\t\t\t\t\t\t\t\tdml_max(DCFCLKRequiredForPeakBandwidthPerSurface[k],\n\t\t\t\t\t\t\t\tExtraLatencyCycles / AllowedTimeForUrgentExtraLatency);\n\t\t\t\t\telse\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k] = DCFCLKPerState[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tDCFCLKRequiredForPeakBandwidth = 0;\n\t\t\tfor (k = 0; k <= NumberOfActiveSurfaces - 1; ++k) {\n\t\t\t\tDCFCLKRequiredForPeakBandwidth = DCFCLKRequiredForPeakBandwidth +\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerSurface[k];\n\t\t\t}\n\t\t\tMinimumTvmPlus2Tr0 = UrgLatency[i] * (GPUVMEnable == true ?\n\t\t\t\t\t(HostVMEnable == true ? (GPUVMMaxPageTableLevels + 2) *\n\t\t\t\t\t(HostVMMaxNonCachedPageTableLevels + 1) - 1 : GPUVMMaxPageTableLevels + 1) : 0);\n\t\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\t\tdouble MaximumTvmPlus2Tr0PlusTsw;\n\n\t\t\t\tMaximumTvmPlus2Tr0PlusTsw = (MaximumVStartup[i][j][k] - 2) * HTotal[k] /\n\t\t\t\t\t\tPixelClock[k] - MinimumTWait - DynamicMetadataVMExtraLatency[k];\n\t\t\t\tif (MaximumTvmPlus2Tr0PlusTsw <= MinimumTvmPlus2Tr0 + PrefetchPixelLinesTime[k] / 4) {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = DCFCLKPerState[i];\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = dml_max3(DCFCLKRequiredForPeakBandwidth,\n\t\t\t\t\t\t\t2 * ExtraLatencyCycles / (MaximumTvmPlus2Tr0PlusTsw -\n\t\t\t\t\t\t\t\tMinimumTvmPlus2Tr0 -\n\t\t\t\t\t\t\t\tPrefetchPixelLinesTime[k] / 4),\n\t\t\t\t\t\t\t(2 * ExtraLatencyCycles +\n\t\t\t\t\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k]) /\n\t\t\t\t\t\t\t\t(MaximumTvmPlus2Tr0PlusTsw - MinimumTvmPlus2Tr0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tDCFCLKState[i][j] = dml_min(DCFCLKPerState[i], 1.05 *\n\t\t\t\t\tdml_max(DCFCLKRequiredForAverageBandwidth, DCFCLKRequiredForPeakBandwidth));\n\t\t}\n\t}\n}\n\nunsigned int dml32_CalculateExtraLatencyBytes(unsigned int ReorderingBytes,\n\t\tunsigned int TotalNumberOfActiveDPP,\n\t\tunsigned int PixelChunkSizeInKByte,\n\t\tunsigned int TotalNumberOfDCCActiveDPP,\n\t\tunsigned int MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int NumberOfDPP[],\n\t\tunsigned int dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels)\n{\n\tunsigned int k;\n\tdouble   ret;\n\tunsigned int  HostVMDynamicLevels;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tif (HostVMMinPageSize < 2048)\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\telse if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576)\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\telse\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t} else {\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tret = ReorderingBytes + (TotalNumberOfActiveDPP * PixelChunkSizeInKByte +\n\t\t\tTotalNumberOfDCCActiveDPP * MetaChunkSize) * 1024.0;\n\n\tif (GPUVMEnable == true) {\n\t\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\t\tret = ret + NumberOfDPP[k] * dpte_group_bytes[k] *\n\t\t\t\t\t(1 + 8 * HostVMDynamicLevels) * HostVMInefficiencyFactor;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid dml32_CalculateVUpdateAndDynamicMetadataParameters(\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tdouble Dppclk,\n\t\tdouble Dispclk,\n\t\tdouble DCFClkDeepSleep,\n\t\tdouble PixelClock,\n\t\tunsigned int HTotal,\n\t\tunsigned int VBlank,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tunsigned int DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int InterlaceEnable,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\n\t\t \n\t\tdouble *TSetup,\n\t\tdouble *Tdmbf,\n\t\tdouble *Tdmec,\n\t\tdouble *Tdmsks,\n\t\tunsigned int *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix)\n{\n\tdouble TotalRepeaterDelayTime;\n\n\tTotalRepeaterDelayTime = MaxInterDCNTileRepeaters * (2 / Dppclk + 3 / Dispclk);\n\t*VUpdateWidthPix  =\n\t\t\tdml_ceil((14.0 / DCFClkDeepSleep + 12.0 / Dppclk + TotalRepeaterDelayTime) * PixelClock, 1.0);\n\t*VReadyOffsetPix  = dml_ceil(dml_max(150.0 / Dppclk,\n\t\t\tTotalRepeaterDelayTime + 20.0 / DCFClkDeepSleep + 10.0 / Dppclk) * PixelClock, 1.0);\n\t*VUpdateOffsetPix = dml_ceil(HTotal / 4.0, 1.0);\n\t*TSetup = (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;\n\t*Tdmbf = DynamicMetadataTransmittedBytes / 4.0 / Dispclk;\n\t*Tdmec = HTotal / PixelClock;\n\n\tif (DynamicMetadataLinesBeforeActiveRequired == 0)\n\t\t*Tdmsks = VBlank * HTotal / PixelClock / 2.0;\n\telse\n\t\t*Tdmsks = DynamicMetadataLinesBeforeActiveRequired * HTotal / PixelClock;\n\n\tif (InterlaceEnable == 1 && ProgressiveToInterlaceUnitInOPP == false)\n\t\t*Tdmsks = *Tdmsks / 2;\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VUpdateWidthPix = %d\\n\", __func__, *VUpdateWidthPix);\n\tdml_print(\"DML::%s: VReadyOffsetPix = %d\\n\", __func__, *VReadyOffsetPix);\n\tdml_print(\"DML::%s: VUpdateOffsetPix = %d\\n\", __func__, *VUpdateOffsetPix);\n\n\tdml_print(\"DML::%s: DynamicMetadataLinesBeforeActiveRequired = %d\\n\",\n\t\t\t__func__, DynamicMetadataLinesBeforeActiveRequired);\n\tdml_print(\"DML::%s: VBlank = %d\\n\", __func__, VBlank);\n\tdml_print(\"DML::%s: HTotal = %d\\n\", __func__, HTotal);\n\tdml_print(\"DML::%s: PixelClock = %f\\n\", __func__, PixelClock);\n\tdml_print(\"DML::%s: Tdmsks = %f\\n\", __func__, *Tdmsks);\n#endif\n}\n\ndouble dml32_CalculateTWait(\n\t\tunsigned int PrefetchMode,\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange,\n\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,\n\t\tbool DRRDisplay,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble FCLKChangeLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble SREnterPlusExitTime)\n{\n\tdouble TWait = 0.0;\n\n\tif (PrefetchMode == 0 &&\n\t\t\t!(UseMALLForPStateChange == dm_use_mall_pstate_change_full_frame) &&\n\t\t\t!(UseMALLForPStateChange == dm_use_mall_pstate_change_sub_viewport) &&\n\t\t\t!(UseMALLForPStateChange == dm_use_mall_pstate_change_phantom_pipe) &&\n\t\t\t!(SynchronizeDRRDisplaysForUCLKPStateChangeFinal && DRRDisplay)) {\n\t\tTWait = dml_max3(DRAMClockChangeLatency + UrgentLatency, SREnterPlusExitTime, UrgentLatency);\n\t} else if (PrefetchMode <= 1 && !(UseMALLForPStateChange == dm_use_mall_pstate_change_phantom_pipe)) {\n\t\tTWait = dml_max3(FCLKChangeLatency + UrgentLatency, SREnterPlusExitTime, UrgentLatency);\n\t} else if (PrefetchMode <= 2 && !(UseMALLForPStateChange == dm_use_mall_pstate_change_phantom_pipe)) {\n\t\tTWait = dml_max(SREnterPlusExitTime, UrgentLatency);\n\t} else {\n\t\tTWait = UrgentLatency;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: PrefetchMode = %d\\n\", __func__, PrefetchMode);\n\tdml_print(\"DML::%s: TWait = %f\\n\", __func__, TWait);\n#endif\n\treturn TWait;\n} \n\n\n\ndouble dml32_get_return_bw_mbps(const soc_bounding_box_st *soc,\n\t\tconst int VoltageLevel,\n\t\tconst bool HostVMEnable,\n\t\tconst double DCFCLK,\n\t\tconst double FabricClock,\n\t\tconst double DRAMSpeed)\n{\n\tdouble ReturnBW = 0.;\n\tdouble IdealSDPPortBandwidth    = soc->return_bus_width_bytes   * DCFCLK;\n\tdouble IdealFabricBandwidth     = FabricClock * soc->fabric_datapath_to_dcn_data_return_bytes;\n\tdouble IdealDRAMBandwidth       = DRAMSpeed * soc->num_chans * soc->dram_channel_width_bytes;\n\tdouble PixelDataOnlyReturnBW    = dml_min3(IdealSDPPortBandwidth * soc->pct_ideal_sdp_bw_after_urgent / 100,\n\t\t\tIdealFabricBandwidth * soc->pct_ideal_fabric_bw_after_urgent / 100,\n\t\t\tIdealDRAMBandwidth * (VoltageLevel < 2 ? soc->pct_ideal_dram_bw_after_urgent_strobe  :\n\t\t\t\t\tsoc->pct_ideal_dram_sdp_bw_after_urgent_pixel_only) / 100);\n\tdouble PixelMixedWithVMDataReturnBW = dml_min3(IdealSDPPortBandwidth * soc->pct_ideal_sdp_bw_after_urgent / 100,\n\t\t\tIdealFabricBandwidth * soc->pct_ideal_fabric_bw_after_urgent / 100,\n\t\t\tIdealDRAMBandwidth * (VoltageLevel < 2 ? soc->pct_ideal_dram_bw_after_urgent_strobe :\n\t\t\t\t\tsoc->pct_ideal_dram_sdp_bw_after_urgent_pixel_only) / 100);\n\n\tif (HostVMEnable != true)\n\t\tReturnBW = PixelDataOnlyReturnBW;\n\telse\n\t\tReturnBW = PixelMixedWithVMDataReturnBW;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VoltageLevel = %d\\n\", __func__, VoltageLevel);\n\tdml_print(\"DML::%s: HostVMEnable = %d\\n\", __func__, HostVMEnable);\n\tdml_print(\"DML::%s: DCFCLK       = %f\\n\", __func__, DCFCLK);\n\tdml_print(\"DML::%s: FabricClock  = %f\\n\", __func__, FabricClock);\n\tdml_print(\"DML::%s: DRAMSpeed    = %f\\n\", __func__, DRAMSpeed);\n\tdml_print(\"DML::%s: IdealSDPPortBandwidth        = %f\\n\", __func__, IdealSDPPortBandwidth);\n\tdml_print(\"DML::%s: IdealFabricBandwidth         = %f\\n\", __func__, IdealFabricBandwidth);\n\tdml_print(\"DML::%s: IdealDRAMBandwidth           = %f\\n\", __func__, IdealDRAMBandwidth);\n\tdml_print(\"DML::%s: PixelDataOnlyReturnBW        = %f\\n\", __func__, PixelDataOnlyReturnBW);\n\tdml_print(\"DML::%s: PixelMixedWithVMDataReturnBW = %f\\n\", __func__, PixelMixedWithVMDataReturnBW);\n\tdml_print(\"DML::%s: ReturnBW                     = %f MBps\\n\", __func__, ReturnBW);\n#endif\n\treturn ReturnBW;\n}\n\n\n\ndouble dml32_get_return_bw_mbps_vm_only(const soc_bounding_box_st *soc,\n\t\tconst int VoltageLevel,\n\t\tconst double DCFCLK,\n\t\tconst double FabricClock,\n\t\tconst double DRAMSpeed)\n{\n\tdouble VMDataOnlyReturnBW = dml_min3(\n\t\t\tsoc->return_bus_width_bytes * DCFCLK * soc->pct_ideal_sdp_bw_after_urgent / 100.0,\n\t\t\tFabricClock * soc->fabric_datapath_to_dcn_data_return_bytes\n\t\t\t\t\t* soc->pct_ideal_sdp_bw_after_urgent / 100.0,\n\t\t\tDRAMSpeed * soc->num_chans * soc->dram_channel_width_bytes\n\t\t\t\t\t* (VoltageLevel < 2 ?\n\t\t\t\t\t\t\tsoc->pct_ideal_dram_bw_after_urgent_strobe :\n\t\t\t\t\t\t\tsoc->pct_ideal_dram_sdp_bw_after_urgent_vm_only) / 100.0);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VoltageLevel = %d\\n\", __func__, VoltageLevel);\n\tdml_print(\"DML::%s: DCFCLK       = %f\\n\", __func__, DCFCLK);\n\tdml_print(\"DML::%s: FabricClock  = %f\\n\", __func__, FabricClock);\n\tdml_print(\"DML::%s: DRAMSpeed    = %f\\n\", __func__, DRAMSpeed);\n\tdml_print(\"DML::%s: VMDataOnlyReturnBW = %f\\n\", __func__, VMDataOnlyReturnBW);\n#endif\n\treturn VMDataOnlyReturnBW;\n}\n\ndouble dml32_CalculateExtraLatency(\n\t\tunsigned int RoundTripPingLatencyCycles,\n\t\tunsigned int ReorderingBytes,\n\t\tdouble DCFCLK,\n\t\tunsigned int TotalNumberOfActiveDPP,\n\t\tunsigned int PixelChunkSizeInKByte,\n\t\tunsigned int TotalNumberOfDCCActiveDPP,\n\t\tunsigned int MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tunsigned int NumberOfDPP[],\n\t\tunsigned int dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels)\n{\n\tdouble ExtraLatencyBytes;\n\tdouble ExtraLatency;\n\n\tExtraLatencyBytes = dml32_CalculateExtraLatencyBytes(\n\t\t\tReorderingBytes,\n\t\t\tTotalNumberOfActiveDPP,\n\t\t\tPixelChunkSizeInKByte,\n\t\t\tTotalNumberOfDCCActiveDPP,\n\t\t\tMetaChunkSize,\n\t\t\tGPUVMEnable,\n\t\t\tHostVMEnable,\n\t\t\tNumberOfActiveSurfaces,\n\t\t\tNumberOfDPP,\n\t\t\tdpte_group_bytes,\n\t\t\tHostVMInefficiencyFactor,\n\t\t\tHostVMMinPageSize,\n\t\t\tHostVMMaxNonCachedPageTableLevels);\n\n\tExtraLatency = (RoundTripPingLatencyCycles + __DML_ARB_TO_RET_DELAY__) / DCFCLK + ExtraLatencyBytes / ReturnBW;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: RoundTripPingLatencyCycles=%d\\n\", __func__, RoundTripPingLatencyCycles);\n\tdml_print(\"DML::%s: DCFCLK=%f\\n\", __func__, DCFCLK);\n\tdml_print(\"DML::%s: ExtraLatencyBytes=%f\\n\", __func__, ExtraLatencyBytes);\n\tdml_print(\"DML::%s: ReturnBW=%f\\n\", __func__, ReturnBW);\n\tdml_print(\"DML::%s: ExtraLatency=%f\\n\", __func__, ExtraLatency);\n#endif\n\n\treturn ExtraLatency;\n} \n\nbool dml32_CalculatePrefetchSchedule(\n\t\tstruct vba_vars_st *v,\n\t\tunsigned int k,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tDmlPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tunsigned int DPP_RECOUT_WIDTH,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tunsigned int VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tunsigned int SwathWidthC,\n\t\tunsigned int VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tunsigned int swath_width_luma_ub,\n\t\tunsigned int swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tdouble TPreReq,\n\t\t \n\t\tdouble   *DSTXAfterScaler,\n\t\tdouble   *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tbool   *NotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tdouble *Tdmdl_vm,\n\t\tdouble *Tdmdl,\n\t\tdouble *TSetup,\n\t\tunsigned int   *VUpdateOffsetPix,\n\t\tdouble   *VUpdateWidthPix,\n\t\tdouble   *VReadyOffsetPix)\n{\n\tdouble DPPCLKDelaySubtotalPlusCNVCFormater = v->DPPCLKDelaySubtotal + v->DPPCLKDelayCNVCFormater;\n\tbool MyError = false;\n\tunsigned int DPPCycles, DISPCLKCycles;\n\tdouble DSTTotalPixelsAfterScaler;\n\tdouble LineTime;\n\tdouble dst_y_prefetch_equ;\n\tdouble prefetch_bw_oto;\n\tdouble Tvm_oto;\n\tdouble Tr0_oto;\n\tdouble Tvm_oto_lines;\n\tdouble Tr0_oto_lines;\n\tdouble dst_y_prefetch_oto;\n\tdouble TimeForFetchingMetaPTE = 0;\n\tdouble TimeForFetchingRowInVBlank = 0;\n\tdouble LinesToRequestPrefetchPixelData = 0;\n\tdouble LinesForPrefetchBandwidth = 0;\n\tunsigned int HostVMDynamicLevelsTrips;\n\tdouble  trip_to_mem;\n\tdouble  Tvm_trips;\n\tdouble  Tr0_trips;\n\tdouble  Tvm_trips_rounded;\n\tdouble  Tr0_trips_rounded;\n\tdouble  Lsw_oto;\n\tdouble  Tpre_rounded;\n\tdouble  prefetch_bw_equ;\n\tdouble  Tvm_equ;\n\tdouble  Tr0_equ;\n\tdouble  Tdmbf;\n\tdouble  Tdmec;\n\tdouble  Tdmsks;\n\tdouble  prefetch_sw_bytes;\n\tdouble  bytes_pp;\n\tdouble  dep_bytes;\n\tunsigned int max_vratio_pre = v->MaxVRatioPre;\n\tdouble  min_Lsw;\n\tdouble  Tsw_est1 = 0;\n\tdouble  Tsw_est3 = 0;\n\n\tif (v->GPUVMEnable == true && v->HostVMEnable == true)\n\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;\n\telse\n\t\tHostVMDynamicLevelsTrips = 0;\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: v->GPUVMEnable = %d\\n\", __func__, v->GPUVMEnable);\n\tdml_print(\"DML::%s: v->GPUVMMaxPageTableLevels = %d\\n\", __func__, v->GPUVMMaxPageTableLevels);\n\tdml_print(\"DML::%s: DCCEnable = %d\\n\", __func__, myPipe->DCCEnable);\n\tdml_print(\"DML::%s: v->HostVMEnable=%d HostVMInefficiencyFactor=%f\\n\",\n\t\t\t__func__, v->HostVMEnable, HostVMInefficiencyFactor);\n#endif\n\tdml32_CalculateVUpdateAndDynamicMetadataParameters(\n\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\tmyPipe->Dppclk,\n\t\t\tmyPipe->Dispclk,\n\t\t\tmyPipe->DCFClkDeepSleep,\n\t\t\tmyPipe->PixelClock,\n\t\t\tmyPipe->HTotal,\n\t\t\tmyPipe->VBlank,\n\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\tmyPipe->InterlaceEnable,\n\t\t\tmyPipe->ProgressiveToInterlaceUnitInOPP,\n\t\t\tTSetup,\n\n\t\t\t \n\t\t\t&Tdmbf,\n\t\t\t&Tdmec,\n\t\t\t&Tdmsks,\n\t\t\tVUpdateOffsetPix,\n\t\t\tVUpdateWidthPix,\n\t\t\tVReadyOffsetPix);\n\n\tLineTime = myPipe->HTotal / myPipe->PixelClock;\n\ttrip_to_mem = UrgentLatency;\n\tTvm_trips = UrgentExtraLatency + trip_to_mem * (v->GPUVMMaxPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1);\n\n\tif (v->DynamicMetadataVMEnabled == true)\n\t\t*Tdmdl = TWait + Tvm_trips + trip_to_mem;\n\telse\n\t\t*Tdmdl = TWait + UrgentExtraLatency;\n\n#ifdef __DML_VBA_ALLOW_DELTA__\n\tif (v->DynamicMetadataEnable[k] == false)\n\t\t*Tdmdl = 0.0;\n#endif\n\n\tif (v->DynamicMetadataEnable[k] == true) {\n\t\tif (VStartup * LineTime < *TSetup + *Tdmdl + Tdmbf + Tdmec + Tdmsks) {\n\t\t\t*NotEnoughTimeForDynamicMetadata = true;\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: Not Enough Time for Dynamic Meta!\\n\", __func__);\n\t\t\tdml_print(\"DML::%s: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\",\n\t\t\t\t\t__func__, Tdmbf);\n\t\t\tdml_print(\"DML::%s: Tdmec: %fus - time dio takes to transfer dmd\\n\", __func__, Tdmec);\n\t\t\tdml_print(\"DML::%s: Tdmsks: %fus - time before active dmd must complete transmission at dio\\n\",\n\t\t\t\t\t__func__, Tdmsks);\n\t\t\tdml_print(\"DML::%s: Tdmdl: %fus - time for fabric to become ready and fetch dmd\\n\",\n\t\t\t\t\t__func__, *Tdmdl);\n#endif\n\t\t} else {\n\t\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t\t}\n\t} else {\n\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t}\n\n\t*Tdmdl_vm =  (v->DynamicMetadataEnable[k] == true && v->DynamicMetadataVMEnabled == true &&\n\t\t\tv->GPUVMEnable == true ? TWait + Tvm_trips : 0);\n\n\tif (myPipe->ScalerEnabled)\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + v->DPPCLKDelaySCL;\n\telse\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + v->DPPCLKDelaySCLLBOnly;\n\n\tDPPCycles = DPPCycles + myPipe->NumberOfCursors * v->DPPCLKDelayCNVCCursor;\n\n\tDISPCLKCycles = v->DISPCLKDelaySubtotal;\n\n\tif (myPipe->Dppclk == 0.0 || myPipe->Dispclk == 0.0)\n\t\treturn true;\n\n\t*DSTXAfterScaler = DPPCycles * myPipe->PixelClock / myPipe->Dppclk + DISPCLKCycles *\n\t\t\tmyPipe->PixelClock / myPipe->Dispclk + DSCDelay;\n\n\t*DSTXAfterScaler = *DSTXAfterScaler + (myPipe->ODMMode != dm_odm_combine_mode_disabled ? 18 : 0)\n\t\t\t+ (myPipe->DPPPerSurface - 1) * DPP_RECOUT_WIDTH\n\t\t\t+ ((myPipe->ODMMode == dm_odm_split_mode_1to2 || myPipe->ODMMode == dm_odm_mode_mso_1to2) ?\n\t\t\t\t\tmyPipe->HActive / 2 : 0)\n\t\t\t+ ((myPipe->ODMMode == dm_odm_mode_mso_1to4) ? myPipe->HActive * 3 / 4 : 0);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DPPCycles: %d\\n\", __func__, DPPCycles);\n\tdml_print(\"DML::%s: PixelClock: %f\\n\", __func__, myPipe->PixelClock);\n\tdml_print(\"DML::%s: Dppclk: %f\\n\", __func__, myPipe->Dppclk);\n\tdml_print(\"DML::%s: DISPCLKCycles: %d\\n\", __func__, DISPCLKCycles);\n\tdml_print(\"DML::%s: DISPCLK: %f\\n\", __func__,  myPipe->Dispclk);\n\tdml_print(\"DML::%s: DSCDelay: %d\\n\", __func__,  DSCDelay);\n\tdml_print(\"DML::%s: ODMMode: %d\\n\", __func__,  myPipe->ODMMode);\n\tdml_print(\"DML::%s: DPP_RECOUT_WIDTH: %d\\n\", __func__, DPP_RECOUT_WIDTH);\n\tdml_print(\"DML::%s: DSTXAfterScaler: %d\\n\", __func__,  *DSTXAfterScaler);\n#endif\n\n\tif (v->OutputFormat[k] == dm_420 || (myPipe->InterlaceEnable && myPipe->ProgressiveToInterlaceUnitInOPP))\n\t\t*DSTYAfterScaler = 1;\n\telse\n\t\t*DSTYAfterScaler = 0;\n\n\tDSTTotalPixelsAfterScaler = *DSTYAfterScaler * myPipe->HTotal + *DSTXAfterScaler;\n\t*DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / myPipe->HTotal, 1);\n\t*DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * myPipe->HTotal));\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DSTXAfterScaler: %d (final)\\n\", __func__,  *DSTXAfterScaler);\n\tdml_print(\"DML::%s: DSTYAfterScaler: %d (final)\\n\", __func__, *DSTYAfterScaler);\n#endif\n\n\tMyError = false;\n\n\tTr0_trips = trip_to_mem * (HostVMDynamicLevelsTrips + 1);\n\n\tif (v->GPUVMEnable == true) {\n\t\tTvm_trips_rounded = dml_ceil(4.0 * Tvm_trips / LineTime, 1.0) / 4.0 * LineTime;\n\t\tTr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1.0) / 4.0 * LineTime;\n\t\tif (v->GPUVMMaxPageTableLevels >= 3) {\n\t\t\t*Tno_bw = UrgentExtraLatency + trip_to_mem *\n\t\t\t\t\t(double) ((v->GPUVMMaxPageTableLevels - 2) * (HostVMDynamicLevelsTrips + 1) - 1);\n\t\t} else if (v->GPUVMMaxPageTableLevels == 1 && myPipe->DCCEnable != true) {\n\t\t\tTr0_trips_rounded = dml_ceil(4.0 * UrgentExtraLatency / LineTime, 1.0) /\n\t\t\t\t\t4.0 * LineTime; \n\t\t\t*Tno_bw = UrgentExtraLatency;\n\t\t} else {\n\t\t\t*Tno_bw = 0;\n\t\t}\n\t} else if (myPipe->DCCEnable == true) {\n\t\tTvm_trips_rounded = LineTime / 4.0;\n\t\tTr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1.0) / 4.0 * LineTime;\n\t\t*Tno_bw = 0;\n\t} else {\n\t\tTvm_trips_rounded = LineTime / 4.0;\n\t\tTr0_trips_rounded = LineTime / 2.0;\n\t\t*Tno_bw = 0;\n\t}\n\tTvm_trips_rounded = dml_max(Tvm_trips_rounded, LineTime / 4.0);\n\tTr0_trips_rounded = dml_max(Tr0_trips_rounded, LineTime / 4.0);\n\n\tif (myPipe->SourcePixelFormat == dm_420_8 || myPipe->SourcePixelFormat == dm_420_10\n\t\t\t|| myPipe->SourcePixelFormat == dm_420_12) {\n\t\tbytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC / 4;\n\t} else {\n\t\tbytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC;\n\t}\n\n\tprefetch_sw_bytes = PrefetchSourceLinesY * swath_width_luma_ub * myPipe->BytePerPixelY\n\t\t\t+ PrefetchSourceLinesC * swath_width_chroma_ub * myPipe->BytePerPixelC;\n\tprefetch_bw_oto = dml_max(bytes_pp * myPipe->PixelClock / myPipe->DPPPerSurface,\n\t\t\tprefetch_sw_bytes / (dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) * LineTime));\n\n\tmin_Lsw = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) / max_vratio_pre;\n\tmin_Lsw = dml_max(min_Lsw, 1.0);\n\tLsw_oto = dml_ceil(4.0 * dml_max(prefetch_sw_bytes / prefetch_bw_oto / LineTime, min_Lsw), 1.0) / 4.0;\n\n\tif (v->GPUVMEnable == true) {\n\t\tTvm_oto = dml_max3(\n\t\t\t\tTvm_trips,\n\t\t\t\t*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_oto,\n\t\t\t\tLineTime / 4.0);\n\t} else\n\t\tTvm_oto = LineTime / 4.0;\n\n\tif ((v->GPUVMEnable == true || myPipe->DCCEnable == true)) {\n\t\tTr0_oto = dml_max4(\n\t\t\t\tTr0_trips,\n\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto,\n\t\t\t\t(LineTime - Tvm_oto)/2.0,\n\t\t\t\tLineTime / 4.0);\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: Tr0_oto max0 = %f\\n\", __func__,\n\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto);\n\t\tdml_print(\"DML::%s: Tr0_oto max1 = %f\\n\", __func__, Tr0_trips);\n\t\tdml_print(\"DML::%s: Tr0_oto max2 = %f\\n\", __func__, LineTime - Tvm_oto);\n\t\tdml_print(\"DML::%s: Tr0_oto max3 = %f\\n\", __func__, LineTime / 4);\n#endif\n\t} else\n\t\tTr0_oto = (LineTime - Tvm_oto) / 2.0;\n\n\tTvm_oto_lines = dml_ceil(4.0 * Tvm_oto / LineTime, 1) / 4.0;\n\tTr0_oto_lines = dml_ceil(4.0 * Tr0_oto / LineTime, 1) / 4.0;\n\tdst_y_prefetch_oto = Tvm_oto_lines + 2 * Tr0_oto_lines + Lsw_oto;\n\n\tdst_y_prefetch_equ = VStartup - (*TSetup + dml_max(TWait + TCalc, *Tdmdl)) / LineTime -\n\t\t\t(*DSTYAfterScaler + (double) *DSTXAfterScaler / (double) myPipe->HTotal);\n\n\tdst_y_prefetch_equ = dml_min(dst_y_prefetch_equ, __DML_VBA_MAX_DST_Y_PRE__);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: HTotal = %d\\n\", __func__, myPipe->HTotal);\n\tdml_print(\"DML::%s: min_Lsw = %f\\n\", __func__, min_Lsw);\n\tdml_print(\"DML::%s: *Tno_bw = %f\\n\", __func__, *Tno_bw);\n\tdml_print(\"DML::%s: UrgentExtraLatency = %f\\n\", __func__, UrgentExtraLatency);\n\tdml_print(\"DML::%s: trip_to_mem = %f\\n\", __func__, trip_to_mem);\n\tdml_print(\"DML::%s: BytePerPixelY = %d\\n\", __func__, myPipe->BytePerPixelY);\n\tdml_print(\"DML::%s: PrefetchSourceLinesY = %f\\n\", __func__, PrefetchSourceLinesY);\n\tdml_print(\"DML::%s: swath_width_luma_ub = %d\\n\", __func__, swath_width_luma_ub);\n\tdml_print(\"DML::%s: BytePerPixelC = %d\\n\", __func__, myPipe->BytePerPixelC);\n\tdml_print(\"DML::%s: PrefetchSourceLinesC = %f\\n\", __func__, PrefetchSourceLinesC);\n\tdml_print(\"DML::%s: swath_width_chroma_ub = %d\\n\", __func__, swath_width_chroma_ub);\n\tdml_print(\"DML::%s: prefetch_sw_bytes = %f\\n\", __func__, prefetch_sw_bytes);\n\tdml_print(\"DML::%s: bytes_pp = %f\\n\", __func__, bytes_pp);\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n\tdml_print(\"DML::%s: MetaRowByte = %d\\n\", __func__, MetaRowByte);\n\tdml_print(\"DML::%s: PixelPTEBytesPerRow = %d\\n\", __func__, PixelPTEBytesPerRow);\n\tdml_print(\"DML::%s: HostVMInefficiencyFactor = %f\\n\", __func__, HostVMInefficiencyFactor);\n\tdml_print(\"DML::%s: Tvm_trips = %f\\n\", __func__, Tvm_trips);\n\tdml_print(\"DML::%s: Tr0_trips = %f\\n\", __func__, Tr0_trips);\n\tdml_print(\"DML::%s: prefetch_bw_oto = %f\\n\", __func__, prefetch_bw_oto);\n\tdml_print(\"DML::%s: Tr0_oto = %f\\n\", __func__, Tr0_oto);\n\tdml_print(\"DML::%s: Tvm_oto = %f\\n\", __func__, Tvm_oto);\n\tdml_print(\"DML::%s: Tvm_oto_lines = %f\\n\", __func__, Tvm_oto_lines);\n\tdml_print(\"DML::%s: Tr0_oto_lines = %f\\n\", __func__, Tr0_oto_lines);\n\tdml_print(\"DML::%s: Lsw_oto = %f\\n\", __func__, Lsw_oto);\n\tdml_print(\"DML::%s: dst_y_prefetch_oto = %f\\n\", __func__, dst_y_prefetch_oto);\n\tdml_print(\"DML::%s: dst_y_prefetch_equ = %f\\n\", __func__, dst_y_prefetch_equ);\n#endif\n\n\tdst_y_prefetch_equ = dml_floor(4.0 * (dst_y_prefetch_equ + 0.125), 1) / 4.0;\n\tTpre_rounded = dst_y_prefetch_equ * LineTime;\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: dst_y_prefetch_equ: %f (after round)\\n\", __func__, dst_y_prefetch_equ);\n\tdml_print(\"DML::%s: LineTime: %f\\n\", __func__, LineTime);\n\tdml_print(\"DML::%s: VStartup: %d\\n\", __func__, VStartup);\n\tdml_print(\"DML::%s: Tvstartup: %fus - time between vstartup and first pixel of active\\n\",\n\t\t\t__func__, VStartup * LineTime);\n\tdml_print(\"DML::%s: TSetup: %fus - time from vstartup to vready\\n\", __func__, *TSetup);\n\tdml_print(\"DML::%s: TCalc: %fus - time for calculations in dchub starting at vready\\n\", __func__, TCalc);\n\tdml_print(\"DML::%s: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\", __func__, Tdmbf);\n\tdml_print(\"DML::%s: Tdmec: %fus - time dio takes to transfer dmd\\n\", __func__, Tdmec);\n\tdml_print(\"DML::%s: Tdmdl_vm: %fus - time for vm stages of dmd\\n\", __func__, *Tdmdl_vm);\n\tdml_print(\"DML::%s: Tdmdl: %fus - time for fabric to become ready and fetch dmd\\n\", __func__, *Tdmdl);\n\tdml_print(\"DML::%s: DSTYAfterScaler: %d lines - number of lines of pipeline and buffer delay after scaler\\n\",\n\t\t\t__func__, *DSTYAfterScaler);\n#endif\n\tdep_bytes = dml_max(PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor,\n\t\t\tMetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor);\n\n\tif (prefetch_sw_bytes < dep_bytes)\n\t\tprefetch_sw_bytes = 2 * dep_bytes;\n\n\t*PrefetchBandwidth = 0;\n\t*DestinationLinesToRequestVMInVBlank = 0;\n\t*DestinationLinesToRequestRowInVBlank = 0;\n\t*VRatioPrefetchY = 0;\n\t*VRatioPrefetchC = 0;\n\t*RequiredPrefetchPixDataBWLuma = 0;\n\tif (dst_y_prefetch_equ > 1 &&\n\t\t\t(Tpre_rounded >= TPreReq || dst_y_prefetch_equ == __DML_VBA_MAX_DST_Y_PRE__)) {\n\t\tdouble PrefetchBandwidth1;\n\t\tdouble PrefetchBandwidth2;\n\t\tdouble PrefetchBandwidth3;\n\t\tdouble PrefetchBandwidth4;\n\n\t\tif (Tpre_rounded - *Tno_bw > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte\n\t\t\t\t\t+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t\t+ prefetch_sw_bytes) / (Tpre_rounded - *Tno_bw);\n\t\t\tTsw_est1 = prefetch_sw_bytes / PrefetchBandwidth1;\n\t\t} else\n\t\t\tPrefetchBandwidth1 = 0;\n\n\t\tif (VStartup == MaxVStartup && (Tsw_est1 / LineTime < min_Lsw)\n\t\t\t\t&& Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte\n\t\t\t\t\t+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw);\n\t\t}\n\n\t\tif (Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded > 0)\n\t\t\tPrefetchBandwidth2 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + prefetch_sw_bytes) /\n\t\t\t(Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth2 = 0;\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t\t+ prefetch_sw_bytes) / (Tpre_rounded - Tvm_trips_rounded);\n\t\t\tTsw_est3 = prefetch_sw_bytes / PrefetchBandwidth3;\n\t\t} else\n\t\t\tPrefetchBandwidth3 = 0;\n\n\n\t\tif (VStartup == MaxVStartup &&\n\t\t\t\t(Tsw_est3 / LineTime < min_Lsw) && Tpre_rounded - min_Lsw * LineTime - 0.75 *\n\t\t\t\tLineTime - Tvm_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - Tvm_trips_rounded);\n\t\t}\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth4 = prefetch_sw_bytes /\n\t\t\t\t\t(Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded);\n\t\t} else {\n\t\t\tPrefetchBandwidth4 = 0;\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: Tpre_rounded: %f\\n\", __func__, Tpre_rounded);\n\t\tdml_print(\"DML::%s: Tno_bw: %f\\n\", __func__, *Tno_bw);\n\t\tdml_print(\"DML::%s: Tvm_trips_rounded: %f\\n\", __func__, Tvm_trips_rounded);\n\t\tdml_print(\"DML::%s: Tsw_est1: %f\\n\", __func__, Tsw_est1);\n\t\tdml_print(\"DML::%s: Tsw_est3: %f\\n\", __func__, Tsw_est3);\n\t\tdml_print(\"DML::%s: PrefetchBandwidth1: %f\\n\", __func__, PrefetchBandwidth1);\n\t\tdml_print(\"DML::%s: PrefetchBandwidth2: %f\\n\", __func__, PrefetchBandwidth2);\n\t\tdml_print(\"DML::%s: PrefetchBandwidth3: %f\\n\", __func__, PrefetchBandwidth3);\n\t\tdml_print(\"DML::%s: PrefetchBandwidth4: %f\\n\", __func__, PrefetchBandwidth4);\n#endif\n\t\t{\n\t\t\tbool Case1OK;\n\t\t\tbool Case2OK;\n\t\t\tbool Case3OK;\n\n\t\t\tif (PrefetchBandwidth1 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth1\n\t\t\t\t\t\t>= Tvm_trips_rounded\n\t\t\t\t\t\t&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t\t\t\t/ PrefetchBandwidth1 >= Tr0_trips_rounded) {\n\t\t\t\t\tCase1OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase1OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase1OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth2 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth2\n\t\t\t\t\t\t>= Tvm_trips_rounded\n\t\t\t\t\t\t&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t\t/ PrefetchBandwidth2 < Tr0_trips_rounded) {\n\t\t\t\t\tCase2OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase2OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase2OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth3 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth3 <\n\t\t\t\t\t\tTvm_trips_rounded && (MetaRowByte + PixelPTEBytesPerRow *\n\t\t\t\t\t\t\t\tHostVMInefficiencyFactor) / PrefetchBandwidth3 >=\n\t\t\t\t\t\t\t\tTr0_trips_rounded) {\n\t\t\t\t\tCase3OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase3OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase3OK = false;\n\t\t\t}\n\n\t\t\tif (Case1OK)\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth1;\n\t\t\telse if (Case2OK)\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth2;\n\t\t\telse if (Case3OK)\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth3;\n\t\t\telse\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth4;\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: Case1OK: %d\\n\", __func__, Case1OK);\n\t\t\tdml_print(\"DML::%s: Case2OK: %d\\n\", __func__, Case2OK);\n\t\t\tdml_print(\"DML::%s: Case3OK: %d\\n\", __func__, Case3OK);\n\t\t\tdml_print(\"DML::%s: prefetch_bw_equ: %f\\n\", __func__, prefetch_bw_equ);\n#endif\n\n\t\t\tif (prefetch_bw_equ > 0) {\n\t\t\t\tif (v->GPUVMEnable == true) {\n\t\t\t\t\tTvm_equ = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame *\n\t\t\t\t\t\t\tHostVMInefficiencyFactor / prefetch_bw_equ,\n\t\t\t\t\t\t\tTvm_trips, LineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTvm_equ = LineTime / 4;\n\t\t\t\t}\n\n\t\t\t\tif ((v->GPUVMEnable == true || myPipe->DCCEnable == true)) {\n\t\t\t\t\tTr0_equ = dml_max4((MetaRowByte + PixelPTEBytesPerRow *\n\t\t\t\t\t\t\tHostVMInefficiencyFactor) / prefetch_bw_equ, Tr0_trips,\n\t\t\t\t\t\t\t(LineTime - Tvm_equ) / 2, LineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTr0_equ = (LineTime - Tvm_equ) / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTvm_equ = 0;\n\t\t\t\tTr0_equ = 0;\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML: prefetch_bw_equ equals 0! %s:%d\\n\", __FILE__, __LINE__);\n#endif\n\t\t\t}\n\t\t}\n\n\t\tif (dst_y_prefetch_oto < dst_y_prefetch_equ) {\n\t\t\tif (dst_y_prefetch_oto * LineTime < TPreReq) {\n\t\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_equ;\n\t\t\t} else {\n\t\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_oto;\n\t\t\t}\n\t\t\tTimeForFetchingMetaPTE = Tvm_oto;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_oto;\n\t\t\t*PrefetchBandwidth = prefetch_bw_oto;\n\t\t\t \n\t\t\tLinesForPrefetchBandwidth = dst_y_prefetch_oto;\n\t\t} else {\n\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_equ;\n\t\t\tTimeForFetchingMetaPTE = Tvm_equ;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_equ;\n\t\t\t*PrefetchBandwidth = prefetch_bw_equ;\n\t\t\t \n\t\t\tLinesForPrefetchBandwidth = dst_y_prefetch_equ;\n\t\t}\n\n\t\t*DestinationLinesToRequestVMInVBlank = dml_ceil(4.0 * TimeForFetchingMetaPTE / LineTime, 1.0) / 4.0;\n\n\t\t*DestinationLinesToRequestRowInVBlank =\n\t\t\t\tdml_ceil(4.0 * TimeForFetchingRowInVBlank / LineTime, 1.0) / 4.0;\n\n\t\tLinesToRequestPrefetchPixelData = LinesForPrefetchBandwidth -\n\t\t\t\t*DestinationLinesToRequestVMInVBlank - 2 * *DestinationLinesToRequestRowInVBlank;\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: DestinationLinesForPrefetch = %f\\n\", __func__, *DestinationLinesForPrefetch);\n\t\tdml_print(\"DML::%s: DestinationLinesToRequestVMInVBlank = %f\\n\",\n\t\t\t\t__func__, *DestinationLinesToRequestVMInVBlank);\n\t\tdml_print(\"DML::%s: TimeForFetchingRowInVBlank = %f\\n\", __func__, TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n\t\tdml_print(\"DML::%s: DestinationLinesToRequestRowInVBlank = %f\\n\",\n\t\t\t\t__func__, *DestinationLinesToRequestRowInVBlank);\n\t\tdml_print(\"DML::%s: PrefetchSourceLinesY = %f\\n\", __func__, PrefetchSourceLinesY);\n\t\tdml_print(\"DML::%s: LinesToRequestPrefetchPixelData = %f\\n\", __func__, LinesToRequestPrefetchPixelData);\n#endif\n\n\t\tif (LinesToRequestPrefetchPixelData >= 1 && prefetch_bw_equ > 0) {\n\t\t\t*VRatioPrefetchY = (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: VRatioPrefetchY = %f\\n\", __func__, *VRatioPrefetchY);\n\t\t\tdml_print(\"DML::%s: SwathHeightY = %d\\n\", __func__, SwathHeightY);\n\t\t\tdml_print(\"DML::%s: VInitPreFillY = %d\\n\", __func__, VInitPreFillY);\n#endif\n\t\t\tif ((SwathHeightY > 4) && (VInitPreFillY > 3)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchY =\n\t\t\t\t\t\t\tdml_max((double) PrefetchSourceLinesY /\n\t\t\t\t\t\t\t\t\tLinesToRequestPrefetchPixelData,\n\t\t\t\t\t\t\t\t\t(double) MaxNumSwathY * SwathHeightY /\n\t\t\t\t\t\t\t\t\t(LinesToRequestPrefetchPixelData -\n\t\t\t\t\t\t\t\t\t(VInitPreFillY - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\t*VRatioPrefetchY = 0;\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: VRatioPrefetchY = %f\\n\", __func__, *VRatioPrefetchY);\n\t\t\t\tdml_print(\"DML::%s: PrefetchSourceLinesY = %f\\n\", __func__, PrefetchSourceLinesY);\n\t\t\t\tdml_print(\"DML::%s: MaxNumSwathY = %d\\n\", __func__, MaxNumSwathY);\n#endif\n\t\t\t}\n\n\t\t\t*VRatioPrefetchC = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: VRatioPrefetchC = %f\\n\", __func__, *VRatioPrefetchC);\n\t\t\tdml_print(\"DML::%s: SwathHeightC = %d\\n\", __func__, SwathHeightC);\n\t\t\tdml_print(\"DML::%s: VInitPreFillC = %d\\n\", __func__, VInitPreFillC);\n#endif\n\t\t\tif ((SwathHeightC > 4)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchC =\n\t\t\t\t\t\tdml_max(*VRatioPrefetchC,\n\t\t\t\t\t\t\t(double) MaxNumSwathC * SwathHeightC /\n\t\t\t\t\t\t\t(LinesToRequestPrefetchPixelData -\n\t\t\t\t\t\t\t(VInitPreFillC - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\t*VRatioPrefetchC = 0;\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: VRatioPrefetchC = %f\\n\", __func__, *VRatioPrefetchC);\n\t\t\t\tdml_print(\"DML::%s: PrefetchSourceLinesC = %f\\n\", __func__, PrefetchSourceLinesC);\n\t\t\t\tdml_print(\"DML::%s: MaxNumSwathC = %d\\n\", __func__, MaxNumSwathC);\n#endif\n\t\t\t}\n\n\t\t\t*RequiredPrefetchPixDataBWLuma = (double) PrefetchSourceLinesY\n\t\t\t\t\t/ LinesToRequestPrefetchPixelData * myPipe->BytePerPixelY * swath_width_luma_ub\n\t\t\t\t\t/ LineTime;\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: BytePerPixelY = %d\\n\", __func__, myPipe->BytePerPixelY);\n\t\t\tdml_print(\"DML::%s: swath_width_luma_ub = %d\\n\", __func__, swath_width_luma_ub);\n\t\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n\t\t\tdml_print(\"DML::%s: RequiredPrefetchPixDataBWLuma = %f\\n\",\n\t\t\t\t\t__func__, *RequiredPrefetchPixDataBWLuma);\n#endif\n\t\t\t*RequiredPrefetchPixDataBWChroma = (double) PrefetchSourceLinesC /\n\t\t\t\t\tLinesToRequestPrefetchPixelData\n\t\t\t\t\t* myPipe->BytePerPixelC\n\t\t\t\t\t* swath_width_chroma_ub / LineTime;\n\t\t} else {\n\t\t\tMyError = true;\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML:%s: MyErr set. LinesToRequestPrefetchPixelData: %f, should be > 0\\n\",\n\t\t\t\t\t__func__, LinesToRequestPrefetchPixelData);\n#endif\n\t\t\t*VRatioPrefetchY = 0;\n\t\t\t*VRatioPrefetchC = 0;\n\t\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML: Tpre: %fus - sum of time to request meta pte, 2 x data pte + meta data, swaths\\n\",\n\t\t\t(double)LinesToRequestPrefetchPixelData * LineTime +\n\t\t\t2.0*TimeForFetchingRowInVBlank + TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML:  Tvm: %fus - time to fetch page tables for meta surface\\n\", TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML: To: %fus - time for propagation from scaler to optc\\n\",\n\t\t\t(*DSTYAfterScaler + ((double) (*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime);\n\t\tdml_print(\"DML: Tvstartup - TSetup - Tcalc - Twait - Tpre - To > 0\\n\");\n\t\tdml_print(\"DML: Tslack(pre): %fus - time left over in schedule\\n\", VStartup * LineTime -\n\t\t\tTimeForFetchingMetaPTE - 2*TimeForFetchingRowInVBlank - (*DSTYAfterScaler +\n\t\t\t((double) (*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime - TWait - TCalc - *TSetup);\n\t\tdml_print(\"DML: row_bytes = dpte_row_bytes (per_pipe) = PixelPTEBytesPerRow = : %d\\n\",\n\t\t\t\tPixelPTEBytesPerRow);\n#endif\n\t} else {\n\t\tMyError = true;\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: MyErr set, dst_y_prefetch_equ = %f (should be > 1)\\n\",\n\t\t\t\t__func__, dst_y_prefetch_equ);\n#endif\n\t}\n\n\t{\n\t\tdouble prefetch_vm_bw;\n\t\tdouble prefetch_row_bw;\n\n\t\tif (PDEAndMetaPTEBytesFrame == 0) {\n\t\t\tprefetch_vm_bw = 0;\n\t\t} else if (*DestinationLinesToRequestVMInVBlank > 0) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n\t\t\tdml_print(\"DML::%s: HostVMInefficiencyFactor = %f\\n\", __func__, HostVMInefficiencyFactor);\n\t\t\tdml_print(\"DML::%s: DestinationLinesToRequestVMInVBlank = %f\\n\",\n\t\t\t\t\t__func__, *DestinationLinesToRequestVMInVBlank);\n\t\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n#endif\n\t\t\tprefetch_vm_bw = PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor /\n\t\t\t\t\t(*DestinationLinesToRequestVMInVBlank * LineTime);\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: prefetch_vm_bw = %f\\n\", __func__, prefetch_vm_bw);\n#endif\n\t\t} else {\n\t\t\tprefetch_vm_bw = 0;\n\t\t\tMyError = true;\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: MyErr set. DestinationLinesToRequestVMInVBlank=%f (should be > 0)\\n\",\n\t\t\t\t\t__func__, *DestinationLinesToRequestVMInVBlank);\n#endif\n\t\t}\n\n\t\tif (MetaRowByte + PixelPTEBytesPerRow == 0) {\n\t\t\tprefetch_row_bw = 0;\n\t\t} else if (*DestinationLinesToRequestRowInVBlank > 0) {\n\t\t\tprefetch_row_bw = (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) /\n\t\t\t\t\t(*DestinationLinesToRequestRowInVBlank * LineTime);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: MetaRowByte = %d\\n\", __func__, MetaRowByte);\n\t\t\tdml_print(\"DML::%s: PixelPTEBytesPerRow = %d\\n\", __func__, PixelPTEBytesPerRow);\n\t\t\tdml_print(\"DML::%s: DestinationLinesToRequestRowInVBlank = %f\\n\",\n\t\t\t\t\t__func__, *DestinationLinesToRequestRowInVBlank);\n\t\t\tdml_print(\"DML::%s: prefetch_row_bw = %f\\n\", __func__, prefetch_row_bw);\n#endif\n\t\t} else {\n\t\t\tprefetch_row_bw = 0;\n\t\t\tMyError = true;\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: MyErr set. DestinationLinesToRequestRowInVBlank=%f (should be > 0)\\n\",\n\t\t\t\t\t__func__, *DestinationLinesToRequestRowInVBlank);\n#endif\n\t\t}\n\n\t\t*prefetch_vmrow_bw = dml_max(prefetch_vm_bw, prefetch_row_bw);\n\t}\n\n\tif (MyError) {\n\t\t*PrefetchBandwidth = 0;\n\t\tTimeForFetchingMetaPTE = 0;\n\t\tTimeForFetchingRowInVBlank = 0;\n\t\t*DestinationLinesToRequestVMInVBlank = 0;\n\t\t*DestinationLinesToRequestRowInVBlank = 0;\n\t\t*DestinationLinesForPrefetch = 0;\n\t\tLinesToRequestPrefetchPixelData = 0;\n\t\t*VRatioPrefetchY = 0;\n\t\t*VRatioPrefetchC = 0;\n\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t}\n\n\treturn MyError;\n} \n\nvoid dml32_CalculateFlipSchedule(\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tdouble HostVMMinPageSize,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow,\n\t\tdouble BandwidthAvailableForImmediateFlip,\n\t\tunsigned int TotImmediateFlipBytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble LineTime,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tdouble Tno_bw,\n\t\tbool DCCEnable,\n\t\tunsigned int dpte_row_height,\n\t\tunsigned int meta_row_height,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tbool    use_one_row_for_frame_flip,\n\n\t\t \n\t\tdouble *DestinationLinesToRequestVMInImmediateFlip,\n\t\tdouble *DestinationLinesToRequestRowInImmediateFlip,\n\t\tdouble *final_flip_bw,\n\t\tbool *ImmediateFlipSupportedForPipe)\n{\n\tdouble min_row_time = 0.0;\n\tunsigned int HostVMDynamicLevelsTrips;\n\tdouble TimeForFetchingMetaPTEImmediateFlip;\n\tdouble TimeForFetchingRowInVBlankImmediateFlip;\n\tdouble ImmediateFlipBW = 1.0;\n\n\tif (GPUVMEnable == true && HostVMEnable == true)\n\t\tHostVMDynamicLevelsTrips = HostVMMaxNonCachedPageTableLevels;\n\telse\n\t\tHostVMDynamicLevelsTrips = 0;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: TotImmediateFlipBytes = %d\\n\", __func__, TotImmediateFlipBytes);\n\tdml_print(\"DML::%s: BandwidthAvailableForImmediateFlip = %f\\n\", __func__, BandwidthAvailableForImmediateFlip);\n#endif\n\n\tif (TotImmediateFlipBytes > 0) {\n\t\tif (use_one_row_for_frame_flip) {\n\t\t\tImmediateFlipBW = (PDEAndMetaPTEBytesPerFrame + MetaRowBytes + 2 * DPTEBytesPerRow) *\n\t\t\t\t\tBandwidthAvailableForImmediateFlip / TotImmediateFlipBytes;\n\t\t} else {\n\t\t\tImmediateFlipBW = (PDEAndMetaPTEBytesPerFrame + MetaRowBytes + DPTEBytesPerRow) *\n\t\t\t\t\tBandwidthAvailableForImmediateFlip / TotImmediateFlipBytes;\n\t\t}\n\t\tif (GPUVMEnable == true) {\n\t\t\tTimeForFetchingMetaPTEImmediateFlip = dml_max3(Tno_bw + PDEAndMetaPTEBytesPerFrame *\n\t\t\t\t\tHostVMInefficiencyFactor / ImmediateFlipBW,\n\t\t\t\t\tUrgentExtraLatency + UrgentLatency *\n\t\t\t\t\t(GPUVMMaxPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1),\n\t\t\t\t\tLineTime / 4.0);\n\t\t} else {\n\t\t\tTimeForFetchingMetaPTEImmediateFlip = 0;\n\t\t}\n\t\tif ((GPUVMEnable == true || DCCEnable == true)) {\n\t\t\tTimeForFetchingRowInVBlankImmediateFlip = dml_max3(\n\t\t\t\t\t(MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / ImmediateFlipBW,\n\t\t\t\t\tUrgentLatency * (HostVMDynamicLevelsTrips + 1), LineTime / 4.0);\n\t\t} else {\n\t\t\tTimeForFetchingRowInVBlankImmediateFlip = 0;\n\t\t}\n\n\t\t*DestinationLinesToRequestVMInImmediateFlip =\n\t\t\t\tdml_ceil(4.0 * (TimeForFetchingMetaPTEImmediateFlip / LineTime), 1.0) / 4.0;\n\t\t*DestinationLinesToRequestRowInImmediateFlip =\n\t\t\t\tdml_ceil(4.0 * (TimeForFetchingRowInVBlankImmediateFlip / LineTime), 1.0) / 4.0;\n\n\t\tif (GPUVMEnable == true) {\n\t\t\t*final_flip_bw = dml_max(PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor /\n\t\t\t\t\t(*DestinationLinesToRequestVMInImmediateFlip * LineTime),\n\t\t\t\t\t(MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) /\n\t\t\t\t\t(*DestinationLinesToRequestRowInImmediateFlip * LineTime));\n\t\t} else if ((GPUVMEnable == true || DCCEnable == true)) {\n\t\t\t*final_flip_bw = (MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) /\n\t\t\t\t\t(*DestinationLinesToRequestRowInImmediateFlip * LineTime);\n\t\t} else {\n\t\t\t*final_flip_bw = 0;\n\t\t}\n\t} else {\n\t\tTimeForFetchingMetaPTEImmediateFlip = 0;\n\t\tTimeForFetchingRowInVBlankImmediateFlip = 0;\n\t\t*DestinationLinesToRequestVMInImmediateFlip = 0;\n\t\t*DestinationLinesToRequestRowInImmediateFlip = 0;\n\t\t*final_flip_bw = 0;\n\t}\n\n\tif (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dml_min(dpte_row_height *\n\t\t\t\t\tLineTime / VRatio, dpte_row_height_chroma * LineTime / VRatioChroma);\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = dml_min(meta_row_height *\n\t\t\t\t\tLineTime / VRatio, meta_row_height_chroma * LineTime / VRatioChroma);\n\t\t} else {\n\t\t\tmin_row_time = dml_min4(dpte_row_height * LineTime / VRatio, meta_row_height *\n\t\t\t\t\tLineTime / VRatio, dpte_row_height_chroma * LineTime /\n\t\t\t\t\tVRatioChroma, meta_row_height_chroma * LineTime / VRatioChroma);\n\t\t}\n\t} else {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dpte_row_height * LineTime / VRatio;\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = meta_row_height * LineTime / VRatio;\n\t\t} else {\n\t\t\tmin_row_time =\n\t\t\t\tdml_min(dpte_row_height * LineTime / VRatio, meta_row_height * LineTime / VRatio);\n\t\t}\n\t}\n\n\tif (*DestinationLinesToRequestVMInImmediateFlip >= 32 || *DestinationLinesToRequestRowInImmediateFlip >= 16\n\t\t\t|| TimeForFetchingMetaPTEImmediateFlip + 2 * TimeForFetchingRowInVBlankImmediateFlip\n\t\t\t\t\t> min_row_time) {\n\t\t*ImmediateFlipSupportedForPipe = false;\n\t} else {\n\t\t*ImmediateFlipSupportedForPipe = true;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: GPUVMEnable = %d\\n\", __func__, GPUVMEnable);\n\tdml_print(\"DML::%s: DCCEnable = %d\\n\", __func__, DCCEnable);\n\tdml_print(\"DML::%s: DestinationLinesToRequestVMInImmediateFlip = %f\\n\",\n\t\t\t__func__, *DestinationLinesToRequestVMInImmediateFlip);\n\tdml_print(\"DML::%s: DestinationLinesToRequestRowInImmediateFlip = %f\\n\",\n\t\t\t__func__, *DestinationLinesToRequestRowInImmediateFlip);\n\tdml_print(\"DML::%s: TimeForFetchingMetaPTEImmediateFlip = %f\\n\", __func__, TimeForFetchingMetaPTEImmediateFlip);\n\tdml_print(\"DML::%s: TimeForFetchingRowInVBlankImmediateFlip = %f\\n\",\n\t\t\t__func__, TimeForFetchingRowInVBlankImmediateFlip);\n\tdml_print(\"DML::%s: min_row_time = %f\\n\", __func__, min_row_time);\n\tdml_print(\"DML::%s: ImmediateFlipSupportedForPipe = %d\\n\", __func__, *ImmediateFlipSupportedForPipe);\n#endif\n} \n\nvoid dml32_CalculateWatermarksMALLUseAndDRAMSpeedChangeSupport(\n\t\tstruct vba_vars_st *v,\n\t\tunsigned int PrefetchMode,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tSOCParametersList mmSOCParameters,\n\t\tdouble SOCCLK,\n\t\tdouble DCFClkDeepSleep,\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerSurface[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tdouble DSTXAfterScaler[],\n\t\tdouble DSTYAfterScaler[],\n\t\tbool UnboundedRequestEnabled,\n\t\tunsigned int CompressedBufferSizeInkByte,\n\n\t\t \n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble MaxActiveDRAMClockChangeLatencySupported[],\n\t\tunsigned int SubViewportLinesNeededInMALL[],\n\t\tenum dm_fclock_change_support *FCLKChangeSupport,\n\t\tdouble *MinActiveFCLKChangeLatencySupported,\n\t\tbool *USRRetrainingSupport,\n\t\tdouble ActiveDRAMClockChangeLatencyMargin[])\n{\n\tunsigned int i, j, k;\n\tunsigned int SurfaceWithMinActiveFCLKChangeMargin = 0;\n\tunsigned int DRAMClockChangeSupportNumber = 0;\n\tunsigned int LastSurfaceWithoutMargin;\n\tunsigned int DRAMClockChangeMethod = 0;\n\tbool FoundFirstSurfaceWithMinActiveFCLKChangeMargin = false;\n\tdouble MinActiveFCLKChangeMargin = 0.;\n\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;\n\tdouble ActiveClockChangeLatencyHidingY;\n\tdouble ActiveClockChangeLatencyHidingC;\n\tdouble ActiveClockChangeLatencyHiding;\n\tdouble EffectiveDETBufferSizeY;\n\tdouble     ActiveFCLKChangeLatencyMargin[DC__NUM_DPP__MAX];\n\tdouble     USRRetrainingLatencyMargin[DC__NUM_DPP__MAX];\n\tdouble TotalPixelBW = 0.0;\n\tbool    SynchronizedSurfaces[DC__NUM_DPP__MAX][DC__NUM_DPP__MAX];\n\tdouble     EffectiveLBLatencyHidingY;\n\tdouble     EffectiveLBLatencyHidingC;\n\tdouble     LinesInDETY[DC__NUM_DPP__MAX];\n\tdouble     LinesInDETC[DC__NUM_DPP__MAX];\n\tunsigned int    LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];\n\tunsigned int    LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];\n\tdouble     FullDETBufferingTimeY;\n\tdouble     FullDETBufferingTimeC;\n\tdouble     WritebackDRAMClockChangeLatencyMargin;\n\tdouble     WritebackFCLKChangeLatencyMargin;\n\tdouble     WritebackLatencyHiding;\n\tbool    SameTimingForFCLKChange;\n\n\tunsigned int    TotalActiveWriteback = 0;\n\tunsigned int LBLatencyHidingSourceLinesY[DC__NUM_DPP__MAX];\n\tunsigned int LBLatencyHidingSourceLinesC[DC__NUM_DPP__MAX];\n\n\tv->Watermark.UrgentWatermark = mmSOCParameters.UrgentLatency + mmSOCParameters.ExtraLatency;\n\tv->Watermark.USRRetrainingWatermark = mmSOCParameters.UrgentLatency + mmSOCParameters.ExtraLatency\n\t\t\t+ mmSOCParameters.USRRetrainingLatency + mmSOCParameters.SMNLatency;\n\tv->Watermark.DRAMClockChangeWatermark = mmSOCParameters.DRAMClockChangeLatency + v->Watermark.UrgentWatermark;\n\tv->Watermark.FCLKChangeWatermark = mmSOCParameters.FCLKChangeLatency + v->Watermark.UrgentWatermark;\n\tv->Watermark.StutterExitWatermark = mmSOCParameters.SRExitTime + mmSOCParameters.ExtraLatency\n\t\t\t+ 10 / DCFClkDeepSleep;\n\tv->Watermark.StutterEnterPlusExitWatermark = mmSOCParameters.SREnterPlusExitTime + mmSOCParameters.ExtraLatency\n\t\t\t+ 10 / DCFClkDeepSleep;\n\tv->Watermark.Z8StutterExitWatermark = mmSOCParameters.SRExitZ8Time + mmSOCParameters.ExtraLatency\n\t\t\t+ 10 / DCFClkDeepSleep;\n\tv->Watermark.Z8StutterEnterPlusExitWatermark = mmSOCParameters.SREnterPlusExitZ8Time\n\t\t\t+ mmSOCParameters.ExtraLatency + 10 / DCFClkDeepSleep;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: UrgentLatency = %f\\n\", __func__, mmSOCParameters.UrgentLatency);\n\tdml_print(\"DML::%s: ExtraLatency = %f\\n\", __func__, mmSOCParameters.ExtraLatency);\n\tdml_print(\"DML::%s: DRAMClockChangeLatency = %f\\n\", __func__, mmSOCParameters.DRAMClockChangeLatency);\n\tdml_print(\"DML::%s: UrgentWatermark = %f\\n\", __func__, v->Watermark.UrgentWatermark);\n\tdml_print(\"DML::%s: USRRetrainingWatermark = %f\\n\", __func__, v->Watermark.USRRetrainingWatermark);\n\tdml_print(\"DML::%s: DRAMClockChangeWatermark = %f\\n\", __func__, v->Watermark.DRAMClockChangeWatermark);\n\tdml_print(\"DML::%s: FCLKChangeWatermark = %f\\n\", __func__, v->Watermark.FCLKChangeWatermark);\n\tdml_print(\"DML::%s: StutterExitWatermark = %f\\n\", __func__, v->Watermark.StutterExitWatermark);\n\tdml_print(\"DML::%s: StutterEnterPlusExitWatermark = %f\\n\", __func__, v->Watermark.StutterEnterPlusExitWatermark);\n\tdml_print(\"DML::%s: Z8StutterExitWatermark = %f\\n\", __func__, v->Watermark.Z8StutterExitWatermark);\n\tdml_print(\"DML::%s: Z8StutterEnterPlusExitWatermark = %f\\n\",\n\t\t\t__func__, v->Watermark.Z8StutterEnterPlusExitWatermark);\n#endif\n\n\n\tTotalActiveWriteback = 0;\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif (v->WritebackEnable[k] == true)\n\t\t\tTotalActiveWriteback = TotalActiveWriteback + 1;\n\t}\n\n\tif (TotalActiveWriteback <= 1) {\n\t\tv->Watermark.WritebackUrgentWatermark = mmSOCParameters.WritebackLatency;\n\t} else {\n\t\tv->Watermark.WritebackUrgentWatermark = mmSOCParameters.WritebackLatency\n\t\t\t\t+ v->WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\tif (v->USRRetrainingRequiredFinal)\n\t\tv->Watermark.WritebackDRAMClockChangeWatermark = v->Watermark.WritebackDRAMClockChangeWatermark\n\t\t\t\t+ mmSOCParameters.USRRetrainingLatency;\n\n\tif (TotalActiveWriteback <= 1) {\n\t\tv->Watermark.WritebackDRAMClockChangeWatermark = mmSOCParameters.DRAMClockChangeLatency\n\t\t\t\t+ mmSOCParameters.WritebackLatency;\n\t\tv->Watermark.WritebackFCLKChangeWatermark = mmSOCParameters.FCLKChangeLatency\n\t\t\t\t+ mmSOCParameters.WritebackLatency;\n\t} else {\n\t\tv->Watermark.WritebackDRAMClockChangeWatermark = mmSOCParameters.DRAMClockChangeLatency\n\t\t\t\t+ mmSOCParameters.WritebackLatency + v->WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t\tv->Watermark.WritebackFCLKChangeWatermark = mmSOCParameters.FCLKChangeLatency\n\t\t\t\t+ mmSOCParameters.WritebackLatency + v->WritebackChunkSize * 1024 / 32 / SOCCLK;\n\t}\n\n\tif (v->USRRetrainingRequiredFinal)\n\t\tv->Watermark.WritebackDRAMClockChangeWatermark = v->Watermark.WritebackDRAMClockChangeWatermark\n\t\t\t\t+ mmSOCParameters.USRRetrainingLatency;\n\n\tif (v->USRRetrainingRequiredFinal)\n\t\tv->Watermark.WritebackFCLKChangeWatermark = v->Watermark.WritebackFCLKChangeWatermark\n\t\t\t\t+ mmSOCParameters.USRRetrainingLatency;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: WritebackDRAMClockChangeWatermark = %f\\n\",\n\t\t\t__func__, v->Watermark.WritebackDRAMClockChangeWatermark);\n\tdml_print(\"DML::%s: WritebackFCLKChangeWatermark = %f\\n\", __func__, v->Watermark.WritebackFCLKChangeWatermark);\n\tdml_print(\"DML::%s: WritebackUrgentWatermark = %f\\n\", __func__, v->Watermark.WritebackUrgentWatermark);\n\tdml_print(\"DML::%s: v->USRRetrainingRequiredFinal = %d\\n\", __func__, v->USRRetrainingRequiredFinal);\n\tdml_print(\"DML::%s: USRRetrainingLatency = %f\\n\", __func__, mmSOCParameters.USRRetrainingLatency);\n#endif\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tTotalPixelBW = TotalPixelBW + DPPPerSurface[k] * (SwathWidthY[k] * BytePerPixelDETY[k] * v->VRatio[k] +\n\t\t\t\tSwathWidthC[k] * BytePerPixelDETC[k] * v->VRatioChroma[k]) / (v->HTotal[k] / v->PixelClock[k]);\n\t}\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\n\t\tLBLatencyHidingSourceLinesY[k] = dml_min((double) v->MaxLineBufferLines, dml_floor(v->LineBufferSizeFinal / v->LBBitPerPixel[k] / (SwathWidthY[k] / dml_max(v->HRatio[k], 1.0)), 1)) - (v->vtaps[k] - 1);\n\t\tLBLatencyHidingSourceLinesC[k] = dml_min((double) v->MaxLineBufferLines, dml_floor(v->LineBufferSizeFinal / v->LBBitPerPixel[k] / (SwathWidthC[k] / dml_max(v->HRatioChroma[k], 1.0)), 1)) - (v->VTAPsChroma[k] - 1);\n\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, v->MaxLineBufferLines = %d\\n\", __func__, k, v->MaxLineBufferLines);\n\t\tdml_print(\"DML::%s: k=%d, v->LineBufferSizeFinal     = %d\\n\", __func__, k, v->LineBufferSizeFinal);\n\t\tdml_print(\"DML::%s: k=%d, v->LBBitPerPixel      = %d\\n\", __func__, k, v->LBBitPerPixel[k]);\n\t\tdml_print(\"DML::%s: k=%d, v->HRatio             = %f\\n\", __func__, k, v->HRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d, v->vtaps              = %d\\n\", __func__, k, v->vtaps[k]);\n#endif\n\n\t\tEffectiveLBLatencyHidingY = LBLatencyHidingSourceLinesY[k] / v->VRatio[k] * (v->HTotal[k] / v->PixelClock[k]);\n\t\tEffectiveLBLatencyHidingC = LBLatencyHidingSourceLinesC[k] / v->VRatioChroma[k] * (v->HTotal[k] / v->PixelClock[k]);\n\t\tEffectiveDETBufferSizeY = DETBufferSizeY[k];\n\n\t\tif (UnboundedRequestEnabled) {\n\t\t\tEffectiveDETBufferSizeY = EffectiveDETBufferSizeY\n\t\t\t\t\t+ CompressedBufferSizeInkByte * 1024\n\t\t\t\t\t\t\t* (SwathWidthY[k] * BytePerPixelDETY[k] * v->VRatio[k])\n\t\t\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) / TotalPixelBW;\n\t\t}\n\n\t\tLinesInDETY[k] = (double) EffectiveDETBufferSizeY / BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath[k] = dml_floor(LinesInDETY[k], SwathHeightY[k]);\n\t\tFullDETBufferingTimeY = LinesInDETYRoundedDownToSwath[k] * (v->HTotal[k] / v->PixelClock[k]) / v->VRatio[k];\n\n\t\tActiveClockChangeLatencyHidingY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY\n\t\t\t\t- (DSTXAfterScaler[k] / v->HTotal[k] + DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k];\n\n\t\tif (v->NumberOfActiveSurfaces > 1) {\n\t\t\tActiveClockChangeLatencyHidingY = ActiveClockChangeLatencyHidingY\n\t\t\t\t\t- (1.0 - 1.0 / v->NumberOfActiveSurfaces) * SwathHeightY[k] * v->HTotal[k]\n\t\t\t\t\t\t\t/ v->PixelClock[k] / v->VRatio[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tLinesInDETC[k] = DETBufferSizeC[k] / BytePerPixelDETC[k] / SwathWidthC[k];\n\t\t\tLinesInDETCRoundedDownToSwath[k] = dml_floor(LinesInDETC[k], SwathHeightC[k]);\n\t\t\tFullDETBufferingTimeC = LinesInDETCRoundedDownToSwath[k] * (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t\t/ v->VRatioChroma[k];\n\t\t\tActiveClockChangeLatencyHidingC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC\n\t\t\t\t\t- (DSTXAfterScaler[k] / v->HTotal[k] + DSTYAfterScaler[k]) * v->HTotal[k]\n\t\t\t\t\t\t\t/ v->PixelClock[k];\n\t\t\tif (v->NumberOfActiveSurfaces > 1) {\n\t\t\t\tActiveClockChangeLatencyHidingC = ActiveClockChangeLatencyHidingC\n\t\t\t\t\t\t- (1 - 1 / v->NumberOfActiveSurfaces) * SwathHeightC[k] * v->HTotal[k]\n\t\t\t\t\t\t\t\t/ v->PixelClock[k] / v->VRatioChroma[k];\n\t\t\t}\n\t\t\tActiveClockChangeLatencyHiding = dml_min(ActiveClockChangeLatencyHidingY,\n\t\t\t\t\tActiveClockChangeLatencyHidingC);\n\t\t} else {\n\t\t\tActiveClockChangeLatencyHiding = ActiveClockChangeLatencyHidingY;\n\t\t}\n\n\t\tActiveDRAMClockChangeLatencyMargin[k] = ActiveClockChangeLatencyHiding - v->Watermark.UrgentWatermark\n\t\t\t\t- v->Watermark.DRAMClockChangeWatermark;\n\t\tActiveFCLKChangeLatencyMargin[k] = ActiveClockChangeLatencyHiding - v->Watermark.UrgentWatermark\n\t\t\t\t- v->Watermark.FCLKChangeWatermark;\n\t\tUSRRetrainingLatencyMargin[k] = ActiveClockChangeLatencyHiding - v->Watermark.USRRetrainingWatermark;\n\n\t\tif (v->WritebackEnable[k]) {\n\t\t\tWritebackLatencyHiding = v->WritebackInterfaceBufferSize * 1024\n\t\t\t\t\t/ (v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k]\n\t\t\t\t\t\t\t/ (v->WritebackSourceHeight[k] * v->HTotal[k] / v->PixelClock[k]) * 4);\n\t\t\tif (v->WritebackPixelFormat[k] == dm_444_64)\n\t\t\t\tWritebackLatencyHiding = WritebackLatencyHiding / 2;\n\n\t\t\tWritebackDRAMClockChangeLatencyMargin = WritebackLatencyHiding\n\t\t\t\t\t- v->Watermark.WritebackDRAMClockChangeWatermark;\n\n\t\t\tWritebackFCLKChangeLatencyMargin = WritebackLatencyHiding\n\t\t\t\t\t- v->Watermark.WritebackFCLKChangeWatermark;\n\n\t\t\tActiveDRAMClockChangeLatencyMargin[k] = dml_min(ActiveDRAMClockChangeLatencyMargin[k],\n\t\t\t\t\tWritebackFCLKChangeLatencyMargin);\n\t\t\tActiveFCLKChangeLatencyMargin[k] = dml_min(ActiveFCLKChangeLatencyMargin[k],\n\t\t\t\t\tWritebackDRAMClockChangeLatencyMargin);\n\t\t}\n\t\tMaxActiveDRAMClockChangeLatencySupported[k] =\n\t\t\t\t(v->UsesMALLForPStateChange[k] == dm_use_mall_pstate_change_phantom_pipe) ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\t(ActiveDRAMClockChangeLatencyMargin[k]\n\t\t\t\t\t\t\t\t+ mmSOCParameters.DRAMClockChangeLatency);\n\t}\n\n\tfor (i = 0; i < v->NumberOfActiveSurfaces; ++i) {\n\t\tfor (j = 0; j < v->NumberOfActiveSurfaces; ++j) {\n\t\t\tif (i == j ||\n\t\t\t\t\t(v->BlendingAndTiming[i] == i && v->BlendingAndTiming[j] == i) ||\n\t\t\t\t\t(v->BlendingAndTiming[j] == j && v->BlendingAndTiming[i] == j) ||\n\t\t\t\t\t(v->BlendingAndTiming[i] == v->BlendingAndTiming[j] && v->BlendingAndTiming[i] != i) ||\n\t\t\t\t\t(v->SynchronizeTimingsFinal && v->PixelClock[i] == v->PixelClock[j] &&\n\t\t\t\t\tv->HTotal[i] == v->HTotal[j] && v->VTotal[i] == v->VTotal[j] &&\n\t\t\t\t\tv->VActive[i] == v->VActive[j]) || (v->SynchronizeDRRDisplaysForUCLKPStateChangeFinal &&\n\t\t\t\t\t(v->DRRDisplay[i] || v->DRRDisplay[j]))) {\n\t\t\t\tSynchronizedSurfaces[i][j] = true;\n\t\t\t} else {\n\t\t\t\tSynchronizedSurfaces[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif ((v->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) &&\n\t\t\t\t(!FoundFirstSurfaceWithMinActiveFCLKChangeMargin ||\n\t\t\t\tActiveFCLKChangeLatencyMargin[k] < MinActiveFCLKChangeMargin)) {\n\t\t\tFoundFirstSurfaceWithMinActiveFCLKChangeMargin = true;\n\t\t\tMinActiveFCLKChangeMargin = ActiveFCLKChangeLatencyMargin[k];\n\t\t\tSurfaceWithMinActiveFCLKChangeMargin = k;\n\t\t}\n\t}\n\n\t*MinActiveFCLKChangeLatencySupported = MinActiveFCLKChangeMargin + mmSOCParameters.FCLKChangeLatency;\n\n\tSameTimingForFCLKChange = true;\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif (!SynchronizedSurfaces[k][SurfaceWithMinActiveFCLKChangeMargin]) {\n\t\t\tif ((v->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) &&\n\t\t\t\t\t(SameTimingForFCLKChange ||\n\t\t\t\t\tActiveFCLKChangeLatencyMargin[k] <\n\t\t\t\t\tSecondMinActiveFCLKChangeMarginOneDisplayInVBLank)) {\n\t\t\t\tSecondMinActiveFCLKChangeMarginOneDisplayInVBLank = ActiveFCLKChangeLatencyMargin[k];\n\t\t\t}\n\t\t\tSameTimingForFCLKChange = false;\n\t\t}\n\t}\n\n\tif (MinActiveFCLKChangeMargin > 0) {\n\t\t*FCLKChangeSupport = dm_fclock_change_vactive;\n\t} else if ((SameTimingForFCLKChange || SecondMinActiveFCLKChangeMarginOneDisplayInVBLank > 0) &&\n\t\t\t(PrefetchMode <= 1)) {\n\t\t*FCLKChangeSupport = dm_fclock_change_vblank;\n\t} else {\n\t\t*FCLKChangeSupport = dm_fclock_change_unsupported;\n\t}\n\n\t*USRRetrainingSupport = true;\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif ((v->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) &&\n\t\t\t\t(USRRetrainingLatencyMargin[k] < 0)) {\n\t\t\t*USRRetrainingSupport = false;\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif (v->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_full_frame &&\n\t\t\t\tv->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_sub_viewport &&\n\t\t\t\tv->UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe &&\n\t\t\t\tActiveDRAMClockChangeLatencyMargin[k] < 0) {\n\t\t\tif (PrefetchMode > 0) {\n\t\t\t\tDRAMClockChangeSupportNumber = 2;\n\t\t\t} else if (DRAMClockChangeSupportNumber == 0) {\n\t\t\t\tDRAMClockChangeSupportNumber = 1;\n\t\t\t\tLastSurfaceWithoutMargin = k;\n\t\t\t} else if (DRAMClockChangeSupportNumber == 1 &&\n\t\t\t\t\t!SynchronizedSurfaces[LastSurfaceWithoutMargin][k]) {\n\t\t\t\tDRAMClockChangeSupportNumber = 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tif (v->UsesMALLForPStateChange[k] == dm_use_mall_pstate_change_full_frame)\n\t\t\tDRAMClockChangeMethod = 1;\n\t\telse if (v->UsesMALLForPStateChange[k] == dm_use_mall_pstate_change_sub_viewport)\n\t\t\tDRAMClockChangeMethod = 2;\n\t}\n\n\tif (DRAMClockChangeMethod == 0) {\n\t\tif (DRAMClockChangeSupportNumber == 0)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive;\n\t\telse if (DRAMClockChangeSupportNumber == 1)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank;\n\t\telse\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t} else if (DRAMClockChangeMethod == 1) {\n\t\tif (DRAMClockChangeSupportNumber == 0)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive_w_mall_full_frame;\n\t\telse if (DRAMClockChangeSupportNumber == 1)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank_w_mall_full_frame;\n\t\telse\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t} else {\n\t\tif (DRAMClockChangeSupportNumber == 0)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive_w_mall_sub_vp;\n\t\telse if (DRAMClockChangeSupportNumber == 1)\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank_w_mall_sub_vp;\n\t\telse\n\t\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t}\n\n\tfor (k = 0; k < v->NumberOfActiveSurfaces; ++k) {\n\t\tunsigned int dst_y_pstate;\n\t\tunsigned int src_y_pstate_l;\n\t\tunsigned int src_y_pstate_c;\n\t\tunsigned int src_y_ahead_l, src_y_ahead_c, sub_vp_lines_l, sub_vp_lines_c;\n\n\t\tdst_y_pstate = dml_ceil((mmSOCParameters.DRAMClockChangeLatency + mmSOCParameters.UrgentLatency) / (v->HTotal[k] / v->PixelClock[k]), 1);\n\t\tsrc_y_pstate_l = dml_ceil(dst_y_pstate * v->VRatio[k], SwathHeightY[k]);\n\t\tsrc_y_ahead_l = dml_floor(DETBufferSizeY[k] / BytePerPixelDETY[k] / SwathWidthY[k], SwathHeightY[k]) + LBLatencyHidingSourceLinesY[k];\n\t\tsub_vp_lines_l = src_y_pstate_l + src_y_ahead_l + v->meta_row_height[k];\n\n#ifdef __DML_VBA_DEBUG__\ndml_print(\"DML::%s: k=%d, DETBufferSizeY               = %d\\n\", __func__, k, DETBufferSizeY[k]);\ndml_print(\"DML::%s: k=%d, BytePerPixelDETY             = %f\\n\", __func__, k, BytePerPixelDETY[k]);\ndml_print(\"DML::%s: k=%d, SwathWidthY                  = %d\\n\", __func__, k, SwathWidthY[k]);\ndml_print(\"DML::%s: k=%d, SwathHeightY                 = %d\\n\", __func__, k, SwathHeightY[k]);\ndml_print(\"DML::%s: k=%d, LBLatencyHidingSourceLinesY  = %d\\n\", __func__, k, LBLatencyHidingSourceLinesY[k]);\ndml_print(\"DML::%s: k=%d, dst_y_pstate      = %d\\n\", __func__, k, dst_y_pstate);\ndml_print(\"DML::%s: k=%d, src_y_pstate_l    = %d\\n\", __func__, k, src_y_pstate_l);\ndml_print(\"DML::%s: k=%d, src_y_ahead_l     = %d\\n\", __func__, k, src_y_ahead_l);\ndml_print(\"DML::%s: k=%d, v->meta_row_height   = %d\\n\", __func__, k, v->meta_row_height[k]);\ndml_print(\"DML::%s: k=%d, sub_vp_lines_l    = %d\\n\", __func__, k, sub_vp_lines_l);\n#endif\n\t\tSubViewportLinesNeededInMALL[k] = sub_vp_lines_l;\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tsrc_y_pstate_c = dml_ceil(dst_y_pstate * v->VRatioChroma[k], SwathHeightC[k]);\n\t\t\tsrc_y_ahead_c = dml_floor(DETBufferSizeC[k] / BytePerPixelDETC[k] / SwathWidthC[k], SwathHeightC[k]) + LBLatencyHidingSourceLinesC[k];\n\t\t\tsub_vp_lines_c = src_y_pstate_c + src_y_ahead_c + v->meta_row_height_chroma[k];\n\t\t\tSubViewportLinesNeededInMALL[k] = dml_max(sub_vp_lines_l, sub_vp_lines_c);\n\n#ifdef __DML_VBA_DEBUG__\ndml_print(\"DML::%s: k=%d, src_y_pstate_c            = %d\\n\", __func__, k, src_y_pstate_c);\ndml_print(\"DML::%s: k=%d, src_y_ahead_c             = %d\\n\", __func__, k, src_y_ahead_c);\ndml_print(\"DML::%s: k=%d, v->meta_row_height_chroma    = %d\\n\", __func__, k, v->meta_row_height_chroma[k]);\ndml_print(\"DML::%s: k=%d, sub_vp_lines_c            = %d\\n\", __func__, k, sub_vp_lines_c);\n#endif\n\t\t}\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DRAMClockChangeSupport = %d\\n\", __func__, *DRAMClockChangeSupport);\n\tdml_print(\"DML::%s: FCLKChangeSupport = %d\\n\", __func__, *FCLKChangeSupport);\n\tdml_print(\"DML::%s: MinActiveFCLKChangeLatencySupported = %f\\n\",\n\t\t\t__func__, *MinActiveFCLKChangeLatencySupported);\n\tdml_print(\"DML::%s: USRRetrainingSupport = %d\\n\", __func__, *USRRetrainingSupport);\n#endif\n} \n\ndouble dml32_CalculateWriteBackDISPCLK(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble PixelClock,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackHTaps,\n\t\tunsigned int WritebackVTaps,\n\t\tunsigned int   WritebackSourceWidth,\n\t\tunsigned int   WritebackDestinationWidth,\n\t\tunsigned int HTotal,\n\t\tunsigned int WritebackLineBufferSize,\n\t\tdouble DISPCLKDPPCLKVCOSpeed)\n{\n\tdouble DISPCLK_H, DISPCLK_V, DISPCLK_HB;\n\n\tDISPCLK_H = PixelClock * dml_ceil(WritebackHTaps / 8.0, 1) / WritebackHRatio;\n\tDISPCLK_V = PixelClock * (WritebackVTaps * dml_ceil(WritebackDestinationWidth / 6.0, 1) + 8.0) / HTotal;\n\tDISPCLK_HB = PixelClock * WritebackVTaps * (WritebackDestinationWidth *\n\t\t\tWritebackVTaps - WritebackLineBufferSize / 57.0) / 6.0 / WritebackSourceWidth;\n\treturn dml32_RoundToDFSGranularity(dml_max3(DISPCLK_H, DISPCLK_V, DISPCLK_HB), 1, DISPCLKDPPCLKVCOSpeed);\n}\n\nvoid dml32_CalculateMinAndMaxPrefetchMode(\n\t\tenum dm_prefetch_modes   AllowForPStateChangeOrStutterInVBlankFinal,\n\t\tunsigned int             *MinPrefetchMode,\n\t\tunsigned int             *MaxPrefetchMode)\n{\n\tif (AllowForPStateChangeOrStutterInVBlankFinal == dm_prefetch_support_none) {\n\t\t*MinPrefetchMode = 3;\n\t\t*MaxPrefetchMode = 3;\n\t} else if (AllowForPStateChangeOrStutterInVBlankFinal == dm_prefetch_support_stutter) {\n\t\t*MinPrefetchMode = 2;\n\t\t*MaxPrefetchMode = 2;\n\t} else if (AllowForPStateChangeOrStutterInVBlankFinal == dm_prefetch_support_fclk_and_stutter) {\n\t\t*MinPrefetchMode = 1;\n\t\t*MaxPrefetchMode = 1;\n\t} else if (AllowForPStateChangeOrStutterInVBlankFinal == dm_prefetch_support_uclk_fclk_and_stutter) {\n\t\t*MinPrefetchMode = 0;\n\t\t*MaxPrefetchMode = 0;\n\t} else if (AllowForPStateChangeOrStutterInVBlankFinal ==\n\t\t\tdm_prefetch_support_uclk_fclk_and_stutter_if_possible) {\n\t\t*MinPrefetchMode = 0;\n\t\t*MaxPrefetchMode = 3;\n\t} else {\n\t\t*MinPrefetchMode = 0;\n\t\t*MaxPrefetchMode = 3;\n\t}\n} \n\nvoid dml32_CalculatePixelDeliveryTimes(\n\t\tunsigned int             NumberOfActiveSurfaces,\n\t\tdouble              VRatio[],\n\t\tdouble              VRatioChroma[],\n\t\tdouble              VRatioPrefetchY[],\n\t\tdouble              VRatioPrefetchC[],\n\t\tunsigned int             swath_width_luma_ub[],\n\t\tunsigned int             swath_width_chroma_ub[],\n\t\tunsigned int             DPPPerSurface[],\n\t\tdouble              HRatio[],\n\t\tdouble              HRatioChroma[],\n\t\tdouble              PixelClock[],\n\t\tdouble              PSCL_THROUGHPUT[],\n\t\tdouble              PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble              Dppclk[],\n\t\tunsigned int             BytePerPixelC[],\n\t\tenum dm_rotation_angle   SourceRotation[],\n\t\tunsigned int             NumberOfCursors[],\n\t\tunsigned int             CursorWidth[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int             CursorBPP[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int             BlockWidth256BytesY[],\n\t\tunsigned int             BlockHeight256BytesY[],\n\t\tunsigned int             BlockWidth256BytesC[],\n\t\tunsigned int             BlockHeight256BytesC[],\n\n\t\t \n\t\tdouble              DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble              DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble              DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble              DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble              DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble              DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble              DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble              DisplayPipeRequestDeliveryTimeChromaPrefetch[],\n\t\tdouble              CursorRequestDeliveryTime[],\n\t\tdouble              CursorRequestDeliveryTimePrefetch[])\n{\n\tdouble   req_per_swath_ub;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : HRatio = %f\\n\", __func__, k, HRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d : VRatio = %f\\n\", __func__, k, VRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d : HRatioChroma = %f\\n\", __func__, k, HRatioChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : VRatioChroma = %f\\n\", __func__, k, VRatioChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : swath_width_luma_ub = %d\\n\", __func__, k, swath_width_luma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d : swath_width_chroma_ub = %d\\n\", __func__, k, swath_width_chroma_ub[k]);\n\t\tdml_print(\"DML::%s: k=%d : PSCL_THROUGHPUT = %f\\n\", __func__, k, PSCL_THROUGHPUT[k]);\n\t\tdml_print(\"DML::%s: k=%d : PSCL_THROUGHPUT_CHROMA = %f\\n\", __func__, k, PSCL_THROUGHPUT_CHROMA[k]);\n\t\tdml_print(\"DML::%s: k=%d : DPPPerSurface = %d\\n\", __func__, k, DPPPerSurface[k]);\n\t\tdml_print(\"DML::%s: k=%d : PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n\t\tdml_print(\"DML::%s: k=%d : Dppclk = %f\\n\", __func__, k, Dppclk[k]);\n#endif\n\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] =\n\t\t\t\t\tswath_width_luma_ub[k] * DPPPerSurface[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / Dppclk[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] =\n\t\t\t\t\tswath_width_chroma_ub[k] * DPPPerSurface[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] =\n\t\t\t\t\tswath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / Dppclk[k];\n\t\t\t}\n\t\t}\n\n\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] =\n\t\t\t\t\tswath_width_luma_ub[k] * DPPPerSurface[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] =\n\t\t\t\t\tswath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / Dppclk[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioPrefetchC[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = swath_width_chroma_ub[k] *\n\t\t\t\t\t\tDPPPerSurface[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] =\n\t\t\t\t\t\tswath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / Dppclk[k];\n\t\t\t}\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeLuma = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeLineDeliveryTimeLuma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeLumaPrefetch = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeLineDeliveryTimeLumaPrefetch[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeChroma = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeLineDeliveryTimeChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeChromaPrefetch = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeLineDeliveryTimeChromaPrefetch[k]);\n#endif\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (!IsVertical(SourceRotation[k]))\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockWidth256BytesY[k];\n\t\telse\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockHeight256BytesY[k];\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : req_per_swath_ub = %f (Luma)\\n\", __func__, k, req_per_swath_ub);\n#endif\n\n\t\tDisplayPipeRequestDeliveryTimeLuma[k] = DisplayPipeLineDeliveryTimeLuma[k] / req_per_swath_ub;\n\t\tDisplayPipeRequestDeliveryTimeLumaPrefetch[k] =\n\t\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] / req_per_swath_ub;\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = 0;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (!IsVertical(SourceRotation[k]))\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockWidth256BytesC[k];\n\t\t\telse\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockHeight256BytesC[k];\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%d : req_per_swath_ub = %f (Chroma)\\n\", __func__, k, req_per_swath_ub);\n#endif\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] =\n\t\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] / req_per_swath_ub;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] =\n\t\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] / req_per_swath_ub;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeLuma = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeRequestDeliveryTimeLuma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeLumaPrefetch = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeRequestDeliveryTimeLumaPrefetch[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeChroma = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeRequestDeliveryTimeChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeChromaPrefetch = %f\\n\",\n\t\t\t\t__func__, k, DisplayPipeRequestDeliveryTimeChromaPrefetch[k]);\n#endif\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tunsigned int cursor_req_per_width;\n\n\t\tcursor_req_per_width = dml_ceil((double) CursorWidth[k][0] * (double) CursorBPP[k][0] /\n\t\t\t\t256.0 / 8.0, 1.0);\n\t\tif (NumberOfCursors[k] > 0) {\n\t\t\tif (VRatio[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTime[k] = (double) CursorWidth[k][0] /\n\t\t\t\t\t\tHRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTime[k] = (double) CursorWidth[k][0] /\n\t\t\t\t\t\tPSCL_THROUGHPUT[k] / Dppclk[k] / cursor_req_per_width;\n\t\t\t}\n\t\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = (double) CursorWidth[k][0] /\n\t\t\t\t\t\tHRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = (double) CursorWidth[k][0] /\n\t\t\t\t\t\tPSCL_THROUGHPUT[k] / Dppclk[k] / cursor_req_per_width;\n\t\t\t}\n\t\t} else {\n\t\t\tCursorRequestDeliveryTime[k] = 0;\n\t\t\tCursorRequestDeliveryTimePrefetch[k] = 0;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : NumberOfCursors = %d\\n\",\n\t\t\t\t__func__, k, NumberOfCursors[k]);\n\t\tdml_print(\"DML::%s: k=%d : CursorRequestDeliveryTime = %f\\n\",\n\t\t\t\t__func__, k, CursorRequestDeliveryTime[k]);\n\t\tdml_print(\"DML::%s: k=%d : CursorRequestDeliveryTimePrefetch = %f\\n\",\n\t\t\t\t__func__, k, CursorRequestDeliveryTimePrefetch[k]);\n#endif\n\t}\n} \n\nvoid dml32_CalculateMetaAndPTETimes(\n\t\tbool use_one_row_for_frame[],\n\t\tunsigned int NumberOfActiveSurfaces,\n\t\tbool GPUVMEnable,\n\t\tunsigned int MetaChunkSize,\n\t\tunsigned int MinMetaChunkSizeBytes,\n\t\tunsigned int    HTotal[],\n\t\tdouble  VRatio[],\n\t\tdouble  VRatioChroma[],\n\t\tdouble  DestinationLinesToRequestRowInVBlank[],\n\t\tdouble  DestinationLinesToRequestRowInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble  PixelClock[],\n\t\tunsigned int BytePerPixelY[],\n\t\tunsigned int BytePerPixelC[],\n\t\tenum dm_rotation_angle SourceRotation[],\n\t\tunsigned int dpte_row_height[],\n\t\tunsigned int dpte_row_height_chroma[],\n\t\tunsigned int meta_row_width[],\n\t\tunsigned int meta_row_width_chroma[],\n\t\tunsigned int meta_row_height[],\n\t\tunsigned int meta_row_height_chroma[],\n\t\tunsigned int meta_req_width[],\n\t\tunsigned int meta_req_width_chroma[],\n\t\tunsigned int meta_req_height[],\n\t\tunsigned int meta_req_height_chroma[],\n\t\tunsigned int dpte_group_bytes[],\n\t\tunsigned int    PTERequestSizeY[],\n\t\tunsigned int    PTERequestSizeC[],\n\t\tunsigned int    PixelPTEReqWidthY[],\n\t\tunsigned int    PixelPTEReqHeightY[],\n\t\tunsigned int    PixelPTEReqWidthC[],\n\t\tunsigned int    PixelPTEReqHeightC[],\n\t\tunsigned int    dpte_row_width_luma_ub[],\n\t\tunsigned int    dpte_row_width_chroma_ub[],\n\n\t\t \n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_C[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerChromaMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerChromaMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble TimePerChromaMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[])\n{\n\tunsigned int   meta_chunk_width;\n\tunsigned int   min_meta_chunk_width;\n\tunsigned int   meta_chunk_per_row_int;\n\tunsigned int   meta_row_remainder;\n\tunsigned int   meta_chunk_threshold;\n\tunsigned int   meta_chunks_per_row_ub;\n\tunsigned int   meta_chunk_width_chroma;\n\tunsigned int   min_meta_chunk_width_chroma;\n\tunsigned int   meta_chunk_per_row_int_chroma;\n\tunsigned int   meta_row_remainder_chroma;\n\tunsigned int   meta_chunk_threshold_chroma;\n\tunsigned int   meta_chunks_per_row_ub_chroma;\n\tunsigned int   dpte_group_width_luma;\n\tunsigned int   dpte_groups_per_row_luma_ub;\n\tunsigned int   dpte_group_width_chroma;\n\tunsigned int   dpte_groups_per_row_chroma_ub;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tDST_Y_PER_PTE_ROW_NOM_L[k] = dpte_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0)\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = 0;\n\t\telse\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = dpte_row_height_chroma[k] / VRatioChroma[k];\n\t\tDST_Y_PER_META_ROW_NOM_L[k] = meta_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0)\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = 0;\n\t\telse\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = meta_row_height_chroma[k] / VRatioChroma[k];\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmeta_chunk_width = MetaChunkSize * 1024 * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmin_meta_chunk_width = MinMetaChunkSizeBytes * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmeta_chunk_per_row_int = meta_row_width[k] / meta_chunk_width;\n\t\t\tmeta_row_remainder = meta_row_width[k] % meta_chunk_width;\n\t\t\tif (!IsVertical(SourceRotation[k]))\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_width[k];\n\t\t\telse\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_height[k];\n\n\t\t\tif (meta_row_remainder <= meta_chunk_threshold)\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 1;\n\t\t\telse\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 2;\n\n\t\t\tTimePerMetaChunkNominal[k] = meta_row_height[k] / VRatio[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t\t} else {\n\t\t\t\tmeta_chunk_width_chroma = MetaChunkSize * 1024 * 256 / BytePerPixelC[k] /\n\t\t\t\t\t\tmeta_row_height_chroma[k];\n\t\t\t\tmin_meta_chunk_width_chroma = MinMetaChunkSizeBytes * 256 / BytePerPixelC[k] /\n\t\t\t\t\t\tmeta_row_height_chroma[k];\n\t\t\t\tmeta_chunk_per_row_int_chroma = (double) meta_row_width_chroma[k] /\n\t\t\t\t\t\tmeta_chunk_width_chroma;\n\t\t\t\tmeta_row_remainder_chroma = meta_row_width_chroma[k] % meta_chunk_width_chroma;\n\t\t\t\tif (!IsVertical(SourceRotation[k])) {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma -\n\t\t\t\t\t\t\tmeta_req_width_chroma[k];\n\t\t\t\t} else {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma -\n\t\t\t\t\t\t\tmeta_req_height_chroma[k];\n\t\t\t\t}\n\t\t\t\tif (meta_row_remainder_chroma <= meta_chunk_threshold_chroma)\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 1;\n\t\t\t\telse\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 2;\n\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = meta_row_height_chroma[k] / VRatioChroma[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t}\n\t\t} else {\n\t\t\tTimePerMetaChunkNominal[k] = 0;\n\t\t\tTimePerMetaChunkVBlank[k] = 0;\n\t\t\tTimePerMetaChunkFlip[k] = 0;\n\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (GPUVMEnable == true) {\n\t\t\tif (!IsVertical(SourceRotation[k])) {\n\t\t\t\tdpte_group_width_luma = (double) dpte_group_bytes[k] /\n\t\t\t\t\t\t(double) PTERequestSizeY[k] * PixelPTEReqWidthY[k];\n\t\t\t} else {\n\t\t\t\tdpte_group_width_luma = (double) dpte_group_bytes[k] /\n\t\t\t\t\t\t(double) PTERequestSizeY[k] * PixelPTEReqHeightY[k];\n\t\t\t}\n\n\t\t\tif (use_one_row_for_frame[k]) {\n\t\t\t\tdpte_groups_per_row_luma_ub = dml_ceil((double) dpte_row_width_luma_ub[k] /\n\t\t\t\t\t\t(double) dpte_group_width_luma / 2.0, 1.0);\n\t\t\t} else {\n\t\t\t\tdpte_groups_per_row_luma_ub = dml_ceil((double) dpte_row_width_luma_ub[k] /\n\t\t\t\t\t\t(double) dpte_group_width_luma, 1.0);\n\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d, use_one_row_for_frame        = %d\\n\",\n\t\t\t\t\t__func__, k, use_one_row_for_frame[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, dpte_group_bytes             = %d\\n\",\n\t\t\t\t\t__func__, k, dpte_group_bytes[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, PTERequestSizeY              = %d\\n\",\n\t\t\t\t\t__func__, k, PTERequestSizeY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, PixelPTEReqWidthY            = %d\\n\",\n\t\t\t\t\t__func__, k, PixelPTEReqWidthY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, PixelPTEReqHeightY           = %d\\n\",\n\t\t\t\t\t__func__, k, PixelPTEReqHeightY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, dpte_row_width_luma_ub       = %d\\n\",\n\t\t\t\t\t__func__, k, dpte_row_width_luma_ub[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, dpte_group_width_luma        = %d\\n\",\n\t\t\t\t\t__func__, k, dpte_group_width_luma);\n\t\t\tdml_print(\"DML::%s: k=%0d, dpte_groups_per_row_luma_ub  = %d\\n\",\n\t\t\t\t\t__func__, k, dpte_groups_per_row_luma_ub);\n#endif\n\n\t\t\ttime_per_pte_group_nom_luma[k] = DST_Y_PER_PTE_ROW_NOM_L[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_vblank_luma[k] = DestinationLinesToRequestRowInVBlank[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_flip_luma[k] = DestinationLinesToRequestRowInImmediateFlip[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t\t} else {\n\t\t\t\tif (!IsVertical(SourceRotation[k])) {\n\t\t\t\t\tdpte_group_width_chroma = (double) dpte_group_bytes[k] /\n\t\t\t\t\t\t\t(double) PTERequestSizeC[k] * PixelPTEReqWidthC[k];\n\t\t\t\t} else {\n\t\t\t\t\tdpte_group_width_chroma = (double) dpte_group_bytes[k] /\n\t\t\t\t\t\t\t(double) PTERequestSizeC[k] * PixelPTEReqHeightC[k];\n\t\t\t\t}\n\n\t\t\t\tif (use_one_row_for_frame[k]) {\n\t\t\t\t\tdpte_groups_per_row_chroma_ub = dml_ceil((double) dpte_row_width_chroma_ub[k] /\n\t\t\t\t\t\t\t(double) dpte_group_width_chroma / 2.0, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tdpte_groups_per_row_chroma_ub = dml_ceil((double) dpte_row_width_chroma_ub[k] /\n\t\t\t\t\t\t\t(double) dpte_group_width_chroma, 1.0);\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: k=%0d, dpte_row_width_chroma_ub        = %d\\n\",\n\t\t\t\t\t\t__func__, k, dpte_row_width_chroma_ub[k]);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, dpte_group_width_chroma        = %d\\n\",\n\t\t\t\t\t\t__func__, k, dpte_group_width_chroma);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, dpte_groups_per_row_chroma_ub  = %d\\n\",\n\t\t\t\t\t\t__func__, k, dpte_groups_per_row_chroma_ub);\n#endif\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = DST_Y_PER_PTE_ROW_NOM_C[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = DestinationLinesToRequestRowInVBlank[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = DestinationLinesToRequestRowInImmediateFlip[k] *\n\t\t\t\t\t\tHTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t}\n\t\t} else {\n\t\t\ttime_per_pte_group_nom_luma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_luma[k] = 0;\n\t\t\ttime_per_pte_group_flip_luma[k] = 0;\n\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d, DestinationLinesToRequestRowInVBlank         = %f\\n\",\n\t\t\t\t__func__, k, DestinationLinesToRequestRowInVBlank[k]);\n\t\tdml_print(\"DML::%s: k=%0d, DestinationLinesToRequestRowInImmediateFlip  = %f\\n\",\n\t\t\t\t__func__, k, DestinationLinesToRequestRowInImmediateFlip[k]);\n\t\tdml_print(\"DML::%s: k=%0d, DST_Y_PER_PTE_ROW_NOM_L                      = %f\\n\",\n\t\t\t\t__func__, k, DST_Y_PER_PTE_ROW_NOM_L[k]);\n\t\tdml_print(\"DML::%s: k=%0d, DST_Y_PER_PTE_ROW_NOM_C                      = %f\\n\",\n\t\t\t\t__func__, k, DST_Y_PER_PTE_ROW_NOM_C[k]);\n\t\tdml_print(\"DML::%s: k=%0d, DST_Y_PER_META_ROW_NOM_L                     = %f\\n\",\n\t\t\t\t__func__, k, DST_Y_PER_META_ROW_NOM_L[k]);\n\t\tdml_print(\"DML::%s: k=%0d, DST_Y_PER_META_ROW_NOM_C                     = %f\\n\",\n\t\t\t\t__func__, k, DST_Y_PER_META_ROW_NOM_C[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerMetaChunkNominal          = %f\\n\",\n\t\t\t\t__func__, k, TimePerMetaChunkNominal[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerMetaChunkVBlank           = %f\\n\",\n\t\t\t\t__func__, k, TimePerMetaChunkVBlank[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerMetaChunkFlip             = %f\\n\",\n\t\t\t\t__func__, k, TimePerMetaChunkFlip[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerChromaMetaChunkNominal    = %f\\n\",\n\t\t\t\t__func__, k, TimePerChromaMetaChunkNominal[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerChromaMetaChunkVBlank     = %f\\n\",\n\t\t\t\t__func__, k, TimePerChromaMetaChunkVBlank[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerChromaMetaChunkFlip       = %f\\n\",\n\t\t\t\t__func__, k, TimePerChromaMetaChunkFlip[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_nom_luma      = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_nom_luma[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_vblank_luma   = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_vblank_luma[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_flip_luma     = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_flip_luma[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_nom_chroma    = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_nom_chroma[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_vblank_chroma = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_vblank_chroma[k]);\n\t\tdml_print(\"DML::%s: k=%0d, time_per_pte_group_flip_chroma   = %f\\n\",\n\t\t\t\t__func__, k, time_per_pte_group_flip_chroma[k]);\n#endif\n\t}\n} \n\nvoid dml32_CalculateVMGroupAndRequestTimes(\n\t\tunsigned int     NumberOfActiveSurfaces,\n\t\tbool     GPUVMEnable,\n\t\tunsigned int     GPUVMMaxPageTableLevels,\n\t\tunsigned int     HTotal[],\n\t\tunsigned int     BytePerPixelC[],\n\t\tdouble      DestinationLinesToRequestVMInVBlank[],\n\t\tdouble      DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool     DCCEnable[],\n\t\tdouble      PixelClock[],\n\t\tunsigned int        dpte_row_width_luma_ub[],\n\t\tunsigned int        dpte_row_width_chroma_ub[],\n\t\tunsigned int     vm_group_bytes[],\n\t\tunsigned int     dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int     dpde0_bytes_per_frame_ub_c[],\n\t\tunsigned int        meta_pte_bytes_per_frame_ub_l[],\n\t\tunsigned int        meta_pte_bytes_per_frame_ub_c[],\n\n\t\t \n\t\tdouble      TimePerVMGroupVBlank[],\n\t\tdouble      TimePerVMGroupFlip[],\n\t\tdouble      TimePerVMRequestVBlank[],\n\t\tdouble      TimePerVMRequestFlip[])\n{\n\tunsigned int k;\n\tunsigned int   num_group_per_lower_vm_stage;\n\tunsigned int   num_req_per_lower_vm_stage;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: NumberOfActiveSurfaces = %d\\n\", __func__, NumberOfActiveSurfaces);\n\tdml_print(\"DML::%s: GPUVMEnable = %d\\n\", __func__, GPUVMEnable);\n#endif\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d, DCCEnable = %d\\n\", __func__, k, DCCEnable[k]);\n\t\tdml_print(\"DML::%s: k=%0d, vm_group_bytes = %d\\n\", __func__, k, vm_group_bytes[k]);\n\t\tdml_print(\"DML::%s: k=%0d, dpde0_bytes_per_frame_ub_l = %d\\n\",\n\t\t\t\t__func__, k, dpde0_bytes_per_frame_ub_l[k]);\n\t\tdml_print(\"DML::%s: k=%0d, dpde0_bytes_per_frame_ub_c = %d\\n\",\n\t\t\t\t__func__, k, dpde0_bytes_per_frame_ub_c[k]);\n\t\tdml_print(\"DML::%s: k=%0d, meta_pte_bytes_per_frame_ub_l = %d\\n\",\n\t\t\t\t__func__, k, meta_pte_bytes_per_frame_ub_l[k]);\n\t\tdml_print(\"DML::%s: k=%0d, meta_pte_bytes_per_frame_ub_c = %d\\n\",\n\t\t\t\t__func__, k, meta_pte_bytes_per_frame_ub_c[k]);\n#endif\n\n\t\tif (GPUVMEnable == true && (DCCEnable[k] == true || GPUVMMaxPageTableLevels > 1)) {\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil(\n\t\t\t\t\t\t\t(double) (dpde0_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0) +\n\t\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil(\n\t\t\t\t\t\t\t(double) (dpde0_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil(\n\t\t\t\t\t\t\t(double) (meta_pte_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0) +\n\t\t\t\t\t\t\tdml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil(\n\t\t\t\t\t\t\t\t(double) (meta_pte_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1.0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 2 + dml_ceil(\n\t\t\t\t\t\t\t(double) (dpde0_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1) +\n\t\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1) +\n\t\t\t\t\t\t\tdml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1) +\n\t\t\t\t\t\t\tdml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 1 + dml_ceil(\n\t\t\t\t\t\t\t(double) (dpde0_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1) + dml_ceil(\n\t\t\t\t\t\t\t(double) (meta_pte_bytes_per_frame_ub_l[k]) /\n\t\t\t\t\t\t\t(double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64 +\n\t\t\t\t\t\t\tdpde0_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t} else {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64 +\n\t\t\t\t\t\t\t\tmeta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] /\n\t\t\t\t\t\t\t\t64 + dpde0_bytes_per_frame_ub_c[k] / 64 +\n\t\t\t\t\t\t\t\tmeta_pte_bytes_per_frame_ub_l[k] / 64 +\n\t\t\t\t\t\t\t\tmeta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] /\n\t\t\t\t\t\t\t\t64 + meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTimePerVMGroupVBlank[k] = DestinationLinesToRequestVMInVBlank[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMGroupFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMRequestVBlank[k] = DestinationLinesToRequestVMInVBlank[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\t\t\tTimePerVMRequestFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] *\n\t\t\t\t\tHTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\n\t\t\tif (GPUVMMaxPageTableLevels > 2) {\n\t\t\t\tTimePerVMGroupVBlank[k]    = TimePerVMGroupVBlank[k] / 2;\n\t\t\t\tTimePerVMGroupFlip[k]      = TimePerVMGroupFlip[k] / 2;\n\t\t\t\tTimePerVMRequestVBlank[k]  = TimePerVMRequestVBlank[k] / 2;\n\t\t\t\tTimePerVMRequestFlip[k]    = TimePerVMRequestFlip[k] / 2;\n\t\t\t}\n\n\t\t} else {\n\t\t\tTimePerVMGroupVBlank[k] = 0;\n\t\t\tTimePerVMGroupFlip[k] = 0;\n\t\t\tTimePerVMRequestVBlank[k] = 0;\n\t\t\tTimePerVMRequestFlip[k] = 0;\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d, TimePerVMGroupVBlank = %f\\n\", __func__, k, TimePerVMGroupVBlank[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerVMGroupFlip = %f\\n\", __func__, k, TimePerVMGroupFlip[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerVMRequestVBlank = %f\\n\", __func__, k, TimePerVMRequestVBlank[k]);\n\t\tdml_print(\"DML::%s: k=%0d, TimePerVMRequestFlip = %f\\n\", __func__, k, TimePerVMRequestFlip[k]);\n#endif\n\t}\n} \n\nvoid dml32_CalculateDCCConfiguration(\n\t\tbool             DCCEnabled,\n\t\tbool             DCCProgrammingAssumesScanDirectionUnknown,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int             SurfaceWidthLuma,\n\t\tunsigned int             SurfaceWidthChroma,\n\t\tunsigned int             SurfaceHeightLuma,\n\t\tunsigned int             SurfaceHeightChroma,\n\t\tunsigned int                nomDETInKByte,\n\t\tunsigned int             RequestHeight256ByteLuma,\n\t\tunsigned int             RequestHeight256ByteChroma,\n\t\tenum dm_swizzle_mode     TilingFormat,\n\t\tunsigned int             BytePerPixelY,\n\t\tunsigned int             BytePerPixelC,\n\t\tdouble              BytePerPixelDETY,\n\t\tdouble              BytePerPixelDETC,\n\t\tenum dm_rotation_angle   SourceRotation,\n\t\t \n\t\tunsigned int        *MaxUncompressedBlockLuma,\n\t\tunsigned int        *MaxUncompressedBlockChroma,\n\t\tunsigned int        *MaxCompressedBlockLuma,\n\t\tunsigned int        *MaxCompressedBlockChroma,\n\t\tunsigned int        *IndependentBlockLuma,\n\t\tunsigned int        *IndependentBlockChroma)\n{\n\ttypedef enum {\n\t\tREQ_256Bytes,\n\t\tREQ_128BytesNonContiguous,\n\t\tREQ_128BytesContiguous,\n\t\tREQ_NA\n\t} RequestType;\n\n\tRequestType   RequestLuma;\n\tRequestType   RequestChroma;\n\n\tunsigned int   segment_order_horz_contiguous_luma;\n\tunsigned int   segment_order_horz_contiguous_chroma;\n\tunsigned int   segment_order_vert_contiguous_luma;\n\tunsigned int   segment_order_vert_contiguous_chroma;\n\tunsigned int req128_horz_wc_l;\n\tunsigned int req128_horz_wc_c;\n\tunsigned int req128_vert_wc_l;\n\tunsigned int req128_vert_wc_c;\n\tunsigned int MAS_vp_horz_limit;\n\tunsigned int MAS_vp_vert_limit;\n\tunsigned int max_vp_horz_width;\n\tunsigned int max_vp_vert_height;\n\tunsigned int eff_surf_width_l;\n\tunsigned int eff_surf_width_c;\n\tunsigned int eff_surf_height_l;\n\tunsigned int eff_surf_height_c;\n\tunsigned int full_swath_bytes_horz_wc_l;\n\tunsigned int full_swath_bytes_horz_wc_c;\n\tunsigned int full_swath_bytes_vert_wc_l;\n\tunsigned int full_swath_bytes_vert_wc_c;\n\tunsigned int DETBufferSizeForDCC = nomDETInKByte * 1024;\n\n\tunsigned int   yuv420;\n\tunsigned int   horz_div_l;\n\tunsigned int   horz_div_c;\n\tunsigned int   vert_div_l;\n\tunsigned int   vert_div_c;\n\n\tunsigned int     swath_buf_size;\n\tdouble   detile_buf_vp_horz_limit;\n\tdouble   detile_buf_vp_vert_limit;\n\n\tyuv420 = ((SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 ||\n\t\t\tSourcePixelFormat == dm_420_12) ? 1 : 0);\n\thorz_div_l = 1;\n\thorz_div_c = 1;\n\tvert_div_l = 1;\n\tvert_div_c = 1;\n\n\tif (BytePerPixelY == 1)\n\t\tvert_div_l = 0;\n\tif (BytePerPixelC == 1)\n\t\tvert_div_c = 0;\n\n\tif (BytePerPixelC == 0) {\n\t\tswath_buf_size = DETBufferSizeForDCC / 2 - 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size / ((double) RequestHeight256ByteLuma *\n\t\t\t\tBytePerPixelY / (1 + horz_div_l));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size / (256.0 / RequestHeight256ByteLuma /\n\t\t\t\t(1 + vert_div_l));\n\t} else {\n\t\tswath_buf_size = DETBufferSizeForDCC / 2 - 2 * 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size / ((double) RequestHeight256ByteLuma *\n\t\t\t\tBytePerPixelY / (1 + horz_div_l) + (double) RequestHeight256ByteChroma *\n\t\t\t\tBytePerPixelC / (1 + horz_div_c) / (1 + yuv420));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size / (256.0 / RequestHeight256ByteLuma /\n\t\t\t\t(1 + vert_div_l) + 256.0 / RequestHeight256ByteChroma /\n\t\t\t\t(1 + vert_div_c) / (1 + yuv420));\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tdetile_buf_vp_horz_limit = 1.5 * detile_buf_vp_horz_limit;\n\t\tdetile_buf_vp_vert_limit = 1.5 * detile_buf_vp_vert_limit;\n\t}\n\n\tdetile_buf_vp_horz_limit = dml_floor(detile_buf_vp_horz_limit - 1, 16);\n\tdetile_buf_vp_vert_limit = dml_floor(detile_buf_vp_vert_limit - 1, 16);\n\n\tMAS_vp_horz_limit = SourcePixelFormat == dm_rgbe_alpha ? 3840 : 6144;\n\tMAS_vp_vert_limit = SourcePixelFormat == dm_rgbe_alpha ? 3840 : (BytePerPixelY == 8 ? 3072 : 6144);\n\tmax_vp_horz_width = dml_min((double) MAS_vp_horz_limit, detile_buf_vp_horz_limit);\n\tmax_vp_vert_height = dml_min((double) MAS_vp_vert_limit, detile_buf_vp_vert_limit);\n\teff_surf_width_l =  (SurfaceWidthLuma > max_vp_horz_width ? max_vp_horz_width : SurfaceWidthLuma);\n\teff_surf_width_c =  eff_surf_width_l / (1 + yuv420);\n\teff_surf_height_l =  (SurfaceHeightLuma > max_vp_vert_height ? max_vp_vert_height : SurfaceHeightLuma);\n\teff_surf_height_c =  eff_surf_height_l / (1 + yuv420);\n\n\tfull_swath_bytes_horz_wc_l = eff_surf_width_l * RequestHeight256ByteLuma * BytePerPixelY;\n\tfull_swath_bytes_vert_wc_l = eff_surf_height_l * 256 / RequestHeight256ByteLuma;\n\tif (BytePerPixelC > 0) {\n\t\tfull_swath_bytes_horz_wc_c = eff_surf_width_c * RequestHeight256ByteChroma * BytePerPixelC;\n\t\tfull_swath_bytes_vert_wc_c = eff_surf_height_c * 256 / RequestHeight256ByteChroma;\n\t} else {\n\t\tfull_swath_bytes_horz_wc_c = 0;\n\t\tfull_swath_bytes_vert_wc_c = 0;\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tfull_swath_bytes_horz_wc_l = dml_ceil((double) full_swath_bytes_horz_wc_l * 2.0 / 3.0, 256.0);\n\t\tfull_swath_bytes_horz_wc_c = dml_ceil((double) full_swath_bytes_horz_wc_c * 2.0 / 3.0, 256.0);\n\t\tfull_swath_bytes_vert_wc_l = dml_ceil((double) full_swath_bytes_vert_wc_l * 2.0 / 3.0, 256.0);\n\t\tfull_swath_bytes_vert_wc_c = dml_ceil((double) full_swath_bytes_vert_wc_c * 2.0 / 3.0, 256.0);\n\t}\n\n\tif (2 * full_swath_bytes_horz_wc_l + 2 * full_swath_bytes_horz_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 0;\n\t} else if (full_swath_bytes_horz_wc_l < 1.5 * full_swath_bytes_horz_wc_c && 2 * full_swath_bytes_horz_wc_l +\n\t\t\tfull_swath_bytes_horz_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 1;\n\t} else if (full_swath_bytes_horz_wc_l >= 1.5 * full_swath_bytes_horz_wc_c && full_swath_bytes_horz_wc_l + 2 *\n\t\t\tfull_swath_bytes_horz_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 0;\n\t} else {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 1;\n\t}\n\n\tif (2 * full_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 0;\n\t} else if (full_swath_bytes_vert_wc_l < 1.5 * full_swath_bytes_vert_wc_c && 2 *\n\t\t\tfull_swath_bytes_vert_wc_l + full_swath_bytes_vert_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 1;\n\t} else if (full_swath_bytes_vert_wc_l >= 1.5 * full_swath_bytes_vert_wc_c &&\n\t\t\tfull_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c <= DETBufferSizeForDCC) {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 0;\n\t} else {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 1;\n\t}\n\n\tif (BytePerPixelY == 2) {\n\t\tsegment_order_horz_contiguous_luma = 0;\n\t\tsegment_order_vert_contiguous_luma = 1;\n\t} else {\n\t\tsegment_order_horz_contiguous_luma = 1;\n\t\tsegment_order_vert_contiguous_luma = 0;\n\t}\n\n\tif (BytePerPixelC == 2) {\n\t\tsegment_order_horz_contiguous_chroma = 0;\n\t\tsegment_order_vert_contiguous_chroma = 1;\n\t} else {\n\t\tsegment_order_horz_contiguous_chroma = 1;\n\t\tsegment_order_vert_contiguous_chroma = 0;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DCCEnabled = %d\\n\", __func__, DCCEnabled);\n\tdml_print(\"DML::%s: nomDETInKByte = %d\\n\", __func__, nomDETInKByte);\n\tdml_print(\"DML::%s: DETBufferSizeForDCC = %d\\n\", __func__, DETBufferSizeForDCC);\n\tdml_print(\"DML::%s: req128_horz_wc_l = %d\\n\", __func__, req128_horz_wc_l);\n\tdml_print(\"DML::%s: req128_horz_wc_c = %d\\n\", __func__, req128_horz_wc_c);\n\tdml_print(\"DML::%s: full_swath_bytes_horz_wc_l = %d\\n\", __func__, full_swath_bytes_horz_wc_l);\n\tdml_print(\"DML::%s: full_swath_bytes_vert_wc_c = %d\\n\", __func__, full_swath_bytes_vert_wc_c);\n\tdml_print(\"DML::%s: segment_order_horz_contiguous_luma = %d\\n\", __func__, segment_order_horz_contiguous_luma);\n\tdml_print(\"DML::%s: segment_order_horz_contiguous_chroma = %d\\n\",\n\t\t\t__func__, segment_order_horz_contiguous_chroma);\n#endif\n\n\tif (DCCProgrammingAssumesScanDirectionUnknown == true) {\n\t\tif (req128_horz_wc_l == 0 && req128_vert_wc_l == 0)\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\telse if ((req128_horz_wc_l == 1 && segment_order_horz_contiguous_luma == 0) ||\n\t\t\t\t(req128_vert_wc_l == 1 && segment_order_vert_contiguous_luma == 0))\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\n\t\tif (req128_horz_wc_c == 0 && req128_vert_wc_c == 0)\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\telse if ((req128_horz_wc_c == 1 && segment_order_horz_contiguous_chroma == 0) ||\n\t\t\t\t(req128_vert_wc_c == 1 && segment_order_vert_contiguous_chroma == 0))\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\n\t} else if (!IsVertical(SourceRotation)) {\n\t\tif (req128_horz_wc_l == 0)\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\telse if (segment_order_horz_contiguous_luma == 0)\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\n\t\tif (req128_horz_wc_c == 0)\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\telse if (segment_order_horz_contiguous_chroma == 0)\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\n\t} else {\n\t\tif (req128_vert_wc_l == 0)\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\telse if (segment_order_vert_contiguous_luma == 0)\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\n\t\tif (req128_vert_wc_c == 0)\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\telse if (segment_order_vert_contiguous_chroma == 0)\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\telse\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t}\n\n\tif (RequestLuma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 256;\n\t\t*IndependentBlockLuma = 0;\n\t} else if (RequestLuma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 128;\n\t\t*IndependentBlockLuma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 64;\n\t\t*IndependentBlockLuma = 64;\n\t}\n\n\tif (RequestChroma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 256;\n\t\t*IndependentBlockChroma = 0;\n\t} else if (RequestChroma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 128;\n\t\t*IndependentBlockChroma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 64;\n\t\t*IndependentBlockChroma = 64;\n\t}\n\n\tif (DCCEnabled != true || BytePerPixelC == 0) {\n\t\t*MaxUncompressedBlockChroma = 0;\n\t\t*MaxCompressedBlockChroma = 0;\n\t\t*IndependentBlockChroma = 0;\n\t}\n\n\tif (DCCEnabled != true) {\n\t\t*MaxUncompressedBlockLuma = 0;\n\t\t*MaxCompressedBlockLuma = 0;\n\t\t*IndependentBlockLuma = 0;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: MaxUncompressedBlockLuma = %d\\n\", __func__, *MaxUncompressedBlockLuma);\n\tdml_print(\"DML::%s: MaxCompressedBlockLuma = %d\\n\", __func__, *MaxCompressedBlockLuma);\n\tdml_print(\"DML::%s: IndependentBlockLuma = %d\\n\", __func__, *IndependentBlockLuma);\n\tdml_print(\"DML::%s: MaxUncompressedBlockChroma = %d\\n\", __func__, *MaxUncompressedBlockChroma);\n\tdml_print(\"DML::%s: MaxCompressedBlockChroma = %d\\n\", __func__, *MaxCompressedBlockChroma);\n\tdml_print(\"DML::%s: IndependentBlockChroma = %d\\n\", __func__, *IndependentBlockChroma);\n#endif\n\n} \n\nvoid dml32_CalculateStutterEfficiency(\n\t\tunsigned int      CompressedBufferSizeInkByte,\n\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange[],\n\t\tbool   UnboundedRequestEnabled,\n\t\tunsigned int      MetaFIFOSizeInKEntries,\n\t\tunsigned int      ZeroSizeBufferEntries,\n\t\tunsigned int      PixelChunkSizeInKByte,\n\t\tunsigned int   NumberOfActiveSurfaces,\n\t\tunsigned int      ROBBufferSizeInKByte,\n\t\tdouble    TotalDataReadBandwidth,\n\t\tdouble    DCFCLK,\n\t\tdouble    ReturnBW,\n\t\tunsigned int      CompbufReservedSpace64B,\n\t\tunsigned int      CompbufReservedSpaceZs,\n\t\tdouble    SRExitTime,\n\t\tdouble    SRExitZ8Time,\n\t\tbool   SynchronizeTimingsFinal,\n\t\tunsigned int   BlendingAndTiming[],\n\t\tdouble    StutterEnterPlusExitWatermark,\n\t\tdouble    Z8StutterEnterPlusExitWatermark,\n\t\tbool   ProgressiveToInterlaceUnitInOPP,\n\t\tbool   Interlace[],\n\t\tdouble    MinTTUVBlank[],\n\t\tunsigned int   DPPPerSurface[],\n\t\tunsigned int      DETBufferSizeY[],\n\t\tunsigned int   BytePerPixelY[],\n\t\tdouble    BytePerPixelDETY[],\n\t\tdouble      SwathWidthY[],\n\t\tunsigned int   SwathHeightY[],\n\t\tunsigned int   SwathHeightC[],\n\t\tdouble    NetDCCRateLuma[],\n\t\tdouble    NetDCCRateChroma[],\n\t\tdouble    DCCFractionOfZeroSizeRequestsLuma[],\n\t\tdouble    DCCFractionOfZeroSizeRequestsChroma[],\n\t\tunsigned int      HTotal[],\n\t\tunsigned int      VTotal[],\n\t\tdouble    PixelClock[],\n\t\tdouble    VRatio[],\n\t\tenum dm_rotation_angle SourceRotation[],\n\t\tunsigned int   BlockHeight256BytesY[],\n\t\tunsigned int   BlockWidth256BytesY[],\n\t\tunsigned int   BlockHeight256BytesC[],\n\t\tunsigned int   BlockWidth256BytesC[],\n\t\tunsigned int   DCCYMaxUncompressedBlock[],\n\t\tunsigned int   DCCCMaxUncompressedBlock[],\n\t\tunsigned int      VActive[],\n\t\tbool   DCCEnable[],\n\t\tbool   WritebackEnable[],\n\t\tdouble    ReadBandwidthSurfaceLuma[],\n\t\tdouble    ReadBandwidthSurfaceChroma[],\n\t\tdouble    meta_row_bw[],\n\t\tdouble    dpte_row_bw[],\n\n\t\t \n\t\tdouble   *StutterEfficiencyNotIncludingVBlank,\n\t\tdouble   *StutterEfficiency,\n\t\tunsigned int     *NumberOfStutterBurstsPerFrame,\n\t\tdouble   *Z8StutterEfficiencyNotIncludingVBlank,\n\t\tdouble   *Z8StutterEfficiency,\n\t\tunsigned int     *Z8NumberOfStutterBurstsPerFrame,\n\t\tdouble   *StutterPeriod,\n\t\tbool  *DCHUBBUB_ARB_CSTATE_MAX_CAP_MODE)\n{\n\n\tbool FoundCriticalSurface = false;\n\tunsigned int SwathSizeCriticalSurface = 0;\n\tunsigned int LastChunkOfSwathSize;\n\tunsigned int MissingPartOfLastSwathOfDETSize;\n\tdouble LastZ8StutterPeriod = 0.0;\n\tdouble LastStutterPeriod = 0.0;\n\tunsigned int TotalNumberOfActiveOTG = 0;\n\tdouble doublePixelClock;\n\tunsigned int doubleHTotal;\n\tunsigned int doubleVTotal;\n\tbool SameTiming = true;\n\tdouble DETBufferingTimeY;\n\tdouble SwathWidthYCriticalSurface = 0.0;\n\tdouble SwathHeightYCriticalSurface = 0.0;\n\tdouble VActiveTimeCriticalSurface = 0.0;\n\tdouble FrameTimeCriticalSurface = 0.0;\n\tunsigned int BytePerPixelYCriticalSurface = 0;\n\tdouble LinesToFinishSwathTransferStutterCriticalSurface = 0.0;\n\tunsigned int DETBufferSizeYCriticalSurface = 0;\n\tdouble MinTTUVBlankCriticalSurface = 0.0;\n\tunsigned int BlockWidth256BytesYCriticalSurface = 0;\n\tbool doublePlaneCriticalSurface = 0;\n\tbool doublePipeCriticalSurface = 0;\n\tdouble TotalCompressedReadBandwidth;\n\tdouble TotalRowReadBandwidth;\n\tdouble AverageDCCCompressionRate;\n\tdouble EffectiveCompressedBufferSize;\n\tdouble PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer;\n\tdouble StutterBurstTime;\n\tunsigned int TotalActiveWriteback;\n\tdouble LinesInDETY;\n\tdouble LinesInDETYRoundedDownToSwath;\n\tdouble MaximumEffectiveCompressionLuma;\n\tdouble MaximumEffectiveCompressionChroma;\n\tdouble TotalZeroSizeRequestReadBandwidth;\n\tdouble TotalZeroSizeCompressedReadBandwidth;\n\tdouble AverageDCCZeroSizeFraction;\n\tdouble AverageZeroSizeCompressionRate;\n\tunsigned int k;\n\n\tTotalZeroSizeRequestReadBandwidth = 0;\n\tTotalZeroSizeCompressedReadBandwidth = 0;\n\tTotalRowReadBandwidth = 0;\n\tTotalCompressedReadBandwidth = 0;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\tif (DCCEnable[k] == true) {\n\t\t\t\tif ((IsVertical(SourceRotation[k]) && BlockWidth256BytesY[k] > SwathHeightY[k])\n\t\t\t\t\t\t|| (!IsVertical(SourceRotation[k])\n\t\t\t\t\t\t\t\t&& BlockHeight256BytesY[k] > SwathHeightY[k])\n\t\t\t\t\t\t|| DCCYMaxUncompressedBlock[k] < 256) {\n\t\t\t\t\tMaximumEffectiveCompressionLuma = 2;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumEffectiveCompressionLuma = 4;\n\t\t\t\t}\n\t\t\t\tTotalCompressedReadBandwidth = TotalCompressedReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthSurfaceLuma[k]\n\t\t\t\t\t\t\t\t/ dml_min(NetDCCRateLuma[k],\n\t\t\t\t\t\t\t\t\t\tMaximumEffectiveCompressionLuma);\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: k=%0d, ReadBandwidthSurfaceLuma = %f\\n\",\n\t\t\t\t\t\t__func__, k, ReadBandwidthSurfaceLuma[k]);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, NetDCCRateLuma = %f\\n\",\n\t\t\t\t\t\t__func__, k, NetDCCRateLuma[k]);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, MaximumEffectiveCompressionLuma = %f\\n\",\n\t\t\t\t\t\t__func__, k, MaximumEffectiveCompressionLuma);\n#endif\n\t\t\t\tTotalZeroSizeRequestReadBandwidth = TotalZeroSizeRequestReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthSurfaceLuma[k] * DCCFractionOfZeroSizeRequestsLuma[k];\n\t\t\t\tTotalZeroSizeCompressedReadBandwidth = TotalZeroSizeCompressedReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthSurfaceLuma[k] * DCCFractionOfZeroSizeRequestsLuma[k]\n\t\t\t\t\t\t\t\t/ MaximumEffectiveCompressionLuma;\n\n\t\t\t\tif (ReadBandwidthSurfaceChroma[k] > 0) {\n\t\t\t\t\tif ((IsVertical(SourceRotation[k]) && BlockWidth256BytesC[k] > SwathHeightC[k])\n\t\t\t\t\t\t\t|| (!IsVertical(SourceRotation[k])\n\t\t\t\t\t\t\t\t\t&& BlockHeight256BytesC[k] > SwathHeightC[k])\n\t\t\t\t\t\t\t|| DCCCMaxUncompressedBlock[k] < 256) {\n\t\t\t\t\t\tMaximumEffectiveCompressionChroma = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMaximumEffectiveCompressionChroma = 4;\n\t\t\t\t\t}\n\t\t\t\t\tTotalCompressedReadBandwidth =\n\t\t\t\t\t\t\tTotalCompressedReadBandwidth\n\t\t\t\t\t\t\t+ ReadBandwidthSurfaceChroma[k]\n\t\t\t\t\t\t\t/ dml_min(NetDCCRateChroma[k],\n\t\t\t\t\t\t\tMaximumEffectiveCompressionChroma);\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\t\tdml_print(\"DML::%s: k=%0d, ReadBandwidthSurfaceChroma = %f\\n\",\n\t\t\t\t\t\t\t__func__, k, ReadBandwidthSurfaceChroma[k]);\n\t\t\t\t\tdml_print(\"DML::%s: k=%0d, NetDCCRateChroma = %f\\n\",\n\t\t\t\t\t\t\t__func__, k, NetDCCRateChroma[k]);\n\t\t\t\t\tdml_print(\"DML::%s: k=%0d, MaximumEffectiveCompressionChroma = %f\\n\",\n\t\t\t\t\t\t\t__func__, k, MaximumEffectiveCompressionChroma);\n#endif\n\t\t\t\t\tTotalZeroSizeRequestReadBandwidth = TotalZeroSizeRequestReadBandwidth\n\t\t\t\t\t\t\t+ ReadBandwidthSurfaceChroma[k]\n\t\t\t\t\t\t\t\t\t* DCCFractionOfZeroSizeRequestsChroma[k];\n\t\t\t\t\tTotalZeroSizeCompressedReadBandwidth = TotalZeroSizeCompressedReadBandwidth\n\t\t\t\t\t\t\t+ ReadBandwidthSurfaceChroma[k]\n\t\t\t\t\t\t\t\t\t* DCCFractionOfZeroSizeRequestsChroma[k]\n\t\t\t\t\t\t\t\t\t/ MaximumEffectiveCompressionChroma;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTotalCompressedReadBandwidth = TotalCompressedReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthSurfaceLuma[k] + ReadBandwidthSurfaceChroma[k];\n\t\t\t}\n\t\t\tTotalRowReadBandwidth = TotalRowReadBandwidth\n\t\t\t\t\t+ DPPPerSurface[k] * (meta_row_bw[k] + dpte_row_bw[k]);\n\t\t}\n\t}\n\n\tAverageDCCCompressionRate = TotalDataReadBandwidth / TotalCompressedReadBandwidth;\n\tAverageDCCZeroSizeFraction = TotalZeroSizeRequestReadBandwidth / TotalDataReadBandwidth;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: UnboundedRequestEnabled = %d\\n\", __func__, UnboundedRequestEnabled);\n\tdml_print(\"DML::%s: TotalCompressedReadBandwidth = %f\\n\", __func__, TotalCompressedReadBandwidth);\n\tdml_print(\"DML::%s: TotalZeroSizeRequestReadBandwidth = %f\\n\", __func__, TotalZeroSizeRequestReadBandwidth);\n\tdml_print(\"DML::%s: TotalZeroSizeCompressedReadBandwidth = %f\\n\",\n\t\t\t__func__, TotalZeroSizeCompressedReadBandwidth);\n\tdml_print(\"DML::%s: MaximumEffectiveCompressionLuma = %f\\n\", __func__, MaximumEffectiveCompressionLuma);\n\tdml_print(\"DML::%s: MaximumEffectiveCompressionChroma = %f\\n\", __func__, MaximumEffectiveCompressionChroma);\n\tdml_print(\"DML::%s: AverageDCCCompressionRate = %f\\n\", __func__, AverageDCCCompressionRate);\n\tdml_print(\"DML::%s: AverageDCCZeroSizeFraction = %f\\n\", __func__, AverageDCCZeroSizeFraction);\n\tdml_print(\"DML::%s: CompbufReservedSpace64B = %d\\n\", __func__, CompbufReservedSpace64B);\n\tdml_print(\"DML::%s: CompbufReservedSpaceZs = %d\\n\", __func__, CompbufReservedSpaceZs);\n\tdml_print(\"DML::%s: CompressedBufferSizeInkByte = %d\\n\", __func__, CompressedBufferSizeInkByte);\n#endif\n\tif (AverageDCCZeroSizeFraction == 1) {\n\t\tAverageZeroSizeCompressionRate = TotalZeroSizeRequestReadBandwidth\n\t\t\t\t/ TotalZeroSizeCompressedReadBandwidth;\n\t\tEffectiveCompressedBufferSize = (double) MetaFIFOSizeInKEntries * 1024 * 64\n\t\t\t\t* AverageZeroSizeCompressionRate\n\t\t\t\t+ ((double) ZeroSizeBufferEntries - CompbufReservedSpaceZs) * 64\n\t\t\t\t\t\t* AverageZeroSizeCompressionRate;\n\t} else if (AverageDCCZeroSizeFraction > 0) {\n\t\tAverageZeroSizeCompressionRate = TotalZeroSizeRequestReadBandwidth\n\t\t\t\t/ TotalZeroSizeCompressedReadBandwidth;\n\t\tEffectiveCompressedBufferSize = dml_min(\n\t\t\t\t(double) CompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate,\n\t\t\t\t(double) MetaFIFOSizeInKEntries * 1024 * 64\n\t\t\t\t\t/ (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate\n\t\t\t\t\t+ 1 / AverageDCCCompressionRate))\n\t\t\t\t\t+ dml_min(((double) ROBBufferSizeInKByte * 1024 - CompbufReservedSpace64B * 64)\n\t\t\t\t\t* AverageDCCCompressionRate,\n\t\t\t\t\t((double) ZeroSizeBufferEntries - CompbufReservedSpaceZs) * 64\n\t\t\t\t\t/ (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate));\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: min 1 = %f\\n\", __func__,\n\t\t\t\tCompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate);\n\t\tdml_print(\"DML::%s: min 2 = %f\\n\", __func__, MetaFIFOSizeInKEntries * 1024 * 64 /\n\t\t\t\t(AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate + 1 /\n\t\t\t\t\t\tAverageDCCCompressionRate));\n\t\tdml_print(\"DML::%s: min 3 = %f\\n\", __func__, (ROBBufferSizeInKByte * 1024 -\n\t\t\t\tCompbufReservedSpace64B * 64) * AverageDCCCompressionRate);\n\t\tdml_print(\"DML::%s: min 4 = %f\\n\", __func__, (ZeroSizeBufferEntries - CompbufReservedSpaceZs) * 64 /\n\t\t\t\t(AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate));\n#endif\n\t} else {\n\t\tEffectiveCompressedBufferSize = dml_min(\n\t\t\t\t(double) CompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate,\n\t\t\t\t(double) MetaFIFOSizeInKEntries * 1024 * 64 * AverageDCCCompressionRate)\n\t\t\t\t+ ((double) ROBBufferSizeInKByte * 1024 - CompbufReservedSpace64B * 64)\n\t\t\t\t\t\t* AverageDCCCompressionRate;\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: min 1 = %f\\n\", __func__,\n\t\t\t\tCompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate);\n\t\tdml_print(\"DML::%s: min 2 = %f\\n\", __func__,\n\t\t\t\tMetaFIFOSizeInKEntries * 1024 * 64 * AverageDCCCompressionRate);\n#endif\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: MetaFIFOSizeInKEntries = %d\\n\", __func__, MetaFIFOSizeInKEntries);\n\tdml_print(\"DML::%s: AverageZeroSizeCompressionRate = %f\\n\", __func__, AverageZeroSizeCompressionRate);\n\tdml_print(\"DML::%s: EffectiveCompressedBufferSize = %f\\n\", __func__, EffectiveCompressedBufferSize);\n#endif\n\n\t*StutterPeriod = 0;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\tLinesInDETY = ((double) DETBufferSizeY[k]\n\t\t\t\t\t+ (UnboundedRequestEnabled == true ? EffectiveCompressedBufferSize : 0)\n\t\t\t\t\t\t\t* ReadBandwidthSurfaceLuma[k] / TotalDataReadBandwidth)\n\t\t\t\t\t/ BytePerPixelDETY[k] / SwathWidthY[k];\n\t\t\tLinesInDETYRoundedDownToSwath = dml_floor(LinesInDETY, SwathHeightY[k]);\n\t\t\tDETBufferingTimeY = LinesInDETYRoundedDownToSwath * ((double) HTotal[k] / PixelClock[k])\n\t\t\t\t\t/ VRatio[k];\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d, DETBufferSizeY = %d\\n\", __func__, k, DETBufferSizeY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, BytePerPixelDETY = %f\\n\", __func__, k, BytePerPixelDETY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, SwathWidthY = %d\\n\", __func__, k, SwathWidthY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, ReadBandwidthSurfaceLuma = %f\\n\",\n\t\t\t\t\t__func__, k, ReadBandwidthSurfaceLuma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, TotalDataReadBandwidth = %f\\n\", __func__, k, TotalDataReadBandwidth);\n\t\t\tdml_print(\"DML::%s: k=%0d, LinesInDETY = %f\\n\", __func__, k, LinesInDETY);\n\t\t\tdml_print(\"DML::%s: k=%0d, LinesInDETYRoundedDownToSwath = %f\\n\",\n\t\t\t\t\t__func__, k, LinesInDETYRoundedDownToSwath);\n\t\t\tdml_print(\"DML::%s: k=%0d, HTotal = %d\\n\", __func__, k, HTotal[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, VRatio = %f\\n\", __func__, k, VRatio[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d, DETBufferingTimeY = %f\\n\", __func__, k, DETBufferingTimeY);\n\t\t\tdml_print(\"DML::%s: k=%0d, PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n#endif\n\n\t\t\tif (!FoundCriticalSurface || DETBufferingTimeY < *StutterPeriod) {\n\t\t\t\tbool isInterlaceTiming = Interlace[k] && !ProgressiveToInterlaceUnitInOPP;\n\n\t\t\t\tFoundCriticalSurface = true;\n\t\t\t\t*StutterPeriod = DETBufferingTimeY;\n\t\t\t\tFrameTimeCriticalSurface = (\n\t\t\t\t\t\tisInterlaceTiming ?\n\t\t\t\t\t\t\t\tdml_floor((double) VTotal[k] / 2.0, 1.0) : VTotal[k])\n\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];\n\t\t\t\tVActiveTimeCriticalSurface = (\n\t\t\t\t\t\tisInterlaceTiming ?\n\t\t\t\t\t\t\t\tdml_floor((double) VActive[k] / 2.0, 1.0) : VActive[k])\n\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];\n\t\t\t\tBytePerPixelYCriticalSurface = BytePerPixelY[k];\n\t\t\t\tSwathWidthYCriticalSurface = SwathWidthY[k];\n\t\t\t\tSwathHeightYCriticalSurface = SwathHeightY[k];\n\t\t\t\tBlockWidth256BytesYCriticalSurface = BlockWidth256BytesY[k];\n\t\t\t\tLinesToFinishSwathTransferStutterCriticalSurface = SwathHeightY[k]\n\t\t\t\t\t\t- (LinesInDETY - LinesInDETYRoundedDownToSwath);\n\t\t\t\tDETBufferSizeYCriticalSurface = DETBufferSizeY[k];\n\t\t\t\tMinTTUVBlankCriticalSurface = MinTTUVBlank[k];\n\t\t\t\tdoublePlaneCriticalSurface = (ReadBandwidthSurfaceChroma[k] == 0);\n\t\t\t\tdoublePipeCriticalSurface = (DPPPerSurface[k] == 1);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: k=%0d, FoundCriticalSurface                = %d\\n\",\n\t\t\t\t\t\t__func__, k, FoundCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, StutterPeriod                       = %f\\n\",\n\t\t\t\t\t\t__func__, k, *StutterPeriod);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, MinTTUVBlankCriticalSurface         = %f\\n\",\n\t\t\t\t\t\t__func__, k, MinTTUVBlankCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, FrameTimeCriticalSurface            = %f\\n\",\n\t\t\t\t\t\t__func__, k, FrameTimeCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, VActiveTimeCriticalSurface          = %f\\n\",\n\t\t\t\t\t\t__func__, k, VActiveTimeCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, BytePerPixelYCriticalSurface        = %d\\n\",\n\t\t\t\t\t\t__func__, k, BytePerPixelYCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, SwathWidthYCriticalSurface          = %f\\n\",\n\t\t\t\t\t\t__func__, k, SwathWidthYCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, SwathHeightYCriticalSurface         = %f\\n\",\n\t\t\t\t\t\t__func__, k, SwathHeightYCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, BlockWidth256BytesYCriticalSurface  = %d\\n\",\n\t\t\t\t\t\t__func__, k, BlockWidth256BytesYCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, doublePlaneCriticalSurface          = %d\\n\",\n\t\t\t\t\t\t__func__, k, doublePlaneCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, doublePipeCriticalSurface           = %d\\n\",\n\t\t\t\t\t\t__func__, k, doublePipeCriticalSurface);\n\t\t\t\tdml_print(\"DML::%s: k=%0d, LinesToFinishSwathTransferStutterCriticalSurface = %f\\n\",\n\t\t\t\t\t\t__func__, k, LinesToFinishSwathTransferStutterCriticalSurface);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tPartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer = dml_min(*StutterPeriod * TotalDataReadBandwidth,\n\t\t\tEffectiveCompressedBufferSize);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ROBBufferSizeInKByte = %d\\n\", __func__, ROBBufferSizeInKByte);\n\tdml_print(\"DML::%s: AverageDCCCompressionRate = %f\\n\", __func__, AverageDCCCompressionRate);\n\tdml_print(\"DML::%s: StutterPeriod * TotalDataReadBandwidth = %f\\n\",\n\t\t\t__func__, *StutterPeriod * TotalDataReadBandwidth);\n\tdml_print(\"DML::%s: EffectiveCompressedBufferSize = %f\\n\", __func__, EffectiveCompressedBufferSize);\n\tdml_print(\"DML::%s: PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer = %f\\n\", __func__,\n\t\t\tPartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer);\n\tdml_print(\"DML::%s: ReturnBW = %f\\n\", __func__, ReturnBW);\n\tdml_print(\"DML::%s: TotalDataReadBandwidth = %f\\n\", __func__, TotalDataReadBandwidth);\n\tdml_print(\"DML::%s: TotalRowReadBandwidth = %f\\n\", __func__, TotalRowReadBandwidth);\n\tdml_print(\"DML::%s: DCFCLK = %f\\n\", __func__, DCFCLK);\n#endif\n\n\tStutterBurstTime = PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer / AverageDCCCompressionRate\n\t\t\t/ ReturnBW\n\t\t\t+ (*StutterPeriod * TotalDataReadBandwidth\n\t\t\t\t\t- PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer) / (DCFCLK * 64)\n\t\t\t+ *StutterPeriod * TotalRowReadBandwidth / ReturnBW;\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: Part 1 = %f\\n\", __func__, PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer /\n\t\t\tAverageDCCCompressionRate / ReturnBW);\n\tdml_print(\"DML::%s: StutterPeriod * TotalDataReadBandwidth = %f\\n\",\n\t\t\t__func__, (*StutterPeriod * TotalDataReadBandwidth));\n\tdml_print(\"DML::%s: Part 2 = %f\\n\", __func__, (*StutterPeriod * TotalDataReadBandwidth -\n\t\t\tPartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer) / (DCFCLK * 64));\n\tdml_print(\"DML::%s: Part 3 = %f\\n\", __func__, *StutterPeriod * TotalRowReadBandwidth / ReturnBW);\n\tdml_print(\"DML::%s: StutterBurstTime = %f\\n\", __func__, StutterBurstTime);\n#endif\n\tStutterBurstTime = dml_max(StutterBurstTime,\n\t\t\tLinesToFinishSwathTransferStutterCriticalSurface * BytePerPixelYCriticalSurface\n\t\t\t\t\t* SwathWidthYCriticalSurface / ReturnBW);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: Time to finish residue swath=%f\\n\",\n\t\t\t__func__,\n\t\t\tLinesToFinishSwathTransferStutterCriticalSurface *\n\t\t\tBytePerPixelYCriticalSurface * SwathWidthYCriticalSurface / ReturnBW);\n#endif\n\n\tTotalActiveWriteback = 0;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (WritebackEnable[k])\n\t\t\tTotalActiveWriteback = TotalActiveWriteback + 1;\n\t}\n\n\tif (TotalActiveWriteback == 0) {\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: SRExitTime = %f\\n\", __func__, SRExitTime);\n\t\tdml_print(\"DML::%s: SRExitZ8Time = %f\\n\", __func__, SRExitZ8Time);\n\t\tdml_print(\"DML::%s: StutterBurstTime = %f (final)\\n\", __func__, StutterBurstTime);\n\t\tdml_print(\"DML::%s: StutterPeriod = %f\\n\", __func__, *StutterPeriod);\n#endif\n\t\t*StutterEfficiencyNotIncludingVBlank = dml_max(0.,\n\t\t\t\t1 - (SRExitTime + StutterBurstTime) / *StutterPeriod) * 100;\n\t\t*Z8StutterEfficiencyNotIncludingVBlank = dml_max(0.,\n\t\t\t\t1 - (SRExitZ8Time + StutterBurstTime) / *StutterPeriod) * 100;\n\t\t*NumberOfStutterBurstsPerFrame = (\n\t\t\t\t*StutterEfficiencyNotIncludingVBlank > 0 ?\n\t\t\t\t\t\tdml_ceil(VActiveTimeCriticalSurface / *StutterPeriod, 1) : 0);\n\t\t*Z8NumberOfStutterBurstsPerFrame = (\n\t\t\t\t*Z8StutterEfficiencyNotIncludingVBlank > 0 ?\n\t\t\t\t\t\tdml_ceil(VActiveTimeCriticalSurface / *StutterPeriod, 1) : 0);\n\t} else {\n\t\t*StutterEfficiencyNotIncludingVBlank = 0.;\n\t\t*Z8StutterEfficiencyNotIncludingVBlank = 0.;\n\t\t*NumberOfStutterBurstsPerFrame = 0;\n\t\t*Z8NumberOfStutterBurstsPerFrame = 0;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VActiveTimeCriticalSurface = %f\\n\", __func__, VActiveTimeCriticalSurface);\n\tdml_print(\"DML::%s: StutterEfficiencyNotIncludingVBlank = %f\\n\",\n\t\t\t__func__, *StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: Z8StutterEfficiencyNotIncludingVBlank = %f\\n\",\n\t\t\t__func__, *Z8StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *NumberOfStutterBurstsPerFrame);\n\tdml_print(\"DML::%s: Z8NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *Z8NumberOfStutterBurstsPerFrame);\n#endif\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\tif (BlendingAndTiming[k] == k) {\n\t\t\t\tif (TotalNumberOfActiveOTG == 0) {\n\t\t\t\t\tdoublePixelClock = PixelClock[k];\n\t\t\t\t\tdoubleHTotal = HTotal[k];\n\t\t\t\t\tdoubleVTotal = VTotal[k];\n\t\t\t\t} else if (doublePixelClock != PixelClock[k] || doubleHTotal != HTotal[k]\n\t\t\t\t\t\t|| doubleVTotal != VTotal[k]) {\n\t\t\t\t\tSameTiming = false;\n\t\t\t\t}\n\t\t\t\tTotalNumberOfActiveOTG = TotalNumberOfActiveOTG + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*StutterEfficiencyNotIncludingVBlank > 0) {\n\t\tLastStutterPeriod = VActiveTimeCriticalSurface - (*NumberOfStutterBurstsPerFrame - 1) * *StutterPeriod;\n\n\t\tif ((SynchronizeTimingsFinal || TotalNumberOfActiveOTG == 1) && SameTiming\n\t\t\t\t&& LastStutterPeriod + MinTTUVBlankCriticalSurface > StutterEnterPlusExitWatermark) {\n\t\t\t*StutterEfficiency = (1 - (*NumberOfStutterBurstsPerFrame * SRExitTime\n\t\t\t\t\t\t+ StutterBurstTime * VActiveTimeCriticalSurface\n\t\t\t\t\t\t/ *StutterPeriod) / FrameTimeCriticalSurface) * 100;\n\t\t} else {\n\t\t\t*StutterEfficiency = *StutterEfficiencyNotIncludingVBlank;\n\t\t}\n\t} else {\n\t\t*StutterEfficiency = 0;\n\t}\n\n\tif (*Z8StutterEfficiencyNotIncludingVBlank > 0) {\n\t\tLastZ8StutterPeriod = VActiveTimeCriticalSurface\n\t\t\t\t- (*NumberOfStutterBurstsPerFrame - 1) * *StutterPeriod;\n\t\tif ((SynchronizeTimingsFinal || TotalNumberOfActiveOTG == 1) && SameTiming && LastZ8StutterPeriod +\n\t\t\t\tMinTTUVBlankCriticalSurface > Z8StutterEnterPlusExitWatermark) {\n\t\t\t*Z8StutterEfficiency = (1 - (*NumberOfStutterBurstsPerFrame * SRExitZ8Time + StutterBurstTime\n\t\t\t\t* VActiveTimeCriticalSurface / *StutterPeriod) / FrameTimeCriticalSurface) * 100;\n\t\t} else {\n\t\t\t*Z8StutterEfficiency = *Z8StutterEfficiencyNotIncludingVBlank;\n\t\t}\n\t} else {\n\t\t*Z8StutterEfficiency = 0.;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: LastZ8StutterPeriod = %f\\n\", __func__, LastZ8StutterPeriod);\n\tdml_print(\"DML::%s: Z8StutterEnterPlusExitWatermark = %f\\n\", __func__, Z8StutterEnterPlusExitWatermark);\n\tdml_print(\"DML::%s: StutterBurstTime = %f\\n\", __func__, StutterBurstTime);\n\tdml_print(\"DML::%s: StutterPeriod = %f\\n\", __func__, *StutterPeriod);\n\tdml_print(\"DML::%s: StutterEfficiency = %f\\n\", __func__, *StutterEfficiency);\n\tdml_print(\"DML::%s: Z8StutterEfficiency = %f\\n\", __func__, *Z8StutterEfficiency);\n\tdml_print(\"DML::%s: StutterEfficiencyNotIncludingVBlank = %f\\n\",\n\t\t\t__func__, *StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: Z8NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *Z8NumberOfStutterBurstsPerFrame);\n#endif\n\n\tSwathSizeCriticalSurface = BytePerPixelYCriticalSurface * SwathHeightYCriticalSurface\n\t\t\t* dml_ceil(SwathWidthYCriticalSurface, BlockWidth256BytesYCriticalSurface);\n\tLastChunkOfSwathSize = SwathSizeCriticalSurface % (PixelChunkSizeInKByte * 1024);\n\tMissingPartOfLastSwathOfDETSize = dml_ceil(DETBufferSizeYCriticalSurface, SwathSizeCriticalSurface)\n\t\t\t- DETBufferSizeYCriticalSurface;\n\n\t*DCHUBBUB_ARB_CSTATE_MAX_CAP_MODE = !(!UnboundedRequestEnabled && (NumberOfActiveSurfaces == 1)\n\t\t\t&& doublePlaneCriticalSurface && doublePipeCriticalSurface && (LastChunkOfSwathSize > 0)\n\t\t\t&& (LastChunkOfSwathSize <= 4096) && (MissingPartOfLastSwathOfDETSize > 0)\n\t\t\t&& (MissingPartOfLastSwathOfDETSize <= LastChunkOfSwathSize));\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: SwathSizeCriticalSurface = %d\\n\", __func__, SwathSizeCriticalSurface);\n\tdml_print(\"DML::%s: LastChunkOfSwathSize = %d\\n\", __func__, LastChunkOfSwathSize);\n\tdml_print(\"DML::%s: MissingPartOfLastSwathOfDETSize = %d\\n\", __func__, MissingPartOfLastSwathOfDETSize);\n\tdml_print(\"DML::%s: DCHUBBUB_ARB_CSTATE_MAX_CAP_MODE = %d\\n\", __func__, *DCHUBBUB_ARB_CSTATE_MAX_CAP_MODE);\n#endif\n} \n\nvoid dml32_CalculateMaxDETAndMinCompressedBufferSize(\n\t\tunsigned int    ConfigReturnBufferSizeInKByte,\n\t\tunsigned int    ROBBufferSizeInKByte,\n\t\tunsigned int MaxNumDPP,\n\t\tbool nomDETInKByteOverrideEnable, \n\t\tunsigned int nomDETInKByteOverrideValue,  \n\n\t\t \n\t\tunsigned int *MaxTotalDETInKByte,\n\t\tunsigned int *nomDETInKByte,\n\t\tunsigned int *MinCompressedBufferSizeInKByte)\n{\n\tbool     det_buff_size_override_en  = nomDETInKByteOverrideEnable;\n\tunsigned int        det_buff_size_override_val = nomDETInKByteOverrideValue;\n\n\t*MaxTotalDETInKByte = dml_ceil(((double)ConfigReturnBufferSizeInKByte +\n\t\t\t(double) ROBBufferSizeInKByte) * 4.0 / 5.0, 64);\n\t*nomDETInKByte = dml_floor((double) *MaxTotalDETInKByte / (double) MaxNumDPP, 64);\n\t*MinCompressedBufferSizeInKByte = ConfigReturnBufferSizeInKByte - *MaxTotalDETInKByte;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ConfigReturnBufferSizeInKByte = %0d\\n\", __func__, ConfigReturnBufferSizeInKByte);\n\tdml_print(\"DML::%s: ROBBufferSizeInKByte = %0d\\n\", __func__, ROBBufferSizeInKByte);\n\tdml_print(\"DML::%s: MaxNumDPP = %0d\\n\", __func__, MaxNumDPP);\n\tdml_print(\"DML::%s: MaxTotalDETInKByte = %0d\\n\", __func__, *MaxTotalDETInKByte);\n\tdml_print(\"DML::%s: nomDETInKByte = %0d\\n\", __func__, *nomDETInKByte);\n\tdml_print(\"DML::%s: MinCompressedBufferSizeInKByte = %0d\\n\", __func__, *MinCompressedBufferSizeInKByte);\n#endif\n\n\tif (det_buff_size_override_en) {\n\t\t*nomDETInKByte = det_buff_size_override_val;\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: nomDETInKByte = %0d (override)\\n\", __func__, *nomDETInKByte);\n#endif\n\t}\n} \n\nbool dml32_CalculateVActiveBandwithSupport(unsigned int NumberOfActiveSurfaces,\n\t\tdouble ReturnBW,\n\t\tbool NotUrgentLatencyHiding[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble cursor_bw[],\n\t\tdouble meta_row_bandwidth[],\n\t\tdouble dpte_row_bandwidth[],\n\t\tunsigned int NumberOfDPP[],\n\t\tdouble UrgentBurstFactorLuma[],\n\t\tdouble UrgentBurstFactorChroma[],\n\t\tdouble UrgentBurstFactorCursor[])\n{\n\tunsigned int k;\n\tbool NotEnoughUrgentLatencyHiding = false;\n\tbool CalculateVActiveBandwithSupport_val = false;\n\tdouble VActiveBandwith = 0;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (NotUrgentLatencyHiding[k]) {\n\t\t\tNotEnoughUrgentLatencyHiding = true;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tVActiveBandwith = VActiveBandwith + ReadBandwidthLuma[k] * UrgentBurstFactorLuma[k] + ReadBandwidthChroma[k] * UrgentBurstFactorChroma[k] + cursor_bw[k] * UrgentBurstFactorCursor[k] + NumberOfDPP[k] * meta_row_bandwidth[k] + NumberOfDPP[k] * dpte_row_bandwidth[k];\n\t}\n\n\tCalculateVActiveBandwithSupport_val = (VActiveBandwith <= ReturnBW) && !NotEnoughUrgentLatencyHiding;\n\n#ifdef __DML_VBA_DEBUG__\ndml_print(\"DML::%s: NotEnoughUrgentLatencyHiding        = %d\\n\", __func__, NotEnoughUrgentLatencyHiding);\ndml_print(\"DML::%s: VActiveBandwith                     = %f\\n\", __func__, VActiveBandwith);\ndml_print(\"DML::%s: ReturnBW                            = %f\\n\", __func__, ReturnBW);\ndml_print(\"DML::%s: CalculateVActiveBandwithSupport_val = %d\\n\", __func__, CalculateVActiveBandwithSupport_val);\n#endif\n\treturn CalculateVActiveBandwithSupport_val;\n}\n\nvoid dml32_CalculatePrefetchBandwithSupport(unsigned int NumberOfActiveSurfaces,\n\t\tdouble ReturnBW,\n\t\tbool NotUrgentLatencyHiding[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble PrefetchBandwidthLuma[],\n\t\tdouble PrefetchBandwidthChroma[],\n\t\tdouble cursor_bw[],\n\t\tdouble meta_row_bandwidth[],\n\t\tdouble dpte_row_bandwidth[],\n\t\tdouble cursor_bw_pre[],\n\t\tdouble prefetch_vmrow_bw[],\n\t\tunsigned int NumberOfDPP[],\n\t\tdouble UrgentBurstFactorLuma[],\n\t\tdouble UrgentBurstFactorChroma[],\n\t\tdouble UrgentBurstFactorCursor[],\n\t\tdouble UrgentBurstFactorLumaPre[],\n\t\tdouble UrgentBurstFactorChromaPre[],\n\t\tdouble UrgentBurstFactorCursorPre[],\n\t\tdouble PrefetchBW[],\n\t\tdouble VRatio[],\n\t\tdouble MaxVRatioPre,\n\n\t\t \n\t\tdouble  *MaxPrefetchBandwidth,\n\t\tdouble  *FractionOfUrgentBandwidth,\n\t\tbool *PrefetchBandwidthSupport)\n{\n\tunsigned int k;\n\tdouble ActiveBandwidthPerSurface;\n\tbool NotEnoughUrgentLatencyHiding = false;\n\tdouble TotalActiveBandwidth = 0;\n\tdouble TotalPrefetchBandwidth = 0;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (NotUrgentLatencyHiding[k]) {\n\t\t\tNotEnoughUrgentLatencyHiding = true;\n\t\t}\n\t}\n\n\t*MaxPrefetchBandwidth = 0;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tActiveBandwidthPerSurface = ReadBandwidthLuma[k] * UrgentBurstFactorLuma[k] + ReadBandwidthChroma[k] * UrgentBurstFactorChroma[k] + cursor_bw[k] * UrgentBurstFactorCursor[k] + NumberOfDPP[k] * (meta_row_bandwidth[k] + dpte_row_bandwidth[k]);\n\n\t\tTotalActiveBandwidth += ActiveBandwidthPerSurface;\n\n\t\tTotalPrefetchBandwidth = TotalPrefetchBandwidth + PrefetchBW[k] * VRatio[k];\n\n\t\t*MaxPrefetchBandwidth = *MaxPrefetchBandwidth + dml_max3(NumberOfDPP[k] * prefetch_vmrow_bw[k],\n\t\t\t\tActiveBandwidthPerSurface,\n\t\t\t\tNumberOfDPP[k] * (PrefetchBandwidthLuma[k] * UrgentBurstFactorLumaPre[k] + PrefetchBandwidthChroma[k] * UrgentBurstFactorChromaPre[k]) + cursor_bw_pre[k] * UrgentBurstFactorCursorPre[k]);\n\t}\n\n\tif (MaxVRatioPre == __DML_MAX_VRATIO_PRE__)\n\t\t*PrefetchBandwidthSupport = (*MaxPrefetchBandwidth <= ReturnBW) && (TotalPrefetchBandwidth <= TotalActiveBandwidth * __DML_MAX_BW_RATIO_PRE__) && !NotEnoughUrgentLatencyHiding;\n\telse\n\t\t*PrefetchBandwidthSupport = (*MaxPrefetchBandwidth <= ReturnBW) && !NotEnoughUrgentLatencyHiding;\n\n\t*FractionOfUrgentBandwidth = *MaxPrefetchBandwidth / ReturnBW;\n}\n\ndouble dml32_CalculateBandwidthAvailableForImmediateFlip(unsigned int NumberOfActiveSurfaces,\n\t\tdouble ReturnBW,\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble PrefetchBandwidthLuma[],\n\t\tdouble PrefetchBandwidthChroma[],\n\t\tdouble cursor_bw[],\n\t\tdouble cursor_bw_pre[],\n\t\tunsigned int NumberOfDPP[],\n\t\tdouble UrgentBurstFactorLuma[],\n\t\tdouble UrgentBurstFactorChroma[],\n\t\tdouble UrgentBurstFactorCursor[],\n\t\tdouble UrgentBurstFactorLumaPre[],\n\t\tdouble UrgentBurstFactorChromaPre[],\n\t\tdouble UrgentBurstFactorCursorPre[])\n{\n\tunsigned int k;\n\tdouble CalculateBandwidthAvailableForImmediateFlip_val = ReturnBW;\n\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tCalculateBandwidthAvailableForImmediateFlip_val = CalculateBandwidthAvailableForImmediateFlip_val - dml_max(ReadBandwidthLuma[k] * UrgentBurstFactorLuma[k] + ReadBandwidthChroma[k] * UrgentBurstFactorChroma[k] + cursor_bw[k] * UrgentBurstFactorCursor[k],\n\t\t\t\tNumberOfDPP[k] * (PrefetchBandwidthLuma[k] * UrgentBurstFactorLumaPre[k] + PrefetchBandwidthChroma[k] * UrgentBurstFactorChromaPre[k]) + cursor_bw_pre[k] * UrgentBurstFactorCursorPre[k]);\n\t}\n\n\treturn CalculateBandwidthAvailableForImmediateFlip_val;\n}\n\nvoid dml32_CalculateImmediateFlipBandwithSupport(unsigned int NumberOfActiveSurfaces,\n\t\tdouble ReturnBW,\n\t\tenum immediate_flip_requirement ImmediateFlipRequirement[],\n\t\tdouble final_flip_bw[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tdouble PrefetchBandwidthLuma[],\n\t\tdouble PrefetchBandwidthChroma[],\n\t\tdouble cursor_bw[],\n\t\tdouble meta_row_bandwidth[],\n\t\tdouble dpte_row_bandwidth[],\n\t\tdouble cursor_bw_pre[],\n\t\tdouble prefetch_vmrow_bw[],\n\t\tunsigned int NumberOfDPP[],\n\t\tdouble UrgentBurstFactorLuma[],\n\t\tdouble UrgentBurstFactorChroma[],\n\t\tdouble UrgentBurstFactorCursor[],\n\t\tdouble UrgentBurstFactorLumaPre[],\n\t\tdouble UrgentBurstFactorChromaPre[],\n\t\tdouble UrgentBurstFactorCursorPre[],\n\n\t\t \n\t\tdouble  *TotalBandwidth,\n\t\tdouble  *FractionOfUrgentBandwidth,\n\t\tbool *ImmediateFlipBandwidthSupport)\n{\n\tunsigned int k;\n\t*TotalBandwidth = 0;\n\tfor (k = 0; k < NumberOfActiveSurfaces; ++k) {\n\t\tif (ImmediateFlipRequirement[k] != dm_immediate_flip_not_required) {\n\t\t\t*TotalBandwidth = *TotalBandwidth + dml_max3(NumberOfDPP[k] * prefetch_vmrow_bw[k],\n\t\t\t\t\tNumberOfDPP[k] * final_flip_bw[k] + ReadBandwidthLuma[k] * UrgentBurstFactorLuma[k] + ReadBandwidthChroma[k] * UrgentBurstFactorChroma[k] + cursor_bw[k] * UrgentBurstFactorCursor[k],\n\t\t\t\t\tNumberOfDPP[k] * (final_flip_bw[k] + PrefetchBandwidthLuma[k] * UrgentBurstFactorLumaPre[k] + PrefetchBandwidthChroma[k] * UrgentBurstFactorChromaPre[k]) + cursor_bw_pre[k] * UrgentBurstFactorCursorPre[k]);\n\t\t} else {\n\t\t\t*TotalBandwidth = *TotalBandwidth + dml_max3(NumberOfDPP[k] * prefetch_vmrow_bw[k],\n\t\t\t\t\tNumberOfDPP[k] * (meta_row_bandwidth[k] + dpte_row_bandwidth[k]) + ReadBandwidthLuma[k] * UrgentBurstFactorLuma[k] + ReadBandwidthChroma[k] * UrgentBurstFactorChroma[k] + cursor_bw[k] * UrgentBurstFactorCursor[k],\n\t\t\t\t\tNumberOfDPP[k] * (PrefetchBandwidthLuma[k] * UrgentBurstFactorLumaPre[k] + PrefetchBandwidthChroma[k] * UrgentBurstFactorChromaPre[k]) + cursor_bw_pre[k] * UrgentBurstFactorCursorPre[k]);\n\t\t}\n\t}\n\t*ImmediateFlipBandwidthSupport = (*TotalBandwidth <= ReturnBW);\n\t*FractionOfUrgentBandwidth = *TotalBandwidth / ReturnBW;\n}\n\nbool dml32_CalculateDETSwathFillLatencyHiding(unsigned int NumberOfActiveSurfaces,\n\t\tdouble ReturnBW,\n\t\tdouble UrgentLatency,\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tunsigned int SwathWidthY[],\n\t\tunsigned int SwathWidthC[],\n\t\tdouble  BytePerPixelInDETY[],\n\t\tdouble  BytePerPixelInDETC[],\n\t\tunsigned int    DETBufferSizeY[],\n\t\tunsigned int    DETBufferSizeC[],\n\t\tunsigned int\tNumOfDPP[],\n\t\tunsigned int\tHTotal[],\n\t\tdouble\tPixelClock[],\n\t\tdouble\tVRatioY[],\n\t\tdouble\tVRatioC[],\n\t\tenum dm_use_mall_for_pstate_change_mode UsesMALLForPStateChange[],\n\t\tenum unbounded_requesting_policy UseUnboundedRequesting)\n{\n\tint k;\n\tdouble SwathSizeAllSurfaces = 0;\n\tdouble SwathSizeAllSurfacesInFetchTimeUs;\n\tdouble DETSwathLatencyHidingUs;\n\tdouble DETSwathLatencyHidingYUs;\n\tdouble DETSwathLatencyHidingCUs;\n\tdouble SwathSizePerSurfaceY[DC__NUM_DPP__MAX];\n\tdouble SwathSizePerSurfaceC[DC__NUM_DPP__MAX];\n\tbool NotEnoughDETSwathFillLatencyHiding = false;\n\n\tif (UseUnboundedRequesting == dm_unbounded_requesting)\n\t\treturn false;\n\n\t \n\tfor (k = 0; k < NumberOfActiveSurfaces; k++) {\n\t\tSwathSizePerSurfaceY[k] = SwathHeightY[k] * SwathWidthY[k] * BytePerPixelInDETY[k] * NumOfDPP[k];\n\n\t\tif (SwathHeightC[k] != 0)\n\t\t\tSwathSizePerSurfaceC[k] = SwathHeightC[k] * SwathWidthC[k] * BytePerPixelInDETC[k] * NumOfDPP[k];\n\t\telse\n\t\t\tSwathSizePerSurfaceC[k] = 0;\n\n\t\tSwathSizeAllSurfaces += SwathSizePerSurfaceY[k] + SwathSizePerSurfaceC[k];\n\t}\n\n\tSwathSizeAllSurfacesInFetchTimeUs = SwathSizeAllSurfaces / ReturnBW + UrgentLatency;\n\n\t \n\tfor (k = 0; k < NumberOfActiveSurfaces; k++) {\n\t\tdouble LineTime = HTotal[k] / PixelClock[k];\n\n\t\t \n\t\tif (UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {\n\t\t\tDETSwathLatencyHidingYUs = (dml_floor(DETBufferSizeY[k] / BytePerPixelInDETY[k] / SwathWidthY[k], 1.0) - SwathHeightY[k]) / VRatioY[k] * LineTime;\n\n\t\t\tif (SwathHeightC[k] != 0) {\n\t\t\t\tDETSwathLatencyHidingCUs = (dml_floor(DETBufferSizeC[k] / BytePerPixelInDETC[k] / SwathWidthC[k], 1.0) - SwathHeightC[k]) / VRatioC[k] * LineTime;\n\n\t\t\t\tDETSwathLatencyHidingUs = dml_min(DETSwathLatencyHidingYUs, DETSwathLatencyHidingCUs);\n\t\t\t} else {\n\t\t\t\tDETSwathLatencyHidingUs = DETSwathLatencyHidingYUs;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (DETSwathLatencyHidingUs < SwathSizeAllSurfacesInFetchTimeUs) {\n\t\t\t\tNotEnoughDETSwathFillLatencyHiding = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NotEnoughDETSwathFillLatencyHiding;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}