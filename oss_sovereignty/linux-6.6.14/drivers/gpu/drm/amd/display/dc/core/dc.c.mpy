{
  "module_name": "dc.c",
  "hash_id": "1f35e6b14fecfa2c0c134b6e213f46b51e41075c1c9863fa0c6a1f05f19c01b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"dc.h\"\n\n#include \"core_status.h\"\n#include \"core_types.h\"\n#include \"hw_sequencer.h\"\n#include \"dce/dce_hwseq.h\"\n\n#include \"resource.h\"\n\n#include \"gpio_service_interface.h\"\n#include \"clk_mgr.h\"\n#include \"clock_source.h\"\n#include \"dc_bios_types.h\"\n\n#include \"bios_parser_interface.h\"\n#include \"bios/bios_parser_helper.h\"\n#include \"include/irq_service_interface.h\"\n#include \"transform.h\"\n#include \"dmcu.h\"\n#include \"dpp.h\"\n#include \"timing_generator.h\"\n#include \"abm.h\"\n#include \"virtual/virtual_link_encoder.h\"\n#include \"hubp.h\"\n\n#include \"link_hwss.h\"\n#include \"link_encoder.h\"\n#include \"link_enc_cfg.h\"\n\n#include \"link.h\"\n#include \"dm_helpers.h\"\n#include \"mem_input.h\"\n\n#include \"dc_dmub_srv.h\"\n\n#include \"dsc.h\"\n\n#include \"vm_helper.h\"\n\n#include \"dce/dce_i2c.h\"\n\n#include \"dmub/dmub_srv.h\"\n\n#include \"dce/dmub_psr.h\"\n\n#include \"dce/dmub_hw_lock_mgr.h\"\n\n#include \"dc_trace.h\"\n\n#include \"hw_sequencer_private.h\"\n\n#include \"dce/dmub_outbox.h\"\n\n#define CTX \\\n\tdc->ctx\n\n#define DC_LOGGER \\\n\tdc->ctx->logger\n\nstatic const char DC_BUILD_ID[] = \"production-build\";\n\n \n\n \n\nstatic inline void elevate_update_type(enum surface_update_type *original, enum surface_update_type new)\n{\n\tif (new > *original)\n\t\t*original = new;\n}\n\nstatic void destroy_links(struct dc *dc)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tif (NULL != dc->links[i])\n\t\t\tdc->link_srv->destroy_link(&dc->links[i]);\n\t}\n}\n\nstatic uint32_t get_num_of_internal_disp(struct dc_link **links, uint32_t num_links)\n{\n\tint i;\n\tuint32_t count = 0;\n\n\tfor (i = 0; i < num_links; i++) {\n\t\tif (links[i]->connector_signal == SIGNAL_TYPE_EDP ||\n\t\t\t\tlinks[i]->is_internal_display)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int get_seamless_boot_stream_count(struct dc_state *ctx)\n{\n\tuint8_t i;\n\tuint8_t seamless_boot_stream_count = 0;\n\n\tfor (i = 0; i < ctx->stream_count; i++)\n\t\tif (ctx->streams[i]->apply_seamless_boot_optimization)\n\t\t\tseamless_boot_stream_count++;\n\n\treturn seamless_boot_stream_count;\n}\n\nstatic bool create_links(\n\t\tstruct dc *dc,\n\t\tuint32_t num_virtual_links)\n{\n\tint i;\n\tint connectors_num;\n\tstruct dc_bios *bios = dc->ctx->dc_bios;\n\n\tdc->link_count = 0;\n\n\tconnectors_num = bios->funcs->get_connectors_number(bios);\n\n\tDC_LOG_DC(\"BIOS object table - number of connectors: %d\", connectors_num);\n\n\tif (connectors_num > ENUM_ID_COUNT) {\n\t\tdm_error(\n\t\t\t\"DC: Number of connectors %d exceeds maximum of %d!\\n\",\n\t\t\tconnectors_num,\n\t\t\tENUM_ID_COUNT);\n\t\treturn false;\n\t}\n\n\tdm_output_to_console(\n\t\t\"DC: %s: connectors_num: physical:%d, virtual:%d\\n\",\n\t\t__func__,\n\t\tconnectors_num,\n\t\tnum_virtual_links);\n\n\tfor (i = 0; i < connectors_num; i++) {\n\t\tstruct link_init_data link_init_params = {0};\n\t\tstruct dc_link *link;\n\n\t\tDC_LOG_DC(\"BIOS object table - printing link object info for connector number: %d, link_index: %d\", i, dc->link_count);\n\n\t\tlink_init_params.ctx = dc->ctx;\n\t\t \n\t\tlink_init_params.connector_index = i;\n\t\tlink_init_params.link_index = dc->link_count;\n\t\tlink_init_params.dc = dc;\n\t\tlink = dc->link_srv->create_link(&link_init_params);\n\n\t\tif (link) {\n\t\t\tdc->links[dc->link_count] = link;\n\t\t\tlink->dc = dc;\n\t\t\t++dc->link_count;\n\t\t}\n\t}\n\n\tDC_LOG_DC(\"BIOS object table - end\");\n\n\t \n\tfor (i = 0; i < dc->res_pool->usb4_dpia_count; i++) {\n\t\tstruct link_init_data link_init_params = {0};\n\t\tstruct dc_link *link;\n\n\t\tlink_init_params.ctx = dc->ctx;\n\t\tlink_init_params.connector_index = i;\n\t\tlink_init_params.link_index = dc->link_count;\n\t\tlink_init_params.dc = dc;\n\t\tlink_init_params.is_dpia_link = true;\n\n\t\tlink = dc->link_srv->create_link(&link_init_params);\n\t\tif (link) {\n\t\t\tdc->links[dc->link_count] = link;\n\t\t\tlink->dc = dc;\n\t\t\t++dc->link_count;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_virtual_links; i++) {\n\t\tstruct dc_link *link = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tstruct encoder_init_data enc_init = {0};\n\n\t\tif (link == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto failed_alloc;\n\t\t}\n\n\t\tlink->link_index = dc->link_count;\n\t\tdc->links[dc->link_count] = link;\n\t\tdc->link_count++;\n\n\t\tlink->ctx = dc->ctx;\n\t\tlink->dc = dc;\n\t\tlink->connector_signal = SIGNAL_TYPE_VIRTUAL;\n\t\tlink->link_id.type = OBJECT_TYPE_CONNECTOR;\n\t\tlink->link_id.id = CONNECTOR_ID_VIRTUAL;\n\t\tlink->link_id.enum_id = ENUM_ID_1;\n\t\tlink->link_enc = kzalloc(sizeof(*link->link_enc), GFP_KERNEL);\n\n\t\tif (!link->link_enc) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto failed_alloc;\n\t\t}\n\n\t\tlink->link_status.dpcd_caps = &link->dpcd_caps;\n\n\t\tenc_init.ctx = dc->ctx;\n\t\tenc_init.channel = CHANNEL_ID_UNKNOWN;\n\t\tenc_init.hpd_source = HPD_SOURCEID_UNKNOWN;\n\t\tenc_init.transmitter = TRANSMITTER_UNKNOWN;\n\t\tenc_init.connector = link->link_id;\n\t\tenc_init.encoder.type = OBJECT_TYPE_ENCODER;\n\t\tenc_init.encoder.id = ENCODER_ID_INTERNAL_VIRTUAL;\n\t\tenc_init.encoder.enum_id = ENUM_ID_1;\n\t\tvirtual_link_encoder_construct(link->link_enc, &enc_init);\n\t}\n\n\tdc->caps.num_of_internal_disp = get_num_of_internal_disp(dc->links, dc->link_count);\n\n\treturn true;\n\nfailed_alloc:\n\treturn false;\n}\n\n \nstatic bool create_link_encoders(struct dc *dc)\n{\n\tbool res = true;\n\tunsigned int num_usb4_dpia = dc->res_pool->res_cap->num_usb4_dpia;\n\tunsigned int num_dig_link_enc = dc->res_pool->res_cap->num_dig_link_enc;\n\tint i;\n\n\t \n\tif (num_usb4_dpia == 0)\n\t\treturn res;\n\n\t \n\tif (num_dig_link_enc > dc->res_pool->dig_link_enc_count) {\n\t\tfor (i = 0; i < num_dig_link_enc; i++) {\n\t\t\tstruct link_encoder *link_enc = dc->res_pool->link_encoders[i];\n\n\t\t\tif (!link_enc && dc->res_pool->funcs->link_enc_create_minimal) {\n\t\t\t\tlink_enc = dc->res_pool->funcs->link_enc_create_minimal(dc->ctx,\n\t\t\t\t\t\t(enum engine_id)(ENGINE_ID_DIGA + i));\n\t\t\t\tif (link_enc) {\n\t\t\t\t\tdc->res_pool->link_encoders[i] = link_enc;\n\t\t\t\t\tdc->res_pool->dig_link_enc_count++;\n\t\t\t\t} else {\n\t\t\t\t\tres = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \nstatic void destroy_link_encoders(struct dc *dc)\n{\n\tunsigned int num_usb4_dpia;\n\tunsigned int num_dig_link_enc;\n\tint i;\n\n\tif (!dc->res_pool)\n\t\treturn;\n\n\tnum_usb4_dpia = dc->res_pool->res_cap->num_usb4_dpia;\n\tnum_dig_link_enc = dc->res_pool->res_cap->num_dig_link_enc;\n\n\t \n\tif (num_usb4_dpia == 0)\n\t\treturn;\n\n\tfor (i = 0; i < num_dig_link_enc; i++) {\n\t\tstruct link_encoder *link_enc = dc->res_pool->link_encoders[i];\n\n\t\tif (link_enc) {\n\t\t\tlink_enc->funcs->destroy(&link_enc);\n\t\t\tdc->res_pool->link_encoders[i] = NULL;\n\t\t\tdc->res_pool->dig_link_enc_count--;\n\t\t}\n\t}\n}\n\nstatic struct dc_perf_trace *dc_perf_trace_create(void)\n{\n\treturn kzalloc(sizeof(struct dc_perf_trace), GFP_KERNEL);\n}\n\nstatic void dc_perf_trace_destroy(struct dc_perf_trace **perf_trace)\n{\n\tkfree(*perf_trace);\n\t*perf_trace = NULL;\n}\n\n \nbool dc_stream_adjust_vmin_vmax(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_crtc_timing_adjust *adjust)\n{\n\tint i;\n\n\t \n\tif (dc->ctx->dce_version > DCE_VERSION_MAX)\n\t\tif (dc->optimized_required || dc->wm_optimized_required)\n\t\t\treturn false;\n\n\tstream->adjust.v_total_max = adjust->v_total_max;\n\tstream->adjust.v_total_mid = adjust->v_total_mid;\n\tstream->adjust.v_total_mid_frame_num = adjust->v_total_mid_frame_num;\n\tstream->adjust.v_total_min = adjust->v_total_min;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.tg) {\n\t\t\tdc->hwss.set_drr(&pipe,\n\t\t\t\t\t1,\n\t\t\t\t\t*adjust);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nbool dc_stream_get_last_used_drr_vtotal(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tuint32_t *refresh_rate)\n{\n\tbool status = false;\n\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.tg) {\n\t\t\t \n\t\t\tif (pipe->stream_res.tg->funcs->get_last_used_drr_vtotal) {\n\t\t\t\tpipe->stream_res.tg->funcs->get_last_used_drr_vtotal(pipe->stream_res.tg, refresh_rate);\n\n\t\t\t\tstatus = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nbool dc_stream_get_crtc_position(struct dc *dc,\n\t\tstruct dc_stream_state **streams, int num_streams,\n\t\tunsigned int *v_pos, unsigned int *nom_v_pos)\n{\n\t \n\tconst struct dc_stream_state *stream = streams[0];\n\tint i;\n\tbool ret = false;\n\tstruct crtc_position position;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe =\n\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.stream_enc) {\n\t\t\tdc->hwss.get_position(&pipe, 1, &position);\n\n\t\t\t*v_pos = position.vertical_count;\n\t\t\t*nom_v_pos = position.nominal_vcount;\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\nstatic inline void\ndc_stream_forward_dmub_crc_window(struct dc_dmub_srv *dmub_srv,\n\t\tstruct rect *rect, struct otg_phy_mux *mux_mapping, bool is_stop)\n{\n\tunion dmub_rb_cmd cmd = {0};\n\n\tcmd.secure_display.roi_info.phy_id = mux_mapping->phy_output_num;\n\tcmd.secure_display.roi_info.otg_id = mux_mapping->otg_output_num;\n\n\tif (is_stop) {\n\t\tcmd.secure_display.header.type = DMUB_CMD__SECURE_DISPLAY;\n\t\tcmd.secure_display.header.sub_type = DMUB_CMD__SECURE_DISPLAY_CRC_STOP_UPDATE;\n\t} else {\n\t\tcmd.secure_display.header.type = DMUB_CMD__SECURE_DISPLAY;\n\t\tcmd.secure_display.header.sub_type = DMUB_CMD__SECURE_DISPLAY_CRC_WIN_NOTIFY;\n\t\tcmd.secure_display.roi_info.x_start = rect->x;\n\t\tcmd.secure_display.roi_info.y_start = rect->y;\n\t\tcmd.secure_display.roi_info.x_end = rect->x + rect->width;\n\t\tcmd.secure_display.roi_info.y_end = rect->y + rect->height;\n\t}\n\n\tdm_execute_dmub_cmd(dmub_srv->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n}\n\nstatic inline void\ndc_stream_forward_dmcu_crc_window(struct dmcu *dmcu,\n\t\tstruct rect *rect, struct otg_phy_mux *mux_mapping, bool is_stop)\n{\n\tif (is_stop)\n\t\tdmcu->funcs->stop_crc_win_update(dmcu, mux_mapping);\n\telse\n\t\tdmcu->funcs->forward_crc_window(dmcu, rect, mux_mapping);\n}\n\nbool\ndc_stream_forward_crc_window(struct dc_stream_state *stream,\n\t\tstruct rect *rect, bool is_stop)\n{\n\tstruct dmcu *dmcu;\n\tstruct dc_dmub_srv *dmub_srv;\n\tstruct otg_phy_mux mux_mapping;\n\tstruct pipe_ctx *pipe;\n\tint i;\n\tstruct dc *dc = stream->ctx->dc;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe->stream == stream && !pipe->top_pipe && !pipe->prev_odm_pipe)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == MAX_PIPES)\n\t\treturn false;\n\n\tmux_mapping.phy_output_num = stream->link->link_enc_hw_inst;\n\tmux_mapping.otg_output_num = pipe->stream_res.tg->inst;\n\n\tdmcu = dc->res_pool->dmcu;\n\tdmub_srv = dc->ctx->dmub_srv;\n\n\t \n\tif (dmub_srv)\n\t\tdc_stream_forward_dmub_crc_window(dmub_srv, rect, &mux_mapping, is_stop);\n\t \n\telse if (dmcu && dmcu->funcs->is_dmcu_initialized(dmcu))\n\t\tdc_stream_forward_dmcu_crc_window(dmcu, rect, &mux_mapping, is_stop);\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n#endif  \n\n \nbool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,\n\t\t\t     struct crc_params *crc_window, bool enable, bool continuous)\n{\n\tstruct pipe_ctx *pipe;\n\tstruct crc_params param;\n\tstruct timing_generator *tg;\n\n\tpipe = resource_get_otg_master_for_stream(\n\t\t\t&dc->current_state->res_ctx, stream);\n\n\t \n\tif (pipe == NULL)\n\t\treturn false;\n\n\t \n\tparam.windowa_x_start = 0;\n\tparam.windowa_y_start = 0;\n\tparam.windowa_x_end = pipe->stream->timing.h_addressable;\n\tparam.windowa_y_end = pipe->stream->timing.v_addressable;\n\tparam.windowb_x_start = 0;\n\tparam.windowb_y_start = 0;\n\tparam.windowb_x_end = pipe->stream->timing.h_addressable;\n\tparam.windowb_y_end = pipe->stream->timing.v_addressable;\n\n\tif (crc_window) {\n\t\tparam.windowa_x_start = crc_window->windowa_x_start;\n\t\tparam.windowa_y_start = crc_window->windowa_y_start;\n\t\tparam.windowa_x_end = crc_window->windowa_x_end;\n\t\tparam.windowa_y_end = crc_window->windowa_y_end;\n\t\tparam.windowb_x_start = crc_window->windowb_x_start;\n\t\tparam.windowb_y_start = crc_window->windowb_y_start;\n\t\tparam.windowb_x_end = crc_window->windowb_x_end;\n\t\tparam.windowb_y_end = crc_window->windowb_y_end;\n\t}\n\n\tparam.dsc_mode = pipe->stream->timing.flags.DSC ? 1:0;\n\tparam.odm_mode = pipe->next_odm_pipe ? 1:0;\n\n\t \n\tparam.selection = UNION_WINDOW_A_B;\n\tparam.continuous_mode = continuous;\n\tparam.enable = enable;\n\n\ttg = pipe->stream_res.tg;\n\n\t \n\tif (tg->funcs->configure_crc)\n\t\treturn tg->funcs->configure_crc(tg, &param);\n\tDC_LOG_WARNING(\"CRC capture not supported.\");\n\treturn false;\n}\n\n \nbool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,\n\t\t       uint32_t *r_cr, uint32_t *g_y, uint32_t *b_cb)\n{\n\tint i;\n\tstruct pipe_ctx *pipe;\n\tstruct timing_generator *tg;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe->stream == stream)\n\t\t\tbreak;\n\t}\n\t \n\tif (i == MAX_PIPES)\n\t\treturn false;\n\n\ttg = pipe->stream_res.tg;\n\n\tif (tg->funcs->get_crc)\n\t\treturn tg->funcs->get_crc(tg, r_cr, g_y, b_cb);\n\tDC_LOG_WARNING(\"CRC capture not supported.\");\n\treturn false;\n}\n\nvoid dc_stream_set_dyn_expansion(struct dc *dc, struct dc_stream_state *stream,\n\t\tenum dc_dynamic_expansion option)\n{\n\t \n\tint i;\n\tstruct pipe_ctx *pipe_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream\n\t\t\t\t== stream) {\n\t\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tpipe_ctx->stream_res.opp->dyn_expansion = option;\n\t\t\tpipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(\n\t\t\t\t\tpipe_ctx->stream_res.opp,\n\t\t\t\t\tCOLOR_SPACE_YCBCR601,\n\t\t\t\t\tstream->timing.display_color_depth,\n\t\t\t\t\tstream->signal);\n\t\t}\n\t}\n}\n\nvoid dc_stream_set_dither_option(struct dc_stream_state *stream,\n\t\tenum dc_dither_option option)\n{\n\tstruct bit_depth_reduction_params params;\n\tstruct dc_link *link = stream->link;\n\tstruct pipe_ctx *pipes = NULL;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (link->dc->current_state->res_ctx.pipe_ctx[i].stream ==\n\t\t\t\tstream) {\n\t\t\tpipes = &link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pipes)\n\t\treturn;\n\tif (option > DITHER_OPTION_MAX)\n\t\treturn;\n\n\tstream->dither_option = option;\n\n\tmemset(&params, 0, sizeof(params));\n\tresource_build_bit_depth_reduction_params(stream, &params);\n\tstream->bit_depth_params = params;\n\n\tif (pipes->plane_res.xfm &&\n\t    pipes->plane_res.xfm->funcs->transform_set_pixel_storage_depth) {\n\t\tpipes->plane_res.xfm->funcs->transform_set_pixel_storage_depth(\n\t\t\tpipes->plane_res.xfm,\n\t\t\tpipes->plane_res.scl_data.lb_params.depth,\n\t\t\t&stream->bit_depth_params);\n\t}\n\n\tpipes->stream_res.opp->funcs->\n\t\topp_program_bit_depth_reduction(pipes->stream_res.opp, &params);\n}\n\nbool dc_stream_set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)\n{\n\tint i;\n\tbool ret = false;\n\tstruct pipe_ctx *pipes;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {\n\t\t\tpipes = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tdc->hwss.program_gamut_remap(pipes);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)\n{\n\tint i;\n\tbool ret = false;\n\tstruct pipe_ctx *pipes;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream\n\t\t\t\t== stream) {\n\n\t\t\tpipes = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tdc->hwss.program_output_csc(dc,\n\t\t\t\t\tpipes,\n\t\t\t\t\tstream->output_color_space,\n\t\t\t\t\tstream->csc_color_matrix.matrix,\n\t\t\t\t\tpipes->stream_res.opp->inst);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid dc_stream_set_static_screen_params(struct dc *dc,\n\t\tstruct dc_stream_state **streams,\n\t\tint num_streams,\n\t\tconst struct dc_static_screen_params *params)\n{\n\tint i, j;\n\tstruct pipe_ctx *pipes_affected[MAX_PIPES];\n\tint num_pipes_affected = 0;\n\n\tfor (i = 0; i < num_streams; i++) {\n\t\tstruct dc_stream_state *stream = streams[i];\n\n\t\tfor (j = 0; j < MAX_PIPES; j++) {\n\t\t\tif (dc->current_state->res_ctx.pipe_ctx[j].stream\n\t\t\t\t\t== stream) {\n\t\t\t\tpipes_affected[num_pipes_affected++] =\n\t\t\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tdc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, params);\n}\n\nstatic void dc_destruct(struct dc *dc)\n{\n\t\n\tif (dc->res_pool && dc->res_pool->funcs->link_encs_assign)\n\t\tlink_enc_cfg_init(dc, dc->current_state);\n\n\tif (dc->current_state) {\n\t\tdc_release_state(dc->current_state);\n\t\tdc->current_state = NULL;\n\t}\n\n\tdestroy_links(dc);\n\n\tdestroy_link_encoders(dc);\n\n\tif (dc->clk_mgr) {\n\t\tdc_destroy_clk_mgr(dc->clk_mgr);\n\t\tdc->clk_mgr = NULL;\n\t}\n\n\tdc_destroy_resource_pool(dc);\n\n\tif (dc->link_srv)\n\t\tlink_destroy_link_service(&dc->link_srv);\n\n\tif (dc->ctx->gpio_service)\n\t\tdal_gpio_service_destroy(&dc->ctx->gpio_service);\n\n\tif (dc->ctx->created_bios)\n\t\tdal_bios_parser_destroy(&dc->ctx->dc_bios);\n\n\tdc_perf_trace_destroy(&dc->ctx->perf_trace);\n\n\tkfree(dc->ctx);\n\tdc->ctx = NULL;\n\n\tkfree(dc->bw_vbios);\n\tdc->bw_vbios = NULL;\n\n\tkfree(dc->bw_dceip);\n\tdc->bw_dceip = NULL;\n\n\tkfree(dc->dcn_soc);\n\tdc->dcn_soc = NULL;\n\n\tkfree(dc->dcn_ip);\n\tdc->dcn_ip = NULL;\n\n\tkfree(dc->vm_helper);\n\tdc->vm_helper = NULL;\n\n}\n\nstatic bool dc_construct_ctx(struct dc *dc,\n\t\tconst struct dc_init_data *init_params)\n{\n\tstruct dc_context *dc_ctx;\n\n\tdc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);\n\tif (!dc_ctx)\n\t\treturn false;\n\n\tdc_ctx->cgs_device = init_params->cgs_device;\n\tdc_ctx->driver_context = init_params->driver;\n\tdc_ctx->dc = dc;\n\tdc_ctx->asic_id = init_params->asic_id;\n\tdc_ctx->dc_sink_id_count = 0;\n\tdc_ctx->dc_stream_id_count = 0;\n\tdc_ctx->dce_environment = init_params->dce_environment;\n\tdc_ctx->dcn_reg_offsets = init_params->dcn_reg_offsets;\n\tdc_ctx->nbio_reg_offsets = init_params->nbio_reg_offsets;\n\n\t \n\n\tdc_ctx->dce_version = resource_parse_asic_id(init_params->asic_id);\n\n\tdc_ctx->perf_trace = dc_perf_trace_create();\n\tif (!dc_ctx->perf_trace) {\n\t\tkfree(dc_ctx);\n\t\tASSERT_CRITICAL(false);\n\t\treturn false;\n\t}\n\n\tdc->ctx = dc_ctx;\n\n\tdc->link_srv = link_create_link_service();\n\tif (!dc->link_srv)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool dc_construct(struct dc *dc,\n\t\tconst struct dc_init_data *init_params)\n{\n\tstruct dc_context *dc_ctx;\n\tstruct bw_calcs_dceip *dc_dceip;\n\tstruct bw_calcs_vbios *dc_vbios;\n\tstruct dcn_soc_bounding_box *dcn_soc;\n\tstruct dcn_ip_params *dcn_ip;\n\n\tdc->config = init_params->flags;\n\n\t\n\tdc->vm_helper = kzalloc(sizeof(struct vm_helper), GFP_KERNEL);\n\tif (!dc->vm_helper) {\n\t\tdm_error(\"%s: failed to create dc->vm_helper\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tmemcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));\n\n\tdc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);\n\tif (!dc_dceip) {\n\t\tdm_error(\"%s: failed to create dceip\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tdc->bw_dceip = dc_dceip;\n\n\tdc_vbios = kzalloc(sizeof(*dc_vbios), GFP_KERNEL);\n\tif (!dc_vbios) {\n\t\tdm_error(\"%s: failed to create vbios\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tdc->bw_vbios = dc_vbios;\n\tdcn_soc = kzalloc(sizeof(*dcn_soc), GFP_KERNEL);\n\tif (!dcn_soc) {\n\t\tdm_error(\"%s: failed to create dcn_soc\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tdc->dcn_soc = dcn_soc;\n\n\tdcn_ip = kzalloc(sizeof(*dcn_ip), GFP_KERNEL);\n\tif (!dcn_ip) {\n\t\tdm_error(\"%s: failed to create dcn_ip\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tdc->dcn_ip = dcn_ip;\n\n\tif (!dc_construct_ctx(dc, init_params)) {\n\t\tdm_error(\"%s: failed to create ctx\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n        dc_ctx = dc->ctx;\n\n\t \n\tif (init_params->vbios_override)\n\t\tdc_ctx->dc_bios = init_params->vbios_override;\n\telse {\n\t\t \n\t\tstruct bp_init_data bp_init_data;\n\n\t\tbp_init_data.ctx = dc_ctx;\n\t\tbp_init_data.bios = init_params->asic_id.atombios_base_address;\n\n\t\tdc_ctx->dc_bios = dal_bios_parser_create(\n\t\t\t\t&bp_init_data, dc_ctx->dce_version);\n\n\t\tif (!dc_ctx->dc_bios) {\n\t\t\tASSERT_CRITICAL(false);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdc_ctx->created_bios = true;\n\t}\n\n\tdc->vendor_signature = init_params->vendor_signature;\n\n\t \n\tdc_ctx->gpio_service = dal_gpio_service_create(\n\t\t\tdc_ctx->dce_version,\n\t\t\tdc_ctx->dce_environment,\n\t\t\tdc_ctx);\n\n\tif (!dc_ctx->gpio_service) {\n\t\tASSERT_CRITICAL(false);\n\t\tgoto fail;\n\t}\n\n\tdc->res_pool = dc_create_resource_pool(dc, init_params, dc_ctx->dce_version);\n\tif (!dc->res_pool)\n\t\tgoto fail;\n\n\t \n\tif (dc->caps.i2c_speed_in_khz_hdcp == 0)\n\t\tdc->caps.i2c_speed_in_khz_hdcp = dc->caps.i2c_speed_in_khz;\n\tif (dc->caps.max_optimizable_video_width == 0)\n\t\tdc->caps.max_optimizable_video_width = 5120;\n\tdc->clk_mgr = dc_clk_mgr_create(dc->ctx, dc->res_pool->pp_smu, dc->res_pool->dccg);\n\tif (!dc->clk_mgr)\n\t\tgoto fail;\n#ifdef CONFIG_DRM_AMD_DC_FP\n\tdc->clk_mgr->force_smu_not_present = init_params->force_smu_not_present;\n\n\tif (dc->res_pool->funcs->update_bw_bounding_box) {\n\t\tDC_FP_START();\n\t\tdc->res_pool->funcs->update_bw_bounding_box(dc, dc->clk_mgr->bw_params);\n\t\tDC_FP_END();\n\t}\n#endif\n\n\t \n\n\tdc->current_state = dc_create_state(dc);\n\n\tif (!dc->current_state) {\n\t\tdm_error(\"%s: failed to create validate ctx\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\tif (!create_links(dc, init_params->num_virtual_links))\n\t\tgoto fail;\n\n\t \n\tif (!create_link_encoders(dc))\n\t\tgoto fail;\n\n\tdc_resource_state_construct(dc, dc->current_state);\n\n\treturn true;\n\nfail:\n\treturn false;\n}\n\nstatic void disable_all_writeback_pipes_for_stream(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < stream->num_wb_info; i++)\n\t\tstream->writeback_info[i].wb_enabled = false;\n}\n\nstatic void apply_ctx_interdependent_lock(struct dc *dc,\n\t\t\t\t\t  struct dc_state *context,\n\t\t\t\t\t  struct dc_stream_state *stream,\n\t\t\t\t\t  bool lock)\n{\n\tint i;\n\n\t \n\tif (dc->hwss.interdependent_update_lock)\n\t\tdc->hwss.interdependent_update_lock(dc, context, lock);\n\telse {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\tstruct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\t\t\n\t\t\tif (stream == pipe_ctx->stream) {\n\t\t\t\tif (resource_is_pipe_type(pipe_ctx, OPP_HEAD) &&\n\t\t\t\t\t(pipe_ctx->plane_state || old_pipe_ctx->plane_state))\n\t\t\t\t\tdc->hwss.pipe_control_lock(dc, pipe_ctx, lock);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dc_update_viusal_confirm_color(struct dc *dc, struct dc_state *context, struct pipe_ctx *pipe_ctx)\n{\n\tif (dc->ctx->dce_version >= DCN_VERSION_1_0) {\n\t\tmemset(&pipe_ctx->visual_confirm_color, 0, sizeof(struct tg_color));\n\n\t\tif (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR)\n\t\t\tget_hdr_visual_confirm_color(pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\telse if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE)\n\t\t\tget_surface_visual_confirm_color(pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\telse if (dc->debug.visual_confirm == VISUAL_CONFIRM_SWIZZLE)\n\t\t\tget_surface_tile_visual_confirm_color(pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\telse {\n\t\t\tif (dc->ctx->dce_version < DCN_VERSION_2_0)\n\t\t\t\tcolor_space_to_black_color(\n\t\t\t\t\tdc, pipe_ctx->stream->output_color_space, &(pipe_ctx->visual_confirm_color));\n\t\t}\n\t\tif (dc->ctx->dce_version >= DCN_VERSION_2_0) {\n\t\t\tif (dc->debug.visual_confirm == VISUAL_CONFIRM_MPCTREE)\n\t\t\t\tget_mpctree_visual_confirm_color(pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\t\telse if (dc->debug.visual_confirm == VISUAL_CONFIRM_SUBVP)\n\t\t\t\tget_subvp_visual_confirm_color(dc, context, pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\t\telse if (dc->debug.visual_confirm == VISUAL_CONFIRM_MCLK_SWITCH)\n\t\t\t\tget_mclk_switch_visual_confirm_color(dc, context, pipe_ctx, &(pipe_ctx->visual_confirm_color));\n\t\t}\n\t}\n}\n\nstatic void disable_dangling_plane(struct dc *dc, struct dc_state *context)\n{\n\tint i, j;\n\tstruct dc_state *dangling_context = dc_create_state(dc);\n\tstruct dc_state *current_ctx;\n\tstruct pipe_ctx *pipe;\n\tstruct timing_generator *tg;\n\n\tif (dangling_context == NULL)\n\t\treturn;\n\n\tdc_resource_state_copy_construct(dc->current_state, dangling_context);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_stream_state *old_stream =\n\t\t\t\tdc->current_state->res_ctx.pipe_ctx[i].stream;\n\t\tbool should_disable = true;\n\t\tbool pipe_split_change = false;\n\n\t\tif ((context->res_ctx.pipe_ctx[i].top_pipe) &&\n\t\t\t(dc->current_state->res_ctx.pipe_ctx[i].top_pipe))\n\t\t\tpipe_split_change = context->res_ctx.pipe_ctx[i].top_pipe->pipe_idx !=\n\t\t\t\tdc->current_state->res_ctx.pipe_ctx[i].top_pipe->pipe_idx;\n\t\telse\n\t\t\tpipe_split_change = context->res_ctx.pipe_ctx[i].top_pipe !=\n\t\t\t\tdc->current_state->res_ctx.pipe_ctx[i].top_pipe;\n\n\t\tfor (j = 0; j < context->stream_count; j++) {\n\t\t\tif (old_stream == context->streams[j]) {\n\t\t\t\tshould_disable = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!should_disable && pipe_split_change &&\n\t\t\t\tdc->current_state->stream_count != context->stream_count)\n\t\t\tshould_disable = true;\n\n\t\tif (old_stream && !dc->current_state->res_ctx.pipe_ctx[i].top_pipe &&\n\t\t\t\t!dc->current_state->res_ctx.pipe_ctx[i].prev_odm_pipe) {\n\t\t\tstruct pipe_ctx *old_pipe, *new_pipe;\n\n\t\t\told_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tnew_pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (old_pipe->plane_state && !new_pipe->plane_state)\n\t\t\t\tshould_disable = true;\n\t\t}\n\n\t\tif (should_disable && old_stream) {\n\t\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\ttg = pipe->stream_res.tg;\n\t\t\t \n\t\t\tif (old_stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\tif (tg->funcs->enable_crtc) {\n\t\t\t\t\tint main_pipe_width, main_pipe_height;\n\n\t\t\t\t\tmain_pipe_width = old_stream->mall_stream_config.paired_stream->dst.width;\n\t\t\t\t\tmain_pipe_height = old_stream->mall_stream_config.paired_stream->dst.height;\n\t\t\t\t\tif (dc->hwss.blank_phantom)\n\t\t\t\t\t\tdc->hwss.blank_phantom(dc, tg, main_pipe_width, main_pipe_height);\n\t\t\t\t\ttg->funcs->enable_crtc(tg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdc_rem_all_planes_for_stream(dc, old_stream, dangling_context);\n\t\t\tdisable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);\n\n\t\t\tif (pipe->stream && pipe->plane_state)\n\t\t\t\tdc_update_viusal_confirm_color(dc, context, pipe);\n\n\t\t\tif (dc->hwss.apply_ctx_for_surface) {\n\t\t\t\tapply_ctx_interdependent_lock(dc, dc->current_state, old_stream, true);\n\t\t\t\tdc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);\n\t\t\t\tapply_ctx_interdependent_lock(dc, dc->current_state, old_stream, false);\n\t\t\t\tdc->hwss.post_unlock_program_front_end(dc, dangling_context);\n\t\t\t}\n\t\t\tif (dc->hwss.program_front_end_for_ctx) {\n\t\t\t\tdc->hwss.interdependent_update_lock(dc, dc->current_state, true);\n\t\t\t\tdc->hwss.program_front_end_for_ctx(dc, dangling_context);\n\t\t\t\tdc->hwss.interdependent_update_lock(dc, dc->current_state, false);\n\t\t\t\tdc->hwss.post_unlock_program_front_end(dc, dangling_context);\n\t\t\t}\n\t\t\t \n\t\t\tif (old_stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\tif (tg->funcs->disable_phantom_crtc)\n\t\t\t\t\ttg->funcs->disable_phantom_crtc(tg);\n\t\t\t}\n\t\t}\n\t}\n\n\tcurrent_ctx = dc->current_state;\n\tdc->current_state = dangling_context;\n\tdc_release_state(current_ctx);\n}\n\nstatic void disable_vbios_mode_if_required(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_stream_state *stream = NULL;\n\t\tstruct dc_link *link = NULL;\n\t\tstruct pipe_ctx *pipe = NULL;\n\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\tstream = pipe->stream;\n\t\tif (stream == NULL)\n\t\t\tcontinue;\n\n\t\tif (stream->apply_seamless_boot_optimization)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (pipe->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tif (stream->link->local_sink &&\n\t\t\tstream->link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\t\tlink = stream->link;\n\t\t}\n\n\t\tif (link != NULL && link->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tunsigned int enc_inst, tg_inst = 0;\n\t\t\tunsigned int pix_clk_100hz;\n\n\t\t\tenc_inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);\n\t\t\tif (enc_inst != ENGINE_ID_UNKNOWN) {\n\t\t\t\tfor (j = 0; j < dc->res_pool->stream_enc_count; j++) {\n\t\t\t\t\tif (dc->res_pool->stream_enc[j]->id == enc_inst) {\n\t\t\t\t\t\ttg_inst = dc->res_pool->stream_enc[j]->funcs->dig_source_otg(\n\t\t\t\t\t\t\tdc->res_pool->stream_enc[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(\n\t\t\t\t\tdc->res_pool->dp_clock_source,\n\t\t\t\t\ttg_inst, &pix_clk_100hz);\n\n\t\t\t\tif (link->link_status.link_active) {\n\t\t\t\t\tuint32_t requested_pix_clk_100hz =\n\t\t\t\t\t\tpipe->stream_res.pix_clk_params.requested_pix_clk_100hz;\n\n\t\t\t\t\tif (pix_clk_100hz != requested_pix_clk_100hz) {\n\t\t\t\t\t\tdc->link_srv->set_dpms_off(pipe);\n\t\t\t\t\t\tpipe->stream->dpms_off = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void wait_for_no_pipes_pending(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tPERF_TRACE();\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tint count = 0;\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->plane_state || pipe->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (count < 100000) {\n\t\t\t \n\t\t\tpipe->plane_state->status.is_flip_pending = false;\n\t\t\tdc->hwss.update_pending_status(pipe);\n\t\t\tif (!pipe->plane_state->status.is_flip_pending)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t\tcount++;\n\t\t}\n\t\tASSERT(!pipe->plane_state->status.is_flip_pending);\n\t}\n\tPERF_TRACE();\n}\n\n \n\nstruct dc *dc_create(const struct dc_init_data *init_params)\n{\n\tstruct dc *dc = kzalloc(sizeof(*dc), GFP_KERNEL);\n\tunsigned int full_pipe_count;\n\n\tif (!dc)\n\t\treturn NULL;\n\n\tif (init_params->dce_environment == DCE_ENV_VIRTUAL_HW) {\n\t\tif (!dc_construct_ctx(dc, init_params))\n\t\t\tgoto destruct_dc;\n\t} else {\n\t\tif (!dc_construct(dc, init_params))\n\t\t\tgoto destruct_dc;\n\n\t\tfull_pipe_count = dc->res_pool->pipe_count;\n\t\tif (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)\n\t\t\tfull_pipe_count--;\n\t\tdc->caps.max_streams = min(\n\t\t\t\tfull_pipe_count,\n\t\t\t\tdc->res_pool->stream_enc_count);\n\n\t\tdc->caps.max_links = dc->link_count;\n\t\tdc->caps.max_audios = dc->res_pool->audio_count;\n\t\tdc->caps.linear_pitch_alignment = 64;\n\n\t\tdc->caps.max_dp_protocol_version = DP_VERSION_1_4;\n\n\t\tdc->caps.max_otg_num = dc->res_pool->res_cap->num_timing_generator;\n\n\t\tif (dc->res_pool->dmcu != NULL)\n\t\t\tdc->versions.dmcu_version = dc->res_pool->dmcu->dmcu_version;\n\t}\n\n\tdc->dcn_reg_offsets = init_params->dcn_reg_offsets;\n\tdc->nbio_reg_offsets = init_params->nbio_reg_offsets;\n\n\t \n\tdc->versions.dc_ver = DC_VER;\n\n\tdc->build_id = DC_BUILD_ID;\n\n\tDC_LOG_DC(\"Display Core initialized\\n\");\n\n\n\n\treturn dc;\n\ndestruct_dc:\n\tdc_destruct(dc);\n\tkfree(dc);\n\treturn NULL;\n}\n\nstatic void detect_edp_presence(struct dc *dc)\n{\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\tstruct dc_link *edp_link = NULL;\n\tenum dc_connection_type type;\n\tint i;\n\tint edp_num;\n\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\tif (!edp_num)\n\t\treturn;\n\n\tfor (i = 0; i < edp_num; i++) {\n\t\tedp_link = edp_links[i];\n\t\tif (dc->config.edp_not_connected) {\n\t\t\tedp_link->edp_sink_present = false;\n\t\t} else {\n\t\t\tdc_link_detect_connection_type(edp_link, &type);\n\t\t\tedp_link->edp_sink_present = (type != dc_connection_none);\n\t\t}\n\t}\n}\n\nvoid dc_hardware_init(struct dc *dc)\n{\n\n\tdetect_edp_presence(dc);\n\tif (dc->ctx->dce_environment != DCE_ENV_VIRTUAL_HW)\n\t\tdc->hwss.init_hw(dc);\n}\n\nvoid dc_init_callbacks(struct dc *dc,\n\t\tconst struct dc_callback_init *init_params)\n{\n\tdc->ctx->cp_psp = init_params->cp_psp;\n}\n\nvoid dc_deinit_callbacks(struct dc *dc)\n{\n\tmemset(&dc->ctx->cp_psp, 0, sizeof(dc->ctx->cp_psp));\n}\n\nvoid dc_destroy(struct dc **dc)\n{\n\tdc_destruct(*dc);\n\tkfree(*dc);\n\t*dc = NULL;\n}\n\nstatic void enable_timing_multisync(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *ctx)\n{\n\tint i, multisync_count = 0;\n\tint pipe_count = dc->res_pool->pipe_count;\n\tstruct pipe_ctx *multisync_pipes[MAX_PIPES] = { NULL };\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tif (!ctx->res_ctx.pipe_ctx[i].stream ||\n\t\t\t\t!ctx->res_ctx.pipe_ctx[i].stream->triggered_crtc_reset.enabled)\n\t\t\tcontinue;\n\t\tif (ctx->res_ctx.pipe_ctx[i].stream == ctx->res_ctx.pipe_ctx[i].stream->triggered_crtc_reset.event_source)\n\t\t\tcontinue;\n\t\tmultisync_pipes[multisync_count] = &ctx->res_ctx.pipe_ctx[i];\n\t\tmultisync_count++;\n\t}\n\n\tif (multisync_count > 0) {\n\t\tdc->hwss.enable_per_frame_crtc_position_reset(\n\t\t\tdc, multisync_count, multisync_pipes);\n\t}\n}\n\nstatic void program_timing_sync(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *ctx)\n{\n\tint i, j, k;\n\tint group_index = 0;\n\tint num_group = 0;\n\tint pipe_count = dc->res_pool->pipe_count;\n\tstruct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tif (!ctx->res_ctx.pipe_ctx[i].stream\n\t\t\t\t|| ctx->res_ctx.pipe_ctx[i].top_pipe\n\t\t\t\t|| ctx->res_ctx.pipe_ctx[i].prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tunsynced_pipes[i] = &ctx->res_ctx.pipe_ctx[i];\n\t}\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tint group_size = 1;\n\t\tenum timing_synchronization_type sync_type = NOT_SYNCHRONIZABLE;\n\t\tstruct pipe_ctx *pipe_set[MAX_PIPES];\n\n\t\tif (!unsynced_pipes[i])\n\t\t\tcontinue;\n\n\t\tpipe_set[0] = unsynced_pipes[i];\n\t\tunsynced_pipes[i] = NULL;\n\n\t\t \n\t\tfor (j = i + 1; j < pipe_count; j++) {\n\t\t\tif (!unsynced_pipes[j])\n\t\t\t\tcontinue;\n\t\t\tif (sync_type != TIMING_SYNCHRONIZABLE &&\n\t\t\t\tdc->hwss.enable_vblanks_synchronization &&\n\t\t\t\tunsynced_pipes[j]->stream_res.tg->funcs->align_vblanks &&\n\t\t\t\tresource_are_vblanks_synchronizable(\n\t\t\t\t\tunsynced_pipes[j]->stream,\n\t\t\t\t\tpipe_set[0]->stream)) {\n\t\t\t\tsync_type = VBLANK_SYNCHRONIZABLE;\n\t\t\t\tpipe_set[group_size] = unsynced_pipes[j];\n\t\t\t\tunsynced_pipes[j] = NULL;\n\t\t\t\tgroup_size++;\n\t\t\t} else\n\t\t\tif (sync_type != VBLANK_SYNCHRONIZABLE &&\n\t\t\t\tresource_are_streams_timing_synchronizable(\n\t\t\t\t\tunsynced_pipes[j]->stream,\n\t\t\t\t\tpipe_set[0]->stream)) {\n\t\t\t\tsync_type = TIMING_SYNCHRONIZABLE;\n\t\t\t\tpipe_set[group_size] = unsynced_pipes[j];\n\t\t\t\tunsynced_pipes[j] = NULL;\n\t\t\t\tgroup_size++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < group_size; j++) {\n\t\t\tbool is_blanked;\n\n\t\t\tif (pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked)\n\t\t\t\tis_blanked =\n\t\t\t\t\tpipe_set[j]->stream_res.opp->funcs->dpg_is_blanked(pipe_set[j]->stream_res.opp);\n\t\t\telse\n\t\t\t\tis_blanked =\n\t\t\t\t\tpipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg);\n\t\t\tif (!is_blanked) {\n\t\t\t\tif (j == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tswap(pipe_set[0], pipe_set[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (k = 0; k < group_size; k++) {\n\t\t\tstruct dc_stream_status *status = dc_stream_get_status_from_state(ctx, pipe_set[k]->stream);\n\n\t\t\tstatus->timing_sync_info.group_id = num_group;\n\t\t\tstatus->timing_sync_info.group_size = group_size;\n\t\t\tif (k == 0)\n\t\t\t\tstatus->timing_sync_info.master = true;\n\t\t\telse\n\t\t\t\tstatus->timing_sync_info.master = false;\n\n\t\t}\n\n\t\t \n\t\tif (dc->config.use_pipe_ctx_sync_logic) {\n\t\t\t \n\t\t\tfor (j = 1; j < group_size; j++) {\n\t\t\t\tif (pipe_set[j]->pipe_idx_syncd == pipe_set[0]->pipe_idx_syncd) {\n\t\t\t\t\tgroup_size--;\n\t\t\t\t\tpipe_set[j] = pipe_set[group_size];\n\t\t\t\t\tj--;\n\t\t\t\t} else\n\t\t\t\t\t \n\t\t\t\t\tpipe_set[j]->pipe_idx_syncd = pipe_set[0]->pipe_idx_syncd;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = j + 1; j < group_size; j++) {\n\t\t\t\tbool is_blanked;\n\n\t\t\t\tif (pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked)\n\t\t\t\t\tis_blanked =\n\t\t\t\t\t\tpipe_set[j]->stream_res.opp->funcs->dpg_is_blanked(pipe_set[j]->stream_res.opp);\n\t\t\t\telse\n\t\t\t\t\tis_blanked =\n\t\t\t\t\t\tpipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg);\n\t\t\t\tif (!is_blanked) {\n\t\t\t\t\tgroup_size--;\n\t\t\t\t\tpipe_set[j] = pipe_set[group_size];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (group_size > 1) {\n\t\t\tif (sync_type == TIMING_SYNCHRONIZABLE) {\n\t\t\t\tdc->hwss.enable_timing_synchronization(\n\t\t\t\t\tdc, group_index, group_size, pipe_set);\n\t\t\t} else\n\t\t\t\tif (sync_type == VBLANK_SYNCHRONIZABLE) {\n\t\t\t\tdc->hwss.enable_vblanks_synchronization(\n\t\t\t\t\tdc, group_index, group_size, pipe_set);\n\t\t\t\t}\n\t\t\tgroup_index++;\n\t\t}\n\t\tnum_group++;\n\t}\n}\n\nstatic bool streams_changed(struct dc *dc,\n\t\t\t    struct dc_stream_state *streams[],\n\t\t\t    uint8_t stream_count)\n{\n\tuint8_t i;\n\n\tif (stream_count != dc->current_state->stream_count)\n\t\treturn true;\n\n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tif (dc->current_state->streams[i] != streams[i])\n\t\t\treturn true;\n\t\tif (!streams[i]->link->link_state_valid)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool dc_validate_boot_timing(const struct dc *dc,\n\t\t\t\tconst struct dc_sink *sink,\n\t\t\t\tstruct dc_crtc_timing *crtc_timing)\n{\n\tstruct timing_generator *tg;\n\tstruct stream_encoder *se = NULL;\n\n\tstruct dc_crtc_timing hw_crtc_timing = {0};\n\n\tstruct dc_link *link = sink->link;\n\tunsigned int i, enc_inst, tg_inst = 0;\n\n\t \n\tif (sink->sink_signal != SIGNAL_TYPE_EDP) {\n\t\treturn false;\n\t}\n\n\tif (dc->debug.force_odm_combine)\n\t\treturn false;\n\n\t \n\tif (!link->link_enc->funcs->is_dig_enabled(link->link_enc))\n\t\treturn false;\n\n\tenc_inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);\n\n\tif (enc_inst == ENGINE_ID_UNKNOWN)\n\t\treturn false;\n\n\tfor (i = 0; i < dc->res_pool->stream_enc_count; i++) {\n\t\tif (dc->res_pool->stream_enc[i]->id == enc_inst) {\n\n\t\t\tse = dc->res_pool->stream_enc[i];\n\n\t\t\ttg_inst = dc->res_pool->stream_enc[i]->funcs->dig_source_otg(\n\t\t\t\tdc->res_pool->stream_enc[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == dc->res_pool->stream_enc_count)\n\t\treturn false;\n\n\tif (tg_inst >= dc->res_pool->timing_generator_count)\n\t\treturn false;\n\n\tif (tg_inst != link->link_enc->preferred_engine)\n\t\treturn false;\n\n\ttg = dc->res_pool->timing_generators[tg_inst];\n\n\tif (!tg->funcs->get_hw_timing)\n\t\treturn false;\n\n\tif (!tg->funcs->get_hw_timing(tg, &hw_crtc_timing))\n\t\treturn false;\n\n\tif (crtc_timing->h_total != hw_crtc_timing.h_total)\n\t\treturn false;\n\n\tif (crtc_timing->h_border_left != hw_crtc_timing.h_border_left)\n\t\treturn false;\n\n\tif (crtc_timing->h_addressable != hw_crtc_timing.h_addressable)\n\t\treturn false;\n\n\tif (crtc_timing->h_border_right != hw_crtc_timing.h_border_right)\n\t\treturn false;\n\n\tif (crtc_timing->h_front_porch != hw_crtc_timing.h_front_porch)\n\t\treturn false;\n\n\tif (crtc_timing->h_sync_width != hw_crtc_timing.h_sync_width)\n\t\treturn false;\n\n\tif (crtc_timing->v_total != hw_crtc_timing.v_total)\n\t\treturn false;\n\n\tif (crtc_timing->v_border_top != hw_crtc_timing.v_border_top)\n\t\treturn false;\n\n\tif (crtc_timing->v_addressable != hw_crtc_timing.v_addressable)\n\t\treturn false;\n\n\tif (crtc_timing->v_border_bottom != hw_crtc_timing.v_border_bottom)\n\t\treturn false;\n\n\tif (crtc_timing->v_front_porch != hw_crtc_timing.v_front_porch)\n\t\treturn false;\n\n\tif (crtc_timing->v_sync_width != hw_crtc_timing.v_sync_width)\n\t\treturn false;\n\n\t \n\tif (crtc_timing->flags.DSC)\n\t\treturn false;\n\n\tif (dc_is_dp_signal(link->connector_signal)) {\n\t\tunsigned int pix_clk_100hz;\n\t\tuint32_t numOdmPipes = 1;\n\t\tuint32_t id_src[4] = {0};\n\n\t\tdc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(\n\t\t\tdc->res_pool->dp_clock_source,\n\t\t\ttg_inst, &pix_clk_100hz);\n\n\t\tif (tg->funcs->get_optc_source)\n\t\t\ttg->funcs->get_optc_source(tg,\n\t\t\t\t\t\t&numOdmPipes, &id_src[0], &id_src[1]);\n\n\t\tif (numOdmPipes == 2)\n\t\t\tpix_clk_100hz *= 2;\n\t\tif (numOdmPipes == 4)\n\t\t\tpix_clk_100hz *= 4;\n\n\t\t \n\t\t\n\t\tif (crtc_timing->pix_clk_100hz != pix_clk_100hz)\n\t\t\treturn false;\n\n\t\tif (!se->funcs->dp_get_pixel_format)\n\t\t\treturn false;\n\n\t\tif (!se->funcs->dp_get_pixel_format(\n\t\t\tse,\n\t\t\t&hw_crtc_timing.pixel_encoding,\n\t\t\t&hw_crtc_timing.display_color_depth))\n\t\t\treturn false;\n\n\t\tif (hw_crtc_timing.display_color_depth != crtc_timing->display_color_depth)\n\t\t\treturn false;\n\n\t\tif (hw_crtc_timing.pixel_encoding != crtc_timing->pixel_encoding)\n\t\t\treturn false;\n\t}\n\n\tif (link->dpcd_caps.dprx_feature.bits.VSC_SDP_COLORIMETRY_SUPPORTED) {\n\t\treturn false;\n\t}\n\n\tif (dc->link_srv->edp_is_ilr_optimization_required(link, crtc_timing)) {\n\t\tDC_LOG_EVENT_LINK_TRAINING(\"Seamless boot disabled to optimize eDP link rate\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool should_update_pipe_for_stream(\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_stream_state *stream)\n{\n\treturn (pipe_ctx->stream && pipe_ctx->stream == stream);\n}\n\nstatic inline bool should_update_pipe_for_plane(\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_plane_state *plane_state)\n{\n\treturn (pipe_ctx->plane_state == plane_state);\n}\n\nvoid dc_enable_stereo(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tstruct dc_stream_state *streams[],\n\tuint8_t stream_count)\n{\n\tint i, j;\n\tstruct pipe_ctx *pipe;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (context != NULL) {\n\t\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\t} else {\n\t\t\tcontext = dc->current_state;\n\t\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t}\n\n\t\tfor (j = 0; pipe && j < stream_count; j++)  {\n\t\t\tif (should_update_pipe_for_stream(context, pipe, streams[j]) &&\n\t\t\t\tdc->hwss.setup_stereo)\n\t\t\t\tdc->hwss.setup_stereo(pipe, dc);\n\t\t}\n\t}\n}\n\nvoid dc_trigger_sync(struct dc *dc, struct dc_state *context)\n{\n\tif (context->stream_count > 1 && !dc->debug.disable_timing_sync) {\n\t\tenable_timing_multisync(dc, context);\n\t\tprogram_timing_sync(dc, context);\n\t}\n}\n\nstatic uint8_t get_stream_mask(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tunsigned int stream_mask = 0;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tstream_mask |= 1 << i;\n\t}\n\n\treturn stream_mask;\n}\n\nvoid dc_z10_restore(const struct dc *dc)\n{\n\tif (dc->hwss.z10_restore)\n\t\tdc->hwss.z10_restore(dc);\n}\n\nvoid dc_z10_save_init(struct dc *dc)\n{\n\tif (dc->hwss.z10_save_init)\n\t\tdc->hwss.z10_save_init(dc);\n}\n\n \nstatic enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *context)\n{\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\tstruct pipe_ctx *pipe;\n\tint i, k, l;\n\tstruct dc_stream_state *dc_streams[MAX_STREAMS] = {0};\n\tstruct dc_state *old_state;\n\tbool subvp_prev_use = false;\n\n\tdc_z10_restore(dc);\n\tdc_allow_idle_optimizations(dc, false);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tsubvp_prev_use |= (old_pipe->stream && old_pipe->stream->mall_stream_config.type == SUBVP_PHANTOM);\n\t\tif (subvp_prev_use)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < context->stream_count; i++)\n\t\tdc_streams[i] =  context->streams[i];\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb)) {\n\t\tdisable_vbios_mode_if_required(dc, context);\n\t\tdc->hwss.enable_accelerated_mode(dc, context);\n\t}\n\n\tif (context->stream_count > get_seamless_boot_stream_count(context) ||\n\t\tcontext->stream_count == 0)\n\t\tdc->hwss.prepare_bandwidth(dc, context);\n\n\t \n\tif (dc->hwss.subvp_pipe_control_lock)\n\t\tdc->hwss.subvp_pipe_control_lock(dc, context, true, true, NULL, subvp_prev_use);\n\n\tif (dc->hwss.update_dsc_pg)\n\t\tdc->hwss.update_dsc_pg(dc, context, false);\n\n\tdisable_dangling_plane(dc, context);\n\t \n\tif (dc->hwss.apply_ctx_for_surface) {\n\t\tfor (i = 0; i < context->stream_count; i++) {\n\t\t\tif (context->streams[i]->mode_changed)\n\t\t\t\tcontinue;\n\t\t\tapply_ctx_interdependent_lock(dc, context, context->streams[i], true);\n\t\t\tdc->hwss.apply_ctx_for_surface(\n\t\t\t\tdc, context->streams[i],\n\t\t\t\tcontext->stream_status[i].plane_count,\n\t\t\t\tcontext);  \n\t\t\tapply_ctx_interdependent_lock(dc, context, context->streams[i], false);\n\t\t\tdc->hwss.post_unlock_program_front_end(dc, context);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\tdc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);\n\t}\n\n\tresult = dc->hwss.apply_ctx_to_hw(dc, context);\n\n\tif (result != DC_OK) {\n\t\t \n\t\tdc->current_state->res_ctx.link_enc_cfg_ctx.mode = LINK_ENC_CFG_STEADY;\n\t\treturn result;\n\t}\n\n\tdc_trigger_sync(dc, context);\n\n\t \n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tuint32_t prev_dsc_changed = context->streams[i]->update_flags.bits.dsc_changed;\n\n\t\tcontext->streams[i]->update_flags.raw = 0xFFFFFFFF;\n\t\tcontext->streams[i]->update_flags.bits.dsc_changed = prev_dsc_changed;\n\t}\n\n\t \n\tif (dc->hwss.program_front_end_for_ctx) {\n\t\tdc->hwss.interdependent_update_lock(dc, context, true);\n\t\tdc->hwss.program_front_end_for_ctx(dc, context);\n\t\tdc->hwss.interdependent_update_lock(dc, context, false);\n\t\tdc->hwss.post_unlock_program_front_end(dc, context);\n\t}\n\n\tif (dc->hwss.commit_subvp_config)\n\t\tdc->hwss.commit_subvp_config(dc, context);\n\tif (dc->hwss.subvp_pipe_control_lock)\n\t\tdc->hwss.subvp_pipe_control_lock(dc, context, false, true, NULL, subvp_prev_use);\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tconst struct dc_link *link = context->streams[i]->link;\n\n\t\tif (!context->streams[i]->mode_changed)\n\t\t\tcontinue;\n\n\t\tif (dc->hwss.apply_ctx_for_surface) {\n\t\t\tapply_ctx_interdependent_lock(dc, context, context->streams[i], true);\n\t\t\tdc->hwss.apply_ctx_for_surface(\n\t\t\t\t\tdc, context->streams[i],\n\t\t\t\t\tcontext->stream_status[i].plane_count,\n\t\t\t\t\tcontext);\n\t\t\tapply_ctx_interdependent_lock(dc, context, context->streams[i], false);\n\t\t\tdc->hwss.post_unlock_program_front_end(dc, context);\n\t\t}\n\n\t\t \n\t\tfor (k = 0; k < MAX_PIPES; k++) {\n\t\t\tpipe = &context->res_ctx.pipe_ctx[k];\n\n\t\t\tfor (l = 0 ; pipe && l < context->stream_count; l++)  {\n\t\t\t\tif (context->streams[l] &&\n\t\t\t\t\tcontext->streams[l] == pipe->stream &&\n\t\t\t\t\tdc->hwss.setup_stereo)\n\t\t\t\t\tdc->hwss.setup_stereo(pipe, dc);\n\t\t\t}\n\t\t}\n\n\t\tCONN_MSG_MODE(link, \"{%dx%d, %dx%d@%dKhz}\",\n\t\t\t\tcontext->streams[i]->timing.h_addressable,\n\t\t\t\tcontext->streams[i]->timing.v_addressable,\n\t\t\t\tcontext->streams[i]->timing.h_total,\n\t\t\t\tcontext->streams[i]->timing.v_total,\n\t\t\t\tcontext->streams[i]->timing.pix_clk_100hz / 10);\n\t}\n\n\tdc_enable_stereo(dc, context, dc_streams, context->stream_count);\n\n\tif (context->stream_count > get_seamless_boot_stream_count(context) ||\n\t\tcontext->stream_count == 0) {\n\t\t \n\t\twait_for_no_pipes_pending(dc, context);\n\t\t \n\t\tdc->hwss.optimize_bandwidth(dc, context);\n\t}\n\n\tif (dc->hwss.update_dsc_pg)\n\t\tdc->hwss.update_dsc_pg(dc, context, true);\n\n\tif (dc->ctx->dce_version >= DCE_VERSION_MAX)\n\t\tTRACE_DCN_CLOCK_STATE(&context->bw_ctx.bw.dcn.clk);\n\telse\n\t\tTRACE_DCE_CLOCK_STATE(&context->bw_ctx.bw.dce);\n\n\tcontext->stream_mask = get_stream_mask(dc, context);\n\n\tif (context->stream_mask != dc->current_state->stream_mask)\n\t\tdc_dmub_srv_notify_stream_mask(dc->ctx->dmub_srv, context->stream_mask);\n\n\tfor (i = 0; i < context->stream_count; i++)\n\t\tcontext->streams[i]->mode_changed = false;\n\n\t \n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tcontext->streams[i]->update_flags.raw = 0x0;\n\t}\n\n\told_state = dc->current_state;\n\tdc->current_state = context;\n\n\tdc_release_state(old_state);\n\n\tdc_retain_state(dc->current_state);\n\n\treturn result;\n}\n\nstatic bool commit_minimal_transition_state(struct dc *dc,\n\t\tstruct dc_state *transition_base_context);\n\n \nenum dc_status dc_commit_streams(struct dc *dc,\n\t\t\t\t struct dc_stream_state *streams[],\n\t\t\t\t uint8_t stream_count)\n{\n\tint i, j;\n\tstruct dc_state *context;\n\tenum dc_status res = DC_OK;\n\tstruct dc_validation_set set[MAX_STREAMS] = {0};\n\tstruct pipe_ctx *pipe;\n\tbool handle_exit_odm2to1 = false;\n\n\tif (dc->ctx->dce_environment == DCE_ENV_VIRTUAL_HW)\n\t\treturn res;\n\n\tif (!streams_changed(dc, streams, stream_count))\n\t\treturn res;\n\n\tDC_LOG_DC(\"%s: %d streams\\n\", __func__, stream_count);\n\n\tfor (i = 0; i < stream_count; i++) {\n\t\tstruct dc_stream_state *stream = streams[i];\n\t\tstruct dc_stream_status *status = dc_stream_get_status(stream);\n\n\t\tdc_stream_log(dc, stream);\n\n\t\tset[i].stream = stream;\n\n\t\tif (status) {\n\t\t\tset[i].plane_count = status->plane_count;\n\t\t\tfor (j = 0; j < status->plane_count; j++)\n\t\t\t\tset[i].plane_states[j] = status->plane_states[j];\n\t\t}\n\t}\n\n\t \n\tif (stream_count > dc->current_state->stream_count &&\n\t\t\tdc->current_state->stream_count == 1) {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tif (pipe->next_odm_pipe)\n\t\t\t\thandle_exit_odm2to1 = true;\n\t\t}\n\t}\n\n\tif (handle_exit_odm2to1)\n\t\tres = commit_minimal_transition_state(dc, dc->current_state);\n\n\tcontext = dc_create_state(dc);\n\tif (!context)\n\t\tgoto context_alloc_fail;\n\n\tdc_resource_state_copy_construct_current(dc, context);\n\n\tres = dc_validate_with_context(dc, set, stream_count, context, false);\n\tif (res != DC_OK) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto fail;\n\t}\n\n\tres = dc_commit_state_no_check(dc, context);\n\n\tfor (i = 0; i < stream_count; i++) {\n\t\tfor (j = 0; j < context->stream_count; j++) {\n\t\t\tif (streams[i]->stream_id == context->streams[j]->stream_id)\n\t\t\t\tstreams[i]->out.otg_offset = context->stream_status[j].primary_otg_inst;\n\n\t\t\tif (dc_is_embedded_signal(streams[i]->signal)) {\n\t\t\t\tstruct dc_stream_status *status = dc_stream_get_status_from_state(context, streams[i]);\n\n\t\t\t\tif (dc->hwss.is_abm_supported)\n\t\t\t\t\tstatus->is_abm_supported = dc->hwss.is_abm_supported(dc, context, streams[i]);\n\t\t\t\telse\n\t\t\t\t\tstatus->is_abm_supported = true;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\tdc_release_state(context);\n\ncontext_alloc_fail:\n\n\tDC_LOG_DC(\"%s Finished.\\n\", __func__);\n\n\treturn res;\n}\n\nbool dc_acquire_release_mpc_3dlut(\n\t\tstruct dc *dc, bool acquire,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_3dlut **lut,\n\t\tstruct dc_transfer_func **shaper)\n{\n\tint pipe_idx;\n\tbool ret = false;\n\tbool found_pipe_idx = false;\n\tconst struct resource_pool *pool = dc->res_pool;\n\tstruct resource_context *res_ctx = &dc->current_state->res_ctx;\n\tint mpcc_id = 0;\n\n\tif (pool && res_ctx) {\n\t\tif (acquire) {\n\t\t\t \n\t\t\tfor (pipe_idx = 0; pipe_idx < pool->pipe_count; pipe_idx++) {\n\t\t\t\tif (res_ctx->pipe_ctx[pipe_idx].stream == stream) {\n\t\t\t\t\tfound_pipe_idx = true;\n\t\t\t\t\tmpcc_id = res_ctx->pipe_ctx[pipe_idx].plane_res.hubp->inst;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tfound_pipe_idx = true; \n\n\t\tif (found_pipe_idx) {\n\t\t\tif (acquire && pool->funcs->acquire_post_bldn_3dlut)\n\t\t\t\tret = pool->funcs->acquire_post_bldn_3dlut(res_ctx, pool, mpcc_id, lut, shaper);\n\t\t\telse if (!acquire && pool->funcs->release_post_bldn_3dlut)\n\t\t\t\tret = pool->funcs->release_post_bldn_3dlut(res_ctx, pool, lut, shaper);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool is_flip_pending_in_pipes(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tstruct pipe_ctx *pipe;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (!pipe->plane_state || (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM))\n\t\t\tcontinue;\n\n\t\t \n\t\tpipe->plane_state->status.is_flip_pending = false;\n\t\tdc->hwss.update_pending_status(pipe);\n\t\tif (pipe->plane_state->status.is_flip_pending)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void process_deferred_updates(struct dc *dc)\n{\n\tint i = 0;\n\n\tif (dc->debug.enable_mem_low_power.bits.cm) {\n\t\tASSERT(dc->dcn_ip->max_num_dpp);\n\t\tfor (i = 0; i < dc->dcn_ip->max_num_dpp; i++)\n\t\t\tif (dc->res_pool->dpps[i]->funcs->dpp_deferred_update)\n\t\t\t\tdc->res_pool->dpps[i]->funcs->dpp_deferred_update(dc->res_pool->dpps[i]);\n\t}\n}\n\nvoid dc_post_update_surfaces_to_stream(struct dc *dc)\n{\n\tint i;\n\tstruct dc_state *context = dc->current_state;\n\n\tif ((!dc->optimized_required) || get_seamless_boot_stream_count(context) > 0)\n\t\treturn;\n\n\tpost_surface_trace(dc);\n\n\t \n\n\tif (dc->ctx->dce_version < DCE_VERSION_MAX)\n\t\tTRACE_DCE_CLOCK_STATE(&context->bw_ctx.bw.dce);\n\telse {\n\t\tTRACE_DCN_CLOCK_STATE(&context->bw_ctx.bw.dcn.clk);\n\n\t\tif (is_flip_pending_in_pipes(dc, context))\n\t\t\treturn;\n\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream == NULL ||\n\t\t\t\t\tcontext->res_ctx.pipe_ctx[i].plane_state == NULL) {\n\t\t\t\tcontext->res_ctx.pipe_ctx[i].pipe_idx = i;\n\t\t\t\tdc->hwss.disable_plane(dc, &context->res_ctx.pipe_ctx[i]);\n\t\t\t}\n\n\t\tprocess_deferred_updates(dc);\n\n\t\tdc->hwss.optimize_bandwidth(dc, context);\n\n\t\tif (dc->hwss.update_dsc_pg)\n\t\t\tdc->hwss.update_dsc_pg(dc, context, true);\n\t}\n\n\tdc->optimized_required = false;\n\tdc->wm_optimized_required = false;\n}\n\nstatic void init_state(struct dc *dc, struct dc_state *context)\n{\n\t \n\tmemcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));\n}\n\nstruct dc_state *dc_create_state(struct dc *dc)\n{\n\tstruct dc_state *context = kvzalloc(sizeof(struct dc_state),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tinit_state(dc, context);\n\n\tkref_init(&context->refcount);\n\n\treturn context;\n}\n\nstruct dc_state *dc_copy_state(struct dc_state *src_ctx)\n{\n\tint i, j;\n\tstruct dc_state *new_ctx = kvmalloc(sizeof(struct dc_state), GFP_KERNEL);\n\n\tif (!new_ctx)\n\t\treturn NULL;\n\tmemcpy(new_ctx, src_ctx, sizeof(struct dc_state));\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\t\tstruct pipe_ctx *cur_pipe = &new_ctx->res_ctx.pipe_ctx[i];\n\n\t\t\tif (cur_pipe->top_pipe)\n\t\t\t\tcur_pipe->top_pipe =  &new_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];\n\n\t\t\tif (cur_pipe->bottom_pipe)\n\t\t\t\tcur_pipe->bottom_pipe = &new_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];\n\n\t\t\tif (cur_pipe->prev_odm_pipe)\n\t\t\t\tcur_pipe->prev_odm_pipe =  &new_ctx->res_ctx.pipe_ctx[cur_pipe->prev_odm_pipe->pipe_idx];\n\n\t\t\tif (cur_pipe->next_odm_pipe)\n\t\t\t\tcur_pipe->next_odm_pipe = &new_ctx->res_ctx.pipe_ctx[cur_pipe->next_odm_pipe->pipe_idx];\n\n\t}\n\n\tfor (i = 0; i < new_ctx->stream_count; i++) {\n\t\t\tdc_stream_retain(new_ctx->streams[i]);\n\t\t\tfor (j = 0; j < new_ctx->stream_status[i].plane_count; j++)\n\t\t\t\tdc_plane_state_retain(\n\t\t\t\t\tnew_ctx->stream_status[i].plane_states[j]);\n\t}\n\n\tkref_init(&new_ctx->refcount);\n\n\treturn new_ctx;\n}\n\nvoid dc_retain_state(struct dc_state *context)\n{\n\tkref_get(&context->refcount);\n}\n\nstatic void dc_state_free(struct kref *kref)\n{\n\tstruct dc_state *context = container_of(kref, struct dc_state, refcount);\n\tdc_resource_state_destruct(context);\n\tkvfree(context);\n}\n\nvoid dc_release_state(struct dc_state *context)\n{\n\tkref_put(&context->refcount, dc_state_free);\n}\n\nbool dc_set_generic_gpio_for_stereo(bool enable,\n\t\tstruct gpio_service *gpio_service)\n{\n\tenum gpio_result gpio_result = GPIO_RESULT_NON_SPECIFIC_ERROR;\n\tstruct gpio_pin_info pin_info;\n\tstruct gpio *generic;\n\tstruct gpio_generic_mux_config *config = kzalloc(sizeof(struct gpio_generic_mux_config),\n\t\t\t   GFP_KERNEL);\n\n\tif (!config)\n\t\treturn false;\n\tpin_info = dal_gpio_get_generic_pin_info(gpio_service, GPIO_ID_GENERIC, 0);\n\n\tif (pin_info.mask == 0xFFFFFFFF || pin_info.offset == 0xFFFFFFFF) {\n\t\tkfree(config);\n\t\treturn false;\n\t} else {\n\t\tgeneric = dal_gpio_service_create_generic_mux(\n\t\t\tgpio_service,\n\t\t\tpin_info.offset,\n\t\t\tpin_info.mask);\n\t}\n\n\tif (!generic) {\n\t\tkfree(config);\n\t\treturn false;\n\t}\n\n\tgpio_result = dal_gpio_open(generic, GPIO_MODE_OUTPUT);\n\n\tconfig->enable_output_from_mux = enable;\n\tconfig->mux_select = GPIO_SIGNAL_SOURCE_PASS_THROUGH_STEREO_SYNC;\n\n\tif (gpio_result == GPIO_RESULT_OK)\n\t\tgpio_result = dal_mux_setup_config(generic, config);\n\n\tif (gpio_result == GPIO_RESULT_OK) {\n\t\tdal_gpio_close(generic);\n\t\tdal_gpio_destroy_generic_mux(&generic);\n\t\tkfree(config);\n\t\treturn true;\n\t} else {\n\t\tdal_gpio_close(generic);\n\t\tdal_gpio_destroy_generic_mux(&generic);\n\t\tkfree(config);\n\t\treturn false;\n\t}\n}\n\nstatic bool is_surface_in_context(\n\t\tconst struct dc_state *context,\n\t\tconst struct dc_plane_state *plane_state)\n{\n\tint j;\n\n\tfor (j = 0; j < MAX_PIPES; j++) {\n\t\tconst struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (plane_state == pipe_ctx->plane_state) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic enum surface_update_type get_plane_info_update_type(const struct dc_surface_update *u)\n{\n\tunion surface_update_flags *update_flags = &u->surface->update_flags;\n\tenum surface_update_type update_type = UPDATE_TYPE_FAST;\n\n\tif (!u->plane_info)\n\t\treturn UPDATE_TYPE_FAST;\n\n\tif (u->plane_info->color_space != u->surface->color_space) {\n\t\tupdate_flags->bits.color_space_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\t}\n\n\tif (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror) {\n\t\tupdate_flags->bits.horizontal_mirror_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\t}\n\n\tif (u->plane_info->rotation != u->surface->rotation) {\n\t\tupdate_flags->bits.rotation_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t}\n\n\tif (u->plane_info->format != u->surface->format) {\n\t\tupdate_flags->bits.pixel_format_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t}\n\n\tif (u->plane_info->stereo_format != u->surface->stereo_format) {\n\t\tupdate_flags->bits.stereo_format_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t}\n\n\tif (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha) {\n\t\tupdate_flags->bits.per_pixel_alpha_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\t}\n\n\tif (u->plane_info->global_alpha_value != u->surface->global_alpha_value) {\n\t\tupdate_flags->bits.global_alpha_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\t}\n\n\tif (u->plane_info->dcc.enable != u->surface->dcc.enable\n\t\t\t|| u->plane_info->dcc.dcc_ind_blk != u->surface->dcc.dcc_ind_blk\n\t\t\t|| u->plane_info->dcc.meta_pitch != u->surface->dcc.meta_pitch) {\n\t\t \n\t\tupdate_flags->bits.dcc_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t}\n\n\tif (resource_pixel_format_to_bpp(u->plane_info->format) !=\n\t\t\tresource_pixel_format_to_bpp(u->surface->format)) {\n\t\t \n\t\tupdate_flags->bits.bpp_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t}\n\n\tif (u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch\n\t\t\t|| u->plane_info->plane_size.chroma_pitch != u->surface->plane_size.chroma_pitch) {\n\t\tupdate_flags->bits.plane_size_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\t}\n\n\n\tif (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,\n\t\t\tsizeof(union dc_tiling_info)) != 0) {\n\t\tupdate_flags->bits.swizzle_change = 1;\n\t\televate_update_type(&update_type, UPDATE_TYPE_MED);\n\n\t\t \n\t\tif (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR) {\n\t\t\t \n\t\t\tupdate_flags->bits.bandwidth_change = 1;\n\t\t\televate_update_type(&update_type, UPDATE_TYPE_FULL);\n\t\t}\n\t}\n\n\t \n\treturn update_type;\n}\n\nstatic enum surface_update_type get_scaling_info_update_type(\n\t\tconst struct dc *dc,\n\t\tconst struct dc_surface_update *u)\n{\n\tunion surface_update_flags *update_flags = &u->surface->update_flags;\n\n\tif (!u->scaling_info)\n\t\treturn UPDATE_TYPE_FAST;\n\n\tif (u->scaling_info->dst_rect.width != u->surface->dst_rect.width\n\t\t\t|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height\n\t\t\t|| u->scaling_info->scaling_quality.integer_scaling !=\n\t\t\t\tu->surface->scaling_quality.integer_scaling\n\t\t\t) {\n\t\tupdate_flags->bits.scaling_change = 1;\n\n\t\tif ((u->scaling_info->dst_rect.width < u->surface->dst_rect.width\n\t\t\t|| u->scaling_info->dst_rect.height < u->surface->dst_rect.height)\n\t\t\t\t&& (u->scaling_info->dst_rect.width < u->surface->src_rect.width\n\t\t\t\t\t|| u->scaling_info->dst_rect.height < u->surface->src_rect.height))\n\t\t\t \n\t\t\tupdate_flags->bits.bandwidth_change = 1;\n\t}\n\n\tif (u->scaling_info->src_rect.width != u->surface->src_rect.width\n\t\t|| u->scaling_info->src_rect.height != u->surface->src_rect.height) {\n\n\t\tupdate_flags->bits.scaling_change = 1;\n\t\tif (u->scaling_info->src_rect.width > u->surface->src_rect.width\n\t\t\t\t|| u->scaling_info->src_rect.height > u->surface->src_rect.height)\n\t\t\t \n\t\t\tupdate_flags->bits.clock_change = 1;\n\t}\n\n\tif (u->scaling_info->src_rect.width > dc->caps.max_optimizable_video_width &&\n\t\t(u->scaling_info->clip_rect.width > u->surface->clip_rect.width ||\n\t\t u->scaling_info->clip_rect.height > u->surface->clip_rect.height))\n\t\t  \n\t\tupdate_flags->bits.bandwidth_change = 1;\n\n\tif (u->scaling_info->src_rect.x != u->surface->src_rect.x\n\t\t\t|| u->scaling_info->src_rect.y != u->surface->src_rect.y\n\t\t\t|| u->scaling_info->clip_rect.x != u->surface->clip_rect.x\n\t\t\t|| u->scaling_info->clip_rect.y != u->surface->clip_rect.y\n\t\t\t|| u->scaling_info->dst_rect.x != u->surface->dst_rect.x\n\t\t\t|| u->scaling_info->dst_rect.y != u->surface->dst_rect.y)\n\t\tupdate_flags->bits.position_change = 1;\n\n\tif (update_flags->bits.clock_change\n\t\t\t|| update_flags->bits.bandwidth_change\n\t\t\t|| update_flags->bits.scaling_change)\n\t\treturn UPDATE_TYPE_FULL;\n\n\tif (update_flags->bits.position_change)\n\t\treturn UPDATE_TYPE_MED;\n\n\treturn UPDATE_TYPE_FAST;\n}\n\nstatic enum surface_update_type det_surface_update(const struct dc *dc,\n\t\tconst struct dc_surface_update *u)\n{\n\tconst struct dc_state *context = dc->current_state;\n\tenum surface_update_type type;\n\tenum surface_update_type overall_type = UPDATE_TYPE_FAST;\n\tunion surface_update_flags *update_flags = &u->surface->update_flags;\n\n\tif (!is_surface_in_context(context, u->surface) || u->surface->force_full_update) {\n\t\tupdate_flags->raw = 0xFFFFFFFF;\n\t\treturn UPDATE_TYPE_FULL;\n\t}\n\n\tupdate_flags->raw = 0; \n\n\ttype = get_plane_info_update_type(u);\n\televate_update_type(&overall_type, type);\n\n\ttype = get_scaling_info_update_type(dc, u);\n\televate_update_type(&overall_type, type);\n\n\tif (u->flip_addr) {\n\t\tupdate_flags->bits.addr_update = 1;\n\t\tif (u->flip_addr->address.tmz_surface != u->surface->address.tmz_surface) {\n\t\t\tupdate_flags->bits.tmz_changed = 1;\n\t\t\televate_update_type(&overall_type, UPDATE_TYPE_FULL);\n\t\t}\n\t}\n\tif (u->in_transfer_func)\n\t\tupdate_flags->bits.in_transfer_func_change = 1;\n\n\tif (u->input_csc_color_matrix)\n\t\tupdate_flags->bits.input_csc_change = 1;\n\n\tif (u->coeff_reduction_factor)\n\t\tupdate_flags->bits.coeff_reduction_change = 1;\n\n\tif (u->gamut_remap_matrix)\n\t\tupdate_flags->bits.gamut_remap_change = 1;\n\n\tif (u->gamma) {\n\t\tenum surface_pixel_format format = SURFACE_PIXEL_FORMAT_GRPH_BEGIN;\n\n\t\tif (u->plane_info)\n\t\t\tformat = u->plane_info->format;\n\t\telse if (u->surface)\n\t\t\tformat = u->surface->format;\n\n\t\tif (dce_use_lut(format))\n\t\t\tupdate_flags->bits.gamma_change = 1;\n\t}\n\n\tif (u->lut3d_func || u->func_shaper)\n\t\tupdate_flags->bits.lut_3d = 1;\n\n\tif (u->hdr_mult.value)\n\t\tif (u->hdr_mult.value != u->surface->hdr_mult.value) {\n\t\t\tupdate_flags->bits.hdr_mult = 1;\n\t\t\televate_update_type(&overall_type, UPDATE_TYPE_MED);\n\t\t}\n\n\tif (update_flags->bits.in_transfer_func_change) {\n\t\ttype = UPDATE_TYPE_MED;\n\t\televate_update_type(&overall_type, type);\n\t}\n\n\tif (update_flags->bits.lut_3d) {\n\t\ttype = UPDATE_TYPE_FULL;\n\t\televate_update_type(&overall_type, type);\n\t}\n\n\tif (dc->debug.enable_legacy_fast_update &&\n\t\t\t(update_flags->bits.gamma_change ||\n\t\t\tupdate_flags->bits.gamut_remap_change ||\n\t\t\tupdate_flags->bits.input_csc_change ||\n\t\t\tupdate_flags->bits.coeff_reduction_change)) {\n\t\ttype = UPDATE_TYPE_FULL;\n\t\televate_update_type(&overall_type, type);\n\t}\n\treturn overall_type;\n}\n\nstatic enum surface_update_type check_update_surfaces_for_stream(\n\t\tstruct dc *dc,\n\t\tstruct dc_surface_update *updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_update *stream_update,\n\t\tconst struct dc_stream_status *stream_status)\n{\n\tint i;\n\tenum surface_update_type overall_type = UPDATE_TYPE_FAST;\n\n\tif (dc->idle_optimizations_allowed)\n\t\toverall_type = UPDATE_TYPE_FULL;\n\n\tif (stream_status == NULL || stream_status->plane_count != surface_count)\n\t\toverall_type = UPDATE_TYPE_FULL;\n\n\tif (stream_update && stream_update->pending_test_pattern) {\n\t\toverall_type = UPDATE_TYPE_FULL;\n\t}\n\n\t \n\tif (stream_update) {\n\t\tunion stream_update_flags *su_flags = &stream_update->stream->update_flags;\n\n\t\tif ((stream_update->src.height != 0 && stream_update->src.width != 0) ||\n\t\t\t(stream_update->dst.height != 0 && stream_update->dst.width != 0) ||\n\t\t\tstream_update->integer_scaling_update)\n\t\t\tsu_flags->bits.scaling = 1;\n\n\t\tif (dc->debug.enable_legacy_fast_update && stream_update->out_transfer_func)\n\t\t\tsu_flags->bits.out_tf = 1;\n\n\t\tif (stream_update->abm_level)\n\t\t\tsu_flags->bits.abm_level = 1;\n\n\t\tif (stream_update->dpms_off)\n\t\t\tsu_flags->bits.dpms_off = 1;\n\n\t\tif (stream_update->gamut_remap)\n\t\t\tsu_flags->bits.gamut_remap = 1;\n\n\t\tif (stream_update->wb_update)\n\t\t\tsu_flags->bits.wb_update = 1;\n\n\t\tif (stream_update->dsc_config)\n\t\t\tsu_flags->bits.dsc_changed = 1;\n\n\t\tif (stream_update->mst_bw_update)\n\t\t\tsu_flags->bits.mst_bw = 1;\n\n\t\tif (stream_update->stream && stream_update->stream->freesync_on_desktop &&\n\t\t\t(stream_update->vrr_infopacket || stream_update->allow_freesync ||\n\t\t\t\tstream_update->vrr_active_variable || stream_update->vrr_active_fixed))\n\t\t\tsu_flags->bits.fams_changed = 1;\n\n\t\tif (su_flags->raw != 0)\n\t\t\toverall_type = UPDATE_TYPE_FULL;\n\n\t\tif (stream_update->output_csc_transform || stream_update->output_color_space)\n\t\t\tsu_flags->bits.out_csc = 1;\n\n\t\t \n\t\tif (!dc->debug.enable_legacy_fast_update && stream_update->out_transfer_func)\n\t\t\tsu_flags->bits.out_tf = 1;\n\t}\n\n\tfor (i = 0 ; i < surface_count; i++) {\n\t\tenum surface_update_type type =\n\t\t\t\tdet_surface_update(dc, &updates[i]);\n\n\t\televate_update_type(&overall_type, type);\n\t}\n\n\treturn overall_type;\n}\n\n \nenum surface_update_type dc_check_update_surfaces_for_stream(\n\t\tstruct dc *dc,\n\t\tstruct dc_surface_update *updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_update *stream_update,\n\t\tconst struct dc_stream_status *stream_status)\n{\n\tint i;\n\tenum surface_update_type type;\n\n\tif (stream_update)\n\t\tstream_update->stream->update_flags.raw = 0;\n\tfor (i = 0; i < surface_count; i++)\n\t\tupdates[i].surface->update_flags.raw = 0;\n\n\ttype = check_update_surfaces_for_stream(dc, updates, surface_count, stream_update, stream_status);\n\tif (type == UPDATE_TYPE_FULL) {\n\t\tif (stream_update) {\n\t\t\tuint32_t dsc_changed = stream_update->stream->update_flags.bits.dsc_changed;\n\t\t\tstream_update->stream->update_flags.raw = 0xFFFFFFFF;\n\t\t\tstream_update->stream->update_flags.bits.dsc_changed = dsc_changed;\n\t\t}\n\t\tfor (i = 0; i < surface_count; i++)\n\t\t\tupdates[i].surface->update_flags.raw = 0xFFFFFFFF;\n\t}\n\n\tif (type == UPDATE_TYPE_FAST) {\n\t\t \n\t\tif (dc->clk_mgr->funcs->are_clock_states_equal) {\n\t\t\tif (!dc->clk_mgr->funcs->are_clock_states_equal(&dc->clk_mgr->clks, &dc->current_state->bw_ctx.bw.dcn.clk))\n\t\t\t\tdc->optimized_required = true;\n\t\t\n\t\t} else if (memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0) {\n\t\t\tdc->optimized_required = true;\n\t\t}\n\n\t\tdc->optimized_required |= dc->wm_optimized_required;\n\t}\n\n\treturn type;\n}\n\nstatic struct dc_stream_status *stream_get_status(\n\tstruct dc_state *ctx,\n\tstruct dc_stream_state *stream)\n{\n\tuint8_t i;\n\n\tfor (i = 0; i < ctx->stream_count; i++) {\n\t\tif (stream == ctx->streams[i]) {\n\t\t\treturn &ctx->stream_status[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;\n\nstatic void copy_surface_update_to_plane(\n\t\tstruct dc_plane_state *surface,\n\t\tstruct dc_surface_update *srf_update)\n{\n\tif (srf_update->flip_addr) {\n\t\tsurface->address = srf_update->flip_addr->address;\n\t\tsurface->flip_immediate =\n\t\t\tsrf_update->flip_addr->flip_immediate;\n\t\tsurface->time.time_elapsed_in_us[surface->time.index] =\n\t\t\tsrf_update->flip_addr->flip_timestamp_in_us -\n\t\t\t\tsurface->time.prev_update_time_in_us;\n\t\tsurface->time.prev_update_time_in_us =\n\t\t\tsrf_update->flip_addr->flip_timestamp_in_us;\n\t\tsurface->time.index++;\n\t\tif (surface->time.index >= DC_PLANE_UPDATE_TIMES_MAX)\n\t\t\tsurface->time.index = 0;\n\n\t\tsurface->triplebuffer_flips = srf_update->flip_addr->triplebuffer_flips;\n\t}\n\n\tif (srf_update->scaling_info) {\n\t\tsurface->scaling_quality =\n\t\t\t\tsrf_update->scaling_info->scaling_quality;\n\t\tsurface->dst_rect =\n\t\t\t\tsrf_update->scaling_info->dst_rect;\n\t\tsurface->src_rect =\n\t\t\t\tsrf_update->scaling_info->src_rect;\n\t\tsurface->clip_rect =\n\t\t\t\tsrf_update->scaling_info->clip_rect;\n\t}\n\n\tif (srf_update->plane_info) {\n\t\tsurface->color_space =\n\t\t\t\tsrf_update->plane_info->color_space;\n\t\tsurface->format =\n\t\t\t\tsrf_update->plane_info->format;\n\t\tsurface->plane_size =\n\t\t\t\tsrf_update->plane_info->plane_size;\n\t\tsurface->rotation =\n\t\t\t\tsrf_update->plane_info->rotation;\n\t\tsurface->horizontal_mirror =\n\t\t\t\tsrf_update->plane_info->horizontal_mirror;\n\t\tsurface->stereo_format =\n\t\t\t\tsrf_update->plane_info->stereo_format;\n\t\tsurface->tiling_info =\n\t\t\t\tsrf_update->plane_info->tiling_info;\n\t\tsurface->visible =\n\t\t\t\tsrf_update->plane_info->visible;\n\t\tsurface->per_pixel_alpha =\n\t\t\t\tsrf_update->plane_info->per_pixel_alpha;\n\t\tsurface->global_alpha =\n\t\t\t\tsrf_update->plane_info->global_alpha;\n\t\tsurface->global_alpha_value =\n\t\t\t\tsrf_update->plane_info->global_alpha_value;\n\t\tsurface->dcc =\n\t\t\t\tsrf_update->plane_info->dcc;\n\t\tsurface->layer_index =\n\t\t\t\tsrf_update->plane_info->layer_index;\n\t}\n\n\tif (srf_update->gamma &&\n\t\t\t(surface->gamma_correction !=\n\t\t\t\t\tsrf_update->gamma)) {\n\t\tmemcpy(&surface->gamma_correction->entries,\n\t\t\t&srf_update->gamma->entries,\n\t\t\tsizeof(struct dc_gamma_entries));\n\t\tsurface->gamma_correction->is_identity =\n\t\t\tsrf_update->gamma->is_identity;\n\t\tsurface->gamma_correction->num_entries =\n\t\t\tsrf_update->gamma->num_entries;\n\t\tsurface->gamma_correction->type =\n\t\t\tsrf_update->gamma->type;\n\t}\n\n\tif (srf_update->in_transfer_func &&\n\t\t\t(surface->in_transfer_func !=\n\t\t\t\tsrf_update->in_transfer_func)) {\n\t\tsurface->in_transfer_func->sdr_ref_white_level =\n\t\t\tsrf_update->in_transfer_func->sdr_ref_white_level;\n\t\tsurface->in_transfer_func->tf =\n\t\t\tsrf_update->in_transfer_func->tf;\n\t\tsurface->in_transfer_func->type =\n\t\t\tsrf_update->in_transfer_func->type;\n\t\tmemcpy(&surface->in_transfer_func->tf_pts,\n\t\t\t&srf_update->in_transfer_func->tf_pts,\n\t\t\tsizeof(struct dc_transfer_func_distributed_points));\n\t}\n\n\tif (srf_update->func_shaper &&\n\t\t\t(surface->in_shaper_func !=\n\t\t\tsrf_update->func_shaper))\n\t\tmemcpy(surface->in_shaper_func, srf_update->func_shaper,\n\t\tsizeof(*surface->in_shaper_func));\n\n\tif (srf_update->lut3d_func &&\n\t\t\t(surface->lut3d_func !=\n\t\t\tsrf_update->lut3d_func))\n\t\tmemcpy(surface->lut3d_func, srf_update->lut3d_func,\n\t\tsizeof(*surface->lut3d_func));\n\n\tif (srf_update->hdr_mult.value)\n\t\tsurface->hdr_mult =\n\t\t\t\tsrf_update->hdr_mult;\n\n\tif (srf_update->blend_tf &&\n\t\t\t(surface->blend_tf !=\n\t\t\tsrf_update->blend_tf))\n\t\tmemcpy(surface->blend_tf, srf_update->blend_tf,\n\t\tsizeof(*surface->blend_tf));\n\n\tif (srf_update->input_csc_color_matrix)\n\t\tsurface->input_csc_color_matrix =\n\t\t\t*srf_update->input_csc_color_matrix;\n\n\tif (srf_update->coeff_reduction_factor)\n\t\tsurface->coeff_reduction_factor =\n\t\t\t*srf_update->coeff_reduction_factor;\n\n\tif (srf_update->gamut_remap_matrix)\n\t\tsurface->gamut_remap_matrix =\n\t\t\t*srf_update->gamut_remap_matrix;\n}\n\nstatic void copy_stream_update_to_stream(struct dc *dc,\n\t\t\t\t\t struct dc_state *context,\n\t\t\t\t\t struct dc_stream_state *stream,\n\t\t\t\t\t struct dc_stream_update *update)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\n\tif (update == NULL || stream == NULL)\n\t\treturn;\n\n\tif (update->src.height && update->src.width)\n\t\tstream->src = update->src;\n\n\tif (update->dst.height && update->dst.width)\n\t\tstream->dst = update->dst;\n\n\tif (update->out_transfer_func &&\n\t    stream->out_transfer_func != update->out_transfer_func) {\n\t\tstream->out_transfer_func->sdr_ref_white_level =\n\t\t\tupdate->out_transfer_func->sdr_ref_white_level;\n\t\tstream->out_transfer_func->tf = update->out_transfer_func->tf;\n\t\tstream->out_transfer_func->type =\n\t\t\tupdate->out_transfer_func->type;\n\t\tmemcpy(&stream->out_transfer_func->tf_pts,\n\t\t       &update->out_transfer_func->tf_pts,\n\t\t       sizeof(struct dc_transfer_func_distributed_points));\n\t}\n\n\tif (update->hdr_static_metadata)\n\t\tstream->hdr_static_metadata = *update->hdr_static_metadata;\n\n\tif (update->abm_level)\n\t\tstream->abm_level = *update->abm_level;\n\n\tif (update->periodic_interrupt)\n\t\tstream->periodic_interrupt = *update->periodic_interrupt;\n\n\tif (update->gamut_remap)\n\t\tstream->gamut_remap_matrix = *update->gamut_remap;\n\n\t \n\tif (update->output_color_space)\n\t\tstream->output_color_space = *update->output_color_space;\n\n\tif (update->output_csc_transform)\n\t\tstream->csc_color_matrix = *update->output_csc_transform;\n\n\tif (update->vrr_infopacket)\n\t\tstream->vrr_infopacket = *update->vrr_infopacket;\n\n\tif (update->allow_freesync)\n\t\tstream->allow_freesync = *update->allow_freesync;\n\n\tif (update->vrr_active_variable)\n\t\tstream->vrr_active_variable = *update->vrr_active_variable;\n\n\tif (update->vrr_active_fixed)\n\t\tstream->vrr_active_fixed = *update->vrr_active_fixed;\n\n\tif (update->crtc_timing_adjust)\n\t\tstream->adjust = *update->crtc_timing_adjust;\n\n\tif (update->dpms_off)\n\t\tstream->dpms_off = *update->dpms_off;\n\n\tif (update->hfvsif_infopacket)\n\t\tstream->hfvsif_infopacket = *update->hfvsif_infopacket;\n\n\tif (update->vtem_infopacket)\n\t\tstream->vtem_infopacket = *update->vtem_infopacket;\n\n\tif (update->vsc_infopacket)\n\t\tstream->vsc_infopacket = *update->vsc_infopacket;\n\n\tif (update->vsp_infopacket)\n\t\tstream->vsp_infopacket = *update->vsp_infopacket;\n\n\tif (update->adaptive_sync_infopacket)\n\t\tstream->adaptive_sync_infopacket = *update->adaptive_sync_infopacket;\n\n\tif (update->dither_option)\n\t\tstream->dither_option = *update->dither_option;\n\n\tif (update->pending_test_pattern)\n\t\tstream->test_pattern = *update->pending_test_pattern;\n\t \n\tif (update->wb_update) {\n\t\tint i;\n\n\t\tstream->num_wb_info = update->wb_update->num_wb_info;\n\t\tASSERT(stream->num_wb_info <= MAX_DWB_PIPES);\n\t\tfor (i = 0; i < stream->num_wb_info; i++)\n\t\t\tstream->writeback_info[i] =\n\t\t\t\tupdate->wb_update->writeback_info[i];\n\t}\n\tif (update->dsc_config) {\n\t\tstruct dc_dsc_config old_dsc_cfg = stream->timing.dsc_cfg;\n\t\tuint32_t old_dsc_enabled = stream->timing.flags.DSC;\n\t\tuint32_t enable_dsc = (update->dsc_config->num_slices_h != 0 &&\n\t\t\t\t       update->dsc_config->num_slices_v != 0);\n\n\t\t \n\t\tstruct dc_state *dsc_validate_context = dc_create_state(dc);\n\n\t\tif (dsc_validate_context) {\n\t\t\tdc_resource_state_copy_construct(dc->current_state, dsc_validate_context);\n\n\t\t\tstream->timing.dsc_cfg = *update->dsc_config;\n\t\t\tstream->timing.flags.DSC = enable_dsc;\n\t\t\tif (!dc->res_pool->funcs->validate_bandwidth(dc, dsc_validate_context, true)) {\n\t\t\t\tstream->timing.dsc_cfg = old_dsc_cfg;\n\t\t\t\tstream->timing.flags.DSC = old_dsc_enabled;\n\t\t\t\tupdate->dsc_config = NULL;\n\t\t\t}\n\n\t\t\tdc_release_state(dsc_validate_context);\n\t\t} else {\n\t\t\tDC_ERROR(\"Failed to allocate new validate context for DSC change\\n\");\n\t\t\tupdate->dsc_config = NULL;\n\t\t}\n\t}\n}\n\nstatic bool update_planes_and_stream_state(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates, int surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update,\n\t\tenum surface_update_type *new_update_type,\n\t\tstruct dc_state **new_context)\n{\n\tstruct dc_state *context;\n\tint i, j;\n\tenum surface_update_type update_type;\n\tconst struct dc_stream_status *stream_status;\n\tstruct dc_context *dc_ctx = dc->ctx;\n\n\tstream_status = dc_stream_get_status(stream);\n\n\tif (!stream_status) {\n\t\tif (surface_count)  \n\t\t\tASSERT(false);\n\n\t\treturn false;  \n\t}\n\n\tcontext = dc->current_state;\n\n\tupdate_type = dc_check_update_surfaces_for_stream(\n\t\t\tdc, srf_updates, surface_count, stream_update, stream_status);\n\n\t \n\tcopy_stream_update_to_stream(dc, context, stream, stream_update);\n\n\t \n\tif (surface_count > 0) {\n\t\tfor (i = 0; i < surface_count; i++) {\n\t\t\tif ((srf_updates[i].surface->src_rect.width == 0 ||\n\t\t\t\t srf_updates[i].surface->src_rect.height == 0 ||\n\t\t\t\t srf_updates[i].surface->dst_rect.width == 0 ||\n\t\t\t\t srf_updates[i].surface->dst_rect.height == 0) &&\n\t\t\t\t(!srf_updates[i].scaling_info ||\n\t\t\t\t  srf_updates[i].scaling_info->src_rect.width == 0 ||\n\t\t\t\t  srf_updates[i].scaling_info->src_rect.height == 0 ||\n\t\t\t\t  srf_updates[i].scaling_info->dst_rect.width == 0 ||\n\t\t\t\t  srf_updates[i].scaling_info->dst_rect.height == 0)) {\n\t\t\t\tDC_ERROR(\"Invalid src/dst rects in surface update!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (update_type >= update_surface_trace_level)\n\t\tupdate_surface_trace(dc, srf_updates, surface_count);\n\n\tif (update_type >= UPDATE_TYPE_FULL) {\n\t\tstruct dc_plane_state *new_planes[MAX_SURFACES] = {0};\n\n\t\tfor (i = 0; i < surface_count; i++)\n\t\t\tnew_planes[i] = srf_updates[i].surface;\n\n\t\t \n\t\tcontext = dc_create_state(dc);\n\t\tif (context == NULL) {\n\t\t\tDC_ERROR(\"Failed to allocate new validate context!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdc_resource_state_copy_construct(\n\t\t\t\tdc->current_state, context);\n\n\t\t \n\t\tif (dc->res_pool->funcs->remove_phantom_pipes)\n\t\t\tdc->res_pool->funcs->remove_phantom_pipes(dc, context, false);\n\n\t\t \n\t\tif (!dc_rem_all_planes_for_stream(dc, stream, context)) {\n\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (!dc_add_all_planes_for_stream(dc, stream, new_planes, surface_count, context)) {\n\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *surface = srf_updates[i].surface;\n\n\t\tcopy_surface_update_to_plane(surface, &srf_updates[i]);\n\n\t\tif (update_type >= UPDATE_TYPE_MED) {\n\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\t\tif (pipe_ctx->plane_state != surface)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresource_build_scaling_params(pipe_ctx);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (update_type == UPDATE_TYPE_FULL) {\n\t\tif (!dc->res_pool->funcs->validate_bandwidth(dc, context, false)) {\n\t\t\t \n\t\t\tif (dc->res_pool->funcs->retain_phantom_pipes)\n\t\t\t\tdc->res_pool->funcs->retain_phantom_pipes(dc, dc->current_state);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t*new_context = context;\n\t*new_update_type = update_type;\n\n\treturn true;\n\nfail:\n\tdc_release_state(context);\n\n\treturn false;\n\n}\n\nstatic void commit_planes_do_stream_update(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update,\n\t\tenum surface_update_type update_type,\n\t\tstruct dc_state *context)\n{\n\tint j;\n\n\t \n\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (resource_is_pipe_type(pipe_ctx, OTG_MASTER) && pipe_ctx->stream == stream) {\n\n\t\t\tif (stream_update->periodic_interrupt && dc->hwss.setup_periodic_interrupt)\n\t\t\t\tdc->hwss.setup_periodic_interrupt(dc, pipe_ctx);\n\n\t\t\tif ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||\n\t\t\t\t\tstream_update->vrr_infopacket ||\n\t\t\t\t\tstream_update->vsc_infopacket ||\n\t\t\t\t\tstream_update->vsp_infopacket ||\n\t\t\t\t\tstream_update->hfvsif_infopacket ||\n\t\t\t\t\tstream_update->adaptive_sync_infopacket ||\n\t\t\t\t\tstream_update->vtem_infopacket) {\n\t\t\t\tresource_build_info_frame(pipe_ctx);\n\t\t\t\tdc->hwss.update_info_frame(pipe_ctx);\n\n\t\t\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\t\t\t\tdc->link_srv->dp_trace_source_sequence(\n\t\t\t\t\t\t\tpipe_ctx->stream->link,\n\t\t\t\t\t\t\tDPCD_SOURCE_SEQ_AFTER_UPDATE_INFO_FRAME);\n\t\t\t}\n\n\t\t\tif (stream_update->hdr_static_metadata &&\n\t\t\t\t\tstream->use_dynamic_meta &&\n\t\t\t\t\tdc->hwss.set_dmdata_attributes &&\n\t\t\t\t\tpipe_ctx->stream->dmdata_address.quad_part != 0)\n\t\t\t\tdc->hwss.set_dmdata_attributes(pipe_ctx);\n\n\t\t\tif (stream_update->gamut_remap)\n\t\t\t\tdc_stream_set_gamut_remap(dc, stream);\n\n\t\t\tif (stream_update->output_csc_transform)\n\t\t\t\tdc_stream_program_csc_matrix(dc, stream);\n\n\t\t\tif (stream_update->dither_option) {\n\t\t\t\tstruct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;\n\t\t\t\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t\t\t\t\t\t\t&pipe_ctx->stream->bit_depth_params);\n\t\t\t\tpipe_ctx->stream_res.opp->funcs->opp_program_fmt(pipe_ctx->stream_res.opp,\n\t\t\t\t\t\t&stream->bit_depth_params,\n\t\t\t\t\t\t&stream->clamping);\n\t\t\t\twhile (odm_pipe) {\n\t\t\t\t\todm_pipe->stream_res.opp->funcs->opp_program_fmt(odm_pipe->stream_res.opp,\n\t\t\t\t\t\t\t&stream->bit_depth_params,\n\t\t\t\t\t\t\t&stream->clamping);\n\t\t\t\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t \n\t\t\tif (update_type == UPDATE_TYPE_FAST)\n\t\t\t\tcontinue;\n\n\t\t\tif (stream_update->dsc_config)\n\t\t\t\tdc->link_srv->update_dsc_config(pipe_ctx);\n\n\t\t\tif (stream_update->mst_bw_update) {\n\t\t\t\tif (stream_update->mst_bw_update->is_increase)\n\t\t\t\t\tdc->link_srv->increase_mst_payload(pipe_ctx,\n\t\t\t\t\t\t\tstream_update->mst_bw_update->mst_stream_bw);\n \t\t\t\telse\n\t\t\t\t\tdc->link_srv->reduce_mst_payload(pipe_ctx,\n\t\t\t\t\t\t\tstream_update->mst_bw_update->mst_stream_bw);\n \t\t\t}\n\n\t\t\tif (stream_update->pending_test_pattern) {\n\t\t\t\tdc_link_dp_set_test_pattern(stream->link,\n\t\t\t\t\tstream->test_pattern.type,\n\t\t\t\t\tstream->test_pattern.color_space,\n\t\t\t\t\tstream->test_pattern.p_link_settings,\n\t\t\t\t\tstream->test_pattern.p_custom_pattern,\n\t\t\t\t\tstream->test_pattern.cust_pattern_size);\n\t\t\t}\n\n\t\t\tif (stream_update->dpms_off) {\n\t\t\t\tif (*stream_update->dpms_off) {\n\t\t\t\t\tdc->link_srv->set_dpms_off(pipe_ctx);\n\t\t\t\t\t \n\t\t\t\t\tif (pipe_ctx->stream_res.audio && !dc->debug.az_endpoint_mute_only)\n\t\t\t\t\t\tpipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);\n\n\t\t\t\t\tdc->optimized_required = true;\n\n\t\t\t\t} else {\n\t\t\t\t\tif (get_seamless_boot_stream_count(context) == 0)\n\t\t\t\t\t\tdc->hwss.prepare_bandwidth(dc, dc->current_state);\n\t\t\t\t\tdc->link_srv->set_dpms_on(dc->current_state, pipe_ctx);\n\t\t\t\t}\n\t\t\t} else if (pipe_ctx->stream->link->wa_flags.blank_stream_on_ocs_change && stream_update->output_color_space\n\t\t\t\t\t&& !stream->dpms_off && dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\t\t\t \n\t\t\t\tdc->link_srv->set_dpms_on(dc->current_state, pipe_ctx);\n\t\t\t}\n\n\t\t\tif (stream_update->abm_level && pipe_ctx->stream_res.abm) {\n\t\t\t\tbool should_program_abm = true;\n\n\t\t\t\t\n\t\t\t\tif (pipe_ctx->stream_res.tg->funcs->is_blanked)\n\t\t\t\t\tif (pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))\n\t\t\t\t\t\tshould_program_abm = false;\n\n\t\t\t\tif (should_program_abm) {\n\t\t\t\t\tif (*stream_update->abm_level == ABM_LEVEL_IMMEDIATE_DISABLE) {\n\t\t\t\t\t\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpipe_ctx->stream_res.abm->funcs->set_abm_level(\n\t\t\t\t\t\t\tpipe_ctx->stream_res.abm, stream->abm_level);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool dc_dmub_should_send_dirty_rect_cmd(struct dc *dc, struct dc_stream_state *stream)\n{\n\tif ((stream->link->psr_settings.psr_version == DC_PSR_VERSION_SU_1\n\t\t\t|| stream->link->psr_settings.psr_version == DC_PSR_VERSION_1)\n\t\t\t&& stream->ctx->dce_version >= DCN_VERSION_3_1)\n\t\treturn true;\n\n\tif (stream->link->replay_settings.config.replay_supported)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid dc_dmub_update_dirty_rect(struct dc *dc,\n\t\t\t       int surface_count,\n\t\t\t       struct dc_stream_state *stream,\n\t\t\t       struct dc_surface_update *srf_updates,\n\t\t\t       struct dc_state *context)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dmub_cmd_update_dirty_rect_data *update_dirty_rect;\n\tunsigned int i, j;\n\tunsigned int panel_inst = 0;\n\n\tif (!dc_dmub_should_send_dirty_rect_cmd(dc, stream))\n\t\treturn;\n\n\tif (!dc_get_edp_link_panel_inst(dc, stream->link, &panel_inst))\n\t\treturn;\n\n\tmemset(&cmd, 0x0, sizeof(cmd));\n\tcmd.update_dirty_rect.header.type = DMUB_CMD__UPDATE_DIRTY_RECT;\n\tcmd.update_dirty_rect.header.sub_type = 0;\n\tcmd.update_dirty_rect.header.payload_bytes =\n\t\tsizeof(cmd.update_dirty_rect) -\n\t\tsizeof(cmd.update_dirty_rect.header);\n\tupdate_dirty_rect = &cmd.update_dirty_rect.update_dirty_rect_data;\n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\t\tconst struct dc_flip_addrs *flip_addr = srf_updates[i].flip_addr;\n\n\t\tif (!srf_updates[i].surface || !flip_addr)\n\t\t\tcontinue;\n\t\t \n\t\tif (srf_updates[i].surface->flip_immediate)\n\t\t\tcontinue;\n\n\t\tupdate_dirty_rect->dirty_rect_count = flip_addr->dirty_rect_count;\n\t\tmemcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects));\n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\tif (pipe_ctx->stream != stream)\n\t\t\t\tcontinue;\n\t\t\tif (pipe_ctx->plane_state != plane_state)\n\t\t\t\tcontinue;\n\n\t\t\tupdate_dirty_rect->panel_inst = panel_inst;\n\t\t\tupdate_dirty_rect->pipe_idx = j;\n\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\t\t}\n\t}\n}\n\nstatic void build_dmub_update_dirty_rect(\n\t\tstruct dc *dc,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tstruct dc_state *context,\n\t\tstruct dc_dmub_cmd dc_dmub_cmd[],\n\t\tunsigned int *dmub_cmd_count)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dmub_cmd_update_dirty_rect_data *update_dirty_rect;\n\tunsigned int i, j;\n\tunsigned int panel_inst = 0;\n\n\tif (!dc_dmub_should_send_dirty_rect_cmd(dc, stream))\n\t\treturn;\n\n\tif (!dc_get_edp_link_panel_inst(dc, stream->link, &panel_inst))\n\t\treturn;\n\n\tmemset(&cmd, 0x0, sizeof(cmd));\n\tcmd.update_dirty_rect.header.type = DMUB_CMD__UPDATE_DIRTY_RECT;\n\tcmd.update_dirty_rect.header.sub_type = 0;\n\tcmd.update_dirty_rect.header.payload_bytes =\n\t\tsizeof(cmd.update_dirty_rect) -\n\t\tsizeof(cmd.update_dirty_rect.header);\n\tupdate_dirty_rect = &cmd.update_dirty_rect.update_dirty_rect_data;\n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\t\tconst struct dc_flip_addrs *flip_addr = srf_updates[i].flip_addr;\n\n\t\tif (!srf_updates[i].surface || !flip_addr)\n\t\t\tcontinue;\n\t\t \n\t\tif (srf_updates[i].surface->flip_immediate)\n\t\t\tcontinue;\n\t\tupdate_dirty_rect->cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\t\tupdate_dirty_rect->dirty_rect_count = flip_addr->dirty_rect_count;\n\t\tmemcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects));\n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\tif (pipe_ctx->stream != stream)\n\t\t\t\tcontinue;\n\t\t\tif (pipe_ctx->plane_state != plane_state)\n\t\t\t\tcontinue;\n\t\t\tupdate_dirty_rect->panel_inst = panel_inst;\n\t\t\tupdate_dirty_rect->pipe_idx = j;\n\t\t\tdc_dmub_cmd[*dmub_cmd_count].dmub_cmd = cmd;\n\t\t\tdc_dmub_cmd[*dmub_cmd_count].wait_type = DM_DMUB_WAIT_TYPE_NO_WAIT;\n\t\t\t(*dmub_cmd_count)++;\n\t\t}\n\t}\n}\n\n\n \nstatic void build_dmub_cmd_list(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_state *context,\n\t\tstruct dc_dmub_cmd dc_dmub_cmd[],\n\t\tunsigned int *dmub_cmd_count)\n{\n\t\n\t*dmub_cmd_count = 0;\n\tbuild_dmub_update_dirty_rect(dc, surface_count, stream, srf_updates, context, dc_dmub_cmd, dmub_cmd_count);\n}\n\nstatic void commit_planes_for_stream_fast(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update,\n\t\tenum surface_update_type update_type,\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\tstruct pipe_ctx *top_pipe_to_program = NULL;\n\tdc_z10_restore(dc);\n\n\ttop_pipe_to_program = resource_get_otg_master_for_stream(\n\t\t\t&context->res_ctx,\n\t\t\tstream);\n\n\tif (dc->debug.visual_confirm) {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe->stream && pipe->plane_state)\n\t\t\t\tdc_update_viusal_confirm_color(dc, context, pipe);\n\t\t}\n\t}\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\t\t \n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\tif (!pipe_ctx->plane_state)\n\t\t\t\tcontinue;\n\t\t\tif (should_update_pipe_for_plane(context, pipe_ctx, plane_state))\n\t\t\t\tcontinue;\n\t\t\tpipe_ctx->plane_state->triplebuffer_flips = false;\n\t\t\tif (update_type == UPDATE_TYPE_FAST &&\n\t\t\t    dc->hwss.program_triplebuffer &&\n\t\t\t    !pipe_ctx->plane_state->flip_immediate && dc->debug.enable_tri_buf) {\n\t\t\t\t \n\t\t\t\tpipe_ctx->plane_state->triplebuffer_flips = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuild_dmub_cmd_list(dc,\n\t\t\tsrf_updates,\n\t\t\tsurface_count,\n\t\t\tstream,\n\t\t\tcontext,\n\t\t\tcontext->dc_dmub_cmd,\n\t\t\t&(context->dmub_cmd_count));\n\thwss_build_fast_sequence(dc,\n\t\t\tcontext->dc_dmub_cmd,\n\t\t\tcontext->dmub_cmd_count,\n\t\t\tcontext->block_sequence,\n\t\t\t&(context->block_sequence_steps),\n\t\t\ttop_pipe_to_program);\n\thwss_execute_sequence(dc,\n\t\t\tcontext->block_sequence,\n\t\t\tcontext->block_sequence_steps);\n\t \n\tif (top_pipe_to_program->stream)\n\t\ttop_pipe_to_program->stream->update_flags.raw = 0;\n}\n\nstatic void wait_for_outstanding_hw_updates(struct dc *dc, const struct dc_state *dc_context)\n{\n \n\tint pipe_idx;\n\tint opp_inst;\n\tint opp_count = dc->res_pool->pipe_count;\n\tstruct hubp *hubp;\n\tint mpcc_inst;\n\tconst struct pipe_ctx *pipe_ctx;\n\n\tfor (pipe_idx = 0; pipe_idx < dc->res_pool->pipe_count; pipe_idx++) {\n\t\tpipe_ctx = &dc_context->res_ctx.pipe_ctx[pipe_idx];\n\n\t\tif (!pipe_ctx->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream_res.tg->funcs->wait_drr_doublebuffer_pending_clear)\n\t\t\tpipe_ctx->stream_res.tg->funcs->wait_drr_doublebuffer_pending_clear(pipe_ctx->stream_res.tg);\n\n\t\thubp = pipe_ctx->plane_res.hubp;\n\t\tif (!hubp)\n\t\t\tcontinue;\n\n\t\tmpcc_inst = hubp->inst;\n\t\t\n\t\tfor (opp_inst = 0; opp_inst < opp_count; opp_inst++) {\n\t\t\tif (dc->res_pool->opps[opp_inst]->mpcc_disconnect_pending[mpcc_inst]) {\n\t\t\t\tdc->res_pool->mpc->funcs->wait_for_idle(dc->res_pool->mpc, mpcc_inst);\n\t\t\t\tdc->res_pool->opps[opp_inst]->mpcc_disconnect_pending[mpcc_inst] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void commit_planes_for_stream(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update,\n\t\tenum surface_update_type update_type,\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\tstruct pipe_ctx *top_pipe_to_program = NULL;\n\tbool should_lock_all_pipes = (update_type != UPDATE_TYPE_FAST);\n\tbool subvp_prev_use = false;\n\tbool subvp_curr_use = false;\n\n\t\n\t\n\t\n\tsubvp_prev_use = false;\n\tdc_z10_restore(dc);\n\tif (update_type == UPDATE_TYPE_FULL)\n\t\twait_for_outstanding_hw_updates(dc, context);\n\n\tif (update_type == UPDATE_TYPE_FULL) {\n\t\tdc_allow_idle_optimizations(dc, false);\n\n\t\tif (get_seamless_boot_stream_count(context) == 0)\n\t\t\tdc->hwss.prepare_bandwidth(dc, context);\n\n\t\tif (dc->hwss.update_dsc_pg)\n\t\t\tdc->hwss.update_dsc_pg(dc, context, false);\n\n\t\tcontext_clock_trace(dc, context);\n\t}\n\n\ttop_pipe_to_program = resource_get_otg_master_for_stream(\n\t\t\t\t&context->res_ctx,\n\t\t\t\tstream);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\tsubvp_prev_use |= (old_pipe->stream && old_pipe->stream->mall_stream_config.type == SUBVP_PHANTOM);\n\t\tif (subvp_prev_use)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\tsubvp_curr_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dc->debug.visual_confirm)\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe->stream && pipe->plane_state)\n\t\t\t\tdc_update_viusal_confirm_color(dc, context, pipe);\n\t\t}\n\n\tif (stream->test_pattern.type != DP_TEST_PATTERN_VIDEO_MODE) {\n\t\tstruct pipe_ctx *mpcc_pipe;\n\t\tstruct pipe_ctx *odm_pipe;\n\n\t\tfor (mpcc_pipe = top_pipe_to_program; mpcc_pipe; mpcc_pipe = mpcc_pipe->bottom_pipe)\n\t\t\tfor (odm_pipe = mpcc_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\t\t\todm_pipe->ttu_regs.min_ttu_vblank = MAX_TTU;\n\t}\n\n\tif ((update_type != UPDATE_TYPE_FAST) && stream->update_flags.bits.dsc_changed)\n\t\tif (top_pipe_to_program &&\n\t\t\ttop_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable) {\n\t\t\tif (should_use_dmub_lock(stream->link)) {\n\t\t\t\tunion dmub_hw_lock_flags hw_locks = { 0 };\n\t\t\t\tstruct dmub_hw_lock_inst_flags inst_flags = { 0 };\n\n\t\t\t\thw_locks.bits.lock_dig = 1;\n\t\t\t\tinst_flags.dig_inst = top_pipe_to_program->stream_res.tg->inst;\n\n\t\t\t\tdmub_hw_lock_mgr_cmd(dc->ctx->dmub_srv,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t&hw_locks,\n\t\t\t\t\t\t\t&inst_flags);\n\t\t\t} else\n\t\t\t\ttop_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable(\n\t\t\t\t\t\ttop_pipe_to_program->stream_res.tg);\n\t\t}\n\n\tif (should_lock_all_pipes && dc->hwss.interdependent_update_lock) {\n\t\tif (dc->hwss.subvp_pipe_control_lock)\n\t\t\t\tdc->hwss.subvp_pipe_control_lock(dc, context, true, should_lock_all_pipes, NULL, subvp_prev_use);\n\t\tdc->hwss.interdependent_update_lock(dc, context, true);\n\n\t} else {\n\t\tif (dc->hwss.subvp_pipe_control_lock)\n\t\t\tdc->hwss.subvp_pipe_control_lock(dc, context, true, should_lock_all_pipes, top_pipe_to_program, subvp_prev_use);\n\t\t \n\t\tdc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);\n\t}\n\n\tdc_dmub_update_dirty_rect(dc, surface_count, stream, srf_updates, context);\n\n\t\n\tif (stream_update)\n\t\tcommit_planes_do_stream_update(dc, stream, stream_update, update_type, context);\n\n\tif (surface_count == 0) {\n\t\t \n\t\tif (dc->hwss.apply_ctx_for_surface)\n\t\t\tdc->hwss.apply_ctx_for_surface(dc, stream, 0, context);\n\t\tif (dc->hwss.program_front_end_for_ctx)\n\t\t\tdc->hwss.program_front_end_for_ctx(dc, context);\n\n\t\tif (should_lock_all_pipes && dc->hwss.interdependent_update_lock) {\n\t\t\tdc->hwss.interdependent_update_lock(dc, context, false);\n\t\t} else {\n\t\t\tdc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);\n\t\t}\n\t\tdc->hwss.post_unlock_program_front_end(dc, context);\n\n\t\tif (update_type != UPDATE_TYPE_FAST)\n\t\t\tif (dc->hwss.commit_subvp_config)\n\t\t\t\tdc->hwss.commit_subvp_config(dc, context);\n\n\t\t \n\t\tif (dc->hwss.subvp_pipe_control_lock)\n\t\t\tdc->hwss.subvp_pipe_control_lock(dc, context, false, should_lock_all_pipes,\n\t\t\t\t\t\t\t NULL, subvp_prev_use);\n\t\treturn;\n\t}\n\n\tif (update_type != UPDATE_TYPE_FAST) {\n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\tif ((dc->debug.visual_confirm == VISUAL_CONFIRM_SUBVP ||\n\t\t\t\tdc->debug.visual_confirm == VISUAL_CONFIRM_MCLK_SWITCH) &&\n\t\t\t\tpipe_ctx->stream && pipe_ctx->plane_state) {\n\t\t\t\t \n\t\t\t\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx,\n\t\t\t\t\t\tpipe_ctx->plane_res.hubp->inst);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\t\t \n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\t\t\tif (!pipe_ctx->plane_state)\n\t\t\t\tcontinue;\n\t\t\tif (should_update_pipe_for_plane(context, pipe_ctx, plane_state))\n\t\t\t\tcontinue;\n\t\t\tpipe_ctx->plane_state->triplebuffer_flips = false;\n\t\t\tif (update_type == UPDATE_TYPE_FAST &&\n\t\t\t\tdc->hwss.program_triplebuffer != NULL &&\n\t\t\t\t!pipe_ctx->plane_state->flip_immediate && dc->debug.enable_tri_buf) {\n\t\t\t\t\t \n\t\t\t\t\tpipe_ctx->plane_state->triplebuffer_flips = true;\n\t\t\t}\n\t\t}\n\t\tif (update_type == UPDATE_TYPE_FULL) {\n\t\t\t \n\t\t\tplane_state->flip_immediate = false;\n\t\t}\n\t}\n\n\t \n\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (!pipe_ctx->top_pipe &&\n\t\t\t!pipe_ctx->prev_odm_pipe &&\n\t\t\tshould_update_pipe_for_stream(context, pipe_ctx, stream)) {\n\t\t\tstruct dc_stream_status *stream_status = NULL;\n\n\t\t\tif (!pipe_ctx->plane_state)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (update_type == UPDATE_TYPE_FAST)\n\t\t\t\tcontinue;\n\n\t\t\tASSERT(!pipe_ctx->plane_state->triplebuffer_flips);\n\n\t\t\tif (dc->hwss.program_triplebuffer != NULL && dc->debug.enable_tri_buf) {\n\t\t\t\t \n\t\t\t\tdc->hwss.program_triplebuffer(\n\t\t\t\t\tdc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);\n\t\t\t}\n\t\t\tstream_status =\n\t\t\t\tstream_get_status(context, pipe_ctx->stream);\n\n\t\t\tif (dc->hwss.apply_ctx_for_surface)\n\t\t\t\tdc->hwss.apply_ctx_for_surface(\n\t\t\t\t\tdc, pipe_ctx->stream, stream_status->plane_count, context);\n\t\t}\n\t}\n\tif (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST) {\n\t\tdc->hwss.program_front_end_for_ctx(dc, context);\n\t\tif (dc->debug.validate_dml_output) {\n\t\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\t\tstruct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];\n\t\t\t\tif (cur_pipe->stream == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcur_pipe->plane_res.hubp->funcs->validate_dml_output(\n\t\t\t\t\t\tcur_pipe->plane_res.hubp, dc->ctx,\n\t\t\t\t\t\t&context->res_ctx.pipe_ctx[i].rq_regs,\n\t\t\t\t\t\t&context->res_ctx.pipe_ctx[i].dlg_regs,\n\t\t\t\t\t\t&context->res_ctx.pipe_ctx[i].ttu_regs);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (update_type == UPDATE_TYPE_FAST) {\n\t\tif (dc->hwss.set_flip_control_gsl)\n\t\t\tfor (i = 0; i < surface_count; i++) {\n\t\t\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\n\t\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\t\t\tif (!should_update_pipe_for_stream(context, pipe_ctx, stream))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!should_update_pipe_for_plane(context, pipe_ctx, plane_state))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t \n\t\t\t\t\tdc->hwss.set_flip_control_gsl(pipe_ctx,\n\t\t\t\t\t\t\tpipe_ctx->plane_state->flip_immediate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t \n\t\tfor (i = 0; i < surface_count; i++) {\n\t\t\tstruct dc_plane_state *plane_state = srf_updates[i].surface;\n\n\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\t\t\tif (!should_update_pipe_for_stream(context, pipe_ctx, stream))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!should_update_pipe_for_plane(context, pipe_ctx, plane_state))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (dc->hwss.program_triplebuffer != NULL && dc->debug.enable_tri_buf) {\n\t\t\t\t\t \n\t\t\t\t\tdc->hwss.program_triplebuffer(\n\t\t\t\t\t\tdc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);\n\t\t\t\t}\n\t\t\t\tif (pipe_ctx->plane_state->update_flags.bits.addr_update)\n\t\t\t\t\tdc->hwss.update_plane_addr(dc, pipe_ctx);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (should_lock_all_pipes && dc->hwss.interdependent_update_lock) {\n\t\tdc->hwss.interdependent_update_lock(dc, context, false);\n\t} else {\n\t\tdc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);\n\t}\n\n\tif ((update_type != UPDATE_TYPE_FAST) && stream->update_flags.bits.dsc_changed)\n\t\tif (top_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable) {\n\t\t\ttop_pipe_to_program->stream_res.tg->funcs->wait_for_state(\n\t\t\t\ttop_pipe_to_program->stream_res.tg,\n\t\t\t\tCRTC_STATE_VACTIVE);\n\t\t\ttop_pipe_to_program->stream_res.tg->funcs->wait_for_state(\n\t\t\t\ttop_pipe_to_program->stream_res.tg,\n\t\t\t\tCRTC_STATE_VBLANK);\n\t\t\ttop_pipe_to_program->stream_res.tg->funcs->wait_for_state(\n\t\t\t\ttop_pipe_to_program->stream_res.tg,\n\t\t\t\tCRTC_STATE_VACTIVE);\n\n\t\t\tif (should_use_dmub_lock(stream->link)) {\n\t\t\t\tunion dmub_hw_lock_flags hw_locks = { 0 };\n\t\t\t\tstruct dmub_hw_lock_inst_flags inst_flags = { 0 };\n\n\t\t\t\thw_locks.bits.lock_dig = 1;\n\t\t\t\tinst_flags.dig_inst = top_pipe_to_program->stream_res.tg->inst;\n\n\t\t\t\tdmub_hw_lock_mgr_cmd(dc->ctx->dmub_srv,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t&hw_locks,\n\t\t\t\t\t\t\t&inst_flags);\n\t\t\t} else\n\t\t\t\ttop_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_disable(\n\t\t\t\t\ttop_pipe_to_program->stream_res.tg);\n\t\t}\n\n\tif (subvp_curr_use) {\n\t\t \n\t\tif (update_type != UPDATE_TYPE_FAST) {\n\t\t\tif (dc->hwss.enable_phantom_streams)\n\t\t\t\tdc->hwss.enable_phantom_streams(dc, context);\n\t\t}\n\t}\n\n\tif (update_type != UPDATE_TYPE_FAST)\n\t\tdc->hwss.post_unlock_program_front_end(dc, context);\n\n\tif (subvp_prev_use && !subvp_curr_use) {\n\t\t \n\t\tdc->hwss.apply_ctx_to_hw(dc, context);\n\t}\n\n\tif (update_type != UPDATE_TYPE_FAST)\n\t\tif (dc->hwss.commit_subvp_config)\n\t\t\tdc->hwss.commit_subvp_config(dc, context);\n\t \n\tif (should_lock_all_pipes && dc->hwss.interdependent_update_lock) {\n\t\tif (dc->hwss.subvp_pipe_control_lock)\n\t\t\tdc->hwss.subvp_pipe_control_lock(dc, context, false, should_lock_all_pipes, NULL, subvp_prev_use);\n\t} else {\n\t\tif (dc->hwss.subvp_pipe_control_lock)\n\t\t\tdc->hwss.subvp_pipe_control_lock(dc, context, false, should_lock_all_pipes, top_pipe_to_program, subvp_prev_use);\n\t}\n\n\t \n\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (!pipe_ctx->plane_state)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->bottom_pipe || pipe_ctx->next_odm_pipe ||\n\t\t\t\t!pipe_ctx->stream || !should_update_pipe_for_stream(context, pipe_ctx, stream) ||\n\t\t\t\t!pipe_ctx->plane_state->update_flags.bits.addr_update ||\n\t\t\t\tpipe_ctx->plane_state->skip_manual_trigger)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream_res.tg->funcs->program_manual_trigger)\n\t\t\tpipe_ctx->stream_res.tg->funcs->program_manual_trigger(pipe_ctx->stream_res.tg);\n\t}\n}\n\n \nstatic bool could_mpcc_tree_change_for_active_pipes(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tint surface_count,\n\t\tbool *is_plane_addition)\n{\n\n\tstruct dc_stream_status *cur_stream_status = stream_get_status(dc->current_state, stream);\n\tbool force_minimal_pipe_splitting = false;\n\tbool subvp_active = false;\n\tuint32_t i;\n\n\t*is_plane_addition = false;\n\n\tif (cur_stream_status &&\n\t\t\tdc->current_state->stream_count > 0 &&\n\t\t\tdc->debug.pipe_split_policy != MPC_SPLIT_AVOID) {\n\t\t \n\t\tif (surface_count > 0) {\n\t\t\tif (cur_stream_status->plane_count > surface_count) {\n\t\t\t\tforce_minimal_pipe_splitting = true;\n\t\t\t} else if (cur_stream_status->plane_count < surface_count) {\n\t\t\t\tforce_minimal_pipe_splitting = true;\n\t\t\t\t*is_plane_addition = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cur_stream_status &&\n\t\t\tdc->current_state->stream_count == 1 &&\n\t\t\tdc->debug.enable_single_display_2to1_odm_policy) {\n\t\t \n\t\tif (surface_count > 0) {\n\t\t\tif (cur_stream_status->plane_count > 2 && cur_stream_status->plane_count > surface_count) {\n\t\t\t\tforce_minimal_pipe_splitting = true;\n\t\t\t} else if (surface_count > 2 && cur_stream_status->plane_count < surface_count) {\n\t\t\t\tforce_minimal_pipe_splitting = true;\n\t\t\t\t*is_plane_addition = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type != SUBVP_NONE) {\n\t\t\tsubvp_active = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (cur_stream_status && subvp_active) {\n\t\t \n\t\tif (cur_stream_status->plane_count > surface_count) {\n\t\t\tforce_minimal_pipe_splitting = true;\n\t\t} else if (cur_stream_status->plane_count < surface_count) {\n\t\t\tforce_minimal_pipe_splitting = true;\n\t\t\t*is_plane_addition = true;\n\t\t}\n\t}\n\n\treturn force_minimal_pipe_splitting;\n}\n\n \nstatic bool commit_minimal_transition_state(struct dc *dc,\n\t\tstruct dc_state *transition_base_context)\n{\n\tstruct dc_state *transition_context = dc_create_state(dc);\n\tenum pipe_split_policy tmp_mpc_policy = 0;\n\tbool temp_dynamic_odm_policy = 0;\n\tbool temp_subvp_policy = 0;\n\tenum dc_status ret = DC_ERROR_UNEXPECTED;\n\tunsigned int i, j;\n\tunsigned int pipe_in_use = 0;\n\tbool subvp_in_use = false;\n\tbool odm_in_use = false;\n\n\tif (!transition_context)\n\t\treturn false;\n\t \n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &transition_base_context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->plane_state)\n\t\t\tpipe_in_use++;\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\tsubvp_in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->next_odm_pipe) {\n\t\t\todm_in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (pipe_in_use != dc->res_pool->pipe_count && !subvp_in_use && !odm_in_use) {\n\t\tdc_release_state(transition_context);\n\t\treturn true;\n\t}\n\n\tif (!dc->config.is_vmin_only_asic) {\n\t\ttmp_mpc_policy = dc->debug.pipe_split_policy;\n\t\tdc->debug.pipe_split_policy = MPC_SPLIT_AVOID;\n\t}\n\n\ttemp_dynamic_odm_policy = dc->debug.enable_single_display_2to1_odm_policy;\n\tdc->debug.enable_single_display_2to1_odm_policy = false;\n\n\ttemp_subvp_policy = dc->debug.force_disable_subvp;\n\tdc->debug.force_disable_subvp = true;\n\n\tdc_resource_state_copy_construct(transition_base_context, transition_context);\n\n\t \n\tif (dc->res_pool->funcs->validate_bandwidth(dc, transition_context, false)) {\n\t\tfor (i = 0; i < transition_context->stream_count; i++) {\n\t\t\tstruct dc_stream_status *stream_status = &transition_context->stream_status[i];\n\n\t\t\tfor (j = 0; j < stream_status->plane_count; j++) {\n\t\t\t\tstruct dc_plane_state *plane_state = stream_status->plane_states[j];\n\n\t\t\t\t \n\t\t\t\tplane_state->flip_immediate = false;\n\t\t\t}\n\t\t}\n\n\t\tret = dc_commit_state_no_check(dc, transition_context);\n\t}\n\n\t \n\tdc_release_state(transition_context);\n\n\t \n\tif (!dc->config.is_vmin_only_asic)\n\t\tdc->debug.pipe_split_policy = tmp_mpc_policy;\n\n\tdc->debug.enable_single_display_2to1_odm_policy = temp_dynamic_odm_policy;\n\tdc->debug.force_disable_subvp = temp_subvp_policy;\n\n\tif (ret != DC_OK) {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tfor (j = 0; j < dc->current_state->stream_status[i].plane_count; j++) {\n\t\t\tdc->current_state->stream_status[i].plane_states[j]->update_flags.raw = 0xFFFFFFFF;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void update_seamless_boot_flags(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream)\n{\n\tif (get_seamless_boot_stream_count(context) > 0 && surface_count > 0) {\n\t\t \n\t\tif (stream->apply_seamless_boot_optimization) {\n\t\t\tstream->apply_seamless_boot_optimization = false;\n\n\t\t\tif (get_seamless_boot_stream_count(context) == 0)\n\t\t\t\tdc->optimized_required = true;\n\t\t}\n\t}\n}\n\nstatic void populate_fast_updates(struct dc_fast_update *fast_update,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_update *stream_update)\n{\n\tint i = 0;\n\n\tif (stream_update) {\n\t\tfast_update[0].out_transfer_func = stream_update->out_transfer_func;\n\t\tfast_update[0].output_csc_transform = stream_update->output_csc_transform;\n\t}\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tfast_update[i].flip_addr = srf_updates[i].flip_addr;\n\t\tfast_update[i].gamma = srf_updates[i].gamma;\n\t\tfast_update[i].gamut_remap_matrix = srf_updates[i].gamut_remap_matrix;\n\t\tfast_update[i].input_csc_color_matrix = srf_updates[i].input_csc_color_matrix;\n\t\tfast_update[i].coeff_reduction_factor = srf_updates[i].coeff_reduction_factor;\n\t}\n}\n\nstatic bool fast_updates_exist(struct dc_fast_update *fast_update, int surface_count)\n{\n\tint i;\n\n\tif (fast_update[0].out_transfer_func ||\n\t\tfast_update[0].output_csc_transform)\n\t\treturn true;\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tif (fast_update[i].flip_addr ||\n\t\t\t\tfast_update[i].gamma ||\n\t\t\t\tfast_update[i].gamut_remap_matrix ||\n\t\t\t\tfast_update[i].input_csc_color_matrix ||\n\t\t\t\tfast_update[i].coeff_reduction_factor)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool full_update_required(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_update *stream_update,\n\t\tstruct dc_stream_state *stream)\n{\n\n\tint i;\n\tstruct dc_stream_status *stream_status;\n\tconst struct dc_state *context = dc->current_state;\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tif (srf_updates &&\n\t\t\t\t(srf_updates[i].plane_info ||\n\t\t\t\tsrf_updates[i].scaling_info ||\n\t\t\t\t(srf_updates[i].hdr_mult.value &&\n\t\t\t\tsrf_updates[i].hdr_mult.value != srf_updates->surface->hdr_mult.value) ||\n\t\t\t\tsrf_updates[i].in_transfer_func ||\n\t\t\t\tsrf_updates[i].func_shaper ||\n\t\t\t\tsrf_updates[i].lut3d_func ||\n\t\t\t\tsrf_updates[i].blend_tf ||\n\t\t\t\tsrf_updates[i].surface->force_full_update ||\n\t\t\t\t(srf_updates[i].flip_addr &&\n\t\t\t\tsrf_updates[i].flip_addr->address.tmz_surface != srf_updates[i].surface->address.tmz_surface) ||\n\t\t\t\t!is_surface_in_context(context, srf_updates[i].surface)))\n\t\t\treturn true;\n\t}\n\n\tif (stream_update &&\n\t\t\t(((stream_update->src.height != 0 && stream_update->src.width != 0) ||\n\t\t\t(stream_update->dst.height != 0 && stream_update->dst.width != 0) ||\n\t\t\tstream_update->integer_scaling_update) ||\n\t\t\tstream_update->hdr_static_metadata ||\n\t\t\tstream_update->abm_level ||\n\t\t\tstream_update->periodic_interrupt ||\n\t\t\tstream_update->vrr_infopacket ||\n\t\t\tstream_update->vsc_infopacket ||\n\t\t\tstream_update->vsp_infopacket ||\n\t\t\tstream_update->hfvsif_infopacket ||\n\t\t\tstream_update->vtem_infopacket ||\n\t\t\tstream_update->adaptive_sync_infopacket ||\n\t\t\tstream_update->dpms_off ||\n\t\t\tstream_update->allow_freesync ||\n\t\t\tstream_update->vrr_active_variable ||\n\t\t\tstream_update->vrr_active_fixed ||\n\t\t\tstream_update->gamut_remap ||\n\t\t\tstream_update->output_color_space ||\n\t\t\tstream_update->dither_option ||\n\t\t\tstream_update->wb_update ||\n\t\t\tstream_update->dsc_config ||\n\t\t\tstream_update->mst_bw_update ||\n\t\t\tstream_update->func_shaper ||\n\t\t\tstream_update->lut3d_func ||\n\t\t\tstream_update->pending_test_pattern ||\n\t\t\tstream_update->crtc_timing_adjust))\n\t\treturn true;\n\n\tif (stream) {\n\t\tstream_status = dc_stream_get_status(stream);\n\t\tif (stream_status == NULL || stream_status->plane_count != surface_count)\n\t\t\treturn true;\n\t}\n\tif (dc->idle_optimizations_allowed)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool fast_update_only(struct dc *dc,\n\t\tstruct dc_fast_update *fast_update,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_update *stream_update,\n\t\tstruct dc_stream_state *stream)\n{\n\treturn fast_updates_exist(fast_update, surface_count)\n\t\t\t&& !full_update_required(dc, srf_updates, surface_count, stream_update, stream);\n}\n\nbool dc_update_planes_and_stream(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates, int surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update)\n{\n\tstruct dc_state *context;\n\tenum surface_update_type update_type;\n\tint i;\n\tstruct mall_temp_config mall_temp_config;\n\tstruct dc_fast_update fast_update[MAX_SURFACES] = {0};\n\n\t \n\tbool force_minimal_pipe_splitting = 0;\n\tbool is_plane_addition = 0;\n\n\tpopulate_fast_updates(fast_update, srf_updates, surface_count, stream_update);\n\tforce_minimal_pipe_splitting = could_mpcc_tree_change_for_active_pipes(\n\t\t\tdc,\n\t\t\tstream,\n\t\t\tsurface_count,\n\t\t\t&is_plane_addition);\n\n\t \n\tif (force_minimal_pipe_splitting && is_plane_addition &&\n\t\t!commit_minimal_transition_state(dc, dc->current_state))\n\t\t\t\treturn false;\n\n\tif (!update_planes_and_stream_state(\n\t\t\tdc,\n\t\t\tsrf_updates,\n\t\t\tsurface_count,\n\t\t\tstream,\n\t\t\tstream_update,\n\t\t\t&update_type,\n\t\t\t&context))\n\t\treturn false;\n\n\t \n\tif (force_minimal_pipe_splitting && !is_plane_addition) {\n\t\t \n\t\tif (dc->res_pool->funcs->save_mall_state)\n\t\t\tdc->res_pool->funcs->save_mall_state(dc, context, &mall_temp_config);\n\t\tif (!commit_minimal_transition_state(dc, context)) {\n\t\t\tdc_release_state(context);\n\t\t\treturn false;\n\t\t}\n\t\tif (dc->res_pool->funcs->restore_mall_state)\n\t\t\tdc->res_pool->funcs->restore_mall_state(dc, context, &mall_temp_config);\n\n\t\t \n\t\tif (dc->res_pool->funcs->retain_phantom_pipes)\n\t\t\tdc->res_pool->funcs->retain_phantom_pipes(dc, context);\n\t\tupdate_type = UPDATE_TYPE_FULL;\n\t}\n\n\tupdate_seamless_boot_flags(dc, context, surface_count, stream);\n\tif (fast_update_only(dc, fast_update, srf_updates, surface_count, stream_update, stream) &&\n\t\t\t!dc->debug.enable_legacy_fast_update) {\n\t\tcommit_planes_for_stream_fast(dc,\n\t\t\t\tsrf_updates,\n\t\t\t\tsurface_count,\n\t\t\t\tstream,\n\t\t\t\tstream_update,\n\t\t\t\tupdate_type,\n\t\t\t\tcontext);\n\t} else {\n\t\tif (!stream_update &&\n\t\t\t\tdc->hwss.is_pipe_topology_transition_seamless &&\n\t\t\t\t!dc->hwss.is_pipe_topology_transition_seamless(\n\t\t\t\t\t\tdc, dc->current_state, context)) {\n\n\t\t\tDC_LOG_ERROR(\"performing non-seamless pipe topology transition with surface only update!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t\tcommit_planes_for_stream(\n\t\t\t\tdc,\n\t\t\t\tsrf_updates,\n\t\t\t\tsurface_count,\n\t\t\t\tstream,\n\t\t\t\tstream_update,\n\t\t\t\tupdate_type,\n\t\t\t\tcontext);\n\t}\n\n\tif (dc->current_state != context) {\n\n\t\t \n\n\t\tstruct dc_state *old = dc->current_state;\n\n\t\tdc->current_state = context;\n\t\tdc_release_state(old);\n\n\t\t \n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->plane_state && pipe_ctx->stream == stream)\n\t\t\t\tpipe_ctx->plane_state->force_full_update = false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dc_commit_updates_for_stream(struct dc *dc,\n\t\tstruct dc_surface_update *srf_updates,\n\t\tint surface_count,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_stream_update *stream_update,\n\t\tstruct dc_state *state)\n{\n\tconst struct dc_stream_status *stream_status;\n\tenum surface_update_type update_type;\n\tstruct dc_state *context;\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tint i, j;\n\tstruct dc_fast_update fast_update[MAX_SURFACES] = {0};\n\n\tpopulate_fast_updates(fast_update, srf_updates, surface_count, stream_update);\n\tstream_status = dc_stream_get_status(stream);\n\tcontext = dc->current_state;\n\n\tupdate_type = dc_check_update_surfaces_for_stream(\n\t\t\t\tdc, srf_updates, surface_count, stream_update, stream_status);\n\n\t \n\tif (dc->ctx->dce_version >= DCN_VERSION_3_2) {\n\t\t \n\t\tif (update_type == UPDATE_TYPE_FAST)\n\t\t\tdc_post_update_surfaces_to_stream(dc);\n\n\t\tdc_update_planes_and_stream(dc, srf_updates,\n\t\t\t\t\t    surface_count, stream,\n\t\t\t\t\t    stream_update);\n\t\treturn;\n\t}\n\n\tif (update_type >= update_surface_trace_level)\n\t\tupdate_surface_trace(dc, srf_updates, surface_count);\n\n\n\tif (update_type >= UPDATE_TYPE_FULL) {\n\n\t\t \n\t\tcontext = dc_create_state(dc);\n\t\tif (context == NULL) {\n\t\t\tDC_ERROR(\"Failed to allocate new validate context!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tdc_resource_state_copy_construct(state, context);\n\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *new_pipe = &context->res_ctx.pipe_ctx[i];\n\t\t\tstruct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\t\tif (new_pipe->plane_state && new_pipe->plane_state != old_pipe->plane_state)\n\t\t\t\tnew_pipe->plane_state->force_full_update = true;\n\t\t}\n\t} else if (update_type == UPDATE_TYPE_FAST) {\n\t\t \n\t\tdc_post_update_surfaces_to_stream(dc);\n\t}\n\n\n\tfor (i = 0; i < surface_count; i++) {\n\t\tstruct dc_plane_state *surface = srf_updates[i].surface;\n\n\t\tcopy_surface_update_to_plane(surface, &srf_updates[i]);\n\n\t\tif (update_type >= UPDATE_TYPE_MED) {\n\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t\t\t&context->res_ctx.pipe_ctx[j];\n\n\t\t\t\tif (pipe_ctx->plane_state != surface)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresource_build_scaling_params(pipe_ctx);\n\t\t\t}\n\t\t}\n\t}\n\n\tcopy_stream_update_to_stream(dc, context, stream, stream_update);\n\n\tif (update_type >= UPDATE_TYPE_FULL) {\n\t\tif (!dc->res_pool->funcs->validate_bandwidth(dc, context, false)) {\n\t\t\tDC_ERROR(\"Mode validation failed for stream update!\\n\");\n\t\t\tdc_release_state(context);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tTRACE_DC_PIPE_STATE(pipe_ctx, i, MAX_PIPES);\n\n\tupdate_seamless_boot_flags(dc, context, surface_count, stream);\n\tif (fast_update_only(dc, fast_update, srf_updates, surface_count, stream_update, stream) &&\n\t\t\t!dc->debug.enable_legacy_fast_update) {\n\t\tcommit_planes_for_stream_fast(dc,\n\t\t\t\tsrf_updates,\n\t\t\t\tsurface_count,\n\t\t\t\tstream,\n\t\t\t\tstream_update,\n\t\t\t\tupdate_type,\n\t\t\t\tcontext);\n\t} else {\n\t\tcommit_planes_for_stream(\n\t\t\t\tdc,\n\t\t\t\tsrf_updates,\n\t\t\t\tsurface_count,\n\t\t\t\tstream,\n\t\t\t\tstream_update,\n\t\t\t\tupdate_type,\n\t\t\t\tcontext);\n\t}\n\t \n\tif (dc->current_state != context) {\n\n\t\tstruct dc_state *old = dc->current_state;\n\n\t\tdc->current_state = context;\n\t\tdc_release_state(old);\n\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->plane_state && pipe_ctx->stream == stream)\n\t\t\t\tpipe_ctx->plane_state->force_full_update = false;\n\t\t}\n\t}\n\n\t \n\tif (update_type >= UPDATE_TYPE_FULL && dc_ctx->dce_version < DCE_VERSION_MAX) {\n\t\tdc_post_update_surfaces_to_stream(dc);\n\t\tTRACE_DCE_CLOCK_STATE(&context->bw_ctx.bw.dce);\n\t}\n\n\treturn;\n\n}\n\nuint8_t dc_get_current_stream_count(struct dc *dc)\n{\n\treturn dc->current_state->stream_count;\n}\n\nstruct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)\n{\n\tif (i < dc->current_state->stream_count)\n\t\treturn dc->current_state->streams[i];\n\treturn NULL;\n}\n\nenum dc_irq_source dc_interrupt_to_irq_source(\n\t\tstruct dc *dc,\n\t\tuint32_t src_id,\n\t\tuint32_t ext_id)\n{\n\treturn dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);\n}\n\n \nbool dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)\n{\n\n\tif (dc == NULL)\n\t\treturn false;\n\n\treturn dal_irq_service_set(dc->res_pool->irqs, src, enable);\n}\n\nvoid dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)\n{\n\tdal_irq_service_ack(dc->res_pool->irqs, src);\n}\n\nvoid dc_power_down_on_boot(struct dc *dc)\n{\n\tif (dc->ctx->dce_environment != DCE_ENV_VIRTUAL_HW &&\n\t\t\tdc->hwss.power_down_on_boot)\n\t\tdc->hwss.power_down_on_boot(dc);\n}\n\nvoid dc_set_power_state(\n\tstruct dc *dc,\n\tenum dc_acpi_cm_power_state power_state)\n{\n\tstruct kref refcount;\n\tstruct display_mode_lib *dml;\n\n\tif (!dc->current_state)\n\t\treturn;\n\n\tswitch (power_state) {\n\tcase DC_ACPI_CM_POWER_STATE_D0:\n\t\tdc_resource_state_construct(dc, dc->current_state);\n\n\t\tdc_z10_restore(dc);\n\n\t\tdc->hwss.init_hw(dc);\n\n\t\tif (dc->hwss.init_sys_ctx != NULL &&\n\t\t\tdc->vm_pa_config.valid) {\n\t\t\tdc->hwss.init_sys_ctx(dc->hwseq, dc, &dc->vm_pa_config);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tASSERT(dc->current_state->stream_count == 0);\n\t\t \n\t\tdml = kzalloc(sizeof(struct display_mode_lib),\n\t\t\t\tGFP_KERNEL);\n\n\t\tASSERT(dml);\n\t\tif (!dml)\n\t\t\treturn;\n\n\t\t \n\t\trefcount = dc->current_state->refcount;\n\t\t \n\t\tmemcpy(dml, &dc->current_state->bw_ctx.dml, sizeof(struct display_mode_lib));\n\n\t\tdc_resource_state_destruct(dc->current_state);\n\t\tmemset(dc->current_state, 0,\n\t\t\t\tsizeof(*dc->current_state));\n\n\t\tdc->current_state->refcount = refcount;\n\t\tdc->current_state->bw_ctx.dml = *dml;\n\n\t\tkfree(dml);\n\n\t\tbreak;\n\t}\n}\n\nvoid dc_resume(struct dc *dc)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->link_count; i++)\n\t\tdc->link_srv->resume(dc->links[i]);\n}\n\nbool dc_is_dmcu_initialized(struct dc *dc)\n{\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\n\tif (dmcu)\n\t\treturn dmcu->funcs->is_dmcu_initialized(dmcu);\n\treturn false;\n}\n\nvoid get_clock_requirements_for_state(struct dc_state *state, struct AsicStateEx *info)\n{\n\tinfo->displayClock\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.dispclk_khz;\n\tinfo->engineClock\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.dcfclk_khz;\n\tinfo->memoryClock\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.dramclk_khz;\n\tinfo->maxSupportedDppClock\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz;\n\tinfo->dppClock\t\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.dppclk_khz;\n\tinfo->socClock\t\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.socclk_khz;\n\tinfo->dcfClockDeepSleep\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz;\n\tinfo->fClock\t\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.fclk_khz;\n\tinfo->phyClock\t\t\t\t\t= (unsigned int)state->bw_ctx.bw.dcn.clk.phyclk_khz;\n}\nenum dc_status dc_set_clock(struct dc *dc, enum dc_clock_type clock_type, uint32_t clk_khz, uint32_t stepping)\n{\n\tif (dc->hwss.set_clock)\n\t\treturn dc->hwss.set_clock(dc, clock_type, clk_khz, stepping);\n\treturn DC_ERROR_UNEXPECTED;\n}\nvoid dc_get_clock(struct dc *dc, enum dc_clock_type clock_type, struct dc_clock_config *clock_cfg)\n{\n\tif (dc->hwss.get_clock)\n\t\tdc->hwss.get_clock(dc, clock_type, clock_cfg);\n}\n\n \nbool dc_set_psr_allow_active(struct dc *dc, bool enable)\n{\n\tint i;\n\tbool allow_active;\n\n\tfor (i = 0; i < dc->current_state->stream_count ; i++) {\n\t\tstruct dc_link *link;\n\t\tstruct dc_stream_state *stream = dc->current_state->streams[i];\n\n\t\tlink = stream->link;\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tif (link->psr_settings.psr_feature_enabled) {\n\t\t\tif (enable && !link->psr_settings.psr_allow_active) {\n\t\t\t\tallow_active = true;\n\t\t\t\tif (!dc_link_set_psr_allow_active(link, &allow_active, false, false, NULL))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!enable && link->psr_settings.psr_allow_active) {\n\t\t\t\tallow_active = false;\n\t\t\t\tif (!dc_link_set_psr_allow_active(link, &allow_active, true, false, NULL))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid dc_allow_idle_optimizations(struct dc *dc, bool allow)\n{\n\tif (dc->debug.disable_idle_power_optimizations)\n\t\treturn;\n\n\tif (dc->clk_mgr != NULL && dc->clk_mgr->funcs->is_smu_present)\n\t\tif (!dc->clk_mgr->funcs->is_smu_present(dc->clk_mgr))\n\t\t\treturn;\n\n\tif (allow == dc->idle_optimizations_allowed)\n\t\treturn;\n\n\tif (dc->hwss.apply_idle_power_optimizations && dc->hwss.apply_idle_power_optimizations(dc, allow))\n\t\tdc->idle_optimizations_allowed = allow;\n}\n\n \nvoid dc_unlock_memory_clock_frequency(struct dc *dc)\n{\n\tif (dc->clk_mgr->funcs->set_hard_min_memclk)\n\t\tdc->clk_mgr->funcs->set_hard_min_memclk(dc->clk_mgr, false);\n\n\tif (dc->clk_mgr->funcs->set_hard_max_memclk)\n\t\tdc->clk_mgr->funcs->set_hard_max_memclk(dc->clk_mgr);\n}\n\n \nvoid dc_lock_memory_clock_frequency(struct dc *dc)\n{\n\tif (dc->clk_mgr->funcs->get_memclk_states_from_smu)\n\t\tdc->clk_mgr->funcs->get_memclk_states_from_smu(dc->clk_mgr);\n\n\tif (dc->clk_mgr->funcs->set_hard_min_memclk)\n\t\tdc->clk_mgr->funcs->set_hard_min_memclk(dc->clk_mgr, true);\n\n\tif (dc->clk_mgr->funcs->set_hard_max_memclk)\n\t\tdc->clk_mgr->funcs->set_hard_max_memclk(dc->clk_mgr);\n}\n\nstatic void blank_and_force_memclk(struct dc *dc, bool apply, unsigned int memclk_mhz)\n{\n\tstruct dc_state *context = dc->current_state;\n\tstruct hubp *hubp;\n\tstruct pipe_ctx *pipe;\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream != NULL) {\n\t\t\tdc->hwss.disable_pixel_data(dc, pipe, true);\n\n\t\t\t\n\t\t\tpipe->stream_res.tg->funcs->wait_for_state(pipe->stream_res.tg, CRTC_STATE_VACTIVE);\n\t\t\tpipe->stream_res.tg->funcs->wait_for_state(pipe->stream_res.tg, CRTC_STATE_VBLANK);\n\t\t\tpipe->stream_res.tg->funcs->wait_for_state(pipe->stream_res.tg, CRTC_STATE_VACTIVE);\n\n\t\t\thubp = pipe->plane_res.hubp;\n\t\t\thubp->funcs->set_blank_regs(hubp, true);\n\t\t}\n\t}\n\n\tdc->clk_mgr->funcs->set_max_memclk(dc->clk_mgr, memclk_mhz);\n\tdc->clk_mgr->funcs->set_min_memclk(dc->clk_mgr, memclk_mhz);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream != NULL) {\n\t\t\tdc->hwss.disable_pixel_data(dc, pipe, false);\n\n\t\t\thubp = pipe->plane_res.hubp;\n\t\t\thubp->funcs->set_blank_regs(hubp, false);\n\t\t}\n\t}\n}\n\n\n \nvoid dc_enable_dcmode_clk_limit(struct dc *dc, bool enable)\n{\n\tunsigned int softMax = 0, maxDPM = 0, funcMin = 0, i;\n\tbool p_state_change_support;\n\n\tif (!dc->config.dc_mode_clk_limit_support)\n\t\treturn;\n\n\tsoftMax = dc->clk_mgr->bw_params->dc_mode_softmax_memclk;\n\tfor (i = 0; i < dc->clk_mgr->bw_params->clk_table.num_entries; i++) {\n\t\tif (dc->clk_mgr->bw_params->clk_table.entries[i].memclk_mhz > maxDPM)\n\t\t\tmaxDPM = dc->clk_mgr->bw_params->clk_table.entries[i].memclk_mhz;\n\t}\n\tfuncMin = (dc->clk_mgr->clks.dramclk_khz + 999) / 1000;\n\tp_state_change_support = dc->clk_mgr->clks.p_state_change_support;\n\n\tif (enable && !dc->clk_mgr->dc_mode_softmax_enabled) {\n\t\tif (p_state_change_support) {\n\t\t\tif (funcMin <= softMax)\n\t\t\t\tdc->clk_mgr->funcs->set_max_memclk(dc->clk_mgr, softMax);\n\t\t\t\n\t\t} else {\n\t\t\tif (funcMin <= softMax)\n\t\t\t\tblank_and_force_memclk(dc, true, softMax);\n\t\t\t\n\t\t}\n\t} else if (!enable && dc->clk_mgr->dc_mode_softmax_enabled) {\n\t\tif (p_state_change_support) {\n\t\t\tif (funcMin <= softMax)\n\t\t\t\tdc->clk_mgr->funcs->set_max_memclk(dc->clk_mgr, maxDPM);\n\t\t\t\n\t\t} else {\n\t\t\tif (funcMin <= softMax)\n\t\t\t\tblank_and_force_memclk(dc, true, maxDPM);\n\t\t\t\n\t\t}\n\t}\n\tdc->clk_mgr->dc_mode_softmax_enabled = enable;\n}\nbool dc_is_plane_eligible_for_idle_optimizations(struct dc *dc, struct dc_plane_state *plane,\n\t\tstruct dc_cursor_attributes *cursor_attr)\n{\n\tif (dc->hwss.does_plane_fit_in_mall && dc->hwss.does_plane_fit_in_mall(dc, plane, cursor_attr))\n\t\treturn true;\n\treturn false;\n}\n\n \nvoid dc_hardware_release(struct dc *dc)\n{\n\tdc_mclk_switch_using_fw_based_vblank_stretch_shut_down(dc);\n\n\tif (dc->hwss.hardware_release)\n\t\tdc->hwss.hardware_release(dc);\n}\n\nvoid dc_mclk_switch_using_fw_based_vblank_stretch_shut_down(struct dc *dc)\n{\n\tif (dc->current_state)\n\t\tdc->current_state->bw_ctx.bw.dcn.clk.fw_based_mclk_switching_shut_down = true;\n}\n\n \nbool dc_is_dmub_outbox_supported(struct dc *dc)\n{\n\tswitch (dc->ctx->asic_id.chip_family) {\n\n\tcase FAMILY_YELLOW_CARP:\n\t\t \n\t\tif (dc->ctx->asic_id.hw_internal_rev == YELLOW_CARP_B0 &&\n\t\t    !dc->debug.dpia_debug.bits.disable_dpia)\n\t\t\treturn true;\n\tbreak;\n\n\tcase AMDGPU_FAMILY_GC_11_0_1:\n\tcase AMDGPU_FAMILY_GC_11_5_0:\n\t\tif (!dc->debug.dpia_debug.bits.disable_dpia)\n\t\t\treturn true;\n\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\treturn dc->debug.enable_dmub_aux_for_legacy_ddc;\n\n}\n\n \nbool dc_enable_dmub_notifications(struct dc *dc)\n{\n\treturn dc_is_dmub_outbox_supported(dc);\n}\n\n \nvoid dc_enable_dmub_outbox(struct dc *dc)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\n\tdmub_enable_outbox_notification(dc_ctx->dmub_srv);\n\tDC_LOG_DC(\"%s: dmub outbox notifications enabled\\n\", __func__);\n}\n\n \nbool dc_process_dmub_aux_transfer_async(struct dc *dc,\n\t\t\t\tuint32_t link_index,\n\t\t\t\tstruct aux_payload *payload)\n{\n\tuint8_t action;\n\tunion dmub_rb_cmd cmd = {0};\n\n\tASSERT(payload->length <= 16);\n\n\tcmd.dp_aux_access.header.type = DMUB_CMD__DP_AUX_ACCESS;\n\tcmd.dp_aux_access.header.payload_bytes = 0;\n\t \n\tif (!dc->links[link_index]->ddc->ddc_pin)\n\t\tcmd.dp_aux_access.aux_control.type = AUX_CHANNEL_DPIA;\n\telse\n\t\tcmd.dp_aux_access.aux_control.type = AUX_CHANNEL_LEGACY_DDC;\n\n\tcmd.dp_aux_access.aux_control.instance = dc->links[link_index]->ddc_hw_inst;\n\tcmd.dp_aux_access.aux_control.sw_crc_enabled = 0;\n\tcmd.dp_aux_access.aux_control.timeout = 0;\n\tcmd.dp_aux_access.aux_control.dpaux.address = payload->address;\n\tcmd.dp_aux_access.aux_control.dpaux.is_i2c_over_aux = payload->i2c_over_aux;\n\tcmd.dp_aux_access.aux_control.dpaux.length = payload->length;\n\n\t \n\tif (payload->i2c_over_aux) {\n\t\tif (payload->write) {\n\t\t\tif (payload->mot)\n\t\t\t\taction = DP_AUX_REQ_ACTION_I2C_WRITE_MOT;\n\t\t\telse\n\t\t\t\taction = DP_AUX_REQ_ACTION_I2C_WRITE;\n\t\t} else {\n\t\t\tif (payload->mot)\n\t\t\t\taction = DP_AUX_REQ_ACTION_I2C_READ_MOT;\n\t\t\telse\n\t\t\t\taction = DP_AUX_REQ_ACTION_I2C_READ;\n\t\t\t}\n\t} else {\n\t\tif (payload->write)\n\t\t\taction = DP_AUX_REQ_ACTION_DPCD_WRITE;\n\t\telse\n\t\t\taction = DP_AUX_REQ_ACTION_DPCD_READ;\n\t}\n\n\tcmd.dp_aux_access.aux_control.dpaux.action = action;\n\n\tif (payload->length && payload->write) {\n\t\tmemcpy(cmd.dp_aux_access.aux_control.dpaux.data,\n\t\t\tpayload->data,\n\t\t\tpayload->length\n\t\t\t);\n\t}\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nuint8_t get_link_index_from_dpia_port_index(const struct dc *dc,\n\t\t\t\t\t    uint8_t dpia_port_index)\n{\n\tuint8_t index, link_index = 0xFF;\n\n\tfor (index = 0; index < dc->link_count; index++) {\n\t\t \n\t\tif (!dc->links[index]->ddc->ddc_pin) {\n\t\t\tif (dc->links[index]->ddc_hw_inst == dpia_port_index) {\n\t\t\t\tlink_index = index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tASSERT(link_index != 0xFF);\n\treturn link_index;\n}\n\n \nbool dc_process_dmub_set_config_async(struct dc *dc,\n\t\t\t\tuint32_t link_index,\n\t\t\t\tstruct set_config_cmd_payload *payload,\n\t\t\t\tstruct dmub_notification *notify)\n{\n\tunion dmub_rb_cmd cmd = {0};\n\tbool is_cmd_complete = true;\n\n\t \n\tcmd.set_config_access.header.type = DMUB_CMD__DPIA;\n\tcmd.set_config_access.header.sub_type = DMUB_CMD__DPIA_SET_CONFIG_ACCESS;\n\n\tcmd.set_config_access.set_config_control.instance = dc->links[link_index]->ddc_hw_inst;\n\tcmd.set_config_access.set_config_control.cmd_pkt.msg_type = payload->msg_type;\n\tcmd.set_config_access.set_config_control.cmd_pkt.msg_data = payload->msg_data;\n\n\tif (!dm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY)) {\n\t\t \n\t\tnotify->sc_status = SET_CONFIG_UNKNOWN_ERROR;\n\t\treturn is_cmd_complete;\n\t}\n\n\t \n\tif (cmd.set_config_access.header.ret_status == 1)\n\t\tnotify->sc_status = cmd.set_config_access.set_config_control.immed_status;\n\telse\n\t\t \n\t\tis_cmd_complete = false;\n\n\treturn is_cmd_complete;\n}\n\n \nenum dc_status dc_process_dmub_set_mst_slots(const struct dc *dc,\n\t\t\t\tuint32_t link_index,\n\t\t\t\tuint8_t mst_alloc_slots,\n\t\t\t\tuint8_t *mst_slots_in_use)\n{\n\tunion dmub_rb_cmd cmd = {0};\n\n\t \n\tcmd.set_mst_alloc_slots.header.type = DMUB_CMD__DPIA;\n\tcmd.set_mst_alloc_slots.header.sub_type = DMUB_CMD__DPIA_MST_ALLOC_SLOTS;\n\n\tcmd.set_mst_alloc_slots.mst_slots_control.instance = dc->links[link_index]->ddc_hw_inst;\n\tcmd.set_mst_alloc_slots.mst_slots_control.mst_alloc_slots = mst_alloc_slots;\n\n\tif (!dm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY))\n\t\t \n\t\treturn DC_ERROR_UNEXPECTED;\n\n\t \n\tif (cmd.set_config_access.header.ret_status != 1)\n\t\t \n\t\treturn DC_ERROR_UNEXPECTED;\n\n\t \n\tif (cmd.set_mst_alloc_slots.mst_slots_control.immed_status == 2)\n\t\treturn DC_FAIL_UNSUPPORTED_1;\n\n\t \n\tif (cmd.set_mst_alloc_slots.mst_slots_control.immed_status == 3) {\n\t\t*mst_slots_in_use = cmd.set_mst_alloc_slots.mst_slots_control.mst_slots_in_use;\n\t\treturn DC_NOT_SUPPORTED;\n\t}\n\n\treturn DC_OK;\n}\n\n \nvoid dc_process_dmub_dpia_hpd_int_enable(const struct dc *dc,\n\t\t\t\tuint32_t hpd_int_enable)\n{\n\tunion dmub_rb_cmd cmd = {0};\n\n\tcmd.dpia_hpd_int_enable.header.type = DMUB_CMD__DPIA_HPD_INT_ENABLE;\n\tcmd.dpia_hpd_int_enable.enable = hpd_int_enable;\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\tDC_LOG_DEBUG(\"%s: hpd_int_enable(%d)\\n\", __func__, hpd_int_enable);\n}\n\n \nvoid dc_print_dmub_diagnostic_data(const struct dc *dc)\n{\n\tdc_dmub_srv_log_diagnostic_data(dc->ctx->dmub_srv);\n}\n\n \nvoid dc_disable_accelerated_mode(struct dc *dc)\n{\n\tbios_set_scratch_acc_mode_change(dc->ctx->dc_bios, 0);\n}\n\n\n \nvoid dc_notify_vsync_int_state(struct dc *dc, struct dc_stream_state *stream, bool enable)\n{\n\tint i;\n\tint edp_num;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct dc_link *link = stream->sink->link;\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\n\n\tif (link->psr_settings.psr_feature_enabled)\n\t\treturn;\n\n\tif (link->replay_settings.replay_feature_enabled)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.tg)\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_PIPES) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\n\t \n\tfor (i = 0; i < edp_num; i++) {\n\t\tif (edp_links[i] == link)\n\t\t\tbreak;\n\t}\n\n\tif (i == edp_num) {\n\t\treturn;\n\t}\n\n\tif (pipe->stream_res.abm && pipe->stream_res.abm->funcs->set_abm_pause)\n\t\tpipe->stream_res.abm->funcs->set_abm_pause(pipe->stream_res.abm, !enable, i, pipe->stream_res.tg->inst);\n}\n\n \nbool dc_abm_save_restore(\n\t\tstruct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct abm_save_restore *pData)\n{\n\tint i;\n\tint edp_num;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct dc_link *link = stream->sink->link;\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.tg)\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_PIPES) {\n\t\tASSERT(0);\n\t\treturn false;\n\t}\n\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\n\t \n\tfor (i = 0; i < edp_num; i++)\n\t\tif (edp_links[i] == link)\n\t\t\tbreak;\n\n\tif (i == edp_num)\n\t\treturn false;\n\n\tif (pipe->stream_res.abm &&\n\t\tpipe->stream_res.abm->funcs->save_restore)\n\t\treturn pipe->stream_res.abm->funcs->save_restore(\n\t\t\t\tpipe->stream_res.abm,\n\t\t\t\ti,\n\t\t\t\tpData);\n\treturn false;\n}\n\nvoid dc_query_current_properties(struct dc *dc, struct dc_current_properties *properties)\n{\n\tunsigned int i;\n\tbool subvp_in_use = false;\n\n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tif (dc->current_state->streams[i]->mall_stream_config.type != SUBVP_NONE) {\n\t\t\tsubvp_in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tproperties->cursor_size_limit = subvp_in_use ? 64 : dc->caps.max_cursor_size;\n}\n\n \nvoid dc_set_edp_power(const struct dc *dc, struct dc_link *edp_link,\n\t\t\t\t bool powerOn)\n{\n\tif (edp_link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn;\n\n\tif (edp_link->skip_implict_edp_power_control == false)\n\t\treturn;\n\n\tedp_link->dc->link_srv->edp_set_panel_power(edp_link, powerOn);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}