{
  "module_name": "dcn30_fpu.c",
  "hash_id": "8861af412f80ddd59c50b07f0a1f01512fb67a4a420dcc51937114ee7f87b8b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn30/dcn30_fpu.c",
  "human_readable_source": " \n#include \"resource.h\"\n#include \"clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"dcn_calc_math.h\"\n#include \"dcn20/dcn20_resource.h\"\n#include \"dcn30/dcn30_resource.h\"\n\n#include \"clk_mgr/dcn30/dcn30_smu11_driver_if.h\"\n#include \"display_mode_vba_30.h\"\n#include \"dcn30_fpu.h\"\n\n#define REG(reg)\\\n\toptc1->tg_regs->reg\n\n#define CTX \\\n\toptc1->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\toptc1->tg_shift->field_name, optc1->tg_mask->field_name\n\n\nstruct _vcs_dpi_ip_params_st dcn3_0_ip = {\n\t.use_min_dcfclk = 0,\n\t.clamp_min_dcfclk = 0,\n\t.odm_capable = 1,\n\t.gpuvm_enable = 0,\n\t.hostvm_enable = 0,\n\t.gpuvm_max_page_table_levels = 4,\n\t.hostvm_max_page_table_levels = 4,\n\t.hostvm_cached_page_table_levels = 0,\n\t.pte_group_size_bytes = 2048,\n\t.num_dsc = 6,\n\t.rob_buffer_size_kbytes = 184,\n\t.det_buffer_size_kbytes = 184,\n\t.dpte_buffer_size_in_pte_reqs_luma = 84,\n\t.pde_proc_buffer_size_64k_reqs = 48,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.pte_enable = 1,\n\t.max_page_table_levels = 2,\n\t.pte_chunk_size_kbytes = 2,  \n\t.meta_chunk_size_kbytes = 2,\n\t.writeback_chunk_size_kbytes = 8,\n\t.line_buffer_size_bits = 789504,\n\t.is_line_buffer_bpp_fixed = 0,  \n\t.line_buffer_fixed_bpp = 0,     \n\t.dcc_supported = true,\n\t.writeback_interface_buffer_size_kbytes = 90,\n\t.writeback_line_buffer_buffer_size = 0,\n\t.max_line_buffer_lines = 12,\n\t.writeback_luma_buffer_size_kbytes = 12,  \n\t.writeback_chroma_buffer_size_kbytes = 8,\n\t.writeback_chroma_line_buffer_width_pixels = 4,\n\t.writeback_max_hscl_ratio = 1,\n\t.writeback_max_vscl_ratio = 1,\n\t.writeback_min_hscl_ratio = 1,\n\t.writeback_min_vscl_ratio = 1,\n\t.writeback_max_hscl_taps = 1,\n\t.writeback_max_vscl_taps = 1,\n\t.writeback_line_buffer_luma_buffer_size = 0,\n\t.writeback_line_buffer_chroma_buffer_size = 14643,\n\t.cursor_buffer_size = 8,\n\t.cursor_chunk_size = 2,\n\t.max_num_otg = 6,\n\t.max_num_dpp = 6,\n\t.max_num_wb = 1,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 6,\n\t.max_vscl_ratio = 6,\n\t.hscl_mults = 4,\n\t.vscl_mults = 4,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dispclk_ramp_margin_percent = 1,\n\t.underscan_factor = 1.11,\n\t.min_vblank_lines = 32,\n\t.dppclk_delay_subtotal = 46,\n\t.dynamic_metadata_vm_enabled = true,\n\t.dppclk_delay_scl_lb_only = 16,\n\t.dppclk_delay_scl = 50,\n\t.dppclk_delay_cnvc_formatter = 27,\n\t.dppclk_delay_cnvc_cursor = 6,\n\t.dispclk_delay_subtotal = 119,\n\t.dcfclk_cstate_latency = 5.2, \n\t.max_inter_dcn_tile_repeaters = 8,\n\t.max_num_hdmi_frl_outputs = 1,\n\t.odm_combine_4to1_supported = true,\n\n\t.xfc_supported = false,\n\t.xfc_fill_bw_overhead_percent = 10.0,\n\t.xfc_fill_constant_bytes = 0,\n\t.gfx7_compat_tiling_supported = 0,\n\t.number_of_cursors = 1,\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn3_0_soc = {\n\t.clock_limits = {\n\t\t\t{\n\t\t\t\t.state = 0,\n\t\t\t\t.dispclk_mhz = 562.0,\n\t\t\t\t.dppclk_mhz = 300.0,\n\t\t\t\t.phyclk_mhz = 300.0,\n\t\t\t\t.phyclk_d18_mhz = 667.0,\n\t\t\t\t.dscclk_mhz = 405.6,\n\t\t\t},\n\t\t},\n\n\t.min_dcfclk = 500.0,  \n\t.num_states = 1,\n\t.sr_exit_time_us = 15.5,\n\t.sr_enter_plus_exit_time_us = 20,\n\t.urgent_latency_us = 4.0,\n\t.urgent_latency_pixel_data_only_us = 4.0,\n\t.urgent_latency_pixel_mixed_with_vm_data_us = 4.0,\n\t.urgent_latency_vm_data_only_us = 4.0,\n\t.urgent_out_of_order_return_per_channel_pixel_only_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_vm_only_bytes = 4096,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_only = 80.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm = 60.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_vm_only = 40.0,\n\t.max_avg_sdp_bw_use_normal_percent = 60.0,\n\t.max_avg_dram_bw_use_normal_percent = 40.0,\n\t.writeback_latency_us = 12.0,\n\t.max_request_size_bytes = 256,\n\t.fabric_datapath_to_dcn_data_return_bytes = 64,\n\t.dcn_downspread_percent = 0.5,\n\t.downspread_percent = 0.38,\n\t.dram_page_open_time_ns = 50.0,\n\t.dram_rw_turnaround_time_ns = 17.5,\n\t.dram_return_buffer_per_channel_bytes = 8192,\n\t.round_trip_ping_latency_dcfclk_cycles = 191,\n\t.urgent_out_of_order_return_per_channel_bytes = 4096,\n\t.channel_interleave_bytes = 256,\n\t.num_banks = 8,\n\t.gpuvm_min_page_size_bytes = 4096,\n\t.hostvm_min_page_size_bytes = 4096,\n\t.dram_clock_change_latency_us = 404,\n\t.dummy_pstate_latency_us = 5,\n\t.writeback_dram_clock_change_latency_us = 23.0,\n\t.return_bus_width_bytes = 64,\n\t.dispclk_dppclk_vco_speed_mhz = 3650,\n\t.xfc_bus_transport_time_us = 20,      \n\t.xfc_xbuf_latency_tolerance_us = 4,  \n\t.use_urgent_burst_bw = 1,            \n\t.do_urgent_latency_adjustment = true,\n\t.urgent_latency_adjustment_fabric_clock_component_us = 1.0,\n\t.urgent_latency_adjustment_fabric_clock_reference_mhz = 1000,\n};\n\n\nvoid optc3_fpu_set_vrr_m_const(struct timing_generator *optc,\n\t\tdouble vtotal_avg)\n{\n\tstruct optc *optc1 = DCN10TG_FROM_TG(optc);\n\tdouble vtotal_min, vtotal_max;\n\tdouble ratio, modulo, phase;\n\tuint32_t vblank_start;\n\tuint32_t v_total_mask_value = 0;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tv_total_mask_value = 16;\n\tvtotal_min = dcn_bw_floor(vtotal_avg);\n\tvtotal_max = dcn_bw_ceil(vtotal_avg);\n\n\t \n\tREG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START,\n\t\t&vblank_start);\n\tASSERT(vtotal_min >= vblank_start + 1);\n\n\t \n\tif (vtotal_min == vtotal_max) {\n\t\tREG_SET(OTG_V_TOTAL, 0, OTG_V_TOTAL, (uint32_t)vtotal_min);\n\n\t\toptc->funcs->set_vtotal_min_max(optc, 0, 0);\n\t\tREG_SET(OTG_M_CONST_DTO0, 0, OTG_M_CONST_DTO_PHASE, 0);\n\t\tREG_SET(OTG_M_CONST_DTO1, 0, OTG_M_CONST_DTO_MODULO, 0);\n\t\tREG_UPDATE_3(OTG_V_TOTAL_CONTROL,\n\t\t\tOTG_V_TOTAL_MIN_SEL, 0,\n\t\t\tOTG_V_TOTAL_MAX_SEL, 0,\n\t\t\tOTG_SET_V_TOTAL_MIN_MASK_EN, 0);\n\t\treturn;\n\t}\n\n\tratio = vtotal_max - vtotal_avg;\n\tmodulo = 65536.0 * 65536.0 - 1.0;  \n\tphase = ratio * modulo;\n\n\t \n\tif (phase <= 0 || phase >= modulo) {\n\t\tREG_SET(OTG_V_TOTAL, 0, OTG_V_TOTAL,\n\t\t\tphase <= 0 ?\n\t\t\t\t(uint32_t)vtotal_max : (uint32_t)vtotal_min);\n\t\tREG_SET(OTG_V_TOTAL_MIN, 0, OTG_V_TOTAL_MIN, 0);\n\t\tREG_SET(OTG_V_TOTAL_MAX, 0, OTG_V_TOTAL_MAX, 0);\n\t\tREG_SET(OTG_M_CONST_DTO0, 0, OTG_M_CONST_DTO_PHASE, 0);\n\t\tREG_SET(OTG_M_CONST_DTO1, 0, OTG_M_CONST_DTO_MODULO, 0);\n\t\tREG_UPDATE_3(OTG_V_TOTAL_CONTROL,\n\t\t\tOTG_V_TOTAL_MIN_SEL, 0,\n\t\t\tOTG_V_TOTAL_MAX_SEL, 0,\n\t\t\tOTG_SET_V_TOTAL_MIN_MASK_EN, 0);\n\t\treturn;\n\t}\n\tREG_UPDATE_6(OTG_V_TOTAL_CONTROL,\n\t\tOTG_V_TOTAL_MIN_SEL, 1,\n\t\tOTG_V_TOTAL_MAX_SEL, 1,\n\t\tOTG_SET_V_TOTAL_MIN_MASK_EN, 1,\n\t\tOTG_SET_V_TOTAL_MIN_MASK, v_total_mask_value,\n\t\tOTG_VTOTAL_MID_REPLACING_MIN_EN, 0,\n\t\tOTG_VTOTAL_MID_REPLACING_MAX_EN, 0);\n\tREG_SET(OTG_V_TOTAL, 0, OTG_V_TOTAL, (uint32_t)vtotal_min);\n\toptc->funcs->set_vtotal_min_max(optc, vtotal_min, vtotal_max);\n\tREG_SET(OTG_M_CONST_DTO0, 0, OTG_M_CONST_DTO_PHASE, (uint32_t)phase);\n\tREG_SET(OTG_M_CONST_DTO1, 0, OTG_M_CONST_DTO_MODULO, (uint32_t)modulo);\n}\n\nvoid dcn30_fpu_populate_dml_writeback_from_context(\n\t\tstruct dc *dc, struct resource_context *res_ctx, display_e2e_pipe_params_st *pipes)\n{\n\tint pipe_cnt, i, j;\n\tdouble max_calc_writeback_dispclk;\n\tdouble writeback_dispclk;\n\tstruct writeback_st dout_wb;\n\n\tdc_assert_fp_enabled();\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_stream_state *stream = res_ctx->pipe_ctx[i].stream;\n\n\t\tif (!stream)\n\t\t\tcontinue;\n\t\tmax_calc_writeback_dispclk = 0;\n\n\t\t \n\t\tpipes[pipe_cnt].dout.wb_enable = 0;\n\t\tpipes[pipe_cnt].dout.num_active_wb = 0;\n\t\tfor (j = 0; j < stream->num_wb_info; j++) {\n\t\t\tstruct dc_writeback_info *wb_info = &stream->writeback_info[j];\n\n\t\t\tif (wb_info->wb_enabled && wb_info->writeback_source_plane &&\n\t\t\t\t\t(wb_info->writeback_source_plane == res_ctx->pipe_ctx[i].plane_state)) {\n\t\t\t\tpipes[pipe_cnt].dout.wb_enable = 1;\n\t\t\t\tpipes[pipe_cnt].dout.num_active_wb++;\n\t\t\t\tdout_wb.wb_src_height = wb_info->dwb_params.cnv_params.crop_en ?\n\t\t\t\t\twb_info->dwb_params.cnv_params.crop_height :\n\t\t\t\t\twb_info->dwb_params.cnv_params.src_height;\n\t\t\t\tdout_wb.wb_src_width = wb_info->dwb_params.cnv_params.crop_en ?\n\t\t\t\t\twb_info->dwb_params.cnv_params.crop_width :\n\t\t\t\t\twb_info->dwb_params.cnv_params.src_width;\n\t\t\t\tdout_wb.wb_dst_width = wb_info->dwb_params.dest_width;\n\t\t\t\tdout_wb.wb_dst_height = wb_info->dwb_params.dest_height;\n\n\t\t\t\t \n\t\t\t\tif (dc->dml.ip.writeback_max_hscl_taps > 1) {\n\t\t\t\t\tdout_wb.wb_htaps_luma = wb_info->dwb_params.scaler_taps.h_taps;\n\t\t\t\t\tdout_wb.wb_vtaps_luma = wb_info->dwb_params.scaler_taps.v_taps;\n\t\t\t\t} else {\n\t\t\t\t\tdout_wb.wb_htaps_luma = 1;\n\t\t\t\t\tdout_wb.wb_vtaps_luma = 1;\n\t\t\t\t}\n\t\t\t\tdout_wb.wb_htaps_chroma = 0;\n\t\t\t\tdout_wb.wb_vtaps_chroma = 0;\n\t\t\t\tdout_wb.wb_hratio = wb_info->dwb_params.cnv_params.crop_en ?\n\t\t\t\t\t(double)wb_info->dwb_params.cnv_params.crop_width /\n\t\t\t\t\t\t(double)wb_info->dwb_params.dest_width :\n\t\t\t\t\t(double)wb_info->dwb_params.cnv_params.src_width /\n\t\t\t\t\t\t(double)wb_info->dwb_params.dest_width;\n\t\t\t\tdout_wb.wb_vratio = wb_info->dwb_params.cnv_params.crop_en ?\n\t\t\t\t\t(double)wb_info->dwb_params.cnv_params.crop_height /\n\t\t\t\t\t\t(double)wb_info->dwb_params.dest_height :\n\t\t\t\t\t(double)wb_info->dwb_params.cnv_params.src_height /\n\t\t\t\t\t\t(double)wb_info->dwb_params.dest_height;\n\t\t\t\tif (wb_info->dwb_params.cnv_params.fc_out_format == DWB_OUT_FORMAT_64BPP_ARGB ||\n\t\t\t\t\twb_info->dwb_params.cnv_params.fc_out_format == DWB_OUT_FORMAT_64BPP_RGBA)\n\t\t\t\t\tdout_wb.wb_pixel_format = dm_444_64;\n\t\t\t\telse\n\t\t\t\t\tdout_wb.wb_pixel_format = dm_444_32;\n\n\t\t\t\t \n\t\t\t\twriteback_dispclk = dml30_CalculateWriteBackDISPCLK(\n\t\t\t\t\t\tdout_wb.wb_pixel_format,\n\t\t\t\t\t\tpipes[pipe_cnt].pipe.dest.pixel_rate_mhz,\n\t\t\t\t\t\tdout_wb.wb_hratio,\n\t\t\t\t\t\tdout_wb.wb_vratio,\n\t\t\t\t\t\tdout_wb.wb_htaps_luma,\n\t\t\t\t\t\tdout_wb.wb_vtaps_luma,\n\t\t\t\t\t\tdout_wb.wb_src_width,\n\t\t\t\t\t\tdout_wb.wb_dst_width,\n\t\t\t\t\t\tpipes[pipe_cnt].pipe.dest.htotal,\n\t\t\t\t\t\tdc->current_state->bw_ctx.dml.ip.writeback_line_buffer_buffer_size);\n\n\t\t\t\tif (writeback_dispclk > max_calc_writeback_dispclk) {\n\t\t\t\t\tmax_calc_writeback_dispclk = writeback_dispclk;\n\t\t\t\t\tpipes[pipe_cnt].dout.wb = dout_wb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpipe_cnt++;\n\t}\n}\n\nvoid dcn30_fpu_set_mcif_arb_params(struct mcif_arb_params *wb_arb_params,\n\tstruct display_mode_lib *dml,\n\tdisplay_e2e_pipe_params_st *pipes,\n\tint pipe_cnt,\n\tint cur_pipe)\n{\n\tint i;\n\n\tdc_assert_fp_enabled();\n\n\tfor (i = 0; i < ARRAY_SIZE(wb_arb_params->cli_watermark); i++) {\n\t\twb_arb_params->cli_watermark[i] = get_wm_writeback_urgent(dml, pipes, pipe_cnt) * 1000;\n\t\twb_arb_params->pstate_watermark[i] = get_wm_writeback_dram_clock_change(dml, pipes, pipe_cnt) * 1000;\n\t}\n\n\twb_arb_params->dram_speed_change_duration = dml->vba.WritebackAllowDRAMClockChangeEndPosition[cur_pipe] * pipes[0].clks_cfg.refclk_mhz;  \n}\n\nvoid dcn30_fpu_update_soc_for_wm_a(struct dc *dc, struct dc_state *context)\n{\n\n\tdc_assert_fp_enabled();\n\n\tif (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].valid) {\n\t\tif (!context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching ||\n\t\t\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us == 0)\n\t\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_exit_time_us;\n\t}\n}\n\nvoid dcn30_fpu_calculate_wm_and_dlg(\n\t\tstruct dc *dc, struct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt,\n\t\tint vlevel)\n{\n\tint maxMpcComb = context->bw_ctx.dml.vba.maxMpcComb;\n\tint i, pipe_idx;\n\tdouble dcfclk = context->bw_ctx.dml.vba.DCFCLKState[vlevel][maxMpcComb];\n\tbool pstate_en = context->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] != dm_dram_clock_change_unsupported;\n\tunsigned int dummy_latency_index = 0;\n\n\tdc_assert_fp_enabled();\n\n\tcontext->bw_ctx.bw.dcn.clk.fw_based_mclk_switching = false;\n    for (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i])\n\t\t\tcontext->streams[i]->fpo_in_use = false;\n\t}\n\n\tif (!pstate_en) {\n\t\t \n\t\tcontext->bw_ctx.bw.dcn.clk.fw_based_mclk_switching =\n\t\t\tdcn30_can_support_mclk_switch_using_fw_based_vblank_stretch(dc, context);\n\n\t\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\t\tdummy_latency_index = dcn30_find_dummy_latency_index_for_fw_based_mclk_switch(dc,\n\t\t\t\tcontext, pipes, pipe_cnt, vlevel);\n\n\t\t\t \n\t\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\t\t\tdcn30_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, false, true);\n\t\t\tmaxMpcComb = context->bw_ctx.dml.vba.maxMpcComb;\n\t\t\tdcfclk = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\t\t\tpstate_en = context->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] != dm_dram_clock_change_unsupported;\n\t\t}\n\t}\n\n\tif (context->bw_ctx.dml.soc.min_dcfclk > dcfclk)\n\t\tdcfclk = context->bw_ctx.dml.soc.min_dcfclk;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\n\t \n\tif (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].valid) {\n\t\tif (vlevel == 0) {\n\t\t\tpipes[0].clks_cfg.voltage = 1;\n\t\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dcfclk_mhz;\n\t\t}\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.pstate_latency_us;\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.sr_exit_time_us;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk;\n\n\t \n\t \n\n\t \n\tif (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].valid) {\n\t\tunsigned int min_dram_speed_mts = context->bw_ctx.dml.vba.DRAMSpeed;\n\t\tunsigned int min_dram_speed_mts_margin = 160;\n\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[0].dummy_pstate_latency_us;\n\n\t\tif (context->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] ==\n\t\t\tdm_dram_clock_change_unsupported) {\n\t\t\tint min_dram_speed_mts_offset = dc->clk_mgr->bw_params->clk_table.num_entries - 1;\n\n\t\t\tmin_dram_speed_mts =\n\t\t\t\tdc->clk_mgr->bw_params->clk_table.entries[min_dram_speed_mts_offset].memclk_mhz * 16;\n\t\t}\n\n\t\tif (!context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\t\t \n\t\t\tfor (dummy_latency_index = 3; dummy_latency_index > 0; dummy_latency_index--)\n\t\t\t\tif (min_dram_speed_mts + min_dram_speed_mts_margin >\n\t\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dram_speed_mts)\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_exit_time_us;\n\t}\n\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif (!pstate_en) {\n\t\t \n\t\tcontext->bw_ctx.bw.dcn.watermarks.a = context->bw_ctx.bw.dcn.watermarks.c;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = 0;\n\t} else {\n\t\t \n\t\tdc->res_pool->funcs->update_soc_for_wm_a(dc, context);\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t}\n\n\tcontext->perf_params.stutter_period_us = context->bw_ctx.dml.vba.StutterPeriod;\n\n\t \n\tcontext->bw_ctx.bw.dcn.watermarks.d = context->bw_ctx.bw.dcn.watermarks.a;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = get_dispclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt);\n\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = get_dppclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\n\t\tif (dc->config.forced_clocks) {\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dispclk_mhz;\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dppclk_mhz;\n\t\t}\n\t\tif (dc->debug.min_disp_clk_khz > pipes[pipe_idx].clks_cfg.dispclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = dc->debug.min_disp_clk_khz / 1000.0;\n\t\tif (dc->debug.min_dpp_clk_khz > pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = dc->debug.min_dpp_clk_khz / 1000.0;\n\n\t\tpipe_idx++;\n\t}\n\n\t\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching &&\n\t\t\tdc->dml.soc.num_chans <= 4 &&\n\t\t\tcontext->bw_ctx.dml.vba.DRAMSpeed <= 1700 &&\n\t\t\tcontext->bw_ctx.dml.vba.DRAMSpeed >= 1500) {\n\n\t\tfor (i = 0; i < dc->dml.soc.num_states; i++) {\n\t\t\tif (dc->dml.soc.clock_limits[i].dram_speed_mts > 1700) {\n\t\t\t\tcontext->bw_ctx.dml.vba.DRAMSpeed = dc->dml.soc.clock_limits[i].dram_speed_mts;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdcn20_calculate_dlg_params(dc, context, pipes, pipe_cnt, vlevel);\n\n\tif (!pstate_en)\n\t\t \n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching)\n\t\tdcn30_setup_mclk_switch_using_fw_based_vblank_stretch(dc, context);\n}\n\nvoid dcn30_fpu_update_dram_channel_width_bytes(struct dc *dc)\n{\n\tdc_assert_fp_enabled();\n\n\tif (dc->ctx->dc_bios->vram_info.dram_channel_width_bytes)\n\t\tdcn3_0_soc.dram_channel_width_bytes = dc->ctx->dc_bios->vram_info.dram_channel_width_bytes;\n}\n\nvoid dcn30_fpu_update_max_clk(struct dc_bounding_box_max_clk *dcn30_bb_max_clk)\n{\n\t\tdc_assert_fp_enabled();\n\n\t\tif (!dcn30_bb_max_clk->max_dcfclk_mhz)\n\t\t\tdcn30_bb_max_clk->max_dcfclk_mhz = dcn3_0_soc.clock_limits[0].dcfclk_mhz;\n\t\tif (!dcn30_bb_max_clk->max_dispclk_mhz)\n\t\t\tdcn30_bb_max_clk->max_dispclk_mhz = dcn3_0_soc.clock_limits[0].dispclk_mhz;\n\t\tif (!dcn30_bb_max_clk->max_dppclk_mhz)\n\t\t\tdcn30_bb_max_clk->max_dppclk_mhz = dcn3_0_soc.clock_limits[0].dppclk_mhz;\n\t\tif (!dcn30_bb_max_clk->max_phyclk_mhz)\n\t\t\tdcn30_bb_max_clk->max_phyclk_mhz = dcn3_0_soc.clock_limits[0].phyclk_mhz;\n}\n\nvoid dcn30_fpu_get_optimal_dcfclk_fclk_for_uclk(unsigned int uclk_mts,\n\t\tunsigned int *optimal_dcfclk,\n\t\tunsigned int *optimal_fclk)\n{\n\tdouble bw_from_dram, bw_from_dram1, bw_from_dram2;\n\n\tdc_assert_fp_enabled();\n\n\tbw_from_dram1 = uclk_mts * dcn3_0_soc.num_chans *\n\t\tdcn3_0_soc.dram_channel_width_bytes * (dcn3_0_soc.max_avg_dram_bw_use_normal_percent / 100);\n\tbw_from_dram2 = uclk_mts * dcn3_0_soc.num_chans *\n\t\tdcn3_0_soc.dram_channel_width_bytes * (dcn3_0_soc.max_avg_sdp_bw_use_normal_percent / 100);\n\n\tbw_from_dram = (bw_from_dram1 < bw_from_dram2) ? bw_from_dram1 : bw_from_dram2;\n\n\tif (optimal_fclk)\n\t\t*optimal_fclk = bw_from_dram /\n\t\t(dcn3_0_soc.fabric_datapath_to_dcn_data_return_bytes * (dcn3_0_soc.max_avg_sdp_bw_use_normal_percent / 100));\n\n\tif (optimal_dcfclk)\n\t\t*optimal_dcfclk =  bw_from_dram /\n\t\t(dcn3_0_soc.return_bus_width_bytes * (dcn3_0_soc.max_avg_sdp_bw_use_normal_percent / 100));\n}\n\nvoid dcn30_fpu_update_bw_bounding_box(struct dc *dc,\n\tstruct clk_bw_params *bw_params,\n\tstruct dc_bounding_box_max_clk *dcn30_bb_max_clk,\n\tunsigned int *dcfclk_mhz,\n\tunsigned int *dram_speed_mts)\n{\n\tunsigned int i;\n\n\tdc_assert_fp_enabled();\n\n\tdcn3_0_soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\tdc->dml.soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\n\tfor (i = 0; i < dcn3_0_soc.num_states; i++) {\n\t\tdcn3_0_soc.clock_limits[i].state = i;\n\t\tdcn3_0_soc.clock_limits[i].dcfclk_mhz = dcfclk_mhz[i];\n\t\tdcn3_0_soc.clock_limits[i].fabricclk_mhz = dcfclk_mhz[i];\n\t\tdcn3_0_soc.clock_limits[i].dram_speed_mts = dram_speed_mts[i];\n\n\t\t \n\t\tdcn3_0_soc.clock_limits[i].dispclk_mhz = dcn30_bb_max_clk->max_dispclk_mhz;\n\t\tdcn3_0_soc.clock_limits[i].dppclk_mhz  = dcn30_bb_max_clk->max_dppclk_mhz;\n\t\tdcn3_0_soc.clock_limits[i].phyclk_mhz  = dcn30_bb_max_clk->max_phyclk_mhz;\n\t\tdcn3_0_soc.clock_limits[i].dtbclk_mhz = dcn3_0_soc.clock_limits[0].dtbclk_mhz;\n\t\t \n\t\t \n\t\tdcn3_0_soc.clock_limits[i].phyclk_d18_mhz = dcn3_0_soc.clock_limits[0].phyclk_d18_mhz;\n\t\tdcn3_0_soc.clock_limits[i].socclk_mhz = dcn3_0_soc.clock_limits[0].socclk_mhz;\n\t\tdcn3_0_soc.clock_limits[i].dscclk_mhz = dcn3_0_soc.clock_limits[0].dscclk_mhz;\n\t}\n\t \n\tdml_init_instance(&dc->dml, &dcn3_0_soc, &dcn3_0_ip, DML_PROJECT_DCN30);\n\tif (dc->current_state)\n\t\tdml_init_instance(&dc->current_state->bw_ctx.dml, &dcn3_0_soc, &dcn3_0_ip, DML_PROJECT_DCN30);\n\n}\n\n \nint dcn30_find_dummy_latency_index_for_fw_based_mclk_switch(struct dc *dc,\n\t\t\t\t\t\t\t    struct dc_state *context,\n\t\t\t\t\t\t\t    display_e2e_pipe_params_st *pipes,\n\t\t\t\t\t\t\t    int pipe_cnt,\n\t\t\t\t\t\t\t    int vlevel)\n{\n\tconst int max_latency_table_entries = 4;\n\tint dummy_latency_index = 0;\n\n\tdc_assert_fp_enabled();\n\n\twhile (dummy_latency_index < max_latency_table_entries) {\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\t\tdcn30_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, false, true);\n\n\t\tif (context->bw_ctx.dml.soc.allow_dram_self_refresh_or_dram_clock_change_in_vblank ==\n\t\t\tdm_allow_self_refresh_and_mclk_switch)\n\t\t\tbreak;\n\n\t\tdummy_latency_index++;\n\t}\n\n\tif (dummy_latency_index == max_latency_table_entries) {\n\t\tASSERT(dummy_latency_index != max_latency_table_entries);\n\t\t \n\t\tdummy_latency_index = 3;\n\t}\n\n\treturn dummy_latency_index;\n}\n\nvoid dcn3_fpu_build_wm_range_table(struct clk_mgr *base)\n{\n\t \n\tdouble pstate_latency_us = base->ctx->dc->dml.soc.dram_clock_change_latency_us;\n\tdouble sr_exit_time_us = base->ctx->dc->dml.soc.sr_exit_time_us;\n\tdouble sr_enter_plus_exit_time_us = base->ctx->dc->dml.soc.sr_enter_plus_exit_time_us;\n\tuint16_t min_uclk_mhz = base->bw_params->clk_table.entries[0].memclk_mhz;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tbase->bw_params->wm_table.nv_entries[WM_A].valid = true;\n\tbase->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us = pstate_latency_us;\n\tbase->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_exit_time_us = sr_exit_time_us;\n\tbase->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us;\n\tbase->bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.wm_type = WATERMARKS_CLOCK_RANGE;\n\tbase->bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.min_dcfclk = 0;\n\tbase->bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tbase->bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\tbase->bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.max_uclk = 0xFFFF;\n\n\t \n\n\n\n\n\n\n\n\n\n\n\t \n\tbase->bw_params->wm_table.nv_entries[WM_C].valid = true;\n\tbase->bw_params->wm_table.nv_entries[WM_C].dml_input.pstate_latency_us = 0;\n\tbase->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_exit_time_us = sr_exit_time_us;\n\tbase->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us;\n\tbase->bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.wm_type = WATERMARKS_DUMMY_PSTATE;\n\tbase->bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.min_dcfclk = 0;\n\tbase->bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tbase->bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\tbase->bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.max_uclk = 0xFFFF;\n\tbase->bw_params->dummy_pstate_table[0].dram_speed_mts = 1600;\n\tbase->bw_params->dummy_pstate_table[0].dummy_pstate_latency_us = 38;\n\tbase->bw_params->dummy_pstate_table[1].dram_speed_mts = 8000;\n\tbase->bw_params->dummy_pstate_table[1].dummy_pstate_latency_us = 9;\n\tbase->bw_params->dummy_pstate_table[2].dram_speed_mts = 10000;\n\tbase->bw_params->dummy_pstate_table[2].dummy_pstate_latency_us = 8;\n\tbase->bw_params->dummy_pstate_table[3].dram_speed_mts = 16000;\n\tbase->bw_params->dummy_pstate_table[3].dummy_pstate_latency_us = 5;\n\n\t \n\tbase->bw_params->wm_table.nv_entries[WM_D].valid = true;\n\tbase->bw_params->wm_table.nv_entries[WM_D].dml_input.pstate_latency_us = pstate_latency_us;\n\tbase->bw_params->wm_table.nv_entries[WM_D].dml_input.sr_exit_time_us = 2;\n\tbase->bw_params->wm_table.nv_entries[WM_D].dml_input.sr_enter_plus_exit_time_us = 4;\n\tbase->bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.wm_type = WATERMARKS_MALL;\n\tbase->bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.min_dcfclk = 0;\n\tbase->bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tbase->bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\tbase->bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.max_uclk = 0xFFFF;\n}\n\nvoid patch_dcn30_soc_bounding_box(struct dc *dc, struct _vcs_dpi_soc_bounding_box_st *dcn3_0_ip)\n{\n\tdc_assert_fp_enabled();\n\n\tif (dc->ctx->dc_bios->funcs->get_soc_bb_info) {\n\t\tstruct bp_soc_bb_info bb_info = {0};\n\n\t\tif (dc->ctx->dc_bios->funcs->get_soc_bb_info(dc->ctx->dc_bios, &bb_info) == BP_RESULT_OK) {\n\t\t\tif (bb_info.dram_clock_change_latency_100ns > 0)\n\t\t\t\tdcn3_0_soc.dram_clock_change_latency_us = bb_info.dram_clock_change_latency_100ns * 10;\n\n\t\t\tif (bb_info.dram_sr_enter_exit_latency_100ns > 0)\n\t\t\t\tdcn3_0_soc.sr_enter_plus_exit_time_us = bb_info.dram_sr_enter_exit_latency_100ns * 10;\n\n\t\t\tif (bb_info.dram_sr_exit_latency_100ns > 0)\n\t\t\t\tdcn3_0_soc.sr_exit_time_us = bb_info.dram_sr_exit_latency_100ns * 10;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}