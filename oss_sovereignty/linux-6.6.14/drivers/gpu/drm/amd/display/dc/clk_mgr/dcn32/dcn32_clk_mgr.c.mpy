{
  "module_name": "dcn32_clk_mgr.c",
  "hash_id": "c94e9f4c5baec6732fd822e57a326f2cca5a5737682456ad79637eff64392581",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
  "human_readable_source": " \n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n\n#include \"dcn32/dcn32_clk_mgr_smu_msg.h\"\n#include \"dcn20/dcn20_clk_mgr.h\"\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dcn31/dcn31_clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n#include \"link.h\"\n\n#include \"atomfirmware.h\"\n#include \"smu13_driver_if.h\"\n\n#include \"dcn/dcn_3_2_0_offset.h\"\n#include \"dcn/dcn_3_2_0_sh_mask.h\"\n\n#include \"dcn32/dcn32_clk_mgr.h\"\n#include \"dml/dcn32/dcn32_fpu.h\"\n\n#define DCN_BASE__INST0_SEG1                       0x000000C0\n\n#define mmCLK1_CLK_PLL_REQ                              0x16E37\n#define mmCLK1_CLK0_DFS_CNTL                            0x16E69\n#define mmCLK1_CLK1_DFS_CNTL                            0x16E6C\n#define mmCLK1_CLK2_DFS_CNTL                            0x16E6F\n#define mmCLK1_CLK3_DFS_CNTL                            0x16E72\n#define mmCLK1_CLK4_DFS_CNTL                            0x16E75\n\n#define CLK1_CLK_PLL_REQ__FbMult_int_MASK               0x000001ffUL\n#define CLK1_CLK_PLL_REQ__PllSpineDiv_MASK              0x0000f000UL\n#define CLK1_CLK_PLL_REQ__FbMult_frac_MASK              0xffff0000UL\n#define CLK1_CLK_PLL_REQ__FbMult_int__SHIFT             0x00000000\n#define CLK1_CLK_PLL_REQ__PllSpineDiv__SHIFT            0x0000000c\n#define CLK1_CLK_PLL_REQ__FbMult_frac__SHIFT            0x00000010\n\n#define mmCLK01_CLK0_CLK_PLL_REQ                        0x16E37\n#define mmCLK01_CLK0_CLK0_DFS_CNTL                      0x16E64\n#define mmCLK01_CLK0_CLK1_DFS_CNTL                      0x16E67\n#define mmCLK01_CLK0_CLK2_DFS_CNTL                      0x16E6A\n#define mmCLK01_CLK0_CLK3_DFS_CNTL                      0x16E6D\n#define mmCLK01_CLK0_CLK4_DFS_CNTL                      0x16E70\n\n#define CLK0_CLK_PLL_REQ__FbMult_int_MASK               0x000001ffL\n#define CLK0_CLK_PLL_REQ__PllSpineDiv_MASK              0x0000f000L\n#define CLK0_CLK_PLL_REQ__FbMult_frac_MASK              0xffff0000L\n#define CLK0_CLK_PLL_REQ__FbMult_int__SHIFT             0x00000000\n#define CLK0_CLK_PLL_REQ__PllSpineDiv__SHIFT            0x0000000c\n#define CLK0_CLK_PLL_REQ__FbMult_frac__SHIFT            0x00000010\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#define BASE_INNER(seg) DCN_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(reg ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\treg ## reg_name\n\n#define CLK_SR_DCN32(reg_name)\\\n\t.reg_name = mm ## reg_name\n\nstatic const struct clk_mgr_registers clk_mgr_regs_dcn32 = {\n\tCLK_REG_LIST_DCN32()\n};\n\nstatic const struct clk_mgr_shift clk_mgr_shift_dcn32 = {\n\tCLK_COMMON_MASK_SH_LIST_DCN32(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask clk_mgr_mask_dcn32 = {\n\tCLK_COMMON_MASK_SH_LIST_DCN32(_MASK)\n};\n\n\n#define CLK_SR_DCN321(reg_name, block, inst)\\\n\t.reg_name = mm ## block ## _ ## reg_name\n\nstatic const struct clk_mgr_registers clk_mgr_regs_dcn321 = {\n\tCLK_REG_LIST_DCN321()\n};\n\nstatic const struct clk_mgr_shift clk_mgr_shift_dcn321 = {\n\tCLK_COMMON_MASK_SH_LIST_DCN321(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask clk_mgr_mask_dcn321 = {\n\tCLK_COMMON_MASK_SH_LIST_DCN321(_MASK)\n};\n\n\n \nstatic void dcn32_init_single_clock(struct clk_mgr_internal *clk_mgr, PPCLK_e clk, unsigned int *entry_0,\n\t\tunsigned int *num_levels)\n{\n\tunsigned int i;\n\tchar *entry_i = (char *)entry_0;\n\n\tuint32_t ret = dcn30_smu_get_dpm_freq_by_index(clk_mgr, clk, 0xFF);\n\n\tif (ret & (1 << 31))\n\t\t \n\t\t*num_levels = 2;\n\telse\n\t\t \n\t\t \n\t\t*num_levels = ret & 0xFF;\n\n\t \n\tfor (i = 0; i < *num_levels; i++) {\n\t\t*((unsigned int *)entry_i) = (dcn30_smu_get_dpm_freq_by_index(clk_mgr, clk, i) & 0xFFFF);\n\t\tentry_i += sizeof(clk_mgr->base.bw_params->clk_table.entries[0]);\n\t}\n}\n\nstatic void dcn32_build_wm_range_table(struct clk_mgr_internal *clk_mgr)\n{\n\tDC_FP_START();\n\tdcn32_build_wm_range_table_fpu(clk_mgr);\n\tDC_FP_END();\n}\n\nvoid dcn32_init_clocks(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int num_levels;\n\tstruct clk_limit_num_entries *num_entries_per_clk = &clk_mgr_base->bw_params->clk_table.num_entries_per_clk;\n\tunsigned int i;\n\n\tmemset(&(clk_mgr_base->clks), 0, sizeof(struct dc_clocks));\n\tclk_mgr_base->clks.p_state_change_support = true;\n\tclk_mgr_base->clks.prev_p_state_change_support = true;\n\tclk_mgr_base->clks.fclk_prev_p_state_change_support = true;\n\tclk_mgr->smu_present = false;\n\tclk_mgr->dpm_present = false;\n\n\tif (!clk_mgr_base->bw_params)\n\t\treturn;\n\n\tif (!clk_mgr_base->force_smu_not_present && dcn30_smu_get_smu_version(clk_mgr, &clk_mgr->smu_ver))\n\t\tclk_mgr->smu_present = true;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_check_driver_if_version(clk_mgr);\n\tdcn30_smu_check_msg_header_version(clk_mgr);\n\n\t \n\tdcn32_init_single_clock(clk_mgr, PPCLK_DCFCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dcfclk_mhz,\n\t\t\t&num_entries_per_clk->num_dcfclk_levels);\n\tclk_mgr_base->bw_params->dc_mode_limit.dcfclk_mhz = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_DCFCLK);\n\n\t \n\tdcn32_init_single_clock(clk_mgr, PPCLK_SOCCLK,\n\t\t\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].socclk_mhz,\n\t\t\t\t\t&num_entries_per_clk->num_socclk_levels);\n\tclk_mgr_base->bw_params->dc_mode_limit.socclk_mhz = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_SOCCLK);\n\n\t \n\tif (!clk_mgr->base.ctx->dc->debug.disable_dtb_ref_clk_switch) {\n\t\tdcn32_init_single_clock(clk_mgr, PPCLK_DTBCLK,\n\t\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dtbclk_mhz,\n\t\t\t\t&num_entries_per_clk->num_dtbclk_levels);\n\t\tclk_mgr_base->bw_params->dc_mode_limit.dtbclk_mhz =\n\t\t\t\tdcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_DTBCLK);\n\t}\n\n\t \n\tdcn32_init_single_clock(clk_mgr, PPCLK_DISPCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].dispclk_mhz,\n\t\t\t&num_entries_per_clk->num_dispclk_levels);\n\tnum_levels = num_entries_per_clk->num_dispclk_levels;\n\tclk_mgr_base->bw_params->dc_mode_limit.dispclk_mhz = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_DISPCLK);\n\t\n\tif (clk_mgr_base->bw_params->dc_mode_limit.dispclk_mhz > 1950)\n\t\tclk_mgr_base->bw_params->dc_mode_limit.dispclk_mhz = 1950;\n\n\tif (num_entries_per_clk->num_dcfclk_levels &&\n\t\t\tnum_entries_per_clk->num_dtbclk_levels &&\n\t\t\tnum_entries_per_clk->num_dispclk_levels)\n\t\tclk_mgr->dpm_present = true;\n\n\tif (clk_mgr_base->ctx->dc->debug.min_disp_clk_khz) {\n\t\tfor (i = 0; i < num_levels; i++)\n\t\t\tif (clk_mgr_base->bw_params->clk_table.entries[i].dispclk_mhz\n\t\t\t\t\t< khz_to_mhz_ceil(clk_mgr_base->ctx->dc->debug.min_disp_clk_khz))\n\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[i].dispclk_mhz\n\t\t\t\t\t= khz_to_mhz_ceil(clk_mgr_base->ctx->dc->debug.min_disp_clk_khz);\n\t}\n\tfor (i = 0; i < num_levels; i++)\n\t\tif (clk_mgr_base->bw_params->clk_table.entries[i].dispclk_mhz > 1950)\n\t\t\tclk_mgr_base->bw_params->clk_table.entries[i].dispclk_mhz = 1950;\n\n\tif (clk_mgr_base->ctx->dc->debug.min_dpp_clk_khz) {\n\t\tfor (i = 0; i < num_levels; i++)\n\t\t\tif (clk_mgr_base->bw_params->clk_table.entries[i].dppclk_mhz\n\t\t\t\t\t< khz_to_mhz_ceil(clk_mgr_base->ctx->dc->debug.min_dpp_clk_khz))\n\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[i].dppclk_mhz\n\t\t\t\t\t= khz_to_mhz_ceil(clk_mgr_base->ctx->dc->debug.min_dpp_clk_khz);\n\t}\n\n\t \n\tclk_mgr_base->funcs->get_memclk_states_from_smu(clk_mgr_base);\n\n\tDC_FP_START();\n\t \n\tdcn32_build_wm_range_table(clk_mgr);\n\tDC_FP_END();\n}\n\nstatic void dcn32_update_clocks_update_dtb_dto(struct clk_mgr_internal *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tint ref_dtbclk_khz)\n{\n\tstruct dccg *dccg = clk_mgr->dccg;\n\tuint32_t tg_mask = 0;\n\tint i;\n\n\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tstruct dtbclk_dto_params dto_params = {0};\n\n\t\t \n\t\tif (pipe_ctx->stream_res.tg &&\n\t\t\t\t!(tg_mask & (1 << pipe_ctx->stream_res.tg->inst))) {\n\t\t\ttg_mask |= (1 << pipe_ctx->stream_res.tg->inst);\n\n\t\t\tdto_params.otg_inst = pipe_ctx->stream_res.tg->inst;\n\t\t\tdto_params.ref_dtbclk_khz = ref_dtbclk_khz;\n\n\t\t\tdccg->funcs->set_dtbclk_dto(clk_mgr->dccg, &dto_params);\n\t\t\t\n\t\t}\n\t}\n}\n\n \nstatic void dcn32_update_dppclk_dispclk_freq(struct clk_mgr_internal *clk_mgr, struct dc_clocks *new_clocks)\n{\n\tint dpp_divider = 0;\n\tint disp_divider = 0;\n\n\tif (new_clocks->dppclk_khz) {\n\t\tdpp_divider = DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t\t* clk_mgr->base.dentist_vco_freq_khz / new_clocks->dppclk_khz;\n\t\tnew_clocks->dppclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR * clk_mgr->base.dentist_vco_freq_khz) / dpp_divider;\n\t}\n\tif (new_clocks->dispclk_khz > 0) {\n\t\tdisp_divider = DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t\t* clk_mgr->base.dentist_vco_freq_khz / new_clocks->dispclk_khz;\n\t\tnew_clocks->dispclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR * clk_mgr->base.dentist_vco_freq_khz) / disp_divider;\n\t}\n}\n\nvoid dcn32_update_clocks_update_dpp_dto(struct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context, bool safe_to_lower)\n{\n\tint i;\n\n\tclk_mgr->dccg->ref_dppclk = clk_mgr->base.clks.dppclk_khz;\n\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\tint dpp_inst = 0, dppclk_khz, prev_dppclk_khz;\n\n\t\tdppclk_khz = context->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz;\n\n\t\tif (context->res_ctx.pipe_ctx[i].plane_res.dpp)\n\t\t\tdpp_inst = context->res_ctx.pipe_ctx[i].plane_res.dpp->inst;\n\t\telse if (!context->res_ctx.pipe_ctx[i].plane_res.dpp && dppclk_khz == 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (!context->res_ctx.pipe_ctx[i].plane_res.dpp && dppclk_khz > 0) {\n\t\t\t \n\t\t\tASSERT(false);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprev_dppclk_khz = clk_mgr->dccg->pipe_dppclk_khz[i];\n\n\t\tif (safe_to_lower || prev_dppclk_khz < dppclk_khz)\n\t\t\tclk_mgr->dccg->funcs->update_dpp_dto(\n\t\t\t\t\t\t\tclk_mgr->dccg, dpp_inst, dppclk_khz);\n\t}\n}\n\nstatic void dcn32_update_clocks_update_dentist(\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context)\n{\n\tuint32_t new_disp_divider = 0;\n\tuint32_t new_dispclk_wdivider = 0;\n\tuint32_t old_dispclk_wdivider = 0;\n\tuint32_t i;\n\tuint32_t dentist_dispclk_wdivider_readback = 0;\n\tstruct dc *dc = clk_mgr->base.ctx->dc;\n\n\tif (clk_mgr->base.clks.dispclk_khz == 0)\n\t\treturn;\n\n\tnew_disp_divider = DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz / clk_mgr->base.clks.dispclk_khz;\n\n\tnew_dispclk_wdivider = dentist_get_did_from_divider(new_disp_divider);\n\tREG_GET(DENTIST_DISPCLK_CNTL,\n\t\t\tDENTIST_DISPCLK_WDIVIDER, &old_dispclk_wdivider);\n\n\t \n\tif (old_dispclk_wdivider == 127 && new_dispclk_wdivider != 127) {\n\t\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\tuint32_t fifo_level;\n\t\t\tstruct dccg *dccg = clk_mgr->base.ctx->dc->res_pool->dccg;\n\t\t\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\t\t\tint32_t N;\n\t\t\tint32_t j;\n\n\t\t\tif (!resource_is_pipe_type(pipe_ctx, OTG_MASTER))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!stream_enc->funcs->get_fifo_cal_average_level)\n\t\t\t\tcontinue;\n\t\t\tfifo_level = stream_enc->funcs->get_fifo_cal_average_level(\n\t\t\t\t\tstream_enc);\n\t\t\tN = fifo_level / 4;\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(\n\t\t\t\t\tdccg,\n\t\t\t\t\ttrue);\n\t\t\tfor (j = 0; j < N - 4; j++)\n\t\t\t\tdccg->funcs->otg_drop_pixel(\n\t\t\t\t\t\tdccg,\n\t\t\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(\n\t\t\t\t\tdccg,\n\t\t\t\t\tfalse);\n\t\t}\n\t} else if (new_dispclk_wdivider == 127 && old_dispclk_wdivider != 127) {\n\t\t \n\t\tuint32_t temp_disp_divider = dentist_get_divider_from_did(126);\n\t\tuint32_t temp_dispclk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR * clk_mgr->base.dentist_vco_freq_khz) / temp_disp_divider;\n\n\t\tif (clk_mgr->smu_present)\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DISPCLK, khz_to_mhz_ceil(temp_dispclk_khz));\n\n\t\tif (dc->debug.override_dispclk_programming) {\n\t\t\tREG_GET(DENTIST_DISPCLK_CNTL,\n\t\t\t\t\tDENTIST_DISPCLK_WDIVIDER, &dentist_dispclk_wdivider_readback);\n\n\t\t\tif (dentist_dispclk_wdivider_readback != 126) {\n\t\t\t\tREG_UPDATE(DENTIST_DISPCLK_CNTL,\n\t\t\t\t\t\tDENTIST_DISPCLK_WDIVIDER, 126);\n\t\t\t\tREG_WAIT(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, 1, 50, 2000);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\tstruct dccg *dccg = clk_mgr->base.ctx->dc->res_pool->dccg;\n\t\t\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\t\t\tuint32_t fifo_level;\n\t\t\tint32_t N;\n\t\t\tint32_t j;\n\n\t\t\tif (!resource_is_pipe_type(pipe_ctx, OTG_MASTER))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!stream_enc->funcs->get_fifo_cal_average_level)\n\t\t\t\tcontinue;\n\t\t\tfifo_level = stream_enc->funcs->get_fifo_cal_average_level(\n\t\t\t\t\tstream_enc);\n\t\t\tN = fifo_level / 4;\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(dccg, true);\n\t\t\tfor (j = 0; j < 12 - N; j++)\n\t\t\t\tdccg->funcs->otg_add_pixel(dccg,\n\t\t\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t\t\tdccg->funcs->set_fifo_errdet_ovr_en(dccg, false);\n\t\t}\n\t}\n\n\t \n\tif (clk_mgr->smu_present)\n\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DISPCLK, khz_to_mhz_ceil(clk_mgr->base.clks.dispclk_khz));\n\n\tif (dc->debug.override_dispclk_programming) {\n\t\tREG_GET(DENTIST_DISPCLK_CNTL,\n\t\t\t\tDENTIST_DISPCLK_WDIVIDER, &dentist_dispclk_wdivider_readback);\n\n\t\tif (dentist_dispclk_wdivider_readback > new_dispclk_wdivider) {\n\t\t\tREG_UPDATE(DENTIST_DISPCLK_CNTL,\n\t\t\t\t\tDENTIST_DISPCLK_WDIVIDER, new_dispclk_wdivider);\n\t\t\tREG_WAIT(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_DONE, 1, 50, 2000);\n\t\t}\n\t}\n\n}\n\nstatic int dcn32_get_dispclk_from_dentist(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tuint32_t dispclk_wdivider;\n\tint disp_divider;\n\n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, &dispclk_wdivider);\n\tdisp_divider = dentist_get_divider_from_did(dispclk_wdivider);\n\n\t \n\tif (disp_divider)\n\t\treturn (DENTIST_DIVIDER_RANGE_SCALE_FACTOR * clk_mgr->base.dentist_vco_freq_khz) / disp_divider;\n\n\treturn 0;\n}\n\n\nstatic void dcn32_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool enter_display_off = false;\n\tbool dpp_clock_lowered = false;\n\tstruct dmcu *dmcu = clk_mgr_base->ctx->dc->res_pool->dmcu;\n\tbool force_reset = false;\n\tbool update_uclk = false, update_fclk = false;\n\tbool p_state_change_support;\n\tbool fclk_p_state_change_support;\n\n\tif (clk_mgr_base->clks.dispclk_khz == 0 ||\n\t\t\t(dc->debug.force_clock_mode & 0x1)) {\n\t\t \n\t\tforce_reset = true;\n\n\t\tdcn2_read_clocks_from_hw_dentist(clk_mgr_base);\n\n\t\t \n\t}\n\tdisplay_count = clk_mgr_helper_get_active_display_cnt(dc, context);\n\n\tif (display_count == 0)\n\t\tenter_display_off = true;\n\n\tif (clk_mgr->smu_present) {\n\t\tif (enter_display_off == safe_to_lower)\n\t\t\tdcn30_smu_set_num_of_displays(clk_mgr, display_count);\n\n\t\tclk_mgr_base->clks.fclk_prev_p_state_change_support = clk_mgr_base->clks.fclk_p_state_change_support;\n\n\t\tfclk_p_state_change_support = new_clocks->fclk_p_state_change_support;\n\n\t\tif (should_update_pstate_support(safe_to_lower, fclk_p_state_change_support, clk_mgr_base->clks.fclk_p_state_change_support) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.fclk) {\n\t\t\tclk_mgr_base->clks.fclk_p_state_change_support = fclk_p_state_change_support;\n\n\t\t\t \n\t\t\tif (clk_mgr_base->ctx->dce_version != DCN_VERSION_3_21 && clk_mgr_base->clks.fclk_p_state_change_support) {\n\t\t\t\t \n\t\t\t\tdcn32_smu_send_fclk_pstate_message(clk_mgr, FCLK_PSTATE_SUPPORTED);\n\t\t\t}\n\t\t}\n\n\t\tif (dc->debug.force_min_dcfclk_mhz > 0)\n\t\t\tnew_clocks->dcfclk_khz = (new_clocks->dcfclk_khz > (dc->debug.force_min_dcfclk_mhz * 1000)) ?\n\t\t\t\t\tnew_clocks->dcfclk_khz : (dc->debug.force_min_dcfclk_mhz * 1000);\n\n\t\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.dcfclk) {\n\t\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DCFCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_khz));\n\t\t}\n\n\t\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.dcfclk_ds) {\n\t\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\t\tdcn30_smu_set_min_deep_sleep_dcef_clk(clk_mgr, khz_to_mhz_ceil(clk_mgr_base->clks.dcfclk_deep_sleep_khz));\n\t\t}\n\n\t\tif (should_set_clock(safe_to_lower, new_clocks->socclk_khz, clk_mgr_base->clks.socclk_khz))\n\t\t\t \n\t\t\tclk_mgr_base->clks.socclk_khz = new_clocks->socclk_khz;\n\n\t\tclk_mgr_base->clks.prev_p_state_change_support = clk_mgr_base->clks.p_state_change_support;\n\t\tclk_mgr_base->clks.prev_num_ways = clk_mgr_base->clks.num_ways;\n\n\t\tif (clk_mgr_base->clks.num_ways != new_clocks->num_ways &&\n\t\t\t\tclk_mgr_base->clks.num_ways < new_clocks->num_ways) {\n\t\t\tclk_mgr_base->clks.num_ways = new_clocks->num_ways;\n\t\t\tdcn32_smu_send_cab_for_uclk_message(clk_mgr, clk_mgr_base->clks.num_ways);\n\t\t}\n\n\t\tp_state_change_support = new_clocks->p_state_change_support;\n\t\tif (should_update_pstate_support(safe_to_lower, p_state_change_support, clk_mgr_base->clks.p_state_change_support) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.uclk) {\n\t\t\tclk_mgr_base->clks.p_state_change_support = p_state_change_support;\n\n\t\t\t \n\t\t\tif (!clk_mgr_base->clks.p_state_change_support) {\n\t\t\t\tif (dc->clk_mgr->dc_mode_softmax_enabled) {\n\t\t\t\t\t \n\t\t\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\t\t\tdc->clk_mgr->bw_params->dc_mode_softmax_memclk);\n\t\t\t\t} else {\n\t\t\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK, dc->clk_mgr->bw_params->max_memclk_mhz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching)\n\t\t\tdcn32_smu_wait_for_dmub_ack_mclk(clk_mgr, true);\n\t\telse\n\t\t\tdcn32_smu_wait_for_dmub_ack_mclk(clk_mgr, false);\n\n\t\t \n\t\tif (safe_to_lower && (clk_mgr_base->clks.fclk_p_state_change_support != clk_mgr_base->clks.fclk_prev_p_state_change_support)) {\n\t\t\tupdate_fclk = true;\n\t\t}\n\n\t\tif (clk_mgr_base->ctx->dce_version != DCN_VERSION_3_21 && !clk_mgr_base->clks.fclk_p_state_change_support && update_fclk &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.fclk) {\n\t\t\t \n\t\t\tdcn32_smu_send_fclk_pstate_message(clk_mgr, FCLK_PSTATE_NOTSUPPORTED);\n\t\t}\n\n\t\t \n\t\tif (should_set_clock(safe_to_lower, new_clocks->dramclk_khz, clk_mgr_base->clks.dramclk_khz) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.uclk) {\n\t\t\tclk_mgr_base->clks.dramclk_khz = new_clocks->dramclk_khz;\n\t\t\tupdate_uclk = true;\n\t\t}\n\n\t\t \n\t\tif (clk_mgr_base->clks.p_state_change_support &&\n\t\t\t\t(update_uclk || !clk_mgr_base->clks.prev_p_state_change_support) &&\n\t\t\t\t!dc->work_arounds.clock_update_disable_mask.uclk)\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dramclk_khz));\n\n\t\tif (clk_mgr_base->clks.num_ways != new_clocks->num_ways &&\n\t\t\t\tclk_mgr_base->clks.num_ways > new_clocks->num_ways) {\n\t\t\tclk_mgr_base->clks.num_ways = new_clocks->num_ways;\n\t\t\tdcn32_smu_send_cab_for_uclk_message(clk_mgr, clk_mgr_base->clks.num_ways);\n\t\t}\n\t}\n\n\tdcn32_update_dppclk_dispclk_freq(clk_mgr, new_clocks);\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr_base->clks.dppclk_khz)) {\n\t\tif (clk_mgr_base->clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\n\t\tclk_mgr_base->clks.dppclk_khz = new_clocks->dppclk_khz;\n\n\t\tif (clk_mgr->smu_present && !dpp_clock_lowered)\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DPPCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dppclk_khz));\n\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (!new_clocks->dtbclk_en) {\n\t\tnew_clocks->ref_dtbclk_khz = clk_mgr_base->bw_params->clk_table.entries[0].dtbclk_mhz * 1000;\n\t}\n\n\t \n\tif (!dc->debug.disable_dtb_ref_clk_switch &&\n\t\t\tshould_set_clock(safe_to_lower, new_clocks->ref_dtbclk_khz / 1000, clk_mgr_base->clks.ref_dtbclk_khz / 1000)) {\n\t\t \n\t\tclk_mgr_base->clks.ref_dtbclk_khz =\n\t\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DTBCLK, khz_to_mhz_ceil(new_clocks->ref_dtbclk_khz));\n\t\tdcn32_update_clocks_update_dtb_dto(clk_mgr, context, clk_mgr_base->clks.ref_dtbclk_khz);\n\t}\n\n\tif (dc->config.forced_clocks == false || (force_reset && safe_to_lower)) {\n\t\tif (dpp_clock_lowered) {\n\t\t\t \n\t\t\tdcn32_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t\tdcn32_update_clocks_update_dentist(clk_mgr, context);\n\t\t\tif (clk_mgr->smu_present)\n\t\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_DPPCLK, khz_to_mhz_ceil(clk_mgr_base->clks.dppclk_khz));\n\t\t} else {\n\t\t\t \n\t\t\tif (update_dppclk || update_dispclk)\n\t\t\t\tdcn32_update_clocks_update_dentist(clk_mgr, context);\n\t\t\t \n\t\t\tdcn32_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\t}\n\t}\n\n\tif (update_dispclk && dmcu && dmcu->funcs->is_dmcu_initialized(dmcu))\n\t\t \n\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\t\tclk_mgr_base->clks.dispclk_khz / 1000 / 7);\n}\n\nstatic uint32_t dcn32_get_vco_frequency_from_reg(struct clk_mgr_internal *clk_mgr)\n{\n\t\tstruct fixed31_32 pll_req;\n\t\tuint32_t pll_req_reg = 0;\n\n\t\t \n\t\tif (ASICREV_IS_GC_11_0_2(clk_mgr->base.ctx->asic_id.hw_internal_rev))\n\t\t\tpll_req_reg = REG_READ(CLK0_CLK_PLL_REQ);\n\t\telse\n\t\t\tpll_req_reg = REG_READ(CLK1_CLK_PLL_REQ);\n\n\t\t \n\t\tpll_req = dc_fixpt_from_int(pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_int);\n\t\tpll_req.value |= pll_req_reg & clk_mgr->clk_mgr_mask->FbMult_frac;\n\n\t\t \n\t\tpll_req = dc_fixpt_mul_int(pll_req, clk_mgr->dfs_ref_freq_khz);\n\n\t\treturn dc_fixpt_floor(pll_req);\n}\n\nstatic void dcn32_dump_clk_registers(struct clk_state_registers_and_bypass *regs_and_bypass,\n\t\tstruct clk_mgr *clk_mgr_base, struct clk_log_info *log_info)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tuint32_t dprefclk_did = 0;\n\tuint32_t dcfclk_did = 0;\n\tuint32_t dtbclk_did = 0;\n\tuint32_t dispclk_did = 0;\n\tuint32_t dppclk_did = 0;\n\tuint32_t target_div = 0;\n\n\tif (ASICREV_IS_GC_11_0_2(clk_mgr->base.ctx->asic_id.hw_internal_rev)) {\n\t\t \n\t\tdispclk_did = REG_READ(CLK0_CLK0_DFS_CNTL);\n\t\t \n\t\tdppclk_did = REG_READ(CLK0_CLK1_DFS_CNTL);\n\t\t \n\t\tdprefclk_did = REG_READ(CLK0_CLK2_DFS_CNTL);\n\t\t \n\t\tdcfclk_did = REG_READ(CLK0_CLK3_DFS_CNTL);\n\t\t \n\t\tdtbclk_did = REG_READ(CLK0_CLK4_DFS_CNTL);\n\t} else {\n\t\t \n\t\tdispclk_did = REG_READ(CLK1_CLK0_DFS_CNTL);\n\t\t \n\t\tdppclk_did = REG_READ(CLK1_CLK1_DFS_CNTL);\n\t\t \n\t\tdprefclk_did = REG_READ(CLK1_CLK2_DFS_CNTL);\n\t\t \n\t\tdcfclk_did = REG_READ(CLK1_CLK3_DFS_CNTL);\n\t\t \n\t\tdtbclk_did = REG_READ(CLK1_CLK4_DFS_CNTL);\n\t}\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dispclk_did);\n\t\n\tregs_and_bypass->dispclk = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dppclk_did);\n\t\n\tregs_and_bypass->dppclk = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dprefclk_did);\n\t\n\tregs_and_bypass->dprefclk = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dcfclk_did);\n\t\n\tregs_and_bypass->dcfclk = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dtbclk_did);\n\t\n\tregs_and_bypass->dtbclk = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n}\n\nstatic void dcn32_clock_read_ss_info(struct clk_mgr_internal *clk_mgr)\n{\n\tstruct dc_bios *bp = clk_mgr->base.ctx->dc_bios;\n\tint ss_info_num = bp->funcs->get_ss_entry_number(\n\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL);\n\n\tif (ss_info_num) {\n\t\tstruct spread_spectrum_info info = { { 0 } };\n\t\tenum bp_result result = bp->funcs->get_spread_spectrum_info(\n\t\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL, 0, &info);\n\n\t\t \n\t\tif (result == BP_RESULT_OK &&\n\t\t\t\tinfo.spread_spectrum_percentage != 0) {\n\t\t\tclk_mgr->ss_on_dprefclk = true;\n\t\t\tclk_mgr->dprefclk_ss_divider = info.spread_percentage_divider;\n\n\t\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t\t \n\t\t\t\tclk_mgr->dprefclk_ss_percentage =\n\t\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void dcn32_notify_wm_ranges(struct clk_mgr *clk_mgr_base)\n{\n\tunsigned int i;\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tWatermarksExternal_t *table = (WatermarksExternal_t *) clk_mgr->wm_range_table;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (!table)\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\t \n\tfor (i = 0; i < WM_SET_COUNT; i++)\n\t\tif (clk_mgr->base.bw_params->wm_table.nv_entries[i].valid) {\n\t\t\ttable->Watermarks.WatermarkRow[i].WmSetting = i;\n\t\t\ttable->Watermarks.WatermarkRow[i].Flags = clk_mgr->base.bw_params->wm_table.nv_entries[i].pmfw_breakdown.wm_type;\n\t\t}\n\tdcn30_smu_set_dram_addr_high(clk_mgr, clk_mgr->wm_range_table_addr >> 32);\n\tdcn30_smu_set_dram_addr_low(clk_mgr, clk_mgr->wm_range_table_addr & 0xFFFFFFFF);\n\tdcn32_smu_transfer_wm_table_dram_2_smu(clk_mgr);\n}\n\n \nstatic void dcn32_set_hard_min_memclk(struct clk_mgr *clk_mgr_base, bool current_mode)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (current_mode) {\n\t\tif (clk_mgr_base->clks.p_state_change_support)\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tkhz_to_mhz_ceil(clk_mgr_base->clks.dramclk_khz));\n\t\telse\n\t\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\t\tclk_mgr_base->bw_params->max_memclk_mhz);\n\t} else {\n\t\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK,\n\t\t\t\tclk_mgr_base->bw_params->clk_table.entries[0].memclk_mhz);\n\t}\n}\n\n \nstatic void dcn32_set_hard_max_memclk(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_set_hard_max_by_freq(clk_mgr, PPCLK_UCLK, clk_mgr_base->bw_params->max_memclk_mhz);\n}\n\n \nstatic void dcn32_get_memclk_states_from_smu(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct clk_limit_num_entries *num_entries_per_clk = &clk_mgr_base->bw_params->clk_table.num_entries_per_clk;\n\tunsigned int num_levels;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t \n\tdcn32_init_single_clock(clk_mgr, PPCLK_UCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].memclk_mhz,\n\t\t\t&num_entries_per_clk->num_memclk_levels);\n\tclk_mgr_base->bw_params->dc_mode_limit.memclk_mhz = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_UCLK);\n\tclk_mgr_base->bw_params->dc_mode_softmax_memclk = clk_mgr_base->bw_params->dc_mode_limit.memclk_mhz;\n\n\t \n\tnum_entries_per_clk->num_memclk_levels = num_entries_per_clk->num_memclk_levels ? num_entries_per_clk->num_memclk_levels : 1;\n\n\tdcn32_init_single_clock(clk_mgr, PPCLK_FCLK,\n\t\t\t&clk_mgr_base->bw_params->clk_table.entries[0].fclk_mhz,\n\t\t\t&num_entries_per_clk->num_fclk_levels);\n\tclk_mgr_base->bw_params->dc_mode_limit.fclk_mhz = dcn30_smu_get_dc_mode_max_dpm_freq(clk_mgr, PPCLK_FCLK);\n\n\tif (num_entries_per_clk->num_memclk_levels >= num_entries_per_clk->num_fclk_levels) {\n\t\tnum_levels = num_entries_per_clk->num_memclk_levels;\n\t} else {\n\t\tnum_levels = num_entries_per_clk->num_fclk_levels;\n\t}\n\tclk_mgr_base->bw_params->max_memclk_mhz =\n\t\t\tclk_mgr_base->bw_params->clk_table.entries[num_entries_per_clk->num_memclk_levels - 1].memclk_mhz;\n\tclk_mgr_base->bw_params->clk_table.num_entries = num_levels ? num_levels : 1;\n\n\tif (clk_mgr->dpm_present && !num_levels)\n\t\tclk_mgr->dpm_present = false;\n\n\tif (!clk_mgr->dpm_present)\n\t\tdcn32_patch_dpm_table(clk_mgr_base->bw_params);\n\n\tDC_FP_START();\n\t \n\tclk_mgr_base->ctx->dc->res_pool->funcs->update_bw_bounding_box(\n\t\t\tclk_mgr->base.ctx->dc, clk_mgr_base->bw_params);\n\tDC_FP_END();\n}\n\nstatic bool dcn32_are_clock_states_equal(struct dc_clocks *a,\n\t\t\t\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\telse if (a->dramclk_khz != b->dramclk_khz)\n\t\treturn false;\n\telse if (a->p_state_change_support != b->p_state_change_support)\n\t\treturn false;\n\telse if (a->fclk_p_state_change_support != b->fclk_p_state_change_support)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void dcn32_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn32_smu_set_pme_workaround(clk_mgr);\n}\n\nstatic bool dcn32_is_smu_present(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\treturn clk_mgr->smu_present;\n}\n\nstatic void dcn32_set_max_memclk(struct clk_mgr *clk_mgr_base, unsigned int memclk_mhz)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn30_smu_set_hard_max_by_freq(clk_mgr, PPCLK_UCLK, memclk_mhz);\n}\n\nstatic void dcn32_set_min_memclk(struct clk_mgr *clk_mgr_base, unsigned int memclk_mhz)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn32_smu_set_hard_min_by_freq(clk_mgr, PPCLK_UCLK, memclk_mhz);\n}\n\nstatic struct clk_mgr_funcs dcn32_funcs = {\n\t\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t\t.get_dtb_ref_clk_frequency = dcn31_get_dtb_ref_freq_khz,\n\t\t.update_clocks = dcn32_update_clocks,\n\t\t.dump_clk_registers = dcn32_dump_clk_registers,\n\t\t.init_clocks = dcn32_init_clocks,\n\t\t.notify_wm_ranges = dcn32_notify_wm_ranges,\n\t\t.set_hard_min_memclk = dcn32_set_hard_min_memclk,\n\t\t.set_hard_max_memclk = dcn32_set_hard_max_memclk,\n\t\t.set_max_memclk = dcn32_set_max_memclk,\n\t\t.set_min_memclk = dcn32_set_min_memclk,\n\t\t.get_memclk_states_from_smu = dcn32_get_memclk_states_from_smu,\n\t\t.are_clock_states_equal = dcn32_are_clock_states_equal,\n\t\t.enable_pme_wa = dcn32_enable_pme_wa,\n\t\t.is_smu_present = dcn32_is_smu_present,\n\t\t.get_dispclk_from_dentist = dcn32_get_dispclk_from_dentist,\n};\n\nvoid dcn32_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct clk_log_info log_info = {0};\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn32_funcs;\n\tif (ASICREV_IS_GC_11_0_2(clk_mgr->base.ctx->asic_id.hw_internal_rev)) {\n\t\tclk_mgr->regs = &clk_mgr_regs_dcn321;\n\t\tclk_mgr->clk_mgr_shift = &clk_mgr_shift_dcn321;\n\t\tclk_mgr->clk_mgr_mask = &clk_mgr_mask_dcn321;\n\t} else {\n\t\tclk_mgr->regs = &clk_mgr_regs_dcn32;\n\t\tclk_mgr->clk_mgr_shift = &clk_mgr_shift_dcn32;\n\t\tclk_mgr->clk_mgr_mask = &clk_mgr_mask_dcn32;\n\t}\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->dfs_ref_freq_khz = 100000;\n\n\t \n\tclk_mgr->base.dprefclk_khz = 716666;\n\tif (ctx->dc->debug.disable_dtb_ref_clk_switch) {\n\t\t\n\t\tif (ctx->dce_version == DCN_VERSION_3_21)\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz = 477800;\n\t\telse\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz = 268750;\n\t}\n\n\n\t \n\tclk_mgr->base.dentist_vco_freq_khz = dcn32_get_vco_frequency_from_reg(clk_mgr);\n\n\t \n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 4300000;  \n\n\tdcn32_dump_clk_registers(&clk_mgr->base.boot_snapshot, &clk_mgr->base, &log_info);\n\n\tif (ctx->dc->debug.disable_dtb_ref_clk_switch &&\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz != clk_mgr->base.boot_snapshot.dtbclk) {\n\t\tclk_mgr->base.clks.ref_dtbclk_khz = clk_mgr->base.boot_snapshot.dtbclk;\n\t}\n\n\tif (clk_mgr->base.boot_snapshot.dprefclk != 0) {\n\t\tclk_mgr->base.dprefclk_khz = clk_mgr->base.boot_snapshot.dprefclk;\n\t}\n\tdcn32_clock_read_ss_info(clk_mgr);\n\n\tclk_mgr->dfs_bypass_enabled = false;\n\n\tclk_mgr->smu_present = false;\n\n\tclk_mgr->base.bw_params = kzalloc(sizeof(*clk_mgr->base.bw_params), GFP_KERNEL);\n\n\t \n\tclk_mgr->wm_range_table = dm_helpers_allocate_gpu_mem(clk_mgr->base.ctx,\n\t\t\tDC_MEM_ALLOC_TYPE_GART, sizeof(WatermarksExternal_t),\n\t\t\t&clk_mgr->wm_range_table_addr);\n}\n\nvoid dcn32_clk_mgr_destroy(struct clk_mgr_internal *clk_mgr)\n{\n\tkfree(clk_mgr->base.bw_params);\n\n\tif (clk_mgr->wm_range_table)\n\t\tdm_helpers_free_gpu_mem(clk_mgr->base.ctx, DC_MEM_ALLOC_TYPE_GART,\n\t\t\t\tclk_mgr->wm_range_table);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}