{
  "module_name": "dce110_hw_sequencer.c",
  "hash_id": "f9d2d34aad0ed638c743542127be2b2c8fde28dd9196c32ce147067abea9fdc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"dc_bios_types.h\"\n#include \"core_types.h\"\n#include \"core_status.h\"\n#include \"resource.h\"\n#include \"dm_helpers.h\"\n#include \"dce110_timing_generator.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"gpio_service_interface.h\"\n\n#include \"dce110_compressor.h\"\n\n#include \"bios/bios_parser_helper.h\"\n#include \"timing_generator.h\"\n#include \"mem_input.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"transform.h\"\n#include \"stream_encoder.h\"\n#include \"link_encoder.h\"\n#include \"link_enc_cfg.h\"\n#include \"link_hwss.h\"\n#include \"link.h\"\n#include \"dccg.h\"\n#include \"clock_source.h\"\n#include \"clk_mgr.h\"\n#include \"abm.h\"\n#include \"audio.h\"\n#include \"reg_helper.h\"\n#include \"panel_cntl.h\"\n#include \"dpcd_defs.h\"\n \n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n#include \"custom_float.h\"\n\n#include \"atomfirmware.h\"\n\n#include \"dcn10/dcn10_hw_sequencer.h\"\n\n#include \"dce110_hw_sequencer.h\"\n\n#define GAMMA_HW_POINTS_NUM 256\n\n \n#define PANEL_POWER_UP_TIMEOUT 300\n#define PANEL_POWER_DOWN_TIMEOUT 500\n#define HPD_CHECK_INTERVAL 10\n#define OLED_POST_T7_DELAY 100\n#define OLED_PRE_T11_DELAY 150\n\n#define CTX \\\n\thws->ctx\n\n#define DC_LOGGER_INIT()\n\n#define REG(reg)\\\n\thws->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstruct dce110_hw_seq_reg_offsets {\n\tuint32_t crtc;\n};\n\nstatic const struct dce110_hw_seq_reg_offsets reg_offsets[] = {\n{\n\t.crtc = (mmCRTC0_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC1_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC2_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTCV_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n}\n};\n\n#define HW_REG_BLND(reg, id)\\\n\t(reg + reg_offsets[id].blnd)\n\n#define HW_REG_CRTC(reg, id)\\\n\t(reg + reg_offsets[id].crtc)\n\n#define MAX_WATERMARK 0xFFFF\n#define SAFE_NBP_MARK 0x7FFF\n\n \n \nstatic void dce110_init_pte(struct dc_context *ctx)\n{\n\tuint32_t addr;\n\tuint32_t value = 0;\n\tuint32_t chunk_int = 0;\n\tuint32_t chunk_mul = 0;\n\n\taddr = mmUNP_DVMM_PTE_CONTROL;\n\tvalue = dm_read_reg(ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tDVMM_PTE_CONTROL,\n\t\tDVMM_USE_SINGLE_PTE);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tDVMM_PTE_CONTROL,\n\t\tDVMM_PTE_BUFFER_MODE0);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tDVMM_PTE_CONTROL,\n\t\tDVMM_PTE_BUFFER_MODE1);\n\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmDVMM_PTE_REQ;\n\tvalue = dm_read_reg(ctx, addr);\n\n\tchunk_int = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\tchunk_mul = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\tif (chunk_int != 0x4 || chunk_mul != 0x4) {\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t255,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tMAX_PTEREQ_TO_ISSUE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n}\n \n\nstatic void enable_display_pipe_clock_gating(\n\tstruct dc_context *ctx,\n\tbool clock_gating)\n{\n\t \n}\n\nstatic bool dce110_enable_display_power_gating(\n\tstruct dc *dc,\n\tuint8_t controller_id,\n\tstruct dc_bios *dcb,\n\tenum pipe_gating_control power_gating)\n{\n\tenum bp_result bp_result = BP_RESULT_OK;\n\tenum bp_pipe_control_action cntl;\n\tstruct dc_context *ctx = dc->ctx;\n\tunsigned int underlay_idx = dc->res_pool->underlay_pipe_index;\n\n\tif (power_gating == PIPE_GATING_CONTROL_INIT)\n\t\tcntl = ASIC_PIPE_INIT;\n\telse if (power_gating == PIPE_GATING_CONTROL_ENABLE)\n\t\tcntl = ASIC_PIPE_ENABLE;\n\telse\n\t\tcntl = ASIC_PIPE_DISABLE;\n\n\tif (controller_id == underlay_idx)\n\t\tcontroller_id = CONTROLLER_ID_UNDERLAY0 - 1;\n\n\tif (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0) {\n\n\t\tbp_result = dcb->funcs->enable_disp_power_gating(\n\t\t\t\t\t\tdcb, controller_id + 1, cntl);\n\n\t\t \n\t\tif (controller_id < CONTROLLER_ID_MAX - 1)\n\t\t\tdm_write_reg(ctx,\n\t\t\t\tHW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),\n\t\t\t\t0);\n\t}\n\n\tif (power_gating != PIPE_GATING_CONTROL_ENABLE)\n\t\tdce110_init_pte(ctx);\n\n\tif (bp_result == BP_RESULT_OK)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void build_prescale_params(struct ipp_prescale_params *prescale_params,\n\t\tconst struct dc_plane_state *plane_state)\n{\n\tprescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;\n\n\tswitch (plane_state->format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\tprescale_params->scale = 0x2082;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\tprescale_params->scale = 0x2020;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\t\tprescale_params->scale = 0x2008;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\tprescale_params->scale = 0x2000;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(false);\n\t\tbreak;\n\t}\n}\n\nstatic bool\ndce110_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\t       const struct dc_plane_state *plane_state)\n{\n\tstruct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;\n\tconst struct dc_transfer_func *tf = NULL;\n\tstruct ipp_prescale_params prescale_params = { 0 };\n\tbool result = true;\n\n\tif (ipp == NULL)\n\t\treturn false;\n\n\tif (plane_state->in_transfer_func)\n\t\ttf = plane_state->in_transfer_func;\n\n\tbuild_prescale_params(&prescale_params, plane_state);\n\tipp->funcs->ipp_program_prescale(ipp, &prescale_params);\n\n\tif (plane_state->gamma_correction &&\n\t\t\t!plane_state->gamma_correction->is_identity &&\n\t\t\tdce_use_lut(plane_state->format))\n\t\tipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);\n\n\tif (tf == NULL) {\n\t\t \n\t\tipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);\n\t} else if (tf->type == TF_TYPE_PREDEFINED) {\n\t\tswitch (tf->tf) {\n\t\tcase TRANSFER_FUNCTION_SRGB:\n\t\t\tipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_BT709:\n\t\t\tipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_xvYCC);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_LINEAR:\n\t\t\tipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_PQ:\n\t\tdefault:\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t} else if (tf->type == TF_TYPE_BYPASS) {\n\t\tipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);\n\t} else {\n\t\t \n\t\tresult = false;\n\t}\n\n\treturn result;\n}\n\nstatic bool convert_to_custom_float(struct pwl_result_data *rgb_resulted,\n\t\t\t\t    struct curve_points *arr_points,\n\t\t\t\t    uint32_t hw_points_num)\n{\n\tstruct custom_float_format fmt;\n\n\tstruct pwl_result_data *rgb = rgb_resulted;\n\n\tuint32_t i = 0;\n\n\tfmt.exponenta_bits = 6;\n\tfmt.mantissa_bits = 12;\n\tfmt.sign = true;\n\n\tif (!convert_to_custom_float_format(arr_points[0].x, &fmt,\n\t\t\t\t\t    &arr_points[0].custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(arr_points[0].offset, &fmt,\n\t\t\t\t\t    &arr_points[0].custom_float_offset)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(arr_points[0].slope, &fmt,\n\t\t\t\t\t    &arr_points[0].custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tfmt.mantissa_bits = 10;\n\tfmt.sign = false;\n\n\tif (!convert_to_custom_float_format(arr_points[1].x, &fmt,\n\t\t\t\t\t    &arr_points[1].custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(arr_points[1].y, &fmt,\n\t\t\t\t\t    &arr_points[1].custom_float_y)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(arr_points[1].slope, &fmt,\n\t\t\t\t\t    &arr_points[1].custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tfmt.mantissa_bits = 12;\n\tfmt.sign = true;\n\n\twhile (i != hw_points_num) {\n\t\tif (!convert_to_custom_float_format(rgb->red, &fmt,\n\t\t\t\t\t\t    &rgb->red_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->green, &fmt,\n\t\t\t\t\t\t    &rgb->green_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->blue, &fmt,\n\t\t\t\t\t\t    &rgb->blue_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_red, &fmt,\n\t\t\t\t\t\t    &rgb->delta_red_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_green, &fmt,\n\t\t\t\t\t\t    &rgb->delta_green_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_blue, &fmt,\n\t\t\t\t\t\t    &rgb->delta_blue_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\t++rgb;\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\n#define MAX_LOW_POINT      25\n#define NUMBER_REGIONS     16\n#define NUMBER_SW_SEGMENTS 16\n\nstatic bool\ndce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,\n\t\t\t\t      struct pwl_params *regamma_params)\n{\n\tstruct curve_points *arr_points;\n\tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct pwl_result_data *rgb_plus_1;\n\tstruct fixed31_32 y_r;\n\tstruct fixed31_32 y_g;\n\tstruct fixed31_32 y_b;\n\tstruct fixed31_32 y1_min;\n\tstruct fixed31_32 y3_max;\n\n\tint32_t region_start, region_end;\n\tuint32_t i, j, k, seg_distr[NUMBER_REGIONS], increment, start_index, hw_points;\n\n\tif (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tarr_points = regamma_params->arr_points;\n\trgb_resulted = regamma_params->rgb_resulted;\n\thw_points = 0;\n\n\tmemset(regamma_params, 0, sizeof(struct pwl_params));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ) {\n\t\t \n\t\tregion_start = -11;\n\t\tregion_end = region_start + NUMBER_REGIONS;\n\n\t\tfor (i = 0; i < NUMBER_REGIONS; i++)\n\t\t\tseg_distr[i] = 4;\n\n\t} else {\n\t\t \n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\n\t\tseg_distr[0] = 4;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3] = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\tseg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10] = 0;\n\t\tseg_distr[11] = -1;\n\t\tseg_distr[12] = -1;\n\t\tseg_distr[13] = -1;\n\t\tseg_distr[14] = -1;\n\t\tseg_distr[15] = -1;\n\t}\n\n\tfor (k = 0; k < 16; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start); k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment) {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\n\t \n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];\n\n\tarr_points[0].x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tarr_points[1].x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\n\ty_r = rgb_resulted[0].red;\n\ty_g = rgb_resulted[0].green;\n\ty_b = rgb_resulted[0].blue;\n\n\ty1_min = dc_fixpt_min(y_r, dc_fixpt_min(y_g, y_b));\n\n\tarr_points[0].y = y1_min;\n\tarr_points[0].slope = dc_fixpt_div(arr_points[0].y,\n\t\t\t\t\t\t arr_points[0].x);\n\n\ty_r = rgb_resulted[hw_points - 1].red;\n\ty_g = rgb_resulted[hw_points - 1].green;\n\ty_b = rgb_resulted[hw_points - 1].blue;\n\n\t \n\ty3_max = dc_fixpt_max(y_r, dc_fixpt_max(y_g, y_b));\n\n\tarr_points[1].y = y3_max;\n\n\tarr_points[1].slope = dc_fixpt_zero;\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ) {\n\t\t \n\t\tconst struct fixed31_32 end_value = dc_fixpt_from_int(125);\n\n\t\tarr_points[1].slope = dc_fixpt_div(\n\t\t\t\tdc_fixpt_sub(dc_fixpt_one, arr_points[1].y),\n\t\t\t\tdc_fixpt_sub(end_value, arr_points[1].x));\n\t}\n\n\tregamma_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < 16; i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tregamma_params->arr_curve_points[k].segments_num = seg_distr[k];\n\t\t\tregamma_params->arr_curve_points[i].offset =\n\t\t\t\t\tregamma_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tregamma_params->arr_curve_points[k].segments_num = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\n\ti = 1;\n\n\twhile (i != hw_points + 1) {\n\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\trgb_plus_1->red = rgb->red;\n\t\tif (dc_fixpt_lt(rgb_plus_1->green, rgb->green))\n\t\t\trgb_plus_1->green = rgb->green;\n\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\trgb_plus_1->blue = rgb->blue;\n\n\t\trgb->delta_red = dc_fixpt_sub(rgb_plus_1->red, rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green, rgb->green);\n\t\trgb->delta_blue = dc_fixpt_sub(rgb_plus_1->blue, rgb->blue);\n\n\t\t++rgb_plus_1;\n\t\t++rgb;\n\t\t++i;\n\t}\n\n\tconvert_to_custom_float(rgb_resulted, arr_points, hw_points);\n\n\treturn true;\n}\n\nstatic bool\ndce110_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_stream_state *stream)\n{\n\tstruct transform *xfm = pipe_ctx->plane_res.xfm;\n\n\txfm->funcs->opp_power_on_regamma_lut(xfm, true);\n\txfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;\n\n\tif (stream->out_transfer_func &&\n\t    stream->out_transfer_func->type == TF_TYPE_PREDEFINED &&\n\t    stream->out_transfer_func->tf == TRANSFER_FUNCTION_SRGB) {\n\t\txfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);\n\t} else if (dce110_translate_regamma_to_hw_format(stream->out_transfer_func,\n\t\t\t\t\t\t\t &xfm->regamma_params)) {\n\t\txfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);\n\t\txfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);\n\t} else {\n\t\txfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_BYPASS);\n\t}\n\n\txfm->funcs->opp_power_on_regamma_lut(xfm, false);\n\n\treturn true;\n}\n\nvoid dce110_update_info_frame(struct pipe_ctx *pipe_ctx)\n{\n\tbool is_hdmi_tmds;\n\tbool is_dp;\n\n\tASSERT(pipe_ctx->stream);\n\n\tif (pipe_ctx->stream_res.stream_enc == NULL)\n\t\treturn;   \n\n\tis_hdmi_tmds = dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal);\n\tis_dp = dc_is_dp_signal(pipe_ctx->stream->signal);\n\n\tif (!is_hdmi_tmds && !is_dp)\n\t\treturn;\n\n\tif (is_hdmi_tmds)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\telse {\n\t\tif (pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num)\n\t\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num(\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\t}\n}\n\nvoid dce110_enable_stream(struct pipe_ctx *pipe_ctx)\n{\n\tenum dc_lane_count lane_count =\n\t\tpipe_ctx->stream->link->cur_link_settings.lane_count;\n\tstruct dc_crtc_timing *timing = &pipe_ctx->stream->timing;\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\tconst struct dc *dc = link->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tuint32_t active_total_with_borders;\n\tuint32_t early_control = 0;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\n\tlink_hwss->setup_stream_encoder(pipe_ctx);\n\n\tdc->hwss.update_info_frame(pipe_ctx);\n\n\t \n\tactive_total_with_borders =\n\t\t\ttiming->h_addressable\n\t\t\t\t+ timing->h_border_left\n\t\t\t\t+ timing->h_border_right;\n\n\tif (lane_count != 0)\n\t\tearly_control = active_total_with_borders % lane_count;\n\n\tif (early_control == 0)\n\t\tearly_control = lane_count;\n\n\ttg->funcs->set_early_control(tg, early_control);\n}\n\nstatic enum bp_result link_transmitter_control(\n\t\tstruct dc_bios *bios,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result;\n\n\tresult = bios->funcs->transmitter_control(bios, cntl);\n\n\treturn result;\n}\n\n \nvoid dce110_edp_wait_for_hpd_ready(\n\t\tstruct dc_link *link,\n\t\tbool power_up)\n{\n\tstruct dc_context *ctx = link->ctx;\n\tstruct graphics_object_id connector = link->link_enc->connector;\n\tstruct gpio *hpd;\n\tbool edp_hpd_high = false;\n\tuint32_t time_elapsed = 0;\n\tuint32_t timeout = power_up ?\n\t\tPANEL_POWER_UP_TIMEOUT : PANEL_POWER_DOWN_TIMEOUT;\n\n\tif (dal_graphics_object_id_get_connector_id(connector)\n\t\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (!power_up)\n\t\t \n\t\treturn;\n\n\t \n\n\t \n\t \n\thpd = ctx->dc->link_srv->get_hpd_gpio(ctx->dc_bios, connector, ctx->gpio_service);\n\n\tif (!hpd) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (link != NULL) {\n\t\tif (link->panel_config.pps.extra_t3_ms > 0) {\n\t\t\tint extra_t3_in_ms = link->panel_config.pps.extra_t3_ms;\n\n\t\t\tmsleep(extra_t3_in_ms);\n\t\t}\n\t}\n\n\tdal_gpio_open(hpd, GPIO_MODE_INTERRUPT);\n\n\t \n\n\tdo {\n\t\tuint32_t detected = 0;\n\n\t\tdal_gpio_get_value(hpd, &detected);\n\n\t\tif (!(detected ^ power_up)) {\n\t\t\tedp_hpd_high = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(HPD_CHECK_INTERVAL);\n\n\t\ttime_elapsed += HPD_CHECK_INTERVAL;\n\t} while (time_elapsed < timeout);\n\n\tdal_gpio_close(hpd);\n\n\tdal_gpio_destroy_irq(&hpd);\n\n\t \n\tif (!edp_hpd_high)\n\t\tDC_LOG_DC(\"%s: wait timed out!\\n\", __func__);\n}\n\nvoid dce110_edp_power_control(\n\t\tstruct dc_link *link,\n\t\tbool power_up)\n{\n\tstruct dc_context *ctx = link->ctx;\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result bp_result;\n\tuint8_t pwrseq_instance;\n\n\n\tif (dal_graphics_object_id_get_connector_id(link->link_enc->connector)\n\t\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (!link->panel_cntl)\n\t\treturn;\n\tif (power_up !=\n\t\tlink->panel_cntl->funcs->is_panel_powered_on(link->panel_cntl)) {\n\n\t\tunsigned long long current_ts = dm_get_timestamp(ctx);\n\t\tunsigned long long time_since_edp_poweroff_ms =\n\t\t\t\tdiv64_u64(dm_get_elapse_time_in_ns(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\tcurrent_ts,\n\t\t\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link)), 1000000);\n\t\tunsigned long long time_since_edp_poweron_ms =\n\t\t\t\tdiv64_u64(dm_get_elapse_time_in_ns(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\tcurrent_ts,\n\t\t\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweron_timestamp(link)), 1000000);\n\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: transition: power_up=%d current_ts=%llu edp_poweroff=%llu edp_poweron=%llu time_since_edp_poweroff_ms=%llu time_since_edp_poweron_ms=%llu\",\n\t\t\t\t__func__,\n\t\t\t\tpower_up,\n\t\t\t\tcurrent_ts,\n\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link),\n\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweron_timestamp(link),\n\t\t\t\ttime_since_edp_poweroff_ms,\n\t\t\t\ttime_since_edp_poweron_ms);\n\n\t\t \n\t\tif (power_up) {\n\t\t\t \n\t\t\tunsigned long long remaining_min_edp_poweroff_time_ms = 500;\n\n\t\t\t \n\t\t\tif (link->local_sink != NULL)\n\t\t\t\tremaining_min_edp_poweroff_time_ms +=\n\t\t\t\t\tlink->panel_config.pps.extra_t12_ms;\n\n\t\t\t \n\t\t\tif (ctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link) != 0) {\n\t\t\t\tif (time_since_edp_poweroff_ms < remaining_min_edp_poweroff_time_ms)\n\t\t\t\t\tremaining_min_edp_poweroff_time_ms =\n\t\t\t\t\t\tremaining_min_edp_poweroff_time_ms - time_since_edp_poweroff_ms;\n\t\t\t\telse\n\t\t\t\t\tremaining_min_edp_poweroff_time_ms = 0;\n\t\t\t}\n\n\t\t\tif (remaining_min_edp_poweroff_time_ms) {\n\t\t\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\t\t\"%s: remaining_min_edp_poweroff_time_ms=%llu: begin wait.\\n\",\n\t\t\t\t\t\t__func__, remaining_min_edp_poweroff_time_ms);\n\t\t\t\tmsleep(remaining_min_edp_poweroff_time_ms);\n\t\t\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\t\t\"%s: remaining_min_edp_poweroff_time_ms=%llu: end wait.\\n\",\n\t\t\t\t\t\t__func__, remaining_min_edp_poweroff_time_ms);\n\t\t\t\tdm_output_to_console(\"%s: wait %lld ms to power on eDP.\\n\",\n\t\t\t\t\t\t__func__, remaining_min_edp_poweroff_time_ms);\n\t\t\t} else {\n\t\t\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\t\t\"%s: remaining_min_edp_poweroff_time_ms=%llu: no wait required.\\n\",\n\t\t\t\t\t\t__func__, remaining_min_edp_poweroff_time_ms);\n\t\t\t}\n\t\t}\n\n\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: BEGIN: Panel Power action: %s\\n\",\n\t\t\t\t__func__, (power_up ? \"On\":\"Off\"));\n\n\t\tcntl.action = power_up ?\n\t\t\tTRANSMITTER_CONTROL_POWER_ON :\n\t\t\tTRANSMITTER_CONTROL_POWER_OFF;\n\t\tcntl.transmitter = link->link_enc->transmitter;\n\t\tcntl.connector_obj_id = link->link_enc->connector;\n\t\tcntl.coherent = false;\n\t\tcntl.lanes_number = LANE_COUNT_FOUR;\n\t\tcntl.hpd_sel = link->link_enc->hpd_source;\n\t\tpwrseq_instance = link->panel_cntl->pwrseq_inst;\n\n\t\tif (ctx->dc->ctx->dmub_srv &&\n\t\t\t\tctx->dc->debug.dmub_command_table) {\n\n\t\t\tif (cntl.action == TRANSMITTER_CONTROL_POWER_ON) {\n\t\t\t\tbp_result = ctx->dc_bios->funcs->enable_lvtma_control(ctx->dc_bios,\n\t\t\t\t\t\tLVTMA_CONTROL_POWER_ON,\n\t\t\t\t\t\tpwrseq_instance, link->link_powered_externally);\n\t\t\t} else {\n\t\t\t\tbp_result = ctx->dc_bios->funcs->enable_lvtma_control(ctx->dc_bios,\n\t\t\t\t\t\tLVTMA_CONTROL_POWER_OFF,\n\t\t\t\t\t\tpwrseq_instance, link->link_powered_externally);\n\t\t\t}\n\t\t}\n\n\t\tbp_result = link_transmitter_control(ctx->dc_bios, &cntl);\n\n\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: END: Panel Power action: %s bp_result=%u\\n\",\n\t\t\t\t__func__, (power_up ? \"On\":\"Off\"),\n\t\t\t\tbp_result);\n\n\t\tctx->dc->link_srv->dp_trace_set_edp_power_timestamp(link, power_up);\n\n\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: updated values: edp_poweroff=%llu edp_poweron=%llu\\n\",\n\t\t\t\t__func__,\n\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link),\n\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweron_timestamp(link));\n\n\t\tif (bp_result != BP_RESULT_OK)\n\t\t\tDC_LOG_ERROR(\n\t\t\t\t\t\"%s: Panel Power bp_result: %d\\n\",\n\t\t\t\t\t__func__, bp_result);\n\t} else {\n\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: Skipping Panel Power action: %s\\n\",\n\t\t\t\t__func__, (power_up ? \"On\":\"Off\"));\n\t}\n}\n\nvoid dce110_edp_wait_for_T12(\n\t\tstruct dc_link *link)\n{\n\tstruct dc_context *ctx = link->ctx;\n\n\tif (dal_graphics_object_id_get_connector_id(link->link_enc->connector)\n\t\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (!link->panel_cntl)\n\t\treturn;\n\n\tif (!link->panel_cntl->funcs->is_panel_powered_on(link->panel_cntl) &&\n\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link) != 0) {\n\t\tunsigned int t12_duration = 500;  \n\t\tunsigned long long current_ts = dm_get_timestamp(ctx);\n\t\tunsigned long long time_since_edp_poweroff_ms =\n\t\t\t\tdiv64_u64(dm_get_elapse_time_in_ns(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\tcurrent_ts,\n\t\t\t\t\t\tctx->dc->link_srv->dp_trace_get_edp_poweroff_timestamp(link)), 1000000);\n\n\t\tt12_duration += link->panel_config.pps.extra_t12_ms;  \n\n\t\tif (time_since_edp_poweroff_ms < t12_duration)\n\t\t\tmsleep(t12_duration - time_since_edp_poweroff_ms);\n\t}\n}\n \n \nvoid dce110_edp_backlight_control(\n\t\tstruct dc_link *link,\n\t\tbool enable)\n{\n\tstruct dc_context *ctx = link->ctx;\n\tstruct bp_transmitter_control cntl = { 0 };\n\tuint8_t pwrseq_instance;\n\tunsigned int pre_T11_delay = OLED_PRE_T11_DELAY;\n\tunsigned int post_T7_delay = OLED_POST_T7_DELAY;\n\n\tif (dal_graphics_object_id_get_connector_id(link->link_enc->connector)\n\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (link->panel_cntl && !(link->dpcd_sink_ext_caps.bits.oled ||\n\t\tlink->dpcd_sink_ext_caps.bits.hdr_aux_backlight_control == 1 ||\n\t\tlink->dpcd_sink_ext_caps.bits.sdr_aux_backlight_control == 1)) {\n\t\tbool is_backlight_on = link->panel_cntl->funcs->is_panel_backlight_on(link->panel_cntl);\n\n\t\tif ((enable && is_backlight_on) || (!enable && !is_backlight_on)) {\n\t\t\tDC_LOG_HW_RESUME_S3(\n\t\t\t\t\"%s: panel already powered up/off. Do nothing.\\n\",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\tDC_LOG_HW_RESUME_S3(\n\t\t\t\"%s: backlight action: %s\\n\",\n\t\t\t__func__, (enable ? \"On\":\"Off\"));\n\n\tcntl.action = enable ?\n\t\tTRANSMITTER_CONTROL_BACKLIGHT_ON :\n\t\tTRANSMITTER_CONTROL_BACKLIGHT_OFF;\n\n\t \n\tcntl.transmitter = link->link_enc->transmitter;\n\tcntl.connector_obj_id = link->link_enc->connector;\n\t \n\tcntl.lanes_number = LANE_COUNT_FOUR;\n\tcntl.hpd_sel = link->link_enc->hpd_source;\n\tcntl.signal = SIGNAL_TYPE_EDP;\n\n\t \n\t \n\t\t \n\tpwrseq_instance = link->panel_cntl->pwrseq_inst;\n\n\tif (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_ON) {\n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t \n\t\t\tctx->dc->link_srv->edp_receiver_ready_T7(link);\n\t\telse\n\t\t\tDC_LOG_DC(\"edp_receiver_ready_T7 skipped\\n\");\n\t}\n\n\t \n\tif (ctx->dc->ctx->dmub_srv &&\n\t\t\tctx->dc->debug.dmub_command_table) {\n\t\tif (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_ON)\n\t\t\tctx->dc_bios->funcs->enable_lvtma_control(ctx->dc_bios,\n\t\t\t\t\tLVTMA_CONTROL_LCD_BLON,\n\t\t\t\t\tpwrseq_instance, link->link_powered_externally);\n\t\telse\n\t\t\tctx->dc_bios->funcs->enable_lvtma_control(ctx->dc_bios,\n\t\t\t\t\tLVTMA_CONTROL_LCD_BLOFF,\n\t\t\t\t\tpwrseq_instance, link->link_powered_externally);\n\t}\n\n\tlink_transmitter_control(ctx->dc_bios, &cntl);\n\n\tif (enable && link->dpcd_sink_ext_caps.bits.oled) {\n\t\tpost_T7_delay += link->panel_config.pps.extra_post_t7_ms;\n\t\tmsleep(post_T7_delay);\n\t}\n\n\tif (link->dpcd_sink_ext_caps.bits.oled ||\n\t\tlink->dpcd_sink_ext_caps.bits.hdr_aux_backlight_control == 1 ||\n\t\tlink->dpcd_sink_ext_caps.bits.sdr_aux_backlight_control == 1)\n\t\tctx->dc->link_srv->edp_backlight_enable_aux(link, enable);\n\n\t \n\tif (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_OFF) {\n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t \n\t\t\tctx->dc->link_srv->edp_add_delay_for_T9(link);\n\t\telse\n\t\t\tDC_LOG_DC(\"edp_receiver_ready_T9 skipped\\n\");\n\t}\n\n\tif (!enable && link->dpcd_sink_ext_caps.bits.oled) {\n\t\tpre_T11_delay += link->panel_config.pps.extra_pre_t11_ms;\n\t\tmsleep(pre_T11_delay);\n\t}\n}\n\nvoid dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)\n{\n\t \n\tstruct dc *dc;\n\tstruct clk_mgr *clk_mgr;\n\tunsigned int i, num_audio = 1;\n\tconst struct link_hwss *link_hwss;\n\n\tif (!pipe_ctx->stream)\n\t\treturn;\n\n\tdc = pipe_ctx->stream->ctx->dc;\n\tclk_mgr = dc->clk_mgr;\n\tlink_hwss = get_link_hwss(pipe_ctx->stream->link, &pipe_ctx->link_res);\n\n\tif (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)\n\t\treturn;\n\n\tif (pipe_ctx->stream_res.audio) {\n\t\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\t\t \n\t\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream_res.audio != NULL)\n\t\t\t\tnum_audio++;\n\t\t}\n\n\t\tpipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);\n\n\t\tif (num_audio >= 1 && clk_mgr->funcs->enable_pme_wa)\n\t\t\t \n\t\t\tclk_mgr->funcs->enable_pme_wa(clk_mgr);\n\n\t\tlink_hwss->enable_audio_packet(pipe_ctx);\n\n\t\tif (pipe_ctx->stream_res.audio)\n\t\t\tpipe_ctx->stream_res.audio->enabled = true;\n\t}\n}\n\nvoid dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc *dc;\n\tstruct clk_mgr *clk_mgr;\n\tconst struct link_hwss *link_hwss;\n\n\tif (!pipe_ctx || !pipe_ctx->stream)\n\t\treturn;\n\n\tdc = pipe_ctx->stream->ctx->dc;\n\tclk_mgr = dc->clk_mgr;\n\tlink_hwss = get_link_hwss(pipe_ctx->stream->link, &pipe_ctx->link_res);\n\n\tif (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)\n\t\treturn;\n\n\tlink_hwss->disable_audio_packet(pipe_ctx);\n\n\tif (pipe_ctx->stream_res.audio) {\n\t\tpipe_ctx->stream_res.audio->enabled = false;\n\n\t\tif (clk_mgr->funcs->enable_pme_wa)\n\t\t\t \n\t\t\tclk_mgr->funcs->enable_pme_wa(clk_mgr);\n\n\t\t \n\t\t \n\t}\n}\n\nvoid dce110_disable_stream(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tstruct dccg *dccg = dc->res_pool->dccg;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tstruct dtbclk_dto_params dto_params = {0};\n\tint dp_hpo_inst;\n\tstruct link_encoder *link_enc = link_enc_cfg_get_link_enc(pipe_ctx->stream->link);\n\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\n\tif (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal)) {\n\t\tpipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\t\tpipe_ctx->stream_res.stream_enc->funcs->hdmi_reset_stream_attribute(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\t}\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->stop_dp_info_packets(\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc);\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\n\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\tlink_hwss->reset_stream_encoder(pipe_ctx);\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tdto_params.otg_inst = tg->inst;\n\t\tdto_params.timing = &pipe_ctx->stream->timing;\n\t\tdp_hpo_inst = pipe_ctx->stream_res.hpo_dp_stream_enc->inst;\n\t\tif (dccg) {\n\t\t\tdccg->funcs->set_dtbclk_dto(dccg, &dto_params);\n\t\t\tdccg->funcs->disable_symclk32_se(dccg, dp_hpo_inst);\n\t\t\tdccg->funcs->set_dpstreamclk(dccg, REFCLK, tg->inst, dp_hpo_inst);\n\t\t}\n\t} else if (dccg && dccg->funcs->disable_symclk_se) {\n\t\tdccg->funcs->disable_symclk_se(dccg, stream_enc->stream_enc_inst,\n\t\t\t\tlink_enc->transmitter - TRANSMITTER_UNIPHY_A);\n\t}\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t \n\t\tif (pipe_ctx->stream->ctx->dc->hwseq->funcs.setup_hpo_hw_control)\n\t\t\tpipe_ctx->stream->ctx->dc->hwseq->funcs.setup_hpo_hw_control(\n\t\t\t\t\tpipe_ctx->stream->ctx->dc->hwseq, false);\n\t}\n}\n\nvoid dce110_unblank_stream(struct pipe_ctx *pipe_ctx,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tstruct encoder_unblank_param params = { { 0 } };\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\n\t \n\tparams.timing = pipe_ctx->stream->timing;\n\tparams.link_settings.link_rate = link_settings->link_rate;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_unblank(link, pipe_ctx->stream_res.stream_enc, &params);\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\thws->funcs.edp_backlight_control(link, true);\n\t}\n}\n\nvoid dce110_blank_stream(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\tif (!link->skip_implict_edp_power_control)\n\t\t\thws->funcs.edp_backlight_control(link, false);\n\t\tlink->dc->hwss.set_abm_immediate_disable(pipe_ctx);\n\t}\n\n\tif (link->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t \n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_blank(\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc);\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_blank(link, pipe_ctx->stream_res.stream_enc);\n\n\t\tif (!dc_is_embedded_signal(pipe_ctx->stream->signal)) {\n\t\t\t \n\t\t\tmsleep(60);\n\t\t} else if (pipe_ctx->stream->signal == SIGNAL_TYPE_EDP) {\n\t\t\tif (!link->dc->config.edp_no_power_sequencing) {\n\t\t\t\t \n\t\t\t\tlink->dc->link_srv->edp_receiver_ready_T9(link);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nvoid dce110_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tif (pipe_ctx != NULL && pipe_ctx->stream_res.stream_enc != NULL)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->set_avmute(pipe_ctx->stream_res.stream_enc, enable);\n}\n\nstatic enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)\n{\n\tswitch (crtc_id) {\n\tcase CONTROLLER_ID_D0:\n\t\treturn DTO_SOURCE_ID0;\n\tcase CONTROLLER_ID_D1:\n\t\treturn DTO_SOURCE_ID1;\n\tcase CONTROLLER_ID_D2:\n\t\treturn DTO_SOURCE_ID2;\n\tcase CONTROLLER_ID_D3:\n\t\treturn DTO_SOURCE_ID3;\n\tcase CONTROLLER_ID_D4:\n\t\treturn DTO_SOURCE_ID4;\n\tcase CONTROLLER_ID_D5:\n\t\treturn DTO_SOURCE_ID5;\n\tdefault:\n\t\treturn DTO_SOURCE_UNKNOWN;\n\t}\n}\n\nstatic void build_audio_output(\n\tstruct dc_state *state,\n\tconst struct pipe_ctx *pipe_ctx,\n\tstruct audio_output *audio_output)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\taudio_output->engine_id = pipe_ctx->stream_res.stream_enc->id;\n\n\taudio_output->signal = pipe_ctx->stream->signal;\n\n\t \n\n\taudio_output->crtc_info.h_total =\n\t\tstream->timing.h_total;\n\n\t \n\taudio_output->crtc_info.h_active =\n\t\t\tstream->timing.h_addressable\n\t\t\t+ stream->timing.h_border_left\n\t\t\t+ stream->timing.h_border_right;\n\n\taudio_output->crtc_info.v_active =\n\t\t\tstream->timing.v_addressable\n\t\t\t+ stream->timing.v_border_top\n\t\t\t+ stream->timing.v_border_bottom;\n\n\taudio_output->crtc_info.pixel_repetition = 1;\n\n\taudio_output->crtc_info.interlaced =\n\t\t\tstream->timing.flags.INTERLACE;\n\n\taudio_output->crtc_info.refresh_rate =\n\t\t(stream->timing.pix_clk_100hz*100)/\n\t\t(stream->timing.h_total*stream->timing.v_total);\n\n\taudio_output->crtc_info.color_depth =\n\t\tstream->timing.display_color_depth;\n\n\taudio_output->crtc_info.requested_pixel_clock_100Hz =\n\t\t\tpipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz;\n\n\taudio_output->crtc_info.calculated_pixel_clock_100Hz =\n\t\t\tpipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz;\n\n \n\tif (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal) &&\n\t\taudio_output->crtc_info.requested_pixel_clock_100Hz ==\n\t\t\t\t(stream->timing.pix_clk_100hz)) {\n\t\tif (pipe_ctx->stream_res.pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {\n\t\t\taudio_output->crtc_info.requested_pixel_clock_100Hz =\n\t\t\t\t\taudio_output->crtc_info.requested_pixel_clock_100Hz/2;\n\t\t\taudio_output->crtc_info.calculated_pixel_clock_100Hz =\n\t\t\t\t\tpipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz/2;\n\n\t\t}\n\t}\n\n\tif (state->clk_mgr &&\n\t\t(pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||\n\t\t\tpipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)) {\n\t\taudio_output->pll_info.dp_dto_source_clock_in_khz =\n\t\t\t\tstate->clk_mgr->funcs->get_dp_ref_clk_frequency(\n\t\t\t\t\t\tstate->clk_mgr);\n\t}\n\n\taudio_output->pll_info.feed_back_divider =\n\t\t\tpipe_ctx->pll_settings.feedback_divider;\n\n\taudio_output->pll_info.dto_source =\n\t\ttranslate_to_dto_source(\n\t\t\tpipe_ctx->stream_res.tg->inst + 1);\n\n\t \n\taudio_output->pll_info.ss_enabled = true;\n\n\taudio_output->pll_info.ss_percentage =\n\t\t\tpipe_ctx->pll_settings.ss_percentage;\n}\n\nstatic void program_scaler(const struct dc *dc,\n\t\tconst struct pipe_ctx *pipe_ctx)\n{\n\tstruct tg_color color = {0};\n\n\t \n\tif (pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth == NULL)\n\t\treturn;\n\n\tif (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE)\n\t\tget_surface_visual_confirm_color(pipe_ctx, &color);\n\telse\n\t\tcolor_space_to_black_color(dc,\n\t\t\t\tpipe_ctx->stream->output_color_space,\n\t\t\t\t&color);\n\n\tpipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth(\n\t\tpipe_ctx->plane_res.xfm,\n\t\tpipe_ctx->plane_res.scl_data.lb_params.depth,\n\t\t&pipe_ctx->stream->bit_depth_params);\n\n\tif (pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color) {\n\t\t \n\t\tif (pipe_ctx->stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\tcolor.color_r_cr = color.color_g_y;\n\n\t\tpipe_ctx->stream_res.tg->funcs->set_overscan_blank_color(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&color);\n\t}\n\n\tpipe_ctx->plane_res.xfm->funcs->transform_set_scaler(pipe_ctx->plane_res.xfm,\n\t\t&pipe_ctx->plane_res.scl_data);\n}\n\nstatic enum dc_status dce110_enable_stream_timing(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context,\n\t\tstruct dc *dc)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.\n\t\t\tpipe_ctx[pipe_ctx->pipe_idx];\n\tstruct tg_color black_color = {0};\n\n\tif (!pipe_ctx_old->stream) {\n\n\t\t \n\t\tcolor_space_to_black_color(dc,\n\t\t\t\tstream->output_color_space, &black_color);\n\t\tpipe_ctx->stream_res.tg->funcs->set_blank_color(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&black_color);\n\n\t\t \n\t\tpipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);\n\n\t\tif (false == pipe_ctx->clock_source->funcs->program_pix_clk(\n\t\t\t\tpipe_ctx->clock_source,\n\t\t\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t\t\tdc->link_srv->dp_get_encoding_format(&pipe_ctx->link_config.dp_link_settings),\n\t\t\t\t&pipe_ctx->pll_settings)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn DC_ERROR_UNEXPECTED;\n\t\t}\n\n\t\tif (dc_is_hdmi_tmds_signal(stream->signal)) {\n\t\t\tstream->link->phy_state.symclk_ref_cnts.otg = 1;\n\t\t\tif (stream->link->phy_state.symclk_state == SYMCLK_OFF_TX_OFF)\n\t\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_OFF;\n\t\t\telse\n\t\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n\t\t}\n\n\t\tpipe_ctx->stream_res.tg->funcs->program_timing(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&stream->timing,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\ttrue);\n\t}\n\n\tif (!pipe_ctx_old->stream) {\n\t\tif (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(\n\t\t\t\tpipe_ctx->stream_res.tg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn DC_ERROR_UNEXPECTED;\n\t\t}\n\t}\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status apply_single_controller_ctx_to_hw(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context,\n\t\tstruct dc *dc)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct drr_params params = {0};\n\tunsigned int event_triggers = 0;\n\tstruct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tconst struct link_hwss *link_hwss = get_link_hwss(\n\t\t\tlink, &pipe_ctx->link_res);\n\n\n\tif (hws->funcs.disable_stream_gating) {\n\t\thws->funcs.disable_stream_gating(dc, pipe_ctx);\n\t}\n\n\tif (pipe_ctx->stream_res.audio != NULL) {\n\t\tstruct audio_output audio_output;\n\n\t\tbuild_audio_output(context, pipe_ctx, &audio_output);\n\n\t\tlink_hwss->setup_audio_output(pipe_ctx, &audio_output,\n\t\t\t\tpipe_ctx->stream_res.audio->inst);\n\n\t\tpipe_ctx->stream_res.audio->funcs->az_configure(\n\t\t\t\tpipe_ctx->stream_res.audio,\n\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\t&audio_output.crtc_info,\n\t\t\t\t&pipe_ctx->stream->audio_info);\n\t}\n\n\t \n\tif (!pipe_ctx->stream->apply_seamless_boot_optimization && dc->config.use_pipe_ctx_sync_logic)\n\t\tcheck_syncd_pipes_for_disabled_master_pipe(dc, context, pipe_ctx->pipe_idx);\n\n\tpipe_ctx->stream_res.opp->funcs->opp_program_fmt(\n\t\tpipe_ctx->stream_res.opp,\n\t\t&stream->bit_depth_params,\n\t\t&stream->clamping);\n\n\tpipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\tCOLOR_SPACE_YCBCR601,\n\t\t\tstream->timing.display_color_depth,\n\t\t\tstream->signal);\n\n\twhile (odm_pipe) {\n\t\todm_pipe->stream_res.opp->funcs->opp_set_dyn_expansion(\n\t\t\t\todm_pipe->stream_res.opp,\n\t\t\t\tCOLOR_SPACE_YCBCR601,\n\t\t\t\tstream->timing.display_color_depth,\n\t\t\t\tstream->signal);\n\n\t\todm_pipe->stream_res.opp->funcs->opp_program_fmt(\n\t\t\t\todm_pipe->stream_res.opp,\n\t\t\t\t&stream->bit_depth_params,\n\t\t\t\t&stream->clamping);\n\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t}\n\n\t \n\tif (!(hws->wa.dp_hpo_and_otg_sequence && dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)))\n\t\t \n\t\t \n\t\tif (!pipe_ctx->stream->apply_seamless_boot_optimization)\n\t\t\thws->funcs.enable_stream_timing(pipe_ctx, context, dc);\n\n\tif (hws->funcs.setup_vupdate_interrupt)\n\t\thws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);\n\n\tparams.vertical_total_min = stream->adjust.v_total_min;\n\tparams.vertical_total_max = stream->adjust.v_total_max;\n\tif (pipe_ctx->stream_res.tg->funcs->set_drr)\n\t\tpipe_ctx->stream_res.tg->funcs->set_drr(\n\t\t\tpipe_ctx->stream_res.tg, &params);\n\n\t \n\tif (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)\n\t\tevent_triggers = 0x80;\n\t \n\tif (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)\n\t\tpipe_ctx->stream_res.tg->funcs->set_static_screen_control(\n\t\t\t\tpipe_ctx->stream_res.tg, event_triggers, 2);\n\n\tif (!dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\tpipe_ctx->stream_res.tg->inst);\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_CONNECT_DIG_FE_OTG);\n\n\tif (!stream->dpms_off)\n\t\tdc->link_srv->set_dpms_on(context, pipe_ctx);\n\n\t \n\tif (hws->wa.dp_hpo_and_otg_sequence && dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tif (!pipe_ctx->stream->apply_seamless_boot_optimization)\n\t\t\thws->funcs.enable_stream_timing(pipe_ctx, context, dc);\n\t}\n\n\tpipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != NULL;\n\n\t \n\tif (pipe_ctx->stream->mall_stream_config.type != SUBVP_PHANTOM) {\n\t\tpipe_ctx->stream->link->psr_settings.psr_feature_enabled = false;\n\t\tpipe_ctx->stream->link->replay_settings.replay_feature_enabled = false;\n\t}\n\treturn DC_OK;\n}\n\n \n\nstatic void power_down_encoders(struct dc *dc)\n{\n\tint i;\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tenum signal_type signal = dc->links[i]->connector_signal;\n\n\t\tdc->link_srv->blank_dp_stream(dc->links[i], false);\n\n\t\tif (signal != SIGNAL_TYPE_EDP)\n\t\t\tsignal = SIGNAL_TYPE_NONE;\n\n\t\tif (dc->links[i]->ep_type == DISPLAY_ENDPOINT_PHY)\n\t\t\tdc->links[i]->link_enc->funcs->disable_output(\n\t\t\t\t\tdc->links[i]->link_enc, signal);\n\n\t\tdc->links[i]->link_status.link_active = false;\n\t\tmemset(&dc->links[i]->cur_link_settings, 0,\n\t\t\t\tsizeof(dc->links[i]->cur_link_settings));\n\t}\n}\n\nstatic void power_down_controllers(struct dc *dc)\n{\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\tdc->res_pool->timing_generators[i]->funcs->disable_crtc(\n\t\t\t\tdc->res_pool->timing_generators[i]);\n\t}\n}\n\nstatic void power_down_clock_sources(struct dc *dc)\n{\n\tint i;\n\n\tif (dc->res_pool->dp_clock_source->funcs->cs_power_down(\n\t\tdc->res_pool->dp_clock_source) == false)\n\t\tdm_error(\"Failed to power down pll! (dp clk src)\\n\");\n\n\tfor (i = 0; i < dc->res_pool->clk_src_count; i++) {\n\t\tif (dc->res_pool->clock_sources[i]->funcs->cs_power_down(\n\t\t\t\tdc->res_pool->clock_sources[i]) == false)\n\t\t\tdm_error(\"Failed to power down pll! (clk src index=%d)\\n\", i);\n\t}\n}\n\nstatic void power_down_all_hw_blocks(struct dc *dc)\n{\n\tpower_down_encoders(dc);\n\n\tpower_down_controllers(dc);\n\n\tpower_down_clock_sources(dc);\n\n\tif (dc->fbc_compressor)\n\t\tdc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);\n}\n\nstatic void disable_vga_and_power_gate_all_controllers(\n\t\tstruct dc *dc)\n{\n\tint i;\n\tstruct timing_generator *tg;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\ttg = dc->res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->disable_vga)\n\t\t\ttg->funcs->disable_vga(tg);\n\t}\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t \n\t\tenable_display_pipe_clock_gating(ctx,\n\t\t\t\ttrue);\n\n\t\tdc->current_state->res_ctx.pipe_ctx[i].pipe_idx = i;\n\t\tdc->hwss.disable_plane(dc,\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i]);\n\t}\n}\n\n\nstatic void get_edp_streams(struct dc_state *context,\n\t\tstruct dc_stream_state **edp_streams,\n\t\tint *edp_stream_num)\n{\n\tint i;\n\n\t*edp_stream_num = 0;\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i]->signal == SIGNAL_TYPE_EDP) {\n\t\t\tedp_streams[*edp_stream_num] = context->streams[i];\n\t\t\tif (++(*edp_stream_num) == MAX_NUM_EDP)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void get_edp_links_with_sink(\n\t\tstruct dc *dc,\n\t\tstruct dc_link **edp_links_with_sink,\n\t\tint *edp_with_sink_num)\n{\n\tint i;\n\n\t \n\t*edp_with_sink_num = 0;\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tif (dc->links[i]->local_sink &&\n\t\t\tdc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\t\tedp_links_with_sink[*edp_with_sink_num] = dc->links[i];\n\t\t\tif (++(*edp_with_sink_num) == MAX_NUM_EDP)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nvoid dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)\n{\n\tstruct dc_link *edp_links_with_sink[MAX_NUM_EDP];\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\tstruct dc_stream_state *edp_streams[MAX_NUM_EDP];\n\tstruct dc_link *edp_link_with_sink = NULL;\n\tstruct dc_link *edp_link = NULL;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tint edp_with_sink_num;\n\tint edp_num;\n\tint edp_stream_num;\n\tint i;\n\tbool can_apply_edp_fast_boot = false;\n\tbool can_apply_seamless_boot = false;\n\tbool keep_edp_vdd_on = false;\n\tDC_LOGGER_INIT();\n\n\n\tget_edp_links_with_sink(dc, edp_links_with_sink, &edp_with_sink_num);\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\n\tif (hws->funcs.init_pipes)\n\t\thws->funcs.init_pipes(dc, context);\n\n\tget_edp_streams(context, edp_streams, &edp_stream_num);\n\n\t \n\tif (edp_num && edp_stream_num && dc->ctx->dce_version != DCE_VERSION_8_0 &&\n\t\t    dc->ctx->dce_version != DCE_VERSION_8_1 &&\n\t\t    dc->ctx->dce_version != DCE_VERSION_8_3) {\n\t\tfor (i = 0; i < edp_num; i++) {\n\t\t\tedp_link = edp_links[i];\n\t\t\tif (edp_link != edp_streams[0]->link)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (edp_link->link_enc->funcs->is_dig_enabled &&\n\t\t\t    edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc) &&\n\t\t\t    edp_link->link_status.link_active) {\n\t\t\t\tstruct dc_stream_state *edp_stream = edp_streams[0];\n\n\t\t\t\tcan_apply_edp_fast_boot = dc_validate_boot_timing(dc,\n\t\t\t\t\tedp_stream->sink, &edp_stream->timing);\n\t\t\t\tedp_stream->apply_edp_fast_boot_optimization = can_apply_edp_fast_boot;\n\t\t\t\tif (can_apply_edp_fast_boot)\n\t\t\t\t\tDC_LOG_EVENT_LINK_TRAINING(\"eDP fast boot disabled to optimize link rate\\n\");\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (can_apply_edp_fast_boot)\n\t\t\tkeep_edp_vdd_on = true;\n\t}\n\n\t\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i]->apply_seamless_boot_optimization) {\n\t\t\tcan_apply_seamless_boot = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (edp_with_sink_num)\n\t\tedp_link_with_sink = edp_links_with_sink[0];\n\n\tif (!can_apply_edp_fast_boot && !can_apply_seamless_boot) {\n\t\tif (edp_link_with_sink && !keep_edp_vdd_on) {\n\t\t\t \n\t\t\thws->funcs.edp_backlight_control(edp_link_with_sink, false);\n\t\t}\n\t\t \n\t\tclk_mgr_exit_optimized_pwr_state(dc, dc->clk_mgr);\n\n\t\tpower_down_all_hw_blocks(dc);\n\t\tdisable_vga_and_power_gate_all_controllers(dc);\n\t\tif (edp_link_with_sink && !keep_edp_vdd_on)\n\t\t\tdc->hwss.edp_power_control(edp_link_with_sink, false);\n\t\tclk_mgr_optimize_pwr_state(dc, dc->clk_mgr);\n\t}\n\tbios_set_scratch_acc_mode_change(dc->ctx->dc_bios, 1);\n}\n\nstatic uint32_t compute_pstate_blackout_duration(\n\tstruct bw_fixed blackout_duration,\n\tconst struct dc_stream_state *stream)\n{\n\tuint32_t total_dest_line_time_ns;\n\tuint32_t pstate_blackout_duration_ns;\n\n\tpstate_blackout_duration_ns = 1000 * blackout_duration.value >> 24;\n\n\ttotal_dest_line_time_ns = 1000000UL *\n\t\t(stream->timing.h_total * 10) /\n\t\tstream->timing.pix_clk_100hz +\n\t\tpstate_blackout_duration_ns;\n\n\treturn total_dest_line_time_ns;\n}\n\nstatic void dce110_set_displaymarks(\n\tconst struct dc *dc,\n\tstruct dc_state *context)\n{\n\tuint8_t i, num_pipes;\n\tunsigned int underlay_idx = dc->res_pool->underlay_pipe_index;\n\n\tfor (i = 0, num_pipes = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tuint32_t total_dest_line_time_ns;\n\n\t\tif (pipe_ctx->stream == NULL)\n\t\t\tcontinue;\n\n\t\ttotal_dest_line_time_ns = compute_pstate_blackout_duration(\n\t\t\tdc->bw_vbios->blackout_duration, pipe_ctx->stream);\n\t\tpipe_ctx->plane_res.mi->funcs->mem_input_program_display_marks(\n\t\t\tpipe_ctx->plane_res.mi,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[num_pipes],\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[num_pipes],\n\t\t\tcontext->bw_ctx.bw.dce.stutter_entry_wm_ns[num_pipes],\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[num_pipes],\n\t\t\ttotal_dest_line_time_ns);\n\t\tif (i == underlay_idx) {\n\t\t\tnum_pipes++;\n\t\t\tpipe_ctx->plane_res.mi->funcs->mem_input_program_chroma_display_marks(\n\t\t\t\tpipe_ctx->plane_res.mi,\n\t\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[num_pipes],\n\t\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[num_pipes],\n\t\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[num_pipes],\n\t\t\t\ttotal_dest_line_time_ns);\n\t\t}\n\t\tnum_pipes++;\n\t}\n}\n\nvoid dce110_set_safe_displaymarks(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint i;\n\tint underlay_idx = pool->underlay_pipe_index;\n\tstruct dce_watermarks max_marks = {\n\t\tMAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };\n\tstruct dce_watermarks nbp_marks = {\n\t\tSAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };\n\tstruct dce_watermarks min_marks = { 0, 0, 0, 0};\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (res_ctx->pipe_ctx[i].stream == NULL || res_ctx->pipe_ctx[i].plane_res.mi == NULL)\n\t\t\tcontinue;\n\n\t\tres_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_display_marks(\n\t\t\t\tres_ctx->pipe_ctx[i].plane_res.mi,\n\t\t\t\tnbp_marks,\n\t\t\t\tmax_marks,\n\t\t\t\tmin_marks,\n\t\t\t\tmax_marks,\n\t\t\t\tMAX_WATERMARK);\n\n\t\tif (i == underlay_idx)\n\t\t\tres_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_chroma_display_marks(\n\t\t\t\tres_ctx->pipe_ctx[i].plane_res.mi,\n\t\t\t\tnbp_marks,\n\t\t\t\tmax_marks,\n\t\t\t\tmax_marks,\n\t\t\t\tMAX_WATERMARK);\n\n\t}\n}\n\n \n\nstatic void set_drr(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, struct dc_crtc_timing_adjust adjust)\n{\n\tint i = 0;\n\tstruct drr_params params = {0};\n\t\n\tunsigned int event_triggers = 0x80;\n\t\n\tunsigned int num_frames = 2;\n\n\tparams.vertical_total_max = adjust.v_total_max;\n\tparams.vertical_total_min = adjust.v_total_min;\n\n\t \n\tfor (i = 0; i < num_pipes; i++) {\n\t\tpipe_ctx[i]->stream_res.tg->funcs->set_drr(\n\t\t\tpipe_ctx[i]->stream_res.tg, &params);\n\n\t\tif (adjust.v_total_max != 0 && adjust.v_total_min != 0)\n\t\t\tpipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(\n\t\t\t\t\tpipe_ctx[i]->stream_res.tg,\n\t\t\t\t\tevent_triggers, num_frames);\n\t}\n}\n\nstatic void get_position(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes,\n\t\tstruct crtc_position *position)\n{\n\tint i = 0;\n\n\t \n\tfor (i = 0; i < num_pipes; i++)\n\t\tpipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);\n}\n\nstatic void set_static_screen_control(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, const struct dc_static_screen_params *params)\n{\n\tunsigned int i;\n\tunsigned int triggers = 0;\n\n\tif (params->triggers.overlay_update)\n\t\ttriggers |= 0x100;\n\tif (params->triggers.surface_update)\n\t\ttriggers |= 0x80;\n\tif (params->triggers.cursor_update)\n\t\ttriggers |= 0x2;\n\tif (params->triggers.force_trigger)\n\t\ttriggers |= 0x1;\n\n\tif (num_pipes) {\n\t\tstruct dc *dc = pipe_ctx[0]->stream->ctx->dc;\n\n\t\tif (dc->fbc_compressor)\n\t\t\ttriggers |= 0x84;\n\t}\n\n\tfor (i = 0; i < num_pipes; i++)\n\t\tpipe_ctx[i]->stream_res.tg->funcs->\n\t\t\tset_static_screen_control(pipe_ctx[i]->stream_res.tg,\n\t\t\t\t\ttriggers, params->num_frames);\n}\n\n \nstatic bool should_enable_fbc(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tuint32_t *pipe_idx)\n{\n\tuint32_t i;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tunsigned int underlay_idx = dc->res_pool->underlay_pipe_index;\n\n\n\tASSERT(dc->fbc_compressor);\n\n\t \n\tif (!dc->ctx->fbc_gpu_addr)\n\t\treturn false;\n\n\t \n\tif (context->stream_count != 1)\n\t\treturn false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (res_ctx->pipe_ctx[i].stream) {\n\n\t\t\tpipe_ctx = &res_ctx->pipe_ctx[i];\n\n\t\t\tif (!pipe_ctx)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (pipe_ctx->pipe_idx != underlay_idx) {\n\t\t\t\t*pipe_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == dc->res_pool->pipe_count)\n\t\treturn false;\n\n\tif (!pipe_ctx->stream->link)\n\t\treturn false;\n\n\t \n\tif (pipe_ctx->stream->link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn false;\n\n\t \n\tif (pipe_ctx->stream->link->psr_settings.psr_feature_enabled)\n\t\treturn false;\n\n\t \n\tif (pipe_ctx->stream->link->replay_settings.replay_feature_enabled)\n\t\treturn false;\n\n\t \n\tif (!pipe_ctx->plane_state)\n\t\treturn false;\n\n\t \n\tif (pipe_ctx->plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void enable_fbc(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tuint32_t pipe_idx = 0;\n\n\tif (should_enable_fbc(dc, context, &pipe_idx)) {\n\t\t \n\t\tstruct compr_addr_and_pitch_params params = {0, 0, 0};\n\t\tstruct compressor *compr = dc->fbc_compressor;\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];\n\n\t\tparams.source_view_width = pipe_ctx->stream->timing.h_addressable;\n\t\tparams.source_view_height = pipe_ctx->stream->timing.v_addressable;\n\t\tparams.inst = pipe_ctx->stream_res.tg->inst;\n\t\tcompr->compr_surface_address.quad_part = dc->ctx->fbc_gpu_addr;\n\n\t\tcompr->funcs->surface_address_and_pitch(compr, &params);\n\t\tcompr->funcs->set_fbc_invalidation_triggers(compr, 1);\n\n\t\tcompr->funcs->enable_fbc(compr, &params);\n\t}\n}\n\nstatic void dce110_reset_hw_ctx_wrap(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\t \n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\n\t\t \n\t\tif (!pipe_ctx_old->stream || pipe_ctx_old->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (!pipe_ctx->stream ||\n\t\t\t\tpipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {\n\t\t\tstruct clock_source *old_clk = pipe_ctx_old->clock_source;\n\n\t\t\t \n\t\t\tif (!pipe_ctx->stream || !pipe_ctx->stream->dpms_off) {\n\t\t\t\tdc->link_srv->set_dpms_off(pipe_ctx_old);\n\n\t\t\t\t \n\t\t\t\tif (pipe_ctx_old->stream_res.audio) {\n\t\t\t\t\t \n\t\t\t\t\tpipe_ctx_old->stream_res.audio->funcs->\n\t\t\t\t\t\t\taz_disable(pipe_ctx_old->stream_res.audio);\n\n\t\t\t\t\t \n\t\t\t\t\tif (dc->caps.dynamic_audio == true) {\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tupdate_audio_usage(&dc->current_state->res_ctx, dc->res_pool,\n\t\t\t\t\t\t\t\tpipe_ctx_old->stream_res.audio, false);\n\t\t\t\t\t\tpipe_ctx_old->stream_res.audio = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);\n\t\t\tif (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {\n\t\t\t\tdm_error(\"DC: failed to blank crtc!\\n\");\n\t\t\t\tBREAK_TO_DEBUGGER();\n\t\t\t}\n\t\t\tpipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);\n\t\t\tpipe_ctx_old->stream->link->phy_state.symclk_ref_cnts.otg = 0;\n\t\t\tpipe_ctx_old->plane_res.mi->funcs->free_mem_input(\n\t\t\t\t\tpipe_ctx_old->plane_res.mi, dc->current_state->stream_count);\n\n\t\t\tif (old_clk && 0 == resource_get_clock_source_reference(&context->res_ctx,\n\t\t\t\t\t\t\t\t\t\tdc->res_pool,\n\t\t\t\t\t\t\t\t\t\told_clk))\n\t\t\t\told_clk->funcs->cs_power_down(old_clk);\n\n\t\t\tdc->hwss.disable_plane(dc, pipe_ctx_old);\n\n\t\t\tpipe_ctx_old->stream = NULL;\n\t\t}\n\t}\n}\n\nstatic void dce110_setup_audio_dto(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\t \n\t \n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == NULL)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->top_pipe)\n\t\t\tcontinue;\n\t\tif (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)\n\t\t\tcontinue;\n\t\tif (pipe_ctx->stream_res.audio != NULL) {\n\t\t\tstruct audio_output audio_output;\n\n\t\t\tbuild_audio_output(context, pipe_ctx, &audio_output);\n\n\t\t\tif (dc->res_pool->dccg && dc->res_pool->dccg->funcs->set_audio_dtbclk_dto) {\n\t\t\t\tstruct dtbclk_dto_params dto_params = {0};\n\n\t\t\t\tdc->res_pool->dccg->funcs->set_audio_dtbclk_dto(\n\t\t\t\t\tdc->res_pool->dccg, &dto_params);\n\n\t\t\t\tpipe_ctx->stream_res.audio->funcs->wall_dto_setup(\n\t\t\t\t\t\tpipe_ctx->stream_res.audio,\n\t\t\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\t\t\t&audio_output.crtc_info,\n\t\t\t\t\t\t&audio_output.pll_info);\n\t\t\t} else\n\t\t\t\tpipe_ctx->stream_res.audio->funcs->wall_dto_setup(\n\t\t\t\t\tpipe_ctx->stream_res.audio,\n\t\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\t\t&audio_output.crtc_info,\n\t\t\t\t\t&audio_output.pll_info);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == dc->res_pool->pipe_count) {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->stream == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (pipe_ctx->top_pipe)\n\t\t\t\tcontinue;\n\n\t\t\tif (!dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\t\t\tcontinue;\n\n\t\t\tif (pipe_ctx->stream_res.audio != NULL) {\n\t\t\t\tstruct audio_output audio_output;\n\n\t\t\t\tbuild_audio_output(context, pipe_ctx, &audio_output);\n\n\t\t\t\tpipe_ctx->stream_res.audio->funcs->wall_dto_setup(\n\t\t\t\t\tpipe_ctx->stream_res.audio,\n\t\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\t\t&audio_output.crtc_info,\n\t\t\t\t\t&audio_output.pll_info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum dc_status dce110_apply_ctx_to_hw(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tenum dc_status status;\n\tint i;\n\n\t \n\tif (dc->config.use_pipe_ctx_sync_logic)\n\t\treset_syncd_pipes_from_disabled_pipes(dc, context);\n\n\t \n\t \n\thws->funcs.reset_hw_ctx_wrap(dc, context);\n\n\t \n\tif (context->stream_count <= 0)\n\t\treturn DC_OK;\n\n\t \n\tdcb->funcs->set_scratch_critical_state(dcb, true);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream == pipe_ctx_old->stream) {\n\t\t\tif (pipe_ctx_old->clock_source != pipe_ctx->clock_source)\n\t\t\t\tdce_crtc_switch_to_clk_src(dc->hwseq,\n\t\t\t\t\t\tpipe_ctx->clock_source, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\thws->funcs.enable_display_power_gating(\n\t\t\t\tdc, i, dc->ctx->dc_bios,\n\t\t\t\tPIPE_GATING_CONTROL_DISABLE);\n\t}\n\n\tif (dc->fbc_compressor)\n\t\tdc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);\n\n\tdce110_setup_audio_dto(dc, context);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == NULL)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream == pipe_ctx_old->stream &&\n\t\t\tpipe_ctx->stream->link->link_state_valid) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pipe_ctx_old->stream && !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->top_pipe || pipe_ctx->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tstatus = apply_single_controller_ctx_to_hw(\n\t\t\t\tpipe_ctx,\n\t\t\t\tcontext,\n\t\t\t\tdc);\n\n\t\tif (DC_OK != status)\n\t\t\treturn status;\n\n#ifdef CONFIG_DRM_AMD_DC_FP\n\t\tif (hws->funcs.resync_fifo_dccg_dio)\n\t\t\thws->funcs.resync_fifo_dccg_dio(hws, dc, context);\n#endif\n\t}\n\n\tif (dc->fbc_compressor)\n\t\tenable_fbc(dc, dc->current_state);\n\n\tdcb->funcs->set_scratch_critical_state(dcb, false);\n\n\treturn DC_OK;\n}\n\n \nstatic void set_default_colors(struct pipe_ctx *pipe_ctx)\n{\n\tstruct default_adjustment default_adjust = { 0 };\n\n\tdefault_adjust.force_hw_default = false;\n\tdefault_adjust.in_color_space = pipe_ctx->plane_state->color_space;\n\tdefault_adjust.out_color_space = pipe_ctx->stream->output_color_space;\n\tdefault_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;\n\tdefault_adjust.surface_pixel_format = pipe_ctx->plane_res.scl_data.format;\n\n\t \n\tdefault_adjust.color_depth =\n\t\tpipe_ctx->stream->timing.display_color_depth;\n\n\t \n\tdefault_adjust.lb_color_depth = pipe_ctx->plane_res.scl_data.lb_params.depth;\n\n\tpipe_ctx->plane_res.xfm->funcs->opp_set_csc_default(\n\t\t\t\t\tpipe_ctx->plane_res.xfm, &default_adjust);\n}\n\n\n \nstatic void program_surface_visibility(const struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tenum blnd_mode blender_mode = BLND_MODE_CURRENT_PIPE;\n\tbool blank_target = false;\n\n\tif (pipe_ctx->bottom_pipe) {\n\n\t\t \n\t\tASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);\n\n\t\tif (pipe_ctx->bottom_pipe->plane_state->visible) {\n\t\t\tif (pipe_ctx->plane_state->visible)\n\t\t\t\tblender_mode = BLND_MODE_BLENDING;\n\t\t\telse\n\t\t\t\tblender_mode = BLND_MODE_OTHER_PIPE;\n\n\t\t} else if (!pipe_ctx->plane_state->visible)\n\t\t\tblank_target = true;\n\n\t} else if (!pipe_ctx->plane_state->visible)\n\t\tblank_target = true;\n\n\tdce_set_blender_mode(dc->hwseq, pipe_ctx->stream_res.tg->inst, blender_mode);\n\tpipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, blank_target);\n\n}\n\nstatic void program_gamut_remap(struct pipe_ctx *pipe_ctx)\n{\n\tint i = 0;\n\tstruct xfm_grph_csc_adjustment adjust;\n\tmemset(&adjust, 0, sizeof(adjust));\n\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;\n\n\n\tif (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {\n\t\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;\n\n\t\tfor (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)\n\t\t\tadjust.temperature_matrix[i] =\n\t\t\t\tpipe_ctx->stream->gamut_remap_matrix.matrix[i];\n\t}\n\n\tpipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);\n}\nstatic void update_plane_addr(const struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\tpipe_ctx->plane_res.mi->funcs->mem_input_program_surface_flip_and_addr(\n\t\t\tpipe_ctx->plane_res.mi,\n\t\t\t&plane_state->address,\n\t\t\tplane_state->flip_immediate);\n\n\tplane_state->status.requested_address = plane_state->address;\n}\n\nstatic void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\tplane_state->status.is_flip_pending =\n\t\t\tpipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(\n\t\t\t\t\tpipe_ctx->plane_res.mi);\n\n\tif (plane_state->status.is_flip_pending && !plane_state->visible)\n\t\tpipe_ctx->plane_res.mi->current_address = pipe_ctx->plane_res.mi->request_address;\n\n\tplane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;\n\tif (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t\tpipe_ctx->stream_res.tg->funcs->is_stereo_left_eye) {\n\t\tplane_state->status.is_right_eye =\\\n\t\t\t\t!pipe_ctx->stream_res.tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);\n\t}\n}\n\nvoid dce110_power_down(struct dc *dc)\n{\n\tpower_down_all_hw_blocks(dc);\n\tdisable_vga_and_power_gate_all_controllers(dc);\n}\n\nstatic bool wait_for_reset_trigger_to_occur(\n\tstruct dc_context *dc_ctx,\n\tstruct timing_generator *tg)\n{\n\tbool rc = false;\n\n\t \n\tconst uint32_t frames_to_wait_on_triggered_reset = 10;\n\tuint32_t i;\n\n\tfor (i = 0; i < frames_to_wait_on_triggered_reset; i++) {\n\n\t\tif (!tg->funcs->is_counter_moving(tg)) {\n\t\t\tDC_ERROR(\"TG counter is not moving!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tg->funcs->did_triggered_reset_occur(tg)) {\n\t\t\trc = true;\n\t\t\t \n\t\t\tDC_SYNC_INFO(\"GSL: reset occurred at wait count: %d\\n\",\n\t\t\t\t\ti);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttg->funcs->wait_for_state(tg, CRTC_STATE_VACTIVE);\n\t\ttg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);\n\t}\n\n\tif (false == rc)\n\t\tDC_ERROR(\"GSL: Timeout on reset trigger!\\n\");\n\n\treturn rc;\n}\n\n \nstatic void dce110_enable_timing_synchronization(\n\t\tstruct dc *dc,\n\t\tint group_index,\n\t\tint group_size,\n\t\tstruct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct dcp_gsl_params gsl_params = { 0 };\n\tint i;\n\n\tDC_SYNC_INFO(\"GSL: Setting-up...\\n\");\n\n\t \n\tgsl_params.gsl_group = 0;\n\tgsl_params.gsl_master = grouped_pipes[0]->stream_res.tg->inst;\n\n\tfor (i = 0; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->setup_global_swap_lock(\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg, &gsl_params);\n\n\t \n\tDC_SYNC_INFO(\"GSL: enabling trigger-reset\\n\");\n\n\tfor (i = 1  ; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(\n\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\tgsl_params.gsl_group);\n\n\tfor (i = 1  ; i < group_size; i++) {\n\t\tDC_SYNC_INFO(\"GSL: waiting for reset to occur.\\n\");\n\t\twait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(\n\t\t\t\tgrouped_pipes[i]->stream_res.tg);\n\t}\n\n\t \n\tDC_SYNC_INFO(\"GSL: Restoring register states.\\n\");\n\tfor (i = 0; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->stream_res.tg);\n\n\tDC_SYNC_INFO(\"GSL: Set-up complete.\\n\");\n}\n\nstatic void dce110_enable_per_frame_crtc_position_reset(\n\t\tstruct dc *dc,\n\t\tint group_size,\n\t\tstruct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct dcp_gsl_params gsl_params = { 0 };\n\tint i;\n\n\tgsl_params.gsl_group = 0;\n\tgsl_params.gsl_master = 0;\n\n\tfor (i = 0; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->setup_global_swap_lock(\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg, &gsl_params);\n\n\tDC_SYNC_INFO(\"GSL: enabling trigger-reset\\n\");\n\n\tfor (i = 1; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(\n\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\tgsl_params.gsl_master,\n\t\t\t\t&grouped_pipes[i]->stream->triggered_crtc_reset);\n\n\tDC_SYNC_INFO(\"GSL: waiting for reset to occur.\\n\");\n\tfor (i = 1; i < group_size; i++)\n\t\twait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);\n\n\tfor (i = 0; i < group_size; i++)\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->stream_res.tg);\n\n}\n\nstatic void init_pipes(struct dc *dc, struct dc_state *context)\n{\n\t\n}\n\nstatic void init_hw(struct dc *dc)\n{\n\tint i;\n\tstruct dc_bios *bp;\n\tstruct transform *xfm;\n\tstruct abm *abm;\n\tstruct dmcu *dmcu;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tuint32_t backlight = MAX_BACKLIGHT_LEVEL;\n\n\tbp = dc->ctx->dc_bios;\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\txfm = dc->res_pool->transforms[i];\n\t\txfm->funcs->transform_reset(xfm);\n\n\t\thws->funcs.enable_display_power_gating(\n\t\t\t\tdc, i, bp,\n\t\t\t\tPIPE_GATING_CONTROL_INIT);\n\t\thws->funcs.enable_display_power_gating(\n\t\t\t\tdc, i, bp,\n\t\t\t\tPIPE_GATING_CONTROL_DISABLE);\n\t\thws->funcs.enable_display_pipe_clock_gating(\n\t\t\tdc->ctx,\n\t\t\ttrue);\n\t}\n\n\tdce_clock_gating_power_up(dc->hwseq, false);\n\t \n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\ttg->funcs->disable_vga(tg);\n\n\t\t \n\t\ttg->funcs->set_blank(tg, true);\n\t\thwss_wait_for_blank_complete(tg);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->audio_count; i++) {\n\t\tstruct audio *audio = dc->res_pool->audios[i];\n\t\taudio->funcs->hw_init(audio);\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (link->panel_cntl)\n\t\t\tbacklight = link->panel_cntl->funcs->hw_init(link->panel_cntl);\n\t}\n\n\tabm = dc->res_pool->abm;\n\tif (abm != NULL)\n\t\tabm->funcs->abm_init(abm, backlight);\n\n\tdmcu = dc->res_pool->dmcu;\n\tif (dmcu != NULL && abm != NULL)\n\t\tabm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);\n\n\tif (dc->fbc_compressor)\n\t\tdc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);\n\n}\n\n\nvoid dce110_prepare_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct clk_mgr *dccg = dc->clk_mgr;\n\n\tdce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);\n\tif (dccg)\n\t\tdccg->funcs->update_clocks(\n\t\t\t\tdccg,\n\t\t\t\tcontext,\n\t\t\t\tfalse);\n}\n\nvoid dce110_optimize_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct clk_mgr *dccg = dc->clk_mgr;\n\n\tdce110_set_displaymarks(dc, context);\n\n\tif (dccg)\n\t\tdccg->funcs->update_clocks(\n\t\t\t\tdccg,\n\t\t\t\tcontext,\n\t\t\t\ttrue);\n}\n\nstatic void dce110_program_front_end_for_pipe(\n\t\tstruct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct mem_input *mi = pipe_ctx->plane_res.mi;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct xfm_grph_csc_adjustment adjust;\n\tstruct out_csc_color_matrix tbl_entry;\n\tunsigned int i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tDC_LOGGER_INIT();\n\tmemset(&tbl_entry, 0, sizeof(tbl_entry));\n\n\tmemset(&adjust, 0, sizeof(adjust));\n\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;\n\n\tdce_enable_fe_clock(dc->hwseq, mi->inst, true);\n\n\tset_default_colors(pipe_ctx);\n\tif (pipe_ctx->stream->csc_color_matrix.enable_adjustment\n\t\t\t== true) {\n\t\ttbl_entry.color_space =\n\t\t\tpipe_ctx->stream->output_color_space;\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\ttbl_entry.regval[i] =\n\t\t\tpipe_ctx->stream->csc_color_matrix.matrix[i];\n\n\t\tpipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment\n\t\t\t\t(pipe_ctx->plane_res.xfm, &tbl_entry);\n\t}\n\n\tif (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {\n\t\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;\n\n\t\tfor (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)\n\t\t\tadjust.temperature_matrix[i] =\n\t\t\t\tpipe_ctx->stream->gamut_remap_matrix.matrix[i];\n\t}\n\n\tpipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);\n\n\tpipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != NULL;\n\n\tprogram_scaler(dc, pipe_ctx);\n\n\tmi->funcs->mem_input_program_surface_config(\n\t\t\tmi,\n\t\t\tplane_state->format,\n\t\t\t&plane_state->tiling_info,\n\t\t\t&plane_state->plane_size,\n\t\t\tplane_state->rotation,\n\t\t\tNULL,\n\t\t\tfalse);\n\tif (mi->funcs->set_blank)\n\t\tmi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);\n\n\tif (dc->config.gpu_vm_support)\n\t\tmi->funcs->mem_input_program_pte_vm(\n\t\t\t\tpipe_ctx->plane_res.mi,\n\t\t\t\tplane_state->format,\n\t\t\t\t&plane_state->tiling_info,\n\t\t\t\tplane_state->rotation);\n\n\t \n\tif (pipe_ctx->plane_state->update_flags.bits.full_update ||\n\t\t\tpipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||\n\t\t\tpipe_ctx->plane_state->update_flags.bits.gamma_change)\n\t\thws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);\n\n\tif (pipe_ctx->plane_state->update_flags.bits.full_update)\n\t\thws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);\n\n\tDC_LOG_SURFACE(\n\t\t\t\"Pipe:%d %p: addr hi:0x%x, \"\n\t\t\t\"addr low:0x%x, \"\n\t\t\t\"src: %d, %d, %d,\"\n\t\t\t\" %d; dst: %d, %d, %d, %d;\"\n\t\t\t\"clip: %d, %d, %d, %d\\n\",\n\t\t\tpipe_ctx->pipe_idx,\n\t\t\t(void *) pipe_ctx->plane_state,\n\t\t\tpipe_ctx->plane_state->address.grph.addr.high_part,\n\t\t\tpipe_ctx->plane_state->address.grph.addr.low_part,\n\t\t\tpipe_ctx->plane_state->src_rect.x,\n\t\t\tpipe_ctx->plane_state->src_rect.y,\n\t\t\tpipe_ctx->plane_state->src_rect.width,\n\t\t\tpipe_ctx->plane_state->src_rect.height,\n\t\t\tpipe_ctx->plane_state->dst_rect.x,\n\t\t\tpipe_ctx->plane_state->dst_rect.y,\n\t\t\tpipe_ctx->plane_state->dst_rect.width,\n\t\t\tpipe_ctx->plane_state->dst_rect.height,\n\t\t\tpipe_ctx->plane_state->clip_rect.x,\n\t\t\tpipe_ctx->plane_state->clip_rect.y,\n\t\t\tpipe_ctx->plane_state->clip_rect.width,\n\t\t\tpipe_ctx->plane_state->clip_rect.height);\n\n\tDC_LOG_SURFACE(\n\t\t\t\"Pipe %d: width, height, x, y\\n\"\n\t\t\t\"viewport:%d, %d, %d, %d\\n\"\n\t\t\t\"recout:  %d, %d, %d, %d\\n\",\n\t\t\tpipe_ctx->pipe_idx,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.width,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.height,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.x,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.y,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.width,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.height,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.x,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.y);\n}\n\nstatic void dce110_apply_ctx_for_surface(\n\t\tstruct dc *dc,\n\t\tconst struct dc_stream_state *stream,\n\t\tint num_planes,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tif (num_planes == 0)\n\t\treturn;\n\n\tif (dc->fbc_compressor)\n\t\tdc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != stream)\n\t\t\tcontinue;\n\n\t\t \n\t\tpipe_ctx->plane_res.mi->funcs->allocate_mem_input(\n\t\t\t\tpipe_ctx->plane_res.mi,\n\t\t\t\tpipe_ctx->stream->timing.h_total,\n\t\t\t\tpipe_ctx->stream->timing.v_total,\n\t\t\t\tpipe_ctx->stream->timing.pix_clk_100hz / 10,\n\t\t\t\tcontext->stream_count);\n\n\t\tdce110_program_front_end_for_pipe(dc, pipe_ctx);\n\n\t\tdc->hwss.update_plane_addr(dc, pipe_ctx);\n\n\t\tprogram_surface_visibility(dc, pipe_ctx);\n\n\t}\n\n\tif (dc->fbc_compressor)\n\t\tenable_fbc(dc, context);\n}\n\nstatic void dce110_post_unlock_program_front_end(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n}\n\nstatic void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tint fe_idx = pipe_ctx->plane_res.mi ?\n\t\tpipe_ctx->plane_res.mi->inst : pipe_ctx->pipe_idx;\n\n\t \n\tif (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)\n\t\treturn;\n\n\thws->funcs.enable_display_power_gating(\n\t\tdc, fe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);\n\n\tdc->res_pool->transforms[fe_idx]->funcs->transform_reset(\n\t\t\t\tdc->res_pool->transforms[fe_idx]);\n}\n\nstatic void dce110_wait_for_mpcc_disconnect(\n\t\tstruct dc *dc,\n\t\tstruct resource_pool *res_pool,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\t \n}\n\nstatic void program_output_csc(struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tenum dc_color_space colorspace,\n\t\tuint16_t *matrix,\n\t\tint opp_id)\n{\n\tint i;\n\tstruct out_csc_color_matrix tbl_entry;\n\n\tif (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {\n\t\tenum dc_color_space color_space = pipe_ctx->stream->output_color_space;\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\ttbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];\n\n\t\ttbl_entry.color_space = color_space;\n\n\t\tpipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(\n\t\t\t\tpipe_ctx->plane_res.xfm, &tbl_entry);\n\t}\n}\n\nstatic void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;\n\tstruct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;\n\tstruct mem_input *mi = pipe_ctx->plane_res.mi;\n\tstruct dc_cursor_mi_param param = {\n\t\t.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,\n\t\t.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clocks.xtalin_clock_inKhz,\n\t\t.viewport = pipe_ctx->plane_res.scl_data.viewport,\n\t\t.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,\n\t\t.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,\n\t\t.rotation = pipe_ctx->plane_state->rotation,\n\t\t.mirror = pipe_ctx->plane_state->horizontal_mirror\n\t};\n\n\t \n\tif (pos_cpy.translate_by_source) {\n\t\tpos_cpy.x += pipe_ctx->plane_state->src_rect.x;\n\t\tpos_cpy.y += pipe_ctx->plane_state->src_rect.y;\n\t}\n\n\tif (pipe_ctx->plane_state->address.type\n\t\t\t== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)\n\t\tpos_cpy.enable = false;\n\n\tif (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)\n\t\tpos_cpy.enable = false;\n\n\tif (ipp->funcs->ipp_cursor_set_position)\n\t\tipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);\n\tif (mi->funcs->set_cursor_position)\n\t\tmi->funcs->set_cursor_position(mi, &pos_cpy, &param);\n}\n\nstatic void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;\n\n\tif (pipe_ctx->plane_res.ipp &&\n\t    pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes)\n\t\tpipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(\n\t\t\t\tpipe_ctx->plane_res.ipp, attributes);\n\n\tif (pipe_ctx->plane_res.mi &&\n\t    pipe_ctx->plane_res.mi->funcs->set_cursor_attributes)\n\t\tpipe_ctx->plane_res.mi->funcs->set_cursor_attributes(\n\t\t\t\tpipe_ctx->plane_res.mi, attributes);\n\n\tif (pipe_ctx->plane_res.xfm &&\n\t    pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes)\n\t\tpipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(\n\t\t\t\tpipe_ctx->plane_res.xfm, attributes);\n}\n\nbool dce110_set_backlight_level(struct pipe_ctx *pipe_ctx,\n\t\tuint32_t backlight_pwm_u16_16,\n\t\tuint32_t frame_ramp)\n{\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct abm *abm = pipe_ctx->stream_res.abm;\n\tstruct panel_cntl *panel_cntl = link->panel_cntl;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tbool fw_set_brightness = true;\n\t \n\tuint32_t controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\n\tif (abm == NULL || panel_cntl == NULL || (abm->funcs->set_backlight_level_pwm == NULL))\n\t\treturn false;\n\n\tif (dmcu)\n\t\tfw_set_brightness = dmcu->funcs->is_dmcu_initialized(dmcu);\n\n\tif (!fw_set_brightness && panel_cntl->funcs->driver_set_backlight)\n\t\tpanel_cntl->funcs->driver_set_backlight(panel_cntl, backlight_pwm_u16_16);\n\telse\n\t\tabm->funcs->set_backlight_level_pwm(\n\t\t\t\tabm,\n\t\t\t\tbacklight_pwm_u16_16,\n\t\t\t\tframe_ramp,\n\t\t\t\tcontroller_id,\n\t\t\t\tlink->panel_cntl->inst);\n\n\treturn true;\n}\n\nvoid dce110_set_abm_immediate_disable(struct pipe_ctx *pipe_ctx)\n{\n\tstruct abm *abm = pipe_ctx->stream_res.abm;\n\tstruct panel_cntl *panel_cntl = pipe_ctx->stream->link->panel_cntl;\n\n\tif (abm)\n\t\tabm->funcs->set_abm_immediate_disable(abm,\n\t\t\t\tpipe_ctx->stream->link->panel_cntl->inst);\n\n\tif (panel_cntl)\n\t\tpanel_cntl->funcs->store_backlight_level(panel_cntl);\n}\n\nvoid dce110_set_pipe(struct pipe_ctx *pipe_ctx)\n{\n\tstruct abm *abm = pipe_ctx->stream_res.abm;\n\tstruct panel_cntl *panel_cntl = pipe_ctx->stream->link->panel_cntl;\n\tuint32_t otg_inst = pipe_ctx->stream_res.tg->inst + 1;\n\n\tif (abm && panel_cntl)\n\t\tabm->funcs->set_pipe(abm, otg_inst, panel_cntl->inst);\n}\n\nvoid dce110_enable_lvds_link_output(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum clock_source_id clock_source,\n\t\tuint32_t pixel_clock)\n{\n\tlink->link_enc->funcs->enable_lvds_output(\n\t\t\tlink->link_enc,\n\t\t\tclock_source,\n\t\t\tpixel_clock);\n\tlink->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n}\n\nvoid dce110_enable_tmds_link_output(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal,\n\t\tenum clock_source_id clock_source,\n\t\tenum dc_color_depth color_depth,\n\t\tuint32_t pixel_clock)\n{\n\tlink->link_enc->funcs->enable_tmds_output(\n\t\t\tlink->link_enc,\n\t\t\tclock_source,\n\t\t\tcolor_depth,\n\t\t\tsignal,\n\t\t\tpixel_clock);\n\tlink->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n}\n\nvoid dce110_enable_dp_link_output(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal,\n\t\tenum clock_source_id clock_source,\n\t\tconst struct dc_link_settings *link_settings)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tstruct pipe_ctx *pipes =\n\t\t\tlink->dc->current_state->res_ctx.pipe_ctx;\n\tstruct clock_source *dp_cs =\n\t\t\tlink->dc->res_pool->dp_clock_source;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\tunsigned int i;\n\n\t \n\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\tlink->dc->hwss.edp_wait_for_hpd_ready(link, true);\n\t}\n\n\t \n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (pipes[i].stream != NULL &&\n\t\t\t\tpipes[i].stream->link == link) {\n\t\t\tif (pipes[i].clock_source != NULL &&\n\t\t\t\t\tpipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {\n\t\t\t\tpipes[i].clock_source = dp_cs;\n\t\t\t\tpipes[i].stream_res.pix_clk_params.requested_pix_clk_100hz =\n\t\t\t\t\t\tpipes[i].stream->timing.pix_clk_100hz;\n\t\t\t\tpipes[i].clock_source->funcs->program_pix_clk(\n\t\t\t\t\t\tpipes[i].clock_source,\n\t\t\t\t\t\t&pipes[i].stream_res.pix_clk_params,\n\t\t\t\t\t\tdc->link_srv->dp_get_encoding_format(link_settings),\n\t\t\t\t\t\t&pipes[i].pll_settings);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dc->link_srv->dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING) {\n\t\tif (dc->clk_mgr->funcs->notify_link_rate_change)\n\t\t\tdc->clk_mgr->funcs->notify_link_rate_change(dc->clk_mgr, link);\n\t}\n\n\tif (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->lock_phy(dmcu);\n\n\tif (link_hwss->ext.enable_dp_link_output)\n\t\tlink_hwss->ext.enable_dp_link_output(link, link_res, signal,\n\t\t\t\tclock_source, link_settings);\n\n\tlink->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n\n\tif (dmcu != NULL && dmcu->funcs->unlock_phy)\n\t\tdmcu->funcs->unlock_phy(dmcu);\n\n\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_ENABLE_LINK_PHY);\n}\n\nvoid dce110_disable_link_output(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tstruct dc *dc = link->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\n\tif (signal == SIGNAL_TYPE_EDP &&\n\t\t\tlink->dc->hwss.edp_backlight_control)\n\t\tlink->dc->hwss.edp_backlight_control(link, false);\n\telse if (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->lock_phy(dmcu);\n\n\tlink_hwss->disable_link_output(link, link_res, signal);\n\tlink->phy_state.symclk_state = SYMCLK_OFF_TX_OFF;\n\t \n\tif (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->unlock_phy(dmcu);\n\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_DISABLE_LINK_PHY);\n}\n\nstatic const struct hw_sequencer_funcs dce110_funcs = {\n\t.program_gamut_remap = program_gamut_remap,\n\t.program_output_csc = program_output_csc,\n\t.init_hw = init_hw,\n\t.apply_ctx_to_hw = dce110_apply_ctx_to_hw,\n\t.apply_ctx_for_surface = dce110_apply_ctx_for_surface,\n\t.post_unlock_program_front_end = dce110_post_unlock_program_front_end,\n\t.update_plane_addr = update_plane_addr,\n\t.update_pending_status = dce110_update_pending_status,\n\t.enable_accelerated_mode = dce110_enable_accelerated_mode,\n\t.enable_timing_synchronization = dce110_enable_timing_synchronization,\n\t.enable_per_frame_crtc_position_reset = dce110_enable_per_frame_crtc_position_reset,\n\t.update_info_frame = dce110_update_info_frame,\n\t.enable_stream = dce110_enable_stream,\n\t.disable_stream = dce110_disable_stream,\n\t.unblank_stream = dce110_unblank_stream,\n\t.blank_stream = dce110_blank_stream,\n\t.enable_audio_stream = dce110_enable_audio_stream,\n\t.disable_audio_stream = dce110_disable_audio_stream,\n\t.disable_plane = dce110_power_down_fe,\n\t.pipe_control_lock = dce_pipe_control_lock,\n\t.interdependent_update_lock = NULL,\n\t.cursor_lock = dce_pipe_control_lock,\n\t.prepare_bandwidth = dce110_prepare_bandwidth,\n\t.optimize_bandwidth = dce110_optimize_bandwidth,\n\t.set_drr = set_drr,\n\t.get_position = get_position,\n\t.set_static_screen_control = set_static_screen_control,\n\t.setup_stereo = NULL,\n\t.set_avmute = dce110_set_avmute,\n\t.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,\n\t.edp_backlight_control = dce110_edp_backlight_control,\n\t.edp_power_control = dce110_edp_power_control,\n\t.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,\n\t.set_cursor_position = dce110_set_cursor_position,\n\t.set_cursor_attribute = dce110_set_cursor_attribute,\n\t.set_backlight_level = dce110_set_backlight_level,\n\t.set_abm_immediate_disable = dce110_set_abm_immediate_disable,\n\t.set_pipe = dce110_set_pipe,\n\t.enable_lvds_link_output = dce110_enable_lvds_link_output,\n\t.enable_tmds_link_output = dce110_enable_tmds_link_output,\n\t.enable_dp_link_output = dce110_enable_dp_link_output,\n\t.disable_link_output = dce110_disable_link_output,\n};\n\nstatic const struct hwseq_private_funcs dce110_private_funcs = {\n\t.init_pipes = init_pipes,\n\t.update_plane_addr = update_plane_addr,\n\t.set_input_transfer_func = dce110_set_input_transfer_func,\n\t.set_output_transfer_func = dce110_set_output_transfer_func,\n\t.power_down = dce110_power_down,\n\t.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,\n\t.enable_display_power_gating = dce110_enable_display_power_gating,\n\t.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,\n\t.enable_stream_timing = dce110_enable_stream_timing,\n\t.disable_stream_gating = NULL,\n\t.enable_stream_gating = NULL,\n\t.edp_backlight_control = dce110_edp_backlight_control,\n};\n\nvoid dce110_hw_sequencer_construct(struct dc *dc)\n{\n\tdc->hwss = dce110_funcs;\n\tdc->hwseq->funcs = dce110_private_funcs;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}