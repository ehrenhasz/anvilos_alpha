{
  "module_name": "dc_link_exports.c",
  "hash_id": "99f158d4eddd99c3a689b04a8beff85b2f42b27d79e59adb95fbb872ad73293e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_link_exports.c",
  "human_readable_source": " \n\n \n#include \"link.h\"\n#include \"dce/dce_i2c.h\"\nstruct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)\n{\n\treturn dc->links[link_index];\n}\n\nvoid dc_get_edp_links(const struct dc *dc,\n\t\tstruct dc_link **edp_links,\n\t\tint *edp_num)\n{\n\tint i;\n\n\t*edp_num = 0;\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t\n\t\tif (!dc->links[i])\n\t\t\tcontinue;\n\t\tif (dc->links[i]->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\tedp_links[*edp_num] = dc->links[i];\n\t\t\tif (++(*edp_num) == MAX_NUM_EDP)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool dc_get_edp_link_panel_inst(const struct dc *dc,\n\t\tconst struct dc_link *link,\n\t\tunsigned int *inst_out)\n{\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\tint edp_num, i;\n\n\t*inst_out = 0;\n\tif (link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn false;\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\tfor (i = 0; i < edp_num; i++) {\n\t\tif (link == edp_links[i])\n\t\t\tbreak;\n\t\t(*inst_out)++;\n\t}\n\treturn true;\n}\n\nbool dc_link_detect(struct dc_link *link, enum dc_detect_reason reason)\n{\n\treturn link->dc->link_srv->detect_link(link, reason);\n}\n\nbool dc_link_detect_connection_type(struct dc_link *link,\n\t\tenum dc_connection_type *type)\n{\n\treturn link->dc->link_srv->detect_connection_type(link, type);\n}\n\nconst struct dc_link_status *dc_link_get_status(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->get_status(link);\n}\n\n \nbool dc_link_is_hdcp14(struct dc_link *link, enum signal_type signal)\n{\n\treturn link->dc->link_srv->is_hdcp1x_supported(link, signal);\n}\n\nbool dc_link_is_hdcp22(struct dc_link *link, enum signal_type signal)\n{\n\treturn link->dc->link_srv->is_hdcp2x_supported(link, signal);\n}\n\nvoid dc_link_clear_dprx_states(struct dc_link *link)\n{\n\tlink->dc->link_srv->clear_dprx_states(link);\n}\n\nbool dc_link_reset_cur_dp_mst_topology(struct dc_link *link)\n{\n\treturn link->dc->link_srv->reset_cur_dp_mst_topology(link);\n}\n\nuint32_t dc_link_bandwidth_kbps(\n\tconst struct dc_link *link,\n\tconst struct dc_link_settings *link_settings)\n{\n\treturn link->dc->link_srv->dp_link_bandwidth_kbps(link, link_settings);\n}\n\nvoid dc_get_cur_link_res_map(const struct dc *dc, uint32_t *map)\n{\n\tdc->link_srv->get_cur_res_map(dc, map);\n}\n\nvoid dc_restore_link_res_map(const struct dc *dc, uint32_t *map)\n{\n\tdc->link_srv->restore_res_map(dc, map);\n}\n\nbool dc_link_update_dsc_config(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\n\treturn link->dc->link_srv->update_dsc_config(pipe_ctx);\n}\n\nbool dc_is_oem_i2c_device_present(\n\tstruct dc *dc,\n\tsize_t slave_address)\n{\n\tif (dc->res_pool->oem_device)\n\t\treturn dce_i2c_oem_device_present(\n\t\t\tdc->res_pool,\n\t\t\tdc->res_pool->oem_device,\n\t\t\tslave_address);\n\n\treturn false;\n}\n\nbool dc_submit_i2c(\n\t\tstruct dc *dc,\n\t\tuint32_t link_index,\n\t\tstruct i2c_command *cmd)\n{\n\n\tstruct dc_link *link = dc->links[link_index];\n\tstruct ddc_service *ddc = link->ddc;\n\n\treturn dce_i2c_submit_command(\n\t\tdc->res_pool,\n\t\tddc->ddc_pin,\n\t\tcmd);\n}\n\nbool dc_submit_i2c_oem(\n\t\tstruct dc *dc,\n\t\tstruct i2c_command *cmd)\n{\n\tstruct ddc_service *ddc = dc->res_pool->oem_device;\n\n\tif (ddc)\n\t\treturn dce_i2c_submit_command(\n\t\t\tdc->res_pool,\n\t\t\tddc->ddc_pin,\n\t\t\tcmd);\n\n\treturn false;\n}\n\nvoid dc_link_dp_handle_automated_test(struct dc_link *link)\n{\n\tlink->dc->link_srv->dp_handle_automated_test(link);\n}\n\nbool dc_link_dp_set_test_pattern(\n\tstruct dc_link *link,\n\tenum dp_test_pattern test_pattern,\n\tenum dp_test_pattern_color_space test_pattern_color_space,\n\tconst struct link_training_settings *p_link_settings,\n\tconst unsigned char *p_custom_pattern,\n\tunsigned int cust_pattern_size)\n{\n\treturn link->dc->link_srv->dp_set_test_pattern(link, test_pattern,\n\t\t\ttest_pattern_color_space, p_link_settings,\n\t\t\tp_custom_pattern, cust_pattern_size);\n}\n\nvoid dc_link_set_drive_settings(struct dc *dc,\n\t\t\t\tstruct link_training_settings *lt_settings,\n\t\t\t\tstruct dc_link *link)\n{\n\tstruct link_resource link_res;\n\n\tdc->link_srv->get_cur_link_res(link, &link_res);\n\tdc->link_srv->dp_set_drive_settings(link, &link_res, lt_settings);\n}\n\nvoid dc_link_set_preferred_link_settings(struct dc *dc,\n\t\t\t\t\t struct dc_link_settings *link_setting,\n\t\t\t\t\t struct dc_link *link)\n{\n\tdc->link_srv->dp_set_preferred_link_settings(dc, link_setting, link);\n}\n\nvoid dc_link_set_preferred_training_settings(struct dc *dc,\n\t\tstruct dc_link_settings *link_setting,\n\t\tstruct dc_link_training_overrides *lt_overrides,\n\t\tstruct dc_link *link,\n\t\tbool skip_immediate_retrain)\n{\n\tdc->link_srv->dp_set_preferred_training_settings(dc, link_setting,\n\t\t\tlt_overrides, link, skip_immediate_retrain);\n}\n\nbool dc_dp_trace_is_initialized(struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_trace_is_initialized(link);\n}\n\nvoid dc_dp_trace_set_is_logged_flag(struct dc_link *link,\n\t\tbool in_detection,\n\t\tbool is_logged)\n{\n\tlink->dc->link_srv->dp_trace_set_is_logged_flag(link, in_detection, is_logged);\n}\n\nbool dc_dp_trace_is_logged(struct dc_link *link, bool in_detection)\n{\n\treturn link->dc->link_srv->dp_trace_is_logged(link, in_detection);\n}\n\nunsigned long long dc_dp_trace_get_lt_end_timestamp(struct dc_link *link,\n\t\tbool in_detection)\n{\n\treturn link->dc->link_srv->dp_trace_get_lt_end_timestamp(link, in_detection);\n}\n\nconst struct dp_trace_lt_counts *dc_dp_trace_get_lt_counts(struct dc_link *link,\n\t\tbool in_detection)\n{\n\treturn link->dc->link_srv->dp_trace_get_lt_counts(link, in_detection);\n}\n\nunsigned int dc_dp_trace_get_link_loss_count(struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_trace_get_link_loss_count(link);\n}\n\nstruct dc_sink *dc_link_add_remote_sink(\n\t\tstruct dc_link *link,\n\t\tconst uint8_t *edid,\n\t\tint len,\n\t\tstruct dc_sink_init_data *init_data)\n{\n\treturn link->dc->link_srv->add_remote_sink(link, edid, len, init_data);\n}\n\nvoid dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)\n{\n\tlink->dc->link_srv->remove_remote_sink(link, sink);\n}\n\nint dc_link_aux_transfer_raw(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload,\n\t\tenum aux_return_code_type *operation_result)\n{\n\tconst struct dc *dc = ddc->link->dc;\n\n\treturn dc->link_srv->aux_transfer_raw(\n\t\t\tddc, payload, operation_result);\n}\n\nuint32_t dc_link_bw_kbps_from_raw_frl_link_rate_data(const struct dc *dc, uint8_t bw)\n{\n\treturn dc->link_srv->bw_kbps_from_raw_frl_link_rate_data(bw);\n}\n\nbool dc_link_decide_edp_link_settings(struct dc_link *link,\n\t\tstruct dc_link_settings *link_setting, uint32_t req_bw)\n{\n\treturn link->dc->link_srv->edp_decide_link_settings(link, link_setting, req_bw);\n}\n\n\nbool dc_link_dp_get_max_link_enc_cap(const struct dc_link *link,\n\t\tstruct dc_link_settings *max_link_enc_cap)\n{\n\treturn link->dc->link_srv->dp_get_max_link_enc_cap(link, max_link_enc_cap);\n}\n\nenum dp_link_encoding dc_link_dp_mst_decide_link_encoding_format(\n\t\tconst struct dc_link *link)\n{\n\treturn link->dc->link_srv->mst_decide_link_encoding_format(link);\n}\n\nconst struct dc_link_settings *dc_link_get_link_cap(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_get_verified_link_cap(link);\n}\n\nenum dc_link_encoding_format dc_link_get_highest_encoding_format(const struct dc_link *link)\n{\n\tif (dc_is_dp_signal(link->connector_signal)) {\n\t\tif (link->dpcd_caps.dongle_type >= DISPLAY_DONGLE_DP_DVI_DONGLE &&\n\t\t\t\tlink->dpcd_caps.dongle_type <= DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE)\n\t\t\treturn DC_LINK_ENCODING_HDMI_TMDS;\n\t\telse if (link->dc->link_srv->dp_get_encoding_format(&link->verified_link_cap) ==\n\t\t\t\tDP_8b_10b_ENCODING)\n\t\t\treturn DC_LINK_ENCODING_DP_8b_10b;\n\t\telse if (link->dc->link_srv->dp_get_encoding_format(&link->verified_link_cap) ==\n\t\t\t\tDP_128b_132b_ENCODING)\n\t\t\treturn DC_LINK_ENCODING_DP_128b_132b;\n\t} else if (dc_is_hdmi_signal(link->connector_signal)) {\n\t}\n\n\treturn DC_LINK_ENCODING_UNSPECIFIED;\n}\n\nbool dc_link_is_dp_sink_present(struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_is_sink_present(link);\n}\n\nbool dc_link_is_fec_supported(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_is_fec_supported(link);\n}\n\nvoid dc_link_overwrite_extended_receiver_cap(\n\t\tstruct dc_link *link)\n{\n\tlink->dc->link_srv->dp_overwrite_extended_receiver_cap(link);\n}\n\nbool dc_link_should_enable_fec(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_should_enable_fec(link);\n}\n\nint dc_link_dp_dpia_handle_usb4_bandwidth_allocation_for_link(\n\t\tstruct dc_link *link, int peak_bw)\n{\n\treturn link->dc->link_srv->dpia_handle_usb4_bandwidth_allocation_for_link(link, peak_bw);\n}\n\nvoid dc_link_handle_usb4_bw_alloc_response(struct dc_link *link, uint8_t bw, uint8_t result)\n{\n\tlink->dc->link_srv->dpia_handle_bw_alloc_response(link, bw, result);\n}\n\nbool dc_link_check_link_loss_status(\n\tstruct dc_link *link,\n\tunion hpd_irq_data *hpd_irq_dpcd_data)\n{\n\treturn link->dc->link_srv->dp_parse_link_loss_status(link, hpd_irq_dpcd_data);\n}\n\nbool dc_link_dp_allow_hpd_rx_irq(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->dp_should_allow_hpd_rx_irq(link);\n}\n\nvoid dc_link_dp_handle_link_loss(struct dc_link *link)\n{\n\tlink->dc->link_srv->dp_handle_link_loss(link);\n}\n\nenum dc_status dc_link_dp_read_hpd_rx_irq_data(\n\tstruct dc_link *link,\n\tunion hpd_irq_data *irq_data)\n{\n\treturn link->dc->link_srv->dp_read_hpd_rx_irq_data(link, irq_data);\n}\n\nbool dc_link_handle_hpd_rx_irq(struct dc_link *link,\n\t\tunion hpd_irq_data *out_hpd_irq_dpcd_data, bool *out_link_loss,\n\t\tbool defer_handling, bool *has_left_work)\n{\n\treturn link->dc->link_srv->dp_handle_hpd_rx_irq(link, out_hpd_irq_dpcd_data,\n\t\t\tout_link_loss, defer_handling, has_left_work);\n}\n\nvoid dc_link_dp_receiver_power_ctrl(struct dc_link *link, bool on)\n{\n\tlink->dc->link_srv->dpcd_write_rx_power_ctrl(link, on);\n}\n\nenum lttpr_mode dc_link_decide_lttpr_mode(struct dc_link *link,\n\t\tstruct dc_link_settings *link_setting)\n{\n\treturn link->dc->link_srv->dp_decide_lttpr_mode(link, link_setting);\n}\n\nvoid dc_link_edp_panel_backlight_power_on(struct dc_link *link, bool wait_for_hpd)\n{\n\tlink->dc->link_srv->edp_panel_backlight_power_on(link, wait_for_hpd);\n}\n\nint dc_link_get_backlight_level(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->edp_get_backlight_level(link);\n}\n\nbool dc_link_get_backlight_level_nits(struct dc_link *link,\n\t\tuint32_t *backlight_millinits_avg,\n\t\tuint32_t *backlight_millinits_peak)\n{\n\treturn link->dc->link_srv->edp_get_backlight_level_nits(link,\n\t\t\tbacklight_millinits_avg,\n\t\t\tbacklight_millinits_peak);\n}\n\nbool dc_link_set_backlight_level(const struct dc_link *link,\n\t\tuint32_t backlight_pwm_u16_16,\n\t\tuint32_t frame_ramp)\n{\n\treturn link->dc->link_srv->edp_set_backlight_level(link,\n\t\t\tbacklight_pwm_u16_16, frame_ramp);\n}\n\nbool dc_link_set_backlight_level_nits(struct dc_link *link,\n\t\tbool isHDR,\n\t\tuint32_t backlight_millinits,\n\t\tuint32_t transition_time_in_ms)\n{\n\treturn link->dc->link_srv->edp_set_backlight_level_nits(link, isHDR,\n\t\t\tbacklight_millinits, transition_time_in_ms);\n}\n\nint dc_link_get_target_backlight_pwm(const struct dc_link *link)\n{\n\treturn link->dc->link_srv->edp_get_target_backlight_pwm(link);\n}\n\nbool dc_link_get_psr_state(const struct dc_link *link, enum dc_psr_state *state)\n{\n\treturn link->dc->link_srv->edp_get_psr_state(link, state);\n}\n\nbool dc_link_set_psr_allow_active(struct dc_link *link, const bool *allow_active,\n\t\tbool wait, bool force_static, const unsigned int *power_opts)\n{\n\treturn link->dc->link_srv->edp_set_psr_allow_active(link, allow_active, wait,\n\t\t\tforce_static, power_opts);\n}\n\nbool dc_link_setup_psr(struct dc_link *link,\n\t\tconst struct dc_stream_state *stream, struct psr_config *psr_config,\n\t\tstruct psr_context *psr_context)\n{\n\treturn link->dc->link_srv->edp_setup_psr(link, stream, psr_config, psr_context);\n}\n\nbool dc_link_get_replay_state(const struct dc_link *link, uint64_t *state)\n{\n\treturn link->dc->link_srv->edp_get_replay_state(link, state);\n}\n\nbool dc_link_wait_for_t12(struct dc_link *link)\n{\n\treturn link->dc->link_srv->edp_wait_for_t12(link);\n}\n\nbool dc_link_get_hpd_state(struct dc_link *link)\n{\n\treturn link->dc->link_srv->get_hpd_state(link);\n}\n\nvoid dc_link_enable_hpd(const struct dc_link *link)\n{\n\tlink->dc->link_srv->enable_hpd(link);\n}\n\nvoid dc_link_disable_hpd(const struct dc_link *link)\n{\n\tlink->dc->link_srv->disable_hpd(link);\n}\n\nvoid dc_link_enable_hpd_filter(struct dc_link *link, bool enable)\n{\n\tlink->dc->link_srv->enable_hpd_filter(link, enable);\n}\n\nbool dc_link_validate(struct dc *dc, const struct dc_stream_state *streams, const unsigned int count)\n{\n\treturn dc->link_srv->validate_dpia_bandwidth(streams, count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}