{
  "module_name": "dcn31_dio_link_encoder.c",
  "hash_id": "4d19dbd3cbff3068867328473fd068288b99de22fcd26183f061cb56814a7147",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dio_link_encoder.c",
  "human_readable_source": " \n\n\n#include \"reg_helper.h\"\n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dcn31_dio_link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"dc_bios_types.h\"\n\n#include \"gpio_service_interface.h\"\n\n#include \"link_enc_cfg.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dal_asic_id.h\"\n#include \"link.h\"\n\n#define CTX \\\n\tenc10->base.ctx\n#define DC_LOGGER \\\n\tenc10->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc10->link_regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc10->link_shift->field_name, enc10->link_mask->field_name\n\n#define IND_REG(index) \\\n\t(enc10->link_regs->index)\n\n#define AUX_REG(reg)\\\n\t(enc10->aux_regs->reg)\n\n#define AUX_REG_READ(reg_name) \\\n\t\tdm_read_reg(CTX, AUX_REG(reg_name))\n\n#define AUX_REG_WRITE(reg_name, val) \\\n\t\t\tdm_write_reg(CTX, AUX_REG(reg_name), val)\n\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\nstatic uint8_t phy_id_from_transmitter(enum transmitter t)\n{\n\tuint8_t phy_id;\n\n\tswitch (t) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tphy_id = 0;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tphy_id = 1;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tphy_id = 2;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tphy_id = 3;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tphy_id = 4;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tphy_id = 5;\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tphy_id = 6;\n\t\tbreak;\n\tdefault:\n\t\tphy_id = 0;\n\t\tbreak;\n\t}\n\treturn phy_id;\n}\n\nstatic bool has_query_dp_alt(struct link_encoder *enc)\n{\n\tstruct dc_dmub_srv *dc_dmub_srv = enc->ctx->dmub_srv;\n\n\tif (enc->ctx->dce_version >= DCN_VERSION_3_15)\n\t\treturn true;\n\n\t \n\treturn dc_dmub_srv &&\n\t       !(dc_dmub_srv->dmub->fw_version >= DMUB_FW_VERSION(4, 0, 0) &&\n\t\t dc_dmub_srv->dmub->fw_version <= DMUB_FW_VERSION(4, 0, 10));\n}\n\nstatic bool query_dp_alt_from_dmub(struct link_encoder *enc,\n\t\t\t\t   union dmub_rb_cmd *cmd)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->query_dp_alt.header.type = DMUB_CMD__VBIOS;\n\tcmd->query_dp_alt.header.sub_type =\n\t\tDMUB_CMD__VBIOS_TRANSMITTER_QUERY_DP_ALT;\n\tcmd->query_dp_alt.header.payload_bytes = sizeof(cmd->query_dp_alt.data);\n\tcmd->query_dp_alt.data.phy_id = phy_id_from_transmitter(enc10->base.transmitter);\n\n\tif (!dm_execute_dmub_cmd(enc->ctx, cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid dcn31_link_encoder_set_dio_phy_mux(\n\tstruct link_encoder *enc,\n\tenum encoder_type_select sel,\n\tuint32_t hpo_inst)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tswitch (enc->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKA_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKA_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKA_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKB_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKB_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKB_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKC_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKC_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKC_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKD_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKD_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKD_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKE_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKE_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKE_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tif (sel == ENCODER_TYPE_HDMI_FRL)\n\t\t\tREG_UPDATE(DIO_LINKF_CNTL,\n\t\t\t\t\tHPO_HDMI_ENC_SEL, hpo_inst);\n\t\telse if (sel == ENCODER_TYPE_DP_128B132B)\n\t\t\tREG_UPDATE(DIO_LINKF_CNTL,\n\t\t\t\t\tHPO_DP_ENC_SEL, hpo_inst);\n\t\tREG_UPDATE(DIO_LINKF_CNTL,\n\t\t\t\tENC_TYPE_SEL, sel);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void enc31_hw_init(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n \n\n \n\t\n\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tREG_UPDATE(TMDS_CTL_BITS, TMDS_CTL0, 1);\n\n\tdcn10_aux_initialize(enc10);\n}\n\nstatic const struct link_encoder_funcs dcn31_link_enc_funcs = {\n\t.read_state = link_enc2_read_state,\n\t.validate_output_with_stream =\n\t\t\tdcn30_link_encoder_validate_output_with_stream,\n\t.hw_init = enc31_hw_init,\n\t.setup = dcn10_link_encoder_setup,\n\t.enable_tmds_output = dcn10_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dcn31_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dcn31_link_encoder_enable_dp_mst_output,\n\t.disable_output = dcn31_link_encoder_disable_output,\n\t.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdcn10_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdcn10_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dcn10_link_encoder_enable_hpd,\n\t.disable_hpd = dcn10_link_encoder_disable_hpd,\n\t.is_dig_enabled = dcn10_is_dig_enabled,\n\t.destroy = dcn10_link_encoder_destroy,\n\t.fec_set_enable = enc2_fec_set_enable,\n\t.fec_set_ready = enc2_fec_set_ready,\n\t.fec_is_active = enc2_fec_is_active,\n\t.get_dig_frontend = dcn10_get_dig_frontend,\n\t.get_dig_mode = dcn10_get_dig_mode,\n\t.is_in_alt_mode = dcn31_link_encoder_is_in_alt_mode,\n\t.get_max_link_cap = dcn31_link_encoder_get_max_link_cap,\n\t.set_dio_phy_mux = dcn31_link_encoder_set_dio_phy_mux,\n};\n\nvoid dcn31_link_encoder_construct(\n\tstruct dcn20_link_encoder *enc20,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tconst struct dcn10_link_enc_aux_registers *aux_regs,\n\tconst struct dcn10_link_enc_hpd_registers *hpd_regs,\n\tconst struct dcn10_link_enc_shift *link_shift,\n\tconst struct dcn10_link_enc_mask *link_mask)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct dcn10_link_encoder *enc10 = &enc20->enc10;\n\n\tenc10->base.funcs = &dcn31_link_enc_funcs;\n\tenc10->base.ctx = init_data->ctx;\n\tenc10->base.id = init_data->encoder;\n\n\tenc10->base.hpd_source = init_data->hpd_source;\n\tenc10->base.connector = init_data->connector;\n\n\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc10->base.features = *enc_features;\n\n\tenc10->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc10->link_regs = link_regs;\n\tenc10->aux_regs = aux_regs;\n\tenc10->hpd_regs = hpd_regs;\n\tenc10->link_shift = link_shift;\n\tenc10->link_mask = link_mask;\n\n\tswitch (enc10->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc10->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc10->base.ctx->dc_bios,\n\t\t\t\t\t\tenc10->base.id, &bp_cap_info);\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tenc10->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc10->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t\tenc10->base.features.flags.bits.IS_DP2_CAPABLE = bp_cap_info.IS_DP2_CAPABLE;\n\t\tenc10->base.features.flags.bits.IS_UHBR10_CAPABLE = bp_cap_info.DP_UHBR10_EN;\n\t\tenc10->base.features.flags.bits.IS_UHBR13_5_CAPABLE = bp_cap_info.DP_UHBR13_5_EN;\n\t\tenc10->base.features.flags.bits.IS_UHBR20_CAPABLE = bp_cap_info.DP_UHBR20_EN;\n\t\tenc10->base.features.flags.bits.DP_IS_USB_C =\n\t\t\t\tbp_cap_info.DP_IS_USB_C;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n\nvoid dcn31_link_encoder_construct_minimal(\n\tstruct dcn20_link_encoder *enc20,\n\tstruct dc_context *ctx,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tenum engine_id eng_id)\n{\n\tstruct dcn10_link_encoder *enc10 = &enc20->enc10;\n\n\tenc10->base.funcs = &dcn31_link_enc_funcs;\n\tenc10->base.ctx = ctx;\n\tenc10->base.id.type = OBJECT_TYPE_ENCODER;\n\tenc10->base.hpd_source = HPD_SOURCEID_UNKNOWN;\n\tenc10->base.connector.type = OBJECT_TYPE_CONNECTOR;\n\tenc10->base.preferred_engine = eng_id;\n\tenc10->base.features = *enc_features;\n\tenc10->base.transmitter = TRANSMITTER_UNKNOWN;\n\tenc10->link_regs = link_regs;\n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP;\n}\n\n \nstatic bool link_dpia_control(struct dc_context *dc_ctx,\n\tstruct dmub_cmd_dig_dpia_control_data *dpia_control)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.dig1_dpia_control.header.type = DMUB_CMD__DPIA;\n\tcmd.dig1_dpia_control.header.sub_type =\n\t\t\tDMUB_CMD__DPIA_DIG1_DPIA_CONTROL;\n\tcmd.dig1_dpia_control.header.payload_bytes =\n\t\tsizeof(cmd.dig1_dpia_control) -\n\t\tsizeof(cmd.dig1_dpia_control.header);\n\n\tcmd.dig1_dpia_control.dpia_control = *dpia_control;\n\n\tdm_execute_dmub_cmd(dc_ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nstatic void link_encoder_disable(struct dcn10_link_encoder *enc10)\n{\n\t \n\tREG_UPDATE(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, 0);\n}\n\nvoid dcn31_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\t \n\tif (!link_enc_cfg_is_transmitter_mappable(enc->ctx->dc, enc)) {\n\n\t\tDC_LOG_DEBUG(\"%s: enc_id(%d)\\n\", __func__, enc->preferred_engine);\n\t\tdcn20_link_encoder_enable_dp_output(enc, link_settings, clock_source);\n\n\t} else {\n\n\t\tstruct dmub_cmd_dig_dpia_control_data dpia_control = { 0 };\n\t\tstruct dc_link *link;\n\n\t\tlink = link_enc_cfg_get_link_using_link_enc(enc->ctx->dc, enc->preferred_engine);\n\n\t\tenc1_configure_encoder(enc10, link_settings);\n\n\t\tdpia_control.action = (uint8_t)TRANSMITTER_CONTROL_ENABLE;\n\t\tdpia_control.enc_id = enc->preferred_engine;\n\t\tdpia_control.mode_laneset.digmode = 0;  \n\t\tdpia_control.lanenum = (uint8_t)link_settings->lane_count;\n\t\tdpia_control.symclk_10khz = link_settings->link_rate *\n\t\t\t\tLINK_RATE_REF_FREQ_IN_KHZ / 10;\n\t\t \n\t\tdpia_control.hpdsel = 6;\n\n\t\tif (link) {\n\t\t\tdpia_control.dpia_id = link->ddc_hw_inst;\n\t\t\tdpia_control.fec_rdy = link->dc->link_srv->dp_should_enable_fec(link);\n\t\t} else {\n\t\t\tDC_LOG_ERROR(\"%s: Failed to execute DPIA enable DMUB command.\\n\", __func__);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\n\t\tDC_LOG_DEBUG(\"%s: DPIA(%d) - enc_id(%d)\\n\", __func__, dpia_control.dpia_id, dpia_control.enc_id);\n\t\tlink_dpia_control(enc->ctx, &dpia_control);\n\t}\n}\n\nvoid dcn31_link_encoder_enable_dp_mst_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\t \n\tif (!link_enc_cfg_is_transmitter_mappable(enc->ctx->dc, enc)) {\n\n\t\tDC_LOG_DEBUG(\"%s: enc_id(%d)\\n\", __func__, enc->preferred_engine);\n\t\tdcn10_link_encoder_enable_dp_mst_output(enc, link_settings, clock_source);\n\n\t} else {\n\n\t\tstruct dmub_cmd_dig_dpia_control_data dpia_control = { 0 };\n\t\tstruct dc_link *link;\n\n\t\tlink = link_enc_cfg_get_link_using_link_enc(enc->ctx->dc, enc->preferred_engine);\n\n\t\tenc1_configure_encoder(enc10, link_settings);\n\n\t\tdpia_control.action = (uint8_t)TRANSMITTER_CONTROL_ENABLE;\n\t\tdpia_control.enc_id = enc->preferred_engine;\n\t\tdpia_control.mode_laneset.digmode = 5;  \n\t\tdpia_control.lanenum = (uint8_t)link_settings->lane_count;\n\t\tdpia_control.symclk_10khz = link_settings->link_rate *\n\t\t\t\tLINK_RATE_REF_FREQ_IN_KHZ / 10;\n\t\t \n\t\tdpia_control.hpdsel = 6;\n\n\t\tif (link) {\n\t\t\tdpia_control.dpia_id = link->ddc_hw_inst;\n\t\t\tdpia_control.fec_rdy = link->dc->link_srv->dp_should_enable_fec(link);\n\t\t} else {\n\t\t\tDC_LOG_ERROR(\"%s: Failed to execute DPIA enable DMUB command.\\n\", __func__);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\n\t\tDC_LOG_DEBUG(\"%s: DPIA(%d) - enc_id(%d)\\n\", __func__, dpia_control.dpia_id, dpia_control.enc_id);\n\t\tlink_dpia_control(enc->ctx, &dpia_control);\n\t}\n}\n\nvoid dcn31_link_encoder_disable_output(\n\tstruct link_encoder *enc,\n\tenum signal_type signal)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\t \n\tif (!link_enc_cfg_is_transmitter_mappable(enc->ctx->dc, enc)) {\n\n\t\tDC_LOG_DEBUG(\"%s: enc_id(%d)\\n\", __func__, enc->preferred_engine);\n\t\tdcn10_link_encoder_disable_output(enc, signal);\n\n\t} else {\n\n\t\tstruct dmub_cmd_dig_dpia_control_data dpia_control = { 0 };\n\t\tstruct dc_link *link;\n\n\t\tif (enc->funcs->is_dig_enabled && !enc->funcs->is_dig_enabled(enc))\n\t\t\treturn;\n\n\t\tlink = link_enc_cfg_get_link_using_link_enc(enc->ctx->dc, enc->preferred_engine);\n\n\t\tdpia_control.action = (uint8_t)TRANSMITTER_CONTROL_DISABLE;\n\t\tdpia_control.enc_id = enc->preferred_engine;\n\t\tif (signal == SIGNAL_TYPE_DISPLAY_PORT) {\n\t\t\tdpia_control.mode_laneset.digmode = 0;  \n\t\t} else if (signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\t\tdpia_control.mode_laneset.digmode = 5;  \n\t\t} else {\n\t\t\tDC_LOG_ERROR(\"%s: USB4 DPIA only supports DisplayPort.\\n\", __func__);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\n\t\tif (link) {\n\t\t\tdpia_control.dpia_id = link->ddc_hw_inst;\n\t\t} else {\n\t\t\tDC_LOG_ERROR(\"%s: Failed to execute DPIA enable DMUB command.\\n\", __func__);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\n\t\tDC_LOG_DEBUG(\"%s: DPIA(%d) - enc_id(%d)\\n\", __func__, dpia_control.dpia_id, dpia_control.enc_id);\n\t\tlink_dpia_control(enc->ctx, &dpia_control);\n\n\t\tlink_encoder_disable(enc10);\n\t}\n}\n\nbool dcn31_link_encoder_is_in_alt_mode(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tunion dmub_rb_cmd cmd;\n\tuint32_t dp_alt_mode_disable;\n\n\t \n\tif (!enc->features.flags.bits.DP_IS_USB_C)\n\t\treturn false;\n\n\t \n\tif (has_query_dp_alt(enc)) {\n\t\tif (!query_dp_alt_from_dmub(enc, &cmd))\n\t\t\treturn false;\n\n\t\treturn (cmd.query_dp_alt.data.is_dp_alt_disable == 0);\n\t}\n\n\t \n\tif (enc->ctx->asic_id.hw_internal_rev != YELLOW_CARP_B0) {\n\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DISABLE,\n\t\t\t&dp_alt_mode_disable);\n\t} else {\n\t\t \n\t\tif ((enc10->base.transmitter == TRANSMITTER_UNIPHY_A) ||\n\t\t    (enc10->base.transmitter == TRANSMITTER_UNIPHY_B) ||\n\t\t    (enc10->base.transmitter == TRANSMITTER_UNIPHY_E)) {\n\t\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DISABLE,\n\t\t\t\t&dp_alt_mode_disable);\n\t\t} else {\n\t\t\tREG_GET(RDPCSPIPE_PHY_CNTL6, RDPCS_PHY_DPALT_DISABLE,\n\t\t\t\t&dp_alt_mode_disable);\n\t\t}\n\t}\n\n\treturn (dp_alt_mode_disable == 0);\n}\n\nvoid dcn31_link_encoder_get_max_link_cap(struct link_encoder *enc, struct dc_link_settings *link_settings)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tunion dmub_rb_cmd cmd;\n\tuint32_t is_in_usb_c_dp4_mode = 0;\n\n\tdcn10_link_encoder_get_max_link_cap(enc, link_settings);\n\n\t \n\tif (!enc->features.flags.bits.DP_IS_USB_C)\n\t\treturn;\n\n\t \n\tif (has_query_dp_alt(enc)) {\n\t\tif (!query_dp_alt_from_dmub(enc, &cmd))\n\t\t\treturn;\n\n\t\tif (cmd.query_dp_alt.data.is_usb &&\n\t\t    cmd.query_dp_alt.data.is_dp4 == 0)\n\t\t\tlink_settings->lane_count = MIN(LANE_COUNT_TWO, link_settings->lane_count);\n\n\t\treturn;\n\t}\n\n\t \n\tif (enc->ctx->asic_id.hw_internal_rev != YELLOW_CARP_B0) {\n\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DP4,\n\t\t\t&is_in_usb_c_dp4_mode);\n\t} else {\n\t\tif ((enc10->base.transmitter == TRANSMITTER_UNIPHY_A) ||\n\t\t    (enc10->base.transmitter == TRANSMITTER_UNIPHY_B) ||\n\t\t    (enc10->base.transmitter == TRANSMITTER_UNIPHY_E)) {\n\t\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DP4,\n\t\t\t\t&is_in_usb_c_dp4_mode);\n\t\t} else {\n\t\t\tREG_GET(RDPCSPIPE_PHY_CNTL6, RDPCS_PHY_DPALT_DP4,\n\t\t\t\t&is_in_usb_c_dp4_mode);\n\t\t}\n\t}\n\n\tif (!is_in_usb_c_dp4_mode)\n\t\tlink_settings->lane_count = MIN(LANE_COUNT_TWO, link_settings->lane_count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}