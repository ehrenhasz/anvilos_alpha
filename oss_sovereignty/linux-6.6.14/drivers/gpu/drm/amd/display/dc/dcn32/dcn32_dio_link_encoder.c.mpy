{
  "module_name": "dcn32_dio_link_encoder.c",
  "hash_id": "0d8fb2e42c97ac414864eb687a60704803fb72ce5d96eaab715a5d2cc4c93e58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dio_link_encoder.c",
  "human_readable_source": " \n\n\n#include \"reg_helper.h\"\n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dcn31/dcn31_dio_link_encoder.h\"\n#include \"dcn32_dio_link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"dc_bios_types.h\"\n#include \"link_enc_cfg.h\"\n\n#include \"gpio_service_interface.h\"\n\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\n#define CTX \\\n\tenc10->base.ctx\n#define DC_LOGGER \\\n\tenc10->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc10->link_regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc10->link_shift->field_name, enc10->link_mask->field_name\n\n#define AUX_REG(reg)\\\n\t(enc10->aux_regs->reg)\n\n#define AUX_REG_READ(reg_name) \\\n\t\tdm_read_reg(CTX, AUX_REG(reg_name))\n\n#define AUX_REG_WRITE(reg_name, val) \\\n\t\t\tdm_write_reg(CTX, AUX_REG(reg_name), val)\n\n\nvoid enc32_hw_init(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n \n\n \n\tAUX_REG_WRITE(AUX_DPHY_RX_CONTROL0, 0x103d1110);\n\n\tAUX_REG_WRITE(AUX_DPHY_TX_CONTROL, 0x21c7a);\n\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tREG_UPDATE(TMDS_CTL_BITS, TMDS_CTL0, 1);\n\n\tdcn10_aux_initialize(enc10);\n}\n\n\nvoid dcn32_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tif (!enc->ctx->dc->debug.avoid_vbios_exec_table) {\n\t\tdcn10_link_encoder_enable_dp_output(enc, link_settings, clock_source);\n\t\treturn;\n\t}\n}\n\nstatic bool dcn32_link_encoder_is_in_alt_mode(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t dp_alt_mode_disable = 0;\n\tbool is_usb_c_alt_mode = false;\n\n\tif (enc->features.flags.bits.DP_IS_USB_C) {\n\t\t \n\t\tREG_GET(RDPCSPIPE_PHY_CNTL6, RDPCS_PHY_DPALT_DISABLE, &dp_alt_mode_disable);\n\t\tis_usb_c_alt_mode = (dp_alt_mode_disable == 0);\n\t}\n\n\treturn is_usb_c_alt_mode;\n}\n\nstatic void dcn32_link_encoder_get_max_link_cap(struct link_encoder *enc,\n\tstruct dc_link_settings *link_settings)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t is_in_usb_c_dp4_mode = 0;\n\n\tdcn10_link_encoder_get_max_link_cap(enc, link_settings);\n\n\t \n\tif (enc->funcs->is_in_alt_mode && enc->funcs->is_in_alt_mode(enc)) {\n\t\tREG_GET(RDPCSPIPE_PHY_CNTL6, RDPCS_PHY_DPALT_DP4, &is_in_usb_c_dp4_mode);\n\t\tif (!is_in_usb_c_dp4_mode)\n\t\t\tlink_settings->lane_count = MIN(LANE_COUNT_TWO, link_settings->lane_count);\n\t}\n\n}\n\nstatic const struct link_encoder_funcs dcn32_link_enc_funcs = {\n\t.read_state = link_enc2_read_state,\n\t.validate_output_with_stream =\n\t\t\tdcn30_link_encoder_validate_output_with_stream,\n\t.hw_init = enc32_hw_init,\n\t.setup = dcn10_link_encoder_setup,\n\t.enable_tmds_output = dcn10_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dcn32_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dcn10_link_encoder_enable_dp_mst_output,\n\t.disable_output = dcn10_link_encoder_disable_output,\n\t.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdcn10_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdcn10_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dcn10_link_encoder_enable_hpd,\n\t.disable_hpd = dcn10_link_encoder_disable_hpd,\n\t.is_dig_enabled = dcn10_is_dig_enabled,\n\t.destroy = dcn10_link_encoder_destroy,\n\t.fec_set_enable = enc2_fec_set_enable,\n\t.fec_set_ready = enc2_fec_set_ready,\n\t.fec_is_active = enc2_fec_is_active,\n\t.get_dig_frontend = dcn10_get_dig_frontend,\n\t.get_dig_mode = dcn10_get_dig_mode,\n\t.is_in_alt_mode = dcn32_link_encoder_is_in_alt_mode,\n\t.get_max_link_cap = dcn32_link_encoder_get_max_link_cap,\n\t.set_dio_phy_mux = dcn31_link_encoder_set_dio_phy_mux,\n};\n\nvoid dcn32_link_encoder_construct(\n\tstruct dcn20_link_encoder *enc20,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tconst struct dcn10_link_enc_aux_registers *aux_regs,\n\tconst struct dcn10_link_enc_hpd_registers *hpd_regs,\n\tconst struct dcn10_link_enc_shift *link_shift,\n\tconst struct dcn10_link_enc_mask *link_mask)\n{\n\tstruct bp_connector_speed_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct dcn10_link_encoder *enc10 = &enc20->enc10;\n\n\tenc10->base.funcs = &dcn32_link_enc_funcs;\n\tenc10->base.ctx = init_data->ctx;\n\tenc10->base.id = init_data->encoder;\n\n\tenc10->base.hpd_source = init_data->hpd_source;\n\tenc10->base.connector = init_data->connector;\n\n\tif (enc10->base.connector.id == CONNECTOR_ID_USBC)\n\t\tenc10->base.features.flags.bits.DP_IS_USB_C = 1;\n\n\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc10->base.features = *enc_features;\n\n\tenc10->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\tenc10->link_regs = link_regs;\n\tenc10->aux_regs = aux_regs;\n\tenc10->hpd_regs = hpd_regs;\n\tenc10->link_shift = link_shift;\n\tenc10->link_mask = link_mask;\n\n\tswitch (enc10->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc10->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tif (bp_funcs->get_connector_speed_cap_info)\n\t\tresult = bp_funcs->get_connector_speed_cap_info(enc10->base.ctx->dc_bios,\n\t\t\t\t\t\tenc10->base.connector, &bp_cap_info);\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tenc10->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc10->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t\tenc10->base.features.flags.bits.IS_DP2_CAPABLE = 1;\n\t\tenc10->base.features.flags.bits.IS_UHBR10_CAPABLE = bp_cap_info.DP_UHBR10_EN;\n\t\tenc10->base.features.flags.bits.IS_UHBR13_5_CAPABLE = bp_cap_info.DP_UHBR13_5_EN;\n\t\tenc10->base.features.flags.bits.IS_UHBR20_CAPABLE = bp_cap_info.DP_UHBR20_EN;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}