{
  "module_name": "dcn10_mpc.c",
  "hash_id": "270fdd8bc72b6325cc8f92869f03f390e867ed7fd615c22a5007b32994fce089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"dcn10_mpc.h\"\n\n#define REG(reg)\\\n\tmpc10->mpc_regs->reg\n\n#define CTX \\\n\tmpc10->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tmpc10->mpc_shift->field_name, mpc10->mpc_mask->field_name\n\n\nvoid mpc1_set_bg_color(struct mpc *mpc,\n\t\tstruct tg_color *bg_color,\n\t\tint mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tstruct mpcc *bottommost_mpcc = mpc1_get_mpcc(mpc, mpcc_id);\n\tuint32_t bg_r_cr, bg_g_y, bg_b_cb;\n\n\tbottommost_mpcc->blnd_cfg.black_color = *bg_color;\n\n\t \n\twhile (bottommost_mpcc->mpcc_bot) {\n\t\t \n\t\tASSERT(bottommost_mpcc != bottommost_mpcc->mpcc_bot);\n\t\tif (bottommost_mpcc == bottommost_mpcc->mpcc_bot)\n\t\t\tbreak;\n\n\t\tbottommost_mpcc = bottommost_mpcc->mpcc_bot;\n\t}\n\n\t \n\t \n\tbg_r_cr = bg_color->color_r_cr << 2;\n\tbg_g_y = bg_color->color_g_y << 2;\n\tbg_b_cb = bg_color->color_b_cb << 2;\n\n\tREG_SET(MPCC_BG_R_CR[bottommost_mpcc->mpcc_id], 0,\n\t\t\tMPCC_BG_R_CR, bg_r_cr);\n\tREG_SET(MPCC_BG_G_Y[bottommost_mpcc->mpcc_id], 0,\n\t\t\tMPCC_BG_G_Y, bg_g_y);\n\tREG_SET(MPCC_BG_B_CB[bottommost_mpcc->mpcc_id], 0,\n\t\t\tMPCC_BG_B_CB, bg_b_cb);\n}\n\nstatic void mpc1_update_blending(\n\tstruct mpc *mpc,\n\tstruct mpcc_blnd_cfg *blnd_cfg,\n\tint mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tstruct mpcc *mpcc = mpc1_get_mpcc(mpc, mpcc_id);\n\n\tREG_UPDATE_5(MPCC_CONTROL[mpcc_id],\n\t\t\tMPCC_ALPHA_BLND_MODE,\t\tblnd_cfg->alpha_mode,\n\t\t\tMPCC_ALPHA_MULTIPLIED_MODE,\tblnd_cfg->pre_multiplied_alpha,\n\t\t\tMPCC_BLND_ACTIVE_OVERLAP_ONLY,\tblnd_cfg->overlap_only,\n\t\t\tMPCC_GLOBAL_ALPHA,\t\tblnd_cfg->global_alpha,\n\t\t\tMPCC_GLOBAL_GAIN,\t\tblnd_cfg->global_gain);\n\n\tmpcc->blnd_cfg = *blnd_cfg;\n}\n\nvoid mpc1_update_stereo_mix(\n\tstruct mpc *mpc,\n\tstruct mpcc_sm_cfg *sm_cfg,\n\tint mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\n\tREG_UPDATE_6(MPCC_SM_CONTROL[mpcc_id],\n\t\t\tMPCC_SM_EN,\t\t\tsm_cfg->enable,\n\t\t\tMPCC_SM_MODE,\t\t\tsm_cfg->sm_mode,\n\t\t\tMPCC_SM_FRAME_ALT,\t\tsm_cfg->frame_alt,\n\t\t\tMPCC_SM_FIELD_ALT,\t\tsm_cfg->field_alt,\n\t\t\tMPCC_SM_FORCE_NEXT_FRAME_POL,\tsm_cfg->force_next_frame_porlarity,\n\t\t\tMPCC_SM_FORCE_NEXT_TOP_POL,\tsm_cfg->force_next_field_polarity);\n}\nvoid mpc1_assert_idle_mpcc(struct mpc *mpc, int id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\n\tASSERT(!(mpc10->mpcc_in_use_mask & 1 << id));\n\tREG_WAIT(MPCC_STATUS[id],\n\t\t\tMPCC_IDLE, 1,\n\t\t\t1, 100000);\n}\n\nstruct mpcc *mpc1_get_mpcc(struct mpc *mpc, int mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\n\tASSERT(mpcc_id < mpc10->num_mpcc);\n\treturn &(mpc->mpcc_array[mpcc_id]);\n}\n\nstruct mpcc *mpc1_get_mpcc_for_dpp(struct mpc_tree *tree, int dpp_id)\n{\n\tstruct mpcc *tmp_mpcc = tree->opp_list;\n\n\twhile (tmp_mpcc != NULL) {\n\t\tif (tmp_mpcc->dpp_id == dpp_id)\n\t\t\treturn tmp_mpcc;\n\n\t\t \n\t\tASSERT(tmp_mpcc != tmp_mpcc->mpcc_bot);\n\t\tif (tmp_mpcc == tmp_mpcc->mpcc_bot)\n\t\t\tbreak;\n\n\t\ttmp_mpcc = tmp_mpcc->mpcc_bot;\n\t}\n\treturn NULL;\n}\n\nbool mpc1_is_mpcc_idle(struct mpc *mpc, int mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tunsigned int top_sel;\n\tunsigned int opp_id;\n\tunsigned int idle;\n\n\tREG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);\n\tREG_GET(MPCC_OPP_ID[mpcc_id],  MPCC_OPP_ID, &opp_id);\n\tREG_GET(MPCC_STATUS[mpcc_id],  MPCC_IDLE,   &idle);\n\tif (top_sel == 0xf && opp_id == 0xf && idle)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid mpc1_assert_mpcc_idle_before_connect(struct mpc *mpc, int mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tunsigned int top_sel, mpc_busy, mpc_idle;\n\n\tREG_GET(MPCC_TOP_SEL[mpcc_id],\n\t\t\tMPCC_TOP_SEL, &top_sel);\n\n\tif (top_sel == 0xf) {\n\t\tREG_GET_2(MPCC_STATUS[mpcc_id],\n\t\t\t\tMPCC_BUSY, &mpc_busy,\n\t\t\t\tMPCC_IDLE, &mpc_idle);\n\n\t\tASSERT(mpc_busy == 0);\n\t\tASSERT(mpc_idle == 1);\n\t}\n}\n\n \nstruct mpcc *mpc1_insert_plane(\n\tstruct mpc *mpc,\n\tstruct mpc_tree *tree,\n\tstruct mpcc_blnd_cfg *blnd_cfg,\n\tstruct mpcc_sm_cfg *sm_cfg,\n\tstruct mpcc *insert_above_mpcc,\n\tint dpp_id,\n\tint mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tstruct mpcc *new_mpcc = NULL;\n\n\t \n\tASSERT(mpcc_id < mpc10->num_mpcc);\n\tASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));\n\n\tif (insert_above_mpcc) {\n\t\t \n\t\tstruct mpcc *temp_mpcc = tree->opp_list;\n\n\t\tif (temp_mpcc != insert_above_mpcc)\n\t\t\twhile (temp_mpcc && temp_mpcc->mpcc_bot != insert_above_mpcc)\n\t\t\t\ttemp_mpcc = temp_mpcc->mpcc_bot;\n\t\tif (temp_mpcc == NULL)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tnew_mpcc = mpc1_get_mpcc(mpc, mpcc_id);\n\tnew_mpcc->dpp_id = dpp_id;\n\n\t \n\tif (insert_above_mpcc) {\n\t\tnew_mpcc->mpcc_bot = insert_above_mpcc;\n\t\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, insert_above_mpcc->mpcc_id);\n\t\tREG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_BOT_BLENDING);\n\t} else {\n\t\tnew_mpcc->mpcc_bot = NULL;\n\t\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);\n\t\tREG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_ONLY);\n\t}\n\tREG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, dpp_id);\n\tREG_SET(MPCC_OPP_ID[mpcc_id], 0, MPCC_OPP_ID, tree->opp_id);\n\n\t \n\tREG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, tree->opp_id);\n\n\t \n\tif (tree->opp_list == insert_above_mpcc) {\n\t\t \n\t\ttree->opp_list = new_mpcc;\n\t\tREG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, mpcc_id);\n\t} else {\n\t\t \n\t\tstruct mpcc *temp_mpcc = tree->opp_list;\n\n\t\twhile (temp_mpcc && temp_mpcc->mpcc_bot != insert_above_mpcc)\n\t\t\ttemp_mpcc = temp_mpcc->mpcc_bot;\n\t\tif (temp_mpcc && temp_mpcc->mpcc_bot == insert_above_mpcc) {\n\t\t\tREG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0, MPCC_BOT_SEL, mpcc_id);\n\t\t\ttemp_mpcc->mpcc_bot = new_mpcc;\n\t\t\tif (!insert_above_mpcc)\n\t\t\t\tREG_UPDATE(MPCC_CONTROL[temp_mpcc->mpcc_id],\n\t\t\t\t\t\tMPCC_MODE, MPCC_BLEND_MODE_TOP_BOT_BLENDING);\n\t\t}\n\t}\n\n\t \n\tmpc->funcs->update_blending(mpc, blnd_cfg, mpcc_id);\n\n\t \n\tif (sm_cfg != NULL) {\n\t\tnew_mpcc->sm_cfg = *sm_cfg;\n\t\tmpc1_update_stereo_mix(mpc, sm_cfg, mpcc_id);\n\t}\n\n\t \n\tmpc10->mpcc_in_use_mask |= 1 << mpcc_id;\n\n\treturn new_mpcc;\n}\n\n \nvoid mpc1_remove_mpcc(\n\tstruct mpc *mpc,\n\tstruct mpc_tree *tree,\n\tstruct mpcc *mpcc_to_remove)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tbool found = false;\n\tint mpcc_id = mpcc_to_remove->mpcc_id;\n\n\tif (tree->opp_list == mpcc_to_remove) {\n\t\tfound = true;\n\t\t \n\t\tif (mpcc_to_remove->mpcc_bot) {\n\t\t\t \n\t\t\ttree->opp_list = mpcc_to_remove->mpcc_bot;\n\t\t\tREG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, tree->opp_list->mpcc_id);\n\t\t} else {\n\t\t\t \n\t\t\ttree->opp_list = NULL;\n\t\t\tREG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, 0xf);\n\t\t}\n\t} else {\n\t\t \n\t\tstruct mpcc *temp_mpcc = tree->opp_list;\n\n\t\twhile (temp_mpcc && temp_mpcc->mpcc_bot != mpcc_to_remove)\n\t\t\ttemp_mpcc = temp_mpcc->mpcc_bot;\n\n\t\tif (temp_mpcc && temp_mpcc->mpcc_bot == mpcc_to_remove) {\n\t\t\tfound = true;\n\t\t\ttemp_mpcc->mpcc_bot = mpcc_to_remove->mpcc_bot;\n\t\t\tif (mpcc_to_remove->mpcc_bot) {\n\t\t\t\t \n\t\t\t\tREG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,\n\t\t\t\t\t\tMPCC_BOT_SEL, mpcc_to_remove->mpcc_bot->mpcc_id);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tREG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,\n\t\t\t\t\t\tMPCC_BOT_SEL, 0xf);\n\t\t\t\tREG_UPDATE(MPCC_CONTROL[temp_mpcc->mpcc_id],\n\t\t\t\t\t\tMPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_PASSTHROUGH);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found) {\n\t\t \n\t\tREG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);\n\t\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);\n\t\tREG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);\n\t\tREG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);\n\n\t\t \n\t\tmpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);\n\t\tmpcc_to_remove->dpp_id = 0xf;\n\t\tmpcc_to_remove->mpcc_bot = NULL;\n\t} else {\n\t\t \n\t\tREG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);\n\t\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);\n\t\tREG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);\n\t\tREG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);\n\t}\n}\n\nstatic void mpc1_init_mpcc(struct mpcc *mpcc, int mpcc_inst)\n{\n\tmpcc->mpcc_id = mpcc_inst;\n\tmpcc->dpp_id = 0xf;\n\tmpcc->mpcc_bot = NULL;\n\tmpcc->blnd_cfg.overlap_only = false;\n\tmpcc->blnd_cfg.global_alpha = 0xff;\n\tmpcc->blnd_cfg.global_gain = 0xff;\n\tmpcc->sm_cfg.enable = false;\n}\n\n \nvoid mpc1_mpc_init(struct mpc *mpc)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tint mpcc_id;\n\tint opp_id;\n\n\tmpc10->mpcc_in_use_mask = 0;\n\tfor (mpcc_id = 0; mpcc_id < mpc10->num_mpcc; mpcc_id++) {\n\t\tREG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);\n\t\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);\n\t\tREG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);\n\t\tREG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);\n\n\t\tmpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);\n\t}\n\n\tfor (opp_id = 0; opp_id < MAX_OPP; opp_id++) {\n\t\tif (REG(MUX[opp_id]))\n\t\t\tREG_UPDATE(MUX[opp_id], MPC_OUT_MUX, 0xf);\n\t}\n}\n\nvoid mpc1_mpc_init_single_inst(struct mpc *mpc, unsigned int mpcc_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tint opp_id;\n\n\tREG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);\n\n\tREG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);\n\tREG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);\n\tREG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);\n\tREG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);\n\n\tmpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);\n\n\tif (opp_id < MAX_OPP && REG(MUX[opp_id]))\n\t\tREG_UPDATE(MUX[opp_id], MPC_OUT_MUX, 0xf);\n}\n\n\nvoid mpc1_init_mpcc_list_from_hw(\n\tstruct mpc *mpc,\n\tstruct mpc_tree *tree)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tunsigned int opp_id;\n\tunsigned int top_sel;\n\tunsigned int bot_sel;\n\tunsigned int out_mux;\n\tstruct mpcc *mpcc;\n\tint mpcc_id;\n\tint bot_mpcc_id;\n\n\tREG_GET(MUX[tree->opp_id], MPC_OUT_MUX, &out_mux);\n\n\tif (out_mux != 0xf) {\n\t\tfor (mpcc_id = 0; mpcc_id < mpc10->num_mpcc; mpcc_id++) {\n\t\t\tREG_GET(MPCC_OPP_ID[mpcc_id],  MPCC_OPP_ID,  &opp_id);\n\t\t\tREG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);\n\t\t\tREG_GET(MPCC_BOT_SEL[mpcc_id],  MPCC_BOT_SEL, &bot_sel);\n\n\t\t\tif (bot_sel == mpcc_id)\n\t\t\t\tbot_sel = 0xf;\n\n\t\t\tif ((opp_id == tree->opp_id) && (top_sel != 0xf)) {\n\t\t\t\tmpcc = mpc1_get_mpcc(mpc, mpcc_id);\n\t\t\t\tmpcc->dpp_id = top_sel;\n\t\t\t\tmpc10->mpcc_in_use_mask |= 1 << mpcc_id;\n\n\t\t\t\tif (out_mux == mpcc_id)\n\t\t\t\t\ttree->opp_list = mpcc;\n\t\t\t\tif (bot_sel != 0xf && bot_sel < mpc10->num_mpcc) {\n\t\t\t\t\tbot_mpcc_id = bot_sel;\n\t\t\t\t\tREG_GET(MPCC_OPP_ID[bot_mpcc_id],  MPCC_OPP_ID,  &opp_id);\n\t\t\t\t\tREG_GET(MPCC_TOP_SEL[bot_mpcc_id], MPCC_TOP_SEL, &top_sel);\n\t\t\t\t\tif ((opp_id == tree->opp_id) && (top_sel != 0xf)) {\n\t\t\t\t\t\tstruct mpcc *mpcc_bottom = mpc1_get_mpcc(mpc, bot_mpcc_id);\n\n\t\t\t\t\t\tmpcc->mpcc_bot = mpcc_bottom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mpc1_read_mpcc_state(\n\t\tstruct mpc *mpc,\n\t\tint mpcc_inst,\n\t\tstruct mpcc_state *s)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\n\tREG_GET(MPCC_OPP_ID[mpcc_inst], MPCC_OPP_ID, &s->opp_id);\n\tREG_GET(MPCC_TOP_SEL[mpcc_inst], MPCC_TOP_SEL, &s->dpp_id);\n\tREG_GET(MPCC_BOT_SEL[mpcc_inst], MPCC_BOT_SEL, &s->bot_mpcc_id);\n\tREG_GET_4(MPCC_CONTROL[mpcc_inst], MPCC_MODE, &s->mode,\n\t\t\tMPCC_ALPHA_BLND_MODE, &s->alpha_mode,\n\t\t\tMPCC_ALPHA_MULTIPLIED_MODE, &s->pre_multiplied_alpha,\n\t\t\tMPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->overlap_only);\n\tREG_GET_2(MPCC_STATUS[mpcc_inst], MPCC_IDLE, &s->idle,\n\t\t\tMPCC_BUSY, &s->busy);\n}\n\nvoid mpc1_cursor_lock(struct mpc *mpc, int opp_id, bool lock)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\n\tREG_SET(CUR[opp_id], 0, CUR_VUPDATE_LOCK_SET, lock ? 1 : 0);\n}\n\nunsigned int mpc1_get_mpc_out_mux(struct mpc *mpc, int opp_id)\n{\n\tstruct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);\n\tuint32_t val = 0xf;\n\n\tif (opp_id < MAX_OPP && REG(MUX[opp_id]))\n\t\tREG_GET(MUX[opp_id], MPC_OUT_MUX, &val);\n\n\treturn val;\n}\n\nstatic const struct mpc_funcs dcn10_mpc_funcs = {\n\t.read_mpcc_state = mpc1_read_mpcc_state,\n\t.insert_plane = mpc1_insert_plane,\n\t.remove_mpcc = mpc1_remove_mpcc,\n\t.mpc_init = mpc1_mpc_init,\n\t.mpc_init_single_inst = mpc1_mpc_init_single_inst,\n\t.get_mpcc_for_dpp = mpc1_get_mpcc_for_dpp,\n\t.wait_for_idle = mpc1_assert_idle_mpcc,\n\t.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,\n\t.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,\n\t.update_blending = mpc1_update_blending,\n\t.cursor_lock = mpc1_cursor_lock,\n\t.set_denorm = NULL,\n\t.set_denorm_clamp = NULL,\n\t.set_output_csc = NULL,\n\t.set_output_gamma = NULL,\n\t.get_mpc_out_mux = mpc1_get_mpc_out_mux,\n\t.set_bg_color = mpc1_set_bg_color,\n};\n\nvoid dcn10_mpc_construct(struct dcn10_mpc *mpc10,\n\tstruct dc_context *ctx,\n\tconst struct dcn_mpc_registers *mpc_regs,\n\tconst struct dcn_mpc_shift *mpc_shift,\n\tconst struct dcn_mpc_mask *mpc_mask,\n\tint num_mpcc)\n{\n\tint i;\n\n\tmpc10->base.ctx = ctx;\n\n\tmpc10->base.funcs = &dcn10_mpc_funcs;\n\n\tmpc10->mpc_regs = mpc_regs;\n\tmpc10->mpc_shift = mpc_shift;\n\tmpc10->mpc_mask = mpc_mask;\n\n\tmpc10->mpcc_in_use_mask = 0;\n\tmpc10->num_mpcc = num_mpcc;\n\n\tfor (i = 0; i < MAX_MPCC; i++)\n\t\tmpc1_init_mpcc(&mpc10->base.mpcc_array[i], i);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}