{
  "module_name": "dcn20_link_encoder.c",
  "hash_id": "ba74892a11d3f79c36e651a2886e35ec892beab08c3242da75f203225c9547a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dcn20_link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"dc_bios_types.h\"\n\n#include \"gpio_service_interface.h\"\n\n#define CTX \\\n\tenc10->base.ctx\n#define DC_LOGGER \\\n\tenc10->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc10->link_regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc10->link_shift->field_name, enc10->link_mask->field_name\n\n#define IND_REG(index) \\\n\t(enc10->link_regs->index)\n\n#ifndef MAX\n#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#endif\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\nstatic struct mpll_cfg dcn2_mpll_cfg[] = {\n\t\n\t{\n\t\t.hdmimode_enable = 1,\n\t\t.ref_range = 3,\n\t\t.ref_clk_mpllb_div = 2,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 226,\n\t\t.mpllb_fracn_en = 1,\n\t\t.mpllb_fracn_quot = 39321,\n\t\t.mpllb_fracn_rem = 3,\n\t\t.mpllb_fracn_den = 5,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 38221,\n\t\t.mpllb_ssc_stepsize = 49314,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 2,\n\t\t.tx_vboost_lvl = 4,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 2,\n\t\t.mpllb_ana_cp_int = 7,\n\t\t.mpllb_ana_cp_prop = 18,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 1,\n\t\t.ref_range = 3,\n\t\t.ref_clk_mpllb_div = 2,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 184,\n\t\t.mpllb_fracn_en = 0,\n\t\t.mpllb_fracn_quot = 0,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 31850,\n\t\t.mpllb_ssc_stepsize = 41095,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 1,\n\t\t.tx_vboost_lvl = 4,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 3,\n\t\t.mpllb_ana_cp_int = 7,\n\t\t.mpllb_ana_cp_prop = 18,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 1,\n\t\t.ref_range = 3,\n\t\t.ref_clk_mpllb_div = 2,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 184,\n\t\t.mpllb_fracn_en = 0,\n\t\t.mpllb_fracn_quot = 0,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 31850,\n\t\t.mpllb_ssc_stepsize = 41095,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 0,\n\t\t.tx_vboost_lvl = 4,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 3,\n\t\t.mpllb_ana_cp_int = 7,\n\t\t.mpllb_ana_cp_prop = 18,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 1,\n\t\t.ref_range = 3,\n\t\t.ref_clk_mpllb_div = 2,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 292,\n\t\t.mpllb_fracn_en = 0,\n\t\t.mpllb_fracn_quot = 0,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 47776,\n\t\t.mpllb_ssc_stepsize = 61642,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 0,\n\t\t.tx_vboost_lvl = 4,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 0,\n\t\t.mpllb_ana_cp_int = 7,\n\t\t.mpllb_ana_cp_prop = 18,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n};\n\nvoid enc2_fec_set_enable(struct link_encoder *enc, bool enable)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tDC_LOG_DSC(\"%s FEC at link encoder inst %d\",\n\t\t\tenable ? \"Enabling\" : \"Disabling\", enc->id.enum_id);\n\tREG_UPDATE(DP_DPHY_CNTL, DPHY_FEC_EN, enable);\n}\n\nvoid enc2_fec_set_ready(struct link_encoder *enc, bool ready)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tREG_UPDATE(DP_DPHY_CNTL, DPHY_FEC_READY_SHADOW, ready);\n}\n\nbool enc2_fec_is_active(struct link_encoder *enc)\n{\n\tuint32_t active = 0;\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tREG_GET(DP_DPHY_CNTL, DPHY_FEC_ACTIVE_STATUS, &active);\n\n\treturn (active != 0);\n}\n\n \nvoid link_enc2_read_state(struct link_encoder *enc, struct link_enc_state *s)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tREG_GET(DP_DPHY_CNTL, DPHY_FEC_EN, &s->dphy_fec_en);\n\tREG_GET(DP_DPHY_CNTL, DPHY_FEC_READY_SHADOW, &s->dphy_fec_ready_shadow);\n\tREG_GET(DP_DPHY_CNTL, DPHY_FEC_ACTIVE_STATUS, &s->dphy_fec_active_status);\n\tREG_GET(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, &s->dp_link_training_complete);\n}\n\nstatic bool update_cfg_data(\n\t\tstruct dcn10_link_encoder *enc10,\n\t\tconst struct dc_link_settings *link_settings,\n\t\tstruct dpcssys_phy_seq_cfg *cfg)\n{\n\tint i;\n\n\tcfg->load_sram_fw = false;\n\n\tfor (i = 0; i < link_settings->lane_count; i++)\n\t\tcfg->lane_en[i] = true;\n\n\tswitch (link_settings->link_rate) {\n\tcase LINK_RATE_LOW:\n\t\tcfg->mpll_cfg = dcn2_mpll_cfg[0];\n\t\tbreak;\n\tcase LINK_RATE_HIGH:\n\t\tcfg->mpll_cfg = dcn2_mpll_cfg[1];\n\t\tbreak;\n\tcase LINK_RATE_HIGH2:\n\t\tcfg->mpll_cfg = dcn2_mpll_cfg[2];\n\t\tbreak;\n\tcase LINK_RATE_HIGH3:\n\t\tcfg->mpll_cfg = dcn2_mpll_cfg[3];\n\t\tbreak;\n\tdefault:\n\t\tDC_LOG_ERROR(\"%s: No supported link rate found %X!\\n\",\n\t\t\t\t__func__, link_settings->link_rate);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid dcn20_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct dcn20_link_encoder *enc20 = (struct dcn20_link_encoder *) enc10;\n\tstruct dpcssys_phy_seq_cfg *cfg = &enc20->phy_seq_cfg;\n\n\tif (!enc->ctx->dc->debug.avoid_vbios_exec_table) {\n\t\tdcn10_link_encoder_enable_dp_output(enc, link_settings, clock_source);\n\t\treturn;\n\t}\n\n\tif (!update_cfg_data(enc10, link_settings, cfg))\n\t\treturn;\n\n\tenc1_configure_encoder(enc10, link_settings);\n\n\tdcn10_link_encoder_setup(enc, SIGNAL_TYPE_DISPLAY_PORT);\n\n}\n\nvoid dcn20_link_encoder_get_max_link_cap(struct link_encoder *enc,\n\tstruct dc_link_settings *link_settings)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t is_in_usb_c_dp4_mode = 0;\n\n\tdcn10_link_encoder_get_max_link_cap(enc, link_settings);\n\n\t \n\tif (enc->funcs->is_in_alt_mode && enc->funcs->is_in_alt_mode(enc)) {\n\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DP4, &is_in_usb_c_dp4_mode);\n\t\tif (!is_in_usb_c_dp4_mode)\n\t\t\tlink_settings->lane_count = MIN(LANE_COUNT_TWO, link_settings->lane_count);\n\t}\n\n}\n\nbool dcn20_link_encoder_is_in_alt_mode(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t dp_alt_mode_disable = 0;\n\tbool is_usb_c_alt_mode = false;\n\n\tif (enc->features.flags.bits.DP_IS_USB_C) {\n\t\t \n\t\tREG_GET(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DPALT_DISABLE, &dp_alt_mode_disable);\n\t\tis_usb_c_alt_mode = (dp_alt_mode_disable == 0);\n\t}\n\n\treturn is_usb_c_alt_mode;\n}\n\n#define AUX_REG(reg)\\\n\t(enc10->aux_regs->reg)\n\n#define AUX_REG_READ(reg_name) \\\n\t\tdm_read_reg(CTX, AUX_REG(reg_name))\n\n#define AUX_REG_WRITE(reg_name, val) \\\n\t\t\tdm_write_reg(CTX, AUX_REG(reg_name), val)\nvoid enc2_hw_init(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n \n\n \n\tif (enc->ctx->dc_bios->golden_table.dc_golden_table_ver > 0) {\n\t\tAUX_REG_WRITE(AUX_DPHY_RX_CONTROL0, enc->ctx->dc_bios->golden_table.aux_dphy_rx_control0_val);\n\n\t\tAUX_REG_WRITE(AUX_DPHY_TX_CONTROL, enc->ctx->dc_bios->golden_table.aux_dphy_tx_control_val);\n\n\t\tAUX_REG_WRITE(AUX_DPHY_RX_CONTROL1, enc->ctx->dc_bios->golden_table.aux_dphy_rx_control1_val);\n\t} else {\n\t\tAUX_REG_WRITE(AUX_DPHY_RX_CONTROL0, 0x103d1110);\n\n\t\tAUX_REG_WRITE(AUX_DPHY_TX_CONTROL, 0x21c7a);\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tREG_UPDATE(TMDS_CTL_BITS, TMDS_CTL0, 1);\n\n\tdcn10_aux_initialize(enc10);\n}\n\nstatic const struct link_encoder_funcs dcn20_link_enc_funcs = {\n\t.read_state = link_enc2_read_state,\n\t.validate_output_with_stream =\n\t\tdcn10_link_encoder_validate_output_with_stream,\n\t.hw_init = enc2_hw_init,\n\t.setup = dcn10_link_encoder_setup,\n\t.enable_tmds_output = dcn10_link_encoder_enable_tmds_output_with_clk_pattern_wa,\n\t.enable_dp_output = dcn20_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dcn10_link_encoder_enable_dp_mst_output,\n\t.disable_output = dcn10_link_encoder_disable_output,\n\t.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdcn10_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdcn10_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dcn10_link_encoder_enable_hpd,\n\t.disable_hpd = dcn10_link_encoder_disable_hpd,\n\t.is_dig_enabled = dcn10_is_dig_enabled,\n\t.destroy = dcn10_link_encoder_destroy,\n\t.fec_set_enable = enc2_fec_set_enable,\n\t.fec_set_ready = enc2_fec_set_ready,\n\t.fec_is_active = enc2_fec_is_active,\n\t.get_dig_mode = dcn10_get_dig_mode,\n\t.get_dig_frontend = dcn10_get_dig_frontend,\n\t.is_in_alt_mode = dcn20_link_encoder_is_in_alt_mode,\n\t.get_max_link_cap = dcn20_link_encoder_get_max_link_cap,\n};\n\nvoid dcn20_link_encoder_construct(\n\tstruct dcn20_link_encoder *enc20,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tconst struct dcn10_link_enc_aux_registers *aux_regs,\n\tconst struct dcn10_link_enc_hpd_registers *hpd_regs,\n\tconst struct dcn10_link_enc_shift *link_shift,\n\tconst struct dcn10_link_enc_mask *link_mask)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct dcn10_link_encoder *enc10 = &enc20->enc10;\n\n\tenc10->base.funcs = &dcn20_link_enc_funcs;\n\tenc10->base.ctx = init_data->ctx;\n\tenc10->base.id = init_data->encoder;\n\n\tenc10->base.hpd_source = init_data->hpd_source;\n\tenc10->base.connector = init_data->connector;\n\n\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc10->base.features = *enc_features;\n\n\tenc10->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc10->link_regs = link_regs;\n\tenc10->aux_regs = aux_regs;\n\tenc10->hpd_regs = hpd_regs;\n\tenc10->link_shift = link_shift;\n\tenc10->link_mask = link_mask;\n\n\tswitch (enc10->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGG;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc10->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc10->base.ctx->dc_bios,\n\t\t\t\t\t\tenc10->base.id, &bp_cap_info);\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tenc10->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc10->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t\tenc10->base.features.flags.bits.DP_IS_USB_C =\n\t\t\t\tbp_cap_info.DP_IS_USB_C;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}