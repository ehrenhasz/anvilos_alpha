{
  "module_name": "link_dpcd.c",
  "hash_id": "bd88f14c66c3b34b9601a848b25702efa0c1b0c27564cb09e42b8f838b60d093",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c",
  "human_readable_source": " \n\n \n\n#include \"link_dpcd.h\"\n#include <drm/display/drm_dp_helper.h>\n#include \"dm_helpers.h\"\n\n#define END_ADDRESS(start, size) (start + size - 1)\n#define ADDRESS_RANGE_SIZE(start, end) (end - start + 1)\nstruct dpcd_address_range {\n\tuint32_t start;\n\tuint32_t end;\n};\n\nstatic enum dc_status internal_link_read_dpcd(\n\tstruct dc_link *link,\n\tuint32_t address,\n\tuint8_t *data,\n\tuint32_t size)\n{\n\tif (!link->aux_access_disabled &&\n\t\t\t!dm_helpers_dp_read_dpcd(link->ctx,\n\t\t\tlink, address, data, size)) {\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status internal_link_write_dpcd(\n\tstruct dc_link *link,\n\tuint32_t address,\n\tconst uint8_t *data,\n\tuint32_t size)\n{\n\tif (!link->aux_access_disabled &&\n\t\t\t!dm_helpers_dp_write_dpcd(link->ctx,\n\t\t\tlink, address, data, size)) {\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\treturn DC_OK;\n}\n\n \nstatic const struct dpcd_address_range mandatory_dpcd_partitions[] = {\n\t{ 0, DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR1) - 1},\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR1), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR2) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR2), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR3) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR3), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR4) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR4), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR5) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR5), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR6) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR6), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR7) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR7), DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR8) - 1 },\n\t{ DP_TRAINING_PATTERN_SET_PHY_REPEATER(DP_PHY_LTTPR8), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR1) - 1 },\n\t \n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR1), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR1) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR2), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR2) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR3), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR3) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR4), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR4) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR5), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR5) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR6), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR6) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR7), DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR7) - 1 },\n\t{ DP_FEC_STATUS_PHY_REPEATER(DP_PHY_LTTPR8), DP_LTTPR_MAX_ADD },\n\t \n\t{ DP_LTTPR_MAX_ADD + 1, DP_DPCD_MAX_ADD } };\n\nstatic inline bool do_addresses_intersect_with_range(\n\t\tconst struct dpcd_address_range *range,\n\t\tconst uint32_t start_address,\n\t\tconst uint32_t end_address)\n{\n\treturn start_address <= range->end && end_address >= range->start;\n}\n\nstatic uint32_t dpcd_get_next_partition_size(const uint32_t address, const uint32_t size)\n{\n\tconst uint32_t end_address = END_ADDRESS(address, size);\n\tuint32_t partition_iterator = 0;\n\n\t \n\twhile (!do_addresses_intersect_with_range(&mandatory_dpcd_partitions[partition_iterator],\n\t\t\t\taddress, end_address))\n\t\tpartition_iterator++;\n\tif (end_address < mandatory_dpcd_partitions[partition_iterator].end)\n\t\treturn size;\n\treturn ADDRESS_RANGE_SIZE(address, mandatory_dpcd_partitions[partition_iterator].end);\n}\n\n \nstatic const struct dpcd_address_range mandatory_dpcd_blocks[] = {\n\t{ DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV, DP_PHY_REPEATER_EXTENDED_WAIT_TIMEOUT }};\n\n \nstatic void dpcd_extend_address_range(\n\t\tconst uint32_t in_address,\n\t\tuint8_t * const in_data,\n\t\tconst uint32_t in_size,\n\t\tuint32_t *out_address,\n\t\tuint8_t **out_data,\n\t\tuint32_t *out_size)\n{\n\tconst uint32_t end_address = END_ADDRESS(in_address, in_size);\n\tconst struct dpcd_address_range *addr_range;\n\tstruct dpcd_address_range new_addr_range;\n\tuint32_t i;\n\n\tnew_addr_range.start = in_address;\n\tnew_addr_range.end = end_address;\n\tfor (i = 0; i < ARRAY_SIZE(mandatory_dpcd_blocks); i++) {\n\t\taddr_range = &mandatory_dpcd_blocks[i];\n\t\tif (addr_range->start <= in_address && addr_range->end >= in_address)\n\t\t\tnew_addr_range.start = addr_range->start;\n\n\t\tif (addr_range->start <= end_address && addr_range->end >= end_address)\n\t\t\tnew_addr_range.end = addr_range->end;\n\t}\n\t*out_address = in_address;\n\t*out_size = in_size;\n\t*out_data = in_data;\n\tif (new_addr_range.start != in_address || new_addr_range.end != end_address) {\n\t\t*out_address = new_addr_range.start;\n\t\t*out_size = ADDRESS_RANGE_SIZE(new_addr_range.start, new_addr_range.end);\n\t\t*out_data = kzalloc(*out_size * sizeof(**out_data), GFP_KERNEL);\n\t}\n}\n\n \nstatic void dpcd_reduce_address_range(\n\t\tconst uint32_t extended_address,\n\t\tuint8_t * const extended_data,\n\t\tconst uint32_t extended_size,\n\t\tconst uint32_t reduced_address,\n\t\tuint8_t * const reduced_data,\n\t\tconst uint32_t reduced_size)\n{\n\tconst uint32_t offset = reduced_address - extended_address;\n\n\t \n\tif (extended_data == reduced_data)\n\t\treturn;\n\n\tmemcpy(&extended_data[offset], reduced_data, reduced_size);\n\tkfree(extended_data);\n}\n\nenum dc_status core_link_read_dpcd(\n\tstruct dc_link *link,\n\tuint32_t address,\n\tuint8_t *data,\n\tuint32_t size)\n{\n\tuint32_t extended_address;\n\tuint32_t partitioned_address;\n\tuint8_t *extended_data;\n\tuint32_t extended_size;\n\t \n\tuint32_t size_left_to_read;\n\tenum dc_status status;\n\t \n\tuint32_t partition_size;\n\tuint32_t data_index = 0;\n\n\tdpcd_extend_address_range(address, data, size, &extended_address, &extended_data, &extended_size);\n\tpartitioned_address = extended_address;\n\tsize_left_to_read = extended_size;\n\twhile (size_left_to_read) {\n\t\tpartition_size = dpcd_get_next_partition_size(partitioned_address, size_left_to_read);\n\t\tstatus = internal_link_read_dpcd(link, partitioned_address, &extended_data[data_index], partition_size);\n\t\tif (status != DC_OK)\n\t\t\tbreak;\n\t\tpartitioned_address += partition_size;\n\t\tdata_index += partition_size;\n\t\tsize_left_to_read -= partition_size;\n\t}\n\tdpcd_reduce_address_range(extended_address, extended_data, extended_size, address, data, size);\n\treturn status;\n}\n\nenum dc_status core_link_write_dpcd(\n\tstruct dc_link *link,\n\tuint32_t address,\n\tconst uint8_t *data,\n\tuint32_t size)\n{\n\tuint32_t partition_size;\n\tuint32_t data_index = 0;\n\tenum dc_status status;\n\n\twhile (size) {\n\t\tpartition_size = dpcd_get_next_partition_size(address, size);\n\t\tstatus = internal_link_write_dpcd(link, address, &data[data_index], partition_size);\n\t\tif (status != DC_OK)\n\t\t\tbreak;\n\t\taddress += partition_size;\n\t\tdata_index += partition_size;\n\t\tsize -= partition_size;\n\t}\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}