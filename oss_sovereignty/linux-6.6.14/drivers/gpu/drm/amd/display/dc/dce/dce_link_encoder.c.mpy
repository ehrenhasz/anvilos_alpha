{
  "module_name": "dce_link_encoder.c",
  "hash_id": "37b32cf1a23056efd17a57adc7b07aa4f8ab5980d2911884aa333cc8a8be9d56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dce_link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"dc_bios_types.h\"\n\n#include \"gpio_service_interface.h\"\n\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n#include \"dce/dce_11_0_enum.h\"\n\n#ifndef DMU_MEM_PWR_CNTL__DMCU_IRAM_MEM_PWR_STATE__SHIFT\n#define DMU_MEM_PWR_CNTL__DMCU_IRAM_MEM_PWR_STATE__SHIFT 0xa\n#endif\n\n#ifndef DMU_MEM_PWR_CNTL__DMCU_IRAM_MEM_PWR_STATE_MASK\n#define DMU_MEM_PWR_CNTL__DMCU_IRAM_MEM_PWR_STATE_MASK 0x00000400L\n#endif\n\n#ifndef HPD0_DC_HPD_CONTROL__DC_HPD_EN_MASK\n#define HPD0_DC_HPD_CONTROL__DC_HPD_EN_MASK  0x10000000L\n#endif\n\n#ifndef HPD0_DC_HPD_CONTROL__DC_HPD_EN__SHIFT\n#define HPD0_DC_HPD_CONTROL__DC_HPD_EN__SHIFT  0x1c\n#endif\n\n#define CTX \\\n\tenc110->base.ctx\n#define DC_LOGGER \\\n\tenc110->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc110->link_regs->reg)\n\n#define AUX_REG(reg)\\\n\t(enc110->aux_regs->reg)\n\n#define HPD_REG(reg)\\\n\t(enc110->hpd_regs->reg)\n\n#define DEFAULT_AUX_MAX_DATA_SIZE 16\n#define AUX_MAX_DEFER_WRITE_RETRY 20\n \n#define DCE110_DIG_FE_SOURCE_SELECT_INVALID 0x0\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGA 0x1\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGB 0x2\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGC 0x4\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGD 0x08\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGE 0x10\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGF 0x20\n#define DCE110_DIG_FE_SOURCE_SELECT_DIGG 0x40\n\nenum {\n\tDP_MST_UPDATE_MAX_RETRY = 50\n};\n\n#define DIG_REG(reg)\\\n\t(reg + enc110->offsets.dig)\n\n#define DP_REG(reg)\\\n\t(reg + enc110->offsets.dp)\n\nstatic const struct link_encoder_funcs dce110_lnk_enc_funcs = {\n\t.validate_output_with_stream =\n\t\tdce110_link_encoder_validate_output_with_stream,\n\t.hw_init = dce110_link_encoder_hw_init,\n\t.setup = dce110_link_encoder_setup,\n\t.enable_tmds_output = dce110_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dce110_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dce110_link_encoder_enable_dp_mst_output,\n\t.enable_lvds_output = dce110_link_encoder_enable_lvds_output,\n\t.disable_output = dce110_link_encoder_disable_output,\n\t.dp_set_lane_settings = dce110_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dce110_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdce110_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdce110_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dce110_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dce110_link_encoder_enable_hpd,\n\t.disable_hpd = dce110_link_encoder_disable_hpd,\n\t.is_dig_enabled = dce110_is_dig_enabled,\n\t.destroy = dce110_link_encoder_destroy,\n\t.get_max_link_cap = dce110_link_encoder_get_max_link_cap,\n\t.get_dig_frontend = dce110_get_dig_frontend,\n};\n\nstatic enum bp_result link_transmitter_control(\n\tstruct dce110_link_encoder *enc110,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result;\n\tstruct dc_bios *bp = enc110->base.ctx->dc_bios;\n\n\tresult = bp->funcs->transmitter_control(bp, cntl);\n\n\treturn result;\n}\n\nstatic void enable_phy_bypass_mode(\n\tstruct dce110_link_encoder *enc110,\n\tbool enable)\n{\n\t \n\n\tREG_UPDATE(DP_DPHY_CNTL, DPHY_BYPASS, enable);\n\n}\n\nstatic void disable_prbs_symbols(\n\tstruct dce110_link_encoder *enc110,\n\tbool disable)\n{\n\t \n\n\tREG_UPDATE_4(DP_DPHY_CNTL,\n\t\t\tDPHY_ATEST_SEL_LANE0, disable,\n\t\t\tDPHY_ATEST_SEL_LANE1, disable,\n\t\t\tDPHY_ATEST_SEL_LANE2, disable,\n\t\t\tDPHY_ATEST_SEL_LANE3, disable);\n}\n\nstatic void disable_prbs_mode(\n\tstruct dce110_link_encoder *enc110)\n{\n\tREG_UPDATE(DP_DPHY_PRBS_CNTL, DPHY_PRBS_EN, 0);\n}\n\nstatic void program_pattern_symbols(\n\tstruct dce110_link_encoder *enc110,\n\tuint16_t pattern_symbols[8])\n{\n\t \n\n\tREG_SET_3(DP_DPHY_SYM0, 0,\n\t\t\tDPHY_SYM1, pattern_symbols[0],\n\t\t\tDPHY_SYM2, pattern_symbols[1],\n\t\t\tDPHY_SYM3, pattern_symbols[2]);\n\n\t \n\n\tREG_SET_3(DP_DPHY_SYM1, 0,\n\t\t\tDPHY_SYM4, pattern_symbols[3],\n\t\t\tDPHY_SYM5, pattern_symbols[4],\n\t\t\tDPHY_SYM6, pattern_symbols[5]);\n\n\t \n\n\tREG_SET_2(DP_DPHY_SYM2, 0,\n\t\t\tDPHY_SYM7, pattern_symbols[6],\n\t\t\tDPHY_SYM8, pattern_symbols[7]);\n}\n\nstatic void set_dp_phy_pattern_d102(\n\tstruct dce110_link_encoder *enc110)\n{\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\n\t \n\n\tdisable_prbs_symbols(enc110, true);\n\n\t \n\tdisable_prbs_mode(enc110);\n\n\t \n\t{\n\t\tuint16_t pattern_symbols[8] = {\n\t\t\t0x2AA, 0x2AA, 0x2AA, 0x2AA,\n\t\t\t0x2AA, 0x2AA, 0x2AA, 0x2AA\n\t\t};\n\n\t\tprogram_pattern_symbols(enc110, pattern_symbols);\n\t}\n\n\t \n\n\tenable_phy_bypass_mode(enc110, true);\n}\n\nstatic void set_link_training_complete(\n\tstruct dce110_link_encoder *enc110,\n\tbool complete)\n{\n\t \n\n\tREG_UPDATE(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, complete);\n\n}\n\nunsigned int dce110_get_dig_frontend(struct link_encoder *enc)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tu32 value;\n\tenum engine_id result;\n\n\tREG_GET(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, &value);\n\n\tswitch (value) {\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGA:\n\t\tresult = ENGINE_ID_DIGA;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGB:\n\t\tresult = ENGINE_ID_DIGB;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGC:\n\t\tresult = ENGINE_ID_DIGC;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGD:\n\t\tresult = ENGINE_ID_DIGD;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGE:\n\t\tresult = ENGINE_ID_DIGE;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGF:\n\t\tresult = ENGINE_ID_DIGF;\n\t\tbreak;\n\tcase DCE110_DIG_FE_SOURCE_SELECT_DIGG:\n\t\tresult = ENGINE_ID_DIGG;\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tresult = ENGINE_ID_UNKNOWN;\n\t}\n\n\treturn result;\n}\n\nvoid dce110_link_encoder_set_dp_phy_pattern_training_pattern(\n\tstruct link_encoder *enc,\n\tuint32_t index)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\t \n\n\tREG_WRITE(DP_DPHY_TRAINING_PATTERN_SEL, index);\n\n\t \n\n\tset_link_training_complete(enc110, false);\n\n\t \n\n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tdisable_prbs_mode(enc110);\n}\n\nstatic void setup_panel_mode(\n\tstruct dce110_link_encoder *enc110,\n\tenum dp_panel_mode panel_mode)\n{\n\tuint32_t value;\n\tstruct dc_context *ctx = enc110->base.ctx;\n\n\t \n\tif (ctx->dc->caps.psp_setup_panel_mode)\n\t\treturn;\n\n\tASSERT(REG(DP_DPHY_INTERNAL_CTRL));\n\tvalue = REG_READ(DP_DPHY_INTERNAL_CTRL);\n\n\tswitch (panel_mode) {\n\tcase DP_PANEL_MODE_EDP:\n\t\tvalue = 0x1;\n\t\tbreak;\n\tcase DP_PANEL_MODE_SPECIAL:\n\t\tvalue = 0x11;\n\t\tbreak;\n\tdefault:\n\t\tvalue = 0x0;\n\t\tbreak;\n\t}\n\n\tREG_WRITE(DP_DPHY_INTERNAL_CTRL, value);\n}\n\nstatic void set_dp_phy_pattern_symbol_error(\n\tstruct dce110_link_encoder *enc110)\n{\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tsetup_panel_mode(enc110, DP_PANEL_MODE_DEFAULT);\n\n\t \n\n\t \n\tdisable_prbs_symbols(enc110, false);\n\n\t \n\tREG_UPDATE_2(DP_DPHY_PRBS_CNTL,\n\t\t\tDPHY_PRBS_SEL, 1,\n\t\t\tDPHY_PRBS_EN, 1);\n\n\t \n\tenable_phy_bypass_mode(enc110, true);\n}\n\nstatic void set_dp_phy_pattern_prbs7(\n\tstruct dce110_link_encoder *enc110)\n{\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\n\t \n\tdisable_prbs_symbols(enc110, false);\n\n\t \n\tREG_UPDATE_2(DP_DPHY_PRBS_CNTL,\n\t\t\tDPHY_PRBS_SEL, 0,\n\t\t\tDPHY_PRBS_EN, 1);\n\n\t \n\tenable_phy_bypass_mode(enc110, true);\n}\n\nstatic void set_dp_phy_pattern_80bit_custom(\n\tstruct dce110_link_encoder *enc110,\n\tconst uint8_t *pattern)\n{\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\n\tdisable_prbs_symbols(enc110, true);\n\n\t \n\t \n\n\tenable_phy_bypass_mode(enc110, true);\n\n\t \n\t{\n\t\tuint16_t pattern_symbols[8];\n\n\t\tpattern_symbols[0] =\n\t\t\t((pattern[1] & 0x03) << 8) | pattern[0];\n\t\tpattern_symbols[1] =\n\t\t\t((pattern[2] & 0x0f) << 6) | ((pattern[1] >> 2) & 0x3f);\n\t\tpattern_symbols[2] =\n\t\t\t((pattern[3] & 0x3f) << 4) | ((pattern[2] >> 4) & 0x0f);\n\t\tpattern_symbols[3] =\n\t\t\t(pattern[4] << 2) | ((pattern[3] >> 6) & 0x03);\n\t\tpattern_symbols[4] =\n\t\t\t((pattern[6] & 0x03) << 8) | pattern[5];\n\t\tpattern_symbols[5] =\n\t\t\t((pattern[7] & 0x0f) << 6) | ((pattern[6] >> 2) & 0x3f);\n\t\tpattern_symbols[6] =\n\t\t\t((pattern[8] & 0x3f) << 4) | ((pattern[7] >> 4) & 0x0f);\n\t\tpattern_symbols[7] =\n\t\t\t(pattern[9] << 2) | ((pattern[8] >> 6) & 0x03);\n\n\t\tprogram_pattern_symbols(enc110, pattern_symbols);\n\t}\n\n\t \n\n\tenable_phy_bypass_mode(enc110, true);\n}\n\nstatic void set_dp_phy_pattern_hbr2_compliance_cp2520_2(\n\tstruct dce110_link_encoder *enc110,\n\tunsigned int cp2520_pattern)\n{\n\n\t \n\n\t \n\n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tenc110->base.funcs->setup(&enc110->base, SIGNAL_TYPE_DISPLAY_PORT);\n\n\t \n\tsetup_panel_mode(enc110, DP_PANEL_MODE_DEFAULT);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0xFC,\n\t\t\tDP_VBID_DISABLE, 1,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\t \n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_BS_COUNT, 0);\n\n\t \n\tif (REG(DP_DPHY_HBR2_PATTERN_CONTROL))\n\t\tREG_UPDATE(DP_DPHY_HBR2_PATTERN_CONTROL,\n\t\t\t\tDP_DPHY_HBR2_PATTERN_CONTROL, cp2520_pattern);\n\telse\n\t\t \n\t\tASSERT(cp2520_pattern == 2);\n\n\t \n\tset_link_training_complete(enc110, true);\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, 0);\n\n\t \n\tenable_phy_bypass_mode(enc110, false);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_set_dp_phy_pattern_hbr2_compliance_cp2520_2(\n\tstruct dce110_link_encoder *enc110,\n\tunsigned int cp2520_pattern)\n{\n\n\t \n\n\t \n\n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tenc110->base.funcs->setup(&enc110->base, SIGNAL_TYPE_DISPLAY_PORT);\n\n\t \n\tsetup_panel_mode(enc110, DP_PANEL_MODE_DEFAULT);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0xFC,\n\t\t\tDP_VBID_DISABLE, 1,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\t \n\n\t \n\tif (REG(DP_DPHY_HBR2_PATTERN_CONTROL))\n\t\tREG_UPDATE(DP_DPHY_HBR2_PATTERN_CONTROL,\n\t\t\t\tDP_DPHY_HBR2_PATTERN_CONTROL, cp2520_pattern);\n\telse\n\t\t \n\t\tASSERT(cp2520_pattern == 2);\n\n\t \n\tset_link_training_complete(enc110, true);\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, 0);\n\n\t \n\tenable_phy_bypass_mode(enc110, false);\n}\n#endif\n\nstatic void set_dp_phy_pattern_passthrough_mode(\n\tstruct dce110_link_encoder *enc110,\n\tenum dp_panel_mode panel_mode)\n{\n\t \n\tsetup_panel_mode(enc110, panel_mode);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0x2000,\n\t\t\tDP_VBID_DISABLE, 0,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_BS_COUNT, 0x1FF);\n\n\t \n\tset_link_training_complete(enc110, true);\n\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tdisable_prbs_mode(enc110);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_set_dp_phy_pattern_passthrough_mode(\n\tstruct dce110_link_encoder *enc110,\n\tenum dp_panel_mode panel_mode)\n{\n\t \n\tsetup_panel_mode(enc110, panel_mode);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0x2000,\n\t\t\tDP_VBID_DISABLE, 0,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\t \n\n\t \n\tset_link_training_complete(enc110, true);\n\n\t \n\tenable_phy_bypass_mode(enc110, false);\n\n\t \n\tdisable_prbs_mode(enc110);\n}\n#endif\n\n \nstatic uint8_t get_frontend_source(\n\tenum engine_id engine)\n{\n\tswitch (engine) {\n\tcase ENGINE_ID_DIGA:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGA;\n\tcase ENGINE_ID_DIGB:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGB;\n\tcase ENGINE_ID_DIGC:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGC;\n\tcase ENGINE_ID_DIGD:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGD;\n\tcase ENGINE_ID_DIGE:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGE;\n\tcase ENGINE_ID_DIGF:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGF;\n\tcase ENGINE_ID_DIGG:\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_DIGG;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\treturn DCE110_DIG_FE_SOURCE_SELECT_INVALID;\n\t}\n}\n\nstatic void configure_encoder(\n\tstruct dce110_link_encoder *enc110,\n\tconst struct dc_link_settings *link_settings)\n{\n\t \n\n\tREG_SET(DP_CONFIG, 0,\n\t\t\tDP_UDI_LANES, link_settings->lane_count - LANE_COUNT_ONE);\n\n\t \n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_ADVANCE, 1);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_configure_encoder(\n\tstruct dce110_link_encoder *enc110,\n\tconst struct dc_link_settings *link_settings)\n{\n\t \n\n\tREG_SET(DP_CONFIG, 0,\n\t\t\tDP_UDI_LANES, link_settings->lane_count - LANE_COUNT_ONE);\n\n\t \n}\n#endif\n\nstatic void aux_initialize(\n\tstruct dce110_link_encoder *enc110)\n{\n\tstruct dc_context *ctx = enc110->base.ctx;\n\tenum hpd_source_id hpd_source = enc110->base.hpd_source;\n\tuint32_t addr = AUX_REG(AUX_CONTROL);\n\tuint32_t value = dm_read_reg(ctx, addr);\n\n\tset_reg_field_value(value, hpd_source, AUX_CONTROL, AUX_HPD_SEL);\n\tset_reg_field_value(value, 0, AUX_CONTROL, AUX_LS_READ_EN);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = AUX_REG(AUX_DPHY_RX_CONTROL0);\n\tvalue = dm_read_reg(ctx, addr);\n\n\t \n\tset_reg_field_value(value, 1,\n\t\t\tAUX_DPHY_RX_CONTROL0, AUX_RX_RECEIVE_WINDOW);\n\tdm_write_reg(ctx, addr, value);\n\n}\n\nvoid dce110_psr_program_dp_dphy_fast_training(struct link_encoder *enc,\n\t\t\tbool exit_link_training_required)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\n\tif (exit_link_training_required)\n\t\tREG_UPDATE(DP_DPHY_FAST_TRAINING,\n\t\t\t\tDPHY_RX_FAST_TRAINING_CAPABLE, 1);\n\telse {\n\t\tREG_UPDATE(DP_DPHY_FAST_TRAINING,\n\t\t\t\tDPHY_RX_FAST_TRAINING_CAPABLE, 0);\n\t\t \n\n\t\tREG_UPDATE(DP_DPHY_BS_SR_SWAP_CNTL, DPHY_LOAD_BS_COUNT, 0x5);\n\t}\n}\n\nvoid dce110_psr_program_secondary_packet(struct link_encoder *enc,\n\t\t\tunsigned int sdp_transmit_line_num_deadline)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\n\tREG_UPDATE_2(DP_SEC_CNTL1,\n\t\tDP_SEC_GSP0_LINE_NUM, sdp_transmit_line_num_deadline,\n\t\tDP_SEC_GSP0_PRIORITY, 1);\n}\n\nbool dce110_is_dig_enabled(struct link_encoder *enc)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tuint32_t value;\n\n\tREG_GET(DIG_BE_EN_CNTL, DIG_ENABLE, &value);\n\treturn value;\n}\n\nstatic void link_encoder_disable(struct dce110_link_encoder *enc110)\n{\n\t \n\tREG_SET(DP_DPHY_TRAINING_PATTERN_SEL, 0,\n\t\t\tDPHY_TRAINING_PATTERN_SEL, 0);\n\n\t \n\tREG_UPDATE(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, 0);\n\n\t \n\tsetup_panel_mode(enc110, DP_PANEL_MODE_DEFAULT);\n}\n\nstatic void hpd_initialize(\n\tstruct dce110_link_encoder *enc110)\n{\n\t \n\tenum hpd_source_id hpd_source = enc110->base.hpd_source;\n\n\tREG_UPDATE(DIG_BE_CNTL, DIG_HPD_SELECT, hpd_source);\n}\n\nbool dce110_link_encoder_validate_dvi_output(\n\tconst struct dce110_link_encoder *enc110,\n\tenum signal_type connector_signal,\n\tenum signal_type signal,\n\tconst struct dc_crtc_timing *crtc_timing)\n{\n\tuint32_t max_pixel_clock = TMDS_MAX_PIXEL_CLOCK;\n\n\tif (signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\tmax_pixel_clock *= 2;\n\n\t \n\tif (connector_signal != SIGNAL_TYPE_DVI_DUAL_LINK &&\n\t\t\tconnector_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)\n\t\tmax_pixel_clock = enc110->base.features.max_hdmi_pixel_clock;\n\n\t \n\tif (crtc_timing->pixel_encoding != PIXEL_ENCODING_RGB)\n\t\treturn false;\n\n\t \n\tif ((connector_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||\n\t\tconnector_signal == SIGNAL_TYPE_HDMI_TYPE_A) &&\n\t\tsignal != SIGNAL_TYPE_HDMI_TYPE_A &&\n\t\tcrtc_timing->pix_clk_100hz > (TMDS_MAX_PIXEL_CLOCK * 10))\n\t\treturn false;\n\tif (crtc_timing->pix_clk_100hz < (TMDS_MIN_PIXEL_CLOCK * 10))\n\t\treturn false;\n\n\tif (crtc_timing->pix_clk_100hz > (max_pixel_clock * 10))\n\t\treturn false;\n\n\t \n\tswitch (crtc_timing->display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\tcase COLOR_DEPTH_888:\n\tbreak;\n\tcase COLOR_DEPTH_101010:\n\tcase COLOR_DEPTH_161616:\n\t\tif (signal != SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\treturn false;\n\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool dce110_link_encoder_validate_hdmi_output(\n\tconst struct dce110_link_encoder *enc110,\n\tconst struct dc_crtc_timing *crtc_timing,\n\tint adjusted_pix_clk_khz)\n{\n\tenum dc_color_depth max_deep_color =\n\t\t\tenc110->base.features.max_hdmi_deep_color;\n\n\tif (max_deep_color < crtc_timing->display_color_depth)\n\t\treturn false;\n\n\tif (crtc_timing->display_color_depth < COLOR_DEPTH_888)\n\t\treturn false;\n\tif (adjusted_pix_clk_khz < TMDS_MIN_PIXEL_CLOCK)\n\t\treturn false;\n\n\tif ((adjusted_pix_clk_khz == 0) ||\n\t\t(adjusted_pix_clk_khz > enc110->base.features.max_hdmi_pixel_clock))\n\t\treturn false;\n\n\t \n\tif (!enc110->base.features.hdmi_ycbcr420_supported &&\n\t\t\tcrtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\treturn false;\n\n\tif ((!enc110->base.features.flags.bits.HDMI_6GB_EN ||\n\t\t\tenc110->base.ctx->dc->debug.hdmi20_disable) &&\n\t\t\tadjusted_pix_clk_khz >= 300000)\n\t\treturn false;\n\tif (enc110->base.ctx->dc->debug.hdmi20_disable &&\n\t\tcrtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\treturn false;\n\treturn true;\n}\n\nbool dce110_link_encoder_validate_dp_output(\n\tconst struct dce110_link_encoder *enc110,\n\tconst struct dc_crtc_timing *crtc_timing)\n{\n\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid dce110_link_encoder_construct(\n\tstruct dce110_link_encoder *enc110,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dce110_link_enc_registers *link_regs,\n\tconst struct dce110_link_enc_aux_registers *aux_regs,\n\tconst struct dce110_link_enc_hpd_registers *hpd_regs)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\n\tenc110->base.funcs = &dce110_lnk_enc_funcs;\n\tenc110->base.ctx = init_data->ctx;\n\tenc110->base.id = init_data->encoder;\n\n\tenc110->base.hpd_source = init_data->hpd_source;\n\tenc110->base.connector = init_data->connector;\n\n\tenc110->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc110->base.features = *enc_features;\n\n\tenc110->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc110->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc110->link_regs = link_regs;\n\tenc110->aux_regs = aux_regs;\n\tenc110->hpd_regs = hpd_regs;\n\n\tswitch (enc110->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGG;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc110->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc110->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc110->base.ctx->dc_bios,\n\t\t\t\t\t\tenc110->base.id, &bp_cap_info);\n\n\t \n\tif (BP_RESULT_OK == result) {\n\t\tenc110->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc110->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc110->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc110->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc110->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n\nbool dce110_link_encoder_validate_output_with_stream(\n\tstruct link_encoder *enc,\n\tconst struct dc_stream_state *stream)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tbool is_valid;\n\n\tswitch (stream->signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\tis_valid = dce110_link_encoder_validate_dvi_output(\n\t\t\tenc110,\n\t\t\tstream->link->connector_signal,\n\t\t\tstream->signal,\n\t\t\t&stream->timing);\n\tbreak;\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tis_valid = dce110_link_encoder_validate_hdmi_output(\n\t\t\t\tenc110,\n\t\t\t\t&stream->timing,\n\t\t\t\tstream->phy_pix_clk);\n\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tis_valid = dce110_link_encoder_validate_dp_output(\n\t\t\t\t\tenc110, &stream->timing);\n\tbreak;\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_LVDS:\n\t\tis_valid = stream->timing.pixel_encoding == PIXEL_ENCODING_RGB;\n\tbreak;\n\tcase SIGNAL_TYPE_VIRTUAL:\n\t\tis_valid = true;\n\t\tbreak;\n\tdefault:\n\t\tis_valid = false;\n\tbreak;\n\t}\n\n\treturn is_valid;\n}\n\nvoid dce110_link_encoder_hw_init(\n\tstruct link_encoder *enc)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\tcntl.action = TRANSMITTER_CONTROL_INIT;\n\tcntl.engine_id = ENGINE_ID_UNKNOWN;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.lanes_number = LANE_COUNT_FOUR;\n\tcntl.coherent = false;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\n\tif (enc110->base.connector.id == CONNECTOR_ID_EDP)\n\t\tcntl.signal = SIGNAL_TYPE_EDP;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (enc110->base.connector.id == CONNECTOR_ID_LVDS) {\n\t\tcntl.action = TRANSMITTER_CONTROL_BACKLIGHT_BRIGHTNESS;\n\n\t\tresult = link_transmitter_control(enc110, &cntl);\n\n\t\tASSERT(result == BP_RESULT_OK);\n\n\t}\n\taux_initialize(enc110);\n\n\t \n\thpd_initialize(enc110);\n}\n\nvoid dce110_link_encoder_destroy(struct link_encoder **enc)\n{\n\tkfree(TO_DCE110_LINK_ENC(*enc));\n\t*enc = NULL;\n}\n\nvoid dce110_link_encoder_setup(\n\tstruct link_encoder *enc,\n\tenum signal_type signal)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\n\tswitch (signal) {\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 0);\n\t\tbreak;\n\tcase SIGNAL_TYPE_LVDS:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 1);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 2);\n\t\tbreak;\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 3);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 5);\n\t\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n \nvoid dce110_link_encoder_enable_tmds_output(\n\tstruct link_encoder *enc,\n\tenum clock_source_id clock_source,\n\tenum dc_color_depth color_depth,\n\tenum signal_type signal,\n\tuint32_t pixel_clock)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = signal;\n\tif (cntl.signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\tcntl.lanes_number = 8;\n\telse\n\t\tcntl.lanes_number = 4;\n\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\n\tcntl.pixel_clock = pixel_clock;\n\tcntl.color_depth = color_depth;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n \nvoid dce110_link_encoder_enable_lvds_output(\n\tstruct link_encoder *enc,\n\tenum clock_source_id clock_source,\n\tuint32_t pixel_clock)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_LVDS;\n\tcntl.lanes_number = 4;\n\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\n\tcntl.pixel_clock = pixel_clock;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n \nvoid dce110_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tconfigure_encoder(enc110, link_settings);\n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n \nvoid dce110_link_encoder_enable_dp_mst_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tconfigure_encoder(enc110, link_settings);\n\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = ENGINE_ID_UNKNOWN;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT_MST;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n \nstatic void dce60_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tdce60_configure_encoder(enc110, link_settings);\n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n \nstatic void dce60_link_encoder_enable_dp_mst_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tdce60_configure_encoder(enc110, link_settings);\n\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = ENGINE_ID_UNKNOWN;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT_MST;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n#endif\n\n \nvoid dce110_link_encoder_disable_output(\n\tstruct link_encoder *enc,\n\tenum signal_type signal)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\tif (!dce110_is_dig_enabled(enc)) {\n\t\t \n\t\treturn;\n\t}\n\t \n\n\t \n\n\t \n\tcntl.action = TRANSMITTER_CONTROL_DISABLE;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.signal = signal;\n\tcntl.connector_obj_id = enc110->base.connector;\n\n\tresult = link_transmitter_control(enc110, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t \n\tif (dc_is_dp_signal(signal))\n\t\tlink_encoder_disable(enc110);\n}\n\nvoid dce110_link_encoder_dp_set_lane_settings(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tconst struct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX])\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tunion dpcd_training_lane_set training_lane_set = { { 0 } };\n\tint32_t lane = 0;\n\tstruct bp_transmitter_control cntl = { 0 };\n\n\tif (!link_settings) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tcntl.action = TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS;\n\tcntl.transmitter = enc110->base.transmitter;\n\tcntl.connector_obj_id = enc110->base.connector;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc110->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate *\n\t\t\t\t\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\n\tfor (lane = 0; lane < link_settings->lane_count; lane++) {\n\t\t \n\n\t\ttraining_lane_set.bits.VOLTAGE_SWING_SET =\n\t\t\t\tlane_settings[lane].VOLTAGE_SWING;\n\t\ttraining_lane_set.bits.PRE_EMPHASIS_SET =\n\t\t\t\tlane_settings[lane].PRE_EMPHASIS;\n\n\t\t \n\t\tif (link_settings->link_rate == LINK_RATE_HIGH2) {\n\t\t\t \n\n\t\t\ttraining_lane_set.bits.POST_CURSOR2_SET =\n\t\t\t\t\tlane_settings[lane].POST_CURSOR2;\n\t\t}\n\n\t\tcntl.lane_select = lane;\n\t\tcntl.lane_settings = training_lane_set.raw;\n\n\t\t \n\t\tlink_transmitter_control(enc110, &cntl);\n\t}\n}\n\n \nvoid dce110_link_encoder_dp_set_phy_pattern(\n\tstruct link_encoder *enc,\n\tconst struct encoder_set_dp_phy_pattern_param *param)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\n\tswitch (param->dp_phy_pattern) {\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN1:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 0);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN2:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN3:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN4:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_D102:\n\t\tset_dp_phy_pattern_d102(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_SYMBOL_ERROR:\n\t\tset_dp_phy_pattern_symbol_error(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_PRBS7:\n\t\tset_dp_phy_pattern_prbs7(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_80BIT_CUSTOM:\n\t\tset_dp_phy_pattern_80bit_custom(\n\t\t\tenc110, param->custom_pattern);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_1:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_2:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_3:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_VIDEO_MODE: {\n\t\tset_dp_phy_pattern_passthrough_mode(\n\t\t\tenc110, param->dp_panel_mode);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\tASSERT_CRITICAL(false);\n\t\tbreak;\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n \nstatic void dce60_link_encoder_dp_set_phy_pattern(\n\tstruct link_encoder *enc,\n\tconst struct encoder_set_dp_phy_pattern_param *param)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\n\tswitch (param->dp_phy_pattern) {\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN1:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 0);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN2:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN3:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN4:\n\t\tdce110_link_encoder_set_dp_phy_pattern_training_pattern(enc, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_D102:\n\t\tset_dp_phy_pattern_d102(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_SYMBOL_ERROR:\n\t\tset_dp_phy_pattern_symbol_error(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_PRBS7:\n\t\tset_dp_phy_pattern_prbs7(enc110);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_80BIT_CUSTOM:\n\t\tset_dp_phy_pattern_80bit_custom(\n\t\t\tenc110, param->custom_pattern);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_1:\n\t\tdce60_set_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_2:\n\t\tdce60_set_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_3:\n\t\tdce60_set_dp_phy_pattern_hbr2_compliance_cp2520_2(enc110, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_VIDEO_MODE: {\n\t\tdce60_set_dp_phy_pattern_passthrough_mode(\n\t\t\tenc110, param->dp_panel_mode);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\tASSERT_CRITICAL(false);\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic void fill_stream_allocation_row_info(\n\tconst struct link_mst_stream_allocation *stream_allocation,\n\tuint32_t *src,\n\tuint32_t *slots)\n{\n\tconst struct stream_encoder *stream_enc = stream_allocation->stream_enc;\n\n\tif (stream_enc) {\n\t\t*src = stream_enc->id;\n\t\t*slots = stream_allocation->slot_count;\n\t} else {\n\t\t*src = 0;\n\t\t*slots = 0;\n\t}\n}\n\n \nvoid dce110_link_encoder_update_mst_stream_allocation_table(\n\tstruct link_encoder *enc,\n\tconst struct link_mst_stream_allocation_table *table)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tuint32_t value1 = 0;\n\tuint32_t value2 = 0;\n\tuint32_t slots = 0;\n\tuint32_t src = 0;\n\tuint32_t retries = 0;\n\n\t \n\n\t \n\n\t \n\n\tif (table->stream_count >= 1) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[0],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT0,\n\t\t\tDP_MSE_SAT_SRC0, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT0, slots);\n\n\tif (table->stream_count >= 2) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[1],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT0,\n\t\t\tDP_MSE_SAT_SRC1, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT1, slots);\n\n\tif (table->stream_count >= 3) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[2],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT1,\n\t\t\tDP_MSE_SAT_SRC2, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT2, slots);\n\n\tif (table->stream_count >= 4) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[3],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT1,\n\t\t\tDP_MSE_SAT_SRC3, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT3, slots);\n\n\t \n\n\t \n\n\n\t \n\n\tREG_UPDATE(DP_MSE_SAT_UPDATE,\n\t\t\tDP_MSE_SAT_UPDATE, 1);\n\n\t \n\n\tdo {\n\t\tudelay(10);\n\n\t\tREG_READ(DP_MSE_SAT_UPDATE);\n\n\t\tREG_GET(DP_MSE_SAT_UPDATE,\n\t\t\t\tDP_MSE_SAT_UPDATE, &value1);\n\n\t\tREG_GET(DP_MSE_SAT_UPDATE,\n\t\t\t\tDP_MSE_16_MTP_KEEPOUT, &value2);\n\n\t\t \n\t\tif (!value1 && !value2)\n\t\t\tbreak;\n\t\t++retries;\n\t} while (retries < DP_MST_UPDATE_MAX_RETRY);\n}\n\nvoid dce110_link_encoder_connect_dig_be_to_fe(\n\tstruct link_encoder *enc,\n\tenum engine_id engine,\n\tbool connect)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tuint32_t field;\n\n\tif (engine != ENGINE_ID_UNKNOWN) {\n\n\t\tREG_GET(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, &field);\n\n\t\tif (connect)\n\t\t\tfield |= get_frontend_source(engine);\n\t\telse\n\t\t\tfield &= ~get_frontend_source(engine);\n\n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, field);\n\t}\n}\n\nvoid dce110_link_encoder_enable_hpd(struct link_encoder *enc)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct dc_context *ctx = enc110->base.ctx;\n\tuint32_t addr = HPD_REG(DC_HPD_CONTROL);\n\tuint32_t hpd_enable = 0;\n\tuint32_t value = dm_read_reg(ctx, addr);\n\n\thpd_enable = get_reg_field_value(hpd_enable, DC_HPD_CONTROL, DC_HPD_EN);\n\n\tif (hpd_enable == 0)\n\t\tset_reg_field_value(value, 1, DC_HPD_CONTROL, DC_HPD_EN);\n}\n\nvoid dce110_link_encoder_disable_hpd(struct link_encoder *enc)\n{\n\tstruct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);\n\tstruct dc_context *ctx = enc110->base.ctx;\n\tuint32_t addr = HPD_REG(DC_HPD_CONTROL);\n\tuint32_t value = dm_read_reg(ctx, addr);\n\n\tset_reg_field_value(value, 0, DC_HPD_CONTROL, DC_HPD_EN);\n}\n\nvoid dce110_link_encoder_get_max_link_cap(struct link_encoder *enc,\n\tstruct dc_link_settings *link_settings)\n{\n\t \n\tstruct dc_link_settings max_link_cap = {LANE_COUNT_FOUR, LINK_RATE_HIGH,\n\t\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ, false, 0};\n\n\t \n\tif (enc->features.flags.bits.IS_HBR2_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_HIGH2;\n\n\tif (enc->features.flags.bits.IS_HBR3_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_HIGH3;\n\n\t*link_settings = max_link_cap;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic const struct link_encoder_funcs dce60_lnk_enc_funcs = {\n\t.validate_output_with_stream =\n\t\tdce110_link_encoder_validate_output_with_stream,\n\t.hw_init = dce110_link_encoder_hw_init,\n\t.setup = dce110_link_encoder_setup,\n\t.enable_tmds_output = dce110_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dce60_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dce60_link_encoder_enable_dp_mst_output,\n\t.enable_lvds_output = dce110_link_encoder_enable_lvds_output,\n\t.disable_output = dce110_link_encoder_disable_output,\n\t.dp_set_lane_settings = dce110_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dce60_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdce110_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdce110_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dce110_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dce110_link_encoder_enable_hpd,\n\t.disable_hpd = dce110_link_encoder_disable_hpd,\n\t.is_dig_enabled = dce110_is_dig_enabled,\n\t.destroy = dce110_link_encoder_destroy,\n\t.get_max_link_cap = dce110_link_encoder_get_max_link_cap,\n\t.get_dig_frontend = dce110_get_dig_frontend\n};\n\nvoid dce60_link_encoder_construct(\n\tstruct dce110_link_encoder *enc110,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dce110_link_enc_registers *link_regs,\n\tconst struct dce110_link_enc_aux_registers *aux_regs,\n\tconst struct dce110_link_enc_hpd_registers *hpd_regs)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\n\tenc110->base.funcs = &dce60_lnk_enc_funcs;\n\tenc110->base.ctx = init_data->ctx;\n\tenc110->base.id = init_data->encoder;\n\n\tenc110->base.hpd_source = init_data->hpd_source;\n\tenc110->base.connector = init_data->connector;\n\n\tenc110->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc110->base.features = *enc_features;\n\n\tenc110->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc110->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc110->link_regs = link_regs;\n\tenc110->aux_regs = aux_regs;\n\tenc110->hpd_regs = hpd_regs;\n\n\tswitch (enc110->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tenc110->base.preferred_engine = ENGINE_ID_DIGG;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc110->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc110->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc110->base.ctx->dc_bios,\n\t\t\t\t\t\tenc110->base.id, &bp_cap_info);\n\n\t \n\tif (BP_RESULT_OK == result) {\n\t\tenc110->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc110->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc110->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc110->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc110->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}