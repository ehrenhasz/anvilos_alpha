{
  "module_name": "bios_parser2.c",
  "hash_id": "410ec0cd80af6c51d8e7552286ffe6b49b46c4d73702c88faf2be0a191a20793",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n\n#include \"ObjectID.h\"\n#include \"atomfirmware.h\"\n\n#include \"dc_bios_types.h\"\n#include \"include/grph_object_ctrl_defs.h\"\n#include \"include/bios_parser_interface.h\"\n#include \"include/logger_interface.h\"\n\n#include \"command_table2.h\"\n\n#include \"bios_parser_helper.h\"\n#include \"command_table_helper2.h\"\n#include \"bios_parser2.h\"\n#include \"bios_parser_types_internal2.h\"\n#include \"bios_parser_interface.h\"\n\n#include \"bios_parser_common.h\"\n\n#define DC_LOGGER \\\n\tbp->base.ctx->logger\n\n#define LAST_RECORD_TYPE 0xff\n#define SMU9_SYSPLL0_ID  0\n\nstatic enum bp_result get_gpio_i2c_info(struct bios_parser *bp,\n\tstruct atom_i2c_record *record,\n\tstruct graphics_object_i2c_info *info);\n\nstatic enum bp_result bios_parser_get_firmware_info(\n\tstruct dc_bios *dcb,\n\tstruct dc_firmware_info *info);\n\nstatic enum bp_result bios_parser_get_encoder_cap_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id object_id,\n\tstruct bp_encoder_cap_info *info);\n\nstatic enum bp_result get_firmware_info_v3_1(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\n\nstatic enum bp_result get_firmware_info_v3_2(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\n\nstatic enum bp_result get_firmware_info_v3_4(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\n\nstatic struct atom_hpd_int_record *get_hpd_record(struct bios_parser *bp,\n\t\tstruct atom_display_object_path_v2 *object);\n\nstatic struct atom_encoder_caps_record *get_encoder_cap_record(\n\tstruct bios_parser *bp,\n\tstruct atom_display_object_path_v2 *object);\n\n#define BIOS_IMAGE_SIZE_OFFSET 2\n#define BIOS_IMAGE_SIZE_UNIT 512\n\n#define DATA_TABLES(table) (bp->master_data_tbl->listOfdatatables.table)\n\nstatic void bios_parser2_destruct(struct bios_parser *bp)\n{\n\tkfree(bp->base.bios_local_image);\n\tkfree(bp->base.integrated_info);\n}\n\nstatic void firmware_parser_destroy(struct dc_bios **dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(*dcb);\n\n\tif (!bp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tbios_parser2_destruct(bp);\n\n\tkfree(bp);\n\t*dcb = NULL;\n}\n\nstatic void get_atom_data_table_revision(\n\tstruct atom_common_table_header *atom_data_tbl,\n\tstruct atom_data_revision *tbl_revision)\n{\n\tif (!tbl_revision)\n\t\treturn;\n\n\t \n\ttbl_revision->major = 0;\n\ttbl_revision->minor = 0;\n\n\tif (!atom_data_tbl)\n\t\treturn;\n\n\ttbl_revision->major =\n\t\t\t(uint32_t) atom_data_tbl->format_revision & 0x3f;\n\ttbl_revision->minor =\n\t\t\t(uint32_t) atom_data_tbl->content_revision & 0x3f;\n}\n\n \nstatic uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tunsigned int count = 0;\n\tunsigned int i;\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\tdefault:\n\tcase 4:\n\t\tfor (i = 0; i < bp->object_info_tbl.v1_4->number_of_path; i++)\n\t\t\tif (bp->object_info_tbl.v1_4->display_path[i].encoderobjid != 0)\n\t\t\t\tcount++;\n\n\t\tbreak;\n\n\tcase 5:\n\t\tfor (i = 0; i < bp->object_info_tbl.v1_5->number_of_path; i++)\n\t\t\tif (bp->object_info_tbl.v1_5->display_path[i].encoderobjid != 0)\n\t\t\t\tcount++;\n\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic struct graphics_object_id bios_parser_get_connector_id(\n\tstruct dc_bios *dcb,\n\tuint8_t i)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct graphics_object_id object_id = dal_graphics_object_id_init(\n\t\t0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);\n\tstruct object_info_table *tbl = &bp->object_info_tbl;\n\tstruct display_object_info_table_v1_4 *v1_4 = tbl->v1_4;\n\n\tstruct display_object_info_table_v1_5 *v1_5 = tbl->v1_5;\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\tdefault:\n\tcase 4:\n\t\tif (v1_4->number_of_path > i) {\n\t\t\t \n\t\t\tif (v1_4->display_path[i].encoderobjid != 0 &&\n\t\t\t    v1_4->display_path[i].display_objid != 0)\n\t\t\t\tobject_id = object_id_from_bios_object_id(\n\t\t\t\t\tv1_4->display_path[i].display_objid);\n\t\t}\n\t\tbreak;\n\n\tcase 5:\n\t\tif (v1_5->number_of_path > i) {\n\t\t\t \n\t\t\tif (v1_5->display_path[i].encoderobjid != 0 &&\n\t\t\t    v1_5->display_path[i].display_objid != 0)\n\t\t\t\tobject_id = object_id_from_bios_object_id(\n\t\t\t\t\tv1_5->display_path[i].display_objid);\n\t\t}\n\t\tbreak;\n\t}\n\treturn object_id;\n}\n\nstatic enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,\n\tstruct graphics_object_id object_id, uint32_t index,\n\tstruct graphics_object_id *src_object_id)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tunsigned int i;\n\tenum bp_result bp_result = BP_RESULT_BADINPUT;\n\tstruct graphics_object_id obj_id = { 0 };\n\tstruct object_info_table *tbl = &bp->object_info_tbl;\n\n\tif (!src_object_id)\n\t\treturn bp_result;\n\n\tswitch (object_id.type) {\n\t \n\tcase OBJECT_TYPE_ENCODER:\n\t\t \n\t\tswitch (bp->object_info_tbl.revision.minor) {\n\t\tdefault:\n\t\tcase 4:\n\t\t\tfor (i = 0; i < tbl->v1_4->number_of_path; i++) {\n\t\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\ttbl->v1_4->display_path[i].encoderobjid);\n\t\t\t\tif (object_id.type == obj_id.type &&\n\t\t\t\t    object_id.id == obj_id.id &&\n\t\t\t\t    object_id.enum_id == obj_id.enum_id) {\n\t\t\t\t\t*src_object_id =\n\t\t\t\t\t\tobject_id_from_bios_object_id(\n\t\t\t\t\t\t\t0x1100);\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tbp_result = BP_RESULT_OK;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tfor (i = 0; i < tbl->v1_5->number_of_path; i++) {\n\t\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\ttbl->v1_5->display_path[i].encoderobjid);\n\t\t\t\tif (object_id.type == obj_id.type &&\n\t\t\t\t    object_id.id == obj_id.id &&\n\t\t\t\t    object_id.enum_id == obj_id.enum_id) {\n\t\t\t\t\t*src_object_id =\n\t\t\t\t\t\tobject_id_from_bios_object_id(\n\t\t\t\t\t\t\t0x1100);\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tbp_result = BP_RESULT_OK;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase OBJECT_TYPE_CONNECTOR:\n\t\tswitch (bp->object_info_tbl.revision.minor) {\n\t\tdefault:\n\t\tcase 4:\n\t\t\tfor (i = 0; i < tbl->v1_4->number_of_path; i++) {\n\t\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\ttbl->v1_4->display_path[i]\n\t\t\t\t\t\t.display_objid);\n\n\t\t\t\tif (object_id.type == obj_id.type &&\n\t\t\t\t    object_id.id == obj_id.id &&\n\t\t\t\t    object_id.enum_id == obj_id.enum_id) {\n\t\t\t\t\t*src_object_id =\n\t\t\t\t\t\tobject_id_from_bios_object_id(\n\t\t\t\t\t\t\ttbl->v1_4\n\t\t\t\t\t\t\t\t->display_path[i]\n\t\t\t\t\t\t\t\t.encoderobjid);\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tbp_result = BP_RESULT_OK;\n\t\t\tbreak;\n\t\t}\n\t\tbp_result = BP_RESULT_OK;\n\t\tbreak;\n\t\tcase 5:\n\t\t\tfor (i = 0; i < tbl->v1_5->number_of_path; i++) {\n\t\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\t\t\t\t       tbl->v1_5->display_path[i].display_objid);\n\n\t\t\t\tif (object_id.type == obj_id.type &&\n\t\t\t\t    object_id.id == obj_id.id &&\n\t\t\t\t    object_id.enum_id == obj_id.enum_id) {\n\t\t\t\t\t*src_object_id = object_id_from_bios_object_id(\n\t\t\t\t\t\t\t\t\t\t       tbl->v1_5->display_path[i].encoderobjid);\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\tbp_result = BP_RESULT_OK;\n\t\tbreak;\n\n\tdefault:\n\t\tbp_result = BP_RESULT_OK;\n\t\tbreak;\n\t}\n\n\treturn bp_result;\n}\n\n \nstatic struct atom_display_object_path_v2 *get_bios_object(\n\t\tstruct bios_parser *bp,\n\t\tstruct graphics_object_id id)\n{\n\tunsigned int i;\n\tstruct graphics_object_id obj_id = {0};\n\n\tswitch (id.type) {\n\tcase OBJECT_TYPE_ENCODER:\n\t\tfor (i = 0; i < bp->object_info_tbl.v1_4->number_of_path; i++) {\n\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\tbp->object_info_tbl.v1_4->display_path[i].encoderobjid);\n\t\t\tif (id.type == obj_id.type && id.id == obj_id.id\n\t\t\t\t\t&& id.enum_id == obj_id.enum_id)\n\t\t\t\treturn &bp->object_info_tbl.v1_4->display_path[i];\n\t\t}\n\t\tfallthrough;\n\tcase OBJECT_TYPE_CONNECTOR:\n\tcase OBJECT_TYPE_GENERIC:\n\t\t \n\t\tfor (i = 0; i < bp->object_info_tbl.v1_4->number_of_path; i++) {\n\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\tbp->object_info_tbl.v1_4->display_path[i].display_objid);\n\t\t\tif (id.type == obj_id.type && id.id == obj_id.id\n\t\t\t\t\t&& id.enum_id == obj_id.enum_id)\n\t\t\t\treturn &bp->object_info_tbl.v1_4->display_path[i];\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic struct atom_display_object_path_v3 *get_bios_object_from_path_v3(struct bios_parser *bp,\n\t\t\t\t\t\t\t\t\tstruct graphics_object_id id)\n{\n\tunsigned int i;\n\tstruct graphics_object_id obj_id = {0};\n\n\tswitch (id.type) {\n\tcase OBJECT_TYPE_ENCODER:\n\t\tfor (i = 0; i < bp->object_info_tbl.v1_5->number_of_path; i++) {\n\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\tbp->object_info_tbl.v1_5->display_path[i].encoderobjid);\n\t\t\tif (id.type == obj_id.type && id.id == obj_id.id\n\t\t\t\t\t&& id.enum_id == obj_id.enum_id)\n\t\t\t\treturn &bp->object_info_tbl.v1_5->display_path[i];\n\t\t}\n        break;\n\n\tcase OBJECT_TYPE_CONNECTOR:\n\tcase OBJECT_TYPE_GENERIC:\n\t\t \n\t\tfor (i = 0; i < bp->object_info_tbl.v1_5->number_of_path; i++) {\n\t\t\tobj_id = object_id_from_bios_object_id(\n\t\t\t\t\tbp->object_info_tbl.v1_5->display_path[i].display_objid);\n\t\t\tif (id.type == obj_id.type && id.id == obj_id.id\n\t\t\t\t\t&& id.enum_id == obj_id.enum_id)\n\t\t\t\treturn &bp->object_info_tbl.v1_5->display_path[i];\n\t\t}\n        break;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,\n\tstruct graphics_object_id id,\n\tstruct graphics_object_i2c_info *info)\n{\n\tuint32_t offset;\n\tstruct atom_display_object_path_v2 *object;\n\n\tstruct atom_display_object_path_v3 *object_path_v3;\n\n\tstruct atom_common_record_header *header;\n\tstruct atom_i2c_record *record;\n\tstruct atom_i2c_record dummy_record = {0};\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (id.type == OBJECT_TYPE_GENERIC) {\n\t\tdummy_record.i2c_id = id.id;\n\n\t\tif (get_gpio_i2c_info(bp, &dummy_record, info) == BP_RESULT_OK)\n\t\t\treturn BP_RESULT_OK;\n\t\telse\n\t\t\treturn BP_RESULT_NORECORD;\n\t}\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\t    case 4:\n\t    default:\n\t        object = get_bios_object(bp, id);\n\n\t        if (!object)\n\t\t\t\treturn BP_RESULT_BADINPUT;\n\n\t        offset = object->disp_recordoffset + bp->object_info_tbl_offset;\n\t        break;\n\t    case 5:\n\t\tobject_path_v3 = get_bios_object_from_path_v3(bp, id);\n\n\t\tif (!object_path_v3)\n\t\t\treturn BP_RESULT_BADINPUT;\n\n\t\toffset = object_path_v3->disp_recordoffset + bp->object_info_tbl_offset;\n\t\tbreak;\n\t}\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\tif (header->record_type == LAST_RECORD_TYPE ||\n\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type == ATOM_I2C_RECORD_TYPE\n\t\t\t&& sizeof(struct atom_i2c_record) <=\n\t\t\t\t\t\t\theader->record_size) {\n\t\t\t \n\t\t\trecord = (struct atom_i2c_record *) header;\n\n\t\t\tif (get_gpio_i2c_info(bp, record, info) ==\n\t\t\t\t\t\t\t\tBP_RESULT_OK)\n\t\t\t\treturn BP_RESULT_OK;\n\t\t}\n\n\t\toffset += header->record_size;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result get_gpio_i2c_info(\n\tstruct bios_parser *bp,\n\tstruct atom_i2c_record *record,\n\tstruct graphics_object_i2c_info *info)\n{\n\tstruct atom_gpio_pin_lut_v2_1 *header;\n\tuint32_t count = 0;\n\tunsigned int table_index = 0;\n\tbool find_valid = false;\n\tstruct atom_gpio_pin_assignment *pin;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\t \n\tif (!DATA_TABLES(gpio_pin_lut))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\theader = GET_IMAGE(struct atom_gpio_pin_lut_v2_1,\n\t\t\t\t\tDATA_TABLES(gpio_pin_lut));\n\tif (!header)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (sizeof(struct atom_common_table_header) +\n\t\t\tsizeof(struct atom_gpio_pin_assignment)\t>\n\t\t\tle16_to_cpu(header->table_header.structuresize))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t \n\tif (header->table_header.content_revision != 1)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\t \n\tcount = (le16_to_cpu(header->table_header.structuresize)\n\t\t\t- sizeof(struct atom_common_table_header))\n\t\t\t\t/ sizeof(struct atom_gpio_pin_assignment);\n\n\tpin = (struct atom_gpio_pin_assignment *) header->gpio_pin;\n\n\tfor (table_index = 0; table_index < count; table_index++) {\n\t\tif (((record->i2c_id & I2C_HW_CAP) \t\t\t\t== (pin->gpio_id & I2C_HW_CAP)) &&\n\t\t    ((record->i2c_id & I2C_HW_ENGINE_ID_MASK)\t== (pin->gpio_id & I2C_HW_ENGINE_ID_MASK)) &&\n\t\t    ((record->i2c_id & I2C_HW_LANE_MUX) \t\t== (pin->gpio_id & I2C_HW_LANE_MUX))) {\n\t\t\t \n\t\t\tfind_valid = true;\n\t\t\tbreak;\n\t\t}\n\t\tpin = (struct atom_gpio_pin_assignment *)((uint8_t *)pin + sizeof(struct atom_gpio_pin_assignment));\n\t}\n\n\t \n\tif (find_valid == false)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t \n\tinfo->i2c_hw_assist = (record->i2c_id & I2C_HW_CAP) ? true : false;\n\tinfo->i2c_line = record->i2c_id & I2C_HW_LANE_MUX;\n\tinfo->i2c_engine_id = (record->i2c_id & I2C_HW_ENGINE_ID_MASK) >> 4;\n\tinfo->i2c_slave_address = record->i2c_slave_addr;\n\n\t \n\tinfo->gpio_info.clk_a_register_index = le16_to_cpu(pin->data_a_reg_index);\n\tinfo->gpio_info.clk_a_shift = pin->gpio_bitshift;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic struct atom_hpd_int_record *get_hpd_record_for_path_v3(struct bios_parser *bp,\n\t\t\t\t\t\t\t      struct atom_display_object_path_v3 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = object->disp_recordoffset + bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\tif (header->record_type == ATOM_RECORD_END_TYPE ||\n\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type == ATOM_HPD_INT_RECORD_TYPE\n\t\t\t&& sizeof(struct atom_hpd_int_record) <=\n\t\t\t\t\t\t\theader->record_size)\n\t\t\treturn (struct atom_hpd_int_record *) header;\n\n\t\toffset += header->record_size;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum bp_result bios_parser_get_hpd_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id id,\n\tstruct graphics_object_hpd_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_display_object_path_v2 *object;\n\tstruct atom_display_object_path_v3 *object_path_v3;\n\tstruct atom_hpd_int_record *record = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\t    case 4:\n\t    default:\n\t        object = get_bios_object(bp, id);\n\n\t\tif (!object)\n\t\t\treturn BP_RESULT_BADINPUT;\n\n\t        record = get_hpd_record(bp, object);\n\n\t        break;\n\t    case 5:\n\t\tobject_path_v3 = get_bios_object_from_path_v3(bp, id);\n\n\t\tif (!object_path_v3)\n\t\t\treturn BP_RESULT_BADINPUT;\n\n\t\trecord = get_hpd_record_for_path_v3(bp, object_path_v3);\n\t\tbreak;\n\t}\n\n\tif (record != NULL) {\n\t\tinfo->hpd_int_gpio_uid = record->pin_id;\n\t\tinfo->hpd_active = record->plugin_pin_state;\n\t\treturn BP_RESULT_OK;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic struct atom_hpd_int_record *get_hpd_record(\n\tstruct bios_parser *bp,\n\tstruct atom_display_object_path_v2 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = le16_to_cpu(object->disp_recordoffset)\n\t\t\t+ bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\tif (header->record_type == LAST_RECORD_TYPE ||\n\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type == ATOM_HPD_INT_RECORD_TYPE\n\t\t\t&& sizeof(struct atom_hpd_int_record) <=\n\t\t\t\t\t\t\theader->record_size)\n\t\t\treturn (struct atom_hpd_int_record *) header;\n\n\t\toffset += header->record_size;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic enum bp_result bios_parser_get_gpio_pin_info(\n\tstruct dc_bios *dcb,\n\tuint32_t gpio_id,\n\tstruct gpio_pin_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_gpio_pin_lut_v2_1 *header;\n\tuint32_t count = 0;\n\tuint32_t i = 0;\n\n\tif (!DATA_TABLES(gpio_pin_lut))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\theader = GET_IMAGE(struct atom_gpio_pin_lut_v2_1,\n\t\t\t\t\t\tDATA_TABLES(gpio_pin_lut));\n\tif (!header)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (sizeof(struct atom_common_table_header) +\n\t\t\tsizeof(struct atom_gpio_pin_assignment)\n\t\t\t> le16_to_cpu(header->table_header.structuresize))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (header->table_header.content_revision != 1)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\t \n\tcount = (le16_to_cpu(header->table_header.structuresize)\n\t\t\t- sizeof(struct atom_common_table_header))\n\t\t\t\t/ sizeof(struct atom_gpio_pin_assignment);\n\tfor (i = 0; i < count; ++i) {\n\t\tif (header->gpio_pin[i].gpio_id != gpio_id)\n\t\t\tcontinue;\n\n\t\tinfo->offset =\n\t\t\t(uint32_t) le16_to_cpu(\n\t\t\t\t\theader->gpio_pin[i].data_a_reg_index);\n\t\tinfo->offset_y = info->offset + 2;\n\t\tinfo->offset_en = info->offset + 1;\n\t\tinfo->offset_mask = info->offset - 1;\n\n\t\tinfo->mask = (uint32_t) (1 <<\n\t\t\theader->gpio_pin[i].gpio_bitshift);\n\t\tinfo->mask_y = info->mask + 2;\n\t\tinfo->mask_en = info->mask + 1;\n\t\tinfo->mask_mask = info->mask - 1;\n\n\t\treturn BP_RESULT_OK;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic struct device_id device_type_from_device_id(uint16_t device_id)\n{\n\n\tstruct device_id result_device_id;\n\n\tresult_device_id.raw_device_tag = device_id;\n\n\tswitch (device_id) {\n\tcase ATOM_DISPLAY_LCD1_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_LCD;\n\t\tresult_device_id.enum_id = 1;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_LCD2_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_LCD;\n\t\tresult_device_id.enum_id = 2;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP1_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 1;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP2_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 2;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP3_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 3;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP4_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 4;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP5_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 5;\n\t\tbreak;\n\n\tcase ATOM_DISPLAY_DFP6_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 6;\n\t\tbreak;\n\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();  \n\t\tresult_device_id.device_type = DEVICE_TYPE_UNKNOWN;\n\t\tresult_device_id.enum_id = 0;\n\t}\n\treturn result_device_id;\n}\n\nstatic enum bp_result bios_parser_get_device_tag(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id connector_object_id,\n\tuint32_t device_tag_index,\n\tstruct connector_device_tag_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_display_object_path_v2 *object;\n\n\tstruct atom_display_object_path_v3 *object_path_v3;\n\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\tcase 4:\n\tdefault:\n\t         \n\t\tobject = get_bios_object(bp, connector_object_id);\n\n\t\tif (!object) {\n\t\t\tBREAK_TO_DEBUGGER();  \n\t\t\treturn BP_RESULT_BADINPUT;\n\t\t}\n\n\t\tinfo->acpi_device = 0;  \n\t\tinfo->dev_id = device_type_from_device_id(object->device_tag);\n\t\tbreak;\n\tcase 5:\n\t\tobject_path_v3 = get_bios_object_from_path_v3(bp, connector_object_id);\n\n\t\tif (!object_path_v3) {\n\t\t\tBREAK_TO_DEBUGGER();  \n\t\t\treturn BP_RESULT_BADINPUT;\n\t\t}\n\t\tinfo->acpi_device = 0;  \n\t\tinfo->dev_id = device_type_from_device_id(object_path_v3->device_tag);\n\t\tbreak;\n\t}\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_ss_info_v4_1(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_1 *disp_cntl_tbl = NULL;\n\tstruct atom_smu_info_v3_3 *smu_info = NULL;\n\n\tif (!ss_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl =  GET_IMAGE(struct atom_display_controller_info_v4_1,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\n\tss_info->type.STEP_AND_DELAY_INFO = false;\n\tss_info->spread_percentage_divider = 1000;\n\t \n\tss_info->target_clock_range = 0xffffffff;\n\n\tswitch (id) {\n\tcase AS_SIGNAL_TYPE_DVI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->dvi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DVI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_HDMI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->hdmi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_HDMI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\t \n\tcase AS_SIGNAL_TYPE_DISPLAY_PORT:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->dp_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->dp_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->dp_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DISPLAY_PORT ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_GPU_PLL:\n\t\t \n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_XGMI:\n\t\tsmu_info =  GET_IMAGE(struct atom_smu_info_v3_3,\n\t\t\t\t      DATA_TABLES(smu_info));\n\t\tif (!smu_info)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\t\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", smu_info->gpuclk_ss_percentage);\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tsmu_info->waflclk_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tsmu_info->gpuclk_ss_rate_10hz * 10;\n\t\tif (smu_info->waflclk_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_XGMI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tdefault:\n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result get_ss_info_v4_2(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_2 *disp_cntl_tbl = NULL;\n\tstruct atom_smu_info_v3_1 *smu_info = NULL;\n\n\tif (!ss_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (!DATA_TABLES(smu_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl =  GET_IMAGE(struct atom_display_controller_info_v4_2,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tsmu_info =  GET_IMAGE(struct atom_smu_info_v3_1, DATA_TABLES(smu_info));\n\tif (!smu_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", smu_info->gpuclk_ss_percentage);\n\tss_info->type.STEP_AND_DELAY_INFO = false;\n\tss_info->spread_percentage_divider = 1000;\n\t \n\tss_info->target_clock_range = 0xffffffff;\n\n\tswitch (id) {\n\tcase AS_SIGNAL_TYPE_DVI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->dvi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DVI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_HDMI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->hdmi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_HDMI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\t \n\tcase AS_SIGNAL_TYPE_DISPLAY_PORT:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tsmu_info->gpuclk_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tsmu_info->gpuclk_ss_rate_10hz * 10;\n\t\tif (smu_info->gpuclk_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DISPLAY_PORT ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_GPU_PLL:\n\t\t \n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t\tbreak;\n\tdefault:\n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result get_ss_info_v4_5(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_5 *disp_cntl_tbl = NULL;\n\n\tif (!ss_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl =  GET_IMAGE(struct atom_display_controller_info_v4_5,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tss_info->type.STEP_AND_DELAY_INFO = false;\n\tss_info->spread_percentage_divider = 1000;\n\t \n\tss_info->target_clock_range = 0xffffffff;\n\n\tswitch (id) {\n\tcase AS_SIGNAL_TYPE_DVI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->dvi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->dvi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DVI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_HDMI:\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_percentage;\n\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->hdmi_ss_rate_10hz * 10;\n\t\tif (disp_cntl_tbl->hdmi_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_HDMI ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_DISPLAY_PORT:\n\t\tif (bp->base.integrated_info) {\n\t\t\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", bp->base.integrated_info->gpuclk_ss_percentage);\n\t\t\tss_info->spread_spectrum_percentage =\n\t\t\t\t\tbp->base.integrated_info->gpuclk_ss_percentage;\n\t\t\tss_info->type.CENTER_MODE =\n\t\t\t\t\tbp->base.integrated_info->gpuclk_ss_type;\n\t\t} else {\n\t\t\tss_info->spread_spectrum_percentage =\n\t\t\t\tdisp_cntl_tbl->dp_ss_percentage;\n\t\t\tss_info->spread_spectrum_range =\n\t\t\t\tdisp_cntl_tbl->dp_ss_rate_10hz * 10;\n\t\t\tif (disp_cntl_tbl->dp_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)\n\t\t\t\tss_info->type.CENTER_MODE = true;\n\t\t}\n\t\tDC_LOG_BIOS(\"AS_SIGNAL_TYPE_DISPLAY_PORT ss_percentage: %d\\n\", ss_info->spread_spectrum_percentage);\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_GPU_PLL:\n\t\t \n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t\tbreak;\n\tdefault:\n\t\tresult = BP_RESULT_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nstatic enum bp_result bios_parser_get_spread_spectrum_info(\n\tstruct dc_bios *dcb,\n\tenum as_signal_type signal,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!ss_info)  \n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tget_atom_data_table_revision(header, &tbl_revision);\n\n\tswitch (tbl_revision.major) {\n\tcase 4:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\treturn get_ss_info_v4_1(bp, signal, index, ss_info);\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\t\treturn get_ss_info_v4_2(bp, signal, index, ss_info);\n\t\tcase 5:\n\t\t\treturn get_ss_info_v4_5(bp, signal, index, ss_info);\n\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\treturn result;\n}\n\nstatic enum bp_result get_soc_bb_info_v4_4(\n\tstruct bios_parser *bp,\n\tstruct bp_soc_bb_info *soc_bb_info)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_4 *disp_cntl_tbl = NULL;\n\n\tif (!soc_bb_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (!DATA_TABLES(smu_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl =  GET_IMAGE(struct atom_display_controller_info_v4_4,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tsoc_bb_info->dram_clock_change_latency_100ns = disp_cntl_tbl->max_mclk_chg_lat;\n\tsoc_bb_info->dram_sr_enter_exit_latency_100ns = disp_cntl_tbl->max_sr_enter_exit_lat;\n\tsoc_bb_info->dram_sr_exit_latency_100ns = disp_cntl_tbl->max_sr_exit_lat;\n\n\treturn result;\n}\n\nstatic enum bp_result get_soc_bb_info_v4_5(\n\tstruct bios_parser *bp,\n\tstruct bp_soc_bb_info *soc_bb_info)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_5 *disp_cntl_tbl = NULL;\n\n\tif (!soc_bb_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl =  GET_IMAGE(struct atom_display_controller_info_v4_5,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tsoc_bb_info->dram_clock_change_latency_100ns = disp_cntl_tbl->max_mclk_chg_lat;\n\tsoc_bb_info->dram_sr_enter_exit_latency_100ns = disp_cntl_tbl->max_sr_enter_exit_lat;\n\tsoc_bb_info->dram_sr_exit_latency_100ns = disp_cntl_tbl->max_sr_exit_lat;\n\n\treturn result;\n}\n\nstatic enum bp_result bios_parser_get_soc_bb_info(\n\tstruct dc_bios *dcb,\n\tstruct bp_soc_bb_info *soc_bb_info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!soc_bb_info)  \n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tget_atom_data_table_revision(header, &tbl_revision);\n\n\tswitch (tbl_revision.major) {\n\tcase 4:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresult = get_soc_bb_info_v4_4(bp, soc_bb_info);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresult = get_soc_bb_info_v4_5(bp, soc_bb_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result get_disp_caps_v4_1(\n\tstruct bios_parser *bp,\n\tuint8_t *dce_caps)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_1 *disp_cntl_tbl = NULL;\n\n\tif (!dce_caps)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl = GET_IMAGE(struct atom_display_controller_info_v4_1,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t*dce_caps = disp_cntl_tbl->display_caps;\n\n\treturn result;\n}\n\nstatic enum bp_result get_disp_caps_v4_2(\n\tstruct bios_parser *bp,\n\tuint8_t *dce_caps)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_2 *disp_cntl_tbl = NULL;\n\n\tif (!dce_caps)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl = GET_IMAGE(struct atom_display_controller_info_v4_2,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t*dce_caps = disp_cntl_tbl->display_caps;\n\n\treturn result;\n}\n\nstatic enum bp_result get_disp_caps_v4_3(\n\tstruct bios_parser *bp,\n\tuint8_t *dce_caps)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_3 *disp_cntl_tbl = NULL;\n\n\tif (!dce_caps)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl = GET_IMAGE(struct atom_display_controller_info_v4_3,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t*dce_caps = disp_cntl_tbl->display_caps;\n\n\treturn result;\n}\n\nstatic enum bp_result get_disp_caps_v4_4(\n\tstruct bios_parser *bp,\n\tuint8_t *dce_caps)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_4 *disp_cntl_tbl = NULL;\n\n\tif (!dce_caps)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl = GET_IMAGE(struct atom_display_controller_info_v4_4,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t*dce_caps = disp_cntl_tbl->display_caps;\n\n\treturn result;\n}\n\nstatic enum bp_result get_disp_caps_v4_5(\n\tstruct bios_parser *bp,\n\tuint8_t *dce_caps)\n{\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_display_controller_info_v4_5 *disp_cntl_tbl = NULL;\n\n\tif (!dce_caps)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tdisp_cntl_tbl = GET_IMAGE(struct atom_display_controller_info_v4_5,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tif (!disp_cntl_tbl)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t*dce_caps = disp_cntl_tbl->display_caps;\n\n\treturn result;\n}\n\nstatic enum bp_result bios_parser_get_lttpr_interop(\n\tstruct dc_bios *dcb,\n\tuint8_t *dce_caps)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tget_atom_data_table_revision(header, &tbl_revision);\n\tswitch (tbl_revision.major) {\n\tcase 4:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\tresult = get_disp_caps_v4_1(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = get_disp_caps_v4_2(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tresult = get_disp_caps_v4_3(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresult = get_disp_caps_v4_4(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresult = get_disp_caps_v4_5(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tDC_LOG_BIOS(\"DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE: %d tbl_revision.major = %d tbl_revision.minor = %d\\n\", *dce_caps, tbl_revision.major, tbl_revision.minor);\n\treturn result;\n}\n\nstatic enum bp_result bios_parser_get_lttpr_caps(\n\tstruct dc_bios *dcb,\n\tuint8_t *dce_caps)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\t*dce_caps  = 0;\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tget_atom_data_table_revision(header, &tbl_revision);\n\tswitch (tbl_revision.major) {\n\tcase 4:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\tresult = get_disp_caps_v4_1(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = get_disp_caps_v4_2(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tresult = get_disp_caps_v4_3(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresult = get_disp_caps_v4_4(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresult = get_disp_caps_v4_5(bp, dce_caps);\n\t\t\t*dce_caps = !!(*dce_caps & DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tDC_LOG_BIOS(\"DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE: %d tbl_revision.major = %d tbl_revision.minor = %d\\n\", *dce_caps, tbl_revision.major, tbl_revision.minor);\n\tif (dcb->ctx->dc->config.force_bios_enable_lttpr && *dce_caps == 0) {\n\t\t*dce_caps = 1;\n\t\tDC_LOG_BIOS(\"DCE_INFO_CAPS_VBIOS_LTTPR_TRANSPARENT_ENABLE: forced enabled\");\n\t}\n\treturn result;\n}\n\nstatic enum bp_result get_embedded_panel_info_v2_1(\n\t\tstruct bios_parser *bp,\n\t\tstruct embedded_panel_info *info)\n{\n\tstruct lcd_info_v2_1 *lvds;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(lcd_info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tlvds = GET_IMAGE(struct lcd_info_v2_1, DATA_TABLES(lcd_info));\n\n\tif (!lvds)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t \n\tif (!((lvds->table_header.format_revision == 2)\n\t\t\t&& (lvds->table_header.content_revision >= 1)))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tmemset(info, 0, sizeof(struct embedded_panel_info));\n\n\t \n\tinfo->lcd_timing.pixel_clk = le16_to_cpu(lvds->lcd_timing.pixclk) * 10;\n\t \n\tinfo->lcd_timing.horizontal_addressable = le16_to_cpu(lvds->lcd_timing.h_active);\n\t \n\tinfo->lcd_timing.horizontal_blanking_time = le16_to_cpu(lvds->lcd_timing.h_blanking_time);\n\t \n\tinfo->lcd_timing.vertical_addressable = le16_to_cpu(lvds->lcd_timing.v_active);\n\t \n\tinfo->lcd_timing.vertical_blanking_time = le16_to_cpu(lvds->lcd_timing.v_blanking_time);\n\tinfo->lcd_timing.horizontal_sync_offset = le16_to_cpu(lvds->lcd_timing.h_sync_offset);\n\tinfo->lcd_timing.horizontal_sync_width = le16_to_cpu(lvds->lcd_timing.h_sync_width);\n\tinfo->lcd_timing.vertical_sync_offset = le16_to_cpu(lvds->lcd_timing.v_sync_offset);\n\tinfo->lcd_timing.vertical_sync_width = le16_to_cpu(lvds->lcd_timing.v_syncwidth);\n\tinfo->lcd_timing.horizontal_border = lvds->lcd_timing.h_border;\n\tinfo->lcd_timing.vertical_border = lvds->lcd_timing.v_border;\n\n\t \n\tinfo->lcd_timing.misc_info.HORIZONTAL_CUT_OFF = 0;\n\n\tinfo->lcd_timing.misc_info.H_SYNC_POLARITY = ~(uint32_t) (lvds->lcd_timing.miscinfo\n\t\t\t& ATOM_HSYNC_POLARITY);\n\tinfo->lcd_timing.misc_info.V_SYNC_POLARITY = ~(uint32_t) (lvds->lcd_timing.miscinfo\n\t\t\t& ATOM_VSYNC_POLARITY);\n\n\t \n\tinfo->lcd_timing.misc_info.VERTICAL_CUT_OFF = 0;\n\n\tinfo->lcd_timing.misc_info.H_REPLICATION_BY2 = !!(lvds->lcd_timing.miscinfo\n\t\t\t& ATOM_H_REPLICATIONBY2);\n\tinfo->lcd_timing.misc_info.V_REPLICATION_BY2 = !!(lvds->lcd_timing.miscinfo\n\t\t\t& ATOM_V_REPLICATIONBY2);\n\tinfo->lcd_timing.misc_info.COMPOSITE_SYNC = !!(lvds->lcd_timing.miscinfo\n\t\t\t& ATOM_COMPOSITESYNC);\n\tinfo->lcd_timing.misc_info.INTERLACE = !!(lvds->lcd_timing.miscinfo & ATOM_INTERLACE);\n\n\t \n\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = 0;\n\t \n\tinfo->ss_id = 0;\n\n\tinfo->realtek_eDPToLVDS = !!(lvds->dplvdsrxid == eDP_TO_LVDS_REALTEK_ID);\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result bios_parser_get_embedded_panel_info(\n\t\tstruct dc_bios *dcb,\n\t\tstruct embedded_panel_info *info)\n{\n\tstruct bios_parser\n\t*bp = BP_FROM_DCB(dcb);\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!DATA_TABLES(lcd_info))\n\t\treturn BP_RESULT_FAILURE;\n\n\theader = GET_IMAGE(struct atom_common_table_header, DATA_TABLES(lcd_info));\n\n\tif (!header)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tget_atom_data_table_revision(header, &tbl_revision);\n\n\tswitch (tbl_revision.major) {\n\tcase 2:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\treturn get_embedded_panel_info_v2_1(bp, info);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\nstatic uint32_t get_support_mask_for_device_id(struct device_id device_id)\n{\n\tenum dal_device_type device_type = device_id.device_type;\n\tuint32_t enum_id = device_id.enum_id;\n\n\tswitch (device_type) {\n\tcase DEVICE_TYPE_LCD:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DISPLAY_LCD1_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DEVICE_TYPE_DFP:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DISPLAY_DFP1_SUPPORT;\n\t\tcase 2:\n\t\t\treturn ATOM_DISPLAY_DFP2_SUPPORT;\n\t\tcase 3:\n\t\t\treturn ATOM_DISPLAY_DFP3_SUPPORT;\n\t\tcase 4:\n\t\t\treturn ATOM_DISPLAY_DFP4_SUPPORT;\n\t\tcase 5:\n\t\t\treturn ATOM_DISPLAY_DFP5_SUPPORT;\n\t\tcase 6:\n\t\t\treturn ATOM_DISPLAY_DFP6_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic bool bios_parser_is_device_id_supported(\n\tstruct dc_bios *dcb,\n\tstruct device_id id)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tuint32_t mask = get_support_mask_for_device_id(id);\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\tcase 4:\n\tdefault:\n\t\treturn (le16_to_cpu(bp->object_info_tbl.v1_4->supporteddevices) & mask) != 0;\n\t\tbreak;\n\tcase 5:\n\t\treturn (le16_to_cpu(bp->object_info_tbl.v1_5->supporteddevices) & mask) != 0;\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic uint32_t bios_parser_get_ss_entry_number(\n\tstruct dc_bios *dcb,\n\tenum as_signal_type signal)\n{\n\t \n\treturn 1;\n}\n\nstatic enum bp_result bios_parser_transmitter_control(\n\tstruct dc_bios *dcb,\n\tstruct bp_transmitter_control *cntl)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.transmitter_control)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.transmitter_control(bp, cntl);\n}\n\nstatic enum bp_result bios_parser_encoder_control(\n\tstruct dc_bios *dcb,\n\tstruct bp_encoder_control *cntl)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.dig_encoder_control)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.dig_encoder_control(bp, cntl);\n}\n\nstatic enum bp_result bios_parser_set_pixel_clock(\n\tstruct dc_bios *dcb,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_pixel_clock)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_pixel_clock(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_set_dce_clock(\n\tstruct dc_bios *dcb,\n\tstruct bp_set_dce_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_dce_clock)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_dce_clock(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_program_crtc_timing(\n\tstruct dc_bios *dcb,\n\tstruct bp_hw_crtc_timing_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_crtc_timing)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_crtc_timing(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_enable_crtc(\n\tstruct dc_bios *dcb,\n\tenum controller_id id,\n\tbool enable)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_crtc)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_crtc(bp, id, enable);\n}\n\nstatic enum bp_result bios_parser_enable_disp_power_gating(\n\tstruct dc_bios *dcb,\n\tenum controller_id controller_id,\n\tenum bp_pipe_control_action action)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_disp_power_gating)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_disp_power_gating(bp, controller_id,\n\t\taction);\n}\n\nstatic enum bp_result bios_parser_enable_lvtma_control(\n\tstruct dc_bios *dcb,\n\tuint8_t uc_pwr_on,\n\tuint8_t pwrseq_instance,\n\tuint8_t bypass_panel_control_wait)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_lvtma_control)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_lvtma_control(bp, uc_pwr_on, pwrseq_instance, bypass_panel_control_wait);\n}\n\nstatic bool bios_parser_is_accelerated_mode(\n\tstruct dc_bios *dcb)\n{\n\treturn bios_is_accelerated_mode(dcb);\n}\n\n \nstatic void bios_parser_set_scratch_critical_state(\n\tstruct dc_bios *dcb,\n\tbool state)\n{\n\tbios_set_scratch_critical_state(dcb, state);\n}\n\nstruct atom_dig_transmitter_info_header_v5_3 {\n    struct atom_common_table_header table_header;\n    uint16_t dpphy_hdmi_settings_offset;\n    uint16_t dpphy_dvi_settings_offset;\n    uint16_t dpphy_dp_setting_table_offset;\n    uint16_t uniphy_xbar_settings_v2_table_offset;\n    uint16_t dpphy_internal_reg_overide_offset;\n};\n\nstatic enum bp_result bios_parser_get_firmware_info(\n\tstruct dc_bios *dcb,\n\tstruct dc_firmware_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstatic enum bp_result result = BP_RESULT_BADBIOSTABLE;\n\tstruct atom_common_table_header *header;\n\n\tstruct atom_data_revision revision;\n\n\tif (info && DATA_TABLES(firmwareinfo)) {\n\t\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\tDATA_TABLES(firmwareinfo));\n\t\tget_atom_data_table_revision(header, &revision);\n\t\tswitch (revision.major) {\n\t\tcase 3:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 1:\n\t\t\t\tresult = get_firmware_info_v3_1(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tresult = get_firmware_info_v3_2(bp, info);\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tresult = get_firmware_info_v3_4(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result get_firmware_info_v3_1(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tstruct atom_firmware_info_v3_1 *firmware_info;\n\tstruct atom_display_controller_info_v4_1 *dce_info = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tfirmware_info = GET_IMAGE(struct atom_firmware_info_v3_1,\n\t\t\tDATA_TABLES(firmwareinfo));\n\n\tdce_info = GET_IMAGE(struct atom_display_controller_info_v4_1,\n\t\t\tDATA_TABLES(dce_info));\n\n\tif (!firmware_info || !dce_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\t  \n\tinfo->default_memory_clk = firmware_info->bootup_mclk_in10khz * 10;\n\tinfo->default_engine_clk = firmware_info->bootup_sclk_in10khz * 10;\n\n\t  \n\tinfo->pll_info.crystal_frequency = dce_info->dce_refclk_10khz * 10;\n\n\t \n\tif (info->pll_info.crystal_frequency == 0)\n\t\tinfo->pll_info.crystal_frequency = 27000;\n\t \n\tinfo->dp_phy_ref_clk     = dce_info->dpphy_refclk_10khz * 10;\n\tinfo->i2c_engine_ref_clk = dce_info->i2c_engine_refclk_10khz * 10;\n\n\t \n\n\tif (bp->cmd_tbl.get_smu_clock_info != NULL) {\n\t\t \n\t\tinfo->smu_gpu_pll_output_freq =\n\t\t\t\tbp->cmd_tbl.get_smu_clock_info(bp, SMU9_SYSPLL0_ID) * 10;\n\t}\n\n\tinfo->oem_i2c_present = false;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_firmware_info_v3_2(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tstruct atom_firmware_info_v3_2 *firmware_info;\n\tstruct atom_display_controller_info_v4_1 *dce_info = NULL;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision revision;\n\tstruct atom_smu_info_v3_2 *smu_info_v3_2 = NULL;\n\tstruct atom_smu_info_v3_3 *smu_info_v3_3 = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tfirmware_info = GET_IMAGE(struct atom_firmware_info_v3_2,\n\t\t\tDATA_TABLES(firmwareinfo));\n\n\tdce_info = GET_IMAGE(struct atom_display_controller_info_v4_1,\n\t\t\tDATA_TABLES(dce_info));\n\n\tif (!firmware_info || !dce_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(smu_info));\n\tget_atom_data_table_revision(header, &revision);\n\n\tif (revision.minor == 2) {\n\t\t \n\t\tsmu_info_v3_2 = GET_IMAGE(struct atom_smu_info_v3_2,\n\t\t\t\t\t\t\tDATA_TABLES(smu_info));\n\t\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", smu_info_v3_2->gpuclk_ss_percentage);\n\t\tif (!smu_info_v3_2)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\tinfo->default_engine_clk = smu_info_v3_2->bootup_dcefclk_10khz * 10;\n\t} else if (revision.minor == 3) {\n\t\t \n\t\tsmu_info_v3_3 = GET_IMAGE(struct atom_smu_info_v3_3,\n\t\t\t\t\t\t\tDATA_TABLES(smu_info));\n\t\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", smu_info_v3_3->gpuclk_ss_percentage);\n\t\tif (!smu_info_v3_3)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\tinfo->default_engine_clk = smu_info_v3_3->bootup_dcefclk_10khz * 10;\n\t}\n\n\t  \n\tinfo->default_memory_clk = firmware_info->bootup_mclk_in10khz * 10;\n\n\t  \n\tinfo->pll_info.crystal_frequency = dce_info->dce_refclk_10khz * 10;\n\t \n\tif (info->pll_info.crystal_frequency == 0) {\n\t\tif (revision.minor == 2)\n\t\t\tinfo->pll_info.crystal_frequency = 27000;\n\t\telse if (revision.minor == 3)\n\t\t\tinfo->pll_info.crystal_frequency = 100000;\n\t}\n\t \n\tinfo->dp_phy_ref_clk     = dce_info->dpphy_refclk_10khz * 10;\n\tinfo->i2c_engine_ref_clk = dce_info->i2c_engine_refclk_10khz * 10;\n\n\t \n\tif (bp->cmd_tbl.get_smu_clock_info != NULL) {\n\t\tif (revision.minor == 2)\n\t\t\tinfo->smu_gpu_pll_output_freq =\n\t\t\t\t\tbp->cmd_tbl.get_smu_clock_info(bp, SMU9_SYSPLL0_ID) * 10;\n\t\telse if (revision.minor == 3)\n\t\t\tinfo->smu_gpu_pll_output_freq =\n\t\t\t\t\tbp->cmd_tbl.get_smu_clock_info(bp, SMU11_SYSPLL3_0_ID) * 10;\n\t}\n\n\tif (firmware_info->board_i2c_feature_id == 0x2) {\n\t\tinfo->oem_i2c_present = true;\n\t\tinfo->oem_i2c_obj_id = firmware_info->board_i2c_feature_gpio_id;\n\t} else {\n\t\tinfo->oem_i2c_present = false;\n\t}\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_firmware_info_v3_4(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tstruct atom_firmware_info_v3_4 *firmware_info;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision revision;\n\tstruct atom_display_controller_info_v4_1 *dce_info_v4_1 = NULL;\n\tstruct atom_display_controller_info_v4_4 *dce_info_v4_4 = NULL;\n\n\tstruct atom_smu_info_v3_5 *smu_info_v3_5 = NULL;\n\tstruct atom_display_controller_info_v4_5 *dce_info_v4_5 = NULL;\n\tstruct atom_smu_info_v4_0 *smu_info_v4_0 = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tfirmware_info = GET_IMAGE(struct atom_firmware_info_v3_4,\n\t\t\tDATA_TABLES(firmwareinfo));\n\n\tif (!firmware_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(dce_info));\n\n\tget_atom_data_table_revision(header, &revision);\n\n\tswitch (revision.major) {\n\tcase 4:\n\t\tswitch (revision.minor) {\n\t\tcase 5:\n\t\t\tdce_info_v4_5 = GET_IMAGE(struct atom_display_controller_info_v4_5,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\t\t\tif (!dce_info_v4_5)\n\t\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\t\t  \n\t\t\tinfo->pll_info.crystal_frequency = dce_info_v4_5->dce_refclk_10khz * 10;\n\t\t\tinfo->dp_phy_ref_clk             = dce_info_v4_5->dpphy_refclk_10khz * 10;\n\t\t\t  \n\t\t\tinfo->i2c_engine_ref_clk         = dce_info_v4_5->i2c_engine_refclk_10khz * 10;\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdce_info_v4_4 = GET_IMAGE(struct atom_display_controller_info_v4_4,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\t\t\tif (!dce_info_v4_4)\n\t\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\t\t \n\t\t\tinfo->pll_info.crystal_frequency = dce_info_v4_4->dce_refclk_10khz * 10;\n\t\t\tinfo->dp_phy_ref_clk             = dce_info_v4_4->dpphy_refclk_10khz * 10;\n\t\t\t \n\t\t\tinfo->i2c_engine_ref_clk         = dce_info_v4_4->i2c_engine_refclk_10khz * 10;\n\n\t\t\t \n\t\t\tinfo->smu_gpu_pll_output_freq =\tdce_info_v4_4->dispclk_pll_vco_freq * 10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tdce_info_v4_1 = GET_IMAGE(struct atom_display_controller_info_v4_1,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\n\t\t\tif (!dce_info_v4_1)\n\t\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\t\tinfo->pll_info.crystal_frequency = dce_info_v4_1->dce_refclk_10khz * 10;\n\t\t\tinfo->dp_phy_ref_clk             = dce_info_v4_1->dpphy_refclk_10khz * 10;\n\t\t\tinfo->i2c_engine_ref_clk         = dce_info_v4_1->i2c_engine_refclk_10khz * 10;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(smu_info));\n\tget_atom_data_table_revision(header, &revision);\n\n\tswitch (revision.major) {\n\tcase 3:\n\t\tswitch (revision.minor) {\n\t\tcase 5:\n\t\t\tsmu_info_v3_5 = GET_IMAGE(struct atom_smu_info_v3_5,\n\t\t\t\t\t\t\tDATA_TABLES(smu_info));\n\n\t\t\tif (!smu_info_v3_5)\n\t\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\t\t\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", smu_info_v3_5->gpuclk_ss_percentage);\n\t\t\tinfo->default_engine_clk = smu_info_v3_5->bootup_dcefclk_10khz * 10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (revision.minor) {\n\t\tcase 0:\n\t\t\tsmu_info_v4_0 = GET_IMAGE(struct atom_smu_info_v4_0,\n\t\t\t\t\t\t\tDATA_TABLES(smu_info));\n\n\t\t\tif (!smu_info_v4_0)\n\t\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tinfo->default_memory_clk = firmware_info->bootup_mclk_in10khz * 10;\n\n\tif (firmware_info->board_i2c_feature_id == 0x2) {\n\t\tinfo->oem_i2c_present = true;\n\t\tinfo->oem_i2c_obj_id = firmware_info->board_i2c_feature_gpio_id;\n\t} else {\n\t\tinfo->oem_i2c_present = false;\n\t}\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result bios_parser_get_encoder_cap_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id object_id,\n\tstruct bp_encoder_cap_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_display_object_path_v2 *object;\n\tstruct atom_encoder_caps_record *record = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\t \n\tif (bp->object_info_tbl.revision.minor == 5)\n\t\treturn BP_RESULT_NORECORD;\n#endif\n\n\tobject = get_bios_object(bp, object_id);\n\n\tif (!object)\n\t\treturn BP_RESULT_BADINPUT;\n\n\trecord = get_encoder_cap_record(bp, object);\n\tif (!record)\n\t\treturn BP_RESULT_NORECORD;\n\tDC_LOG_BIOS(\"record->encodercaps 0x%x for object_id 0x%x\", record->encodercaps, object_id.id);\n\n\tinfo->DP_HBR2_CAP = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_HBR2) ? 1 : 0;\n\tinfo->DP_HBR2_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_HBR2_EN) ? 1 : 0;\n\tinfo->DP_HBR3_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_HBR3_EN) ? 1 : 0;\n\tinfo->HDMI_6GB_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_HDMI6Gbps_EN) ? 1 : 0;\n\tinfo->IS_DP2_CAPABLE = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_DP2) ? 1 : 0;\n\tinfo->DP_UHBR10_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_UHBR10_EN) ? 1 : 0;\n\tinfo->DP_UHBR13_5_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_UHBR13_5_EN) ? 1 : 0;\n\tinfo->DP_UHBR20_EN = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_UHBR20_EN) ? 1 : 0;\n\tinfo->DP_IS_USB_C = (record->encodercaps &\n\t\t\tATOM_ENCODER_CAP_RECORD_USB_C_TYPE) ? 1 : 0;\n\tDC_LOG_BIOS(\"\\t info->DP_IS_USB_C %d\", info->DP_IS_USB_C);\n\n\treturn BP_RESULT_OK;\n}\n\n\nstatic struct atom_encoder_caps_record *get_encoder_cap_record(\n\tstruct bios_parser *bp,\n\tstruct atom_display_object_path_v2 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = object->encoder_recordoffset + bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\toffset += header->record_size;\n\n\t\tif (header->record_type == LAST_RECORD_TYPE ||\n\t\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type != ATOM_ENCODER_CAP_RECORD_TYPE)\n\t\t\tcontinue;\n\n\t\tif (sizeof(struct atom_encoder_caps_record) <=\n\t\t\t\t\t\t\theader->record_size)\n\t\t\treturn (struct atom_encoder_caps_record *)header;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct atom_disp_connector_caps_record *get_disp_connector_caps_record(\n\tstruct bios_parser *bp,\n\tstruct atom_display_object_path_v2 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = object->disp_recordoffset + bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\toffset += header->record_size;\n\n\t\tif (header->record_type == LAST_RECORD_TYPE ||\n\t\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type != ATOM_DISP_CONNECTOR_CAPS_RECORD_TYPE)\n\t\t\tcontinue;\n\n\t\tif (sizeof(struct atom_disp_connector_caps_record) <=\n\t\t\t\t\t\t\theader->record_size)\n\t\t\treturn (struct atom_disp_connector_caps_record *)header;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct atom_connector_caps_record *get_connector_caps_record(struct bios_parser *bp,\n\t\t\t\t\t\t\t\t    struct atom_display_object_path_v3 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = object->disp_recordoffset + bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\toffset += header->record_size;\n\n\t\tif (header->record_type == ATOM_RECORD_END_TYPE ||\n\t\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type != ATOM_CONNECTOR_CAP_RECORD_TYPE)\n\t\t\tcontinue;\n\n\t\tif (sizeof(struct atom_connector_caps_record) <= header->record_size)\n\t\t\treturn (struct atom_connector_caps_record *)header;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum bp_result bios_parser_get_disp_connector_caps_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id object_id,\n\tstruct bp_disp_connector_caps_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_display_object_path_v2 *object;\n\n\tstruct atom_display_object_path_v3 *object_path_v3;\n\tstruct atom_connector_caps_record *record_path_v3;\n\n\tstruct atom_disp_connector_caps_record *record = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tswitch (bp->object_info_tbl.revision.minor) {\n\tcase 4:\n\t    default:\n\t\t    object = get_bios_object(bp, object_id);\n\n\t\t    if (!object)\n\t\t\t    return BP_RESULT_BADINPUT;\n\n\t\t    record = get_disp_connector_caps_record(bp, object);\n\t\t    if (!record)\n\t\t\t    return BP_RESULT_NORECORD;\n\n\t\t    info->INTERNAL_DISPLAY =\n\t\t\t    (record->connectcaps & ATOM_CONNECTOR_CAP_INTERNAL_DISPLAY) ? 1 : 0;\n\t\t    info->INTERNAL_DISPLAY_BL =\n\t\t\t    (record->connectcaps & ATOM_CONNECTOR_CAP_INTERNAL_DISPLAY_BL) ? 1 : 0;\n\t\t    break;\n\t    case 5:\n\t\tobject_path_v3 = get_bios_object_from_path_v3(bp, object_id);\n\n\t\tif (!object_path_v3)\n\t\t\treturn BP_RESULT_BADINPUT;\n\n\t\trecord_path_v3 = get_connector_caps_record(bp, object_path_v3);\n\t\tif (!record_path_v3)\n\t\t\treturn BP_RESULT_NORECORD;\n\n\t\tinfo->INTERNAL_DISPLAY = (record_path_v3->connector_caps & ATOM_CONNECTOR_CAP_INTERNAL_DISPLAY)\n\t\t\t\t\t\t\t\t\t? 1 : 0;\n\t\tinfo->INTERNAL_DISPLAY_BL = (record_path_v3->connector_caps & ATOM_CONNECTOR_CAP_INTERNAL_DISPLAY_BL)\n\t\t\t\t\t\t\t\t\t\t? 1 : 0;\n\t\tbreak;\n\t}\n\n\treturn BP_RESULT_OK;\n}\n\nstatic struct atom_connector_speed_record *get_connector_speed_cap_record(struct bios_parser *bp,\n\t\t\t\t\t\t\t\t\t  struct atom_display_object_path_v3 *object)\n{\n\tstruct atom_common_record_header *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = object->disp_recordoffset + bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(struct atom_common_record_header, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\toffset += header->record_size;\n\n\t\tif (header->record_type == ATOM_RECORD_END_TYPE ||\n\t\t\t\t!header->record_size)\n\t\t\tbreak;\n\n\t\tif (header->record_type != ATOM_CONNECTOR_SPEED_UPTO)\n\t\t\tcontinue;\n\n\t\tif (sizeof(struct atom_connector_speed_record) <= header->record_size)\n\t\t\treturn (struct atom_connector_speed_record *)header;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum bp_result bios_parser_get_connector_speed_cap_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id object_id,\n\tstruct bp_connector_speed_cap_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct atom_display_object_path_v3 *object_path_v3;\n\t\n\tstruct atom_connector_speed_record *record;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tobject_path_v3 = get_bios_object_from_path_v3(bp, object_id);\n\n\tif (!object_path_v3)\n\t\treturn BP_RESULT_BADINPUT;\n\n\trecord = get_connector_speed_cap_record(bp, object_path_v3);\n\tif (!record)\n\t\treturn BP_RESULT_NORECORD;\n\n\tinfo->DP_HBR2_EN = (record->connector_max_speed >= 5400) ? 1 : 0;\n\tinfo->DP_HBR3_EN = (record->connector_max_speed >= 8100) ? 1 : 0;\n\tinfo->HDMI_6GB_EN = (record->connector_max_speed >= 5940) ? 1 : 0;\n\tinfo->DP_UHBR10_EN = (record->connector_max_speed >= 10000) ? 1 : 0;\n\tinfo->DP_UHBR13_5_EN = (record->connector_max_speed >= 13500) ? 1 : 0;\n\tinfo->DP_UHBR20_EN = (record->connector_max_speed >= 20000) ? 1 : 0;\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_vram_info_v23(\n\tstruct bios_parser *bp,\n\tstruct dc_vram_info *info)\n{\n\tstruct atom_vram_info_header_v2_3 *info_v23;\n\tstatic enum bp_result result = BP_RESULT_OK;\n\n\tinfo_v23 = GET_IMAGE(struct atom_vram_info_header_v2_3,\n\t\t\t\t\t\tDATA_TABLES(vram_info));\n\n\tif (info_v23 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->num_chans = info_v23->vram_module[0].channel_num;\n\tinfo->dram_channel_width_bytes = (1 << info_v23->vram_module[0].channel_width) / 8;\n\n\treturn result;\n}\n\nstatic enum bp_result get_vram_info_v24(\n\tstruct bios_parser *bp,\n\tstruct dc_vram_info *info)\n{\n\tstruct atom_vram_info_header_v2_4 *info_v24;\n\tstatic enum bp_result result = BP_RESULT_OK;\n\n\tinfo_v24 = GET_IMAGE(struct atom_vram_info_header_v2_4,\n\t\t\t\t\t\tDATA_TABLES(vram_info));\n\n\tif (info_v24 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->num_chans = info_v24->vram_module[0].channel_num;\n\tinfo->dram_channel_width_bytes = (1 << info_v24->vram_module[0].channel_width) / 8;\n\n\treturn result;\n}\n\nstatic enum bp_result get_vram_info_v25(\n\tstruct bios_parser *bp,\n\tstruct dc_vram_info *info)\n{\n\tstruct atom_vram_info_header_v2_5 *info_v25;\n\tstatic enum bp_result result = BP_RESULT_OK;\n\n\tinfo_v25 = GET_IMAGE(struct atom_vram_info_header_v2_5,\n\t\t\t\t\t\tDATA_TABLES(vram_info));\n\n\tif (info_v25 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->num_chans = info_v25->vram_module[0].channel_num;\n\tinfo->dram_channel_width_bytes = (1 << info_v25->vram_module[0].channel_width) / 8;\n\n\treturn result;\n}\n\nstatic enum bp_result get_vram_info_v30(\n\tstruct bios_parser *bp,\n\tstruct dc_vram_info *info)\n{\n\tstruct atom_vram_info_header_v3_0 *info_v30;\n\tenum bp_result result = BP_RESULT_OK;\n\n\tinfo_v30 = GET_IMAGE(struct atom_vram_info_header_v3_0,\n\t\t\t\t\t\tDATA_TABLES(vram_info));\n\n\tif (info_v30 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->num_chans = info_v30->channel_num;\n\tinfo->dram_channel_width_bytes = (1 << info_v30->channel_width) / 8;\n\n\treturn result;\n}\n\n\n \nstatic enum bp_result get_integrated_info_v11(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tstruct atom_integrated_system_info_v1_11 *info_v11;\n\tuint32_t i;\n\n\tinfo_v11 = GET_IMAGE(struct atom_integrated_system_info_v1_11,\n\t\t\t\t\tDATA_TABLES(integratedsysteminfo));\n\n\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", info_v11->gpuclk_ss_percentage);\n\tif (info_v11 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->gpu_cap_info =\n\tle32_to_cpu(info_v11->gpucapinfo);\n\t \n\tinfo->system_config = le32_to_cpu(info_v11->system_config);\n\tinfo->cpu_cap_info = le32_to_cpu(info_v11->cpucapinfo);\n\tinfo->memory_type = info_v11->memorytype;\n\tinfo->ma_channel_number = info_v11->umachannelnumber;\n\tinfo->lvds_ss_percentage =\n\tle16_to_cpu(info_v11->lvds_ss_percentage);\n\tinfo->dp_ss_control =\n\tle16_to_cpu(info_v11->reserved1);\n\tinfo->lvds_sspread_rate_in_10hz =\n\tle16_to_cpu(info_v11->lvds_ss_rate_10hz);\n\tinfo->hdmi_ss_percentage =\n\tle16_to_cpu(info_v11->hdmi_ss_percentage);\n\tinfo->hdmi_sspread_rate_in_10hz =\n\tle16_to_cpu(info_v11->hdmi_ss_rate_10hz);\n\tinfo->dvi_ss_percentage =\n\tle16_to_cpu(info_v11->dvi_ss_percentage);\n\tinfo->dvi_sspread_rate_in_10_hz =\n\tle16_to_cpu(info_v11->dvi_ss_rate_10hz);\n\tinfo->lvds_misc = info_v11->lvds_misc;\n\tfor (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {\n\t\tinfo->ext_disp_conn_info.gu_id[i] =\n\t\t\t\tinfo_v11->extdispconninfo.guid[i];\n\t}\n\n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {\n\t\tinfo->ext_disp_conn_info.path[i].device_connector_id =\n\t\tobject_id_from_bios_object_id(\n\t\tle16_to_cpu(info_v11->extdispconninfo.path[i].connectorobjid));\n\n\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id =\n\t\tobject_id_from_bios_object_id(\n\t\t\tle16_to_cpu(\n\t\t\tinfo_v11->extdispconninfo.path[i].ext_encoder_objid));\n\n\t\tinfo->ext_disp_conn_info.path[i].device_tag =\n\t\t\tle16_to_cpu(\n\t\t\t\tinfo_v11->extdispconninfo.path[i].device_tag);\n\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum =\n\t\tle16_to_cpu(\n\t\t\tinfo_v11->extdispconninfo.path[i].device_acpi_enum);\n\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =\n\t\t\tinfo_v11->extdispconninfo.path[i].auxddclut_index;\n\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =\n\t\t\tinfo_v11->extdispconninfo.path[i].hpdlut_index;\n\t\tinfo->ext_disp_conn_info.path[i].channel_mapping.raw =\n\t\t\tinfo_v11->extdispconninfo.path[i].channelmapping;\n\t\tinfo->ext_disp_conn_info.path[i].caps =\n\t\t\t\tle16_to_cpu(info_v11->extdispconninfo.path[i].caps);\n\t}\n\tinfo->ext_disp_conn_info.checksum =\n\tinfo_v11->extdispconninfo.checksum;\n\n\tinfo->dp0_ext_hdmi_slv_addr = info_v11->dp0_retimer_set.HdmiSlvAddr;\n\tinfo->dp0_ext_hdmi_reg_num = info_v11->dp0_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp0_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp0_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp0_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp0_ext_hdmi_6g_reg_num = info_v11->dp0_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp0_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\n\tinfo->dp1_ext_hdmi_slv_addr = info_v11->dp1_retimer_set.HdmiSlvAddr;\n\tinfo->dp1_ext_hdmi_reg_num = info_v11->dp1_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp1_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp1_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp1_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp1_ext_hdmi_6g_reg_num = info_v11->dp1_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp1_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\n\tinfo->dp2_ext_hdmi_slv_addr = info_v11->dp2_retimer_set.HdmiSlvAddr;\n\tinfo->dp2_ext_hdmi_reg_num = info_v11->dp2_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp2_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp2_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp2_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp2_ext_hdmi_6g_reg_num = info_v11->dp2_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp2_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\n\tinfo->dp3_ext_hdmi_slv_addr = info_v11->dp3_retimer_set.HdmiSlvAddr;\n\tinfo->dp3_ext_hdmi_reg_num = info_v11->dp3_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp3_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp3_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp3_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp3_ext_hdmi_6g_reg_num = info_v11->dp3_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp3_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v11->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v11->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\n\n\t \n\t#if 0\n\tinfo->boot_up_engine_clock = le32_to_cpu(info_v11->ulBootUpEngineClock)\n\t\t\t\t\t\t\t\t\t* 10;\n\tinfo->dentist_vco_freq = le32_to_cpu(info_v11->ulDentistVCOFreq) * 10;\n\tinfo->boot_up_uma_clock = le32_to_cpu(info_v8->ulBootUpUMAClock) * 10;\n\n\tfor (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\t \n\t\tinfo->disp_clk_voltage[i].max_supported_clk =\n\t\tle32_to_cpu(info_v11->sDISPCLK_Voltage[i].\n\t\t\tulMaximumSupportedCLK) * 10;\n\t\tinfo->disp_clk_voltage[i].voltage_index =\n\t\tle32_to_cpu(info_v11->sDISPCLK_Voltage[i].ulVoltageIndex);\n\t}\n\n\tinfo->boot_up_req_display_vector =\n\t\t\tle32_to_cpu(info_v11->ulBootUpReqDisplayVector);\n\tinfo->boot_up_nb_voltage =\n\t\t\tle16_to_cpu(info_v11->usBootUpNBVoltage);\n\tinfo->ext_disp_conn_info_offset =\n\t\t\tle16_to_cpu(info_v11->usExtDispConnInfoOffset);\n\tinfo->gmc_restore_reset_time =\n\t\t\tle32_to_cpu(info_v11->ulGMCRestoreResetTime);\n\tinfo->minimum_n_clk =\n\t\t\tle32_to_cpu(info_v11->ulNbpStateNClkFreq[0]);\n\tfor (i = 1; i < 4; ++i)\n\t\tinfo->minimum_n_clk =\n\t\t\t\tinfo->minimum_n_clk <\n\t\t\t\tle32_to_cpu(info_v11->ulNbpStateNClkFreq[i]) ?\n\t\t\t\tinfo->minimum_n_clk : le32_to_cpu(\n\t\t\t\t\tinfo_v11->ulNbpStateNClkFreq[i]);\n\n\tinfo->idle_n_clk = le32_to_cpu(info_v11->ulIdleNClk);\n\tinfo->ddr_dll_power_up_time =\n\t    le32_to_cpu(info_v11->ulDDR_DLL_PowerUpTime);\n\tinfo->ddr_pll_power_up_time =\n\t\tle32_to_cpu(info_v11->ulDDR_PLL_PowerUpTime);\n\tinfo->pcie_clk_ss_type = le16_to_cpu(info_v11->usPCIEClkSSType);\n\tinfo->max_lvds_pclk_freq_in_single_link =\n\t\tle16_to_cpu(info_v11->usMaxLVDSPclkFreqInSingleLink);\n\tinfo->max_lvds_pclk_freq_in_single_link =\n\t\tle16_to_cpu(info_v11->usMaxLVDSPclkFreqInSingleLink);\n\tinfo->lvds_pwr_on_seq_dig_on_to_de_in_4ms =\n\t\tinfo_v11->ucLVDSPwrOnSeqDIGONtoDE_in4Ms;\n\tinfo->lvds_pwr_on_seq_de_to_vary_bl_in_4ms =\n\t\tinfo_v11->ucLVDSPwrOnSeqDEtoVARY_BL_in4Ms;\n\tinfo->lvds_pwr_on_seq_vary_bl_to_blon_in_4ms =\n\t\tinfo_v11->ucLVDSPwrOnSeqVARY_BLtoBLON_in4Ms;\n\tinfo->lvds_pwr_off_seq_vary_bl_to_de_in4ms =\n\t\tinfo_v11->ucLVDSPwrOffSeqVARY_BLtoDE_in4Ms;\n\tinfo->lvds_pwr_off_seq_de_to_dig_on_in4ms =\n\t\tinfo_v11->ucLVDSPwrOffSeqDEtoDIGON_in4Ms;\n\tinfo->lvds_pwr_off_seq_blon_to_vary_bl_in_4ms =\n\t\tinfo_v11->ucLVDSPwrOffSeqBLONtoVARY_BL_in4Ms;\n\tinfo->lvds_off_to_on_delay_in_4ms =\n\t\tinfo_v11->ucLVDSOffToOnDelay_in4Ms;\n\tinfo->lvds_bit_depth_control_val =\n\t\tle32_to_cpu(info_v11->ulLCDBitDepthControlVal);\n\n\tfor (i = 0; i < NUMBER_OF_AVAILABLE_SCLK; ++i) {\n\t\t \n\t\tinfo->avail_s_clk[i].supported_s_clk =\n\t\t\tle32_to_cpu(info_v11->sAvail_SCLK[i].ulSupportedSCLK)\n\t\t\t\t\t\t\t\t\t* 10;\n\t\tinfo->avail_s_clk[i].voltage_index =\n\t\t\tle16_to_cpu(info_v11->sAvail_SCLK[i].usVoltageIndex);\n\t\tinfo->avail_s_clk[i].voltage_id =\n\t\t\tle16_to_cpu(info_v11->sAvail_SCLK[i].usVoltageID);\n\t}\n\t#endif  \n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_integrated_info_v2_1(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tstruct atom_integrated_system_info_v2_1 *info_v2_1;\n\tuint32_t i;\n\n\tinfo_v2_1 = GET_IMAGE(struct atom_integrated_system_info_v2_1,\n\t\t\t\t\tDATA_TABLES(integratedsysteminfo));\n\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", info_v2_1->gpuclk_ss_percentage);\n\n\tif (info_v2_1 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->gpu_cap_info =\n\tle32_to_cpu(info_v2_1->gpucapinfo);\n\t \n\tinfo->system_config = le32_to_cpu(info_v2_1->system_config);\n\tinfo->cpu_cap_info = le32_to_cpu(info_v2_1->cpucapinfo);\n\tinfo->memory_type = info_v2_1->memorytype;\n\tinfo->ma_channel_number = info_v2_1->umachannelnumber;\n\tinfo->dp_ss_control =\n\t\tle16_to_cpu(info_v2_1->reserved1);\n\n\tfor (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {\n\t\tinfo->ext_disp_conn_info.gu_id[i] =\n\t\t\t\tinfo_v2_1->extdispconninfo.guid[i];\n\t}\n\n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {\n\t\tinfo->ext_disp_conn_info.path[i].device_connector_id =\n\t\tobject_id_from_bios_object_id(\n\t\tle16_to_cpu(info_v2_1->extdispconninfo.path[i].connectorobjid));\n\n\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id =\n\t\tobject_id_from_bios_object_id(\n\t\t\tle16_to_cpu(\n\t\t\tinfo_v2_1->extdispconninfo.path[i].ext_encoder_objid));\n\n\t\tinfo->ext_disp_conn_info.path[i].device_tag =\n\t\t\tle16_to_cpu(\n\t\t\t\tinfo_v2_1->extdispconninfo.path[i].device_tag);\n\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum =\n\t\tle16_to_cpu(\n\t\t\tinfo_v2_1->extdispconninfo.path[i].device_acpi_enum);\n\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =\n\t\t\tinfo_v2_1->extdispconninfo.path[i].auxddclut_index;\n\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =\n\t\t\tinfo_v2_1->extdispconninfo.path[i].hpdlut_index;\n\t\tinfo->ext_disp_conn_info.path[i].channel_mapping.raw =\n\t\t\tinfo_v2_1->extdispconninfo.path[i].channelmapping;\n\t\tinfo->ext_disp_conn_info.path[i].caps =\n\t\t\t\tle16_to_cpu(info_v2_1->extdispconninfo.path[i].caps);\n\t}\n\n\tinfo->ext_disp_conn_info.checksum =\n\t\tinfo_v2_1->extdispconninfo.checksum;\n\tinfo->dp0_ext_hdmi_slv_addr = info_v2_1->dp0_retimer_set.HdmiSlvAddr;\n\tinfo->dp0_ext_hdmi_reg_num = info_v2_1->dp0_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp0_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp0_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp0_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp0_ext_hdmi_6g_reg_num = info_v2_1->dp0_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp0_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp1_ext_hdmi_slv_addr = info_v2_1->dp1_retimer_set.HdmiSlvAddr;\n\tinfo->dp1_ext_hdmi_reg_num = info_v2_1->dp1_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp1_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp1_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp1_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp1_ext_hdmi_6g_reg_num = info_v2_1->dp1_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp1_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp2_ext_hdmi_slv_addr = info_v2_1->dp2_retimer_set.HdmiSlvAddr;\n\tinfo->dp2_ext_hdmi_reg_num = info_v2_1->dp2_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp2_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp2_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp2_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp2_ext_hdmi_6g_reg_num = info_v2_1->dp2_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp2_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp3_ext_hdmi_slv_addr = info_v2_1->dp3_retimer_set.HdmiSlvAddr;\n\tinfo->dp3_ext_hdmi_reg_num = info_v2_1->dp3_retimer_set.HdmiRegNum;\n\tfor (i = 0; i < info->dp3_ext_hdmi_reg_num; i++) {\n\t\tinfo->dp3_ext_hdmi_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp3_ext_hdmi_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegVal;\n\t}\n\tinfo->dp3_ext_hdmi_6g_reg_num = info_v2_1->dp3_retimer_set.Hdmi6GRegNum;\n\tfor (i = 0; i < info->dp3_ext_hdmi_6g_reg_num; i++) {\n\t\tinfo->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_index =\n\t\t\t\tinfo_v2_1->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;\n\t\tinfo->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_val =\n\t\t\t\tinfo_v2_1->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;\n\t}\n\n\tinfo->edp1_info.edp_backlight_pwm_hz =\n\tle16_to_cpu(info_v2_1->edp1_info.edp_backlight_pwm_hz);\n\tinfo->edp1_info.edp_ss_percentage =\n\tle16_to_cpu(info_v2_1->edp1_info.edp_ss_percentage);\n\tinfo->edp1_info.edp_ss_rate_10hz =\n\tle16_to_cpu(info_v2_1->edp1_info.edp_ss_rate_10hz);\n\tinfo->edp1_info.edp_pwr_on_off_delay =\n\t\tinfo_v2_1->edp1_info.edp_pwr_on_off_delay;\n\tinfo->edp1_info.edp_pwr_on_vary_bl_to_blon =\n\t\tinfo_v2_1->edp1_info.edp_pwr_on_vary_bl_to_blon;\n\tinfo->edp1_info.edp_pwr_down_bloff_to_vary_bloff =\n\t\tinfo_v2_1->edp1_info.edp_pwr_down_bloff_to_vary_bloff;\n\tinfo->edp1_info.edp_panel_bpc =\n\t\tinfo_v2_1->edp1_info.edp_panel_bpc;\n\tinfo->edp1_info.edp_bootup_bl_level = info_v2_1->edp1_info.edp_bootup_bl_level;\n\n\tinfo->edp2_info.edp_backlight_pwm_hz =\n\tle16_to_cpu(info_v2_1->edp2_info.edp_backlight_pwm_hz);\n\tinfo->edp2_info.edp_ss_percentage =\n\tle16_to_cpu(info_v2_1->edp2_info.edp_ss_percentage);\n\tinfo->edp2_info.edp_ss_rate_10hz =\n\tle16_to_cpu(info_v2_1->edp2_info.edp_ss_rate_10hz);\n\tinfo->edp2_info.edp_pwr_on_off_delay =\n\t\tinfo_v2_1->edp2_info.edp_pwr_on_off_delay;\n\tinfo->edp2_info.edp_pwr_on_vary_bl_to_blon =\n\t\tinfo_v2_1->edp2_info.edp_pwr_on_vary_bl_to_blon;\n\tinfo->edp2_info.edp_pwr_down_bloff_to_vary_bloff =\n\t\tinfo_v2_1->edp2_info.edp_pwr_down_bloff_to_vary_bloff;\n\tinfo->edp2_info.edp_panel_bpc =\n\t\tinfo_v2_1->edp2_info.edp_panel_bpc;\n\tinfo->edp2_info.edp_bootup_bl_level =\n\t\tinfo_v2_1->edp2_info.edp_bootup_bl_level;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_integrated_info_v2_2(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tstruct atom_integrated_system_info_v2_2 *info_v2_2;\n\tuint32_t i;\n\n\tinfo_v2_2 = GET_IMAGE(struct atom_integrated_system_info_v2_2,\n\t\t\t\t\tDATA_TABLES(integratedsysteminfo));\n\n\tDC_LOG_BIOS(\"gpuclk_ss_percentage (unit of 0.001 percent): %d\\n\", info_v2_2->gpuclk_ss_percentage);\n\n\tif (info_v2_2 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->gpu_cap_info =\n\tle32_to_cpu(info_v2_2->gpucapinfo);\n\t \n\tinfo->system_config = le32_to_cpu(info_v2_2->system_config);\n\tinfo->cpu_cap_info = le32_to_cpu(info_v2_2->cpucapinfo);\n\tinfo->memory_type = info_v2_2->memorytype;\n\tinfo->ma_channel_number = info_v2_2->umachannelnumber;\n\tinfo->dp_ss_control =\n\t\tle16_to_cpu(info_v2_2->reserved1);\n\tinfo->gpuclk_ss_percentage = info_v2_2->gpuclk_ss_percentage;\n\tinfo->gpuclk_ss_type = info_v2_2->gpuclk_ss_type;\n\n\tfor (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {\n\t\tinfo->ext_disp_conn_info.gu_id[i] =\n\t\t\t\tinfo_v2_2->extdispconninfo.guid[i];\n\t}\n\n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {\n\t\tinfo->ext_disp_conn_info.path[i].device_connector_id =\n\t\tobject_id_from_bios_object_id(\n\t\tle16_to_cpu(info_v2_2->extdispconninfo.path[i].connectorobjid));\n\n\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id =\n\t\tobject_id_from_bios_object_id(\n\t\t\tle16_to_cpu(\n\t\t\tinfo_v2_2->extdispconninfo.path[i].ext_encoder_objid));\n\n\t\tinfo->ext_disp_conn_info.path[i].device_tag =\n\t\t\tle16_to_cpu(\n\t\t\t\tinfo_v2_2->extdispconninfo.path[i].device_tag);\n\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum =\n\t\tle16_to_cpu(\n\t\t\tinfo_v2_2->extdispconninfo.path[i].device_acpi_enum);\n\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =\n\t\t\tinfo_v2_2->extdispconninfo.path[i].auxddclut_index;\n\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =\n\t\t\tinfo_v2_2->extdispconninfo.path[i].hpdlut_index;\n\t\tinfo->ext_disp_conn_info.path[i].channel_mapping.raw =\n\t\t\tinfo_v2_2->extdispconninfo.path[i].channelmapping;\n\t\tinfo->ext_disp_conn_info.path[i].caps =\n\t\t\t\tle16_to_cpu(info_v2_2->extdispconninfo.path[i].caps);\n\t}\n\n\tinfo->ext_disp_conn_info.checksum =\n\t\tinfo_v2_2->extdispconninfo.checksum;\n\tinfo->ext_disp_conn_info.fixdpvoltageswing =\n\t\tinfo_v2_2->extdispconninfo.fixdpvoltageswing;\n\n\tinfo->edp1_info.edp_backlight_pwm_hz =\n\tle16_to_cpu(info_v2_2->edp1_info.edp_backlight_pwm_hz);\n\tinfo->edp1_info.edp_ss_percentage =\n\tle16_to_cpu(info_v2_2->edp1_info.edp_ss_percentage);\n\tinfo->edp1_info.edp_ss_rate_10hz =\n\tle16_to_cpu(info_v2_2->edp1_info.edp_ss_rate_10hz);\n\tinfo->edp1_info.edp_pwr_on_off_delay =\n\t\tinfo_v2_2->edp1_info.edp_pwr_on_off_delay;\n\tinfo->edp1_info.edp_pwr_on_vary_bl_to_blon =\n\t\tinfo_v2_2->edp1_info.edp_pwr_on_vary_bl_to_blon;\n\tinfo->edp1_info.edp_pwr_down_bloff_to_vary_bloff =\n\t\tinfo_v2_2->edp1_info.edp_pwr_down_bloff_to_vary_bloff;\n\tinfo->edp1_info.edp_panel_bpc =\n\t\tinfo_v2_2->edp1_info.edp_panel_bpc;\n\tinfo->edp1_info.edp_bootup_bl_level =\n\n\tinfo->edp2_info.edp_backlight_pwm_hz =\n\tle16_to_cpu(info_v2_2->edp2_info.edp_backlight_pwm_hz);\n\tinfo->edp2_info.edp_ss_percentage =\n\tle16_to_cpu(info_v2_2->edp2_info.edp_ss_percentage);\n\tinfo->edp2_info.edp_ss_rate_10hz =\n\tle16_to_cpu(info_v2_2->edp2_info.edp_ss_rate_10hz);\n\tinfo->edp2_info.edp_pwr_on_off_delay =\n\t\tinfo_v2_2->edp2_info.edp_pwr_on_off_delay;\n\tinfo->edp2_info.edp_pwr_on_vary_bl_to_blon =\n\t\tinfo_v2_2->edp2_info.edp_pwr_on_vary_bl_to_blon;\n\tinfo->edp2_info.edp_pwr_down_bloff_to_vary_bloff =\n\t\tinfo_v2_2->edp2_info.edp_pwr_down_bloff_to_vary_bloff;\n\tinfo->edp2_info.edp_panel_bpc =\n\t\tinfo_v2_2->edp2_info.edp_panel_bpc;\n\tinfo->edp2_info.edp_bootup_bl_level =\n\t\tinfo_v2_2->edp2_info.edp_bootup_bl_level;\n\n\treturn BP_RESULT_OK;\n}\n\n \nstatic enum bp_result construct_integrated_info(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tstatic enum bp_result result = BP_RESULT_BADBIOSTABLE;\n\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision revision;\n\n\tuint32_t i;\n\tuint32_t j;\n\n\tif (info && DATA_TABLES(integratedsysteminfo)) {\n\t\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(integratedsysteminfo));\n\n\t\tget_atom_data_table_revision(header, &revision);\n\n\t\tswitch (revision.major) {\n\t\tcase 1:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\t\tresult = get_integrated_info_v11(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 1:\n\t\t\t\tresult = get_integrated_info_v2_1(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tresult = get_integrated_info_v2_2(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn result;\n\t\t}\n\t\tif (result == BP_RESULT_OK) {\n\n\t\t\tDC_LOG_BIOS(\"edp1:\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_off_delay = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_vary_bl_to_blon = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_down_bloff_to_vary_bloff = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_bootup_bl_level = %d\\n\",\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_on_off_delay,\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_on_vary_bl_to_blon,\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_down_bloff_to_vary_bloff,\n\t\t\t\t\t\tinfo->edp1_info.edp_bootup_bl_level);\n\t\t\tDC_LOG_BIOS(\"edp2:\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_off_delayv = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_vary_bl_to_blon = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_down_bloff_to_vary_bloff = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_bootup_bl_level = %d\\n\",\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_on_off_delay,\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_on_vary_bl_to_blon,\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_down_bloff_to_vary_bloff,\n\t\t\t\t\t\tinfo->edp2_info.edp_bootup_bl_level);\n\t\t}\n\t}\n\n\tif (result != BP_RESULT_OK)\n\t\treturn result;\n\telse {\n\t\t\n\t\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; i++) {\n\t\t\tif (info->ext_disp_conn_info.path[i].device_tag != 0)\n\t\t\t\tDC_LOG_BIOS(\"integrated_info:For EXTERNAL DISPLAY PATH %d --------------\\n\"\n\t\t\t\t\t\t\"DEVICE_TAG: 0x%x\\n\"\n\t\t\t\t\t\t\"DEVICE_ACPI_ENUM: 0x%x\\n\"\n\t\t\t\t\t\t\"DEVICE_CONNECTOR_ID: 0x%x\\n\"\n\t\t\t\t\t\t\"EXT_AUX_DDC_LUT_INDEX: %d\\n\"\n\t\t\t\t\t\t\"EXT_HPD_PIN_LUT_INDEX: %d\\n\"\n\t\t\t\t\t\t\"EXT_ENCODER_OBJ_ID: 0x%x\\n\"\n\t\t\t\t\t\t\"Encoder CAPS: 0x%x\\n\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_tag,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_connector_id.id,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id.id,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].caps\n\t\t\t\t\t\t);\n\t\t\tif (info->ext_disp_conn_info.path[i].caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN)\n\t\t\t\tDC_LOG_BIOS(\"BIOS EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN on path %d\\n\", i);\n\t\t\telse if (bp->base.ctx->dc->config.force_bios_fixed_vs) {\n\t\t\t\tinfo->ext_disp_conn_info.path[i].caps |= EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN;\n\t\t\t\tDC_LOG_BIOS(\"driver forced EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN on path %d\\n\", i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tDC_LOG_BIOS(\"Integrated info table CHECKSUM: %d\\n\"\n\t\t\t\t\t\"Integrated info table FIX_DP_VOLTAGE_SWING: %d\\n\",\n\t\t\t\t\tinfo->ext_disp_conn_info.checksum,\n\t\t\t\t\tinfo->ext_disp_conn_info.fixdpvoltageswing);\n\t\tif (bp->base.ctx->dc->config.force_bios_fixed_vs && info->ext_disp_conn_info.fixdpvoltageswing == 0) {\n\t\t\tinfo->ext_disp_conn_info.fixdpvoltageswing = bp->base.ctx->dc->config.force_bios_fixed_vs & 0xF;\n\t\t\tDC_LOG_BIOS(\"driver forced fixdpvoltageswing = %d\\n\", info->ext_disp_conn_info.fixdpvoltageswing);\n\t\t}\n\t}\n\t \n\tfor (i = 1; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\tfor (j = i; j > 0; --j) {\n\t\t\tif (info->disp_clk_voltage[j].max_supported_clk <\n\t\t\t    info->disp_clk_voltage[j-1].max_supported_clk)\n\t\t\t\tswap(info->disp_clk_voltage[j-1], info->disp_clk_voltage[j]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result bios_parser_get_vram_info(\n\t\tstruct dc_bios *dcb,\n\t\tstruct dc_vram_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstatic enum bp_result result = BP_RESULT_BADBIOSTABLE;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision revision;\n\n\tif (info && DATA_TABLES(vram_info)) {\n\t\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(vram_info));\n\n\t\tget_atom_data_table_revision(header, &revision);\n\n\t\tswitch (revision.major) {\n\t\tcase 2:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 3:\n\t\t\t\tresult = get_vram_info_v23(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tresult = get_vram_info_v24(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tresult = get_vram_info_v25(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 0:\n\t\t\t\tresult = get_vram_info_v30(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn result;\n\t\t}\n\n\t}\n\treturn result;\n}\n\nstatic struct integrated_info *bios_parser_create_integrated_info(\n\tstruct dc_bios *dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct integrated_info *info;\n\n\tinfo = kzalloc(sizeof(struct integrated_info), GFP_KERNEL);\n\n\tif (info == NULL) {\n\t\tASSERT_CRITICAL(0);\n\t\treturn NULL;\n\t}\n\n\tif (construct_integrated_info(bp, info) == BP_RESULT_OK)\n\t\treturn info;\n\n\tkfree(info);\n\n\treturn NULL;\n}\n\nstatic enum bp_result update_slot_layout_info(\n\tstruct dc_bios *dcb,\n\tunsigned int i,\n\tstruct slot_layout_info *slot_layout_info)\n{\n\tunsigned int record_offset;\n\tunsigned int j;\n\tstruct atom_display_object_path_v2 *object;\n\tstruct atom_bracket_layout_record *record;\n\tstruct atom_common_record_header *record_header;\n\tstatic enum bp_result result;\n\tstruct bios_parser *bp;\n\tstruct object_info_table *tbl;\n\tstruct display_object_info_table_v1_4 *v1_4;\n\n\trecord = NULL;\n\trecord_header = NULL;\n\tresult = BP_RESULT_NORECORD;\n\n\tbp = BP_FROM_DCB(dcb);\n\ttbl = &bp->object_info_tbl;\n\tv1_4 = tbl->v1_4;\n\n\tobject = &v1_4->display_path[i];\n\trecord_offset = (unsigned int)\n\t\t(object->disp_recordoffset) +\n\t\t(unsigned int)(bp->object_info_tbl_offset);\n\n\tfor (;;) {\n\n\t\trecord_header = (struct atom_common_record_header *)\n\t\t\tGET_IMAGE(struct atom_common_record_header,\n\t\t\trecord_offset);\n\t\tif (record_header == NULL) {\n\t\t\tresult = BP_RESULT_BADBIOSTABLE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (record_header->record_type == 0xff ||\n\t\t\trecord_header->record_size == 0)\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record_header->record_type ==\n\t\t\tATOM_BRACKET_LAYOUT_RECORD_TYPE &&\n\t\t\tsizeof(struct atom_bracket_layout_record)\n\t\t\t<= record_header->record_size) {\n\t\t\trecord = (struct atom_bracket_layout_record *)\n\t\t\t\t(record_header);\n\t\t\tresult = BP_RESULT_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\trecord_offset += record_header->record_size;\n\t}\n\n\t \n\tif (result != BP_RESULT_OK)\n\t\treturn result;\n\n\t \n\tslot_layout_info->length = record->bracketlen;\n\tslot_layout_info->width = record->bracketwidth;\n\n\t \n\tslot_layout_info->num_of_connectors = record->conn_num;\n\tfor (j = 0; j < slot_layout_info->num_of_connectors; ++j) {\n\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t(enum connector_layout_type)\n\t\t\t(record->conn_info[j].connector_type);\n\t\tswitch (record->conn_info[j].connector_type) {\n\t\tcase CONNECTOR_TYPE_DVI_D:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_DVI_D;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_DVI;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_HDMI:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_HDMI;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_HDMI;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_DISPLAY_PORT:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_DP;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_DP;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_MINI_DISPLAY_PORT:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_MINI_DP;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_MINI_DP;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_UNKNOWN;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_UNKNOWN;\n\t\t}\n\n\t\tslot_layout_info->connectors[j].position =\n\t\t\trecord->conn_info[j].position;\n\t\tslot_layout_info->connectors[j].connector_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\trecord->conn_info[j].connectorobjid);\n\t}\n\treturn result;\n}\n\nstatic enum bp_result update_slot_layout_info_v2(\n\tstruct dc_bios *dcb,\n\tunsigned int i,\n\tstruct slot_layout_info *slot_layout_info)\n{\n\tunsigned int record_offset;\n\tstruct atom_display_object_path_v3 *object;\n\tstruct atom_bracket_layout_record_v2 *record;\n\tstruct atom_common_record_header *record_header;\n\tstatic enum bp_result result;\n\tstruct bios_parser *bp;\n\tstruct object_info_table *tbl;\n\tstruct display_object_info_table_v1_5 *v1_5;\n\tstruct graphics_object_id connector_id;\n\n\trecord = NULL;\n\trecord_header = NULL;\n\tresult = BP_RESULT_NORECORD;\n\n\tbp = BP_FROM_DCB(dcb);\n\ttbl = &bp->object_info_tbl;\n\tv1_5 = tbl->v1_5;\n\n\tobject = &v1_5->display_path[i];\n\trecord_offset = (unsigned int)\n\t\t(object->disp_recordoffset) +\n\t\t(unsigned int)(bp->object_info_tbl_offset);\n\n\tfor (;;) {\n\n\t\trecord_header = (struct atom_common_record_header *)\n\t\t\tGET_IMAGE(struct atom_common_record_header,\n\t\t\trecord_offset);\n\t\tif (record_header == NULL) {\n\t\t\tresult = BP_RESULT_BADBIOSTABLE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (record_header->record_type == ATOM_RECORD_END_TYPE ||\n\t\t\trecord_header->record_size == 0)\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record_header->record_type ==\n\t\t\tATOM_BRACKET_LAYOUT_V2_RECORD_TYPE &&\n\t\t\tsizeof(struct atom_bracket_layout_record_v2)\n\t\t\t<= record_header->record_size) {\n\t\t\trecord = (struct atom_bracket_layout_record_v2 *)\n\t\t\t\t(record_header);\n\t\t\tresult = BP_RESULT_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\trecord_offset += record_header->record_size;\n\t}\n\n\t \n\tif (result != BP_RESULT_OK)\n\t\treturn result;\n\n\t \n\tconnector_id = object_id_from_bios_object_id(object->display_objid);\n\n\tslot_layout_info->length = record->bracketlen;\n\tslot_layout_info->width = record->bracketwidth;\n\tslot_layout_info->num_of_connectors = v1_5->number_of_path;\n\tslot_layout_info->connectors[i].position = record->conn_num;\n\tslot_layout_info->connectors[i].connector_id = connector_id;\n\n\tswitch (connector_id.id) {\n\tcase CONNECTOR_ID_SINGLE_LINK_DVID:\n\tcase CONNECTOR_ID_DUAL_LINK_DVID:\n\t\tslot_layout_info->connectors[i].connector_type = CONNECTOR_LAYOUT_TYPE_DVI_D;\n\t\tslot_layout_info->connectors[i].length = CONNECTOR_SIZE_DVI;\n\t\tbreak;\n\n\tcase CONNECTOR_ID_HDMI_TYPE_A:\n\t\tslot_layout_info->connectors[i].connector_type = CONNECTOR_LAYOUT_TYPE_HDMI;\n\t\tslot_layout_info->connectors[i].length = CONNECTOR_SIZE_HDMI;\n\t\tbreak;\n\n\tcase CONNECTOR_ID_DISPLAY_PORT:\n\tcase CONNECTOR_ID_USBC:\n\t\tif (record->mini_type == MINI_TYPE_NORMAL) {\n\t\t\tslot_layout_info->connectors[i].connector_type = CONNECTOR_LAYOUT_TYPE_DP;\n\t\t\tslot_layout_info->connectors[i].length = CONNECTOR_SIZE_DP;\n\t\t} else {\n\t\t\tslot_layout_info->connectors[i].connector_type = CONNECTOR_LAYOUT_TYPE_MINI_DP;\n\t\t\tslot_layout_info->connectors[i].length = CONNECTOR_SIZE_MINI_DP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tslot_layout_info->connectors[i].connector_type = CONNECTOR_LAYOUT_TYPE_UNKNOWN;\n\t\tslot_layout_info->connectors[i].length = CONNECTOR_SIZE_UNKNOWN;\n\t}\n\treturn result;\n}\n\nstatic enum bp_result get_bracket_layout_record(\n\tstruct dc_bios *dcb,\n\tunsigned int bracket_layout_id,\n\tstruct slot_layout_info *slot_layout_info)\n{\n\tunsigned int i;\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstatic enum bp_result result;\n\tstruct object_info_table *tbl;\n\tstruct display_object_info_table_v1_4 *v1_4;\n\tstruct display_object_info_table_v1_5 *v1_5;\n\n\tif (slot_layout_info == NULL) {\n\t\tDC_LOG_DETECTION_EDID_PARSER(\"Invalid slot_layout_info\\n\");\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\ttbl = &bp->object_info_tbl;\n\tv1_4 = tbl->v1_4;\n\tv1_5 = tbl->v1_5;\n\n\tresult = BP_RESULT_NORECORD;\n\tswitch (bp->object_info_tbl.revision.minor) {\n\t\tcase 4:\n\t\tdefault:\n\t\t\tfor (i = 0; i < v1_4->number_of_path; ++i)\t{\n\t\t\t\tif (bracket_layout_id ==\n\t\t\t\t\tv1_4->display_path[i].display_objid) {\n\t\t\t\t\tresult = update_slot_layout_info(dcb, i, slot_layout_info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t    break;\n\t\tcase 5:\n\t\t\tfor (i = 0; i < v1_5->number_of_path; ++i)\n\t\t\t\tresult = update_slot_layout_info_v2(dcb, i, slot_layout_info);\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic enum bp_result bios_get_board_layout_info(\n\tstruct dc_bios *dcb,\n\tstruct board_layout_info *board_layout_info)\n{\n\tunsigned int i;\n\n\tstruct bios_parser *bp;\n\n\tstatic enum bp_result record_result;\n\tunsigned int max_slots;\n\n\tconst unsigned int slot_index_to_vbios_id[MAX_BOARD_SLOTS] = {\n\t\tGENERICOBJECT_BRACKET_LAYOUT_ENUM_ID1,\n\t\tGENERICOBJECT_BRACKET_LAYOUT_ENUM_ID2,\n\t\t0, 0\n\t};\n\n\n\tbp = BP_FROM_DCB(dcb);\n\n\tif (board_layout_info == NULL) {\n\t\tDC_LOG_DETECTION_EDID_PARSER(\"Invalid board_layout_info\\n\");\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tboard_layout_info->num_of_slots = 0;\n\tmax_slots = MAX_BOARD_SLOTS;\n\n\t\n\tif (bp->object_info_tbl.revision.minor == 5) {\n\t\tmax_slots = 1;\n\t}\n\n\tfor (i = 0; i < max_slots; ++i) {\n\t\trecord_result = get_bracket_layout_record(dcb,\n\t\t\tslot_index_to_vbios_id[i],\n\t\t\t&board_layout_info->slots[i]);\n\n\t\tif (record_result == BP_RESULT_NORECORD && i > 0)\n\t\t\tbreak;  \n\t\telse if (record_result != BP_RESULT_OK)\n\t\t\treturn record_result;   \n\n\t\t++board_layout_info->num_of_slots;\n\t}\n\n\t \n\tboard_layout_info->is_number_of_slots_valid = 1;\n\tboard_layout_info->is_slots_size_valid = 1;\n\tboard_layout_info->is_connector_offsets_valid = 1;\n\tboard_layout_info->is_connector_lengths_valid = 1;\n\n\treturn BP_RESULT_OK;\n}\n\n\nstatic uint16_t bios_parser_pack_data_tables(\n\tstruct dc_bios *dcb,\n\tvoid *dst)\n{\n\t\n\treturn 0;\n}\n\nstatic struct atom_dc_golden_table_v1 *bios_get_golden_table(\n\t\tstruct bios_parser *bp,\n\t\tuint32_t rev_major,\n\t\tuint32_t rev_minor,\n\t\tuint16_t *dc_golden_table_ver)\n{\n\tstruct atom_display_controller_info_v4_4 *disp_cntl_tbl_4_4 = NULL;\n\tuint32_t dc_golden_offset = 0;\n\t*dc_golden_table_ver = 0;\n\n\tif (!DATA_TABLES(dce_info))\n\t\treturn NULL;\n\n\t \n\tswitch (rev_major) {\n\tcase 4:\n\t\tswitch (rev_minor) {\n\t\tcase 4:\n\t\t\tdisp_cntl_tbl_4_4 = GET_IMAGE(struct atom_display_controller_info_v4_4,\n\t\t\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\t\t\tif (!disp_cntl_tbl_4_4)\n\t\t\t\treturn NULL;\n\t\t\tdc_golden_offset = DATA_TABLES(dce_info) + disp_cntl_tbl_4_4->dc_golden_table_offset;\n\t\t\t*dc_golden_table_ver = disp_cntl_tbl_4_4->dc_golden_table_ver;\n\t\t\tbreak;\n\t\tcase 5:\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!dc_golden_offset)\n\t\treturn NULL;\n\n\tif (*dc_golden_table_ver != 1)\n\t\treturn NULL;\n\n\treturn GET_IMAGE(struct atom_dc_golden_table_v1,\n\t\t\tdc_golden_offset);\n}\n\nstatic enum bp_result bios_get_atom_dc_golden_table(\n\tstruct dc_bios *dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct atom_dc_golden_table_v1 *atom_dc_golden_table = NULL;\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision tbl_revision;\n\tuint16_t dc_golden_table_ver = 0;\n\n\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\t\t\tDATA_TABLES(dce_info));\n\tif (!header)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tget_atom_data_table_revision(header, &tbl_revision);\n\n\tatom_dc_golden_table = bios_get_golden_table(bp,\n\t\t\ttbl_revision.major,\n\t\t\ttbl_revision.minor,\n\t\t\t&dc_golden_table_ver);\n\n\tif (!atom_dc_golden_table)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tdcb->golden_table.dc_golden_table_ver = dc_golden_table_ver;\n\tdcb->golden_table.aux_dphy_rx_control0_val = atom_dc_golden_table->aux_dphy_rx_control0_val;\n\tdcb->golden_table.aux_dphy_rx_control1_val = atom_dc_golden_table->aux_dphy_rx_control1_val;\n\tdcb->golden_table.aux_dphy_tx_control_val = atom_dc_golden_table->aux_dphy_tx_control_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_0_val = atom_dc_golden_table->dc_gpio_aux_ctrl_0_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_1_val = atom_dc_golden_table->dc_gpio_aux_ctrl_1_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_2_val = atom_dc_golden_table->dc_gpio_aux_ctrl_2_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_3_val = atom_dc_golden_table->dc_gpio_aux_ctrl_3_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_4_val = atom_dc_golden_table->dc_gpio_aux_ctrl_4_val;\n\tdcb->golden_table.dc_gpio_aux_ctrl_5_val = atom_dc_golden_table->dc_gpio_aux_ctrl_5_val;\n\n\treturn result;\n}\n\n\nstatic const struct dc_vbios_funcs vbios_funcs = {\n\t.get_connectors_number = bios_parser_get_connectors_number,\n\n\t.get_connector_id = bios_parser_get_connector_id,\n\n\t.get_src_obj = bios_parser_get_src_obj,\n\n\t.get_i2c_info = bios_parser_get_i2c_info,\n\n\t.get_hpd_info = bios_parser_get_hpd_info,\n\n\t.get_device_tag = bios_parser_get_device_tag,\n\n\t.get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,\n\n\t.get_ss_entry_number = bios_parser_get_ss_entry_number,\n\n\t.get_embedded_panel_info = bios_parser_get_embedded_panel_info,\n\n\t.get_gpio_pin_info = bios_parser_get_gpio_pin_info,\n\n\t.get_encoder_cap_info = bios_parser_get_encoder_cap_info,\n\n\t.is_device_id_supported = bios_parser_is_device_id_supported,\n\n\t.is_accelerated_mode = bios_parser_is_accelerated_mode,\n\n\t.set_scratch_critical_state = bios_parser_set_scratch_critical_state,\n\n\n \n\t.encoder_control = bios_parser_encoder_control,\n\n\t.transmitter_control = bios_parser_transmitter_control,\n\n\t.enable_crtc = bios_parser_enable_crtc,\n\n\t.set_pixel_clock = bios_parser_set_pixel_clock,\n\n\t.set_dce_clock = bios_parser_set_dce_clock,\n\n\t.program_crtc_timing = bios_parser_program_crtc_timing,\n\n\t.enable_disp_power_gating = bios_parser_enable_disp_power_gating,\n\n\t.bios_parser_destroy = firmware_parser_destroy,\n\n\t.get_board_layout_info = bios_get_board_layout_info,\n\t \n\t.pack_data_tables = bios_parser_pack_data_tables,\n\n\t.get_atom_dc_golden_table = bios_get_atom_dc_golden_table,\n\n\t.enable_lvtma_control = bios_parser_enable_lvtma_control,\n\n\t.get_soc_bb_info = bios_parser_get_soc_bb_info,\n\n\t.get_disp_connector_caps_info = bios_parser_get_disp_connector_caps_info,\n\n\t.get_lttpr_caps = bios_parser_get_lttpr_caps,\n\n\t.get_lttpr_interop = bios_parser_get_lttpr_interop,\n\n\t.get_connector_speed_cap_info = bios_parser_get_connector_speed_cap_info,\n};\n\nstatic bool bios_parser2_construct(\n\tstruct bios_parser *bp,\n\tstruct bp_init_data *init,\n\tenum dce_version dce_version)\n{\n\tuint16_t *rom_header_offset = NULL;\n\tstruct atom_rom_header_v2_2 *rom_header = NULL;\n\tstruct display_object_info_table_v1_4 *object_info_tbl;\n\tstruct atom_data_revision tbl_rev = {0};\n\n\tif (!init)\n\t\treturn false;\n\n\tif (!init->bios)\n\t\treturn false;\n\n\tbp->base.funcs = &vbios_funcs;\n\tbp->base.bios = init->bios;\n\tbp->base.bios_size = bp->base.bios[OFFSET_TO_ATOM_ROM_IMAGE_SIZE] * BIOS_IMAGE_SIZE_UNIT;\n\n\tbp->base.ctx = init->ctx;\n\n\tbp->base.bios_local_image = NULL;\n\n\trom_header_offset =\n\t\t\tGET_IMAGE(uint16_t, OFFSET_TO_ATOM_ROM_HEADER_POINTER);\n\n\tif (!rom_header_offset)\n\t\treturn false;\n\n\trom_header = GET_IMAGE(struct atom_rom_header_v2_2, *rom_header_offset);\n\n\tif (!rom_header)\n\t\treturn false;\n\n\tget_atom_data_table_revision(&rom_header->table_header, &tbl_rev);\n\tif (!(tbl_rev.major >= 2 && tbl_rev.minor >= 2))\n\t\treturn false;\n\n\tbp->master_data_tbl =\n\t\tGET_IMAGE(struct atom_master_data_table_v2_1,\n\t\t\t\trom_header->masterdatatable_offset);\n\n\tif (!bp->master_data_tbl)\n\t\treturn false;\n\n\tbp->object_info_tbl_offset = DATA_TABLES(displayobjectinfo);\n\n\tif (!bp->object_info_tbl_offset)\n\t\treturn false;\n\n\tobject_info_tbl =\n\t\t\tGET_IMAGE(struct display_object_info_table_v1_4,\n\t\t\t\t\t\tbp->object_info_tbl_offset);\n\n\tif (!object_info_tbl)\n\t\treturn false;\n\n\tget_atom_data_table_revision(&object_info_tbl->table_header,\n\t\t&bp->object_info_tbl.revision);\n\n\tif (bp->object_info_tbl.revision.major == 1\n\t\t&& bp->object_info_tbl.revision.minor == 4) {\n\t\tstruct display_object_info_table_v1_4 *tbl_v1_4;\n\n\t\ttbl_v1_4 = GET_IMAGE(struct display_object_info_table_v1_4,\n\t\t\tbp->object_info_tbl_offset);\n\t\tif (!tbl_v1_4)\n\t\t\treturn false;\n\n\t\tbp->object_info_tbl.v1_4 = tbl_v1_4;\n\t} else if (bp->object_info_tbl.revision.major == 1\n\t\t&& bp->object_info_tbl.revision.minor == 5) {\n\t\tstruct display_object_info_table_v1_5 *tbl_v1_5;\n\n\t\ttbl_v1_5 = GET_IMAGE(struct display_object_info_table_v1_5,\n\t\t\tbp->object_info_tbl_offset);\n\t\tif (!tbl_v1_5)\n\t\t\treturn false;\n\n\t\tbp->object_info_tbl.v1_5 = tbl_v1_5;\n\t} else {\n\t\tASSERT(0);\n\t\treturn false;\n\t}\n\n\tdal_firmware_parser_init_cmd_tbl(bp);\n\tdal_bios_parser_init_cmd_tbl_helper2(&bp->cmd_helper, dce_version);\n\n\tbp->base.integrated_info = bios_parser_create_integrated_info(&bp->base);\n\tbp->base.fw_info_valid = bios_parser_get_firmware_info(&bp->base, &bp->base.fw_info) == BP_RESULT_OK;\n\tbios_parser_get_vram_info(&bp->base, &bp->base.vram_info);\n\n\treturn true;\n}\n\nstruct dc_bios *firmware_parser_create(\n\tstruct bp_init_data *init,\n\tenum dce_version dce_version)\n{\n\tstruct bios_parser *bp;\n\n\tbp = kzalloc(sizeof(struct bios_parser), GFP_KERNEL);\n\tif (!bp)\n\t\treturn NULL;\n\n\tif (bios_parser2_construct(bp, init, dce_version))\n\t\treturn &bp->base;\n\n\tkfree(bp);\n\treturn NULL;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}