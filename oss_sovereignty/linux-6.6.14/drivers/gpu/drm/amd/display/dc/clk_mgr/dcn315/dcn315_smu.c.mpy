{
  "module_name": "dcn315_smu.c",
  "hash_id": "075df08ae90ec325335415fb616b0f8aa81a26915a8f2b30d9ef772eab446ced",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn315/dcn315_smu.c",
  "human_readable_source": " \n\n#include \"core_types.h\"\n#include \"clk_mgr_internal.h\"\n#include \"reg_helper.h\"\n#include \"dm_helpers.h\"\n#include \"dcn315_smu.h\"\n#include \"mp/mp_13_0_5_offset.h\"\n\n#define MAX_INSTANCE                                        6\n#define MAX_SEGMENT                                         6\n#define SMU_REGISTER_WRITE_RETRY_COUNT                      5\n\nstruct IP_BASE_INSTANCE {\n    unsigned int segment[MAX_SEGMENT];\n};\n\nstruct IP_BASE {\n    struct IP_BASE_INSTANCE instance[MAX_INSTANCE];\n};\n\nstatic const struct IP_BASE MP0_BASE = { { { { 0x00016000, 0x00DC0000, 0x00E00000, 0x00E40000, 0x0243FC00, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } } } };\nstatic const struct IP_BASE NBIO_BASE = { { { { 0x00000000, 0x00000014, 0x00000D20, 0x00010400, 0x0241B000, 0x04040000 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0, 0, 0, 0, 0, 0 } } } };\n\n#define regBIF_BX_PF2_RSMU_INDEX                                                                        0x0000\n#define regBIF_BX_PF2_RSMU_INDEX_BASE_IDX                                                               1\n#define regBIF_BX_PF2_RSMU_DATA                                                                         0x0001\n#define regBIF_BX_PF2_RSMU_DATA_BASE_IDX                                                                1\n\n#define REG(reg_name) \\\n\t(MP0_BASE.instance[0].segment[reg ## reg_name ## _BASE_IDX] + reg ## reg_name)\n\n#define FN(reg_name, field) \\\n\tFD(reg_name##__##field)\n\n#define REG_NBIO(reg_name) \\\n\t(NBIO_BASE.instance[0].segment[regBIF_BX_PF2_ ## reg_name ## _BASE_IDX] + regBIF_BX_PF2_ ## reg_name)\n\n#include \"logger_types.h\"\n#undef DC_LOGGER\n#define DC_LOGGER \\\n\tCTX->logger\n#define smu_print(str, ...) {DC_LOG_SMU(str, ##__VA_ARGS__); }\n\n#define mmMP1_C2PMSG_3                            0x3B1050C\n\n#define VBIOSSMC_MSG_TestMessage                  0x01 \n#define VBIOSSMC_MSG_GetPmfwVersion               0x02 \n#define VBIOSSMC_MSG_Spare0                       0x03 \n#define VBIOSSMC_MSG_SetDispclkFreq               0x04 \n#define VBIOSSMC_MSG_Spare1                       0x05 \n#define VBIOSSMC_MSG_SetDppclkFreq                0x06 \n#define VBIOSSMC_MSG_SetHardMinDcfclkByFreq       0x07 \n#define VBIOSSMC_MSG_SetMinDeepSleepDcfclk        0x08 \n#define VBIOSSMC_MSG_GetDtbclkFreq                0x09 \n#define VBIOSSMC_MSG_SetDtbClk                    0x0A \n#define VBIOSSMC_MSG_SetDisplayCount              0x0B \n#define VBIOSSMC_MSG_EnableTmdp48MHzRefclkPwrDown 0x0C \n#define VBIOSSMC_MSG_UpdatePmeRestore             0x0D \n#define VBIOSSMC_MSG_SetVbiosDramAddrHigh         0x0E \n#define VBIOSSMC_MSG_SetVbiosDramAddrLow          0x0F \n#define VBIOSSMC_MSG_TransferTableSmu2Dram        0x10 \n#define VBIOSSMC_MSG_TransferTableDram2Smu        0x11 \n#define VBIOSSMC_MSG_SetDisplayIdleOptimizations  0x12 \n#define VBIOSSMC_MSG_GetDprefclkFreq              0x13 \n#define VBIOSSMC_Message_Count                    0x14 \n\n#define VBIOSSMC_Status_BUSY                      0x0\n#define VBIOSSMC_Result_OK                        0x01 \n#define VBIOSSMC_Result_Failed                    0xFF \n#define VBIOSSMC_Result_UnknownCmd                0xFE \n#define VBIOSSMC_Result_CmdRejectedPrereq         0xFD \n#define VBIOSSMC_Result_CmdRejectedBusy           0xFC \n\n \nstatic uint32_t dcn315_smu_wait_for_response(struct clk_mgr_internal *clk_mgr, unsigned int delay_us, unsigned int max_retries)\n{\n\tuint32_t res_val = VBIOSSMC_Status_BUSY;\n\n\tdo {\n\t\tres_val = REG_READ(MP1_SMN_C2PMSG_38);\n\t\tif (res_val != VBIOSSMC_Status_BUSY)\n\t\t\tbreak;\n\n\t\tif (delay_us >= 1000)\n\t\t\tmsleep(delay_us/1000);\n\t\telse if (delay_us > 0)\n\t\t\tudelay(delay_us);\n\t} while (max_retries--);\n\n\treturn res_val;\n}\n\nstatic int dcn315_smu_send_msg_with_param(\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tunsigned int msg_id, unsigned int param)\n{\n\tuint32_t result;\n\tuint32_t i = 0;\n\tuint32_t read_back_data;\n\n\tresult = dcn315_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tif (result != VBIOSSMC_Result_OK)\n\t\tsmu_print(\"SMU Response was not OK. SMU response after wait received is: %d\\n\", result);\n\n\tif (result == VBIOSSMC_Status_BUSY) {\n\t\treturn -1;\n\t}\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_38, VBIOSSMC_Status_BUSY);\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_37, param);\n\n\tfor (i = 0; i < SMU_REGISTER_WRITE_RETRY_COUNT; i++) {\n\t\t \n\t\tgeneric_write_indirect_reg(CTX,\n\t\t\tREG_NBIO(RSMU_INDEX), REG_NBIO(RSMU_DATA),\n\t\t\tmmMP1_C2PMSG_3, msg_id);\n\t\tread_back_data = generic_read_indirect_reg(CTX,\n\t\t\tREG_NBIO(RSMU_INDEX), REG_NBIO(RSMU_DATA),\n\t\t\tmmMP1_C2PMSG_3);\n\t\tif (read_back_data == msg_id)\n\t\t\tbreak;\n\t\tudelay(2);\n\t\tsmu_print(\"SMU msg id write fail %x times. \\n\", i + 1);\n\t}\n\n\tresult = dcn315_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tif (result == VBIOSSMC_Status_BUSY) {\n\t\tASSERT(0);\n\t\tdm_helpers_smu_timeout(CTX, msg_id, param, 10 * 200000);\n\t}\n\n\treturn REG_READ(MP1_SMN_C2PMSG_37);\n}\n\nint dcn315_smu_get_smu_version(struct clk_mgr_internal *clk_mgr)\n{\n\treturn dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_GetPmfwVersion,\n\t\t\t0);\n}\n\n\nint dcn315_smu_set_dispclk(struct clk_mgr_internal *clk_mgr, int requested_dispclk_khz)\n{\n\tint actual_dispclk_set_mhz = -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dispclk_khz;\n\n\t \n\tactual_dispclk_set_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDispclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dispclk_khz));\n\n\treturn actual_dispclk_set_mhz * 1000;\n}\n\nint dcn315_smu_set_hard_min_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_dcfclk_khz)\n{\n\tint actual_dcfclk_set_mhz = -1;\n\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dcfclk_khz;\n\n\tactual_dcfclk_set_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetHardMinDcfclkByFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dcfclk_khz));\n\n#ifdef DBG\n\tsmu_print(\"actual_dcfclk_set_mhz %d is set to : %d\\n\", actual_dcfclk_set_mhz, actual_dcfclk_set_mhz * 1000);\n#endif\n\n\treturn actual_dcfclk_set_mhz * 1000;\n}\n\nint dcn315_smu_set_min_deep_sleep_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_min_ds_dcfclk_khz)\n{\n\tint actual_min_ds_dcfclk_mhz = -1;\n\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_min_ds_dcfclk_khz;\n\n\tactual_min_ds_dcfclk_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetMinDeepSleepDcfclk,\n\t\t\tkhz_to_mhz_ceil(requested_min_ds_dcfclk_khz));\n\n\treturn actual_min_ds_dcfclk_mhz * 1000;\n}\n\nint dcn315_smu_set_dppclk(struct clk_mgr_internal *clk_mgr, int requested_dpp_khz)\n{\n\tint actual_dppclk_set_mhz = -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dpp_khz;\n\n\tactual_dppclk_set_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDppclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dpp_khz));\n\n\treturn actual_dppclk_set_mhz * 1000;\n}\n\nvoid dcn315_smu_set_display_idle_optimization(struct clk_mgr_internal *clk_mgr, uint32_t idle_info)\n{\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t\n\tdcn315_smu_send_msg_with_param(\n\t\tclk_mgr,\n\t\tVBIOSSMC_MSG_SetDisplayIdleOptimizations,\n\t\tidle_info);\n}\n\nvoid dcn315_smu_enable_phy_refclk_pwrdwn(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tunion display_idle_optimization_u idle_info = { 0 };\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (enable) {\n\t\tidle_info.idle_info.df_request_disabled = 1;\n\t\tidle_info.idle_info.phy_ref_clk_off = 1;\n\t}\n\n\tdcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDisplayIdleOptimizations,\n\t\t\tidle_info.data);\n}\n\nvoid dcn315_smu_enable_pme_wa(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_UpdatePmeRestore,\n\t\t\t0);\n}\nvoid dcn315_smu_set_dram_addr_high(struct clk_mgr_internal *clk_mgr, uint32_t addr_high)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_SetVbiosDramAddrHigh, addr_high);\n}\n\nvoid dcn315_smu_set_dram_addr_low(struct clk_mgr_internal *clk_mgr, uint32_t addr_low)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_SetVbiosDramAddrLow, addr_low);\n}\n\nvoid dcn315_smu_transfer_dpm_table_smu_2_dram(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_TransferTableSmu2Dram, TABLE_DPMCLOCKS);\n}\n\nvoid dcn315_smu_transfer_wm_table_dram_2_smu(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_TransferTableDram2Smu, TABLE_WATERMARKS);\n}\n\nint dcn315_smu_get_dpref_clk(struct clk_mgr_internal *clk_mgr)\n{\n\tint dprefclk_get_mhz = -1;\n\tif (clk_mgr->smu_present) {\n\t\tdprefclk_get_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_GetDprefclkFreq,\n\t\t\t0);\n\t}\n\treturn (dprefclk_get_mhz * 1000);\n}\n\nint dcn315_smu_get_dtbclk(struct clk_mgr_internal *clk_mgr)\n{\n\tint fclk_get_mhz = -1;\n\n\tif (clk_mgr->smu_present) {\n\t\tfclk_get_mhz = dcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_GetDtbclkFreq,\n\t\t\t0);\n\t}\n\treturn (fclk_get_mhz * 1000);\n}\n\nvoid dcn315_smu_set_dtbclk(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn315_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDtbClk,\n\t\t\tenable);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}