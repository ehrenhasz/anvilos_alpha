{
  "module_name": "link_dp_capability.c",
  "hash_id": "5e07973913225c1a6f2a348f5f90cc5d365c4a9855b52f3c2bc2a0102c922e55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c",
  "human_readable_source": " \n\n \n\n#include \"link_dp_capability.h\"\n#include \"link_ddc.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_dpia.h\"\n#include \"link_dp_phy.h\"\n#include \"link_edp_panel_control.h\"\n#include \"link_dp_irq_handler.h\"\n#include \"link/accessories/link_dp_trace.h\"\n#include \"link/link_detection.h\"\n#include \"link/link_validation.h\"\n#include \"link_dp_training.h\"\n#include \"atomfirmware.h\"\n#include \"resource.h\"\n#include \"link_enc_cfg.h\"\n#include \"dc_dmub_srv.h\"\n#include \"gpio_service_interface.h\"\n\n#define DC_LOGGER \\\n\tlink->ctx->logger\n#define DC_TRACE_LEVEL_MESSAGE(...)  \n\n#ifndef MAX\n#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#endif\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\nstruct dp_lt_fallback_entry {\n\tenum dc_lane_count lane_count;\n\tenum dc_link_rate link_rate;\n};\n\nstatic const struct dp_lt_fallback_entry dp_lt_fallbacks[] = {\n\t\t \n\t\t{LANE_COUNT_FOUR, LINK_RATE_UHBR20},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_UHBR13_5},\n\t\t{LANE_COUNT_TWO, LINK_RATE_UHBR20},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_UHBR10},\n\t\t{LANE_COUNT_TWO, LINK_RATE_UHBR13_5},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_HIGH3},\n\t\t{LANE_COUNT_ONE, LINK_RATE_UHBR20},\n\t\t{LANE_COUNT_TWO, LINK_RATE_UHBR10},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_HIGH2},\n\t\t{LANE_COUNT_ONE, LINK_RATE_UHBR13_5},\n\t\t{LANE_COUNT_TWO, LINK_RATE_HIGH3},\n\t\t{LANE_COUNT_ONE, LINK_RATE_UHBR10},\n\t\t{LANE_COUNT_TWO, LINK_RATE_HIGH2},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_HIGH},\n\t\t{LANE_COUNT_ONE, LINK_RATE_HIGH3},\n\t\t{LANE_COUNT_FOUR, LINK_RATE_LOW},\n\t\t{LANE_COUNT_ONE, LINK_RATE_HIGH2},\n\t\t{LANE_COUNT_TWO, LINK_RATE_HIGH},\n\t\t{LANE_COUNT_TWO, LINK_RATE_LOW},\n\t\t{LANE_COUNT_ONE, LINK_RATE_HIGH},\n\t\t{LANE_COUNT_ONE, LINK_RATE_LOW},\n};\n\nstatic const struct dc_link_settings fail_safe_link_settings = {\n\t\t.lane_count = LANE_COUNT_ONE,\n\t\t.link_rate = LINK_RATE_LOW,\n\t\t.link_spread = LINK_SPREAD_DISABLED,\n};\n\nbool is_dp_active_dongle(const struct dc_link *link)\n{\n\treturn (link->dpcd_caps.dongle_type >= DISPLAY_DONGLE_DP_VGA_CONVERTER) &&\n\t\t\t\t(link->dpcd_caps.dongle_type <= DISPLAY_DONGLE_DP_HDMI_CONVERTER);\n}\n\nbool is_dp_branch_device(const struct dc_link *link)\n{\n\treturn link->dpcd_caps.is_branch_dev;\n}\n\nstatic int translate_dpcd_max_bpc(enum dpcd_downstream_port_max_bpc bpc)\n{\n\tswitch (bpc) {\n\tcase DOWN_STREAM_MAX_8BPC:\n\t\treturn 8;\n\tcase DOWN_STREAM_MAX_10BPC:\n\t\treturn 10;\n\tcase DOWN_STREAM_MAX_12BPC:\n\t\treturn 12;\n\tcase DOWN_STREAM_MAX_16BPC:\n\t\treturn 16;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nuint8_t dp_parse_lttpr_repeater_count(uint8_t lttpr_repeater_count)\n{\n\tswitch (lttpr_repeater_count) {\n\tcase 0x80: \n\t\treturn 1;\n\tcase 0x40: \n\t\treturn 2;\n\tcase 0x20: \n\t\treturn 3;\n\tcase 0x10: \n\t\treturn 4;\n\tcase 0x08: \n\t\treturn 5;\n\tcase 0x04: \n\t\treturn 6;\n\tcase 0x02: \n\t\treturn 7;\n\tcase 0x01: \n\t\treturn 8;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0; \n}\n\nuint32_t link_bw_kbps_from_raw_frl_link_rate_data(uint8_t bw)\n{\n\tswitch (bw) {\n\tcase 0b001:\n\t\treturn 9000000;\n\tcase 0b010:\n\t\treturn 18000000;\n\tcase 0b011:\n\t\treturn 24000000;\n\tcase 0b100:\n\t\treturn 32000000;\n\tcase 0b101:\n\t\treturn 40000000;\n\tcase 0b110:\n\t\treturn 48000000;\n\t}\n\n\treturn 0;\n}\n\nstatic enum dc_link_rate linkRateInKHzToLinkRateMultiplier(uint32_t link_rate_in_khz)\n{\n\tenum dc_link_rate link_rate;\n\t\n\tswitch (link_rate_in_khz) {\n\tcase 1620000:\n\t\tlink_rate = LINK_RATE_LOW;\t\n\t\tbreak;\n\tcase 2160000:\n\t\tlink_rate = LINK_RATE_RATE_2;\t\n\t\tbreak;\n\tcase 2430000:\n\t\tlink_rate = LINK_RATE_RATE_3;\t\n\t\tbreak;\n\tcase 2700000:\n\t\tlink_rate = LINK_RATE_HIGH;\t\n\t\tbreak;\n\tcase 3240000:\n\t\tlink_rate = LINK_RATE_RBR2;\t\n\t\tbreak;\n\tcase 4320000:\n\t\tlink_rate = LINK_RATE_RATE_6;\t\n\t\tbreak;\n\tcase 5400000:\n\t\tlink_rate = LINK_RATE_HIGH2;\t\n\t\tbreak;\n\tcase 6750000:\n\t\tlink_rate = LINK_RATE_RATE_8;\t\n\t\tbreak;\n\tcase 8100000:\n\t\tlink_rate = LINK_RATE_HIGH3;\t\n\t\tbreak;\n\tdefault:\n\t\tlink_rate = LINK_RATE_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn link_rate;\n}\n\nstatic union dp_cable_id intersect_cable_id(\n\t\tunion dp_cable_id *a, union dp_cable_id *b)\n{\n\tunion dp_cable_id out;\n\n\tout.bits.UHBR10_20_CAPABILITY = MIN(a->bits.UHBR10_20_CAPABILITY,\n\t\t\tb->bits.UHBR10_20_CAPABILITY);\n\tout.bits.UHBR13_5_CAPABILITY = MIN(a->bits.UHBR13_5_CAPABILITY,\n\t\t\tb->bits.UHBR13_5_CAPABILITY);\n\tout.bits.CABLE_TYPE = MAX(a->bits.CABLE_TYPE, b->bits.CABLE_TYPE);\n\n\treturn out;\n}\n\n \nstatic uint32_t intersect_frl_link_bw_support(\n\tconst uint32_t max_supported_frl_bw_in_kbps,\n\tconst union hdmi_encoded_link_bw hdmi_encoded_link_bw)\n{\n\tuint32_t supported_bw_in_kbps = max_supported_frl_bw_in_kbps;\n\n\t \n\tif (hdmi_encoded_link_bw.bits.FRL_MODE) {\n\t\tif (hdmi_encoded_link_bw.bits.BW_48Gbps)\n\t\t\tsupported_bw_in_kbps = 48000000;\n\t\telse if (hdmi_encoded_link_bw.bits.BW_40Gbps)\n\t\t\tsupported_bw_in_kbps = 40000000;\n\t\telse if (hdmi_encoded_link_bw.bits.BW_32Gbps)\n\t\t\tsupported_bw_in_kbps = 32000000;\n\t\telse if (hdmi_encoded_link_bw.bits.BW_24Gbps)\n\t\t\tsupported_bw_in_kbps = 24000000;\n\t\telse if (hdmi_encoded_link_bw.bits.BW_18Gbps)\n\t\t\tsupported_bw_in_kbps = 18000000;\n\t\telse if (hdmi_encoded_link_bw.bits.BW_9Gbps)\n\t\t\tsupported_bw_in_kbps = 9000000;\n\t}\n\n\treturn supported_bw_in_kbps;\n}\n\nstatic enum clock_source_id get_clock_source_id(struct dc_link *link)\n{\n\tenum clock_source_id dp_cs_id = CLOCK_SOURCE_ID_UNDEFINED;\n\tstruct clock_source *dp_cs = link->dc->res_pool->dp_clock_source;\n\n\tif (dp_cs != NULL) {\n\t\tdp_cs_id = dp_cs->id;\n\t} else {\n\t\t \n\t\tASSERT(dp_cs);\n\t}\n\n\treturn dp_cs_id;\n}\n\nstatic void dp_wa_power_up_0010FA(struct dc_link *link, uint8_t *dpcd_data,\n\t\tint length)\n{\n\tint retry = 0;\n\n\tif (!link->dpcd_caps.dpcd_rev.raw) {\n\t\tdo {\n\t\t\tdpcd_write_rx_power_ctrl(link, true);\n\t\t\tcore_link_read_dpcd(link, DP_DPCD_REV,\n\t\t\t\t\t\t\tdpcd_data, length);\n\t\t\tlink->dpcd_caps.dpcd_rev.raw = dpcd_data[\n\t\t\t\tDP_DPCD_REV -\n\t\t\t\tDP_DPCD_REV];\n\t\t} while (retry++ < 4 && !link->dpcd_caps.dpcd_rev.raw);\n\t}\n\n\tif (link->dpcd_caps.dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER) {\n\t\tswitch (link->dpcd_caps.branch_dev_id) {\n\t\t \n\t\tcase DP_BRANCH_DEVICE_ID_0010FA:\n\t\tcase DP_BRANCH_DEVICE_ID_0080E1:\n\t\tcase DP_BRANCH_DEVICE_ID_00E04C:\n\t\t\tlink->wa_flags.dp_keep_receiver_powered = true;\n\t\t\tbreak;\n\n\t\t \n\t\tdefault:\n\t\t\tlink->wa_flags.dp_keep_receiver_powered = false;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlink->wa_flags.dp_keep_receiver_powered = false;\n}\n\nbool dp_is_fec_supported(const struct dc_link *link)\n{\n\t \n\tstruct link_encoder *link_enc = NULL;\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\treturn (dc_is_dp_signal(link->connector_signal) && link_enc &&\n\t\t\tlink_enc->features.fec_supported &&\n\t\t\tlink->dpcd_caps.fec_cap.bits.FEC_CAPABLE);\n}\n\nbool dp_should_enable_fec(const struct dc_link *link)\n{\n\tbool force_disable = false;\n\n\tif (link->fec_state == dc_link_fec_enabled)\n\t\tforce_disable = false;\n\telse if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT_MST &&\n\t\t\tlink->local_sink &&\n\t\t\tlink->local_sink->edid_caps.panel_patch.disable_fec)\n\t\tforce_disable = true;\n\telse if (link->connector_signal == SIGNAL_TYPE_EDP\n\t\t\t&& (link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.\n\t\t\t dsc_support.DSC_SUPPORT == false\n\t\t\t\t|| link->panel_config.dsc.disable_dsc_edp\n\t\t\t\t|| !link->dc->caps.edp_dsc_support))\n\t\tforce_disable = true;\n\n\treturn !force_disable && dp_is_fec_supported(link);\n}\n\nbool dp_is_128b_132b_signal(struct pipe_ctx *pipe_ctx)\n{\n\t \n\tASSERT(pipe_ctx->stream_res.hpo_dp_stream_enc ? pipe_ctx->link_res.hpo_dp_link_enc != NULL : true);\n\treturn (pipe_ctx->stream_res.hpo_dp_stream_enc &&\n\t\t\tpipe_ctx->link_res.hpo_dp_link_enc &&\n\t\t\tdc_is_dp_signal(pipe_ctx->stream->signal));\n}\n\nbool dp_is_lttpr_present(struct dc_link *link)\n{\n\treturn (dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt) != 0 &&\n\t\t\tlink->dpcd_caps.lttpr_caps.max_lane_count > 0 &&\n\t\t\tlink->dpcd_caps.lttpr_caps.max_lane_count <= 4 &&\n\t\t\tlink->dpcd_caps.lttpr_caps.revision.raw >= 0x14);\n}\n\n \nstatic enum dc_link_rate get_link_rate_from_max_link_bw(\n\t\t uint8_t max_link_bw)\n{\n\tenum dc_link_rate link_rate;\n\n\tif (max_link_bw >= LINK_RATE_HIGH3) {\n\t\tlink_rate = LINK_RATE_HIGH3;\n\t} else if (max_link_bw < LINK_RATE_HIGH3\n\t\t\t&& max_link_bw >= LINK_RATE_HIGH2) {\n\t\tlink_rate = LINK_RATE_HIGH2;\n\t} else if (max_link_bw < LINK_RATE_HIGH2\n\t\t\t&& max_link_bw >= LINK_RATE_HIGH) {\n\t\tlink_rate = LINK_RATE_HIGH;\n\t} else if (max_link_bw < LINK_RATE_HIGH\n\t\t\t&& max_link_bw >= LINK_RATE_LOW) {\n\t\tlink_rate = LINK_RATE_LOW;\n\t} else {\n\t\tlink_rate = LINK_RATE_UNKNOWN;\n\t}\n\n\treturn link_rate;\n}\n\nstatic enum dc_link_rate get_lttpr_max_link_rate(struct dc_link *link)\n{\n\tenum dc_link_rate lttpr_max_link_rate = link->dpcd_caps.lttpr_caps.max_link_rate;\n\n\tif (link->dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR20)\n\t\tlttpr_max_link_rate = LINK_RATE_UHBR20;\n\telse if (link->dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR13_5)\n\t\tlttpr_max_link_rate = LINK_RATE_UHBR13_5;\n\telse if (link->dpcd_caps.lttpr_caps.supported_128b_132b_rates.bits.UHBR10)\n\t\tlttpr_max_link_rate = LINK_RATE_UHBR10;\n\n\treturn lttpr_max_link_rate;\n}\n\nstatic enum dc_link_rate get_cable_max_link_rate(struct dc_link *link)\n{\n\tenum dc_link_rate cable_max_link_rate = LINK_RATE_UNKNOWN;\n\n\tif (link->dpcd_caps.cable_id.bits.UHBR10_20_CAPABILITY & DP_UHBR20)\n\t\tcable_max_link_rate = LINK_RATE_UHBR20;\n\telse if (link->dpcd_caps.cable_id.bits.UHBR13_5_CAPABILITY)\n\t\tcable_max_link_rate = LINK_RATE_UHBR13_5;\n\telse if (link->dpcd_caps.cable_id.bits.UHBR10_20_CAPABILITY & DP_UHBR10)\n\t\tcable_max_link_rate = LINK_RATE_UHBR10;\n\n\treturn cable_max_link_rate;\n}\n\nstatic inline bool reached_minimum_lane_count(enum dc_lane_count lane_count)\n{\n\treturn lane_count <= LANE_COUNT_ONE;\n}\n\nstatic inline bool reached_minimum_link_rate(enum dc_link_rate link_rate)\n{\n\treturn link_rate <= LINK_RATE_LOW;\n}\n\nstatic enum dc_lane_count reduce_lane_count(enum dc_lane_count lane_count)\n{\n\tswitch (lane_count) {\n\tcase LANE_COUNT_FOUR:\n\t\treturn LANE_COUNT_TWO;\n\tcase LANE_COUNT_TWO:\n\t\treturn LANE_COUNT_ONE;\n\tcase LANE_COUNT_ONE:\n\t\treturn LANE_COUNT_UNKNOWN;\n\tdefault:\n\t\treturn LANE_COUNT_UNKNOWN;\n\t}\n}\n\nstatic enum dc_link_rate reduce_link_rate(const struct dc_link *link, enum dc_link_rate link_rate)\n{\n\t \n\t \n\t \n\n\tswitch (link_rate) {\n\tcase LINK_RATE_UHBR20:\n\t\treturn LINK_RATE_UHBR13_5;\n\tcase LINK_RATE_UHBR13_5:\n\t\treturn LINK_RATE_UHBR10;\n\tcase LINK_RATE_UHBR10:\n\t\treturn LINK_RATE_HIGH3;\n\tcase LINK_RATE_HIGH3:\n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP && link->dc->debug.support_eDP1_5)\n\t\t\treturn LINK_RATE_RATE_8;\n\t\treturn LINK_RATE_HIGH2;\n\tcase LINK_RATE_RATE_8:\n\t\treturn LINK_RATE_HIGH2;\n\tcase LINK_RATE_HIGH2:\n\t\treturn LINK_RATE_HIGH;\n\tcase LINK_RATE_RATE_6:\n\tcase LINK_RATE_RBR2:\n\t\treturn LINK_RATE_HIGH;\n\tcase LINK_RATE_HIGH:\n\t\treturn LINK_RATE_LOW;\n\tcase LINK_RATE_RATE_3:\n\tcase LINK_RATE_RATE_2:\n\t\treturn LINK_RATE_LOW;\n\tcase LINK_RATE_LOW:\n\tdefault:\n\t\treturn LINK_RATE_UNKNOWN;\n\t}\n}\n\nstatic enum dc_lane_count increase_lane_count(enum dc_lane_count lane_count)\n{\n\tswitch (lane_count) {\n\tcase LANE_COUNT_ONE:\n\t\treturn LANE_COUNT_TWO;\n\tcase LANE_COUNT_TWO:\n\t\treturn LANE_COUNT_FOUR;\n\tdefault:\n\t\treturn LANE_COUNT_UNKNOWN;\n\t}\n}\n\nstatic enum dc_link_rate increase_link_rate(struct dc_link *link,\n\t\tenum dc_link_rate link_rate)\n{\n\tswitch (link_rate) {\n\tcase LINK_RATE_LOW:\n\t\treturn LINK_RATE_HIGH;\n\tcase LINK_RATE_HIGH:\n\t\treturn LINK_RATE_HIGH2;\n\tcase LINK_RATE_HIGH2:\n\t\treturn LINK_RATE_HIGH3;\n\tcase LINK_RATE_HIGH3:\n\t\treturn LINK_RATE_UHBR10;\n\tcase LINK_RATE_UHBR10:\n\t\t \n\t\treturn link->dpcd_caps.dp_128b_132b_supported_link_rates.bits.UHBR13_5 ?\n\t\t\t\tLINK_RATE_UHBR13_5 : LINK_RATE_UHBR20;\n\tcase LINK_RATE_UHBR13_5:\n\t\treturn LINK_RATE_UHBR20;\n\tdefault:\n\t\treturn LINK_RATE_UNKNOWN;\n\t}\n}\n\nstatic bool decide_fallback_link_setting_max_bw_policy(\n\t\tstruct dc_link *link,\n\t\tconst struct dc_link_settings *max,\n\t\tstruct dc_link_settings *cur,\n\t\tenum link_training_result training_result)\n{\n\tuint8_t cur_idx = 0, next_idx;\n\tbool found = false;\n\n\tif (training_result == LINK_TRAINING_ABORT)\n\t\treturn false;\n\n\twhile (cur_idx < ARRAY_SIZE(dp_lt_fallbacks))\n\t\t \n\t\tif (dp_lt_fallbacks[cur_idx].lane_count == cur->lane_count &&\n\t\t\t\tdp_lt_fallbacks[cur_idx].link_rate == cur->link_rate)\n\t\t\tbreak;\n\t\telse\n\t\t\tcur_idx++;\n\n\tnext_idx = cur_idx + 1;\n\n\twhile (next_idx < ARRAY_SIZE(dp_lt_fallbacks))\n\t\t \n\t\tif (dp_lt_fallbacks[next_idx].lane_count > max->lane_count ||\n\t\t\t\tdp_lt_fallbacks[next_idx].link_rate > max->link_rate)\n\t\t\tnext_idx++;\n\t\telse if (dp_lt_fallbacks[next_idx].link_rate == LINK_RATE_UHBR13_5 &&\n\t\t\t\tlink->dpcd_caps.dp_128b_132b_supported_link_rates.bits.UHBR13_5 == 0)\n\t\t\t \n\t\t\tnext_idx++;\n\t\telse\n\t\t\tbreak;\n\n\tif (next_idx < ARRAY_SIZE(dp_lt_fallbacks)) {\n\t\tcur->lane_count = dp_lt_fallbacks[next_idx].lane_count;\n\t\tcur->link_rate = dp_lt_fallbacks[next_idx].link_rate;\n\t\tfound = true;\n\t}\n\n\treturn found;\n}\n\n \nbool decide_fallback_link_setting(\n\t\tstruct dc_link *link,\n\t\tstruct dc_link_settings *max,\n\t\tstruct dc_link_settings *cur,\n\t\tenum link_training_result training_result)\n{\n\tif (link_dp_get_encoding_format(max) == DP_128b_132b_ENCODING ||\n\t\t\tlink->dc->debug.force_dp2_lt_fallback_method)\n\t\treturn decide_fallback_link_setting_max_bw_policy(link, max,\n\t\t\t\tcur, training_result);\n\n\tswitch (training_result) {\n\tcase LINK_TRAINING_CR_FAIL_LANE0:\n\tcase LINK_TRAINING_CR_FAIL_LANE1:\n\tcase LINK_TRAINING_CR_FAIL_LANE23:\n\tcase LINK_TRAINING_LQA_FAIL:\n\t{\n\t\tif (!reached_minimum_link_rate(cur->link_rate)) {\n\t\t\tcur->link_rate = reduce_link_rate(link, cur->link_rate);\n\t\t} else if (!reached_minimum_lane_count(cur->lane_count)) {\n\t\t\tcur->link_rate = max->link_rate;\n\t\t\tif (training_result == LINK_TRAINING_CR_FAIL_LANE0)\n\t\t\t\treturn false;\n\t\t\telse if (training_result == LINK_TRAINING_CR_FAIL_LANE1)\n\t\t\t\tcur->lane_count = LANE_COUNT_ONE;\n\t\t\telse if (training_result == LINK_TRAINING_CR_FAIL_LANE23)\n\t\t\t\tcur->lane_count = LANE_COUNT_TWO;\n\t\t\telse\n\t\t\t\tcur->lane_count = reduce_lane_count(cur->lane_count);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase LINK_TRAINING_EQ_FAIL_EQ:\n\tcase LINK_TRAINING_EQ_FAIL_CR_PARTIAL:\n\t{\n\t\tif (!reached_minimum_lane_count(cur->lane_count)) {\n\t\t\tcur->lane_count = reduce_lane_count(cur->lane_count);\n\t\t} else if (!reached_minimum_link_rate(cur->link_rate)) {\n\t\t\tcur->link_rate = reduce_link_rate(link, cur->link_rate);\n\t\t\t \n\t\t\tmax->link_rate = cur->link_rate;\n\t\t\tcur->lane_count = max->lane_count;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase LINK_TRAINING_EQ_FAIL_CR:\n\t{\n\t\tif (!reached_minimum_link_rate(cur->link_rate)) {\n\t\t\tcur->link_rate = reduce_link_rate(link, cur->link_rate);\n\t\t\t \n\t\t\tmax->link_rate = cur->link_rate;\n\t\t\tcur->lane_count = max->lane_count;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic bool decide_dp_link_settings(struct dc_link *link, struct dc_link_settings *link_setting, uint32_t req_bw)\n{\n\tstruct dc_link_settings initial_link_setting = {\n\t\tLANE_COUNT_ONE, LINK_RATE_LOW, LINK_SPREAD_DISABLED, false, 0};\n\tstruct dc_link_settings current_link_setting =\n\t\t\tinitial_link_setting;\n\tuint32_t link_bw;\n\n\tif (req_bw > dp_link_bandwidth_kbps(link, &link->verified_link_cap))\n\t\treturn false;\n\n\t \n\twhile (current_link_setting.link_rate <=\n\t\t\tlink->verified_link_cap.link_rate) {\n\t\tlink_bw = dp_link_bandwidth_kbps(\n\t\t\t\tlink,\n\t\t\t\t&current_link_setting);\n\t\tif (req_bw <= link_bw) {\n\t\t\t*link_setting = current_link_setting;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (current_link_setting.lane_count <\n\t\t\t\tlink->verified_link_cap.lane_count) {\n\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t} else {\n\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\tincrease_link_rate(link,\n\t\t\t\t\t\t\tcurrent_link_setting.link_rate);\n\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\tinitial_link_setting.lane_count;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool edp_decide_link_settings(struct dc_link *link,\n\t\tstruct dc_link_settings *link_setting, uint32_t req_bw)\n{\n\tstruct dc_link_settings initial_link_setting;\n\tstruct dc_link_settings current_link_setting;\n\tuint32_t link_bw;\n\n\t \n\tif (!edp_is_ilr_optimization_enabled(link)) {\n\t\t*link_setting = link->verified_link_cap;\n\t\treturn true;\n\t}\n\n\tmemset(&initial_link_setting, 0, sizeof(initial_link_setting));\n\tinitial_link_setting.lane_count = LANE_COUNT_ONE;\n\tinitial_link_setting.link_rate = link->dpcd_caps.edp_supported_link_rates[0];\n\tinitial_link_setting.link_spread = LINK_SPREAD_DISABLED;\n\tinitial_link_setting.use_link_rate_set = true;\n\tinitial_link_setting.link_rate_set = 0;\n\tcurrent_link_setting = initial_link_setting;\n\n\t \n\twhile (current_link_setting.link_rate <=\n\t\t\tlink->verified_link_cap.link_rate) {\n\t\tlink_bw = dp_link_bandwidth_kbps(\n\t\t\t\tlink,\n\t\t\t\t&current_link_setting);\n\t\tif (req_bw <= link_bw) {\n\t\t\t*link_setting = current_link_setting;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (current_link_setting.lane_count <\n\t\t\t\tlink->verified_link_cap.lane_count) {\n\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t} else {\n\t\t\tif (current_link_setting.link_rate_set < link->dpcd_caps.edp_supported_link_rates_count) {\n\t\t\t\tcurrent_link_setting.link_rate_set++;\n\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[current_link_setting.link_rate_set];\n\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\t\t\t\tinitial_link_setting.lane_count;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool decide_edp_link_settings_with_dsc(struct dc_link *link,\n\t\tstruct dc_link_settings *link_setting,\n\t\tuint32_t req_bw,\n\t\tenum dc_link_rate max_link_rate)\n{\n\tstruct dc_link_settings initial_link_setting;\n\tstruct dc_link_settings current_link_setting;\n\tuint32_t link_bw;\n\n\tunsigned int policy = 0;\n\n\tpolicy = link->panel_config.dsc.force_dsc_edp_policy;\n\tif (max_link_rate == LINK_RATE_UNKNOWN)\n\t\tmax_link_rate = link->verified_link_cap.link_rate;\n\t \n\tif (!edp_is_ilr_optimization_enabled(link)) {\n\t\t \n\t\tmemset(&initial_link_setting, 0, sizeof(initial_link_setting));\n\t\tinitial_link_setting.lane_count = LANE_COUNT_ONE;\n\t\tinitial_link_setting.link_rate = LINK_RATE_LOW;\n\t\tinitial_link_setting.link_spread = LINK_SPREAD_DISABLED;\n\t\tinitial_link_setting.use_link_rate_set = false;\n\t\tinitial_link_setting.link_rate_set = 0;\n\t\tcurrent_link_setting = initial_link_setting;\n\t\tif (req_bw > dp_link_bandwidth_kbps(link, &link->verified_link_cap))\n\t\t\treturn false;\n\n\t\t \n\t\twhile (current_link_setting.link_rate <=\n\t\t\t\tmax_link_rate) {\n\t\t\tlink_bw = dp_link_bandwidth_kbps(\n\t\t\t\t\tlink,\n\t\t\t\t\t&current_link_setting);\n\t\t\tif (req_bw <= link_bw) {\n\t\t\t\t*link_setting = current_link_setting;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (policy) {\n\t\t\t\t \n\t\t\t\tif (current_link_setting.link_rate < max_link_rate) {\n\t\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\t\t\tincrease_link_rate(link,\n\t\t\t\t\t\t\t\t\tcurrent_link_setting.link_rate);\n\t\t\t\t} else {\n\t\t\t\t\tif (current_link_setting.lane_count <\n\t\t\t\t\t\t\t\t\tlink->verified_link_cap.lane_count) {\n\t\t\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t\t\t\t\tcurrent_link_setting.link_rate = initial_link_setting.link_rate;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (current_link_setting.lane_count <\n\t\t\t\t\t\tlink->verified_link_cap.lane_count) {\n\t\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\t\t\tincrease_link_rate(link,\n\t\t\t\t\t\t\t\t\tcurrent_link_setting.link_rate);\n\t\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\t\tinitial_link_setting.lane_count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t \n\tmemset(&initial_link_setting, 0, sizeof(initial_link_setting));\n\tinitial_link_setting.lane_count = LANE_COUNT_ONE;\n\tinitial_link_setting.link_rate = link->dpcd_caps.edp_supported_link_rates[0];\n\tinitial_link_setting.link_spread = LINK_SPREAD_DISABLED;\n\tinitial_link_setting.use_link_rate_set = true;\n\tinitial_link_setting.link_rate_set = 0;\n\tcurrent_link_setting = initial_link_setting;\n\n\t \n\twhile (current_link_setting.link_rate <=\n\t\t\tmax_link_rate) {\n\t\tlink_bw = dp_link_bandwidth_kbps(\n\t\t\t\tlink,\n\t\t\t\t&current_link_setting);\n\t\tif (req_bw <= link_bw) {\n\t\t\t*link_setting = current_link_setting;\n\t\t\treturn true;\n\t\t}\n\t\tif (policy) {\n\t\t\t \n\t\t\tif (current_link_setting.link_rate_set <\n\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates_count\n\t\t\t\t\t&& current_link_setting.link_rate < max_link_rate) {\n\t\t\t\tcurrent_link_setting.link_rate_set++;\n\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[current_link_setting.link_rate_set];\n\t\t\t} else {\n\t\t\t\tif (current_link_setting.lane_count < link->verified_link_cap.lane_count) {\n\t\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t\t\t\tcurrent_link_setting.link_rate_set = initial_link_setting.link_rate_set;\n\t\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[current_link_setting.link_rate_set];\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (current_link_setting.lane_count <\n\t\t\t\t\tlink->verified_link_cap.lane_count) {\n\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\tincrease_lane_count(\n\t\t\t\t\t\t\t\tcurrent_link_setting.lane_count);\n\t\t\t} else {\n\t\t\t\tif (current_link_setting.link_rate_set < link->dpcd_caps.edp_supported_link_rates_count) {\n\t\t\t\t\tcurrent_link_setting.link_rate_set++;\n\t\t\t\t\tcurrent_link_setting.link_rate =\n\t\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[current_link_setting.link_rate_set];\n\t\t\t\t\tcurrent_link_setting.lane_count =\n\t\t\t\t\t\tinitial_link_setting.lane_count;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool decide_mst_link_settings(const struct dc_link *link, struct dc_link_settings *link_setting)\n{\n\t*link_setting = link->verified_link_cap;\n\treturn true;\n}\n\nbool link_decide_link_settings(struct dc_stream_state *stream,\n\tstruct dc_link_settings *link_setting)\n{\n\tstruct dc_link *link = stream->link;\n\tuint32_t req_bw = dc_bandwidth_in_kbps_from_timing(&stream->timing, dc_link_get_highest_encoding_format(link));\n\n\tmemset(link_setting, 0, sizeof(*link_setting));\n\n\t \n\tif (link->preferred_link_setting.lane_count !=\n\t\t\tLANE_COUNT_UNKNOWN &&\n\t\t\tlink->preferred_link_setting.link_rate !=\n\t\t\t\t\tLINK_RATE_UNKNOWN) {\n\t\t*link_setting = link->preferred_link_setting;\n\t\treturn true;\n\t}\n\n\t \n\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\tdecide_mst_link_settings(link, link_setting);\n\t} else if (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t \n\t\tif (stream->timing.flags.DSC) {\n\t\t\tenum dc_link_rate max_link_rate = LINK_RATE_UNKNOWN;\n\n\t\t\tif (link->panel_config.dsc.force_dsc_edp_policy) {\n\t\t\t\t \n\t\t\t\tstruct dc_link_settings tmp_link_setting;\n\t\t\t\tstruct dc_crtc_timing tmp_timing = stream->timing;\n\t\t\t\tuint32_t orig_req_bw;\n\n\t\t\t\ttmp_link_setting.link_rate = LINK_RATE_UNKNOWN;\n\t\t\t\ttmp_timing.flags.DSC = 0;\n\t\t\t\torig_req_bw = dc_bandwidth_in_kbps_from_timing(&tmp_timing,\n\t\t\t\t\t\tdc_link_get_highest_encoding_format(link));\n\t\t\t\tedp_decide_link_settings(link, &tmp_link_setting, orig_req_bw);\n\t\t\t\tmax_link_rate = tmp_link_setting.link_rate;\n\t\t\t}\n\t\t\tdecide_edp_link_settings_with_dsc(link, link_setting, req_bw, max_link_rate);\n\t\t} else {\n\t\t\tedp_decide_link_settings(link, link_setting, req_bw);\n\t\t}\n\t} else {\n\t\tdecide_dp_link_settings(link, link_setting, req_bw);\n\t}\n\n\treturn link_setting->lane_count != LANE_COUNT_UNKNOWN &&\n\t\t\tlink_setting->link_rate != LINK_RATE_UNKNOWN;\n}\n\nenum dp_link_encoding link_dp_get_encoding_format(const struct dc_link_settings *link_settings)\n{\n\tif ((link_settings->link_rate >= LINK_RATE_LOW) &&\n\t\t\t(link_settings->link_rate <= LINK_RATE_HIGH3))\n\t\treturn DP_8b_10b_ENCODING;\n\telse if ((link_settings->link_rate >= LINK_RATE_UHBR10) &&\n\t\t\t(link_settings->link_rate <= LINK_RATE_UHBR20))\n\t\treturn DP_128b_132b_ENCODING;\n\treturn DP_UNKNOWN_ENCODING;\n}\n\nenum dp_link_encoding mst_decide_link_encoding_format(const struct dc_link *link)\n{\n\tstruct dc_link_settings link_settings = {0};\n\n\tif (!dc_is_dp_signal(link->connector_signal))\n\t\treturn DP_UNKNOWN_ENCODING;\n\n\tif (link->preferred_link_setting.lane_count !=\n\t\t\tLANE_COUNT_UNKNOWN &&\n\t\t\tlink->preferred_link_setting.link_rate !=\n\t\t\t\t\tLINK_RATE_UNKNOWN) {\n\t\tlink_settings = link->preferred_link_setting;\n\t} else {\n\t\tdecide_mst_link_settings(link, &link_settings);\n\t}\n\n\treturn link_dp_get_encoding_format(&link_settings);\n}\n\nstatic void read_dp_device_vendor_id(struct dc_link *link)\n{\n\tstruct dp_device_vendor_id dp_id;\n\n\t \n\tcore_link_read_dpcd(\n\t\tlink,\n\t\tDP_BRANCH_OUI,\n\t\t(uint8_t *)&dp_id,\n\t\tsizeof(dp_id));\n\n\tlink->dpcd_caps.branch_dev_id =\n\t\t(dp_id.ieee_oui[0] << 16) +\n\t\t(dp_id.ieee_oui[1] << 8) +\n\t\tdp_id.ieee_oui[2];\n\n\tmemmove(\n\t\tlink->dpcd_caps.branch_dev_name,\n\t\tdp_id.ieee_device_id,\n\t\tsizeof(dp_id.ieee_device_id));\n}\n\nstatic enum dc_status wake_up_aux_channel(struct dc_link *link)\n{\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\tuint32_t aux_channel_retry_cnt = 0;\n\tuint8_t dpcd_power_state = '\\0';\n\n\twhile (status != DC_OK && aux_channel_retry_cnt < 10) {\n\t\tstatus = core_link_read_dpcd(link, DP_SET_POWER,\n\t\t\t\t&dpcd_power_state, sizeof(dpcd_power_state));\n\n\t\t \n\t\tif (status != DC_OK || dpcd_power_state == DP_SET_POWER_D3) {\n\t\t\tfsleep(1000);\n\t\t\taux_channel_retry_cnt++;\n\t\t}\n\t}\n\n\tif (status != DC_OK) {\n\t\tdpcd_power_state = DP_SET_POWER_D0;\n\t\tstatus = core_link_write_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_SET_POWER,\n\t\t\t\t&dpcd_power_state,\n\t\t\t\tsizeof(dpcd_power_state));\n\n\t\tdpcd_power_state = DP_SET_POWER_D3;\n\t\tstatus = core_link_write_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_SET_POWER,\n\t\t\t\t&dpcd_power_state,\n\t\t\t\tsizeof(dpcd_power_state));\n\t\tDC_LOG_DC(\"%s: Failed to power up sink\\n\", __func__);\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\treturn DC_OK;\n}\n\nstatic void get_active_converter_info(\n\tuint8_t data, struct dc_link *link)\n{\n\tunion dp_downstream_port_present ds_port = { .byte = data };\n\tmemset(&link->dpcd_caps.dongle_caps, 0, sizeof(link->dpcd_caps.dongle_caps));\n\n\t \n\tif (!ds_port.fields.PORT_PRESENT) {\n\t\tlink->dpcd_caps.dongle_type = DISPLAY_DONGLE_NONE;\n\t\tset_dongle_type(link->ddc,\n\t\t\t\tlink->dpcd_caps.dongle_type);\n\t\tlink->dpcd_caps.is_branch_dev = false;\n\t\treturn;\n\t}\n\n\t \n\tlink->dpcd_caps.is_branch_dev = ds_port.fields.PORT_PRESENT;\n\n\tswitch (ds_port.fields.PORT_TYPE) {\n\tcase DOWNSTREAM_VGA:\n\t\tlink->dpcd_caps.dongle_type = DISPLAY_DONGLE_DP_VGA_CONVERTER;\n\t\tbreak;\n\tcase DOWNSTREAM_DVI_HDMI_DP_PLUS_PLUS:\n\t\t \n\t\tlink->dpcd_caps.dongle_type = DISPLAY_DONGLE_DP_DVI_CONVERTER;\n\t\tbreak;\n\tdefault:\n\t\tlink->dpcd_caps.dongle_type = DISPLAY_DONGLE_NONE;\n\t\tbreak;\n\t}\n\n\tif (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_11) {\n\t\tuint8_t det_caps[16];  \n\t\tunion dwnstream_port_caps_byte0 *port_caps =\n\t\t\t(union dwnstream_port_caps_byte0 *)det_caps;\n\t\tif (core_link_read_dpcd(link, DP_DOWNSTREAM_PORT_0,\n\t\t\t\tdet_caps, sizeof(det_caps)) == DC_OK) {\n\n\t\t\tswitch (port_caps->bits.DWN_STRM_PORTX_TYPE) {\n\t\t\t \n\t\t\tcase DOWN_STREAM_DETAILED_DP:\n\t\t\t\tlink->dpcd_caps.dongle_type = DISPLAY_DONGLE_NONE;\n\t\t\t\tbreak;\n\t\t\tcase DOWN_STREAM_DETAILED_VGA:\n\t\t\t\tlink->dpcd_caps.dongle_type =\n\t\t\t\t\tDISPLAY_DONGLE_DP_VGA_CONVERTER;\n\t\t\t\tbreak;\n\t\t\tcase DOWN_STREAM_DETAILED_DVI:\n\t\t\t\tlink->dpcd_caps.dongle_type =\n\t\t\t\t\tDISPLAY_DONGLE_DP_DVI_CONVERTER;\n\t\t\t\tbreak;\n\t\t\tcase DOWN_STREAM_DETAILED_HDMI:\n\t\t\tcase DOWN_STREAM_DETAILED_DP_PLUS_PLUS:\n\t\t\t\t \n\t\t\t\tlink->dpcd_caps.dongle_type =\n\t\t\t\t\tDISPLAY_DONGLE_DP_HDMI_CONVERTER;\n\n\t\t\t\tlink->dpcd_caps.dongle_caps.dongle_type = link->dpcd_caps.dongle_type;\n\t\t\t\tif (ds_port.fields.DETAILED_CAPS) {\n\n\t\t\t\t\tunion dwnstream_port_caps_byte3_hdmi\n\t\t\t\t\t\thdmi_caps = {.raw = det_caps[3] };\n\t\t\t\t\tunion dwnstream_port_caps_byte2\n\t\t\t\t\t\thdmi_color_caps = {.raw = det_caps[2] };\n\t\t\t\t\tlink->dpcd_caps.dongle_caps.dp_hdmi_max_pixel_clk_in_khz =\n\t\t\t\t\t\tdet_caps[1] * 2500;\n\n\t\t\t\t\tlink->dpcd_caps.dongle_caps.is_dp_hdmi_s3d_converter =\n\t\t\t\t\t\thdmi_caps.bits.FRAME_SEQ_TO_FRAME_PACK;\n\t\t\t\t\t \n\t\t\t\t\tif (port_caps->bits.DWN_STRM_PORTX_TYPE\n\t\t\t\t\t\t\t== DOWN_STREAM_DETAILED_HDMI) {\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.is_dp_hdmi_ycbcr422_pass_through =\n\t\t\t\t\t\t\t\thdmi_caps.bits.YCrCr422_PASS_THROUGH;\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.is_dp_hdmi_ycbcr420_pass_through =\n\t\t\t\t\t\t\t\thdmi_caps.bits.YCrCr420_PASS_THROUGH;\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.is_dp_hdmi_ycbcr422_converter =\n\t\t\t\t\t\t\t\thdmi_caps.bits.YCrCr422_CONVERSION;\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.is_dp_hdmi_ycbcr420_converter =\n\t\t\t\t\t\t\t\thdmi_caps.bits.YCrCr420_CONVERSION;\n\t\t\t\t\t}\n\n\t\t\t\t\tlink->dpcd_caps.dongle_caps.dp_hdmi_max_bpc =\n\t\t\t\t\t\ttranslate_dpcd_max_bpc(\n\t\t\t\t\t\t\thdmi_color_caps.bits.MAX_BITS_PER_COLOR_COMPONENT);\n\n\t\t\t\t\tif (link->dc->caps.dp_hdmi21_pcon_support) {\n\t\t\t\t\t\tunion hdmi_encoded_link_bw hdmi_encoded_link_bw;\n\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.dp_hdmi_frl_max_link_bw_in_kbps =\n\t\t\t\t\t\t\t\tlink_bw_kbps_from_raw_frl_link_rate_data(\n\t\t\t\t\t\t\t\t\t\thdmi_color_caps.bits.MAX_ENCODED_LINK_BW_SUPPORT);\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (core_link_read_dpcd(link, DP_PCON_HDMI_POST_FRL_STATUS,\n\t\t\t\t\t\t\t\t&hdmi_encoded_link_bw.raw, sizeof(hdmi_encoded_link_bw)) == DC_OK) {\n\t\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.dp_hdmi_frl_max_link_bw_in_kbps = intersect_frl_link_bw_support(\n\t\t\t\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.dp_hdmi_frl_max_link_bw_in_kbps,\n\t\t\t\t\t\t\t\t\thdmi_encoded_link_bw);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (link->dpcd_caps.dongle_caps.dp_hdmi_frl_max_link_bw_in_kbps > 0)\n\t\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.extendedCapValid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (link->dpcd_caps.dongle_caps.dp_hdmi_max_pixel_clk_in_khz != 0)\n\t\t\t\t\t\tlink->dpcd_caps.dongle_caps.extendedCapValid = true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tset_dongle_type(link->ddc, link->dpcd_caps.dongle_type);\n\n\t{\n\t\tstruct dp_sink_hw_fw_revision dp_hw_fw_revision;\n\n\t\tcore_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_BRANCH_REVISION_START,\n\t\t\t(uint8_t *)&dp_hw_fw_revision,\n\t\t\tsizeof(dp_hw_fw_revision));\n\n\t\tlink->dpcd_caps.branch_hw_revision =\n\t\t\tdp_hw_fw_revision.ieee_hw_rev;\n\n\t\tmemmove(\n\t\t\tlink->dpcd_caps.branch_fw_revision,\n\t\t\tdp_hw_fw_revision.ieee_fw_rev,\n\t\t\tsizeof(dp_hw_fw_revision.ieee_fw_rev));\n\t}\n\tif (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_14 &&\n\t\t\tlink->dpcd_caps.dongle_type != DISPLAY_DONGLE_NONE) {\n\t\tunion dp_dfp_cap_ext dfp_cap_ext;\n\t\tmemset(&dfp_cap_ext, '\\0', sizeof (dfp_cap_ext));\n\t\tcore_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_DFP_CAPABILITY_EXTENSION_SUPPORT,\n\t\t\t\tdfp_cap_ext.raw,\n\t\t\t\tsizeof(dfp_cap_ext.raw));\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.supported = dfp_cap_ext.fields.supported;\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.max_pixel_rate_in_mps =\n\t\t\t\tdfp_cap_ext.fields.max_pixel_rate_in_mps[0] +\n\t\t\t\t(dfp_cap_ext.fields.max_pixel_rate_in_mps[1] << 8);\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.max_video_h_active_width =\n\t\t\t\tdfp_cap_ext.fields.max_video_h_active_width[0] +\n\t\t\t\t(dfp_cap_ext.fields.max_video_h_active_width[1] << 8);\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.max_video_v_active_height =\n\t\t\t\tdfp_cap_ext.fields.max_video_v_active_height[0] +\n\t\t\t\t(dfp_cap_ext.fields.max_video_v_active_height[1] << 8);\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.encoding_format_caps =\n\t\t\t\tdfp_cap_ext.fields.encoding_format_caps;\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.rgb_color_depth_caps =\n\t\t\t\tdfp_cap_ext.fields.rgb_color_depth_caps;\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.ycbcr444_color_depth_caps =\n\t\t\t\tdfp_cap_ext.fields.ycbcr444_color_depth_caps;\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.ycbcr422_color_depth_caps =\n\t\t\t\tdfp_cap_ext.fields.ycbcr422_color_depth_caps;\n\t\tlink->dpcd_caps.dongle_caps.dfp_cap_ext.ycbcr420_color_depth_caps =\n\t\t\t\tdfp_cap_ext.fields.ycbcr420_color_depth_caps;\n\t\tDC_LOG_DP2(\"DFP capability extension is read at link %d\", link->link_index);\n\t\tDC_LOG_DP2(\"\\tdfp_cap_ext.supported = %s\", link->dpcd_caps.dongle_caps.dfp_cap_ext.supported ? \"true\" : \"false\");\n\t\tDC_LOG_DP2(\"\\tdfp_cap_ext.max_pixel_rate_in_mps = %d\", link->dpcd_caps.dongle_caps.dfp_cap_ext.max_pixel_rate_in_mps);\n\t\tDC_LOG_DP2(\"\\tdfp_cap_ext.max_video_h_active_width = %d\", link->dpcd_caps.dongle_caps.dfp_cap_ext.max_video_h_active_width);\n\t\tDC_LOG_DP2(\"\\tdfp_cap_ext.max_video_v_active_height = %d\", link->dpcd_caps.dongle_caps.dfp_cap_ext.max_video_v_active_height);\n\t}\n}\n\nstatic void apply_usbc_combo_phy_reset_wa(struct dc_link *link,\n\t\tstruct dc_link_settings *link_settings)\n{\n\t \n\tstruct link_resource link_res = {0};\n\tenum clock_source_id dp_cs_id = get_clock_source_id(link);\n\n\tdp_enable_link_phy(link, &link_res, link->connector_signal,\n\t\t\tdp_cs_id, link_settings);\n\tdp_disable_link_phy(link, &link_res, link->connector_signal);\n}\n\nbool dp_overwrite_extended_receiver_cap(struct dc_link *link)\n{\n\tuint8_t dpcd_data[16];\n\tuint32_t read_dpcd_retry_cnt = 3;\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\tunion dp_downstream_port_present ds_port = { 0 };\n\tunion down_stream_port_count down_strm_port_count;\n\tunion edp_configuration_cap edp_config_cap;\n\n\tint i;\n\n\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\tstatus = core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_DPCD_REV,\n\t\t\t\tdpcd_data,\n\t\t\t\tsizeof(dpcd_data));\n\t\tif (status == DC_OK)\n\t\t\tbreak;\n\t}\n\n\tlink->dpcd_caps.dpcd_rev.raw =\n\t\tdpcd_data[DP_DPCD_REV - DP_DPCD_REV];\n\n\tif (dpcd_data[DP_MAX_LANE_COUNT - DP_DPCD_REV] == 0)\n\t\treturn false;\n\n\tds_port.byte = dpcd_data[DP_DOWNSTREAMPORT_PRESENT -\n\t\t\tDP_DPCD_REV];\n\n\tget_active_converter_info(ds_port.byte, link);\n\n\tdown_strm_port_count.raw = dpcd_data[DP_DOWN_STREAM_PORT_COUNT -\n\t\t\tDP_DPCD_REV];\n\n\tlink->dpcd_caps.allow_invalid_MSA_timing_param =\n\t\tdown_strm_port_count.bits.IGNORE_MSA_TIMING_PARAM;\n\n\tlink->dpcd_caps.max_ln_count.raw = dpcd_data[\n\t\tDP_MAX_LANE_COUNT - DP_DPCD_REV];\n\n\tlink->dpcd_caps.max_down_spread.raw = dpcd_data[\n\t\tDP_MAX_DOWNSPREAD - DP_DPCD_REV];\n\n\tlink->reported_link_cap.lane_count =\n\t\tlink->dpcd_caps.max_ln_count.bits.MAX_LANE_COUNT;\n\tlink->reported_link_cap.link_rate = dpcd_data[\n\t\tDP_MAX_LINK_RATE - DP_DPCD_REV];\n\tlink->reported_link_cap.link_spread =\n\t\tlink->dpcd_caps.max_down_spread.bits.MAX_DOWN_SPREAD ?\n\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ : LINK_SPREAD_DISABLED;\n\n\tedp_config_cap.raw = dpcd_data[\n\t\tDP_EDP_CONFIGURATION_CAP - DP_DPCD_REV];\n\tlink->dpcd_caps.panel_mode_edp =\n\t\tedp_config_cap.bits.ALT_SCRAMBLER_RESET;\n\tlink->dpcd_caps.dpcd_display_control_capable =\n\t\tedp_config_cap.bits.DPCD_DISPLAY_CONTROL_CAPABLE;\n\n\treturn true;\n}\n\nvoid dpcd_set_source_specific_data(struct dc_link *link)\n{\n\tif (!link->dc->vendor_signature.is_valid) {\n\t\tenum dc_status __maybe_unused result_write_min_hblank = DC_NOT_SUPPORTED;\n\t\tstruct dpcd_amd_signature amd_signature = {0};\n\t\tstruct dpcd_amd_device_id amd_device_id = {0};\n\n\t\tamd_device_id.device_id_byte1 =\n\t\t\t\t(uint8_t)(link->ctx->asic_id.chip_id);\n\t\tamd_device_id.device_id_byte2 =\n\t\t\t\t(uint8_t)(link->ctx->asic_id.chip_id >> 8);\n\t\tamd_device_id.dce_version =\n\t\t\t\t(uint8_t)(link->ctx->dce_version);\n\t\tamd_device_id.dal_version_byte1 = 0x0;  \n\t\tamd_device_id.dal_version_byte2 = 0x0;  \n\n\t\tcore_link_read_dpcd(link, DP_SOURCE_OUI,\n\t\t\t\t(uint8_t *)(&amd_signature),\n\t\t\t\tsizeof(amd_signature));\n\n\t\tif (!((amd_signature.AMD_IEEE_TxSignature_byte1 == 0x0) &&\n\t\t\t(amd_signature.AMD_IEEE_TxSignature_byte2 == 0x0) &&\n\t\t\t(amd_signature.AMD_IEEE_TxSignature_byte3 == 0x1A))) {\n\n\t\t\tamd_signature.AMD_IEEE_TxSignature_byte1 = 0x0;\n\t\t\tamd_signature.AMD_IEEE_TxSignature_byte2 = 0x0;\n\t\t\tamd_signature.AMD_IEEE_TxSignature_byte3 = 0x1A;\n\n\t\t\tcore_link_write_dpcd(link, DP_SOURCE_OUI,\n\t\t\t\t(uint8_t *)(&amd_signature),\n\t\t\t\tsizeof(amd_signature));\n\t\t}\n\n\t\tcore_link_write_dpcd(link, DP_SOURCE_OUI+0x03,\n\t\t\t\t(uint8_t *)(&amd_device_id),\n\t\t\t\tsizeof(amd_device_id));\n\n\t\tif (link->ctx->dce_version >= DCN_VERSION_2_0 &&\n\t\t\tlink->dc->caps.min_horizontal_blanking_period != 0) {\n\n\t\t\tuint8_t hblank_size = (uint8_t)link->dc->caps.min_horizontal_blanking_period;\n\n\t\t\tresult_write_min_hblank = core_link_write_dpcd(link,\n\t\t\t\tDP_SOURCE_MINIMUM_HBLANK_SUPPORTED, (uint8_t *)(&hblank_size),\n\t\t\t\tsizeof(hblank_size));\n\t\t}\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tWPP_BIT_FLAG_DC_DETECTION_DP_CAPS,\n\t\t\t\t\t\t\t\"result=%u link_index=%u enum dce_version=%d DPCD=0x%04X min_hblank=%u branch_dev_id=0x%x branch_dev_name='%c%c%c%c%c%c'\",\n\t\t\t\t\t\t\tresult_write_min_hblank,\n\t\t\t\t\t\t\tlink->link_index,\n\t\t\t\t\t\t\tlink->ctx->dce_version,\n\t\t\t\t\t\t\tDP_SOURCE_MINIMUM_HBLANK_SUPPORTED,\n\t\t\t\t\t\t\tlink->dc->caps.min_horizontal_blanking_period,\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_id,\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[0],\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[1],\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[2],\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[3],\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[4],\n\t\t\t\t\t\t\tlink->dpcd_caps.branch_dev_name[5]);\n\t} else {\n\t\tcore_link_write_dpcd(link, DP_SOURCE_OUI,\n\t\t\t\tlink->dc->vendor_signature.data.raw,\n\t\t\t\tsizeof(link->dc->vendor_signature.data.raw));\n\t}\n}\n\nvoid dpcd_write_cable_id_to_dprx(struct dc_link *link)\n{\n\tif (!link->dpcd_caps.channel_coding_cap.bits.DP_128b_132b_SUPPORTED ||\n\t\t\tlink->dpcd_caps.cable_id.raw == 0 ||\n\t\t\tlink->dprx_states.cable_id_written)\n\t\treturn;\n\n\tcore_link_write_dpcd(link, DP_CABLE_ATTRIBUTES_UPDATED_BY_DPTX,\n\t\t\t&link->dpcd_caps.cable_id.raw,\n\t\t\tsizeof(link->dpcd_caps.cable_id.raw));\n\n\tlink->dprx_states.cable_id_written = 1;\n}\n\nstatic bool get_usbc_cable_id(struct dc_link *link, union dp_cable_id *cable_id)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tif (!link->ctx->dmub_srv ||\n\t\t\tlink->ep_type != DISPLAY_ENDPOINT_PHY ||\n\t\t\tlink->link_enc->features.flags.bits.DP_IS_USB_C == 0)\n\t\treturn false;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cable_id.header.type = DMUB_CMD_GET_USBC_CABLE_ID;\n\tcmd.cable_id.header.payload_bytes = sizeof(cmd.cable_id.data);\n\tcmd.cable_id.data.input.phy_inst = resource_transmitter_to_phy_idx(\n\t\t\tlink->dc, link->link_enc->transmitter);\n\tif (dm_execute_dmub_cmd(link->dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY) &&\n\t\t\tcmd.cable_id.header.ret_status == 1) {\n\t\tcable_id->raw = cmd.cable_id.data.output_raw;\n\t\tDC_LOG_DC(\"usbc_cable_id = %d.\\n\", cable_id->raw);\n\t}\n\treturn cmd.cable_id.header.ret_status == 1;\n}\n\nstatic void retrieve_cable_id(struct dc_link *link)\n{\n\tunion dp_cable_id usbc_cable_id;\n\n\tlink->dpcd_caps.cable_id.raw = 0;\n\tcore_link_read_dpcd(link, DP_CABLE_ATTRIBUTES_UPDATED_BY_DPRX,\n\t\t\t&link->dpcd_caps.cable_id.raw, sizeof(uint8_t));\n\n\tif (get_usbc_cable_id(link, &usbc_cable_id))\n\t\tlink->dpcd_caps.cable_id = intersect_cable_id(\n\t\t\t\t&link->dpcd_caps.cable_id, &usbc_cable_id);\n}\n\nbool read_is_mst_supported(struct dc_link *link)\n{\n\tbool mst          = false;\n\tenum dc_status st = DC_OK;\n\tunion dpcd_rev rev;\n\tunion mstm_cap cap;\n\n\tif (link->preferred_training_settings.mst_enable &&\n\t\t*link->preferred_training_settings.mst_enable == false) {\n\t\treturn false;\n\t}\n\n\trev.raw  = 0;\n\tcap.raw  = 0;\n\n\tst = core_link_read_dpcd(link, DP_DPCD_REV, &rev.raw,\n\t\t\tsizeof(rev));\n\n\tif (st == DC_OK && rev.raw >= DPCD_REV_12) {\n\n\t\tst = core_link_read_dpcd(link, DP_MSTM_CAP,\n\t\t\t\t&cap.raw, sizeof(cap));\n\t\tif (st == DC_OK && cap.bits.MST_CAP == 1)\n\t\t\tmst = true;\n\t}\n\treturn mst;\n\n}\n\n \nstatic bool dpcd_read_sink_ext_caps(struct dc_link *link)\n{\n\tuint8_t dpcd_data = 0;\n\tuint8_t edp_general_cap2 = 0;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (core_link_read_dpcd(link, DP_SOURCE_SINK_CAP, &dpcd_data, 1) != DC_OK)\n\t\treturn false;\n\n\tlink->dpcd_sink_ext_caps.raw = dpcd_data;\n\n\tif (core_link_read_dpcd(link, DP_EDP_GENERAL_CAP_2, &edp_general_cap2, 1) != DC_OK)\n\t\treturn false;\n\n\tlink->dpcd_caps.panel_luminance_control = (edp_general_cap2 & DP_EDP_PANEL_LUMINANCE_CONTROL_CAPABLE) != 0;\n\n\treturn true;\n}\n\nenum dc_status dp_retrieve_lttpr_cap(struct dc_link *link)\n{\n\tuint8_t lttpr_dpcd_data[8];\n\tenum dc_status status;\n\tbool is_lttpr_present;\n\n\t \n\tbool vbios_lttpr_interop = link->dc->caps.vbios_lttpr_aware;\n\n\tif (!vbios_lttpr_interop || !link->dc->caps.extended_aux_timeout_support)\n\t\treturn DC_NOT_SUPPORTED;\n\n\t \n\tstatus = core_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV,\n\t\t\tlttpr_dpcd_data,\n\t\t\tsizeof(lttpr_dpcd_data));\n\n\tlink->dpcd_caps.lttpr_caps.revision.raw =\n\t\t\tlttpr_dpcd_data[DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.max_link_rate =\n\t\t\tlttpr_dpcd_data[DP_MAX_LINK_RATE_PHY_REPEATER -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.phy_repeater_cnt =\n\t\t\tlttpr_dpcd_data[DP_PHY_REPEATER_CNT -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.max_lane_count =\n\t\t\tlttpr_dpcd_data[DP_MAX_LANE_COUNT_PHY_REPEATER -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.mode =\n\t\t\tlttpr_dpcd_data[DP_PHY_REPEATER_MODE -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.max_ext_timeout =\n\t\t\tlttpr_dpcd_data[DP_PHY_REPEATER_EXTENDED_WAIT_TIMEOUT -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\tlink->dpcd_caps.lttpr_caps.main_link_channel_coding.raw =\n\t\t\tlttpr_dpcd_data[DP_MAIN_LINK_CHANNEL_CODING_PHY_REPEATER -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\tlink->dpcd_caps.lttpr_caps.supported_128b_132b_rates.raw =\n\t\t\tlttpr_dpcd_data[DP_PHY_REPEATER_128B132B_RATES -\n\t\t\t\t\t\t\tDP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n\n\t \n\tif ((link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) &&\n\t\t\t(dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt) == 0)) {\n\t\tASSERT(0);\n\t\tlink->dpcd_caps.lttpr_caps.phy_repeater_cnt = 0x80;\n\t\tDC_LOG_DC(\"lttpr_caps forced phy_repeater_cnt = %d\\n\", link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\t}\n\n\t \n\tis_lttpr_present = dp_is_lttpr_present(link);\n\n\tif (is_lttpr_present)\n\t\tCONN_DATA_DETECT(link, lttpr_dpcd_data, sizeof(lttpr_dpcd_data), \"LTTPR Caps: \");\n\n\tDC_LOG_DC(\"is_lttpr_present = %d\\n\", is_lttpr_present);\n\treturn status;\n}\n\nstatic bool retrieve_link_cap(struct dc_link *link)\n{\n\t \n\tuint8_t dpcd_data[16];\n\t \n\tuint8_t dpcd_dprx_data = '\\0';\n\n\tstruct dp_device_vendor_id sink_id;\n\tunion down_stream_port_count down_strm_port_count;\n\tunion edp_configuration_cap edp_config_cap;\n\tunion dp_downstream_port_present ds_port = { 0 };\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\tuint32_t read_dpcd_retry_cnt = 3;\n\tint i;\n\tstruct dp_sink_hw_fw_revision dp_hw_fw_revision;\n\tconst uint32_t post_oui_delay = 30;  \n\tbool is_fec_supported = false;\n\tbool is_dsc_basic_supported = false;\n\tbool is_dsc_passthrough_supported = false;\n\n\tmemset(dpcd_data, '\\0', sizeof(dpcd_data));\n\tmemset(&down_strm_port_count,\n\t\t'\\0', sizeof(union down_stream_port_count));\n\tmemset(&edp_config_cap, '\\0',\n\t\tsizeof(union edp_configuration_cap));\n\n\t \n\ttry_to_configure_aux_timeout(link->ddc,\n\t\t\tLINK_AUX_DEFAULT_LTTPR_TIMEOUT_PERIOD);\n\n\tstatus = dp_retrieve_lttpr_cap(link);\n\n\tif (status != DC_OK) {\n\t\tstatus = wake_up_aux_channel(link);\n\t\tif (status == DC_OK)\n\t\t\tdp_retrieve_lttpr_cap(link);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tif (dp_is_lttpr_present(link))\n\t\tconfigure_lttpr_mode_transparent(link);\n\n\t \n\tstatus = dpcd_get_tunneling_device_data(link);\n\n\tdpcd_set_source_specific_data(link);\n\t \n\tmsleep(post_oui_delay);\n\n\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\tstatus = core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_DPCD_REV,\n\t\t\t\tdpcd_data,\n\t\t\t\tsizeof(dpcd_data));\n\t\tif (status == DC_OK)\n\t\t\tbreak;\n\t}\n\n\n\tif (status != DC_OK) {\n\t\tdm_error(\"%s: Read receiver caps dpcd data failed.\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tif (!dp_is_lttpr_present(link))\n\t\ttry_to_configure_aux_timeout(link->ddc, LINK_AUX_DEFAULT_TIMEOUT_PERIOD);\n\n\n\t{\n\t\tunion training_aux_rd_interval aux_rd_interval;\n\n\t\taux_rd_interval.raw =\n\t\t\tdpcd_data[DP_TRAINING_AUX_RD_INTERVAL];\n\n\t\tlink->dpcd_caps.ext_receiver_cap_field_present =\n\t\t\t\taux_rd_interval.bits.EXT_RECEIVER_CAP_FIELD_PRESENT == 1;\n\n\t\tif (aux_rd_interval.bits.EXT_RECEIVER_CAP_FIELD_PRESENT == 1) {\n\t\t\tuint8_t ext_cap_data[16];\n\n\t\t\tmemset(ext_cap_data, '\\0', sizeof(ext_cap_data));\n\t\t\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_DP13_DPCD_REV,\n\t\t\t\text_cap_data,\n\t\t\t\tsizeof(ext_cap_data));\n\t\t\t\tif (status == DC_OK) {\n\t\t\t\t\tmemcpy(dpcd_data, ext_cap_data, sizeof(dpcd_data));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (status != DC_OK)\n\t\t\t\tdm_error(\"%s: Read extend caps data failed, use cap from dpcd 0.\\n\", __func__);\n\t\t}\n\t}\n\n\tlink->dpcd_caps.dpcd_rev.raw =\n\t\t\tdpcd_data[DP_DPCD_REV - DP_DPCD_REV];\n\n\tif (link->dpcd_caps.ext_receiver_cap_field_present) {\n\t\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_DPRX_FEATURE_ENUMERATION_LIST,\n\t\t\t\t\t&dpcd_dprx_data,\n\t\t\t\t\tsizeof(dpcd_dprx_data));\n\t\t\tif (status == DC_OK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlink->dpcd_caps.dprx_feature.raw = dpcd_dprx_data;\n\n\t\tif (status != DC_OK)\n\t\t\tdm_error(\"%s: Read DPRX caps data failed.\\n\", __func__);\n\n\t\t \n\t\tdpcd_dprx_data = 0;\n\t\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink, DP_DPRX_FEATURE_ENUMERATION_LIST_CONT_1,\n\t\t\t\t\t&dpcd_dprx_data, sizeof(dpcd_dprx_data));\n\t\t\tif (status == DC_OK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlink->dpcd_caps.adaptive_sync_caps.dp_adap_sync_caps.raw = dpcd_dprx_data;\n\n\t\tif (status != DC_OK)\n\t\t\tdm_error(\"%s: Read DPRX caps data failed. Addr:%#x\\n\",\n\t\t\t\t\t__func__, DP_DPRX_FEATURE_ENUMERATION_LIST_CONT_1);\n\t}\n\n\telse {\n\t\tlink->dpcd_caps.dprx_feature.raw = 0;\n\t}\n\n\n\t \n\tif (dpcd_data[DP_MAX_LANE_COUNT - DP_DPCD_REV] == 0)\n\t\treturn false;\n\n\tds_port.byte = dpcd_data[DP_DOWNSTREAMPORT_PRESENT -\n\t\t\t\t DP_DPCD_REV];\n\n\tread_dp_device_vendor_id(link);\n\n\t \n\tlink->dpcd_caps.is_mst_capable = read_is_mst_supported(link);\n\tDC_LOG_DC(\"%s: MST_Support: %s\\n\", __func__, str_yes_no(link->dpcd_caps.is_mst_capable));\n\n\tget_active_converter_info(ds_port.byte, link);\n\n\tdp_wa_power_up_0010FA(link, dpcd_data, sizeof(dpcd_data));\n\n\tdown_strm_port_count.raw = dpcd_data[DP_DOWN_STREAM_PORT_COUNT -\n\t\t\t\t DP_DPCD_REV];\n\n\tlink->dpcd_caps.allow_invalid_MSA_timing_param =\n\t\tdown_strm_port_count.bits.IGNORE_MSA_TIMING_PARAM;\n\n\tlink->dpcd_caps.max_ln_count.raw = dpcd_data[\n\t\tDP_MAX_LANE_COUNT - DP_DPCD_REV];\n\n\tlink->dpcd_caps.max_down_spread.raw = dpcd_data[\n\t\tDP_MAX_DOWNSPREAD - DP_DPCD_REV];\n\n\tlink->reported_link_cap.lane_count =\n\t\tlink->dpcd_caps.max_ln_count.bits.MAX_LANE_COUNT;\n\tlink->reported_link_cap.link_rate = get_link_rate_from_max_link_bw(\n\t\t\tdpcd_data[DP_MAX_LINK_RATE - DP_DPCD_REV]);\n\tlink->reported_link_cap.link_spread =\n\t\tlink->dpcd_caps.max_down_spread.bits.MAX_DOWN_SPREAD ?\n\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ : LINK_SPREAD_DISABLED;\n\n\tedp_config_cap.raw = dpcd_data[\n\t\tDP_EDP_CONFIGURATION_CAP - DP_DPCD_REV];\n\tlink->dpcd_caps.panel_mode_edp =\n\t\tedp_config_cap.bits.ALT_SCRAMBLER_RESET;\n\tlink->dpcd_caps.dpcd_display_control_capable =\n\t\tedp_config_cap.bits.DPCD_DISPLAY_CONTROL_CAPABLE;\n\tlink->dpcd_caps.channel_coding_cap.raw =\n\t\t\tdpcd_data[DP_MAIN_LINK_CHANNEL_CODING - DP_DPCD_REV];\n\tlink->test_pattern_enabled = false;\n\tlink->compliance_test_state.raw = 0;\n\n\t \n\tcore_link_read_dpcd(link,\n\t\t\tDP_SINK_COUNT,\n\t\t\t&link->dpcd_caps.sink_count.raw,\n\t\t\tsizeof(link->dpcd_caps.sink_count.raw));\n\n\t \n\tcore_link_read_dpcd(link,\n\t\t\tDP_SINK_OUI,\n\t\t\t(uint8_t *)(&sink_id),\n\t\t\tsizeof(sink_id));\n\n\tlink->dpcd_caps.sink_dev_id =\n\t\t\t(sink_id.ieee_oui[0] << 16) +\n\t\t\t(sink_id.ieee_oui[1] << 8) +\n\t\t\t(sink_id.ieee_oui[2]);\n\n\tmemmove(\n\t\tlink->dpcd_caps.sink_dev_id_str,\n\t\tsink_id.ieee_device_id,\n\t\tsizeof(sink_id.ieee_device_id));\n\n\tcore_link_read_dpcd(\n\t\tlink,\n\t\tDP_SINK_HW_REVISION_START,\n\t\t(uint8_t *)&dp_hw_fw_revision,\n\t\tsizeof(dp_hw_fw_revision));\n\n\tlink->dpcd_caps.sink_hw_revision =\n\t\tdp_hw_fw_revision.ieee_hw_rev;\n\n\tmemmove(\n\t\tlink->dpcd_caps.sink_fw_revision,\n\t\tdp_hw_fw_revision.ieee_fw_rev,\n\t\tsizeof(dp_hw_fw_revision.ieee_fw_rev));\n\n\t \n\t{\n\t\tuint8_t str_mbp_2018[] = { 101, 68, 21, 103, 98, 97 };\n\t\tuint8_t fwrev_mbp_2018[] = { 7, 4 };\n\t\tuint8_t fwrev_mbp_2018_vega[] = { 8, 4 };\n\n\t\t \n\t\tif ((link->dpcd_caps.sink_dev_id == 0x0010fa) &&\n\t\t    !memcmp(link->dpcd_caps.sink_dev_id_str, str_mbp_2018,\n\t\t\t     sizeof(str_mbp_2018)) &&\n\t\t    (!memcmp(link->dpcd_caps.sink_fw_revision, fwrev_mbp_2018,\n\t\t\t     sizeof(fwrev_mbp_2018)) ||\n\t\t    !memcmp(link->dpcd_caps.sink_fw_revision, fwrev_mbp_2018_vega,\n\t\t\t     sizeof(fwrev_mbp_2018_vega)))) {\n\t\t\tlink->reported_link_cap.link_rate = LINK_RATE_RBR2;\n\t\t}\n\t}\n\n\tmemset(&link->dpcd_caps.dsc_caps, '\\0',\n\t\t\tsizeof(link->dpcd_caps.dsc_caps));\n\tmemset(&link->dpcd_caps.fec_cap, '\\0', sizeof(link->dpcd_caps.fec_cap));\n\t \n\tif (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_14) {\n\t\tstatus = core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_FEC_CAPABILITY,\n\t\t\t\t&link->dpcd_caps.fec_cap.raw,\n\t\t\t\tsizeof(link->dpcd_caps.fec_cap.raw));\n\t\tstatus = core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_DSC_SUPPORT,\n\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_basic_caps.raw,\n\t\t\t\tsizeof(link->dpcd_caps.dsc_caps.dsc_basic_caps.raw));\n\t\tif (status == DC_OK) {\n\t\t\tis_fec_supported = link->dpcd_caps.fec_cap.bits.FEC_CAPABLE;\n\t\t\tis_dsc_basic_supported = link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT;\n\t\t\tis_dsc_passthrough_supported = link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_PASSTHROUGH_SUPPORT;\n\t\t\tDC_LOG_DC(\"%s: FEC_Sink_Support: %s\\n\", __func__,\n\t\t\t\t  str_yes_no(is_fec_supported));\n\t\t\tDC_LOG_DC(\"%s: DSC_Basic_Sink_Support: %s\\n\", __func__,\n\t\t\t\t  str_yes_no(is_dsc_basic_supported));\n\t\t\tDC_LOG_DC(\"%s: DSC_Passthrough_Sink_Support: %s\\n\", __func__,\n\t\t\t\t  str_yes_no(is_dsc_passthrough_supported));\n\t\t}\n\t\tif (link->dpcd_caps.dongle_type != DISPLAY_DONGLE_NONE) {\n\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_DSC_BRANCH_OVERALL_THROUGHPUT_0,\n\t\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.raw,\n\t\t\t\t\tsizeof(link->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.raw));\n\t\t\tDC_LOG_DSC(\"DSC branch decoder capability is read at link %d\", link->link_index);\n\t\t\tDC_LOG_DSC(\"\\tBRANCH_OVERALL_THROUGHPUT_0 = 0x%02x\",\n\t\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.fields.BRANCH_OVERALL_THROUGHPUT_0);\n\t\t\tDC_LOG_DSC(\"\\tBRANCH_OVERALL_THROUGHPUT_1 = 0x%02x\",\n\t\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.fields.BRANCH_OVERALL_THROUGHPUT_1);\n\t\t\tDC_LOG_DSC(\"\\tBRANCH_MAX_LINE_WIDTH 0x%02x\",\n\t\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.fields.BRANCH_MAX_LINE_WIDTH);\n\t\t}\n\n\t\t \n\t\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA &&\n\t\t\t\tlink->dc->debug.dpia_debug.bits.enable_force_tbt3_work_around &&\n\t\t\t\tlink->dpcd_caps.is_branch_dev &&\n\t\t\t\tlink->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_90CC24 &&\n\t\t\t\tlink->dpcd_caps.branch_hw_revision == DP_BRANCH_HW_REV_10 &&\n\t\t\t\t(link->dpcd_caps.fec_cap.bits.FEC_CAPABLE ||\n\t\t\t\tlink->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT)) {\n\t\t\t \n\t\t\tlink->wa_flags.dpia_forced_tbt3_mode = true;\n\t\t\tmemset(&link->dpcd_caps.dsc_caps, '\\0', sizeof(link->dpcd_caps.dsc_caps));\n\t\t\tmemset(&link->dpcd_caps.fec_cap, '\\0', sizeof(link->dpcd_caps.fec_cap));\n\t\t\tDC_LOG_DSC(\"Clear DSC SUPPORT for USB4 link(%d) in TBT3 compatibility mode\", link->link_index);\n\t\t} else\n\t\t\tlink->wa_flags.dpia_forced_tbt3_mode = false;\n\t}\n\n\tif (!dpcd_read_sink_ext_caps(link))\n\t\tlink->dpcd_sink_ext_caps.raw = 0;\n\n\tif (link->dpcd_caps.channel_coding_cap.bits.DP_128b_132b_SUPPORTED) {\n\t\tDC_LOG_DP2(\"128b/132b encoding is supported at link %d\", link->link_index);\n\n\t\tcore_link_read_dpcd(link,\n\t\t\t\tDP_128B132B_SUPPORTED_LINK_RATES,\n\t\t\t\t&link->dpcd_caps.dp_128b_132b_supported_link_rates.raw,\n\t\t\t\tsizeof(link->dpcd_caps.dp_128b_132b_supported_link_rates.raw));\n\t\tif (link->dpcd_caps.dp_128b_132b_supported_link_rates.bits.UHBR20)\n\t\t\tlink->reported_link_cap.link_rate = LINK_RATE_UHBR20;\n\t\telse if (link->dpcd_caps.dp_128b_132b_supported_link_rates.bits.UHBR13_5)\n\t\t\tlink->reported_link_cap.link_rate = LINK_RATE_UHBR13_5;\n\t\telse if (link->dpcd_caps.dp_128b_132b_supported_link_rates.bits.UHBR10)\n\t\t\tlink->reported_link_cap.link_rate = LINK_RATE_UHBR10;\n\t\telse\n\t\t\tdm_error(\"%s: Invalid RX 128b_132b_supported_link_rates\\n\", __func__);\n\t\tDC_LOG_DP2(\"128b/132b supported link rates is read at link %d\", link->link_index);\n\t\tDC_LOG_DP2(\"\\tmax 128b/132b link rate support is %d.%d GHz\",\n\t\t\t\tlink->reported_link_cap.link_rate / 100,\n\t\t\t\tlink->reported_link_cap.link_rate % 100);\n\n\t\tcore_link_read_dpcd(link,\n\t\t\t\tDP_SINK_VIDEO_FALLBACK_FORMATS,\n\t\t\t\t&link->dpcd_caps.fallback_formats.raw,\n\t\t\t\tsizeof(link->dpcd_caps.fallback_formats.raw));\n\t\tDC_LOG_DP2(\"sink video fallback format is read at link %d\", link->link_index);\n\t\tif (link->dpcd_caps.fallback_formats.bits.dp_1920x1080_60Hz_24bpp_support)\n\t\t\tDC_LOG_DP2(\"\\t1920x1080@60Hz 24bpp fallback format supported\");\n\t\tif (link->dpcd_caps.fallback_formats.bits.dp_1280x720_60Hz_24bpp_support)\n\t\t\tDC_LOG_DP2(\"\\t1280x720@60Hz 24bpp fallback format supported\");\n\t\tif (link->dpcd_caps.fallback_formats.bits.dp_1024x768_60Hz_24bpp_support)\n\t\t\tDC_LOG_DP2(\"\\t1024x768@60Hz 24bpp fallback format supported\");\n\t\tif (link->dpcd_caps.fallback_formats.raw == 0) {\n\t\t\tDC_LOG_DP2(\"\\tno supported fallback formats, assume 1920x1080@60Hz 24bpp is supported\");\n\t\t\tlink->dpcd_caps.fallback_formats.bits.dp_1920x1080_60Hz_24bpp_support = 1;\n\t\t}\n\n\t\tcore_link_read_dpcd(link,\n\t\t\t\tDP_FEC_CAPABILITY_1,\n\t\t\t\t&link->dpcd_caps.fec_cap1.raw,\n\t\t\t\tsizeof(link->dpcd_caps.fec_cap1.raw));\n\t\tDC_LOG_DP2(\"FEC CAPABILITY 1 is read at link %d\", link->link_index);\n\t\tif (link->dpcd_caps.fec_cap1.bits.AGGREGATED_ERROR_COUNTERS_CAPABLE)\n\t\t\tDC_LOG_DP2(\"\\tFEC aggregated error counters are supported\");\n\t}\n\n\tretrieve_cable_id(link);\n\tdpcd_write_cable_id_to_dprx(link);\n\n\t \n\tCONN_DATA_DETECT(link, dpcd_data, sizeof(dpcd_data), \"Rx Caps: \");\n\n\treturn true;\n}\n\nbool detect_dp_sink_caps(struct dc_link *link)\n{\n\treturn retrieve_link_cap(link);\n}\n\nvoid detect_edp_sink_caps(struct dc_link *link)\n{\n\tuint8_t supported_link_rates[16];\n\tuint32_t entry;\n\tuint32_t link_rate_in_khz;\n\tenum dc_link_rate link_rate = LINK_RATE_UNKNOWN;\n\tuint8_t backlight_adj_cap;\n\tuint8_t general_edp_cap;\n\n\tretrieve_link_cap(link);\n\tlink->dpcd_caps.edp_supported_link_rates_count = 0;\n\tmemset(supported_link_rates, 0, sizeof(supported_link_rates));\n\n\t \n\tif (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_13) {\n\t\t \n\t\tcore_link_read_dpcd(link, DP_SUPPORTED_LINK_RATES,\n\t\t\t\t\t\t\tsupported_link_rates, sizeof(supported_link_rates));\n\n\t\tfor (entry = 0; entry < 16; entry += 2) {\n\t\t\t \n\t\t\t \n\t\t\tlink_rate_in_khz = (supported_link_rates[entry+1] * 0x100 +\n\t\t\t\t\t\t\t\t\t\tsupported_link_rates[entry]) * 200;\n\n\t\t\tDC_LOG_DC(\"%s: eDP v1.4 supported sink rates: [%d] %d kHz\\n\", __func__,\n\t\t\t\t  entry / 2, link_rate_in_khz);\n\n\t\t\tif (link_rate_in_khz != 0) {\n\t\t\t\tlink_rate = linkRateInKHzToLinkRateMultiplier(link_rate_in_khz);\n\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[link->dpcd_caps.edp_supported_link_rates_count] = link_rate;\n\t\t\t\tlink->dpcd_caps.edp_supported_link_rates_count++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcore_link_read_dpcd(link, DP_EDP_BACKLIGHT_ADJUSTMENT_CAP,\n\t\t\t\t\t\t&backlight_adj_cap, sizeof(backlight_adj_cap));\n\n\tlink->dpcd_caps.dynamic_backlight_capable_edp =\n\t\t\t\t(backlight_adj_cap & DP_EDP_DYNAMIC_BACKLIGHT_CAP) ? true:false;\n\n\tcore_link_read_dpcd(link, DP_EDP_GENERAL_CAP_1,\n\t\t\t\t\t\t&general_edp_cap, sizeof(general_edp_cap));\n\n\tlink->dpcd_caps.set_power_state_capable_edp =\n\t\t\t\t(general_edp_cap & DP_EDP_SET_POWER_CAP) ? true:false;\n\n\tset_default_brightness_aux(link);\n\n\tcore_link_read_dpcd(link, DP_EDP_DPCD_REV,\n\t\t&link->dpcd_caps.edp_rev,\n\t\tsizeof(link->dpcd_caps.edp_rev));\n\t \n\tif (link->dpcd_caps.edp_rev >= DP_EDP_13) {\n\t\tcore_link_read_dpcd(link, DP_PSR_SUPPORT,\n\t\t\t&link->dpcd_caps.psr_info.psr_version,\n\t\t\tsizeof(link->dpcd_caps.psr_info.psr_version));\n\t\tif (link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_001CF8)\n\t\t\tcore_link_read_dpcd(link, DP_FORCE_PSRSU_CAPABILITY,\n\t\t\t\t\t\t&link->dpcd_caps.psr_info.force_psrsu_cap,\n\t\t\t\t\t\tsizeof(link->dpcd_caps.psr_info.force_psrsu_cap));\n\t\tcore_link_read_dpcd(link, DP_PSR_CAPS,\n\t\t\t&link->dpcd_caps.psr_info.psr_dpcd_caps.raw,\n\t\t\tsizeof(link->dpcd_caps.psr_info.psr_dpcd_caps.raw));\n\t\tif (link->dpcd_caps.psr_info.psr_dpcd_caps.bits.Y_COORDINATE_REQUIRED) {\n\t\t\tcore_link_read_dpcd(link, DP_PSR2_SU_Y_GRANULARITY,\n\t\t\t\t&link->dpcd_caps.psr_info.psr2_su_y_granularity_cap,\n\t\t\t\tsizeof(link->dpcd_caps.psr_info.psr2_su_y_granularity_cap));\n\t\t}\n\t}\n\n\t \n\tif (link->dpcd_caps.dpcd_rev.raw >= DP_EDP_14)\n\t\tcore_link_read_dpcd(link, DP_RECEIVER_ALPM_CAP,\n\t\t\t&link->dpcd_caps.alpm_caps.raw,\n\t\t\tsizeof(link->dpcd_caps.alpm_caps.raw));\n\n\t \n\tcore_link_read_dpcd(link, DP_SINK_PR_PIXEL_DEVIATION_PER_LINE,\n\t\t\t&link->dpcd_caps.pr_info.pixel_deviation_per_line,\n\t\t\tsizeof(link->dpcd_caps.pr_info.pixel_deviation_per_line));\n\tcore_link_read_dpcd(link, DP_SINK_PR_MAX_NUMBER_OF_DEVIATION_LINE,\n\t\t\t&link->dpcd_caps.pr_info.max_deviation_line,\n\t\t\tsizeof(link->dpcd_caps.pr_info.max_deviation_line));\n}\n\nbool dp_get_max_link_enc_cap(const struct dc_link *link, struct dc_link_settings *max_link_enc_cap)\n{\n\tstruct link_encoder *link_enc = NULL;\n\n\tif (!max_link_enc_cap) {\n\t\tDC_LOG_ERROR(\"%s: Could not return max link encoder caps\", __func__);\n\t\treturn false;\n\t}\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\tif (link_enc && link_enc->funcs->get_max_link_cap) {\n\t\tlink_enc->funcs->get_max_link_cap(link_enc, max_link_enc_cap);\n\t\treturn true;\n\t}\n\n\tDC_LOG_ERROR(\"%s: Max link encoder caps unknown\", __func__);\n\tmax_link_enc_cap->lane_count = 1;\n\tmax_link_enc_cap->link_rate = 6;\n\treturn false;\n}\n\nconst struct dc_link_settings *dp_get_verified_link_cap(\n\t\tconst struct dc_link *link)\n{\n\tif (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&\n\t\t\tlink->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN)\n\t\treturn &link->preferred_link_setting;\n\treturn &link->verified_link_cap;\n}\n\nstruct dc_link_settings dp_get_max_link_cap(struct dc_link *link)\n{\n\tstruct dc_link_settings max_link_cap = {0};\n\tenum dc_link_rate lttpr_max_link_rate;\n\tenum dc_link_rate cable_max_link_rate;\n\tstruct link_encoder *link_enc = NULL;\n\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\t \n\tif (link_enc)\n\t\tlink_enc->funcs->get_max_link_cap(link_enc, &max_link_cap);\n\n\t \n\tif (link->reported_link_cap.lane_count < max_link_cap.lane_count)\n\t\tmax_link_cap.lane_count =\n\t\t\t\tlink->reported_link_cap.lane_count;\n\tif (link->reported_link_cap.link_rate < max_link_cap.link_rate)\n\t\tmax_link_cap.link_rate =\n\t\t\t\tlink->reported_link_cap.link_rate;\n\tif (link->reported_link_cap.link_spread <\n\t\t\tmax_link_cap.link_spread)\n\t\tmax_link_cap.link_spread =\n\t\t\t\tlink->reported_link_cap.link_spread;\n\n\t \n\tcable_max_link_rate = get_cable_max_link_rate(link);\n\n\tif (!link->dc->debug.ignore_cable_id &&\n\t\t\tcable_max_link_rate != LINK_RATE_UNKNOWN &&\n\t\t\tcable_max_link_rate < max_link_cap.link_rate)\n\t\tmax_link_cap.link_rate = cable_max_link_rate;\n\n\t \n\tif (dp_is_lttpr_present(link)) {\n\t\tif (link->dpcd_caps.lttpr_caps.max_lane_count < max_link_cap.lane_count)\n\t\t\tmax_link_cap.lane_count = link->dpcd_caps.lttpr_caps.max_lane_count;\n\t\tlttpr_max_link_rate = get_lttpr_max_link_rate(link);\n\n\t\tif (lttpr_max_link_rate < max_link_cap.link_rate)\n\t\t\tmax_link_cap.link_rate = lttpr_max_link_rate;\n\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n Training with LTTPR,  max_lane count %d max_link rate %d \\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tmax_link_cap.lane_count,\n\t\t\t\t\t\tmax_link_cap.link_rate);\n\t}\n\n\tif (link_dp_get_encoding_format(&max_link_cap) == DP_128b_132b_ENCODING &&\n\t\t\tlink->dc->debug.disable_uhbr)\n\t\tmax_link_cap.link_rate = LINK_RATE_HIGH3;\n\n\treturn max_link_cap;\n}\n\nstatic bool dp_verify_link_cap(\n\tstruct dc_link *link,\n\tstruct dc_link_settings *known_limit_link_setting,\n\tint *fail_count)\n{\n\tstruct dc_link_settings cur_link_settings = {0};\n\tstruct dc_link_settings max_link_settings = *known_limit_link_setting;\n\tbool success = false;\n\tbool skip_video_pattern;\n\tenum clock_source_id dp_cs_id = get_clock_source_id(link);\n\tenum link_training_result status = LINK_TRAINING_SUCCESS;\n\tunion hpd_irq_data irq_data;\n\tstruct link_resource link_res;\n\n\tmemset(&irq_data, 0, sizeof(irq_data));\n\tcur_link_settings = max_link_settings;\n\n\t \n\tif (dp_is_lttpr_present(link) && link->dpcd_caps.lttpr_caps.max_ext_timeout > 0) {\n\t\tuint8_t grant = link->dpcd_caps.lttpr_caps.max_ext_timeout & 0x80;\n\n\t\tcore_link_write_dpcd(link, DP_PHY_REPEATER_EXTENDED_WAIT_TIMEOUT, &grant, sizeof(grant));\n\t}\n\n\tdo {\n\t\tif (!get_temp_dp_link_res(link, &link_res, &cur_link_settings))\n\t\t\tcontinue;\n\n\t\tskip_video_pattern = cur_link_settings.link_rate != LINK_RATE_LOW;\n\t\tdp_enable_link_phy(\n\t\t\t\tlink,\n\t\t\t\t&link_res,\n\t\t\t\tlink->connector_signal,\n\t\t\t\tdp_cs_id,\n\t\t\t\t&cur_link_settings);\n\n\t\tstatus = dp_perform_link_training(\n\t\t\t\tlink,\n\t\t\t\t&link_res,\n\t\t\t\t&cur_link_settings,\n\t\t\t\tskip_video_pattern);\n\n\t\tif (status == LINK_TRAINING_SUCCESS) {\n\t\t\tsuccess = true;\n\t\t\tfsleep(1000);\n\t\t\tif (dp_read_hpd_rx_irq_data(link, &irq_data) == DC_OK &&\n\t\t\t\t\tdp_parse_link_loss_status(\n\t\t\t\t\t\t\tlink,\n\t\t\t\t\t\t\t&irq_data))\n\t\t\t\t(*fail_count)++;\n\t\t} else if (status == LINK_TRAINING_LINK_LOSS) {\n\t\t\tsuccess = true;\n\t\t\t(*fail_count)++;\n\t\t} else {\n\t\t\t(*fail_count)++;\n\t\t}\n\t\tdp_trace_lt_total_count_increment(link, true);\n\t\tdp_trace_lt_result_update(link, status, true);\n\t\tdp_disable_link_phy(link, &link_res, link->connector_signal);\n\t} while (!success && decide_fallback_link_setting(link,\n\t\t\t&max_link_settings, &cur_link_settings, status));\n\n\tlink->verified_link_cap = success ?\n\t\t\tcur_link_settings : fail_safe_link_settings;\n\treturn success;\n}\n\nbool dp_verify_link_cap_with_retries(\n\tstruct dc_link *link,\n\tstruct dc_link_settings *known_limit_link_setting,\n\tint attempts)\n{\n\tint i = 0;\n\tbool success = false;\n\tint fail_count = 0;\n\tstruct dc_link_settings last_verified_link_cap = fail_safe_link_settings;\n\n\tdp_trace_detect_lt_init(link);\n\n\tif (link->link_enc && link->link_enc->features.flags.bits.DP_IS_USB_C &&\n\t\t\tlink->dc->debug.usbc_combo_phy_reset_wa)\n\t\tapply_usbc_combo_phy_reset_wa(link, known_limit_link_setting);\n\n\tdp_trace_set_lt_start_timestamp(link, false);\n\tfor (i = 0; i < attempts; i++) {\n\t\tenum dc_connection_type type = dc_connection_none;\n\n\t\tmemset(&link->verified_link_cap, 0,\n\t\t\t\tsizeof(struct dc_link_settings));\n\t\tif (!link_detect_connection_type(link, &type) || type == dc_connection_none) {\n\t\t\tlink->verified_link_cap = fail_safe_link_settings;\n\t\t\tbreak;\n\t\t} else if (dp_verify_link_cap(link, known_limit_link_setting, &fail_count)) {\n\t\t\tlast_verified_link_cap = link->verified_link_cap;\n\t\t\tif (fail_count == 0) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlink->verified_link_cap = last_verified_link_cap;\n\t\t}\n\t\tfsleep(10 * 1000);\n\t}\n\n\tdp_trace_lt_fail_count_update(link, fail_count, true);\n\tdp_trace_set_lt_end_timestamp(link, true);\n\n\treturn success;\n}\n\n \nbool dp_is_sink_present(struct dc_link *link)\n{\n\tenum gpio_result gpio_result;\n\tuint32_t clock_pin = 0;\n\tuint8_t retry = 0;\n\tstruct ddc *ddc;\n\n\tenum connector_id connector_id =\n\t\tdal_graphics_object_id_get_connector_id(link->link_id);\n\n\tbool present =\n\t\t((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||\n\t\t(connector_id == CONNECTOR_ID_EDP) ||\n\t\t(connector_id == CONNECTOR_ID_USBC));\n\n\tddc = get_ddc_pin(link->ddc);\n\n\tif (!ddc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn present;\n\t}\n\n\t \n\t \n\n\tif (dal_ddc_open(ddc, GPIO_MODE_INPUT,\n\t\t\t GPIO_DDC_CONFIG_TYPE_MODE_I2C) != GPIO_RESULT_OK) {\n\t\tdal_ddc_close(ddc);\n\n\t\treturn present;\n\t}\n\n\t \n\tdo {\n\t\tgpio_result = dal_gpio_get_value(ddc->pin_clock, &clock_pin);\n\t\tASSERT(gpio_result == GPIO_RESULT_OK);\n\t\tif (clock_pin)\n\t\t\tfsleep(1000);\n\t\telse\n\t\t\tbreak;\n\t} while (retry++ < 3);\n\n\tpresent = (gpio_result == GPIO_RESULT_OK) && !clock_pin;\n\n\tdal_ddc_close(ddc);\n\n\treturn present;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}