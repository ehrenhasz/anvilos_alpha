{
  "module_name": "dce60_timing_generator.c",
  "hash_id": "a3614ed0ab65bec8f439306e08bdbe2ecafeb475be6e136749aa4c50d5cdd313",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce60/dce60_timing_generator.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n \n#include \"dce/dce_6_0_d.h\"\n#include \"dce/dce_6_0_sh_mask.h\"\n\n#include \"dc_types.h\"\n\n#include \"include/grph_object_id.h\"\n#include \"include/logger_interface.h\"\n#include \"../dce110/dce110_timing_generator.h\"\n#include \"dce60_timing_generator.h\"\n\n#include \"timing_generator.h\"\n\nenum black_color_format {\n\tBLACK_COLOR_FORMAT_RGB_FULLRANGE = 0,\t \n\tBLACK_COLOR_FORMAT_RGB_LIMITED,\n\tBLACK_COLOR_FORMAT_YUV_TV,\n\tBLACK_COLOR_FORMAT_YUV_CV,\n\tBLACK_COLOR_FORMAT_YUV_SUPER_AA,\n\n\tBLACK_COLOR_FORMAT_COUNT\n};\n\nstatic const struct dce110_timing_generator_offsets reg_offsets[] = {\n{\n\t.crtc = (mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n},\n{\n\t.crtc = (mmCRTC1_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP1_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n},\n{\n\t.crtc = (mmCRTC2_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP2_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n},\n{\n\t.crtc = (mmCRTC3_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP3_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n},\n{\n\t.crtc = (mmCRTC4_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP4_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n},\n{\n\t.crtc = (mmCRTC5_DCFE_MEM_LIGHT_SLEEP_CNTL - mmCRTC0_DCFE_MEM_LIGHT_SLEEP_CNTL),\n\t.dcp = (mmDCP5_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),\n}\n};\n\n#define NUMBER_OF_FRAME_TO_WAIT_ON_TRIGGERED_RESET 10\n\n#define MAX_H_TOTAL (CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1)\n#define MAX_V_TOTAL (CRTC_V_TOTAL__CRTC_V_TOTAL_MASKhw + 1)\n\n#define CRTC_REG(reg) (reg + tg110->offsets.crtc)\n#define DCP_REG(reg) (reg + tg110->offsets.dcp)\n#define DMIF_REG(reg) (reg + tg110->offsets.dmif)\n\nstatic void program_pix_dur(struct timing_generator *tg, uint32_t pix_clk_100hz)\n{\n\tuint64_t pix_dur;\n\tuint32_t addr = mmDMIF_PG0_DPG_PIPE_ARBITRATION_CONTROL1\n\t\t\t\t\t+ DCE110TG_FROM_TG(tg)->offsets.dmif;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tif (pix_clk_100hz == 0)\n\t\treturn;\n\n\tpix_dur = div_u64(10000000000ull, pix_clk_100hz);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tpix_dur,\n\t\tDPG_PIPE_ARBITRATION_CONTROL1,\n\t\tPIXEL_DURATION);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic void program_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tint vready_offset,\n\tint vstartup_start,\n\tint vupdate_offset,\n\tint vupdate_width,\n\tconst enum signal_type signal,\n\tbool use_vbios)\n{\n\tif (!use_vbios)\n\t\tprogram_pix_dur(tg, timing->pix_clk_100hz);\n\n\tdce110_tg_program_timing(tg, timing, 0, 0, 0, 0, 0, use_vbios);\n}\n\nstatic void dce60_timing_generator_enable_advanced_request(\n\tstruct timing_generator *tg,\n\tbool enable,\n\tconst struct dc_crtc_timing *timing)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_START_LINE_CONTROL);\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\t \n\tuint32_t addr2 = CRTC_REG(mmCRTC_CONTROL);\n\tuint32_t value2 = dm_read_reg(tg->ctx, addr2);\n\n\t \n\n\tif ((timing->v_sync_width + timing->v_front_porch) <= 3) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t3,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\tset_reg_field_value(\n\t\t\tvalue2,\n\t\t\t0,\n\t\t\tCRTC_CONTROL,\n\t\t\tCRTC_PREFETCH_EN);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\tset_reg_field_value(\n\t\t\tvalue2,\n\t\t\t1,\n\t\t\tCRTC_CONTROL,\n\t\t\tCRTC_PREFETCH_EN);\n\t}\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTC_START_LINE_CONTROL,\n\t\tCRTC_PROGRESSIVE_START_LINE_EARLY);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTC_START_LINE_CONTROL,\n\t\tCRTC_INTERLACE_START_LINE_EARLY);\n\n\tdm_write_reg(tg->ctx, addr, value);\n\tdm_write_reg(tg->ctx, addr2, value2);\n}\n\nstatic bool dce60_is_tg_enabled(struct timing_generator *tg)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\tuint32_t field = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\taddr = CRTC_REG(mmCRTC_CONTROL);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tfield = get_reg_field_value(value, CRTC_CONTROL,\n\t\t\t\t    CRTC_CURRENT_MASTER_EN_STATE);\n\treturn field == 1;\n}\n\nstatic bool dce60_configure_crc(struct timing_generator *tg,\n\t\t\t\tconst struct crc_params *params)\n{\n\t \n\tif (!dce60_is_tg_enabled(tg))\n\t\treturn false;\n\n\t \n\n\treturn true;\n}\n\nstatic const struct timing_generator_funcs dce60_tg_funcs = {\n\t\t.validate_timing = dce110_tg_validate_timing,\n\t\t.program_timing = program_timing,\n\t\t.enable_crtc = dce110_timing_generator_enable_crtc,\n\t\t.disable_crtc = dce110_timing_generator_disable_crtc,\n\t\t.is_counter_moving = dce110_timing_generator_is_counter_moving,\n\t\t.get_position = dce110_timing_generator_get_position,\n\t\t.get_frame_count = dce110_timing_generator_get_vblank_counter,\n\t\t.get_scanoutpos = dce110_timing_generator_get_crtc_scanoutpos,\n\t\t.set_early_control = dce110_timing_generator_set_early_control,\n\t\t.wait_for_state = dce110_tg_wait_for_state,\n\t\t.set_blank = dce110_tg_set_blank,\n\t\t.is_blanked = dce110_tg_is_blanked,\n\t\t.set_colors = dce110_tg_set_colors,\n\t\t.set_overscan_blank_color =\n\t\t\t\tdce110_timing_generator_set_overscan_color_black,\n\t\t.set_blank_color = dce110_timing_generator_program_blank_color,\n\t\t.disable_vga = dce110_timing_generator_disable_vga,\n\t\t.did_triggered_reset_occur =\n\t\t\t\tdce110_timing_generator_did_triggered_reset_occur,\n\t\t.setup_global_swap_lock =\n\t\t\t\tdce110_timing_generator_setup_global_swap_lock,\n\t\t.enable_reset_trigger = dce110_timing_generator_enable_reset_trigger,\n\t\t.disable_reset_trigger = dce110_timing_generator_disable_reset_trigger,\n\t\t.tear_down_global_swap_lock =\n\t\t\t\tdce110_timing_generator_tear_down_global_swap_lock,\n\t\t.set_drr = dce110_timing_generator_set_drr,\n\t\t.set_static_screen_control =\n\t\t\tdce110_timing_generator_set_static_screen_control,\n\t\t.set_test_pattern = dce110_timing_generator_set_test_pattern,\n\t\t.arm_vert_intr = dce110_arm_vert_intr,\n\n\t\t \n\t\t.enable_advanced_request =\n\t\t\t\tdce60_timing_generator_enable_advanced_request,\n\t\t.configure_crc = dce60_configure_crc,\n\t\t.get_crc = dce110_get_crc,\n};\n\nvoid dce60_timing_generator_construct(\n\tstruct dce110_timing_generator *tg110,\n\tstruct dc_context *ctx,\n\tuint32_t instance,\n\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\ttg110->controller_id = CONTROLLER_ID_D0 + instance;\n\ttg110->base.inst = instance;\n\ttg110->offsets = *offsets;\n\ttg110->derived_offsets = reg_offsets[instance];\n\n\ttg110->base.funcs = &dce60_tg_funcs;\n\n\ttg110->base.ctx = ctx;\n\ttg110->base.bp = ctx->dc_bios;\n\n\ttg110->max_h_total = CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1;\n\ttg110->max_v_total = CRTC_V_TOTAL__CRTC_V_TOTAL_MASK + 1;\n\n\ttg110->min_h_blank = 56;\n\ttg110->min_h_front_porch = 4;\n\ttg110->min_h_back_porch = 4;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}