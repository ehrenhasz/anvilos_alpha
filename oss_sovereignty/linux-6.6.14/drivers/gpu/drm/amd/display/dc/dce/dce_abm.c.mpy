{
  "module_name": "dce_abm.c",
  "hash_id": "09ab0ac9b31e173b3faf92288b66336100e90eee8a465f3467526adc33067528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_abm.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"dce_abm.h\"\n#include \"dm_services.h\"\n#include \"reg_helper.h\"\n#include \"fixed31_32.h\"\n#include \"dc.h\"\n\n#include \"atom.h\"\n\n\n#define TO_DCE_ABM(abm)\\\n\tcontainer_of(abm, struct dce_abm, base)\n\n#define REG(reg) \\\n\t(abm_dce->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tabm_dce->abm_shift->field_name, abm_dce->abm_mask->field_name\n\n#define DC_LOGGER \\\n\tabm->ctx->logger\n#define CTX \\\n\tabm_dce->base.ctx\n\n#define MCP_ABM_LEVEL_SET 0x65\n#define MCP_ABM_PIPE_SET 0x66\n#define MCP_BL_SET 0x67\n\n#define MCP_DISABLE_ABM_IMMEDIATELY 255\n\nstatic bool dce_abm_set_pipe(struct abm *abm, uint32_t controller_id, uint32_t panel_inst)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\tuint32_t rampingBoundary = 0xFFFF;\n\n\tif (abm->dmcu_is_running == false)\n\t\treturn true;\n\n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t1, 80000);\n\n\t \n\tREG_WRITE(MASTER_COMM_DATA_REG1, rampingBoundary);\n\n\t \n\tREG_UPDATE_2(MASTER_COMM_CMD_REG,\n\t\t\tMASTER_COMM_CMD_REG_BYTE0, MCP_ABM_PIPE_SET,\n\t\t\tMASTER_COMM_CMD_REG_BYTE1, controller_id);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t1, 80000);\n\n\treturn true;\n}\n\nstatic void dmcu_set_backlight_level(\n\tstruct dce_abm *abm_dce,\n\tuint32_t backlight_pwm_u16_16,\n\tuint32_t frame_ramp,\n\tuint32_t controller_id,\n\tuint32_t panel_id)\n{\n\tunsigned int backlight_8_bit = 0;\n\tuint32_t s2;\n\n\tif (backlight_pwm_u16_16 & 0x10000)\n\t\t\n\t\tbacklight_8_bit = 0xFF;\n\telse\n\t\t\n\t\tbacklight_8_bit = (backlight_pwm_u16_16 >> 8) & 0xFF;\n\n\tdce_abm_set_pipe(&abm_dce->base, controller_id, panel_id);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT,\n\t\t\t0, 1, 80000);\n\n\t \n\tREG_UPDATE(BL1_PWM_USER_LEVEL, BL1_PWM_USER_LEVEL, backlight_pwm_u16_16);\n\n\t \n\tif (controller_id == 0)\n\t\tframe_ramp = 0;\n\tREG_WRITE(MASTER_COMM_DATA_REG1, frame_ramp);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, MCP_BL_SET);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\ts2 = REG_READ(BIOS_SCRATCH_2);\n\n\ts2 &= ~ATOM_S2_CURRENT_BL_LEVEL_MASK;\n\tbacklight_8_bit &= (ATOM_S2_CURRENT_BL_LEVEL_MASK >>\n\t\t\t\tATOM_S2_CURRENT_BL_LEVEL_SHIFT);\n\ts2 |= (backlight_8_bit << ATOM_S2_CURRENT_BL_LEVEL_SHIFT);\n\n\tREG_WRITE(BIOS_SCRATCH_2, s2);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT,\n\t\t\t0, 1, 80000);\n}\n\nstatic void dce_abm_init(struct abm *abm, uint32_t backlight)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\n\tREG_WRITE(DC_ABM1_HG_SAMPLE_RATE, 0x103);\n\tREG_WRITE(DC_ABM1_HG_SAMPLE_RATE, 0x101);\n\tREG_WRITE(DC_ABM1_LS_SAMPLE_RATE, 0x103);\n\tREG_WRITE(DC_ABM1_LS_SAMPLE_RATE, 0x101);\n\tREG_WRITE(BL1_PWM_BL_UPDATE_SAMPLE_RATE, 0x101);\n\n\tREG_SET_3(DC_ABM1_HG_MISC_CTRL, 0,\n\t\t\tABM1_HG_NUM_OF_BINS_SEL, 0,\n\t\t\tABM1_HG_VMAX_SEL, 1,\n\t\t\tABM1_HG_BIN_BITWIDTH_SIZE_SEL, 0);\n\n\tREG_SET_3(DC_ABM1_IPCSC_COEFF_SEL, 0,\n\t\t\tABM1_IPCSC_COEFF_SEL_R, 2,\n\t\t\tABM1_IPCSC_COEFF_SEL_G, 4,\n\t\t\tABM1_IPCSC_COEFF_SEL_B, 2);\n\n\tREG_UPDATE(BL1_PWM_CURRENT_ABM_LEVEL,\n\t\t\tBL1_PWM_CURRENT_ABM_LEVEL, backlight);\n\n\tREG_UPDATE(BL1_PWM_TARGET_ABM_LEVEL,\n\t\t\tBL1_PWM_TARGET_ABM_LEVEL, backlight);\n\n\tREG_UPDATE(BL1_PWM_USER_LEVEL,\n\t\t\tBL1_PWM_USER_LEVEL, backlight);\n\n\tREG_UPDATE_2(DC_ABM1_LS_MIN_MAX_PIXEL_VALUE_THRES,\n\t\t\tABM1_LS_MIN_PIXEL_VALUE_THRES, 0,\n\t\t\tABM1_LS_MAX_PIXEL_VALUE_THRES, 1000);\n\n\tREG_SET_3(DC_ABM1_HGLS_REG_READ_PROGRESS, 0,\n\t\t\tABM1_HG_REG_READ_MISSED_FRAME_CLEAR, 1,\n\t\t\tABM1_LS_REG_READ_MISSED_FRAME_CLEAR, 1,\n\t\t\tABM1_BL_REG_READ_MISSED_FRAME_CLEAR, 1);\n}\n\nstatic unsigned int dce_abm_get_current_backlight(struct abm *abm)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\tunsigned int backlight = REG_READ(BL1_PWM_CURRENT_ABM_LEVEL);\n\n\t \n\treturn backlight;\n}\n\nstatic unsigned int dce_abm_get_target_backlight(struct abm *abm)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\tunsigned int backlight = REG_READ(BL1_PWM_TARGET_ABM_LEVEL);\n\n\t \n\treturn backlight;\n}\n\nstatic bool dce_abm_set_level(struct abm *abm, uint32_t level)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\n\tif (abm->dmcu_is_running == false)\n\t\treturn true;\n\n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t1, 80000);\n\n\t \n\tREG_UPDATE_2(MASTER_COMM_CMD_REG,\n\t\t\tMASTER_COMM_CMD_REG_BYTE0, MCP_ABM_LEVEL_SET,\n\t\t\tMASTER_COMM_CMD_REG_BYTE2, level);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\treturn true;\n}\n\nstatic bool dce_abm_immediate_disable(struct abm *abm, uint32_t panel_inst)\n{\n\tif (abm->dmcu_is_running == false)\n\t\treturn true;\n\n\tdce_abm_set_pipe(abm, MCP_DISABLE_ABM_IMMEDIATELY, panel_inst);\n\n\treturn true;\n}\n\nstatic bool dce_abm_set_backlight_level_pwm(\n\t\tstruct abm *abm,\n\t\tunsigned int backlight_pwm_u16_16,\n\t\tunsigned int frame_ramp,\n\t\tunsigned int controller_id,\n\t\tunsigned int panel_inst)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(abm);\n\n\tDC_LOG_BACKLIGHT(\"New Backlight level: %d (0x%X)\\n\",\n\t\t\tbacklight_pwm_u16_16, backlight_pwm_u16_16);\n\n\tdmcu_set_backlight_level(abm_dce,\n\t\t\tbacklight_pwm_u16_16,\n\t\t\tframe_ramp,\n\t\t\tcontroller_id,\n\t\t\tpanel_inst);\n\n\treturn true;\n}\n\nstatic const struct abm_funcs dce_funcs = {\n\t.abm_init = dce_abm_init,\n\t.set_abm_level = dce_abm_set_level,\n\t.set_pipe = dce_abm_set_pipe,\n\t.set_backlight_level_pwm = dce_abm_set_backlight_level_pwm,\n\t.get_current_backlight = dce_abm_get_current_backlight,\n\t.get_target_backlight = dce_abm_get_target_backlight,\n\t.init_abm_config = NULL,\n\t.set_abm_immediate_disable = dce_abm_immediate_disable,\n};\n\nstatic void dce_abm_construct(\n\tstruct dce_abm *abm_dce,\n\tstruct dc_context *ctx,\n\tconst struct dce_abm_registers *regs,\n\tconst struct dce_abm_shift *abm_shift,\n\tconst struct dce_abm_mask *abm_mask)\n{\n\tstruct abm *base = &abm_dce->base;\n\n\tbase->ctx = ctx;\n\tbase->funcs = &dce_funcs;\n\tbase->dmcu_is_running = false;\n\n\tabm_dce->regs = regs;\n\tabm_dce->abm_shift = abm_shift;\n\tabm_dce->abm_mask = abm_mask;\n}\n\nstruct abm *dce_abm_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_abm_registers *regs,\n\tconst struct dce_abm_shift *abm_shift,\n\tconst struct dce_abm_mask *abm_mask)\n{\n\tstruct dce_abm *abm_dce = kzalloc(sizeof(*abm_dce), GFP_ATOMIC);\n\n\tif (abm_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_abm_construct(abm_dce, ctx, regs, abm_shift, abm_mask);\n\n\tabm_dce->base.funcs = &dce_funcs;\n\n\treturn &abm_dce->base;\n}\n\nvoid dce_abm_destroy(struct abm **abm)\n{\n\tstruct dce_abm *abm_dce = TO_DCE_ABM(*abm);\n\n\tkfree(abm_dce);\n\t*abm = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}