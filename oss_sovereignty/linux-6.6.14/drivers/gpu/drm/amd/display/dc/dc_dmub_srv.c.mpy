{
  "module_name": "dc_dmub_srv.c",
  "hash_id": "f4c94240a06c30a54511acb05c19119ebcb13d6ba162bf454136a23f0708097c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c",
  "human_readable_source": " \n\n#include \"dc.h\"\n#include \"dc_dmub_srv.h\"\n#include \"../dmub/dmub_srv.h\"\n#include \"dm_helpers.h\"\n#include \"dc_hw_types.h\"\n#include \"core_types.h\"\n#include \"../basics/conversion.h\"\n#include \"cursor_reg_cache.h\"\n#include \"resource.h\"\n\n#define CTX dc_dmub_srv->ctx\n#define DC_LOGGER CTX->logger\n\nstatic void dc_dmub_srv_construct(struct dc_dmub_srv *dc_srv, struct dc *dc,\n\t\t\t\t  struct dmub_srv *dmub)\n{\n\tdc_srv->dmub = dmub;\n\tdc_srv->ctx = dc->ctx;\n}\n\nstruct dc_dmub_srv *dc_dmub_srv_create(struct dc *dc, struct dmub_srv *dmub)\n{\n\tstruct dc_dmub_srv *dc_srv =\n\t\tkzalloc(sizeof(struct dc_dmub_srv), GFP_KERNEL);\n\n\tif (dc_srv == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdc_dmub_srv_construct(dc_srv, dc, dmub);\n\n\treturn dc_srv;\n}\n\nvoid dc_dmub_srv_destroy(struct dc_dmub_srv **dmub_srv)\n{\n\tif (*dmub_srv) {\n\t\tkfree(*dmub_srv);\n\t\t*dmub_srv = NULL;\n\t}\n}\n\nvoid dc_dmub_srv_wait_idle(struct dc_dmub_srv *dc_dmub_srv)\n{\n\tstruct dmub_srv *dmub = dc_dmub_srv->dmub;\n\tstruct dc_context *dc_ctx = dc_dmub_srv->ctx;\n\tenum dmub_status status;\n\n\tstatus = dmub_srv_wait_for_idle(dmub, 100000);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error waiting for DMUB idle: status=%d\\n\", status);\n\t\tdc_dmub_srv_log_diagnostic_data(dc_dmub_srv);\n\t}\n}\n\nvoid dc_dmub_srv_clear_inbox0_ack(struct dc_dmub_srv *dmub_srv)\n{\n\tstruct dmub_srv *dmub = dmub_srv->dmub;\n\tstruct dc_context *dc_ctx = dmub_srv->ctx;\n\tenum dmub_status status = DMUB_STATUS_OK;\n\n\tstatus = dmub_srv_clear_inbox0_ack(dmub);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error clearing INBOX0 ack: status=%d\\n\", status);\n\t\tdc_dmub_srv_log_diagnostic_data(dmub_srv);\n\t}\n}\n\nvoid dc_dmub_srv_wait_for_inbox0_ack(struct dc_dmub_srv *dmub_srv)\n{\n\tstruct dmub_srv *dmub = dmub_srv->dmub;\n\tstruct dc_context *dc_ctx = dmub_srv->ctx;\n\tenum dmub_status status = DMUB_STATUS_OK;\n\n\tstatus = dmub_srv_wait_for_inbox0_ack(dmub, 100000);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error waiting for INBOX0 HW Lock Ack\\n\");\n\t\tdc_dmub_srv_log_diagnostic_data(dmub_srv);\n\t}\n}\n\nvoid dc_dmub_srv_send_inbox0_cmd(struct dc_dmub_srv *dmub_srv,\n\t\tunion dmub_inbox0_data_register data)\n{\n\tstruct dmub_srv *dmub = dmub_srv->dmub;\n\tstruct dc_context *dc_ctx = dmub_srv->ctx;\n\tenum dmub_status status = DMUB_STATUS_OK;\n\n\tstatus = dmub_srv_send_inbox0_cmd(dmub, data);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error sending INBOX0 cmd\\n\");\n\t\tdc_dmub_srv_log_diagnostic_data(dmub_srv);\n\t}\n}\n\nbool dc_dmub_srv_cmd_run(struct dc_dmub_srv *dc_dmub_srv, union dmub_rb_cmd *cmd, enum dm_dmub_wait_type wait_type)\n{\n\treturn dc_dmub_srv_cmd_run_list(dc_dmub_srv, 1, cmd, wait_type);\n}\n\nbool dc_dmub_srv_cmd_run_list(struct dc_dmub_srv *dc_dmub_srv, unsigned int count, union dmub_rb_cmd *cmd_list, enum dm_dmub_wait_type wait_type)\n{\n\tstruct dc_context *dc_ctx;\n\tstruct dmub_srv *dmub;\n\tenum dmub_status status;\n\tint i;\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub)\n\t\treturn false;\n\n\tdc_ctx = dc_dmub_srv->ctx;\n\tdmub = dc_dmub_srv->dmub;\n\n\tfor (i = 0 ; i < count; i++) {\n\t\t\n\t\tstatus = dmub_srv_cmd_queue(dmub, &cmd_list[i]);\n\n\t\tif (status == DMUB_STATUS_QUEUE_FULL) {\n\t\t\t \n\t\t\tdmub_srv_cmd_execute(dmub);\n\t\t\tdmub_srv_wait_for_idle(dmub, 100000);\n\n\t\t\t \n\t\t\tstatus = dmub_srv_cmd_queue(dmub, &cmd_list[i]);\n\t\t}\n\n\t\tif (status != DMUB_STATUS_OK) {\n\t\t\tDC_ERROR(\"Error queueing DMUB command: status=%d\\n\", status);\n\t\t\tdc_dmub_srv_log_diagnostic_data(dc_dmub_srv);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatus = dmub_srv_cmd_execute(dmub);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error starting DMUB execution: status=%d\\n\", status);\n\t\tdc_dmub_srv_log_diagnostic_data(dc_dmub_srv);\n\t\treturn false;\n\t}\n\n\t\n\tif (wait_type != DM_DMUB_WAIT_TYPE_NO_WAIT) {\n\t\tstatus = dmub_srv_wait_for_idle(dmub, 100000);\n\n\t\tif (status != DMUB_STATUS_OK) {\n\t\t\tDC_LOG_DEBUG(\"No reply for DMUB command: status=%d\\n\", status);\n\t\t\tdc_dmub_srv_log_diagnostic_data(dc_dmub_srv);\n\t\t\treturn false;\n\t\t}\n\n\t\t\n\t\tif (wait_type == DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY)\n\t\t\tdmub_rb_get_return_data(&dmub->inbox1_rb, cmd_list);\n\t}\n\n\treturn true;\n}\n\nbool dc_dmub_srv_optimized_init_done(struct dc_dmub_srv *dc_dmub_srv)\n{\n\tstruct dmub_srv *dmub;\n\tstruct dc_context *dc_ctx;\n\tunion dmub_fw_boot_status boot_status;\n\tenum dmub_status status;\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub)\n\t\treturn false;\n\n\tdmub = dc_dmub_srv->dmub;\n\tdc_ctx = dc_dmub_srv->ctx;\n\n\tstatus = dmub_srv_get_fw_boot_status(dmub, &boot_status);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error querying DMUB boot status: error=%d\\n\", status);\n\t\treturn false;\n\t}\n\n\treturn boot_status.bits.optimized_init_done;\n}\n\nbool dc_dmub_srv_notify_stream_mask(struct dc_dmub_srv *dc_dmub_srv,\n\t\t\t\t    unsigned int stream_mask)\n{\n\tstruct dmub_srv *dmub;\n\tconst uint32_t timeout = 30;\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub)\n\t\treturn false;\n\n\tdmub = dc_dmub_srv->dmub;\n\n\treturn dmub_srv_send_gpint_command(\n\t\t       dmub, DMUB_GPINT__IDLE_OPT_NOTIFY_STREAM_MASK,\n\t\t       stream_mask, timeout) == DMUB_STATUS_OK;\n}\n\nbool dc_dmub_srv_is_restore_required(struct dc_dmub_srv *dc_dmub_srv)\n{\n\tstruct dmub_srv *dmub;\n\tstruct dc_context *dc_ctx;\n\tunion dmub_fw_boot_status boot_status;\n\tenum dmub_status status;\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub)\n\t\treturn false;\n\n\tdmub = dc_dmub_srv->dmub;\n\tdc_ctx = dc_dmub_srv->ctx;\n\n\tstatus = dmub_srv_get_fw_boot_status(dmub, &boot_status);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_ERROR(\"Error querying DMUB boot status: error=%d\\n\", status);\n\t\treturn false;\n\t}\n\n\treturn boot_status.bits.restore_required;\n}\n\nbool dc_dmub_srv_get_dmub_outbox0_msg(const struct dc *dc, struct dmcub_trace_buf_entry *entry)\n{\n\tstruct dmub_srv *dmub = dc->ctx->dmub_srv->dmub;\n\treturn dmub_srv_get_outbox0_msg(dmub, entry);\n}\n\nvoid dc_dmub_trace_event_control(struct dc *dc, bool enable)\n{\n\tdm_helpers_dmub_outbox_interrupt_control(dc->ctx, enable);\n}\n\nvoid dc_dmub_srv_drr_update_cmd(struct dc *dc, uint32_t tg_inst, uint32_t vtotal_min, uint32_t vtotal_max)\n{\n\tunion dmub_rb_cmd cmd = { 0 };\n\n\tcmd.drr_update.header.type = DMUB_CMD__FW_ASSISTED_MCLK_SWITCH;\n\tcmd.drr_update.header.sub_type = DMUB_CMD__FAMS_DRR_UPDATE;\n\tcmd.drr_update.dmub_optc_state_req.v_total_max = vtotal_max;\n\tcmd.drr_update.dmub_optc_state_req.v_total_min = vtotal_min;\n\tcmd.drr_update.dmub_optc_state_req.tg_inst = tg_inst;\n\n\tcmd.drr_update.header.payload_bytes = sizeof(cmd.drr_update) - sizeof(cmd.drr_update.header);\n\n\t\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nvoid dc_dmub_srv_set_drr_manual_trigger_cmd(struct dc *dc, uint32_t tg_inst)\n{\n\tunion dmub_rb_cmd cmd = { 0 };\n\n\tcmd.drr_update.header.type = DMUB_CMD__FW_ASSISTED_MCLK_SWITCH;\n\tcmd.drr_update.header.sub_type = DMUB_CMD__FAMS_SET_MANUAL_TRIGGER;\n\tcmd.drr_update.dmub_optc_state_req.tg_inst = tg_inst;\n\n\tcmd.drr_update.header.payload_bytes = sizeof(cmd.drr_update) - sizeof(cmd.drr_update.header);\n\n\t\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic uint8_t dc_dmub_srv_get_pipes_for_stream(struct dc *dc, struct dc_stream_state *stream)\n{\n\tuint8_t pipes = 0;\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream && pipe->stream_res.tg)\n\t\t\tpipes = i;\n\t}\n\treturn pipes;\n}\n\nstatic void dc_dmub_srv_populate_fams_pipe_info(struct dc *dc, struct dc_state *context,\n\t\tstruct pipe_ctx *head_pipe,\n\t\tstruct dmub_cmd_fw_assisted_mclk_switch_pipe_data *fams_pipe_data)\n{\n\tint j;\n\tint pipe_idx = 0;\n\n\tfams_pipe_data->pipe_index[pipe_idx++] = head_pipe->plane_res.hubp->inst;\n\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\tstruct pipe_ctx *split_pipe = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (split_pipe->stream == head_pipe->stream && (split_pipe->top_pipe || split_pipe->prev_odm_pipe)) {\n\t\t\tfams_pipe_data->pipe_index[pipe_idx++] = split_pipe->plane_res.hubp->inst;\n\t\t}\n\t}\n\tfams_pipe_data->pipe_count = pipe_idx;\n}\n\nbool dc_dmub_srv_p_state_delegate(struct dc *dc, bool should_manage_pstate, struct dc_state *context)\n{\n\tunion dmub_rb_cmd cmd = { 0 };\n\tstruct dmub_cmd_fw_assisted_mclk_switch_config *config_data = &cmd.fw_assisted_mclk_switch.config_data;\n\tint i = 0, k = 0;\n\tint ramp_up_num_steps = 1; \n\tuint8_t visual_confirm_enabled;\n\tint pipe_idx = 0;\n\n\tif (dc == NULL)\n\t\treturn false;\n\n\tvisual_confirm_enabled = dc->debug.visual_confirm == VISUAL_CONFIRM_FAMS;\n\n\t\n\tcmd.fw_assisted_mclk_switch.header.type = DMUB_CMD__FW_ASSISTED_MCLK_SWITCH;\n\tcmd.fw_assisted_mclk_switch.header.sub_type = DMUB_CMD__FAMS_SETUP_FW_CTRL;\n\tcmd.fw_assisted_mclk_switch.config_data.fams_enabled = should_manage_pstate;\n\tcmd.fw_assisted_mclk_switch.config_data.visual_confirm_enabled = visual_confirm_enabled;\n\n\tif (should_manage_pstate) {\n\t\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (!pipe->stream)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!pipe->stream->fpo_in_use) {\n\t\t\t\tcmd.fw_assisted_mclk_switch.config_data.vactive_stretch_margin_us = dc->debug.fpo_vactive_margin_us;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_idx++;\n\t\t}\n\t}\n\n\tfor (i = 0, k = 0; context && i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(pipe, OTG_MASTER) && pipe->stream->fpo_in_use) {\n\t\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\t\tuint8_t min_refresh_in_hz = (pipe->stream->timing.min_refresh_in_uhz + 999999) / 1000000;\n\n\t\t\tconfig_data->pipe_data[k].pix_clk_100hz = pipe->stream->timing.pix_clk_100hz;\n\t\t\tconfig_data->pipe_data[k].min_refresh_in_hz = min_refresh_in_hz;\n\t\t\tconfig_data->pipe_data[k].max_ramp_step = ramp_up_num_steps;\n\t\t\tconfig_data->pipe_data[k].pipes = dc_dmub_srv_get_pipes_for_stream(dc, pipe->stream);\n\t\t\tdc_dmub_srv_populate_fams_pipe_info(dc, context, pipe, &config_data->pipe_data[k]);\n\t\t\tk++;\n\t\t}\n\t}\n\tcmd.fw_assisted_mclk_switch.header.payload_bytes =\n\t\tsizeof(cmd.fw_assisted_mclk_switch) - sizeof(cmd.fw_assisted_mclk_switch.header);\n\n\t\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\nvoid dc_dmub_srv_query_caps_cmd(struct dc_dmub_srv *dc_dmub_srv)\n{\n\tunion dmub_rb_cmd cmd = { 0 };\n\n\tif (dc_dmub_srv->ctx->dc->debug.dmcub_emulation)\n\t\treturn;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\t \n\tcmd.query_feature_caps.header.type = DMUB_CMD__QUERY_FEATURE_CAPS;\n\tcmd.query_feature_caps.header.sub_type = 0;\n\tcmd.query_feature_caps.header.ret_status = 1;\n\tcmd.query_feature_caps.header.payload_bytes = sizeof(struct dmub_cmd_query_feature_caps_data);\n\n\t \n\tif (dm_execute_dmub_cmd(dc_dmub_srv->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY) &&\n\t    cmd.query_feature_caps.header.ret_status == 0) {\n\t\tmemcpy(&dc_dmub_srv->dmub->feature_caps,\n\t\t       &cmd.query_feature_caps.query_feature_caps_data,\n\t\t       sizeof(struct dmub_feature_caps));\n\t}\n}\n\nvoid dc_dmub_srv_get_visual_confirm_color_cmd(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tunion dmub_rb_cmd cmd = { 0 };\n\tunsigned int panel_inst = 0;\n\n\tdc_get_edp_link_panel_inst(dc, pipe_ctx->stream->link, &panel_inst);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\t\n\tcmd.visual_confirm_color.header.type = DMUB_CMD__GET_VISUAL_CONFIRM_COLOR;\n\tcmd.visual_confirm_color.header.sub_type = 0;\n\tcmd.visual_confirm_color.header.ret_status = 1;\n\tcmd.visual_confirm_color.header.payload_bytes = sizeof(struct dmub_cmd_visual_confirm_color_data);\n\tcmd.visual_confirm_color.visual_confirm_color_data.visual_confirm_color.panel_inst = panel_inst;\n\n\t\n\tif (dm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT_WITH_REPLY) &&\n\t\tcmd.visual_confirm_color.header.ret_status == 0) {\n\t\tmemcpy(&dc->ctx->dmub_srv->dmub->visual_confirm_color,\n\t\t\t&cmd.visual_confirm_color.visual_confirm_color_data,\n\t\t\tsizeof(struct dmub_visual_confirm_color));\n\t}\n}\n\n \nstatic void populate_subvp_cmd_drr_info(struct dc *dc,\n\t\tstruct pipe_ctx *subvp_pipe,\n\t\tstruct pipe_ctx *vblank_pipe,\n\t\tstruct dmub_cmd_fw_assisted_mclk_switch_pipe_data_v2 *pipe_data)\n{\n\tstruct dc_crtc_timing *main_timing = &subvp_pipe->stream->timing;\n\tstruct dc_crtc_timing *phantom_timing = &subvp_pipe->stream->mall_stream_config.paired_stream->timing;\n\tstruct dc_crtc_timing *drr_timing = &vblank_pipe->stream->timing;\n\tuint16_t drr_frame_us = 0;\n\tuint16_t min_drr_supported_us = 0;\n\tuint16_t max_drr_supported_us = 0;\n\tuint16_t max_drr_vblank_us = 0;\n\tuint16_t max_drr_mallregion_us = 0;\n\tuint16_t mall_region_us = 0;\n\tuint16_t prefetch_us = 0;\n\tuint16_t subvp_active_us = 0;\n\tuint16_t drr_active_us = 0;\n\tuint16_t min_vtotal_supported = 0;\n\tuint16_t max_vtotal_supported = 0;\n\n\tpipe_data->pipe_config.vblank_data.drr_info.drr_in_use = true;\n\tpipe_data->pipe_config.vblank_data.drr_info.use_ramping = false; \n\tpipe_data->pipe_config.vblank_data.drr_info.drr_window_size_ms = 4; \n\n\tdrr_frame_us = div64_u64(((uint64_t)drr_timing->v_total * drr_timing->h_total * 1000000),\n\t\t\t(((uint64_t)drr_timing->pix_clk_100hz * 100)));\n\t\n\tmall_region_us = div64_u64(((uint64_t)phantom_timing->v_addressable * phantom_timing->h_total * 1000000),\n\t\t\t(((uint64_t)phantom_timing->pix_clk_100hz * 100)));\n\tmin_drr_supported_us = drr_frame_us + mall_region_us + SUBVP_DRR_MARGIN_US;\n\tmin_vtotal_supported = div64_u64(((uint64_t)drr_timing->pix_clk_100hz * 100 * min_drr_supported_us),\n\t\t\t(((uint64_t)drr_timing->h_total * 1000000)));\n\n\tprefetch_us = div64_u64(((uint64_t)(phantom_timing->v_total - phantom_timing->v_front_porch) * phantom_timing->h_total * 1000000),\n\t\t\t(((uint64_t)phantom_timing->pix_clk_100hz * 100) + dc->caps.subvp_prefetch_end_to_mall_start_us));\n\tsubvp_active_us = div64_u64(((uint64_t)main_timing->v_addressable * main_timing->h_total * 1000000),\n\t\t\t(((uint64_t)main_timing->pix_clk_100hz * 100)));\n\tdrr_active_us = div64_u64(((uint64_t)drr_timing->v_addressable * drr_timing->h_total * 1000000),\n\t\t\t(((uint64_t)drr_timing->pix_clk_100hz * 100)));\n\tmax_drr_vblank_us = div64_u64((subvp_active_us - prefetch_us -\n\t\t\tdc->caps.subvp_fw_processing_delay_us - drr_active_us), 2) + drr_active_us;\n\tmax_drr_mallregion_us = subvp_active_us - prefetch_us - mall_region_us - dc->caps.subvp_fw_processing_delay_us;\n\tmax_drr_supported_us = max_drr_vblank_us > max_drr_mallregion_us ? max_drr_vblank_us : max_drr_mallregion_us;\n\tmax_vtotal_supported = div64_u64(((uint64_t)drr_timing->pix_clk_100hz * 100 * max_drr_supported_us),\n\t\t\t(((uint64_t)drr_timing->h_total * 1000000)));\n\n\t \n\tmax_vtotal_supported = max_vtotal_supported - dc->caps.subvp_drr_max_vblank_margin_us;\n\n\tpipe_data->pipe_config.vblank_data.drr_info.min_vtotal_supported = min_vtotal_supported;\n\tpipe_data->pipe_config.vblank_data.drr_info.max_vtotal_supported = max_vtotal_supported;\n\tpipe_data->pipe_config.vblank_data.drr_info.drr_vblank_start_margin = dc->caps.subvp_drr_vblank_start_margin_us;\n}\n\n \nstatic void populate_subvp_cmd_vblank_pipe_info(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tunion dmub_rb_cmd *cmd,\n\t\tstruct pipe_ctx *vblank_pipe,\n\t\tuint8_t cmd_pipe_index)\n{\n\tuint32_t i;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct dmub_cmd_fw_assisted_mclk_switch_pipe_data_v2 *pipe_data =\n\t\t\t&cmd->fw_assisted_mclk_switch_v2.config_data.pipe_data[cmd_pipe_index];\n\n\t\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\t\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN)\n\t\t\tbreak;\n\t}\n\n\tpipe_data->mode = VBLANK;\n\tpipe_data->pipe_config.vblank_data.pix_clk_100hz = vblank_pipe->stream->timing.pix_clk_100hz;\n\tpipe_data->pipe_config.vblank_data.vblank_start = vblank_pipe->stream->timing.v_total -\n\t\t\t\t\t\t\tvblank_pipe->stream->timing.v_front_porch;\n\tpipe_data->pipe_config.vblank_data.vtotal = vblank_pipe->stream->timing.v_total;\n\tpipe_data->pipe_config.vblank_data.htotal = vblank_pipe->stream->timing.h_total;\n\tpipe_data->pipe_config.vblank_data.vblank_pipe_index = vblank_pipe->pipe_idx;\n\tpipe_data->pipe_config.vblank_data.vstartup_start = vblank_pipe->pipe_dlg_param.vstartup_start;\n\tpipe_data->pipe_config.vblank_data.vblank_end =\n\t\t\tvblank_pipe->stream->timing.v_total - vblank_pipe->stream->timing.v_front_porch - vblank_pipe->stream->timing.v_addressable;\n\n\tif (vblank_pipe->stream->ignore_msa_timing_param)\n\t\tpopulate_subvp_cmd_drr_info(dc, pipe, vblank_pipe, pipe_data);\n}\n\n \nstatic void update_subvp_prefetch_end_to_mall_start(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tunion dmub_rb_cmd *cmd,\n\t\tstruct pipe_ctx *subvp_pipes[])\n{\n\tuint32_t subvp0_prefetch_us = 0;\n\tuint32_t subvp1_prefetch_us = 0;\n\tuint32_t prefetch_delta_us = 0;\n\tstruct dc_crtc_timing *phantom_timing0 = &subvp_pipes[0]->stream->mall_stream_config.paired_stream->timing;\n\tstruct dc_crtc_timing *phantom_timing1 = &subvp_pipes[1]->stream->mall_stream_config.paired_stream->timing;\n\tstruct dmub_cmd_fw_assisted_mclk_switch_pipe_data_v2 *pipe_data = NULL;\n\n\tsubvp0_prefetch_us = div64_u64(((uint64_t)(phantom_timing0->v_total - phantom_timing0->v_front_porch) *\n\t\t\t(uint64_t)phantom_timing0->h_total * 1000000),\n\t\t\t(((uint64_t)phantom_timing0->pix_clk_100hz * 100) + dc->caps.subvp_prefetch_end_to_mall_start_us));\n\tsubvp1_prefetch_us = div64_u64(((uint64_t)(phantom_timing1->v_total - phantom_timing1->v_front_porch) *\n\t\t\t(uint64_t)phantom_timing1->h_total * 1000000),\n\t\t\t(((uint64_t)phantom_timing1->pix_clk_100hz * 100) + dc->caps.subvp_prefetch_end_to_mall_start_us));\n\n\t \n\t \n\tif (subvp0_prefetch_us > subvp1_prefetch_us) {\n\t\tpipe_data = &cmd->fw_assisted_mclk_switch_v2.config_data.pipe_data[1];\n\t\tprefetch_delta_us = subvp0_prefetch_us - subvp1_prefetch_us;\n\t\tpipe_data->pipe_config.subvp_data.prefetch_to_mall_start_lines =\n\t\t\t\tdiv64_u64(((uint64_t)(dc->caps.subvp_prefetch_end_to_mall_start_us + prefetch_delta_us) *\n\t\t\t\t\t((uint64_t)phantom_timing1->pix_clk_100hz * 100) + ((uint64_t)phantom_timing1->h_total * 1000000 - 1)),\n\t\t\t\t\t((uint64_t)phantom_timing1->h_total * 1000000));\n\n\t} else if (subvp1_prefetch_us >  subvp0_prefetch_us) {\n\t\tpipe_data = &cmd->fw_assisted_mclk_switch_v2.config_data.pipe_data[0];\n\t\tprefetch_delta_us = subvp1_prefetch_us - subvp0_prefetch_us;\n\t\tpipe_data->pipe_config.subvp_data.prefetch_to_mall_start_lines =\n\t\t\t\tdiv64_u64(((uint64_t)(dc->caps.subvp_prefetch_end_to_mall_start_us + prefetch_delta_us) *\n\t\t\t\t\t((uint64_t)phantom_timing0->pix_clk_100hz * 100) + ((uint64_t)phantom_timing0->h_total * 1000000 - 1)),\n\t\t\t\t\t((uint64_t)phantom_timing0->h_total * 1000000));\n\t}\n}\n\n \nstatic void populate_subvp_cmd_pipe_info(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tunion dmub_rb_cmd *cmd,\n\t\tstruct pipe_ctx *subvp_pipe,\n\t\tuint8_t cmd_pipe_index)\n{\n\tuint32_t j;\n\tstruct dmub_cmd_fw_assisted_mclk_switch_pipe_data_v2 *pipe_data =\n\t\t\t&cmd->fw_assisted_mclk_switch_v2.config_data.pipe_data[cmd_pipe_index];\n\tstruct dc_crtc_timing *main_timing = &subvp_pipe->stream->timing;\n\tstruct dc_crtc_timing *phantom_timing = &subvp_pipe->stream->mall_stream_config.paired_stream->timing;\n\tuint32_t out_num_stream, out_den_stream, out_num_plane, out_den_plane, out_num, out_den;\n\n\tpipe_data->mode = SUBVP;\n\tpipe_data->pipe_config.subvp_data.pix_clk_100hz = subvp_pipe->stream->timing.pix_clk_100hz;\n\tpipe_data->pipe_config.subvp_data.htotal = subvp_pipe->stream->timing.h_total;\n\tpipe_data->pipe_config.subvp_data.vtotal = subvp_pipe->stream->timing.v_total;\n\tpipe_data->pipe_config.subvp_data.main_vblank_start =\n\t\t\tmain_timing->v_total - main_timing->v_front_porch;\n\tpipe_data->pipe_config.subvp_data.main_vblank_end =\n\t\t\tmain_timing->v_total - main_timing->v_front_porch - main_timing->v_addressable;\n\tpipe_data->pipe_config.subvp_data.mall_region_lines = phantom_timing->v_addressable;\n\tpipe_data->pipe_config.subvp_data.main_pipe_index = subvp_pipe->stream_res.tg->inst;\n\tpipe_data->pipe_config.subvp_data.is_drr = subvp_pipe->stream->ignore_msa_timing_param;\n\n\t \n\treduce_fraction(subvp_pipe->stream->src.height, subvp_pipe->stream->dst.height,\n\t\t\t&out_num_stream, &out_den_stream);\n\treduce_fraction(subvp_pipe->plane_state->src_rect.height, subvp_pipe->plane_state->dst_rect.height,\n\t\t\t&out_num_plane, &out_den_plane);\n\treduce_fraction(out_num_stream * out_num_plane, out_den_stream * out_den_plane, &out_num, &out_den);\n\tpipe_data->pipe_config.subvp_data.scale_factor_numerator = out_num;\n\tpipe_data->pipe_config.subvp_data.scale_factor_denominator = out_den;\n\n\t\n\tpipe_data->pipe_config.subvp_data.prefetch_lines =\n\t\t\tphantom_timing->v_total - phantom_timing->v_front_porch;\n\n\t\n\tpipe_data->pipe_config.subvp_data.prefetch_to_mall_start_lines =\n\t\t\tdiv64_u64(((uint64_t)dc->caps.subvp_prefetch_end_to_mall_start_us * ((uint64_t)phantom_timing->pix_clk_100hz * 100) +\n\t\t\t\t\t((uint64_t)phantom_timing->h_total * 1000000 - 1)), ((uint64_t)phantom_timing->h_total * 1000000));\n\tpipe_data->pipe_config.subvp_data.processing_delay_lines =\n\t\t\tdiv64_u64(((uint64_t)(dc->caps.subvp_fw_processing_delay_us) * ((uint64_t)phantom_timing->pix_clk_100hz * 100) +\n\t\t\t\t\t((uint64_t)phantom_timing->h_total * 1000000 - 1)), ((uint64_t)phantom_timing->h_total * 1000000));\n\n\tif (subvp_pipe->bottom_pipe) {\n\t\tpipe_data->pipe_config.subvp_data.main_split_pipe_index = subvp_pipe->bottom_pipe->pipe_idx;\n\t} else if (subvp_pipe->next_odm_pipe) {\n\t\tpipe_data->pipe_config.subvp_data.main_split_pipe_index = subvp_pipe->next_odm_pipe->pipe_idx;\n\t} else {\n\t\tpipe_data->pipe_config.subvp_data.main_split_pipe_index = 0;\n\t}\n\n\t\n\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\tstruct pipe_ctx *phantom_pipe = &context->res_ctx.pipe_ctx[j];\n\n\t\tif (phantom_pipe->stream == subvp_pipe->stream->mall_stream_config.paired_stream) {\n\t\t\tpipe_data->pipe_config.subvp_data.phantom_pipe_index = phantom_pipe->stream_res.tg->inst;\n\t\t\tif (phantom_pipe->bottom_pipe) {\n\t\t\t\tpipe_data->pipe_config.subvp_data.phantom_split_pipe_index = phantom_pipe->bottom_pipe->plane_res.hubp->inst;\n\t\t\t} else if (phantom_pipe->next_odm_pipe) {\n\t\t\t\tpipe_data->pipe_config.subvp_data.phantom_split_pipe_index = phantom_pipe->next_odm_pipe->plane_res.hubp->inst;\n\t\t\t} else {\n\t\t\t\tpipe_data->pipe_config.subvp_data.phantom_split_pipe_index = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid dc_dmub_setup_subvp_dmub_command(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tbool enable)\n{\n\tuint8_t cmd_pipe_index = 0;\n\tuint32_t i, pipe_idx;\n\tuint8_t subvp_count = 0;\n\tunion dmub_rb_cmd cmd;\n\tstruct pipe_ctx *subvp_pipes[2];\n\tuint32_t wm_val_refclk = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\t\n\tcmd.fw_assisted_mclk_switch_v2.header.type = DMUB_CMD__FW_ASSISTED_MCLK_SWITCH;\n\tcmd.fw_assisted_mclk_switch_v2.header.sub_type = DMUB_CMD__HANDLE_SUBVP_CMD;\n\tcmd.fw_assisted_mclk_switch_v2.header.payload_bytes =\n\t\t\tsizeof(cmd.fw_assisted_mclk_switch_v2) - sizeof(cmd.fw_assisted_mclk_switch_v2.header);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (resource_is_pipe_type(pipe, OTG_MASTER) &&\n\t\t\t\tresource_is_pipe_type(pipe, DPP_PIPE) &&\n\t\t\t\tpipe->stream->mall_stream_config.type == SUBVP_MAIN)\n\t\t\tsubvp_pipes[subvp_count++] = pipe;\n\t}\n\n\tif (enable) {\n\t\t\n\t\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (!pipe->stream)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (resource_is_pipe_type(pipe, OTG_MASTER) &&\n\t\t\t\t\tresource_is_pipe_type(pipe, DPP_PIPE) &&\n\t\t\t\t\tpipe->stream->mall_stream_config.paired_stream &&\n\t\t\t\t\tpipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t\tpopulate_subvp_cmd_pipe_info(dc, context, &cmd, pipe, cmd_pipe_index++);\n\t\t\t} else if (resource_is_pipe_type(pipe, OTG_MASTER) &&\n\t\t\t\t\tresource_is_pipe_type(pipe, DPP_PIPE) &&\n\t\t\t\t\tpipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpopulate_subvp_cmd_vblank_pipe_info(dc, context, &cmd, pipe, cmd_pipe_index++);\n\n\t\t\t}\n\t\t\tpipe_idx++;\n\t\t}\n\t\tif (subvp_count == 2) {\n\t\t\tupdate_subvp_prefetch_end_to_mall_start(dc, context, &cmd, subvp_pipes);\n\t\t}\n\t\tcmd.fw_assisted_mclk_switch_v2.config_data.pstate_allow_width_us = dc->caps.subvp_pstate_allow_width_us;\n\t\tcmd.fw_assisted_mclk_switch_v2.config_data.vertical_int_margin_us = dc->caps.subvp_vertical_int_margin_us;\n\n\t\t\n\t\t\n\t\twm_val_refclk = context->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns *\n\t\t\t\t(dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000) / 1000;\n\n\t\tcmd.fw_assisted_mclk_switch_v2.config_data.watermark_a_cache = wm_val_refclk < 0xFFFF ? wm_val_refclk : 0xFFFF;\n\t}\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nbool dc_dmub_srv_get_diagnostic_data(struct dc_dmub_srv *dc_dmub_srv, struct dmub_diagnostic_data *diag_data)\n{\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub || !diag_data)\n\t\treturn false;\n\treturn dmub_srv_get_diagnostic_data(dc_dmub_srv->dmub, diag_data);\n}\n\nvoid dc_dmub_srv_log_diagnostic_data(struct dc_dmub_srv *dc_dmub_srv)\n{\n\tstruct dmub_diagnostic_data diag_data = {0};\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub) {\n\t\tDC_LOG_ERROR(\"%s: invalid parameters.\", __func__);\n\t\treturn;\n\t}\n\n\tif (!dc_dmub_srv_get_diagnostic_data(dc_dmub_srv, &diag_data)) {\n\t\tDC_LOG_ERROR(\"%s: dc_dmub_srv_get_diagnostic_data failed.\", __func__);\n\t\treturn;\n\t}\n\n\tDC_LOG_DEBUG(\"DMCUB STATE:\");\n\tDC_LOG_DEBUG(\"    dmcub_version      : %08x\", diag_data.dmcub_version);\n\tDC_LOG_DEBUG(\"    scratch  [0]       : %08x\", diag_data.scratch[0]);\n\tDC_LOG_DEBUG(\"    scratch  [1]       : %08x\", diag_data.scratch[1]);\n\tDC_LOG_DEBUG(\"    scratch  [2]       : %08x\", diag_data.scratch[2]);\n\tDC_LOG_DEBUG(\"    scratch  [3]       : %08x\", diag_data.scratch[3]);\n\tDC_LOG_DEBUG(\"    scratch  [4]       : %08x\", diag_data.scratch[4]);\n\tDC_LOG_DEBUG(\"    scratch  [5]       : %08x\", diag_data.scratch[5]);\n\tDC_LOG_DEBUG(\"    scratch  [6]       : %08x\", diag_data.scratch[6]);\n\tDC_LOG_DEBUG(\"    scratch  [7]       : %08x\", diag_data.scratch[7]);\n\tDC_LOG_DEBUG(\"    scratch  [8]       : %08x\", diag_data.scratch[8]);\n\tDC_LOG_DEBUG(\"    scratch  [9]       : %08x\", diag_data.scratch[9]);\n\tDC_LOG_DEBUG(\"    scratch [10]       : %08x\", diag_data.scratch[10]);\n\tDC_LOG_DEBUG(\"    scratch [11]       : %08x\", diag_data.scratch[11]);\n\tDC_LOG_DEBUG(\"    scratch [12]       : %08x\", diag_data.scratch[12]);\n\tDC_LOG_DEBUG(\"    scratch [13]       : %08x\", diag_data.scratch[13]);\n\tDC_LOG_DEBUG(\"    scratch [14]       : %08x\", diag_data.scratch[14]);\n\tDC_LOG_DEBUG(\"    scratch [15]       : %08x\", diag_data.scratch[15]);\n\tDC_LOG_DEBUG(\"    pc                 : %08x\", diag_data.pc);\n\tDC_LOG_DEBUG(\"    unk_fault_addr     : %08x\", diag_data.undefined_address_fault_addr);\n\tDC_LOG_DEBUG(\"    inst_fault_addr    : %08x\", diag_data.inst_fetch_fault_addr);\n\tDC_LOG_DEBUG(\"    data_fault_addr    : %08x\", diag_data.data_write_fault_addr);\n\tDC_LOG_DEBUG(\"    inbox1_rptr        : %08x\", diag_data.inbox1_rptr);\n\tDC_LOG_DEBUG(\"    inbox1_wptr        : %08x\", diag_data.inbox1_wptr);\n\tDC_LOG_DEBUG(\"    inbox1_size        : %08x\", diag_data.inbox1_size);\n\tDC_LOG_DEBUG(\"    inbox0_rptr        : %08x\", diag_data.inbox0_rptr);\n\tDC_LOG_DEBUG(\"    inbox0_wptr        : %08x\", diag_data.inbox0_wptr);\n\tDC_LOG_DEBUG(\"    inbox0_size        : %08x\", diag_data.inbox0_size);\n\tDC_LOG_DEBUG(\"    is_enabled         : %d\", diag_data.is_dmcub_enabled);\n\tDC_LOG_DEBUG(\"    is_soft_reset      : %d\", diag_data.is_dmcub_soft_reset);\n\tDC_LOG_DEBUG(\"    is_secure_reset    : %d\", diag_data.is_dmcub_secure_reset);\n\tDC_LOG_DEBUG(\"    is_traceport_en    : %d\", diag_data.is_traceport_en);\n\tDC_LOG_DEBUG(\"    is_cw0_en          : %d\", diag_data.is_cw0_enabled);\n\tDC_LOG_DEBUG(\"    is_cw6_en          : %d\", diag_data.is_cw6_enabled);\n}\n\nstatic bool dc_can_pipe_disable_cursor(struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *test_pipe, *split_pipe;\n\tconst struct scaler_data *scl_data = &pipe_ctx->plane_res.scl_data;\n\tstruct rect r1 = scl_data->recout, r2, r2_half;\n\tint r1_r = r1.x + r1.width, r1_b = r1.y + r1.height, r2_r, r2_b;\n\tint cur_layer = pipe_ctx->plane_state->layer_index;\n\n\t \n\tfor (test_pipe = pipe_ctx->top_pipe; test_pipe;\n\t     test_pipe = test_pipe->top_pipe) {\n\t\t\n\t\tif (!test_pipe->plane_state->visible || test_pipe->plane_state->layer_index == cur_layer)\n\t\t\tcontinue;\n\n\t\tr2 = test_pipe->plane_res.scl_data.recout;\n\t\tr2_r = r2.x + r2.width;\n\t\tr2_b = r2.y + r2.height;\n\t\tsplit_pipe = test_pipe;\n\n\t\t \n\t\tfor (split_pipe = pipe_ctx->top_pipe; split_pipe;\n\t\t     split_pipe = split_pipe->top_pipe)\n\t\t\tif (split_pipe->plane_state->layer_index == test_pipe->plane_state->layer_index) {\n\t\t\t\tr2_half = split_pipe->plane_res.scl_data.recout;\n\t\t\t\tr2.x = (r2_half.x < r2.x) ? r2_half.x : r2.x;\n\t\t\t\tr2.width = r2.width + r2_half.width;\n\t\t\t\tr2_r = r2.x + r2.width;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (r1.x >= r2.x && r1.y >= r2.y && r1_r <= r2_r && r1_b <= r2_b)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool dc_dmub_should_update_cursor_data(struct pipe_ctx *pipe_ctx)\n{\n\tif (pipe_ctx->plane_state != NULL) {\n\t\tif (pipe_ctx->plane_state->address.type == PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)\n\t\t\treturn false;\n\n\t\tif (dc_can_pipe_disable_cursor(pipe_ctx))\n\t\t\treturn false;\n\t}\n\n\tif ((pipe_ctx->stream->link->psr_settings.psr_version == DC_PSR_VERSION_SU_1 ||\n\t\tpipe_ctx->stream->link->psr_settings.psr_version == DC_PSR_VERSION_1) &&\n\t\tpipe_ctx->stream->ctx->dce_version >= DCN_VERSION_3_1)\n\t\treturn true;\n\n\tif (pipe_ctx->stream->link->replay_settings.config.replay_supported)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void dc_build_cursor_update_payload0(\n\t\tstruct pipe_ctx *pipe_ctx, uint8_t p_idx,\n\t\tstruct dmub_cmd_update_cursor_payload0 *payload)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tunsigned int panel_inst = 0;\n\n\tif (!dc_get_edp_link_panel_inst(hubp->ctx->dc,\n\t\tpipe_ctx->stream->link, &panel_inst))\n\t\treturn;\n\n\t \n\tpayload->cursor_rect.x = hubp->cur_rect.x;\n\tpayload->cursor_rect.y = hubp->cur_rect.y;\n\t \n\tpayload->cursor_rect.width  = hubp->cur_rect.w;\n\tpayload->cursor_rect.height = hubp->cur_rect.h;\n\n\tpayload->enable      = hubp->pos.cur_ctl.bits.cur_enable;\n\tpayload->pipe_idx    = p_idx;\n\tpayload->cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tpayload->panel_inst  = panel_inst;\n}\n\nstatic void dc_build_cursor_position_update_payload0(\n\t\tstruct dmub_cmd_update_cursor_payload0 *pl, const uint8_t p_idx,\n\t\tconst struct hubp *hubp, const struct dpp *dpp)\n{\n\t \n\tpl->position_cfg.pHubp.cur_ctl.raw  = hubp->pos.cur_ctl.raw;\n\tpl->position_cfg.pHubp.position.raw = hubp->pos.position.raw;\n\tpl->position_cfg.pHubp.hot_spot.raw = hubp->pos.hot_spot.raw;\n\tpl->position_cfg.pHubp.dst_offset.raw = hubp->pos.dst_offset.raw;\n\n\t \n\tpl->position_cfg.pDpp.cur0_ctl.raw = dpp->pos.cur0_ctl.raw;\n\tpl->position_cfg.pipe_idx = p_idx;\n}\n\nstatic void dc_build_cursor_attribute_update_payload1(\n\t\tstruct dmub_cursor_attributes_cfg *pl_A, const uint8_t p_idx,\n\t\tconst struct hubp *hubp, const struct dpp *dpp)\n{\n\t \n\tpl_A->aHubp.SURFACE_ADDR_HIGH = hubp->att.SURFACE_ADDR_HIGH;\n\tpl_A->aHubp.SURFACE_ADDR = hubp->att.SURFACE_ADDR;\n\tpl_A->aHubp.cur_ctl.raw  = hubp->att.cur_ctl.raw;\n\tpl_A->aHubp.size.raw     = hubp->att.size.raw;\n\tpl_A->aHubp.settings.raw = hubp->att.settings.raw;\n\n\t \n\tpl_A->aDpp.cur0_ctl.raw = dpp->att.cur0_ctl.raw;\n}\n\n \nvoid dc_send_update_cursor_info_to_dmu(\n\t\tstruct pipe_ctx *pCtx, uint8_t pipe_idx)\n{\n\tunion dmub_rb_cmd cmd[2];\n\tunion dmub_cmd_update_cursor_info_data *update_cursor_info_0 =\n\t\t\t\t\t&cmd[0].update_cursor_info.update_cursor_info_data;\n\n\tmemset(cmd, 0, sizeof(cmd));\n\n\tif (!dc_dmub_should_update_cursor_data(pCtx))\n\t\treturn;\n\t \n\n\t{\n\t\t \n\t\tcmd[0].update_cursor_info.header.type = DMUB_CMD__UPDATE_CURSOR_INFO;\n\t\tcmd[0].update_cursor_info.header.payload_bytes =\n\t\t\t\tsizeof(cmd[0].update_cursor_info.update_cursor_info_data);\n\t\tcmd[0].update_cursor_info.header.multi_cmd_pending = 1;  \n\n\t\t \n\t\tdc_build_cursor_update_payload0(pCtx, pipe_idx, &update_cursor_info_0->payload0);\n\n\t\tdc_build_cursor_position_update_payload0(&update_cursor_info_0->payload0, pipe_idx,\n\t\t\t\tpCtx->plane_res.hubp, pCtx->plane_res.dpp);\n\t\t}\n\t{\n\t\t \n\t\tcmd[1].update_cursor_info.header.type = DMUB_CMD__UPDATE_CURSOR_INFO;\n\t\tcmd[1].update_cursor_info.header.payload_bytes = sizeof(struct cursor_attributes_cfg);\n\t\tcmd[1].update_cursor_info.header.multi_cmd_pending = 0;  \n\n\t\tdc_build_cursor_attribute_update_payload1(\n\t\t\t\t&cmd[1].update_cursor_info.update_cursor_info_data.payload1.attribute_cfg,\n\t\t\t\tpipe_idx, pCtx->plane_res.hubp, pCtx->plane_res.dpp);\n\n\t\t \n\t\tdm_execute_dmub_cmd_list(pCtx->stream->ctx, 2, cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\t}\n}\n\nbool dc_dmub_check_min_version(struct dmub_srv *srv)\n{\n\tif (!srv->hw_funcs.is_psrsu_supported)\n\t\treturn true;\n\treturn srv->hw_funcs.is_psrsu_supported(srv);\n}\n\nvoid dc_dmub_srv_enable_dpia_trace(const struct dc *dc)\n{\n\tstruct dc_dmub_srv *dc_dmub_srv = dc->ctx->dmub_srv;\n\tstruct dmub_srv *dmub;\n\tenum dmub_status status;\n\tstatic const uint32_t timeout_us = 30;\n\n\tif (!dc_dmub_srv || !dc_dmub_srv->dmub) {\n\t\tDC_LOG_ERROR(\"%s: invalid parameters.\", __func__);\n\t\treturn;\n\t}\n\n\tdmub = dc_dmub_srv->dmub;\n\n\tstatus = dmub_srv_send_gpint_command(dmub, DMUB_GPINT__SET_TRACE_BUFFER_MASK_WORD1, 0x0010, timeout_us);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_LOG_ERROR(\"timeout updating trace buffer mask word\\n\");\n\t\treturn;\n\t}\n\n\tstatus = dmub_srv_send_gpint_command(dmub, DMUB_GPINT__UPDATE_TRACE_BUFFER_MASK, 0x0000, timeout_us);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDC_LOG_ERROR(\"timeout updating trace buffer mask word\\n\");\n\t\treturn;\n\t}\n\n\tDC_LOG_DEBUG(\"Enabled DPIA trace\\n\");\n}",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}