{
  "module_name": "custom_float.c",
  "hash_id": "79298f2b2d6d7a1cd544285fc386b4b01373c5f5f4ed7a5443eb0be79fad8b88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/calcs/custom_float.c",
  "human_readable_source": " \n#include \"dm_services.h\"\n#include \"custom_float.h\"\n\n\nstatic bool build_custom_float(\n\tstruct fixed31_32 value,\n\tconst struct custom_float_format *format,\n\tbool *negative,\n\tuint32_t *mantissa,\n\tuint32_t *exponenta)\n{\n\tuint32_t exp_offset = (1 << (format->exponenta_bits - 1)) - 1;\n\n\tconst struct fixed31_32 mantissa_constant_plus_max_fraction =\n\t\tdc_fixpt_from_fraction(\n\t\t\t(1LL << (format->mantissa_bits + 1)) - 1,\n\t\t\t1LL << format->mantissa_bits);\n\n\tstruct fixed31_32 mantiss;\n\n\tif (dc_fixpt_eq(\n\t\tvalue,\n\t\tdc_fixpt_zero)) {\n\t\t*negative = false;\n\t\t*mantissa = 0;\n\t\t*exponenta = 0;\n\t\treturn true;\n\t}\n\n\tif (dc_fixpt_lt(\n\t\tvalue,\n\t\tdc_fixpt_zero)) {\n\t\t*negative = format->sign;\n\t\tvalue = dc_fixpt_neg(value);\n\t} else {\n\t\t*negative = false;\n\t}\n\n\tif (dc_fixpt_lt(\n\t\tvalue,\n\t\tdc_fixpt_one)) {\n\t\tuint32_t i = 1;\n\n\t\tdo {\n\t\t\tvalue = dc_fixpt_shl(value, 1);\n\t\t\t++i;\n\t\t} while (dc_fixpt_lt(\n\t\t\tvalue,\n\t\t\tdc_fixpt_one));\n\n\t\t--i;\n\n\t\tif (exp_offset <= i) {\n\t\t\t*mantissa = 0;\n\t\t\t*exponenta = 0;\n\t\t\treturn true;\n\t\t}\n\n\t\t*exponenta = exp_offset - i;\n\t} else if (dc_fixpt_le(\n\t\tmantissa_constant_plus_max_fraction,\n\t\tvalue)) {\n\t\tuint32_t i = 1;\n\n\t\tdo {\n\t\t\tvalue = dc_fixpt_shr(value, 1);\n\t\t\t++i;\n\t\t} while (dc_fixpt_lt(\n\t\t\tmantissa_constant_plus_max_fraction,\n\t\t\tvalue));\n\n\t\t*exponenta = exp_offset + i - 1;\n\t} else {\n\t\t*exponenta = exp_offset;\n\t}\n\n\tmantiss = dc_fixpt_sub(\n\t\tvalue,\n\t\tdc_fixpt_one);\n\n\tif (dc_fixpt_lt(\n\t\t\tmantiss,\n\t\t\tdc_fixpt_zero) ||\n\t\tdc_fixpt_lt(\n\t\t\tdc_fixpt_one,\n\t\t\tmantiss))\n\t\tmantiss = dc_fixpt_zero;\n\telse\n\t\tmantiss = dc_fixpt_shl(\n\t\t\tmantiss,\n\t\t\tformat->mantissa_bits);\n\n\t*mantissa = dc_fixpt_floor(mantiss);\n\n\treturn true;\n}\n\nstatic bool setup_custom_float(\n\tconst struct custom_float_format *format,\n\tbool negative,\n\tuint32_t mantissa,\n\tuint32_t exponenta,\n\tuint32_t *result)\n{\n\tuint32_t i = 0;\n\tuint32_t j = 0;\n\n\tuint32_t value = 0;\n\n\t \n\n\tconst uint32_t mantissa_mask =\n\t\t(1 << (format->mantissa_bits + 1)) - 1;\n\n\tconst uint32_t exponenta_mask =\n\t\t(1 << (format->exponenta_bits + 1)) - 1;\n\n\tif (mantissa & ~mantissa_mask) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tmantissa = mantissa_mask;\n\t}\n\n\tif (exponenta & ~exponenta_mask) {\n\t\tBREAK_TO_DEBUGGER();\n\t\texponenta = exponenta_mask;\n\t}\n\n\t \n\n\twhile (i < format->mantissa_bits) {\n\t\tuint32_t mask = 1 << i;\n\n\t\tif (mantissa & mask)\n\t\t\tvalue |= mask;\n\n\t\t++i;\n\t}\n\n\twhile (j < format->exponenta_bits) {\n\t\tuint32_t mask = 1 << j;\n\n\t\tif (exponenta & mask)\n\t\t\tvalue |= mask << i;\n\n\t\t++j;\n\t}\n\n\tif (negative && format->sign)\n\t\tvalue |= 1 << (i + j);\n\n\t*result = value;\n\n\treturn true;\n}\n\nbool convert_to_custom_float_format(\n\tstruct fixed31_32 value,\n\tconst struct custom_float_format *format,\n\tuint32_t *result)\n{\n\tuint32_t mantissa;\n\tuint32_t exponenta;\n\tbool negative;\n\n\treturn build_custom_float(\n\t\tvalue, format, &negative, &mantissa, &exponenta) &&\n\tsetup_custom_float(\n\t\tformat, negative, mantissa, exponenta, result);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}