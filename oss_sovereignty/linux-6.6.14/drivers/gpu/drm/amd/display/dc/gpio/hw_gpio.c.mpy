{
  "module_name": "hw_gpio.c",
  "hash_id": "90b81b978cd546f627397404c1d63d85be9df48c12a485349bce99a03a9321fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"include/gpio_types.h\"\n#include \"hw_gpio.h\"\n\n#include \"reg_helper.h\"\n#include \"gpio_regs.h\"\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tgpio->regs->field_name ## _shift, gpio->regs->field_name ## _mask\n\n#define CTX \\\n\tgpio->base.ctx\n#define REG(reg)\\\n\t(gpio->regs->reg)\n\nstatic void store_registers(\n\tstruct hw_gpio *gpio)\n{\n\tREG_GET(MASK_reg, MASK, &gpio->store.mask);\n\tREG_GET(A_reg, A, &gpio->store.a);\n\tREG_GET(EN_reg, EN, &gpio->store.en);\n\t \n}\n\nstatic void restore_registers(\n\tstruct hw_gpio *gpio)\n{\n\tREG_UPDATE(MASK_reg, MASK, gpio->store.mask);\n\tREG_UPDATE(A_reg, A, gpio->store.a);\n\tREG_UPDATE(EN_reg, EN, gpio->store.en);\n\t \n}\n\nbool dal_hw_gpio_open(\n\tstruct hw_gpio_pin *ptr,\n\tenum gpio_mode mode)\n{\n\tstruct hw_gpio *pin = FROM_HW_GPIO_PIN(ptr);\n\n\tstore_registers(pin);\n\n\tptr->opened = (dal_hw_gpio_config_mode(pin, mode) == GPIO_RESULT_OK);\n\n\treturn ptr->opened;\n}\n\nenum gpio_result dal_hw_gpio_get_value(\n\tconst struct hw_gpio_pin *ptr,\n\tuint32_t *value)\n{\n\tconst struct hw_gpio *gpio = FROM_HW_GPIO_PIN(ptr);\n\n\tenum gpio_result result = GPIO_RESULT_OK;\n\n\tswitch (ptr->mode) {\n\tcase GPIO_MODE_INPUT:\n\tcase GPIO_MODE_OUTPUT:\n\tcase GPIO_MODE_HARDWARE:\n\tcase GPIO_MODE_FAST_OUTPUT:\n\t\tREG_GET(Y_reg, Y, value);\n\t\tbreak;\n\tdefault:\n\t\tresult = GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n\n\treturn result;\n}\n\nenum gpio_result dal_hw_gpio_set_value(\n\tconst struct hw_gpio_pin *ptr,\n\tuint32_t value)\n{\n\tstruct hw_gpio *gpio = FROM_HW_GPIO_PIN(ptr);\n\n\t \n\n\tswitch (ptr->mode) {\n\tcase GPIO_MODE_OUTPUT:\n\t\tREG_UPDATE(A_reg, A, value);\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_MODE_FAST_OUTPUT:\n\t\t \n\t\tREG_UPDATE(EN_reg, EN, ~value);\n\t\treturn GPIO_RESULT_OK;\n\tdefault:\n\t\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n}\n\nenum gpio_result dal_hw_gpio_change_mode(\n\tstruct hw_gpio_pin *ptr,\n\tenum gpio_mode mode)\n{\n\tstruct hw_gpio *pin = FROM_HW_GPIO_PIN(ptr);\n\n\treturn dal_hw_gpio_config_mode(pin, mode);\n}\n\nvoid dal_hw_gpio_close(\n\tstruct hw_gpio_pin *ptr)\n{\n\tstruct hw_gpio *pin = FROM_HW_GPIO_PIN(ptr);\n\n\trestore_registers(pin);\n\n\tptr->mode = GPIO_MODE_UNKNOWN;\n\tptr->opened = false;\n}\n\nenum gpio_result dal_hw_gpio_config_mode(\n\tstruct hw_gpio *gpio,\n\tenum gpio_mode mode)\n{\n\tgpio->base.mode = mode;\n\n\tswitch (mode) {\n\tcase GPIO_MODE_INPUT:\n\t\t \n\t\tREG_UPDATE(EN_reg, EN, 0);\n\t\tREG_UPDATE(MASK_reg, MASK, 1);\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_MODE_OUTPUT:\n\t\t \n\t\tREG_UPDATE(A_reg, A, 0);\n\t\tREG_UPDATE(MASK_reg, MASK, 1);\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_MODE_FAST_OUTPUT:\n\t\t \n\t\tREG_UPDATE(A_reg, A, 0);\n\t\tREG_UPDATE(MASK_reg, MASK, 1);\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_MODE_HARDWARE:\n\t\t \n\t\tREG_UPDATE(MASK_reg, MASK, 0);\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_MODE_INTERRUPT:\n\t\t \n\t\tREG_UPDATE(MASK_reg, MASK, 0);\n\t\treturn GPIO_RESULT_OK;\n\tdefault:\n\t\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n\t}\n}\n\nvoid dal_hw_gpio_construct(\n\tstruct hw_gpio *pin,\n\tenum gpio_id id,\n\tuint32_t en,\n\tstruct dc_context *ctx)\n{\n\tpin->base.ctx = ctx;\n\tpin->base.id = id;\n\tpin->base.en = en;\n\tpin->base.mode = GPIO_MODE_UNKNOWN;\n\tpin->base.opened = false;\n\n\tpin->store.mask = 0;\n\tpin->store.a = 0;\n\tpin->store.en = 0;\n\tpin->store.mux = 0;\n\n\tpin->mux_supported = false;\n}\n\nvoid dal_hw_gpio_destruct(\n\tstruct hw_gpio *pin)\n{\n\tASSERT(!pin->base.opened);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}