{
  "module_name": "dce110_timing_generator.h",
  "hash_id": "76631ab74df69ba2be33e3c594714a53eb255dc113e6034ffc6f1f526d9ae992",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.h",
  "human_readable_source": " \n\n#ifndef __DC_TIMING_GENERATOR_DCE110_H__\n#define __DC_TIMING_GENERATOR_DCE110_H__\n\n#include \"timing_generator.h\"\n#include \"../include/grph_object_id.h\"\n\n \n\n \n#define VFLIP_READY_DELAY 4\n \n#define HFLIP_READY_DELAY 2\n \n#define HFLIP_CHECK_DELAY 6\n \n#define FLIP_READY_BACK_LOOKUP 3\n\n \nenum trigger_source_select {\n\tTRIGGER_SOURCE_SELECT_LOGIC_ZERO = 0,\n\tTRIGGER_SOURCE_SELECT_CRTC_VSYNCA = 1,\n\tTRIGGER_SOURCE_SELECT_CRTC_HSYNCA = 2,\n\tTRIGGER_SOURCE_SELECT_CRTC_VSYNCB = 3,\n\tTRIGGER_SOURCE_SELECT_CRTC_HSYNCB = 4,\n\tTRIGGER_SOURCE_SELECT_GENERICF = 5,\n\tTRIGGER_SOURCE_SELECT_GENERICE = 6,\n\tTRIGGER_SOURCE_SELECT_VSYNCA = 7,\n\tTRIGGER_SOURCE_SELECT_HSYNCA = 8,\n\tTRIGGER_SOURCE_SELECT_VSYNCB = 9,\n\tTRIGGER_SOURCE_SELECT_HSYNCB = 10,\n\tTRIGGER_SOURCE_SELECT_HPD1 = 11,\n\tTRIGGER_SOURCE_SELECT_HPD2 = 12,\n\tTRIGGER_SOURCE_SELECT_GENERICD = 13,\n\tTRIGGER_SOURCE_SELECT_GENERICC = 14,\n\tTRIGGER_SOURCE_SELECT_VIDEO_CAPTURE = 15,\n\tTRIGGER_SOURCE_SELECT_GSL_GROUP0 = 16,\n\tTRIGGER_SOURCE_SELECT_GSL_GROUP1 = 17,\n\tTRIGGER_SOURCE_SELECT_GSL_GROUP2 = 18,\n\tTRIGGER_SOURCE_SELECT_BLONY = 19,\n\tTRIGGER_SOURCE_SELECT_GENERICA = 20,\n\tTRIGGER_SOURCE_SELECT_GENERICB = 21,\n\tTRIGGER_SOURCE_SELECT_GSL_ALLOW_FLIP = 22,\n\tTRIGGER_SOURCE_SELECT_MANUAL_TRIGGER = 23\n};\n\n \nenum trigger_polarity_select {\n\tTRIGGER_POLARITY_SELECT_LOGIC_ZERO = 0,\n\tTRIGGER_POLARITY_SELECT_CRTC = 1,\n\tTRIGGER_POLARITY_SELECT_GENERICA = 2,\n\tTRIGGER_POLARITY_SELECT_GENERICB = 3,\n\tTRIGGER_POLARITY_SELECT_HSYNCA = 4,\n\tTRIGGER_POLARITY_SELECT_HSYNCB = 5,\n\tTRIGGER_POLARITY_SELECT_VIDEO_CAPTURE = 6,\n\tTRIGGER_POLARITY_SELECT_GENERICC = 7\n};\n\n\nstruct dce110_timing_generator_offsets {\n\tint32_t crtc;\n\tint32_t dcp;\n\n\t \n\tint32_t dmif;\n};\n\nstruct dce110_timing_generator {\n\tstruct timing_generator base;\n\tstruct dce110_timing_generator_offsets offsets;\n\tstruct dce110_timing_generator_offsets derived_offsets;\n\n\tenum controller_id controller_id;\n\n\tuint32_t max_h_total;\n\tuint32_t max_v_total;\n\n\tuint32_t min_h_blank;\n\tuint32_t min_h_front_porch;\n\tuint32_t min_h_back_porch;\n\n\t \n\tuint32_t min_h_sync_width;\n\tuint32_t min_v_sync_width;\n\tuint32_t min_v_blank;\n\n};\n\n#define DCE110TG_FROM_TG(tg)\\\n\tcontainer_of(tg, struct dce110_timing_generator, base)\n\nvoid dce110_timing_generator_construct(\n\tstruct dce110_timing_generator *tg,\n\tstruct dc_context *ctx,\n\tuint32_t instance,\n\tconst struct dce110_timing_generator_offsets *offsets);\n\n \nbool dce110_timing_generator_validate_timing(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tenum signal_type signal);\n\n \n\n \nbool dce110_timing_generator_program_timing_generator(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *dc_crtc_timing);\n\n \nbool dce110_timing_generator_enable_crtc(struct timing_generator *tg);\nbool dce110_timing_generator_disable_crtc(struct timing_generator *tg);\n\nvoid dce110_timing_generator_set_early_control(\n\t\tstruct timing_generator *tg,\n\t\tuint32_t early_cntl);\n\n \n\n \nuint32_t dce110_timing_generator_get_vblank_counter(\n\t\tstruct timing_generator *tg);\n\nvoid dce110_timing_generator_get_position(\n\tstruct timing_generator *tg,\n\tstruct crtc_position *position);\n\n \nbool dce110_timing_generator_is_counter_moving(struct timing_generator *tg);\n\n \nvoid dce110_timing_generator_wait_for_vblank(struct timing_generator *tg);\n\n \nvoid dce110_timing_generator_wait_for_vactive(struct timing_generator *tg);\n\n \n\n \nvoid dce110_timing_generator_setup_global_swap_lock(\n\tstruct timing_generator *tg,\n\tconst struct dcp_gsl_params *gsl_params);\n\n \nvoid dce110_timing_generator_tear_down_global_swap_lock(\n\tstruct timing_generator *tg);\n\n \nvoid dce110_timing_generator_enable_crtc_reset(\n\tstruct timing_generator *tg,\n\tint source,\n\tstruct crtc_trigger_info *crtc_tp);\n\n \nvoid dce110_timing_generator_enable_reset_trigger(\n\tstruct timing_generator *tg,\n\tint source);\n\n \nvoid dce110_timing_generator_disable_reset_trigger(\n\tstruct timing_generator *tg);\n\n \nbool dce110_timing_generator_did_triggered_reset_occur(\n\tstruct timing_generator *tg);\n\n \n \nvoid dce110_timing_generator_disable_vga(struct timing_generator *tg);\n \n \nvoid dce110_timing_generator_program_blanking(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing);\n\n \n \nvoid dce110_timing_generator_program_blank_color(\n\tstruct timing_generator *tg,\n\tconst struct tg_color *black_color);\n \nvoid dce110_timing_generator_set_overscan_color_black(\n\tstruct timing_generator *tg,\n\tconst struct tg_color *color);\nvoid dce110_timing_generator_color_space_to_black_color(\n\t\tenum dc_color_space colorspace,\n\tstruct tg_color *black_color);\n \n\n \nvoid dce110_timing_generator_set_test_pattern(\n\tstruct timing_generator *tg,\n\t \n\tenum controller_dp_test_pattern test_pattern,\n\tenum dc_color_depth color_depth);\n\nvoid dce110_timing_generator_set_drr(\n\tstruct timing_generator *tg,\n\tconst struct drr_params *params);\n\nvoid dce110_timing_generator_set_static_screen_control(\n\tstruct timing_generator *tg,\n\tuint32_t event_triggers,\n\tuint32_t num_frames);\n\nvoid dce110_timing_generator_get_crtc_scanoutpos(\n\tstruct timing_generator *tg,\n\tuint32_t *v_blank_start,\n\tuint32_t *v_blank_end,\n\tuint32_t *h_position,\n\tuint32_t *v_position);\n\nvoid dce110_timing_generator_enable_advanced_request(\n\tstruct timing_generator *tg,\n\tbool enable,\n\tconst struct dc_crtc_timing *timing);\n\nvoid dce110_timing_generator_set_lock_master(struct timing_generator *tg,\n\t\tbool lock);\n\nvoid dce110_tg_program_blank_color(struct timing_generator *tg,\n\tconst struct tg_color *black_color);\n\nvoid dce110_tg_set_overscan_color(struct timing_generator *tg,\n\tconst struct tg_color *overscan_color);\n\nvoid dce110_tg_program_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tint vready_offset,\n\tint vstartup_start,\n\tint vupdate_offset,\n\tint vupdate_width,\n\tconst enum signal_type signal,\n\tbool use_vbios);\n\nbool dce110_tg_is_blanked(struct timing_generator *tg);\n\nvoid dce110_tg_set_blank(struct timing_generator *tg,\n\t\tbool enable_blanking);\n\nbool dce110_tg_validate_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing);\n\nvoid dce110_tg_wait_for_state(struct timing_generator *tg,\n\tenum crtc_state state);\n\nvoid dce110_tg_set_colors(struct timing_generator *tg,\n\tconst struct tg_color *blank_color,\n\tconst struct tg_color *overscan_color);\n\nbool dce110_arm_vert_intr(\n\t\tstruct timing_generator *tg, uint8_t width);\n\nbool dce110_configure_crc(struct timing_generator *tg,\n\t\t\t  const struct crc_params *params);\n\nbool dce110_get_crc(struct timing_generator *tg,\n\t\t    uint32_t *r_cr, uint32_t *g_y, uint32_t *b_cb);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}