{
  "module_name": "bios_parser.c",
  "hash_id": "ddd09e75b5ea0e9f02d6ef8913ce4de9a1ef8b1f415651e093577ec4266cba6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"atom.h\"\n\n#include \"dc_bios_types.h\"\n#include \"include/gpio_service_interface.h\"\n#include \"include/grph_object_ctrl_defs.h\"\n#include \"include/bios_parser_interface.h\"\n#include \"include/logger_interface.h\"\n\n#include \"command_table.h\"\n#include \"bios_parser_helper.h\"\n#include \"command_table_helper.h\"\n#include \"bios_parser.h\"\n#include \"bios_parser_types_internal.h\"\n#include \"bios_parser_interface.h\"\n\n#include \"bios_parser_common.h\"\n\n#include \"dc.h\"\n\n#define THREE_PERCENT_OF_10000 300\n\n#define LAST_RECORD_TYPE 0xff\n\n#define DC_LOGGER \\\n\tbp->base.ctx->logger\n\n#define DATA_TABLES(table) (bp->master_data_tbl->ListOfDataTables.table)\n\nstatic void get_atom_data_table_revision(\n\tATOM_COMMON_TABLE_HEADER *atom_data_tbl,\n\tstruct atom_data_revision *tbl_revision);\nstatic uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,\n\tuint16_t **id_list);\nstatic ATOM_OBJECT *get_bios_object(struct bios_parser *bp,\n\tstruct graphics_object_id id);\nstatic enum bp_result get_gpio_i2c_info(struct bios_parser *bp,\n\tATOM_I2C_RECORD *record,\n\tstruct graphics_object_i2c_info *info);\nstatic ATOM_HPD_INT_RECORD *get_hpd_record(struct bios_parser *bp,\n\tATOM_OBJECT *object);\nstatic struct device_id device_type_from_device_id(uint16_t device_id);\nstatic uint32_t signal_to_ss_id(enum as_signal_type signal);\nstatic uint32_t get_support_mask_for_device_id(struct device_id device_id);\nstatic ATOM_ENCODER_CAP_RECORD_V2 *get_encoder_cap_record(\n\tstruct bios_parser *bp,\n\tATOM_OBJECT *object);\n\n#define BIOS_IMAGE_SIZE_OFFSET 2\n#define BIOS_IMAGE_SIZE_UNIT 512\n\n \nstatic bool bios_parser_construct(\n\tstruct bios_parser *bp,\n\tstruct bp_init_data *init,\n\tenum dce_version dce_version);\n\nstatic uint8_t bios_parser_get_connectors_number(\n\tstruct dc_bios *dcb);\n\nstatic enum bp_result bios_parser_get_embedded_panel_info(\n\tstruct dc_bios *dcb,\n\tstruct embedded_panel_info *info);\n\n \n\nstruct dc_bios *bios_parser_create(\n\tstruct bp_init_data *init,\n\tenum dce_version dce_version)\n{\n\tstruct bios_parser *bp;\n\n\tbp = kzalloc(sizeof(struct bios_parser), GFP_KERNEL);\n\tif (!bp)\n\t\treturn NULL;\n\n\tif (bios_parser_construct(bp, init, dce_version))\n\t\treturn &bp->base;\n\n\tkfree(bp);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void bios_parser_destruct(struct bios_parser *bp)\n{\n\tkfree(bp->base.bios_local_image);\n\tkfree(bp->base.integrated_info);\n}\n\nstatic void bios_parser_destroy(struct dc_bios **dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(*dcb);\n\n\tif (!bp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tbios_parser_destruct(bp);\n\n\tkfree(bp);\n\t*dcb = NULL;\n}\n\nstatic uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)\n{\n\tATOM_OBJECT_TABLE *table;\n\n\tuint32_t object_table_offset = bp->object_info_tbl_offset + offset;\n\n\ttable = ((ATOM_OBJECT_TABLE *) bios_get_image(&bp->base,\n\t\t\t\tobject_table_offset,\n\t\t\t\tstruct_size(table, asObjects, 1)));\n\n\tif (!table)\n\t\treturn 0;\n\telse\n\t\treturn table->ucNumberOfObjects;\n}\n\nstatic uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\treturn get_number_of_objects(bp,\n\t\tle16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset));\n}\n\nstatic struct graphics_object_id bios_parser_get_connector_id(\n\tstruct dc_bios *dcb,\n\tuint8_t i)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct graphics_object_id object_id = dal_graphics_object_id_init(\n\t\t0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);\n\tuint16_t id;\n\n\tuint32_t connector_table_offset = bp->object_info_tbl_offset\n\t\t+ le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);\n\n\tATOM_OBJECT_TABLE *tbl = ((ATOM_OBJECT_TABLE *) bios_get_image(&bp->base,\n\t\t\t\tconnector_table_offset,\n\t\t\t\tstruct_size(tbl, asObjects, 1)));\n\n\tif (!tbl) {\n\t\tdm_error(\"Can't get connector table from atom bios.\\n\");\n\t\treturn object_id;\n\t}\n\n\tif (tbl->ucNumberOfObjects <= i) {\n\t\tdm_error(\"Can't find connector id %d in connector table of size %d.\\n\",\n\t\t\t i, tbl->ucNumberOfObjects);\n\t\treturn object_id;\n\t}\n\n\tid = le16_to_cpu(tbl->asObjects[i].usObjectID);\n\tobject_id = object_id_from_bios_object_id(id);\n\treturn object_id;\n}\n\nstatic enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,\n\tstruct graphics_object_id object_id, uint32_t index,\n\tstruct graphics_object_id *src_object_id)\n{\n\tuint32_t number;\n\tuint16_t *id;\n\tATOM_OBJECT *object;\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!src_object_id)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tobject = get_bios_object(bp, object_id);\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tnumber = get_src_obj_list(bp, object, &id);\n\n\tif (number <= index)\n\t\treturn BP_RESULT_BADINPUT;\n\n\t*src_object_id = object_id_from_bios_object_id(id[index]);\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,\n\tstruct graphics_object_id id,\n\tstruct graphics_object_i2c_info *info)\n{\n\tuint32_t offset;\n\tATOM_OBJECT *object;\n\tATOM_COMMON_RECORD_HEADER *header;\n\tATOM_I2C_RECORD *record;\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tobject = get_bios_object(bp, id);\n\n\tif (!object)\n\t\treturn BP_RESULT_BADINPUT;\n\n\toffset = le16_to_cpu(object->usRecordOffset)\n\t\t\t+ bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);\n\n\t\tif (!header)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\tif (LAST_RECORD_TYPE == header->ucRecordType ||\n\t\t\t!header->ucRecordSize)\n\t\t\tbreak;\n\n\t\tif (ATOM_I2C_RECORD_TYPE == header->ucRecordType\n\t\t\t&& sizeof(ATOM_I2C_RECORD) <= header->ucRecordSize) {\n\t\t\t \n\t\t\trecord = (ATOM_I2C_RECORD *) header;\n\n\t\t\tif (get_gpio_i2c_info(bp, record, info) == BP_RESULT_OK)\n\t\t\t\treturn BP_RESULT_OK;\n\t\t}\n\n\t\toffset += header->ucRecordSize;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,\n\tstruct graphics_object_id id,\n\tstruct graphics_object_hpd_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tATOM_OBJECT *object;\n\tATOM_HPD_INT_RECORD *record = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tobject = get_bios_object(bp, id);\n\n\tif (!object)\n\t\treturn BP_RESULT_BADINPUT;\n\n\trecord = get_hpd_record(bp, object);\n\n\tif (record != NULL) {\n\t\tinfo->hpd_int_gpio_uid = record->ucHPDIntGPIOID;\n\t\tinfo->hpd_active = record->ucPlugged_PinState;\n\t\treturn BP_RESULT_OK;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result bios_parser_get_device_tag_record(\n\tstruct bios_parser *bp,\n\tATOM_OBJECT *object,\n\tATOM_CONNECTOR_DEVICE_TAG_RECORD **record)\n{\n\tATOM_COMMON_RECORD_HEADER *header;\n\tuint32_t offset;\n\n\toffset = le16_to_cpu(object->usRecordOffset)\n\t\t\t+ bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);\n\n\t\tif (!header)\n\t\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t\toffset += header->ucRecordSize;\n\n\t\tif (LAST_RECORD_TYPE == header->ucRecordType ||\n\t\t\t!header->ucRecordSize)\n\t\t\tbreak;\n\n\t\tif (ATOM_CONNECTOR_DEVICE_TAG_RECORD_TYPE !=\n\t\t\theader->ucRecordType)\n\t\t\tcontinue;\n\n\t\tif (sizeof(ATOM_CONNECTOR_DEVICE_TAG) > header->ucRecordSize)\n\t\t\tcontinue;\n\n\t\t*record = (ATOM_CONNECTOR_DEVICE_TAG_RECORD *) header;\n\t\treturn BP_RESULT_OK;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result bios_parser_get_device_tag(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id connector_object_id,\n\tuint32_t device_tag_index,\n\tstruct connector_device_tag_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tATOM_OBJECT *object;\n\tATOM_CONNECTOR_DEVICE_TAG_RECORD *record = NULL;\n\tATOM_CONNECTOR_DEVICE_TAG *device_tag;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\t \n\tobject = get_bios_object(bp, connector_object_id);\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tif (bios_parser_get_device_tag_record(bp, object, &record)\n\t\t!= BP_RESULT_OK)\n\t\treturn BP_RESULT_NORECORD;\n\n\tif (device_tag_index >= record->ucNumberOfDevice)\n\t\treturn BP_RESULT_NORECORD;\n\n\tdevice_tag = &record->asDeviceTag[device_tag_index];\n\n\tinfo->acpi_device = le32_to_cpu(device_tag->ulACPIDeviceEnum);\n\tinfo->dev_id =\n\t\tdevice_type_from_device_id(le16_to_cpu(device_tag->usDeviceID));\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_firmware_info_v1_4(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\nstatic enum bp_result get_firmware_info_v2_1(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\nstatic enum bp_result get_firmware_info_v2_2(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info);\n\nstatic enum bp_result bios_parser_get_firmware_info(\n\tstruct dc_bios *dcb,\n\tstruct dc_firmware_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_BADBIOSTABLE;\n\tATOM_COMMON_TABLE_HEADER *header;\n\tstruct atom_data_revision revision;\n\n\tif (info && DATA_TABLES(FirmwareInfo)) {\n\t\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,\n\t\t\tDATA_TABLES(FirmwareInfo));\n\t\tget_atom_data_table_revision(header, &revision);\n\t\tswitch (revision.major) {\n\t\tcase 1:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 4:\n\t\t\t\tresult = get_firmware_info_v1_4(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 1:\n\t\t\t\tresult = get_firmware_info_v2_1(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tresult = get_firmware_info_v2_2(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic enum bp_result get_firmware_info_v1_4(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tATOM_FIRMWARE_INFO_V1_4 *firmware_info =\n\t\tGET_IMAGE(ATOM_FIRMWARE_INFO_V1_4,\n\t\t\tDATA_TABLES(FirmwareInfo));\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!firmware_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tinfo->pll_info.crystal_frequency =\n\t\tle16_to_cpu(firmware_info->usReferenceClock) * 10;\n\tinfo->pll_info.min_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmware_info->usMinPixelClockPLL_Input) * 10;\n\tinfo->pll_info.max_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmware_info->usMaxPixelClockPLL_Input) * 10;\n\tinfo->pll_info.min_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmware_info->ulMinPixelClockPLL_Output) * 10;\n\tinfo->pll_info.max_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmware_info->ulMaxPixelClockPLL_Output) * 10;\n\n\tif (firmware_info->usFirmwareCapability.sbfAccess.MemoryClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.memory_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\n\tif (firmware_info->usFirmwareCapability.sbfAccess.EngineClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.engine_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_ss_info_v3_1(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info);\n\nstatic enum bp_result get_firmware_info_v2_1(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tATOM_FIRMWARE_INFO_V2_1 *firmwareInfo =\n\t\tGET_IMAGE(ATOM_FIRMWARE_INFO_V2_1, DATA_TABLES(FirmwareInfo));\n\tstruct spread_spectrum_info internalSS;\n\tuint32_t index;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!firmwareInfo)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tinfo->pll_info.crystal_frequency =\n\t\tle16_to_cpu(firmwareInfo->usCoreReferenceClock) * 10;\n\tinfo->pll_info.min_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmwareInfo->usMinPixelClockPLL_Input) * 10;\n\tinfo->pll_info.max_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmwareInfo->usMaxPixelClockPLL_Input) * 10;\n\tinfo->pll_info.min_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmwareInfo->ulMinPixelClockPLL_Output) * 10;\n\tinfo->pll_info.max_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmwareInfo->ulMaxPixelClockPLL_Output) * 10;\n\tinfo->default_display_engine_pll_frequency =\n\t\tle32_to_cpu(firmwareInfo->ulDefaultDispEngineClkFreq) * 10;\n\tinfo->external_clock_source_frequency_for_dp =\n\t\tle16_to_cpu(firmwareInfo->usUniphyDPModeExtClkFreq) * 10;\n\tinfo->min_allowed_bl_level = firmwareInfo->ucMinAllowedBL_Level;\n\n\t \n\tindex = 0;\n\tif (firmwareInfo->usFirmwareCapability.sbfAccess.MemoryClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.memory_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\telse if (get_ss_info_v3_1(bp,\n\t\tASIC_INTERNAL_MEMORY_SS, index, &internalSS) == BP_RESULT_OK) {\n\t\tif (internalSS.spread_spectrum_percentage) {\n\t\t\tinfo->feature.memory_clk_ss_percentage =\n\t\t\t\tinternalSS.spread_spectrum_percentage;\n\t\t\tif (internalSS.type.CENTER_MODE) {\n\t\t\t\t \n\t\t\t\t++info->feature.memory_clk_ss_percentage;\n\t\t\t\tinfo->feature.memory_clk_ss_percentage /= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tindex = 1;\n\tif (firmwareInfo->usFirmwareCapability.sbfAccess.EngineClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.engine_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\telse if (get_ss_info_v3_1(bp,\n\t\tASIC_INTERNAL_ENGINE_SS, index, &internalSS) == BP_RESULT_OK) {\n\t\tif (internalSS.spread_spectrum_percentage) {\n\t\t\tinfo->feature.engine_clk_ss_percentage =\n\t\t\t\tinternalSS.spread_spectrum_percentage;\n\t\t\tif (internalSS.type.CENTER_MODE) {\n\t\t\t\t \n\t\t\t\t++info->feature.engine_clk_ss_percentage;\n\t\t\t\tinfo->feature.engine_clk_ss_percentage /= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_firmware_info_v2_2(\n\tstruct bios_parser *bp,\n\tstruct dc_firmware_info *info)\n{\n\tATOM_FIRMWARE_INFO_V2_2 *firmware_info;\n\tstruct spread_spectrum_info internal_ss;\n\tuint32_t index;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tfirmware_info = GET_IMAGE(ATOM_FIRMWARE_INFO_V2_2,\n\t\tDATA_TABLES(FirmwareInfo));\n\n\tif (!firmware_info)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tinfo->pll_info.crystal_frequency =\n\t\tle16_to_cpu(firmware_info->usCoreReferenceClock) * 10;\n\tinfo->pll_info.min_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmware_info->usMinPixelClockPLL_Input) * 10;\n\tinfo->pll_info.max_input_pxl_clk_pll_frequency =\n\t\tle16_to_cpu(firmware_info->usMaxPixelClockPLL_Input) * 10;\n\tinfo->pll_info.min_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmware_info->ulMinPixelClockPLL_Output) * 10;\n\tinfo->pll_info.max_output_pxl_clk_pll_frequency =\n\t\tle32_to_cpu(firmware_info->ulMaxPixelClockPLL_Output) * 10;\n\tinfo->default_display_engine_pll_frequency =\n\t\tle32_to_cpu(firmware_info->ulDefaultDispEngineClkFreq) * 10;\n\tinfo->external_clock_source_frequency_for_dp =\n\t\tle16_to_cpu(firmware_info->usUniphyDPModeExtClkFreq) * 10;\n\n\t \n\tindex = 0;\n\tif (firmware_info->usFirmwareCapability.sbfAccess.MemoryClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.memory_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\telse if (get_ss_info_v3_1(bp,\n\t\t\tASIC_INTERNAL_MEMORY_SS, index, &internal_ss) == BP_RESULT_OK) {\n\t\tif (internal_ss.spread_spectrum_percentage) {\n\t\t\tinfo->feature.memory_clk_ss_percentage =\n\t\t\t\t\tinternal_ss.spread_spectrum_percentage;\n\t\t\tif (internal_ss.type.CENTER_MODE) {\n\t\t\t\t \n\t\t\t\t++info->feature.memory_clk_ss_percentage;\n\t\t\t\tinfo->feature.memory_clk_ss_percentage /= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tindex = 1;\n\tif (firmware_info->usFirmwareCapability.sbfAccess.EngineClockSS_Support)\n\t\t \n\t\t \n\t\tinfo->feature.engine_clk_ss_percentage = THREE_PERCENT_OF_10000;\n\telse if (get_ss_info_v3_1(bp,\n\t\t\tASIC_INTERNAL_ENGINE_SS, index, &internal_ss) == BP_RESULT_OK) {\n\t\tif (internal_ss.spread_spectrum_percentage) {\n\t\t\tinfo->feature.engine_clk_ss_percentage =\n\t\t\t\t\tinternal_ss.spread_spectrum_percentage;\n\t\t\tif (internal_ss.type.CENTER_MODE) {\n\t\t\t\t \n\t\t\t\t++info->feature.engine_clk_ss_percentage;\n\t\t\t\tinfo->feature.engine_clk_ss_percentage /= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tinfo->remote_display_config = firmware_info->ucRemoteDisplayConfig;\n\n\t \n\tinfo->min_allowed_bl_level = firmware_info->ucMinAllowedBL_Level;\n\t \n\tinfo->smu_gpu_pll_output_freq =\n\t\t\t(uint32_t) (le32_to_cpu(firmware_info->ulGPUPLL_OutputFreq) * 10);\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_ss_info_v3_1(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tATOM_ASIC_INTERNAL_SS_INFO_V3 *ss_table_header_include;\n\tATOM_ASIC_SS_ASSIGNMENT_V3 *tbl;\n\tuint32_t table_size;\n\tuint32_t i;\n\tuint32_t table_index = 0;\n\n\tif (!ss_info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tss_table_header_include = ((ATOM_ASIC_INTERNAL_SS_INFO_V3 *) bios_get_image(&bp->base,\n\t\t\t\tDATA_TABLES(ASIC_InternalSS_Info),\n\t\t\t\tstruct_size(ss_table_header_include, asSpreadSpectrum, 1)));\n\ttable_size =\n\t\t(le16_to_cpu(ss_table_header_include->sHeader.usStructureSize)\n\t\t\t\t- sizeof(ATOM_COMMON_TABLE_HEADER))\n\t\t\t\t/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);\n\n\ttbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)\n\t\t\t\t&ss_table_header_include->asSpreadSpectrum[0];\n\n\tmemset(ss_info, 0, sizeof(struct spread_spectrum_info));\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (tbl[i].ucClockIndication != (uint8_t) id)\n\t\t\tcontinue;\n\n\t\tif (table_index != index) {\n\t\t\ttable_index++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\n\t\tif (SS_MODE_V3_EXTERNAL_SS_MASK & tbl[i].ucSpreadSpectrumMode)\n\t\t\tss_info->type.EXTERNAL = true;\n\n\t\tif (SS_MODE_V3_CENTRE_SPREAD_MASK & tbl[i].ucSpreadSpectrumMode)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\t \n\t\tss_info->spread_percentage_divider = 100;\n\n\t\t \n\t\tif (SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK\n\t\t\t\t& tbl[i].ucSpreadSpectrumMode)\n\t\t\tss_info->spread_percentage_divider = 1000;\n\n\t\tss_info->type.STEP_AND_DELAY_INFO = false;\n\t\t \n\t\tss_info->target_clock_range =\n\t\t\t\tle32_to_cpu(tbl[i].ulTargetClockRange) * 10;\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t\t(uint32_t)le16_to_cpu(tbl[i].usSpreadSpectrumPercentage);\n\t\tss_info->spread_spectrum_range =\n\t\t\t\t(uint32_t)(le16_to_cpu(tbl[i].usSpreadRateIn10Hz) * 10);\n\n\t\treturn BP_RESULT_OK;\n\t}\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result bios_parser_transmitter_control(\n\tstruct dc_bios *dcb,\n\tstruct bp_transmitter_control *cntl)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.transmitter_control)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.transmitter_control(bp, cntl);\n}\n\nstatic enum bp_result bios_parser_encoder_control(\n\tstruct dc_bios *dcb,\n\tstruct bp_encoder_control *cntl)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.dig_encoder_control)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.dig_encoder_control(bp, cntl);\n}\n\nstatic enum bp_result bios_parser_adjust_pixel_clock(\n\tstruct dc_bios *dcb,\n\tstruct bp_adjust_pixel_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.adjust_display_pll)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.adjust_display_pll(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_set_pixel_clock(\n\tstruct dc_bios *dcb,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_pixel_clock)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_pixel_clock(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_set_dce_clock(\n\tstruct dc_bios *dcb,\n\tstruct bp_set_dce_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_dce_clock)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_dce_clock(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_enable_spread_spectrum_on_ppll(\n\tstruct dc_bios *dcb,\n\tstruct bp_spread_spectrum_parameters *bp_params,\n\tbool enable)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_spread_spectrum_on_ppll)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_spread_spectrum_on_ppll(\n\t\t\tbp, bp_params, enable);\n\n}\n\nstatic enum bp_result bios_parser_program_crtc_timing(\n\tstruct dc_bios *dcb,\n\tstruct bp_hw_crtc_timing_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.set_crtc_timing)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.set_crtc_timing(bp, bp_params);\n}\n\nstatic enum bp_result bios_parser_program_display_engine_pll(\n\tstruct dc_bios *dcb,\n\tstruct bp_pixel_clock_parameters *bp_params)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.program_clock)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.program_clock(bp, bp_params);\n\n}\n\n\nstatic enum bp_result bios_parser_enable_crtc(\n\tstruct dc_bios *dcb,\n\tenum controller_id id,\n\tbool enable)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_crtc)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_crtc(bp, id, enable);\n}\n\nstatic enum bp_result bios_parser_enable_disp_power_gating(\n\tstruct dc_bios *dcb,\n\tenum controller_id controller_id,\n\tenum bp_pipe_control_action action)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tif (!bp->cmd_tbl.enable_disp_power_gating)\n\t\treturn BP_RESULT_FAILURE;\n\n\treturn bp->cmd_tbl.enable_disp_power_gating(bp, controller_id,\n\t\taction);\n}\n\nstatic bool bios_parser_is_device_id_supported(\n\tstruct dc_bios *dcb,\n\tstruct device_id id)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\n\tuint32_t mask = get_support_mask_for_device_id(id);\n\n\treturn (le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport) & mask) != 0;\n}\n\nstatic ATOM_HPD_INT_RECORD *get_hpd_record(struct bios_parser *bp,\n\tATOM_OBJECT *object)\n{\n\tATOM_COMMON_RECORD_HEADER *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = le16_to_cpu(object->usRecordOffset)\n\t\t\t+ bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\tif (LAST_RECORD_TYPE == header->ucRecordType ||\n\t\t\t!header->ucRecordSize)\n\t\t\tbreak;\n\n\t\tif (ATOM_HPD_INT_RECORD_TYPE == header->ucRecordType\n\t\t\t&& sizeof(ATOM_HPD_INT_RECORD) <= header->ucRecordSize)\n\t\t\treturn (ATOM_HPD_INT_RECORD *) header;\n\n\t\toffset += header->ucRecordSize;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum bp_result get_ss_info_from_ss_info_table(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *ss_info);\nstatic enum bp_result get_ss_info_from_tbl(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *ss_info);\n \nstatic enum bp_result bios_parser_get_spread_spectrum_info(\n\tstruct dc_bios *dcb,\n\tenum as_signal_type signal,\n\tuint32_t index,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tuint32_t clk_id_ss = 0;\n\tATOM_COMMON_TABLE_HEADER *header;\n\tstruct atom_data_revision tbl_revision;\n\n\tif (!ss_info)  \n\t\treturn BP_RESULT_BADINPUT;\n\t \n\tclk_id_ss = signal_to_ss_id(signal);\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\tif (!index)\n\t\t\treturn get_ss_info_from_ss_info_table(bp, clk_id_ss,\n\t\t\t\tss_info);\n\n\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,\n\t\tDATA_TABLES(ASIC_InternalSS_Info));\n\tget_atom_data_table_revision(header, &tbl_revision);\n\n\tswitch (tbl_revision.major) {\n\tcase 2:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\t \n\t\t\tif (!index)\n\t\t\t\treturn get_ss_info_from_tbl(bp, clk_id_ss,\n\t\t\t\t\t\tss_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (tbl_revision.minor) {\n\t\tcase 1:\n\t\t\treturn get_ss_info_v3_1(bp, clk_id_ss, index, ss_info);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\treturn result;\n}\n\nstatic enum bp_result get_ss_info_from_internal_ss_info_tbl_V2_1(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *info);\n\n \nstatic enum bp_result get_ss_info_from_tbl(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tif (!ss_info)  \n\t\treturn BP_RESULT_BADINPUT;\n\t \n\tif (id == ASIC_INTERNAL_SS_ON_DP || id == ASIC_INTERNAL_SS_ON_LVDS)\n\t\treturn get_ss_info_from_ss_info_table(bp, id, ss_info);\n\telse\n\t\treturn get_ss_info_from_internal_ss_info_tbl_V2_1(bp, id,\n\t\t\tss_info);\n}\n\n \nstatic enum bp_result get_ss_info_from_internal_ss_info_tbl_V2_1(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *info)\n{\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tATOM_ASIC_INTERNAL_SS_INFO_V2 *header;\n\tATOM_ASIC_SS_ASSIGNMENT_V2 *tbl;\n\tuint32_t tbl_size, i;\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\treturn result;\n\n\theader = ((ATOM_ASIC_INTERNAL_SS_INFO_V2 *) bios_get_image(\n\t\t\t\t&bp->base,\n\t\t\t\tDATA_TABLES(ASIC_InternalSS_Info),\n\t\t\t\tstruct_size(header, asSpreadSpectrum, 1)));\n\n\tmemset(info, 0, sizeof(struct spread_spectrum_info));\n\n\ttbl_size = (le16_to_cpu(header->sHeader.usStructureSize)\n\t\t\t- sizeof(ATOM_COMMON_TABLE_HEADER))\n\t\t\t\t\t/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);\n\n\ttbl = (ATOM_ASIC_SS_ASSIGNMENT_V2 *)\n\t\t\t\t\t&(header->asSpreadSpectrum[0]);\n\tfor (i = 0; i < tbl_size; i++) {\n\t\tresult = BP_RESULT_NORECORD;\n\n\t\tif (tbl[i].ucClockIndication != (uint8_t)id)\n\t\t\tcontinue;\n\n\t\tif (ATOM_EXTERNAL_SS_MASK\n\t\t\t& tbl[i].ucSpreadSpectrumMode) {\n\t\t\tinfo->type.EXTERNAL = true;\n\t\t}\n\t\tif (ATOM_SS_CENTRE_SPREAD_MODE_MASK\n\t\t\t& tbl[i].ucSpreadSpectrumMode) {\n\t\t\tinfo->type.CENTER_MODE = true;\n\t\t}\n\t\tinfo->type.STEP_AND_DELAY_INFO = false;\n\t\t \n\t\tinfo->target_clock_range =\n\t\t\tle32_to_cpu(tbl[i].ulTargetClockRange) * 10;\n\t\tinfo->spread_spectrum_percentage =\n\t\t\t(uint32_t)le16_to_cpu(tbl[i].usSpreadSpectrumPercentage);\n\t\tinfo->spread_spectrum_range =\n\t\t\t(uint32_t)(le16_to_cpu(tbl[i].usSpreadRateIn10Hz) * 10);\n\t\tresult = BP_RESULT_OK;\n\t\tbreak;\n\t}\n\n\treturn result;\n\n}\n\n \nstatic enum bp_result get_ss_info_from_ss_info_table(\n\tstruct bios_parser *bp,\n\tuint32_t id,\n\tstruct spread_spectrum_info *ss_info)\n{\n\tenum bp_result result = BP_RESULT_UNSUPPORTED;\n\tATOM_SPREAD_SPECTRUM_INFO *tbl;\n\tATOM_COMMON_TABLE_HEADER *header;\n\tuint32_t table_size;\n\tuint32_t i;\n\tuint32_t id_local = SS_ID_UNKNOWN;\n\tstruct atom_data_revision revision;\n\n\t \n\t \n\tif (!DATA_TABLES(SS_Info) || !ss_info)\n\t\treturn result;\n\n\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER, DATA_TABLES(SS_Info));\n\tget_atom_data_table_revision(header, &revision);\n\n\ttbl = GET_IMAGE(ATOM_SPREAD_SPECTRUM_INFO, DATA_TABLES(SS_Info));\n\n\tif (1 != revision.major || 2 > revision.minor)\n\t\treturn result;\n\n\t \n\tswitch (id) {\n\tcase ASIC_INTERNAL_SS_ON_DP:\n\t\tid_local = SS_ID_DP1;\n\t\tbreak;\n\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t{\n\t\tstruct embedded_panel_info panel_info;\n\n\t\tif (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)\n\t\t\t\t== BP_RESULT_OK)\n\t\t\tid_local = panel_info.ss_id;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (id_local == SS_ID_UNKNOWN)\n\t\treturn result;\n\n\ttable_size = (le16_to_cpu(tbl->sHeader.usStructureSize) -\n\t\t\tsizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\t\tsizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (id_local != (uint32_t)tbl->asSS_Info[i].ucSS_Id)\n\t\t\tcontinue;\n\n\t\tmemset(ss_info, 0, sizeof(struct spread_spectrum_info));\n\n\t\tif (ATOM_EXTERNAL_SS_MASK &\n\t\t\t\ttbl->asSS_Info[i].ucSpreadSpectrumType)\n\t\t\tss_info->type.EXTERNAL = true;\n\n\t\tif (ATOM_SS_CENTRE_SPREAD_MODE_MASK &\n\t\t\t\ttbl->asSS_Info[i].ucSpreadSpectrumType)\n\t\t\tss_info->type.CENTER_MODE = true;\n\n\t\tss_info->type.STEP_AND_DELAY_INFO = true;\n\t\tss_info->spread_spectrum_percentage =\n\t\t\t(uint32_t)le16_to_cpu(tbl->asSS_Info[i].usSpreadSpectrumPercentage);\n\t\tss_info->step_and_delay_info.step = tbl->asSS_Info[i].ucSS_Step;\n\t\tss_info->step_and_delay_info.delay =\n\t\t\ttbl->asSS_Info[i].ucSS_Delay;\n\t\tss_info->step_and_delay_info.recommended_ref_div =\n\t\t\ttbl->asSS_Info[i].ucRecommendedRef_Div;\n\t\tss_info->spread_spectrum_range =\n\t\t\t(uint32_t)tbl->asSS_Info[i].ucSS_Range * 10000;\n\n\t\t \n\t\tresult = BP_RESULT_OK;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\nstatic enum bp_result get_embedded_panel_info_v1_2(\n\tstruct bios_parser *bp,\n\tstruct embedded_panel_info *info);\nstatic enum bp_result get_embedded_panel_info_v1_3(\n\tstruct bios_parser *bp,\n\tstruct embedded_panel_info *info);\n\nstatic enum bp_result bios_parser_get_embedded_panel_info(\n\tstruct dc_bios *dcb,\n\tstruct embedded_panel_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tATOM_COMMON_TABLE_HEADER *hdr;\n\n\tif (!DATA_TABLES(LCD_Info))\n\t\treturn BP_RESULT_FAILURE;\n\n\thdr = GET_IMAGE(ATOM_COMMON_TABLE_HEADER, DATA_TABLES(LCD_Info));\n\n\tif (!hdr)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tswitch (hdr->ucTableFormatRevision) {\n\tcase 1:\n\t\tswitch (hdr->ucTableContentRevision) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\treturn get_embedded_panel_info_v1_2(bp, info);\n\t\tcase 3:\n\t\t\treturn get_embedded_panel_info_v1_3(bp, info);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn BP_RESULT_FAILURE;\n}\n\nstatic enum bp_result get_embedded_panel_info_v1_2(\n\tstruct bios_parser *bp,\n\tstruct embedded_panel_info *info)\n{\n\tATOM_LVDS_INFO_V12 *lvds;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(LVDS_Info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tlvds =\n\t\tGET_IMAGE(ATOM_LVDS_INFO_V12, DATA_TABLES(LVDS_Info));\n\n\tif (!lvds)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (1 != lvds->sHeader.ucTableFormatRevision\n\t\t|| 2 > lvds->sHeader.ucTableContentRevision)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tmemset(info, 0, sizeof(struct embedded_panel_info));\n\n\t \n\tinfo->lcd_timing.pixel_clk =\n\t\tle16_to_cpu(lvds->sLCDTiming.usPixClk) * 10;\n\t \n\tinfo->lcd_timing.horizontal_addressable =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHActive);\n\t \n\t \n\tinfo->lcd_timing.horizontal_blanking_time =\n\t\t\tle16_to_cpu(lvds->sLCDTiming.usHBlanking_Time);\n\t \n\tinfo->lcd_timing.vertical_addressable =\n\t\t\tle16_to_cpu(lvds->sLCDTiming.usVActive);\n\t \n\t \n\tinfo->lcd_timing.vertical_blanking_time =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVBlanking_Time);\n\tinfo->lcd_timing.horizontal_sync_offset =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHSyncOffset);\n\tinfo->lcd_timing.horizontal_sync_width =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHSyncWidth);\n\tinfo->lcd_timing.vertical_sync_offset =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVSyncOffset);\n\tinfo->lcd_timing.vertical_sync_width =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVSyncWidth);\n\tinfo->lcd_timing.horizontal_border = lvds->sLCDTiming.ucHBorder;\n\tinfo->lcd_timing.vertical_border = lvds->sLCDTiming.ucVBorder;\n\tinfo->lcd_timing.misc_info.HORIZONTAL_CUT_OFF =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.HorizontalCutOff;\n\tinfo->lcd_timing.misc_info.H_SYNC_POLARITY =\n\t\t~(uint32_t)\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.HSyncPolarity;\n\tinfo->lcd_timing.misc_info.V_SYNC_POLARITY =\n\t\t~(uint32_t)\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.VSyncPolarity;\n\tinfo->lcd_timing.misc_info.VERTICAL_CUT_OFF =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.VerticalCutOff;\n\tinfo->lcd_timing.misc_info.H_REPLICATION_BY2 =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.H_ReplicationBy2;\n\tinfo->lcd_timing.misc_info.V_REPLICATION_BY2 =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.V_ReplicationBy2;\n\tinfo->lcd_timing.misc_info.COMPOSITE_SYNC =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;\n\tinfo->lcd_timing.misc_info.INTERLACE =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;\n\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;\n\tinfo->ss_id = lvds->ucSS_Id;\n\n\t{\n\t\tuint8_t rr = le16_to_cpu(lvds->usSupportedRefreshRate);\n\t\t \n\t\tif (SUPPORTED_LCD_REFRESHRATE_30Hz & rr)\n\t\t\tinfo->supported_rr.REFRESH_RATE_30HZ = 1;\n\t\telse if (SUPPORTED_LCD_REFRESHRATE_40Hz & rr)\n\t\t\tinfo->supported_rr.REFRESH_RATE_40HZ = 1;\n\t\telse if (SUPPORTED_LCD_REFRESHRATE_48Hz & rr)\n\t\t\tinfo->supported_rr.REFRESH_RATE_48HZ = 1;\n\t\telse if (SUPPORTED_LCD_REFRESHRATE_50Hz & rr)\n\t\t\tinfo->supported_rr.REFRESH_RATE_50HZ = 1;\n\t\telse if (SUPPORTED_LCD_REFRESHRATE_60Hz & rr)\n\t\t\tinfo->supported_rr.REFRESH_RATE_60HZ = 1;\n\t}\n\n\t \n\tif (LCDPANEL_CAP_DRR_SUPPORTED\n\t\t\t& lvds->ucLCDPanel_SpecialHandlingCap)\n\t\tinfo->drr_enabled = 1;\n\n\tif (ATOM_PANEL_MISC_DUAL & lvds->ucLVDS_Misc)\n\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;\n\n\tif (ATOM_PANEL_MISC_888RGB & lvds->ucLVDS_Misc)\n\t\tinfo->lcd_timing.misc_info.RGB888 = true;\n\n\tinfo->lcd_timing.misc_info.GREY_LEVEL =\n\t\t(uint32_t) (ATOM_PANEL_MISC_GREY_LEVEL &\n\t\t\tlvds->ucLVDS_Misc) >> ATOM_PANEL_MISC_GREY_LEVEL_SHIFT;\n\n\tif (ATOM_PANEL_MISC_SPATIAL & lvds->ucLVDS_Misc)\n\t\tinfo->lcd_timing.misc_info.SPATIAL = true;\n\n\tif (ATOM_PANEL_MISC_TEMPORAL & lvds->ucLVDS_Misc)\n\t\tinfo->lcd_timing.misc_info.TEMPORAL = true;\n\n\tif (ATOM_PANEL_MISC_API_ENABLED & lvds->ucLVDS_Misc)\n\t\tinfo->lcd_timing.misc_info.API_ENABLED = true;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic enum bp_result get_embedded_panel_info_v1_3(\n\tstruct bios_parser *bp,\n\tstruct embedded_panel_info *info)\n{\n\tATOM_LCD_INFO_V13 *lvds;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tif (!DATA_TABLES(LCD_Info))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tlvds = GET_IMAGE(ATOM_LCD_INFO_V13, DATA_TABLES(LCD_Info));\n\n\tif (!lvds)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (!((1 == lvds->sHeader.ucTableFormatRevision)\n\t\t\t&& (3 <= lvds->sHeader.ucTableContentRevision)))\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tmemset(info, 0, sizeof(struct embedded_panel_info));\n\n\t \n\tinfo->lcd_timing.pixel_clk =\n\t\t\tle16_to_cpu(lvds->sLCDTiming.usPixClk) * 10;\n\t \n\tinfo->lcd_timing.horizontal_addressable =\n\t\t\tle16_to_cpu(lvds->sLCDTiming.usHActive);\n\t \n\t \n\tinfo->lcd_timing.horizontal_blanking_time =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHBlanking_Time);\n\t \n\tinfo->lcd_timing.vertical_addressable =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVActive);\n\t \n\t \n\tinfo->lcd_timing.vertical_blanking_time =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVBlanking_Time);\n\tinfo->lcd_timing.horizontal_sync_offset =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHSyncOffset);\n\tinfo->lcd_timing.horizontal_sync_width =\n\t\tle16_to_cpu(lvds->sLCDTiming.usHSyncWidth);\n\tinfo->lcd_timing.vertical_sync_offset =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVSyncOffset);\n\tinfo->lcd_timing.vertical_sync_width =\n\t\tle16_to_cpu(lvds->sLCDTiming.usVSyncWidth);\n\tinfo->lcd_timing.horizontal_border = lvds->sLCDTiming.ucHBorder;\n\tinfo->lcd_timing.vertical_border = lvds->sLCDTiming.ucVBorder;\n\tinfo->lcd_timing.misc_info.HORIZONTAL_CUT_OFF =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.HorizontalCutOff;\n\tinfo->lcd_timing.misc_info.H_SYNC_POLARITY =\n\t\t~(uint32_t)\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.HSyncPolarity;\n\tinfo->lcd_timing.misc_info.V_SYNC_POLARITY =\n\t\t~(uint32_t)\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.VSyncPolarity;\n\tinfo->lcd_timing.misc_info.VERTICAL_CUT_OFF =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.VerticalCutOff;\n\tinfo->lcd_timing.misc_info.H_REPLICATION_BY2 =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.H_ReplicationBy2;\n\tinfo->lcd_timing.misc_info.V_REPLICATION_BY2 =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.V_ReplicationBy2;\n\tinfo->lcd_timing.misc_info.COMPOSITE_SYNC =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;\n\tinfo->lcd_timing.misc_info.INTERLACE =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;\n\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =\n\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;\n\tinfo->ss_id = lvds->ucSS_Id;\n\n\t \n\tif (LCDPANEL_CAP_V13_DRR_SUPPORTED\n\t\t\t& lvds->ucLCDPanel_SpecialHandlingCap)\n\t\tinfo->drr_enabled = 1;\n\n\t \n\tif (info->drr_enabled == 1) {\n\t\tuint8_t min_rr =\n\t\t\t\tlvds->sRefreshRateSupport.ucMinRefreshRateForDRR;\n\t\tuint8_t rr = lvds->sRefreshRateSupport.ucSupportedRefreshRate;\n\n\t\tif (min_rr != 0) {\n\t\t\tif (SUPPORTED_LCD_REFRESHRATE_30Hz & min_rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_30HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_40Hz & min_rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_40HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_48Hz & min_rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_48HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_50Hz & min_rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_50HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_60Hz & min_rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_60HZ = 1;\n\t\t} else {\n\t\t\tif (SUPPORTED_LCD_REFRESHRATE_30Hz & rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_30HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_40Hz & rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_40HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_48Hz & rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_48HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_50Hz & rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_50HZ = 1;\n\t\t\telse if (SUPPORTED_LCD_REFRESHRATE_60Hz & rr)\n\t\t\t\tinfo->supported_rr.REFRESH_RATE_60HZ = 1;\n\t\t}\n\t}\n\n\tif (ATOM_PANEL_MISC_V13_DUAL & lvds->ucLCD_Misc)\n\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;\n\n\tif (ATOM_PANEL_MISC_V13_8BIT_PER_COLOR & lvds->ucLCD_Misc)\n\t\tinfo->lcd_timing.misc_info.RGB888 = true;\n\n\tinfo->lcd_timing.misc_info.GREY_LEVEL =\n\t\t\t(uint32_t) (ATOM_PANEL_MISC_V13_GREY_LEVEL &\n\t\t\t\tlvds->ucLCD_Misc) >> ATOM_PANEL_MISC_V13_GREY_LEVEL_SHIFT;\n\n\treturn BP_RESULT_OK;\n}\n\n \nstatic enum bp_result bios_parser_get_encoder_cap_info(\n\tstruct dc_bios *dcb,\n\tstruct graphics_object_id object_id,\n\tstruct bp_encoder_cap_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tATOM_OBJECT *object;\n\tATOM_ENCODER_CAP_RECORD_V2 *record = NULL;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\tobject = get_bios_object(bp, object_id);\n\n\tif (!object)\n\t\treturn BP_RESULT_BADINPUT;\n\n\trecord = get_encoder_cap_record(bp, object);\n\tif (!record)\n\t\treturn BP_RESULT_NORECORD;\n\n\tinfo->DP_HBR2_EN = record->usHBR2En;\n\tinfo->DP_HBR3_EN = record->usHBR3En;\n\tinfo->HDMI_6GB_EN = record->usHDMI6GEn;\n\treturn BP_RESULT_OK;\n}\n\n \nstatic ATOM_ENCODER_CAP_RECORD_V2 *get_encoder_cap_record(\n\tstruct bios_parser *bp,\n\tATOM_OBJECT *object)\n{\n\tATOM_COMMON_RECORD_HEADER *header;\n\tuint32_t offset;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn NULL;\n\t}\n\n\toffset = le16_to_cpu(object->usRecordOffset)\n\t\t\t\t\t+ bp->object_info_tbl_offset;\n\n\tfor (;;) {\n\t\theader = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);\n\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\toffset += header->ucRecordSize;\n\n\t\tif (LAST_RECORD_TYPE == header->ucRecordType ||\n\t\t\t\t!header->ucRecordSize)\n\t\t\tbreak;\n\n\t\tif (ATOM_ENCODER_CAP_RECORD_TYPE != header->ucRecordType)\n\t\t\tcontinue;\n\n\t\tif (sizeof(ATOM_ENCODER_CAP_RECORD_V2) <= header->ucRecordSize)\n\t\t\treturn (ATOM_ENCODER_CAP_RECORD_V2 *)header;\n\t}\n\n\treturn NULL;\n}\n\nstatic uint32_t get_ss_entry_number(\n\tstruct bios_parser *bp,\n\tuint32_t id);\nstatic uint32_t get_ss_entry_number_from_internal_ss_info_tbl_v2_1(\n\tstruct bios_parser *bp,\n\tuint32_t id);\nstatic uint32_t get_ss_entry_number_from_internal_ss_info_tbl_V3_1(\n\tstruct bios_parser *bp,\n\tuint32_t id);\nstatic uint32_t get_ss_entry_number_from_ss_info_tbl(\n\tstruct bios_parser *bp,\n\tuint32_t id);\n\n \nstatic uint32_t bios_parser_get_ss_entry_number(\n\tstruct dc_bios *dcb,\n\tenum as_signal_type signal)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tuint32_t ss_id = 0;\n\tATOM_COMMON_TABLE_HEADER *header;\n\tstruct atom_data_revision revision;\n\n\tss_id = signal_to_ss_id(signal);\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\treturn get_ss_entry_number_from_ss_info_tbl(bp, ss_id);\n\n\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,\n\t\t\tDATA_TABLES(ASIC_InternalSS_Info));\n\tget_atom_data_table_revision(header, &revision);\n\n\tswitch (revision.major) {\n\tcase 2:\n\t\tswitch (revision.minor) {\n\t\tcase 1:\n\t\t\treturn get_ss_entry_number(bp, ss_id);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tswitch (revision.minor) {\n\t\tcase 1:\n\t\t\treturn\n\t\t\t\tget_ss_entry_number_from_internal_ss_info_tbl_V3_1(\n\t\t\t\t\t\tbp, ss_id);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic uint32_t get_ss_entry_number_from_ss_info_tbl(\n\tstruct bios_parser *bp,\n\tuint32_t id)\n{\n\tATOM_SPREAD_SPECTRUM_INFO *tbl;\n\tATOM_COMMON_TABLE_HEADER *header;\n\tuint32_t table_size;\n\tuint32_t i;\n\tuint32_t number = 0;\n\tuint32_t id_local = SS_ID_UNKNOWN;\n\tstruct atom_data_revision revision;\n\n\t \n\tif (!DATA_TABLES(SS_Info))\n\t\treturn number;\n\n\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,\n\t\t\tDATA_TABLES(SS_Info));\n\tget_atom_data_table_revision(header, &revision);\n\n\ttbl = GET_IMAGE(ATOM_SPREAD_SPECTRUM_INFO,\n\t\t\tDATA_TABLES(SS_Info));\n\n\tif (1 != revision.major || 2 > revision.minor)\n\t\treturn number;\n\n\t \n\tswitch (id) {\n\tcase ASIC_INTERNAL_SS_ON_DP:\n\t\tid_local = SS_ID_DP1;\n\t\tbreak;\n\tcase ASIC_INTERNAL_SS_ON_LVDS: {\n\t\tstruct embedded_panel_info panel_info;\n\n\t\tif (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)\n\t\t\t\t== BP_RESULT_OK)\n\t\t\tid_local = panel_info.ss_id;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (id_local == SS_ID_UNKNOWN)\n\t\treturn number;\n\n\ttable_size = (le16_to_cpu(tbl->sHeader.usStructureSize) -\n\t\t\tsizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\t\tsizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);\n\n\tfor (i = 0; i < table_size; i++)\n\t\tif (id_local == (uint32_t)tbl->asSS_Info[i].ucSS_Id) {\n\t\t\tnumber = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn number;\n}\n\n \nstatic uint32_t get_ss_entry_number(struct bios_parser *bp, uint32_t id)\n{\n\tif (id == ASIC_INTERNAL_SS_ON_DP || id == ASIC_INTERNAL_SS_ON_LVDS)\n\t\treturn get_ss_entry_number_from_ss_info_tbl(bp, id);\n\n\treturn get_ss_entry_number_from_internal_ss_info_tbl_v2_1(bp, id);\n}\n\n \nstatic uint32_t get_ss_entry_number_from_internal_ss_info_tbl_v2_1(\n\tstruct bios_parser *bp,\n\tuint32_t id)\n{\n\tATOM_ASIC_INTERNAL_SS_INFO_V2 *header_include;\n\tATOM_ASIC_SS_ASSIGNMENT_V2 *tbl;\n\tuint32_t size;\n\tuint32_t i;\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\treturn 0;\n\n\theader_include = ((ATOM_ASIC_INTERNAL_SS_INFO_V2 *) bios_get_image(\n\t\t\t\t&bp->base,\n\t\t\t\tDATA_TABLES(ASIC_InternalSS_Info),\n\t\t\t\tstruct_size(header_include, asSpreadSpectrum, 1)));\n\n\tsize = (le16_to_cpu(header_include->sHeader.usStructureSize)\n\t\t\t- sizeof(ATOM_COMMON_TABLE_HEADER))\n\t\t\t\t\t\t/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);\n\n\ttbl = (ATOM_ASIC_SS_ASSIGNMENT_V2 *)\n\t\t\t\t&header_include->asSpreadSpectrum[0];\n\tfor (i = 0; i < size; i++)\n\t\tif (tbl[i].ucClockIndication == (uint8_t)id)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n \nstatic uint32_t get_ss_entry_number_from_internal_ss_info_tbl_V3_1(\n\tstruct bios_parser *bp,\n\tuint32_t id)\n{\n\tuint32_t number = 0;\n\tATOM_ASIC_INTERNAL_SS_INFO_V3 *header_include;\n\tATOM_ASIC_SS_ASSIGNMENT_V3 *tbl;\n\tuint32_t size;\n\tuint32_t i;\n\n\tif (!DATA_TABLES(ASIC_InternalSS_Info))\n\t\treturn number;\n\n\theader_include = ((ATOM_ASIC_INTERNAL_SS_INFO_V3 *) bios_get_image(&bp->base,\n\t\t\t\tDATA_TABLES(ASIC_InternalSS_Info),\n\t\t\t\tstruct_size(header_include, asSpreadSpectrum, 1)));\n\tsize = (le16_to_cpu(header_include->sHeader.usStructureSize) -\n\t\t\tsizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);\n\n\ttbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)\n\t\t\t\t&header_include->asSpreadSpectrum[0];\n\n\tfor (i = 0; i < size; i++)\n\t\tif (tbl[i].ucClockIndication == (uint8_t)id)\n\t\t\tnumber++;\n\n\treturn number;\n}\n\n \nstatic enum bp_result bios_parser_get_gpio_pin_info(\n\tstruct dc_bios *dcb,\n\tuint32_t gpio_id,\n\tstruct gpio_pin_info *info)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tATOM_GPIO_PIN_LUT *header;\n\tuint32_t count = 0;\n\tuint32_t i = 0;\n\n\tif (!DATA_TABLES(GPIO_Pin_LUT))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\theader = ((ATOM_GPIO_PIN_LUT *) bios_get_image(&bp->base,\n\t\t\t\tDATA_TABLES(GPIO_Pin_LUT),\n\t\t\t\tstruct_size(header, asGPIO_Pin, 1)));\n\tif (!header)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (sizeof(ATOM_COMMON_TABLE_HEADER) + struct_size(header, asGPIO_Pin, 1)\n\t\t\t> le16_to_cpu(header->sHeader.usStructureSize))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (1 != header->sHeader.ucTableContentRevision)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\tcount = (le16_to_cpu(header->sHeader.usStructureSize)\n\t\t\t- sizeof(ATOM_COMMON_TABLE_HEADER))\n\t\t\t\t/ sizeof(ATOM_GPIO_PIN_ASSIGNMENT);\n\tfor (i = 0; i < count; ++i) {\n\t\tif (header->asGPIO_Pin[i].ucGPIO_ID != gpio_id)\n\t\t\tcontinue;\n\n\t\tinfo->offset =\n\t\t\t(uint32_t) le16_to_cpu(header->asGPIO_Pin[i].usGpioPin_AIndex);\n\t\tinfo->offset_y = info->offset + 2;\n\t\tinfo->offset_en = info->offset + 1;\n\t\tinfo->offset_mask = info->offset - 1;\n\n\t\tinfo->mask = (uint32_t) (1 <<\n\t\t\theader->asGPIO_Pin[i].ucGpioPinBitShift);\n\t\tinfo->mask_y = info->mask + 2;\n\t\tinfo->mask_en = info->mask + 1;\n\t\tinfo->mask_mask = info->mask - 1;\n\n\t\treturn BP_RESULT_OK;\n\t}\n\n\treturn BP_RESULT_NORECORD;\n}\n\nstatic enum bp_result get_gpio_i2c_info(struct bios_parser *bp,\n\tATOM_I2C_RECORD *record,\n\tstruct graphics_object_i2c_info *info)\n{\n\tATOM_GPIO_I2C_INFO *header;\n\tuint32_t count = 0;\n\n\tif (!info)\n\t\treturn BP_RESULT_BADINPUT;\n\n\t \n\tif (!DATA_TABLES(GPIO_I2C_Info))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\theader = GET_IMAGE(ATOM_GPIO_I2C_INFO, DATA_TABLES(GPIO_I2C_Info));\n\tif (!header)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (sizeof(ATOM_COMMON_TABLE_HEADER) + sizeof(ATOM_GPIO_I2C_ASSIGMENT)\n\t\t\t> le16_to_cpu(header->sHeader.usStructureSize))\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tif (1 != header->sHeader.ucTableContentRevision)\n\t\treturn BP_RESULT_UNSUPPORTED;\n\n\t \n\tcount = (le16_to_cpu(header->sHeader.usStructureSize)\n\t\t\t- sizeof(ATOM_COMMON_TABLE_HEADER))\n\t\t\t\t/ sizeof(ATOM_GPIO_I2C_ASSIGMENT);\n\tif (count < record->sucI2cId.bfI2C_LineMux)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\t \n\tinfo->i2c_hw_assist = record->sucI2cId.bfHW_Capable;\n\tinfo->i2c_line = record->sucI2cId.bfI2C_LineMux;\n\tinfo->i2c_engine_id = record->sucI2cId.bfHW_EngineID;\n\tinfo->i2c_slave_address = record->ucI2CAddr;\n\n\tinfo->gpio_info.clk_mask_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkMaskRegisterIndex);\n\tinfo->gpio_info.clk_en_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkEnRegisterIndex);\n\tinfo->gpio_info.clk_y_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkY_RegisterIndex);\n\tinfo->gpio_info.clk_a_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkA_RegisterIndex);\n\tinfo->gpio_info.data_mask_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataMaskRegisterIndex);\n\tinfo->gpio_info.data_en_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataEnRegisterIndex);\n\tinfo->gpio_info.data_y_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataY_RegisterIndex);\n\tinfo->gpio_info.data_a_register_index =\n\t\t\tle16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataA_RegisterIndex);\n\n\tinfo->gpio_info.clk_mask_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucClkMaskShift;\n\tinfo->gpio_info.clk_en_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucClkEnShift;\n\tinfo->gpio_info.clk_y_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucClkY_Shift;\n\tinfo->gpio_info.clk_a_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucClkA_Shift;\n\tinfo->gpio_info.data_mask_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucDataMaskShift;\n\tinfo->gpio_info.data_en_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucDataEnShift;\n\tinfo->gpio_info.data_y_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucDataY_Shift;\n\tinfo->gpio_info.data_a_shift =\n\t\t\theader->asGPIO_Info[info->i2c_line].ucDataA_Shift;\n\n\treturn BP_RESULT_OK;\n}\n\nstatic bool dal_graphics_object_id_is_valid(struct graphics_object_id id)\n{\n\tbool rc = true;\n\n\tswitch (id.type) {\n\tcase OBJECT_TYPE_UNKNOWN:\n\t\trc = false;\n\t\tbreak;\n\tcase OBJECT_TYPE_GPU:\n\tcase OBJECT_TYPE_ENGINE:\n\t\t \n\t\tif (id.enum_id == ENUM_ID_UNKNOWN)\n\t\t\trc = false;\n\t\tbreak;\n\tdefault:\n\t\tif (id.id == 0 || id.enum_id == ENUM_ID_UNKNOWN)\n\t\t\trc = false;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic bool dal_graphics_object_id_is_equal(\n\tstruct graphics_object_id id1,\n\tstruct graphics_object_id id2)\n{\n\tif (false == dal_graphics_object_id_is_valid(id1)) {\n\t\tdm_output_to_console(\n\t\t\"%s: Warning: comparing invalid object 'id1'!\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tif (false == dal_graphics_object_id_is_valid(id2)) {\n\t\tdm_output_to_console(\n\t\t\"%s: Warning: comparing invalid object 'id2'!\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tif (id1.id == id2.id && id1.enum_id == id2.enum_id\n\t\t&& id1.type == id2.type)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic ATOM_OBJECT *get_bios_object(struct bios_parser *bp,\n\tstruct graphics_object_id id)\n{\n\tuint32_t offset;\n\tATOM_OBJECT_TABLE *tbl;\n\tuint32_t i;\n\n\tswitch (id.type) {\n\tcase OBJECT_TYPE_ENCODER:\n\t\toffset = le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset);\n\t\tbreak;\n\n\tcase OBJECT_TYPE_CONNECTOR:\n\t\toffset = le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);\n\t\tbreak;\n\n\tcase OBJECT_TYPE_ROUTER:\n\t\toffset = le16_to_cpu(bp->object_info_tbl.v1_1->usRouterObjectTableOffset);\n\t\tbreak;\n\n\tcase OBJECT_TYPE_GENERIC:\n\t\tif (bp->object_info_tbl.revision.minor < 3)\n\t\t\treturn NULL;\n\t\toffset = le16_to_cpu(bp->object_info_tbl.v1_3->usMiscObjectTableOffset);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\toffset += bp->object_info_tbl_offset;\n\n\ttbl = ((ATOM_OBJECT_TABLE *) bios_get_image(&bp->base, offset,\n\t\t\t\tstruct_size(tbl, asObjects, 1)));\n\tif (!tbl)\n\t\treturn NULL;\n\n\tfor (i = 0; i < tbl->ucNumberOfObjects; i++)\n\t\tif (dal_graphics_object_id_is_equal(id,\n\t\t\t\tobject_id_from_bios_object_id(\n\t\t\t\t\t\tle16_to_cpu(tbl->asObjects[i].usObjectID))))\n\t\t\treturn &tbl->asObjects[i];\n\n\treturn NULL;\n}\n\nstatic uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,\n\tuint16_t **id_list)\n{\n\tuint32_t offset;\n\tuint8_t *number;\n\n\tif (!object) {\n\t\tBREAK_TO_DEBUGGER();  \n\t\treturn 0;\n\t}\n\n\toffset = le16_to_cpu(object->usSrcDstTableOffset)\n\t\t\t\t\t+ bp->object_info_tbl_offset;\n\n\tnumber = GET_IMAGE(uint8_t, offset);\n\tif (!number)\n\t\treturn 0;\n\n\toffset += sizeof(uint8_t);\n\t*id_list = (uint16_t *)bios_get_image(&bp->base, offset, *number * sizeof(uint16_t));\n\n\tif (!*id_list)\n\t\treturn 0;\n\n\treturn *number;\n}\n\nstatic struct device_id device_type_from_device_id(uint16_t device_id)\n{\n\n\tstruct device_id result_device_id = {0};\n\n\tswitch (device_id) {\n\tcase ATOM_DEVICE_LCD1_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_LCD;\n\t\tresult_device_id.enum_id = 1;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_LCD2_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_LCD;\n\t\tresult_device_id.enum_id = 2;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_CRT1_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_CRT;\n\t\tresult_device_id.enum_id = 1;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_CRT2_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_CRT;\n\t\tresult_device_id.enum_id = 2;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP1_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 1;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP2_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 2;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP3_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 3;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP4_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 4;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP5_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 5;\n\t\tbreak;\n\n\tcase ATOM_DEVICE_DFP6_SUPPORT:\n\t\tresult_device_id.device_type = DEVICE_TYPE_DFP;\n\t\tresult_device_id.enum_id = 6;\n\t\tbreak;\n\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();  \n\t\tresult_device_id.device_type = DEVICE_TYPE_UNKNOWN;\n\t\tresult_device_id.enum_id = 0;\n\t}\n\treturn result_device_id;\n}\n\nstatic void get_atom_data_table_revision(\n\tATOM_COMMON_TABLE_HEADER *atom_data_tbl,\n\tstruct atom_data_revision *tbl_revision)\n{\n\tif (!tbl_revision)\n\t\treturn;\n\n\t \n\ttbl_revision->major = 0;\n\ttbl_revision->minor = 0;\n\n\tif (!atom_data_tbl)\n\t\treturn;\n\n\ttbl_revision->major =\n\t\t\t(uint32_t) GET_DATA_TABLE_MAJOR_REVISION(atom_data_tbl);\n\ttbl_revision->minor =\n\t\t\t(uint32_t) GET_DATA_TABLE_MINOR_REVISION(atom_data_tbl);\n}\n\nstatic uint32_t signal_to_ss_id(enum as_signal_type signal)\n{\n\tuint32_t clk_id_ss = 0;\n\n\tswitch (signal) {\n\tcase AS_SIGNAL_TYPE_DVI:\n\t\tclk_id_ss = ASIC_INTERNAL_SS_ON_TMDS;\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_HDMI:\n\t\tclk_id_ss = ASIC_INTERNAL_SS_ON_HDMI;\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_LVDS:\n\t\tclk_id_ss = ASIC_INTERNAL_SS_ON_LVDS;\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_DISPLAY_PORT:\n\t\tclk_id_ss = ASIC_INTERNAL_SS_ON_DP;\n\t\tbreak;\n\tcase AS_SIGNAL_TYPE_GPU_PLL:\n\t\tclk_id_ss = ASIC_INTERNAL_GPUPLL_SS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn clk_id_ss;\n}\n\nstatic uint32_t get_support_mask_for_device_id(struct device_id device_id)\n{\n\tenum dal_device_type device_type = device_id.device_type;\n\tuint32_t enum_id = device_id.enum_id;\n\n\tswitch (device_type) {\n\tcase DEVICE_TYPE_LCD:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DEVICE_LCD1_SUPPORT;\n\t\tcase 2:\n\t\t\treturn ATOM_DEVICE_LCD2_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DEVICE_TYPE_CRT:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DEVICE_CRT1_SUPPORT;\n\t\tcase 2:\n\t\t\treturn ATOM_DEVICE_CRT2_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DEVICE_TYPE_DFP:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DEVICE_DFP1_SUPPORT;\n\t\tcase 2:\n\t\t\treturn ATOM_DEVICE_DFP2_SUPPORT;\n\t\tcase 3:\n\t\t\treturn ATOM_DEVICE_DFP3_SUPPORT;\n\t\tcase 4:\n\t\t\treturn ATOM_DEVICE_DFP4_SUPPORT;\n\t\tcase 5:\n\t\t\treturn ATOM_DEVICE_DFP5_SUPPORT;\n\t\tcase 6:\n\t\t\treturn ATOM_DEVICE_DFP6_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DEVICE_TYPE_CV:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DEVICE_CV_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DEVICE_TYPE_TV:\n\t\tswitch (enum_id) {\n\t\tcase 1:\n\t\t\treturn ATOM_DEVICE_TV1_SUPPORT;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic void bios_parser_set_scratch_critical_state(\n\tstruct dc_bios *dcb,\n\tbool state)\n{\n\tbios_set_scratch_critical_state(dcb, state);\n}\n\n \nstatic enum bp_result get_integrated_info_v8(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tATOM_INTEGRATED_SYSTEM_INFO_V1_8 *info_v8;\n\tuint32_t i;\n\n\tinfo_v8 = GET_IMAGE(ATOM_INTEGRATED_SYSTEM_INFO_V1_8,\n\t\t\tbp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);\n\n\tif (info_v8 == NULL)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\tinfo->boot_up_engine_clock = le32_to_cpu(info_v8->ulBootUpEngineClock) * 10;\n\tinfo->dentist_vco_freq = le32_to_cpu(info_v8->ulDentistVCOFreq) * 10;\n\tinfo->boot_up_uma_clock = le32_to_cpu(info_v8->ulBootUpUMAClock) * 10;\n\n\tfor (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\t \n\t\tinfo->disp_clk_voltage[i].max_supported_clk =\n\t\t\tle32_to_cpu(info_v8->sDISPCLK_Voltage[i].\n\t\t\t\t    ulMaximumSupportedCLK) * 10;\n\t\tinfo->disp_clk_voltage[i].voltage_index =\n\t\t\tle32_to_cpu(info_v8->sDISPCLK_Voltage[i].ulVoltageIndex);\n\t}\n\n\tinfo->boot_up_req_display_vector =\n\t\tle32_to_cpu(info_v8->ulBootUpReqDisplayVector);\n\tinfo->gpu_cap_info =\n\t\tle32_to_cpu(info_v8->ulGPUCapInfo);\n\n\t \n\tinfo->system_config = le32_to_cpu(info_v8->ulSystemConfig);\n\tinfo->cpu_cap_info = le32_to_cpu(info_v8->ulCPUCapInfo);\n\tinfo->boot_up_nb_voltage =\n\t\tle16_to_cpu(info_v8->usBootUpNBVoltage);\n\tinfo->ext_disp_conn_info_offset =\n\t\tle16_to_cpu(info_v8->usExtDispConnInfoOffset);\n\tinfo->memory_type = info_v8->ucMemoryType;\n\tinfo->ma_channel_number = info_v8->ucUMAChannelNumber;\n\tinfo->gmc_restore_reset_time =\n\t\tle32_to_cpu(info_v8->ulGMCRestoreResetTime);\n\n\tinfo->minimum_n_clk =\n\t\tle32_to_cpu(info_v8->ulNbpStateNClkFreq[0]);\n\tfor (i = 1; i < 4; ++i)\n\t\tinfo->minimum_n_clk =\n\t\t\tinfo->minimum_n_clk < le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]) ?\n\t\t\tinfo->minimum_n_clk : le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]);\n\n\tinfo->idle_n_clk = le32_to_cpu(info_v8->ulIdleNClk);\n\tinfo->ddr_dll_power_up_time =\n\t\tle32_to_cpu(info_v8->ulDDR_DLL_PowerUpTime);\n\tinfo->ddr_pll_power_up_time =\n\t\tle32_to_cpu(info_v8->ulDDR_PLL_PowerUpTime);\n\tinfo->pcie_clk_ss_type = le16_to_cpu(info_v8->usPCIEClkSSType);\n\tinfo->lvds_ss_percentage =\n\t\tle16_to_cpu(info_v8->usLvdsSSPercentage);\n\tinfo->lvds_sspread_rate_in_10hz =\n\t\tle16_to_cpu(info_v8->usLvdsSSpreadRateIn10Hz);\n\tinfo->hdmi_ss_percentage =\n\t\tle16_to_cpu(info_v8->usHDMISSPercentage);\n\tinfo->hdmi_sspread_rate_in_10hz =\n\t\tle16_to_cpu(info_v8->usHDMISSpreadRateIn10Hz);\n\tinfo->dvi_ss_percentage =\n\t\tle16_to_cpu(info_v8->usDVISSPercentage);\n\tinfo->dvi_sspread_rate_in_10_hz =\n\t\tle16_to_cpu(info_v8->usDVISSpreadRateIn10Hz);\n\n\tinfo->max_lvds_pclk_freq_in_single_link =\n\t\tle16_to_cpu(info_v8->usMaxLVDSPclkFreqInSingleLink);\n\tinfo->lvds_misc = info_v8->ucLvdsMisc;\n\tinfo->lvds_pwr_on_seq_dig_on_to_de_in_4ms =\n\t\tinfo_v8->ucLVDSPwrOnSeqDIGONtoDE_in4Ms;\n\tinfo->lvds_pwr_on_seq_de_to_vary_bl_in_4ms =\n\t\tinfo_v8->ucLVDSPwrOnSeqDEtoVARY_BL_in4Ms;\n\tinfo->lvds_pwr_on_seq_vary_bl_to_blon_in_4ms =\n\t\tinfo_v8->ucLVDSPwrOnSeqVARY_BLtoBLON_in4Ms;\n\tinfo->lvds_pwr_off_seq_vary_bl_to_de_in4ms =\n\t\tinfo_v8->ucLVDSPwrOffSeqVARY_BLtoDE_in4Ms;\n\tinfo->lvds_pwr_off_seq_de_to_dig_on_in4ms =\n\t\tinfo_v8->ucLVDSPwrOffSeqDEtoDIGON_in4Ms;\n\tinfo->lvds_pwr_off_seq_blon_to_vary_bl_in_4ms =\n\t\tinfo_v8->ucLVDSPwrOffSeqBLONtoVARY_BL_in4Ms;\n\tinfo->lvds_off_to_on_delay_in_4ms =\n\t\tinfo_v8->ucLVDSOffToOnDelay_in4Ms;\n\tinfo->lvds_bit_depth_control_val =\n\t\tle32_to_cpu(info_v8->ulLCDBitDepthControlVal);\n\n\tfor (i = 0; i < NUMBER_OF_AVAILABLE_SCLK; ++i) {\n\t\t \n\t\tinfo->avail_s_clk[i].supported_s_clk =\n\t\t\tle32_to_cpu(info_v8->sAvail_SCLK[i].ulSupportedSCLK) * 10;\n\t\tinfo->avail_s_clk[i].voltage_index =\n\t\t\tle16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageIndex);\n\t\tinfo->avail_s_clk[i].voltage_id =\n\t\t\tle16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageID);\n\t}\n\n\tfor (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {\n\t\tinfo->ext_disp_conn_info.gu_id[i] =\n\t\t\tinfo_v8->sExtDispConnInfo.ucGuid[i];\n\t}\n\n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {\n\t\tinfo->ext_disp_conn_info.path[i].device_connector_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\tle16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceConnector));\n\n\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\tle16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usExtEncoderObjId));\n\n\t\tinfo->ext_disp_conn_info.path[i].device_tag =\n\t\t\tle16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceTag);\n\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum =\n\t\t\tle16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);\n\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =\n\t\t\tinfo_v8->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;\n\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =\n\t\t\tinfo_v8->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;\n\t\tinfo->ext_disp_conn_info.path[i].channel_mapping.raw =\n\t\t\tinfo_v8->sExtDispConnInfo.sPath[i].ucChannelMapping;\n\t}\n\tinfo->ext_disp_conn_info.checksum =\n\t\tinfo_v8->sExtDispConnInfo.ucChecksum;\n\n\treturn BP_RESULT_OK;\n}\n\n \nstatic enum bp_result get_integrated_info_v9(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tATOM_INTEGRATED_SYSTEM_INFO_V1_9 *info_v9;\n\tuint32_t i;\n\n\tinfo_v9 = GET_IMAGE(ATOM_INTEGRATED_SYSTEM_INFO_V1_9,\n\t\t\tbp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);\n\n\tif (!info_v9)\n\t\treturn BP_RESULT_BADBIOSTABLE;\n\n\tinfo->boot_up_engine_clock = le32_to_cpu(info_v9->ulBootUpEngineClock) * 10;\n\tinfo->dentist_vco_freq = le32_to_cpu(info_v9->ulDentistVCOFreq) * 10;\n\tinfo->boot_up_uma_clock = le32_to_cpu(info_v9->ulBootUpUMAClock) * 10;\n\n\tfor (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\t \n\t\tinfo->disp_clk_voltage[i].max_supported_clk =\n\t\t\tle32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulMaximumSupportedCLK) * 10;\n\t\tinfo->disp_clk_voltage[i].voltage_index =\n\t\t\tle32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulVoltageIndex);\n\t}\n\n\tinfo->boot_up_req_display_vector =\n\t\tle32_to_cpu(info_v9->ulBootUpReqDisplayVector);\n\tinfo->gpu_cap_info = le32_to_cpu(info_v9->ulGPUCapInfo);\n\n\t \n\tinfo->system_config = le32_to_cpu(info_v9->ulSystemConfig);\n\tinfo->cpu_cap_info = le32_to_cpu(info_v9->ulCPUCapInfo);\n\tinfo->boot_up_nb_voltage = le16_to_cpu(info_v9->usBootUpNBVoltage);\n\tinfo->ext_disp_conn_info_offset = le16_to_cpu(info_v9->usExtDispConnInfoOffset);\n\tinfo->memory_type = info_v9->ucMemoryType;\n\tinfo->ma_channel_number = info_v9->ucUMAChannelNumber;\n\tinfo->gmc_restore_reset_time = le32_to_cpu(info_v9->ulGMCRestoreResetTime);\n\n\tinfo->minimum_n_clk = le32_to_cpu(info_v9->ulNbpStateNClkFreq[0]);\n\tfor (i = 1; i < 4; ++i)\n\t\tinfo->minimum_n_clk =\n\t\t\tinfo->minimum_n_clk < le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]) ?\n\t\t\tinfo->minimum_n_clk : le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]);\n\n\tinfo->idle_n_clk = le32_to_cpu(info_v9->ulIdleNClk);\n\tinfo->ddr_dll_power_up_time = le32_to_cpu(info_v9->ulDDR_DLL_PowerUpTime);\n\tinfo->ddr_pll_power_up_time = le32_to_cpu(info_v9->ulDDR_PLL_PowerUpTime);\n\tinfo->pcie_clk_ss_type = le16_to_cpu(info_v9->usPCIEClkSSType);\n\tinfo->lvds_ss_percentage = le16_to_cpu(info_v9->usLvdsSSPercentage);\n\tinfo->lvds_sspread_rate_in_10hz = le16_to_cpu(info_v9->usLvdsSSpreadRateIn10Hz);\n\tinfo->hdmi_ss_percentage = le16_to_cpu(info_v9->usHDMISSPercentage);\n\tinfo->hdmi_sspread_rate_in_10hz = le16_to_cpu(info_v9->usHDMISSpreadRateIn10Hz);\n\tinfo->dvi_ss_percentage = le16_to_cpu(info_v9->usDVISSPercentage);\n\tinfo->dvi_sspread_rate_in_10_hz = le16_to_cpu(info_v9->usDVISSpreadRateIn10Hz);\n\n\tinfo->max_lvds_pclk_freq_in_single_link =\n\t\tle16_to_cpu(info_v9->usMaxLVDSPclkFreqInSingleLink);\n\tinfo->lvds_misc = info_v9->ucLvdsMisc;\n\tinfo->lvds_pwr_on_seq_dig_on_to_de_in_4ms =\n\t\tinfo_v9->ucLVDSPwrOnSeqDIGONtoDE_in4Ms;\n\tinfo->lvds_pwr_on_seq_de_to_vary_bl_in_4ms =\n\t\tinfo_v9->ucLVDSPwrOnSeqDEtoVARY_BL_in4Ms;\n\tinfo->lvds_pwr_on_seq_vary_bl_to_blon_in_4ms =\n\t\tinfo_v9->ucLVDSPwrOnSeqVARY_BLtoBLON_in4Ms;\n\tinfo->lvds_pwr_off_seq_vary_bl_to_de_in4ms =\n\t\tinfo_v9->ucLVDSPwrOffSeqVARY_BLtoDE_in4Ms;\n\tinfo->lvds_pwr_off_seq_de_to_dig_on_in4ms =\n\t\tinfo_v9->ucLVDSPwrOffSeqDEtoDIGON_in4Ms;\n\tinfo->lvds_pwr_off_seq_blon_to_vary_bl_in_4ms =\n\t\tinfo_v9->ucLVDSPwrOffSeqBLONtoVARY_BL_in4Ms;\n\tinfo->lvds_off_to_on_delay_in_4ms =\n\t\tinfo_v9->ucLVDSOffToOnDelay_in4Ms;\n\tinfo->lvds_bit_depth_control_val =\n\t\tle32_to_cpu(info_v9->ulLCDBitDepthControlVal);\n\n\tfor (i = 0; i < NUMBER_OF_AVAILABLE_SCLK; ++i) {\n\t\t \n\t\tinfo->avail_s_clk[i].supported_s_clk =\n\t\t\tle32_to_cpu(info_v9->sAvail_SCLK[i].ulSupportedSCLK) * 10;\n\t\tinfo->avail_s_clk[i].voltage_index =\n\t\t\tle16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageIndex);\n\t\tinfo->avail_s_clk[i].voltage_id =\n\t\t\tle16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageID);\n\t}\n\n\tfor (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {\n\t\tinfo->ext_disp_conn_info.gu_id[i] =\n\t\t\tinfo_v9->sExtDispConnInfo.ucGuid[i];\n\t}\n\n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {\n\t\tinfo->ext_disp_conn_info.path[i].device_connector_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\tle16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceConnector));\n\n\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\tle16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usExtEncoderObjId));\n\n\t\tinfo->ext_disp_conn_info.path[i].device_tag =\n\t\t\tle16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceTag);\n\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum =\n\t\t\tle16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);\n\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =\n\t\t\tinfo_v9->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;\n\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =\n\t\t\tinfo_v9->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;\n\t\tinfo->ext_disp_conn_info.path[i].channel_mapping.raw =\n\t\t\tinfo_v9->sExtDispConnInfo.sPath[i].ucChannelMapping;\n\t}\n\tinfo->ext_disp_conn_info.checksum =\n\t\tinfo_v9->sExtDispConnInfo.ucChecksum;\n\n\treturn BP_RESULT_OK;\n}\n\n \nstatic enum bp_result construct_integrated_info(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tenum bp_result result = BP_RESULT_BADBIOSTABLE;\n\n\tATOM_COMMON_TABLE_HEADER *header;\n\tstruct atom_data_revision revision;\n\n\tif (bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo) {\n\t\theader = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,\n\t\t\t\tbp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);\n\n\t\tget_atom_data_table_revision(header, &revision);\n\n\t\t \n\t\tswitch (revision.minor) {\n\t\tcase 8:\n\t\t\tresult = get_integrated_info_v8(bp, info);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tresult = get_integrated_info_v9(bp, info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn result;\n\n\t\t}\n\t}\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tuint32_t i;\n\t\tuint32_t j;\n\n\t\tfor (i = 1; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\t\tfor (j = i; j > 0; --j) {\n\t\t\t\tif (\n\t\t\t\t\t\tinfo->disp_clk_voltage[j].max_supported_clk <\n\t\t\t\t\t\tinfo->disp_clk_voltage[j-1].max_supported_clk) {\n\t\t\t\t\t \n\t\t\t\t\tswap(info->disp_clk_voltage[j - 1],\n\t\t\t\t\t     info->disp_clk_voltage[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn result;\n}\n\nstatic struct integrated_info *bios_parser_create_integrated_info(\n\tstruct dc_bios *dcb)\n{\n\tstruct bios_parser *bp = BP_FROM_DCB(dcb);\n\tstruct integrated_info *info;\n\n\tinfo = kzalloc(sizeof(struct integrated_info), GFP_KERNEL);\n\n\tif (info == NULL) {\n\t\tASSERT_CRITICAL(0);\n\t\treturn NULL;\n\t}\n\n\tif (construct_integrated_info(bp, info) == BP_RESULT_OK)\n\t\treturn info;\n\n\tkfree(info);\n\n\treturn NULL;\n}\n\nstatic enum bp_result update_slot_layout_info(struct dc_bios *dcb,\n\t\t\t\t\t      unsigned int i,\n\t\t\t\t\t      struct slot_layout_info *slot_layout_info,\n\t\t\t\t\t      unsigned int record_offset)\n{\n\tunsigned int j;\n\tstruct bios_parser *bp;\n\tATOM_BRACKET_LAYOUT_RECORD *record;\n\tATOM_COMMON_RECORD_HEADER *record_header;\n\tenum bp_result result = BP_RESULT_NORECORD;\n\n\tbp = BP_FROM_DCB(dcb);\n\trecord = NULL;\n\trecord_header = NULL;\n\n\tfor (;;) {\n\n\t\trecord_header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, record_offset);\n\t\tif (record_header == NULL) {\n\t\t\tresult = BP_RESULT_BADBIOSTABLE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (record_header->ucRecordType == 0xff ||\n\t\t\trecord_header->ucRecordSize == 0)\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record_header->ucRecordType ==\n\t\t\tATOM_BRACKET_LAYOUT_RECORD_TYPE &&\n\t\t\tstruct_size(record, asConnInfo, 1)\n\t\t\t<= record_header->ucRecordSize) {\n\t\t\trecord = (ATOM_BRACKET_LAYOUT_RECORD *)\n\t\t\t\t(record_header);\n\t\t\tresult = BP_RESULT_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\trecord_offset += record_header->ucRecordSize;\n\t}\n\n\t \n\tif (result != BP_RESULT_OK)\n\t\treturn result;\n\n\t \n\tslot_layout_info->length = record->ucLength;\n\tslot_layout_info->width = record->ucWidth;\n\n\t \n\tslot_layout_info->num_of_connectors = record->ucConnNum;\n\tfor (j = 0; j < slot_layout_info->num_of_connectors; ++j) {\n\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t(enum connector_layout_type)\n\t\t\t(record->asConnInfo[j].ucConnectorType);\n\t\tswitch (record->asConnInfo[j].ucConnectorType) {\n\t\tcase CONNECTOR_TYPE_DVI_D:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_DVI_D;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_DVI;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_HDMI:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_HDMI;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_HDMI;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_DISPLAY_PORT:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_DP;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_DP;\n\t\t\tbreak;\n\n\t\tcase CONNECTOR_TYPE_MINI_DISPLAY_PORT:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_MINI_DP;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_MINI_DP;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tslot_layout_info->connectors[j].connector_type =\n\t\t\t\tCONNECTOR_LAYOUT_TYPE_UNKNOWN;\n\t\t\tslot_layout_info->connectors[j].length =\n\t\t\t\tCONNECTOR_SIZE_UNKNOWN;\n\t\t}\n\n\t\tslot_layout_info->connectors[j].position =\n\t\t\trecord->asConnInfo[j].ucPosition;\n\t\tslot_layout_info->connectors[j].connector_id =\n\t\t\tobject_id_from_bios_object_id(\n\t\t\t\trecord->asConnInfo[j].usConnectorObjectId);\n\t}\n\treturn result;\n}\n\n\nstatic enum bp_result get_bracket_layout_record(struct dc_bios *dcb,\n\t\t\t\t\t\tunsigned int bracket_layout_id,\n\t\t\t\t\t\tstruct slot_layout_info *slot_layout_info)\n{\n\tunsigned int i;\n\tunsigned int record_offset;\n\tstruct bios_parser *bp;\n\tenum bp_result result;\n\tATOM_OBJECT *object;\n\tATOM_OBJECT_TABLE *object_table;\n\tunsigned int genericTableOffset;\n\n\tbp = BP_FROM_DCB(dcb);\n\tobject = NULL;\n\tif (slot_layout_info == NULL) {\n\t\tDC_LOG_DETECTION_EDID_PARSER(\"Invalid slot_layout_info\\n\");\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\n\tgenericTableOffset = bp->object_info_tbl_offset +\n\t\tbp->object_info_tbl.v1_3->usMiscObjectTableOffset;\n\tobject_table = ((ATOM_OBJECT_TABLE *) bios_get_image(&bp->base,\n\t\t\t\tgenericTableOffset,\n\t\t\t\tstruct_size(object_table, asObjects, 1)));\n\tif (!object_table)\n\t\treturn BP_RESULT_FAILURE;\n\n\tresult = BP_RESULT_NORECORD;\n\tfor (i = 0; i < object_table->ucNumberOfObjects; ++i) {\n\n\t\tif (bracket_layout_id ==\n\t\t\tobject_table->asObjects[i].usObjectID) {\n\n\t\t\tobject = &object_table->asObjects[i];\n\t\t\trecord_offset = object->usRecordOffset +\n\t\t\t\tbp->object_info_tbl_offset;\n\n\t\t\tresult = update_slot_layout_info(dcb, i,\n\t\t\t\tslot_layout_info, record_offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic enum bp_result bios_get_board_layout_info(\n\tstruct dc_bios *dcb,\n\tstruct board_layout_info *board_layout_info)\n{\n\tunsigned int i;\n\tenum bp_result record_result;\n\n\tconst unsigned int slot_index_to_vbios_id[MAX_BOARD_SLOTS] = {\n\t\tGENERICOBJECT_BRACKET_LAYOUT_ENUM_ID1,\n\t\tGENERICOBJECT_BRACKET_LAYOUT_ENUM_ID2,\n\t\t0, 0\n\t};\n\n\tif (board_layout_info == NULL) {\n\t\tDC_LOG_DETECTION_EDID_PARSER(\"Invalid board_layout_info\\n\");\n\t\treturn BP_RESULT_BADINPUT;\n\t}\n\n\tboard_layout_info->num_of_slots = 0;\n\n\tfor (i = 0; i < MAX_BOARD_SLOTS; ++i) {\n\t\trecord_result = get_bracket_layout_record(dcb,\n\t\t\tslot_index_to_vbios_id[i],\n\t\t\t&board_layout_info->slots[i]);\n\n\t\tif (record_result == BP_RESULT_NORECORD && i > 0)\n\t\t\tbreak;  \n\t\telse if (record_result != BP_RESULT_OK)\n\t\t\treturn record_result;   \n\n\t\t++board_layout_info->num_of_slots;\n\t}\n\n\t \n\tboard_layout_info->is_number_of_slots_valid = 1;\n\tboard_layout_info->is_slots_size_valid = 1;\n\tboard_layout_info->is_connector_offsets_valid = 1;\n\tboard_layout_info->is_connector_lengths_valid = 1;\n\n\treturn BP_RESULT_OK;\n}\n\n \n\nstatic const struct dc_vbios_funcs vbios_funcs = {\n\t.get_connectors_number = bios_parser_get_connectors_number,\n\n\t.get_connector_id = bios_parser_get_connector_id,\n\n\t.get_src_obj = bios_parser_get_src_obj,\n\n\t.get_i2c_info = bios_parser_get_i2c_info,\n\n\t.get_hpd_info = bios_parser_get_hpd_info,\n\n\t.get_device_tag = bios_parser_get_device_tag,\n\n\t.get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,\n\n\t.get_ss_entry_number = bios_parser_get_ss_entry_number,\n\n\t.get_embedded_panel_info = bios_parser_get_embedded_panel_info,\n\n\t.get_gpio_pin_info = bios_parser_get_gpio_pin_info,\n\n\t.get_encoder_cap_info = bios_parser_get_encoder_cap_info,\n\n\t \n\t.is_accelerated_mode = bios_is_accelerated_mode,\n\n\t.set_scratch_critical_state = bios_parser_set_scratch_critical_state,\n\n\t.is_device_id_supported = bios_parser_is_device_id_supported,\n\n\t \n\t.encoder_control = bios_parser_encoder_control,\n\n\t.transmitter_control = bios_parser_transmitter_control,\n\n\t.enable_crtc = bios_parser_enable_crtc,\n\n\t.adjust_pixel_clock = bios_parser_adjust_pixel_clock,\n\n\t.set_pixel_clock = bios_parser_set_pixel_clock,\n\n\t.set_dce_clock = bios_parser_set_dce_clock,\n\n\t.enable_spread_spectrum_on_ppll = bios_parser_enable_spread_spectrum_on_ppll,\n\n\t.program_crtc_timing = bios_parser_program_crtc_timing,  \n\n\t.program_display_engine_pll = bios_parser_program_display_engine_pll,\n\n\t.enable_disp_power_gating = bios_parser_enable_disp_power_gating,\n\n\t \n\n\t.bios_parser_destroy = bios_parser_destroy,\n\n\t.get_board_layout_info = bios_get_board_layout_info,\n\n\t.get_atom_dc_golden_table = NULL\n};\n\nstatic bool bios_parser_construct(\n\tstruct bios_parser *bp,\n\tstruct bp_init_data *init,\n\tenum dce_version dce_version)\n{\n\tuint16_t *rom_header_offset = NULL;\n\tATOM_ROM_HEADER *rom_header = NULL;\n\tATOM_OBJECT_HEADER *object_info_tbl;\n\tstruct atom_data_revision tbl_rev = {0};\n\n\tif (!init)\n\t\treturn false;\n\n\tif (!init->bios)\n\t\treturn false;\n\n\tbp->base.funcs = &vbios_funcs;\n\tbp->base.bios = init->bios;\n\tbp->base.bios_size = bp->base.bios[BIOS_IMAGE_SIZE_OFFSET] * BIOS_IMAGE_SIZE_UNIT;\n\n\tbp->base.ctx = init->ctx;\n\tbp->base.bios_local_image = NULL;\n\n\trom_header_offset =\n\tGET_IMAGE(uint16_t, OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER);\n\n\tif (!rom_header_offset)\n\t\treturn false;\n\n\trom_header = GET_IMAGE(ATOM_ROM_HEADER, *rom_header_offset);\n\n\tif (!rom_header)\n\t\treturn false;\n\n\tget_atom_data_table_revision(&rom_header->sHeader, &tbl_rev);\n\tif (tbl_rev.major >= 2 && tbl_rev.minor >= 2)\n\t\treturn false;\n\n\tbp->master_data_tbl =\n\tGET_IMAGE(ATOM_MASTER_DATA_TABLE,\n\t\trom_header->usMasterDataTableOffset);\n\n\tif (!bp->master_data_tbl)\n\t\treturn false;\n\n\tbp->object_info_tbl_offset = DATA_TABLES(Object_Header);\n\n\tif (!bp->object_info_tbl_offset)\n\t\treturn false;\n\n\tobject_info_tbl =\n\tGET_IMAGE(ATOM_OBJECT_HEADER, bp->object_info_tbl_offset);\n\n\tif (!object_info_tbl)\n\t\treturn false;\n\n\tget_atom_data_table_revision(&object_info_tbl->sHeader,\n\t\t&bp->object_info_tbl.revision);\n\n\tif (bp->object_info_tbl.revision.major == 1\n\t\t&& bp->object_info_tbl.revision.minor >= 3) {\n\t\tATOM_OBJECT_HEADER_V3 *tbl_v3;\n\n\t\ttbl_v3 = GET_IMAGE(ATOM_OBJECT_HEADER_V3,\n\t\t\tbp->object_info_tbl_offset);\n\t\tif (!tbl_v3)\n\t\t\treturn false;\n\n\t\tbp->object_info_tbl.v1_3 = tbl_v3;\n\t} else if (bp->object_info_tbl.revision.major == 1\n\t\t&& bp->object_info_tbl.revision.minor >= 1)\n\t\tbp->object_info_tbl.v1_1 = object_info_tbl;\n\telse\n\t\treturn false;\n\n\tdal_bios_parser_init_cmd_tbl(bp);\n\tdal_bios_parser_init_cmd_tbl_helper(&bp->cmd_helper, dce_version);\n\n\tbp->base.integrated_info = bios_parser_create_integrated_info(&bp->base);\n\tbp->base.fw_info_valid = bios_parser_get_firmware_info(&bp->base, &bp->base.fw_info) == BP_RESULT_OK;\n\n\treturn true;\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}