{
  "module_name": "display_mode_vba_31.c",
  "hash_id": "01403f1e2911719e86b8d1d0e00719b36d67017ca374517906eaf0309dbfc73e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn31/display_mode_vba_31.c",
  "human_readable_source": " \n\n#include \"dc.h\"\n#include \"../display_mode_lib.h\"\n#include \"../dcn30/display_mode_vba_30.h\"\n#include \"display_mode_vba_31.h\"\n#include \"../dml_inline_defs.h\"\n\n \n\n#define BPP_INVALID 0\n#define BPP_BLENDED_PIPE 0xffffffff\n#define DCN31_MAX_DSC_IMAGE_WIDTH 5184\n#define DCN31_MAX_FMT_420_BUFFER_WIDTH 4096\n#define DCN3_15_MIN_COMPBUF_SIZE_KB 128\n#define DCN3_15_MAX_DET_SIZE 384\n\n \n\n\n\n\n\n#define __DML_VBA_MIN_VSTARTUP__    9\n\n\n#define __DML_ARB_TO_RET_DELAY__    (7 + 95)\n\n\n#define __DML_MIN_DCFCLK_FACTOR__   1.15\n\ntypedef struct {\n\tdouble DPPCLK;\n\tdouble DISPCLK;\n\tdouble PixelClock;\n\tdouble DCFCLKDeepSleep;\n\tunsigned int DPPPerPlane;\n\tbool ScalerEnabled;\n\tdouble VRatio;\n\tdouble VRatioChroma;\n\tenum scan_direction_class SourceScan;\n\tunsigned int BlockWidth256BytesY;\n\tunsigned int BlockHeight256BytesY;\n\tunsigned int BlockWidth256BytesC;\n\tunsigned int BlockHeight256BytesC;\n\tunsigned int InterlaceEnable;\n\tunsigned int NumberOfCursors;\n\tunsigned int VBlank;\n\tunsigned int HTotal;\n\tunsigned int DCCEnable;\n\tbool ODMCombineIsEnabled;\n\tenum source_format_class SourcePixelFormat;\n\tint BytePerPixelY;\n\tint BytePerPixelC;\n\tbool ProgressiveToInterlaceUnitInOPP;\n} Pipe;\n\n#define BPP_INVALID 0\n#define BPP_BLENDED_PIPE 0xffffffff\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib);\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(struct display_mode_lib *mode_lib);\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble BPP,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output);\nstatic unsigned int dscComputeDelay(enum output_format_class pixelFormat, enum output_encoder_class Output);\nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotalPlusCNVCFormater,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int DPP_RECOUT_WIDTH,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tdouble HostVMMinPageSize,\n\t\tbool DynamicMetadataEnable,\n\t\tbool DynamicMetadataVMEnabled,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tunsigned int SwathWidthC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tint swath_width_luma_ub,\n\t\tint swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tbool *NotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tdouble *Tdmdl_vm,\n\t\tdouble *Tdmdl,\n\t\tdouble *TSetup,\n\t\tint *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix);\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed);\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed);\nstatic void CalculateDCCConfiguration(\n\t\tbool DCCEnabled,\n\t\tbool DCCProgrammingAssumesScanDirectionUnknown,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceWidthLuma,\n\t\tunsigned int SurfaceWidthChroma,\n\t\tunsigned int SurfaceHeightLuma,\n\t\tunsigned int SurfaceHeightChroma,\n\t\tdouble DETBufferSize,\n\t\tunsigned int RequestHeight256ByteLuma,\n\t\tunsigned int RequestHeight256ByteChroma,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int BytePerPixelY,\n\t\tunsigned int BytePerPixelC,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble BytePerPixelDETC,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int *MaxUncompressedBlockLuma,\n\t\tunsigned int *MaxUncompressedBlockChroma,\n\t\tunsigned int *MaxCompressedBlockLuma,\n\t\tunsigned int *MaxCompressedBlockChroma,\n\t\tunsigned int *IndependentBlockLuma,\n\t\tunsigned int *IndependentBlockChroma);\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath);\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMinPageSize,\n\t\tunsigned int HostVMMinPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tint *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tint *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tint *DPDE0BytesFrame,\n\t\tint *MetaPTEBytesFrame);\nstatic double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime);\nstatic void CalculateRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw);\n\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int k,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow);\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackVTaps,\n\t\tint WritebackDestinationWidth,\n\t\tint WritebackDestinationHeight,\n\t\tint WritebackSourceHeight,\n\t\tunsigned int HTotal);\n\nstatic void CalculateVupdateAndDynamicMetadataParameters(\n\t\tint MaxInterDCNTileRepeaters,\n\t\tdouble DPPCLK,\n\t\tdouble DISPCLK,\n\t\tdouble DCFClkDeepSleep,\n\t\tdouble PixelClock,\n\t\tint HTotal,\n\t\tint VBlank,\n\t\tint DynamicMetadataTransmittedBytes,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tint InterlaceEnable,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *TSetup,\n\t\tdouble *Tdmbf,\n\t\tdouble *Tdmec,\n\t\tdouble *Tdmsks,\n\t\tint *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix);\n\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble SOCCLK,\n\t\tdouble DCFCLKDeepSleep,\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tbool UnboundedRequestEnabled,\n\t\tint unsigned CompressedBufferSizeInkByte,\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *Z8StutterExitWatermark,\n\t\tdouble *Z8StutterEnterPlusExitWatermark);\n\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tint ReturnBusWidth,\n\t\tdouble *DCFCLKDeepSleep);\n\nstatic void CalculateUrgentBurstFactor(\n\t\tint swath_width_luma_ub,\n\t\tint swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble DETBufferSizeY,\n\t\tdouble DETBufferSizeC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tbool *NotEnoughUrgentLatencyHiding);\n\nstatic void UseMinimumDCFCLK(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tint MaxPrefetchMode,\n\t\tint ReorderingBytes);\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int NumberOfCursors[],\n\t\tunsigned int CursorWidth[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int CursorBPP[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int BlockWidth256BytesY[],\n\t\tunsigned int BlockHeight256BytesY[],\n\t\tunsigned int BlockWidth256BytesC[],\n\t\tunsigned int BlockHeight256BytesC[],\n\t\tdouble DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[],\n\t\tdouble CursorRequestDeliveryTime[],\n\t\tdouble CursorRequestDeliveryTimePrefetch[]);\n\nstatic void CalculateMetaAndPTETimes(\n\t\tint NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tint MetaChunkSize,\n\t\tint MinMetaChunkSizeBytes,\n\t\tint HTotal[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble DestinationLinesToRequestRowInVBlank[],\n\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint dpte_row_height[],\n\t\tint dpte_row_height_chroma[],\n\t\tint meta_row_width[],\n\t\tint meta_row_width_chroma[],\n\t\tint meta_row_height[],\n\t\tint meta_row_height_chroma[],\n\t\tint meta_req_width[],\n\t\tint meta_req_width_chroma[],\n\t\tint meta_req_height[],\n\t\tint meta_req_height_chroma[],\n\t\tint dpte_group_bytes[],\n\t\tint PTERequestSizeY[],\n\t\tint PTERequestSizeC[],\n\t\tint PixelPTEReqWidthY[],\n\t\tint PixelPTEReqHeightY[],\n\t\tint PixelPTEReqWidthC[],\n\t\tint PixelPTEReqHeightC[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_C[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerChromaMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerChromaMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble TimePerChromaMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[]);\n\nstatic void CalculateVMGroupAndRequestTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int HTotal[],\n\t\tint BytePerPixelC[],\n\t\tdouble DestinationLinesToRequestVMInVBlank[],\n\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tint vm_group_bytes[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tint meta_pte_bytes_per_frame_ub_l[],\n\t\tint meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble TimePerVMGroupVBlank[],\n\t\tdouble TimePerVMGroupFlip[],\n\t\tdouble TimePerVMRequestVBlank[],\n\t\tdouble TimePerVMRequestFlip[]);\n\nstatic void CalculateStutterEfficiency(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tint CompressedBufferSizeInkByte,\n\t\tbool UnboundedRequestEnabled,\n\t\tint ConfigReturnBufferSizeInKByte,\n\t\tint MetaFIFOSizeInKEntries,\n\t\tint ZeroSizeBufferEntries,\n\t\tint NumberOfActivePlanes,\n\t\tint ROBBufferSizeInKByte,\n\t\tdouble TotalDataReadBandwidth,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble COMPBUF_RESERVED_SPACE_64B,\n\t\tdouble COMPBUF_RESERVED_SPACE_ZS,\n\t\tdouble SRExitTime,\n\t\tdouble SRExitZ8Time,\n\t\tbool SynchronizedVBlank,\n\t\tdouble Z8StutterEnterPlusExitWatermark,\n\t\tdouble StutterEnterPlusExitWatermark,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tbool Interlace[],\n\t\tdouble MinTTUVBlank[],\n\t\tint DPPPerPlane[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tint BytePerPixelY[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble SwathWidthY[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tdouble NetDCCRateLuma[],\n\t\tdouble NetDCCRateChroma[],\n\t\tdouble DCCFractionOfZeroSizeRequestsLuma[],\n\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],\n\t\tint HTotal[],\n\t\tint VTotal[],\n\t\tdouble PixelClock[],\n\t\tdouble VRatio[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint BlockHeight256BytesY[],\n\t\tint BlockWidth256BytesY[],\n\t\tint BlockHeight256BytesC[],\n\t\tint BlockWidth256BytesC[],\n\t\tint DCCYMaxUncompressedBlock[],\n\t\tint DCCCMaxUncompressedBlock[],\n\t\tint VActive[],\n\t\tbool DCCEnable[],\n\t\tbool WritebackEnable[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tdouble meta_row_bw[],\n\t\tdouble dpte_row_bw[],\n\t\tdouble *StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *StutterEfficiency,\n\t\tint *NumberOfStutterBurstsPerFrame,\n\t\tdouble *Z8StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *Z8StutterEfficiency,\n\t\tint *Z8NumberOfStutterBurstsPerFrame,\n\t\tdouble *StutterPeriod);\n\nstatic void CalculateSwathAndDETConfiguration(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tbool DETSharedByAllDPP,\n\t\tunsigned int DETBufferSizeInKByte[],\n\t\tdouble MaximumSwathWidthLuma[],\n\t\tdouble MaximumSwathWidthChroma[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum dm_swizzle_mode SurfaceTiling[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BlendingAndTiming[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tdouble BytePerPixDETY[],\n\t\tdouble BytePerPixDETC[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tint DPPPerPlane[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[],\n\t\tdouble SwathWidth[],\n\t\tdouble SwathWidthChroma[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tbool ViewportSizeSupportPerPlane[],\n\t\tbool *ViewportSizeSupport);\nstatic void CalculateSwathWidth(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tint BlendingAndTiming[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tint DPPPerPlane[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tdouble SwathWidthSingleDPPC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tint MaximumSwathHeightY[],\n\t\tint MaximumSwathHeightC[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[]);\n\nstatic double CalculateExtraLatency(\n\t\tint RoundTripPingLatencyCycles,\n\t\tint ReorderingBytes,\n\t\tdouble DCFCLK,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels);\n\nstatic double CalculateExtraLatencyBytes(\n\t\tint ReorderingBytes,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels);\n\nstatic double CalculateUrgentLatency(\n\t\tdouble UrgentLatencyPixelDataOnly,\n\t\tdouble UrgentLatencyPixelMixedWithVMData,\n\t\tdouble UrgentLatencyVMDataOnly,\n\t\tbool DoUrgentLatencyAdjustment,\n\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,\n\t\tdouble UrgentLatencyAdjustmentFabricClockReference,\n\t\tdouble FabricClockSingle);\n\nstatic void CalculateUnboundedRequestAndCompressedBufferSize(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tint ConfigReturnBufferSizeInKByte,\n\t\tenum unbounded_requesting_policy UseUnboundedRequestingFinal,\n\t\tint TotalActiveDPP,\n\t\tbool NoChromaPlanes,\n\t\tint MaxNumDPP,\n\t\tint CompressedBufferSegmentSizeInkByteFinal,\n\t\tenum output_encoder_class *Output,\n\t\tbool *UnboundedRequestEnabled,\n\t\tint *CompressedBufferSizeInkByte);\n\nstatic bool UnboundedRequest(enum unbounded_requesting_policy UseUnboundedRequestingFinal, int TotalNumberOfActiveDPP, bool NoChroma, enum output_encoder_class Output);\n\nvoid dml31_recalculate(struct display_mode_lib *mode_lib)\n{\n\tModeSupportAndSystemConfiguration(mode_lib);\n\tPixelClockAdjustmentForProgressiveToInterlaceUnit(mode_lib);\n\tDisplayPipeConfiguration(mode_lib);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: Calling DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation\\n\", __func__);\n#endif\n\tDISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(mode_lib);\n}\n\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble BPP,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output)\n{\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tunsigned int rcModelSize = 8192;\n\n\t\n\tunsigned int pixelsPerClock = 0, lstall, D, initalXmitDelay, w, s, ix, wx, P, l0, a, ax, L, Delay, pixels;\n\n\tif (pixelFormat == dm_420)\n\t\tpixelsPerClock = 2;\n\telse if (pixelFormat == dm_444)\n\t\tpixelsPerClock = 1;\n\telse if (pixelFormat == dm_n422)\n\t\tpixelsPerClock = 2;\n\t\n\telse\n\t\tpixelsPerClock = 1;\n\n\t\n\tinitalXmitDelay = dml_round(rcModelSize / 2.0 / BPP / pixelsPerClock);\n\n\t\n\tif (bpc == 8)\n\t\tD = 81;\n\telse if (bpc == 10)\n\t\tD = 89;\n\telse\n\t\tD = 113;\n\n\t\n\tw = sliceWidth / pixelsPerClock;\n\n\t\n\tif (pixelFormat == dm_420 || pixelFormat == dm_444 || pixelFormat == dm_n422)\n\t\ts = 0;\n\telse\n\t\ts = 1;\n\n\t\n\tix = initalXmitDelay + 45;\n\twx = (w + 2) / 3;\n\tP = 3 * wx - w;\n\tl0 = ix / w;\n\ta = ix + P * l0;\n\tax = (a + 2) / 3 + D + 6 + 1;\n\tL = (ax + wx - 1) / wx;\n\tif ((ix % w) == 0 && P != 0)\n\t\tlstall = 1;\n\telse\n\t\tlstall = 0;\n\tDelay = L * wx * (numSlices - 1) + ax + s + lstall + 22;\n\n\t\n\tpixels = Delay * 3 * pixelsPerClock;\n\treturn pixels;\n}\n\nstatic unsigned int dscComputeDelay(enum output_format_class pixelFormat, enum output_encoder_class Output)\n{\n\tunsigned int Delay = 0;\n\n\tif (pixelFormat == dm_420) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 13;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else if (pixelFormat == dm_n422) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 5;\n\t\t\n\t\tDelay = Delay + 25;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 10;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t}\n\n\treturn Delay;\n}\n\nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotalPlusCNVCFormater,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int DPP_RECOUT_WIDTH,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tdouble HostVMMinPageSize,\n\t\tbool DynamicMetadataEnable,\n\t\tbool DynamicMetadataVMEnabled,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tunsigned int SwathWidthC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tint swath_width_luma_ub,\n\t\tint swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tbool *NotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tdouble *Tdmdl_vm,\n\t\tdouble *Tdmdl,\n\t\tdouble *TSetup,\n\t\tint *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix)\n{\n\tbool MyError = false;\n\tunsigned int DPPCycles, DISPCLKCycles;\n\tdouble DSTTotalPixelsAfterScaler;\n\tdouble LineTime;\n\tdouble dst_y_prefetch_equ;\n#ifdef __DML_VBA_DEBUG__\n\tdouble Tsw_oto;\n#endif\n\tdouble prefetch_bw_oto;\n\tdouble prefetch_bw_pr;\n\tdouble Tvm_oto;\n\tdouble Tr0_oto;\n\tdouble Tvm_oto_lines;\n\tdouble Tr0_oto_lines;\n\tdouble dst_y_prefetch_oto;\n\tdouble TimeForFetchingMetaPTE = 0;\n\tdouble TimeForFetchingRowInVBlank = 0;\n\tdouble LinesToRequestPrefetchPixelData = 0;\n\tunsigned int HostVMDynamicLevelsTrips;\n\tdouble trip_to_mem;\n\tdouble Tvm_trips;\n\tdouble Tr0_trips;\n\tdouble Tvm_trips_rounded;\n\tdouble Tr0_trips_rounded;\n\tdouble Lsw_oto;\n\tdouble Tpre_rounded;\n\tdouble prefetch_bw_equ;\n\tdouble Tvm_equ;\n\tdouble Tr0_equ;\n\tdouble Tdmbf;\n\tdouble Tdmec;\n\tdouble Tdmsks;\n\tdouble prefetch_sw_bytes;\n\tdouble bytes_pp;\n\tdouble dep_bytes;\n\tint max_vratio_pre = 4;\n\tdouble min_Lsw;\n\tdouble Tsw_est1 = 0;\n\tdouble Tsw_est3 = 0;\n\tdouble  max_Tsw = 0;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tHostVMDynamicLevelsTrips = HostVMMaxNonCachedPageTableLevels;\n\t} else {\n\t\tHostVMDynamicLevelsTrips = 0;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: GPUVMEnable=%d HostVMEnable=%d HostVMInefficiencyFactor=%f\\n\", __func__, GPUVMEnable, HostVMEnable, HostVMInefficiencyFactor);\n#endif\n\tCalculateVupdateAndDynamicMetadataParameters(\n\t\t\tMaxInterDCNTileRepeaters,\n\t\t\tmyPipe->DPPCLK,\n\t\t\tmyPipe->DISPCLK,\n\t\t\tmyPipe->DCFCLKDeepSleep,\n\t\t\tmyPipe->PixelClock,\n\t\t\tmyPipe->HTotal,\n\t\t\tmyPipe->VBlank,\n\t\t\tDynamicMetadataTransmittedBytes,\n\t\t\tDynamicMetadataLinesBeforeActiveRequired,\n\t\t\tmyPipe->InterlaceEnable,\n\t\t\tmyPipe->ProgressiveToInterlaceUnitInOPP,\n\t\t\tTSetup,\n\t\t\t&Tdmbf,\n\t\t\t&Tdmec,\n\t\t\t&Tdmsks,\n\t\t\tVUpdateOffsetPix,\n\t\t\tVUpdateWidthPix,\n\t\t\tVReadyOffsetPix);\n\n\tLineTime = myPipe->HTotal / myPipe->PixelClock;\n\ttrip_to_mem = UrgentLatency;\n\tTvm_trips = UrgentExtraLatency + trip_to_mem * (GPUVMPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1);\n\n#ifdef __DML_VBA_ALLOW_DELTA__\n\tif (DynamicMetadataVMEnabled == true && GPUVMEnable == true) {\n#else\n\tif (DynamicMetadataVMEnabled == true) {\n#endif\n\t\t*Tdmdl = TWait + Tvm_trips + trip_to_mem;\n\t} else {\n\t\t*Tdmdl = TWait + UrgentExtraLatency;\n\t}\n\n#ifdef __DML_VBA_ALLOW_DELTA__\n\tif (DynamicMetadataEnable == false) {\n\t\t*Tdmdl = 0.0;\n\t}\n#endif\n\n\tif (DynamicMetadataEnable == true) {\n\t\tif (VStartup * LineTime < *TSetup + *Tdmdl + Tdmbf + Tdmec + Tdmsks) {\n\t\t\t*NotEnoughTimeForDynamicMetadata = true;\n\t\t\tdml_print(\"DML::%s: Not Enough Time for Dynamic Meta!\\n\", __func__);\n\t\t\tdml_print(\"DML::%s: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\", __func__, Tdmbf);\n\t\t\tdml_print(\"DML::%s: Tdmec: %fus - time dio takes to transfer dmd\\n\", __func__, Tdmec);\n\t\t\tdml_print(\"DML::%s: Tdmsks: %fus - time before active dmd must complete transmission at dio\\n\", __func__, Tdmsks);\n\t\t\tdml_print(\"DML::%s: Tdmdl: %fus - time for fabric to become ready and fetch dmd \\n\", __func__, *Tdmdl);\n\t\t} else {\n\t\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t\t}\n\t} else {\n\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t}\n\n\t*Tdmdl_vm = (DynamicMetadataEnable == true && DynamicMetadataVMEnabled == true && GPUVMEnable == true ? TWait + Tvm_trips : 0);\n\n\tif (myPipe->ScalerEnabled)\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + DPPCLKDelaySCL;\n\telse\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + DPPCLKDelaySCLLBOnly;\n\n\tDPPCycles = DPPCycles + myPipe->NumberOfCursors * DPPCLKDelayCNVCCursor;\n\n\tDISPCLKCycles = DISPCLKDelaySubtotal;\n\n\tif (myPipe->DPPCLK == 0.0 || myPipe->DISPCLK == 0.0)\n\t\treturn true;\n\n\t*DSTXAfterScaler = DPPCycles * myPipe->PixelClock / myPipe->DPPCLK + DISPCLKCycles * myPipe->PixelClock / myPipe->DISPCLK + DSCDelay;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DPPCycles: %d\\n\", __func__, DPPCycles);\n\tdml_print(\"DML::%s: PixelClock: %f\\n\", __func__, myPipe->PixelClock);\n\tdml_print(\"DML::%s: DPPCLK: %f\\n\", __func__, myPipe->DPPCLK);\n\tdml_print(\"DML::%s: DISPCLKCycles: %d\\n\", __func__, DISPCLKCycles);\n\tdml_print(\"DML::%s: DISPCLK: %f\\n\", __func__, myPipe->DISPCLK);\n\tdml_print(\"DML::%s: DSCDelay: %d\\n\", __func__, DSCDelay);\n\tdml_print(\"DML::%s: DSTXAfterScaler: %d\\n\", __func__, *DSTXAfterScaler);\n\tdml_print(\"DML::%s: ODMCombineIsEnabled: %d\\n\", __func__, myPipe->ODMCombineIsEnabled);\n#endif\n\n\t*DSTXAfterScaler = *DSTXAfterScaler + ((myPipe->ODMCombineIsEnabled) ? 18 : 0) + (myPipe->DPPPerPlane - 1) * DPP_RECOUT_WIDTH;\n\n\tif (OutputFormat == dm_420 || (myPipe->InterlaceEnable && myPipe->ProgressiveToInterlaceUnitInOPP))\n\t\t*DSTYAfterScaler = 1;\n\telse\n\t\t*DSTYAfterScaler = 0;\n\n\tDSTTotalPixelsAfterScaler = *DSTYAfterScaler * myPipe->HTotal + *DSTXAfterScaler;\n\t*DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / myPipe->HTotal, 1);\n\t*DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * myPipe->HTotal));\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DSTXAfterScaler: %d (final)\\n\", __func__, *DSTXAfterScaler);\n#endif\n\n\tMyError = false;\n\n\tTr0_trips = trip_to_mem * (HostVMDynamicLevelsTrips + 1);\n\tTvm_trips_rounded = dml_ceil(4.0 * Tvm_trips / LineTime, 1) / 4 * LineTime;\n\tTr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1) / 4 * LineTime;\n\n#ifdef __DML_VBA_ALLOW_DELTA__\n\tif (!myPipe->DCCEnable) {\n\t\tTr0_trips = 0.0;\n\t\tTr0_trips_rounded = 0.0;\n\t}\n#endif\n\n\tif (!GPUVMEnable) {\n\t\tTvm_trips = 0.0;\n\t\tTvm_trips_rounded = 0.0;\n\t}\n\n\tif (GPUVMEnable) {\n\t\tif (GPUVMPageTableLevels >= 3) {\n\t\t\t*Tno_bw = UrgentExtraLatency + trip_to_mem * ((GPUVMPageTableLevels - 2) - 1);\n\t\t} else {\n\t\t\t*Tno_bw = 0;\n\t\t}\n\t} else if (!myPipe->DCCEnable) {\n\t\t*Tno_bw = LineTime;\n\t} else {\n\t\t*Tno_bw = LineTime / 4;\n\t}\n\n\tif (myPipe->SourcePixelFormat == dm_420_8 || myPipe->SourcePixelFormat == dm_420_10 || myPipe->SourcePixelFormat == dm_420_12)\n\t\tbytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC / 4;\n\telse\n\t\tbytes_pp = myPipe->BytePerPixelY + myPipe->BytePerPixelC;\n\t \n\tprefetch_bw_pr = bytes_pp * myPipe->PixelClock / (double) myPipe->DPPPerPlane;\n\tprefetch_bw_pr = dml_min(1, myPipe->VRatio) * prefetch_bw_pr;\n\tmax_Tsw = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) * LineTime;\n\tprefetch_sw_bytes = PrefetchSourceLinesY * swath_width_luma_ub * myPipe->BytePerPixelY + PrefetchSourceLinesC * swath_width_chroma_ub * myPipe->BytePerPixelC;\n\tprefetch_bw_oto = dml_max(prefetch_bw_pr, prefetch_sw_bytes / max_Tsw);\n\n\tmin_Lsw = dml_max(1, dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) / max_vratio_pre);\n\tLsw_oto = dml_ceil(4 * dml_max(prefetch_sw_bytes / prefetch_bw_oto / LineTime, min_Lsw), 1) / 4;\n#ifdef __DML_VBA_DEBUG__\n\tTsw_oto = Lsw_oto * LineTime;\n#endif\n\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML: HTotal: %d\\n\", myPipe->HTotal);\n\tdml_print(\"DML: prefetch_bw_oto: %f\\n\", prefetch_bw_oto);\n\tdml_print(\"DML: PrefetchSourceLinesY: %f\\n\", PrefetchSourceLinesY);\n\tdml_print(\"DML: swath_width_luma_ub: %d\\n\", swath_width_luma_ub);\n\tdml_print(\"DML: BytePerPixelY: %d\\n\", myPipe->BytePerPixelY);\n\tdml_print(\"DML: Tsw_oto: %f\\n\", Tsw_oto);\n#endif\n\n\tif (GPUVMEnable == true)\n\t\tTvm_oto = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_oto, Tvm_trips, LineTime / 4.0);\n\telse\n\t\tTvm_oto = LineTime / 4.0;\n\n\tif ((GPUVMEnable == true || myPipe->DCCEnable == true)) {\n\t\tTr0_oto = dml_max4((MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto, Tr0_trips, \n\t\t\t\tLineTime - Tvm_oto,\n\t\t\t\tLineTime / 4);\n\t} else {\n\t\tTr0_oto = (LineTime - Tvm_oto) / 2.0;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: Tvm_trips = %f\\n\", __func__, Tvm_trips);\n\tdml_print(\"DML::%s: Tr0_trips = %f\\n\", __func__, Tr0_trips);\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, MetaRowByte);\n\tdml_print(\"DML::%s: MetaRowByte = %d\\n\", __func__, MetaRowByte);\n\tdml_print(\"DML::%s: PixelPTEBytesPerRow = %d\\n\", __func__, PixelPTEBytesPerRow);\n\tdml_print(\"DML::%s: HostVMInefficiencyFactor = %f\\n\", __func__, HostVMInefficiencyFactor);\n\tdml_print(\"DML::%s: prefetch_bw_oto = %f\\n\", __func__, prefetch_bw_oto);\n\tdml_print(\"DML::%s: Tr0_oto = %f\\n\", __func__, Tr0_oto);\n\tdml_print(\"DML::%s: Tvm_oto = %f\\n\", __func__, Tvm_oto);\n#endif\n\n\tTvm_oto_lines = dml_ceil(4.0 * Tvm_oto / LineTime, 1) / 4.0;\n\tTr0_oto_lines = dml_ceil(4.0 * Tr0_oto / LineTime, 1) / 4.0;\n\tdst_y_prefetch_oto = Tvm_oto_lines + 2 * Tr0_oto_lines + Lsw_oto;\n\tdst_y_prefetch_equ =  VStartup - (*TSetup + dml_max(TWait + TCalc, *Tdmdl)) / LineTime - (*DSTYAfterScaler + *DSTXAfterScaler / myPipe->HTotal);\n\tdst_y_prefetch_equ = dml_floor(4.0 * (dst_y_prefetch_equ + 0.125), 1) / 4.0;\n\tTpre_rounded = dst_y_prefetch_equ * LineTime;\n\n\tdep_bytes = dml_max(PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor, MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor);\n\n\tif (prefetch_sw_bytes < dep_bytes)\n\t\tprefetch_sw_bytes = 2 * dep_bytes;\n\n\tdml_print(\"DML: dst_y_prefetch_oto: %f\\n\", dst_y_prefetch_oto);\n\tdml_print(\"DML: Tvm_oto_lines: %f\\n\", Tvm_oto_lines);\n\tdml_print(\"DML: Tr0_oto_lines: %f\\n\", Tr0_oto_lines);\n\tdml_print(\"DML: Lsw_oto: %f\\n\", Lsw_oto);\n\tdml_print(\"DML: LineTime: %f\\n\", LineTime);\n\tdml_print(\"DML: dst_y_prefetch_equ: %f (after round)\\n\", dst_y_prefetch_equ);\n\n\tdml_print(\"DML: LineTime: %f\\n\", LineTime);\n\tdml_print(\"DML: VStartup: %d\\n\", VStartup);\n\tdml_print(\"DML: Tvstartup: %fus - time between vstartup and first pixel of active\\n\", VStartup * LineTime);\n\tdml_print(\"DML: TSetup: %fus - time from vstartup to vready\\n\", *TSetup);\n\tdml_print(\"DML: TCalc: %fus - time for calculations in dchub starting at vready\\n\", TCalc);\n\tdml_print(\"DML: TWait: %fus - time for fabric to become ready max(pstate exit,cstate enter/exit, urgent latency) after TCalc\\n\", TWait);\n\tdml_print(\"DML: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\", Tdmbf);\n\tdml_print(\"DML: Tdmec: %fus - time dio takes to transfer dmd\\n\", Tdmec);\n\tdml_print(\"DML: Tdmsks: %fus - time before active dmd must complete transmission at dio\\n\", Tdmsks);\n\tdml_print(\"DML: Tdmdl_vm: %fus - time for vm stages of dmd \\n\", *Tdmdl_vm);\n\tdml_print(\"DML: Tdmdl: %fus - time for fabric to become ready and fetch dmd \\n\", *Tdmdl);\n\tdml_print(\"DML: DSTXAfterScaler: %f pixels - number of pixel clocks pipeline and buffer delay after scaler \\n\", *DSTXAfterScaler);\n\tdml_print(\"DML: DSTYAfterScaler: %f lines - number of lines of pipeline and buffer delay after scaler \\n\", *DSTYAfterScaler);\n\n\t*PrefetchBandwidth = 0;\n\t*DestinationLinesToRequestVMInVBlank = 0;\n\t*DestinationLinesToRequestRowInVBlank = 0;\n\t*VRatioPrefetchY = 0;\n\t*VRatioPrefetchC = 0;\n\t*RequiredPrefetchPixDataBWLuma = 0;\n\tif (dst_y_prefetch_equ > 1) {\n\t\tdouble PrefetchBandwidth1;\n\t\tdouble PrefetchBandwidth2;\n\t\tdouble PrefetchBandwidth3;\n\t\tdouble PrefetchBandwidth4;\n\n\t\tif (Tpre_rounded - *Tno_bw > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t\t+ prefetch_sw_bytes) / (Tpre_rounded - *Tno_bw);\n\t\t\tTsw_est1 = prefetch_sw_bytes / PrefetchBandwidth1;\n\t\t} else {\n\t\t\tPrefetchBandwidth1 = 0;\n\t\t}\n\n\t\tif (VStartup == MaxVStartup && Tsw_est1 / LineTime < min_Lsw && Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - *Tno_bw);\n\t\t}\n\n\t\tif (Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded > 0)\n\t\t\tPrefetchBandwidth2 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + prefetch_sw_bytes) / (Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth2 = 0;\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t\t+ prefetch_sw_bytes) / (Tpre_rounded - Tvm_trips_rounded);\n\t\t\tTsw_est3 = prefetch_sw_bytes / PrefetchBandwidth3;\n\t\t} else {\n\t\t\tPrefetchBandwidth3 = 0;\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: Tpre_rounded: %f\\n\", __func__, Tpre_rounded);\n\t\tdml_print(\"DML::%s: Tvm_trips_rounded: %f\\n\", __func__, Tvm_trips_rounded);\n\t\tdml_print(\"DML::%s: PrefetchBandwidth3: %f\\n\", __func__, PrefetchBandwidth3);\n#endif\n\t\tif (VStartup == MaxVStartup && Tsw_est3 / LineTime < min_Lsw && Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - Tvm_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t/ (Tpre_rounded - min_Lsw * LineTime - 0.75 * LineTime - Tvm_trips_rounded);\n\t\t}\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded > 0)\n\t\t\tPrefetchBandwidth4 = prefetch_sw_bytes / (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth4 = 0;\n\n\t\t{\n\t\t\tbool Case1OK;\n\t\t\tbool Case2OK;\n\t\t\tbool Case3OK;\n\n\t\t\tif (PrefetchBandwidth1 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth1 >= Tvm_trips_rounded\n\t\t\t\t\t\t&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth1 >= Tr0_trips_rounded) {\n\t\t\t\t\tCase1OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase1OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase1OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth2 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth2 >= Tvm_trips_rounded\n\t\t\t\t\t\t&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth2 < Tr0_trips_rounded) {\n\t\t\t\t\tCase2OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase2OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase2OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth3 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth3 < Tvm_trips_rounded\n\t\t\t\t\t\t&& (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth3 >= Tr0_trips_rounded) {\n\t\t\t\t\tCase3OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase3OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase3OK = false;\n\t\t\t}\n\n\t\t\tif (Case1OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth1;\n\t\t\t} else if (Case2OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth2;\n\t\t\t} else if (Case3OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth3;\n\t\t\t} else {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth4;\n\t\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: Case1OK: %d\\n\", __func__, Case1OK);\n\t\t\tdml_print(\"DML::%s: Case2OK: %d\\n\", __func__, Case2OK);\n\t\t\tdml_print(\"DML::%s: Case3OK: %d\\n\", __func__, Case3OK);\n\t\t\tdml_print(\"DML::%s: prefetch_bw_equ: %f\\n\", __func__, prefetch_bw_equ);\n#endif\n\n\t\t\tif (prefetch_bw_equ > 0) {\n\t\t\t\tif (GPUVMEnable == true) {\n\t\t\t\t\tTvm_equ = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_equ, Tvm_trips, LineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTvm_equ = LineTime / 4;\n\t\t\t\t}\n\n\t\t\t\tif ((GPUVMEnable == true || myPipe->DCCEnable == true)) {\n\t\t\t\t\tTr0_equ = dml_max4(\n\t\t\t\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_equ,\n\t\t\t\t\t\t\tTr0_trips,\n\t\t\t\t\t\t\t(LineTime - Tvm_equ) / 2,\n\t\t\t\t\t\t\tLineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTr0_equ = (LineTime - Tvm_equ) / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTvm_equ = 0;\n\t\t\t\tTr0_equ = 0;\n\t\t\t\tdml_print(\"DML: prefetch_bw_equ equals 0! %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t}\n\t\t}\n\n\t\tif (dst_y_prefetch_oto < dst_y_prefetch_equ) {\n\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_oto;\n\t\t\tTimeForFetchingMetaPTE = Tvm_oto;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_oto;\n\t\t\t*PrefetchBandwidth = prefetch_bw_oto;\n\t\t} else {\n\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_equ;\n\t\t\tTimeForFetchingMetaPTE = Tvm_equ;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_equ;\n\t\t\t*PrefetchBandwidth = prefetch_bw_equ;\n\t\t}\n\n\t\t*DestinationLinesToRequestVMInVBlank = dml_ceil(4.0 * TimeForFetchingMetaPTE / LineTime, 1.0) / 4.0;\n\n\t\t*DestinationLinesToRequestRowInVBlank = dml_ceil(4.0 * TimeForFetchingRowInVBlank / LineTime, 1.0) / 4.0;\n\n#ifdef __DML_VBA_ALLOW_DELTA__\n\t\tLinesToRequestPrefetchPixelData = *DestinationLinesForPrefetch\n\t\t\n\t\t\n\t\t\t\t- ((GPUVMEnable || myPipe->DCCEnable) ? (*DestinationLinesToRequestVMInVBlank + 2 * *DestinationLinesToRequestRowInVBlank) : 0.0); \n#else\n\t\t\t\tLinesToRequestPrefetchPixelData = *DestinationLinesForPrefetch - *DestinationLinesToRequestVMInVBlank - 2 * *DestinationLinesToRequestRowInVBlank;\n#endif\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: DestinationLinesForPrefetch = %f\\n\", __func__, *DestinationLinesForPrefetch);\n\t\tdml_print(\"DML::%s: DestinationLinesToRequestVMInVBlank = %f\\n\", __func__, *DestinationLinesToRequestVMInVBlank);\n\t\tdml_print(\"DML::%s: TimeForFetchingRowInVBlank = %f\\n\", __func__, TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n\t\tdml_print(\"DML::%s: DestinationLinesToRequestRowInVBlank = %f\\n\", __func__, *DestinationLinesToRequestRowInVBlank);\n\t\tdml_print(\"DML::%s: PrefetchSourceLinesY = %f\\n\", __func__, PrefetchSourceLinesY);\n\t\tdml_print(\"DML::%s: LinesToRequestPrefetchPixelData = %f\\n\", __func__, LinesToRequestPrefetchPixelData);\n#endif\n\n\t\tif (LinesToRequestPrefetchPixelData > 0 && prefetch_bw_equ > 0) {\n\n\t\t\t*VRatioPrefetchY = (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: VRatioPrefetchY = %f\\n\", __func__, *VRatioPrefetchY);\n\t\t\tdml_print(\"DML::%s: SwathHeightY = %d\\n\", __func__, SwathHeightY);\n\t\t\tdml_print(\"DML::%s: VInitPreFillY = %f\\n\", __func__, VInitPreFillY);\n#endif\n\t\t\tif ((SwathHeightY > 4) && (VInitPreFillY > 3)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchY = dml_max(\n\t\t\t\t\t\t\t(double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData,\n\t\t\t\t\t\t\t(double) MaxNumSwathY * SwathHeightY / (LinesToRequestPrefetchPixelData - (VInitPreFillY - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t\t\t*VRatioPrefetchY = 0;\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: VRatioPrefetchY = %f\\n\", __func__, *VRatioPrefetchY);\n\t\t\t\tdml_print(\"DML::%s: PrefetchSourceLinesY = %f\\n\", __func__, PrefetchSourceLinesY);\n\t\t\t\tdml_print(\"DML::%s: MaxNumSwathY = %d\\n\", __func__, MaxNumSwathY);\n#endif\n\t\t\t}\n\n\t\t\t*VRatioPrefetchC = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: VRatioPrefetchC = %f\\n\", __func__, *VRatioPrefetchC);\n\t\t\tdml_print(\"DML::%s: SwathHeightC = %d\\n\", __func__, SwathHeightC);\n\t\t\tdml_print(\"DML::%s: VInitPreFillC = %f\\n\", __func__, VInitPreFillC);\n#endif\n\t\t\tif ((SwathHeightC > 4) || VInitPreFillC > 3) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchC = dml_max(\n\t\t\t\t\t\t\t*VRatioPrefetchC,\n\t\t\t\t\t\t\t(double) MaxNumSwathC * SwathHeightC / (LinesToRequestPrefetchPixelData - (VInitPreFillC - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t\t\t*VRatioPrefetchC = 0;\n\t\t\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: VRatioPrefetchC = %f\\n\", __func__, *VRatioPrefetchC);\n\t\t\t\tdml_print(\"DML::%s: PrefetchSourceLinesC = %f\\n\", __func__, PrefetchSourceLinesC);\n\t\t\t\tdml_print(\"DML::%s: MaxNumSwathC = %d\\n\", __func__, MaxNumSwathC);\n#endif\n\t\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: BytePerPixelY = %d\\n\", __func__, myPipe->BytePerPixelY);\n\t\t\tdml_print(\"DML::%s: swath_width_luma_ub = %d\\n\", __func__, swath_width_luma_ub);\n\t\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n#endif\n\n\t\t\t*RequiredPrefetchPixDataBWLuma = (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData * myPipe->BytePerPixelY * swath_width_luma_ub / LineTime;\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: RequiredPrefetchPixDataBWLuma = %f\\n\", __func__, *RequiredPrefetchPixDataBWLuma);\n#endif\n\n\t\t\t*RequiredPrefetchPixDataBWChroma = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData * myPipe->BytePerPixelC * swath_width_chroma_ub\n\t\t\t\t\t/ LineTime;\n\t\t} else {\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\tdml_print(\"DML: LinesToRequestPrefetchPixelData: %f, should be > 0\\n\", LinesToRequestPrefetchPixelData);\n\t\t\t*VRatioPrefetchY = 0;\n\t\t\t*VRatioPrefetchC = 0;\n\t\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t\t}\n\n\t\tdml_print(\n\t\t\t\t\"DML: Tpre: %fus - sum of time to request meta pte, 2 x data pte + meta data, swaths\\n\",\n\t\t\t\t(double) LinesToRequestPrefetchPixelData * LineTime + 2.0 * TimeForFetchingRowInVBlank + TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML:  Tvm: %fus - time to fetch page tables for meta surface\\n\", TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML:  Tr0: %fus - time to fetch first row of data pagetables and first row of meta data (done in parallel)\\n\", TimeForFetchingRowInVBlank);\n\t\tdml_print(\n\t\t\t\t\"DML:  Tsw: %fus = time to fetch enough pixel data and cursor data to feed the scalers init position and detile\\n\",\n\t\t\t\t(double) LinesToRequestPrefetchPixelData * LineTime);\n\t\tdml_print(\"DML: To: %fus - time for propagation from scaler to optc\\n\",\n\t\t\t  (*DSTYAfterScaler + ((double) (*DSTXAfterScaler) /\n\t\t\t  (double) myPipe->HTotal)) * LineTime);\n\t\tdml_print(\"DML: Tvstartup - TSetup - Tcalc - Twait - Tpre - To > 0\\n\");\n\t\tdml_print(\"DML: Tslack(pre): %fus - time left over in schedule\\n\",\n\t\t\t\tVStartup * LineTime - TimeForFetchingMetaPTE - 2 * TimeForFetchingRowInVBlank\n\t\t\t\t\t\t- (*DSTYAfterScaler + ((double) (*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime - TWait - TCalc - *TSetup);\n\t\tdml_print(\"DML: row_bytes = dpte_row_bytes (per_pipe) = PixelPTEBytesPerRow = : %d\\n\", PixelPTEBytesPerRow);\n\n\t} else {\n\t\tMyError = true;\n\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t}\n\n\t{\n\t\tdouble prefetch_vm_bw;\n\t\tdouble prefetch_row_bw;\n\n\t\tif (PDEAndMetaPTEBytesFrame == 0) {\n\t\t\tprefetch_vm_bw = 0;\n\t\t} else if (*DestinationLinesToRequestVMInVBlank > 0) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n\t\t\tdml_print(\"DML::%s: HostVMInefficiencyFactor = %f\\n\", __func__, HostVMInefficiencyFactor);\n\t\t\tdml_print(\"DML::%s: DestinationLinesToRequestVMInVBlank = %f\\n\", __func__, *DestinationLinesToRequestVMInVBlank);\n\t\t\tdml_print(\"DML::%s: LineTime = %f\\n\", __func__, LineTime);\n#endif\n\t\t\tprefetch_vm_bw = PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / (*DestinationLinesToRequestVMInVBlank * LineTime);\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: prefetch_vm_bw = %f\\n\", __func__, prefetch_vm_bw);\n#endif\n\t\t} else {\n\t\t\tprefetch_vm_bw = 0;\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t}\n\n\t\tif (MetaRowByte + PixelPTEBytesPerRow == 0) {\n\t\t\tprefetch_row_bw = 0;\n\t\t} else if (*DestinationLinesToRequestRowInVBlank > 0) {\n\t\t\tprefetch_row_bw = (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / (*DestinationLinesToRequestRowInVBlank * LineTime);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: MetaRowByte = %d\\n\", __func__, MetaRowByte);\n\t\t\tdml_print(\"DML::%s: PixelPTEBytesPerRow = %d\\n\", __func__, PixelPTEBytesPerRow);\n\t\t\tdml_print(\"DML::%s: DestinationLinesToRequestRowInVBlank = %f\\n\", __func__, *DestinationLinesToRequestRowInVBlank);\n\t\t\tdml_print(\"DML::%s: prefetch_row_bw = %f\\n\", __func__, prefetch_row_bw);\n#endif\n\t\t} else {\n\t\t\tprefetch_row_bw = 0;\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t}\n\n\t\t*prefetch_vmrow_bw = dml_max(prefetch_vm_bw, prefetch_row_bw);\n\t}\n\n\tif (MyError) {\n\t\t*PrefetchBandwidth = 0;\n\t\tTimeForFetchingMetaPTE = 0;\n\t\tTimeForFetchingRowInVBlank = 0;\n\t\t*DestinationLinesToRequestVMInVBlank = 0;\n\t\t*DestinationLinesToRequestRowInVBlank = 0;\n\t\t*DestinationLinesForPrefetch = 0;\n\t\tLinesToRequestPrefetchPixelData = 0;\n\t\t*VRatioPrefetchY = 0;\n\t\t*VRatioPrefetchC = 0;\n\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t}\n\n\treturn MyError;\n}\n\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);\n}\n\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);\n}\n\nstatic void CalculateDCCConfiguration(\n\t\tbool DCCEnabled,\n\t\tbool DCCProgrammingAssumesScanDirectionUnknown,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceWidthLuma,\n\t\tunsigned int SurfaceWidthChroma,\n\t\tunsigned int SurfaceHeightLuma,\n\t\tunsigned int SurfaceHeightChroma,\n\t\tdouble DETBufferSize,\n\t\tunsigned int RequestHeight256ByteLuma,\n\t\tunsigned int RequestHeight256ByteChroma,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int BytePerPixelY,\n\t\tunsigned int BytePerPixelC,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble BytePerPixelDETC,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int *MaxUncompressedBlockLuma,\n\t\tunsigned int *MaxUncompressedBlockChroma,\n\t\tunsigned int *MaxCompressedBlockLuma,\n\t\tunsigned int *MaxCompressedBlockChroma,\n\t\tunsigned int *IndependentBlockLuma,\n\t\tunsigned int *IndependentBlockChroma)\n{\n\tint yuv420;\n\tint horz_div_l;\n\tint horz_div_c;\n\tint vert_div_l;\n\tint vert_div_c;\n\n\tint swath_buf_size;\n\tdouble detile_buf_vp_horz_limit;\n\tdouble detile_buf_vp_vert_limit;\n\n\tint MAS_vp_horz_limit;\n\tint MAS_vp_vert_limit;\n\tint max_vp_horz_width;\n\tint max_vp_vert_height;\n\tint eff_surf_width_l;\n\tint eff_surf_width_c;\n\tint eff_surf_height_l;\n\tint eff_surf_height_c;\n\n\tint full_swath_bytes_horz_wc_l;\n\tint full_swath_bytes_horz_wc_c;\n\tint full_swath_bytes_vert_wc_l;\n\tint full_swath_bytes_vert_wc_c;\n\tint req128_horz_wc_l;\n\tint req128_horz_wc_c;\n\tint req128_vert_wc_l;\n\tint req128_vert_wc_c;\n\tint segment_order_horz_contiguous_luma;\n\tint segment_order_horz_contiguous_chroma;\n\tint segment_order_vert_contiguous_luma;\n\tint segment_order_vert_contiguous_chroma;\n\n\ttypedef enum {\n\t\tREQ_256Bytes, REQ_128BytesNonContiguous, REQ_128BytesContiguous, REQ_NA\n\t} RequestType;\n\tRequestType RequestLuma;\n\tRequestType RequestChroma;\n\n\tyuv420 = ((SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12) ? 1 : 0);\n\thorz_div_l = 1;\n\thorz_div_c = 1;\n\tvert_div_l = 1;\n\tvert_div_c = 1;\n\n\tif (BytePerPixelY == 1)\n\t\tvert_div_l = 0;\n\tif (BytePerPixelC == 1)\n\t\tvert_div_c = 0;\n\tif (BytePerPixelY == 8 && (TilingFormat == dm_sw_64kb_s || TilingFormat == dm_sw_64kb_s_t || TilingFormat == dm_sw_64kb_s_x))\n\t\thorz_div_l = 0;\n\tif (BytePerPixelC == 8 && (TilingFormat == dm_sw_64kb_s || TilingFormat == dm_sw_64kb_s_t || TilingFormat == dm_sw_64kb_s_x))\n\t\thorz_div_c = 0;\n\n\tif (BytePerPixelC == 0) {\n\t\tswath_buf_size = DETBufferSize / 2 - 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size / ((double) RequestHeight256ByteLuma * BytePerPixelY / (1 + horz_div_l));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size / (256.0 / RequestHeight256ByteLuma / (1 + vert_div_l));\n\t} else {\n\t\tswath_buf_size = DETBufferSize / 2 - 2 * 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size\n\t\t\t\t/ ((double) RequestHeight256ByteLuma * BytePerPixelY / (1 + horz_div_l)\n\t\t\t\t\t\t+ (double) RequestHeight256ByteChroma * BytePerPixelC / (1 + horz_div_c) / (1 + yuv420));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size\n\t\t\t\t/ (256.0 / RequestHeight256ByteLuma / (1 + vert_div_l) + 256.0 / RequestHeight256ByteChroma / (1 + vert_div_c) / (1 + yuv420));\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tdetile_buf_vp_horz_limit = 1.5 * detile_buf_vp_horz_limit;\n\t\tdetile_buf_vp_vert_limit = 1.5 * detile_buf_vp_vert_limit;\n\t}\n\n\tdetile_buf_vp_horz_limit = dml_floor(detile_buf_vp_horz_limit - 1, 16);\n\tdetile_buf_vp_vert_limit = dml_floor(detile_buf_vp_vert_limit - 1, 16);\n\n\tMAS_vp_horz_limit = SourcePixelFormat == dm_rgbe_alpha ? 3840 : 5760;\n\tMAS_vp_vert_limit = (BytePerPixelC > 0 ? 2880 : 5760);\n\tmax_vp_horz_width = dml_min((double) MAS_vp_horz_limit, detile_buf_vp_horz_limit);\n\tmax_vp_vert_height = dml_min((double) MAS_vp_vert_limit, detile_buf_vp_vert_limit);\n\teff_surf_width_l = (SurfaceWidthLuma > max_vp_horz_width ? max_vp_horz_width : SurfaceWidthLuma);\n\teff_surf_width_c = eff_surf_width_l / (1 + yuv420);\n\teff_surf_height_l = (SurfaceHeightLuma > max_vp_vert_height ? max_vp_vert_height : SurfaceHeightLuma);\n\teff_surf_height_c = eff_surf_height_l / (1 + yuv420);\n\n\tfull_swath_bytes_horz_wc_l = eff_surf_width_l * RequestHeight256ByteLuma * BytePerPixelY;\n\tfull_swath_bytes_vert_wc_l = eff_surf_height_l * 256 / RequestHeight256ByteLuma;\n\tif (BytePerPixelC > 0) {\n\t\tfull_swath_bytes_horz_wc_c = eff_surf_width_c * RequestHeight256ByteChroma * BytePerPixelC;\n\t\tfull_swath_bytes_vert_wc_c = eff_surf_height_c * 256 / RequestHeight256ByteChroma;\n\t} else {\n\t\tfull_swath_bytes_horz_wc_c = 0;\n\t\tfull_swath_bytes_vert_wc_c = 0;\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tfull_swath_bytes_horz_wc_l = dml_ceil(full_swath_bytes_horz_wc_l * 2 / 3, 256);\n\t\tfull_swath_bytes_horz_wc_c = dml_ceil(full_swath_bytes_horz_wc_c * 2 / 3, 256);\n\t\tfull_swath_bytes_vert_wc_l = dml_ceil(full_swath_bytes_vert_wc_l * 2 / 3, 256);\n\t\tfull_swath_bytes_vert_wc_c = dml_ceil(full_swath_bytes_vert_wc_c * 2 / 3, 256);\n\t}\n\n\tif (2 * full_swath_bytes_horz_wc_l + 2 * full_swath_bytes_horz_wc_c <= DETBufferSize) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 0;\n\t} else if (full_swath_bytes_horz_wc_l < 1.5 * full_swath_bytes_horz_wc_c && 2 * full_swath_bytes_horz_wc_l + full_swath_bytes_horz_wc_c <= DETBufferSize) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 1;\n\t} else if (full_swath_bytes_horz_wc_l >= 1.5 * full_swath_bytes_horz_wc_c && full_swath_bytes_horz_wc_l + 2 * full_swath_bytes_horz_wc_c <= DETBufferSize) {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 0;\n\t} else {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 1;\n\t}\n\n\tif (2 * full_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c <= DETBufferSize) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 0;\n\t} else if (full_swath_bytes_vert_wc_l < 1.5 * full_swath_bytes_vert_wc_c && 2 * full_swath_bytes_vert_wc_l + full_swath_bytes_vert_wc_c <= DETBufferSize) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 1;\n\t} else if (full_swath_bytes_vert_wc_l >= 1.5 * full_swath_bytes_vert_wc_c && full_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c <= DETBufferSize) {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 0;\n\t} else {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 1;\n\t}\n\n\tif (BytePerPixelY == 2 || (BytePerPixelY == 4 && TilingFormat != dm_sw_64kb_r_x)) {\n\t\tsegment_order_horz_contiguous_luma = 0;\n\t} else {\n\t\tsegment_order_horz_contiguous_luma = 1;\n\t}\n\tif ((BytePerPixelY == 8 && (TilingFormat == dm_sw_64kb_d || TilingFormat == dm_sw_64kb_d_x || TilingFormat == dm_sw_64kb_d_t || TilingFormat == dm_sw_64kb_r_x))\n\t\t\t|| (BytePerPixelY == 4 && TilingFormat == dm_sw_64kb_r_x)) {\n\t\tsegment_order_vert_contiguous_luma = 0;\n\t} else {\n\t\tsegment_order_vert_contiguous_luma = 1;\n\t}\n\tif (BytePerPixelC == 2 || (BytePerPixelC == 4 && TilingFormat != dm_sw_64kb_r_x)) {\n\t\tsegment_order_horz_contiguous_chroma = 0;\n\t} else {\n\t\tsegment_order_horz_contiguous_chroma = 1;\n\t}\n\tif ((BytePerPixelC == 8 && (TilingFormat == dm_sw_64kb_d || TilingFormat == dm_sw_64kb_d_x || TilingFormat == dm_sw_64kb_d_t || TilingFormat == dm_sw_64kb_r_x))\n\t\t\t|| (BytePerPixelC == 4 && TilingFormat == dm_sw_64kb_r_x)) {\n\t\tsegment_order_vert_contiguous_chroma = 0;\n\t} else {\n\t\tsegment_order_vert_contiguous_chroma = 1;\n\t}\n\n\tif (DCCProgrammingAssumesScanDirectionUnknown == true) {\n\t\tif (req128_horz_wc_l == 0 && req128_vert_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if ((req128_horz_wc_l == 1 && segment_order_horz_contiguous_luma == 0) || (req128_vert_wc_l == 1 && segment_order_vert_contiguous_luma == 0)) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_horz_wc_c == 0 && req128_vert_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if ((req128_horz_wc_c == 1 && segment_order_horz_contiguous_chroma == 0) || (req128_vert_wc_c == 1 && segment_order_vert_contiguous_chroma == 0)) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t} else if (ScanOrientation != dm_vert) {\n\t\tif (req128_horz_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if (segment_order_horz_contiguous_luma == 0) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_horz_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if (segment_order_horz_contiguous_chroma == 0) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t} else {\n\t\tif (req128_vert_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if (segment_order_vert_contiguous_luma == 0) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_vert_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if (segment_order_vert_contiguous_chroma == 0) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t}\n\n\tif (RequestLuma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 256;\n\t\t*IndependentBlockLuma = 0;\n\t} else if (RequestLuma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 128;\n\t\t*IndependentBlockLuma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 64;\n\t\t*IndependentBlockLuma = 64;\n\t}\n\n\tif (RequestChroma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 256;\n\t\t*IndependentBlockChroma = 0;\n\t} else if (RequestChroma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 128;\n\t\t*IndependentBlockChroma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 64;\n\t\t*IndependentBlockChroma = 64;\n\t}\n\n\tif (DCCEnabled != true || BytePerPixelC == 0) {\n\t\t*MaxUncompressedBlockChroma = 0;\n\t\t*MaxCompressedBlockChroma = 0;\n\t\t*IndependentBlockChroma = 0;\n\t}\n\n\tif (DCCEnabled != true) {\n\t\t*MaxUncompressedBlockLuma = 0;\n\t\t*MaxCompressedBlockLuma = 0;\n\t\t*IndependentBlockLuma = 0;\n\t}\n}\n\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tunsigned int MaxPartialSwath;\n\n\tif (ProgressiveToInterlaceUnitInOPP)\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1) / 2.0, 1);\n\telse\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1 + Interlace * 0.5 * VRatio) / 2.0, 1);\n\n\tif (!v->IgnoreViewportPositioning) {\n\n\t\t*MaxNumSwath = dml_ceil((*VInitPreFill - 1.0) / SwathHeight, 1) + 1.0;\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 2) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 2) % SwathHeight;\n\t\tMaxPartialSwath = dml_max(1U, MaxPartialSwath);\n\n\t} else {\n\n\t\tif (ViewportYStart != 0)\n\t\t\tdml_print(\"WARNING DML: using viewport y position of 0 even though actual viewport y position is non-zero in prefetch source lines calculation\\n\");\n\n\t\t*MaxNumSwath = dml_ceil(*VInitPreFill / SwathHeight, 1);\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 1) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 1) % SwathHeight;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VRatio = %f\\n\", __func__, VRatio);\n\tdml_print(\"DML::%s: vtaps = %f\\n\", __func__, vtaps);\n\tdml_print(\"DML::%s: VInitPreFill = %f\\n\", __func__, *VInitPreFill);\n\tdml_print(\"DML::%s: ProgressiveToInterlaceUnitInOPP = %d\\n\", __func__, ProgressiveToInterlaceUnitInOPP);\n\tdml_print(\"DML::%s: IgnoreViewportPositioning = %d\\n\", __func__, v->IgnoreViewportPositioning);\n\tdml_print(\"DML::%s: SwathHeight = %d\\n\", __func__, SwathHeight);\n\tdml_print(\"DML::%s: MaxPartialSwath = %d\\n\", __func__, MaxPartialSwath);\n\tdml_print(\"DML::%s: MaxNumSwath = %d\\n\", __func__, *MaxNumSwath);\n\tdml_print(\"DML::%s: Prefetch source lines = %d\\n\", __func__, *MaxNumSwath * SwathHeight + MaxPartialSwath);\n#endif\n\treturn *MaxNumSwath * SwathHeight + MaxPartialSwath;\n}\n\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMinPageSize,\n\t\tunsigned int HostVMMinPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tint *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tint *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tint *DPDE0BytesFrame,\n\t\tint *MetaPTEBytesFrame)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tunsigned int MPDEBytesFrame;\n\tunsigned int DCCMetaSurfaceBytes;\n\tunsigned int MacroTileSizeBytes;\n\tunsigned int MacroTileHeight;\n\tunsigned int ExtraDPDEBytesFrame;\n\tunsigned int PDEAndMetaPTEBytesFrame;\n\tunsigned int PixelPTEReqHeightPTEs = 0;\n\tunsigned int HostVMDynamicLevels = 0;\n\tdouble FractionOfPTEReturnDrop;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tif (HostVMMinPageSize < 2048) {\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\t} else if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576) {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\t} else {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t\t}\n\t}\n\n\t*MetaRequestHeight = 8 * BlockHeight256Bytes;\n\t*MetaRequestWidth = 8 * BlockWidth256Bytes;\n\tif (ScanDirection != dm_vert) {\n\t\t*meta_row_height = *MetaRequestHeight;\n\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestWidth) + *MetaRequestWidth;\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestHeight * BytePerPixel / 256.0;\n\t} else {\n\t\t*meta_row_height = *MetaRequestWidth;\n\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestHeight) + *MetaRequestHeight;\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestWidth * BytePerPixel / 256.0;\n\t}\n\tDCCMetaSurfaceBytes = DCCMetaPitch * (dml_ceil(ViewportHeight - 1, 64 * BlockHeight256Bytes) + 64 * BlockHeight256Bytes) * BytePerPixel / 256;\n\tif (GPUVMEnable == true) {\n\t\t*MetaPTEBytesFrame = (dml_ceil((double) (DCCMetaSurfaceBytes - 4.0 * 1024.0) / (8 * 4.0 * 1024), 1) + 1) * 64;\n\t\tMPDEBytesFrame = 128 * (v->GPUVMMaxPageTableLevels - 1);\n\t} else {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t}\n\n\tif (DCCEnable != true) {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t\t*MetaRowByte = 0;\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\tMacroTileSizeBytes = 256;\n\t\tMacroTileHeight = BlockHeight256Bytes;\n\t} else {\n\t\tMacroTileSizeBytes = 65536;\n\t\tMacroTileHeight = 16 * BlockHeight256Bytes;\n\t}\n\t*MacroTileWidth = MacroTileSizeBytes / BytePerPixel / MacroTileHeight;\n\n\tif (GPUVMEnable == true && v->GPUVMMaxPageTableLevels > 1) {\n\t\tif (ScanDirection != dm_vert) {\n\t\t\t*DPDE0BytesFrame = 64\n\t\t\t\t\t* (dml_ceil(\n\t\t\t\t\t\t\t((Pitch * (dml_ceil(ViewportHeight - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes)\n\t\t\t\t\t\t\t\t\t/ (8 * 2097152),\n\t\t\t\t\t\t\t1) + 1);\n\t\t} else {\n\t\t\t*DPDE0BytesFrame = 64\n\t\t\t\t\t* (dml_ceil(\n\t\t\t\t\t\t\t((Pitch * (dml_ceil((double) SwathWidth - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes)\n\t\t\t\t\t\t\t\t\t/ (8 * 2097152),\n\t\t\t\t\t\t\t1) + 1);\n\t\t}\n\t\tExtraDPDEBytesFrame = 128 * (v->GPUVMMaxPageTableLevels - 2);\n\t} else {\n\t\t*DPDE0BytesFrame = 0;\n\t\tExtraDPDEBytesFrame = 0;\n\t}\n\n\tPDEAndMetaPTEBytesFrame = *MetaPTEBytesFrame + MPDEBytesFrame + *DPDE0BytesFrame + ExtraDPDEBytesFrame;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: MetaPTEBytesFrame = %d\\n\", __func__, *MetaPTEBytesFrame);\n\tdml_print(\"DML::%s: MPDEBytesFrame = %d\\n\", __func__, MPDEBytesFrame);\n\tdml_print(\"DML::%s: DPDE0BytesFrame = %d\\n\", __func__, *DPDE0BytesFrame);\n\tdml_print(\"DML::%s: ExtraDPDEBytesFrame= %d\\n\", __func__, ExtraDPDEBytesFrame);\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n#endif\n\n\tif (HostVMEnable == true) {\n\t\tPDEAndMetaPTEBytesFrame = PDEAndMetaPTEBytesFrame * (1 + 8 * HostVMDynamicLevels);\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: PDEAndMetaPTEBytesFrame = %d\\n\", __func__, PDEAndMetaPTEBytesFrame);\n#endif\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = 1;\n\t\t*PixelPTEReqWidth = 32768.0 / BytePerPixel;\n\t\t*PTERequestSize = 64;\n\t\tFractionOfPTEReturnDrop = 0;\n\t} else if (MacroTileSizeBytes == 4096) {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t*PTERequestSize = 64;\n\t\tif (ScanDirection != dm_vert)\n\t\t\tFractionOfPTEReturnDrop = 0;\n\t\telse\n\t\t\tFractionOfPTEReturnDrop = 7 / 8;\n\t} else if (GPUVMMinPageSize == 4 && MacroTileSizeBytes > 4096) {\n\t\tPixelPTEReqHeightPTEs = 16;\n\t\t*PixelPTEReqHeight = 16 * BlockHeight256Bytes;\n\t\t*PixelPTEReqWidth = 16 * BlockWidth256Bytes;\n\t\t*PTERequestSize = 128;\n\t\tFractionOfPTEReturnDrop = 0;\n\t} else {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t*PTERequestSize = 64;\n\t\tFractionOfPTEReturnDrop = 0;\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\t*dpte_row_height = dml_min(128, 1 << (unsigned int) dml_floor(dml_log2(PTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch), 1));\n\t\t*dpte_row_width_ub = (dml_ceil((double)(Pitch * *dpte_row_height - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t} else if (ScanDirection != dm_vert) {\n\t\t*dpte_row_height = *PixelPTEReqHeight;\n\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t} else {\n\t\t*dpte_row_height = dml_min(*PixelPTEReqWidth, *MacroTileWidth);\n\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqHeight, 1) + 1) * *PixelPTEReqHeight;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqHeight * *PTERequestSize;\n\t}\n\n\tif (*PixelPTEBytesPerRow * (1 - FractionOfPTEReturnDrop) <= 64 * PTEBufferSizeInRequests) {\n\t\t*PTEBufferSizeNotExceeded = true;\n\t} else {\n\t\t*PTEBufferSizeNotExceeded = false;\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*PixelPTEBytesPerRow = 0;\n\t\t*PTEBufferSizeNotExceeded = true;\n\t}\n\n\tdml_print(\"DML: vm_bytes = meta_pte_bytes_per_frame (per_pipe) = MetaPTEBytesFrame = : %i\\n\", *MetaPTEBytesFrame);\n\n\tif (HostVMEnable == true) {\n\t\t*PixelPTEBytesPerRow = *PixelPTEBytesPerRow * (1 + 8 * HostVMDynamicLevels);\n\t}\n\n\tif (HostVMEnable == true) {\n\t\t*vm_group_bytes = 512;\n\t\t*dpte_group_bytes = 512;\n\t} else if (GPUVMEnable == true) {\n\t\t*vm_group_bytes = 2048;\n\t\tif (SurfaceTiling != dm_sw_linear && PixelPTEReqHeightPTEs == 1 && ScanDirection == dm_vert) {\n\t\t\t*dpte_group_bytes = 512;\n\t\t} else {\n\t\t\t*dpte_group_bytes = 2048;\n\t\t}\n\t} else {\n\t\t*vm_group_bytes = 0;\n\t\t*dpte_group_bytes = 0;\n\t}\n\treturn PDEAndMetaPTEBytesFrame;\n}\n\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(struct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tunsigned int j, k;\n\tdouble HostVMInefficiencyFactor = 1.0;\n\tbool NoChromaPlanes = true;\n\tint ReorderBytes;\n\tdouble VMDataOnlyReturnBW;\n\tdouble MaxTotalRDBandwidth = 0;\n\tint PrefetchMode = v->PrefetchModePerState[v->VoltageLevel][v->maxMpcComb];\n\n\tv->WritebackDISPCLK = 0.0;\n\tv->DISPCLKWithRamping = 0;\n\tv->DISPCLKWithoutRamping = 0;\n\tv->GlobalDPPCLK = 0.0;\n\t \n\t{\n\tdouble IdealFabricAndSDPPortBandwidthPerState = dml_min(\n\t\t\tv->ReturnBusWidth * v->DCFCLKState[v->VoltageLevel][v->maxMpcComb],\n\t\t\tv->FabricClockPerState[v->VoltageLevel] * v->FabricDatapathToDCNDataReturn);\n\tdouble IdealDRAMBandwidthPerState = v->DRAMSpeedPerState[v->VoltageLevel] * v->NumberOfChannels * v->DRAMChannelWidth;\n\tif (v->HostVMEnable != true) {\n\t\tv->ReturnBW = dml_min(\n\t\t\t\tIdealFabricAndSDPPortBandwidthPerState * v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\t\tIdealDRAMBandwidthPerState * v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyPixelDataOnly / 100.0);\n\t} else {\n\t\tv->ReturnBW = dml_min(\n\t\t\t\tIdealFabricAndSDPPortBandwidthPerState * v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\t\tIdealDRAMBandwidthPerState * v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyPixelMixedWithVMData / 100.0);\n\t}\n\t}\n\t \n\n\t\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->WritebackEnable[k]) {\n\t\t\tv->WritebackDISPCLK = dml_max(\n\t\t\t\t\tv->WritebackDISPCLK,\n\t\t\t\t\tdml31_CalculateWriteBackDISPCLK(\n\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\tv->WritebackHTaps[k],\n\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\tv->WritebackSourceWidth[k],\n\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->WritebackLineBufferSize));\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->HRatio[k] > 1) {\n\t\t\tv->PSCL_THROUGHPUT_LUMA[k] = dml_min(\n\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatio[k] / dml_ceil(v->htaps[k] / 6.0, 1));\n\t\t} else {\n\t\t\tv->PSCL_THROUGHPUT_LUMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t}\n\n\t\tv->DPPCLKUsingSingleDPPLuma = v->PixelClock[k]\n\t\t\t\t* dml_max(\n\t\t\t\t\t\tv->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]),\n\t\t\t\t\t\tdml_max(v->HRatio[k] * v->VRatio[k] / v->PSCL_THROUGHPUT_LUMA[k], 1.0));\n\n\t\tif ((v->htaps[k] > 6 || v->vtaps[k] > 6) && v->DPPCLKUsingSingleDPPLuma < 2 * v->PixelClock[k]) {\n\t\t\tv->DPPCLKUsingSingleDPPLuma = 2 * v->PixelClock[k];\n\t\t}\n\n\t\tif ((v->SourcePixelFormat[k] != dm_420_8 && v->SourcePixelFormat[k] != dm_420_10 && v->SourcePixelFormat[k] != dm_420_12\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe_alpha)) {\n\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = 0.0;\n\t\t\tv->DPPCLKUsingSingleDPP[k] = v->DPPCLKUsingSingleDPPLuma;\n\t\t} else {\n\t\t\tif (v->HRatioChroma[k] > 1) {\n\t\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = dml_min(\n\t\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatioChroma[k] / dml_ceil(v->HTAPsChroma[k] / 6.0, 1.0));\n\t\t\t} else {\n\t\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tv->DPPCLKUsingSingleDPPChroma = v->PixelClock[k]\n\t\t\t\t\t* dml_max3(\n\t\t\t\t\t\t\tv->VTAPsChroma[k] / 6.0 * dml_min(1.0, v->HRatioChroma[k]),\n\t\t\t\t\t\t\tv->HRatioChroma[k] * v->VRatioChroma[k] / v->PSCL_THROUGHPUT_CHROMA[k],\n\t\t\t\t\t\t\t1.0);\n\n\t\t\tif ((v->HTAPsChroma[k] > 6 || v->VTAPsChroma[k] > 6) && v->DPPCLKUsingSingleDPPChroma < 2 * v->PixelClock[k]) {\n\t\t\t\tv->DPPCLKUsingSingleDPPChroma = 2 * v->PixelClock[k];\n\t\t\t}\n\n\t\t\tv->DPPCLKUsingSingleDPP[k] = dml_max(v->DPPCLKUsingSingleDPPLuma, v->DPPCLKUsingSingleDPPChroma);\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] != k)\n\t\t\tcontinue;\n\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_4to1) {\n\t\t\tv->DISPCLKWithRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithRamping,\n\t\t\t\t\tv->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithoutRamping,\n\t\t\t\t\tv->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t} else if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\tv->DISPCLKWithRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithRamping,\n\t\t\t\t\tv->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithoutRamping,\n\t\t\t\t\tv->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t} else {\n\t\t\tv->DISPCLKWithRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithRamping,\n\t\t\t\t\tv->PixelClock[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100) * (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(\n\t\t\t\t\tv->DISPCLKWithoutRamping,\n\t\t\t\t\tv->PixelClock[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t}\n\t}\n\n\tv->DISPCLKWithRamping = dml_max(v->DISPCLKWithRamping, v->WritebackDISPCLK);\n\tv->DISPCLKWithoutRamping = dml_max(v->DISPCLKWithoutRamping, v->WritebackDISPCLK);\n\n\tASSERT(v->DISPCLKDPPCLKVCOSpeed != 0);\n\tv->DISPCLKWithRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(v->DISPCLKWithRamping, v->DISPCLKDPPCLKVCOSpeed);\n\tv->DISPCLKWithoutRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(v->DISPCLKWithoutRamping, v->DISPCLKDPPCLKVCOSpeed);\n\tv->MaxDispclkRoundedToDFSGranularity = RoundToDFSGranularityDown(\n\t\t\tv->soc.clock_limits[v->soc.num_states - 1].dispclk_mhz,\n\t\t\tv->DISPCLKDPPCLKVCOSpeed);\n\tif (v->DISPCLKWithoutRampingRoundedToDFSGranularity > v->MaxDispclkRoundedToDFSGranularity) {\n\t\tv->DISPCLK_calculated = v->DISPCLKWithoutRampingRoundedToDFSGranularity;\n\t} else if (v->DISPCLKWithRampingRoundedToDFSGranularity > v->MaxDispclkRoundedToDFSGranularity) {\n\t\tv->DISPCLK_calculated = v->MaxDispclkRoundedToDFSGranularity;\n\t} else {\n\t\tv->DISPCLK_calculated = v->DISPCLKWithRampingRoundedToDFSGranularity;\n\t}\n\tv->DISPCLK = v->DISPCLK_calculated;\n\tDTRACE(\"   dispclk_mhz (calculated) = %f\", v->DISPCLK_calculated);\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->DPPCLK_calculated[k] = v->DPPCLKUsingSingleDPP[k] / v->DPPPerPlane[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\tv->GlobalDPPCLK = dml_max(v->GlobalDPPCLK, v->DPPCLK_calculated[k]);\n\t}\n\tv->GlobalDPPCLK = RoundToDFSGranularityUp(v->GlobalDPPCLK, v->DISPCLKDPPCLKVCOSpeed);\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->DPPCLK_calculated[k] = v->GlobalDPPCLK / 255 * dml_ceil(v->DPPCLK_calculated[k] * 255.0 / v->GlobalDPPCLK, 1);\n\t\tDTRACE(\"   dppclk_mhz[%i] (calculated) = %f\", k, v->DPPCLK_calculated[k]);\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->DPPCLK[k] = v->DPPCLK_calculated[k];\n\t}\n\n\t\n\tDTRACE(\"   dcfclk_mhz         = %f\", v->DCFCLK);\n\tDTRACE(\"   return_bus_bw      = %f\", v->ReturnBW);\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t&v->BytePerPixelY[k],\n\t\t\t\t&v->BytePerPixelC[k],\n\t\t\t\t&v->BytePerPixelDETY[k],\n\t\t\t\t&v->BytePerPixelDETC[k],\n\t\t\t\t&v->BlockHeight256BytesY[k],\n\t\t\t\t&v->BlockHeight256BytesC[k],\n\t\t\t\t&v->BlockWidth256BytesY[k],\n\t\t\t\t&v->BlockWidth256BytesC[k]);\n\t}\n\n\tCalculateSwathWidth(\n\t\t\tfalse,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->SourcePixelFormat,\n\t\t\tv->SourceScan,\n\t\t\tv->ViewportWidth,\n\t\t\tv->ViewportHeight,\n\t\t\tv->SurfaceWidthY,\n\t\t\tv->SurfaceWidthC,\n\t\t\tv->SurfaceHeightY,\n\t\t\tv->SurfaceHeightC,\n\t\t\tv->ODMCombineEnabled,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->BlendingAndTiming,\n\t\t\tv->HActive,\n\t\t\tv->HRatio,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->SwathWidthSingleDPPY,\n\t\t\tv->SwathWidthSingleDPPC,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->dummyinteger3,\n\t\t\tv->dummyinteger4,\n\t\t\tv->swath_width_luma_ub,\n\t\t\tv->swath_width_chroma_ub);\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->ReadBandwidthPlaneLuma[k] = v->SwathWidthSingleDPPY[k] * v->BytePerPixelY[k] / (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t* v->VRatio[k];\n\t\tv->ReadBandwidthPlaneChroma[k] = v->SwathWidthSingleDPPC[k] * v->BytePerPixelC[k] / (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t* v->VRatioChroma[k];\n\t\tDTRACE(\"   read_bw[%i] = %fBps\", k, v->ReadBandwidthPlaneLuma[k] + v->ReadBandwidthPlaneChroma[k]);\n\t}\n\n\t\n\tCalculateDCFCLKDeepSleep(\n\t\t\tmode_lib,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->PixelClock,\n\t\t\tv->PSCL_THROUGHPUT_LUMA,\n\t\t\tv->PSCL_THROUGHPUT_CHROMA,\n\t\t\tv->DPPCLK,\n\t\t\tv->ReadBandwidthPlaneLuma,\n\t\t\tv->ReadBandwidthPlaneChroma,\n\t\t\tv->ReturnBusWidth,\n\t\t\t&v->DCFCLKDeepSleep);\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif ((v->BlendingAndTiming[k] != k) || !v->DSCEnabled[k]) {\n\t\t\tv->DSCCLK_calculated[k] = 0.0;\n\t\t} else {\n\t\t\tif (v->OutputFormat[k] == dm_420)\n\t\t\t\tv->DSCFormatFactor = 2;\n\t\t\telse if (v->OutputFormat[k] == dm_444)\n\t\t\t\tv->DSCFormatFactor = 1;\n\t\t\telse if (v->OutputFormat[k] == dm_n422)\n\t\t\t\tv->DSCFormatFactor = 2;\n\t\t\telse\n\t\t\t\tv->DSCFormatFactor = 1;\n\t\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_4to1)\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 12 / v->DSCFormatFactor\n\t\t\t\t\t\t/ (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t\telse if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 6 / v->DSCFormatFactor\n\t\t\t\t\t\t/ (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t\telse\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 3 / v->DSCFormatFactor\n\t\t\t\t\t\t/ (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t}\n\t}\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tdouble BPP = v->OutputBpp[k];\n\n\t\tif (v->DSCEnabled[k] && BPP != 0) {\n\t\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_disabled) {\n\t\t\t\tv->DSCDelay[k] = dscceComputeDelay(\n\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\tBPP,\n\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t} else if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\t\tv->DSCDelay[k] = 2\n\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tBPP,\n\t\t\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 2.0,\n\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]));\n\t\t\t} else {\n\t\t\t\tv->DSCDelay[k] = 4\n\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tBPP,\n\t\t\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 4.0,\n\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]));\n\t\t\t}\n\t\t\tv->DSCDelay[k] = v->DSCDelay[k] * v->PixelClock[k] / v->PixelClockBackEnd[k];\n\t\t} else {\n\t\t\tv->DSCDelay[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) \n\t\t\tif (j != k && v->BlendingAndTiming[k] == j && v->DSCEnabled[j])\n\t\t\t\tv->DSCDelay[k] = v->DSCDelay[j];\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tunsigned int PDEAndMetaPTEBytesFrameY;\n\t\tunsigned int PixelPTEBytesPerRowY;\n\t\tunsigned int MetaRowByteY;\n\t\tunsigned int MetaRowByteC;\n\t\tunsigned int PDEAndMetaPTEBytesFrameC;\n\t\tunsigned int PixelPTEBytesPerRowC;\n\t\tbool PTEBufferSizeNotExceededY;\n\t\tbool PTEBufferSizeNotExceededC;\n\n\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12\n\t\t\t\t|| v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\tif ((v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12) && v->SourceScan[k] != dm_vert) {\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma = (v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma) / 2;\n\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsForLuma;\n\t\t\t} else {\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma;\n\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsChroma;\n\t\t\t}\n\n\t\t\tPDEAndMetaPTEBytesFrameC = CalculateVMAndRowBytes(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\tv->BlockHeight256BytesC[k],\n\t\t\t\t\tv->BlockWidth256BytesC[k],\n\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\tv->SwathWidthC[k],\n\t\t\t\t\tv->ViewportHeightChroma[k],\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma,\n\t\t\t\t\tv->PitchC[k],\n\t\t\t\t\tv->DCCMetaPitchC[k],\n\t\t\t\t\t&v->MacroTileWidthC[k],\n\t\t\t\t\t&MetaRowByteC,\n\t\t\t\t\t&PixelPTEBytesPerRowC,\n\t\t\t\t\t&PTEBufferSizeNotExceededC,\n\t\t\t\t\t&v->dpte_row_width_chroma_ub[k],\n\t\t\t\t\t&v->dpte_row_height_chroma[k],\n\t\t\t\t\t&v->meta_req_width_chroma[k],\n\t\t\t\t\t&v->meta_req_height_chroma[k],\n\t\t\t\t\t&v->meta_row_width_chroma[k],\n\t\t\t\t\t&v->meta_row_height_chroma[k],\n\t\t\t\t\t&v->dummyinteger1,\n\t\t\t\t\t&v->dummyinteger2,\n\t\t\t\t\t&v->PixelPTEReqWidthC[k],\n\t\t\t\t\t&v->PixelPTEReqHeightC[k],\n\t\t\t\t\t&v->PTERequestSizeC[k],\n\t\t\t\t\t&v->dpde0_bytes_per_frame_ub_c[k],\n\t\t\t\t\t&v->meta_pte_bytes_per_frame_ub_c[k]);\n\n\t\t\tv->PrefetchSourceLinesC[k] = CalculatePrefetchSourceLines(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\tv->VTAPsChroma[k],\n\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->ViewportYStartC[k],\n\t\t\t\t\t&v->VInitPreFillC[k],\n\t\t\t\t\t&v->MaxNumSwathC[k]);\n\t\t} else {\n\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma;\n\t\t\tv->PTEBufferSizeInRequestsForChroma = 0;\n\t\t\tPixelPTEBytesPerRowC = 0;\n\t\t\tPDEAndMetaPTEBytesFrameC = 0;\n\t\t\tMetaRowByteC = 0;\n\t\t\tv->MaxNumSwathC[k] = 0;\n\t\t\tv->PrefetchSourceLinesC[k] = 0;\n\t\t}\n\n\t\tPDEAndMetaPTEBytesFrameY = CalculateVMAndRowBytes(\n\t\t\t\tmode_lib,\n\t\t\t\tv->DCCEnable[k],\n\t\t\t\tv->BlockHeight256BytesY[k],\n\t\t\t\tv->BlockWidth256BytesY[k],\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\tv->SourceScan[k],\n\t\t\t\tv->SwathWidthY[k],\n\t\t\t\tv->ViewportHeight[k],\n\t\t\t\tv->GPUVMEnable,\n\t\t\t\tv->HostVMEnable,\n\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma,\n\t\t\t\tv->PitchY[k],\n\t\t\t\tv->DCCMetaPitchY[k],\n\t\t\t\t&v->MacroTileWidthY[k],\n\t\t\t\t&MetaRowByteY,\n\t\t\t\t&PixelPTEBytesPerRowY,\n\t\t\t\t&PTEBufferSizeNotExceededY,\n\t\t\t\t&v->dpte_row_width_luma_ub[k],\n\t\t\t\t&v->dpte_row_height[k],\n\t\t\t\t&v->meta_req_width[k],\n\t\t\t\t&v->meta_req_height[k],\n\t\t\t\t&v->meta_row_width[k],\n\t\t\t\t&v->meta_row_height[k],\n\t\t\t\t&v->vm_group_bytes[k],\n\t\t\t\t&v->dpte_group_bytes[k],\n\t\t\t\t&v->PixelPTEReqWidthY[k],\n\t\t\t\t&v->PixelPTEReqHeightY[k],\n\t\t\t\t&v->PTERequestSizeY[k],\n\t\t\t\t&v->dpde0_bytes_per_frame_ub_l[k],\n\t\t\t\t&v->meta_pte_bytes_per_frame_ub_l[k]);\n\n\t\tv->PrefetchSourceLinesY[k] = CalculatePrefetchSourceLines(\n\t\t\t\tmode_lib,\n\t\t\t\tv->VRatio[k],\n\t\t\t\tv->vtaps[k],\n\t\t\t\tv->Interlace[k],\n\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\tv->SwathHeightY[k],\n\t\t\t\tv->ViewportYStartY[k],\n\t\t\t\t&v->VInitPreFillY[k],\n\t\t\t\t&v->MaxNumSwathY[k]);\n\t\tv->PixelPTEBytesPerRow[k] = PixelPTEBytesPerRowY + PixelPTEBytesPerRowC;\n\t\tv->PDEAndMetaPTEBytesFrame[k] = PDEAndMetaPTEBytesFrameY + PDEAndMetaPTEBytesFrameC;\n\t\tv->MetaRowByte[k] = MetaRowByteY + MetaRowByteC;\n\n\t\tCalculateRowBandwidth(\n\t\t\t\tv->GPUVMEnable,\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->VRatio[k],\n\t\t\t\tv->VRatioChroma[k],\n\t\t\t\tv->DCCEnable[k],\n\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\tMetaRowByteY,\n\t\t\t\tMetaRowByteC,\n\t\t\t\tv->meta_row_height[k],\n\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\tPixelPTEBytesPerRowY,\n\t\t\t\tPixelPTEBytesPerRowC,\n\t\t\t\tv->dpte_row_height[k],\n\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t&v->meta_row_bw[k],\n\t\t\t\t&v->dpte_row_bw[k]);\n\t}\n\n\tv->TotalDCCActiveDPP = 0;\n\tv->TotalActiveDPP = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->TotalActiveDPP = v->TotalActiveDPP + v->DPPPerPlane[k];\n\t\tif (v->DCCEnable[k])\n\t\t\tv->TotalDCCActiveDPP = v->TotalDCCActiveDPP + v->DPPPerPlane[k];\n\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12\n\t\t\t\t|| v->SourcePixelFormat[k] == dm_rgbe_alpha)\n\t\t\tNoChromaPlanes = false;\n\t}\n\n\tReorderBytes = v->NumberOfChannels\n\t\t\t* dml_max3(\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\n\tVMDataOnlyReturnBW = dml_min(\n\t\t\tdml_min(v->ReturnBusWidth * v->DCFCLK, v->FabricClock * v->FabricDatapathToDCNDataReturn)\n\t\t\t\t\t* v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\tv->DRAMSpeed * v->NumberOfChannels * v->DRAMChannelWidth\n\t\t\t\t\t* v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyVMDataOnly / 100.0);\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: v->ReturnBusWidth = %f\\n\", __func__, v->ReturnBusWidth);\n\tdml_print(\"DML::%s: v->DCFCLK = %f\\n\", __func__, v->DCFCLK);\n\tdml_print(\"DML::%s: v->FabricClock = %f\\n\", __func__, v->FabricClock);\n\tdml_print(\"DML::%s: v->FabricDatapathToDCNDataReturn = %f\\n\", __func__, v->FabricDatapathToDCNDataReturn);\n\tdml_print(\"DML::%s: v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency = %f\\n\", __func__, v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency);\n\tdml_print(\"DML::%s: v->DRAMSpeed = %f\\n\", __func__, v->DRAMSpeed);\n\tdml_print(\"DML::%s: v->NumberOfChannels = %f\\n\", __func__, v->NumberOfChannels);\n\tdml_print(\"DML::%s: v->DRAMChannelWidth = %f\\n\", __func__, v->DRAMChannelWidth);\n\tdml_print(\"DML::%s: v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyVMDataOnly = %f\\n\", __func__, v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyVMDataOnly);\n\tdml_print(\"DML::%s: VMDataOnlyReturnBW = %f\\n\", __func__, VMDataOnlyReturnBW);\n\tdml_print(\"DML::%s: ReturnBW = %f\\n\", __func__, v->ReturnBW);\n#endif\n\n\tif (v->GPUVMEnable && v->HostVMEnable)\n\t\tHostVMInefficiencyFactor = v->ReturnBW / VMDataOnlyReturnBW;\n\n\tv->UrgentExtraLatency = CalculateExtraLatency(\n\t\t\tv->RoundTripPingLatencyCycles,\n\t\t\tReorderBytes,\n\t\t\tv->DCFCLK,\n\t\t\tv->TotalActiveDPP,\n\t\t\tv->PixelChunkSizeInKByte,\n\t\t\tv->TotalDCCActiveDPP,\n\t\t\tv->MetaChunkSize,\n\t\t\tv->ReturnBW,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->HostVMEnable,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->dpte_group_bytes,\n\t\t\tHostVMInefficiencyFactor,\n\t\t\tv->HostVMMinPageSize,\n\t\t\tv->HostVMMaxNonCachedPageTableLevels);\n\n\tv->TCalc = 24.0 / v->DCFCLKDeepSleep;\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackLatency\n\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[k],\n\t\t\t\t\t\t\t\tv->WritebackSourceHeight[k],\n\t\t\t\t\t\t\t\tv->HTotal[k]) / v->DISPCLK;\n\t\t\t} else\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = 0;\n\t\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) {\n\t\t\t\tif (v->BlendingAndTiming[j] == k && v->WritebackEnable[j] == true) {\n\t\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = dml_max(\n\t\t\t\t\t\t\tv->WritebackDelay[v->VoltageLevel][k],\n\t\t\t\t\t\t\tv->WritebackLatency\n\t\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[j],\n\t\t\t\t\t\t\t\t\t\t\tv->HTotal[k]) / v->DISPCLK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j)\n\t\t\tif (v->BlendingAndTiming[k] == j)\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackDelay[v->VoltageLevel][j];\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->MaxVStartupLines[k] =\n\t\t\t\t(v->Interlace[k] && !v->ProgressiveToInterlaceUnitInOPP) ?\n\t\t\t\t\t\tdml_floor((v->VTotal[k] - v->VActive[k]) / 2.0, 1.0) :\n\t\t\t\t\t\tv->VTotal[k] - v->VActive[k]\n\t\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t(double) v->WritebackDelay[v->VoltageLevel][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]),\n\t\t\t\t\t\t\t\t\t\t\t\t1));\n\t\tif (v->MaxVStartupLines[k] > 1023)\n\t\t\tv->MaxVStartupLines[k] = 1023;\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d MaxVStartupLines = %d\\n\", __func__, k, v->MaxVStartupLines[k]);\n\t\tdml_print(\"DML::%s: k=%d VoltageLevel = %d\\n\", __func__, k, v->VoltageLevel);\n\t\tdml_print(\"DML::%s: k=%d WritebackDelay = %f\\n\", __func__, k, v->WritebackDelay[v->VoltageLevel][k]);\n#endif\n\t}\n\n\tv->MaximumMaxVStartupLines = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tv->MaximumMaxVStartupLines = dml_max(v->MaximumMaxVStartupLines, v->MaxVStartupLines[k]);\n\n\t\n\t\n\t\n\n\tv->UrgentLatency = CalculateUrgentLatency(\n\t\t\tv->UrgentLatencyPixelDataOnly,\n\t\t\tv->UrgentLatencyPixelMixedWithVMData,\n\t\t\tv->UrgentLatencyVMDataOnly,\n\t\t\tv->DoUrgentLatencyAdjustment,\n\t\t\tv->UrgentLatencyAdjustmentFabricClockComponent,\n\t\t\tv->UrgentLatencyAdjustmentFabricClockReference,\n\t\t\tv->FabricClock);\n\n\tv->FractionOfUrgentBandwidth = 0.0;\n\tv->FractionOfUrgentBandwidthImmediateFlip = 0.0;\n\n\tv->VStartupLines = __DML_VBA_MIN_VSTARTUP__;\n\n\tdo {\n\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0.0;\n\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;\n\t\tbool VRatioPrefetchMoreThan4 = false;\n\t\tdouble TWait = CalculateTWait(PrefetchMode, v->DRAMClockChangeLatency, v->UrgentLatency, v->SREnterPlusExitTime);\n\t\tMaxTotalRDBandwidth = 0;\n\n\t\tdml_print(\"DML::%s: Start loop: VStartup = %d\\n\", __func__, v->VStartupLines);\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tPipe myPipe;\n\n\t\t\tmyPipe.DPPCLK = v->DPPCLK[k];\n\t\t\tmyPipe.DISPCLK = v->DISPCLK;\n\t\t\tmyPipe.PixelClock = v->PixelClock[k];\n\t\t\tmyPipe.DCFCLKDeepSleep = v->DCFCLKDeepSleep;\n\t\t\tmyPipe.DPPPerPlane = v->DPPPerPlane[k];\n\t\t\tmyPipe.ScalerEnabled = v->ScalerEnabled[k];\n\t\t\tmyPipe.VRatio = v->VRatio[k];\n\t\t\tmyPipe.VRatioChroma = v->VRatioChroma[k];\n\t\t\tmyPipe.SourceScan = v->SourceScan[k];\n\t\t\tmyPipe.BlockWidth256BytesY = v->BlockWidth256BytesY[k];\n\t\t\tmyPipe.BlockHeight256BytesY = v->BlockHeight256BytesY[k];\n\t\t\tmyPipe.BlockWidth256BytesC = v->BlockWidth256BytesC[k];\n\t\t\tmyPipe.BlockHeight256BytesC = v->BlockHeight256BytesC[k];\n\t\t\tmyPipe.InterlaceEnable = v->Interlace[k];\n\t\t\tmyPipe.NumberOfCursors = v->NumberOfCursors[k];\n\t\t\tmyPipe.VBlank = v->VTotal[k] - v->VActive[k];\n\t\t\tmyPipe.HTotal = v->HTotal[k];\n\t\t\tmyPipe.DCCEnable = v->DCCEnable[k];\n\t\t\tmyPipe.ODMCombineIsEnabled = v->ODMCombineEnabled[k] == dm_odm_combine_mode_4to1\n\t\t\t\t\t|| v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1;\n\t\t\tmyPipe.SourcePixelFormat = v->SourcePixelFormat[k];\n\t\t\tmyPipe.BytePerPixelY = v->BytePerPixelY[k];\n\t\t\tmyPipe.BytePerPixelC = v->BytePerPixelC[k];\n\t\t\tmyPipe.ProgressiveToInterlaceUnitInOPP = v->ProgressiveToInterlaceUnitInOPP;\n\t\t\tv->ErrorResult[k] = CalculatePrefetchSchedule(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tHostVMInefficiencyFactor,\n\t\t\t\t\t&myPipe,\n\t\t\t\t\tv->DSCDelay[k],\n\t\t\t\t\tv->DPPCLKDelaySubtotal + v->DPPCLKDelayCNVCFormater,\n\t\t\t\t\tv->DPPCLKDelaySCL,\n\t\t\t\t\tv->DPPCLKDelaySCLLBOnly,\n\t\t\t\t\tv->DPPCLKDelayCNVCCursor,\n\t\t\t\t\tv->DISPCLKDelaySubtotal,\n\t\t\t\t\t(unsigned int) (v->SwathWidthY[k] / v->HRatio[k]),\n\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\t\t\tdml_min(v->VStartupLines, v->MaxVStartupLines[k]),\n\t\t\t\t\tv->MaxVStartupLines[k],\n\t\t\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->DynamicMetadataEnable[k],\n\t\t\t\t\tv->DynamicMetadataVMEnabled,\n\t\t\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->UrgentExtraLatency,\n\t\t\t\t\tv->TCalc,\n\t\t\t\t\tv->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\tv->MetaRowByte[k],\n\t\t\t\t\tv->PixelPTEBytesPerRow[k],\n\t\t\t\t\tv->PrefetchSourceLinesY[k],\n\t\t\t\t\tv->SwathWidthY[k],\n\t\t\t\t\tv->VInitPreFillY[k],\n\t\t\t\t\tv->MaxNumSwathY[k],\n\t\t\t\t\tv->PrefetchSourceLinesC[k],\n\t\t\t\t\tv->SwathWidthC[k],\n\t\t\t\t\tv->VInitPreFillC[k],\n\t\t\t\t\tv->MaxNumSwathC[k],\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tTWait,\n\t\t\t\t\t&v->DSTXAfterScaler[k],\n\t\t\t\t\t&v->DSTYAfterScaler[k],\n\t\t\t\t\t&v->DestinationLinesForPrefetch[k],\n\t\t\t\t\t&v->PrefetchBandwidth[k],\n\t\t\t\t\t&v->DestinationLinesToRequestVMInVBlank[k],\n\t\t\t\t\t&v->DestinationLinesToRequestRowInVBlank[k],\n\t\t\t\t\t&v->VRatioPrefetchY[k],\n\t\t\t\t\t&v->VRatioPrefetchC[k],\n\t\t\t\t\t&v->RequiredPrefetchPixDataBWLuma[k],\n\t\t\t\t\t&v->RequiredPrefetchPixDataBWChroma[k],\n\t\t\t\t\t&v->NotEnoughTimeForDynamicMetadata[k],\n\t\t\t\t\t&v->Tno_bw[k],\n\t\t\t\t\t&v->prefetch_vmrow_bw[k],\n\t\t\t\t\t&v->Tdmdl_vm[k],\n\t\t\t\t\t&v->Tdmdl[k],\n\t\t\t\t\t&v->TSetup[k],\n\t\t\t\t\t&v->VUpdateOffsetPix[k],\n\t\t\t\t\t&v->VUpdateWidthPix[k],\n\t\t\t\t\t&v->VReadyOffsetPix[k]);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d Prefetch cal result=%0d\\n\", __func__, k, v->ErrorResult[k]);\n#endif\n\t\t\tv->VStartup[k] = dml_min(v->VStartupLines, v->MaxVStartupLines[k]);\n\t\t}\n\n\t\tv->NoEnoughUrgentLatencyHiding = false;\n\t\tv->NoEnoughUrgentLatencyHidingPre = false;\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tv->cursor_bw[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0\n\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t\t\tv->cursor_bw_pre[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0\n\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatioPrefetchY[k];\n\n\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\t\tv->DETBufferSizeY[k],\n\t\t\t\t\tv->DETBufferSizeC[k],\n\t\t\t\t\t&v->UrgBurstFactorCursor[k],\n\t\t\t\t\t&v->UrgBurstFactorLuma[k],\n\t\t\t\t\t&v->UrgBurstFactorChroma[k],\n\t\t\t\t\t&v->NoUrgentLatencyHiding[k]);\n\n\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\tv->VRatioPrefetchY[k],\n\t\t\t\t\tv->VRatioPrefetchC[k],\n\t\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\t\tv->DETBufferSizeY[k],\n\t\t\t\t\tv->DETBufferSizeC[k],\n\t\t\t\t\t&v->UrgBurstFactorCursorPre[k],\n\t\t\t\t\t&v->UrgBurstFactorLumaPre[k],\n\t\t\t\t\t&v->UrgBurstFactorChromaPre[k],\n\t\t\t\t\t&v->NoUrgentLatencyHidingPre[k]);\n\n\t\t\tMaxTotalRDBandwidth = MaxTotalRDBandwidth\n\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] * v->UrgBurstFactorLuma[k]\n\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthPlaneChroma[k] * v->UrgBurstFactorChroma[k]\n\t\t\t\t\t\t\t\t\t+ v->cursor_bw[k] * v->UrgBurstFactorCursor[k]\n\t\t\t\t\t\t\t\t\t+ v->DPPPerPlane[k] * (v->meta_row_bw[k] + v->dpte_row_bw[k]),\n\t\t\t\t\t\t\tv->DPPPerPlane[k]\n\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixDataBWLuma[k] * v->UrgBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixDataBWChroma[k] * v->UrgBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgBurstFactorCursorPre[k]);\n\n\t\t\tMaxTotalRDBandwidthNoUrgentBurst = MaxTotalRDBandwidthNoUrgentBurst\n\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] + v->ReadBandwidthPlaneChroma[k] + v->cursor_bw[k]\n\t\t\t\t\t\t\t\t\t+ v->DPPPerPlane[k] * (v->meta_row_bw[k] + v->dpte_row_bw[k]),\n\t\t\t\t\t\t\tv->DPPPerPlane[k] * (v->RequiredPrefetchPixDataBWLuma[k] + v->RequiredPrefetchPixDataBWChroma[k])\n\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k]);\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: k=%0d DPPPerPlane=%d\\n\", __func__, k, v->DPPPerPlane[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d UrgBurstFactorLuma=%f\\n\", __func__, k, v->UrgBurstFactorLuma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d UrgBurstFactorChroma=%f\\n\", __func__, k, v->UrgBurstFactorChroma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d UrgBurstFactorLumaPre=%f\\n\", __func__, k, v->UrgBurstFactorLumaPre[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d UrgBurstFactorChromaPre=%f\\n\", __func__, k, v->UrgBurstFactorChromaPre[k]);\n\n\t\t\tdml_print(\"DML::%s: k=%0d VRatioPrefetchY=%f\\n\", __func__, k, v->VRatioPrefetchY[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d VRatioY=%f\\n\", __func__, k, v->VRatio[k]);\n\n\t\t\tdml_print(\"DML::%s: k=%0d prefetch_vmrow_bw=%f\\n\", __func__, k, v->prefetch_vmrow_bw[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d ReadBandwidthPlaneLuma=%f\\n\", __func__, k, v->ReadBandwidthPlaneLuma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d ReadBandwidthPlaneChroma=%f\\n\", __func__, k, v->ReadBandwidthPlaneChroma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d cursor_bw=%f\\n\", __func__, k, v->cursor_bw[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d meta_row_bw=%f\\n\", __func__, k, v->meta_row_bw[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d dpte_row_bw=%f\\n\", __func__, k, v->dpte_row_bw[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d RequiredPrefetchPixDataBWLuma=%f\\n\", __func__, k, v->RequiredPrefetchPixDataBWLuma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d RequiredPrefetchPixDataBWChroma=%f\\n\", __func__, k, v->RequiredPrefetchPixDataBWChroma[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d cursor_bw_pre=%f\\n\", __func__, k, v->cursor_bw_pre[k]);\n\t\t\tdml_print(\"DML::%s: k=%0d MaxTotalRDBandwidthNoUrgentBurst=%f\\n\", __func__, k, MaxTotalRDBandwidthNoUrgentBurst);\n#endif\n\n\t\t\tif (v->DestinationLinesForPrefetch[k] < 2)\n\t\t\t\tDestinationLineTimesForPrefetchLessThan2 = true;\n\n\t\t\tif (v->VRatioPrefetchY[k] > 4 || v->VRatioPrefetchC[k] > 4)\n\t\t\t\tVRatioPrefetchMoreThan4 = true;\n\n\t\t\tif (v->NoUrgentLatencyHiding[k] == true)\n\t\t\t\tv->NoEnoughUrgentLatencyHiding = true;\n\n\t\t\tif (v->NoUrgentLatencyHidingPre[k] == true)\n\t\t\t\tv->NoEnoughUrgentLatencyHidingPre = true;\n\t\t}\n\n\t\tv->FractionOfUrgentBandwidth = MaxTotalRDBandwidthNoUrgentBurst / v->ReturnBW;\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: MaxTotalRDBandwidthNoUrgentBurst=%f \\n\", __func__, MaxTotalRDBandwidthNoUrgentBurst);\n\t\tdml_print(\"DML::%s: ReturnBW=%f \\n\", __func__, v->ReturnBW);\n\t\tdml_print(\"DML::%s: FractionOfUrgentBandwidth=%f \\n\", __func__, v->FractionOfUrgentBandwidth);\n#endif\n\n\t\tif (MaxTotalRDBandwidth <= v->ReturnBW && v->NoEnoughUrgentLatencyHiding == 0 && v->NoEnoughUrgentLatencyHidingPre == 0\n\t\t\t\t&& !VRatioPrefetchMoreThan4 && !DestinationLineTimesForPrefetchLessThan2)\n\t\t\tv->PrefetchModeSupported = true;\n\t\telse {\n\t\t\tv->PrefetchModeSupported = false;\n\t\t\tdml_print(\"DML::%s: ***failed***. Bandwidth violation. Results are NOT valid\\n\", __func__);\n\t\t\tdml_print(\"DML::%s: MaxTotalRDBandwidth:%f AvailReturnBandwidth:%f\\n\", __func__, MaxTotalRDBandwidth, v->ReturnBW);\n\t\t\tdml_print(\"DML::%s: VRatioPrefetch %s more than 4\\n\", __func__, (VRatioPrefetchMoreThan4) ? \"is\" : \"is not\");\n\t\t\tdml_print(\"DML::%s: DestinationLines for Prefetch %s less than 2\\n\", __func__, (DestinationLineTimesForPrefetchLessThan2) ? \"is\" : \"is not\");\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->ErrorResult[k] == true || v->NotEnoughTimeForDynamicMetadata[k] == true) {\n\t\t\t\tv->PrefetchModeSupported = false;\n\t\t\t\tdml_print(\"DML::%s: ***failed***. Prefetch schedule violation. Results are NOT valid\\n\", __func__);\n\t\t\t}\n\t\t}\n\n\t\tif (v->PrefetchModeSupported == true && v->ImmediateFlipSupport == true) {\n\t\t\tv->BandwidthAvailableForImmediateFlip = v->ReturnBW;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->BandwidthAvailableForImmediateFlip = v->BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] * v->UrgBurstFactorLuma[k]\n\t\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthPlaneChroma[k] * v->UrgBurstFactorChroma[k]\n\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw[k] * v->UrgBurstFactorCursor[k],\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k]\n\t\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixDataBWLuma[k] * v->UrgBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixDataBWChroma[k] * v->UrgBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgBurstFactorCursorPre[k]);\n\t\t\t}\n\n\t\t\tv->TotImmediateFlipBytes = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->TotImmediateFlipBytes = v->TotImmediateFlipBytes\n\t\t\t\t\t\t+ v->DPPPerPlane[k] * (v->PDEAndMetaPTEBytesFrame[k] + v->MetaRowByte[k] + v->PixelPTEBytesPerRow[k]);\n\t\t\t}\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tk,\n\t\t\t\t\t\tHostVMInefficiencyFactor,\n\t\t\t\t\t\tv->UrgentExtraLatency,\n\t\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\t\tv->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\t\tv->MetaRowByte[k],\n\t\t\t\t\t\tv->PixelPTEBytesPerRow[k]);\n\t\t\t}\n\n\t\t\tv->total_dcn_read_bw_with_flip = 0.0;\n\t\t\tv->total_dcn_read_bw_with_flip_no_urgent_burst = 0.0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->total_dcn_read_bw_with_flip = v->total_dcn_read_bw_with_flip\n\t\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->final_flip_bw[k]\n\t\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthLuma[k] * v->UrgBurstFactorLuma[k]\n\t\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthChroma[k] * v->UrgBurstFactorChroma[k]\n\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw[k] * v->UrgBurstFactorCursor[k],\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k]\n\t\t\t\t\t\t\t\t\t\t* (v->final_flip_bw[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixDataBWLuma[k] * v->UrgBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixDataBWChroma[k] * v->UrgBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgBurstFactorCursorPre[k]);\n\t\t\t\tv->total_dcn_read_bw_with_flip_no_urgent_burst = v->total_dcn_read_bw_with_flip_no_urgent_burst\n\t\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->final_flip_bw[k] + v->ReadBandwidthPlaneLuma[k]\n\t\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthPlaneChroma[k] + v->cursor_bw[k],\n\t\t\t\t\t\t\t\tv->DPPPerPlane[k]\n\t\t\t\t\t\t\t\t\t\t* (v->final_flip_bw[k] + v->RequiredPrefetchPixDataBWLuma[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixDataBWChroma[k]) + v->cursor_bw_pre[k]);\n\t\t\t}\n\t\t\tv->FractionOfUrgentBandwidthImmediateFlip = v->total_dcn_read_bw_with_flip_no_urgent_burst / v->ReturnBW;\n\n\t\t\tv->ImmediateFlipSupported = true;\n\t\t\tif (v->total_dcn_read_bw_with_flip > v->ReturnBW) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tdml_print(\"DML::%s: total_dcn_read_bw_with_flip %f (bw w/ flip too high!)\\n\", __func__, v->total_dcn_read_bw_with_flip);\n#endif\n\t\t\t\tv->ImmediateFlipSupported = false;\n\t\t\t\tv->total_dcn_read_bw_with_flip = MaxTotalRDBandwidth;\n\t\t\t}\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (v->ImmediateFlipSupportedForPipe[k] == false) {\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\t\tdml_print(\"DML::%s: Pipe %0d not supporting iflip\\n\",\n\t\t\t\t\t\t  __func__, k);\n#endif\n\t\t\t\t\tv->ImmediateFlipSupported = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->ImmediateFlipSupported = false;\n\t\t}\n\n\t\tv->PrefetchAndImmediateFlipSupported =\n\t\t\t\t(v->PrefetchModeSupported == true && ((!v->ImmediateFlipSupport && !v->HostVMEnable\n\t\t\t\t&& v->ImmediateFlipRequirement[0] != dm_immediate_flip_required) ||\n\t\t\t\tv->ImmediateFlipSupported)) ? true : false;\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: PrefetchModeSupported %d\\n\", __func__, v->PrefetchModeSupported);\n\t\tdml_print(\"DML::%s: ImmediateFlipRequirement[0] %d\\n\", __func__, v->ImmediateFlipRequirement[0] == dm_immediate_flip_required);\n\t\tdml_print(\"DML::%s: ImmediateFlipSupported %d\\n\", __func__, v->ImmediateFlipSupported);\n\t\tdml_print(\"DML::%s: ImmediateFlipSupport %d\\n\", __func__, v->ImmediateFlipSupport);\n\t\tdml_print(\"DML::%s: HostVMEnable %d\\n\", __func__, v->HostVMEnable);\n\t\tdml_print(\"DML::%s: PrefetchAndImmediateFlipSupported %d\\n\", __func__, v->PrefetchAndImmediateFlipSupported);\n#endif\n\t\tdml_print(\"DML::%s: Done loop: Vstartup=%d, Max Vstartup is %d\\n\", __func__, v->VStartupLines, v->MaximumMaxVStartupLines);\n\n\t\tv->VStartupLines = v->VStartupLines + 1;\n\t} while (!v->PrefetchAndImmediateFlipSupported && v->VStartupLines <= v->MaximumMaxVStartupLines);\n\tASSERT(v->PrefetchAndImmediateFlipSupported);\n\n\t\n\tCalculateUnboundedRequestAndCompressedBufferSize(\n\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\tv->ConfigReturnBufferSizeInKByte,\n\t\t\tv->UseUnboundedRequesting,\n\t\t\tv->TotalActiveDPP,\n\t\t\tNoChromaPlanes,\n\t\t\tv->MaxNumDPP,\n\t\t\tv->CompressedBufferSegmentSizeInkByte,\n\t\t\tv->Output,\n\t\t\t&v->UnboundedRequestEnabled,\n\t\t\t&v->CompressedBufferSizeInkByte);\n\n\t\n\t{\n\t\tenum clock_change_support DRAMClockChangeSupport; \n\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\t\tmode_lib,\n\t\t\t\tPrefetchMode,\n\t\t\t\tv->DCFCLK,\n\t\t\t\tv->ReturnBW,\n\t\t\t\tv->UrgentLatency,\n\t\t\t\tv->UrgentExtraLatency,\n\t\t\t\tv->SOCCLK,\n\t\t\t\tv->DCFCLKDeepSleep,\n\t\t\t\tv->DETBufferSizeY,\n\t\t\t\tv->DETBufferSizeC,\n\t\t\t\tv->SwathHeightY,\n\t\t\t\tv->SwathHeightC,\n\t\t\t\tv->SwathWidthY,\n\t\t\t\tv->SwathWidthC,\n\t\t\t\tv->DPPPerPlane,\n\t\t\t\tv->BytePerPixelDETY,\n\t\t\t\tv->BytePerPixelDETC,\n\t\t\t\tv->UnboundedRequestEnabled,\n\t\t\t\tv->CompressedBufferSizeInkByte,\n\t\t\t\t&DRAMClockChangeSupport,\n\t\t\t\t&v->StutterExitWatermark,\n\t\t\t\t&v->StutterEnterPlusExitWatermark,\n\t\t\t\t&v->Z8StutterExitWatermark,\n\t\t\t\t&v->Z8StutterEnterPlusExitWatermark);\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\tv->WritebackAllowDRAMClockChangeEndPosition[k] = dml_max(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tv->VStartup[k] * v->HTotal[k] / v->PixelClock[k] - v->WritebackDRAMClockChangeWatermark);\n\t\t\t} else {\n\t\t\t\tv->WritebackAllowDRAMClockChangeEndPosition[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tCalculatePixelDeliveryTimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->VRatioPrefetchY,\n\t\t\tv->VRatioPrefetchC,\n\t\t\tv->swath_width_luma_ub,\n\t\t\tv->swath_width_chroma_ub,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->PixelClock,\n\t\t\tv->PSCL_THROUGHPUT_LUMA,\n\t\t\tv->PSCL_THROUGHPUT_CHROMA,\n\t\t\tv->DPPCLK,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->SourceScan,\n\t\t\tv->NumberOfCursors,\n\t\t\tv->CursorWidth,\n\t\t\tv->CursorBPP,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->DisplayPipeLineDeliveryTimeLuma,\n\t\t\tv->DisplayPipeLineDeliveryTimeChroma,\n\t\t\tv->DisplayPipeLineDeliveryTimeLumaPrefetch,\n\t\t\tv->DisplayPipeLineDeliveryTimeChromaPrefetch,\n\t\t\tv->DisplayPipeRequestDeliveryTimeLuma,\n\t\t\tv->DisplayPipeRequestDeliveryTimeChroma,\n\t\t\tv->DisplayPipeRequestDeliveryTimeLumaPrefetch,\n\t\t\tv->DisplayPipeRequestDeliveryTimeChromaPrefetch,\n\t\t\tv->CursorRequestDeliveryTime,\n\t\t\tv->CursorRequestDeliveryTimePrefetch);\n\n\tCalculateMetaAndPTETimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->MetaChunkSize,\n\t\t\tv->MinMetaChunkSizeBytes,\n\t\t\tv->HTotal,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->DestinationLinesToRequestRowInVBlank,\n\t\t\tv->DestinationLinesToRequestRowInImmediateFlip,\n\t\t\tv->DCCEnable,\n\t\t\tv->PixelClock,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->SourceScan,\n\t\t\tv->dpte_row_height,\n\t\t\tv->dpte_row_height_chroma,\n\t\t\tv->meta_row_width,\n\t\t\tv->meta_row_width_chroma,\n\t\t\tv->meta_row_height,\n\t\t\tv->meta_row_height_chroma,\n\t\t\tv->meta_req_width,\n\t\t\tv->meta_req_width_chroma,\n\t\t\tv->meta_req_height,\n\t\t\tv->meta_req_height_chroma,\n\t\t\tv->dpte_group_bytes,\n\t\t\tv->PTERequestSizeY,\n\t\t\tv->PTERequestSizeC,\n\t\t\tv->PixelPTEReqWidthY,\n\t\t\tv->PixelPTEReqHeightY,\n\t\t\tv->PixelPTEReqWidthC,\n\t\t\tv->PixelPTEReqHeightC,\n\t\t\tv->dpte_row_width_luma_ub,\n\t\t\tv->dpte_row_width_chroma_ub,\n\t\t\tv->DST_Y_PER_PTE_ROW_NOM_L,\n\t\t\tv->DST_Y_PER_PTE_ROW_NOM_C,\n\t\t\tv->DST_Y_PER_META_ROW_NOM_L,\n\t\t\tv->DST_Y_PER_META_ROW_NOM_C,\n\t\t\tv->TimePerMetaChunkNominal,\n\t\t\tv->TimePerChromaMetaChunkNominal,\n\t\t\tv->TimePerMetaChunkVBlank,\n\t\t\tv->TimePerChromaMetaChunkVBlank,\n\t\t\tv->TimePerMetaChunkFlip,\n\t\t\tv->TimePerChromaMetaChunkFlip,\n\t\t\tv->time_per_pte_group_nom_luma,\n\t\t\tv->time_per_pte_group_vblank_luma,\n\t\t\tv->time_per_pte_group_flip_luma,\n\t\t\tv->time_per_pte_group_nom_chroma,\n\t\t\tv->time_per_pte_group_vblank_chroma,\n\t\t\tv->time_per_pte_group_flip_chroma);\n\n\tCalculateVMGroupAndRequestTimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\tv->HTotal,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->DestinationLinesToRequestVMInVBlank,\n\t\t\tv->DestinationLinesToRequestVMInImmediateFlip,\n\t\t\tv->DCCEnable,\n\t\t\tv->PixelClock,\n\t\t\tv->dpte_row_width_luma_ub,\n\t\t\tv->dpte_row_width_chroma_ub,\n\t\t\tv->vm_group_bytes,\n\t\t\tv->dpde0_bytes_per_frame_ub_l,\n\t\t\tv->dpde0_bytes_per_frame_ub_c,\n\t\t\tv->meta_pte_bytes_per_frame_ub_l,\n\t\t\tv->meta_pte_bytes_per_frame_ub_c,\n\t\t\tv->TimePerVMGroupVBlank,\n\t\t\tv->TimePerVMGroupFlip,\n\t\t\tv->TimePerVMRequestVBlank,\n\t\t\tv->TimePerVMRequestFlip);\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (PrefetchMode == 0) {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = true;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tv->MinTTUVBlank[k] = dml_max(\n\t\t\t\t\tv->DRAMClockChangeWatermark,\n\t\t\t\t\tdml_max(v->StutterEnterPlusExitWatermark, v->UrgentWatermark));\n\t\t} else if (PrefetchMode == 1) {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tv->MinTTUVBlank[k] = dml_max(v->StutterEnterPlusExitWatermark, v->UrgentWatermark);\n\t\t} else {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = false;\n\t\t\tv->MinTTUVBlank[k] = v->UrgentWatermark;\n\t\t}\n\t\tif (!v->DynamicMetadataEnable[k])\n\t\t\tv->MinTTUVBlank[k] = v->TCalc + v->MinTTUVBlank[k];\n\t}\n\n\t\n\tv->ActiveDPPs = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tCalculateDCCConfiguration(v->DCCEnable[k], false, \n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceWidthY[k],\n\t\t\t\tv->SurfaceWidthC[k],\n\t\t\t\tv->SurfaceHeightY[k],\n\t\t\t\tv->SurfaceHeightC[k],\n\t\t\t\tv->DETBufferSizeInKByte[k] * 1024,\n\t\t\t\tv->BlockHeight256BytesY[k],\n\t\t\t\tv->BlockHeight256BytesC[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\tv->SourceScan[k],\n\t\t\t\t&v->DCCYMaxUncompressedBlock[k],\n\t\t\t\t&v->DCCCMaxUncompressedBlock[k],\n\t\t\t\t&v->DCCYMaxCompressedBlock[k],\n\t\t\t\t&v->DCCCMaxCompressedBlock[k],\n\t\t\t\t&v->DCCYIndependentBlock[k],\n\t\t\t\t&v->DCCCIndependentBlock[k]);\n\t}\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tbool isInterlaceTiming;\n\t\tdouble Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock[k];\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f (before margin)\\n\", __func__, k, v->MinTTUVBlank[k]);\n#endif\n\n\t\tv->MinTTUVBlank[k] = v->MinTTUVBlank[k] + Tvstartup_margin;\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, Tvstartup_margin = %f\\n\", __func__, k, Tvstartup_margin);\n\t\tdml_print(\"DML::%s: k=%d, MaxVStartupLines = %d\\n\", __func__, k, v->MaxVStartupLines[k]);\n\t\tdml_print(\"DML::%s: k=%d, VStartup = %d\\n\", __func__, k, v->VStartup[k]);\n\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f\\n\", __func__, k, v->MinTTUVBlank[k]);\n#endif\n\n\t\tv->Tdmdl[k] = v->Tdmdl[k] + Tvstartup_margin;\n\t\tif (v->DynamicMetadataEnable[k] && v->DynamicMetadataVMEnabled) {\n\t\t\tv->Tdmdl_vm[k] = v->Tdmdl_vm[k] + Tvstartup_margin;\n\t\t}\n\n\t\tisInterlaceTiming = (v->Interlace[k] && !v->ProgressiveToInterlaceUnitInOPP);\n\n\t\tv->MIN_DST_Y_NEXT_START[k] = ((isInterlaceTiming ? dml_floor((v->VTotal[k] - v->VFrontPorch[k]) / 2.0, 1.0) : v->VTotal[k])\n\t\t\t\t- v->VFrontPorch[k])\n\t\t\t\t+ dml_max(1.0, dml_ceil(v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock[k]), 1.0))\n\t\t\t\t+ dml_floor(4.0 * v->TSetup[k] / (v->HTotal[k] / v->PixelClock[k]), 1.0) / 4.0;\n\n\t\tv->VStartup[k] = (isInterlaceTiming ? (2 * v->MaxVStartupLines[k]) : v->MaxVStartupLines[k]);\n\n\t\tif (((v->VUpdateOffsetPix[k] + v->VUpdateWidthPix[k] + v->VReadyOffsetPix[k]) / v->HTotal[k])\n\t\t\t\t<= (isInterlaceTiming ?\n\t\t\t\t\t\tdml_floor((v->VTotal[k] - v->VActive[k] - v->VFrontPorch[k] - v->VStartup[k]) / 2.0, 1.0) :\n\t\t\t\t\t\t(int) (v->VTotal[k] - v->VActive[k] - v->VFrontPorch[k] - v->VStartup[k]))) {\n\t\t\tv->VREADY_AT_OR_AFTER_VSYNC[k] = true;\n\t\t} else {\n\t\t\tv->VREADY_AT_OR_AFTER_VSYNC[k] = false;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d, VStartup = %d (max)\\n\", __func__, k, v->VStartup[k]);\n\t\tdml_print(\"DML::%s: k=%d, VUpdateOffsetPix = %d\\n\", __func__, k, v->VUpdateOffsetPix[k]);\n\t\tdml_print(\"DML::%s: k=%d, VUpdateWidthPix = %d\\n\", __func__, k, v->VUpdateWidthPix[k]);\n\t\tdml_print(\"DML::%s: k=%d, VReadyOffsetPix = %d\\n\", __func__, k, v->VReadyOffsetPix[k]);\n\t\tdml_print(\"DML::%s: k=%d, HTotal = %d\\n\", __func__, k, v->HTotal[k]);\n\t\tdml_print(\"DML::%s: k=%d, VTotal = %d\\n\", __func__, k, v->VTotal[k]);\n\t\tdml_print(\"DML::%s: k=%d, VActive = %d\\n\", __func__, k, v->VActive[k]);\n\t\tdml_print(\"DML::%s: k=%d, VFrontPorch = %d\\n\", __func__, k, v->VFrontPorch[k]);\n\t\tdml_print(\"DML::%s: k=%d, VStartup = %d\\n\", __func__, k, v->VStartup[k]);\n\t\tdml_print(\"DML::%s: k=%d, MIN_DST_Y_NEXT_START = %f\\n\", __func__, k, v->MIN_DST_Y_NEXT_START[k]);\n\t\tdml_print(\"DML::%s: k=%d, VREADY_AT_OR_AFTER_VSYNC = %d\\n\", __func__, k, v->VREADY_AT_OR_AFTER_VSYNC[k]);\n#endif\n\t}\n\n\t{\n\t\t\n\t\tdouble TotalWRBandwidth = 0;\n\t\tdouble MaxPerPlaneVActiveWRBandwidth = 0;\n\t\tdouble WRBandwidth = 0;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->WritebackEnable[k] == true && v->WritebackPixelFormat[k] == dm_444_32) {\n\t\t\t\tWRBandwidth = v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k]\n\t\t\t\t\t\t/ (v->HTotal[k] * v->WritebackSourceHeight[k] / v->PixelClock[k]) * 4;\n\t\t\t} else if (v->WritebackEnable[k] == true) {\n\t\t\t\tWRBandwidth = v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k]\n\t\t\t\t\t\t/ (v->HTotal[k] * v->WritebackSourceHeight[k] / v->PixelClock[k]) * 8;\n\t\t\t}\n\t\t\tTotalWRBandwidth = TotalWRBandwidth + WRBandwidth;\n\t\t\tMaxPerPlaneVActiveWRBandwidth = dml_max(MaxPerPlaneVActiveWRBandwidth, WRBandwidth);\n\t\t}\n\n\t\tv->TotalDataReadBandwidth = 0;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tv->TotalDataReadBandwidth = v->TotalDataReadBandwidth + v->ReadBandwidthPlaneLuma[k] + v->ReadBandwidthPlaneChroma[k];\n\t\t}\n\t}\n\t\n\tCalculateStutterEfficiency(\n\t\t\tmode_lib,\n\t\t\tv->CompressedBufferSizeInkByte,\n\t\t\tv->UnboundedRequestEnabled,\n\t\t\tv->ConfigReturnBufferSizeInKByte,\n\t\t\tv->MetaFIFOSizeInKEntries,\n\t\t\tv->ZeroSizeBufferEntries,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->ROBBufferSizeInKByte,\n\t\t\tv->TotalDataReadBandwidth,\n\t\t\tv->DCFCLK,\n\t\t\tv->ReturnBW,\n\t\t\tv->COMPBUF_RESERVED_SPACE_64B,\n\t\t\tv->COMPBUF_RESERVED_SPACE_ZS,\n\t\t\tv->SRExitTime,\n\t\t\tv->SRExitZ8Time,\n\t\t\tv->SynchronizedVBlank,\n\t\t\tv->StutterEnterPlusExitWatermark,\n\t\t\tv->Z8StutterEnterPlusExitWatermark,\n\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\tv->Interlace,\n\t\t\tv->MinTTUVBlank,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->DETBufferSizeY,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelDETY,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathHeightY,\n\t\t\tv->SwathHeightC,\n\t\t\tv->DCCRateLuma,\n\t\t\tv->DCCRateChroma,\n\t\t\tv->DCCFractionOfZeroSizeRequestsLuma,\n\t\t\tv->DCCFractionOfZeroSizeRequestsChroma,\n\t\t\tv->HTotal,\n\t\t\tv->VTotal,\n\t\t\tv->PixelClock,\n\t\t\tv->VRatio,\n\t\t\tv->SourceScan,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->DCCYMaxUncompressedBlock,\n\t\t\tv->DCCCMaxUncompressedBlock,\n\t\t\tv->VActive,\n\t\t\tv->DCCEnable,\n\t\t\tv->WritebackEnable,\n\t\t\tv->ReadBandwidthPlaneLuma,\n\t\t\tv->ReadBandwidthPlaneChroma,\n\t\t\tv->meta_row_bw,\n\t\t\tv->dpte_row_bw,\n\t\t\t&v->StutterEfficiencyNotIncludingVBlank,\n\t\t\t&v->StutterEfficiency,\n\t\t\t&v->NumberOfStutterBurstsPerFrame,\n\t\t\t&v->Z8StutterEfficiencyNotIncludingVBlank,\n\t\t\t&v->Z8StutterEfficiency,\n\t\t\t&v->Z8NumberOfStutterBurstsPerFrame,\n\t\t\t&v->StutterPeriod);\n}\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\t\n\tdouble BytePerPixDETY[DC__NUM_DPP__MAX];\n\tdouble BytePerPixDETC[DC__NUM_DPP__MAX];\n\tint BytePerPixY[DC__NUM_DPP__MAX];\n\tint BytePerPixC[DC__NUM_DPP__MAX];\n\tint Read256BytesBlockHeightY[DC__NUM_DPP__MAX];\n\tint Read256BytesBlockHeightC[DC__NUM_DPP__MAX];\n\tint Read256BytesBlockWidthY[DC__NUM_DPP__MAX];\n\tint Read256BytesBlockWidthC[DC__NUM_DPP__MAX];\n\tdouble dummy1[DC__NUM_DPP__MAX];\n\tdouble dummy2[DC__NUM_DPP__MAX];\n\tdouble dummy3[DC__NUM_DPP__MAX];\n\tdouble dummy4[DC__NUM_DPP__MAX];\n\tint dummy5[DC__NUM_DPP__MAX];\n\tint dummy6[DC__NUM_DPP__MAX];\n\tbool dummy7[DC__NUM_DPP__MAX];\n\tbool dummysinglestring;\n\n\tunsigned int k;\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t&BytePerPixY[k],\n\t\t\t\t&BytePerPixC[k],\n\t\t\t\t&BytePerPixDETY[k],\n\t\t\t\t&BytePerPixDETC[k],\n\t\t\t\t&Read256BytesBlockHeightY[k],\n\t\t\t\t&Read256BytesBlockHeightC[k],\n\t\t\t\t&Read256BytesBlockWidthY[k],\n\t\t\t\t&Read256BytesBlockWidthC[k]);\n\t}\n\n\tCalculateSwathAndDETConfiguration(\n\t\t\tfalse,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tmode_lib->project == DML_PROJECT_DCN315 && v->DETSizeOverride[0],\n\t\t\tv->DETBufferSizeInKByte,\n\t\t\tdummy1,\n\t\t\tdummy2,\n\t\t\tv->SourceScan,\n\t\t\tv->SourcePixelFormat,\n\t\t\tv->SurfaceTiling,\n\t\t\tv->ViewportWidth,\n\t\t\tv->ViewportHeight,\n\t\t\tv->SurfaceWidthY,\n\t\t\tv->SurfaceWidthC,\n\t\t\tv->SurfaceHeightY,\n\t\t\tv->SurfaceHeightC,\n\t\t\tRead256BytesBlockHeightY,\n\t\t\tRead256BytesBlockHeightC,\n\t\t\tRead256BytesBlockWidthY,\n\t\t\tRead256BytesBlockWidthC,\n\t\t\tv->ODMCombineEnabled,\n\t\t\tv->BlendingAndTiming,\n\t\t\tBytePerPixY,\n\t\t\tBytePerPixC,\n\t\t\tBytePerPixDETY,\n\t\t\tBytePerPixDETC,\n\t\t\tv->HActive,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->DPPPerPlane,\n\t\t\tdummy5,\n\t\t\tdummy6,\n\t\t\tdummy3,\n\t\t\tdummy4,\n\t\t\tv->SwathHeightY,\n\t\t\tv->SwathHeightC,\n\t\t\tv->DETBufferSizeY,\n\t\t\tv->DETBufferSizeC,\n\t\t\tdummy7,\n\t\t\t&dummysinglestring);\n}\n\nstatic double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime)\n{\n\tif (PrefetchMode == 0) {\n\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency, dml_max(SREnterPlusExitTime, UrgentLatency));\n\t} else if (PrefetchMode == 1) {\n\t\treturn dml_max(SREnterPlusExitTime, UrgentLatency);\n\t} else {\n\t\treturn UrgentLatency;\n\t}\n}\n\ndouble dml31_CalculateWriteBackDISPCLK(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble PixelClock,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackHTaps,\n\t\tunsigned int WritebackVTaps,\n\t\tlong WritebackSourceWidth,\n\t\tlong WritebackDestinationWidth,\n\t\tunsigned int HTotal,\n\t\tunsigned int WritebackLineBufferSize)\n{\n\tdouble DISPCLK_H, DISPCLK_V, DISPCLK_HB;\n\n\tDISPCLK_H = PixelClock * dml_ceil(WritebackHTaps / 8.0, 1) / WritebackHRatio;\n\tDISPCLK_V = PixelClock * (WritebackVTaps * dml_ceil(WritebackDestinationWidth / 6.0, 1) + 8.0) / HTotal;\n\tDISPCLK_HB = PixelClock * WritebackVTaps * (WritebackDestinationWidth * WritebackVTaps - WritebackLineBufferSize / 57.0) / 6.0 / WritebackSourceWidth;\n\treturn dml_max3(DISPCLK_H, DISPCLK_V, DISPCLK_HB);\n}\n\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackVTaps,\n\t\tint WritebackDestinationWidth,\n\t\tint WritebackDestinationHeight,\n\t\tint WritebackSourceHeight,\n\t\tunsigned int HTotal)\n{\n\tdouble CalculateWriteBackDelay;\n\tdouble Line_length;\n\tdouble Output_lines_last_notclamped;\n\tdouble WritebackVInit;\n\n\tWritebackVInit = (WritebackVRatio + WritebackVTaps + 1) / 2;\n\tLine_length = dml_max((double) WritebackDestinationWidth, dml_ceil(WritebackDestinationWidth / 6.0, 1) * WritebackVTaps);\n\tOutput_lines_last_notclamped = WritebackDestinationHeight - 1 - dml_ceil((WritebackSourceHeight - WritebackVInit) / WritebackVRatio, 1);\n\tif (Output_lines_last_notclamped < 0) {\n\t\tCalculateWriteBackDelay = 0;\n\t} else {\n\t\tCalculateWriteBackDelay = Output_lines_last_notclamped * Line_length + (HTotal - WritebackDestinationWidth) + 80;\n\t}\n\treturn CalculateWriteBackDelay;\n}\n\nstatic void CalculateVupdateAndDynamicMetadataParameters(\n\t\tint MaxInterDCNTileRepeaters,\n\t\tdouble DPPCLK,\n\t\tdouble DISPCLK,\n\t\tdouble DCFClkDeepSleep,\n\t\tdouble PixelClock,\n\t\tint HTotal,\n\t\tint VBlank,\n\t\tint DynamicMetadataTransmittedBytes,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tint InterlaceEnable,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *TSetup,\n\t\tdouble *Tdmbf,\n\t\tdouble *Tdmec,\n\t\tdouble *Tdmsks,\n\t\tint *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix)\n{\n\tdouble TotalRepeaterDelayTime;\n\n\tTotalRepeaterDelayTime = MaxInterDCNTileRepeaters * (2 / DPPCLK + 3 / DISPCLK);\n\t*VUpdateWidthPix = dml_ceil((14.0 / DCFClkDeepSleep + 12.0 / DPPCLK + TotalRepeaterDelayTime) * PixelClock, 1.0);\n\t*VReadyOffsetPix = dml_ceil(dml_max(150.0 / DPPCLK, TotalRepeaterDelayTime + 20.0 / DCFClkDeepSleep + 10.0 / DPPCLK) * PixelClock, 1.0);\n\t*VUpdateOffsetPix = dml_ceil(HTotal / 4.0, 1);\n\t*TSetup = (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;\n\t*Tdmbf = DynamicMetadataTransmittedBytes / 4.0 / DISPCLK;\n\t*Tdmec = HTotal / PixelClock;\n\tif (DynamicMetadataLinesBeforeActiveRequired == 0) {\n\t\t*Tdmsks = VBlank * HTotal / PixelClock / 2.0;\n\t} else {\n\t\t*Tdmsks = DynamicMetadataLinesBeforeActiveRequired * HTotal / PixelClock;\n\t}\n\tif (InterlaceEnable == 1 && ProgressiveToInterlaceUnitInOPP == false) {\n\t\t*Tdmsks = *Tdmsks / 2;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VUpdateWidthPix = %d\\n\", __func__, *VUpdateWidthPix);\n\tdml_print(\"DML::%s: VReadyOffsetPix = %d\\n\", __func__, *VReadyOffsetPix);\n\tdml_print(\"DML::%s: VUpdateOffsetPix = %d\\n\", __func__, *VUpdateOffsetPix);\n#endif\n}\n\nstatic void CalculateRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw)\n{\n\tif (DCCEnable != true) {\n\t\t*meta_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime) + VRatioChroma * MetaRowByteChroma / (meta_row_height_chroma * LineTime);\n\t} else {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime);\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*dpte_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime)\n\t\t\t\t+ VRatioChroma * PixelPTEBytesPerRowChroma / (dpte_row_height_chroma * LineTime);\n\t} else {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime);\n\t}\n}\n\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int k,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tdouble min_row_time = 0.0;\n\tunsigned int HostVMDynamicLevelsTrips;\n\tdouble TimeForFetchingMetaPTEImmediateFlip;\n\tdouble TimeForFetchingRowInVBlankImmediateFlip;\n\tdouble ImmediateFlipBW = 1.0;\n\tdouble LineTime = v->HTotal[k] / v->PixelClock[k];\n\n\tif (v->GPUVMEnable == true && v->HostVMEnable == true) {\n\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;\n\t} else {\n\t\tHostVMDynamicLevelsTrips = 0;\n\t}\n\n\tif (v->GPUVMEnable == true || v->DCCEnable[k] == true) {\n\t\tImmediateFlipBW = (PDEAndMetaPTEBytesPerFrame + MetaRowBytes + DPTEBytesPerRow) * v->BandwidthAvailableForImmediateFlip / v->TotImmediateFlipBytes;\n\t}\n\n\tif (v->GPUVMEnable == true) {\n\t\tTimeForFetchingMetaPTEImmediateFlip = dml_max3(\n\t\t\t\tv->Tno_bw[k] + PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / ImmediateFlipBW,\n\t\t\t\tUrgentExtraLatency + UrgentLatency * (v->GPUVMMaxPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1),\n\t\t\t\tLineTime / 4.0);\n\t} else {\n\t\tTimeForFetchingMetaPTEImmediateFlip = 0;\n\t}\n\n\tv->DestinationLinesToRequestVMInImmediateFlip[k] = dml_ceil(4.0 * (TimeForFetchingMetaPTEImmediateFlip / LineTime), 1) / 4.0;\n\tif ((v->GPUVMEnable == true || v->DCCEnable[k] == true)) {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = dml_max3(\n\t\t\t\t(MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / ImmediateFlipBW,\n\t\t\t\tUrgentLatency * (HostVMDynamicLevelsTrips + 1),\n\t\t\t\tLineTime / 4);\n\t} else {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = 0;\n\t}\n\n\tv->DestinationLinesToRequestRowInImmediateFlip[k] = dml_ceil(4.0 * (TimeForFetchingRowInVBlankImmediateFlip / LineTime), 1) / 4.0;\n\n\tif (v->GPUVMEnable == true) {\n\t\tv->final_flip_bw[k] = dml_max(\n\t\t\t\tPDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / (v->DestinationLinesToRequestVMInImmediateFlip[k] * LineTime),\n\t\t\t\t(MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / (v->DestinationLinesToRequestRowInImmediateFlip[k] * LineTime));\n\t} else if ((v->GPUVMEnable == true || v->DCCEnable[k] == true)) {\n\t\tv->final_flip_bw[k] = (MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / (v->DestinationLinesToRequestRowInImmediateFlip[k] * LineTime);\n\t} else {\n\t\tv->final_flip_bw[k] = 0;\n\t}\n\n\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\tif (v->GPUVMEnable == true && v->DCCEnable[k] != true) {\n\t\t\tmin_row_time = dml_min(v->dpte_row_height[k] * LineTime / v->VRatio[k], v->dpte_row_height_chroma[k] * LineTime / v->VRatioChroma[k]);\n\t\t} else if (v->GPUVMEnable != true && v->DCCEnable[k] == true) {\n\t\t\tmin_row_time = dml_min(v->meta_row_height[k] * LineTime / v->VRatio[k], v->meta_row_height_chroma[k] * LineTime / v->VRatioChroma[k]);\n\t\t} else {\n\t\t\tmin_row_time = dml_min4(\n\t\t\t\t\tv->dpte_row_height[k] * LineTime / v->VRatio[k],\n\t\t\t\t\tv->meta_row_height[k] * LineTime / v->VRatio[k],\n\t\t\t\t\tv->dpte_row_height_chroma[k] * LineTime / v->VRatioChroma[k],\n\t\t\t\t\tv->meta_row_height_chroma[k] * LineTime / v->VRatioChroma[k]);\n\t\t}\n\t} else {\n\t\tif (v->GPUVMEnable == true && v->DCCEnable[k] != true) {\n\t\t\tmin_row_time = v->dpte_row_height[k] * LineTime / v->VRatio[k];\n\t\t} else if (v->GPUVMEnable != true && v->DCCEnable[k] == true) {\n\t\t\tmin_row_time = v->meta_row_height[k] * LineTime / v->VRatio[k];\n\t\t} else {\n\t\t\tmin_row_time = dml_min(v->dpte_row_height[k] * LineTime / v->VRatio[k], v->meta_row_height[k] * LineTime / v->VRatio[k]);\n\t\t}\n\t}\n\n\tif (v->DestinationLinesToRequestVMInImmediateFlip[k] >= 32 || v->DestinationLinesToRequestRowInImmediateFlip[k] >= 16\n\t\t\t|| TimeForFetchingMetaPTEImmediateFlip + 2 * TimeForFetchingRowInVBlankImmediateFlip > min_row_time) {\n\t\tv->ImmediateFlipSupportedForPipe[k] = false;\n\t} else {\n\t\tv->ImmediateFlipSupportedForPipe[k] = true;\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: DestinationLinesToRequestVMInImmediateFlip = %f\\n\", __func__, v->DestinationLinesToRequestVMInImmediateFlip[k]);\n\tdml_print(\"DML::%s: DestinationLinesToRequestRowInImmediateFlip = %f\\n\", __func__, v->DestinationLinesToRequestRowInImmediateFlip[k]);\n\tdml_print(\"DML::%s: TimeForFetchingMetaPTEImmediateFlip = %f\\n\", __func__, TimeForFetchingMetaPTEImmediateFlip);\n\tdml_print(\"DML::%s: TimeForFetchingRowInVBlankImmediateFlip = %f\\n\", __func__, TimeForFetchingRowInVBlankImmediateFlip);\n\tdml_print(\"DML::%s: min_row_time = %f\\n\", __func__, min_row_time);\n\tdml_print(\"DML::%s: ImmediateFlipSupportedForPipe = %d\\n\", __func__, v->ImmediateFlipSupportedForPipe[k]);\n#endif\n\n}\n\nstatic double TruncToValidBPP(\n\t\tdouble LinkBitRate,\n\t\tint Lanes,\n\t\tint HTotal,\n\t\tint HActive,\n\t\tdouble PixelClock,\n\t\tdouble DesiredBPP,\n\t\tbool DSCEnable,\n\t\tenum output_encoder_class Output,\n\t\tenum output_format_class Format,\n\t\tunsigned int DSCInputBitPerComponent,\n\t\tint DSCSlices,\n\t\tint AudioRate,\n\t\tint AudioLayout,\n\t\tenum odm_combine_mode ODMCombine)\n{\n\tdouble MaxLinkBPP;\n\tint MinDSCBPP;\n\tdouble MaxDSCBPP;\n\tint NonDSCBPP0;\n\tint NonDSCBPP1;\n\tint NonDSCBPP2;\n\n\tif (Format == dm_420) {\n\t\tNonDSCBPP0 = 12;\n\t\tNonDSCBPP1 = 15;\n\t\tNonDSCBPP2 = 18;\n\t\tMinDSCBPP = 6;\n\t\tMaxDSCBPP = 1.5 * DSCInputBitPerComponent - 1 / 16;\n\t} else if (Format == dm_444) {\n\t\tNonDSCBPP0 = 24;\n\t\tNonDSCBPP1 = 30;\n\t\tNonDSCBPP2 = 36;\n\t\tMinDSCBPP = 8;\n\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16;\n\t} else {\n\n\t\tNonDSCBPP0 = 16;\n\t\tNonDSCBPP1 = 20;\n\t\tNonDSCBPP2 = 24;\n\n\t\tif (Format == dm_n422) {\n\t\t\tMinDSCBPP = 7;\n\t\t\tMaxDSCBPP = 2 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t} else {\n\t\t\tMinDSCBPP = 8;\n\t\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t}\n\t}\n\n\tif (DSCEnable && Output == dm_dp) {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock * (1 - 2.4 / 100);\n\t} else {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock;\n\t}\n\n\tif (ODMCombine == dm_odm_combine_mode_4to1 && MaxLinkBPP > 16) {\n\t\tMaxLinkBPP = 16;\n\t} else if (ODMCombine == dm_odm_combine_mode_2to1 && MaxLinkBPP > 32) {\n\t\tMaxLinkBPP = 32;\n\t}\n\n\tif (DesiredBPP == 0) {\n\t\tif (DSCEnable) {\n\t\t\tif (MaxLinkBPP < MinDSCBPP) {\n\t\t\t\treturn BPP_INVALID;\n\t\t\t} else if (MaxLinkBPP >= MaxDSCBPP) {\n\t\t\t\treturn MaxDSCBPP;\n\t\t\t} else {\n\t\t\t\treturn dml_floor(16.0 * MaxLinkBPP, 1.0) / 16.0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (MaxLinkBPP >= NonDSCBPP2) {\n\t\t\t\treturn NonDSCBPP2;\n\t\t\t} else if (MaxLinkBPP >= NonDSCBPP1) {\n\t\t\t\treturn NonDSCBPP1;\n\t\t\t} else if (MaxLinkBPP >= NonDSCBPP0) {\n\t\t\t\treturn 16.0;\n\t\t\t} else {\n\t\t\t\treturn BPP_INVALID;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!((DSCEnable == false && (DesiredBPP == NonDSCBPP2 || DesiredBPP == NonDSCBPP1 || DesiredBPP <= NonDSCBPP0))\n\t\t\t\t|| (DSCEnable && DesiredBPP >= MinDSCBPP && DesiredBPP <= MaxDSCBPP))) {\n\t\t\treturn BPP_INVALID;\n\t\t} else {\n\t\t\treturn DesiredBPP;\n\t\t}\n\t}\n\treturn BPP_INVALID;\n}\n\nstatic noinline void CalculatePrefetchSchedulePerPlane(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble HostVMInefficiencyFactor,\n\t\tint i,\n\t\tunsigned j,\n\t\tunsigned k)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tPipe myPipe;\n\n\tmyPipe.DPPCLK = v->RequiredDPPCLK[i][j][k];\n\tmyPipe.DISPCLK = v->RequiredDISPCLK[i][j];\n\tmyPipe.PixelClock = v->PixelClock[k];\n\tmyPipe.DCFCLKDeepSleep = v->ProjectedDCFCLKDeepSleep[i][j];\n\tmyPipe.DPPPerPlane = v->NoOfDPP[i][j][k];\n\tmyPipe.ScalerEnabled = v->ScalerEnabled[k];\n\tmyPipe.VRatio = mode_lib->vba.VRatio[k];\n\tmyPipe.VRatioChroma = mode_lib->vba.VRatioChroma[k];\n\n\tmyPipe.SourceScan = v->SourceScan[k];\n\tmyPipe.BlockWidth256BytesY = v->Read256BlockWidthY[k];\n\tmyPipe.BlockHeight256BytesY = v->Read256BlockHeightY[k];\n\tmyPipe.BlockWidth256BytesC = v->Read256BlockWidthC[k];\n\tmyPipe.BlockHeight256BytesC = v->Read256BlockHeightC[k];\n\tmyPipe.InterlaceEnable = v->Interlace[k];\n\tmyPipe.NumberOfCursors = v->NumberOfCursors[k];\n\tmyPipe.VBlank = v->VTotal[k] - v->VActive[k];\n\tmyPipe.HTotal = v->HTotal[k];\n\tmyPipe.DCCEnable = v->DCCEnable[k];\n\tmyPipe.ODMCombineIsEnabled = v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1\n\t\t|| v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1;\n\tmyPipe.SourcePixelFormat = v->SourcePixelFormat[k];\n\tmyPipe.BytePerPixelY = v->BytePerPixelY[k];\n\tmyPipe.BytePerPixelC = v->BytePerPixelC[k];\n\tmyPipe.ProgressiveToInterlaceUnitInOPP = v->ProgressiveToInterlaceUnitInOPP;\n\tv->NoTimeForPrefetch[i][j][k] = CalculatePrefetchSchedule(\n\t\tmode_lib,\n\t\tHostVMInefficiencyFactor,\n\t\t&myPipe,\n\t\tv->DSCDelayPerState[i][k],\n\t\tv->DPPCLKDelaySubtotal + v->DPPCLKDelayCNVCFormater,\n\t\tv->DPPCLKDelaySCL,\n\t\tv->DPPCLKDelaySCLLBOnly,\n\t\tv->DPPCLKDelayCNVCCursor,\n\t\tv->DISPCLKDelaySubtotal,\n\t\tv->SwathWidthYThisState[k] / v->HRatio[k],\n\t\tv->OutputFormat[k],\n\t\tv->MaxInterDCNTileRepeaters,\n\t\tdml_min(v->MaxVStartup, v->MaximumVStartup[i][j][k]),\n\t\tv->MaximumVStartup[i][j][k],\n\t\tv->GPUVMMaxPageTableLevels,\n\t\tv->GPUVMEnable,\n\t\tv->HostVMEnable,\n\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\tv->HostVMMinPageSize,\n\t\tv->DynamicMetadataEnable[k],\n\t\tv->DynamicMetadataVMEnabled,\n\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\tv->UrgLatency[i],\n\t\tv->ExtraLatency,\n\t\tv->TimeCalc,\n\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k],\n\t\tv->MetaRowBytes[i][j][k],\n\t\tv->DPTEBytesPerRow[i][j][k],\n\t\tv->PrefetchLinesY[i][j][k],\n\t\tv->SwathWidthYThisState[k],\n\t\tv->PrefillY[k],\n\t\tv->MaxNumSwY[k],\n\t\tv->PrefetchLinesC[i][j][k],\n\t\tv->SwathWidthCThisState[k],\n\t\tv->PrefillC[k],\n\t\tv->MaxNumSwC[k],\n\t\tv->swath_width_luma_ub_this_state[k],\n\t\tv->swath_width_chroma_ub_this_state[k],\n\t\tv->SwathHeightYThisState[k],\n\t\tv->SwathHeightCThisState[k],\n\t\tv->TWait,\n\t\t&v->DSTXAfterScaler[k],\n\t\t&v->DSTYAfterScaler[k],\n\t\t&v->LineTimesForPrefetch[k],\n\t\t&v->PrefetchBW[k],\n\t\t&v->LinesForMetaPTE[k],\n\t\t&v->LinesForMetaAndDPTERow[k],\n\t\t&v->VRatioPreY[i][j][k],\n\t\t&v->VRatioPreC[i][j][k],\n\t\t&v->RequiredPrefetchPixelDataBWLuma[i][j][k],\n\t\t&v->RequiredPrefetchPixelDataBWChroma[i][j][k],\n\t\t&v->NoTimeForDynamicMetadata[i][j][k],\n\t\t&v->Tno_bw[k],\n\t\t&v->prefetch_vmrow_bw[k],\n\t\t&v->dummy7[k],\n\t\t&v->dummy8[k],\n\t\t&v->dummy13[k],\n\t\t&v->VUpdateOffsetPix[k],\n\t\t&v->VUpdateWidthPix[k],\n\t\t&v->VReadyOffsetPix[k]);\n}\n\nstatic void PatchDETBufferSizeInKByte(unsigned int NumberOfActivePlanes, int NoOfDPPThisState[], unsigned int config_return_buffer_size_in_kbytes, unsigned int DETBufferSizeInKByte[])\n{\n\tint i, total_pipes = 0;\n\tfor (i = 0; i < NumberOfActivePlanes; i++)\n\t\ttotal_pipes += NoOfDPPThisState[i];\n\tDETBufferSizeInKByte[0] = ((config_return_buffer_size_in_kbytes - DCN3_15_MIN_COMPBUF_SIZE_KB) / 64 / total_pipes) * 64;\n\tif (DETBufferSizeInKByte[0] > DCN3_15_MAX_DET_SIZE)\n\t\tDETBufferSizeInKByte[0] = DCN3_15_MAX_DET_SIZE;\n\tfor (i = 1; i < NumberOfActivePlanes; i++)\n\t\tDETBufferSizeInKByte[i] = DETBufferSizeInKByte[0];\n}\n\n\nvoid dml31_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\n\tint i, j;\n\tunsigned int k, m;\n\tint ReorderingBytes;\n\tint MinPrefetchMode = 0, MaxPrefetchMode = 2;\n\tbool NoChroma = true;\n\tbool EnoughWritebackUnits = true;\n\tbool P2IWith420 = false;\n\tbool DSCOnlyIfNecessaryWithBPP = false;\n\tbool DSC422NativeNotSupported = false;\n\tdouble MaxTotalVActiveRDBandwidth;\n\tbool ViewportExceedsSurface = false;\n\tbool FMTBufferExceeded = false;\n\n\t \n\n\tCalculateMinAndMaxPrefetchMode(\n\t\tmode_lib->vba.AllowDRAMSelfRefreshOrDRAMClockChangeInVblank,\n\t\t&MinPrefetchMode, &MaxPrefetchMode);\n\n\t \n\n\tv->ScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->ScalerEnabled[k] == false\n\t\t\t\t&& ((v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16 && v->SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_8 && v->SourcePixelFormat[k] != dm_rgbe\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe_alpha) || v->HRatio[k] != 1.0 || v->htaps[k] != 1.0\n\t\t\t\t\t\t|| v->VRatio[k] != 1.0 || v->vtaps[k] != 1.0)) {\n\t\t\tv->ScaleRatioAndTapsSupport = false;\n\t\t} else if (v->vtaps[k] < 1.0 || v->vtaps[k] > 8.0 || v->htaps[k] < 1.0 || v->htaps[k] > 8.0\n\t\t\t\t|| (v->htaps[k] > 1.0 && (v->htaps[k] % 2) == 1) || v->HRatio[k] > v->MaxHSCLRatio\n\t\t\t\t|| v->VRatio[k] > v->MaxVSCLRatio || v->HRatio[k] > v->htaps[k]\n\t\t\t\t|| v->VRatio[k] > v->vtaps[k]\n\t\t\t\t|| (v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16 && v->SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_8 && v->SourcePixelFormat[k] != dm_rgbe\n\t\t\t\t\t\t&& (v->VTAPsChroma[k] < 1 || v->VTAPsChroma[k] > 8 || v->HTAPsChroma[k] < 1\n\t\t\t\t\t\t\t\t|| v->HTAPsChroma[k] > 8 || (v->HTAPsChroma[k] > 1 && v->HTAPsChroma[k] % 2 == 1)\n\t\t\t\t\t\t\t\t|| v->HRatioChroma[k] > v->MaxHSCLRatio\n\t\t\t\t\t\t\t\t|| v->VRatioChroma[k] > v->MaxVSCLRatio\n\t\t\t\t\t\t\t\t|| v->HRatioChroma[k] > v->HTAPsChroma[k]\n\t\t\t\t\t\t\t\t|| v->VRatioChroma[k] > v->VTAPsChroma[k]))) {\n\t\t\tv->ScaleRatioAndTapsSupport = false;\n\t\t}\n\t}\n\t \n\n\tv->SourceFormatPixelAndScanSupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif ((v->SurfaceTiling[k] == dm_sw_linear && (!(v->SourceScan[k] != dm_vert) || v->DCCEnable[k] == true))\n\t\t\t\t|| ((v->SurfaceTiling[k] == dm_sw_64kb_d || v->SurfaceTiling[k] == dm_sw_64kb_d_t\n\t\t\t\t\t\t|| v->SurfaceTiling[k] == dm_sw_64kb_d_x) && !(v->SourcePixelFormat[k] == dm_444_64))) {\n\t\t\tv->SourceFormatPixelAndScanSupport = false;\n\t\t}\n\t}\n\t \n\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t&v->BytePerPixelY[k],\n\t\t\t\t&v->BytePerPixelC[k],\n\t\t\t\t&v->BytePerPixelInDETY[k],\n\t\t\t\t&v->BytePerPixelInDETC[k],\n\t\t\t\t&v->Read256BlockHeightY[k],\n\t\t\t\t&v->Read256BlockHeightC[k],\n\t\t\t\t&v->Read256BlockWidthY[k],\n\t\t\t\t&v->Read256BlockWidthC[k]);\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->SourceScan[k] != dm_vert) {\n\t\t\tv->SwathWidthYSingleDPP[k] = v->ViewportWidth[k];\n\t\t\tv->SwathWidthCSingleDPP[k] = v->ViewportWidthChroma[k];\n\t\t} else {\n\t\t\tv->SwathWidthYSingleDPP[k] = v->ViewportHeight[k];\n\t\t\tv->SwathWidthCSingleDPP[k] = v->ViewportHeightChroma[k];\n\t\t}\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tv->ReadBandwidthLuma[k] = v->SwathWidthYSingleDPP[k] * dml_ceil(v->BytePerPixelInDETY[k], 1.0)\n\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t\tv->ReadBandwidthChroma[k] = v->SwathWidthYSingleDPP[k] / 2 * dml_ceil(v->BytePerPixelInDETC[k], 2.0)\n\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k] / 2.0;\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->WritebackEnable[k] == true && v->WritebackPixelFormat[k] == dm_444_64) {\n\t\t\tv->WriteBandwidth[k] = v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k]\n\t\t\t\t\t/ (v->WritebackSourceHeight[k] * v->HTotal[k] / v->PixelClock[k]) * 8.0;\n\t\t} else if (v->WritebackEnable[k] == true) {\n\t\t\tv->WriteBandwidth[k] = v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k]\n\t\t\t\t\t/ (v->WritebackSourceHeight[k] * v->HTotal[k] / v->PixelClock[k]) * 4.0;\n\t\t} else {\n\t\t\tv->WriteBandwidth[k] = 0.0;\n\t\t}\n\t}\n\n\t \n\n\tv->WritebackLatencySupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->WritebackEnable[k] == true && (v->WriteBandwidth[k] > v->WritebackInterfaceBufferSize * 1024 / v->WritebackLatency)) {\n\t\t\tv->WritebackLatencySupport = false;\n\t\t}\n\t}\n\n\t \n\n\tv->TotalNumberOfActiveWriteback = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tv->TotalNumberOfActiveWriteback = v->TotalNumberOfActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (v->TotalNumberOfActiveWriteback > v->MaxNumWriteback) {\n\t\tEnoughWritebackUnits = false;\n\t}\n\n\t \n\n\tv->WritebackScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tif (v->WritebackHRatio[k] > v->WritebackMaxHSCLRatio || v->WritebackVRatio[k] > v->WritebackMaxVSCLRatio\n\t\t\t\t\t|| v->WritebackHRatio[k] < v->WritebackMinHSCLRatio\n\t\t\t\t\t|| v->WritebackVRatio[k] < v->WritebackMinVSCLRatio\n\t\t\t\t\t|| v->WritebackHTaps[k] > v->WritebackMaxHSCLTaps\n\t\t\t\t\t|| v->WritebackVTaps[k] > v->WritebackMaxVSCLTaps\n\t\t\t\t\t|| v->WritebackHRatio[k] > v->WritebackHTaps[k] || v->WritebackVRatio[k] > v->WritebackVTaps[k]\n\t\t\t\t\t|| (v->WritebackHTaps[k] > 2.0 && ((v->WritebackHTaps[k] % 2) == 1))) {\n\t\t\t\tv->WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t\tif (2.0 * v->WritebackDestinationWidth[k] * (v->WritebackVTaps[k] - 1) * 57 > v->WritebackLineBufferSize) {\n\t\t\t\tv->WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->WritebackRequiredDISPCLK = 0.0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tv->WritebackRequiredDISPCLK = dml_max(\n\t\t\t\t\tv->WritebackRequiredDISPCLK,\n\t\t\t\t\tdml31_CalculateWriteBackDISPCLK(\n\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\tv->WritebackHTaps[k],\n\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\tv->WritebackSourceWidth[k],\n\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->WritebackLineBufferSize));\n\t\t}\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->HRatio[k] > 1.0) {\n\t\t\tv->PSCL_FACTOR[k] = dml_min(\n\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatio[k] / dml_ceil(v->htaps[k] / 6.0, 1.0));\n\t\t} else {\n\t\t\tv->PSCL_FACTOR[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t}\n\t\tif (v->BytePerPixelC[k] == 0.0) {\n\t\t\tv->PSCL_FACTOR_CHROMA[k] = 0.0;\n\t\t\tv->MinDPPCLKUsingSingleDPP[k] = v->PixelClock[k]\n\t\t\t\t\t* dml_max3(\n\t\t\t\t\t\t\tv->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]),\n\t\t\t\t\t\t\tv->HRatio[k] * v->VRatio[k] / v->PSCL_FACTOR[k],\n\t\t\t\t\t\t\t1.0);\n\t\t\tif ((v->htaps[k] > 6.0 || v->vtaps[k] > 6.0) && v->MinDPPCLKUsingSingleDPP[k] < 2.0 * v->PixelClock[k]) {\n\t\t\t\tv->MinDPPCLKUsingSingleDPP[k] = 2.0 * v->PixelClock[k];\n\t\t\t}\n\t\t} else {\n\t\t\tif (v->HRatioChroma[k] > 1.0) {\n\t\t\t\tv->PSCL_FACTOR_CHROMA[k] = dml_min(\n\t\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatioChroma[k] / dml_ceil(v->HTAPsChroma[k] / 6.0, 1.0));\n\t\t\t} else {\n\t\t\t\tv->PSCL_FACTOR_CHROMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tv->MinDPPCLKUsingSingleDPP[k] = v->PixelClock[k]\n\t\t\t\t\t* dml_max5(\n\t\t\t\t\t\t\tv->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]),\n\t\t\t\t\t\t\tv->HRatio[k] * v->VRatio[k] / v->PSCL_FACTOR[k],\n\t\t\t\t\t\t\tv->VTAPsChroma[k] / 6.0 * dml_min(1.0, v->HRatioChroma[k]),\n\t\t\t\t\t\t\tv->HRatioChroma[k] * v->VRatioChroma[k] / v->PSCL_FACTOR_CHROMA[k],\n\t\t\t\t\t\t\t1.0);\n\t\t\tif ((v->htaps[k] > 6.0 || v->vtaps[k] > 6.0 || v->HTAPsChroma[k] > 6.0 || v->VTAPsChroma[k] > 6.0)\n\t\t\t\t\t&& v->MinDPPCLKUsingSingleDPP[k] < 2.0 * v->PixelClock[k]) {\n\t\t\t\tv->MinDPPCLKUsingSingleDPP[k] = 2.0 * v->PixelClock[k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tint MaximumSwathWidthSupportLuma;\n\t\tint MaximumSwathWidthSupportChroma;\n\n\t\tif (v->SurfaceTiling[k] == dm_sw_linear) {\n\t\t\tMaximumSwathWidthSupportLuma = 8192.0;\n\t\t} else if (v->SourceScan[k] == dm_vert && v->BytePerPixelC[k] > 0) {\n\t\t\tMaximumSwathWidthSupportLuma = 2880.0;\n\t\t} else if (v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\tMaximumSwathWidthSupportLuma = 3840.0;\n\t\t} else {\n\t\t\tMaximumSwathWidthSupportLuma = 5760.0;\n\t\t}\n\n\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12) {\n\t\t\tMaximumSwathWidthSupportChroma = MaximumSwathWidthSupportLuma / 2.0;\n\t\t} else {\n\t\t\tMaximumSwathWidthSupportChroma = MaximumSwathWidthSupportLuma;\n\t\t}\n\t\tv->MaximumSwathWidthInLineBufferLuma = v->LineBufferSize * dml_max(v->HRatio[k], 1.0) / v->LBBitPerPixel[k]\n\t\t\t\t/ (v->vtaps[k] + dml_max(dml_ceil(v->VRatio[k], 1.0) - 2, 0.0));\n\t\tif (v->BytePerPixelC[k] == 0.0) {\n\t\t\tv->MaximumSwathWidthInLineBufferChroma = 0;\n\t\t} else {\n\t\t\tv->MaximumSwathWidthInLineBufferChroma = v->LineBufferSize * dml_max(v->HRatioChroma[k], 1.0) / v->LBBitPerPixel[k]\n\t\t\t\t\t/ (v->VTAPsChroma[k] + dml_max(dml_ceil(v->VRatioChroma[k], 1.0) - 2, 0.0));\n\t\t}\n\t\tv->MaximumSwathWidthLuma[k] = dml_min(MaximumSwathWidthSupportLuma, v->MaximumSwathWidthInLineBufferLuma);\n\t\tv->MaximumSwathWidthChroma[k] = dml_min(MaximumSwathWidthSupportChroma, v->MaximumSwathWidthInLineBufferChroma);\n\t}\n\n\tCalculateSwathAndDETConfiguration(\n\t\t\ttrue,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tmode_lib->project == DML_PROJECT_DCN315 && v->DETSizeOverride[0],\n\t\t\tv->DETBufferSizeInKByte,\n\t\t\tv->MaximumSwathWidthLuma,\n\t\t\tv->MaximumSwathWidthChroma,\n\t\t\tv->SourceScan,\n\t\t\tv->SourcePixelFormat,\n\t\t\tv->SurfaceTiling,\n\t\t\tv->ViewportWidth,\n\t\t\tv->ViewportHeight,\n\t\t\tv->SurfaceWidthY,\n\t\t\tv->SurfaceWidthC,\n\t\t\tv->SurfaceHeightY,\n\t\t\tv->SurfaceHeightC,\n\t\t\tv->Read256BlockHeightY,\n\t\t\tv->Read256BlockHeightC,\n\t\t\tv->Read256BlockWidthY,\n\t\t\tv->Read256BlockWidthC,\n\t\t\tv->odm_combine_dummy,\n\t\t\tv->BlendingAndTiming,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->BytePerPixelInDETY,\n\t\t\tv->BytePerPixelInDETC,\n\t\t\tv->HActive,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->NoOfDPPThisState,\n\t\t\tv->swath_width_luma_ub_this_state,\n\t\t\tv->swath_width_chroma_ub_this_state,\n\t\t\tv->SwathWidthYThisState,\n\t\t\tv->SwathWidthCThisState,\n\t\t\tv->SwathHeightYThisState,\n\t\t\tv->SwathHeightCThisState,\n\t\t\tv->DETBufferSizeYThisState,\n\t\t\tv->DETBufferSizeCThisState,\n\t\t\tv->SingleDPPViewportSizeSupportPerPlane,\n\t\t\t&v->ViewportSizeSupport[0][0]);\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tv->MaxDispclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(v->MaxDispclk[i], v->DISPCLKDPPCLKVCOSpeed);\n\t\t\tv->MaxDppclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(v->MaxDppclk[i], v->DISPCLKDPPCLKVCOSpeed);\n\t\t\tv->RequiredDISPCLK[i][j] = 0.0;\n\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tv->PlaneRequiredDISPCLKWithoutODMCombine = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1.0 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithoutODMCombine >= v->MaxDispclk[i]\n\t\t\t\t\t\t&& v->MaxDispclk[i] == v->MaxDispclk[v->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[v->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithoutODMCombine = v->PixelClock[k]\n\t\t\t\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine2To1 = v->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithODMCombine2To1 >= v->MaxDispclk[i]\n\t\t\t\t\t\t&& v->MaxDispclk[i] == v->MaxDispclk[v->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[v->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine2To1 = v->PixelClock[k] / 2\n\t\t\t\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine4To1 = v->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithODMCombine4To1 >= v->MaxDispclk[i]\n\t\t\t\t\t\t&& v->MaxDispclk[i] == v->MaxDispclk[v->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[v->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine4To1 = v->PixelClock[k] / 4\n\t\t\t\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\n\t\t\t\tif (v->ODMCombinePolicy == dm_odm_combine_policy_none\n\t\t\t\t\t\t|| !(v->Output[k] == dm_dp ||\n\t\t\t\t\t\t     v->Output[k] == dm_dp2p0 ||\n\t\t\t\t\t\t     v->Output[k] == dm_edp)) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithoutODMCombine;\n\n\t\t\t\t\tif (v->HActive[k] / 2 > DCN31_MAX_FMT_420_BUFFER_WIDTH)\n\t\t\t\t\t\tFMTBufferExceeded = true;\n\t\t\t\t} else if (v->ODMCombinePolicy == dm_odm_combine_policy_2to1) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t} else if (v->ODMCombinePolicy == dm_odm_combine_policy_4to1\n\t\t\t\t\t\t|| v->PlaneRequiredDISPCLKWithODMCombine2To1 > v->MaxDispclkRoundedDownToDFSGranularity) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\t\t\t\t} else if (v->PlaneRequiredDISPCLKWithoutODMCombine > v->MaxDispclkRoundedDownToDFSGranularity) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t} else {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithoutODMCombine;\n\t\t\t\t}\n\t\t\t\tif (v->DSCEnabled[k] && v->HActive[k] > DCN31_MAX_DSC_IMAGE_WIDTH\n\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {\n\t\t\t\t\tif (v->HActive[k] / 2 > DCN31_MAX_DSC_IMAGE_WIDTH) {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->OutputFormat[k] == dm_420 && v->HActive[k] > DCN31_MAX_FMT_420_BUFFER_WIDTH\n\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {\n\t\t\t\t\tif (v->Output[k] == dm_hdmi) {\n\t\t\t\t\t\tFMTBufferExceeded = true;\n\t\t\t\t\t} else if (v->HActive[k] / 2 > DCN31_MAX_FMT_420_BUFFER_WIDTH) {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\n\t\t\t\t\t\tif (v->HActive[k] / 4 > DCN31_MAX_FMT_420_BUFFER_WIDTH)\n\t\t\t\t\t\t\tFMTBufferExceeded = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 4;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 4;\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2;\n\t\t\t\t} else if ((v->WhenToDoMPCCombine == dm_mpc_never\n\t\t\t\t\t\t|| (v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t\t<= v->MaxDppclkRoundedDownToDFSGranularity && v->SingleDPPViewportSizeSupportPerPlane[k] == true))) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t} else {\n\t\t\t\t\tv->MPCCombine[i][j][k] = true;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t}\n\t\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->PlaneRequiredDISPCLK);\n\t\t\t\tif ((v->MinDPPCLKUsingSingleDPP[k] / v->NoOfDPP[i][j][k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t> v->MaxDppclkRoundedDownToDFSGranularity)\n\t\t\t\t\t\t|| (v->PlaneRequiredDISPCLK > v->MaxDispclkRoundedDownToDFSGranularity)) {\n\t\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t}\n\t\t\t\tif (mode_lib->project == DML_PROJECT_DCN315 && v->DETSizeOverride[k] > DCN3_15_MAX_DET_SIZE && v->NoOfDPP[i][j][k] < 2) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = true;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->TotalNumberOfActiveDPP[i][j] = 0;\n\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\tif (v->NoOfDPP[i][j][k] == 1)\n\t\t\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = v->TotalNumberOfSingleDPPPlanes[i][j] + 1;\n\t\t\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10\n\t\t\t\t\t\t|| v->SourcePixelFormat[k] == dm_420_12 || v->SourcePixelFormat[k] == dm_rgbe_alpha)\n\t\t\t\t\tNoChroma = false;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (j == 1 && v->WhenToDoMPCCombine != dm_mpc_never\n\t\t\t\t\t&& !UnboundedRequest(v->UseUnboundedRequesting, v->TotalNumberOfActiveDPP[i][j], NoChroma, v->Output[0])) {\n\t\t\t\twhile (!(v->TotalNumberOfActiveDPP[i][j] >= v->MaxNumDPP || v->TotalNumberOfSingleDPPPlanes[i][j] == 0)) {\n\t\t\t\t\tdouble BWOfNonSplitPlaneOfMaximumBandwidth;\n\t\t\t\t\tunsigned int NumberOfNonSplitPlaneOfMaximumBandwidth;\n\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\t\tif (v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k] > BWOfNonSplitPlaneOfMaximumBandwidth\n\t\t\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled && v->MPCCombine[i][j][k] == false) {\n\t\t\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k];\n\t\t\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv->MPCCombine[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = true;\n\t\t\t\t\tv->NoOfDPP[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] =\n\t\t\t\t\t\t\tv->MinDPPCLKUsingSingleDPP[NumberOfNonSplitPlaneOfMaximumBandwidth]\n\t\t\t\t\t\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100) / 2;\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + 1;\n\t\t\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = v->TotalNumberOfSingleDPPPlanes[i][j] - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v->TotalNumberOfActiveDPP[i][j] > v->MaxNumDPP) {\n\t\t\t\tv->RequiredDISPCLK[i][j] = 0.0;\n\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tif (v->SingleDPPViewportSizeSupportPerPlane[k] == false && v->WhenToDoMPCCombine != dm_mpc_never) {\n\t\t\t\t\t\tv->MPCCombine[i][j][k] = true;\n\t\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t\t* (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\t\tv->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t\t* (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(v->MaxDispclk[i] == v->MaxDispclk[v->soc.num_states - 1]\n\t\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[v->soc.num_states - 1])) {\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t\t* (1.0 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t}\n\t\t\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->PlaneRequiredDISPCLK);\n\t\t\t\t\tif ((v->MinDPPCLKUsingSingleDPP[k] / v->NoOfDPP[i][j][k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t> v->MaxDppclkRoundedDownToDFSGranularity)\n\t\t\t\t\t\t\t|| (v->PlaneRequiredDISPCLK > v->MaxDispclkRoundedDownToDFSGranularity)) {\n\t\t\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = 0.0;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->WritebackRequiredDISPCLK);\n\t\t\tif (v->MaxDispclkRoundedDownToDFSGranularity < v->WritebackRequiredDISPCLK) {\n\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (v->TotalNumberOfActiveDPP[i][j] <= v->MaxNumDPP) {\n\t\t\t\tv->TotalAvailablePipesSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->TotalAvailablePipesSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->NonsupportedDSCInputBPC = false;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (!(v->DSCInputBitPerComponent[k] == 12.0 || v->DSCInputBitPerComponent[k] == 10.0 || v->DSCInputBitPerComponent[k] == 8.0)\n\t\t\t\t|| v->DSCInputBitPerComponent[k] > v->MaximumDSCBitsPerComponent) {\n\t\t\tv->NonsupportedDSCInputBPC = true;\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tif (v->PixelClockBackEnd[k] > 3200) {\n\t\t\t\tv->NumberOfDSCSlices[k] = dml_ceil(v->PixelClockBackEnd[k] / 400.0, 4.0);\n\t\t\t} else if (v->PixelClockBackEnd[k] > 1360) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 8;\n\t\t\t} else if (v->PixelClockBackEnd[k] > 680) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 4;\n\t\t\t} else if (v->PixelClockBackEnd[k] > 340) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 2;\n\t\t\t} else {\n\t\t\t\tv->NumberOfDSCSlices[k] = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tv->NumberOfDSCSlices[k] = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\tif (v->Output[k] == dm_hdmi) {\n\t\t\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\tv->OutputBppPerState[i][k] = TruncToValidBPP(\n\t\t\t\t\t\t\tdml_min(600.0, v->PHYCLKPerState[i]) * 10,\n\t\t\t\t\t\t\t3,\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t} else if (v->Output[k] == dm_dp || v->Output[k] == dm_edp || v->Output[k] == dm_dp2p0) {\n\t\t\t\t\tif (v->DSCEnable[k] == true) {\n\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\tif (v->Output[k] == dm_dp || v->Output[k] == dm_dp2p0) {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\t\t\t\tv->LinkDSCEnable = false;\n\t\t\t\t\t\tif (v->Output[k] == dm_dp2p0) {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (v->Output[k] == dm_dp2p0) {\n\t\t\t\t\t\tv->Outbpp = BPP_INVALID;\n\t\t\t\t\t\tif ((v->OutputLinkDPRate[k] == dm_dp_rate_na || v->OutputLinkDPRate[k] == dm_dp_rate_uhbr10) &&\n\t\t\t\t\t\t\tv->PHYCLKD18PerState[k] >= 10000.0 / 18.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 10000,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKD18PerState[k] < 13500.0 / 18.0 &&\n\t\t\t\t\t\t\t\tv->DSCEnable[k] == true && v->ForcedOutputLinkBPP[k] == 0) {\n\t\t\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 10000,\n\t\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID &&\n\t\t\t\t\t\t\t(v->OutputLinkDPRate[k] == dm_dp_rate_na || v->OutputLinkDPRate[k] == dm_dp_rate_uhbr13p5) &&\n\t\t\t\t\t\t\tv->PHYCLKD18PerState[k] >= 13500.0 / 18.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 13500,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKD18PerState[k] < 20000.0 / 18.0 &&\n\t\t\t\t\t\t\t\tv->DSCEnable[k] == true && v->ForcedOutputLinkBPP[k] == 0) {\n\t\t\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 13500,\n\t\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID &&\n\t\t\t\t\t\t\t(v->OutputLinkDPRate[k] == dm_dp_rate_na || v->OutputLinkDPRate[k] == dm_dp_rate_uhbr20) &&\n\t\t\t\t\t\t\tv->PHYCLKD18PerState[k] >= 20000.0 / 18.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 20000,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->DSCEnable[k] == true &&\n\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k] == 0) {\n\t\t\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 20000,\n\t\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->Outbpp = BPP_INVALID;\n\t\t\t\t\t\tif (v->PHYCLKPerState[i] >= 270.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 2700,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKPerState[i] >= 540.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 5400,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKPerState[i] >= 810.0) {\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 8100,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tv->OutputBppPerState[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tv->LinkCapacitySupport[i] = true;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\tif (v->BlendingAndTiming[k] == k\n\t\t\t\t\t&& (v->Output[k] == dm_dp ||\n\t\t\t\t\t    v->Output[k] == dm_edp ||\n\t\t\t\t\t    v->Output[k] == dm_hdmi) && v->OutputBppPerState[i][k] == 0) {\n\t\t\t\tv->LinkCapacitySupport[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k\n\t\t\t\t&& (v->Output[k] == dm_dp ||\n\t\t\t\t    v->Output[k] == dm_edp ||\n\t\t\t\t    v->Output[k] == dm_hdmi)) {\n\t\t\tif (v->OutputFormat[k] == dm_420 && v->Interlace[k] == 1 && v->ProgressiveToInterlaceUnitInOPP == true) {\n\t\t\t\tP2IWith420 = true;\n\t\t\t}\n\t\t\tif (v->DSCEnable[k] == true && v->OutputFormat[k] == dm_n422\n\t\t\t\t\t&& !v->DSC422NativeSupport) {\n\t\t\t\tDSC422NativeNotSupported = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tv->ODMCombine4To1SupportCheckOK[i] = true;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->BlendingAndTiming[k] == k && v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1\n\t\t\t\t\t&& (v->ODMCombine4To1Supported == false || v->Output[k] == dm_dp || v->Output[k] == dm_edp\n\t\t\t\t\t\t\t|| v->Output[k] == dm_hdmi)) {\n\t\t\t\tv->ODMCombine4To1SupportCheckOK[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tv->NotEnoughDSCUnits[i] = false;\n\t\tv->TotalDSCUnitsRequired = 0.0;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\tif (v->RequiresDSC[i][k] == true) {\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 4.0;\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 2.0;\n\t\t\t\t} else {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (v->TotalDSCUnitsRequired > v->NumberOfDSC) {\n\t\t\tv->NotEnoughDSCUnits[i] = true;\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\tif (v->OutputBppPerState[i][k] == BPP_INVALID) {\n\t\t\t\tv->BPP = 0.0;\n\t\t\t} else {\n\t\t\t\tv->BPP = v->OutputBppPerState[i][k];\n\t\t\t}\n\t\t\tif (v->RequiresDSC[i][k] == true && v->BPP != 0.0) {\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = dscceComputeDelay(\n\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = 2.0\n\t\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 2,\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]));\n\t\t\t\t} else {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = 4.0\n\t\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 4,\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]));\n\t\t\t\t}\n\t\t\t\tv->DSCDelayPerState[i][k] = v->DSCDelayPerState[i][k] * v->PixelClock[k] / v->PixelClockBackEnd[k];\n\t\t\t} else {\n\t\t\t\tv->DSCDelayPerState[i][k] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\tfor (m = 0; m < v->NumberOfActivePlanes; m++) {\n\t\t\t\tif (v->BlendingAndTiming[k] == m && v->RequiresDSC[i][m] == true) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = v->DSCDelayPerState[i][m];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->RequiredDPPCLKThisState[k] = v->RequiredDPPCLK[i][j][k];\n\t\t\t\tv->NoOfDPPThisState[k] = v->NoOfDPP[i][j][k];\n\t\t\t\tv->ODMCombineEnableThisState[k] = v->ODMCombineEnablePerState[i][k];\n\t\t\t}\n\n\t\t\tif (v->NumberOfActivePlanes > 1 && mode_lib->project == DML_PROJECT_DCN315 && !v->DETSizeOverride[0])\n\t\t\t\tPatchDETBufferSizeInKByte(v->NumberOfActivePlanes, v->NoOfDPPThisState, v->ip.config_return_buffer_size_in_kbytes, v->DETBufferSizeInKByte);\n\t\t\tCalculateSwathAndDETConfiguration(\n\t\t\t\t\tfalse,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tmode_lib->project == DML_PROJECT_DCN315 && v->DETSizeOverride[0],\n\t\t\t\t\tv->DETBufferSizeInKByte,\n\t\t\t\t\tv->MaximumSwathWidthLuma,\n\t\t\t\t\tv->MaximumSwathWidthChroma,\n\t\t\t\t\tv->SourceScan,\n\t\t\t\t\tv->SourcePixelFormat,\n\t\t\t\t\tv->SurfaceTiling,\n\t\t\t\t\tv->ViewportWidth,\n\t\t\t\t\tv->ViewportHeight,\n\t\t\t\t\tv->SurfaceWidthY,\n\t\t\t\t\tv->SurfaceWidthC,\n\t\t\t\t\tv->SurfaceHeightY,\n\t\t\t\t\tv->SurfaceHeightC,\n\t\t\t\t\tv->Read256BlockHeightY,\n\t\t\t\t\tv->Read256BlockHeightC,\n\t\t\t\t\tv->Read256BlockWidthY,\n\t\t\t\t\tv->Read256BlockWidthC,\n\t\t\t\t\tv->ODMCombineEnableThisState,\n\t\t\t\t\tv->BlendingAndTiming,\n\t\t\t\t\tv->BytePerPixelY,\n\t\t\t\t\tv->BytePerPixelC,\n\t\t\t\t\tv->BytePerPixelInDETY,\n\t\t\t\t\tv->BytePerPixelInDETC,\n\t\t\t\t\tv->HActive,\n\t\t\t\t\tv->HRatio,\n\t\t\t\t\tv->HRatioChroma,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->swath_width_luma_ub_this_state,\n\t\t\t\t\tv->swath_width_chroma_ub_this_state,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->SwathHeightYThisState,\n\t\t\t\t\tv->SwathHeightCThisState,\n\t\t\t\t\tv->DETBufferSizeYThisState,\n\t\t\t\t\tv->DETBufferSizeCThisState,\n\t\t\t\t\tv->dummystring,\n\t\t\t\t\t&v->ViewportSizeSupport[i][j]);\n\n\t\t\tCalculateDCFCLKDeepSleep(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->BytePerPixelY,\n\t\t\t\t\tv->BytePerPixelC,\n\t\t\t\t\tv->VRatio,\n\t\t\t\t\tv->VRatioChroma,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->HRatio,\n\t\t\t\t\tv->HRatioChroma,\n\t\t\t\t\tv->PixelClock,\n\t\t\t\t\tv->PSCL_FACTOR,\n\t\t\t\t\tv->PSCL_FACTOR_CHROMA,\n\t\t\t\t\tv->RequiredDPPCLKThisState,\n\t\t\t\t\tv->ReadBandwidthLuma,\n\t\t\t\t\tv->ReadBandwidthChroma,\n\t\t\t\t\tv->ReturnBusWidth,\n\t\t\t\t\t&v->ProjectedDCFCLKDeepSleep[i][j]);\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->swath_width_luma_ub_all_states[i][j][k] = v->swath_width_luma_ub_this_state[k];\n\t\t\t\tv->swath_width_chroma_ub_all_states[i][j][k] = v->swath_width_chroma_ub_this_state[k];\n\t\t\t\tv->SwathWidthYAllStates[i][j][k] = v->SwathWidthYThisState[k];\n\t\t\t\tv->SwathWidthCAllStates[i][j][k] = v->SwathWidthCThisState[k];\n\t\t\t\tv->SwathHeightYAllStates[i][j][k] = v->SwathHeightYThisState[k];\n\t\t\t\tv->SwathHeightCAllStates[i][j][k] = v->SwathHeightCThisState[k];\n\t\t\t\tv->DETBufferSizeYAllStates[i][j][k] = v->DETBufferSizeYThisState[k];\n\t\t\t\tv->DETBufferSizeCAllStates[i][j][k] = v->DETBufferSizeCThisState[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->cursor_bw[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0\n\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tbool NotUrgentLatencyHiding[DC__NUM_DPP__MAX];\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tv->swath_width_luma_ub_this_state[k] = v->swath_width_luma_ub_all_states[i][j][k];\n\t\t\t\tv->swath_width_chroma_ub_this_state[k] = v->swath_width_chroma_ub_all_states[i][j][k];\n\t\t\t\tv->SwathWidthYThisState[k] = v->SwathWidthYAllStates[i][j][k];\n\t\t\t\tv->SwathWidthCThisState[k] = v->SwathWidthCAllStates[i][j][k];\n\t\t\t\tv->SwathHeightYThisState[k] = v->SwathHeightYAllStates[i][j][k];\n\t\t\t\tv->SwathHeightCThisState[k] = v->SwathHeightCAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeYThisState[k] = v->DETBufferSizeYAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeCThisState[k] = v->DETBufferSizeCAllStates[i][j][k];\n\t\t\t}\n\n\t\t\tv->TotalNumberOfDCCActiveDPP[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (v->DCCEnable[k] == true) {\n\t\t\t\t\tv->TotalNumberOfDCCActiveDPP[i][j] = v->TotalNumberOfDCCActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10\n\t\t\t\t\t\t|| v->SourcePixelFormat[k] == dm_420_12 || v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\n\t\t\t\t\tif ((v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12)\n\t\t\t\t\t\t\t&& v->SourceScan[k] != dm_vert) {\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = (v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma)\n\t\t\t\t\t\t\t\t/ 2;\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsForLuma;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma;\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsChroma;\n\t\t\t\t\t}\n\n\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrameC = CalculateVMAndRowBytes(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\t\tv->Read256BlockHeightC[k],\n\t\t\t\t\t\t\tv->Read256BlockWidthC[k],\n\t\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\t\t\tv->SwathWidthCThisState[k],\n\t\t\t\t\t\t\tv->ViewportHeightChroma[k],\n\t\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma,\n\t\t\t\t\t\t\tv->PitchC[k],\n\t\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t\t&v->MacroTileWidthC[k],\n\t\t\t\t\t\t\t&v->MetaRowBytesC,\n\t\t\t\t\t\t\t&v->DPTEBytesPerRowC,\n\t\t\t\t\t\t\t&v->PTEBufferSizeNotExceededC[i][j][k],\n\t\t\t\t\t\t\t&v->dummyinteger7,\n\t\t\t\t\t\t\t&v->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\t&v->dummyinteger28,\n\t\t\t\t\t\t\t&v->dummyinteger26,\n\t\t\t\t\t\t\t&v->dummyinteger23,\n\t\t\t\t\t\t\t&v->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t&v->dummyinteger8,\n\t\t\t\t\t\t\t&v->dummyinteger9,\n\t\t\t\t\t\t\t&v->dummyinteger19,\n\t\t\t\t\t\t\t&v->dummyinteger20,\n\t\t\t\t\t\t\t&v->dummyinteger17,\n\t\t\t\t\t\t\t&v->dummyinteger10,\n\t\t\t\t\t\t\t&v->dummyinteger11);\n\n\t\t\t\t\tv->PrefetchLinesC[i][j][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\t\tv->VTAPsChroma[k],\n\t\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tv->ViewportYStartC[k],\n\t\t\t\t\t\t\t&v->PrefillC[k],\n\t\t\t\t\t\t\t&v->MaxNumSwC[k]);\n\t\t\t\t} else {\n\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma;\n\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = 0;\n\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrameC = 0.0;\n\t\t\t\t\tv->MetaRowBytesC = 0.0;\n\t\t\t\t\tv->DPTEBytesPerRowC = 0.0;\n\t\t\t\t\tv->PrefetchLinesC[i][j][k] = 0.0;\n\t\t\t\t\tv->PTEBufferSizeNotExceededC[i][j][k] = true;\n\t\t\t\t}\n\t\t\t\tv->PDEAndMetaPTEBytesPerFrameY = CalculateVMAndRowBytes(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\tv->Read256BlockHeightY[k],\n\t\t\t\t\t\tv->Read256BlockWidthY[k],\n\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\t\tv->SwathWidthYThisState[k],\n\t\t\t\t\t\tv->ViewportHeight[k],\n\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma,\n\t\t\t\t\t\tv->PitchY[k],\n\t\t\t\t\t\tv->DCCMetaPitchY[k],\n\t\t\t\t\t\t&v->MacroTileWidthY[k],\n\t\t\t\t\t\t&v->MetaRowBytesY,\n\t\t\t\t\t\t&v->DPTEBytesPerRowY,\n\t\t\t\t\t\t&v->PTEBufferSizeNotExceededY[i][j][k],\n\t\t\t\t\t\t&v->dummyinteger7,\n\t\t\t\t\t\t&v->dpte_row_height[k],\n\t\t\t\t\t\t&v->dummyinteger29,\n\t\t\t\t\t\t&v->dummyinteger27,\n\t\t\t\t\t\t&v->dummyinteger24,\n\t\t\t\t\t\t&v->meta_row_height[k],\n\t\t\t\t\t\t&v->dummyinteger25,\n\t\t\t\t\t\t&v->dpte_group_bytes[k],\n\t\t\t\t\t\t&v->dummyinteger21,\n\t\t\t\t\t\t&v->dummyinteger22,\n\t\t\t\t\t\t&v->dummyinteger18,\n\t\t\t\t\t\t&v->dummyinteger5,\n\t\t\t\t\t\t&v->dummyinteger6);\n\t\t\t\tv->PrefetchLinesY[i][j][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->vtaps[k],\n\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\tv->ViewportYStartY[k],\n\t\t\t\t\t\t&v->PrefillY[k],\n\t\t\t\t\t\t&v->MaxNumSwY[k]);\n\t\t\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k] = v->PDEAndMetaPTEBytesPerFrameY + v->PDEAndMetaPTEBytesPerFrameC;\n\t\t\t\tv->MetaRowBytes[i][j][k] = v->MetaRowBytesY + v->MetaRowBytesC;\n\t\t\t\tv->DPTEBytesPerRow[i][j][k] = v->DPTEBytesPerRowY + v->DPTEBytesPerRowC;\n\n\t\t\t\tCalculateRowBandwidth(\n\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\tv->MetaRowBytesY,\n\t\t\t\t\t\tv->MetaRowBytesC,\n\t\t\t\t\t\tv->meta_row_height[k],\n\t\t\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\t\t\tv->DPTEBytesPerRowY,\n\t\t\t\t\t\tv->DPTEBytesPerRowC,\n\t\t\t\t\t\tv->dpte_row_height[k],\n\t\t\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t\t\t&v->meta_row_bandwidth[i][j][k],\n\t\t\t\t\t\t&v->dpte_row_bandwidth[i][j][k]);\n\t\t\t}\n\t\t\t \n\t\t\tv->DCCMetaBufferSizeSupport[i][j] = true;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (v->MetaRowBytes[i][j][k] > 24064)\n\t\t\t\t\tv->DCCMetaBufferSizeSupport[i][j] = false;\n\t\t\t}\n\t\t\tv->UrgLatency[i] = CalculateUrgentLatency(\n\t\t\t\t\tv->UrgentLatencyPixelDataOnly,\n\t\t\t\t\tv->UrgentLatencyPixelMixedWithVMData,\n\t\t\t\t\tv->UrgentLatencyVMDataOnly,\n\t\t\t\t\tv->DoUrgentLatencyAdjustment,\n\t\t\t\t\tv->UrgentLatencyAdjustmentFabricClockComponent,\n\t\t\t\t\tv->UrgentLatencyAdjustmentFabricClockReference,\n\t\t\t\t\tv->FabricClockPerState[i]);\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\t\tv->swath_width_luma_ub_this_state[k],\n\t\t\t\t\t\tv->swath_width_chroma_ub_this_state[k],\n\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\tv->BytePerPixelInDETY[k],\n\t\t\t\t\t\tv->BytePerPixelInDETC[k],\n\t\t\t\t\t\tv->DETBufferSizeYThisState[k],\n\t\t\t\t\t\tv->DETBufferSizeCThisState[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorLuma[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorChroma[k],\n\t\t\t\t\t\t&NotUrgentLatencyHiding[k]);\n\t\t\t}\n\n\t\t\tv->NotEnoughUrgentLatencyHidingA[i][j] = false;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (NotUrgentLatencyHiding[k]) {\n\t\t\t\t\tv->NotEnoughUrgentLatencyHidingA[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->VActivePixelBandwidth[i][j][k] = v->ReadBandwidthLuma[k] * v->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t+ v->ReadBandwidthChroma[k] * v->UrgentBurstFactorChroma[k];\n\t\t\t\tv->VActiveCursorBandwidth[i][j][k] = v->cursor_bw[k] * v->UrgentBurstFactorCursor[k];\n\t\t\t}\n\n\t\t\tv->TotalVActivePixelBandwidth[i][j] = 0;\n\t\t\tv->TotalVActiveCursorBandwidth[i][j] = 0;\n\t\t\tv->TotalMetaRowBandwidth[i][j] = 0;\n\t\t\tv->TotalDPTERowBandwidth[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->TotalVActivePixelBandwidth[i][j] = v->TotalVActivePixelBandwidth[i][j] + v->VActivePixelBandwidth[i][j][k];\n\t\t\t\tv->TotalVActiveCursorBandwidth[i][j] = v->TotalVActiveCursorBandwidth[i][j] + v->VActiveCursorBandwidth[i][j][k];\n\t\t\t\tv->TotalMetaRowBandwidth[i][j] = v->TotalMetaRowBandwidth[i][j] + v->NoOfDPP[i][j][k] * v->meta_row_bandwidth[i][j][k];\n\t\t\t\tv->TotalDPTERowBandwidth[i][j] = v->TotalDPTERowBandwidth[i][j] + v->NoOfDPP[i][j][k] * v->dpte_row_bandwidth[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = v->WritebackLatency\n\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[k],\n\t\t\t\t\t\t\t\t\t\tv->HTotal[k]) / v->RequiredDISPCLK[i][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (m = 0; m < v->NumberOfActivePlanes; m++) {\n\t\t\t\t\t\tif (v->BlendingAndTiming[m] == k && v->WritebackEnable[m] == true) {\n\t\t\t\t\t\t\tv->WritebackDelayTime[k] = dml_max(\n\t\t\t\t\t\t\t\t\tv->WritebackDelayTime[k],\n\t\t\t\t\t\t\t\t\tv->WritebackLatency\n\t\t\t\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->HTotal[m]) / v->RequiredDISPCLK[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tfor (m = 0; m < v->NumberOfActivePlanes; m++) {\n\t\t\t\t\tif (v->BlendingAndTiming[k] == m) {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = v->WritebackDelayTime[m];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->MaxMaxVStartup[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tv->MaximumVStartup[i][j][k] =\n\t\t\t\t\t\t(v->Interlace[k] && !v->ProgressiveToInterlaceUnitInOPP) ?\n\t\t\t\t\t\t\t\tdml_floor((v->VTotal[k] - v->VActive[k]) / 2.0, 1.0) :\n\t\t\t\t\t\t\t\tv->VTotal[k] - v->VActive[k]\n\t\t\t\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t1.0 * v->WritebackDelayTime[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ (v->HTotal[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ v->PixelClock[k]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t1.0));\n\t\t\t\tif (v->MaximumVStartup[i][j][k] > 1023)\n\t\t\t\t\tv->MaximumVStartup[i][j][k] = 1023;\n\t\t\t\tv->MaxMaxVStartup[i][j] = dml_max(v->MaxMaxVStartup[i][j], v->MaximumVStartup[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tReorderingBytes = v->NumberOfChannels\n\t\t\t* dml_max3(\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tv->DCFCLKState[i][j] = v->DCFCLKPerState[i];\n\t\t}\n\t}\n\n\tif (v->UseMinimumRequiredDCFCLK == true)\n\t\tUseMinimumDCFCLK(mode_lib, MaxPrefetchMode, ReorderingBytes);\n\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tdouble IdealFabricAndSDPPortBandwidthPerState = dml_min(\n\t\t\t\t\tv->ReturnBusWidth * v->DCFCLKState[i][j],\n\t\t\t\t\tv->FabricClockPerState[i] * v->FabricDatapathToDCNDataReturn);\n\t\t\tdouble IdealDRAMBandwidthPerState = v->DRAMSpeedPerState[i] * v->NumberOfChannels * v->DRAMChannelWidth;\n\t\t\tdouble PixelDataOnlyReturnBWPerState = dml_min(\n\t\t\t\t\tIdealFabricAndSDPPortBandwidthPerState * v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\t\t\tIdealDRAMBandwidthPerState * v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyPixelDataOnly / 100.0);\n\t\t\tdouble PixelMixedWithVMDataReturnBWPerState = dml_min(\n\t\t\t\t\tIdealFabricAndSDPPortBandwidthPerState * v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\t\t\tIdealDRAMBandwidthPerState * v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyPixelMixedWithVMData / 100.0);\n\n\t\t\tif (v->HostVMEnable != true) {\n\t\t\t\tv->ReturnBWPerState[i][j] = PixelDataOnlyReturnBWPerState;\n\t\t\t} else {\n\t\t\t\tv->ReturnBWPerState[i][j] = PixelMixedWithVMDataReturnBWPerState;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tif ((v->ROBBufferSizeInKByte - v->PixelChunkSizeInKByte) * 1024 / v->ReturnBWPerState[i][j]\n\t\t\t\t\t> (v->RoundTripPingLatencyCycles + __DML_ARB_TO_RET_DELAY__) / v->DCFCLKState[i][j] + ReorderingBytes / v->ReturnBWPerState[i][j]) {\n\t\t\t\tv->ROBSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->ROBSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\n\tMaxTotalVActiveRDBandwidth = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tMaxTotalVActiveRDBandwidth = MaxTotalVActiveRDBandwidth + v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k];\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tv->MaxTotalVerticalActiveAvailableBandwidth[i][j] = dml_min(\n\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\tv->ReturnBusWidth * v->DCFCLKState[i][j],\n\t\t\t\t\t\t\tv->FabricClockPerState[i] * v->FabricDatapathToDCNDataReturn)\n\t\t\t\t\t\t\t* v->MaxAveragePercentOfIdealFabricAndSDPPortBWDisplayCanUseInNormalSystemOperation / 100,\n\t\t\t\t\tv->DRAMSpeedPerState[i] * v->NumberOfChannels * v->DRAMChannelWidth\n\t\t\t\t\t\t\t* v->MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation / 100);\n\n\t\t\tif (MaxTotalVActiveRDBandwidth <= v->MaxTotalVerticalActiveAvailableBandwidth[i][j]) {\n\t\t\t\tv->TotalVerticalActiveBandwidthSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->TotalVerticalActiveBandwidthSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tv->UrgentLatency = CalculateUrgentLatency(\n\t\t\tv->UrgentLatencyPixelDataOnly,\n\t\t\tv->UrgentLatencyPixelMixedWithVMData,\n\t\t\tv->UrgentLatencyVMDataOnly,\n\t\t\tv->DoUrgentLatencyAdjustment,\n\t\t\tv->UrgentLatencyAdjustmentFabricClockComponent,\n\t\t\tv->UrgentLatencyAdjustmentFabricClockReference,\n\t\t\tv->FabricClock);\n\t\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tdouble VMDataOnlyReturnBWPerState;\n\t\t\tdouble HostVMInefficiencyFactor = 1;\n\t\t\tint NextPrefetchModeState = MinPrefetchMode;\n\t\t\tbool UnboundedRequestEnabledThisState = false;\n\t\t\tint CompressedBufferSizeInkByteThisState = 0;\n\t\t\tdouble dummy;\n\n\t\t\tv->TimeCalc = 24 / v->ProjectedDCFCLKDeepSleep[i][j];\n\n\t\t\tv->BandwidthWithoutPrefetchSupported[i][j] = true;\n\t\t\tif (v->TotalVActivePixelBandwidth[i][j] + v->TotalVActiveCursorBandwidth[i][j] + v->TotalMetaRowBandwidth[i][j]\n\t\t\t\t\t+ v->TotalDPTERowBandwidth[i][j] > v->ReturnBWPerState[i][j] || v->NotEnoughUrgentLatencyHidingA[i][j]) {\n\t\t\t\tv->BandwidthWithoutPrefetchSupported[i][j] = false;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->NoOfDPPThisState[k] = v->NoOfDPP[i][j][k];\n\t\t\t\tv->swath_width_luma_ub_this_state[k] = v->swath_width_luma_ub_all_states[i][j][k];\n\t\t\t\tv->swath_width_chroma_ub_this_state[k] = v->swath_width_chroma_ub_all_states[i][j][k];\n\t\t\t\tv->SwathWidthYThisState[k] = v->SwathWidthYAllStates[i][j][k];\n\t\t\t\tv->SwathWidthCThisState[k] = v->SwathWidthCAllStates[i][j][k];\n\t\t\t\tv->SwathHeightYThisState[k] = v->SwathHeightYAllStates[i][j][k];\n\t\t\t\tv->SwathHeightCThisState[k] = v->SwathHeightCAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeYThisState[k] = v->DETBufferSizeYAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeCThisState[k] = v->DETBufferSizeCAllStates[i][j][k];\n\t\t\t}\n\n\t\t\tVMDataOnlyReturnBWPerState = dml_min(\n\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\tv->ReturnBusWidth * v->DCFCLKState[i][j],\n\t\t\t\t\t\t\tv->FabricClockPerState[i] * v->FabricDatapathToDCNDataReturn)\n\t\t\t\t\t\t\t* v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0,\n\t\t\t\t\tv->DRAMSpeedPerState[i] * v->NumberOfChannels * v->DRAMChannelWidth\n\t\t\t\t\t\t\t* v->PercentOfIdealDRAMBWReceivedAfterUrgLatencyVMDataOnly / 100.0);\n\t\t\tif (v->GPUVMEnable && v->HostVMEnable)\n\t\t\t\tHostVMInefficiencyFactor = v->ReturnBWPerState[i][j] / VMDataOnlyReturnBWPerState;\n\n\t\t\tv->ExtraLatency = CalculateExtraLatency(\n\t\t\t\t\tv->RoundTripPingLatencyCycles,\n\t\t\t\t\tReorderingBytes,\n\t\t\t\t\tv->DCFCLKState[i][j],\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j],\n\t\t\t\t\tv->PixelChunkSizeInKByte,\n\t\t\t\t\tv->TotalNumberOfDCCActiveDPP[i][j],\n\t\t\t\t\tv->MetaChunkSize,\n\t\t\t\t\tv->ReturnBWPerState[i][j],\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->dpte_group_bytes,\n\t\t\t\t\tHostVMInefficiencyFactor,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels);\n\n\t\t\tv->NextMaxVStartup = v->MaxMaxVStartup[i][j];\n\t\t\tdo {\n\t\t\t\tv->PrefetchModePerState[i][j] = NextPrefetchModeState;\n\t\t\t\tv->MaxVStartup = v->NextMaxVStartup;\n\n\t\t\t\tv->TWait = CalculateTWait(\n\t\t\t\t\t\tv->PrefetchModePerState[i][j],\n\t\t\t\t\t\tv->DRAMClockChangeLatency,\n\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\tv->SREnterPlusExitTime);\n\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tCalculatePrefetchSchedulePerPlane(mode_lib,\n\t\t\t\t\t\t\t\t\t  HostVMInefficiencyFactor,\n\t\t\t\t\t\t\t\t\t  i, j,\tk);\n\t\t\t\t}\n\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\t\t\tv->swath_width_luma_ub_this_state[k],\n\t\t\t\t\t\t\tv->swath_width_chroma_ub_this_state[k],\n\t\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\t\t\tv->VRatioPreY[i][j][k],\n\t\t\t\t\t\t\tv->VRatioPreC[i][j][k],\n\t\t\t\t\t\t\tv->BytePerPixelInDETY[k],\n\t\t\t\t\t\t\tv->BytePerPixelInDETC[k],\n\t\t\t\t\t\t\tv->DETBufferSizeYThisState[k],\n\t\t\t\t\t\t\tv->DETBufferSizeCThisState[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorCursorPre[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorLumaPre[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorChromaPre[k],\n\t\t\t\t\t\t\t&v->NotUrgentLatencyHidingPre[k]);\n\t\t\t\t}\n\n\t\t\t\tv->MaximumReadBandwidthWithPrefetch = 0.0;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tv->cursor_bw_pre[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0\n\t\t\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]) * v->VRatioPreY[i][j][k];\n\n\t\t\t\t\tv->MaximumReadBandwidthWithPrefetch =\n\t\t\t\t\t\t\tv->MaximumReadBandwidthWithPrefetch\n\t\t\t\t\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\t\t\t\t\tv->VActivePixelBandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->VActiveCursorBandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* (v->meta_row_bandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->dpte_row_bandwidth[i][j][k]),\n\t\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixelDataBWLuma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t}\n\n\t\t\t\tv->NotEnoughUrgentLatencyHidingPre = false;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tif (v->NotUrgentLatencyHidingPre[k] == true) {\n\t\t\t\t\t\tv->NotEnoughUrgentLatencyHidingPre = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->PrefetchSupported[i][j] = true;\n\t\t\t\tif (v->BandwidthWithoutPrefetchSupported[i][j] == false || v->MaximumReadBandwidthWithPrefetch > v->ReturnBWPerState[i][j]\n\t\t\t\t\t\t|| v->NotEnoughUrgentLatencyHidingPre == 1) {\n\t\t\t\t\tv->PrefetchSupported[i][j] = false;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tif (v->LineTimesForPrefetch[k] < 2.0 || v->LinesForMetaPTE[k] >= 32.0 || v->LinesForMetaAndDPTERow[k] >= 16.0\n\t\t\t\t\t\t\t|| v->NoTimeForPrefetch[i][j][k] == true) {\n\t\t\t\t\t\tv->PrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->DynamicMetadataSupported[i][j] = true;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\tif (v->NoTimeForDynamicMetadata[i][j][k] == true) {\n\t\t\t\t\t\tv->DynamicMetadataSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->VRatioInPrefetchSupported[i][j] = true;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\tif (v->VRatioPreY[i][j][k] > 4.0 || v->VRatioPreC[i][j][k] > 4.0 || v->NoTimeForPrefetch[i][j][k] == true) {\n\t\t\t\t\t\tv->VRatioInPrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv->AnyLinesForVMOrRowTooLarge = false;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\tif (v->LinesForMetaAndDPTERow[k] >= 16 || v->LinesForMetaPTE[k] >= 32) {\n\t\t\t\t\t\tv->AnyLinesForVMOrRowTooLarge = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->NextPrefetchMode = v->NextPrefetchMode + 1;\n\n\t\t\t\tif (v->PrefetchSupported[i][j] == true && v->VRatioInPrefetchSupported[i][j] == true) {\n\t\t\t\t\tv->BandwidthAvailableForImmediateFlip = v->ReturnBWPerState[i][j];\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\t\tv->BandwidthAvailableForImmediateFlip = v->BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\t\t\tv->VActivePixelBandwidth[i][j][k] + v->VActiveCursorBandwidth[i][j][k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixelDataBWLuma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->TotImmediateFlipBytes = 0.0;\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\t\tv->TotImmediateFlipBytes = v->TotImmediateFlipBytes\n\t\t\t\t\t\t\t\t+ v->NoOfDPP[i][j][k] * (v->PDEAndMetaPTEBytesPerFrame[i][j][k] + v->MetaRowBytes[i][j][k]\n\t\t\t\t\t\t\t\t+ v->DPTEBytesPerRow[i][j][k]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\t\tHostVMInefficiencyFactor,\n\t\t\t\t\t\t\t\tv->ExtraLatency,\n\t\t\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k],\n\t\t\t\t\t\t\t\tv->MetaRowBytes[i][j][k],\n\t\t\t\t\t\t\t\tv->DPTEBytesPerRow[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->total_dcn_read_bw_with_flip = 0.0;\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\t\tv->total_dcn_read_bw_with_flip = v->total_dcn_read_bw_with_flip\n\t\t\t\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->final_flip_bw[k] + v->VActivePixelBandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->VActiveCursorBandwidth[i][j][k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* (v->final_flip_bw[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWLuma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = true;\n\t\t\t\t\tif (v->total_dcn_read_bw_with_flip > v->ReturnBWPerState[i][j]) {\n\t\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\t\t\tif (v->ImmediateFlipSupportedForPipe[k] == false) {\n\t\t\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t}\n\n\t\t\t\tif (v->MaxVStartup <= __DML_VBA_MIN_VSTARTUP__ || v->AnyLinesForVMOrRowTooLarge == false) {\n\t\t\t\t\tv->NextMaxVStartup = v->MaxMaxVStartup[i][j];\n\t\t\t\t\tNextPrefetchModeState = NextPrefetchModeState + 1;\n\t\t\t\t} else {\n\t\t\t\t\tv->NextMaxVStartup = v->NextMaxVStartup - 1;\n\t\t\t\t}\n\t\t\t\tv->NextPrefetchMode = v->NextPrefetchMode + 1;\n\t\t\t} while (!((v->PrefetchSupported[i][j] == true && v->DynamicMetadataSupported[i][j] == true && v->VRatioInPrefetchSupported[i][j] == true\n\t\t\t\t\t&& ((v->HostVMEnable == false &&\n\t\t\t\t\t\t\tv->ImmediateFlipRequirement[0] != dm_immediate_flip_required)\n\t\t\t\t\t\t\t|| v->ImmediateFlipSupportedForState[i][j] == true))\n\t\t\t\t\t|| (v->NextMaxVStartup == v->MaxMaxVStartup[i][j] && NextPrefetchModeState > MaxPrefetchMode)));\n\n\t\t\tCalculateUnboundedRequestAndCompressedBufferSize(\n\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\tv->ConfigReturnBufferSizeInKByte,\n\t\t\t\t\tv->UseUnboundedRequesting,\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j],\n\t\t\t\t\tNoChroma,\n\t\t\t\t\tv->MaxNumDPP,\n\t\t\t\t\tv->CompressedBufferSegmentSizeInkByte,\n\t\t\t\t\tv->Output,\n\t\t\t\t\t&UnboundedRequestEnabledThisState,\n\t\t\t\t\t&CompressedBufferSizeInkByteThisState);\n\n\t\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->PrefetchModePerState[i][j],\n\t\t\t\t\tv->DCFCLKState[i][j],\n\t\t\t\t\tv->ReturnBWPerState[i][j],\n\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\tv->ExtraLatency,\n\t\t\t\t\tv->SOCCLKPerState[i],\n\t\t\t\t\tv->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\tv->DETBufferSizeYThisState,\n\t\t\t\t\tv->DETBufferSizeCThisState,\n\t\t\t\t\tv->SwathHeightYThisState,\n\t\t\t\t\tv->SwathHeightCThisState,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->BytePerPixelInDETY,\n\t\t\t\t\tv->BytePerPixelInDETC,\n\t\t\t\t\tUnboundedRequestEnabledThisState,\n\t\t\t\t\tCompressedBufferSizeInkByteThisState,\n\t\t\t\t\t&v->DRAMClockChangeSupport[i][j],\n\t\t\t\t\t&dummy,\n\t\t\t\t\t&dummy,\n\t\t\t\t\t&dummy,\n\t\t\t\t\t&dummy);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tv->PTEBufferSizeNotExceeded[i][j] = true;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\t\t\tif (v->PTEBufferSizeNotExceededY[i][j][k] == false || v->PTEBufferSizeNotExceededC[i][j][k] == false) {\n\t\t\t\t\tv->PTEBufferSizeNotExceeded[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tv->CursorSupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->CursorWidth[k][0] > 0.0) {\n\t\t\tif (v->CursorBPP[k][0] == 64 && v->Cursor64BppSupport == false) {\n\t\t\t\tv->CursorSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tv->PitchSupport = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tv->AlignedYPitch[k] = dml_ceil(dml_max(v->PitchY[k], v->SurfaceWidthY[k]), v->MacroTileWidthY[k]);\n\t\tif (v->DCCEnable[k] == true) {\n\t\t\tv->AlignedDCCMetaPitchY[k] = dml_ceil(dml_max(v->DCCMetaPitchY[k], v->SurfaceWidthY[k]), 64.0 * v->Read256BlockWidthY[k]);\n\t\t} else {\n\t\t\tv->AlignedDCCMetaPitchY[k] = v->DCCMetaPitchY[k];\n\t\t}\n\t\tif (v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32 && v->SourcePixelFormat[k] != dm_444_16\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_16 && v->SourcePixelFormat[k] != dm_rgbe\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_8) {\n\t\t\tv->AlignedCPitch[k] = dml_ceil(dml_max(v->PitchC[k], v->SurfaceWidthC[k]), v->MacroTileWidthC[k]);\n\t\t\tif (v->DCCEnable[k] == true) {\n\t\t\t\tv->AlignedDCCMetaPitchC[k] = dml_ceil(\n\t\t\t\t\t\tdml_max(v->DCCMetaPitchC[k], v->SurfaceWidthC[k]),\n\t\t\t\t\t\t64.0 * v->Read256BlockWidthC[k]);\n\t\t\t} else {\n\t\t\t\tv->AlignedDCCMetaPitchC[k] = v->DCCMetaPitchC[k];\n\t\t\t}\n\t\t} else {\n\t\t\tv->AlignedCPitch[k] = v->PitchC[k];\n\t\t\tv->AlignedDCCMetaPitchC[k] = v->DCCMetaPitchC[k];\n\t\t}\n\t\tif (v->AlignedYPitch[k] > v->PitchY[k] || v->AlignedCPitch[k] > v->PitchC[k]\n\t\t\t\t|| v->AlignedDCCMetaPitchY[k] > v->DCCMetaPitchY[k] || v->AlignedDCCMetaPitchC[k] > v->DCCMetaPitchC[k]) {\n\t\t\tv->PitchSupport = false;\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; k++) {\n\t\tif (v->ViewportWidth[k] > v->SurfaceWidthY[k] || v->ViewportHeight[k] > v->SurfaceHeightY[k]) {\n\t\t\tViewportExceedsSurface = true;\n\t\t\tif (v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16 && v->SourcePixelFormat[k] != dm_444_8\n\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe) {\n\t\t\t\tif (v->ViewportWidthChroma[k] > v->SurfaceWidthC[k]\n\t\t\t\t\t\t|| v->ViewportHeightChroma[k] > v->SurfaceHeightC[k]) {\n\t\t\t\t\tViewportExceedsSurface = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = v->soc.num_states - 1; i >= 0; i--) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (v->ScaleRatioAndTapsSupport == true && v->SourceFormatPixelAndScanSupport == true && v->ViewportSizeSupport[i][j] == true\n\t\t\t\t\t&& v->LinkCapacitySupport[i] == true && !P2IWith420 && !DSCOnlyIfNecessaryWithBPP\n\t\t\t\t\t&& !DSC422NativeNotSupported && v->ODMCombine4To1SupportCheckOK[i] == true && v->NotEnoughDSCUnits[i] == false\n\t\t\t\t\t&& v->DTBCLKRequiredMoreThanSupported[i] == false\n\t\t\t\t\t&& v->ROBSupport[i][j] == true && v->DISPCLK_DPPCLK_Support[i][j] == true\n\t\t\t\t\t&& v->TotalAvailablePipesSupport[i][j] == true && EnoughWritebackUnits == true\n\t\t\t\t\t&& v->WritebackLatencySupport == true && v->WritebackScaleRatioAndTapsSupport == true\n\t\t\t\t\t&& v->CursorSupport == true && v->PitchSupport == true && ViewportExceedsSurface == false\n\t\t\t\t\t&& v->PrefetchSupported[i][j] == true && v->DynamicMetadataSupported[i][j] == true\n\t\t\t\t\t&& v->TotalVerticalActiveBandwidthSupport[i][j] == true && v->VRatioInPrefetchSupported[i][j] == true\n\t\t\t\t\t&& v->PTEBufferSizeNotExceeded[i][j] == true && v->NonsupportedDSCInputBPC == false\n\t\t\t\t\t&& ((v->HostVMEnable == false\n\t\t\t\t\t&& v->ImmediateFlipRequirement[0] != dm_immediate_flip_required)\n\t\t\t\t\t\t\t|| v->ImmediateFlipSupportedForState[i][j] == true)\n\t\t\t\t\t&& FMTBufferExceeded == false) {\n\t\t\t\tv->ModeSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->ModeSupport[i][j] = false;\n#ifdef __DML_VBA_DEBUG__\n\t\t\t\tif (v->ScaleRatioAndTapsSupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     ScaleRatioAndTapsSupport failed\");\n\t\t\t\tif (v->SourceFormatPixelAndScanSupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     SourceFormatPixelAndScanSupport failed\");\n\t\t\t\tif (v->ViewportSizeSupport[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     ViewportSizeSupport failed\");\n\t\t\t\tif (v->LinkCapacitySupport[i] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     LinkCapacitySupport failed\");\n\t\t\t\tif (v->ODMCombine4To1SupportCheckOK[i] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported failed\");\n\t\t\t\tif (v->NotEnoughDSCUnits[i] == true)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     NotEnoughDSCUnits\");\n\t\t\t\tif (v->DTBCLKRequiredMoreThanSupported[i] == true)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DTBCLKRequiredMoreThanSupported\");\n\t\t\t\tif (v->ROBSupport[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     ROBSupport failed\");\n\t\t\t\tif (v->DISPCLK_DPPCLK_Support[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DISPCLK_DPPCLK_Support failed\");\n\t\t\t\tif (v->TotalAvailablePipesSupport[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported failed\");\n\t\t\t\tif (EnoughWritebackUnits == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported failed\");\n\t\t\t\tif (v->WritebackLatencySupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     WritebackLatencySupport failed\");\n\t\t\t\tif (v->WritebackScaleRatioAndTapsSupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported \");\n\t\t\t\tif (v->CursorSupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported failed\");\n\t\t\t\tif (v->PitchSupport == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     PitchSupport failed\");\n\t\t\t\tif (ViewportExceedsSurface == true)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     ViewportExceedsSurface failed\");\n\t\t\t\tif (v->PrefetchSupported[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     PrefetchSupported failed\");\n\t\t\t\tif (v->DynamicMetadataSupported[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     DSC422NativeNotSupported failed\");\n\t\t\t\tif (v->TotalVerticalActiveBandwidthSupport[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     TotalVerticalActiveBandwidthSupport failed\");\n\t\t\t\tif (v->VRatioInPrefetchSupported[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     VRatioInPrefetchSupported failed\");\n\t\t\t\tif (v->PTEBufferSizeNotExceeded[i][j] == false)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     PTEBufferSizeNotExceeded failed\");\n\t\t\t\tif (v->NonsupportedDSCInputBPC == true)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     NonsupportedDSCInputBPC failed\");\n\t\t\t\tif (!((v->HostVMEnable == false\n\t\t\t\t\t&& v->ImmediateFlipRequirement[0] != dm_immediate_flip_required)\n\t\t\t\t\t\t\t|| v->ImmediateFlipSupportedForState[i][j] == true))\n\t\t\t\t\tdml_print(\"DML SUPPORT:     ImmediateFlipRequirement failed\");\n\t\t\t\tif (FMTBufferExceeded == true)\n\t\t\t\t\tdml_print(\"DML SUPPORT:     FMTBufferExceeded failed\");\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tunsigned int MaximumMPCCombine = 0;\n\t\tfor (i = v->soc.num_states; i >= 0; i--) {\n\t\t\tif (i == v->soc.num_states || v->ModeSupport[i][0] == true || v->ModeSupport[i][1] == true) {\n\t\t\t\tv->VoltageLevel = i;\n\t\t\t\tv->ModeIsSupported = v->ModeSupport[i][0] == true || v->ModeSupport[i][1] == true;\n\t\t\t\tif (v->ModeSupport[i][0] == true) {\n\t\t\t\t\tMaximumMPCCombine = 0;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumMPCCombine = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv->ImmediateFlipSupport = v->ImmediateFlipSupportedForState[v->VoltageLevel][MaximumMPCCombine];\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tv->MPCCombineEnable[k] = v->MPCCombine[v->VoltageLevel][MaximumMPCCombine][k];\n\t\t\tv->DPPPerPlane[k] = v->NoOfDPP[v->VoltageLevel][MaximumMPCCombine][k];\n\t\t}\n\t\tv->DCFCLK = v->DCFCLKState[v->VoltageLevel][MaximumMPCCombine];\n\t\tv->DRAMSpeed = v->DRAMSpeedPerState[v->VoltageLevel];\n\t\tv->FabricClock = v->FabricClockPerState[v->VoltageLevel];\n\t\tv->SOCCLK = v->SOCCLKPerState[v->VoltageLevel];\n\t\tv->ReturnBW = v->ReturnBWPerState[v->VoltageLevel][MaximumMPCCombine];\n\t\tv->maxMpcComb = MaximumMPCCombine;\n\t}\n}\n\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble SOCCLK,\n\t\tdouble DCFCLKDeepSleep,\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tbool UnboundedRequestEnabled,\n\t\tint unsigned CompressedBufferSizeInkByte,\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *Z8StutterExitWatermark,\n\t\tdouble *Z8StutterEnterPlusExitWatermark)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tdouble EffectiveLBLatencyHidingY;\n\tdouble EffectiveLBLatencyHidingC;\n\tdouble LinesInDETY[DC__NUM_DPP__MAX];\n\tdouble LinesInDETC;\n\tunsigned int LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];\n\tunsigned int LinesInDETCRoundedDownToSwath;\n\tdouble FullDETBufferingTimeY;\n\tdouble FullDETBufferingTimeC;\n\tdouble ActiveDRAMClockChangeLatencyMarginY;\n\tdouble ActiveDRAMClockChangeLatencyMarginC;\n\tdouble WritebackDRAMClockChangeLatencyMargin;\n\tdouble PlaneWithMinActiveDRAMClockChangeMargin;\n\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;\n\tdouble WritebackDRAMClockChangeLatencyHiding;\n\tdouble TotalPixelBW = 0.0;\n\tint k, j;\n\n\tv->UrgentWatermark = UrgentLatency + ExtraLatency;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: UrgentLatency = %f\\n\", __func__, UrgentLatency);\n\tdml_print(\"DML::%s: ExtraLatency = %f\\n\", __func__, ExtraLatency);\n\tdml_print(\"DML::%s: UrgentWatermark = %f\\n\", __func__, v->UrgentWatermark);\n#endif\n\n\tv->DRAMClockChangeWatermark = v->DRAMClockChangeLatency + v->UrgentWatermark;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: v->DRAMClockChangeLatency = %f\\n\", __func__, v->DRAMClockChangeLatency);\n\tdml_print(\"DML::%s: DRAMClockChangeWatermark = %f\\n\", __func__, v->DRAMClockChangeWatermark);\n#endif\n\n\tv->TotalActiveWriteback = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tv->TotalActiveWriteback = v->TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (v->TotalActiveWriteback <= 1) {\n\t\tv->WritebackUrgentWatermark = v->WritebackLatency;\n\t} else {\n\t\tv->WritebackUrgentWatermark = v->WritebackLatency + v->WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tif (v->TotalActiveWriteback <= 1) {\n\t\tv->WritebackDRAMClockChangeWatermark = v->DRAMClockChangeLatency + v->WritebackLatency;\n\t} else {\n\t\tv->WritebackDRAMClockChangeWatermark = v->DRAMClockChangeLatency + v->WritebackLatency + v->WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tTotalPixelBW = TotalPixelBW\n\t\t\t\t+ DPPPerPlane[k] * (SwathWidthY[k] * BytePerPixelDETY[k] * v->VRatio[k] + SwathWidthC[k] * BytePerPixelDETC[k] * v->VRatioChroma[k])\n\t\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k]);\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tdouble EffectiveDETBufferSizeY = DETBufferSizeY[k];\n\n\t\tv->LBLatencyHidingSourceLinesY = dml_min(\n\t\t\t\t(double) v->MaxLineBufferLines,\n\t\t\t\tdml_floor(v->LineBufferSize / v->LBBitPerPixel[k] / (SwathWidthY[k] / dml_max(v->HRatio[k], 1.0)), 1)) - (v->vtaps[k] - 1);\n\n\t\tv->LBLatencyHidingSourceLinesC = dml_min(\n\t\t\t\t(double) v->MaxLineBufferLines,\n\t\t\t\tdml_floor(v->LineBufferSize / v->LBBitPerPixel[k] / (SwathWidthC[k] / dml_max(v->HRatioChroma[k], 1.0)), 1)) - (v->VTAPsChroma[k] - 1);\n\n\t\tEffectiveLBLatencyHidingY = v->LBLatencyHidingSourceLinesY / v->VRatio[k] * (v->HTotal[k] / v->PixelClock[k]);\n\n\t\tEffectiveLBLatencyHidingC = v->LBLatencyHidingSourceLinesC / v->VRatioChroma[k] * (v->HTotal[k] / v->PixelClock[k]);\n\n\t\tif (UnboundedRequestEnabled) {\n\t\t\tEffectiveDETBufferSizeY = EffectiveDETBufferSizeY\n\t\t\t\t\t+ CompressedBufferSizeInkByte * 1024 * SwathWidthY[k] * BytePerPixelDETY[k] * v->VRatio[k] / (v->HTotal[k] / v->PixelClock[k]) / TotalPixelBW;\n\t\t}\n\n\t\tLinesInDETY[k] = (double) EffectiveDETBufferSizeY / BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath[k] = dml_floor(LinesInDETY[k], SwathHeightY[k]);\n\t\tFullDETBufferingTimeY = LinesInDETYRoundedDownToSwath[k] * (v->HTotal[k] / v->PixelClock[k]) / v->VRatio[k];\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tLinesInDETC = v->DETBufferSizeC[k] / BytePerPixelDETC[k] / SwathWidthC[k];\n\t\t\tLinesInDETCRoundedDownToSwath = dml_floor(LinesInDETC, SwathHeightC[k]);\n\t\t\tFullDETBufferingTimeC = LinesInDETCRoundedDownToSwath * (v->HTotal[k] / v->PixelClock[k]) / v->VRatioChroma[k];\n\t\t} else {\n\t\t\tLinesInDETC = 0;\n\t\t\tFullDETBufferingTimeC = 999999;\n\t\t}\n\n\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY\n\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;\n\n\t\tif (v->NumberOfActivePlanes > 1) {\n\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY\n\t\t\t\t\t- (1 - 1.0 / v->NumberOfActivePlanes) * SwathHeightY[k] * v->HTotal[k] / v->PixelClock[k] / v->VRatio[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC\n\t\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;\n\n\t\t\tif (v->NumberOfActivePlanes > 1) {\n\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC\n\t\t\t\t\t\t- (1 - 1.0 / v->NumberOfActivePlanes) * SwathHeightC[k] * v->HTotal[k] / v->PixelClock[k] / v->VRatioChroma[k];\n\t\t\t}\n\t\t\tv->ActiveDRAMClockChangeLatencyMargin[k] = dml_min(ActiveDRAMClockChangeLatencyMarginY, ActiveDRAMClockChangeLatencyMarginC);\n\t\t} else {\n\t\t\tv->ActiveDRAMClockChangeLatencyMargin[k] = ActiveDRAMClockChangeLatencyMarginY;\n\t\t}\n\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tWritebackDRAMClockChangeLatencyHiding = v->WritebackInterfaceBufferSize * 1024\n\t\t\t\t\t/ (v->WritebackDestinationWidth[k] * v->WritebackDestinationHeight[k] / (v->WritebackSourceHeight[k] * v->HTotal[k] / v->PixelClock[k]) * 4);\n\t\t\tif (v->WritebackPixelFormat[k] == dm_444_64) {\n\t\t\t\tWritebackDRAMClockChangeLatencyHiding = WritebackDRAMClockChangeLatencyHiding / 2;\n\t\t\t}\n\t\t\tWritebackDRAMClockChangeLatencyMargin = WritebackDRAMClockChangeLatencyHiding - v->WritebackDRAMClockChangeWatermark;\n\t\t\tv->ActiveDRAMClockChangeLatencyMargin[k] = dml_min(v->ActiveDRAMClockChangeLatencyMargin[k], WritebackDRAMClockChangeLatencyMargin);\n\t\t}\n\t}\n\n\tv->MinActiveDRAMClockChangeMargin = 999999;\n\tPlaneWithMinActiveDRAMClockChangeMargin = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->ActiveDRAMClockChangeLatencyMargin[k] < v->MinActiveDRAMClockChangeMargin) {\n\t\t\tv->MinActiveDRAMClockChangeMargin = v->ActiveDRAMClockChangeLatencyMargin[k];\n\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = k;\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) {\n\t\t\t\t\tif (v->BlendingAndTiming[k] == j) {\n\t\t\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tv->MinActiveDRAMClockChangeLatencySupported = v->MinActiveDRAMClockChangeMargin + v->DRAMClockChangeLatency ;\n\n\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 999999;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (!((k == PlaneWithMinActiveDRAMClockChangeMargin) && (v->BlendingAndTiming[k] == k)) && !(v->BlendingAndTiming[k] == PlaneWithMinActiveDRAMClockChangeMargin)\n\t\t\t\t&& v->ActiveDRAMClockChangeLatencyMargin[k] < SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank) {\n\t\t\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = v->ActiveDRAMClockChangeLatencyMargin[k];\n\t\t}\n\t}\n\n\tv->TotalNumberOfActiveOTG = 0;\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tv->TotalNumberOfActiveOTG = v->TotalNumberOfActiveOTG + 1;\n\t\t}\n\t}\n\n\tif (v->MinActiveDRAMClockChangeMargin > 0 && PrefetchMode == 0) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive;\n\t} else if ((v->SynchronizedVBlank == true || v->TotalNumberOfActiveOTG == 1\n\t\t\t|| SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank > 0) && PrefetchMode == 0) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank;\n\t} else {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t}\n\n\t*StutterExitWatermark = v->SRExitTime + ExtraLatency + 10 / DCFCLKDeepSleep;\n\t*StutterEnterPlusExitWatermark = (v->SREnterPlusExitTime + ExtraLatency + 10 / DCFCLKDeepSleep);\n\t*Z8StutterExitWatermark = v->SRExitZ8Time + ExtraLatency + 10 / DCFCLKDeepSleep;\n\t*Z8StutterEnterPlusExitWatermark = v->SREnterPlusExitZ8Time + ExtraLatency + 10 / DCFCLKDeepSleep;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: StutterExitWatermark = %f\\n\", __func__, *StutterExitWatermark);\n\tdml_print(\"DML::%s: StutterEnterPlusExitWatermark = %f\\n\", __func__, *StutterEnterPlusExitWatermark);\n\tdml_print(\"DML::%s: Z8StutterExitWatermark = %f\\n\", __func__, *Z8StutterExitWatermark);\n\tdml_print(\"DML::%s: Z8StutterEnterPlusExitWatermark = %f\\n\", __func__, *Z8StutterEnterPlusExitWatermark);\n#endif\n}\n\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tint ReturnBusWidth,\n\t\tdouble *DCFCLKDeepSleep)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tdouble DisplayPipeLineDeliveryTimeLuma;\n\tdouble DisplayPipeLineDeliveryTimeChroma;\n\tdouble ReadBandwidth = 0.0;\n\tint k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (BytePerPixelC[k] > 0) {\n\t\t\tv->DCFCLKDeepSleepPerPlane[k] = dml_max(__DML_MIN_DCFCLK_FACTOR__ * SwathWidthY[k] * BytePerPixelY[k] / 32.0 / DisplayPipeLineDeliveryTimeLuma,\n\t\t\t__DML_MIN_DCFCLK_FACTOR__ * SwathWidthC[k] * BytePerPixelC[k] / 32.0 / DisplayPipeLineDeliveryTimeChroma);\n\t\t} else {\n\t\t\tv->DCFCLKDeepSleepPerPlane[k] = __DML_MIN_DCFCLK_FACTOR__ * SwathWidthY[k] * BytePerPixelY[k] / 64.0 / DisplayPipeLineDeliveryTimeLuma;\n\t\t}\n\t\tv->DCFCLKDeepSleepPerPlane[k] = dml_max(v->DCFCLKDeepSleepPerPlane[k], PixelClock[k] / 16);\n\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tReadBandwidth = ReadBandwidth + ReadBandwidthLuma[k] + ReadBandwidthChroma[k];\n\t}\n\n\t*DCFCLKDeepSleep = dml_max(8.0, __DML_MIN_DCFCLK_FACTOR__ * ReadBandwidth / ReturnBusWidth);\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\t*DCFCLKDeepSleep = dml_max(*DCFCLKDeepSleep, v->DCFCLKDeepSleepPerPlane[k]);\n\t}\n}\n\nstatic void CalculateUrgentBurstFactor(\n\t\tint swath_width_luma_ub,\n\t\tint swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble DETBufferSizeY,\n\t\tdouble DETBufferSizeC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tbool *NotEnoughUrgentLatencyHiding)\n{\n\tdouble LinesInDETLuma;\n\tdouble LinesInDETChroma;\n\tunsigned int LinesInCursorBuffer;\n\tdouble CursorBufferSizeInTime;\n\tdouble DETBufferSizeInTimeLuma;\n\tdouble DETBufferSizeInTimeChroma;\n\n\t*NotEnoughUrgentLatencyHiding = 0;\n\n\tif (CursorWidth > 0) {\n\t\tLinesInCursorBuffer = 1 << (unsigned int) dml_floor(dml_log2(CursorBufferSize * 1024.0 / (CursorWidth * CursorBPP / 8.0)), 1.0);\n\t\tif (VRatio > 0) {\n\t\t\tCursorBufferSizeInTime = LinesInCursorBuffer * LineTime / VRatio;\n\t\t\tif (CursorBufferSizeInTime - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorCursor = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorCursor = CursorBufferSizeInTime / (CursorBufferSizeInTime - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorCursor = 1;\n\t\t}\n\t}\n\n\tLinesInDETLuma = DETBufferSizeY / BytePerPixelInDETY / swath_width_luma_ub;\n\tif (VRatio > 0) {\n\t\tDETBufferSizeInTimeLuma = dml_floor(LinesInDETLuma, SwathHeightY) * LineTime / VRatio;\n\t\tif (DETBufferSizeInTimeLuma - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t*UrgentBurstFactorLuma = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorLuma = DETBufferSizeInTimeLuma / (DETBufferSizeInTimeLuma - UrgentLatency);\n\t\t}\n\t} else {\n\t\t*UrgentBurstFactorLuma = 1;\n\t}\n\n\tif (BytePerPixelInDETC > 0) {\n\t\tLinesInDETChroma = DETBufferSizeC / BytePerPixelInDETC / swath_width_chroma_ub;\n\t\tif (VRatio > 0) {\n\t\t\tDETBufferSizeInTimeChroma = dml_floor(LinesInDETChroma, SwathHeightC) * LineTime / VRatio;\n\t\t\tif (DETBufferSizeInTimeChroma - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorChroma = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorChroma = DETBufferSizeInTimeChroma / (DETBufferSizeInTimeChroma - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorChroma = 1;\n\t\t}\n\t}\n}\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int NumberOfCursors[],\n\t\tunsigned int CursorWidth[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int CursorBPP[][DC__NUM_CURSOR__MAX],\n\t\tunsigned int BlockWidth256BytesY[],\n\t\tunsigned int BlockHeight256BytesY[],\n\t\tunsigned int BlockWidth256BytesC[],\n\t\tunsigned int BlockHeight256BytesC[],\n\t\tdouble DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[],\n\t\tdouble CursorRequestDeliveryTime[],\n\t\tdouble CursorRequestDeliveryTimePrefetch[])\n{\n\tdouble req_per_swath_ub;\n\tint k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioPrefetchC[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = swath_width_chroma_ub[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = swath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockWidth256BytesY[k];\n\t\t} else {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockHeight256BytesY[k];\n\t\t}\n\t\tDisplayPipeRequestDeliveryTimeLuma[k] = DisplayPipeLineDeliveryTimeLuma[k] / req_per_swath_ub;\n\t\tDisplayPipeRequestDeliveryTimeLumaPrefetch[k] = DisplayPipeLineDeliveryTimeLumaPrefetch[k] / req_per_swath_ub;\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = 0;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockWidth256BytesC[k];\n\t\t\t} else {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockHeight256BytesC[k];\n\t\t\t}\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = DisplayPipeLineDeliveryTimeChroma[k] / req_per_swath_ub;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = DisplayPipeLineDeliveryTimeChromaPrefetch[k] / req_per_swath_ub;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : HRatio = %f\\n\", __func__, k, HRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d : VRatio = %f\\n\", __func__, k, VRatio[k]);\n\t\tdml_print(\"DML::%s: k=%d : HRatioChroma = %f\\n\", __func__, k, HRatioChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : VRatioChroma = %f\\n\", __func__, k, VRatioChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeLuma = %f\\n\", __func__, k, DisplayPipeLineDeliveryTimeLuma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeLumaPrefetch = %f\\n\", __func__, k, DisplayPipeLineDeliveryTimeLumaPrefetch[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeChroma = %f\\n\", __func__, k, DisplayPipeLineDeliveryTimeChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeLineDeliveryTimeChromaPrefetch = %f\\n\", __func__, k, DisplayPipeLineDeliveryTimeChromaPrefetch[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeLuma = %f\\n\", __func__, k, DisplayPipeRequestDeliveryTimeLuma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeLumaPrefetch = %f\\n\", __func__, k, DisplayPipeRequestDeliveryTimeLumaPrefetch[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeChroma = %f\\n\", __func__, k, DisplayPipeRequestDeliveryTimeChroma[k]);\n\t\tdml_print(\"DML::%s: k=%d : DisplayPipeRequestDeliveryTimeChromaPrefetch = %f\\n\", __func__, k, DisplayPipeRequestDeliveryTimeChromaPrefetch[k]);\n#endif\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tint cursor_req_per_width;\n\t\tcursor_req_per_width = dml_ceil(CursorWidth[k][0] * CursorBPP[k][0] / 256 / 8, 1);\n\t\tif (NumberOfCursors[k] > 0) {\n\t\t\tif (VRatio[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTime[k] = CursorWidth[k][0] / HRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTime[k] = CursorWidth[k][0] / PSCL_THROUGHPUT[k] / DPPCLK[k] / cursor_req_per_width;\n\t\t\t}\n\t\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = CursorWidth[k][0] / HRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = CursorWidth[k][0] / PSCL_THROUGHPUT[k] / DPPCLK[k] / cursor_req_per_width;\n\t\t\t}\n\t\t} else {\n\t\t\tCursorRequestDeliveryTime[k] = 0;\n\t\t\tCursorRequestDeliveryTimePrefetch[k] = 0;\n\t\t}\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d : NumberOfCursors = %d\\n\", __func__, k, NumberOfCursors[k]);\n\t\tdml_print(\"DML::%s: k=%d : CursorRequestDeliveryTime = %f\\n\", __func__, k, CursorRequestDeliveryTime[k]);\n\t\tdml_print(\"DML::%s: k=%d : CursorRequestDeliveryTimePrefetch = %f\\n\", __func__, k, CursorRequestDeliveryTimePrefetch[k]);\n#endif\n\t}\n}\n\nstatic void CalculateMetaAndPTETimes(\n\t\tint NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tint MetaChunkSize,\n\t\tint MinMetaChunkSizeBytes,\n\t\tint HTotal[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble DestinationLinesToRequestRowInVBlank[],\n\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint dpte_row_height[],\n\t\tint dpte_row_height_chroma[],\n\t\tint meta_row_width[],\n\t\tint meta_row_width_chroma[],\n\t\tint meta_row_height[],\n\t\tint meta_row_height_chroma[],\n\t\tint meta_req_width[],\n\t\tint meta_req_width_chroma[],\n\t\tint meta_req_height[],\n\t\tint meta_req_height_chroma[],\n\t\tint dpte_group_bytes[],\n\t\tint PTERequestSizeY[],\n\t\tint PTERequestSizeC[],\n\t\tint PixelPTEReqWidthY[],\n\t\tint PixelPTEReqHeightY[],\n\t\tint PixelPTEReqWidthC[],\n\t\tint PixelPTEReqHeightC[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_C[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerChromaMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerChromaMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble TimePerChromaMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[])\n{\n\tunsigned int meta_chunk_width;\n\tunsigned int min_meta_chunk_width;\n\tunsigned int meta_chunk_per_row_int;\n\tunsigned int meta_row_remainder;\n\tunsigned int meta_chunk_threshold;\n\tunsigned int meta_chunks_per_row_ub;\n\tunsigned int meta_chunk_width_chroma;\n\tunsigned int min_meta_chunk_width_chroma;\n\tunsigned int meta_chunk_per_row_int_chroma;\n\tunsigned int meta_row_remainder_chroma;\n\tunsigned int meta_chunk_threshold_chroma;\n\tunsigned int meta_chunks_per_row_ub_chroma;\n\tunsigned int dpte_group_width_luma;\n\tunsigned int dpte_groups_per_row_luma_ub;\n\tunsigned int dpte_group_width_chroma;\n\tunsigned int dpte_groups_per_row_chroma_ub;\n\tint k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tDST_Y_PER_PTE_ROW_NOM_L[k] = dpte_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = 0;\n\t\t} else {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = dpte_row_height_chroma[k] / VRatioChroma[k];\n\t\t}\n\t\tDST_Y_PER_META_ROW_NOM_L[k] = meta_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = 0;\n\t\t} else {\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = meta_row_height_chroma[k] / VRatioChroma[k];\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmeta_chunk_width = MetaChunkSize * 1024 * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmin_meta_chunk_width = MinMetaChunkSizeBytes * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmeta_chunk_per_row_int = meta_row_width[k] / meta_chunk_width;\n\t\t\tmeta_row_remainder = meta_row_width[k] % meta_chunk_width;\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_width[k];\n\t\t\t} else {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_height[k];\n\t\t\t}\n\t\t\tif (meta_row_remainder <= meta_chunk_threshold) {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 1;\n\t\t\t} else {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 2;\n\t\t\t}\n\t\t\tTimePerMetaChunkNominal[k] = meta_row_height[k] / VRatio[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t\t} else {\n\t\t\t\tmeta_chunk_width_chroma = MetaChunkSize * 1024 * 256 / BytePerPixelC[k] / meta_row_height_chroma[k];\n\t\t\t\tmin_meta_chunk_width_chroma = MinMetaChunkSizeBytes * 256 / BytePerPixelC[k] / meta_row_height_chroma[k];\n\t\t\t\tmeta_chunk_per_row_int_chroma = (double) meta_row_width_chroma[k] / meta_chunk_width_chroma;\n\t\t\t\tmeta_row_remainder_chroma = meta_row_width_chroma[k] % meta_chunk_width_chroma;\n\t\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma - meta_req_width_chroma[k];\n\t\t\t\t} else {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma - meta_req_height_chroma[k];\n\t\t\t\t}\n\t\t\t\tif (meta_row_remainder_chroma <= meta_chunk_threshold_chroma) {\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 2;\n\t\t\t\t}\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = meta_row_height_chroma[k] / VRatioChroma[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t}\n\t\t} else {\n\t\t\tTimePerMetaChunkNominal[k] = 0;\n\t\t\tTimePerMetaChunkVBlank[k] = 0;\n\t\t\tTimePerMetaChunkFlip[k] = 0;\n\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true) {\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k] * PixelPTEReqWidthY[k];\n\t\t\t} else {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k] * PixelPTEReqHeightY[k];\n\t\t\t}\n\t\t\tdpte_groups_per_row_luma_ub = dml_ceil(1.0 * dpte_row_width_luma_ub[k] / dpte_group_width_luma, 1);\n\t\t\ttime_per_pte_group_nom_luma[k] = DST_Y_PER_PTE_ROW_NOM_L[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_vblank_luma[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_flip_luma[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t\t} else {\n\t\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k] / PTERequestSizeC[k] * PixelPTEReqWidthC[k];\n\t\t\t\t} else {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k] / PTERequestSizeC[k] * PixelPTEReqHeightC[k];\n\t\t\t\t}\n\t\t\t\tdpte_groups_per_row_chroma_ub = dml_ceil(1.0 * dpte_row_width_chroma_ub[k] / dpte_group_width_chroma, 1);\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = DST_Y_PER_PTE_ROW_NOM_C[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t}\n\t\t} else {\n\t\t\ttime_per_pte_group_nom_luma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_luma[k] = 0;\n\t\t\ttime_per_pte_group_flip_luma[k] = 0;\n\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t}\n\t}\n}\n\nstatic void CalculateVMGroupAndRequestTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int HTotal[],\n\t\tint BytePerPixelC[],\n\t\tdouble DestinationLinesToRequestVMInVBlank[],\n\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tint vm_group_bytes[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tint meta_pte_bytes_per_frame_ub_l[],\n\t\tint meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble TimePerVMGroupVBlank[],\n\t\tdouble TimePerVMGroupFlip[],\n\t\tdouble TimePerVMRequestVBlank[],\n\t\tdouble TimePerVMRequestFlip[])\n{\n\tint num_group_per_lower_vm_stage;\n\tint num_req_per_lower_vm_stage;\n\tint k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true && (DCCEnable[k] == true || GPUVMMaxPageTableLevels > 1)) {\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t} else {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 2 + dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 1 + dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64 + dpde0_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t} else {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64 + meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64 + dpde0_bytes_per_frame_ub_c[k] / 64\n\t\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_l[k] / 64 + meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64 + meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTimePerVMGroupVBlank[k] = DestinationLinesToRequestVMInVBlank[k] * HTotal[k] / PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMGroupFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] * HTotal[k] / PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMRequestVBlank[k] = DestinationLinesToRequestVMInVBlank[k] * HTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\t\t\tTimePerVMRequestFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] * HTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\n\t\t\tif (GPUVMMaxPageTableLevels > 2) {\n\t\t\t\tTimePerVMGroupVBlank[k] = TimePerVMGroupVBlank[k] / 2;\n\t\t\t\tTimePerVMGroupFlip[k] = TimePerVMGroupFlip[k] / 2;\n\t\t\t\tTimePerVMRequestVBlank[k] = TimePerVMRequestVBlank[k] / 2;\n\t\t\t\tTimePerVMRequestFlip[k] = TimePerVMRequestFlip[k] / 2;\n\t\t\t}\n\n\t\t} else {\n\t\t\tTimePerVMGroupVBlank[k] = 0;\n\t\t\tTimePerVMGroupFlip[k] = 0;\n\t\t\tTimePerVMRequestVBlank[k] = 0;\n\t\t\tTimePerVMRequestFlip[k] = 0;\n\t\t}\n\t}\n}\n\nstatic void CalculateStutterEfficiency(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tint CompressedBufferSizeInkByte,\n\t\tbool UnboundedRequestEnabled,\n\t\tint ConfigReturnBufferSizeInKByte,\n\t\tint MetaFIFOSizeInKEntries,\n\t\tint ZeroSizeBufferEntries,\n\t\tint NumberOfActivePlanes,\n\t\tint ROBBufferSizeInKByte,\n\t\tdouble TotalDataReadBandwidth,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble COMPBUF_RESERVED_SPACE_64B,\n\t\tdouble COMPBUF_RESERVED_SPACE_ZS,\n\t\tdouble SRExitTime,\n\t\tdouble SRExitZ8Time,\n\t\tbool SynchronizedVBlank,\n\t\tdouble Z8StutterEnterPlusExitWatermark,\n\t\tdouble StutterEnterPlusExitWatermark,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tbool Interlace[],\n\t\tdouble MinTTUVBlank[],\n\t\tint DPPPerPlane[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tint BytePerPixelY[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble SwathWidthY[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tdouble NetDCCRateLuma[],\n\t\tdouble NetDCCRateChroma[],\n\t\tdouble DCCFractionOfZeroSizeRequestsLuma[],\n\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],\n\t\tint HTotal[],\n\t\tint VTotal[],\n\t\tdouble PixelClock[],\n\t\tdouble VRatio[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint BlockHeight256BytesY[],\n\t\tint BlockWidth256BytesY[],\n\t\tint BlockHeight256BytesC[],\n\t\tint BlockWidth256BytesC[],\n\t\tint DCCYMaxUncompressedBlock[],\n\t\tint DCCCMaxUncompressedBlock[],\n\t\tint VActive[],\n\t\tbool DCCEnable[],\n\t\tbool WritebackEnable[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tdouble meta_row_bw[],\n\t\tdouble dpte_row_bw[],\n\t\tdouble *StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *StutterEfficiency,\n\t\tint *NumberOfStutterBurstsPerFrame,\n\t\tdouble *Z8StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *Z8StutterEfficiency,\n\t\tint *Z8NumberOfStutterBurstsPerFrame,\n\t\tdouble *StutterPeriod)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\n\tdouble DETBufferingTimeY;\n\tdouble SwathWidthYCriticalPlane = 0;\n\tdouble VActiveTimeCriticalPlane = 0;\n\tdouble FrameTimeCriticalPlane = 0;\n\tint BytePerPixelYCriticalPlane = 0;\n\tdouble LinesToFinishSwathTransferStutterCriticalPlane = 0;\n\tdouble MinTTUVBlankCriticalPlane = 0;\n\tdouble TotalCompressedReadBandwidth;\n\tdouble TotalRowReadBandwidth;\n\tdouble AverageDCCCompressionRate;\n\tdouble EffectiveCompressedBufferSize;\n\tdouble PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer;\n\tdouble StutterBurstTime;\n\tint TotalActiveWriteback;\n\tdouble LinesInDETY;\n\tdouble LinesInDETYRoundedDownToSwath;\n\tdouble MaximumEffectiveCompressionLuma;\n\tdouble MaximumEffectiveCompressionChroma;\n\tdouble TotalZeroSizeRequestReadBandwidth;\n\tdouble TotalZeroSizeCompressedReadBandwidth;\n\tdouble AverageDCCZeroSizeFraction;\n\tdouble AverageZeroSizeCompressionRate;\n\tint TotalNumberOfActiveOTG = 0;\n\tdouble LastStutterPeriod = 0.0;\n\tdouble LastZ8StutterPeriod = 0.0;\n\tint k;\n\n\tTotalZeroSizeRequestReadBandwidth = 0;\n\tTotalZeroSizeCompressedReadBandwidth = 0;\n\tTotalRowReadBandwidth = 0;\n\tTotalCompressedReadBandwidth = 0;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tif ((SourceScan[k] == dm_vert && BlockWidth256BytesY[k] > SwathHeightY[k]) || (SourceScan[k] != dm_vert && BlockHeight256BytesY[k] > SwathHeightY[k])\n\t\t\t\t\t|| DCCYMaxUncompressedBlock[k] < 256) {\n\t\t\t\tMaximumEffectiveCompressionLuma = 2;\n\t\t\t} else {\n\t\t\t\tMaximumEffectiveCompressionLuma = 4;\n\t\t\t}\n\t\t\tTotalCompressedReadBandwidth = TotalCompressedReadBandwidth + ReadBandwidthPlaneLuma[k] / dml_min(NetDCCRateLuma[k], MaximumEffectiveCompressionLuma);\n\t\t\tTotalZeroSizeRequestReadBandwidth = TotalZeroSizeRequestReadBandwidth + ReadBandwidthPlaneLuma[k] * DCCFractionOfZeroSizeRequestsLuma[k];\n\t\t\tTotalZeroSizeCompressedReadBandwidth = TotalZeroSizeCompressedReadBandwidth\n\t\t\t\t\t+ ReadBandwidthPlaneLuma[k] * DCCFractionOfZeroSizeRequestsLuma[k] / MaximumEffectiveCompressionLuma;\n\t\t\tif (ReadBandwidthPlaneChroma[k] > 0) {\n\t\t\t\tif ((SourceScan[k] == dm_vert && BlockWidth256BytesC[k] > SwathHeightC[k])\n\t\t\t\t\t\t|| (SourceScan[k] != dm_vert && BlockHeight256BytesC[k] > SwathHeightC[k]) || DCCCMaxUncompressedBlock[k] < 256) {\n\t\t\t\t\tMaximumEffectiveCompressionChroma = 2;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumEffectiveCompressionChroma = 4;\n\t\t\t\t}\n\t\t\t\tTotalCompressedReadBandwidth = TotalCompressedReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthPlaneChroma[k] / dml_min(NetDCCRateChroma[k], MaximumEffectiveCompressionChroma);\n\t\t\t\tTotalZeroSizeRequestReadBandwidth = TotalZeroSizeRequestReadBandwidth + ReadBandwidthPlaneChroma[k] * DCCFractionOfZeroSizeRequestsChroma[k];\n\t\t\t\tTotalZeroSizeCompressedReadBandwidth = TotalZeroSizeCompressedReadBandwidth\n\t\t\t\t\t\t+ ReadBandwidthPlaneChroma[k] * DCCFractionOfZeroSizeRequestsChroma[k] / MaximumEffectiveCompressionChroma;\n\t\t\t}\n\t\t} else {\n\t\t\tTotalCompressedReadBandwidth = TotalCompressedReadBandwidth + ReadBandwidthPlaneLuma[k] + ReadBandwidthPlaneChroma[k];\n\t\t}\n\t\tTotalRowReadBandwidth = TotalRowReadBandwidth + DPPPerPlane[k] * (meta_row_bw[k] + dpte_row_bw[k]);\n\t}\n\n\tAverageDCCCompressionRate = TotalDataReadBandwidth / TotalCompressedReadBandwidth;\n\tAverageDCCZeroSizeFraction = TotalZeroSizeRequestReadBandwidth / TotalDataReadBandwidth;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: TotalCompressedReadBandwidth = %f\\n\", __func__, TotalCompressedReadBandwidth);\n\tdml_print(\"DML::%s: TotalZeroSizeRequestReadBandwidth = %f\\n\", __func__, TotalZeroSizeRequestReadBandwidth);\n\tdml_print(\"DML::%s: TotalZeroSizeCompressedReadBandwidth = %f\\n\", __func__, TotalZeroSizeCompressedReadBandwidth);\n\tdml_print(\"DML::%s: MaximumEffectiveCompressionLuma = %f\\n\", __func__, MaximumEffectiveCompressionLuma);\n\tdml_print(\"DML::%s: MaximumEffectiveCompressionChroma = %f\\n\", __func__, MaximumEffectiveCompressionChroma);\n\tdml_print(\"DML::%s: AverageDCCCompressionRate = %f\\n\", __func__, AverageDCCCompressionRate);\n\tdml_print(\"DML::%s: AverageDCCZeroSizeFraction = %f\\n\", __func__, AverageDCCZeroSizeFraction);\n\tdml_print(\"DML::%s: CompressedBufferSizeInkByte = %d\\n\", __func__, CompressedBufferSizeInkByte);\n#endif\n\n\tif (AverageDCCZeroSizeFraction == 1) {\n\t\tAverageZeroSizeCompressionRate = TotalZeroSizeRequestReadBandwidth / TotalZeroSizeCompressedReadBandwidth;\n\t\tEffectiveCompressedBufferSize = MetaFIFOSizeInKEntries * 1024 * 64 * AverageZeroSizeCompressionRate + (ZeroSizeBufferEntries - COMPBUF_RESERVED_SPACE_ZS) * 64 * AverageZeroSizeCompressionRate;\n\t} else if (AverageDCCZeroSizeFraction > 0) {\n\t\tAverageZeroSizeCompressionRate = TotalZeroSizeRequestReadBandwidth / TotalZeroSizeCompressedReadBandwidth;\n\t\tEffectiveCompressedBufferSize = dml_min(\n\t\t\t\tCompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate,\n\t\t\t\tMetaFIFOSizeInKEntries * 1024 * 64 / (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate + 1 / AverageDCCCompressionRate))\n\t\t\t\t\t+ dml_min((ROBBufferSizeInKByte * 1024 - COMPBUF_RESERVED_SPACE_64B * 64) * AverageDCCCompressionRate,\n\t\t\t\t\t\t(ZeroSizeBufferEntries - COMPBUF_RESERVED_SPACE_ZS) * 64 / (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate));\n\t\tdml_print(\"DML::%s: min 1 = %f\\n\", __func__, CompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate);\n\t\tdml_print(\n\t\t\t\t\"DML::%s: min 2 = %f\\n\",\n\t\t\t\t__func__,\n\t\t\t\tMetaFIFOSizeInKEntries * 1024 * 64 / (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate + 1 / AverageDCCCompressionRate));\n\t\tdml_print(\"DML::%s: min 3 = %f\\n\", __func__, ROBBufferSizeInKByte * 1024 * AverageDCCCompressionRate);\n\t\tdml_print(\"DML::%s: min 4 = %f\\n\", __func__, ZeroSizeBufferEntries * 64 / (AverageDCCZeroSizeFraction / AverageZeroSizeCompressionRate));\n\t} else {\n\t\tEffectiveCompressedBufferSize = dml_min(\n\t\t\t\tCompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate,\n\t\t\t\tMetaFIFOSizeInKEntries * 1024 * 64 * AverageDCCCompressionRate) + (ROBBufferSizeInKByte * 1024 - COMPBUF_RESERVED_SPACE_64B * 64) * AverageDCCCompressionRate;\n\t\tdml_print(\"DML::%s: min 1 = %f\\n\", __func__, CompressedBufferSizeInkByte * 1024 * AverageDCCCompressionRate);\n\t\tdml_print(\"DML::%s: min 2 = %f\\n\", __func__, MetaFIFOSizeInKEntries * 1024 * 64 * AverageDCCCompressionRate);\n\t}\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: MetaFIFOSizeInKEntries = %d\\n\", __func__, MetaFIFOSizeInKEntries);\n\tdml_print(\"DML::%s: AverageZeroSizeCompressionRate = %f\\n\", __func__, AverageZeroSizeCompressionRate);\n\tdml_print(\"DML::%s: EffectiveCompressedBufferSize = %f\\n\", __func__, EffectiveCompressedBufferSize);\n#endif\n\n\t*StutterPeriod = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tLinesInDETY = (DETBufferSizeY[k] + (UnboundedRequestEnabled == true ? EffectiveCompressedBufferSize : 0) * ReadBandwidthPlaneLuma[k] / TotalDataReadBandwidth)\n\t\t\t\t/ BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath = dml_floor(LinesInDETY, SwathHeightY[k]);\n\t\tDETBufferingTimeY = LinesInDETYRoundedDownToSwath * (HTotal[k] / PixelClock[k]) / VRatio[k];\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%0d DETBufferSizeY = %f\\n\", __func__, k, DETBufferSizeY[k]);\n\t\tdml_print(\"DML::%s: k=%0d BytePerPixelDETY = %f\\n\", __func__, k, BytePerPixelDETY[k]);\n\t\tdml_print(\"DML::%s: k=%0d SwathWidthY = %f\\n\", __func__, k, SwathWidthY[k]);\n\t\tdml_print(\"DML::%s: k=%0d ReadBandwidthPlaneLuma = %f\\n\", __func__, k, ReadBandwidthPlaneLuma[k]);\n\t\tdml_print(\"DML::%s: k=%0d TotalDataReadBandwidth = %f\\n\", __func__, k, TotalDataReadBandwidth);\n\t\tdml_print(\"DML::%s: k=%0d LinesInDETY = %f\\n\", __func__, k, LinesInDETY);\n\t\tdml_print(\"DML::%s: k=%0d LinesInDETYRoundedDownToSwath = %f\\n\", __func__, k, LinesInDETYRoundedDownToSwath);\n\t\tdml_print(\"DML::%s: k=%0d HTotal = %d\\n\", __func__, k, HTotal[k]);\n\t\tdml_print(\"DML::%s: k=%0d PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n\t\tdml_print(\"DML::%s: k=%0d VRatio = %f\\n\", __func__, k, VRatio[k]);\n\t\tdml_print(\"DML::%s: k=%0d DETBufferingTimeY = %f\\n\", __func__, k, DETBufferingTimeY);\n\t\tdml_print(\"DML::%s: k=%0d PixelClock = %f\\n\", __func__, k, PixelClock[k]);\n#endif\n\n\t\tif (k == 0 || DETBufferingTimeY < *StutterPeriod) {\n\t\t\tbool isInterlaceTiming = Interlace[k] && !ProgressiveToInterlaceUnitInOPP;\n\n\t\t\t*StutterPeriod = DETBufferingTimeY;\n\t\t\tFrameTimeCriticalPlane = (isInterlaceTiming ? dml_floor(VTotal[k] / 2.0, 1.0) : VTotal[k]) * HTotal[k] / PixelClock[k];\n\t\t\tVActiveTimeCriticalPlane = (isInterlaceTiming ? dml_floor(VActive[k] / 2.0, 1.0) : VActive[k]) * HTotal[k] / PixelClock[k];\n\t\t\tBytePerPixelYCriticalPlane = BytePerPixelY[k];\n\t\t\tSwathWidthYCriticalPlane = SwathWidthY[k];\n\t\t\tLinesToFinishSwathTransferStutterCriticalPlane = SwathHeightY[k] - (LinesInDETY - LinesInDETYRoundedDownToSwath);\n\t\t\tMinTTUVBlankCriticalPlane = MinTTUVBlank[k];\n\n#ifdef __DML_VBA_DEBUG__\n\t\t\tdml_print(\"DML::%s: StutterPeriod = %f\\n\", __func__, *StutterPeriod);\n\t\t\tdml_print(\"DML::%s: MinTTUVBlankCriticalPlane = %f\\n\", __func__, MinTTUVBlankCriticalPlane);\n\t\t\tdml_print(\"DML::%s: FrameTimeCriticalPlane = %f\\n\", __func__, FrameTimeCriticalPlane);\n\t\t\tdml_print(\"DML::%s: VActiveTimeCriticalPlane = %f\\n\", __func__, VActiveTimeCriticalPlane);\n\t\t\tdml_print(\"DML::%s: BytePerPixelYCriticalPlane = %d\\n\", __func__, BytePerPixelYCriticalPlane);\n\t\t\tdml_print(\"DML::%s: SwathWidthYCriticalPlane = %f\\n\", __func__, SwathWidthYCriticalPlane);\n\t\t\tdml_print(\"DML::%s: LinesToFinishSwathTransferStutterCriticalPlane = %f\\n\", __func__, LinesToFinishSwathTransferStutterCriticalPlane);\n#endif\n\t\t}\n\t}\n\n\tPartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer = dml_min(*StutterPeriod * TotalDataReadBandwidth, EffectiveCompressedBufferSize);\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: ROBBufferSizeInKByte = %d\\n\", __func__, ROBBufferSizeInKByte);\n\tdml_print(\"DML::%s: AverageDCCCompressionRate = %f\\n\", __func__, AverageDCCCompressionRate);\n\tdml_print(\"DML::%s: StutterPeriod * TotalDataReadBandwidth = %f\\n\", __func__, *StutterPeriod * TotalDataReadBandwidth);\n\tdml_print(\"DML::%s: ROBBufferSizeInKByte * 1024 * AverageDCCCompressionRate + EffectiveCompressedBufferSize = %f\\n\", __func__, ROBBufferSizeInKByte * 1024 * AverageDCCCompressionRate + EffectiveCompressedBufferSize);\n\tdml_print(\"DML::%s: EffectiveCompressedBufferSize = %f\\n\", __func__, EffectiveCompressedBufferSize);\n\tdml_print(\"DML::%s: PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer = %f\\n\", __func__, PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer);\n\tdml_print(\"DML::%s: ReturnBW = %f\\n\", __func__, ReturnBW);\n\tdml_print(\"DML::%s: TotalDataReadBandwidth = %f\\n\", __func__, TotalDataReadBandwidth);\n\tdml_print(\"DML::%s: TotalRowReadBandwidth = %f\\n\", __func__, TotalRowReadBandwidth);\n\tdml_print(\"DML::%s: DCFCLK = %f\\n\", __func__, DCFCLK);\n#endif\n\n\tStutterBurstTime = PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer / AverageDCCCompressionRate / ReturnBW\n\t\t\t+ (*StutterPeriod * TotalDataReadBandwidth - PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer) / (DCFCLK * 64)\n\t\t\t+ *StutterPeriod * TotalRowReadBandwidth / ReturnBW;\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: Part 1 = %f\\n\", __func__, PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer / AverageDCCCompressionRate / ReturnBW);\n\tdml_print(\"DML::%s: StutterPeriod * TotalDataReadBandwidth = %f\\n\", __func__, (*StutterPeriod * TotalDataReadBandwidth));\n\tdml_print(\"DML::%s: Part 2 = %f\\n\", __func__, (*StutterPeriod * TotalDataReadBandwidth - PartOfUncompressedPixelBurstThatFitsInROBAndCompressedBuffer) / (DCFCLK * 64));\n\tdml_print(\"DML::%s: Part 3 = %f\\n\", __func__, *StutterPeriod * TotalRowReadBandwidth / ReturnBW);\n\tdml_print(\"DML::%s: StutterBurstTime = %f\\n\", __func__, StutterBurstTime);\n#endif\n\tStutterBurstTime = dml_max(StutterBurstTime, LinesToFinishSwathTransferStutterCriticalPlane * BytePerPixelYCriticalPlane * SwathWidthYCriticalPlane / ReturnBW);\n\n\tdml_print(\n\t\t\t\"DML::%s: Time to finish residue swath=%f\\n\",\n\t\t\t__func__,\n\t\t\tLinesToFinishSwathTransferStutterCriticalPlane * BytePerPixelYCriticalPlane * SwathWidthYCriticalPlane / ReturnBW);\n\n\tTotalActiveWriteback = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (WritebackEnable[k]) {\n\t\t\tTotalActiveWriteback = TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (TotalActiveWriteback == 0) {\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: SRExitTime = %f\\n\", __func__, SRExitTime);\n\t\tdml_print(\"DML::%s: SRExitZ8Time = %f\\n\", __func__, SRExitZ8Time);\n\t\tdml_print(\"DML::%s: StutterBurstTime = %f (final)\\n\", __func__, StutterBurstTime);\n\t\tdml_print(\"DML::%s: StutterPeriod = %f\\n\", __func__, *StutterPeriod);\n#endif\n\t\t*StutterEfficiencyNotIncludingVBlank = dml_max(0., 1 - (SRExitTime + StutterBurstTime) / *StutterPeriod) * 100;\n\t\t*Z8StutterEfficiencyNotIncludingVBlank = dml_max(0., 1 - (SRExitZ8Time + StutterBurstTime) / *StutterPeriod) * 100;\n\t\t*NumberOfStutterBurstsPerFrame = (*StutterEfficiencyNotIncludingVBlank > 0 ? dml_ceil(VActiveTimeCriticalPlane / *StutterPeriod, 1) : 0);\n\t\t*Z8NumberOfStutterBurstsPerFrame = (*Z8StutterEfficiencyNotIncludingVBlank > 0 ? dml_ceil(VActiveTimeCriticalPlane / *StutterPeriod, 1) : 0);\n\t} else {\n\t\t*StutterEfficiencyNotIncludingVBlank = 0.;\n\t\t*Z8StutterEfficiencyNotIncludingVBlank = 0.;\n\t\t*NumberOfStutterBurstsPerFrame = 0;\n\t\t*Z8NumberOfStutterBurstsPerFrame = 0;\n\t}\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: VActiveTimeCriticalPlane = %f\\n\", __func__, VActiveTimeCriticalPlane);\n\tdml_print(\"DML::%s: StutterEfficiencyNotIncludingVBlank = %f\\n\", __func__, *StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: Z8StutterEfficiencyNotIncludingVBlank = %f\\n\", __func__, *Z8StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *NumberOfStutterBurstsPerFrame);\n\tdml_print(\"DML::%s: Z8NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *Z8NumberOfStutterBurstsPerFrame);\n#endif\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tTotalNumberOfActiveOTG = TotalNumberOfActiveOTG + 1;\n\t\t}\n\t}\n\n\tif (*StutterEfficiencyNotIncludingVBlank > 0) {\n\t\tLastStutterPeriod = VActiveTimeCriticalPlane - (*NumberOfStutterBurstsPerFrame - 1) * *StutterPeriod;\n\n\t\tif ((SynchronizedVBlank || TotalNumberOfActiveOTG == 1) && LastStutterPeriod + MinTTUVBlankCriticalPlane > StutterEnterPlusExitWatermark) {\n\t\t\t*StutterEfficiency = (1 - (*NumberOfStutterBurstsPerFrame * SRExitTime + StutterBurstTime * VActiveTimeCriticalPlane\n\t\t\t\t\t/ *StutterPeriod) / FrameTimeCriticalPlane) * 100;\n\t\t} else {\n\t\t\t*StutterEfficiency = *StutterEfficiencyNotIncludingVBlank;\n\t\t}\n\t} else {\n\t\t*StutterEfficiency = 0;\n\t}\n\n\tif (*Z8StutterEfficiencyNotIncludingVBlank > 0) {\n\t\tLastZ8StutterPeriod = VActiveTimeCriticalPlane - (*NumberOfStutterBurstsPerFrame - 1) * *StutterPeriod;\n\t\tif ((SynchronizedVBlank || TotalNumberOfActiveOTG == 1) && LastZ8StutterPeriod + MinTTUVBlankCriticalPlane > Z8StutterEnterPlusExitWatermark) {\n\t\t\t*Z8StutterEfficiency = (1 - (*NumberOfStutterBurstsPerFrame * SRExitZ8Time + StutterBurstTime * VActiveTimeCriticalPlane\n\t\t\t\t\t/ *StutterPeriod) / FrameTimeCriticalPlane) * 100;\n\t\t} else {\n\t\t\t*Z8StutterEfficiency = *Z8StutterEfficiencyNotIncludingVBlank;\n\t\t}\n\t} else {\n\t\t*Z8StutterEfficiency = 0.;\n\t}\n\n\tdml_print(\"DML::%s: LastZ8StutterPeriod = %f\\n\", __func__, LastZ8StutterPeriod);\n\tdml_print(\"DML::%s: Z8StutterEnterPlusExitWatermark = %f\\n\", __func__, Z8StutterEnterPlusExitWatermark);\n\tdml_print(\"DML::%s: StutterBurstTime = %f\\n\", __func__, StutterBurstTime);\n\tdml_print(\"DML::%s: StutterPeriod = %f\\n\", __func__, *StutterPeriod);\n\tdml_print(\"DML::%s: StutterEfficiency = %f\\n\", __func__, *StutterEfficiency);\n\tdml_print(\"DML::%s: Z8StutterEfficiency = %f\\n\", __func__, *Z8StutterEfficiency);\n\tdml_print(\"DML::%s: StutterEfficiencyNotIncludingVBlank = %f\\n\", __func__, *StutterEfficiencyNotIncludingVBlank);\n\tdml_print(\"DML::%s: Z8NumberOfStutterBurstsPerFrame = %d\\n\", __func__, *Z8NumberOfStutterBurstsPerFrame);\n}\n\nstatic void CalculateSwathAndDETConfiguration(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tbool DETSharedByAllDPP,\n\t\tunsigned int DETBufferSizeInKByteA[],\n\t\tdouble MaximumSwathWidthLuma[],\n\t\tdouble MaximumSwathWidthChroma[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum dm_swizzle_mode SurfaceTiling[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BlendingAndTiming[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tdouble BytePerPixDETY[],\n\t\tdouble BytePerPixDETC[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tint DPPPerPlane[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[],\n\t\tdouble SwathWidth[],\n\t\tdouble SwathWidthChroma[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tbool ViewportSizeSupportPerPlane[],\n\t\tbool *ViewportSizeSupport)\n{\n\tint MaximumSwathHeightY[DC__NUM_DPP__MAX];\n\tint MaximumSwathHeightC[DC__NUM_DPP__MAX];\n\tint MinimumSwathHeightY;\n\tint MinimumSwathHeightC;\n\tint RoundedUpMaxSwathSizeBytesY;\n\tint RoundedUpMaxSwathSizeBytesC;\n\tint RoundedUpMinSwathSizeBytesY;\n\tint RoundedUpMinSwathSizeBytesC;\n\tint RoundedUpSwathSizeBytesY;\n\tint RoundedUpSwathSizeBytesC;\n\tdouble SwathWidthSingleDPP[DC__NUM_DPP__MAX];\n\tdouble SwathWidthSingleDPPChroma[DC__NUM_DPP__MAX];\n\tint k;\n\n\tCalculateSwathWidth(\n\t\t\tForceSingleDPP,\n\t\t\tNumberOfActivePlanes,\n\t\t\tSourcePixelFormat,\n\t\t\tSourceScan,\n\t\t\tViewportWidth,\n\t\t\tViewportHeight,\n\t\t\tSurfaceWidthY,\n\t\t\tSurfaceWidthC,\n\t\t\tSurfaceHeightY,\n\t\t\tSurfaceHeightC,\n\t\t\tODMCombineEnabled,\n\t\t\tBytePerPixY,\n\t\t\tBytePerPixC,\n\t\t\tRead256BytesBlockHeightY,\n\t\t\tRead256BytesBlockHeightC,\n\t\t\tRead256BytesBlockWidthY,\n\t\t\tRead256BytesBlockWidthC,\n\t\t\tBlendingAndTiming,\n\t\t\tHActive,\n\t\t\tHRatio,\n\t\t\tDPPPerPlane,\n\t\t\tSwathWidthSingleDPP,\n\t\t\tSwathWidthSingleDPPChroma,\n\t\t\tSwathWidth,\n\t\t\tSwathWidthChroma,\n\t\t\tMaximumSwathHeightY,\n\t\t\tMaximumSwathHeightC,\n\t\t\tswath_width_luma_ub,\n\t\t\tswath_width_chroma_ub);\n\n\t*ViewportSizeSupport = true;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tunsigned int DETBufferSizeInKByte = DETBufferSizeInKByteA[k];\n\n\t\tif (DETSharedByAllDPP && DPPPerPlane[k])\n\t\t\tDETBufferSizeInKByte /= DPPPerPlane[k];\n\t\tif ((SourcePixelFormat[k] == dm_444_64 || SourcePixelFormat[k] == dm_444_32 || SourcePixelFormat[k] == dm_444_16 || SourcePixelFormat[k] == dm_mono_16\n\t\t\t\t|| SourcePixelFormat[k] == dm_mono_8 || SourcePixelFormat[k] == dm_rgbe)) {\n\t\t\tif (SurfaceTiling[k] == dm_sw_linear\n\t\t\t\t\t|| (SourcePixelFormat[k] == dm_444_64\n\t\t\t\t\t\t\t&& (SurfaceTiling[k] == dm_sw_64kb_s || SurfaceTiling[k] == dm_sw_64kb_s_t || SurfaceTiling[k] == dm_sw_64kb_s_x)\n\t\t\t\t\t\t\t&& SourceScan[k] != dm_vert)) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_444_8 && SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t}\n\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t} else {\n\t\t\tif (SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_rgbe_alpha && SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t} else if (SourcePixelFormat[k] == dm_420_8 && SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t}\n\t\t}\n\n\t\tRoundedUpMaxSwathSizeBytesY = swath_width_luma_ub[k] * BytePerPixDETY[k] * MaximumSwathHeightY[k];\n\t\tRoundedUpMinSwathSizeBytesY = swath_width_luma_ub[k] * BytePerPixDETY[k] * MinimumSwathHeightY;\n\t\tif (SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesY = dml_ceil((double) RoundedUpMaxSwathSizeBytesY, 256);\n\t\t\tRoundedUpMinSwathSizeBytesY = dml_ceil((double) RoundedUpMinSwathSizeBytesY, 256);\n\t\t}\n\t\tRoundedUpMaxSwathSizeBytesC = swath_width_chroma_ub[k] * BytePerPixDETC[k] * MaximumSwathHeightC[k];\n\t\tRoundedUpMinSwathSizeBytesC = swath_width_chroma_ub[k] * BytePerPixDETC[k] * MinimumSwathHeightC;\n\t\tif (SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesC = dml_ceil(RoundedUpMaxSwathSizeBytesC, 256);\n\t\t\tRoundedUpMinSwathSizeBytesC = dml_ceil(RoundedUpMinSwathSizeBytesC, 256);\n\t\t}\n\n\t\tif (RoundedUpMaxSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC <= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC;\n\t\t} else if (RoundedUpMaxSwathSizeBytesY >= 1.5 * RoundedUpMaxSwathSizeBytesC\n\t\t\t\t&& RoundedUpMinSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC <= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MinimumSwathHeightY;\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMinSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC;\n\t\t} else if (RoundedUpMaxSwathSizeBytesY < 1.5 * RoundedUpMaxSwathSizeBytesC\n\t\t\t\t&& RoundedUpMaxSwathSizeBytesY + RoundedUpMinSwathSizeBytesC <= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MinimumSwathHeightC;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMinSwathSizeBytesC;\n\t\t} else {\n\t\t\tSwathHeightY[k] = MinimumSwathHeightY;\n\t\t\tSwathHeightC[k] = MinimumSwathHeightC;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMinSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMinSwathSizeBytesC;\n\t\t}\n\t\t{\n\t\tdouble actDETBufferSizeInKByte = dml_ceil(DETBufferSizeInKByte, 64);\n\t\tif (SwathHeightC[k] == 0) {\n\t\t\tDETBufferSizeY[k] = actDETBufferSizeInKByte * 1024;\n\t\t\tDETBufferSizeC[k] = 0;\n\t\t} else if (RoundedUpSwathSizeBytesY <= 1.5 * RoundedUpSwathSizeBytesC) {\n\t\t\tDETBufferSizeY[k] = actDETBufferSizeInKByte * 1024 / 2;\n\t\t\tDETBufferSizeC[k] = actDETBufferSizeInKByte * 1024 / 2;\n\t\t} else {\n\t\t\tDETBufferSizeY[k] = dml_floor(actDETBufferSizeInKByte * 1024 * 2 / 3, 1024);\n\t\t\tDETBufferSizeC[k] = actDETBufferSizeInKByte * 1024 / 3;\n\t\t}\n\n\t\tif (RoundedUpMinSwathSizeBytesY + RoundedUpMinSwathSizeBytesC > actDETBufferSizeInKByte * 1024 / 2 || SwathWidth[k] > MaximumSwathWidthLuma[k]\n\t\t\t\t|| (SwathHeightC[k] > 0 && SwathWidthChroma[k] > MaximumSwathWidthChroma[k])) {\n\t\t\t*ViewportSizeSupport = false;\n\t\t\tViewportSizeSupportPerPlane[k] = false;\n\t\t} else {\n\t\t\tViewportSizeSupportPerPlane[k] = true;\n\t\t}\n\t\t}\n\t}\n}\n\nstatic void CalculateSwathWidth(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tint BlendingAndTiming[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tint DPPPerPlane[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tdouble SwathWidthSingleDPPC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tint MaximumSwathHeightY[],\n\t\tint MaximumSwathHeightC[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[])\n{\n\tenum odm_combine_mode MainPlaneODMCombine;\n\tint j, k;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: NumberOfActivePlanes = %d\\n\", __func__, NumberOfActivePlanes);\n#endif\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\tSwathWidthSingleDPPY[k] = ViewportWidth[k];\n\t\t} else {\n\t\t\tSwathWidthSingleDPPY[k] = ViewportHeight[k];\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d ViewportWidth=%d\\n\", __func__, k, ViewportWidth[k]);\n\t\tdml_print(\"DML::%s: k=%d ViewportHeight=%d\\n\", __func__, k, ViewportHeight[k]);\n#endif\n\n\t\tMainPlaneODMCombine = ODMCombineEnabled[k];\n\t\tfor (j = 0; j < NumberOfActivePlanes; ++j) {\n\t\t\tif (BlendingAndTiming[k] == j) {\n\t\t\t\tMainPlaneODMCombine = ODMCombineEnabled[j];\n\t\t\t}\n\t\t}\n\n\t\tif (MainPlaneODMCombine == dm_odm_combine_mode_4to1) {\n\t\t\tSwathWidthY[k] = dml_min(SwathWidthSingleDPPY[k], dml_round(HActive[k] / 4.0 * HRatio[k]));\n\t\t} else if (MainPlaneODMCombine == dm_odm_combine_mode_2to1) {\n\t\t\tSwathWidthY[k] = dml_min(SwathWidthSingleDPPY[k], dml_round(HActive[k] / 2.0 * HRatio[k]));\n\t\t} else if (DPPPerPlane[k] == 2) {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k] / 2;\n\t\t} else {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k];\n\t\t}\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d SwathWidthSingleDPPY=%f\\n\", __func__, k, SwathWidthSingleDPPY[k]);\n\t\tdml_print(\"DML::%s: k=%d SwathWidthY=%f\\n\", __func__, k, SwathWidthY[k]);\n#endif\n\n\t\tif (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 || SourcePixelFormat[k] == dm_420_12) {\n\t\t\tSwathWidthC[k] = SwathWidthY[k] / 2;\n\t\t\tSwathWidthSingleDPPC[k] = SwathWidthSingleDPPY[k] / 2;\n\t\t} else {\n\t\t\tSwathWidthC[k] = SwathWidthY[k];\n\t\t\tSwathWidthSingleDPPC[k] = SwathWidthSingleDPPY[k];\n\t\t}\n\n\t\tif (ForceSingleDPP == true) {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k];\n\t\t\tSwathWidthC[k] = SwathWidthSingleDPPC[k];\n\t\t}\n\t\t{\n\t\tint surface_width_ub_l = dml_ceil(SurfaceWidthY[k], Read256BytesBlockWidthY[k]);\n\t\tint surface_height_ub_l = dml_ceil(SurfaceHeightY[k], Read256BytesBlockHeightY[k]);\n\n#ifdef __DML_VBA_DEBUG__\n\t\tdml_print(\"DML::%s: k=%d surface_width_ub_l=%0d\\n\", __func__, k, surface_width_ub_l);\n#endif\n\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockHeightY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockHeightC[k];\n\t\t\tswath_width_luma_ub[k] = dml_min(surface_width_ub_l, (int) dml_ceil(SwathWidthY[k] - 1, Read256BytesBlockWidthY[k]) + Read256BytesBlockWidthY[k]);\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tint surface_width_ub_c = dml_ceil(SurfaceWidthC[k], Read256BytesBlockWidthC[k]);\n\n\t\t\t\tswath_width_chroma_ub[k] = dml_min(\n\t\t\t\t\t\tsurface_width_ub_c,\n\t\t\t\t\t\t(int) dml_ceil(SwathWidthC[k] - 1, Read256BytesBlockWidthC[k]) + Read256BytesBlockWidthC[k]);\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockWidthY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockWidthC[k];\n\t\t\tswath_width_luma_ub[k] = dml_min(surface_height_ub_l, (int) dml_ceil(SwathWidthY[k] - 1, Read256BytesBlockHeightY[k]) + Read256BytesBlockHeightY[k]);\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tint surface_height_ub_c = dml_ceil(SurfaceHeightC[k], Read256BytesBlockHeightC[k]);\n\n\t\t\t\tswath_width_chroma_ub[k] = dml_min(\n\t\t\t\t\t\tsurface_height_ub_c,\n\t\t\t\t\t\t(int) dml_ceil(SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) + Read256BytesBlockHeightC[k]);\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n}\n\nstatic double CalculateExtraLatency(\n\t\tint RoundTripPingLatencyCycles,\n\t\tint ReorderingBytes,\n\t\tdouble DCFCLK,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels)\n{\n\tdouble ExtraLatencyBytes;\n\tdouble ExtraLatency;\n\n\tExtraLatencyBytes = CalculateExtraLatencyBytes(\n\t\t\tReorderingBytes,\n\t\t\tTotalNumberOfActiveDPP,\n\t\t\tPixelChunkSizeInKByte,\n\t\t\tTotalNumberOfDCCActiveDPP,\n\t\t\tMetaChunkSize,\n\t\t\tGPUVMEnable,\n\t\t\tHostVMEnable,\n\t\t\tNumberOfActivePlanes,\n\t\t\tNumberOfDPP,\n\t\t\tdpte_group_bytes,\n\t\t\tHostVMInefficiencyFactor,\n\t\t\tHostVMMinPageSize,\n\t\t\tHostVMMaxNonCachedPageTableLevels);\n\n\tExtraLatency = (RoundTripPingLatencyCycles + __DML_ARB_TO_RET_DELAY__) / DCFCLK + ExtraLatencyBytes / ReturnBW;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: RoundTripPingLatencyCycles=%d\\n\", __func__, RoundTripPingLatencyCycles);\n\tdml_print(\"DML::%s: DCFCLK=%f\\n\", __func__, DCFCLK);\n\tdml_print(\"DML::%s: ExtraLatencyBytes=%f\\n\", __func__, ExtraLatencyBytes);\n\tdml_print(\"DML::%s: ReturnBW=%f\\n\", __func__, ReturnBW);\n\tdml_print(\"DML::%s: ExtraLatency=%f\\n\", __func__, ExtraLatency);\n#endif\n\n\treturn ExtraLatency;\n}\n\nstatic double CalculateExtraLatencyBytes(\n\t\tint ReorderingBytes,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble HostVMInefficiencyFactor,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels)\n{\n\tdouble ret;\n\tint HostVMDynamicLevels = 0, k;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tif (HostVMMinPageSize < 2048) {\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\t} else if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576) {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\t} else {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t\t}\n\t} else {\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tret = ReorderingBytes + (TotalNumberOfActiveDPP * PixelChunkSizeInKByte + TotalNumberOfDCCActiveDPP * MetaChunkSize) * 1024.0;\n\n\tif (GPUVMEnable == true) {\n\t\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\t\tret = ret + NumberOfDPP[k] * dpte_group_bytes[k] * (1 + 8 * HostVMDynamicLevels) * HostVMInefficiencyFactor;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic double CalculateUrgentLatency(\n\t\tdouble UrgentLatencyPixelDataOnly,\n\t\tdouble UrgentLatencyPixelMixedWithVMData,\n\t\tdouble UrgentLatencyVMDataOnly,\n\t\tbool DoUrgentLatencyAdjustment,\n\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,\n\t\tdouble UrgentLatencyAdjustmentFabricClockReference,\n\t\tdouble FabricClock)\n{\n\tdouble ret;\n\n\tret = dml_max3(UrgentLatencyPixelDataOnly, UrgentLatencyPixelMixedWithVMData, UrgentLatencyVMDataOnly);\n\tif (DoUrgentLatencyAdjustment == true) {\n\t\tret = ret + UrgentLatencyAdjustmentFabricClockComponent * (UrgentLatencyAdjustmentFabricClockReference / FabricClock - 1);\n\t}\n\treturn ret;\n}\n\nstatic noinline_for_stack void UseMinimumDCFCLK(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tint MaxPrefetchMode,\n\t\tint ReorderingBytes)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tint dummy1, i, j, k;\n\tdouble NormalEfficiency,  dummy2, dummy3;\n\tdouble TotalMaxPrefetchFlipDPTERowBandwidth[DC__VOLTAGE_STATES][2];\n\n\tNormalEfficiency = v->PercentOfIdealFabricAndSDPPortBWReceivedAfterUrgLatency / 100.0;\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tdouble PixelDCFCLKCyclesRequiredInPrefetch[DC__NUM_DPP__MAX];\n\t\t\tdouble PrefetchPixelLinesTime[DC__NUM_DPP__MAX];\n\t\t\tdouble DCFCLKRequiredForPeakBandwidthPerPlane[DC__NUM_DPP__MAX];\n\t\t\tdouble DynamicMetadataVMExtraLatency[DC__NUM_DPP__MAX];\n\t\t\tdouble MinimumTWait;\n\t\t\tdouble NonDPTEBandwidth;\n\t\t\tdouble DPTEBandwidth;\n\t\t\tdouble DCFCLKRequiredForAverageBandwidth;\n\t\t\tdouble ExtraLatencyBytes;\n\t\t\tdouble ExtraLatencyCycles;\n\t\t\tdouble DCFCLKRequiredForPeakBandwidth;\n\t\t\tint NoOfDPPState[DC__NUM_DPP__MAX];\n\t\t\tdouble MinimumTvmPlus2Tr0;\n\n\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = TotalMaxPrefetchFlipDPTERowBandwidth[i][j]\n\t\t\t\t\t\t+ v->NoOfDPP[i][j][k] * v->DPTEBytesPerRow[i][j][k] / (15.75 * v->HTotal[k] / v->PixelClock[k]);\n\t\t\t}\n\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; ++k) {\n\t\t\t\tNoOfDPPState[k] = v->NoOfDPP[i][j][k];\n\t\t\t}\n\n\t\t\tMinimumTWait = CalculateTWait(MaxPrefetchMode, v->FinalDRAMClockChangeLatency, v->UrgLatency[i], v->SREnterPlusExitTime);\n\t\t\tNonDPTEBandwidth = v->TotalVActivePixelBandwidth[i][j] + v->TotalVActiveCursorBandwidth[i][j] + v->TotalMetaRowBandwidth[i][j];\n\t\t\tDPTEBandwidth = (v->HostVMEnable == true || v->ImmediateFlipRequirement[0] == dm_immediate_flip_required) ?\n\t\t\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] : v->TotalDPTERowBandwidth[i][j];\n\t\t\tDCFCLKRequiredForAverageBandwidth = dml_max3(\n\t\t\t\t\tv->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\t(NonDPTEBandwidth + v->TotalDPTERowBandwidth[i][j]) / v->ReturnBusWidth\n\t\t\t\t\t\t\t/ (v->MaxAveragePercentOfIdealFabricAndSDPPortBWDisplayCanUseInNormalSystemOperation / 100),\n\t\t\t\t\t(NonDPTEBandwidth + DPTEBandwidth / NormalEfficiency) / NormalEfficiency / v->ReturnBusWidth);\n\n\t\t\tExtraLatencyBytes = CalculateExtraLatencyBytes(\n\t\t\t\t\tReorderingBytes,\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j],\n\t\t\t\t\tv->PixelChunkSizeInKByte,\n\t\t\t\t\tv->TotalNumberOfDCCActiveDPP[i][j],\n\t\t\t\t\tv->MetaChunkSize,\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tNoOfDPPState,\n\t\t\t\t\tv->dpte_group_bytes,\n\t\t\t\t\t1,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels);\n\t\t\tExtraLatencyCycles = v->RoundTripPingLatencyCycles + __DML_ARB_TO_RET_DELAY__ + ExtraLatencyBytes / NormalEfficiency / v->ReturnBusWidth;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tdouble DCFCLKCyclesRequiredInPrefetch;\n\t\t\t\tdouble ExpectedPrefetchBWAcceleration;\n\t\t\t\tdouble PrefetchTime;\n\n\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k] = (v->PrefetchLinesY[i][j][k] * v->swath_width_luma_ub_all_states[i][j][k] * v->BytePerPixelY[k]\n\t\t\t\t\t\t+ v->PrefetchLinesC[i][j][k] * v->swath_width_chroma_ub_all_states[i][j][k] * v->BytePerPixelC[k]) / NormalEfficiency / v->ReturnBusWidth;\n\t\t\t\tDCFCLKCyclesRequiredInPrefetch = 2 * ExtraLatencyCycles / NoOfDPPState[k]\n\t\t\t\t\t\t+ v->PDEAndMetaPTEBytesPerFrame[i][j][k] / NormalEfficiency / NormalEfficiency / v->ReturnBusWidth * (v->GPUVMMaxPageTableLevels > 2 ? 1 : 0)\n\t\t\t\t\t\t+ 2 * v->DPTEBytesPerRow[i][j][k] / NormalEfficiency / NormalEfficiency / v->ReturnBusWidth\n\t\t\t\t\t\t+ 2 * v->MetaRowBytes[i][j][k] / NormalEfficiency / v->ReturnBusWidth + PixelDCFCLKCyclesRequiredInPrefetch[k];\n\t\t\t\tPrefetchPixelLinesTime[k] = dml_max(v->PrefetchLinesY[i][j][k], v->PrefetchLinesC[i][j][k]) * v->HTotal[k] / v->PixelClock[k];\n\t\t\t\tExpectedPrefetchBWAcceleration = (v->VActivePixelBandwidth[i][j][k] + v->VActiveCursorBandwidth[i][j][k])\n\t\t\t\t\t\t/ (v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k]);\n\t\t\t\tDynamicMetadataVMExtraLatency[k] =\n\t\t\t\t\t\t(v->GPUVMEnable == true && v->DynamicMetadataEnable[k] == true && v->DynamicMetadataVMEnabled == true) ?\n\t\t\t\t\t\t\t\tv->UrgLatency[i] * v->GPUVMMaxPageTableLevels * (v->HostVMEnable == true ? v->HostVMMaxNonCachedPageTableLevels + 1 : 1) : 0;\n\t\t\t\tPrefetchTime = (v->MaximumVStartup[i][j][k] - 1) * v->HTotal[k] / v->PixelClock[k] - MinimumTWait\n\t\t\t\t\t\t- v->UrgLatency[i]\n\t\t\t\t\t\t\t\t* ((v->GPUVMMaxPageTableLevels <= 2 ? v->GPUVMMaxPageTableLevels : v->GPUVMMaxPageTableLevels - 2)\n\t\t\t\t\t\t\t\t\t\t* (v->HostVMEnable == true ? v->HostVMMaxNonCachedPageTableLevels + 1 : 1) - 1)\n\t\t\t\t\t\t- DynamicMetadataVMExtraLatency[k];\n\n\t\t\t\tif (PrefetchTime > 0) {\n\t\t\t\t\tdouble ExpectedVRatioPrefetch;\n\t\t\t\t\tExpectedVRatioPrefetch = PrefetchPixelLinesTime[k]\n\t\t\t\t\t\t\t/ (PrefetchTime * PixelDCFCLKCyclesRequiredInPrefetch[k] / DCFCLKCyclesRequiredInPrefetch);\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = NoOfDPPState[k] * PixelDCFCLKCyclesRequiredInPrefetch[k] / PrefetchPixelLinesTime[k]\n\t\t\t\t\t\t\t* dml_max(1.0, ExpectedVRatioPrefetch) * dml_max(1.0, ExpectedVRatioPrefetch / 4) * ExpectedPrefetchBWAcceleration;\n\t\t\t\t\tif (v->HostVMEnable == true || v->ImmediateFlipRequirement[0] == dm_immediate_flip_required) {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = DCFCLKRequiredForPeakBandwidthPerPlane[k]\n\t\t\t\t\t\t\t\t+ NoOfDPPState[k] * DPTEBandwidth / NormalEfficiency / NormalEfficiency / v->ReturnBusWidth;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = v->DCFCLKPerState[i];\n\t\t\t\t}\n\t\t\t\tif (v->DynamicMetadataEnable[k] == true) {\n\t\t\t\t\tdouble TSetupPipe;\n\t\t\t\t\tdouble TdmbfPipe;\n\t\t\t\t\tdouble TdmsksPipe;\n\t\t\t\t\tdouble TdmecPipe;\n\t\t\t\t\tdouble AllowedTimeForUrgentExtraLatency;\n\n\t\t\t\t\tCalculateVupdateAndDynamicMetadataParameters(\n\t\t\t\t\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k],\n\t\t\t\t\t\t\tv->RequiredDISPCLK[i][j],\n\t\t\t\t\t\t\tv->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->VTotal[k] - v->VActive[k],\n\t\t\t\t\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\t&TSetupPipe,\n\t\t\t\t\t\t\t&TdmbfPipe,\n\t\t\t\t\t\t\t&TdmecPipe,\n\t\t\t\t\t\t\t&TdmsksPipe,\n\t\t\t\t\t\t\t&dummy1,\n\t\t\t\t\t\t\t&dummy2,\n\t\t\t\t\t\t\t&dummy3);\n\t\t\t\t\tAllowedTimeForUrgentExtraLatency = v->MaximumVStartup[i][j][k] * v->HTotal[k] / v->PixelClock[k] - MinimumTWait - TSetupPipe - TdmbfPipe - TdmecPipe\n\t\t\t\t\t\t\t- TdmsksPipe - DynamicMetadataVMExtraLatency[k];\n\t\t\t\t\tif (AllowedTimeForUrgentExtraLatency > 0) {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = dml_max(\n\t\t\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k],\n\t\t\t\t\t\t\t\tExtraLatencyCycles / AllowedTimeForUrgentExtraLatency);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = v->DCFCLKPerState[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDCFCLKRequiredForPeakBandwidth = 0;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; ++k) {\n\t\t\t\tDCFCLKRequiredForPeakBandwidth = DCFCLKRequiredForPeakBandwidth + DCFCLKRequiredForPeakBandwidthPerPlane[k];\n\t\t\t}\n\t\t\tMinimumTvmPlus2Tr0 = v->UrgLatency[i]\n\t\t\t\t\t* (v->GPUVMEnable == true ?\n\t\t\t\t\t\t\t(v->HostVMEnable == true ?\n\t\t\t\t\t\t\t\t\t(v->GPUVMMaxPageTableLevels + 2) * (v->HostVMMaxNonCachedPageTableLevels + 1) - 1 : v->GPUVMMaxPageTableLevels + 1) :\n\t\t\t\t\t\t\t0);\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tdouble MaximumTvmPlus2Tr0PlusTsw;\n\t\t\t\tMaximumTvmPlus2Tr0PlusTsw = (v->MaximumVStartup[i][j][k] - 2) * v->HTotal[k] / v->PixelClock[k] - MinimumTWait - DynamicMetadataVMExtraLatency[k];\n\t\t\t\tif (MaximumTvmPlus2Tr0PlusTsw <= MinimumTvmPlus2Tr0 + PrefetchPixelLinesTime[k] / 4) {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = v->DCFCLKPerState[i];\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = dml_max3(\n\t\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidth,\n\t\t\t\t\t\t\t2 * ExtraLatencyCycles / (MaximumTvmPlus2Tr0PlusTsw - MinimumTvmPlus2Tr0 - PrefetchPixelLinesTime[k] / 4),\n\t\t\t\t\t\t\t(2 * ExtraLatencyCycles + PixelDCFCLKCyclesRequiredInPrefetch[k]) / (MaximumTvmPlus2Tr0PlusTsw - MinimumTvmPlus2Tr0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->DCFCLKState[i][j] = dml_min(v->DCFCLKPerState[i], 1.05 * dml_max(DCFCLKRequiredForAverageBandwidth, DCFCLKRequiredForPeakBandwidth));\n\t\t}\n\t}\n}\n\nstatic void CalculateUnboundedRequestAndCompressedBufferSize(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tint ConfigReturnBufferSizeInKByte,\n\t\tenum unbounded_requesting_policy UseUnboundedRequestingFinal,\n\t\tint TotalActiveDPP,\n\t\tbool NoChromaPlanes,\n\t\tint MaxNumDPP,\n\t\tint CompressedBufferSegmentSizeInkByteFinal,\n\t\tenum output_encoder_class *Output,\n\t\tbool *UnboundedRequestEnabled,\n\t\tint *CompressedBufferSizeInkByte)\n{\n\tdouble actDETBufferSizeInKByte = dml_ceil(DETBufferSizeInKByte, 64);\n\n\t*UnboundedRequestEnabled = UnboundedRequest(UseUnboundedRequestingFinal, TotalActiveDPP, NoChromaPlanes, Output[0]);\n\t*CompressedBufferSizeInkByte = (\n\t\t\t*UnboundedRequestEnabled == true ?\n\t\t\t\t\tConfigReturnBufferSizeInKByte - TotalActiveDPP * actDETBufferSizeInKByte :\n\t\t\t\t\tConfigReturnBufferSizeInKByte - MaxNumDPP * actDETBufferSizeInKByte);\n\t*CompressedBufferSizeInkByte = *CompressedBufferSizeInkByte * CompressedBufferSegmentSizeInkByteFinal / 64;\n\n#ifdef __DML_VBA_DEBUG__\n\tdml_print(\"DML::%s: TotalActiveDPP = %d\\n\", __func__, TotalActiveDPP);\n\tdml_print(\"DML::%s: DETBufferSizeInKByte = %d\\n\", __func__, DETBufferSizeInKByte);\n\tdml_print(\"DML::%s: ConfigReturnBufferSizeInKByte = %d\\n\", __func__, ConfigReturnBufferSizeInKByte);\n\tdml_print(\"DML::%s: UseUnboundedRequestingFinal = %d\\n\", __func__, UseUnboundedRequestingFinal);\n\tdml_print(\"DML::%s: actDETBufferSizeInKByte = %f\\n\", __func__, actDETBufferSizeInKByte);\n\tdml_print(\"DML::%s: UnboundedRequestEnabled = %d\\n\", __func__, *UnboundedRequestEnabled);\n\tdml_print(\"DML::%s: CompressedBufferSizeInkByte = %d\\n\", __func__, *CompressedBufferSizeInkByte);\n#endif\n}\n\nstatic bool UnboundedRequest(enum unbounded_requesting_policy UseUnboundedRequestingFinal, int TotalNumberOfActiveDPP, bool NoChroma, enum output_encoder_class Output)\n{\n\tbool ret_val = false;\n\n\tret_val = (UseUnboundedRequestingFinal != dm_unbounded_requesting_disable && TotalNumberOfActiveDPP == 1 && NoChroma);\n\tif (UseUnboundedRequestingFinal == dm_unbounded_requesting_edp_only && Output != dm_edp) {\n\t\tret_val = false;\n\t}\n\treturn (ret_val);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}