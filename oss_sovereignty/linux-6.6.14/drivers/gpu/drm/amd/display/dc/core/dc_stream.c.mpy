{
  "module_name": "dc_stream.c",
  "hash_id": "b17fdae7d8a60c22a8fae360e3bd221d5916a1abd3a3842ef8608b30146a1b6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_stream.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"basics/dc_common.h\"\n#include \"dc.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"ipp.h\"\n#include \"timing_generator.h\"\n#include \"dc_dmub_srv.h\"\n\n#define DC_LOGGER dc->ctx->logger\n\n \nvoid update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)\n{\n\tif (sink->sink_signal == SIGNAL_TYPE_NONE)\n\t\tstream->signal = stream->link->connector_signal;\n\telse\n\t\tstream->signal = sink->sink_signal;\n\n\tif (dc_is_dvi_signal(stream->signal)) {\n\t\tif (stream->ctx->dc->caps.dual_link_dvi &&\n\t\t\t(stream->timing.pix_clk_100hz / 10) > TMDS_MAX_PIXEL_CLOCK &&\n\t\t\tsink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)\n\t\t\tstream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\telse\n\t\t\tstream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t}\n}\n\nstatic bool dc_stream_construct(struct dc_stream_state *stream,\n\tstruct dc_sink *dc_sink_data)\n{\n\tuint32_t i = 0;\n\n\tstream->sink = dc_sink_data;\n\tdc_sink_retain(dc_sink_data);\n\n\tstream->ctx = dc_sink_data->ctx;\n\tstream->link = dc_sink_data->link;\n\tstream->sink_patches = dc_sink_data->edid_caps.panel_patch;\n\tstream->converter_disable_audio = dc_sink_data->converter_disable_audio;\n\tstream->qs_bit = dc_sink_data->edid_caps.qs_bit;\n\tstream->qy_bit = dc_sink_data->edid_caps.qy_bit;\n\n\t \n\t \n\tfor (i = 0; i < (dc_sink_data->edid_caps.audio_mode_count); i++) {\n\t\tstream->audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;\n\t\tstream->audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;\n\t\tstream->audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;\n\t\tstream->audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;\n\t}\n\tstream->audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;\n\tstream->audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;\n\tstream->audio_info.video_latency = dc_sink_data->edid_caps.video_latency;\n\tmemmove(\n\t\tstream->audio_info.display_name,\n\t\tdc_sink_data->edid_caps.display_name,\n\t\tAUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);\n\tstream->audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;\n\tstream->audio_info.product_id = dc_sink_data->edid_caps.product_id;\n\tstream->audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;\n\n\tif (dc_sink_data->dc_container_id != NULL) {\n\t\tstruct dc_container_id *dc_container_id = dc_sink_data->dc_container_id;\n\n\t\tstream->audio_info.port_id[0] = dc_container_id->portId[0];\n\t\tstream->audio_info.port_id[1] = dc_container_id->portId[1];\n\t} else {\n\t\t \n\t\tstream->audio_info.port_id[0] = 0x5558859e;\n\t\tstream->audio_info.port_id[1] = 0xd989449;\n\t}\n\n\t \n\tstream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;\n\n\tmemset(&stream->timing.dsc_cfg, 0, sizeof(stream->timing.dsc_cfg));\n\tstream->timing.dsc_cfg.num_slices_h = 0;\n\tstream->timing.dsc_cfg.num_slices_v = 0;\n\tstream->timing.dsc_cfg.bits_per_pixel = 128;\n\tstream->timing.dsc_cfg.block_pred_enable = 1;\n\tstream->timing.dsc_cfg.linebuf_depth = 9;\n\tstream->timing.dsc_cfg.version_minor = 2;\n\tstream->timing.dsc_cfg.ycbcr422_simple = 0;\n\n\tupdate_stream_signal(stream, dc_sink_data);\n\n\tstream->out_transfer_func = dc_create_transfer_func();\n\tif (stream->out_transfer_func == NULL) {\n\t\tdc_sink_release(dc_sink_data);\n\t\treturn false;\n\t}\n\tstream->out_transfer_func->type = TF_TYPE_BYPASS;\n\n\tstream->stream_id = stream->ctx->dc_stream_id_count;\n\tstream->ctx->dc_stream_id_count++;\n\n\treturn true;\n}\n\nstatic void dc_stream_destruct(struct dc_stream_state *stream)\n{\n\tdc_sink_release(stream->sink);\n\tif (stream->out_transfer_func != NULL) {\n\t\tdc_transfer_func_release(stream->out_transfer_func);\n\t\tstream->out_transfer_func = NULL;\n\t}\n}\n\nvoid dc_stream_retain(struct dc_stream_state *stream)\n{\n\tkref_get(&stream->refcount);\n}\n\nstatic void dc_stream_free(struct kref *kref)\n{\n\tstruct dc_stream_state *stream = container_of(kref, struct dc_stream_state, refcount);\n\n\tdc_stream_destruct(stream);\n\tkfree(stream);\n}\n\nvoid dc_stream_release(struct dc_stream_state *stream)\n{\n\tif (stream != NULL) {\n\t\tkref_put(&stream->refcount, dc_stream_free);\n\t}\n}\n\nstruct dc_stream_state *dc_create_stream_for_sink(\n\t\tstruct dc_sink *sink)\n{\n\tstruct dc_stream_state *stream;\n\n\tif (sink == NULL)\n\t\treturn NULL;\n\n\tstream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);\n\tif (stream == NULL)\n\t\tgoto alloc_fail;\n\n\tif (dc_stream_construct(stream, sink) == false)\n\t\tgoto construct_fail;\n\n\tkref_init(&stream->refcount);\n\n\treturn stream;\n\nconstruct_fail:\n\tkfree(stream);\n\nalloc_fail:\n\treturn NULL;\n}\n\nstruct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)\n{\n\tstruct dc_stream_state *new_stream;\n\n\tnew_stream = kmemdup(stream, sizeof(struct dc_stream_state), GFP_KERNEL);\n\tif (!new_stream)\n\t\treturn NULL;\n\n\tif (new_stream->sink)\n\t\tdc_sink_retain(new_stream->sink);\n\n\tif (new_stream->out_transfer_func)\n\t\tdc_transfer_func_retain(new_stream->out_transfer_func);\n\n\tnew_stream->stream_id = new_stream->ctx->dc_stream_id_count;\n\tnew_stream->ctx->dc_stream_id_count++;\n\n\t \n\tif (new_stream->ctx->dc->res_pool->funcs->link_encs_assign)\n\t\tnew_stream->link_enc = NULL;\n\n\tkref_init(&new_stream->refcount);\n\n\treturn new_stream;\n}\n\n \nstruct dc_stream_status *dc_stream_get_status_from_state(\n\tstruct dc_state *state,\n\tstruct dc_stream_state *stream)\n{\n\tuint8_t i;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < state->stream_count; i++) {\n\t\tif (stream == state->streams[i])\n\t\t\treturn &state->stream_status[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstruct dc_stream_status *dc_stream_get_status(\n\tstruct dc_stream_state *stream)\n{\n\tstruct dc *dc = stream->ctx->dc;\n\treturn dc_stream_get_status_from_state(dc->current_state, stream);\n}\n\nstatic void program_cursor_attributes(\n\tstruct dc *dc,\n\tstruct dc_stream_state *stream,\n\tconst struct dc_cursor_attributes *attributes)\n{\n\tint i;\n\tstruct resource_context *res_ctx;\n\tstruct pipe_ctx *pipe_to_program = NULL;\n\n\tif (!stream)\n\t\treturn;\n\n\tres_ctx = &dc->current_state->res_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != stream)\n\t\t\tcontinue;\n\n\t\tif (!pipe_to_program) {\n\t\t\tpipe_to_program = pipe_ctx;\n\t\t\tdc->hwss.cursor_lock(dc, pipe_to_program, true);\n\t\t\tif (pipe_to_program->next_odm_pipe)\n\t\t\t\tdc->hwss.cursor_lock(dc, pipe_to_program->next_odm_pipe, true);\n\t\t}\n\n\t\tdc->hwss.set_cursor_attribute(pipe_ctx);\n\t\tif (dc->ctx->dmub_srv)\n\t\t\tdc_send_update_cursor_info_to_dmu(pipe_ctx, i);\n\t\tif (dc->hwss.set_cursor_sdr_white_level)\n\t\t\tdc->hwss.set_cursor_sdr_white_level(pipe_ctx);\n\t}\n\n\tif (pipe_to_program) {\n\t\tdc->hwss.cursor_lock(dc, pipe_to_program, false);\n\t\tif (pipe_to_program->next_odm_pipe)\n\t\t\tdc->hwss.cursor_lock(dc, pipe_to_program->next_odm_pipe, false);\n\t}\n}\n\n#ifndef TRIM_FSFT\n \nbool dc_optimize_timing_for_fsft(\n\tstruct dc_stream_state *pStream,\n\tunsigned int max_input_rate_in_khz)\n{\n\tstruct dc  *dc;\n\n\tdc = pStream->ctx->dc;\n\n\treturn (dc->hwss.optimize_timing_for_fsft &&\n\t\tdc->hwss.optimize_timing_for_fsft(dc, &pStream->timing, max_input_rate_in_khz));\n}\n#endif\n\nstatic bool is_subvp_high_refresh_candidate(struct dc_stream_state *stream)\n{\n\tuint32_t refresh_rate;\n\tstruct dc *dc = stream->ctx->dc;\n\n\trefresh_rate = (stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\tstream->timing.v_total * stream->timing.h_total - (uint64_t)1);\n\trefresh_rate = div_u64(refresh_rate, stream->timing.v_total);\n\trefresh_rate = div_u64(refresh_rate, stream->timing.h_total);\n\n\t \n\tif ((refresh_rate >= 120 && refresh_rate <= 175 &&\n\t\t\tstream->timing.v_addressable >= 1440 &&\n\t\t\tstream->timing.v_addressable <= 2160) &&\n\t\t\t(dc->current_state->stream_count > 1 ||\n\t\t\t(dc->current_state->stream_count == 1 && !stream->allow_freesync)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nbool dc_stream_set_cursor_attributes(\n\tstruct dc_stream_state *stream,\n\tconst struct dc_cursor_attributes *attributes)\n{\n\tstruct dc  *dc;\n\tbool reset_idle_optimizations = false;\n\n\tif (NULL == stream) {\n\t\tdm_error(\"DC: dc_stream is NULL!\\n\");\n\t\treturn false;\n\t}\n\tif (NULL == attributes) {\n\t\tdm_error(\"DC: attributes is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tif (attributes->address.quad_part == 0) {\n\t\tdm_output_to_console(\"DC: Cursor address is 0!\\n\");\n\t\treturn false;\n\t}\n\n\tdc = stream->ctx->dc;\n\n\t \n\tif (dc->debug.allow_sw_cursor_fallback && attributes->height * attributes->width * 4 > 16384) {\n\t\tif (!dc->debug.disable_subvp_high_refresh && is_subvp_high_refresh_candidate(stream))\n\t\t\treturn false;\n\t\tif (dc->current_state->stream_count == 1 && stream->timing.v_addressable >= 2880 &&\n\t\t\t\t((stream->timing.pix_clk_100hz * 100) / stream->timing.v_total / stream->timing.h_total) < 120)\n\t\t\treturn false;\n\t\telse if (dc->current_state->stream_count > 1 && stream->timing.v_addressable >= 2160 &&\n\t\t\t\t((stream->timing.pix_clk_100hz * 100) / stream->timing.v_total / stream->timing.h_total) < 120)\n\t\t\treturn false;\n\t}\n\n\tstream->cursor_attributes = *attributes;\n\n\tdc_z10_restore(dc);\n\t \n\tif (dc->idle_optimizations_allowed) {\n\t\tdc_allow_idle_optimizations(dc, false);\n\t\treset_idle_optimizations = true;\n\t}\n\n\tprogram_cursor_attributes(dc, stream, attributes);\n\n\t \n\tif (reset_idle_optimizations)\n\t\tdc_allow_idle_optimizations(dc, true);\n\n\treturn true;\n}\n\nstatic void program_cursor_position(\n\tstruct dc *dc,\n\tstruct dc_stream_state *stream,\n\tconst struct dc_cursor_position *position)\n{\n\tint i;\n\tstruct resource_context *res_ctx;\n\tstruct pipe_ctx *pipe_to_program = NULL;\n\n\tif (!stream)\n\t\treturn;\n\n\tres_ctx = &dc->current_state->res_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != stream ||\n\t\t\t\t(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||\n\t\t\t\t!pipe_ctx->plane_state ||\n\t\t\t\t(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp) ||\n\t\t\t\t(!pipe_ctx->plane_res.ipp && !pipe_ctx->plane_res.dpp))\n\t\t\tcontinue;\n\n\t\tif (!pipe_to_program) {\n\t\t\tpipe_to_program = pipe_ctx;\n\t\t\tdc->hwss.cursor_lock(dc, pipe_to_program, true);\n\t\t}\n\n\t\tdc->hwss.set_cursor_position(pipe_ctx);\n\t\tif (dc->ctx->dmub_srv)\n\t\t\tdc_send_update_cursor_info_to_dmu(pipe_ctx, i);\n\t}\n\n\tif (pipe_to_program)\n\t\tdc->hwss.cursor_lock(dc, pipe_to_program, false);\n}\n\nbool dc_stream_set_cursor_position(\n\tstruct dc_stream_state *stream,\n\tconst struct dc_cursor_position *position)\n{\n\tstruct dc *dc;\n\tbool reset_idle_optimizations = false;\n\n\tif (NULL == stream) {\n\t\tdm_error(\"DC: dc_stream is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tif (NULL == position) {\n\t\tdm_error(\"DC: cursor position is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tdc = stream->ctx->dc;\n\tdc_z10_restore(dc);\n\n\t \n\tif (dc->idle_optimizations_allowed && (!stream->cursor_position.enable || dc->debug.exit_idle_opt_for_cursor_updates)\n\t\t\t&& position->enable) {\n\t\tdc_allow_idle_optimizations(dc, false);\n\t\treset_idle_optimizations = true;\n\t}\n\n\tstream->cursor_position = *position;\n\n\tprogram_cursor_position(dc, stream, position);\n\t \n\tif (reset_idle_optimizations)\n\t\tdc_allow_idle_optimizations(dc, true);\n\n\treturn true;\n}\n\nbool dc_stream_add_writeback(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_writeback_info *wb_info)\n{\n\tbool isDrc = false;\n\tint i = 0;\n\tstruct dwbc *dwb;\n\n\tif (stream == NULL) {\n\t\tdm_error(\"DC: dc_stream is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tif (wb_info == NULL) {\n\t\tdm_error(\"DC: dc_writeback_info is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tif (wb_info->dwb_pipe_inst >= MAX_DWB_PIPES) {\n\t\tdm_error(\"DC: writeback pipe is invalid!\\n\");\n\t\treturn false;\n\t}\n\n\twb_info->dwb_params.out_transfer_func = stream->out_transfer_func;\n\n\tdwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];\n\tdwb->dwb_is_drc = false;\n\n\t \n\n\tfor (i = 0; i < stream->num_wb_info; i++) {\n\t\t \n\t\tif (stream->writeback_info[i].wb_enabled &&\n\t\t\tstream->writeback_info[i].dwb_pipe_inst == wb_info->dwb_pipe_inst) {\n\t\t\tstream->writeback_info[i] = *wb_info;\n\t\t\tisDrc = true;\n\t\t}\n\t}\n\n\tif (!isDrc) {\n\t\tASSERT(stream->num_wb_info + 1 <= MAX_DWB_PIPES);\n\t\tstream->writeback_info[stream->num_wb_info++] = *wb_info;\n\t}\n\n\tif (dc->hwss.enable_writeback) {\n\t\tstruct dc_stream_status *stream_status = dc_stream_get_status(stream);\n\t\tstruct dwbc *dwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];\n\t\tdwb->otg_inst = stream_status->primary_otg_inst;\n\t}\n\treturn true;\n}\n\nbool dc_stream_remove_writeback(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tuint32_t dwb_pipe_inst)\n{\n\tint i = 0, j = 0;\n\tif (stream == NULL) {\n\t\tdm_error(\"DC: dc_stream is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tif (dwb_pipe_inst >= MAX_DWB_PIPES) {\n\t\tdm_error(\"DC: writeback pipe is invalid!\\n\");\n\t\treturn false;\n\t}\n\n\tif (stream->num_wb_info > MAX_DWB_PIPES) {\n\t\tdm_error(\"DC: num_wb_info is invalid!\\n\");\n\t\treturn false;\n\t}\n\n\n\tfor (i = 0; i < stream->num_wb_info; i++) {\n\t\t \n\t\tif (stream->writeback_info[i].wb_enabled &&\n\t\t\tstream->writeback_info[i].dwb_pipe_inst == dwb_pipe_inst) {\n\t\t\tstream->writeback_info[i].wb_enabled = false;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < stream->num_wb_info; i++) {\n\t\tif (stream->writeback_info[i].wb_enabled) {\n\t\t\tif (j < i)\n\t\t\t\t \n\t\t\t\tmemcpy(&stream->writeback_info[j], &stream->writeback_info[i],\n\t\t\t\t\t\tsizeof(struct dc_writeback_info));\n\t\t\tj++;\n\t\t}\n\t}\n\tstream->num_wb_info = j;\n\n\treturn true;\n}\n\nbool dc_stream_warmup_writeback(struct dc *dc,\n\t\tint num_dwb,\n\t\tstruct dc_writeback_info *wb_info)\n{\n\tif (dc->hwss.mmhubbub_warmup)\n\t\treturn dc->hwss.mmhubbub_warmup(dc, num_dwb, wb_info);\n\telse\n\t\treturn false;\n}\nuint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)\n{\n\tuint8_t i;\n\tstruct dc  *dc = stream->ctx->dc;\n\tstruct resource_context *res_ctx =\n\t\t&dc->current_state->res_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;\n\n\t\tif (res_ctx->pipe_ctx[i].stream != stream || !tg)\n\t\t\tcontinue;\n\n\t\treturn tg->funcs->get_frame_count(tg);\n\t}\n\n\treturn 0;\n}\n\nbool dc_stream_send_dp_sdp(const struct dc_stream_state *stream,\n\t\tconst uint8_t *custom_sdp_message,\n\t\tunsigned int sdp_message_size)\n{\n\tint i;\n\tstruct dc  *dc;\n\tstruct resource_context *res_ctx;\n\n\tif (stream == NULL) {\n\t\tdm_error(\"DC: dc_stream is NULL!\\n\");\n\t\treturn false;\n\t}\n\n\tdc = stream->ctx->dc;\n\tres_ctx = &dc->current_state->res_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != stream)\n\t\t\tcontinue;\n\n\t\tif (dc->hwss.send_immediate_sdp_message != NULL)\n\t\t\tdc->hwss.send_immediate_sdp_message(pipe_ctx,\n\t\t\t\t\t\t\t\tcustom_sdp_message,\n\t\t\t\t\t\t\t\tsdp_message_size);\n\t\telse\n\t\t\tDC_LOG_WARNING(\"%s:send_immediate_sdp_message not implemented on this ASIC\\n\",\n\t\t\t__func__);\n\n\t}\n\n\treturn true;\n}\n\nbool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,\n\t\t\t\t  uint32_t *v_blank_start,\n\t\t\t\t  uint32_t *v_blank_end,\n\t\t\t\t  uint32_t *h_position,\n\t\t\t\t  uint32_t *v_position)\n{\n\tuint8_t i;\n\tbool ret = false;\n\tstruct dc  *dc = stream->ctx->dc;\n\tstruct resource_context *res_ctx =\n\t\t&dc->current_state->res_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;\n\n\t\tif (res_ctx->pipe_ctx[i].stream != stream || !tg)\n\t\t\tcontinue;\n\n\t\ttg->funcs->get_scanoutpos(tg,\n\t\t\t\t\t  v_blank_start,\n\t\t\t\t\t  v_blank_end,\n\t\t\t\t\t  h_position,\n\t\t\t\t\t  v_position);\n\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nbool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe = NULL;\n\tint i;\n\n\tif (!dc->hwss.dmdata_status_done)\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe->stream == stream)\n\t\t\tbreak;\n\t}\n\t \n\tif (i == MAX_PIPES)\n\t\treturn true;\n\n\treturn dc->hwss.dmdata_status_done(pipe);\n}\n\nbool dc_stream_set_dynamic_metadata(struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_dmdata_attributes *attr)\n{\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tstruct hubp *hubp;\n\tint i;\n\n\t \n\tif (!dc_is_hdmi_signal(stream->signal) && !dc_is_dp_signal(stream->signal))\n\t\treturn false;\n\n\t \n\tif (!dc->hwss.program_dmdata_engine)\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream == stream)\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_PIPES)\n\t\treturn false;\n\n\thubp = pipe_ctx->plane_res.hubp;\n\tif (hubp == NULL)\n\t\treturn false;\n\n\tpipe_ctx->stream->dmdata_address = attr->address;\n\n\tdc->hwss.program_dmdata_engine(pipe_ctx);\n\n\tif (hubp->funcs->dmdata_set_attributes != NULL &&\n\t\t\tpipe_ctx->stream->dmdata_address.quad_part != 0) {\n\t\thubp->funcs->dmdata_set_attributes(hubp, attr);\n\t}\n\n\treturn true;\n}\n\nenum dc_status dc_stream_add_dsc_to_resource(struct dc *dc,\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *stream)\n{\n\tif (dc->res_pool->funcs->add_dsc_to_stream_resource) {\n\t\treturn dc->res_pool->funcs->add_dsc_to_stream_resource(dc, state, stream);\n\t} else {\n\t\treturn DC_NO_DSC_RESOURCE;\n\t}\n}\n\nstruct pipe_ctx *dc_stream_get_pipe_ctx(struct dc_stream_state *stream)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe = &stream->ctx->dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream == stream)\n\t\t\treturn pipe;\n\t}\n\n\treturn NULL;\n}\n\nvoid dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)\n{\n\tDC_LOG_DC(\n\t\t\t\"core_stream 0x%p: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\\n\",\n\t\t\tstream,\n\t\t\tstream->src.x,\n\t\t\tstream->src.y,\n\t\t\tstream->src.width,\n\t\t\tstream->src.height,\n\t\t\tstream->dst.x,\n\t\t\tstream->dst.y,\n\t\t\tstream->dst.width,\n\t\t\tstream->dst.height,\n\t\t\tstream->output_color_space);\n\tDC_LOG_DC(\n\t\t\t\"\\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\\n\",\n\t\t\tstream->timing.pix_clk_100hz / 10,\n\t\t\tstream->timing.h_total,\n\t\t\tstream->timing.v_total,\n\t\t\tstream->timing.pixel_encoding,\n\t\t\tstream->timing.display_color_depth);\n\tDC_LOG_DC(\n\t\t\t\"\\tlink: %d\\n\",\n\t\t\tstream->link->link_index);\n\n\tDC_LOG_DC(\n\t\t\t\"\\tdsc: %d, mst_pbn: %d\\n\",\n\t\t\tstream->timing.flags.DSC,\n\t\t\tstream->timing.dsc_cfg.mst_pbn);\n\n\tif (stream->sink) {\n\t\tif (stream->sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&\n\t\t\tstream->sink->sink_signal != SIGNAL_TYPE_NONE) {\n\n\t\t\tDC_LOG_DC(\n\t\t\t\t\t\"\\tdispname: %s signal: %x\\n\",\n\t\t\t\t\tstream->sink->edid_caps.display_name,\n\t\t\t\t\tstream->signal);\n\t\t}\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}