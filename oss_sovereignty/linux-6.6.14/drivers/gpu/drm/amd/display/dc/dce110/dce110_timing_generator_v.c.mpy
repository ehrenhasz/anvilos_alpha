{
  "module_name": "dce110_timing_generator_v.c",
  "hash_id": "598652a42a2c0da13e59d44cfeacab6fc1a683bccc0204c3c106d80cc8e240c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n \n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#include \"dc_types.h\"\n#include \"dc_bios_types.h\"\n#include \"dc.h\"\n\n#include \"include/grph_object_id.h\"\n#include \"include/logger_interface.h\"\n#include \"dce110_timing_generator.h\"\n#include \"dce110_timing_generator_v.h\"\n\n#include \"timing_generator.h\"\n\n#define DC_LOGGER \\\n\ttg->ctx->logger\n \n\n \n\nstatic bool dce110_timing_generator_v_enable_crtc(struct timing_generator *tg)\n{\n \n\tuint32_t value;\n\n\tvalue = 0;\n\tset_reg_field_value(value, 0,\n\t\t\tCRTCV_MASTER_UPDATE_MODE, MASTER_UPDATE_MODE);\n\tdm_write_reg(tg->ctx,\n\t\t\tmmCRTCV_MASTER_UPDATE_MODE, value);\n\n\t \n\tvalue = 0;\n\tdm_write_reg(tg->ctx, mmCRTCV_MASTER_UPDATE_MODE, value);\n\n\tvalue = 0;\n\tset_reg_field_value(value, 1,\n\t\t\tCRTCV_MASTER_EN, CRTC_MASTER_EN);\n\tdm_write_reg(tg->ctx,\n\t\t\tmmCRTCV_MASTER_EN, value);\n\n\treturn true;\n}\n\nstatic bool dce110_timing_generator_v_disable_crtc(struct timing_generator *tg)\n{\n\tuint32_t value;\n\n\tvalue = dm_read_reg(tg->ctx,\n\t\t\tmmCRTCV_CONTROL);\n\tset_reg_field_value(value, 0,\n\t\t\tCRTCV_CONTROL, CRTC_DISABLE_POINT_CNTL);\n\tset_reg_field_value(value, 0,\n\t\t\t\tCRTCV_CONTROL, CRTC_MASTER_EN);\n\tdm_write_reg(tg->ctx,\n\t\t\tmmCRTCV_CONTROL, value);\n\t \n\treturn true;\n}\n\nstatic void dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)\n{\n\tuint32_t addr = mmCRTCV_BLANK_CONTROL;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTCV_BLANK_CONTROL,\n\t\tCRTC_BLANK_DATA_EN);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tCRTCV_BLANK_CONTROL,\n\t\tCRTC_BLANK_DE_MODE);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_unblank_crtc(struct timing_generator *tg)\n{\n\tuint32_t addr = mmCRTCV_BLANK_CONTROL;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tCRTCV_BLANK_CONTROL,\n\t\tCRTC_BLANK_DATA_EN);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tCRTCV_BLANK_CONTROL,\n\t\tCRTC_BLANK_DE_MODE);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic bool dce110_timing_generator_v_is_in_vertical_blank(\n\t\tstruct timing_generator *tg)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\tuint32_t field = 0;\n\n\taddr = mmCRTCV_STATUS;\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tfield = get_reg_field_value(value, CRTCV_STATUS, CRTC_V_BLANK);\n\treturn field == 1;\n}\n\nstatic bool dce110_timing_generator_v_is_counter_moving(struct timing_generator *tg)\n{\n\tuint32_t value;\n\tuint32_t h1 = 0;\n\tuint32_t h2 = 0;\n\tuint32_t v1 = 0;\n\tuint32_t v2 = 0;\n\n\tvalue = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);\n\n\th1 = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTCV_STATUS_POSITION,\n\t\t\tCRTC_HORZ_COUNT);\n\n\tv1 = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTCV_STATUS_POSITION,\n\t\t\tCRTC_VERT_COUNT);\n\n\tvalue = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);\n\n\th2 = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTCV_STATUS_POSITION,\n\t\t\tCRTC_HORZ_COUNT);\n\n\tv2 = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTCV_STATUS_POSITION,\n\t\t\tCRTC_VERT_COUNT);\n\n\tif (h1 == h2 && v1 == v2)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic void dce110_timing_generator_v_wait_for_vblank(struct timing_generator *tg)\n{\n\t \n\twhile (dce110_timing_generator_v_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_v_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (!dce110_timing_generator_v_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_v_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void dce110_timing_generator_v_wait_for_vactive(struct timing_generator *tg)\n{\n\twhile (dce110_timing_generator_v_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_v_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void dce110_timing_generator_v_wait_for_state(struct timing_generator *tg,\n\tenum crtc_state state)\n{\n\tswitch (state) {\n\tcase CRTC_STATE_VBLANK:\n\t\tdce110_timing_generator_v_wait_for_vblank(tg);\n\t\tbreak;\n\n\tcase CRTC_STATE_VACTIVE:\n\t\tdce110_timing_generator_v_wait_for_vactive(tg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dce110_timing_generator_v_program_blanking(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing)\n{\n\tuint32_t vsync_offset = timing->v_border_bottom +\n\t\t\ttiming->v_front_porch;\n\tuint32_t v_sync_start = timing->v_addressable + vsync_offset;\n\n\tuint32_t hsync_offset = timing->h_border_right +\n\t\t\ttiming->h_front_porch;\n\tuint32_t h_sync_start = timing->h_addressable + hsync_offset;\n\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t value = 0;\n\tuint32_t addr = 0;\n\tuint32_t tmp = 0;\n\n\taddr = mmCRTCV_H_TOTAL;\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->h_total - 1,\n\t\tCRTCV_H_TOTAL,\n\t\tCRTC_H_TOTAL);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_V_TOTAL;\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->v_total - 1,\n\t\tCRTCV_V_TOTAL,\n\t\tCRTC_V_TOTAL);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_H_BLANK_START_END;\n\tvalue = dm_read_reg(ctx, addr);\n\n\ttmp = timing->h_total -\n\t\t(h_sync_start + timing->h_border_left);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTCV_H_BLANK_START_END,\n\t\tCRTC_H_BLANK_END);\n\n\ttmp = tmp + timing->h_addressable +\n\t\ttiming->h_border_left + timing->h_border_right;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTCV_H_BLANK_START_END,\n\t\tCRTC_H_BLANK_START);\n\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_V_BLANK_START_END;\n\tvalue = dm_read_reg(ctx, addr);\n\n\ttmp = timing->v_total - (v_sync_start + timing->v_border_top);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTCV_V_BLANK_START_END,\n\t\tCRTC_V_BLANK_END);\n\n\ttmp = tmp + timing->v_addressable + timing->v_border_top +\n\t\ttiming->v_border_bottom;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTCV_V_BLANK_START_END,\n\t\tCRTC_V_BLANK_START);\n\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_H_SYNC_A;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->h_sync_width,\n\t\tCRTCV_H_SYNC_A,\n\t\tCRTC_H_SYNC_A_END);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_H_SYNC_A_CNTL;\n\tvalue = dm_read_reg(ctx, addr);\n\tif (timing->flags.HSYNC_POSITIVE_POLARITY) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTCV_H_SYNC_A_CNTL,\n\t\t\tCRTC_H_SYNC_A_POL);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTCV_H_SYNC_A_CNTL,\n\t\t\tCRTC_H_SYNC_A_POL);\n\t}\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_V_SYNC_A;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->v_sync_width,\n\t\tCRTCV_V_SYNC_A,\n\t\tCRTC_V_SYNC_A_END);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_V_SYNC_A_CNTL;\n\tvalue = dm_read_reg(ctx, addr);\n\tif (timing->flags.VSYNC_POSITIVE_POLARITY) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTCV_V_SYNC_A_CNTL,\n\t\t\tCRTC_V_SYNC_A_POL);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTCV_V_SYNC_A_CNTL,\n\t\t\tCRTC_V_SYNC_A_POL);\n\t}\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmCRTCV_INTERLACE_CONTROL;\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->flags.INTERLACE,\n\t\tCRTCV_INTERLACE_CONTROL,\n\t\tCRTC_INTERLACE_ENABLE);\n\tdm_write_reg(ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_enable_advanced_request(\n\tstruct timing_generator *tg,\n\tbool enable,\n\tconst struct dc_crtc_timing *timing)\n{\n\tuint32_t addr = mmCRTCV_START_LINE_CONTROL;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tif (enable) {\n\t\tif ((timing->v_sync_width + timing->v_front_porch) <= 3) {\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t3,\n\t\t\t\tCRTCV_START_LINE_CONTROL,\n\t\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\t} else {\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t4,\n\t\t\t\tCRTCV_START_LINE_CONTROL,\n\t\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\t}\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTCV_START_LINE_CONTROL,\n\t\t\tCRTC_LEGACY_REQUESTOR_EN);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t2,\n\t\t\tCRTCV_START_LINE_CONTROL,\n\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTCV_START_LINE_CONTROL,\n\t\t\tCRTC_LEGACY_REQUESTOR_EN);\n\t}\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_set_blank(struct timing_generator *tg,\n\t\tbool enable_blanking)\n{\n\tif (enable_blanking)\n\t\tdce110_timing_generator_v_blank_crtc(tg);\n\telse\n\t\tdce110_timing_generator_v_unblank_crtc(tg);\n}\n\nstatic void dce110_timing_generator_v_program_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tint vready_offset,\n\tint vstartup_start,\n\tint vupdate_offset,\n\tint vupdate_width,\n\tconst enum signal_type signal,\n\tbool use_vbios)\n{\n\tif (use_vbios)\n\t\tdce110_timing_generator_program_timing_generator(tg, timing);\n\telse\n\t\tdce110_timing_generator_v_program_blanking(tg, timing);\n}\n\nstatic void dce110_timing_generator_v_program_blank_color(\n\t\tstruct timing_generator *tg,\n\t\tconst struct tg_color *black_color)\n{\n\tuint32_t addr = mmCRTCV_BLACK_COLOR;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_b_cb,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_B_CB);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_g_y,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_G_Y);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_r_cr,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_R_CR);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_set_overscan_color_black(\n\tstruct timing_generator *tg,\n\tconst struct tg_color *color)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t addr;\n\tuint32_t value = 0;\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_b_cb,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_BLUE);\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_r_cr,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_RED);\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_g_y,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_GREEN);\n\n\taddr = mmCRTCV_OVERSCAN_COLOR;\n\tdm_write_reg(ctx, addr, value);\n\taddr = mmCRTCV_BLACK_COLOR;\n\tdm_write_reg(ctx, addr, value);\n\t \n\taddr = mmCRTCV_BLANK_DATA_COLOR;\n\tdm_write_reg(ctx, addr, value);\n\n\t \n}\n\nstatic void dce110_tg_v_program_blank_color(struct timing_generator *tg,\n\t\tconst struct tg_color *black_color)\n{\n\tuint32_t addr = mmCRTCV_BLACK_COLOR;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_b_cb,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_B_CB);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_g_y,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_G_Y);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_r_cr,\n\t\tCRTCV_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_R_CR);\n\n\tdm_write_reg(tg->ctx, addr, value);\n\n\taddr = mmCRTCV_BLANK_DATA_COLOR;\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_set_overscan_color(struct timing_generator *tg,\n\tconst struct tg_color *overscan_color)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t value = 0;\n\tuint32_t addr;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_b_cb,\n\t\tCRTCV_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_BLUE);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_g_y,\n\t\tCRTCV_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_GREEN);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_r_cr,\n\t\tCRTCV_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_RED);\n\n\taddr = mmCRTCV_OVERSCAN_COLOR;\n\tdm_write_reg(ctx, addr, value);\n}\n\nstatic void dce110_timing_generator_v_set_colors(struct timing_generator *tg,\n\tconst struct tg_color *blank_color,\n\tconst struct tg_color *overscan_color)\n{\n\tif (blank_color != NULL)\n\t\tdce110_tg_v_program_blank_color(tg, blank_color);\n\tif (overscan_color != NULL)\n\t\tdce110_timing_generator_v_set_overscan_color(tg, overscan_color);\n}\n\nstatic void dce110_timing_generator_v_set_early_control(\n\t\tstruct timing_generator *tg,\n\t\tuint32_t early_cntl)\n{\n\tuint32_t regval;\n\tuint32_t address = mmCRTC_CONTROL;\n\n\tregval = dm_read_reg(tg->ctx, address);\n\tset_reg_field_value(regval, early_cntl,\n\t\t\tCRTCV_CONTROL, CRTC_HBLANK_EARLY_CONTROL);\n\tdm_write_reg(tg->ctx, address, regval);\n}\n\nstatic uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_generator *tg)\n{\n\tuint32_t addr = mmCRTCV_STATUS_FRAME_COUNT;\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\tuint32_t field = get_reg_field_value(\n\t\t\tvalue, CRTCV_STATUS_FRAME_COUNT, CRTC_FRAME_COUNT);\n\n\treturn field;\n}\n\nstatic bool dce110_timing_generator_v_did_triggered_reset_occur(\n\tstruct timing_generator *tg)\n{\n\tDC_LOG_ERROR(\"Timing Sync not supported on underlay pipe\\n\");\n\treturn false;\n}\n\nstatic void dce110_timing_generator_v_setup_global_swap_lock(\n\tstruct timing_generator *tg,\n\tconst struct dcp_gsl_params *gsl_params)\n{\n\tDC_LOG_ERROR(\"Timing Sync not supported on underlay pipe\\n\");\n\treturn;\n}\n\nstatic void dce110_timing_generator_v_enable_reset_trigger(\n\tstruct timing_generator *tg,\n\tint source_tg_inst)\n{\n\tDC_LOG_ERROR(\"Timing Sync not supported on underlay pipe\\n\");\n\treturn;\n}\n\nstatic void dce110_timing_generator_v_disable_reset_trigger(\n\tstruct timing_generator *tg)\n{\n\tDC_LOG_ERROR(\"Timing Sync not supported on underlay pipe\\n\");\n\treturn;\n}\n\nstatic void dce110_timing_generator_v_tear_down_global_swap_lock(\n\tstruct timing_generator *tg)\n{\n\tDC_LOG_ERROR(\"Timing Sync not supported on underlay pipe\\n\");\n\treturn;\n}\n\nstatic void dce110_timing_generator_v_disable_vga(\n\tstruct timing_generator *tg)\n{\n\treturn;\n}\n\n \nstatic const struct timing_generator_funcs dce110_tg_v_funcs = {\n\t\t.validate_timing = dce110_tg_validate_timing,\n\t\t.program_timing = dce110_timing_generator_v_program_timing,\n\t\t.enable_crtc = dce110_timing_generator_v_enable_crtc,\n\t\t.disable_crtc = dce110_timing_generator_v_disable_crtc,\n\t\t.is_counter_moving = dce110_timing_generator_v_is_counter_moving,\n\t\t.get_position = NULL,  \n\t\t.get_frame_count = dce110_timing_generator_v_get_vblank_counter,\n\t\t.set_early_control = dce110_timing_generator_v_set_early_control,\n\t\t.wait_for_state = dce110_timing_generator_v_wait_for_state,\n\t\t.set_blank = dce110_timing_generator_v_set_blank,\n\t\t.set_colors = dce110_timing_generator_v_set_colors,\n\t\t.set_overscan_blank_color =\n\t\t\t\tdce110_timing_generator_v_set_overscan_color_black,\n\t\t.set_blank_color = dce110_timing_generator_v_program_blank_color,\n\t\t.disable_vga = dce110_timing_generator_v_disable_vga,\n\t\t.did_triggered_reset_occur =\n\t\t\t\tdce110_timing_generator_v_did_triggered_reset_occur,\n\t\t.setup_global_swap_lock =\n\t\t\t\tdce110_timing_generator_v_setup_global_swap_lock,\n\t\t.enable_reset_trigger = dce110_timing_generator_v_enable_reset_trigger,\n\t\t.disable_reset_trigger = dce110_timing_generator_v_disable_reset_trigger,\n\t\t.tear_down_global_swap_lock =\n\t\t\t\tdce110_timing_generator_v_tear_down_global_swap_lock,\n\t\t.enable_advanced_request =\n\t\t\t\tdce110_timing_generator_v_enable_advanced_request\n};\n\nvoid dce110_timing_generator_v_construct(\n\tstruct dce110_timing_generator *tg110,\n\tstruct dc_context *ctx)\n{\n\ttg110->controller_id = CONTROLLER_ID_UNDERLAY0;\n\n\ttg110->base.funcs = &dce110_tg_v_funcs;\n\n\ttg110->base.ctx = ctx;\n\ttg110->base.bp = ctx->dc_bios;\n\n\ttg110->max_h_total = CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1;\n\ttg110->max_v_total = CRTC_V_TOTAL__CRTC_V_TOTAL_MASK + 1;\n\n\ttg110->min_h_blank = 56;\n\ttg110->min_h_front_porch = 4;\n\ttg110->min_h_back_porch = 4;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}