{
  "module_name": "dcn21_link_encoder.c",
  "hash_id": "9b36745ae2e925a101b2fde6629e94e21df98cadeeac465d44a0562b9cd7f314",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn21/dcn21_link_encoder.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n\n#include <linux/delay.h>\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dcn21_link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"dc_bios_types.h\"\n\n#include \"gpio_service_interface.h\"\n\n#define CTX \\\n\tenc10->base.ctx\n#define DC_LOGGER \\\n\tenc10->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc10->link_regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc10->link_shift->field_name, enc10->link_mask->field_name\n\n#define IND_REG(index) \\\n\t(enc10->link_regs->index)\n\nstatic struct mpll_cfg dcn21_mpll_cfg_ref[] = {\n\t\n\t{\n\t\t.hdmimode_enable = 0,\n\t\t.ref_range = 1,\n\t\t.ref_clk_mpllb_div = 1,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 238,\n\t\t.mpllb_fracn_en = 0,\n\t\t.mpllb_fracn_quot = 0,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 44237,\n\t\t.mpllb_ssc_stepsize = 59454,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 2,\n\t\t.tx_vboost_lvl = 5,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 2,\n\t\t.mpllb_ana_cp_int = 9,\n\t\t.mpllb_ana_cp_prop = 15,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 0,\n\t\t.ref_range = 1,\n\t\t.ref_clk_mpllb_div = 1,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 192,\n\t\t.mpllb_fracn_en = 1,\n\t\t.mpllb_fracn_quot = 32768,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 36864,\n\t\t.mpllb_ssc_stepsize = 49545,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 1,\n\t\t.tx_vboost_lvl = 5,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 3,\n\t\t.mpllb_ana_cp_int = 9,\n\t\t.mpllb_ana_cp_prop = 15,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 0,\n\t\t.ref_range = 1,\n\t\t.ref_clk_mpllb_div = 1,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 192,\n\t\t.mpllb_fracn_en = 1,\n\t\t.mpllb_fracn_quot = 32768,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 36864,\n\t\t.mpllb_ssc_stepsize = 49545,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 0,\n\t\t.tx_vboost_lvl = 5,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 3,\n\t\t.mpllb_ana_cp_int = 9,\n\t\t.mpllb_ana_cp_prop = 15,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n\t\n\t{\n\t\t.hdmimode_enable = 0,\n\t\t.ref_range = 1,\n\t\t.ref_clk_mpllb_div = 1,\n\t\t.mpllb_ssc_en = 1,\n\t\t.mpllb_div5_clk_en = 1,\n\t\t.mpllb_multiplier = 304,\n\t\t.mpllb_fracn_en = 1,\n\t\t.mpllb_fracn_quot = 49152,\n\t\t.mpllb_fracn_rem = 0,\n\t\t.mpllb_fracn_den = 1,\n\t\t.mpllb_ssc_up_spread = 0,\n\t\t.mpllb_ssc_peak = 55296,\n\t\t.mpllb_ssc_stepsize = 74318,\n\t\t.mpllb_div_clk_en = 0,\n\t\t.mpllb_div_multiplier = 0,\n\t\t.mpllb_hdmi_div = 0,\n\t\t.mpllb_tx_clk_div = 0,\n\t\t.tx_vboost_lvl = 5,\n\t\t.mpllb_pmix_en = 1,\n\t\t.mpllb_word_div2_en = 0,\n\t\t.mpllb_ana_v2i = 2,\n\t\t.mpllb_ana_freq_vco = 1,\n\t\t.mpllb_ana_cp_int = 7,\n\t\t.mpllb_ana_cp_prop = 16,\n\t\t.hdmi_pixel_clk_div = 0,\n\t},\n};\n\n\nstatic bool update_cfg_data(\n\t\tstruct dcn10_link_encoder *enc10,\n\t\tconst struct dc_link_settings *link_settings,\n\t\tstruct dpcssys_phy_seq_cfg *cfg)\n{\n\tint i;\n\n\tcfg->load_sram_fw = false;\n\tcfg->use_calibration_setting = true;\n\n\t\n\tfor (i = 0; i < 4; i++)\n\t\tcfg->lane_en[i] = true;\n\n\tswitch (link_settings->link_rate) {\n\tcase LINK_RATE_LOW:\n\t\tcfg->mpll_cfg = dcn21_mpll_cfg_ref[0];\n\t\tbreak;\n\tcase LINK_RATE_HIGH:\n\t\tcfg->mpll_cfg = dcn21_mpll_cfg_ref[1];\n\t\tbreak;\n\tcase LINK_RATE_HIGH2:\n\t\tcfg->mpll_cfg = dcn21_mpll_cfg_ref[2];\n\t\tbreak;\n\tcase LINK_RATE_HIGH3:\n\t\tcfg->mpll_cfg = dcn21_mpll_cfg_ref[3];\n\t\tbreak;\n\tdefault:\n\t\tDC_LOG_ERROR(\"%s: No supported link rate found %X!\\n\",\n\t\t\t\t__func__, link_settings->link_rate);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool dcn21_link_encoder_acquire_phy(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tint value;\n\n\tif (enc->features.flags.bits.DP_IS_USB_C) {\n\t\tREG_GET(RDPCSTX_PHY_CNTL6,\n\t\t\t\tRDPCS_PHY_DPALT_DISABLE, &value);\n\n\t\tif (value == 1) {\n\t\t\tASSERT(0);\n\t\t\treturn false;\n\t\t}\n\t\tREG_UPDATE(RDPCSTX_PHY_CNTL6,\n\t\t\t\tRDPCS_PHY_DPALT_DISABLE_ACK, 0);\n\n\t\tudelay(40);\n\n\t\tREG_GET(RDPCSTX_PHY_CNTL6,\n\t\t\t\t\t\tRDPCS_PHY_DPALT_DISABLE, &value);\n\t\tif (value == 1) {\n\t\t\tASSERT(0);\n\t\t\tREG_UPDATE(RDPCSTX_PHY_CNTL6,\n\t\t\t\t\tRDPCS_PHY_DPALT_DISABLE_ACK, 1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tREG_UPDATE(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DP_REF_CLK_EN, 1);\n\n\treturn true;\n}\n\n\n\nstatic void dcn21_link_encoder_release_phy(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tif (enc->features.flags.bits.DP_IS_USB_C) {\n\t\tREG_UPDATE(RDPCSTX_PHY_CNTL6,\n\t\t\t\tRDPCS_PHY_DPALT_DISABLE_ACK, 1);\n\t}\n\n\tREG_UPDATE(RDPCSTX_PHY_CNTL6, RDPCS_PHY_DP_REF_CLK_EN, 0);\n\n}\n\nvoid dcn21_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct dcn21_link_encoder *enc21 = (struct dcn21_link_encoder *) enc10;\n\tstruct dpcssys_phy_seq_cfg *cfg = &enc21->phy_seq_cfg;\n\n\tif (!dcn21_link_encoder_acquire_phy(enc))\n\t\treturn;\n\n\tif (!enc->ctx->dc->debug.avoid_vbios_exec_table) {\n\t\tdcn10_link_encoder_enable_dp_output(enc, link_settings, clock_source);\n\t\treturn;\n\t}\n\n\tif (!update_cfg_data(enc10, link_settings, cfg))\n\t\treturn;\n\n\tenc1_configure_encoder(enc10, link_settings);\n\n\tdcn10_link_encoder_setup(enc, SIGNAL_TYPE_DISPLAY_PORT);\n\n}\n\nstatic void dcn21_link_encoder_enable_dp_mst_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tif (!dcn21_link_encoder_acquire_phy(enc))\n\t\treturn;\n\n\tdcn10_link_encoder_enable_dp_mst_output(enc, link_settings, clock_source);\n}\n\nstatic void dcn21_link_encoder_disable_output(struct link_encoder *enc,\n\t\t\t\t\t      enum signal_type signal)\n{\n\tdcn10_link_encoder_disable_output(enc, signal);\n\n\tif (dc_is_dp_signal(signal))\n\t\tdcn21_link_encoder_release_phy(enc);\n}\n\n\nstatic const struct link_encoder_funcs dcn21_link_enc_funcs = {\n\t.read_state = link_enc2_read_state,\n\t.validate_output_with_stream =\n\t\tdcn10_link_encoder_validate_output_with_stream,\n\t.hw_init = enc2_hw_init,\n\t.setup = dcn10_link_encoder_setup,\n\t.enable_tmds_output = dcn10_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dcn21_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dcn21_link_encoder_enable_dp_mst_output,\n\t.disable_output = dcn21_link_encoder_disable_output,\n\t.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdcn10_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdcn10_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dcn10_link_encoder_enable_hpd,\n\t.disable_hpd = dcn10_link_encoder_disable_hpd,\n\t.is_dig_enabled = dcn10_is_dig_enabled,\n\t.destroy = dcn10_link_encoder_destroy,\n\t.fec_set_enable = enc2_fec_set_enable,\n\t.fec_set_ready = enc2_fec_set_ready,\n\t.fec_is_active = enc2_fec_is_active,\n\t.get_dig_frontend = dcn10_get_dig_frontend,\n\t.is_in_alt_mode = dcn20_link_encoder_is_in_alt_mode,\n\t.get_max_link_cap = dcn20_link_encoder_get_max_link_cap,\n};\n\nvoid dcn21_link_encoder_construct(\n\tstruct dcn21_link_encoder *enc21,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tconst struct dcn10_link_enc_aux_registers *aux_regs,\n\tconst struct dcn10_link_enc_hpd_registers *hpd_regs,\n\tconst struct dcn10_link_enc_shift *link_shift,\n\tconst struct dcn10_link_enc_mask *link_mask)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\tstruct dcn10_link_encoder *enc10 = &enc21->enc10;\n\n\tenc10->base.funcs = &dcn21_link_enc_funcs;\n\tenc10->base.ctx = init_data->ctx;\n\tenc10->base.id = init_data->encoder;\n\n\tenc10->base.hpd_source = init_data->hpd_source;\n\tenc10->base.connector = init_data->connector;\n\n\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc10->base.features = *enc_features;\n\n\tenc10->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc10->link_regs = link_regs;\n\tenc10->aux_regs = aux_regs;\n\tenc10->hpd_regs = hpd_regs;\n\tenc10->link_shift = link_shift;\n\tenc10->link_mask = link_mask;\n\n\tswitch (enc10->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGG;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc10->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc10->base.ctx->dc_bios,\n\t\t\t\t\t\tenc10->base.id, &bp_cap_info);\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tenc10->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc10->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t\tenc10->base.features.flags.bits.DP_IS_USB_C =\n\t\t\t\tbp_cap_info.DP_IS_USB_C;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}