{
  "module_name": "dcn32_hubp.c",
  "hash_id": "c484db3fbe5c3616a900c180da3be9e734956b85f5b9531e3b1cc97a6ddabcef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_hubp.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dce_calcs.h\"\n#include \"reg_helper.h\"\n#include \"basics/conversion.h\"\n#include \"dcn32_hubp.h\"\n\n#define REG(reg)\\\n\thubp2->hubp_regs->reg\n\n#define CTX \\\n\thubp2->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thubp2->hubp_shift->field_name, hubp2->hubp_mask->field_name\n\nvoid hubp32_update_force_pstate_disallow(struct hubp *hubp, bool pstate_disallow)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\tREG_UPDATE_2(UCLK_PSTATE_FORCE,\n\t\t\tDATA_UCLK_PSTATE_FORCE_EN, pstate_disallow,\n\t\t\tDATA_UCLK_PSTATE_FORCE_VALUE, 0);\n}\n\nvoid hubp32_update_force_cursor_pstate_disallow(struct hubp *hubp, bool pstate_disallow)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\n\tREG_UPDATE_2(UCLK_PSTATE_FORCE,\n\t\t\tCURSOR_UCLK_PSTATE_FORCE_EN, pstate_disallow,\n\t\t\tCURSOR_UCLK_PSTATE_FORCE_VALUE, 0);\n}\n\nvoid hubp32_update_mall_sel(struct hubp *hubp, uint32_t mall_sel, bool c_cursor)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\n\t\n\tREG_UPDATE_2(DCHUBP_MALL_CONFIG, USE_MALL_SEL, mall_sel,\n\t\t\tUSE_MALL_FOR_CURSOR, c_cursor);\n}\n\nvoid hubp32_prepare_subvp_buffering(struct hubp *hubp, bool enable)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\tREG_UPDATE(DCHUBP_VMPG_CONFIG, FORCE_ONE_ROW_FOR_FRAME, enable);\n\n\t \n\tREG_UPDATE(CURSOR_CONTROL, CURSOR_REQ_MODE, enable);\n}\n\nvoid hubp32_phantom_hubp_post_enable(struct hubp *hubp)\n{\n\tuint32_t reg_val;\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\n\t \n\tREG_UPDATE(DCSURF_FLIP_CONTROL2, SURFACE_GSL_ENABLE, 0);\n\tREG_UPDATE(DCHUBP_CNTL, HUBP_BLANK_EN, 1);\n\treg_val = REG_READ(DCHUBP_CNTL);\n\tif (reg_val) {\n\t\t \n\t\tREG_WAIT(DCHUBP_CNTL,\n\t\t\t\tHUBP_NO_OUTSTANDING_REQ, 1,\n\t\t\t\t1, 200);\n\t}\n}\n\nvoid hubp32_cursor_set_attributes(\n\t\tstruct hubp *hubp,\n\t\tconst struct dc_cursor_attributes *attr)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\tenum cursor_pitch hw_pitch = hubp1_get_cursor_pitch(attr->pitch);\n\tenum cursor_lines_per_chunk lpc = hubp2_get_lines_per_chunk(\n\t\t\tattr->width, attr->color_format);\n\n\t\n\tuint32_t cursor_width = ((attr->width + 63) / 64) * 64;\n\tuint32_t cursor_height = attr->height;\n\tuint32_t cursor_size = cursor_width * cursor_height;\n\n\thubp->curs_attr = *attr;\n\n\tREG_UPDATE(CURSOR_SURFACE_ADDRESS_HIGH,\n\t\t\tCURSOR_SURFACE_ADDRESS_HIGH, attr->address.high_part);\n\tREG_UPDATE(CURSOR_SURFACE_ADDRESS,\n\t\t\tCURSOR_SURFACE_ADDRESS, attr->address.low_part);\n\n\tREG_UPDATE_2(CURSOR_SIZE,\n\t\t\tCURSOR_WIDTH, attr->width,\n\t\t\tCURSOR_HEIGHT, attr->height);\n\n\tREG_UPDATE_4(CURSOR_CONTROL,\n\t\t\tCURSOR_MODE, attr->color_format,\n\t\t\tCURSOR_2X_MAGNIFY, attr->attribute_flags.bits.ENABLE_MAGNIFICATION,\n\t\t\tCURSOR_PITCH, hw_pitch,\n\t\t\tCURSOR_LINES_PER_CHUNK, lpc);\n\n\tREG_SET_2(CURSOR_SETTINGS, 0,\n\t\t\t \n\t\t\tCURSOR0_DST_Y_OFFSET, 0,\n\t\t\t  \n\t\t\tCURSOR0_CHUNK_HDL_ADJUST, 3);\n\n\tswitch (attr->color_format) {\n\tcase CURSOR_MODE_MONO:\n\t\tcursor_size /= 2;\n\t\tbreak;\n\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\tcursor_size *= 4;\n\t\tbreak;\n\n\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\tdefault:\n\t\tcursor_size *= 8;\n\t\tbreak;\n\t}\n\n\tif (cursor_size > 16384)\n\t\tREG_UPDATE(DCHUBP_MALL_CONFIG, USE_MALL_FOR_CURSOR, true);\n\telse\n\t\tREG_UPDATE(DCHUBP_MALL_CONFIG, USE_MALL_FOR_CURSOR, false);\n}\nvoid hubp32_init(struct hubp *hubp)\n{\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\tREG_WRITE(HUBPREQ_DEBUG_DB, 1 << 8);\n}\nstatic struct hubp_funcs dcn32_hubp_funcs = {\n\t.hubp_enable_tripleBuffer = hubp2_enable_triplebuffer,\n\t.hubp_is_triplebuffer_enabled = hubp2_is_triplebuffer_enabled,\n\t.hubp_program_surface_flip_and_addr = hubp3_program_surface_flip_and_addr,\n\t.hubp_program_surface_config = hubp3_program_surface_config,\n\t.hubp_is_flip_pending = hubp2_is_flip_pending,\n\t.hubp_setup = hubp3_setup,\n\t.hubp_setup_interdependent = hubp2_setup_interdependent,\n\t.hubp_set_vm_system_aperture_settings = hubp3_set_vm_system_aperture_settings,\n\t.set_blank = hubp2_set_blank,\n\t.set_blank_regs = hubp2_set_blank_regs,\n\t.dcc_control = hubp3_dcc_control,\n\t.mem_program_viewport = min_set_viewport,\n\t.set_cursor_attributes\t= hubp32_cursor_set_attributes,\n\t.set_cursor_position\t= hubp2_cursor_set_position,\n\t.hubp_clk_cntl = hubp2_clk_cntl,\n\t.hubp_vtg_sel = hubp2_vtg_sel,\n\t.dmdata_set_attributes = hubp3_dmdata_set_attributes,\n\t.dmdata_load = hubp2_dmdata_load,\n\t.dmdata_status_done = hubp2_dmdata_status_done,\n\t.hubp_read_state = hubp3_read_state,\n\t.hubp_clear_underflow = hubp2_clear_underflow,\n\t.hubp_set_flip_control_surface_gsl = hubp2_set_flip_control_surface_gsl,\n\t.hubp_init = hubp3_init,\n\t.set_unbounded_requesting = hubp31_set_unbounded_requesting,\n\t.hubp_soft_reset = hubp31_soft_reset,\n\t.hubp_set_flip_int = hubp1_set_flip_int,\n\t.hubp_in_blank = hubp1_in_blank,\n\t.hubp_update_force_pstate_disallow = hubp32_update_force_pstate_disallow,\n\t.hubp_update_force_cursor_pstate_disallow = hubp32_update_force_cursor_pstate_disallow,\n\t.phantom_hubp_post_enable = hubp32_phantom_hubp_post_enable,\n\t.hubp_update_mall_sel = hubp32_update_mall_sel,\n\t.hubp_prepare_subvp_buffering = hubp32_prepare_subvp_buffering\n};\n\nbool hubp32_construct(\n\tstruct dcn20_hubp *hubp2,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dcn_hubp2_registers *hubp_regs,\n\tconst struct dcn_hubp2_shift *hubp_shift,\n\tconst struct dcn_hubp2_mask *hubp_mask)\n{\n\thubp2->base.funcs = &dcn32_hubp_funcs;\n\thubp2->base.ctx = ctx;\n\thubp2->hubp_regs = hubp_regs;\n\thubp2->hubp_shift = hubp_shift;\n\thubp2->hubp_mask = hubp_mask;\n\thubp2->base.inst = inst;\n\thubp2->base.opp_id = OPP_ID_INVALID;\n\thubp2->base.mpcc_id = 0xf;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}