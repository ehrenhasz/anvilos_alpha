{
  "module_name": "dce_clk_mgr.c",
  "hash_id": "6926b96be9b1ccb1846d8690c16872fc273d67bc3e7ebd64a0c4ac46277c8ce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dce100/dce_clk_mgr.c",
  "human_readable_source": " \n\n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n#include \"dce_clk_mgr.h\"\n#include \"dce110/dce110_clk_mgr.h\"\n#include \"dce112/dce112_clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"dmcu.h\"\n#include \"core_types.h\"\n#include \"dal_asic_id.h\"\n\n \n#include \"dce/dce_8_0_d.h\"\n#include \"dce/dce_8_0_sh_mask.h\"\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\nstatic const struct clk_mgr_registers disp_clk_regs = {\n\t\tCLK_COMMON_REG_LIST_DCE_BASE()\n};\n\nstatic const struct clk_mgr_shift disp_clk_shift = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask disp_clk_mask = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n\n \nstatic const struct state_dependent_clocks dce80_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000},\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 } };\n\nint dentist_get_divider_from_did(int did)\n{\n\tif (did < DENTIST_BASE_DID_1)\n\t\tdid = DENTIST_BASE_DID_1;\n\tif (did > DENTIST_MAX_DID)\n\t\tdid = DENTIST_MAX_DID;\n\n\tif (did < DENTIST_BASE_DID_2) {\n\t\treturn DENTIST_DIVIDER_RANGE_1_START + DENTIST_DIVIDER_RANGE_1_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_1);\n\t} else if (did < DENTIST_BASE_DID_3) {\n\t\treturn DENTIST_DIVIDER_RANGE_2_START + DENTIST_DIVIDER_RANGE_2_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_2);\n\t} else if (did < DENTIST_BASE_DID_4) {\n\t\treturn DENTIST_DIVIDER_RANGE_3_START + DENTIST_DIVIDER_RANGE_3_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_3);\n\t} else {\n\t\treturn DENTIST_DIVIDER_RANGE_4_START + DENTIST_DIVIDER_RANGE_4_STEP\n\t\t\t\t\t\t\t* (did - DENTIST_BASE_DID_4);\n\t}\n}\n\n \n\nint dce_adjust_dp_ref_freq_for_ss(struct clk_mgr_internal *clk_mgr_dce, int dp_ref_clk_khz)\n{\n\tif (clk_mgr_dce->ss_on_dprefclk && clk_mgr_dce->dprefclk_ss_divider != 0) {\n\t\tstruct fixed31_32 ss_percentage = dc_fixpt_div_int(\n\t\t\t\tdc_fixpt_from_fraction(clk_mgr_dce->dprefclk_ss_percentage,\n\t\t\t\t\t\t\tclk_mgr_dce->dprefclk_ss_divider), 200);\n\t\tstruct fixed31_32 adj_dp_ref_clk_khz;\n\n\t\tss_percentage = dc_fixpt_sub(dc_fixpt_one, ss_percentage);\n\t\tadj_dp_ref_clk_khz = dc_fixpt_mul_int(ss_percentage, dp_ref_clk_khz);\n\t\tdp_ref_clk_khz = dc_fixpt_floor(adj_dp_ref_clk_khz);\n\t}\n\treturn dp_ref_clk_khz;\n}\n\nint dce_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tint dprefclk_wdivider;\n\tint dprefclk_src_sel;\n\tint dp_ref_clk_khz;\n\tint target_div;\n\n\t \n\tREG_GET(DPREFCLK_CNTL, DPREFCLK_SRC_SEL, &dprefclk_src_sel);\n\tASSERT(dprefclk_src_sel == 0);\n\n\t \n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DPREFCLK_WDIVIDER, &dprefclk_wdivider);\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dprefclk_wdivider);\n\n\t \n\tdp_ref_clk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\treturn dce_adjust_dp_ref_freq_for_ss(clk_mgr, dp_ref_clk_khz);\n}\n\nint dce12_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\treturn dce_adjust_dp_ref_freq_for_ss(clk_mgr_dce, clk_mgr_base->dprefclk_khz);\n}\n\n \nuint32_t dce_get_max_pixel_clock_for_all_paths(struct dc_state *context)\n{\n\tuint32_t max_pix_clk = 0;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pipe_ctx->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10 > max_pix_clk)\n\t\t\tmax_pix_clk = pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;\n\n\t\t \n\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal) &&\n\t\t\t\tpipe_ctx->stream_res.pix_clk_params.requested_sym_clk > max_pix_clk)\n\t\t\tmax_pix_clk = pipe_ctx->stream_res.pix_clk_params.requested_sym_clk;\n\t}\n\n\treturn max_pix_clk;\n}\n\nenum dm_pp_clocks_state dce_get_required_clocks_state(\n\tstruct clk_mgr *clk_mgr_base,\n\tstruct dc_state *context)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tint i;\n\tenum dm_pp_clocks_state low_req_clk;\n\tint max_pix_clk = dce_get_max_pixel_clock_for_all_paths(context);\n\n\t \n\tfor (i = clk_mgr_dce->max_clks_state; i >= DM_PP_CLOCKS_STATE_ULTRA_LOW; i--)\n\t\tif (context->bw_ctx.bw.dce.dispclk_khz >\n\t\t\t\tclk_mgr_dce->max_clks_by_state[i].display_clk_khz\n\t\t\t|| max_pix_clk >\n\t\t\t\tclk_mgr_dce->max_clks_by_state[i].pixel_clk_khz)\n\t\t\tbreak;\n\n\tlow_req_clk = i + 1;\n\tif (low_req_clk > clk_mgr_dce->max_clks_state) {\n\t\t \n\t\tif (clk_mgr_dce->max_clks_by_state[clk_mgr_dce->max_clks_state].display_clk_khz\n\t\t\t\t< context->bw_ctx.bw.dce.dispclk_khz)\n\t\t\tlow_req_clk = DM_PP_CLOCKS_STATE_INVALID;\n\t\telse\n\t\t\tlow_req_clk = clk_mgr_dce->max_clks_state;\n\t}\n\n\treturn low_req_clk;\n}\n\n\n \nint dce_set_clock(\n\tstruct clk_mgr *clk_mgr_base,\n\tint requested_clk_khz)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct bp_pixel_clock_parameters pxl_clk_params = { 0 };\n\tstruct dc_bios *bp = clk_mgr_base->ctx->dc_bios;\n\tint actual_clock = requested_clk_khz;\n\tstruct dmcu *dmcu = clk_mgr_dce->base.ctx->dc->res_pool->dmcu;\n\n\t \n\tif (requested_clk_khz > 0)\n\t\trequested_clk_khz = max(requested_clk_khz,\n\t\t\t\tclk_mgr_dce->base.dentist_vco_freq_khz / 64);\n\n\t \n\tpxl_clk_params.target_pixel_clock_100hz = requested_clk_khz * 10;\n\tpxl_clk_params.pll_id = CLOCK_SOURCE_ID_DFS;\n\n\tif (clk_mgr_dce->dfs_bypass_active)\n\t\tpxl_clk_params.flags.SET_DISPCLK_DFS_BYPASS = true;\n\n\tbp->funcs->program_display_engine_pll(bp, &pxl_clk_params);\n\n\tif (clk_mgr_dce->dfs_bypass_active) {\n\t\t \n\t\tclk_mgr_dce->dfs_bypass_disp_clk =\n\t\t\tpxl_clk_params.dfs_bypass_display_clock;\n\t\tactual_clock = pxl_clk_params.dfs_bypass_display_clock;\n\t}\n\n\t \n\tif (requested_clk_khz == 0)\n\t\tclk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\n\tif (dmcu && dmcu->funcs->is_dmcu_initialized(dmcu))\n\t\tdmcu->funcs->set_psr_wait_loop(dmcu, actual_clock / 1000 / 7);\n\n\treturn actual_clock;\n}\n\n\nstatic void dce_clock_read_integrated_info(struct clk_mgr_internal *clk_mgr_dce)\n{\n\tstruct dc_debug_options *debug = &clk_mgr_dce->base.ctx->dc->debug;\n\tstruct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;\n\tint i;\n\n\tif (bp->integrated_info)\n\t\tclk_mgr_dce->base.dentist_vco_freq_khz = bp->integrated_info->dentist_vco_freq;\n\tif (clk_mgr_dce->base.dentist_vco_freq_khz == 0) {\n\t\tclk_mgr_dce->base.dentist_vco_freq_khz = bp->fw_info.smu_gpu_pll_output_freq;\n\t\tif (clk_mgr_dce->base.dentist_vco_freq_khz == 0)\n\t\t\tclk_mgr_dce->base.dentist_vco_freq_khz = 3600000;\n\t}\n\n\t \n\tfor (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\tenum dm_pp_clocks_state clk_state = DM_PP_CLOCKS_STATE_INVALID;\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_ULTRA_LOW;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_LOW;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_PERFORMANCE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tclk_state = DM_PP_CLOCKS_STATE_INVALID;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (bp->integrated_info)\n\t\t\tif (bp->integrated_info->disp_clk_voltage[i].max_supported_clk >= 100000)\n\t\t\t\tclk_mgr_dce->max_clks_by_state[clk_state].display_clk_khz =\n\t\t\t\t\tbp->integrated_info->disp_clk_voltage[i].max_supported_clk;\n\t}\n\n\tif (!debug->disable_dfs_bypass && bp->integrated_info)\n\t\tif (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)\n\t\t\tclk_mgr_dce->dfs_bypass_enabled = true;\n}\n\nvoid dce_clock_read_ss_info(struct clk_mgr_internal *clk_mgr_dce)\n{\n\tstruct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;\n\tint ss_info_num = bp->funcs->get_ss_entry_number(\n\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL);\n\n\tif (ss_info_num) {\n\t\tstruct spread_spectrum_info info = { { 0 } };\n\t\tenum bp_result result = bp->funcs->get_spread_spectrum_info(\n\t\t\t\tbp, AS_SIGNAL_TYPE_GPU_PLL, 0, &info);\n\n\t\t \n\t\tif (result == BP_RESULT_OK &&\n\t\t\t\tinfo.spread_spectrum_percentage != 0) {\n\t\t\tclk_mgr_dce->ss_on_dprefclk = true;\n\t\t\tclk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;\n\n\t\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t\t \n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage =\n\t\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresult = bp->funcs->get_spread_spectrum_info(\n\t\t\t\tbp, AS_SIGNAL_TYPE_DISPLAY_PORT, 0, &info);\n\n\t\t \n\t\tif (result == BP_RESULT_OK &&\n\t\t\t\tinfo.spread_spectrum_percentage != 0) {\n\t\t\tclk_mgr_dce->ss_on_dprefclk = true;\n\t\t\tclk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;\n\n\t\t\tif (info.type.CENTER_MODE == 0) {\n\t\t\t\t \n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage =\n\t\t\t\t\t\tinfo.spread_spectrum_percentage;\n\t\t\t}\n\t\t\tif (clk_mgr_dce->base.ctx->dc->config.ignore_dpref_ss)\n\t\t\t\tclk_mgr_dce->dprefclk_ss_percentage = 0;\n\t\t}\n\t}\n}\n\nstatic void dce_pplib_apply_display_requirements(\n\tstruct dc *dc,\n\tstruct dc_state *context)\n{\n\tstruct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;\n\n\tpp_display_cfg->avail_mclk_switch_time_us = dce110_get_min_vblank_time_us(context);\n\n\tdce110_fill_display_configs(context, pp_display_cfg);\n\n\tif (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)\n\t\tdm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);\n}\n\nstatic void dce_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr_base, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr_base->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr_base->clks.dispclk_khz)) {\n\t\tpatched_disp_clk = dce_set_clock(clk_mgr_base, patched_disp_clk);\n\t\tclk_mgr_base->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce_pplib_apply_display_requirements(clk_mgr_base->ctx->dc, context);\n}\n\n\n\n\n\n\n\n\nstatic struct clk_mgr_funcs dce_funcs = {\n\t.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,\n\t.update_clocks = dce_update_clocks\n};\n\nvoid dce_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr)\n{\n\tstruct clk_mgr *base = &clk_mgr->base;\n\tstruct dm_pp_static_clock_info static_clk_info = {0};\n\n\tmemcpy(clk_mgr->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state));\n\n\tbase->ctx = ctx;\n\tbase->funcs = &dce_funcs;\n\n\tclk_mgr->regs = &disp_clk_regs;\n\tclk_mgr->clk_mgr_shift = &disp_clk_shift;\n\tclk_mgr->clk_mgr_mask = &disp_clk_mask;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\n\tif (dm_pp_get_static_clocks(ctx, &static_clk_info))\n\t\tclk_mgr->max_clks_state = static_clk_info.max_clocks_state;\n\telse\n\t\tclk_mgr->max_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;\n\tclk_mgr->cur_min_clks_state = DM_PP_CLOCKS_STATE_INVALID;\n\n\tdce_clock_read_integrated_info(clk_mgr);\n\tdce_clock_read_ss_info(clk_mgr);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}