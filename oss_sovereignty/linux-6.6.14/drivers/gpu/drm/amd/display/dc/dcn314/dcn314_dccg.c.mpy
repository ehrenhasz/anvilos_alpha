{
  "module_name": "dcn314_dccg.c",
  "hash_id": "0c46e249c5218bbe3a7cb305d9f901b7b9da9162591840ef0f6861901d5695c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_dccg.c",
  "human_readable_source": "\n \n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n\n#include \"dcn31/dcn31_dccg.h\"\n#include \"dcn314_dccg.h\"\n\n#define TO_DCN_DCCG(dccg)\\\n\tcontainer_of(dccg, struct dcn_dccg, base)\n\n#define REG(reg) \\\n\t(dccg_dcn->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name\n\n#define CTX \\\n\tdccg_dcn->base.ctx\n#define DC_LOGGER \\\n\tdccg->ctx->logger\n\nstatic void dccg314_trigger_dio_fifo_resync(\n\tstruct dccg *dccg)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tuint32_t dispclk_rdivider_value = 0;\n\n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);\n\tREG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);\n}\n\nstatic void dccg314_get_pixel_rate_div(\n\t\tstruct dccg *dccg,\n\t\tuint32_t otg_inst,\n\t\tenum pixel_rate_div *k1,\n\t\tenum pixel_rate_div *k2)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tuint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;\n\n\t*k1 = PIXEL_RATE_DIV_NA;\n\t*k2 = PIXEL_RATE_DIV_NA;\n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG0_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG0_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 1:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG1_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG1_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 2:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG2_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG2_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 3:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG3_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG3_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t*k1 = (enum pixel_rate_div)val_k1;\n\t*k2 = (enum pixel_rate_div)val_k2;\n}\n\nstatic void dccg314_set_pixel_rate_div(\n\t\tstruct dccg *dccg,\n\t\tuint32_t otg_inst,\n\t\tenum pixel_rate_div k1,\n\t\tenum pixel_rate_div k2)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tenum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;\n\n\t\n\t\n\tif (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tdccg314_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);\n\tif (k1 == cur_k1 && k2 == cur_k2)\n\t\treturn;\n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG0_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG0_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG1_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG1_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG2_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG2_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG3_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG3_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n\nstatic void dccg314_set_dtbclk_p_src(\n\t\tstruct dccg *dccg,\n\t\tenum streamclk_source src,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tuint32_t p_src_sel = 0;  \n\n\tif (src == DTBCLK0)\n\t\tp_src_sel = 2;   \n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P0_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P0_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P0_EN, 1);\n\t\tbreak;\n\tcase 1:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P1_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P1_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P1_EN, 1);\n\t\tbreak;\n\tcase 2:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P2_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P2_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P2_EN, 1);\n\t\tbreak;\n\tcase 3:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P3_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P3_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P3_EN, 1);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n}\n\n \nstatic void dccg314_set_dtbclk_dto(\n\t\tstruct dccg *dccg,\n\t\tconst struct dtbclk_dto_params *params)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\t \n\tint req_dtbclk_khz = params->pixclk_khz / 4;\n\n\tif (params->ref_dtbclk_khz && req_dtbclk_khz) {\n\t\tuint32_t modulo, phase;\n\n\t\t\n\t\tmodulo = params->ref_dtbclk_khz * 1000;\n\t\tphase = req_dtbclk_khz * 1000;\n\n\t\tREG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);\n\t\tREG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);\n\n\t\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLK_DTO_ENABLE[params->otg_inst], 1);\n\n\t\tREG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,\n\t\t\t\t1, 100);\n\n\t\t \n\t\tdccg314_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);\n\n\t\t \n\t\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tPIPE_DTO_SRC_SEL[params->otg_inst], 2);\n\t} else {\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLK_DTO_ENABLE[params->otg_inst], 0,\n\t\t\t\tPIPE_DTO_SRC_SEL[params->otg_inst], 1);\n\n\t\tREG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);\n\t\tREG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);\n\t}\n}\n\nstatic void dccg314_set_dpstreamclk(\n\t\tstruct dccg *dccg,\n\t\tenum streamclk_source src,\n\t\tint otg_inst,\n\t\tint dp_hpo_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\t \n\tdccg314_set_dtbclk_p_src(dccg, src, otg_inst);\n\n\t \n\tswitch (dp_hpo_inst) {\n\tcase 0:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL,\n\t\t\t\t\tDPSTREAMCLK0_EN, (src == REFCLK) ? 0 : 1,\n\t\t\t\t\tDPSTREAMCLK0_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL,\n\t\t\t\t\tDPSTREAMCLK1_EN, (src == REFCLK) ? 0 : 1,\n\t\t\t\t\tDPSTREAMCLK1_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL,\n\t\t\t\t\tDPSTREAMCLK2_EN, (src == REFCLK) ? 0 : 1,\n\t\t\t\t\tDPSTREAMCLK2_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL,\n\t\t\t\t\tDPSTREAMCLK3_EN, (src == REFCLK) ? 0 : 1,\n\t\t\t\t\tDPSTREAMCLK3_SRC_SEL, otg_inst);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n\nstatic void dccg314_init(struct dccg *dccg)\n{\n\tint otg_inst;\n\n\t \n\tfor (otg_inst = 0; otg_inst < 4; otg_inst++)\n\t\tdccg31_disable_symclk32_se(dccg, otg_inst);\n\n\tif (dccg->ctx->dc->debug.root_clock_optimization.bits.symclk32_le)\n\t\tfor (otg_inst = 0; otg_inst < 2; otg_inst++)\n\t\t\tdccg31_disable_symclk32_le(dccg, otg_inst);\n\n\tif (dccg->ctx->dc->debug.root_clock_optimization.bits.dpstream)\n\t\tfor (otg_inst = 0; otg_inst < 4; otg_inst++)\n\t\t\tdccg314_set_dpstreamclk(dccg, REFCLK, otg_inst,\n\t\t\t\t\t\totg_inst);\n\n\tif (dccg->ctx->dc->debug.root_clock_optimization.bits.physymclk)\n\t\tfor (otg_inst = 0; otg_inst < 5; otg_inst++)\n\t\t\tdccg31_set_physymclk(dccg, otg_inst,\n\t\t\t\t\t     PHYSYMCLK_FORCE_SRC_SYMCLK, false);\n}\n\nstatic void dccg314_set_valid_pixel_rate(\n\t\tstruct dccg *dccg,\n\t\tint ref_dtbclk_khz,\n\t\tint otg_inst,\n\t\tint pixclk_khz)\n{\n\tstruct dtbclk_dto_params dto_params = {0};\n\n\tdto_params.ref_dtbclk_khz = ref_dtbclk_khz;\n\tdto_params.otg_inst = otg_inst;\n\tdto_params.pixclk_khz = pixclk_khz;\n\n\tdccg314_set_dtbclk_dto(dccg, &dto_params);\n}\n\nstatic void dccg314_dpp_root_clock_control(\n\t\tstruct dccg *dccg,\n\t\tunsigned int dpp_inst,\n\t\tbool clock_on)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tif (dccg->dpp_clock_gated[dpp_inst] != clock_on)\n\t\treturn;\n\n\tif (clock_on) {\n\t\t \n\t\tREG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 0);\n\t\tREG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,\n\t\t\t  DPPCLK0_DTO_PHASE, 0xFF,\n\t\t\t  DPPCLK0_DTO_MODULO, 0xFF);\n\t} else {\n\t\t \n\t\tREG_UPDATE(DPPCLK_DTO_CTRL, DPPCLK_DTO_ENABLE[dpp_inst], 1);\n\t\tREG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,\n\t\t\t  DPPCLK0_DTO_PHASE, 0,\n\t\t\t  DPPCLK0_DTO_MODULO, 1);\n\t}\n\n\tdccg->dpp_clock_gated[dpp_inst] = !clock_on;\n}\n\nstatic const struct dccg_funcs dccg314_funcs = {\n\t.update_dpp_dto = dccg31_update_dpp_dto,\n\t.dpp_root_clock_control = dccg314_dpp_root_clock_control,\n\t.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,\n\t.dccg_init = dccg314_init,\n\t.set_dpstreamclk = dccg314_set_dpstreamclk,\n\t.enable_symclk32_se = dccg31_enable_symclk32_se,\n\t.disable_symclk32_se = dccg31_disable_symclk32_se,\n\t.enable_symclk32_le = dccg31_enable_symclk32_le,\n\t.disable_symclk32_le = dccg31_disable_symclk32_le,\n\t.set_symclk32_le_root_clock_gating = dccg31_set_symclk32_le_root_clock_gating,\n\t.set_physymclk = dccg31_set_physymclk,\n\t.set_dtbclk_dto = dccg314_set_dtbclk_dto,\n\t.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,\n\t.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,\n\t.otg_add_pixel = dccg31_otg_add_pixel,\n\t.otg_drop_pixel = dccg31_otg_drop_pixel,\n\t.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,\n\t.disable_dsc = dccg31_disable_dscclk,\n\t.enable_dsc = dccg31_enable_dscclk,\n\t.set_pixel_rate_div = dccg314_set_pixel_rate_div,\n\t.trigger_dio_fifo_resync = dccg314_trigger_dio_fifo_resync,\n\t.set_valid_pixel_rate = dccg314_set_valid_pixel_rate,\n};\n\nstruct dccg *dccg314_create(\n\tstruct dc_context *ctx,\n\tconst struct dccg_registers *regs,\n\tconst struct dccg_shift *dccg_shift,\n\tconst struct dccg_mask *dccg_mask)\n{\n\tstruct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);\n\tstruct dccg *base;\n\n\tif (dccg_dcn == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tbase = &dccg_dcn->base;\n\tbase->ctx = ctx;\n\tbase->funcs = &dccg314_funcs;\n\n\tdccg_dcn->regs = regs;\n\tdccg_dcn->dccg_shift = dccg_shift;\n\tdccg_dcn->dccg_mask = dccg_mask;\n\n\treturn &dccg_dcn->base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}