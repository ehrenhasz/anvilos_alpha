{
  "module_name": "vector.c",
  "hash_id": "3cca1fc84430b62746cc5e8249df7a5bc9d1be9f0880ee09c76468e0bd46b03d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/basics/vector.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"include/vector.h\"\n\nbool dal_vector_construct(\n\tstruct vector *vector,\n\tstruct dc_context *ctx,\n\tuint32_t capacity,\n\tuint32_t struct_size)\n{\n\tvector->container = NULL;\n\n\tif (!struct_size || !capacity) {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tvector->container = kcalloc(capacity, struct_size, GFP_KERNEL);\n\tif (vector->container == NULL)\n\t\treturn false;\n\tvector->capacity = capacity;\n\tvector->struct_size = struct_size;\n\tvector->count = 0;\n\tvector->ctx = ctx;\n\treturn true;\n}\n\nstatic bool dal_vector_presized_costruct(struct vector *vector,\n\t\t\t\t\t struct dc_context *ctx,\n\t\t\t\t\t uint32_t count,\n\t\t\t\t\t void *initial_value,\n\t\t\t\t\t uint32_t struct_size)\n{\n\tuint32_t i;\n\n\tvector->container = NULL;\n\n\tif (!struct_size || !count) {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tvector->container = kcalloc(count, struct_size, GFP_KERNEL);\n\n\tif (vector->container == NULL)\n\t\treturn false;\n\n\t \n\tif (NULL != initial_value) {\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmemmove(\n\t\t\t\tvector->container + i * struct_size,\n\t\t\t\tinitial_value,\n\t\t\t\tstruct_size);\n\t}\n\n\tvector->capacity = count;\n\tvector->struct_size = struct_size;\n\tvector->count = count;\n\treturn true;\n}\n\nstruct vector *dal_vector_presized_create(\n\tstruct dc_context *ctx,\n\tuint32_t size,\n\tvoid *initial_value,\n\tuint32_t struct_size)\n{\n\tstruct vector *vector = kzalloc(sizeof(struct vector), GFP_KERNEL);\n\n\tif (vector == NULL)\n\t\treturn NULL;\n\n\tif (dal_vector_presized_costruct(\n\t\tvector, ctx, size, initial_value, struct_size))\n\t\treturn vector;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(vector);\n\treturn NULL;\n}\n\nstruct vector *dal_vector_create(\n\tstruct dc_context *ctx,\n\tuint32_t capacity,\n\tuint32_t struct_size)\n{\n\tstruct vector *vector = kzalloc(sizeof(struct vector), GFP_KERNEL);\n\n\tif (vector == NULL)\n\t\treturn NULL;\n\n\tif (dal_vector_construct(vector, ctx, capacity, struct_size))\n\t\treturn vector;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(vector);\n\treturn NULL;\n}\n\nvoid dal_vector_destruct(\n\tstruct vector *vector)\n{\n\tkfree(vector->container);\n\tvector->count = 0;\n\tvector->capacity = 0;\n}\n\nvoid dal_vector_destroy(\n\tstruct vector **vector)\n{\n\tif (vector == NULL || *vector == NULL)\n\t\treturn;\n\tdal_vector_destruct(*vector);\n\tkfree(*vector);\n\t*vector = NULL;\n}\n\nuint32_t dal_vector_get_count(\n\tconst struct vector *vector)\n{\n\treturn vector->count;\n}\n\nvoid *dal_vector_at_index(\n\tconst struct vector *vector,\n\tuint32_t index)\n{\n\tif (vector->container == NULL || index >= vector->count)\n\t\treturn NULL;\n\treturn vector->container + (index * vector->struct_size);\n}\n\nbool dal_vector_remove_at_index(\n\tstruct vector *vector,\n\tuint32_t index)\n{\n\tif (index >= vector->count)\n\t\treturn false;\n\n\tif (index != vector->count - 1)\n\t\tmemmove(\n\t\t\tvector->container + (index * vector->struct_size),\n\t\t\tvector->container + ((index + 1) * vector->struct_size),\n\t\t\t(vector->count - index - 1) * vector->struct_size);\n\tvector->count -= 1;\n\n\treturn true;\n}\n\nvoid dal_vector_set_at_index(\n\tconst struct vector *vector,\n\tconst void *what,\n\tuint32_t index)\n{\n\tvoid *where = dal_vector_at_index(vector, index);\n\n\tif (!where) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\tmemmove(\n\t\twhere,\n\t\twhat,\n\t\tvector->struct_size);\n}\n\nstatic inline uint32_t calc_increased_capacity(\n\tuint32_t old_capacity)\n{\n\treturn old_capacity * 2;\n}\n\nbool dal_vector_insert_at(\n\tstruct vector *vector,\n\tconst void *what,\n\tuint32_t position)\n{\n\tuint8_t *insert_address;\n\n\tif (vector->count == vector->capacity) {\n\t\tif (!dal_vector_reserve(\n\t\t\tvector,\n\t\t\tcalc_increased_capacity(vector->capacity)))\n\t\t\treturn false;\n\t}\n\n\tinsert_address = vector->container + (vector->struct_size * position);\n\n\tif (vector->count && position < vector->count)\n\t\tmemmove(\n\t\t\tinsert_address + vector->struct_size,\n\t\t\tinsert_address,\n\t\t\tvector->struct_size * (vector->count - position));\n\n\tmemmove(\n\t\tinsert_address,\n\t\twhat,\n\t\tvector->struct_size);\n\n\tvector->count++;\n\n\treturn true;\n}\n\nbool dal_vector_append(\n\tstruct vector *vector,\n\tconst void *item)\n{\n\treturn dal_vector_insert_at(vector, item, vector->count);\n}\n\nstruct vector *dal_vector_clone(\n\tconst struct vector *vector)\n{\n\tstruct vector *vec_cloned;\n\tuint32_t count;\n\n\t \n\tcount = dal_vector_get_count(vector);\n\n\tif (count == 0)\n\t\t \n\t\tvec_cloned = dal_vector_create(\n\t\t\tvector->ctx,\n\t\t\tvector->capacity,\n\t\t\tvector->struct_size);\n\telse\n\t\t \n\t\tvec_cloned = dal_vector_presized_create(vector->ctx, count,\n\t\t\tNULL, \n\t\t\tvector->struct_size);\n\n\tif (NULL == vec_cloned) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\t \n\tmemmove(vec_cloned->container, vector->container,\n\t\t\tvec_cloned->struct_size * vec_cloned->capacity);\n\n\treturn vec_cloned;\n}\n\nuint32_t dal_vector_capacity(const struct vector *vector)\n{\n\treturn vector->capacity;\n}\n\nbool dal_vector_reserve(struct vector *vector, uint32_t capacity)\n{\n\tvoid *new_container;\n\n\tif (capacity <= vector->capacity)\n\t\treturn true;\n\n\tnew_container = krealloc(vector->container,\n\t\t\t\t capacity * vector->struct_size, GFP_KERNEL);\n\n\tif (new_container) {\n\t\tvector->container = new_container;\n\t\tvector->capacity = capacity;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid dal_vector_clear(struct vector *vector)\n{\n\tvector->count = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}