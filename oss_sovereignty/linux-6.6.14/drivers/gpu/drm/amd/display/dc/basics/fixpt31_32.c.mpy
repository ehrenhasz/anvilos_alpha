{
  "module_name": "fixpt31_32.c",
  "hash_id": "7e3fff8bb2d0906ce5d2860fe3bebbc0c973441ba76cf73f7eb60361167088bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/basics/fixpt31_32.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"include/fixed31_32.h\"\n\nstatic const struct fixed31_32 dc_fixpt_two_pi = { 26986075409LL };\nstatic const struct fixed31_32 dc_fixpt_ln2 = { 2977044471LL };\nstatic const struct fixed31_32 dc_fixpt_ln2_div_2 = { 1488522236LL };\n\nstatic inline unsigned long long abs_i64(\n\tlong long arg)\n{\n\tif (arg > 0)\n\t\treturn (unsigned long long)arg;\n\telse\n\t\treturn (unsigned long long)(-arg);\n}\n\n \nstatic inline unsigned long long complete_integer_division_u64(\n\tunsigned long long dividend,\n\tunsigned long long divisor,\n\tunsigned long long *remainder)\n{\n\tunsigned long long result;\n\n\tASSERT(divisor);\n\n\tresult = div64_u64_rem(dividend, divisor, remainder);\n\n\treturn result;\n}\n\n\n#define FRACTIONAL_PART_MASK \\\n\t((1ULL << FIXED31_32_BITS_PER_FRACTIONAL_PART) - 1)\n\n#define GET_INTEGER_PART(x) \\\n\t((x) >> FIXED31_32_BITS_PER_FRACTIONAL_PART)\n\n#define GET_FRACTIONAL_PART(x) \\\n\t(FRACTIONAL_PART_MASK & (x))\n\nstruct fixed31_32 dc_fixpt_from_fraction(long long numerator, long long denominator)\n{\n\tstruct fixed31_32 res;\n\n\tbool arg1_negative = numerator < 0;\n\tbool arg2_negative = denominator < 0;\n\n\tunsigned long long arg1_value = arg1_negative ? -numerator : numerator;\n\tunsigned long long arg2_value = arg2_negative ? -denominator : denominator;\n\n\tunsigned long long remainder;\n\n\t \n\n\tunsigned long long res_value = complete_integer_division_u64(\n\t\targ1_value, arg2_value, &remainder);\n\n\tASSERT(res_value <= LONG_MAX);\n\n\t \n\t{\n\t\tunsigned int i = FIXED31_32_BITS_PER_FRACTIONAL_PART;\n\n\t\tdo {\n\t\t\tremainder <<= 1;\n\n\t\t\tres_value <<= 1;\n\n\t\t\tif (remainder >= arg2_value) {\n\t\t\t\tres_value |= 1;\n\t\t\t\tremainder -= arg2_value;\n\t\t\t}\n\t\t} while (--i != 0);\n\t}\n\n\t \n\t{\n\t\tunsigned long long summand = (remainder << 1) >= arg2_value;\n\n\t\tASSERT(res_value <= LLONG_MAX - summand);\n\n\t\tres_value += summand;\n\t}\n\n\tres.value = (long long)res_value;\n\n\tif (arg1_negative ^ arg2_negative)\n\t\tres.value = -res.value;\n\n\treturn res;\n}\n\nstruct fixed31_32 dc_fixpt_mul(struct fixed31_32 arg1, struct fixed31_32 arg2)\n{\n\tstruct fixed31_32 res;\n\n\tbool arg1_negative = arg1.value < 0;\n\tbool arg2_negative = arg2.value < 0;\n\n\tunsigned long long arg1_value = arg1_negative ? -arg1.value : arg1.value;\n\tunsigned long long arg2_value = arg2_negative ? -arg2.value : arg2.value;\n\n\tunsigned long long arg1_int = GET_INTEGER_PART(arg1_value);\n\tunsigned long long arg2_int = GET_INTEGER_PART(arg2_value);\n\n\tunsigned long long arg1_fra = GET_FRACTIONAL_PART(arg1_value);\n\tunsigned long long arg2_fra = GET_FRACTIONAL_PART(arg2_value);\n\n\tunsigned long long tmp;\n\n\tres.value = arg1_int * arg2_int;\n\n\tASSERT(res.value <= LONG_MAX);\n\n\tres.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;\n\n\ttmp = arg1_int * arg2_fra;\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\ttmp = arg2_int * arg1_fra;\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\ttmp = arg1_fra * arg2_fra;\n\n\ttmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +\n\t\t(tmp >= (unsigned long long)dc_fixpt_half.value);\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\tif (arg1_negative ^ arg2_negative)\n\t\tres.value = -res.value;\n\n\treturn res;\n}\n\nstruct fixed31_32 dc_fixpt_sqr(struct fixed31_32 arg)\n{\n\tstruct fixed31_32 res;\n\n\tunsigned long long arg_value = abs_i64(arg.value);\n\n\tunsigned long long arg_int = GET_INTEGER_PART(arg_value);\n\n\tunsigned long long arg_fra = GET_FRACTIONAL_PART(arg_value);\n\n\tunsigned long long tmp;\n\n\tres.value = arg_int * arg_int;\n\n\tASSERT(res.value <= LONG_MAX);\n\n\tres.value <<= FIXED31_32_BITS_PER_FRACTIONAL_PART;\n\n\ttmp = arg_int * arg_fra;\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\ttmp = arg_fra * arg_fra;\n\n\ttmp = (tmp >> FIXED31_32_BITS_PER_FRACTIONAL_PART) +\n\t\t(tmp >= (unsigned long long)dc_fixpt_half.value);\n\n\tASSERT(tmp <= (unsigned long long)(LLONG_MAX - res.value));\n\n\tres.value += tmp;\n\n\treturn res;\n}\n\nstruct fixed31_32 dc_fixpt_recip(struct fixed31_32 arg)\n{\n\t \n\n\tASSERT(arg.value);\n\n\treturn dc_fixpt_from_fraction(\n\t\tdc_fixpt_one.value,\n\t\targ.value);\n}\n\nstruct fixed31_32 dc_fixpt_sinc(struct fixed31_32 arg)\n{\n\tstruct fixed31_32 square;\n\n\tstruct fixed31_32 res = dc_fixpt_one;\n\n\tint n = 27;\n\n\tstruct fixed31_32 arg_norm = arg;\n\n\tif (dc_fixpt_le(\n\t\tdc_fixpt_two_pi,\n\t\tdc_fixpt_abs(arg))) {\n\t\targ_norm = dc_fixpt_sub(\n\t\t\targ_norm,\n\t\t\tdc_fixpt_mul_int(\n\t\t\t\tdc_fixpt_two_pi,\n\t\t\t\t(int)div64_s64(\n\t\t\t\t\targ_norm.value,\n\t\t\t\t\tdc_fixpt_two_pi.value)));\n\t}\n\n\tsquare = dc_fixpt_sqr(arg_norm);\n\n\tdo {\n\t\tres = dc_fixpt_sub(\n\t\t\tdc_fixpt_one,\n\t\t\tdc_fixpt_div_int(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\tsquare,\n\t\t\t\t\tres),\n\t\t\t\tn * (n - 1)));\n\n\t\tn -= 2;\n\t} while (n > 2);\n\n\tif (arg.value != arg_norm.value)\n\t\tres = dc_fixpt_div(\n\t\t\tdc_fixpt_mul(res, arg_norm),\n\t\t\targ);\n\n\treturn res;\n}\n\nstruct fixed31_32 dc_fixpt_sin(struct fixed31_32 arg)\n{\n\treturn dc_fixpt_mul(\n\t\targ,\n\t\tdc_fixpt_sinc(arg));\n}\n\nstruct fixed31_32 dc_fixpt_cos(struct fixed31_32 arg)\n{\n\t \n\n\tconst struct fixed31_32 square = dc_fixpt_sqr(arg);\n\n\tstruct fixed31_32 res = dc_fixpt_one;\n\n\tint n = 26;\n\n\tdo {\n\t\tres = dc_fixpt_sub(\n\t\t\tdc_fixpt_one,\n\t\t\tdc_fixpt_div_int(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\tsquare,\n\t\t\t\t\tres),\n\t\t\t\tn * (n - 1)));\n\n\t\tn -= 2;\n\t} while (n != 0);\n\n\treturn res;\n}\n\n \nstatic struct fixed31_32 fixed31_32_exp_from_taylor_series(struct fixed31_32 arg)\n{\n\tunsigned int n = 9;\n\n\tstruct fixed31_32 res = dc_fixpt_from_fraction(\n\t\tn + 2,\n\t\tn + 1);\n\t \n\n\tASSERT(dc_fixpt_lt(arg, dc_fixpt_one));\n\n\tdo\n\t\tres = dc_fixpt_add(\n\t\t\tdc_fixpt_one,\n\t\t\tdc_fixpt_div_int(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\targ,\n\t\t\t\t\tres),\n\t\t\t\tn));\n\twhile (--n != 1);\n\n\treturn dc_fixpt_add(\n\t\tdc_fixpt_one,\n\t\tdc_fixpt_mul(\n\t\t\targ,\n\t\t\tres));\n}\n\nstruct fixed31_32 dc_fixpt_exp(struct fixed31_32 arg)\n{\n\t \n\n\tif (dc_fixpt_le(\n\t\tdc_fixpt_ln2_div_2,\n\t\tdc_fixpt_abs(arg))) {\n\t\tint m = dc_fixpt_round(\n\t\t\tdc_fixpt_div(\n\t\t\t\targ,\n\t\t\t\tdc_fixpt_ln2));\n\n\t\tstruct fixed31_32 r = dc_fixpt_sub(\n\t\t\targ,\n\t\t\tdc_fixpt_mul_int(\n\t\t\t\tdc_fixpt_ln2,\n\t\t\t\tm));\n\n\t\tASSERT(m != 0);\n\n\t\tASSERT(dc_fixpt_lt(\n\t\t\tdc_fixpt_abs(r),\n\t\t\tdc_fixpt_one));\n\n\t\tif (m > 0)\n\t\t\treturn dc_fixpt_shl(\n\t\t\t\tfixed31_32_exp_from_taylor_series(r),\n\t\t\t\t(unsigned char)m);\n\t\telse\n\t\t\treturn dc_fixpt_div_int(\n\t\t\t\tfixed31_32_exp_from_taylor_series(r),\n\t\t\t\t1LL << -m);\n\t} else if (arg.value != 0)\n\t\treturn fixed31_32_exp_from_taylor_series(arg);\n\telse\n\t\treturn dc_fixpt_one;\n}\n\nstruct fixed31_32 dc_fixpt_log(struct fixed31_32 arg)\n{\n\tstruct fixed31_32 res = dc_fixpt_neg(dc_fixpt_one);\n\t \n\n\tstruct fixed31_32 error;\n\n\tASSERT(arg.value > 0);\n\t \n\t \n\n\tdo {\n\t\tstruct fixed31_32 res1 = dc_fixpt_add(\n\t\t\tdc_fixpt_sub(\n\t\t\t\tres,\n\t\t\t\tdc_fixpt_one),\n\t\t\tdc_fixpt_div(\n\t\t\t\targ,\n\t\t\t\tdc_fixpt_exp(res)));\n\n\t\terror = dc_fixpt_sub(\n\t\t\tres,\n\t\t\tres1);\n\n\t\tres = res1;\n\t\t \n\t} while (abs_i64(error.value) > 100ULL);\n\n\treturn res;\n}\n\n\n \n\nstatic inline unsigned int ux_dy(\n\tlong long value,\n\tunsigned int integer_bits,\n\tunsigned int fractional_bits)\n{\n\t \n\tunsigned int result = (1 << integer_bits) - 1;\n\t \n\tunsigned int fractional_part = FRACTIONAL_PART_MASK & value;\n\t \n\tresult &= GET_INTEGER_PART(value);\n\t \n\tresult <<= fractional_bits;\n\t \n\tfractional_part >>= FIXED31_32_BITS_PER_FRACTIONAL_PART - fractional_bits;\n\t \n\treturn result | fractional_part;\n}\n\nstatic inline unsigned int clamp_ux_dy(\n\tlong long value,\n\tunsigned int integer_bits,\n\tunsigned int fractional_bits,\n\tunsigned int min_clamp)\n{\n\tunsigned int truncated_val = ux_dy(value, integer_bits, fractional_bits);\n\n\tif (value >= (1LL << (integer_bits + FIXED31_32_BITS_PER_FRACTIONAL_PART)))\n\t\treturn (1 << (integer_bits + fractional_bits)) - 1;\n\telse if (truncated_val > min_clamp)\n\t\treturn truncated_val;\n\telse\n\t\treturn min_clamp;\n}\n\nunsigned int dc_fixpt_u4d19(struct fixed31_32 arg)\n{\n\treturn ux_dy(arg.value, 4, 19);\n}\n\nunsigned int dc_fixpt_u3d19(struct fixed31_32 arg)\n{\n\treturn ux_dy(arg.value, 3, 19);\n}\n\nunsigned int dc_fixpt_u2d19(struct fixed31_32 arg)\n{\n\treturn ux_dy(arg.value, 2, 19);\n}\n\nunsigned int dc_fixpt_u0d19(struct fixed31_32 arg)\n{\n\treturn ux_dy(arg.value, 0, 19);\n}\n\nunsigned int dc_fixpt_clamp_u0d14(struct fixed31_32 arg)\n{\n\treturn clamp_ux_dy(arg.value, 0, 14, 1);\n}\n\nunsigned int dc_fixpt_clamp_u0d10(struct fixed31_32 arg)\n{\n\treturn clamp_ux_dy(arg.value, 0, 10, 1);\n}\n\nint dc_fixpt_s4d19(struct fixed31_32 arg)\n{\n\tif (arg.value < 0)\n\t\treturn -(int)ux_dy(dc_fixpt_abs(arg).value, 4, 19);\n\telse\n\t\treturn ux_dy(arg.value, 4, 19);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}