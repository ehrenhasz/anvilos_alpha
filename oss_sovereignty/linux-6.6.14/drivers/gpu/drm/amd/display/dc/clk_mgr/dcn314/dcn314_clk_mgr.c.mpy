{
  "module_name": "dcn314_clk_mgr.c",
  "hash_id": "c6a9e90e5b03b27c5c4a0fc9b4a6f96c8c0057eecdec437013f7cf4d8bed2f1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn314/dcn314_clk_mgr.c",
  "human_readable_source": "\n \n\n\n\n#include \"dcn314_clk_mgr.h\"\n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n\n\n#include \"dce100/dce_clk_mgr.h\"\n\n\n#include \"dcn20/dcn20_clk_mgr.h\"\n\n\n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n\n \n#include \"dcn30/dcn30_clk_mgr.h\"\n#include \"dcn31/dcn31_clk_mgr.h\"\n\n#include \"dc_dmub_srv.h\"\n#include \"link.h\"\n#include \"dcn314_smu.h\"\n\n\n#include \"logger_types.h\"\n#undef DC_LOGGER\n#define DC_LOGGER \\\n\tclk_mgr->base.base.ctx->logger\n\n\n#define MAX_INSTANCE                                        7\n#define MAX_SEGMENT                                         8\n\nstruct IP_BASE_INSTANCE {\n\tunsigned int segment[MAX_SEGMENT];\n};\n\nstruct IP_BASE {\n\tstruct IP_BASE_INSTANCE instance[MAX_INSTANCE];\n};\n\nstatic const struct IP_BASE CLK_BASE = { { { { 0x00016C00, 0x02401800, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x00016E00, 0x02401C00, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x00017000, 0x02402000, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x00017200, 0x02402400, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x0001B000, 0x0242D800, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x0001B200, 0x0242DC00, 0, 0, 0, 0, 0, 0 } },\n\t\t\t\t\t{ { 0x0001B400, 0x0242E000, 0, 0, 0, 0, 0, 0 } } } };\n\n#define regCLK1_CLK_PLL_REQ\t\t\t0x0237\n#define regCLK1_CLK_PLL_REQ_BASE_IDX\t\t0\n\n#define CLK1_CLK_PLL_REQ__FbMult_int__SHIFT\t0x0\n#define CLK1_CLK_PLL_REQ__PllSpineDiv__SHIFT\t0xc\n#define CLK1_CLK_PLL_REQ__FbMult_frac__SHIFT\t0x10\n#define CLK1_CLK_PLL_REQ__FbMult_int_MASK\t0x000001FFL\n#define CLK1_CLK_PLL_REQ__PllSpineDiv_MASK\t0x0000F000L\n#define CLK1_CLK_PLL_REQ__FbMult_frac_MASK\t0xFFFF0000L\n\n#define REG(reg_name) \\\n\t(CLK_BASE.instance[0].segment[reg ## reg_name ## _BASE_IDX] + reg ## reg_name)\n\n#define TO_CLK_MGR_DCN314(clk_mgr)\\\n\tcontainer_of(clk_mgr, struct clk_mgr_dcn314, base)\n\nstatic int dcn314_get_active_display_cnt_wa(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i, display_count;\n\tbool tmds_present = false;\n\n\tdisplay_count = 0;\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tconst struct dc_stream_state *stream = context->streams[i];\n\n\t\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\ttmds_present = true;\n\n\t\t \n\t\tif (dc_is_dp_signal(stream->signal) && !stream->dpms_off)\n\t\t\tdisplay_count++;\n\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tconst struct dc_link *link = dc->links[i];\n\n\t\t \n\t\tif (link->link_enc && link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc))\n\t\t\tdisplay_count++;\n\t}\n\n\t \n\tif (display_count == 0 && tmds_present)\n\t\tdisplay_count = 1;\n\n\treturn display_count;\n}\n\nstatic void dcn314_disable_otg_wa(struct clk_mgr *clk_mgr_base, struct dc_state *context, bool disable)\n{\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; ++i) {\n\t\tstruct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->top_pipe || pipe->prev_odm_pipe)\n\t\t\tcontinue;\n\t\tif (pipe->stream && (pipe->stream->dpms_off || dc_is_virtual_signal(pipe->stream->signal))) {\n\t\t\tstruct stream_encoder *stream_enc = pipe->stream_res.stream_enc;\n\n\t\t\tif (disable) {\n\t\t\t\tif (stream_enc && stream_enc->funcs->disable_fifo)\n\t\t\t\t\tpipe->stream_res.stream_enc->funcs->disable_fifo(stream_enc);\n\n\t\t\t\tpipe->stream_res.tg->funcs->immediate_disable_crtc(pipe->stream_res.tg);\n\t\t\t\treset_sync_context_for_pipe(dc, context, i);\n\t\t\t} else {\n\t\t\t\tpipe->stream_res.tg->funcs->enable_crtc(pipe->stream_res.tg);\n\n\t\t\t\tif (stream_enc && stream_enc->funcs->enable_fifo)\n\t\t\t\t\tpipe->stream_res.stream_enc->funcs->enable_fifo(stream_enc);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dcn314_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool dpp_clock_lowered = false;\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\t \n\tif (safe_to_lower) {\n\t\tif (new_clocks->zstate_support != DCN_ZSTATE_SUPPORT_DISALLOW &&\n\t\t\t\tnew_clocks->zstate_support != clk_mgr_base->clks.zstate_support) {\n\t\t\tdcn314_smu_set_zstate_support(clk_mgr, new_clocks->zstate_support);\n\t\t\tdm_helpers_enable_periodic_detection(clk_mgr_base->ctx, true);\n\t\t\tclk_mgr_base->clks.zstate_support = new_clocks->zstate_support;\n\t\t}\n\n\t\tif (clk_mgr_base->clks.dtbclk_en && !new_clocks->dtbclk_en) {\n\t\t\tdcn314_smu_set_dtbclk(clk_mgr, false);\n\t\t\tclk_mgr_base->clks.dtbclk_en = new_clocks->dtbclk_en;\n\t\t}\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_LOW_POWER) {\n\t\t\tdisplay_count = dcn314_get_active_display_cnt_wa(dc, context);\n\t\t\t \n\t\t\tif (display_count == 0) {\n\t\t\t\tunion display_idle_optimization_u idle_info = { 0 };\n\t\t\t\tidle_info.idle_info.df_request_disabled = 1;\n\t\t\t\tidle_info.idle_info.phy_ref_clk_off = 1;\n\t\t\t\tidle_info.idle_info.s0i2_rdy = 1;\n\t\t\t\tdcn314_smu_set_display_idle_optimization(clk_mgr, idle_info.data);\n\t\t\t\t \n\t\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_LOW_POWER;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (new_clocks->zstate_support == DCN_ZSTATE_SUPPORT_DISALLOW &&\n\t\t\t\tnew_clocks->zstate_support != clk_mgr_base->clks.zstate_support) {\n\t\t\tdcn314_smu_set_zstate_support(clk_mgr, DCN_ZSTATE_SUPPORT_DISALLOW);\n\t\t\tdm_helpers_enable_periodic_detection(clk_mgr_base->ctx, false);\n\t\t\tclk_mgr_base->clks.zstate_support = new_clocks->zstate_support;\n\t\t}\n\n\t\tif (!clk_mgr_base->clks.dtbclk_en && new_clocks->dtbclk_en) {\n\t\t\tdcn314_smu_set_dtbclk(clk_mgr, true);\n\t\t\tclk_mgr_base->clks.dtbclk_en = new_clocks->dtbclk_en;\n\t\t}\n\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_MISSION_MODE) {\n\t\t\tunion display_idle_optimization_u idle_info = { 0 };\n\n\t\t\tdcn314_smu_set_display_idle_optimization(clk_mgr, idle_info.data);\n\t\t\t \n\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_MISSION_MODE;\n\t\t}\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\tdcn314_smu_set_hard_min_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_khz);\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\tdcn314_smu_set_min_deep_sleep_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_deep_sleep_khz);\n\t}\n\n\t \n\tif (new_clocks->dppclk_khz < 100000)\n\t\tnew_clocks->dppclk_khz = 100000;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr->base.clks.dppclk_khz)) {\n\t\tif (clk_mgr->base.clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\t\tclk_mgr_base->clks.dppclk_khz = new_clocks->dppclk_khz;\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tdcn314_disable_otg_wa(clk_mgr_base, context, true);\n\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t\tdcn314_smu_set_dispclk(clk_mgr, clk_mgr_base->clks.dispclk_khz);\n\t\tdcn314_disable_otg_wa(clk_mgr_base, context, false);\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (dpp_clock_lowered) {\n\t\t \n\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\tdcn314_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\t} else {\n\t\t \n\t\tif (update_dppclk || update_dispclk)\n\t\t\tdcn314_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\t\t \n\t\tif (new_clocks->dppclk_khz >= dc->current_state->bw_ctx.bw.dcn.clk.dppclk_khz)\n\t\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t}\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.notify_clocks.header.type = DMUB_CMD__CLK_MGR;\n\tcmd.notify_clocks.header.sub_type = DMUB_CMD__CLK_MGR_NOTIFY_CLOCKS;\n\tcmd.notify_clocks.clocks.dcfclk_khz = clk_mgr_base->clks.dcfclk_khz;\n\tcmd.notify_clocks.clocks.dcfclk_deep_sleep_khz =\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz;\n\tcmd.notify_clocks.clocks.dispclk_khz = clk_mgr_base->clks.dispclk_khz;\n\tcmd.notify_clocks.clocks.dppclk_khz = clk_mgr_base->clks.dppclk_khz;\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nstatic int get_vco_frequency_from_reg(struct clk_mgr_internal *clk_mgr)\n{\n\t \n\tstruct fixed31_32 pll_req;\n\tunsigned int fbmult_frac_val = 0;\n\tunsigned int fbmult_int_val = 0;\n\n\t \n\n\tREG_GET(CLK1_CLK_PLL_REQ, FbMult_frac, &fbmult_frac_val);  \n\tREG_GET(CLK1_CLK_PLL_REQ, FbMult_int, &fbmult_int_val);  \n\n\tpll_req = dc_fixpt_from_int(fbmult_int_val);\n\n\t \n\tpll_req.value |= fbmult_frac_val << 16;\n\n\t \n\tpll_req = dc_fixpt_mul_int(pll_req, clk_mgr->dfs_ref_freq_khz);\n\n\t \n\treturn dc_fixpt_floor(pll_req);\n}\n\nstatic void dcn314_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tdcn314_smu_enable_pme_wa(clk_mgr);\n}\n\nbool dcn314_are_clock_states_equal(struct dc_clocks *a,\n\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\telse if (a->zstate_support != b->zstate_support)\n\t\treturn false;\n\telse if (a->dtbclk_en != b->dtbclk_en)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void dcn314_dump_clk_registers(struct clk_state_registers_and_bypass *regs_and_bypass,\n\t\tstruct clk_mgr *clk_mgr_base, struct clk_log_info *log_info)\n{\n\treturn;\n}\n\nstatic struct clk_bw_params dcn314_bw_params = {\n\t.vram_type = Ddr4MemType,\n\t.num_channels = 1,\n\t.clk_table = {\n\t\t.num_entries = 4,\n\t},\n\n};\n\nstatic struct wm_table ddr5_wm_table = {\n\t.entries = {\n\t\t{\n\t\t\t.wm_inst = WM_A,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.72,\n\t\t\t.sr_exit_time_us = 12.5,\n\t\t\t.sr_enter_plus_exit_time_us = 14.5,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_B,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.72,\n\t\t\t.sr_exit_time_us = 12.5,\n\t\t\t.sr_enter_plus_exit_time_us = 14.5,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_C,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.72,\n\t\t\t.sr_exit_time_us = 12.5,\n\t\t\t.sr_enter_plus_exit_time_us = 14.5,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_D,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.72,\n\t\t\t.sr_exit_time_us = 12.5,\n\t\t\t.sr_enter_plus_exit_time_us = 14.5,\n\t\t\t.valid = true,\n\t\t},\n\t}\n};\n\nstatic struct wm_table lpddr5_wm_table = {\n\t.entries = {\n\t\t{\n\t\t\t.wm_inst = WM_A,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.65333,\n\t\t\t.sr_exit_time_us = 30.0,\n\t\t\t.sr_enter_plus_exit_time_us = 32.0,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_B,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.65333,\n\t\t\t.sr_exit_time_us = 30.0,\n\t\t\t.sr_enter_plus_exit_time_us = 32.0,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_C,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.65333,\n\t\t\t.sr_exit_time_us = 30.0,\n\t\t\t.sr_enter_plus_exit_time_us = 32.0,\n\t\t\t.valid = true,\n\t\t},\n\t\t{\n\t\t\t.wm_inst = WM_D,\n\t\t\t.wm_type = WM_TYPE_PSTATE_CHG,\n\t\t\t.pstate_latency_us = 11.65333,\n\t\t\t.sr_exit_time_us = 30.0,\n\t\t\t.sr_enter_plus_exit_time_us = 32.0,\n\t\t\t.valid = true,\n\t\t},\n\t}\n};\n\nstatic DpmClocks314_t dummy_clocks;\n\nstatic struct dcn314_watermarks dummy_wms = { 0 };\n\nstatic void dcn314_build_watermark_ranges(struct clk_bw_params *bw_params, struct dcn314_watermarks *table)\n{\n\tint i, num_valid_sets;\n\n\tnum_valid_sets = 0;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\t \n\t\tif (!bw_params->wm_table.entries[i].valid)\n\t\t\tcontinue;\n\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].WmSetting = bw_params->wm_table.entries[i].wm_inst;\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].WmType = bw_params->wm_table.entries[i].wm_type;\n\t\t \n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinClock = 0;\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxClock = 0xFFFF;\n\n\t\tif (table->WatermarkRow[WM_DCFCLK][num_valid_sets].WmType == WM_TYPE_PSTATE_CHG) {\n\t\t\tif (i == 0)\n\t\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinMclk = 0;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinMclk =\n\t\t\t\t\t\tbw_params->clk_table.entries[i - 1].dcfclk_mhz + 1;\n\t\t\t}\n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxMclk =\n\t\t\t\t\tbw_params->clk_table.entries[i].dcfclk_mhz;\n\n\t\t} else {\n\t\t\t \n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinClock = 0;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxClock = 0xFFFF;\n\n\t\t\t \n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxClock = 0xFFFF;\n\t\t}\n\t\tnum_valid_sets++;\n\t}\n\n\tASSERT(num_valid_sets != 0);  \n\n\t \n\ttable->WatermarkRow[WM_DCFCLK][0].MinMclk = 0;\n\ttable->WatermarkRow[WM_DCFCLK][0].MinClock = 0;\n\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxMclk = 0xFFFF;\n\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxClock = 0xFFFF;\n\n\t \n\ttable->WatermarkRow[WM_SOCCLK][0].WmSetting = WM_A;\n\ttable->WatermarkRow[WM_SOCCLK][0].MinClock = 0;\n\ttable->WatermarkRow[WM_SOCCLK][0].MaxClock = 0xFFFF;\n\ttable->WatermarkRow[WM_SOCCLK][0].MinMclk = 0;\n\ttable->WatermarkRow[WM_SOCCLK][0].MaxMclk = 0xFFFF;\n}\n\nstatic void dcn314_notify_wm_ranges(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct clk_mgr_dcn314 *clk_mgr_dcn314 = TO_CLK_MGR_DCN314(clk_mgr);\n\tstruct dcn314_watermarks *table = clk_mgr_dcn314->smu_wm_set.wm_set;\n\n\tif (!clk_mgr->smu_ver)\n\t\treturn;\n\n\tif (!table || clk_mgr_dcn314->smu_wm_set.mc_address.quad_part == 0)\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\tdcn314_build_watermark_ranges(clk_mgr_base->bw_params, table);\n\n\tdcn314_smu_set_dram_addr_high(clk_mgr,\n\t\t\tclk_mgr_dcn314->smu_wm_set.mc_address.high_part);\n\tdcn314_smu_set_dram_addr_low(clk_mgr,\n\t\t\tclk_mgr_dcn314->smu_wm_set.mc_address.low_part);\n\tdcn314_smu_transfer_wm_table_dram_2_smu(clk_mgr);\n}\n\nstatic void dcn314_get_dpm_table_from_smu(struct clk_mgr_internal *clk_mgr,\n\t\tstruct dcn314_smu_dpm_clks *smu_dpm_clks)\n{\n\tDpmClocks314_t *table = smu_dpm_clks->dpm_clks;\n\n\tif (!clk_mgr->smu_ver)\n\t\treturn;\n\n\tif (!table || smu_dpm_clks->mc_address.quad_part == 0)\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\tdcn314_smu_set_dram_addr_high(clk_mgr,\n\t\t\tsmu_dpm_clks->mc_address.high_part);\n\tdcn314_smu_set_dram_addr_low(clk_mgr,\n\t\t\tsmu_dpm_clks->mc_address.low_part);\n\tdcn314_smu_transfer_dpm_table_smu_2_dram(clk_mgr);\n}\n\nstatic inline bool is_valid_clock_value(uint32_t clock_value)\n{\n\treturn clock_value > 1 && clock_value < 100000;\n}\n\nstatic unsigned int convert_wck_ratio(uint8_t wck_ratio)\n{\n\tswitch (wck_ratio) {\n\tcase WCK_RATIO_1_2:\n\t\treturn 2;\n\n\tcase WCK_RATIO_1_4:\n\t\treturn 4;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic uint32_t find_max_clk_value(const uint32_t clocks[], uint32_t num_clocks)\n{\n\tuint32_t max = 0;\n\tint i;\n\n\tfor (i = 0; i < num_clocks; ++i) {\n\t\tif (clocks[i] > max)\n\t\t\tmax = clocks[i];\n\t}\n\n\treturn max;\n}\n\nstatic void dcn314_clk_mgr_helper_populate_bw_params(struct clk_mgr_internal *clk_mgr,\n\t\t\t\t\t\t    struct integrated_info *bios_info,\n\t\t\t\t\t\t    const DpmClocks314_t *clock_table)\n{\n\tstruct clk_bw_params *bw_params = clk_mgr->base.bw_params;\n\tstruct clk_limit_table_entry def_max = bw_params->clk_table.entries[bw_params->clk_table.num_entries - 1];\n\tuint32_t max_pstate = 0,  max_fclk = 0,  min_pstate = 0, max_dispclk = 0, max_dppclk = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < clock_table->NumDfPstatesEnabled; i++) {\n\t\tif (is_valid_clock_value(clock_table->DfPstateTable[i].FClk) &&\n\t\t    clock_table->DfPstateTable[i].FClk > max_fclk) {\n\t\t\tmax_fclk = clock_table->DfPstateTable[i].FClk;\n\t\t\tmax_pstate = i;\n\t\t}\n\t}\n\n\t \n\tASSERT(is_valid_clock_value(max_fclk));\n\n\t \n\tif (clock_table->NumDispClkLevelsEnabled <= NUM_DISPCLK_DPM_LEVELS &&\n\t    clock_table->NumDispClkLevelsEnabled <= NUM_DPPCLK_DPM_LEVELS) {\n\t\tmax_dispclk = find_max_clk_value(clock_table->DispClocks, clock_table->NumDispClkLevelsEnabled);\n\t\tmax_dppclk = find_max_clk_value(clock_table->DppClocks, clock_table->NumDispClkLevelsEnabled);\n\t} else {\n\t\t \n\t\tASSERT(0);\n\t}\n\n\t \n\tfor (i = 0; i < clock_table->NumDcfClkLevelsEnabled; i++) {\n\t\tuint32_t min_fclk = clock_table->DfPstateTable[0].FClk;\n\t\tint j;\n\n\t\tfor (j = 1; j < clock_table->NumDfPstatesEnabled; j++) {\n\t\t\tif (is_valid_clock_value(clock_table->DfPstateTable[j].FClk) &&\n\t\t\t    clock_table->DfPstateTable[j].FClk < min_fclk &&\n\t\t\t    clock_table->DfPstateTable[j].Voltage <= clock_table->SocVoltage[i]) {\n\t\t\t\tmin_fclk = clock_table->DfPstateTable[j].FClk;\n\t\t\t\tmin_pstate = j;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (j = bw_params->clk_table.num_entries - 1; j > 0; j--)\n\t\t\tif (bw_params->clk_table.entries[j].dcfclk_mhz <= clock_table->DcfClocks[i])\n\t\t\t\tbreak;\n\n\t\tbw_params->clk_table.entries[i].phyclk_mhz = bw_params->clk_table.entries[j].phyclk_mhz;\n\t\tbw_params->clk_table.entries[i].phyclk_d18_mhz = bw_params->clk_table.entries[j].phyclk_d18_mhz;\n\t\tbw_params->clk_table.entries[i].dtbclk_mhz = bw_params->clk_table.entries[j].dtbclk_mhz;\n\n\t\t \n\t\tbw_params->clk_table.entries[i].fclk_mhz = min_fclk;\n\t\tbw_params->clk_table.entries[i].memclk_mhz = clock_table->DfPstateTable[min_pstate].MemClk;\n\t\tbw_params->clk_table.entries[i].voltage = clock_table->DfPstateTable[min_pstate].Voltage;\n\t\tbw_params->clk_table.entries[i].dcfclk_mhz = clock_table->DcfClocks[i];\n\t\tbw_params->clk_table.entries[i].socclk_mhz = clock_table->SocClocks[i];\n\t\tbw_params->clk_table.entries[i].dispclk_mhz = max_dispclk;\n\t\tbw_params->clk_table.entries[i].dppclk_mhz = max_dppclk;\n\t\tbw_params->clk_table.entries[i].wck_ratio = convert_wck_ratio(\n\t\t\tclock_table->DfPstateTable[min_pstate].WckRatio);\n\t}\n\n\t \n\tif (max_pstate != min_pstate || i == 0) {\n\t\tif (i > MAX_NUM_DPM_LVL - 1)\n\t\t\ti = MAX_NUM_DPM_LVL - 1;\n\n\t\tbw_params->clk_table.entries[i].fclk_mhz = max_fclk;\n\t\tbw_params->clk_table.entries[i].memclk_mhz = clock_table->DfPstateTable[max_pstate].MemClk;\n\t\tbw_params->clk_table.entries[i].voltage = clock_table->DfPstateTable[max_pstate].Voltage;\n\t\tbw_params->clk_table.entries[i].dcfclk_mhz = find_max_clk_value(clock_table->DcfClocks, NUM_DCFCLK_DPM_LEVELS);\n\t\tbw_params->clk_table.entries[i].socclk_mhz = find_max_clk_value(clock_table->SocClocks, NUM_SOCCLK_DPM_LEVELS);\n\t\tbw_params->clk_table.entries[i].dispclk_mhz = max_dispclk;\n\t\tbw_params->clk_table.entries[i].dppclk_mhz = max_dppclk;\n\t\tbw_params->clk_table.entries[i].wck_ratio = convert_wck_ratio(\n\t\t\tclock_table->DfPstateTable[max_pstate].WckRatio);\n\t\ti++;\n\t}\n\tbw_params->clk_table.num_entries = i--;\n\n\t \n\tbw_params->clk_table.entries[i].socclk_mhz = find_max_clk_value(clock_table->SocClocks, NUM_SOCCLK_DPM_LEVELS);\n\tbw_params->clk_table.entries[i].dispclk_mhz = find_max_clk_value(clock_table->DispClocks, NUM_DISPCLK_DPM_LEVELS);\n\tbw_params->clk_table.entries[i].dppclk_mhz = find_max_clk_value(clock_table->DppClocks, NUM_DPPCLK_DPM_LEVELS);\n\tASSERT(clock_table->DcfClocks[i] == find_max_clk_value(clock_table->DcfClocks, NUM_DCFCLK_DPM_LEVELS));\n\tbw_params->clk_table.entries[i].phyclk_mhz = def_max.phyclk_mhz;\n\tbw_params->clk_table.entries[i].phyclk_d18_mhz = def_max.phyclk_d18_mhz;\n\tbw_params->clk_table.entries[i].dtbclk_mhz = def_max.dtbclk_mhz;\n\n\t \n\tfor (i = 0; i < bw_params->clk_table.num_entries; i++) {\n\t\tif (!bw_params->clk_table.entries[i].fclk_mhz) {\n\t\t\tbw_params->clk_table.entries[i].fclk_mhz = def_max.fclk_mhz;\n\t\t\tbw_params->clk_table.entries[i].memclk_mhz = def_max.memclk_mhz;\n\t\t\tbw_params->clk_table.entries[i].voltage = def_max.voltage;\n\t\t}\n\t\tif (!bw_params->clk_table.entries[i].dcfclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].dcfclk_mhz = def_max.dcfclk_mhz;\n\t\tif (!bw_params->clk_table.entries[i].socclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].socclk_mhz = def_max.socclk_mhz;\n\t\tif (!bw_params->clk_table.entries[i].dispclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].dispclk_mhz = def_max.dispclk_mhz;\n\t\tif (!bw_params->clk_table.entries[i].dppclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].dppclk_mhz = def_max.dppclk_mhz;\n\t\tif (!bw_params->clk_table.entries[i].phyclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].phyclk_mhz = def_max.phyclk_mhz;\n\t\tif (!bw_params->clk_table.entries[i].phyclk_d18_mhz)\n\t\t\tbw_params->clk_table.entries[i].phyclk_d18_mhz = def_max.phyclk_d18_mhz;\n\t\tif (!bw_params->clk_table.entries[i].dtbclk_mhz)\n\t\t\tbw_params->clk_table.entries[i].dtbclk_mhz = def_max.dtbclk_mhz;\n\t}\n\tASSERT(bw_params->clk_table.entries[i-1].dcfclk_mhz);\n\tbw_params->vram_type = bios_info->memory_type;\n\n\tbw_params->dram_channel_width_bytes = bios_info->memory_type == 0x22 ? 8 : 4;\n\tbw_params->num_channels = bios_info->ma_channel_number ? bios_info->ma_channel_number : 4;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\tbw_params->wm_table.entries[i].wm_inst = i;\n\n\t\tif (i >= bw_params->clk_table.num_entries) {\n\t\t\tbw_params->wm_table.entries[i].valid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbw_params->wm_table.entries[i].wm_type = WM_TYPE_PSTATE_CHG;\n\t\tbw_params->wm_table.entries[i].valid = true;\n\t}\n}\n\nstatic struct clk_mgr_funcs dcn314_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.get_dtb_ref_clk_frequency = dcn31_get_dtb_ref_freq_khz,\n\t.update_clocks = dcn314_update_clocks,\n\t.init_clocks = dcn31_init_clocks,\n\t.enable_pme_wa = dcn314_enable_pme_wa,\n\t.are_clock_states_equal = dcn314_are_clock_states_equal,\n\t.notify_wm_ranges = dcn314_notify_wm_ranges\n};\nextern struct clk_mgr_funcs dcn3_fpga_funcs;\n\nvoid dcn314_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_dcn314 *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct dcn314_smu_dpm_clks smu_dpm_clks = { 0 };\n\tstruct clk_log_info log_info = {0};\n\n\tclk_mgr->base.base.ctx = ctx;\n\tclk_mgr->base.base.funcs = &dcn314_funcs;\n\n\tclk_mgr->base.pp_smu = pp_smu;\n\n\tclk_mgr->base.dccg = dccg;\n\tclk_mgr->base.dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->base.dprefclk_ss_percentage = 0;\n\tclk_mgr->base.dprefclk_ss_divider = 1000;\n\tclk_mgr->base.ss_on_dprefclk = false;\n\tclk_mgr->base.dfs_ref_freq_khz = 48000;\n\n\tclk_mgr->smu_wm_set.wm_set = (struct dcn314_watermarks *)dm_helpers_allocate_gpu_mem(\n\t\t\t\tclk_mgr->base.base.ctx,\n\t\t\t\tDC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsizeof(struct dcn314_watermarks),\n\t\t\t\t&clk_mgr->smu_wm_set.mc_address.quad_part);\n\n\tif (!clk_mgr->smu_wm_set.wm_set) {\n\t\tclk_mgr->smu_wm_set.wm_set = &dummy_wms;\n\t\tclk_mgr->smu_wm_set.mc_address.quad_part = 0;\n\t}\n\tASSERT(clk_mgr->smu_wm_set.wm_set);\n\n\tsmu_dpm_clks.dpm_clks = (DpmClocks314_t *)dm_helpers_allocate_gpu_mem(\n\t\t\t\tclk_mgr->base.base.ctx,\n\t\t\t\tDC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsizeof(DpmClocks314_t),\n\t\t\t\t&smu_dpm_clks.mc_address.quad_part);\n\n\tif (smu_dpm_clks.dpm_clks == NULL) {\n\t\tsmu_dpm_clks.dpm_clks = &dummy_clocks;\n\t\tsmu_dpm_clks.mc_address.quad_part = 0;\n\t}\n\n\tASSERT(smu_dpm_clks.dpm_clks);\n\n\tclk_mgr->base.smu_ver = dcn314_smu_get_smu_version(&clk_mgr->base);\n\n\tif (clk_mgr->base.smu_ver)\n\t\tclk_mgr->base.smu_present = true;\n\n\t \n\tclk_mgr->base.base.dentist_vco_freq_khz = get_vco_frequency_from_reg(&clk_mgr->base);\n\n\tif (ctx->dc_bios->integrated_info->memory_type == LpDdr5MemType)\n\t\tdcn314_bw_params.wm_table = lpddr5_wm_table;\n\telse\n\t\tdcn314_bw_params.wm_table = ddr5_wm_table;\n\n\t \n\tdcn314_dump_clk_registers(&clk_mgr->base.base.boot_snapshot,\n\t\t\t\t  &clk_mgr->base.base, &log_info);\n\n\tclk_mgr->base.base.dprefclk_khz = 600000;\n\tclk_mgr->base.base.clks.ref_dtbclk_khz = 600000;\n\tdce_clock_read_ss_info(&clk_mgr->base);\n\t \n\n\tclk_mgr->base.base.bw_params = &dcn314_bw_params;\n\n\tif (clk_mgr->base.base.ctx->dc->debug.pstate_enabled) {\n\t\tint i;\n\n\t\tdcn314_get_dpm_table_from_smu(&clk_mgr->base, &smu_dpm_clks);\n\t\tDC_LOG_SMU(\"NumDcfClkLevelsEnabled: %d\\n\"\n\t\t\t\t   \"NumDispClkLevelsEnabled: %d\\n\"\n\t\t\t\t   \"NumSocClkLevelsEnabled: %d\\n\"\n\t\t\t\t   \"VcnClkLevelsEnabled: %d\\n\"\n\t\t\t\t   \"NumDfPst atesEnabled: %d\\n\"\n\t\t\t\t   \"MinGfxClk: %d\\n\"\n\t\t\t\t   \"MaxGfxClk: %d\\n\",\n\t\t\t\t   smu_dpm_clks.dpm_clks->NumDcfClkLevelsEnabled,\n\t\t\t\t   smu_dpm_clks.dpm_clks->NumDispClkLevelsEnabled,\n\t\t\t\t   smu_dpm_clks.dpm_clks->NumSocClkLevelsEnabled,\n\t\t\t\t   smu_dpm_clks.dpm_clks->VcnClkLevelsEnabled,\n\t\t\t\t   smu_dpm_clks.dpm_clks->NumDfPstatesEnabled,\n\t\t\t\t   smu_dpm_clks.dpm_clks->MinGfxClk,\n\t\t\t\t   smu_dpm_clks.dpm_clks->MaxGfxClk);\n\t\tfor (i = 0; i < smu_dpm_clks.dpm_clks->NumDcfClkLevelsEnabled; i++) {\n\t\t\tDC_LOG_SMU(\"smu_dpm_clks.dpm_clks->DcfClocks[%d] = %d\\n\",\n\t\t\t\t\t   i,\n\t\t\t\t\t   smu_dpm_clks.dpm_clks->DcfClocks[i]);\n\t\t}\n\t\tfor (i = 0; i < smu_dpm_clks.dpm_clks->NumDispClkLevelsEnabled; i++) {\n\t\t\tDC_LOG_SMU(\"smu_dpm_clks.dpm_clks->DispClocks[%d] = %d\\n\",\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->DispClocks[i]);\n\t\t}\n\t\tfor (i = 0; i < smu_dpm_clks.dpm_clks->NumSocClkLevelsEnabled; i++) {\n\t\t\tDC_LOG_SMU(\"smu_dpm_clks.dpm_clks->SocClocks[%d] = %d\\n\",\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->SocClocks[i]);\n\t\t}\n\t\tfor (i = 0; i < NUM_SOC_VOLTAGE_LEVELS; i++)\n\t\t\tDC_LOG_SMU(\"smu_dpm_clks.dpm_clks->SocVoltage[%d] = %d\\n\",\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->SocVoltage[i]);\n\n\t\tfor (i = 0; i < NUM_DF_PSTATE_LEVELS; i++) {\n\t\t\tDC_LOG_SMU(\"smu_dpm_clks.dpm_clks.DfPstateTable[%d].FClk = %d\\n\"\n\t\t\t\t\t   \"smu_dpm_clks.dpm_clks->DfPstateTable[%d].MemClk= %d\\n\"\n\t\t\t\t\t   \"smu_dpm_clks.dpm_clks->DfPstateTable[%d].Voltage = %d\\n\",\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->DfPstateTable[i].FClk,\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->DfPstateTable[i].MemClk,\n\t\t\t\t\t   i, smu_dpm_clks.dpm_clks->DfPstateTable[i].Voltage);\n\t\t}\n\n\t\tif (ctx->dc_bios && ctx->dc_bios->integrated_info && ctx->dc->config.use_default_clock_table == false) {\n\t\t\tdcn314_clk_mgr_helper_populate_bw_params(\n\t\t\t\t\t&clk_mgr->base,\n\t\t\t\t\tctx->dc_bios->integrated_info,\n\t\t\t\t\tsmu_dpm_clks.dpm_clks);\n\t\t}\n\t}\n\n\tif (smu_dpm_clks.dpm_clks && smu_dpm_clks.mc_address.quad_part != 0)\n\t\tdm_helpers_free_gpu_mem(clk_mgr->base.base.ctx, DC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsmu_dpm_clks.dpm_clks);\n}\n\nvoid dcn314_clk_mgr_destroy(struct clk_mgr_internal *clk_mgr_int)\n{\n\tstruct clk_mgr_dcn314 *clk_mgr = TO_CLK_MGR_DCN314(clk_mgr_int);\n\n\tif (clk_mgr->smu_wm_set.wm_set && clk_mgr->smu_wm_set.mc_address.quad_part != 0)\n\t\tdm_helpers_free_gpu_mem(clk_mgr_int->base.ctx, DC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tclk_mgr->smu_wm_set.wm_set);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}