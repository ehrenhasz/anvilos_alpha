{
  "module_name": "dce60_clk_mgr.c",
  "hash_id": "bc5b8820351d9657da2a26dea9f2c2a7201f775a2c7f4f67660551fe1793e096",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dce60/dce60_clk_mgr.c",
  "human_readable_source": " \n\n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n#include \"dce100/dce_clk_mgr.h\"\n#include \"dce110/dce110_clk_mgr.h\"\n#include \"dce60_clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"dmcu.h\"\n#include \"core_types.h\"\n#include \"dal_asic_id.h\"\n\n \n#include \"dce/dce_6_0_d.h\"\n#include \"dce/dce_6_0_sh_mask.h\"\n\n#define REG(reg) \\\n\t(clk_mgr->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tclk_mgr->clk_mgr_shift->field_name, clk_mgr->clk_mgr_mask->field_name\n\n \n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\nstatic const struct clk_mgr_registers disp_clk_regs = {\n\t\tCLK_COMMON_REG_LIST_DCE60_BASE()\n};\n\nstatic const struct clk_mgr_shift disp_clk_shift = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE60_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask disp_clk_mask = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE60_COMMON_BASE(_MASK)\n};\n\n\n \nstatic const struct state_dependent_clocks dce60_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000},\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 600000, .pixel_clk_khz = 400000 } };\n\nstatic int dce60_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tint dprefclk_wdivider;\n\tint dp_ref_clk_khz;\n\tint target_div;\n\n\t \n\n\t \n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DPREFCLK_WDIVIDER, &dprefclk_wdivider);\n\n\t \n\ttarget_div = dentist_get_divider_from_did(dprefclk_wdivider);\n\n\t \n\tdp_ref_clk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR\n\t\t* clk_mgr->base.dentist_vco_freq_khz) / target_div;\n\n\treturn dce_adjust_dp_ref_freq_for_ss(clk_mgr, dp_ref_clk_khz);\n}\n\nstatic void dce60_pplib_apply_display_requirements(\n\tstruct dc *dc,\n\tstruct dc_state *context)\n{\n\tstruct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;\n\n\tpp_display_cfg->avail_mclk_switch_time_us = dce110_get_min_vblank_time_us(context);\n\n\tdce110_fill_display_configs(context, pp_display_cfg);\n\n\tif (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)\n\t\tdm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);\n}\n\nstatic void dce60_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr_base, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr_base->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr_base->clks.dispclk_khz)) {\n\t\tpatched_disp_clk = dce_set_clock(clk_mgr_base, patched_disp_clk);\n\t\tclk_mgr_base->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce60_pplib_apply_display_requirements(clk_mgr_base->ctx->dc, context);\n}\n\n\n\n\n\n\n\n\nstatic struct clk_mgr_funcs dce60_funcs = {\n\t.get_dp_ref_clk_frequency = dce60_get_dp_ref_freq_khz,\n\t.update_clocks = dce60_update_clocks\n};\n\nvoid dce60_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr)\n{\n\tdce_clk_mgr_construct(ctx, clk_mgr);\n\n\tmemcpy(clk_mgr->max_clks_by_state,\n\t\tdce60_max_clks_by_state,\n\t\tsizeof(dce60_max_clks_by_state));\n\n\tclk_mgr->regs = &disp_clk_regs;\n\tclk_mgr->clk_mgr_shift = &disp_clk_shift;\n\tclk_mgr->clk_mgr_mask = &disp_clk_mask;\n\tclk_mgr->base.funcs = &dce60_funcs;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}