{
  "module_name": "link_factory.c",
  "hash_id": "6d83744cdf4315fa6ada50af4e34309a752588eb2e10fe23a2d8a4b9f96912b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/link_factory.c",
  "human_readable_source": " \n\n \n#include \"link_factory.h\"\n#include \"link_detection.h\"\n#include \"link_resource.h\"\n#include \"link_validation.h\"\n#include \"link_dpms.h\"\n#include \"accessories/link_dp_cts.h\"\n#include \"accessories/link_dp_trace.h\"\n#include \"accessories/link_fpga.h\"\n#include \"protocols/link_ddc.h\"\n#include \"protocols/link_dp_capability.h\"\n#include \"protocols/link_dp_dpia_bw.h\"\n#include \"protocols/link_dp_dpia.h\"\n#include \"protocols/link_dp_irq_handler.h\"\n#include \"protocols/link_dp_phy.h\"\n#include \"protocols/link_dp_training.h\"\n#include \"protocols/link_edp_panel_control.h\"\n#include \"protocols/link_hpd.h\"\n#include \"gpio_service_interface.h\"\n#include \"atomfirmware.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define LINK_INFO(...) \\\n\tDC_LOG_HW_HOTPLUG(  \\\n\t\t__VA_ARGS__)\n\n \nstatic void construct_link_service_factory(struct link_service *link_srv)\n{\n\n\tlink_srv->create_link = link_create;\n\tlink_srv->destroy_link = link_destroy;\n}\n\n \nstatic void construct_link_service_detection(struct link_service *link_srv)\n{\n\tlink_srv->detect_link = link_detect;\n\tlink_srv->detect_connection_type = link_detect_connection_type;\n\tlink_srv->add_remote_sink = link_add_remote_sink;\n\tlink_srv->remove_remote_sink = link_remove_remote_sink;\n\tlink_srv->get_hpd_state = link_get_hpd_state;\n\tlink_srv->get_hpd_gpio = link_get_hpd_gpio;\n\tlink_srv->enable_hpd = link_enable_hpd;\n\tlink_srv->disable_hpd = link_disable_hpd;\n\tlink_srv->enable_hpd_filter = link_enable_hpd_filter;\n\tlink_srv->reset_cur_dp_mst_topology = link_reset_cur_dp_mst_topology;\n\tlink_srv->get_status = link_get_status;\n\tlink_srv->is_hdcp1x_supported = link_is_hdcp14;\n\tlink_srv->is_hdcp2x_supported = link_is_hdcp22;\n\tlink_srv->clear_dprx_states = link_clear_dprx_states;\n}\n\n \nstatic void construct_link_service_resource(struct link_service *link_srv)\n{\n\tlink_srv->get_cur_res_map = link_get_cur_res_map;\n\tlink_srv->restore_res_map = link_restore_res_map;\n\tlink_srv->get_cur_link_res = link_get_cur_link_res;\n}\n\n \nstatic void construct_link_service_validation(struct link_service *link_srv)\n{\n\tlink_srv->validate_mode_timing = link_validate_mode_timing;\n\tlink_srv->dp_link_bandwidth_kbps = dp_link_bandwidth_kbps;\n\tlink_srv->validate_dpia_bandwidth = link_validate_dpia_bandwidth;\n}\n\n \nstatic void construct_link_service_dpms(struct link_service *link_srv)\n{\n\tlink_srv->set_dpms_on = link_set_dpms_on;\n\tlink_srv->set_dpms_off = link_set_dpms_off;\n\tlink_srv->resume = link_resume;\n\tlink_srv->blank_all_dp_displays = link_blank_all_dp_displays;\n\tlink_srv->blank_all_edp_displays = link_blank_all_edp_displays;\n\tlink_srv->blank_dp_stream = link_blank_dp_stream;\n\tlink_srv->increase_mst_payload = link_increase_mst_payload;\n\tlink_srv->reduce_mst_payload = link_reduce_mst_payload;\n\tlink_srv->set_dsc_on_stream = link_set_dsc_on_stream;\n\tlink_srv->set_dsc_enable = link_set_dsc_enable;\n\tlink_srv->update_dsc_config = link_update_dsc_config;\n}\n\n \nstatic void construct_link_service_ddc(struct link_service *link_srv)\n{\n\tlink_srv->create_ddc_service = link_create_ddc_service;\n\tlink_srv->destroy_ddc_service = link_destroy_ddc_service;\n\tlink_srv->query_ddc_data = link_query_ddc_data;\n\tlink_srv->aux_transfer_raw = link_aux_transfer_raw;\n\tlink_srv->configure_fixed_vs_pe_retimer = link_configure_fixed_vs_pe_retimer;\n\tlink_srv->aux_transfer_with_retries_no_mutex =\n\t\t\tlink_aux_transfer_with_retries_no_mutex;\n\tlink_srv->is_in_aux_transaction_mode = link_is_in_aux_transaction_mode;\n\tlink_srv->get_aux_defer_delay = link_get_aux_defer_delay;\n}\n\n \nstatic void construct_link_service_dp_capability(struct link_service *link_srv)\n{\n\tlink_srv->dp_is_sink_present = dp_is_sink_present;\n\tlink_srv->dp_is_fec_supported = dp_is_fec_supported;\n\tlink_srv->dp_is_128b_132b_signal = dp_is_128b_132b_signal;\n\tlink_srv->dp_get_max_link_enc_cap = dp_get_max_link_enc_cap;\n\tlink_srv->dp_get_verified_link_cap = dp_get_verified_link_cap;\n\tlink_srv->dp_get_encoding_format = link_dp_get_encoding_format;\n\tlink_srv->dp_should_enable_fec = dp_should_enable_fec;\n\tlink_srv->dp_decide_link_settings = link_decide_link_settings;\n\tlink_srv->mst_decide_link_encoding_format =\n\t\t\tmst_decide_link_encoding_format;\n\tlink_srv->edp_decide_link_settings = edp_decide_link_settings;\n\tlink_srv->bw_kbps_from_raw_frl_link_rate_data =\n\t\t\tlink_bw_kbps_from_raw_frl_link_rate_data;\n\tlink_srv->dp_overwrite_extended_receiver_cap =\n\t\t\tdp_overwrite_extended_receiver_cap;\n\tlink_srv->dp_decide_lttpr_mode = dp_decide_lttpr_mode;\n}\n\n \nstatic void construct_link_service_dp_phy_or_dpia(struct link_service *link_srv)\n{\n\tlink_srv->dpia_handle_usb4_bandwidth_allocation_for_link =\n\t\t\tdpia_handle_usb4_bandwidth_allocation_for_link;\n\tlink_srv->dpia_handle_bw_alloc_response = dpia_handle_bw_alloc_response;\n\tlink_srv->dp_set_drive_settings = dp_set_drive_settings;\n\tlink_srv->dpcd_write_rx_power_ctrl = dpcd_write_rx_power_ctrl;\n}\n\n \nstatic void construct_link_service_dp_irq_handler(struct link_service *link_srv)\n{\n\tlink_srv->dp_parse_link_loss_status = dp_parse_link_loss_status;\n\tlink_srv->dp_should_allow_hpd_rx_irq = dp_should_allow_hpd_rx_irq;\n\tlink_srv->dp_handle_link_loss = dp_handle_link_loss;\n\tlink_srv->dp_read_hpd_rx_irq_data = dp_read_hpd_rx_irq_data;\n\tlink_srv->dp_handle_hpd_rx_irq = dp_handle_hpd_rx_irq;\n}\n\n \nstatic void construct_link_service_edp_panel_control(struct link_service *link_srv)\n{\n\tlink_srv->edp_panel_backlight_power_on = edp_panel_backlight_power_on;\n\tlink_srv->edp_get_backlight_level = edp_get_backlight_level;\n\tlink_srv->edp_get_backlight_level_nits = edp_get_backlight_level_nits;\n\tlink_srv->edp_set_backlight_level = edp_set_backlight_level;\n\tlink_srv->edp_set_backlight_level_nits = edp_set_backlight_level_nits;\n\tlink_srv->edp_get_target_backlight_pwm = edp_get_target_backlight_pwm;\n\tlink_srv->edp_get_psr_state = edp_get_psr_state;\n\tlink_srv->edp_set_psr_allow_active = edp_set_psr_allow_active;\n\tlink_srv->edp_setup_psr = edp_setup_psr;\n\tlink_srv->edp_set_sink_vtotal_in_psr_active =\n\t\t\tedp_set_sink_vtotal_in_psr_active;\n\tlink_srv->edp_get_psr_residency = edp_get_psr_residency;\n\n\tlink_srv->edp_get_replay_state = edp_get_replay_state;\n\tlink_srv->edp_set_replay_allow_active = edp_set_replay_allow_active;\n\tlink_srv->edp_setup_replay = edp_setup_replay;\n\tlink_srv->edp_set_coasting_vtotal = edp_set_coasting_vtotal;\n\tlink_srv->edp_replay_residency = edp_replay_residency;\n\n\tlink_srv->edp_wait_for_t12 = edp_wait_for_t12;\n\tlink_srv->edp_is_ilr_optimization_required =\n\t\t\tedp_is_ilr_optimization_required;\n\tlink_srv->edp_backlight_enable_aux = edp_backlight_enable_aux;\n\tlink_srv->edp_add_delay_for_T9 = edp_add_delay_for_T9;\n\tlink_srv->edp_receiver_ready_T9 = edp_receiver_ready_T9;\n\tlink_srv->edp_receiver_ready_T7 = edp_receiver_ready_T7;\n\tlink_srv->edp_power_alpm_dpcd_enable = edp_power_alpm_dpcd_enable;\n\tlink_srv->edp_set_panel_power = edp_set_panel_power;\n}\n\n \nstatic void construct_link_service_dp_cts(struct link_service *link_srv)\n{\n\tlink_srv->dp_handle_automated_test = dp_handle_automated_test;\n\tlink_srv->dp_set_test_pattern = dp_set_test_pattern;\n\tlink_srv->dp_set_preferred_link_settings =\n\t\t\tdp_set_preferred_link_settings;\n\tlink_srv->dp_set_preferred_training_settings =\n\t\t\tdp_set_preferred_training_settings;\n}\n\n \nstatic void construct_link_service_dp_trace(struct link_service *link_srv)\n{\n\tlink_srv->dp_trace_is_initialized = dp_trace_is_initialized;\n\tlink_srv->dp_trace_set_is_logged_flag = dp_trace_set_is_logged_flag;\n\tlink_srv->dp_trace_is_logged = dp_trace_is_logged;\n\tlink_srv->dp_trace_get_lt_end_timestamp = dp_trace_get_lt_end_timestamp;\n\tlink_srv->dp_trace_get_lt_counts = dp_trace_get_lt_counts;\n\tlink_srv->dp_trace_get_link_loss_count = dp_trace_get_link_loss_count;\n\tlink_srv->dp_trace_set_edp_power_timestamp =\n\t\t\tdp_trace_set_edp_power_timestamp;\n\tlink_srv->dp_trace_get_edp_poweron_timestamp =\n\t\t\tdp_trace_get_edp_poweron_timestamp;\n\tlink_srv->dp_trace_get_edp_poweroff_timestamp =\n\t\t\tdp_trace_get_edp_poweroff_timestamp;\n\tlink_srv->dp_trace_source_sequence = dp_trace_source_sequence;\n}\n\nstatic void construct_link_service(struct link_service *link_srv)\n{\n\t \n\tconstruct_link_service_factory(link_srv);\n\tconstruct_link_service_detection(link_srv);\n\tconstruct_link_service_resource(link_srv);\n\tconstruct_link_service_validation(link_srv);\n\tconstruct_link_service_dpms(link_srv);\n\tconstruct_link_service_ddc(link_srv);\n\tconstruct_link_service_dp_capability(link_srv);\n\tconstruct_link_service_dp_phy_or_dpia(link_srv);\n\tconstruct_link_service_dp_irq_handler(link_srv);\n\tconstruct_link_service_edp_panel_control(link_srv);\n\tconstruct_link_service_dp_cts(link_srv);\n\tconstruct_link_service_dp_trace(link_srv);\n}\n\nstruct link_service *link_create_link_service(void)\n{\n\tstruct link_service *link_srv = kzalloc(sizeof(*link_srv), GFP_KERNEL);\n\n\tif (link_srv == NULL)\n\t\tgoto fail;\n\n\tconstruct_link_service(link_srv);\n\n\treturn link_srv;\nfail:\n\treturn NULL;\n}\n\nvoid link_destroy_link_service(struct link_service **link_srv)\n{\n\tkfree(*link_srv);\n\t*link_srv = NULL;\n}\n\nstatic enum transmitter translate_encoder_to_transmitter(\n\t\tstruct graphics_object_id encoder)\n{\n\tswitch (encoder.id) {\n\tcase ENCODER_ID_INTERNAL_UNIPHY:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_UNIPHY_A;\n\t\tcase ENUM_ID_2:\n\t\t\treturn TRANSMITTER_UNIPHY_B;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tcase ENCODER_ID_INTERNAL_UNIPHY1:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_UNIPHY_C;\n\t\tcase ENUM_ID_2:\n\t\t\treturn TRANSMITTER_UNIPHY_D;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tcase ENCODER_ID_INTERNAL_UNIPHY2:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_UNIPHY_E;\n\t\tcase ENUM_ID_2:\n\t\t\treturn TRANSMITTER_UNIPHY_F;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tcase ENCODER_ID_INTERNAL_UNIPHY3:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_UNIPHY_G;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tcase ENCODER_ID_EXTERNAL_NUTMEG:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_NUTMEG_CRT;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tcase ENCODER_ID_EXTERNAL_TRAVIS:\n\t\tswitch (encoder.enum_id) {\n\t\tcase ENUM_ID_1:\n\t\t\treturn TRANSMITTER_TRAVIS_CRT;\n\t\tcase ENUM_ID_2:\n\t\t\treturn TRANSMITTER_TRAVIS_LCD;\n\t\tdefault:\n\t\t\treturn TRANSMITTER_UNKNOWN;\n\t\t}\n\tbreak;\n\tdefault:\n\t\treturn TRANSMITTER_UNKNOWN;\n\t}\n}\n\nstatic uint8_t translate_dig_inst_to_pwrseq_inst(struct dc_link *link)\n{\n\tuint8_t pwrseq_inst = 0xF;\n\n\tswitch (link->eng_id) {\n\tcase ENGINE_ID_DIGA:\n\t\tpwrseq_inst = 0;\n\t\tbreak;\n\tcase ENGINE_ID_DIGB:\n\t\tpwrseq_inst = 1;\n\t\tbreak;\n\tdefault:\n\t\tDC_LOG_WARNING(\"Unsupported pwrseq engine id: %d!\\n\", link->eng_id);\n\t\tASSERT(false);\n\t\tbreak;\n\t}\n\n\treturn pwrseq_inst;\n}\n\n\nstatic void link_destruct(struct dc_link *link)\n{\n\tint i;\n\n\tif (link->hpd_gpio) {\n\t\tdal_gpio_destroy_irq(&link->hpd_gpio);\n\t\tlink->hpd_gpio = NULL;\n\t}\n\n\tif (link->ddc)\n\t\tlink_destroy_ddc_service(&link->ddc);\n\n\tif (link->panel_cntl)\n\t\tlink->panel_cntl->funcs->destroy(&link->panel_cntl);\n\n\tif (link->link_enc) {\n\t\t \n\t\tif (link->link_id.id != CONNECTOR_ID_VIRTUAL) {\n\t\t\tlink->dc->res_pool->link_encoders[link->eng_id - ENGINE_ID_DIGA] = NULL;\n\t\t\tlink->dc->res_pool->dig_link_enc_count--;\n\t\t}\n\t\tlink->link_enc->funcs->destroy(&link->link_enc);\n\t}\n\n\tif (link->local_sink)\n\t\tdc_sink_release(link->local_sink);\n\n\tfor (i = 0; i < link->sink_count; ++i)\n\t\tdc_sink_release(link->remote_sinks[i]);\n}\n\nstatic enum channel_id get_ddc_line(struct dc_link *link)\n{\n\tstruct ddc *ddc;\n\tenum channel_id channel;\n\n\tchannel = CHANNEL_ID_UNKNOWN;\n\n\tddc = get_ddc_pin(link->ddc);\n\n\tif (ddc) {\n\t\tswitch (dal_ddc_get_line(ddc)) {\n\t\tcase GPIO_DDC_LINE_DDC1:\n\t\t\tchannel = CHANNEL_ID_DDC1;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC2:\n\t\t\tchannel = CHANNEL_ID_DDC2;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC3:\n\t\t\tchannel = CHANNEL_ID_DDC3;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC4:\n\t\t\tchannel = CHANNEL_ID_DDC4;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC5:\n\t\t\tchannel = CHANNEL_ID_DDC5;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC6:\n\t\t\tchannel = CHANNEL_ID_DDC6;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_DDC_VGA:\n\t\t\tchannel = CHANNEL_ID_DDC_VGA;\n\t\t\tbreak;\n\t\tcase GPIO_DDC_LINE_I2C_PAD:\n\t\t\tchannel = CHANNEL_ID_I2C_PAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn channel;\n}\n\nstatic bool construct_phy(struct dc_link *link,\n\t\t\t      const struct link_init_data *init_params)\n{\n\tuint8_t i;\n\tstruct ddc_service_init_data ddc_service_init_data = { 0 };\n\tstruct dc_context *dc_ctx = init_params->ctx;\n\tstruct encoder_init_data enc_init_data = { 0 };\n\tstruct panel_cntl_init_data panel_cntl_init_data = { 0 };\n\tstruct integrated_info info = { 0 };\n\tstruct dc_bios *bios = init_params->dc->ctx->dc_bios;\n\tconst struct dc_vbios_funcs *bp_funcs = bios->funcs;\n\tstruct bp_disp_connector_caps_info disp_connect_caps_info = { 0 };\n\n\tDC_LOGGER_INIT(dc_ctx->logger);\n\n\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\tlink->irq_source_hpd_rx = DC_IRQ_SOURCE_INVALID;\n\tlink->link_status.dpcd_caps = &link->dpcd_caps;\n\n\tlink->dc = init_params->dc;\n\tlink->ctx = dc_ctx;\n\tlink->link_index = init_params->link_index;\n\n\tmemset(&link->preferred_training_settings, 0,\n\t       sizeof(struct dc_link_training_overrides));\n\tmemset(&link->preferred_link_setting, 0,\n\t       sizeof(struct dc_link_settings));\n\n\tlink->link_id =\n\t\tbios->funcs->get_connector_id(bios, init_params->connector_index);\n\n\tlink->ep_type = DISPLAY_ENDPOINT_PHY;\n\n\tDC_LOG_DC(\"BIOS object table - link_id: %d\", link->link_id.id);\n\n\tif (bios->funcs->get_disp_connector_caps_info) {\n\t\tbios->funcs->get_disp_connector_caps_info(bios, link->link_id, &disp_connect_caps_info);\n\t\tlink->is_internal_display = disp_connect_caps_info.INTERNAL_DISPLAY;\n\t\tDC_LOG_DC(\"BIOS object table - is_internal_display: %d\", link->is_internal_display);\n\t}\n\n\tif (link->link_id.type != OBJECT_TYPE_CONNECTOR) {\n\t\tdm_output_to_console(\"%s: Invalid Connector ObjectID from Adapter Service for connector index:%d! type %d expected %d\\n\",\n\t\t\t\t     __func__, init_params->connector_index,\n\t\t\t\t     link->link_id.type, OBJECT_TYPE_CONNECTOR);\n\t\tgoto create_fail;\n\t}\n\n\tif (link->dc->res_pool->funcs->link_init)\n\t\tlink->dc->res_pool->funcs->link_init(link);\n\n\tlink->hpd_gpio = link_get_hpd_gpio(link->ctx->dc_bios, link->link_id,\n\t\t\t\t      link->ctx->gpio_service);\n\n\tif (link->hpd_gpio) {\n\t\tdal_gpio_open(link->hpd_gpio, GPIO_MODE_INTERRUPT);\n\t\tdal_gpio_unlock_pin(link->hpd_gpio);\n\t\tlink->irq_source_hpd = dal_irq_get_source(link->hpd_gpio);\n\n\t\tDC_LOG_DC(\"BIOS object table - hpd_gpio id: %d\", link->hpd_gpio->id);\n\t\tDC_LOG_DC(\"BIOS object table - hpd_gpio en: %d\", link->hpd_gpio->en);\n\t}\n\n\tswitch (link->link_id.id) {\n\tcase CONNECTOR_ID_HDMI_TYPE_A:\n\t\tlink->connector_signal = SIGNAL_TYPE_HDMI_TYPE_A;\n\n\t\tbreak;\n\tcase CONNECTOR_ID_SINGLE_LINK_DVID:\n\tcase CONNECTOR_ID_SINGLE_LINK_DVII:\n\t\tlink->connector_signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tbreak;\n\tcase CONNECTOR_ID_DUAL_LINK_DVID:\n\tcase CONNECTOR_ID_DUAL_LINK_DVII:\n\t\tlink->connector_signal = SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\tbreak;\n\tcase CONNECTOR_ID_DISPLAY_PORT:\n\tcase CONNECTOR_ID_USBC:\n\t\tlink->connector_signal = SIGNAL_TYPE_DISPLAY_PORT;\n\n\t\tif (link->hpd_gpio)\n\t\t\tlink->irq_source_hpd_rx =\n\t\t\t\t\tdal_irq_get_rx_source(link->hpd_gpio);\n\n\t\tbreak;\n\tcase CONNECTOR_ID_EDP:\n\t\tlink->connector_signal = SIGNAL_TYPE_EDP;\n\n\t\tif (link->hpd_gpio) {\n\t\t\tif (!link->dc->config.allow_edp_hotplug_detection)\n\t\t\t\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\n\t\t\tswitch (link->dc->config.allow_edp_hotplug_detection) {\n\t\t\tcase HPD_EN_FOR_ALL_EDP:\n\t\t\t\tlink->irq_source_hpd_rx =\n\t\t\t\t\t\tdal_irq_get_rx_source(link->hpd_gpio);\n\t\t\t\tbreak;\n\t\t\tcase HPD_EN_FOR_PRIMARY_EDP_ONLY:\n\t\t\t\tif (link->link_index == 0)\n\t\t\t\t\tlink->irq_source_hpd_rx =\n\t\t\t\t\t\tdal_irq_get_rx_source(link->hpd_gpio);\n\t\t\t\telse\n\t\t\t\t\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\t\t\t\tbreak;\n\t\t\tcase HPD_EN_FOR_SECONDARY_EDP_ONLY:\n\t\t\t\tif (link->link_index == 1)\n\t\t\t\t\tlink->irq_source_hpd_rx =\n\t\t\t\t\t\tdal_irq_get_rx_source(link->hpd_gpio);\n\t\t\t\telse\n\t\t\t\t\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase CONNECTOR_ID_LVDS:\n\t\tlink->connector_signal = SIGNAL_TYPE_LVDS;\n\t\tbreak;\n\tdefault:\n\t\tDC_LOG_WARNING(\"Unsupported Connector type:%d!\\n\",\n\t\t\t       link->link_id.id);\n\t\tgoto create_fail;\n\t}\n\n\tLINK_INFO(\"Connector[%d] description: signal: %s\\n\",\n\t\t  init_params->connector_index,\n\t\t  signal_type_to_string(link->connector_signal));\n\n\tddc_service_init_data.ctx = link->ctx;\n\tddc_service_init_data.id = link->link_id;\n\tddc_service_init_data.link = link;\n\tlink->ddc = link_create_ddc_service(&ddc_service_init_data);\n\n\tif (!link->ddc) {\n\t\tDC_ERROR(\"Failed to create ddc_service!\\n\");\n\t\tgoto ddc_create_fail;\n\t}\n\n\tif (!link->ddc->ddc_pin) {\n\t\tDC_ERROR(\"Failed to get I2C info for connector!\\n\");\n\t\tgoto ddc_create_fail;\n\t}\n\n\tlink->ddc_hw_inst =\n\t\tdal_ddc_get_line(get_ddc_pin(link->ddc));\n\n\tenc_init_data.ctx = dc_ctx;\n\tbp_funcs->get_src_obj(dc_ctx->dc_bios, link->link_id, 0,\n\t\t\t      &enc_init_data.encoder);\n\tenc_init_data.connector = link->link_id;\n\tenc_init_data.channel = get_ddc_line(link);\n\tenc_init_data.hpd_source = get_hpd_line(link);\n\n\tlink->hpd_src = enc_init_data.hpd_source;\n\n\tenc_init_data.transmitter =\n\t\ttranslate_encoder_to_transmitter(enc_init_data.encoder);\n\tlink->link_enc =\n\t\tlink->dc->res_pool->funcs->link_enc_create(dc_ctx, &enc_init_data);\n\n\tDC_LOG_DC(\"BIOS object table - DP_IS_USB_C: %d\", link->link_enc->features.flags.bits.DP_IS_USB_C);\n\tDC_LOG_DC(\"BIOS object table - IS_DP2_CAPABLE: %d\", link->link_enc->features.flags.bits.IS_DP2_CAPABLE);\n\n\tif (!link->link_enc) {\n\t\tDC_ERROR(\"Failed to create link encoder!\\n\");\n\t\tgoto link_enc_create_fail;\n\t}\n\n\t \n\tlink->eng_id = link->link_enc->preferred_engine;\n\tlink->dc->res_pool->link_encoders[link->eng_id - ENGINE_ID_DIGA] = link->link_enc;\n\tlink->dc->res_pool->dig_link_enc_count++;\n\n\tlink->link_enc_hw_inst = link->link_enc->transmitter;\n\n\tif (link->dc->res_pool->funcs->panel_cntl_create &&\n\t\t(link->link_id.id == CONNECTOR_ID_EDP ||\n\t\t\tlink->link_id.id == CONNECTOR_ID_LVDS)) {\n\t\tpanel_cntl_init_data.ctx = dc_ctx;\n\t\tpanel_cntl_init_data.inst = panel_cntl_init_data.ctx->dc_edp_id_count;\n\t\tpanel_cntl_init_data.pwrseq_inst = translate_dig_inst_to_pwrseq_inst(link);\n\t\tlink->panel_cntl =\n\t\t\tlink->dc->res_pool->funcs->panel_cntl_create(\n\t\t\t\t\t\t\t\t&panel_cntl_init_data);\n\t\tpanel_cntl_init_data.ctx->dc_edp_id_count++;\n\n\t\tif (link->panel_cntl == NULL) {\n\t\t\tDC_ERROR(\"Failed to create link panel_cntl!\\n\");\n\t\t\tgoto panel_cntl_create_fail;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tif (bp_funcs->get_device_tag(dc_ctx->dc_bios,\n\t\t\t\t\t     link->link_id, i,\n\t\t\t\t\t     &link->device_tag) != BP_RESULT_OK) {\n\t\t\tDC_ERROR(\"Failed to find device tag!\\n\");\n\t\t\tgoto device_tag_fail;\n\t\t}\n\n\t\t \n\t\tif (!bp_funcs->is_device_id_supported(dc_ctx->dc_bios,\n\t\t\t\t\t\t      link->device_tag.dev_id))\n\t\t\tcontinue;\n\t\tif (link->device_tag.dev_id.device_type == DEVICE_TYPE_CRT &&\n\t\t    link->connector_signal != SIGNAL_TYPE_RGB)\n\t\t\tcontinue;\n\t\tif (link->device_tag.dev_id.device_type == DEVICE_TYPE_LCD &&\n\t\t    link->connector_signal == SIGNAL_TYPE_RGB)\n\t\t\tcontinue;\n\n\t\tDC_LOG_DC(\"BIOS object table - device_tag.acpi_device: %d\", link->device_tag.acpi_device);\n\t\tDC_LOG_DC(\"BIOS object table - device_tag.dev_id.device_type: %d\", link->device_tag.dev_id.device_type);\n\t\tDC_LOG_DC(\"BIOS object table - device_tag.dev_id.enum_id: %d\", link->device_tag.dev_id.enum_id);\n\t\tbreak;\n\t}\n\n\tif (bios->integrated_info)\n\t\tinfo = *bios->integrated_info;\n\n\t \n\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; i++) {\n\t\tstruct external_display_path *path =\n\t\t\t&info.ext_disp_conn_info.path[i];\n\n\t\tif (path->device_connector_id.enum_id == link->link_id.enum_id &&\n\t\t    path->device_connector_id.id == link->link_id.id &&\n\t\t    path->device_connector_id.type == link->link_id.type) {\n\t\t\tif (link->device_tag.acpi_device != 0 &&\n\t\t\t    path->device_acpi_enum == link->device_tag.acpi_device) {\n\t\t\t\tlink->ddi_channel_mapping = path->channel_mapping;\n\t\t\t\tlink->chip_caps = path->caps;\n\t\t\t\tDC_LOG_DC(\"BIOS object table - ddi_channel_mapping: 0x%04X\", link->ddi_channel_mapping.raw);\n\t\t\t\tDC_LOG_DC(\"BIOS object table - chip_caps: %d\", link->chip_caps);\n\t\t\t} else if (path->device_tag ==\n\t\t\t\t   link->device_tag.dev_id.raw_device_tag) {\n\t\t\t\tlink->ddi_channel_mapping = path->channel_mapping;\n\t\t\t\tlink->chip_caps = path->caps;\n\t\t\t\tDC_LOG_DC(\"BIOS object table - ddi_channel_mapping: 0x%04X\", link->ddi_channel_mapping.raw);\n\t\t\t\tDC_LOG_DC(\"BIOS object table - chip_caps: %d\", link->chip_caps);\n\t\t\t}\n\n\t\t\tif (link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) {\n\t\t\t\tlink->bios_forced_drive_settings.VOLTAGE_SWING =\n\t\t\t\t\t\t(info.ext_disp_conn_info.fixdpvoltageswing & 0x3);\n\t\t\t\tlink->bios_forced_drive_settings.PRE_EMPHASIS =\n\t\t\t\t\t\t((info.ext_disp_conn_info.fixdpvoltageswing >> 2) & 0x3);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bios->funcs->get_atom_dc_golden_table)\n\t\tbios->funcs->get_atom_dc_golden_table(bios);\n\n\t \n\tprogram_hpd_filter(link);\n\n\tlink->psr_settings.psr_vtotal_control_support = false;\n\tlink->psr_settings.psr_version = DC_PSR_VERSION_UNSUPPORTED;\n\n\tDC_LOG_DC(\"BIOS object table - %s finished successfully.\\n\", __func__);\n\treturn true;\ndevice_tag_fail:\n\tlink->link_enc->funcs->destroy(&link->link_enc);\nlink_enc_create_fail:\n\tif (link->panel_cntl != NULL)\n\t\tlink->panel_cntl->funcs->destroy(&link->panel_cntl);\npanel_cntl_create_fail:\n\tlink_destroy_ddc_service(&link->ddc);\nddc_create_fail:\ncreate_fail:\n\n\tif (link->hpd_gpio) {\n\t\tdal_gpio_destroy_irq(&link->hpd_gpio);\n\t\tlink->hpd_gpio = NULL;\n\t}\n\n\tDC_LOG_DC(\"BIOS object table - %s failed.\\n\", __func__);\n\treturn false;\n}\n\nstatic bool construct_dpia(struct dc_link *link,\n\t\t\t      const struct link_init_data *init_params)\n{\n\tstruct ddc_service_init_data ddc_service_init_data = { 0 };\n\tstruct dc_context *dc_ctx = init_params->ctx;\n\n\tDC_LOGGER_INIT(dc_ctx->logger);\n\n\t \n\tlink->irq_source_hpd = DC_IRQ_SOURCE_INVALID;\n\tlink->irq_source_hpd_rx = DC_IRQ_SOURCE_INVALID;\n\tlink->link_status.dpcd_caps = &link->dpcd_caps;\n\n\tlink->dc = init_params->dc;\n\tlink->ctx = dc_ctx;\n\tlink->link_index = init_params->link_index;\n\n\tmemset(&link->preferred_training_settings, 0,\n\t       sizeof(struct dc_link_training_overrides));\n\tmemset(&link->preferred_link_setting, 0,\n\t       sizeof(struct dc_link_settings));\n\n\t \n\tlink->link_id.type = OBJECT_TYPE_CONNECTOR;\n\tlink->link_id.id = CONNECTOR_ID_DISPLAY_PORT;\n\tlink->link_id.enum_id = ENUM_ID_1 + init_params->connector_index;\n\tlink->is_internal_display = false;\n\tlink->connector_signal = SIGNAL_TYPE_DISPLAY_PORT;\n\tLINK_INFO(\"Connector[%d] description:signal %d\\n\",\n\t\t  init_params->connector_index,\n\t\t  link->connector_signal);\n\n\tlink->ep_type = DISPLAY_ENDPOINT_USB4_DPIA;\n\tlink->is_dig_mapping_flexible = true;\n\n\t \n\n\tddc_service_init_data.ctx = link->ctx;\n\tddc_service_init_data.id = link->link_id;\n\tddc_service_init_data.link = link;\n\t \n\tddc_service_init_data.is_dpia_link = true;\n\n\tlink->ddc = link_create_ddc_service(&ddc_service_init_data);\n\tif (!link->ddc) {\n\t\tDC_ERROR(\"Failed to create ddc_service!\\n\");\n\t\tgoto ddc_create_fail;\n\t}\n\n\t \n\tlink->ddc_hw_inst = init_params->connector_index;\n\n\t\n\tif (link->dc->res_pool->funcs->get_preferred_eng_id_dpia)\n\t\tlink->dpia_preferred_eng_id = link->dc->res_pool->funcs->get_preferred_eng_id_dpia(link->ddc_hw_inst);\n\n\t \n\n\tlink->psr_settings.psr_version = DC_PSR_VERSION_UNSUPPORTED;\n\n\t \n\tlink->wa_flags.dp_mot_reset_segment = true;\n\n\treturn true;\n\nddc_create_fail:\n\treturn false;\n}\n\nstatic bool link_construct(struct dc_link *link,\n\t\t\t      const struct link_init_data *init_params)\n{\n\t \n\tif (init_params->is_dpia_link == true)\n\t\treturn construct_dpia(link, init_params);\n\telse\n\t\treturn construct_phy(link, init_params);\n}\n\nstruct dc_link *link_create(const struct link_init_data *init_params)\n{\n\tstruct dc_link *link =\n\t\t\tkzalloc(sizeof(*link), GFP_KERNEL);\n\n\tif (NULL == link)\n\t\tgoto alloc_fail;\n\n\tif (false == link_construct(link, init_params))\n\t\tgoto construct_fail;\n\n\treturn link;\n\nconstruct_fail:\n\tkfree(link);\n\nalloc_fail:\n\treturn NULL;\n}\n\nvoid link_destroy(struct dc_link **link)\n{\n\tlink_destruct(*link);\n\tkfree(*link);\n\t*link = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}