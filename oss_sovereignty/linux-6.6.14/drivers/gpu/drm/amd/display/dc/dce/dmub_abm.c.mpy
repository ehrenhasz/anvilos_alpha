{
  "module_name": "dmub_abm.c",
  "hash_id": "519238cd8e84b4e856d29873488b0a4c32e7a2059bd2b9e62b0b7dbec4ef884d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dmub_abm.c",
  "human_readable_source": " \n\n#include \"dmub_abm.h\"\n#include \"dmub_abm_lcd.h\"\n#include \"dc.h\"\n#include \"core_types.h\"\n#include \"dmub_cmd.h\"\n\n#define TO_DMUB_ABM(abm)\\\n\tcontainer_of(abm, struct dce_abm, base)\n\n#define ABM_FEATURE_NO_SUPPORT\t0\n#define ABM_LCD_SUPPORT\t\t\t1\n\nstatic unsigned int abm_feature_support(struct abm *abm, unsigned int panel_inst)\n{\n\tstruct dc_context *dc = abm->ctx;\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\tint i;\n\tint edp_num;\n\tunsigned int ret = ABM_FEATURE_NO_SUPPORT;\n\n\tdc_get_edp_links(dc->dc, edp_links, &edp_num);\n\n\tfor (i = 0; i < edp_num; i++) {\n\t\tif (panel_inst == i)\n\t\t\tbreak;\n\t}\n\n\tif (i < edp_num) {\n\t\tret = ABM_LCD_SUPPORT;\n\t}\n\n\treturn ret;\n}\n\nstatic void dmub_abm_init_ex(struct abm *abm, uint32_t backlight)\n{\n\tdmub_abm_init(abm, backlight);\n}\n\nstatic unsigned int dmub_abm_get_current_backlight_ex(struct abm *abm)\n{\n\treturn dmub_abm_get_current_backlight(abm);\n}\n\nstatic unsigned int dmub_abm_get_target_backlight_ex(struct abm *abm)\n{\n\treturn dmub_abm_get_target_backlight(abm);\n}\n\nstatic bool dmub_abm_set_level_ex(struct abm *abm, uint32_t level)\n{\n\tbool ret = false;\n\tunsigned int feature_support, i;\n\tuint8_t panel_mask0 = 0;\n\n\tfor (i = 0; i < MAX_NUM_EDP; i++) {\n\t\tfeature_support = abm_feature_support(abm, i);\n\n\t\tif (feature_support == ABM_LCD_SUPPORT)\n\t\t\tpanel_mask0 |= (0x01 << i);\n\t}\n\n\tif (panel_mask0)\n\t\tret = dmub_abm_set_level(abm, level, panel_mask0);\n\n\treturn ret;\n}\n\nstatic bool dmub_abm_init_config_ex(struct abm *abm,\n\tconst char *src,\n\tunsigned int bytes,\n\tunsigned int inst)\n{\n\tunsigned int feature_support;\n\n\tfeature_support = abm_feature_support(abm, inst);\n\n\tif (feature_support == ABM_LCD_SUPPORT)\n\t\tdmub_abm_init_config(abm, src, bytes, inst);\n\n\treturn true;\n}\n\nstatic bool dmub_abm_set_pause_ex(struct abm *abm, bool pause, unsigned int panel_inst, unsigned int stream_inst)\n{\n\tbool ret = false;\n\tunsigned int feature_support;\n\n\tfeature_support = abm_feature_support(abm, panel_inst);\n\n\tif (feature_support == ABM_LCD_SUPPORT)\n\t\tret = dmub_abm_set_pause(abm, pause, panel_inst, stream_inst);\n\n\treturn ret;\n}\n\n \nstatic bool dmub_abm_save_restore_ex(\n\t\tstruct abm *abm,\n\t\tunsigned int panel_inst,\n\t\tstruct abm_save_restore *pData)\n{\n\tbool ret = false;\n\tunsigned int feature_support;\n\tstruct dc_context *dc = abm->ctx;\n\n\tfeature_support = abm_feature_support(abm, panel_inst);\n\n\tif (feature_support == ABM_LCD_SUPPORT)\n\t\tret = dmub_abm_save_restore(dc, panel_inst, pData);\n\n\treturn ret;\n}\n\nstatic bool dmub_abm_set_pipe_ex(struct abm *abm,\n\t\tuint32_t otg_inst,\n\t\tuint32_t option,\n\t\tuint32_t panel_inst,\n\t\tuint32_t pwrseq_inst)\n{\n\tbool ret = false;\n\tunsigned int feature_support;\n\n\tfeature_support = abm_feature_support(abm, panel_inst);\n\n\tif (feature_support == ABM_LCD_SUPPORT)\n\t\tret = dmub_abm_set_pipe(abm, otg_inst, option, panel_inst, pwrseq_inst);\n\n\treturn ret;\n}\n\nstatic bool dmub_abm_set_backlight_level_pwm_ex(struct abm *abm,\n\t\tunsigned int backlight_pwm_u16_16,\n\t\tunsigned int frame_ramp,\n\t\tunsigned int controller_id,\n\t\tunsigned int panel_inst)\n{\n\tbool ret = false;\n\tunsigned int feature_support;\n\n\tfeature_support = abm_feature_support(abm, panel_inst);\n\n\tif (feature_support == ABM_LCD_SUPPORT)\n\t\tret = dmub_abm_set_backlight_level(abm, backlight_pwm_u16_16, frame_ramp, panel_inst);\n\n\treturn ret;\n}\n\nstatic const struct abm_funcs abm_funcs = {\n\t.abm_init = dmub_abm_init_ex,\n\t.set_abm_level = dmub_abm_set_level_ex,\n\t.get_current_backlight = dmub_abm_get_current_backlight_ex,\n\t.get_target_backlight = dmub_abm_get_target_backlight_ex,\n\t.init_abm_config = dmub_abm_init_config_ex,\n\t.set_abm_pause = dmub_abm_set_pause_ex,\n\t.save_restore = dmub_abm_save_restore_ex,\n\t.set_pipe_ex = dmub_abm_set_pipe_ex,\n\t.set_backlight_level_pwm = dmub_abm_set_backlight_level_pwm_ex,\n};\n\nstatic void dmub_abm_construct(\n\tstruct dce_abm *abm_dce,\n\tstruct dc_context *ctx,\n\tconst struct dce_abm_registers *regs,\n\tconst struct dce_abm_shift *abm_shift,\n\tconst struct dce_abm_mask *abm_mask)\n{\n\tstruct abm *base = &abm_dce->base;\n\n\tbase->ctx = ctx;\n\tbase->funcs = &abm_funcs;\n\tbase->dmcu_is_running = false;\n\n\tabm_dce->regs = regs;\n\tabm_dce->abm_shift = abm_shift;\n\tabm_dce->abm_mask = abm_mask;\n}\n\nstruct abm *dmub_abm_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_abm_registers *regs,\n\tconst struct dce_abm_shift *abm_shift,\n\tconst struct dce_abm_mask *abm_mask)\n{\n\tif (ctx->dc->caps.dmcub_support) {\n\t\tstruct dce_abm *abm_dce = kzalloc(sizeof(*abm_dce), GFP_KERNEL);\n\n\t\tif (abm_dce == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdmub_abm_construct(abm_dce, ctx, regs, abm_shift, abm_mask);\n\n\t\treturn &abm_dce->base;\n\t}\n\treturn NULL;\n}\n\nvoid dmub_abm_destroy(struct abm **abm)\n{\n\tstruct dce_abm *abm_dce = TO_DMUB_ABM(*abm);\n\n\tkfree(abm_dce);\n\t*abm = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}