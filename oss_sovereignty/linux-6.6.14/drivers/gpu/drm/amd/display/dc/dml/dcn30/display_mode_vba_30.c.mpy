{
  "module_name": "display_mode_vba_30.c",
  "hash_id": "279c6ae8823bce93a8d9720f89bfa4a9255d23640fc824472b8ff66e9773ca33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_mode_vba_30.c",
  "human_readable_source": " \n\n#include \"dc.h\"\n#include \"../display_mode_lib.h\"\n#include \"display_mode_vba_30.h\"\n#include \"../dml_inline_defs.h\"\n\n\n \n\n\ntypedef struct {\n\tdouble DPPCLK;\n\tdouble DISPCLK;\n\tdouble PixelClock;\n\tdouble DCFCLKDeepSleep;\n\tunsigned int DPPPerPlane;\n\tbool ScalerEnabled;\n\tenum scan_direction_class SourceScan;\n\tunsigned int BlockWidth256BytesY;\n\tunsigned int BlockHeight256BytesY;\n\tunsigned int BlockWidth256BytesC;\n\tunsigned int BlockHeight256BytesC;\n\tunsigned int InterlaceEnable;\n\tunsigned int NumberOfCursors;\n\tunsigned int VBlank;\n\tunsigned int HTotal;\n\tunsigned int DCCEnable;\n\tbool ODMCombineEnabled;\n} Pipe;\n\n#define BPP_INVALID 0\n#define BPP_BLENDED_PIPE 0xffffffff\n#define DCN30_MAX_DSC_IMAGE_WIDTH 5184\n#define DCN30_MAX_FMT_420_BUFFER_WIDTH 4096\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib);\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(\n\t\tstruct display_mode_lib *mode_lib);\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble BPP,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output);\nstatic unsigned int dscComputeDelay(\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output);\n\nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotalPlusCNVCFormater,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int DPP_RECOUT_WIDTH,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tdouble HostVMMinPageSize,\n\t\tbool DynamicMetadataEnable,\n\t\tbool DynamicMetadataVMEnabled,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tint BytePerPixelY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tunsigned int SwathWidthC,\n\t\tint BytePerPixelC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tlong swath_width_luma_ub,\n\t\tlong swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tbool *NotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tdouble *Tdmdl_vm,\n\t\tdouble *Tdmdl,\n\t\tunsigned int *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix);\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed);\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed);\nstatic void CalculateDCCConfiguration(\n\t\tbool DCCEnabled,\n\t\tbool DCCProgrammingAssumesScanDirectionUnknown,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int ViewportWidthLuma,\n\t\tunsigned int ViewportWidthChroma,\n\t\tunsigned int ViewportHeightLuma,\n\t\tunsigned int ViewportHeightChroma,\n\t\tdouble DETBufferSize,\n\t\tunsigned int RequestHeight256ByteLuma,\n\t\tunsigned int RequestHeight256ByteChroma,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int BytePerPixelY,\n\t\tunsigned int BytePerPixelC,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble BytePerPixelDETC,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int *MaxUncompressedBlockLuma,\n\t\tunsigned int *MaxUncompressedBlockChroma,\n\t\tunsigned int *MaxCompressedBlockLuma,\n\t\tunsigned int *MaxCompressedBlockChroma,\n\t\tunsigned int *IndependentBlockLuma,\n\t\tunsigned int *IndependentBlockChroma);\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath);\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMinPageSize,\n\t\tunsigned int HostVMMinPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tunsigned int *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tunsigned int *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tunsigned int *DPDE0BytesFrame,\n\t\tunsigned int *MetaPTEBytesFrame);\nstatic double CalculateTWait(\n\t\tunsigned int PrefetchMode,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble SREnterPlusExitTime);\nstatic void CalculateRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw);\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tdouble HostVMMinPageSize,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow,\n\t\tdouble BandwidthAvailableForImmediateFlip,\n\t\tunsigned int TotImmediateFlipBytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble LineTime,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tdouble Tno_bw,\n\t\tbool DCCEnable,\n\t\tunsigned int dpte_row_height,\n\t\tunsigned int meta_row_height,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tdouble *DestinationLinesToRequestVMInImmediateFlip,\n\t\tdouble *DestinationLinesToRequestRowInImmediateFlip,\n\t\tdouble *final_flip_bw,\n\t\tbool *ImmediateFlipSupportedForPipe);\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackVTaps,\n\t\tlong WritebackDestinationWidth,\n\t\tlong WritebackDestinationHeight,\n\t\tlong WritebackSourceHeight,\n\t\tunsigned int HTotal);\nstatic void CalculateDynamicMetadataParameters(\n\t\tint MaxInterDCNTileRepeaters,\n\t\tdouble DPPCLK,\n\t\tdouble DISPCLK,\n\t\tdouble DCFClkDeepSleep,\n\t\tdouble PixelClock,\n\t\tlong HTotal,\n\t\tlong VBlank,\n\t\tlong DynamicMetadataTransmittedBytes,\n\t\tlong DynamicMetadataLinesBeforeActiveRequired,\n\t\tint InterlaceEnable,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *Tsetup,\n\t\tdouble *Tdmbf,\n\t\tdouble *Tdmec,\n\t\tdouble *Tdmsks);\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tunsigned int MaxLineBufferLines,\n\t\tunsigned int LineBufferSize,\n\t\tunsigned int DPPOutputBufferPixels,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int WritebackInterfaceBufferSize,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tunsigned int dpte_group_bytes[],\n\t\tunsigned int MetaChunkSize,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble WritebackLatency,\n\t\tdouble WritebackChunkSize,\n\t\tdouble SOCCLK,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble SRExitTime,\n\t\tdouble SREnterPlusExitTime,\n\t\tdouble DCFCLKDeepSleep,\n\t\tunsigned int DPPPerPlane[],\n\t\tbool DCCEnable[],\n\t\tdouble DPPCLK[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tunsigned int LBBitPerPixel[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tunsigned int vtaps[],\n\t\tunsigned int VTAPsChroma[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tunsigned int HTotal[],\n\t\tdouble PixelClock[],\n\t\tunsigned int BlendingAndTiming[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tdouble DSTXAfterScaler[],\n\t\tdouble DSTYAfterScaler[],\n\t\tbool WritebackEnable[],\n\t\tenum source_format_class WritebackPixelFormat[],\n\t\tdouble WritebackDestinationWidth[],\n\t\tdouble WritebackDestinationHeight[],\n\t\tdouble WritebackSourceHeight[],\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *UrgentWatermark,\n\t\tdouble *WritebackUrgentWatermark,\n\t\tdouble *DRAMClockChangeWatermark,\n\t\tdouble *WritebackDRAMClockChangeWatermark,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *MinActiveDRAMClockChangeLatencySupported);\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tint ReturnBusWidth,\n\t\tdouble *DCFCLKDeepSleep);\nstatic void CalculateUrgentBurstFactor(\n\t\tlong swath_width_luma_ub,\n\t\tlong swath_width_chroma_ub,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble DETBufferSizeY,\n\t\tdouble DETBufferSizeC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tbool *NotEnoughUrgentLatencyHiding);\n\nstatic void UseMinimumDCFCLK(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tstruct vba_vars_st *v,\n\t\tint MaxPrefetchMode,\n\t\tint ReorderingBytes);\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int NumberOfCursors[],\n\t\tunsigned int CursorWidth[][2],\n\t\tunsigned int CursorBPP[][2],\n\t\tunsigned int BlockWidth256BytesY[],\n\t\tunsigned int BlockHeight256BytesY[],\n\t\tunsigned int BlockWidth256BytesC[],\n\t\tunsigned int BlockHeight256BytesC[],\n\t\tdouble DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[],\n\t\tdouble CursorRequestDeliveryTime[],\n\t\tdouble CursorRequestDeliveryTimePrefetch[]);\n\nstatic void CalculateMetaAndPTETimes(\n\t\tint NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tint MetaChunkSize,\n\t\tint MinMetaChunkSizeBytes,\n\t\tint HTotal[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble DestinationLinesToRequestRowInVBlank[],\n\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint dpte_row_height[],\n\t\tint dpte_row_height_chroma[],\n\t\tint meta_row_width[],\n\t\tint meta_row_width_chroma[],\n\t\tint meta_row_height[],\n\t\tint meta_row_height_chroma[],\n\t\tint meta_req_width[],\n\t\tint meta_req_width_chroma[],\n\t\tint meta_req_height[],\n\t\tint meta_req_height_chroma[],\n\t\tint dpte_group_bytes[],\n\t\tint PTERequestSizeY[],\n\t\tint PTERequestSizeC[],\n\t\tint PixelPTEReqWidthY[],\n\t\tint PixelPTEReqHeightY[],\n\t\tint PixelPTEReqWidthC[],\n\t\tint PixelPTEReqHeightC[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_C[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerChromaMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerChromaMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble TimePerChromaMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[]);\n\nstatic void CalculateVMGroupAndRequestTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int HTotal[],\n\t\tint BytePerPixelC[],\n\t\tdouble DestinationLinesToRequestVMInVBlank[],\n\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tint vm_group_bytes[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tint meta_pte_bytes_per_frame_ub_l[],\n\t\tint meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble TimePerVMGroupVBlank[],\n\t\tdouble TimePerVMGroupFlip[],\n\t\tdouble TimePerVMRequestVBlank[],\n\t\tdouble TimePerVMRequestFlip[]);\n\nstatic void CalculateStutterEfficiency(\n\t\tint NumberOfActivePlanes,\n\t\tlong ROBBufferSizeInKByte,\n\t\tdouble TotalDataReadBandwidth,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble SRExitTime,\n\t\tbool SynchronizedVBlank,\n\t\tint DPPPerPlane[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tint BytePerPixelY[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble SwathWidthY[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tdouble DCCRateLuma[],\n\t\tdouble DCCRateChroma[],\n\t\tint HTotal[],\n\t\tint VTotal[],\n\t\tdouble PixelClock[],\n\t\tdouble VRatio[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint BlockHeight256BytesY[],\n\t\tint BlockWidth256BytesY[],\n\t\tint BlockHeight256BytesC[],\n\t\tint BlockWidth256BytesC[],\n\t\tint DCCYMaxUncompressedBlock[],\n\t\tint DCCCMaxUncompressedBlock[],\n\t\tint VActive[],\n\t\tbool DCCEnable[],\n\t\tbool WritebackEnable[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tdouble meta_row_bw[],\n\t\tdouble dpte_row_bw[],\n\t\tdouble *StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *StutterEfficiency,\n\t\tdouble *StutterPeriodOut);\n\nstatic void CalculateSwathAndDETConfiguration(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tdouble MaximumSwathWidthLuma[],\n\t\tdouble MaximumSwathWidthChroma[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum dm_swizzle_mode SurfaceTiling[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BlendingAndTiming[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tdouble BytePerPixDETY[],\n\t\tdouble BytePerPixDETC[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tint DPPPerPlane[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[],\n\t\tdouble SwathWidth[],\n\t\tdouble SwathWidthChroma[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tbool ViewportSizeSupportPerPlane[],\n\t\tbool *ViewportSizeSupport);\nstatic void CalculateSwathWidth(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int ViewportWidth[],\n\t\tunsigned int ViewportHeight[],\n\t\tunsigned int SurfaceWidthY[],\n\t\tunsigned int SurfaceWidthC[],\n\t\tunsigned int SurfaceHeightY[],\n\t\tunsigned int SurfaceHeightC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tint BlendingAndTiming[],\n\t\tunsigned int HActive[],\n\t\tdouble HRatio[],\n\t\tint DPPPerPlane[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tdouble SwathWidthSingleDPPC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tint MaximumSwathHeightY[],\n\t\tint MaximumSwathHeightC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[]);\nstatic double CalculateExtraLatency(\n\t\tlong RoundTripPingLatencyCycles,\n\t\tlong ReorderingBytes,\n\t\tdouble DCFCLK,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels);\nstatic double CalculateExtraLatencyBytes(\n\t\tlong ReorderingBytes,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels);\nstatic double CalculateUrgentLatency(\n\t\tdouble UrgentLatencyPixelDataOnly,\n\t\tdouble UrgentLatencyPixelMixedWithVMData,\n\t\tdouble UrgentLatencyVMDataOnly,\n\t\tbool DoUrgentLatencyAdjustment,\n\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,\n\t\tdouble UrgentLatencyAdjustmentFabricClockReference,\n\t\tdouble FabricClockSingle);\n\nvoid dml30_recalculate(struct display_mode_lib *mode_lib)\n{\n\tModeSupportAndSystemConfiguration(mode_lib);\n\tPixelClockAdjustmentForProgressiveToInterlaceUnit(mode_lib);\n\tDisplayPipeConfiguration(mode_lib);\n\tDISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(mode_lib);\n}\n\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble BPP,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat,\n\t\tenum output_encoder_class Output)\n{\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\t\n\tunsigned int rcModelSize = 8192;\n\n\t\n\tunsigned int pixelsPerClock, lstall, D, initalXmitDelay, w, s, ix, wx, P, l0, a, ax, L,\n\t\t\tDelay, pixels;\n\n\tif (pixelFormat == dm_420)\n\t\tpixelsPerClock = 2;\n\t\n\telse if (pixelFormat == dm_444)\n\t\tpixelsPerClock = 1;\n\telse if (pixelFormat == dm_n422)\n\t\tpixelsPerClock = 2;\n\telse\n\t\tpixelsPerClock = 1;\n\n\t\n\tinitalXmitDelay = dml_round(rcModelSize / 2.0 / BPP / pixelsPerClock);\n\n\t\n\tif (bpc == 8)\n\t\tD = 81;\n\telse if (bpc == 10)\n\t\tD = 89;\n\telse\n\t\tD = 113;\n\n\t\n\tw = sliceWidth / pixelsPerClock;\n\n\t\n\tif (pixelFormat == dm_420 || pixelFormat == dm_444 || pixelFormat == dm_n422)\n\t\ts = 0;\n\telse\n\t\ts = 1;\n\n\t\n\tix = initalXmitDelay + 45;\n\twx = (w + 2) / 3;\n\tP = 3 * wx - w;\n\tl0 = ix / w;\n\ta = ix + P * l0;\n\tax = (a + 2) / 3 + D + 6 + 1;\n\tL = (ax + wx - 1) / wx;\n\tif ((ix % w) == 0 && P != 0)\n\t\tlstall = 1;\n\telse\n\t\tlstall = 0;\n\tDelay = L * wx * (numSlices - 1) + ax + s + lstall + 22;\n\n\t\n\tpixels = Delay * 3 * pixelsPerClock;\n\treturn pixels;\n}\n\nstatic unsigned int dscComputeDelay(enum output_format_class pixelFormat, enum output_encoder_class Output)\n{\n\tunsigned int Delay = 0;\n\n\tif (pixelFormat == dm_420) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 13;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else if (pixelFormat == dm_n422) {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 5;\n\t\t\n\t\tDelay = Delay + 25;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 10;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 1;\n\t} else {\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 0;\n\t\t\n\t\tDelay = Delay + 3;\n\t\t\n\t\tDelay = Delay + 12;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 7;\n\t\t\n\t\tDelay = Delay + 1;\n\t\t\n\t\tDelay = Delay + 2;\n\t\t\n\t\tDelay = Delay + 1;\n\t}\n\n\treturn Delay;\n}\n\nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotalPlusCNVCFormater,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int DPP_RECOUT_WIDTH,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tdouble HostVMMinPageSize,\n\t\tbool DynamicMetadataEnable,\n\t\tbool DynamicMetadataVMEnabled,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tint BytePerPixelY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tunsigned int SwathWidthC,\n\t\tint BytePerPixelC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tlong swath_width_luma_ub,\n\t\tlong swath_width_chroma_ub,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tbool *NotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tdouble *Tdmdl_vm,\n\t\tdouble *Tdmdl,\n\t\tunsigned int *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix)\n{\n\tbool MyError = false;\n\tunsigned int DPPCycles = 0, DISPCLKCycles = 0;\n\tdouble DSTTotalPixelsAfterScaler = 0;\n\tdouble LineTime = 0, Tsetup = 0;\n\tdouble dst_y_prefetch_equ = 0;\n\tdouble Tsw_oto = 0;\n\tdouble prefetch_bw_oto = 0;\n\tdouble Tvm_oto = 0;\n\tdouble Tr0_oto = 0;\n\tdouble Tvm_oto_lines = 0;\n\tdouble Tr0_oto_lines = 0;\n\tdouble dst_y_prefetch_oto = 0;\n\tdouble TimeForFetchingMetaPTE = 0;\n\tdouble TimeForFetchingRowInVBlank = 0;\n\tdouble LinesToRequestPrefetchPixelData = 0;\n\tdouble HostVMInefficiencyFactor = 0;\n\tunsigned int HostVMDynamicLevelsTrips = 0;\n\tdouble trip_to_mem = 0;\n\tdouble Tvm_trips = 0;\n\tdouble Tr0_trips = 0;\n\tdouble Tvm_trips_rounded = 0;\n\tdouble Tr0_trips_rounded = 0;\n\tdouble Lsw_oto = 0;\n\tdouble Tpre_rounded = 0;\n\tdouble prefetch_bw_equ = 0;\n\tdouble Tvm_equ = 0;\n\tdouble Tr0_equ = 0;\n\tdouble Tdmbf = 0;\n\tdouble Tdmec = 0;\n\tdouble Tdmsks = 0;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tHostVMInefficiencyFactor = PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tHostVMDynamicLevelsTrips = HostVMMaxNonCachedPageTableLevels;\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevelsTrips = 0;\n\t}\n\n\tCalculateDynamicMetadataParameters(\n\t\t\tMaxInterDCNTileRepeaters,\n\t\t\tmyPipe->DPPCLK,\n\t\t\tmyPipe->DISPCLK,\n\t\t\tmyPipe->DCFCLKDeepSleep,\n\t\t\tmyPipe->PixelClock,\n\t\t\tmyPipe->HTotal,\n\t\t\tmyPipe->VBlank,\n\t\t\tDynamicMetadataTransmittedBytes,\n\t\t\tDynamicMetadataLinesBeforeActiveRequired,\n\t\t\tmyPipe->InterlaceEnable,\n\t\t\tProgressiveToInterlaceUnitInOPP,\n\t\t\t&Tsetup,\n\t\t\t&Tdmbf,\n\t\t\t&Tdmec,\n\t\t\t&Tdmsks);\n\n\tLineTime = myPipe->HTotal / myPipe->PixelClock;\n\ttrip_to_mem = UrgentLatency;\n\tTvm_trips = UrgentExtraLatency + trip_to_mem * (GPUVMPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1);\n\n\tif (DynamicMetadataVMEnabled == true && GPUVMEnable == true) {\n\t\t*Tdmdl = TWait + Tvm_trips + trip_to_mem;\n\t} else {\n\t\t*Tdmdl = TWait + UrgentExtraLatency;\n\t}\n\n\tif (DynamicMetadataEnable == true) {\n\t\tif (VStartup * LineTime < Tsetup + *Tdmdl + Tdmbf + Tdmec + Tdmsks) {\n\t\t\t*NotEnoughTimeForDynamicMetadata = true;\n\t\t} else {\n\t\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t\t\tdml_print(\"DML: Not Enough Time for Dynamic Meta!\\n\");\n\t\t\tdml_print(\"DML: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\", Tdmbf);\n\t\t\tdml_print(\"DML: Tdmec: %fus - time dio takes to transfer dmd\\n\", Tdmec);\n\t\t\tdml_print(\"DML: Tdmsks: %fus - time before active dmd must complete transmission at dio\\n\", Tdmsks);\n\t\t\tdml_print(\"DML: Tdmdl: %fus - time for fabric to become ready and fetch dmd \\n\", *Tdmdl);\n\t\t}\n\t} else {\n\t\t*NotEnoughTimeForDynamicMetadata = false;\n\t}\n\n\t*Tdmdl_vm = (DynamicMetadataEnable == true && DynamicMetadataVMEnabled == true && GPUVMEnable == true ? TWait + Tvm_trips : 0);\n\n\tif (myPipe->ScalerEnabled)\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + DPPCLKDelaySCL;\n\telse\n\t\tDPPCycles = DPPCLKDelaySubtotalPlusCNVCFormater + DPPCLKDelaySCLLBOnly;\n\n\tDPPCycles = DPPCycles + myPipe->NumberOfCursors * DPPCLKDelayCNVCCursor;\n\n\tDISPCLKCycles = DISPCLKDelaySubtotal;\n\n\tif (myPipe->DPPCLK == 0.0 || myPipe->DISPCLK == 0.0)\n\t\treturn true;\n\n\t*DSTXAfterScaler = DPPCycles * myPipe->PixelClock / myPipe->DPPCLK + DISPCLKCycles * myPipe->PixelClock / myPipe->DISPCLK\n\t\t\t+ DSCDelay;\n\n\t*DSTXAfterScaler = *DSTXAfterScaler + ((myPipe->ODMCombineEnabled)?18:0) + (myPipe->DPPPerPlane - 1) * DPP_RECOUT_WIDTH;\n\n\tif (OutputFormat == dm_420 || (myPipe->InterlaceEnable && ProgressiveToInterlaceUnitInOPP))\n\t\t*DSTYAfterScaler = 1;\n\telse\n\t\t*DSTYAfterScaler = 0;\n\n\tDSTTotalPixelsAfterScaler = *DSTYAfterScaler * myPipe->HTotal + *DSTXAfterScaler;\n\t*DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / myPipe->HTotal, 1);\n\t*DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * myPipe->HTotal));\n\n\tMyError = false;\n\n\n\tTr0_trips = trip_to_mem * (HostVMDynamicLevelsTrips + 1);\n\tTvm_trips_rounded = dml_ceil(4.0 * Tvm_trips / LineTime, 1) / 4 * LineTime;\n\tTr0_trips_rounded = dml_ceil(4.0 * Tr0_trips / LineTime, 1) / 4 * LineTime;\n\n\tif (GPUVMEnable) {\n\t\tif (GPUVMPageTableLevels >= 3) {\n\t\t\t*Tno_bw = UrgentExtraLatency + trip_to_mem * ((GPUVMPageTableLevels - 2) - 1);\n\t\t} else\n\t\t\t*Tno_bw = 0;\n\t} else if (!myPipe->DCCEnable)\n\t\t*Tno_bw = LineTime;\n\telse\n\t\t*Tno_bw = LineTime / 4;\n\n\tdst_y_prefetch_equ = VStartup - (Tsetup + dml_max(TWait + TCalc, *Tdmdl)) / LineTime\n\t\t\t- (*DSTYAfterScaler + *DSTXAfterScaler / myPipe->HTotal);\n\n\tLsw_oto = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC);\n\tTsw_oto = Lsw_oto * LineTime;\n\n\tprefetch_bw_oto = (PrefetchSourceLinesY * swath_width_luma_ub * BytePerPixelY + PrefetchSourceLinesC * swath_width_chroma_ub * BytePerPixelC) / Tsw_oto;\n\n\tif (GPUVMEnable == true) {\n\t\tTvm_oto = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_oto,\n\t\t\t\tTvm_trips,\n\t\t\t\tLineTime / 4.0);\n\t} else\n\t\tTvm_oto = LineTime / 4.0;\n\n\tif ((GPUVMEnable == true || myPipe->DCCEnable == true)) {\n\t\tTr0_oto = dml_max3(\n\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto,\n\t\t\t\tLineTime - Tvm_oto, LineTime / 4);\n\t} else\n\t\tTr0_oto = (LineTime - Tvm_oto) / 2.0;\n\n\tTvm_oto_lines = dml_ceil(4.0 * Tvm_oto / LineTime, 1) / 4.0;\n\tTr0_oto_lines = dml_ceil(4.0 * Tr0_oto / LineTime, 1) / 4.0;\n\tdst_y_prefetch_oto = Tvm_oto_lines + 2 * Tr0_oto_lines + Lsw_oto;\n\n\tdst_y_prefetch_equ = dml_floor(4.0 * (dst_y_prefetch_equ + 0.125), 1) / 4.0;\n\tTpre_rounded = dst_y_prefetch_equ * LineTime;\n\n\tdml_print(\"DML: dst_y_prefetch_oto: %f\\n\", dst_y_prefetch_oto);\n\tdml_print(\"DML: dst_y_prefetch_equ: %f\\n\", dst_y_prefetch_equ);\n\n\tdml_print(\"DML: LineTime: %f\\n\", LineTime);\n\tdml_print(\"DML: VStartup: %d\\n\", VStartup);\n\tdml_print(\"DML: Tvstartup: %fus - time between vstartup and first pixel of active\\n\", VStartup * LineTime);\n\tdml_print(\"DML: Tsetup: %fus - time from vstartup to vready\\n\", Tsetup);\n\tdml_print(\"DML: TCalc: %fus - time for calculations in dchub starting at vready\\n\", TCalc);\n\tdml_print(\"DML: TWait: %fus - time for fabric to become ready max(pstate exit,cstate enter/exit, urgent latency) after TCalc\\n\", TWait);\n\tdml_print(\"DML: Tdmbf: %fus - time for dmd transfer from dchub to dio output buffer\\n\", Tdmbf);\n\tdml_print(\"DML: Tdmec: %fus - time dio takes to transfer dmd\\n\", Tdmec);\n\tdml_print(\"DML: Tdmsks: %fus - time before active dmd must complete transmission at dio\\n\", Tdmsks);\n\tdml_print(\"DML: Tdmdl_vm: %fus - time for vm stages of dmd \\n\", *Tdmdl_vm);\n\tdml_print(\"DML: Tdmdl: %fus - time for fabric to become ready and fetch dmd \\n\", *Tdmdl);\n\tdml_print(\"DML: dst_x_after_scl: %f pixels - number of pixel clocks pipeline and buffer delay after scaler \\n\", *DSTXAfterScaler);\n\tdml_print(\"DML: dst_y_after_scl: %d lines - number of lines of pipeline and buffer delay after scaler \\n\", (int)*DSTYAfterScaler);\n\n\t*PrefetchBandwidth = 0;\n\t*DestinationLinesToRequestVMInVBlank = 0;\n\t*DestinationLinesToRequestRowInVBlank = 0;\n\t*VRatioPrefetchY = 0;\n\t*VRatioPrefetchC = 0;\n\t*RequiredPrefetchPixDataBWLuma = 0;\n\tif (dst_y_prefetch_equ > 1) {\n\t\tdouble PrefetchBandwidth1 = 0;\n\t\tdouble PrefetchBandwidth2 = 0;\n\t\tdouble PrefetchBandwidth3 = 0;\n\t\tdouble PrefetchBandwidth4 = 0;\n\n\t\tif (Tpre_rounded - *Tno_bw > 0)\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte\n\t\t\t\t\t+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t\t+ PrefetchSourceLinesY * swath_width_luma_ub * BytePerPixelY\n\t\t\t\t\t+ PrefetchSourceLinesC * swath_width_chroma_ub * BytePerPixelC)\n\t\t\t\t\t/ (Tpre_rounded - *Tno_bw);\n\t\telse\n\t\t\tPrefetchBandwidth1 = 0;\n\n\t\tif (VStartup == MaxVStartup && (PrefetchBandwidth1 > 4 * prefetch_bw_oto) && (Tpre_rounded - Tsw_oto / 4 - 0.75 * LineTime - *Tno_bw) > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor) / (Tpre_rounded - Tsw_oto / 4 - 0.75 * LineTime - *Tno_bw);\n\t\t}\n\n\t\tif (Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded > 0)\n\t\t\tPrefetchBandwidth2 = (PDEAndMetaPTEBytesFrame *\n\t\t\t\t\tHostVMInefficiencyFactor + PrefetchSourceLinesY *\n\t\t\t\t\tswath_width_luma_ub * BytePerPixelY +\n\t\t\t\t\tPrefetchSourceLinesC * swath_width_chroma_ub *\n\t\t\t\t\tBytePerPixelC) /\n\t\t\t\t\t(Tpre_rounded - *Tno_bw - 2 * Tr0_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth2 = 0;\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded > 0)\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow *\n\t\t\t\t\tHostVMInefficiencyFactor + PrefetchSourceLinesY *\n\t\t\t\t\tswath_width_luma_ub * BytePerPixelY + PrefetchSourceLinesC *\n\t\t\t\t\tswath_width_chroma_ub * BytePerPixelC) / (Tpre_rounded -\n\t\t\t\t\tTvm_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth3 = 0;\n\n\t\tif (VStartup == MaxVStartup && (PrefetchBandwidth3 > 4 * prefetch_bw_oto) && Tpre_rounded - Tsw_oto / 4 - 0.75 * LineTime - Tvm_trips_rounded > 0) {\n\t\t\tPrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor) / (Tpre_rounded - Tsw_oto / 4 - 0.75 * LineTime - Tvm_trips_rounded);\n\t\t}\n\n\t\tif (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded > 0)\n\t\t\tPrefetchBandwidth4 = (PrefetchSourceLinesY * swath_width_luma_ub * BytePerPixelY + PrefetchSourceLinesC * swath_width_chroma_ub * BytePerPixelC)\n\t\t\t\t\t/ (Tpre_rounded - Tvm_trips_rounded - 2 * Tr0_trips_rounded);\n\t\telse\n\t\t\tPrefetchBandwidth4 = 0;\n\n\t\t{\n\t\t\tbool Case1OK;\n\t\t\tbool Case2OK;\n\t\t\tbool Case3OK;\n\n\t\t\tif (PrefetchBandwidth1 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth1\n\t\t\t\t\t\t>= Tvm_trips_rounded && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth1 >= Tr0_trips_rounded) {\n\t\t\t\t\tCase1OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase1OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase1OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth2 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth2\n\t\t\t\t\t\t>= Tvm_trips_rounded && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth2 < Tr0_trips_rounded) {\n\t\t\t\t\tCase2OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase2OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase2OK = false;\n\t\t\t}\n\n\t\t\tif (PrefetchBandwidth3 > 0) {\n\t\t\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth3\n\t\t\t\t\t\t< Tvm_trips_rounded && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth3 >= Tr0_trips_rounded) {\n\t\t\t\t\tCase3OK = true;\n\t\t\t\t} else {\n\t\t\t\t\tCase3OK = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCase3OK = false;\n\t\t\t}\n\n\t\t\tif (Case1OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth1;\n\t\t\t} else if (Case2OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth2;\n\t\t\t} else if (Case3OK) {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth3;\n\t\t\t} else {\n\t\t\t\tprefetch_bw_equ = PrefetchBandwidth4;\n\t\t\t}\n\n\t\t\tdml_print(\"DML: prefetch_bw_equ: %f\\n\", prefetch_bw_equ);\n\n\t\t\tif (prefetch_bw_equ > 0) {\n\t\t\t\tif (GPUVMEnable) {\n\t\t\t\t\tTvm_equ = dml_max3(*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_equ, Tvm_trips, LineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTvm_equ = LineTime / 4;\n\t\t\t\t}\n\n\t\t\t\tif ((GPUVMEnable || myPipe->DCCEnable)) {\n\t\t\t\t\tTr0_equ = dml_max4(\n\t\t\t\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_equ,\n\t\t\t\t\t\t\tTr0_trips,\n\t\t\t\t\t\t\t(LineTime - Tvm_equ) / 2,\n\t\t\t\t\t\t\tLineTime / 4);\n\t\t\t\t} else {\n\t\t\t\t\tTr0_equ = (LineTime - Tvm_equ) / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTvm_equ = 0;\n\t\t\t\tTr0_equ = 0;\n\t\t\t\tdml_print(\"DML: prefetch_bw_equ equals 0! %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t}\n\t\t}\n\n\t\tif (dst_y_prefetch_oto < dst_y_prefetch_equ) {\n\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_oto;\n\t\t\tTimeForFetchingMetaPTE = Tvm_oto;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_oto;\n\t\t\t*PrefetchBandwidth = prefetch_bw_oto;\n\t\t} else {\n\t\t\t*DestinationLinesForPrefetch = dst_y_prefetch_equ;\n\t\t\tTimeForFetchingMetaPTE = Tvm_equ;\n\t\t\tTimeForFetchingRowInVBlank = Tr0_equ;\n\t\t\t*PrefetchBandwidth = prefetch_bw_equ;\n\t\t}\n\n\t\t*DestinationLinesToRequestVMInVBlank = dml_ceil(4.0 * TimeForFetchingMetaPTE / LineTime, 1.0) / 4.0;\n\n\t\t*DestinationLinesToRequestRowInVBlank = dml_ceil(4.0 * TimeForFetchingRowInVBlank / LineTime, 1.0) / 4.0;\n\n\n\t\tLinesToRequestPrefetchPixelData = *DestinationLinesForPrefetch - *DestinationLinesToRequestVMInVBlank\n\t\t\t\t- 2 * *DestinationLinesToRequestRowInVBlank;\n\n\t\tif (LinesToRequestPrefetchPixelData > 0 && prefetch_bw_equ > 0) {\n\n\t\t\t*VRatioPrefetchY = (double) PrefetchSourceLinesY\n\t\t\t\t\t/ LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\tif ((SwathHeightY > 4) && (VInitPreFillY > 3)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchY = dml_max((double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData,\n\t\t\t\t\t\t(double) MaxNumSwathY * SwathHeightY / (LinesToRequestPrefetchPixelData - (VInitPreFillY - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t\t\t*VRatioPrefetchY = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*VRatioPrefetchC = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\n\t\t\tif ((SwathHeightC > 4)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC,\n\t\t\t\t\t\t(double) MaxNumSwathC * SwathHeightC / (LinesToRequestPrefetchPixelData - (VInitPreFillC - 3.0) / 2.0));\n\t\t\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\t\t\t*VRatioPrefetchC = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*RequiredPrefetchPixDataBWLuma = (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData * BytePerPixelY * swath_width_luma_ub / LineTime;\n\t\t\t*RequiredPrefetchPixDataBWChroma = (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData * BytePerPixelC * swath_width_chroma_ub / LineTime;\n\t\t} else {\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t\tdml_print(\"DML: LinesToRequestPrefetchPixelData: %f, should be > 0\\n\", LinesToRequestPrefetchPixelData);\n\t\t\t*VRatioPrefetchY = 0;\n\t\t\t*VRatioPrefetchC = 0;\n\t\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t\t}\n\n\t\tdml_print(\"DML: Tpre: %fus - sum of tim to request meta pte, 2 x data pte + meta data, swaths\\n\", (double)LinesToRequestPrefetchPixelData * LineTime + 2.0*TimeForFetchingRowInVBlank + TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML:  Tvm: %fus - time to fetch page tables for meta surface\\n\", TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML:  Tr0: %fus - time to fetch first row of data pagetables and first row of meta data (done in parallel)\\n\", TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML:  Tr1: %fus - time to fetch second row of data pagetables and second row of meta data (done in parallel)\\n\", TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML:  Tsw: %fus = time to fetch enough pixel data and cursor data to feed the scalers init position and detile\\n\", (double)LinesToRequestPrefetchPixelData * LineTime);\n\t\tdml_print(\"DML: To: %fus - time for propagation from scaler to optc\\n\", (*DSTYAfterScaler + ((*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime);\n\t\tdml_print(\"DML: Tvstartup - Tsetup - Tcalc - Twait - Tpre - To > 0\\n\");\n\t\tdml_print(\"DML: Tslack(pre): %fus - time left over in schedule\\n\", VStartup * LineTime - TimeForFetchingMetaPTE - 2 * TimeForFetchingRowInVBlank - (*DSTYAfterScaler + ((*DSTXAfterScaler) / (double) myPipe->HTotal)) * LineTime - TWait - TCalc - Tsetup);\n\t\tdml_print(\"DML: row_bytes = dpte_row_bytes (per_pipe) = PixelPTEBytesPerRow = : %d\\n\", PixelPTEBytesPerRow);\n\n\t} else {\n\t\tMyError = true;\n\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t}\n\n\t{\n\t\tdouble prefetch_vm_bw = 0;\n\t\tdouble prefetch_row_bw = 0;\n\n\t\tif (PDEAndMetaPTEBytesFrame == 0) {\n\t\t\tprefetch_vm_bw = 0;\n\t\t} else if (*DestinationLinesToRequestVMInVBlank > 0) {\n\t\t\tprefetch_vm_bw = PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / (*DestinationLinesToRequestVMInVBlank * LineTime);\n\t\t} else {\n\t\t\tprefetch_vm_bw = 0;\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t}\n\t\tif (MetaRowByte + PixelPTEBytesPerRow == 0) {\n\t\t\tprefetch_row_bw = 0;\n\t\t} else if (*DestinationLinesToRequestRowInVBlank > 0) {\n\t\t\tprefetch_row_bw = (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / (*DestinationLinesToRequestRowInVBlank * LineTime);\n\t\t} else {\n\t\t\tprefetch_row_bw = 0;\n\t\t\tMyError = true;\n\t\t\tdml_print(\"DML: MyErr set %s:%d\\n\", __FILE__, __LINE__);\n\t\t}\n\n\t\t*prefetch_vmrow_bw = dml_max(prefetch_vm_bw, prefetch_row_bw);\n\t}\n\n\tif (MyError) {\n\t\t*PrefetchBandwidth = 0;\n\t\tTimeForFetchingMetaPTE = 0;\n\t\tTimeForFetchingRowInVBlank = 0;\n\t\t*DestinationLinesToRequestVMInVBlank = 0;\n\t\t*DestinationLinesToRequestRowInVBlank = 0;\n\t\t*DestinationLinesForPrefetch = 0;\n\t\tLinesToRequestPrefetchPixelData = 0;\n\t\t*VRatioPrefetchY = 0;\n\t\t*VRatioPrefetchC = 0;\n\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t}\n\n\treturn MyError;\n}\n\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);\n}\n\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);\n}\n\nstatic void CalculateDCCConfiguration(\n\t\tbool DCCEnabled,\n\t\tbool DCCProgrammingAssumesScanDirectionUnknown,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceWidthLuma,\n\t\tunsigned int SurfaceWidthChroma,\n\t\tunsigned int SurfaceHeightLuma,\n\t\tunsigned int SurfaceHeightChroma,\n\t\tdouble DETBufferSize,\n\t\tunsigned int RequestHeight256ByteLuma,\n\t\tunsigned int RequestHeight256ByteChroma,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int BytePerPixelY,\n\t\tunsigned int BytePerPixelC,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble BytePerPixelDETC,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int *MaxUncompressedBlockLuma,\n\t\tunsigned int *MaxUncompressedBlockChroma,\n\t\tunsigned int *MaxCompressedBlockLuma,\n\t\tunsigned int *MaxCompressedBlockChroma,\n\t\tunsigned int *IndependentBlockLuma,\n\t\tunsigned int *IndependentBlockChroma)\n{\n\tint yuv420 = 0;\n\tint horz_div_l = 0;\n\tint horz_div_c = 0;\n\tint vert_div_l = 0;\n\tint vert_div_c = 0;\n\n\tint req128_horz_wc_l = 0;\n\tint req128_horz_wc_c = 0;\n\tint req128_vert_wc_l = 0;\n\tint req128_vert_wc_c = 0;\n\tint segment_order_horz_contiguous_luma = 0;\n\tint segment_order_horz_contiguous_chroma = 0;\n\tint segment_order_vert_contiguous_luma = 0;\n\tint segment_order_vert_contiguous_chroma = 0;\n\n\tlong full_swath_bytes_horz_wc_l = 0;\n\tlong full_swath_bytes_horz_wc_c = 0;\n\tlong full_swath_bytes_vert_wc_l = 0;\n\tlong full_swath_bytes_vert_wc_c = 0;\n\n\tlong swath_buf_size = 0;\n\tdouble detile_buf_vp_horz_limit = 0;\n\tdouble detile_buf_vp_vert_limit = 0;\n\n\tlong MAS_vp_horz_limit = 0;\n\tlong MAS_vp_vert_limit = 0;\n\tlong max_vp_horz_width = 0;\n\tlong max_vp_vert_height = 0;\n\tlong eff_surf_width_l = 0;\n\tlong eff_surf_width_c = 0;\n\tlong eff_surf_height_l = 0;\n\tlong eff_surf_height_c = 0;\n\n\ttypedef enum {\n\t\tREQ_256Bytes,\n\t\tREQ_128BytesNonContiguous,\n\t\tREQ_128BytesContiguous,\n\t\tREQ_NA\n\t} RequestType;\n\n\tRequestType   RequestLuma;\n\tRequestType   RequestChroma;\n\n\tyuv420 = ((SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12) ? 1 : 0);\n\thorz_div_l = 1;\n\thorz_div_c = 1;\n\tvert_div_l = 1;\n\tvert_div_c = 1;\n\n\tif (BytePerPixelY == 1)\n\t\tvert_div_l = 0;\n\tif (BytePerPixelC == 1)\n\t\tvert_div_c = 0;\n\tif (BytePerPixelY == 8\n\t\t\t&& (TilingFormat == dm_sw_64kb_s || TilingFormat == dm_sw_64kb_s_t\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_s_x))\n\t\thorz_div_l = 0;\n\tif (BytePerPixelC == 8\n\t\t\t&& (TilingFormat == dm_sw_64kb_s || TilingFormat == dm_sw_64kb_s_t\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_s_x))\n\t\thorz_div_c = 0;\n\n\tif (BytePerPixelC == 0) {\n\t\tswath_buf_size = DETBufferSize / 2 - 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size\n\t\t\t\t/ ((double) RequestHeight256ByteLuma * BytePerPixelY\n\t\t\t\t\t\t/ (1 + horz_div_l));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size\n\t\t\t\t/ (256.0 / RequestHeight256ByteLuma / (1 + vert_div_l));\n\t} else {\n\t\tswath_buf_size = DETBufferSize / 2 - 2 * 2 * 256;\n\t\tdetile_buf_vp_horz_limit = (double) swath_buf_size\n\t\t\t\t/ ((double) RequestHeight256ByteLuma * BytePerPixelY\n\t\t\t\t\t\t/ (1 + horz_div_l)\n\t\t\t\t\t\t+ (double) RequestHeight256ByteChroma\n\t\t\t\t\t\t\t\t* BytePerPixelC / (1 + horz_div_c)\n\t\t\t\t\t\t\t\t/ (1 + yuv420));\n\t\tdetile_buf_vp_vert_limit = (double) swath_buf_size\n\t\t\t\t/ (256.0 / RequestHeight256ByteLuma / (1 + vert_div_l)\n\t\t\t\t\t\t+ 256.0 / RequestHeight256ByteChroma\n\t\t\t\t\t\t\t\t/ (1 + vert_div_c) / (1 + yuv420));\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tdetile_buf_vp_horz_limit = 1.5 * detile_buf_vp_horz_limit;\n\t\tdetile_buf_vp_vert_limit = 1.5 * detile_buf_vp_vert_limit;\n\t}\n\n\tdetile_buf_vp_horz_limit = dml_floor(detile_buf_vp_horz_limit - 1, 16);\n\tdetile_buf_vp_vert_limit = dml_floor(detile_buf_vp_vert_limit - 1, 16);\n\n\tMAS_vp_horz_limit = 5760;\n\tMAS_vp_vert_limit = (BytePerPixelC > 0 ? 2880 : 5760);\n\tmax_vp_horz_width = dml_min((double) MAS_vp_horz_limit, detile_buf_vp_horz_limit);\n\tmax_vp_vert_height = dml_min((double) MAS_vp_vert_limit, detile_buf_vp_vert_limit);\n\teff_surf_width_l =\n\t\t\t(SurfaceWidthLuma > max_vp_horz_width ? max_vp_horz_width : SurfaceWidthLuma);\n\teff_surf_width_c = eff_surf_width_l / (1 + yuv420);\n\teff_surf_height_l = (\n\t\t\tSurfaceHeightLuma > max_vp_vert_height ?\n\t\t\t\t\tmax_vp_vert_height : SurfaceHeightLuma);\n\teff_surf_height_c = eff_surf_height_l / (1 + yuv420);\n\n\tfull_swath_bytes_horz_wc_l = eff_surf_width_l * RequestHeight256ByteLuma * BytePerPixelY;\n\tfull_swath_bytes_vert_wc_l = eff_surf_height_l * 256 / RequestHeight256ByteLuma;\n\tif (BytePerPixelC > 0) {\n\t\tfull_swath_bytes_horz_wc_c = eff_surf_width_c * RequestHeight256ByteChroma\n\t\t\t\t* BytePerPixelC;\n\t\tfull_swath_bytes_vert_wc_c = eff_surf_height_c * 256 / RequestHeight256ByteChroma;\n\t} else {\n\t\tfull_swath_bytes_horz_wc_c = 0;\n\t\tfull_swath_bytes_vert_wc_c = 0;\n\t}\n\n\tif (SourcePixelFormat == dm_420_10) {\n\t\tfull_swath_bytes_horz_wc_l = dml_ceil(full_swath_bytes_horz_wc_l * 2 / 3, 256);\n\t\tfull_swath_bytes_horz_wc_c = dml_ceil(full_swath_bytes_horz_wc_c * 2 / 3, 256);\n\t\tfull_swath_bytes_vert_wc_l = dml_ceil(full_swath_bytes_vert_wc_l * 2 / 3, 256);\n\t\tfull_swath_bytes_vert_wc_c = dml_ceil(full_swath_bytes_vert_wc_c * 2 / 3, 256);\n\t}\n\n\tif (2 * full_swath_bytes_horz_wc_l + 2 * full_swath_bytes_horz_wc_c <= DETBufferSize) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 0;\n\t} else if (full_swath_bytes_horz_wc_l < 1.5 * full_swath_bytes_horz_wc_c\n\t\t\t&& 2 * full_swath_bytes_horz_wc_l + full_swath_bytes_horz_wc_c\n\t\t\t\t\t<= DETBufferSize) {\n\t\treq128_horz_wc_l = 0;\n\t\treq128_horz_wc_c = 1;\n\t} else if (full_swath_bytes_horz_wc_l >= 1.5 * full_swath_bytes_horz_wc_c\n\t\t\t&& full_swath_bytes_horz_wc_l + 2 * full_swath_bytes_horz_wc_c\n\t\t\t\t\t<= DETBufferSize) {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 0;\n\t} else {\n\t\treq128_horz_wc_l = 1;\n\t\treq128_horz_wc_c = 1;\n\t}\n\n\tif (2 * full_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c <= DETBufferSize) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 0;\n\t} else if (full_swath_bytes_vert_wc_l < 1.5 * full_swath_bytes_vert_wc_c\n\t\t\t&& 2 * full_swath_bytes_vert_wc_l + full_swath_bytes_vert_wc_c\n\t\t\t\t\t<= DETBufferSize) {\n\t\treq128_vert_wc_l = 0;\n\t\treq128_vert_wc_c = 1;\n\t} else if (full_swath_bytes_vert_wc_l >= 1.5 * full_swath_bytes_vert_wc_c\n\t\t\t&& full_swath_bytes_vert_wc_l + 2 * full_swath_bytes_vert_wc_c\n\t\t\t\t\t<= DETBufferSize) {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 0;\n\t} else {\n\t\treq128_vert_wc_l = 1;\n\t\treq128_vert_wc_c = 1;\n\t}\n\n\tif (BytePerPixelY == 2 || (BytePerPixelY == 4 && TilingFormat != dm_sw_64kb_r_x)) {\n\t\tsegment_order_horz_contiguous_luma = 0;\n\t} else {\n\t\tsegment_order_horz_contiguous_luma = 1;\n\t}\n\tif ((BytePerPixelY == 8\n\t\t\t&& (TilingFormat == dm_sw_64kb_d || TilingFormat == dm_sw_64kb_d_x\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_d_t\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_r_x))\n\t\t\t|| (BytePerPixelY == 4 && TilingFormat == dm_sw_64kb_r_x)) {\n\t\tsegment_order_vert_contiguous_luma = 0;\n\t} else {\n\t\tsegment_order_vert_contiguous_luma = 1;\n\t}\n\tif (BytePerPixelC == 2 || (BytePerPixelC == 4 && TilingFormat != dm_sw_64kb_r_x)) {\n\t\tsegment_order_horz_contiguous_chroma = 0;\n\t} else {\n\t\tsegment_order_horz_contiguous_chroma = 1;\n\t}\n\tif ((BytePerPixelC == 8\n\t\t\t&& (TilingFormat == dm_sw_64kb_d || TilingFormat == dm_sw_64kb_d_x\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_d_t\n\t\t\t\t\t|| TilingFormat == dm_sw_64kb_r_x))\n\t\t\t|| (BytePerPixelC == 4 && TilingFormat == dm_sw_64kb_r_x)) {\n\t\tsegment_order_vert_contiguous_chroma = 0;\n\t} else {\n\t\tsegment_order_vert_contiguous_chroma = 1;\n\t}\n\n\tif (DCCProgrammingAssumesScanDirectionUnknown == true) {\n\t\tif (req128_horz_wc_l == 0 && req128_vert_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if ((req128_horz_wc_l == 1 && segment_order_horz_contiguous_luma == 0)\n\t\t\t\t|| (req128_vert_wc_l == 1 && segment_order_vert_contiguous_luma == 0)) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_horz_wc_c == 0 && req128_vert_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if ((req128_horz_wc_c == 1 && segment_order_horz_contiguous_chroma == 0)\n\t\t\t\t|| (req128_vert_wc_c == 1\n\t\t\t\t\t\t&& segment_order_vert_contiguous_chroma == 0)) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t} else if (ScanOrientation != dm_vert) {\n\t\tif (req128_horz_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if (segment_order_horz_contiguous_luma == 0) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_horz_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if (segment_order_horz_contiguous_chroma == 0) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t} else {\n\t\tif (req128_vert_wc_l == 0) {\n\t\t\tRequestLuma = REQ_256Bytes;\n\t\t} else if (segment_order_vert_contiguous_luma == 0) {\n\t\t\tRequestLuma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestLuma = REQ_128BytesContiguous;\n\t\t}\n\t\tif (req128_vert_wc_c == 0) {\n\t\t\tRequestChroma = REQ_256Bytes;\n\t\t} else if (segment_order_vert_contiguous_chroma == 0) {\n\t\t\tRequestChroma = REQ_128BytesNonContiguous;\n\t\t} else {\n\t\t\tRequestChroma = REQ_128BytesContiguous;\n\t\t}\n\t}\n\n\tif (RequestLuma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 256;\n\t\t*IndependentBlockLuma = 0;\n\t} else if (RequestLuma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 128;\n\t\t*IndependentBlockLuma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockLuma = 256;\n\t\t*MaxCompressedBlockLuma = 64;\n\t\t*IndependentBlockLuma = 64;\n\t}\n\n\tif (RequestChroma == REQ_256Bytes) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 256;\n\t\t*IndependentBlockChroma = 0;\n\t} else if (RequestChroma == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 128;\n\t\t*IndependentBlockChroma = 128;\n\t} else {\n\t\t*MaxUncompressedBlockChroma = 256;\n\t\t*MaxCompressedBlockChroma = 64;\n\t\t*IndependentBlockChroma = 64;\n\t}\n\n\tif (DCCEnabled != true || BytePerPixelC == 0) {\n\t\t*MaxUncompressedBlockChroma = 0;\n\t\t*MaxCompressedBlockChroma = 0;\n\t\t*IndependentBlockChroma = 0;\n\t}\n\n\tif (DCCEnabled != true) {\n\t\t*MaxUncompressedBlockLuma = 0;\n\t\t*MaxCompressedBlockLuma = 0;\n\t\t*IndependentBlockLuma = 0;\n\t}\n}\n\n\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath)\n{\n\tunsigned int MaxPartialSwath = 0;\n\n\tif (ProgressiveToInterlaceUnitInOPP)\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1) / 2.0, 1);\n\telse\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1 + Interlace * 0.5 * VRatio) / 2.0, 1);\n\n\tif (!mode_lib->vba.IgnoreViewportPositioning) {\n\n\t\t*MaxNumSwath = dml_ceil((*VInitPreFill - 1.0) / SwathHeight, 1) + 1.0;\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 2) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 2)\n\t\t\t\t\t% SwathHeight;\n\t\tMaxPartialSwath = dml_max(1U, MaxPartialSwath);\n\n\t} else {\n\n\t\tif (ViewportYStart != 0)\n\t\t\tdml_print(\n\t\t\t\t\t\"WARNING DML: using viewport y position of 0 even though actual viewport y position is non-zero in prefetch source lines calculation\\n\");\n\n\t\t*MaxNumSwath = dml_ceil(*VInitPreFill / SwathHeight, 1);\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 1) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 1)\n\t\t\t\t\t% SwathHeight;\n\t}\n\n\treturn *MaxNumSwath * SwathHeight + MaxPartialSwath;\n}\n\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int SwathWidth,\n\t\tunsigned int ViewportHeight,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tunsigned int GPUVMMinPageSize,\n\t\tunsigned int HostVMMinPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tunsigned int *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tunsigned int *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tunsigned int *DPDE0BytesFrame,\n\t\tunsigned int *MetaPTEBytesFrame)\n{\n\tunsigned int MPDEBytesFrame = 0;\n\tunsigned int DCCMetaSurfaceBytes = 0;\n\tunsigned int MacroTileSizeBytes = 0;\n\tunsigned int MacroTileHeight = 0;\n\tunsigned int ExtraDPDEBytesFrame = 0;\n\tunsigned int PDEAndMetaPTEBytesFrame = 0;\n\tunsigned int PixelPTEReqHeightPTEs = 0;\n\tunsigned int HostVMDynamicLevels = 0;\n\n\tdouble FractionOfPTEReturnDrop;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tif (HostVMMinPageSize < 2048) {\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\t} else if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576) {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\t} else {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t\t}\n\t}\n\n\t*MetaRequestHeight = 8 * BlockHeight256Bytes;\n\t*MetaRequestWidth = 8 * BlockWidth256Bytes;\n\tif (ScanDirection != dm_vert) {\n\t\t*meta_row_height = *MetaRequestHeight;\n\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestWidth)\n\t\t\t\t+ *MetaRequestWidth;\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestHeight * BytePerPixel / 256.0;\n\t} else {\n\t\t*meta_row_height = *MetaRequestWidth;\n\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestHeight)\n\t\t\t\t+ *MetaRequestHeight;\n\t\t*MetaRowByte = *meta_row_width * *MetaRequestWidth * BytePerPixel / 256.0;\n\t}\n\tDCCMetaSurfaceBytes = DCCMetaPitch * (dml_ceil(ViewportHeight - 1, 64 * BlockHeight256Bytes)\n\t\t\t\t\t+ 64 * BlockHeight256Bytes) * BytePerPixel / 256;\n\tif (GPUVMEnable == true) {\n\t\t*MetaPTEBytesFrame = (dml_ceil((double) (DCCMetaSurfaceBytes - 4.0 * 1024.0) / (8 * 4.0 * 1024), 1) + 1) * 64;\n\t\tMPDEBytesFrame = 128 * (mode_lib->vba.GPUVMMaxPageTableLevels - 1);\n\t} else {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t}\n\n\tif (DCCEnable != true) {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t\t*MetaRowByte = 0;\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\tMacroTileSizeBytes = 256;\n\t\tMacroTileHeight = BlockHeight256Bytes;\n\t} else {\n\t\tMacroTileSizeBytes = 65536;\n\t\tMacroTileHeight = 16 * BlockHeight256Bytes;\n\t}\n\t*MacroTileWidth = MacroTileSizeBytes / BytePerPixel / MacroTileHeight;\n\n\tif (GPUVMEnable == true && mode_lib->vba.GPUVMMaxPageTableLevels > 1) {\n\t\tif (ScanDirection != dm_vert) {\n\t\t\t*DPDE0BytesFrame = 64 * (dml_ceil(((Pitch * (dml_ceil(ViewportHeight - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes) / (8 * 2097152), 1) + 1);\n\t\t} else {\n\t\t\t*DPDE0BytesFrame = 64 * (dml_ceil(((Pitch * (dml_ceil((double) SwathWidth - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes) / (8 * 2097152), 1) + 1);\n\t\t}\n\t\tExtraDPDEBytesFrame = 128 * (mode_lib->vba.GPUVMMaxPageTableLevels - 2);\n\t} else {\n\t\t*DPDE0BytesFrame = 0;\n\t\tExtraDPDEBytesFrame = 0;\n\t}\n\n\tPDEAndMetaPTEBytesFrame = *MetaPTEBytesFrame + MPDEBytesFrame + *DPDE0BytesFrame\n\t\t\t+ ExtraDPDEBytesFrame;\n\n\tif (HostVMEnable == true) {\n\t\tPDEAndMetaPTEBytesFrame = PDEAndMetaPTEBytesFrame * (1 + 8 * HostVMDynamicLevels);\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = 1;\n\t\t*PixelPTEReqWidth = 32768.0 / BytePerPixel;\n\t\t*PTERequestSize = 64;\n\t\tFractionOfPTEReturnDrop = 0;\n\t} else if (MacroTileSizeBytes == 4096) {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t*PTERequestSize = 64;\n\t\tif (ScanDirection != dm_vert)\n\t\t\tFractionOfPTEReturnDrop = 0;\n\t\telse\n\t\t\tFractionOfPTEReturnDrop = 7 / 8;\n\t} else if (GPUVMMinPageSize == 4 && MacroTileSizeBytes > 4096) {\n\t\tPixelPTEReqHeightPTEs = 16;\n\t\t*PixelPTEReqHeight = 16 * BlockHeight256Bytes;\n\t\t*PixelPTEReqWidth = 16 * BlockWidth256Bytes;\n\t\t*PTERequestSize = 128;\n\t\tFractionOfPTEReturnDrop = 0;\n\t} else {\n\t\tPixelPTEReqHeightPTEs = 1;\n\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t*PTERequestSize = 64;\n\t\tFractionOfPTEReturnDrop = 0;\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear) {\n\t\tif (PTEBufferSizeInRequests == 0)\n\t\t\t*dpte_row_height = 1;\n\t\telse\n\t\t\t*dpte_row_height = dml_min(128, 1 << (unsigned int) dml_floor(dml_log2(PTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch), 1));\n\t\t*dpte_row_width_ub = (dml_ceil(((double) SwathWidth - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t} else if (ScanDirection != dm_vert) {\n\t\t*dpte_row_height = *PixelPTEReqHeight;\n\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t} else {\n\t\t*dpte_row_height = dml_min(*PixelPTEReqWidth, *MacroTileWidth);\n\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqHeight, 1) + 1) * *PixelPTEReqHeight;\n\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqHeight * *PTERequestSize;\n\t}\n\tif (*PixelPTEBytesPerRow * (1 - FractionOfPTEReturnDrop)\n\t\t\t<= 64 * PTEBufferSizeInRequests) {\n\t\t*PTEBufferSizeNotExceeded = true;\n\t} else {\n\t\t*PTEBufferSizeNotExceeded = false;\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*PixelPTEBytesPerRow = 0;\n\t\t*PTEBufferSizeNotExceeded = true;\n\t}\n\tdml_print(\"DML: vm_bytes = meta_pte_bytes_per_frame (per_pipe) = MetaPTEBytesFrame = : %i\\n\", *MetaPTEBytesFrame);\n\n\tif (HostVMEnable == true) {\n\t\t*PixelPTEBytesPerRow = *PixelPTEBytesPerRow * (1 + 8 * HostVMDynamicLevels);\n\t}\n\n\tif (HostVMEnable == true) {\n\t\t*vm_group_bytes = 512;\n\t\t*dpte_group_bytes = 512;\n\t} else if (GPUVMEnable == true) {\n\t\t*vm_group_bytes = 2048;\n\t\tif (SurfaceTiling != dm_sw_linear && PixelPTEReqHeightPTEs == 1 && ScanDirection == dm_vert) {\n\t\t\t*dpte_group_bytes = 512;\n\t\t} else {\n\t\t\t*dpte_group_bytes = 2048;\n\t\t}\n\t} else {\n\t\t*vm_group_bytes = 0;\n\t\t*dpte_group_bytes = 0;\n\t}\n\n\treturn PDEAndMetaPTEBytesFrame;\n}\n\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(\n\t\tstruct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tunsigned int j, k;\n\tlong ReorderBytes = 0;\n\tunsigned int PrefetchMode = v->PrefetchModePerState[v->VoltageLevel][v->maxMpcComb];\n\tdouble MaxTotalRDBandwidth = 0;\n\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0;\n\tbool DestinationLineTimesForPrefetchLessThan2 = false;\n\tbool VRatioPrefetchMoreThan4 = false;\n\tdouble TWait;\n\n\tv->WritebackDISPCLK = 0.0;\n\tv->DISPCLKWithRamping = 0;\n\tv->DISPCLKWithoutRamping = 0;\n\tv->GlobalDPPCLK = 0.0;\n\t \n\tv->IdealSDPPortBandwidthPerState[v->VoltageLevel][v->maxMpcComb] = dml_min3(\n\t\t\tv->ReturnBusWidth * v->DCFCLK,\n\t\t\tv->DRAMSpeedPerState[v->VoltageLevel] * v->NumberOfChannels * v->DRAMChannelWidth,\n\t\t\tv->FabricClockPerState[v->VoltageLevel] * v->FabricDatapathToDCNDataReturn);\n\tif (v->HostVMEnable != true) {\n\t\tv->ReturnBW = v->IdealSDPPortBandwidthPerState[v->VoltageLevel][v->maxMpcComb] * v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly / 100;\n\t} else {\n\t\tv->ReturnBW = v->IdealSDPPortBandwidthPerState[v->VoltageLevel][v->maxMpcComb] * v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / 100;\n\t}\n\t \n\n\t\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->WritebackEnable[k]) {\n\t\t\tv->WritebackDISPCLK = dml_max(v->WritebackDISPCLK,\n\t\t\t\tdml30_CalculateWriteBackDISPCLK(\n\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\tv->WritebackHTaps[k],\n\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\tv->WritebackSourceWidth[k],\n\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\tv->WritebackLineBufferSize));\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->HRatio[k] > 1) {\n\t\t\tv->PSCL_THROUGHPUT_LUMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput,\n\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatio[k] / dml_ceil(v->htaps[k] / 6.0, 1));\n\t\t} else {\n\t\t\tv->PSCL_THROUGHPUT_LUMA[k] = dml_min(\n\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tv->MaxPSCLToLBThroughput);\n\t\t}\n\n\t\tv->DPPCLKUsingSingleDPPLuma = v->PixelClock[k]\n\t\t\t* dml_max(v->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]),\n\t\t\t\tdml_max(v->HRatio[k] * v->VRatio[k] / v->PSCL_THROUGHPUT_LUMA[k], 1.0));\n\n\t\tif ((v->htaps[k] > 6 || v->vtaps[k] > 6)\n\t\t\t\t&& v->DPPCLKUsingSingleDPPLuma < 2 * v->PixelClock[k]) {\n\t\t\tv->DPPCLKUsingSingleDPPLuma = 2 * v->PixelClock[k];\n\t\t}\n\n\t\tif ((v->SourcePixelFormat[k] != dm_420_8\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_420_10\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_420_12\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe_alpha)) {\n\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = 0.0;\n\t\t\tv->DPPCLKUsingSingleDPP[k] = v->DPPCLKUsingSingleDPPLuma;\n\t\t} else {\n\t\t\tif (v->HRatioChroma[k] > 1) {\n\t\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatioChroma[k] / dml_ceil(v->HTAPsChroma[k] / 6.0, 1.0));\n\t\t\t} else {\n\t\t\t\tv->PSCL_THROUGHPUT_CHROMA[k] = dml_min(\n\t\t\t\t\t\tv->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tv->MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tv->DPPCLKUsingSingleDPPChroma = v->PixelClock[k]\n\t\t\t\t* dml_max3(v->VTAPsChroma[k] / 6.0 * dml_min(1.0, v->HRatioChroma[k]),\n\t\t\t\t\tv->HRatioChroma[k] * v->VRatioChroma[k] / v->PSCL_THROUGHPUT_CHROMA[k], 1.0);\n\n\t\t\tif ((v->HTAPsChroma[k] > 6 || v->VTAPsChroma[k] > 6)\n\t\t\t\t\t&& v->DPPCLKUsingSingleDPPChroma\n\t\t\t\t\t\t\t< 2 * v->PixelClock[k]) {\n\t\t\t\tv->DPPCLKUsingSingleDPPChroma = 2\n\t\t\t\t\t\t* v->PixelClock[k];\n\t\t\t}\n\n\t\t\tv->DPPCLKUsingSingleDPP[k] = dml_max(\n\t\t\t\t\tv->DPPCLKUsingSingleDPPLuma,\n\t\t\t\t\tv->DPPCLKUsingSingleDPPChroma);\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] != k)\n\t\t\tcontinue;\n\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_4to1) {\n\t\t\tv->DISPCLKWithRamping = dml_max(v->DISPCLKWithRamping,\n\t\t\t\tv->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(v->DISPCLKWithoutRamping,\n\t\t\t\tv->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t} else if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\tv->DISPCLKWithRamping = dml_max(v->DISPCLKWithRamping,\n\t\t\t\tv->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(v->DISPCLKWithoutRamping,\n\t\t\t\tv->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t} else {\n\t\t\tv->DISPCLKWithRamping = dml_max(v->DISPCLKWithRamping,\n\t\t\t\tv->PixelClock[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100)\n\t\t\t\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100));\n\t\t\tv->DISPCLKWithoutRamping = dml_max(v->DISPCLKWithoutRamping,\n\t\t\t\tv->PixelClock[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100));\n\t\t}\n\t}\n\n\tv->DISPCLKWithRamping = dml_max(\n\t\t\tv->DISPCLKWithRamping,\n\t\t\tv->WritebackDISPCLK);\n\tv->DISPCLKWithoutRamping = dml_max(\n\t\t\tv->DISPCLKWithoutRamping,\n\t\t\tv->WritebackDISPCLK);\n\n\tASSERT(v->DISPCLKDPPCLKVCOSpeed != 0);\n\tv->DISPCLKWithRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(\n\t\t\tv->DISPCLKWithRamping,\n\t\t\tv->DISPCLKDPPCLKVCOSpeed);\n\tv->DISPCLKWithoutRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(\n\t\t\tv->DISPCLKWithoutRamping,\n\t\t\tv->DISPCLKDPPCLKVCOSpeed);\n\tv->MaxDispclkRoundedToDFSGranularity = RoundToDFSGranularityDown(\n\t\t\tv->soc.clock_limits[mode_lib->soc.num_states - 1].dispclk_mhz,\n\t\t\tv->DISPCLKDPPCLKVCOSpeed);\n\tif (v->DISPCLKWithoutRampingRoundedToDFSGranularity\n\t\t\t> v->MaxDispclkRoundedToDFSGranularity) {\n\t\tv->DISPCLK_calculated =\n\t\t\t\tv->DISPCLKWithoutRampingRoundedToDFSGranularity;\n\t} else if (v->DISPCLKWithRampingRoundedToDFSGranularity\n\t\t\t> v->MaxDispclkRoundedToDFSGranularity) {\n\t\tv->DISPCLK_calculated = v->MaxDispclkRoundedToDFSGranularity;\n\t} else {\n\t\tv->DISPCLK_calculated =\n\t\t\t\tv->DISPCLKWithRampingRoundedToDFSGranularity;\n\t}\n\tv->DISPCLK = v->DISPCLK_calculated;\n\tDTRACE(\"   dispclk_mhz (calculated) = %f\", v->DISPCLK_calculated);\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->DPPCLK_calculated[k] = v->DPPCLKUsingSingleDPP[k]\n\t\t\t\t/ v->DPPPerPlane[k]\n\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\tv->GlobalDPPCLK = dml_max(\n\t\t\t\tv->GlobalDPPCLK,\n\t\t\t\tv->DPPCLK_calculated[k]);\n\t}\n\tv->GlobalDPPCLK = RoundToDFSGranularityUp(\n\t\t\tv->GlobalDPPCLK,\n\t\t\tv->DISPCLKDPPCLKVCOSpeed);\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->DPPCLK_calculated[k] = v->GlobalDPPCLK / 255\n\t\t\t\t* dml_ceil(\n\t\t\t\t\t\tv->DPPCLK_calculated[k] * 255.0\n\t\t\t\t\t\t\t\t/ v->GlobalDPPCLK,\n\t\t\t\t\t\t1);\n\t\tDTRACE(\"   dppclk_mhz[%i] (calculated) = %f\", k, v->DPPCLK_calculated[k]);\n\t\tv->DPPCLK[k] = v->DPPCLK_calculated[k];\n\t}\n\n\t\n\tDTRACE(\"   dcfclk_mhz         = %f\", v->DCFCLK);\n\tDTRACE(\"   return_bus_bw      = %f\", v->ReturnBW);\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t&v->BytePerPixelY[k],\n\t\t\t\t&v->BytePerPixelC[k],\n\t\t\t\t&v->BytePerPixelDETY[k],\n\t\t\t\t&v->BytePerPixelDETC[k],\n\t\t\t\t&v->BlockHeight256BytesY[k],\n\t\t\t\t&v->BlockHeight256BytesC[k],\n\t\t\t\t&v->BlockWidth256BytesY[k],\n\t\t\t\t&v->BlockWidth256BytesC[k]);\n\t}\n\n\tCalculateSwathWidth(\n\t\t\tfalse,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->SourcePixelFormat,\n\t\t\tv->SourceScan,\n\t\t\tv->ViewportWidth,\n\t\t\tv->ViewportHeight,\n\t\t\tv->SurfaceWidthY,\n\t\t\tv->SurfaceWidthC,\n\t\t\tv->SurfaceHeightY,\n\t\t\tv->SurfaceHeightC,\n\t\t\tv->ODMCombineEnabled,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->BlendingAndTiming,\n\t\t\tv->HActive,\n\t\t\tv->HRatio,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->SwathWidthSingleDPPY,\n\t\t\tv->SwathWidthSingleDPPC,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->dummyinteger3,\n\t\t\tv->dummyinteger4,\n\t\t\tv->swath_width_luma_ub,\n\t\t\tv->swath_width_chroma_ub);\n\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->ReadBandwidthPlaneLuma[k] = v->SwathWidthSingleDPPY[k] * v->BytePerPixelY[k] / (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t\tv->ReadBandwidthPlaneChroma[k] = v->SwathWidthSingleDPPC[k] * v->BytePerPixelC[k] / (v->HTotal[k] / v->PixelClock[k]) * v->VRatioChroma[k];\n\t\tDTRACE(\"read_bw[%i] = %fBps\", k, v->ReadBandwidthPlaneLuma[k] + v->ReadBandwidthPlaneChroma[k]);\n\t}\n\n\n\t\n\tCalculateDCFCLKDeepSleep(\n\t\t\tmode_lib,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->PixelClock,\n\t\t\tv->PSCL_THROUGHPUT_LUMA,\n\t\t\tv->PSCL_THROUGHPUT_CHROMA,\n\t\t\tv->DPPCLK,\n\t\t\tv->ReadBandwidthPlaneLuma,\n\t\t\tv->ReadBandwidthPlaneChroma,\n\t\t\tv->ReturnBusWidth,\n\t\t\t&v->DCFCLKDeepSleep);\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif ((v->BlendingAndTiming[k] != k) || !v->DSCEnabled[k]) {\n\t\t\tv->DSCCLK_calculated[k] = 0.0;\n\t\t} else {\n\t\t\tif (v->OutputFormat[k] == dm_420)\n\t\t\t\tv->DSCFormatFactor = 2;\n\t\t\telse if (v->OutputFormat[k] == dm_444)\n\t\t\t\tv->DSCFormatFactor = 1;\n\t\t\telse if (v->OutputFormat[k] == dm_n422)\n\t\t\t\tv->DSCFormatFactor = 2;\n\t\t\telse\n\t\t\t\tv->DSCFormatFactor = 1;\n\t\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_4to1)\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 12\n\t\t\t\t\t/ v->DSCFormatFactor / (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t\telse if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 6\n\t\t\t\t\t/ v->DSCFormatFactor / (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t\telse\n\t\t\t\tv->DSCCLK_calculated[k] = v->PixelClockBackEnd[k] / 3\n\t\t\t\t\t/ v->DSCFormatFactor / (1 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\t}\n\t}\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tdouble BPP = v->OutputBppPerState[k][v->VoltageLevel];\n\n\t\tif (v->DSCEnabled[k] && BPP != 0) {\n\t\t\tif (v->ODMCombineEnabled[k] == dm_odm_combine_mode_disabled) {\n\t\t\t\tv->DSCDelay[k] = dscceComputeDelay(v->DSCInputBitPerComponent[k],\n\t\t\t\t\t\tBPP,\n\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\tv->Output[k])\n\t\t\t\t\t+ dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t} else if (v->ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\t\tv->DSCDelay[k] = 2 * dscceComputeDelay(v->DSCInputBitPerComponent[k],\n\t\t\t\t\t\tBPP,\n\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 2.0,\n\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\tv->Output[k])\n\t\t\t\t\t+ dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t} else {\n\t\t\t\tv->DSCDelay[k] = 4 * dscceComputeDelay(v->DSCInputBitPerComponent[k],\n\t\t\t\t\t\tBPP,\n\t\t\t\t\t\tdml_ceil((double) v->HActive[k] / v->NumberOfDSCSlices[k], 1),\n\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 4.0,\n\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\tv->Output[k])\n\t\t\t\t\t+ dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t}\n\t\t\tv->DSCDelay[k] = v->DSCDelay[k] * v->PixelClock[k] / v->PixelClockBackEnd[k];\n\t\t} else {\n\t\t\tv->DSCDelay[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) \n\t\t\tif (j != k && v->BlendingAndTiming[k] == j\n\t\t\t\t\t&& v->DSCEnabled[j])\n\t\t\t\tv->DSCDelay[k] = v->DSCDelay[j];\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tunsigned int PDEAndMetaPTEBytesFrameY = 0;\n\t\tunsigned int PixelPTEBytesPerRowY = 0;\n\t\tunsigned int MetaRowByteY = 0;\n\t\tunsigned int MetaRowByteC = 0;\n\t\tunsigned int PDEAndMetaPTEBytesFrameC = 0;\n\t\tunsigned int PixelPTEBytesPerRowC = 0;\n\t\tbool         PTEBufferSizeNotExceededY = 0;\n\t\tbool         PTEBufferSizeNotExceededC = 0;\n\n\n\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12 || v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\tif ((v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12) && v->SourceScan[k] != dm_vert) {\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma = (v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma) / 2;\n\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsForLuma;\n\t\t\t} else {\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma;\n\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsChroma;\n\n\t\t\t}\n\t\t\tPDEAndMetaPTEBytesFrameC = CalculateVMAndRowBytes(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\tv->BlockHeight256BytesC[k],\n\t\t\t\t\tv->BlockWidth256BytesC[k],\n\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\tv->SwathWidthC[k],\n\t\t\t\t\tv->ViewportHeightChroma[k],\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma,\n\t\t\t\t\tv->PitchC[k],\n\t\t\t\t\tv->DCCMetaPitchC[k],\n\t\t\t\t\t&v->MacroTileWidthC[k],\n\t\t\t\t\t&MetaRowByteC,\n\t\t\t\t\t&PixelPTEBytesPerRowC,\n\t\t\t\t\t&PTEBufferSizeNotExceededC,\n\t\t\t\t\t&v->dpte_row_width_chroma_ub[k],\n\t\t\t\t\t&v->dpte_row_height_chroma[k],\n\t\t\t\t\t&v->meta_req_width_chroma[k],\n\t\t\t\t\t&v->meta_req_height_chroma[k],\n\t\t\t\t\t&v->meta_row_width_chroma[k],\n\t\t\t\t\t&v->meta_row_height_chroma[k],\n\t\t\t\t\t&v->dummyinteger1,\n\t\t\t\t\t&v->dummyinteger2,\n\t\t\t\t\t&v->PixelPTEReqWidthC[k],\n\t\t\t\t\t&v->PixelPTEReqHeightC[k],\n\t\t\t\t\t&v->PTERequestSizeC[k],\n\t\t\t\t\t&v->dpde0_bytes_per_frame_ub_c[k],\n\t\t\t\t\t&v->meta_pte_bytes_per_frame_ub_c[k]);\n\n\t\t\tv->PrefetchSourceLinesC[k] = CalculatePrefetchSourceLines(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\tv->VTAPsChroma[k],\n\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->ViewportYStartC[k],\n\t\t\t\t\t&v->VInitPreFillC[k],\n\t\t\t\t\t&v->MaxNumSwathC[k]);\n\t\t} else {\n\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma;\n\t\t\tv->PTEBufferSizeInRequestsForChroma = 0;\n\t\t\tPixelPTEBytesPerRowC = 0;\n\t\t\tPDEAndMetaPTEBytesFrameC = 0;\n\t\t\tMetaRowByteC = 0;\n\t\t\tv->MaxNumSwathC[k] = 0;\n\t\t\tv->PrefetchSourceLinesC[k] = 0;\n\t\t}\n\n\t\tPDEAndMetaPTEBytesFrameY = CalculateVMAndRowBytes(\n\t\t\t\tmode_lib,\n\t\t\t\tv->DCCEnable[k],\n\t\t\t\tv->BlockHeight256BytesY[k],\n\t\t\t\tv->BlockWidth256BytesY[k],\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\tv->SourceScan[k],\n\t\t\t\tv->SwathWidthY[k],\n\t\t\t\tv->ViewportHeight[k],\n\t\t\t\tv->GPUVMEnable,\n\t\t\t\tv->HostVMEnable,\n\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\tv->PTEBufferSizeInRequestsForLuma,\n\t\t\t\tv->PitchY[k],\n\t\t\t\tv->DCCMetaPitchY[k],\n\t\t\t\t&v->MacroTileWidthY[k],\n\t\t\t\t&MetaRowByteY,\n\t\t\t\t&PixelPTEBytesPerRowY,\n\t\t\t\t&PTEBufferSizeNotExceededY,\n\t\t\t\t&v->dpte_row_width_luma_ub[k],\n\t\t\t\t&v->dpte_row_height[k],\n\t\t\t\t&v->meta_req_width[k],\n\t\t\t\t&v->meta_req_height[k],\n\t\t\t\t&v->meta_row_width[k],\n\t\t\t\t&v->meta_row_height[k],\n\t\t\t\t&v->vm_group_bytes[k],\n\t\t\t\t&v->dpte_group_bytes[k],\n\t\t\t\t&v->PixelPTEReqWidthY[k],\n\t\t\t\t&v->PixelPTEReqHeightY[k],\n\t\t\t\t&v->PTERequestSizeY[k],\n\t\t\t\t&v->dpde0_bytes_per_frame_ub_l[k],\n\t\t\t\t&v->meta_pte_bytes_per_frame_ub_l[k]);\n\n\t\tv->PrefetchSourceLinesY[k] = CalculatePrefetchSourceLines(\n\t\t\t\tmode_lib,\n\t\t\t\tv->VRatio[k],\n\t\t\t\tv->vtaps[k],\n\t\t\t\tv->Interlace[k],\n\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\tv->SwathHeightY[k],\n\t\t\t\tv->ViewportYStartY[k],\n\t\t\t\t&v->VInitPreFillY[k],\n\t\t\t\t&v->MaxNumSwathY[k]);\n\t\tv->PixelPTEBytesPerRow[k] = PixelPTEBytesPerRowY + PixelPTEBytesPerRowC;\n\t\tv->PDEAndMetaPTEBytesFrame[k] = PDEAndMetaPTEBytesFrameY\n\t\t\t\t+ PDEAndMetaPTEBytesFrameC;\n\t\tv->MetaRowByte[k] = MetaRowByteY + MetaRowByteC;\n\n\t\tCalculateRowBandwidth(\n\t\t\t\tv->GPUVMEnable,\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->VRatio[k],\n\t\t\t\tv->VRatioChroma[k],\n\t\t\t\tv->DCCEnable[k],\n\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\tMetaRowByteY,\n\t\t\t\tMetaRowByteC,\n\t\t\t\tv->meta_row_height[k],\n\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\tPixelPTEBytesPerRowY,\n\t\t\t\tPixelPTEBytesPerRowC,\n\t\t\t\tv->dpte_row_height[k],\n\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t&v->meta_row_bw[k],\n\t\t\t\t&v->dpte_row_bw[k]);\n\t}\n\n\tv->TotalDCCActiveDPP = 0;\n\tv->TotalActiveDPP = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->TotalActiveDPP = v->TotalActiveDPP\n\t\t\t\t+ v->DPPPerPlane[k];\n\t\tif (v->DCCEnable[k])\n\t\t\tv->TotalDCCActiveDPP = v->TotalDCCActiveDPP\n\t\t\t\t\t+ v->DPPPerPlane[k];\n\t}\n\n\n\tReorderBytes = v->NumberOfChannels * dml_max3(\n\t\tv->UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\tv->UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\tv->UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\n\tv->UrgentExtraLatency = CalculateExtraLatency(\n\t\tv->RoundTripPingLatencyCycles,\n\t\tReorderBytes,\n\t\tv->DCFCLK,\n\t\tv->TotalActiveDPP,\n\t\tv->PixelChunkSizeInKByte,\n\t\tv->TotalDCCActiveDPP,\n\t\tv->MetaChunkSize,\n\t\tv->ReturnBW,\n\t\tv->GPUVMEnable,\n\t\tv->HostVMEnable,\n\t\tv->NumberOfActivePlanes,\n\t\tv->DPPPerPlane,\n\t\tv->dpte_group_bytes,\n\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tv->HostVMMinPageSize,\n\t\tv->HostVMMaxNonCachedPageTableLevels);\n\n\tv->TCalc = 24.0 / v->DCFCLKDeepSleep;\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackLatency +\n\t\t\t\t\t\tCalculateWriteBackDelay(v->WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[k],\n\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k]) / v->DISPCLK;\n\t\t\t} else\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = 0;\n\t\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) {\n\t\t\t\tif (v->BlendingAndTiming[j] == k\n\t\t\t\t\t\t&& v->WritebackEnable[j] == true) {\n\t\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = dml_max(v->WritebackDelay[v->VoltageLevel][k],\n\t\t\t\t\t\t\tv->WritebackLatency + CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[j],\n\t\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[j],\n\t\t\t\t\t\t\t\t\t\t\tv->HTotal[k]) / v->DISPCLK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j)\n\t\t\tif (v->BlendingAndTiming[k] == j)\n\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackDelay[v->VoltageLevel][j];\n\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->MaxVStartupLines[k] = v->VTotal[k] - v->VActive[k] - dml_max(1.0, dml_ceil((double) v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock[k]), 1));\n\t}\n\n\tv->MaximumMaxVStartupLines = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k)\n\t\tv->MaximumMaxVStartupLines = dml_max(v->MaximumMaxVStartupLines, v->MaxVStartupLines[k]);\n\n\tif (v->DRAMClockChangeLatencyOverride > 0.0) {\n\t\tv->FinalDRAMClockChangeLatency = v->DRAMClockChangeLatencyOverride;\n\t} else {\n\t\tv->FinalDRAMClockChangeLatency = v->DRAMClockChangeLatency;\n\t}\n\tv->UrgentLatency = CalculateUrgentLatency(v->UrgentLatencyPixelDataOnly, v->UrgentLatencyPixelMixedWithVMData, v->UrgentLatencyVMDataOnly, v->DoUrgentLatencyAdjustment, v->UrgentLatencyAdjustmentFabricClockComponent, v->UrgentLatencyAdjustmentFabricClockReference, v->FabricClock);\n\n\n\tv->FractionOfUrgentBandwidth = 0.0;\n\tv->FractionOfUrgentBandwidthImmediateFlip = 0.0;\n\n\tv->VStartupLines = 13;\n\n\tdo {\n\t\tMaxTotalRDBandwidth = 0;\n\t\tMaxTotalRDBandwidthNoUrgentBurst = 0;\n\t\tDestinationLineTimesForPrefetchLessThan2 = false;\n\t\tVRatioPrefetchMoreThan4 = false;\n\t\tTWait = CalculateTWait(\n\t\t\t\tPrefetchMode,\n\t\t\t\tv->FinalDRAMClockChangeLatency,\n\t\t\t\tv->UrgentLatency,\n\t\t\t\tv->SREnterPlusExitTime);\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tPipe myPipe = { 0 };\n\n\t\t\tmyPipe.DPPCLK = v->DPPCLK[k];\n\t\t\tmyPipe.DISPCLK = v->DISPCLK;\n\t\t\tmyPipe.PixelClock = v->PixelClock[k];\n\t\t\tmyPipe.DCFCLKDeepSleep = v->DCFCLKDeepSleep;\n\t\t\tmyPipe.DPPPerPlane = v->DPPPerPlane[k];\n\t\t\tmyPipe.ScalerEnabled = v->ScalerEnabled[k];\n\t\t\tmyPipe.SourceScan = v->SourceScan[k];\n\t\t\tmyPipe.BlockWidth256BytesY = v->BlockWidth256BytesY[k];\n\t\t\tmyPipe.BlockHeight256BytesY = v->BlockHeight256BytesY[k];\n\t\t\tmyPipe.BlockWidth256BytesC = v->BlockWidth256BytesC[k];\n\t\t\tmyPipe.BlockHeight256BytesC = v->BlockHeight256BytesC[k];\n\t\t\tmyPipe.InterlaceEnable = v->Interlace[k];\n\t\t\tmyPipe.NumberOfCursors = v->NumberOfCursors[k];\n\t\t\tmyPipe.VBlank = v->VTotal[k] - v->VActive[k];\n\t\t\tmyPipe.HTotal = v->HTotal[k];\n\t\t\tmyPipe.DCCEnable = v->DCCEnable[k];\n\t\t\tmyPipe.ODMCombineEnabled = !!v->ODMCombineEnabled[k];\n\n\t\t\tv->ErrorResult[k] = CalculatePrefetchSchedule(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t&myPipe,\n\t\t\t\t\tv->DSCDelay[k],\n\t\t\t\t\tv->DPPCLKDelaySubtotal\n\t\t\t\t\t\t\t+ v->DPPCLKDelayCNVCFormater,\n\t\t\t\t\tv->DPPCLKDelaySCL,\n\t\t\t\t\tv->DPPCLKDelaySCLLBOnly,\n\t\t\t\t\tv->DPPCLKDelayCNVCCursor,\n\t\t\t\t\tv->DISPCLKDelaySubtotal,\n\t\t\t\t\t(unsigned int) (v->SwathWidthY[k] / v->HRatio[k]),\n\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\t\t\tdml_min(v->VStartupLines, v->MaxVStartupLines[k]),\n\t\t\t\t\tv->MaxVStartupLines[k],\n\t\t\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->DynamicMetadataEnable[k],\n\t\t\t\t\tv->DynamicMetadataVMEnabled,\n\t\t\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->UrgentExtraLatency,\n\t\t\t\t\tv->TCalc,\n\t\t\t\t\tv->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\tv->MetaRowByte[k],\n\t\t\t\t\tv->PixelPTEBytesPerRow[k],\n\t\t\t\t\tv->PrefetchSourceLinesY[k],\n\t\t\t\t\tv->SwathWidthY[k],\n\t\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\t\tv->VInitPreFillY[k],\n\t\t\t\t\tv->MaxNumSwathY[k],\n\t\t\t\t\tv->PrefetchSourceLinesC[k],\n\t\t\t\t\tv->SwathWidthC[k],\n\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\tv->VInitPreFillC[k],\n\t\t\t\t\tv->MaxNumSwathC[k],\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tTWait,\n\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t&v->DSTXAfterScaler[k],\n\t\t\t\t\t&v->DSTYAfterScaler[k],\n\t\t\t\t\t&v->DestinationLinesForPrefetch[k],\n\t\t\t\t\t&v->PrefetchBandwidth[k],\n\t\t\t\t\t&v->DestinationLinesToRequestVMInVBlank[k],\n\t\t\t\t\t&v->DestinationLinesToRequestRowInVBlank[k],\n\t\t\t\t\t&v->VRatioPrefetchY[k],\n\t\t\t\t\t&v->VRatioPrefetchC[k],\n\t\t\t\t\t&v->RequiredPrefetchPixDataBWLuma[k],\n\t\t\t\t\t&v->RequiredPrefetchPixDataBWChroma[k],\n\t\t\t\t\t&v->NotEnoughTimeForDynamicMetadata[k],\n\t\t\t\t\t&v->Tno_bw[k],\n\t\t\t\t\t&v->prefetch_vmrow_bw[k],\n\t\t\t\t\t&v->Tdmdl_vm[k],\n\t\t\t\t\t&v->Tdmdl[k],\n\t\t\t\t\t&v->VUpdateOffsetPix[k],\n\t\t\t\t\t&v->VUpdateWidthPix[k],\n\t\t\t\t\t&v->VReadyOffsetPix[k]);\n\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\tdouble TotalRepeaterDelayTime = v->MaxInterDCNTileRepeaters * (2 / v->DPPCLK[k] + 3 / v->DISPCLK);\n\t\t\t\tv->VUpdateWidthPix[k] = (14 / v->DCFCLKDeepSleep + 12 / v->DPPCLK[k] + TotalRepeaterDelayTime) * v->PixelClock[k];\n\t\t\t\tv->VReadyOffsetPix[k] = dml_max(150.0 / v->DPPCLK[k], TotalRepeaterDelayTime + 20 / v->DCFCLKDeepSleep + 10 / v->DPPCLK[k]) * v->PixelClock[k];\n\t\t\t\tv->VUpdateOffsetPix[k] = dml_ceil(v->HTotal[k] / 4.0, 1);\n\t\t\t\tv->VStartup[k] = dml_min(v->VStartupLines, v->MaxVStartupLines[k]);\n\t\t\t} else {\n\t\t\t\tint x = v->BlendingAndTiming[k];\n\t\t\t\tdouble TotalRepeaterDelayTime = v->MaxInterDCNTileRepeaters * (2 / v->DPPCLK[k] + 3 / v->DISPCLK);\n\t\t\t\tv->VUpdateWidthPix[k] = (14 / v->DCFCLKDeepSleep + 12 / v->DPPCLK[k] + TotalRepeaterDelayTime) * v->PixelClock[x];\n\t\t\t\tv->VReadyOffsetPix[k] = dml_max(150.0 / v->DPPCLK[k], TotalRepeaterDelayTime + 20 / v->DCFCLKDeepSleep + 10 / v->DPPCLK[k]) * v->PixelClock[x];\n\t\t\t\tv->VUpdateOffsetPix[k] = dml_ceil(v->HTotal[x] / 4.0, 1);\n\t\t\t\tif (!v->MaxVStartupLines[x])\n\t\t\t\t\tv->MaxVStartupLines[x] = v->MaxVStartupLines[k];\n\t\t\t\tv->VStartup[k] = dml_min(v->VStartupLines, v->MaxVStartupLines[x]);\n\t\t\t}\n\t\t}\n\n\t\tv->NotEnoughUrgentLatencyHiding[0][0] = false;\n\t\tv->NotEnoughUrgentLatencyHidingPre = false;\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tv->cursor_bw[k] = v->NumberOfCursors[k]\n\t\t\t\t\t* v->CursorWidth[k][0] * v->CursorBPP[k][0]\n\t\t\t\t\t/ 8.0\n\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t\t* v->VRatio[k];\n\t\t\tv->cursor_bw_pre[k] = v->NumberOfCursors[k]\n\t\t\t\t\t* v->CursorWidth[k][0] * v->CursorBPP[k][0]\n\t\t\t\t\t/ 8.0\n\t\t\t\t\t/ (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t\t* v->VRatioPrefetchY[k];\n\n\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\t\tv->DETBufferSizeY[k],\n\t\t\t\t\tv->DETBufferSizeC[k],\n\t\t\t\t\t&v->UrgentBurstFactorCursor[k],\n\t\t\t\t\t&v->UrgentBurstFactorLuma[k],\n\t\t\t\t\t&v->UrgentBurstFactorChroma[k],\n\t\t\t\t\t&v->NoUrgentLatencyHiding[k]);\n\n\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\tv->swath_width_luma_ub[k],\n\t\t\t\t\tv->swath_width_chroma_ub[k],\n\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\tv->SwathHeightY[k],\n\t\t\t\t\tv->SwathHeightC[k],\n\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\tv->VRatioPrefetchY[k],\n\t\t\t\t\tv->VRatioPrefetchC[k],\n\t\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\t\tv->DETBufferSizeY[k],\n\t\t\t\t\tv->DETBufferSizeC[k],\n\t\t\t\t\t&v->UrgentBurstFactorCursorPre[k],\n\t\t\t\t\t&v->UrgentBurstFactorLumaPre[k],\n\t\t\t\t\t&v->UrgentBurstFactorChromaPre[k],\n\t\t\t\t\t&v->NoUrgentLatencyHidingPre[k]);\n\n\t\t\tMaxTotalRDBandwidth = MaxTotalRDBandwidth +\n\t\t\t\tdml_max3(v->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] *\n\t\t\t\t\tv->UrgentBurstFactorLuma[k] +\n\t\t\t\t\tv->ReadBandwidthPlaneChroma[k] *\n\t\t\t\t\tv->UrgentBurstFactorChroma[k] +\n\t\t\t\t\tv->cursor_bw[k] *\n\t\t\t\t\tv->UrgentBurstFactorCursor[k] +\n\t\t\t\t\tv->DPPPerPlane[k] * (v->meta_row_bw[k] + v->dpte_row_bw[k]),\n\t\t\t\t\tv->DPPPerPlane[k] * (v->RequiredPrefetchPixDataBWLuma[k] * v->UrgentBurstFactorLumaPre[k] +\n\t\t\t\t\t\tv->RequiredPrefetchPixDataBWChroma[k] * v->UrgentBurstFactorChromaPre[k]) + v->cursor_bw_pre[k] *\n\t\t\t\t\tv->UrgentBurstFactorCursorPre[k]);\n\n\t\t\tMaxTotalRDBandwidthNoUrgentBurst = MaxTotalRDBandwidthNoUrgentBurst +\n\t\t\t\tdml_max3(v->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] +\n\t\t\t\t\tv->ReadBandwidthPlaneChroma[k] +\n\t\t\t\t\tv->cursor_bw[k] +\n\t\t\t\t\tv->DPPPerPlane[k] * (v->meta_row_bw[k] + v->dpte_row_bw[k]),\n\t\t\t\t\tv->DPPPerPlane[k] * (v->RequiredPrefetchPixDataBWLuma[k] + v->RequiredPrefetchPixDataBWChroma[k]) + v->cursor_bw_pre[k]);\n\n\t\t\tif (v->DestinationLinesForPrefetch[k] < 2)\n\t\t\t\tDestinationLineTimesForPrefetchLessThan2 = true;\n\t\t\tif (v->VRatioPrefetchY[k] > 4 || v->VRatioPrefetchC[k] > 4)\n\t\t\t\tVRatioPrefetchMoreThan4 = true;\n\t\t\tif (v->NoUrgentLatencyHiding[k] == true)\n\t\t\t\tv->NotEnoughUrgentLatencyHiding[0][0] = true;\n\n\t\t\tif (v->NoUrgentLatencyHidingPre[k] == true)\n\t\t\t\tv->NotEnoughUrgentLatencyHidingPre = true;\n\t\t}\n\t\tv->FractionOfUrgentBandwidth = MaxTotalRDBandwidthNoUrgentBurst / v->ReturnBW;\n\n\n\t\tif (MaxTotalRDBandwidth <= v->ReturnBW && v->NotEnoughUrgentLatencyHiding[0][0] == 0\n\t\t\t\t&& v->NotEnoughUrgentLatencyHidingPre == 0 && !VRatioPrefetchMoreThan4\n\t\t\t\t&& !DestinationLineTimesForPrefetchLessThan2)\n\t\t\tv->PrefetchModeSupported = true;\n\t\telse {\n\t\t\tv->PrefetchModeSupported = false;\n\t\t\tdml_print(\"DML: CalculatePrefetchSchedule ***failed***. Bandwidth violation. Results are NOT valid\\n\");\n\t\t\tdml_print(\"DML: MaxTotalRDBandwidth:%f AvailReturnBandwidth:%f\\n\", MaxTotalRDBandwidth, v->ReturnBW);\n\t\t\tdml_print(\"DML: VRatioPrefetch %s more than 4\\n\", (VRatioPrefetchMoreThan4) ? \"is\" : \"is not\");\n\t\t\tdml_print(\"DML: DestinationLines for Prefetch %s less than 2\\n\", (DestinationLineTimesForPrefetchLessThan2) ? \"is\" : \"is not\");\n\t\t}\n\n\t\tif (v->PrefetchModeSupported == true && v->ImmediateFlipSupport == true) {\n\t\t\tv->BandwidthAvailableForImmediateFlip = v->ReturnBW;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->BandwidthAvailableForImmediateFlip =\n\t\t\t\t\t\tv->BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\t\t\tv->ReadBandwidthPlaneLuma[k] * v->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->ReadBandwidthPlaneChroma[k] * v->UrgentBurstFactorChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw[k] * v->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t\t\t\t\tv->DPPPerPlane[k] * (v->RequiredPrefetchPixDataBWLuma[k] * v->UrgentBurstFactorLumaPre[k] +\n\t\t\t\t\t\t\t\t\t\tv->RequiredPrefetchPixDataBWChroma[k] * v->UrgentBurstFactorChromaPre[k]) +\n\t\t\t\t\t\t\t\t\t\tv->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t}\n\n\t\t\tv->TotImmediateFlipBytes = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->TotImmediateFlipBytes = v->TotImmediateFlipBytes + v->DPPPerPlane[k] * (v->PDEAndMetaPTEBytesFrame[k] + v->MetaRowByte[k] + v->PixelPTEBytesPerRow[k]);\n\t\t\t}\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\tv->UrgentExtraLatency,\n\t\t\t\t\t\tv->UrgentLatency,\n\t\t\t\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\tv->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\t\tv->MetaRowByte[k],\n\t\t\t\t\t\tv->PixelPTEBytesPerRow[k],\n\t\t\t\t\t\tv->BandwidthAvailableForImmediateFlip,\n\t\t\t\t\t\tv->TotImmediateFlipBytes,\n\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\tv->Tno_bw[k],\n\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\tv->dpte_row_height[k],\n\t\t\t\t\t\tv->meta_row_height[k],\n\t\t\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\t\t\t&v->DestinationLinesToRequestVMInImmediateFlip[k],\n\t\t\t\t\t\t&v->DestinationLinesToRequestRowInImmediateFlip[k],\n\t\t\t\t\t\t&v->final_flip_bw[k],\n\t\t\t\t\t\t&v->ImmediateFlipSupportedForPipe[k]);\n\t\t\t}\n\t\t\tv->total_dcn_read_bw_with_flip = 0.0;\n\t\t\tv->total_dcn_read_bw_with_flip_no_urgent_burst = 0.0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->total_dcn_read_bw_with_flip = v->total_dcn_read_bw_with_flip + dml_max3(\n\t\t\t\t\tv->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\tv->DPPPerPlane[k] * v->final_flip_bw[k] +\n\t\t\t\t\tv->ReadBandwidthLuma[k] * v->UrgentBurstFactorLuma[k] +\n\t\t\t\t\tv->ReadBandwidthChroma[k] * v->UrgentBurstFactorChroma[k] +\n\t\t\t\t\tv->cursor_bw[k] * v->UrgentBurstFactorCursor[k],\n\t\t\t\t\tv->DPPPerPlane[k] * (v->final_flip_bw[k] +\n\t\t\t\t\tv->RequiredPrefetchPixDataBWLuma[k] * v->UrgentBurstFactorLumaPre[k] +\n\t\t\t\t\tv->RequiredPrefetchPixDataBWChroma[k] * v->UrgentBurstFactorChromaPre[k]) +\n\t\t\t\t\tv->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\tv->total_dcn_read_bw_with_flip_no_urgent_burst =\n\t\t\t\t\tv->total_dcn_read_bw_with_flip_no_urgent_burst +\n\t\t\t\t\t\tdml_max3(v->DPPPerPlane[k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\tv->DPPPerPlane[k] * v->final_flip_bw[k] + v->ReadBandwidthPlaneLuma[k] + v->ReadBandwidthPlaneChroma[k] + v->cursor_bw[k],\n\t\t\t\t\t\t\tv->DPPPerPlane[k] * (v->final_flip_bw[k] + v->RequiredPrefetchPixDataBWLuma[k] + v->RequiredPrefetchPixDataBWChroma[k]) + v->cursor_bw_pre[k]);\n\n\t\t\t}\n\t\t\tv->FractionOfUrgentBandwidthImmediateFlip = v->total_dcn_read_bw_with_flip_no_urgent_burst / v->ReturnBW;\n\n\t\t\tv->ImmediateFlipSupported = true;\n\t\t\tif (v->total_dcn_read_bw_with_flip > v->ReturnBW) {\n\t\t\t\tv->ImmediateFlipSupported = false;\n\t\t\t\tv->total_dcn_read_bw_with_flip = MaxTotalRDBandwidth;\n\t\t\t}\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (v->ImmediateFlipSupportedForPipe[k] == false) {\n\t\t\t\t\tv->ImmediateFlipSupported = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->ImmediateFlipSupported = false;\n\t\t}\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->ErrorResult[k] || v->NotEnoughTimeForDynamicMetadata[k]) {\n\t\t\t\tv->PrefetchModeSupported = false;\n\t\t\t\tdml_print(\"DML: CalculatePrefetchSchedule ***failed***. Prefetch schedule violation. Results are NOT valid\\n\");\n\t\t\t}\n\t\t}\n\n\t\tv->VStartupLines = v->VStartupLines + 1;\n\t\tv->PrefetchModeSupported = (v->PrefetchModeSupported == true && ((!v->ImmediateFlipSupport &&\n\t\t\t\t!v->HostVMEnable && v->ImmediateFlipRequirement[0] != dm_immediate_flip_required) ||\n\t\t\t\tv->ImmediateFlipSupported)) ? true : false;\n\t} while (!v->PrefetchModeSupported && v->VStartupLines <= v->MaximumMaxVStartupLines);\n\tASSERT(v->PrefetchModeSupported);\n\n\t\n\t{\n\t\tenum clock_change_support   DRAMClockChangeSupport = 0; \n\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\tmode_lib,\n\t\t\tPrefetchMode,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->MaxLineBufferLines,\n\t\t\tv->LineBufferSize,\n\t\t\tv->DPPOutputBufferPixels,\n\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\tv->WritebackInterfaceBufferSize,\n\t\t\tv->DCFCLK,\n\t\t\tv->ReturnBW,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->dpte_group_bytes,\n\t\t\tv->MetaChunkSize,\n\t\t\tv->UrgentLatency,\n\t\t\tv->UrgentExtraLatency,\n\t\t\tv->WritebackLatency,\n\t\t\tv->WritebackChunkSize,\n\t\t\tv->SOCCLK,\n\t\t\tv->FinalDRAMClockChangeLatency,\n\t\t\tv->SRExitTime,\n\t\t\tv->SREnterPlusExitTime,\n\t\t\tv->DCFCLKDeepSleep,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->DCCEnable,\n\t\t\tv->DPPCLK,\n\t\t\tv->DETBufferSizeY,\n\t\t\tv->DETBufferSizeC,\n\t\t\tv->SwathHeightY,\n\t\t\tv->SwathHeightC,\n\t\t\tv->LBBitPerPixel,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->vtaps,\n\t\t\tv->VTAPsChroma,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->HTotal,\n\t\t\tv->PixelClock,\n\t\t\tv->BlendingAndTiming,\n\t\t\tv->BytePerPixelDETY,\n\t\t\tv->BytePerPixelDETC,\n\t\t\tv->DSTXAfterScaler,\n\t\t\tv->DSTYAfterScaler,\n\t\t\tv->WritebackEnable,\n\t\t\tv->WritebackPixelFormat,\n\t\t\tv->WritebackDestinationWidth,\n\t\t\tv->WritebackDestinationHeight,\n\t\t\tv->WritebackSourceHeight,\n\t\t\t&DRAMClockChangeSupport,\n\t\t\t&v->UrgentWatermark,\n\t\t\t&v->WritebackUrgentWatermark,\n\t\t\t&v->DRAMClockChangeWatermark,\n\t\t\t&v->WritebackDRAMClockChangeWatermark,\n\t\t\t&v->StutterExitWatermark,\n\t\t\t&v->StutterEnterPlusExitWatermark,\n\t\t\t&v->MinActiveDRAMClockChangeLatencySupported);\n\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\t\tv->ThisVStartup = v->VStartup[k];\n\t\t\t\t} else {\n\t\t\t\t\tfor (j = 0; j < v->NumberOfActivePlanes; ++j) {\n\t\t\t\t\t\tif (v->BlendingAndTiming[k] == j) {\n\t\t\t\t\t\t\tv->ThisVStartup = v->VStartup[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv->WritebackAllowDRAMClockChangeEndPosition[k] = dml_max(0,\n\t\t\t\t\tv->ThisVStartup * v->HTotal[k] / v->PixelClock[k] - v->WritebackDRAMClockChangeWatermark);\n\t\t\t} else {\n\t\t\t\tv->WritebackAllowDRAMClockChangeEndPosition[k] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t\n\tCalculatePixelDeliveryTimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->VRatioPrefetchY,\n\t\t\tv->VRatioPrefetchC,\n\t\t\tv->swath_width_luma_ub,\n\t\t\tv->swath_width_chroma_ub,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->PixelClock,\n\t\t\tv->PSCL_THROUGHPUT_LUMA,\n\t\t\tv->PSCL_THROUGHPUT_CHROMA,\n\t\t\tv->DPPCLK,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->SourceScan,\n\t\t\tv->NumberOfCursors,\n\t\t\tv->CursorWidth,\n\t\t\tv->CursorBPP,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->DisplayPipeLineDeliveryTimeLuma,\n\t\t\tv->DisplayPipeLineDeliveryTimeChroma,\n\t\t\tv->DisplayPipeLineDeliveryTimeLumaPrefetch,\n\t\t\tv->DisplayPipeLineDeliveryTimeChromaPrefetch,\n\t\t\tv->DisplayPipeRequestDeliveryTimeLuma,\n\t\t\tv->DisplayPipeRequestDeliveryTimeChroma,\n\t\t\tv->DisplayPipeRequestDeliveryTimeLumaPrefetch,\n\t\t\tv->DisplayPipeRequestDeliveryTimeChromaPrefetch,\n\t\t\tv->CursorRequestDeliveryTime,\n\t\t\tv->CursorRequestDeliveryTimePrefetch);\n\n\tCalculateMetaAndPTETimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->MetaChunkSize,\n\t\t\tv->MinMetaChunkSizeBytes,\n\t\t\tv->HTotal,\n\t\t\tv->VRatio,\n\t\t\tv->VRatioChroma,\n\t\t\tv->DestinationLinesToRequestRowInVBlank,\n\t\t\tv->DestinationLinesToRequestRowInImmediateFlip,\n\t\t\tv->DCCEnable,\n\t\t\tv->PixelClock,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->SourceScan,\n\t\t\tv->dpte_row_height,\n\t\t\tv->dpte_row_height_chroma,\n\t\t\tv->meta_row_width,\n\t\t\tv->meta_row_width_chroma,\n\t\t\tv->meta_row_height,\n\t\t\tv->meta_row_height_chroma,\n\t\t\tv->meta_req_width,\n\t\t\tv->meta_req_width_chroma,\n\t\t\tv->meta_req_height,\n\t\t\tv->meta_req_height_chroma,\n\t\t\tv->dpte_group_bytes,\n\t\t\tv->PTERequestSizeY,\n\t\t\tv->PTERequestSizeC,\n\t\t\tv->PixelPTEReqWidthY,\n\t\t\tv->PixelPTEReqHeightY,\n\t\t\tv->PixelPTEReqWidthC,\n\t\t\tv->PixelPTEReqHeightC,\n\t\t\tv->dpte_row_width_luma_ub,\n\t\t\tv->dpte_row_width_chroma_ub,\n\t\t\tv->DST_Y_PER_PTE_ROW_NOM_L,\n\t\t\tv->DST_Y_PER_PTE_ROW_NOM_C,\n\t\t\tv->DST_Y_PER_META_ROW_NOM_L,\n\t\t\tv->DST_Y_PER_META_ROW_NOM_C,\n\t\t\tv->TimePerMetaChunkNominal,\n\t\t\tv->TimePerChromaMetaChunkNominal,\n\t\t\tv->TimePerMetaChunkVBlank,\n\t\t\tv->TimePerChromaMetaChunkVBlank,\n\t\t\tv->TimePerMetaChunkFlip,\n\t\t\tv->TimePerChromaMetaChunkFlip,\n\t\t\tv->time_per_pte_group_nom_luma,\n\t\t\tv->time_per_pte_group_vblank_luma,\n\t\t\tv->time_per_pte_group_flip_luma,\n\t\t\tv->time_per_pte_group_nom_chroma,\n\t\t\tv->time_per_pte_group_vblank_chroma,\n\t\t\tv->time_per_pte_group_flip_chroma);\n\n\tCalculateVMGroupAndRequestTimes(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->GPUVMEnable,\n\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\tv->HTotal,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->DestinationLinesToRequestVMInVBlank,\n\t\t\tv->DestinationLinesToRequestVMInImmediateFlip,\n\t\t\tv->DCCEnable,\n\t\t\tv->PixelClock,\n\t\t\tv->dpte_row_width_luma_ub,\n\t\t\tv->dpte_row_width_chroma_ub,\n\t\t\tv->vm_group_bytes,\n\t\t\tv->dpde0_bytes_per_frame_ub_l,\n\t\t\tv->dpde0_bytes_per_frame_ub_c,\n\t\t\tv->meta_pte_bytes_per_frame_ub_l,\n\t\t\tv->meta_pte_bytes_per_frame_ub_c,\n\t\t\tv->TimePerVMGroupVBlank,\n\t\t\tv->TimePerVMGroupFlip,\n\t\t\tv->TimePerVMRequestVBlank,\n\t\t\tv->TimePerVMRequestFlip);\n\n\n\t\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (PrefetchMode == 0) {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = true;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tv->MinTTUVBlank[k] = dml_max(\n\t\t\t\t\tv->DRAMClockChangeWatermark,\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tv->StutterEnterPlusExitWatermark,\n\t\t\t\t\t\t\tv->UrgentWatermark));\n\t\t} else if (PrefetchMode == 1) {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tv->MinTTUVBlank[k] = dml_max(\n\t\t\t\t\tv->StutterEnterPlusExitWatermark,\n\t\t\t\t\tv->UrgentWatermark);\n\t\t} else {\n\t\t\tv->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tv->AllowDRAMSelfRefreshDuringVBlank[k] = false;\n\t\t\tv->MinTTUVBlank[k] = v->UrgentWatermark;\n\t\t}\n\t\tif (!v->DynamicMetadataEnable[k])\n\t\t\tv->MinTTUVBlank[k] = v->TCalc\n\t\t\t\t\t+ v->MinTTUVBlank[k];\n\t}\n\n\t\n\tv->ActiveDPPs = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tCalculateDCCConfiguration(v->DCCEnable[k], false, \n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceWidthY[k],\n\t\t\t\tv->SurfaceWidthC[k],\n\t\t\t\tv->SurfaceHeightY[k],\n\t\t\t\tv->SurfaceHeightC[k],\n\t\t\t\tv->DETBufferSizeInKByte[0] * 1024,\n\t\t\t\tv->BlockHeight256BytesY[k],\n\t\t\t\tv->BlockHeight256BytesC[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\tv->BytePerPixelDETY[k],\n\t\t\t\tv->BytePerPixelDETC[k],\n\t\t\t\tv->SourceScan[k],\n\t\t\t\t&v->DCCYMaxUncompressedBlock[k],\n\t\t\t\t&v->DCCCMaxUncompressedBlock[k],\n\t\t\t\t&v->DCCYMaxCompressedBlock[k],\n\t\t\t\t&v->DCCCMaxCompressedBlock[k],\n\t\t\t\t&v->DCCYIndependentBlock[k],\n\t\t\t\t&v->DCCCIndependentBlock[k]);\n\t}\n\n\t{\n\t\t\n\t\tv->TotalDataReadBandwidth = 0;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tv->TotalDataReadBandwidth = v->TotalDataReadBandwidth\n\t\t\t\t\t+ v->ReadBandwidthPlaneLuma[k]\n\t\t\t\t\t+ v->ReadBandwidthPlaneChroma[k];\n\t\t}\n\t}\n\n\t\n\tv->VStartupMargin = 0;\n\tv->FirstMainPlane = true;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tdouble margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k]\n\t\t\t\t\t/ v->PixelClock[k];\n\t\t\tif (v->FirstMainPlane == true) {\n\t\t\t\tv->VStartupMargin = margin;\n\t\t\t\tv->FirstMainPlane = false;\n\t\t\t} else {\n\t\t\t\tv->VStartupMargin = dml_min(v->VStartupMargin, margin);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tCalculateStutterEfficiency(\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->ROBBufferSizeInKByte,\n\t\t\tv->TotalDataReadBandwidth,\n\t\t\tv->DCFCLK,\n\t\t\tv->ReturnBW,\n\t\t\tv->SRExitTime,\n\t\t\tv->SynchronizedVBlank,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->DETBufferSizeY,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelDETY,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathHeightY,\n\t\t\tv->SwathHeightC,\n\t\t\tv->DCCRateLuma,\n\t\t\tv->DCCRateChroma,\n\t\t\tv->HTotal,\n\t\t\tv->VTotal,\n\t\t\tv->PixelClock,\n\t\t\tv->VRatio,\n\t\t\tv->SourceScan,\n\t\t\tv->BlockHeight256BytesY,\n\t\t\tv->BlockWidth256BytesY,\n\t\t\tv->BlockHeight256BytesC,\n\t\t\tv->BlockWidth256BytesC,\n\t\t\tv->DCCYMaxUncompressedBlock,\n\t\t\tv->DCCCMaxUncompressedBlock,\n\t\t\tv->VActive,\n\t\t\tv->DCCEnable,\n\t\t\tv->WritebackEnable,\n\t\t\tv->ReadBandwidthPlaneLuma,\n\t\t\tv->ReadBandwidthPlaneChroma,\n\t\t\tv->meta_row_bw,\n\t\t\tv->dpte_row_bw,\n\t\t\t&v->StutterEfficiencyNotIncludingVBlank,\n\t\t\t&v->StutterEfficiency,\n\t\t\t&v->StutterPeriod);\n}\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib)\n{\n\t\n\tdouble BytePerPixDETY[DC__NUM_DPP__MAX] = { 0 };\n\tdouble BytePerPixDETC[DC__NUM_DPP__MAX] = { 0 };\n\tint BytePerPixY[DC__NUM_DPP__MAX] = { 0 };\n\tint BytePerPixC[DC__NUM_DPP__MAX] = { 0 };\n\tint Read256BytesBlockHeightY[DC__NUM_DPP__MAX] = { 0 };\n\tint Read256BytesBlockHeightC[DC__NUM_DPP__MAX] = { 0 };\n\tint Read256BytesBlockWidthY[DC__NUM_DPP__MAX] = { 0 };\n\tint Read256BytesBlockWidthC[DC__NUM_DPP__MAX] = { 0 };\n\tdouble dummy1[DC__NUM_DPP__MAX] = { 0 };\n\tdouble dummy2[DC__NUM_DPP__MAX] = { 0 };\n\tdouble dummy3[DC__NUM_DPP__MAX] = { 0 };\n\tdouble dummy4[DC__NUM_DPP__MAX] = { 0 };\n\tint dummy5[DC__NUM_DPP__MAX] = { 0 };\n\tint dummy6[DC__NUM_DPP__MAX] = { 0 };\n\tbool dummy7[DC__NUM_DPP__MAX] = { 0 };\n\tbool dummysinglestring = 0;\n\tunsigned int k;\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\t&BytePerPixY[k],\n\t\t\t\t&BytePerPixC[k],\n\t\t\t\t&BytePerPixDETY[k],\n\t\t\t\t&BytePerPixDETC[k],\n\t\t\t\t&Read256BytesBlockHeightY[k],\n\t\t\t\t&Read256BytesBlockHeightC[k],\n\t\t\t\t&Read256BytesBlockWidthY[k],\n\t\t\t\t&Read256BytesBlockWidthC[k]);\n\t}\n\tCalculateSwathAndDETConfiguration(\n\t\t\tfalse,\n\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\tdummy1,\n\t\t\tdummy2,\n\t\t\tmode_lib->vba.SourceScan,\n\t\t\tmode_lib->vba.SourcePixelFormat,\n\t\t\tmode_lib->vba.SurfaceTiling,\n\t\t\tmode_lib->vba.ViewportWidth,\n\t\t\tmode_lib->vba.ViewportHeight,\n\t\t\tmode_lib->vba.SurfaceWidthY,\n\t\t\tmode_lib->vba.SurfaceWidthC,\n\t\t\tmode_lib->vba.SurfaceHeightY,\n\t\t\tmode_lib->vba.SurfaceHeightC,\n\t\t\tRead256BytesBlockHeightY,\n\t\t\tRead256BytesBlockHeightC,\n\t\t\tRead256BytesBlockWidthY,\n\t\t\tRead256BytesBlockWidthC,\n\t\t\tmode_lib->vba.ODMCombineEnabled,\n\t\t\tmode_lib->vba.BlendingAndTiming,\n\t\t\tBytePerPixY,\n\t\t\tBytePerPixC,\n\t\t\tBytePerPixDETY,\n\t\t\tBytePerPixDETC,\n\t\t\tmode_lib->vba.HActive,\n\t\t\tmode_lib->vba.HRatio,\n\t\t\tmode_lib->vba.HRatioChroma,\n\t\t\tmode_lib->vba.DPPPerPlane,\n\t\t\tdummy5,\n\t\t\tdummy6,\n\t\t\tdummy3,\n\t\t\tdummy4,\n\t\t\tmode_lib->vba.SwathHeightY,\n\t\t\tmode_lib->vba.SwathHeightC,\n\t\t\tmode_lib->vba.DETBufferSizeY,\n\t\t\tmode_lib->vba.DETBufferSizeC,\n\t\t\tdummy7,\n\t\t\t&dummysinglestring);\n}\n\nvoid dml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\tenum source_format_class SourcePixelFormat,\n\t\tenum dm_swizzle_mode SurfaceTiling,\n\t\tunsigned int *BytePerPixelY,\n\t\tunsigned int *BytePerPixelC,\n\t\tdouble       *BytePerPixelDETY,\n\t\tdouble       *BytePerPixelDETC,\n\t\tunsigned int *BlockHeight256BytesY,\n\t\tunsigned int *BlockHeight256BytesC,\n\t\tunsigned int *BlockWidth256BytesY,\n\t\tunsigned int *BlockWidth256BytesC)\n{\n\tif (SourcePixelFormat == dm_444_64) {\n\t\t*BytePerPixelDETY = 8;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 8;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_32 || SourcePixelFormat == dm_rgbe) {\n\t\t*BytePerPixelDETY = 4;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 4;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_16) {\n\t\t*BytePerPixelDETY = 2;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_444_8) {\n\t\t*BytePerPixelDETY = 1;\n\t\t*BytePerPixelDETC = 0;\n\t\t*BytePerPixelY = 1;\n\t\t*BytePerPixelC = 0;\n\t} else if (SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*BytePerPixelDETY = 4;\n\t\t*BytePerPixelDETC = 1;\n\t\t*BytePerPixelY = 4;\n\t\t*BytePerPixelC = 1;\n\t} else if (SourcePixelFormat == dm_420_8) {\n\t\t*BytePerPixelDETY = 1;\n\t\t*BytePerPixelDETC = 2;\n\t\t*BytePerPixelY = 1;\n\t\t*BytePerPixelC = 2;\n\t} else if (SourcePixelFormat == dm_420_12) {\n\t\t*BytePerPixelDETY = 2;\n\t\t*BytePerPixelDETC = 4;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 4;\n\t} else {\n\t\t*BytePerPixelDETY = 4.0 / 3;\n\t\t*BytePerPixelDETC = 8.0 / 3;\n\t\t*BytePerPixelY = 2;\n\t\t*BytePerPixelC = 4;\n\t}\n\n\tif ((SourcePixelFormat == dm_444_64 || SourcePixelFormat == dm_444_32\n\t\t\t|| SourcePixelFormat == dm_444_16 || SourcePixelFormat == dm_444_8\n\t\t\t|| SourcePixelFormat == dm_mono_16 || SourcePixelFormat == dm_mono_8\n\t\t\t|| SourcePixelFormat == dm_rgbe)) {\n\t\tif (SurfaceTiling == dm_sw_linear) {\n\t\t\t*BlockHeight256BytesY = 1;\n\t\t} else if (SourcePixelFormat == dm_444_64) {\n\t\t\t*BlockHeight256BytesY = 4;\n\t\t} else if (SourcePixelFormat == dm_444_8) {\n\t\t\t*BlockHeight256BytesY = 16;\n\t\t} else {\n\t\t\t*BlockHeight256BytesY = 8;\n\t\t}\n\t\t*BlockWidth256BytesY = 256U / *BytePerPixelY / *BlockHeight256BytesY;\n\t\t*BlockHeight256BytesC = 0;\n\t\t*BlockWidth256BytesC = 0;\n\t} else {\n\t\tif (SurfaceTiling == dm_sw_linear) {\n\t\t\t*BlockHeight256BytesY = 1;\n\t\t\t*BlockHeight256BytesC = 1;\n\t\t} else if (SourcePixelFormat == dm_rgbe_alpha) {\n\t\t\t*BlockHeight256BytesY = 8;\n\t\t\t*BlockHeight256BytesC = 16;\n\t\t} else if (SourcePixelFormat == dm_420_8) {\n\t\t\t*BlockHeight256BytesY = 16;\n\t\t\t*BlockHeight256BytesC = 8;\n\t\t} else {\n\t\t\t*BlockHeight256BytesY = 8;\n\t\t\t*BlockHeight256BytesC = 8;\n\t\t}\n\t\t*BlockWidth256BytesY = 256U / *BytePerPixelY / *BlockHeight256BytesY;\n\t\t*BlockWidth256BytesC = 256U / *BytePerPixelC / *BlockHeight256BytesC;\n\t}\n}\n\nstatic double CalculateTWait(\n\t\tunsigned int PrefetchMode,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble SREnterPlusExitTime)\n{\n\tif (PrefetchMode == 0) {\n\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency,\n\t\t\t\tdml_max(SREnterPlusExitTime, UrgentLatency));\n\t} else if (PrefetchMode == 1) {\n\t\treturn dml_max(SREnterPlusExitTime, UrgentLatency);\n\t} else {\n\t\treturn UrgentLatency;\n\t}\n}\n\ndouble dml30_CalculateWriteBackDISPCLK(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble PixelClock,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackHTaps,\n\t\tunsigned int WritebackVTaps,\n\t\tlong   WritebackSourceWidth,\n\t\tlong   WritebackDestinationWidth,\n\t\tunsigned int HTotal,\n\t\tunsigned int WritebackLineBufferSize)\n{\n\tdouble DISPCLK_H = 0, DISPCLK_V = 0, DISPCLK_HB = 0;\n\n\tDISPCLK_H = PixelClock * dml_ceil(WritebackHTaps / 8.0, 1) / WritebackHRatio;\n\tDISPCLK_V = PixelClock * (WritebackVTaps * dml_ceil(WritebackDestinationWidth / 6.0, 1) + 8.0) / HTotal;\n\tDISPCLK_HB = PixelClock * WritebackVTaps * (WritebackDestinationWidth * WritebackVTaps - WritebackLineBufferSize / 57.0) / 6.0 / WritebackSourceWidth;\n\treturn dml_max3(DISPCLK_H, DISPCLK_V, DISPCLK_HB);\n}\n\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackVTaps,\n\t\tlong         WritebackDestinationWidth,\n\t\tlong         WritebackDestinationHeight,\n\t\tlong         WritebackSourceHeight,\n\t\tunsigned int HTotal)\n{\n\tdouble CalculateWriteBackDelay = 0;\n\tdouble Line_length = 0;\n\tdouble Output_lines_last_notclamped = 0;\n\tdouble WritebackVInit = 0;\n\n\tWritebackVInit = (WritebackVRatio + WritebackVTaps + 1) / 2;\n\tLine_length = dml_max((double) WritebackDestinationWidth, dml_ceil(WritebackDestinationWidth / 6.0, 1) * WritebackVTaps);\n\tOutput_lines_last_notclamped = WritebackDestinationHeight - 1 - dml_ceil((WritebackSourceHeight - WritebackVInit) / WritebackVRatio, 1);\n\tif (Output_lines_last_notclamped < 0) {\n\t\tCalculateWriteBackDelay = 0;\n\t} else {\n\t\tCalculateWriteBackDelay = Output_lines_last_notclamped * Line_length + (HTotal - WritebackDestinationWidth) + 80;\n\t}\n\treturn CalculateWriteBackDelay;\n}\n\n\nstatic void CalculateDynamicMetadataParameters(int MaxInterDCNTileRepeaters, double DPPCLK, double DISPCLK,\n\t\tdouble DCFClkDeepSleep, double PixelClock, long HTotal, long VBlank, long DynamicMetadataTransmittedBytes,\n\t\tlong DynamicMetadataLinesBeforeActiveRequired, int InterlaceEnable, bool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *Tsetup, double *Tdmbf, double *Tdmec, double *Tdmsks)\n{\n\tdouble TotalRepeaterDelayTime = 0;\n\tdouble VUpdateWidthPix = 0;\n\tdouble VReadyOffsetPix = 0;\n\tdouble VUpdateOffsetPix = 0;\n\tTotalRepeaterDelayTime = MaxInterDCNTileRepeaters * (2 / DPPCLK + 3 / DISPCLK);\n\tVUpdateWidthPix = (14 / DCFClkDeepSleep + 12 / DPPCLK + TotalRepeaterDelayTime) * PixelClock;\n\tVReadyOffsetPix = dml_max(150.0 / DPPCLK, TotalRepeaterDelayTime + 20 / DCFClkDeepSleep + 10 / DPPCLK) * PixelClock;\n\tVUpdateOffsetPix = dml_ceil(HTotal / 4.0, 1);\n\t*Tsetup = (VUpdateOffsetPix + VUpdateWidthPix + VReadyOffsetPix) / PixelClock;\n\t*Tdmbf = DynamicMetadataTransmittedBytes / 4.0 / DISPCLK;\n\t*Tdmec = HTotal / PixelClock;\n\tif (DynamicMetadataLinesBeforeActiveRequired == 0) {\n\t\t*Tdmsks = VBlank * HTotal / PixelClock / 2.0;\n\t} else {\n\t\t*Tdmsks = DynamicMetadataLinesBeforeActiveRequired * HTotal / PixelClock;\n\t}\n\tif (InterlaceEnable == 1 && ProgressiveToInterlaceUnitInOPP == false) {\n\t\t*Tdmsks = *Tdmsks / 2;\n\t}\n}\n\nstatic void CalculateRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw)\n{\n\tif (DCCEnable != true) {\n\t\t*meta_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime)\n\t\t\t\t+ VRatioChroma * MetaRowByteChroma\n\t\t\t\t\t\t/ (meta_row_height_chroma * LineTime);\n\t} else {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime);\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*dpte_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_420_12 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime)\n\t\t\t\t+ VRatioChroma * PixelPTEBytesPerRowChroma\n\t\t\t\t\t\t/ (dpte_row_height_chroma * LineTime);\n\t} else {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime);\n\t}\n}\n\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxNonCachedPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tdouble HostVMMinPageSize,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow,\n\t\tdouble BandwidthAvailableForImmediateFlip,\n\t\tunsigned int TotImmediateFlipBytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble LineTime,\n\t\tdouble VRatio,\n\t\tdouble VRatioChroma,\n\t\tdouble Tno_bw,\n\t\tbool DCCEnable,\n\t\tunsigned int dpte_row_height,\n\t\tunsigned int meta_row_height,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tdouble *DestinationLinesToRequestVMInImmediateFlip,\n\t\tdouble *DestinationLinesToRequestRowInImmediateFlip,\n\t\tdouble *final_flip_bw,\n\t\tbool *ImmediateFlipSupportedForPipe)\n{\n\tdouble min_row_time = 0.0;\n\tunsigned int HostVMDynamicLevelsTrips = 0;\n\tdouble TimeForFetchingMetaPTEImmediateFlip = 0;\n\tdouble TimeForFetchingRowInVBlankImmediateFlip = 0;\n\tdouble ImmediateFlipBW = 0;\n\tdouble HostVMInefficiencyFactor = 0;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tHostVMInefficiencyFactor = PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tHostVMDynamicLevelsTrips = HostVMMaxNonCachedPageTableLevels;\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevelsTrips = 0;\n\t}\n\n\tif (GPUVMEnable == true || DCCEnable == true) {\n\t\tImmediateFlipBW = (PDEAndMetaPTEBytesPerFrame + MetaRowBytes + DPTEBytesPerRow) * BandwidthAvailableForImmediateFlip / TotImmediateFlipBytes;\n\t}\n\n\tif (GPUVMEnable == true) {\n\t\tTimeForFetchingMetaPTEImmediateFlip = dml_max3(Tno_bw + PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / ImmediateFlipBW,\n\t\t\t\tUrgentExtraLatency + UrgentLatency * (GPUVMMaxPageTableLevels * (HostVMDynamicLevelsTrips + 1) - 1), LineTime / 4.0);\n\t} else {\n\t\tTimeForFetchingMetaPTEImmediateFlip = 0;\n\t}\n\n\t*DestinationLinesToRequestVMInImmediateFlip = dml_ceil(4.0 * (TimeForFetchingMetaPTEImmediateFlip / LineTime), 1) / 4.0;\n\tif ((GPUVMEnable == true || DCCEnable == true)) {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = dml_max3((MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / ImmediateFlipBW,\n\t\t\t\tUrgentLatency * (HostVMDynamicLevelsTrips + 1), LineTime / 4);\n\t} else {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = 0;\n\t}\n\n\t*DestinationLinesToRequestRowInImmediateFlip = dml_ceil(4.0 * (TimeForFetchingRowInVBlankImmediateFlip / LineTime), 1) / 4.0;\n\n\tif (GPUVMEnable == true) {\n\t\t*final_flip_bw = dml_max(PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / (*DestinationLinesToRequestVMInImmediateFlip * LineTime),\n\t\t\t\t(MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / (*DestinationLinesToRequestRowInImmediateFlip * LineTime));\n\t} else if ((GPUVMEnable == true || DCCEnable == true)) {\n\t\t*final_flip_bw = (MetaRowBytes + DPTEBytesPerRow * HostVMInefficiencyFactor) / (*DestinationLinesToRequestRowInImmediateFlip * LineTime);\n\t} else {\n\t\t*final_flip_bw = 0;\n\t}\n\n\n\tif (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10 || SourcePixelFormat == dm_rgbe_alpha) {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dml_min(dpte_row_height * LineTime / VRatio, dpte_row_height_chroma * LineTime / VRatioChroma);\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = dml_min(meta_row_height * LineTime / VRatio, meta_row_height_chroma * LineTime / VRatioChroma);\n\t\t} else {\n\t\t\tmin_row_time = dml_min4(dpte_row_height * LineTime / VRatio, meta_row_height * LineTime / VRatio,\n\t\t\t\t\tdpte_row_height_chroma * LineTime / VRatioChroma, meta_row_height_chroma * LineTime / VRatioChroma);\n\t\t}\n\t} else {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dpte_row_height * LineTime / VRatio;\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = meta_row_height * LineTime / VRatio;\n\t\t} else {\n\t\t\tmin_row_time = dml_min(dpte_row_height * LineTime / VRatio, meta_row_height * LineTime / VRatio);\n\t\t}\n\t}\n\n\tif (*DestinationLinesToRequestVMInImmediateFlip >= 32 || *DestinationLinesToRequestRowInImmediateFlip >= 16\n\t\t\t|| TimeForFetchingMetaPTEImmediateFlip + 2 * TimeForFetchingRowInVBlankImmediateFlip > min_row_time) {\n\t\t*ImmediateFlipSupportedForPipe = false;\n\t} else {\n\t\t*ImmediateFlipSupportedForPipe = true;\n\t}\n}\n\nstatic double TruncToValidBPP(\n\t\tdouble LinkBitRate,\n\t\tint Lanes,\n\t\tlong HTotal,\n\t\tlong HActive,\n\t\tdouble PixelClock,\n\t\tdouble DesiredBPP,\n\t\tbool DSCEnable,\n\t\tenum output_encoder_class Output,\n\t\tenum output_format_class Format,\n\t\tunsigned int DSCInputBitPerComponent,\n\t\tint DSCSlices,\n\t\tint AudioRate,\n\t\tint AudioLayout,\n\t\tenum odm_combine_mode ODMCombine)\n{\n\tdouble MaxLinkBPP = 0;\n\tint MinDSCBPP = 0;\n\tdouble MaxDSCBPP = 0;\n\tint NonDSCBPP0 = 0;\n\tint NonDSCBPP1 = 0;\n\tint NonDSCBPP2 = 0;\n\n\tif (Format == dm_420) {\n\t\tNonDSCBPP0 = 12;\n\t\tNonDSCBPP1 = 15;\n\t\tNonDSCBPP2 = 18;\n\t\tMinDSCBPP = 6;\n\t\tMaxDSCBPP = 1.5 * DSCInputBitPerComponent - 1.0 / 16;\n\t} else if (Format == dm_444) {\n\t\tNonDSCBPP0 = 24;\n\t\tNonDSCBPP1 = 30;\n\t\tNonDSCBPP2 = 36;\n\t\tMinDSCBPP = 8;\n\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16;\n\t} else {\n\t\tNonDSCBPP0 = 16;\n\t\tNonDSCBPP1 = 20;\n\t\tNonDSCBPP2 = 24;\n\n\t\tif (Format == dm_n422) {\n\t\t\tMinDSCBPP = 7;\n\t\t\tMaxDSCBPP = 2 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t} else {\n\t\t\tMinDSCBPP = 8;\n\t\t\tMaxDSCBPP = 3 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t}\n\t}\n\n\tif (DSCEnable && Output == dm_dp) {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock * (1 - 2.4 / 100);\n\t} else {\n\t\tMaxLinkBPP = LinkBitRate / 10 * 8 * Lanes / PixelClock;\n\t}\n\n\tif (ODMCombine == dm_odm_combine_mode_4to1 && MaxLinkBPP > 16) {\n\t\tMaxLinkBPP = 16;\n\t} else if (ODMCombine == dm_odm_combine_mode_2to1 && MaxLinkBPP > 32) {\n\t\tMaxLinkBPP = 32;\n\t}\n\n\n\tif (DesiredBPP == 0) {\n\t\tif (DSCEnable) {\n\t\t\tif (MaxLinkBPP < MinDSCBPP) {\n\t\t\t\treturn BPP_INVALID;\n\t\t\t} else if (MaxLinkBPP >= MaxDSCBPP) {\n\t\t\t\treturn MaxDSCBPP;\n\t\t\t} else {\n\t\t\t\treturn dml_floor(16.0 * MaxLinkBPP, 1.0) / 16.0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (MaxLinkBPP >= NonDSCBPP2) {\n\t\t\t\treturn NonDSCBPP2;\n\t\t\t} else if (MaxLinkBPP >= NonDSCBPP1) {\n\t\t\t\treturn NonDSCBPP1;\n\t\t\t} else if (MaxLinkBPP >= NonDSCBPP0) {\n\t\t\t\treturn NonDSCBPP0;\n\t\t\t} else {\n\t\t\t\treturn BPP_INVALID;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!((DSCEnable == false && (DesiredBPP == NonDSCBPP2 || DesiredBPP == NonDSCBPP1 || DesiredBPP == NonDSCBPP0 || DesiredBPP == 18)) ||\n\t\t\t\t(DSCEnable && DesiredBPP >= MinDSCBPP && DesiredBPP <= MaxDSCBPP))) {\n\t\t\treturn BPP_INVALID;\n\t\t} else {\n\t\t\treturn DesiredBPP;\n\t\t}\n\t}\n\treturn BPP_INVALID;\n}\n\nvoid dml30_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *v = &mode_lib->vba;\n\tint MinPrefetchMode, MaxPrefetchMode;\n\tint i;\n\tunsigned int j, k, m;\n\tbool   EnoughWritebackUnits = true;\n\tbool   WritebackModeSupport = true;\n\tbool   ViewportExceedsSurface = false;\n\tdouble MaxTotalVActiveRDBandwidth = 0;\n\tlong ReorderingBytes = 0;\n\tbool NotUrgentLatencyHiding[DC__NUM_DPP__MAX] = { 0 };\n\n\t \n\n\tCalculateMinAndMaxPrefetchMode(\n\t\tmode_lib->vba.AllowDRAMSelfRefreshOrDRAMClockChangeInVblank,\n\t\t&MinPrefetchMode, &MaxPrefetchMode);\n\n\t \n\n\tv->ScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->ScalerEnabled[k] == false\n\t\t\t\t&& ((v->SourcePixelFormat[k] != dm_444_64\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_8\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe_alpha)\n\t\t\t\t\t\t|| v->HRatio[k] != 1.0\n\t\t\t\t\t\t|| v->htaps[k] != 1.0\n\t\t\t\t\t\t|| v->VRatio[k] != 1.0\n\t\t\t\t\t\t|| v->vtaps[k] != 1.0)) {\n\t\t\tv->ScaleRatioAndTapsSupport = false;\n\t\t} else if (v->vtaps[k] < 1.0 || v->vtaps[k] > 8.0\n\t\t\t\t|| v->htaps[k] < 1.0 || v->htaps[k] > 8.0\n\t\t\t\t|| (v->htaps[k] > 1.0\n\t\t\t\t\t\t&& (v->htaps[k] % 2) == 1)\n\t\t\t\t|| v->HRatio[k] > v->MaxHSCLRatio\n\t\t\t\t|| v->VRatio[k] > v->MaxVSCLRatio\n\t\t\t\t|| v->HRatio[k] > v->htaps[k]\n\t\t\t\t|| v->VRatio[k] > v->vtaps[k]\n\t\t\t\t|| (v->SourcePixelFormat[k] != dm_444_64\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_mono_8\n\t\t\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe\n\t\t\t\t\t\t&& (v->VTAPsChroma[k] < 1\n\t\t\t\t\t\t\t|| v->VTAPsChroma[k] > 8\n\t\t\t\t\t\t\t|| v->HTAPsChroma[k] < 1\n\t\t\t\t\t\t\t|| v->HTAPsChroma[k] > 8\n\t\t\t\t\t\t\t|| (v->HTAPsChroma[k] > 1 && v->HTAPsChroma[k] % 2 == 1)\n\t\t\t\t\t\t\t|| v->HRatioChroma[k] > v->MaxHSCLRatio\n\t\t\t\t\t\t\t|| v->VRatioChroma[k] > v->MaxVSCLRatio\n\t\t\t\t\t\t\t|| v->HRatioChroma[k] > v->HTAPsChroma[k]\n\t\t\t\t\t\t\t|| v->VRatioChroma[k] > v->VTAPsChroma[k]))) {\n\t\t\tv->ScaleRatioAndTapsSupport = false;\n\t\t}\n\t}\n\t \n\n\tv->SourceFormatPixelAndScanSupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif ((v->SurfaceTiling[k] == dm_sw_linear && (!(v->SourceScan[k] != dm_vert) || v->DCCEnable[k] == true))\n\t\t\t\t|| ((v->SurfaceTiling[k] == dm_sw_64kb_d || v->SurfaceTiling[k] == dm_sw_64kb_d_t || v->SurfaceTiling[k] == dm_sw_64kb_d_x)\n\t\t\t\t\t\t&& !(v->SourcePixelFormat[k] == dm_444_64))) {\n\t\t\tv->SourceFormatPixelAndScanSupport = false;\n\t\t}\n\t}\n\t \n\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tdml30_CalculateBytePerPixelAnd256BBlockSizes(\n\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t&v->BytePerPixelY[k],\n\t\t\t\t&v->BytePerPixelC[k],\n\t\t\t\t&v->BytePerPixelInDETY[k],\n\t\t\t\t&v->BytePerPixelInDETC[k],\n\t\t\t\t&v->Read256BlockHeightY[k],\n\t\t\t\t&v->Read256BlockHeightC[k],\n\t\t\t\t&v->Read256BlockWidthY[k],\n\t\t\t\t&v->Read256BlockWidthC[k]);\n\t}\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->SourceScan[k] != dm_vert) {\n\t\t\tv->SwathWidthYSingleDPP[k] = v->ViewportWidth[k];\n\t\t\tv->SwathWidthCSingleDPP[k] = v->ViewportWidthChroma[k];\n\t\t} else {\n\t\t\tv->SwathWidthYSingleDPP[k] = v->ViewportHeight[k];\n\t\t\tv->SwathWidthCSingleDPP[k] = v->ViewportHeightChroma[k];\n\t\t}\n\t}\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tv->ReadBandwidthLuma[k] = v->SwathWidthYSingleDPP[k] * dml_ceil(v->BytePerPixelInDETY[k], 1.0) / (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t\tv->ReadBandwidthChroma[k] = v->SwathWidthYSingleDPP[k] / 2 * dml_ceil(v->BytePerPixelInDETC[k], 2.0) / (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k] / 2.0;\n\t}\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->WritebackEnable[k] == true\n\t\t\t\t&& v->WritebackPixelFormat[k] == dm_444_64) {\n\t\t\tv->WriteBandwidth[k] = v->WritebackDestinationWidth[k]\n\t\t\t\t\t* v->WritebackDestinationHeight[k]\n\t\t\t\t\t/ (v->WritebackSourceHeight[k]\n\t\t\t\t\t\t\t* v->HTotal[k]\n\t\t\t\t\t\t\t/ v->PixelClock[k]) * 8.0;\n\t\t} else if (v->WritebackEnable[k] == true) {\n\t\t\tv->WriteBandwidth[k] = v->WritebackDestinationWidth[k]\n\t\t\t\t\t* v->WritebackDestinationHeight[k]\n\t\t\t\t\t/ (v->WritebackSourceHeight[k]\n\t\t\t\t\t\t\t* v->HTotal[k]\n\t\t\t\t\t\t\t/ v->PixelClock[k]) * 4.0;\n\t\t} else {\n\t\t\tv->WriteBandwidth[k] = 0.0;\n\t\t}\n\t}\n\n\t \n\n\tv->WritebackLatencySupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tif (v->WritebackConfiguration == dm_whole_buffer_for_single_stream_no_interleave ||\n\t\t\t    v->WritebackConfiguration == dm_whole_buffer_for_single_stream_interleave) {\n\t\t\t\tif (v->WriteBandwidth[k]\n\t\t\t\t\t\t> 2.0 * v->WritebackInterfaceBufferSize * 1024\n\t\t\t\t\t\t\t\t/ v->WritebackLatency) {\n\t\t\t\t\tv->WritebackLatencySupport = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (v->WriteBandwidth[k]\n\t\t\t\t\t\t> v->WritebackInterfaceBufferSize * 1024\n\t\t\t\t\t\t\t\t/ v->WritebackLatency) {\n\t\t\t\t\tv->WritebackLatencySupport = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tv->TotalNumberOfActiveWriteback = 0;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tv->TotalNumberOfActiveWriteback =\n\t\t\t\t\tv->TotalNumberOfActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (v->TotalNumberOfActiveWriteback > v->MaxNumWriteback) {\n\t\tEnoughWritebackUnits = false;\n\t}\n\tif (!v->WritebackSupportInterleaveAndUsingWholeBufferForASingleStream\n\t\t\t&& (v->WritebackConfiguration == dm_whole_buffer_for_single_stream_no_interleave\n\t\t\t\t\t|| v->WritebackConfiguration == dm_whole_buffer_for_single_stream_interleave)) {\n\n\t\tWritebackModeSupport = false;\n\t}\n\tif (v->WritebackConfiguration == dm_whole_buffer_for_single_stream_no_interleave && v->TotalNumberOfActiveWriteback > 1) {\n\t\tWritebackModeSupport = false;\n\t}\n\n\t \n\n\tv->WritebackScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tif (v->WritebackHRatio[k] > v->WritebackMaxHSCLRatio\n\t\t\t\t\t|| v->WritebackVRatio[k]\n\t\t\t\t\t\t\t> v->WritebackMaxVSCLRatio\n\t\t\t\t\t|| v->WritebackHRatio[k]\n\t\t\t\t\t\t\t< v->WritebackMinHSCLRatio\n\t\t\t\t\t|| v->WritebackVRatio[k]\n\t\t\t\t\t\t\t< v->WritebackMinVSCLRatio\n\t\t\t\t\t|| v->WritebackHTaps[k]\n\t\t\t\t\t\t\t> v->WritebackMaxHSCLTaps\n\t\t\t\t\t|| v->WritebackVTaps[k]\n\t\t\t\t\t\t\t> v->WritebackMaxVSCLTaps\n\t\t\t\t\t|| v->WritebackHRatio[k]\n\t\t\t\t\t\t\t> v->WritebackHTaps[k]\n\t\t\t\t\t|| v->WritebackVRatio[k]\n\t\t\t\t\t\t\t> v->WritebackVTaps[k]\n\t\t\t\t\t|| (v->WritebackHTaps[k] > 2.0\n\t\t\t\t\t\t\t&& ((v->WritebackHTaps[k] % 2)\n\t\t\t\t\t\t\t\t\t== 1))) {\n\t\t\t\tv->WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t\tif (2.0 * v->WritebackDestinationWidth[k] * (v->WritebackVTaps[k] - 1) * 57 > v->WritebackLineBufferSize) {\n\t\t\t\tv->WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->WritebackRequiredDISPCLK = 0.0;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->WritebackEnable[k] == true) {\n\t\t\tv->WritebackRequiredDISPCLK = dml_max(v->WritebackRequiredDISPCLK,\n\t\t\t\t\tdml30_CalculateWriteBackDISPCLK(\n\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\tv->WritebackHTaps[k],\n\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\tv->WritebackSourceWidth[k],\n\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->WritebackLineBufferSize));\n\t\t}\n\t}\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->HRatio[k] > 1.0) {\n\t\t\tv->PSCL_FACTOR[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput * v->HRatio[k] / dml_ceil(v->htaps[k] / 6.0, 1.0));\n\t\t} else {\n\t\t\tv->PSCL_FACTOR[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t}\n\t\tif (v->BytePerPixelC[k] == 0.0) {\n\t\t\tv->PSCL_FACTOR_CHROMA[k] = 0.0;\n\t\t\tv->MinDPPCLKUsingSingleDPP[k] = v->PixelClock[k]\n\t\t\t\t\t* dml_max3(v->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]), v->HRatio[k] * v->VRatio[k] / v->PSCL_FACTOR[k], 1.0);\n\t\t\tif ((v->htaps[k] > 6.0 || v->vtaps[k] > 6.0) && v->MinDPPCLKUsingSingleDPP[k] < 2.0 * v->PixelClock[k]) {\n\t\t\t\tv->MinDPPCLKUsingSingleDPP[k] = 2.0 * v->PixelClock[k];\n\t\t\t}\n\t\t} else {\n\t\t\tif (v->HRatioChroma[k] > 1.0) {\n\t\t\t\tv->PSCL_FACTOR_CHROMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tv->MaxPSCLToLBThroughput * v->HRatioChroma[k] / dml_ceil(v->HTAPsChroma[k] / 6.0, 1.0));\n\t\t\t} else {\n\t\t\t\tv->PSCL_FACTOR_CHROMA[k] = dml_min(v->MaxDCHUBToPSCLThroughput, v->MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tv->MinDPPCLKUsingSingleDPP[k] = v->PixelClock[k] * dml_max5(v->vtaps[k] / 6.0 * dml_min(1.0, v->HRatio[k]),\n\t\t\t\t\t\t\tv->HRatio[k] * v->VRatio[k] / v->PSCL_FACTOR[k],\n\t\t\t\t\t\t\tv->VTAPsChroma[k] / 6.0 * dml_min(1.0, v->HRatioChroma[k]),\n\t\t\t\t\t\t\tv->HRatioChroma[k] * v->VRatioChroma[k] / v->PSCL_FACTOR_CHROMA[k],\n\t\t\t\t\t\t\t1.0);\n\t\t\tif ((v->htaps[k] > 6.0 || v->vtaps[k] > 6.0 || v->HTAPsChroma[k] > 6.0 || v->VTAPsChroma[k] > 6.0)\n\t\t\t\t\t&& v->MinDPPCLKUsingSingleDPP[k] < 2.0 * v->PixelClock[k]) {\n\t\t\t\tv->MinDPPCLKUsingSingleDPP[k] = 2.0 * v->PixelClock[k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tint MaximumSwathWidthSupportLuma = 0;\n\t\tint MaximumSwathWidthSupportChroma = 0;\n\n\t\tif (v->SurfaceTiling[k] == dm_sw_linear) {\n\t\t\tMaximumSwathWidthSupportLuma = 8192.0;\n\t\t} else if (v->SourceScan[k] == dm_vert && v->BytePerPixelC[k] > 0) {\n\t\t\tMaximumSwathWidthSupportLuma = 2880.0;\n\t\t} else {\n\t\t\tMaximumSwathWidthSupportLuma = 5760.0;\n\t\t}\n\n\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12) {\n\t\t\tMaximumSwathWidthSupportChroma = MaximumSwathWidthSupportLuma / 2.0;\n\t\t} else {\n\t\t\tMaximumSwathWidthSupportChroma = MaximumSwathWidthSupportLuma;\n\t\t}\n\t\tv->MaximumSwathWidthInLineBufferLuma = v->LineBufferSize * dml_max(v->HRatio[k], 1.0) / v->LBBitPerPixel[k]\n\t\t\t\t/ (v->vtaps[k] + dml_max(dml_ceil(v->VRatio[k], 1.0) - 2, 0.0));\n\t\tif (v->BytePerPixelC[k] == 0.0) {\n\t\t\tv->MaximumSwathWidthInLineBufferChroma = 0;\n\t\t} else {\n\t\t\tv->MaximumSwathWidthInLineBufferChroma = v->LineBufferSize * dml_max(v->HRatioChroma[k], 1.0) / v->LBBitPerPixel[k]\n\t\t\t\t\t/ (v->VTAPsChroma[k] + dml_max(dml_ceil(v->VRatioChroma[k], 1.0) - 2, 0.0));\n\t\t}\n\t\tv->MaximumSwathWidthLuma[k] = dml_min(MaximumSwathWidthSupportLuma, v->MaximumSwathWidthInLineBufferLuma);\n\t\tv->MaximumSwathWidthChroma[k] = dml_min(MaximumSwathWidthSupportChroma, v->MaximumSwathWidthInLineBufferChroma);\n\t}\n\n\tCalculateSwathAndDETConfiguration(\n\t\t\ttrue,\n\t\t\tv->NumberOfActivePlanes,\n\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\tv->MaximumSwathWidthLuma,\n\t\t\tv->MaximumSwathWidthChroma,\n\t\t\tv->SourceScan,\n\t\t\tv->SourcePixelFormat,\n\t\t\tv->SurfaceTiling,\n\t\t\tv->ViewportWidth,\n\t\t\tv->ViewportHeight,\n\t\t\tv->SurfaceWidthY,\n\t\t\tv->SurfaceWidthC,\n\t\t\tv->SurfaceHeightY,\n\t\t\tv->SurfaceHeightC,\n\t\t\tv->Read256BlockHeightY,\n\t\t\tv->Read256BlockHeightC,\n\t\t\tv->Read256BlockWidthY,\n\t\t\tv->Read256BlockWidthC,\n\t\t\tv->odm_combine_dummy,\n\t\t\tv->BlendingAndTiming,\n\t\t\tv->BytePerPixelY,\n\t\t\tv->BytePerPixelC,\n\t\t\tv->BytePerPixelInDETY,\n\t\t\tv->BytePerPixelInDETC,\n\t\t\tv->HActive,\n\t\t\tv->HRatio,\n\t\t\tv->HRatioChroma,\n\t\t\tv->DPPPerPlane,\n\t\t\tv->swath_width_luma_ub,\n\t\t\tv->swath_width_chroma_ub,\n\t\t\tv->SwathWidthY,\n\t\t\tv->SwathWidthC,\n\t\t\tv->SwathHeightY,\n\t\t\tv->SwathHeightC,\n\t\t\tv->DETBufferSizeY,\n\t\t\tv->DETBufferSizeC,\n\t\t\tv->SingleDPPViewportSizeSupportPerPlane,\n\t\t\t&v->ViewportSizeSupport[0][0]);\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tv->MaxDispclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(v->MaxDispclk[i], v->DISPCLKDPPCLKVCOSpeed);\n\t\t\tv->MaxDppclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(v->MaxDppclk[i], v->DISPCLKDPPCLKVCOSpeed);\n\t\t\tv->RequiredDISPCLK[i][j] = 0.0;\n\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tv->PlaneRequiredDISPCLKWithoutODMCombine = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1.0 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithoutODMCombine >= v->MaxDispclk[i] && v->MaxDispclk[i] == v->MaxDispclk[mode_lib->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[mode_lib->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithoutODMCombine = v->PixelClock[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine2To1 = v->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithODMCombine2To1 >= v->MaxDispclk[i] && v->MaxDispclk[i] == v->MaxDispclk[mode_lib->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[mode_lib->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine2To1 = v->PixelClock[k] / 2 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine4To1 = v->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t* (1 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\tif ((v->PlaneRequiredDISPCLKWithODMCombine4To1 >= v->MaxDispclk[i] && v->MaxDispclk[i] == v->MaxDispclk[mode_lib->soc.num_states - 1]\n\t\t\t\t\t\t&& v->MaxDppclk[i] == v->MaxDppclk[mode_lib->soc.num_states - 1])) {\n\t\t\t\t\tv->PlaneRequiredDISPCLKWithODMCombine4To1 = v->PixelClock[k] / 4 * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t}\n\n\t\t\t\tif (v->ODMCombinePolicy == dm_odm_combine_policy_none) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithoutODMCombine;\n\t\t\t\t} else if (v->ODMCombinePolicy == dm_odm_combine_policy_2to1) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t} else if (v->ODMCombinePolicy == dm_odm_combine_policy_4to1\n\t\t\t\t\t\t|| v->PlaneRequiredDISPCLKWithODMCombine2To1 > v->MaxDispclkRoundedDownToDFSGranularity) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\t\t\t\t} else if (v->PlaneRequiredDISPCLKWithoutODMCombine > v->MaxDispclkRoundedDownToDFSGranularity) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t} else {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithoutODMCombine;\n\t\t\t\t}\n\t\t\t\tif (v->DSCEnabled[k] && v->HActive[k] > DCN30_MAX_DSC_IMAGE_WIDTH\n\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {\n\t\t\t\t\tif (v->HActive[k] / 2 > DCN30_MAX_DSC_IMAGE_WIDTH) {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->OutputFormat[k] == dm_420 && v->HActive[k] > DCN30_MAX_FMT_420_BUFFER_WIDTH\n\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {\n\t\t\t\t\tif (v->HActive[k] / 2 > DCN30_MAX_FMT_420_BUFFER_WIDTH) {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 4;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 4;\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2;\n\t\t\t\t} else if ((v->WhenToDoMPCCombine == dm_mpc_never\n\t\t\t\t\t\t|| (v->MinDPPCLKUsingSingleDPP[k] * (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) <= v->MaxDppclkRoundedDownToDFSGranularity\n\t\t\t\t\t\t\t\t&& v->SingleDPPViewportSizeSupportPerPlane[k] == true))) {\n\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t} else {\n\t\t\t\t\tv->MPCCombine[i][j][k] = true;\n\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t}\n\t\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->PlaneRequiredDISPCLK);\n\t\t\t\tif ((v->MinDPPCLKUsingSingleDPP[k] / v->NoOfDPP[i][j][k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t> v->MaxDppclkRoundedDownToDFSGranularity) || (v->PlaneRequiredDISPCLK > v->MaxDispclkRoundedDownToDFSGranularity)) {\n\t\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->TotalNumberOfActiveDPP[i][j] = 0;\n\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = 0;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\tif (v->NoOfDPP[i][j][k] == 1)\n\t\t\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = v->TotalNumberOfSingleDPPPlanes[i][j] + 1;\n\t\t\t}\n\t\t\tif (j == 1 && v->WhenToDoMPCCombine != dm_mpc_never) {\n\t\t\t\twhile (!(v->TotalNumberOfActiveDPP[i][j] >= v->MaxNumDPP || v->TotalNumberOfSingleDPPPlanes[i][j] == 0)) {\n\t\t\t\t\tdouble BWOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tunsigned int NumberOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\t\tif (v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k] > BWOfNonSplitPlaneOfMaximumBandwidth\n\t\t\t\t\t\t\t\t&& v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled && v->MPCCombine[i][j][k] == false) {\n\t\t\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k];\n\t\t\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv->MPCCombine[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = true;\n\t\t\t\t\tv->NoOfDPP[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = 2;\n\t\t\t\t\tv->RequiredDPPCLK[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = v->MinDPPCLKUsingSingleDPP[NumberOfNonSplitPlaneOfMaximumBandwidth]\n\t\t\t\t\t\t\t* (1 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100) / 2;\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + 1;\n\t\t\t\t\tv->TotalNumberOfSingleDPPPlanes[i][j] = v->TotalNumberOfSingleDPPPlanes[i][j] - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v->TotalNumberOfActiveDPP[i][j] > v->MaxNumDPP) {\n\t\t\t\tv->RequiredDISPCLK[i][j] = 0.0;\n\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tv->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tif (v->SingleDPPViewportSizeSupportPerPlane[k] == false && v->WhenToDoMPCCombine != dm_mpc_never) {\n\t\t\t\t\t\tv->MPCCombine[i][j][k] = true;\n\t\t\t\t\t\tv->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->MPCCombine[i][j][k] = false;\n\t\t\t\t\t\tv->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k] = v->MinDPPCLKUsingSingleDPP[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(v->MaxDispclk[i] == v->MaxDispclk[v->soc.num_states - 1] && v->MaxDppclk[i] == v->MaxDppclk[v->soc.num_states - 1])) {\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t\t* (1.0 + v->DISPCLKRampingMargin / 100.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->PlaneRequiredDISPCLK = v->PixelClock[k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t}\n\t\t\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->PlaneRequiredDISPCLK);\n\t\t\t\t\tif ((v->MinDPPCLKUsingSingleDPP[k] / v->NoOfDPP[i][j][k] * (1.0 + v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t> v->MaxDppclkRoundedDownToDFSGranularity) || (v->PlaneRequiredDISPCLK > v->MaxDispclkRoundedDownToDFSGranularity)) {\n\t\t\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = 0.0;\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j] = v->TotalNumberOfActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->RequiredDISPCLK[i][j] = dml_max(v->RequiredDISPCLK[i][j], v->WritebackRequiredDISPCLK);\n\t\t\tif (v->MaxDispclkRoundedDownToDFSGranularity < v->WritebackRequiredDISPCLK) {\n\t\t\t\tv->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (v->TotalNumberOfActiveDPP[i][j] <= v->MaxNumDPP) {\n\t\t\t\tv->TotalAvailablePipesSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->TotalAvailablePipesSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->NonsupportedDSCInputBPC = false;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (!(v->DSCInputBitPerComponent[k] == 12.0\n\t\t\t\t|| v->DSCInputBitPerComponent[k] == 10.0\n\t\t\t\t|| v->DSCInputBitPerComponent[k] == 8.0)) {\n\t\t\tv->NonsupportedDSCInputBPC = true;\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\tif (v->PixelClockBackEnd[k] > 3200) {\n\t\t\t\tv->NumberOfDSCSlices[k] = dml_ceil(v->PixelClockBackEnd[k] / 400.0, 4.0);\n\t\t\t} else if (v->PixelClockBackEnd[k] > 1360) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 8;\n\t\t\t} else if (v->PixelClockBackEnd[k] > 680) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 4;\n\t\t\t} else if (v->PixelClockBackEnd[k] > 340) {\n\t\t\t\tv->NumberOfDSCSlices[k] = 2;\n\t\t\t} else {\n\t\t\t\tv->NumberOfDSCSlices[k] = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tv->NumberOfDSCSlices[k] = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\tif (v->Output[k] == dm_hdmi) {\n\t\t\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\tv->OutputBppPerState[i][k] = TruncToValidBPP(\n\t\t\t\t\t\t\tdml_min(600.0, v->PHYCLKPerState[i]) * 10,\n\t\t\t\t\t\t\t3,\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t} else if (v->Output[k] == dm_dp || v->Output[k] == dm_edp) {\n\t\t\t\t\tif (v->DSCEnable[k] == true) {\n\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\tif (v->Output[k] == dm_dp) {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->RequiresDSC[i][k] = false;\n\t\t\t\t\t\tv->LinkDSCEnable = false;\n\t\t\t\t\t\tv->RequiresFEC[i][k] = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tv->Outbpp = BPP_INVALID;\n\t\t\t\t\tif (v->PHYCLKPerState[i] >= 270.0) {\n\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 2700,\n\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKPerState[i] >= 540.0) {\n\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 5400,\n\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->PHYCLKPerState[i] >= 810.0) {\n\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 8100,\n\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\tif (v->Outbpp == BPP_INVALID && v->ForcedOutputLinkBPP[k] == 0) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tv->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\tv->LinkDSCEnable = true;\n\t\t\t\t\t\t\tif (v->Output[k] == dm_dp) {\n\t\t\t\t\t\t\t\tv->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv->Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t\t(1.0 - v->Downspreading / 100.0) * 8100,\n\t\t\t\t\t\t\t\t\tv->OutputLinkDPLanes[k],\n\t\t\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\t\t\tv->HActive[k],\n\t\t\t\t\t\t\t\t\tv->PixelClockBackEnd[k],\n\t\t\t\t\t\t\t\t\tv->ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tv->LinkDSCEnable,\n\t\t\t\t\t\t\t\t\tv->Output[k],\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleRate[k],\n\t\t\t\t\t\t\t\t\tv->AudioSampleLayout[k],\n\t\t\t\t\t\t\t\t\tv->ODMCombineEnablePerState[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->OutputBppPerState[i][k] = v->Outbpp;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tv->OutputBppPerState[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tv->DIOSupport[i] = true;\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tif (!v->skip_dio_check[k] && v->BlendingAndTiming[k] == k && (v->Output[k] == dm_dp || v->Output[k] == dm_edp || v->Output[k] == dm_hdmi)\n\t\t\t\t\t&& (v->OutputBppPerState[i][k] == 0\n\t\t\t\t\t\t\t|| (v->OutputFormat[k] == dm_420 && v->Interlace[k] == true && v->ProgressiveToInterlaceUnitInOPP == true))) {\n\t\t\t\tv->DIOSupport[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; ++i) {\n\t\tv->ODMCombine4To1SupportCheckOK[i] = true;\n\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\tif (v->BlendingAndTiming[k] == k && v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1\n\t\t\t\t\t&& (v->ODMCombine4To1Supported == false || v->Output[k] == dm_dp || v->Output[k] == dm_edp || v->Output[k] == dm_hdmi)) {\n\t\t\t\tv->ODMCombine4To1SupportCheckOK[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tv->NotEnoughDSCUnits[i] = false;\n\t\tv->TotalDSCUnitsRequired = 0.0;\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tif (v->RequiresDSC[i][k] == true) {\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 4.0;\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 2.0;\n\t\t\t\t} else {\n\t\t\t\t\tv->TotalDSCUnitsRequired = v->TotalDSCUnitsRequired + 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (v->TotalDSCUnitsRequired > v->NumberOfDSC) {\n\t\t\tv->NotEnoughDSCUnits[i] = true;\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tif (v->OutputBppPerState[i][k] == BPP_INVALID) {\n\t\t\t\tv->BPP = 0.0;\n\t\t\t} else {\n\t\t\t\tv->BPP = v->OutputBppPerState[i][k];\n\t\t\t}\n\t\t\tif (v->RequiresDSC[i][k] == true && v->BPP != 0.0) {\n\t\t\t\tif (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = dscceComputeDelay(\n\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\tv->NumberOfDSCSlices[k],\n\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t\t} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = 2.0\n\t\t\t\t\t\t\t* dscceComputeDelay(\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 2,\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]);\n\t\t\t\t} else {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = 4.0\n\t\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\t\tv->DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tv->BPP,\n\t\t\t\t\t\t\t\t\tdml_ceil(1.0 * v->HActive[k] / v->NumberOfDSCSlices[k], 1.0),\n\t\t\t\t\t\t\t\t\tv->NumberOfDSCSlices[k] / 4,\n\t\t\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\t\t\tv->Output[k]) + dscComputeDelay(v->OutputFormat[k], v->Output[k]));\n\t\t\t\t}\n\t\t\t\tv->DSCDelayPerState[i][k] = v->DSCDelayPerState[i][k] * v->PixelClock[k] / v->PixelClockBackEnd[k];\n\t\t\t} else {\n\t\t\t\tv->DSCDelayPerState[i][k] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tfor (m = 0; m <= v->NumberOfActivePlanes - 1; m++) {\n\t\t\t\tif (v->BlendingAndTiming[k] == m && v->RequiresDSC[i][m] == true) {\n\t\t\t\t\tv->DSCDelayPerState[i][k] = v->DSCDelayPerState[i][m];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->RequiredDPPCLKThisState[k] = v->RequiredDPPCLK[i][j][k];\n\t\t\t\tv->NoOfDPPThisState[k] = v->NoOfDPP[i][j][k];\n\t\t\t\tv->ODMCombineEnableThisState[k] = v->ODMCombineEnablePerState[i][k];\n\t\t\t}\n\n\t\t\tCalculateSwathAndDETConfiguration(\n\t\t\t\t\tfalse,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\tv->MaximumSwathWidthLuma,\n\t\t\t\t\tv->MaximumSwathWidthChroma,\n\t\t\t\t\tv->SourceScan,\n\t\t\t\t\tv->SourcePixelFormat,\n\t\t\t\t\tv->SurfaceTiling,\n\t\t\t\t\tv->ViewportWidth,\n\t\t\t\t\tv->ViewportHeight,\n\t\t\t\t\tv->SurfaceWidthY,\n\t\t\t\t\tv->SurfaceWidthC,\n\t\t\t\t\tv->SurfaceHeightY,\n\t\t\t\t\tv->SurfaceHeightC,\n\t\t\t\t\tv->Read256BlockHeightY,\n\t\t\t\t\tv->Read256BlockHeightC,\n\t\t\t\t\tv->Read256BlockWidthY,\n\t\t\t\t\tv->Read256BlockWidthC,\n\t\t\t\t\tv->ODMCombineEnableThisState,\n\t\t\t\t\tv->BlendingAndTiming,\n\t\t\t\t\tv->BytePerPixelY,\n\t\t\t\t\tv->BytePerPixelC,\n\t\t\t\t\tv->BytePerPixelInDETY,\n\t\t\t\t\tv->BytePerPixelInDETC,\n\t\t\t\t\tv->HActive,\n\t\t\t\t\tv->HRatio,\n\t\t\t\t\tv->HRatioChroma,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->swath_width_luma_ub_this_state,\n\t\t\t\t\tv->swath_width_chroma_ub_this_state,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->SwathHeightYThisState,\n\t\t\t\t\tv->SwathHeightCThisState,\n\t\t\t\t\tv->DETBufferSizeYThisState,\n\t\t\t\t\tv->DETBufferSizeCThisState,\n\t\t\t\t\tv->dummystring,\n\t\t\t\t\t&v->ViewportSizeSupport[i][j]);\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->swath_width_luma_ub_all_states[i][j][k] = v->swath_width_luma_ub_this_state[k];\n\t\t\t\tv->swath_width_chroma_ub_all_states[i][j][k] = v->swath_width_chroma_ub_this_state[k];\n\t\t\t\tv->SwathWidthYAllStates[i][j][k] = v->SwathWidthYThisState[k];\n\t\t\t\tv->SwathWidthCAllStates[i][j][k] = v->SwathWidthCThisState[k];\n\t\t\t\tv->SwathHeightYAllStates[i][j][k] = v->SwathHeightYThisState[k];\n\t\t\t\tv->SwathHeightCAllStates[i][j][k] = v->SwathHeightCThisState[k];\n\t\t\t\tv->DETBufferSizeYAllStates[i][j][k] = v->DETBufferSizeYThisState[k];\n\t\t\t\tv->DETBufferSizeCAllStates[i][j][k] = v->DETBufferSizeCThisState[k];\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tv->cursor_bw[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0 / (v->HTotal[k] / v->PixelClock[k]) * v->VRatio[k];\n\t}\n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tv->swath_width_luma_ub_this_state[k] = v->swath_width_luma_ub_all_states[i][j][k];\n\t\t\t\tv->swath_width_chroma_ub_this_state[k] = v->swath_width_chroma_ub_all_states[i][j][k];\n\t\t\t\tv->SwathWidthYThisState[k] = v->SwathWidthYAllStates[i][j][k];\n\t\t\t\tv->SwathWidthCThisState[k] = v->SwathWidthCAllStates[i][j][k];\n\t\t\t\tv->SwathHeightYThisState[k] = v->SwathHeightYAllStates[i][j][k];\n\t\t\t\tv->SwathHeightCThisState[k] = v->SwathHeightCAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeYThisState[k] = v->DETBufferSizeYAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeCThisState[k] = v->DETBufferSizeCAllStates[i][j][k];\n\t\t\t}\n\n\t\t\tv->TotalNumberOfDCCActiveDPP[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (v->DCCEnable[k] == true) {\n\t\t\t\t\tv->TotalNumberOfDCCActiveDPP[i][j] = v->TotalNumberOfDCCActiveDPP[i][j] + v->NoOfDPP[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif (v->SourcePixelFormat[k] == dm_420_8 || v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12\n\t\t\t\t\t\t|| v->SourcePixelFormat[k] == dm_rgbe_alpha) {\n\n\t\t\t\t\tif ((v->SourcePixelFormat[k] == dm_420_10 || v->SourcePixelFormat[k] == dm_420_12) && v->SourceScan[k] != dm_vert) {\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = (v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma) / 2;\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsForLuma;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma;\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = v->PTEBufferSizeInRequestsChroma;\n\t\t\t\t\t}\n\n\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrameC = CalculateVMAndRowBytes(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\t\tv->Read256BlockHeightC[k],\n\t\t\t\t\t\t\tv->Read256BlockWidthY[k],\n\t\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\t\t\tv->SwathWidthCThisState[k],\n\t\t\t\t\t\t\tv->ViewportHeightChroma[k],\n\t\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma,\n\t\t\t\t\t\t\tv->PitchC[k],\n\t\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t\t&v->MacroTileWidthC[k],\n\t\t\t\t\t\t\t&v->MetaRowBytesC,\n\t\t\t\t\t\t\t&v->DPTEBytesPerRowC,\n\t\t\t\t\t\t\t&v->PTEBufferSizeNotExceededC[i][j][k],\n\t\t\t\t\t\t\t&v->dummyinteger7,\n\t\t\t\t\t\t\t&v->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\t&v->dummyinteger28,\n\t\t\t\t\t\t\t&v->dummyinteger26,\n\t\t\t\t\t\t\t&v->dummyinteger23,\n\t\t\t\t\t\t\t&v->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t&v->dummyinteger8,\n\t\t\t\t\t\t\t&v->dummyinteger9,\n\t\t\t\t\t\t\t&v->dummyinteger19,\n\t\t\t\t\t\t\t&v->dummyinteger20,\n\t\t\t\t\t\t\t&v->dummyinteger17,\n\t\t\t\t\t\t\t&v->dummyinteger10,\n\t\t\t\t\t\t\t&v->dummyinteger11);\n\n\t\t\t\t\tv->PrefetchLinesC[i][j][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\t\tv->VTAPsChroma[k],\n\t\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tv->ViewportYStartC[k],\n\t\t\t\t\t\t\t&v->PrefillC[k],\n\t\t\t\t\t\t\t&v->MaxNumSwC[k]);\n\t\t\t\t} else {\n\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma = v->PTEBufferSizeInRequestsLuma + v->PTEBufferSizeInRequestsChroma;\n\t\t\t\t\tv->PTEBufferSizeInRequestsForChroma = 0;\n\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrameC = 0.0;\n\t\t\t\t\tv->MetaRowBytesC = 0.0;\n\t\t\t\t\tv->DPTEBytesPerRowC = 0.0;\n\t\t\t\t\tv->PrefetchLinesC[i][j][k] = 0.0;\n\t\t\t\t\tv->PTEBufferSizeNotExceededC[i][j][k] = true;\n\t\t\t\t}\n\t\t\t\tv->PDEAndMetaPTEBytesPerFrameY = CalculateVMAndRowBytes(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\tv->Read256BlockHeightY[k],\n\t\t\t\t\t\tv->Read256BlockWidthY[k],\n\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\tv->SurfaceTiling[k],\n\t\t\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\t\t\tv->SourceScan[k],\n\t\t\t\t\t\tv->SwathWidthYThisState[k],\n\t\t\t\t\t\tv->ViewportHeight[k],\n\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\tv->GPUVMMinPageSize,\n\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\tv->PTEBufferSizeInRequestsForLuma,\n\t\t\t\t\t\tv->PitchY[k],\n\t\t\t\t\t\tv->DCCMetaPitchY[k],\n\t\t\t\t\t\t&v->MacroTileWidthY[k],\n\t\t\t\t\t\t&v->MetaRowBytesY,\n\t\t\t\t\t\t&v->DPTEBytesPerRowY,\n\t\t\t\t\t\t&v->PTEBufferSizeNotExceededY[i][j][k],\n\t\t\t\t\t\tv->dummyinteger4,\n\t\t\t\t\t\t&v->dpte_row_height[k],\n\t\t\t\t\t\t&v->dummyinteger29,\n\t\t\t\t\t\t&v->dummyinteger27,\n\t\t\t\t\t\t&v->dummyinteger24,\n\t\t\t\t\t\t&v->meta_row_height[k],\n\t\t\t\t\t\t&v->dummyinteger25,\n\t\t\t\t\t\t&v->dpte_group_bytes[k],\n\t\t\t\t\t\t&v->dummyinteger21,\n\t\t\t\t\t\t&v->dummyinteger22,\n\t\t\t\t\t\t&v->dummyinteger18,\n\t\t\t\t\t\t&v->dummyinteger5,\n\t\t\t\t\t\t&v->dummyinteger6);\n\t\t\t\tv->PrefetchLinesY[i][j][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->vtaps[k],\n\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\tv->ViewportYStartY[k],\n\t\t\t\t\t\t&v->PrefillY[k],\n\t\t\t\t\t\t&v->MaxNumSwY[k]);\n\t\t\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k] = v->PDEAndMetaPTEBytesPerFrameY + v->PDEAndMetaPTEBytesPerFrameC;\n\t\t\t\tv->MetaRowBytes[i][j][k] = v->MetaRowBytesY + v->MetaRowBytesC;\n\t\t\t\tv->DPTEBytesPerRow[i][j][k] = v->DPTEBytesPerRowY + v->DPTEBytesPerRowC;\n\n\t\t\t\tCalculateRowBandwidth(\n\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\tv->MetaRowBytesY,\n\t\t\t\t\t\tv->MetaRowBytesC,\n\t\t\t\t\t\tv->meta_row_height[k],\n\t\t\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\t\t\tv->DPTEBytesPerRowY,\n\t\t\t\t\t\tv->DPTEBytesPerRowC,\n\t\t\t\t\t\tv->dpte_row_height[k],\n\t\t\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t\t\t&v->meta_row_bandwidth[i][j][k],\n\t\t\t\t\t\t&v->dpte_row_bandwidth[i][j][k]);\n\t\t\t}\n\t\t\tv->UrgLatency[i] = CalculateUrgentLatency(\n\t\t\t\t\tv->UrgentLatencyPixelDataOnly,\n\t\t\t\t\tv->UrgentLatencyPixelMixedWithVMData,\n\t\t\t\t\tv->UrgentLatencyVMDataOnly,\n\t\t\t\t\tv->DoUrgentLatencyAdjustment,\n\t\t\t\t\tv->UrgentLatencyAdjustmentFabricClockComponent,\n\t\t\t\t\tv->UrgentLatencyAdjustmentFabricClockReference,\n\t\t\t\t\tv->FabricClockPerState[i]);\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\t\tv->swath_width_luma_ub_this_state[k],\n\t\t\t\t\t\tv->swath_width_chroma_ub_this_state[k],\n\t\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\tv->BytePerPixelInDETY[k],\n\t\t\t\t\t\tv->BytePerPixelInDETC[k],\n\t\t\t\t\t\tv->DETBufferSizeYThisState[k],\n\t\t\t\t\t\tv->DETBufferSizeCThisState[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorLuma[k],\n\t\t\t\t\t\t&v->UrgentBurstFactorChroma[k],\n\t\t\t\t\t\t&NotUrgentLatencyHiding[k]);\n\t\t\t}\n\n\t\t\tv->NotUrgentLatencyHiding[i][j] = false;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tif (NotUrgentLatencyHiding[k]) {\n\t\t\t\t\tv->NotUrgentLatencyHiding[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->VActivePixelBandwidth[i][j][k] = v->ReadBandwidthLuma[k] * v->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t+ v->ReadBandwidthChroma[k] * v->UrgentBurstFactorChroma[k];\n\t\t\t\tv->VActiveCursorBandwidth[i][j][k] = v->cursor_bw[k] * v->UrgentBurstFactorCursor[k];\n\t\t\t}\n\n\t\t\tv->TotalVActivePixelBandwidth[i][j] = 0;\n\t\t\tv->TotalVActiveCursorBandwidth[i][j] = 0;\n\t\t\tv->TotalMetaRowBandwidth[i][j] = 0;\n\t\t\tv->TotalDPTERowBandwidth[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->TotalVActivePixelBandwidth[i][j] = v->TotalVActivePixelBandwidth[i][j] + v->VActivePixelBandwidth[i][j][k];\n\t\t\t\tv->TotalVActiveCursorBandwidth[i][j] = v->TotalVActiveCursorBandwidth[i][j] + v->VActiveCursorBandwidth[i][j][k];\n\t\t\t\tv->TotalMetaRowBandwidth[i][j] = v->TotalMetaRowBandwidth[i][j] + v->NoOfDPP[i][j][k] * v->meta_row_bandwidth[i][j][k];\n\t\t\t\tv->TotalDPTERowBandwidth[i][j] = v->TotalDPTERowBandwidth[i][j] + v->NoOfDPP[i][j][k] * v->dpte_row_bandwidth[i][j][k];\n\t\t\t}\n\n\t\t\tCalculateDCFCLKDeepSleep(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->BytePerPixelY,\n\t\t\t\t\tv->BytePerPixelC,\n\t\t\t\t\tv->VRatio,\n\t\t\t\t\tv->VRatioChroma,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->HRatio,\n\t\t\t\t\tv->HRatioChroma,\n\t\t\t\t\tv->PixelClock,\n\t\t\t\t\tv->PSCL_FACTOR,\n\t\t\t\t\tv->PSCL_FACTOR_CHROMA,\n\t\t\t\t\tv->RequiredDPPCLKThisState,\n\t\t\t\t\tv->ReadBandwidthLuma,\n\t\t\t\t\tv->ReadBandwidthChroma,\n\t\t\t\t\tv->ReturnBusWidth,\n\t\t\t\t\t&v->ProjectedDCFCLKDeepSleep[i][j]);\n\t\t}\n\t}\n\n\t\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif (v->BlendingAndTiming[k] == k) {\n\t\t\t\t\tif (v->WritebackEnable[k] == true) {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = v->WritebackLatency\n\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[k],\n\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[k],\n\t\t\t\t\t\t\t\t\t\tv->HTotal[k]) / v->RequiredDISPCLK[i][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (m = 0; m <= v->NumberOfActivePlanes - 1; m++) {\n\t\t\t\t\t\tif (v->BlendingAndTiming[m] == k && v->WritebackEnable[m] == true) {\n\t\t\t\t\t\t\tv->WritebackDelayTime[k] = dml_max(\n\t\t\t\t\t\t\t\t\tv->WritebackDelayTime[k],\n\t\t\t\t\t\t\t\t\tv->WritebackLatency\n\t\t\t\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackPixelFormat[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackHRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackVRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackVTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationWidth[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackDestinationHeight[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->WritebackSourceHeight[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tv->HTotal[m]) / v->RequiredDISPCLK[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tfor (m = 0; m <= v->NumberOfActivePlanes - 1; m++) {\n\t\t\t\t\tif (v->BlendingAndTiming[k] == m) {\n\t\t\t\t\t\tv->WritebackDelayTime[k] = v->WritebackDelayTime[m];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->MaxMaxVStartup[i][j] = 0;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tv->MaximumVStartup[i][j][k] = v->VTotal[k] - v->VActive[k]\n\t\t\t\t\t\t- dml_max(1.0, dml_ceil(1.0 * v->WritebackDelayTime[k] / (v->HTotal[k] / v->PixelClock[k]), 1.0));\n\t\t\t\tv->MaxMaxVStartup[i][j] = dml_max(v->MaxMaxVStartup[i][j], v->MaximumVStartup[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tReorderingBytes = v->NumberOfChannels\n\t\t\t* dml_max3(\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\t\t\tv->UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\tv->FinalDRAMClockChangeLatency = (v->DRAMClockChangeLatencyOverride > 0 ? v->DRAMClockChangeLatencyOverride : v->DRAMClockChangeLatency);\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tv->DCFCLKState[i][j] = v->DCFCLKPerState[i];\n\t\t}\n\t}\n\n\tif (v->UseMinimumRequiredDCFCLK == true) {\n\t\tUseMinimumDCFCLK(mode_lib, v, MaxPrefetchMode, ReorderingBytes);\n\n\t\tif (v->ClampMinDCFCLK) {\n\t\t\t \n\t\t\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\t\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\t\t\tif (v->DCFCLKState[i][j] < mode_lib->soc.min_dcfclk) {\n\t\t\t\t\t\tv->DCFCLKState[i][j] = mode_lib->soc.min_dcfclk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tv->IdealSDPPortBandwidthPerState[i][j] = dml_min3(\n\t\t\t\t\tv->ReturnBusWidth * v->DCFCLKState[i][j],\n\t\t\t\t\tv->DRAMSpeedPerState[i] * v->NumberOfChannels * v->DRAMChannelWidth,\n\t\t\t\t\tv->FabricClockPerState[i] * v->FabricDatapathToDCNDataReturn);\n\t\t\tif (v->HostVMEnable != true) {\n\t\t\t\tv->ReturnBWPerState[i][j] = v->IdealSDPPortBandwidthPerState[i][j] * v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly\n\t\t\t\t\t\t/ 100;\n\t\t\t} else {\n\t\t\t\tv->ReturnBWPerState[i][j] = v->IdealSDPPortBandwidthPerState[i][j]\n\t\t\t\t\t\t* v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / 100;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tif ((v->ROBBufferSizeInKByte - v->PixelChunkSizeInKByte) * 1024 / v->ReturnBWPerState[i][j]\n\t\t\t\t\t> (v->RoundTripPingLatencyCycles + 32) / v->DCFCLKState[i][j] + ReorderingBytes / v->ReturnBWPerState[i][j]) {\n\t\t\t\tv->ROBSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->ROBSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\n\tMaxTotalVActiveRDBandwidth = 0;\n\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\tMaxTotalVActiveRDBandwidth = MaxTotalVActiveRDBandwidth + v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k];\n\t}\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tv->MaxTotalVerticalActiveAvailableBandwidth[i][j] = dml_min(\n\t\t\t\t\tv->IdealSDPPortBandwidthPerState[i][j] * v->MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation / 100,\n\t\t\t\t\tv->DRAMSpeedPerState[i] * v->NumberOfChannels * v->DRAMChannelWidth * v->MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation\n\t\t\t\t\t\t\t/ 100);\n\t\t\tif (MaxTotalVActiveRDBandwidth <= v->MaxTotalVerticalActiveAvailableBandwidth[i][j]) {\n\t\t\t\tv->TotalVerticalActiveBandwidthSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->TotalVerticalActiveBandwidthSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tint NextPrefetchModeState = MinPrefetchMode;\n\n\t\t\tv->TimeCalc = 24 / v->ProjectedDCFCLKDeepSleep[i][j];\n\n\t\t\tv->BandwidthWithoutPrefetchSupported[i][j] = true;\n\t\t\tif (v->TotalVActivePixelBandwidth[i][j] + v->TotalVActiveCursorBandwidth[i][j] + v->TotalMetaRowBandwidth[i][j] + v->TotalDPTERowBandwidth[i][j]\n\t\t\t\t\t> v->ReturnBWPerState[i][j] || v->NotUrgentLatencyHiding[i][j]) {\n\t\t\t\tv->BandwidthWithoutPrefetchSupported[i][j] = false;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tv->NoOfDPPThisState[k] = v->NoOfDPP[i][j][k];\n\t\t\t\tv->swath_width_luma_ub_this_state[k] = v->swath_width_luma_ub_all_states[i][j][k];\n\t\t\t\tv->swath_width_chroma_ub_this_state[k] = v->swath_width_chroma_ub_all_states[i][j][k];\n\t\t\t\tv->SwathWidthYThisState[k] = v->SwathWidthYAllStates[i][j][k];\n\t\t\t\tv->SwathWidthCThisState[k] = v->SwathWidthCAllStates[i][j][k];\n\t\t\t\tv->SwathHeightYThisState[k] = v->SwathHeightYAllStates[i][j][k];\n\t\t\t\tv->SwathHeightCThisState[k] = v->SwathHeightCAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeYThisState[k] = v->DETBufferSizeYAllStates[i][j][k];\n\t\t\t\tv->DETBufferSizeCThisState[k] = v->DETBufferSizeCAllStates[i][j][k];\n\t\t\t\tv->ODMCombineEnabled[k] = v->ODMCombineEnablePerState[i][k];\n\t\t\t}\n\n\t\t\tv->ExtraLatency = CalculateExtraLatency(\n\t\t\t\t\tv->RoundTripPingLatencyCycles,\n\t\t\t\t\tReorderingBytes,\n\t\t\t\t\tv->DCFCLKState[i][j],\n\t\t\t\t\tv->TotalNumberOfActiveDPP[i][j],\n\t\t\t\t\tv->PixelChunkSizeInKByte,\n\t\t\t\t\tv->TotalNumberOfDCCActiveDPP[i][j],\n\t\t\t\t\tv->MetaChunkSize,\n\t\t\t\t\tv->ReturnBWPerState[i][j],\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->dpte_group_bytes,\n\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels);\n\n\t\t\tv->NextMaxVStartup = v->MaxMaxVStartup[i][j];\n\t\t\tdo {\n\t\t\t\tv->PrefetchModePerState[i][j] = NextPrefetchModeState;\n\t\t\t\tv->MaxVStartup = v->NextMaxVStartup;\n\n\t\t\t\tv->TWait = CalculateTWait(v->PrefetchModePerState[i][j], v->FinalDRAMClockChangeLatency, v->UrgLatency[i], v->SREnterPlusExitTime);\n\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tPipe myPipe = { 0 };\n\n\t\t\t\t\tmyPipe.DPPCLK = v->RequiredDPPCLK[i][j][k];\n\t\t\t\t\tmyPipe.DISPCLK = v->RequiredDISPCLK[i][j];\n\t\t\t\t\tmyPipe.PixelClock = v->PixelClock[k];\n\t\t\t\t\tmyPipe.DCFCLKDeepSleep = v->ProjectedDCFCLKDeepSleep[i][j];\n\t\t\t\t\tmyPipe.DPPPerPlane = v->NoOfDPP[i][j][k];\n\t\t\t\t\tmyPipe.ScalerEnabled = v->ScalerEnabled[k];\n\t\t\t\t\tmyPipe.SourceScan = v->SourceScan[k];\n\t\t\t\t\tmyPipe.BlockWidth256BytesY = v->Read256BlockWidthY[k];\n\t\t\t\t\tmyPipe.BlockHeight256BytesY = v->Read256BlockHeightY[k];\n\t\t\t\t\tmyPipe.BlockWidth256BytesC = v->Read256BlockWidthC[k];\n\t\t\t\t\tmyPipe.BlockHeight256BytesC = v->Read256BlockHeightC[k];\n\t\t\t\t\tmyPipe.InterlaceEnable = v->Interlace[k];\n\t\t\t\t\tmyPipe.NumberOfCursors = v->NumberOfCursors[k];\n\t\t\t\t\tmyPipe.VBlank = v->VTotal[k] - v->VActive[k];\n\t\t\t\t\tmyPipe.HTotal = v->HTotal[k];\n\t\t\t\t\tmyPipe.DCCEnable = v->DCCEnable[k];\n\t\t\t\t\tmyPipe.ODMCombineEnabled = !!v->ODMCombineEnabled[k];\n\n\t\t\t\t\tv->NoTimeForPrefetch[i][j][k] = CalculatePrefetchSchedule(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\t\t&myPipe,\n\t\t\t\t\t\t\tv->DSCDelayPerState[i][k],\n\t\t\t\t\t\t\tv->DPPCLKDelaySubtotal + v->DPPCLKDelayCNVCFormater,\n\t\t\t\t\t\t\tv->DPPCLKDelaySCL,\n\t\t\t\t\t\t\tv->DPPCLKDelaySCLLBOnly,\n\t\t\t\t\t\t\tv->DPPCLKDelayCNVCCursor,\n\t\t\t\t\t\t\tv->DISPCLKDelaySubtotal,\n\t\t\t\t\t\t\tv->SwathWidthYThisState[k] / v->HRatio[k],\n\t\t\t\t\t\t\tv->OutputFormat[k],\n\t\t\t\t\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\t\t\t\t\tdml_min(v->MaxVStartup, v->MaximumVStartup[i][j][k]),\n\t\t\t\t\t\t\tv->MaximumVStartup[i][j][k],\n\t\t\t\t\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\t\tv->DynamicMetadataEnable[k],\n\t\t\t\t\t\t\tv->DynamicMetadataVMEnabled,\n\t\t\t\t\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\t\tv->ExtraLatency,\n\t\t\t\t\t\t\tv->TimeCalc,\n\t\t\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k],\n\t\t\t\t\t\t\tv->MetaRowBytes[i][j][k],\n\t\t\t\t\t\t\tv->DPTEBytesPerRow[i][j][k],\n\t\t\t\t\t\t\tv->PrefetchLinesY[i][j][k],\n\t\t\t\t\t\t\tv->SwathWidthYThisState[k],\n\t\t\t\t\t\t\tv->BytePerPixelY[k],\n\t\t\t\t\t\t\tv->PrefillY[k],\n\t\t\t\t\t\t\tv->MaxNumSwY[k],\n\t\t\t\t\t\t\tv->PrefetchLinesC[i][j][k],\n\t\t\t\t\t\t\tv->SwathWidthCThisState[k],\n\t\t\t\t\t\t\tv->BytePerPixelC[k],\n\t\t\t\t\t\t\tv->PrefillC[k],\n\t\t\t\t\t\t\tv->MaxNumSwC[k],\n\t\t\t\t\t\t\tv->swath_width_luma_ub_this_state[k],\n\t\t\t\t\t\t\tv->swath_width_chroma_ub_this_state[k],\n\t\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tv->TWait,\n\t\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\t&v->DSTXAfterScaler[k],\n\t\t\t\t\t\t\t&v->DSTYAfterScaler[k],\n\t\t\t\t\t\t\t&v->LineTimesForPrefetch[k],\n\t\t\t\t\t\t\t&v->PrefetchBW[k],\n\t\t\t\t\t\t\t&v->LinesForMetaPTE[k],\n\t\t\t\t\t\t\t&v->LinesForMetaAndDPTERow[k],\n\t\t\t\t\t\t\t&v->VRatioPreY[i][j][k],\n\t\t\t\t\t\t\t&v->VRatioPreC[i][j][k],\n\t\t\t\t\t\t\t&v->RequiredPrefetchPixelDataBWLuma[i][j][k],\n\t\t\t\t\t\t\t&v->RequiredPrefetchPixelDataBWChroma[i][j][k],\n\t\t\t\t\t\t\t&v->NoTimeForDynamicMetadata[i][j][k],\n\t\t\t\t\t\t\t&v->Tno_bw[k],\n\t\t\t\t\t\t\t&v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t&v->Tdmdl_vm[k],\n\t\t\t\t\t\t\t&v->Tdmdl[k],\n\t\t\t\t\t\t\t&v->VUpdateOffsetPix[k],\n\t\t\t\t\t\t\t&v->VUpdateWidthPix[k],\n\t\t\t\t\t\t\t&v->VReadyOffsetPix[k]);\n\t\t\t\t}\n\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\t\t\tv->swath_width_luma_ub_this_state[k],\n\t\t\t\t\t\t\tv->swath_width_chroma_ub_this_state[k],\n\t\t\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\t\t\tv->SwathHeightYThisState[k],\n\t\t\t\t\t\t\tv->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\t\tv->CursorBufferSize,\n\t\t\t\t\t\t\tv->CursorWidth[k][0],\n\t\t\t\t\t\t\tv->CursorBPP[k][0],\n\t\t\t\t\t\t\tv->VRatioPreY[i][j][k],\n\t\t\t\t\t\t\tv->VRatioPreC[i][j][k],\n\t\t\t\t\t\t\tv->BytePerPixelInDETY[k],\n\t\t\t\t\t\t\tv->BytePerPixelInDETC[k],\n\t\t\t\t\t\t\tv->DETBufferSizeYThisState[k],\n\t\t\t\t\t\t\tv->DETBufferSizeCThisState[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorCursorPre[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorLumaPre[k],\n\t\t\t\t\t\t\t&v->UrgentBurstFactorChromaPre[k],\n\t\t\t\t\t\t\t&v->NoUrgentLatencyHidingPre[k]);\n\t\t\t\t}\n\n\t\t\t\tv->MaximumReadBandwidthWithPrefetch = 0.0;\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tv->cursor_bw_pre[k] = v->NumberOfCursors[k] * v->CursorWidth[k][0] * v->CursorBPP[k][0] / 8.0 / (v->HTotal[k] / v->PixelClock[k])\n\t\t\t\t\t\t\t* v->VRatioPreY[i][j][k];\n\n\t\t\t\t\tv->MaximumReadBandwidthWithPrefetch = v->MaximumReadBandwidthWithPrefetch\n\t\t\t\t\t\t\t+ dml_max4(\n\t\t\t\t\t\t\t\t\tv->VActivePixelBandwidth[i][j][k],\n\t\t\t\t\t\t\t\t\tv->VActiveCursorBandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t+ v->NoOfDPP[i][j][k] * (v->meta_row_bandwidth[i][j][k] + v->dpte_row_bandwidth[i][j][k]),\n\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixelDataBWLuma[i][j][k] * v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t}\n\n\t\t\t\tv->NotEnoughUrgentLatencyHidingPre = false;\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (v->NoUrgentLatencyHidingPre[k] == true) {\n\t\t\t\t\t\tv->NotEnoughUrgentLatencyHidingPre = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->PrefetchSupported[i][j] = true;\n\t\t\t\tif (v->BandwidthWithoutPrefetchSupported[i][j] == false || v->MaximumReadBandwidthWithPrefetch > v->ReturnBWPerState[i][j]\n\t\t\t\t\t\t|| v->NotEnoughUrgentLatencyHidingPre == 1) {\n\t\t\t\t\tv->PrefetchSupported[i][j] = false;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (v->LineTimesForPrefetch[k] < 2.0 || v->LinesForMetaPTE[k] >= 32.0 || v->LinesForMetaAndDPTERow[k] >= 16.0\n\t\t\t\t\t\t\t|| v->NoTimeForPrefetch[i][j][k] == true) {\n\t\t\t\t\t\tv->PrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->DynamicMetadataSupported[i][j] = true;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\tif (v->NoTimeForDynamicMetadata[i][j][k] == true) {\n\t\t\t\t\t\tv->DynamicMetadataSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv->VRatioInPrefetchSupported[i][j] = true;\n\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (v->VRatioPreY[i][j][k] > 4.0 || v->VRatioPreC[i][j][k] > 4.0 || v->NoTimeForPrefetch[i][j][k] == true) {\n\t\t\t\t\t\tv->VRatioInPrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv->AnyLinesForVMOrRowTooLarge = false;\n\t\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\t\tif (v->LinesForMetaAndDPTERow[k] >= 16 || v->LinesForMetaPTE[k] >= 32) {\n\t\t\t\t\t\tv->AnyLinesForVMOrRowTooLarge = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (v->PrefetchSupported[i][j] == true && v->VRatioInPrefetchSupported[i][j] == true) {\n\t\t\t\t\tv->BandwidthAvailableForImmediateFlip = v->ReturnBWPerState[i][j];\n\t\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\t\tv->BandwidthAvailableForImmediateFlip = v->BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\t\t\tv->VActivePixelBandwidth[i][j][k] + v->VActiveCursorBandwidth[i][j][k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* (v->RequiredPrefetchPixelDataBWLuma[i][j][k] * v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->TotImmediateFlipBytes = 0.0;\n\t\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\t\tv->TotImmediateFlipBytes = v->TotImmediateFlipBytes + v->NoOfDPP[i][j][k] * (v->PDEAndMetaPTEBytesPerFrame[i][j][k]\n\t\t\t\t\t\t\t\t+ v->MetaRowBytes[i][j][k] + v->DPTEBytesPerRow[i][j][k]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\t\t\tv->ExtraLatency,\n\t\t\t\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\t\t\t\tv->GPUVMMaxPageTableLevels,\n\t\t\t\t\t\t\t\tv->HostVMEnable,\n\t\t\t\t\t\t\t\tv->HostVMMaxNonCachedPageTableLevels,\n\t\t\t\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\t\t\t\tv->HostVMMinPageSize,\n\t\t\t\t\t\t\t\tv->PDEAndMetaPTEBytesPerFrame[i][j][k],\n\t\t\t\t\t\t\t\tv->MetaRowBytes[i][j][k],\n\t\t\t\t\t\t\t\tv->DPTEBytesPerRow[i][j][k],\n\t\t\t\t\t\t\t\tv->BandwidthAvailableForImmediateFlip,\n\t\t\t\t\t\t\t\tv->TotImmediateFlipBytes,\n\t\t\t\t\t\t\t\tv->SourcePixelFormat[k],\n\t\t\t\t\t\t\t\tv->HTotal[k] / v->PixelClock[k],\n\t\t\t\t\t\t\t\tv->VRatio[k],\n\t\t\t\t\t\t\t\tv->VRatioChroma[k],\n\t\t\t\t\t\t\t\tv->Tno_bw[k],\n\t\t\t\t\t\t\t\tv->DCCEnable[k],\n\t\t\t\t\t\t\t\tv->dpte_row_height[k],\n\t\t\t\t\t\t\t\tv->meta_row_height[k],\n\t\t\t\t\t\t\t\tv->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\t\tv->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t\t&v->DestinationLinesToRequestVMInImmediateFlip[k],\n\t\t\t\t\t\t\t\t&v->DestinationLinesToRequestRowInImmediateFlip[k],\n\t\t\t\t\t\t\t\t&v->final_flip_bw[k],\n\t\t\t\t\t\t\t\t&v->ImmediateFlipSupportedForPipe[k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->total_dcn_read_bw_with_flip = 0.0;\n\t\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\t\tv->total_dcn_read_bw_with_flip = v->total_dcn_read_bw_with_flip\n\t\t\t\t\t\t\t\t+ dml_max3(\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k] * v->final_flip_bw[k] + v->VActivePixelBandwidth[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->VActiveCursorBandwidth[i][j][k],\n\t\t\t\t\t\t\t\t\t\tv->NoOfDPP[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* (v->final_flip_bw[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWLuma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ v->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* v->UrgentBurstFactorChromaPre[k])\n\t\t\t\t\t\t\t\t\t\t\t\t+ v->cursor_bw_pre[k] * v->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t\t}\n\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = true;\n\t\t\t\t\tif (v->total_dcn_read_bw_with_flip > v->ReturnBWPerState[i][j]) {\n\t\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\t\tif (v->ImmediateFlipSupportedForPipe[k] == false) {\n\t\t\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t}\n\t\t\t\tif (v->MaxVStartup <= 13 || v->AnyLinesForVMOrRowTooLarge == false) {\n\t\t\t\t\tv->NextMaxVStartup = v->MaxMaxVStartup[i][j];\n\t\t\t\t\tNextPrefetchModeState = NextPrefetchModeState + 1;\n\t\t\t\t} else {\n\t\t\t\t\tv->NextMaxVStartup = v->NextMaxVStartup - 1;\n\t\t\t\t}\n\t\t\t} while (!((v->PrefetchSupported[i][j] == true && v->DynamicMetadataSupported[i][j] == true && v->VRatioInPrefetchSupported[i][j] == true\n\t\t\t\t\t&& ((v->HostVMEnable == false && v->ImmediateFlipRequirement[0] != dm_immediate_flip_required)\n\t\t\t\t\t\t\t|| v->ImmediateFlipSupportedForState[i][j] == true))\n\t\t\t\t\t|| (v->NextMaxVStartup == v->MaxMaxVStartup[i][j] && NextPrefetchModeState > MaxPrefetchMode)));\n\n\t\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tv->PrefetchModePerState[i][j],\n\t\t\t\t\tv->NumberOfActivePlanes,\n\t\t\t\t\tv->MaxLineBufferLines,\n\t\t\t\t\tv->LineBufferSize,\n\t\t\t\t\tv->DPPOutputBufferPixels,\n\t\t\t\t\tv->DETBufferSizeInKByte[0],\n\t\t\t\t\tv->WritebackInterfaceBufferSize,\n\t\t\t\t\tv->DCFCLKState[i][j],\n\t\t\t\t\tv->ReturnBWPerState[i][j],\n\t\t\t\t\tv->GPUVMEnable,\n\t\t\t\t\tv->dpte_group_bytes,\n\t\t\t\t\tv->MetaChunkSize,\n\t\t\t\t\tv->UrgLatency[i],\n\t\t\t\t\tv->ExtraLatency,\n\t\t\t\t\tv->WritebackLatency,\n\t\t\t\t\tv->WritebackChunkSize,\n\t\t\t\t\tv->SOCCLKPerState[i],\n\t\t\t\t\tv->FinalDRAMClockChangeLatency,\n\t\t\t\t\tv->SRExitTime,\n\t\t\t\t\tv->SREnterPlusExitTime,\n\t\t\t\t\tv->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\tv->NoOfDPPThisState,\n\t\t\t\t\tv->DCCEnable,\n\t\t\t\t\tv->RequiredDPPCLKThisState,\n\t\t\t\t\tv->DETBufferSizeYThisState,\n\t\t\t\t\tv->DETBufferSizeCThisState,\n\t\t\t\t\tv->SwathHeightYThisState,\n\t\t\t\t\tv->SwathHeightCThisState,\n\t\t\t\t\tv->LBBitPerPixel,\n\t\t\t\t\tv->SwathWidthYThisState,\n\t\t\t\t\tv->SwathWidthCThisState,\n\t\t\t\t\tv->HRatio,\n\t\t\t\t\tv->HRatioChroma,\n\t\t\t\t\tv->vtaps,\n\t\t\t\t\tv->VTAPsChroma,\n\t\t\t\t\tv->VRatio,\n\t\t\t\t\tv->VRatioChroma,\n\t\t\t\t\tv->HTotal,\n\t\t\t\t\tv->PixelClock,\n\t\t\t\t\tv->BlendingAndTiming,\n\t\t\t\t\tv->BytePerPixelInDETY,\n\t\t\t\t\tv->BytePerPixelInDETC,\n\t\t\t\t\tv->DSTXAfterScaler,\n\t\t\t\t\tv->DSTYAfterScaler,\n\t\t\t\t\tv->WritebackEnable,\n\t\t\t\t\tv->WritebackPixelFormat,\n\t\t\t\t\tv->WritebackDestinationWidth,\n\t\t\t\t\tv->WritebackDestinationHeight,\n\t\t\t\t\tv->WritebackSourceHeight,\n\t\t\t\t\t&v->DRAMClockChangeSupport[i][j],\n\t\t\t\t\t&v->UrgentWatermark,\n\t\t\t\t\t&v->WritebackUrgentWatermark,\n\t\t\t\t\t&v->DRAMClockChangeWatermark,\n\t\t\t\t\t&v->WritebackDRAMClockChangeWatermark,\n\t\t\t\t\t&v->StutterExitWatermark,\n\t\t\t\t\t&v->StutterEnterPlusExitWatermark,\n\t\t\t\t\t&v->MinActiveDRAMClockChangeLatencySupported);\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < v->soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tv->PTEBufferSizeNotExceeded[i][j] = true;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif (v->PTEBufferSizeNotExceededY[i][j][k] == false || v->PTEBufferSizeNotExceededC[i][j][k] == false) {\n\t\t\t\t\tv->PTEBufferSizeNotExceeded[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->CursorSupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->CursorWidth[k][0] > 0.0) {\n\t\t\tif (v->CursorBPP[k][0] == 64 && v->Cursor64BppSupport == false) {\n\t\t\t\tv->CursorSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tv->PitchSupport = true;\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tv->AlignedYPitch[k] = dml_ceil(dml_max(v->PitchY[k], v->SurfaceWidthY[k]), v->MacroTileWidthY[k]);\n\t\tif (v->DCCEnable[k] == true) {\n\t\t\tv->AlignedDCCMetaPitchY[k] = dml_ceil(dml_max(v->DCCMetaPitchY[k], v->SurfaceWidthY[k]), 64.0 * v->Read256BlockWidthY[k]);\n\t\t} else {\n\t\t\tv->AlignedDCCMetaPitchY[k] = v->DCCMetaPitchY[k];\n\t\t}\n\t\tif (v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32 && v->SourcePixelFormat[k] != dm_444_16 && v->SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_rgbe && v->SourcePixelFormat[k] != dm_mono_8) {\n\t\t\tv->AlignedCPitch[k] = dml_ceil(dml_max(v->PitchC[k], v->SurfaceWidthC[k]), v->MacroTileWidthC[k]);\n\t\t\tif (v->DCCEnable[k] == true) {\n\t\t\t\tv->AlignedDCCMetaPitchC[k] = dml_ceil(dml_max(v->DCCMetaPitchC[k], v->SurfaceWidthC[k]), 64.0 * v->Read256BlockWidthC[k]);\n\t\t\t} else {\n\t\t\t\tv->AlignedDCCMetaPitchC[k] = v->DCCMetaPitchC[k];\n\t\t\t}\n\t\t} else {\n\t\t\tv->AlignedCPitch[k] = v->PitchC[k];\n\t\t\tv->AlignedDCCMetaPitchC[k] = v->DCCMetaPitchC[k];\n\t\t}\n\t\tif (v->AlignedYPitch[k] > v->PitchY[k] || v->AlignedCPitch[k] > v->PitchC[k] || v->AlignedDCCMetaPitchY[k] > v->DCCMetaPitchY[k]\n\t\t\t\t|| v->AlignedDCCMetaPitchC[k] > v->DCCMetaPitchC[k]) {\n\t\t\tv->PitchSupport = false;\n\t\t}\n\t}\n\n\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\tif (v->ViewportWidth[k] > v->SurfaceWidthY[k] || v->ViewportHeight[k] > v->SurfaceHeightY[k])\n\t\t\tViewportExceedsSurface = true;\n\n\t\tif (v->SourcePixelFormat[k] != dm_444_64 && v->SourcePixelFormat[k] != dm_444_32 && v->SourcePixelFormat[k] != dm_444_16\n\t\t\t\t&& v->SourcePixelFormat[k] != dm_444_16 && v->SourcePixelFormat[k] != dm_444_8 && v->SourcePixelFormat[k] != dm_rgbe) {\n\t\t\tif (v->ViewportWidthChroma[k] > v->SurfaceWidthC[k] || v->ViewportHeightChroma[k] > v->SurfaceHeightC[k]) {\n\t\t\t\tViewportExceedsSurface = true;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tfor (i = v->soc.num_states - 1; i >= 0; i--) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (v->ScaleRatioAndTapsSupport == 1 && v->SourceFormatPixelAndScanSupport == 1 && v->ViewportSizeSupport[i][j] == 1\n\t\t\t\t\t&& v->DIOSupport[i] == 1 && v->ODMCombine4To1SupportCheckOK[i] == 1\n\t\t\t\t\t&& v->NotEnoughDSCUnits[i] == 0\n\t\t\t\t\t&& v->DTBCLKRequiredMoreThanSupported[i] == 0\n\t\t\t\t\t&& v->ROBSupport[i][j] == 1 && v->DISPCLK_DPPCLK_Support[i][j] == 1 && v->TotalAvailablePipesSupport[i][j] == 1\n\t\t\t\t\t&& EnoughWritebackUnits == 1 && WritebackModeSupport == 1\n\t\t\t\t\t&& v->WritebackLatencySupport == 1 && v->WritebackScaleRatioAndTapsSupport == 1 && v->CursorSupport == 1 && v->PitchSupport == 1\n\t\t\t\t\t&& ViewportExceedsSurface == 0 && v->PrefetchSupported[i][j] == 1 && v->DynamicMetadataSupported[i][j] == 1\n\t\t\t\t\t&& v->TotalVerticalActiveBandwidthSupport[i][j] == 1 && v->VRatioInPrefetchSupported[i][j] == 1\n\t\t\t\t\t&& v->PTEBufferSizeNotExceeded[i][j] == 1 && v->NonsupportedDSCInputBPC == 0\n\t\t\t\t\t&& ((v->HostVMEnable == 0 && v->ImmediateFlipRequirement[0] != dm_immediate_flip_required)\n\t\t\t\t\t\t\t|| v->ImmediateFlipSupportedForState[i][j] == true)) {\n\t\t\t\tv->ModeSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tv->ModeSupport[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tunsigned int MaximumMPCCombine = 0;\n\t\tfor (i = v->soc.num_states; i >= 0; i--) {\n\t\t\tif (i == v->soc.num_states || v->ModeSupport[i][0] == true || v->ModeSupport[i][1] == true) {\n\t\t\t\tv->VoltageLevel = i;\n\t\t\t\tv->ModeIsSupported = v->ModeSupport[i][0] == true || v->ModeSupport[i][1] == true;\n\t\t\t\tif (v->ModeSupport[i][1] == true) {\n\t\t\t\t\tMaximumMPCCombine = 1;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumMPCCombine = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv->ImmediateFlipSupport = v->ImmediateFlipSupportedForState[v->VoltageLevel][MaximumMPCCombine];\n\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {\n\t\t\tv->MPCCombineEnable[k] = v->MPCCombine[v->VoltageLevel][MaximumMPCCombine][k];\n\t\t\tv->DPPPerPlane[k] = v->NoOfDPP[v->VoltageLevel][MaximumMPCCombine][k];\n\t\t}\n\t\tv->DCFCLK = v->DCFCLKState[v->VoltageLevel][MaximumMPCCombine];\n\t\tv->DRAMSpeed = v->DRAMSpeedPerState[v->VoltageLevel];\n\t\tv->FabricClock = v->FabricClockPerState[v->VoltageLevel];\n\t\tv->SOCCLK = v->SOCCLKPerState[v->VoltageLevel];\n\t\tv->ReturnBW = v->ReturnBWPerState[v->VoltageLevel][MaximumMPCCombine];\n\t\tv->maxMpcComb = MaximumMPCCombine;\n\t}\n}\n\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tunsigned int MaxLineBufferLines,\n\t\tunsigned int LineBufferSize,\n\t\tunsigned int DPPOutputBufferPixels,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int WritebackInterfaceBufferSize,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tunsigned int dpte_group_bytes[],\n\t\tunsigned int MetaChunkSize,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble WritebackLatency,\n\t\tdouble WritebackChunkSize,\n\t\tdouble SOCCLK,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble SRExitTime,\n\t\tdouble SREnterPlusExitTime,\n\t\tdouble DCFCLKDeepSleep,\n\t\tunsigned int DPPPerPlane[],\n\t\tbool DCCEnable[],\n\t\tdouble DPPCLK[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tunsigned int SwathHeightY[],\n\t\tunsigned int SwathHeightC[],\n\t\tunsigned int LBBitPerPixel[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tunsigned int vtaps[],\n\t\tunsigned int VTAPsChroma[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tunsigned int HTotal[],\n\t\tdouble PixelClock[],\n\t\tunsigned int BlendingAndTiming[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tdouble DSTXAfterScaler[],\n\t\tdouble DSTYAfterScaler[],\n\t\tbool WritebackEnable[],\n\t\tenum source_format_class WritebackPixelFormat[],\n\t\tdouble WritebackDestinationWidth[],\n\t\tdouble WritebackDestinationHeight[],\n\t\tdouble WritebackSourceHeight[],\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *UrgentWatermark,\n\t\tdouble *WritebackUrgentWatermark,\n\t\tdouble *DRAMClockChangeWatermark,\n\t\tdouble *WritebackDRAMClockChangeWatermark,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *MinActiveDRAMClockChangeLatencySupported)\n{\n\tdouble EffectiveLBLatencyHidingY = 0;\n\tdouble EffectiveLBLatencyHidingC = 0;\n\tdouble LinesInDETY[DC__NUM_DPP__MAX] = { 0 };\n\tdouble LinesInDETC = 0;\n\tunsigned int LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX] = { 0 };\n\tunsigned int LinesInDETCRoundedDownToSwath = 0;\n\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };\n\tdouble FullDETBufferingTimeC = 0;\n\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;\n\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;\n\tdouble WritebackDRAMClockChangeLatencyMargin = 0;\n\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;\n\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;\n\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;\n\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;\n\tdouble WritebackDRAMClockChangeLatencyHiding = 0;\n\tunsigned int k, j;\n\n\tmode_lib->vba.TotalActiveDPP = 0;\n\tmode_lib->vba.TotalDCCActiveDPP = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.TotalActiveDPP = mode_lib->vba.TotalActiveDPP + DPPPerPlane[k];\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmode_lib->vba.TotalDCCActiveDPP = mode_lib->vba.TotalDCCActiveDPP + DPPPerPlane[k];\n\t\t}\n\t}\n\n\t*UrgentWatermark = UrgentLatency + ExtraLatency;\n\n\t*DRAMClockChangeWatermark = DRAMClockChangeLatency + *UrgentWatermark;\n\n\tmode_lib->vba.TotalActiveWriteback = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (WritebackEnable[k] == true) {\n\t\t\tmode_lib->vba.TotalActiveWriteback = mode_lib->vba.TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (mode_lib->vba.TotalActiveWriteback <= 1) {\n\t\t*WritebackUrgentWatermark = WritebackLatency;\n\t} else {\n\t\t*WritebackUrgentWatermark = WritebackLatency + WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tif (mode_lib->vba.TotalActiveWriteback <= 1) {\n\t\t*WritebackDRAMClockChangeWatermark = DRAMClockChangeLatency + WritebackLatency;\n\t} else {\n\t\t*WritebackDRAMClockChangeWatermark = DRAMClockChangeLatency + WritebackLatency + WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\n\t\tmode_lib->vba.LBLatencyHidingSourceLinesY = dml_min((double) MaxLineBufferLines, dml_floor(LineBufferSize / LBBitPerPixel[k] / (SwathWidthY[k] / dml_max(HRatio[k], 1.0)), 1)) - (vtaps[k] - 1);\n\n\t\tmode_lib->vba.LBLatencyHidingSourceLinesC = dml_min((double) MaxLineBufferLines, dml_floor(LineBufferSize / LBBitPerPixel[k] / (SwathWidthC[k] / dml_max(HRatioChroma[k], 1.0)), 1)) - (VTAPsChroma[k] - 1);\n\n\t\tEffectiveLBLatencyHidingY = mode_lib->vba.LBLatencyHidingSourceLinesY / VRatio[k] * (HTotal[k] / PixelClock[k]);\n\n\t\tEffectiveLBLatencyHidingC = mode_lib->vba.LBLatencyHidingSourceLinesC / VRatioChroma[k] * (HTotal[k] / PixelClock[k]);\n\n\t\tLinesInDETY[k] = (double) DETBufferSizeY[k] / BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath[k] = dml_floor(LinesInDETY[k], SwathHeightY[k]);\n\t\tFullDETBufferingTimeY[k] = LinesInDETYRoundedDownToSwath[k] * (HTotal[k] / PixelClock[k]) / VRatio[k];\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tLinesInDETC = mode_lib->vba.DETBufferSizeC[k] / BytePerPixelDETC[k] / SwathWidthC[k];\n\t\t\tLinesInDETCRoundedDownToSwath = dml_floor(LinesInDETC, SwathHeightC[k]);\n\t\t\tFullDETBufferingTimeC = LinesInDETCRoundedDownToSwath * (HTotal[k] / PixelClock[k]) / VRatioChroma[k];\n\t\t} else {\n\t\t\tLinesInDETC = 0;\n\t\t\tFullDETBufferingTimeC = 999999;\n\t\t}\n\n\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY[k] - *UrgentWatermark - (HTotal[k] / PixelClock[k]) * (DSTXAfterScaler[k] / HTotal[k] + DSTYAfterScaler[k]) - *DRAMClockChangeWatermark;\n\n\t\tif (NumberOfActivePlanes > 1) {\n\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY - (1 - 1.0 / NumberOfActivePlanes) * SwathHeightY[k] * HTotal[k] / PixelClock[k] / VRatio[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC - *UrgentWatermark - (HTotal[k] / PixelClock[k]) * (DSTXAfterScaler[k] / HTotal[k] + DSTYAfterScaler[k]) - *DRAMClockChangeWatermark;\n\n\t\t\tif (NumberOfActivePlanes > 1) {\n\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC - (1 - 1.0 / NumberOfActivePlanes) * SwathHeightC[k] * HTotal[k] / PixelClock[k] / VRatioChroma[k];\n\t\t\t}\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(ActiveDRAMClockChangeLatencyMarginY, ActiveDRAMClockChangeLatencyMarginC);\n\t\t} else {\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = ActiveDRAMClockChangeLatencyMarginY;\n\t\t}\n\n\t\tif (WritebackEnable[k] == true) {\n\n\t\t\tWritebackDRAMClockChangeLatencyHiding = WritebackInterfaceBufferSize * 1024 / (WritebackDestinationWidth[k] * WritebackDestinationHeight[k] / (WritebackSourceHeight[k] * HTotal[k] / PixelClock[k]) * 4);\n\t\t\tif (WritebackPixelFormat[k] == dm_444_64) {\n\t\t\t\tWritebackDRAMClockChangeLatencyHiding = WritebackDRAMClockChangeLatencyHiding / 2;\n\t\t\t}\n\t\t\tif (mode_lib->vba.WritebackConfiguration == dm_whole_buffer_for_single_stream_interleave) {\n\t\t\t\tWritebackDRAMClockChangeLatencyHiding = WritebackDRAMClockChangeLatencyHiding * 2;\n\t\t\t}\n\t\t\tWritebackDRAMClockChangeLatencyMargin = WritebackDRAMClockChangeLatencyHiding - mode_lib->vba.WritebackDRAMClockChangeWatermark;\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k], WritebackDRAMClockChangeLatencyMargin);\n\t\t}\n\t}\n\n\tmode_lib->vba.MinActiveDRAMClockChangeMargin = 999999;\n\tPlaneWithMinActiveDRAMClockChangeMargin = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] < mode_lib->vba.MinActiveDRAMClockChangeMargin) {\n\t\t\tmode_lib->vba.MinActiveDRAMClockChangeMargin = mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k];\n\t\t\tif (BlendingAndTiming[k] == k) {\n\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = k;\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < NumberOfActivePlanes; ++j) {\n\t\t\t\t\tif (BlendingAndTiming[k] == j) {\n\t\t\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*MinActiveDRAMClockChangeLatencySupported = mode_lib->vba.MinActiveDRAMClockChangeMargin + DRAMClockChangeLatency;\n\n\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 999999;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (!((k == PlaneWithMinActiveDRAMClockChangeMargin) && (BlendingAndTiming[k] == k)) && !(BlendingAndTiming[k] == PlaneWithMinActiveDRAMClockChangeMargin) && mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] < SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank) {\n\t\t\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k];\n\t\t}\n\t}\n\n\tmode_lib->vba.TotalNumberOfActiveOTG = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (BlendingAndTiming[k] == k) {\n\t\t\tmode_lib->vba.TotalNumberOfActiveOTG = mode_lib->vba.TotalNumberOfActiveOTG + 1;\n\t\t}\n\t}\n\n\tif (mode_lib->vba.MinActiveDRAMClockChangeMargin > 0) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive;\n\t} else if (((mode_lib->vba.SynchronizedVBlank == true || mode_lib->vba.TotalNumberOfActiveOTG == 1 || SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank > 0) && PrefetchMode == 0)) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank;\n\t} else {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t}\n\n\tFullDETBufferingTimeYStutterCriticalPlane = FullDETBufferingTimeY[0];\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (FullDETBufferingTimeY[k] <= FullDETBufferingTimeYStutterCriticalPlane) {\n\t\t\tFullDETBufferingTimeYStutterCriticalPlane = FullDETBufferingTimeY[k];\n\t\t\tTimeToFinishSwathTransferStutterCriticalPlane = (SwathHeightY[k] - (LinesInDETY[k] - LinesInDETYRoundedDownToSwath[k])) * (HTotal[k] / PixelClock[k]) / VRatio[k];\n\t\t}\n\t}\n\n\t*StutterExitWatermark = SRExitTime +  ExtraLatency + 10 / DCFCLKDeepSleep;\n\t*StutterEnterPlusExitWatermark = dml_max(SREnterPlusExitTime + ExtraLatency + 10 / DCFCLKDeepSleep, TimeToFinishSwathTransferStutterCriticalPlane);\n\n}\n\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble ReadBandwidthLuma[],\n\t\tdouble ReadBandwidthChroma[],\n\t\tint ReturnBusWidth,\n\t\tdouble *DCFCLKDeepSleep)\n{\n\tdouble DisplayPipeLineDeliveryTimeLuma = 0;\n\tdouble DisplayPipeLineDeliveryTimeChroma = 0;\n\tunsigned int k;\n\tdouble ReadBandwidth = 0.0;\n\n\t\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthC[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (BytePerPixelC[k] > 0) {\n\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = dml_max(1.1 * SwathWidthY[k] * BytePerPixelY[k] / 32.0 / DisplayPipeLineDeliveryTimeLuma, 1.1 * SwathWidthC[k] * BytePerPixelC[k] / 32.0 / DisplayPipeLineDeliveryTimeChroma);\n\t\t} else {\n\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = 1.1 * SwathWidthY[k] * BytePerPixelY[k] / 64.0 / DisplayPipeLineDeliveryTimeLuma;\n\t\t}\n\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = dml_max(mode_lib->vba.DCFCLKDeepSleepPerPlane[k], PixelClock[k] / 16);\n\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tReadBandwidth = ReadBandwidth + ReadBandwidthLuma[k] + ReadBandwidthChroma[k];\n\t}\n\n\t*DCFCLKDeepSleep = dml_max(8.0, ReadBandwidth / ReturnBusWidth);\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\t*DCFCLKDeepSleep = dml_max(*DCFCLKDeepSleep, mode_lib->vba.DCFCLKDeepSleepPerPlane[k]);\n\t}\n}\n\nstatic void CalculateUrgentBurstFactor(\n\t\tlong swath_width_luma_ub,\n\t\tlong swath_width_chroma_ub,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble DETBufferSizeY,\n\t\tdouble DETBufferSizeC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tbool *NotEnoughUrgentLatencyHiding)\n{\n\tdouble LinesInDETLuma = 0;\n\tdouble LinesInDETChroma = 0;\n\tunsigned int LinesInCursorBuffer = 0;\n\tdouble CursorBufferSizeInTime = 0;\n\tdouble DETBufferSizeInTimeLuma = 0;\n\tdouble DETBufferSizeInTimeChroma = 0;\n\n\t*NotEnoughUrgentLatencyHiding = 0;\n\n\tif (CursorWidth > 0) {\n\t\tLinesInCursorBuffer = 1 << (unsigned int) dml_floor(dml_log2(CursorBufferSize * 1024.0 / (CursorWidth * CursorBPP / 8.0)), 1.0);\n\t\tif (VRatio > 0) {\n\t\t\tCursorBufferSizeInTime = LinesInCursorBuffer * LineTime / VRatio;\n\t\t\tif (CursorBufferSizeInTime - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorCursor = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorCursor = CursorBufferSizeInTime / (CursorBufferSizeInTime - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorCursor = 1;\n\t\t}\n\t}\n\n\tLinesInDETLuma = DETBufferSizeY / BytePerPixelInDETY / swath_width_luma_ub;\n\tif (VRatio > 0) {\n\t\tDETBufferSizeInTimeLuma = dml_floor(LinesInDETLuma, SwathHeightY) * LineTime / VRatio;\n\t\tif (DETBufferSizeInTimeLuma - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t*UrgentBurstFactorLuma = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorLuma = DETBufferSizeInTimeLuma / (DETBufferSizeInTimeLuma - UrgentLatency);\n\t\t}\n\t} else {\n\t\t*UrgentBurstFactorLuma = 1;\n\t}\n\n\tif (BytePerPixelInDETC > 0) {\n\t\tLinesInDETChroma = DETBufferSizeC / BytePerPixelInDETC / swath_width_chroma_ub;\n\t\tif (VRatio > 0) {\n\t\t\tDETBufferSizeInTimeChroma = dml_floor(LinesInDETChroma, SwathHeightC) * LineTime / VRatio;\n\t\t\tif (DETBufferSizeInTimeChroma - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t\t*UrgentBurstFactorChroma = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorChroma = DETBufferSizeInTimeChroma / (DETBufferSizeInTimeChroma - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorChroma = 1;\n\t\t}\n\t}\n}\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tunsigned int DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int NumberOfCursors[],\n\t\tunsigned int CursorWidth[][2],\n\t\tunsigned int CursorBPP[][2],\n\t\tunsigned int BlockWidth256BytesY[],\n\t\tunsigned int BlockHeight256BytesY[],\n\t\tunsigned int BlockWidth256BytesC[],\n\t\tunsigned int BlockHeight256BytesC[],\n\t\tdouble DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[],\n\t\tdouble CursorRequestDeliveryTime[],\n\t\tdouble CursorRequestDeliveryTimePrefetch[])\n{\n\tdouble req_per_swath_ub = 0;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioChroma[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k] * DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k] / PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioPrefetchC[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = swath_width_chroma_ub[k] * DPPPerPlane[k] / HRatioChroma[k] / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = swath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockWidth256BytesY[k];\n\t\t} else {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockHeight256BytesY[k];\n\t\t}\n\t\tDisplayPipeRequestDeliveryTimeLuma[k] = DisplayPipeLineDeliveryTimeLuma[k] / req_per_swath_ub;\n\t\tDisplayPipeRequestDeliveryTimeLumaPrefetch[k] = DisplayPipeLineDeliveryTimeLumaPrefetch[k] / req_per_swath_ub;\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = 0;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockWidth256BytesC[k];\n\t\t\t} else {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k] / BlockHeight256BytesC[k];\n\t\t\t}\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = DisplayPipeLineDeliveryTimeChroma[k] / req_per_swath_ub;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = DisplayPipeLineDeliveryTimeChromaPrefetch[k] / req_per_swath_ub;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tint cursor_req_per_width = 0;\n\t\tcursor_req_per_width = dml_ceil(CursorWidth[k][0] * CursorBPP[k][0] / 256 / 8, 1);\n\t\tif (NumberOfCursors[k] > 0) {\n\t\t\tif (VRatio[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTime[k] = CursorWidth[k][0] / HRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTime[k] = CursorWidth[k][0] / PSCL_THROUGHPUT[k] / DPPCLK[k] / cursor_req_per_width;\n\t\t\t}\n\t\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = CursorWidth[k][0] / HRatio[k] / PixelClock[k] / cursor_req_per_width;\n\t\t\t} else {\n\t\t\t\tCursorRequestDeliveryTimePrefetch[k] = CursorWidth[k][0] / PSCL_THROUGHPUT[k] / DPPCLK[k] / cursor_req_per_width;\n\t\t\t}\n\t\t} else {\n\t\t\tCursorRequestDeliveryTime[k] = 0;\n\t\t\tCursorRequestDeliveryTimePrefetch[k] = 0;\n\t\t}\n\t}\n}\n\nstatic void CalculateMetaAndPTETimes(\n\t\tint NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tint MetaChunkSize,\n\t\tint MinMetaChunkSizeBytes,\n\t\tint HTotal[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioChroma[],\n\t\tdouble DestinationLinesToRequestRowInVBlank[],\n\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint BytePerPixelY[],\n\t\tint BytePerPixelC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint dpte_row_height[],\n\t\tint dpte_row_height_chroma[],\n\t\tint meta_row_width[],\n\t\tint meta_row_width_chroma[],\n\t\tint meta_row_height[],\n\t\tint meta_row_height_chroma[],\n\t\tint meta_req_width[],\n\t\tint meta_req_width_chroma[],\n\t\tint meta_req_height[],\n\t\tint meta_req_height_chroma[],\n\t\tint dpte_group_bytes[],\n\t\tint PTERequestSizeY[],\n\t\tint PTERequestSizeC[],\n\t\tint PixelPTEReqWidthY[],\n\t\tint PixelPTEReqHeightY[],\n\t\tint PixelPTEReqWidthC[],\n\t\tint PixelPTEReqHeightC[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_C[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerChromaMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerChromaMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble TimePerChromaMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[])\n{\n\tunsigned int meta_chunk_width = 0;\n\tunsigned int min_meta_chunk_width = 0;\n\tunsigned int meta_chunk_per_row_int = 0;\n\tunsigned int meta_row_remainder = 0;\n\tunsigned int meta_chunk_threshold = 0;\n\tunsigned int meta_chunks_per_row_ub = 0;\n\tunsigned int meta_chunk_width_chroma = 0;\n\tunsigned int min_meta_chunk_width_chroma = 0;\n\tunsigned int meta_chunk_per_row_int_chroma = 0;\n\tunsigned int meta_row_remainder_chroma = 0;\n\tunsigned int meta_chunk_threshold_chroma = 0;\n\tunsigned int meta_chunks_per_row_ub_chroma = 0;\n\tunsigned int dpte_group_width_luma = 0;\n\tunsigned int dpte_groups_per_row_luma_ub = 0;\n\tunsigned int dpte_group_width_chroma = 0;\n\tunsigned int dpte_groups_per_row_chroma_ub = 0;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tDST_Y_PER_PTE_ROW_NOM_L[k] = dpte_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = 0;\n\t\t} else {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = dpte_row_height_chroma[k] / VRatioChroma[k];\n\t\t}\n\t\tDST_Y_PER_META_ROW_NOM_L[k] = meta_row_height[k] / VRatio[k];\n\t\tif (BytePerPixelC[k] == 0) {\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = 0;\n\t\t} else {\n\t\t\tDST_Y_PER_META_ROW_NOM_C[k] = meta_row_height_chroma[k] / VRatioChroma[k];\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmeta_chunk_width = MetaChunkSize * 1024 * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmin_meta_chunk_width = MinMetaChunkSizeBytes * 256 / BytePerPixelY[k] / meta_row_height[k];\n\t\t\tmeta_chunk_per_row_int = meta_row_width[k] / meta_chunk_width;\n\t\t\tmeta_row_remainder = meta_row_width[k] % meta_chunk_width;\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_width[k];\n\t\t\t} else {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_height[k];\n\t\t\t}\n\t\t\tif (meta_row_remainder <= meta_chunk_threshold) {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 1;\n\t\t\t} else {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 2;\n\t\t\t}\n\t\t\tTimePerMetaChunkNominal[k] = meta_row_height[k] / VRatio[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t\t} else {\n\t\t\t\tmeta_chunk_width_chroma = MetaChunkSize * 1024 * 256 / BytePerPixelC[k] / meta_row_height_chroma[k];\n\t\t\t\tmin_meta_chunk_width_chroma = MinMetaChunkSizeBytes * 256 / BytePerPixelC[k] / meta_row_height_chroma[k];\n\t\t\t\tmeta_chunk_per_row_int_chroma = (double) meta_row_width_chroma[k] / meta_chunk_width_chroma;\n\t\t\t\tmeta_row_remainder_chroma = meta_row_width_chroma[k] % meta_chunk_width_chroma;\n\t\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma - meta_req_width_chroma[k];\n\t\t\t\t} else {\n\t\t\t\t\tmeta_chunk_threshold_chroma = 2 * min_meta_chunk_width_chroma - meta_req_height_chroma[k];\n\t\t\t\t}\n\t\t\t\tif (meta_row_remainder_chroma <= meta_chunk_threshold_chroma) {\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmeta_chunks_per_row_ub_chroma = meta_chunk_per_row_int_chroma + 2;\n\t\t\t\t}\n\t\t\t\tTimePerChromaMetaChunkNominal[k] = meta_row_height_chroma[k] / VRatioChroma[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t\tTimePerChromaMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub_chroma;\n\t\t\t}\n\t\t} else {\n\t\t\tTimePerMetaChunkNominal[k] = 0;\n\t\t\tTimePerMetaChunkVBlank[k] = 0;\n\t\t\tTimePerMetaChunkFlip[k] = 0;\n\t\t\tTimePerChromaMetaChunkNominal[k] = 0;\n\t\t\tTimePerChromaMetaChunkVBlank[k] = 0;\n\t\t\tTimePerChromaMetaChunkFlip[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true) {\n\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k] * PixelPTEReqWidthY[k];\n\t\t\t} else {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k] * PixelPTEReqHeightY[k];\n\t\t\t}\n\t\t\tdpte_groups_per_row_luma_ub = dml_ceil(1.0 * dpte_row_width_luma_ub[k] / dpte_group_width_luma, 1);\n\t\t\ttime_per_pte_group_nom_luma[k] = DST_Y_PER_PTE_ROW_NOM_L[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_vblank_luma[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_flip_luma[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\tif (BytePerPixelC[k] == 0) {\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t\t} else {\n\t\t\t\tif (SourceScan[k] != dm_vert) {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k] / PTERequestSizeC[k] * PixelPTEReqWidthC[k];\n\t\t\t\t} else {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k] / PTERequestSizeC[k] * PixelPTEReqHeightC[k];\n\t\t\t\t}\n\t\t\t\tdpte_groups_per_row_chroma_ub = dml_ceil(1.0 * dpte_row_width_chroma_ub[k] / dpte_group_width_chroma, 1);\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = DST_Y_PER_PTE_ROW_NOM_C[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = DestinationLinesToRequestRowInVBlank[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = DestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k] / PixelClock[k] / dpte_groups_per_row_chroma_ub;\n\t\t\t}\n\t\t} else {\n\t\t\ttime_per_pte_group_nom_luma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_luma[k] = 0;\n\t\t\ttime_per_pte_group_flip_luma[k] = 0;\n\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t}\n\t}\n}\n\nstatic void CalculateVMGroupAndRequestTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int HTotal[],\n\t\tint BytePerPixelC[],\n\t\tdouble DestinationLinesToRequestVMInVBlank[],\n\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tint dpte_row_width_luma_ub[],\n\t\tint dpte_row_width_chroma_ub[],\n\t\tint vm_group_bytes[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tint meta_pte_bytes_per_frame_ub_l[],\n\t\tint meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble TimePerVMGroupVBlank[],\n\t\tdouble TimePerVMGroupFlip[],\n\t\tdouble TimePerVMRequestVBlank[],\n\t\tdouble TimePerVMRequestFlip[])\n{\n\tint num_group_per_lower_vm_stage = 0;\n\tint num_req_per_lower_vm_stage = 0;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true && (DCCEnable[k] == true || GPUVMMaxPageTableLevels > 1)) {\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k])\n\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1) + dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k])\n\t\t\t\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1);\n\t\t\t\t} else {\n\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k])\n\t\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k])\n\t\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1) + dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k])\n\t\t\t\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k])\n\t\t\t\t\t\t\t/ (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 2 + dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage = 1 + dml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64 + dpde0_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t} else {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t+ dpde0_bytes_per_frame_ub_c[k] / 64 + meta_pte_bytes_per_frame_ub_l[k]\n\t\t\t\t\t\t\t\t\t/ 64 + meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTimePerVMGroupVBlank[k] = DestinationLinesToRequestVMInVBlank[k] * HTotal[k] / PixelClock[k]\n\t\t\t\t\t/ num_group_per_lower_vm_stage;\n\t\t\tTimePerVMGroupFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] * HTotal[k] / PixelClock[k]\n\t\t\t\t\t/ num_group_per_lower_vm_stage;\n\t\t\tTimePerVMRequestVBlank[k] = DestinationLinesToRequestVMInVBlank[k] * HTotal[k] / PixelClock[k]\n\t\t\t\t\t/ num_req_per_lower_vm_stage;\n\t\t\tTimePerVMRequestFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k] * HTotal[k] / PixelClock[k]\n\t\t\t\t\t/ num_req_per_lower_vm_stage;\n\n\t\t\tif (GPUVMMaxPageTableLevels > 2) {\n\t\t\t\tTimePerVMGroupVBlank[k] = TimePerVMGroupVBlank[k] / 2;\n\t\t\t\tTimePerVMGroupFlip[k] = TimePerVMGroupFlip[k] / 2;\n\t\t\t\tTimePerVMRequestVBlank[k] = TimePerVMRequestVBlank[k] / 2;\n\t\t\t\tTimePerVMRequestFlip[k] = TimePerVMRequestFlip[k] / 2;\n\t\t\t}\n\n\t\t} else {\n\t\t\tTimePerVMGroupVBlank[k] = 0;\n\t\t\tTimePerVMGroupFlip[k] = 0;\n\t\t\tTimePerVMRequestVBlank[k] = 0;\n\t\t\tTimePerVMRequestFlip[k] = 0;\n\t\t}\n\t}\n}\n\nstatic void CalculateStutterEfficiency(\n\t\tint NumberOfActivePlanes,\n\t\tlong ROBBufferSizeInKByte,\n\t\tdouble TotalDataReadBandwidth,\n\t\tdouble DCFCLK,\n\t\tdouble ReturnBW,\n\t\tdouble SRExitTime,\n\t\tbool SynchronizedVBlank,\n\t\tint DPPPerPlane[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tint BytePerPixelY[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble SwathWidthY[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tdouble DCCRateLuma[],\n\t\tdouble DCCRateChroma[],\n\t\tint HTotal[],\n\t\tint VTotal[],\n\t\tdouble PixelClock[],\n\t\tdouble VRatio[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tint BlockHeight256BytesY[],\n\t\tint BlockWidth256BytesY[],\n\t\tint BlockHeight256BytesC[],\n\t\tint BlockWidth256BytesC[],\n\t\tint DCCYMaxUncompressedBlock[],\n\t\tint DCCCMaxUncompressedBlock[],\n\t\tint VActive[],\n\t\tbool DCCEnable[],\n\t\tbool WritebackEnable[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tdouble meta_row_bw[],\n\t\tdouble dpte_row_bw[],\n\t\tdouble *StutterEfficiencyNotIncludingVBlank,\n\t\tdouble *StutterEfficiency,\n\t\tdouble *StutterPeriodOut)\n{\n\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };\n\tdouble FrameTimeForMinFullDETBufferingTime = 0;\n\tdouble StutterPeriod = 0;\n\tdouble AverageReadBandwidth = 0;\n\tdouble TotalRowReadBandwidth = 0;\n\tdouble AverageDCCCompressionRate = 0;\n\tdouble PartOfBurstThatFitsInROB = 0;\n\tdouble StutterBurstTime = 0;\n\tint TotalActiveWriteback = 0;\n\tdouble VBlankTime = 0;\n\tdouble SmallestVBlank = 0;\n\tint BytePerPixelYCriticalPlane = 0;\n\tdouble SwathWidthYCriticalPlane = 0;\n\tdouble LinesInDETY[DC__NUM_DPP__MAX] = { 0 };\n\tdouble LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX] = { 0 };\n\tdouble LinesToFinishSwathTransferStutterCriticalPlane = 0;\n\tdouble MaximumEffectiveCompressionLuma = 0;\n\tdouble    MaximumEffectiveCompressionChroma = 0;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tLinesInDETY[k] = DETBufferSizeY[k] / BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath[k] = dml_floor(LinesInDETY[k], SwathHeightY[k]);\n\t\tFullDETBufferingTimeY[k] = LinesInDETYRoundedDownToSwath[k] * (HTotal[k] / PixelClock[k]) / VRatio[k];\n\t}\n\n\tStutterPeriod = FullDETBufferingTimeY[0];\n\tFrameTimeForMinFullDETBufferingTime = VTotal[0] * HTotal[0] / PixelClock[0];\n\tBytePerPixelYCriticalPlane = BytePerPixelY[0];\n\tSwathWidthYCriticalPlane = SwathWidthY[0];\n\tLinesToFinishSwathTransferStutterCriticalPlane = SwathHeightY[0]\n\t\t\t- (LinesInDETY[0] - LinesInDETYRoundedDownToSwath[0]);\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (FullDETBufferingTimeY[k] < StutterPeriod) {\n\t\t\tStutterPeriod = FullDETBufferingTimeY[k];\n\t\t\tFrameTimeForMinFullDETBufferingTime = VTotal[k] * HTotal[k] / PixelClock[k];\n\t\t\tBytePerPixelYCriticalPlane = BytePerPixelY[k];\n\t\t\tSwathWidthYCriticalPlane = SwathWidthY[k];\n\t\t\tLinesToFinishSwathTransferStutterCriticalPlane = SwathHeightY[k]\n\t\t\t\t\t- (LinesInDETY[k] - LinesInDETYRoundedDownToSwath[k]);\n\t\t}\n\t}\n\n\tAverageReadBandwidth = 0;\n\tTotalRowReadBandwidth = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tif ((SourceScan[k] == dm_vert && BlockWidth256BytesY[k] > SwathHeightY[k])\n\t\t\t\t\t|| (SourceScan[k] != dm_vert\n\t\t\t\t\t\t\t&& BlockHeight256BytesY[k] > SwathHeightY[k])\n\t\t\t\t\t|| DCCYMaxUncompressedBlock[k] < 256) {\n\t\t\t\tMaximumEffectiveCompressionLuma = 2;\n\t\t\t} else {\n\t\t\t\tMaximumEffectiveCompressionLuma = 4;\n\t\t\t}\n\t\t\tAverageReadBandwidth = AverageReadBandwidth + ReadBandwidthPlaneLuma[k] / dml_min(DCCRateLuma[k], MaximumEffectiveCompressionLuma);\n\n\t\t\tif (ReadBandwidthPlaneChroma[k] > 0) {\n\t\t\t\tif ((SourceScan[k] == dm_vert && BlockWidth256BytesC[k] > SwathHeightC[k])\n\t\t\t\t\t\t|| (SourceScan[k] != dm_vert && BlockHeight256BytesC[k] > SwathHeightC[k])\n\t\t\t\t\t\t|| DCCCMaxUncompressedBlock[k] < 256) {\n\t\t\t\t\tMaximumEffectiveCompressionChroma = 2;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumEffectiveCompressionChroma = 4;\n\t\t\t\t}\n\t\t\t\tAverageReadBandwidth = AverageReadBandwidth + ReadBandwidthPlaneChroma[k] / dml_min(DCCRateChroma[k], MaximumEffectiveCompressionChroma);\n\t\t\t}\n\t\t} else {\n\t\t\tAverageReadBandwidth = AverageReadBandwidth + ReadBandwidthPlaneLuma[k] + ReadBandwidthPlaneChroma[k];\n\t\t}\n\t\tTotalRowReadBandwidth = TotalRowReadBandwidth + DPPPerPlane[k] * (meta_row_bw[k] + dpte_row_bw[k]);\n\t}\n\n\tAverageDCCCompressionRate = TotalDataReadBandwidth / AverageReadBandwidth;\n\tPartOfBurstThatFitsInROB = dml_min(StutterPeriod * TotalDataReadBandwidth, ROBBufferSizeInKByte * 1024 * AverageDCCCompressionRate);\n\tStutterBurstTime = PartOfBurstThatFitsInROB / AverageDCCCompressionRate / ReturnBW + (StutterPeriod * TotalDataReadBandwidth\n\t\t\t- PartOfBurstThatFitsInROB) / (DCFCLK * 64) + StutterPeriod * TotalRowReadBandwidth / ReturnBW;\n\tStutterBurstTime = dml_max(StutterBurstTime, LinesToFinishSwathTransferStutterCriticalPlane * BytePerPixelYCriticalPlane * SwathWidthYCriticalPlane / ReturnBW);\n\n\tTotalActiveWriteback = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (WritebackEnable[k] == true) {\n\t\t\tTotalActiveWriteback = TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (TotalActiveWriteback == 0) {\n\t\t*StutterEfficiencyNotIncludingVBlank = (1\n\t\t\t\t- (SRExitTime + StutterBurstTime) / StutterPeriod) * 100;\n\t} else {\n\t\t*StutterEfficiencyNotIncludingVBlank = 0;\n\t}\n\n\tif (SynchronizedVBlank == true || NumberOfActivePlanes == 1) {\n\t\tSmallestVBlank = (VTotal[0] - VActive[0]) * HTotal[0] / PixelClock[0];\n\t} else {\n\t\tSmallestVBlank = 0;\n\t}\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (SynchronizedVBlank == true || NumberOfActivePlanes == 1) {\n\t\t\tVBlankTime = (VTotal[k] - VActive[k]) * HTotal[k] / PixelClock[k];\n\t\t} else {\n\t\t\tVBlankTime = 0;\n\t\t}\n\t\tSmallestVBlank = dml_min(SmallestVBlank, VBlankTime);\n\t}\n\n\t*StutterEfficiency =  (*StutterEfficiencyNotIncludingVBlank / 100.0 * (FrameTimeForMinFullDETBufferingTime - SmallestVBlank) + SmallestVBlank) / FrameTimeForMinFullDETBufferingTime * 100;\n\n\tif (StutterPeriodOut)\n\t\t*StutterPeriodOut = StutterPeriod;\n}\n\nstatic void CalculateSwathAndDETConfiguration(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tdouble MaximumSwathWidthLuma[],\n\t\tdouble MaximumSwathWidthChroma[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum dm_swizzle_mode SurfaceTiling[],\n\t\tint ViewportWidth[],\n\t\tint ViewportHeight[],\n\t\tint SurfaceWidthY[],\n\t\tint SurfaceWidthC[],\n\t\tint SurfaceHeightY[],\n\t\tint SurfaceHeightC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BlendingAndTiming[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tdouble BytePerPixDETY[],\n\t\tdouble BytePerPixDETC[],\n\t\tint HActive[],\n\t\tdouble HRatio[],\n\t\tdouble HRatioChroma[],\n\t\tint DPPPerPlane[],\n\t\tint swath_width_luma_ub[],\n\t\tint swath_width_chroma_ub[],\n\t\tdouble SwathWidth[],\n\t\tdouble SwathWidthChroma[],\n\t\tint SwathHeightY[],\n\t\tint SwathHeightC[],\n\t\tunsigned int DETBufferSizeY[],\n\t\tunsigned int DETBufferSizeC[],\n\t\tbool ViewportSizeSupportPerPlane[],\n\t\tbool *ViewportSizeSupport)\n{\n\tint MaximumSwathHeightY[DC__NUM_DPP__MAX] = { 0 };\n\tint MaximumSwathHeightC[DC__NUM_DPP__MAX] = { 0 };\n\tint MinimumSwathHeightY = 0;\n\tint MinimumSwathHeightC = 0;\n\tlong RoundedUpMaxSwathSizeBytesY = 0;\n\tlong RoundedUpMaxSwathSizeBytesC = 0;\n\tlong RoundedUpMinSwathSizeBytesY = 0;\n\tlong RoundedUpMinSwathSizeBytesC = 0;\n\tlong RoundedUpSwathSizeBytesY = 0;\n\tlong RoundedUpSwathSizeBytesC = 0;\n\tdouble SwathWidthSingleDPP[DC__NUM_DPP__MAX] = { 0 };\n\tdouble SwathWidthSingleDPPChroma[DC__NUM_DPP__MAX] = { 0 };\n\tint k;\n\n\tCalculateSwathWidth(\n\t\t\tForceSingleDPP,\n\t\t\tNumberOfActivePlanes,\n\t\t\tSourcePixelFormat,\n\t\t\tSourceScan,\n\t\t\tViewportWidth,\n\t\t\tViewportHeight,\n\t\t\tSurfaceWidthY,\n\t\t\tSurfaceWidthC,\n\t\t\tSurfaceHeightY,\n\t\t\tSurfaceHeightC,\n\t\t\tODMCombineEnabled,\n\t\t\tBytePerPixY,\n\t\t\tBytePerPixC,\n\t\t\tRead256BytesBlockHeightY,\n\t\t\tRead256BytesBlockHeightC,\n\t\t\tRead256BytesBlockWidthY,\n\t\t\tRead256BytesBlockWidthC,\n\t\t\tBlendingAndTiming,\n\t\t\tHActive,\n\t\t\tHRatio,\n\t\t\tDPPPerPlane,\n\t\t\tSwathWidthSingleDPP,\n\t\t\tSwathWidthSingleDPPChroma,\n\t\t\tSwathWidth,\n\t\t\tSwathWidthChroma,\n\t\t\tMaximumSwathHeightY,\n\t\t\tMaximumSwathHeightC,\n\t\t\tswath_width_luma_ub,\n\t\t\tswath_width_chroma_ub);\n\n\t*ViewportSizeSupport = true;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif ((SourcePixelFormat[k] == dm_444_64 || SourcePixelFormat[k] == dm_444_32\n\t\t\t\t|| SourcePixelFormat[k] == dm_444_16\n\t\t\t\t|| SourcePixelFormat[k] == dm_mono_16\n\t\t\t\t|| SourcePixelFormat[k] == dm_mono_8\n\t\t\t\t|| SourcePixelFormat[k] == dm_rgbe)) {\n\t\t\tif (SurfaceTiling[k] == dm_sw_linear\n\t\t\t\t|| (SourcePixelFormat[k] == dm_444_64\n\t\t\t\t\t&& (SurfaceTiling[k] == dm_sw_64kb_s || SurfaceTiling[k] == dm_sw_64kb_s_t || SurfaceTiling[k] == dm_sw_64kb_s_x)\n\t\t\t\t\t&& SourceScan[k] != dm_vert)) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_444_8 && SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t}\n\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t} else {\n\t\t\tif (SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_rgbe_alpha\n\t\t\t\t\t&& SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k];\n\t\t\t} else if (SourcePixelFormat[k] == dm_rgbe_alpha) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t} else if (SourcePixelFormat[k] == dm_420_8 && SourceScan[k] == dm_vert) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k];\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC[k] / 2;\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY[k] / 2;\n\t\t\t}\n\t\t}\n\n\t\tRoundedUpMaxSwathSizeBytesY = swath_width_luma_ub[k] * BytePerPixDETY[k]\n\t\t\t\t* MaximumSwathHeightY[k];\n\t\tRoundedUpMinSwathSizeBytesY = swath_width_luma_ub[k] * BytePerPixDETY[k]\n\t\t\t\t* MinimumSwathHeightY;\n\t\tif (SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesY = dml_ceil((double) RoundedUpMaxSwathSizeBytesY, 256);\n\t\t\tRoundedUpMinSwathSizeBytesY = dml_ceil((double) RoundedUpMinSwathSizeBytesY, 256);\n\t\t}\n\t\tRoundedUpMaxSwathSizeBytesC = swath_width_chroma_ub[k] * BytePerPixDETC[k]\n\t\t\t\t* MaximumSwathHeightC[k];\n\t\tRoundedUpMinSwathSizeBytesC = swath_width_chroma_ub[k] * BytePerPixDETC[k]\n\t\t\t\t* MinimumSwathHeightC;\n\t\tif (SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesC = dml_ceil(RoundedUpMaxSwathSizeBytesC, 256);\n\t\t\tRoundedUpMinSwathSizeBytesC = dml_ceil(RoundedUpMinSwathSizeBytesC, 256);\n\t\t}\n\n\t\tif (RoundedUpMaxSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC\n\t\t\t\t<= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC;\n\t\t} else if (RoundedUpMaxSwathSizeBytesY >= 1.5 * RoundedUpMaxSwathSizeBytesC\n\t\t\t\t&& RoundedUpMinSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC\n\t\t\t\t\t\t<= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MinimumSwathHeightY;\n\t\t\tSwathHeightC[k] = MaximumSwathHeightC[k];\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMinSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMaxSwathSizeBytesC;\n\t\t} else if (RoundedUpMaxSwathSizeBytesY < 1.5 * RoundedUpMaxSwathSizeBytesC\n\t\t\t\t&& RoundedUpMaxSwathSizeBytesY + RoundedUpMinSwathSizeBytesC\n\t\t\t\t\t\t<= DETBufferSizeInKByte * 1024 / 2) {\n\t\t\tSwathHeightY[k] = MaximumSwathHeightY[k];\n\t\t\tSwathHeightC[k] = MinimumSwathHeightC;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMaxSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMinSwathSizeBytesC;\n\t\t} else {\n\t\t\tSwathHeightY[k] = MinimumSwathHeightY;\n\t\t\tSwathHeightC[k] = MinimumSwathHeightC;\n\t\t\tRoundedUpSwathSizeBytesY = RoundedUpMinSwathSizeBytesY;\n\t\t\tRoundedUpSwathSizeBytesC = RoundedUpMinSwathSizeBytesC;\n\t\t}\n\n\t\tif (SwathHeightC[k] == 0) {\n\t\t\tDETBufferSizeY[k] = DETBufferSizeInKByte * 1024;\n\t\t\tDETBufferSizeC[k] = 0;\n\t\t} else if (RoundedUpSwathSizeBytesY <= 1.5 * RoundedUpSwathSizeBytesC) {\n\t\t\tDETBufferSizeY[k] = DETBufferSizeInKByte * 1024 / 2;\n\t\t\tDETBufferSizeC[k] = DETBufferSizeInKByte * 1024 / 2;\n\t\t} else {\n\t\t\tDETBufferSizeY[k] = DETBufferSizeInKByte * 1024 * 2 / 3;\n\t\t\tDETBufferSizeC[k] = DETBufferSizeInKByte * 1024 / 3;\n\t\t}\n\n\t\tif (RoundedUpMinSwathSizeBytesY + RoundedUpMinSwathSizeBytesC\n\t\t\t\t> DETBufferSizeInKByte * 1024 / 2\n\t\t\t\t|| SwathWidth[k] > MaximumSwathWidthLuma[k]\n\t\t\t\t|| (SwathHeightC[k] > 0\n\t\t\t\t\t\t&& SwathWidthChroma[k] > MaximumSwathWidthChroma[k])) {\n\t\t\t*ViewportSizeSupport = false;\n\t\t\tViewportSizeSupportPerPlane[k] = false;\n\t\t} else {\n\t\t\tViewportSizeSupportPerPlane[k] = true;\n\t\t}\n\t}\n}\n\nstatic void CalculateSwathWidth(\n\t\tbool ForceSingleDPP,\n\t\tint NumberOfActivePlanes,\n\t\tenum source_format_class SourcePixelFormat[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int ViewportWidth[],\n\t\tunsigned int ViewportHeight[],\n\t\tunsigned int SurfaceWidthY[],\n\t\tunsigned int SurfaceWidthC[],\n\t\tunsigned int SurfaceHeightY[],\n\t\tunsigned int SurfaceHeightC[],\n\t\tenum odm_combine_mode ODMCombineEnabled[],\n\t\tint BytePerPixY[],\n\t\tint BytePerPixC[],\n\t\tint Read256BytesBlockHeightY[],\n\t\tint Read256BytesBlockHeightC[],\n\t\tint Read256BytesBlockWidthY[],\n\t\tint Read256BytesBlockWidthC[],\n\t\tint BlendingAndTiming[],\n\t\tunsigned int HActive[],\n\t\tdouble HRatio[],\n\t\tint DPPPerPlane[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tdouble SwathWidthSingleDPPC[],\n\t\tdouble SwathWidthY[],\n\t\tdouble SwathWidthC[],\n\t\tint MaximumSwathHeightY[],\n\t\tint MaximumSwathHeightC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[])\n{\n\tunsigned int k, j;\n\tlong surface_width_ub_l;\n\tlong surface_height_ub_l;\n\tlong surface_width_ub_c;\n\tlong surface_height_ub_c;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tenum odm_combine_mode MainPlaneODMCombine = 0;\n\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\tSwathWidthSingleDPPY[k] = ViewportWidth[k];\n\t\t} else {\n\t\t\tSwathWidthSingleDPPY[k] = ViewportHeight[k];\n\t\t}\n\n\t\tMainPlaneODMCombine = ODMCombineEnabled[k];\n\t\tfor (j = 0; j < NumberOfActivePlanes; ++j) {\n\t\t\tif (BlendingAndTiming[k] == j) {\n\t\t\t\tMainPlaneODMCombine = ODMCombineEnabled[j];\n\t\t\t}\n\t\t}\n\n\t\tif (MainPlaneODMCombine == dm_odm_combine_mode_4to1) {\n\t\t\tSwathWidthY[k] = dml_min(SwathWidthSingleDPPY[k], dml_round(HActive[k] / 4.0 * HRatio[k]));\n\t\t} else if (MainPlaneODMCombine == dm_odm_combine_mode_2to1) {\n\t\t\tSwathWidthY[k] = dml_min(SwathWidthSingleDPPY[k], dml_round(HActive[k] / 2.0 * HRatio[k]));\n\t\t} else if (DPPPerPlane[k] == 2) {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k] / 2;\n\t\t} else {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k];\n\t\t}\n\n\t\tif (SourcePixelFormat[k] == dm_420_8 || SourcePixelFormat[k] == dm_420_10 || SourcePixelFormat[k] == dm_420_12) {\n\t\t\tSwathWidthC[k] = SwathWidthY[k] / 2;\n\t\t\tSwathWidthSingleDPPC[k] = SwathWidthSingleDPPY[k] / 2;\n\t\t} else {\n\t\t\tSwathWidthC[k] = SwathWidthY[k];\n\t\t\tSwathWidthSingleDPPC[k] = SwathWidthSingleDPPY[k];\n\t\t}\n\n\t\tif (ForceSingleDPP == true) {\n\t\t\tSwathWidthY[k] = SwathWidthSingleDPPY[k];\n\t\t\tSwathWidthC[k] = SwathWidthSingleDPPC[k];\n\t\t}\n\n\t\tsurface_width_ub_l  = dml_ceil(SurfaceWidthY[k], Read256BytesBlockWidthY[k]);\n\t\tsurface_height_ub_l = dml_ceil(SurfaceHeightY[k], Read256BytesBlockHeightY[k]);\n\n\t\tif (SourceScan[k] != dm_vert) {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockHeightY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockHeightC[k];\n\t\t\tswath_width_luma_ub[k] = dml_min(surface_width_ub_l, (long) dml_ceil(SwathWidthY[k] - 1,\n\t\t\t\t\tRead256BytesBlockWidthY[k]) + Read256BytesBlockWidthY[k]);\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tsurface_width_ub_c  = dml_ceil(SurfaceWidthC[k], Read256BytesBlockWidthC[k]);\n\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_width_ub_c, (long) dml_ceil(SwathWidthC[k] - 1,\n\t\t\t\t\t\tRead256BytesBlockWidthC[k]) + Read256BytesBlockWidthC[k]);\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tMaximumSwathHeightY[k] = Read256BytesBlockWidthY[k];\n\t\t\tMaximumSwathHeightC[k] = Read256BytesBlockWidthC[k];\n\t\t\tswath_width_luma_ub[k] = dml_min(surface_height_ub_l, (long) dml_ceil(SwathWidthY[k] - 1,\n\t\t\t\t\tRead256BytesBlockHeightY[k]) + Read256BytesBlockHeightY[k]);\n\t\t\tif (BytePerPixC[k] > 0) {\n\t\t\t\tsurface_height_ub_c = dml_ceil(SurfaceHeightC[k], Read256BytesBlockHeightC[k]);\n\t\t\t\tswath_width_chroma_ub[k] = dml_min(surface_height_ub_c, (long) dml_ceil(SwathWidthC[k] - 1,\n\t\t\t\t\t\tRead256BytesBlockHeightC[k]) + Read256BytesBlockHeightC[k]);\n\t\t\t} else {\n\t\t\t\tswath_width_chroma_ub[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic double CalculateExtraLatency(\n\t\tlong RoundTripPingLatencyCycles,\n\t\tlong ReorderingBytes,\n\t\tdouble DCFCLK,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels)\n{\n\tdouble ExtraLatencyBytes = 0;\n\tExtraLatencyBytes = CalculateExtraLatencyBytes(\n\t\t\t\t\tReorderingBytes,\n\t\t\t\t\tTotalNumberOfActiveDPP,\n\t\t\t\t\tPixelChunkSizeInKByte,\n\t\t\t\t\tTotalNumberOfDCCActiveDPP,\n\t\t\t\t\tMetaChunkSize,\n\t\t\t\t\tGPUVMEnable,\n\t\t\t\t\tHostVMEnable,\n\t\t\t\t\tNumberOfActivePlanes,\n\t\t\t\t\tNumberOfDPP,\n\t\t\t\t\tdpte_group_bytes,\n\t\t\t\t\tPercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\tPercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\tHostVMMinPageSize,\n\t\t\t\t\tHostVMMaxNonCachedPageTableLevels);\n\n\treturn (RoundTripPingLatencyCycles + 32) / DCFCLK + ExtraLatencyBytes / ReturnBW;\n}\n\nstatic double CalculateExtraLatencyBytes(\n\t\tlong ReorderingBytes,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble HostVMMinPageSize,\n\t\tint HostVMMaxNonCachedPageTableLevels)\n{\n\tdouble ret = 0;\n\tdouble HostVMInefficiencyFactor = 0;\n\tint HostVMDynamicLevels = 0;\n\tunsigned int k;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tHostVMInefficiencyFactor = PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tif (HostVMMinPageSize < 2048) {\n\t\t\tHostVMDynamicLevels = HostVMMaxNonCachedPageTableLevels;\n\t\t} else if (HostVMMinPageSize >= 2048 && HostVMMinPageSize < 1048576) {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 1);\n\t\t} else {\n\t\t\tHostVMDynamicLevels = dml_max(0, (int) HostVMMaxNonCachedPageTableLevels - 2);\n\t\t}\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tret = ReorderingBytes + (TotalNumberOfActiveDPP * PixelChunkSizeInKByte + TotalNumberOfDCCActiveDPP * MetaChunkSize) * 1024.0;\n\n\tif (GPUVMEnable == true) {\n\t\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\t\tret = ret + NumberOfDPP[k] * dpte_group_bytes[k] * (1 + 8 * HostVMDynamicLevels) * HostVMInefficiencyFactor;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstatic double CalculateUrgentLatency(\n\t\tdouble UrgentLatencyPixelDataOnly,\n\t\tdouble UrgentLatencyPixelMixedWithVMData,\n\t\tdouble UrgentLatencyVMDataOnly,\n\t\tbool DoUrgentLatencyAdjustment,\n\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,\n\t\tdouble UrgentLatencyAdjustmentFabricClockReference,\n\t\tdouble FabricClock)\n{\n\tdouble ret;\n\n\tret = dml_max3(UrgentLatencyPixelDataOnly, UrgentLatencyPixelMixedWithVMData, UrgentLatencyVMDataOnly);\n\tif (DoUrgentLatencyAdjustment == true) {\n\t\tret = ret + UrgentLatencyAdjustmentFabricClockComponent * (UrgentLatencyAdjustmentFabricClockReference / FabricClock - 1);\n\t}\n\treturn ret;\n}\n\nstatic noinline_for_stack void UseMinimumDCFCLK(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tstruct vba_vars_st *v,\n\t\tint MaxPrefetchMode,\n\t\tint ReorderingBytes)\n{\n\tdouble   NormalEfficiency = 0;\n\tdouble   PTEEfficiency = 0;\n\tdouble   TotalMaxPrefetchFlipDPTERowBandwidth[DC__VOLTAGE_STATES][2] = { { 0 } };\n\tunsigned int i, j, k;\n\n\tNormalEfficiency =  (v->HostVMEnable == true ? v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData\n\t\t\t: v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly) / 100.0;\n\tPTEEfficiency =  (v->HostVMEnable == true ? v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly\n\t\t\t/ v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData : 1.0);\n\tfor (i = 0; i < mode_lib->soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tdouble PixelDCFCLKCyclesRequiredInPrefetch[DC__NUM_DPP__MAX] = { 0 };\n\t\t\tdouble PrefetchPixelLinesTime[DC__NUM_DPP__MAX] = { 0 };\n\t\t\tdouble DCFCLKRequiredForPeakBandwidthPerPlane[DC__NUM_DPP__MAX] = { 0 };\n\t\t\tdouble DynamicMetadataVMExtraLatency[DC__NUM_DPP__MAX] = { 0 };\n\t\t\tdouble MinimumTWait = 0;\n\t\t\tdouble NonDPTEBandwidth = 0;\n\t\t\tdouble DPTEBandwidth = 0;\n\t\t\tdouble DCFCLKRequiredForAverageBandwidth = 0;\n\t\t\tdouble ExtraLatencyBytes = 0;\n\t\t\tdouble ExtraLatencyCycles = 0;\n\t\t\tdouble DCFCLKRequiredForPeakBandwidth = 0;\n\t\t\tint NoOfDPPState[DC__NUM_DPP__MAX] = { 0 };\n\t\t\tdouble MinimumTvmPlus2Tr0 = 0;\n\n\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = 0;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] = TotalMaxPrefetchFlipDPTERowBandwidth[i][j]\n\t\t\t\t\t+ v->NoOfDPP[i][j][k] * v->DPTEBytesPerRow[i][j][k] / (15.75 * v->HTotal[k] / v->PixelClock[k]);\n\t\t\t}\n\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; ++k) {\n\t\t\t\tNoOfDPPState[k] = v->NoOfDPP[i][j][k];\n\t\t\t}\n\n\t\t\tMinimumTWait = CalculateTWait(MaxPrefetchMode, v->FinalDRAMClockChangeLatency, v->UrgLatency[i], v->SREnterPlusExitTime);\n\t\t\tNonDPTEBandwidth = v->TotalVActivePixelBandwidth[i][j] + v->TotalVActiveCursorBandwidth[i][j] + v->TotalMetaRowBandwidth[i][j];\n\t\t\tDPTEBandwidth =  (v->HostVMEnable == true || v->ImmediateFlipRequirement[0] == dm_immediate_flip_required) ?\n\t\t\t\t\tTotalMaxPrefetchFlipDPTERowBandwidth[i][j] : v->TotalDPTERowBandwidth[i][j];\n\t\t\tDCFCLKRequiredForAverageBandwidth = dml_max3(v->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\t(NonDPTEBandwidth + v->TotalDPTERowBandwidth[i][j]) / v->ReturnBusWidth / (v->MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation / 100),\n\t\t\t\t\t(NonDPTEBandwidth + DPTEBandwidth / PTEEfficiency) / NormalEfficiency / v->ReturnBusWidth);\n\n\t\t\tExtraLatencyBytes = CalculateExtraLatencyBytes(ReorderingBytes, v->TotalNumberOfActiveDPP[i][j], v->PixelChunkSizeInKByte, v->TotalNumberOfDCCActiveDPP[i][j],\n\t\t\t\t\tv->MetaChunkSize, v->GPUVMEnable, v->HostVMEnable, v->NumberOfActivePlanes, NoOfDPPState, v->dpte_group_bytes,\n\t\t\t\t\tv->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData, v->PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\tv->HostVMMinPageSize, v->HostVMMaxNonCachedPageTableLevels);\n\t\t\tExtraLatencyCycles = v->RoundTripPingLatencyCycles + 32 + ExtraLatencyBytes / NormalEfficiency / v->ReturnBusWidth;\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tdouble DCFCLKCyclesRequiredInPrefetch = { 0 };\n\t\t\t\tdouble ExpectedPrefetchBWAcceleration = { 0 };\n\t\t\t\tdouble PrefetchTime = { 0 };\n\n\t\t\t\tPixelDCFCLKCyclesRequiredInPrefetch[k] = (v->PrefetchLinesY[i][j][k] * v->swath_width_luma_ub_all_states[i][j][k] * v->BytePerPixelY[k]\n\t\t\t\t\t+ v->PrefetchLinesC[i][j][k] * v->swath_width_chroma_ub_all_states[i][j][k] * v->BytePerPixelC[k]) / NormalEfficiency / v->ReturnBusWidth;\n\t\t\t\tDCFCLKCyclesRequiredInPrefetch = 2 * ExtraLatencyCycles / NoOfDPPState[k] + v->PDEAndMetaPTEBytesPerFrame[i][j][k] / PTEEfficiency\n\t\t\t\t\t/ NormalEfficiency / v->ReturnBusWidth *  (v->GPUVMMaxPageTableLevels > 2 ? 1 : 0) + 2 * v->DPTEBytesPerRow[i][j][k] / PTEEfficiency\n\t\t\t\t\t/ NormalEfficiency / v->ReturnBusWidth + 2 * v->MetaRowBytes[i][j][k] / NormalEfficiency / v->ReturnBusWidth + PixelDCFCLKCyclesRequiredInPrefetch[k];\n\t\t\t\tPrefetchPixelLinesTime[k] = dml_max(v->PrefetchLinesY[i][j][k], v->PrefetchLinesC[i][j][k]) * v->HTotal[k] / v->PixelClock[k];\n\t\t\t\tExpectedPrefetchBWAcceleration = (v->VActivePixelBandwidth[i][j][k] + v->VActiveCursorBandwidth[i][j][k]) / (v->ReadBandwidthLuma[k] + v->ReadBandwidthChroma[k]);\n\t\t\t\tDynamicMetadataVMExtraLatency[k] = (v->GPUVMEnable == true && v->DynamicMetadataEnable[k] == true && v->DynamicMetadataVMEnabled == true) ?\n\t\t\t\t\t\tv->UrgLatency[i] * v->GPUVMMaxPageTableLevels *  (v->HostVMEnable == true ? v->HostVMMaxNonCachedPageTableLevels + 1 : 1) : 0;\n\t\t\t\tPrefetchTime = (v->MaximumVStartup[i][j][k] - 1) * v->HTotal[k] / v->PixelClock[k] - MinimumTWait - v->UrgLatency[i] * ((v->GPUVMMaxPageTableLevels <= 2 ? v->GPUVMMaxPageTableLevels\n\t\t\t\t\t\t: v->GPUVMMaxPageTableLevels - 2) * (v->HostVMEnable == true ? v->HostVMMaxNonCachedPageTableLevels + 1 : 1) - 1) - DynamicMetadataVMExtraLatency[k];\n\n\t\t\t\tif (PrefetchTime > 0) {\n\t\t\t\t\tdouble ExpectedVRatioPrefetch = { 0 };\n\t\t\t\t\tExpectedVRatioPrefetch = PrefetchPixelLinesTime[k] / (PrefetchTime * PixelDCFCLKCyclesRequiredInPrefetch[k] / DCFCLKCyclesRequiredInPrefetch);\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = NoOfDPPState[k] * PixelDCFCLKCyclesRequiredInPrefetch[k] / PrefetchPixelLinesTime[k]\n\t\t\t\t\t\t* dml_max(1.0, ExpectedVRatioPrefetch) * dml_max(1.0, ExpectedVRatioPrefetch / 4) * ExpectedPrefetchBWAcceleration;\n\t\t\t\t\tif (v->HostVMEnable == true || v->ImmediateFlipRequirement[0] == dm_immediate_flip_required) {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = DCFCLKRequiredForPeakBandwidthPerPlane[k]\n\t\t\t\t\t\t\t+ NoOfDPPState[k] * DPTEBandwidth / PTEEfficiency / NormalEfficiency / v->ReturnBusWidth;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = v->DCFCLKPerState[i];\n\t\t\t\t}\n\t\t\t\tif (v->DynamicMetadataEnable[k] == true) {\n\t\t\t\t\tdouble TsetupPipe = { 0 };\n\t\t\t\t\tdouble TdmbfPipe = { 0 };\n\t\t\t\t\tdouble TdmsksPipe = { 0 };\n\t\t\t\t\tdouble TdmecPipe = { 0 };\n\t\t\t\t\tdouble AllowedTimeForUrgentExtraLatency = { 0 };\n\n\t\t\t\t\tCalculateDynamicMetadataParameters(\n\t\t\t\t\t\t\tv->MaxInterDCNTileRepeaters,\n\t\t\t\t\t\t\tv->RequiredDPPCLK[i][j][k],\n\t\t\t\t\t\t\tv->RequiredDISPCLK[i][j],\n\t\t\t\t\t\t\tv->ProjectedDCFCLKDeepSleep[i][j],\n\t\t\t\t\t\t\tv->PixelClock[k],\n\t\t\t\t\t\t\tv->HTotal[k],\n\t\t\t\t\t\t\tv->VTotal[k] - v->VActive[k],\n\t\t\t\t\t\t\tv->DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\t\t\tv->DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\t\t\tv->Interlace[k],\n\t\t\t\t\t\t\tv->ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\t&TsetupPipe,\n\t\t\t\t\t\t\t&TdmbfPipe,\n\t\t\t\t\t\t\t&TdmecPipe,\n\t\t\t\t\t\t\t&TdmsksPipe);\n\t\t\t\t\tAllowedTimeForUrgentExtraLatency = v->MaximumVStartup[i][j][k] * v->HTotal[k] / v->PixelClock[k] - MinimumTWait - TsetupPipe\n\t\t\t\t\t\t\t- TdmbfPipe - TdmecPipe - TdmsksPipe - DynamicMetadataVMExtraLatency[k];\n\t\t\t\t\tif (AllowedTimeForUrgentExtraLatency > 0) {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = dml_max(DCFCLKRequiredForPeakBandwidthPerPlane[k],\n\t\t\t\t\t\t\t\tExtraLatencyCycles / AllowedTimeForUrgentExtraLatency);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDCFCLKRequiredForPeakBandwidthPerPlane[k] = v->DCFCLKPerState[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDCFCLKRequiredForPeakBandwidth = 0;\n\t\t\tfor (k = 0; k <= v->NumberOfActivePlanes - 1; ++k) {\n\t\t\t\tDCFCLKRequiredForPeakBandwidth = DCFCLKRequiredForPeakBandwidth + DCFCLKRequiredForPeakBandwidthPerPlane[k];\n\t\t\t}\n\t\t\tMinimumTvmPlus2Tr0 = v->UrgLatency[i] * (v->GPUVMEnable == true ? (v->HostVMEnable == true ?\n\t\t\t\t\t(v->GPUVMMaxPageTableLevels + 2) * (v->HostVMMaxNonCachedPageTableLevels + 1) - 1 : v->GPUVMMaxPageTableLevels + 1) : 0);\n\t\t\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {\n\t\t\t\tdouble MaximumTvmPlus2Tr0PlusTsw = { 0 };\n\t\t\t\tMaximumTvmPlus2Tr0PlusTsw = (v->MaximumVStartup[i][j][k] - 2) * v->HTotal[k] / v->PixelClock[k] - MinimumTWait - DynamicMetadataVMExtraLatency[k];\n\t\t\t\tif (MaximumTvmPlus2Tr0PlusTsw <= MinimumTvmPlus2Tr0 + PrefetchPixelLinesTime[k] / 4) {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = v->DCFCLKPerState[i];\n\t\t\t\t} else {\n\t\t\t\t\tDCFCLKRequiredForPeakBandwidth = dml_max3(DCFCLKRequiredForPeakBandwidth, 2 * ExtraLatencyCycles\n\t\t\t\t\t\t\t/ (MaximumTvmPlus2Tr0PlusTsw - MinimumTvmPlus2Tr0 - PrefetchPixelLinesTime[k] / 4),\n\t\t\t\t\t\t(2 * ExtraLatencyCycles + PixelDCFCLKCyclesRequiredInPrefetch[k]) / (MaximumTvmPlus2Tr0PlusTsw - MinimumTvmPlus2Tr0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tv->DCFCLKState[i][j] = dml_min(v->DCFCLKPerState[i], 1.05 * (1 + mode_lib->vba.PercentMarginOverMinimumRequiredDCFCLK / 100)\n\t\t\t\t\t* dml_max(DCFCLKRequiredForAverageBandwidth, DCFCLKRequiredForPeakBandwidth));\n\t\t}\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}