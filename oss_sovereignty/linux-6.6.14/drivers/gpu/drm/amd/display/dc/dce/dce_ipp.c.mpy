{
  "module_name": "dce_ipp.c",
  "hash_id": "f58da2aa9478c742b687ee35c104650525d480e18e2af341b75d6816c35c95da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c",
  "human_readable_source": " \n\n#include \"dce_ipp.h\"\n#include \"reg_helper.h\"\n#include \"dm_services.h\"\n\n#define REG(reg) \\\n\t(ipp_dce->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tipp_dce->ipp_shift->field_name, ipp_dce->ipp_mask->field_name\n\n#define CTX \\\n\tipp_dce->base.ctx\n\n\nstatic void dce_ipp_cursor_set_position(\n\tstruct input_pixel_processor *ipp,\n\tconst struct dc_cursor_position *position,\n\tconst struct dc_cursor_mi_param *param)\n{\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\n\t \n\tREG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, true);\n\n\t \n\t \n\tREG_UPDATE(CUR_CONTROL, CURSOR_EN, position->enable);\n\n\tREG_SET_2(CUR_POSITION, 0,\n\t\tCURSOR_X_POSITION, position->x,\n\t\tCURSOR_Y_POSITION, position->y);\n\n\tREG_SET_2(CUR_HOT_SPOT, 0,\n\t\tCURSOR_HOT_SPOT_X, position->x_hotspot,\n\t\tCURSOR_HOT_SPOT_Y, position->y_hotspot);\n\n\t \n\tREG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, false);\n}\n\nstatic void dce_ipp_cursor_set_attributes(\n\tstruct input_pixel_processor *ipp,\n\tconst struct dc_cursor_attributes *attributes)\n{\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\tint mode;\n\n\t \n\tREG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, true);\n\n\t \n\tswitch (attributes->color_format) {\n\tcase CURSOR_MODE_MONO:\n\t\tmode = 0;\n\t\tbreak;\n\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\tmode = 1;\n\t\tbreak;\n\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\tmode = 2;\n\t\tbreak;\n\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\tmode = 3;\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();  \n\t\tmode = 0;\n\t}\n\n\tREG_UPDATE_3(CUR_CONTROL,\n\t\tCURSOR_MODE, mode,\n\t\tCURSOR_2X_MAGNIFY, attributes->attribute_flags.bits.ENABLE_MAGNIFICATION,\n\t\tCUR_INV_TRANS_CLAMP, attributes->attribute_flags.bits.INVERSE_TRANSPARENT_CLAMPING);\n\n\tif (attributes->color_format == CURSOR_MODE_MONO) {\n\t\tREG_SET_3(CUR_COLOR1, 0,\n\t\t\tCUR_COLOR1_BLUE, 0,\n\t\t\tCUR_COLOR1_GREEN, 0,\n\t\t\tCUR_COLOR1_RED, 0);\n\n\t\tREG_SET_3(CUR_COLOR2, 0,\n\t\t\tCUR_COLOR2_BLUE, 0xff,\n\t\t\tCUR_COLOR2_GREEN, 0xff,\n\t\t\tCUR_COLOR2_RED, 0xff);\n\t}\n\n\t \n\tREG_SET_2(CUR_SIZE, 0,\n\t\tCURSOR_WIDTH, attributes->width-1,\n\t\tCURSOR_HEIGHT, attributes->height-1);\n\n\t \n\t \n\tREG_SET(CUR_SURFACE_ADDRESS_HIGH, 0,\n\t\tCURSOR_SURFACE_ADDRESS_HIGH, attributes->address.high_part);\n\n\tREG_SET(CUR_SURFACE_ADDRESS, 0,\n\t\tCURSOR_SURFACE_ADDRESS, attributes->address.low_part);\n\n\t \n\tREG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, false);\n}\n\n\nstatic void dce_ipp_program_prescale(struct input_pixel_processor *ipp,\n\t\t\t\t     struct ipp_prescale_params *params)\n{\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\n\t \n\tREG_UPDATE(PRESCALE_GRPH_CONTROL,\n\t\t   GRPH_PRESCALE_BYPASS, 1);\n\n\tREG_SET_2(PRESCALE_VALUES_GRPH_R, 0,\n\t\t  GRPH_PRESCALE_SCALE_R, params->scale,\n\t\t  GRPH_PRESCALE_BIAS_R, params->bias);\n\n\tREG_SET_2(PRESCALE_VALUES_GRPH_G, 0,\n\t\t  GRPH_PRESCALE_SCALE_G, params->scale,\n\t\t  GRPH_PRESCALE_BIAS_G, params->bias);\n\n\tREG_SET_2(PRESCALE_VALUES_GRPH_B, 0,\n\t\t  GRPH_PRESCALE_SCALE_B, params->scale,\n\t\t  GRPH_PRESCALE_BIAS_B, params->bias);\n\n\tif (params->mode != IPP_PRESCALE_MODE_BYPASS) {\n\t\tREG_UPDATE(PRESCALE_GRPH_CONTROL,\n\t\t\t   GRPH_PRESCALE_BYPASS, 0);\n\n\t\t \n\t\tREG_UPDATE(INPUT_GAMMA_CONTROL,\n\t\t\t   GRPH_INPUT_GAMMA_MODE, 1);\n\t}\n}\n\nstatic void dce_ipp_program_input_lut(\n\tstruct input_pixel_processor *ipp,\n\tconst struct dc_gamma *gamma)\n{\n\tint i;\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_SET(DCFE_MEM_PWR_CTRL, 0, DCP_LUT_MEM_PWR_DIS, 1);\n\n\t \n\tREG_SET(DC_LUT_WRITE_EN_MASK, 0, DC_LUT_WRITE_EN_MASK, 0x7);\n\n\t \n\tREG_UPDATE(DC_LUT_RW_MODE, DC_LUT_RW_MODE, 0);\n\n\t \n\tREG_SET_3(DC_LUT_CONTROL, 0,\n\t\tDC_LUT_DATA_R_FORMAT, 3,\n\t\tDC_LUT_DATA_G_FORMAT, 3,\n\t\tDC_LUT_DATA_B_FORMAT, 3);\n\n\t \n\tREG_SET(DC_LUT_RW_INDEX, 0,\n\t\tDC_LUT_RW_INDEX, 0);\n\n\tfor (i = 0; i < gamma->num_entries; i++) {\n\t\tREG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.red[i]));\n\t\tREG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.green[i]));\n\t\tREG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.blue[i]));\n\t}\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_SET(DCFE_MEM_PWR_CTRL, 0, DCP_LUT_MEM_PWR_DIS, 0);\n\n\t \n\tREG_UPDATE(PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_BYPASS, 1);\n\tREG_UPDATE(INPUT_GAMMA_CONTROL, GRPH_INPUT_GAMMA_MODE, 0);\n}\n\nstatic void dce_ipp_set_degamma(\n\tstruct input_pixel_processor *ipp,\n\tenum ipp_degamma_mode mode)\n{\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\tuint32_t degamma_type = (mode == IPP_DEGAMMA_MODE_HW_sRGB) ? 1 : 0;\n\n\tASSERT(mode == IPP_DEGAMMA_MODE_BYPASS || mode == IPP_DEGAMMA_MODE_HW_sRGB);\n\n\tREG_SET_3(DEGAMMA_CONTROL, 0,\n\t\t  GRPH_DEGAMMA_MODE, degamma_type,\n\t\t  CURSOR_DEGAMMA_MODE, degamma_type,\n\t\t  CURSOR2_DEGAMMA_MODE, degamma_type);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_ipp_set_degamma(\n\tstruct input_pixel_processor *ipp,\n\tenum ipp_degamma_mode mode)\n{\n\tstruct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);\n\tuint32_t degamma_type = (mode == IPP_DEGAMMA_MODE_HW_sRGB) ? 1 : 0;\n\n\tASSERT(mode == IPP_DEGAMMA_MODE_BYPASS || mode == IPP_DEGAMMA_MODE_HW_sRGB);\n\t \n\tREG_SET_2(DEGAMMA_CONTROL, 0,\n\t\t  GRPH_DEGAMMA_MODE, degamma_type,\n\t\t  CURSOR_DEGAMMA_MODE, degamma_type);\n}\n#endif\n\nstatic const struct ipp_funcs dce_ipp_funcs = {\n\t.ipp_cursor_set_attributes = dce_ipp_cursor_set_attributes,\n\t.ipp_cursor_set_position = dce_ipp_cursor_set_position,\n\t.ipp_program_prescale = dce_ipp_program_prescale,\n\t.ipp_program_input_lut = dce_ipp_program_input_lut,\n\t.ipp_set_degamma = dce_ipp_set_degamma\n};\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic const struct ipp_funcs dce60_ipp_funcs = {\n\t.ipp_cursor_set_attributes = dce_ipp_cursor_set_attributes,\n\t.ipp_cursor_set_position = dce_ipp_cursor_set_position,\n\t.ipp_program_prescale = dce_ipp_program_prescale,\n\t.ipp_program_input_lut = dce_ipp_program_input_lut,\n\t.ipp_set_degamma = dce60_ipp_set_degamma\n};\n#endif\n\n\n \n \n \n\nvoid dce_ipp_construct(\n\tstruct dce_ipp *ipp_dce,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_ipp_registers *regs,\n\tconst struct dce_ipp_shift *ipp_shift,\n\tconst struct dce_ipp_mask *ipp_mask)\n{\n\tipp_dce->base.ctx = ctx;\n\tipp_dce->base.inst = inst;\n\tipp_dce->base.funcs = &dce_ipp_funcs;\n\n\tipp_dce->regs = regs;\n\tipp_dce->ipp_shift = ipp_shift;\n\tipp_dce->ipp_mask = ipp_mask;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nvoid dce60_ipp_construct(\n\tstruct dce_ipp *ipp_dce,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_ipp_registers *regs,\n\tconst struct dce_ipp_shift *ipp_shift,\n\tconst struct dce_ipp_mask *ipp_mask)\n{\n\tipp_dce->base.ctx = ctx;\n\tipp_dce->base.inst = inst;\n\tipp_dce->base.funcs = &dce60_ipp_funcs;\n\n\tipp_dce->regs = regs;\n\tipp_dce->ipp_shift = ipp_shift;\n\tipp_dce->ipp_mask = ipp_mask;\n}\n#endif\n\nvoid dce_ipp_destroy(struct input_pixel_processor **ipp)\n{\n\tkfree(TO_DCE_IPP(*ipp));\n\t*ipp = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}