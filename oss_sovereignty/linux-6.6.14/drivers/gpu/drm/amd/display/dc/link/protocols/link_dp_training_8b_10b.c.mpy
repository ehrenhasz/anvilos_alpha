{
  "module_name": "link_dp_training_8b_10b.c",
  "hash_id": "313b0b94c9b449dc8e6b169dccde9d1f92a0bcad007d23f7ea40056be001cae9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_8b_10b.c",
  "human_readable_source": " \n\n \n#include \"link_dp_training_8b_10b.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_phy.h\"\n#include \"link_dp_capability.h\"\n\n#define DC_LOGGER \\\n\tlink->ctx->logger\n\nstatic int32_t get_cr_training_aux_rd_interval(struct dc_link *link,\n\t\tconst struct dc_link_settings *link_settings)\n{\n\tunion training_aux_rd_interval training_rd_interval;\n\tuint32_t wait_in_micro_secs = 100;\n\n\tmemset(&training_rd_interval, 0, sizeof(training_rd_interval));\n\tif (link_dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING &&\n\t\t\tlink->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {\n\t\tcore_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_TRAINING_AUX_RD_INTERVAL,\n\t\t\t\t(uint8_t *)&training_rd_interval,\n\t\t\t\tsizeof(training_rd_interval));\n\t\tif (training_rd_interval.bits.TRAINIG_AUX_RD_INTERVAL)\n\t\t\twait_in_micro_secs = training_rd_interval.bits.TRAINIG_AUX_RD_INTERVAL * 4000;\n\t}\n\treturn wait_in_micro_secs;\n}\n\nstatic uint32_t get_eq_training_aux_rd_interval(\n\tstruct dc_link *link,\n\tconst struct dc_link_settings *link_settings)\n{\n\tunion training_aux_rd_interval training_rd_interval;\n\n\tmemset(&training_rd_interval, 0, sizeof(training_rd_interval));\n\tif (link_dp_get_encoding_format(link_settings) == DP_128b_132b_ENCODING) {\n\t\tcore_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_128B132B_TRAINING_AUX_RD_INTERVAL,\n\t\t\t\t(uint8_t *)&training_rd_interval,\n\t\t\t\tsizeof(training_rd_interval));\n\t} else if (link_dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING &&\n\t\t\tlink->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {\n\t\tcore_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_TRAINING_AUX_RD_INTERVAL,\n\t\t\t\t(uint8_t *)&training_rd_interval,\n\t\t\t\tsizeof(training_rd_interval));\n\t}\n\n\tswitch (training_rd_interval.bits.TRAINIG_AUX_RD_INTERVAL) {\n\tcase 0: return 400;\n\tcase 1: return 4000;\n\tcase 2: return 8000;\n\tcase 3: return 12000;\n\tcase 4: return 16000;\n\tcase 5: return 32000;\n\tcase 6: return 64000;\n\tdefault: return 400;\n\t}\n}\n\nvoid decide_8b_10b_training_settings(\n\t struct dc_link *link,\n\tconst struct dc_link_settings *link_setting,\n\tstruct link_training_settings *lt_settings)\n{\n\tmemset(lt_settings, '\\0', sizeof(struct link_training_settings));\n\n\t \n\tlt_settings->link_settings.use_link_rate_set = link_setting->use_link_rate_set;\n\tlt_settings->link_settings.link_rate_set = link_setting->link_rate_set;\n\tlt_settings->link_settings.link_rate = link_setting->link_rate;\n\tlt_settings->link_settings.lane_count = link_setting->lane_count;\n\t \n\tlt_settings->link_settings.link_spread = link->dp_ss_off ?\n\t\t\tLINK_SPREAD_DISABLED : LINK_SPREAD_05_DOWNSPREAD_30KHZ;\n\tlt_settings->cr_pattern_time = get_cr_training_aux_rd_interval(link, link_setting);\n\tlt_settings->eq_pattern_time = get_eq_training_aux_rd_interval(link, link_setting);\n\tlt_settings->pattern_for_cr = decide_cr_training_pattern(link_setting);\n\tlt_settings->pattern_for_eq = decide_eq_training_pattern(link, link_setting);\n\tlt_settings->enhanced_framing = 1;\n\tlt_settings->should_set_fec_ready = true;\n\tlt_settings->disallow_per_lane_settings = true;\n\tlt_settings->always_match_dpcd_with_hw_lane_settings = true;\n\tlt_settings->lttpr_mode = dp_decide_8b_10b_lttpr_mode(link);\n\tdp_hw_to_dpcd_lane_settings(lt_settings, lt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n}\n\nenum lttpr_mode dp_decide_8b_10b_lttpr_mode(struct dc_link *link)\n{\n\tbool is_lttpr_present = dp_is_lttpr_present(link);\n\tbool vbios_lttpr_force_non_transparent = link->dc->caps.vbios_lttpr_enable;\n\tbool vbios_lttpr_aware = link->dc->caps.vbios_lttpr_aware;\n\n\tif (!is_lttpr_present)\n\t\treturn LTTPR_MODE_NON_LTTPR;\n\n\tif (vbios_lttpr_aware) {\n\t\tif (vbios_lttpr_force_non_transparent) {\n\t\t\tDC_LOG_DC(\"chose LTTPR_MODE_NON_TRANSPARENT due to VBIOS DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE set to 1.\\n\");\n\t\t\treturn LTTPR_MODE_NON_TRANSPARENT;\n\t\t} else {\n\t\t\tDC_LOG_DC(\"chose LTTPR_MODE_NON_TRANSPARENT by default due to VBIOS not set DCE_INFO_CAPS_LTTPR_SUPPORT_ENABLE set to 1.\\n\");\n\t\t\treturn LTTPR_MODE_TRANSPARENT;\n\t\t}\n\t}\n\n\tif (link->dc->config.allow_lttpr_non_transparent_mode.bits.DP1_4A &&\n\t\t\tlink->dc->caps.extended_aux_timeout_support) {\n\t\tDC_LOG_DC(\"chose LTTPR_MODE_NON_TRANSPARENT by default and dc->config.allow_lttpr_non_transparent_mode.bits.DP1_4A set to 1.\\n\");\n\t\treturn LTTPR_MODE_NON_TRANSPARENT;\n\t}\n\n\tDC_LOG_DC(\"chose LTTPR_MODE_NON_LTTPR.\\n\");\n\treturn LTTPR_MODE_NON_LTTPR;\n}\n\nenum link_training_result perform_8b_10b_clock_recovery_sequence(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tstruct link_training_settings *lt_settings,\n\tuint32_t offset)\n{\n\tuint32_t retries_cr;\n\tuint32_t retry_count;\n\tuint32_t wait_time_microsec;\n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX];\n\tunion lane_align_status_updated dpcd_lane_status_updated;\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\n\tretries_cr = 0;\n\tretry_count = 0;\n\n\tmemset(&dpcd_lane_status, '\\0', sizeof(dpcd_lane_status));\n\tmemset(&dpcd_lane_status_updated, '\\0',\n\tsizeof(dpcd_lane_status_updated));\n\n\tif (!link->ctx->dc->work_arounds.lt_early_cr_pattern)\n\t\tdp_set_hw_training_pattern(link, link_res, lt_settings->pattern_for_cr, offset);\n\n\t \n\t \n\twhile ((retries_cr < LINK_TRAINING_MAX_RETRY_COUNT) &&\n\t\t(retry_count < LINK_TRAINING_MAX_CR_RETRY)) {\n\n\n\t\t \n\t\tdp_set_hw_lane_settings(\n\t\t\t\tlink,\n\t\t\t\tlink_res,\n\t\t\t\tlt_settings,\n\t\t\t\toffset);\n\n\t\t \n\t\tif (!retry_count)\n\t\t\t \n\t\t\tdpcd_set_lt_pattern_and_lane_settings(\n\t\t\t\t\tlink,\n\t\t\t\t\tlt_settings,\n\t\t\t\t\tlt_settings->pattern_for_cr,\n\t\t\t\t\toffset);\n\t\telse\n\t\t\tdpcd_set_lane_settings(\n\t\t\t\t\tlink,\n\t\t\t\t\tlt_settings,\n\t\t\t\t\toffset);\n\n\t\t \n\t\twait_time_microsec = lt_settings->cr_pattern_time;\n\n\t\tdp_wait_for_training_aux_rd_interval(\n\t\t\t\tlink,\n\t\t\t\twait_time_microsec);\n\n\t\t \n\t\tdp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\toffset);\n\n\t\t \n\t\tif (dp_is_cr_done(lane_count, dpcd_lane_status)) {\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Clock recovery OK\\n\", __func__);\n\t\t\treturn LINK_TRAINING_SUCCESS;\n\t\t}\n\n\t\t \n\t\tif ((link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_8b_10b_ENCODING) &&\n\t\t\t\tdp_is_max_vs_reached(lt_settings))\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\tif ((link_dp_get_encoding_format(&lt_settings->link_settings) == DP_8b_10b_ENCODING) &&\n\t\t\t\tlt_settings->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET ==\n\t\t\t\t\t\tdpcd_lane_adjust[0].bits.VOLTAGE_SWING_LANE)\n\t\t\tretries_cr++;\n\t\telse if ((link_dp_get_encoding_format(&lt_settings->link_settings) == DP_128b_132b_ENCODING) &&\n\t\t\t\tlt_settings->dpcd_lane_settings[0].tx_ffe.PRESET_VALUE ==\n\t\t\t\t\t\tdpcd_lane_adjust[0].tx_ffe.PRESET_VALUE)\n\t\t\tretries_cr++;\n\t\telse\n\t\t\tretries_cr = 0;\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t\tretry_count++;\n\t}\n\n\tif (retry_count >= LINK_TRAINING_MAX_CR_RETRY) {\n\t\tASSERT(0);\n\t\tDC_LOG_ERROR(\"%s: Link Training Error, could not get CR after %d tries. Possibly voltage swing issue\",\n\t\t\t__func__,\n\t\t\tLINK_TRAINING_MAX_CR_RETRY);\n\n\t}\n\n\treturn dp_get_cr_failure(lane_count, dpcd_lane_status);\n}\n\nenum link_training_result perform_8b_10b_channel_equalization_sequence(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tstruct link_training_settings *lt_settings,\n\tuint32_t offset)\n{\n\tenum dc_dp_training_pattern tr_pattern;\n\tuint32_t retries_ch_eq;\n\tuint32_t wait_time_microsec;\n\tenum dc_lane_count lane_count = lt_settings->link_settings.lane_count;\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\n\t \n\ttr_pattern = lt_settings->pattern_for_eq;\n\n\tif (is_repeater(lt_settings, offset) && link_dp_get_encoding_format(&lt_settings->link_settings) == DP_8b_10b_ENCODING)\n\t\ttr_pattern = DP_TRAINING_PATTERN_SEQUENCE_4;\n\n\tdp_set_hw_training_pattern(link, link_res, tr_pattern, offset);\n\n\tfor (retries_ch_eq = 0; retries_ch_eq <= LINK_TRAINING_MAX_RETRY_COUNT;\n\t\tretries_ch_eq++) {\n\n\t\tdp_set_hw_lane_settings(link, link_res, lt_settings, offset);\n\n\t\t \n\t\tif (!retries_ch_eq)\n\t\t\t \n\n\t\t\tdpcd_set_lt_pattern_and_lane_settings(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\ttr_pattern, offset);\n\t\telse\n\t\t\tdpcd_set_lane_settings(link, lt_settings, offset);\n\n\t\t \n\t\twait_time_microsec = lt_settings->eq_pattern_time;\n\n\t\tif (is_repeater(lt_settings, offset))\n\t\t\twait_time_microsec =\n\t\t\t\t\tdp_translate_training_aux_read_interval(\n\t\t\t\t\t\tlink->dpcd_caps.lttpr_caps.aux_rd_interval[offset - 1]);\n\n\t\tdp_wait_for_training_aux_rd_interval(\n\t\t\t\tlink,\n\t\t\t\twait_time_microsec);\n\n\t\t \n\n\t\tdp_get_lane_status_and_lane_adjust(\n\t\t\tlink,\n\t\t\tlt_settings,\n\t\t\tdpcd_lane_status,\n\t\t\t&dpcd_lane_status_updated,\n\t\t\tdpcd_lane_adjust,\n\t\t\toffset);\n\n\t\t \n\t\tif (!dp_is_cr_done(lane_count, dpcd_lane_status))\n\t\t\treturn dpcd_lane_status[0].bits.CR_DONE_0 ?\n\t\t\t\t\tLINK_TRAINING_EQ_FAIL_CR_PARTIAL :\n\t\t\t\t\tLINK_TRAINING_EQ_FAIL_CR;\n\n\t\t \n\t\tif (dp_is_ch_eq_done(lane_count, dpcd_lane_status) &&\n\t\t\t\tdp_is_symbol_locked(lane_count, dpcd_lane_status) &&\n\t\t\t\tdp_is_interlane_aligned(dpcd_lane_status_updated))\n\t\t\treturn LINK_TRAINING_SUCCESS;\n\n\t\t \n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t}\n\n\treturn LINK_TRAINING_EQ_FAIL_EQ;\n\n}\n\nenum link_training_result dp_perform_8b_10b_link_training(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum link_training_result status = LINK_TRAINING_SUCCESS;\n\n\tuint8_t repeater_cnt;\n\tuint8_t repeater_id;\n\tuint8_t lane = 0;\n\n\tif (link->ctx->dc->work_arounds.lt_early_cr_pattern)\n\t\tstart_clock_recovery_pattern_early(link, link_res, lt_settings, DPRX);\n\n\t \n\tdpcd_set_link_settings(link, lt_settings);\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT) {\n\n\t\t \n\t\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\t\tfor (repeater_id = repeater_cnt; (repeater_id > 0 && status == LINK_TRAINING_SUCCESS);\n\t\t\t\trepeater_id--) {\n\t\t\tstatus = perform_8b_10b_clock_recovery_sequence(link, link_res, lt_settings, repeater_id);\n\n\t\t\tif (status != LINK_TRAINING_SUCCESS) {\n\t\t\t\trepeater_training_done(link, repeater_id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = perform_8b_10b_channel_equalization_sequence(link,\n\t\t\t\t\tlink_res,\n\t\t\t\t\tlt_settings,\n\t\t\t\t\trepeater_id);\n\t\t\tif (status == LINK_TRAINING_SUCCESS)\n\t\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Channel EQ done.\\n\", __func__);\n\n\t\t\trepeater_training_done(link, repeater_id);\n\n\t\t\tif (status != LINK_TRAINING_SUCCESS)\n\t\t\t\tbreak;\n\n\t\t\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\t\t\tlt_settings->dpcd_lane_settings[lane].raw = 0;\n\t\t\t\tlt_settings->hw_lane_settings[lane].VOLTAGE_SWING = 0;\n\t\t\t\tlt_settings->hw_lane_settings[lane].PRE_EMPHASIS = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status == LINK_TRAINING_SUCCESS) {\n\t\tstatus = perform_8b_10b_clock_recovery_sequence(link, link_res, lt_settings, DPRX);\n\t\tif (status == LINK_TRAINING_SUCCESS) {\n\t\t\tstatus = perform_8b_10b_channel_equalization_sequence(link,\n\t\t\t\t\tlink_res,\n\t\t\t\t\tlt_settings,\n\t\t\t\t\tDPRX);\n\t\t\tif (status == LINK_TRAINING_SUCCESS)\n\t\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Channel EQ done.\\n\", __func__);\n\t\t}\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}