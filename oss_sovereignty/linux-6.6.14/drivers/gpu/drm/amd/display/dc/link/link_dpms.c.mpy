{
  "module_name": "link_dpms.c",
  "hash_id": "2fb8d5b52fd4aaaab07610631cedea0414b8acd4d4634c4c7c498b3ed56949da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/link_dpms.c",
  "human_readable_source": " \n\n \n\n#include \"link_dpms.h\"\n#include \"link_hwss.h\"\n#include \"link_validation.h\"\n#include \"accessories/link_fpga.h\"\n#include \"accessories/link_dp_trace.h\"\n#include \"protocols/link_dpcd.h\"\n#include \"protocols/link_ddc.h\"\n#include \"protocols/link_hpd.h\"\n#include \"protocols/link_dp_phy.h\"\n#include \"protocols/link_dp_capability.h\"\n#include \"protocols/link_dp_training.h\"\n#include \"protocols/link_edp_panel_control.h\"\n#include \"protocols/link_dp_dpia_bw.h\"\n\n#include \"dm_helpers.h\"\n#include \"link_enc_cfg.h\"\n#include \"resource.h\"\n#include \"dsc.h\"\n#include \"dccg.h\"\n#include \"clk_mgr.h\"\n#include \"atomfirmware.h\"\n#define DC_LOGGER_INIT(logger)\n\n#define LINK_INFO(...) \\\n\tDC_LOG_HW_HOTPLUG(  \\\n\t\t__VA_ARGS__)\n\n#define RETIMER_REDRIVER_INFO(...) \\\n\tDC_LOG_RETIMER_REDRIVER(  \\\n\t\t__VA_ARGS__)\n#include \"dc/dcn30/dcn30_vpg.h\"\n\n#define MAX_MTP_SLOT_COUNT 64\n#define LINK_TRAINING_ATTEMPTS 4\n#define PEAK_FACTOR_X1000 1006\n\nvoid link_blank_all_dp_displays(struct dc *dc)\n{\n\tunsigned int i;\n\tuint8_t dpcd_power_state = '\\0';\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tif ((dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) ||\n\t\t\t(dc->links[i]->priv == NULL) || (dc->links[i]->local_sink == NULL))\n\t\t\tcontinue;\n\n\t\t \n\t\tdp_retrieve_lttpr_cap(dc->links[i]);\n\t\t \n\t\tstatus = core_link_read_dpcd(dc->links[i], DP_SET_POWER,\n\t\t\t\t\t\t\t&dpcd_power_state, sizeof(dpcd_power_state));\n\n\t\tif (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0)\n\t\t\tlink_blank_dp_stream(dc->links[i], true);\n\t}\n\n}\n\nvoid link_blank_all_edp_displays(struct dc *dc)\n{\n\tunsigned int i;\n\tuint8_t dpcd_power_state = '\\0';\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tif ((dc->links[i]->connector_signal != SIGNAL_TYPE_EDP) ||\n\t\t\t(!dc->links[i]->edp_sink_present))\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = core_link_read_dpcd(dc->links[i], DP_SET_POWER,\n\t\t\t\t\t\t\t&dpcd_power_state, sizeof(dpcd_power_state));\n\n\t\tif (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0)\n\t\t\tlink_blank_dp_stream(dc->links[i], true);\n\t}\n}\n\nvoid link_blank_dp_stream(struct dc_link *link, bool hw_init)\n{\n\tunsigned int j;\n\tstruct dc  *dc = link->ctx->dc;\n\tenum signal_type signal = link->connector_signal;\n\n\tif ((signal == SIGNAL_TYPE_EDP) ||\n\t\t(signal == SIGNAL_TYPE_DISPLAY_PORT)) {\n\t\tif (link->ep_type == DISPLAY_ENDPOINT_PHY &&\n\t\t\tlink->link_enc->funcs->get_dig_frontend &&\n\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tunsigned int fe = link->link_enc->funcs->get_dig_frontend(link->link_enc);\n\n\t\t\tif (fe != ENGINE_ID_UNKNOWN)\n\t\t\t\tfor (j = 0; j < dc->res_pool->stream_enc_count; j++) {\n\t\t\t\t\tif (fe == dc->res_pool->stream_enc[j]->id) {\n\t\t\t\t\t\tdc->res_pool->stream_enc[j]->funcs->dp_blank(link,\n\t\t\t\t\t\t\t\t\tdc->res_pool->stream_enc[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tif ((!link->wa_flags.dp_keep_receiver_powered) || hw_init)\n\t\t\tdpcd_write_rx_power_ctrl(link, false);\n\t}\n}\n\nvoid link_set_all_streams_dpms_off_for_link(struct dc_link *link)\n{\n\tstruct pipe_ctx *pipes[MAX_PIPES];\n\tstruct dc_state *state = link->dc->current_state;\n\tuint8_t count;\n\tint i;\n\tstruct dc_stream_update stream_update;\n\tbool dpms_off = true;\n\tstruct link_resource link_res = {0};\n\n\tmemset(&stream_update, 0, sizeof(stream_update));\n\tstream_update.dpms_off = &dpms_off;\n\n\tlink_get_master_pipes_with_dpms_on(link, state, &count, pipes);\n\n\tfor (i = 0; i < count; i++) {\n\t\tstream_update.stream = pipes[i]->stream;\n\t\tdc_commit_updates_for_stream(link->ctx->dc, NULL, 0,\n\t\t\t\tpipes[i]->stream, &stream_update,\n\t\t\t\tstate);\n\t}\n\n\t \n\tdp_disable_link_phy(link, &link_res, link->connector_signal);\n}\n\nvoid link_resume(struct dc_link *link)\n{\n\tif (link->connector_signal != SIGNAL_TYPE_VIRTUAL)\n\t\tprogram_hpd_filter(link);\n}\n\n \nstatic bool is_master_pipe_for_link(const struct dc_link *link,\n\t\tconst struct pipe_ctx *pipe)\n{\n\treturn resource_is_pipe_type(pipe, OTG_MASTER) &&\n\t\t\tpipe->stream->link == link;\n}\n\n \nvoid link_get_master_pipes_with_dpms_on(const struct dc_link *link,\n\t\tstruct dc_state *state,\n\t\tuint8_t *count,\n\t\tstruct pipe_ctx *pipes[MAX_PIPES])\n{\n\tint i;\n\tstruct pipe_ctx *pipe = NULL;\n\n\t*count = 0;\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe = &state->res_ctx.pipe_ctx[i];\n\n\t\tif (is_master_pipe_for_link(link, pipe) &&\n\t\t\t\tpipe->stream->dpms_off == false) {\n\t\t\tpipes[(*count)++] = pipe;\n\t\t}\n\t}\n}\n\nstatic bool get_ext_hdmi_settings(struct pipe_ctx *pipe_ctx,\n\t\tenum engine_id eng_id,\n\t\tstruct ext_hdmi_settings *settings)\n{\n\tbool result = false;\n\tint i = 0;\n\tstruct integrated_info *integrated_info =\n\t\t\tpipe_ctx->stream->ctx->dc_bios->integrated_info;\n\n\tif (integrated_info == NULL)\n\t\treturn false;\n\n\t \n\n\t\n\tif (integrated_info->gpu_cap_info & 0x20) {\n\t\tswitch (eng_id) {\n\t\tcase ENGINE_ID_DIGA:\n\t\t\tsettings->slv_addr = integrated_info->dp0_ext_hdmi_slv_addr;\n\t\t\tsettings->reg_num = integrated_info->dp0_ext_hdmi_6g_reg_num;\n\t\t\tsettings->reg_num_6g = integrated_info->dp0_ext_hdmi_6g_reg_num;\n\t\t\tmemmove(settings->reg_settings,\n\t\t\t\t\tintegrated_info->dp0_ext_hdmi_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp0_ext_hdmi_reg_settings));\n\t\t\tmemmove(settings->reg_settings_6g,\n\t\t\t\t\tintegrated_info->dp0_ext_hdmi_6g_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp0_ext_hdmi_6g_reg_settings));\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tcase ENGINE_ID_DIGB:\n\t\t\tsettings->slv_addr = integrated_info->dp1_ext_hdmi_slv_addr;\n\t\t\tsettings->reg_num = integrated_info->dp1_ext_hdmi_6g_reg_num;\n\t\t\tsettings->reg_num_6g = integrated_info->dp1_ext_hdmi_6g_reg_num;\n\t\t\tmemmove(settings->reg_settings,\n\t\t\t\t\tintegrated_info->dp1_ext_hdmi_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp1_ext_hdmi_reg_settings));\n\t\t\tmemmove(settings->reg_settings_6g,\n\t\t\t\t\tintegrated_info->dp1_ext_hdmi_6g_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp1_ext_hdmi_6g_reg_settings));\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tcase ENGINE_ID_DIGC:\n\t\t\tsettings->slv_addr = integrated_info->dp2_ext_hdmi_slv_addr;\n\t\t\tsettings->reg_num = integrated_info->dp2_ext_hdmi_6g_reg_num;\n\t\t\tsettings->reg_num_6g = integrated_info->dp2_ext_hdmi_6g_reg_num;\n\t\t\tmemmove(settings->reg_settings,\n\t\t\t\t\tintegrated_info->dp2_ext_hdmi_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp2_ext_hdmi_reg_settings));\n\t\t\tmemmove(settings->reg_settings_6g,\n\t\t\t\t\tintegrated_info->dp2_ext_hdmi_6g_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp2_ext_hdmi_6g_reg_settings));\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tcase ENGINE_ID_DIGD:\n\t\t\tsettings->slv_addr = integrated_info->dp3_ext_hdmi_slv_addr;\n\t\t\tsettings->reg_num = integrated_info->dp3_ext_hdmi_6g_reg_num;\n\t\t\tsettings->reg_num_6g = integrated_info->dp3_ext_hdmi_6g_reg_num;\n\t\t\tmemmove(settings->reg_settings,\n\t\t\t\t\tintegrated_info->dp3_ext_hdmi_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp3_ext_hdmi_reg_settings));\n\t\t\tmemmove(settings->reg_settings_6g,\n\t\t\t\t\tintegrated_info->dp3_ext_hdmi_6g_reg_settings,\n\t\t\t\t\tsizeof(integrated_info->dp3_ext_hdmi_6g_reg_settings));\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == true) {\n\t\t\t\n\t\t\tif (settings->slv_addr == 0)\n\t\t\t\treturn false;\n\t\t\tif (settings->reg_num > 9)\n\t\t\t\treturn false;\n\t\t\tif (settings->reg_num_6g > 3)\n\t\t\t\treturn false;\n\n\t\t\tfor (i = 0; i < settings->reg_num; i++) {\n\t\t\t\tif (settings->reg_settings[i].i2c_reg_index > 0x20)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < settings->reg_num_6g; i++) {\n\t\t\t\tif (settings->reg_settings_6g[i].i2c_reg_index > 0x20)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic bool write_i2c(struct pipe_ctx *pipe_ctx,\n\t\tuint8_t address, uint8_t *buffer, uint32_t length)\n{\n\tstruct i2c_command cmd = {0};\n\tstruct i2c_payload payload = {0};\n\n\tmemset(&payload, 0, sizeof(payload));\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.number_of_payloads = 1;\n\tcmd.engine = I2C_COMMAND_ENGINE_DEFAULT;\n\tcmd.speed = pipe_ctx->stream->ctx->dc->caps.i2c_speed_in_khz;\n\n\tpayload.address = address;\n\tpayload.data = buffer;\n\tpayload.length = length;\n\tpayload.write = true;\n\tcmd.payloads = &payload;\n\n\tif (dm_helpers_submit_i2c(pipe_ctx->stream->ctx,\n\t\t\tpipe_ctx->stream->link, &cmd))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void write_i2c_retimer_setting(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool is_vga_mode,\n\t\tbool is_over_340mhz,\n\t\tstruct ext_hdmi_settings *settings)\n{\n\tuint8_t slave_address = (settings->slv_addr >> 1);\n\tuint8_t buffer[2];\n\tconst uint8_t apply_rx_tx_change = 0x4;\n\tuint8_t offset = 0xA;\n\tuint8_t value = 0;\n\tint i = 0;\n\tbool i2c_success = false;\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\tmemset(&buffer, 0, sizeof(buffer));\n\n\t \n\n\tfor (i = 0; i < settings->reg_num; i++) {\n\t\t \n\t\tif (settings->reg_settings[i].i2c_reg_index <= 0x20) {\n\n\t\t\tbuffer[0] = settings->reg_settings[i].i2c_reg_index;\n\t\t\tbuffer[1] = settings->reg_settings[i].i2c_reg_val;\n\t\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\t\t\tbuffer, sizeof(buffer));\n\t\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\t\toffset = 0x%x, reg_val= 0x%x, i2c_success = %d\\n\",\n\t\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\n\t\t\tif (!i2c_success)\n\t\t\t\tgoto i2c_write_fail;\n\n\t\t\t/* Based on DP159 specs, APPLY_RX_TX_CHANGE bit in 0x0A\n\t\t\t * needs to be set to 1 on every 0xA-0xC write.\n\t\t\t */\n\t\t\tif (settings->reg_settings[i].i2c_reg_index == 0xA ||\n\t\t\t\tsettings->reg_settings[i].i2c_reg_index == 0xB ||\n\t\t\t\tsettings->reg_settings[i].i2c_reg_index == 0xC) {\n\n\t\t\t\t/* Query current value from offset 0xA */\n\t\t\t\tif (settings->reg_settings[i].i2c_reg_index == 0xA)\n\t\t\t\t\tvalue = settings->reg_settings[i].i2c_reg_val;\n\t\t\t\telse {\n\t\t\t\t\ti2c_success =\n\t\t\t\t\t\tlink_query_ddc_data(\n\t\t\t\t\t\tpipe_ctx->stream->link->ddc,\n\t\t\t\t\t\tslave_address, &offset, 1, &value, 1);\n\t\t\t\t\tif (!i2c_success)\n\t\t\t\t\t\tgoto i2c_write_fail;\n\t\t\t\t}\n\n\t\t\t\tbuffer[0] = offset;\n\t\t\t\t/* Set APPLY_RX_TX_CHANGE bit to 1 */\n\t\t\t\tbuffer[1] = value | apply_rx_tx_change;\n\t\t\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\t\t\tbuffer, sizeof(buffer));\n\t\t\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\t\t\tif (!i2c_success)\n\t\t\t\t\tgoto i2c_write_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply 3G settings */\n\tif (is_over_340mhz) {\n\t\tfor (i = 0; i < settings->reg_num_6g; i++) {\n\t\t\t/* Apply 3G settings */\n\t\t\tif (settings->reg_settings[i].i2c_reg_index <= 0x20) {\n\n\t\t\t\tbuffer[0] = settings->reg_settings_6g[i].i2c_reg_index;\n\t\t\t\tbuffer[1] = settings->reg_settings_6g[i].i2c_reg_val;\n\t\t\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\t\t\t\tbuffer, sizeof(buffer));\n\t\t\t\tRETIMER_REDRIVER_INFO(\"above 340Mhz: retimer write to slave_address = 0x%x,\\\n\t\t\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\n\t\t\t\tif (!i2c_success)\n\t\t\t\t\tgoto i2c_write_fail;\n\n\t\t\t\t/* Based on DP159 specs, APPLY_RX_TX_CHANGE bit in 0x0A\n\t\t\t\t * needs to be set to 1 on every 0xA-0xC write.\n\t\t\t\t */\n\t\t\t\tif (settings->reg_settings_6g[i].i2c_reg_index == 0xA ||\n\t\t\t\t\tsettings->reg_settings_6g[i].i2c_reg_index == 0xB ||\n\t\t\t\t\tsettings->reg_settings_6g[i].i2c_reg_index == 0xC) {\n\n\t\t\t\t\t/* Query current value from offset 0xA */\n\t\t\t\t\tif (settings->reg_settings_6g[i].i2c_reg_index == 0xA)\n\t\t\t\t\t\tvalue = settings->reg_settings_6g[i].i2c_reg_val;\n\t\t\t\t\telse {\n\t\t\t\t\t\ti2c_success =\n\t\t\t\t\t\t\t\tlink_query_ddc_data(\n\t\t\t\t\t\t\t\tpipe_ctx->stream->link->ddc,\n\t\t\t\t\t\t\t\tslave_address, &offset, 1, &value, 1);\n\t\t\t\t\t\tif (!i2c_success)\n\t\t\t\t\t\t\tgoto i2c_write_fail;\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffer[0] = offset;\n\t\t\t\t\t/* Set APPLY_RX_TX_CHANGE bit to 1 */\n\t\t\t\t\tbuffer[1] = value | apply_rx_tx_change;\n\t\t\t\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\t\t\t\tbuffer, sizeof(buffer));\n\t\t\t\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\t\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\t\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\t\t\t\tif (!i2c_success)\n\t\t\t\t\t\tgoto i2c_write_fail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_vga_mode) {\n\t\t/* Program additional settings if using 640x480 resolution */\n\n\t\t/* Write offset 0xFF to 0x01 */\n\t\tbuffer[0] = 0xff;\n\t\tbuffer[1] = 0x01;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\n\t\t/* Write offset 0x00 to 0x23 */\n\t\tbuffer[0] = 0x00;\n\t\tbuffer[1] = 0x23;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\n\t\t/* Write offset 0xff to 0x00 */\n\t\tbuffer[0] = 0xff;\n\t\tbuffer[1] = 0x00;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_address = 0x%x,\\\n\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\n\t}\n\n\treturn;\n\ni2c_write_fail:\n\tDC_LOG_DEBUG(\"Set retimer failed\");\n}\n\nstatic void write_i2c_default_retimer_setting(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool is_vga_mode,\n\t\tbool is_over_340mhz)\n{\n\tuint8_t slave_address = (0xBA >> 1);\n\tuint8_t buffer[2];\n\tbool i2c_success = false;\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\tmemset(&buffer, 0, sizeof(buffer));\n\n\t/* Program Slave Address for tuning single integrity */\n\t/* Write offset 0x0A to 0x13 */\n\tbuffer[0] = 0x0A;\n\tbuffer[1] = 0x13;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer writes default setting to slave_address = 0x%x,\\\n\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\t/* Write offset 0x0A to 0x17 */\n\tbuffer[0] = 0x0A;\n\tbuffer[1] = 0x17;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\t/* Write offset 0x0B to 0xDA or 0xD8 */\n\tbuffer[0] = 0x0B;\n\tbuffer[1] = is_over_340mhz ? 0xDA : 0xD8;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\t/* Write offset 0x0A to 0x17 */\n\tbuffer[0] = 0x0A;\n\tbuffer[1] = 0x17;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\toffset = 0x%x, reg_val= 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\t/* Write offset 0x0C to 0x1D or 0x91 */\n\tbuffer[0] = 0x0C;\n\tbuffer[1] = is_over_340mhz ? 0x1D : 0x91;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\t/* Write offset 0x0A to 0x17 */\n\tbuffer[0] = 0x0A;\n\tbuffer[1] = 0x17;\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\tif (!i2c_success)\n\t\tgoto i2c_write_fail;\n\n\n\tif (is_vga_mode) {\n\t\t/* Program additional settings if using 640x480 resolution */\n\n\t\t/* Write offset 0xFF to 0x01 */\n\t\tbuffer[0] = 0xff;\n\t\tbuffer[1] = 0x01;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\t\toffset = 0x%x, reg_val = 0x%x, i2c_success = %d\\n\",\n\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\n\t\t/* Write offset 0x00 to 0x23 */\n\t\tbuffer[0] = 0x00;\n\t\tbuffer[1] = 0x23;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write to slave_addr = 0x%x,\\\n\t\t\toffset = 0x%x, reg_val= 0x%x, i2c_success = %d\\n\",\n\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\n\t\t/* Write offset 0xff to 0x00 */\n\t\tbuffer[0] = 0xff;\n\t\tbuffer[1] = 0x00;\n\t\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\tbuffer, sizeof(buffer));\n\t\tRETIMER_REDRIVER_INFO(\"retimer write default setting to slave_addr = 0x%x,\\\n\t\t\toffset = 0x%x, reg_val= 0x%x, i2c_success = %d end here\\n\",\n\t\t\tslave_address, buffer[0], buffer[1], i2c_success?1:0);\n\t\tif (!i2c_success)\n\t\t\tgoto i2c_write_fail;\n\t}\n\n\treturn;\n\ni2c_write_fail:\n\tDC_LOG_DEBUG(\"Set default retimer failed\");\n}\n\nstatic void write_i2c_redriver_setting(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool is_over_340mhz)\n{\n\tuint8_t slave_address = (0xF0 >> 1);\n\tuint8_t buffer[16];\n\tbool i2c_success = false;\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\tmemset(&buffer, 0, sizeof(buffer));\n\n\t// Program Slave Address for tuning single integrity\n\tbuffer[3] = 0x4E;\n\tbuffer[4] = 0x4E;\n\tbuffer[5] = 0x4E;\n\tbuffer[6] = is_over_340mhz ? 0x4E : 0x4A;\n\n\ti2c_success = write_i2c(pipe_ctx, slave_address,\n\t\t\t\t\tbuffer, sizeof(buffer));\n\tRETIMER_REDRIVER_INFO(\"redriver write 0 to all 16 reg offset expect following:\\n\\\n\t\t\\t slave_addr = 0x%x, offset[3] = 0x%x, offset[4] = 0x%x,\\\n\t\toffset[5] = 0x%x,offset[6] is_over_340mhz = 0x%x,\\\n\t\ti2c_success = %d\\n\",\n\t\tslave_address, buffer[3], buffer[4], buffer[5], buffer[6], i2c_success?1:0);\n\n\tif (!i2c_success)\n\t\tDC_LOG_DEBUG(\"Set redriver failed\");\n}\n\nstatic void update_psp_stream_config(struct pipe_ctx *pipe_ctx, bool dpms_off)\n{\n\tstruct cp_psp *cp_psp = &pipe_ctx->stream->ctx->cp_psp;\n\tstruct link_encoder *link_enc = NULL;\n\tstruct cp_psp_stream_config config = {0};\n\tenum dp_panel_mode panel_mode =\n\t\t\tdp_get_panel_mode(pipe_ctx->stream->link);\n\n\tif (cp_psp == NULL || cp_psp->funcs.update_stream_config == NULL)\n\t\treturn;\n\n\tlink_enc = link_enc_cfg_get_link_enc(pipe_ctx->stream->link);\n\tASSERT(link_enc);\n\tif (link_enc == NULL)\n\t\treturn;\n\n\t/* otg instance */\n\tconfig.otg_inst = (uint8_t) pipe_ctx->stream_res.tg->inst;\n\n\t/* dig front end */\n\tconfig.dig_fe = (uint8_t) pipe_ctx->stream_res.stream_enc->stream_enc_inst;\n\n\t/* stream encoder index */\n\tconfig.stream_enc_idx = pipe_ctx->stream_res.stream_enc->id - ENGINE_ID_DIGA;\n\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\tconfig.stream_enc_idx =\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->id - ENGINE_ID_HPO_DP_0;\n\n\t/* dig back end */\n\tconfig.dig_be = pipe_ctx->stream->link->link_enc_hw_inst;\n\n\t/* link encoder index */\n\tconfig.link_enc_idx = link_enc->transmitter - TRANSMITTER_UNIPHY_A;\n\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\tconfig.link_enc_idx = pipe_ctx->link_res.hpo_dp_link_enc->inst;\n\n\t/* dio output index is dpia index for DPIA endpoint & dcio index by default */\n\tif (pipe_ctx->stream->link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA)\n\t\tconfig.dio_output_idx = pipe_ctx->stream->link->link_id.enum_id - ENUM_ID_1;\n\telse\n\t\tconfig.dio_output_idx = link_enc->transmitter - TRANSMITTER_UNIPHY_A;\n\n\n\t/* phy index */\n\tconfig.phy_idx = resource_transmitter_to_phy_idx(\n\t\t\tpipe_ctx->stream->link->dc, link_enc->transmitter);\n\tif (pipe_ctx->stream->link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA)\n\t\t/* USB4 DPIA doesn't use PHY in our soc, initialize it to 0 */\n\t\tconfig.phy_idx = 0;\n\n\t/* stream properties */\n\tconfig.assr_enabled = (panel_mode == DP_PANEL_MODE_EDP) ? 1 : 0;\n\tconfig.mst_enabled = (pipe_ctx->stream->signal ==\n\t\t\tSIGNAL_TYPE_DISPLAY_PORT_MST) ? 1 : 0;\n\tconfig.dp2_enabled = dp_is_128b_132b_signal(pipe_ctx) ? 1 : 0;\n\tconfig.usb4_enabled = (pipe_ctx->stream->link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA) ?\n\t\t\t1 : 0;\n\tconfig.dpms_off = dpms_off;\n\n\t/* dm stream context */\n\tconfig.dm_stream_ctx = pipe_ctx->stream->dm_stream_context;\n\n\tcp_psp->funcs.update_stream_config(cp_psp->handle, &config);\n}\n\nstatic void set_avmute(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct dc  *dc = pipe_ctx->stream->ctx->dc;\n\n\tif (!dc_is_hdmi_signal(pipe_ctx->stream->signal))\n\t\treturn;\n\n\tdc->hwss.set_avmute(pipe_ctx, enable);\n}\n\nstatic void enable_mst_on_sink(struct dc_link *link, bool enable)\n{\n\tunsigned char mstmCntl;\n\n\tcore_link_read_dpcd(link, DP_MSTM_CTRL, &mstmCntl, 1);\n\tif (enable)\n\t\tmstmCntl |= DP_MST_EN;\n\telse\n\t\tmstmCntl &= (~DP_MST_EN);\n\n\tcore_link_write_dpcd(link, DP_MSTM_CTRL, &mstmCntl, 1);\n}\n\nstatic void dsc_optc_config_log(struct display_stream_compressor *dsc,\n\t\tstruct dsc_optc_config *config)\n{\n\tuint32_t precision = 1 << 28;\n\tuint32_t bytes_per_pixel_int = config->bytes_per_pixel / precision;\n\tuint32_t bytes_per_pixel_mod = config->bytes_per_pixel % precision;\n\tuint64_t ll_bytes_per_pix_fraq = bytes_per_pixel_mod;\n\tDC_LOGGER_INIT(dsc->ctx->logger);\n\n\t/* 7 fractional digits decimal precision for bytes per pixel is enough because DSC\n\t * bits per pixel precision is 1/16th of a pixel, which means bytes per pixel precision is\n\t * 1/16/8 = 1/128 of a byte, or 0.0078125 decimal\n\t */\n\tll_bytes_per_pix_fraq *= 10000000;\n\tll_bytes_per_pix_fraq /= precision;\n\n\tDC_LOG_DSC(\"\\tbytes_per_pixel 0x%08x (%d.%07d)\",\n\t\t\tconfig->bytes_per_pixel, bytes_per_pixel_int, (uint32_t)ll_bytes_per_pix_fraq);\n\tDC_LOG_DSC(\"\\tis_pixel_format_444 %d\", config->is_pixel_format_444);\n\tDC_LOG_DSC(\"\\tslice_width %d\", config->slice_width);\n}\n\nstatic bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tbool result = false;\n\n\tif (dc_is_virtual_signal(stream->signal))\n\t\tresult = true;\n\telse\n\t\tresult = dm_helpers_dp_write_dsc_enable(dc->ctx, stream, enable);\n\treturn result;\n}\n\n/* The stream with these settings can be sent (unblanked) only after DSC was enabled on RX first,\n * i.e. after dp_enable_dsc_on_rx() had been called\n */\nvoid link_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\tDC_LOGGER_INIT(dsc->ctx->logger);\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\topp_cnt++;\n\n\tif (enable) {\n\t\tstruct dsc_config dsc_cfg;\n\t\tstruct dsc_optc_config dsc_optc_cfg;\n\t\tenum optc_dsc_mode optc_dsc_mode;\n\n\t\t/* Enable DSC hw block */\n\t\tdsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right) / opp_cnt;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\t\tASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % opp_cnt == 0);\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;\n\n\t\tdsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\tdsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\t\tstruct display_stream_compressor *odm_dsc = odm_pipe->stream_res.dsc;\n\n\t\t\todm_dsc->funcs->dsc_set_config(odm_dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\t\todm_dsc->funcs->dsc_enable(odm_dsc, odm_pipe->stream_res.opp->inst);\n\t\t}\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h *= opp_cnt;\n\t\tdsc_cfg.pic_width *= opp_cnt;\n\n\t\toptc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;\n\n\t\t/* Enable DSC in encoder */\n\t\tif (dc_is_dp_signal(stream->signal) && !dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t\tDC_LOG_DSC(\"Setting stream encoder DSC config for engine %d:\", (int)pipe_ctx->stream_res.stream_enc->id);\n\t\t\tdsc_optc_config_log(dsc, &dsc_optc_cfg);\n\t\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,\n\t\t\t\t\t\t\t\t\toptc_dsc_mode,\n\t\t\t\t\t\t\t\t\tdsc_optc_cfg.bytes_per_pixel,\n\t\t\t\t\t\t\t\t\tdsc_optc_cfg.slice_width);\n\n\t\t\t/* PPS SDP is set elsewhere because it has to be done after DIG FE is connected to DIG BE */\n\t\t}\n\n\t\t/* Enable DSC in OPTC */\n\t\tDC_LOG_DSC(\"Setting optc DSC config for tg instance %d:\", pipe_ctx->stream_res.tg->inst);\n\t\tdsc_optc_config_log(dsc, &dsc_optc_cfg);\n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,\n\t\t\t\t\t\t\toptc_dsc_mode,\n\t\t\t\t\t\t\tdsc_optc_cfg.bytes_per_pixel,\n\t\t\t\t\t\t\tdsc_optc_cfg.slice_width);\n\t} else {\n\t\t/* disable DSC in OPTC */\n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\tOPTC_DSC_DISABLED, 0, 0);\n\n\t\t/* disable DSC in stream encoder */\n\t\tif (dc_is_dp_signal(stream->signal)) {\n\t\t\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\telse {\n\t\t\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(\n\t\t\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t\t\tOPTC_DSC_DISABLED, 0, 0);\n\t\t\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\t\tpipe_ctx->stream_res.stream_enc, false, NULL, true);\n\t\t\t}\n\t\t}\n\n\t\t/* disable DSC block */\n\t\tpipe_ctx->stream_res.dsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\t\todm_pipe->stream_res.dsc->funcs->dsc_disable(odm_pipe->stream_res.dsc);\n\t}\n}\n\n/*\n * For dynamic bpp change case, dsc is programmed with MASTER_UPDATE_LOCK enabled;\n * hence PPS info packet update need to use frame update instead of immediate update.\n * Added parameter immediate_update for this purpose.\n * The decision to use frame update is hard-coded in function dp_update_dsc_config(),\n * which is the only place where a \"false\" would be passed in for param immediate_update.\n *\n * immediate_update is only applicable when DSC is enabled.\n */\nbool link_set_dsc_pps_packet(struct pipe_ctx *pipe_ctx, bool enable, bool immediate_update)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tDC_LOGGER_INIT(dsc->ctx->logger);\n\n\tif (!pipe_ctx->stream->timing.flags.DSC || !dsc)\n\t\treturn false;\n\n\tif (enable) {\n\t\tstruct dsc_config dsc_cfg;\n\t\tuint8_t dsc_packed_pps[128];\n\n\t\tmemset(&dsc_cfg, 0, sizeof(dsc_cfg));\n\t\tmemset(dsc_packed_pps, 0, 128);\n\n\t\t/* Enable DSC hw block */\n\t\tdsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\n\t\tdsc->funcs->dsc_get_packed_pps(dsc, &dsc_cfg, &dsc_packed_pps[0]);\n\t\tmemcpy(&stream->dsc_packed_pps[0], &dsc_packed_pps[0], sizeof(stream->dsc_packed_pps));\n\t\tif (dc_is_dp_signal(stream->signal)) {\n\t\t\tDC_LOG_DSC(\"Setting stream encoder DSC PPS SDP for engine %d\\n\", (int)pipe_ctx->stream_res.stream_enc->id);\n\t\t\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t&dsc_packed_pps[0],\n\t\t\t\t\t\t\t\t\t\timmediate_update);\n\t\t\telse\n\t\t\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t&dsc_packed_pps[0],\n\t\t\t\t\t\timmediate_update);\n\t\t}\n\t} else {\n\t\t/* disable DSC PPS in stream encoder */\n\t\tmemset(&stream->dsc_packed_pps[0], 0, sizeof(stream->dsc_packed_pps));\n\t\tif (dc_is_dp_signal(stream->signal)) {\n\t\t\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\telse\n\t\t\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(\n\t\t\t\t\t\tpipe_ctx->stream_res.stream_enc, false, NULL, true);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool link_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\tbool result = false;\n\n\tif (!pipe_ctx->stream->timing.flags.DSC)\n\t\tgoto out;\n\tif (!dsc)\n\t\tgoto out;\n\n\tif (enable) {\n\t\t{\n\t\t\tlink_set_dsc_on_stream(pipe_ctx, true);\n\t\t\tresult = true;\n\t\t}\n\t} else {\n\t\tdp_set_dsc_on_rx(pipe_ctx, false);\n\t\tlink_set_dsc_on_stream(pipe_ctx, false);\n\t\tresult = true;\n\t}\nout:\n\treturn result;\n}\n\nbool link_update_dsc_config(struct pipe_ctx *pipe_ctx)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\n\tif (!pipe_ctx->stream->timing.flags.DSC)\n\t\treturn false;\n\tif (!dsc)\n\t\treturn false;\n\n\tlink_set_dsc_on_stream(pipe_ctx, true);\n\tlink_set_dsc_pps_packet(pipe_ctx, true, false);\n\treturn true;\n}\n\nstatic void enable_stream_features(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\n\tif (pipe_ctx->stream->signal != SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\tstruct dc_link *link = stream->link;\n\t\tunion down_spread_ctrl old_downspread;\n\t\tunion down_spread_ctrl new_downspread;\n\n\t\tmemset(&old_downspread, 0, sizeof(old_downspread));\n\n\t\tcore_link_read_dpcd(link, DP_DOWNSPREAD_CTRL,\n\t\t\t\t&old_downspread.raw, sizeof(old_downspread));\n\n\t\tnew_downspread.raw = old_downspread.raw;\n\n\t\tnew_downspread.bits.IGNORE_MSA_TIMING_PARAM =\n\t\t\t\t(stream->ignore_msa_timing_param) ? 1 : 0;\n\n\t\tif (new_downspread.raw != old_downspread.raw) {\n\t\t\tcore_link_write_dpcd(link, DP_DOWNSPREAD_CTRL,\n\t\t\t\t&new_downspread.raw, sizeof(new_downspread));\n\t\t}\n\n\t} else {\n\t\tdm_helpers_mst_enable_stream_features(stream);\n\t}\n}\n\nstatic void log_vcp_x_y(const struct dc_link *link, struct fixed31_32 avg_time_slots_per_mtp)\n{\n\tconst uint32_t VCP_Y_PRECISION = 1000;\n\tuint64_t vcp_x, vcp_y;\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t// Add 0.5*(1/VCP_Y_PRECISION) to round up to decimal precision\n\tavg_time_slots_per_mtp = dc_fixpt_add(\n\t\t\tavg_time_slots_per_mtp,\n\t\t\tdc_fixpt_from_fraction(\n\t\t\t\t1,\n\t\t\t\t2*VCP_Y_PRECISION));\n\n\tvcp_x = dc_fixpt_floor(\n\t\t\tavg_time_slots_per_mtp);\n\tvcp_y = dc_fixpt_floor(\n\t\t\tdc_fixpt_mul_int(\n\t\t\t\tdc_fixpt_sub_int(\n\t\t\t\t\tavg_time_slots_per_mtp,\n\t\t\t\t\tdc_fixpt_floor(\n\t\t\t\t\t\t\tavg_time_slots_per_mtp)),\n\t\t\t\tVCP_Y_PRECISION));\n\n\n\tif (link->type == dc_connection_mst_branch)\n\t\tDC_LOG_DP2(\"MST Update Payload: set_throttled_vcp_size slot X.Y for MST stream \"\n\t\t\t\t\"X: %llu \"\n\t\t\t\t\"Y: %llu/%d\",\n\t\t\t\tvcp_x,\n\t\t\t\tvcp_y,\n\t\t\t\tVCP_Y_PRECISION);\n\telse\n\t\tDC_LOG_DP2(\"SST Update Payload: set_throttled_vcp_size slot X.Y for SST stream \"\n\t\t\t\t\"X: %llu \"\n\t\t\t\t\"Y: %llu/%d\",\n\t\t\t\tvcp_x,\n\t\t\t\tvcp_y,\n\t\t\t\tVCP_Y_PRECISION);\n}\n\nstatic struct fixed31_32 get_pbn_per_slot(struct dc_stream_state *stream)\n{\n\tstruct fixed31_32 mbytes_per_sec;\n\tuint32_t link_rate_in_mbytes_per_sec = dp_link_bandwidth_kbps(stream->link,\n\t\t\t&stream->link->cur_link_settings);\n\tlink_rate_in_mbytes_per_sec /= 8000; /* Kbits to MBytes */\n\n\tmbytes_per_sec = dc_fixpt_from_int(link_rate_in_mbytes_per_sec);\n\n\treturn dc_fixpt_div_int(mbytes_per_sec, 54);\n}\n\nstatic struct fixed31_32 get_pbn_from_bw_in_kbps(uint64_t kbps)\n{\n\tstruct fixed31_32 peak_kbps;\n\tuint32_t numerator = 0;\n\tuint32_t denominator = 1;\n\n\t/*\n\t * margin 5300ppm + 300ppm ~ 0.6% as per spec, factor is 1.006\n\t * The unit of 54/64Mbytes/sec is an arbitrary unit chosen based on\n\t * common multiplier to render an integer PBN for all link rate/lane\n\t * counts combinations\n\t * calculate\n\t * peak_kbps *= (1006/1000)\n\t * peak_kbps *= (64/54)\n\t * peak_kbps *= 8    convert to bytes\n\t */\n\n\tnumerator = 64 * PEAK_FACTOR_X1000;\n\tdenominator = 54 * 8 * 1000 * 1000;\n\tkbps *= numerator;\n\tpeak_kbps = dc_fixpt_from_fraction(kbps, denominator);\n\n\treturn peak_kbps;\n}\n\nstatic struct fixed31_32 get_pbn_from_timing(struct pipe_ctx *pipe_ctx)\n{\n\tuint64_t kbps;\n\tenum dc_link_encoding_format link_encoding;\n\n\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\tlink_encoding = DC_LINK_ENCODING_DP_128b_132b;\n\telse\n\t\tlink_encoding = DC_LINK_ENCODING_DP_8b_10b;\n\n\tkbps = dc_bandwidth_in_kbps_from_timing(&pipe_ctx->stream->timing, link_encoding);\n\treturn get_pbn_from_bw_in_kbps(kbps);\n}\n\n\n// TODO - DP2.0 Link: Fix get_lane_status to handle LTTPR offset (SST and MST)\nstatic void get_lane_status(\n\tstruct dc_link *link,\n\tuint32_t lane_count,\n\tunion lane_status *status,\n\tunion lane_align_status_updated *status_updated)\n{\n\tunsigned int lane;\n\tuint8_t dpcd_buf[3] = {0};\n\n\tif (status == NULL || status_updated == NULL) {\n\t\treturn;\n\t}\n\n\tcore_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_LANE0_1_STATUS,\n\t\t\tdpcd_buf,\n\t\t\tsizeof(dpcd_buf));\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tstatus[lane].raw = dp_get_nibble_at_index(&dpcd_buf[0], lane);\n\t}\n\n\tstatus_updated->raw = dpcd_buf[2];\n}\n\nstatic bool poll_for_allocation_change_trigger(struct dc_link *link)\n{\n\t/*\n\t * wait for ACT handled\n\t */\n\tint i;\n\tconst int act_retries = 30;\n\tenum act_return_status result = ACT_FAILED;\n\tunion payload_table_update_status update_status = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX];\n\tunion lane_align_status_updated lane_status_updated;\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tif (link->aux_access_disabled)\n\t\treturn true;\n\tfor (i = 0; i < act_retries; i++) {\n\t\tget_lane_status(link, link->cur_link_settings.lane_count, dpcd_lane_status, &lane_status_updated);\n\n\t\tif (!dp_is_cr_done(link->cur_link_settings.lane_count, dpcd_lane_status) ||\n\t\t\t\t!dp_is_ch_eq_done(link->cur_link_settings.lane_count, dpcd_lane_status) ||\n\t\t\t\t!dp_is_symbol_locked(link->cur_link_settings.lane_count, dpcd_lane_status) ||\n\t\t\t\t!dp_is_interlane_aligned(lane_status_updated)) {\n\t\t\tDC_LOG_ERROR(\"SST Update Payload: Link loss occurred while \"\n\t\t\t\t\t\"polling for ACT handled.\");\n\t\t\tresult = ACT_LINK_LOST;\n\t\t\tbreak;\n\t\t}\n\t\tcore_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_PAYLOAD_TABLE_UPDATE_STATUS,\n\t\t\t\t&update_status.raw,\n\t\t\t\t1);\n\n\t\tif (update_status.bits.ACT_HANDLED == 1) {\n\t\t\tDC_LOG_DP2(\"SST Update Payload: ACT handled by downstream.\");\n\t\t\tresult = ACT_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tfsleep(5000);\n\t}\n\n\tif (result == ACT_FAILED) {\n\t\tDC_LOG_ERROR(\"SST Update Payload: ACT still not handled after retries, \"\n\t\t\t\t\"continue on. Something is wrong with the branch.\");\n\t}\n\n\treturn (result == ACT_SUCCESS);\n}\n\nstatic void update_mst_stream_alloc_table(\n\tstruct dc_link *link,\n\tstruct stream_encoder *stream_enc,\n\tstruct hpo_dp_stream_encoder *hpo_dp_stream_enc, // TODO: Rename stream_enc to dio_stream_enc?\n\tconst struct dc_dp_mst_stream_allocation_table *proposed_table)\n{\n\tstruct link_mst_stream_allocation work_table[MAX_CONTROLLER_NUM] = { 0 };\n\tstruct link_mst_stream_allocation *dc_alloc;\n\n\tint i;\n\tint j;\n\n\t/* if DRM proposed_table has more than one new payload */\n\tASSERT(proposed_table->stream_count -\n\t\t\tlink->mst_stream_alloc_table.stream_count < 2);\n\n\t/* copy proposed_table to link, add stream encoder */\n\tfor (i = 0; i < proposed_table->stream_count; i++) {\n\n\t\tfor (j = 0; j < link->mst_stream_alloc_table.stream_count; j++) {\n\t\t\tdc_alloc =\n\t\t\t&link->mst_stream_alloc_table.stream_allocations[j];\n\n\t\t\tif (dc_alloc->vcp_id ==\n\t\t\t\tproposed_table->stream_allocations[i].vcp_id) {\n\n\t\t\t\twork_table[i] = *dc_alloc;\n\t\t\t\twork_table[i].slot_count = proposed_table->stream_allocations[i].slot_count;\n\t\t\t\tbreak; /* exit j loop */\n\t\t\t}\n\t\t}\n\n\t\t/* new vcp_id */\n\t\tif (j == link->mst_stream_alloc_table.stream_count) {\n\t\t\twork_table[i].vcp_id =\n\t\t\t\tproposed_table->stream_allocations[i].vcp_id;\n\t\t\twork_table[i].slot_count =\n\t\t\t\tproposed_table->stream_allocations[i].slot_count;\n\t\t\twork_table[i].stream_enc = stream_enc;\n\t\t\twork_table[i].hpo_dp_stream_enc = hpo_dp_stream_enc;\n\t\t}\n\t}\n\n\t/* update link->mst_stream_alloc_table with work_table */\n\tlink->mst_stream_alloc_table.stream_count =\n\t\t\tproposed_table->stream_count;\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++)\n\t\tlink->mst_stream_alloc_table.stream_allocations[i] =\n\t\t\t\twork_table[i];\n}\n\nstatic void remove_stream_from_alloc_table(\n\t\tstruct dc_link *link,\n\t\tstruct stream_encoder *dio_stream_enc,\n\t\tstruct hpo_dp_stream_encoder *hpo_dp_stream_enc)\n{\n\tint i = 0;\n\tstruct link_mst_stream_allocation_table *table =\n\t\t\t&link->mst_stream_alloc_table;\n\n\tif (hpo_dp_stream_enc) {\n\t\tfor (; i < table->stream_count; i++)\n\t\t\tif (hpo_dp_stream_enc == table->stream_allocations[i].hpo_dp_stream_enc)\n\t\t\t\tbreak;\n\t} else {\n\t\tfor (; i < table->stream_count; i++)\n\t\t\tif (dio_stream_enc == table->stream_allocations[i].stream_enc)\n\t\t\t\tbreak;\n\t}\n\n\tif (i < table->stream_count) {\n\t\ti++;\n\t\tfor (; i < table->stream_count; i++)\n\t\t\ttable->stream_allocations[i-1] = table->stream_allocations[i];\n\t\tmemset(&table->stream_allocations[table->stream_count-1], 0,\n\t\t\t\tsizeof(struct link_mst_stream_allocation));\n\t\ttable->stream_count--;\n\t}\n}\n\nstatic enum dc_status deallocate_mst_payload_with_temp_drm_wa(\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc_dp_mst_stream_allocation_table proposed_table = {0};\n\tstruct fixed31_32 avg_time_slots_per_mtp = dc_fixpt_from_int(0);\n\tint i;\n\tbool mst_mode = (link->type == dc_connection_mst_branch);\n\t/* adjust for drm changes*/\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tconst struct dc_link_settings empty_link_settings = {0};\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx, avg_time_slots_per_mtp);\n\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t&empty_link_settings,\n\t\t\t\tavg_time_slots_per_mtp);\n\n\tif (dm_helpers_dp_mst_write_payload_allocation_table(\n\t\t\tstream->ctx,\n\t\t\tstream,\n\t\t\t&proposed_table,\n\t\t\tfalse))\n\t\tupdate_mst_stream_alloc_table(\n\t\t\t\tlink,\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t&proposed_table);\n\telse\n\t\tDC_LOG_WARNING(\"Failed to update\"\n\t\t\t\t\"MST allocation table for\"\n\t\t\t\t\"pipe idx:%d\\n\",\n\t\t\t\tpipe_ctx->pipe_idx);\n\n\tDC_LOG_MST(\"%s\"\n\t\t\t\"stream_count: %d: \",\n\t\t\t__func__,\n\t\t\tlink->mst_stream_alloc_table.stream_count);\n\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tDC_LOG_MST(\"stream_enc[%d]: %p      \"\n\t\t\"stream[%d].hpo_dp_stream_enc: %p      \"\n\t\t\"stream[%d].vcp_id: %d      \"\n\t\t\"stream[%d].slot_count: %d\\n\",\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].stream_enc,\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].hpo_dp_stream_enc,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].vcp_id,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].slot_count);\n\t}\n\n\tif (link_hwss->ext.update_stream_allocation_table == NULL ||\n\t\t\tlink_dp_get_encoding_format(&link->cur_link_settings) == DP_UNKNOWN_ENCODING) {\n\t\tDC_LOG_DEBUG(\"Unknown encoding format\\n\");\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tlink_hwss->ext.update_stream_allocation_table(link, &pipe_ctx->link_res,\n\t\t\t&link->mst_stream_alloc_table);\n\n\tif (mst_mode) {\n\t\tdm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\t\tstream->ctx,\n\t\t\tstream);\n\t}\n\n\tdm_helpers_dp_mst_send_payload_allocation(\n\t\t\tstream->ctx,\n\t\t\tstream,\n\t\t\tfalse);\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc_dp_mst_stream_allocation_table proposed_table = {0};\n\tstruct fixed31_32 avg_time_slots_per_mtp = dc_fixpt_from_int(0);\n\tint i;\n\tbool mst_mode = (link->type == dc_connection_mst_branch);\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tconst struct dc_link_settings empty_link_settings = {0};\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tif (link->dc->debug.temp_mst_deallocation_sequence)\n\t\treturn deallocate_mst_payload_with_temp_drm_wa(pipe_ctx);\n\n\t/* deallocate_mst_payload is called before disable link. When mode or\n\t * disable/enable monitor, new stream is created which is not in link\n\t * stream[] yet. For this, payload is not allocated yet, so de-alloc\n\t * should not done. For new mode set, map_resources will get engine\n\t * for new stream, so stream_enc->id should be validated until here.\n\t */\n\n\t/* slot X.Y */\n\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx, avg_time_slots_per_mtp);\n\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t&empty_link_settings,\n\t\t\t\tavg_time_slots_per_mtp);\n\n\tif (mst_mode) {\n\t\t/* when link is in mst mode, reply on mst manager to remove\n\t\t * payload\n\t\t */\n\t\tif (dm_helpers_dp_mst_write_payload_allocation_table(\n\t\t\t\tstream->ctx,\n\t\t\t\tstream,\n\t\t\t\t&proposed_table,\n\t\t\t\tfalse))\n\t\t\tupdate_mst_stream_alloc_table(\n\t\t\t\t\tlink,\n\t\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\t&proposed_table);\n\t\telse\n\t\t\tDC_LOG_WARNING(\"Failed to update\"\n\t\t\t\t\t\"MST allocation table for\"\n\t\t\t\t\t\"pipe idx:%d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx);\n\t} else {\n\t\t/* when link is no longer in mst mode (mst hub unplugged),\n\t\t * remove payload with default dc logic\n\t\t */\n\t\tremove_stream_from_alloc_table(link, pipe_ctx->stream_res.stream_enc,\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc);\n\t}\n\n\tDC_LOG_MST(\"%s\"\n\t\t\t\"stream_count: %d: \",\n\t\t\t__func__,\n\t\t\tlink->mst_stream_alloc_table.stream_count);\n\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tDC_LOG_MST(\"stream_enc[%d]: %p      \"\n\t\t\"stream[%d].hpo_dp_stream_enc: %p      \"\n\t\t\"stream[%d].vcp_id: %d      \"\n\t\t\"stream[%d].slot_count: %d\\n\",\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].stream_enc,\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].hpo_dp_stream_enc,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].vcp_id,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].slot_count);\n\t}\n\n\t/* update mst stream allocation table hardware state */\n\tif (link_hwss->ext.update_stream_allocation_table == NULL ||\n\t\t\tlink_dp_get_encoding_format(&link->cur_link_settings) == DP_UNKNOWN_ENCODING) {\n\t\tDC_LOG_DEBUG(\"Unknown encoding format\\n\");\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tlink_hwss->ext.update_stream_allocation_table(link, &pipe_ctx->link_res,\n\t\t\t&link->mst_stream_alloc_table);\n\n\tif (mst_mode) {\n\t\tdm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\t\tstream->ctx,\n\t\t\tstream);\n\n\t\tdm_helpers_dp_mst_send_payload_allocation(\n\t\t\t\tstream->ctx,\n\t\t\t\tstream,\n\t\t\t\tfalse);\n\t}\n\n\treturn DC_OK;\n}\n\n/* convert link_mst_stream_alloc_table to dm dp_mst_stream_alloc_table\n * because stream_encoder is not exposed to dm\n */\nstatic enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc_dp_mst_stream_allocation_table proposed_table = {0};\n\tstruct fixed31_32 avg_time_slots_per_mtp;\n\tstruct fixed31_32 pbn;\n\tstruct fixed31_32 pbn_per_slot;\n\tint i;\n\tenum act_return_status ret;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t/* enable_link_dp_mst already check link->enabled_stream_count\n\t * and stream is in link->stream[]. This is called during set mode,\n\t * stream_enc is available.\n\t */\n\n\t/* get calculate VC payload for stream: stream_alloc */\n\tif (dm_helpers_dp_mst_write_payload_allocation_table(\n\t\tstream->ctx,\n\t\tstream,\n\t\t&proposed_table,\n\t\ttrue))\n\t\tupdate_mst_stream_alloc_table(\n\t\t\t\t\tlink,\n\t\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\t&proposed_table);\n\telse\n\t\tDC_LOG_WARNING(\"Failed to update\"\n\t\t\t\t\"MST allocation table for\"\n\t\t\t\t\"pipe idx:%d\\n\",\n\t\t\t\tpipe_ctx->pipe_idx);\n\n\tDC_LOG_MST(\"%s  \"\n\t\t\t\"stream_count: %d: \\n \",\n\t\t\t__func__,\n\t\t\tlink->mst_stream_alloc_table.stream_count);\n\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tDC_LOG_MST(\"stream_enc[%d]: %p      \"\n\t\t\"stream[%d].hpo_dp_stream_enc: %p      \"\n\t\t\"stream[%d].vcp_id: %d      \"\n\t\t\"stream[%d].slot_count: %d\\n\",\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].stream_enc,\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].hpo_dp_stream_enc,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].vcp_id,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].slot_count);\n\t}\n\n\tASSERT(proposed_table.stream_count > 0);\n\n\t/* program DP source TX for payload */\n\tif (link_hwss->ext.update_stream_allocation_table == NULL ||\n\t\t\tlink_dp_get_encoding_format(&link->cur_link_settings) == DP_UNKNOWN_ENCODING) {\n\t\tDC_LOG_ERROR(\"Failure: unknown encoding format\\n\");\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tlink_hwss->ext.update_stream_allocation_table(link,\n\t\t\t&pipe_ctx->link_res,\n\t\t\t&link->mst_stream_alloc_table);\n\n\t/* send down message */\n\tret = dm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\t\tstream->ctx,\n\t\t\tstream);\n\n\tif (ret != ACT_LINK_LOST) {\n\t\tdm_helpers_dp_mst_send_payload_allocation(\n\t\t\t\tstream->ctx,\n\t\t\t\tstream,\n\t\t\t\ttrue);\n\t}\n\n\t/* slot X.Y for only current stream */\n\tpbn_per_slot = get_pbn_per_slot(stream);\n\tif (pbn_per_slot.value == 0) {\n\t\tDC_LOG_ERROR(\"Failure: pbn_per_slot==0 not allowed. Cannot continue, returning DC_UNSUPPORTED_VALUE.\\n\");\n\t\treturn DC_UNSUPPORTED_VALUE;\n\t}\n\tpbn = get_pbn_from_timing(pipe_ctx);\n\tavg_time_slots_per_mtp = dc_fixpt_div(pbn, pbn_per_slot);\n\n\tlog_vcp_x_y(link, avg_time_slots_per_mtp);\n\n\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx, avg_time_slots_per_mtp);\n\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t&link->cur_link_settings,\n\t\t\t\tavg_time_slots_per_mtp);\n\n\treturn DC_OK;\n}\n\nstruct fixed31_32 link_calculate_sst_avg_time_slots_per_mtp(\n\t\tconst struct dc_stream_state *stream,\n\t\tconst struct dc_link *link)\n{\n\tstruct fixed31_32 link_bw_effective =\n\t\t\tdc_fixpt_from_int(\n\t\t\t\t\tdp_link_bandwidth_kbps(link, &link->cur_link_settings));\n\tstruct fixed31_32 timeslot_bw_effective =\n\t\t\tdc_fixpt_div_int(link_bw_effective, MAX_MTP_SLOT_COUNT);\n\tstruct fixed31_32 timing_bw =\n\t\t\tdc_fixpt_from_int(\n\t\t\t\t\tdc_bandwidth_in_kbps_from_timing(&stream->timing,\n\t\t\t\t\t\t\tdc_link_get_highest_encoding_format(link)));\n\tstruct fixed31_32 avg_time_slots_per_mtp =\n\t\t\tdc_fixpt_div(timing_bw, timeslot_bw_effective);\n\n\treturn avg_time_slots_per_mtp;\n}\n\n\nstatic bool write_128b_132b_sst_payload_allocation_table(\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct dc_link *link,\n\t\tstruct link_mst_stream_allocation_table *proposed_table,\n\t\tbool allocate)\n{\n\tconst uint8_t vc_id = 1; /// VC ID always 1 for SST\n\tconst uint8_t start_time_slot = 0; /// Always start at time slot 0 for SST\n\tbool result = false;\n\tuint8_t req_slot_count = 0;\n\tstruct fixed31_32 avg_time_slots_per_mtp = { 0 };\n\tunion payload_table_update_status update_status = { 0 };\n\tconst uint32_t max_retries = 30;\n\tuint32_t retries = 0;\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tif (allocate)\t{\n\t\tavg_time_slots_per_mtp = link_calculate_sst_avg_time_slots_per_mtp(stream, link);\n\t\treq_slot_count = dc_fixpt_ceil(avg_time_slots_per_mtp);\n\t\t/// Validation should filter out modes that exceed link BW\n\t\tASSERT(req_slot_count <= MAX_MTP_SLOT_COUNT);\n\t\tif (req_slot_count > MAX_MTP_SLOT_COUNT)\n\t\t\treturn false;\n\t} else {\n\t\t/// Leave req_slot_count = 0 if allocate is false.\n\t}\n\n\tproposed_table->stream_count = 1; /// Always 1 stream for SST\n\tproposed_table->stream_allocations[0].slot_count = req_slot_count;\n\tproposed_table->stream_allocations[0].vcp_id = vc_id;\n\n\tif (link->aux_access_disabled)\n\t\treturn true;\n\n\t/// Write DPCD 2C0 = 1 to start updating\n\tupdate_status.bits.VC_PAYLOAD_TABLE_UPDATED = 1;\n\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_PAYLOAD_TABLE_UPDATE_STATUS,\n\t\t\t&update_status.raw,\n\t\t\t1);\n\n\t/// Program the changes in DPCD 1C0 - 1C2\n\tASSERT(vc_id == 1);\n\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_PAYLOAD_ALLOCATE_SET,\n\t\t\t&vc_id,\n\t\t\t1);\n\n\tASSERT(start_time_slot == 0);\n\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_PAYLOAD_ALLOCATE_START_TIME_SLOT,\n\t\t\t&start_time_slot,\n\t\t\t1);\n\n\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_PAYLOAD_ALLOCATE_TIME_SLOT_COUNT,\n\t\t\t&req_slot_count,\n\t\t\t1);\n\n\t/// Poll till DPCD 2C0 read 1\n\t/// Try for at least 150ms (30 retries, with 5ms delay after each attempt)\n\n\twhile (retries < max_retries) {\n\t\tif (core_link_read_dpcd(\n\t\t\t\tlink,\n\t\t\t\tDP_PAYLOAD_TABLE_UPDATE_STATUS,\n\t\t\t\t&update_status.raw,\n\t\t\t\t1) == DC_OK) {\n\t\t\tif (update_status.bits.VC_PAYLOAD_TABLE_UPDATED == 1) {\n\t\t\t\tDC_LOG_DP2(\"SST Update Payload: downstream payload table updated.\");\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tunion dpcd_rev dpcdRev;\n\n\t\t\tif (core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_DPCD_REV,\n\t\t\t\t\t&dpcdRev.raw,\n\t\t\t\t\t1) != DC_OK) {\n\t\t\t\tDC_LOG_ERROR(\"SST Update Payload: Unable to read DPCD revision \"\n\t\t\t\t\t\t\"of sink while polling payload table \"\n\t\t\t\t\t\t\"updated status bit.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tretries++;\n\t\tfsleep(5000);\n\t}\n\n\tif (!result && retries == max_retries) {\n\t\tDC_LOG_ERROR(\"SST Update Payload: Payload table not updated after retries, \"\n\t\t\t\t\"continue on. Something is wrong with the branch.\");\n\t\t// TODO - DP2.0 Payload: Read and log the payload table from downstream branch\n\t}\n\n\treturn result;\n}\n\n/*\n * Payload allocation/deallocation for SST introduced in DP2.0\n */\nstatic enum dc_status update_sst_payload(struct pipe_ctx *pipe_ctx,\n\t\t\t\t\t\t bool allocate)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct link_mst_stream_allocation_table proposed_table = {0};\n\tstruct fixed31_32 avg_time_slots_per_mtp;\n\tconst struct dc_link_settings empty_link_settings = {0};\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t/* slot X.Y for SST payload deallocate */\n\tif (!allocate) {\n\t\tavg_time_slots_per_mtp = dc_fixpt_from_int(0);\n\n\t\tlog_vcp_x_y(link, avg_time_slots_per_mtp);\n\n\t\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx,\n\t\t\t\t\tavg_time_slots_per_mtp);\n\t\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t\t&empty_link_settings,\n\t\t\t\t\tavg_time_slots_per_mtp);\n\t}\n\n\t/* calculate VC payload and update branch with new payload allocation table*/\n\tif (!write_128b_132b_sst_payload_allocation_table(\n\t\t\tstream,\n\t\t\tlink,\n\t\t\t&proposed_table,\n\t\t\tallocate)) {\n\t\tDC_LOG_ERROR(\"SST Update Payload: Failed to update \"\n\t\t\t\t\t\t\"allocation table for \"\n\t\t\t\t\t\t\"pipe idx: %d\\n\",\n\t\t\t\t\t\tpipe_ctx->pipe_idx);\n\t\treturn DC_FAIL_DP_PAYLOAD_ALLOCATION;\n\t}\n\n\tproposed_table.stream_allocations[0].hpo_dp_stream_enc = pipe_ctx->stream_res.hpo_dp_stream_enc;\n\n\tASSERT(proposed_table.stream_count == 1);\n\n\t//TODO - DP2.0 Logging: Instead of hpo_dp_stream_enc pointer, log instance id\n\tDC_LOG_DP2(\"SST Update Payload: hpo_dp_stream_enc: %p      \"\n\t\t\"vcp_id: %d      \"\n\t\t\"slot_count: %d\\n\",\n\t\t(void *) proposed_table.stream_allocations[0].hpo_dp_stream_enc,\n\t\tproposed_table.stream_allocations[0].vcp_id,\n\t\tproposed_table.stream_allocations[0].slot_count);\n\n\t/* program DP source TX for payload */\n\tlink_hwss->ext.update_stream_allocation_table(link, &pipe_ctx->link_res,\n\t\t\t&proposed_table);\n\n\t/* poll for ACT handled */\n\tif (!poll_for_allocation_change_trigger(link)) {\n\t\t// Failures will result in blackscreen and errors logged\n\t\tBREAK_TO_DEBUGGER();\n\t}\n\n\t/* slot X.Y for SST payload allocate */\n\tif (allocate && link_dp_get_encoding_format(&link->cur_link_settings) ==\n\t\t\tDP_128b_132b_ENCODING) {\n\t\tavg_time_slots_per_mtp = link_calculate_sst_avg_time_slots_per_mtp(stream, link);\n\n\t\tlog_vcp_x_y(link, avg_time_slots_per_mtp);\n\n\t\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx,\n\t\t\t\t\tavg_time_slots_per_mtp);\n\t\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t\t&link->cur_link_settings,\n\t\t\t\t\tavg_time_slots_per_mtp);\n\t}\n\n\t/* Always return DC_OK.\n\t * If part of sequence fails, log failure(s) and show blackscreen\n\t */\n\treturn DC_OK;\n}\n\nenum dc_status link_reduce_mst_payload(struct pipe_ctx *pipe_ctx, uint32_t bw_in_kbps)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct fixed31_32 avg_time_slots_per_mtp;\n\tstruct fixed31_32 pbn;\n\tstruct fixed31_32 pbn_per_slot;\n\tstruct dc_dp_mst_stream_allocation_table proposed_table = {0};\n\tuint8_t i;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t/* decrease throttled vcp size */\n\tpbn_per_slot = get_pbn_per_slot(stream);\n\tpbn = get_pbn_from_bw_in_kbps(bw_in_kbps);\n\tavg_time_slots_per_mtp = dc_fixpt_div(pbn, pbn_per_slot);\n\n\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx, avg_time_slots_per_mtp);\n\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t&link->cur_link_settings,\n\t\t\t\tavg_time_slots_per_mtp);\n\n\t/* send ALLOCATE_PAYLOAD sideband message with updated pbn */\n\tdm_helpers_dp_mst_send_payload_allocation(\n\t\t\tstream->ctx,\n\t\t\tstream,\n\t\t\ttrue);\n\n\t/* notify immediate branch device table update */\n\tif (dm_helpers_dp_mst_write_payload_allocation_table(\n\t\t\tstream->ctx,\n\t\t\tstream,\n\t\t\t&proposed_table,\n\t\t\ttrue)) {\n\t\t/* update mst stream allocation table software state */\n\t\tupdate_mst_stream_alloc_table(\n\t\t\t\tlink,\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t&proposed_table);\n\t} else {\n\t\tDC_LOG_WARNING(\"Failed to update\"\n\t\t\t\t\"MST allocation table for\"\n\t\t\t\t\"pipe idx:%d\\n\",\n\t\t\t\tpipe_ctx->pipe_idx);\n\t}\n\n\tDC_LOG_MST(\"%s  \"\n\t\t\t\"stream_count: %d: \\n \",\n\t\t\t__func__,\n\t\t\tlink->mst_stream_alloc_table.stream_count);\n\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tDC_LOG_MST(\"stream_enc[%d]: %p      \"\n\t\t\"stream[%d].hpo_dp_stream_enc: %p      \"\n\t\t\"stream[%d].vcp_id: %d      \"\n\t\t\"stream[%d].slot_count: %d\\n\",\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].stream_enc,\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].hpo_dp_stream_enc,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].vcp_id,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].slot_count);\n\t}\n\n\tASSERT(proposed_table.stream_count > 0);\n\n\t/* update mst stream allocation table hardware state */\n\tif (link_hwss->ext.update_stream_allocation_table == NULL ||\n\t\t\tlink_dp_get_encoding_format(&link->cur_link_settings) == DP_UNKNOWN_ENCODING) {\n\t\tDC_LOG_ERROR(\"Failure: unknown encoding format\\n\");\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tlink_hwss->ext.update_stream_allocation_table(link, &pipe_ctx->link_res,\n\t\t\t&link->mst_stream_alloc_table);\n\n\t/* poll for immediate branch device ACT handled */\n\tdm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\t\tstream->ctx,\n\t\t\tstream);\n\n\treturn DC_OK;\n}\n\nenum dc_status link_increase_mst_payload(struct pipe_ctx *pipe_ctx, uint32_t bw_in_kbps)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct fixed31_32 avg_time_slots_per_mtp;\n\tstruct fixed31_32 pbn;\n\tstruct fixed31_32 pbn_per_slot;\n\tstruct dc_dp_mst_stream_allocation_table proposed_table = {0};\n\tuint8_t i;\n\tenum act_return_status ret;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t/* notify immediate branch device table update */\n\tif (dm_helpers_dp_mst_write_payload_allocation_table(\n\t\t\t\tstream->ctx,\n\t\t\t\tstream,\n\t\t\t\t&proposed_table,\n\t\t\t\ttrue)) {\n\t\t/* update mst stream allocation table software state */\n\t\tupdate_mst_stream_alloc_table(\n\t\t\t\tlink,\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t&proposed_table);\n\t}\n\n\tDC_LOG_MST(\"%s  \"\n\t\t\t\"stream_count: %d: \\n \",\n\t\t\t__func__,\n\t\t\tlink->mst_stream_alloc_table.stream_count);\n\n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tDC_LOG_MST(\"stream_enc[%d]: %p      \"\n\t\t\"stream[%d].hpo_dp_stream_enc: %p      \"\n\t\t\"stream[%d].vcp_id: %d      \"\n\t\t\"stream[%d].slot_count: %d\\n\",\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].stream_enc,\n\t\ti,\n\t\t(void *) link->mst_stream_alloc_table.stream_allocations[i].hpo_dp_stream_enc,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].vcp_id,\n\t\ti,\n\t\tlink->mst_stream_alloc_table.stream_allocations[i].slot_count);\n\t}\n\n\tASSERT(proposed_table.stream_count > 0);\n\n\t/* update mst stream allocation table hardware state */\n\tif (link_hwss->ext.update_stream_allocation_table == NULL ||\n\t\t\tlink_dp_get_encoding_format(&link->cur_link_settings) == DP_UNKNOWN_ENCODING) {\n\t\tDC_LOG_ERROR(\"Failure: unknown encoding format\\n\");\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tlink_hwss->ext.update_stream_allocation_table(link, &pipe_ctx->link_res,\n\t\t\t&link->mst_stream_alloc_table);\n\n\t/* poll for immediate branch device ACT handled */\n\tret = dm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\t\tstream->ctx,\n\t\t\tstream);\n\n\tif (ret != ACT_LINK_LOST) {\n\t\t/* send ALLOCATE_PAYLOAD sideband message with updated pbn */\n\t\tdm_helpers_dp_mst_send_payload_allocation(\n\t\t\t\tstream->ctx,\n\t\t\t\tstream,\n\t\t\t\ttrue);\n\t}\n\n\t/* increase throttled vcp size */\n\tpbn = get_pbn_from_bw_in_kbps(bw_in_kbps);\n\tpbn_per_slot = get_pbn_per_slot(stream);\n\tavg_time_slots_per_mtp = dc_fixpt_div(pbn, pbn_per_slot);\n\n\tif (link_hwss->ext.set_throttled_vcp_size)\n\t\tlink_hwss->ext.set_throttled_vcp_size(pipe_ctx, avg_time_slots_per_mtp);\n\tif (link_hwss->ext.set_hblank_min_symbol_width)\n\t\tlink_hwss->ext.set_hblank_min_symbol_width(pipe_ctx,\n\t\t\t\t&link->cur_link_settings,\n\t\t\t\tavg_time_slots_per_mtp);\n\n\treturn DC_OK;\n}\n\nstatic void disable_link_dp(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tstruct dc_link_settings link_settings = link->cur_link_settings;\n\n\tif (signal == SIGNAL_TYPE_DISPLAY_PORT_MST &&\n\t\t\tlink->mst_stream_alloc_table.stream_count > 0)\n\t\t/* disable MST link only when last vc payload is deallocated */\n\t\treturn;\n\n\tdp_disable_link_phy(link, link_res, signal);\n\n\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\tif (!link->skip_implict_edp_power_control)\n\t\t\tlink->dc->hwss.edp_power_control(link, false);\n\t}\n\n\tif (signal == SIGNAL_TYPE_DISPLAY_PORT_MST)\n\t\t/* set the sink to SST mode after disabling the link */\n\t\tenable_mst_on_sink(link, false);\n\n\tif (link_dp_get_encoding_format(&link_settings) ==\n\t\t\tDP_8b_10b_ENCODING) {\n\t\tdp_set_fec_enable(link, false);\n\t\tdp_set_fec_ready(link, link_res, false);\n\t}\n}\n\nstatic void disable_link(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tif (dc_is_dp_signal(signal)) {\n\t\tdisable_link_dp(link, link_res, signal);\n\t} else if (signal != SIGNAL_TYPE_VIRTUAL) {\n\t\tlink->dc->hwss.disable_link_output(link, link_res, signal);\n\t}\n\n\tif (signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\t/* MST disable link only when no stream use the link */\n\t\tif (link->mst_stream_alloc_table.stream_count <= 0)\n\t\t\tlink->link_status.link_active = false;\n\t} else {\n\t\tlink->link_status.link_active = false;\n\t}\n}\n\nstatic void enable_link_hdmi(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tenum dc_color_depth display_color_depth;\n\tenum engine_id eng_id;\n\tstruct ext_hdmi_settings settings = {0};\n\tbool is_over_340mhz = false;\n\tbool is_vga_mode = (stream->timing.h_addressable == 640)\n\t\t\t&& (stream->timing.v_addressable == 480);\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\n\tif (stream->phy_pix_clk == 0)\n\t\tstream->phy_pix_clk = stream->timing.pix_clk_100hz / 10;\n\tif (stream->phy_pix_clk > 340000)\n\t\tis_over_340mhz = true;\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal)) {\n\t\tunsigned short masked_chip_caps = pipe_ctx->stream->link->chip_caps &\n\t\t\t\tEXT_DISPLAY_PATH_CAPS__EXT_CHIP_MASK;\n\t\tif (masked_chip_caps == EXT_DISPLAY_PATH_CAPS__HDMI20_TISN65DP159RSBT) {\n\t\t\t/* DP159, Retimer settings */\n\t\t\teng_id = pipe_ctx->stream_res.stream_enc->id;\n\n\t\t\tif (get_ext_hdmi_settings(pipe_ctx, eng_id, &settings)) {\n\t\t\t\twrite_i2c_retimer_setting(pipe_ctx,\n\t\t\t\t\t\tis_vga_mode, is_over_340mhz, &settings);\n\t\t\t} else {\n\t\t\t\twrite_i2c_default_retimer_setting(pipe_ctx,\n\t\t\t\t\t\tis_vga_mode, is_over_340mhz);\n\t\t\t}\n\t\t} else if (masked_chip_caps == EXT_DISPLAY_PATH_CAPS__HDMI20_PI3EQX1204) {\n\t\t\t/* PI3EQX1204, Redriver settings */\n\t\t\twrite_i2c_redriver_setting(pipe_ctx, is_over_340mhz);\n\t\t}\n\t}\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal))\n\t\twrite_scdc_data(\n\t\t\tstream->link->ddc,\n\t\t\tstream->phy_pix_clk,\n\t\t\tstream->timing.flags.LTE_340MCSC_SCRAMBLE);\n\n\tmemset(&stream->link->cur_link_settings, 0,\n\t\t\tsizeof(struct dc_link_settings));\n\n\tdisplay_color_depth = stream->timing.display_color_depth;\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\tdisplay_color_depth = COLOR_DEPTH_888;\n\n\t/* We need to enable stream encoder for TMDS first to apply 1/4 TMDS\n\t * character clock in case that beyond 340MHz.\n\t */\n\tif (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal))\n\t\tlink_hwss->setup_stream_encoder(pipe_ctx);\n\n\tdc->hwss.enable_tmds_link_output(\n\t\t\tlink,\n\t\t\t&pipe_ctx->link_res,\n\t\t\tpipe_ctx->stream->signal,\n\t\t\tpipe_ctx->clock_source->id,\n\t\t\tdisplay_color_depth,\n\t\t\tstream->phy_pix_clk);\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal))\n\t\tread_scdc_data(link->ddc);\n}\n\nstatic enum dc_status enable_link_dp(struct dc_state *state,\n\t\t\t\t     struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tenum dc_status status;\n\tbool skip_video_pattern;\n\tstruct dc_link *link = stream->link;\n\tconst struct dc_link_settings *link_settings =\n\t\t\t&pipe_ctx->link_config.dp_link_settings;\n\tbool fec_enable;\n\tint i;\n\tbool apply_seamless_boot_optimization = false;\n\tuint32_t bl_oled_enable_delay = 50; // in ms\n\tuint32_t post_oui_delay = 30; // 30ms\n\t/* Reduce link bandwidth between failed link training attempts. */\n\tbool do_fallback = false;\n\tint lt_attempts = LINK_TRAINING_ATTEMPTS;\n\n\t// Increase retry count if attempting DP1.x on FIXED_VS link\n\tif ((link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) &&\n\t\t\tlink_dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING)\n\t\tlt_attempts = 10;\n\n\t// check for seamless boot\n\tfor (i = 0; i < state->stream_count; i++) {\n\t\tif (state->streams[i]->apply_seamless_boot_optimization) {\n\t\t\tapply_seamless_boot_optimization = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If the link is DP-over-USB4 do the following:\n\t * - Train with fallback when enabling DPIA link. Conventional links are\n\t * trained with fallback during sink detection.\n\t * - Allocate only what the stream needs for bw in Gbps. Inform the CM\n\t * in case stream needs more or less bw from what has been allocated\n\t * earlier at plug time.\n\t */\n\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA) {\n\t\tdo_fallback = true;\n\t}\n\n\t/*\n\t * Temporary w/a to get DP2.0 link rates to work with SST.\n\t * TODO DP2.0 - Workaround: Remove w/a if and when the issue is resolved.\n\t */\n\tif (link_dp_get_encoding_format(link_settings) == DP_128b_132b_ENCODING &&\n\t\t\tpipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t\tlink->dc->debug.set_mst_en_for_sst) {\n\t\tenable_mst_on_sink(link, true);\n\t}\n\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_EDP) {\n\t\t/*in case it is not on*/\n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t\tlink->dc->hwss.edp_power_control(link, true);\n\t\tlink->dc->hwss.edp_wait_for_hpd_ready(link, true);\n\t}\n\n\tif (link_dp_get_encoding_format(link_settings) == DP_128b_132b_ENCODING) {\n\t\t/* TODO - DP2.0 HW: calculate 32 symbol clock for HPO encoder */\n\t} else {\n\t\tpipe_ctx->stream_res.pix_clk_params.requested_sym_clk =\n\t\t\t\tlink_settings->link_rate * LINK_RATE_REF_FREQ_IN_KHZ;\n\t\tif (state->clk_mgr && !apply_seamless_boot_optimization)\n\t\t\tstate->clk_mgr->funcs->update_clocks(state->clk_mgr,\n\t\t\t\t\tstate, false);\n\t}\n\n\t// during mode switch we do DP_SET_POWER off then on, and OUI is lost\n\tdpcd_set_source_specific_data(link);\n\tif (link->dpcd_sink_ext_caps.raw != 0) {\n\t\tpost_oui_delay += link->panel_config.pps.extra_post_OUI_ms;\n\t\tmsleep(post_oui_delay);\n\t}\n\n\t// similarly, mode switch can cause loss of cable ID\n\tdpcd_write_cable_id_to_dprx(link);\n\n\tskip_video_pattern = true;\n\n\tif (link_settings->link_rate == LINK_RATE_LOW)\n\t\tskip_video_pattern = false;\n\n\tif (perform_link_training_with_retries(link_settings,\n\t\t\t\t\t       skip_video_pattern,\n\t\t\t\t\t       lt_attempts,\n\t\t\t\t\t       pipe_ctx,\n\t\t\t\t\t       pipe_ctx->stream->signal,\n\t\t\t\t\t       do_fallback)) {\n\t\tstatus = DC_OK;\n\t} else {\n\t\tstatus = DC_FAIL_DP_LINK_TRAINING;\n\t}\n\n\tif (link->preferred_training_settings.fec_enable)\n\t\tfec_enable = *link->preferred_training_settings.fec_enable;\n\telse\n\t\tfec_enable = true;\n\n\tif (link_dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING)\n\t\tdp_set_fec_enable(link, fec_enable);\n\n\t// during mode set we do DP_SET_POWER off then on, aux writes are lost\n\tif (link->dpcd_sink_ext_caps.bits.oled == 1 ||\n\t\tlink->dpcd_sink_ext_caps.bits.sdr_aux_backlight_control == 1 ||\n\t\tlink->dpcd_sink_ext_caps.bits.hdr_aux_backlight_control == 1) {\n\t\tset_default_brightness_aux(link);\n\t\tif (link->dpcd_sink_ext_caps.bits.oled == 1)\n\t\t\tmsleep(bl_oled_enable_delay);\n\t\tedp_backlight_enable_aux(link, true);\n\t}\n\n\treturn status;\n}\n\nstatic enum dc_status enable_link_edp(\n\t\tstruct dc_state *state,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\treturn enable_link_dp(state, pipe_ctx);\n}\n\nstatic void enable_link_lvds(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc *dc = stream->ctx->dc;\n\n\tif (stream->phy_pix_clk == 0)\n\t\tstream->phy_pix_clk = stream->timing.pix_clk_100hz / 10;\n\n\tmemset(&stream->link->cur_link_settings, 0,\n\t\t\tsizeof(struct dc_link_settings));\n\tdc->hwss.enable_lvds_link_output(\n\t\t\tlink,\n\t\t\t&pipe_ctx->link_res,\n\t\t\tpipe_ctx->clock_source->id,\n\t\t\tstream->phy_pix_clk);\n\n}\n\nstatic enum dc_status enable_link_dp_mst(\n\t\tstruct dc_state *state,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\tunsigned char mstm_cntl;\n\n\t/* sink signal type after MST branch is MST. Multiple MST sinks\n\t * share one link. Link DP PHY is enable or training only once.\n\t */\n\tif (link->link_status.link_active)\n\t\treturn DC_OK;\n\n\t/* clear payload table */\n\tcore_link_read_dpcd(link, DP_MSTM_CTRL, &mstm_cntl, 1);\n\tif (mstm_cntl & DP_MST_EN)\n\t\tdm_helpers_dp_mst_clear_payload_allocation_table(link->ctx, link);\n\n\t/* to make sure the pending down rep can be processed\n\t * before enabling the link\n\t */\n\tdm_helpers_dp_mst_poll_pending_down_reply(link->ctx, link);\n\n\t/* set the sink to MST mode before enabling the link */\n\tenable_mst_on_sink(link, true);\n\n\treturn enable_link_dp(state, pipe_ctx);\n}\n\nstatic enum dc_status enable_link(\n\t\tstruct dc_state *state,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\n\t/* There's some scenarios where driver is unloaded with display\n\t * still enabled. When driver is reloaded, it may cause a display\n\t * to not light up if there is a mismatch between old and new\n\t * link settings. Need to call disable first before enabling at\n\t * new link settings.\n\t */\n\tif (link->link_status.link_active)\n\t\tdisable_link(link, &pipe_ctx->link_res, pipe_ctx->stream->signal);\n\n\tswitch (pipe_ctx->stream->signal) {\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\tstatus = enable_link_dp(state, pipe_ctx);\n\t\tbreak;\n\tcase SIGNAL_TYPE_EDP:\n\t\tstatus = enable_link_edp(state, pipe_ctx);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tstatus = enable_link_dp_mst(state, pipe_ctx);\n\t\tmsleep(200);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tenable_link_hdmi(pipe_ctx);\n\t\tstatus = DC_OK;\n\t\tbreak;\n\tcase SIGNAL_TYPE_LVDS:\n\t\tenable_link_lvds(pipe_ctx);\n\t\tstatus = DC_OK;\n\t\tbreak;\n\tcase SIGNAL_TYPE_VIRTUAL:\n\t\tstatus = DC_OK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (status == DC_OK) {\n\t\tpipe_ctx->stream->link->link_status.link_active = true;\n\t}\n\n\treturn status;\n}\n\nvoid link_set_dpms_off(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc  *dc = pipe_ctx->stream->ctx->dc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->sink->link;\n\tstruct vpg *vpg = pipe_ctx->stream_res.stream_enc->vpg;\n\n\tASSERT(is_master_pipe_for_link(link, pipe_ctx));\n\n\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\tvpg = pipe_ctx->stream_res.hpo_dp_stream_enc->vpg;\n\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\tif (pipe_ctx->stream->sink) {\n\t\tif (pipe_ctx->stream->sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&\n\t\t\tpipe_ctx->stream->sink->sink_signal != SIGNAL_TYPE_NONE) {\n\t\t\tDC_LOG_DC(\"%s pipe_ctx dispname=%s signal=%x\\n\", __func__,\n\t\t\tpipe_ctx->stream->sink->edid_caps.display_name,\n\t\t\tpipe_ctx->stream->signal);\n\t\t}\n\t}\n\n\tif (dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\treturn;\n\n\tif (!pipe_ctx->stream->sink->edid_caps.panel_patch.skip_avmute) {\n\t\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal))\n\t\t\tset_avmute(pipe_ctx, true);\n\t}\n\n\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\tupdate_psp_stream_config(pipe_ctx, true);\n\tdc->hwss.blank_stream(pipe_ctx);\n\n\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)\n\t\tdeallocate_mst_payload(pipe_ctx);\n\telse if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t\tdp_is_128b_132b_signal(pipe_ctx))\n\t\tupdate_sst_payload(pipe_ctx, false);\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal)) {\n\t\tstruct ext_hdmi_settings settings = {0};\n\t\tenum engine_id eng_id = pipe_ctx->stream_res.stream_enc->id;\n\n\t\tunsigned short masked_chip_caps = link->chip_caps &\n\t\t\t\tEXT_DISPLAY_PATH_CAPS__EXT_CHIP_MASK;\n\t\t//Need to inform that sink is going to use legacy HDMI mode.\n\t\twrite_scdc_data(\n\t\t\tlink->ddc,\n\t\t\t165000,//vbios only handles 165Mhz.\n\t\t\tfalse);\n\t\tif (masked_chip_caps == EXT_DISPLAY_PATH_CAPS__HDMI20_TISN65DP159RSBT) {\n\t\t\t/* DP159, Retimer settings */\n\t\t\tif (get_ext_hdmi_settings(pipe_ctx, eng_id, &settings))\n\t\t\t\twrite_i2c_retimer_setting(pipe_ctx,\n\t\t\t\t\t\tfalse, false, &settings);\n\t\t\telse\n\t\t\t\twrite_i2c_default_retimer_setting(pipe_ctx,\n\t\t\t\t\t\tfalse, false);\n\t\t} else if (masked_chip_caps == EXT_DISPLAY_PATH_CAPS__HDMI20_PI3EQX1204) {\n\t\t\t/* PI3EQX1204, Redriver settings */\n\t\t\twrite_i2c_redriver_setting(pipe_ctx, false);\n\t\t}\n\t}\n\n\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t\t!dp_is_128b_132b_signal(pipe_ctx)) {\n\n\t\t/* In DP1.x SST mode, our encoder will go to TPS1\n\t\t * when link is on but stream is off.\n\t\t * Disabling link before stream will avoid exposing TPS1 pattern\n\t\t * during the disable sequence as it will confuse some receivers\n\t\t * state machine.\n\t\t * In DP2 or MST mode, our encoder will stay video active\n\t\t */\n\t\tdisable_link(pipe_ctx->stream->link, &pipe_ctx->link_res, pipe_ctx->stream->signal);\n\t\tdc->hwss.disable_stream(pipe_ctx);\n\t} else {\n\t\tdc->hwss.disable_stream(pipe_ctx);\n\t\tdisable_link(pipe_ctx->stream->link, &pipe_ctx->link_res, pipe_ctx->stream->signal);\n\t}\n\n\tif (pipe_ctx->stream->timing.flags.DSC) {\n\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\t\tlink_set_dsc_enable(pipe_ctx, false);\n\t}\n\tif (dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tif (pipe_ctx->stream_res.tg->funcs->set_out_mux)\n\t\t\tpipe_ctx->stream_res.tg->funcs->set_out_mux(pipe_ctx->stream_res.tg, OUT_MUX_DIO);\n\t}\n\n\tif (vpg && vpg->funcs->vpg_powerdown)\n\t\tvpg->funcs->vpg_powerdown(vpg);\n}\n\nvoid link_set_dpms_on(\n\t\tstruct dc_state *state,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->sink->link;\n\tenum dc_status status;\n\tstruct link_encoder *link_enc;\n\tenum otg_out_mux_dest otg_out_dest = OUT_MUX_DIO;\n\tstruct vpg *vpg = pipe_ctx->stream_res.stream_enc->vpg;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tbool apply_edp_fast_boot_optimization =\n\t\tpipe_ctx->stream->apply_edp_fast_boot_optimization;\n\n\tASSERT(is_master_pipe_for_link(link, pipe_ctx));\n\n\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\tvpg = pipe_ctx->stream_res.hpo_dp_stream_enc->vpg;\n\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\tif (pipe_ctx->stream->sink) {\n\t\tif (pipe_ctx->stream->sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&\n\t\t\tpipe_ctx->stream->sink->sink_signal != SIGNAL_TYPE_NONE) {\n\t\t\tDC_LOG_DC(\"%s pipe_ctx dispname=%s signal=%x\\n\", __func__,\n\t\t\tpipe_ctx->stream->sink->edid_caps.display_name,\n\t\t\tpipe_ctx->stream->signal);\n\t\t}\n\t}\n\n\tif (dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\treturn;\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\tif (!dc_is_virtual_signal(pipe_ctx->stream->signal)\n\t\t\t&& !dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tif (link_enc)\n\t\t\tlink_enc->funcs->setup(\n\t\t\t\tlink_enc,\n\t\t\t\tpipe_ctx->stream->signal);\n\t}\n\n\tpipe_ctx->stream->link->link_state_valid = true;\n\n\tif (pipe_ctx->stream_res.tg->funcs->set_out_mux) {\n\t\tif (dp_is_128b_132b_signal(pipe_ctx))\n\t\t\totg_out_dest = OUT_MUX_HPO_DP;\n\t\telse\n\t\t\totg_out_dest = OUT_MUX_DIO;\n\t\tpipe_ctx->stream_res.tg->funcs->set_out_mux(pipe_ctx->stream_res.tg, otg_out_dest);\n\t}\n\n\tlink_hwss->setup_stream_attribute(pipe_ctx);\n\n\tpipe_ctx->stream->apply_edp_fast_boot_optimization = false;\n\n\t// Enable VPG before building infoframe\n\tif (vpg && vpg->funcs->vpg_poweron)\n\t\tvpg->funcs->vpg_poweron(vpg);\n\n\tresource_build_info_frame(pipe_ctx);\n\tdc->hwss.update_info_frame(pipe_ctx);\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tdp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_UPDATE_INFO_FRAME);\n\n\t/* Do not touch link on seamless boot optimization. */\n\tif (pipe_ctx->stream->apply_seamless_boot_optimization) {\n\t\tpipe_ctx->stream->dpms_off = false;\n\n\t\t/* Still enable stream features & audio on seamless boot for DP external displays */\n\t\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT) {\n\t\t\tenable_stream_features(pipe_ctx);\n\t\t\tdc->hwss.enable_audio_stream(pipe_ctx);\n\t\t}\n\n\t\tupdate_psp_stream_config(pipe_ctx, false);\n\t\treturn;\n\t}\n\n\t/* eDP lit up by bios already, no need to enable again. */\n\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_EDP &&\n\t\t\t\tapply_edp_fast_boot_optimization &&\n\t\t\t\t!pipe_ctx->stream->timing.flags.DSC &&\n\t\t\t\t!pipe_ctx->next_odm_pipe) {\n\t\tpipe_ctx->stream->dpms_off = false;\n\t\tupdate_psp_stream_config(pipe_ctx, false);\n\t\treturn;\n\t}\n\n\tif (pipe_ctx->stream->dpms_off)\n\t\treturn;\n\n\t/* Have to setup DSC before DIG FE and BE are connected (which happens before the\n\t * link training). This is to make sure the bandwidth sent to DIG BE won't be\n\t * bigger than what the link and/or DIG BE can handle. VBID[6]/CompressedStream_flag\n\t * will be automatically set at a later time when the video is enabled\n\t * (DP_VID_STREAM_EN = 1).\n\t */\n\tif (pipe_ctx->stream->timing.flags.DSC) {\n\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal) ||\n\t\t\tdc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\tlink_set_dsc_enable(pipe_ctx, true);\n\n\t}\n\n\tstatus = enable_link(state, pipe_ctx);\n\n\tif (status != DC_OK) {\n\t\tDC_LOG_WARNING(\"enabling link %u failed: %d\\n\",\n\t\tpipe_ctx->stream->link->link_index,\n\t\tstatus);\n\n\t\t/* Abort stream enable *unless* the failure was due to\n\t\t * DP link training - some DP monitors will recover and\n\t\t * show the stream anyway. But MST displays can't proceed\n\t\t * without link training.\n\t\t */\n\t\tif (status != DC_FAIL_DP_LINK_TRAINING ||\n\t\t\t\tpipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\t\tif (false == stream->link->link_status.link_active)\n\t\t\t\tdisable_link(stream->link, &pipe_ctx->link_res,\n\t\t\t\t\t\tpipe_ctx->stream->signal);\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* turn off otg test pattern if enable */\n\tif (pipe_ctx->stream_res.tg->funcs->set_test_pattern)\n\t\tpipe_ctx->stream_res.tg->funcs->set_test_pattern(pipe_ctx->stream_res.tg,\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_VIDEOMODE,\n\t\t\t\tCOLOR_DEPTH_UNDEFINED);\n\n\t/* This second call is needed to reconfigure the DIG\n\t * as a workaround for the incorrect value being applied\n\t * from transmitter control.\n\t */\n\tif (!(dc_is_virtual_signal(pipe_ctx->stream->signal) ||\n\t\t\tdp_is_128b_132b_signal(pipe_ctx))) {\n\t\t\tif (link_enc)\n\t\t\t\tlink_enc->funcs->setup(\n\t\t\t\t\tlink_enc,\n\t\t\t\t\tpipe_ctx->stream->signal);\n\t\t}\n\n\tdc->hwss.enable_stream(pipe_ctx);\n\n\t/* Set DPS PPS SDP (AKA \"info frames\") */\n\tif (pipe_ctx->stream->timing.flags.DSC) {\n\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal) ||\n\t\t\t\tdc_is_virtual_signal(pipe_ctx->stream->signal)) {\n\t\t\tdp_set_dsc_on_rx(pipe_ctx, true);\n\t\t\tlink_set_dsc_pps_packet(pipe_ctx, true, true);\n\t\t}\n\t}\n\n\tif (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)\n\t\tallocate_mst_payload(pipe_ctx);\n\telse if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t\tdp_is_128b_132b_signal(pipe_ctx))\n\t\tupdate_sst_payload(pipe_ctx, true);\n\n\tdc->hwss.unblank_stream(pipe_ctx,\n\t\t&pipe_ctx->stream->link->cur_link_settings);\n\n\tif (stream->sink_patches.delay_ignore_msa > 0)\n\t\tmsleep(stream->sink_patches.delay_ignore_msa);\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tenable_stream_features(pipe_ctx);\n\tupdate_psp_stream_config(pipe_ctx, false);\n\n\tdc->hwss.enable_audio_stream(pipe_ctx);\n\n\tif (dc_is_hdmi_signal(pipe_ctx->stream->signal)) {\n\t\tset_avmute(pipe_ctx, false);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}