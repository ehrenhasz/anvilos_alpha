{
  "module_name": "dcn32_dio_stream_encoder.c",
  "hash_id": "0ca3180e6b122f6e74099cdec0b6227e9c07899ed1e57a851fd7d75824624864",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dio_stream_encoder.c",
  "human_readable_source": " \n\n\n#include \"dc_bios_types.h\"\n#include \"dcn30/dcn30_dio_stream_encoder.h\"\n#include \"dcn32_dio_stream_encoder.h\"\n#include \"reg_helper.h\"\n#include \"hw_shared.h\"\n#include \"link.h\"\n#include \"dpcd_defs.h\"\n\n#define DC_LOGGER \\\n\t\tenc1->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc1->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc1->se_shift->field_name, enc1->se_mask->field_name\n\n#define VBI_LINE_0 0\n#define HDMI_CLOCK_CHANNEL_RATE_MORE_340M 340000\n\n#define CTX \\\n\tenc1->base.ctx\n\n\n\nstatic void enc32_dp_set_odm_combine(\n\tstruct stream_encoder *enc,\n\tbool odm_combine)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_PER_CYCLE_PROCESSING_MODE, odm_combine ? 1 : 0);\n}\n\n \nstatic void enc32_stream_encoder_dvi_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tbool is_dual_link)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (!enc->ctx->dc->debug.avoid_vbios_exec_table) {\n\t\tstruct bp_encoder_control cntl = {0};\n\n\t\tcntl.action = ENCODER_CONTROL_SETUP;\n\t\tcntl.engine_id = enc1->base.id;\n\t\tcntl.signal = is_dual_link ?\n\t\t\tSIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tcntl.enable_dp_audio = false;\n\t\tcntl.pixel_clock = crtc_timing->pix_clk_100hz / 10;\n\t\tcntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;\n\n\t\tif (enc1->base.bp->funcs->encoder_control(\n\t\t\t\tenc1->base.bp, &cntl) != BP_RESULT_OK)\n\t\t\treturn;\n\n\t} else {\n\n\t\t\n\t\tREG_UPDATE(DIG_CLOCK_PATTERN, DIG_CLOCK_PATTERN, 0x1F);\n\n\t\t\n\n\t\t\n\n\t\t \n\t}\n\n\tASSERT(crtc_timing->pixel_encoding == PIXEL_ENCODING_RGB);\n\tASSERT(crtc_timing->display_color_depth == COLOR_DEPTH_888);\n\tenc1_stream_encoder_set_stream_attribute_helper(enc1, crtc_timing);\n}\n\n \nstatic void enc32_stream_encoder_hdmi_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tint actual_pix_clk_khz,\n\tbool enable_audio)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (!enc->ctx->dc->debug.avoid_vbios_exec_table) {\n\t\tstruct bp_encoder_control cntl = {0};\n\n\t\tcntl.action = ENCODER_CONTROL_SETUP;\n\t\tcntl.engine_id = enc1->base.id;\n\t\tcntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;\n\t\tcntl.enable_dp_audio = enable_audio;\n\t\tcntl.pixel_clock = actual_pix_clk_khz;\n\t\tcntl.lanes_number = LANE_COUNT_FOUR;\n\n\t\tif (enc1->base.bp->funcs->encoder_control(\n\t\t\t\tenc1->base.bp, &cntl) != BP_RESULT_OK)\n\t\t\treturn;\n\n\t} else {\n\n\t\t\n\t\tREG_UPDATE(DIG_CLOCK_PATTERN, DIG_CLOCK_PATTERN, 0x1F);\n\n\t\t\n\n\t\t\n\n\t\t \n\t}\n\n\t \n\tenc1_stream_encoder_set_stream_attribute_helper(enc1, crtc_timing);\n\n\t \n\tREG_UPDATE_6(HDMI_CONTROL,\n\t\tHDMI_PACKET_GEN_VERSION, 1,\n\t\tHDMI_KEEPOUT_MODE, 1,\n\t\tHDMI_DEEP_COLOR_ENABLE, 0,\n\t\tHDMI_DATA_SCRAMBLE_EN, 0,\n\t\tHDMI_NO_EXTRA_NULL_PACKET_FILLED, 1,\n\t\tHDMI_CLOCK_CHANNEL_RATE, 0);\n\n\t \n\tswitch (crtc_timing->display_color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tREG_UPDATE(HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 0);\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 1,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n\t\t} else {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 1,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\t\t}\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 2,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 0);\n\t\t} else {\n\t\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 2,\n\t\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\t\t}\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\t\tHDMI_DEEP_COLOR_DEPTH, 3,\n\t\t\t\tHDMI_DEEP_COLOR_ENABLE, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (actual_pix_clk_khz >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {\n\t\t \n\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\tHDMI_DATA_SCRAMBLE_EN, 1,\n\t\t\tHDMI_CLOCK_CHANNEL_RATE, 1);\n\t} else if (crtc_timing->flags.LTE_340MCSC_SCRAMBLE) {\n\n\t\t \n\n\t\t \n\t\tREG_UPDATE_2(HDMI_CONTROL,\n\t\t\tHDMI_DATA_SCRAMBLE_EN, 1,\n\t\t\tHDMI_CLOCK_CHANNEL_RATE, 0);\n\t}\n\n\n\t \n\tREG_UPDATE_3(HDMI_VBI_PACKET_CONTROL,\n\t\tHDMI_GC_CONT, 1,\n\t\tHDMI_GC_SEND, 1,\n\t\tHDMI_NULL_SEND, 1);\n\n\t \n\tREG_UPDATE(HDMI_VBI_PACKET_CONTROL, HDMI_ACP_SEND, 0);\n\n\t \n\t \n\tREG_UPDATE(HDMI_INFOFRAME_CONTROL0, HDMI_AUDIO_INFO_SEND, 1);\n\n\t \n\tASSERT(enc->afmt);\n\tenc->afmt->funcs->audio_info_immediate_update(enc->afmt);\n\n\t \n\tREG_UPDATE(HDMI_INFOFRAME_CONTROL1, HDMI_AUDIO_INFO_LINE,\n\t\t\t\tVBI_LINE_0 + 2);\n\n\t \n\tREG_UPDATE(HDMI_GC, HDMI_GC_AVMUTE, 0);\n}\n\n\n\nstatic bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)\n{\n\tbool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;\n\n\ttwo_pix = two_pix || (timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422\n\t\t\t&& !timing->dsc_cfg.ycbcr422_simple);\n\treturn two_pix;\n}\n\nstatic bool is_h_timing_divisible_by_2(const struct dc_crtc_timing *timing)\n{\n\t \n\n\tbool divisible = false;\n\tuint16_t h_blank_start = 0;\n\tuint16_t h_blank_end = 0;\n\n\tif (timing) {\n\t\th_blank_start = timing->h_total - timing->h_front_porch;\n\t\th_blank_end = h_blank_start - timing->h_addressable;\n\n\t\t \n\t\tdivisible = (timing->h_total % 2 == 0) &&\n\t\t\t\t(h_blank_start % 2 == 0) &&\n\t\t\t\t(h_blank_end % 2 == 0) &&\n\t\t\t\t(timing->h_sync_width % 2 == 0);\n\t}\n\treturn divisible;\n}\n\nstatic bool is_dp_dig_pixel_rate_div_policy(struct dc *dc, const struct dc_crtc_timing *timing)\n{\n\t \n\treturn is_h_timing_divisible_by_2(timing) &&\n\t\tdc->debug.enable_dp_dig_pixel_rate_div_policy;\n}\n\nvoid enc32_stream_encoder_dp_unblank(\n\tstruct dc_link *link,\n\tstruct stream_encoder *enc,\n\tconst struct encoder_unblank_param *param)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\tstruct dc *dc = enc->ctx->dc;\n\n\tif (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {\n\t\tuint32_t n_vid = 0x8000;\n\t\tuint32_t m_vid;\n\t\tuint32_t n_multiply = 0;\n\t\tuint32_t pix_per_cycle = 0;\n\t\tuint64_t m_vid_l = n_vid;\n\n\t\t \n\t\tif (is_two_pixels_per_containter(&param->timing) || param->opp_cnt > 1\n\t\t\t|| is_dp_dig_pixel_rate_div_policy(dc, &param->timing)) {\n\t\t\t \n\t\t\tn_multiply = 1;\n\t\t\tpix_per_cycle = 1;\n\t\t}\n\t\t \n\n\t\tm_vid_l *= param->timing.pix_clk_100hz / 10;\n\t\tm_vid_l = div_u64(m_vid_l,\n\t\t\tparam->link_settings.link_rate\n\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ);\n\n\t\tm_vid = (uint32_t) m_vid_l;\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 0);\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_N, DP_VID_N, n_vid);\n\n\t\tREG_UPDATE(DP_VID_M, DP_VID_M, m_vid);\n\n\t\tREG_UPDATE_2(DP_VID_TIMING,\n\t\t\t\tDP_VID_M_N_GEN_EN, 1,\n\t\t\t\tDP_VID_N_MUL, n_multiply);\n\n\t\tREG_UPDATE(DP_PIXEL_FORMAT,\n\t\t\t\tDP_PIXEL_PER_CYCLE_PROCESSING_MODE,\n\t\t\t\tpix_per_cycle);\n\t}\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, false);\n\tREG_WAIT(DP_VID_STREAM_CNTL, DP_VID_STREAM_STATUS, 0, 10, 5000);\n\n\t \n\n\t \n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 1);\n\tudelay(10);\n\n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);\n\n\t \n\t\n\tREG_WAIT(DIG_FE_CNTL, DIG_SYMCLK_FE_ON, 1, 10, 5000);\n\n\t \n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_READ_START_LEVEL, 0x7);\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_RESET, 1);\n\n\tREG_WAIT(DIG_FIFO_CTRL0, DIG_FIFO_RESET_DONE, 1, 10, 5000);\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_RESET, 0);\n\n\tREG_WAIT(DIG_FIFO_CTRL0, DIG_FIFO_RESET_DONE, 0, 10, 5000);\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_ENABLE, 1);\n\n\t \n\tudelay(100);\n\n\t \n\n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, true);\n\n\tlink->dc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_ENABLE_DP_VID_STREAM);\n}\n\n \nstatic void enc32_dp_set_dsc_config(struct stream_encoder *enc,\n\t\t\t\t\tenum optc_dsc_mode dsc_mode,\n\t\t\t\t\tuint32_t dsc_bytes_per_pixel,\n\t\t\t\t\tuint32_t dsc_slice_width)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(DP_DSC_CNTL,\tDP_DSC_MODE, dsc_mode == OPTC_DSC_DISABLED ? 0 : 1);\n}\n\n \nstatic void enc32_read_state(struct stream_encoder *enc, struct enc_state *s)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\t\n\tREG_GET(DP_DSC_CNTL, DP_DSC_MODE, &s->dsc_mode);\n\tif (s->dsc_mode) {\n\t\tREG_GET(DP_GSP11_CNTL, DP_SEC_GSP11_LINE_NUM, &s->sec_gsp_pps_line_num);\n\n\t\tREG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_REFERENCE, &s->vbid6_line_reference);\n\t\tREG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_NUM, &s->vbid6_line_num);\n\n\t\tREG_GET(DP_GSP11_CNTL, DP_SEC_GSP11_ENABLE, &s->sec_gsp_pps_enable);\n\t\tREG_GET(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, &s->sec_stream_enable);\n\t}\n}\n\nstatic void enc32_set_dig_input_mode(struct stream_encoder *enc, unsigned int pix_per_container)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\t \n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_OUTPUT_PIXEL_MODE, pix_per_container == 2 ? 0x1 : 0x0);\n}\n\nstatic void enc32_reset_fifo(struct stream_encoder *enc, bool reset)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\tuint32_t reset_val = reset ? 1 : 0;\n\tuint32_t is_symclk_on;\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_RESET, reset_val);\n\tREG_GET(DIG_FE_CNTL, DIG_SYMCLK_FE_ON, &is_symclk_on);\n\n\tif (is_symclk_on)\n\t\tREG_WAIT(DIG_FIFO_CTRL0, DIG_FIFO_RESET_DONE, reset_val, 10, 5000);\n\telse\n\t\tudelay(10);\n}\n\nvoid enc32_enable_fifo(struct stream_encoder *enc)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_READ_START_LEVEL, 0x7);\n\n\tenc32_reset_fifo(enc, true);\n\tenc32_reset_fifo(enc, false);\n\n\tREG_UPDATE(DIG_FIFO_CTRL0, DIG_FIFO_ENABLE, 1);\n}\n\nstatic const struct stream_encoder_funcs dcn32_str_enc_funcs = {\n\t.dp_set_odm_combine =\n\t\tenc32_dp_set_odm_combine,\n\t.dp_set_stream_attribute =\n\t\tenc2_stream_encoder_dp_set_stream_attribute,\n\t.hdmi_set_stream_attribute =\n\t\tenc32_stream_encoder_hdmi_set_stream_attribute,\n\t.dvi_set_stream_attribute =\n\t\tenc32_stream_encoder_dvi_set_stream_attribute,\n\t.set_throttled_vcp_size =\n\t\tenc1_stream_encoder_set_throttled_vcp_size,\n\t.update_hdmi_info_packets =\n\t\tenc3_stream_encoder_update_hdmi_info_packets,\n\t.stop_hdmi_info_packets =\n\t\tenc3_stream_encoder_stop_hdmi_info_packets,\n\t.update_dp_info_packets_sdp_line_num =\n\t\tenc3_stream_encoder_update_dp_info_packets_sdp_line_num,\n\t.update_dp_info_packets =\n\t\tenc3_stream_encoder_update_dp_info_packets,\n\t.stop_dp_info_packets =\n\t\tenc1_stream_encoder_stop_dp_info_packets,\n\t.dp_blank =\n\t\tenc1_stream_encoder_dp_blank,\n\t.dp_unblank =\n\t\tenc32_stream_encoder_dp_unblank,\n\t.audio_mute_control = enc3_audio_mute_control,\n\n\t.dp_audio_setup = enc3_se_dp_audio_setup,\n\t.dp_audio_enable = enc3_se_dp_audio_enable,\n\t.dp_audio_disable = enc1_se_dp_audio_disable,\n\n\t.hdmi_audio_setup = enc3_se_hdmi_audio_setup,\n\t.hdmi_audio_disable = enc1_se_hdmi_audio_disable,\n\t.setup_stereo_sync  = enc1_setup_stereo_sync,\n\t.set_avmute = enc1_stream_encoder_set_avmute,\n\t.dig_connect_to_otg = enc1_dig_connect_to_otg,\n\t.dig_source_otg = enc1_dig_source_otg,\n\n\t.dp_get_pixel_format  = enc1_stream_encoder_dp_get_pixel_format,\n\n\t.enc_read_state = enc32_read_state,\n\t.dp_set_dsc_config = enc32_dp_set_dsc_config,\n\t.dp_set_dsc_pps_info_packet = enc3_dp_set_dsc_pps_info_packet,\n\t.set_dynamic_metadata = enc2_set_dynamic_metadata,\n\t.hdmi_reset_stream_attribute = enc1_reset_hdmi_stream_attribute,\n\n\t.set_input_mode = enc32_set_dig_input_mode,\n\t.enable_fifo = enc32_enable_fifo,\n};\n\nvoid dcn32_dio_stream_encoder_construct(\n\tstruct dcn10_stream_encoder *enc1,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bp,\n\tenum engine_id eng_id,\n\tstruct vpg *vpg,\n\tstruct afmt *afmt,\n\tconst struct dcn10_stream_enc_registers *regs,\n\tconst struct dcn10_stream_encoder_shift *se_shift,\n\tconst struct dcn10_stream_encoder_mask *se_mask)\n{\n\tenc1->base.funcs = &dcn32_str_enc_funcs;\n\tenc1->base.ctx = ctx;\n\tenc1->base.id = eng_id;\n\tenc1->base.bp = bp;\n\tenc1->base.vpg = vpg;\n\tenc1->base.afmt = afmt;\n\tenc1->regs = regs;\n\tenc1->se_shift = se_shift;\n\tenc1->se_mask = se_mask;\n\tenc1->base.stream_enc_inst = vpg->inst;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}