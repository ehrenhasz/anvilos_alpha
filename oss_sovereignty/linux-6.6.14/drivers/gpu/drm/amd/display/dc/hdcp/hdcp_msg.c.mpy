{
  "module_name": "hdcp_msg.c",
  "hash_id": "62d496ad7ac1ede0ea726b164fbee53c09cc502eaa5b248ac73e510d6393be31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/hdcp/hdcp_msg.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n#include \"dm_helpers.h\"\n#include \"include/hdcp_msg_types.h\"\n#include \"include/signal_types.h\"\n#include \"core_types.h\"\n#include \"link.h\"\n#include \"link_hwss.h\"\n#include \"link/protocols/link_dpcd.h\"\n\n#define DC_LOGGER \\\n\tlink->ctx->logger\n#define HDCP14_KSV_SIZE 5\n#define HDCP14_MAX_KSV_FIFO_SIZE 127*HDCP14_KSV_SIZE\n\nstatic const bool hdcp_cmd_is_read[HDCP_MESSAGE_ID_MAX] = {\n\t[HDCP_MESSAGE_ID_READ_BKSV] = true,\n\t[HDCP_MESSAGE_ID_READ_RI_R0] = true,\n\t[HDCP_MESSAGE_ID_READ_PJ] = true,\n\t[HDCP_MESSAGE_ID_WRITE_AKSV] = false,\n\t[HDCP_MESSAGE_ID_WRITE_AINFO] = false,\n\t[HDCP_MESSAGE_ID_WRITE_AN] = false,\n\t[HDCP_MESSAGE_ID_READ_VH_X] = true,\n\t[HDCP_MESSAGE_ID_READ_VH_0] = true,\n\t[HDCP_MESSAGE_ID_READ_VH_1] = true,\n\t[HDCP_MESSAGE_ID_READ_VH_2] = true,\n\t[HDCP_MESSAGE_ID_READ_VH_3] = true,\n\t[HDCP_MESSAGE_ID_READ_VH_4] = true,\n\t[HDCP_MESSAGE_ID_READ_BCAPS] = true,\n\t[HDCP_MESSAGE_ID_READ_BSTATUS] = true,\n\t[HDCP_MESSAGE_ID_READ_KSV_FIFO] = true,\n\t[HDCP_MESSAGE_ID_READ_BINFO] = true,\n\t[HDCP_MESSAGE_ID_HDCP2VERSION] = true,\n\t[HDCP_MESSAGE_ID_RX_CAPS] = true,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_INIT] = false,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_CERT] = true,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_NO_STORED_KM] = false,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_STORED_KM] = false,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_H_PRIME] = true,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_PAIRING_INFO] = true,\n\t[HDCP_MESSAGE_ID_WRITE_LC_INIT] = false,\n\t[HDCP_MESSAGE_ID_READ_LC_SEND_L_PRIME] = true,\n\t[HDCP_MESSAGE_ID_WRITE_SKE_SEND_EKS] = false,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_SEND_RECEIVERID_LIST] = true,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_SEND_ACK] = false,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_STREAM_MANAGE] = false,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_STREAM_READY] = true,\n\t[HDCP_MESSAGE_ID_READ_RXSTATUS] = true,\n\t[HDCP_MESSAGE_ID_WRITE_CONTENT_STREAM_TYPE] = false\n};\n\nstatic const uint8_t hdcp_i2c_offsets[HDCP_MESSAGE_ID_MAX] = {\n\t[HDCP_MESSAGE_ID_READ_BKSV] = 0x0,\n\t[HDCP_MESSAGE_ID_READ_RI_R0] = 0x8,\n\t[HDCP_MESSAGE_ID_READ_PJ] = 0xA,\n\t[HDCP_MESSAGE_ID_WRITE_AKSV] = 0x10,\n\t[HDCP_MESSAGE_ID_WRITE_AINFO] = 0x15,\n\t[HDCP_MESSAGE_ID_WRITE_AN] = 0x18,\n\t[HDCP_MESSAGE_ID_READ_VH_X] = 0x20,\n\t[HDCP_MESSAGE_ID_READ_VH_0] = 0x20,\n\t[HDCP_MESSAGE_ID_READ_VH_1] = 0x24,\n\t[HDCP_MESSAGE_ID_READ_VH_2] = 0x28,\n\t[HDCP_MESSAGE_ID_READ_VH_3] = 0x2C,\n\t[HDCP_MESSAGE_ID_READ_VH_4] = 0x30,\n\t[HDCP_MESSAGE_ID_READ_BCAPS] = 0x40,\n\t[HDCP_MESSAGE_ID_READ_BSTATUS] = 0x41,\n\t[HDCP_MESSAGE_ID_READ_KSV_FIFO] = 0x43,\n\t[HDCP_MESSAGE_ID_READ_BINFO] = 0xFF,\n\t[HDCP_MESSAGE_ID_HDCP2VERSION] = 0x50,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_INIT] = 0x60,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_CERT] = 0x80,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_NO_STORED_KM] = 0x60,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_STORED_KM] = 0x60,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_H_PRIME] = 0x80,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_PAIRING_INFO] = 0x80,\n\t[HDCP_MESSAGE_ID_WRITE_LC_INIT] = 0x60,\n\t[HDCP_MESSAGE_ID_READ_LC_SEND_L_PRIME] = 0x80,\n\t[HDCP_MESSAGE_ID_WRITE_SKE_SEND_EKS] = 0x60,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_SEND_RECEIVERID_LIST] = 0x80,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_SEND_ACK] = 0x60,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_STREAM_MANAGE] = 0x60,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_STREAM_READY] = 0x80,\n\t[HDCP_MESSAGE_ID_READ_RXSTATUS] = 0x70,\n\t[HDCP_MESSAGE_ID_WRITE_CONTENT_STREAM_TYPE] = 0x0,\n};\n\nstruct protection_properties {\n\tbool supported;\n\tbool (*process_transaction)(\n\t\tstruct dc_link *link,\n\t\tstruct hdcp_protection_message *message_info);\n};\n\nstatic const struct protection_properties non_supported_protection = {\n\t.supported = false\n};\n\nstatic bool hdmi_14_process_transaction(\n\tstruct dc_link *link,\n\tstruct hdcp_protection_message *message_info)\n{\n\tuint8_t *buff = NULL;\n\tbool result;\n\tconst uint8_t hdcp_i2c_addr_link_primary = 0x3a;  \n\tconst uint8_t hdcp_i2c_addr_link_secondary = 0x3b;  \n\tstruct i2c_command i2c_command;\n\tuint8_t offset = hdcp_i2c_offsets[message_info->msg_id];\n\tstruct i2c_payload i2c_payloads[] = {\n\t\t{ true, 0, 1, &offset },\n\t\t \n\t\t{ 0 }\n\t};\n\n\tswitch (message_info->link) {\n\tcase HDCP_LINK_SECONDARY:\n\t\ti2c_payloads[0].address = hdcp_i2c_addr_link_secondary;\n\t\ti2c_payloads[1].address = hdcp_i2c_addr_link_secondary;\n\t\tbreak;\n\tcase HDCP_LINK_PRIMARY:\n\tdefault:\n\t\ti2c_payloads[0].address = hdcp_i2c_addr_link_primary;\n\t\ti2c_payloads[1].address = hdcp_i2c_addr_link_primary;\n\t\tbreak;\n\t}\n\n\tif (hdcp_cmd_is_read[message_info->msg_id]) {\n\t\ti2c_payloads[1].write = false;\n\t\ti2c_command.number_of_payloads = ARRAY_SIZE(i2c_payloads);\n\t\ti2c_payloads[1].length = message_info->length;\n\t\ti2c_payloads[1].data = message_info->data;\n\t} else {\n\t\ti2c_command.number_of_payloads = 1;\n\t\tbuff = kzalloc(message_info->length + 1, GFP_KERNEL);\n\n\t\tif (!buff)\n\t\t\treturn false;\n\n\t\tbuff[0] = offset;\n\t\tmemmove(&buff[1], message_info->data, message_info->length);\n\t\ti2c_payloads[0].length = message_info->length + 1;\n\t\ti2c_payloads[0].data = buff;\n\t}\n\n\ti2c_command.payloads = i2c_payloads;\n\ti2c_command.engine = I2C_COMMAND_ENGINE_HW;\n\ti2c_command.speed = link->ddc->ctx->dc->caps.i2c_speed_in_khz;\n\n\tresult = dm_helpers_submit_i2c(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\t&i2c_command);\n\tkfree(buff);\n\n\treturn result;\n}\n\nstatic const struct protection_properties hdmi_14_protection = {\n\t.supported = true,\n\t.process_transaction = hdmi_14_process_transaction\n};\n\nstatic const uint32_t hdcp_dpcd_addrs[HDCP_MESSAGE_ID_MAX] = {\n\t[HDCP_MESSAGE_ID_READ_BKSV] = 0x68000,\n\t[HDCP_MESSAGE_ID_READ_RI_R0] = 0x68005,\n\t[HDCP_MESSAGE_ID_READ_PJ] = 0xFFFFFFFF,\n\t[HDCP_MESSAGE_ID_WRITE_AKSV] = 0x68007,\n\t[HDCP_MESSAGE_ID_WRITE_AINFO] = 0x6803B,\n\t[HDCP_MESSAGE_ID_WRITE_AN] = 0x6800c,\n\t[HDCP_MESSAGE_ID_READ_VH_X] = 0x68014,\n\t[HDCP_MESSAGE_ID_READ_VH_0] = 0x68014,\n\t[HDCP_MESSAGE_ID_READ_VH_1] = 0x68018,\n\t[HDCP_MESSAGE_ID_READ_VH_2] = 0x6801c,\n\t[HDCP_MESSAGE_ID_READ_VH_3] = 0x68020,\n\t[HDCP_MESSAGE_ID_READ_VH_4] = 0x68024,\n\t[HDCP_MESSAGE_ID_READ_BCAPS] = 0x68028,\n\t[HDCP_MESSAGE_ID_READ_BSTATUS] = 0x68029,\n\t[HDCP_MESSAGE_ID_READ_KSV_FIFO] = 0x6802c,\n\t[HDCP_MESSAGE_ID_READ_BINFO] = 0x6802a,\n\t[HDCP_MESSAGE_ID_RX_CAPS] = 0x6921d,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_INIT] = 0x69000,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_CERT] = 0x6900b,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_NO_STORED_KM] = 0x69220,\n\t[HDCP_MESSAGE_ID_WRITE_AKE_STORED_KM] = 0x692a0,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_H_PRIME] = 0x692c0,\n\t[HDCP_MESSAGE_ID_READ_AKE_SEND_PAIRING_INFO] = 0x692e0,\n\t[HDCP_MESSAGE_ID_WRITE_LC_INIT] = 0x692f0,\n\t[HDCP_MESSAGE_ID_READ_LC_SEND_L_PRIME] = 0x692f8,\n\t[HDCP_MESSAGE_ID_WRITE_SKE_SEND_EKS] = 0x69318,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_SEND_RECEIVERID_LIST] = 0x69330,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_SEND_ACK] = 0x693e0,\n\t[HDCP_MESSAGE_ID_WRITE_REPEATER_AUTH_STREAM_MANAGE] = 0x693f0,\n\t[HDCP_MESSAGE_ID_READ_REPEATER_AUTH_STREAM_READY] = 0x69473,\n\t[HDCP_MESSAGE_ID_READ_RXSTATUS] = 0x69493,\n\t[HDCP_MESSAGE_ID_WRITE_CONTENT_STREAM_TYPE] = 0x69494\n};\n\nstatic bool dpcd_access_helper(\n\tstruct dc_link *link,\n\tuint32_t length,\n\tuint8_t *data,\n\tuint32_t dpcd_addr,\n\tbool is_read)\n{\n\tenum dc_status status;\n\tuint32_t cur_length = 0;\n\tuint32_t offset = 0;\n\tuint32_t ksv_read_size = 0x6803b - 0x6802c;\n\n\t \n\tif (dpcd_addr == 0x6802c) {\n\t\tif (length % HDCP14_KSV_SIZE) {\n\t\t\tDC_LOG_ERROR(\"%s: KsvFifo Size(%d) is not a multiple of HDCP14_KSV_SIZE(%d)\\n\",\n\t\t\t\t__func__,\n\t\t\t\tlength,\n\t\t\t\tHDCP14_KSV_SIZE);\n\t\t}\n\t\tif (length > HDCP14_MAX_KSV_FIFO_SIZE) {\n\t\t\tDC_LOG_ERROR(\"%s: KsvFifo Size(%d) is greater than HDCP14_MAX_KSV_FIFO_SIZE(%d)\\n\",\n\t\t\t\t__func__,\n\t\t\t\tlength,\n\t\t\t\tHDCP14_MAX_KSV_FIFO_SIZE);\n\t\t}\n\n\t\tDC_LOG_ERROR(\"%s: Reading %d Ksv(s) from KsvFifo\\n\",\n\t\t\t__func__,\n\t\t\tlength / HDCP14_KSV_SIZE);\n\n\t\twhile (length > 0) {\n\t\t\tif (length > ksv_read_size) {\n\t\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tdpcd_addr + offset,\n\t\t\t\t\tdata + offset,\n\t\t\t\t\tksv_read_size);\n\n\t\t\t\tdata += ksv_read_size;\n\t\t\t\tlength -= ksv_read_size;\n\t\t\t} else {\n\t\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tdpcd_addr + offset,\n\t\t\t\t\tdata + offset,\n\t\t\t\t\tlength);\n\n\t\t\t\tdata += length;\n\t\t\t\tlength = 0;\n\t\t\t}\n\n\t\t\tif (status != DC_OK)\n\t\t\t\treturn false;\n\t\t}\n\t} else {\n\t\twhile (length > 0) {\n\t\t\tif (length > DEFAULT_AUX_MAX_DATA_SIZE)\n\t\t\t\tcur_length = DEFAULT_AUX_MAX_DATA_SIZE;\n\t\t\telse\n\t\t\t\tcur_length = length;\n\n\t\t\tif (is_read) {\n\t\t\t\tstatus = core_link_read_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tdpcd_addr + offset,\n\t\t\t\t\tdata + offset,\n\t\t\t\t\tcur_length);\n\t\t\t} else {\n\t\t\t\tstatus = core_link_write_dpcd(\n\t\t\t\t\tlink,\n\t\t\t\t\tdpcd_addr + offset,\n\t\t\t\t\tdata + offset,\n\t\t\t\t\tcur_length);\n\t\t\t}\n\n\t\t\tif (status != DC_OK)\n\t\t\t\treturn false;\n\n\t\t\tlength -= cur_length;\n\t\t\toffset += cur_length;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool dp_11_process_transaction(\n\tstruct dc_link *link,\n\tstruct hdcp_protection_message *message_info)\n{\n\treturn dpcd_access_helper(\n\t\tlink,\n\t\tmessage_info->length,\n\t\tmessage_info->data,\n\t\thdcp_dpcd_addrs[message_info->msg_id],\n\t\thdcp_cmd_is_read[message_info->msg_id]);\n}\n\nstatic const struct protection_properties dp_11_protection = {\n\t.supported = true,\n\t.process_transaction = dp_11_process_transaction\n};\n\nstatic const struct protection_properties *get_protection_properties_by_signal(\n\tstruct dc_link *link,\n\tenum signal_type st,\n\tenum hdcp_version version)\n{\n\tswitch (version) {\n\tcase HDCP_VERSION_14:\n\t\tswitch (st) {\n\t\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\t\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\t\treturn &hdmi_14_protection;\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\t\tif (link &&\n\t\t\t\t(link->dpcd_caps.dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER ||\n\t\t\t\tlink->dpcd_caps.dongle_caps.dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER)) {\n\t\t\t\treturn &non_supported_protection;\n\t\t\t}\n\t\t\treturn &dp_11_protection;\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tcase SIGNAL_TYPE_EDP:\n\t\t\treturn &dp_11_protection;\n\t\tdefault:\n\t\t\treturn &non_supported_protection;\n\t\t}\n\t\tbreak;\n\tcase HDCP_VERSION_22:\n\t\tswitch (st) {\n\t\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\t\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\t\treturn &hdmi_14_protection; \n\t\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tcase SIGNAL_TYPE_EDP:\n\t\t\treturn &dp_11_protection;  \n\t\tdefault:\n\t\t\treturn &non_supported_protection;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn &non_supported_protection;\n\t}\n}\n\nenum hdcp_message_status dc_process_hdcp_msg(\n\tenum signal_type signal,\n\tstruct dc_link *link,\n\tstruct hdcp_protection_message *message_info)\n{\n\tenum hdcp_message_status status = HDCP_MESSAGE_FAILURE;\n\tuint32_t i = 0;\n\n\tconst struct protection_properties *protection_props;\n\n\tif (!message_info)\n\t\treturn HDCP_MESSAGE_UNSUPPORTED;\n\n\tif (message_info->msg_id < HDCP_MESSAGE_ID_READ_BKSV ||\n\t\tmessage_info->msg_id >= HDCP_MESSAGE_ID_MAX)\n\t\treturn HDCP_MESSAGE_UNSUPPORTED;\n\n\tprotection_props =\n\t\tget_protection_properties_by_signal(\n\t\t\tlink,\n\t\t\tsignal,\n\t\t\tmessage_info->version);\n\n\tif (!protection_props->supported)\n\t\treturn HDCP_MESSAGE_UNSUPPORTED;\n\n\tif (protection_props->process_transaction(\n\t\tlink,\n\t\tmessage_info)) {\n\t\tstatus = HDCP_MESSAGE_SUCCESS;\n\t} else {\n\t\tfor (i = 0; i < message_info->max_retries; i++) {\n\t\t\tif (protection_props->process_transaction(\n\t\t\t\t\t\tlink,\n\t\t\t\t\t\tmessage_info)) {\n\t\t\t\tstatus = HDCP_MESSAGE_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}