{
  "module_name": "dcn10_link_encoder.c",
  "hash_id": "904a22adb2c02cf56adb3e55abba8c762274c7357acd316e9f34578f756a99ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dcn10_link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"dc_bios_types.h\"\n\n#include \"gpio_service_interface.h\"\n\n#define CTX \\\n\tenc10->base.ctx\n#define DC_LOGGER \\\n\tenc10->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc10->link_regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc10->link_shift->field_name, enc10->link_mask->field_name\n\n\n \n#define DCN10_DIG_FE_SOURCE_SELECT_INVALID 0x0\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGA 0x1\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGB 0x2\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGC 0x4\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGD 0x08\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGE 0x10\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGF 0x20\n#define DCN10_DIG_FE_SOURCE_SELECT_DIGG 0x40\n\nenum {\n\tDP_MST_UPDATE_MAX_RETRY = 50\n};\n\nstatic const struct link_encoder_funcs dcn10_lnk_enc_funcs = {\n\t.validate_output_with_stream =\n\t\tdcn10_link_encoder_validate_output_with_stream,\n\t.hw_init = dcn10_link_encoder_hw_init,\n\t.setup = dcn10_link_encoder_setup,\n\t.enable_tmds_output = dcn10_link_encoder_enable_tmds_output,\n\t.enable_dp_output = dcn10_link_encoder_enable_dp_output,\n\t.enable_dp_mst_output = dcn10_link_encoder_enable_dp_mst_output,\n\t.disable_output = dcn10_link_encoder_disable_output,\n\t.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,\n\t.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,\n\t.update_mst_stream_allocation_table =\n\t\tdcn10_link_encoder_update_mst_stream_allocation_table,\n\t.psr_program_dp_dphy_fast_training =\n\t\t\tdcn10_psr_program_dp_dphy_fast_training,\n\t.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,\n\t.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,\n\t.enable_hpd = dcn10_link_encoder_enable_hpd,\n\t.disable_hpd = dcn10_link_encoder_disable_hpd,\n\t.is_dig_enabled = dcn10_is_dig_enabled,\n\t.get_dig_frontend = dcn10_get_dig_frontend,\n\t.get_dig_mode = dcn10_get_dig_mode,\n\t.destroy = dcn10_link_encoder_destroy,\n\t.get_max_link_cap = dcn10_link_encoder_get_max_link_cap,\n};\n\nstatic enum bp_result link_transmitter_control(\n\tstruct dcn10_link_encoder *enc10,\n\tstruct bp_transmitter_control *cntl)\n{\n\tenum bp_result result;\n\tstruct dc_bios *bp = enc10->base.ctx->dc_bios;\n\n\tresult = bp->funcs->transmitter_control(bp, cntl);\n\n\treturn result;\n}\n\nstatic void enable_phy_bypass_mode(\n\tstruct dcn10_link_encoder *enc10,\n\tbool enable)\n{\n\t \n\tREG_UPDATE(DP_DPHY_CNTL, DPHY_BYPASS, enable);\n\n}\n\nstatic void disable_prbs_symbols(\n\tstruct dcn10_link_encoder *enc10,\n\tbool disable)\n{\n\t \n\tREG_UPDATE_4(DP_DPHY_CNTL,\n\t\t\tDPHY_ATEST_SEL_LANE0, disable,\n\t\t\tDPHY_ATEST_SEL_LANE1, disable,\n\t\t\tDPHY_ATEST_SEL_LANE2, disable,\n\t\t\tDPHY_ATEST_SEL_LANE3, disable);\n}\n\nstatic void disable_prbs_mode(\n\tstruct dcn10_link_encoder *enc10)\n{\n\tREG_UPDATE(DP_DPHY_PRBS_CNTL, DPHY_PRBS_EN, 0);\n}\n\nstatic void program_pattern_symbols(\n\tstruct dcn10_link_encoder *enc10,\n\tuint16_t pattern_symbols[8])\n{\n\t \n\tREG_SET_3(DP_DPHY_SYM0, 0,\n\t\t\tDPHY_SYM1, pattern_symbols[0],\n\t\t\tDPHY_SYM2, pattern_symbols[1],\n\t\t\tDPHY_SYM3, pattern_symbols[2]);\n\n\t \n\tREG_SET_3(DP_DPHY_SYM1, 0,\n\t\t\tDPHY_SYM4, pattern_symbols[3],\n\t\t\tDPHY_SYM5, pattern_symbols[4],\n\t\t\tDPHY_SYM6, pattern_symbols[5]);\n\n\t \n\tREG_SET_2(DP_DPHY_SYM2, 0,\n\t\t\tDPHY_SYM7, pattern_symbols[6],\n\t\t\tDPHY_SYM8, pattern_symbols[7]);\n}\n\nstatic void set_dp_phy_pattern_d102(\n\tstruct dcn10_link_encoder *enc10)\n{\n\t \n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\tdisable_prbs_symbols(enc10, true);\n\n\t \n\tdisable_prbs_mode(enc10);\n\n\t \n\t{\n\t\tuint16_t pattern_symbols[8] = {\n\t\t\t0x2AA, 0x2AA, 0x2AA, 0x2AA,\n\t\t\t0x2AA, 0x2AA, 0x2AA, 0x2AA\n\t\t};\n\n\t\tprogram_pattern_symbols(enc10, pattern_symbols);\n\t}\n\n\t \n\n\tenable_phy_bypass_mode(enc10, true);\n}\n\nstatic void set_link_training_complete(\n\tstruct dcn10_link_encoder *enc10,\n\tbool complete)\n{\n\t \n\tREG_UPDATE(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, complete);\n\n}\n\nvoid dcn10_link_encoder_set_dp_phy_pattern_training_pattern(\n\tstruct link_encoder *enc,\n\tuint32_t index)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\t \n\n\tREG_WRITE(DP_DPHY_TRAINING_PATTERN_SEL, index);\n\n\t \n\n\tset_link_training_complete(enc10, false);\n\n\t \n\n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\tdisable_prbs_mode(enc10);\n}\n\nstatic void setup_panel_mode(\n\tstruct dcn10_link_encoder *enc10,\n\tenum dp_panel_mode panel_mode)\n{\n\tuint32_t value;\n\n\tif (!REG(DP_DPHY_INTERNAL_CTRL))\n\t\treturn;\n\n\tvalue = REG_READ(DP_DPHY_INTERNAL_CTRL);\n\n\tswitch (panel_mode) {\n\tcase DP_PANEL_MODE_EDP:\n\t\tvalue = 0x1;\n\t\tbreak;\n\tcase DP_PANEL_MODE_SPECIAL:\n\t\tvalue = 0x11;\n\t\tbreak;\n\tdefault:\n\t\tvalue = 0x0;\n\t\tbreak;\n\t}\n\n\tREG_WRITE(DP_DPHY_INTERNAL_CTRL, value);\n}\n\nstatic void set_dp_phy_pattern_symbol_error(\n\tstruct dcn10_link_encoder *enc10)\n{\n\t \n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\tsetup_panel_mode(enc10, DP_PANEL_MODE_DEFAULT);\n\n\t \n\n\t \n\tdisable_prbs_symbols(enc10, false);\n\n\t \n\tREG_UPDATE_2(DP_DPHY_PRBS_CNTL,\n\t\t\tDPHY_PRBS_SEL, 1,\n\t\t\tDPHY_PRBS_EN, 1);\n\n\t \n\tenable_phy_bypass_mode(enc10, true);\n}\n\nstatic void set_dp_phy_pattern_prbs7(\n\tstruct dcn10_link_encoder *enc10)\n{\n\t \n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\n\t \n\tdisable_prbs_symbols(enc10, false);\n\n\t \n\tREG_UPDATE_2(DP_DPHY_PRBS_CNTL,\n\t\t\tDPHY_PRBS_SEL, 0,\n\t\t\tDPHY_PRBS_EN, 1);\n\n\t \n\tenable_phy_bypass_mode(enc10, true);\n}\n\nstatic void set_dp_phy_pattern_80bit_custom(\n\tstruct dcn10_link_encoder *enc10,\n\tconst uint8_t *pattern)\n{\n\t \n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\n\tdisable_prbs_symbols(enc10, true);\n\n\t \n\t \n\n\tenable_phy_bypass_mode(enc10, true);\n\n\t \n\t{\n\t\tuint16_t pattern_symbols[8];\n\n\t\tpattern_symbols[0] =\n\t\t\t((pattern[1] & 0x03) << 8) | pattern[0];\n\t\tpattern_symbols[1] =\n\t\t\t((pattern[2] & 0x0f) << 6) | ((pattern[1] >> 2) & 0x3f);\n\t\tpattern_symbols[2] =\n\t\t\t((pattern[3] & 0x3f) << 4) | ((pattern[2] >> 4) & 0x0f);\n\t\tpattern_symbols[3] =\n\t\t\t(pattern[4] << 2) | ((pattern[3] >> 6) & 0x03);\n\t\tpattern_symbols[4] =\n\t\t\t((pattern[6] & 0x03) << 8) | pattern[5];\n\t\tpattern_symbols[5] =\n\t\t\t((pattern[7] & 0x0f) << 6) | ((pattern[6] >> 2) & 0x3f);\n\t\tpattern_symbols[6] =\n\t\t\t((pattern[8] & 0x3f) << 4) | ((pattern[7] >> 4) & 0x0f);\n\t\tpattern_symbols[7] =\n\t\t\t(pattern[9] << 2) | ((pattern[8] >> 6) & 0x03);\n\n\t\tprogram_pattern_symbols(enc10, pattern_symbols);\n\t}\n\n\t \n\n\tenable_phy_bypass_mode(enc10, true);\n}\n\nstatic void set_dp_phy_pattern_hbr2_compliance_cp2520_2(\n\tstruct dcn10_link_encoder *enc10,\n\tunsigned int cp2520_pattern)\n{\n\n\t \n\n\t \n\n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\tenc10->base.funcs->setup(&enc10->base, SIGNAL_TYPE_DISPLAY_PORT);\n\n\t \n\tsetup_panel_mode(enc10, DP_PANEL_MODE_DEFAULT);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0xFC,\n\t\t\tDP_VBID_DISABLE, 1,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\t \n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_BS_COUNT, 0);\n\n\t \n\tif (REG(DP_DPHY_HBR2_PATTERN_CONTROL))\n\t\tREG_UPDATE(DP_DPHY_HBR2_PATTERN_CONTROL,\n\t\t\t\tDP_DPHY_HBR2_PATTERN_CONTROL, cp2520_pattern);\n\telse\n\t\t \n\t\tASSERT(cp2520_pattern == 2);\n\n\t \n\tset_link_training_complete(enc10, true);\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, 0);\n\n\t \n\tenable_phy_bypass_mode(enc10, false);\n}\n\nstatic void set_dp_phy_pattern_passthrough_mode(\n\tstruct dcn10_link_encoder *enc10,\n\tenum dp_panel_mode panel_mode)\n{\n\t \n\tsetup_panel_mode(enc10, panel_mode);\n\n\t \n\tREG_UPDATE_3(DP_LINK_FRAMING_CNTL,\n\t\t\tDP_IDLE_BS_INTERVAL, 0x2000,\n\t\t\tDP_VBID_DISABLE, 0,\n\t\t\tDP_VID_ENHANCED_FRAME_MODE, 1);\n\n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_BS_COUNT, 0x1FF);\n\n\t \n\tset_link_training_complete(enc10, true);\n\n\t \n\tenable_phy_bypass_mode(enc10, false);\n\n\t \n\tdisable_prbs_mode(enc10);\n}\n\n \nstatic uint8_t get_frontend_source(\n\tenum engine_id engine)\n{\n\tswitch (engine) {\n\tcase ENGINE_ID_DIGA:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGA;\n\tcase ENGINE_ID_DIGB:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGB;\n\tcase ENGINE_ID_DIGC:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGC;\n\tcase ENGINE_ID_DIGD:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGD;\n\tcase ENGINE_ID_DIGE:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGE;\n\tcase ENGINE_ID_DIGF:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGF;\n\tcase ENGINE_ID_DIGG:\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_DIGG;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\treturn DCN10_DIG_FE_SOURCE_SELECT_INVALID;\n\t}\n}\n\nunsigned int dcn10_get_dig_frontend(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tint32_t value;\n\tenum engine_id result;\n\n\tREG_GET(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, &value);\n\n\tswitch (value) {\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGA:\n\t\tresult = ENGINE_ID_DIGA;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGB:\n\t\tresult = ENGINE_ID_DIGB;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGC:\n\t\tresult = ENGINE_ID_DIGC;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGD:\n\t\tresult = ENGINE_ID_DIGD;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGE:\n\t\tresult = ENGINE_ID_DIGE;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGF:\n\t\tresult = ENGINE_ID_DIGF;\n\t\tbreak;\n\tcase DCN10_DIG_FE_SOURCE_SELECT_DIGG:\n\t\tresult = ENGINE_ID_DIGG;\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tresult = ENGINE_ID_UNKNOWN;\n\t}\n\n\treturn result;\n\n}\n\nvoid enc1_configure_encoder(\n\tstruct dcn10_link_encoder *enc10,\n\tconst struct dc_link_settings *link_settings)\n{\n\t \n\tREG_SET(DP_CONFIG, 0,\n\t\t\tDP_UDI_LANES, link_settings->lane_count - LANE_COUNT_ONE);\n\n\t \n\tREG_UPDATE(DP_DPHY_SCRAM_CNTL, DPHY_SCRAMBLER_ADVANCE, 1);\n}\n\nvoid dcn10_psr_program_dp_dphy_fast_training(struct link_encoder *enc,\n\t\t\tbool exit_link_training_required)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tif (exit_link_training_required)\n\t\tREG_UPDATE(DP_DPHY_FAST_TRAINING,\n\t\t\t\tDPHY_RX_FAST_TRAINING_CAPABLE, 1);\n\telse {\n\t\tREG_UPDATE(DP_DPHY_FAST_TRAINING,\n\t\t\t\tDPHY_RX_FAST_TRAINING_CAPABLE, 0);\n\t\t \n\n\t\tREG_UPDATE(DP_DPHY_BS_SR_SWAP_CNTL, DPHY_LOAD_BS_COUNT, 0x5);\n\t}\n}\n\nvoid dcn10_psr_program_secondary_packet(struct link_encoder *enc,\n\t\t\tunsigned int sdp_transmit_line_num_deadline)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tREG_UPDATE_2(DP_SEC_CNTL1,\n\t\tDP_SEC_GSP0_LINE_NUM, sdp_transmit_line_num_deadline,\n\t\tDP_SEC_GSP0_PRIORITY, 1);\n}\n\nbool dcn10_is_dig_enabled(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t value;\n\n\tREG_GET(DIG_BE_EN_CNTL, DIG_ENABLE, &value);\n\treturn value;\n}\n\nstatic void link_encoder_disable(struct dcn10_link_encoder *enc10)\n{\n\t \n\tREG_SET(DP_DPHY_TRAINING_PATTERN_SEL, 0,\n\t\t\tDPHY_TRAINING_PATTERN_SEL, 0);\n\n\t \n\tREG_UPDATE(DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE, 0);\n\n\t \n\tsetup_panel_mode(enc10, DP_PANEL_MODE_DEFAULT);\n}\n\nstatic void hpd_initialize(\n\tstruct dcn10_link_encoder *enc10)\n{\n\t \n\tenum hpd_source_id hpd_source = enc10->base.hpd_source;\n\n\tREG_UPDATE(DIG_BE_CNTL, DIG_HPD_SELECT, hpd_source);\n}\n\nbool dcn10_link_encoder_validate_dvi_output(\n\tconst struct dcn10_link_encoder *enc10,\n\tenum signal_type connector_signal,\n\tenum signal_type signal,\n\tconst struct dc_crtc_timing *crtc_timing)\n{\n\tuint32_t max_pixel_clock = TMDS_MAX_PIXEL_CLOCK;\n\n\tif (signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\tmax_pixel_clock *= 2;\n\n\t \n\tif (connector_signal != SIGNAL_TYPE_DVI_DUAL_LINK &&\n\t\t\tconnector_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)\n\t\tmax_pixel_clock = enc10->base.features.max_hdmi_pixel_clock;\n\n\t \n\tif (crtc_timing->pixel_encoding != PIXEL_ENCODING_RGB)\n\t\treturn false;\n\n\t \n\tif ((connector_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||\n\t\tconnector_signal == SIGNAL_TYPE_HDMI_TYPE_A) &&\n\t\tsignal != SIGNAL_TYPE_HDMI_TYPE_A &&\n\t\tcrtc_timing->pix_clk_100hz > (TMDS_MAX_PIXEL_CLOCK * 10))\n\t\treturn false;\n\tif (crtc_timing->pix_clk_100hz < (TMDS_MIN_PIXEL_CLOCK * 10))\n\t\treturn false;\n\n\tif (crtc_timing->pix_clk_100hz > (max_pixel_clock * 10))\n\t\treturn false;\n\n\t \n\tswitch (crtc_timing->display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\tcase COLOR_DEPTH_888:\n\tbreak;\n\tcase COLOR_DEPTH_101010:\n\tcase COLOR_DEPTH_161616:\n\t\tif (signal != SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\treturn false;\n\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool dcn10_link_encoder_validate_hdmi_output(\n\tconst struct dcn10_link_encoder *enc10,\n\tconst struct dc_crtc_timing *crtc_timing,\n\tconst struct dc_edid_caps *edid_caps,\n\tint adjusted_pix_clk_100hz)\n{\n\tenum dc_color_depth max_deep_color =\n\t\t\tenc10->base.features.max_hdmi_deep_color;\n\n\t \n\tif (edid_caps->max_tmds_clk_mhz != 0 &&\n\t\t\tadjusted_pix_clk_100hz > edid_caps->max_tmds_clk_mhz * 10000)\n\t\treturn false;\n\n\tif (max_deep_color < crtc_timing->display_color_depth)\n\t\treturn false;\n\n\tif (crtc_timing->display_color_depth < COLOR_DEPTH_888)\n\t\treturn false;\n\tif (adjusted_pix_clk_100hz < (TMDS_MIN_PIXEL_CLOCK * 10))\n\t\treturn false;\n\n\tif ((adjusted_pix_clk_100hz == 0) ||\n\t\t(adjusted_pix_clk_100hz > (enc10->base.features.max_hdmi_pixel_clock * 10)))\n\t\treturn false;\n\n\t \n\tif (!enc10->base.features.hdmi_ycbcr420_supported &&\n\t\t\tcrtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\treturn false;\n\n\tif ((!enc10->base.features.flags.bits.HDMI_6GB_EN ||\n\t\t\tenc10->base.ctx->dc->debug.hdmi20_disable) &&\n\t\t\tadjusted_pix_clk_100hz >= 3000000)\n\t\treturn false;\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable &&\n\t\tcrtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\treturn false;\n\treturn true;\n}\n\nbool dcn10_link_encoder_validate_dp_output(\n\tconst struct dcn10_link_encoder *enc10,\n\tconst struct dc_crtc_timing *crtc_timing)\n{\n\tif (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) {\n\t\tif (!enc10->base.features.dp_ycbcr420_supported)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid dcn10_link_encoder_construct(\n\tstruct dcn10_link_encoder *enc10,\n\tconst struct encoder_init_data *init_data,\n\tconst struct encoder_feature_support *enc_features,\n\tconst struct dcn10_link_enc_registers *link_regs,\n\tconst struct dcn10_link_enc_aux_registers *aux_regs,\n\tconst struct dcn10_link_enc_hpd_registers *hpd_regs,\n\tconst struct dcn10_link_enc_shift *link_shift,\n\tconst struct dcn10_link_enc_mask *link_mask)\n{\n\tstruct bp_encoder_cap_info bp_cap_info = {0};\n\tconst struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;\n\tenum bp_result result = BP_RESULT_OK;\n\n\tenc10->base.funcs = &dcn10_lnk_enc_funcs;\n\tenc10->base.ctx = init_data->ctx;\n\tenc10->base.id = init_data->encoder;\n\n\tenc10->base.hpd_source = init_data->hpd_source;\n\tenc10->base.connector = init_data->connector;\n\n\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\n\tenc10->base.features = *enc_features;\n\n\tenc10->base.transmitter = init_data->transmitter;\n\n\t \n\n \n\n\tenc10->base.output_signals =\n\t\tSIGNAL_TYPE_DVI_SINGLE_LINK |\n\t\tSIGNAL_TYPE_DVI_DUAL_LINK |\n\t\tSIGNAL_TYPE_LVDS |\n\t\tSIGNAL_TYPE_DISPLAY_PORT |\n\t\tSIGNAL_TYPE_DISPLAY_PORT_MST |\n\t\tSIGNAL_TYPE_EDP |\n\t\tSIGNAL_TYPE_HDMI_TYPE_A;\n\n\t \n\n\tenc10->link_regs = link_regs;\n\tenc10->aux_regs = aux_regs;\n\tenc10->hpd_regs = hpd_regs;\n\tenc10->link_shift = link_shift;\n\tenc10->link_mask = link_mask;\n\n\tswitch (enc10->base.transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGA;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGB;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGC;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGD;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGE;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGF;\n\tbreak;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\tenc10->base.preferred_engine = ENGINE_ID_DIGG;\n\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\tenc10->base.preferred_engine = ENGINE_ID_UNKNOWN;\n\t}\n\n\t \n\tenc10->base.features.flags.bits.HDMI_6GB_EN = 1;\n\n\tresult = bp_funcs->get_encoder_cap_info(enc10->base.ctx->dc_bios,\n\t\t\t\t\t\tenc10->base.id, &bp_cap_info);\n\n\t \n\tif (result == BP_RESULT_OK) {\n\t\tenc10->base.features.flags.bits.IS_HBR2_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR2_EN;\n\t\tenc10->base.features.flags.bits.IS_HBR3_CAPABLE =\n\t\t\t\tbp_cap_info.DP_HBR3_EN;\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;\n\t\tenc10->base.features.flags.bits.DP_IS_USB_C =\n\t\t\t\tbp_cap_info.DP_IS_USB_C;\n\t} else {\n\t\tDC_LOG_WARNING(\"%s: Failed to get encoder_cap_info from VBIOS with error code %d!\\n\",\n\t\t\t\t__func__,\n\t\t\t\tresult);\n\t}\n\tif (enc10->base.ctx->dc->debug.hdmi20_disable) {\n\t\tenc10->base.features.flags.bits.HDMI_6GB_EN = 0;\n\t}\n}\n\nbool dcn10_link_encoder_validate_output_with_stream(\n\tstruct link_encoder *enc,\n\tconst struct dc_stream_state *stream)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tbool is_valid;\n\n\t \n\tif (stream->sink->edid_caps.panel_patch.skip_scdc_overwrite &&\n\t\tenc10->base.features.max_hdmi_pixel_clock > 300000)\n\t\tenc10->base.features.max_hdmi_pixel_clock = 300000;\n\n\tswitch (stream->signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\tis_valid = dcn10_link_encoder_validate_dvi_output(\n\t\t\tenc10,\n\t\t\tstream->link->connector_signal,\n\t\t\tstream->signal,\n\t\t\t&stream->timing);\n\tbreak;\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tis_valid = dcn10_link_encoder_validate_hdmi_output(\n\t\t\t\tenc10,\n\t\t\t\t&stream->timing,\n\t\t\t\t&stream->sink->edid_caps,\n\t\t\t\tstream->phy_pix_clk * 10);\n\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tis_valid = dcn10_link_encoder_validate_dp_output(\n\t\t\t\t\tenc10, &stream->timing);\n\tbreak;\n\tcase SIGNAL_TYPE_EDP:\n\t\tis_valid = (stream->timing.pixel_encoding == PIXEL_ENCODING_RGB) ? true : false;\n\tbreak;\n\tcase SIGNAL_TYPE_VIRTUAL:\n\t\tis_valid = true;\n\t\tbreak;\n\tdefault:\n\t\tis_valid = false;\n\tbreak;\n\t}\n\n\treturn is_valid;\n}\n\nvoid dcn10_link_encoder_hw_init(\n\tstruct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\tcntl.action = TRANSMITTER_CONTROL_INIT;\n\tcntl.engine_id = ENGINE_ID_UNKNOWN;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.connector_obj_id = enc10->base.connector;\n\tcntl.lanes_number = LANE_COUNT_FOUR;\n\tcntl.coherent = false;\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\n\tif (enc10->base.connector.id == CONNECTOR_ID_EDP)\n\t\tcntl.signal = SIGNAL_TYPE_EDP;\n\n\tresult = link_transmitter_control(enc10, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (enc10->base.connector.id == CONNECTOR_ID_LVDS) {\n\t\tcntl.action = TRANSMITTER_CONTROL_BACKLIGHT_BRIGHTNESS;\n\n\t\tresult = link_transmitter_control(enc10, &cntl);\n\n\t\tASSERT(result == BP_RESULT_OK);\n\n\t}\n\tdcn10_aux_initialize(enc10);\n\n\t \n\thpd_initialize(enc10);\n}\n\nvoid dcn10_link_encoder_destroy(struct link_encoder **enc)\n{\n\tkfree(TO_DCN10_LINK_ENC(*enc));\n\t*enc = NULL;\n}\n\nvoid dcn10_link_encoder_setup(\n\tstruct link_encoder *enc,\n\tenum signal_type signal)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tswitch (signal) {\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 0);\n\t\tbreak;\n\tcase SIGNAL_TYPE_LVDS:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 1);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 2);\n\t\tbreak;\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 3);\n\t\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\t \n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_MODE, 5);\n\t\tbreak;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n \nvoid dcn10_link_encoder_enable_tmds_output(\n\tstruct link_encoder *enc,\n\tenum clock_source_id clock_source,\n\tenum dc_color_depth color_depth,\n\tenum signal_type signal,\n\tuint32_t pixel_clock)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = signal;\n\tif (cntl.signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\tcntl.lanes_number = 8;\n\telse\n\t\tcntl.lanes_number = 4;\n\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\n\tcntl.pixel_clock = pixel_clock;\n\tcntl.color_depth = color_depth;\n\n\tresult = link_transmitter_control(enc10, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\nvoid dcn10_link_encoder_enable_tmds_output_with_clk_pattern_wa(\n\tstruct link_encoder *enc,\n\tenum clock_source_id clock_source,\n\tenum dc_color_depth color_depth,\n\tenum signal_type signal,\n\tuint32_t pixel_clock)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tdcn10_link_encoder_enable_tmds_output(\n\t\tenc, clock_source, color_depth, signal, pixel_clock);\n\n\tREG_UPDATE(DIG_CLOCK_PATTERN, DIG_CLOCK_PATTERN, 0x1F);\n}\n\n \nvoid dcn10_link_encoder_enable_dp_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tenc1_configure_encoder(enc10, link_settings);\n\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = enc->preferred_engine;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc10, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n\n \nvoid dcn10_link_encoder_enable_dp_mst_output(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tenum clock_source_id clock_source)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\t \n\n\t \n\tenc1_configure_encoder(enc10, link_settings);\n\n\tcntl.action = TRANSMITTER_CONTROL_ENABLE;\n\tcntl.engine_id = ENGINE_ID_UNKNOWN;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.pll_id = clock_source;\n\tcntl.signal = SIGNAL_TYPE_DISPLAY_PORT_MST;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate\n\t\t\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ;\n\t \n\tcntl.color_depth = COLOR_DEPTH_UNDEFINED;\n\n\tresult = link_transmitter_control(enc10, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t}\n}\n \nvoid dcn10_link_encoder_disable_output(\n\tstruct link_encoder *enc,\n\tenum signal_type signal)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tstruct bp_transmitter_control cntl = { 0 };\n\tenum bp_result result;\n\n\tif (enc->funcs->is_dig_enabled && !enc->funcs->is_dig_enabled(enc)) {\n\t\t \n\t \n\t\treturn;\n\t}\n\t \n\n\t \n\n\t \n\tcntl.action = TRANSMITTER_CONTROL_DISABLE;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\tcntl.signal = signal;\n\tcntl.connector_obj_id = enc10->base.connector;\n\n\tresult = link_transmitter_control(enc10, &cntl);\n\n\tif (result != BP_RESULT_OK) {\n\t\tDC_LOG_ERROR(\"%s: Failed to execute VBIOS command table!\\n\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t \n\tif (dc_is_dp_signal(signal))\n\t\tlink_encoder_disable(enc10);\n}\n\nvoid dcn10_link_encoder_dp_set_lane_settings(\n\tstruct link_encoder *enc,\n\tconst struct dc_link_settings *link_settings,\n\tconst struct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX])\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tunion dpcd_training_lane_set training_lane_set = { { 0 } };\n\tint32_t lane = 0;\n\tstruct bp_transmitter_control cntl = { 0 };\n\n\tif (!link_settings) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tcntl.action = TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS;\n\tcntl.transmitter = enc10->base.transmitter;\n\tcntl.connector_obj_id = enc10->base.connector;\n\tcntl.lanes_number = link_settings->lane_count;\n\tcntl.hpd_sel = enc10->base.hpd_source;\n\tcntl.pixel_clock = link_settings->link_rate * LINK_RATE_REF_FREQ_IN_KHZ;\n\n\tfor (lane = 0; lane < link_settings->lane_count; lane++) {\n\t\t \n\n\t\ttraining_lane_set.bits.VOLTAGE_SWING_SET =\n\t\t\t\tlane_settings[lane].VOLTAGE_SWING;\n\t\ttraining_lane_set.bits.PRE_EMPHASIS_SET =\n\t\t\t\tlane_settings[lane].PRE_EMPHASIS;\n\n\t\t \n\t\tif (link_settings->link_rate == LINK_RATE_HIGH2) {\n\t\t\t \n\t\t\ttraining_lane_set.bits.POST_CURSOR2_SET =\n\t\t\t\t\tlane_settings[lane].POST_CURSOR2;\n\t\t}\n\n\t\tcntl.lane_select = lane;\n\t\tcntl.lane_settings = training_lane_set.raw;\n\n\t\t \n\t\tlink_transmitter_control(enc10, &cntl);\n\t}\n}\n\n \nvoid dcn10_link_encoder_dp_set_phy_pattern(\n\tstruct link_encoder *enc,\n\tconst struct encoder_set_dp_phy_pattern_param *param)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tswitch (param->dp_phy_pattern) {\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN1:\n\t\tdcn10_link_encoder_set_dp_phy_pattern_training_pattern(enc, 0);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN2:\n\t\tdcn10_link_encoder_set_dp_phy_pattern_training_pattern(enc, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN3:\n\t\tdcn10_link_encoder_set_dp_phy_pattern_training_pattern(enc, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN4:\n\t\tdcn10_link_encoder_set_dp_phy_pattern_training_pattern(enc, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_D102:\n\t\tset_dp_phy_pattern_d102(enc10);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_SYMBOL_ERROR:\n\t\tset_dp_phy_pattern_symbol_error(enc10);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_PRBS7:\n\t\tset_dp_phy_pattern_prbs7(enc10);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_80BIT_CUSTOM:\n\t\tset_dp_phy_pattern_80bit_custom(\n\t\t\tenc10, param->custom_pattern);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_1:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc10, 1);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_2:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc10, 2);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_CP2520_3:\n\t\tset_dp_phy_pattern_hbr2_compliance_cp2520_2(enc10, 3);\n\t\tbreak;\n\tcase DP_TEST_PATTERN_VIDEO_MODE: {\n\t\tset_dp_phy_pattern_passthrough_mode(\n\t\t\tenc10, param->dp_panel_mode);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\tASSERT_CRITICAL(false);\n\t\tbreak;\n\t}\n}\n\nstatic void fill_stream_allocation_row_info(\n\tconst struct link_mst_stream_allocation *stream_allocation,\n\tuint32_t *src,\n\tuint32_t *slots)\n{\n\tconst struct stream_encoder *stream_enc = stream_allocation->stream_enc;\n\n\tif (stream_enc) {\n\t\t*src = stream_enc->id;\n\t\t*slots = stream_allocation->slot_count;\n\t} else {\n\t\t*src = 0;\n\t\t*slots = 0;\n\t}\n}\n\n \nvoid dcn10_link_encoder_update_mst_stream_allocation_table(\n\tstruct link_encoder *enc,\n\tconst struct link_mst_stream_allocation_table *table)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t value1 = 0;\n\tuint32_t value2 = 0;\n\tuint32_t slots = 0;\n\tuint32_t src = 0;\n\tuint32_t retries = 0;\n\n\t \n\n\t \n\n\t \n\n\tif (table->stream_count >= 1) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[0],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT0,\n\t\t\tDP_MSE_SAT_SRC0, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT0, slots);\n\n\tif (table->stream_count >= 2) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[1],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT0,\n\t\t\tDP_MSE_SAT_SRC1, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT1, slots);\n\n\tif (table->stream_count >= 3) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[2],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT1,\n\t\t\tDP_MSE_SAT_SRC2, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT2, slots);\n\n\tif (table->stream_count >= 4) {\n\t\tfill_stream_allocation_row_info(\n\t\t\t&table->stream_allocations[3],\n\t\t\t&src,\n\t\t\t&slots);\n\t} else {\n\t\tsrc = 0;\n\t\tslots = 0;\n\t}\n\n\tREG_UPDATE_2(DP_MSE_SAT1,\n\t\t\tDP_MSE_SAT_SRC3, src,\n\t\t\tDP_MSE_SAT_SLOT_COUNT3, slots);\n\n\t \n\n\t \n\n\t \n\tREG_UPDATE(DP_MSE_SAT_UPDATE,\n\t\t\tDP_MSE_SAT_UPDATE, 1);\n\n\t \n\tdo {\n\t\tudelay(10);\n\n\t\tREG_READ(DP_MSE_SAT_UPDATE);\n\n\t\tREG_GET(DP_MSE_SAT_UPDATE,\n\t\t\t\tDP_MSE_SAT_UPDATE, &value1);\n\n\t\tREG_GET(DP_MSE_SAT_UPDATE,\n\t\t\t\tDP_MSE_16_MTP_KEEPOUT, &value2);\n\n\t\t \n\t\tif (!value1 && !value2)\n\t\t\tbreak;\n\t\t++retries;\n\t} while (retries < DP_MST_UPDATE_MAX_RETRY);\n}\n\nvoid dcn10_link_encoder_connect_dig_be_to_fe(\n\tstruct link_encoder *enc,\n\tenum engine_id engine,\n\tbool connect)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t field;\n\n\tif (engine != ENGINE_ID_UNKNOWN) {\n\n\t\tREG_GET(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, &field);\n\n\t\tif (connect)\n\t\t\tfield |= get_frontend_source(engine);\n\t\telse\n\t\t\tfield &= ~get_frontend_source(engine);\n\n\t\tREG_UPDATE(DIG_BE_CNTL, DIG_FE_SOURCE_SELECT, field);\n\t}\n}\n\n\n#define HPD_REG(reg)\\\n\t(enc10->hpd_regs->reg)\n\n#define HPD_REG_READ(reg_name) \\\n\t\tdm_read_reg(CTX, HPD_REG(reg_name))\n\n#define HPD_REG_UPDATE_N(reg_name, n, ...)\t\\\n\t\tgeneric_reg_update_ex(CTX, \\\n\t\t\t\tHPD_REG(reg_name), \\\n\t\t\t\tn, __VA_ARGS__)\n\n#define HPD_REG_UPDATE(reg_name, field, val)\t\\\n\t\tHPD_REG_UPDATE_N(reg_name, 1, \\\n\t\t\t\tFN(reg_name, field), val)\n\nvoid dcn10_link_encoder_enable_hpd(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tHPD_REG_UPDATE(DC_HPD_CONTROL,\n\t\t\tDC_HPD_EN, 1);\n}\n\nvoid dcn10_link_encoder_disable_hpd(struct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\n\tHPD_REG_UPDATE(DC_HPD_CONTROL,\n\t\t\tDC_HPD_EN, 0);\n}\n\n#define AUX_REG(reg)\\\n\t(enc10->aux_regs->reg)\n\n#define AUX_REG_READ(reg_name) \\\n\t\tdm_read_reg(CTX, AUX_REG(reg_name))\n\n#define AUX_REG_UPDATE_N(reg_name, n, ...)\t\\\n\t\tgeneric_reg_update_ex(CTX, \\\n\t\t\t\tAUX_REG(reg_name), \\\n\t\t\t\tn, __VA_ARGS__)\n\n#define AUX_REG_UPDATE(reg_name, field, val)\t\\\n\t\tAUX_REG_UPDATE_N(reg_name, 1, \\\n\t\t\t\tFN(reg_name, field), val)\n\n#define AUX_REG_UPDATE_2(reg, f1, v1, f2, v2)\t\\\n\t\tAUX_REG_UPDATE_N(reg, 2,\\\n\t\t\t\tFN(reg, f1), v1,\\\n\t\t\t\tFN(reg, f2), v2)\n\nvoid dcn10_aux_initialize(struct dcn10_link_encoder *enc10)\n{\n\tenum hpd_source_id hpd_source = enc10->base.hpd_source;\n\n\tAUX_REG_UPDATE_2(AUX_CONTROL,\n\t\t\tAUX_HPD_SEL, hpd_source,\n\t\t\tAUX_LS_READ_EN, 0);\n\n\t \n\tAUX_REG_UPDATE(AUX_DPHY_RX_CONTROL0,\n\t\t\tAUX_RX_RECEIVE_WINDOW, 0);\n}\n\nenum signal_type dcn10_get_dig_mode(\n\tstruct link_encoder *enc)\n{\n\tstruct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);\n\tuint32_t value;\n\tREG_GET(DIG_BE_CNTL, DIG_MODE, &value);\n\tswitch (value) {\n\tcase 1:\n\t\treturn SIGNAL_TYPE_DISPLAY_PORT;\n\tcase 2:\n\t\treturn SIGNAL_TYPE_DVI_SINGLE_LINK;\n\tcase 3:\n\t\treturn SIGNAL_TYPE_HDMI_TYPE_A;\n\tcase 5:\n\t\treturn SIGNAL_TYPE_DISPLAY_PORT_MST;\n\tdefault:\n\t\treturn SIGNAL_TYPE_NONE;\n\t}\n\treturn SIGNAL_TYPE_NONE;\n}\n\nvoid dcn10_link_encoder_get_max_link_cap(struct link_encoder *enc,\n\tstruct dc_link_settings *link_settings)\n{\n\t \n\tstruct dc_link_settings max_link_cap = {LANE_COUNT_FOUR, LINK_RATE_HIGH,\n\t\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ, false, 0};\n\n\t \n\tif (enc->features.flags.bits.IS_HBR2_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_HIGH2;\n\n\tif (enc->features.flags.bits.IS_HBR3_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_HIGH3;\n\n\tif (enc->features.flags.bits.IS_UHBR10_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_UHBR10;\n\n\tif (enc->features.flags.bits.IS_UHBR13_5_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_UHBR13_5;\n\n\tif (enc->features.flags.bits.IS_UHBR20_CAPABLE)\n\t\tmax_link_cap.link_rate = LINK_RATE_UHBR20;\n\n\t*link_settings = max_link_cap;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}