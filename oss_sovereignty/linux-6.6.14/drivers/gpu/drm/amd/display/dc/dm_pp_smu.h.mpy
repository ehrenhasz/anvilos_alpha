{
  "module_name": "dm_pp_smu.h",
  "hash_id": "da34e2b468cc2c3ef96fd83a9519ee3031cb7eb9c929c2f0fe26389b43cc4e69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dm_pp_smu.h",
  "human_readable_source": " \n\n#ifndef DM_PP_SMU_IF__H\n#define DM_PP_SMU_IF__H\n\n \n\nenum pp_smu_ver {\n\t \n\tPP_SMU_UNSUPPORTED,\n\tPP_SMU_VER_RV,\n\tPP_SMU_VER_NV,\n\tPP_SMU_VER_RN,\n\n\tPP_SMU_VER_MAX\n};\n\nstruct pp_smu {\n\tenum pp_smu_ver ver;\n\tconst void *pp;\n\n\t \n\tconst void *dm;\n};\n\nenum pp_smu_status {\n\tPP_SMU_RESULT_UNDEFINED = 0,\n\tPP_SMU_RESULT_OK = 1,\n\tPP_SMU_RESULT_FAIL,\n\tPP_SMU_RESULT_UNSUPPORTED\n};\n\n#define PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN 0x0\n#define PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX 0xFFFF\n\nenum wm_type {\n\tWM_TYPE_PSTATE_CHG = 0,\n\tWM_TYPE_RETRAINING = 1,\n};\n\n \nstruct pp_smu_wm_set_range {\n\tuint16_t min_fill_clk_mhz;\n\tuint16_t max_fill_clk_mhz;\n\tuint16_t min_drain_clk_mhz;\n\tuint16_t max_drain_clk_mhz;\n\n\tuint8_t wm_inst;\n\tuint8_t wm_type;\n};\n\n#define MAX_WATERMARK_SETS 4\n\nstruct pp_smu_wm_range_sets {\n\tunsigned int num_reader_wm_sets;\n\tstruct pp_smu_wm_set_range reader_wm_sets[MAX_WATERMARK_SETS];\n\n\tunsigned int num_writer_wm_sets;\n\tstruct pp_smu_wm_set_range writer_wm_sets[MAX_WATERMARK_SETS];\n};\n\nstruct pp_smu_funcs_rv {\n\tstruct pp_smu pp_smu;\n\n\t \n\n\tvoid (*set_display_count)(struct pp_smu *pp, int count);\n\n\t \n\t \n\tvoid (*set_wm_ranges)(struct pp_smu *pp,\n\t\t\tstruct pp_smu_wm_range_sets *ranges);\n\n\t \n\tvoid (*set_hard_min_dcfclk_by_freq)(struct pp_smu *pp, int mhz);\n\n\t \n\tvoid (*set_min_deep_sleep_dcfclk)(struct pp_smu *pp, int mhz);\n\n\t \n\tvoid (*set_hard_min_fclk_by_freq)(struct pp_smu *pp, int mhz);\n\n\t \n\tvoid (*set_hard_min_socclk_by_freq)(struct pp_smu *pp, int mhz);\n\n\t \n\tvoid (*set_pme_wa_enable)(struct pp_smu *pp);\n};\n\n \nenum pp_smu_nv_clock_id {\n\tPP_SMU_NV_DISPCLK,\n\tPP_SMU_NV_PHYCLK,\n\tPP_SMU_NV_PIXELCLK\n};\n\n \nstruct pp_smu_nv_clock_table {\n\t \n\tunsigned int    displayClockInKhz;\n\tunsigned int\tdppClockInKhz;\n\tunsigned int    phyClockInKhz;\n\tunsigned int    pixelClockInKhz;\n\tunsigned int\tdscClockInKhz;\n\n\t \n\tunsigned int\tfabricClockInKhz;\n\tunsigned int\tsocClockInKhz;\n\tunsigned int    dcfClockInKhz;\n\tunsigned int    uClockInKhz;\n};\n\nstruct pp_smu_funcs_nv {\n\tstruct pp_smu pp_smu;\n\n\t \n\tenum pp_smu_status (*set_display_count)(struct pp_smu *pp, int count);\n\n\t \n\tenum pp_smu_status (*set_hard_min_dcfclk_by_freq)(struct pp_smu *pp, int Mhz);\n\n\t \n\tenum pp_smu_status (*set_min_deep_sleep_dcfclk)(struct pp_smu *pp, int Mhz);\n\n\t \n\tenum pp_smu_status (*set_hard_min_uclk_by_freq)(struct pp_smu *pp, int Mhz);\n\n\t \n\tenum pp_smu_status (*set_hard_min_socclk_by_freq)(struct pp_smu *pp, int Mhz);\n\n\t \n\tenum pp_smu_status (*set_pme_wa_enable)(struct pp_smu *pp);\n\n\t \n\tenum pp_smu_status (*set_voltage_by_freq)(struct pp_smu *pp,\n\t\t\tenum pp_smu_nv_clock_id clock_id, int Mhz);\n\n\t \n\t \n\tenum pp_smu_status (*set_wm_ranges)(struct pp_smu *pp,\n\t\t\tstruct pp_smu_wm_range_sets *ranges);\n\n\t \n\tenum pp_smu_status (*get_maximum_sustainable_clocks)(struct pp_smu *pp,\n\t\t\tstruct pp_smu_nv_clock_table *max_clocks);\n\n\t \n\tenum pp_smu_status (*get_uclk_dpm_states)(struct pp_smu *pp,\n\t\t\tunsigned int *clock_values_in_khz, unsigned int *num_states);\n\n\t \n\tenum pp_smu_status (*set_pstate_handshake_support)(struct pp_smu *pp,\n\t\t\tbool pstate_handshake_supported);\n};\n\n#define PP_SMU_NUM_SOCCLK_DPM_LEVELS  8\n#define PP_SMU_NUM_DCFCLK_DPM_LEVELS  8\n#define PP_SMU_NUM_FCLK_DPM_LEVELS    4\n#define PP_SMU_NUM_MEMCLK_DPM_LEVELS  4\n#define PP_SMU_NUM_DCLK_DPM_LEVELS    8\n#define PP_SMU_NUM_VCLK_DPM_LEVELS    8\n\nstruct dpm_clock {\n  uint32_t  Freq;    \n  uint32_t  Vol;     \n};\n\n\n \nstruct dpm_clocks {\n\tstruct dpm_clock DcfClocks[PP_SMU_NUM_DCFCLK_DPM_LEVELS];\n\tstruct dpm_clock SocClocks[PP_SMU_NUM_SOCCLK_DPM_LEVELS];\n\tstruct dpm_clock FClocks[PP_SMU_NUM_FCLK_DPM_LEVELS];\n\tstruct dpm_clock MemClocks[PP_SMU_NUM_MEMCLK_DPM_LEVELS];\n\tstruct dpm_clock VClocks[PP_SMU_NUM_VCLK_DPM_LEVELS];\n\tstruct dpm_clock DClocks[PP_SMU_NUM_DCLK_DPM_LEVELS];\n};\n\n\nstruct pp_smu_funcs_rn {\n\tstruct pp_smu pp_smu;\n\n\t \n\tenum pp_smu_status (*set_wm_ranges)(struct pp_smu *pp,\n\t\t\tstruct pp_smu_wm_range_sets *ranges);\n\n\tenum pp_smu_status (*get_dpm_clock_table) (struct pp_smu *pp,\n\t\t\tstruct dpm_clocks *clock_table);\n};\n\nstruct pp_smu_funcs_vgh {\n\tstruct pp_smu pp_smu;\n\n\t \n\t\n\tenum pp_smu_status (*set_wm_ranges)(struct pp_smu *pp,\n\t\t\tstruct pp_smu_wm_range_sets *ranges);\n\n\t\n\tenum pp_smu_status (*get_dpm_clock_table) (struct pp_smu *pp,\n\t\t\tstruct dpm_clocks *clock_table);\n\n\tenum pp_smu_status (*notify_smu_timeout) (struct pp_smu *pp);\n};\n\nstruct pp_smu_funcs {\n\tstruct pp_smu ctx;\n\tunion {\n\t\tstruct pp_smu_funcs_rv rv_funcs;\n\t\tstruct pp_smu_funcs_nv nv_funcs;\n\t\tstruct pp_smu_funcs_rn rn_funcs;\n\t\tstruct pp_smu_funcs_vgh vgh_funcs;\n\t};\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}