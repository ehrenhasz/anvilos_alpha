{
  "module_name": "dcn20_stream_encoder.c",
  "hash_id": "594591604da2dfbd0a62b3e683caa5cf3f4de433e7a9bf73ebb10141bf6de0c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n\n#include \"dc_bios_types.h\"\n#include \"dcn20_stream_encoder.h\"\n#include \"reg_helper.h\"\n#include \"hw_shared.h\"\n#include \"link.h\"\n#include \"dpcd_defs.h\"\n\n#define DC_LOGGER \\\n\t\tenc1->base.ctx->logger\n\n#define REG(reg)\\\n\t(enc1->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tenc1->se_shift->field_name, enc1->se_mask->field_name\n\n\n#define CTX \\\n\tenc1->base.ctx\n\n\nstatic void enc2_update_hdmi_info_packet(\n\tstruct dcn10_stream_encoder *enc1,\n\tuint32_t packet_index,\n\tconst struct dc_info_packet *info_packet)\n{\n\tuint32_t cont, send, line;\n\n\tif (info_packet->valid) {\n\t\tenc1_update_generic_info_packet(\n\t\t\tenc1,\n\t\t\tpacket_index,\n\t\t\tinfo_packet);\n\n\t\t \n\t\tcont = 1;\n\t\t \n\t\tsend = 1;\n\t\t \n\t\tline = 2;\n\t} else {\n\t\tcont = 0;\n\t\tsend = 0;\n\t\tline = 0;\n\t}\n\n\t \n\n\t \n\tswitch (packet_index) {\n\tcase 0:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC0_CONT, cont,\n\t\t\t\tHDMI_GENERIC0_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,\n\t\t\t\tHDMI_GENERIC0_LINE, line);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC1_CONT, cont,\n\t\t\t\tHDMI_GENERIC1_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,\n\t\t\t\tHDMI_GENERIC1_LINE, line);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC2_CONT, cont,\n\t\t\t\tHDMI_GENERIC2_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,\n\t\t\t\tHDMI_GENERIC2_LINE, line);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC3_CONT, cont,\n\t\t\t\tHDMI_GENERIC3_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,\n\t\t\t\tHDMI_GENERIC3_LINE, line);\n\t\tbreak;\n\tcase 4:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC4_CONT, cont,\n\t\t\t\tHDMI_GENERIC4_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,\n\t\t\t\tHDMI_GENERIC4_LINE, line);\n\t\tbreak;\n\tcase 5:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC5_CONT, cont,\n\t\t\t\tHDMI_GENERIC5_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,\n\t\t\t\tHDMI_GENERIC5_LINE, line);\n\t\tbreak;\n\tcase 6:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC6_CONT, cont,\n\t\t\t\tHDMI_GENERIC6_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,\n\t\t\t\tHDMI_GENERIC6_LINE, line);\n\t\tbreak;\n\tcase 7:\n\t\tREG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,\n\t\t\t\tHDMI_GENERIC7_CONT, cont,\n\t\t\t\tHDMI_GENERIC7_SEND, send);\n\t\tREG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,\n\t\t\t\tHDMI_GENERIC7_LINE, line);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDC_LOG_WARNING(\n\t\t\t\"Invalid HW packet index: %s()\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n}\n\nstatic void enc2_stream_encoder_update_hdmi_info_packets(\n\tstruct stream_encoder *enc,\n\tconst struct encoder_info_frame *info_frame)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\t \n\tREG_UPDATE(HDMI_DB_CONTROL, HDMI_DB_DISABLE, 1);\n\n\t \n\tenc2_update_hdmi_info_packet(enc1, 0, &info_frame->avi);\n\tenc2_update_hdmi_info_packet(enc1, 1, &info_frame->hfvsif);\n\tenc2_update_hdmi_info_packet(enc1, 2, &info_frame->gamut);\n\tenc2_update_hdmi_info_packet(enc1, 3, &info_frame->vendor);\n\tenc2_update_hdmi_info_packet(enc1, 4, &info_frame->spd);\n\tenc2_update_hdmi_info_packet(enc1, 5, &info_frame->hdrsmd);\n\tenc2_update_hdmi_info_packet(enc1, 6, &info_frame->vtem);\n}\n\nstatic void enc2_stream_encoder_stop_hdmi_info_packets(\n\tstruct stream_encoder *enc)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\t \n\tREG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,\n\t\tHDMI_GENERIC0_CONT, 0,\n\t\tHDMI_GENERIC0_SEND, 0,\n\t\tHDMI_GENERIC1_CONT, 0,\n\t\tHDMI_GENERIC1_SEND, 0);\n\tREG_SET_2(HDMI_GENERIC_PACKET_CONTROL1, 0,\n\t\tHDMI_GENERIC0_LINE, 0,\n\t\tHDMI_GENERIC1_LINE, 0);\n\n\t \n\tREG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,\n\t\tHDMI_GENERIC2_CONT, 0,\n\t\tHDMI_GENERIC2_SEND, 0,\n\t\tHDMI_GENERIC3_CONT, 0,\n\t\tHDMI_GENERIC3_SEND, 0);\n\tREG_SET_2(HDMI_GENERIC_PACKET_CONTROL2, 0,\n\t\tHDMI_GENERIC2_LINE, 0,\n\t\tHDMI_GENERIC3_LINE, 0);\n\n\t \n\tREG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,\n\t\tHDMI_GENERIC4_CONT, 0,\n\t\tHDMI_GENERIC4_SEND, 0,\n\t\tHDMI_GENERIC5_CONT, 0,\n\t\tHDMI_GENERIC5_SEND, 0);\n\tREG_SET_2(HDMI_GENERIC_PACKET_CONTROL3, 0,\n\t\tHDMI_GENERIC4_LINE, 0,\n\t\tHDMI_GENERIC5_LINE, 0);\n\n\t \n\tREG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,\n\t\tHDMI_GENERIC6_CONT, 0,\n\t\tHDMI_GENERIC6_SEND, 0,\n\t\tHDMI_GENERIC7_CONT, 0,\n\t\tHDMI_GENERIC7_SEND, 0);\n\tREG_SET_2(HDMI_GENERIC_PACKET_CONTROL4, 0,\n\t\tHDMI_GENERIC6_LINE, 0,\n\t\tHDMI_GENERIC7_LINE, 0);\n}\n\n\n \nstatic void enc2_update_gsp7_128_info_packet(\n\tstruct dcn10_stream_encoder *enc1,\n\tconst struct dc_info_packet_128 *info_packet,\n\tbool immediate_update)\n{\n\tuint32_t i;\n\n\t \n\tuint32_t max_retries = 50;\n\tconst uint32_t *content = (const uint32_t *) &info_packet->sb[0];\n\n\tASSERT(info_packet->hb1  == DC_DP_INFOFRAME_TYPE_PPS);\n\n\t \n\tREG_UPDATE(DP_SEC_CNTL2, DP_SEC_GSP7_PPS, 1);\n\n\t \n\tREG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, 1);\n\n\t \n\t \n\n\t \n\tREG_WAIT(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT,\n\t\t\t0, 10, max_retries);\n\n\t \n\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT_CLR, 1);\n\n\t \n\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_INDEX, 7);\n\tREG_SET_4(AFMT_GENERIC_HDR, 0,\n\t\t\tAFMT_GENERIC_HB0, info_packet->hb0,\n\t\t\tAFMT_GENERIC_HB1, info_packet->hb1,\n\t\t\tAFMT_GENERIC_HB2, info_packet->hb2,\n\t\t\tAFMT_GENERIC_HB3, info_packet->hb3);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tuint32_t packet_index = 7 + i;\n\t\tREG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_INDEX, packet_index);\n\n\t\tREG_WRITE(AFMT_GENERIC_0, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_1, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_2, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_3, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_4, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_5, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_6, *content++);\n\t\tREG_WRITE(AFMT_GENERIC_7, *content++);\n\t}\n\n\tREG_UPDATE_2(AFMT_VBI_PACKET_CONTROL1,\n\t\t\tAFMT_GENERIC7_FRAME_UPDATE, !immediate_update,\n\t\t\tAFMT_GENERIC7_IMMEDIATE_UPDATE, immediate_update);\n}\n\n \nstatic void enc2_dp_set_dsc_config(struct stream_encoder *enc,\n\t\t\t\t\tenum optc_dsc_mode dsc_mode,\n\t\t\t\t\tuint32_t dsc_bytes_per_pixel,\n\t\t\t\t\tuint32_t dsc_slice_width)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE_2(DP_DSC_CNTL,\n\t\t\tDP_DSC_MODE, dsc_mode,\n\t\t\tDP_DSC_SLICE_WIDTH, dsc_slice_width);\n\n\tREG_SET(DP_DSC_BYTES_PER_PIXEL, 0,\n\t\tDP_DSC_BYTES_PER_PIXEL, dsc_bytes_per_pixel);\n}\n\n\nstatic void enc2_dp_set_dsc_pps_info_packet(struct stream_encoder *enc,\n\t\t\t\t\tbool enable,\n\t\t\t\t\tuint8_t *dsc_packed_pps,\n\t\t\t\t\tbool immediate_update)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (enable) {\n\t\tstruct dc_info_packet_128 pps_sdp;\n\n\t\tASSERT(dsc_packed_pps);\n\n\t\t \n\t\tpps_sdp.valid = true;\n\t\tpps_sdp.hb0 = 0;\n\t\tpps_sdp.hb1 = DC_DP_INFOFRAME_TYPE_PPS;\n\t\tpps_sdp.hb2 = 127;\n\t\tpps_sdp.hb3 = 0;\n\t\tmemcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb));\n\t\tenc2_update_gsp7_128_info_packet(enc1, &pps_sdp, immediate_update);\n\n\t\t \n\t\t\n\t\t\n\n\t\t \n\t\tREG_UPDATE(DP_SEC_CNTL6,\n\t\t\t\tDP_SEC_GSP7_LINE_NUM, 2);\n\t\tREG_UPDATE_2(DP_MSA_VBID_MISC,\n\t\t\t\tDP_VBID6_LINE_REFERENCE, 0,\n\t\t\t\tDP_VBID6_LINE_NUM, 3);\n\n\t\t \n\t\tREG_UPDATE_2(DP_SEC_CNTL,\n\t\t\tDP_SEC_GSP7_ENABLE, 1,\n\t\t\tDP_SEC_STREAM_ENABLE, 1);\n\t} else {\n\t\t \n\t\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, 0);\n\t\tREG_UPDATE(DP_SEC_CNTL2, DP_SEC_GSP7_PPS, 0);\n\t}\n}\n\n\n \nstatic void enc2_read_state(struct stream_encoder *enc, struct enc_state *s)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\t\n\tREG_GET(DP_DSC_CNTL, DP_DSC_MODE, &s->dsc_mode);\n\tif (s->dsc_mode) {\n\t\tREG_GET(DP_DSC_CNTL, DP_DSC_SLICE_WIDTH, &s->dsc_slice_width);\n\t\tREG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp_pps_line_num);\n\n\t\tREG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_REFERENCE, &s->vbid6_line_reference);\n\t\tREG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_NUM, &s->vbid6_line_num);\n\n\t\tREG_GET(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, &s->sec_gsp_pps_enable);\n\t\tREG_GET(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, &s->sec_stream_enable);\n\t}\n}\n\n \nvoid enc2_set_dynamic_metadata(struct stream_encoder *enc,\n\t\tbool enable_dme,\n\t\tuint32_t hubp_requestor_id,\n\t\tenum dynamic_metadata_mode dmdata_mode)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (enable_dme) {\n\t\tREG_UPDATE_2(DME_CONTROL,\n\t\t\t\tMETADATA_HUBP_REQUESTOR_ID, hubp_requestor_id,\n\t\t\t\tMETADATA_STREAM_TYPE, (dmdata_mode == dmdata_dolby_vision) ? 1 : 0);\n\n\t\t \n\t\tif (dmdata_mode == dmdata_dp)\n\t\t\tREG_UPDATE_3(DP_SEC_METADATA_TRANSMISSION,\n\t\t\t\t\tDP_SEC_METADATA_PACKET_ENABLE, 1,\n\t\t\t\t\tDP_SEC_METADATA_PACKET_LINE_REFERENCE, 0,\n\t\t\t\t\tDP_SEC_METADATA_PACKET_LINE, 20);\n\t\telse {\n\t\t\tREG_UPDATE_3(HDMI_METADATA_PACKET_CONTROL,\n\t\t\t\t\tHDMI_METADATA_PACKET_ENABLE, 1,\n\t\t\t\t\tHDMI_METADATA_PACKET_LINE_REFERENCE, 0,\n\t\t\t\t\tHDMI_METADATA_PACKET_LINE, 2);\n\n\t\t\tif (dmdata_mode == dmdata_dolby_vision)\n\t\t\t\tREG_UPDATE(DIG_FE_CNTL,\n\t\t\t\t\t\tDOLBY_VISION_EN, 1);\n\t\t}\n\n\t\tREG_UPDATE(DME_CONTROL,\n\t\t\t\tMETADATA_ENGINE_EN, 1);\n\t} else {\n\t\tREG_UPDATE(DME_CONTROL,\n\t\t\t\tMETADATA_ENGINE_EN, 0);\n\n\t\tif (dmdata_mode == dmdata_dp)\n\t\t\tREG_UPDATE(DP_SEC_METADATA_TRANSMISSION,\n\t\t\t\t\tDP_SEC_METADATA_PACKET_ENABLE, 0);\n\t\telse {\n\t\t\tREG_UPDATE(HDMI_METADATA_PACKET_CONTROL,\n\t\t\t\t\tHDMI_METADATA_PACKET_ENABLE, 0);\n\t\t\tREG_UPDATE(DIG_FE_CNTL,\n\t\t\t\t\tDOLBY_VISION_EN, 0);\n\t\t}\n\t}\n}\n\nstatic void enc2_stream_encoder_update_dp_info_packets_sdp_line_num(\n\t\tstruct stream_encoder *enc,\n\t\tstruct encoder_info_frame *info_frame)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (info_frame->adaptive_sync.valid == true &&\n\t\tinfo_frame->sdp_line_num.adaptive_sync_line_num_valid == true) {\n\t\t\n\t\tREG_UPDATE(DP_SEC_CNTL1, DP_SEC_GSP5_LINE_REFERENCE, 1);\n\n\t\tREG_UPDATE(DP_SEC_CNTL5, DP_SEC_GSP5_LINE_NUM,\n\t\t\t\t\tinfo_frame->sdp_line_num.adaptive_sync_line_num);\n\t}\n}\n\nstatic void enc2_stream_encoder_update_dp_info_packets(\n\tstruct stream_encoder *enc,\n\tconst struct encoder_info_frame *info_frame)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\tuint32_t dmdata_packet_enabled = 0;\n\n\tenc1_stream_encoder_update_dp_info_packets(enc, info_frame);\n\n\t \n\tREG_GET(DP_SEC_METADATA_TRANSMISSION,\n\t\t\tDP_SEC_METADATA_PACKET_ENABLE, &dmdata_packet_enabled);\n\n\tif (dmdata_packet_enabled)\n\t\tREG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);\n}\n\nstatic bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)\n{\n\tbool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;\n\n\ttwo_pix = two_pix || (timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422\n\t\t\t&& !timing->dsc_cfg.ycbcr422_simple);\n\treturn two_pix;\n}\n\nvoid enc2_stream_encoder_dp_unblank(\n\t\tstruct dc_link *link,\n\t\tstruct stream_encoder *enc,\n\t\tconst struct encoder_unblank_param *param)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tif (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {\n\t\tuint32_t n_vid = 0x8000;\n\t\tuint32_t m_vid;\n\t\tuint32_t n_multiply = 0;\n\t\tuint64_t m_vid_l = n_vid;\n\n\t\t \n\t\tif (is_two_pixels_per_containter(&param->timing) || param->opp_cnt > 1) {\n\t\t\t \n\t\t\tn_multiply = 1;\n\t\t}\n\t\t \n\n\t\tm_vid_l *= param->timing.pix_clk_100hz / 10;\n\t\tm_vid_l = div_u64(m_vid_l,\n\t\t\tparam->link_settings.link_rate\n\t\t\t\t* LINK_RATE_REF_FREQ_IN_KHZ);\n\n\t\tm_vid = (uint32_t) m_vid_l;\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 0);\n\n\t\t \n\n\t\tREG_UPDATE(DP_VID_N, DP_VID_N, n_vid);\n\n\t\tREG_UPDATE(DP_VID_M, DP_VID_M, m_vid);\n\n\t\tREG_UPDATE_2(DP_VID_TIMING,\n\t\t\t\tDP_VID_M_N_GEN_EN, 1,\n\t\t\t\tDP_VID_N_MUL, n_multiply);\n\t}\n\n\t \n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, false);\n\tREG_WAIT(DP_VID_STREAM_CNTL, DP_VID_STREAM_STATUS, 0, 10, 5000);\n\n\t \n\tREG_UPDATE(DIG_FE_CNTL, DIG_START, 1);\n\tudelay(1);\n\n\t \n\n\tREG_UPDATE(DIG_FE_CNTL, DIG_START, 0);\n\n\t \n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 1);\n\tudelay(10);\n\n\tREG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);\n\n\t \n\tudelay(100);\n\n\t \n\n\tREG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, true);\n\n\tlink->dc->link_srv->dp_trace_source_sequence(link,\n\t\t\tDPCD_SOURCE_SEQ_AFTER_ENABLE_DP_VID_STREAM);\n}\n\nstatic void enc2_dp_set_odm_combine(\n\tstruct stream_encoder *enc,\n\tbool odm_combine)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tREG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_COMBINE, odm_combine);\n}\n\nvoid enc2_stream_encoder_dp_set_stream_attribute(\n\tstruct stream_encoder *enc,\n\tstruct dc_crtc_timing *crtc_timing,\n\tenum dc_color_space output_color_space,\n\tbool use_vsc_sdp_for_colorimetry,\n\tuint32_t enable_sdp_splitting)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\n\tenc1_stream_encoder_dp_set_stream_attribute(enc,\n\t\t\tcrtc_timing,\n\t\t\toutput_color_space,\n\t\t\tuse_vsc_sdp_for_colorimetry,\n\t\t\tenable_sdp_splitting);\n\n\tREG_UPDATE(DP_SEC_FRAMING4,\n\t\tDP_SST_SDP_SPLITTING, enable_sdp_splitting);\n}\n\nuint32_t enc2_get_fifo_cal_average_level(\n\t\tstruct stream_encoder *enc)\n{\n\tstruct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);\n\tuint32_t fifo_level;\n\n\tREG_GET(DIG_FIFO_STATUS,\n\t\t\tDIG_FIFO_CAL_AVERAGE_LEVEL, &fifo_level);\n\treturn fifo_level;\n}\n\nstatic const struct stream_encoder_funcs dcn20_str_enc_funcs = {\n\t.dp_set_odm_combine =\n\t\tenc2_dp_set_odm_combine,\n\t.dp_set_stream_attribute =\n\t\tenc2_stream_encoder_dp_set_stream_attribute,\n\t.hdmi_set_stream_attribute =\n\t\tenc1_stream_encoder_hdmi_set_stream_attribute,\n\t.dvi_set_stream_attribute =\n\t\tenc1_stream_encoder_dvi_set_stream_attribute,\n\t.set_throttled_vcp_size =\n\t\tenc1_stream_encoder_set_throttled_vcp_size,\n\t.update_hdmi_info_packets =\n\t\tenc2_stream_encoder_update_hdmi_info_packets,\n\t.stop_hdmi_info_packets =\n\t\tenc2_stream_encoder_stop_hdmi_info_packets,\n\t.update_dp_info_packets_sdp_line_num =\n\t\tenc2_stream_encoder_update_dp_info_packets_sdp_line_num,\n\t.update_dp_info_packets =\n\t\tenc2_stream_encoder_update_dp_info_packets,\n\t.send_immediate_sdp_message =\n\t\tenc1_stream_encoder_send_immediate_sdp_message,\n\t.stop_dp_info_packets =\n\t\tenc1_stream_encoder_stop_dp_info_packets,\n\t.dp_blank =\n\t\tenc1_stream_encoder_dp_blank,\n\t.dp_unblank =\n\t\tenc2_stream_encoder_dp_unblank,\n\t.audio_mute_control = enc1_se_audio_mute_control,\n\n\t.dp_audio_setup = enc1_se_dp_audio_setup,\n\t.dp_audio_enable = enc1_se_dp_audio_enable,\n\t.dp_audio_disable = enc1_se_dp_audio_disable,\n\n\t.hdmi_audio_setup = enc1_se_hdmi_audio_setup,\n\t.hdmi_audio_disable = enc1_se_hdmi_audio_disable,\n\t.setup_stereo_sync  = enc1_setup_stereo_sync,\n\t.set_avmute = enc1_stream_encoder_set_avmute,\n\t.dig_connect_to_otg  = enc1_dig_connect_to_otg,\n\t.dig_source_otg = enc1_dig_source_otg,\n\n\t.dp_get_pixel_format =\n\t\tenc1_stream_encoder_dp_get_pixel_format,\n\n\t.enc_read_state = enc2_read_state,\n\t.dp_set_dsc_config = enc2_dp_set_dsc_config,\n\t.dp_set_dsc_pps_info_packet = enc2_dp_set_dsc_pps_info_packet,\n\t.set_dynamic_metadata = enc2_set_dynamic_metadata,\n\t.hdmi_reset_stream_attribute = enc1_reset_hdmi_stream_attribute,\n\t.get_fifo_cal_average_level = enc2_get_fifo_cal_average_level,\n};\n\nvoid dcn20_stream_encoder_construct(\n\tstruct dcn10_stream_encoder *enc1,\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bp,\n\tenum engine_id eng_id,\n\tconst struct dcn10_stream_enc_registers *regs,\n\tconst struct dcn10_stream_encoder_shift *se_shift,\n\tconst struct dcn10_stream_encoder_mask *se_mask)\n{\n\tenc1->base.funcs = &dcn20_str_enc_funcs;\n\tenc1->base.ctx = ctx;\n\tenc1->base.id = eng_id;\n\tenc1->base.bp = bp;\n\tenc1->regs = regs;\n\tenc1->se_shift = se_shift;\n\tenc1->se_mask = se_mask;\n\tenc1->base.stream_enc_inst = eng_id - ENGINE_ID_DIGA;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}