{
  "module_name": "link_hpd.c",
  "hash_id": "7abd95174d6f65d1e190ae4da8ca5ee1bc71db8c3b62acb38d6bc1b59b299b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_hpd.c",
  "human_readable_source": " \n\n \n#include \"link_hpd.h\"\n#include \"gpio_service_interface.h\"\n\nbool link_get_hpd_state(struct dc_link *link)\n{\n\tuint32_t state;\n\n\tdal_gpio_lock_pin(link->hpd_gpio);\n\tdal_gpio_get_value(link->hpd_gpio, &state);\n\tdal_gpio_unlock_pin(link->hpd_gpio);\n\n\treturn state;\n}\n\nvoid link_enable_hpd(const struct dc_link *link)\n{\n\tstruct link_encoder *encoder = link->link_enc;\n\n\tif (encoder != NULL && encoder->funcs->enable_hpd != NULL)\n\t\tencoder->funcs->enable_hpd(encoder);\n}\n\nvoid link_disable_hpd(const struct dc_link *link)\n{\n\tstruct link_encoder *encoder = link->link_enc;\n\n\tif (encoder != NULL && encoder->funcs->enable_hpd != NULL)\n\t\tencoder->funcs->disable_hpd(encoder);\n}\n\nvoid link_enable_hpd_filter(struct dc_link *link, bool enable)\n{\n\tstruct gpio *hpd;\n\n\tif (enable) {\n\t\tlink->is_hpd_filter_disabled = false;\n\t\tprogram_hpd_filter(link);\n\t} else {\n\t\tlink->is_hpd_filter_disabled = true;\n\t\t \n\t\thpd = link_get_hpd_gpio(link->ctx->dc_bios, link->link_id, link->ctx->gpio_service);\n\n\t\tif (!hpd)\n\t\t\treturn;\n\n\t\t \n\t\tif (dal_gpio_open(hpd, GPIO_MODE_INTERRUPT) == GPIO_RESULT_OK) {\n\t\t\tstruct gpio_hpd_config config;\n\n\t\t\tconfig.delay_on_connect = 0;\n\t\t\tconfig.delay_on_disconnect = 0;\n\n\t\t\tdal_irq_setup_hpd_filter(hpd, &config);\n\n\t\t\tdal_gpio_close(hpd);\n\t\t} else {\n\t\t\tASSERT_CRITICAL(false);\n\t\t}\n\t\t \n\t\tdal_gpio_destroy_irq(&hpd);\n\t}\n}\n\nstruct gpio *link_get_hpd_gpio(struct dc_bios *dcb,\n\t\t\t  struct graphics_object_id link_id,\n\t\t\t  struct gpio_service *gpio_service)\n{\n\tenum bp_result bp_result;\n\tstruct graphics_object_hpd_info hpd_info;\n\tstruct gpio_pin_info pin_info;\n\n\tif (dcb->funcs->get_hpd_info(dcb, link_id, &hpd_info) != BP_RESULT_OK)\n\t\treturn NULL;\n\n\tbp_result = dcb->funcs->get_gpio_pin_info(dcb,\n\t\thpd_info.hpd_int_gpio_uid, &pin_info);\n\n\tif (bp_result != BP_RESULT_OK) {\n\t\tASSERT(bp_result == BP_RESULT_NORECORD);\n\t\treturn NULL;\n\t}\n\n\treturn dal_gpio_service_create_irq(gpio_service,\n\t\t\t\t\t   pin_info.offset,\n\t\t\t\t\t   pin_info.mask);\n}\n\nbool query_hpd_status(struct dc_link *link, uint32_t *is_hpd_high)\n{\n\tstruct gpio *hpd_pin = link_get_hpd_gpio(\n\t\t\tlink->ctx->dc_bios, link->link_id,\n\t\t\tlink->ctx->gpio_service);\n\tif (!hpd_pin)\n\t\treturn false;\n\n\tdal_gpio_open(hpd_pin, GPIO_MODE_INTERRUPT);\n\tdal_gpio_get_value(hpd_pin, is_hpd_high);\n\tdal_gpio_close(hpd_pin);\n\tdal_gpio_destroy_irq(&hpd_pin);\n\treturn true;\n}\n\nenum hpd_source_id get_hpd_line(struct dc_link *link)\n{\n\tstruct gpio *hpd;\n\tenum hpd_source_id hpd_id;\n\n\t\thpd_id = HPD_SOURCEID_UNKNOWN;\n\n\thpd = link_get_hpd_gpio(link->ctx->dc_bios, link->link_id,\n\t\t\t   link->ctx->gpio_service);\n\n\tif (hpd) {\n\t\tswitch (dal_irq_get_source(hpd)) {\n\t\tcase DC_IRQ_SOURCE_HPD1:\n\t\t\thpd_id = HPD_SOURCEID1;\n\t\tbreak;\n\t\tcase DC_IRQ_SOURCE_HPD2:\n\t\t\thpd_id = HPD_SOURCEID2;\n\t\tbreak;\n\t\tcase DC_IRQ_SOURCE_HPD3:\n\t\t\thpd_id = HPD_SOURCEID3;\n\t\tbreak;\n\t\tcase DC_IRQ_SOURCE_HPD4:\n\t\t\thpd_id = HPD_SOURCEID4;\n\t\tbreak;\n\t\tcase DC_IRQ_SOURCE_HPD5:\n\t\t\thpd_id = HPD_SOURCEID5;\n\t\tbreak;\n\t\tcase DC_IRQ_SOURCE_HPD6:\n\t\t\thpd_id = HPD_SOURCEID6;\n\t\tbreak;\n\t\tdefault:\n\t\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t\t}\n\n\t\tdal_gpio_destroy_irq(&hpd);\n\t}\n\n\treturn hpd_id;\n}\n\nbool program_hpd_filter(const struct dc_link *link)\n{\n\tbool result = false;\n\tstruct gpio *hpd;\n\tint delay_on_connect_in_ms = 0;\n\tint delay_on_disconnect_in_ms = 0;\n\n\tif (link->is_hpd_filter_disabled)\n\t\treturn false;\n\t \n\tswitch (link->connector_signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\t \n\t\tdelay_on_connect_in_ms = 500;\n\t\tdelay_on_disconnect_in_ms = 100;\n\t\tbreak;\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\t \n\t\t \n\t\tdelay_on_connect_in_ms = 80;\n\t\tdelay_on_disconnect_in_ms = 0;\n\t\tbreak;\n\tcase SIGNAL_TYPE_LVDS:\n\tcase SIGNAL_TYPE_EDP:\n\tdefault:\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\thpd = link_get_hpd_gpio(link->ctx->dc_bios, link->link_id,\n\t\t\t   link->ctx->gpio_service);\n\n\tif (!hpd)\n\t\treturn result;\n\n\t \n\tif (dal_gpio_open(hpd, GPIO_MODE_INTERRUPT) == GPIO_RESULT_OK) {\n\t\tstruct gpio_hpd_config config;\n\n\t\tconfig.delay_on_connect = delay_on_connect_in_ms;\n\t\tconfig.delay_on_disconnect = delay_on_disconnect_in_ms;\n\n\t\tdal_irq_setup_hpd_filter(hpd, &config);\n\n\t\tdal_gpio_close(hpd);\n\n\t\tresult = true;\n\t} else {\n\t\tASSERT_CRITICAL(false);\n\t}\n\n\t \n\tdal_gpio_destroy_irq(&hpd);\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}