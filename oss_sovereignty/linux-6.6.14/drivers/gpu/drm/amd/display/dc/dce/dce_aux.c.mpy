{
  "module_name": "dce_aux.c",
  "hash_id": "573c8d0f0854a9716c03e507f4dc4df70244773eaaf0f0fd73e5c796675c3fc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_aux.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n#include \"dce_aux.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n#include \"dm_event_log.h\"\n#include \"dm_helpers.h\"\n#include \"dmub/inc/dmub_cmd.h\"\n\n#define CTX \\\n\taux110->base.ctx\n#define REG(reg_name)\\\n\t(aux110->regs->reg_name)\n\n#define DC_LOGGER \\\n\tengine->ctx->logger\n\n#define DC_TRACE_LEVEL_MESSAGE(...) do { } while (0)\n#define IS_DC_I2CAUX_LOGGING_ENABLED() (false)\n#define LOG_FLAG_Error_I2cAux LOG_ERROR\n#define LOG_FLAG_I2cAux_DceAux LOG_I2C_AUX\n\n#include \"reg_helper.h\"\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\taux110->shift->field_name, aux110->mask->field_name\n\n#define FROM_AUX_ENGINE(ptr) \\\n\tcontainer_of((ptr), struct aux_engine_dce110, base)\n\n#define FROM_ENGINE(ptr) \\\n\tFROM_AUX_ENGINE(container_of((ptr), struct dce_aux, base))\n\n#define FROM_AUX_ENGINE_ENGINE(ptr) \\\n\tcontainer_of((ptr), struct dce_aux, base)\nenum {\n\tAUX_INVALID_REPLY_RETRY_COUNTER = 1,\n\tAUX_TIMED_OUT_RETRY_COUNTER = 2,\n\tAUX_DEFER_RETRY_COUNTER = 6\n};\n\n#define TIME_OUT_INCREMENT        1016\n#define TIME_OUT_MULTIPLIER_8     8\n#define TIME_OUT_MULTIPLIER_16    16\n#define TIME_OUT_MULTIPLIER_32    32\n#define TIME_OUT_MULTIPLIER_64    64\n#define MAX_TIMEOUT_LENGTH        127\n#define DEFAULT_AUX_ENGINE_MULT   0\n#define DEFAULT_AUX_ENGINE_LENGTH 69\n\n#define DC_TRACE_LEVEL_MESSAGE(...) do { } while (0)\n\nstatic void release_engine(\n\tstruct dce_aux *engine)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\n\tdal_ddc_close(engine->ddc);\n\n\tengine->ddc = NULL;\n\n\tREG_UPDATE_2(AUX_ARB_CONTROL, AUX_SW_DONE_USING_AUX_REG, 1,\n\t\tAUX_SW_USE_AUX_REG_REQ, 0);\n}\n\n#define SW_CAN_ACCESS_AUX 1\n#define DMCU_CAN_ACCESS_AUX 2\n\nstatic bool is_engine_available(\n\tstruct dce_aux *engine)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\n\tuint32_t value = REG_READ(AUX_ARB_CONTROL);\n\tuint32_t field = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tAUX_ARB_CONTROL,\n\t\t\tAUX_REG_RW_CNTL_STATUS);\n\n\treturn (field != DMCU_CAN_ACCESS_AUX);\n}\nstatic bool acquire_engine(\n\tstruct dce_aux *engine)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\n\tuint32_t value = REG_READ(AUX_ARB_CONTROL);\n\tuint32_t field = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tAUX_ARB_CONTROL,\n\t\t\tAUX_REG_RW_CNTL_STATUS);\n\tif (field == DMCU_CAN_ACCESS_AUX)\n\t\treturn false;\n\t \n\tvalue = REG_READ(AUX_CONTROL);\n\tfield = get_reg_field_value(value,\n\t\t\t\tAUX_CONTROL,\n\t\t\t\tAUX_EN);\n\n\tif (field == 0) {\n\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t1,\n\t\t\t\tAUX_CONTROL,\n\t\t\t\tAUX_EN);\n\n\t\tif (REG(AUX_RESET_MASK)) {\n\t\t\t \n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t1,\n\t\t\t\tAUX_CONTROL,\n\t\t\t\tAUX_RESET);\n\t\t}\n\n\t\tREG_WRITE(AUX_CONTROL, value);\n\n\t\tif (REG(AUX_RESET_MASK)) {\n\t\t\t \n\n\t\t\tREG_WAIT(AUX_CONTROL, AUX_RESET_DONE, 1,\n\t\t\t\t\t1, 11);\n\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t0,\n\t\t\t\tAUX_CONTROL,\n\t\t\t\tAUX_RESET);\n\n\t\t\tREG_WRITE(AUX_CONTROL, value);\n\n\t\t\tREG_WAIT(AUX_CONTROL, AUX_RESET_DONE, 0,\n\t\t\t\t\t1, 11);\n\t\t}\n\t}  \n\n\t \n\tREG_UPDATE(AUX_ARB_CONTROL, AUX_SW_USE_AUX_REG_REQ, 1);\n\n\tvalue = REG_READ(AUX_ARB_CONTROL);\n\tfield = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tAUX_ARB_CONTROL,\n\t\t\tAUX_REG_RW_CNTL_STATUS);\n\n\treturn (field == SW_CAN_ACCESS_AUX);\n}\n\n#define COMPOSE_AUX_SW_DATA_16_20(command, address) \\\n\t((command) | ((0xF0000 & (address)) >> 16))\n\n#define COMPOSE_AUX_SW_DATA_8_15(address) \\\n\t((0xFF00 & (address)) >> 8)\n\n#define COMPOSE_AUX_SW_DATA_0_7(address) \\\n\t(0xFF & (address))\n\nstatic void submit_channel_request(\n\tstruct dce_aux *engine,\n\tstruct aux_request_transaction_data *request)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\tuint32_t value;\n\tuint32_t length;\n\n\tbool is_write =\n\t\t((request->type == AUX_TRANSACTION_TYPE_DP) &&\n\t\t (request->action == I2CAUX_TRANSACTION_ACTION_DP_WRITE)) ||\n\t\t((request->type == AUX_TRANSACTION_TYPE_I2C) &&\n\t\t((request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE) ||\n\t\t (request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT)));\n\tif (REG(AUXN_IMPCAL)) {\n\t\t \n\t\tREG_UPDATE_SEQ_2(AUXN_IMPCAL,\n\t\t\t\tAUXN_CALOUT_ERROR_AK, 1,\n\t\t\t\tAUXN_CALOUT_ERROR_AK, 0);\n\n\t\tREG_UPDATE_SEQ_2(AUXP_IMPCAL,\n\t\t\t\tAUXP_CALOUT_ERROR_AK, 1,\n\t\t\t\tAUXP_CALOUT_ERROR_AK, 0);\n\n\t\t \n\t\tREG_UPDATE_SEQ_2(AUXN_IMPCAL,\n\t\t\t\tAUXN_IMPCAL_ENABLE, 1,\n\t\t\t\tAUXN_IMPCAL_OVERRIDE_ENABLE, 0);\n\n\t\t \n\n\t\tREG_UPDATE_SEQ_2(AUXP_IMPCAL,\n\t\t\t\tAUXP_IMPCAL_OVERRIDE_ENABLE, 1,\n\t\t\t\tAUXP_IMPCAL_OVERRIDE_ENABLE, 0);\n\t}\n\n\tREG_UPDATE(AUX_INTERRUPT_CONTROL, AUX_SW_DONE_ACK, 1);\n\n\tREG_WAIT(AUX_SW_STATUS, AUX_SW_DONE, 0,\n\t\t\t\t10, aux110->polling_timeout_period/10);\n\n\t \n\n\t \n\n\tlength = request->length ? 4 : 3;\n\tif (is_write)\n\t\tlength += request->length;\n\n\tREG_UPDATE_2(AUX_SW_CONTROL,\n\t\t\tAUX_SW_START_DELAY, request->delay,\n\t\t\tAUX_SW_WR_BYTES, length);\n\n\t \n\tvalue = REG_UPDATE_4(AUX_SW_DATA,\n\t\t\tAUX_SW_INDEX, 0,\n\t\t\tAUX_SW_DATA_RW, 0,\n\t\t\tAUX_SW_AUTOINCREMENT_DISABLE, 1,\n\t\t\tAUX_SW_DATA, COMPOSE_AUX_SW_DATA_16_20(request->action, request->address));\n\n\tvalue = REG_SET_2(AUX_SW_DATA, value,\n\t\t\tAUX_SW_AUTOINCREMENT_DISABLE, 0,\n\t\t\tAUX_SW_DATA, COMPOSE_AUX_SW_DATA_8_15(request->address));\n\n\tvalue = REG_SET(AUX_SW_DATA, value,\n\t\t\tAUX_SW_DATA, COMPOSE_AUX_SW_DATA_0_7(request->address));\n\n\tif (request->length) {\n\t\tvalue = REG_SET(AUX_SW_DATA, value,\n\t\t\t\tAUX_SW_DATA, request->length - 1);\n\t}\n\n\tif (is_write) {\n\t\t \n\t\tuint32_t i = 0;\n\n\t\twhile (i < request->length) {\n\t\t\tvalue = REG_SET(AUX_SW_DATA, value,\n\t\t\t\t\tAUX_SW_DATA, request->data[i]);\n\n\t\t\t++i;\n\t\t}\n\t}\n\n\tREG_UPDATE(AUX_SW_CONTROL, AUX_SW_GO, 1);\n\tEVENT_LOG_AUX_REQ(engine->ddc->pin_data->en, EVENT_LOG_AUX_ORIGIN_NATIVE,\n\t\t\t\t\trequest->action, request->address, request->length, request->data);\n}\n\nstatic int read_channel_reply(struct dce_aux *engine, uint32_t size,\n\t\t\t      uint8_t *buffer, uint8_t *reply_result,\n\t\t\t      uint32_t *sw_status)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\tuint32_t bytes_replied;\n\tuint32_t reply_result_32;\n\n\t*sw_status = REG_GET(AUX_SW_STATUS, AUX_SW_REPLY_BYTE_COUNT,\n\t\t\t     &bytes_replied);\n\n\t \n\tif ((*sw_status & AUX_SW_STATUS__AUX_SW_HPD_DISCON_MASK))\n\t\treturn -1;\n\n\t \n\tif (!bytes_replied)\n\t\treturn -1;\n\n\tREG_UPDATE_SEQ_3(AUX_SW_DATA,\n\t\t\t  AUX_SW_INDEX, 0,\n\t\t\t  AUX_SW_AUTOINCREMENT_DISABLE, 1,\n\t\t\t  AUX_SW_DATA_RW, 1);\n\n\tREG_GET(AUX_SW_DATA, AUX_SW_DATA, &reply_result_32);\n\treply_result_32 = reply_result_32 >> 4;\n\tif (reply_result != NULL)\n\t\t*reply_result = (uint8_t)reply_result_32;\n\n\tif (reply_result_32 == 0) {  \n\t\tuint32_t i = 0;\n\n\t\t \n\t\t--bytes_replied;\n\n\t\t \n\t\tif (bytes_replied > size)\n\t\t\treturn -1;\n\n\t\twhile (i < bytes_replied) {\n\t\t\tuint32_t aux_sw_data_val;\n\n\t\t\tREG_GET(AUX_SW_DATA, AUX_SW_DATA, &aux_sw_data_val);\n\t\t\tbuffer[i] = aux_sw_data_val;\n\t\t\t++i;\n\t\t}\n\n\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic enum aux_return_code_type get_channel_status(\n\tstruct dce_aux *engine,\n\tuint8_t *returned_bytes)\n{\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);\n\n\tuint32_t value;\n\n\tif (returned_bytes == NULL) {\n\t\t \n\t\tASSERT_CRITICAL(false);\n\t\treturn AUX_RET_ERROR_UNKNOWN;\n\t}\n\t*returned_bytes = 0;\n\n\t \n\tREG_WAIT(AUX_SW_STATUS, AUX_SW_DONE, 1,\n\t\t\t\t10, aux110->polling_timeout_period/10);\n\n\tvalue = REG_READ(AUX_SW_STATUS);\n\t \n\tif ((value & AUX_SW_STATUS__AUX_SW_HPD_DISCON_MASK))\n\t\treturn AUX_RET_ERROR_HPD_DISCON;\n\n\t \n\tif (value & AUX_SW_STATUS__AUX_SW_DONE_MASK) {\n\t\tif ((value & AUX_SW_STATUS__AUX_SW_RX_TIMEOUT_STATE_MASK) ||\n\t\t\t(value & AUX_SW_STATUS__AUX_SW_RX_TIMEOUT_MASK))\n\t\t\treturn AUX_RET_ERROR_TIMEOUT;\n\n\t\telse if ((value & AUX_SW_STATUS__AUX_SW_RX_INVALID_STOP_MASK) ||\n\t\t\t(value & AUX_SW_STATUS__AUX_SW_RX_RECV_NO_DET_MASK) ||\n\t\t\t(value &\n\t\t\t\tAUX_SW_STATUS__AUX_SW_RX_RECV_INVALID_H_MASK) ||\n\t\t\t(value & AUX_SW_STATUS__AUX_SW_RX_RECV_INVALID_L_MASK))\n\t\t\treturn AUX_RET_ERROR_INVALID_REPLY;\n\n\t\t*returned_bytes = get_reg_field_value(value,\n\t\t\t\tAUX_SW_STATUS,\n\t\t\t\tAUX_SW_REPLY_BYTE_COUNT);\n\n\t\tif (*returned_bytes == 0)\n\t\t\treturn\n\t\t\tAUX_RET_ERROR_INVALID_REPLY;\n\t\telse {\n\t\t\t*returned_bytes -= 1;\n\t\t\treturn AUX_RET_SUCCESS;\n\t\t}\n\t} else {\n\t\t \n\t\tASSERT_CRITICAL(false);\n\t\treturn AUX_RET_ERROR_TIMEOUT;\n\t}\n}\n\nstatic bool acquire(\n\tstruct dce_aux *engine,\n\tstruct ddc *ddc)\n{\n\tenum gpio_result result;\n\n\tif ((engine == NULL) || !is_engine_available(engine))\n\t\treturn false;\n\n\tresult = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,\n\t\tGPIO_DDC_CONFIG_TYPE_MODE_AUX);\n\n\tif (result != GPIO_RESULT_OK)\n\t\treturn false;\n\n\tif (!acquire_engine(engine)) {\n\t\tengine->ddc = ddc;\n\t\trelease_engine(engine);\n\t\treturn false;\n\t}\n\n\tengine->ddc = ddc;\n\n\treturn true;\n}\n\nvoid dce110_engine_destroy(struct dce_aux **engine)\n{\n\n\tstruct aux_engine_dce110 *engine110 = FROM_AUX_ENGINE(*engine);\n\n\tkfree(engine110);\n\t*engine = NULL;\n\n}\n\nstatic uint32_t dce_aux_configure_timeout(struct ddc_service *ddc,\n\t\tuint32_t timeout_in_us)\n{\n\tuint32_t multiplier = 0;\n\tuint32_t length = 0;\n\tuint32_t prev_length = 0;\n\tuint32_t prev_mult = 0;\n\tuint32_t prev_timeout_val = 0;\n\tstruct ddc *ddc_pin = ddc->ddc_pin;\n\tstruct dce_aux *aux_engine = ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en];\n\tstruct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(aux_engine);\n\n\t \n\taux110->polling_timeout_period = timeout_in_us * SW_AUX_TIMEOUT_PERIOD_MULTIPLIER;\n\n\t \n\tif (timeout_in_us == 0) {\n\t\tmultiplier = DEFAULT_AUX_ENGINE_MULT;\n\t\tlength = DEFAULT_AUX_ENGINE_LENGTH;\n\t} else if (timeout_in_us <= TIME_OUT_INCREMENT) {\n\t\tmultiplier = 0;\n\t\tlength = timeout_in_us/TIME_OUT_MULTIPLIER_8;\n\t\tif (timeout_in_us % TIME_OUT_MULTIPLIER_8 != 0)\n\t\t\tlength++;\n\t} else if (timeout_in_us <= 2 * TIME_OUT_INCREMENT) {\n\t\tmultiplier = 1;\n\t\tlength = timeout_in_us/TIME_OUT_MULTIPLIER_16;\n\t\tif (timeout_in_us % TIME_OUT_MULTIPLIER_16 != 0)\n\t\t\tlength++;\n\t} else if (timeout_in_us <= 4 * TIME_OUT_INCREMENT) {\n\t\tmultiplier = 2;\n\t\tlength = timeout_in_us/TIME_OUT_MULTIPLIER_32;\n\t\tif (timeout_in_us % TIME_OUT_MULTIPLIER_32 != 0)\n\t\t\tlength++;\n\t} else if (timeout_in_us > 4 * TIME_OUT_INCREMENT) {\n\t\tmultiplier = 3;\n\t\tlength = timeout_in_us/TIME_OUT_MULTIPLIER_64;\n\t\tif (timeout_in_us % TIME_OUT_MULTIPLIER_64 != 0)\n\t\t\tlength++;\n\t}\n\n\tlength = (length < MAX_TIMEOUT_LENGTH) ? length : MAX_TIMEOUT_LENGTH;\n\n\tREG_GET_2(AUX_DPHY_RX_CONTROL1, AUX_RX_TIMEOUT_LEN, &prev_length, AUX_RX_TIMEOUT_LEN_MUL, &prev_mult);\n\n\tswitch (prev_mult) {\n\tcase 0:\n\t\tprev_timeout_val = prev_length * TIME_OUT_MULTIPLIER_8;\n\t\tbreak;\n\tcase 1:\n\t\tprev_timeout_val = prev_length * TIME_OUT_MULTIPLIER_16;\n\t\tbreak;\n\tcase 2:\n\t\tprev_timeout_val = prev_length * TIME_OUT_MULTIPLIER_32;\n\t\tbreak;\n\tcase 3:\n\t\tprev_timeout_val = prev_length * TIME_OUT_MULTIPLIER_64;\n\t\tbreak;\n\tdefault:\n\t\tprev_timeout_val = DEFAULT_AUX_ENGINE_LENGTH * TIME_OUT_MULTIPLIER_8;\n\t\tbreak;\n\t}\n\n\tREG_UPDATE_SEQ_2(AUX_DPHY_RX_CONTROL1, AUX_RX_TIMEOUT_LEN, length, AUX_RX_TIMEOUT_LEN_MUL, multiplier);\n\n\treturn prev_timeout_val;\n}\n\nstatic struct dce_aux_funcs aux_functions = {\n\t.configure_timeout = NULL,\n\t.destroy = NULL,\n};\n\nstruct dce_aux *dce110_aux_engine_construct(struct aux_engine_dce110 *aux_engine110,\n\t\tstruct dc_context *ctx,\n\t\tuint32_t inst,\n\t\tuint32_t timeout_period,\n\t\tconst struct dce110_aux_registers *regs,\n\t\tconst struct dce110_aux_registers_mask *mask,\n\t\tconst struct dce110_aux_registers_shift *shift,\n\t\tbool is_ext_aux_timeout_configurable)\n{\n\taux_engine110->base.ddc = NULL;\n\taux_engine110->base.ctx = ctx;\n\taux_engine110->base.delay = 0;\n\taux_engine110->base.max_defer_write_retry = 0;\n\taux_engine110->base.inst = inst;\n\taux_engine110->polling_timeout_period = timeout_period;\n\taux_engine110->regs = regs;\n\n\taux_engine110->mask = mask;\n\taux_engine110->shift = shift;\n\taux_engine110->base.funcs = &aux_functions;\n\tif (is_ext_aux_timeout_configurable)\n\t\taux_engine110->base.funcs->configure_timeout = &dce_aux_configure_timeout;\n\n\treturn &aux_engine110->base;\n}\n\nstatic enum i2caux_transaction_action i2caux_action_from_payload(struct aux_payload *payload)\n{\n\tif (payload->i2c_over_aux) {\n\t\tif (payload->write_status_update) {\n\t\t\tif (payload->mot)\n\t\t\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_STATUS_REQUEST_MOT;\n\t\t\telse\n\t\t\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_STATUS_REQUEST;\n\t\t}\n\t\tif (payload->write) {\n\t\t\tif (payload->mot)\n\t\t\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT;\n\t\t\telse\n\t\t\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_WRITE;\n\t\t}\n\t\tif (payload->mot)\n\t\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_READ_MOT;\n\n\t\treturn I2CAUX_TRANSACTION_ACTION_I2C_READ;\n\t}\n\tif (payload->write)\n\t\treturn I2CAUX_TRANSACTION_ACTION_DP_WRITE;\n\n\treturn I2CAUX_TRANSACTION_ACTION_DP_READ;\n}\n\nint dce_aux_transfer_raw(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload,\n\t\tenum aux_return_code_type *operation_result)\n{\n\tstruct ddc *ddc_pin = ddc->ddc_pin;\n\tstruct dce_aux *aux_engine;\n\tstruct aux_request_transaction_data aux_req;\n\tuint8_t returned_bytes = 0;\n\tint res = -1;\n\tuint32_t status;\n\n\tmemset(&aux_req, 0, sizeof(aux_req));\n\n\tif (ddc_pin == NULL) {\n\t\t*operation_result = AUX_RET_ERROR_ENGINE_ACQUIRE;\n\t\treturn -1;\n\t}\n\n\taux_engine = ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en];\n\tif (!acquire(aux_engine, ddc_pin)) {\n\t\t*operation_result = AUX_RET_ERROR_ENGINE_ACQUIRE;\n\t\treturn -1;\n\t}\n\n\tif (payload->i2c_over_aux)\n\t\taux_req.type = AUX_TRANSACTION_TYPE_I2C;\n\telse\n\t\taux_req.type = AUX_TRANSACTION_TYPE_DP;\n\n\taux_req.action = i2caux_action_from_payload(payload);\n\n\taux_req.address = payload->address;\n\taux_req.delay = 0;\n\taux_req.length = payload->length;\n\taux_req.data = payload->data;\n\n\tsubmit_channel_request(aux_engine, &aux_req);\n\t*operation_result = get_channel_status(aux_engine, &returned_bytes);\n\n\tif (*operation_result == AUX_RET_SUCCESS) {\n\t\tint __maybe_unused bytes_replied = 0;\n\n\t\tbytes_replied = read_channel_reply(aux_engine, payload->length,\n\t\t\t\t\t payload->data, payload->reply,\n\t\t\t\t\t &status);\n\t\tEVENT_LOG_AUX_REP(aux_engine->ddc->pin_data->en,\n\t\t\t\t\tEVENT_LOG_AUX_ORIGIN_NATIVE, *payload->reply,\n\t\t\t\t\tbytes_replied, payload->data);\n\t\tres = returned_bytes;\n\t} else {\n\t\tres = -1;\n\t}\n\n\trelease_engine(aux_engine);\n\treturn res;\n}\n\nint dce_aux_transfer_dmub_raw(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload,\n\t\tenum aux_return_code_type *operation_result)\n{\n\tstruct ddc *ddc_pin = ddc->ddc_pin;\n\n\tif (ddc_pin != NULL) {\n\t\tstruct dce_aux *aux_engine = ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en];\n\t\t \n\t\tif (!acquire(aux_engine, ddc_pin)) {\n\t\t\t*operation_result = AUX_RET_ERROR_ENGINE_ACQUIRE;\n\t\t\treturn -1;\n\t\t}\n\t\trelease_engine(aux_engine);\n\t}\n\n\treturn dm_helper_dmub_aux_transfer_sync(ddc->ctx, ddc->link, payload, operation_result);\n}\n\n#define AUX_MAX_RETRIES 7\n#define AUX_MIN_DEFER_RETRIES 7\n#define AUX_MAX_DEFER_TIMEOUT_MS 50\n#define AUX_MAX_I2C_DEFER_RETRIES 7\n#define AUX_MAX_INVALID_REPLY_RETRIES 2\n#define AUX_MAX_TIMEOUT_RETRIES 3\n#define AUX_DEFER_DELAY_FOR_DPIA 4  \n\nstatic void dce_aux_log_payload(const char *payload_name,\n\tunsigned char *payload, uint32_t length, uint32_t max_length_to_log)\n{\n\tif (!IS_DC_I2CAUX_LOGGING_ENABLED())\n\t\treturn;\n\n\tif (payload && length) {\n\t\tchar hex_str[128] = {0};\n\t\tchar *hex_str_ptr = &hex_str[0];\n\t\tuint32_t hex_str_remaining = sizeof(hex_str);\n\t\tunsigned char *payload_ptr = payload;\n\t\tunsigned char *payload_max_to_log_ptr = payload_ptr + min(max_length_to_log, length);\n\t\tunsigned int count;\n\t\tchar *padding = \"\";\n\n\t\twhile (payload_ptr < payload_max_to_log_ptr) {\n\t\t\tcount = snprintf_count(hex_str_ptr, hex_str_remaining, \"%s%02X\", padding, *payload_ptr);\n\t\t\tpadding = \" \";\n\t\t\thex_str_remaining -= count;\n\t\t\thex_str_ptr += count;\n\t\t\tpayload_ptr++;\n\t\t}\n\n\t\tcount = snprintf_count(hex_str_ptr, hex_str_remaining, \"   \");\n\t\thex_str_remaining -= count;\n\t\thex_str_ptr += count;\n\n\t\tpayload_ptr = payload;\n\t\twhile (payload_ptr < payload_max_to_log_ptr) {\n\t\t\tcount = snprintf_count(hex_str_ptr, hex_str_remaining, \"%c\",\n\t\t\t\t*payload_ptr >= ' ' ? *payload_ptr : '.');\n\t\t\thex_str_remaining -= count;\n\t\t\thex_str_ptr += count;\n\t\t\tpayload_ptr++;\n\t\t}\n\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_VERBOSE,\n\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\"dce_aux_log_payload: %s: length=%u: data: %s%s\",\n\t\t\t\t\tpayload_name,\n\t\t\t\t\tlength,\n\t\t\t\t\thex_str,\n\t\t\t\t\t(length > max_length_to_log ? \" (...)\" : \" \"));\n\t} else {\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_VERBOSE,\n\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\"dce_aux_log_payload: %s: length=%u: data: <empty payload>\",\n\t\t\t\t\tpayload_name,\n\t\t\t\t\tlength);\n\t}\n}\n\nbool dce_aux_transfer_with_retries(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload)\n{\n\tint i, ret = 0;\n\tuint8_t reply;\n\tbool payload_reply = true;\n\tenum aux_return_code_type operation_result;\n\tbool retry_on_defer = false;\n\tstruct ddc *ddc_pin = ddc->ddc_pin;\n\tstruct dce_aux *aux_engine = NULL;\n\tstruct aux_engine_dce110 *aux110 = NULL;\n\tuint32_t defer_time_in_ms = 0;\n\n\tint aux_ack_retries = 0,\n\t\taux_defer_retries = 0,\n\t\taux_i2c_defer_retries = 0,\n\t\taux_timeout_retries = 0,\n\t\taux_invalid_reply_retries = 0,\n\t\taux_ack_m_retries = 0;\n\n\tif (ddc_pin) {\n\t\taux_engine = ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en];\n\t\taux110 = FROM_AUX_ENGINE(aux_engine);\n\t}\n\n\tif (!payload->reply) {\n\t\tpayload_reply = false;\n\t\tpayload->reply = &reply;\n\t}\n\n\tfor (i = 0; i < AUX_MAX_RETRIES; i++) {\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\"dce_aux_transfer_with_retries: link_index=%u: START: retry %d of %d: address=0x%04x length=%u write=%d mot=%d\",\n\t\t\t\t\tddc && ddc->link ? ddc->link->link_index : UINT_MAX,\n\t\t\t\t\ti + 1,\n\t\t\t\t\t(int)AUX_MAX_RETRIES,\n\t\t\t\t\tpayload->address,\n\t\t\t\t\tpayload->length,\n\t\t\t\t\t(unsigned int) payload->write,\n\t\t\t\t\t(unsigned int) payload->mot);\n\t\tif (payload->write)\n\t\t\tdce_aux_log_payload(\"  write\", payload->data, payload->length, 16);\n\t\tret = dce_aux_transfer_raw(ddc, payload, &operation_result);\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\"dce_aux_transfer_with_retries: link_index=%u: END: retry %d of %d: address=0x%04x length=%u write=%d mot=%d: ret=%d operation_result=%d payload->reply=%u\",\n\t\t\t\t\tddc && ddc->link ? ddc->link->link_index : UINT_MAX,\n\t\t\t\t\ti + 1,\n\t\t\t\t\t(int)AUX_MAX_RETRIES,\n\t\t\t\t\tpayload->address,\n\t\t\t\t\tpayload->length,\n\t\t\t\t\t(unsigned int) payload->write,\n\t\t\t\t\t(unsigned int) payload->mot,\n\t\t\t\t\tret,\n\t\t\t\t\t(int)operation_result,\n\t\t\t\t\t(unsigned int) *payload->reply);\n\t\tif (!payload->write)\n\t\t\tdce_aux_log_payload(\"  read\", payload->data, ret > 0 ? ret : 0, 16);\n\n\t\tswitch (operation_result) {\n\t\tcase AUX_RET_SUCCESS:\n\t\t\taux_timeout_retries = 0;\n\t\t\taux_invalid_reply_retries = 0;\n\n\t\t\tswitch (*payload->reply) {\n\t\t\tcase AUX_TRANSACTION_REPLY_AUX_ACK:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_AUX_ACK\");\n\t\t\t\tif (!payload->write && payload->length != ret) {\n\t\t\t\t\tif (++aux_ack_retries >= AUX_MAX_RETRIES) {\n\t\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_ack_retries=%d >= AUX_MAX_RETRIES=%d\",\n\t\t\t\t\t\t\t\t\taux_defer_retries,\n\t\t\t\t\t\t\t\t\tAUX_MAX_RETRIES);\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t} else \n\t\t\t\t\t\tudelay(300);\n\t\t\t\t} else if (payload->write && ret > 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (++aux_ack_m_retries >= AUX_MAX_RETRIES) {\n\t\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_ack_m_retries=%d >= AUX_MAX_RETRIES=%d\",\n\t\t\t\t\t\t\t\taux_ack_m_retries,\n\t\t\t\t\t\t\t\tAUX_MAX_RETRIES);\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tpayload->write = false;\n\t\t\t\t\tpayload->write_status_update = true;\n\t\t\t\t\tpayload->length = 0;\n\t\t\t\t\tudelay(300);\n\n\t\t\t\t} else\n\t\t\t\t\treturn true;\n\t\t\tbreak;\n\n\t\t\tcase AUX_TRANSACTION_REPLY_AUX_DEFER:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_AUX_DEFER\");\n\n\t\t\t\t \n\t\t\t\tif (aux110)\n\t\t\t\t\tdefer_time_in_ms += aux110->polling_timeout_period / 1000;\n\t\t\t\telse\n\t\t\t\t\tdefer_time_in_ms += AUX_DEFER_DELAY_FOR_DPIA;\n\t\t\t\t++aux_defer_retries;\n\t\t\t\tfallthrough;\n\t\t\tcase AUX_TRANSACTION_REPLY_I2C_OVER_AUX_DEFER:\n\t\t\t\tif (*payload->reply == AUX_TRANSACTION_REPLY_I2C_OVER_AUX_DEFER)\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_I2C_OVER_AUX_DEFER\");\n\n\t\t\t\tretry_on_defer = true;\n\n\t\t\t\tif (aux_defer_retries >= AUX_MIN_DEFER_RETRIES\n\t\t\t\t\t\t&& defer_time_in_ms >= AUX_MAX_DEFER_TIMEOUT_MS) {\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_defer_retries=%d >= AUX_MIN_DEFER_RETRIES=%d && defer_time_in_ms=%d >= AUX_MAX_DEFER_TIMEOUT_MS=%d\",\n\t\t\t\t\t\t\t\taux_defer_retries,\n\t\t\t\t\t\t\t\tAUX_MIN_DEFER_RETRIES,\n\t\t\t\t\t\t\t\tdefer_time_in_ms,\n\t\t\t\t\t\t\t\tAUX_MAX_DEFER_TIMEOUT_MS);\n\t\t\t\t\tgoto fail;\n\t\t\t\t} else {\n\t\t\t\t\tif ((*payload->reply == AUX_TRANSACTION_REPLY_AUX_DEFER) ||\n\t\t\t\t\t\t(*payload->reply == AUX_TRANSACTION_REPLY_I2C_OVER_AUX_DEFER)) {\n\t\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: payload->defer_delay=%u\",\n\t\t\t\t\t\t\t\t\tpayload->defer_delay);\n\t\t\t\t\t\tfsleep(payload->defer_delay * 1000);\n\t\t\t\t\t\tdefer_time_in_ms += payload->defer_delay;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUX_TRANSACTION_REPLY_I2C_OVER_AUX_NACK:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: AUX_TRANSACTION_REPLY_I2C_OVER_AUX_NACK\");\n\t\t\t\tgoto fail;\n\t\t\tcase AUX_TRANSACTION_REPLY_I2C_DEFER:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_I2C_DEFER\");\n\n\t\t\t\taux_defer_retries = 0;\n\t\t\t\tif (++aux_i2c_defer_retries >= AUX_MAX_I2C_DEFER_RETRIES) {\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_i2c_defer_retries=%d >= AUX_MAX_I2C_DEFER_RETRIES=%d\",\n\t\t\t\t\t\t\t\taux_i2c_defer_retries,\n\t\t\t\t\t\t\t\tAUX_MAX_I2C_DEFER_RETRIES);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AUX_TRANSACTION_REPLY_AUX_NACK:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_AUX_NACK\");\n\t\t\t\tgoto fail;\n\n\t\t\tcase AUX_TRANSACTION_REPLY_HPD_DISCON:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: AUX_TRANSACTION_REPLY_HPD_DISCON\");\n\t\t\t\tgoto fail;\n\n\t\t\tdefault:\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_SUCCESS: FAILURE: AUX_TRANSACTION_REPLY_* unknown, default case. Reply: %d\", *payload->reply);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AUX_RET_ERROR_INVALID_REPLY:\n\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_ERROR_INVALID_REPLY\");\n\t\t\tif (++aux_invalid_reply_retries >= AUX_MAX_INVALID_REPLY_RETRIES) {\n\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_invalid_reply_retries=%d >= AUX_MAX_INVALID_REPLY_RETRIES=%d\",\n\t\t\t\t\t\t\taux_invalid_reply_retries,\n\t\t\t\t\t\t\tAUX_MAX_INVALID_REPLY_RETRIES);\n\t\t\t\tgoto fail;\n\t\t\t} else\n\t\t\t\tudelay(400);\n\t\t\tbreak;\n\n\t\tcase AUX_RET_ERROR_TIMEOUT:\n\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\"dce_aux_transfer_with_retries: AUX_RET_ERROR_TIMEOUT\");\n\t\t\t\n\t\t\t\n\t\t\tif (retry_on_defer) {\n\t\t\t\tif (++aux_defer_retries >= AUX_MIN_DEFER_RETRIES) {\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_defer_retries=%d >= AUX_MIN_DEFER_RETRIES=%d\",\n\t\t\t\t\t\t\t\taux_defer_retries,\n\t\t\t\t\t\t\t\tAUX_MIN_DEFER_RETRIES);\n\t\t\t\t\tgoto fail;\n\t\t\t\t} else if (payload->defer_delay > 0) {\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_INFORMATION,\n\t\t\t\t\t\t\t\tLOG_FLAG_I2cAux_DceAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: payload->defer_delay=%u\",\n\t\t\t\t\t\t\t\tpayload->defer_delay);\n\t\t\t\t\tmsleep(payload->defer_delay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (++aux_timeout_retries >= AUX_MAX_TIMEOUT_RETRIES) {\n\t\t\t\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\t\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\t\t\t\t\"dce_aux_transfer_with_retries: FAILURE: aux_timeout_retries=%d >= AUX_MAX_TIMEOUT_RETRIES=%d\",\n\t\t\t\t\t\t\t\taux_timeout_retries,\n\t\t\t\t\t\t\t\tAUX_MAX_TIMEOUT_RETRIES);\n\t\t\t\t\tgoto fail;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AUX_RET_ERROR_HPD_DISCON:\n\t\tcase AUX_RET_ERROR_ENGINE_ACQUIRE:\n\t\tcase AUX_RET_ERROR_UNKNOWN:\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\tLOG_FLAG_Error_I2cAux,\n\t\t\t\t\"%s: Failure: operation_result=%d\",\n\t\t\t\t__func__,\n\t\t\t\t(int)operation_result);\n\tif (!payload_reply)\n\t\tpayload->reply = NULL;\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}