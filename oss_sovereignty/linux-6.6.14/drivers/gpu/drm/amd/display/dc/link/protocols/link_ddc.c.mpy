{
  "module_name": "link_ddc.c",
  "hash_id": "d1150696b665e2f57b38205993a3fe9bae9cd867849a3be0acc4e6b135efd8b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_ddc.c",
  "human_readable_source": " \n\n \n#include \"link_ddc.h\"\n#include \"vector.h\"\n#include \"dce/dce_aux.h\"\n#include \"dal_asic_id.h\"\n#include \"link_dpcd.h\"\n#include \"dm_helpers.h\"\n#include \"atomfirmware.h\"\n\n#define DC_LOGGER_INIT(logger)\n\nstatic const uint8_t DP_VGA_DONGLE_BRANCH_DEV_NAME[] = \"DpVga\";\n \nstatic const uint8_t DP_DVI_CONVERTER_ID_4[] = \"m2DVIa\";\nstatic const uint8_t DP_DVI_CONVERTER_ID_5[] = \"3393N2\";\n\nstruct i2c_payloads {\n\tstruct vector payloads;\n};\n\nstruct aux_payloads {\n\tstruct vector payloads;\n};\n\nstatic bool i2c_payloads_create(\n\t\tstruct dc_context *ctx,\n\t\tstruct i2c_payloads *payloads,\n\t\tuint32_t count)\n{\n\tif (dal_vector_construct(\n\t\t&payloads->payloads, ctx, count, sizeof(struct i2c_payload)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct i2c_payload *i2c_payloads_get(struct i2c_payloads *p)\n{\n\treturn (struct i2c_payload *)p->payloads.container;\n}\n\nstatic uint32_t i2c_payloads_get_count(struct i2c_payloads *p)\n{\n\treturn p->payloads.count;\n}\n\nstatic void i2c_payloads_destroy(struct i2c_payloads *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tdal_vector_destruct(&p->payloads);\n}\n\n#define DDC_MIN(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic void i2c_payloads_add(\n\tstruct i2c_payloads *payloads,\n\tuint32_t address,\n\tuint32_t len,\n\tuint8_t *data,\n\tbool write)\n{\n\tuint32_t payload_size = EDID_SEGMENT_SIZE;\n\tuint32_t pos;\n\n\tfor (pos = 0; pos < len; pos += payload_size) {\n\t\tstruct i2c_payload payload = {\n\t\t\t.write = write,\n\t\t\t.address = address,\n\t\t\t.length = DDC_MIN(payload_size, len - pos),\n\t\t\t.data = data + pos };\n\t\tdal_vector_append(&payloads->payloads, &payload);\n\t}\n\n}\n\nstatic void ddc_service_construct(\n\tstruct ddc_service *ddc_service,\n\tstruct ddc_service_init_data *init_data)\n{\n\tenum connector_id connector_id =\n\t\tdal_graphics_object_id_get_connector_id(init_data->id);\n\n\tstruct gpio_service *gpio_service = init_data->ctx->gpio_service;\n\tstruct graphics_object_i2c_info i2c_info;\n\tstruct gpio_ddc_hw_info hw_info;\n\tstruct dc_bios *dcb = init_data->ctx->dc_bios;\n\n\tddc_service->link = init_data->link;\n\tddc_service->ctx = init_data->ctx;\n\n\tif (init_data->is_dpia_link ||\n\t    dcb->funcs->get_i2c_info(dcb, init_data->id, &i2c_info) != BP_RESULT_OK) {\n\t\tddc_service->ddc_pin = NULL;\n\t} else {\n\t\tDC_LOGGER_INIT(ddc_service->ctx->logger);\n\t\tDC_LOG_DC(\"BIOS object table - i2c_line: %d\", i2c_info.i2c_line);\n\t\tDC_LOG_DC(\"BIOS object table - i2c_engine_id: %d\", i2c_info.i2c_engine_id);\n\n\t\thw_info.ddc_channel = i2c_info.i2c_line;\n\t\tif (ddc_service->link != NULL)\n\t\t\thw_info.hw_supported = i2c_info.i2c_hw_assist;\n\t\telse\n\t\t\thw_info.hw_supported = false;\n\n\t\tddc_service->ddc_pin = dal_gpio_create_ddc(\n\t\t\tgpio_service,\n\t\t\ti2c_info.gpio_info.clk_a_register_index,\n\t\t\t1 << i2c_info.gpio_info.clk_a_shift,\n\t\t\t&hw_info);\n\t}\n\n\tddc_service->flags.EDID_QUERY_DONE_ONCE = false;\n\tddc_service->flags.FORCE_READ_REPEATED_START = false;\n\tddc_service->flags.EDID_STRESS_READ = false;\n\n\tddc_service->flags.IS_INTERNAL_DISPLAY =\n\t\tconnector_id == CONNECTOR_ID_EDP ||\n\t\tconnector_id == CONNECTOR_ID_LVDS;\n\n\tddc_service->wa.raw = 0;\n}\n\nstruct ddc_service *link_create_ddc_service(\n\tstruct ddc_service_init_data *init_data)\n{\n\tstruct ddc_service *ddc_service;\n\n\tddc_service = kzalloc(sizeof(struct ddc_service), GFP_KERNEL);\n\n\tif (!ddc_service)\n\t\treturn NULL;\n\n\tddc_service_construct(ddc_service, init_data);\n\treturn ddc_service;\n}\n\nstatic void ddc_service_destruct(struct ddc_service *ddc)\n{\n\tif (ddc->ddc_pin)\n\t\tdal_gpio_destroy_ddc(&ddc->ddc_pin);\n}\n\nvoid link_destroy_ddc_service(struct ddc_service **ddc)\n{\n\tif (!ddc || !*ddc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\tddc_service_destruct(*ddc);\n\tkfree(*ddc);\n\t*ddc = NULL;\n}\n\nvoid set_ddc_transaction_type(\n\tstruct ddc_service *ddc,\n\tenum ddc_transaction_type type)\n{\n\tddc->transaction_type = type;\n}\n\nbool link_is_in_aux_transaction_mode(struct ddc_service *ddc)\n{\n\tswitch (ddc->transaction_type) {\n\tcase DDC_TRANSACTION_TYPE_I2C_OVER_AUX:\n\tcase DDC_TRANSACTION_TYPE_I2C_OVER_AUX_WITH_DEFER:\n\tcase DDC_TRANSACTION_TYPE_I2C_OVER_AUX_RETRY_DEFER:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nvoid set_dongle_type(struct ddc_service *ddc,\n\t\tenum display_dongle_type dongle_type)\n{\n\tddc->dongle_type = dongle_type;\n}\n\nstatic uint32_t defer_delay_converter_wa(\n\tstruct ddc_service *ddc,\n\tuint32_t defer_delay)\n{\n\tstruct dc_link *link = ddc->link;\n\n\tif (link->dpcd_caps.dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER &&\n\t\tlink->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_0080E1 &&\n\t\t(link->dpcd_caps.branch_fw_revision[0] < 0x01 ||\n\t\t\t\t(link->dpcd_caps.branch_fw_revision[0] == 0x01 &&\n\t\t\t\tlink->dpcd_caps.branch_fw_revision[1] < 0x40)) &&\n\t\t!memcmp(link->dpcd_caps.branch_dev_name,\n\t\t    DP_VGA_DONGLE_BRANCH_DEV_NAME,\n\t\t\tsizeof(link->dpcd_caps.branch_dev_name)))\n\n\t\treturn defer_delay > DPVGA_DONGLE_AUX_DEFER_WA_DELAY ?\n\t\t\tdefer_delay : DPVGA_DONGLE_AUX_DEFER_WA_DELAY;\n\n\tif (link->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_0080E1 &&\n\t    !memcmp(link->dpcd_caps.branch_dev_name,\n\t\t    DP_DVI_CONVERTER_ID_4,\n\t\t    sizeof(link->dpcd_caps.branch_dev_name)))\n\t\treturn defer_delay > I2C_OVER_AUX_DEFER_WA_DELAY ?\n\t\t\tdefer_delay : I2C_OVER_AUX_DEFER_WA_DELAY;\n\tif (link->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_006037 &&\n\t    !memcmp(link->dpcd_caps.branch_dev_name,\n\t\t    DP_DVI_CONVERTER_ID_5,\n\t\t    sizeof(link->dpcd_caps.branch_dev_name)))\n\t\treturn defer_delay > I2C_OVER_AUX_DEFER_WA_DELAY_1MS ?\n\t\t\tI2C_OVER_AUX_DEFER_WA_DELAY_1MS : defer_delay;\n\n\treturn defer_delay;\n}\n\n#define DP_TRANSLATOR_DELAY 5\n\nuint32_t link_get_aux_defer_delay(struct ddc_service *ddc)\n{\n\tuint32_t defer_delay = 0;\n\n\tswitch (ddc->transaction_type) {\n\tcase DDC_TRANSACTION_TYPE_I2C_OVER_AUX:\n\t\tif ((DISPLAY_DONGLE_DP_VGA_CONVERTER == ddc->dongle_type) ||\n\t\t\t(DISPLAY_DONGLE_DP_DVI_CONVERTER == ddc->dongle_type) ||\n\t\t\t(DISPLAY_DONGLE_DP_HDMI_CONVERTER ==\n\t\t\t\tddc->dongle_type)) {\n\n\t\t\tdefer_delay = DP_TRANSLATOR_DELAY;\n\n\t\t\tdefer_delay =\n\t\t\t\tdefer_delay_converter_wa(ddc, defer_delay);\n\n\t\t} else  \n\t\t\tdefer_delay = 0;\n\t\tbreak;\n\tcase DDC_TRANSACTION_TYPE_I2C_OVER_AUX_WITH_DEFER:\n\t\tdefer_delay = DP_TRANSLATOR_DELAY;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn defer_delay;\n}\n\nstatic bool submit_aux_command(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload)\n{\n\tuint32_t retrieved = 0;\n\tbool ret = false;\n\n\tif (!ddc)\n\t\treturn false;\n\n\tif (!payload)\n\t\treturn false;\n\n\tdo {\n\t\tstruct aux_payload current_payload;\n\t\tbool is_end_of_payload = (retrieved + DEFAULT_AUX_MAX_DATA_SIZE) >=\n\t\t\t\tpayload->length;\n\t\tuint32_t payload_length = is_end_of_payload ?\n\t\t\t\tpayload->length - retrieved : DEFAULT_AUX_MAX_DATA_SIZE;\n\n\t\tcurrent_payload.address = payload->address;\n\t\tcurrent_payload.data = &payload->data[retrieved];\n\t\tcurrent_payload.defer_delay = payload->defer_delay;\n\t\tcurrent_payload.i2c_over_aux = payload->i2c_over_aux;\n\t\tcurrent_payload.length = payload_length;\n\t\t \n\t\tcurrent_payload.mot = is_end_of_payload ? payload->mot:true;\n\t\tcurrent_payload.write_status_update = false;\n\t\tcurrent_payload.reply = payload->reply;\n\t\tcurrent_payload.write = payload->write;\n\n\t\tret = link_aux_transfer_with_retries_no_mutex(ddc, &current_payload);\n\n\t\tretrieved += payload_length;\n\t} while (retrieved < payload->length && ret == true);\n\n\treturn ret;\n}\n\nbool link_query_ddc_data(\n\tstruct ddc_service *ddc,\n\tuint32_t address,\n\tuint8_t *write_buf,\n\tuint32_t write_size,\n\tuint8_t *read_buf,\n\tuint32_t read_size)\n{\n\tbool success = true;\n\tuint32_t payload_size =\n\t\tlink_is_in_aux_transaction_mode(ddc) ?\n\t\t\tDEFAULT_AUX_MAX_DATA_SIZE : EDID_SEGMENT_SIZE;\n\n\tuint32_t write_payloads =\n\t\t(write_size + payload_size - 1) / payload_size;\n\n\tuint32_t read_payloads =\n\t\t(read_size + payload_size - 1) / payload_size;\n\n\tuint32_t payloads_num = write_payloads + read_payloads;\n\n\tif (!payloads_num)\n\t\treturn false;\n\n\tif (link_is_in_aux_transaction_mode(ddc)) {\n\t\tstruct aux_payload payload;\n\n\t\tpayload.i2c_over_aux = true;\n\t\tpayload.address = address;\n\t\tpayload.reply = NULL;\n\t\tpayload.defer_delay = link_get_aux_defer_delay(ddc);\n\t\tpayload.write_status_update = false;\n\n\t\tif (write_size != 0) {\n\t\t\tpayload.write = true;\n\t\t\t \n\t\t\tpayload.mot = !(read_size == 0);\n\t\t\tpayload.length = write_size;\n\t\t\tpayload.data = write_buf;\n\n\t\t\tsuccess = submit_aux_command(ddc, &payload);\n\t\t}\n\n\t\tif (read_size != 0 && success) {\n\t\t\tpayload.write = false;\n\t\t\t \n\t\t\tpayload.mot = false;\n\t\t\tpayload.length = read_size;\n\t\t\tpayload.data = read_buf;\n\n\t\t\tsuccess = submit_aux_command(ddc, &payload);\n\t\t}\n\t} else {\n\t\tstruct i2c_command command = {0};\n\t\tstruct i2c_payloads payloads;\n\n\t\tif (!i2c_payloads_create(ddc->ctx, &payloads, payloads_num))\n\t\t\treturn false;\n\n\t\tcommand.payloads = i2c_payloads_get(&payloads);\n\t\tcommand.number_of_payloads = 0;\n\t\tcommand.engine = DDC_I2C_COMMAND_ENGINE;\n\t\tcommand.speed = ddc->ctx->dc->caps.i2c_speed_in_khz;\n\n\t\ti2c_payloads_add(\n\t\t\t&payloads, address, write_size, write_buf, true);\n\n\t\ti2c_payloads_add(\n\t\t\t&payloads, address, read_size, read_buf, false);\n\n\t\tcommand.number_of_payloads =\n\t\t\ti2c_payloads_get_count(&payloads);\n\n\t\tsuccess = dm_helpers_submit_i2c(\n\t\t\t\tddc->ctx,\n\t\t\t\tddc->link,\n\t\t\t\t&command);\n\n\t\ti2c_payloads_destroy(&payloads);\n\t}\n\n\treturn success;\n}\n\nint link_aux_transfer_raw(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload,\n\t\tenum aux_return_code_type *operation_result)\n{\n\tif (ddc->ctx->dc->debug.enable_dmub_aux_for_legacy_ddc ||\n\t    !ddc->ddc_pin) {\n\t\treturn dce_aux_transfer_dmub_raw(ddc, payload, operation_result);\n\t} else {\n\t\treturn dce_aux_transfer_raw(ddc, payload, operation_result);\n\t}\n}\n\nuint32_t link_get_fixed_vs_pe_retimer_write_address(struct dc_link *link)\n{\n\tuint32_t vendor_lttpr_write_address = 0xF004F;\n\tuint8_t offset;\n\n\tswitch (link->dpcd_caps.lttpr_caps.phy_repeater_cnt) {\n\tcase 0x80: \n\t\toffset =  1;\n\t\tbreak;\n\tcase 0x40: \n\t\toffset = 2;\n\t\tbreak;\n\tcase 0x20: \n\t\toffset = 3;\n\t\tbreak;\n\tcase 0x10: \n\t\toffset = 4;\n\t\tbreak;\n\tcase 0x08: \n\t\toffset = 5;\n\t\tbreak;\n\tcase 0x04: \n\t\toffset = 6;\n\t\tbreak;\n\tcase 0x02: \n\t\toffset = 7;\n\t\tbreak;\n\tcase 0x01: \n\t\toffset = 8;\n\t\tbreak;\n\tdefault:\n\t\toffset = 0xFF;\n\t}\n\n\tif (offset != 0xFF) {\n\t\tvendor_lttpr_write_address +=\n\t\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\t}\n\treturn vendor_lttpr_write_address;\n}\n\nuint32_t link_get_fixed_vs_pe_retimer_read_address(struct dc_link *link)\n{\n\treturn link_get_fixed_vs_pe_retimer_write_address(link) + 4;\n}\n\nbool link_configure_fixed_vs_pe_retimer(struct ddc_service *ddc, const uint8_t *data, uint32_t length)\n{\n\tstruct aux_payload write_payload = {\n\t\t.i2c_over_aux = false,\n\t\t.write = true,\n\t\t.address = link_get_fixed_vs_pe_retimer_write_address(ddc->link),\n\t\t.length = length,\n\t\t.data = (uint8_t *) data,\n\t\t.reply = NULL,\n\t\t.mot = I2C_MOT_UNDEF,\n\t\t.write_status_update = false,\n\t\t.defer_delay = 0,\n\t};\n\n\treturn link_aux_transfer_with_retries_no_mutex(ddc,\n\t\t\t&write_payload);\n}\n\nbool link_query_fixed_vs_pe_retimer(struct ddc_service *ddc, uint8_t *data, uint32_t length)\n{\n\tstruct aux_payload read_payload = {\n\t\t.i2c_over_aux = false,\n\t\t.write = false,\n\t\t.address = link_get_fixed_vs_pe_retimer_read_address(ddc->link),\n\t\t.length = length,\n\t\t.data = data,\n\t\t.reply = NULL,\n\t\t.mot = I2C_MOT_UNDEF,\n\t\t.write_status_update = false,\n\t\t.defer_delay = 0,\n\t};\n\n\treturn link_aux_transfer_with_retries_no_mutex(ddc,\n\t\t\t&read_payload);\n}\n\nbool link_aux_transfer_with_retries_no_mutex(struct ddc_service *ddc,\n\t\tstruct aux_payload *payload)\n{\n\treturn dce_aux_transfer_with_retries(ddc, payload);\n}\n\n\nbool try_to_configure_aux_timeout(struct ddc_service *ddc,\n\t\tuint32_t timeout)\n{\n\tbool result = false;\n\tstruct ddc *ddc_pin = ddc->ddc_pin;\n\n\tif ((ddc->link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) &&\n\t\t\t!ddc->link->dc->debug.disable_fixed_vs_aux_timeout_wa &&\n\t\t\tddc->ctx->dce_version == DCN_VERSION_3_1) {\n\t\t \n\t\tconst uint32_t fixed_vs_address = 0xF004F;\n\t\tconst uint8_t fixed_vs_data[4] = {0x1, 0x22, 0x63, 0xc};\n\n\t\tcore_link_write_dpcd(ddc->link,\n\t\t\t\tfixed_vs_address,\n\t\t\t\tfixed_vs_data,\n\t\t\t\tsizeof(fixed_vs_data));\n\n\t\ttimeout = 3072;\n\t}\n\n\t \n\tif (ddc->link->ep_type != DISPLAY_ENDPOINT_PHY)\n\t\treturn true;\n\n\tif (ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en]->funcs->configure_timeout) {\n\t\tddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en]->funcs->configure_timeout(ddc, timeout);\n\t\tresult = true;\n\t}\n\n\treturn result;\n}\n\nstruct ddc *get_ddc_pin(struct ddc_service *ddc_service)\n{\n\treturn ddc_service->ddc_pin;\n}\n\nvoid write_scdc_data(struct ddc_service *ddc_service,\n\t\tuint32_t pix_clk,\n\t\tbool lte_340_scramble)\n{\n\tbool over_340_mhz = pix_clk > 340000 ? 1 : 0;\n\tuint8_t slave_address = HDMI_SCDC_ADDRESS;\n\tuint8_t offset = HDMI_SCDC_SINK_VERSION;\n\tuint8_t sink_version = 0;\n\tuint8_t write_buffer[2] = {0};\n\t \n\n\tif (ddc_service->link->local_sink &&\n\t\tddc_service->link->local_sink->edid_caps.panel_patch.skip_scdc_overwrite)\n\t\treturn;\n\n\tlink_query_ddc_data(ddc_service, slave_address, &offset,\n\t\t\tsizeof(offset), &sink_version, sizeof(sink_version));\n\tif (sink_version == 1) {\n\t\t \n\t\twrite_buffer[0] = HDMI_SCDC_SOURCE_VERSION;\n\t\twrite_buffer[1] = 1;\n\t\tlink_query_ddc_data(ddc_service, slave_address,\n\t\t\t\twrite_buffer, sizeof(write_buffer), NULL, 0);\n\t\t \n\t}\n\twrite_buffer[0] = HDMI_SCDC_TMDS_CONFIG;\n\n\tif (over_340_mhz) {\n\t\twrite_buffer[1] = 3;\n\t} else if (lte_340_scramble) {\n\t\twrite_buffer[1] = 1;\n\t} else {\n\t\twrite_buffer[1] = 0;\n\t}\n\tlink_query_ddc_data(ddc_service, slave_address, write_buffer,\n\t\t\tsizeof(write_buffer), NULL, 0);\n}\n\nvoid read_scdc_data(struct ddc_service *ddc_service)\n{\n\tuint8_t slave_address = HDMI_SCDC_ADDRESS;\n\tuint8_t offset = HDMI_SCDC_TMDS_CONFIG;\n\tuint8_t tmds_config = 0;\n\n\tif (ddc_service->link->local_sink &&\n\t\tddc_service->link->local_sink->edid_caps.panel_patch.skip_scdc_overwrite)\n\t\treturn;\n\n\tlink_query_ddc_data(ddc_service, slave_address, &offset,\n\t\t\tsizeof(offset), &tmds_config, sizeof(tmds_config));\n\tif (tmds_config & 0x1) {\n\t\tunion hdmi_scdc_status_flags_data status_data = {0};\n\t\tuint8_t scramble_status = 0;\n\n\t\toffset = HDMI_SCDC_SCRAMBLER_STATUS;\n\t\tlink_query_ddc_data(ddc_service, slave_address,\n\t\t\t\t&offset, sizeof(offset), &scramble_status,\n\t\t\t\tsizeof(scramble_status));\n\t\toffset = HDMI_SCDC_STATUS_FLAGS;\n\t\tlink_query_ddc_data(ddc_service, slave_address,\n\t\t\t\t&offset, sizeof(offset), &status_data.byte,\n\t\t\t\tsizeof(status_data.byte));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}