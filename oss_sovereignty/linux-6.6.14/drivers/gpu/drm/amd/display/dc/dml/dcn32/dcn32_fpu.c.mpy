{
  "module_name": "dcn32_fpu.c",
  "hash_id": "2548d726e1c74c8758d8fd7fb0914b3c9113176e03606af36f8ae15cb66c2c43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c",
  "human_readable_source": "\n \n#include \"dcn32_fpu.h\"\n#include \"dcn32/dcn32_resource.h\"\n#include \"dcn20/dcn20_resource.h\"\n#include \"display_mode_vba_util_32.h\"\n#include \"dml/dcn32/display_mode_vba_32.h\"\n\n#include \"clk_mgr/dcn32/dcn32_smu13_driver_if.h\"\n#include \"dcn30/dcn30_resource.h\"\n#include \"link.h\"\n\n#define DC_LOGGER_INIT(logger)\n\nstatic const struct subvp_high_refresh_list subvp_high_refresh_list = {\n\t\t\t.min_refresh = 120,\n\t\t\t.max_refresh = 175,\n\t\t\t.res = {\n\t\t\t\t{.width = 3840, .height = 2160, },\n\t\t\t\t{.width = 3440, .height = 1440, },\n\t\t\t\t{.width = 2560, .height = 1440, }},\n};\n\nstruct _vcs_dpi_ip_params_st dcn3_2_ip = {\n\t.gpuvm_enable = 0,\n\t.gpuvm_max_page_table_levels = 4,\n\t.hostvm_enable = 0,\n\t.rob_buffer_size_kbytes = 128,\n\t.det_buffer_size_kbytes = DCN3_2_DEFAULT_DET_SIZE,\n\t.config_return_buffer_size_in_kbytes = 1280,\n\t.compressed_buffer_segment_size_in_kbytes = 64,\n\t.meta_fifo_size_in_kentries = 22,\n\t.zero_size_buffer_entries = 512,\n\t.compbuf_reserved_space_64b = 256,\n\t.compbuf_reserved_space_zs = 64,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.alpha_pixel_chunk_size_kbytes = 4,\n\t.min_pixel_chunk_size_bytes = 1024,\n\t.dcc_meta_buffer_size_bytes = 6272,\n\t.meta_chunk_size_kbytes = 2,\n\t.min_meta_chunk_size_bytes = 256,\n\t.writeback_chunk_size_kbytes = 8,\n\t.ptoi_supported = false,\n\t.num_dsc = 4,\n\t.maximum_dsc_bits_per_component = 12,\n\t.maximum_pixels_per_line_per_dsc_unit = 6016,\n\t.dsc422_native_support = true,\n\t.is_line_buffer_bpp_fixed = true,\n\t.line_buffer_fixed_bpp = 57,\n\t.line_buffer_size_bits = 1171920,\n\t.max_line_buffer_lines = 32,\n\t.writeback_interface_buffer_size_kbytes = 90,\n\t.max_num_dpp = 4,\n\t.max_num_otg = 4,\n\t.max_num_hdmi_frl_outputs = 1,\n\t.max_num_wb = 1,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 6,\n\t.max_vscl_ratio = 6,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dpte_buffer_size_in_pte_reqs_luma = 64,\n\t.dpte_buffer_size_in_pte_reqs_chroma = 34,\n\t.dispclk_ramp_margin_percent = 1,\n\t.max_inter_dcn_tile_repeaters = 8,\n\t.cursor_buffer_size = 16,\n\t.cursor_chunk_size = 2,\n\t.writeback_line_buffer_buffer_size = 0,\n\t.writeback_min_hscl_ratio = 1,\n\t.writeback_min_vscl_ratio = 1,\n\t.writeback_max_hscl_ratio = 1,\n\t.writeback_max_vscl_ratio = 1,\n\t.writeback_max_hscl_taps = 1,\n\t.writeback_max_vscl_taps = 1,\n\t.dppclk_delay_subtotal = 47,\n\t.dppclk_delay_scl = 50,\n\t.dppclk_delay_scl_lb_only = 16,\n\t.dppclk_delay_cnvc_formatter = 28,\n\t.dppclk_delay_cnvc_cursor = 6,\n\t.dispclk_delay_subtotal = 125,\n\t.dynamic_metadata_vm_enabled = false,\n\t.odm_combine_4to1_supported = false,\n\t.dcc_supported = true,\n\t.max_num_dp2p0_outputs = 2,\n\t.max_num_dp2p0_streams = 4,\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn3_2_soc = {\n\t.clock_limits = {\n\t\t{\n\t\t\t.state = 0,\n\t\t\t.dcfclk_mhz = 1564.0,\n\t\t\t.fabricclk_mhz = 2500.0,\n\t\t\t.dispclk_mhz = 2150.0,\n\t\t\t.dppclk_mhz = 2150.0,\n\t\t\t.phyclk_mhz = 810.0,\n\t\t\t.phyclk_d18_mhz = 667.0,\n\t\t\t.phyclk_d32_mhz = 625.0,\n\t\t\t.socclk_mhz = 1200.0,\n\t\t\t.dscclk_mhz = 716.667,\n\t\t\t.dram_speed_mts = 18000.0,\n\t\t\t.dtbclk_mhz = 1564.0,\n\t\t},\n\t},\n\t.num_states = 1,\n\t.sr_exit_time_us = 42.97,\n\t.sr_enter_plus_exit_time_us = 49.94,\n\t.sr_exit_z8_time_us = 285.0,\n\t.sr_enter_plus_exit_z8_time_us = 320,\n\t.writeback_latency_us = 12.0,\n\t.round_trip_ping_latency_dcfclk_cycles = 263,\n\t.urgent_latency_pixel_data_only_us = 4.0,\n\t.urgent_latency_pixel_mixed_with_vm_data_us = 4.0,\n\t.urgent_latency_vm_data_only_us = 4.0,\n\t.fclk_change_latency_us = 25,\n\t.usr_retraining_latency_us = 2,\n\t.smn_latency_us = 2,\n\t.mall_allocated_for_dcn_mbytes = 64,\n\t.urgent_out_of_order_return_per_channel_pixel_only_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_vm_only_bytes = 4096,\n\t.pct_ideal_sdp_bw_after_urgent = 90.0,\n\t.pct_ideal_fabric_bw_after_urgent = 67.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_only = 20.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm = 60.0, \n\t.pct_ideal_dram_sdp_bw_after_urgent_vm_only = 30.0, \n\t.pct_ideal_dram_bw_after_urgent_strobe = 67.0,\n\t.max_avg_sdp_bw_use_normal_percent = 80.0,\n\t.max_avg_fabric_bw_use_normal_percent = 60.0,\n\t.max_avg_dram_bw_use_normal_strobe_percent = 50.0,\n\t.max_avg_dram_bw_use_normal_percent = 15.0,\n\t.num_chans = 24,\n\t.dram_channel_width_bytes = 2,\n\t.fabric_datapath_to_dcn_data_return_bytes = 64,\n\t.return_bus_width_bytes = 64,\n\t.downspread_percent = 0.38,\n\t.dcn_downspread_percent = 0.5,\n\t.dram_clock_change_latency_us = 400,\n\t.dispclk_dppclk_vco_speed_mhz = 4300.0,\n\t.do_urgent_latency_adjustment = true,\n\t.urgent_latency_adjustment_fabric_clock_component_us = 1.0,\n\t.urgent_latency_adjustment_fabric_clock_reference_mhz = 3000,\n};\n\nvoid dcn32_build_wm_range_table_fpu(struct clk_mgr_internal *clk_mgr)\n{\n\t \n\tdouble pstate_latency_us = clk_mgr->base.ctx->dc->dml.soc.dram_clock_change_latency_us;\n\tdouble fclk_change_latency_us = clk_mgr->base.ctx->dc->dml.soc.fclk_change_latency_us;\n\tdouble sr_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_exit_time_us;\n\tdouble sr_enter_plus_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_enter_plus_exit_time_us;\n\t \n\tuint16_t min_uclk_mhz\t\t\t= clk_mgr->base.bw_params->clk_table.entries[0].memclk_mhz;\n\tuint16_t min_dcfclk_mhz\t\t\t= clk_mgr->base.bw_params->clk_table.entries[0].dcfclk_mhz;\n\tuint16_t setb_min_uclk_mhz\t\t= min_uclk_mhz;\n\tuint16_t dcfclk_mhz_for_the_second_state = clk_mgr->base.ctx->dc->dml.soc.clock_limits[2].dcfclk_mhz;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tif (dcfclk_mhz_for_the_second_state)\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.min_dcfclk = dcfclk_mhz_for_the_second_state;\n\telse\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.min_dcfclk = clk_mgr->base.bw_params->clk_table.entries[0].dcfclk_mhz;\n\n\tif (clk_mgr->base.bw_params->clk_table.entries[2].memclk_mhz)\n\t\tsetb_min_uclk_mhz = clk_mgr->base.bw_params->clk_table.entries[2].memclk_mhz;\n\n\t \n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].valid = true;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us = pstate_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].dml_input.fclk_change_latency_us = fclk_change_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].dml_input.sr_exit_time_us = sr_exit_time_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.wm_type = WATERMARKS_CLOCK_RANGE;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.min_dcfclk = min_dcfclk_mhz;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_A].pmfw_breakdown.max_uclk = 0xFFFF;\n\n\t \n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].valid = true;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].dml_input.pstate_latency_us = pstate_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].dml_input.fclk_change_latency_us = fclk_change_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].dml_input.sr_exit_time_us = sr_exit_time_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.wm_type = WATERMARKS_CLOCK_RANGE;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.min_uclk = setb_min_uclk_mhz;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_B].pmfw_breakdown.max_uclk = 0xFFFF;\n\n\t \n\t \n\tif (clk_mgr->base.ctx->dc->bb_overrides.dummy_clock_change_latency_ns != 0x7FFFFFFF) {\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].valid = true;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].dml_input.pstate_latency_us = 50;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].dml_input.fclk_change_latency_us = fclk_change_latency_us;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].dml_input.sr_exit_time_us = sr_exit_time_us;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.wm_type = WATERMARKS_DUMMY_PSTATE;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.min_dcfclk = min_dcfclk_mhz;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\t\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_C].pmfw_breakdown.max_uclk = 0xFFFF;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[0].dram_speed_mts = clk_mgr->base.bw_params->clk_table.entries[0].memclk_mhz * 16;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[0].dummy_pstate_latency_us = 50;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[1].dram_speed_mts = clk_mgr->base.bw_params->clk_table.entries[1].memclk_mhz * 16;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[1].dummy_pstate_latency_us = 9;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[2].dram_speed_mts = clk_mgr->base.bw_params->clk_table.entries[2].memclk_mhz * 16;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[2].dummy_pstate_latency_us = 8;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[3].dram_speed_mts = clk_mgr->base.bw_params->clk_table.entries[3].memclk_mhz * 16;\n\t\tclk_mgr->base.bw_params->dummy_pstate_table[3].dummy_pstate_latency_us = 5;\n\t}\n\t \n\t \n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].valid = true;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].dml_input.pstate_latency_us = clk_mgr->base.bw_params->dummy_pstate_table[3].dummy_pstate_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].dml_input.fclk_change_latency_us = fclk_change_latency_us;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].dml_input.sr_exit_time_us = sr_exit_time_us / 2; \n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].dml_input.sr_enter_plus_exit_time_us = sr_enter_plus_exit_time_us / 2; \n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.wm_type = WATERMARKS_MALL;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.min_dcfclk = min_dcfclk_mhz;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.max_dcfclk = 0xFFFF;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.min_uclk = min_uclk_mhz;\n\tclk_mgr->base.bw_params->wm_table.nv_entries[WM_D].pmfw_breakdown.max_uclk = 0xFFFF;\n}\n\n \nint dcn32_find_dummy_latency_index_for_fw_based_mclk_switch(struct dc *dc,\n\t\t\t\t\t\t\t    struct dc_state *context,\n\t\t\t\t\t\t\t    display_e2e_pipe_params_st *pipes,\n\t\t\t\t\t\t\t    int pipe_cnt,\n\t\t\t\t\t\t\t    int vlevel)\n{\n\tconst int max_latency_table_entries = 4;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tint dummy_latency_index = 0;\n\tenum clock_change_support temp_clock_change_support = vba->DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\n\tdc_assert_fp_enabled();\n\n\twhile (dummy_latency_index < max_latency_table_entries) {\n\t\tif (temp_clock_change_support != dm_dram_clock_change_unsupported)\n\t\t\tvba->DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb] = temp_clock_change_support;\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\t\tdcn32_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, false);\n\n\t\t \n\t\tif (vba->DRAMClockChangeSupport[vlevel][vba->maxMpcComb] == dm_dram_clock_change_unsupported &&\n\t\t\t\tdcn32_subvp_in_use(dc, context))\n\t\t\tvba->DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb] = temp_clock_change_support;\n\n\t\tif (vlevel < context->bw_ctx.dml.vba.soc.num_states &&\n\t\t\t\tvba->DRAMClockChangeSupport[vlevel][vba->maxMpcComb] != dm_dram_clock_change_unsupported)\n\t\t\tbreak;\n\n\t\tdummy_latency_index++;\n\t}\n\n\tif (dummy_latency_index == max_latency_table_entries) {\n\t\tASSERT(dummy_latency_index != max_latency_table_entries);\n\t\t \n\t\tdummy_latency_index = max_latency_table_entries - 1;\n\t}\n\n\treturn dummy_latency_index;\n}\n\n \nvoid dcn32_helper_populate_phantom_dlg_params(struct dc *dc,\n\t\t\t\t\t      struct dc_state *context,\n\t\t\t\t\t      display_e2e_pipe_params_st *pipes,\n\t\t\t\t\t      int pipe_cnt)\n{\n\tuint32_t i, pipe_idx;\n\n\tdc_assert_fp_enabled();\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe->plane_state && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\tpipes[pipe_idx].pipe.dest.vstartup_start =\n\t\t\t\tget_vstartup(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\t\t\tpipes[pipe_idx].pipe.dest.vupdate_offset =\n\t\t\t\tget_vupdate_offset(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\t\t\tpipes[pipe_idx].pipe.dest.vupdate_width =\n\t\t\t\tget_vupdate_width(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\t\t\tpipes[pipe_idx].pipe.dest.vready_offset =\n\t\t\t\tget_vready_offset(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\t\t\tpipe->pipe_dlg_param = pipes[pipe_idx].pipe.dest;\n\t\t}\n\t\tpipe_idx++;\n\t}\n}\n\n \nuint8_t dcn32_predict_pipe_split(struct dc_state *context,\n\t\t\t\t  display_e2e_pipe_params_st *pipe_e2e)\n{\n\tdouble pscl_throughput;\n\tdouble pscl_throughput_chroma;\n\tdouble dpp_clk_single_dpp, clock;\n\tdouble clk_frequency = 0.0;\n\tdouble vco_speed = context->bw_ctx.dml.soc.dispclk_dppclk_vco_speed_mhz;\n\tbool total_available_pipes_support = false;\n\tuint32_t number_of_dpp = 0;\n\tenum odm_combine_mode odm_mode = dm_odm_combine_mode_disabled;\n\tdouble req_dispclk_per_surface = 0;\n\tuint8_t num_splits = 0;\n\n\tdc_assert_fp_enabled();\n\n\tdml32_CalculateODMMode(context->bw_ctx.dml.ip.maximum_pixels_per_line_per_dsc_unit,\n\t\t\tpipe_e2e->pipe.dest.hactive,\n\t\t\tpipe_e2e->dout.output_format,\n\t\t\tpipe_e2e->dout.output_type,\n\t\t\tpipe_e2e->pipe.dest.odm_combine_policy,\n\t\t\tcontext->bw_ctx.dml.soc.clock_limits[context->bw_ctx.dml.soc.num_states - 1].dispclk_mhz,\n\t\t\tcontext->bw_ctx.dml.soc.clock_limits[context->bw_ctx.dml.soc.num_states - 1].dispclk_mhz,\n\t\t\tpipe_e2e->dout.dsc_enable != 0,\n\t\t\t0,  \n\t\t\tcontext->bw_ctx.dml.ip.max_num_dpp,\n\t\t\tpipe_e2e->pipe.dest.pixel_rate_mhz,\n\t\t\tcontext->bw_ctx.dml.soc.dcn_downspread_percent,\n\t\t\tcontext->bw_ctx.dml.ip.dispclk_ramp_margin_percent,\n\t\t\tcontext->bw_ctx.dml.soc.dispclk_dppclk_vco_speed_mhz,\n\t\t\tpipe_e2e->dout.dsc_slices,\n\t\t\t \n\t\t\t&total_available_pipes_support,\n\t\t\t&number_of_dpp,\n\t\t\t&odm_mode,\n\t\t\t&req_dispclk_per_surface);\n\n\tdml32_CalculateSinglePipeDPPCLKAndSCLThroughput(pipe_e2e->pipe.scale_ratio_depth.hscl_ratio,\n\t\t\tpipe_e2e->pipe.scale_ratio_depth.hscl_ratio_c,\n\t\t\tpipe_e2e->pipe.scale_ratio_depth.vscl_ratio,\n\t\t\tpipe_e2e->pipe.scale_ratio_depth.vscl_ratio_c,\n\t\t\tcontext->bw_ctx.dml.ip.max_dchub_pscl_bw_pix_per_clk,\n\t\t\tcontext->bw_ctx.dml.ip.max_pscl_lb_bw_pix_per_clk,\n\t\t\tpipe_e2e->pipe.dest.pixel_rate_mhz,\n\t\t\tpipe_e2e->pipe.src.source_format,\n\t\t\tpipe_e2e->pipe.scale_taps.htaps,\n\t\t\tpipe_e2e->pipe.scale_taps.htaps_c,\n\t\t\tpipe_e2e->pipe.scale_taps.vtaps,\n\t\t\tpipe_e2e->pipe.scale_taps.vtaps_c,\n\t\t\t \n\t\t\t&pscl_throughput, &pscl_throughput_chroma,\n\t\t\t&dpp_clk_single_dpp);\n\n\tclock = dpp_clk_single_dpp * (1 + context->bw_ctx.dml.soc.dcn_downspread_percent / 100);\n\n\tif (clock > 0)\n\t\tclk_frequency = vco_speed * 4.0 / ((int)(vco_speed * 4.0) / clock);\n\n\tif (odm_mode == dm_odm_combine_mode_2to1)\n\t\tnum_splits = 1;\n\telse if (odm_mode == dm_odm_combine_mode_4to1)\n\t\tnum_splits = 3;\n\telse if (clk_frequency > context->bw_ctx.dml.soc.clock_limits[context->bw_ctx.dml.soc.num_states - 1].dppclk_mhz)\n\t\tnum_splits = 1;\n\n\treturn num_splits;\n}\n\nstatic float calculate_net_bw_in_kbytes_sec(struct _vcs_dpi_voltage_scaling_st *entry)\n{\n\tfloat memory_bw_kbytes_sec;\n\tfloat fabric_bw_kbytes_sec;\n\tfloat sdp_bw_kbytes_sec;\n\tfloat limiting_bw_kbytes_sec;\n\n\tmemory_bw_kbytes_sec = entry->dram_speed_mts *\n\t\t\t\tdcn3_2_soc.num_chans *\n\t\t\t\tdcn3_2_soc.dram_channel_width_bytes *\n\t\t\t\t((float)dcn3_2_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only / 100);\n\n\tfabric_bw_kbytes_sec = entry->fabricclk_mhz *\n\t\t\t\tdcn3_2_soc.return_bus_width_bytes *\n\t\t\t\t((float)dcn3_2_soc.pct_ideal_fabric_bw_after_urgent / 100);\n\n\tsdp_bw_kbytes_sec = entry->dcfclk_mhz *\n\t\t\t\tdcn3_2_soc.return_bus_width_bytes *\n\t\t\t\t((float)dcn3_2_soc.pct_ideal_sdp_bw_after_urgent / 100);\n\n\tlimiting_bw_kbytes_sec = memory_bw_kbytes_sec;\n\n\tif (fabric_bw_kbytes_sec < limiting_bw_kbytes_sec)\n\t\tlimiting_bw_kbytes_sec = fabric_bw_kbytes_sec;\n\n\tif (sdp_bw_kbytes_sec < limiting_bw_kbytes_sec)\n\t\tlimiting_bw_kbytes_sec = sdp_bw_kbytes_sec;\n\n\treturn limiting_bw_kbytes_sec;\n}\n\nstatic void get_optimal_ntuple(struct _vcs_dpi_voltage_scaling_st *entry)\n{\n\tif (entry->dcfclk_mhz > 0) {\n\t\tfloat bw_on_sdp = entry->dcfclk_mhz * dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_sdp_bw_after_urgent / 100);\n\n\t\tentry->fabricclk_mhz = bw_on_sdp / (dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_fabric_bw_after_urgent / 100));\n\t\tentry->dram_speed_mts = bw_on_sdp / (dcn3_2_soc.num_chans *\n\t\t\t\tdcn3_2_soc.dram_channel_width_bytes * ((float)dcn3_2_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only / 100));\n\t} else if (entry->fabricclk_mhz > 0) {\n\t\tfloat bw_on_fabric = entry->fabricclk_mhz * dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_fabric_bw_after_urgent / 100);\n\n\t\tentry->dcfclk_mhz = bw_on_fabric / (dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_sdp_bw_after_urgent / 100));\n\t\tentry->dram_speed_mts = bw_on_fabric / (dcn3_2_soc.num_chans *\n\t\t\t\tdcn3_2_soc.dram_channel_width_bytes * ((float)dcn3_2_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only / 100));\n\t} else if (entry->dram_speed_mts > 0) {\n\t\tfloat bw_on_dram = entry->dram_speed_mts * dcn3_2_soc.num_chans *\n\t\t\t\tdcn3_2_soc.dram_channel_width_bytes * ((float)dcn3_2_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only / 100);\n\n\t\tentry->fabricclk_mhz = bw_on_dram / (dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_fabric_bw_after_urgent / 100));\n\t\tentry->dcfclk_mhz = bw_on_dram / (dcn3_2_soc.return_bus_width_bytes * ((float)dcn3_2_soc.pct_ideal_sdp_bw_after_urgent / 100));\n\t}\n}\n\nstatic void insert_entry_into_table_sorted(struct _vcs_dpi_voltage_scaling_st *table,\n\t\t\t\t    unsigned int *num_entries,\n\t\t\t\t    struct _vcs_dpi_voltage_scaling_st *entry)\n{\n\tint i = 0;\n\tint index = 0;\n\n\tdc_assert_fp_enabled();\n\n\tif (*num_entries == 0) {\n\t\ttable[0] = *entry;\n\t\t(*num_entries)++;\n\t} else {\n\t\twhile (entry->net_bw_in_kbytes_sec > table[index].net_bw_in_kbytes_sec) {\n\t\t\tindex++;\n\t\t\tif (index >= *num_entries)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = *num_entries; i > index; i--)\n\t\t\ttable[i] = table[i - 1];\n\n\t\ttable[index] = *entry;\n\t\t(*num_entries)++;\n\t}\n}\n\n \nvoid dcn32_set_phantom_stream_timing(struct dc *dc,\n\t\t\t\t     struct dc_state *context,\n\t\t\t\t     struct pipe_ctx *ref_pipe,\n\t\t\t\t     struct dc_stream_state *phantom_stream,\n\t\t\t\t     display_e2e_pipe_params_st *pipes,\n\t\t\t\t     unsigned int pipe_cnt,\n\t\t\t\t     unsigned int dc_pipe_idx)\n{\n\tunsigned int i, pipe_idx;\n\tstruct pipe_ctx *pipe;\n\tuint32_t phantom_vactive, phantom_bp, pstate_width_fw_delay_lines;\n\tunsigned int num_dpp;\n\tunsigned int vlevel = context->bw_ctx.dml.vba.VoltageLevel;\n\tunsigned int dcfclk = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\tunsigned int socclk = context->bw_ctx.dml.vba.SOCCLKPerState[vlevel];\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tstruct dc_stream_state *main_stream = ref_pipe->stream;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (i == dc_pipe_idx)\n\t\t\tbreak;\n\n\t\tpipe_idx++;\n\t}\n\n\t \n\tpstate_width_fw_delay_lines = ((double)(dc->caps.subvp_fw_processing_delay_us +\n\t\t\tdc->caps.subvp_pstate_allow_width_us) / 1000000) *\n\t\t\t(ref_pipe->stream->timing.pix_clk_100hz * 100) /\n\t\t\t(double)ref_pipe->stream->timing.h_total;\n\n\t \n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk;\n\tpipes[0].clks_cfg.socclk_mhz = socclk;\n\n\t \n\t\n\t \n\tphantom_vactive = get_subviewport_lines_needed_in_mall(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx) +\n\t\t\t\tpstate_width_fw_delay_lines + dc->caps.subvp_swath_height_margin_lines;\n\n\t\n\t\n\tnum_dpp = vba->NoOfDPP[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]];\n\tphantom_vactive += num_dpp > 1 ? vba->meta_row_height[vba->pipe_plane[pipe_idx]] : 0;\n\n\t \n\tphantom_vactive += dc->debug.subvp_extra_lines;\n\n\t\n\tphantom_bp = get_vstartup(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\n\tphantom_stream->dst.y = 0;\n\tphantom_stream->dst.height = phantom_vactive;\n\t \n\tphantom_stream->src.y = 0;\n\tphantom_stream->src.height = (double)phantom_vactive * (double)main_stream->src.height / (double)main_stream->dst.height;\n\n\tphantom_stream->timing.v_addressable = phantom_vactive;\n\tphantom_stream->timing.v_front_porch = 1;\n\tphantom_stream->timing.v_total = phantom_stream->timing.v_addressable +\n\t\t\t\t\t\tphantom_stream->timing.v_front_porch +\n\t\t\t\t\t\tphantom_stream->timing.v_sync_width +\n\t\t\t\t\t\tphantom_bp;\n\tphantom_stream->timing.flags.DSC = 0; \n}\n\n \nstatic unsigned int dcn32_get_num_free_pipes(struct dc *dc, struct dc_state *context)\n{\n\tunsigned int i;\n\tunsigned int free_pipes = 0;\n\tunsigned int num_pipes = 0;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && !pipe->top_pipe) {\n\t\t\twhile (pipe) {\n\t\t\t\tnum_pipes++;\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_pipes = dc->res_pool->pipe_count - num_pipes;\n\treturn free_pipes;\n}\n\n \nstatic bool dcn32_assign_subvp_pipe(struct dc *dc,\n\t\t\t\t    struct dc_state *context,\n\t\t\t\t    unsigned int *index)\n{\n\tunsigned int i, pipe_idx;\n\tunsigned int max_frame_time = 0;\n\tbool valid_assignment_found = false;\n\tunsigned int free_pipes = dcn32_get_num_free_pipes(dc, context);\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tunsigned int num_pipes = 0;\n\t\tunsigned int refresh_rate = 0;\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\t\n\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * 100 +\n\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - 1)\n\t\t\t\t/ (double)(pipe->stream->timing.v_total * pipe->stream->timing.h_total);\n\t\t \n\t\tif (pipe->plane_state && !pipe->top_pipe && !dcn32_is_center_timing(pipe) &&\n\t\t\t\t!(pipe->stream->timing.pix_clk_100hz / 10000 > DCN3_2_MAX_SUBVP_PIXEL_RATE_MHZ) &&\n\t\t\t\t(!dcn32_is_psr_capable(pipe) || (context->stream_count == 1 && dc->caps.dmub_caps.subvp_psr)) &&\n\t\t\t\tpipe->stream->mall_stream_config.type == SUBVP_NONE &&\n\t\t\t\t(refresh_rate < 120 || dcn32_allow_subvp_high_refresh_rate(dc, context, pipe)) &&\n\t\t\t\t!pipe->plane_state->address.tmz_surface &&\n\t\t\t\t(vba->ActiveDRAMClockChangeLatencyMarginPerState[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] <= 0 ||\n\t\t\t\t(vba->ActiveDRAMClockChangeLatencyMarginPerState[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] > 0 &&\n\t\t\t\t\t\tdcn32_allow_subvp_with_active_margin(pipe)))) {\n\t\t\twhile (pipe) {\n\t\t\t\tnum_pipes++;\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\n\t\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\t\tif (num_pipes <= free_pipes) {\n\t\t\t\tstruct dc_stream_state *stream = pipe->stream;\n\t\t\t\tunsigned int frame_us = (stream->timing.v_total * stream->timing.h_total /\n\t\t\t\t\t\t(double)(stream->timing.pix_clk_100hz * 100)) * 1000000;\n\t\t\t\tif (frame_us > max_frame_time) {\n\t\t\t\t\t*index = i;\n\t\t\t\t\tmax_frame_time = frame_us;\n\t\t\t\t\tvalid_assignment_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpipe_idx++;\n\t}\n\treturn valid_assignment_found;\n}\n\n \nstatic bool dcn32_enough_pipes_for_subvp(struct dc *dc, struct dc_state *context)\n{\n\tunsigned int i, split_cnt, free_pipes;\n\tunsigned int min_pipe_split = dc->res_pool->pipe_count + 1; \n\tbool subvp_possible = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\tif (resource_is_pipe_type(pipe, OPP_HEAD) &&\n\t\t    pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\tsplit_cnt = 0;\n\t\t\twhile (pipe) {\n\t\t\t\tsplit_cnt++;\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\n\t\t\tif (split_cnt < min_pipe_split)\n\t\t\t\tmin_pipe_split = split_cnt;\n\t\t}\n\t}\n\n\tfree_pipes = dcn32_get_num_free_pipes(dc, context);\n\n\t\n\t\n\tif (free_pipes >= min_pipe_split && free_pipes < dc->res_pool->pipe_count)\n\t\tsubvp_possible = true;\n\n\treturn subvp_possible;\n}\n\n \nstatic bool subvp_subvp_schedulable(struct dc *dc, struct dc_state *context)\n{\n\tstruct pipe_ctx *subvp_pipes[2];\n\tstruct dc_stream_state *phantom = NULL;\n\tuint32_t microschedule_lines = 0;\n\tuint32_t index = 0;\n\tuint32_t i;\n\tuint32_t max_microschedule_us = 0;\n\tint32_t vactive1_us, vactive2_us, vblank1_us, vblank2_us;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tuint32_t time_us = 0;\n\n\t\t \n\t\tif (pipe->stream && pipe->plane_state && !pipe->top_pipe &&\n\t\t    pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\tphantom = pipe->stream->mall_stream_config.paired_stream;\n\t\t\tmicroschedule_lines = (phantom->timing.v_total - phantom->timing.v_front_porch) +\n\t\t\t\t\tphantom->timing.v_addressable;\n\n\t\t\t\n\t\t\ttime_us = (microschedule_lines * phantom->timing.h_total) /\n\t\t\t\t\t(double)(phantom->timing.pix_clk_100hz * 100) * 1000000 +\n\t\t\t\t\t\tdc->caps.subvp_prefetch_end_to_mall_start_us +\n\t\t\t\t\t\tdc->caps.subvp_fw_processing_delay_us + 1;\n\t\t\tif (time_us > max_microschedule_us)\n\t\t\t\tmax_microschedule_us = time_us;\n\n\t\t\tsubvp_pipes[index] = pipe;\n\t\t\tindex++;\n\n\t\t\t\n\t\t\tif (index == 2)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvactive1_us = ((subvp_pipes[0]->stream->timing.v_addressable * subvp_pipes[0]->stream->timing.h_total) /\n\t\t\t(double)(subvp_pipes[0]->stream->timing.pix_clk_100hz * 100)) * 1000000;\n\tvactive2_us = ((subvp_pipes[1]->stream->timing.v_addressable * subvp_pipes[1]->stream->timing.h_total) /\n\t\t\t\t(double)(subvp_pipes[1]->stream->timing.pix_clk_100hz * 100)) * 1000000;\n\tvblank1_us = (((subvp_pipes[0]->stream->timing.v_total - subvp_pipes[0]->stream->timing.v_addressable) *\n\t\t\tsubvp_pipes[0]->stream->timing.h_total) /\n\t\t\t(double)(subvp_pipes[0]->stream->timing.pix_clk_100hz * 100)) * 1000000;\n\tvblank2_us = (((subvp_pipes[1]->stream->timing.v_total - subvp_pipes[1]->stream->timing.v_addressable) *\n\t\t\tsubvp_pipes[1]->stream->timing.h_total) /\n\t\t\t(double)(subvp_pipes[1]->stream->timing.pix_clk_100hz * 100)) * 1000000;\n\n\tif ((vactive1_us - vblank2_us) / 2 > max_microschedule_us &&\n\t    (vactive2_us - vblank1_us) / 2 > max_microschedule_us)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool subvp_drr_schedulable(struct dc *dc, struct dc_state *context)\n{\n\tbool schedulable = false;\n\tuint32_t i;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct pipe_ctx *drr_pipe = NULL;\n\tstruct dc_crtc_timing *main_timing = NULL;\n\tstruct dc_crtc_timing *phantom_timing = NULL;\n\tstruct dc_crtc_timing *drr_timing = NULL;\n\tint16_t prefetch_us = 0;\n\tint16_t mall_region_us = 0;\n\tint16_t drr_frame_us = 0;\t\n\tint16_t subvp_active_us = 0;\n\tint16_t stretched_drr_us = 0;\n\tint16_t drr_stretched_vblank_us = 0;\n\tint16_t max_vblank_mallregion = 0;\n\n\t\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\t\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN)\n\t\t\tbreak;\n\t}\n\n\t\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tdrr_pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\tif (drr_pipe->stream->mall_stream_config.type == SUBVP_NONE && drr_pipe->stream->ignore_msa_timing_param &&\n\t\t\t\t(drr_pipe->stream->allow_freesync || drr_pipe->stream->vrr_active_variable))\n\t\t\tbreak;\n\t}\n\n\tmain_timing = &pipe->stream->timing;\n\tphantom_timing = &pipe->stream->mall_stream_config.paired_stream->timing;\n\tdrr_timing = &drr_pipe->stream->timing;\n\tprefetch_us = (phantom_timing->v_total - phantom_timing->v_front_porch) * phantom_timing->h_total /\n\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000 +\n\t\t\tdc->caps.subvp_prefetch_end_to_mall_start_us;\n\tsubvp_active_us = main_timing->v_addressable * main_timing->h_total /\n\t\t\t(double)(main_timing->pix_clk_100hz * 100) * 1000000;\n\tdrr_frame_us = drr_timing->v_total * drr_timing->h_total /\n\t\t\t(double)(drr_timing->pix_clk_100hz * 100) * 1000000;\n\t\n\tmall_region_us = phantom_timing->v_addressable * phantom_timing->h_total /\n\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000;\n\tstretched_drr_us = drr_frame_us + mall_region_us + SUBVP_DRR_MARGIN_US;\n\tdrr_stretched_vblank_us = (drr_timing->v_total - drr_timing->v_addressable) * drr_timing->h_total /\n\t\t\t(double)(drr_timing->pix_clk_100hz * 100) * 1000000 + (stretched_drr_us - drr_frame_us);\n\tmax_vblank_mallregion = drr_stretched_vblank_us > mall_region_us ? drr_stretched_vblank_us : mall_region_us;\n\n\t \n\tif (stretched_drr_us < (1 / (double)drr_timing->min_refresh_in_uhz) * 1000000 * 1000000 &&\n\t\t\tsubvp_active_us - prefetch_us - stretched_drr_us - max_vblank_mallregion > 0)\n\t\tschedulable = true;\n\n\treturn schedulable;\n}\n\n\n \nstatic bool subvp_vblank_schedulable(struct dc *dc, struct dc_state *context)\n{\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct pipe_ctx *subvp_pipe = NULL;\n\tbool found = false;\n\tbool schedulable = false;\n\tuint32_t i = 0;\n\tuint8_t vblank_index = 0;\n\tuint16_t prefetch_us = 0;\n\tuint16_t mall_region_us = 0;\n\tuint16_t vblank_frame_us = 0;\n\tuint16_t subvp_active_us = 0;\n\tuint16_t vblank_blank_us = 0;\n\tuint16_t max_vblank_mallregion = 0;\n\tstruct dc_crtc_timing *main_timing = NULL;\n\tstruct dc_crtc_timing *phantom_timing = NULL;\n\tstruct dc_crtc_timing *vblank_timing = NULL;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\t\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\tif (!found && pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\t\n\t\t\tvblank_index = i;\n\t\t\tfound = true;\n\t\t}\n\n\t\tif (!subvp_pipe && pipe->stream->mall_stream_config.type == SUBVP_MAIN)\n\t\t\tsubvp_pipe = pipe;\n\t}\n\tif (found) {\n\t\tmain_timing = &subvp_pipe->stream->timing;\n\t\tphantom_timing = &subvp_pipe->stream->mall_stream_config.paired_stream->timing;\n\t\tvblank_timing = &context->res_ctx.pipe_ctx[vblank_index].stream->timing;\n\t\t\n\t\t\n\t\tprefetch_us = (phantom_timing->v_total - phantom_timing->v_front_porch) * phantom_timing->h_total /\n\t\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000 +\n\t\t\t\tdc->caps.subvp_prefetch_end_to_mall_start_us;\n\t\t\n\t\tmall_region_us = phantom_timing->v_addressable * phantom_timing->h_total /\n\t\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000;\n\t\tvblank_frame_us = vblank_timing->v_total * vblank_timing->h_total /\n\t\t\t\t(double)(vblank_timing->pix_clk_100hz * 100) * 1000000;\n\t\tvblank_blank_us =  (vblank_timing->v_total - vblank_timing->v_addressable) * vblank_timing->h_total /\n\t\t\t\t(double)(vblank_timing->pix_clk_100hz * 100) * 1000000;\n\t\tsubvp_active_us = main_timing->v_addressable * main_timing->h_total /\n\t\t\t\t(double)(main_timing->pix_clk_100hz * 100) * 1000000;\n\t\tmax_vblank_mallregion = vblank_blank_us > mall_region_us ? vblank_blank_us : mall_region_us;\n\n\t\t\n\t\t\n\t\t\n\t\tif (subvp_active_us - prefetch_us - vblank_frame_us - max_vblank_mallregion > 0)\n\t\t\tschedulable = true;\n\t}\n\treturn schedulable;\n}\n\n \nstatic bool subvp_subvp_admissable(struct dc *dc,\n\t\t\t\tstruct dc_state *context)\n{\n\tbool result = false;\n\tuint32_t i;\n\tuint8_t subvp_count = 0;\n\tuint32_t min_refresh = subvp_high_refresh_list.min_refresh, max_refresh = 0;\n\tuint64_t refresh_rate = 0;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe->plane_state && !pipe->top_pipe &&\n\t\t\t\tpipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - (uint64_t)1);\n\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.v_total);\n\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.h_total);\n\n\t\t\tif ((uint32_t)refresh_rate < min_refresh)\n\t\t\t\tmin_refresh = (uint32_t)refresh_rate;\n\t\t\tif ((uint32_t)refresh_rate > max_refresh)\n\t\t\t\tmax_refresh = (uint32_t)refresh_rate;\n\t\t\tsubvp_count++;\n\t\t}\n\t}\n\n\tif (subvp_count == 2 && ((min_refresh < 120 && max_refresh < 120) ||\n\t\t(min_refresh >= subvp_high_refresh_list.min_refresh &&\n\t\t\t\tmax_refresh <= subvp_high_refresh_list.max_refresh)))\n\t\tresult = true;\n\n\treturn result;\n}\n\n \nstatic bool subvp_validate_static_schedulability(struct dc *dc,\n\t\t\t\tstruct dc_state *context,\n\t\t\t\tint vlevel)\n{\n\tbool schedulable = false;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tuint32_t i, pipe_idx;\n\tuint8_t subvp_count = 0;\n\tuint8_t vactive_count = 0;\n\tuint8_t non_subvp_pipes = 0;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe->plane_state && !pipe->top_pipe) {\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN)\n\t\t\t\tsubvp_count++;\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\t\tnon_subvp_pipes++;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\tif (vba->ActiveDRAMClockChangeLatencyMarginPerState[vlevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] > 0 &&\n\t\t    pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\tvactive_count++;\n\t\t}\n\t\tpipe_idx++;\n\t}\n\n\tif (subvp_count == 2) {\n\t\t\n\t\tschedulable = subvp_subvp_admissable(dc, context) && subvp_subvp_schedulable(dc, context);\n\t} else if (subvp_count == 1 && non_subvp_pipes == 0) {\n\t\t\n\t\tschedulable = true;\n\t} else if (subvp_count == 1 && non_subvp_pipes == 1) {\n\t\tif (dcn32_subvp_drr_admissable(dc, context))\n\t\t\tschedulable = subvp_drr_schedulable(dc, context);\n\t\telse if (dcn32_subvp_vblank_admissable(dc, context, vlevel))\n\t\t\tschedulable = subvp_vblank_schedulable(dc, context);\n\t} else if (vba->DRAMClockChangeSupport[vlevel][vba->maxMpcComb] == dm_dram_clock_change_vactive_w_mall_sub_vp &&\n\t\t\tvactive_count > 0) {\n\t\t\n\t\t\n\t\t\n\t\tschedulable = false;\n\t}\n\treturn schedulable;\n}\n\nstatic void dcn32_full_validate_bw_helper(struct dc *dc,\n\t\t\t\t   struct dc_state *context,\n\t\t\t\t   display_e2e_pipe_params_st *pipes,\n\t\t\t\t   int *vlevel,\n\t\t\t\t   int *split,\n\t\t\t\t   bool *merge,\n\t\t\t\t   int *pipe_cnt)\n{\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tunsigned int dc_pipe_idx = 0;\n\tint i = 0;\n\tbool found_supported_config = false;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tif (dc->debug.dml_disallow_alternate_prefetch_modes)\n\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final =\n\t\t\tdm_prefetch_support_uclk_fclk_and_stutter;\n\telse\n\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final =\n\t\t\tdm_prefetch_support_uclk_fclk_and_stutter_if_possible;\n\n\t*vlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, *pipe_cnt);\n\t \n\tif (*vlevel < context->bw_ctx.dml.soc.num_states) {\n\t\t*vlevel = dcn20_validate_apply_pipe_split_flags(dc, context, *vlevel, split, merge);\n\t\tvba->VoltageLevel = *vlevel;\n\t}\n\n\t \n\tif (!dc->debug.force_disable_subvp && !dc->caps.dmub_caps.gecc_enable && dcn32_all_pipes_have_stream_and_plane(dc, context) &&\n\t    !dcn32_mpo_in_use(context) && !dcn32_any_surfaces_rotated(dc, context) &&\n\t\t(*vlevel == context->bw_ctx.dml.soc.num_states ||\n\t    vba->DRAMClockChangeSupport[*vlevel][vba->maxMpcComb] == dm_dram_clock_change_unsupported ||\n\t    dc->debug.force_subvp_mclk_switch)) {\n\n\t\tdcn32_merge_pipes_for_subvp(dc, context);\n\t\tmemset(merge, 0, MAX_PIPES * sizeof(bool));\n\n\t\t \n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (!pipe_ctx->plane_state || !pipe_ctx->stream)\n\t\t\t\tcontinue;\n\n\t\t\tresource_build_scaling_params(pipe_ctx);\n\t\t}\n\n\t\twhile (!found_supported_config && dcn32_enough_pipes_for_subvp(dc, context) &&\n\t\t\tdcn32_assign_subvp_pipe(dc, context, &dc_pipe_idx)) {\n\t\t\t \n\t\t\tif (*vlevel == context->bw_ctx.dml.soc.num_states &&\n\t\t\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final ==\n\t\t\t\t\tdm_prefetch_support_uclk_fclk_and_stutter) {\n\t\t\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final =\n\t\t\t\t\t\t\t\tdm_prefetch_support_fclk_and_stutter;\n\t\t\t\t \n\t\t\t\t*vlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, *pipe_cnt);\n\t\t\t}\n\n\t\t\tdc->res_pool->funcs->add_phantom_pipes(dc, context, pipes, *pipe_cnt, dc_pipe_idx);\n\n\t\t\t*pipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc, context, pipes, false);\n\t\t\t\n\t\t\t\n\t\t\tpipes[0].clks_cfg.dppclk_mhz = get_dppclk_calculated(&context->bw_ctx.dml, pipes, *pipe_cnt, 0);\n\t\t\t*vlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, *pipe_cnt);\n\n\t\t\t \n\t\t\tfor (i = *vlevel; i < context->bw_ctx.dml.soc.num_states; i++) {\n\t\t\t\tif (vba->DRAMClockChangeSupport[i][vba->maxMpcComb] != dm_dram_clock_change_unsupported) {\n\t\t\t\t\t*vlevel = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*vlevel < context->bw_ctx.dml.soc.num_states\n\t\t\t    && subvp_validate_static_schedulability(dc, context, *vlevel))\n\t\t\t\tfound_supported_config = true;\n\t\t\tif (found_supported_config) {\n\t\t\t\t\n\t\t\t\tif (dcn32_subvp_drr_admissable(dc, context) && subvp_drr_schedulable(dc, context)) {\n\t\t\t\t\t \n\t\t\t\t\tfor (i = *vlevel; i >= 0; i--) {\n\t\t\t\t\t\tif (vba->ModeSupport[i][vba->maxMpcComb]) {\n\t\t\t\t\t\t\t*vlevel = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\tif (!found_supported_config) {\n\t\t\tdc->res_pool->funcs->remove_phantom_pipes(dc, context, false);\n\t\t\tvba->DRAMClockChangeSupport[*vlevel][vba->maxMpcComb] = dm_dram_clock_change_unsupported;\n\t\t\t*pipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc, context, pipes, false);\n\n\t\t\t*vlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, *pipe_cnt);\n\t\t\t \n\t\t\tif (*vlevel < context->bw_ctx.dml.soc.num_states) {\n\t\t\t\t*vlevel = dcn20_validate_apply_pipe_split_flags(dc, context, *vlevel, split, merge);\n\t\t\t\tvba->VoltageLevel = *vlevel;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tdcn32_helper_populate_phantom_dlg_params(dc, context, pipes, *pipe_cnt);\n\n\t\t\t \n\t\t\tmemset(split, 0, MAX_PIPES * sizeof(int));\n\t\t\tmemset(merge, 0, MAX_PIPES * sizeof(bool));\n\t\t\t*vlevel = dcn20_validate_apply_pipe_split_flags(dc, context, *vlevel, split, merge);\n\t\t\tvba->VoltageLevel = *vlevel;\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n\nstatic bool is_dtbclk_required(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tif (dc->link_srv->dp_is_128b_132b_signal(&context->res_ctx.pipe_ctx[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void dcn20_adjust_freesync_v_startup(const struct dc_crtc_timing *dc_crtc_timing, int *vstartup_start)\n{\n\tstruct dc_crtc_timing patched_crtc_timing;\n\tuint32_t asic_blank_end   = 0;\n\tuint32_t asic_blank_start = 0;\n\tuint32_t newVstartup\t  = 0;\n\n\tpatched_crtc_timing = *dc_crtc_timing;\n\n\tif (patched_crtc_timing.flags.INTERLACE == 1) {\n\t\tif (patched_crtc_timing.v_front_porch < 2)\n\t\t\tpatched_crtc_timing.v_front_porch = 2;\n\t} else {\n\t\tif (patched_crtc_timing.v_front_porch < 1)\n\t\t\tpatched_crtc_timing.v_front_porch = 1;\n\t}\n\n\t \n\tasic_blank_start = patched_crtc_timing.v_total -\n\t\t\t\t\tpatched_crtc_timing.v_front_porch;\n\n\t \n\tasic_blank_end = asic_blank_start -\n\t\t\t\t\tpatched_crtc_timing.v_border_bottom -\n\t\t\t\t\tpatched_crtc_timing.v_addressable -\n\t\t\t\t\tpatched_crtc_timing.v_border_top;\n\n\tnewVstartup = asic_blank_end + (patched_crtc_timing.v_total - asic_blank_start);\n\n\t*vstartup_start = ((newVstartup > *vstartup_start) ? newVstartup : *vstartup_start);\n}\n\nstatic void dcn32_calculate_dlg_params(struct dc *dc, struct dc_state *context,\n\t\t\t\t       display_e2e_pipe_params_st *pipes,\n\t\t\t\t       int pipe_cnt, int vlevel)\n{\n\tint i, pipe_idx, active_hubp_count = 0;\n\tbool usr_retraining_support = false;\n\tbool unbounded_req_enabled = false;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tdc->res_pool->funcs->set_mcif_arb_params(dc, context, pipes, pipe_cnt);\n\n\tcontext->bw_ctx.bw.dcn.clk.dispclk_khz = context->bw_ctx.dml.vba.DISPCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_khz = context->bw_ctx.dml.vba.DCFCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.socclk_khz = context->bw_ctx.dml.vba.SOCCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz = context->bw_ctx.dml.vba.DRAMSpeed * 1000 / 16;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz = context->bw_ctx.dml.vba.DCFCLKDeepSleep * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.fclk_khz = context->bw_ctx.dml.vba.FabricClock * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support =\n\t\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb]\n\t\t\t\t\t!= dm_dram_clock_change_unsupported;\n\n\t \n\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support |= context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching;\n\n\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = 0;\n\tcontext->bw_ctx.bw.dcn.clk.dtbclk_en = is_dtbclk_required(dc, context);\n\tcontext->bw_ctx.bw.dcn.clk.ref_dtbclk_khz = context->bw_ctx.dml.vba.DTBCLKPerState[vlevel] * 1000;\n\tif (context->bw_ctx.dml.vba.FCLKChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb] == dm_fclock_change_unsupported)\n\t\tcontext->bw_ctx.bw.dcn.clk.fclk_p_state_change_support = false;\n\telse\n\t\tcontext->bw_ctx.bw.dcn.clk.fclk_p_state_change_support = true;\n\n\tusr_retraining_support = context->bw_ctx.dml.vba.USRRetrainingSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\tASSERT(usr_retraining_support);\n\n\tif (context->bw_ctx.bw.dcn.clk.dispclk_khz < dc->debug.min_disp_clk_khz)\n\t\tcontext->bw_ctx.bw.dcn.clk.dispclk_khz = dc->debug.min_disp_clk_khz;\n\n\tunbounded_req_enabled = get_unbounded_request_enabled(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tif (unbounded_req_enabled && pipe_cnt > 1) {\n\t\t\n\t\tASSERT(false);\n\t\tunbounded_req_enabled = false;\n\t}\n\n\tcontext->bw_ctx.bw.dcn.mall_ss_size_bytes = 0;\n\tcontext->bw_ctx.bw.dcn.mall_ss_psr_active_size_bytes = 0;\n\tcontext->bw_ctx.bw.dcn.mall_subvp_size_bytes = 0;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tif (context->res_ctx.pipe_ctx[i].plane_state)\n\t\t\tactive_hubp_count++;\n\t\tpipes[pipe_idx].pipe.dest.vstartup_start = get_vstartup(&context->bw_ctx.dml, pipes, pipe_cnt,\n\t\t\t\tpipe_idx);\n\t\tpipes[pipe_idx].pipe.dest.vupdate_offset = get_vupdate_offset(&context->bw_ctx.dml, pipes, pipe_cnt,\n\t\t\t\tpipe_idx);\n\t\tpipes[pipe_idx].pipe.dest.vupdate_width = get_vupdate_width(&context->bw_ctx.dml, pipes, pipe_cnt,\n\t\t\t\tpipe_idx);\n\t\tpipes[pipe_idx].pipe.dest.vready_offset = get_vready_offset(&context->bw_ctx.dml, pipes, pipe_cnt,\n\t\t\t\tpipe_idx);\n\n\t\tif (context->res_ctx.pipe_ctx[i].stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\n\t\t\tcontext->res_ctx.pipe_ctx[i].det_buffer_size_kb = 0;\n\t\t\tcontext->res_ctx.pipe_ctx[i].unbounded_req = false;\n\t\t} else {\n\t\t\tcontext->res_ctx.pipe_ctx[i].det_buffer_size_kb = get_det_buffer_size_kbytes(&context->bw_ctx.dml, pipes, pipe_cnt,\n\t\t\t\t\t\t\tpipe_idx);\n\t\t\tcontext->res_ctx.pipe_ctx[i].unbounded_req = unbounded_req_enabled;\n\t\t}\n\n\t\tif (context->bw_ctx.bw.dcn.clk.dppclk_khz < pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\tif (context->res_ctx.pipe_ctx[i].plane_state)\n\t\t\tcontext->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz = pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\telse\n\t\t\tcontext->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz = 0;\n\t\tcontext->res_ctx.pipe_ctx[i].pipe_dlg_param = pipes[pipe_idx].pipe.dest;\n\n\t\tcontext->res_ctx.pipe_ctx[i].surface_size_in_mall_bytes = get_surface_size_in_mall(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\n\t\tif (vba->ActiveDRAMClockChangeLatencyMarginPerState[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] > 0)\n\t\t\tcontext->res_ctx.pipe_ctx[i].has_vactive_margin = true;\n\t\telse\n\t\t\tcontext->res_ctx.pipe_ctx[i].has_vactive_margin = false;\n\n\t\t \n\t\t \n\t\tif (context->res_ctx.pipe_ctx[i].stream && context->res_ctx.pipe_ctx[i].plane_state &&\n\t\t\t\t(context->res_ctx.pipe_ctx[i].top_pipe == NULL ||\n\t\t\t\tcontext->res_ctx.pipe_ctx[i].plane_state != context->res_ctx.pipe_ctx[i].top_pipe->plane_state) &&\n\t\t\t\tcontext->res_ctx.pipe_ctx[i].prev_odm_pipe == NULL) {\n\t\t\t \n\t\t\tif (context->res_ctx.pipe_ctx[i].stream->mall_stream_config.type != SUBVP_PHANTOM) {\n\t\t\t\tcontext->bw_ctx.bw.dcn.mall_ss_size_bytes += context->res_ctx.pipe_ctx[i].surface_size_in_mall_bytes;\n\n\t\t\t\tif (context->res_ctx.pipe_ctx[i].stream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED) {\n\t\t\t\t\t \n\t\t\t\t\tcontext->bw_ctx.bw.dcn.mall_ss_psr_active_size_bytes += context->res_ctx.pipe_ctx[i].surface_size_in_mall_bytes;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcontext->bw_ctx.bw.dcn.mall_subvp_size_bytes += context->res_ctx.pipe_ctx[i].surface_size_in_mall_bytes;\n\t\t\t}\n\t\t}\n\n\t\tif (context->res_ctx.pipe_ctx[i].stream->adaptive_sync_infopacket.valid)\n\t\t\tdcn20_adjust_freesync_v_startup(\n\t\t\t\t&context->res_ctx.pipe_ctx[i].stream->timing,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].pipe_dlg_param.vstartup_start);\n\n\t\tpipe_idx++;\n\t}\n\t \n\tif (!active_hubp_count) {\n\t\tcontext->bw_ctx.bw.dcn.clk.socclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.dcfclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.fclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = true;\n\t\tcontext->bw_ctx.bw.dcn.clk.fclk_p_state_change_support = true;\n\t}\n\t \n\tcontext->bw_ctx.bw.dcn.clk.bw_dppclk_khz = context->bw_ctx.bw.dcn.clk.dppclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.bw_dispclk_khz = context->bw_ctx.bw.dcn.clk.dispclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dppclk_mhz\n\t\t\t* 1000;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dispclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dispclk_mhz\n\t\t\t* 1000;\n\n\tcontext->bw_ctx.bw.dcn.clk.num_ways = dcn32_helper_calculate_num_ways_for_subvp(dc, context);\n\n\tcontext->bw_ctx.bw.dcn.compbuf_size_kb = context->bw_ctx.dml.ip.config_return_buffer_size_in_kbytes;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontext->bw_ctx.bw.dcn.compbuf_size_kb -= context->res_ctx.pipe_ctx[i].det_buffer_size_kb;\n\t}\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_dlg_reg_v2(&context->bw_ctx.dml,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].dlg_regs, &context->res_ctx.pipe_ctx[i].ttu_regs, pipes,\n\t\t\t\tpipe_cnt, pipe_idx);\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_rq_reg_v2(&context->res_ctx.pipe_ctx[i].rq_regs,\n\t\t\t\t&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\t\tpipe_idx++;\n\t}\n}\n\nstatic struct pipe_ctx *dcn32_find_split_pipe(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tint old_index)\n{\n\tstruct pipe_ctx *pipe = NULL;\n\tint i;\n\n\tif (old_index >= 0 && context->res_ctx.pipe_ctx[old_index].stream == NULL) {\n\t\tpipe = &context->res_ctx.pipe_ctx[old_index];\n\t\tpipe->pipe_idx = old_index;\n\t}\n\n\tif (!pipe)\n\t\tfor (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {\n\t\t\tif (dc->current_state->res_ctx.pipe_ctx[i].top_pipe == NULL\n\t\t\t\t\t&& dc->current_state->res_ctx.pipe_ctx[i].prev_odm_pipe == NULL) {\n\t\t\t\tif (context->res_ctx.pipe_ctx[i].stream == NULL) {\n\t\t\t\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\t\t\t\tpipe->pipe_idx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t \n\tif (!pipe)\n\t\tfor (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream == NULL) {\n\t\t\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\t\t\tpipe->pipe_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\treturn pipe;\n}\n\nstatic bool dcn32_split_stream_for_mpc_or_odm(\n\t\tconst struct dc *dc,\n\t\tstruct resource_context *res_ctx,\n\t\tstruct pipe_ctx *pri_pipe,\n\t\tstruct pipe_ctx *sec_pipe,\n\t\tbool odm)\n{\n\tint pipe_idx = sec_pipe->pipe_idx;\n\tconst struct resource_pool *pool = dc->res_pool;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (odm && pri_pipe->plane_state) {\n\t\t \n\t\tif (pri_pipe->plane_state->clip_rect.x + pri_pipe->plane_state->clip_rect.width <=\n\t\t\t\tpri_pipe->stream->src.x + pri_pipe->stream->src.width/2) {\n\n\t\t\tDC_LOG_SCALER(\"%s - ODM + window MPO(left). pri_pipe:%d\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tpri_pipe->pipe_idx);\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tif (pri_pipe->plane_state->clip_rect.x >= pri_pipe->stream->src.x +  pri_pipe->stream->src.width/2) {\n\n\t\t\tDC_LOG_SCALER(\"%s - ODM + window MPO(right). pri_pipe:%d\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tpri_pipe->pipe_idx);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*sec_pipe = *pri_pipe;\n\n\tsec_pipe->pipe_idx = pipe_idx;\n\tsec_pipe->plane_res.mi = pool->mis[pipe_idx];\n\tsec_pipe->plane_res.hubp = pool->hubps[pipe_idx];\n\tsec_pipe->plane_res.ipp = pool->ipps[pipe_idx];\n\tsec_pipe->plane_res.xfm = pool->transforms[pipe_idx];\n\tsec_pipe->plane_res.dpp = pool->dpps[pipe_idx];\n\tsec_pipe->plane_res.mpcc_inst = pool->dpps[pipe_idx]->inst;\n\tsec_pipe->stream_res.dsc = NULL;\n\tif (odm) {\n\t\tif (pri_pipe->next_odm_pipe) {\n\t\t\tASSERT(pri_pipe->next_odm_pipe != sec_pipe);\n\t\t\tsec_pipe->next_odm_pipe = pri_pipe->next_odm_pipe;\n\t\t\tsec_pipe->next_odm_pipe->prev_odm_pipe = sec_pipe;\n\t\t}\n\t\tif (pri_pipe->top_pipe && pri_pipe->top_pipe->next_odm_pipe) {\n\t\t\tpri_pipe->top_pipe->next_odm_pipe->bottom_pipe = sec_pipe;\n\t\t\tsec_pipe->top_pipe = pri_pipe->top_pipe->next_odm_pipe;\n\t\t}\n\t\tif (pri_pipe->bottom_pipe && pri_pipe->bottom_pipe->next_odm_pipe) {\n\t\t\tpri_pipe->bottom_pipe->next_odm_pipe->top_pipe = sec_pipe;\n\t\t\tsec_pipe->bottom_pipe = pri_pipe->bottom_pipe->next_odm_pipe;\n\t\t}\n\t\tpri_pipe->next_odm_pipe = sec_pipe;\n\t\tsec_pipe->prev_odm_pipe = pri_pipe;\n\t\tASSERT(sec_pipe->top_pipe == NULL);\n\n\t\tif (!sec_pipe->top_pipe)\n\t\t\tsec_pipe->stream_res.opp = pool->opps[pipe_idx];\n\t\telse\n\t\t\tsec_pipe->stream_res.opp = sec_pipe->top_pipe->stream_res.opp;\n\t\tif (sec_pipe->stream->timing.flags.DSC == 1) {\n\t\t\tdcn20_acquire_dsc(dc, res_ctx, &sec_pipe->stream_res.dsc, pipe_idx);\n\t\t\tASSERT(sec_pipe->stream_res.dsc);\n\t\t\tif (sec_pipe->stream_res.dsc == NULL)\n\t\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (pri_pipe->bottom_pipe) {\n\t\t\tASSERT(pri_pipe->bottom_pipe != sec_pipe);\n\t\t\tsec_pipe->bottom_pipe = pri_pipe->bottom_pipe;\n\t\t\tsec_pipe->bottom_pipe->top_pipe = sec_pipe;\n\t\t}\n\t\tpri_pipe->bottom_pipe = sec_pipe;\n\t\tsec_pipe->top_pipe = pri_pipe;\n\n\t\tASSERT(pri_pipe->plane_state);\n\t}\n\n\treturn true;\n}\n\nbool dcn32_internal_validate_bw(struct dc *dc,\n\t\t\t\tstruct dc_state *context,\n\t\t\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\t\t\tint *pipe_cnt_out,\n\t\t\t\tint *vlevel_out,\n\t\t\t\tbool fast_validate)\n{\n\tbool out = false;\n\tbool repopulate_pipes = false;\n\tint split[MAX_PIPES] = { 0 };\n\tbool merge[MAX_PIPES] = { false };\n\tbool newly_split[MAX_PIPES] = { false };\n\tint pipe_cnt, i, pipe_idx;\n\tint vlevel = context->bw_ctx.dml.soc.num_states;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\n\tdc_assert_fp_enabled();\n\n\tASSERT(pipes);\n\tif (!pipes)\n\t\treturn false;\n\n\t \n\tdc->res_pool->funcs->remove_phantom_pipes(dc, context, fast_validate);\n\n\tdc->res_pool->funcs->update_soc_for_wm_a(dc, context);\n\n\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc, context, pipes, fast_validate);\n\n\tif (!pipe_cnt) {\n\t\tout = true;\n\t\tgoto validate_out;\n\t}\n\n\tdml_log_pipe_params(&context->bw_ctx.dml, pipes, pipe_cnt);\n\tcontext->bw_ctx.dml.soc.max_vratio_pre = dcn32_determine_max_vratio_prefetch(dc, context);\n\n\tif (!fast_validate)\n\t\tdcn32_full_validate_bw_helper(dc, context, pipes, &vlevel, split, merge, &pipe_cnt);\n\n\tif (fast_validate ||\n\t\t\t(dc->debug.dml_disallow_alternate_prefetch_modes &&\n\t\t\t(vlevel == context->bw_ctx.dml.soc.num_states ||\n\t\t\t\tvba->DRAMClockChangeSupport[vlevel][vba->maxMpcComb] == dm_dram_clock_change_unsupported))) {\n\t\t \n\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final =\n\t\t\tdm_prefetch_support_none;\n\n\t\tcontext->bw_ctx.dml.validate_max_state = fast_validate;\n\t\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\t\tcontext->bw_ctx.dml.validate_max_state = false;\n\n\t\tif (vlevel < context->bw_ctx.dml.soc.num_states) {\n\t\t\tmemset(split, 0, sizeof(split));\n\t\t\tmemset(merge, 0, sizeof(merge));\n\t\t\tvlevel = dcn20_validate_apply_pipe_split_flags(dc, context, vlevel, split, merge);\n\t\t\t \n\t\t\tvba->VoltageLevel = vlevel;\n\t\t}\n\t}\n\n\tdml_log_mode_support_params(&context->bw_ctx.dml);\n\n\tif (vlevel == context->bw_ctx.dml.soc.num_states)\n\t\tgoto validate_fail;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *mpo_pipe = pipe->bottom_pipe;\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (vba->ODMCombineEnabled[vba->pipe_plane[pipe_idx]] != dm_odm_combine_mode_disabled\n\t\t\t\t&& !dc->config.enable_windowed_mpo_odm\n\t\t\t\t&& pipe->plane_state && mpo_pipe\n\t\t\t\t&& memcmp(&mpo_pipe->plane_state->clip_rect,\n\t\t\t\t\t\t&pipe->stream->src,\n\t\t\t\t\t\tsizeof(struct rect)) != 0) {\n\t\t\tASSERT(mpo_pipe->plane_state != pipe->plane_state);\n\t\t\tgoto validate_fail;\n\t\t}\n\t\tpipe_idx++;\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (!merge[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pipe->prev_odm_pipe) {\n\t\t\t \n\t\t\tpipe->prev_odm_pipe->next_odm_pipe = pipe->next_odm_pipe;\n\t\t\tif (pipe->next_odm_pipe)\n\t\t\t\tpipe->next_odm_pipe->prev_odm_pipe = pipe->prev_odm_pipe;\n\n\t\t\t \n\t\t\tif (pipe->bottom_pipe) {\n\t\t\t\tif (pipe->bottom_pipe->prev_odm_pipe || pipe->bottom_pipe->next_odm_pipe) {\n\t\t\t\t\t \n\t\t\t\t\tpipe->bottom_pipe->top_pipe = NULL;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (pipe->prev_odm_pipe->bottom_pipe) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tpipe->bottom_pipe->top_pipe = pipe->prev_odm_pipe->bottom_pipe;\n\t\t\t\t\t\tpipe->prev_odm_pipe->bottom_pipe->bottom_pipe = pipe->bottom_pipe;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tpipe->bottom_pipe->top_pipe = pipe->prev_odm_pipe;\n\t\t\t\t\t\tpipe->prev_odm_pipe->bottom_pipe = pipe->bottom_pipe;\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(&pipe->bottom_pipe->stream_res, &pipe->bottom_pipe->top_pipe->stream_res, sizeof(struct stream_resource));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pipe->top_pipe) {\n\t\t\t\tpipe->top_pipe->bottom_pipe = NULL;\n\t\t\t}\n\n\t\t\tpipe->bottom_pipe = NULL;\n\t\t\tpipe->next_odm_pipe = NULL;\n\t\t\tpipe->plane_state = NULL;\n\t\t\tpipe->stream = NULL;\n\t\t\tpipe->top_pipe = NULL;\n\t\t\tpipe->prev_odm_pipe = NULL;\n\t\t\tif (pipe->stream_res.dsc)\n\t\t\t\tdcn20_release_dsc(&context->res_ctx, dc->res_pool, &pipe->stream_res.dsc);\n\t\t\tmemset(&pipe->plane_res, 0, sizeof(pipe->plane_res));\n\t\t\tmemset(&pipe->stream_res, 0, sizeof(pipe->stream_res));\n\t\t\tmemset(&pipe->link_res, 0, sizeof(pipe->link_res));\n\t\t\trepopulate_pipes = true;\n\t\t} else if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state) {\n\t\t\tstruct pipe_ctx *top_pipe = pipe->top_pipe;\n\t\t\tstruct pipe_ctx *bottom_pipe = pipe->bottom_pipe;\n\n\t\t\ttop_pipe->bottom_pipe = bottom_pipe;\n\t\t\tif (bottom_pipe)\n\t\t\t\tbottom_pipe->top_pipe = top_pipe;\n\n\t\t\tpipe->top_pipe = NULL;\n\t\t\tpipe->bottom_pipe = NULL;\n\t\t\tpipe->plane_state = NULL;\n\t\t\tpipe->stream = NULL;\n\t\t\tmemset(&pipe->plane_res, 0, sizeof(pipe->plane_res));\n\t\t\tmemset(&pipe->stream_res, 0, sizeof(pipe->stream_res));\n\t\t\tmemset(&pipe->link_res, 0, sizeof(pipe->link_res));\n\t\t\trepopulate_pipes = true;\n\t\t} else\n\t\t\tASSERT(0);  \n\n\t}\n\n\tfor (i = 0, pipe_idx = -1; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *hsplit_pipe = NULL;\n\t\tbool odm;\n\t\tint old_index = -1;\n\n\t\tif (!pipe->stream || newly_split[i])\n\t\t\tcontinue;\n\n\t\tpipe_idx++;\n\t\todm = vba->ODMCombineEnabled[vba->pipe_plane[pipe_idx]] != dm_odm_combine_mode_disabled;\n\n\t\tif (!pipe->plane_state && !odm)\n\t\t\tcontinue;\n\n\t\tif (split[i]) {\n\t\t\tif (odm) {\n\t\t\t\tif (split[i] == 4 && old_pipe->next_odm_pipe && old_pipe->next_odm_pipe->next_odm_pipe)\n\t\t\t\t\told_index = old_pipe->next_odm_pipe->next_odm_pipe->pipe_idx;\n\t\t\t\telse if (old_pipe->next_odm_pipe)\n\t\t\t\t\told_index = old_pipe->next_odm_pipe->pipe_idx;\n\t\t\t} else {\n\t\t\t\tif (split[i] == 4 && old_pipe->bottom_pipe && old_pipe->bottom_pipe->bottom_pipe &&\n\t\t\t\t\t\told_pipe->bottom_pipe->bottom_pipe->plane_state == old_pipe->plane_state)\n\t\t\t\t\told_index = old_pipe->bottom_pipe->bottom_pipe->pipe_idx;\n\t\t\t\telse if (old_pipe->bottom_pipe &&\n\t\t\t\t\t\told_pipe->bottom_pipe->plane_state == old_pipe->plane_state)\n\t\t\t\t\told_index = old_pipe->bottom_pipe->pipe_idx;\n\t\t\t}\n\t\t\thsplit_pipe = dcn32_find_split_pipe(dc, context, old_index);\n\t\t\tASSERT(hsplit_pipe);\n\t\t\tif (!hsplit_pipe)\n\t\t\t\tgoto validate_fail;\n\n\t\t\tif (!dcn32_split_stream_for_mpc_or_odm(\n\t\t\t\t\tdc, &context->res_ctx,\n\t\t\t\t\tpipe, hsplit_pipe, odm))\n\t\t\t\tgoto validate_fail;\n\n\t\t\tnewly_split[hsplit_pipe->pipe_idx] = true;\n\t\t\trepopulate_pipes = true;\n\t\t}\n\t\tif (split[i] == 4) {\n\t\t\tstruct pipe_ctx *pipe_4to1;\n\n\t\t\tif (odm && old_pipe->next_odm_pipe)\n\t\t\t\told_index = old_pipe->next_odm_pipe->pipe_idx;\n\t\t\telse if (!odm && old_pipe->bottom_pipe &&\n\t\t\t\t\t\told_pipe->bottom_pipe->plane_state == old_pipe->plane_state)\n\t\t\t\told_index = old_pipe->bottom_pipe->pipe_idx;\n\t\t\telse\n\t\t\t\told_index = -1;\n\t\t\tpipe_4to1 = dcn32_find_split_pipe(dc, context, old_index);\n\t\t\tASSERT(pipe_4to1);\n\t\t\tif (!pipe_4to1)\n\t\t\t\tgoto validate_fail;\n\t\t\tif (!dcn32_split_stream_for_mpc_or_odm(\n\t\t\t\t\tdc, &context->res_ctx,\n\t\t\t\t\tpipe, pipe_4to1, odm))\n\t\t\t\tgoto validate_fail;\n\t\t\tnewly_split[pipe_4to1->pipe_idx] = true;\n\n\t\t\tif (odm && old_pipe->next_odm_pipe && old_pipe->next_odm_pipe->next_odm_pipe\n\t\t\t\t\t&& old_pipe->next_odm_pipe->next_odm_pipe->next_odm_pipe)\n\t\t\t\told_index = old_pipe->next_odm_pipe->next_odm_pipe->next_odm_pipe->pipe_idx;\n\t\t\telse if (!odm && old_pipe->bottom_pipe && old_pipe->bottom_pipe->bottom_pipe &&\n\t\t\t\t\told_pipe->bottom_pipe->bottom_pipe->bottom_pipe &&\n\t\t\t\t\told_pipe->bottom_pipe->bottom_pipe->bottom_pipe->plane_state == old_pipe->plane_state)\n\t\t\t\told_index = old_pipe->bottom_pipe->bottom_pipe->bottom_pipe->pipe_idx;\n\t\t\telse\n\t\t\t\told_index = -1;\n\t\t\tpipe_4to1 = dcn32_find_split_pipe(dc, context, old_index);\n\t\t\tASSERT(pipe_4to1);\n\t\t\tif (!pipe_4to1)\n\t\t\t\tgoto validate_fail;\n\t\t\tif (!dcn32_split_stream_for_mpc_or_odm(\n\t\t\t\t\tdc, &context->res_ctx,\n\t\t\t\t\thsplit_pipe, pipe_4to1, odm))\n\t\t\t\tgoto validate_fail;\n\t\t\tnewly_split[pipe_4to1->pipe_idx] = true;\n\t\t}\n\t\tif (odm)\n\t\t\tdcn20_build_mapped_resource(dc, context, pipe->stream);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->plane_state) {\n\t\t\tif (!resource_build_scaling_params(pipe))\n\t\t\t\tgoto validate_fail;\n\t\t}\n\t}\n\n\t \n\tif (!dcn20_validate_dsc(dc, context)) {\n\t\tvba->ValidationStatus[vba->soc.num_states] = DML_FAIL_DSC_VALIDATION_FAILURE;\n\t\tgoto validate_fail;\n\t}\n\n\tif (repopulate_pipes) {\n\t\tint flag_max_mpc_comb = vba->maxMpcComb;\n\t\tint flag_vlevel = vlevel;\n\t\tint i;\n\n\t\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc, context, pipes, fast_validate);\n\n\t\t \n\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final =\n\t\t\t\t\tdm_prefetch_support_uclk_fclk_and_stutter_if_possible;\n\t\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\t\tif (vlevel == context->bw_ctx.dml.soc.num_states) {\n\t\t\t \n\t\t\tgoto validate_fail;\n\t\t} else if (flag_max_mpc_comb == 0 &&\n\t\t\t\tflag_max_mpc_comb != context->bw_ctx.dml.vba.maxMpcComb) {\n\t\t\t \n\t\t\tbool flags_valid = false;\n\t\t\tfor (i = flag_vlevel; i < context->bw_ctx.dml.soc.num_states; i++) {\n\t\t\t\tif (vba->ModeSupport[i][flag_max_mpc_comb]) {\n\t\t\t\t\tvba->maxMpcComb = flag_max_mpc_comb;\n\t\t\t\t\tvba->VoltageLevel = i;\n\t\t\t\t\tvlevel = i;\n\t\t\t\t\tflags_valid = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!flags_valid)\n\t\t\t\tgoto validate_fail;\n\t\t}\n\t}\n\t*vlevel_out = vlevel;\n\t*pipe_cnt_out = pipe_cnt;\n\n\tout = true;\n\tgoto validate_out;\n\nvalidate_fail:\n\tout = false;\n\nvalidate_out:\n\treturn out;\n}\n\n\nvoid dcn32_calculate_wm_and_dlg_fpu(struct dc *dc, struct dc_state *context,\n\t\t\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\t\t\tint pipe_cnt,\n\t\t\t\tint vlevel)\n{\n\tint i, pipe_idx, vlevel_temp = 0;\n\tdouble dcfclk = dcn3_2_soc.clock_limits[0].dcfclk_mhz;\n\tdouble dcfclk_from_validation = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\tdouble dram_speed_from_validation = context->bw_ctx.dml.vba.DRAMSpeed;\n\tdouble dcfclk_from_fw_based_mclk_switching = dcfclk_from_validation;\n\tbool pstate_en = context->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb] !=\n\t\t\tdm_dram_clock_change_unsupported;\n\tunsigned int dummy_latency_index = 0;\n\tint maxMpcComb = context->bw_ctx.dml.vba.maxMpcComb;\n\tunsigned int min_dram_speed_mts = context->bw_ctx.dml.vba.DRAMSpeed;\n\tbool subvp_in_use = dcn32_subvp_in_use(dc, context);\n\tunsigned int min_dram_speed_mts_margin;\n\tbool need_fclk_lat_as_dummy = false;\n\tbool is_subvp_p_drr = false;\n\tstruct dc_stream_state *fpo_candidate_stream = NULL;\n\n\tdc_assert_fp_enabled();\n\n\t \n\tif (subvp_in_use) {\n\t\t \n\t\tif (!pstate_en) {\n\t\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] = dm_dram_clock_change_vblank_w_mall_sub_vp;\n\t\t\tcontext->bw_ctx.dml.soc.allow_for_pstate_or_stutter_in_vblank_final = dm_prefetch_support_fclk_and_stutter;\n\t\t\tpstate_en = true;\n\t\t\tis_subvp_p_drr = true;\n\t\t}\n\t\tdummy_latency_index = dcn32_find_dummy_latency_index_for_fw_based_mclk_switch(dc,\n\t\t\t\t\t\tcontext, pipes, pipe_cnt, vlevel);\n\n\t\t \n\t\tif (context->bw_ctx.dml.soc.fclk_change_latency_us < dc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us) {\n\t\t\tneed_fclk_lat_as_dummy = true;\n\t\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us =\n\t\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\t\t}\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\t\t\t\tdc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\t\tdcn32_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, false);\n\t\tmaxMpcComb = context->bw_ctx.dml.vba.maxMpcComb;\n\t\tif (is_subvp_p_drr) {\n\t\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] = dm_dram_clock_change_vblank_w_mall_sub_vp;\n\t\t}\n\t}\n\n\tcontext->bw_ctx.bw.dcn.clk.fw_based_mclk_switching = false;\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i])\n\t\t\tcontext->streams[i]->fpo_in_use = false;\n\t}\n\n\tif (!pstate_en || (!dc->debug.disable_fpo_optimizations &&\n\t\t\tpstate_en && vlevel != 0)) {\n\t\t \n\t\tfpo_candidate_stream = dcn32_can_support_mclk_switch_using_fw_based_vblank_stretch(dc, context);\n\t\tif (fpo_candidate_stream) {\n\t\t\tfpo_candidate_stream->fpo_in_use = true;\n\t\t\tcontext->bw_ctx.bw.dcn.clk.fw_based_mclk_switching = true;\n\t\t}\n\n\t\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\t\tdummy_latency_index = dcn32_find_dummy_latency_index_for_fw_based_mclk_switch(dc,\n\t\t\t\tcontext, pipes, pipe_cnt, vlevel);\n\n\t\t\t \n\t\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\t\tdc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\t\t\t \n\t\t\tif (context->bw_ctx.dml.soc.fclk_change_latency_us < dc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us) {\n\t\t\t\tneed_fclk_lat_as_dummy = true;\n\t\t\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us =\n\t\t\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\t\t\t}\n\t\t\tdcn32_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel_temp, false);\n\t\t\tif (vlevel_temp < vlevel) {\n\t\t\t\tvlevel = vlevel_temp;\n\t\t\t\tmaxMpcComb = context->bw_ctx.dml.vba.maxMpcComb;\n\t\t\t\tdcfclk_from_fw_based_mclk_switching = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\t\t\t\tpstate_en = true;\n\t\t\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] = dm_dram_clock_change_vblank;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcontext->bw_ctx.bw.dcn.clk.fw_based_mclk_switching = false;\n\t\t\t\tfor (i = 0; i < context->stream_count; i++) {\n\t\t\t\t\tif (context->streams[i])\n\t\t\t\t\t\tcontext->streams[i]->fpo_in_use = false;\n\t\t\t\t}\n\t\t\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.fclk_change_latency_us;\n\t\t\t\tdcn32_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (dcn3_2_soc.num_states > 2) {\n\t\tvlevel_temp = 2;\n\t\tdcfclk = dcn3_2_soc.clock_limits[2].dcfclk_mhz;\n\t} else\n\t\tdcfclk = 615; \n\n\tpipes[0].clks_cfg.voltage = vlevel_temp;\n\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel_temp].socclk_mhz;\n\n\tif (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].valid) {\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.pstate_latency_us;\n\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.fclk_change_latency_us;\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_B].dml_input.sr_exit_time_us;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.fclk_pstate_change_ns = get_fclk_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.usr_retraining_ns = get_usr_retraining_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\t \n\n\t \n\n\t \n\n\t\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk_from_validation;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\tpipes[0].clks_cfg.dcfclk_mhz = dcfclk_from_fw_based_mclk_switching;\n\t}\n\n\tif (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].valid) {\n\t\tmin_dram_speed_mts = dram_speed_from_validation;\n\t\tmin_dram_speed_mts_margin = 160;\n\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[0].dummy_pstate_latency_us;\n\n\t\tif (context->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][maxMpcComb] ==\n\t\t\tdm_dram_clock_change_unsupported) {\n\t\t\tint min_dram_speed_mts_offset = dc->clk_mgr->bw_params->clk_table.num_entries_per_clk.num_memclk_levels - 1;\n\n\t\t\tmin_dram_speed_mts =\n\t\t\t\tdc->clk_mgr->bw_params->clk_table.entries[min_dram_speed_mts_offset].memclk_mhz * 16;\n\t\t}\n\n\t\tif (!context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching && !subvp_in_use) {\n\t\t\t \n\t\t\tfor (dummy_latency_index = 3; dummy_latency_index > 0; dummy_latency_index--)\n\t\t\t\tif (min_dram_speed_mts + min_dram_speed_mts_margin >\n\t\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dram_speed_mts)\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\n\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].dml_input.fclk_change_latency_us;\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].dml_input.sr_exit_time_us;\n\t}\n\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t \n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.fclk_pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.usr_retraining_ns = get_usr_retraining_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif ((!pstate_en) && (dc->clk_mgr->bw_params->wm_table.nv_entries[WM_C].valid)) {\n\t\t \n\t\tcontext->bw_ctx.bw.dcn.watermarks.a = context->bw_ctx.bw.dcn.watermarks.c;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = 0;\n\t\t \n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.fclk_pstate_change_ns = get_fclk_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t} else {\n\t\t \n\n\t\t \n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\t\tcontext->bw_ctx.dml.soc.sr_enter_plus_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_enter_plus_exit_time_us;\n\t\tcontext->bw_ctx.dml.soc.sr_exit_time_us = dc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.sr_exit_time_us;\n\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_latency_ns = get_urgent_latency(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.fclk_pstate_change_ns = get_fclk_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\tcontext->bw_ctx.bw.dcn.watermarks.a.usr_retraining_ns = get_usr_retraining_watermark(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t}\n\n\t \n\tcontext->bw_ctx.bw.dcn.watermarks.d = context->bw_ctx.bw.dcn.watermarks.a;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = get_dispclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt);\n\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = get_dppclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\n\t\tif (dc->config.forced_clocks) {\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dispclk_mhz;\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dppclk_mhz;\n\t\t}\n\t\tif (dc->debug.min_disp_clk_khz > pipes[pipe_idx].clks_cfg.dispclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = dc->debug.min_disp_clk_khz / 1000.0;\n\t\tif (dc->debug.min_dpp_clk_khz > pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = dc->debug.min_dpp_clk_khz / 1000.0;\n\n\t\tpipe_idx++;\n\t}\n\n\tcontext->perf_params.stutter_period_us = context->bw_ctx.dml.vba.StutterPeriod;\n\n\t \n\tif (need_fclk_lat_as_dummy)\n\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->dummy_pstate_table[dummy_latency_index].dummy_pstate_latency_us;\n\n\tdcn32_calculate_dlg_params(dc, context, pipes, pipe_cnt, vlevel);\n\n\tif (!pstate_en)\n\t\t \n\t\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.pstate_latency_us;\n\n\t \n\tif (need_fclk_lat_as_dummy)\n\t\tcontext->bw_ctx.dml.soc.fclk_change_latency_us =\n\t\t\t\tdc->clk_mgr->bw_params->wm_table.nv_entries[WM_A].dml_input.fclk_change_latency_us;\n}\n\nstatic void dcn32_get_optimal_dcfclk_fclk_for_uclk(unsigned int uclk_mts,\n\t\tunsigned int *optimal_dcfclk,\n\t\tunsigned int *optimal_fclk)\n{\n\tdouble bw_from_dram, bw_from_dram1, bw_from_dram2;\n\n\tbw_from_dram1 = uclk_mts * dcn3_2_soc.num_chans *\n\t\tdcn3_2_soc.dram_channel_width_bytes * (dcn3_2_soc.max_avg_dram_bw_use_normal_percent / 100);\n\tbw_from_dram2 = uclk_mts * dcn3_2_soc.num_chans *\n\t\tdcn3_2_soc.dram_channel_width_bytes * (dcn3_2_soc.max_avg_sdp_bw_use_normal_percent / 100);\n\n\tbw_from_dram = (bw_from_dram1 < bw_from_dram2) ? bw_from_dram1 : bw_from_dram2;\n\n\tif (optimal_fclk)\n\t\t*optimal_fclk = bw_from_dram /\n\t\t(dcn3_2_soc.fabric_datapath_to_dcn_data_return_bytes * (dcn3_2_soc.max_avg_sdp_bw_use_normal_percent / 100));\n\n\tif (optimal_dcfclk)\n\t\t*optimal_dcfclk =  bw_from_dram /\n\t\t(dcn3_2_soc.return_bus_width_bytes * (dcn3_2_soc.max_avg_sdp_bw_use_normal_percent / 100));\n}\n\nstatic void remove_entry_from_table_at_index(struct _vcs_dpi_voltage_scaling_st *table, unsigned int *num_entries,\n\t\tunsigned int index)\n{\n\tint i;\n\n\tif (*num_entries == 0)\n\t\treturn;\n\n\tfor (i = index; i < *num_entries - 1; i++) {\n\t\ttable[i] = table[i + 1];\n\t}\n\tmemset(&table[--(*num_entries)], 0, sizeof(struct _vcs_dpi_voltage_scaling_st));\n}\n\nvoid dcn32_patch_dpm_table(struct clk_bw_params *bw_params)\n{\n\tint i;\n\tunsigned int max_dcfclk_mhz = 0, max_dispclk_mhz = 0, max_dppclk_mhz = 0,\n\t\t\tmax_phyclk_mhz = 0, max_dtbclk_mhz = 0, max_fclk_mhz = 0, max_uclk_mhz = 0;\n\n\tfor (i = 0; i < MAX_NUM_DPM_LVL; i++) {\n\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz > max_dcfclk_mhz)\n\t\t\tmax_dcfclk_mhz = bw_params->clk_table.entries[i].dcfclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].fclk_mhz > max_fclk_mhz)\n\t\t\tmax_fclk_mhz = bw_params->clk_table.entries[i].fclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].memclk_mhz > max_uclk_mhz)\n\t\t\tmax_uclk_mhz = bw_params->clk_table.entries[i].memclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dispclk_mhz > max_dispclk_mhz)\n\t\t\tmax_dispclk_mhz = bw_params->clk_table.entries[i].dispclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dppclk_mhz > max_dppclk_mhz)\n\t\t\tmax_dppclk_mhz = bw_params->clk_table.entries[i].dppclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].phyclk_mhz > max_phyclk_mhz)\n\t\t\tmax_phyclk_mhz = bw_params->clk_table.entries[i].phyclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dtbclk_mhz > max_dtbclk_mhz)\n\t\t\tmax_dtbclk_mhz = bw_params->clk_table.entries[i].dtbclk_mhz;\n\t}\n\n\t \n\tif (max_dcfclk_mhz == 0)\n\t\tbw_params->clk_table.entries[0].dcfclk_mhz = dcn3_2_soc.clock_limits[0].dcfclk_mhz;\n\tif (max_dispclk_mhz == 0)\n\t\tbw_params->clk_table.entries[0].dispclk_mhz = dcn3_2_soc.clock_limits[0].dispclk_mhz;\n\tif (max_dtbclk_mhz == 0)\n\t\tbw_params->clk_table.entries[0].dtbclk_mhz = dcn3_2_soc.clock_limits[0].dtbclk_mhz;\n\tif (max_uclk_mhz == 0)\n\t\tbw_params->clk_table.entries[0].memclk_mhz = dcn3_2_soc.clock_limits[0].dram_speed_mts / 16;\n}\n\nstatic void swap_table_entries(struct _vcs_dpi_voltage_scaling_st *first_entry,\n\t\tstruct _vcs_dpi_voltage_scaling_st *second_entry)\n{\n\tstruct _vcs_dpi_voltage_scaling_st temp_entry = *first_entry;\n\t*first_entry = *second_entry;\n\t*second_entry = temp_entry;\n}\n\n \nstatic void sort_entries_with_same_bw(struct _vcs_dpi_voltage_scaling_st *table, unsigned int *num_entries)\n{\n\tunsigned int start_index = 0;\n\tunsigned int end_index = 0;\n\tunsigned int current_bw = 0;\n\n\tfor (int i = 0; i < (*num_entries - 1); i++) {\n\t\tif (table[i].net_bw_in_kbytes_sec == table[i+1].net_bw_in_kbytes_sec) {\n\t\t\tcurrent_bw = table[i].net_bw_in_kbytes_sec;\n\t\t\tstart_index = i;\n\t\t\tend_index = ++i;\n\n\t\t\twhile ((i < (*num_entries - 1)) && (table[i+1].net_bw_in_kbytes_sec == current_bw))\n\t\t\t\tend_index = ++i;\n\t\t}\n\n\t\tif (start_index != end_index) {\n\t\t\tfor (int j = start_index; j < end_index; j++) {\n\t\t\t\tfor (int k = start_index; k < end_index; k++) {\n\t\t\t\t\tif (table[k].dcfclk_mhz > table[k+1].dcfclk_mhz)\n\t\t\t\t\t\tswap_table_entries(&table[k], &table[k+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_index = 0;\n\t\tend_index = 0;\n\n\t}\n}\n\n \nstatic void remove_inconsistent_entries(struct _vcs_dpi_voltage_scaling_st *table, unsigned int *num_entries)\n{\n\tfor (int i = 0; i < (*num_entries - 1); i++) {\n\t\tif (table[i].net_bw_in_kbytes_sec == table[i+1].net_bw_in_kbytes_sec) {\n\t\t\tif ((table[i].dram_speed_mts > table[i+1].dram_speed_mts) ||\n\t\t\t\t(table[i].fabricclk_mhz > table[i+1].fabricclk_mhz))\n\t\t\t\tremove_entry_from_table_at_index(table, num_entries, i);\n\t\t}\n\t}\n}\n\n \nstatic int override_max_clk_values(struct clk_limit_table_entry *max_clk_limit,\n\t\tstruct clk_limit_table_entry *curr_clk_limit)\n{\n\tif (NULL == max_clk_limit || NULL == curr_clk_limit)\n\t\treturn -1; \n\n\t\n\tif (max_clk_limit->dcfclk_mhz != 0)\n\t\tcurr_clk_limit->dcfclk_mhz = max_clk_limit->dcfclk_mhz;\n\n\tif (max_clk_limit->fclk_mhz != 0)\n\t\tcurr_clk_limit->fclk_mhz = max_clk_limit->fclk_mhz;\n\n\tif (max_clk_limit->memclk_mhz != 0)\n\t\tcurr_clk_limit->memclk_mhz = max_clk_limit->memclk_mhz;\n\n\tif (max_clk_limit->socclk_mhz != 0)\n\t\tcurr_clk_limit->socclk_mhz = max_clk_limit->socclk_mhz;\n\n\tif (max_clk_limit->dtbclk_mhz != 0)\n\t\tcurr_clk_limit->dtbclk_mhz = max_clk_limit->dtbclk_mhz;\n\n\tif (max_clk_limit->dispclk_mhz != 0)\n\t\tcurr_clk_limit->dispclk_mhz = max_clk_limit->dispclk_mhz;\n\n\treturn 0;\n}\n\nstatic int build_synthetic_soc_states(bool disable_dc_mode_overwrite, struct clk_bw_params *bw_params,\n\t\tstruct _vcs_dpi_voltage_scaling_st *table, unsigned int *num_entries)\n{\n\tint i, j;\n\tstruct _vcs_dpi_voltage_scaling_st entry = {0};\n\tstruct clk_limit_table_entry max_clk_data = {0};\n\n\tunsigned int min_dcfclk_mhz = 199, min_fclk_mhz = 299;\n\n\tstatic const unsigned int num_dcfclk_stas = 5;\n\tunsigned int dcfclk_sta_targets[DC__VOLTAGE_STATES] = {199, 615, 906, 1324, 1564};\n\n\tunsigned int num_uclk_dpms = 0;\n\tunsigned int num_fclk_dpms = 0;\n\tunsigned int num_dcfclk_dpms = 0;\n\n\tunsigned int num_dc_uclk_dpms = 0;\n\tunsigned int num_dc_fclk_dpms = 0;\n\tunsigned int num_dc_dcfclk_dpms = 0;\n\n\tfor (i = 0; i < MAX_NUM_DPM_LVL; i++) {\n\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz > max_clk_data.dcfclk_mhz)\n\t\t\tmax_clk_data.dcfclk_mhz = bw_params->clk_table.entries[i].dcfclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].fclk_mhz > max_clk_data.fclk_mhz)\n\t\t\tmax_clk_data.fclk_mhz = bw_params->clk_table.entries[i].fclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].memclk_mhz > max_clk_data.memclk_mhz)\n\t\t\tmax_clk_data.memclk_mhz = bw_params->clk_table.entries[i].memclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dispclk_mhz > max_clk_data.dispclk_mhz)\n\t\t\tmax_clk_data.dispclk_mhz = bw_params->clk_table.entries[i].dispclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dppclk_mhz > max_clk_data.dppclk_mhz)\n\t\t\tmax_clk_data.dppclk_mhz = bw_params->clk_table.entries[i].dppclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].phyclk_mhz > max_clk_data.phyclk_mhz)\n\t\t\tmax_clk_data.phyclk_mhz = bw_params->clk_table.entries[i].phyclk_mhz;\n\t\tif (bw_params->clk_table.entries[i].dtbclk_mhz > max_clk_data.dtbclk_mhz)\n\t\t\tmax_clk_data.dtbclk_mhz = bw_params->clk_table.entries[i].dtbclk_mhz;\n\n\t\tif (bw_params->clk_table.entries[i].memclk_mhz > 0) {\n\t\t\tnum_uclk_dpms++;\n\t\t\tif (bw_params->clk_table.entries[i].memclk_mhz <= bw_params->dc_mode_limit.memclk_mhz)\n\t\t\t\tnum_dc_uclk_dpms++;\n\t\t}\n\t\tif (bw_params->clk_table.entries[i].fclk_mhz > 0) {\n\t\t\tnum_fclk_dpms++;\n\t\t\tif (bw_params->clk_table.entries[i].fclk_mhz <= bw_params->dc_mode_limit.fclk_mhz)\n\t\t\t\tnum_dc_fclk_dpms++;\n\t\t}\n\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz > 0) {\n\t\t\tnum_dcfclk_dpms++;\n\t\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz <= bw_params->dc_mode_limit.dcfclk_mhz)\n\t\t\t\tnum_dc_dcfclk_dpms++;\n\t\t}\n\t}\n\n\tif (!disable_dc_mode_overwrite) {\n\t\t\n\t\toverride_max_clk_values(&bw_params->dc_mode_limit, &max_clk_data);\n\t\tnum_uclk_dpms = num_dc_uclk_dpms;\n\t\tnum_fclk_dpms = num_dc_fclk_dpms;\n\t\tnum_dcfclk_dpms = num_dc_dcfclk_dpms;\n\t\tbw_params->clk_table.num_entries_per_clk.num_memclk_levels = num_uclk_dpms;\n\t\tbw_params->clk_table.num_entries_per_clk.num_fclk_levels = num_fclk_dpms;\n\t}\n\n\tif (num_dcfclk_dpms > 0 && bw_params->clk_table.entries[0].fclk_mhz > min_fclk_mhz)\n\t\tmin_fclk_mhz = bw_params->clk_table.entries[0].fclk_mhz;\n\n\tif (!max_clk_data.dcfclk_mhz || !max_clk_data.dispclk_mhz || !max_clk_data.dtbclk_mhz)\n\t\treturn -1;\n\n\tif (max_clk_data.dppclk_mhz == 0)\n\t\tmax_clk_data.dppclk_mhz = max_clk_data.dispclk_mhz;\n\n\tif (max_clk_data.fclk_mhz == 0)\n\t\tmax_clk_data.fclk_mhz = max_clk_data.dcfclk_mhz *\n\t\t\t\tdcn3_2_soc.pct_ideal_sdp_bw_after_urgent /\n\t\t\t\tdcn3_2_soc.pct_ideal_fabric_bw_after_urgent;\n\n\tif (max_clk_data.phyclk_mhz == 0)\n\t\tmax_clk_data.phyclk_mhz = dcn3_2_soc.clock_limits[0].phyclk_mhz;\n\n\t*num_entries = 0;\n\tentry.dispclk_mhz = max_clk_data.dispclk_mhz;\n\tentry.dscclk_mhz = max_clk_data.dispclk_mhz / 3;\n\tentry.dppclk_mhz = max_clk_data.dppclk_mhz;\n\tentry.dtbclk_mhz = max_clk_data.dtbclk_mhz;\n\tentry.phyclk_mhz = max_clk_data.phyclk_mhz;\n\tentry.phyclk_d18_mhz = dcn3_2_soc.clock_limits[0].phyclk_d18_mhz;\n\tentry.phyclk_d32_mhz = dcn3_2_soc.clock_limits[0].phyclk_d32_mhz;\n\n\t\n\tfor (i = 0; i < num_dcfclk_stas; i++) {\n\t\tentry.dcfclk_mhz = dcfclk_sta_targets[i];\n\t\tentry.fabricclk_mhz = 0;\n\t\tentry.dram_speed_mts = 0;\n\n\t\tget_optimal_ntuple(&entry);\n\t\tentry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&entry);\n\t\tinsert_entry_into_table_sorted(table, num_entries, &entry);\n\t}\n\n\t\n\tentry.dcfclk_mhz = max_clk_data.dcfclk_mhz;\n\tentry.fabricclk_mhz = 0;\n\tentry.dram_speed_mts = 0;\n\n\tget_optimal_ntuple(&entry);\n\tentry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&entry);\n\tinsert_entry_into_table_sorted(table, num_entries, &entry);\n\n\t\n\tfor (i = 0; i < num_uclk_dpms; i++) {\n\t\tentry.dcfclk_mhz = 0;\n\t\tentry.fabricclk_mhz = 0;\n\t\tentry.dram_speed_mts = bw_params->clk_table.entries[i].memclk_mhz * 16;\n\n\t\tget_optimal_ntuple(&entry);\n\t\tentry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&entry);\n\t\tinsert_entry_into_table_sorted(table, num_entries, &entry);\n\t}\n\n\t\n\tif (num_fclk_dpms > 2) {\n\t\tfor (i = 0; i < num_fclk_dpms; i++) {\n\t\t\tentry.dcfclk_mhz = 0;\n\t\t\tentry.fabricclk_mhz = bw_params->clk_table.entries[i].fclk_mhz;\n\t\t\tentry.dram_speed_mts = 0;\n\n\t\t\tget_optimal_ntuple(&entry);\n\t\t\tentry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&entry);\n\t\t\tinsert_entry_into_table_sorted(table, num_entries, &entry);\n\t\t}\n\t}\n\t\n\telse {\n\t\tentry.dcfclk_mhz = 0;\n\t\tentry.fabricclk_mhz = max_clk_data.fclk_mhz;\n\t\tentry.dram_speed_mts = 0;\n\n\t\tget_optimal_ntuple(&entry);\n\t\tentry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&entry);\n\t\tinsert_entry_into_table_sorted(table, num_entries, &entry);\n\t}\n\n\t\n\t\n\t\n\n\t\n\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\tif (table[i].dcfclk_mhz > max_clk_data.dcfclk_mhz ||\n\t\t\t\ttable[i].fabricclk_mhz > max_clk_data.fclk_mhz ||\n\t\t\t\ttable[i].dram_speed_mts > max_clk_data.memclk_mhz * 16)\n\t\t\tremove_entry_from_table_at_index(table, num_entries, i);\n\t}\n\n\t\n\tif (!disable_dc_mode_overwrite) {\n\t\tstruct _vcs_dpi_voltage_scaling_st max_dc_limits_entry = entry;\n\n\t\tmax_dc_limits_entry.dcfclk_mhz = max_clk_data.dcfclk_mhz;\n\t\tmax_dc_limits_entry.fabricclk_mhz = max_clk_data.fclk_mhz;\n\t\tmax_dc_limits_entry.dram_speed_mts = max_clk_data.memclk_mhz * 16;\n\n\t\tmax_dc_limits_entry.net_bw_in_kbytes_sec = calculate_net_bw_in_kbytes_sec(&max_dc_limits_entry);\n\t\tinsert_entry_into_table_sorted(table, num_entries, &max_dc_limits_entry);\n\n\t\tsort_entries_with_same_bw(table, num_entries);\n\t\tremove_inconsistent_entries(table, num_entries);\n\t}\n\n\t\n\t\n\t\n\t\n\n\t\n\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\tfor (j = 0; j < num_uclk_dpms; j++) {\n\t\t\tif (bw_params->clk_table.entries[j].memclk_mhz * 16 >= table[i].dram_speed_mts) {\n\t\t\t\ttable[i].dram_speed_mts = bw_params->clk_table.entries[j].memclk_mhz * 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (num_fclk_dpms > 2) {\n\t\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\t\tfor (j = 0; j < num_fclk_dpms; j++) {\n\t\t\t\tif (bw_params->clk_table.entries[j].fclk_mhz >= table[i].fabricclk_mhz) {\n\t\t\t\t\ttable[i].fabricclk_mhz = bw_params->clk_table.entries[j].fclk_mhz;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse {\n\t\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\t\tif (table[i].fabricclk_mhz < min_fclk_mhz) {\n\t\t\t\ttable[i].fabricclk_mhz = min_fclk_mhz;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\tif (table[i].dcfclk_mhz < min_dcfclk_mhz) {\n\t\t\ttable[i].dcfclk_mhz = min_dcfclk_mhz;\n\t\t}\n\t}\n\n\t\n\ti = 0;\n\twhile (i < *num_entries - 1) {\n\t\tif (table[i].dcfclk_mhz == table[i + 1].dcfclk_mhz &&\n\t\t\t\ttable[i].fabricclk_mhz == table[i + 1].fabricclk_mhz &&\n\t\t\t\ttable[i].dram_speed_mts == table[i + 1].dram_speed_mts)\n\t\t\tremove_entry_from_table_at_index(table, num_entries, i + 1);\n\t\telse\n\t\t\ti++;\n\t}\n\n\t\n\tfor (i = *num_entries - 1; i >= 0 ; i--) {\n\t\ttable[i].state = i;\n\t}\n\n\treturn 0;\n}\n\n \nvoid dcn32_update_bw_bounding_box_fpu(struct dc *dc, struct clk_bw_params *bw_params)\n{\n\tdc_assert_fp_enabled();\n\n\t \n\tdcn3_2_ip.clamp_min_dcfclk = dc->config.clamp_min_dcfclk;\n\n\t \n\tif ((int)(dcn3_2_soc.sr_exit_time_us * 1000) != dc->bb_overrides.sr_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_exit_time_ns) {\n\t\tdcn3_2_soc.sr_exit_time_us = dc->bb_overrides.sr_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(dcn3_2_soc.sr_enter_plus_exit_time_us * 1000)\n\t\t\t!= dc->bb_overrides.sr_enter_plus_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_enter_plus_exit_time_ns) {\n\t\tdcn3_2_soc.sr_enter_plus_exit_time_us =\n\t\t\tdc->bb_overrides.sr_enter_plus_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(dcn3_2_soc.urgent_latency_us * 1000) != dc->bb_overrides.urgent_latency_ns\n\t\t&& dc->bb_overrides.urgent_latency_ns) {\n\t\tdcn3_2_soc.urgent_latency_us = dc->bb_overrides.urgent_latency_ns / 1000.0;\n\t\tdcn3_2_soc.urgent_latency_pixel_data_only_us = dc->bb_overrides.urgent_latency_ns / 1000.0;\n\t}\n\n\tif ((int)(dcn3_2_soc.dram_clock_change_latency_us * 1000)\n\t\t\t!= dc->bb_overrides.dram_clock_change_latency_ns\n\t\t\t&& dc->bb_overrides.dram_clock_change_latency_ns) {\n\t\tdcn3_2_soc.dram_clock_change_latency_us =\n\t\t\tdc->bb_overrides.dram_clock_change_latency_ns / 1000.0;\n\t}\n\n\tif ((int)(dcn3_2_soc.fclk_change_latency_us * 1000)\n\t\t\t!= dc->bb_overrides.fclk_clock_change_latency_ns\n\t\t\t&& dc->bb_overrides.fclk_clock_change_latency_ns) {\n\t\tdcn3_2_soc.fclk_change_latency_us =\n\t\t\tdc->bb_overrides.fclk_clock_change_latency_ns / 1000;\n\t}\n\n\tif ((int)(dcn3_2_soc.dummy_pstate_latency_us * 1000)\n\t\t\t!= dc->bb_overrides.dummy_clock_change_latency_ns\n\t\t\t&& dc->bb_overrides.dummy_clock_change_latency_ns) {\n\t\tdcn3_2_soc.dummy_pstate_latency_us =\n\t\t\tdc->bb_overrides.dummy_clock_change_latency_ns / 1000.0;\n\t}\n\n\t \n\tif (dc->ctx->dc_bios->funcs->get_soc_bb_info) {\n\t\tstruct bp_soc_bb_info bb_info = {0};\n\n\t\tif (dc->ctx->dc_bios->funcs->get_soc_bb_info(dc->ctx->dc_bios, &bb_info) == BP_RESULT_OK) {\n\t\t\tif (bb_info.dram_clock_change_latency_100ns > 0)\n\t\t\t\tdcn3_2_soc.dram_clock_change_latency_us =\n\t\t\t\t\tbb_info.dram_clock_change_latency_100ns * 10;\n\n\t\t\tif (bb_info.dram_sr_enter_exit_latency_100ns > 0)\n\t\t\t\tdcn3_2_soc.sr_enter_plus_exit_time_us =\n\t\t\t\t\tbb_info.dram_sr_enter_exit_latency_100ns * 10;\n\n\t\t\tif (bb_info.dram_sr_exit_latency_100ns > 0)\n\t\t\t\tdcn3_2_soc.sr_exit_time_us =\n\t\t\t\t\tbb_info.dram_sr_exit_latency_100ns * 10;\n\t\t}\n\t}\n\n\t \n\tif (dc->ctx->dc_bios->vram_info.num_chans) {\n\t\tdcn3_2_soc.num_chans = dc->ctx->dc_bios->vram_info.num_chans;\n\t\tdcn3_2_soc.mall_allocated_for_dcn_mbytes = (double)(dcn32_calc_num_avail_chans_for_mall(dc,\n\t\t\tdc->ctx->dc_bios->vram_info.num_chans) * dc->caps.mall_size_per_mem_channel);\n\t}\n\n\tif (dc->ctx->dc_bios->vram_info.dram_channel_width_bytes)\n\t\tdcn3_2_soc.dram_channel_width_bytes = dc->ctx->dc_bios->vram_info.dram_channel_width_bytes;\n\n\t \n\tdcn3_2_ip.dsc_delay_factor_wa = dc->debug.dsc_delay_factor_wa_x1000 / 1000.0;\n\n\tdcn3_2_ip.min_prefetch_in_strobe_us = dc->debug.min_prefetch_in_strobe_ns / 1000.0;\n\n\t \n\tdcn3_2_soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\tdc->dml.soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\n\t \n\tif (bw_params->clk_table.entries[0].memclk_mhz) {\n\t\tif (dc->debug.use_legacy_soc_bb_mechanism) {\n\t\t\tunsigned int i = 0, j = 0, num_states = 0;\n\n\t\t\tunsigned int dcfclk_mhz[DC__VOLTAGE_STATES] = {0};\n\t\t\tunsigned int dram_speed_mts[DC__VOLTAGE_STATES] = {0};\n\t\t\tunsigned int optimal_uclk_for_dcfclk_sta_targets[DC__VOLTAGE_STATES] = {0};\n\t\t\tunsigned int optimal_dcfclk_for_uclk[DC__VOLTAGE_STATES] = {0};\n\t\t\tunsigned int min_dcfclk = UINT_MAX;\n\t\t\t \n\t\t\tunsigned int dcfclk_sta_targets[DC__VOLTAGE_STATES] = {199, 615, 906, 1324, 1564};\n\t\t\tunsigned int num_dcfclk_sta_targets = 4, num_uclk_states = 0;\n\t\t\tunsigned int max_dcfclk_mhz = 0, max_dispclk_mhz = 0, max_dppclk_mhz = 0, max_phyclk_mhz = 0;\n\n\t\t\tfor (i = 0; i < MAX_NUM_DPM_LVL; i++) {\n\t\t\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz > max_dcfclk_mhz)\n\t\t\t\t\tmax_dcfclk_mhz = bw_params->clk_table.entries[i].dcfclk_mhz;\n\t\t\t\tif (bw_params->clk_table.entries[i].dcfclk_mhz != 0 &&\n\t\t\t\t\t\tbw_params->clk_table.entries[i].dcfclk_mhz < min_dcfclk)\n\t\t\t\t\tmin_dcfclk = bw_params->clk_table.entries[i].dcfclk_mhz;\n\t\t\t\tif (bw_params->clk_table.entries[i].dispclk_mhz > max_dispclk_mhz)\n\t\t\t\t\tmax_dispclk_mhz = bw_params->clk_table.entries[i].dispclk_mhz;\n\t\t\t\tif (bw_params->clk_table.entries[i].dppclk_mhz > max_dppclk_mhz)\n\t\t\t\t\tmax_dppclk_mhz = bw_params->clk_table.entries[i].dppclk_mhz;\n\t\t\t\tif (bw_params->clk_table.entries[i].phyclk_mhz > max_phyclk_mhz)\n\t\t\t\t\tmax_phyclk_mhz = bw_params->clk_table.entries[i].phyclk_mhz;\n\t\t\t}\n\t\t\tif (min_dcfclk > dcfclk_sta_targets[0])\n\t\t\t\tdcfclk_sta_targets[0] = min_dcfclk;\n\t\t\tif (!max_dcfclk_mhz)\n\t\t\t\tmax_dcfclk_mhz = dcn3_2_soc.clock_limits[0].dcfclk_mhz;\n\t\t\tif (!max_dispclk_mhz)\n\t\t\t\tmax_dispclk_mhz = dcn3_2_soc.clock_limits[0].dispclk_mhz;\n\t\t\tif (!max_dppclk_mhz)\n\t\t\t\tmax_dppclk_mhz = dcn3_2_soc.clock_limits[0].dppclk_mhz;\n\t\t\tif (!max_phyclk_mhz)\n\t\t\t\tmax_phyclk_mhz = dcn3_2_soc.clock_limits[0].phyclk_mhz;\n\n\t\t\tif (max_dcfclk_mhz > dcfclk_sta_targets[num_dcfclk_sta_targets-1]) {\n\t\t\t\t\n\t\t\t\tdcfclk_sta_targets[num_dcfclk_sta_targets] = max_dcfclk_mhz;\n\t\t\t\tnum_dcfclk_sta_targets++;\n\t\t\t} else if (max_dcfclk_mhz < dcfclk_sta_targets[num_dcfclk_sta_targets-1]) {\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < num_dcfclk_sta_targets; i++) {\n\t\t\t\t\tif (dcfclk_sta_targets[i] > max_dcfclk_mhz) {\n\t\t\t\t\t\tdcfclk_sta_targets[i] = max_dcfclk_mhz;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnum_dcfclk_sta_targets = i + 1;\n\t\t\t}\n\n\t\t\tnum_uclk_states = bw_params->clk_table.num_entries;\n\n\t\t\t\n\t\t\tfor (i = 0; i < num_uclk_states; i++) {\n\t\t\t\tdcn32_get_optimal_dcfclk_fclk_for_uclk(bw_params->clk_table.entries[i].memclk_mhz * 16,\n\t\t\t\t\t\t&optimal_dcfclk_for_uclk[i], NULL);\n\t\t\t\tif (optimal_dcfclk_for_uclk[i] < bw_params->clk_table.entries[0].dcfclk_mhz) {\n\t\t\t\t\toptimal_dcfclk_for_uclk[i] = bw_params->clk_table.entries[0].dcfclk_mhz;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tfor (i = 0; i < num_dcfclk_sta_targets; i++) {\n\t\t\t\tfor (j = 0; j < num_uclk_states; j++) {\n\t\t\t\t\tif (dcfclk_sta_targets[i] < optimal_dcfclk_for_uclk[j]) {\n\t\t\t\t\t\toptimal_uclk_for_dcfclk_sta_targets[i] =\n\t\t\t\t\t\t\t\tbw_params->clk_table.entries[j].memclk_mhz * 16;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\t\n\t\t\twhile (i < num_dcfclk_sta_targets && j < num_uclk_states && num_states < DC__VOLTAGE_STATES) {\n\t\t\t\tif (dcfclk_sta_targets[i] < optimal_dcfclk_for_uclk[j] && i < num_dcfclk_sta_targets) {\n\t\t\t\t\tdcfclk_mhz[num_states] = dcfclk_sta_targets[i];\n\t\t\t\t\tdram_speed_mts[num_states++] = optimal_uclk_for_dcfclk_sta_targets[i++];\n\t\t\t\t} else {\n\t\t\t\t\tif (j < num_uclk_states && optimal_dcfclk_for_uclk[j] <= max_dcfclk_mhz) {\n\t\t\t\t\t\tdcfclk_mhz[num_states] = optimal_dcfclk_for_uclk[j];\n\t\t\t\t\t\tdram_speed_mts[num_states++] = bw_params->clk_table.entries[j++].memclk_mhz * 16;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj = num_uclk_states;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (i < num_dcfclk_sta_targets && num_states < DC__VOLTAGE_STATES) {\n\t\t\t\tdcfclk_mhz[num_states] = dcfclk_sta_targets[i];\n\t\t\t\tdram_speed_mts[num_states++] = optimal_uclk_for_dcfclk_sta_targets[i++];\n\t\t\t}\n\n\t\t\twhile (j < num_uclk_states && num_states < DC__VOLTAGE_STATES &&\n\t\t\t\t\toptimal_dcfclk_for_uclk[j] <= max_dcfclk_mhz) {\n\t\t\t\tdcfclk_mhz[num_states] = optimal_dcfclk_for_uclk[j];\n\t\t\t\tdram_speed_mts[num_states++] = bw_params->clk_table.entries[j++].memclk_mhz * 16;\n\t\t\t}\n\n\t\t\tdcn3_2_soc.num_states = num_states;\n\t\t\tfor (i = 0; i < dcn3_2_soc.num_states; i++) {\n\t\t\t\tdcn3_2_soc.clock_limits[i].state = i;\n\t\t\t\tdcn3_2_soc.clock_limits[i].dcfclk_mhz = dcfclk_mhz[i];\n\t\t\t\tdcn3_2_soc.clock_limits[i].fabricclk_mhz = dcfclk_mhz[i];\n\n\t\t\t\t \n\t\t\t\tdcn3_2_soc.clock_limits[i].dispclk_mhz = max_dispclk_mhz;\n\t\t\t\tdcn3_2_soc.clock_limits[i].dppclk_mhz  = max_dppclk_mhz;\n\t\t\t\tdcn3_2_soc.clock_limits[i].phyclk_mhz  = max_phyclk_mhz;\n\t\t\t\tdcn3_2_soc.clock_limits[i].dscclk_mhz  = max_dispclk_mhz / 3;\n\n\t\t\t\t \n\t\t\t\tif (i > 0) {\n\t\t\t\t\tif (!bw_params->clk_table.entries[i].dtbclk_mhz) {\n\t\t\t\t\t\tdcn3_2_soc.clock_limits[i].dtbclk_mhz  = dcn3_2_soc.clock_limits[i-1].dtbclk_mhz;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdcn3_2_soc.clock_limits[i].dtbclk_mhz  = bw_params->clk_table.entries[i].dtbclk_mhz;\n\t\t\t\t\t}\n\t\t\t\t} else if (bw_params->clk_table.entries[i].dtbclk_mhz) {\n\t\t\t\t\tdcn3_2_soc.clock_limits[i].dtbclk_mhz  = bw_params->clk_table.entries[i].dtbclk_mhz;\n\t\t\t\t}\n\n\t\t\t\tif (!bw_params->clk_table.entries[i].socclk_mhz && i > 0)\n\t\t\t\t\tdcn3_2_soc.clock_limits[i].socclk_mhz = dcn3_2_soc.clock_limits[i-1].socclk_mhz;\n\t\t\t\telse\n\t\t\t\t\tdcn3_2_soc.clock_limits[i].socclk_mhz = bw_params->clk_table.entries[i].socclk_mhz;\n\n\t\t\t\tif (!dram_speed_mts[i] && i > 0)\n\t\t\t\t\tdcn3_2_soc.clock_limits[i].dram_speed_mts = dcn3_2_soc.clock_limits[i-1].dram_speed_mts;\n\t\t\t\telse\n\t\t\t\t\tdcn3_2_soc.clock_limits[i].dram_speed_mts = dram_speed_mts[i];\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tdcn3_2_soc.clock_limits[i].phyclk_d18_mhz = dcn3_2_soc.clock_limits[0].phyclk_d18_mhz;\n\t\t\t\tdcn3_2_soc.clock_limits[i].phyclk_d32_mhz = dcn3_2_soc.clock_limits[0].phyclk_d32_mhz;\n\t\t\t}\n\t\t} else {\n\t\t\tbuild_synthetic_soc_states(dc->debug.disable_dc_mode_overwrite, bw_params,\n\t\t\t\t\tdcn3_2_soc.clock_limits, &dcn3_2_soc.num_states);\n\t\t}\n\n\t\t \n\t\tdml_init_instance(&dc->dml, &dcn3_2_soc, &dcn3_2_ip, DML_PROJECT_DCN32);\n\t\tif (dc->current_state)\n\t\t\tdml_init_instance(&dc->current_state->bw_ctx.dml, &dcn3_2_soc, &dcn3_2_ip, DML_PROJECT_DCN32);\n\t}\n}\n\nvoid dcn32_zero_pipe_dcc_fraction(display_e2e_pipe_params_st *pipes,\n\t\t\t\t  int pipe_cnt)\n{\n\tdc_assert_fp_enabled();\n\n\tpipes[pipe_cnt].pipe.src.dcc_fraction_of_zs_req_luma = 0;\n\tpipes[pipe_cnt].pipe.src.dcc_fraction_of_zs_req_chroma = 0;\n}\n\nbool dcn32_allow_subvp_with_active_margin(struct pipe_ctx *pipe)\n{\n\tbool allow = false;\n\tuint32_t refresh_rate = 0;\n\n\t \n\tif (pipe->stream && pipe->plane_state) {\n\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * 100 +\n\t\t\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - 1)\n\t\t\t\t\t\t/ (double)(pipe->stream->timing.v_total * pipe->stream->timing.h_total);\n\t\tif (pipe->stream->timing.v_addressable == 1440 &&\n\t\t\t\tpipe->stream->timing.h_addressable == 2560 &&\n\t\t\t\trefresh_rate >= 55 && refresh_rate <= 65 &&\n\t\t\t\tpipe->plane_state->src_rect.height == 1440 &&\n\t\t\t\tpipe->plane_state->src_rect.width == 2560 &&\n\t\t\t\tpipe->plane_state->dst_rect.height == 1440 &&\n\t\t\t\tpipe->plane_state->dst_rect.width == 2560)\n\t\t\tallow = true;\n\t}\n\treturn allow;\n}\n\n \nbool dcn32_allow_subvp_high_refresh_rate(struct dc *dc, struct dc_state *context, struct pipe_ctx *pipe)\n{\n\tbool allow = false;\n\tuint32_t refresh_rate = 0;\n\tuint32_t subvp_min_refresh = subvp_high_refresh_list.min_refresh;\n\tuint32_t subvp_max_refresh = subvp_high_refresh_list.max_refresh;\n\tuint32_t min_refresh = subvp_max_refresh;\n\tuint32_t i;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx->stream)\n\t\t\tcontinue;\n\t\trefresh_rate = (pipe_ctx->stream->timing.pix_clk_100hz * 100 +\n\t\t\t\tpipe_ctx->stream->timing.v_total * pipe_ctx->stream->timing.h_total - 1)\n\t\t\t\t\t\t/ (double)(pipe_ctx->stream->timing.v_total * pipe_ctx->stream->timing.h_total);\n\n\t\tif (refresh_rate < min_refresh)\n\t\t\tmin_refresh = refresh_rate;\n\t}\n\n\tif (!dc->debug.disable_subvp_high_refresh && min_refresh >= subvp_min_refresh && pipe->stream &&\n\t\t\tpipe->plane_state && !(pipe->stream->vrr_active_variable || pipe->stream->vrr_active_fixed)) {\n\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * 100 +\n\t\t\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - 1)\n\t\t\t\t\t\t/ (double)(pipe->stream->timing.v_total * pipe->stream->timing.h_total);\n\t\tif (refresh_rate >= subvp_min_refresh && refresh_rate <= subvp_max_refresh) {\n\t\t\tfor (i = 0; i < SUBVP_HIGH_REFRESH_LIST_LEN; i++) {\n\t\t\t\tuint32_t width = subvp_high_refresh_list.res[i].width;\n\t\t\t\tuint32_t height = subvp_high_refresh_list.res[i].height;\n\n\t\t\t\tif (dcn32_check_native_scaling_for_res(pipe, width, height)) {\n\t\t\t\t\tif ((context->stream_count == 1 && !pipe->stream->allow_freesync) || context->stream_count > 1) {\n\t\t\t\t\t\tallow = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn allow;\n}\n\n \ndouble dcn32_determine_max_vratio_prefetch(struct dc *dc, struct dc_state *context)\n{\n\tdouble max_vratio_pre = __DML_MAX_BW_RATIO_PRE__; \n\tint i;\n\n\t \n\tif (context->stream_count == 1 && context->stream_status[0].plane_count > 1) {\n\t\tfor (i = 0; i < context->stream_status[0].plane_count; i++) {\n\t\t\tif (context->stream_status[0].plane_states[i]->format == SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr ||\n\t\t\t\t\tcontext->stream_status[0].plane_states[i]->format == SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb) {\n\t\t\t\tmax_vratio_pre = __DML_MAX_VRATIO_PRE__;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_vratio_pre;\n}\n\n \nvoid dcn32_assign_fpo_vactive_candidate(struct dc *dc, const struct dc_state *context, struct dc_stream_state **fpo_candidate_stream)\n{\n\tunsigned int i, pipe_idx;\n\tconst struct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tconst struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (vba->ActiveDRAMClockChangeLatencyMarginPerState[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] <= 0) {\n\t\t\t*fpo_candidate_stream = pipe->stream;\n\t\t\tbreak;\n\t\t}\n\t\tpipe_idx++;\n\t}\n}\n\n \nbool dcn32_find_vactive_pipe(struct dc *dc, const struct dc_state *context, uint32_t vactive_margin_req_us)\n{\n\tunsigned int i, pipe_idx;\n\tconst struct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tbool vactive_found = false;\n\tunsigned int blank_us = 0;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tconst struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tblank_us = ((pipe->stream->timing.v_total - pipe->stream->timing.v_addressable) * pipe->stream->timing.h_total /\n\t\t\t\t(double)(pipe->stream->timing.pix_clk_100hz * 100)) * 1000000;\n\t\tif (vba->ActiveDRAMClockChangeLatencyMarginPerState[vba->VoltageLevel][vba->maxMpcComb][vba->pipe_plane[pipe_idx]] >= vactive_margin_req_us &&\n\t\t\t\t!(pipe->stream->vrr_active_variable || pipe->stream->vrr_active_fixed) && blank_us < dc->debug.fpo_vactive_max_blank_us) {\n\t\t\tvactive_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tpipe_idx++;\n\t}\n\treturn vactive_found;\n}\n\nvoid dcn32_set_clock_limits(const struct _vcs_dpi_soc_bounding_box_st *soc_bb)\n{\n\tdc_assert_fp_enabled();\n\tdcn3_2_soc.clock_limits[0].dcfclk_mhz = 1200.0;\n}\n\nvoid dcn32_override_min_req_memclk(struct dc *dc, struct dc_state *context)\n{\n\t\n\tif ((context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching || dcn32_subvp_in_use(dc, context)) &&\n\t\t\tdc->dml.soc.num_chans <= 8) {\n\t\tint num_mclk_levels = dc->clk_mgr->bw_params->clk_table.num_entries_per_clk.num_memclk_levels;\n\n\t\tif (context->bw_ctx.dml.vba.DRAMSpeed <= dc->clk_mgr->bw_params->clk_table.entries[0].memclk_mhz * 16 &&\n\t\t\t\tnum_mclk_levels > 1) {\n\t\t\tcontext->bw_ctx.dml.vba.DRAMSpeed = dc->clk_mgr->bw_params->clk_table.entries[1].memclk_mhz * 16;\n\t\t\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz = context->bw_ctx.dml.vba.DRAMSpeed * 1000 / 16;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}