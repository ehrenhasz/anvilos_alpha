{
  "module_name": "dcn20_dwb.c",
  "hash_id": "29edaa446764e30c0c511071e52cd20af2b595eb748d1105a7b5f959b17d85b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dwb.c",
  "human_readable_source": " \n\n\n#include \"reg_helper.h\"\n#include \"resource.h\"\n#include \"dwb.h\"\n#include \"dcn20_dwb.h\"\n\n\n#define REG(reg)\\\n\tdwbc20->dwbc_regs->reg\n\n#define CTX \\\n\tdwbc20->base.ctx\n\n#define DC_LOGGER \\\n\tdwbc20->base.ctx->logger\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdwbc20->dwbc_shift->field_name, dwbc20->dwbc_mask->field_name\n\nenum dwb_outside_pix_strategy {\n\tDWB_OUTSIDE_PIX_STRATEGY_BLACK = 0,\n\tDWB_OUTSIDE_PIX_STRATEGY_EDGE  = 1\n};\n\nstatic bool dwb2_get_caps(struct dwbc *dwbc, struct dwb_caps *caps)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tif (caps) {\n\t\tcaps->adapter_id = 0;\t \n\t\tcaps->hw_version = DCN_VERSION_2_0;\n\t\tcaps->num_pipes = 1;\n\t\tmemset(&caps->reserved, 0, sizeof(caps->reserved));\n\t\tmemset(&caps->reserved2, 0, sizeof(caps->reserved2));\n\t\tcaps->sw_version = dwb_ver_1_0;\n\t\tcaps->caps.support_dwb = true;\n\t\tcaps->caps.support_ogam = false;\n\t\tcaps->caps.support_wbscl = false;\n\t\tcaps->caps.support_ocsc = false;\n\t\tDC_LOG_DWB(\"%s SUPPORTED! inst = %d\", __func__, dwbc20->base.inst);\n\t\treturn true;\n\t} else {\n\t\tDC_LOG_DWB(\"%s NOT SUPPORTED! inst = %d\", __func__, dwbc20->base.inst);\n\t\treturn false;\n\t}\n}\n\nvoid dwb2_config_dwb_cnv(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d\", __func__, dwbc20->base.inst);\n\n\t \n\tREG_UPDATE_2(CNV_SOURCE_SIZE, CNV_SOURCE_WIDTH, params->cnv_params.src_width,\n\t\t\tCNV_SOURCE_HEIGHT, params->cnv_params.src_height);\n\n\t \n\tif (params->cnv_params.crop_en) {\n\t\tREG_UPDATE(CNV_MODE, CNV_WINDOW_CROP_EN, 1);\n\t\tREG_UPDATE(CNV_WINDOW_START, CNV_WINDOW_START_X, params->cnv_params.crop_x);\n\t\tREG_UPDATE(CNV_WINDOW_START, CNV_WINDOW_START_Y, params->cnv_params.crop_y);\n\t\tREG_UPDATE(CNV_WINDOW_SIZE,  CNV_WINDOW_WIDTH,   params->cnv_params.crop_width);\n\t\tREG_UPDATE(CNV_WINDOW_SIZE,  CNV_WINDOW_HEIGHT,  params->cnv_params.crop_height);\n\t} else {\n\t\tREG_UPDATE(CNV_MODE, CNV_WINDOW_CROP_EN, 0);\n\t}\n\n\t \n\tREG_UPDATE(CNV_MODE, CNV_FRAME_CAPTURE_RATE, params->capture_rate);\n\n\t \n\tREG_UPDATE(CNV_MODE, CNV_OUT_BPC, params->cnv_params.cnv_out_bpc);\n}\n\nstatic bool dwb2_enable(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\n\t \n\tif ((params->cnv_params.src_width  != params->dest_width) ||\n\t    (params->cnv_params.src_height != params->dest_height)) {\n\n\t\tDC_LOG_DWB(\"%s inst = %d, FAILED!LUMA SCALING NOT SUPPORTED\", __func__, dwbc20->base.inst);\n\t\treturn false;\n\t}\n\tDC_LOG_DWB(\"%s inst = %d, ENABLED\", __func__, dwbc20->base.inst);\n\n\t \n\t\n\t\n\t\n\n\t \n\tREG_UPDATE(WB_ENABLE, WB_ENABLE, 1);\n\n\t \n\tdwb2_config_dwb_cnv(dwbc, params);\n\n\t \n\tdwb2_set_scaler(dwbc, params);\n\n\t \n\tREG_UPDATE(CNV_MODE, CNV_FRAME_CAPTURE_EN, DWB_FRAME_CAPTURE_ENABLE);\n\n\t\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL1, GMC_WARM_UP_ENABLE, 0);\n\n\treturn true;\n}\n\nbool dwb2_disable(struct dwbc *dwbc)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d, Disabled\", __func__, dwbc20->base.inst);\n\n\t \n\tREG_UPDATE(CNV_MODE, CNV_FRAME_CAPTURE_EN, DWB_FRAME_CAPTURE_DISABLE);\n\n\t \n\tREG_UPDATE(WB_ENABLE, WB_ENABLE, 0);\n\n\t \n\tREG_UPDATE(WB_SOFT_RESET, WB_SOFT_RESET, 1);\n\tREG_UPDATE(WB_SOFT_RESET, WB_SOFT_RESET, 0);\n\n\t \n\t\n\t\n\t\n\n\treturn true;\n}\n\nstatic bool dwb2_update(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tunsigned int pre_locked;\n\n\t \n\tif ((params->cnv_params.src_width != params->dest_width) ||\n\t\t\t(params->cnv_params.src_height != params->dest_height)) {\n\t\tDC_LOG_DWB(\"%s inst = %d, FAILED!LUMA SCALING NOT SUPPORTED\", __func__, dwbc20->base.inst);\n\t\treturn false;\n\t}\n\tDC_LOG_DWB(\"%s inst = %d, scaling\", __func__, dwbc20->base.inst);\n\n\t \n\tREG_GET(CNV_UPDATE, CNV_UPDATE_LOCK, &pre_locked);\n\n\tif (pre_locked == 0) {\n\t\t \n\t\tREG_UPDATE(CNV_UPDATE, CNV_UPDATE_LOCK, 1);\n\t}\n\n\t \n\tdwb2_config_dwb_cnv(dwbc, params);\n\n\t \n\tdwb2_set_scaler(dwbc, params);\n\n\tif (pre_locked == 0) {\n\t\t \n\t\tREG_UPDATE(CNV_UPDATE, CNV_UPDATE_LOCK, 0);\n\t}\n\n\treturn true;\n}\n\nbool dwb2_is_enabled(struct dwbc *dwbc)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tunsigned int wb_enabled = 0;\n\tunsigned int cnv_frame_capture_en = 0;\n\n\tREG_GET(WB_ENABLE, WB_ENABLE, &wb_enabled);\n\tREG_GET(CNV_MODE, CNV_FRAME_CAPTURE_EN, &cnv_frame_capture_en);\n\n\treturn ((wb_enabled != 0) && (cnv_frame_capture_en != 0));\n}\n\nvoid dwb2_set_stereo(struct dwbc *dwbc,\n\t\tstruct dwb_stereo_params *stereo_params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d, enabled =%d\", __func__,\\\n\t\tdwbc20->base.inst, stereo_params->stereo_enabled);\n\n\tif (stereo_params->stereo_enabled) {\n\t\tREG_UPDATE(CNV_MODE, CNV_STEREO_TYPE,     stereo_params->stereo_type);\n\t\tREG_UPDATE(CNV_MODE, CNV_EYE_SELECTION,   stereo_params->stereo_eye_select);\n\t\tREG_UPDATE(CNV_MODE, CNV_STEREO_POLARITY, stereo_params->stereo_polarity);\n\t} else {\n\t\tREG_UPDATE(CNV_MODE, CNV_EYE_SELECTION, 0);\n\t}\n}\n\nvoid dwb2_set_new_content(struct dwbc *dwbc,\n\t\t\t\t\t\tbool is_new_content)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d\", __func__, dwbc20->base.inst);\n\n\tREG_UPDATE(CNV_MODE, CNV_NEW_CONTENT, is_new_content);\n}\n\nstatic void dwb2_set_warmup(struct dwbc *dwbc,\n\t\tstruct dwb_warmup_params *warmup_params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d\", __func__, dwbc20->base.inst);\n\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL1, GMC_WARM_UP_ENABLE, warmup_params->warmup_en);\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL1, WIDTH_WARMUP, warmup_params->warmup_width);\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL1, HEIGHT_WARMUP, warmup_params->warmup_height);\n\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL2, DATA_VALUE_WARMUP, warmup_params->warmup_data);\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL2, MODE_WARMUP, warmup_params->warmup_mode);\n\tREG_UPDATE(WB_WARM_UP_MODE_CTL2, DATA_DEPTH_WARMUP, warmup_params->warmup_depth);\n}\n\nvoid dwb2_set_scaler(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn20_dwbc *dwbc20 = TO_DCN20_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s inst = %d\", __func__, dwbc20->base.inst);\n\n\t \n\tREG_UPDATE_2(WBSCL_MODE, WBSCL_MODE, params->out_format,\n\t\t\tWBSCL_OUT_BIT_DEPTH, params->output_depth);\n\n\tif (params->out_format != dwb_scaler_mode_bypass444) {\n\t\t \n\t\tREG_UPDATE(WBSCL_DEST_SIZE, WBSCL_DEST_WIDTH,\tparams->dest_width);\n\t\tREG_UPDATE(WBSCL_DEST_SIZE, WBSCL_DEST_HEIGHT,\tparams->dest_height);\n\n\t\t \n\t\tREG_UPDATE(WBSCL_ROUND_OFFSET, WBSCL_ROUND_OFFSET_Y_RGB, 0x40);\n\t\tREG_UPDATE(WBSCL_ROUND_OFFSET, WBSCL_ROUND_OFFSET_CBCR,  0x200);\n\n\t\t \n\t\tREG_UPDATE(WBSCL_CLAMP_Y_RGB,\tWBSCL_CLAMP_UPPER_Y_RGB,\t0x3fe);\n\t\tREG_UPDATE(WBSCL_CLAMP_Y_RGB,\tWBSCL_CLAMP_LOWER_Y_RGB,\t0x1);\n\t\tREG_UPDATE(WBSCL_CLAMP_CBCR,\tWBSCL_CLAMP_UPPER_CBCR,\t\t0x3fe);\n\t\tREG_UPDATE(WBSCL_CLAMP_CBCR,\tWBSCL_CLAMP_LOWER_CBCR,\t\t0x1);\n\n\t\t \n\t\tREG_UPDATE(WBSCL_OUTSIDE_PIX_STRATEGY, WBSCL_OUTSIDE_PIX_STRATEGY, DWB_OUTSIDE_PIX_STRATEGY_EDGE);\n\n\t\tif (params->cnv_params.crop_en) {\n\t\t\t \n\t\t\tdwb_program_horz_scalar(dwbc20, params->cnv_params.crop_width,\n\t\t\t\t\t\t\tparams->dest_width,\n\t\t\t\t\t\t\tparams->scaler_taps);\n\n\t\t\t \n\t\t\tdwb_program_vert_scalar(dwbc20, params->cnv_params.crop_height,\n\t\t\t\t\t\t\tparams->dest_height,\n\t\t\t\t\t\t\tparams->scaler_taps,\n\t\t\t\t\t\t\tparams->subsample_position);\n\t\t} else {\n\t\t\t \n\t\t\tdwb_program_horz_scalar(dwbc20, params->cnv_params.src_width,\n\t\t\t\t\t\t\tparams->dest_width,\n\t\t\t\t\t\t\tparams->scaler_taps);\n\n\t\t\t \n\t\t\tdwb_program_vert_scalar(dwbc20, params->cnv_params.src_height,\n\t\t\t\t\t\t\tparams->dest_height,\n\t\t\t\t\t\t\tparams->scaler_taps,\n\t\t\t\t\t\t\tparams->subsample_position);\n\t\t}\n\t}\n\n}\n\nstatic const struct dwbc_funcs dcn20_dwbc_funcs = {\n\t.get_caps\t\t= dwb2_get_caps,\n\t.enable\t\t\t= dwb2_enable,\n\t.disable\t\t= dwb2_disable,\n\t.update\t\t\t= dwb2_update,\n\t.is_enabled\t\t= dwb2_is_enabled,\n\t.set_stereo\t\t= dwb2_set_stereo,\n\t.set_new_content\t= dwb2_set_new_content,\n\t.set_warmup\t\t= dwb2_set_warmup,\n\t.dwb_set_scaler\t\t= dwb2_set_scaler,\n};\n\nvoid dcn20_dwbc_construct(struct dcn20_dwbc *dwbc20,\n\t\tstruct dc_context *ctx,\n\t\tconst struct dcn20_dwbc_registers *dwbc_regs,\n\t\tconst struct dcn20_dwbc_shift *dwbc_shift,\n\t\tconst struct dcn20_dwbc_mask *dwbc_mask,\n\t\tint inst)\n{\n\tdwbc20->base.ctx = ctx;\n\n\tdwbc20->base.inst = inst;\n\tdwbc20->base.funcs = &dcn20_dwbc_funcs;\n\n\tdwbc20->dwbc_regs = dwbc_regs;\n\tdwbc20->dwbc_shift = dwbc_shift;\n\tdwbc20->dwbc_mask = dwbc_mask;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}