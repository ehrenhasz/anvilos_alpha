{
  "module_name": "link_dp_phy.c",
  "hash_id": "7f5c3ee018038a1d69e96d790a1db8c9b33f9d0ec5c34245a971752069e38729",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_phy.c",
  "human_readable_source": " \n\n \n\n#include \"link_dp_phy.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_training.h\"\n#include \"link_dp_capability.h\"\n#include \"clk_mgr.h\"\n#include \"resource.h\"\n#include \"link_enc_cfg.h\"\n#define DC_LOGGER \\\n\tlink->ctx->logger\n\nvoid dpcd_write_rx_power_ctrl(struct dc_link *link, bool on)\n{\n\tuint8_t state;\n\n\tstate = on ? DP_POWER_STATE_D0 : DP_POWER_STATE_D3;\n\n\tif (link->sync_lt_in_progress)\n\t\treturn;\n\n\tcore_link_write_dpcd(link, DP_SET_POWER, &state,\n\t\t\t\t\t\t sizeof(state));\n\n}\n\nvoid dp_enable_link_phy(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tenum signal_type signal,\n\tenum clock_source_id clock_source,\n\tconst struct dc_link_settings *link_settings)\n{\n\tlink->cur_link_settings = *link_settings;\n\tlink->dc->hwss.enable_dp_link_output(link, link_res, signal,\n\t\t\tclock_source, link_settings);\n\tdpcd_write_rx_power_ctrl(link, true);\n}\n\nvoid dp_disable_link_phy(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\n\tif (!link->wa_flags.dp_keep_receiver_powered &&\n\t\t!link->skip_implict_edp_power_control)\n\t\tdpcd_write_rx_power_ctrl(link, false);\n\n\tdc->hwss.disable_link_output(link, link_res, signal);\n\t \n\tmemset(&link->cur_link_settings, 0,\n\t\t\tsizeof(link->cur_link_settings));\n\n\tif (dc->clk_mgr->funcs->notify_link_rate_change)\n\t\tdc->clk_mgr->funcs->notify_link_rate_change(dc->clk_mgr, link);\n}\n\nstatic inline bool is_immediate_downstream(struct dc_link *link, uint32_t offset)\n{\n\treturn (dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt) ==\n\t\t\toffset);\n}\n\nvoid dp_set_hw_lane_settings(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tconst struct link_training_settings *link_settings,\n\tuint32_t offset)\n{\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\n\tif ((link_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT) &&\n\t\t\t!is_immediate_downstream(link, offset))\n\t\treturn;\n\n\tif (link_hwss->ext.set_dp_lane_settings)\n\t\tlink_hwss->ext.set_dp_lane_settings(link, link_res,\n\t\t\t\t&link_settings->link_settings,\n\t\t\t\tlink_settings->hw_lane_settings);\n\n\tmemmove(link->cur_lane_setting,\n\t\t\tlink_settings->hw_lane_settings,\n\t\t\tsizeof(link->cur_lane_setting));\n}\n\nvoid dp_set_drive_settings(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tstruct link_training_settings *lt_settings)\n{\n\t \n\tdp_set_hw_lane_settings(link, link_res, lt_settings, DPRX);\n\n\tdp_hw_to_dpcd_lane_settings(lt_settings,\n\t\t\tlt_settings->hw_lane_settings,\n\t\t\tlt_settings->dpcd_lane_settings);\n\n\t \n\tdpcd_set_lane_settings(link, lt_settings, DPRX);\n}\n\nenum dc_status dp_set_fec_ready(struct dc_link *link, const struct link_resource *link_res, bool ready)\n{\n\t \n\tstruct link_encoder *link_enc = NULL;\n\tenum dc_status status = DC_OK;\n\tuint8_t fec_config = 0;\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\tif (!dp_should_enable_fec(link))\n\t\treturn status;\n\n\tif (link_enc->funcs->fec_set_ready &&\n\t\t\tlink->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {\n\t\tif (ready) {\n\t\t\tfec_config = 1;\n\t\t\tstatus = core_link_write_dpcd(link,\n\t\t\t\t\tDP_FEC_CONFIGURATION,\n\t\t\t\t\t&fec_config,\n\t\t\t\t\tsizeof(fec_config));\n\t\t\tif (status == DC_OK) {\n\t\t\t\tlink_enc->funcs->fec_set_ready(link_enc, true);\n\t\t\t\tlink->fec_state = dc_link_fec_ready;\n\t\t\t} else {\n\t\t\t\tlink_enc->funcs->fec_set_ready(link_enc, false);\n\t\t\t\tlink->fec_state = dc_link_fec_not_ready;\n\t\t\t\tdm_error(\"dpcd write failed to set fec_ready\");\n\t\t\t}\n\t\t} else if (link->fec_state == dc_link_fec_ready) {\n\t\t\tfec_config = 0;\n\t\t\tstatus = core_link_write_dpcd(link,\n\t\t\t\t\tDP_FEC_CONFIGURATION,\n\t\t\t\t\t&fec_config,\n\t\t\t\t\tsizeof(fec_config));\n\t\t\tlink_enc->funcs->fec_set_ready(link_enc, false);\n\t\t\tlink->fec_state = dc_link_fec_not_ready;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nvoid dp_set_fec_enable(struct dc_link *link, bool enable)\n{\n\tstruct link_encoder *link_enc = NULL;\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\n\tif (!dp_should_enable_fec(link))\n\t\treturn;\n\n\tif (link_enc->funcs->fec_set_enable &&\n\t\t\tlink->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {\n\t\tif (link->fec_state == dc_link_fec_ready && enable) {\n\t\t\t \n\t\t\tudelay(7);\n\t\t\tlink_enc->funcs->fec_set_enable(link_enc, true);\n\t\t\tlink->fec_state = dc_link_fec_enabled;\n\t\t} else if (link->fec_state == dc_link_fec_enabled && !enable) {\n\t\t\tlink_enc->funcs->fec_set_enable(link_enc, false);\n\t\t\tlink->fec_state = dc_link_fec_ready;\n\t\t}\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}