{
  "module_name": "link_dp_training.c",
  "hash_id": "242af6015a1d523aa95f8645de31d81824c07c901bb37163901cf506393db15b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c",
  "human_readable_source": " \n\n \n#include \"link_dp_training.h\"\n#include \"link_dp_training_8b_10b.h\"\n#include \"link_dp_training_128b_132b.h\"\n#include \"link_dp_training_auxless.h\"\n#include \"link_dp_training_dpia.h\"\n#include \"link_dp_training_fixed_vs_pe_retimer.h\"\n#include \"link_dpcd.h\"\n#include \"link/accessories/link_dp_trace.h\"\n#include \"link_dp_phy.h\"\n#include \"link_dp_capability.h\"\n#include \"link_edp_panel_control.h\"\n#include \"link/link_detection.h\"\n#include \"link/link_validation.h\"\n#include \"atomfirmware.h\"\n#include \"link_enc_cfg.h\"\n#include \"resource.h\"\n#include \"dm_helpers.h\"\n\n#define DC_LOGGER \\\n\tlink->ctx->logger\n\n#define POST_LT_ADJ_REQ_LIMIT 6\n#define POST_LT_ADJ_REQ_TIMEOUT 200\n#define LINK_TRAINING_RETRY_DELAY 50  \n\nvoid dp_log_training_result(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *lt_settings,\n\tenum link_training_result status)\n{\n\tchar *link_rate = \"Unknown\";\n\tchar *lt_result = \"Unknown\";\n\tchar *lt_spread = \"Disabled\";\n\n\tswitch (lt_settings->link_settings.link_rate) {\n\tcase LINK_RATE_LOW:\n\t\tlink_rate = \"RBR\";\n\t\tbreak;\n\tcase LINK_RATE_RATE_2:\n\t\tlink_rate = \"R2\";\n\t\tbreak;\n\tcase LINK_RATE_RATE_3:\n\t\tlink_rate = \"R3\";\n\t\tbreak;\n\tcase LINK_RATE_HIGH:\n\t\tlink_rate = \"HBR\";\n\t\tbreak;\n\tcase LINK_RATE_RBR2:\n\t\tlink_rate = \"RBR2\";\n\t\tbreak;\n\tcase LINK_RATE_RATE_6:\n\t\tlink_rate = \"R6\";\n\t\tbreak;\n\tcase LINK_RATE_HIGH2:\n\t\tlink_rate = \"HBR2\";\n\t\tbreak;\n\tcase LINK_RATE_RATE_8:\n\t\tlink_rate = \"R8\";\n\t\tbreak;\n\tcase LINK_RATE_HIGH3:\n\t\tlink_rate = \"HBR3\";\n\t\tbreak;\n\tcase LINK_RATE_UHBR10:\n\t\tlink_rate = \"UHBR10\";\n\t\tbreak;\n\tcase LINK_RATE_UHBR13_5:\n\t\tlink_rate = \"UHBR13.5\";\n\t\tbreak;\n\tcase LINK_RATE_UHBR20:\n\t\tlink_rate = \"UHBR20\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (status) {\n\tcase LINK_TRAINING_SUCCESS:\n\t\tlt_result = \"pass\";\n\t\tbreak;\n\tcase LINK_TRAINING_CR_FAIL_LANE0:\n\t\tlt_result = \"CR failed lane0\";\n\t\tbreak;\n\tcase LINK_TRAINING_CR_FAIL_LANE1:\n\t\tlt_result = \"CR failed lane1\";\n\t\tbreak;\n\tcase LINK_TRAINING_CR_FAIL_LANE23:\n\t\tlt_result = \"CR failed lane23\";\n\t\tbreak;\n\tcase LINK_TRAINING_EQ_FAIL_CR:\n\t\tlt_result = \"CR failed in EQ\";\n\t\tbreak;\n\tcase LINK_TRAINING_EQ_FAIL_CR_PARTIAL:\n\t\tlt_result = \"CR failed in EQ partially\";\n\t\tbreak;\n\tcase LINK_TRAINING_EQ_FAIL_EQ:\n\t\tlt_result = \"EQ failed\";\n\t\tbreak;\n\tcase LINK_TRAINING_LQA_FAIL:\n\t\tlt_result = \"LQA failed\";\n\t\tbreak;\n\tcase LINK_TRAINING_LINK_LOSS:\n\t\tlt_result = \"Link loss\";\n\t\tbreak;\n\tcase DP_128b_132b_LT_FAILED:\n\t\tlt_result = \"LT_FAILED received\";\n\t\tbreak;\n\tcase DP_128b_132b_MAX_LOOP_COUNT_REACHED:\n\t\tlt_result = \"max loop count reached\";\n\t\tbreak;\n\tcase DP_128b_132b_CHANNEL_EQ_DONE_TIMEOUT:\n\t\tlt_result = \"channel EQ timeout\";\n\t\tbreak;\n\tcase DP_128b_132b_CDS_DONE_TIMEOUT:\n\t\tlt_result = \"CDS timeout\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (lt_settings->link_settings.link_spread) {\n\tcase LINK_SPREAD_DISABLED:\n\t\tlt_spread = \"Disabled\";\n\t\tbreak;\n\tcase LINK_SPREAD_05_DOWNSPREAD_30KHZ:\n\t\tlt_spread = \"0.5% 30KHz\";\n\t\tbreak;\n\tcase LINK_SPREAD_05_DOWNSPREAD_33KHZ:\n\t\tlt_spread = \"0.5% 33KHz\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\n\t \n\n\tCONN_MSG_LT(link, \"%sx%d %s VS=%d, PE=%d, DS=%s\",\n\t\t\t\tlink_rate,\n\t\t\t\tlt_settings->link_settings.lane_count,\n\t\t\t\tlt_result,\n\t\t\t\tlt_settings->hw_lane_settings[0].VOLTAGE_SWING,\n\t\t\t\tlt_settings->hw_lane_settings[0].PRE_EMPHASIS,\n\t\t\t\tlt_spread);\n}\n\nuint8_t dp_initialize_scrambling_data_symbols(\n\tstruct dc_link *link,\n\tenum dc_dp_training_pattern pattern)\n{\n\tuint8_t disable_scrabled_data_symbols = 0;\n\n\tswitch (pattern) {\n\tcase DP_TRAINING_PATTERN_SEQUENCE_1:\n\tcase DP_TRAINING_PATTERN_SEQUENCE_2:\n\tcase DP_TRAINING_PATTERN_SEQUENCE_3:\n\t\tdisable_scrabled_data_symbols = 1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_4:\n\tcase DP_128b_132b_TPS1:\n\tcase DP_128b_132b_TPS2:\n\t\tdisable_scrabled_data_symbols = 0;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Invalid HW Training pattern: %d\\n\",\n\t\t\t__func__, pattern);\n\t\tbreak;\n\t}\n\treturn disable_scrabled_data_symbols;\n}\n\nenum dpcd_training_patterns\n\tdp_training_pattern_to_dpcd_training_pattern(\n\tstruct dc_link *link,\n\tenum dc_dp_training_pattern pattern)\n{\n\tenum dpcd_training_patterns dpcd_tr_pattern =\n\tDPCD_TRAINING_PATTERN_VIDEOIDLE;\n\n\tswitch (pattern) {\n\tcase DP_TRAINING_PATTERN_SEQUENCE_1:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP training pattern TPS1\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_TRAINING_PATTERN_1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_2:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP training pattern TPS2\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_TRAINING_PATTERN_2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_3:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP training pattern TPS3\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_TRAINING_PATTERN_3;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_4:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP training pattern TPS4\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_TRAINING_PATTERN_4;\n\t\tbreak;\n\tcase DP_128b_132b_TPS1:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP 128b/132b training pattern TPS1\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_128b_132b_TPS1;\n\t\tbreak;\n\tcase DP_128b_132b_TPS2:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP 128b/132b training pattern TPS2\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_128b_132b_TPS2;\n\t\tbreak;\n\tcase DP_128b_132b_TPS2_CDS:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP 128b/132b training pattern TPS2 CDS\\n\",\n\t\t\t\t\t__func__);\n\t\tdpcd_tr_pattern = DPCD_128b_132b_TPS2_CDS;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_VIDEOIDLE:\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Using DP training pattern videoidle\\n\", __func__);\n\t\tdpcd_tr_pattern = DPCD_TRAINING_PATTERN_VIDEOIDLE;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Invalid HW Training pattern: %d\\n\",\n\t\t\t__func__, pattern);\n\t\tbreak;\n\t}\n\n\treturn dpcd_tr_pattern;\n}\n\nuint8_t dp_get_nibble_at_index(const uint8_t *buf,\n\tuint32_t index)\n{\n\tuint8_t nibble;\n\tnibble = buf[index / 2];\n\n\tif (index % 2)\n\t\tnibble >>= 4;\n\telse\n\t\tnibble &= 0x0F;\n\n\treturn nibble;\n}\n\nvoid dp_wait_for_training_aux_rd_interval(\n\tstruct dc_link *link,\n\tuint32_t wait_in_micro_secs)\n{\n\tfsleep(wait_in_micro_secs);\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n wait = %d\\n\",\n\t\t__func__,\n\t\twait_in_micro_secs);\n}\n\n \nstatic const enum dc_pre_emphasis voltage_swing_to_pre_emphasis[] = {\n\t\tPRE_EMPHASIS_LEVEL3,\n\t\tPRE_EMPHASIS_LEVEL2,\n\t\tPRE_EMPHASIS_LEVEL1,\n\t\tPRE_EMPHASIS_DISABLED };\n\nstatic enum dc_pre_emphasis get_max_pre_emphasis_for_voltage_swing(\n\tenum dc_voltage_swing voltage)\n{\n\tenum dc_pre_emphasis pre_emphasis;\n\tpre_emphasis = PRE_EMPHASIS_MAX_LEVEL;\n\n\tif (voltage <= VOLTAGE_SWING_MAX_LEVEL)\n\t\tpre_emphasis = voltage_swing_to_pre_emphasis[voltage];\n\n\treturn pre_emphasis;\n\n}\n\nstatic void maximize_lane_settings(const struct link_training_settings *lt_settings,\n\t\tstruct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX])\n{\n\tuint32_t lane;\n\tstruct dc_lane_settings max_requested;\n\n\tmax_requested.VOLTAGE_SWING = lane_settings[0].VOLTAGE_SWING;\n\tmax_requested.PRE_EMPHASIS = lane_settings[0].PRE_EMPHASIS;\n\tmax_requested.FFE_PRESET = lane_settings[0].FFE_PRESET;\n\n\t \n\tfor (lane = 1; lane < lt_settings->link_settings.lane_count; lane++) {\n\t\tif (lane_settings[lane].VOLTAGE_SWING > max_requested.VOLTAGE_SWING)\n\t\t\tmax_requested.VOLTAGE_SWING = lane_settings[lane].VOLTAGE_SWING;\n\n\t\tif (lane_settings[lane].PRE_EMPHASIS > max_requested.PRE_EMPHASIS)\n\t\t\tmax_requested.PRE_EMPHASIS = lane_settings[lane].PRE_EMPHASIS;\n\t\tif (lane_settings[lane].FFE_PRESET.settings.level >\n\t\t\t\tmax_requested.FFE_PRESET.settings.level)\n\t\t\tmax_requested.FFE_PRESET.settings.level =\n\t\t\t\t\tlane_settings[lane].FFE_PRESET.settings.level;\n\t}\n\n\t \n\tif (max_requested.VOLTAGE_SWING > VOLTAGE_SWING_MAX_LEVEL)\n\t\tmax_requested.VOLTAGE_SWING = VOLTAGE_SWING_MAX_LEVEL;\n\n\tif (max_requested.PRE_EMPHASIS > PRE_EMPHASIS_MAX_LEVEL)\n\t\tmax_requested.PRE_EMPHASIS = PRE_EMPHASIS_MAX_LEVEL;\n\tif (max_requested.FFE_PRESET.settings.level > DP_FFE_PRESET_MAX_LEVEL)\n\t\tmax_requested.FFE_PRESET.settings.level = DP_FFE_PRESET_MAX_LEVEL;\n\n\t \n\tif (max_requested.PRE_EMPHASIS >\n\t\tget_max_pre_emphasis_for_voltage_swing(\n\t\t\tmax_requested.VOLTAGE_SWING))\n\t\tmax_requested.PRE_EMPHASIS =\n\t\tget_max_pre_emphasis_for_voltage_swing(\n\t\t\tmax_requested.VOLTAGE_SWING);\n\n\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\tlane_settings[lane].VOLTAGE_SWING = max_requested.VOLTAGE_SWING;\n\t\tlane_settings[lane].PRE_EMPHASIS = max_requested.PRE_EMPHASIS;\n\t\tlane_settings[lane].FFE_PRESET = max_requested.FFE_PRESET;\n\t}\n}\n\nvoid dp_hw_to_dpcd_lane_settings(\n\t\tconst struct link_training_settings *lt_settings,\n\t\tconst struct dc_lane_settings hw_lane_settings[LANE_COUNT_DP_MAX],\n\t\tunion dpcd_training_lane dpcd_lane_settings[LANE_COUNT_DP_MAX])\n{\n\tuint8_t lane = 0;\n\n\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\tif (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_8b_10b_ENCODING) {\n\t\t\tdpcd_lane_settings[lane].bits.VOLTAGE_SWING_SET =\n\t\t\t\t\t(uint8_t)(hw_lane_settings[lane].VOLTAGE_SWING);\n\t\t\tdpcd_lane_settings[lane].bits.PRE_EMPHASIS_SET =\n\t\t\t\t\t(uint8_t)(hw_lane_settings[lane].PRE_EMPHASIS);\n\t\t\tdpcd_lane_settings[lane].bits.MAX_SWING_REACHED =\n\t\t\t\t\t(hw_lane_settings[lane].VOLTAGE_SWING ==\n\t\t\t\t\t\t\tVOLTAGE_SWING_MAX_LEVEL ? 1 : 0);\n\t\t\tdpcd_lane_settings[lane].bits.MAX_PRE_EMPHASIS_REACHED =\n\t\t\t\t\t(hw_lane_settings[lane].PRE_EMPHASIS ==\n\t\t\t\t\t\t\tPRE_EMPHASIS_MAX_LEVEL ? 1 : 0);\n\t\t} else if (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_128b_132b_ENCODING) {\n\t\t\tdpcd_lane_settings[lane].tx_ffe.PRESET_VALUE =\n\t\t\t\t\thw_lane_settings[lane].FFE_PRESET.settings.level;\n\t\t}\n\t}\n}\n\nuint8_t get_dpcd_link_rate(const struct dc_link_settings *link_settings)\n{\n\tuint8_t link_rate = 0;\n\tenum dp_link_encoding encoding = link_dp_get_encoding_format(link_settings);\n\n\tif (encoding == DP_128b_132b_ENCODING)\n\t\tswitch (link_settings->link_rate) {\n\t\tcase LINK_RATE_UHBR10:\n\t\t\tlink_rate = 0x1;\n\t\t\tbreak;\n\t\tcase LINK_RATE_UHBR20:\n\t\t\tlink_rate = 0x2;\n\t\t\tbreak;\n\t\tcase LINK_RATE_UHBR13_5:\n\t\t\tlink_rate = 0x4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlink_rate = 0;\n\t\t\tbreak;\n\t\t}\n\telse if (encoding == DP_8b_10b_ENCODING)\n\t\tlink_rate = (uint8_t) link_settings->link_rate;\n\telse\n\t\tlink_rate = 0;\n\n\treturn link_rate;\n}\n\n \nuint32_t dp_translate_training_aux_read_interval(uint32_t dpcd_aux_read_interval)\n{\n\tunsigned int aux_rd_interval_us = 400;\n\n\tswitch (dpcd_aux_read_interval) {\n\tcase 0x01:\n\t\taux_rd_interval_us = 4000;\n\t\tbreak;\n\tcase 0x02:\n\t\taux_rd_interval_us = 8000;\n\t\tbreak;\n\tcase 0x03:\n\t\taux_rd_interval_us = 12000;\n\t\tbreak;\n\tcase 0x04:\n\t\taux_rd_interval_us = 16000;\n\t\tbreak;\n\tcase 0x05:\n\t\taux_rd_interval_us = 32000;\n\t\tbreak;\n\tcase 0x06:\n\t\taux_rd_interval_us = 64000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn aux_rd_interval_us;\n}\n\nenum link_training_result dp_get_cr_failure(enum dc_lane_count ln_count,\n\t\t\t\t\tunion lane_status *dpcd_lane_status)\n{\n\tenum link_training_result result = LINK_TRAINING_SUCCESS;\n\n\tif (ln_count >= LANE_COUNT_ONE && !dpcd_lane_status[0].bits.CR_DONE_0)\n\t\tresult = LINK_TRAINING_CR_FAIL_LANE0;\n\telse if (ln_count >= LANE_COUNT_TWO && !dpcd_lane_status[1].bits.CR_DONE_0)\n\t\tresult = LINK_TRAINING_CR_FAIL_LANE1;\n\telse if (ln_count >= LANE_COUNT_FOUR && !dpcd_lane_status[2].bits.CR_DONE_0)\n\t\tresult = LINK_TRAINING_CR_FAIL_LANE23;\n\telse if (ln_count >= LANE_COUNT_FOUR && !dpcd_lane_status[3].bits.CR_DONE_0)\n\t\tresult = LINK_TRAINING_CR_FAIL_LANE23;\n\treturn result;\n}\n\nbool is_repeater(const struct link_training_settings *lt_settings, uint32_t offset)\n{\n\treturn (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT) && (offset != 0);\n}\n\nbool dp_is_max_vs_reached(\n\tconst struct link_training_settings *lt_settings)\n{\n\tuint32_t lane;\n\tfor (lane = 0; lane <\n\t\t(uint32_t)(lt_settings->link_settings.lane_count);\n\t\tlane++) {\n\t\tif (lt_settings->dpcd_lane_settings[lane].bits.VOLTAGE_SWING_SET\n\t\t\t== VOLTAGE_SWING_MAX_LEVEL)\n\t\t\treturn true;\n\t}\n\treturn false;\n\n}\n\nbool dp_is_cr_done(enum dc_lane_count ln_count,\n\tunion lane_status *dpcd_lane_status)\n{\n\tbool done = true;\n\tuint32_t lane;\n\t \n\tfor (lane = 0; lane < (uint32_t)(ln_count); lane++) {\n\t\tif (!dpcd_lane_status[lane].bits.CR_DONE_0)\n\t\t\tdone = false;\n\t}\n\treturn done;\n\n}\n\nbool dp_is_ch_eq_done(enum dc_lane_count ln_count,\n\t\tunion lane_status *dpcd_lane_status)\n{\n\tbool done = true;\n\tuint32_t lane;\n\tfor (lane = 0; lane < (uint32_t)(ln_count); lane++)\n\t\tif (!dpcd_lane_status[lane].bits.CHANNEL_EQ_DONE_0)\n\t\t\tdone = false;\n\treturn done;\n}\n\nbool dp_is_symbol_locked(enum dc_lane_count ln_count,\n\t\tunion lane_status *dpcd_lane_status)\n{\n\tbool locked = true;\n\tuint32_t lane;\n\tfor (lane = 0; lane < (uint32_t)(ln_count); lane++)\n\t\tif (!dpcd_lane_status[lane].bits.SYMBOL_LOCKED_0)\n\t\t\tlocked = false;\n\treturn locked;\n}\n\nbool dp_is_interlane_aligned(union lane_align_status_updated align_status)\n{\n\treturn align_status.bits.INTERLANE_ALIGN_DONE == 1;\n}\n\nenum link_training_result dp_check_link_loss_status(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *link_training_setting)\n{\n\tenum link_training_result status = LINK_TRAINING_SUCCESS;\n\tunion lane_status lane_status;\n\tuint8_t dpcd_buf[6] = {0};\n\tuint32_t lane;\n\n\tcore_link_read_dpcd(\n\t\t\tlink,\n\t\t\tDP_SINK_COUNT,\n\t\t\t(uint8_t *)(dpcd_buf),\n\t\t\tsizeof(dpcd_buf));\n\n\t \n\tfor (lane = 0; lane < link->cur_link_settings.lane_count; lane++) {\n\t\t \n\t\tlane_status.raw = dp_get_nibble_at_index(&dpcd_buf[2], lane);\n\n\t\tif (!lane_status.bits.CHANNEL_EQ_DONE_0 ||\n\t\t\t!lane_status.bits.CR_DONE_0 ||\n\t\t\t!lane_status.bits.SYMBOL_LOCKED_0) {\n\t\t\t \n\t\t\tstatus = LINK_TRAINING_LINK_LOSS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nenum dc_status dp_get_lane_status_and_lane_adjust(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *link_training_setting,\n\tunion lane_status ln_status[LANE_COUNT_DP_MAX],\n\tunion lane_align_status_updated *ln_align,\n\tunion lane_adjust ln_adjust[LANE_COUNT_DP_MAX],\n\tuint32_t offset)\n{\n\tunsigned int lane01_status_address = DP_LANE0_1_STATUS;\n\tuint8_t lane_adjust_offset = 4;\n\tunsigned int lane01_adjust_address;\n\tuint8_t dpcd_buf[6] = {0};\n\tuint32_t lane;\n\tenum dc_status status;\n\n\tif (is_repeater(link_training_setting, offset)) {\n\t\tlane01_status_address =\n\t\t\t\tDP_LANE0_1_STATUS_PHY_REPEATER1 +\n\t\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\t\tlane_adjust_offset = 3;\n\t}\n\n\tstatus = core_link_read_dpcd(\n\t\tlink,\n\t\tlane01_status_address,\n\t\t(uint8_t *)(dpcd_buf),\n\t\tsizeof(dpcd_buf));\n\n\tif (status != DC_OK) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n Failed to read from address 0x%X,\"\n\t\t\t\" keep current lane status and lane adjust unchanged\",\n\t\t\t__func__,\n\t\t\tlane01_status_address);\n\t\treturn status;\n\t}\n\n\tfor (lane = 0; lane <\n\t\t(uint32_t)(link_training_setting->link_settings.lane_count);\n\t\tlane++) {\n\n\t\tln_status[lane].raw =\n\t\t\tdp_get_nibble_at_index(&dpcd_buf[0], lane);\n\t\tln_adjust[lane].raw =\n\t\t\tdp_get_nibble_at_index(&dpcd_buf[lane_adjust_offset], lane);\n\t}\n\n\tln_align->raw = dpcd_buf[2];\n\n\tif (is_repeater(link_training_setting, offset)) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n LTTPR Repeater ID: %d\\n\"\n\t\t\t\t\" 0x%X Lane01Status = %x\\n 0x%X Lane23Status = %x\\n \",\n\t\t\t__func__,\n\t\t\toffset,\n\t\t\tlane01_status_address, dpcd_buf[0],\n\t\t\tlane01_status_address + 1, dpcd_buf[1]);\n\n\t\tlane01_adjust_address = DP_ADJUST_REQUEST_LANE0_1_PHY_REPEATER1 +\n\t\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n LTTPR Repeater ID: %d\\n\"\n\t\t\t\t\" 0x%X Lane01AdjustRequest = %x\\n 0x%X Lane23AdjustRequest = %x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\toffset,\n\t\t\t\t\tlane01_adjust_address,\n\t\t\t\t\tdpcd_buf[lane_adjust_offset],\n\t\t\t\t\tlane01_adjust_address + 1,\n\t\t\t\t\tdpcd_buf[lane_adjust_offset + 1]);\n\t} else {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X Lane01Status = %x\\n 0x%X Lane23Status = %x\\n \",\n\t\t\t__func__,\n\t\t\tlane01_status_address, dpcd_buf[0],\n\t\t\tlane01_status_address + 1, dpcd_buf[1]);\n\n\t\tlane01_adjust_address = DP_ADJUST_REQUEST_LANE0_1;\n\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X Lane01AdjustRequest = %x\\n 0x%X Lane23AdjustRequest = %x\\n\",\n\t\t\t__func__,\n\t\t\tlane01_adjust_address,\n\t\t\tdpcd_buf[lane_adjust_offset],\n\t\t\tlane01_adjust_address + 1,\n\t\t\tdpcd_buf[lane_adjust_offset + 1]);\n\t}\n\n\treturn status;\n}\n\nstatic void override_lane_settings(const struct link_training_settings *lt_settings,\n\t\tstruct dc_lane_settings lane_settings[LANE_COUNT_DP_MAX])\n{\n\tuint32_t lane;\n\n\tif (lt_settings->voltage_swing == NULL &&\n\t\t\tlt_settings->pre_emphasis == NULL &&\n\t\t\tlt_settings->ffe_preset == NULL &&\n\t\t\tlt_settings->post_cursor2 == NULL)\n\n\t\treturn;\n\n\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\tif (lt_settings->voltage_swing)\n\t\t\tlane_settings[lane].VOLTAGE_SWING = *lt_settings->voltage_swing;\n\t\tif (lt_settings->pre_emphasis)\n\t\t\tlane_settings[lane].PRE_EMPHASIS = *lt_settings->pre_emphasis;\n\t\tif (lt_settings->post_cursor2)\n\t\t\tlane_settings[lane].POST_CURSOR2 = *lt_settings->post_cursor2;\n\t\tif (lt_settings->ffe_preset)\n\t\t\tlane_settings[lane].FFE_PRESET = *lt_settings->ffe_preset;\n\t}\n}\n\nvoid dp_get_lttpr_mode_override(struct dc_link *link, enum lttpr_mode *override)\n{\n\tif (!dp_is_lttpr_present(link))\n\t\treturn;\n\n\tif (link->dc->debug.lttpr_mode_override == LTTPR_MODE_TRANSPARENT) {\n\t\t*override = LTTPR_MODE_TRANSPARENT;\n\t} else if (link->dc->debug.lttpr_mode_override == LTTPR_MODE_NON_TRANSPARENT) {\n\t\t*override = LTTPR_MODE_NON_TRANSPARENT;\n\t} else if (link->dc->debug.lttpr_mode_override == LTTPR_MODE_NON_LTTPR) {\n\t\t*override = LTTPR_MODE_NON_LTTPR;\n\t}\n\tDC_LOG_DC(\"lttpr_mode_override chose LTTPR_MODE = %d\\n\", (uint8_t)(*override));\n}\n\nvoid override_training_settings(\n\t\tstruct dc_link *link,\n\t\tconst struct dc_link_training_overrides *overrides,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tuint32_t lane;\n\n\t \n\tif (!link->dp_ss_off && overrides->downspread != NULL)\n\t\tlt_settings->link_settings.link_spread = *overrides->downspread ?\n\t\t\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ\n\t\t\t\t: LINK_SPREAD_DISABLED;\n\n\t \n\tif (overrides->voltage_swing != NULL)\n\t\tlt_settings->voltage_swing = overrides->voltage_swing;\n\tif (overrides->pre_emphasis != NULL)\n\t\tlt_settings->pre_emphasis = overrides->pre_emphasis;\n\tif (overrides->post_cursor2 != NULL)\n\t\tlt_settings->post_cursor2 = overrides->post_cursor2;\n\tif (overrides->ffe_preset != NULL)\n\t\tlt_settings->ffe_preset = overrides->ffe_preset;\n\t \n\tif ((link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) &&\n\t\t\tlt_settings->lttpr_mode == LTTPR_MODE_TRANSPARENT) {\n\t\tlt_settings->voltage_swing = &link->bios_forced_drive_settings.VOLTAGE_SWING;\n\t\tlt_settings->pre_emphasis = &link->bios_forced_drive_settings.PRE_EMPHASIS;\n\t\tlt_settings->always_match_dpcd_with_hw_lane_settings = false;\n\t}\n\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\tlt_settings->hw_lane_settings[lane].VOLTAGE_SWING =\n\t\t\tlt_settings->voltage_swing != NULL ?\n\t\t\t*lt_settings->voltage_swing :\n\t\t\tVOLTAGE_SWING_LEVEL0;\n\t\tlt_settings->hw_lane_settings[lane].PRE_EMPHASIS =\n\t\t\tlt_settings->pre_emphasis != NULL ?\n\t\t\t*lt_settings->pre_emphasis\n\t\t\t: PRE_EMPHASIS_DISABLED;\n\t\tlt_settings->hw_lane_settings[lane].POST_CURSOR2 =\n\t\t\tlt_settings->post_cursor2 != NULL ?\n\t\t\t*lt_settings->post_cursor2\n\t\t\t: POST_CURSOR2_DISABLED;\n\t}\n\n\tif (lt_settings->always_match_dpcd_with_hw_lane_settings)\n\t\tdp_hw_to_dpcd_lane_settings(lt_settings,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\n\t \n\tif (overrides->cr_pattern_time != NULL)\n\t\tlt_settings->cr_pattern_time = *overrides->cr_pattern_time;\n\tif (overrides->eq_pattern_time != NULL)\n\t\tlt_settings->eq_pattern_time = *overrides->eq_pattern_time;\n\tif (overrides->pattern_for_cr != NULL)\n\t\tlt_settings->pattern_for_cr = *overrides->pattern_for_cr;\n\tif (overrides->pattern_for_eq != NULL)\n\t\tlt_settings->pattern_for_eq = *overrides->pattern_for_eq;\n\tif (overrides->enhanced_framing != NULL)\n\t\tlt_settings->enhanced_framing = *overrides->enhanced_framing;\n\tif (link->preferred_training_settings.fec_enable != NULL)\n\t\tlt_settings->should_set_fec_ready = *link->preferred_training_settings.fec_enable;\n\n\t \n\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA && link->dc->debug.dpia_debug.bits.force_non_lttpr)\n\t\tlt_settings->lttpr_mode = LTTPR_MODE_NON_LTTPR;\n\n\tdp_get_lttpr_mode_override(link, &lt_settings->lttpr_mode);\n\n}\n\nenum dc_dp_training_pattern decide_cr_training_pattern(\n\t\tconst struct dc_link_settings *link_settings)\n{\n\tswitch (link_dp_get_encoding_format(link_settings)) {\n\tcase DP_8b_10b_ENCODING:\n\tdefault:\n\t\treturn DP_TRAINING_PATTERN_SEQUENCE_1;\n\tcase DP_128b_132b_ENCODING:\n\t\treturn DP_128b_132b_TPS1;\n\t}\n}\n\nenum dc_dp_training_pattern decide_eq_training_pattern(struct dc_link *link,\n\t\tconst struct dc_link_settings *link_settings)\n{\n\tstruct link_encoder *link_enc;\n\tstruct encoder_feature_support *enc_caps;\n\tstruct dpcd_caps *rx_caps = &link->dpcd_caps;\n\tenum dc_dp_training_pattern pattern = DP_TRAINING_PATTERN_SEQUENCE_2;\n\n\tlink_enc = link_enc_cfg_get_link_enc(link);\n\tASSERT(link_enc);\n\tenc_caps = &link_enc->features;\n\n\tswitch (link_dp_get_encoding_format(link_settings)) {\n\tcase DP_8b_10b_ENCODING:\n\t\tif (enc_caps->flags.bits.IS_TPS4_CAPABLE &&\n\t\t\t\trx_caps->max_down_spread.bits.TPS4_SUPPORTED)\n\t\t\tpattern = DP_TRAINING_PATTERN_SEQUENCE_4;\n\t\telse if (enc_caps->flags.bits.IS_TPS3_CAPABLE &&\n\t\t\t\trx_caps->max_ln_count.bits.TPS3_SUPPORTED)\n\t\t\tpattern = DP_TRAINING_PATTERN_SEQUENCE_3;\n\t\telse\n\t\t\tpattern = DP_TRAINING_PATTERN_SEQUENCE_2;\n\t\tbreak;\n\tcase DP_128b_132b_ENCODING:\n\t\tpattern = DP_128b_132b_TPS2;\n\t\tbreak;\n\tdefault:\n\t\tpattern = DP_TRAINING_PATTERN_SEQUENCE_2;\n\t\tbreak;\n\t}\n\treturn pattern;\n}\n\nenum lttpr_mode dp_decide_lttpr_mode(struct dc_link *link,\n\t\tstruct dc_link_settings *link_setting)\n{\n\tenum dp_link_encoding encoding = link_dp_get_encoding_format(link_setting);\n\n\tif (encoding == DP_8b_10b_ENCODING)\n\t\treturn dp_decide_8b_10b_lttpr_mode(link);\n\telse if (encoding == DP_128b_132b_ENCODING)\n\t\treturn dp_decide_128b_132b_lttpr_mode(link);\n\n\tASSERT(0);\n\treturn LTTPR_MODE_NON_LTTPR;\n}\n\nvoid dp_decide_lane_settings(\n\t\tconst struct link_training_settings *lt_settings,\n\t\tconst union lane_adjust ln_adjust[LANE_COUNT_DP_MAX],\n\t\tstruct dc_lane_settings hw_lane_settings[LANE_COUNT_DP_MAX],\n\t\tunion dpcd_training_lane *dpcd_lane_settings)\n{\n\tuint32_t lane;\n\n\tfor (lane = 0; lane < LANE_COUNT_DP_MAX; lane++) {\n\t\tif (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_8b_10b_ENCODING) {\n\t\t\thw_lane_settings[lane].VOLTAGE_SWING =\n\t\t\t\t\t(enum dc_voltage_swing)(ln_adjust[lane].bits.\n\t\t\t\t\t\t\tVOLTAGE_SWING_LANE);\n\t\t\thw_lane_settings[lane].PRE_EMPHASIS =\n\t\t\t\t\t(enum dc_pre_emphasis)(ln_adjust[lane].bits.\n\t\t\t\t\t\t\tPRE_EMPHASIS_LANE);\n\t\t} else if (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_128b_132b_ENCODING) {\n\t\t\thw_lane_settings[lane].FFE_PRESET.raw =\n\t\t\t\t\tln_adjust[lane].tx_ffe.PRESET_VALUE;\n\t\t}\n\t}\n\tdp_hw_to_dpcd_lane_settings(lt_settings, hw_lane_settings, dpcd_lane_settings);\n\n\tif (lt_settings->disallow_per_lane_settings) {\n\t\t \n\t\t \n\t\tmaximize_lane_settings(lt_settings, hw_lane_settings);\n\t\toverride_lane_settings(lt_settings, hw_lane_settings);\n\n\t\tif (lt_settings->always_match_dpcd_with_hw_lane_settings)\n\t\t\tdp_hw_to_dpcd_lane_settings(lt_settings, hw_lane_settings, dpcd_lane_settings);\n\t}\n\n}\n\nvoid dp_decide_training_settings(\n\t\tstruct dc_link *link,\n\t\tconst struct dc_link_settings *link_settings,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tif (link_dp_get_encoding_format(link_settings) == DP_8b_10b_ENCODING)\n\t\tdecide_8b_10b_training_settings(link, link_settings, lt_settings);\n\telse if (link_dp_get_encoding_format(link_settings) == DP_128b_132b_ENCODING)\n\t\tdecide_128b_132b_training_settings(link, link_settings, lt_settings);\n}\n\n\nenum dc_status configure_lttpr_mode_transparent(struct dc_link *link)\n{\n\tuint8_t repeater_mode = DP_PHY_REPEATER_MODE_TRANSPARENT;\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n Set LTTPR to Transparent Mode\\n\", __func__);\n\treturn core_link_write_dpcd(link,\n\t\t\tDP_PHY_REPEATER_MODE,\n\t\t\t(uint8_t *)&repeater_mode,\n\t\t\tsizeof(repeater_mode));\n}\n\nstatic enum dc_status configure_lttpr_mode_non_transparent(\n\t\tstruct dc_link *link,\n\t\tconst struct link_training_settings *lt_settings)\n{\n\t \n\t \n\tuint8_t repeater_cnt;\n\tuint32_t aux_interval_address;\n\tuint8_t repeater_id;\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\tuint8_t repeater_mode = DP_PHY_REPEATER_MODE_TRANSPARENT;\n\tconst struct dc *dc = link->dc;\n\n\tenum dp_link_encoding encoding = dc->link_srv->dp_get_encoding_format(&lt_settings->link_settings);\n\n\tif (encoding == DP_8b_10b_ENCODING) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n Set LTTPR to Transparent Mode\\n\", __func__);\n\t\tresult = core_link_write_dpcd(link,\n\t\t\t\tDP_PHY_REPEATER_MODE,\n\t\t\t\t(uint8_t *)&repeater_mode,\n\t\t\t\tsizeof(repeater_mode));\n\n\t}\n\n\tif (result == DC_OK) {\n\t\tlink->dpcd_caps.lttpr_caps.mode = repeater_mode;\n\t}\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT) {\n\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n Set LTTPR to Non Transparent Mode\\n\", __func__);\n\n\t\trepeater_mode = DP_PHY_REPEATER_MODE_NON_TRANSPARENT;\n\t\tresult = core_link_write_dpcd(link,\n\t\t\t\tDP_PHY_REPEATER_MODE,\n\t\t\t\t(uint8_t *)&repeater_mode,\n\t\t\t\tsizeof(repeater_mode));\n\n\t\tif (result == DC_OK) {\n\t\t\tlink->dpcd_caps.lttpr_caps.mode = repeater_mode;\n\t\t}\n\n\t\tif (encoding == DP_8b_10b_ENCODING) {\n\t\t\trepeater_cnt = dp_parse_lttpr_repeater_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt);\n\n\t\t\t \n\t\t\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA)\n\t\t\t\tlink->dpcd_caps.lttpr_caps.aux_rd_interval[--repeater_cnt] = 0;\n\n\t\t\tfor (repeater_id = repeater_cnt; repeater_id > 0; repeater_id--) {\n\t\t\t\taux_interval_address = DP_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER1 +\n\t\t\t\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (repeater_id - 1));\n\t\t\t\tcore_link_read_dpcd(\n\t\t\t\t\t\tlink,\n\t\t\t\t\t\taux_interval_address,\n\t\t\t\t\t\t(uint8_t *)&link->dpcd_caps.lttpr_caps.aux_rd_interval[repeater_id - 1],\n\t\t\t\t\t\tsizeof(link->dpcd_caps.lttpr_caps.aux_rd_interval[repeater_id - 1]));\n\t\t\t\tlink->dpcd_caps.lttpr_caps.aux_rd_interval[repeater_id - 1] &= 0x7F;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nenum dc_status dpcd_configure_lttpr_mode(struct dc_link *link, struct link_training_settings *lt_settings)\n{\n\tenum dc_status status = DC_OK;\n\n\tif (lt_settings->lttpr_mode == LTTPR_MODE_TRANSPARENT)\n\t\tstatus = configure_lttpr_mode_transparent(link);\n\n\telse if (lt_settings->lttpr_mode == LTTPR_MODE_NON_TRANSPARENT)\n\t\tstatus = configure_lttpr_mode_non_transparent(link, lt_settings);\n\n\treturn status;\n}\n\nvoid repeater_training_done(struct dc_link *link, uint32_t offset)\n{\n\tunion dpcd_training_pattern dpcd_pattern = {0};\n\n\tconst uint32_t dpcd_base_lt_offset =\n\t\t\tDP_TRAINING_PATTERN_SET_PHY_REPEATER1 +\n\t\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\t \n\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET = DPCD_TRAINING_PATTERN_VIDEOIDLE;\n\n\tcore_link_write_dpcd(\n\t\tlink,\n\t\tdpcd_base_lt_offset,\n\t\t&dpcd_pattern.raw,\n\t\t1);\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n LTTPR Id: %d 0x%X pattern = %x\\n\",\n\t\t__func__,\n\t\toffset,\n\t\tdpcd_base_lt_offset,\n\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n}\n\nstatic void dpcd_exit_training_mode(struct dc_link *link, enum dp_link_encoding encoding)\n{\n\tuint8_t sink_status = 0;\n\tuint8_t i;\n\n\t \n\tdpcd_set_training_pattern(link, DP_TRAINING_PATTERN_VIDEOIDLE);\n\n\tif (encoding == DP_128b_132b_ENCODING) {\n\t\t \n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tif ((core_link_read_dpcd(link, DP_SINK_STATUS, &sink_status, 1) == DC_OK) &&\n\t\t\t\t\t(sink_status & DP_INTRA_HOP_AUX_REPLY_INDICATION) == 0)\n\t\t\t\tbreak;\n\t\t\tfsleep(1000);\n\t\t}\n\t}\n}\n\nenum dc_status dpcd_configure_channel_coding(struct dc_link *link,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum dp_link_encoding encoding =\n\t\t\tlink_dp_get_encoding_format(\n\t\t\t\t\t&lt_settings->link_settings);\n\tenum dc_status status;\n\n\tstatus = core_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_MAIN_LINK_CHANNEL_CODING_SET,\n\t\t\t(uint8_t *) &encoding,\n\t\t\t1);\n\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X MAIN_LINK_CHANNEL_CODING_SET = %x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tDP_MAIN_LINK_CHANNEL_CODING_SET,\n\t\t\t\t\tencoding);\n\n\treturn status;\n}\n\nvoid dpcd_set_training_pattern(\n\tstruct dc_link *link,\n\tenum dc_dp_training_pattern training_pattern)\n{\n\tunion dpcd_training_pattern dpcd_pattern = {0};\n\n\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET =\n\t\t\tdp_training_pattern_to_dpcd_training_pattern(\n\t\t\t\t\tlink, training_pattern);\n\n\tcore_link_write_dpcd(\n\t\tlink,\n\t\tDP_TRAINING_PATTERN_SET,\n\t\t&dpcd_pattern.raw,\n\t\t1);\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n %x pattern = %x\\n\",\n\t\t__func__,\n\t\tDP_TRAINING_PATTERN_SET,\n\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n}\n\nenum dc_status dpcd_set_link_settings(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *lt_settings)\n{\n\tuint8_t rate;\n\tenum dc_status status;\n\n\tunion down_spread_ctrl downspread = {0};\n\tunion lane_count_set lane_count_set = {0};\n\n\tdownspread.raw = (uint8_t)\n\t(lt_settings->link_settings.link_spread);\n\n\tlane_count_set.bits.LANE_COUNT_SET =\n\tlt_settings->link_settings.lane_count;\n\n\tlane_count_set.bits.ENHANCED_FRAMING = lt_settings->enhanced_framing;\n\tlane_count_set.bits.POST_LT_ADJ_REQ_GRANTED = 0;\n\n\n\tif (link->ep_type == DISPLAY_ENDPOINT_PHY &&\n\t\t\tlt_settings->pattern_for_eq < DP_TRAINING_PATTERN_SEQUENCE_4) {\n\t\tlane_count_set.bits.POST_LT_ADJ_REQ_GRANTED =\n\t\t\t\tlink->dpcd_caps.max_ln_count.bits.POST_LT_ADJ_REQ_SUPPORTED;\n\t}\n\n\tstatus = core_link_write_dpcd(link, DP_DOWNSPREAD_CTRL,\n\t\t&downspread.raw, sizeof(downspread));\n\n\tstatus = core_link_write_dpcd(link, DP_LANE_COUNT_SET,\n\t\t&lane_count_set.raw, 1);\n\n\tif (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_13 &&\n\t\t\tlt_settings->link_settings.use_link_rate_set == true) {\n\t\trate = 0;\n\t\t \n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\tuint8_t supported_link_rates[16];\n\n\t\t\tcore_link_read_dpcd(link, DP_SUPPORTED_LINK_RATES,\n\t\t\t\t\tsupported_link_rates, sizeof(supported_link_rates));\n\t\t}\n\t\tstatus = core_link_write_dpcd(link, DP_LINK_BW_SET, &rate, 1);\n\t\tstatus = core_link_write_dpcd(link, DP_LINK_RATE_SET,\n\t\t\t\t&lt_settings->link_settings.link_rate_set, 1);\n\t} else {\n\t\trate = get_dpcd_link_rate(&lt_settings->link_settings);\n\n\t\tstatus = core_link_write_dpcd(link, DP_LINK_BW_SET, &rate, 1);\n\t}\n\n\tif (rate) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n %x rate = %x\\n %x lane = %x framing = %x\\n %x spread = %x\\n\",\n\t\t\t__func__,\n\t\t\tDP_LINK_BW_SET,\n\t\t\tlt_settings->link_settings.link_rate,\n\t\t\tDP_LANE_COUNT_SET,\n\t\t\tlt_settings->link_settings.lane_count,\n\t\t\tlt_settings->enhanced_framing,\n\t\t\tDP_DOWNSPREAD_CTRL,\n\t\t\tlt_settings->link_settings.link_spread);\n\t} else {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n %x rate set = %x\\n %x lane = %x framing = %x\\n %x spread = %x\\n\",\n\t\t\t__func__,\n\t\t\tDP_LINK_RATE_SET,\n\t\t\tlt_settings->link_settings.link_rate_set,\n\t\t\tDP_LANE_COUNT_SET,\n\t\t\tlt_settings->link_settings.lane_count,\n\t\t\tlt_settings->enhanced_framing,\n\t\t\tDP_DOWNSPREAD_CTRL,\n\t\t\tlt_settings->link_settings.link_spread);\n\t}\n\n\treturn status;\n}\n\nenum dc_status dpcd_set_lane_settings(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *link_training_setting,\n\tuint32_t offset)\n{\n\tunsigned int lane0_set_address;\n\tenum dc_status status;\n\tlane0_set_address = DP_TRAINING_LANE0_SET;\n\n\tif (is_repeater(link_training_setting, offset))\n\t\tlane0_set_address = DP_TRAINING_LANE0_SET_PHY_REPEATER1 +\n\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\n\tstatus = core_link_write_dpcd(link,\n\t\tlane0_set_address,\n\t\t(uint8_t *)(link_training_setting->dpcd_lane_settings),\n\t\tlink_training_setting->link_settings.lane_count);\n\n\tif (is_repeater(link_training_setting, offset)) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n LTTPR Repeater ID: %d\\n\"\n\t\t\t\t\" 0x%X VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\\n\",\n\t\t\t__func__,\n\t\t\toffset,\n\t\t\tlane0_set_address,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.MAX_SWING_REACHED,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.MAX_PRE_EMPHASIS_REACHED);\n\n\t} else {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n 0x%X VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\\n\",\n\t\t\t__func__,\n\t\t\tlane0_set_address,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.MAX_SWING_REACHED,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].bits.MAX_PRE_EMPHASIS_REACHED);\n\t}\n\n\treturn status;\n}\n\nvoid dpcd_set_lt_pattern_and_lane_settings(\n\tstruct dc_link *link,\n\tconst struct link_training_settings *lt_settings,\n\tenum dc_dp_training_pattern pattern,\n\tuint32_t offset)\n{\n\tuint32_t dpcd_base_lt_offset;\n\tuint8_t dpcd_lt_buffer[5] = {0};\n\tunion dpcd_training_pattern dpcd_pattern = {0};\n\tuint32_t size_in_bytes;\n\tbool edp_workaround = false;  \n\tdpcd_base_lt_offset = DP_TRAINING_PATTERN_SET;\n\n\tif (is_repeater(lt_settings, offset))\n\t\tdpcd_base_lt_offset = DP_TRAINING_PATTERN_SET_PHY_REPEATER1 +\n\t\t\t((DP_REPEATER_CONFIGURATION_AND_STATUS_SIZE) * (offset - 1));\n\n\t \n\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET =\n\t\tdp_training_pattern_to_dpcd_training_pattern(link, pattern);\n\n\tdpcd_pattern.v1_4.SCRAMBLING_DISABLE =\n\t\tdp_initialize_scrambling_data_symbols(link, pattern);\n\n\tdpcd_lt_buffer[DP_TRAINING_PATTERN_SET - DP_TRAINING_PATTERN_SET]\n\t\t= dpcd_pattern.raw;\n\n\tif (is_repeater(lt_settings, offset)) {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n LTTPR Repeater ID: %d\\n 0x%X pattern = %x\\n\",\n\t\t\t__func__,\n\t\t\toffset,\n\t\t\tdpcd_base_lt_offset,\n\t\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n\t} else {\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s\\n 0x%X pattern = %x\\n\",\n\t\t\t__func__,\n\t\t\tdpcd_base_lt_offset,\n\t\t\tdpcd_pattern.v1_4.TRAINING_PATTERN_SET);\n\t}\n\n\t \n\tsize_in_bytes = lt_settings->link_settings.lane_count *\n\t\t\tsizeof(lt_settings->dpcd_lane_settings[0]);\n\n\t \n\tmemmove(\n\t\t&dpcd_lt_buffer[DP_TRAINING_LANE0_SET - DP_TRAINING_PATTERN_SET],\n\t\tlt_settings->dpcd_lane_settings,\n\t\tsize_in_bytes);\n\n\tif (is_repeater(lt_settings, offset)) {\n\t\tif (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_128b_132b_ENCODING)\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n LTTPR Repeater ID: %d\\n\"\n\t\t\t\t\t\" 0x%X TX_FFE_PRESET_VALUE = %x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\toffset,\n\t\t\t\t\tdpcd_base_lt_offset,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].tx_ffe.PRESET_VALUE);\n\t\telse if (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_8b_10b_ENCODING)\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n LTTPR Repeater ID: %d\\n\"\n\t\t\t\t\" 0x%X VS set = %x PE set = %x max VS Reached = %x  max PE Reached = %x\\n\",\n\t\t\t__func__,\n\t\t\toffset,\n\t\t\tdpcd_base_lt_offset,\n\t\t\tlt_settings->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET,\n\t\t\tlt_settings->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET,\n\t\t\tlt_settings->dpcd_lane_settings[0].bits.MAX_SWING_REACHED,\n\t\t\tlt_settings->dpcd_lane_settings[0].bits.MAX_PRE_EMPHASIS_REACHED);\n\t} else {\n\t\tif (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_128b_132b_ENCODING)\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X TX_FFE_PRESET_VALUE = %x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tdpcd_base_lt_offset,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].tx_ffe.PRESET_VALUE);\n\t\telse if (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\t\tDP_8b_10b_ENCODING)\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tdpcd_base_lt_offset,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].bits.VOLTAGE_SWING_SET,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].bits.PRE_EMPHASIS_SET,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].bits.MAX_SWING_REACHED,\n\t\t\t\t\tlt_settings->dpcd_lane_settings[0].bits.MAX_PRE_EMPHASIS_REACHED);\n\t}\n\tif (edp_workaround) {\n\t\t \n\t\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_TRAINING_PATTERN_SET,\n\t\t\t&dpcd_pattern.raw,\n\t\t\tsizeof(dpcd_pattern.raw));\n\n\t\tcore_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_TRAINING_LANE0_SET,\n\t\t\t(uint8_t *)(lt_settings->dpcd_lane_settings),\n\t\t\tsize_in_bytes);\n\n\t} else if (link_dp_get_encoding_format(&lt_settings->link_settings) ==\n\t\t\tDP_128b_132b_ENCODING) {\n\t\tcore_link_write_dpcd(\n\t\t\t\tlink,\n\t\t\t\tdpcd_base_lt_offset,\n\t\t\t\tdpcd_lt_buffer,\n\t\t\t\tsizeof(dpcd_lt_buffer));\n\t} else\n\t\t \n\t\tcore_link_write_dpcd(\n\t\t\t\tlink,\n\t\t\t\tdpcd_base_lt_offset,\n\t\t\t\tdpcd_lt_buffer,\n\t\t\t\tsize_in_bytes + sizeof(dpcd_pattern.raw));\n}\n\nvoid start_clock_recovery_pattern_early(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings,\n\t\tuint32_t offset)\n{\n\tDC_LOG_HW_LINK_TRAINING(\"%s\\n GPU sends TPS1. Wait 400us.\\n\",\n\t\t\t__func__);\n\tdp_set_hw_training_pattern(link, link_res, lt_settings->pattern_for_cr, offset);\n\tdp_set_hw_lane_settings(link, link_res, lt_settings, offset);\n\tudelay(400);\n}\n\nvoid dp_set_hw_test_pattern(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tenum dp_test_pattern test_pattern,\n\tuint8_t *custom_pattern,\n\tuint32_t custom_pattern_size)\n{\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\tstruct encoder_set_dp_phy_pattern_param pattern_param = {0};\n\n\tpattern_param.dp_phy_pattern = test_pattern;\n\tpattern_param.custom_pattern = custom_pattern;\n\tpattern_param.custom_pattern_size = custom_pattern_size;\n\tpattern_param.dp_panel_mode = dp_get_panel_mode(link);\n\n\tif (link_hwss->ext.set_dp_link_test_pattern)\n\t\tlink_hwss->ext.set_dp_link_test_pattern(link, link_res, &pattern_param);\n}\n\nbool dp_set_hw_training_pattern(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tenum dc_dp_training_pattern pattern,\n\tuint32_t offset)\n{\n\tenum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;\n\n\tswitch (pattern) {\n\tcase DP_TRAINING_PATTERN_SEQUENCE_1:\n\t\ttest_pattern = DP_TEST_PATTERN_TRAINING_PATTERN1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_2:\n\t\ttest_pattern = DP_TEST_PATTERN_TRAINING_PATTERN2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_3:\n\t\ttest_pattern = DP_TEST_PATTERN_TRAINING_PATTERN3;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_SEQUENCE_4:\n\t\ttest_pattern = DP_TEST_PATTERN_TRAINING_PATTERN4;\n\t\tbreak;\n\tcase DP_128b_132b_TPS1:\n\t\ttest_pattern = DP_TEST_PATTERN_128b_132b_TPS1_TRAINING_MODE;\n\t\tbreak;\n\tcase DP_128b_132b_TPS2:\n\t\ttest_pattern = DP_TEST_PATTERN_128b_132b_TPS2_TRAINING_MODE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdp_set_hw_test_pattern(link, link_res, test_pattern, NULL, 0);\n\n\treturn true;\n}\n\nstatic bool perform_post_lt_adj_req_sequence(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum dc_lane_count lane_count =\n\tlt_settings->link_settings.lane_count;\n\n\tuint32_t adj_req_count;\n\tuint32_t adj_req_timer;\n\tbool req_drv_setting_changed;\n\tuint32_t lane;\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\n\treq_drv_setting_changed = false;\n\tfor (adj_req_count = 0; adj_req_count < POST_LT_ADJ_REQ_LIMIT;\n\tadj_req_count++) {\n\n\t\treq_drv_setting_changed = false;\n\n\t\tfor (adj_req_timer = 0;\n\t\t\tadj_req_timer < POST_LT_ADJ_REQ_TIMEOUT;\n\t\t\tadj_req_timer++) {\n\n\t\t\tdp_get_lane_status_and_lane_adjust(\n\t\t\t\tlink,\n\t\t\t\tlt_settings,\n\t\t\t\tdpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated,\n\t\t\t\tdpcd_lane_adjust,\n\t\t\t\tDPRX);\n\n\t\t\tif (dpcd_lane_status_updated.bits.\n\t\t\t\t\tPOST_LT_ADJ_REQ_IN_PROGRESS == 0)\n\t\t\t\treturn true;\n\n\t\t\tif (!dp_is_cr_done(lane_count, dpcd_lane_status))\n\t\t\t\treturn false;\n\n\t\t\tif (!dp_is_ch_eq_done(lane_count, dpcd_lane_status) ||\n\t\t\t\t\t!dp_is_symbol_locked(lane_count, dpcd_lane_status) ||\n\t\t\t\t\t!dp_is_interlane_aligned(dpcd_lane_status_updated))\n\t\t\t\treturn false;\n\n\t\t\tfor (lane = 0; lane < (uint32_t)(lane_count); lane++) {\n\n\t\t\t\tif (lt_settings->\n\t\t\t\tdpcd_lane_settings[lane].bits.VOLTAGE_SWING_SET !=\n\t\t\t\tdpcd_lane_adjust[lane].bits.VOLTAGE_SWING_LANE ||\n\t\t\t\tlt_settings->dpcd_lane_settings[lane].bits.PRE_EMPHASIS_SET !=\n\t\t\t\tdpcd_lane_adjust[lane].bits.PRE_EMPHASIS_LANE) {\n\n\t\t\t\t\treq_drv_setting_changed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (req_drv_setting_changed) {\n\t\t\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\n\t\t\t\tdp_set_drive_settings(link,\n\t\t\t\t\t\tlink_res,\n\t\t\t\t\t\tlt_settings);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (!req_drv_setting_changed) {\n\t\t\tDC_LOG_WARNING(\"%s: Post Link Training Adjust Request Timed out\\n\",\n\t\t\t\t__func__);\n\n\t\t\tASSERT(0);\n\t\t\treturn true;\n\t\t}\n\t}\n\tDC_LOG_WARNING(\"%s: Post Link Training Adjust Request limit reached\\n\",\n\t\t__func__);\n\n\tASSERT(0);\n\treturn true;\n\n}\n\nstatic enum link_training_result dp_transition_to_video_idle(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tstruct link_training_settings *lt_settings,\n\tenum link_training_result status)\n{\n\tunion lane_count_set lane_count_set = {0};\n\n\t \n\tdp_set_hw_test_pattern(link, link_res, DP_TEST_PATTERN_VIDEO_MODE, NULL, 0);\n\n\t \n\tif (link->dpcd_caps.max_ln_count.bits.POST_LT_ADJ_REQ_SUPPORTED != 1 ||\n\t\t\tlt_settings->pattern_for_eq >= DP_TRAINING_PATTERN_SEQUENCE_4) {\n\t\t \n\t\tif (link->connector_signal != SIGNAL_TYPE_EDP && status == LINK_TRAINING_SUCCESS) {\n\t\t\tmsleep(5);\n\t\t\tstatus = dp_check_link_loss_status(link, lt_settings);\n\t\t}\n\t\treturn status;\n\t}\n\n\tif (status == LINK_TRAINING_SUCCESS &&\n\t\tperform_post_lt_adj_req_sequence(link, link_res, lt_settings) == false)\n\t\tstatus = LINK_TRAINING_LQA_FAIL;\n\n\tlane_count_set.bits.LANE_COUNT_SET = lt_settings->link_settings.lane_count;\n\tlane_count_set.bits.ENHANCED_FRAMING = lt_settings->enhanced_framing;\n\tlane_count_set.bits.POST_LT_ADJ_REQ_GRANTED = 0;\n\n\tcore_link_write_dpcd(\n\t\tlink,\n\t\tDP_LANE_COUNT_SET,\n\t\t&lane_count_set.raw,\n\t\tsizeof(lane_count_set));\n\n\treturn status;\n}\n\nenum link_training_result dp_perform_link_training(\n\tstruct dc_link *link,\n\tconst struct link_resource *link_res,\n\tconst struct dc_link_settings *link_settings,\n\tbool skip_video_pattern)\n{\n\tenum link_training_result status = LINK_TRAINING_SUCCESS;\n\tstruct link_training_settings lt_settings = {0};\n\tenum dp_link_encoding encoding =\n\t\t\tlink_dp_get_encoding_format(link_settings);\n\n\t \n\tdp_decide_training_settings(\n\t\t\tlink,\n\t\t\tlink_settings,\n\t\t\t&lt_settings);\n\n\toverride_training_settings(\n\t\t\tlink,\n\t\t\t&link->preferred_training_settings,\n\t\t\t&lt_settings);\n\n\t \n\tdpcd_exit_training_mode(link, encoding);\n\n\t \n\tdpcd_configure_lttpr_mode(link, &lt_settings);\n\tdp_set_fec_ready(link, link_res, lt_settings.should_set_fec_ready);\n\tdpcd_configure_channel_coding(link, &lt_settings);\n\n\t \n\tif ((link->chip_caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN) && encoding == DP_8b_10b_ENCODING)\n\t\tif (link->dc->config.use_old_fixed_vs_sequence)\n\t\t\tstatus = dp_perform_fixed_vs_pe_training_sequence_legacy(link, link_res, &lt_settings);\n\t\telse\n\t\t\tstatus = dp_perform_fixed_vs_pe_training_sequence(link, link_res, &lt_settings);\n\telse if (encoding == DP_8b_10b_ENCODING)\n\t\tstatus = dp_perform_8b_10b_link_training(link, link_res, &lt_settings);\n\telse if (encoding == DP_128b_132b_ENCODING)\n\t\tstatus = dp_perform_128b_132b_link_training(link, link_res, &lt_settings);\n\telse\n\t\tASSERT(0);\n\n\t \n\tdpcd_exit_training_mode(link, encoding);\n\n\t \n\tif ((status == LINK_TRAINING_SUCCESS) || !skip_video_pattern)\n\t\tstatus = dp_transition_to_video_idle(link,\n\t\t\t\tlink_res,\n\t\t\t\t&lt_settings,\n\t\t\t\tstatus);\n\n\t \n\tdp_log_training_result(link, &lt_settings, status);\n\tif (status != LINK_TRAINING_SUCCESS)\n\t\tlink->ctx->dc->debug_data.ltFailCount++;\n\treturn status;\n}\n\nbool perform_link_training_with_retries(\n\tconst struct dc_link_settings *link_setting,\n\tbool skip_video_pattern,\n\tint attempts,\n\tstruct pipe_ctx *pipe_ctx,\n\tenum signal_type signal,\n\tbool do_fallback)\n{\n\tint j;\n\tuint8_t delay_between_attempts = LINK_TRAINING_RETRY_DELAY;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tenum dp_panel_mode panel_mode = dp_get_panel_mode(link);\n\tenum link_training_result status = LINK_TRAINING_CR_FAIL_LANE0;\n\tstruct dc_link_settings cur_link_settings = *link_setting;\n\tstruct dc_link_settings max_link_settings = *link_setting;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tint fail_count = 0;\n\tbool is_link_bw_low = false;  \n\tbool is_link_bw_min =  \n\t\t(cur_link_settings.link_rate <= LINK_RATE_LOW) &&\n\t\t(cur_link_settings.lane_count <= LANE_COUNT_ONE);\n\n\tdp_trace_commit_lt_init(link);\n\n\n\tif (link_dp_get_encoding_format(&cur_link_settings) == DP_8b_10b_ENCODING)\n\t\t \n\t\tlink_hwss->setup_stream_encoder(pipe_ctx);\n\n\tdp_trace_set_lt_start_timestamp(link, false);\n\tj = 0;\n\twhile (j < attempts && fail_count < (attempts * 10)) {\n\n\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Beginning link(%d) training attempt %u of %d @ rate(%d) x lane(%d) @ spread = %x\\n\",\n\t\t\t\t\t__func__, link->link_index, (unsigned int)j + 1, attempts,\n\t\t\t\t       cur_link_settings.link_rate, cur_link_settings.lane_count,\n\t\t\t\t       cur_link_settings.link_spread);\n\n\t\tdp_enable_link_phy(\n\t\t\tlink,\n\t\t\t&pipe_ctx->link_res,\n\t\t\tsignal,\n\t\t\tpipe_ctx->clock_source->id,\n\t\t\t&cur_link_settings);\n\n\t\tif (stream->sink_patches.dppowerup_delay > 0) {\n\t\t\tint delay_dp_power_up_in_ms = stream->sink_patches.dppowerup_delay;\n\n\t\t\tmsleep(delay_dp_power_up_in_ms);\n\t\t}\n\n\t\tif (panel_mode == DP_PANEL_MODE_EDP) {\n\t\t\tstruct cp_psp *cp_psp = &stream->ctx->cp_psp;\n\n\t\t\tif (cp_psp && cp_psp->funcs.enable_assr) {\n\t\t\t\t \n\t\t\t\tbool result;\n\t\t\t\tresult = cp_psp->funcs.enable_assr(cp_psp->handle, link);\n\t\t\t\tif (!result && link->panel_mode != DP_PANEL_MODE_EDP)\n\t\t\t\t\tpanel_mode = DP_PANEL_MODE_DEFAULT;\n\t\t\t}\n\t\t}\n\n\t\tdp_set_panel_mode(link, panel_mode);\n\n\t\tif (link->aux_access_disabled) {\n\t\t\tdp_perform_link_training_skip_aux(link, &pipe_ctx->link_res, &cur_link_settings);\n\t\t\treturn true;\n\t\t} else {\n\t\t\t \n\t\t\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA) {\n\t\t\t\tstatus = dpia_perform_link_training(\n\t\t\t\t\t\tlink,\n\t\t\t\t\t\t&pipe_ctx->link_res,\n\t\t\t\t\t\t&cur_link_settings,\n\t\t\t\t\t\tskip_video_pattern);\n\n\t\t\t\t \n\t\t\t\tif (status == LINK_TRAINING_SUCCESS && !is_link_bw_low) {\n\t\t\t\t\tdp_set_hw_test_pattern(link, &pipe_ctx->link_res, DP_TEST_PATTERN_VIDEO_MODE, NULL, 0);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\t\t\t\t\tlink->verified_link_cap.link_rate = link->cur_link_settings.link_rate;\n\t\t\t\t\t\tlink->verified_link_cap.lane_count = link->cur_link_settings.lane_count;\n\t\t\t\t\t\tdm_helpers_dp_mst_update_branch_bandwidth(link->ctx, link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus = dp_perform_link_training(\n\t\t\t\t\t\tlink,\n\t\t\t\t\t\t&pipe_ctx->link_res,\n\t\t\t\t\t\t&cur_link_settings,\n\t\t\t\t\t\tskip_video_pattern);\n\t\t\t}\n\n\t\t\tdp_trace_lt_total_count_increment(link, false);\n\t\t\tdp_trace_lt_result_update(link, status, false);\n\t\t\tdp_trace_set_lt_end_timestamp(link, false);\n\t\t\tif (status == LINK_TRAINING_SUCCESS && !is_link_bw_low)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tfail_count++;\n\t\tdp_trace_lt_fail_count_update(link, fail_count, false);\n\t\tif (link->ep_type == DISPLAY_ENDPOINT_PHY) {\n\t\t\t \n\t\t\tif (j == (attempts - 1) || (status == LINK_TRAINING_ABORT))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == (attempts - 1)) {\n\t\t\tDC_LOG_WARNING(\n\t\t\t\t\"%s: Link(%d) training attempt %u of %d failed @ rate(%d) x lane(%d) @ spread = %x : fail reason:(%d)\\n\",\n\t\t\t\t__func__, link->link_index, (unsigned int)j + 1, attempts,\n\t\t\t\tcur_link_settings.link_rate, cur_link_settings.lane_count,\n\t\t\t\tcur_link_settings.link_spread, status);\n\t\t} else {\n\t\t\tDC_LOG_HW_LINK_TRAINING(\n\t\t\t\t\"%s: Link(%d) training attempt %u of %d failed @ rate(%d) x lane(%d) @ spread = %x : fail reason:(%d)\\n\",\n\t\t\t\t__func__, link->link_index, (unsigned int)j + 1, attempts,\n\t\t\t\tcur_link_settings.link_rate, cur_link_settings.lane_count,\n\t\t\t\tcur_link_settings.link_spread, status);\n\t\t}\n\n\t\tdp_disable_link_phy(link, &pipe_ctx->link_res, signal);\n\n\t\t \n\t\tif (status == LINK_TRAINING_ABORT) {\n\t\t\tenum dc_connection_type type = dc_connection_none;\n\n\t\t\tlink_detect_connection_type(link, &type);\n\t\t\tif (type == dc_connection_none) {\n\t\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Aborting training because sink unplugged\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!do_fallback || (status == LINK_TRAINING_ABORT) ||\n\t\t\t\t(status == LINK_TRAINING_SUCCESS && is_link_bw_low) ||\n\t\t\t\tis_link_bw_min) {\n\t\t\tj++;\n\t\t\tcur_link_settings = *link_setting;\n\t\t\tdelay_between_attempts += LINK_TRAINING_RETRY_DELAY;\n\t\t\tis_link_bw_low = false;\n\t\t\tis_link_bw_min = (cur_link_settings.link_rate <= LINK_RATE_LOW) &&\n\t\t\t\t(cur_link_settings.lane_count <= LANE_COUNT_ONE);\n\n\t\t} else if (do_fallback) {  \n\t\t\tuint32_t req_bw;\n\t\t\tuint32_t link_bw;\n\t\t\tenum dc_link_encoding_format link_encoding = DC_LINK_ENCODING_UNSPECIFIED;\n\n\t\t\tdecide_fallback_link_setting(link, &max_link_settings,\n\t\t\t\t\t&cur_link_settings, status);\n\n\t\t\tif (link_dp_get_encoding_format(&cur_link_settings) == DP_8b_10b_ENCODING)\n\t\t\t\tlink_encoding = DC_LINK_ENCODING_DP_8b_10b;\n\t\t\telse if (link_dp_get_encoding_format(&cur_link_settings) == DP_128b_132b_ENCODING)\n\t\t\t\tlink_encoding = DC_LINK_ENCODING_DP_128b_132b;\n\n\t\t\t \n\t\t\treq_bw = dc_bandwidth_in_kbps_from_timing(&stream->timing, link_encoding);\n\t\t\tlink_bw = dp_link_bandwidth_kbps(link, &cur_link_settings);\n\t\t\tis_link_bw_low = (req_bw > link_bw);\n\t\t\tis_link_bw_min = ((cur_link_settings.link_rate <= LINK_RATE_LOW) &&\n\t\t\t\t(cur_link_settings.lane_count <= LANE_COUNT_ONE));\n\n\t\t\tif (is_link_bw_low)\n\t\t\t\tDC_LOG_WARNING(\n\t\t\t\t\t\"%s: Link(%d) bandwidth too low after fallback req_bw(%d) > link_bw(%d)\\n\",\n\t\t\t\t\t__func__, link->link_index, req_bw, link_bw);\n\t\t}\n\n\t\tmsleep(delay_between_attempts);\n\t}\n\n\treturn false;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}