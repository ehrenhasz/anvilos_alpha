{
  "module_name": "dcn31_smu.c",
  "hash_id": "4a09509c0efb92aea765d992d47826e5bbeb3f53e898de6040fffd48ac67b7e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn31/dcn31_smu.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include \"core_types.h\"\n#include \"clk_mgr_internal.h\"\n#include \"reg_helper.h\"\n#include \"dm_helpers.h\"\n#include \"dcn31_smu.h\"\n\n#include \"yellow_carp_offset.h\"\n#include \"mp/mp_13_0_2_offset.h\"\n#include \"mp/mp_13_0_2_sh_mask.h\"\n\n#define REG(reg_name) \\\n\t(MP0_BASE.instance[0].segment[reg ## reg_name ## _BASE_IDX] + reg ## reg_name)\n\n#define FN(reg_name, field) \\\n\tFD(reg_name##__##field)\n\n#include \"logger_types.h\"\n#undef DC_LOGGER\n#define DC_LOGGER \\\n\tCTX->logger\n#define smu_print(str, ...) {DC_LOG_SMU(str, ##__VA_ARGS__); }\n\n#define VBIOSSMC_MSG_TestMessage                  0x1\n#define VBIOSSMC_MSG_GetSmuVersion                0x2\n#define VBIOSSMC_MSG_PowerUpGfx                   0x3\n#define VBIOSSMC_MSG_SetDispclkFreq               0x4\n#define VBIOSSMC_MSG_SetDprefclkFreq              0x5   \n#define VBIOSSMC_MSG_SetDppclkFreq                0x6\n#define VBIOSSMC_MSG_SetHardMinDcfclkByFreq       0x7\n#define VBIOSSMC_MSG_SetMinDeepSleepDcfclk        0x8\n#define VBIOSSMC_MSG_SetPhyclkVoltageByFreq       0x9\t\n#define VBIOSSMC_MSG_GetFclkFrequency             0xA\n#define VBIOSSMC_MSG_SetDisplayCount              0xB   \n#define VBIOSSMC_MSG_EnableTmdp48MHzRefclkPwrDown 0xC   \n#define VBIOSSMC_MSG_UpdatePmeRestore             0xD\n#define VBIOSSMC_MSG_SetVbiosDramAddrHigh         0xE   \n#define VBIOSSMC_MSG_SetVbiosDramAddrLow          0xF\n#define VBIOSSMC_MSG_TransferTableSmu2Dram        0x10\n#define VBIOSSMC_MSG_TransferTableDram2Smu        0x11\n#define VBIOSSMC_MSG_SetDisplayIdleOptimizations  0x12\n#define VBIOSSMC_MSG_GetDprefclkFreq              0x13\n#define VBIOSSMC_MSG_GetDtbclkFreq                0x14\n#define VBIOSSMC_MSG_AllowZstatesEntry            0x15\n#define VBIOSSMC_MSG_DisallowZstatesEntry     \t  0x16\n#define VBIOSSMC_MSG_SetDtbClk                    0x17\n#define VBIOSSMC_Message_Count                    0x18\n\n#define VBIOSSMC_Status_BUSY                      0x0\n#define VBIOSSMC_Result_OK                        0x1\n#define VBIOSSMC_Result_Failed                    0xFF\n#define VBIOSSMC_Result_UnknownCmd                0xFE\n#define VBIOSSMC_Result_CmdRejectedPrereq         0xFD\n#define VBIOSSMC_Result_CmdRejectedBusy           0xFC\n\n \nstatic uint32_t dcn31_smu_wait_for_response(struct clk_mgr_internal *clk_mgr, unsigned int delay_us, unsigned int max_retries)\n{\n\tuint32_t res_val = VBIOSSMC_Status_BUSY;\n\n\tdo {\n\t\tres_val = REG_READ(MP1_SMN_C2PMSG_91);\n\t\tif (res_val != VBIOSSMC_Status_BUSY)\n\t\t\tbreak;\n\n\t\tif (delay_us >= 1000)\n\t\t\tmsleep(delay_us/1000);\n\t\telse if (delay_us > 0)\n\t\t\tudelay(delay_us);\n\t} while (max_retries--);\n\n\treturn res_val;\n}\n\nstatic int dcn31_smu_send_msg_with_param(struct clk_mgr_internal *clk_mgr,\n\t\t\t\t\t unsigned int msg_id,\n\t\t\t\t\t unsigned int param)\n{\n\tuint32_t result;\n\n\tresult = dcn31_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tif (result != VBIOSSMC_Result_OK)\n\t\tsmu_print(\"SMU Response was not OK. SMU response after wait received is: %d\\n\", result);\n\n\tif (result == VBIOSSMC_Status_BUSY) {\n\t\treturn -1;\n\t}\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_91, VBIOSSMC_Status_BUSY);\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_83, param);\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_67, msg_id);\n\n\tresult = dcn31_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tif (result == VBIOSSMC_Result_Failed) {\n\t\tif (msg_id == VBIOSSMC_MSG_TransferTableDram2Smu &&\n\t\t    param == TABLE_WATERMARKS)\n\t\t\tDC_LOG_DEBUG(\"Watermarks table not configured properly by SMU\");\n\t\telse\n\t\t\tASSERT(0);\n\t\tREG_WRITE(MP1_SMN_C2PMSG_91, VBIOSSMC_Result_OK);\n\t\treturn -1;\n\t}\n\n\tif (IS_SMU_TIMEOUT(result)) {\n\t\tASSERT(0);\n\t\tdm_helpers_smu_timeout(CTX, msg_id, param, 10 * 200000);\n\t}\n\n\treturn REG_READ(MP1_SMN_C2PMSG_83);\n}\n\nint dcn31_smu_get_smu_version(struct clk_mgr_internal *clk_mgr)\n{\n\treturn dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_GetSmuVersion,\n\t\t\t0);\n}\n\n\nint dcn31_smu_set_dispclk(struct clk_mgr_internal *clk_mgr, int requested_dispclk_khz)\n{\n\tint actual_dispclk_set_mhz = -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dispclk_khz;\n\n\t \n\tactual_dispclk_set_mhz = dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDispclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dispclk_khz));\n\n\treturn actual_dispclk_set_mhz * 1000;\n}\n\nint dcn31_smu_set_dprefclk(struct clk_mgr_internal *clk_mgr)\n{\n\tint actual_dprefclk_set_mhz = -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn clk_mgr->base.dprefclk_khz;\n\n\tactual_dprefclk_set_mhz = dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDprefclkFreq,\n\t\t\tkhz_to_mhz_ceil(clk_mgr->base.dprefclk_khz));\n\n\t \n\n\treturn actual_dprefclk_set_mhz * 1000;\n}\n\nint dcn31_smu_set_hard_min_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_dcfclk_khz)\n{\n\tint actual_dcfclk_set_mhz = -1;\n\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dcfclk_khz;\n\n\tactual_dcfclk_set_mhz = dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetHardMinDcfclkByFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dcfclk_khz));\n\n#ifdef DBG\n\tsmu_print(\"actual_dcfclk_set_mhz %d is set to : %d\\n\", actual_dcfclk_set_mhz, actual_dcfclk_set_mhz * 1000);\n#endif\n\n\treturn actual_dcfclk_set_mhz * 1000;\n}\n\nint dcn31_smu_set_min_deep_sleep_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_min_ds_dcfclk_khz)\n{\n\tint actual_min_ds_dcfclk_mhz = -1;\n\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_min_ds_dcfclk_khz;\n\n\tactual_min_ds_dcfclk_mhz = dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetMinDeepSleepDcfclk,\n\t\t\tkhz_to_mhz_ceil(requested_min_ds_dcfclk_khz));\n\n\treturn actual_min_ds_dcfclk_mhz * 1000;\n}\n\nint dcn31_smu_set_dppclk(struct clk_mgr_internal *clk_mgr, int requested_dpp_khz)\n{\n\tint actual_dppclk_set_mhz = -1;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn requested_dpp_khz;\n\n\tactual_dppclk_set_mhz = dcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDppclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dpp_khz));\n\n\treturn actual_dppclk_set_mhz * 1000;\n}\n\nvoid dcn31_smu_set_display_idle_optimization(struct clk_mgr_internal *clk_mgr, uint32_t idle_info)\n{\n\tif (!clk_mgr->base.ctx->dc->debug.pstate_enabled)\n\t\treturn;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\t\n\tdcn31_smu_send_msg_with_param(\n\t\tclk_mgr,\n\t\tVBIOSSMC_MSG_SetDisplayIdleOptimizations,\n\t\tidle_info);\n}\n\nvoid dcn31_smu_enable_phy_refclk_pwrdwn(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tunion display_idle_optimization_u idle_info = { 0 };\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (enable) {\n\t\tidle_info.idle_info.df_request_disabled = 1;\n\t\tidle_info.idle_info.phy_ref_clk_off = 1;\n\t}\n\n\tdcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDisplayIdleOptimizations,\n\t\t\tidle_info.data);\n}\n\nvoid dcn31_smu_enable_pme_wa(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_UpdatePmeRestore,\n\t\t\t0);\n}\n\nvoid dcn31_smu_set_dram_addr_high(struct clk_mgr_internal *clk_mgr, uint32_t addr_high)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_SetVbiosDramAddrHigh, addr_high);\n}\n\nvoid dcn31_smu_set_dram_addr_low(struct clk_mgr_internal *clk_mgr, uint32_t addr_low)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_SetVbiosDramAddrLow, addr_low);\n}\n\nvoid dcn31_smu_transfer_dpm_table_smu_2_dram(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_TransferTableSmu2Dram, TABLE_DPMCLOCKS);\n}\n\nvoid dcn31_smu_transfer_wm_table_dram_2_smu(struct clk_mgr_internal *clk_mgr)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(clk_mgr,\n\t\t\tVBIOSSMC_MSG_TransferTableDram2Smu, TABLE_WATERMARKS);\n}\n\nvoid dcn31_smu_set_zstate_support(struct clk_mgr_internal *clk_mgr, enum dcn_zstate_support_state support)\n{\n\tunsigned int msg_id, param;\n\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tif (!clk_mgr->base.ctx->dc->debug.enable_z9_disable_interface &&\n\t\t\t(support == DCN_ZSTATE_SUPPORT_ALLOW_Z10_ONLY))\n\t\tsupport = DCN_ZSTATE_SUPPORT_DISALLOW;\n\n\tif (support == DCN_ZSTATE_SUPPORT_ALLOW_Z10_ONLY ||\n\t    support == DCN_ZSTATE_SUPPORT_ALLOW_Z8_Z10_ONLY)\n\t\tparam = 1;\n\telse\n\t\tparam = 0;\n\n\tif (support == DCN_ZSTATE_SUPPORT_DISALLOW)\n\t\tmsg_id = VBIOSSMC_MSG_DisallowZstatesEntry;\n\telse\n\t\tmsg_id = VBIOSSMC_MSG_AllowZstatesEntry;\n\n\tdcn31_smu_send_msg_with_param(\n\t\tclk_mgr,\n\t\tmsg_id,\n\t\tparam);\n\n}\n\n \nvoid dcn31_smu_set_dtbclk(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tif (!clk_mgr->smu_present)\n\t\treturn;\n\n\tdcn31_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDtbClk,\n\t\t\tenable);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}