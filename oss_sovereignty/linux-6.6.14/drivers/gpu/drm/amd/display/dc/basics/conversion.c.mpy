{
  "module_name": "conversion.c",
  "hash_id": "db17b95deaa0a08e98cfb6c85da61716c8af58dc1999e363eb68d5c8d7b57717",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/basics/conversion.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"basics/conversion.h\"\n\n#define DIVIDER 10000\n\n \n#define S2D13_MIN (-3 * DIVIDER)\n#define S2D13_MAX (3 * DIVIDER)\n\nuint16_t fixed_point_to_int_frac(\n\tstruct fixed31_32 arg,\n\tuint8_t integer_bits,\n\tuint8_t fractional_bits)\n{\n\tint32_t numerator;\n\tint32_t divisor = 1 << fractional_bits;\n\n\tuint16_t result;\n\n\tuint16_t d = (uint16_t)dc_fixpt_floor(\n\t\tdc_fixpt_abs(\n\t\t\targ));\n\n\tif (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))\n\t\tnumerator = (uint16_t)dc_fixpt_round(\n\t\t\tdc_fixpt_mul_int(\n\t\t\t\targ,\n\t\t\t\tdivisor));\n\telse {\n\t\tnumerator = dc_fixpt_floor(\n\t\t\tdc_fixpt_sub(\n\t\t\t\tdc_fixpt_from_int(\n\t\t\t\t\t1LL << integer_bits),\n\t\t\t\tdc_fixpt_recip(\n\t\t\t\t\tdc_fixpt_from_int(\n\t\t\t\t\t\tdivisor))));\n\t}\n\n\tif (numerator >= 0)\n\t\tresult = (uint16_t)numerator;\n\telse\n\t\tresult = (uint16_t)(\n\t\t(1 << (integer_bits + fractional_bits + 1)) + numerator);\n\n\tif ((result != 0) && dc_fixpt_lt(\n\t\targ, dc_fixpt_zero))\n\t\tresult |= 1 << (integer_bits + fractional_bits);\n\n\treturn result;\n}\n \nvoid convert_float_matrix(\n\tuint16_t *matrix,\n\tstruct fixed31_32 *flt,\n\tuint32_t buffer_size)\n{\n\tconst struct fixed31_32 min_2_13 =\n\t\tdc_fixpt_from_fraction(S2D13_MIN, DIVIDER);\n\tconst struct fixed31_32 max_2_13 =\n\t\tdc_fixpt_from_fraction(S2D13_MAX, DIVIDER);\n\tuint32_t i;\n\n\tfor (i = 0; i < buffer_size; ++i) {\n\t\tuint32_t reg_value =\n\t\t\t\tfixed_point_to_int_frac(\n\t\t\t\t\tdc_fixpt_clamp(\n\t\t\t\t\t\tflt[i],\n\t\t\t\t\t\tmin_2_13,\n\t\t\t\t\t\tmax_2_13),\n\t\t\t\t\t\t2,\n\t\t\t\t\t\t13);\n\n\t\tmatrix[i] = (uint16_t)reg_value;\n\t}\n}\n\nstatic uint32_t find_gcd(uint32_t a, uint32_t b)\n{\n\tuint32_t remainder = 0;\n\twhile (b != 0) {\n\t\tremainder = a % b;\n\t\ta = b;\n\t\tb = remainder;\n\t}\n\treturn a;\n}\n\nvoid reduce_fraction(uint32_t num, uint32_t den,\n\t\tuint32_t *out_num, uint32_t *out_den)\n{\n\tuint32_t gcd = 0;\n\n\tgcd = find_gcd(num, den);\n\t*out_num = num / gcd;\n\t*out_den = den / gcd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}