{
  "module_name": "dcn32_dccg.c",
  "hash_id": "1afa29126aa8423963edfaba218ff16340200304c670fc57d24769562ada4b80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_dccg.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dcn32_dccg.h\"\n\n#define TO_DCN_DCCG(dccg)\\\n\tcontainer_of(dccg, struct dcn_dccg, base)\n\n#define REG(reg) \\\n\t(dccg_dcn->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name\n\n#define CTX \\\n\tdccg_dcn->base.ctx\n#define DC_LOGGER \\\n\tdccg->ctx->logger\n\nstatic void dccg32_trigger_dio_fifo_resync(\n\tstruct dccg *dccg)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tuint32_t dispclk_rdivider_value = 0;\n\n\tREG_GET(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_RDIVIDER, &dispclk_rdivider_value);\n\n\t \n\tif (dispclk_rdivider_value != 0)\n\t\tREG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER, dispclk_rdivider_value);\n}\n\nstatic void dccg32_get_pixel_rate_div(\n\t\tstruct dccg *dccg,\n\t\tuint32_t otg_inst,\n\t\tenum pixel_rate_div *k1,\n\t\tenum pixel_rate_div *k2)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tuint32_t val_k1 = PIXEL_RATE_DIV_NA, val_k2 = PIXEL_RATE_DIV_NA;\n\n\t*k1 = PIXEL_RATE_DIV_NA;\n\t*k2 = PIXEL_RATE_DIV_NA;\n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG0_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG0_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 1:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG1_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG1_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 2:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG2_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG2_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tcase 3:\n\t\tREG_GET_2(OTG_PIXEL_RATE_DIV,\n\t\t\tOTG3_PIXEL_RATE_DIVK1, &val_k1,\n\t\t\tOTG3_PIXEL_RATE_DIVK2, &val_k2);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t*k1 = (enum pixel_rate_div)val_k1;\n\t*k2 = (enum pixel_rate_div)val_k2;\n}\n\nstatic void dccg32_set_pixel_rate_div(\n\t\tstruct dccg *dccg,\n\t\tuint32_t otg_inst,\n\t\tenum pixel_rate_div k1,\n\t\tenum pixel_rate_div k2)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tenum pixel_rate_div cur_k1 = PIXEL_RATE_DIV_NA, cur_k2 = PIXEL_RATE_DIV_NA;\n\n\t\n\t\n\tif (k1 == PIXEL_RATE_DIV_NA || k2 == PIXEL_RATE_DIV_NA) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tdccg32_get_pixel_rate_div(dccg, otg_inst, &cur_k1, &cur_k2);\n\tif (k1 == cur_k1 && k2 == cur_k2)\n\t\treturn;\n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG0_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG0_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG1_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG1_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG2_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG2_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_DIV,\n\t\t\t\tOTG3_PIXEL_RATE_DIVK1, k1,\n\t\t\t\tOTG3_PIXEL_RATE_DIVK2, k2);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n\nstatic void dccg32_set_dtbclk_p_src(\n\t\tstruct dccg *dccg,\n\t\tenum streamclk_source src,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tuint32_t p_src_sel = 0;  \n\tif (src == DTBCLK0)\n\t\tp_src_sel = 2;   \n\n\tswitch (otg_inst) {\n\tcase 0:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P0_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P0_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P0_EN, 1);\n\t\tbreak;\n\tcase 1:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P1_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P1_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P1_EN, 1);\n\t\tbreak;\n\tcase 2:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P2_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P2_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P2_EN, 1);\n\t\tbreak;\n\tcase 3:\n\t\tif (src == REFCLK)\n\t\t\tREG_UPDATE(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P3_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE_2(DTBCLK_P_CNTL,\n\t\t\t\t\tDTBCLK_P3_SRC_SEL, p_src_sel,\n\t\t\t\t\tDTBCLK_P3_EN, 1);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n}\n\n \nstatic void dccg32_set_dtbclk_dto(\n\t\tstruct dccg *dccg,\n\t\tconst struct dtbclk_dto_params *params)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\t \n\tint req_dtbclk_khz = params->pixclk_khz / 4;\n\n\tif (params->ref_dtbclk_khz && req_dtbclk_khz) {\n\t\tuint32_t modulo, phase;\n\n\t\t\n\t\tmodulo = params->ref_dtbclk_khz * 1000;\n\t\tphase = req_dtbclk_khz * 1000;\n\n\t\tREG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], modulo);\n\t\tREG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], phase);\n\n\t\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLK_DTO_ENABLE[params->otg_inst], 1);\n\n\t\tREG_WAIT(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLKDTO_ENABLE_STATUS[params->otg_inst], 1,\n\t\t\t\t1, 100);\n\n\t\t \n\t\tdccg32_set_pixel_rate_div(dccg, params->otg_inst, PIXEL_RATE_DIV_BY_1, PIXEL_RATE_DIV_BY_1);\n\n\t\t \n\t\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tPIPE_DTO_SRC_SEL[params->otg_inst], 2);\n\t} else {\n\t\tREG_UPDATE_2(OTG_PIXEL_RATE_CNTL[params->otg_inst],\n\t\t\t\tDTBCLK_DTO_ENABLE[params->otg_inst], 0,\n\t\t\t\tPIPE_DTO_SRC_SEL[params->otg_inst], params->is_hdmi ? 0 : 1);\n\t\tREG_WRITE(DTBCLK_DTO_MODULO[params->otg_inst], 0);\n\t\tREG_WRITE(DTBCLK_DTO_PHASE[params->otg_inst], 0);\n\t}\n}\n\nstatic void dccg32_set_valid_pixel_rate(\n\t\tstruct dccg *dccg,\n\t\tint ref_dtbclk_khz,\n\t\tint otg_inst,\n\t\tint pixclk_khz)\n{\n\tstruct dtbclk_dto_params dto_params = {0};\n\n\tdto_params.ref_dtbclk_khz = ref_dtbclk_khz;\n\tdto_params.otg_inst = otg_inst;\n\tdto_params.pixclk_khz = pixclk_khz;\n\tdto_params.is_hdmi = true;\n\n\tdccg32_set_dtbclk_dto(dccg, &dto_params);\n}\n\nstatic void dccg32_get_dccg_ref_freq(struct dccg *dccg,\n\t\tunsigned int xtalin_freq_inKhz,\n\t\tunsigned int *dccg_ref_freq_inKhz)\n{\n\t \n\t*dccg_ref_freq_inKhz = xtalin_freq_inKhz;\n\treturn;\n}\n\nstatic void dccg32_set_dpstreamclk(\n\t\tstruct dccg *dccg,\n\t\tenum streamclk_source src,\n\t\tint otg_inst,\n\t\tint dp_hpo_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\t \n\t \n\tdccg32_set_dtbclk_p_src(dccg, DTBCLK0, otg_inst);\n\n\t \n\tswitch (dp_hpo_inst) {\n\tcase 0:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL,\n\t\t\t     DPSTREAMCLK0_EN,\n\t\t\t     (src == REFCLK) ? 0 : 1, DPSTREAMCLK0_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK1_EN,\n\t\t\t     (src == REFCLK) ? 0 : 1, DPSTREAMCLK1_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK2_EN,\n\t\t\t     (src == REFCLK) ? 0 : 1, DPSTREAMCLK2_SRC_SEL, otg_inst);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_2(DPSTREAMCLK_CNTL, DPSTREAMCLK3_EN,\n\t\t\t     (src == REFCLK) ? 0 : 1, DPSTREAMCLK3_SRC_SEL, otg_inst);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n\nstatic void dccg32_otg_add_pixel(struct dccg *dccg,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_ADD_PIXEL[otg_inst], 1);\n}\n\nstatic void dccg32_otg_drop_pixel(struct dccg *dccg,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_DROP_PIXEL[otg_inst], 1);\n}\n\nstatic const struct dccg_funcs dccg32_funcs = {\n\t.update_dpp_dto = dccg2_update_dpp_dto,\n\t.get_dccg_ref_freq = dccg32_get_dccg_ref_freq,\n\t.dccg_init = dccg31_init,\n\t.set_dpstreamclk = dccg32_set_dpstreamclk,\n\t.enable_symclk32_se = dccg31_enable_symclk32_se,\n\t.disable_symclk32_se = dccg31_disable_symclk32_se,\n\t.enable_symclk32_le = dccg31_enable_symclk32_le,\n\t.disable_symclk32_le = dccg31_disable_symclk32_le,\n\t.set_physymclk = dccg31_set_physymclk,\n\t.set_dtbclk_dto = dccg32_set_dtbclk_dto,\n\t.set_valid_pixel_rate = dccg32_set_valid_pixel_rate,\n\t.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,\n\t.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,\n\t.otg_add_pixel = dccg32_otg_add_pixel,\n\t.otg_drop_pixel = dccg32_otg_drop_pixel,\n\t.set_pixel_rate_div = dccg32_set_pixel_rate_div,\n\t.trigger_dio_fifo_resync = dccg32_trigger_dio_fifo_resync,\n};\n\nstruct dccg *dccg32_create(\n\tstruct dc_context *ctx,\n\tconst struct dccg_registers *regs,\n\tconst struct dccg_shift *dccg_shift,\n\tconst struct dccg_mask *dccg_mask)\n{\n\tstruct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);\n\tstruct dccg *base;\n\n\tif (dccg_dcn == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tbase = &dccg_dcn->base;\n\tbase->ctx = ctx;\n\tbase->funcs = &dccg32_funcs;\n\n\tdccg_dcn->regs = regs;\n\tdccg_dcn->dccg_shift = dccg_shift;\n\tdccg_dcn->dccg_mask = dccg_mask;\n\n\treturn &dccg_dcn->base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}