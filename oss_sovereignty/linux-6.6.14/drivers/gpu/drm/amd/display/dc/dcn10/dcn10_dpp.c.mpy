{
  "module_name": "dcn10_dpp.c",
  "hash_id": "628f4be98467f21bac7bfb9e92eeebbcac0981eeb27a7183468e5215623a50ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"core_types.h\"\n\n#include \"reg_helper.h\"\n#include \"dcn10_dpp.h\"\n#include \"basics/conversion.h\"\n\n#define NUM_PHASES    64\n#define HORZ_MAX_TAPS 8\n#define VERT_MAX_TAPS 8\n\n#define BLACK_OFFSET_RGB_Y 0x0\n#define BLACK_OFFSET_CBCR  0x8000\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\nenum pixel_format_description {\n\tPIXEL_FORMAT_FIXED = 0,\n\tPIXEL_FORMAT_FIXED16,\n\tPIXEL_FORMAT_FLOAT\n\n};\n\nenum dcn10_coef_filter_type_sel {\n\tSCL_COEF_LUMA_VERT_FILTER = 0,\n\tSCL_COEF_LUMA_HORZ_FILTER = 1,\n\tSCL_COEF_CHROMA_VERT_FILTER = 2,\n\tSCL_COEF_CHROMA_HORZ_FILTER = 3,\n\tSCL_COEF_ALPHA_VERT_FILTER = 4,\n\tSCL_COEF_ALPHA_HORZ_FILTER = 5\n};\n\nenum dscl_autocal_mode {\n\tAUTOCAL_MODE_OFF = 0,\n\n\t \n\tAUTOCAL_MODE_AUTOSCALE = 1,\n\t \n\tAUTOCAL_MODE_AUTOCENTER = 2,\n\t \n\tAUTOCAL_MODE_AUTOREPLICATE = 3\n};\n\nenum dscl_mode_sel {\n\tDSCL_MODE_SCALING_444_BYPASS = 0,\n\tDSCL_MODE_SCALING_444_RGB_ENABLE = 1,\n\tDSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,\n\tDSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,\n\tDSCL_MODE_SCALING_420_LUMA_BYPASS = 4,\n\tDSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,\n\tDSCL_MODE_DSCL_BYPASS = 6\n};\n\nvoid dpp_read_state(struct dpp *dpp_base,\n\t\tstruct dcn_dpp_state *s)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_GET(DPP_CONTROL,\n\t\t\tDPP_CLOCK_ENABLE, &s->is_enabled);\n\tREG_GET(CM_IGAM_CONTROL,\n\t\t\tCM_IGAM_LUT_MODE, &s->igam_lut_mode);\n\tREG_GET(CM_IGAM_CONTROL,\n\t\t\tCM_IGAM_INPUT_FORMAT, &s->igam_input_format);\n\tREG_GET(CM_DGAM_CONTROL,\n\t\t\tCM_DGAM_LUT_MODE, &s->dgam_lut_mode);\n\tREG_GET(CM_RGAM_CONTROL,\n\t\t\tCM_RGAM_LUT_MODE, &s->rgam_lut_mode);\n\tREG_GET(CM_GAMUT_REMAP_CONTROL,\n\t\t\tCM_GAMUT_REMAP_MODE, &s->gamut_remap_mode);\n\n\tif (s->gamut_remap_mode) {\n\t\ts->gamut_remap_c11_c12 = REG_READ(CM_GAMUT_REMAP_C11_C12);\n\t\ts->gamut_remap_c13_c14 = REG_READ(CM_GAMUT_REMAP_C13_C14);\n\t\ts->gamut_remap_c21_c22 = REG_READ(CM_GAMUT_REMAP_C21_C22);\n\t\ts->gamut_remap_c23_c24 = REG_READ(CM_GAMUT_REMAP_C23_C24);\n\t\ts->gamut_remap_c31_c32 = REG_READ(CM_GAMUT_REMAP_C31_C32);\n\t\ts->gamut_remap_c33_c34 = REG_READ(CM_GAMUT_REMAP_C33_C34);\n\t}\n}\n\n#define IDENTITY_RATIO(ratio) (dc_fixpt_u2d19(ratio) == (1 << 19))\n\nbool dpp1_get_optimal_number_of_taps(\n\t\tstruct dpp *dpp,\n\t\tstruct scaler_data *scl_data,\n\t\tconst struct scaling_taps *in_taps)\n{\n\t \n\tif (scl_data->format == PIXEL_FORMAT_FP16 &&\n\t\tdpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&\n\t\tscl_data->ratios.horz.value != dc_fixpt_one.value &&\n\t\tscl_data->ratios.vert.value != dc_fixpt_one.value)\n\t\treturn false;\n\n\tif (scl_data->viewport.width > scl_data->h_active &&\n\t\tdpp->ctx->dc->debug.max_downscale_src_width != 0 &&\n\t\tscl_data->viewport.width > dpp->ctx->dc->debug.max_downscale_src_width)\n\t\treturn false;\n\n\t \n\n\t \n\tif (scl_data->ratios.horz.value == (4ll << 32))\n\t\tscl_data->ratios.horz.value--;\n\tif (scl_data->ratios.vert.value == (4ll << 32))\n\t\tscl_data->ratios.vert.value--;\n\tif (scl_data->ratios.horz_c.value == (4ll << 32))\n\t\tscl_data->ratios.horz_c.value--;\n\tif (scl_data->ratios.vert_c.value == (4ll << 32))\n\t\tscl_data->ratios.vert_c.value--;\n\n\t \n\tif (in_taps->h_taps == 0)\n\t\tscl_data->taps.h_taps = 4;\n\telse\n\t\tscl_data->taps.h_taps = in_taps->h_taps;\n\tif (in_taps->v_taps == 0)\n\t\tscl_data->taps.v_taps = 4;\n\telse\n\t\tscl_data->taps.v_taps = in_taps->v_taps;\n\tif (in_taps->v_taps_c == 0)\n\t\tscl_data->taps.v_taps_c = 2;\n\telse\n\t\tscl_data->taps.v_taps_c = in_taps->v_taps_c;\n\tif (in_taps->h_taps_c == 0)\n\t\tscl_data->taps.h_taps_c = 2;\n\t \n\telse if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)\n\t\tscl_data->taps.h_taps_c = in_taps->h_taps_c - 1;\n\telse\n\t\tscl_data->taps.h_taps_c = in_taps->h_taps_c;\n\n\tif (!dpp->ctx->dc->debug.always_scale) {\n\t\tif (IDENTITY_RATIO(scl_data->ratios.horz))\n\t\t\tscl_data->taps.h_taps = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.vert))\n\t\t\tscl_data->taps.v_taps = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.horz_c))\n\t\t\tscl_data->taps.h_taps_c = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.vert_c))\n\t\t\tscl_data->taps.v_taps_c = 1;\n\t}\n\n\treturn true;\n}\n\nvoid dpp_reset(struct dpp *dpp_base)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tdpp->filter_h_c = NULL;\n\tdpp->filter_v_c = NULL;\n\tdpp->filter_h = NULL;\n\tdpp->filter_v = NULL;\n\n\tmemset(&dpp->scl_data, 0, sizeof(dpp->scl_data));\n\tmemset(&dpp->pwl_data, 0, sizeof(dpp->pwl_data));\n}\n\n\n\nstatic void dpp1_cm_set_regamma_pwl(\n\tstruct dpp *dpp_base, const struct pwl_params *params, enum opp_regamma mode)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tuint32_t re_mode = 0;\n\n\tswitch (mode) {\n\tcase OPP_REGAMMA_BYPASS:\n\t\tre_mode = 0;\n\t\tbreak;\n\tcase OPP_REGAMMA_SRGB:\n\t\tre_mode = 1;\n\t\tbreak;\n\tcase OPP_REGAMMA_XVYCC:\n\t\tre_mode = 2;\n\t\tbreak;\n\tcase OPP_REGAMMA_USER:\n\t\tre_mode = dpp->is_write_to_ram_a_safe ? 4 : 3;\n\t\tif (memcmp(&dpp->pwl_data, params, sizeof(*params)) == 0)\n\t\t\tbreak;\n\n\t\tdpp1_cm_power_on_regamma_lut(dpp_base, true);\n\t\tdpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);\n\n\t\tif (dpp->is_write_to_ram_a_safe)\n\t\t\tdpp1_cm_program_regamma_luta_settings(dpp_base, params);\n\t\telse\n\t\t\tdpp1_cm_program_regamma_lutb_settings(dpp_base, params);\n\n\t\tdpp1_cm_program_regamma_lut(dpp_base, params->rgb_resulted,\n\t\t\t\t\t    params->hw_points_num);\n\t\tdpp->pwl_data = *params;\n\n\t\tre_mode = dpp->is_write_to_ram_a_safe ? 3 : 4;\n\t\tdpp->is_write_to_ram_a_safe = !dpp->is_write_to_ram_a_safe;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tREG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);\n}\n\nstatic void dpp1_setup_format_flags(enum surface_pixel_format input_format,\\\n\t\t\t\t\t\tenum pixel_format_description *fmt)\n{\n\n\tif (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F ||\n\t\tinput_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F)\n\t\t*fmt = PIXEL_FORMAT_FLOAT;\n\telse if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616 ||\n\t\tinput_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616)\n\t\t*fmt = PIXEL_FORMAT_FIXED16;\n\telse\n\t\t*fmt = PIXEL_FORMAT_FIXED;\n}\n\nstatic void dpp1_set_degamma_format_float(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_float)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tif (is_float) {\n\t\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);\n\t\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 1);\n\t} else {\n\t\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 2);\n\t\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 0);\n\t}\n}\n\nvoid dpp1_cnv_setup (\n\t\tstruct dpp *dpp_base,\n\t\tenum surface_pixel_format format,\n\t\tenum expansion_mode mode,\n\t\tstruct dc_csc_transform input_csc_color_matrix,\n\t\tenum dc_color_space input_color_space,\n\t\tstruct cnv_alpha_2bit_lut *alpha_2bit_lut)\n{\n\tuint32_t pixel_format;\n\tuint32_t alpha_en;\n\tenum pixel_format_description fmt ;\n\tenum dc_color_space color_space;\n\tenum dcn10_input_csc_select select;\n\tbool is_float;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tbool force_disable_cursor = false;\n\tstruct out_csc_color_matrix tbl_entry;\n\tint i = 0;\n\n\tdpp1_setup_format_flags(format, &fmt);\n\talpha_en = 1;\n\tpixel_format = 0;\n\tcolor_space = COLOR_SPACE_SRGB;\n\tselect = INPUT_CSC_SELECT_BYPASS;\n\tis_float = false;\n\n\tswitch (fmt) {\n\tcase PIXEL_FORMAT_FIXED:\n\tcase PIXEL_FORMAT_FIXED16:\n\t \n\t\tREG_SET_3(FORMAT_CONTROL, 0,\n\t\t\tCNVC_BYPASS, 0,\n\t\t\tFORMAT_EXPANSION_MODE, mode,\n\t\t\tOUTPUT_FP, 0);\n\t\tbreak;\n\tcase PIXEL_FORMAT_FLOAT:\n\t\tREG_SET_3(FORMAT_CONTROL, 0,\n\t\t\tCNVC_BYPASS, 0,\n\t\t\tFORMAT_EXPANSION_MODE, mode,\n\t\t\tOUTPUT_FP, 1);\n\t\tis_float = true;\n\t\tbreak;\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\tdpp1_set_degamma_format_float(dpp_base, is_float);\n\n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\tpixel_format = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\tpixel_format = 3;\n\t\talpha_en = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\tpixel_format = 8;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\t\tpixel_format = 10;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\t\tforce_disable_cursor = false;\n\t\tpixel_format = 65;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 64;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 67;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 66;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\t\tpixel_format = 26;  \n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\t\tpixel_format = 24;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\tpixel_format = 25;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tcolor_space = input_color_space ? input_color_space : color_space;\n\n\tREG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,\n\t\t\tCNVC_SURFACE_PIXEL_FORMAT, pixel_format);\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);\n\n\t\n\n\tif (input_csc_color_matrix.enable_adjustment\n\t\t\t\t== true) {\n\t\tfor (i = 0; i < 12; i++)\n\t\t\ttbl_entry.regval[i] = input_csc_color_matrix.matrix[i];\n\n\t\ttbl_entry.color_space = color_space;\n\n\t\tif (color_space >= COLOR_SPACE_YCBCR601)\n\t\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\telse\n\t\t\tselect = INPUT_CSC_SELECT_BYPASS;\n\n\t\tdpp1_program_input_csc(dpp_base, color_space, select, &tbl_entry);\n\t} else\n\t\tdpp1_program_input_csc(dpp_base, color_space, select, NULL);\n\n\tif (force_disable_cursor) {\n\t\tREG_UPDATE(CURSOR_CONTROL,\n\t\t\t\tCURSOR_ENABLE, 0);\n\t\tREG_UPDATE(CURSOR0_CONTROL,\n\t\t\t\tCUR0_ENABLE, 0);\n\t}\n}\n\nvoid dpp1_set_cursor_attributes(\n\t\tstruct dpp *dpp_base,\n\t\tstruct dc_cursor_attributes *cursor_attributes)\n{\n\tenum dc_cursor_color_format color_format = cursor_attributes->color_format;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_UPDATE_2(CURSOR0_CONTROL,\n\t\t\tCUR0_MODE, color_format,\n\t\t\tCUR0_EXPANSION_MODE, 0);\n\n\tif (color_format == CURSOR_MODE_MONO) {\n\t\t \n\t\tREG_UPDATE(CURSOR0_COLOR0,\n\t\t\t\tCUR0_COLOR0, 0x00000000);\n\t\tREG_UPDATE(CURSOR0_COLOR1,\n\t\t\t\tCUR0_COLOR1, 0xFFFFFFFF);\n\t}\n}\n\n\nvoid dpp1_set_cursor_position(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_cursor_position *pos,\n\t\tconst struct dc_cursor_mi_param *param,\n\t\tuint32_t width,\n\t\tuint32_t height)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tint x_pos = pos->x - param->viewport.x;\n\tint y_pos = pos->y - param->viewport.y;\n\tint x_hotspot = pos->x_hotspot;\n\tint y_hotspot = pos->y_hotspot;\n\tint src_x_offset = x_pos - pos->x_hotspot;\n\tint src_y_offset = y_pos - pos->y_hotspot;\n\tint cursor_height = (int)height;\n\tint cursor_width = (int)width;\n\tuint32_t cur_en = pos->enable ? 1 : 0;\n\n\t\n\tif (param->rotation == ROTATION_ANGLE_90 || param->rotation == ROTATION_ANGLE_270) {\n\t\tswap(cursor_height, cursor_width);\n\t\tswap(x_hotspot, y_hotspot);\n\n\t\tif (param->rotation == ROTATION_ANGLE_90) {\n\t\t\t\n\t\t\tsrc_x_offset = x_pos - (cursor_width - x_hotspot);\n\t\t\tsrc_y_offset = y_pos - y_hotspot;\n\t\t} else if (param->rotation == ROTATION_ANGLE_270) {\n\t\t\t\n\t\t\tsrc_x_offset = x_pos - x_hotspot;\n\t\t\tsrc_y_offset = y_pos - (cursor_height - y_hotspot);\n\t\t}\n\t} else if (param->rotation == ROTATION_ANGLE_180) {\n\t\t\n\t\tif (!param->mirror)\n\t\t\tsrc_x_offset = x_pos - (cursor_width - x_hotspot);\n\n\t\tsrc_y_offset = y_pos - (cursor_height - y_hotspot);\n\t}\n\n\tif (src_x_offset >= (int)param->viewport.width)\n\t\tcur_en = 0;   \n\n\tif (src_x_offset + cursor_width <= 0)\n\t\tcur_en = 0;   \n\n\tif (src_y_offset >= (int)param->viewport.height)\n\t\tcur_en = 0;   \n\n\tif (src_y_offset + cursor_height <= 0)\n\t\tcur_en = 0;   \n\n\tREG_UPDATE(CURSOR0_CONTROL,\n\t\t\tCUR0_ENABLE, cur_en);\n\n\tdpp_base->pos.cur0_ctl.bits.cur0_enable = cur_en;\n}\n\nvoid dpp1_cnv_set_optional_cursor_attributes(\n\t\tstruct dpp *dpp_base,\n\t\tstruct dpp_cursor_attributes *attr)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tif (attr) {\n\t\tREG_UPDATE(CURSOR0_FP_SCALE_BIAS,  CUR0_FP_BIAS,  attr->bias);\n\t\tREG_UPDATE(CURSOR0_FP_SCALE_BIAS,  CUR0_FP_SCALE, attr->scale);\n\t}\n}\n\nvoid dpp1_dppclk_control(\n\t\tstruct dpp *dpp_base,\n\t\tbool dppclk_div,\n\t\tbool enable)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tif (enable) {\n\t\tif (dpp->tf_mask->DPPCLK_RATE_CONTROL)\n\t\t\tREG_UPDATE_2(DPP_CONTROL,\n\t\t\t\tDPPCLK_RATE_CONTROL, dppclk_div,\n\t\t\t\tDPP_CLOCK_ENABLE, 1);\n\t\telse\n\t\t\tREG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 1);\n\t} else\n\t\tREG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 0);\n}\n\nstatic const struct dpp_funcs dcn10_dpp_funcs = {\n\t\t.dpp_read_state = dpp_read_state,\n\t\t.dpp_reset = dpp_reset,\n\t\t.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,\n\t\t.dpp_get_optimal_number_of_taps = dpp1_get_optimal_number_of_taps,\n\t\t.dpp_set_gamut_remap = dpp1_cm_set_gamut_remap,\n\t\t.dpp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,\n\t\t.dpp_set_csc_default = dpp1_cm_set_output_csc_default,\n\t\t.dpp_power_on_regamma_lut = dpp1_cm_power_on_regamma_lut,\n\t\t.dpp_program_regamma_lut = dpp1_cm_program_regamma_lut,\n\t\t.dpp_configure_regamma_lut = dpp1_cm_configure_regamma_lut,\n\t\t.dpp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,\n\t\t.dpp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,\n\t\t.dpp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,\n\t\t.dpp_program_bias_and_scale = dpp1_program_bias_and_scale,\n\t\t.dpp_set_degamma = dpp1_set_degamma,\n\t\t.dpp_program_input_lut\t\t= dpp1_program_input_lut,\n\t\t.dpp_program_degamma_pwl\t= dpp1_set_degamma_pwl,\n\t\t.dpp_setup\t\t\t= dpp1_cnv_setup,\n\t\t.dpp_full_bypass\t\t= dpp1_full_bypass,\n\t\t.set_cursor_attributes = dpp1_set_cursor_attributes,\n\t\t.set_cursor_position = dpp1_set_cursor_position,\n\t\t.set_optional_cursor_attributes = dpp1_cnv_set_optional_cursor_attributes,\n\t\t.dpp_dppclk_control = dpp1_dppclk_control,\n\t\t.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,\n\t\t.dpp_program_blnd_lut = NULL,\n\t\t.dpp_program_shaper_lut = NULL,\n\t\t.dpp_program_3dlut = NULL\n};\n\nstatic struct dpp_caps dcn10_dpp_cap = {\n\t.dscl_data_proc_format = DSCL_DATA_PRCESSING_FIXED_FORMAT,\n\t.dscl_calc_lb_num_partitions = dpp1_dscl_calc_lb_num_partitions,\n};\n\n \n \n \n\nvoid dpp1_construct(\n\tstruct dcn10_dpp *dpp,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dcn_dpp_registers *tf_regs,\n\tconst struct dcn_dpp_shift *tf_shift,\n\tconst struct dcn_dpp_mask *tf_mask)\n{\n\tdpp->base.ctx = ctx;\n\n\tdpp->base.inst = inst;\n\tdpp->base.funcs = &dcn10_dpp_funcs;\n\tdpp->base.caps = &dcn10_dpp_cap;\n\n\tdpp->tf_regs = tf_regs;\n\tdpp->tf_shift = tf_shift;\n\tdpp->tf_mask = tf_mask;\n\n\tdpp->lb_pixel_depth_supported =\n\t\tLB_PIXEL_DEPTH_18BPP |\n\t\tLB_PIXEL_DEPTH_24BPP |\n\t\tLB_PIXEL_DEPTH_30BPP |\n\t\tLB_PIXEL_DEPTH_36BPP;\n\n\tdpp->lb_bits_per_entry = LB_BITS_PER_ENTRY;\n\tdpp->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES;  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}