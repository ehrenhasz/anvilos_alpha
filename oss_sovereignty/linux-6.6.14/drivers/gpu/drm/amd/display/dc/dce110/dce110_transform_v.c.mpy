{
  "module_name": "dce110_transform_v.c",
  "hash_id": "d77cefbeca48bd1f4e22464a072199e29cbcaff7ae713ba801f6a484153352cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_transform_v.c",
  "human_readable_source": " \n\n#include \"dce110_transform_v.h\"\n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#define SCLV_PHASES 64\n#define DC_LOGGER \\\n\txfm->ctx->logger\n\nstruct sclv_ratios_inits {\n\tuint32_t h_int_scale_ratio_luma;\n\tuint32_t h_int_scale_ratio_chroma;\n\tuint32_t v_int_scale_ratio_luma;\n\tuint32_t v_int_scale_ratio_chroma;\n\tstruct init_int_and_frac h_init_luma;\n\tstruct init_int_and_frac h_init_chroma;\n\tstruct init_int_and_frac v_init_luma;\n\tstruct init_int_and_frac v_init_chroma;\n};\n\nstatic void calculate_viewport(\n\t\tconst struct scaler_data *scl_data,\n\t\tstruct rect *luma_viewport,\n\t\tstruct rect *chroma_viewport)\n{\n\t \n\tluma_viewport->x = scl_data->viewport.x - scl_data->viewport.x % 2;\n\tluma_viewport->y = scl_data->viewport.y - scl_data->viewport.y % 2;\n\tluma_viewport->width =\n\t\tscl_data->viewport.width - scl_data->viewport.width % 2;\n\tluma_viewport->height =\n\t\tscl_data->viewport.height - scl_data->viewport.height % 2;\n\tchroma_viewport->x = luma_viewport->x;\n\tchroma_viewport->y = luma_viewport->y;\n\tchroma_viewport->height = luma_viewport->height;\n\tchroma_viewport->width = luma_viewport->width;\n\n\tif (scl_data->format == PIXEL_FORMAT_420BPP8) {\n\t\tluma_viewport->height += luma_viewport->height % 2;\n\t\tluma_viewport->width += luma_viewport->width % 2;\n\t\t \n\t\tchroma_viewport->x = luma_viewport->x / 2;\n\t\tchroma_viewport->y = luma_viewport->y / 2;\n\t\tchroma_viewport->height = luma_viewport->height / 2;\n\t\tchroma_viewport->width = luma_viewport->width / 2;\n\t}\n}\n\nstatic void program_viewport(\n\tstruct dce_transform *xfm_dce,\n\tstruct rect *luma_view_port,\n\tstruct rect *chroma_view_port)\n{\n\tstruct dc_context *ctx = xfm_dce->base.ctx;\n\tuint32_t value = 0;\n\tuint32_t addr = 0;\n\n\tif (luma_view_port->width != 0 && luma_view_port->height != 0) {\n\t\taddr = mmSCLV_VIEWPORT_START;\n\t\tvalue = 0;\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tluma_view_port->x,\n\t\t\tSCLV_VIEWPORT_START,\n\t\t\tVIEWPORT_X_START);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tluma_view_port->y,\n\t\t\tSCLV_VIEWPORT_START,\n\t\t\tVIEWPORT_Y_START);\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\taddr = mmSCLV_VIEWPORT_SIZE;\n\t\tvalue = 0;\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tluma_view_port->height,\n\t\t\tSCLV_VIEWPORT_SIZE,\n\t\t\tVIEWPORT_HEIGHT);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tluma_view_port->width,\n\t\t\tSCLV_VIEWPORT_SIZE,\n\t\t\tVIEWPORT_WIDTH);\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n\n\tif (chroma_view_port->width != 0 && chroma_view_port->height != 0) {\n\t\taddr = mmSCLV_VIEWPORT_START_C;\n\t\tvalue = 0;\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tchroma_view_port->x,\n\t\t\tSCLV_VIEWPORT_START_C,\n\t\t\tVIEWPORT_X_START_C);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tchroma_view_port->y,\n\t\t\tSCLV_VIEWPORT_START_C,\n\t\t\tVIEWPORT_Y_START_C);\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\taddr = mmSCLV_VIEWPORT_SIZE_C;\n\t\tvalue = 0;\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tchroma_view_port->height,\n\t\t\tSCLV_VIEWPORT_SIZE_C,\n\t\t\tVIEWPORT_HEIGHT_C);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tchroma_view_port->width,\n\t\t\tSCLV_VIEWPORT_SIZE_C,\n\t\t\tVIEWPORT_WIDTH_C);\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n}\n\n \nstatic bool setup_scaling_configuration(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data)\n{\n\tbool is_scaling_needed = false;\n\tstruct dc_context *ctx = xfm_dce->base.ctx;\n\tuint32_t value = 0;\n\n\tset_reg_field_value(value, data->taps.h_taps - 1,\n\t\t\tSCLV_TAP_CONTROL, SCL_H_NUM_OF_TAPS);\n\tset_reg_field_value(value, data->taps.v_taps - 1,\n\t\t\tSCLV_TAP_CONTROL, SCL_V_NUM_OF_TAPS);\n\tset_reg_field_value(value, data->taps.h_taps_c - 1,\n\t\t\tSCLV_TAP_CONTROL, SCL_H_NUM_OF_TAPS_C);\n\tset_reg_field_value(value, data->taps.v_taps_c - 1,\n\t\t\tSCLV_TAP_CONTROL, SCL_V_NUM_OF_TAPS_C);\n\tdm_write_reg(ctx, mmSCLV_TAP_CONTROL, value);\n\n\tvalue = 0;\n\tif (data->taps.h_taps + data->taps.v_taps > 2) {\n\t\tset_reg_field_value(value, 1, SCLV_MODE, SCL_MODE);\n\t\tset_reg_field_value(value, 1, SCLV_MODE, SCL_PSCL_EN);\n\t\tis_scaling_needed = true;\n\t} else {\n\t\tset_reg_field_value(value, 0, SCLV_MODE, SCL_MODE);\n\t\tset_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN);\n\t}\n\n\tif (data->taps.h_taps_c + data->taps.v_taps_c > 2) {\n\t\tset_reg_field_value(value, 1, SCLV_MODE, SCL_MODE_C);\n\t\tset_reg_field_value(value, 1, SCLV_MODE, SCL_PSCL_EN_C);\n\t\tis_scaling_needed = true;\n\t} else if (data->format != PIXEL_FORMAT_420BPP8) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tget_reg_field_value(value, SCLV_MODE, SCL_MODE),\n\t\t\tSCLV_MODE,\n\t\t\tSCL_MODE_C);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tget_reg_field_value(value, SCLV_MODE, SCL_PSCL_EN),\n\t\t\tSCLV_MODE,\n\t\t\tSCL_PSCL_EN_C);\n\t} else {\n\t\tset_reg_field_value(value, 0, SCLV_MODE, SCL_MODE_C);\n\t\tset_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN_C);\n\t}\n\tdm_write_reg(ctx, mmSCLV_MODE, value);\n\n\tvalue = 0;\n\t \n\tset_reg_field_value(value, 1, SCLV_CONTROL, SCL_BOUNDARY_MODE);\n\tdm_write_reg(ctx, mmSCLV_CONTROL, value);\n\n\treturn is_scaling_needed;\n}\n\n \nstatic void program_overscan(\n\t\tstruct dce_transform *xfm_dce,\n\t\tconst struct scaler_data *data)\n{\n\tuint32_t overscan_left_right = 0;\n\tuint32_t overscan_top_bottom = 0;\n\n\tint overscan_right = data->h_active - data->recout.x - data->recout.width;\n\tint overscan_bottom = data->v_active - data->recout.y - data->recout.height;\n\n\tif (xfm_dce->base.ctx->dc->debug.visual_confirm != VISUAL_CONFIRM_DISABLE) {\n\t\toverscan_bottom += 2;\n\t\toverscan_right += 2;\n\t}\n\n\tif (overscan_right < 0) {\n\t\tBREAK_TO_DEBUGGER();\n\t\toverscan_right = 0;\n\t}\n\tif (overscan_bottom < 0) {\n\t\tBREAK_TO_DEBUGGER();\n\t\toverscan_bottom = 0;\n\t}\n\n\tset_reg_field_value(overscan_left_right, data->recout.x,\n\t\t\tEXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT);\n\n\tset_reg_field_value(overscan_left_right, overscan_right,\n\t\t\tEXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT);\n\n\tset_reg_field_value(overscan_top_bottom, data->recout.y,\n\t\t\tEXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP);\n\n\tset_reg_field_value(overscan_top_bottom, overscan_bottom,\n\t\t\tEXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);\n\n\tdm_write_reg(xfm_dce->base.ctx,\n\t\t\tmmSCLV_EXT_OVERSCAN_LEFT_RIGHT,\n\t\t\toverscan_left_right);\n\n\tdm_write_reg(xfm_dce->base.ctx,\n\t\t\tmmSCLV_EXT_OVERSCAN_TOP_BOTTOM,\n\t\t\toverscan_top_bottom);\n}\n\nstatic void set_coeff_update_complete(\n\t\tstruct dce_transform *xfm_dce)\n{\n\tuint32_t value;\n\n\tvalue = dm_read_reg(xfm_dce->base.ctx, mmSCLV_UPDATE);\n\tset_reg_field_value(value, 1, SCLV_UPDATE, SCL_COEF_UPDATE_COMPLETE);\n\tdm_write_reg(xfm_dce->base.ctx, mmSCLV_UPDATE, value);\n}\n\nstatic void program_multi_taps_filter(\n\tstruct dce_transform *xfm_dce,\n\tint taps,\n\tconst uint16_t *coeffs,\n\tenum ram_filter_type filter_type)\n{\n\tstruct dc_context *ctx = xfm_dce->base.ctx;\n\tint i, phase, pair;\n\tint array_idx = 0;\n\tint taps_pairs = (taps + 1) / 2;\n\tint phases_to_program = SCLV_PHASES / 2 + 1;\n\n\tuint32_t select = 0;\n\tuint32_t power_ctl, power_ctl_off;\n\n\tif (!coeffs)\n\t\treturn;\n\n\t \n\tpower_ctl = dm_read_reg(ctx, mmDCFEV_MEM_PWR_CTRL);\n\tpower_ctl_off = power_ctl;\n\tset_reg_field_value(power_ctl_off, 1, DCFEV_MEM_PWR_CTRL, SCLV_COEFF_MEM_PWR_DIS);\n\tdm_write_reg(ctx, mmDCFEV_MEM_PWR_CTRL, power_ctl_off);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tif (get_reg_field_value(\n\t\t\t\tdm_read_reg(ctx, mmDCFEV_MEM_PWR_STATUS),\n\t\t\t\tDCFEV_MEM_PWR_STATUS,\n\t\t\t\tSCLV_COEFF_MEM_PWR_STATE) == 0)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\tset_reg_field_value(select, filter_type, SCLV_COEF_RAM_SELECT, SCL_C_RAM_FILTER_TYPE);\n\n\tfor (phase = 0; phase < phases_to_program; phase++) {\n\t\t \n\t\tset_reg_field_value(select, phase, SCLV_COEF_RAM_SELECT, SCL_C_RAM_PHASE);\n\t\tfor (pair = 0; pair < taps_pairs; pair++) {\n\t\t\tuint32_t data = 0;\n\n\t\t\tset_reg_field_value(select, pair,\n\t\t\t\t\tSCLV_COEF_RAM_SELECT, SCL_C_RAM_TAP_PAIR_IDX);\n\n\t\t\tdm_write_reg(ctx, mmSCLV_COEF_RAM_SELECT, select);\n\n\t\t\tset_reg_field_value(\n\t\t\t\t\tdata, 1,\n\t\t\t\t\tSCLV_COEF_RAM_TAP_DATA,\n\t\t\t\t\tSCL_C_RAM_EVEN_TAP_COEF_EN);\n\t\t\tset_reg_field_value(\n\t\t\t\t\tdata, coeffs[array_idx],\n\t\t\t\t\tSCLV_COEF_RAM_TAP_DATA,\n\t\t\t\t\tSCL_C_RAM_EVEN_TAP_COEF);\n\n\t\t\tif (taps % 2 && pair == taps_pairs - 1) {\n\t\t\t\tset_reg_field_value(\n\t\t\t\t\t\tdata, 0,\n\t\t\t\t\t\tSCLV_COEF_RAM_TAP_DATA,\n\t\t\t\t\t\tSCL_C_RAM_ODD_TAP_COEF_EN);\n\t\t\t\tarray_idx++;\n\t\t\t} else {\n\t\t\t\tset_reg_field_value(\n\t\t\t\t\t\tdata, 1,\n\t\t\t\t\t\tSCLV_COEF_RAM_TAP_DATA,\n\t\t\t\t\t\tSCL_C_RAM_ODD_TAP_COEF_EN);\n\t\t\t\tset_reg_field_value(\n\t\t\t\t\t\tdata, coeffs[array_idx + 1],\n\t\t\t\t\t\tSCLV_COEF_RAM_TAP_DATA,\n\t\t\t\t\t\tSCL_C_RAM_ODD_TAP_COEF);\n\n\t\t\t\tarray_idx += 2;\n\t\t\t}\n\n\t\t\tdm_write_reg(ctx, mmSCLV_COEF_RAM_TAP_DATA, data);\n\t\t}\n\t}\n\n\t \n\tdm_write_reg(ctx, mmDCFEV_MEM_PWR_CTRL, power_ctl);\n}\n\nstatic void calculate_inits(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data,\n\tstruct sclv_ratios_inits *inits,\n\tstruct rect *luma_viewport,\n\tstruct rect *chroma_viewport)\n{\n\tinits->h_int_scale_ratio_luma =\n\t\tdc_fixpt_u2d19(data->ratios.horz) << 5;\n\tinits->v_int_scale_ratio_luma =\n\t\tdc_fixpt_u2d19(data->ratios.vert) << 5;\n\tinits->h_int_scale_ratio_chroma =\n\t\tdc_fixpt_u2d19(data->ratios.horz_c) << 5;\n\tinits->v_int_scale_ratio_chroma =\n\t\tdc_fixpt_u2d19(data->ratios.vert_c) << 5;\n\n\tinits->h_init_luma.integer = 1;\n\tinits->v_init_luma.integer = 1;\n\tinits->h_init_chroma.integer = 1;\n\tinits->v_init_chroma.integer = 1;\n}\n\nstatic void program_scl_ratios_inits(\n\tstruct dce_transform *xfm_dce,\n\tstruct sclv_ratios_inits *inits)\n{\n\tstruct dc_context *ctx = xfm_dce->base.ctx;\n\tuint32_t addr = mmSCLV_HORZ_FILTER_SCALE_RATIO;\n\tuint32_t value = 0;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_int_scale_ratio_luma,\n\t\tSCLV_HORZ_FILTER_SCALE_RATIO,\n\t\tSCL_H_SCALE_RATIO);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_VERT_FILTER_SCALE_RATIO;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_int_scale_ratio_luma,\n\t\tSCLV_VERT_FILTER_SCALE_RATIO,\n\t\tSCL_V_SCALE_RATIO);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_HORZ_FILTER_SCALE_RATIO_C;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_int_scale_ratio_chroma,\n\t\tSCLV_HORZ_FILTER_SCALE_RATIO_C,\n\t\tSCL_H_SCALE_RATIO_C);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_VERT_FILTER_SCALE_RATIO_C;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_int_scale_ratio_chroma,\n\t\tSCLV_VERT_FILTER_SCALE_RATIO_C,\n\t\tSCL_V_SCALE_RATIO_C);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_HORZ_FILTER_INIT;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_init_luma.fraction,\n\t\tSCLV_HORZ_FILTER_INIT,\n\t\tSCL_H_INIT_FRAC);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_init_luma.integer,\n\t\tSCLV_HORZ_FILTER_INIT,\n\t\tSCL_H_INIT_INT);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_VERT_FILTER_INIT;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_init_luma.fraction,\n\t\tSCLV_VERT_FILTER_INIT,\n\t\tSCL_V_INIT_FRAC);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_init_luma.integer,\n\t\tSCLV_VERT_FILTER_INIT,\n\t\tSCL_V_INIT_INT);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_HORZ_FILTER_INIT_C;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_init_chroma.fraction,\n\t\tSCLV_HORZ_FILTER_INIT_C,\n\t\tSCL_H_INIT_FRAC_C);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->h_init_chroma.integer,\n\t\tSCLV_HORZ_FILTER_INIT_C,\n\t\tSCL_H_INIT_INT_C);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = mmSCLV_VERT_FILTER_INIT_C;\n\tvalue = 0;\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_init_chroma.fraction,\n\t\tSCLV_VERT_FILTER_INIT_C,\n\t\tSCL_V_INIT_FRAC_C);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tinits->v_init_chroma.integer,\n\t\tSCLV_VERT_FILTER_INIT_C,\n\t\tSCL_V_INIT_INT_C);\n\tdm_write_reg(ctx, addr, value);\n}\n\nstatic const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)\n{\n\tif (taps == 4)\n\t\treturn get_filter_4tap_64p(ratio);\n\telse if (taps == 2)\n\t\treturn get_filter_2tap_64p();\n\telse if (taps == 1)\n\t\treturn NULL;\n\telse {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n}\n\nstatic bool dce110_xfmv_power_up_line_buffer(struct transform *xfm)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tuint32_t value;\n\n\tvalue = dm_read_reg(xfm_dce->base.ctx, mmLBV_MEMORY_CTRL);\n\n\t \n\tset_reg_field_value(value, 0, LBV_MEMORY_CTRL, LB_MEMORY_CONFIG);\n\t \n\tset_reg_field_value(value, xfm_dce->lb_memory_size, LBV_MEMORY_CTRL,\n\t\t\tLB_MEMORY_SIZE);\n\n\tdm_write_reg(xfm_dce->base.ctx, mmLBV_MEMORY_CTRL, value);\n\n\treturn true;\n}\n\nstatic void dce110_xfmv_set_scaler(\n\tstruct transform *xfm,\n\tconst struct scaler_data *data)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tbool is_scaling_required = false;\n\tbool filter_updated = false;\n\tconst uint16_t *coeffs_v, *coeffs_h, *coeffs_h_c, *coeffs_v_c;\n\tstruct rect luma_viewport = {0};\n\tstruct rect chroma_viewport = {0};\n\n\tdce110_xfmv_power_up_line_buffer(xfm);\n\t \n\n\tcalculate_viewport(data, &luma_viewport, &chroma_viewport);\n\n\t \n\tprogram_overscan(xfm_dce, data);\n\n\t \n\tis_scaling_required = setup_scaling_configuration(xfm_dce, data);\n\n\tif (is_scaling_required) {\n\t\t \n\n\t\tstruct sclv_ratios_inits inits = { 0 };\n\n\t\tcalculate_inits(\n\t\t\txfm_dce,\n\t\t\tdata,\n\t\t\t&inits,\n\t\t\t&luma_viewport,\n\t\t\t&chroma_viewport);\n\n\t\tprogram_scl_ratios_inits(xfm_dce, &inits);\n\n\t\tcoeffs_v = get_filter_coeffs_64p(data->taps.v_taps, data->ratios.vert);\n\t\tcoeffs_h = get_filter_coeffs_64p(data->taps.h_taps, data->ratios.horz);\n\t\tcoeffs_v_c = get_filter_coeffs_64p(data->taps.v_taps_c, data->ratios.vert_c);\n\t\tcoeffs_h_c = get_filter_coeffs_64p(data->taps.h_taps_c, data->ratios.horz_c);\n\n\t\tif (coeffs_v != xfm_dce->filter_v\n\t\t\t\t|| coeffs_v_c != xfm_dce->filter_v_c\n\t\t\t\t|| coeffs_h != xfm_dce->filter_h\n\t\t\t\t|| coeffs_h_c != xfm_dce->filter_h_c) {\n\t\t \n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps,\n\t\t\t\t\tcoeffs_v,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_VERTICAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps_c,\n\t\t\t\t\tcoeffs_v_c,\n\t\t\t\t\tFILTER_TYPE_CBCR_VERTICAL);\n\n\t\t \n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps,\n\t\t\t\t\tcoeffs_h,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_HORIZONTAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps_c,\n\t\t\t\t\tcoeffs_h_c,\n\t\t\t\t\tFILTER_TYPE_CBCR_HORIZONTAL);\n\n\t\t\txfm_dce->filter_v = coeffs_v;\n\t\t\txfm_dce->filter_v_c = coeffs_v_c;\n\t\t\txfm_dce->filter_h = coeffs_h;\n\t\t\txfm_dce->filter_h_c = coeffs_h_c;\n\t\t\tfilter_updated = true;\n\t\t}\n\t}\n\n\t \n\tprogram_viewport(xfm_dce, &luma_viewport, &chroma_viewport);\n\n\t \n\tif (filter_updated)\n\t\tset_coeff_update_complete(xfm_dce);\n}\n\nstatic void dce110_xfmv_reset(struct transform *xfm)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\n\txfm_dce->filter_h = NULL;\n\txfm_dce->filter_v = NULL;\n\txfm_dce->filter_h_c = NULL;\n\txfm_dce->filter_v_c = NULL;\n}\n\nstatic void dce110_xfmv_set_gamut_remap(\n\tstruct transform *xfm,\n\tconst struct xfm_grph_csc_adjustment *adjust)\n{\n\t \n}\n\nstatic void dce110_xfmv_set_pixel_storage_depth(\n\tstruct transform *xfm,\n\tenum lb_pixel_depth depth,\n\tconst struct bit_depth_reduction_params *bit_depth_params)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tint pixel_depth = 0;\n\tint expan_mode = 0;\n\tuint32_t reg_data = 0;\n\n\tswitch (depth) {\n\tcase LB_PIXEL_DEPTH_18BPP:\n\t\tpixel_depth = 2;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_24BPP:\n\t\tpixel_depth = 1;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_30BPP:\n\t\tpixel_depth = 0;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_36BPP:\n\t\tpixel_depth = 3;\n\t\texpan_mode  = 0;\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tset_reg_field_value(\n\t\treg_data,\n\t\texpan_mode,\n\t\tLBV_DATA_FORMAT,\n\t\tPIXEL_EXPAN_MODE);\n\n\tset_reg_field_value(\n\t\treg_data,\n\t\tpixel_depth,\n\t\tLBV_DATA_FORMAT,\n\t\tPIXEL_DEPTH);\n\n\tdm_write_reg(xfm->ctx, mmLBV_DATA_FORMAT, reg_data);\n\n\tif (!(xfm_dce->lb_pixel_depth_supported & depth)) {\n\t\t \n\t\tDC_LOG_WARNING(\"%s: Capability not supported\",\n\t\t\t__func__);\n\t}\n}\n\nstatic const struct transform_funcs dce110_xfmv_funcs = {\n\t.transform_reset = dce110_xfmv_reset,\n\t.transform_set_scaler = dce110_xfmv_set_scaler,\n\t.transform_set_gamut_remap =\n\t\tdce110_xfmv_set_gamut_remap,\n\t.opp_set_csc_default = dce110_opp_v_set_csc_default,\n\t.opp_set_csc_adjustment = dce110_opp_v_set_csc_adjustment,\n\t.opp_power_on_regamma_lut = dce110_opp_power_on_regamma_lut_v,\n\t.opp_program_regamma_pwl = dce110_opp_program_regamma_pwl_v,\n\t.opp_set_regamma_mode = dce110_opp_set_regamma_mode_v,\n\t.transform_set_pixel_storage_depth =\n\t\t\tdce110_xfmv_set_pixel_storage_depth,\n\t.transform_get_optimal_number_of_taps =\n\t\tdce_transform_get_optimal_number_of_taps\n};\n \n \n \n\nbool dce110_transform_v_construct(\n\tstruct dce_transform *xfm_dce,\n\tstruct dc_context *ctx)\n{\n\txfm_dce->base.ctx = ctx;\n\n\txfm_dce->base.funcs = &dce110_xfmv_funcs;\n\n\txfm_dce->lb_pixel_depth_supported =\n\t\t\tLB_PIXEL_DEPTH_18BPP |\n\t\t\tLB_PIXEL_DEPTH_24BPP |\n\t\t\tLB_PIXEL_DEPTH_30BPP |\n\t\t\tLB_PIXEL_DEPTH_36BPP;\n\n\txfm_dce->prescaler_on = true;\n\txfm_dce->lb_bits_per_entry = LB_BITS_PER_ENTRY;\n\txfm_dce->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES;  \n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}