{
  "module_name": "rn_clk_mgr_vbios_smu.c",
  "hash_id": "2f16ae77092f74ceefdc967d67da5c8a1d2fade062dc9e7007bef8f4c8c94b52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn21/rn_clk_mgr_vbios_smu.c",
  "human_readable_source": " \n\n#include \"core_types.h\"\n#include \"clk_mgr_internal.h\"\n#include \"reg_helper.h\"\n#include <linux/delay.h>\n\n#include \"renoir_ip_offset.h\"\n\n#include \"mp/mp_12_0_0_offset.h\"\n#include \"mp/mp_12_0_0_sh_mask.h\"\n\n#include \"rn_clk_mgr_vbios_smu.h\"\n\n#define REG(reg_name) \\\n\t(MP0_BASE.instance[0].segment[mm ## reg_name ## _BASE_IDX] + mm ## reg_name)\n\n#define FN(reg_name, field) \\\n\tFD(reg_name##__##field)\n\n#include \"logger_types.h\"\n#undef DC_LOGGER\n#define DC_LOGGER \\\n\tCTX->logger\n#define smu_print(str, ...) {DC_LOG_SMU(str, ##__VA_ARGS__); }\n\n#define VBIOSSMC_MSG_TestMessage                  0x1\n#define VBIOSSMC_MSG_GetSmuVersion                0x2\n#define VBIOSSMC_MSG_PowerUpGfx                   0x3\n#define VBIOSSMC_MSG_SetDispclkFreq               0x4\n#define VBIOSSMC_MSG_SetDprefclkFreq              0x5\n#define VBIOSSMC_MSG_PowerDownGfx                 0x6\n#define VBIOSSMC_MSG_SetDppclkFreq                0x7\n#define VBIOSSMC_MSG_SetHardMinDcfclkByFreq       0x8\n#define VBIOSSMC_MSG_SetMinDeepSleepDcfclk        0x9\n#define VBIOSSMC_MSG_SetPhyclkVoltageByFreq       0xA\n#define VBIOSSMC_MSG_GetFclkFrequency             0xB\n#define VBIOSSMC_MSG_SetDisplayCount              0xC\n#define VBIOSSMC_MSG_EnableTmdp48MHzRefclkPwrDown 0xD\n#define VBIOSSMC_MSG_UpdatePmeRestore             0xE\n#define VBIOSSMC_MSG_IsPeriodicRetrainingDisabled 0xF\n\n#define VBIOSSMC_Status_BUSY                      0x0\n#define VBIOSSMC_Result_OK                        0x1\n#define VBIOSSMC_Result_Failed                    0xFF\n#define VBIOSSMC_Result_UnknownCmd                0xFE\n#define VBIOSSMC_Result_CmdRejectedPrereq         0xFD\n#define VBIOSSMC_Result_CmdRejectedBusy           0xFC\n\n \nstatic uint32_t rn_smu_wait_for_response(struct clk_mgr_internal *clk_mgr, unsigned int delay_us, unsigned int max_retries)\n{\n\tuint32_t res_val = VBIOSSMC_Status_BUSY;\n\n\tdo {\n\t\tres_val = REG_READ(MP1_SMN_C2PMSG_91);\n\t\tif (res_val != VBIOSSMC_Status_BUSY)\n\t\t\tbreak;\n\n\t\tif (delay_us >= 1000)\n\t\t\tmsleep(delay_us/1000);\n\t\telse if (delay_us > 0)\n\t\t\tudelay(delay_us);\n\t} while (max_retries--);\n\n\treturn res_val;\n}\n\n\nstatic int rn_vbios_smu_send_msg_with_param(struct clk_mgr_internal *clk_mgr,\n\t\t\t\t\t    unsigned int msg_id,\n\t\t\t\t\t    unsigned int param)\n{\n\tuint32_t result;\n\n\tresult = rn_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tif (result != VBIOSSMC_Result_OK)\n\t\tsmu_print(\"SMU Response was not OK. SMU response after wait received is: %d\\n\", result);\n\n\tif (result == VBIOSSMC_Status_BUSY) {\n\t\treturn -1;\n\t}\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_91, VBIOSSMC_Status_BUSY);\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_83, param);\n\n\t \n\tREG_WRITE(MP1_SMN_C2PMSG_67, msg_id);\n\n\tresult = rn_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\tASSERT(result == VBIOSSMC_Result_OK || result == VBIOSSMC_Result_UnknownCmd);\n\n\t \n\treturn REG_READ(MP1_SMN_C2PMSG_83);\n}\n\nint rn_vbios_smu_get_smu_version(struct clk_mgr_internal *clk_mgr)\n{\n\treturn rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_GetSmuVersion,\n\t\t\t0);\n}\n\n\nint rn_vbios_smu_set_dispclk(struct clk_mgr_internal *clk_mgr, int requested_dispclk_khz)\n{\n\tint actual_dispclk_set_mhz = -1;\n\tstruct dc *dc = clk_mgr->base.ctx->dc;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\n\t \n\tactual_dispclk_set_mhz = rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDispclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dispclk_khz));\n\n\tif (dmcu && dmcu->funcs->is_dmcu_initialized(dmcu)) {\n\t\tif (clk_mgr->dfs_bypass_disp_clk != actual_dispclk_set_mhz)\n\t\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\t\t\tactual_dispclk_set_mhz / 7);\n\t}\n\n\t \n\tASSERT(actual_dispclk_set_mhz >= khz_to_mhz_ceil(requested_dispclk_khz));\n\n\treturn actual_dispclk_set_mhz * 1000;\n}\n\nint rn_vbios_smu_set_dprefclk(struct clk_mgr_internal *clk_mgr)\n{\n\tint actual_dprefclk_set_mhz = -1;\n\n\tactual_dprefclk_set_mhz = rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDprefclkFreq,\n\t\t\tkhz_to_mhz_ceil(clk_mgr->base.dprefclk_khz));\n\n\t \n\n\treturn actual_dprefclk_set_mhz * 1000;\n}\n\nint rn_vbios_smu_set_hard_min_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_dcfclk_khz)\n{\n\tint actual_dcfclk_set_mhz = -1;\n\n\tif (clk_mgr->smu_ver < 0x370c00)\n\t\treturn actual_dcfclk_set_mhz;\n\n\tactual_dcfclk_set_mhz = rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetHardMinDcfclkByFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dcfclk_khz));\n\n#ifdef DBG\n\tsmu_print(\"actual_dcfclk_set_mhz %d is set to : %d\\n\", actual_dcfclk_set_mhz, actual_dcfclk_set_mhz * 1000);\n#endif\n\n\treturn actual_dcfclk_set_mhz * 1000;\n}\n\nint rn_vbios_smu_set_min_deep_sleep_dcfclk(struct clk_mgr_internal *clk_mgr, int requested_min_ds_dcfclk_khz)\n{\n\tint actual_min_ds_dcfclk_mhz = -1;\n\n\tif (clk_mgr->smu_ver < 0x370c00)\n\t\treturn actual_min_ds_dcfclk_mhz;\n\n\tactual_min_ds_dcfclk_mhz = rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetMinDeepSleepDcfclk,\n\t\t\tkhz_to_mhz_ceil(requested_min_ds_dcfclk_khz));\n\n\treturn actual_min_ds_dcfclk_mhz * 1000;\n}\n\nvoid rn_vbios_smu_set_phyclk(struct clk_mgr_internal *clk_mgr, int requested_phyclk_khz)\n{\n\trn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetPhyclkVoltageByFreq,\n\t\t\tkhz_to_mhz_ceil(requested_phyclk_khz));\n}\n\nint rn_vbios_smu_set_dppclk(struct clk_mgr_internal *clk_mgr, int requested_dpp_khz)\n{\n\tint actual_dppclk_set_mhz = -1;\n\n\tactual_dppclk_set_mhz = rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_SetDppclkFreq,\n\t\t\tkhz_to_mhz_ceil(requested_dpp_khz));\n\n\tASSERT(actual_dppclk_set_mhz >= khz_to_mhz_ceil(requested_dpp_khz));\n\n\treturn actual_dppclk_set_mhz * 1000;\n}\n\nvoid rn_vbios_smu_set_dcn_low_power_state(struct clk_mgr_internal *clk_mgr, enum dcn_pwr_state state)\n{\n\tint disp_count;\n\n\tif (state == DCN_PWR_STATE_LOW_POWER)\n\t\tdisp_count = 0;\n\telse\n\t\tdisp_count = 1;\n\n\trn_vbios_smu_send_msg_with_param(\n\t\tclk_mgr,\n\t\tVBIOSSMC_MSG_SetDisplayCount,\n\t\tdisp_count);\n}\n\nvoid rn_vbios_smu_enable_48mhz_tmdp_refclk_pwrdwn(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\trn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_EnableTmdp48MHzRefclkPwrDown,\n\t\t\tenable);\n}\n\nvoid rn_vbios_smu_enable_pme_wa(struct clk_mgr_internal *clk_mgr)\n{\n\trn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_UpdatePmeRestore,\n\t\t\t0);\n}\n\nint rn_vbios_smu_is_periodic_retraining_disabled(struct clk_mgr_internal *clk_mgr)\n{\n\treturn rn_vbios_smu_send_msg_with_param(\n\t\t\tclk_mgr,\n\t\t\tVBIOSSMC_MSG_IsPeriodicRetrainingDisabled,\n\t\t\t1);\t \n\t\t\t\t\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}