{
  "module_name": "dce_i2c_hw.c",
  "hash_id": "66989db2be437d5c9fad4420230a0435699a49b4d3b4d9ae693d05f84de1da44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n\n#include \"resource.h\"\n#include \"dce_i2c.h\"\n#include \"dce_i2c_hw.h\"\n#include \"reg_helper.h\"\n#include \"include/gpio_service_interface.h\"\n\n#define CTX \\\n\tdce_i2c_hw->ctx\n#define REG(reg)\\\n\tdce_i2c_hw->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdce_i2c_hw->shifts->field_name, dce_i2c_hw->masks->field_name\n\nstatic void execute_transaction(\n\tstruct dce_i2c_hw *dce_i2c_hw)\n{\n\tREG_UPDATE_N(SETUP, 5,\n\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_EN), 0,\n\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_CLK_DRIVE_EN), 0,\n\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_SEL), 0,\n\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_TRANSACTION_DELAY), 0,\n\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_BYTE_DELAY), 0);\n\n\n\tREG_UPDATE_5(DC_I2C_CONTROL,\n\t\t     DC_I2C_SOFT_RESET, 0,\n\t\t     DC_I2C_SW_STATUS_RESET, 0,\n\t\t     DC_I2C_SEND_RESET, 0,\n\t\t     DC_I2C_GO, 0,\n\t\t     DC_I2C_TRANSACTION_COUNT, dce_i2c_hw->transaction_count - 1);\n\n\t \n\tREG_UPDATE(DC_I2C_CONTROL, DC_I2C_GO, 1);\n\n\t \n\tdce_i2c_hw->transaction_count = 0;\n\tdce_i2c_hw->buffer_used_bytes = 0;\n}\n\nstatic enum i2c_channel_operation_result get_channel_status(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tuint8_t *returned_bytes)\n{\n\tuint32_t i2c_sw_status = 0;\n\tuint32_t value =\n\t\tREG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);\n\tif (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_SW)\n\t\treturn I2C_CHANNEL_OPERATION_ENGINE_BUSY;\n\telse if (value & dce_i2c_hw->masks->DC_I2C_SW_STOPPED_ON_NACK)\n\t\treturn I2C_CHANNEL_OPERATION_NO_RESPONSE;\n\telse if (value & dce_i2c_hw->masks->DC_I2C_SW_TIMEOUT)\n\t\treturn I2C_CHANNEL_OPERATION_TIMEOUT;\n\telse if (value & dce_i2c_hw->masks->DC_I2C_SW_ABORTED)\n\t\treturn I2C_CHANNEL_OPERATION_FAILED;\n\telse if (value & dce_i2c_hw->masks->DC_I2C_SW_DONE)\n\t\treturn I2C_CHANNEL_OPERATION_SUCCEEDED;\n\n\t \n\treturn I2C_CHANNEL_OPERATION_SUCCEEDED;\n}\n\nstatic uint32_t get_hw_buffer_available_size(\n\tconst struct dce_i2c_hw *dce_i2c_hw)\n{\n\treturn dce_i2c_hw->buffer_size -\n\t\t\tdce_i2c_hw->buffer_used_bytes;\n}\n\nstatic void process_channel_reply(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct i2c_payload *reply)\n{\n\tuint32_t length = reply->length;\n\tuint8_t *buffer = reply->data;\n\n\tREG_SET_3(DC_I2C_DATA, 0,\n\t\t DC_I2C_INDEX, dce_i2c_hw->buffer_used_write,\n\t\t DC_I2C_DATA_RW, 1,\n\t\t DC_I2C_INDEX_WRITE, 1);\n\n\twhile (length) {\n\t\t \n\n\t\tuint32_t i2c_data;\n\n\t\tREG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);\n\t\t*buffer++ = i2c_data;\n\n\t\t--length;\n\t}\n}\n\nstatic bool is_engine_available(struct dce_i2c_hw *dce_i2c_hw)\n{\n\tunsigned int arbitrate;\n\tunsigned int i2c_hw_status;\n\n\tREG_GET(HW_STATUS, DC_I2C_DDC1_HW_STATUS, &i2c_hw_status);\n\tif (i2c_hw_status == DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_HW)\n\t\treturn false;\n\n\tREG_GET(DC_I2C_ARBITRATION, DC_I2C_REG_RW_CNTL_STATUS, &arbitrate);\n\tif (arbitrate == DC_I2C_REG_RW_CNTL_STATUS_DMCU_ONLY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)\n{\n\tuint32_t i2c_sw_status = 0;\n\n\tREG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);\n\tif (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)\n\t\treturn false;\n\n\tif (is_engine_available(dce_i2c_hw))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool process_transaction(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct i2c_request_transaction_data *request)\n{\n\tuint32_t length = request->length;\n\tuint8_t *buffer = request->data;\n\n\tbool last_transaction = false;\n\tuint32_t value = 0;\n\n\tif (is_hw_busy(dce_i2c_hw)) {\n\t\trequest->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;\n\t\treturn false;\n\t}\n\n\tlast_transaction = ((dce_i2c_hw->transaction_count == 3) ||\n\t\t\t(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||\n\t\t\t(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ));\n\n\n\tswitch (dce_i2c_hw->transaction_count) {\n\tcase 0:\n\t\tREG_UPDATE_5(DC_I2C_TRANSACTION0,\n\t\t\t\t DC_I2C_STOP_ON_NACK0, 1,\n\t\t\t\t DC_I2C_START0, 1,\n\t\t\t\t DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),\n\t\t\t\t DC_I2C_COUNT0, length,\n\t\t\t\t DC_I2C_STOP0, last_transaction ? 1 : 0);\n\t\tbreak;\n\tcase 1:\n\t\tREG_UPDATE_5(DC_I2C_TRANSACTION1,\n\t\t\t\t DC_I2C_STOP_ON_NACK0, 1,\n\t\t\t\t DC_I2C_START0, 1,\n\t\t\t\t DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),\n\t\t\t\t DC_I2C_COUNT0, length,\n\t\t\t\t DC_I2C_STOP0, last_transaction ? 1 : 0);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE_5(DC_I2C_TRANSACTION2,\n\t\t\t\t DC_I2C_STOP_ON_NACK0, 1,\n\t\t\t\t DC_I2C_START0, 1,\n\t\t\t\t DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),\n\t\t\t\t DC_I2C_COUNT0, length,\n\t\t\t\t DC_I2C_STOP0, last_transaction ? 1 : 0);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE_5(DC_I2C_TRANSACTION3,\n\t\t\t\t DC_I2C_STOP_ON_NACK0, 1,\n\t\t\t\t DC_I2C_START0, 1,\n\t\t\t\t DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),\n\t\t\t\t DC_I2C_COUNT0, length,\n\t\t\t\t DC_I2C_STOP0, last_transaction ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (dce_i2c_hw->transaction_count == 0) {\n\t\tvalue = REG_SET_4(DC_I2C_DATA, 0,\n\t\t\t\t  DC_I2C_DATA_RW, false,\n\t\t\t\t  DC_I2C_DATA, request->address,\n\t\t\t\t  DC_I2C_INDEX, 0,\n\t\t\t\t  DC_I2C_INDEX_WRITE, 1);\n\t\tdce_i2c_hw->buffer_used_write = 0;\n\t} else\n\t\tvalue = REG_SET_2(DC_I2C_DATA, 0,\n\t\t\t  DC_I2C_DATA_RW, false,\n\t\t\t  DC_I2C_DATA, request->address);\n\n\tdce_i2c_hw->buffer_used_write++;\n\n\tif (!(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)) {\n\t\twhile (length) {\n\t\t\tREG_SET_2(DC_I2C_DATA, value,\n\t\t\t\t  DC_I2C_INDEX_WRITE, 0,\n\t\t\t\t  DC_I2C_DATA, *buffer++);\n\t\t\tdce_i2c_hw->buffer_used_write++;\n\t\t\t--length;\n\t\t}\n\t}\n\n\t++dce_i2c_hw->transaction_count;\n\tdce_i2c_hw->buffer_used_bytes += length + 1;\n\n\treturn last_transaction;\n}\n\nstatic inline void reset_hw_engine(struct dce_i2c_hw *dce_i2c_hw)\n{\n\tREG_UPDATE_2(DC_I2C_CONTROL,\n\t\t     DC_I2C_SW_STATUS_RESET, 1,\n\t\t     DC_I2C_SW_STATUS_RESET, 1);\n}\n\nstatic void set_speed(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tuint32_t speed)\n{\n\tuint32_t xtal_ref_div = 0, ref_base_div = 0;\n\tuint32_t prescale = 0;\n\tuint32_t i2c_ref_clock = 0;\n\n\tif (speed == 0)\n\t\treturn;\n\n\tREG_GET_2(MICROSECOND_TIME_BASE_DIV, MICROSECOND_TIME_BASE_DIV, &ref_base_div,\n\t\tXTAL_REF_DIV, &xtal_ref_div);\n\n\tif (xtal_ref_div == 0)\n\t\txtal_ref_div = 2;\n\n\tif (ref_base_div == 0)\n\t\ti2c_ref_clock = (dce_i2c_hw->reference_frequency * 2);\n\telse\n\t\ti2c_ref_clock = ref_base_div * 1000;\n\n\tprescale = (i2c_ref_clock / xtal_ref_div) / speed;\n\n\tif (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)\n\t\tREG_UPDATE_N(SPEED, 3,\n\t\t\t     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,\n\t\t\t     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,\n\t\t\t     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);\n\telse\n\t\tREG_UPDATE_N(SPEED, 2,\n\t\t\t     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,\n\t\t\t     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);\n}\n\nstatic bool setup_engine(\n\tstruct dce_i2c_hw *dce_i2c_hw)\n{\n\tuint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;\n\tuint32_t  reset_length = 0;\n\n        if (dce_i2c_hw->ctx->dc->debug.enable_mem_low_power.bits.i2c) {\n\t     if (dce_i2c_hw->regs->DIO_MEM_PWR_CTRL) {\n\t\t     REG_UPDATE(DIO_MEM_PWR_CTRL, I2C_LIGHT_SLEEP_FORCE, 0);\n\t\t     REG_WAIT(DIO_MEM_PWR_STATUS, I2C_MEM_PWR_STATE, 0, 0, 5);\n\t\t     }\n\t     }\n\n\t \n\tREG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);\n\n\t \n\tREG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);\n\n\t \n\tset_speed(dce_i2c_hw, dce_i2c_hw->ctx->dc->caps.i2c_speed_in_khz);\n\n\tif (dce_i2c_hw->setup_limit != 0)\n\t\ti2c_setup_limit = dce_i2c_hw->setup_limit;\n\n\t \n\tREG_UPDATE_6(DC_I2C_CONTROL,\n\t\t     DC_I2C_GO, 0,\n\t\t     DC_I2C_SOFT_RESET, 0,\n\t\t     DC_I2C_SEND_RESET, 0,\n\t\t     DC_I2C_SW_STATUS_RESET, 1,\n\t\t     DC_I2C_TRANSACTION_COUNT, 0,\n\t\t     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);\n\n\t \n\tif (dce_i2c_hw->send_reset_length == 0) {\n\t\t \n\t\tREG_UPDATE_N(SETUP, 2,\n\t\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,\n\t\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);\n\t} else {\n\t\treset_length = dce_i2c_hw->send_reset_length;\n\t\tREG_UPDATE_N(SETUP, 3,\n\t\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,\n\t\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_SEND_RESET_LENGTH), reset_length,\n\t\t\t     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);\n\t}\n\t \n\tREG_UPDATE(DC_I2C_ARBITRATION,\n\t\t\tDC_I2C_NO_QUEUED_SW_GO, 0);\n\n\treturn true;\n}\n\nstatic void release_engine(\n\tstruct dce_i2c_hw *dce_i2c_hw)\n{\n\tbool safe_to_reset;\n\n\n\t \n\t{\n\t\tuint32_t i2c_sw_status = 0;\n\n\t\tREG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);\n\t\t \n\t\tsafe_to_reset = (i2c_sw_status == 1);\n\t}\n\n\tif (safe_to_reset)\n\t\tREG_UPDATE_2(DC_I2C_CONTROL,\n\t\t\t     DC_I2C_SOFT_RESET, 1,\n\t\t\t     DC_I2C_SW_STATUS_RESET, 1);\n\telse\n\t\tREG_UPDATE(DC_I2C_CONTROL, DC_I2C_SW_STATUS_RESET, 1);\n\t \n\tif (!dce_i2c_hw->engine_keep_power_up_count)\n\t\tREG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);\n\n\t \n\tset_speed(dce_i2c_hw, dce_i2c_hw->ctx->dc->caps.i2c_speed_in_khz_hdcp);\n\t \n\tREG_UPDATE_2(DC_I2C_ARBITRATION, DC_I2C_SW_DONE_USING_I2C_REG, 1,\n\t\tDC_I2C_SW_USE_I2C_REG_REQ, 0);\n\n\tif (dce_i2c_hw->ctx->dc->debug.enable_mem_low_power.bits.i2c) {\n\t\tif (dce_i2c_hw->regs->DIO_MEM_PWR_CTRL)\n\t\t\tREG_UPDATE(DIO_MEM_PWR_CTRL, I2C_LIGHT_SLEEP_FORCE, 1);\n\t}\n}\n\nstruct dce_i2c_hw *acquire_i2c_hw_engine(\n\tstruct resource_pool *pool,\n\tstruct ddc *ddc)\n{\n\tuint32_t counter = 0;\n\tenum gpio_result result;\n\tstruct dce_i2c_hw *dce_i2c_hw = NULL;\n\n\tif (!ddc)\n\t\treturn NULL;\n\n\tif (ddc->hw_info.hw_supported) {\n\t\tenum gpio_ddc_line line = dal_ddc_get_line(ddc);\n\n\t\tif (line < pool->res_cap->num_ddc)\n\t\t\tdce_i2c_hw = pool->hw_i2cs[line];\n\t}\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tif (pool->i2c_hw_buffer_in_use || !is_engine_available(dce_i2c_hw))\n\t\treturn NULL;\n\n\tdo {\n\t\tresult = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,\n\t\t\tGPIO_DDC_CONFIG_TYPE_MODE_I2C);\n\n\t\tif (result == GPIO_RESULT_OK)\n\t\t\tbreak;\n\n\t\t \n\n\t\tudelay(10);\n\n\t\t++counter;\n\t} while (counter < 2);\n\n\tif (result != GPIO_RESULT_OK)\n\t\treturn NULL;\n\n\tdce_i2c_hw->ddc = ddc;\n\n\tif (!setup_engine(dce_i2c_hw)) {\n\t\trelease_engine(dce_i2c_hw);\n\t\treturn NULL;\n\t}\n\n\tpool->i2c_hw_buffer_in_use = true;\n\treturn dce_i2c_hw;\n}\n\nstatic enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(struct dce_i2c_hw *dce_i2c_hw,\n\t\t\t\t\t\t\t\t\t\t    uint32_t timeout,\n\t\t\t\t\t\t\t\t\t\t    enum i2c_channel_operation_result expected_result)\n{\n\tenum i2c_channel_operation_result result;\n\tuint32_t i = 0;\n\n\tif (!timeout)\n\t\treturn I2C_CHANNEL_OPERATION_SUCCEEDED;\n\n\tdo {\n\n\t\tresult = get_channel_status(\n\t\t\t\tdce_i2c_hw, NULL);\n\n\t\tif (result != expected_result)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\n\t\t++i;\n\t} while (i < timeout);\n\treturn result;\n}\n\nstatic void submit_channel_request_hw(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct i2c_request_transaction_data *request)\n{\n\trequest->status = I2C_CHANNEL_OPERATION_SUCCEEDED;\n\n\tif (!process_transaction(dce_i2c_hw, request))\n\t\treturn;\n\n\tif (is_hw_busy(dce_i2c_hw)) {\n\t\trequest->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;\n\t\treturn;\n\t}\n\treset_hw_engine(dce_i2c_hw);\n\n\texecute_transaction(dce_i2c_hw);\n\n\n}\n\nstatic uint32_t get_transaction_timeout_hw(\n\tconst struct dce_i2c_hw *dce_i2c_hw,\n\tuint32_t length,\n\tuint32_t speed)\n{\n\tuint32_t period_timeout;\n\tuint32_t num_of_clock_stretches;\n\n\tif (!speed)\n\t\treturn 0;\n\n\tperiod_timeout = (1000 * TRANSACTION_TIMEOUT_IN_I2C_CLOCKS) / speed;\n\n\tnum_of_clock_stretches = 1 + (length << 3) + 1;\n\tnum_of_clock_stretches +=\n\t\t(dce_i2c_hw->buffer_used_bytes << 3) +\n\t\t(dce_i2c_hw->transaction_count << 1);\n\n\treturn period_timeout * num_of_clock_stretches;\n}\n\nstatic bool dce_i2c_hw_engine_submit_payload(struct dce_i2c_hw *dce_i2c_hw,\n\t\t\t\t\t     struct i2c_payload *payload,\n\t\t\t\t\t     bool middle_of_transaction,\n\t\t\t\t\t     uint32_t speed)\n{\n\n\tstruct i2c_request_transaction_data request;\n\n\tuint32_t transaction_timeout;\n\n\tenum i2c_channel_operation_result operation_result;\n\n\tbool result = false;\n\n\t \n\n\tif (payload->length >=\n\t\t\tget_hw_buffer_available_size(dce_i2c_hw)) {\n\t\treturn false;\n\t}\n\n\tif (!payload->write)\n\t\trequest.action = middle_of_transaction ?\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_READ_MOT :\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_READ;\n\telse\n\t\trequest.action = middle_of_transaction ?\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_WRITE_MOT :\n\t\t\tDCE_I2C_TRANSACTION_ACTION_I2C_WRITE;\n\n\n\trequest.address = (uint8_t) ((payload->address << 1) | !payload->write);\n\trequest.length = payload->length;\n\trequest.data = payload->data;\n\n\t \n\n\ttransaction_timeout = get_transaction_timeout_hw(\n\t\tdce_i2c_hw, payload->length + 1, speed);\n\n\tsubmit_channel_request_hw(\n\t\tdce_i2c_hw, &request);\n\n\tif ((request.status == I2C_CHANNEL_OPERATION_FAILED) ||\n\t\t(request.status == I2C_CHANNEL_OPERATION_ENGINE_BUSY))\n\t\treturn false;\n\n\t \n\n\toperation_result = dce_i2c_hw_engine_wait_on_operation_result(\n\t\tdce_i2c_hw,\n\t\ttransaction_timeout,\n\t\tI2C_CHANNEL_OPERATION_ENGINE_BUSY);\n\n\t \n\n\tif (operation_result == I2C_CHANNEL_OPERATION_SUCCEEDED)\n\t\tresult = true;\n\n\tif (result && (!payload->write))\n\t\tprocess_channel_reply(dce_i2c_hw, payload);\n\n\treturn result;\n}\n\nbool dce_i2c_submit_command_hw(\n\tstruct resource_pool *pool,\n\tstruct ddc *ddc,\n\tstruct i2c_command *cmd,\n\tstruct dce_i2c_hw *dce_i2c_hw)\n{\n\tuint8_t index_of_payload = 0;\n\tbool result;\n\n\tset_speed(dce_i2c_hw, cmd->speed);\n\n\tresult = true;\n\n\twhile (index_of_payload < cmd->number_of_payloads) {\n\t\tbool mot = (index_of_payload != cmd->number_of_payloads - 1);\n\n\t\tstruct i2c_payload *payload = cmd->payloads + index_of_payload;\n\n\t\tif (!dce_i2c_hw_engine_submit_payload(\n\t\t\t\tdce_i2c_hw, payload, mot, cmd->speed)) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t++index_of_payload;\n\t}\n\n\tpool->i2c_hw_buffer_in_use = false;\n\n\trelease_engine(dce_i2c_hw);\n\tdal_ddc_close(dce_i2c_hw->ddc);\n\n\tdce_i2c_hw->ddc = NULL;\n\n\treturn result;\n}\n\nvoid dce_i2c_hw_construct(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct dc_context *ctx,\n\tuint32_t engine_id,\n\tconst struct dce_i2c_registers *regs,\n\tconst struct dce_i2c_shift *shifts,\n\tconst struct dce_i2c_mask *masks)\n{\n\tdce_i2c_hw->ctx = ctx;\n\tdce_i2c_hw->engine_id = engine_id;\n\tdce_i2c_hw->reference_frequency = (ctx->dc_bios->fw_info.pll_info.crystal_frequency) >> 1;\n\tdce_i2c_hw->regs = regs;\n\tdce_i2c_hw->shifts = shifts;\n\tdce_i2c_hw->masks = masks;\n\tdce_i2c_hw->buffer_used_bytes = 0;\n\tdce_i2c_hw->transaction_count = 0;\n\tdce_i2c_hw->engine_keep_power_up_count = 1;\n\tdce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED;\n\tdce_i2c_hw->send_reset_length = 0;\n\tdce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCE;\n\tdce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE;\n}\n\nvoid dce100_i2c_hw_construct(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct dc_context *ctx,\n\tuint32_t engine_id,\n\tconst struct dce_i2c_registers *regs,\n\tconst struct dce_i2c_shift *shifts,\n\tconst struct dce_i2c_mask *masks)\n{\n\tdce_i2c_hw_construct(dce_i2c_hw,\n\t\t\tctx,\n\t\t\tengine_id,\n\t\t\tregs,\n\t\t\tshifts,\n\t\t\tmasks);\n\tdce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE100;\n}\n\nvoid dce112_i2c_hw_construct(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct dc_context *ctx,\n\tuint32_t engine_id,\n\tconst struct dce_i2c_registers *regs,\n\tconst struct dce_i2c_shift *shifts,\n\tconst struct dce_i2c_mask *masks)\n{\n\tdce100_i2c_hw_construct(dce_i2c_hw,\n\t\t\tctx,\n\t\t\tengine_id,\n\t\t\tregs,\n\t\t\tshifts,\n\t\t\tmasks);\n\tdce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED_100KHZ;\n}\n\nvoid dcn1_i2c_hw_construct(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct dc_context *ctx,\n\tuint32_t engine_id,\n\tconst struct dce_i2c_registers *regs,\n\tconst struct dce_i2c_shift *shifts,\n\tconst struct dce_i2c_mask *masks)\n{\n\tdce112_i2c_hw_construct(dce_i2c_hw,\n\t\t\tctx,\n\t\t\tengine_id,\n\t\t\tregs,\n\t\t\tshifts,\n\t\t\tmasks);\n\tdce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCN;\n}\n\nvoid dcn2_i2c_hw_construct(\n\tstruct dce_i2c_hw *dce_i2c_hw,\n\tstruct dc_context *ctx,\n\tuint32_t engine_id,\n\tconst struct dce_i2c_registers *regs,\n\tconst struct dce_i2c_shift *shifts,\n\tconst struct dce_i2c_mask *masks)\n{\n\tdcn1_i2c_hw_construct(dce_i2c_hw,\n\t\t\tctx,\n\t\t\tengine_id,\n\t\t\tregs,\n\t\t\tshifts,\n\t\t\tmasks);\n\tdce_i2c_hw->send_reset_length = I2C_SEND_RESET_LENGTH_9;\n\tif (ctx->dc->debug.scl_reset_length10)\n\t\tdce_i2c_hw->send_reset_length = I2C_SEND_RESET_LENGTH_10;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}