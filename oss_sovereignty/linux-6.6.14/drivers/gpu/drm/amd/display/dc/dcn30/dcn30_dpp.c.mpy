{
  "module_name": "dcn30_dpp.c",
  "hash_id": "7b509bcf8a4a48ecd845a353ca62e3b8b940b4fe4eaafd01d790dd7b0907ce4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dpp.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n#include \"reg_helper.h\"\n#include \"dcn30_dpp.h\"\n#include \"basics/conversion.h\"\n#include \"dcn30_cm_common.h\"\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\n\nvoid dpp30_read_state(struct dpp *dpp_base, struct dcn_dpp_state *s)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_GET(DPP_CONTROL,\n\t\t\tDPP_CLOCK_ENABLE, &s->is_enabled);\n\n\t\n}\n \nvoid dpp3_program_post_csc(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_color_space color_space,\n\t\tenum dcn10_input_csc_select input_select,\n\t\tconst struct out_csc_color_matrix *tbl_entry)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tint i;\n\tint arr_size = sizeof(dpp_input_csc_matrix)/sizeof(struct dpp_input_csc_matrix);\n\tconst uint16_t *regval = NULL;\n\tuint32_t cur_select = 0;\n\tenum dcn10_input_csc_select select;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (input_select == INPUT_CSC_SELECT_BYPASS) {\n\t\tREG_SET(CM_POST_CSC_CONTROL, 0, CM_POST_CSC_MODE, 0);\n\t\treturn;\n\t}\n\n\tif (tbl_entry == NULL) {\n\t\tfor (i = 0; i < arr_size; i++)\n\t\t\tif (dpp_input_csc_matrix[i].color_space == color_space) {\n\t\t\t\tregval = dpp_input_csc_matrix[i].regval;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (regval == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tregval = tbl_entry->regval;\n\t}\n\n\t \n\tREG_GET(CM_POST_CSC_CONTROL,\n\t\t\tCM_POST_CSC_MODE_CURRENT, &cur_select);\n\n\tif (cur_select != INPUT_CSC_SELECT_ICSC)\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\telse\n\t\tselect = INPUT_CSC_SELECT_COMA;\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_POST_CSC_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_POST_CSC_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_POST_CSC_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_POST_CSC_C12;\n\n\tif (select == INPUT_CSC_SELECT_ICSC) {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_POST_CSC_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_POST_CSC_C33_C34);\n\n\t} else {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_POST_CSC_B_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_POST_CSC_B_C33_C34);\n\n\t}\n\n\tcm_helper_program_color_matrices(\n\t\t\tdpp->base.ctx,\n\t\t\tregval,\n\t\t\t&gam_regs);\n\n\tREG_SET(CM_POST_CSC_CONTROL, 0,\n\t\t\tCM_POST_CSC_MODE, select);\n}\n\n\n \nvoid dpp3_set_pre_degam(struct dpp *dpp_base, enum dc_transfer_func_predefined tr)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tint pre_degam_en = 1;\n\tint degamma_lut_selection = 0;\n\n\tswitch (tr) {\n\tcase TRANSFER_FUNCTION_LINEAR:\n\tcase TRANSFER_FUNCTION_UNITY:\n\t\tpre_degam_en = 0; \n\t\tbreak;\n\tcase TRANSFER_FUNCTION_SRGB:\n\t\tdegamma_lut_selection = 0;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_BT709:\n\t\tdegamma_lut_selection = 4;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_PQ:\n\t\tdegamma_lut_selection = 5;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_HLG:\n\t\tdegamma_lut_selection = 6;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_GAMMA22:\n\t\tdegamma_lut_selection = 1;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_GAMMA24:\n\t\tdegamma_lut_selection = 2;\n\t\tbreak;\n\tcase TRANSFER_FUNCTION_GAMMA26:\n\t\tdegamma_lut_selection = 3;\n\t\tbreak;\n\tdefault:\n\t\tpre_degam_en = 0;\n\t\tbreak;\n\t}\n\n\tREG_SET_2(PRE_DEGAM, 0,\n\t\t\tPRE_DEGAM_MODE, pre_degam_en,\n\t\t\tPRE_DEGAM_SELECT, degamma_lut_selection);\n}\n\nvoid dpp3_cnv_setup (\n\t\tstruct dpp *dpp_base,\n\t\tenum surface_pixel_format format,\n\t\tenum expansion_mode mode,\n\t\tstruct dc_csc_transform input_csc_color_matrix,\n\t\tenum dc_color_space input_color_space,\n\t\tstruct cnv_alpha_2bit_lut *alpha_2bit_lut)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tuint32_t pixel_format = 0;\n\tuint32_t alpha_en = 1;\n\tenum dc_color_space color_space = COLOR_SPACE_SRGB;\n\tenum dcn10_input_csc_select select = INPUT_CSC_SELECT_BYPASS;\n\tbool force_disable_cursor = false;\n\tuint32_t is_2bit = 0;\n\tuint32_t alpha_plane_enable = 0;\n\tuint32_t dealpha_en = 0, dealpha_ablnd_en = 0;\n\tuint32_t realpha_en = 0, realpha_ablnd_en = 0;\n\tuint32_t program_prealpha_dealpha = 0;\n\tstruct out_csc_color_matrix tbl_entry;\n\tint i;\n\n\tREG_SET_2(FORMAT_CONTROL, 0,\n\t\tCNVC_BYPASS, 0,\n\t\tFORMAT_EXPANSION_MODE, mode);\n\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CNV16, 0);\n\tREG_UPDATE(FORMAT_CONTROL, CNVC_BYPASS_MSB_ALIGN, 0);\n\tREG_UPDATE(FORMAT_CONTROL, CLAMP_POSITIVE, 0);\n\tREG_UPDATE(FORMAT_CONTROL, CLAMP_POSITIVE_C, 0);\n\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CROSSBAR_R, 0);\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CROSSBAR_G, 1);\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CROSSBAR_B, 2);\n\n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\tpixel_format = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\tpixel_format = 3;\n\t\talpha_en = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\tpixel_format = 8;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\t\tpixel_format = 10;\n\t\tis_2bit = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\t\tforce_disable_cursor = false;\n\t\tpixel_format = 65;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 64;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 67;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\tforce_disable_cursor = true;\n\t\tpixel_format = 66;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\t\tpixel_format = 26;  \n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\t\tpixel_format = 24;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\tpixel_format = 25;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_AYCrCb8888:\n\t\tpixel_format = 12;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FIX:\n\t\tpixel_format = 112;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FIX:\n\t\tpixel_format = 113;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_ACrYCb2101010:\n\t\tpixel_format = 114;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tis_2bit = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_CrYCbA1010102:\n\t\tpixel_format = 115;\n\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\tis_2bit = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGBE:\n\t\tpixel_format = 116;\n\t\talpha_plane_enable = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA:\n\t\tpixel_format = 116;\n\t\talpha_plane_enable = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FLOAT:\n\t\tpixel_format = 118;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FLOAT:\n\t\tpixel_format = 119;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tcolor_space = input_color_space ? input_color_space : color_space;\n\n\tif (is_2bit == 1 && alpha_2bit_lut != NULL) {\n\t\tREG_UPDATE(ALPHA_2BIT_LUT, ALPHA_2BIT_LUT0, alpha_2bit_lut->lut0);\n\t\tREG_UPDATE(ALPHA_2BIT_LUT, ALPHA_2BIT_LUT1, alpha_2bit_lut->lut1);\n\t\tREG_UPDATE(ALPHA_2BIT_LUT, ALPHA_2BIT_LUT2, alpha_2bit_lut->lut2);\n\t\tREG_UPDATE(ALPHA_2BIT_LUT, ALPHA_2BIT_LUT3, alpha_2bit_lut->lut3);\n\t}\n\n\tREG_SET_2(CNVC_SURFACE_PIXEL_FORMAT, 0,\n\t\t\tCNVC_SURFACE_PIXEL_FORMAT, pixel_format,\n\t\t\tCNVC_ALPHA_PLANE_ENABLE, alpha_plane_enable);\n\tREG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);\n\n\tif (program_prealpha_dealpha) {\n\t\tdealpha_en = 1;\n\t\trealpha_en = 1;\n\t}\n\tREG_SET_2(PRE_DEALPHA, 0,\n\t\t\tPRE_DEALPHA_EN, dealpha_en,\n\t\t\tPRE_DEALPHA_ABLND_EN, dealpha_ablnd_en);\n\tREG_SET_2(PRE_REALPHA, 0,\n\t\t\tPRE_REALPHA_EN, realpha_en,\n\t\t\tPRE_REALPHA_ABLND_EN, realpha_ablnd_en);\n\n\t \n\tif (input_csc_color_matrix.enable_adjustment == true) {\n\t\tfor (i = 0; i < 12; i++)\n\t\t\ttbl_entry.regval[i] = input_csc_color_matrix.matrix[i];\n\n\t\ttbl_entry.color_space = input_color_space;\n\n\t\tif (color_space >= COLOR_SPACE_YCBCR601)\n\t\t\tselect = INPUT_CSC_SELECT_ICSC;\n\t\telse\n\t\t\tselect = INPUT_CSC_SELECT_BYPASS;\n\n\t\tdpp3_program_post_csc(dpp_base, color_space, select,\n\t\t\t\t      &tbl_entry);\n\t} else {\n\t\tdpp3_program_post_csc(dpp_base, color_space, select, NULL);\n\t}\n\n\tif (force_disable_cursor) {\n\t\tREG_UPDATE(CURSOR_CONTROL,\n\t\t\t\tCURSOR_ENABLE, 0);\n\t\tREG_UPDATE(CURSOR0_CONTROL,\n\t\t\t\tCUR0_ENABLE, 0);\n\t}\n}\n\n#define IDENTITY_RATIO(ratio) (dc_fixpt_u3d19(ratio) == (1 << 19))\n\nvoid dpp3_set_cursor_attributes(\n\t\tstruct dpp *dpp_base,\n\t\tstruct dc_cursor_attributes *cursor_attributes)\n{\n\tenum dc_cursor_color_format color_format = cursor_attributes->color_format;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tint cur_rom_en = 0;\n\n\tif (color_format == CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA ||\n\t\tcolor_format == CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA) {\n\t\tif (cursor_attributes->attribute_flags.bits.ENABLE_CURSOR_DEGAMMA) {\n\t\t\tcur_rom_en = 1;\n\t\t}\n\t}\n\n\tREG_UPDATE_3(CURSOR0_CONTROL,\n\t\t\tCUR0_MODE, color_format,\n\t\t\tCUR0_EXPANSION_MODE, 0,\n\t\t\tCUR0_ROM_EN, cur_rom_en);\n\n\tif (color_format == CURSOR_MODE_MONO) {\n\t\t \n\t\tREG_UPDATE(CURSOR0_COLOR0,\n\t\t\t\tCUR0_COLOR0, 0x00000000);\n\t\tREG_UPDATE(CURSOR0_COLOR1,\n\t\t\t\tCUR0_COLOR1, 0xFFFFFFFF);\n\t}\n\n\tdpp_base->att.cur0_ctl.bits.expansion_mode = 0;\n\tdpp_base->att.cur0_ctl.bits.cur0_rom_en = cur_rom_en;\n\tdpp_base->att.cur0_ctl.bits.mode = color_format;\n}\n\n\nbool dpp3_get_optimal_number_of_taps(\n\t\tstruct dpp *dpp,\n\t\tstruct scaler_data *scl_data,\n\t\tconst struct scaling_taps *in_taps)\n{\n\tint num_part_y, num_part_c;\n\tint max_taps_y, max_taps_c;\n\tint min_taps_y, min_taps_c;\n\tenum lb_memory_config lb_config;\n\n\tif (scl_data->viewport.width > scl_data->h_active &&\n\t\tdpp->ctx->dc->debug.max_downscale_src_width != 0 &&\n\t\tscl_data->viewport.width > dpp->ctx->dc->debug.max_downscale_src_width)\n\t\treturn false;\n\n\t \n\tif (in_taps->h_taps == 0) {\n\t\tif (dc_fixpt_ceil(scl_data->ratios.horz) > 1)\n\t\t\tscl_data->taps.h_taps = min(2 * dc_fixpt_ceil(scl_data->ratios.horz), 8);\n\t\telse\n\t\t\tscl_data->taps.h_taps = 4;\n\t} else\n\t\tscl_data->taps.h_taps = in_taps->h_taps;\n\tif (in_taps->v_taps == 0) {\n\t\tif (dc_fixpt_ceil(scl_data->ratios.vert) > 1)\n\t\t\tscl_data->taps.v_taps = min(dc_fixpt_ceil(dc_fixpt_mul_int(scl_data->ratios.vert, 2)), 8);\n\t\telse\n\t\t\tscl_data->taps.v_taps = 4;\n\t} else\n\t\tscl_data->taps.v_taps = in_taps->v_taps;\n\tif (in_taps->v_taps_c == 0) {\n\t\tif (dc_fixpt_ceil(scl_data->ratios.vert_c) > 1)\n\t\t\tscl_data->taps.v_taps_c = min(dc_fixpt_ceil(dc_fixpt_mul_int(scl_data->ratios.vert_c, 2)), 8);\n\t\telse\n\t\t\tscl_data->taps.v_taps_c = 4;\n\t} else\n\t\tscl_data->taps.v_taps_c = in_taps->v_taps_c;\n\tif (in_taps->h_taps_c == 0) {\n\t\tif (dc_fixpt_ceil(scl_data->ratios.horz_c) > 1)\n\t\t\tscl_data->taps.h_taps_c = min(2 * dc_fixpt_ceil(scl_data->ratios.horz_c), 8);\n\t\telse\n\t\t\tscl_data->taps.h_taps_c = 4;\n\t} else if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)\n\t\t \n\t\tscl_data->taps.h_taps_c = in_taps->h_taps_c - 1;\n\telse\n\t\tscl_data->taps.h_taps_c = in_taps->h_taps_c;\n\n\t \n\tmin_taps_y = dc_fixpt_ceil(scl_data->ratios.vert);\n\tmin_taps_c = dc_fixpt_ceil(scl_data->ratios.vert_c);\n\n\t \n\tif ((scl_data->format == PIXEL_FORMAT_420BPP8) || (scl_data->format == PIXEL_FORMAT_420BPP10))\n\t\tlb_config = LB_MEMORY_CONFIG_3;\n\telse\n\t\tlb_config = LB_MEMORY_CONFIG_0;\n\n\tdpp->caps->dscl_calc_lb_num_partitions(\n\t\t\tscl_data, lb_config, &num_part_y, &num_part_c);\n\n\t \n\tif (dc_fixpt_ceil(scl_data->ratios.vert) > 2)\n\t\tmax_taps_y = num_part_y - (dc_fixpt_ceil(scl_data->ratios.vert) - 2);\n\telse\n\t\tmax_taps_y = num_part_y;\n\n\tif (dc_fixpt_ceil(scl_data->ratios.vert_c) > 2)\n\t\tmax_taps_c = num_part_c - (dc_fixpt_ceil(scl_data->ratios.vert_c) - 2);\n\telse\n\t\tmax_taps_c = num_part_c;\n\n\tif (max_taps_y < min_taps_y)\n\t\treturn false;\n\telse if (max_taps_c < min_taps_c)\n\t\treturn false;\n\n\tif (scl_data->taps.v_taps > max_taps_y)\n\t\tscl_data->taps.v_taps = max_taps_y;\n\n\tif (scl_data->taps.v_taps_c > max_taps_c)\n\t\tscl_data->taps.v_taps_c = max_taps_c;\n\n\tif (!dpp->ctx->dc->debug.always_scale) {\n\t\tif (IDENTITY_RATIO(scl_data->ratios.horz))\n\t\t\tscl_data->taps.h_taps = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.vert))\n\t\t\tscl_data->taps.v_taps = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.horz_c))\n\t\t\tscl_data->taps.h_taps_c = 1;\n\t\tif (IDENTITY_RATIO(scl_data->ratios.vert_c))\n\t\t\tscl_data->taps.v_taps_c = 1;\n\t}\n\n\treturn true;\n}\n\nstatic void dpp3_deferred_update(struct dpp *dpp_base)\n{\n\tint bypass_state;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (dpp_base->deferred_reg_writes.bits.disable_dscl) {\n\t\tREG_UPDATE(DSCL_MEM_PWR_CTRL, LUT_MEM_PWR_FORCE, 3);\n\t\tdpp_base->deferred_reg_writes.bits.disable_dscl = false;\n\t}\n\n\tif (dpp_base->deferred_reg_writes.bits.disable_gamcor) {\n\t\tREG_GET(CM_GAMCOR_CONTROL, CM_GAMCOR_MODE_CURRENT, &bypass_state);\n\t\tif (bypass_state == 0) {\t\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL, GAMCOR_MEM_PWR_FORCE, 3);\n\t\t} else\n\t\t\tASSERT(0); \n\t\tdpp_base->deferred_reg_writes.bits.disable_gamcor = false;\n\t}\n\n\tif (dpp_base->deferred_reg_writes.bits.disable_blnd_lut) {\n\t\tREG_GET(CM_BLNDGAM_CONTROL, CM_BLNDGAM_MODE_CURRENT, &bypass_state);\n\t\tif (bypass_state == 0) {\t\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL, BLNDGAM_MEM_PWR_FORCE, 3);\n\t\t} else\n\t\t\tASSERT(0); \n\t\tdpp_base->deferred_reg_writes.bits.disable_blnd_lut = false;\n\t}\n\n\tif (dpp_base->deferred_reg_writes.bits.disable_3dlut) {\n\t\tREG_GET(CM_3DLUT_MODE, CM_3DLUT_MODE_CURRENT, &bypass_state);\n\t\tif (bypass_state == 0) {\t\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL2, HDR3DLUT_MEM_PWR_FORCE, 3);\n\t\t} else\n\t\t\tASSERT(0); \n\t\tdpp_base->deferred_reg_writes.bits.disable_3dlut = false;\n\t}\n\n\tif (dpp_base->deferred_reg_writes.bits.disable_shaper) {\n\t\tREG_GET(CM_SHAPER_CONTROL, CM_SHAPER_MODE_CURRENT, &bypass_state);\n\t\tif (bypass_state == 0) {\t\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL2, SHAPER_MEM_PWR_FORCE, 3);\n\t\t} else\n\t\t\tASSERT(0); \n\t\tdpp_base->deferred_reg_writes.bits.disable_shaper = false;\n\t}\n}\n\nstatic void dpp3_power_on_blnd_lut(\n\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm) {\n\t\tif (power_on) {\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL, BLNDGAM_MEM_PWR_FORCE, 0);\n\t\t\tREG_WAIT(CM_MEM_PWR_STATUS, BLNDGAM_MEM_PWR_STATE, 0, 1, 5);\n\t\t} else {\n\t\t\tdpp_base->ctx->dc->optimized_required = true;\n\t\t\tdpp_base->deferred_reg_writes.bits.disable_blnd_lut = true;\n\t\t}\n\t} else {\n\t\tREG_SET(CM_MEM_PWR_CTRL, 0,\n\t\t\t\tBLNDGAM_MEM_PWR_FORCE, power_on == true ? 0 : 1);\n\t}\n}\n\nstatic void dpp3_power_on_hdr3dlut(\n\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm) {\n\t\tif (power_on) {\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL2, HDR3DLUT_MEM_PWR_FORCE, 0);\n\t\t\tREG_WAIT(CM_MEM_PWR_STATUS2, HDR3DLUT_MEM_PWR_STATE, 0, 1, 5);\n\t\t} else {\n\t\t\tdpp_base->ctx->dc->optimized_required = true;\n\t\t\tdpp_base->deferred_reg_writes.bits.disable_3dlut = true;\n\t\t}\n\t}\n}\n\nstatic void dpp3_power_on_shaper(\n\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm) {\n\t\tif (power_on) {\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL2, SHAPER_MEM_PWR_FORCE, 0);\n\t\t\tREG_WAIT(CM_MEM_PWR_STATUS2, SHAPER_MEM_PWR_STATE, 0, 1, 5);\n\t\t} else {\n\t\t\tdpp_base->ctx->dc->optimized_required = true;\n\t\t\tdpp_base->deferred_reg_writes.bits.disable_shaper = true;\n\t\t}\n\t}\n}\n\nstatic void dpp3_configure_blnd_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE_2(CM_BLNDGAM_LUT_CONTROL,\n\t\t\tCM_BLNDGAM_LUT_WRITE_COLOR_MASK, 7,\n\t\t\tCM_BLNDGAM_LUT_HOST_SEL, is_ram_a == true ? 0 : 1);\n\n\tREG_SET(CM_BLNDGAM_LUT_INDEX, 0, CM_BLNDGAM_LUT_INDEX, 0);\n}\n\nstatic void dpp3_program_blnd_pwl(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num)\n{\n\tuint32_t i;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tuint32_t last_base_value_red = rgb[num-1].red_reg + rgb[num-1].delta_red_reg;\n\tuint32_t last_base_value_green = rgb[num-1].green_reg + rgb[num-1].delta_green_reg;\n\tuint32_t last_base_value_blue = rgb[num-1].blue_reg + rgb[num-1].delta_blue_reg;\n\n\tif (is_rgb_equal(rgb, num)) {\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, last_base_value_red);\n\t} else {\n\t\tREG_UPDATE(CM_BLNDGAM_LUT_CONTROL, CM_BLNDGAM_LUT_WRITE_COLOR_MASK, 4);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, last_base_value_red);\n\n\t\tREG_UPDATE(CM_BLNDGAM_LUT_CONTROL, CM_BLNDGAM_LUT_WRITE_COLOR_MASK, 2);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].green_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, last_base_value_green);\n\n\t\tREG_UPDATE(CM_BLNDGAM_LUT_CONTROL, CM_BLNDGAM_LUT_WRITE_COLOR_MASK, 1);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, rgb[i].blue_reg);\n\t\tREG_SET(CM_BLNDGAM_LUT_DATA, 0, CM_BLNDGAM_LUT_DATA, last_base_value_blue);\n\t}\n}\n\nstatic void dcn3_dpp_cm_get_reg_field(\n\t\tstruct dcn3_dpp *dpp,\n\t\tstruct dcn3_xfer_func_reg *reg)\n{\n\treg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_B;\n\treg->masks.field_region_end = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->masks.field_region_linear_slope = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->shifts.exp_region_start = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_BLNDGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dpp->tf_mask->CM_BLNDGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n}\n\n \nstatic void dpp3_program_blnd_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tstruct dcn3_xfer_func_reg gam_regs;\n\n\tdcn3_dpp_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_BLNDGAM_RAMA_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_BLNDGAM_RAMA_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_BLNDGAM_RAMA_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_BLNDGAM_RAMA_START_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_BLNDGAM_RAMA_START_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_BLNDGAM_RAMA_START_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_BLNDGAM_RAMA_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_BLNDGAM_RAMA_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_BLNDGAM_RAMA_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_BLNDGAM_RAMA_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_BLNDGAM_RAMA_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_BLNDGAM_RAMA_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_BLNDGAM_RAMA_REGION_0_1);\n\tgam_regs.region_end = REG(CM_BLNDGAM_RAMA_REGION_32_33);\n\n\tcm_helper_program_gamcor_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\n \nstatic void dpp3_program_blnd_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tstruct dcn3_xfer_func_reg gam_regs;\n\n\tdcn3_dpp_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_BLNDGAM_RAMB_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_BLNDGAM_RAMB_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_BLNDGAM_RAMB_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_BLNDGAM_RAMB_START_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_BLNDGAM_RAMB_START_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_BLNDGAM_RAMB_START_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_BLNDGAM_RAMB_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_BLNDGAM_RAMB_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_BLNDGAM_RAMB_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_BLNDGAM_RAMB_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_BLNDGAM_RAMB_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_BLNDGAM_RAMB_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_BLNDGAM_RAMB_REGION_0_1);\n\tgam_regs.region_end = REG(CM_BLNDGAM_RAMB_REGION_32_33);\n\n\tcm_helper_program_gamcor_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\nstatic enum dc_lut_mode dpp3_get_blndgam_current(struct dpp *dpp_base)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t mode_current = 0;\n\tuint32_t in_use = 0;\n\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_GET(CM_BLNDGAM_CONTROL, CM_BLNDGAM_MODE_CURRENT, &mode_current);\n\tREG_GET(CM_BLNDGAM_CONTROL, CM_BLNDGAM_SELECT_CURRENT, &in_use);\n\n\tswitch (mode_current) {\n\tcase 0:\n\tcase 1:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\n\tcase 2:\n\t\tif (in_use == 0)\n\t\t\tmode = LUT_RAM_A;\n\t\telse\n\t\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic bool dpp3_program_blnd_lut(struct dpp *dpp_base,\n\t\t\t\t  const struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (params == NULL) {\n\t\tREG_SET(CM_BLNDGAM_CONTROL, 0, CM_BLNDGAM_MODE, 0);\n\t\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\t\tdpp3_power_on_blnd_lut(dpp_base, false);\n\t\treturn false;\n\t}\n\n\tcurrent_mode = dpp3_get_blndgam_current(dpp_base);\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_B)\n\t\tnext_mode = LUT_RAM_A;\n\telse\n\t\tnext_mode = LUT_RAM_B;\n\n\tdpp3_power_on_blnd_lut(dpp_base, true);\n\tdpp3_configure_blnd_lut(dpp_base, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_A)\n\t\tdpp3_program_blnd_luta_settings(dpp_base, params);\n\telse\n\t\tdpp3_program_blnd_lutb_settings(dpp_base, params);\n\n\tdpp3_program_blnd_pwl(\n\t\t\tdpp_base, params->rgb_resulted, params->hw_points_num);\n\n\tREG_UPDATE_2(CM_BLNDGAM_CONTROL,\n\t\t\tCM_BLNDGAM_MODE, 2,\n\t\t\tCM_BLNDGAM_SELECT, next_mode == LUT_RAM_A ? 0 : 1);\n\n\treturn true;\n}\n\n\nstatic void dpp3_program_shaper_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num)\n{\n\tuint32_t i, red, green, blue;\n\tuint32_t  red_delta, green_delta, blue_delta;\n\tuint32_t  red_value, green_value, blue_value;\n\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tfor (i = 0 ; i < num; i++) {\n\n\t\tred   = rgb[i].red_reg;\n\t\tgreen = rgb[i].green_reg;\n\t\tblue  = rgb[i].blue_reg;\n\n\t\tred_delta   = rgb[i].delta_red_reg;\n\t\tgreen_delta = rgb[i].delta_green_reg;\n\t\tblue_delta  = rgb[i].delta_blue_reg;\n\n\t\tred_value   = ((red_delta   & 0x3ff) << 14) | (red   & 0x3fff);\n\t\tgreen_value = ((green_delta & 0x3ff) << 14) | (green & 0x3fff);\n\t\tblue_value  = ((blue_delta  & 0x3ff) << 14) | (blue  & 0x3fff);\n\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, red_value);\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, green_value);\n\t\tREG_SET(CM_SHAPER_LUT_DATA, 0, CM_SHAPER_LUT_DATA, blue_value);\n\t}\n\n}\n\nstatic enum dc_lut_mode dpp3_get_shaper_current(struct dpp *dpp_base)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t state_mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_GET(CM_SHAPER_CONTROL, CM_SHAPER_MODE_CURRENT, &state_mode);\n\n\tswitch (state_mode) {\n\tcase 0:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\tcase 1:\n\t\tmode = LUT_RAM_A;\n\t\tbreak;\n\tcase 2:\n\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic void dpp3_configure_shaper_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE(CM_SHAPER_LUT_WRITE_EN_MASK,\n\t\t\tCM_SHAPER_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_SHAPER_LUT_WRITE_EN_MASK,\n\t\t\tCM_SHAPER_LUT_WRITE_SEL, is_ram_a == true ? 0:1);\n\tREG_SET(CM_SHAPER_LUT_INDEX, 0, CM_SHAPER_LUT_INDEX, 0);\n}\n\n \n\nstatic void dpp3_program_shaper_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tconst struct gamma_curve *curve;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_B, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_B, params->corner_points[0].blue.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_B, 0);\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_G, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_G, params->corner_points[0].green.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_G, 0);\n\tREG_SET_2(CM_SHAPER_RAMA_START_CNTL_R, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_R, params->corner_points[0].red.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_START_SEGMENT_R, 0);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_B, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_B, params->corner_points[1].blue.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_B, params->corner_points[1].blue.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_G, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_G, params->corner_points[1].green.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_G, params->corner_points[1].green.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMA_END_CNTL_R, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_R, params->corner_points[1].red.custom_float_x,\n\t\tCM_SHAPER_RAMA_EXP_REGION_END_BASE_R, params->corner_points[1].red.custom_float_y);\n\n\tcurve = params->arr_curve_points;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_0_1, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_2_3, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_4_5, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_6_7, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_8_9, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_10_11, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_12_13, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_14_15, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_16_17, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_18_19, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_20_21, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_22_23, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_24_25, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_26_27, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_28_29, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_30_31, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMA_REGION_32_33, 0,\n\t\tCM_SHAPER_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);\n}\n\n \nstatic void dpp3_program_shaper_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tconst struct gamma_curve *curve;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_B, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_B, params->corner_points[0].blue.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_B, 0);\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_G, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_G, params->corner_points[0].green.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_G, 0);\n\tREG_SET_2(CM_SHAPER_RAMB_START_CNTL_R, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_R, params->corner_points[0].red.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_START_SEGMENT_R, 0);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_B, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_B, params->corner_points[1].blue.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_B, params->corner_points[1].blue.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_G, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_G, params->corner_points[1].green.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_G, params->corner_points[1].green.custom_float_y);\n\n\tREG_SET_2(CM_SHAPER_RAMB_END_CNTL_R, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_R, params->corner_points[1].red.custom_float_x,\n\t\tCM_SHAPER_RAMB_EXP_REGION_END_BASE_R, params->corner_points[1].red.custom_float_y);\n\n\tcurve = params->arr_curve_points;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_0_1, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_2_3, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_4_5, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_6_7, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_8_9, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_10_11, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_12_13, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_14_15, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_16_17, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_18_19, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_20_21, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_22_23, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_24_25, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_26_27, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_28_29, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_30_31, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);\n\n\tcurve += 2;\n\tREG_SET_4(CM_SHAPER_RAMB_REGION_32_33, 0,\n\t\tCM_SHAPER_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,\n\t\tCM_SHAPER_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,\n\t\tCM_SHAPER_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);\n\n}\n\n\nstatic bool dpp3_program_shaper(struct dpp *dpp_base,\n\t\t\t\tconst struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (params == NULL) {\n\t\tREG_SET(CM_SHAPER_CONTROL, 0, CM_SHAPER_LUT_MODE, 0);\n\t\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\t\tdpp3_power_on_shaper(dpp_base, false);\n\t\treturn false;\n\t}\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\tdpp3_power_on_shaper(dpp_base, true);\n\n\tcurrent_mode = dpp3_get_shaper_current(dpp_base);\n\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)\n\t\tnext_mode = LUT_RAM_B;\n\telse\n\t\tnext_mode = LUT_RAM_A;\n\n\tdpp3_configure_shaper_lut(dpp_base, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_A)\n\t\tdpp3_program_shaper_luta_settings(dpp_base, params);\n\telse\n\t\tdpp3_program_shaper_lutb_settings(dpp_base, params);\n\n\tdpp3_program_shaper_lut(\n\t\t\tdpp_base, params->rgb_resulted, params->hw_points_num);\n\n\tREG_SET(CM_SHAPER_CONTROL, 0, CM_SHAPER_LUT_MODE, next_mode == LUT_RAM_A ? 1:2);\n\n\treturn true;\n\n}\n\nstatic enum dc_lut_mode get3dlut_config(\n\t\t\tstruct dpp *dpp_base,\n\t\t\tbool *is_17x17x17,\n\t\t\tbool *is_12bits_color_channel)\n{\n\tuint32_t i_mode, i_enable_10bits, lut_size;\n\tenum dc_lut_mode mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_GET(CM_3DLUT_READ_WRITE_CONTROL,\n\t\t\tCM_3DLUT_30BIT_EN, &i_enable_10bits);\n\tREG_GET(CM_3DLUT_MODE,\n\t\t\tCM_3DLUT_MODE_CURRENT, &i_mode);\n\n\tswitch (i_mode) {\n\tcase 0:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\tcase 1:\n\t\tmode = LUT_RAM_A;\n\t\tbreak;\n\tcase 2:\n\t\tmode = LUT_RAM_B;\n\t\tbreak;\n\tdefault:\n\t\tmode = LUT_BYPASS;\n\t\tbreak;\n\t}\n\tif (i_enable_10bits > 0)\n\t\t*is_12bits_color_channel = false;\n\telse\n\t\t*is_12bits_color_channel = true;\n\n\tREG_GET(CM_3DLUT_MODE, CM_3DLUT_SIZE, &lut_size);\n\n\tif (lut_size == 0)\n\t\t*is_17x17x17 = true;\n\telse\n\t\t*is_17x17x17 = false;\n\n\treturn mode;\n}\n \nstatic void dpp3_set_3dlut_mode(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_lut_mode mode,\n\t\tbool is_color_channel_12bits,\n\t\tbool is_lut_size17x17x17)\n{\n\tuint32_t lut_mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (mode == LUT_BYPASS)\n\t\tlut_mode = 0;\n\telse if (mode == LUT_RAM_A)\n\t\tlut_mode = 1;\n\telse\n\t\tlut_mode = 2;\n\n\tREG_UPDATE_2(CM_3DLUT_MODE,\n\t\t\tCM_3DLUT_MODE, lut_mode,\n\t\t\tCM_3DLUT_SIZE, is_lut_size17x17x17 == true ? 0 : 1);\n}\n\nstatic void dpp3_select_3dlut_ram(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_lut_mode mode,\n\t\tbool is_color_channel_12bits)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE_2(CM_3DLUT_READ_WRITE_CONTROL,\n\t\t\tCM_3DLUT_RAM_SEL, mode == LUT_RAM_A ? 0 : 1,\n\t\t\tCM_3DLUT_30BIT_EN,\n\t\t\tis_color_channel_12bits == true ? 0:1);\n}\n\n\n\nstatic void dpp3_set3dlut_ram12(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_rgb *lut,\n\t\tuint32_t entries)\n{\n\tuint32_t i, red, green, blue, red1, green1, blue1;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tfor (i = 0 ; i < entries; i += 2) {\n\t\tred   = lut[i].red<<4;\n\t\tgreen = lut[i].green<<4;\n\t\tblue  = lut[i].blue<<4;\n\t\tred1   = lut[i+1].red<<4;\n\t\tgreen1 = lut[i+1].green<<4;\n\t\tblue1  = lut[i+1].blue<<4;\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, red,\n\t\t\t\tCM_3DLUT_DATA1, red1);\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, green,\n\t\t\t\tCM_3DLUT_DATA1, green1);\n\n\t\tREG_SET_2(CM_3DLUT_DATA, 0,\n\t\t\t\tCM_3DLUT_DATA0, blue,\n\t\t\t\tCM_3DLUT_DATA1, blue1);\n\n\t}\n}\n\n \nstatic void dpp3_set3dlut_ram10(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_rgb *lut,\n\t\tuint32_t entries)\n{\n\tuint32_t i, red, green, blue, value;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tred   = lut[i].red;\n\t\tgreen = lut[i].green;\n\t\tblue  = lut[i].blue;\n\n\t\tvalue = (red<<20) | (green<<10) | blue;\n\n\t\tREG_SET(CM_3DLUT_DATA_30BIT, 0, CM_3DLUT_DATA_30BIT, value);\n\t}\n\n}\n\n\nstatic void dpp3_select_3dlut_ram_mask(\n\t\tstruct dpp *dpp_base,\n\t\tuint32_t ram_selection_mask)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE(CM_3DLUT_READ_WRITE_CONTROL, CM_3DLUT_WRITE_EN_MASK,\n\t\t\tram_selection_mask);\n\tREG_SET(CM_3DLUT_INDEX, 0, CM_3DLUT_INDEX, 0);\n}\n\nstatic bool dpp3_program_3dlut(struct dpp *dpp_base,\n\t\t\t       struct tetrahedral_params *params)\n{\n\tenum dc_lut_mode mode;\n\tbool is_17x17x17;\n\tbool is_12bits_color_channel;\n\tstruct dc_rgb *lut0;\n\tstruct dc_rgb *lut1;\n\tstruct dc_rgb *lut2;\n\tstruct dc_rgb *lut3;\n\tint lut_size0;\n\tint lut_size;\n\n\tif (params == NULL) {\n\t\tdpp3_set_3dlut_mode(dpp_base, LUT_BYPASS, false, false);\n\t\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\t\tdpp3_power_on_hdr3dlut(dpp_base, false);\n\t\treturn false;\n\t}\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\tdpp3_power_on_hdr3dlut(dpp_base, true);\n\n\tmode = get3dlut_config(dpp_base, &is_17x17x17, &is_12bits_color_channel);\n\n\tif (mode == LUT_BYPASS || mode == LUT_RAM_B)\n\t\tmode = LUT_RAM_A;\n\telse\n\t\tmode = LUT_RAM_B;\n\n\tis_17x17x17 = !params->use_tetrahedral_9;\n\tis_12bits_color_channel = params->use_12bits;\n\tif (is_17x17x17) {\n\t\tlut0 = params->tetrahedral_17.lut0;\n\t\tlut1 = params->tetrahedral_17.lut1;\n\t\tlut2 = params->tetrahedral_17.lut2;\n\t\tlut3 = params->tetrahedral_17.lut3;\n\t\tlut_size0 = sizeof(params->tetrahedral_17.lut0)/\n\t\t\t\t\tsizeof(params->tetrahedral_17.lut0[0]);\n\t\tlut_size  = sizeof(params->tetrahedral_17.lut1)/\n\t\t\t\t\tsizeof(params->tetrahedral_17.lut1[0]);\n\t} else {\n\t\tlut0 = params->tetrahedral_9.lut0;\n\t\tlut1 = params->tetrahedral_9.lut1;\n\t\tlut2 = params->tetrahedral_9.lut2;\n\t\tlut3 = params->tetrahedral_9.lut3;\n\t\tlut_size0 = sizeof(params->tetrahedral_9.lut0)/\n\t\t\t\tsizeof(params->tetrahedral_9.lut0[0]);\n\t\tlut_size  = sizeof(params->tetrahedral_9.lut1)/\n\t\t\t\tsizeof(params->tetrahedral_9.lut1[0]);\n\t\t}\n\n\tdpp3_select_3dlut_ram(dpp_base, mode,\n\t\t\t\tis_12bits_color_channel);\n\tdpp3_select_3dlut_ram_mask(dpp_base, 0x1);\n\tif (is_12bits_color_channel)\n\t\tdpp3_set3dlut_ram12(dpp_base, lut0, lut_size0);\n\telse\n\t\tdpp3_set3dlut_ram10(dpp_base, lut0, lut_size0);\n\n\tdpp3_select_3dlut_ram_mask(dpp_base, 0x2);\n\tif (is_12bits_color_channel)\n\t\tdpp3_set3dlut_ram12(dpp_base, lut1, lut_size);\n\telse\n\t\tdpp3_set3dlut_ram10(dpp_base, lut1, lut_size);\n\n\tdpp3_select_3dlut_ram_mask(dpp_base, 0x4);\n\tif (is_12bits_color_channel)\n\t\tdpp3_set3dlut_ram12(dpp_base, lut2, lut_size);\n\telse\n\t\tdpp3_set3dlut_ram10(dpp_base, lut2, lut_size);\n\n\tdpp3_select_3dlut_ram_mask(dpp_base, 0x8);\n\tif (is_12bits_color_channel)\n\t\tdpp3_set3dlut_ram12(dpp_base, lut3, lut_size);\n\telse\n\t\tdpp3_set3dlut_ram10(dpp_base, lut3, lut_size);\n\n\n\tdpp3_set_3dlut_mode(dpp_base, mode, is_12bits_color_channel,\n\t\t\t\t\tis_17x17x17);\n\n\treturn true;\n}\nstatic struct dpp_funcs dcn30_dpp_funcs = {\n\t.dpp_program_gamcor_lut = dpp3_program_gamcor_lut,\n\t.dpp_read_state\t\t\t= dpp30_read_state,\n\t.dpp_reset\t\t\t= dpp_reset,\n\t.dpp_set_scaler\t\t\t= dpp1_dscl_set_scaler_manual_scale,\n\t.dpp_get_optimal_number_of_taps\t= dpp3_get_optimal_number_of_taps,\n\t.dpp_set_gamut_remap\t\t= dpp3_cm_set_gamut_remap,\n\t.dpp_set_csc_adjustment\t\t= NULL,\n\t.dpp_set_csc_default\t\t= NULL,\n\t.dpp_program_regamma_pwl\t= NULL,\n\t.dpp_set_pre_degam\t\t= dpp3_set_pre_degam,\n\t.dpp_program_input_lut\t\t= NULL,\n\t.dpp_full_bypass\t\t= dpp1_full_bypass,\n\t.dpp_setup\t\t\t= dpp3_cnv_setup,\n\t.dpp_program_degamma_pwl\t= NULL,\n\t.dpp_program_cm_dealpha = dpp3_program_cm_dealpha,\n\t.dpp_program_cm_bias = dpp3_program_cm_bias,\n\t.dpp_program_blnd_lut = dpp3_program_blnd_lut,\n\t.dpp_program_shaper_lut = dpp3_program_shaper,\n\t.dpp_program_3dlut = dpp3_program_3dlut,\n\t.dpp_deferred_update = dpp3_deferred_update,\n\t.dpp_program_bias_and_scale\t= NULL,\n\t.dpp_cnv_set_alpha_keyer\t= dpp2_cnv_set_alpha_keyer,\n\t.set_cursor_attributes\t\t= dpp3_set_cursor_attributes,\n\t.set_cursor_position\t\t= dpp1_set_cursor_position,\n\t.set_optional_cursor_attributes\t= dpp1_cnv_set_optional_cursor_attributes,\n\t.dpp_dppclk_control\t\t= dpp1_dppclk_control,\n\t.dpp_set_hdr_multiplier\t\t= dpp3_set_hdr_multiplier,\n};\n\n\nstatic struct dpp_caps dcn30_dpp_cap = {\n\t.dscl_data_proc_format = DSCL_DATA_PRCESSING_FLOAT_FORMAT,\n\t.dscl_calc_lb_num_partitions = dscl2_calc_lb_num_partitions,\n};\n\nbool dpp3_construct(\n\tstruct dcn3_dpp *dpp,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dcn3_dpp_registers *tf_regs,\n\tconst struct dcn3_dpp_shift *tf_shift,\n\tconst struct dcn3_dpp_mask *tf_mask)\n{\n\tdpp->base.ctx = ctx;\n\n\tdpp->base.inst = inst;\n\tdpp->base.funcs = &dcn30_dpp_funcs;\n\tdpp->base.caps = &dcn30_dpp_cap;\n\n\tdpp->tf_regs = tf_regs;\n\tdpp->tf_shift = tf_shift;\n\tdpp->tf_mask = tf_mask;\n\n\treturn true;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}