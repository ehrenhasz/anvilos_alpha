{
  "module_name": "link_dp_training_128b_132b.c",
  "hash_id": "27dd617094ac087fd488c54a86e4f7dad7f1a3f41d485107f3e44cd7d834515e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training_128b_132b.c",
  "human_readable_source": " \n\n \n#include \"link_dp_training_128b_132b.h\"\n#include \"link_dp_training_8b_10b.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_phy.h\"\n#include \"link_dp_capability.h\"\n\n#define DC_LOGGER \\\n\tlink->ctx->logger\n\nstatic enum dc_status dpcd_128b_132b_set_lane_settings(\n\t\tstruct dc_link *link,\n\t\tconst struct link_training_settings *link_training_setting)\n{\n\tenum dc_status status = core_link_write_dpcd(link,\n\t\t\tDP_TRAINING_LANE0_SET,\n\t\t\t(uint8_t *)(link_training_setting->dpcd_lane_settings),\n\t\t\tsizeof(link_training_setting->dpcd_lane_settings));\n\n\tDC_LOG_HW_LINK_TRAINING(\"%s:\\n 0x%X TX_FFE_PRESET_VALUE = %x\\n\",\n\t\t\t__func__,\n\t\t\tDP_TRAINING_LANE0_SET,\n\t\t\tlink_training_setting->dpcd_lane_settings[0].tx_ffe.PRESET_VALUE);\n\treturn status;\n}\n\nstatic void dpcd_128b_132b_get_aux_rd_interval(struct dc_link *link,\n\t\tuint32_t *interval_in_us)\n{\n\tunion dp_128b_132b_training_aux_rd_interval dpcd_interval;\n\tuint32_t interval_unit = 0;\n\n\tdpcd_interval.raw = 0;\n\tcore_link_read_dpcd(link, DP_128B132B_TRAINING_AUX_RD_INTERVAL,\n\t\t\t&dpcd_interval.raw, sizeof(dpcd_interval.raw));\n\tinterval_unit = dpcd_interval.bits.UNIT ? 1 : 2;  \n\t \n\t*interval_in_us = (dpcd_interval.bits.VALUE + 1) * interval_unit * 1000;\n}\n\nstatic enum link_training_result dp_perform_128b_132b_channel_eq_done_sequence(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tuint8_t loop_count;\n\tuint32_t aux_rd_interval = 0;\n\tuint32_t wait_time = 0;\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\tenum dc_status status = DC_OK;\n\tenum link_training_result result = LINK_TRAINING_SUCCESS;\n\n\t \n\tdp_set_hw_training_pattern(link, link_res, lt_settings->pattern_for_cr, DPRX);\n\n\t \n\tdpcd_set_training_pattern(link, lt_settings->pattern_for_cr);\n\n\t \n\tdpcd_128b_132b_get_aux_rd_interval(link, &aux_rd_interval);\n\tdp_get_lane_status_and_lane_adjust(link, lt_settings, dpcd_lane_status,\n\t\t\t&dpcd_lane_status_updated, dpcd_lane_adjust, DPRX);\n\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\tdp_set_hw_lane_settings(link, link_res, lt_settings, DPRX);\n\tdp_set_hw_training_pattern(link, link_res, lt_settings->pattern_for_eq, DPRX);\n\n\t \n\tloop_count = 1;\n\n\t \n\tdpcd_set_lt_pattern_and_lane_settings(link, lt_settings,\n\t\t\tlt_settings->pattern_for_eq, DPRX);\n\n\t \n\twhile (result == LINK_TRAINING_SUCCESS) {\n\t\tdp_wait_for_training_aux_rd_interval(link, aux_rd_interval);\n\t\twait_time += aux_rd_interval;\n\t\tstatus = dp_get_lane_status_and_lane_adjust(link, lt_settings, dpcd_lane_status,\n\t\t\t\t&dpcd_lane_status_updated, dpcd_lane_adjust, DPRX);\n\t\tdp_decide_lane_settings(lt_settings, dpcd_lane_adjust,\n\t\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n\t\tdpcd_128b_132b_get_aux_rd_interval(link, &aux_rd_interval);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t} else if (dp_is_ch_eq_done(lt_settings->link_settings.lane_count,\n\t\t\t\tdpcd_lane_status)) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (loop_count >= lt_settings->eq_loop_count_limit) {\n\t\t\tresult = DP_128b_132b_MAX_LOOP_COUNT_REACHED;\n\t\t} else if (dpcd_lane_status_updated.bits.LT_FAILED_128b_132b) {\n\t\t\tresult = DP_128b_132b_LT_FAILED;\n\t\t} else {\n\t\t\tdp_set_hw_lane_settings(link, link_res, lt_settings, DPRX);\n\t\t\tdpcd_128b_132b_set_lane_settings(link, lt_settings);\n\t\t}\n\t\tloop_count++;\n\t}\n\n\t \n\twhile (result == LINK_TRAINING_SUCCESS) {\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t} else if (dpcd_lane_status_updated.bits.EQ_INTERLANE_ALIGN_DONE_128b_132b) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (wait_time >= lt_settings->eq_wait_time_limit) {\n\t\t\tresult = DP_128b_132b_CHANNEL_EQ_DONE_TIMEOUT;\n\t\t} else if (dpcd_lane_status_updated.bits.LT_FAILED_128b_132b) {\n\t\t\tresult = DP_128b_132b_LT_FAILED;\n\t\t} else {\n\t\t\tdp_wait_for_training_aux_rd_interval(link,\n\t\t\t\t\tlt_settings->eq_pattern_time);\n\t\t\twait_time += lt_settings->eq_pattern_time;\n\t\t\tstatus = dp_get_lane_status_and_lane_adjust(link, lt_settings, dpcd_lane_status,\n\t\t\t\t\t&dpcd_lane_status_updated, dpcd_lane_adjust, DPRX);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic enum link_training_result dp_perform_128b_132b_cds_done_sequence(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\t \n\tenum dc_status status = DC_OK;\n\tenum link_training_result result = LINK_TRAINING_SUCCESS;\n\tunion lane_align_status_updated dpcd_lane_status_updated = {0};\n\tunion lane_status dpcd_lane_status[LANE_COUNT_DP_MAX] = {0};\n\tunion lane_adjust dpcd_lane_adjust[LANE_COUNT_DP_MAX] = {0};\n\tuint32_t wait_time = 0;\n\n\t \n\tdpcd_set_training_pattern(link, lt_settings->pattern_for_cds);\n\n\t \n\twhile (result == LINK_TRAINING_SUCCESS) {\n\t\tdp_wait_for_training_aux_rd_interval(link,\n\t\t\t\tlt_settings->cds_pattern_time);\n\t\twait_time += lt_settings->cds_pattern_time;\n\t\tstatus = dp_get_lane_status_and_lane_adjust(link, lt_settings, dpcd_lane_status,\n\t\t\t\t\t\t&dpcd_lane_status_updated, dpcd_lane_adjust, DPRX);\n\t\tif (status != DC_OK) {\n\t\t\tresult = LINK_TRAINING_ABORT;\n\t\t} else if (dp_is_symbol_locked(lt_settings->link_settings.lane_count, dpcd_lane_status) &&\n\t\t\t\tdpcd_lane_status_updated.bits.CDS_INTERLANE_ALIGN_DONE_128b_132b) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (dpcd_lane_status_updated.bits.LT_FAILED_128b_132b) {\n\t\t\tresult = DP_128b_132b_LT_FAILED;\n\t\t} else if (wait_time >= lt_settings->cds_wait_time_limit) {\n\t\t\tresult = DP_128b_132b_CDS_DONE_TIMEOUT;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nenum link_training_result dp_perform_128b_132b_link_training(\n\t\tstruct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tenum link_training_result result = LINK_TRAINING_SUCCESS;\n\n\t \n\tif (link->dc->debug.legacy_dp2_lt) {\n\t\tstruct link_training_settings legacy_settings;\n\n\t\tdecide_8b_10b_training_settings(link,\n\t\t\t\t&lt_settings->link_settings,\n\t\t\t\t&legacy_settings);\n\t\treturn dp_perform_8b_10b_link_training(link, link_res, &legacy_settings);\n\t}\n\n\tdpcd_set_link_settings(link, lt_settings);\n\n\tif (result == LINK_TRAINING_SUCCESS) {\n\t\tresult = dp_perform_128b_132b_channel_eq_done_sequence(link, link_res, lt_settings);\n\t\tif (result == LINK_TRAINING_SUCCESS)\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: Channel EQ done.\\n\", __func__);\n\t}\n\n\tif (result == LINK_TRAINING_SUCCESS) {\n\t\tresult = dp_perform_128b_132b_cds_done_sequence(link, link_res, lt_settings);\n\t\tif (result == LINK_TRAINING_SUCCESS)\n\t\t\tDC_LOG_HW_LINK_TRAINING(\"%s: CDS done.\\n\", __func__);\n\t}\n\n\treturn result;\n}\n\nvoid decide_128b_132b_training_settings(struct dc_link *link,\n\t\tconst struct dc_link_settings *link_settings,\n\t\tstruct link_training_settings *lt_settings)\n{\n\tmemset(lt_settings, 0, sizeof(*lt_settings));\n\n\tlt_settings->link_settings = *link_settings;\n\t \n\tlt_settings->link_settings.link_spread = link->dp_ss_off ? LINK_SPREAD_DISABLED :\n\t\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ;\n\n\tlt_settings->pattern_for_cr = decide_cr_training_pattern(link_settings);\n\tlt_settings->pattern_for_eq = decide_eq_training_pattern(link, link_settings);\n\tlt_settings->eq_pattern_time = 2500;\n\tlt_settings->eq_wait_time_limit = 400000;\n\tlt_settings->eq_loop_count_limit = 20;\n\tlt_settings->pattern_for_cds = DP_128b_132b_TPS2_CDS;\n\tlt_settings->cds_pattern_time = 2500;\n\tlt_settings->cds_wait_time_limit = (dp_parse_lttpr_repeater_count(\n\t\t\tlink->dpcd_caps.lttpr_caps.phy_repeater_cnt) + 1) * 20000;\n\tlt_settings->disallow_per_lane_settings = true;\n\tlt_settings->lttpr_mode = dp_decide_128b_132b_lttpr_mode(link);\n\tdp_hw_to_dpcd_lane_settings(lt_settings,\n\t\t\tlt_settings->hw_lane_settings, lt_settings->dpcd_lane_settings);\n}\n\nenum lttpr_mode dp_decide_128b_132b_lttpr_mode(struct dc_link *link)\n{\n\tenum lttpr_mode mode = LTTPR_MODE_NON_LTTPR;\n\n\tif (dp_is_lttpr_present(link))\n\t\tmode = LTTPR_MODE_NON_TRANSPARENT;\n\n\tDC_LOG_DC(\"128b_132b chose LTTPR_MODE %d.\\n\", mode);\n\treturn mode;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}