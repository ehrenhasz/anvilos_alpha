{
  "module_name": "dce_panel_cntl.c",
  "hash_id": "06b41cec0e58a8e5c2d5c37408fb9530f54e3f31b69b2434e1b1caf46a40ce6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_panel_cntl.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dc_dmub_srv.h\"\n#include \"panel_cntl.h\"\n#include \"dce_panel_cntl.h\"\n#include \"atom.h\"\n\n#define TO_DCE_PANEL_CNTL(panel_cntl)\\\n\tcontainer_of(panel_cntl, struct dce_panel_cntl, base)\n\n#define CTX \\\n\tdce_panel_cntl->base.ctx\n\n#define DC_LOGGER \\\n\tdce_panel_cntl->base.ctx->logger\n\n#define REG(reg)\\\n\tdce_panel_cntl->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdce_panel_cntl->shift->field_name, dce_panel_cntl->mask->field_name\n\nstatic unsigned int dce_get_16_bit_backlight_from_pwm(struct panel_cntl *panel_cntl)\n{\n\tuint64_t current_backlight;\n\tuint32_t bl_period, bl_int_count;\n\tuint32_t bl_pwm, fractional_duty_cycle_en;\n\tuint32_t bl_period_mask, bl_pwm_mask;\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\n\tREG_READ(BL_PWM_PERIOD_CNTL);\n\tREG_GET(BL_PWM_PERIOD_CNTL, BL_PWM_PERIOD, &bl_period);\n\tREG_GET(BL_PWM_PERIOD_CNTL, BL_PWM_PERIOD_BITCNT, &bl_int_count);\n\n\tREG_READ(BL_PWM_CNTL);\n\tREG_GET(BL_PWM_CNTL, BL_ACTIVE_INT_FRAC_CNT, (uint32_t *)(&bl_pwm));\n\tREG_GET(BL_PWM_CNTL, BL_PWM_FRACTIONAL_EN, &fractional_duty_cycle_en);\n\n\tif (bl_int_count == 0)\n\t\tbl_int_count = 16;\n\n\tbl_period_mask = (1 << bl_int_count) - 1;\n\tbl_period &= bl_period_mask;\n\n\tbl_pwm_mask = bl_period_mask << (16 - bl_int_count);\n\n\tif (fractional_duty_cycle_en == 0)\n\t\tbl_pwm &= bl_pwm_mask;\n\telse\n\t\tbl_pwm &= 0xFFFF;\n\n\tcurrent_backlight = (uint64_t)bl_pwm << (1 + bl_int_count);\n\n\tif (bl_period == 0)\n\t\tbl_period = 0xFFFF;\n\n\tcurrent_backlight = div_u64(current_backlight, bl_period);\n\tcurrent_backlight = (current_backlight + 1) >> 1;\n\n\treturn (uint32_t)(current_backlight);\n}\n\nstatic uint32_t dce_panel_cntl_hw_init(struct panel_cntl *panel_cntl)\n{\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\tuint32_t value;\n\tuint32_t current_backlight;\n\n\t \n\tREG_GET(BL_PWM_CNTL, BL_ACTIVE_INT_FRAC_CNT, &value);\n\n\tif (panel_cntl->stored_backlight_registers.BL_PWM_CNTL != 0) {\n\t\tREG_WRITE(BL_PWM_CNTL,\n\t\t\t\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL);\n\t\tREG_WRITE(BL_PWM_CNTL2,\n\t\t\t\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL2);\n\t\tREG_WRITE(BL_PWM_PERIOD_CNTL,\n\t\t\t\tpanel_cntl->stored_backlight_registers.BL_PWM_PERIOD_CNTL);\n\t\tREG_UPDATE(PWRSEQ_REF_DIV,\n\t\t\tBL_PWM_REF_DIV,\n\t\t\tpanel_cntl->stored_backlight_registers.LVTMA_PWRSEQ_REF_DIV_BL_PWM_REF_DIV);\n\t} else if ((value != 0) && (value != 1)) {\n\t\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL =\n\t\t\t\tREG_READ(BL_PWM_CNTL);\n\t\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL2 =\n\t\t\t\tREG_READ(BL_PWM_CNTL2);\n\t\tpanel_cntl->stored_backlight_registers.BL_PWM_PERIOD_CNTL =\n\t\t\t\tREG_READ(BL_PWM_PERIOD_CNTL);\n\n\t\tREG_GET(PWRSEQ_REF_DIV, BL_PWM_REF_DIV,\n\t\t\t\t&panel_cntl->stored_backlight_registers.LVTMA_PWRSEQ_REF_DIV_BL_PWM_REF_DIV);\n\t} else {\n\t\t \n\t\tREG_WRITE(BL_PWM_CNTL, 0x8000FA00);\n\t\tREG_WRITE(BL_PWM_PERIOD_CNTL, 0x000C0FA0);\n\t}\n\n\t\n\t\n\tvalue = REG_READ(BIOS_SCRATCH_2);\n\tvalue |= ATOM_S2_VRI_BRIGHT_ENABLE;\n\tREG_WRITE(BIOS_SCRATCH_2, value);\n\n\t\n\tREG_UPDATE(BL_PWM_CNTL, BL_PWM_EN, 1);\n\n\t\n\tREG_UPDATE(BL_PWM_GRP1_REG_LOCK,\n\t\t\tBL_PWM_GRP1_REG_LOCK, 0);\n\n\tcurrent_backlight = dce_get_16_bit_backlight_from_pwm(panel_cntl);\n\n\treturn current_backlight;\n}\n\nstatic bool dce_is_panel_backlight_on(struct panel_cntl *panel_cntl)\n{\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\tuint32_t blon, blon_ovrd, pwrseq_target_state;\n\n\tREG_GET_2(PWRSEQ_CNTL, LVTMA_BLON, &blon, LVTMA_BLON_OVRD, &blon_ovrd);\n\tREG_GET(PWRSEQ_CNTL, LVTMA_PWRSEQ_TARGET_STATE, &pwrseq_target_state);\n\n\tif (blon_ovrd)\n\t\treturn blon;\n\telse\n\t\treturn pwrseq_target_state;\n}\n\nstatic bool dce_is_panel_powered_on(struct panel_cntl *panel_cntl)\n{\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\tuint32_t pwr_seq_state, dig_on, dig_on_ovrd;\n\n\tREG_GET(PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &pwr_seq_state);\n\n\tREG_GET_2(PWRSEQ_CNTL, LVTMA_DIGON, &dig_on, LVTMA_DIGON_OVRD, &dig_on_ovrd);\n\n\treturn (pwr_seq_state == 1) || (dig_on == 1 && dig_on_ovrd == 1);\n}\n\nstatic void dce_store_backlight_level(struct panel_cntl *panel_cntl)\n{\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\n\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL =\n\t\tREG_READ(BL_PWM_CNTL);\n\tpanel_cntl->stored_backlight_registers.BL_PWM_CNTL2 =\n\t\tREG_READ(BL_PWM_CNTL2);\n\tpanel_cntl->stored_backlight_registers.BL_PWM_PERIOD_CNTL =\n\t\tREG_READ(BL_PWM_PERIOD_CNTL);\n\n\tREG_GET(PWRSEQ_REF_DIV, BL_PWM_REF_DIV,\n\t\t&panel_cntl->stored_backlight_registers.LVTMA_PWRSEQ_REF_DIV_BL_PWM_REF_DIV);\n}\n\nstatic void dce_driver_set_backlight(struct panel_cntl *panel_cntl,\n\t\tuint32_t backlight_pwm_u16_16)\n{\n\tuint32_t backlight_16bit;\n\tuint32_t masked_pwm_period;\n\tuint8_t bit_count;\n\tuint64_t active_duty_cycle;\n\tuint32_t pwm_period_bitcnt;\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(panel_cntl);\n\n\t \n\n\t \n\tREG_GET_2(BL_PWM_PERIOD_CNTL,\n\t\t\tBL_PWM_PERIOD_BITCNT, &pwm_period_bitcnt,\n\t\t\tBL_PWM_PERIOD, &masked_pwm_period);\n\n\tif (pwm_period_bitcnt == 0)\n\t\tbit_count = 16;\n\telse\n\t\tbit_count = pwm_period_bitcnt;\n\n\t \n\tmasked_pwm_period = masked_pwm_period & ((1 << bit_count) - 1);\n\n\t \n\tactive_duty_cycle = backlight_pwm_u16_16 * masked_pwm_period;\n\n\t \n\tbacklight_16bit = active_duty_cycle >> bit_count;\n\tbacklight_16bit &= 0xFFFF;\n\tbacklight_16bit += (active_duty_cycle >> (bit_count - 1)) & 0x1;\n\n\t \n\n\t \n\n\tREG_UPDATE_2(BL_PWM_GRP1_REG_LOCK,\n\t\t\tBL_PWM_GRP1_IGNORE_MASTER_LOCK_EN, 1,\n\t\t\tBL_PWM_GRP1_REG_LOCK, 1);\n\n\t\n\tREG_UPDATE(BL_PWM_CNTL, BL_ACTIVE_INT_FRAC_CNT, backlight_16bit);\n\n\t \n\tREG_UPDATE(BL_PWM_GRP1_REG_LOCK,\n\t\t\tBL_PWM_GRP1_REG_LOCK, 0);\n\n\t \n\tREG_WAIT(BL_PWM_GRP1_REG_LOCK,\n\t\t\tBL_PWM_GRP1_REG_UPDATE_PENDING, 0,\n\t\t\t1, 10000);\n}\n\nstatic void dce_panel_cntl_destroy(struct panel_cntl **panel_cntl)\n{\n\tstruct dce_panel_cntl *dce_panel_cntl = TO_DCE_PANEL_CNTL(*panel_cntl);\n\n\tkfree(dce_panel_cntl);\n\t*panel_cntl = NULL;\n}\n\nstatic const struct panel_cntl_funcs dce_link_panel_cntl_funcs = {\n\t.destroy = dce_panel_cntl_destroy,\n\t.hw_init = dce_panel_cntl_hw_init,\n\t.is_panel_backlight_on = dce_is_panel_backlight_on,\n\t.is_panel_powered_on = dce_is_panel_powered_on,\n\t.store_backlight_level = dce_store_backlight_level,\n\t.driver_set_backlight = dce_driver_set_backlight,\n\t.get_current_backlight = dce_get_16_bit_backlight_from_pwm,\n};\n\nvoid dce_panel_cntl_construct(\n\tstruct dce_panel_cntl *dce_panel_cntl,\n\tconst struct panel_cntl_init_data *init_data,\n\tconst struct dce_panel_cntl_registers *regs,\n\tconst struct dce_panel_cntl_shift *shift,\n\tconst struct dce_panel_cntl_mask *mask)\n{\n\tstruct panel_cntl *base = &dce_panel_cntl->base;\n\n\tbase->stored_backlight_registers.BL_PWM_CNTL = 0;\n\tbase->stored_backlight_registers.BL_PWM_CNTL2 = 0;\n\tbase->stored_backlight_registers.BL_PWM_PERIOD_CNTL = 0;\n\tbase->stored_backlight_registers.LVTMA_PWRSEQ_REF_DIV_BL_PWM_REF_DIV = 0;\n\n\tdce_panel_cntl->regs = regs;\n\tdce_panel_cntl->shift = shift;\n\tdce_panel_cntl->mask = mask;\n\n\tdce_panel_cntl->base.funcs = &dce_link_panel_cntl_funcs;\n\tdce_panel_cntl->base.ctx = init_data->ctx;\n\tdce_panel_cntl->base.inst = init_data->inst;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}