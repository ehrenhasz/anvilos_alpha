{
  "module_name": "clk_mgr.h",
  "hash_id": "6421e8907521a9ede6745747b06030717846abdb9275150e555bf7160f56b313",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/inc/hw/clk_mgr.h",
  "human_readable_source": " \n\n#ifndef __DAL_CLK_MGR_H__\n#define __DAL_CLK_MGR_H__\n\n#include \"dc.h\"\n#include \"dm_pp_smu.h\"\n\n#define DCN_MINIMUM_DISPCLK_Khz 100000\n#define DCN_MINIMUM_DPPCLK_Khz 100000\n\n \n#define DDR4_DRAM_WIDTH   64\n#define WM_A 0\n#define WM_B 1\n#define WM_C 2\n#define WM_D 3\n#define WM_SET_COUNT 4\n\n#define DCN_MINIMUM_DISPCLK_Khz 100000\n#define DCN_MINIMUM_DPPCLK_Khz 100000\n\nstruct dcn3_clk_internal {\n\tint dummy;\n\t \n};\n\nstruct dcn301_clk_internal {\n\tint dummy;\n\tuint32_t CLK1_CLK0_CURRENT_CNT; \n\tuint32_t CLK1_CLK1_CURRENT_CNT; \n\tuint32_t CLK1_CLK2_CURRENT_CNT; \n\tuint32_t CLK1_CLK3_CURRENT_CNT; \n\tuint32_t CLK1_CLK3_DS_CNTL;\t\n\tuint32_t CLK1_CLK3_ALLOW_DS;\t\n\n\tuint32_t CLK1_CLK0_BYPASS_CNTL; \n\tuint32_t CLK1_CLK1_BYPASS_CNTL; \n\tuint32_t CLK1_CLK2_BYPASS_CNTL; \n\tuint32_t CLK1_CLK3_BYPASS_CNTL; \n};\n\n \n\n#define MAX_NUM_DPM_LVL\t\t8\n#define WM_SET_COUNT \t\t4\n\n\nstruct clk_limit_table_entry {\n\tunsigned int voltage;  \n\tunsigned int dcfclk_mhz;\n\tunsigned int fclk_mhz;\n\tunsigned int memclk_mhz;\n\tunsigned int socclk_mhz;\n\tunsigned int dtbclk_mhz;\n\tunsigned int dispclk_mhz;\n\tunsigned int dppclk_mhz;\n\tunsigned int phyclk_mhz;\n\tunsigned int phyclk_d18_mhz;\n\tunsigned int wck_ratio;\n};\n\nstruct clk_limit_num_entries {\n\tunsigned int num_dcfclk_levels;\n\tunsigned int num_fclk_levels;\n\tunsigned int num_memclk_levels;\n\tunsigned int num_socclk_levels;\n\tunsigned int num_dtbclk_levels;\n\tunsigned int num_dispclk_levels;\n\tunsigned int num_dppclk_levels;\n\tunsigned int num_phyclk_levels;\n\tunsigned int num_phyclk_d18_levels;\n};\n\n \nstruct clk_limit_table {\n\tstruct clk_limit_table_entry entries[MAX_NUM_DPM_LVL];\n\tstruct clk_limit_num_entries num_entries_per_clk;\n\tunsigned int num_entries;  \n};\n\nstruct wm_range_table_entry {\n\tunsigned int wm_inst;\n\tunsigned int wm_type;\n\tdouble pstate_latency_us;\n\tdouble sr_exit_time_us;\n\tdouble sr_enter_plus_exit_time_us;\n\tbool valid;\n};\n\nstruct nv_wm_range_entry {\n\tbool valid;\n\n\tstruct {\n\t\tuint8_t wm_type;\n\t\tuint16_t min_dcfclk;\n\t\tuint16_t max_dcfclk;\n\t\tuint16_t min_uclk;\n\t\tuint16_t max_uclk;\n\t} pmfw_breakdown;\n\n\tstruct {\n\t\tdouble pstate_latency_us;\n\t\tdouble sr_exit_time_us;\n\t\tdouble sr_enter_plus_exit_time_us;\n\t\tdouble fclk_change_latency_us;\n\t} dml_input;\n};\n\nstruct clk_log_info {\n\tbool enabled;\n\tchar *pBuf;\n\tunsigned int bufSize;\n\tunsigned int *sum_chars_printed;\n};\n\nstruct clk_state_registers_and_bypass {\n\tuint32_t dcfclk;\n\tuint32_t dcf_deep_sleep_divider;\n\tuint32_t dcf_deep_sleep_allow;\n\tuint32_t dprefclk;\n\tuint32_t dispclk;\n\tuint32_t dppclk;\n\tuint32_t dtbclk;\n\n\tuint32_t dppclk_bypass;\n\tuint32_t dcfclk_bypass;\n\tuint32_t dprefclk_bypass;\n\tuint32_t dispclk_bypass;\n};\n\nstruct rv1_clk_internal {\n\tuint32_t CLK0_CLK8_CURRENT_CNT;  \n\tuint32_t CLK0_CLK8_DS_CNTL;\t\t \n\tuint32_t CLK0_CLK8_ALLOW_DS;\t \n\tuint32_t CLK0_CLK10_CURRENT_CNT; \n\tuint32_t CLK0_CLK11_CURRENT_CNT; \n\n\tuint32_t CLK0_CLK8_BYPASS_CNTL;  \n\tuint32_t CLK0_CLK10_BYPASS_CNTL; \n\tuint32_t CLK0_CLK11_BYPASS_CNTL; \n};\n\nstruct rn_clk_internal {\n\tuint32_t CLK1_CLK0_CURRENT_CNT; \n\tuint32_t CLK1_CLK1_CURRENT_CNT; \n\tuint32_t CLK1_CLK2_CURRENT_CNT; \n\tuint32_t CLK1_CLK3_CURRENT_CNT; \n\tuint32_t CLK1_CLK3_DS_CNTL;\t\t\n\tuint32_t CLK1_CLK3_ALLOW_DS;\t\n\n\tuint32_t CLK1_CLK0_BYPASS_CNTL; \n\tuint32_t CLK1_CLK1_BYPASS_CNTL; \n\tuint32_t CLK1_CLK2_BYPASS_CNTL; \n\tuint32_t CLK1_CLK3_BYPASS_CNTL; \n\n};\n\n \nstruct clk_state_registers {\n\t\tuint32_t CLK0_CLK8_CURRENT_CNT;  \n\t\tuint32_t CLK0_CLK8_DS_CNTL;\t\t \n\t\tuint32_t CLK0_CLK8_ALLOW_DS;\t \n\t\tuint32_t CLK0_CLK10_CURRENT_CNT; \n\t\tuint32_t CLK0_CLK11_CURRENT_CNT; \n};\n\n \nstruct clk_bypass {\n\tuint32_t dcfclk_bypass;\n\tuint32_t dispclk_pypass;\n\tuint32_t dprefclk_bypass;\n};\n \nstruct wm_table {\n\tunion {\n\t\tstruct nv_wm_range_entry nv_entries[WM_SET_COUNT];\n\t\tstruct wm_range_table_entry entries[WM_SET_COUNT];\n\t};\n};\n\nstruct dummy_pstate_entry {\n\tunsigned int dram_speed_mts;\n\tdouble dummy_pstate_latency_us;\n};\n\nstruct clk_bw_params {\n\tunsigned int vram_type;\n\tunsigned int num_channels;\n\tunsigned int dram_channel_width_bytes;\n \tunsigned int dispclk_vco_khz;\n\tunsigned int dc_mode_softmax_memclk;\n\tunsigned int max_memclk_mhz;\n\tstruct clk_limit_table clk_table;\n\tstruct wm_table wm_table;\n\tstruct dummy_pstate_entry dummy_pstate_table[4];\n\tstruct clk_limit_table_entry dc_mode_limit;\n};\n \n\nstruct clk_states {\n\tuint32_t dprefclk_khz;\n};\n\nstruct clk_mgr_funcs {\n\t \n\tvoid (*update_clocks)(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower);\n\n\tint (*get_dp_ref_clk_frequency)(struct clk_mgr *clk_mgr);\n\tint (*get_dtb_ref_clk_frequency)(struct clk_mgr *clk_mgr);\n\n\tvoid (*set_low_power_state)(struct clk_mgr *clk_mgr);\n\n\tvoid (*init_clocks)(struct clk_mgr *clk_mgr);\n\n\tvoid (*dump_clk_registers)(struct clk_state_registers_and_bypass *regs_and_bypass,\n\t\t\tstruct clk_mgr *clk_mgr_base, struct clk_log_info *log_info);\n\n\tvoid (*enable_pme_wa) (struct clk_mgr *clk_mgr);\n\tvoid (*get_clock)(struct clk_mgr *clk_mgr,\n\t\t\tstruct dc_state *context,\n\t\t\tenum dc_clock_type clock_type,\n\t\t\tstruct dc_clock_config *clock_cfg);\n\n\tbool (*are_clock_states_equal) (struct dc_clocks *a,\n\t\t\tstruct dc_clocks *b);\n\tvoid (*notify_wm_ranges)(struct clk_mgr *clk_mgr);\n\n\t \n\tvoid (*notify_link_rate_change)(struct clk_mgr *clk_mgr, struct dc_link *link);\n\t \n\tvoid (*set_hard_min_memclk)(struct clk_mgr *clk_mgr, bool current_mode);\n\n\t \n\tvoid (*set_hard_max_memclk)(struct clk_mgr *clk_mgr);\n\n\t \n\tvoid (*set_max_memclk)(struct clk_mgr *clk_mgr, unsigned int memclk_mhz);\n\tvoid (*set_min_memclk)(struct clk_mgr *clk_mgr, unsigned int memclk_mhz);\n\n\t \n\tvoid (*get_memclk_states_from_smu)(struct clk_mgr *clk_mgr);\n\n\t \n\tbool (*is_smu_present)(struct clk_mgr *clk_mgr);\n\n\tint (*get_dispclk_from_dentist)(struct clk_mgr *clk_mgr_base);\n\n};\n\nstruct clk_mgr {\n\tstruct dc_context *ctx;\n\tstruct clk_mgr_funcs *funcs;\n\tstruct dc_clocks clks;\n\tbool psr_allow_active_cache;\n\tbool force_smu_not_present;\n\tbool dc_mode_softmax_enabled;\n\tint dprefclk_khz; \n\tint dentist_vco_freq_khz;\n\tstruct clk_state_registers_and_bypass boot_snapshot;\n\tstruct clk_bw_params *bw_params;\n\tstruct pp_smu_wm_range_sets ranges;\n};\n\n \nstruct dccg;\n\nstruct clk_mgr *dc_clk_mgr_create(struct dc_context *ctx, struct pp_smu_funcs *pp_smu, struct dccg *dccg);\n\nvoid dc_destroy_clk_mgr(struct clk_mgr *clk_mgr);\n\nvoid clk_mgr_exit_optimized_pwr_state(const struct dc *dc, struct clk_mgr *clk_mgr);\n\nvoid clk_mgr_optimize_pwr_state(const struct dc *dc, struct clk_mgr *clk_mgr);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}