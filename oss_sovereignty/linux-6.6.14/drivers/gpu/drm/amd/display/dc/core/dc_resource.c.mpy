{
  "module_name": "dc_resource.c",
  "hash_id": "a8be9325a7c28ba61896b16d3ca9a57dc8b417231615deb70b5e7405ea272fd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_resource.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n#include \"opp.h\"\n#include \"timing_generator.h\"\n#include \"transform.h\"\n#include \"dccg.h\"\n#include \"dchubbub.h\"\n#include \"dpp.h\"\n#include \"core_types.h\"\n#include \"set_mode_types.h\"\n#include \"virtual/virtual_stream_encoder.h\"\n#include \"dpcd_defs.h\"\n#include \"link_enc_cfg.h\"\n#include \"link.h\"\n#include \"virtual/virtual_link_hwss.h\"\n#include \"link/hwss/link_hwss_dio.h\"\n#include \"link/hwss/link_hwss_dpia.h\"\n#include \"link/hwss/link_hwss_hpo_dp.h\"\n#include \"link/hwss/link_hwss_dio_fixed_vs_pe_retimer.h\"\n#include \"link/hwss/link_hwss_hpo_fixed_vs_pe_retimer_dp.h\"\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n#include \"dce60/dce60_resource.h\"\n#endif\n#include \"dce80/dce80_resource.h\"\n#include \"dce100/dce100_resource.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce112/dce112_resource.h\"\n#include \"dce120/dce120_resource.h\"\n#include \"dcn10/dcn10_resource.h\"\n#include \"dcn20/dcn20_resource.h\"\n#include \"dcn21/dcn21_resource.h\"\n#include \"dcn201/dcn201_resource.h\"\n#include \"dcn30/dcn30_resource.h\"\n#include \"dcn301/dcn301_resource.h\"\n#include \"dcn302/dcn302_resource.h\"\n#include \"dcn303/dcn303_resource.h\"\n#include \"dcn31/dcn31_resource.h\"\n#include \"dcn314/dcn314_resource.h\"\n#include \"dcn315/dcn315_resource.h\"\n#include \"dcn316/dcn316_resource.h\"\n#include \"../dcn32/dcn32_resource.h\"\n#include \"../dcn321/dcn321_resource.h\"\n\n#define VISUAL_CONFIRM_BASE_DEFAULT 3\n#define VISUAL_CONFIRM_BASE_MIN 1\n#define VISUAL_CONFIRM_BASE_MAX 10\n \n#define VISUAL_CONFIRM_DPP_OFFSET_DENO 240\n\n#define DC_LOGGER_INIT(logger)\n\n#define UNABLE_TO_SPLIT -1\n\nenum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)\n{\n\tenum dce_version dc_version = DCE_VERSION_UNKNOWN;\n\n\tswitch (asic_id.chip_family) {\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n\tcase FAMILY_SI:\n\t\tif (ASIC_REV_IS_TAHITI_P(asic_id.hw_internal_rev) ||\n\t\t    ASIC_REV_IS_PITCAIRN_PM(asic_id.hw_internal_rev) ||\n\t\t    ASIC_REV_IS_CAPEVERDE_M(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCE_VERSION_6_0;\n\t\telse if (ASIC_REV_IS_OLAND_M(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCE_VERSION_6_4;\n\t\telse\n\t\t\tdc_version = DCE_VERSION_6_1;\n\t\tbreak;\n#endif\n\tcase FAMILY_CI:\n\t\tdc_version = DCE_VERSION_8_0;\n\t\tbreak;\n\tcase FAMILY_KV:\n\t\tif (ASIC_REV_IS_KALINDI(asic_id.hw_internal_rev) ||\n\t\t    ASIC_REV_IS_BHAVANI(asic_id.hw_internal_rev) ||\n\t\t    ASIC_REV_IS_GODAVARI(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCE_VERSION_8_3;\n\t\telse\n\t\t\tdc_version = DCE_VERSION_8_1;\n\t\tbreak;\n\tcase FAMILY_CZ:\n\t\tdc_version = DCE_VERSION_11_0;\n\t\tbreak;\n\n\tcase FAMILY_VI:\n\t\tif (ASIC_REV_IS_TONGA_P(asic_id.hw_internal_rev) ||\n\t\t\t\tASIC_REV_IS_FIJI_P(asic_id.hw_internal_rev)) {\n\t\t\tdc_version = DCE_VERSION_10_0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ASIC_REV_IS_POLARIS10_P(asic_id.hw_internal_rev) ||\n\t\t\t\tASIC_REV_IS_POLARIS11_M(asic_id.hw_internal_rev) ||\n\t\t\t\tASIC_REV_IS_POLARIS12_V(asic_id.hw_internal_rev)) {\n\t\t\tdc_version = DCE_VERSION_11_2;\n\t\t}\n\t\tif (ASIC_REV_IS_VEGAM(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCE_VERSION_11_22;\n\t\tbreak;\n\tcase FAMILY_AI:\n\t\tif (ASICREV_IS_VEGA20_P(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCE_VERSION_12_1;\n\t\telse\n\t\t\tdc_version = DCE_VERSION_12_0;\n\t\tbreak;\n\tcase FAMILY_RV:\n\t\tdc_version = DCN_VERSION_1_0;\n\t\tif (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_1_01;\n\t\tif (ASICREV_IS_RENOIR(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_2_1;\n\t\tif (ASICREV_IS_GREEN_SARDINE(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_2_1;\n\t\tbreak;\n\n\tcase FAMILY_NV:\n\t\tdc_version = DCN_VERSION_2_0;\n\t\tif (asic_id.chip_id == DEVICE_ID_NV_13FE || asic_id.chip_id == DEVICE_ID_NV_143F) {\n\t\t\tdc_version = DCN_VERSION_2_01;\n\t\t\tbreak;\n\t\t}\n\t\tif (ASICREV_IS_SIENNA_CICHLID_P(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_0;\n\t\tif (ASICREV_IS_DIMGREY_CAVEFISH_P(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_02;\n\t\tif (ASICREV_IS_BEIGE_GOBY_P(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_03;\n\t\tbreak;\n\n\tcase FAMILY_VGH:\n\t\tdc_version = DCN_VERSION_3_01;\n\t\tbreak;\n\n\tcase FAMILY_YELLOW_CARP:\n\t\tif (ASICREV_IS_YELLOW_CARP(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_1;\n\t\tbreak;\n\tcase AMDGPU_FAMILY_GC_10_3_6:\n\t\tif (ASICREV_IS_GC_10_3_6(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_15;\n\t\tbreak;\n\tcase AMDGPU_FAMILY_GC_10_3_7:\n\t\tif (ASICREV_IS_GC_10_3_7(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_16;\n\t\tbreak;\n\tcase AMDGPU_FAMILY_GC_11_0_0:\n\t\tdc_version = DCN_VERSION_3_2;\n\t\tif (ASICREV_IS_GC_11_0_2(asic_id.hw_internal_rev))\n\t\t\tdc_version = DCN_VERSION_3_21;\n\t\tbreak;\n\tcase AMDGPU_FAMILY_GC_11_0_1:\n\t\tdc_version = DCN_VERSION_3_14;\n\t\tbreak;\n\tdefault:\n\t\tdc_version = DCE_VERSION_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn dc_version;\n}\n\nstruct resource_pool *dc_create_resource_pool(struct dc  *dc,\n\t\t\t\t\t      const struct dc_init_data *init_data,\n\t\t\t\t\t      enum dce_version dc_version)\n{\n\tstruct resource_pool *res_pool = NULL;\n\n\tswitch (dc_version) {\n#if defined(CONFIG_DRM_AMD_DC_SI)\n\tcase DCE_VERSION_6_0:\n\t\tres_pool = dce60_create_resource_pool(\n\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_6_1:\n\t\tres_pool = dce61_create_resource_pool(\n\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_6_4:\n\t\tres_pool = dce64_create_resource_pool(\n\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n#endif\n\tcase DCE_VERSION_8_0:\n\t\tres_pool = dce80_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_8_1:\n\t\tres_pool = dce81_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_8_3:\n\t\tres_pool = dce83_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_10_0:\n\t\tres_pool = dce100_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_11_0:\n\t\tres_pool = dce110_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc,\n\t\t\t\tinit_data->asic_id);\n\t\tbreak;\n\tcase DCE_VERSION_11_2:\n\tcase DCE_VERSION_11_22:\n\t\tres_pool = dce112_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\tcase DCE_VERSION_12_0:\n\tcase DCE_VERSION_12_1:\n\t\tres_pool = dce120_create_resource_pool(\n\t\t\t\tinit_data->num_virtual_links, dc);\n\t\tbreak;\n\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\tcase DCN_VERSION_1_0:\n\tcase DCN_VERSION_1_01:\n\t\tres_pool = dcn10_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_2_0:\n\t\tres_pool = dcn20_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_2_1:\n\t\tres_pool = dcn21_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_2_01:\n\t\tres_pool = dcn201_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_0:\n\t\tres_pool = dcn30_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_01:\n\t\tres_pool = dcn301_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_02:\n\t\tres_pool = dcn302_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_03:\n\t\tres_pool = dcn303_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_1:\n\t\tres_pool = dcn31_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_14:\n\t\tres_pool = dcn314_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_15:\n\t\tres_pool = dcn315_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_16:\n\t\tres_pool = dcn316_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_2:\n\t\tres_pool = dcn32_create_resource_pool(init_data, dc);\n\t\tbreak;\n\tcase DCN_VERSION_3_21:\n\t\tres_pool = dcn321_create_resource_pool(init_data, dc);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (res_pool != NULL) {\n\t\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\t\t\t \n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t} else\n\t\t\tASSERT_CRITICAL(false);\n\t}\n\n\treturn res_pool;\n}\n\nvoid dc_destroy_resource_pool(struct dc  *dc)\n{\n\tif (dc) {\n\t\tif (dc->res_pool)\n\t\t\tdc->res_pool->funcs->destroy(&dc->res_pool);\n\n\t\tkfree(dc->hwseq);\n\t}\n}\n\nstatic void update_num_audio(\n\tconst struct resource_straps *straps,\n\tunsigned int *num_audio,\n\tstruct audio_support *aud_support)\n{\n\taud_support->dp_audio = true;\n\taud_support->hdmi_audio_native = false;\n\taud_support->hdmi_audio_on_dongle = false;\n\n\tif (straps->hdmi_disable == 0) {\n\t\tif (straps->dc_pinstraps_audio & 0x2) {\n\t\t\taud_support->hdmi_audio_on_dongle = true;\n\t\t\taud_support->hdmi_audio_native = true;\n\t\t}\n\t}\n\n\tswitch (straps->audio_stream_number) {\n\tcase 0:  \n\t\tbreak;\n\tcase 1:  \n\t\t*num_audio = 1;\n\t\tbreak;\n\tdefault:\n\t\tDC_ERR(\"DC: unexpected audio fuse!\\n\");\n\t}\n}\n\nbool resource_construct(\n\tunsigned int num_virtual_links,\n\tstruct dc  *dc,\n\tstruct resource_pool *pool,\n\tconst struct resource_create_funcs *create_funcs)\n{\n\tstruct dc_context *ctx = dc->ctx;\n\tconst struct resource_caps *caps = pool->res_cap;\n\tint i;\n\tunsigned int num_audio = caps->num_audio;\n\tstruct resource_straps straps = {0};\n\n\tif (create_funcs->read_dce_straps)\n\t\tcreate_funcs->read_dce_straps(dc->ctx, &straps);\n\n\tpool->audio_count = 0;\n\tif (create_funcs->create_audio) {\n\t\t \n\t\tupdate_num_audio(&straps, &num_audio, &pool->audio_support);\n\t\tfor (i = 0; i < caps->num_audio; i++) {\n\t\t\tstruct audio *aud = create_funcs->create_audio(ctx, i);\n\n\t\t\tif (aud == NULL) {\n\t\t\t\tDC_ERR(\"DC: failed to create audio!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!aud->funcs->endpoint_valid(aud)) {\n\t\t\t\taud->funcs->destroy(&aud);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpool->audios[i] = aud;\n\t\t\tpool->audio_count++;\n\t\t}\n\t}\n\n\tpool->stream_enc_count = 0;\n\tif (create_funcs->create_stream_encoder) {\n\t\tfor (i = 0; i < caps->num_stream_encoder; i++) {\n\t\t\tpool->stream_enc[i] = create_funcs->create_stream_encoder(i, ctx);\n\t\t\tif (pool->stream_enc[i] == NULL)\n\t\t\t\tDC_ERR(\"DC: failed to create stream_encoder!\\n\");\n\t\t\tpool->stream_enc_count++;\n\t\t}\n\t}\n\n\tpool->hpo_dp_stream_enc_count = 0;\n\tif (create_funcs->create_hpo_dp_stream_encoder) {\n\t\tfor (i = 0; i < caps->num_hpo_dp_stream_encoder; i++) {\n\t\t\tpool->hpo_dp_stream_enc[i] = create_funcs->create_hpo_dp_stream_encoder(i+ENGINE_ID_HPO_DP_0, ctx);\n\t\t\tif (pool->hpo_dp_stream_enc[i] == NULL)\n\t\t\t\tDC_ERR(\"DC: failed to create HPO DP stream encoder!\\n\");\n\t\t\tpool->hpo_dp_stream_enc_count++;\n\n\t\t}\n\t}\n\n\tpool->hpo_dp_link_enc_count = 0;\n\tif (create_funcs->create_hpo_dp_link_encoder) {\n\t\tfor (i = 0; i < caps->num_hpo_dp_link_encoder; i++) {\n\t\t\tpool->hpo_dp_link_enc[i] = create_funcs->create_hpo_dp_link_encoder(i, ctx);\n\t\t\tif (pool->hpo_dp_link_enc[i] == NULL)\n\t\t\t\tDC_ERR(\"DC: failed to create HPO DP link encoder!\\n\");\n\t\t\tpool->hpo_dp_link_enc_count++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < caps->num_mpc_3dlut; i++) {\n\t\tpool->mpc_lut[i] = dc_create_3dlut_func();\n\t\tif (pool->mpc_lut[i] == NULL)\n\t\t\tDC_ERR(\"DC: failed to create MPC 3dlut!\\n\");\n\t\tpool->mpc_shaper[i] = dc_create_transfer_func();\n\t\tif (pool->mpc_shaper[i] == NULL)\n\t\t\tDC_ERR(\"DC: failed to create MPC shaper!\\n\");\n\t}\n\n\tdc->caps.dynamic_audio = false;\n\tif (pool->audio_count < pool->stream_enc_count) {\n\t\tdc->caps.dynamic_audio = true;\n\t}\n\tfor (i = 0; i < num_virtual_links; i++) {\n\t\tpool->stream_enc[pool->stream_enc_count] =\n\t\t\tvirtual_stream_encoder_create(\n\t\t\t\t\tctx, ctx->dc_bios);\n\t\tif (pool->stream_enc[pool->stream_enc_count] == NULL) {\n\t\t\tDC_ERR(\"DC: failed to create stream_encoder!\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpool->stream_enc_count++;\n\t}\n\n\tdc->hwseq = create_funcs->create_hwseq(ctx);\n\n\treturn true;\n}\nstatic int find_matching_clock_source(\n\t\tconst struct resource_pool *pool,\n\t\tstruct clock_source *clock_source)\n{\n\n\tint i;\n\n\tfor (i = 0; i < pool->clk_src_count; i++) {\n\t\tif (pool->clock_sources[i] == clock_source)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nvoid resource_unreference_clock_source(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct clock_source *clock_source)\n{\n\tint i = find_matching_clock_source(pool, clock_source);\n\n\tif (i > -1)\n\t\tres_ctx->clock_source_ref_count[i]--;\n\n\tif (pool->dp_clock_source == clock_source)\n\t\tres_ctx->dp_clock_source_ref_count--;\n}\n\nvoid resource_reference_clock_source(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct clock_source *clock_source)\n{\n\tint i = find_matching_clock_source(pool, clock_source);\n\n\tif (i > -1)\n\t\tres_ctx->clock_source_ref_count[i]++;\n\n\tif (pool->dp_clock_source == clock_source)\n\t\tres_ctx->dp_clock_source_ref_count++;\n}\n\nint resource_get_clock_source_reference(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct clock_source *clock_source)\n{\n\tint i = find_matching_clock_source(pool, clock_source);\n\n\tif (i > -1)\n\t\treturn res_ctx->clock_source_ref_count[i];\n\n\tif (pool->dp_clock_source == clock_source)\n\t\treturn res_ctx->dp_clock_source_ref_count;\n\n\treturn -1;\n}\n\nbool resource_are_vblanks_synchronizable(\n\tstruct dc_stream_state *stream1,\n\tstruct dc_stream_state *stream2)\n{\n\tuint32_t base60_refresh_rates[] = {10, 20, 5};\n\tuint8_t i;\n\tuint8_t rr_count = ARRAY_SIZE(base60_refresh_rates);\n\tuint64_t frame_time_diff;\n\n\tif (stream1->ctx->dc->config.vblank_alignment_dto_params &&\n\t\tstream1->ctx->dc->config.vblank_alignment_max_frame_time_diff > 0 &&\n\t\tdc_is_dp_signal(stream1->signal) &&\n\t\tdc_is_dp_signal(stream2->signal) &&\n\t\tfalse == stream1->has_non_synchronizable_pclk &&\n\t\tfalse == stream2->has_non_synchronizable_pclk &&\n\t\tstream1->timing.flags.VBLANK_SYNCHRONIZABLE &&\n\t\tstream2->timing.flags.VBLANK_SYNCHRONIZABLE) {\n\t\t \n\t\tif (stream1->timing.pix_clk_100hz*100/stream1->timing.h_total/\n\t\t\t\tstream1->timing.v_total > 60)\n\t\t\treturn false;\n\t\tif (stream2->timing.pix_clk_100hz*100/stream2->timing.h_total/\n\t\t\t\tstream2->timing.v_total > 60)\n\t\t\treturn false;\n\t\tframe_time_diff = (uint64_t)10000 *\n\t\t\tstream1->timing.h_total *\n\t\t\tstream1->timing.v_total *\n\t\t\tstream2->timing.pix_clk_100hz;\n\t\tframe_time_diff = div_u64(frame_time_diff, stream1->timing.pix_clk_100hz);\n\t\tframe_time_diff = div_u64(frame_time_diff, stream2->timing.h_total);\n\t\tframe_time_diff = div_u64(frame_time_diff, stream2->timing.v_total);\n\t\tfor (i = 0; i < rr_count; i++) {\n\t\t\tint64_t diff = (int64_t)div_u64(frame_time_diff * base60_refresh_rates[i], 10) - 10000;\n\n\t\t\tif (diff < 0)\n\t\t\t\tdiff = -diff;\n\t\t\tif (diff < stream1->ctx->dc->config.vblank_alignment_max_frame_time_diff)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool resource_are_streams_timing_synchronizable(\n\tstruct dc_stream_state *stream1,\n\tstruct dc_stream_state *stream2)\n{\n\tif (stream1->timing.h_total != stream2->timing.h_total)\n\t\treturn false;\n\n\tif (stream1->timing.v_total != stream2->timing.v_total)\n\t\treturn false;\n\n\tif (stream1->timing.h_addressable\n\t\t\t\t!= stream2->timing.h_addressable)\n\t\treturn false;\n\n\tif (stream1->timing.v_addressable\n\t\t\t\t!= stream2->timing.v_addressable)\n\t\treturn false;\n\n\tif (stream1->timing.v_front_porch\n\t\t\t\t!= stream2->timing.v_front_porch)\n\t\treturn false;\n\n\tif (stream1->timing.pix_clk_100hz\n\t\t\t\t!= stream2->timing.pix_clk_100hz)\n\t\treturn false;\n\n\tif (stream1->clamping.c_depth != stream2->clamping.c_depth)\n\t\treturn false;\n\n\tif (stream1->phy_pix_clk != stream2->phy_pix_clk\n\t\t\t&& (!dc_is_dp_signal(stream1->signal)\n\t\t\t|| !dc_is_dp_signal(stream2->signal)))\n\t\treturn false;\n\n\tif (stream1->view_format != stream2->view_format)\n\t\treturn false;\n\n\tif (stream1->ignore_msa_timing_param || stream2->ignore_msa_timing_param)\n\t\treturn false;\n\n\treturn true;\n}\nstatic bool is_dp_and_hdmi_sharable(\n\t\tstruct dc_stream_state *stream1,\n\t\tstruct dc_stream_state *stream2)\n{\n\tif (stream1->ctx->dc->caps.disable_dp_clk_share)\n\t\treturn false;\n\n\tif (stream1->clamping.c_depth != COLOR_DEPTH_888 ||\n\t\tstream2->clamping.c_depth != COLOR_DEPTH_888)\n\t\treturn false;\n\n\treturn true;\n\n}\n\nstatic bool is_sharable_clk_src(\n\tconst struct pipe_ctx *pipe_with_clk_src,\n\tconst struct pipe_ctx *pipe)\n{\n\tif (pipe_with_clk_src->clock_source == NULL)\n\t\treturn false;\n\n\tif (pipe_with_clk_src->stream->signal == SIGNAL_TYPE_VIRTUAL)\n\t\treturn false;\n\n\tif (dc_is_dp_signal(pipe_with_clk_src->stream->signal) ||\n\t\t(dc_is_dp_signal(pipe->stream->signal) &&\n\t\t!is_dp_and_hdmi_sharable(pipe_with_clk_src->stream,\n\t\t\t\t     pipe->stream)))\n\t\treturn false;\n\n\tif (dc_is_hdmi_signal(pipe_with_clk_src->stream->signal)\n\t\t\t&& dc_is_dual_link_signal(pipe->stream->signal))\n\t\treturn false;\n\n\tif (dc_is_hdmi_signal(pipe->stream->signal)\n\t\t\t&& dc_is_dual_link_signal(pipe_with_clk_src->stream->signal))\n\t\treturn false;\n\n\tif (!resource_are_streams_timing_synchronizable(\n\t\t\tpipe_with_clk_src->stream, pipe->stream))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct clock_source *resource_find_used_clk_src_for_sharing(\n\t\t\t\t\tstruct resource_context *res_ctx,\n\t\t\t\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (is_sharable_clk_src(&res_ctx->pipe_ctx[i], pipe_ctx))\n\t\t\treturn res_ctx->pipe_ctx[i].clock_source;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum pixel_format convert_pixel_format_to_dalsurface(\n\t\tenum surface_pixel_format surface_pixel_format)\n{\n\tenum pixel_format dal_pixel_format = PIXEL_FORMAT_UNKNOWN;\n\n\tswitch (surface_pixel_format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:\n\t\tdal_pixel_format = PIXEL_FORMAT_INDEX8;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\tdal_pixel_format = PIXEL_FORMAT_RGB565;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\tdal_pixel_format = PIXEL_FORMAT_RGB565;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\t\tdal_pixel_format = PIXEL_FORMAT_ARGB8888;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\tdal_pixel_format = PIXEL_FORMAT_ARGB8888;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\t\tdal_pixel_format = PIXEL_FORMAT_ARGB2101010;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\t\tdal_pixel_format = PIXEL_FORMAT_ARGB2101010;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:\n\t\tdal_pixel_format = PIXEL_FORMAT_ARGB2101010_XRBIAS;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\t\tdal_pixel_format = PIXEL_FORMAT_FP16;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\tdal_pixel_format = PIXEL_FORMAT_420BPP8;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\tdal_pixel_format = PIXEL_FORMAT_420BPP10;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\tdefault:\n\t\tdal_pixel_format = PIXEL_FORMAT_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn dal_pixel_format;\n}\n\nstatic inline void get_vp_scan_direction(\n\tenum dc_rotation_angle rotation,\n\tbool horizontal_mirror,\n\tbool *orthogonal_rotation,\n\tbool *flip_vert_scan_dir,\n\tbool *flip_horz_scan_dir)\n{\n\t*orthogonal_rotation = false;\n\t*flip_vert_scan_dir = false;\n\t*flip_horz_scan_dir = false;\n\tif (rotation == ROTATION_ANGLE_180) {\n\t\t*flip_vert_scan_dir = true;\n\t\t*flip_horz_scan_dir = true;\n\t} else if (rotation == ROTATION_ANGLE_90) {\n\t\t*orthogonal_rotation = true;\n\t\t*flip_horz_scan_dir = true;\n\t} else if (rotation == ROTATION_ANGLE_270) {\n\t\t*orthogonal_rotation = true;\n\t\t*flip_vert_scan_dir = true;\n\t}\n\n\tif (horizontal_mirror)\n\t\t*flip_horz_scan_dir = !*flip_horz_scan_dir;\n}\n\nint resource_get_num_mpc_splits(const struct pipe_ctx *pipe)\n{\n\tint mpc_split_count = 0;\n\tconst struct pipe_ctx *other_pipe = pipe->bottom_pipe;\n\n\twhile (other_pipe && other_pipe->plane_state == pipe->plane_state) {\n\t\tmpc_split_count++;\n\t\tother_pipe = other_pipe->bottom_pipe;\n\t}\n\tother_pipe = pipe->top_pipe;\n\twhile (other_pipe && other_pipe->plane_state == pipe->plane_state) {\n\t\tmpc_split_count++;\n\t\tother_pipe = other_pipe->top_pipe;\n\t}\n\n\treturn mpc_split_count;\n}\n\nint resource_get_num_odm_splits(const struct pipe_ctx *pipe)\n{\n\tint odm_split_count = 0;\n\n\tpipe = resource_get_otg_master(pipe);\n\n\twhile (pipe->next_odm_pipe) {\n\t\todm_split_count++;\n\t\tpipe = pipe->next_odm_pipe;\n\t}\n\treturn odm_split_count;\n}\n\nstatic int get_odm_split_index(struct pipe_ctx *pipe_ctx)\n{\n\tint index = 0;\n\n\tpipe_ctx = resource_get_opp_head(pipe_ctx);\n\tif (!pipe_ctx)\n\t\treturn 0;\n\n\twhile (pipe_ctx->prev_odm_pipe) {\n\t\tindex++;\n\t\tpipe_ctx = pipe_ctx->prev_odm_pipe;\n\t}\n\n\treturn index;\n}\n\nstatic int get_mpc_split_index(struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *split_pipe = pipe_ctx->top_pipe;\n\tint index = 0;\n\n\twhile (split_pipe && split_pipe->plane_state == pipe_ctx->plane_state) {\n\t\tindex++;\n\t\tsplit_pipe = split_pipe->top_pipe;\n\t}\n\n\treturn index;\n}\n\n \nstatic void calculate_viewport_size(struct pipe_ctx *pipe_ctx)\n{\n\tstruct scaler_data *data = &pipe_ctx->plane_res.scl_data;\n\n\tdata->viewport.width = dc_fixpt_ceil(dc_fixpt_mul_int(data->ratios.horz, data->recout.width));\n\tdata->viewport.height = dc_fixpt_ceil(dc_fixpt_mul_int(data->ratios.vert, data->recout.height));\n\tdata->viewport_c.width = dc_fixpt_ceil(dc_fixpt_mul_int(data->ratios.horz_c, data->recout.width));\n\tdata->viewport_c.height = dc_fixpt_ceil(dc_fixpt_mul_int(data->ratios.vert_c, data->recout.height));\n\tif (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||\n\t\t\tpipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {\n\t\tswap(data->viewport.width, data->viewport.height);\n\t\tswap(data->viewport_c.width, data->viewport_c.height);\n\t}\n}\n\nstatic struct rect intersect_rec(const struct rect *r0, const struct rect *r1)\n{\n\tstruct rect rec;\n\tint r0_x_end = r0->x + r0->width;\n\tint r1_x_end = r1->x + r1->width;\n\tint r0_y_end = r0->y + r0->height;\n\tint r1_y_end = r1->y + r1->height;\n\n\trec.x = r0->x > r1->x ? r0->x : r1->x;\n\trec.width = r0_x_end > r1_x_end ? r1_x_end - rec.x : r0_x_end - rec.x;\n\trec.y = r0->y > r1->y ? r0->y : r1->y;\n\trec.height = r0_y_end > r1_y_end ? r1_y_end - rec.y : r0_y_end - rec.y;\n\n\t \n\tif (rec.width < 0 || rec.height < 0)\n\t\tmemset(&rec, 0, sizeof(rec));\n\n\treturn rec;\n}\n\nstatic struct rect shift_rec(const struct rect *rec_in, int x, int y)\n{\n\tstruct rect rec_out = *rec_in;\n\n\trec_out.x += x;\n\trec_out.y += y;\n\n\treturn rec_out;\n}\n\nstatic struct rect calculate_odm_slice_in_timing_active(struct pipe_ctx *pipe_ctx)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tint odm_slice_count = resource_get_num_odm_splits(pipe_ctx) + 1;\n\tint odm_slice_idx = get_odm_split_index(pipe_ctx);\n\tbool is_last_odm_slice = (odm_slice_idx + 1) == odm_slice_count;\n\tint h_active = stream->timing.h_addressable +\n\t\t\tstream->timing.h_border_left +\n\t\t\tstream->timing.h_border_right;\n\tint odm_slice_width = h_active / odm_slice_count;\n\tstruct rect odm_rec;\n\n\todm_rec.x = odm_slice_width * odm_slice_idx;\n\todm_rec.width = is_last_odm_slice ?\n\t\t\t \n\t\t\th_active - odm_slice_width * (odm_slice_count - 1) :\n\t\t\t \n\t\t\todm_slice_width;\n\todm_rec.y = 0;\n\todm_rec.height = stream->timing.v_addressable +\n\t\t\tstream->timing.v_border_bottom +\n\t\t\tstream->timing.v_border_top;\n\n\treturn odm_rec;\n}\n\nstatic struct rect calculate_plane_rec_in_timing_active(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tconst struct rect *rec_in)\n{\n\t \n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct rect rec_out = {0};\n\tstruct fixed31_32 temp;\n\n\ttemp = dc_fixpt_from_fraction(rec_in->x * stream->dst.width,\n\t\t\tstream->src.width);\n\trec_out.x = stream->dst.x + dc_fixpt_round(temp);\n\n\ttemp = dc_fixpt_from_fraction(\n\t\t\t(rec_in->x + rec_in->width) * stream->dst.width,\n\t\t\tstream->src.width);\n\trec_out.width = stream->dst.x + dc_fixpt_round(temp) - rec_out.x;\n\n\ttemp = dc_fixpt_from_fraction(rec_in->y * stream->dst.height,\n\t\t\tstream->src.height);\n\trec_out.y = stream->dst.y + dc_fixpt_round(temp);\n\n\ttemp = dc_fixpt_from_fraction(\n\t\t\t(rec_in->y + rec_in->height) * stream->dst.height,\n\t\t\tstream->src.height);\n\trec_out.height = stream->dst.y + dc_fixpt_round(temp) - rec_out.y;\n\n\treturn rec_out;\n}\n\nstatic struct rect calculate_mpc_slice_in_timing_active(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct rect *plane_clip_rec)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tint mpc_slice_count = resource_get_num_mpc_splits(pipe_ctx) + 1;\n\tint mpc_slice_idx = get_mpc_split_index(pipe_ctx);\n\tint epimo = mpc_slice_count - plane_clip_rec->width % mpc_slice_count - 1;\n\tstruct rect mpc_rec;\n\n\tmpc_rec.width = plane_clip_rec->width / mpc_slice_count;\n\tmpc_rec.x = plane_clip_rec->x + mpc_rec.width * mpc_slice_idx;\n\tmpc_rec.height = plane_clip_rec->height;\n\tmpc_rec.y = plane_clip_rec->y;\n\tASSERT(mpc_slice_count == 1 ||\n\t\t\tstream->view_format != VIEW_3D_FORMAT_SIDE_BY_SIDE ||\n\t\t\tmpc_rec.width % 2 == 0);\n\n\t \n\tif (mpc_slice_idx > epimo) {\n\t\tmpc_rec.x += mpc_slice_idx - epimo - 1;\n\t\tmpc_rec.width += 1;\n\t}\n\n\tif (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {\n\t\tASSERT(mpc_rec.height % 2 == 0);\n\t\tmpc_rec.height /= 2;\n\t}\n\treturn mpc_rec;\n}\n\nstatic void adjust_recout_for_visual_confirm(struct rect *recout,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tint dpp_offset, base_offset;\n\n\tif (dc->debug.visual_confirm == VISUAL_CONFIRM_DISABLE || !pipe_ctx->plane_res.dpp)\n\t\treturn;\n\n\tdpp_offset = pipe_ctx->stream->timing.v_addressable / VISUAL_CONFIRM_DPP_OFFSET_DENO;\n\tdpp_offset *= pipe_ctx->plane_res.dpp->inst;\n\n\tif ((dc->debug.visual_confirm_rect_height >= VISUAL_CONFIRM_BASE_MIN) &&\n\t\t\tdc->debug.visual_confirm_rect_height <= VISUAL_CONFIRM_BASE_MAX)\n\t\tbase_offset = dc->debug.visual_confirm_rect_height;\n\telse\n\t\tbase_offset = VISUAL_CONFIRM_BASE_DEFAULT;\n\n\trecout->height -= base_offset;\n\trecout->height -= dpp_offset;\n}\n\n \nstatic void calculate_recout(struct pipe_ctx *pipe_ctx)\n{\n\t \n\tstruct rect plane_clip;\n\tstruct rect mpc_slice_of_plane_clip;\n\tstruct rect odm_slice;\n\tstruct rect overlapping_area;\n\n\tplane_clip = calculate_plane_rec_in_timing_active(pipe_ctx,\n\t\t\t&pipe_ctx->plane_state->clip_rect);\n\t \n\tplane_clip = intersect_rec(&plane_clip,\n\t\t\t\t&pipe_ctx->stream->dst);\n\tmpc_slice_of_plane_clip = calculate_mpc_slice_in_timing_active(\n\t\t\tpipe_ctx, &plane_clip);\n\todm_slice = calculate_odm_slice_in_timing_active(pipe_ctx);\n\toverlapping_area = intersect_rec(&mpc_slice_of_plane_clip, &odm_slice);\n\tif (overlapping_area.height > 0 &&\n\t\t\toverlapping_area.width > 0) {\n\t\t \n\t\tpipe_ctx->plane_res.scl_data.recout = shift_rec(\n\t\t\t\t&overlapping_area,\n\t\t\t\t-odm_slice.x, -odm_slice.y);\n\t\tadjust_recout_for_visual_confirm(\n\t\t\t\t&pipe_ctx->plane_res.scl_data.recout,\n\t\t\t\tpipe_ctx);\n\t} else {\n\t\t \n\t\tmemset(&pipe_ctx->plane_res.scl_data.recout, 0,\n\t\t\t\tsizeof(struct rect));\n\t}\n\n}\n\nstatic void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)\n{\n\tconst struct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct rect surf_src = plane_state->src_rect;\n\tconst int in_w = stream->src.width;\n\tconst int in_h = stream->src.height;\n\tconst int out_w = stream->dst.width;\n\tconst int out_h = stream->dst.height;\n\n\t \n\tif (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||\n\t\t\tpipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)\n\t\tswap(surf_src.height, surf_src.width);\n\n\tpipe_ctx->plane_res.scl_data.ratios.horz = dc_fixpt_from_fraction(\n\t\t\t\t\tsurf_src.width,\n\t\t\t\t\tplane_state->dst_rect.width);\n\tpipe_ctx->plane_res.scl_data.ratios.vert = dc_fixpt_from_fraction(\n\t\t\t\t\tsurf_src.height,\n\t\t\t\t\tplane_state->dst_rect.height);\n\n\tif (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)\n\t\tpipe_ctx->plane_res.scl_data.ratios.horz.value *= 2;\n\telse if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)\n\t\tpipe_ctx->plane_res.scl_data.ratios.vert.value *= 2;\n\n\tpipe_ctx->plane_res.scl_data.ratios.vert.value = div64_s64(\n\t\tpipe_ctx->plane_res.scl_data.ratios.vert.value * in_h, out_h);\n\tpipe_ctx->plane_res.scl_data.ratios.horz.value = div64_s64(\n\t\tpipe_ctx->plane_res.scl_data.ratios.horz.value * in_w, out_w);\n\n\tpipe_ctx->plane_res.scl_data.ratios.horz_c = pipe_ctx->plane_res.scl_data.ratios.horz;\n\tpipe_ctx->plane_res.scl_data.ratios.vert_c = pipe_ctx->plane_res.scl_data.ratios.vert;\n\n\tif (pipe_ctx->plane_res.scl_data.format == PIXEL_FORMAT_420BPP8\n\t\t\t|| pipe_ctx->plane_res.scl_data.format == PIXEL_FORMAT_420BPP10) {\n\t\tpipe_ctx->plane_res.scl_data.ratios.horz_c.value /= 2;\n\t\tpipe_ctx->plane_res.scl_data.ratios.vert_c.value /= 2;\n\t}\n\tpipe_ctx->plane_res.scl_data.ratios.horz = dc_fixpt_truncate(\n\t\t\tpipe_ctx->plane_res.scl_data.ratios.horz, 19);\n\tpipe_ctx->plane_res.scl_data.ratios.vert = dc_fixpt_truncate(\n\t\t\tpipe_ctx->plane_res.scl_data.ratios.vert, 19);\n\tpipe_ctx->plane_res.scl_data.ratios.horz_c = dc_fixpt_truncate(\n\t\t\tpipe_ctx->plane_res.scl_data.ratios.horz_c, 19);\n\tpipe_ctx->plane_res.scl_data.ratios.vert_c = dc_fixpt_truncate(\n\t\t\tpipe_ctx->plane_res.scl_data.ratios.vert_c, 19);\n}\n\n\n \nstatic void calculate_init_and_vp(\n\t\tbool flip_scan_dir,\n\t\tint recout_offset_within_recout_full,\n\t\tint recout_size,\n\t\tint src_size,\n\t\tint taps,\n\t\tstruct fixed31_32 ratio,\n\t\tstruct fixed31_32 *init,\n\t\tint *vp_offset,\n\t\tint *vp_size)\n{\n\tstruct fixed31_32 temp;\n\tint int_part;\n\n\t \n\ttemp = dc_fixpt_mul_int(ratio, recout_offset_within_recout_full);\n\t*vp_offset = dc_fixpt_floor(temp);\n\ttemp.value &= 0xffffffff;\n\t*init = dc_fixpt_truncate(dc_fixpt_add(dc_fixpt_div_int(\n\t\t\tdc_fixpt_add_int(ratio, taps + 1), 2), temp), 19);\n\t \n\tint_part = dc_fixpt_floor(*init);\n\tif (int_part < taps) {\n\t\tint_part = taps - int_part;\n\t\tif (int_part > *vp_offset)\n\t\t\tint_part = *vp_offset;\n\t\t*vp_offset -= int_part;\n\t\t*init = dc_fixpt_add_int(*init, int_part);\n\t}\n\t \n\ttemp = dc_fixpt_add(*init, dc_fixpt_mul_int(ratio, recout_size - 1));\n\t*vp_size = dc_fixpt_floor(temp);\n\tif (*vp_size + *vp_offset > src_size)\n\t\t*vp_size = src_size - *vp_offset;\n\n\t \n\tif (flip_scan_dir)\n\t\t*vp_offset = src_size - *vp_offset - *vp_size;\n}\n\nstatic void calculate_inits_and_viewports(struct pipe_ctx *pipe_ctx)\n{\n\tconst struct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct scaler_data *data = &pipe_ctx->plane_res.scl_data;\n\tstruct rect src = plane_state->src_rect;\n\tstruct rect recout_dst_in_active_timing;\n\tstruct rect recout_clip_in_active_timing;\n\tstruct rect recout_clip_in_recout_dst;\n\tstruct rect overlap_in_active_timing;\n\tstruct rect odm_slice = calculate_odm_slice_in_timing_active(pipe_ctx);\n\tint vpc_div = (data->format == PIXEL_FORMAT_420BPP8\n\t\t\t\t|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;\n\tbool orthogonal_rotation, flip_vert_scan_dir, flip_horz_scan_dir;\n\n\trecout_clip_in_active_timing = shift_rec(\n\t\t\t&data->recout, odm_slice.x, odm_slice.y);\n\trecout_dst_in_active_timing = calculate_plane_rec_in_timing_active(\n\t\t\tpipe_ctx, &plane_state->dst_rect);\n\toverlap_in_active_timing = intersect_rec(&recout_clip_in_active_timing,\n\t\t\t&recout_dst_in_active_timing);\n\tif (overlap_in_active_timing.width > 0 &&\n\t\t\toverlap_in_active_timing.height > 0)\n\t\trecout_clip_in_recout_dst = shift_rec(&overlap_in_active_timing,\n\t\t\t\t-recout_dst_in_active_timing.x,\n\t\t\t\t-recout_dst_in_active_timing.y);\n\telse\n\t\tmemset(&recout_clip_in_recout_dst, 0, sizeof(struct rect));\n\n\t \n\tget_vp_scan_direction(\n\t\t\tplane_state->rotation,\n\t\t\tplane_state->horizontal_mirror,\n\t\t\t&orthogonal_rotation,\n\t\t\t&flip_vert_scan_dir,\n\t\t\t&flip_horz_scan_dir);\n\n\tif (orthogonal_rotation) {\n\t\tswap(src.width, src.height);\n\t\tswap(flip_vert_scan_dir, flip_horz_scan_dir);\n\t}\n\n\tcalculate_init_and_vp(\n\t\t\tflip_horz_scan_dir,\n\t\t\trecout_clip_in_recout_dst.x,\n\t\t\tdata->recout.width,\n\t\t\tsrc.width,\n\t\t\tdata->taps.h_taps,\n\t\t\tdata->ratios.horz,\n\t\t\t&data->inits.h,\n\t\t\t&data->viewport.x,\n\t\t\t&data->viewport.width);\n\tcalculate_init_and_vp(\n\t\t\tflip_horz_scan_dir,\n\t\t\trecout_clip_in_recout_dst.x,\n\t\t\tdata->recout.width,\n\t\t\tsrc.width / vpc_div,\n\t\t\tdata->taps.h_taps_c,\n\t\t\tdata->ratios.horz_c,\n\t\t\t&data->inits.h_c,\n\t\t\t&data->viewport_c.x,\n\t\t\t&data->viewport_c.width);\n\tcalculate_init_and_vp(\n\t\t\tflip_vert_scan_dir,\n\t\t\trecout_clip_in_recout_dst.y,\n\t\t\tdata->recout.height,\n\t\t\tsrc.height,\n\t\t\tdata->taps.v_taps,\n\t\t\tdata->ratios.vert,\n\t\t\t&data->inits.v,\n\t\t\t&data->viewport.y,\n\t\t\t&data->viewport.height);\n\tcalculate_init_and_vp(\n\t\t\tflip_vert_scan_dir,\n\t\t\trecout_clip_in_recout_dst.y,\n\t\t\tdata->recout.height,\n\t\t\tsrc.height / vpc_div,\n\t\t\tdata->taps.v_taps_c,\n\t\t\tdata->ratios.vert_c,\n\t\t\t&data->inits.v_c,\n\t\t\t&data->viewport_c.y,\n\t\t\t&data->viewport_c.height);\n\tif (orthogonal_rotation) {\n\t\tswap(data->viewport.x, data->viewport.y);\n\t\tswap(data->viewport.width, data->viewport.height);\n\t\tswap(data->viewport_c.x, data->viewport_c.y);\n\t\tswap(data->viewport_c.width, data->viewport_c.height);\n\t}\n\tdata->viewport.x += src.x;\n\tdata->viewport.y += src.y;\n\tASSERT(src.x % vpc_div == 0 && src.y % vpc_div == 0);\n\tdata->viewport_c.x += src.x / vpc_div;\n\tdata->viewport_c.y += src.y / vpc_div;\n}\n\nbool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)\n{\n\tconst struct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct dc_crtc_timing *timing = &pipe_ctx->stream->timing;\n\tconst struct rect odm_slice_rec = calculate_odm_slice_in_timing_active(pipe_ctx);\n\tbool res = false;\n\tDC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);\n\n\t \n\tif (!plane_state->dst_rect.width ||\n\t\t\t!plane_state->dst_rect.height ||\n\t\t\t!plane_state->src_rect.width ||\n\t\t\t!plane_state->src_rect.height) {\n\t\tASSERT(0);\n\t\treturn false;\n\t}\n\n\tpipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(\n\t\t\tpipe_ctx->plane_state->format);\n\n\t \n\tpipe_ctx->stream->dst.x += timing->h_border_left;\n\tpipe_ctx->stream->dst.y += timing->v_border_top;\n\n\t \n\tpipe_ctx->plane_res.scl_data.h_active = odm_slice_rec.width;\n\tpipe_ctx->plane_res.scl_data.v_active = odm_slice_rec.height;\n\n\t \n\tcalculate_recout(pipe_ctx);\n\t \n\tcalculate_scaling_ratios(pipe_ctx);\n\t \n\tcalculate_viewport_size(pipe_ctx);\n\n\tif (!pipe_ctx->stream->ctx->dc->config.enable_windowed_mpo_odm) {\n\t\t \n\t\tif (pipe_ctx->plane_res.scl_data.viewport.height < 1 ||\n\t\t\t\tpipe_ctx->plane_res.scl_data.viewport.width < 1)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (plane_state->ctx->dce_version > DCE_VERSION_MAX)\n\t\tpipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_36BPP;\n\telse\n\t\tpipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;\n\n\tpipe_ctx->plane_res.scl_data.lb_params.alpha_en = plane_state->per_pixel_alpha;\n\n\tif (pipe_ctx->plane_res.xfm != NULL)\n\t\tres = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(\n\t\t\t\tpipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);\n\n\tif (pipe_ctx->plane_res.dpp != NULL)\n\t\tres = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(\n\t\t\t\tpipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);\n\n\n\tif (!res) {\n\t\t \n\t\tpipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;\n\n\t\tif (pipe_ctx->plane_res.xfm != NULL)\n\t\t\tres = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(\n\t\t\t\t\tpipe_ctx->plane_res.xfm,\n\t\t\t\t\t&pipe_ctx->plane_res.scl_data,\n\t\t\t\t\t&plane_state->scaling_quality);\n\n\t\tif (pipe_ctx->plane_res.dpp != NULL)\n\t\t\tres = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(\n\t\t\t\t\tpipe_ctx->plane_res.dpp,\n\t\t\t\t\t&pipe_ctx->plane_res.scl_data,\n\t\t\t\t\t&plane_state->scaling_quality);\n\t}\n\n\t \n\tif (res)\n\t\tcalculate_inits_and_viewports(pipe_ctx);\n\n\t \n\tif (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state == plane_state) {\n\t\tASSERT(plane_state->rotation == ROTATION_ANGLE_0 ||\n\t\t\t(pipe_ctx->stream->view_format != VIEW_3D_FORMAT_TOP_AND_BOTTOM &&\n\t\t\t\tpipe_ctx->stream->view_format != VIEW_3D_FORMAT_SIDE_BY_SIDE));\n\t\tif (pipe_ctx->stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)\n\t\t\tpipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height;\n\t\telse if (pipe_ctx->stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)\n\t\t\tpipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width;\n\t}\n\n\t \n\tif (pipe_ctx->plane_res.scl_data.viewport.height < MIN_VIEWPORT_SIZE)\n\t\tpipe_ctx->plane_res.scl_data.viewport.height = MIN_VIEWPORT_SIZE;\n\tif (pipe_ctx->plane_res.scl_data.viewport.width < MIN_VIEWPORT_SIZE)\n\t\tpipe_ctx->plane_res.scl_data.viewport.width = MIN_VIEWPORT_SIZE;\n\n\n\tDC_LOG_SCALER(\"%s pipe %d:\\nViewport: height:%d width:%d x:%d y:%d  Recout: height:%d width:%d x:%d y:%d  HACTIVE:%d VACTIVE:%d\\n\"\n\t\t\t\"src_rect: height:%d width:%d x:%d y:%d  dst_rect: height:%d width:%d x:%d y:%d  clip_rect: height:%d width:%d x:%d y:%d\\n\",\n\t\t\t__func__,\n\t\t\tpipe_ctx->pipe_idx,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.height,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.width,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.x,\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.y,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.height,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.width,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.x,\n\t\t\tpipe_ctx->plane_res.scl_data.recout.y,\n\t\t\tpipe_ctx->plane_res.scl_data.h_active,\n\t\t\tpipe_ctx->plane_res.scl_data.v_active,\n\t\t\tplane_state->src_rect.height,\n\t\t\tplane_state->src_rect.width,\n\t\t\tplane_state->src_rect.x,\n\t\t\tplane_state->src_rect.y,\n\t\t\tplane_state->dst_rect.height,\n\t\t\tplane_state->dst_rect.width,\n\t\t\tplane_state->dst_rect.x,\n\t\t\tplane_state->dst_rect.y,\n\t\t\tplane_state->clip_rect.height,\n\t\t\tplane_state->clip_rect.width,\n\t\t\tplane_state->clip_rect.x,\n\t\t\tplane_state->clip_rect.y);\n\n\tpipe_ctx->stream->dst.x -= timing->h_border_left;\n\tpipe_ctx->stream->dst.y -= timing->v_border_top;\n\n\treturn res;\n}\n\n\nenum dc_status resource_build_scaling_params_for_context(\n\tconst struct dc  *dc,\n\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].plane_state != NULL &&\n\t\t\t\tcontext->res_ctx.pipe_ctx[i].stream != NULL)\n\t\t\tif (!resource_build_scaling_params(&context->res_ctx.pipe_ctx[i]))\n\t\t\t\treturn DC_FAIL_SCALING;\n\t}\n\n\treturn DC_OK;\n}\n\nstruct pipe_ctx *resource_find_free_secondary_pipe_legacy(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct pipe_ctx *primary_pipe)\n{\n\tint i;\n\tstruct pipe_ctx *secondary_pipe = NULL;\n\n\t \n\tif (primary_pipe) {\n\t\tint preferred_pipe_idx = (pool->pipe_count - 1) - primary_pipe->pipe_idx;\n\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t}\n\t}\n\n\t \n\tif (!secondary_pipe)\n\t\tfor (i = pool->pipe_count - 1; i >= 0; i--) {\n\t\t\tif (res_ctx->pipe_ctx[i].stream == NULL) {\n\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[i];\n\t\t\t\tsecondary_pipe->pipe_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\treturn secondary_pipe;\n}\n\nint resource_find_free_pipe_used_in_cur_mpc_blending_tree(\n\t\tconst struct resource_context *cur_res_ctx,\n\t\tstruct resource_context *new_res_ctx,\n\t\tconst struct pipe_ctx *cur_opp_head)\n{\n\tconst struct pipe_ctx *cur_sec_dpp = cur_opp_head->bottom_pipe;\n\tstruct pipe_ctx *new_pipe;\n\tint free_pipe_idx = FREE_PIPE_INDEX_NOT_FOUND;\n\n\twhile (cur_sec_dpp) {\n\t\t \n\t\tnew_pipe = &new_res_ctx->pipe_ctx[cur_sec_dpp->pipe_idx];\n\t\tif (resource_is_pipe_type(new_pipe, FREE_PIPE)) {\n\t\t\tfree_pipe_idx = cur_sec_dpp->pipe_idx;\n\t\t\tbreak;\n\t\t}\n\t\tcur_sec_dpp = cur_sec_dpp->bottom_pipe;\n\t}\n\n\treturn free_pipe_idx;\n}\n\nint recource_find_free_pipe_not_used_in_cur_res_ctx(\n\t\tconst struct resource_context *cur_res_ctx,\n\t\tstruct resource_context *new_res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint free_pipe_idx = FREE_PIPE_INDEX_NOT_FOUND;\n\tconst struct pipe_ctx *new_pipe, *cur_pipe;\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tcur_pipe = &cur_res_ctx->pipe_ctx[i];\n\t\tnew_pipe = &new_res_ctx->pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(cur_pipe, FREE_PIPE) &&\n\t\t\t\tresource_is_pipe_type(new_pipe, FREE_PIPE)) {\n\t\t\tfree_pipe_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn free_pipe_idx;\n}\n\nint resource_find_free_pipe_used_as_cur_sec_dpp_in_mpcc_combine(\n\t\tconst struct resource_context *cur_res_ctx,\n\t\tstruct resource_context *new_res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint free_pipe_idx = FREE_PIPE_INDEX_NOT_FOUND;\n\tconst struct pipe_ctx *new_pipe, *cur_pipe;\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tcur_pipe = &cur_res_ctx->pipe_ctx[i];\n\t\tnew_pipe = &new_res_ctx->pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(cur_pipe, DPP_PIPE) &&\n\t\t\t\t!resource_is_pipe_type(cur_pipe, OPP_HEAD) &&\n\t\t\t\tresource_is_for_mpcc_combine(cur_pipe) &&\n\t\t\t\tresource_is_pipe_type(new_pipe, FREE_PIPE)) {\n\t\t\tfree_pipe_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn free_pipe_idx;\n}\n\nint resource_find_any_free_pipe(struct resource_context *new_res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint free_pipe_idx = FREE_PIPE_INDEX_NOT_FOUND;\n\tconst struct pipe_ctx *new_pipe;\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tnew_pipe = &new_res_ctx->pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(new_pipe, FREE_PIPE)) {\n\t\t\tfree_pipe_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn free_pipe_idx;\n}\n\nbool resource_is_pipe_type(const struct pipe_ctx *pipe_ctx, enum pipe_type type)\n{\n#ifdef DBG\n\tif (pipe_ctx->stream == NULL) {\n\t\t \n\t\tASSERT(!pipe_ctx->plane_state);\n\t\tASSERT(!pipe_ctx->prev_odm_pipe);\n\t\tASSERT(!pipe_ctx->next_odm_pipe);\n\t\tASSERT(!pipe_ctx->top_pipe);\n\t\tASSERT(!pipe_ctx->bottom_pipe);\n\t} else if (pipe_ctx->top_pipe) {\n\t\t \n\t\tASSERT(pipe_ctx->plane_state)\n\t}\n\t \n#endif\n\tswitch (type) {\n\tcase OTG_MASTER:\n\t\treturn !pipe_ctx->prev_odm_pipe &&\n\t\t\t\t!pipe_ctx->top_pipe &&\n\t\t\t\tpipe_ctx->stream;\n\tcase OPP_HEAD:\n\t\treturn !pipe_ctx->top_pipe && pipe_ctx->stream;\n\tcase DPP_PIPE:\n\t\treturn pipe_ctx->plane_state && pipe_ctx->stream;\n\tcase FREE_PIPE:\n\t\treturn !pipe_ctx->plane_state && !pipe_ctx->stream;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool resource_is_for_mpcc_combine(const struct pipe_ctx *pipe_ctx)\n{\n\treturn resource_get_num_mpc_splits(pipe_ctx) > 0;\n}\n\nstruct pipe_ctx *resource_get_otg_master_for_stream(\n\t\tstruct resource_context *res_ctx,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (res_ctx->pipe_ctx[i].stream == stream &&\n\t\t\t\tresource_is_pipe_type(&res_ctx->pipe_ctx[i], OTG_MASTER))\n\t\t\treturn &res_ctx->pipe_ctx[i];\n\t}\n\treturn NULL;\n}\n\nstruct pipe_ctx *resource_get_otg_master(const struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *otg_master = resource_get_opp_head(pipe_ctx);\n\n\twhile (otg_master->prev_odm_pipe)\n\t\totg_master = otg_master->prev_odm_pipe;\n\treturn otg_master;\n}\n\nstruct pipe_ctx *resource_get_opp_head(const struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *opp_head = (struct pipe_ctx *) pipe_ctx;\n\n\tASSERT(!resource_is_pipe_type(opp_head, FREE_PIPE));\n\twhile (opp_head->top_pipe)\n\t\topp_head = opp_head->top_pipe;\n\treturn opp_head;\n}\n\nstatic struct pipe_ctx *get_tail_pipe(\n\t\tstruct pipe_ctx *head_pipe)\n{\n\tstruct pipe_ctx *tail_pipe = head_pipe->bottom_pipe;\n\n\twhile (tail_pipe) {\n\t\thead_pipe = tail_pipe;\n\t\ttail_pipe = tail_pipe->bottom_pipe;\n\t}\n\n\treturn head_pipe;\n}\n\nstatic int acquire_first_split_pipe(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *split_pipe = &res_ctx->pipe_ctx[i];\n\n\t\tif (split_pipe->top_pipe &&\n\t\t\t\tsplit_pipe->top_pipe->plane_state == split_pipe->plane_state) {\n\t\t\tsplit_pipe->top_pipe->bottom_pipe = split_pipe->bottom_pipe;\n\t\t\tif (split_pipe->bottom_pipe)\n\t\t\t\tsplit_pipe->bottom_pipe->top_pipe = split_pipe->top_pipe;\n\n\t\t\tif (split_pipe->top_pipe->plane_state)\n\t\t\t\tresource_build_scaling_params(split_pipe->top_pipe);\n\n\t\t\tmemset(split_pipe, 0, sizeof(*split_pipe));\n\t\t\tsplit_pipe->stream_res.tg = pool->timing_generators[i];\n\t\t\tsplit_pipe->plane_res.hubp = pool->hubps[i];\n\t\t\tsplit_pipe->plane_res.ipp = pool->ipps[i];\n\t\t\tsplit_pipe->plane_res.dpp = pool->dpps[i];\n\t\t\tsplit_pipe->stream_res.opp = pool->opps[i];\n\t\t\tsplit_pipe->plane_res.mpcc_inst = pool->dpps[i]->inst;\n\t\t\tsplit_pipe->pipe_idx = i;\n\n\t\t\tsplit_pipe->stream = stream;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn UNABLE_TO_SPLIT;\n}\n\nstatic bool add_plane_to_opp_head_pipes(struct pipe_ctx *otg_master_pipe,\n\t\tstruct dc_plane_state *plane_state,\n\t\tstruct dc_state *context)\n{\n\tstruct pipe_ctx *opp_head_pipe = otg_master_pipe;\n\n\twhile (opp_head_pipe) {\n\t\tif (opp_head_pipe->plane_state) {\n\t\t\tASSERT(0);\n\t\t\treturn false;\n\t\t}\n\t\topp_head_pipe->plane_state = plane_state;\n\t\topp_head_pipe = opp_head_pipe->next_odm_pipe;\n\t}\n\n\treturn true;\n}\n\nstatic void insert_secondary_dpp_pipe_with_plane(struct pipe_ctx *opp_head_pipe,\n\t\tstruct pipe_ctx *sec_pipe, struct dc_plane_state *plane_state)\n{\n\tstruct pipe_ctx *tail_pipe = get_tail_pipe(opp_head_pipe);\n\n\ttail_pipe->bottom_pipe = sec_pipe;\n\tsec_pipe->top_pipe = tail_pipe;\n\tif (tail_pipe->prev_odm_pipe) {\n\t\tASSERT(tail_pipe->prev_odm_pipe->bottom_pipe);\n\t\tsec_pipe->prev_odm_pipe = tail_pipe->prev_odm_pipe->bottom_pipe;\n\t\ttail_pipe->prev_odm_pipe->bottom_pipe->next_odm_pipe = sec_pipe;\n\t}\n\tsec_pipe->plane_state = plane_state;\n}\n\n \nstatic bool acquire_secondary_dpp_pipes_and_add_plane(\n\t\tstruct pipe_ctx *otg_master_pipe,\n\t\tstruct dc_plane_state *plane_state,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_state *cur_ctx,\n\t\tstruct resource_pool *pool)\n{\n\tstruct pipe_ctx *opp_head_pipe, *sec_pipe;\n\n\tif (!pool->funcs->acquire_free_pipe_as_secondary_dpp_pipe)\n\t\treturn false;\n\n\topp_head_pipe = otg_master_pipe;\n\twhile (opp_head_pipe) {\n\t\tsec_pipe = pool->funcs->acquire_free_pipe_as_secondary_dpp_pipe(\n\t\t\t\tcur_ctx,\n\t\t\t\tnew_ctx,\n\t\t\t\tpool,\n\t\t\t\topp_head_pipe);\n\t\tif (!sec_pipe) {\n\t\t\t \n\t\t\tint pipe_idx = acquire_first_split_pipe(\n\t\t\t\t\t&new_ctx->res_ctx, pool,\n\t\t\t\t\totg_master_pipe->stream);\n\n\t\t\tif (pipe_idx >= 0)\n\t\t\t\tsec_pipe = &new_ctx->res_ctx.pipe_ctx[pipe_idx];\n\t\t}\n\n\t\tif (!sec_pipe)\n\t\t\treturn false;\n\n\t\tinsert_secondary_dpp_pipe_with_plane(opp_head_pipe, sec_pipe,\n\t\t\t\tplane_state);\n\t\topp_head_pipe = opp_head_pipe->next_odm_pipe;\n\t}\n\treturn true;\n}\n\nbool dc_add_plane_to_context(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_plane_state *plane_state,\n\t\tstruct dc_state *context)\n{\n\tstruct resource_pool *pool = dc->res_pool;\n\tstruct pipe_ctx *otg_master_pipe;\n\tstruct dc_stream_status *stream_status = NULL;\n\tbool added = false;\n\n\tstream_status = dc_stream_get_status_from_state(context, stream);\n\tif (stream_status == NULL) {\n\t\tdm_error(\"Existing stream not found; failed to attach surface!\\n\");\n\t\tgoto out;\n\t} else if (stream_status->plane_count == MAX_SURFACE_NUM) {\n\t\tdm_error(\"Surface: can not attach plane_state %p! Maximum is: %d\\n\",\n\t\t\t\tplane_state, MAX_SURFACE_NUM);\n\t\tgoto out;\n\t}\n\n\totg_master_pipe = resource_get_otg_master_for_stream(\n\t\t\t&context->res_ctx, stream);\n\tif (otg_master_pipe->plane_state == NULL)\n\t\tadded = add_plane_to_opp_head_pipes(otg_master_pipe,\n\t\t\t\tplane_state, context);\n\telse\n\t\tadded = acquire_secondary_dpp_pipes_and_add_plane(\n\t\t\t\totg_master_pipe, plane_state, context,\n\t\t\t\tdc->current_state, pool);\n\tif (added) {\n\t\tstream_status->plane_states[stream_status->plane_count] =\n\t\t\t\tplane_state;\n\t\tstream_status->plane_count++;\n\t\tdc_plane_state_retain(plane_state);\n\t}\n\nout:\n\treturn added;\n}\n\nbool dc_remove_plane_from_context(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_plane_state *plane_state,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dc_stream_status *stream_status = NULL;\n\tstruct resource_pool *pool = dc->res_pool;\n\n\tif (!plane_state)\n\t\treturn true;\n\n\tfor (i = 0; i < context->stream_count; i++)\n\t\tif (context->streams[i] == stream) {\n\t\t\tstream_status = &context->stream_status[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (stream_status == NULL) {\n\t\tdm_error(\"Existing stream not found; failed to remove plane.\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = pool->pipe_count - 1; i >= 0; i--) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->plane_state == plane_state) {\n\t\t\tif (pipe_ctx->top_pipe)\n\t\t\t\tpipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;\n\n\t\t\t \n\t\t\tif (pipe_ctx->bottom_pipe && pipe_ctx->top_pipe)\n\t\t\t\tpipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;\n\n\t\t\t \n\t\t\tif (!pipe_ctx->top_pipe)\n\t\t\t\tpipe_ctx->plane_state = NULL;\n\t\t\telse\n\t\t\t\tmemset(pipe_ctx, 0, sizeof(*pipe_ctx));\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < stream_status->plane_count; i++) {\n\t\tif (stream_status->plane_states[i] == plane_state) {\n\t\t\tdc_plane_state_release(stream_status->plane_states[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == stream_status->plane_count) {\n\t\tdm_error(\"Existing plane_state not found; failed to detach it!\\n\");\n\t\treturn false;\n\t}\n\n\tstream_status->plane_count--;\n\n\t \n\tfor (; i < stream_status->plane_count; i++)\n\t\tstream_status->plane_states[i] = stream_status->plane_states[i + 1];\n\n\tstream_status->plane_states[stream_status->plane_count] = NULL;\n\n\treturn true;\n}\n\n \nbool dc_rem_all_planes_for_stream(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_state *context)\n{\n\tint i, old_plane_count;\n\tstruct dc_stream_status *stream_status = NULL;\n\tstruct dc_plane_state *del_planes[MAX_SURFACE_NUM] = { 0 };\n\n\tfor (i = 0; i < context->stream_count; i++)\n\t\t\tif (context->streams[i] == stream) {\n\t\t\t\tstream_status = &context->stream_status[i];\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (stream_status == NULL) {\n\t\tdm_error(\"Existing stream %p not found!\\n\", stream);\n\t\treturn false;\n\t}\n\n\told_plane_count = stream_status->plane_count;\n\n\tfor (i = 0; i < old_plane_count; i++)\n\t\tdel_planes[i] = stream_status->plane_states[i];\n\n\tfor (i = 0; i < old_plane_count; i++)\n\t\tif (!dc_remove_plane_from_context(dc, stream, del_planes[i], context))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool add_all_planes_for_stream(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tconst struct dc_validation_set set[],\n\t\tint set_count,\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\n\tfor (i = 0; i < set_count; i++)\n\t\tif (set[i].stream == stream)\n\t\t\tbreak;\n\n\tif (i == set_count) {\n\t\tdm_error(\"Stream %p not found in set!\\n\", stream);\n\t\treturn false;\n\t}\n\n\tfor (j = 0; j < set[i].plane_count; j++)\n\t\tif (!dc_add_plane_to_context(dc, stream, set[i].plane_states[j], context))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool dc_add_all_planes_for_stream(\n\t\tconst struct dc *dc,\n\t\tstruct dc_stream_state *stream,\n\t\tstruct dc_plane_state * const *plane_states,\n\t\tint plane_count,\n\t\tstruct dc_state *context)\n{\n\tstruct dc_validation_set set;\n\tint i;\n\n\tset.stream = stream;\n\tset.plane_count = plane_count;\n\n\tfor (i = 0; i < plane_count; i++)\n\t\tset.plane_states[i] = plane_states[i];\n\n\treturn add_all_planes_for_stream(dc, stream, &set, 1, context);\n}\n\nbool dc_is_timing_changed(struct dc_stream_state *cur_stream,\n\t\t       struct dc_stream_state *new_stream)\n{\n\tif (cur_stream == NULL)\n\t\treturn true;\n\n\t \n\tif (cur_stream->output_color_space != new_stream->output_color_space)\n\t\treturn true;\n\n\treturn memcmp(\n\t\t&cur_stream->timing,\n\t\t&new_stream->timing,\n\t\tsizeof(struct dc_crtc_timing)) != 0;\n}\n\nstatic bool are_stream_backends_same(\n\tstruct dc_stream_state *stream_a, struct dc_stream_state *stream_b)\n{\n\tif (stream_a == stream_b)\n\t\treturn true;\n\n\tif (stream_a == NULL || stream_b == NULL)\n\t\treturn false;\n\n\tif (dc_is_timing_changed(stream_a, stream_b))\n\t\treturn false;\n\n\tif (stream_a->signal != stream_b->signal)\n\t\treturn false;\n\n\tif (stream_a->dpms_off != stream_b->dpms_off)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool dc_is_stream_unchanged(\n\tstruct dc_stream_state *old_stream, struct dc_stream_state *stream)\n{\n\n\tif (!are_stream_backends_same(old_stream, stream))\n\t\treturn false;\n\n\tif (old_stream->ignore_msa_timing_param != stream->ignore_msa_timing_param)\n\t\treturn false;\n\n\t \n\tif (memcmp(&old_stream->audio_info, &stream->audio_info, sizeof(stream->audio_info)) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool dc_is_stream_scaling_unchanged(struct dc_stream_state *old_stream,\n\t\t\t\t    struct dc_stream_state *stream)\n{\n\tif (old_stream == stream)\n\t\treturn true;\n\n\tif (old_stream == NULL || stream == NULL)\n\t\treturn false;\n\n\tif (memcmp(&old_stream->src,\n\t\t\t&stream->src,\n\t\t\tsizeof(struct rect)) != 0)\n\t\treturn false;\n\n\tif (memcmp(&old_stream->dst,\n\t\t\t&stream->dst,\n\t\t\tsizeof(struct rect)) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void update_stream_engine_usage(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct stream_encoder *stream_enc,\n\t\tbool acquired)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (pool->stream_enc[i] == stream_enc)\n\t\t\tres_ctx->is_stream_enc_acquired[i] = acquired;\n\t}\n}\n\nstatic void update_hpo_dp_stream_engine_usage(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct hpo_dp_stream_encoder *hpo_dp_stream_enc,\n\t\tbool acquired)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->hpo_dp_stream_enc_count; i++) {\n\t\tif (pool->hpo_dp_stream_enc[i] == hpo_dp_stream_enc)\n\t\t\tres_ctx->is_hpo_dp_stream_enc_acquired[i] = acquired;\n\t}\n}\n\nstatic inline int find_acquired_hpo_dp_link_enc_for_link(\n\t\tconst struct resource_context *res_ctx,\n\t\tconst struct dc_link *link)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(res_ctx->hpo_dp_link_enc_to_link_idx); i++)\n\t\tif (res_ctx->hpo_dp_link_enc_ref_cnts[i] > 0 &&\n\t\t\t\tres_ctx->hpo_dp_link_enc_to_link_idx[i] == link->link_index)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic inline int find_free_hpo_dp_link_enc(const struct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(res_ctx->hpo_dp_link_enc_ref_cnts); i++)\n\t\tif (res_ctx->hpo_dp_link_enc_ref_cnts[i] == 0)\n\t\t\tbreak;\n\n\treturn (i < ARRAY_SIZE(res_ctx->hpo_dp_link_enc_ref_cnts) &&\n\t\t\ti < pool->hpo_dp_link_enc_count) ? i : -1;\n}\n\nstatic inline void acquire_hpo_dp_link_enc(\n\t\tstruct resource_context *res_ctx,\n\t\tunsigned int link_index,\n\t\tint enc_index)\n{\n\tres_ctx->hpo_dp_link_enc_to_link_idx[enc_index] = link_index;\n\tres_ctx->hpo_dp_link_enc_ref_cnts[enc_index] = 1;\n}\n\nstatic inline void retain_hpo_dp_link_enc(\n\t\tstruct resource_context *res_ctx,\n\t\tint enc_index)\n{\n\tres_ctx->hpo_dp_link_enc_ref_cnts[enc_index]++;\n}\n\nstatic inline void release_hpo_dp_link_enc(\n\t\tstruct resource_context *res_ctx,\n\t\tint enc_index)\n{\n\tASSERT(res_ctx->hpo_dp_link_enc_ref_cnts[enc_index] > 0);\n\tres_ctx->hpo_dp_link_enc_ref_cnts[enc_index]--;\n}\n\nstatic bool add_hpo_dp_link_enc_to_ctx(struct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_stream_state *stream)\n{\n\tint enc_index;\n\n\tenc_index = find_acquired_hpo_dp_link_enc_for_link(res_ctx, stream->link);\n\n\tif (enc_index >= 0) {\n\t\tretain_hpo_dp_link_enc(res_ctx, enc_index);\n\t} else {\n\t\tenc_index = find_free_hpo_dp_link_enc(res_ctx, pool);\n\t\tif (enc_index >= 0)\n\t\t\tacquire_hpo_dp_link_enc(res_ctx, stream->link->link_index, enc_index);\n\t}\n\n\tif (enc_index >= 0)\n\t\tpipe_ctx->link_res.hpo_dp_link_enc = pool->hpo_dp_link_enc[enc_index];\n\n\treturn pipe_ctx->link_res.hpo_dp_link_enc != NULL;\n}\n\nstatic void remove_hpo_dp_link_enc_from_ctx(struct resource_context *res_ctx,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_stream_state *stream)\n{\n\tint enc_index;\n\n\tenc_index = find_acquired_hpo_dp_link_enc_for_link(res_ctx, stream->link);\n\n\tif (enc_index >= 0) {\n\t\trelease_hpo_dp_link_enc(res_ctx, enc_index);\n\t\tpipe_ctx->link_res.hpo_dp_link_enc = NULL;\n\t}\n}\n\n \nvoid update_audio_usage(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct audio *audio,\n\t\tbool acquired)\n{\n\tint i;\n\tfor (i = 0; i < pool->audio_count; i++) {\n\t\tif (pool->audios[i] == audio)\n\t\t\tres_ctx->is_audio_acquired[i] = acquired;\n\t}\n}\n\nstatic int acquire_first_free_pipe(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tif (!res_ctx->pipe_ctx[i].stream) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];\n\n\t\t\tpipe_ctx->stream_res.tg = pool->timing_generators[i];\n\t\t\tpipe_ctx->plane_res.mi = pool->mis[i];\n\t\t\tpipe_ctx->plane_res.hubp = pool->hubps[i];\n\t\t\tpipe_ctx->plane_res.ipp = pool->ipps[i];\n\t\t\tpipe_ctx->plane_res.xfm = pool->transforms[i];\n\t\t\tpipe_ctx->plane_res.dpp = pool->dpps[i];\n\t\t\tpipe_ctx->stream_res.opp = pool->opps[i];\n\t\t\tif (pool->dpps[i])\n\t\t\t\tpipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;\n\t\t\tpipe_ctx->pipe_idx = i;\n\n\t\t\tif (i >= pool->timing_generator_count) {\n\t\t\t\tint tg_inst = pool->timing_generator_count - 1;\n\n\t\t\t\tpipe_ctx->stream_res.tg = pool->timing_generators[tg_inst];\n\t\t\t\tpipe_ctx->stream_res.opp = pool->opps[tg_inst];\n\t\t\t}\n\n\t\t\tpipe_ctx->stream = stream;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic struct hpo_dp_stream_encoder *find_first_free_match_hpo_dp_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->hpo_dp_stream_enc_count; i++) {\n\t\tif (!res_ctx->is_hpo_dp_stream_enc_acquired[i] &&\n\t\t\t\tpool->hpo_dp_stream_enc[i]) {\n\n\t\t\treturn pool->hpo_dp_stream_enc[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct audio *find_first_free_audio(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tenum engine_id id,\n\t\tenum dce_version dc_version)\n{\n\tint i, available_audio_count;\n\n\tavailable_audio_count = pool->audio_count;\n\n\tfor (i = 0; i < available_audio_count; i++) {\n\t\tif ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {\n\t\t\t \n\t\t\tif (id != i)\n\t\t\t\tcontinue;\n\t\t\treturn pool->audios[i];\n\t\t}\n\t}\n\n\t \n\tif ((id < available_audio_count) && (res_ctx->is_audio_acquired[id] == false)) {\n\t\treturn pool->audios[id];\n\t}\n\t \n\tfor (i = 0; i < available_audio_count; i++) {\n\t\tif (res_ctx->is_audio_acquired[i] == false) {\n\t\t\treturn pool->audios[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nenum dc_status dc_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *stream)\n{\n\tenum dc_status res;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (new_ctx->stream_count >= dc->res_pool->timing_generator_count) {\n\t\tDC_LOG_WARNING(\"Max streams reached, can't add stream %p !\\n\", stream);\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tnew_ctx->streams[new_ctx->stream_count] = stream;\n\tdc_stream_retain(stream);\n\tnew_ctx->stream_count++;\n\n\tres = dc->res_pool->funcs->add_stream_to_ctx(dc, new_ctx, stream);\n\tif (res != DC_OK)\n\t\tDC_LOG_WARNING(\"Adding stream %p to context failed with err %d!\\n\", stream, res);\n\n\treturn res;\n}\n\n \nenum dc_status dc_remove_stream_from_ctx(\n\t\t\tstruct dc *dc,\n\t\t\tstruct dc_state *new_ctx,\n\t\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct pipe_ctx *del_pipe = resource_get_otg_master_for_stream(&new_ctx->res_ctx, stream);\n\tstruct pipe_ctx *odm_pipe;\n\n\tif (!del_pipe) {\n\t\tDC_ERROR(\"Pipe not found for stream %p !\\n\", stream);\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\todm_pipe = del_pipe->next_odm_pipe;\n\n\t \n\tASSERT(del_pipe->stream_res.stream_enc);\n\tupdate_stream_engine_usage(\n\t\t\t&new_ctx->res_ctx,\n\t\t\t\tdc->res_pool,\n\t\t\tdel_pipe->stream_res.stream_enc,\n\t\t\tfalse);\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(del_pipe)) {\n\t\tupdate_hpo_dp_stream_engine_usage(\n\t\t\t&new_ctx->res_ctx, dc->res_pool,\n\t\t\tdel_pipe->stream_res.hpo_dp_stream_enc,\n\t\t\tfalse);\n\t\tremove_hpo_dp_link_enc_from_ctx(&new_ctx->res_ctx, del_pipe, del_pipe->stream);\n\t}\n\n\tif (del_pipe->stream_res.audio)\n\t\tupdate_audio_usage(\n\t\t\t&new_ctx->res_ctx,\n\t\t\tdc->res_pool,\n\t\t\tdel_pipe->stream_res.audio,\n\t\t\tfalse);\n\n\tresource_unreference_clock_source(&new_ctx->res_ctx,\n\t\t\t\t\t  dc->res_pool,\n\t\t\t\t\t  del_pipe->clock_source);\n\n\tif (dc->res_pool->funcs->remove_stream_from_ctx)\n\t\tdc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);\n\n\twhile (odm_pipe) {\n\t\tstruct pipe_ctx *next_odm_pipe = odm_pipe->next_odm_pipe;\n\n\t\tmemset(odm_pipe, 0, sizeof(*odm_pipe));\n\t\todm_pipe = next_odm_pipe;\n\t}\n\tmemset(del_pipe, 0, sizeof(*del_pipe));\n\n\tfor (i = 0; i < new_ctx->stream_count; i++)\n\t\tif (new_ctx->streams[i] == stream)\n\t\t\tbreak;\n\n\tif (new_ctx->streams[i] != stream) {\n\t\tDC_ERROR(\"Context doesn't have stream %p !\\n\", stream);\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tdc_stream_release(new_ctx->streams[i]);\n\tnew_ctx->stream_count--;\n\n\t \n\tfor (; i < new_ctx->stream_count; i++) {\n\t\tnew_ctx->streams[i] = new_ctx->streams[i + 1];\n\t\tnew_ctx->stream_status[i] = new_ctx->stream_status[i + 1];\n\t}\n\n\tnew_ctx->streams[new_ctx->stream_count] = NULL;\n\tmemset(\n\t\t\t&new_ctx->stream_status[new_ctx->stream_count],\n\t\t\t0,\n\t\t\tsizeof(new_ctx->stream_status[0]));\n\n\treturn DC_OK;\n}\n\nstatic struct dc_stream_state *find_pll_sharable_stream(\n\t\tstruct dc_stream_state *stream_needs_pll,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tstruct dc_stream_state *stream_has_pll = context->streams[i];\n\n\t\t \n\t\tif (resource_are_streams_timing_synchronizable(\n\t\t\tstream_needs_pll, stream_has_pll)\n\t\t\t&& !dc_is_dp_signal(stream_has_pll->signal)\n\t\t\t&& stream_has_pll->link->connector_signal\n\t\t\t!= SIGNAL_TYPE_VIRTUAL)\n\t\t\treturn stream_has_pll;\n\n\t}\n\n\treturn NULL;\n}\n\nstatic int get_norm_pix_clk(const struct dc_crtc_timing *timing)\n{\n\tuint32_t pix_clk = timing->pix_clk_100hz;\n\tuint32_t normalized_pix_clk = pix_clk;\n\n\tif (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tpix_clk /= 2;\n\tif (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422) {\n\t\tswitch (timing->display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\tcase COLOR_DEPTH_888:\n\t\t\tnormalized_pix_clk = pix_clk;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tnormalized_pix_clk = (pix_clk * 30) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tnormalized_pix_clk = (pix_clk * 36) / 24;\n\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tnormalized_pix_clk = (pix_clk * 48) / 24;\n\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\tbreak;\n\t\t}\n\t}\n\treturn normalized_pix_clk;\n}\n\nstatic void calculate_phy_pix_clks(struct dc_stream_state *stream)\n{\n\t \n\tif (dc_is_hdmi_signal(stream->signal))\n\t\tstream->phy_pix_clk = get_norm_pix_clk(\n\t\t\t&stream->timing) / 10;\n\telse\n\t\tstream->phy_pix_clk =\n\t\t\tstream->timing.pix_clk_100hz / 10;\n\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tstream->phy_pix_clk *= 2;\n}\n\nstatic int acquire_resource_from_hw_enabled_state(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct dc_link *link = stream->link;\n\tunsigned int i, inst, tg_inst = 0;\n\tuint32_t numPipes = 1;\n\tuint32_t id_src[4] = {0};\n\n\t \n\tif (!link->link_enc->funcs->is_dig_enabled(link->link_enc))\n\t\treturn -1;\n\n\tinst = link->link_enc->funcs->get_dig_frontend(link->link_enc);\n\n\tif (inst == ENGINE_ID_UNKNOWN)\n\t\treturn -1;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (pool->stream_enc[i]->id == inst) {\n\t\t\ttg_inst = pool->stream_enc[i]->funcs->dig_source_otg(\n\t\t\t\tpool->stream_enc[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tif (i == pool->stream_enc_count)\n\t\treturn -1;\n\n\tif (tg_inst >= pool->timing_generator_count)\n\t\treturn -1;\n\n\tif (!res_ctx->pipe_ctx[tg_inst].stream) {\n\t\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[tg_inst];\n\n\t\tpipe_ctx->stream_res.tg = pool->timing_generators[tg_inst];\n\t\tid_src[0] = tg_inst;\n\n\t\tif (pipe_ctx->stream_res.tg->funcs->get_optc_source)\n\t\t\tpipe_ctx->stream_res.tg->funcs->get_optc_source(pipe_ctx->stream_res.tg,\n\t\t\t\t\t\t&numPipes, &id_src[0], &id_src[1]);\n\n\t\tif (id_src[0] == 0xf && id_src[1] == 0xf) {\n\t\t\tid_src[0] = tg_inst;\n\t\t\tnumPipes = 1;\n\t\t}\n\n\t\tfor (i = 0; i < numPipes; i++) {\n\t\t\t\n\t\t\tif (id_src[i] == 0xf)\n\t\t\t\treturn -1;\n\n\t\t\tpipe_ctx = &res_ctx->pipe_ctx[id_src[i]];\n\n\t\t\tpipe_ctx->stream_res.tg = pool->timing_generators[tg_inst];\n\t\t\tpipe_ctx->plane_res.mi = pool->mis[id_src[i]];\n\t\t\tpipe_ctx->plane_res.hubp = pool->hubps[id_src[i]];\n\t\t\tpipe_ctx->plane_res.ipp = pool->ipps[id_src[i]];\n\t\t\tpipe_ctx->plane_res.xfm = pool->transforms[id_src[i]];\n\t\t\tpipe_ctx->plane_res.dpp = pool->dpps[id_src[i]];\n\t\t\tpipe_ctx->stream_res.opp = pool->opps[id_src[i]];\n\n\t\t\tif (pool->dpps[id_src[i]]) {\n\t\t\t\tpipe_ctx->plane_res.mpcc_inst = pool->dpps[id_src[i]]->inst;\n\n\t\t\t\tif (pool->mpc->funcs->read_mpcc_state) {\n\t\t\t\t\tstruct mpcc_state s = {0};\n\n\t\t\t\t\tpool->mpc->funcs->read_mpcc_state(pool->mpc, pipe_ctx->plane_res.mpcc_inst, &s);\n\n\t\t\t\t\tif (s.dpp_id < MAX_MPCC)\n\t\t\t\t\t\tpool->mpc->mpcc_array[pipe_ctx->plane_res.mpcc_inst].dpp_id =\n\t\t\t\t\t\t\t\ts.dpp_id;\n\n\t\t\t\t\tif (s.bot_mpcc_id < MAX_MPCC)\n\t\t\t\t\t\tpool->mpc->mpcc_array[pipe_ctx->plane_res.mpcc_inst].mpcc_bot =\n\t\t\t\t\t\t\t\t&pool->mpc->mpcc_array[s.bot_mpcc_id];\n\n\t\t\t\t\tif (s.opp_id < MAX_OPP)\n\t\t\t\t\t\tpipe_ctx->stream_res.opp->mpc_tree_params.opp_id = s.opp_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpipe_ctx->pipe_idx = id_src[i];\n\n\t\t\tif (id_src[i] >= pool->timing_generator_count) {\n\t\t\t\tid_src[i] = pool->timing_generator_count - 1;\n\n\t\t\t\tpipe_ctx->stream_res.tg = pool->timing_generators[id_src[i]];\n\t\t\t\tpipe_ctx->stream_res.opp = pool->opps[id_src[i]];\n\t\t\t}\n\n\t\t\tpipe_ctx->stream = stream;\n\t\t}\n\n\t\tif (numPipes == 2) {\n\t\t\tstream->apply_boot_odm_mode = dm_odm_combine_policy_2to1;\n\t\t\tres_ctx->pipe_ctx[id_src[0]].next_odm_pipe = &res_ctx->pipe_ctx[id_src[1]];\n\t\t\tres_ctx->pipe_ctx[id_src[0]].prev_odm_pipe = NULL;\n\t\t\tres_ctx->pipe_ctx[id_src[1]].next_odm_pipe = NULL;\n\t\t\tres_ctx->pipe_ctx[id_src[1]].prev_odm_pipe = &res_ctx->pipe_ctx[id_src[0]];\n\t\t} else\n\t\t\tstream->apply_boot_odm_mode = dm_odm_combine_mode_disabled;\n\n\t\treturn id_src[0];\n\t}\n\n\treturn -1;\n}\n\nstatic void mark_seamless_boot_stream(\n\t\tconst struct dc  *dc,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\n\tif (dc->config.allow_seamless_boot_optimization &&\n\t\t\t!dcb->funcs->is_accelerated_mode(dcb)) {\n\t\tif (dc_validate_boot_timing(dc, stream->sink, &stream->timing))\n\t\t\tstream->apply_seamless_boot_optimization = true;\n\t}\n}\n\nenum dc_status resource_map_pool_resources(\n\t\tconst struct dc  *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tconst struct resource_pool *pool = dc->res_pool;\n\tint i;\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tint pipe_idx = -1;\n\n\tcalculate_phy_pix_clks(stream);\n\n\tmark_seamless_boot_stream(dc, stream);\n\n\tif (stream->apply_seamless_boot_optimization) {\n\t\tpipe_idx = acquire_resource_from_hw_enabled_state(\n\t\t\t\t&context->res_ctx,\n\t\t\t\tpool,\n\t\t\t\tstream);\n\t\tif (pipe_idx < 0)\n\t\t\t \n\t\t\tstream->apply_seamless_boot_optimization = false;\n\t}\n\n\tif (pipe_idx < 0)\n\t\t \n\t\tpipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);\n\n\tif (pipe_idx < 0)\n\t\tpipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);\n\n\tif (pipe_idx < 0 || context->res_ctx.pipe_ctx[pipe_idx].stream_res.tg == NULL)\n\t\treturn DC_NO_CONTROLLER_RESOURCE;\n\n\tpipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];\n\n\tpipe_ctx->stream_res.stream_enc =\n\t\tdc->res_pool->funcs->find_first_free_match_stream_enc_for_link(\n\t\t\t&context->res_ctx, pool, stream);\n\n\tif (!pipe_ctx->stream_res.stream_enc)\n\t\treturn DC_NO_STREAM_ENC_RESOURCE;\n\n\tupdate_stream_engine_usage(\n\t\t&context->res_ctx, pool,\n\t\tpipe_ctx->stream_res.stream_enc,\n\t\ttrue);\n\n\t \n\tif (dc_is_dp_signal(stream->signal)) {\n\t\tif (!dc->link_srv->dp_decide_link_settings(stream, &pipe_ctx->link_config.dp_link_settings))\n\t\t\treturn DC_FAIL_DP_LINK_BANDWIDTH;\n\t\tif (dc->link_srv->dp_get_encoding_format(\n\t\t\t\t&pipe_ctx->link_config.dp_link_settings) == DP_128b_132b_ENCODING) {\n\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc =\n\t\t\t\t\tfind_first_free_match_hpo_dp_stream_enc_for_link(\n\t\t\t\t\t\t\t&context->res_ctx, pool, stream);\n\n\t\t\tif (!pipe_ctx->stream_res.hpo_dp_stream_enc)\n\t\t\t\treturn DC_NO_STREAM_ENC_RESOURCE;\n\n\t\t\tupdate_hpo_dp_stream_engine_usage(\n\t\t\t\t\t&context->res_ctx, pool,\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\ttrue);\n\t\t\tif (!add_hpo_dp_link_enc_to_ctx(&context->res_ctx, pool, pipe_ctx, stream))\n\t\t\t\treturn DC_NO_LINK_ENC_RESOURCE;\n\t\t}\n\t}\n\n\t \n\tif (!stream->converter_disable_audio &&\n\t    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&\n\t    stream->audio_info.mode_count && stream->audio_info.flags.all) {\n\t\tpipe_ctx->stream_res.audio = find_first_free_audio(\n\t\t&context->res_ctx, pool, pipe_ctx->stream_res.stream_enc->id, dc_ctx->dce_version);\n\n\t\t \n\t\tif (pipe_ctx->stream_res.audio)\n\t\t\tupdate_audio_usage(&context->res_ctx, pool,\n\t\t\t\t\t   pipe_ctx->stream_res.audio, true);\n\t}\n\n\t \n\tif (pipe_ctx->stream && dc_is_embedded_signal(pipe_ctx->stream->signal)) {\n\t\tif (pool->abm)\n\t\t\tpipe_ctx->stream_res.abm = pool->abm;\n\t\telse\n\t\t\tpipe_ctx->stream_res.abm = pool->multiple_abms[pipe_ctx->stream_res.tg->inst];\n\t}\n\n\tfor (i = 0; i < context->stream_count; i++)\n\t\tif (context->streams[i] == stream) {\n\t\t\tcontext->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;\n\t\t\tcontext->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->stream_enc_inst;\n\t\t\tcontext->stream_status[i].audio_inst =\n\t\t\t\tpipe_ctx->stream_res.audio ? pipe_ctx->stream_res.audio->inst : -1;\n\n\t\t\treturn DC_OK;\n\t\t}\n\n\tDC_ERROR(\"Stream %p not found in new ctx!\\n\", stream);\n\treturn DC_ERROR_UNEXPECTED;\n}\n\n \nvoid dc_resource_state_copy_construct_current(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *dst_ctx)\n{\n\tdc_resource_state_copy_construct(dc->current_state, dst_ctx);\n}\n\n\nvoid dc_resource_state_construct(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *dst_ctx)\n{\n\tdst_ctx->clk_mgr = dc->clk_mgr;\n\n\t \n\tlink_enc_cfg_init(dc, dst_ctx);\n}\n\n\nbool dc_resource_is_dsc_encoding_supported(const struct dc *dc)\n{\n\tif (dc->res_pool == NULL)\n\t\treturn false;\n\n\treturn dc->res_pool->res_cap->num_dsc > 0;\n}\n\nstatic bool planes_changed_for_existing_stream(struct dc_state *context,\n\t\t\t\t\t       struct dc_stream_state *stream,\n\t\t\t\t\t       const struct dc_validation_set set[],\n\t\t\t\t\t       int set_count)\n{\n\tint i, j;\n\tstruct dc_stream_status *stream_status = NULL;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i] == stream) {\n\t\t\tstream_status = &context->stream_status[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream_status)\n\t\tASSERT(0);\n\n\tfor (i = 0; i < set_count; i++)\n\t\tif (set[i].stream == stream)\n\t\t\tbreak;\n\n\tif (i == set_count)\n\t\tASSERT(0);\n\n\tif (set[i].plane_count != stream_status->plane_count)\n\t\treturn true;\n\n\tfor (j = 0; j < set[i].plane_count; j++)\n\t\tif (set[i].plane_states[j] != stream_status->plane_states[j])\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nenum dc_status dc_validate_with_context(struct dc *dc,\n\t\t\t\t\tconst struct dc_validation_set set[],\n\t\t\t\t\tint set_count,\n\t\t\t\t\tstruct dc_state *context,\n\t\t\t\t\tbool fast_validate)\n{\n\tstruct dc_stream_state *unchanged_streams[MAX_PIPES] = { 0 };\n\tstruct dc_stream_state *del_streams[MAX_PIPES] = { 0 };\n\tstruct dc_stream_state *add_streams[MAX_PIPES] = { 0 };\n\tint old_stream_count = context->stream_count;\n\tenum dc_status res = DC_ERROR_UNEXPECTED;\n\tint unchanged_streams_count = 0;\n\tint del_streams_count = 0;\n\tint add_streams_count = 0;\n\tbool found = false;\n\tint i, j, k;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\t \n\tfor (i = 0; i < old_stream_count; i++) {\n\t\tstruct dc_stream_state *stream = context->streams[i];\n\n\t\tfor (j = 0; j < set_count; j++) {\n\t\t\tif (stream == set[j].stream) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tdel_streams[del_streams_count++] = stream;\n\n\t\tfound = false;\n\t}\n\n\t \n\tfor (i = 0; i < set_count; i++) {\n\t\tstruct dc_stream_state *stream = set[i].stream;\n\n\t\tfor (j = 0; j < old_stream_count; j++) {\n\t\t\tif (stream == context->streams[j]) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tadd_streams[add_streams_count++] = stream;\n\n\t\tfound = false;\n\t}\n\n\t \n\tfor (i = 0; i < set_count; i++) {\n\t\t \n\t\tfor (j = 0; j < del_streams_count; j++) {\n\t\t\tif (set[i].stream == del_streams[j]) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\t \n\t\t\tfor (j = 0; j < add_streams_count; j++) {\n\t\t\t\tif (set[i].stream == add_streams[j]) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tunchanged_streams[unchanged_streams_count++] = set[i].stream;\n\n\t\tfound = false;\n\t}\n\n\t \n\tfor (i = 0; i < unchanged_streams_count; i++) {\n\t\tif (planes_changed_for_existing_stream(context,\n\t\t\t\t\t\t       unchanged_streams[i],\n\t\t\t\t\t\t       set,\n\t\t\t\t\t\t       set_count)) {\n\t\t\tif (!dc_rem_all_planes_for_stream(dc,\n\t\t\t\t\t\t\t  unchanged_streams[i],\n\t\t\t\t\t\t\t  context)) {\n\t\t\t\tres = DC_FAIL_DETACH_SURFACES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < del_streams_count; i++) {\n\t\t \n\t\tif (del_streams[i]->num_wb_info > 0) {\n\t\t\tfor (j = 0; j < add_streams_count; j++) {\n\t\t\t\tif (del_streams[i]->sink == add_streams[j]->sink) {\n\t\t\t\t\tadd_streams[j]->num_wb_info = del_streams[i]->num_wb_info;\n\t\t\t\t\tfor (k = 0; k < del_streams[i]->num_wb_info; k++)\n\t\t\t\t\t\tadd_streams[j]->writeback_info[k] = del_streams[i]->writeback_info[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!dc_rem_all_planes_for_stream(dc, del_streams[i], context)) {\n\t\t\tres = DC_FAIL_DETACH_SURFACES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tres = dc_remove_stream_from_ctx(dc, context, del_streams[i]);\n\t\tif (res != DC_OK)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 0; i < add_streams_count; i++) {\n\t\tmark_seamless_boot_stream(dc, add_streams[i]);\n\t\tif (add_streams[i]->apply_seamless_boot_optimization && i != 0) {\n\t\t\tstruct dc_stream_state *temp = add_streams[0];\n\n\t\t\tadd_streams[0] = add_streams[i];\n\t\t\tadd_streams[i] = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < add_streams_count; i++) {\n\t\tcalculate_phy_pix_clks(add_streams[i]);\n\t\tres = dc_add_stream_to_ctx(dc, context, add_streams[i]);\n\t\tif (res != DC_OK)\n\t\t\tgoto fail;\n\n\t\tif (!add_all_planes_for_stream(dc, add_streams[i], set, set_count, context)) {\n\t\t\tres = DC_FAIL_ATTACH_SURFACES;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < unchanged_streams_count; i++) {\n\t\tif (planes_changed_for_existing_stream(context,\n\t\t\t\t\t\t       unchanged_streams[i],\n\t\t\t\t\t\t       set,\n\t\t\t\t\t\t       set_count)) {\n\t\t\tif (!add_all_planes_for_stream(dc, unchanged_streams[i], set, set_count, context)) {\n\t\t\t\tres = DC_FAIL_ATTACH_SURFACES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = dc_validate_global_state(dc, context, fast_validate);\n\nfail:\n\tif (res != DC_OK)\n\t\tDC_LOG_WARNING(\"%s:resource validation failed, dc_status:%d\\n\",\n\t\t\t       __func__,\n\t\t\t       res);\n\n\treturn res;\n}\n\n \nenum dc_status dc_validate_global_state(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tbool fast_validate)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\tint i, j;\n\n\tif (!new_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc->res_pool->funcs->validate_global) {\n\t\tresult = dc->res_pool->funcs->validate_global(dc, new_ctx);\n\t\tif (result != DC_OK)\n\t\t\treturn result;\n\t}\n\n\tfor (i = 0; i < new_ctx->stream_count; i++) {\n\t\tstruct dc_stream_state *stream = new_ctx->streams[i];\n\n\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[j];\n\n\t\t\tif (pipe_ctx->stream != stream)\n\t\t\t\tcontinue;\n\n\t\t\tif (dc->res_pool->funcs->patch_unknown_plane_state &&\n\t\t\t\t\tpipe_ctx->plane_state &&\n\t\t\t\t\tpipe_ctx->plane_state->tiling_info.gfx9.swizzle == DC_SW_UNKNOWN) {\n\t\t\t\tresult = dc->res_pool->funcs->patch_unknown_plane_state(pipe_ctx->plane_state);\n\t\t\t\tif (result != DC_OK)\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dc_is_dp_signal(pipe_ctx->stream->signal) &&\n\t\t\t\t!find_pll_sharable_stream(stream, new_ctx)) {\n\n\t\t\t\tresource_unreference_clock_source(\n\t\t\t\t\t\t&new_ctx->res_ctx,\n\t\t\t\t\t\tdc->res_pool,\n\t\t\t\t\t\tpipe_ctx->clock_source);\n\n\t\t\t\tpipe_ctx->clock_source = dc->res_pool->dp_clock_source;\n\t\t\t\tresource_reference_clock_source(\n\t\t\t\t\t\t&new_ctx->res_ctx,\n\t\t\t\t\t\tdc->res_pool,\n\t\t\t\t\t\t pipe_ctx->clock_source);\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = resource_build_scaling_params_for_context(dc, new_ctx);\n\n\tif (result == DC_OK)\n\t\tif (!dc->res_pool->funcs->validate_bandwidth(dc, new_ctx, fast_validate))\n\t\t\tresult = DC_FAIL_BANDWIDTH_VALIDATE;\n\n\t \n\tif (result == DC_OK && dc->res_pool->funcs->link_encs_assign && fast_validate == false)\n\t\tdc->res_pool->funcs->link_encs_assign(\n\t\t\tdc, new_ctx, new_ctx->streams, new_ctx->stream_count);\n\n\treturn result;\n}\n\nstatic void patch_gamut_packet_checksum(\n\t\tstruct dc_info_packet *gamut_packet)\n{\n\t \n\tif (gamut_packet->valid) {\n\t\tuint8_t chk_sum = 0;\n\t\tuint8_t *ptr;\n\t\tuint8_t i;\n\n\t\t \n\t\tptr = &gamut_packet->sb[3];\n\n\t\tfor (i = 0; i <= gamut_packet->sb[1]; i++)\n\t\t\tchk_sum += ptr[i];\n\n\t\tgamut_packet->sb[2] = (uint8_t) (0x100 - chk_sum);\n\t}\n}\n\nstatic void set_avi_info_frame(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tenum dc_color_space color_space = COLOR_SPACE_UNKNOWN;\n\tuint32_t pixel_encoding = 0;\n\tenum scanning_type scan_type = SCANNING_TYPE_NODATA;\n\tenum dc_aspect_ratio aspect = ASPECT_RATIO_NO_DATA;\n\tbool itc = false;\n\tuint8_t itc_value = 0;\n\tuint8_t cn0_cn1 = 0;\n\tunsigned int cn0_cn1_value = 0;\n\tuint8_t *check_sum = NULL;\n\tuint8_t byte_index = 0;\n\tunion hdmi_info_packet hdmi_info;\n\tunion display_content_support support = {0};\n\tunsigned int vic = pipe_ctx->stream->timing.vic;\n\tunsigned int rid = pipe_ctx->stream->timing.rid;\n\tunsigned int fr_ind = pipe_ctx->stream->timing.fr_index;\n\tenum dc_timing_3d_format format;\n\n\tmemset(&hdmi_info, 0, sizeof(union hdmi_info_packet));\n\n\tcolor_space = pipe_ctx->stream->output_color_space;\n\tif (color_space == COLOR_SPACE_UNKNOWN)\n\t\tcolor_space = (stream->timing.pixel_encoding == PIXEL_ENCODING_RGB) ?\n\t\t\tCOLOR_SPACE_SRGB:COLOR_SPACE_YCBCR709;\n\n\t \n\thdmi_info.bits.header.info_frame_type = HDMI_INFOFRAME_TYPE_AVI;\n\t \n\thdmi_info.bits.header.version = 2;\n\thdmi_info.bits.header.length = HDMI_AVI_INFOFRAME_SIZE;\n\n\t \n\n\tswitch (stream->timing.pixel_encoding) {\n\tcase PIXEL_ENCODING_YCBCR422:\n\t\tpixel_encoding = 1;\n\t\tbreak;\n\n\tcase PIXEL_ENCODING_YCBCR444:\n\t\tpixel_encoding = 2;\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR420:\n\t\tpixel_encoding = 3;\n\t\tbreak;\n\n\tcase PIXEL_ENCODING_RGB:\n\tdefault:\n\t\tpixel_encoding = 0;\n\t}\n\n\t \n\t \n\thdmi_info.bits.Y0_Y1_Y2 = pixel_encoding;\n\n\t \n\thdmi_info.bits.A0 = ACTIVE_FORMAT_VALID;\n\n\t \n\thdmi_info.bits.B0_B1 = BAR_INFO_BOTH_VALID;\n\n\thdmi_info.bits.SC0_SC1 = PICTURE_SCALING_UNIFORM;\n\n\t \n\t \n\tscan_type = SCANNING_TYPE_UNDERSCAN;\n\thdmi_info.bits.S0_S1 = scan_type;\n\n\t \n\tswitch (color_space) {\n\tcase COLOR_SPACE_YCBCR709:\n\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\t\thdmi_info.bits.C0_C1 = COLORIMETRY_ITU709;\n\t\tbreak;\n\tcase COLOR_SPACE_YCBCR601:\n\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\t\thdmi_info.bits.C0_C1 = COLORIMETRY_ITU601;\n\t\tbreak;\n\tcase COLOR_SPACE_2020_RGB_FULLRANGE:\n\tcase COLOR_SPACE_2020_RGB_LIMITEDRANGE:\n\tcase COLOR_SPACE_2020_YCBCR:\n\t\thdmi_info.bits.EC0_EC2 = COLORIMETRYEX_BT2020RGBYCBCR;\n\t\thdmi_info.bits.C0_C1   = COLORIMETRY_EXTENDED;\n\t\tbreak;\n\tcase COLOR_SPACE_ADOBERGB:\n\t\thdmi_info.bits.EC0_EC2 = COLORIMETRYEX_ADOBERGB;\n\t\thdmi_info.bits.C0_C1   = COLORIMETRY_EXTENDED;\n\t\tbreak;\n\tcase COLOR_SPACE_SRGB:\n\tdefault:\n\t\thdmi_info.bits.C0_C1 = COLORIMETRY_NO_DATA;\n\t\tbreak;\n\t}\n\n\tif (pixel_encoding && color_space == COLOR_SPACE_2020_YCBCR &&\n\t\t\tstream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {\n\t\thdmi_info.bits.EC0_EC2 = 0;\n\t\thdmi_info.bits.C0_C1 = COLORIMETRY_ITU709;\n\t}\n\n\t \n\taspect = stream->timing.aspect_ratio;\n\n\tswitch (aspect) {\n\tcase ASPECT_RATIO_4_3:\n\tcase ASPECT_RATIO_16_9:\n\t\thdmi_info.bits.M0_M1 = aspect;\n\t\tbreak;\n\n\tcase ASPECT_RATIO_NO_DATA:\n\tcase ASPECT_RATIO_64_27:\n\tcase ASPECT_RATIO_256_135:\n\tdefault:\n\t\thdmi_info.bits.M0_M1 = 0;\n\t}\n\n\t \n\thdmi_info.bits.R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;\n\n\t \n\n\tcn0_cn1 = 0;\n\tcn0_cn1_value = 0;\n\n\titc = true;\n\titc_value = 1;\n\n\tsupport = stream->content_support;\n\n\tif (itc) {\n\t\tif (!support.bits.valid_content_type) {\n\t\t\tcn0_cn1_value = 0;\n\t\t} else {\n\t\t\tif (cn0_cn1 == DISPLAY_CONTENT_TYPE_GRAPHICS) {\n\t\t\t\tif (support.bits.graphics_content == 1) {\n\t\t\t\t\tcn0_cn1_value = 0;\n\t\t\t\t}\n\t\t\t} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_PHOTO) {\n\t\t\t\tif (support.bits.photo_content == 1) {\n\t\t\t\t\tcn0_cn1_value = 1;\n\t\t\t\t} else {\n\t\t\t\t\tcn0_cn1_value = 0;\n\t\t\t\t\titc_value = 0;\n\t\t\t\t}\n\t\t\t} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_CINEMA) {\n\t\t\t\tif (support.bits.cinema_content == 1) {\n\t\t\t\t\tcn0_cn1_value = 2;\n\t\t\t\t} else {\n\t\t\t\t\tcn0_cn1_value = 0;\n\t\t\t\t\titc_value = 0;\n\t\t\t\t}\n\t\t\t} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_GAME) {\n\t\t\t\tif (support.bits.game_content == 1) {\n\t\t\t\t\tcn0_cn1_value = 3;\n\t\t\t\t} else {\n\t\t\t\t\tcn0_cn1_value = 0;\n\t\t\t\t\titc_value = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thdmi_info.bits.CN0_CN1 = cn0_cn1_value;\n\t\thdmi_info.bits.ITC = itc_value;\n\t}\n\n\tif (stream->qs_bit == 1) {\n\t\tif (color_space == COLOR_SPACE_SRGB ||\n\t\t\tcolor_space == COLOR_SPACE_2020_RGB_FULLRANGE)\n\t\t\thdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;\n\t\telse if (color_space == COLOR_SPACE_SRGB_LIMITED ||\n\t\t\t\t\tcolor_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE)\n\t\t\thdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;\n\t\telse\n\t\t\thdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;\n\t} else\n\t\thdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;\n\n\t \n\t \n\thdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;\n\n\t\n\tif (pipe_ctx->stream->timing.hdmi_vic != 0)\n\t\tvic = 0;\n\tformat = stream->timing.timing_3d_format;\n\t \n\tif (format != TIMING_3D_FORMAT_NONE) {\n\t\t\n\t\tswitch (pipe_ctx->stream->timing.hdmi_vic) {\n\t\tcase 1:\n\t\t\tvic = 95;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvic = 94;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvic = 93;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvic = 98;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\thdmi_info.bits.VIC0_VIC7 = vic;\n\tif (vic >= 128)\n\t\thdmi_info.bits.header.version = 3;\n\t \n\tif (hdmi_info.bits.C0_C1 == COLORIMETRY_EXTENDED &&\n\t\t\thdmi_info.bits.EC0_EC2 == COLORIMETRYEX_RESERVED) {\n\t\thdmi_info.bits.header.version = 4;\n\t\thdmi_info.bits.header.length = 14;\n\t}\n\n\tif (rid != 0 && fr_ind != 0) {\n\t\thdmi_info.bits.header.version = 5;\n\t\thdmi_info.bits.header.length = 15;\n\n\t\thdmi_info.bits.FR0_FR3 = fr_ind & 0xF;\n\t\thdmi_info.bits.FR4 = (fr_ind >> 4) & 0x1;\n\t\thdmi_info.bits.RID0_RID5 = rid;\n\t}\n\n\t \n\thdmi_info.bits.PR0_PR3 = 0;\n\n\t \n\thdmi_info.bits.bar_top = stream->timing.v_border_top;\n\thdmi_info.bits.bar_bottom = (stream->timing.v_total\n\t\t\t- stream->timing.v_border_bottom + 1);\n\thdmi_info.bits.bar_left  = stream->timing.h_border_left;\n\thdmi_info.bits.bar_right = (stream->timing.h_total\n\t\t\t- stream->timing.h_border_right + 1);\n\n     \n\thdmi_info.bits.ACE0_ACE3 = 0;\n\n\t \n\tcheck_sum = &hdmi_info.packet_raw_data.sb[0];\n\n\t*check_sum = HDMI_INFOFRAME_TYPE_AVI + hdmi_info.bits.header.length + hdmi_info.bits.header.version;\n\n\tfor (byte_index = 1; byte_index <= hdmi_info.bits.header.length; byte_index++)\n\t\t*check_sum += hdmi_info.packet_raw_data.sb[byte_index];\n\n\t \n\t*check_sum = (uint8_t) (0x100 - *check_sum);\n\n\t \n\tinfo_packet->hb0 = hdmi_info.packet_raw_data.hb0;\n\tinfo_packet->hb1 = hdmi_info.packet_raw_data.hb1;\n\tinfo_packet->hb2 = hdmi_info.packet_raw_data.hb2;\n\n\tfor (byte_index = 0; byte_index < sizeof(hdmi_info.packet_raw_data.sb); byte_index++)\n\t\tinfo_packet->sb[byte_index] = hdmi_info.packet_raw_data.sb[byte_index];\n\n\tinfo_packet->valid = true;\n}\n\nstatic void set_vendor_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\t \n\n\t \n\tif (!stream->vsp_infopacket.valid)\n\t\treturn;\n\n\t*info_packet = stream->vsp_infopacket;\n}\n\nstatic void set_spd_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\t \n\n\t \n\tif (!stream->vrr_infopacket.valid)\n\t\treturn;\n\n\t*info_packet = stream->vrr_infopacket;\n}\n\nstatic void set_hdr_static_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\t \n\n\tif (!stream->hdr_static_metadata.valid ||\n\t\t\tstream->use_dynamic_meta)\n\t\treturn;\n\n\t*info_packet = stream->hdr_static_metadata;\n}\n\nstatic void set_vsc_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\tif (!stream->vsc_infopacket.valid)\n\t\treturn;\n\n\t*info_packet = stream->vsc_infopacket;\n}\nstatic void set_hfvs_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\tif (!stream->hfvsif_infopacket.valid)\n\t\treturn;\n\n\t*info_packet = stream->hfvsif_infopacket;\n}\n\nstatic void adaptive_sync_override_dp_info_packets_sdp_line_num(\n\t\tconst struct dc_crtc_timing *timing,\n\t\tstruct enc_sdp_line_num *sdp_line_num,\n\t\tstruct _vcs_dpi_display_pipe_dest_params_st *pipe_dlg_param)\n{\n\tuint32_t asic_blank_start = 0;\n\tuint32_t asic_blank_end   = 0;\n\tuint32_t v_update = 0;\n\n\tconst struct dc_crtc_timing *tg = timing;\n\n\t \n\tasic_blank_start = tg->v_total - tg->v_front_porch;\n\n\t \n\tasic_blank_end = (asic_blank_start - tg->v_border_bottom -\n\t\t\t\t\t\ttg->v_addressable - tg->v_border_top);\n\n\tif (pipe_dlg_param->vstartup_start > asic_blank_end) {\n\t\tv_update = (tg->v_total - (pipe_dlg_param->vstartup_start - asic_blank_end));\n\t\tsdp_line_num->adaptive_sync_line_num_valid = true;\n\t\tsdp_line_num->adaptive_sync_line_num = (tg->v_total - v_update - 1);\n\t} else {\n\t\tsdp_line_num->adaptive_sync_line_num_valid = false;\n\t\tsdp_line_num->adaptive_sync_line_num = 0;\n\t}\n}\n\nstatic void set_adaptive_sync_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct encoder_info_frame *info_frame,\n\t\tstruct _vcs_dpi_display_pipe_dest_params_st *pipe_dlg_param)\n{\n\tif (!stream->adaptive_sync_infopacket.valid)\n\t\treturn;\n\n\tadaptive_sync_override_dp_info_packets_sdp_line_num(\n\t\t\t&stream->timing,\n\t\t\t&info_frame->sdp_line_num,\n\t\t\tpipe_dlg_param);\n\n\t*info_packet = stream->adaptive_sync_infopacket;\n}\n\nstatic void set_vtem_info_packet(\n\t\tstruct dc_info_packet *info_packet,\n\t\tstruct dc_stream_state *stream)\n{\n\tif (!stream->vtem_infopacket.valid)\n\t\treturn;\n\n\t*info_packet = stream->vtem_infopacket;\n}\n\nvoid dc_resource_state_destruct(struct dc_state *context)\n{\n\tint i, j;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tfor (j = 0; j < context->stream_status[i].plane_count; j++)\n\t\t\tdc_plane_state_release(\n\t\t\t\tcontext->stream_status[i].plane_states[j]);\n\n\t\tcontext->stream_status[i].plane_count = 0;\n\t\tdc_stream_release(context->streams[i]);\n\t\tcontext->streams[i] = NULL;\n\t}\n\tcontext->stream_count = 0;\n}\n\nvoid dc_resource_state_copy_construct(\n\t\tconst struct dc_state *src_ctx,\n\t\tstruct dc_state *dst_ctx)\n{\n\tint i, j;\n\tstruct kref refcount = dst_ctx->refcount;\n\n\t*dst_ctx = *src_ctx;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];\n\n\t\tif (cur_pipe->top_pipe)\n\t\t\tcur_pipe->top_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];\n\n\t\tif (cur_pipe->bottom_pipe)\n\t\t\tcur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];\n\n\t\tif (cur_pipe->next_odm_pipe)\n\t\t\tcur_pipe->next_odm_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->next_odm_pipe->pipe_idx];\n\n\t\tif (cur_pipe->prev_odm_pipe)\n\t\t\tcur_pipe->prev_odm_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->prev_odm_pipe->pipe_idx];\n\t}\n\n\tfor (i = 0; i < dst_ctx->stream_count; i++) {\n\t\tdc_stream_retain(dst_ctx->streams[i]);\n\t\tfor (j = 0; j < dst_ctx->stream_status[i].plane_count; j++)\n\t\t\tdc_plane_state_retain(\n\t\t\t\tdst_ctx->stream_status[i].plane_states[j]);\n\t}\n\n\t \n\tdst_ctx->refcount = refcount;\n\n}\n\nstruct clock_source *dc_resource_find_first_free_pll(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->clk_src_count; ++i) {\n\t\tif (res_ctx->clock_source_ref_count[i] == 0)\n\t\t\treturn pool->clock_sources[i];\n\t}\n\n\treturn NULL;\n}\n\nvoid resource_build_info_frame(struct pipe_ctx *pipe_ctx)\n{\n\tenum signal_type signal = SIGNAL_TYPE_NONE;\n\tstruct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;\n\n\t \n\tinfo->avi.valid = false;\n\tinfo->gamut.valid = false;\n\tinfo->vendor.valid = false;\n\tinfo->spd.valid = false;\n\tinfo->hdrsmd.valid = false;\n\tinfo->vsc.valid = false;\n\tinfo->hfvsif.valid = false;\n\tinfo->vtem.valid = false;\n\tinfo->adaptive_sync.valid = false;\n\tsignal = pipe_ctx->stream->signal;\n\n\t \n\tif (dc_is_hdmi_signal(signal)) {\n\t\tset_avi_info_frame(&info->avi, pipe_ctx);\n\n\t\tset_vendor_info_packet(&info->vendor, pipe_ctx->stream);\n\t\tset_hfvs_info_packet(&info->hfvsif, pipe_ctx->stream);\n\t\tset_vtem_info_packet(&info->vtem, pipe_ctx->stream);\n\n\t\tset_spd_info_packet(&info->spd, pipe_ctx->stream);\n\n\t\tset_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);\n\n\t} else if (dc_is_dp_signal(signal)) {\n\t\tset_vsc_info_packet(&info->vsc, pipe_ctx->stream);\n\n\t\tset_spd_info_packet(&info->spd, pipe_ctx->stream);\n\n\t\tset_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);\n\t\tset_adaptive_sync_info_packet(&info->adaptive_sync,\n\t\t\t\t\t\t\t\t\t\tpipe_ctx->stream,\n\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t&pipe_ctx->pipe_dlg_param);\n\t}\n\n\tpatch_gamut_packet_checksum(&info->gamut);\n}\n\nenum dc_status resource_map_clock_resources(\n\t\tconst struct dc  *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\t \n\tconst struct resource_pool *pool = dc->res_pool;\n\tstruct pipe_ctx *pipe_ctx = resource_get_otg_master_for_stream(\n\t\t\t\t&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)\n\t\t|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)\n\t\tpipe_ctx->clock_source = pool->dp_clock_source;\n\telse {\n\t\tpipe_ctx->clock_source = NULL;\n\n\t\tif (!dc->config.disable_disp_pll_sharing)\n\t\t\tpipe_ctx->clock_source = resource_find_used_clk_src_for_sharing(\n\t\t\t\t&context->res_ctx,\n\t\t\t\tpipe_ctx);\n\n\t\tif (pipe_ctx->clock_source == NULL)\n\t\t\tpipe_ctx->clock_source =\n\t\t\t\tdc_resource_find_first_free_pll(\n\t\t\t\t\t&context->res_ctx,\n\t\t\t\t\tpool);\n\t}\n\n\tif (pipe_ctx->clock_source == NULL)\n\t\treturn DC_NO_CLOCK_SOURCE_RESOURCE;\n\n\tresource_reference_clock_source(\n\t\t&context->res_ctx, pool,\n\t\tpipe_ctx->clock_source);\n\n\treturn DC_OK;\n}\n\n \nbool pipe_need_reprogram(\n\t\tstruct pipe_ctx *pipe_ctx_old,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tif (!pipe_ctx_old->stream)\n\t\treturn false;\n\n\tif (pipe_ctx_old->stream->sink != pipe_ctx->stream->sink)\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream->signal != pipe_ctx->stream->signal)\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream_res.audio != pipe_ctx->stream_res.audio)\n\t\treturn true;\n\n\tif (pipe_ctx_old->clock_source != pipe_ctx->clock_source\n\t\t\t&& pipe_ctx_old->stream != pipe_ctx->stream)\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream_res.stream_enc != pipe_ctx->stream_res.stream_enc)\n\t\treturn true;\n\n\tif (dc_is_timing_changed(pipe_ctx_old->stream, pipe_ctx->stream))\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream->dpms_off != pipe_ctx->stream->dpms_off)\n\t\treturn true;\n\n\tif (false == pipe_ctx_old->stream->link->link_state_valid &&\n\t\tfalse == pipe_ctx_old->stream->dpms_off)\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream_res.dsc != pipe_ctx->stream_res.dsc)\n\t\treturn true;\n\n\tif (pipe_ctx_old->stream_res.hpo_dp_stream_enc != pipe_ctx->stream_res.hpo_dp_stream_enc)\n\t\treturn true;\n\tif (pipe_ctx_old->link_res.hpo_dp_link_enc != pipe_ctx->link_res.hpo_dp_link_enc)\n\t\treturn true;\n\n\t \n\tif (pipe_ctx_old->stream->ctx->dc->res_pool->funcs->link_encs_assign) {\n\t\tbool need_reprogram = false;\n\t\tstruct dc *dc = pipe_ctx_old->stream->ctx->dc;\n\t\tstruct link_encoder *link_enc_prev =\n\t\t\tlink_enc_cfg_get_link_enc_used_by_stream_current(dc, pipe_ctx_old->stream);\n\n\t\tif (link_enc_prev != pipe_ctx->stream->link_enc)\n\t\t\tneed_reprogram = true;\n\n\t\treturn need_reprogram;\n\t}\n\n\treturn false;\n}\n\nvoid resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,\n\t\tstruct bit_depth_reduction_params *fmt_bit_depth)\n{\n\tenum dc_dither_option option = stream->dither_option;\n\tenum dc_pixel_encoding pixel_encoding =\n\t\t\tstream->timing.pixel_encoding;\n\n\tmemset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));\n\n\tif (option == DITHER_OPTION_DEFAULT) {\n\t\tswitch (stream->timing.display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\t\toption = DITHER_OPTION_SPATIAL6;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_888:\n\t\t\toption = DITHER_OPTION_SPATIAL8;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\toption = DITHER_OPTION_SPATIAL10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toption = DITHER_OPTION_DISABLE;\n\t\t}\n\t}\n\n\tif (option == DITHER_OPTION_DISABLE)\n\t\treturn;\n\n\tif (option == DITHER_OPTION_TRUN6) {\n\t\tfmt_bit_depth->flags.TRUNCATE_ENABLED = 1;\n\t\tfmt_bit_depth->flags.TRUNCATE_DEPTH = 0;\n\t} else if (option == DITHER_OPTION_TRUN8 ||\n\t\t\toption == DITHER_OPTION_TRUN8_SPATIAL6 ||\n\t\t\toption == DITHER_OPTION_TRUN8_FM6) {\n\t\tfmt_bit_depth->flags.TRUNCATE_ENABLED = 1;\n\t\tfmt_bit_depth->flags.TRUNCATE_DEPTH = 1;\n\t} else if (option == DITHER_OPTION_TRUN10        ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL6   ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL8   ||\n\t\t\toption == DITHER_OPTION_TRUN10_FM8     ||\n\t\t\toption == DITHER_OPTION_TRUN10_FM6     ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {\n\t\tfmt_bit_depth->flags.TRUNCATE_ENABLED = 1;\n\t\tfmt_bit_depth->flags.TRUNCATE_DEPTH = 2;\n\t}\n\n\t \n\tif (option == DITHER_OPTION_SPATIAL6_FRAME_RANDOM ||\n\t\t\toption == DITHER_OPTION_SPATIAL6 ||\n\t\t\toption == DITHER_OPTION_FM6) {\n\t\tfmt_bit_depth->flags.TRUNCATE_ENABLED = 1;\n\t\tfmt_bit_depth->flags.TRUNCATE_DEPTH = 2;\n\t\tfmt_bit_depth->flags.TRUNCATE_MODE = 1;\n\t}\n\n\t \n\tif (option == DITHER_OPTION_SPATIAL6_FRAME_RANDOM            ||\n\t\t\toption == DITHER_OPTION_SPATIAL6 ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL6      ||\n\t\t\toption == DITHER_OPTION_TRUN8_SPATIAL6) {\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 0;\n\t\tfmt_bit_depth->flags.HIGHPASS_RANDOM = 1;\n\t\tfmt_bit_depth->flags.RGB_RANDOM =\n\t\t\t\t(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;\n\t} else if (option == DITHER_OPTION_SPATIAL8_FRAME_RANDOM            ||\n\t\t\toption == DITHER_OPTION_SPATIAL8 ||\n\t\t\toption == DITHER_OPTION_SPATIAL8_FM6        ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL8      ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 1;\n\t\tfmt_bit_depth->flags.HIGHPASS_RANDOM = 1;\n\t\tfmt_bit_depth->flags.RGB_RANDOM =\n\t\t\t\t(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;\n\t} else if (option == DITHER_OPTION_SPATIAL10_FRAME_RANDOM ||\n\t\t\toption == DITHER_OPTION_SPATIAL10 ||\n\t\t\toption == DITHER_OPTION_SPATIAL10_FM8 ||\n\t\t\toption == DITHER_OPTION_SPATIAL10_FM6) {\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;\n\t\tfmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 2;\n\t\tfmt_bit_depth->flags.HIGHPASS_RANDOM = 1;\n\t\tfmt_bit_depth->flags.RGB_RANDOM =\n\t\t\t\t(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;\n\t}\n\n\tif (option == DITHER_OPTION_SPATIAL6 ||\n\t\t\toption == DITHER_OPTION_SPATIAL8 ||\n\t\t\toption == DITHER_OPTION_SPATIAL10) {\n\t\tfmt_bit_depth->flags.FRAME_RANDOM = 0;\n\t} else {\n\t\tfmt_bit_depth->flags.FRAME_RANDOM = 1;\n\t}\n\n\t \n\t \n\t \n\tif (option == DITHER_OPTION_FM6           ||\n\t\t\toption == DITHER_OPTION_SPATIAL8_FM6     ||\n\t\t\toption == DITHER_OPTION_SPATIAL10_FM6     ||\n\t\t\toption == DITHER_OPTION_TRUN10_FM6     ||\n\t\t\toption == DITHER_OPTION_TRUN8_FM6      ||\n\t\t\toption == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 0;\n\t} else if (option == DITHER_OPTION_FM8        ||\n\t\t\toption == DITHER_OPTION_SPATIAL10_FM8  ||\n\t\t\toption == DITHER_OPTION_TRUN10_FM8) {\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 1;\n\t} else if (option == DITHER_OPTION_FM10) {\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;\n\t\tfmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 2;\n\t}\n\n\tfmt_bit_depth->pixel_encoding = pixel_encoding;\n}\n\nenum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)\n{\n\tstruct dc_link *link = stream->link;\n\tstruct timing_generator *tg = dc->res_pool->timing_generators[0];\n\tenum dc_status res = DC_OK;\n\n\tcalculate_phy_pix_clks(stream);\n\n\tif (!tg->funcs->validate_timing(tg, &stream->timing))\n\t\tres = DC_FAIL_CONTROLLER_VALIDATE;\n\n\tif (res == DC_OK) {\n\t\tif (link->ep_type == DISPLAY_ENDPOINT_PHY &&\n\t\t\t\t!link->link_enc->funcs->validate_output_with_stream(\n\t\t\t\t\t\tlink->link_enc, stream))\n\t\t\tres = DC_FAIL_ENC_VALIDATE;\n\t}\n\n\t \n\n\tif (res == DC_OK)\n\t\tres = dc->link_srv->validate_mode_timing(stream,\n\t\t      link,\n\t\t      &stream->timing);\n\n\treturn res;\n}\n\nenum dc_status dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)\n{\n\tenum dc_status res = DC_OK;\n\n\t \n\tif (plane_state->src_rect.width == 0 || plane_state->src_rect.height == 0 ||\n\t\tplane_state->dst_rect.width == 0 || plane_state->dst_rect.height == 0)\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\t \n\tif (dc->res_pool->funcs->validate_plane)\n\t\treturn dc->res_pool->funcs->validate_plane(plane_state, &dc->caps);\n\n\treturn res;\n}\n\nunsigned int resource_pixel_format_to_bpp(enum surface_pixel_format format)\n{\n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:\n\t\treturn 8;\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\treturn 12;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\treturn 16;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGBE:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA:\n\t\treturn 32;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\treturn 64;\n\tdefault:\n\t\tASSERT_CRITICAL(false);\n\t\treturn -1;\n\t}\n}\nstatic unsigned int get_max_audio_sample_rate(struct audio_mode *modes)\n{\n\tif (modes) {\n\t\tif (modes->sample_rates.rate.RATE_192)\n\t\t\treturn 192000;\n\t\tif (modes->sample_rates.rate.RATE_176_4)\n\t\t\treturn 176400;\n\t\tif (modes->sample_rates.rate.RATE_96)\n\t\t\treturn 96000;\n\t\tif (modes->sample_rates.rate.RATE_88_2)\n\t\t\treturn 88200;\n\t\tif (modes->sample_rates.rate.RATE_48)\n\t\t\treturn 48000;\n\t\tif (modes->sample_rates.rate.RATE_44_1)\n\t\t\treturn 44100;\n\t\tif (modes->sample_rates.rate.RATE_32)\n\t\t\treturn 32000;\n\t}\n\t \n\treturn 441000;\n}\n\nvoid get_audio_check(struct audio_info *aud_modes,\n\tstruct audio_check *audio_chk)\n{\n\tunsigned int i;\n\tunsigned int max_sample_rate = 0;\n\n\tif (aud_modes) {\n\t\taudio_chk->audio_packet_type = 0x2; \n\n\t\taudio_chk->max_audiosample_rate = 0;\n\t\tfor (i = 0; i < aud_modes->mode_count; i++) {\n\t\t\tmax_sample_rate = get_max_audio_sample_rate(&aud_modes->modes[i]);\n\t\t\tif (audio_chk->max_audiosample_rate < max_sample_rate)\n\t\t\t\taudio_chk->max_audiosample_rate = max_sample_rate;\n\t\t\t \n\t\t}\n\t\t \n\t\tif (audio_chk->max_audiosample_rate > 192000)\n\t\t\taudio_chk->audio_packet_type = 0x9; \n\t\taudio_chk->acat = 0; \n\t}\n}\n\nstatic struct hpo_dp_link_encoder *get_temp_hpo_dp_link_enc(\n\t\tconst struct resource_context *res_ctx,\n\t\tconst struct resource_pool *const pool,\n\t\tconst struct dc_link *link)\n{\n\tstruct hpo_dp_link_encoder *hpo_dp_link_enc = NULL;\n\tint enc_index;\n\n\tenc_index = find_acquired_hpo_dp_link_enc_for_link(res_ctx, link);\n\n\tif (enc_index < 0)\n\t\tenc_index = find_free_hpo_dp_link_enc(res_ctx, pool);\n\n\tif (enc_index >= 0)\n\t\thpo_dp_link_enc = pool->hpo_dp_link_enc[enc_index];\n\n\treturn hpo_dp_link_enc;\n}\n\nbool get_temp_dp_link_res(struct dc_link *link,\n\t\tstruct link_resource *link_res,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tconst struct dc *dc  = link->dc;\n\tconst struct resource_context *res_ctx = &dc->current_state->res_ctx;\n\n\tmemset(link_res, 0, sizeof(*link_res));\n\n\tif (dc->link_srv->dp_get_encoding_format(link_settings) == DP_128b_132b_ENCODING) {\n\t\tlink_res->hpo_dp_link_enc = get_temp_hpo_dp_link_enc(res_ctx,\n\t\t\t\tdc->res_pool, link);\n\t\tif (!link_res->hpo_dp_link_enc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid reset_syncd_pipes_from_disabled_pipes(struct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\tstruct pipe_ctx *pipe_ctx_old, *pipe_ctx, *pipe_ctx_syncd;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe_ctx_old =\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tpipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!resource_is_pipe_type(pipe_ctx_old, OTG_MASTER))\n\t\t\tcontinue;\n\n\t\tif (!pipe_ctx->stream ||\n\t\t\t\tpipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {\n\n\t\t\t \n\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\tpipe_ctx_syncd = &context->res_ctx.pipe_ctx[j];\n\t\t\t\tif ((GET_PIPE_SYNCD_FROM_PIPE(pipe_ctx_syncd) == pipe_ctx_old->pipe_idx) ||\n\t\t\t\t\t!IS_PIPE_SYNCD_VALID(pipe_ctx_syncd))\n\t\t\t\t\tSET_PIPE_SYNCD_TO_PIPE(pipe_ctx_syncd, j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid check_syncd_pipes_for_disabled_master_pipe(struct dc *dc,\n\tstruct dc_state *context,\n\tuint8_t disabled_master_pipe_idx)\n{\n\tint i;\n\tstruct pipe_ctx *pipe_ctx, *pipe_ctx_check;\n\n\tpipe_ctx = &context->res_ctx.pipe_ctx[disabled_master_pipe_idx];\n\tif ((GET_PIPE_SYNCD_FROM_PIPE(pipe_ctx) != disabled_master_pipe_idx) ||\n\t\t!IS_PIPE_SYNCD_VALID(pipe_ctx))\n\t\tSET_PIPE_SYNCD_TO_PIPE(pipe_ctx, disabled_master_pipe_idx);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe_ctx_check = &context->res_ctx.pipe_ctx[i];\n\n\t\tif ((GET_PIPE_SYNCD_FROM_PIPE(pipe_ctx_check) == disabled_master_pipe_idx) &&\n\t\t    IS_PIPE_SYNCD_VALID(pipe_ctx_check) && (i != disabled_master_pipe_idx)) {\n\t\t\tstruct pipe_ctx *first_pipe = pipe_ctx_check;\n\n\t\t\twhile (first_pipe->prev_odm_pipe)\n\t\t\t\tfirst_pipe = first_pipe->prev_odm_pipe;\n\t\t\t \n\t\t\tif (first_pipe->pipe_idx == disabled_master_pipe_idx)\n\t\t\t\tcontinue;\n\n\t\t\tDC_ERR(\"DC: Failure: pipe_idx[%d] syncd with disabled master pipe_idx[%d]\\n\",\n\t\t\t\t   i, disabled_master_pipe_idx);\n\t\t}\n\t}\n}\n\nvoid reset_sync_context_for_pipe(const struct dc *dc,\n\tstruct dc_state *context,\n\tuint8_t pipe_idx)\n{\n\tint i;\n\tstruct pipe_ctx *pipe_ctx_reset;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe_ctx_reset = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (((GET_PIPE_SYNCD_FROM_PIPE(pipe_ctx_reset) == pipe_idx) &&\n\t\t\tIS_PIPE_SYNCD_VALID(pipe_ctx_reset)) || (i == pipe_idx))\n\t\t\tSET_PIPE_SYNCD_TO_PIPE(pipe_ctx_reset, i);\n\t}\n}\n\nuint8_t resource_transmitter_to_phy_idx(const struct dc *dc, enum transmitter transmitter)\n{\n\t \n\tuint8_t phy_idx = transmitter - TRANSMITTER_UNIPHY_A;\n\n\tif (dc->ctx->dce_version == DCN_VERSION_3_1 &&\n\t\t\tdc->ctx->asic_id.hw_internal_rev == YELLOW_CARP_B0) {\n\t\tswitch (transmitter) {\n\t\tcase TRANSMITTER_UNIPHY_A:\n\t\t\tphy_idx = 0;\n\t\t\tbreak;\n\t\tcase TRANSMITTER_UNIPHY_B:\n\t\t\tphy_idx = 1;\n\t\t\tbreak;\n\t\tcase TRANSMITTER_UNIPHY_C:\n\t\t\tphy_idx = 5;\n\t\t\tbreak;\n\t\tcase TRANSMITTER_UNIPHY_D:\n\t\t\tphy_idx = 6;\n\t\t\tbreak;\n\t\tcase TRANSMITTER_UNIPHY_E:\n\t\t\tphy_idx = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphy_idx = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn phy_idx;\n}\n\nconst struct link_hwss *get_link_hwss(const struct dc_link *link,\n\t\tconst struct link_resource *link_res)\n{\n\t \n\tif (can_use_hpo_dp_link_hwss(link, link_res))\n\t\t \n\t\treturn (requires_fixed_vs_pe_retimer_hpo_link_hwss(link) ?\n\t\t\t\tget_hpo_fixed_vs_pe_retimer_dp_link_hwss() : get_hpo_dp_link_hwss());\n\telse if (can_use_dpia_link_hwss(link, link_res))\n\t\treturn get_dpia_link_hwss();\n\telse if (can_use_dio_link_hwss(link, link_res))\n\t\treturn (requires_fixed_vs_pe_retimer_dio_link_hwss(link)) ?\n\t\t\t\tget_dio_fixed_vs_pe_retimer_link_hwss() : get_dio_link_hwss();\n\telse\n\t\treturn get_virtual_link_hwss();\n}\n\nbool is_h_timing_divisible_by_2(struct dc_stream_state *stream)\n{\n\tbool divisible = false;\n\tuint16_t h_blank_start = 0;\n\tuint16_t h_blank_end = 0;\n\n\tif (stream) {\n\t\th_blank_start = stream->timing.h_total - stream->timing.h_front_porch;\n\t\th_blank_end = h_blank_start - stream->timing.h_addressable;\n\n\t\t \n\t\tdivisible = (stream->timing.h_total % 2 == 0) &&\n\t\t\t\t(h_blank_start % 2 == 0) &&\n\t\t\t\t(h_blank_end % 2 == 0) &&\n\t\t\t\t(stream->timing.h_sync_width % 2 == 0);\n\t}\n\treturn divisible;\n}\n\nbool dc_resource_acquire_secondary_pipe_for_mpc_odm(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *state,\n\t\tstruct pipe_ctx *pri_pipe,\n\t\tstruct pipe_ctx *sec_pipe,\n\t\tbool odm)\n{\n\tint pipe_idx = sec_pipe->pipe_idx;\n\tstruct pipe_ctx *sec_top, *sec_bottom, *sec_next, *sec_prev;\n\tconst struct resource_pool *pool = dc->res_pool;\n\n\tsec_top = sec_pipe->top_pipe;\n\tsec_bottom = sec_pipe->bottom_pipe;\n\tsec_next = sec_pipe->next_odm_pipe;\n\tsec_prev = sec_pipe->prev_odm_pipe;\n\n\t*sec_pipe = *pri_pipe;\n\n\tsec_pipe->top_pipe = sec_top;\n\tsec_pipe->bottom_pipe = sec_bottom;\n\tsec_pipe->next_odm_pipe = sec_next;\n\tsec_pipe->prev_odm_pipe = sec_prev;\n\n\tsec_pipe->pipe_idx = pipe_idx;\n\tsec_pipe->plane_res.mi = pool->mis[pipe_idx];\n\tsec_pipe->plane_res.hubp = pool->hubps[pipe_idx];\n\tsec_pipe->plane_res.ipp = pool->ipps[pipe_idx];\n\tsec_pipe->plane_res.xfm = pool->transforms[pipe_idx];\n\tsec_pipe->plane_res.dpp = pool->dpps[pipe_idx];\n\tsec_pipe->plane_res.mpcc_inst = pool->dpps[pipe_idx]->inst;\n\tsec_pipe->stream_res.dsc = NULL;\n\tif (odm) {\n\t\tif (!sec_pipe->top_pipe)\n\t\t\tsec_pipe->stream_res.opp = pool->opps[pipe_idx];\n\t\telse\n\t\t\tsec_pipe->stream_res.opp = sec_pipe->top_pipe->stream_res.opp;\n\t\tif (sec_pipe->stream->timing.flags.DSC == 1) {\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\t\t\tdcn20_acquire_dsc(dc, &state->res_ctx, &sec_pipe->stream_res.dsc, pipe_idx);\n#endif\n\t\t\tASSERT(sec_pipe->stream_res.dsc);\n\t\t\tif (sec_pipe->stream_res.dsc == NULL)\n\t\t\t\treturn false;\n\t\t}\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\t\tdcn20_build_mapped_resource(dc, state, sec_pipe->stream);\n#endif\n\t}\n\n\treturn true;\n}\n\nenum dc_status update_dp_encoder_resources_for_test_harness(const struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tif (dc->link_srv->dp_get_encoding_format(&pipe_ctx->link_config.dp_link_settings) == DP_128b_132b_ENCODING) {\n\t\tif (pipe_ctx->stream_res.hpo_dp_stream_enc == NULL) {\n\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc =\n\t\t\t\t\tfind_first_free_match_hpo_dp_stream_enc_for_link(\n\t\t\t\t\t\t\t&context->res_ctx, dc->res_pool, pipe_ctx->stream);\n\n\t\t\tif (!pipe_ctx->stream_res.hpo_dp_stream_enc)\n\t\t\t\treturn DC_NO_STREAM_ENC_RESOURCE;\n\n\t\t\tupdate_hpo_dp_stream_engine_usage(\n\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\ttrue);\n\t\t}\n\n\t\tif (pipe_ctx->link_res.hpo_dp_link_enc == NULL) {\n\t\t\tif (!add_hpo_dp_link_enc_to_ctx(&context->res_ctx, dc->res_pool, pipe_ctx, pipe_ctx->stream))\n\t\t\t\treturn DC_NO_LINK_ENC_RESOURCE;\n\t\t}\n\t} else {\n\t\tif (pipe_ctx->stream_res.hpo_dp_stream_enc) {\n\t\t\tupdate_hpo_dp_stream_engine_usage(\n\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t\tfalse);\n\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc = NULL;\n\t\t}\n\t\tif (pipe_ctx->link_res.hpo_dp_link_enc)\n\t\t\tremove_hpo_dp_link_enc_from_ctx(&context->res_ctx, pipe_ctx, pipe_ctx->stream);\n\t}\n\n\treturn DC_OK;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}