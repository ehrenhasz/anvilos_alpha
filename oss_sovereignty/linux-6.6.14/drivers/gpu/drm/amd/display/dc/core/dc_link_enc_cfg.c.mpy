{
  "module_name": "dc_link_enc_cfg.c",
  "hash_id": "974d2c05279d96ac0cc5ea77362a9ab9281c537ae9f4743f5f6d7ec6ff332e35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/core/dc_link_enc_cfg.c",
  "human_readable_source": " \n\n#include \"link_enc_cfg.h\"\n#include \"resource.h\"\n#include \"link.h\"\n\n#define DC_LOGGER dc->ctx->logger\n\n \nstatic bool is_dig_link_enc_stream(struct dc_stream_state *stream)\n{\n\tbool is_dig_stream = false;\n\tstruct link_encoder *link_enc = NULL;\n\tint i;\n\n\t \n\tif (stream) {\n\t\tfor (i = 0; i < stream->ctx->dc->res_pool->res_cap->num_dig_link_enc; i++) {\n\t\t\tlink_enc = stream->ctx->dc->res_pool->link_encoders[i];\n\n\t\t\t \n\t\t\tif (link_enc && ((uint32_t)stream->link->connector_signal & link_enc->output_signals)) {\n\t\t\t\tif (dc_is_dp_signal(stream->signal)) {\n\t\t\t\t\t \n\t\t\t\t\tstruct dc_link_settings link_settings = {0};\n\n\t\t\t\t\tstream->ctx->dc->link_srv->dp_decide_link_settings(stream, &link_settings);\n\t\t\t\t\tif ((link_settings.link_rate >= LINK_RATE_LOW) &&\n\t\t\t\t\t\t\tlink_settings.link_rate <= LINK_RATE_HIGH3) {\n\t\t\t\t\t\tis_dig_stream = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tis_dig_stream = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn is_dig_stream;\n}\n\nstatic struct link_enc_assignment get_assignment(struct dc *dc, int i)\n{\n\tstruct link_enc_assignment assignment;\n\n\tif (dc->current_state->res_ctx.link_enc_cfg_ctx.mode == LINK_ENC_CFG_TRANSIENT)\n\t\tassignment = dc->current_state->res_ctx.link_enc_cfg_ctx.transient_assignments[i];\n\telse  \n\t\tassignment = dc->current_state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\treturn assignment;\n}\n\n \nstatic struct dc_stream_state *get_stream_using_link_enc(\n\t\tstruct dc_state *state,\n\t\tenum engine_id eng_id)\n{\n\tstruct dc_stream_state *stream = NULL;\n\tint i;\n\n\tfor (i = 0; i < state->stream_count; i++) {\n\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif ((assignment.valid == true) && (assignment.eng_id == eng_id)) {\n\t\t\tstream = state->streams[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn stream;\n}\n\nstatic void remove_link_enc_assignment(\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *stream,\n\t\tenum engine_id eng_id)\n{\n\tint eng_idx;\n\tint i;\n\n\tif (eng_id != ENGINE_ID_UNKNOWN) {\n\t\teng_idx = eng_id - ENGINE_ID_DIGA;\n\n\t\t \n\t\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\t\tif (assignment.valid && assignment.stream == stream) {\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].valid = false;\n\t\t\t\t \n\t\t\t\tif (get_stream_using_link_enc(state, eng_id) == NULL)\n\t\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_avail[eng_idx] = eng_id;\n\n\t\t\t\tstream->link_enc = NULL;\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].eng_id = ENGINE_ID_UNKNOWN;\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].stream = NULL;\n\t\t\t\tdc_stream_release(stream);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void add_link_enc_assignment(\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *stream,\n\t\tenum engine_id eng_id)\n{\n\tint eng_idx;\n\tint i;\n\n\tif (eng_id != ENGINE_ID_UNKNOWN) {\n\t\teng_idx = eng_id - ENGINE_ID_DIGA;\n\n\t\t \n\t\tfor (i = 0; i < state->stream_count; i++) {\n\t\t\tif (stream == state->streams[i]) {\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i] = (struct link_enc_assignment){\n\t\t\t\t\t.valid = true,\n\t\t\t\t\t.ep_id = (struct display_endpoint_id) {\n\t\t\t\t\t\t.link_id = stream->link->link_id,\n\t\t\t\t\t\t.ep_type = stream->link->ep_type},\n\t\t\t\t\t.eng_id = eng_id,\n\t\t\t\t\t.stream = stream};\n\t\t\t\tdc_stream_retain(stream);\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_avail[eng_idx] = ENGINE_ID_UNKNOWN;\n\t\t\t\tstream->link_enc = stream->ctx->dc->res_pool->link_encoders[eng_idx];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tASSERT(i != state->stream_count);\n\t}\n}\n\n \nstatic enum engine_id find_first_avail_link_enc(\n\t\tconst struct dc_context *ctx,\n\t\tconst struct dc_state *state,\n\t\tenum engine_id eng_id_requested)\n{\n\tenum engine_id eng_id = ENGINE_ID_UNKNOWN;\n\tint i;\n\n\tif (eng_id_requested != ENGINE_ID_UNKNOWN) {\n\n\t\tfor (i = 0; i < ctx->dc->res_pool->res_cap->num_dig_link_enc; i++) {\n\t\t\teng_id = state->res_ctx.link_enc_cfg_ctx.link_enc_avail[i];\n\t\t\tif (eng_id == eng_id_requested)\n\t\t\t\treturn eng_id;\n\t\t}\n\t}\n\n\teng_id = ENGINE_ID_UNKNOWN;\n\n\tfor (i = 0; i < ctx->dc->res_pool->res_cap->num_dig_link_enc; i++) {\n\t\teng_id = state->res_ctx.link_enc_cfg_ctx.link_enc_avail[i];\n\t\tif (eng_id != ENGINE_ID_UNKNOWN)\n\t\t\tbreak;\n\t}\n\n\treturn eng_id;\n}\n\n \nstatic bool is_avail_link_enc(struct dc_state *state, enum engine_id eng_id, struct dc_stream_state *stream)\n{\n\tbool is_avail = false;\n\tint eng_idx = eng_id - ENGINE_ID_DIGA;\n\n\t \n\tif (eng_id != ENGINE_ID_UNKNOWN && state->res_ctx.link_enc_cfg_ctx.link_enc_avail[eng_idx] != ENGINE_ID_UNKNOWN) {\n\t\tis_avail = true;\n\t} else {\n\t\tstruct dc_stream_state *stream_assigned = NULL;\n\n\t\t \n\t\tstream_assigned = get_stream_using_link_enc(state, eng_id);\n\t\tif (stream_assigned && stream != stream_assigned && stream->link == stream_assigned->link)\n\t\t\tis_avail = true;\n\t}\n\n\treturn is_avail;\n}\n\n \nstatic bool are_ep_ids_equal(struct display_endpoint_id *lhs, struct display_endpoint_id *rhs)\n{\n\tbool are_equal = false;\n\n\tif (lhs->link_id.id == rhs->link_id.id &&\n\t\t\tlhs->link_id.enum_id == rhs->link_id.enum_id &&\n\t\t\tlhs->link_id.type == rhs->link_id.type &&\n\t\t\tlhs->ep_type == rhs->ep_type)\n\t\tare_equal = true;\n\n\treturn are_equal;\n}\n\nstatic struct link_encoder *get_link_enc_used_by_link(\n\t\tstruct dc_state *state,\n\t\tconst struct dc_link *link)\n{\n\tstruct link_encoder *link_enc = NULL;\n\tstruct display_endpoint_id ep_id;\n\tint i;\n\n\tep_id = (struct display_endpoint_id) {\n\t\t.link_id = link->link_id,\n\t\t.ep_type = link->ep_type};\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid == true && are_ep_ids_equal(&assignment.ep_id, &ep_id))\n\t\t\tlink_enc = link->dc->res_pool->link_encoders[assignment.eng_id - ENGINE_ID_DIGA];\n\t}\n\n\treturn link_enc;\n}\n \nstatic void clear_enc_assignments(const struct dc *dc, struct dc_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].valid = false;\n\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].eng_id = ENGINE_ID_UNKNOWN;\n\t\tif (state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].stream != NULL) {\n\t\t\tdc_stream_release(state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].stream);\n\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].stream = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->res_cap->num_dig_link_enc; i++) {\n\t\tif (dc->res_pool->link_encoders[i])\n\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_avail[i] = (enum engine_id) i;\n\t\telse\n\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_avail[i] = ENGINE_ID_UNKNOWN;\n\t}\n}\n\nvoid link_enc_cfg_init(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *state)\n{\n\tclear_enc_assignments(dc, state);\n\n\tstate->res_ctx.link_enc_cfg_ctx.mode = LINK_ENC_CFG_STEADY;\n}\n\nvoid link_enc_cfg_copy(const struct dc_state *src_ctx, struct dc_state *dst_ctx)\n{\n\tmemcpy(&dst_ctx->res_ctx.link_enc_cfg_ctx,\n\t       &src_ctx->res_ctx.link_enc_cfg_ctx,\n\t       sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx));\n}\n\nvoid link_enc_cfg_link_encs_assign(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *streams[],\n\t\tuint8_t stream_count)\n{\n\tenum engine_id eng_id = ENGINE_ID_UNKNOWN, eng_id_req = ENGINE_ID_UNKNOWN;\n\tint i;\n\tint j;\n\n\tASSERT(state->stream_count == stream_count);\n\tASSERT(dc->current_state->res_ctx.link_enc_cfg_ctx.mode == LINK_ENC_CFG_STEADY);\n\n\t \n\tfor (i = 0; i < dc->current_state->stream_count; i++)\n\t\tdc->res_pool->funcs->link_enc_unassign(state, dc->current_state->streams[i]);\n\n\tfor (i = 0; i < MAX_PIPES; i++)\n\t\tASSERT(state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i].valid == false);\n\n\t \n\tfor (i = 0; i < stream_count; i++) {\n\t\tstruct dc_stream_state *stream = streams[i];\n\n\t\t \n\t\tif (stream->link->is_dig_mapping_flexible)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!is_dig_link_enc_stream(stream))\n\t\t\tcontinue;\n\n\t\t \n\t\teng_id = stream->link->eng_id;\n\t\tadd_link_enc_assignment(state, stream, eng_id);\n\t}\n\n\t \n\teng_id = ENGINE_ID_UNKNOWN;\n\n\tif (state != dc->current_state) {\n\t\tstruct dc_state *prev_state = dc->current_state;\n\n\t\tfor (i = 0; i < stream_count; i++) {\n\t\t\tstruct dc_stream_state *stream = state->streams[i];\n\n\t\t\t \n\t\t\tif (!stream->link->is_dig_mapping_flexible)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!is_dig_link_enc_stream(stream))\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < prev_state->stream_count; j++) {\n\t\t\t\tstruct dc_stream_state *prev_stream = prev_state->streams[j];\n\n\t\t\t\tif (stream == prev_stream && stream->link == prev_stream->link &&\n\t\t\t\t\t\tprev_state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[j].valid) {\n\t\t\t\t\teng_id = prev_state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[j].eng_id;\n\n\t\t\t\t\tif (is_avail_link_enc(state, eng_id, stream))\n\t\t\t\t\t\tadd_link_enc_assignment(state, stream, eng_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\teng_id = ENGINE_ID_UNKNOWN;\n\n\tfor (i = 0; i < stream_count; i++) {\n\t\tstruct dc_stream_state *stream = streams[i];\n\t\tstruct link_encoder *link_enc = NULL;\n\n\t\t \n\t\tif (!stream->link->is_dig_mapping_flexible)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (stream->link_enc)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!is_dig_link_enc_stream(stream)) {\n\t\t\tASSERT(stream->link->is_dig_mapping_flexible != true);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tlink_enc = get_link_enc_used_by_link(state, stream->link);\n\t\tif (link_enc == NULL) {\n\n\t\t\tif (stream->link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA &&\n\t\t\t\t\tstream->link->dpia_preferred_eng_id != ENGINE_ID_UNKNOWN)\n\t\t\t\teng_id_req = stream->link->dpia_preferred_eng_id;\n\n\t\t\teng_id = find_first_avail_link_enc(stream->ctx, state, eng_id_req);\n\t\t}\n\t\telse\n\t\t\teng_id =  link_enc->preferred_engine;\n\n\t\tadd_link_enc_assignment(state, stream, eng_id);\n\t}\n\n\tlink_enc_cfg_validate(dc, state);\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tdc->current_state->res_ctx.link_enc_cfg_ctx.transient_assignments[i] =\n\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\t}\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment =\n\t\t\t\tdc->current_state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid)\n\t\t\tDC_LOG_DEBUG(\"%s: CUR %s(%d) - enc_id(%d)\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tassignment.ep_id.ep_type == DISPLAY_ENDPOINT_PHY ? \"PHY\" : \"DPIA\",\n\t\t\t\t\tassignment.ep_id.ep_type == DISPLAY_ENDPOINT_PHY ?\n\t\t\t\t\t\t\tassignment.ep_id.link_id.enum_id :\n\t\t\t\t\t\t\tassignment.ep_id.link_id.enum_id - 1,\n\t\t\t\t\tassignment.eng_id);\n\t}\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment =\n\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid)\n\t\t\tDC_LOG_DEBUG(\"%s: NEW %s(%d) - enc_id(%d)\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\tassignment.ep_id.ep_type == DISPLAY_ENDPOINT_PHY ? \"PHY\" : \"DPIA\",\n\t\t\t\t\tassignment.ep_id.ep_type == DISPLAY_ENDPOINT_PHY ?\n\t\t\t\t\t\t\tassignment.ep_id.link_id.enum_id :\n\t\t\t\t\t\t\tassignment.ep_id.link_id.enum_id - 1,\n\t\t\t\t\tassignment.eng_id);\n\t}\n\n\t \n\tstate->res_ctx.link_enc_cfg_ctx.mode = LINK_ENC_CFG_STEADY;\n}\n\nvoid link_enc_cfg_link_enc_unassign(\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *stream)\n{\n\tenum engine_id eng_id = ENGINE_ID_UNKNOWN;\n\n\tif (stream->link_enc)\n\t\teng_id = stream->link_enc->preferred_engine;\n\n\tremove_link_enc_assignment(state, stream, eng_id);\n}\n\nbool link_enc_cfg_is_transmitter_mappable(\n\t\tstruct dc *dc,\n\t\tstruct link_encoder *link_enc)\n{\n\tbool is_mappable = false;\n\tenum engine_id eng_id = link_enc->preferred_engine;\n\tstruct dc_stream_state *stream = link_enc_cfg_get_stream_using_link_enc(dc, eng_id);\n\n\tif (stream)\n\t\tis_mappable = stream->link->is_dig_mapping_flexible;\n\n\treturn is_mappable;\n}\n\nstruct dc_stream_state *link_enc_cfg_get_stream_using_link_enc(\n\t\tstruct dc *dc,\n\t\tenum engine_id eng_id)\n{\n\tstruct dc_stream_state *stream = NULL;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = get_assignment(dc, i);\n\n\t\tif ((assignment.valid == true) && (assignment.eng_id == eng_id)) {\n\t\t\tstream = assignment.stream;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn stream;\n}\n\nstruct dc_link *link_enc_cfg_get_link_using_link_enc(\n\t\tstruct dc *dc,\n\t\tenum engine_id eng_id)\n{\n\tstruct dc_link *link = NULL;\n\tstruct dc_stream_state *stream = NULL;\n\n\tstream = link_enc_cfg_get_stream_using_link_enc(dc, eng_id);\n\n\tif (stream)\n\t\tlink = stream->link;\n\n\treturn link;\n}\n\nstruct link_encoder *link_enc_cfg_get_link_enc_used_by_link(\n\t\tstruct dc *dc,\n\t\tconst struct dc_link *link)\n{\n\tstruct link_encoder *link_enc = NULL;\n\tstruct display_endpoint_id ep_id;\n\tint i;\n\n\tep_id = (struct display_endpoint_id) {\n\t\t.link_id = link->link_id,\n\t\t.ep_type = link->ep_type};\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = get_assignment(dc, i);\n\n\t\tif (assignment.valid == true && are_ep_ids_equal(&assignment.ep_id, &ep_id)) {\n\t\t\tlink_enc = link->dc->res_pool->link_encoders[assignment.eng_id - ENGINE_ID_DIGA];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn link_enc;\n}\n\nstruct link_encoder *link_enc_cfg_get_next_avail_link_enc(struct dc *dc)\n{\n\tstruct link_encoder *link_enc = NULL;\n\tenum engine_id encs_assigned[MAX_DIG_LINK_ENCODERS];\n\tint i;\n\n\tfor (i = 0; i < MAX_DIG_LINK_ENCODERS; i++)\n\t\tencs_assigned[i] = ENGINE_ID_UNKNOWN;\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = get_assignment(dc, i);\n\n\t\tif (assignment.valid)\n\t\t\tencs_assigned[assignment.eng_id - ENGINE_ID_DIGA] = assignment.eng_id;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->res_cap->num_dig_link_enc; i++) {\n\t\tif (encs_assigned[i] == ENGINE_ID_UNKNOWN &&\n\t\t\t\tdc->res_pool->link_encoders[i] != NULL) {\n\t\t\tlink_enc = dc->res_pool->link_encoders[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn link_enc;\n}\n\nstruct link_encoder *link_enc_cfg_get_link_enc_used_by_stream(\n\t\tstruct dc *dc,\n\t\tconst struct dc_stream_state *stream)\n{\n\tstruct link_encoder *link_enc;\n\n\tlink_enc = link_enc_cfg_get_link_enc_used_by_link(dc, stream->link);\n\n\treturn link_enc;\n}\n\nstruct link_encoder *link_enc_cfg_get_link_enc(\n\t\tconst struct dc_link *link)\n{\n\tstruct link_encoder *link_enc = NULL;\n\n\t \n\tif (link->is_dig_mapping_flexible &&\n\t    link->dc->res_pool->funcs->link_encs_assign) {\n\t\tlink_enc = link_enc_cfg_get_link_enc_used_by_link(link->ctx->dc, link);\n\t\tif (link_enc == NULL)\n\t\t\tlink_enc = link_enc_cfg_get_next_avail_link_enc(\n\t\t\t\tlink->ctx->dc);\n\t} else\n\t\tlink_enc = link->link_enc;\n\n\treturn link_enc;\n}\n\nstruct link_encoder *link_enc_cfg_get_link_enc_used_by_stream_current(\n\t\tstruct dc *dc,\n\t\tconst struct dc_stream_state *stream)\n{\n\tstruct link_encoder *link_enc = NULL;\n\tstruct display_endpoint_id ep_id;\n\tint i;\n\n\tep_id = (struct display_endpoint_id) {\n\t\t.link_id = stream->link->link_id,\n\t\t.ep_type = stream->link->ep_type};\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment =\n\t\t\tdc->current_state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid == true && are_ep_ids_equal(&assignment.ep_id, &ep_id)) {\n\t\t\tlink_enc = stream->link->dc->res_pool->link_encoders[assignment.eng_id - ENGINE_ID_DIGA];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn link_enc;\n}\n\nbool link_enc_cfg_is_link_enc_avail(struct dc *dc, enum engine_id eng_id, struct dc_link *link)\n{\n\tbool is_avail = true;\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = get_assignment(dc, i);\n\t\tstruct display_endpoint_id ep_id = (struct display_endpoint_id) {\n\t\t\t\t.link_id = link->link_id,\n\t\t\t\t.ep_type = link->ep_type};\n\n\t\tif (assignment.valid && assignment.eng_id == eng_id && !are_ep_ids_equal(&ep_id, &assignment.ep_id)) {\n\t\t\tis_avail = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn is_avail;\n}\n\nbool link_enc_cfg_validate(struct dc *dc, struct dc_state *state)\n{\n\tbool is_valid = false;\n\tbool valid_entries = true;\n\tbool valid_stream_ptrs = true;\n\tbool valid_uniqueness = true;\n\tbool valid_avail = true;\n\tbool valid_streams = true;\n\tint i, j;\n\tuint8_t valid_count = 0;\n\tuint8_t dig_stream_count = 0;\n\tint eng_ids_per_ep_id[MAX_PIPES] = {0};\n\tint ep_ids_per_eng_id[MAX_PIPES] = {0};\n\tint valid_bitmap = 0;\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid)\n\t\t\tvalid_count++;\n\n\t\tif (is_dig_link_enc_stream(state->streams[i]))\n\t\t\tdig_stream_count++;\n\t}\n\tif (valid_count != dig_stream_count)\n\t\tvalid_entries = false;\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid) {\n\t\t\tif (assignment.stream != state->streams[i])\n\t\t\t\tvalid_stream_ptrs = false;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment_i = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment_i.valid) {\n\t\t\tstruct display_endpoint_id ep_id_i = assignment_i.ep_id;\n\n\t\t\teng_ids_per_ep_id[i]++;\n\t\t\tep_ids_per_eng_id[i]++;\n\t\t\tfor (j = 0; j < MAX_PIPES; j++) {\n\t\t\t\tstruct link_enc_assignment assignment_j =\n\t\t\t\t\tstate->res_ctx.link_enc_cfg_ctx.link_enc_assignments[j];\n\n\t\t\t\tif (j == i)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (assignment_j.valid) {\n\t\t\t\t\tstruct display_endpoint_id ep_id_j = assignment_j.ep_id;\n\n\t\t\t\t\tif (are_ep_ids_equal(&ep_id_i, &ep_id_j) &&\n\t\t\t\t\t\t\tassignment_i.eng_id != assignment_j.eng_id) {\n\t\t\t\t\t\tvalid_uniqueness = false;\n\t\t\t\t\t\teng_ids_per_ep_id[i]++;\n\t\t\t\t\t} else if (!are_ep_ids_equal(&ep_id_i, &ep_id_j) &&\n\t\t\t\t\t\t\tassignment_i.eng_id == assignment_j.eng_id) {\n\t\t\t\t\t\tvalid_uniqueness = false;\n\t\t\t\t\t\tep_ids_per_eng_id[i]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct link_enc_assignment assignment = state->res_ctx.link_enc_cfg_ctx.link_enc_assignments[i];\n\n\t\tif (assignment.valid) {\n\t\t\tfor (j = 0; j < dc->res_pool->res_cap->num_dig_link_enc; j++) {\n\t\t\t\tif (state->res_ctx.link_enc_cfg_ctx.link_enc_avail[j] == assignment.eng_id) {\n\t\t\t\t\tvalid_avail = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < state->stream_count; i++) {\n\t\tstruct dc_stream_state *stream = state->streams[i];\n\n\t\tif (is_dig_link_enc_stream(stream) && stream->link_enc == NULL) {\n\t\t\tvalid_streams = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tis_valid = valid_entries && valid_stream_ptrs && valid_uniqueness && valid_avail && valid_streams;\n\tASSERT(is_valid);\n\n\tif (is_valid == false) {\n\t\tvalid_bitmap =\n\t\t\t(valid_entries & 0x1) |\n\t\t\t((valid_stream_ptrs & 0x1) << 1) |\n\t\t\t((valid_uniqueness & 0x1) << 2) |\n\t\t\t((valid_avail & 0x1) << 3) |\n\t\t\t((valid_streams & 0x1) << 4);\n\t\tDC_LOG_ERROR(\"%s: Invalid link encoder assignments - 0x%x\\n\", __func__, valid_bitmap);\n\t}\n\n\treturn is_valid;\n}\n\nvoid link_enc_cfg_set_transient_mode(struct dc *dc, struct dc_state *current_state, struct dc_state *new_state)\n{\n\tint i = 0;\n\tint num_transient_assignments = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (current_state->res_ctx.link_enc_cfg_ctx.transient_assignments[i].valid)\n\t\t\tnum_transient_assignments++;\n\t}\n\n\t \n\tif (new_state->stream_count == num_transient_assignments) {\n\t\tcurrent_state->res_ctx.link_enc_cfg_ctx.mode = LINK_ENC_CFG_TRANSIENT;\n\t\tDC_LOG_DEBUG(\"%s: current_state(%p) mode(%d)\\n\", __func__, current_state, LINK_ENC_CFG_TRANSIENT);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}