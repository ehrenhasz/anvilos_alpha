{
  "module_name": "dce_mem_input.c",
  "hash_id": "ce05b310d67952bfa41384aad7a67b61f89da677d9b229ffa1c260e0f43fed5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c",
  "human_readable_source": " \n\n#include \"dce_mem_input.h\"\n#include \"reg_helper.h\"\n#include \"basics/conversion.h\"\n\n#define CTX \\\n\tdce_mi->base.ctx\n#define REG(reg)\\\n\tdce_mi->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdce_mi->shifts->field_name, dce_mi->masks->field_name\n\nstruct pte_setting {\n\tunsigned int bpp;\n\tunsigned int page_width;\n\tunsigned int page_height;\n\tunsigned char min_pte_before_flip_horiz_scan;\n\tunsigned char min_pte_before_flip_vert_scan;\n\tunsigned char pte_req_per_chunk;\n\tunsigned char param_6;\n\tunsigned char param_7;\n\tunsigned char param_8;\n};\n\nenum mi_bits_per_pixel {\n\tmi_bpp_8 = 0,\n\tmi_bpp_16,\n\tmi_bpp_32,\n\tmi_bpp_64,\n\tmi_bpp_count,\n};\n\nenum mi_tiling_format {\n\tmi_tiling_linear = 0,\n\tmi_tiling_1D,\n\tmi_tiling_2D,\n\tmi_tiling_count,\n};\n\nstatic const struct pte_setting pte_settings[mi_tiling_count][mi_bpp_count] = {\n\t[mi_tiling_linear] = {\n\t\t{  8, 4096, 1, 8, 0, 1, 0, 0, 0},\n\t\t{ 16, 2048, 1, 8, 0, 1, 0, 0, 0},\n\t\t{ 32, 1024, 1, 8, 0, 1, 0, 0, 0},\n\t\t{ 64,  512, 1, 8, 0, 1, 0, 0, 0},  \n\t},\n\t[mi_tiling_1D] = {\n\t\t{  8, 512, 8, 1, 0, 1, 0, 0, 0},   \n\t\t{ 16, 256, 8, 2, 0, 1, 0, 0, 0},\n\t\t{ 32, 128, 8, 4, 0, 1, 0, 0, 0},\n\t\t{ 64,  64, 8, 4, 0, 1, 0, 0, 0},  \n\t},\n\t[mi_tiling_2D] = {\n\t\t{  8, 64, 64,  8,  8, 1, 4, 0, 0},\n\t\t{ 16, 64, 32,  8, 16, 1, 8, 0, 0},\n\t\t{ 32, 32, 32, 16, 16, 1, 8, 0, 0},\n\t\t{ 64,  8, 32, 16, 16, 1, 8, 0, 0},  \n\t},\n};\n\nstatic enum mi_bits_per_pixel get_mi_bpp(\n\t\tenum surface_pixel_format format)\n{\n\tif (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)\n\t\treturn mi_bpp_64;\n\telse if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888)\n\t\treturn mi_bpp_32;\n\telse if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB1555)\n\t\treturn mi_bpp_16;\n\telse\n\t\treturn mi_bpp_8;\n}\n\nstatic enum mi_tiling_format get_mi_tiling(\n\t\tunion dc_tiling_info *tiling_info)\n{\n\tswitch (tiling_info->gfx8.array_mode) {\n\tcase DC_ARRAY_1D_TILED_THIN1:\n\tcase DC_ARRAY_1D_TILED_THICK:\n\tcase DC_ARRAY_PRT_TILED_THIN1:\n\t\treturn mi_tiling_1D;\n\tcase DC_ARRAY_2D_TILED_THIN1:\n\tcase DC_ARRAY_2D_TILED_THICK:\n\tcase DC_ARRAY_2D_TILED_X_THICK:\n\tcase DC_ARRAY_PRT_2D_TILED_THIN1:\n\tcase DC_ARRAY_PRT_2D_TILED_THICK:\n\t\treturn mi_tiling_2D;\n\tcase DC_ARRAY_LINEAR_GENERAL:\n\tcase DC_ARRAY_LINEAR_ALLIGNED:\n\t\treturn mi_tiling_linear;\n\tdefault:\n\t\treturn mi_tiling_2D;\n\t}\n}\n\nstatic bool is_vert_scan(enum dc_rotation_angle rotation)\n{\n\tswitch (rotation) {\n\tcase ROTATION_ANGLE_90:\n\tcase ROTATION_ANGLE_270:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void dce_mi_program_pte_vm(\n\t\tstruct mem_input *mi,\n\t\tenum surface_pixel_format format,\n\t\tunion dc_tiling_info *tiling_info,\n\t\tenum dc_rotation_angle rotation)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tenum mi_bits_per_pixel mi_bpp = get_mi_bpp(format);\n\tenum mi_tiling_format mi_tiling = get_mi_tiling(tiling_info);\n\tconst struct pte_setting *pte = &pte_settings[mi_tiling][mi_bpp];\n\n\tunsigned int page_width = log_2(pte->page_width);\n\tunsigned int page_height = log_2(pte->page_height);\n\tunsigned int min_pte_before_flip = is_vert_scan(rotation) ?\n\t\t\tpte->min_pte_before_flip_vert_scan :\n\t\t\tpte->min_pte_before_flip_horiz_scan;\n\n\tREG_UPDATE(GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT,\n\t\t\tGRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, 0x7f);\n\n\tREG_UPDATE_3(DVMM_PTE_CONTROL,\n\t\t\tDVMM_PAGE_WIDTH, page_width,\n\t\t\tDVMM_PAGE_HEIGHT, page_height,\n\t\t\tDVMM_MIN_PTE_BEFORE_FLIP, min_pte_before_flip);\n\n\tREG_UPDATE_2(DVMM_PTE_ARB_CONTROL,\n\t\t\tDVMM_PTE_REQ_PER_CHUNK, pte->pte_req_per_chunk,\n\t\t\tDVMM_MAX_PTE_REQ_OUTSTANDING, 0x7f);\n}\n\nstatic void program_urgency_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t urgency_low_wm,\n\tuint32_t urgency_high_wm)\n{\n\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\tURGENCY_WATERMARK_MASK, wm_select);\n\n\tREG_SET_2(DPG_PIPE_URGENCY_CONTROL, 0,\n\t\tURGENCY_LOW_WATERMARK, urgency_low_wm,\n\t\tURGENCY_HIGH_WATERMARK, urgency_high_wm);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_program_urgency_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t urgency_low_wm,\n\tuint32_t urgency_high_wm)\n{\n\tREG_UPDATE(DPG_PIPE_ARBITRATION_CONTROL3,\n\t\tURGENCY_WATERMARK_MASK, wm_select);\n\n\tREG_SET_2(DPG_PIPE_URGENCY_CONTROL, 0,\n\t\tURGENCY_LOW_WATERMARK, urgency_low_wm,\n\t\tURGENCY_HIGH_WATERMARK, urgency_high_wm);\n}\n#endif\n\nstatic void dce120_program_urgency_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t urgency_low_wm,\n\tuint32_t urgency_high_wm)\n{\n\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\tURGENCY_WATERMARK_MASK, wm_select);\n\n\tREG_SET_2(DPG_PIPE_URGENCY_CONTROL, 0,\n\t\tURGENCY_LOW_WATERMARK, urgency_low_wm,\n\t\tURGENCY_HIGH_WATERMARK, urgency_high_wm);\n\n\tREG_SET_2(DPG_PIPE_URGENT_LEVEL_CONTROL, 0,\n\t\tURGENT_LEVEL_LOW_WATERMARK, urgency_low_wm,\n\t\tURGENT_LEVEL_HIGH_WATERMARK, urgency_high_wm);\n\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_program_nbp_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t nbp_wm)\n{\n\tREG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,\n\t\tNB_PSTATE_CHANGE_WATERMARK_MASK, wm_select);\n\n\tREG_UPDATE_3(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,\n\t\tNB_PSTATE_CHANGE_ENABLE, 1,\n\t\tNB_PSTATE_CHANGE_URGENT_DURING_REQUEST, 1,\n\t\tNB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, 1);\n\n\tREG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,\n\t\tNB_PSTATE_CHANGE_WATERMARK, nbp_wm);\n}\n#endif\n\nstatic void program_nbp_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t nbp_wm)\n{\n\tif (REG(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL)) {\n\t\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\t\t\tNB_PSTATE_CHANGE_WATERMARK_MASK, wm_select);\n\n\t\tREG_UPDATE_3(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,\n\t\t\t\tNB_PSTATE_CHANGE_ENABLE, 1,\n\t\t\t\tNB_PSTATE_CHANGE_URGENT_DURING_REQUEST, 1,\n\t\t\t\tNB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, 1);\n\n\t\tREG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,\n\t\t\t\tNB_PSTATE_CHANGE_WATERMARK, nbp_wm);\n\t}\n\n\tif (REG(DPG_PIPE_LOW_POWER_CONTROL)) {\n\t\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\t\t\tPSTATE_CHANGE_WATERMARK_MASK, wm_select);\n\n\t\tREG_UPDATE_3(DPG_PIPE_LOW_POWER_CONTROL,\n\t\t\t\tPSTATE_CHANGE_ENABLE, 1,\n\t\t\t\tPSTATE_CHANGE_URGENT_DURING_REQUEST, 1,\n\t\t\t\tPSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, 1);\n\n\t\tREG_UPDATE(DPG_PIPE_LOW_POWER_CONTROL,\n\t\t\t\tPSTATE_CHANGE_WATERMARK, nbp_wm);\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_program_stutter_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t stutter_mark)\n{\n\tREG_UPDATE(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);\n\n\tREG_UPDATE(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);\n}\n#endif\n\nstatic void dce120_program_stutter_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t stutter_mark,\n\tuint32_t stutter_entry)\n{\n\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);\n\n\tif (REG(DPG_PIPE_STUTTER_CONTROL2))\n\t\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL2,\n\t\t\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark,\n\t\t\t\tSTUTTER_ENTER_SELF_REFRESH_WATERMARK, stutter_entry);\n\telse\n\t\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,\n\t\t\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark,\n\t\t\t\tSTUTTER_ENTER_SELF_REFRESH_WATERMARK, stutter_entry);\n}\n\nstatic void program_stutter_watermark(\n\tstruct dce_mem_input *dce_mi,\n\tuint32_t wm_select,\n\tuint32_t stutter_mark)\n{\n\tREG_UPDATE(DPG_WATERMARK_MASK_CONTROL,\n\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);\n\n\tif (REG(DPG_PIPE_STUTTER_CONTROL2))\n\t\tREG_UPDATE(DPG_PIPE_STUTTER_CONTROL2,\n\t\t\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);\n\telse\n\t\tREG_UPDATE(DPG_PIPE_STUTTER_CONTROL,\n\t\t\t\tSTUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);\n}\n\nstatic void dce_mi_program_display_marks(\n\tstruct mem_input *mi,\n\tstruct dce_watermarks nbp,\n\tstruct dce_watermarks stutter_exit,\n\tstruct dce_watermarks stutter_enter,\n\tstruct dce_watermarks urgent,\n\tuint32_t total_dest_line_time_ns)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tuint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;\n\n\tprogram_urgency_watermark(dce_mi, 2,  \n\t\t\turgent.a_mark, total_dest_line_time_ns);\n\tprogram_urgency_watermark(dce_mi, 1,  \n\t\t\turgent.d_mark, total_dest_line_time_ns);\n\n\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_ENABLE, stutter_en,\n\t\tSTUTTER_IGNORE_FBC, 1);\n\tprogram_nbp_watermark(dce_mi, 2, nbp.a_mark);  \n\tprogram_nbp_watermark(dce_mi, 1, nbp.d_mark);  \n\n\tprogram_stutter_watermark(dce_mi, 2, stutter_exit.a_mark);  \n\tprogram_stutter_watermark(dce_mi, 1, stutter_exit.d_mark);  \n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_mi_program_display_marks(\n\tstruct mem_input *mi,\n\tstruct dce_watermarks nbp,\n\tstruct dce_watermarks stutter_exit,\n\tstruct dce_watermarks stutter_enter,\n\tstruct dce_watermarks urgent,\n\tuint32_t total_dest_line_time_ns)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tuint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;\n\n\tdce60_program_urgency_watermark(dce_mi, 2,  \n\t\t\turgent.a_mark, total_dest_line_time_ns);\n\tdce60_program_urgency_watermark(dce_mi, 1,  \n\t\t\turgent.d_mark, total_dest_line_time_ns);\n\n\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_ENABLE, stutter_en,\n\t\tSTUTTER_IGNORE_FBC, 1);\n\tdce60_program_nbp_watermark(dce_mi, 2, nbp.a_mark);  \n\tdce60_program_nbp_watermark(dce_mi, 1, nbp.d_mark);  \n\n\tdce60_program_stutter_watermark(dce_mi, 2, stutter_exit.a_mark);  \n\tdce60_program_stutter_watermark(dce_mi, 1, stutter_exit.d_mark);  \n}\n#endif\n\nstatic void dce112_mi_program_display_marks(struct mem_input *mi,\n\tstruct dce_watermarks nbp,\n\tstruct dce_watermarks stutter_exit,\n\tstruct dce_watermarks stutter_entry,\n\tstruct dce_watermarks urgent,\n\tuint32_t total_dest_line_time_ns)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tuint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;\n\n\tprogram_urgency_watermark(dce_mi, 0,  \n\t\t\turgent.a_mark, total_dest_line_time_ns);\n\tprogram_urgency_watermark(dce_mi, 1,  \n\t\t\turgent.b_mark, total_dest_line_time_ns);\n\tprogram_urgency_watermark(dce_mi, 2,  \n\t\t\turgent.c_mark, total_dest_line_time_ns);\n\tprogram_urgency_watermark(dce_mi, 3,  \n\t\t\turgent.d_mark, total_dest_line_time_ns);\n\n\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_ENABLE, stutter_en,\n\t\tSTUTTER_IGNORE_FBC, 1);\n\tprogram_nbp_watermark(dce_mi, 0, nbp.a_mark);  \n\tprogram_nbp_watermark(dce_mi, 1, nbp.b_mark);  \n\tprogram_nbp_watermark(dce_mi, 2, nbp.c_mark);  \n\tprogram_nbp_watermark(dce_mi, 3, nbp.d_mark);  \n\n\tprogram_stutter_watermark(dce_mi, 0, stutter_exit.a_mark);  \n\tprogram_stutter_watermark(dce_mi, 1, stutter_exit.b_mark);  \n\tprogram_stutter_watermark(dce_mi, 2, stutter_exit.c_mark);  \n\tprogram_stutter_watermark(dce_mi, 3, stutter_exit.d_mark);  \n}\n\nstatic void dce120_mi_program_display_marks(struct mem_input *mi,\n\tstruct dce_watermarks nbp,\n\tstruct dce_watermarks stutter_exit,\n\tstruct dce_watermarks stutter_entry,\n\tstruct dce_watermarks urgent,\n\tuint32_t total_dest_line_time_ns)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tuint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;\n\n\tdce120_program_urgency_watermark(dce_mi, 0,  \n\t\t\turgent.a_mark, total_dest_line_time_ns);\n\tdce120_program_urgency_watermark(dce_mi, 1,  \n\t\t\turgent.b_mark, total_dest_line_time_ns);\n\tdce120_program_urgency_watermark(dce_mi, 2,  \n\t\t\turgent.c_mark, total_dest_line_time_ns);\n\tdce120_program_urgency_watermark(dce_mi, 3,  \n\t\t\turgent.d_mark, total_dest_line_time_ns);\n\n\tREG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,\n\t\tSTUTTER_ENABLE, stutter_en,\n\t\tSTUTTER_IGNORE_FBC, 1);\n\tprogram_nbp_watermark(dce_mi, 0, nbp.a_mark);  \n\tprogram_nbp_watermark(dce_mi, 1, nbp.b_mark);  \n\tprogram_nbp_watermark(dce_mi, 2, nbp.c_mark);  \n\tprogram_nbp_watermark(dce_mi, 3, nbp.d_mark);  \n\n\tdce120_program_stutter_watermark(dce_mi, 0, stutter_exit.a_mark, stutter_entry.a_mark);  \n\tdce120_program_stutter_watermark(dce_mi, 1, stutter_exit.b_mark, stutter_entry.b_mark);  \n\tdce120_program_stutter_watermark(dce_mi, 2, stutter_exit.c_mark, stutter_entry.c_mark);  \n\tdce120_program_stutter_watermark(dce_mi, 3, stutter_exit.d_mark, stutter_entry.d_mark);  \n}\n\nstatic void program_tiling(\n\tstruct dce_mem_input *dce_mi, const union dc_tiling_info *info)\n{\n\tif (dce_mi->masks->GRPH_SW_MODE) {  \n\t\tREG_UPDATE_6(GRPH_CONTROL,\n\t\t\t\tGRPH_SW_MODE, info->gfx9.swizzle,\n\t\t\t\tGRPH_NUM_BANKS, log_2(info->gfx9.num_banks),\n\t\t\t\tGRPH_NUM_SHADER_ENGINES, log_2(info->gfx9.num_shader_engines),\n\t\t\t\tGRPH_NUM_PIPES, log_2(info->gfx9.num_pipes),\n\t\t\t\tGRPH_COLOR_EXPANSION_MODE, 1,\n\t\t\t\tGRPH_SE_ENABLE, info->gfx9.shaderEnable);\n\t\t \n\t}\n\n\tif (dce_mi->masks->GRPH_MICRO_TILE_MODE) {  \n\t\tREG_UPDATE_9(GRPH_CONTROL,\n\t\t\t\tGRPH_NUM_BANKS, info->gfx8.num_banks,\n\t\t\t\tGRPH_BANK_WIDTH, info->gfx8.bank_width,\n\t\t\t\tGRPH_BANK_HEIGHT, info->gfx8.bank_height,\n\t\t\t\tGRPH_MACRO_TILE_ASPECT, info->gfx8.tile_aspect,\n\t\t\t\tGRPH_TILE_SPLIT, info->gfx8.tile_split,\n\t\t\t\tGRPH_MICRO_TILE_MODE, info->gfx8.tile_mode,\n\t\t\t\tGRPH_PIPE_CONFIG, info->gfx8.pipe_config,\n\t\t\t\tGRPH_ARRAY_MODE, info->gfx8.array_mode,\n\t\t\t\tGRPH_COLOR_EXPANSION_MODE, 1);\n\t\t \n\t\t \n\t}\n\n\tif (dce_mi->masks->GRPH_ARRAY_MODE) {  \n\t\tREG_UPDATE_8(GRPH_CONTROL,\n\t\t\t\tGRPH_NUM_BANKS, info->gfx8.num_banks,\n\t\t\t\tGRPH_BANK_WIDTH, info->gfx8.bank_width,\n\t\t\t\tGRPH_BANK_HEIGHT, info->gfx8.bank_height,\n\t\t\t\tGRPH_MACRO_TILE_ASPECT, info->gfx8.tile_aspect,\n\t\t\t\tGRPH_TILE_SPLIT, info->gfx8.tile_split,\n\t\t\t\t \n\t\t\t\tGRPH_PIPE_CONFIG, info->gfx8.pipe_config,\n\t\t\t\tGRPH_ARRAY_MODE, info->gfx8.array_mode,\n\t\t\t\tGRPH_COLOR_EXPANSION_MODE, 1);\n\t\t \n\t\t \n\t}\n}\n\n\nstatic void program_size_and_rotation(\n\tstruct dce_mem_input *dce_mi,\n\tenum dc_rotation_angle rotation,\n\tconst struct plane_size *plane_size)\n{\n\tconst struct rect *in_rect = &plane_size->surface_size;\n\tstruct rect hw_rect = plane_size->surface_size;\n\tconst uint32_t rotation_angles[ROTATION_ANGLE_COUNT] = {\n\t\t\t[ROTATION_ANGLE_0] = 0,\n\t\t\t[ROTATION_ANGLE_90] = 1,\n\t\t\t[ROTATION_ANGLE_180] = 2,\n\t\t\t[ROTATION_ANGLE_270] = 3,\n\t};\n\n\tif (rotation == ROTATION_ANGLE_90 || rotation == ROTATION_ANGLE_270) {\n\t\thw_rect.x = in_rect->y;\n\t\thw_rect.y = in_rect->x;\n\n\t\thw_rect.height = in_rect->width;\n\t\thw_rect.width = in_rect->height;\n\t}\n\n\tREG_SET(GRPH_X_START, 0,\n\t\t\tGRPH_X_START, hw_rect.x);\n\n\tREG_SET(GRPH_Y_START, 0,\n\t\t\tGRPH_Y_START, hw_rect.y);\n\n\tREG_SET(GRPH_X_END, 0,\n\t\t\tGRPH_X_END, hw_rect.width);\n\n\tREG_SET(GRPH_Y_END, 0,\n\t\t\tGRPH_Y_END, hw_rect.height);\n\n\tREG_SET(GRPH_PITCH, 0,\n\t\t\tGRPH_PITCH, plane_size->surface_pitch);\n\n\tREG_SET(HW_ROTATION, 0,\n\t\t\tGRPH_ROTATION_ANGLE, rotation_angles[rotation]);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_program_size(\n\tstruct dce_mem_input *dce_mi,\n\tenum dc_rotation_angle rotation,  \n\tconst struct plane_size *plane_size)\n{\n\tstruct rect hw_rect = plane_size->surface_size;\n\t \n\n\t \n\n\tREG_SET(GRPH_X_START, 0,\n\t\t\tGRPH_X_START, hw_rect.x);\n\n\tREG_SET(GRPH_Y_START, 0,\n\t\t\tGRPH_Y_START, hw_rect.y);\n\n\tREG_SET(GRPH_X_END, 0,\n\t\t\tGRPH_X_END, hw_rect.width);\n\n\tREG_SET(GRPH_Y_END, 0,\n\t\t\tGRPH_Y_END, hw_rect.height);\n\n\tREG_SET(GRPH_PITCH, 0,\n\t\t\tGRPH_PITCH, plane_size->surface_pitch);\n\n\t \n}\n#endif\n\nstatic void program_grph_pixel_format(\n\tstruct dce_mem_input *dce_mi,\n\tenum surface_pixel_format format)\n{\n\tuint32_t red_xbar = 0, blue_xbar = 0;  \n\tuint32_t grph_depth = 0, grph_format = 0;\n\tuint32_t sign = 0, floating = 0;\n\n\tif (format == SURFACE_PIXEL_FORMAT_GRPH_ABGR8888 ||\n\t\t\t \n\t\tformat == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010 ||\n\t\tformat == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS ||\n\t\tformat == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616 ||\n\t\tformat == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F) {\n\t\t \n\t\tred_xbar = 2;\n\t\tblue_xbar = 2;\n\t}\n\n\tREG_SET_2(GRPH_SWAP_CNTL, 0,\n\t\t\tGRPH_RED_CROSSBAR, red_xbar,\n\t\t\tGRPH_BLUE_CROSSBAR, blue_xbar);\n\n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:\n\t\tgrph_depth = 0;\n\t\tgrph_format = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\tgrph_depth = 1;\n\t\tgrph_format = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\tgrph_depth = 1;\n\t\tgrph_format = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\tgrph_depth = 2;\n\t\tgrph_format = 0;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:\n\t\tgrph_depth = 2;\n\t\tgrph_format = 1;\n\t\tbreak;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\tsign = 1;\n\t\tfloating = 1;\n\t\tfallthrough;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:  \n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\t\tgrph_depth = 3;\n\t\tgrph_format = 0;\n\t\tbreak;\n\tdefault:\n\t\tDC_ERR(\"unsupported grph pixel format\");\n\t\tbreak;\n\t}\n\n\tREG_UPDATE_2(GRPH_CONTROL,\n\t\t\tGRPH_DEPTH, grph_depth,\n\t\t\tGRPH_FORMAT, grph_format);\n\n\tREG_UPDATE_4(PRESCALE_GRPH_CONTROL,\n\t\t\tGRPH_PRESCALE_SELECT, floating,\n\t\t\tGRPH_PRESCALE_R_SIGN, sign,\n\t\t\tGRPH_PRESCALE_G_SIGN, sign,\n\t\t\tGRPH_PRESCALE_B_SIGN, sign);\n}\n\nstatic void dce_mi_program_surface_config(\n\tstruct mem_input *mi,\n\tenum surface_pixel_format format,\n\tunion dc_tiling_info *tiling_info,\n\tstruct plane_size *plane_size,\n\tenum dc_rotation_angle rotation,\n\tstruct dc_plane_dcc_param *dcc,\n\tbool horizontal_mirror)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tREG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);\n\n\tprogram_tiling(dce_mi, tiling_info);\n\tprogram_size_and_rotation(dce_mi, rotation, plane_size);\n\n\tif (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&\n\t\tformat < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\tprogram_grph_pixel_format(dce_mi, format);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_mi_program_surface_config(\n\tstruct mem_input *mi,\n\tenum surface_pixel_format format,\n\tunion dc_tiling_info *tiling_info,\n\tstruct plane_size *plane_size,\n\tenum dc_rotation_angle rotation,  \n\tstruct dc_plane_dcc_param *dcc,\n\tbool horizontal_mirror)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tREG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);\n\n\tprogram_tiling(dce_mi, tiling_info);\n\tdce60_program_size(dce_mi, rotation, plane_size);\n\n\tif (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&\n\t\tformat < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\tprogram_grph_pixel_format(dce_mi, format);\n}\n#endif\n\nstatic uint32_t get_dmif_switch_time_us(\n\tuint32_t h_total,\n\tuint32_t v_total,\n\tuint32_t pix_clk_khz)\n{\n\tuint32_t frame_time;\n\tuint32_t pixels_per_second;\n\tuint32_t pixels_per_frame;\n\tuint32_t refresh_rate;\n\tconst uint32_t us_in_sec = 1000000;\n\tconst uint32_t min_single_frame_time_us = 30000;\n\t \n\tconst uint32_t single_frame_time_multiplier = 2;\n\n\tif (!h_total || v_total || !pix_clk_khz)\n\t\treturn single_frame_time_multiplier * min_single_frame_time_us;\n\n\t \n\tpixels_per_second = pix_clk_khz * 1000;\n\tpixels_per_frame = h_total * v_total;\n\n\tif (!pixels_per_second || !pixels_per_frame) {\n\t\t \n\t\tASSERT(pixels_per_frame);\n\t\tASSERT(pixels_per_second);\n\t\treturn single_frame_time_multiplier * min_single_frame_time_us;\n\t}\n\n\trefresh_rate = pixels_per_second / pixels_per_frame;\n\n\tif (!refresh_rate) {\n\t\t \n\t\tASSERT(refresh_rate);\n\t\treturn single_frame_time_multiplier * min_single_frame_time_us;\n\t}\n\n\tframe_time = us_in_sec / refresh_rate;\n\n\tif (frame_time < min_single_frame_time_us)\n\t\tframe_time = min_single_frame_time_us;\n\n\tframe_time *= single_frame_time_multiplier;\n\n\treturn frame_time;\n}\n\nstatic void dce_mi_allocate_dmif(\n\tstruct mem_input *mi,\n\tuint32_t h_total,\n\tuint32_t v_total,\n\tuint32_t pix_clk_khz,\n\tuint32_t total_stream_num)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tconst uint32_t retry_delay = 10;\n\tuint32_t retry_count = get_dmif_switch_time_us(\n\t\t\th_total,\n\t\t\tv_total,\n\t\t\tpix_clk_khz) / retry_delay;\n\n\tuint32_t pix_dur;\n\tuint32_t buffers_allocated;\n\tuint32_t dmif_buffer_control;\n\n\tdmif_buffer_control = REG_GET(DMIF_BUFFER_CONTROL,\n\t\t\tDMIF_BUFFERS_ALLOCATED, &buffers_allocated);\n\n\tif (buffers_allocated == 2)\n\t\treturn;\n\n\tREG_SET(DMIF_BUFFER_CONTROL, dmif_buffer_control,\n\t\t\tDMIF_BUFFERS_ALLOCATED, 2);\n\n\tREG_WAIT(DMIF_BUFFER_CONTROL,\n\t\t\tDMIF_BUFFERS_ALLOCATION_COMPLETED, 1,\n\t\t\tretry_delay, retry_count);\n\n\tif (pix_clk_khz != 0) {\n\t\tpix_dur = 1000000000ULL / pix_clk_khz;\n\n\t\tREG_UPDATE(DPG_PIPE_ARBITRATION_CONTROL1,\n\t\t\tPIXEL_DURATION, pix_dur);\n\t}\n\n\tif (dce_mi->wa.single_head_rdreq_dmif_limit) {\n\t\tuint32_t enable =  (total_stream_num > 1) ? 0 :\n\t\t\t\tdce_mi->wa.single_head_rdreq_dmif_limit;\n\n\t\tREG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,\n\t\t\t\tENABLE, enable);\n\t}\n}\n\nstatic void dce_mi_free_dmif(\n\t\tstruct mem_input *mi,\n\t\tuint32_t total_stream_num)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);\n\tuint32_t buffers_allocated;\n\tuint32_t dmif_buffer_control;\n\n\tdmif_buffer_control = REG_GET(DMIF_BUFFER_CONTROL,\n\t\t\tDMIF_BUFFERS_ALLOCATED, &buffers_allocated);\n\n\tif (buffers_allocated == 0)\n\t\treturn;\n\n\tREG_SET(DMIF_BUFFER_CONTROL, dmif_buffer_control,\n\t\t\tDMIF_BUFFERS_ALLOCATED, 0);\n\n\tREG_WAIT(DMIF_BUFFER_CONTROL,\n\t\t\tDMIF_BUFFERS_ALLOCATION_COMPLETED, 1,\n\t\t\t10, 3500);\n\n\tif (dce_mi->wa.single_head_rdreq_dmif_limit) {\n\t\tuint32_t enable =  (total_stream_num > 1) ? 0 :\n\t\t\t\tdce_mi->wa.single_head_rdreq_dmif_limit;\n\n\t\tREG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,\n\t\t\t\tENABLE, enable);\n\t}\n}\n\n\nstatic void program_sec_addr(\n\tstruct dce_mem_input *dce_mi,\n\tPHYSICAL_ADDRESS_LOC address)\n{\n\t \n\tREG_SET(GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, 0,\n\t\tGRPH_SECONDARY_SURFACE_ADDRESS_HIGH,\n\t\taddress.high_part);\n\n\tREG_SET_2(GRPH_SECONDARY_SURFACE_ADDRESS, 0,\n\t\tGRPH_SECONDARY_SURFACE_ADDRESS, address.low_part >> 8,\n\t\tGRPH_SECONDARY_DFQ_ENABLE, 0);\n}\n\nstatic void program_pri_addr(\n\tstruct dce_mem_input *dce_mi,\n\tPHYSICAL_ADDRESS_LOC address)\n{\n\t \n\tREG_SET(GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, 0,\n\t\tGRPH_PRIMARY_SURFACE_ADDRESS_HIGH,\n\t\taddress.high_part);\n\n\tREG_SET(GRPH_PRIMARY_SURFACE_ADDRESS, 0,\n\t\tGRPH_PRIMARY_SURFACE_ADDRESS,\n\t\taddress.low_part >> 8);\n}\n\n\nstatic bool dce_mi_is_flip_pending(struct mem_input *mem_input)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);\n\tuint32_t update_pending;\n\n\tREG_GET(GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING, &update_pending);\n\tif (update_pending)\n\t\treturn true;\n\n\tmem_input->current_address = mem_input->request_address;\n\treturn false;\n}\n\nstatic bool dce_mi_program_surface_flip_and_addr(\n\tstruct mem_input *mem_input,\n\tconst struct dc_plane_address *address,\n\tbool flip_immediate)\n{\n\tstruct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);\n\n\tREG_UPDATE(GRPH_UPDATE, GRPH_UPDATE_LOCK, 1);\n\n\tREG_UPDATE(\n\t\tGRPH_FLIP_CONTROL,\n\t\tGRPH_SURFACE_UPDATE_H_RETRACE_EN, flip_immediate ? 1 : 0);\n\n\tswitch (address->type) {\n\tcase PLN_ADDR_TYPE_GRAPHICS:\n\t\tif (address->grph.addr.quad_part == 0)\n\t\t\tbreak;\n\t\tprogram_pri_addr(dce_mi, address->grph.addr);\n\t\tbreak;\n\tcase PLN_ADDR_TYPE_GRPH_STEREO:\n\t\tif (address->grph_stereo.left_addr.quad_part == 0 ||\n\t\t    address->grph_stereo.right_addr.quad_part == 0)\n\t\t\tbreak;\n\t\tprogram_pri_addr(dce_mi, address->grph_stereo.left_addr);\n\t\tprogram_sec_addr(dce_mi, address->grph_stereo.right_addr);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tmem_input->request_address = *address;\n\n\tif (flip_immediate)\n\t\tmem_input->current_address = *address;\n\n\tREG_UPDATE(GRPH_UPDATE, GRPH_UPDATE_LOCK, 0);\n\n\treturn true;\n}\n\nstatic const struct mem_input_funcs dce_mi_funcs = {\n\t.mem_input_program_display_marks = dce_mi_program_display_marks,\n\t.allocate_mem_input = dce_mi_allocate_dmif,\n\t.free_mem_input = dce_mi_free_dmif,\n\t.mem_input_program_surface_flip_and_addr =\n\t\t\tdce_mi_program_surface_flip_and_addr,\n\t.mem_input_program_pte_vm = dce_mi_program_pte_vm,\n\t.mem_input_program_surface_config =\n\t\t\tdce_mi_program_surface_config,\n\t.mem_input_is_flip_pending = dce_mi_is_flip_pending\n};\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic const struct mem_input_funcs dce60_mi_funcs = {\n\t.mem_input_program_display_marks = dce60_mi_program_display_marks,\n\t.allocate_mem_input = dce_mi_allocate_dmif,\n\t.free_mem_input = dce_mi_free_dmif,\n\t.mem_input_program_surface_flip_and_addr =\n\t\t\tdce_mi_program_surface_flip_and_addr,\n\t.mem_input_program_pte_vm = dce_mi_program_pte_vm,\n\t.mem_input_program_surface_config =\n\t\t\tdce60_mi_program_surface_config,\n\t.mem_input_is_flip_pending = dce_mi_is_flip_pending\n};\n#endif\n\nstatic const struct mem_input_funcs dce112_mi_funcs = {\n\t.mem_input_program_display_marks = dce112_mi_program_display_marks,\n\t.allocate_mem_input = dce_mi_allocate_dmif,\n\t.free_mem_input = dce_mi_free_dmif,\n\t.mem_input_program_surface_flip_and_addr =\n\t\t\tdce_mi_program_surface_flip_and_addr,\n\t.mem_input_program_pte_vm = dce_mi_program_pte_vm,\n\t.mem_input_program_surface_config =\n\t\t\tdce_mi_program_surface_config,\n\t.mem_input_is_flip_pending = dce_mi_is_flip_pending\n};\n\nstatic const struct mem_input_funcs dce120_mi_funcs = {\n\t.mem_input_program_display_marks = dce120_mi_program_display_marks,\n\t.allocate_mem_input = dce_mi_allocate_dmif,\n\t.free_mem_input = dce_mi_free_dmif,\n\t.mem_input_program_surface_flip_and_addr =\n\t\t\tdce_mi_program_surface_flip_and_addr,\n\t.mem_input_program_pte_vm = dce_mi_program_pte_vm,\n\t.mem_input_program_surface_config =\n\t\t\tdce_mi_program_surface_config,\n\t.mem_input_is_flip_pending = dce_mi_is_flip_pending\n};\n\nvoid dce_mem_input_construct(\n\tstruct dce_mem_input *dce_mi,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_mem_input_registers *regs,\n\tconst struct dce_mem_input_shift *mi_shift,\n\tconst struct dce_mem_input_mask *mi_mask)\n{\n\tdce_mi->base.ctx = ctx;\n\n\tdce_mi->base.inst = inst;\n\tdce_mi->base.funcs = &dce_mi_funcs;\n\n\tdce_mi->regs = regs;\n\tdce_mi->shifts = mi_shift;\n\tdce_mi->masks = mi_mask;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nvoid dce60_mem_input_construct(\n\tstruct dce_mem_input *dce_mi,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_mem_input_registers *regs,\n\tconst struct dce_mem_input_shift *mi_shift,\n\tconst struct dce_mem_input_mask *mi_mask)\n{\n\tdce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);\n\tdce_mi->base.funcs = &dce60_mi_funcs;\n}\n#endif\n\nvoid dce112_mem_input_construct(\n\tstruct dce_mem_input *dce_mi,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_mem_input_registers *regs,\n\tconst struct dce_mem_input_shift *mi_shift,\n\tconst struct dce_mem_input_mask *mi_mask)\n{\n\tdce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);\n\tdce_mi->base.funcs = &dce112_mi_funcs;\n}\n\nvoid dce120_mem_input_construct(\n\tstruct dce_mem_input *dce_mi,\n\tstruct dc_context *ctx,\n\tint inst,\n\tconst struct dce_mem_input_registers *regs,\n\tconst struct dce_mem_input_shift *mi_shift,\n\tconst struct dce_mem_input_mask *mi_mask)\n{\n\tdce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);\n\tdce_mi->base.funcs = &dce120_mi_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}