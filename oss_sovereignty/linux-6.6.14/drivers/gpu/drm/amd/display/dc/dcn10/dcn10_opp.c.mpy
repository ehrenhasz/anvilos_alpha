{
  "module_name": "dcn10_opp.c",
  "hash_id": "ea3884b11734e979260a337837fe82ac1393a40f6449196e3dc0623da5f82ed3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dcn10_opp.h\"\n#include \"reg_helper.h\"\n\n#define REG(reg) \\\n\t(oppn10->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\toppn10->opp_shift->field_name, oppn10->opp_mask->field_name\n\n#define CTX \\\n\toppn10->base.ctx\n\n \nstatic void opp1_set_truncation(\n\t\tstruct dcn10_opp *oppn10,\n\t\tconst struct bit_depth_reduction_params *params)\n{\n\tREG_UPDATE_3(FMT_BIT_DEPTH_CONTROL,\n\t\tFMT_TRUNCATE_EN, params->flags.TRUNCATE_ENABLED,\n\t\tFMT_TRUNCATE_DEPTH, params->flags.TRUNCATE_DEPTH,\n\t\tFMT_TRUNCATE_MODE, params->flags.TRUNCATE_MODE);\n}\n\nstatic void opp1_set_spatial_dither(\n\tstruct dcn10_opp *oppn10,\n\tconst struct bit_depth_reduction_params *params)\n{\n\t \n\tREG_UPDATE_7(FMT_BIT_DEPTH_CONTROL,\n\t\t\tFMT_SPATIAL_DITHER_EN, 0,\n\t\t\tFMT_SPATIAL_DITHER_MODE, 0,\n\t\t\tFMT_SPATIAL_DITHER_DEPTH, 0,\n\t\t\tFMT_TEMPORAL_DITHER_EN, 0,\n\t\t\tFMT_HIGHPASS_RANDOM_ENABLE, 0,\n\t\t\tFMT_FRAME_RANDOM_ENABLE, 0,\n\t\t\tFMT_RGB_RANDOM_ENABLE, 0);\n\n\n\t \n\tif (params->flags.FRAME_RANDOM == 1) {\n\t\tif (params->flags.SPATIAL_DITHER_DEPTH == 0 || params->flags.SPATIAL_DITHER_DEPTH == 1) {\n\t\t\tREG_UPDATE_2(FMT_CONTROL,\n\t\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 15,\n\t\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 2);\n\t\t} else if (params->flags.SPATIAL_DITHER_DEPTH == 2) {\n\t\t\tREG_UPDATE_2(FMT_CONTROL,\n\t\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 3,\n\t\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tREG_UPDATE_2(FMT_CONTROL,\n\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 0,\n\t\t\t\tFMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 0);\n\t}\n\n\t \n\n\tREG_SET(FMT_DITHER_RAND_R_SEED, 0,\n\t\t\tFMT_RAND_R_SEED, params->r_seed_value);\n\n\tREG_SET(FMT_DITHER_RAND_G_SEED, 0,\n\t\t\tFMT_RAND_G_SEED, params->g_seed_value);\n\n\tREG_SET(FMT_DITHER_RAND_B_SEED, 0,\n\t\t\tFMT_RAND_B_SEED, params->b_seed_value);\n\n\t \n\t \n\t \n\n\tREG_UPDATE_6(FMT_BIT_DEPTH_CONTROL,\n\t\t\t \n\t\t\tFMT_SPATIAL_DITHER_EN, params->flags.SPATIAL_DITHER_ENABLED,\n\t\t\t \n\t\t\tFMT_SPATIAL_DITHER_MODE, params->flags.SPATIAL_DITHER_MODE,\n\t\t\t \n\t\t\tFMT_SPATIAL_DITHER_DEPTH, params->flags.SPATIAL_DITHER_DEPTH,\n\t\t\t \n\t\t\tFMT_HIGHPASS_RANDOM_ENABLE, params->flags.HIGHPASS_RANDOM,\n\t\t\t \n\t\t\tFMT_FRAME_RANDOM_ENABLE, params->flags.FRAME_RANDOM,\n\t\t\t \n\t\t\tFMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);\n}\n\nvoid opp1_program_bit_depth_reduction(\n\tstruct output_pixel_processor *opp,\n\tconst struct bit_depth_reduction_params *params)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\n\topp1_set_truncation(oppn10, params);\n\topp1_set_spatial_dither(oppn10, params);\n\t \n}\n\n \nstatic void opp1_set_pixel_encoding(\n\tstruct dcn10_opp *oppn10,\n\tconst struct clamping_and_pixel_encoding_params *params)\n{\n\tswitch (params->pixel_encoding)\t{\n\n\tcase PIXEL_ENCODING_RGB:\n\tcase PIXEL_ENCODING_YCBCR444:\n\t\tREG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 0);\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR422:\n\t\tREG_UPDATE_3(FMT_CONTROL,\n\t\t\t\tFMT_PIXEL_ENCODING, 1,\n\t\t\t\tFMT_SUBSAMPLING_MODE, 2,\n\t\t\t\tFMT_CBCR_BIT_REDUCTION_BYPASS, 0);\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR420:\n\t\tREG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void opp1_set_clamping(\n\tstruct dcn10_opp *oppn10,\n\tconst struct clamping_and_pixel_encoding_params *params)\n{\n\tREG_UPDATE_2(FMT_CLAMP_CNTL,\n\t\t\tFMT_CLAMP_DATA_EN, 0,\n\t\t\tFMT_CLAMP_COLOR_FORMAT, 0);\n\n\tswitch (params->clamping_level) {\n\tcase CLAMPING_FULL_RANGE:\n\t\tREG_UPDATE_2(FMT_CLAMP_CNTL,\n\t\t\t\tFMT_CLAMP_DATA_EN, 1,\n\t\t\t\tFMT_CLAMP_COLOR_FORMAT, 0);\n\t\tbreak;\n\tcase CLAMPING_LIMITED_RANGE_8BPC:\n\t\tREG_UPDATE_2(FMT_CLAMP_CNTL,\n\t\t\t\tFMT_CLAMP_DATA_EN, 1,\n\t\t\t\tFMT_CLAMP_COLOR_FORMAT, 1);\n\t\tbreak;\n\tcase CLAMPING_LIMITED_RANGE_10BPC:\n\t\tREG_UPDATE_2(FMT_CLAMP_CNTL,\n\t\t\t\tFMT_CLAMP_DATA_EN, 1,\n\t\t\t\tFMT_CLAMP_COLOR_FORMAT, 2);\n\n\t\tbreak;\n\tcase CLAMPING_LIMITED_RANGE_12BPC:\n\t\tREG_UPDATE_2(FMT_CLAMP_CNTL,\n\t\t\t\tFMT_CLAMP_DATA_EN, 1,\n\t\t\t\tFMT_CLAMP_COLOR_FORMAT, 3);\n\t\tbreak;\n\tcase CLAMPING_LIMITED_RANGE_PROGRAMMABLE:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nvoid opp1_set_dyn_expansion(\n\tstruct output_pixel_processor *opp,\n\tenum dc_color_space color_sp,\n\tenum dc_color_depth color_dpth,\n\tenum signal_type signal)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\n\tREG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,\n\t\t\tFMT_DYNAMIC_EXP_EN, 0,\n\t\t\tFMT_DYNAMIC_EXP_MODE, 0);\n\n\tif (opp->dyn_expansion == DYN_EXPANSION_DISABLE)\n\t\treturn;\n\n\t \n\t \n\tif (signal == SIGNAL_TYPE_HDMI_TYPE_A ||\n\t\tsignal == SIGNAL_TYPE_DISPLAY_PORT ||\n\t\tsignal == SIGNAL_TYPE_DISPLAY_PORT_MST ||\n\t\tsignal == SIGNAL_TYPE_VIRTUAL) {\n\t\tswitch (color_dpth) {\n\t\tcase COLOR_DEPTH_888:\n\t\t\tREG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,\n\t\t\t\tFMT_DYNAMIC_EXP_EN, 1,\n\t\t\t\tFMT_DYNAMIC_EXP_MODE, 1);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tREG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,\n\t\t\t\tFMT_DYNAMIC_EXP_EN, 1,\n\t\t\t\tFMT_DYNAMIC_EXP_MODE, 0);\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tREG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,\n\t\t\t\tFMT_DYNAMIC_EXP_EN, 1, \n\t\t\t\tFMT_DYNAMIC_EXP_MODE, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void opp1_program_clamping_and_pixel_encoding(\n\tstruct output_pixel_processor *opp,\n\tconst struct clamping_and_pixel_encoding_params *params)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\n\topp1_set_clamping(oppn10, params);\n\topp1_set_pixel_encoding(oppn10, params);\n}\n\nvoid opp1_program_fmt(\n\tstruct output_pixel_processor *opp,\n\tstruct bit_depth_reduction_params *fmt_bit_depth,\n\tstruct clamping_and_pixel_encoding_params *clamping)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\n\tif (clamping->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tREG_UPDATE(FMT_MAP420_MEMORY_CONTROL, FMT_MAP420MEM_PWR_FORCE, 0);\n\n\t \n\topp1_program_bit_depth_reduction(\n\t\topp,\n\t\tfmt_bit_depth);\n\n\topp1_program_clamping_and_pixel_encoding(\n\t\topp,\n\t\tclamping);\n\n\treturn;\n}\n\nvoid opp1_program_stereo(\n\tstruct output_pixel_processor *opp,\n\tbool enable,\n\tconst struct dc_crtc_timing *timing)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\n\tuint32_t active_width = timing->h_addressable - timing->h_border_right - timing->h_border_right;\n\tuint32_t space1_size = timing->v_total - timing->v_addressable;\n\t \n\tuint32_t space2_size = timing->v_total - timing->v_addressable;\n\n\tif (!enable) {\n\t\tactive_width = 0;\n\t\tspace1_size = 0;\n\t\tspace2_size = 0;\n\t}\n\n\t \n\tREG_UPDATE(FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, 0);\n\n\tREG_UPDATE(OPPBUF_CONTROL, OPPBUF_ACTIVE_WIDTH, active_width);\n\n\t \n\tif (timing->timing_3d_format == TIMING_3D_FORMAT_FRAME_ALTERNATE)\n\t\tREG_UPDATE(OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE2_SIZE, space2_size);\n\telse\n\t\tREG_UPDATE(OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE1_SIZE, space1_size);\n\n\t \n\t \n}\n\nvoid opp1_pipe_clock_control(struct output_pixel_processor *opp, bool enable)\n{\n\tstruct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);\n\tuint32_t regval = enable ? 1 : 0;\n\n\tREG_UPDATE(OPP_PIPE_CONTROL, OPP_PIPE_CLOCK_EN, regval);\n}\n\n \n \n \n\nvoid opp1_destroy(struct output_pixel_processor **opp)\n{\n\tkfree(TO_DCN10_OPP(*opp));\n\t*opp = NULL;\n}\n\nstatic const struct opp_funcs dcn10_opp_funcs = {\n\t\t.opp_set_dyn_expansion = opp1_set_dyn_expansion,\n\t\t.opp_program_fmt = opp1_program_fmt,\n\t\t.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,\n\t\t.opp_program_stereo = opp1_program_stereo,\n\t\t.opp_pipe_clock_control = opp1_pipe_clock_control,\n\t\t.opp_set_disp_pattern_generator = NULL,\n\t\t.opp_program_dpg_dimensions = NULL,\n\t\t.dpg_is_blanked = NULL,\n\t\t.opp_destroy = opp1_destroy\n};\n\nvoid dcn10_opp_construct(struct dcn10_opp *oppn10,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dcn10_opp_registers *regs,\n\tconst struct dcn10_opp_shift *opp_shift,\n\tconst struct dcn10_opp_mask *opp_mask)\n{\n\n\toppn10->base.ctx = ctx;\n\toppn10->base.inst = inst;\n\toppn10->base.funcs = &dcn10_opp_funcs;\n\n\toppn10->regs = regs;\n\toppn10->opp_shift = opp_shift;\n\toppn10->opp_mask = opp_mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}