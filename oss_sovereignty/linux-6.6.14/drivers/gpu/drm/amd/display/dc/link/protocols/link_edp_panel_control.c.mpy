{
  "module_name": "link_edp_panel_control.c",
  "hash_id": "ff374d7ecff4eab665b71f61aa711e0987234f1b1eb20997ff6251a99cb56612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/protocols/link_edp_panel_control.c",
  "human_readable_source": " \n\n \n\n#include \"link_edp_panel_control.h\"\n#include \"link_dpcd.h\"\n#include \"link_dp_capability.h\"\n#include \"dm_helpers.h\"\n#include \"dal_asic_id.h\"\n#include \"link_dp_phy.h\"\n#include \"dce/dmub_psr.h\"\n#include \"dc/dc_dmub_srv.h\"\n#include \"dce/dmub_replay.h\"\n#include \"abm.h\"\n#define DC_LOGGER_INIT(logger)\n\n#define DP_SINK_PR_ENABLE_AND_CONFIGURATION\t\t0x37B\n\n \nstatic const uint8_t DP_VGA_LVDS_CONVERTER_ID_2[] = \"sivarT\";\n \nstatic const uint8_t DP_VGA_LVDS_CONVERTER_ID_3[] = \"dnomlA\";\n\nvoid dp_set_panel_mode(struct dc_link *link, enum dp_panel_mode panel_mode)\n{\n\tunion dpcd_edp_config edp_config_set;\n\tbool panel_mode_edp = false;\n\tenum dc_status result;\n\n\tmemset(&edp_config_set, '\\0', sizeof(union dpcd_edp_config));\n\n\tswitch (panel_mode) {\n\tcase DP_PANEL_MODE_EDP:\n\tcase DP_PANEL_MODE_SPECIAL:\n\t\tpanel_mode_edp = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tresult = core_link_read_dpcd(\n\t\tlink,\n\t\tDP_EDP_CONFIGURATION_SET,\n\t\t&edp_config_set.raw,\n\t\tsizeof(edp_config_set.raw));\n\n\tif (result == DC_OK &&\n\t\tedp_config_set.bits.PANEL_MODE_EDP\n\t\t!= panel_mode_edp) {\n\n\t\tedp_config_set.bits.PANEL_MODE_EDP =\n\t\tpanel_mode_edp;\n\t\tresult = core_link_write_dpcd(\n\t\t\tlink,\n\t\t\tDP_EDP_CONFIGURATION_SET,\n\t\t\t&edp_config_set.raw,\n\t\t\tsizeof(edp_config_set.raw));\n\n\t\tASSERT(result == DC_OK);\n\t}\n\n\tlink->panel_mode = panel_mode;\n\tDC_LOG_DETECTION_DP_CAPS(\"Link: %d eDP panel mode supported: %d \"\n\t\t \"eDP panel mode enabled: %d \\n\",\n\t\t link->link_index,\n\t\t link->dpcd_caps.panel_mode_edp,\n\t\t panel_mode_edp);\n}\n\nenum dp_panel_mode dp_get_panel_mode(struct dc_link *link)\n{\n\t \n\tif (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {\n\n\t\tswitch (link->dpcd_caps.branch_dev_id) {\n\t\tcase DP_BRANCH_DEVICE_ID_0022B9:\n\t\t\t \n\t\t\tif (strncmp(\n\t\t\t\tlink->dpcd_caps.branch_dev_name,\n\t\t\t\tDP_VGA_LVDS_CONVERTER_ID_2,\n\t\t\t\tsizeof(\n\t\t\t\tlink->dpcd_caps.\n\t\t\t\tbranch_dev_name)) == 0) {\n\t\t\t\t\treturn DP_PANEL_MODE_SPECIAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_BRANCH_DEVICE_ID_00001A:\n\t\t\t \n\t\t\tif (strncmp(link->dpcd_caps.branch_dev_name,\n\t\t\t\tDP_VGA_LVDS_CONVERTER_ID_3,\n\t\t\t\tsizeof(\n\t\t\t\tlink->dpcd_caps.\n\t\t\t\tbranch_dev_name)) == 0) {\n\t\t\t\t\treturn DP_PANEL_MODE_SPECIAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (link->dpcd_caps.panel_mode_edp &&\n\t\t(link->connector_signal == SIGNAL_TYPE_EDP ||\n\t\t (link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t  link->is_internal_display))) {\n\t\treturn DP_PANEL_MODE_EDP;\n\t}\n\n\treturn DP_PANEL_MODE_DEFAULT;\n}\n\nbool edp_set_backlight_level_nits(struct dc_link *link,\n\t\tbool isHDR,\n\t\tuint32_t backlight_millinits,\n\t\tuint32_t transition_time_in_ms)\n{\n\tstruct dpcd_source_backlight_set dpcd_backlight_set;\n\tuint8_t backlight_control = isHDR ? 1 : 0;\n\n\tif (!link || (link->connector_signal != SIGNAL_TYPE_EDP &&\n\t\t\tlink->connector_signal != SIGNAL_TYPE_DISPLAY_PORT))\n\t\treturn false;\n\n\t\n\tif (link->dpcd_sink_ext_caps.bits.oled == 1)\n\t\tbacklight_control = 1;\n\n\t*(uint32_t *)&dpcd_backlight_set.backlight_level_millinits = backlight_millinits;\n\t*(uint16_t *)&dpcd_backlight_set.backlight_transition_time_ms = (uint16_t)transition_time_in_ms;\n\n\n\tif (!link->dpcd_caps.panel_luminance_control) {\n\t\tif (core_link_write_dpcd(link, DP_SOURCE_BACKLIGHT_LEVEL,\n\t\t\t(uint8_t *)(&dpcd_backlight_set),\n\t\t\tsizeof(dpcd_backlight_set)) != DC_OK)\n\t\t\treturn false;\n\n\t\tif (core_link_write_dpcd(link, DP_SOURCE_BACKLIGHT_CONTROL,\n\t\t\t&backlight_control, 1) != DC_OK)\n\t\t\treturn false;\n\t} else {\n\t\tconst uint8_t backlight_enable = DP_EDP_PANEL_LUMINANCE_CONTROL_ENABLE;\n\t\tstruct target_luminance_value *target_luminance = NULL;\n\n\t\t\n\t\tif (backlight_millinits > 0xFFFFFF)\n\t\t\tbacklight_millinits = 0xFFFFFF;\n\n\t\ttarget_luminance = (struct target_luminance_value *)&backlight_millinits;\n\n\t\tif (core_link_write_dpcd(link, DP_EDP_BACKLIGHT_MODE_SET_REGISTER,\n\t\t\t&backlight_enable,\n\t\t\tsizeof(backlight_enable)) != DC_OK)\n\t\t\treturn false;\n\n\t\tif (core_link_write_dpcd(link, DP_EDP_PANEL_TARGET_LUMINANCE_VALUE,\n\t\t\t(uint8_t *)(target_luminance),\n\t\t\tsizeof(struct target_luminance_value)) != DC_OK)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool edp_get_backlight_level_nits(struct dc_link *link,\n\t\tuint32_t *backlight_millinits_avg,\n\t\tuint32_t *backlight_millinits_peak)\n{\n\tunion dpcd_source_backlight_get dpcd_backlight_get;\n\n\tmemset(&dpcd_backlight_get, 0, sizeof(union dpcd_source_backlight_get));\n\n\tif (!link || (link->connector_signal != SIGNAL_TYPE_EDP &&\n\t\t\tlink->connector_signal != SIGNAL_TYPE_DISPLAY_PORT))\n\t\treturn false;\n\n\tif (!core_link_read_dpcd(link, DP_SOURCE_BACKLIGHT_CURRENT_PEAK,\n\t\t\tdpcd_backlight_get.raw,\n\t\t\tsizeof(union dpcd_source_backlight_get)))\n\t\treturn false;\n\n\t*backlight_millinits_avg =\n\t\tdpcd_backlight_get.bytes.backlight_millinits_avg;\n\t*backlight_millinits_peak =\n\t\tdpcd_backlight_get.bytes.backlight_millinits_peak;\n\n\t \n\tif (*backlight_millinits_avg == 0 ||\n\t\t\t*backlight_millinits_avg > *backlight_millinits_peak)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool edp_backlight_enable_aux(struct dc_link *link, bool enable)\n{\n\tuint8_t backlight_enable = enable ? 1 : 0;\n\n\tif (!link || (link->connector_signal != SIGNAL_TYPE_EDP &&\n\t\tlink->connector_signal != SIGNAL_TYPE_DISPLAY_PORT))\n\t\treturn false;\n\n\tif (core_link_write_dpcd(link, DP_SOURCE_BACKLIGHT_ENABLE,\n\t\t&backlight_enable, 1) != DC_OK)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n\nstatic bool read_default_bl_aux(struct dc_link *link, uint32_t *backlight_millinits)\n{\n\tif (!link || (link->connector_signal != SIGNAL_TYPE_EDP &&\n\t\tlink->connector_signal != SIGNAL_TYPE_DISPLAY_PORT))\n\t\treturn false;\n\n\tif (!link->dpcd_caps.panel_luminance_control) {\n\t\tif (!core_link_read_dpcd(link, DP_SOURCE_BACKLIGHT_LEVEL,\n\t\t\t(uint8_t *)backlight_millinits,\n\t\t\tsizeof(uint32_t)))\n\t\t\treturn false;\n\t} else {\n\t\t\n\t\tmemset(backlight_millinits, 0, sizeof(uint32_t));\n\n\t\tif (!core_link_read_dpcd(link, DP_EDP_PANEL_TARGET_LUMINANCE_VALUE,\n\t\t\t(uint8_t *)backlight_millinits,\n\t\t\tsizeof(struct target_luminance_value)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool set_default_brightness_aux(struct dc_link *link)\n{\n\tuint32_t default_backlight;\n\n\tif (link && link->dpcd_sink_ext_caps.bits.oled == 1) {\n\t\tif (!read_default_bl_aux(link, &default_backlight))\n\t\t\tdefault_backlight = 150000;\n\t\t\n\t\tif (default_backlight < 1000 || default_backlight > 5000000)\n\t\t\tdefault_backlight = 150000;\n\n\t\treturn edp_set_backlight_level_nits(link, true,\n\t\t\t\tdefault_backlight, 0);\n\t}\n\treturn false;\n}\n\nbool edp_is_ilr_optimization_enabled(struct dc_link *link)\n{\n\tif (link->dpcd_caps.edp_supported_link_rates_count == 0 || !link->panel_config.ilr.optimize_edp_link_rate)\n\t\treturn false;\n\treturn true;\n}\n\nenum dc_link_rate get_max_link_rate_from_ilr_table(struct dc_link *link)\n{\n\tenum dc_link_rate link_rate = link->reported_link_cap.link_rate;\n\n\tfor (int i = 0; i < link->dpcd_caps.edp_supported_link_rates_count; i++) {\n\t\tif (link_rate < link->dpcd_caps.edp_supported_link_rates[i])\n\t\t\tlink_rate = link->dpcd_caps.edp_supported_link_rates[i];\n\t}\n\n\treturn link_rate;\n}\n\nbool edp_is_ilr_optimization_required(struct dc_link *link,\n\t\tstruct dc_crtc_timing *crtc_timing)\n{\n\tstruct dc_link_settings link_setting;\n\tuint8_t link_bw_set;\n\tuint8_t link_rate_set;\n\tuint32_t req_bw;\n\tunion lane_count_set lane_count_set = {0};\n\n\tASSERT(link || crtc_timing); \n\n\tif (!edp_is_ilr_optimization_enabled(link))\n\t\treturn false;\n\n\n\t\n\tcore_link_read_dpcd(link, DP_LINK_BW_SET,\n\t\t\t\t&link_bw_set, sizeof(link_bw_set));\n\n\tif (link_bw_set) {\n\t\tDC_LOG_EVENT_LINK_TRAINING(\"eDP ILR: Optimization required, VBIOS used link_bw_set\\n\");\n\t\treturn true;\n\t}\n\n\t\n\tcore_link_read_dpcd(link, DP_LINK_RATE_SET,\n\t\t\t    &link_rate_set, sizeof(link_rate_set));\n\n\t\n\tcore_link_read_dpcd(link, DP_LANE_COUNT_SET,\n\t\t\t\t&lane_count_set.raw, sizeof(lane_count_set));\n\n\treq_bw = dc_bandwidth_in_kbps_from_timing(crtc_timing, dc_link_get_highest_encoding_format(link));\n\n\tif (!crtc_timing->flags.DSC)\n\t\tedp_decide_link_settings(link, &link_setting, req_bw);\n\telse\n\t\tdecide_edp_link_settings_with_dsc(link, &link_setting, req_bw, LINK_RATE_UNKNOWN);\n\n\tif (link->dpcd_caps.edp_supported_link_rates[link_rate_set] != link_setting.link_rate ||\n\t\t\tlane_count_set.bits.LANE_COUNT_SET != link_setting.lane_count) {\n\t\tDC_LOG_EVENT_LINK_TRAINING(\"eDP ILR: Optimization required, VBIOS link_rate_set not optimal\\n\");\n\t\treturn true;\n\t}\n\n\tDC_LOG_EVENT_LINK_TRAINING(\"eDP ILR: No optimization required, VBIOS set optimal link_rate_set\\n\");\n\treturn false;\n}\n\nvoid edp_panel_backlight_power_on(struct dc_link *link, bool wait_for_hpd)\n{\n\tif (link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn;\n\n\tlink->dc->hwss.edp_power_control(link, true);\n\tif (wait_for_hpd)\n\t\tlink->dc->hwss.edp_wait_for_hpd_ready(link, true);\n\tif (link->dc->hwss.edp_backlight_control)\n\t\tlink->dc->hwss.edp_backlight_control(link, true);\n}\n\nvoid edp_set_panel_power(struct dc_link *link, bool powerOn)\n{\n\tif (powerOn) {\n\t\t\n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t\tlink->dc->hwss.edp_power_control(link, true);\n\t\tlink->dc->hwss.edp_wait_for_hpd_ready(link, true);\n\n\t\t\n\t\tif (link->dc->hwss.edp_backlight_control)\n\t\t\tlink->dc->hwss.edp_backlight_control(link, true);\n\n\t\t\n\t\tdpcd_write_rx_power_ctrl(link, true);\n\t} else {\n\t\t\n\t\tdpcd_write_rx_power_ctrl(link, false);\n\n\t\t\n\t\tif (link->dc->hwss.edp_backlight_control)\n\t\t\tlink->dc->hwss.edp_backlight_control(link, false);\n\n\t\t\n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t\tlink->dc->hwss.edp_power_control(link, false);\n\t}\n}\n\nbool edp_wait_for_t12(struct dc_link *link)\n{\n\tif (link->connector_signal == SIGNAL_TYPE_EDP && link->dc->hwss.edp_wait_for_T12) {\n\t\tlink->dc->hwss.edp_wait_for_T12(link);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid edp_add_delay_for_T9(struct dc_link *link)\n{\n\tif (link && link->panel_config.pps.extra_delay_backlight_off > 0)\n\t\tfsleep(link->panel_config.pps.extra_delay_backlight_off * 1000);\n}\n\nbool edp_receiver_ready_T9(struct dc_link *link)\n{\n\tunsigned int tries = 0;\n\tunsigned char sinkstatus = 0;\n\tunsigned char edpRev = 0;\n\tenum dc_status result = DC_OK;\n\n\tresult = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));\n\n\t \n\tif (result == DC_OK && edpRev >= DP_EDP_12) {\n\t\tdo {\n\t\t\tsinkstatus = 1;\n\t\t\tresult = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));\n\t\t\tif (sinkstatus == 0)\n\t\t\t\tbreak;\n\t\t\tif (result != DC_OK)\n\t\t\t\tbreak;\n\t\t\tudelay(100); \n\t\t} while (++tries < 50);\n\t}\n\n\treturn result;\n}\n\nbool edp_receiver_ready_T7(struct dc_link *link)\n{\n\tunsigned char sinkstatus = 0;\n\tunsigned char edpRev = 0;\n\tenum dc_status result = DC_OK;\n\n\t \n\tunsigned long long enter_timestamp = 0;\n\tunsigned long long finish_timestamp = 0;\n\tunsigned long long time_taken_in_ns = 0;\n\n\tresult = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));\n\n\tif (result == DC_OK && edpRev >= DP_EDP_12) {\n\t\t \n\t\tenter_timestamp = dm_get_timestamp(link->ctx);\n\t\tdo {\n\t\t\tsinkstatus = 0;\n\t\t\tresult = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));\n\t\t\tif (sinkstatus == 1)\n\t\t\t\tbreak;\n\t\t\tif (result != DC_OK)\n\t\t\t\tbreak;\n\t\t\tudelay(25);\n\t\t\tfinish_timestamp = dm_get_timestamp(link->ctx);\n\t\t\ttime_taken_in_ns = dm_get_elapse_time_in_ns(link->ctx, finish_timestamp, enter_timestamp);\n\t\t} while (time_taken_in_ns < 50 * 1000000); \n\t}\n\n\tif (link && link->panel_config.pps.extra_t7_ms > 0)\n\t\tfsleep(link->panel_config.pps.extra_t7_ms * 1000);\n\n\treturn result;\n}\n\nbool edp_power_alpm_dpcd_enable(struct dc_link *link, bool enable)\n{\n\tbool ret = false;\n\tunion dpcd_alpm_configuration alpm_config;\n\n\tif (link->psr_settings.psr_version == DC_PSR_VERSION_SU_1) {\n\t\tmemset(&alpm_config, 0, sizeof(alpm_config));\n\n\t\talpm_config.bits.ENABLE = (enable ? true : false);\n\t\tret = dm_helpers_dp_write_dpcd(link->ctx, link,\n\t\t\t\tDP_RECEIVER_ALPM_CONFIG, &alpm_config.raw,\n\t\t\t\tsizeof(alpm_config.raw));\n\t}\n\treturn ret;\n}\n\nstatic struct pipe_ctx *get_pipe_from_link(const struct dc_link *link)\n{\n\tint i;\n\tstruct dc *dc = link->ctx->dc;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream) {\n\t\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream->link == link) {\n\t\t\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pipe_ctx;\n}\n\nbool edp_set_backlight_level(const struct dc_link *link,\n\t\tuint32_t backlight_pwm_u16_16,\n\t\tuint32_t frame_ramp)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\n\tDC_LOGGER_INIT(link->ctx->logger);\n\tDC_LOG_BACKLIGHT(\"New Backlight level: %d (0x%X)\\n\",\n\t\t\tbacklight_pwm_u16_16, backlight_pwm_u16_16);\n\n\tif (dc_is_embedded_signal(link->connector_signal)) {\n\t\tstruct pipe_ctx *pipe_ctx = get_pipe_from_link(link);\n\n\t\tif (pipe_ctx) {\n\t\t\t \n\t\t\tif (pipe_ctx->plane_state == NULL)\n\t\t\t\tframe_ramp = 0;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\tdc->hwss.set_backlight_level(\n\t\t\t\tpipe_ctx,\n\t\t\t\tbacklight_pwm_u16_16,\n\t\t\t\tframe_ramp);\n\t}\n\treturn true;\n}\n\nbool edp_set_psr_allow_active(struct dc_link *link, const bool *allow_active,\n\t\tbool wait, bool force_static, const unsigned int *power_opts)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tstruct dmub_psr *psr = dc->res_pool->psr;\n\tunsigned int panel_inst;\n\n\tif (psr == NULL && force_static)\n\t\treturn false;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\tif ((allow_active != NULL) && (*allow_active == true) && (link->type == dc_connection_none)) {\n\t\t\n\t\treturn false;\n\t}\n\n\t \n\tif (power_opts && link->psr_settings.psr_power_opt != *power_opts) {\n\t\tlink->psr_settings.psr_power_opt = *power_opts;\n\n\t\tif (psr != NULL && link->psr_settings.psr_feature_enabled && psr->funcs->psr_set_power_opt)\n\t\t\tpsr->funcs->psr_set_power_opt(psr, link->psr_settings.psr_power_opt, panel_inst);\n\t}\n\n\tif (psr != NULL && link->psr_settings.psr_feature_enabled &&\n\t\t\tforce_static && psr->funcs->psr_force_static)\n\t\tpsr->funcs->psr_force_static(psr, panel_inst);\n\n\t \n\tif (allow_active && link->psr_settings.psr_allow_active != *allow_active) {\n\t\tlink->psr_settings.psr_allow_active = *allow_active;\n\n\t\tif (!link->psr_settings.psr_allow_active)\n\t\t\tdc_z10_restore(dc);\n\n\t\tif (psr != NULL && link->psr_settings.psr_feature_enabled) {\n\t\t\tpsr->funcs->psr_enable(psr, link->psr_settings.psr_allow_active, wait, panel_inst);\n\t\t} else if ((dmcu != NULL && dmcu->funcs->is_dmcu_initialized(dmcu)) &&\n\t\t\tlink->psr_settings.psr_feature_enabled)\n\t\t\tdmcu->funcs->set_psr_enable(dmcu, link->psr_settings.psr_allow_active, wait);\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool edp_get_psr_state(const struct dc_link *link, enum dc_psr_state *state)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tstruct dmub_psr *psr = dc->res_pool->psr;\n\tunsigned int panel_inst;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\tif (psr != NULL && link->psr_settings.psr_feature_enabled)\n\t\tpsr->funcs->psr_get_state(psr, state, panel_inst);\n\telse if (dmcu != NULL && link->psr_settings.psr_feature_enabled)\n\t\tdmcu->funcs->get_psr_state(dmcu, state);\n\n\treturn true;\n}\n\nstatic inline enum physical_phy_id\ntransmitter_to_phy_id(struct dc_link *link)\n{\n\tstruct dc_context *dc_ctx = link->ctx;\n\tenum transmitter transmitter_value = link->link_enc->transmitter;\n\n\tswitch (transmitter_value) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn PHYLD_0;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn PHYLD_1;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn PHYLD_2;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn PHYLD_3;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn PHYLD_4;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\treturn PHYLD_5;\n\tcase TRANSMITTER_NUTMEG_CRT:\n\t\treturn PHYLD_6;\n\tcase TRANSMITTER_TRAVIS_CRT:\n\t\treturn PHYLD_7;\n\tcase TRANSMITTER_TRAVIS_LCD:\n\t\treturn PHYLD_8;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\treturn PHYLD_9;\n\tcase TRANSMITTER_COUNT:\n\t\treturn PHYLD_COUNT;\n\tcase TRANSMITTER_UNKNOWN:\n\t\treturn PHYLD_UNKNOWN;\n\tdefault:\n\t\tDC_ERROR(\"Unknown transmitter value %d\\n\", transmitter_value);\n\t\treturn PHYLD_UNKNOWN;\n\t}\n}\n\nbool edp_setup_psr(struct dc_link *link,\n\t\tconst struct dc_stream_state *stream, struct psr_config *psr_config,\n\t\tstruct psr_context *psr_context)\n{\n\tstruct dc *dc;\n\tstruct dmcu *dmcu;\n\tstruct dmub_psr *psr;\n\tint i;\n\tunsigned int panel_inst;\n\t \n\tunion dpcd_psr_configuration psr_configuration;\n\tunion dpcd_sink_active_vtotal_control_mode vtotal_control = {0};\n\n\tpsr_context->controllerId = CONTROLLER_ID_UNDEFINED;\n\n\tif (!link)\n\t\treturn false;\n\n\tdc = link->ctx->dc;\n\tdmcu = dc->res_pool->dmcu;\n\tpsr = dc->res_pool->psr;\n\n\tif (!dmcu && !psr)\n\t\treturn false;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\n\tmemset(&psr_configuration, 0, sizeof(psr_configuration));\n\n\tpsr_configuration.bits.ENABLE                    = 1;\n\tpsr_configuration.bits.CRC_VERIFICATION          = 1;\n\tpsr_configuration.bits.FRAME_CAPTURE_INDICATION  =\n\t\t\tpsr_config->psr_frame_capture_indication_req;\n\n\t \n\tif (link->psr_settings.psr_version == DC_PSR_VERSION_SU_1) {\n\t\t \n\t\tpsr_configuration.bits.LINE_CAPTURE_INDICATION = 0;\n\t\t \n\t\tpsr_configuration.bits.IRQ_HPD_WITH_CRC_ERROR    = 1;\n\t\t \n\t\tpsr_configuration.bits.ENABLE_PSR2    = 1;\n\t\t \n\t\tpsr_configuration.bits.EARLY_TRANSPORT_ENABLE    = 1;\n\t}\n\n\tdm_helpers_dp_write_dpcd(\n\t\tlink->ctx,\n\t\tlink,\n\t\t368,\n\t\t&psr_configuration.raw,\n\t\tsizeof(psr_configuration.raw));\n\n\tif (link->psr_settings.psr_version == DC_PSR_VERSION_SU_1) {\n\t\tedp_power_alpm_dpcd_enable(link, true);\n\t\tpsr_context->su_granularity_required =\n\t\t\tpsr_config->su_granularity_required;\n\t\tpsr_context->su_y_granularity =\n\t\t\tpsr_config->su_y_granularity;\n\t\tpsr_context->line_time_in_us = psr_config->line_time_in_us;\n\n\t\t \n\t\tif (link->psr_settings.psr_vtotal_control_support) {\n\t\t\tpsr_context->rate_control_caps = psr_config->rate_control_caps;\n\t\t\tvtotal_control.bits.ENABLE = true;\n\t\t\tcore_link_write_dpcd(link, DP_SINK_PSR_ACTIVE_VTOTAL_CONTROL_MODE,\n\t\t\t\t\t\t\t&vtotal_control.raw, sizeof(vtotal_control.raw));\n\t\t}\n\t}\n\n\tpsr_context->channel = link->ddc->ddc_pin->hw_info.ddc_channel;\n\tpsr_context->transmitterId = link->link_enc->transmitter;\n\tpsr_context->engineId = link->link_enc->preferred_engine;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream\n\t\t\t\t== stream) {\n\t\t\t \n\t\t\tpsr_context->controllerId =\n\t\t\t\tdc->current_state->res_ctx.\n\t\t\t\tpipe_ctx[i].stream_res.tg->inst + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tpsr_context->phyType = PHY_TYPE_UNIPHY;\n\t \n\tpsr_context->smuPhyId = transmitter_to_phy_id(link);\n\n\tpsr_context->crtcTimingVerticalTotal = stream->timing.v_total;\n\tpsr_context->vsync_rate_hz = div64_u64(div64_u64((stream->\n\t\t\t\t\ttiming.pix_clk_100hz * 100),\n\t\t\t\t\tstream->timing.v_total),\n\t\t\t\t\tstream->timing.h_total);\n\n\tpsr_context->psrSupportedDisplayConfig = true;\n\tpsr_context->psrExitLinkTrainingRequired =\n\t\tpsr_config->psr_exit_link_training_required;\n\tpsr_context->sdpTransmitLineNumDeadline =\n\t\tpsr_config->psr_sdp_transmit_line_num_deadline;\n\tpsr_context->psrFrameCaptureIndicationReq =\n\t\tpsr_config->psr_frame_capture_indication_req;\n\n\tpsr_context->skipPsrWaitForPllLock = 0;  \n\n\tpsr_context->numberOfControllers =\n\t\t\tlink->dc->res_pool->timing_generator_count;\n\n\tpsr_context->rfb_update_auto_en = true;\n\n\t \n\tpsr_context->timehyst_frames = 2;\n\t \n\tpsr_context->hyst_lines = stream->timing.v_total / 2 / 100;\n\tpsr_context->aux_repeats = 10;\n\n\tpsr_context->psr_level.u32all = 0;\n\n\t \n\tif (link->ctx->asic_id.chip_family >= FAMILY_RV) {\n\t\tswitch (link->ctx->asic_id.chip_family) {\n\t\tcase FAMILY_YELLOW_CARP:\n\t\tcase AMDGPU_FAMILY_GC_10_3_6:\n\t\tcase AMDGPU_FAMILY_GC_11_0_1:\n\t\t\tif (dc->debug.disable_z10 || dc->debug.psr_skip_crtc_disable)\n\t\t\t\tpsr_context->psr_level.bits.SKIP_CRTC_DISABLE = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpsr_context->psr_level.bits.SKIP_CRTC_DISABLE = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tpsr_context->allow_smu_optimizations = psr_config->allow_smu_optimizations;\n\tpsr_context->allow_multi_disp_optimizations = psr_config->allow_multi_disp_optimizations;\n\n\t \n\tpsr_context->psr_level.bits.DISABLE_PSR_ENTRY_ABORT = 1;\n\n\t \n\tpsr_context->psr_level.bits.DISABLE_ALPM = 0;\n\tpsr_context->psr_level.bits.ALPM_DEFAULT_PD_MODE = 1;\n\n\t \n\tpsr_context->frame_delay = 0;\n\n\tpsr_context->dsc_slice_height = psr_config->dsc_slice_height;\n\n\tif (psr) {\n\t\tlink->psr_settings.psr_feature_enabled = psr->funcs->psr_copy_settings(psr,\n\t\t\tlink, psr_context, panel_inst);\n\t\tlink->psr_settings.psr_power_opt = 0;\n\t\tlink->psr_settings.psr_allow_active = 0;\n\t} else {\n\t\tlink->psr_settings.psr_feature_enabled = dmcu->funcs->setup_psr(dmcu, link, psr_context);\n\t}\n\n\t \n\tif (link->psr_settings.psr_feature_enabled == 0)\n\t\tASSERT(0);\n\n\treturn true;\n\n}\n\nvoid edp_get_psr_residency(const struct dc_link *link, uint32_t *residency)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmub_psr *psr = dc->res_pool->psr;\n\tunsigned int panel_inst;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn;\n\n\t\n\tif (psr != NULL && link->psr_settings.psr_feature_enabled)\n\t\tpsr->funcs->psr_get_residency(psr, residency, panel_inst);\n\telse\n\t\t*residency = 0;\n}\nbool edp_set_sink_vtotal_in_psr_active(const struct dc_link *link, uint16_t psr_vtotal_idle, uint16_t psr_vtotal_su)\n{\n\tstruct dc *dc = link->ctx->dc;\n\tstruct dmub_psr *psr = dc->res_pool->psr;\n\n\tif (psr == NULL || !link->psr_settings.psr_feature_enabled || !link->psr_settings.psr_vtotal_control_support)\n\t\treturn false;\n\n\tpsr->funcs->psr_set_sink_vtotal_in_psr_active(psr, psr_vtotal_idle, psr_vtotal_su);\n\n\treturn true;\n}\n\nbool edp_set_replay_allow_active(struct dc_link *link, const bool *allow_active,\n\tbool wait, bool force_static, const unsigned int *power_opts)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmub_replay *replay = dc->res_pool->replay;\n\tunsigned int panel_inst;\n\n\tif (replay == NULL && force_static)\n\t\treturn false;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\t \n\tif (power_opts && link->replay_settings.replay_power_opt_active != *power_opts) {\n\t\tif (link->replay_settings.replay_feature_enabled && replay->funcs->replay_set_power_opt) {\n\t\t\treplay->funcs->replay_set_power_opt(replay, *power_opts, panel_inst);\n\t\t\tlink->replay_settings.replay_power_opt_active = *power_opts;\n\t\t}\n\t}\n\n\t \n\tif (allow_active && link->replay_settings.replay_allow_active != *allow_active) {\n\t\t\n\t\t\n\t\tif (replay != NULL && link->replay_settings.replay_feature_enabled)\n\t\t\treplay->funcs->replay_enable(replay, *allow_active, wait, panel_inst);\n\t\tlink->replay_settings.replay_allow_active = *allow_active;\n\t}\n\n\treturn true;\n}\n\nbool edp_get_replay_state(const struct dc_link *link, uint64_t *state)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmub_replay *replay = dc->res_pool->replay;\n\tunsigned int panel_inst;\n\tenum replay_state pr_state = REPLAY_STATE_0;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\tif (replay != NULL && link->replay_settings.replay_feature_enabled)\n\t\treplay->funcs->replay_get_state(replay, &pr_state, panel_inst);\n\t*state = pr_state;\n\n\treturn true;\n}\n\nbool edp_setup_replay(struct dc_link *link, const struct dc_stream_state *stream)\n{\n\t \n\tstruct dc *dc = link->ctx->dc;\n\tstruct dmub_replay *replay = dc->res_pool->replay;\n\tint i;\n\tunsigned int panel_inst;\n\tstruct replay_context replay_context = { 0 };\n\tunsigned int lineTimeInNs = 0;\n\n\n\tunion replay_enable_and_configuration replay_config;\n\n\tunion dpcd_alpm_configuration alpm_config;\n\n\treplay_context.controllerId = CONTROLLER_ID_UNDEFINED;\n\n\tif (!link)\n\t\treturn false;\n\n\tif (!replay)\n\t\treturn false;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\treplay_context.aux_inst = link->ddc->ddc_pin->hw_info.ddc_channel;\n\treplay_context.digbe_inst = link->link_enc->transmitter;\n\treplay_context.digfe_inst = link->link_enc->preferred_engine;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dc->current_state->res_ctx.pipe_ctx[i].stream\n\t\t\t\t== stream) {\n\t\t\t \n\t\t\treplay_context.controllerId =\n\t\t\t\tdc->current_state->res_ctx.pipe_ctx[i].stream_res.tg->inst + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlineTimeInNs =\n\t\t((stream->timing.h_total * 1000000) /\n\t\t\t(stream->timing.pix_clk_100hz / 10)) + 1;\n\n\treplay_context.line_time_in_ns = lineTimeInNs;\n\n\tif (replay)\n\t\tlink->replay_settings.replay_feature_enabled =\n\t\t\treplay->funcs->replay_copy_settings(replay, link, &replay_context, panel_inst);\n\tif (link->replay_settings.replay_feature_enabled) {\n\n\t\treplay_config.bits.FREESYNC_PANEL_REPLAY_MODE = 1;\n\t\treplay_config.bits.TIMING_DESYNC_ERROR_VERIFICATION =\n\t\t\tlink->replay_settings.config.replay_timing_sync_supported;\n\t\treplay_config.bits.STATE_TRANSITION_ERROR_DETECTION = 1;\n\t\tdm_helpers_dp_write_dpcd(link->ctx, link,\n\t\t\tDP_SINK_PR_ENABLE_AND_CONFIGURATION,\n\t\t\t(uint8_t *)&(replay_config.raw), sizeof(uint8_t));\n\n\t\tmemset(&alpm_config, 0, sizeof(alpm_config));\n\t\talpm_config.bits.ENABLE = 1;\n\t\tdm_helpers_dp_write_dpcd(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\tDP_RECEIVER_ALPM_CONFIG,\n\t\t\t&alpm_config.raw,\n\t\t\tsizeof(alpm_config.raw));\n\t}\n\treturn true;\n}\n\nbool edp_set_coasting_vtotal(struct dc_link *link, uint16_t coasting_vtotal)\n{\n\tstruct dc *dc = link->ctx->dc;\n\tstruct dmub_replay *replay = dc->res_pool->replay;\n\tunsigned int panel_inst;\n\n\tif (!replay)\n\t\treturn false;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\tif (coasting_vtotal && link->replay_settings.coasting_vtotal != coasting_vtotal) {\n\t\treplay->funcs->replay_set_coasting_vtotal(replay, coasting_vtotal, panel_inst);\n\t\tlink->replay_settings.coasting_vtotal = coasting_vtotal;\n\t}\n\n\treturn true;\n}\n\nbool edp_replay_residency(const struct dc_link *link,\n\tunsigned int *residency, const bool is_start, const bool is_alpm)\n{\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmub_replay *replay = dc->res_pool->replay;\n\tunsigned int panel_inst;\n\n\tif (!dc_get_edp_link_panel_inst(dc, link, &panel_inst))\n\t\treturn false;\n\n\tif (replay != NULL && link->replay_settings.replay_feature_enabled)\n\t\treplay->funcs->replay_residency(replay, panel_inst, residency, is_start, is_alpm);\n\telse\n\t\t*residency = 0;\n\n\treturn true;\n}\n\nstatic struct abm *get_abm_from_stream_res(const struct dc_link *link)\n{\n\tint i;\n\tstruct dc *dc = link->ctx->dc;\n\tstruct abm *abm = NULL;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx pipe_ctx = dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct dc_stream_state *stream = pipe_ctx.stream;\n\n\t\tif (stream && stream->link == link) {\n\t\t\tabm = pipe_ctx.stream_res.abm;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn abm;\n}\n\nint edp_get_backlight_level(const struct dc_link *link)\n{\n\tstruct abm *abm = get_abm_from_stream_res(link);\n\tstruct panel_cntl *panel_cntl = link->panel_cntl;\n\tstruct dc  *dc = link->ctx->dc;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tbool fw_set_brightness = true;\n\n\tif (dmcu)\n\t\tfw_set_brightness = dmcu->funcs->is_dmcu_initialized(dmcu);\n\n\tif (!fw_set_brightness && panel_cntl->funcs->get_current_backlight)\n\t\treturn panel_cntl->funcs->get_current_backlight(panel_cntl);\n\telse if (abm != NULL && abm->funcs->get_current_backlight != NULL)\n\t\treturn (int) abm->funcs->get_current_backlight(abm);\n\telse\n\t\treturn DC_ERROR_UNEXPECTED;\n}\n\nint edp_get_target_backlight_pwm(const struct dc_link *link)\n{\n\tstruct abm *abm = get_abm_from_stream_res(link);\n\n\tif (abm == NULL || abm->funcs->get_target_backlight == NULL)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\treturn (int) abm->funcs->get_target_backlight(abm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}