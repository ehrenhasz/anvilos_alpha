{
  "module_name": "dcn301_fpu.c",
  "hash_id": "d9e421afd9101e8669741ef55dee5bb16fb89e8109a0136fc8374de871e7eec4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn301/dcn301_fpu.c",
  "human_readable_source": " \n#include \"resource.h\"\n#include \"clk_mgr.h\"\n#include \"dcn20/dcn20_resource.h\"\n#include \"dcn301/dcn301_resource.h\"\n#include \"clk_mgr/dcn301/vg_clk_mgr.h\"\n\n#include \"dml/dcn20/dcn20_fpu.h\"\n#include \"dcn301_fpu.h\"\n\n#define TO_DCN301_RES_POOL(pool)\\\n\tcontainer_of(pool, struct dcn301_resource_pool, base)\n\n \n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = dml->soc.clock_limits[vlevel].dcfclk_mhz;\n\tpipes[0].clks_cfg.socclk_mhz = dml->soc.clock_limits[vlevel].socclk_mhz;\n\n\tdml->soc.dram_clock_change_latency_us = table_entry->pstate_latency_us;\n\tdml->soc.sr_exit_time_us = table_entry->sr_exit_time_us;\n\tdml->soc.sr_enter_plus_exit_time_us = table_entry->sr_enter_plus_exit_time_us;\n\n\twm_set->urgent_ns = get_wm_urgent(dml, pipes, pipe_cnt) * 1000;\n\twm_set->cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(dml, pipes, pipe_cnt) * 1000;\n\twm_set->cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(dml, pipes, pipe_cnt) * 1000;\n\twm_set->cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(dml, pipes, pipe_cnt) * 1000;\n\twm_set->pte_meta_urgent_ns = get_wm_memory_trip(dml, pipes, pipe_cnt) * 1000;\n\twm_set->frac_urg_bw_nom = get_fraction_of_urgent_bandwidth(dml, pipes, pipe_cnt) * 1000;\n\twm_set->frac_urg_bw_flip = get_fraction_of_urgent_bandwidth_imm_flip(dml, pipes, pipe_cnt) * 1000;\n\twm_set->urgent_latency_ns = get_urgent_latency(dml, pipes, pipe_cnt) * 1000;\n\tdml->soc.dram_clock_change_latency_us = dram_clock_change_latency_cached;\n\n}\n\nvoid dcn301_update_bw_bounding_box(struct dc *dc, struct clk_bw_params *bw_params)\n{\n\tstruct _vcs_dpi_voltage_scaling_st *s = dc->scratch.update_bw_bounding_box.clock_limits;\n\tstruct dcn301_resource_pool *pool = TO_DCN301_RES_POOL(dc->res_pool);\n\tstruct clk_limit_table *clk_table = &bw_params->clk_table;\n\tunsigned int i, closest_clk_lvl;\n\tint j;\n\n\tdc_assert_fp_enabled();\n\n\tmemcpy(s, dcn3_01_soc.clock_limits, sizeof(dcn3_01_soc.clock_limits));\n\n\t \n\tdcn3_01_ip.max_num_otg = pool->base.res_cap->num_timing_generator;\n\tdcn3_01_ip.max_num_dpp = pool->base.pipe_count;\n\tdcn3_01_soc.num_chans = bw_params->num_channels;\n\n\tASSERT(clk_table->num_entries);\n\tfor (i = 0; i < clk_table->num_entries; i++) {\n\t\t \n\t\tfor (closest_clk_lvl = 0, j = dcn3_01_soc.num_states - 1; j >= 0; j--) {\n\t\t\tif ((unsigned int) dcn3_01_soc.clock_limits[j].dcfclk_mhz <= clk_table->entries[i].dcfclk_mhz) {\n\t\t\t\tclosest_clk_lvl = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ts[i].state = i;\n\t\ts[i].dcfclk_mhz = clk_table->entries[i].dcfclk_mhz;\n\t\ts[i].fabricclk_mhz = clk_table->entries[i].fclk_mhz;\n\t\ts[i].socclk_mhz = clk_table->entries[i].socclk_mhz;\n\t\ts[i].dram_speed_mts = clk_table->entries[i].memclk_mhz * 2;\n\n\t\ts[i].dispclk_mhz = dcn3_01_soc.clock_limits[closest_clk_lvl].dispclk_mhz;\n\t\ts[i].dppclk_mhz = dcn3_01_soc.clock_limits[closest_clk_lvl].dppclk_mhz;\n\t\ts[i].dram_bw_per_chan_gbps =\n\t\t\tdcn3_01_soc.clock_limits[closest_clk_lvl].dram_bw_per_chan_gbps;\n\t\ts[i].dscclk_mhz = dcn3_01_soc.clock_limits[closest_clk_lvl].dscclk_mhz;\n\t\ts[i].dtbclk_mhz = dcn3_01_soc.clock_limits[closest_clk_lvl].dtbclk_mhz;\n\t\ts[i].phyclk_d18_mhz =\n\t\t\tdcn3_01_soc.clock_limits[closest_clk_lvl].phyclk_d18_mhz;\n\t\ts[i].phyclk_mhz = dcn3_01_soc.clock_limits[closest_clk_lvl].phyclk_mhz;\n\t}\n\n\tif (clk_table->num_entries) {\n\t\tdcn3_01_soc.num_states = clk_table->num_entries;\n\t\t \n\t\ts[dcn3_01_soc.num_states] =\n\t\t\tdcn3_01_soc.clock_limits[dcn3_01_soc.num_states - 1];\n\t\ts[dcn3_01_soc.num_states].state = dcn3_01_soc.num_states;\n\t}\n\n\tmemcpy(dcn3_01_soc.clock_limits, s, sizeof(dcn3_01_soc.clock_limits));\n\n\tdcn3_01_soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\tdc->dml.soc.dispclk_dppclk_vco_speed_mhz = dc->clk_mgr->dentist_vco_freq_khz / 1000.0;\n\n\tif ((int)(dcn3_01_soc.dram_clock_change_latency_us * 1000)\n\t\t\t\t!= dc->debug.dram_clock_change_latency_ns\n\t\t\t&& dc->debug.dram_clock_change_latency_ns) {\n\t\tdcn3_01_soc.dram_clock_change_latency_us = dc->debug.dram_clock_change_latency_ns / 1000.0;\n\t}\n\tdml_init_instance(&dc->dml, &dcn3_01_soc, &dcn3_01_ip, DML_PROJECT_DCN30);\n}\n\nvoid dcn301_fpu_set_wm_ranges(int i,\n\tstruct pp_smu_wm_range_sets *ranges,\n\tstruct _vcs_dpi_soc_bounding_box_st *loaded_bb)\n{\n\tdc_assert_fp_enabled();\n\n\tranges->reader_wm_sets[i].min_fill_clk_mhz = (i > 0) ? (loaded_bb->clock_limits[i - 1].dram_speed_mts / 16) + 1 : 0;\n\tranges->reader_wm_sets[i].max_fill_clk_mhz = loaded_bb->clock_limits[i].dram_speed_mts / 16;\n}\n\nvoid dcn301_fpu_init_soc_bounding_box(struct bp_soc_bb_info bb_info)\n{\n\tdc_assert_fp_enabled();\n\n\tif (bb_info.dram_clock_change_latency_100ns > 0)\n\t\tdcn3_01_soc.dram_clock_change_latency_us = bb_info.dram_clock_change_latency_100ns * 10;\n\n\tif (bb_info.dram_sr_enter_exit_latency_100ns > 0)\n\t\tdcn3_01_soc.sr_enter_plus_exit_time_us = bb_info.dram_sr_enter_exit_latency_100ns * 10;\n\n\tif (bb_info.dram_sr_exit_latency_100ns > 0)\n\t\tdcn3_01_soc.sr_exit_time_us = bb_info.dram_sr_exit_latency_100ns * 10;\n}\n\nvoid dcn301_calculate_wm_and_dlg_fp(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt,\n\t\tint vlevel_req)\n{\n\tint i, pipe_idx;\n\tint vlevel, vlevel_max;\n\tstruct wm_range_table_entry *table_entry;\n\tstruct clk_bw_params *bw_params = dc->clk_mgr->bw_params;\n\n\tASSERT(bw_params);\n\tdc_assert_fp_enabled();\n\n\tvlevel_max = bw_params->clk_table.num_entries - 1;\n\n\t \n\ttable_entry = &bw_params->wm_table.entries[WM_D];\n\tif (table_entry->wm_type == WM_TYPE_RETRAINING)\n\t\tvlevel = 0;\n\telse\n\t\tvlevel = vlevel_max;\n\tcalculate_wm_set_for_vlevel(vlevel, table_entry, &context->bw_ctx.bw.dcn.watermarks.d,\n\t\t\t\t\t\t&context->bw_ctx.dml, pipes, pipe_cnt);\n\t \n\ttable_entry = &bw_params->wm_table.entries[WM_C];\n\tvlevel = min(max(vlevel_req, 2), vlevel_max);\n\tcalculate_wm_set_for_vlevel(vlevel, table_entry, &context->bw_ctx.bw.dcn.watermarks.c,\n\t\t\t\t\t\t&context->bw_ctx.dml, pipes, pipe_cnt);\n\t \n\ttable_entry = &bw_params->wm_table.entries[WM_B];\n\tvlevel = min(max(vlevel_req, 1), vlevel_max);\n\tcalculate_wm_set_for_vlevel(vlevel, table_entry, &context->bw_ctx.bw.dcn.watermarks.b,\n\t\t\t\t\t\t&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\t \n\ttable_entry = &bw_params->wm_table.entries[WM_A];\n\tvlevel = min(vlevel_req, vlevel_max);\n\tcalculate_wm_set_for_vlevel(vlevel, table_entry, &context->bw_ctx.bw.dcn.watermarks.a,\n\t\t\t\t\t\t&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = get_dispclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt);\n\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = get_dppclk_calculated(&context->bw_ctx.dml, pipes, pipe_cnt, pipe_idx);\n\n\t\tif (dc->config.forced_clocks) {\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dispclk_mhz;\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dppclk_mhz;\n\t\t}\n\t\tif (dc->debug.min_disp_clk_khz > pipes[pipe_idx].clks_cfg.dispclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dispclk_mhz = dc->debug.min_disp_clk_khz / 1000.0;\n\t\tif (dc->debug.min_dpp_clk_khz > pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz = dc->debug.min_dpp_clk_khz / 1000.0;\n\t\tpipe_idx++;\n\t}\n\n\tdcn20_calculate_dlg_params(dc, context, pipes, pipe_cnt, vlevel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}