{
  "module_name": "dcn20_hwseq.c",
  "hash_id": "adcc8989f5615a9d3a7b3d2587b08acc6fcc6a578e8cd8f872727b3c196003eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c",
  "human_readable_source": " \n#include <linux/delay.h>\n\n#include \"dm_services.h\"\n#include \"basics/dc_common.h\"\n#include \"dm_helpers.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dcn20_resource.h\"\n#include \"dcn20_hwseq.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dcn20_dsc.h\"\n#include \"dcn20_optc.h\"\n#include \"abm.h\"\n#include \"clk_mgr.h\"\n#include \"dmcu.h\"\n#include \"hubp.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"mcif_wb.h\"\n#include \"dchubbub.h\"\n#include \"reg_helper.h\"\n#include \"dcn10/dcn10_cm_common.h\"\n#include \"vm_helper.h\"\n#include \"dccg.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dce/dmub_hw_lock_mgr.h\"\n#include \"hw_sequencer.h\"\n#include \"dpcd_defs.h\"\n#include \"inc/link_enc_cfg.h\"\n#include \"link_hwss.h\"\n#include \"link.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstatic int find_free_gsl_group(const struct dc *dc)\n{\n\tif (dc->res_pool->gsl_groups.gsl_0 == 0)\n\t\treturn 1;\n\tif (dc->res_pool->gsl_groups.gsl_1 == 0)\n\t\treturn 2;\n\tif (dc->res_pool->gsl_groups.gsl_2 == 0)\n\t\treturn 3;\n\n\treturn 0;\n}\n\n \nstatic void dcn20_setup_gsl_group_as_lock(\n\t\tconst struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool enable)\n{\n\tstruct gsl_params gsl;\n\tint group_idx;\n\n\tmemset(&gsl, 0, sizeof(struct gsl_params));\n\n\tif (enable) {\n\t\t \n\t\tif (pipe_ctx->stream_res.gsl_group > 0)\n\t\t\treturn;\n\n\t\tgroup_idx = find_free_gsl_group(dc);\n\t\tASSERT(group_idx != 0);\n\t\tpipe_ctx->stream_res.gsl_group = group_idx;\n\n\t\t \n\t\tswitch (group_idx) {\n\t\tcase 1:\n\t\t\tgsl.gsl0_en = 1;\n\t\t\tdc->res_pool->gsl_groups.gsl_0 = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgsl.gsl1_en = 1;\n\t\t\tdc->res_pool->gsl_groups.gsl_1 = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgsl.gsl2_en = 1;\n\t\t\tdc->res_pool->gsl_groups.gsl_2 = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn; \n\t\t}\n\t\tgsl.gsl_master_en = 1;\n\t} else {\n\t\tgroup_idx = pipe_ctx->stream_res.gsl_group;\n\t\tif (group_idx == 0)\n\t\t\treturn; \n\n\t\tpipe_ctx->stream_res.gsl_group = 0;\n\n\t\t \n\t\tswitch (group_idx) {\n\t\tcase 1:\n\t\t\tgsl.gsl0_en = 0;\n\t\t\tdc->res_pool->gsl_groups.gsl_0 = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgsl.gsl1_en = 0;\n\t\t\tdc->res_pool->gsl_groups.gsl_1 = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgsl.gsl2_en = 0;\n\t\t\tdc->res_pool->gsl_groups.gsl_2 = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\t\tgsl.gsl_master_en = 0;\n\t}\n\n\t \n\tif (pipe_ctx->stream_res.tg->funcs->set_gsl != NULL &&\n\t\tpipe_ctx->stream_res.tg->funcs->set_gsl_source_select != NULL) {\n\t\tpipe_ctx->stream_res.tg->funcs->set_gsl(\n\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t&gsl);\n\n\t\tpipe_ctx->stream_res.tg->funcs->set_gsl_source_select(\n\t\t\tpipe_ctx->stream_res.tg, group_idx,\tenable ? 4 : 0);\n\t} else\n\t\tBREAK_TO_DEBUGGER();\n}\n\nvoid dcn20_set_flip_control_gsl(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool flip_immediate)\n{\n\tif (pipe_ctx && pipe_ctx->plane_res.hubp->funcs->hubp_set_flip_control_surface_gsl)\n\t\tpipe_ctx->plane_res.hubp->funcs->hubp_set_flip_control_surface_gsl(\n\t\t\t\tpipe_ctx->plane_res.hubp, flip_immediate);\n\n}\n\nvoid dcn20_enable_power_gating_plane(\n\tstruct dce_hwseq *hws,\n\tbool enable)\n{\n\tbool force_on = true;  \n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (enable)\n\t\tforce_on = false;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\t \n\tREG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN8_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN8_PG_CONFIG, DOMAIN8_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN10_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN10_PG_CONFIG, DOMAIN8_POWER_FORCEON, force_on);\n\n\t \n\tREG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN9_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN9_PG_CONFIG, DOMAIN9_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN11_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN11_PG_CONFIG, DOMAIN9_POWER_FORCEON, force_on);\n\n\t \n\tREG_UPDATE(DOMAIN16_PG_CONFIG, DOMAIN16_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN17_PG_CONFIG, DOMAIN17_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN18_PG_CONFIG, DOMAIN18_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN19_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN19_PG_CONFIG, DOMAIN19_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN20_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN20_PG_CONFIG, DOMAIN20_POWER_FORCEON, force_on);\n\tif (REG(DOMAIN21_PG_CONFIG))\n\t\tREG_UPDATE(DOMAIN21_PG_CONFIG, DOMAIN21_POWER_FORCEON, force_on);\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n\n}\n\nvoid dcn20_dccg_init(struct dce_hwseq *hws)\n{\n\t \n\tREG_WRITE(MICROSECOND_TIME_BASE_DIV, 0x120264);\n\n\t \n\tREG_WRITE(MILLISECOND_TIME_BASE_DIV, 0x1186a0);\n\n\t \n\tREG_WRITE(DISPCLK_FREQ_CHANGE_CNTL, 0xe01003c);\n}\n\nvoid dcn20_disable_vga(\n\tstruct dce_hwseq *hws)\n{\n\tREG_WRITE(D1VGA_CONTROL, 0);\n\tREG_WRITE(D2VGA_CONTROL, 0);\n\tREG_WRITE(D3VGA_CONTROL, 0);\n\tREG_WRITE(D4VGA_CONTROL, 0);\n\tREG_WRITE(D5VGA_CONTROL, 0);\n\tREG_WRITE(D6VGA_CONTROL, 0);\n}\n\nvoid dcn20_program_triple_buffer(\n\tconst struct dc *dc,\n\tstruct pipe_ctx *pipe_ctx,\n\tbool enable_triple_buffer)\n{\n\tif (pipe_ctx->plane_res.hubp && pipe_ctx->plane_res.hubp->funcs) {\n\t\tpipe_ctx->plane_res.hubp->funcs->hubp_enable_tripleBuffer(\n\t\t\tpipe_ctx->plane_res.hubp,\n\t\t\tenable_triple_buffer);\n\t}\n}\n\n \nvoid dcn20_init_blank(\n\t\tstruct dc *dc,\n\t\tstruct timing_generator *tg)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\tstruct output_pixel_processor *opp = NULL;\n\tstruct output_pixel_processor *bottom_opp = NULL;\n\tuint32_t num_opps, opp_id_src0, opp_id_src1;\n\tuint32_t otg_active_width, otg_active_height;\n\n\t \n\tcolor_space = COLOR_SPACE_SRGB;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\t \n\ttg->funcs->get_otg_active_size(tg,\n\t\t\t&otg_active_width,\n\t\t\t&otg_active_height);\n\n\t \n\ttg->funcs->get_optc_source(tg, &num_opps, &opp_id_src0, &opp_id_src1);\n\n\tif (opp_id_src0 >= dc->res_pool->res_cap->num_opp) {\n\t\tASSERT(false);\n\t\treturn;\n\t}\n\topp = dc->res_pool->opps[opp_id_src0];\n\n\t \n\tif (opp->funcs->dpg_is_blanked && opp->funcs->dpg_is_blanked(opp))\n\t\treturn;\n\n\tif (num_opps == 2) {\n\t\totg_active_width = otg_active_width / 2;\n\n\t\tif (opp_id_src1 >= dc->res_pool->res_cap->num_opp) {\n\t\t\tASSERT(false);\n\t\t\treturn;\n\t\t}\n\t\tbottom_opp = dc->res_pool->opps[opp_id_src1];\n\t}\n\n\topp->funcs->opp_set_disp_pattern_generator(\n\t\t\topp,\n\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t&black_color,\n\t\t\totg_active_width,\n\t\t\totg_active_height,\n\t\t\t0);\n\n\tif (num_opps == 2) {\n\t\tbottom_opp->funcs->opp_set_disp_pattern_generator(\n\t\t\t\tbottom_opp,\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t\t&black_color,\n\t\t\t\totg_active_width,\n\t\t\t\totg_active_height,\n\t\t\t\t0);\n\t}\n\n\thws->funcs.wait_for_blank_complete(opp);\n}\n\nvoid dcn20_dsc_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dsc_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\treturn;\n\n\tif (REG(DOMAIN16_PG_CONFIG) == 0)\n\t\treturn;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\tswitch (dsc_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN16_PG_CONFIG,\n\t\t\t\tDOMAIN16_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN16_PG_STATUS,\n\t\t\t\tDOMAIN16_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN17_PG_CONFIG,\n\t\t\t\tDOMAIN17_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN17_PG_STATUS,\n\t\t\t\tDOMAIN17_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN18_PG_CONFIG,\n\t\t\t\tDOMAIN18_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN18_PG_STATUS,\n\t\t\t\tDOMAIN18_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN19_PG_CONFIG,\n\t\t\t\tDOMAIN19_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN19_PG_STATUS,\n\t\t\t\tDOMAIN19_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 4:  \n\t\tREG_UPDATE(DOMAIN20_PG_CONFIG,\n\t\t\t\tDOMAIN20_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN20_PG_STATUS,\n\t\t\t\tDOMAIN20_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 5:  \n\t\tREG_UPDATE(DOMAIN21_PG_CONFIG,\n\t\t\t\tDOMAIN21_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN21_PG_STATUS,\n\t\t\t\tDOMAIN21_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\nvoid dcn20_dpp_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dpp_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\n\tif (hws->ctx->dc->debug.disable_dpp_power_gate)\n\t\treturn;\n\tif (REG(DOMAIN1_PG_CONFIG) == 0)\n\t\treturn;\n\n\tswitch (dpp_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN1_PG_CONFIG,\n\t\t\t\tDOMAIN1_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN1_PG_STATUS,\n\t\t\t\tDOMAIN1_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN3_PG_CONFIG,\n\t\t\t\tDOMAIN3_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN3_PG_STATUS,\n\t\t\t\tDOMAIN3_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN5_PG_CONFIG,\n\t\t\t\tDOMAIN5_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN5_PG_STATUS,\n\t\t\t\tDOMAIN5_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN7_PG_CONFIG,\n\t\t\t\tDOMAIN7_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN7_PG_STATUS,\n\t\t\t\tDOMAIN7_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 4:  \n\t\tREG_UPDATE(DOMAIN9_PG_CONFIG,\n\t\t\t\tDOMAIN9_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN9_PG_STATUS,\n\t\t\t\tDOMAIN9_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 5:  \n\t\t \n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\n\nvoid dcn20_hubp_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int hubp_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\n\tif (hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\treturn;\n\tif (REG(DOMAIN0_PG_CONFIG) == 0)\n\t\treturn;\n\n\tswitch (hubp_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN0_PG_CONFIG,\n\t\t\t\tDOMAIN0_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN0_PG_STATUS,\n\t\t\t\tDOMAIN0_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN2_PG_CONFIG,\n\t\t\t\tDOMAIN2_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN2_PG_STATUS,\n\t\t\t\tDOMAIN2_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN4_PG_CONFIG,\n\t\t\t\tDOMAIN4_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN4_PG_STATUS,\n\t\t\t\tDOMAIN4_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN6_PG_CONFIG,\n\t\t\t\tDOMAIN6_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN6_PG_STATUS,\n\t\t\t\tDOMAIN6_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 4:  \n\t\tREG_UPDATE(DOMAIN8_PG_CONFIG,\n\t\t\t\tDOMAIN8_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN8_PG_STATUS,\n\t\t\t\tDOMAIN8_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 5:  \n\t\t \n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\n\n \nvoid dcn20_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\n\tdc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);\n\n\t \n\tif (pipe_ctx->stream_res.gsl_group != 0)\n\t\tdcn20_setup_gsl_group_as_lock(dc, pipe_ctx, false);\n\n\tif (hubp->funcs->hubp_update_mall_sel)\n\t\thubp->funcs->hubp_update_mall_sel(hubp, 0, false);\n\n\tdc->hwss.set_flip_control_gsl(pipe_ctx, false);\n\n\thubp->funcs->hubp_clk_cntl(hubp, false);\n\n\tdpp->funcs->dpp_dppclk_control(dpp, false, false);\n\n\thubp->power_gated = true;\n\n\thws->funcs.plane_atomic_power_down(dc,\n\t\t\tpipe_ctx->plane_res.dpp,\n\t\t\tpipe_ctx->plane_res.hubp);\n\n\tpipe_ctx->stream = NULL;\n\tmemset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));\n\tmemset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));\n\tpipe_ctx->top_pipe = NULL;\n\tpipe_ctx->bottom_pipe = NULL;\n\tpipe_ctx->plane_state = NULL;\n}\n\n\nvoid dcn20_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tbool is_phantom = pipe_ctx->plane_state && pipe_ctx->plane_state->is_phantom;\n\tstruct timing_generator *tg = is_phantom ? pipe_ctx->stream_res.tg : NULL;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)\n\t\treturn;\n\n\tdcn20_plane_atomic_disable(dc, pipe_ctx);\n\n\t \n\tif (is_phantom)\n\t\tif (tg && tg->funcs->disable_phantom_crtc)\n\t\t\ttg->funcs->disable_phantom_crtc(tg);\n\n\tDC_LOG_DC(\"Power down front end %d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx);\n}\n\nvoid dcn20_disable_pixel_data(struct dc *dc, struct pipe_ctx *pipe_ctx, bool blank)\n{\n\tdcn20_blank_pixel_data(dc, pipe_ctx, blank);\n}\n\nstatic int calc_mpc_flow_ctrl_cnt(const struct dc_stream_state *stream,\n\t\tint opp_cnt)\n{\n\tbool hblank_halved = optc2_is_two_pixels_per_containter(&stream->timing);\n\tint flow_ctrl_cnt;\n\n\tif (opp_cnt >= 2)\n\t\thblank_halved = true;\n\n\tflow_ctrl_cnt = stream->timing.h_total - stream->timing.h_addressable -\n\t\t\tstream->timing.h_border_left -\n\t\t\tstream->timing.h_border_right;\n\n\tif (hblank_halved)\n\t\tflow_ctrl_cnt /= 2;\n\n\t \n\tif (opp_cnt == 4)\n\t\tflow_ctrl_cnt /= 2;\n\n\treturn flow_ctrl_cnt;\n}\n\nenum dc_status dcn20_enable_stream_timing(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context,\n\t\tstruct dc *dc)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct drr_params params = {0};\n\tunsigned int event_triggers = 0;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\tint opp_inst[MAX_PIPES] = { pipe_ctx->stream_res.opp->inst };\n\tbool interlace = stream->timing.flags.INTERLACE;\n\tint i;\n\tstruct mpc_dwb_flow_control flow_control;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tbool rate_control_2x_pclk = (interlace || optc2_is_two_pixels_per_containter(&stream->timing));\n\tunsigned int k1_div = PIXEL_RATE_DIV_NA;\n\tunsigned int k2_div = PIXEL_RATE_DIV_NA;\n\n\tif (hws->funcs.calculate_dccg_k1_k2_values && dc->res_pool->dccg->funcs->set_pixel_rate_div) {\n\t\thws->funcs.calculate_dccg_k1_k2_values(pipe_ctx, &k1_div, &k2_div);\n\n\t\tdc->res_pool->dccg->funcs->set_pixel_rate_div(\n\t\t\tdc->res_pool->dccg,\n\t\t\tpipe_ctx->stream_res.tg->inst,\n\t\t\tk1_div, k2_div);\n\t}\n\t \n\tif (pipe_ctx->top_pipe != NULL)\n\t\treturn DC_OK;\n\n\t \n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\topp_inst[opp_cnt] = odm_pipe->stream_res.opp->inst;\n\t\topp_cnt++;\n\t}\n\n\tif (opp_cnt > 1)\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\topp_inst, opp_cnt,\n\t\t\t\t&pipe_ctx->stream->timing);\n\n\t \n\tpipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, true);\n\n\tif (false == pipe_ctx->clock_source->funcs->program_pix_clk(\n\t\t\tpipe_ctx->clock_source,\n\t\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t\tdc->link_srv->dp_get_encoding_format(&pipe_ctx->link_config.dp_link_settings),\n\t\t\t&pipe_ctx->pll_settings)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tif (dc_is_hdmi_tmds_signal(stream->signal)) {\n\t\tstream->link->phy_state.symclk_ref_cnts.otg = 1;\n\t\tif (stream->link->phy_state.symclk_state == SYMCLK_OFF_TX_OFF)\n\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_OFF;\n\t\telse\n\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n\t}\n\n\tif (dc->hwseq->funcs.PLAT_58856_wa && (!dc_is_dp_signal(stream->signal)))\n\t\tdc->hwseq->funcs.PLAT_58856_wa(context, pipe_ctx);\n\n\tpipe_ctx->stream_res.tg->funcs->program_timing(\n\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t&stream->timing,\n\t\t\tpipe_ctx->pipe_dlg_param.vready_offset,\n\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start,\n\t\t\tpipe_ctx->pipe_dlg_param.vupdate_offset,\n\t\t\tpipe_ctx->pipe_dlg_param.vupdate_width,\n\t\t\tpipe_ctx->stream->signal,\n\t\t\ttrue);\n\n\trate_control_2x_pclk = rate_control_2x_pclk || opp_cnt > 1;\n\tflow_control.flow_ctrl_mode = 0;\n\tflow_control.flow_ctrl_cnt0 = 0x80;\n\tflow_control.flow_ctrl_cnt1 = calc_mpc_flow_ctrl_cnt(stream, opp_cnt);\n\tif (mpc->funcs->set_out_rate_control) {\n\t\tfor (i = 0; i < opp_cnt; ++i) {\n\t\t\tmpc->funcs->set_out_rate_control(\n\t\t\t\t\tmpc, opp_inst[i],\n\t\t\t\t\ttrue,\n\t\t\t\t\trate_control_2x_pclk,\n\t\t\t\t\t&flow_control);\n\t\t}\n\t}\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\todm_pipe->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\t\todm_pipe->stream_res.opp,\n\t\t\t\ttrue);\n\n\tpipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\ttrue);\n\n\thws->funcs.blank_pixel_data(dc, pipe_ctx, true);\n\n\t \n\tif (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(pipe_ctx->stream_res.tg)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\thws->funcs.wait_for_blank_complete(pipe_ctx->stream_res.opp);\n\n\tparams.vertical_total_min = stream->adjust.v_total_min;\n\tparams.vertical_total_max = stream->adjust.v_total_max;\n\tparams.vertical_total_mid = stream->adjust.v_total_mid;\n\tparams.vertical_total_mid_frame_num = stream->adjust.v_total_mid_frame_num;\n\tif (pipe_ctx->stream_res.tg->funcs->set_drr)\n\t\tpipe_ctx->stream_res.tg->funcs->set_drr(\n\t\t\tpipe_ctx->stream_res.tg, &params);\n\n\t\n\tif (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)\n\t\tevent_triggers = 0x80;\n\t \n\tif (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)\n\t\tpipe_ctx->stream_res.tg->funcs->set_static_screen_control(\n\t\t\t\tpipe_ctx->stream_res.tg, event_triggers, 2);\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\tif (pipe_ctx->stream && pipe_ctx->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\tif (pipe_ctx->stream_res.tg && pipe_ctx->stream_res.tg->funcs->phantom_crtc_post_enable)\n\t\t\tpipe_ctx->stream_res.tg->funcs->phantom_crtc_post_enable(pipe_ctx->stream_res.tg);\n\t}\n\treturn DC_OK;\n}\n\nvoid dcn20_program_output_csc(struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tenum dc_color_space colorspace,\n\t\tuint16_t *matrix,\n\t\tint opp_id)\n{\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tenum mpc_output_csc_mode ocsc_mode = MPC_OUTPUT_CSC_COEF_A;\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\n\tif (mpc->funcs->power_on_mpc_mem_pwr)\n\t\tmpc->funcs->power_on_mpc_mem_pwr(mpc, mpcc_id, true);\n\n\tif (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {\n\t\tif (mpc->funcs->set_output_csc != NULL)\n\t\t\tmpc->funcs->set_output_csc(mpc,\n\t\t\t\t\topp_id,\n\t\t\t\t\tmatrix,\n\t\t\t\t\tocsc_mode);\n\t} else {\n\t\tif (mpc->funcs->set_ocsc_default != NULL)\n\t\t\tmpc->funcs->set_ocsc_default(mpc,\n\t\t\t\t\topp_id,\n\t\t\t\t\tcolorspace,\n\t\t\t\t\tocsc_mode);\n\t}\n}\n\nbool dcn20_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_stream_state *stream)\n{\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tstruct pwl_params *params = NULL;\n\t \n\tif (mpc->funcs->power_on_mpc_mem_pwr)\n\t\tmpc->funcs->power_on_mpc_mem_pwr(mpc, mpcc_id, true);\n\tif (pipe_ctx->top_pipe == NULL\n\t\t\t&& mpc->funcs->set_output_gamma && stream->out_transfer_func) {\n\t\tif (stream->out_transfer_func->type == TF_TYPE_HWPWL)\n\t\t\tparams = &stream->out_transfer_func->pwl;\n\t\telse if (pipe_ctx->stream->out_transfer_func->type ==\n\t\t\tTF_TYPE_DISTRIBUTED_POINTS &&\n\t\t\tcm_helper_translate_curve_to_hw_format(dc->ctx,\n\t\t\tstream->out_transfer_func,\n\t\t\t&mpc->blender_params, false))\n\t\t\tparams = &mpc->blender_params;\n\t\t \n\t\tif (stream->out_transfer_func->type == TF_TYPE_PREDEFINED)\n\t\t\tBREAK_TO_DEBUGGER();\n\t}\n\t \n\tmpc->funcs->set_output_gamma(mpc, mpcc_id, params);\n\n\treturn true;\n}\n\nbool dcn20_set_blend_lut(\n\tstruct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tbool result = true;\n\tstruct pwl_params *blend_lut = NULL;\n\n\tif (plane_state->blend_tf) {\n\t\tif (plane_state->blend_tf->type == TF_TYPE_HWPWL)\n\t\t\tblend_lut = &plane_state->blend_tf->pwl;\n\t\telse if (plane_state->blend_tf->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm_helper_translate_curve_to_hw_format(plane_state->ctx,\n\t\t\t\t\tplane_state->blend_tf,\n\t\t\t\t\t&dpp_base->regamma_params, false);\n\t\t\tblend_lut = &dpp_base->regamma_params;\n\t\t}\n\t}\n\tresult = dpp_base->funcs->dpp_program_blnd_lut(dpp_base, blend_lut);\n\n\treturn result;\n}\n\nbool dcn20_set_shaper_3dlut(\n\tstruct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tbool result = true;\n\tstruct pwl_params *shaper_lut = NULL;\n\n\tif (plane_state->in_shaper_func) {\n\t\tif (plane_state->in_shaper_func->type == TF_TYPE_HWPWL)\n\t\t\tshaper_lut = &plane_state->in_shaper_func->pwl;\n\t\telse if (plane_state->in_shaper_func->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm_helper_translate_curve_to_hw_format(plane_state->ctx,\n\t\t\t\t\tplane_state->in_shaper_func,\n\t\t\t\t\t&dpp_base->shaper_params, true);\n\t\t\tshaper_lut = &dpp_base->shaper_params;\n\t\t}\n\t}\n\n\tresult = dpp_base->funcs->dpp_program_shaper_lut(dpp_base, shaper_lut);\n\tif (plane_state->lut3d_func &&\n\t\tplane_state->lut3d_func->state.bits.initialized == 1)\n\t\tresult = dpp_base->funcs->dpp_program_3dlut(dpp_base,\n\t\t\t\t\t\t\t\t&plane_state->lut3d_func->lut_3d);\n\telse\n\t\tresult = dpp_base->funcs->dpp_program_3dlut(dpp_base, NULL);\n\n\treturn result;\n}\n\nbool dcn20_set_input_transfer_func(struct dc *dc,\n\t\t\t\tstruct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_plane_state *plane_state)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tconst struct dc_transfer_func *tf = NULL;\n\tbool result = true;\n\tbool use_degamma_ram = false;\n\n\tif (dpp_base == NULL || plane_state == NULL)\n\t\treturn false;\n\n\thws->funcs.set_shaper_3dlut(pipe_ctx, plane_state);\n\thws->funcs.set_blend_lut(pipe_ctx, plane_state);\n\n\tif (plane_state->in_transfer_func)\n\t\ttf = plane_state->in_transfer_func;\n\n\n\tif (tf == NULL) {\n\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\tIPP_DEGAMMA_MODE_BYPASS);\n\t\treturn true;\n\t}\n\n\tif (tf->type == TF_TYPE_HWPWL || tf->type == TF_TYPE_DISTRIBUTED_POINTS)\n\t\tuse_degamma_ram = true;\n\n\tif (use_degamma_ram == true) {\n\t\tif (tf->type == TF_TYPE_HWPWL)\n\t\t\tdpp_base->funcs->dpp_program_degamma_pwl(dpp_base,\n\t\t\t\t\t&tf->pwl);\n\t\telse if (tf->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm_helper_translate_curve_to_degamma_hw_format(tf,\n\t\t\t\t\t&dpp_base->degamma_params);\n\t\t\tdpp_base->funcs->dpp_program_degamma_pwl(dpp_base,\n\t\t\t\t&dpp_base->degamma_params);\n\t\t}\n\t\treturn true;\n\t}\n\t \n\tif (tf->type == TF_TYPE_PREDEFINED) {\n\t\tswitch (tf->tf) {\n\t\tcase TRANSFER_FUNCTION_SRGB:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\t\tIPP_DEGAMMA_MODE_HW_sRGB);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_BT709:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\t\tIPP_DEGAMMA_MODE_HW_xvYCC);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_LINEAR:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\t\tIPP_DEGAMMA_MODE_BYPASS);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_PQ:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_USER_PWL);\n\t\t\tcm_helper_translate_curve_to_degamma_hw_format(tf, &dpp_base->degamma_params);\n\t\t\tdpp_base->funcs->dpp_program_degamma_pwl(dpp_base, &dpp_base->degamma_params);\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t} else if (tf->type == TF_TYPE_BYPASS)\n\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\tIPP_DEGAMMA_MODE_BYPASS);\n\telse {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\tdpp_base->funcs->dpp_set_degamma(dpp_base,\n\t\t\t\tIPP_DEGAMMA_MODE_BYPASS);\n\t}\n\n\treturn result;\n}\n\nvoid dcn20_update_odm(struct dc *dc, struct dc_state *context, struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\tint opp_inst[MAX_PIPES] = { pipe_ctx->stream_res.opp->inst };\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\topp_inst[opp_cnt] = odm_pipe->stream_res.opp->inst;\n\t\topp_cnt++;\n\t}\n\n\tif (opp_cnt > 1)\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\topp_inst, opp_cnt,\n\t\t\t\t&pipe_ctx->stream->timing);\n\telse\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_bypass(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);\n}\n\nvoid dcn20_blank_pixel_data(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool blank)\n{\n\tstruct tg_color black_color = {0};\n\tstruct stream_resource *stream_res = &pipe_ctx->stream_res;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tenum dc_color_space color_space = stream->output_color_space;\n\tenum controller_dp_test_pattern test_pattern = CONTROLLER_DP_TEST_PATTERN_SOLID_COLOR;\n\tenum controller_dp_color_space test_pattern_color_space = CONTROLLER_DP_COLOR_SPACE_UDEFINED;\n\tstruct pipe_ctx *odm_pipe;\n\tint odm_cnt = 1;\n\tint h_active = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;\n\tint v_active = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;\n\tint odm_slice_width, last_odm_slice_width, offset = 0;\n\n\tif (stream->link->test_pattern_enabled)\n\t\treturn;\n\n\t \n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\todm_cnt++;\n\todm_slice_width = h_active / odm_cnt;\n\tlast_odm_slice_width = h_active - odm_slice_width * (odm_cnt - 1);\n\n\tif (blank) {\n\t\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\n\t\tif (dc->debug.visual_confirm != VISUAL_CONFIRM_DISABLE) {\n\t\t\ttest_pattern = CONTROLLER_DP_TEST_PATTERN_COLORSQUARES;\n\t\t\ttest_pattern_color_space = CONTROLLER_DP_COLOR_SPACE_RGB;\n\t\t}\n\t} else {\n\t\ttest_pattern = CONTROLLER_DP_TEST_PATTERN_VIDEOMODE;\n\t}\n\n\todm_pipe = pipe_ctx;\n\n\twhile (odm_pipe->next_odm_pipe) {\n\t\tdc->hwss.set_disp_pattern_generator(dc,\n\t\t\t\todm_pipe,\n\t\t\t\ttest_pattern,\n\t\t\t\ttest_pattern_color_space,\n\t\t\t\tstream->timing.display_color_depth,\n\t\t\t\t&black_color,\n\t\t\t\todm_slice_width,\n\t\t\t\tv_active,\n\t\t\t\toffset);\n\t\toffset += odm_slice_width;\n\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t}\n\n\tdc->hwss.set_disp_pattern_generator(dc,\n\t\t\todm_pipe,\n\t\t\ttest_pattern,\n\t\t\ttest_pattern_color_space,\n\t\t\tstream->timing.display_color_depth,\n\t\t\t&black_color,\n\t\t\tlast_odm_slice_width,\n\t\t\tv_active,\n\t\t\toffset);\n\n\tif (!blank)\n\t\tif (stream_res->abm) {\n\t\t\tdc->hwss.set_pipe(pipe_ctx);\n\t\t\tstream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);\n\t\t}\n}\n\n\nstatic void dcn20_power_on_plane_resources(\n\tstruct dce_hwseq *hws,\n\tstruct pipe_ctx *pipe_ctx)\n{\n\tDC_LOGGER_INIT(hws->ctx->logger);\n\n\tif (hws->funcs.dpp_root_clock_control)\n\t\thws->funcs.dpp_root_clock_control(hws, pipe_ctx->plane_res.dpp->inst, true);\n\n\tif (REG(DC_IP_REQUEST_CNTL)) {\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 1);\n\n\t\tif (hws->funcs.dpp_pg_control)\n\t\t\thws->funcs.dpp_pg_control(hws, pipe_ctx->plane_res.dpp->inst, true);\n\n\t\tif (hws->funcs.hubp_pg_control)\n\t\t\thws->funcs.hubp_pg_control(hws, pipe_ctx->plane_res.hubp->inst, true);\n\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 0);\n\t\tDC_LOG_DEBUG(\n\t\t\t\t\"Un-gated front end for pipe %d\\n\", pipe_ctx->plane_res.hubp->inst);\n\t}\n}\n\nstatic void dcn20_enable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\t       struct dc_state *context)\n{\n\t\n\t\n\t\n\tdcn20_power_on_plane_resources(dc->hwseq, pipe_ctx);\n\n\t \n\tpipe_ctx->plane_res.hubp->funcs->hubp_clk_cntl(pipe_ctx->plane_res.hubp, true);\n\n\t \n\tpipe_ctx->plane_res.hubp->funcs->hubp_init(pipe_ctx->plane_res.hubp);\n\n\t \n\tpipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\ttrue);\n\n \n\tif (dc->vm_pa_config.valid) {\n\t\tstruct vm_system_aperture_param apt;\n\n\t\tapt.sys_default.quad_part = 0;\n\n\t\tapt.sys_low.quad_part = dc->vm_pa_config.system_aperture.start_addr;\n\t\tapt.sys_high.quad_part = dc->vm_pa_config.system_aperture.end_addr;\n\n\t\t\n\t\tpipe_ctx->plane_res.hubp->funcs->hubp_set_vm_system_aperture_settings(pipe_ctx->plane_res.hubp, &apt);\n\t}\n\n\tif (!pipe_ctx->top_pipe\n\t\t&& pipe_ctx->plane_state\n\t\t&& pipe_ctx->plane_state->flip_int_enabled\n\t\t&& pipe_ctx->plane_res.hubp->funcs->hubp_set_flip_int)\n\t\t\tpipe_ctx->plane_res.hubp->funcs->hubp_set_flip_int(pipe_ctx->plane_res.hubp);\n\n\n\n\n}\n\nvoid dcn20_pipe_control_lock(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe,\n\tbool lock)\n{\n\tstruct pipe_ctx *temp_pipe;\n\tbool flip_immediate = false;\n\n\t \n\tif (!pipe || pipe->top_pipe)\n\t\treturn;\n\n\tif (pipe->plane_state != NULL)\n\t\tflip_immediate = pipe->plane_state->flip_immediate;\n\n\tif  (pipe->stream_res.gsl_group > 0) {\n\t    temp_pipe = pipe->bottom_pipe;\n\t    while (!flip_immediate && temp_pipe) {\n\t\t    if (temp_pipe->plane_state != NULL)\n\t\t\t    flip_immediate = temp_pipe->plane_state->flip_immediate;\n\t\t    temp_pipe = temp_pipe->bottom_pipe;\n\t    }\n\t}\n\n\tif (flip_immediate && lock) {\n\t\tconst int TIMEOUT_FOR_FLIP_PENDING_US = 100000;\n\t\tunsigned int polling_interval_us = 1;\n\t\tint i;\n\n\t\ttemp_pipe = pipe;\n\t\twhile (temp_pipe) {\n\t\t\tif (temp_pipe->plane_state && temp_pipe->plane_state->flip_immediate) {\n\t\t\t\tfor (i = 0; i < TIMEOUT_FOR_FLIP_PENDING_US / polling_interval_us; ++i) {\n\t\t\t\t\tif (!temp_pipe->plane_res.hubp->funcs->hubp_is_flip_pending(temp_pipe->plane_res.hubp))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tudelay(polling_interval_us);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tASSERT(i != TIMEOUT_FOR_FLIP_PENDING_US);\n\t\t\t}\n\t\t\ttemp_pipe = temp_pipe->bottom_pipe;\n\t\t}\n\t}\n\n\t \n\tif (lock && (pipe->bottom_pipe != NULL || !flip_immediate))\n\t\tif ((flip_immediate && pipe->stream_res.gsl_group == 0) ||\n\t\t    (!flip_immediate && pipe->stream_res.gsl_group > 0))\n\t\t\tdcn20_setup_gsl_group_as_lock(dc, pipe, flip_immediate);\n\n\tif (pipe->plane_state != NULL)\n\t\tflip_immediate = pipe->plane_state->flip_immediate;\n\n\ttemp_pipe = pipe->bottom_pipe;\n\twhile (flip_immediate && temp_pipe) {\n\t    if (temp_pipe->plane_state != NULL)\n\t\tflip_immediate = temp_pipe->plane_state->flip_immediate;\n\t    temp_pipe = temp_pipe->bottom_pipe;\n\t}\n\n\tif (!lock && pipe->stream_res.gsl_group > 0 && pipe->plane_state &&\n\t\t!flip_immediate)\n\t    dcn20_setup_gsl_group_as_lock(dc, pipe, false);\n\n\tif (pipe->stream && should_use_dmub_lock(pipe->stream->link)) {\n\t\tunion dmub_hw_lock_flags hw_locks = { 0 };\n\t\tstruct dmub_hw_lock_inst_flags inst_flags = { 0 };\n\n\t\thw_locks.bits.lock_pipe = 1;\n\t\tinst_flags.otg_inst =  pipe->stream_res.tg->inst;\n\n\t\tif (pipe->plane_state != NULL)\n\t\t\thw_locks.bits.triple_buffer_lock = pipe->plane_state->triplebuffer_flips;\n\n\t\tdmub_hw_lock_mgr_cmd(dc->ctx->dmub_srv,\n\t\t\t\t\tlock,\n\t\t\t\t\t&hw_locks,\n\t\t\t\t\t&inst_flags);\n\t} else if (pipe->plane_state != NULL && pipe->plane_state->triplebuffer_flips) {\n\t\tif (lock)\n\t\t\tpipe->stream_res.tg->funcs->triplebuffer_lock(pipe->stream_res.tg);\n\t\telse\n\t\t\tpipe->stream_res.tg->funcs->triplebuffer_unlock(pipe->stream_res.tg);\n\t} else {\n\t\tif (lock)\n\t\t\tpipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);\n\t\telse\n\t\t\tpipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);\n\t}\n}\n\nstatic void dcn20_detect_pipe_changes(struct pipe_ctx *old_pipe, struct pipe_ctx *new_pipe)\n{\n\tnew_pipe->update_flags.raw = 0;\n\n\t \n\tif (old_pipe->plane_state && !old_pipe->plane_state->is_phantom &&\n\t\t\tnew_pipe->plane_state && new_pipe->plane_state->is_phantom) {\n\t\tnew_pipe->update_flags.bits.disable = 1;\n\t\treturn;\n\t}\n\n\t \n\tif (!old_pipe->plane_state && !new_pipe->plane_state)\n\t\treturn;\n\t \n\tif (!old_pipe->plane_state && new_pipe->plane_state) {\n\t\tnew_pipe->update_flags.bits.enable = 1;\n\t\tnew_pipe->update_flags.bits.mpcc = 1;\n\t\tnew_pipe->update_flags.bits.dppclk = 1;\n\t\tnew_pipe->update_flags.bits.hubp_interdependent = 1;\n\t\tnew_pipe->update_flags.bits.hubp_rq_dlg_ttu = 1;\n\t\tnew_pipe->update_flags.bits.unbounded_req = 1;\n\t\tnew_pipe->update_flags.bits.gamut_remap = 1;\n\t\tnew_pipe->update_flags.bits.scaler = 1;\n\t\tnew_pipe->update_flags.bits.viewport = 1;\n\t\tnew_pipe->update_flags.bits.det_size = 1;\n\t\tif (!new_pipe->top_pipe && !new_pipe->prev_odm_pipe) {\n\t\t\tnew_pipe->update_flags.bits.odm = 1;\n\t\t\tnew_pipe->update_flags.bits.global_sync = 1;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (new_pipe->stream && new_pipe->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\tnew_pipe->update_flags.bits.enable = 1;\n\n\t \n\tif (old_pipe->plane_state && old_pipe->plane_state->is_phantom &&\n\t\t\tnew_pipe->plane_state && !new_pipe->plane_state->is_phantom)\n\t\tnew_pipe->update_flags.bits.enable = 1;\n\n\tif (old_pipe->plane_state && !new_pipe->plane_state) {\n\t\tnew_pipe->update_flags.bits.disable = 1;\n\t\treturn;\n\t}\n\n\t \n\tif (old_pipe->plane_state != new_pipe->plane_state) {\n\t\tnew_pipe->update_flags.bits.plane_changed = true;\n\t}\n\n\t \n\tif (!new_pipe->top_pipe && !new_pipe->prev_odm_pipe) {\n\t\t \n\t\tif ((old_pipe->next_odm_pipe && new_pipe->next_odm_pipe\n\t\t\t&& old_pipe->next_odm_pipe->pipe_idx != new_pipe->next_odm_pipe->pipe_idx)\n\t\t\t\t|| (!old_pipe->next_odm_pipe && new_pipe->next_odm_pipe)\n\t\t\t\t|| (old_pipe->next_odm_pipe && !new_pipe->next_odm_pipe)\n\t\t\t\t|| old_pipe->stream_res.opp != new_pipe->stream_res.opp)\n\t\t\tnew_pipe->update_flags.bits.odm = 1;\n\n\t\t \n\t\tif (old_pipe->pipe_dlg_param.vready_offset != new_pipe->pipe_dlg_param.vready_offset\n\t\t\t\t|| old_pipe->pipe_dlg_param.vstartup_start != new_pipe->pipe_dlg_param.vstartup_start\n\t\t\t\t|| old_pipe->pipe_dlg_param.vupdate_offset != new_pipe->pipe_dlg_param.vupdate_offset\n\t\t\t\t|| old_pipe->pipe_dlg_param.vupdate_width != new_pipe->pipe_dlg_param.vupdate_width)\n\t\t\tnew_pipe->update_flags.bits.global_sync = 1;\n\t}\n\n\tif (old_pipe->det_buffer_size_kb != new_pipe->det_buffer_size_kb)\n\t\tnew_pipe->update_flags.bits.det_size = 1;\n\n\t \n\tif (old_pipe->stream_res.opp != new_pipe->stream_res.opp)\n\t\tnew_pipe->update_flags.bits.opp_changed = 1;\n\tif (old_pipe->stream_res.tg != new_pipe->stream_res.tg)\n\t\tnew_pipe->update_flags.bits.tg_changed = 1;\n\n\t \n\tif (old_pipe->plane_res.dpp != new_pipe->plane_res.dpp\n\t\t\t|| old_pipe->stream_res.opp != new_pipe->stream_res.opp)\n\t\tnew_pipe->update_flags.bits.mpcc = 1;\n\n\t \n\tif (old_pipe->plane_res.bw.dppclk_khz != new_pipe->plane_res.bw.dppclk_khz)\n\t\tnew_pipe->update_flags.bits.dppclk = 1;\n\n\t \n\tif (memcmp(&old_pipe->plane_res.scl_data, &new_pipe->plane_res.scl_data, sizeof(struct scaler_data)))\n\t\t\tnew_pipe->update_flags.bits.scaler = 1;\n\t \n\tif (memcmp(&old_pipe->plane_res.scl_data.viewport, &new_pipe->plane_res.scl_data.viewport, sizeof(struct rect))\n\t\t\t|| memcmp(&old_pipe->plane_res.scl_data.viewport_c,\n\t\t\t\t&new_pipe->plane_res.scl_data.viewport_c, sizeof(struct rect)))\n\t\tnew_pipe->update_flags.bits.viewport = 1;\n\n\t \n\t{\n\t\tstruct _vcs_dpi_display_dlg_regs_st old_dlg_attr = old_pipe->dlg_regs;\n\t\tstruct _vcs_dpi_display_ttu_regs_st old_ttu_attr = old_pipe->ttu_regs;\n\t\tstruct _vcs_dpi_display_dlg_regs_st *new_dlg_attr = &new_pipe->dlg_regs;\n\t\tstruct _vcs_dpi_display_ttu_regs_st *new_ttu_attr = &new_pipe->ttu_regs;\n\n\t\t \n\t\tif (old_dlg_attr.dst_y_prefetch != new_dlg_attr->dst_y_prefetch ||\n\t\t\t\told_dlg_attr.vratio_prefetch != new_dlg_attr->vratio_prefetch ||\n\t\t\t\told_dlg_attr.vratio_prefetch_c != new_dlg_attr->vratio_prefetch_c ||\n\t\t\t\told_dlg_attr.dst_y_per_vm_vblank != new_dlg_attr->dst_y_per_vm_vblank ||\n\t\t\t\told_dlg_attr.dst_y_per_row_vblank != new_dlg_attr->dst_y_per_row_vblank ||\n\t\t\t\told_dlg_attr.dst_y_per_vm_flip != new_dlg_attr->dst_y_per_vm_flip ||\n\t\t\t\told_dlg_attr.dst_y_per_row_flip != new_dlg_attr->dst_y_per_row_flip ||\n\t\t\t\told_dlg_attr.refcyc_per_meta_chunk_vblank_l != new_dlg_attr->refcyc_per_meta_chunk_vblank_l ||\n\t\t\t\told_dlg_attr.refcyc_per_meta_chunk_vblank_c != new_dlg_attr->refcyc_per_meta_chunk_vblank_c ||\n\t\t\t\told_dlg_attr.refcyc_per_meta_chunk_flip_l != new_dlg_attr->refcyc_per_meta_chunk_flip_l ||\n\t\t\t\told_dlg_attr.refcyc_per_line_delivery_pre_l != new_dlg_attr->refcyc_per_line_delivery_pre_l ||\n\t\t\t\told_dlg_attr.refcyc_per_line_delivery_pre_c != new_dlg_attr->refcyc_per_line_delivery_pre_c ||\n\t\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_l != new_ttu_attr->refcyc_per_req_delivery_pre_l ||\n\t\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_c != new_ttu_attr->refcyc_per_req_delivery_pre_c ||\n\t\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_cur0 != new_ttu_attr->refcyc_per_req_delivery_pre_cur0 ||\n\t\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_cur1 != new_ttu_attr->refcyc_per_req_delivery_pre_cur1 ||\n\t\t\t\told_ttu_attr.min_ttu_vblank != new_ttu_attr->min_ttu_vblank ||\n\t\t\t\told_ttu_attr.qos_level_flip != new_ttu_attr->qos_level_flip) {\n\t\t\told_dlg_attr.dst_y_prefetch = new_dlg_attr->dst_y_prefetch;\n\t\t\told_dlg_attr.vratio_prefetch = new_dlg_attr->vratio_prefetch;\n\t\t\told_dlg_attr.vratio_prefetch_c = new_dlg_attr->vratio_prefetch_c;\n\t\t\told_dlg_attr.dst_y_per_vm_vblank = new_dlg_attr->dst_y_per_vm_vblank;\n\t\t\told_dlg_attr.dst_y_per_row_vblank = new_dlg_attr->dst_y_per_row_vblank;\n\t\t\told_dlg_attr.dst_y_per_vm_flip = new_dlg_attr->dst_y_per_vm_flip;\n\t\t\told_dlg_attr.dst_y_per_row_flip = new_dlg_attr->dst_y_per_row_flip;\n\t\t\told_dlg_attr.refcyc_per_meta_chunk_vblank_l = new_dlg_attr->refcyc_per_meta_chunk_vblank_l;\n\t\t\told_dlg_attr.refcyc_per_meta_chunk_vblank_c = new_dlg_attr->refcyc_per_meta_chunk_vblank_c;\n\t\t\told_dlg_attr.refcyc_per_meta_chunk_flip_l = new_dlg_attr->refcyc_per_meta_chunk_flip_l;\n\t\t\told_dlg_attr.refcyc_per_line_delivery_pre_l = new_dlg_attr->refcyc_per_line_delivery_pre_l;\n\t\t\told_dlg_attr.refcyc_per_line_delivery_pre_c = new_dlg_attr->refcyc_per_line_delivery_pre_c;\n\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_l = new_ttu_attr->refcyc_per_req_delivery_pre_l;\n\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_c = new_ttu_attr->refcyc_per_req_delivery_pre_c;\n\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_cur0 = new_ttu_attr->refcyc_per_req_delivery_pre_cur0;\n\t\t\told_ttu_attr.refcyc_per_req_delivery_pre_cur1 = new_ttu_attr->refcyc_per_req_delivery_pre_cur1;\n\t\t\told_ttu_attr.min_ttu_vblank = new_ttu_attr->min_ttu_vblank;\n\t\t\told_ttu_attr.qos_level_flip = new_ttu_attr->qos_level_flip;\n\t\t\tnew_pipe->update_flags.bits.hubp_interdependent = 1;\n\t\t}\n\t\t \n\t\tif (memcmp(&old_dlg_attr, &new_pipe->dlg_regs, sizeof(old_dlg_attr)) ||\n\t\t\t\tmemcmp(&old_ttu_attr, &new_pipe->ttu_regs, sizeof(old_ttu_attr)) ||\n\t\t\t\tmemcmp(&old_pipe->rq_regs, &new_pipe->rq_regs, sizeof(old_pipe->rq_regs)))\n\t\t\tnew_pipe->update_flags.bits.hubp_rq_dlg_ttu = 1;\n\t}\n\n\tif (old_pipe->unbounded_req != new_pipe->unbounded_req)\n\t\tnew_pipe->update_flags.bits.unbounded_req = 1;\n}\n\nstatic void dcn20_update_dchubp_dpp(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe_ctx,\n\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct dccg *dccg = dc->res_pool->dccg;\n\tbool viewport_changed = false;\n\n\tif (pipe_ctx->update_flags.bits.dppclk)\n\t\tdpp->funcs->dpp_dppclk_control(dpp, false, true);\n\n\tif (pipe_ctx->update_flags.bits.enable)\n\t\tdccg->funcs->update_dpp_dto(dccg, dpp->inst, pipe_ctx->plane_res.bw.dppclk_khz);\n\n\t \n\tif (pipe_ctx->update_flags.bits.hubp_rq_dlg_ttu) {\n\t\thubp->funcs->hubp_vtg_sel(hubp, pipe_ctx->stream_res.tg->inst);\n\n\t\thubp->funcs->hubp_setup(\n\t\t\thubp,\n\t\t\t&pipe_ctx->dlg_regs,\n\t\t\t&pipe_ctx->ttu_regs,\n\t\t\t&pipe_ctx->rq_regs,\n\t\t\t&pipe_ctx->pipe_dlg_param);\n\t}\n\n\tif (pipe_ctx->update_flags.bits.unbounded_req && hubp->funcs->set_unbounded_requesting)\n\t\thubp->funcs->set_unbounded_requesting(hubp, pipe_ctx->unbounded_req);\n\n\tif (pipe_ctx->update_flags.bits.hubp_interdependent)\n\t\thubp->funcs->hubp_setup_interdependent(\n\t\t\thubp,\n\t\t\t&pipe_ctx->dlg_regs,\n\t\t\t&pipe_ctx->ttu_regs);\n\n\tif (pipe_ctx->update_flags.bits.enable ||\n\t\t\tpipe_ctx->update_flags.bits.plane_changed ||\n\t\t\tplane_state->update_flags.bits.bpp_change ||\n\t\t\tplane_state->update_flags.bits.input_csc_change ||\n\t\t\tplane_state->update_flags.bits.color_space_change ||\n\t\t\tplane_state->update_flags.bits.coeff_reduction_change) {\n\t\tstruct dc_bias_and_scale bns_params = {0};\n\n\t\t\n\t\tdpp->funcs->dpp_setup(dpp,\n\t\t\t\tplane_state->format,\n\t\t\t\tEXPANSION_MODE_ZERO,\n\t\t\t\tplane_state->input_csc_color_matrix,\n\t\t\t\tplane_state->color_space,\n\t\t\t\tNULL);\n\n\t\tif (dpp->funcs->dpp_program_bias_and_scale) {\n\t\t\t\n\t\t\tbuild_prescale_params(&bns_params, plane_state);\n\t\t\tdpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);\n\t\t}\n\t}\n\n\tif (pipe_ctx->update_flags.bits.mpcc\n\t\t\t|| pipe_ctx->update_flags.bits.plane_changed\n\t\t\t|| plane_state->update_flags.bits.global_alpha_change\n\t\t\t|| plane_state->update_flags.bits.per_pixel_alpha_change) {\n\t\t\n\t\thws->funcs.update_mpcc(dc, pipe_ctx);\n\t}\n\n\tif (pipe_ctx->update_flags.bits.scaler ||\n\t\t\tplane_state->update_flags.bits.scaling_change ||\n\t\t\tplane_state->update_flags.bits.position_change ||\n\t\t\tplane_state->update_flags.bits.per_pixel_alpha_change ||\n\t\t\tpipe_ctx->stream->update_flags.bits.scaling) {\n\t\tpipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->plane_state->per_pixel_alpha;\n\t\tASSERT(pipe_ctx->plane_res.scl_data.lb_params.depth == LB_PIXEL_DEPTH_36BPP);\n\t\t \n\t\tpipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(\n\t\t\t\tpipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);\n\t}\n\n\tif (pipe_ctx->update_flags.bits.viewport ||\n\t\t\t(context == dc->current_state && plane_state->update_flags.bits.position_change) ||\n\t\t\t(context == dc->current_state && plane_state->update_flags.bits.scaling_change) ||\n\t\t\t(context == dc->current_state && pipe_ctx->stream->update_flags.bits.scaling)) {\n\n\t\thubp->funcs->mem_program_viewport(\n\t\t\thubp,\n\t\t\t&pipe_ctx->plane_res.scl_data.viewport,\n\t\t\t&pipe_ctx->plane_res.scl_data.viewport_c);\n\t\tviewport_changed = true;\n\t}\n\n\t \n\tif ((pipe_ctx->update_flags.bits.enable || pipe_ctx->update_flags.bits.opp_changed ||\n\t\t\tpipe_ctx->update_flags.bits.scaler || viewport_changed == true) &&\n\t\t\tpipe_ctx->stream->cursor_attributes.address.quad_part != 0) {\n\t\tdc->hwss.set_cursor_position(pipe_ctx);\n\t\tdc->hwss.set_cursor_attribute(pipe_ctx);\n\n\t\tif (dc->hwss.set_cursor_sdr_white_level)\n\t\t\tdc->hwss.set_cursor_sdr_white_level(pipe_ctx);\n\t}\n\n\t \n\tif (pipe_ctx->update_flags.bits.enable || pipe_ctx->update_flags.bits.opp_changed\n\t\t\t|| pipe_ctx->update_flags.bits.plane_changed\n\t\t\t|| pipe_ctx->stream->update_flags.bits.gamut_remap\n\t\t\t|| plane_state->update_flags.bits.gamut_remap_change\n\t\t\t|| pipe_ctx->stream->update_flags.bits.out_csc) {\n\t\t \n\t\tdc->hwss.program_gamut_remap(pipe_ctx);\n\n\t\t \n\t\tdc->hwss.program_output_csc(dc,\n\t\t\t\tpipe_ctx,\n\t\t\t\tpipe_ctx->stream->output_color_space,\n\t\t\t\tpipe_ctx->stream->csc_color_matrix.matrix,\n\t\t\t\thubp->opp_id);\n\t}\n\n\tif (pipe_ctx->update_flags.bits.enable ||\n\t\t\tpipe_ctx->update_flags.bits.plane_changed ||\n\t\t\tpipe_ctx->update_flags.bits.opp_changed ||\n\t\t\tplane_state->update_flags.bits.pixel_format_change ||\n\t\t\tplane_state->update_flags.bits.horizontal_mirror_change ||\n\t\t\tplane_state->update_flags.bits.rotation_change ||\n\t\t\tplane_state->update_flags.bits.swizzle_change ||\n\t\t\tplane_state->update_flags.bits.dcc_change ||\n\t\t\tplane_state->update_flags.bits.bpp_change ||\n\t\t\tplane_state->update_flags.bits.scaling_change ||\n\t\t\tplane_state->update_flags.bits.plane_size_change) {\n\t\tstruct plane_size size = plane_state->plane_size;\n\n\t\tsize.surface_size = pipe_ctx->plane_res.scl_data.viewport;\n\t\thubp->funcs->hubp_program_surface_config(\n\t\t\thubp,\n\t\t\tplane_state->format,\n\t\t\t&plane_state->tiling_info,\n\t\t\t&size,\n\t\t\tplane_state->rotation,\n\t\t\t&plane_state->dcc,\n\t\t\tplane_state->horizontal_mirror,\n\t\t\t0);\n\t\thubp->power_gated = false;\n\t}\n\n\tif (pipe_ctx->update_flags.bits.enable ||\n\t\tpipe_ctx->update_flags.bits.plane_changed ||\n\t\tplane_state->update_flags.bits.addr_update)\n\t\thws->funcs.update_plane_addr(dc, pipe_ctx);\n\n\tif (pipe_ctx->update_flags.bits.enable)\n\t\thubp->funcs->set_blank(hubp, false);\n\t \n\tif (pipe_ctx->stream && pipe_ctx->stream->mall_stream_config.type == SUBVP_PHANTOM\n\t\t\t&& hubp->funcs->phantom_hubp_post_enable)\n\t\thubp->funcs->phantom_hubp_post_enable(hubp);\n}\n\nstatic int calculate_vready_offset_for_group(struct pipe_ctx *pipe)\n{\n\tstruct pipe_ctx *other_pipe;\n\tint vready_offset = pipe->pipe_dlg_param.vready_offset;\n\n\t \n\tfor (other_pipe = pipe->bottom_pipe; other_pipe != NULL; other_pipe = other_pipe->bottom_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->top_pipe; other_pipe != NULL; other_pipe = other_pipe->top_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->next_odm_pipe; other_pipe != NULL; other_pipe = other_pipe->next_odm_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->prev_odm_pipe; other_pipe != NULL; other_pipe = other_pipe->prev_odm_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\n\treturn vready_offset;\n}\n\nstatic void dcn20_program_pipe(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tif (resource_is_pipe_type(pipe_ctx, OTG_MASTER)) {\n\t\tif (pipe_ctx->update_flags.bits.enable ||\n\t\t\t\tpipe_ctx->update_flags.bits.odm ||\n\t\t\t\tpipe_ctx->stream->update_flags.bits.abm_level)\n\t\t\thws->funcs.blank_pixel_data(dc, pipe_ctx,\n\t\t\t\t\t!pipe_ctx->plane_state ||\n\t\t\t\t\t!pipe_ctx->plane_state->visible);\n\t}\n\n\t \n\tif (pipe_ctx->update_flags.bits.global_sync && !pipe_ctx->top_pipe\n\t\t\t&& !pipe_ctx->prev_odm_pipe) {\n\t\tpipe_ctx->stream_res.tg->funcs->program_global_sync(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\tcalculate_vready_offset_for_group(pipe_ctx),\n\t\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start,\n\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_offset,\n\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_width);\n\n\t\tif (pipe_ctx->stream->mall_stream_config.type != SUBVP_PHANTOM)\n\t\t\tpipe_ctx->stream_res.tg->funcs->wait_for_state(pipe_ctx->stream_res.tg, CRTC_STATE_VACTIVE);\n\n\t\tpipe_ctx->stream_res.tg->funcs->set_vtg_params(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, true);\n\n\t\tif (hws->funcs.setup_vupdate_interrupt)\n\t\t\thws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);\n\t}\n\n\tif (pipe_ctx->update_flags.bits.odm)\n\t\thws->funcs.update_odm(dc, context, pipe_ctx);\n\n\tif (pipe_ctx->update_flags.bits.enable) {\n\t\tdcn20_enable_plane(dc, pipe_ctx, context);\n\t\tif (dc->res_pool->hubbub->funcs->force_wm_propagate_to_pipes)\n\t\t\tdc->res_pool->hubbub->funcs->force_wm_propagate_to_pipes(dc->res_pool->hubbub);\n\t}\n\n\tif (dc->res_pool->hubbub->funcs->program_det_size && pipe_ctx->update_flags.bits.det_size)\n\t\tdc->res_pool->hubbub->funcs->program_det_size(\n\t\t\tdc->res_pool->hubbub, pipe_ctx->plane_res.hubp->inst, pipe_ctx->det_buffer_size_kb);\n\n\tif (pipe_ctx->update_flags.raw || pipe_ctx->plane_state->update_flags.raw || pipe_ctx->stream->update_flags.raw)\n\t\tdcn20_update_dchubp_dpp(dc, pipe_ctx, context);\n\n\tif (pipe_ctx->update_flags.bits.enable\n\t\t\t|| pipe_ctx->plane_state->update_flags.bits.hdr_mult)\n\t\thws->funcs.set_hdr_multiplier(pipe_ctx);\n\n\tif (pipe_ctx->update_flags.bits.enable ||\n\t    pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||\n\t    pipe_ctx->plane_state->update_flags.bits.gamma_change ||\n\t    pipe_ctx->plane_state->update_flags.bits.lut_3d)\n\t\thws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);\n\n\t \n\tif (pipe_ctx->update_flags.bits.enable ||\n\t\t\tpipe_ctx->update_flags.bits.plane_changed ||\n\t\t\tpipe_ctx->stream->update_flags.bits.out_tf ||\n\t\t\tpipe_ctx->plane_state->update_flags.bits.output_tf_change)\n\t\thws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);\n\n\t \n\tif (pipe_ctx->update_flags.bits.enable\n\t    || pipe_ctx->update_flags.bits.opp_changed) {\n\n\t\tpipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\tCOLOR_SPACE_YCBCR601,\n\t\t\tpipe_ctx->stream->timing.display_color_depth,\n\t\t\tpipe_ctx->stream->signal);\n\n\t\tpipe_ctx->stream_res.opp->funcs->opp_program_fmt(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\t&pipe_ctx->stream->bit_depth_params,\n\t\t\t&pipe_ctx->stream->clamping);\n\t}\n\n\t \n\tif (pipe_ctx->plane_state->visible) {\n\t\tif (pipe_ctx->stream_res.abm) {\n\t\t\tdc->hwss.set_pipe(pipe_ctx);\n\t\t\tpipe_ctx->stream_res.abm->funcs->set_abm_level(pipe_ctx->stream_res.abm,\n\t\t\t\tpipe_ctx->stream->abm_level);\n\t\t}\n\t}\n}\n\nvoid dcn20_program_front_end_for_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream == old_pipe_ctx->stream)\n\t\t\tpipe_ctx->stream_res.gsl_group = old_pipe_ctx->stream_res.gsl_group;\n\t}\n\n\tif (dc->hwss.program_triplebuffer != NULL && dc->debug.enable_tri_buf) {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (!pipe_ctx->top_pipe && !pipe_ctx->prev_odm_pipe && pipe_ctx->plane_state) {\n\t\t\t\tASSERT(!pipe_ctx->plane_state->triplebuffer_flips);\n\t\t\t\t \n\t\t\t\tdc->hwss.program_triplebuffer(\n\t\t\t\t\t\tdc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tdcn20_detect_pipe_changes(&dc->current_state->res_ctx.pipe_ctx[i],\n\t\t\t\t&context->res_ctx.pipe_ctx[i]);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_stream_state *stream = dc->current_state->res_ctx.pipe_ctx[i].stream;\n\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable && stream &&\n\t\t\tdc->current_state->res_ctx.pipe_ctx[i].stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\tstruct timing_generator *tg = dc->current_state->res_ctx.pipe_ctx[i].stream_res.tg;\n\n\t\t\tif (tg->funcs->enable_crtc) {\n\t\t\t\tif (dc->hwss.blank_phantom) {\n\t\t\t\t\tint main_pipe_width, main_pipe_height;\n\n\t\t\t\t\tmain_pipe_width = dc->current_state->res_ctx.pipe_ctx[i].stream->mall_stream_config.paired_stream->dst.width;\n\t\t\t\t\tmain_pipe_height = dc->current_state->res_ctx.pipe_ctx[i].stream->mall_stream_config.paired_stream->dst.height;\n\t\t\t\t\tdc->hwss.blank_phantom(dc, tg, main_pipe_width, main_pipe_height);\n\t\t\t\t}\n\t\t\t\ttg->funcs->enable_crtc(tg);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable\n\t\t\t\t&& !context->res_ctx.pipe_ctx[i].top_pipe\n\t\t\t\t&& !context->res_ctx.pipe_ctx[i].prev_odm_pipe\n\t\t\t\t&& context->res_ctx.pipe_ctx[i].stream)\n\t\t\thws->funcs.blank_pixel_data(dc, &context->res_ctx.pipe_ctx[i], true);\n\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable\n\t\t\t\t|| context->res_ctx.pipe_ctx[i].update_flags.bits.opp_changed) {\n\t\t\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\n\t\t\t \n\t\t\tif (hubbub->funcs->program_det_size && (context->res_ctx.pipe_ctx[i].update_flags.bits.disable ||\n\t\t\t\t\t(context->res_ctx.pipe_ctx[i].plane_state && context->res_ctx.pipe_ctx[i].plane_state->is_phantom)))\n\t\t\t\thubbub->funcs->program_det_size(hubbub, dc->current_state->res_ctx.pipe_ctx[i].plane_res.hubp->inst, 0);\n\t\t\thws->funcs.plane_atomic_disconnect(dc, &dc->current_state->res_ctx.pipe_ctx[i]);\n\t\t\tDC_LOG_DC(\"Reset mpcc for pipe %d\\n\", dc->current_state->res_ctx.pipe_ctx[i].pipe_idx);\n\t\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->plane_state && !pipe->top_pipe) {\n\t\t\twhile (pipe) {\n\t\t\t\tif (hws->funcs.program_pipe)\n\t\t\t\t\thws->funcs.program_pipe(dc, pipe, context);\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tif (pipe->stream && pipe->stream->mall_stream_config.type != SUBVP_PHANTOM)\n\t\t\t\t\t\tdcn20_program_pipe(dc, pipe, context);\n\t\t\t\t}\n\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\t\t}\n\t\t \n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\tif (!pipe->top_pipe && !pipe->prev_odm_pipe\n\t\t\t\t&& pipe->stream && pipe->stream->num_wb_info > 0\n\t\t\t\t&& (pipe->update_flags.raw || (pipe->plane_state && pipe->plane_state->update_flags.raw)\n\t\t\t\t\t|| pipe->stream->update_flags.raw)\n\t\t\t\t&& hws->funcs.program_all_writeback_pipes_in_tree)\n\t\t\thws->funcs.program_all_writeback_pipes_in_tree(dc, pipe->stream, context);\n\n\t\t \n\t\tif (hws->wa.wait_hubpret_read_start_during_mpo_transition &&\n\t\t\t!pipe->top_pipe &&\n\t\t\tpipe->stream &&\n\t\t\tpipe->plane_res.hubp->funcs->hubp_wait_pipe_read_start &&\n\t\t\tdc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\tcontext->stream_status[0].plane_count > 1) {\n\t\t\tpipe->plane_res.hubp->funcs->hubp_wait_pipe_read_start(pipe->plane_res.hubp);\n\t\t}\n\n\t\t \n\t\tif (dc->debug.enable_single_display_2to1_odm_policy &&\n\t\t\tpipe->stream &&\n\t\t\tpipe->update_flags.bits.disable &&\n\t\t\t!pipe->prev_odm_pipe &&\n\t\t\thws->funcs.update_odm)\n\t\t\thws->funcs.update_odm(dc, context, pipe);\n\t}\n}\n\nvoid dcn20_post_unlock_program_front_end(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tconst unsigned int TIMEOUT_FOR_PIPE_ENABLE_US = 100000;\n\tunsigned int polling_interval_us = 1;\n\tstruct dce_hwseq *hwseq = dc->hwseq;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable)\n\t\t\tdc->hwss.disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\t \n\t\tif (pipe->plane_state && !pipe->top_pipe && pipe->update_flags.bits.enable &&\n\t\t\t\tpipe->stream->mall_stream_config.type != SUBVP_PHANTOM) {\n\t\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\t\t\tint j = 0;\n\t\t\tfor (j = 0; j < TIMEOUT_FOR_PIPE_ENABLE_US / polling_interval_us\n\t\t\t\t\t&& hubp->funcs->hubp_is_flip_pending(hubp); j++)\n\t\t\t\tudelay(polling_interval_us);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->plane_state && !pipe->top_pipe) {\n\t\t\t \n\t\t\twhile (pipe) {\n\t\t\t\tif (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\t\t \n\t\t\t\t\tif (dc->hwss.apply_update_flags_for_phantom)\n\t\t\t\t\t\tdc->hwss.apply_update_flags_for_phantom(pipe);\n\t\t\t\t\tif (dc->hwss.update_phantom_vp_position)\n\t\t\t\t\t\tdc->hwss.update_phantom_vp_position(dc, context, pipe);\n\t\t\t\t\tdcn20_program_pipe(dc, pipe, context);\n\t\t\t\t}\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (hwseq && hwseq->funcs.update_force_pstate)\n\t\tdc->hwseq->funcs.update_force_pstate(dc, context);\n\n\t \n\tif (hwseq->funcs.program_mall_pipe_config)\n\t\thwseq->funcs.program_mall_pipe_config(dc, context);\n\n\t \n\tif (hwseq->wa.DEGVIDCN21)\n\t\tdc->res_pool->hubbub->funcs->apply_DEDCN21_147_wa(dc->res_pool->hubbub);\n\n\n\t \n\tif (hwseq->wa.disallow_self_refresh_during_multi_plane_transition) {\n\n\t\tif (dc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\t\tcontext->stream_status[0].plane_count > 1) {\n\n\t\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[0];\n\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub, false);\n\n\t\t\thwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied = true;\n\t\t\thwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied_on_frame = tg->funcs->get_frame_count(tg);\n\t\t}\n\t}\n}\n\nvoid dcn20_prepare_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tunsigned int compbuf_size_kb = 0;\n\tunsigned int cache_wm_a = context->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns;\n\tunsigned int i;\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\tfalse);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type != SUBVP_NONE) {\n\t\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = 4U * 1000U * 1000U * 1000U;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdc->wm_optimized_required |= hubbub->funcs->program_watermarks(hubbub,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.watermarks,\n\t\t\t\t\tdc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,\n\t\t\t\t\tfalse);\n\n\t \n\t \n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = cache_wm_a;\n\n\t \n\tif (hubbub->funcs->program_compbuf_size) {\n\t\tif (context->bw_ctx.dml.ip.min_comp_buffer_size_kbytes) {\n\t\t\tcompbuf_size_kb = context->bw_ctx.dml.ip.min_comp_buffer_size_kbytes;\n\t\t\tdc->wm_optimized_required |= (compbuf_size_kb != dc->current_state->bw_ctx.dml.ip.min_comp_buffer_size_kbytes);\n\t\t} else {\n\t\t\tcompbuf_size_kb = context->bw_ctx.bw.dcn.compbuf_size_kb;\n\t\t\tdc->wm_optimized_required |= (compbuf_size_kb != dc->current_state->bw_ctx.bw.dcn.compbuf_size_kb);\n\t\t}\n\n\t\thubbub->funcs->program_compbuf_size(hubbub, compbuf_size_kb, false);\n\t}\n}\n\nvoid dcn20_optimize_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type != SUBVP_NONE) {\n\t\t\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = 4U * 1000U * 1000U * 1000U;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\thubbub->funcs->program_watermarks(hubbub,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.watermarks,\n\t\t\t\t\tdc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,\n\t\t\t\t\ttrue);\n\n\tif (dc->clk_mgr->dc_mode_softmax_enabled)\n\t\tif (dc->clk_mgr->clks.dramclk_khz > dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000 &&\n\t\t\t\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz <= dc->clk_mgr->bw_params->dc_mode_softmax_memclk * 1000)\n\t\t\tdc->clk_mgr->funcs->set_max_memclk(dc->clk_mgr, dc->clk_mgr->bw_params->dc_mode_softmax_memclk);\n\n\t \n\tif (hubbub->funcs->program_compbuf_size)\n\t\thubbub->funcs->program_compbuf_size(hubbub, context->bw_ctx.bw.dcn.compbuf_size_kb, true);\n\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching) {\n\t\tdc_dmub_srv_p_state_delegate(dc,\n\t\t\ttrue, context);\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = true;\n\t\tdc->clk_mgr->clks.fw_based_mclk_switching = true;\n\t} else {\n\t\tdc->clk_mgr->clks.fw_based_mclk_switching = false;\n\t}\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\ttrue);\n\tif (context->bw_ctx.bw.dcn.clk.zstate_support == DCN_ZSTATE_SUPPORT_ALLOW) {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; ++i) {\n\t\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->stream && pipe_ctx->plane_res.hubp->funcs->program_extended_blank\n\t\t\t\t&& pipe_ctx->stream->adjust.v_total_min == pipe_ctx->stream->adjust.v_total_max\n\t\t\t\t&& pipe_ctx->stream->adjust.v_total_max > pipe_ctx->stream->timing.v_total)\n\t\t\t\t\tpipe_ctx->plane_res.hubp->funcs->program_extended_blank(pipe_ctx->plane_res.hubp,\n\t\t\t\t\t\tpipe_ctx->dlg_regs.min_dst_y_next_start);\n\t\t}\n\t}\n}\n\nbool dcn20_update_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tif (!dc->res_pool->funcs->validate_bandwidth(dc, context, false))\n\t\treturn false;\n\n\t \n\tdc->hwss.prepare_bandwidth(dc, context);\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->plane_state == NULL)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx->top_pipe == NULL) {\n\t\t\tbool blank = !is_pipe_tree_visible(pipe_ctx);\n\n\t\t\tpipe_ctx->stream_res.tg->funcs->program_global_sync(\n\t\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t\tcalculate_vready_offset_for_group(pipe_ctx),\n\t\t\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start,\n\t\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_offset,\n\t\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_width);\n\n\t\t\tpipe_ctx->stream_res.tg->funcs->set_vtg_params(\n\t\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, false);\n\n\t\t\tif (pipe_ctx->prev_odm_pipe == NULL)\n\t\t\t\thws->funcs.blank_pixel_data(dc, pipe_ctx, blank);\n\n\t\t\tif (hws->funcs.setup_vupdate_interrupt)\n\t\t\t\thws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);\n\t\t}\n\n\t\tpipe_ctx->plane_res.hubp->funcs->hubp_setup(\n\t\t\t\tpipe_ctx->plane_res.hubp,\n\t\t\t\t\t&pipe_ctx->dlg_regs,\n\t\t\t\t\t&pipe_ctx->ttu_regs,\n\t\t\t\t\t&pipe_ctx->rq_regs,\n\t\t\t\t\t&pipe_ctx->pipe_dlg_param);\n\t}\n\n\treturn true;\n}\n\nvoid dcn20_enable_writeback(\n\t\tstruct dc *dc,\n\t\tstruct dc_writeback_info *wb_info,\n\t\tstruct dc_state *context)\n{\n\tstruct dwbc *dwb;\n\tstruct mcif_wb *mcif_wb;\n\tstruct timing_generator *optc;\n\n\tASSERT(wb_info->dwb_pipe_inst < MAX_DWB_PIPES);\n\tASSERT(wb_info->wb_enabled);\n\tdwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];\n\tmcif_wb = dc->res_pool->mcif_wb[wb_info->dwb_pipe_inst];\n\n\t \n\toptc = dc->res_pool->timing_generators[dwb->otg_inst];\n\toptc->funcs->set_dwb_source(optc, wb_info->dwb_pipe_inst);\n\t \n\tmcif_wb->funcs->config_mcif_buf(mcif_wb, &wb_info->mcif_buf_params, wb_info->dwb_params.dest_height);\n\tmcif_wb->funcs->config_mcif_arb(mcif_wb, &context->bw_ctx.bw.dcn.bw_writeback.mcif_wb_arb[wb_info->dwb_pipe_inst]);\n\t \n\tmcif_wb->funcs->enable_mcif(mcif_wb);\n\t \n\tdwb->funcs->enable(dwb, &wb_info->dwb_params);\n\t \n}\n\nvoid dcn20_disable_writeback(\n\t\tstruct dc *dc,\n\t\tunsigned int dwb_pipe_inst)\n{\n\tstruct dwbc *dwb;\n\tstruct mcif_wb *mcif_wb;\n\n\tASSERT(dwb_pipe_inst < MAX_DWB_PIPES);\n\tdwb = dc->res_pool->dwbc[dwb_pipe_inst];\n\tmcif_wb = dc->res_pool->mcif_wb[dwb_pipe_inst];\n\n\tdwb->funcs->disable(dwb);\n\tmcif_wb->funcs->disable_mcif(mcif_wb);\n}\n\nbool dcn20_wait_for_blank_complete(\n\t\tstruct output_pixel_processor *opp)\n{\n\tint counter;\n\n\tfor (counter = 0; counter < 1000; counter++) {\n\t\tif (opp->funcs->dpg_is_blanked(opp))\n\t\t\tbreak;\n\n\t\tudelay(100);\n\t}\n\n\tif (counter == 1000) {\n\t\tdm_error(\"DC: failed to blank crtc!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool dcn20_dmdata_status_done(struct pipe_ctx *pipe_ctx)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\n\tif (!hubp)\n\t\treturn false;\n\treturn hubp->funcs->dmdata_status_done(hubp);\n}\n\nvoid dcn20_disable_stream_gating(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tif (pipe_ctx->stream_res.dsc) {\n\t\tstruct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;\n\n\t\thws->funcs.dsc_pg_control(hws, pipe_ctx->stream_res.dsc->inst, true);\n\t\twhile (odm_pipe) {\n\t\t\thws->funcs.dsc_pg_control(hws, odm_pipe->stream_res.dsc->inst, true);\n\t\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t\t}\n\t}\n}\n\nvoid dcn20_enable_stream_gating(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tif (pipe_ctx->stream_res.dsc) {\n\t\tstruct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;\n\n\t\thws->funcs.dsc_pg_control(hws, pipe_ctx->stream_res.dsc->inst, false);\n\t\twhile (odm_pipe) {\n\t\t\thws->funcs.dsc_pg_control(hws, odm_pipe->stream_res.dsc->inst, false);\n\t\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t\t}\n\t}\n}\n\nvoid dcn20_set_dmdata_attributes(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_dmdata_attributes attr = { 0 };\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\n\tattr.dmdata_mode = DMDATA_HW_MODE;\n\tattr.dmdata_size =\n\t\tdc_is_hdmi_signal(pipe_ctx->stream->signal) ? 32 : 36;\n\tattr.address.quad_part =\n\t\t\tpipe_ctx->stream->dmdata_address.quad_part;\n\tattr.dmdata_dl_delta = 0;\n\tattr.dmdata_qos_mode = 0;\n\tattr.dmdata_qos_level = 0;\n\tattr.dmdata_repeat = 1;  \n\tattr.dmdata_updated = 1;\n\tattr.dmdata_sw_data = NULL;\n\n\thubp->funcs->dmdata_set_attributes(hubp, &attr);\n}\n\nvoid dcn20_init_vm_ctx(\n\t\tstruct dce_hwseq *hws,\n\t\tstruct dc *dc,\n\t\tstruct dc_virtual_addr_space_config *va_config,\n\t\tint vmid)\n{\n\tstruct dcn_hubbub_virt_addr_config config;\n\n\tif (vmid == 0) {\n\t\tASSERT(0);  \n\t\treturn;\n\t}\n\n\tconfig.page_table_start_addr = va_config->page_table_start_addr;\n\tconfig.page_table_end_addr = va_config->page_table_end_addr;\n\tconfig.page_table_block_size = va_config->page_table_block_size_in_bytes;\n\tconfig.page_table_depth = va_config->page_table_depth;\n\tconfig.page_table_base_addr = va_config->page_table_base_addr;\n\n\tdc->res_pool->hubbub->funcs->init_vm_ctx(dc->res_pool->hubbub, &config, vmid);\n}\n\nint dcn20_init_sys_ctx(struct dce_hwseq *hws, struct dc *dc, struct dc_phy_addr_space_config *pa_config)\n{\n\tstruct dcn_hubbub_phys_addr_config config;\n\n\tconfig.system_aperture.fb_top = pa_config->system_aperture.fb_top;\n\tconfig.system_aperture.fb_offset = pa_config->system_aperture.fb_offset;\n\tconfig.system_aperture.fb_base = pa_config->system_aperture.fb_base;\n\tconfig.system_aperture.agp_top = pa_config->system_aperture.agp_top;\n\tconfig.system_aperture.agp_bot = pa_config->system_aperture.agp_bot;\n\tconfig.system_aperture.agp_base = pa_config->system_aperture.agp_base;\n\tconfig.gart_config.page_table_start_addr = pa_config->gart_config.page_table_start_addr;\n\tconfig.gart_config.page_table_end_addr = pa_config->gart_config.page_table_end_addr;\n\tconfig.gart_config.page_table_base_addr = pa_config->gart_config.page_table_base_addr;\n\tconfig.page_table_default_page_addr = pa_config->page_table_default_page_addr;\n\n\treturn dc->res_pool->hubbub->funcs->init_dchub_sys_ctx(dc->res_pool->hubbub, &config);\n}\n\nstatic bool patch_address_for_sbs_tb_stereo(\n\t\tstruct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tbool sec_split = pipe_ctx->top_pipe &&\n\t\t\tpipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;\n\tif (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t\t(pipe_ctx->stream->timing.timing_3d_format ==\n\t\t\tTIMING_3D_FORMAT_SIDE_BY_SIDE ||\n\t\t\tpipe_ctx->stream->timing.timing_3d_format ==\n\t\t\tTIMING_3D_FORMAT_TOP_AND_BOTTOM)) {\n\t\t*addr = plane_state->address.grph_stereo.left_addr;\n\t\tplane_state->address.grph_stereo.left_addr =\n\t\t\t\tplane_state->address.grph_stereo.right_addr;\n\t\treturn true;\n\t}\n\n\tif (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&\n\t\t\tplane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {\n\t\tplane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;\n\t\tplane_state->address.grph_stereo.right_addr =\n\t\t\t\tplane_state->address.grph_stereo.left_addr;\n\t\tplane_state->address.grph_stereo.right_meta_addr =\n\t\t\t\tplane_state->address.grph_stereo.left_meta_addr;\n\t}\n\treturn false;\n}\n\nvoid dcn20_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tbool addr_patched = false;\n\tPHYSICAL_ADDRESS_LOC addr;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\taddr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);\n\n\t\n\tvm_helper_mark_vmid_used(dc->vm_helper, plane_state->address.vmid, pipe_ctx->plane_res.hubp->inst);\n\n\tpipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(\n\t\t\tpipe_ctx->plane_res.hubp,\n\t\t\t&plane_state->address,\n\t\t\tplane_state->flip_immediate);\n\n\tplane_state->status.requested_address = plane_state->address;\n\n\tif (plane_state->flip_immediate)\n\t\tplane_state->status.current_address = plane_state->address;\n\n\tif (addr_patched)\n\t\tpipe_ctx->plane_state->address.grph_stereo.left_addr = addr;\n}\n\nvoid dcn20_unblank_stream(struct pipe_ctx *pipe_ctx,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tstruct encoder_unblank_param params = {0};\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\tstruct pipe_ctx *odm_pipe;\n\n\tparams.opp_cnt = 1;\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\tparams.opp_cnt++;\n\t}\n\t \n\tparams.timing = pipe_ctx->stream->timing;\n\n\tparams.link_settings.link_rate = link_settings->link_rate;\n\n\tif (link->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t \n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_unblank(\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\tif (optc2_is_two_pixels_per_containter(&stream->timing) || params.opp_cnt > 1)\n\t\t\tparams.timing.pix_clk_100hz /= 2;\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.stream_enc, params.opp_cnt > 1);\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_unblank(link, pipe_ctx->stream_res.stream_enc, &params);\n\t}\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\thws->funcs.edp_backlight_control(link, true);\n\t}\n}\n\nvoid dcn20_setup_vupdate_interrupt(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tint start_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);\n\n\tif (start_line < 0)\n\t\tstart_line = 0;\n\n\tif (tg->funcs->setup_vertical_interrupt2)\n\t\ttg->funcs->setup_vertical_interrupt2(tg, start_line);\n}\n\nstatic void dcn20_reset_back_end_for_pipe(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\tif (pipe_ctx->stream_res.stream_enc == NULL) {\n\t\tpipe_ctx->stream = NULL;\n\t\treturn;\n\t}\n\n\t \n\t \n\tif (!pipe_ctx->stream->dpms_off || link->link_status.link_active)\n\t\tdc->link_srv->set_dpms_off(pipe_ctx);\n\telse if (pipe_ctx->stream_res.audio)\n\t\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\t \n\tif (pipe_ctx->stream_res.audio) {\n\t\t \n\t\tpipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);\n\n\t\t \n\t\tif (dc->caps.dynamic_audio == true) {\n\t\t\t \n\t\t\t \n\t\t\tupdate_audio_usage(&dc->current_state->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe_ctx->stream_res.audio, false);\n\t\t\tpipe_ctx->stream_res.audio = NULL;\n\t\t}\n\t}\n\n\t \n\tif (pipe_ctx->top_pipe == NULL) {\n\n\t\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);\n\n\t\tpipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);\n\t\tif (pipe_ctx->stream_res.tg->funcs->set_odm_bypass)\n\t\t\tpipe_ctx->stream_res.tg->funcs->set_odm_bypass(\n\t\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);\n\n\t\tif (pipe_ctx->stream_res.tg->funcs->set_drr)\n\t\t\tpipe_ctx->stream_res.tg->funcs->set_drr(\n\t\t\t\t\tpipe_ctx->stream_res.tg, NULL);\n\t\t \n\t\tlink->phy_state.symclk_ref_cnts.otg = 0;\n\t\tif (link->phy_state.symclk_state == SYMCLK_ON_TX_OFF) {\n\t\t\tlink_hwss->disable_link_output(link,\n\t\t\t\t\t&pipe_ctx->link_res, pipe_ctx->stream->signal);\n\t\t\tlink->phy_state.symclk_state = SYMCLK_OFF_TX_OFF;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)\n\t\t\tbreak;\n\n\tif (i == dc->res_pool->pipe_count)\n\t\treturn;\n\n\tpipe_ctx->stream = NULL;\n\tDC_LOG_DEBUG(\"Reset back end for pipe %d, tg:%d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);\n}\n\nvoid dcn20_reset_hw_ctx_wrap(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tfor (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx_old->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx_old->top_pipe || pipe_ctx_old->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tif (!pipe_ctx->stream ||\n\t\t\t\tpipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {\n\t\t\tstruct clock_source *old_clk = pipe_ctx_old->clock_source;\n\n\t\t\tdcn20_reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);\n\t\t\tif (hws->funcs.enable_stream_gating)\n\t\t\t\thws->funcs.enable_stream_gating(dc, pipe_ctx_old);\n\t\t\tif (old_clk)\n\t\t\t\told_clk->funcs->cs_power_down(old_clk);\n\t\t}\n\t}\n}\n\nvoid dcn20_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct mpcc_blnd_cfg blnd_cfg = {0};\n\tbool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha;\n\tint mpcc_id;\n\tstruct mpcc *new_mpcc;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);\n\n\tblnd_cfg.overlap_only = false;\n\tblnd_cfg.global_gain = 0xff;\n\n\tif (per_pixel_alpha) {\n\t\tblnd_cfg.pre_multiplied_alpha = pipe_ctx->plane_state->pre_multiplied_alpha;\n\t\tif (pipe_ctx->plane_state->global_alpha) {\n\t\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA_COMBINED_GLOBAL_GAIN;\n\t\t\tblnd_cfg.global_gain = pipe_ctx->plane_state->global_alpha_value;\n\t\t} else {\n\t\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;\n\t\t}\n\t} else {\n\t\tblnd_cfg.pre_multiplied_alpha = false;\n\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA;\n\t}\n\n\tif (pipe_ctx->plane_state->global_alpha)\n\t\tblnd_cfg.global_alpha = pipe_ctx->plane_state->global_alpha_value;\n\telse\n\t\tblnd_cfg.global_alpha = 0xff;\n\n\tblnd_cfg.background_color_bpc = 4;\n\tblnd_cfg.bottom_gain_mode = 0;\n\tblnd_cfg.top_gain = 0x1f000;\n\tblnd_cfg.bottom_inside_gain = 0x1f000;\n\tblnd_cfg.bottom_outside_gain = 0x1f000;\n\n\tif (pipe_ctx->plane_state->format\n\t\t\t== SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA)\n\t\tblnd_cfg.pre_multiplied_alpha = false;\n\n\t \n\tmpcc_id = hubp->inst;\n\n\t \n\tif (!pipe_ctx->plane_state->update_flags.bits.full_update &&\n\t\t!pipe_ctx->update_flags.bits.mpcc) {\n\t\tmpc->funcs->update_blending(mpc, &blnd_cfg, mpcc_id);\n\t\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\t\treturn;\n\t}\n\n\t \n\tnew_mpcc = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, mpcc_id);\n\t \n\tif (new_mpcc != NULL)\n\t\tmpc->funcs->remove_mpcc(mpc, mpc_tree_params, new_mpcc);\n\telse\n\t\tif (dc->debug.sanity_checks)\n\t\t\tmpc->funcs->assert_mpcc_idle_before_connect(\n\t\t\t\t\tdc->res_pool->mpc, mpcc_id);\n\n\t \n\tnew_mpcc = mpc->funcs->insert_plane(dc->res_pool->mpc,\n\t\t\tmpc_tree_params,\n\t\t\t&blnd_cfg,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\thubp->inst,\n\t\t\tmpcc_id);\n\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\n\tASSERT(new_mpcc != NULL);\n\thubp->opp_id = pipe_ctx->stream_res.opp->inst;\n\thubp->mpcc_id = mpcc_id;\n}\n\nstatic enum phyd32clk_clock_source get_phyd32clk_src(struct dc_link *link)\n{\n\tswitch (link->link_enc->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn PHYD32CLKA;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn PHYD32CLKB;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn PHYD32CLKC;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn PHYD32CLKD;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn PHYD32CLKE;\n\tdefault:\n\t\treturn PHYD32CLKA;\n\t}\n}\n\nstatic int get_odm_segment_count(struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;\n\tint count = 1;\n\n\twhile (odm_pipe != NULL) {\n\t\tcount++;\n\t\todm_pipe = odm_pipe->next_odm_pipe;\n\t}\n\n\treturn count;\n}\n\nvoid dcn20_enable_stream(struct pipe_ctx *pipe_ctx)\n{\n\tenum dc_lane_count lane_count =\n\t\tpipe_ctx->stream->link->cur_link_settings.lane_count;\n\n\tstruct dc_crtc_timing *timing = &pipe_ctx->stream->timing;\n\tstruct dc_link *link = pipe_ctx->stream->link;\n\n\tuint32_t active_total_with_borders;\n\tuint32_t early_control = 0;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tstruct dtbclk_dto_params dto_params = {0};\n\tstruct dccg *dccg = dc->res_pool->dccg;\n\tenum phyd32clk_clock_source phyd32clk;\n\tint dp_hpo_inst;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tunsigned int k1_div = PIXEL_RATE_DIV_NA;\n\tunsigned int k2_div = PIXEL_RATE_DIV_NA;\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tif (dc->hwseq->funcs.setup_hpo_hw_control)\n\t\t\tdc->hwseq->funcs.setup_hpo_hw_control(dc->hwseq, true);\n\t}\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tdp_hpo_inst = pipe_ctx->stream_res.hpo_dp_stream_enc->inst;\n\t\tdccg->funcs->set_dpstreamclk(dccg, DTBCLK0, tg->inst, dp_hpo_inst);\n\n\t\tphyd32clk = get_phyd32clk_src(link);\n\t\tdccg->funcs->enable_symclk32_se(dccg, dp_hpo_inst, phyd32clk);\n\n\t\tdto_params.otg_inst = tg->inst;\n\t\tdto_params.pixclk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10;\n\t\tdto_params.num_odm_segments = get_odm_segment_count(pipe_ctx);\n\t\tdto_params.timing = &pipe_ctx->stream->timing;\n\t\tdto_params.ref_dtbclk_khz = dc->clk_mgr->funcs->get_dtb_ref_clk_frequency(dc->clk_mgr);\n\t\tdccg->funcs->set_dtbclk_dto(dccg, &dto_params);\n\t} else {\n\t\t}\n\tif (hws->funcs.calculate_dccg_k1_k2_values && dc->res_pool->dccg->funcs->set_pixel_rate_div) {\n\t\thws->funcs.calculate_dccg_k1_k2_values(pipe_ctx, &k1_div, &k2_div);\n\n\t\tdc->res_pool->dccg->funcs->set_pixel_rate_div(\n\t\t\tdc->res_pool->dccg,\n\t\t\tpipe_ctx->stream_res.tg->inst,\n\t\t\tk1_div, k2_div);\n\t}\n\n\tlink_hwss->setup_stream_encoder(pipe_ctx);\n\n\tif (pipe_ctx->plane_state && pipe_ctx->plane_state->flip_immediate != 1) {\n\t\tif (dc->hwss.program_dmdata_engine)\n\t\t\tdc->hwss.program_dmdata_engine(pipe_ctx);\n\t}\n\n\tdc->hwss.update_info_frame(pipe_ctx);\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_UPDATE_INFO_FRAME);\n\n\t \n\tactive_total_with_borders =\n\t\t\ttiming->h_addressable\n\t\t\t\t+ timing->h_border_left\n\t\t\t\t+ timing->h_border_right;\n\n\tif (lane_count != 0)\n\t\tearly_control = active_total_with_borders % lane_count;\n\n\tif (early_control == 0)\n\t\tearly_control = lane_count;\n\n\ttg->funcs->set_early_control(tg, early_control);\n\n\tif (dc->hwseq->funcs.set_pixels_per_cycle)\n\t\tdc->hwseq->funcs.set_pixels_per_cycle(pipe_ctx);\n}\n\nvoid dcn20_program_dmdata_engine(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state    *stream     = pipe_ctx->stream;\n\tstruct hubp               *hubp       = pipe_ctx->plane_res.hubp;\n\tbool                       enable     = false;\n\tstruct stream_encoder     *stream_enc = pipe_ctx->stream_res.stream_enc;\n\tenum dynamic_metadata_mode mode       = dc_is_dp_signal(stream->signal)\n\t\t\t\t\t\t\t? dmdata_dp\n\t\t\t\t\t\t\t: dmdata_hdmi;\n\n\t \n\tif (pipe_ctx->stream->dmdata_address.quad_part != 0) {\n\t\tpipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;\n\t\tenable = true;\n\t}\n\n\tif (!hubp)\n\t\treturn;\n\n\tif (!stream_enc || !stream_enc->funcs->set_dynamic_metadata)\n\t\treturn;\n\n\tstream_enc->funcs->set_dynamic_metadata(stream_enc, enable,\n\t\t\t\t\t\thubp->inst, mode);\n}\n\nvoid dcn20_fpga_init_hw(struct dc *dc)\n{\n\tint i, j;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tstruct dc_state  *context = dc->current_state;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\t\n\tif (res_pool->dccg->funcs->dccg_init)\n\t\tres_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\t\n\thws->funcs.enable_power_gating_plane(hws, true);\n\n\t\n\tREG_WRITE(RBBMIF_TIMEOUT_DIS, 0xFFFFFFFF);\n\tREG_WRITE(RBBMIF_TIMEOUT_DIS_2, 0xFFFFFFFF);\n\n\thws->funcs.dccg_init(hws);\n\n\tREG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_REFDIV, 2);\n\tREG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);\n\tif (REG(REFCLK_CNTL))\n\t\tREG_WRITE(REFCLK_CNTL, 0);\n\t\n\n\n\t \n\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\tdcn20_init_blank(dc, tg);\n\t}\n\n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\ttg->funcs->lock(tg);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dpp *dpp = res_pool->dpps[i];\n\n\t\tdpp->funcs->dpp_reset(dpp);\n\t}\n\n\t \n\tres_pool->mpc->funcs->mpc_init(res_pool->mpc);\n\n\t \n\tfor (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {\n\t\tres_pool->opps[i]->mpc_tree_params.opp_id = res_pool->opps[i]->inst;\n\t\tres_pool->opps[i]->mpc_tree_params.opp_list = NULL;\n\t\tfor (j = 0; j < MAX_PIPES; j++)\n\t\t\tres_pool->opps[i]->mpcc_disconnect_pending[j] = false;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = dc->res_pool->hubps[i];\n\t\tstruct dpp *dpp = dc->res_pool->dpps[i];\n\n\t\tpipe_ctx->stream_res.tg = tg;\n\t\tpipe_ctx->pipe_idx = i;\n\n\t\tpipe_ctx->plane_res.hubp = hubp;\n\t\tpipe_ctx->plane_res.dpp = dpp;\n\t\tpipe_ctx->plane_res.mpcc_inst = dpp->inst;\n\t\thubp->mpcc_id = dpp->inst;\n\t\thubp->opp_id = OPP_ID_INVALID;\n\t\thubp->power_gated = false;\n\t\tpipe_ctx->stream_res.opp = NULL;\n\n\t\thubp->funcs->hubp_init(hubp);\n\n\t\t\n\t\t\n\t\tdc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;\n\t\tpipe_ctx->stream_res.opp = dc->res_pool->opps[i];\n\t\t \n\t\thws->funcs.plane_atomic_disconnect(dc, pipe_ctx);\n\t}\n\n\t \n\tfor (i = 0; i < res_pool->res_cap->num_dwb; i++)\n\t\tres_pool->dwbc[i]->mcif = res_pool->mcif_wb[i];\n\n\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\ttg->funcs->unlock(tg);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tdc->hwss.disable_plane(dc, pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg = NULL;\n\t\tpipe_ctx->plane_res.hubp = NULL;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\ttg->funcs->tg_init(tg);\n\t}\n\n\tif (dc->res_pool->hubbub->funcs->init_crb)\n\t\tdc->res_pool->hubbub->funcs->init_crb(dc->res_pool->hubbub);\n}\n#ifndef TRIM_FSFT\nbool dcn20_optimize_timing_for_fsft(struct dc *dc,\n\t\tstruct dc_crtc_timing *timing,\n\t\tunsigned int max_input_rate_in_khz)\n{\n\tunsigned int old_v_front_porch;\n\tunsigned int old_v_total;\n\tunsigned int max_input_rate_in_100hz;\n\tunsigned long long new_v_total;\n\n\tmax_input_rate_in_100hz = max_input_rate_in_khz * 10;\n\tif (max_input_rate_in_100hz < timing->pix_clk_100hz)\n\t\treturn false;\n\n\told_v_total = timing->v_total;\n\told_v_front_porch = timing->v_front_porch;\n\n\ttiming->fast_transport_output_rate_100hz = timing->pix_clk_100hz;\n\ttiming->pix_clk_100hz = max_input_rate_in_100hz;\n\n\tnew_v_total = div_u64((unsigned long long)old_v_total * max_input_rate_in_100hz, timing->pix_clk_100hz);\n\n\ttiming->v_total = new_v_total;\n\ttiming->v_front_porch = old_v_front_porch + (timing->v_total - old_v_total);\n\treturn true;\n}\n#endif\n\nvoid dcn20_set_disp_pattern_generator(const struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tenum controller_dp_test_pattern test_pattern,\n\t\tenum controller_dp_color_space color_space,\n\t\tenum dc_color_depth color_depth,\n\t\tconst struct tg_color *solid_color,\n\t\tint width, int height, int offset)\n{\n\tpipe_ctx->stream_res.opp->funcs->opp_set_disp_pattern_generator(pipe_ctx->stream_res.opp, test_pattern,\n\t\t\tcolor_space, color_depth, solid_color, width, height, offset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}