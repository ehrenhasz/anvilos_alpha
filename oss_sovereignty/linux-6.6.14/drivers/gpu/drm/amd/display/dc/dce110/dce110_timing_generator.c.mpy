{
  "module_name": "dce110_timing_generator.c",
  "hash_id": "92eae2ca16f510a0165c288341fb2359d375265ccc8bbea9fed487482eb28373",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n \n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#include \"dc_types.h\"\n#include \"dc_bios_types.h\"\n#include \"dc.h\"\n\n#include \"include/grph_object_id.h\"\n#include \"include/logger_interface.h\"\n#include \"dce110_timing_generator.h\"\n\n#include \"timing_generator.h\"\n\n\n#define NUMBER_OF_FRAME_TO_WAIT_ON_TRIGGERED_RESET 10\n\n#define MAX_H_TOTAL (CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1)\n#define MAX_V_TOTAL (CRTC_V_TOTAL__CRTC_V_TOTAL_MASKhw + 1)\n\n#define CRTC_REG(reg) (reg + tg110->offsets.crtc)\n#define DCP_REG(reg) (reg + tg110->offsets.dcp)\n\n \n\n\n \nstatic void dce110_timing_generator_apply_front_porch_workaround(\n\tstruct timing_generator *tg,\n\tstruct dc_crtc_timing *timing)\n{\n\tif (timing->flags.INTERLACE == 1) {\n\t\tif (timing->v_front_porch < 2)\n\t\t\ttiming->v_front_porch = 2;\n\t} else {\n\t\tif (timing->v_front_porch < 1)\n\t\t\ttiming->v_front_porch = 1;\n\t}\n}\n\n \nstatic bool dce110_timing_generator_is_in_vertical_blank(\n\t\tstruct timing_generator *tg)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\tuint32_t field = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\taddr = CRTC_REG(mmCRTC_STATUS);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tfield = get_reg_field_value(value, CRTC_STATUS, CRTC_V_BLANK);\n\treturn field == 1;\n}\n\nvoid dce110_timing_generator_set_early_control(\n\t\tstruct timing_generator *tg,\n\t\tuint32_t early_cntl)\n{\n\tuint32_t regval;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t address = CRTC_REG(mmCRTC_CONTROL);\n\n\tregval = dm_read_reg(tg->ctx, address);\n\tset_reg_field_value(regval, early_cntl,\n\t\t\tCRTC_CONTROL, CRTC_HBLANK_EARLY_CONTROL);\n\tdm_write_reg(tg->ctx, address, regval);\n}\n\n \nbool dce110_timing_generator_enable_crtc(struct timing_generator *tg)\n{\n\tenum bp_result result;\n\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t value = 0;\n\n\t \n\tset_reg_field_value(\n\t\tvalue,\n\t\t0,\n\t\tCRTC_MASTER_UPDATE_MODE,\n\t\tMASTER_UPDATE_MODE);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_MODE), value);\n\n\t \n\tvalue = 0;\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_LOCK), value);\n\n\tresult = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, true);\n\n\treturn result == BP_RESULT_OK;\n}\n\nvoid dce110_timing_generator_program_blank_color(\n\t\tstruct timing_generator *tg,\n\t\tconst struct tg_color *black_color)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_b_cb,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_B_CB);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_g_y,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_G_Y);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_r_cr,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_R_CR);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\n \n#if 0\n@TODOSTEREO\nstatic void disable_stereo(struct timing_generator *tg)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_3D_STRUCTURE_CONTROL);\n\tuint32_t value = 0;\n\tuint32_t test = 0;\n\tuint32_t field = 0;\n\tuint32_t struc_en = 0;\n\tuint32_t struc_stereo_sel_ovr = 0;\n\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tstruc_en = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_3D_STRUCTURE_CONTROL,\n\t\t\tCRTC_3D_STRUCTURE_EN);\n\n\tstruc_stereo_sel_ovr = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_3D_STRUCTURE_CONTROL,\n\t\t\tCRTC_3D_STRUCTURE_STEREO_SEL_OVR);\n\n\t \n\n\tif (struc_en != 0 && struc_stereo_sel_ovr == 0) {\n\t\ttg->funcs->wait_for_vblank(tg);\n\t\ttg->funcs->wait_for_vactive(tg);\n\t}\n\n\tvalue = 0;\n\tdm_write_reg(tg->ctx, addr, value);\n\n\taddr = tg->regs[IDX_CRTC_STEREO_CONTROL];\n\tdm_write_reg(tg->ctx, addr, value);\n}\n#endif\n\n \nbool dce110_timing_generator_disable_crtc(struct timing_generator *tg)\n{\n\tenum bp_result result;\n\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tresult = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, false);\n\n\t \n\n\t \n\n\treturn result == BP_RESULT_OK;\n}\n\n \nstatic void program_horz_count_by_2(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing)\n{\n\tuint32_t regval;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tregval = dm_read_reg(tg->ctx,\n\t\t\tCRTC_REG(mmCRTC_COUNT_CONTROL));\n\n\tset_reg_field_value(regval, 0, CRTC_COUNT_CONTROL,\n\t\t\tCRTC_HORZ_COUNT_BY2_EN);\n\n\tif (timing->flags.HORZ_COUNT_BY_TWO)\n\t\tset_reg_field_value(regval, 1, CRTC_COUNT_CONTROL,\n\t\t\t\t\tCRTC_HORZ_COUNT_BY2_EN);\n\n\tdm_write_reg(tg->ctx,\n\t\t\tCRTC_REG(mmCRTC_COUNT_CONTROL), regval);\n}\n\n \nbool dce110_timing_generator_program_timing_generator(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *dc_crtc_timing)\n{\n\tenum bp_result result;\n\tstruct bp_hw_crtc_timing_parameters bp_params;\n\tstruct dc_crtc_timing patched_crtc_timing;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tuint32_t vsync_offset = dc_crtc_timing->v_border_bottom +\n\t\t\tdc_crtc_timing->v_front_porch;\n\tuint32_t v_sync_start = dc_crtc_timing->v_addressable + vsync_offset;\n\n\tuint32_t hsync_offset = dc_crtc_timing->h_border_right +\n\t\t\tdc_crtc_timing->h_front_porch;\n\tuint32_t h_sync_start = dc_crtc_timing->h_addressable + hsync_offset;\n\n\tmemset(&bp_params, 0, sizeof(struct bp_hw_crtc_timing_parameters));\n\n\t \n\n\tpatched_crtc_timing = *dc_crtc_timing;\n\n\tdce110_timing_generator_apply_front_porch_workaround(tg, &patched_crtc_timing);\n\n\tbp_params.controller_id = tg110->controller_id;\n\n\tbp_params.h_total = patched_crtc_timing.h_total;\n\tbp_params.h_addressable =\n\t\tpatched_crtc_timing.h_addressable;\n\tbp_params.v_total = patched_crtc_timing.v_total;\n\tbp_params.v_addressable = patched_crtc_timing.v_addressable;\n\n\tbp_params.h_sync_start = h_sync_start;\n\tbp_params.h_sync_width = patched_crtc_timing.h_sync_width;\n\tbp_params.v_sync_start = v_sync_start;\n\tbp_params.v_sync_width = patched_crtc_timing.v_sync_width;\n\n\t \n\tbp_params.h_overscan_left =\n\t\tpatched_crtc_timing.h_border_left;\n\tbp_params.h_overscan_right =\n\t\tpatched_crtc_timing.h_border_right;\n\tbp_params.v_overscan_top = patched_crtc_timing.v_border_top;\n\tbp_params.v_overscan_bottom =\n\t\tpatched_crtc_timing.v_border_bottom;\n\n\t \n\tif (patched_crtc_timing.flags.HSYNC_POSITIVE_POLARITY == 1)\n\t\tbp_params.flags.HSYNC_POSITIVE_POLARITY = 1;\n\n\tif (patched_crtc_timing.flags.VSYNC_POSITIVE_POLARITY == 1)\n\t\tbp_params.flags.VSYNC_POSITIVE_POLARITY = 1;\n\n\tif (patched_crtc_timing.flags.INTERLACE == 1)\n\t\tbp_params.flags.INTERLACE = 1;\n\n\tif (patched_crtc_timing.flags.HORZ_COUNT_BY_TWO == 1)\n\t\tbp_params.flags.HORZ_COUNT_BY_TWO = 1;\n\n\tresult = tg->bp->funcs->program_crtc_timing(tg->bp, &bp_params);\n\n\tprogram_horz_count_by_2(tg, &patched_crtc_timing);\n\n\ttg110->base.funcs->enable_advanced_request(tg, true, &patched_crtc_timing);\n\n\t \n\n\treturn result == BP_RESULT_OK;\n}\n\n \nvoid dce110_timing_generator_set_drr(\n\tstruct timing_generator *tg,\n\tconst struct drr_params *params)\n{\n\t \n\tuint32_t v_total_min = 0;\n\tuint32_t v_total_max = 0;\n\tuint32_t v_total_cntl = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tuint32_t addr = 0;\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MIN);\n\tv_total_min = dm_read_reg(tg->ctx, addr);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MAX);\n\tv_total_max = dm_read_reg(tg->ctx, addr);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_CONTROL);\n\tv_total_cntl = dm_read_reg(tg->ctx, addr);\n\n\tif (params != NULL &&\n\t\tparams->vertical_total_max > 0 &&\n\t\tparams->vertical_total_min > 0) {\n\n\t\tset_reg_field_value(v_total_max,\n\t\t\t\tparams->vertical_total_max - 1,\n\t\t\t\tCRTC_V_TOTAL_MAX,\n\t\t\t\tCRTC_V_TOTAL_MAX);\n\n\t\tset_reg_field_value(v_total_min,\n\t\t\t\tparams->vertical_total_min - 1,\n\t\t\t\tCRTC_V_TOTAL_MIN,\n\t\t\t\tCRTC_V_TOTAL_MIN);\n\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t1,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_V_TOTAL_MIN_SEL);\n\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t1,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_V_TOTAL_MAX_SEL);\n\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_FORCE_LOCK_ON_EVENT);\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_FORCE_LOCK_TO_MASTER_VSYNC);\n\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_SET_V_TOTAL_MIN_MASK_EN);\n\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_SET_V_TOTAL_MIN_MASK);\n\t} else {\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t0,\n\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\tCRTC_SET_V_TOTAL_MIN_MASK);\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_V_TOTAL_MIN_SEL);\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_V_TOTAL_MAX_SEL);\n\t\tset_reg_field_value(v_total_min,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_MIN,\n\t\t\t\tCRTC_V_TOTAL_MIN);\n\t\tset_reg_field_value(v_total_max,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_MAX,\n\t\t\t\tCRTC_V_TOTAL_MAX);\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_FORCE_LOCK_ON_EVENT);\n\t\tset_reg_field_value(v_total_cntl,\n\t\t\t\t0,\n\t\t\t\tCRTC_V_TOTAL_CONTROL,\n\t\t\t\tCRTC_FORCE_LOCK_TO_MASTER_VSYNC);\n\t}\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MIN);\n\tdm_write_reg(tg->ctx, addr, v_total_min);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MAX);\n\tdm_write_reg(tg->ctx, addr, v_total_max);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_CONTROL);\n\tdm_write_reg(tg->ctx, addr, v_total_cntl);\n}\n\nvoid dce110_timing_generator_set_static_screen_control(\n\tstruct timing_generator *tg,\n\tuint32_t event_triggers,\n\tuint32_t num_frames)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t static_screen_cntl = 0;\n\tuint32_t addr = 0;\n\n\t\n\tif (num_frames > 0xFF)\n\t\tnum_frames = 0xFF;\n\n\taddr = CRTC_REG(mmCRTC_STATIC_SCREEN_CONTROL);\n\tstatic_screen_cntl = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(static_screen_cntl,\n\t\t\t\tevent_triggers,\n\t\t\t\tCRTC_STATIC_SCREEN_CONTROL,\n\t\t\t\tCRTC_STATIC_SCREEN_EVENT_MASK);\n\n\tset_reg_field_value(static_screen_cntl,\n\t\t\t\tnum_frames,\n\t\t\t\tCRTC_STATIC_SCREEN_CONTROL,\n\t\t\t\tCRTC_STATIC_SCREEN_FRAME_COUNT);\n\n\tdm_write_reg(tg->ctx, addr, static_screen_cntl);\n}\n\n \nuint32_t dce110_timing_generator_get_vblank_counter(struct timing_generator *tg)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_STATUS_FRAME_COUNT);\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\tuint32_t field = get_reg_field_value(\n\t\t\tvalue, CRTC_STATUS_FRAME_COUNT, CRTC_FRAME_COUNT);\n\n\treturn field;\n}\n\n \nvoid dce110_timing_generator_get_position(struct timing_generator *tg,\n\tstruct crtc_position *position)\n{\n\tuint32_t value;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_STATUS_POSITION));\n\n\tposition->horizontal_count = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_STATUS_POSITION,\n\t\t\tCRTC_HORZ_COUNT);\n\n\tposition->vertical_count = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_STATUS_POSITION,\n\t\t\tCRTC_VERT_COUNT);\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_NOM_VERT_POSITION));\n\n\tposition->nominal_vcount = get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_NOM_VERT_POSITION,\n\t\t\tCRTC_VERT_COUNT_NOM);\n}\n\n \nvoid dce110_timing_generator_get_crtc_scanoutpos(\n\tstruct timing_generator *tg,\n\tuint32_t *v_blank_start,\n\tuint32_t *v_blank_end,\n\tuint32_t *h_position,\n\tuint32_t *v_position)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tstruct crtc_position position;\n\n\tuint32_t value  = dm_read_reg(tg->ctx,\n\t\t\tCRTC_REG(mmCRTC_V_BLANK_START_END));\n\n\t*v_blank_start = get_reg_field_value(value,\n\t\t\t\t\t     CRTC_V_BLANK_START_END,\n\t\t\t\t\t     CRTC_V_BLANK_START);\n\t*v_blank_end = get_reg_field_value(value,\n\t\t\t\t\t   CRTC_V_BLANK_START_END,\n\t\t\t\t\t   CRTC_V_BLANK_END);\n\n\tdce110_timing_generator_get_position(\n\t\t\ttg, &position);\n\n\t*h_position = position.horizontal_count;\n\t*v_position = position.vertical_count;\n}\n\n \nvoid dce110_timing_generator_program_blanking(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing)\n{\n\tuint32_t vsync_offset = timing->v_border_bottom +\n\t\t\ttiming->v_front_porch;\n\tuint32_t v_sync_start = timing->v_addressable + vsync_offset;\n\n\tuint32_t hsync_offset = timing->h_border_right +\n\t\t\ttiming->h_front_porch;\n\tuint32_t h_sync_start = timing->h_addressable + hsync_offset;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t value = 0;\n\tuint32_t addr = 0;\n\tuint32_t tmp = 0;\n\n\taddr = CRTC_REG(mmCRTC_H_TOTAL);\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->h_total - 1,\n\t\tCRTC_H_TOTAL,\n\t\tCRTC_H_TOTAL);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL);\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->v_total - 1,\n\t\tCRTC_V_TOTAL,\n\t\tCRTC_V_TOTAL);\n\tdm_write_reg(ctx, addr, value);\n\n\t \n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MAX);\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->v_total - 1,\n\t\tCRTC_V_TOTAL_MAX,\n\t\tCRTC_V_TOTAL_MAX);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = CRTC_REG(mmCRTC_V_TOTAL_MIN);\n\tvalue = dm_read_reg(ctx, addr);\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttiming->v_total - 1,\n\t\tCRTC_V_TOTAL_MIN,\n\t\tCRTC_V_TOTAL_MIN);\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = CRTC_REG(mmCRTC_H_BLANK_START_END);\n\tvalue = dm_read_reg(ctx, addr);\n\n\ttmp = timing->h_total -\n\t\t(h_sync_start + timing->h_border_left);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTC_H_BLANK_START_END,\n\t\tCRTC_H_BLANK_END);\n\n\ttmp = tmp + timing->h_addressable +\n\t\ttiming->h_border_left + timing->h_border_right;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTC_H_BLANK_START_END,\n\t\tCRTC_H_BLANK_START);\n\n\tdm_write_reg(ctx, addr, value);\n\n\taddr = CRTC_REG(mmCRTC_V_BLANK_START_END);\n\tvalue = dm_read_reg(ctx, addr);\n\n\ttmp = timing->v_total - (v_sync_start + timing->v_border_top);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTC_V_BLANK_START_END,\n\t\tCRTC_V_BLANK_END);\n\n\ttmp = tmp + timing->v_addressable + timing->v_border_top +\n\t\ttiming->v_border_bottom;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\ttmp,\n\t\tCRTC_V_BLANK_START_END,\n\t\tCRTC_V_BLANK_START);\n\n\tdm_write_reg(ctx, addr, value);\n}\n\nvoid dce110_timing_generator_set_test_pattern(\n\tstruct timing_generator *tg,\n\t \n\tenum controller_dp_test_pattern test_pattern,\n\tenum dc_color_depth color_depth)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t value;\n\tuint32_t addr;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tenum test_pattern_color_format bit_depth;\n\tenum test_pattern_dyn_range dyn_range;\n\tenum test_pattern_mode mode;\n\t \n\tuint32_t src_bpc = 16;\n\t \n\tuint32_t dst_bpc;\n\tuint32_t index;\n\t \n\tuint16_t src_color[6] = {0xFFFF, 0xFFFF, 0xFFFF, 0x0000,\n\t\t\t\t\t\t0x0000, 0x0000};\n\t \n\tuint16_t dst_color[6];\n\tuint32_t inc_base;\n\n\t \n\tswitch (color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_6;\n\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;\n\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_10;\n\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_12;\n\tbreak;\n\tdefault:\n\t\tbit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;\n\tbreak;\n\t}\n\n\tswitch (test_pattern) {\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORSQUARES:\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA:\n\t{\n\t\tdyn_range = (test_pattern ==\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA ?\n\t\t\t\tTEST_PATTERN_DYN_RANGE_CEA :\n\t\t\t\tTEST_PATTERN_DYN_RANGE_VESA);\n\t\tmode = TEST_PATTERN_MODE_COLORSQUARES_RGB;\n\t\tvalue = 0;\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t6,\n\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\tCRTC_TEST_PATTERN_VRES);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t6,\n\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\tCRTC_TEST_PATTERN_HRES);\n\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);\n\t\tvalue = 0;\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_EN);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tmode,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_MODE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tdyn_range,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_DYNAMIC_RANGE);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tbit_depth,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_COLOR_FORMAT);\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n\tbreak;\n\n\tcase CONTROLLER_DP_TEST_PATTERN_VERTICALBARS:\n\tcase CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS:\n\t{\n\t\tmode = (test_pattern ==\n\t\t\tCONTROLLER_DP_TEST_PATTERN_VERTICALBARS ?\n\t\t\tTEST_PATTERN_MODE_VERTICALBARS :\n\t\t\tTEST_PATTERN_MODE_HORIZONTALBARS);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t\tdst_bpc = 6;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t\tdst_bpc = 10;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (index = 0; index < 6; index++) {\n\t\t\t \n\t\t\tdst_color[index] =\n\t\t\t\tsrc_color[index] >> (src_bpc - dst_bpc);\n\t\t \n\t\t\tdst_color[index] <<= (16 - dst_bpc);\n\t\t}\n\n\t\tvalue = 0;\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\t \n\n\t\t \n\t\tvalue = 0;\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_COLOR);\n\t\tfor (index = 0; index < 6; index++) {\n\t\t\t \n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t(1 << index),\n\t\t\t\tCRTC_TEST_PATTERN_COLOR,\n\t\t\t\tCRTC_TEST_PATTERN_MASK);\n\t\t\t \n\t\t\tdm_write_reg(ctx, addr, value);\n\t\t\t \n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\tdst_color[index],\n\t\t\t\tCRTC_TEST_PATTERN_COLOR,\n\t\t\t\tCRTC_TEST_PATTERN_DATA);\n\t\t}\n\t\t \n\t\tdm_write_reg(ctx, addr, value);\n\n\t\t \n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);\n\t\tvalue = 0;\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_EN);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tmode,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_MODE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_DYNAMIC_RANGE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tbit_depth,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_COLOR_FORMAT);\n\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n\tbreak;\n\n\tcase CONTROLLER_DP_TEST_PATTERN_COLORRAMP:\n\t{\n\t\tmode = (bit_depth ==\n\t\t\tTEST_PATTERN_COLOR_FORMAT_BPC_10 ?\n\t\t\tTEST_PATTERN_MODE_DUALRAMP_RGB :\n\t\t\tTEST_PATTERN_MODE_SINGLERAMP_RGB);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t\tdst_bpc = 6;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t\tdst_bpc = 10;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdst_bpc = 8;\n\t\tbreak;\n\t\t}\n\n\t\t \n\t\tinc_base = (src_bpc - dst_bpc);\n\n\t\tvalue = 0;\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);\n\n\t\tswitch (bit_depth) {\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_6:\n\t\t{\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\tinc_base,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC0);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t0,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC1);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t6,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_HRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t6,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_VRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t0,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_RAMP0_OFFSET);\n\t\t}\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_8:\n\t\t{\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\tinc_base,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC0);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t0,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC1);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t8,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_HRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t6,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_VRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t0,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_RAMP0_OFFSET);\n\t\t}\n\t\tbreak;\n\t\tcase TEST_PATTERN_COLOR_FORMAT_BPC_10:\n\t\t{\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\tinc_base,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC0);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\tinc_base + 2,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_INC1);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t8,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_HRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t5,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_VRES);\n\t\t\tset_reg_field_value(\n\t\t\t\tvalue,\n\t\t\t\t384 << 6,\n\t\t\t\tCRTC_TEST_PATTERN_PARAMETERS,\n\t\t\t\tCRTC_TEST_PATTERN_RAMP0_OFFSET);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\tbreak;\n\t\t}\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\tvalue = 0;\n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_COLOR);\n\t\tdm_write_reg(ctx, addr, value);\n\n\t\t \n\t\taddr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);\n\t\tvalue = 0;\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_EN);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tmode,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_MODE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_DYNAMIC_RANGE);\n\t\t \n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tbit_depth,\n\t\t\tCRTC_TEST_PATTERN_CONTROL,\n\t\t\tCRTC_TEST_PATTERN_COLOR_FORMAT);\n\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n\tbreak;\n\tcase CONTROLLER_DP_TEST_PATTERN_VIDEOMODE:\n\t{\n\t\tvalue = 0;\n\t\tdm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL), value);\n\t\tdm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_COLOR), value);\n\t\tdm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS),\n\t\t\t\tvalue);\n\t}\n\tbreak;\n\tdefault:\n\tbreak;\n\t}\n}\n\n \nbool dce110_timing_generator_validate_timing(\n\tstruct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tenum signal_type signal)\n{\n\tuint32_t h_blank;\n\tuint32_t h_back_porch, hsync_offset, h_sync_start;\n\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tASSERT(timing != NULL);\n\n\tif (!timing)\n\t\treturn false;\n\n\thsync_offset = timing->h_border_right + timing->h_front_porch;\n\th_sync_start = timing->h_addressable + hsync_offset;\n\n\t \n\tif (timing->timing_3d_format != TIMING_3D_FORMAT_NONE)\n\t\treturn false;\n\n\t \n\tif (timing->flags.INTERLACE == 1)\n\t\treturn false;\n\n\t \n\tif (timing->h_total > tg110->max_h_total ||\n\t\ttiming->v_total > tg110->max_v_total)\n\t\treturn false;\n\n\th_blank = (timing->h_total - timing->h_addressable -\n\t\ttiming->h_border_right -\n\t\ttiming->h_border_left);\n\n\tif (h_blank < tg110->min_h_blank)\n\t\treturn false;\n\n\tif (timing->h_front_porch < tg110->min_h_front_porch)\n\t\treturn false;\n\n\th_back_porch = h_blank - (h_sync_start -\n\t\ttiming->h_addressable -\n\t\ttiming->h_border_right -\n\t\ttiming->h_sync_width);\n\n\tif (h_back_porch < tg110->min_h_back_porch)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid dce110_timing_generator_wait_for_vblank(struct timing_generator *tg)\n{\n\t \n\twhile (dce110_timing_generator_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (!dce110_timing_generator_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid dce110_timing_generator_wait_for_vactive(struct timing_generator *tg)\n{\n\twhile (dce110_timing_generator_is_in_vertical_blank(tg)) {\n\t\tif (!dce110_timing_generator_is_counter_moving(tg)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid dce110_timing_generator_setup_global_swap_lock(\n\tstruct timing_generator *tg,\n\tconst struct dcp_gsl_params *gsl_params)\n{\n\tuint32_t value;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t address = DCP_REG(mmDCP_GSL_CONTROL);\n\tuint32_t check_point = FLIP_READY_BACK_LOOKUP;\n\n\tvalue = dm_read_reg(tg->ctx, address);\n\n\t \n\tset_reg_field_value(value,\n\t\t\t    1,\n\t\t\t    DCP_GSL_CONTROL,\n\t\t\t    DCP_GSL0_EN);\n\n\tset_reg_field_value(value,\n\t\t\t    gsl_params->gsl_master == tg->inst,\n\t\t\t    DCP_GSL_CONTROL,\n\t\t\t    DCP_GSL_MASTER_EN);\n\n\tset_reg_field_value(value,\n\t\t\t    HFLIP_READY_DELAY,\n\t\t\t    DCP_GSL_CONTROL,\n\t\t\t    DCP_GSL_HSYNC_FLIP_FORCE_DELAY);\n\n\t \n\tset_reg_field_value(value,\n\t\t\t    HFLIP_CHECK_DELAY,\n\t\t\t    DCP_GSL_CONTROL,\n\t\t\t    DCP_GSL_HSYNC_FLIP_CHECK_DELAY);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmDCP_GSL_CONTROL), value);\n\tvalue = 0;\n\n\tset_reg_field_value(value,\n\t\t\t    gsl_params->gsl_master,\n\t\t\t    DCIO_GSL0_CNTL,\n\t\t\t    DCIO_GSL0_VSYNC_SEL);\n\n\tset_reg_field_value(value,\n\t\t\t    0,\n\t\t\t    DCIO_GSL0_CNTL,\n\t\t\t    DCIO_GSL0_TIMING_SYNC_SEL);\n\n\tset_reg_field_value(value,\n\t\t\t    0,\n\t\t\t    DCIO_GSL0_CNTL,\n\t\t\t    DCIO_GSL0_GLOBAL_UNLOCK_SEL);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmDCIO_GSL0_CNTL), value);\n\n\n\t{\n\t\tuint32_t value_crtc_vtotal;\n\n\t\tvalue_crtc_vtotal = dm_read_reg(tg->ctx,\n\t\t\t\tCRTC_REG(mmCRTC_V_TOTAL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    0, \n\t\t\t\t    DCP_GSL_CONTROL,\n\t\t\t\t    DCP_GSL_SYNC_SOURCE);\n\n\t\t \n\t\tcheck_point = get_reg_field_value(value_crtc_vtotal,\n\t\t\t\t\t\t  CRTC_V_TOTAL,\n\t\t\t\t\t\t  CRTC_V_TOTAL);\n\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_GSL_WINDOW), 0);\n\t}\n\n\tset_reg_field_value(value,\n\t\t\t    1,\n\t\t\t    DCP_GSL_CONTROL,\n\t\t\t    DCP_GSL_DELAY_SURFACE_UPDATE_PENDING);\n\n\tdm_write_reg(tg->ctx, address, value);\n\n\t \n\taddress = CRTC_REG(mmCRTC_GSL_CONTROL);\n\n\tvalue = dm_read_reg(tg->ctx, address);\n\tset_reg_field_value(value,\n\t\t\t    check_point - FLIP_READY_BACK_LOOKUP,\n\t\t\t    CRTC_GSL_CONTROL,\n\t\t\t    CRTC_GSL_CHECK_LINE_NUM);\n\n\tset_reg_field_value(value,\n\t\t\t    VFLIP_READY_DELAY,\n\t\t\t    CRTC_GSL_CONTROL,\n\t\t\t    CRTC_GSL_FORCE_DELAY);\n\n\tdm_write_reg(tg->ctx, address, value);\n}\n\nvoid dce110_timing_generator_tear_down_global_swap_lock(\n\tstruct timing_generator *tg)\n{\n\t \n\n\tuint32_t value;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t address = DCP_REG(mmDCP_GSL_CONTROL);\n\n\tvalue = 0;\n\n\t \n\t \n\tset_reg_field_value(value,\n\t\t\t0,\n\t\t\tDCP_GSL_CONTROL,\n\t\t\tDCP_GSL0_EN);\n\n\tset_reg_field_value(value,\n\t\t\t0,\n\t\t\tDCP_GSL_CONTROL,\n\t\t\tDCP_GSL_MASTER_EN);\n\n\tset_reg_field_value(value,\n\t\t\t0x2,\n\t\t\tDCP_GSL_CONTROL,\n\t\t\tDCP_GSL_HSYNC_FLIP_FORCE_DELAY);\n\n\tset_reg_field_value(value,\n\t\t\t0x6,\n\t\t\tDCP_GSL_CONTROL,\n\t\t\tDCP_GSL_HSYNC_FLIP_CHECK_DELAY);\n\n\t \n\t{\n\t\tdm_read_reg(tg->ctx, CRTC_REG(mmCRTC_V_TOTAL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t0,\n\t\t\t\tDCP_GSL_CONTROL,\n\t\t\t\tDCP_GSL_SYNC_SOURCE);\n\t}\n\n\tset_reg_field_value(value,\n\t\t\t0,\n\t\t\tDCP_GSL_CONTROL,\n\t\t\tDCP_GSL_DELAY_SURFACE_UPDATE_PENDING);\n\n\tdm_write_reg(tg->ctx, address, value);\n\n\t \n\taddress = CRTC_REG(mmCRTC_GSL_CONTROL);\n\n\tvalue = 0;\n\tset_reg_field_value(value,\n\t\t\t0,\n\t\t\tCRTC_GSL_CONTROL,\n\t\t\tCRTC_GSL_CHECK_LINE_NUM);\n\n\tset_reg_field_value(value,\n\t\t\t0x2,\n\t\t\tCRTC_GSL_CONTROL,\n\t\t\tCRTC_GSL_FORCE_DELAY);\n\n\tdm_write_reg(tg->ctx, address, value);\n}\n \nbool dce110_timing_generator_is_counter_moving(struct timing_generator *tg)\n{\n\tstruct crtc_position position1, position2;\n\n\ttg->funcs->get_position(tg, &position1);\n\ttg->funcs->get_position(tg, &position2);\n\n\tif (position1.horizontal_count == position2.horizontal_count &&\n\t\tposition1.vertical_count == position2.vertical_count)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nvoid dce110_timing_generator_enable_advanced_request(\n\tstruct timing_generator *tg,\n\tbool enable,\n\tconst struct dc_crtc_timing *timing)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_START_LINE_CONTROL);\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tif (enable) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_LEGACY_REQUESTOR_EN);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_LEGACY_REQUESTOR_EN);\n\t}\n\n\tif ((timing->v_sync_width + timing->v_front_porch) <= 3) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t3,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t0,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_PREFETCH_EN);\n\t} else {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_ADVANCED_START_LINE_POSITION);\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_START_LINE_CONTROL,\n\t\t\tCRTC_PREFETCH_EN);\n\t}\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTC_START_LINE_CONTROL,\n\t\tCRTC_PROGRESSIVE_START_LINE_EARLY);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTC_START_LINE_CONTROL,\n\t\tCRTC_INTERLACE_START_LINE_EARLY);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\n \nvoid dce110_timing_generator_set_lock_master(struct timing_generator *tg,\n\t\tbool lock)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_MASTER_UPDATE_LOCK);\n\tuint32_t value = dm_read_reg(ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tlock ? 1 : 0,\n\t\tCRTC_MASTER_UPDATE_LOCK,\n\t\tMASTER_UPDATE_LOCK);\n\n\tdm_write_reg(ctx, addr, value);\n}\n\nvoid dce110_timing_generator_enable_reset_trigger(\n\tstruct timing_generator *tg,\n\tint source_tg_inst)\n{\n\tuint32_t value;\n\tuint32_t rising_edge = 0;\n\tuint32_t falling_edge = 0;\n\tenum trigger_source_select trig_src_select = TRIGGER_SOURCE_SELECT_LOGIC_ZERO;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\t \n\t{\n\t\tuint32_t pol_value = dm_read_reg(tg->ctx,\n\t\t\t\tCRTC_REG(mmCRTC_V_SYNC_A_CNTL));\n\n\t\t \n\t\tif (get_reg_field_value(pol_value,\n\t\t\t\tCRTC_V_SYNC_A_CNTL,\n\t\t\t\tCRTC_V_SYNC_A_POL) == 0) {\n\t\t\trising_edge = 1;\n\t\t} else {\n\t\t\tfalling_edge = 1;\n\t\t}\n\t}\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));\n\n\ttrig_src_select = TRIGGER_SOURCE_SELECT_GSL_GROUP0;\n\n\tset_reg_field_value(value,\n\t\t\ttrig_src_select,\n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_SOURCE_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\tTRIGGER_POLARITY_SELECT_LOGIC_ZERO,\n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_POLARITY_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\trising_edge,\n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_RISING_EDGE_DETECT_CNTL);\n\n\tset_reg_field_value(value,\n\t\t\tfalling_edge,\n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_FALLING_EDGE_DETECT_CNTL);\n\n\tset_reg_field_value(value,\n\t\t\t0,  \n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_FREQUENCY_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\t0,  \n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_DELAY);\n\n\tset_reg_field_value(value,\n\t\t\t1,  \n\t\t\tCRTC_TRIGB_CNTL,\n\t\t\tCRTC_TRIGB_CLEAR);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);\n\n\t \n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));\n\n\tset_reg_field_value(value,\n\t\t\t2,  \n\t\t\tCRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\tCRTC_FORCE_COUNT_NOW_MODE);\n\n\tset_reg_field_value(value,\n\t\t\t1,  \n\t\t\tCRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\tCRTC_FORCE_COUNT_NOW_TRIG_SEL);\n\n\tset_reg_field_value(value,\n\t\t\t1,  \n\t\t\tCRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\tCRTC_FORCE_COUNT_NOW_CLEAR);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);\n}\n\nvoid dce110_timing_generator_enable_crtc_reset(\n\t\tstruct timing_generator *tg,\n\t\tint source_tg_inst,\n\t\tstruct crtc_trigger_info *crtc_tp)\n{\n\tuint32_t value = 0;\n\tuint32_t rising_edge = 0;\n\tuint32_t falling_edge = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\t \n\tswitch (crtc_tp->event) {\n\tcase CRTC_EVENT_VSYNC_RISING:\n\t\t\trising_edge = 1;\n\t\t\tbreak;\n\n\tcase CRTC_EVENT_VSYNC_FALLING:\n\t\tfalling_edge = 1;\n\t\tbreak;\n\t}\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));\n\n\tset_reg_field_value(value,\n\t\t\t    source_tg_inst,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_SOURCE_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\t    TRIGGER_POLARITY_SELECT_LOGIC_ZERO,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_POLARITY_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\t    rising_edge,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_RISING_EDGE_DETECT_CNTL);\n\n\tset_reg_field_value(value,\n\t\t\t    falling_edge,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_FALLING_EDGE_DETECT_CNTL);\n\n\tset_reg_field_value(value,\n\t\t\t    1,  \n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_CLEAR);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);\n\n\t \n\n\tswitch (crtc_tp->delay) {\n\tcase TRIGGER_DELAY_NEXT_LINE:\n\t\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    0,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_MODE);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    0,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_TRIG_SEL);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    1,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CLEAR);\n\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);\n\n\t\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_VERT_SYNC_CONTROL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    1,\n\t\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t\t    CRTC_FORCE_VSYNC_NEXT_LINE_CLEAR);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    2,\n\t\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t\t    CRTC_AUTO_FORCE_VSYNC_MODE);\n\n\t\tbreak;\n\n\tcase TRIGGER_DELAY_NEXT_PIXEL:\n\t\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_VERT_SYNC_CONTROL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    1,\n\t\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t\t    CRTC_FORCE_VSYNC_NEXT_LINE_CLEAR);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    0,\n\t\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t\t    CRTC_AUTO_FORCE_VSYNC_MODE);\n\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_VERT_SYNC_CONTROL), value);\n\n\t\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    2,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_MODE);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    1,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_TRIG_SEL);\n\n\t\tset_reg_field_value(value,\n\t\t\t\t    1,  \n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t    CRTC_FORCE_COUNT_NOW_CLEAR);\n\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);\n\t\tbreak;\n\t}\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_MODE));\n\n\tset_reg_field_value(value,\n\t\t\t    2,\n\t\t\t    CRTC_MASTER_UPDATE_MODE,\n\t\t\t    MASTER_UPDATE_MODE);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_MODE), value);\n}\nvoid dce110_timing_generator_disable_reset_trigger(\n\tstruct timing_generator *tg)\n{\n\tuint32_t value;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));\n\n\tset_reg_field_value(value,\n\t\t\t    0,  \n\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t    CRTC_FORCE_COUNT_NOW_MODE);\n\n\tset_reg_field_value(value,\n\t\t\t    1,  \n\t\t\t    CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t    CRTC_FORCE_COUNT_NOW_CLEAR);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);\n\n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_VERT_SYNC_CONTROL));\n\n\tset_reg_field_value(value,\n\t\t\t    1,\n\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t    CRTC_FORCE_VSYNC_NEXT_LINE_CLEAR);\n\n\tset_reg_field_value(value,\n\t\t\t    0,\n\t\t\t    CRTC_VERT_SYNC_CONTROL,\n\t\t\t    CRTC_AUTO_FORCE_VSYNC_MODE);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_VERT_SYNC_CONTROL), value);\n\n\t \n\tvalue = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));\n\n\tset_reg_field_value(value,\n\t\t\t    TRIGGER_SOURCE_SELECT_LOGIC_ZERO,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_SOURCE_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\t    TRIGGER_POLARITY_SELECT_LOGIC_ZERO,\n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_POLARITY_SELECT);\n\n\tset_reg_field_value(value,\n\t\t\t    1,  \n\t\t\t    CRTC_TRIGB_CNTL,\n\t\t\t    CRTC_TRIGB_CLEAR);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);\n}\n\n \nbool dce110_timing_generator_did_triggered_reset_occur(\n\tstruct timing_generator *tg)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t value = dm_read_reg(tg->ctx,\n\t\t\tCRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));\n\tuint32_t value1 = dm_read_reg(tg->ctx,\n\t\t\tCRTC_REG(mmCRTC_VERT_SYNC_CONTROL));\n\tbool force = get_reg_field_value(value,\n\t\t\t\t\t CRTC_FORCE_COUNT_NOW_CNTL,\n\t\t\t\t\t CRTC_FORCE_COUNT_NOW_OCCURRED) != 0;\n\tbool vert_sync = get_reg_field_value(value1,\n\t\t\t\t\t     CRTC_VERT_SYNC_CONTROL,\n\t\t\t\t\t     CRTC_FORCE_VSYNC_NEXT_LINE_OCCURRED) != 0;\n\n\treturn (force || vert_sync);\n}\n\n \nvoid dce110_timing_generator_disable_vga(\n\tstruct timing_generator *tg)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tswitch (tg110->controller_id) {\n\tcase CONTROLLER_ID_D0:\n\t\taddr = mmD1VGA_CONTROL;\n\t\tbreak;\n\tcase CONTROLLER_ID_D1:\n\t\taddr = mmD2VGA_CONTROL;\n\t\tbreak;\n\tcase CONTROLLER_ID_D2:\n\t\taddr = mmD3VGA_CONTROL;\n\t\tbreak;\n\tcase CONTROLLER_ID_D3:\n\t\taddr = mmD4VGA_CONTROL;\n\t\tbreak;\n\tcase CONTROLLER_ID_D4:\n\t\taddr = mmD5VGA_CONTROL;\n\t\tbreak;\n\tcase CONTROLLER_ID_D5:\n\t\taddr = mmD6VGA_CONTROL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tvalue = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_MODE_ENABLE);\n\tset_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_TIMING_SELECT);\n\tset_reg_field_value(\n\t\t\tvalue, 0, D1VGA_CONTROL, D1VGA_SYNC_POLARITY_SELECT);\n\tset_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_OVERSCAN_COLOR_EN);\n\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\n \nvoid dce110_timing_generator_set_overscan_color_black(\n\tstruct timing_generator *tg,\n\tconst struct tg_color *color)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t addr;\n\tuint32_t value = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_b_cb,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_BLUE);\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_r_cr,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_RED);\n\n\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\tcolor->color_g_y,\n\t\t\tCRTC_OVERSCAN_COLOR,\n\t\t\tCRTC_OVERSCAN_COLOR_GREEN);\n\n\taddr = CRTC_REG(mmCRTC_OVERSCAN_COLOR);\n\tdm_write_reg(ctx, addr, value);\n\taddr = CRTC_REG(mmCRTC_BLACK_COLOR);\n\tdm_write_reg(ctx, addr, value);\n\t \n\taddr = CRTC_REG(mmCRTC_BLANK_DATA_COLOR);\n\tdm_write_reg(ctx, addr, value);\n\n\t \n\n}\n\nvoid dce110_tg_program_blank_color(struct timing_generator *tg,\n\t\tconst struct tg_color *black_color)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);\n\tuint32_t value = dm_read_reg(tg->ctx, addr);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_b_cb,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_B_CB);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_g_y,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_G_Y);\n\tset_reg_field_value(\n\t\tvalue,\n\t\tblack_color->color_r_cr,\n\t\tCRTC_BLACK_COLOR,\n\t\tCRTC_BLACK_COLOR_R_CR);\n\n\tdm_write_reg(tg->ctx, addr, value);\n\n\taddr = CRTC_REG(mmCRTC_BLANK_DATA_COLOR);\n\tdm_write_reg(tg->ctx, addr, value);\n}\n\nvoid dce110_tg_set_overscan_color(struct timing_generator *tg,\n\tconst struct tg_color *overscan_color)\n{\n\tstruct dc_context *ctx = tg->ctx;\n\tuint32_t value = 0;\n\tuint32_t addr;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_b_cb,\n\t\tCRTC_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_BLUE);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_g_y,\n\t\tCRTC_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_GREEN);\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\toverscan_color->color_r_cr,\n\t\tCRTC_OVERSCAN_COLOR,\n\t\tCRTC_OVERSCAN_COLOR_RED);\n\n\taddr = CRTC_REG(mmCRTC_OVERSCAN_COLOR);\n\tdm_write_reg(ctx, addr, value);\n}\n\nvoid dce110_tg_program_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing,\n\tint vready_offset,\n\tint vstartup_start,\n\tint vupdate_offset,\n\tint vupdate_width,\n\tconst enum signal_type signal,\n\tbool use_vbios)\n{\n\tif (use_vbios)\n\t\tdce110_timing_generator_program_timing_generator(tg, timing);\n\telse\n\t\tdce110_timing_generator_program_blanking(tg, timing);\n}\n\nbool dce110_tg_is_blanked(struct timing_generator *tg)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_BLANK_CONTROL));\n\n\tif (get_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_BLANK_CONTROL,\n\t\t\tCRTC_BLANK_DATA_EN) == 1 &&\n\t\tget_reg_field_value(\n\t\t\tvalue,\n\t\t\tCRTC_BLANK_CONTROL,\n\t\t\tCRTC_CURRENT_BLANK_STATE) == 1)\n\t\treturn true;\n\treturn false;\n}\n\nvoid dce110_tg_set_blank(struct timing_generator *tg,\n\t\tbool enable_blanking)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t value = 0;\n\n\tset_reg_field_value(\n\t\tvalue,\n\t\t1,\n\t\tCRTC_DOUBLE_BUFFER_CONTROL,\n\t\tCRTC_BLANK_DATA_DOUBLE_BUFFER_EN);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_DOUBLE_BUFFER_CONTROL), value);\n\tvalue = 0;\n\n\tif (enable_blanking) {\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t1,\n\t\t\tCRTC_BLANK_CONTROL,\n\t\t\tCRTC_BLANK_DATA_EN);\n\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_BLANK_CONTROL), value);\n\n\t} else\n\t\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_BLANK_CONTROL), 0);\n}\n\nbool dce110_tg_validate_timing(struct timing_generator *tg,\n\tconst struct dc_crtc_timing *timing)\n{\n\treturn dce110_timing_generator_validate_timing(tg, timing, SIGNAL_TYPE_NONE);\n}\n\nvoid dce110_tg_wait_for_state(struct timing_generator *tg,\n\tenum crtc_state state)\n{\n\tswitch (state) {\n\tcase CRTC_STATE_VBLANK:\n\t\tdce110_timing_generator_wait_for_vblank(tg);\n\t\tbreak;\n\n\tcase CRTC_STATE_VACTIVE:\n\t\tdce110_timing_generator_wait_for_vactive(tg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid dce110_tg_set_colors(struct timing_generator *tg,\n\tconst struct tg_color *blank_color,\n\tconst struct tg_color *overscan_color)\n{\n\tif (blank_color != NULL)\n\t\tdce110_tg_program_blank_color(tg, blank_color);\n\tif (overscan_color != NULL)\n\t\tdce110_tg_set_overscan_color(tg, overscan_color);\n}\n\n \nbool dce110_arm_vert_intr(struct timing_generator *tg, uint8_t width)\n{\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\tuint32_t v_blank_start = 0;\n\tuint32_t v_blank_end = 0;\n\tuint32_t val = 0;\n\tuint32_t h_position, v_position;\n\n\ttg->funcs->get_scanoutpos(\n\t\t\ttg,\n\t\t\t&v_blank_start,\n\t\t\t&v_blank_end,\n\t\t\t&h_position,\n\t\t\t&v_position);\n\n\tif (v_blank_start == 0 || v_blank_end == 0)\n\t\treturn false;\n\n\tset_reg_field_value(\n\t\tval,\n\t\tv_blank_start,\n\t\tCRTC_VERTICAL_INTERRUPT0_POSITION,\n\t\tCRTC_VERTICAL_INTERRUPT0_LINE_START);\n\n\t \n\tset_reg_field_value(\n\t\tval,\n\t\tv_blank_start + width,\n\t\tCRTC_VERTICAL_INTERRUPT0_POSITION,\n\t\tCRTC_VERTICAL_INTERRUPT0_LINE_END);\n\n\tdm_write_reg(tg->ctx, CRTC_REG(mmCRTC_VERTICAL_INTERRUPT0_POSITION), val);\n\n\treturn true;\n}\n\nstatic bool dce110_is_tg_enabled(struct timing_generator *tg)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\tuint32_t field = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\taddr = CRTC_REG(mmCRTC_CONTROL);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tfield = get_reg_field_value(value, CRTC_CONTROL,\n\t\t\t\t    CRTC_CURRENT_MASTER_EN_STATE);\n\treturn field == 1;\n}\n\nbool dce110_configure_crc(struct timing_generator *tg,\n\t\t\t  const struct crc_params *params)\n{\n\tuint32_t cntl_addr = 0;\n\tuint32_t addr = 0;\n\tuint32_t value;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\t \n\tif (!dce110_is_tg_enabled(tg))\n\t\treturn false;\n\n\tcntl_addr = CRTC_REG(mmCRTC_CRC_CNTL);\n\n\t \n\tdm_write_reg(tg->ctx, cntl_addr, 0);\n\n\tif (!params->enable)\n\t\treturn true;\n\n\t \n\t \n\tvalue = 0;\n\taddr = CRTC_REG(mmCRTC_CRC0_WINDOWA_X_CONTROL);\n\tset_reg_field_value(value, params->windowa_x_start,\n\t\t\t    CRTC_CRC0_WINDOWA_X_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWA_X_START);\n\tset_reg_field_value(value, params->windowa_x_end,\n\t\t\t    CRTC_CRC0_WINDOWA_X_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWA_X_END);\n\tdm_write_reg(tg->ctx, addr, value);\n\n\t \n\tvalue = 0;\n\taddr = CRTC_REG(mmCRTC_CRC0_WINDOWA_Y_CONTROL);\n\tset_reg_field_value(value, params->windowa_y_start,\n\t\t\t    CRTC_CRC0_WINDOWA_Y_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWA_Y_START);\n\tset_reg_field_value(value, params->windowa_y_end,\n\t\t\t    CRTC_CRC0_WINDOWA_Y_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWA_Y_END);\n\tdm_write_reg(tg->ctx, addr, value);\n\n\t \n\tvalue = 0;\n\taddr = CRTC_REG(mmCRTC_CRC0_WINDOWB_X_CONTROL);\n\tset_reg_field_value(value, params->windowb_x_start,\n\t\t\t    CRTC_CRC0_WINDOWB_X_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWB_X_START);\n\tset_reg_field_value(value, params->windowb_x_end,\n\t\t\t    CRTC_CRC0_WINDOWB_X_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWB_X_END);\n\tdm_write_reg(tg->ctx, addr, value);\n\n\t \n\tvalue = 0;\n\taddr = CRTC_REG(mmCRTC_CRC0_WINDOWB_Y_CONTROL);\n\tset_reg_field_value(value, params->windowb_y_start,\n\t\t\t    CRTC_CRC0_WINDOWB_Y_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWB_Y_START);\n\tset_reg_field_value(value, params->windowb_y_end,\n\t\t\t    CRTC_CRC0_WINDOWB_Y_CONTROL,\n\t\t\t    CRTC_CRC0_WINDOWB_Y_END);\n\tdm_write_reg(tg->ctx, addr, value);\n\n\t \n\tvalue = 0;\n\tset_reg_field_value(value, params->continuous_mode ? 1 : 0,\n\t\t\t    CRTC_CRC_CNTL, CRTC_CRC_CONT_EN);\n\tset_reg_field_value(value, params->selection,\n\t\t\t    CRTC_CRC_CNTL, CRTC_CRC0_SELECT);\n\tset_reg_field_value(value, 1, CRTC_CRC_CNTL, CRTC_CRC_EN);\n\tdm_write_reg(tg->ctx, cntl_addr, value);\n\n\treturn true;\n}\n\nbool dce110_get_crc(struct timing_generator *tg,\n\t\t    uint32_t *r_cr, uint32_t *g_y, uint32_t *b_cb)\n{\n\tuint32_t addr = 0;\n\tuint32_t value = 0;\n\tuint32_t field = 0;\n\tstruct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);\n\n\taddr = CRTC_REG(mmCRTC_CRC_CNTL);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\tfield = get_reg_field_value(value, CRTC_CRC_CNTL, CRTC_CRC_EN);\n\n\t \n\tif (!field)\n\t\treturn false;\n\n\taddr = CRTC_REG(mmCRTC_CRC0_DATA_RG);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\t*r_cr = get_reg_field_value(value, CRTC_CRC0_DATA_RG, CRC0_R_CR);\n\t*g_y = get_reg_field_value(value, CRTC_CRC0_DATA_RG, CRC0_G_Y);\n\n\taddr = CRTC_REG(mmCRTC_CRC0_DATA_B);\n\tvalue = dm_read_reg(tg->ctx, addr);\n\t*b_cb = get_reg_field_value(value, CRTC_CRC0_DATA_B, CRC0_B_CB);\n\n\treturn true;\n}\n\nstatic const struct timing_generator_funcs dce110_tg_funcs = {\n\t\t.validate_timing = dce110_tg_validate_timing,\n\t\t.program_timing = dce110_tg_program_timing,\n\t\t.enable_crtc = dce110_timing_generator_enable_crtc,\n\t\t.disable_crtc = dce110_timing_generator_disable_crtc,\n\t\t.is_counter_moving = dce110_timing_generator_is_counter_moving,\n\t\t.get_position = dce110_timing_generator_get_position,\n\t\t.get_frame_count = dce110_timing_generator_get_vblank_counter,\n\t\t.get_scanoutpos = dce110_timing_generator_get_crtc_scanoutpos,\n\t\t.set_early_control = dce110_timing_generator_set_early_control,\n\t\t.wait_for_state = dce110_tg_wait_for_state,\n\t\t.set_blank = dce110_tg_set_blank,\n\t\t.is_blanked = dce110_tg_is_blanked,\n\t\t.set_colors = dce110_tg_set_colors,\n\t\t.set_overscan_blank_color =\n\t\t\t\tdce110_timing_generator_set_overscan_color_black,\n\t\t.set_blank_color = dce110_timing_generator_program_blank_color,\n\t\t.disable_vga = dce110_timing_generator_disable_vga,\n\t\t.did_triggered_reset_occur =\n\t\t\t\tdce110_timing_generator_did_triggered_reset_occur,\n\t\t.setup_global_swap_lock =\n\t\t\t\tdce110_timing_generator_setup_global_swap_lock,\n\t\t.enable_reset_trigger = dce110_timing_generator_enable_reset_trigger,\n\t\t.enable_crtc_reset = dce110_timing_generator_enable_crtc_reset,\n\t\t.disable_reset_trigger = dce110_timing_generator_disable_reset_trigger,\n\t\t.tear_down_global_swap_lock =\n\t\t\t\tdce110_timing_generator_tear_down_global_swap_lock,\n\t\t.enable_advanced_request =\n\t\t\t\tdce110_timing_generator_enable_advanced_request,\n\t\t.set_drr =\n\t\t\t\tdce110_timing_generator_set_drr,\n\t\t.get_last_used_drr_vtotal = NULL,\n\t\t.set_static_screen_control =\n\t\t\tdce110_timing_generator_set_static_screen_control,\n\t\t.set_test_pattern = dce110_timing_generator_set_test_pattern,\n\t\t.arm_vert_intr = dce110_arm_vert_intr,\n\t\t.is_tg_enabled = dce110_is_tg_enabled,\n\t\t.configure_crc = dce110_configure_crc,\n\t\t.get_crc = dce110_get_crc,\n};\n\nvoid dce110_timing_generator_construct(\n\tstruct dce110_timing_generator *tg110,\n\tstruct dc_context *ctx,\n\tuint32_t instance,\n\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\ttg110->controller_id = CONTROLLER_ID_D0 + instance;\n\ttg110->base.inst = instance;\n\n\ttg110->offsets = *offsets;\n\n\ttg110->base.funcs = &dce110_tg_funcs;\n\n\ttg110->base.ctx = ctx;\n\ttg110->base.bp = ctx->dc_bios;\n\n\ttg110->max_h_total = CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1;\n\ttg110->max_v_total = CRTC_V_TOTAL__CRTC_V_TOTAL_MASK + 1;\n\n\ttg110->min_h_blank = 56;\n\ttg110->min_h_front_porch = 4;\n\ttg110->min_h_back_porch = 4;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}