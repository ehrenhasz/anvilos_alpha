{
  "module_name": "rn_clk_mgr.c",
  "hash_id": "1422eab9e86a0125d51cf04fe844fa54a218ed7049d1b6d14eb4ab126335a88d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn21/rn_clk_mgr.c",
  "human_readable_source": " \n\n#include \"dccg.h\"\n#include \"rn_clk_mgr.h\"\n\n#include \"dcn20/dcn20_clk_mgr.h\"\n#include \"dml/dcn20/dcn20_fpu.h\"\n\n#include \"dce100/dce_clk_mgr.h\"\n#include \"rn_clk_mgr_vbios_smu.h\"\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n\n#include \"atomfirmware.h\"\n#include \"clk/clk_10_0_2_offset.h\"\n#include \"clk/clk_10_0_2_sh_mask.h\"\n#include \"renoir_ip_offset.h\"\n\n\n \n\n#define SMU_VER_55_51_0 0x373300  \n\n \n\n#define REG(reg_name) \\\n\t(CLK_BASE.instance[0].segment[mm ## reg_name ## _BASE_IDX] + mm ## reg_name)\n\n\n \nstatic int rn_get_active_display_cnt_wa(struct dc *dc, struct dc_state *context)\n{\n\tint i, display_count;\n\tbool tmds_present = false;\n\n\tdisplay_count = 0;\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tconst struct dc_stream_state *stream = context->streams[i];\n\n\t\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\ttmds_present = true;\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tconst struct dc_link *link = dc->links[i];\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t    link->link_enc->funcs->is_dig_enabled(link->link_enc))\n\t\t\tdisplay_count++;\n\t}\n\n\t \n\tif (display_count == 0 && tmds_present)\n\t\tdisplay_count = 1;\n\n\treturn display_count;\n}\n\nstatic void rn_set_low_power_state(struct clk_mgr *clk_mgr_base)\n{\n\tint display_count;\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tstruct dc_state *context = dc->current_state;\n\n\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_LOW_POWER) {\n\n\t\tdisplay_count = rn_get_active_display_cnt_wa(dc, context);\n\n\t\t \n\t\tif (display_count == 0) {\n\t\t\trn_vbios_smu_set_dcn_low_power_state(clk_mgr, DCN_PWR_STATE_LOW_POWER);\n\t\t\t \n\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_LOW_POWER;\n\t\t}\n\t}\n}\n\nstatic void rn_update_clocks_update_dpp_dto(struct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context, int ref_dpp_clk, bool safe_to_lower)\n{\n\tint i;\n\n\tclk_mgr->dccg->ref_dppclk = ref_dpp_clk;\n\n\tfor (i = 0; i < clk_mgr->base.ctx->dc->res_pool->pipe_count; i++) {\n\t\tint dpp_inst, dppclk_khz, prev_dppclk_khz;\n\n\t\t \n\t\tdpp_inst = clk_mgr->base.ctx->dc->res_pool->dpps[i]->inst;\n\t\tdppclk_khz = context->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz;\n\n\t\tprev_dppclk_khz = clk_mgr->dccg->pipe_dppclk_khz[dpp_inst];\n\n\t\tif (safe_to_lower || prev_dppclk_khz < dppclk_khz)\n\t\t\tclk_mgr->dccg->funcs->update_dpp_dto(\n\t\t\t\t\t\t\tclk_mgr->dccg, dpp_inst, dppclk_khz);\n\t}\n}\n\n\nstatic void rn_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool dpp_clock_lowered = false;\n\n\tstruct dmcu *dmcu = clk_mgr_base->ctx->dc->res_pool->dmcu;\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\t \n\tif (safe_to_lower && !dc->debug.disable_48mhz_pwrdwn) {\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_LOW_POWER) {\n\n\t\t\tdisplay_count = rn_get_active_display_cnt_wa(dc, context);\n\n\t\t\t \n\t\t\tif (display_count == 0) {\n\t\t\t\trn_vbios_smu_set_dcn_low_power_state(clk_mgr, DCN_PWR_STATE_LOW_POWER);\n\t\t\t\t \n\t\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_LOW_POWER;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_MISSION_MODE) {\n\t\t\trn_vbios_smu_set_dcn_low_power_state(clk_mgr, DCN_PWR_STATE_MISSION_MODE);\n\t\t\t \n\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_MISSION_MODE;\n\t\t}\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\trn_vbios_smu_set_hard_min_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_khz);\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz)) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\trn_vbios_smu_set_min_deep_sleep_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_deep_sleep_khz);\n\t}\n\n\t \n\t \n\tif (new_clocks->dppclk_khz < 100000 && new_clocks->dppclk_khz > 0)\n\t\tnew_clocks->dppclk_khz = 100000;\n\n\t \n\tif (new_clocks->dppclk_khz == 0 || new_clocks->dispclk_khz == 0) {\n\t\tnew_clocks->dppclk_khz = clk_mgr_base->clks.dppclk_khz;\n\t\tnew_clocks->dispclk_khz = clk_mgr_base->clks.dispclk_khz;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr_base->clks.dppclk_khz)) {\n\t\tif (clk_mgr_base->clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\t\tclk_mgr_base->clks.dppclk_khz = new_clocks->dppclk_khz;\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t\tclk_mgr_base->clks.actual_dispclk_khz = rn_vbios_smu_set_dispclk(clk_mgr, clk_mgr_base->clks.dispclk_khz);\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (dpp_clock_lowered) {\n\t\t \n\t\trn_update_clocks_update_dpp_dto(\n\t\t\t\tclk_mgr,\n\t\t\t\tcontext,\n\t\t\t\tclk_mgr_base->clks.dppclk_khz,\n\t\t\t\tsafe_to_lower);\n\n\t\tclk_mgr_base->clks.actual_dppclk_khz =\n\t\t\t\trn_vbios_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\n\t\t \n\t\trn_update_clocks_update_dpp_dto(\n\t\t\t\tclk_mgr,\n\t\t\t\tcontext,\n\t\t\t\tclk_mgr_base->clks.actual_dppclk_khz,\n\t\t\t\tsafe_to_lower);\n\n\t} else {\n\t\t \n\t\tif (update_dppclk || update_dispclk)\n\t\t\tclk_mgr_base->clks.actual_dppclk_khz =\n\t\t\t\t\trn_vbios_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\n\t\t \n\t\trn_update_clocks_update_dpp_dto(\n\t\t\t\tclk_mgr,\n\t\t\t\tcontext,\n\t\t\t\tclk_mgr_base->clks.actual_dppclk_khz,\n\t\t\t\tsafe_to_lower);\n\t}\n\n\tif (update_dispclk &&\n\t\t\tdmcu && dmcu->funcs->is_dmcu_initialized(dmcu)) {\n\t\t \n\t\tdmcu->funcs->set_psr_wait_loop(dmcu,\n\t\t\tclk_mgr_base->clks.dispclk_khz / 1000 / 7);\n\t}\n}\n\nstatic int get_vco_frequency_from_reg(struct clk_mgr_internal *clk_mgr)\n{\n\t \n\tstruct fixed31_32 pll_req;\n\tunsigned int fbmult_frac_val = 0;\n\tunsigned int fbmult_int_val = 0;\n\n\n\t \n\n\tREG_GET(CLK1_CLK_PLL_REQ, FbMult_frac, &fbmult_frac_val);  \n\tREG_GET(CLK1_CLK_PLL_REQ, FbMult_int, &fbmult_int_val);  \n\n\tpll_req = dc_fixpt_from_int(fbmult_int_val);\n\n\t \n\tpll_req.value |= fbmult_frac_val << 16;\n\n\t \n\tpll_req = dc_fixpt_mul_int(pll_req, clk_mgr->dfs_ref_freq_khz);\n\n\t \n\treturn dc_fixpt_floor(pll_req);\n}\n\nstatic void rn_dump_clk_registers_internal(struct rn_clk_internal *internal, struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tinternal->CLK1_CLK3_CURRENT_CNT = REG_READ(CLK1_CLK3_CURRENT_CNT);\n\tinternal->CLK1_CLK3_BYPASS_CNTL = REG_READ(CLK1_CLK3_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK3_DS_CNTL = REG_READ(CLK1_CLK3_DS_CNTL);\t \n\tinternal->CLK1_CLK3_ALLOW_DS = REG_READ(CLK1_CLK3_ALLOW_DS);\n\n\tinternal->CLK1_CLK1_CURRENT_CNT = REG_READ(CLK1_CLK1_CURRENT_CNT);\n\tinternal->CLK1_CLK1_BYPASS_CNTL = REG_READ(CLK1_CLK1_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK2_CURRENT_CNT = REG_READ(CLK1_CLK2_CURRENT_CNT);\n\tinternal->CLK1_CLK2_BYPASS_CNTL = REG_READ(CLK1_CLK2_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK0_CURRENT_CNT = REG_READ(CLK1_CLK0_CURRENT_CNT);\n\tinternal->CLK1_CLK0_BYPASS_CNTL = REG_READ(CLK1_CLK0_BYPASS_CNTL);\n}\n\n \nstatic void rn_dump_clk_registers(struct clk_state_registers_and_bypass *regs_and_bypass,\n\t\tstruct clk_mgr *clk_mgr_base, struct clk_log_info *log_info)\n{\n\tstruct rn_clk_internal internal = {0};\n\tchar *bypass_clks[5] = {\"0x0 DFS\", \"0x1 REFCLK\", \"0x2 ERROR\", \"0x3 400 FCH\", \"0x4 600 FCH\"};\n\tunsigned int chars_printed = 0;\n\tunsigned int remaining_buffer = log_info->bufSize;\n\n\trn_dump_clk_registers_internal(&internal, clk_mgr_base);\n\n\tregs_and_bypass->dcfclk = internal.CLK1_CLK3_CURRENT_CNT / 10;\n\tregs_and_bypass->dcf_deep_sleep_divider = internal.CLK1_CLK3_DS_CNTL / 10;\n\tregs_and_bypass->dcf_deep_sleep_allow = internal.CLK1_CLK3_ALLOW_DS;\n\tregs_and_bypass->dprefclk = internal.CLK1_CLK2_CURRENT_CNT / 10;\n\tregs_and_bypass->dispclk = internal.CLK1_CLK0_CURRENT_CNT / 10;\n\tregs_and_bypass->dppclk = internal.CLK1_CLK1_CURRENT_CNT / 10;\n\n\tregs_and_bypass->dppclk_bypass = internal.CLK1_CLK1_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dppclk_bypass < 0 || regs_and_bypass->dppclk_bypass > 4)\n\t\tregs_and_bypass->dppclk_bypass = 0;\n\tregs_and_bypass->dcfclk_bypass = internal.CLK1_CLK3_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dcfclk_bypass < 0 || regs_and_bypass->dcfclk_bypass > 4)\n\t\tregs_and_bypass->dcfclk_bypass = 0;\n\tregs_and_bypass->dispclk_bypass = internal.CLK1_CLK0_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dispclk_bypass < 0 || regs_and_bypass->dispclk_bypass > 4)\n\t\tregs_and_bypass->dispclk_bypass = 0;\n\tregs_and_bypass->dprefclk_bypass = internal.CLK1_CLK2_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dprefclk_bypass < 0 || regs_and_bypass->dprefclk_bypass > 4)\n\t\tregs_and_bypass->dprefclk_bypass = 0;\n\n\tif (log_info->enabled) {\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"clk_type,clk_value,deepsleep_cntl,deepsleep_allow,bypass\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dcfclk,%d,%d,%d,%s\\n\",\n\t\t\tregs_and_bypass->dcfclk,\n\t\t\tregs_and_bypass->dcf_deep_sleep_divider,\n\t\t\tregs_and_bypass->dcf_deep_sleep_allow,\n\t\t\tbypass_clks[(int) regs_and_bypass->dcfclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dprefclk,%d,N/A,N/A,%s\\n\",\n\t\t\tregs_and_bypass->dprefclk,\n\t\t\tbypass_clks[(int) regs_and_bypass->dprefclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dispclk,%d,N/A,N/A,%s\\n\",\n\t\t\tregs_and_bypass->dispclk,\n\t\t\tbypass_clks[(int) regs_and_bypass->dispclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\t \n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"SPLIT\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\t \n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"reg_name,value,clk_type\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_CURRENT_CNT,%d,dcfclk\\n\",\n\t\t\t\tinternal.CLK1_CLK3_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_DS_CNTL,%d,dcf_deep_sleep_divider\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_DS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_ALLOW_DS,%d,dcf_deep_sleep_allow\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_ALLOW_DS);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK2_CURRENT_CNT,%d,dprefclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK2_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK0_CURRENT_CNT,%d,dispclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK0_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK1_CURRENT_CNT,%d,dppclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK1_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_BYPASS_CNTL,%d,dcfclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK2_BYPASS_CNTL,%d,dprefclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK2_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK0_BYPASS_CNTL,%d,dispclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK0_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK1_BYPASS_CNTL,%d,dppclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK1_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\t}\n}\n\nstatic void rn_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\trn_vbios_smu_enable_pme_wa(clk_mgr);\n}\n\nstatic void rn_init_clocks(struct clk_mgr *clk_mgr)\n{\n\tmemset(&(clk_mgr->clks), 0, sizeof(struct dc_clocks));\n\t \n\tclk_mgr->clks.p_state_change_support = true;\n\tclk_mgr->clks.prev_p_state_change_support = true;\n\tclk_mgr->clks.pwr_state = DCN_PWR_STATE_UNKNOWN;\n}\n\nstatic void build_watermark_ranges(struct clk_bw_params *bw_params, struct pp_smu_wm_range_sets *ranges)\n{\n\tint i, num_valid_sets;\n\n\tnum_valid_sets = 0;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\t \n\t\tif (!bw_params->wm_table.entries[i].valid)\n\t\t\tcontinue;\n\n\t\tranges->reader_wm_sets[num_valid_sets].wm_inst = bw_params->wm_table.entries[i].wm_inst;\n\t\tranges->reader_wm_sets[num_valid_sets].wm_type = bw_params->wm_table.entries[i].wm_type;\n\t\t \n\t\tranges->reader_wm_sets[num_valid_sets].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\tranges->reader_wm_sets[num_valid_sets].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t \n\n\t\tif (ranges->reader_wm_sets[num_valid_sets].wm_type == WM_TYPE_PSTATE_CHG) {\n\t\t\tif (i == 0)\n\t\t\t\tranges->reader_wm_sets[num_valid_sets].min_drain_clk_mhz = 0;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tranges->reader_wm_sets[num_valid_sets].min_drain_clk_mhz = bw_params->clk_table.entries[i - 1].dcfclk_mhz + 1;\n\t\t\t}\n\t\t\tranges->reader_wm_sets[num_valid_sets].max_drain_clk_mhz = bw_params->clk_table.entries[i].dcfclk_mhz;\n\n\t\t} else {\n\t\t\t \n\t\t\tranges->reader_wm_sets[num_valid_sets].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges->reader_wm_sets[num_valid_sets].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t\t\t \n\t\t\tranges->reader_wm_sets[num_valid_sets - 1].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t}\n\t\tnum_valid_sets++;\n\t}\n\n\tASSERT(num_valid_sets != 0);  \n\tranges->num_reader_wm_sets = num_valid_sets;\n\n\t \n\tranges->reader_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\tranges->reader_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\tranges->reader_wm_sets[ranges->num_reader_wm_sets - 1].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\tranges->reader_wm_sets[ranges->num_reader_wm_sets - 1].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t \n\tranges->num_writer_wm_sets = 1;\n\tranges->writer_wm_sets[0].wm_inst = WM_A;\n\tranges->writer_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\tranges->writer_wm_sets[0].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\tranges->writer_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\tranges->writer_wm_sets[0].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n}\n\nstatic void rn_notify_wm_ranges(struct clk_mgr *clk_mgr_base)\n{\n\tstruct dc_debug_options *debug = &clk_mgr_base->ctx->dc->debug;\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct pp_smu_funcs *pp_smu = clk_mgr->pp_smu;\n\n\tif (!debug->disable_pplib_wm_range) {\n\t\tbuild_watermark_ranges(clk_mgr_base->bw_params, &clk_mgr_base->ranges);\n\n\t\t \n\t\tif (pp_smu && pp_smu->rn_funcs.set_wm_ranges)\n\t\t\tpp_smu->rn_funcs.set_wm_ranges(&pp_smu->rn_funcs.pp_smu, &clk_mgr_base->ranges);\n\t}\n\n}\n\nstatic bool rn_are_clock_states_equal(struct dc_clocks *a,\n\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n \nstatic void rn_notify_link_rate_change(struct clk_mgr *clk_mgr_base, struct dc_link *link)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tunsigned int i, max_phyclk_req = 0;\n\n\tclk_mgr->cur_phyclk_req_table[link->link_index] = link->cur_link_settings.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;\n\n\tfor (i = 0; i < MAX_PIPES * 2; i++) {\n\t\tif (clk_mgr->cur_phyclk_req_table[i] > max_phyclk_req)\n\t\t\tmax_phyclk_req = clk_mgr->cur_phyclk_req_table[i];\n\t}\n\n\tif (max_phyclk_req != clk_mgr_base->clks.phyclk_khz) {\n\t\tclk_mgr_base->clks.phyclk_khz = max_phyclk_req;\n\t\trn_vbios_smu_set_phyclk(clk_mgr, clk_mgr_base->clks.phyclk_khz);\n\t}\n}\n\nstatic struct clk_mgr_funcs dcn21_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = rn_update_clocks,\n\t.init_clocks = rn_init_clocks,\n\t.enable_pme_wa = rn_enable_pme_wa,\n\t.are_clock_states_equal = rn_are_clock_states_equal,\n\t.set_low_power_state = rn_set_low_power_state,\n\t.notify_wm_ranges = rn_notify_wm_ranges,\n\t.notify_link_rate_change = rn_notify_link_rate_change,\n};\n\nstatic struct clk_bw_params rn_bw_params = {\n\t.vram_type = Ddr4MemType,\n\t.num_channels = 1,\n\t.clk_table = {\n\t\t.entries = {\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 400,\n\t\t\t\t.fclk_mhz = 400,\n\t\t\t\t.memclk_mhz = 800,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 483,\n\t\t\t\t.fclk_mhz = 800,\n\t\t\t\t.memclk_mhz = 1600,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 602,\n\t\t\t\t.fclk_mhz = 1067,\n\t\t\t\t.memclk_mhz = 1067,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 738,\n\t\t\t\t.fclk_mhz = 1333,\n\t\t\t\t.memclk_mhz = 1600,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t},\n\n\t\t.num_entries = 4,\n\t},\n\n};\n\nstatic unsigned int find_socclk_for_voltage(struct dpm_clocks *clock_table, unsigned int voltage)\n{\n\tint i;\n\n\tfor (i = 0; i < PP_SMU_NUM_SOCCLK_DPM_LEVELS; i++) {\n\t\tif (clock_table->SocClocks[i].Vol == voltage)\n\t\t\treturn clock_table->SocClocks[i].Freq;\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}\n\nstatic unsigned int find_dcfclk_for_voltage(struct dpm_clocks *clock_table, unsigned int voltage)\n{\n\tint i;\n\n\tfor (i = 0; i < PP_SMU_NUM_DCFCLK_DPM_LEVELS; i++) {\n\t\tif (clock_table->DcfClocks[i].Vol == voltage)\n\t\t\treturn clock_table->DcfClocks[i].Freq;\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}\n\nstatic void rn_clk_mgr_helper_populate_bw_params(struct clk_bw_params *bw_params, struct dpm_clocks *clock_table, struct integrated_info *bios_info)\n{\n\tint i, j = 0;\n\n\tj = -1;\n\n\tASSERT(PP_SMU_NUM_FCLK_DPM_LEVELS <= MAX_NUM_DPM_LVL);\n\n\t \n\n\tfor (i = PP_SMU_NUM_FCLK_DPM_LEVELS - 1; i >= 0; i--) {\n\t\tif (clock_table->FClocks[i].Freq != 0 && clock_table->FClocks[i].Vol != 0) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j == -1) {\n\t\t \n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tbw_params->clk_table.num_entries = j + 1;\n\n\tfor (i = 0; i < bw_params->clk_table.num_entries; i++, j--) {\n\t\tbw_params->clk_table.entries[i].fclk_mhz = clock_table->FClocks[j].Freq;\n\t\tbw_params->clk_table.entries[i].memclk_mhz = clock_table->MemClocks[j].Freq;\n\t\tbw_params->clk_table.entries[i].voltage = clock_table->FClocks[j].Vol;\n\t\tbw_params->clk_table.entries[i].dcfclk_mhz = find_dcfclk_for_voltage(clock_table, clock_table->FClocks[j].Vol);\n\t\tbw_params->clk_table.entries[i].socclk_mhz = find_socclk_for_voltage(clock_table,\n\t\t\t\t\t\t\t\t\tbw_params->clk_table.entries[i].voltage);\n\t}\n\n\tbw_params->vram_type = bios_info->memory_type;\n\tbw_params->num_channels = bios_info->ma_channel_number;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\tbw_params->wm_table.entries[i].wm_inst = i;\n\n\t\tif (i >= bw_params->clk_table.num_entries) {\n\t\t\tbw_params->wm_table.entries[i].valid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbw_params->wm_table.entries[i].wm_type = WM_TYPE_PSTATE_CHG;\n\t\tbw_params->wm_table.entries[i].valid = true;\n\t}\n\n\tif (bw_params->vram_type == LpDdr4MemType) {\n\t\t \n\t\tDC_FP_START();\n\t\tdcn21_clk_mgr_set_bw_params_wm_table(bw_params);\n\t\tDC_FP_END();\n\t}\n}\n\nvoid rn_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct dc_debug_options *debug = &ctx->dc->debug;\n\tstruct dpm_clocks clock_table = { 0 };\n\tenum pp_smu_status status = 0;\n\tint is_green_sardine = 0;\n\tstruct clk_log_info log_info = {0};\n\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\tis_green_sardine = ASICREV_IS_GREEN_SARDINE(ctx->asic_id.hw_internal_rev);\n#endif\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn21_funcs;\n\n\tclk_mgr->pp_smu = pp_smu;\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->dfs_ref_freq_khz = 48000;\n\n\tclk_mgr->smu_ver = rn_vbios_smu_get_smu_version(clk_mgr);\n\n\tclk_mgr->periodic_retraining_disabled = rn_vbios_smu_is_periodic_retraining_disabled(clk_mgr);\n\n\t \n\tif (clk_mgr->smu_ver >= SMU_VER_55_51_0)\n\t\tdebug->min_disp_clk_khz = 0;\n\n\t \n\tclk_mgr->base.dentist_vco_freq_khz = get_vco_frequency_from_reg(clk_mgr);\n\n\t \n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 3600000;\n\n\tif (ctx->dc_bios->integrated_info->memory_type == LpDdr4MemType) {\n\t\tif (clk_mgr->periodic_retraining_disabled) {\n\t\t\trn_bw_params.wm_table = lpddr4_wm_table_with_disabled_ppt;\n\t\t} else {\n\t\t\tif (is_green_sardine)\n\t\t\t\trn_bw_params.wm_table = lpddr4_wm_table_gs;\n\t\t\telse\n\t\t\t\trn_bw_params.wm_table = lpddr4_wm_table_rn;\n\t\t}\n\t} else {\n\t\tif (is_green_sardine)\n\t\t\trn_bw_params.wm_table = ddr4_wm_table_gs;\n\t\telse {\n\t\t\tif (ctx->dc->config.is_single_rank_dimm)\n\t\t\t\trn_bw_params.wm_table = ddr4_1R_wm_table_rn;\n\t\t\telse\n\t\t\t\trn_bw_params.wm_table = ddr4_wm_table_rn;\n\t\t}\n\t}\n\t \n\trn_dump_clk_registers(&clk_mgr->base.boot_snapshot, &clk_mgr->base, &log_info);\n\n\tclk_mgr->base.dprefclk_khz = 600000;\n\tdce_clock_read_ss_info(clk_mgr);\n\n\n\tclk_mgr->base.bw_params = &rn_bw_params;\n\n\tif (pp_smu && pp_smu->rn_funcs.get_dpm_clock_table) {\n\t\tstatus = pp_smu->rn_funcs.get_dpm_clock_table(&pp_smu->rn_funcs.pp_smu, &clock_table);\n\n\t\tif (status == PP_SMU_RESULT_OK &&\n\t\t    ctx->dc_bios && ctx->dc_bios->integrated_info) {\n\t\t\trn_clk_mgr_helper_populate_bw_params (clk_mgr->base.bw_params, &clock_table, ctx->dc_bios->integrated_info);\n\t\t\t \n\t\t\tif (ctx->dc->config.is_asymmetric_memory)\n\t\t\t\tclk_mgr->base.bw_params->num_channels = 1;\n\t\t}\n\t}\n\n\t \n\tif (clk_mgr->smu_ver >= 0x00371500)\n\t\trn_vbios_smu_enable_48mhz_tmdp_refclk_pwrdwn(clk_mgr, !debug->disable_48mhz_pwrdwn);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}