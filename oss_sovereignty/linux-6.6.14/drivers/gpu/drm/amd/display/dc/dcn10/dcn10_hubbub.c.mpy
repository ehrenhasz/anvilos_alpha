{
  "module_name": "dcn10_hubbub.c",
  "hash_id": "fac6c73af92bffe72d4e4614832e10ae83e6ca51aba0e09f4d60b8b1e2c3521c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hubbub.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dcn10_hubp.h\"\n#include \"dcn10_hubbub.h\"\n#include \"reg_helper.h\"\n\n#define CTX \\\n\thubbub1->base.ctx\n#define DC_LOGGER \\\n\thubbub1->base.ctx->logger\n#define REG(reg)\\\n\thubbub1->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thubbub1->shifts->field_name, hubbub1->masks->field_name\n\nvoid hubbub1_wm_read_state(struct hubbub *hubbub,\n\t\tstruct dcn_hubbub_wm *wm)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tstruct dcn_hubbub_wm_set *s;\n\n\tmemset(wm, 0, sizeof(struct dcn_hubbub_wm));\n\n\ts = &wm->sets[0];\n\ts->wm_set = 0;\n\ts->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A);\n\ts->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A);\n\tif (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A)) {\n\t\ts->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A);\n\t\ts->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A);\n\t}\n\ts->dram_clk_change = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A);\n\n\ts = &wm->sets[1];\n\ts->wm_set = 1;\n\ts->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B);\n\ts->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B);\n\tif (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B)) {\n\t\ts->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B);\n\t\ts->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B);\n\t}\n\ts->dram_clk_change = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B);\n\n\ts = &wm->sets[2];\n\ts->wm_set = 2;\n\ts->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C);\n\ts->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C);\n\tif (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C)) {\n\t\ts->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C);\n\t\ts->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C);\n\t}\n\ts->dram_clk_change = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C);\n\n\ts = &wm->sets[3];\n\ts->wm_set = 3;\n\ts->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D);\n\ts->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D);\n\tif (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D)) {\n\t\ts->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D);\n\t\ts->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D);\n\t}\n\ts->dram_clk_change = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);\n}\n\nvoid hubbub1_allow_self_refresh_control(struct hubbub *hubbub, bool allow)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\t \n\n\tREG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,\n\t\t\tDCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_VALUE, 0,\n\t\t\tDCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE, !allow);\n}\n\nbool hubbub1_is_allow_self_refresh_enabled(struct hubbub *hubbub)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tuint32_t enable = 0;\n\n\tREG_GET(DCHUBBUB_ARB_DRAM_STATE_CNTL,\n\t\t\tDCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE, &enable);\n\n\treturn enable ? true : false;\n}\n\n\nbool hubbub1_verify_allow_pstate_change_high(\n\tstruct hubbub *hubbub)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\t \n\tconst unsigned int pstate_wait_timeout_us = 200;\n\tconst unsigned int pstate_wait_expected_timeout_us = 180;\n\tstatic unsigned int max_sampled_pstate_wait_us;  \n\tstatic bool forced_pstate_allow;  \n\n\tunsigned int debug_data;\n\tunsigned int i;\n\n\tif (forced_pstate_allow) {\n\t\t \n\t\tREG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,\n\t\t\t     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 0,\n\t\t\t     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 0);\n\t\tforced_pstate_allow = false;\n\t}\n\n\t \n\n\tREG_WRITE(DCHUBBUB_TEST_DEBUG_INDEX, hubbub1->debug_test_index_pstate);\n\n\tfor (i = 0; i < pstate_wait_timeout_us; i++) {\n\t\tdebug_data = REG_READ(DCHUBBUB_TEST_DEBUG_DATA);\n\n\t\tif (debug_data & (1 << 30)) {\n\n\t\t\tif (i > pstate_wait_expected_timeout_us)\n\t\t\t\tDC_LOG_WARNING(\"pstate took longer than expected ~%dus\\n\",\n\t\t\t\t\t\ti);\n\n\t\t\treturn true;\n\t\t}\n\t\tif (max_sampled_pstate_wait_us < i)\n\t\t\tmax_sampled_pstate_wait_us = i;\n\n\t\tudelay(1);\n\t}\n\n\t \n\tREG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,\n\t\t     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 1,\n\t\t     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 1);\n\tforced_pstate_allow = true;\n\n\tDC_LOG_WARNING(\"pstate TEST_DEBUG_DATA: 0x%X\\n\",\n\t\t\tdebug_data);\n\n\treturn false;\n}\n\nstatic uint32_t convert_and_clamp(\n\tuint32_t wm_ns,\n\tuint32_t refclk_mhz,\n\tuint32_t clamp_value)\n{\n\tuint32_t ret_val = 0;\n\tret_val = wm_ns * refclk_mhz;\n\tret_val /= 1000;\n\n\tif (ret_val > clamp_value)\n\t\tret_val = clamp_value;\n\n\treturn ret_val;\n}\n\n\nvoid hubbub1_wm_change_req_wa(struct hubbub *hubbub)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\tREG_UPDATE_SEQ_2(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);\n}\n\nbool hubbub1_program_urgent_watermarks(\n\t\tstruct hubbub *hubbub,\n\t\tstruct dcn_watermark_set *watermarks,\n\t\tunsigned int refclk_mhz,\n\t\tbool safe_to_lower)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tuint32_t prog_wm_value;\n\tbool wm_pending = false;\n\n\t \n\t \n\tif (safe_to_lower || watermarks->a.urgent_ns > hubbub1->watermarks.a.urgent_ns) {\n\t\thubbub1->watermarks.a.urgent_ns = watermarks->a.urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->a.urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, 0,\n\t\t\t\tDCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\"URGENCY_WATERMARK_A calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->a.urgent_ns, prog_wm_value);\n\t} else if (watermarks->a.urgent_ns < hubbub1->watermarks.a.urgent_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->a.pte_meta_urgent_ns > hubbub1->watermarks.a.pte_meta_urgent_ns) {\n\t\thubbub1->watermarks.a.pte_meta_urgent_ns = watermarks->a.pte_meta_urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"PTE_META_URGENCY_WATERMARK_A calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->a.pte_meta_urgent_ns, prog_wm_value);\n\t} else if (watermarks->a.pte_meta_urgent_ns < hubbub1->watermarks.a.pte_meta_urgent_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->b.urgent_ns > hubbub1->watermarks.b.urgent_ns) {\n\t\thubbub1->watermarks.b.urgent_ns = watermarks->b.urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->b.urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, 0,\n\t\t\t\tDCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\"URGENCY_WATERMARK_B calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->b.urgent_ns, prog_wm_value);\n\t} else if (watermarks->b.urgent_ns < hubbub1->watermarks.b.urgent_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->b.pte_meta_urgent_ns > hubbub1->watermarks.b.pte_meta_urgent_ns) {\n\t\thubbub1->watermarks.b.pte_meta_urgent_ns = watermarks->b.pte_meta_urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->b.pte_meta_urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"PTE_META_URGENCY_WATERMARK_B calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->b.pte_meta_urgent_ns, prog_wm_value);\n\t} else if (watermarks->b.pte_meta_urgent_ns < hubbub1->watermarks.b.pte_meta_urgent_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->c.urgent_ns > hubbub1->watermarks.c.urgent_ns) {\n\t\thubbub1->watermarks.c.urgent_ns = watermarks->c.urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->c.urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, 0,\n\t\t\t\tDCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\"URGENCY_WATERMARK_C calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->c.urgent_ns, prog_wm_value);\n\t} else if (watermarks->c.urgent_ns < hubbub1->watermarks.c.urgent_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->c.pte_meta_urgent_ns > hubbub1->watermarks.c.pte_meta_urgent_ns) {\n\t\thubbub1->watermarks.c.pte_meta_urgent_ns = watermarks->c.pte_meta_urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->c.pte_meta_urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"PTE_META_URGENCY_WATERMARK_C calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->c.pte_meta_urgent_ns, prog_wm_value);\n\t} else if (watermarks->c.pte_meta_urgent_ns < hubbub1->watermarks.c.pte_meta_urgent_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->d.urgent_ns > hubbub1->watermarks.d.urgent_ns) {\n\t\thubbub1->watermarks.d.urgent_ns = watermarks->d.urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->d.urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, 0,\n\t\t\t\tDCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\"URGENCY_WATERMARK_D calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->d.urgent_ns, prog_wm_value);\n\t} else if (watermarks->d.urgent_ns < hubbub1->watermarks.d.urgent_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->d.pte_meta_urgent_ns > hubbub1->watermarks.d.pte_meta_urgent_ns) {\n\t\thubbub1->watermarks.d.pte_meta_urgent_ns = watermarks->d.pte_meta_urgent_ns;\n\t\tprog_wm_value = convert_and_clamp(watermarks->d.pte_meta_urgent_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"PTE_META_URGENCY_WATERMARK_D calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->d.pte_meta_urgent_ns, prog_wm_value);\n\t} else if (watermarks->d.pte_meta_urgent_ns < hubbub1->watermarks.d.pte_meta_urgent_ns)\n\t\twm_pending = true;\n\n\treturn wm_pending;\n}\n\nbool hubbub1_program_stutter_watermarks(\n\t\tstruct hubbub *hubbub,\n\t\tstruct dcn_watermark_set *watermarks,\n\t\tunsigned int refclk_mhz,\n\t\tbool safe_to_lower)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tuint32_t prog_wm_value;\n\tbool wm_pending = false;\n\n\t \n\tif (safe_to_lower || watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t> hubbub1->watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns) {\n\t\thubbub1->watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns =\n\t\t\t\twatermarks->a.cstate_pstate.cstate_enter_plus_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_ENTER_EXIT_WATERMARK_A calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);\n\t} else if (watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t< hubbub1->watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->a.cstate_pstate.cstate_exit_ns\n\t\t\t> hubbub1->watermarks.a.cstate_pstate.cstate_exit_ns) {\n\t\thubbub1->watermarks.a.cstate_pstate.cstate_exit_ns =\n\t\t\t\twatermarks->a.cstate_pstate.cstate_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->a.cstate_pstate.cstate_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_EXIT_WATERMARK_A calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);\n\t} else if (watermarks->a.cstate_pstate.cstate_exit_ns\n\t\t\t< hubbub1->watermarks.a.cstate_pstate.cstate_exit_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t> hubbub1->watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns) {\n\t\thubbub1->watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns =\n\t\t\t\twatermarks->b.cstate_pstate.cstate_enter_plus_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_ENTER_EXIT_WATERMARK_B calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);\n\t} else if (watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t< hubbub1->watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->b.cstate_pstate.cstate_exit_ns\n\t\t\t> hubbub1->watermarks.b.cstate_pstate.cstate_exit_ns) {\n\t\thubbub1->watermarks.b.cstate_pstate.cstate_exit_ns =\n\t\t\t\twatermarks->b.cstate_pstate.cstate_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->b.cstate_pstate.cstate_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_EXIT_WATERMARK_B calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);\n\t} else if (watermarks->b.cstate_pstate.cstate_exit_ns\n\t\t\t< hubbub1->watermarks.b.cstate_pstate.cstate_exit_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t> hubbub1->watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns) {\n\t\thubbub1->watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns =\n\t\t\t\twatermarks->c.cstate_pstate.cstate_enter_plus_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_ENTER_EXIT_WATERMARK_C calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);\n\t} else if (watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t< hubbub1->watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->c.cstate_pstate.cstate_exit_ns\n\t\t\t> hubbub1->watermarks.c.cstate_pstate.cstate_exit_ns) {\n\t\thubbub1->watermarks.c.cstate_pstate.cstate_exit_ns =\n\t\t\t\twatermarks->c.cstate_pstate.cstate_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->c.cstate_pstate.cstate_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_EXIT_WATERMARK_C calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);\n\t} else if (watermarks->c.cstate_pstate.cstate_exit_ns\n\t\t\t< hubbub1->watermarks.c.cstate_pstate.cstate_exit_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t> hubbub1->watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns) {\n\t\thubbub1->watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns =\n\t\t\t\twatermarks->d.cstate_pstate.cstate_enter_plus_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_ENTER_EXIT_WATERMARK_D calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);\n\t} else if (watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns\n\t\t\t< hubbub1->watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns)\n\t\twm_pending = true;\n\n\tif (safe_to_lower || watermarks->d.cstate_pstate.cstate_exit_ns\n\t\t\t> hubbub1->watermarks.d.cstate_pstate.cstate_exit_ns) {\n\t\thubbub1->watermarks.d.cstate_pstate.cstate_exit_ns =\n\t\t\t\twatermarks->d.cstate_pstate.cstate_exit_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->d.cstate_pstate.cstate_exit_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"SR_EXIT_WATERMARK_D calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\",\n\t\t\twatermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);\n\t} else if (watermarks->d.cstate_pstate.cstate_exit_ns\n\t\t\t< hubbub1->watermarks.d.cstate_pstate.cstate_exit_ns)\n\t\twm_pending = true;\n\n\treturn wm_pending;\n}\n\nbool hubbub1_program_pstate_watermarks(\n\t\tstruct hubbub *hubbub,\n\t\tstruct dcn_watermark_set *watermarks,\n\t\tunsigned int refclk_mhz,\n\t\tbool safe_to_lower)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tuint32_t prog_wm_value;\n\tbool wm_pending = false;\n\n\t \n\tif (safe_to_lower || watermarks->a.cstate_pstate.pstate_change_ns\n\t\t\t> hubbub1->watermarks.a.cstate_pstate.pstate_change_ns) {\n\t\thubbub1->watermarks.a.cstate_pstate.pstate_change_ns =\n\t\t\t\twatermarks->a.cstate_pstate.pstate_change_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->a.cstate_pstate.pstate_change_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\\n\",\n\t\t\twatermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);\n\t} else if (watermarks->a.cstate_pstate.pstate_change_ns\n\t\t\t< hubbub1->watermarks.a.cstate_pstate.pstate_change_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->b.cstate_pstate.pstate_change_ns\n\t\t\t> hubbub1->watermarks.b.cstate_pstate.pstate_change_ns) {\n\t\thubbub1->watermarks.b.cstate_pstate.pstate_change_ns =\n\t\t\t\twatermarks->b.cstate_pstate.pstate_change_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->b.cstate_pstate.pstate_change_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\\n\",\n\t\t\twatermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);\n\t} else if (watermarks->b.cstate_pstate.pstate_change_ns\n\t\t\t< hubbub1->watermarks.b.cstate_pstate.pstate_change_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->c.cstate_pstate.pstate_change_ns\n\t\t\t> hubbub1->watermarks.c.cstate_pstate.pstate_change_ns) {\n\t\thubbub1->watermarks.c.cstate_pstate.pstate_change_ns =\n\t\t\t\twatermarks->c.cstate_pstate.pstate_change_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->c.cstate_pstate.pstate_change_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\\n\",\n\t\t\twatermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);\n\t} else if (watermarks->c.cstate_pstate.pstate_change_ns\n\t\t\t< hubbub1->watermarks.c.cstate_pstate.pstate_change_ns)\n\t\twm_pending = true;\n\n\t \n\tif (safe_to_lower || watermarks->d.cstate_pstate.pstate_change_ns\n\t\t\t> hubbub1->watermarks.d.cstate_pstate.pstate_change_ns) {\n\t\thubbub1->watermarks.d.cstate_pstate.pstate_change_ns =\n\t\t\t\twatermarks->d.cstate_pstate.pstate_change_ns;\n\t\tprog_wm_value = convert_and_clamp(\n\t\t\t\twatermarks->d.cstate_pstate.pstate_change_ns,\n\t\t\t\trefclk_mhz, 0x1fffff);\n\t\tREG_SET(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, 0,\n\t\t\t\tDCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);\n\t\tDC_LOG_BANDWIDTH_CALCS(\"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\\n\"\n\t\t\t\"HW register value = 0x%x\\n\\n\",\n\t\t\twatermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);\n\t} else if (watermarks->d.cstate_pstate.pstate_change_ns\n\t\t\t< hubbub1->watermarks.d.cstate_pstate.pstate_change_ns)\n\t\twm_pending = true;\n\n\treturn wm_pending;\n}\n\nbool hubbub1_program_watermarks(\n\t\tstruct hubbub *hubbub,\n\t\tstruct dcn_watermark_set *watermarks,\n\t\tunsigned int refclk_mhz,\n\t\tbool safe_to_lower)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tbool wm_pending = false;\n\t \n\tif (hubbub1_program_urgent_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))\n\t\twm_pending = true;\n\n\tif (hubbub1_program_stutter_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))\n\t\twm_pending = true;\n\n\tif (hubbub1_program_pstate_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))\n\t\twm_pending = true;\n\n\tREG_UPDATE(DCHUBBUB_ARB_SAT_LEVEL,\n\t\t\tDCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);\n\tREG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND,\n\t\t\tDCHUBBUB_ARB_MIN_REQ_OUTSTAND, 68);\n\n\thubbub1_allow_self_refresh_control(hubbub, !hubbub->ctx->dc->debug.disable_stutter);\n\n#if 0\n\tREG_UPDATE_2(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE, 1,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);\n#endif\n\treturn wm_pending;\n}\n\nvoid hubbub1_update_dchub(\n\tstruct hubbub *hubbub,\n\tstruct dchub_init_data *dh_data)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\tif (REG(DCHUBBUB_SDPIF_FB_TOP) == 0) {\n\t\tASSERT(false);\n\t\t \n\t\treturn;\n\t}\n\t \n\tswitch (dh_data->fb_mode) {\n\tcase FRAME_BUFFER_MODE_ZFB_ONLY:\n\t\t \n\t\tREG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,\n\t\t\t\tSDPIF_FB_TOP, 0);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,\n\t\t\t\tSDPIF_FB_BASE, 0x0FFFF);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,\n\t\t\t\tSDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,\n\t\t\t\tSDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,\n\t\t\t\tSDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +\n\t\t\t\t\t\tdh_data->zfb_size_in_byte - 1) >> 22);\n\t\tbreak;\n\tcase FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:\n\t\t \n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,\n\t\t\t\tSDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,\n\t\t\t\tSDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,\n\t\t\t\tSDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +\n\t\t\t\t\t\tdh_data->zfb_size_in_byte - 1) >> 22);\n\t\tbreak;\n\tcase FRAME_BUFFER_MODE_LOCAL_ONLY:\n\t\t \n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,\n\t\t\t\tSDPIF_AGP_BASE, 0);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,\n\t\t\t\tSDPIF_AGP_BOT, 0X03FFFF);\n\n\t\tREG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,\n\t\t\t\tSDPIF_AGP_TOP, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdh_data->dchub_initialzied = true;\n\tdh_data->dchub_info_valid = false;\n}\n\nvoid hubbub1_toggle_watermark_change_req(struct hubbub *hubbub)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\tuint32_t watermark_change_req;\n\n\tREG_GET(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, &watermark_change_req);\n\n\tif (watermark_change_req)\n\t\twatermark_change_req = 0;\n\telse\n\t\twatermark_change_req = 1;\n\n\tREG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,\n\t\t\tDCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);\n}\n\nvoid hubbub1_soft_reset(struct hubbub *hubbub, bool reset)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\tuint32_t reset_en = reset ? 1 : 0;\n\n\tREG_UPDATE(DCHUBBUB_SOFT_RESET,\n\t\t\tDCHUBBUB_GLOBAL_SOFT_RESET, reset_en);\n}\n\nstatic bool hubbub1_dcc_support_swizzle(\n\t\tenum swizzle_mode_values swizzle,\n\t\tunsigned int bytes_per_element,\n\t\tenum segment_order *segment_order_horz,\n\t\tenum segment_order *segment_order_vert)\n{\n\tbool standard_swizzle = false;\n\tbool display_swizzle = false;\n\n\tswitch (swizzle) {\n\tcase DC_SW_4KB_S:\n\tcase DC_SW_64KB_S:\n\tcase DC_SW_VAR_S:\n\tcase DC_SW_4KB_S_X:\n\tcase DC_SW_64KB_S_X:\n\tcase DC_SW_VAR_S_X:\n\t\tstandard_swizzle = true;\n\t\tbreak;\n\tcase DC_SW_4KB_D:\n\tcase DC_SW_64KB_D:\n\tcase DC_SW_VAR_D:\n\tcase DC_SW_4KB_D_X:\n\tcase DC_SW_64KB_D_X:\n\tcase DC_SW_VAR_D_X:\n\t\tdisplay_swizzle = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (bytes_per_element == 1 && standard_swizzle) {\n\t\t*segment_order_horz = segment_order__contiguous;\n\t\t*segment_order_vert = segment_order__na;\n\t\treturn true;\n\t}\n\tif (bytes_per_element == 2 && standard_swizzle) {\n\t\t*segment_order_horz = segment_order__non_contiguous;\n\t\t*segment_order_vert = segment_order__contiguous;\n\t\treturn true;\n\t}\n\tif (bytes_per_element == 4 && standard_swizzle) {\n\t\t*segment_order_horz = segment_order__non_contiguous;\n\t\t*segment_order_vert = segment_order__contiguous;\n\t\treturn true;\n\t}\n\tif (bytes_per_element == 8 && standard_swizzle) {\n\t\t*segment_order_horz = segment_order__na;\n\t\t*segment_order_vert = segment_order__contiguous;\n\t\treturn true;\n\t}\n\tif (bytes_per_element == 8 && display_swizzle) {\n\t\t*segment_order_horz = segment_order__contiguous;\n\t\t*segment_order_vert = segment_order__non_contiguous;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hubbub1_dcc_support_pixel_format(\n\t\tenum surface_pixel_format format,\n\t\tunsigned int *bytes_per_element)\n{\n\t \n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\t*bytes_per_element = 2;\n\t\treturn true;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:\n\t\t*bytes_per_element = 4;\n\t\treturn true;\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\t*bytes_per_element = 8;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void hubbub1_get_blk256_size(unsigned int *blk256_width, unsigned int *blk256_height,\n\t\tunsigned int bytes_per_element)\n{\n\t \n\t \n\tif (bytes_per_element == 1) {\n\t\t*blk256_width = 16;\n\t\t*blk256_height = 16;\n\t} else if (bytes_per_element == 2) {\n\t\t*blk256_width = 16;\n\t\t*blk256_height = 8;\n\t} else if (bytes_per_element == 4) {\n\t\t*blk256_width = 8;\n\t\t*blk256_height = 8;\n\t} else if (bytes_per_element == 8) {\n\t\t*blk256_width = 8;\n\t\t*blk256_height = 4;\n\t}\n}\n\nstatic void hubbub1_det_request_size(\n\t\tunsigned int height,\n\t\tunsigned int width,\n\t\tunsigned int bpe,\n\t\tbool *req128_horz_wc,\n\t\tbool *req128_vert_wc)\n{\n\tunsigned int detile_buf_size = 164 * 1024;   \n\n\tunsigned int blk256_height = 0;\n\tunsigned int blk256_width = 0;\n\tunsigned int swath_bytes_horz_wc, swath_bytes_vert_wc;\n\n\thubbub1_get_blk256_size(&blk256_width, &blk256_height, bpe);\n\n\tswath_bytes_horz_wc = width * blk256_height * bpe;\n\tswath_bytes_vert_wc = height * blk256_width * bpe;\n\n\t*req128_horz_wc = (2 * swath_bytes_horz_wc <= detile_buf_size) ?\n\t\t\tfalse :  \n\t\t\ttrue;  \n\n\t*req128_vert_wc = (2 * swath_bytes_vert_wc <= detile_buf_size) ?\n\t\t\tfalse :  \n\t\t\ttrue;  \n}\n\nstatic bool hubbub1_get_dcc_compression_cap(struct hubbub *hubbub,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\tstruct dc *dc = hubbub1->base.ctx->dc;\n\n\t \n\tenum dcc_control dcc_control;\n\tunsigned int bpe;\n\tenum segment_order segment_order_horz, segment_order_vert;\n\tbool req128_horz_wc, req128_vert_wc;\n\n\tmemset(output, 0, sizeof(*output));\n\n\tif (dc->debug.disable_dcc == DCC_DISABLE)\n\t\treturn false;\n\n\tif (!hubbub1->base.funcs->dcc_support_pixel_format(input->format, &bpe))\n\t\treturn false;\n\n\tif (!hubbub1->base.funcs->dcc_support_swizzle(input->swizzle_mode, bpe,\n\t\t\t&segment_order_horz, &segment_order_vert))\n\t\treturn false;\n\n\thubbub1_det_request_size(input->surface_size.height,  input->surface_size.width,\n\t\t\tbpe, &req128_horz_wc, &req128_vert_wc);\n\n\tif (!req128_horz_wc && !req128_vert_wc) {\n\t\tdcc_control = dcc_control__256_256_xxx;\n\t} else if (input->scan == SCAN_DIRECTION_HORIZONTAL) {\n\t\tif (!req128_horz_wc)\n\t\t\tdcc_control = dcc_control__256_256_xxx;\n\t\telse if (segment_order_horz == segment_order__contiguous)\n\t\t\tdcc_control = dcc_control__128_128_xxx;\n\t\telse\n\t\t\tdcc_control = dcc_control__256_64_64;\n\t} else if (input->scan == SCAN_DIRECTION_VERTICAL) {\n\t\tif (!req128_vert_wc)\n\t\t\tdcc_control = dcc_control__256_256_xxx;\n\t\telse if (segment_order_vert == segment_order__contiguous)\n\t\t\tdcc_control = dcc_control__128_128_xxx;\n\t\telse\n\t\t\tdcc_control = dcc_control__256_64_64;\n\t} else {\n\t\tif ((req128_horz_wc &&\n\t\t\tsegment_order_horz == segment_order__non_contiguous) ||\n\t\t\t(req128_vert_wc &&\n\t\t\tsegment_order_vert == segment_order__non_contiguous))\n\t\t\t \n\t\t\tdcc_control = dcc_control__256_64_64;\n\t\telse\n\t\t\t \n\t\t\tdcc_control = dcc_control__128_128_xxx;\n\t}\n\n\tif (dc->debug.disable_dcc == DCC_HALF_REQ_DISALBE &&\n\t\tdcc_control != dcc_control__256_256_xxx)\n\t\treturn false;\n\n\tswitch (dcc_control) {\n\tcase dcc_control__256_256_xxx:\n\t\toutput->grph.rgb.max_uncompressed_blk_size = 256;\n\t\toutput->grph.rgb.max_compressed_blk_size = 256;\n\t\toutput->grph.rgb.independent_64b_blks = false;\n\t\tbreak;\n\tcase dcc_control__128_128_xxx:\n\t\toutput->grph.rgb.max_uncompressed_blk_size = 128;\n\t\toutput->grph.rgb.max_compressed_blk_size = 128;\n\t\toutput->grph.rgb.independent_64b_blks = false;\n\t\tbreak;\n\tcase dcc_control__256_64_64:\n\t\toutput->grph.rgb.max_uncompressed_blk_size = 256;\n\t\toutput->grph.rgb.max_compressed_blk_size = 64;\n\t\toutput->grph.rgb.independent_64b_blks = true;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(false);\n\t\tbreak;\n\t}\n\n\toutput->capable = true;\n\toutput->const_color_support = false;\n\n\treturn true;\n}\n\nstatic const struct hubbub_funcs hubbub1_funcs = {\n\t.update_dchub = hubbub1_update_dchub,\n\t.dcc_support_swizzle = hubbub1_dcc_support_swizzle,\n\t.dcc_support_pixel_format = hubbub1_dcc_support_pixel_format,\n\t.get_dcc_compression_cap = hubbub1_get_dcc_compression_cap,\n\t.wm_read_state = hubbub1_wm_read_state,\n\t.program_watermarks = hubbub1_program_watermarks,\n\t.is_allow_self_refresh_enabled = hubbub1_is_allow_self_refresh_enabled,\n\t.allow_self_refresh_control = hubbub1_allow_self_refresh_control,\n\t.verify_allow_pstate_change_high = hubbub1_verify_allow_pstate_change_high,\n};\n\nvoid hubbub1_construct(struct hubbub *hubbub,\n\tstruct dc_context *ctx,\n\tconst struct dcn_hubbub_registers *hubbub_regs,\n\tconst struct dcn_hubbub_shift *hubbub_shift,\n\tconst struct dcn_hubbub_mask *hubbub_mask)\n{\n\tstruct dcn10_hubbub *hubbub1 = TO_DCN10_HUBBUB(hubbub);\n\n\thubbub1->base.ctx = ctx;\n\n\thubbub1->base.funcs = &hubbub1_funcs;\n\n\thubbub1->regs = hubbub_regs;\n\thubbub1->shifts = hubbub_shift;\n\thubbub1->masks = hubbub_mask;\n\n\thubbub1->debug_test_index_pstate = 0x7;\n\tif (ctx->dce_version == DCN_VERSION_1_01)\n\t\thubbub1->debug_test_index_pstate = 0xB;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}