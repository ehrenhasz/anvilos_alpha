{
  "module_name": "dcn10_hw_sequencer.c",
  "hash_id": "eed396ec2d111141e36a806c8bf6f3debab417a72a3cb58a71a141b94d7df82c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include \"dm_services.h\"\n#include \"basics/dc_common.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"custom_float.h\"\n#include \"dcn10_hw_sequencer.h\"\n#include \"dcn10_hw_sequencer_debug.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"abm.h\"\n#include \"dmcu.h\"\n#include \"dcn10_optc.h\"\n#include \"dcn10_dpp.h\"\n#include \"dcn10_mpc.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"reg_helper.h\"\n#include \"dcn10_hubp.h\"\n#include \"dcn10_hubbub.h\"\n#include \"dcn10_cm_common.h\"\n#include \"dccg.h\"\n#include \"clk_mgr.h\"\n#include \"link_hwss.h\"\n#include \"dpcd_defs.h\"\n#include \"dsc.h\"\n#include \"dce/dmub_psr.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dce/dmub_hw_lock_mgr.h\"\n#include \"dc_trace.h\"\n#include \"dce/dmub_outbox.h\"\n#include \"link.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\n \n#define DTN_INFO_MICRO_SEC(ref_cycle) \\\n\tprint_microsec(dc_ctx, log_ctx, ref_cycle)\n\n#define GAMMA_HW_POINTS_NUM 256\n\n#define PGFSM_POWER_ON 0\n#define PGFSM_POWER_OFF 2\n\nstatic void print_microsec(struct dc_context *dc_ctx,\n\t\t\t   struct dc_log_buffer_ctx *log_ctx,\n\t\t\t   uint32_t ref_cycle)\n{\n\tconst uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000;\n\tstatic const unsigned int frac = 1000;\n\tuint32_t us_x10 = (ref_cycle * frac) / ref_clk_mhz;\n\n\tDTN_INFO(\"  %11d.%03d\",\n\t\t\tus_x10 / frac,\n\t\t\tus_x10 % frac);\n}\n\nvoid dcn10_lock_all_pipes(struct dc *dc,\n\tstruct dc_state *context,\n\tbool lock)\n{\n\tstruct pipe_ctx *pipe_ctx;\n\tstruct pipe_ctx *old_pipe_ctx;\n\tstruct timing_generator *tg;\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\told_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\tpipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\ttg = pipe_ctx->stream_res.tg;\n\n\t\t \n\t\tif (pipe_ctx->top_pipe ||\n\t\t    !pipe_ctx->stream ||\n\t\t    (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state) ||\n\t\t    !tg->funcs->is_tg_enabled(tg) ||\n\t\t\tpipe_ctx->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\tif (lock)\n\t\t\tdc->hwss.pipe_control_lock(dc, pipe_ctx, true);\n\t\telse\n\t\t\tdc->hwss.pipe_control_lock(dc, pipe_ctx, false);\n\t}\n}\n\nstatic void log_mpc_crc(struct dc *dc,\n\tstruct dc_log_buffer_ctx *log_ctx)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tif (REG(MPC_CRC_RESULT_GB))\n\t\tDTN_INFO(\"MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\\n\",\n\t\tREG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));\n\tif (REG(DPP_TOP0_DPP_CRC_VAL_B_A))\n\t\tDTN_INFO(\"DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\\n\",\n\t\tREG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));\n}\n\nstatic void dcn10_log_hubbub_state(struct dc *dc,\n\t\t\t\t   struct dc_log_buffer_ctx *log_ctx)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct dcn_hubbub_wm wm;\n\tint i;\n\n\tmemset(&wm, 0, sizeof(struct dcn_hubbub_wm));\n\tdc->res_pool->hubbub->funcs->wm_read_state(dc->res_pool->hubbub, &wm);\n\n\tDTN_INFO(\"HUBBUB WM:      data_urgent  pte_meta_urgent\"\n\t\t\t\"         sr_enter          sr_exit  dram_clk_change\\n\");\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct dcn_hubbub_wm_set *s;\n\n\t\ts = &wm.sets[i];\n\t\tDTN_INFO(\"WM_Set[%d]:\", s->wm_set);\n\t\tDTN_INFO_MICRO_SEC(s->data_urgent);\n\t\tDTN_INFO_MICRO_SEC(s->pte_meta_urgent);\n\t\tDTN_INFO_MICRO_SEC(s->sr_enter);\n\t\tDTN_INFO_MICRO_SEC(s->sr_exit);\n\t\tDTN_INFO_MICRO_SEC(s->dram_clk_change);\n\t\tDTN_INFO(\"\\n\");\n\t}\n\n\tDTN_INFO(\"\\n\");\n}\n\nstatic void dcn10_log_hubp_states(struct dc *dc, void *log_ctx)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct resource_pool *pool = dc->res_pool;\n\tint i;\n\n\tDTN_INFO(\n\t\t\"HUBP:  format  addr_hi  width  height  rot  mir  sw_mode  dcc_en  blank_en  clock_en  ttu_dis  underflow   min_ttu_vblank       qos_low_wm      qos_high_wm\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct hubp *hubp = pool->hubps[i];\n\t\tstruct dcn_hubp_state *s = &(TO_DCN10_HUBP(hubp)->state);\n\n\t\thubp->funcs->hubp_read_state(hubp);\n\n\t\tif (!s->blank_en) {\n\t\t\tDTN_INFO(\"[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh  %6d  %8d  %8d  %7d  %8xh\",\n\t\t\t\t\thubp->inst,\n\t\t\t\t\ts->pixel_format,\n\t\t\t\t\ts->inuse_addr_hi,\n\t\t\t\t\ts->viewport_width,\n\t\t\t\t\ts->viewport_height,\n\t\t\t\t\ts->rotation_angle,\n\t\t\t\t\ts->h_mirror_en,\n\t\t\t\t\ts->sw_mode,\n\t\t\t\t\ts->dcc_en,\n\t\t\t\t\ts->blank_en,\n\t\t\t\t\ts->clock_en,\n\t\t\t\t\ts->ttu_disable,\n\t\t\t\t\ts->underflow_status);\n\t\t\tDTN_INFO_MICRO_SEC(s->min_ttu_vblank);\n\t\t\tDTN_INFO_MICRO_SEC(s->qos_level_low_wm);\n\t\t\tDTN_INFO_MICRO_SEC(s->qos_level_high_wm);\n\t\t\tDTN_INFO(\"\\n\");\n\t\t}\n\t}\n\n\tDTN_INFO(\"\\n=========RQ========\\n\");\n\tDTN_INFO(\"HUBP:  drq_exp_m  prq_exp_m  mrq_exp_m  crq_exp_m  plane1_ba  L:chunk_s  min_chu_s  meta_ch_s\"\n\t\t\"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h  C:chunk_s  min_chu_s  meta_ch_s\"\n\t\t\"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);\n\t\tstruct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;\n\n\t\tif (!s->blank_en)\n\t\t\tDTN_INFO(\"[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\\n\",\n\t\t\t\tpool->hubps[i]->inst, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,\n\t\t\t\trq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,\n\t\t\t\trq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,\n\t\t\t\trq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,\n\t\t\t\trq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,\n\t\t\t\trq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,\n\t\t\t\trq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,\n\t\t\t\trq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,\n\t\t\t\trq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);\n\t}\n\n\tDTN_INFO(\"========DLG========\\n\");\n\tDTN_INFO(\"HUBP:  rc_hbe     dlg_vbe    min_d_y_n  rc_per_ht  rc_x_a_s \"\n\t\t\t\"  dst_y_a_s  dst_y_pf   dst_y_vvb  dst_y_rvb  dst_y_vfl  dst_y_rfl  rf_pix_fq\"\n\t\t\t\"  vratio_pf  vrat_pf_c  rc_pg_vbl  rc_pg_vbc  rc_mc_vbl  rc_mc_vbc  rc_pg_fll\"\n\t\t\t\"  rc_pg_flc  rc_mc_fll  rc_mc_flc  pr_nom_l   pr_nom_c   rc_pg_nl   rc_pg_nc \"\n\t\t\t\"  mr_nom_l   mr_nom_c   rc_mc_nl   rc_mc_nc   rc_ld_pl   rc_ld_pc   rc_ld_l  \"\n\t\t\t\"  rc_ld_c    cha_cur0   ofst_cur1  cha_cur1   vr_af_vc0  ddrq_limt  x_rt_dlay\"\n\t\t\t\"  x_rp_dlay  x_rr_sfl\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);\n\t\tstruct _vcs_dpi_display_dlg_regs_st *dlg_regs = &s->dlg_attr;\n\n\t\tif (!s->blank_en)\n\t\t\tDTN_INFO(\"[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\"\n\t\t\t\t\"  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\"\n\t\t\t\t\"  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\\n\",\n\t\t\t\tpool->hubps[i]->inst, dlg_regs->refcyc_h_blank_end, dlg_regs->dlg_vblank_end, dlg_regs->min_dst_y_next_start,\n\t\t\t\tdlg_regs->refcyc_per_htotal, dlg_regs->refcyc_x_after_scaler, dlg_regs->dst_y_after_scaler,\n\t\t\t\tdlg_regs->dst_y_prefetch, dlg_regs->dst_y_per_vm_vblank, dlg_regs->dst_y_per_row_vblank,\n\t\t\t\tdlg_regs->dst_y_per_vm_flip, dlg_regs->dst_y_per_row_flip, dlg_regs->ref_freq_to_pix_freq,\n\t\t\t\tdlg_regs->vratio_prefetch, dlg_regs->vratio_prefetch_c, dlg_regs->refcyc_per_pte_group_vblank_l,\n\t\t\t\tdlg_regs->refcyc_per_pte_group_vblank_c, dlg_regs->refcyc_per_meta_chunk_vblank_l,\n\t\t\t\tdlg_regs->refcyc_per_meta_chunk_vblank_c, dlg_regs->refcyc_per_pte_group_flip_l,\n\t\t\t\tdlg_regs->refcyc_per_pte_group_flip_c, dlg_regs->refcyc_per_meta_chunk_flip_l,\n\t\t\t\tdlg_regs->refcyc_per_meta_chunk_flip_c, dlg_regs->dst_y_per_pte_row_nom_l,\n\t\t\t\tdlg_regs->dst_y_per_pte_row_nom_c, dlg_regs->refcyc_per_pte_group_nom_l,\n\t\t\t\tdlg_regs->refcyc_per_pte_group_nom_c, dlg_regs->dst_y_per_meta_row_nom_l,\n\t\t\t\tdlg_regs->dst_y_per_meta_row_nom_c, dlg_regs->refcyc_per_meta_chunk_nom_l,\n\t\t\t\tdlg_regs->refcyc_per_meta_chunk_nom_c, dlg_regs->refcyc_per_line_delivery_pre_l,\n\t\t\t\tdlg_regs->refcyc_per_line_delivery_pre_c, dlg_regs->refcyc_per_line_delivery_l,\n\t\t\t\tdlg_regs->refcyc_per_line_delivery_c, dlg_regs->chunk_hdl_adjust_cur0, dlg_regs->dst_y_offset_cur1,\n\t\t\t\tdlg_regs->chunk_hdl_adjust_cur1, dlg_regs->vready_after_vcount0, dlg_regs->dst_y_delta_drq_limit,\n\t\t\t\tdlg_regs->xfc_reg_transfer_delay, dlg_regs->xfc_reg_precharge_delay,\n\t\t\t\tdlg_regs->xfc_reg_remote_surface_flip_latency);\n\t}\n\n\tDTN_INFO(\"========TTU========\\n\");\n\tDTN_INFO(\"HUBP:  qos_ll_wm  qos_lh_wm  mn_ttu_vb  qos_l_flp  rc_rd_p_l  rc_rd_l    rc_rd_p_c\"\n\t\t\t\"  rc_rd_c    rc_rd_c0   rc_rd_pc0  rc_rd_c1   rc_rd_pc1  qos_lf_l   qos_rds_l\"\n\t\t\t\"  qos_lf_c   qos_rds_c  qos_lf_c0  qos_rds_c0 qos_lf_c1  qos_rds_c1\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);\n\t\tstruct _vcs_dpi_display_ttu_regs_st *ttu_regs = &s->ttu_attr;\n\n\t\tif (!s->blank_en)\n\t\t\tDTN_INFO(\"[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\\n\",\n\t\t\t\tpool->hubps[i]->inst, ttu_regs->qos_level_low_wm, ttu_regs->qos_level_high_wm, ttu_regs->min_ttu_vblank,\n\t\t\t\tttu_regs->qos_level_flip, ttu_regs->refcyc_per_req_delivery_pre_l, ttu_regs->refcyc_per_req_delivery_l,\n\t\t\t\tttu_regs->refcyc_per_req_delivery_pre_c, ttu_regs->refcyc_per_req_delivery_c, ttu_regs->refcyc_per_req_delivery_cur0,\n\t\t\t\tttu_regs->refcyc_per_req_delivery_pre_cur0, ttu_regs->refcyc_per_req_delivery_cur1,\n\t\t\t\tttu_regs->refcyc_per_req_delivery_pre_cur1, ttu_regs->qos_level_fixed_l, ttu_regs->qos_ramp_disable_l,\n\t\t\t\tttu_regs->qos_level_fixed_c, ttu_regs->qos_ramp_disable_c, ttu_regs->qos_level_fixed_cur0,\n\t\t\t\tttu_regs->qos_ramp_disable_cur0, ttu_regs->qos_level_fixed_cur1, ttu_regs->qos_ramp_disable_cur1);\n\t}\n\tDTN_INFO(\"\\n\");\n}\n\nvoid dcn10_log_hw_state(struct dc *dc,\n\tstruct dc_log_buffer_ctx *log_ctx)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct resource_pool *pool = dc->res_pool;\n\tint i;\n\n\tDTN_INFO_BEGIN();\n\n\tdcn10_log_hubbub_state(dc, log_ctx);\n\n\tdcn10_log_hubp_states(dc, log_ctx);\n\n\tDTN_INFO(\"DPP:    IGAM format  IGAM mode    DGAM mode    RGAM mode\"\n\t\t\t\"  GAMUT mode  C11 C12   C13 C14   C21 C22   C23 C24   \"\n\t\t\t\"C31 C32   C33 C34\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct dpp *dpp = pool->dpps[i];\n\t\tstruct dcn_dpp_state s = {0};\n\n\t\tdpp->funcs->dpp_read_state(dpp, &s);\n\n\t\tif (!s.is_enabled)\n\t\t\tcontinue;\n\n\t\tDTN_INFO(\"[%2d]:  %11xh  %-11s  %-11s  %-11s\"\n\t\t\t\t\"%8x    %08xh %08xh %08xh %08xh %08xh %08xh\",\n\t\t\t\tdpp->inst,\n\t\t\t\ts.igam_input_format,\n\t\t\t\t(s.igam_lut_mode == 0) ? \"BypassFixed\" :\n\t\t\t\t\t((s.igam_lut_mode == 1) ? \"BypassFloat\" :\n\t\t\t\t\t((s.igam_lut_mode == 2) ? \"RAM\" :\n\t\t\t\t\t((s.igam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\"))),\n\t\t\t\t(s.dgam_lut_mode == 0) ? \"Bypass\" :\n\t\t\t\t\t((s.dgam_lut_mode == 1) ? \"sRGB\" :\n\t\t\t\t\t((s.dgam_lut_mode == 2) ? \"Ycc\" :\n\t\t\t\t\t((s.dgam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t((s.dgam_lut_mode == 4) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\")))),\n\t\t\t\t(s.rgam_lut_mode == 0) ? \"Bypass\" :\n\t\t\t\t\t((s.rgam_lut_mode == 1) ? \"sRGB\" :\n\t\t\t\t\t((s.rgam_lut_mode == 2) ? \"Ycc\" :\n\t\t\t\t\t((s.rgam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t((s.rgam_lut_mode == 4) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\")))),\n\t\t\t\ts.gamut_remap_mode,\n\t\t\t\ts.gamut_remap_c11_c12,\n\t\t\t\ts.gamut_remap_c13_c14,\n\t\t\t\ts.gamut_remap_c21_c22,\n\t\t\t\ts.gamut_remap_c23_c24,\n\t\t\t\ts.gamut_remap_c31_c32,\n\t\t\t\ts.gamut_remap_c33_c34);\n\t\tDTN_INFO(\"\\n\");\n\t}\n\tDTN_INFO(\"\\n\");\n\n\tDTN_INFO(\"MPCC:  OPP  DPP  MPCCBOT  MODE  ALPHA_MODE  PREMULT  OVERLAP_ONLY  IDLE\\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct mpcc_state s = {0};\n\n\t\tpool->mpc->funcs->read_mpcc_state(pool->mpc, i, &s);\n\t\tif (s.opp_id != 0xf)\n\t\t\tDTN_INFO(\"[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\\n\",\n\t\t\t\ti, s.opp_id, s.dpp_id, s.bot_mpcc_id,\n\t\t\t\ts.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,\n\t\t\t\ts.idle);\n\t}\n\tDTN_INFO(\"\\n\");\n\n\tDTN_INFO(\"OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin  vmax_sel  vmin_sel  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow blank_en\\n\");\n\n\tfor (i = 0; i < pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = pool->timing_generators[i];\n\t\tstruct dcn_otg_state s = {0};\n\t\t \n\t\toptc1_read_otg_state(DCN10TG_FROM_TG(tg), &s);\n\n\t\t \n\t\tif (pool->opps[i]->funcs->dpg_is_blanked)\n\t\t\ts.blank_enabled = pool->opps[i]->funcs->dpg_is_blanked(pool->opps[i]);\n\t\telse\n\t\t\ts.blank_enabled = tg->funcs->is_blanked(tg);\n\n\t\t \n\t\tif ((s.otg_enabled & 1) == 0)\n\t\t\tcontinue;\n\n\t\tDTN_INFO(\"[%d]: %5d %5d %5d %5d %5d %5d %5d %9d %9d %5d %5d %5d %5d %5d %5d %5d  %9d %8d\\n\",\n\t\t\t\ttg->inst,\n\t\t\t\ts.v_blank_start,\n\t\t\t\ts.v_blank_end,\n\t\t\t\ts.v_sync_a_start,\n\t\t\t\ts.v_sync_a_end,\n\t\t\t\ts.v_sync_a_pol,\n\t\t\t\ts.v_total_max,\n\t\t\t\ts.v_total_min,\n\t\t\t\ts.v_total_max_sel,\n\t\t\t\ts.v_total_min_sel,\n\t\t\t\ts.h_blank_start,\n\t\t\t\ts.h_blank_end,\n\t\t\t\ts.h_sync_a_start,\n\t\t\t\ts.h_sync_a_end,\n\t\t\t\ts.h_sync_a_pol,\n\t\t\t\ts.h_total,\n\t\t\t\ts.v_total,\n\t\t\t\ts.underflow_occurred_status,\n\t\t\t\ts.blank_enabled);\n\n\t\t \n\t\t \n\t\t \n\t\t\n\t\ttg->funcs->clear_optc_underflow(tg);\n\t}\n\tDTN_INFO(\"\\n\");\n\n\t\n\t\n\tDTN_INFO(\"DSC: CLOCK_EN  SLICE_WIDTH  Bytes_pp\\n\");\n\tfor (i = 0; i < pool->res_cap->num_dsc; i++) {\n\t\tstruct display_stream_compressor *dsc = pool->dscs[i];\n\t\tstruct dcn_dsc_state s = {0};\n\n\t\tdsc->funcs->dsc_read_state(dsc, &s);\n\t\tDTN_INFO(\"[%d]: %-9d %-12d %-10d\\n\",\n\t\tdsc->inst,\n\t\t\ts.dsc_clock_en,\n\t\t\ts.dsc_slice_width,\n\t\t\ts.dsc_bits_per_pixel);\n\t\tDTN_INFO(\"\\n\");\n\t}\n\tDTN_INFO(\"\\n\");\n\n\tDTN_INFO(\"S_ENC: DSC_MODE  SEC_GSP7_LINE_NUM\"\n\t\t\t\"  VBID6_LINE_REFERENCE  VBID6_LINE_NUM  SEC_GSP7_ENABLE  SEC_STREAM_ENABLE\\n\");\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tstruct stream_encoder *enc = pool->stream_enc[i];\n\t\tstruct enc_state s = {0};\n\n\t\tif (enc->funcs->enc_read_state) {\n\t\t\tenc->funcs->enc_read_state(enc, &s);\n\t\t\tDTN_INFO(\"[%-3d]: %-9d %-18d %-21d %-15d %-16d %-17d\\n\",\n\t\t\t\tenc->id,\n\t\t\t\ts.dsc_mode,\n\t\t\t\ts.sec_gsp_pps_line_num,\n\t\t\t\ts.vbid6_line_reference,\n\t\t\t\ts.vbid6_line_num,\n\t\t\t\ts.sec_gsp_pps_enable,\n\t\t\t\ts.sec_stream_enable);\n\t\t\tDTN_INFO(\"\\n\");\n\t\t}\n\t}\n\tDTN_INFO(\"\\n\");\n\n\tDTN_INFO(\"L_ENC: DPHY_FEC_EN  DPHY_FEC_READY_SHADOW  DPHY_FEC_ACTIVE_STATUS  DP_LINK_TRAINING_COMPLETE\\n\");\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tstruct link_encoder *lenc = dc->links[i]->link_enc;\n\n\t\tstruct link_enc_state s = {0};\n\n\t\tif (lenc && lenc->funcs->read_state) {\n\t\t\tlenc->funcs->read_state(lenc, &s);\n\t\t\tDTN_INFO(\"[%-3d]: %-12d %-22d %-22d %-25d\\n\",\n\t\t\t\ti,\n\t\t\t\ts.dphy_fec_en,\n\t\t\t\ts.dphy_fec_ready_shadow,\n\t\t\t\ts.dphy_fec_active_status,\n\t\t\t\ts.dp_link_training_complete);\n\t\t\tDTN_INFO(\"\\n\");\n\t\t}\n\t}\n\tDTN_INFO(\"\\n\");\n\n\tDTN_INFO(\"\\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\\n\"\n\t\t\"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\\n\\n\",\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.dcfclk_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.dispclk_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.dppclk_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.fclk_khz,\n\t\t\tdc->current_state->bw_ctx.bw.dcn.clk.socclk_khz);\n\n\tlog_mpc_crc(dc, log_ctx);\n\n\t{\n\t\tif (pool->hpo_dp_stream_enc_count > 0) {\n\t\t\tDTN_INFO(\"DP HPO S_ENC:  Enabled  OTG   Format   Depth   Vid   SDP   Compressed  Link\\n\");\n\t\t\tfor (i = 0; i < pool->hpo_dp_stream_enc_count; i++) {\n\t\t\t\tstruct hpo_dp_stream_encoder_state hpo_dp_se_state = {0};\n\t\t\t\tstruct hpo_dp_stream_encoder *hpo_dp_stream_enc = pool->hpo_dp_stream_enc[i];\n\n\t\t\t\tif (hpo_dp_stream_enc && hpo_dp_stream_enc->funcs->read_state) {\n\t\t\t\t\thpo_dp_stream_enc->funcs->read_state(hpo_dp_stream_enc, &hpo_dp_se_state);\n\n\t\t\t\t\tDTN_INFO(\"[%d]:                 %d    %d   %6s       %d     %d     %d            %d     %d\\n\",\n\t\t\t\t\t\t\thpo_dp_stream_enc->id - ENGINE_ID_HPO_DP_0,\n\t\t\t\t\t\t\thpo_dp_se_state.stream_enc_enabled,\n\t\t\t\t\t\t\thpo_dp_se_state.otg_inst,\n\t\t\t\t\t\t\t(hpo_dp_se_state.pixel_encoding == 0) ? \"4:4:4\" :\n\t\t\t\t\t\t\t\t\t((hpo_dp_se_state.pixel_encoding == 1) ? \"4:2:2\" :\n\t\t\t\t\t\t\t\t\t(hpo_dp_se_state.pixel_encoding == 2) ? \"4:2:0\" : \"Y-Only\"),\n\t\t\t\t\t\t\t(hpo_dp_se_state.component_depth == 0) ? 6 :\n\t\t\t\t\t\t\t\t\t((hpo_dp_se_state.component_depth == 1) ? 8 :\n\t\t\t\t\t\t\t\t\t(hpo_dp_se_state.component_depth == 2) ? 10 : 12),\n\t\t\t\t\t\t\thpo_dp_se_state.vid_stream_enabled,\n\t\t\t\t\t\t\thpo_dp_se_state.sdp_enabled,\n\t\t\t\t\t\t\thpo_dp_se_state.compressed_format,\n\t\t\t\t\t\t\thpo_dp_se_state.mapped_to_link_enc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDTN_INFO(\"\\n\");\n\t\t}\n\n\t\t \n\t\tif (pool->hpo_dp_link_enc_count) {\n\t\t\tDTN_INFO(\"DP HPO L_ENC:  Enabled  Mode   Lanes   Stream  Slots   VC Rate X    VC Rate Y\\n\");\n\n\t\t\tfor (i = 0; i < pool->hpo_dp_link_enc_count; i++) {\n\t\t\t\tstruct hpo_dp_link_encoder *hpo_dp_link_enc = pool->hpo_dp_link_enc[i];\n\t\t\t\tstruct hpo_dp_link_enc_state hpo_dp_le_state = {0};\n\n\t\t\t\tif (hpo_dp_link_enc->funcs->read_state) {\n\t\t\t\t\thpo_dp_link_enc->funcs->read_state(hpo_dp_link_enc, &hpo_dp_le_state);\n\t\t\t\t\tDTN_INFO(\"[%d]:                 %d  %6s     %d        %d      %d     %d     %d\\n\",\n\t\t\t\t\t\t\thpo_dp_link_enc->inst,\n\t\t\t\t\t\t\thpo_dp_le_state.link_enc_enabled,\n\t\t\t\t\t\t\t(hpo_dp_le_state.link_mode == 0) ? \"TPS1\" :\n\t\t\t\t\t\t\t\t\t(hpo_dp_le_state.link_mode == 1) ? \"TPS2\" :\n\t\t\t\t\t\t\t\t\t(hpo_dp_le_state.link_mode == 2) ? \"ACTIVE\" : \"TEST\",\n\t\t\t\t\t\t\thpo_dp_le_state.lane_count,\n\t\t\t\t\t\t\thpo_dp_le_state.stream_src[0],\n\t\t\t\t\t\t\thpo_dp_le_state.slot_count[0],\n\t\t\t\t\t\t\thpo_dp_le_state.vc_rate_x[0],\n\t\t\t\t\t\t\thpo_dp_le_state.vc_rate_y[0]);\n\t\t\t\t\tDTN_INFO(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDTN_INFO(\"\\n\");\n\t\t}\n\t}\n\n\tDTN_INFO_END();\n}\n\nbool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\n\tif (tg->funcs->is_optc_underflow_occurred(tg)) {\n\t\ttg->funcs->clear_optc_underflow(tg);\n\t\treturn true;\n\t}\n\n\tif (hubp->funcs->hubp_get_underflow_status(hubp)) {\n\t\thubp->funcs->hubp_clear_underflow(hubp);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dcn10_enable_power_gating_plane(\n\tstruct dce_hwseq *hws,\n\tbool enable)\n{\n\tbool force_on = true;  \n\n\tif (enable)\n\t\tforce_on = false;\n\n\t \n\tREG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);\n\n\t \n\tREG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);\n}\n\nvoid dcn10_disable_vga(\n\tstruct dce_hwseq *hws)\n{\n\tunsigned int in_vga1_mode = 0;\n\tunsigned int in_vga2_mode = 0;\n\tunsigned int in_vga3_mode = 0;\n\tunsigned int in_vga4_mode = 0;\n\n\tREG_GET(D1VGA_CONTROL, D1VGA_MODE_ENABLE, &in_vga1_mode);\n\tREG_GET(D2VGA_CONTROL, D2VGA_MODE_ENABLE, &in_vga2_mode);\n\tREG_GET(D3VGA_CONTROL, D3VGA_MODE_ENABLE, &in_vga3_mode);\n\tREG_GET(D4VGA_CONTROL, D4VGA_MODE_ENABLE, &in_vga4_mode);\n\n\tif (in_vga1_mode == 0 && in_vga2_mode == 0 &&\n\t\t\tin_vga3_mode == 0 && in_vga4_mode == 0)\n\t\treturn;\n\n\tREG_WRITE(D1VGA_CONTROL, 0);\n\tREG_WRITE(D2VGA_CONTROL, 0);\n\tREG_WRITE(D3VGA_CONTROL, 0);\n\tREG_WRITE(D4VGA_CONTROL, 0);\n\n\t \n\tREG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_ENABLE, 1);\n\tREG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_RENDER_START, 1);\n}\n\n \nvoid dcn10_dpp_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dpp_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? PGFSM_POWER_ON : PGFSM_POWER_OFF;\n\n\tif (hws->ctx->dc->debug.disable_dpp_power_gate)\n\t\treturn;\n\tif (REG(DOMAIN1_PG_CONFIG) == 0)\n\t\treturn;\n\n\tswitch (dpp_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN1_PG_CONFIG,\n\t\t\t\tDOMAIN1_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN1_PG_STATUS,\n\t\t\t\tDOMAIN1_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN3_PG_CONFIG,\n\t\t\t\tDOMAIN3_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN3_PG_STATUS,\n\t\t\t\tDOMAIN3_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN5_PG_CONFIG,\n\t\t\t\tDOMAIN5_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN5_PG_STATUS,\n\t\t\t\tDOMAIN5_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN7_PG_CONFIG,\n\t\t\t\tDOMAIN7_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN7_PG_STATUS,\n\t\t\t\tDOMAIN7_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\n \nvoid dcn10_hubp_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int hubp_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? PGFSM_POWER_ON : PGFSM_POWER_OFF;\n\n\tif (hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\treturn;\n\tif (REG(DOMAIN0_PG_CONFIG) == 0)\n\t\treturn;\n\n\tswitch (hubp_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN0_PG_CONFIG,\n\t\t\t\tDOMAIN0_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN0_PG_STATUS,\n\t\t\t\tDOMAIN0_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN2_PG_CONFIG,\n\t\t\t\tDOMAIN2_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN2_PG_STATUS,\n\t\t\t\tDOMAIN2_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN4_PG_CONFIG,\n\t\t\t\tDOMAIN4_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN4_PG_STATUS,\n\t\t\t\tDOMAIN4_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN6_PG_CONFIG,\n\t\t\t\tDOMAIN6_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN6_PG_STATUS,\n\t\t\t\tDOMAIN6_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\nstatic void power_on_plane_resources(\n\tstruct dce_hwseq *hws,\n\tint plane_id)\n{\n\tDC_LOGGER_INIT(hws->ctx->logger);\n\n\tif (hws->funcs.dpp_root_clock_control)\n\t\thws->funcs.dpp_root_clock_control(hws, plane_id, true);\n\n\tif (REG(DC_IP_REQUEST_CNTL)) {\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 1);\n\n\t\tif (hws->funcs.dpp_pg_control)\n\t\t\thws->funcs.dpp_pg_control(hws, plane_id, true);\n\n\t\tif (hws->funcs.hubp_pg_control)\n\t\t\thws->funcs.hubp_pg_control(hws, plane_id, true);\n\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 0);\n\t\tDC_LOG_DEBUG(\n\t\t\t\t\"Un-gated front end for pipe %d\\n\", plane_id);\n\t}\n}\n\nstatic void undo_DEGVIDCN10_253_wa(struct dc *dc)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = dc->res_pool->hubps[0];\n\n\tif (!hws->wa_state.DEGVIDCN10_253_applied)\n\t\treturn;\n\n\thubp->funcs->set_blank(hubp, true);\n\n\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\tIP_REQUEST_EN, 1);\n\n\thws->funcs.hubp_pg_control(hws, 0, false);\n\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\tIP_REQUEST_EN, 0);\n\n\thws->wa_state.DEGVIDCN10_253_applied = false;\n}\n\nstatic void apply_DEGVIDCN10_253_wa(struct dc *dc)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = dc->res_pool->hubps[0];\n\tint i;\n\n\tif (dc->debug.disable_stutter)\n\t\treturn;\n\n\tif (!hws->wa.DEGVIDCN10_253)\n\t\treturn;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!dc->res_pool->hubps[i]->power_gated)\n\t\t\treturn;\n\t}\n\n\t \n\n\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\tIP_REQUEST_EN, 1);\n\n\thws->funcs.hubp_pg_control(hws, 0, true);\n\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\tIP_REQUEST_EN, 0);\n\n\thubp->funcs->set_hubp_blank_en(hubp, false);\n\thws->wa_state.DEGVIDCN10_253_applied = true;\n}\n\nvoid dcn10_bios_golden_init(struct dc *dc)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *bp = dc->ctx->dc_bios;\n\tint i;\n\tbool allow_self_fresh_force_enable = true;\n\n\tif (hws->funcs.s0i3_golden_init_wa && hws->funcs.s0i3_golden_init_wa(dc))\n\t\treturn;\n\n\tif (dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled)\n\t\tallow_self_fresh_force_enable =\n\t\t\t\tdc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub);\n\n\n\t \n\n\t \n\tbp->funcs->enable_disp_power_gating(bp,\n\t\t\tCONTROLLER_ID_D0, ASIC_PIPE_INIT);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t \n\t\tbp->funcs->enable_disp_power_gating(bp,\n\t\t\t\tCONTROLLER_ID_D0 + i, ASIC_PIPE_DISABLE);\n\t}\n\n\tif (dc->res_pool->hubbub->funcs->allow_self_refresh_control)\n\t\tif (allow_self_fresh_force_enable == false &&\n\t\t\t\tdc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub))\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,\n\t\t\t\t\t\t\t\t\t\t!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);\n\n}\n\nstatic void false_optc_underflow_wa(\n\t\tstruct dc *dc,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct timing_generator *tg)\n{\n\tint i;\n\tbool underflow;\n\n\tif (!dc->hwseq->wa.false_optc_underflow)\n\t\treturn;\n\n\tunderflow = tg->funcs->is_optc_underflow_occurred(tg);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (old_pipe_ctx->stream != stream)\n\t\t\tcontinue;\n\n\t\tdc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, old_pipe_ctx);\n\t}\n\n\tif (tg->funcs->set_blank_data_double_buffer)\n\t\ttg->funcs->set_blank_data_double_buffer(tg, true);\n\n\tif (tg->funcs->is_optc_underflow_occurred(tg) && !underflow)\n\t\ttg->funcs->clear_optc_underflow(tg);\n}\n\nstatic int calculate_vready_offset_for_group(struct pipe_ctx *pipe)\n{\n\tstruct pipe_ctx *other_pipe;\n\tint vready_offset = pipe->pipe_dlg_param.vready_offset;\n\n\t \n\tfor (other_pipe = pipe->bottom_pipe; other_pipe != NULL; other_pipe = other_pipe->bottom_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->top_pipe; other_pipe != NULL; other_pipe = other_pipe->top_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->next_odm_pipe; other_pipe != NULL; other_pipe = other_pipe->next_odm_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\tfor (other_pipe = pipe->prev_odm_pipe; other_pipe != NULL; other_pipe = other_pipe->prev_odm_pipe) {\n\t\tif (other_pipe->pipe_dlg_param.vready_offset > vready_offset)\n\t\t\tvready_offset = other_pipe->pipe_dlg_param.vready_offset;\n\t}\n\n\treturn vready_offset;\n}\n\nenum dc_status dcn10_enable_stream_timing(\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context,\n\t\tstruct dc *dc)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\n\t \n\tif (pipe_ctx->top_pipe != NULL)\n\t\treturn DC_OK;\n\n\t \n\n\t \n\tpipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, true);\n\n\tif (false == pipe_ctx->clock_source->funcs->program_pix_clk(\n\t\t\tpipe_ctx->clock_source,\n\t\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t\tdc->link_srv->dp_get_encoding_format(&pipe_ctx->link_config.dp_link_settings),\n\t\t\t&pipe_ctx->pll_settings)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\tif (dc_is_hdmi_tmds_signal(stream->signal)) {\n\t\tstream->link->phy_state.symclk_ref_cnts.otg = 1;\n\t\tif (stream->link->phy_state.symclk_state == SYMCLK_OFF_TX_OFF)\n\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_OFF;\n\t\telse\n\t\t\tstream->link->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n\t}\n\n\tpipe_ctx->stream_res.tg->funcs->program_timing(\n\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t&stream->timing,\n\t\t\tcalculate_vready_offset_for_group(pipe_ctx),\n\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start,\n\t\t\tpipe_ctx->pipe_dlg_param.vupdate_offset,\n\t\t\tpipe_ctx->pipe_dlg_param.vupdate_width,\n\t\t\tpipe_ctx->stream->signal,\n\t\t\ttrue);\n\n#if 0  \n\t \n\t \n\n\tinst_offset = reg_offsets[pipe_ctx->stream_res.tg->inst].fmt;\n\n\tpipe_ctx->stream_res.opp->funcs->opp_program_fmt(\n\t\t\t\tpipe_ctx->stream_res.opp,\n\t\t\t\t&stream->bit_depth_params,\n\t\t\t\t&stream->clamping);\n#endif\n\t \n\tcolor_space = stream->output_color_space;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\t \n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tblack_color.color_r_cr = black_color.color_g_y;\n\n\tif (pipe_ctx->stream_res.tg->funcs->set_blank_color)\n\t\tpipe_ctx->stream_res.tg->funcs->set_blank_color(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&black_color);\n\n\tif (pipe_ctx->stream_res.tg->funcs->is_blanked &&\n\t\t\t!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg)) {\n\t\tpipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);\n\t\thwss_wait_for_blank_complete(pipe_ctx->stream_res.tg);\n\t\tfalse_optc_underflow_wa(dc, pipe_ctx->stream, pipe_ctx->stream_res.tg);\n\t}\n\n\t \n\tif (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(pipe_ctx->stream_res.tg)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn DC_ERROR_UNEXPECTED;\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\treturn DC_OK;\n}\n\nstatic void dcn10_reset_back_end_for_pipe(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dc_link *link;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\tif (pipe_ctx->stream_res.stream_enc == NULL) {\n\t\tpipe_ctx->stream = NULL;\n\t\treturn;\n\t}\n\n\tlink = pipe_ctx->stream->link;\n\t \n\t \n\tif (!pipe_ctx->stream->dpms_off || link->link_status.link_active)\n\t\tdc->link_srv->set_dpms_off(pipe_ctx);\n\telse if (pipe_ctx->stream_res.audio)\n\t\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\tif (pipe_ctx->stream_res.audio) {\n\t\t \n\t\tpipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);\n\n\t\t \n\t\tif (dc->caps.dynamic_audio == true) {\n\t\t\t \n\t\t\t \n\t\t\tupdate_audio_usage(&dc->current_state->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe_ctx->stream_res.audio, false);\n\t\t\tpipe_ctx->stream_res.audio = NULL;\n\t\t}\n\t}\n\n\t \n\tif (pipe_ctx->top_pipe == NULL) {\n\n\t\tif (pipe_ctx->stream_res.abm)\n\t\t\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);\n\n\t\tpipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);\n\t\tif (pipe_ctx->stream_res.tg->funcs->set_drr)\n\t\t\tpipe_ctx->stream_res.tg->funcs->set_drr(\n\t\t\t\t\tpipe_ctx->stream_res.tg, NULL);\n\t\tpipe_ctx->stream->link->phy_state.symclk_ref_cnts.otg = 0;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)\n\t\t\tbreak;\n\n\tif (i == dc->res_pool->pipe_count)\n\t\treturn;\n\n\tpipe_ctx->stream = NULL;\n\tDC_LOG_DEBUG(\"Reset back end for pipe %d, tg:%d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);\n}\n\nstatic bool dcn10_hw_wa_force_recovery(struct dc *dc)\n{\n\tstruct hubp *hubp ;\n\tunsigned int i;\n\tbool need_recover = true;\n\n\tif (!dc->debug.recovery_enabled)\n\t\treturn false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx != NULL) {\n\t\t\thubp = pipe_ctx->plane_res.hubp;\n\t\t\tif (hubp != NULL && hubp->funcs->hubp_get_underflow_status) {\n\t\t\t\tif (hubp->funcs->hubp_get_underflow_status(hubp) != 0) {\n\t\t\t\t\t \n\t\t\t\t\tneed_recover = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!need_recover)\n\t\treturn false;\n\t \n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx != NULL) {\n\t\t\thubp = pipe_ctx->plane_res.hubp;\n\t\t\t \n\t\t\tif (hubp != NULL && hubp->funcs->set_hubp_blank_en)\n\t\t\t\thubp->funcs->set_hubp_blank_en(hubp, true);\n\t\t}\n\t}\n\t \n\thubbub1_soft_reset(dc->res_pool->hubbub, true);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx != NULL) {\n\t\t\thubp = pipe_ctx->plane_res.hubp;\n\t\t\t \n\t\t\tif (hubp != NULL && hubp->funcs->hubp_disable_control)\n\t\t\t\thubp->funcs->hubp_disable_control(hubp, true);\n\t\t}\n\t}\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx != NULL) {\n\t\t\thubp = pipe_ctx->plane_res.hubp;\n\t\t\t \n\t\t\tif (hubp != NULL && hubp->funcs->hubp_disable_control)\n\t\t\t\thubp->funcs->hubp_disable_control(hubp, true);\n\t\t}\n\t}\n\t \n\thubbub1_soft_reset(dc->res_pool->hubbub, false);\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx != NULL) {\n\t\t\thubp = pipe_ctx->plane_res.hubp;\n\t\t\t \n\t\t\tif (hubp != NULL && hubp->funcs->set_hubp_blank_en)\n\t\t\t\thubp->funcs->set_hubp_blank_en(hubp, true);\n\t\t}\n\t}\n\treturn true;\n\n}\n\nvoid dcn10_verify_allow_pstate_change_high(struct dc *dc)\n{\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tstatic bool should_log_hw_state;  \n\n\tif (!hubbub->funcs->verify_allow_pstate_change_high)\n\t\treturn;\n\n\tif (!hubbub->funcs->verify_allow_pstate_change_high(hubbub)) {\n\t\tint i = 0;\n\n\t\tif (should_log_hw_state)\n\t\t\tdcn10_log_hw_state(dc, NULL);\n\n\t\tTRACE_DC_PIPE_STATE(pipe_ctx, i, MAX_PIPES);\n\t\tBREAK_TO_DEBUGGER();\n\t\tif (dcn10_hw_wa_force_recovery(dc)) {\n\t\t\t \n\t\t\tif (!hubbub->funcs->verify_allow_pstate_change_high(hubbub))\n\t\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t}\n}\n\n \nvoid dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tint dpp_id = pipe_ctx->plane_res.dpp->inst;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct mpc_tree *mpc_tree_params;\n\tstruct mpcc *mpcc_to_remove = NULL;\n\tstruct output_pixel_processor *opp = pipe_ctx->stream_res.opp;\n\n\tmpc_tree_params = &(opp->mpc_tree_params);\n\tmpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);\n\n\t \n\tif (mpcc_to_remove == NULL)\n\t\treturn;\n\n\tmpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);\n\t \n\t \n\tif (opp != NULL && !pipe_ctx->plane_state->is_phantom)\n\t\topp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;\n\n\tdc->optimized_required = true;\n\n\tif (hubp->funcs->hubp_disconnect)\n\t\thubp->funcs->hubp_disconnect(hubp);\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\n \nvoid dcn10_plane_atomic_power_down(struct dc *dc,\n\t\tstruct dpp *dpp,\n\t\tstruct hubp *hubp)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (REG(DC_IP_REQUEST_CNTL)) {\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 1);\n\n\t\tif (hws->funcs.dpp_pg_control)\n\t\t\thws->funcs.dpp_pg_control(hws, dpp->inst, false);\n\n\t\tif (hws->funcs.hubp_pg_control)\n\t\t\thws->funcs.hubp_pg_control(hws, hubp->inst, false);\n\n\t\tdpp->funcs->dpp_reset(dpp);\n\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0,\n\t\t\t\tIP_REQUEST_EN, 0);\n\t\tDC_LOG_DEBUG(\n\t\t\t\t\"Power gated front end %d\\n\", hubp->inst);\n\t}\n\n\tif (hws->funcs.dpp_root_clock_control)\n\t\thws->funcs.dpp_root_clock_control(hws, dpp->inst, false);\n}\n\n \nvoid dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tint opp_id = hubp->opp_id;\n\n\tdc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);\n\n\thubp->funcs->hubp_clk_cntl(hubp, false);\n\n\tdpp->funcs->dpp_dppclk_control(dpp, false, false);\n\n\tif (opp_id != 0xf && pipe_ctx->stream_res.opp->mpc_tree_params.opp_list == NULL)\n\t\tpipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\t\tpipe_ctx->stream_res.opp,\n\t\t\t\tfalse);\n\n\thubp->power_gated = true;\n\tdc->optimized_required = false;  \n\n\thws->funcs.plane_atomic_power_down(dc,\n\t\t\tpipe_ctx->plane_res.dpp,\n\t\t\tpipe_ctx->plane_res.hubp);\n\n\tpipe_ctx->stream = NULL;\n\tmemset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));\n\tmemset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));\n\tpipe_ctx->top_pipe = NULL;\n\tpipe_ctx->bottom_pipe = NULL;\n\tpipe_ctx->plane_state = NULL;\n}\n\nvoid dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)\n\t\treturn;\n\n\thws->funcs.plane_atomic_disable(dc, pipe_ctx);\n\n\tapply_DEGVIDCN10_253_wa(dc);\n\n\tDC_LOG_DC(\"Power down front end %d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx);\n}\n\nvoid dcn10_init_pipes(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tbool can_apply_seamless_boot = false;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i]->apply_seamless_boot_optimization) {\n\t\t\tcan_apply_seamless_boot = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (pipe_ctx->stream != NULL && can_apply_seamless_boot)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tg->funcs->is_tg_enabled(tg)) {\n\t\t\tif (hws->funcs.init_blank != NULL) {\n\t\t\t\thws->funcs.init_blank(dc, tg);\n\t\t\t\ttg->funcs->lock(tg);\n\t\t\t} else {\n\t\t\t\ttg->funcs->lock(tg);\n\t\t\t\ttg->funcs->set_blank(tg, true);\n\t\t\t\thwss_wait_for_blank_complete(tg);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = dc->res_pool->hubps[i];\n\n\t\t \n\t\tif (pipe_ctx->stream != NULL && can_apply_seamless_boot)\n\t\t\tcontinue;\n\n\t\tif (hubbub && hubp) {\n\t\t\tif (hubbub->funcs->program_det_size)\n\t\t\t\thubbub->funcs->program_det_size(hubbub, hubp->inst, 0);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (pipe_ctx->stream != NULL && can_apply_seamless_boot)\n\t\t\tcontinue;\n\n\t\tdc->res_pool->mpc->funcs->mpc_init_single_inst(\n\t\t\t\tdc->res_pool->mpc, i);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\t\tstruct hubp *hubp = dc->res_pool->hubps[i];\n\t\tstruct dpp *dpp = dc->res_pool->dpps[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (can_apply_seamless_boot &&\n\t\t\tpipe_ctx->stream != NULL &&\n\t\t\tpipe_ctx->stream_res.tg->funcs->is_tg_enabled(\n\t\t\t\tpipe_ctx->stream_res.tg)) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\ttg->funcs->tg_init(tg);\n\t\t\thubp->power_gated = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tdpp->funcs->dpp_reset(dpp);\n\n\t\tpipe_ctx->stream_res.tg = tg;\n\t\tpipe_ctx->pipe_idx = i;\n\n\t\tpipe_ctx->plane_res.hubp = hubp;\n\t\tpipe_ctx->plane_res.dpp = dpp;\n\t\tpipe_ctx->plane_res.mpcc_inst = dpp->inst;\n\t\thubp->mpcc_id = dpp->inst;\n\t\thubp->opp_id = OPP_ID_INVALID;\n\t\thubp->power_gated = false;\n\n\t\tdc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;\n\t\tdc->res_pool->opps[i]->mpc_tree_params.opp_list = NULL;\n\t\tdc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;\n\t\tpipe_ctx->stream_res.opp = dc->res_pool->opps[i];\n\n\t\thws->funcs.plane_atomic_disconnect(dc, pipe_ctx);\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\ttg->funcs->unlock(tg);\n\n\t\tdc->hwss.disable_plane(dc, pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg = NULL;\n\t\tpipe_ctx->plane_res.hubp = NULL;\n\n\t\tif (tg->funcs->is_tg_enabled(tg)) {\n\t\t\tif (tg->funcs->init_odm)\n\t\t\t\ttg->funcs->init_odm(tg);\n\t\t}\n\n\t\ttg->funcs->tg_init(tg);\n\t}\n\n\t \n\tif (hws->funcs.dsc_pg_control != NULL) {\n\t\tuint32_t num_opps = 0;\n\t\tuint32_t opp_id_src0 = OPP_ID_INVALID;\n\t\tuint32_t opp_id_src1 = OPP_ID_INVALID;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\t\tuint32_t optc_dsc_state = 0;\n\t\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\n\t\t\tif (tg->funcs->is_tg_enabled(tg)) {\n\t\t\t\tif (tg->funcs->get_dsc_status)\n\t\t\t\t\ttg->funcs->get_dsc_status(tg, &optc_dsc_state);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (optc_dsc_state != 0) {\n\t\t\t\t\ttg->funcs->get_optc_source(tg, &num_opps, &opp_id_src0, &opp_id_src1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor (i = 0; i < dc->res_pool->res_cap->num_dsc; i++) {\n\t\t\tstruct dcn_dsc_state s  = {0};\n\n\t\t\tdc->res_pool->dscs[i]->funcs->dsc_read_state(dc->res_pool->dscs[i], &s);\n\n\t\t\tif ((s.dsc_opp_source == opp_id_src0 || s.dsc_opp_source == opp_id_src1) &&\n\t\t\t\ts.dsc_clock_en && s.dsc_fw_en)\n\t\t\t\tcontinue;\n\n\t\t\thws->funcs.dsc_pg_control(hws, dc->res_pool->dscs[i]->inst, false);\n\t\t}\n\t}\n}\n\nvoid dcn10_init_hw(struct dc *dc)\n{\n\tint i;\n\tstruct abm *abm = dc->res_pool->abm;\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tuint32_t backlight = MAX_BACKLIGHT_LEVEL;\n\tbool   is_optimized_init_done = false;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\t \n\tif (dc->clk_mgr->clks.dispclk_khz != 0 && dc->clk_mgr->clks.dppclk_khz != 0) {\n\t\tdc->current_state->bw_ctx.bw.dcn.clk.dispclk_khz = dc->clk_mgr->clks.dispclk_khz;\n\t\tdc->current_state->bw_ctx.bw.dcn.clk.dppclk_khz = dc->clk_mgr->clks.dppclk_khz;\n\t}\n\n\t\n\tif (dc->res_pool->dccg && dc->res_pool->dccg->funcs->dccg_init)\n\t\tdc->res_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb))\n\t\thws->funcs.disable_vga(dc->hwseq);\n\n\tif (!dc_dmub_srv_optimized_init_done(dc->ctx->dmub_srv))\n\t\thws->funcs.bios_golden_init(dc);\n\n\n\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\n\t\tif (res_pool->dccg && res_pool->hubbub) {\n\n\t\t\t(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,\n\t\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,\n\t\t\t\t\t&res_pool->ref_clocks.dccg_ref_clock_inKhz);\n\n\t\t\t(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,\n\t\t\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz,\n\t\t\t\t\t&res_pool->ref_clocks.dchub_ref_clock_inKhz);\n\t\t} else {\n\t\t\t\n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t}\n\t} else\n\t\tASSERT_CRITICAL(false);\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (!is_optimized_init_done)\n\t\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tlink->link_status.link_active = true;\n\t\t\tif (link->link_enc->funcs->fec_is_active &&\n\t\t\t\t\tlink->link_enc->funcs->fec_is_active(link->link_enc))\n\t\t\t\tlink->fec_state = dc_link_fec_enabled;\n\t\t}\n\t}\n\n\t \n\tdc->link_srv->blank_all_dp_displays(dc);\n\n\tif (hws->funcs.enable_power_gating_plane)\n\t\thws->funcs.enable_power_gating_plane(dc->hwseq, true);\n\n\t \n\tif (dcb->funcs->is_accelerated_mode(dcb) || !dc->config.seamless_boot_edp_requested) {\n\t\tif (!is_optimized_init_done) {\n\t\t\thws->funcs.init_pipes(dc, dc->current_state);\n\t\t\tif (dc->res_pool->hubbub->funcs->allow_self_refresh_control)\n\t\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,\n\t\t\t\t\t\t!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);\n\t\t}\n\t}\n\n\tif (!is_optimized_init_done) {\n\n\t\tfor (i = 0; i < res_pool->audio_count; i++) {\n\t\t\tstruct audio *audio = res_pool->audios[i];\n\n\t\t\taudio->funcs->hw_init(audio);\n\t\t}\n\n\t\tfor (i = 0; i < dc->link_count; i++) {\n\t\t\tstruct dc_link *link = dc->links[i];\n\n\t\t\tif (link->panel_cntl)\n\t\t\t\tbacklight = link->panel_cntl->funcs->hw_init(link->panel_cntl);\n\t\t}\n\n\t\tif (abm != NULL)\n\t\t\tabm->funcs->abm_init(abm, backlight);\n\n\t\tif (dmcu != NULL && !dmcu->auto_load_dmcu)\n\t\t\tdmcu->funcs->dmcu_init(dmcu);\n\t}\n\n\tif (abm != NULL && dmcu != NULL)\n\t\tabm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);\n\n\t \n\tif (!is_optimized_init_done)\n\t\tREG_WRITE(DIO_MEM_PWR_CTRL, 0);\n\n\tif (!dc->debug.disable_clock_gate) {\n\t\t \n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);\n\n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);\n\n\t\tREG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);\n\t}\n\n\tif (dc->clk_mgr->funcs->notify_wm_ranges)\n\t\tdc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);\n}\n\n \nvoid dcn10_power_down_on_boot(struct dc *dc)\n{\n\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\tstruct dc_link *edp_link = NULL;\n\tint edp_num;\n\tint i = 0;\n\n\tdc_get_edp_links(dc, edp_links, &edp_num);\n\tif (edp_num)\n\t\tedp_link = edp_links[0];\n\n\tif (edp_link && edp_link->link_enc->funcs->is_dig_enabled &&\n\t\t\tedp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc) &&\n\t\t\tdc->hwseq->funcs.edp_backlight_control &&\n\t\t\tdc->hwss.power_down &&\n\t\t\tdc->hwss.edp_power_control) {\n\t\tdc->hwseq->funcs.edp_backlight_control(edp_link, false);\n\t\tdc->hwss.power_down(dc);\n\t\tdc->hwss.edp_power_control(edp_link, false);\n\t} else {\n\t\tfor (i = 0; i < dc->link_count; i++) {\n\t\t\tstruct dc_link *link = dc->links[i];\n\n\t\t\tif (link->link_enc && link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc) &&\n\t\t\t\t\tdc->hwss.power_down) {\n\t\t\t\tdc->hwss.power_down(dc);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t \n\tif (dc->clk_mgr->funcs->set_low_power_state)\n\t\tdc->clk_mgr->funcs->set_low_power_state(dc->clk_mgr);\n}\n\nvoid dcn10_reset_hw_ctx_wrap(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tfor (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx_old->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx_old->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (!pipe_ctx->stream ||\n\t\t\t\tpipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {\n\t\t\tstruct clock_source *old_clk = pipe_ctx_old->clock_source;\n\n\t\t\tdcn10_reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);\n\t\t\tif (hws->funcs.enable_stream_gating)\n\t\t\t\thws->funcs.enable_stream_gating(dc, pipe_ctx_old);\n\t\t\tif (old_clk)\n\t\t\t\told_clk->funcs->cs_power_down(old_clk);\n\t\t}\n\t}\n}\n\nstatic bool patch_address_for_sbs_tb_stereo(\n\t\tstruct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tbool sec_split = pipe_ctx->top_pipe &&\n\t\t\tpipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;\n\tif (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t(pipe_ctx->stream->timing.timing_3d_format ==\n\t\t TIMING_3D_FORMAT_SIDE_BY_SIDE ||\n\t\t pipe_ctx->stream->timing.timing_3d_format ==\n\t\t TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {\n\t\t*addr = plane_state->address.grph_stereo.left_addr;\n\t\tplane_state->address.grph_stereo.left_addr =\n\t\tplane_state->address.grph_stereo.right_addr;\n\t\treturn true;\n\t} else {\n\t\tif (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&\n\t\t\tplane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {\n\t\t\tplane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;\n\t\t\tplane_state->address.grph_stereo.right_addr =\n\t\t\tplane_state->address.grph_stereo.left_addr;\n\t\t\tplane_state->address.grph_stereo.right_meta_addr =\n\t\t\tplane_state->address.grph_stereo.left_meta_addr;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tbool addr_patched = false;\n\tPHYSICAL_ADDRESS_LOC addr;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\taddr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);\n\n\tpipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(\n\t\t\tpipe_ctx->plane_res.hubp,\n\t\t\t&plane_state->address,\n\t\t\tplane_state->flip_immediate);\n\n\tplane_state->status.requested_address = plane_state->address;\n\n\tif (plane_state->flip_immediate)\n\t\tplane_state->status.current_address = plane_state->address;\n\n\tif (addr_patched)\n\t\tpipe_ctx->plane_state->address.grph_stereo.left_addr = addr;\n}\n\nbool dcn10_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\tconst struct dc_plane_state *plane_state)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tconst struct dc_transfer_func *tf = NULL;\n\tbool result = true;\n\n\tif (dpp_base == NULL)\n\t\treturn false;\n\n\tif (plane_state->in_transfer_func)\n\t\ttf = plane_state->in_transfer_func;\n\n\tif (plane_state->gamma_correction &&\n\t\t!dpp_base->ctx->dc->debug.always_use_regamma\n\t\t&& !plane_state->gamma_correction->is_identity\n\t\t\t&& dce_use_lut(plane_state->format))\n\t\tdpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);\n\n\tif (tf == NULL)\n\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);\n\telse if (tf->type == TF_TYPE_PREDEFINED) {\n\t\tswitch (tf->tf) {\n\t\tcase TRANSFER_FUNCTION_SRGB:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_HW_sRGB);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_BT709:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_HW_xvYCC);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_LINEAR:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);\n\t\t\tbreak;\n\t\tcase TRANSFER_FUNCTION_PQ:\n\t\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_USER_PWL);\n\t\t\tcm_helper_translate_curve_to_degamma_hw_format(tf, &dpp_base->degamma_params);\n\t\t\tdpp_base->funcs->dpp_program_degamma_pwl(dpp_base, &dpp_base->degamma_params);\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t} else if (tf->type == TF_TYPE_BYPASS) {\n\t\tdpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);\n\t} else {\n\t\tcm_helper_translate_curve_to_degamma_hw_format(tf,\n\t\t\t\t\t&dpp_base->degamma_params);\n\t\tdpp_base->funcs->dpp_program_degamma_pwl(dpp_base,\n\t\t\t\t&dpp_base->degamma_params);\n\t\tresult = true;\n\t}\n\n\treturn result;\n}\n\n#define MAX_NUM_HW_POINTS 0x200\n\nstatic void log_tf(struct dc_context *ctx,\n\t\t\t\tstruct dc_transfer_func *tf, uint32_t hw_points_num)\n{\n\t\n\t\n\t\n\tint i = 0;\n\n\tDC_LOGGER_INIT(ctx->logger);\n\tDC_LOG_GAMMA(\"Gamma Correction TF\");\n\tDC_LOG_ALL_GAMMA(\"Logging all tf points...\");\n\tDC_LOG_ALL_TF_CHANNELS(\"Logging all channels...\");\n\n\tfor (i = 0; i < hw_points_num; i++) {\n\t\tDC_LOG_GAMMA(\"R\\t%d\\t%llu\", i, tf->tf_pts.red[i].value);\n\t\tDC_LOG_ALL_TF_CHANNELS(\"G\\t%d\\t%llu\", i, tf->tf_pts.green[i].value);\n\t\tDC_LOG_ALL_TF_CHANNELS(\"B\\t%d\\t%llu\", i, tf->tf_pts.blue[i].value);\n\t}\n\n\tfor (i = hw_points_num; i < MAX_NUM_HW_POINTS; i++) {\n\t\tDC_LOG_ALL_GAMMA(\"R\\t%d\\t%llu\", i, tf->tf_pts.red[i].value);\n\t\tDC_LOG_ALL_TF_CHANNELS(\"G\\t%d\\t%llu\", i, tf->tf_pts.green[i].value);\n\t\tDC_LOG_ALL_TF_CHANNELS(\"B\\t%d\\t%llu\", i, tf->tf_pts.blue[i].value);\n\t}\n}\n\nbool dcn10_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_stream_state *stream)\n{\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\n\tif (dpp == NULL)\n\t\treturn false;\n\n\tdpp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;\n\n\tif (stream->out_transfer_func &&\n\t    stream->out_transfer_func->type == TF_TYPE_PREDEFINED &&\n\t    stream->out_transfer_func->tf == TRANSFER_FUNCTION_SRGB)\n\t\tdpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);\n\n\t \n\telse if (cm_helper_translate_curve_to_hw_format(dc->ctx,\n\t\t\tstream->out_transfer_func,\n\t\t\t&dpp->regamma_params, false)) {\n\t\tdpp->funcs->dpp_program_regamma_pwl(\n\t\t\t\tdpp,\n\t\t\t\t&dpp->regamma_params, OPP_REGAMMA_USER);\n\t} else\n\t\tdpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);\n\n\tif (stream != NULL && stream->ctx != NULL &&\n\t\t\tstream->out_transfer_func != NULL) {\n\t\tlog_tf(stream->ctx,\n\t\t\t\tstream->out_transfer_func,\n\t\t\t\tdpp->regamma_params.hw_points_num);\n\t}\n\n\treturn true;\n}\n\nvoid dcn10_pipe_control_lock(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe,\n\tbool lock)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tif (!pipe || pipe->top_pipe)\n\t\treturn;\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\n\tif (lock)\n\t\tpipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);\n\telse\n\t\tpipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\n \nstatic void delay_cursor_until_vupdate(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct crtc_position position;\n\tuint32_t vupdate_start, vupdate_end;\n\tunsigned int lines_to_vupdate, us_to_vupdate, vpos;\n\tunsigned int us_per_line, us_vupdate;\n\n\tif (!dc->hwss.calc_vupdate_position || !dc->hwss.get_position)\n\t\treturn;\n\n\tif (!pipe_ctx->stream_res.stream_enc || !pipe_ctx->stream_res.tg)\n\t\treturn;\n\n\tdc->hwss.calc_vupdate_position(dc, pipe_ctx, &vupdate_start,\n\t\t\t\t       &vupdate_end);\n\n\tdc->hwss.get_position(&pipe_ctx, 1, &position);\n\tvpos = position.vertical_count;\n\n\t \n\tvupdate_start += stream->timing.v_total;\n\tvupdate_end += stream->timing.v_total;\n\tvpos += stream->timing.v_total;\n\n\tif (vpos <= vupdate_start) {\n\t\t \n\t\tlines_to_vupdate = vupdate_start - vpos;\n\t} else if (vpos > vupdate_end) {\n\t\t \n\t\treturn;\n\t} else {\n\t\t \n\t\tlines_to_vupdate = 0;\n\t}\n\n\t \n\tus_per_line =\n\t\tstream->timing.h_total * 10000u / stream->timing.pix_clk_100hz;\n\tus_to_vupdate = lines_to_vupdate * us_per_line;\n\n\t \n\tif (us_to_vupdate > 70)\n\t\treturn;\n\n\t \n\tif (vupdate_end < vupdate_start)\n\t\tvupdate_end += stream->timing.v_total;\n\tus_vupdate = (vupdate_end - vupdate_start + 1) * us_per_line;\n\tudelay(us_to_vupdate + us_vupdate);\n}\n\nvoid dcn10_cursor_lock(struct dc *dc, struct pipe_ctx *pipe, bool lock)\n{\n\t \n\tif (!pipe || pipe->top_pipe)\n\t\treturn;\n\n\t \n\tif (lock)\n\t\tdelay_cursor_until_vupdate(dc, pipe);\n\n\tif (pipe->stream && should_use_dmub_lock(pipe->stream->link)) {\n\t\tunion dmub_hw_lock_flags hw_locks = { 0 };\n\t\tstruct dmub_hw_lock_inst_flags inst_flags = { 0 };\n\n\t\thw_locks.bits.lock_cursor = 1;\n\t\tinst_flags.opp_inst = pipe->stream_res.opp->inst;\n\n\t\tdmub_hw_lock_mgr_cmd(dc->ctx->dmub_srv,\n\t\t\t\t\tlock,\n\t\t\t\t\t&hw_locks,\n\t\t\t\t\t&inst_flags);\n\t} else\n\t\tdc->res_pool->mpc->funcs->cursor_lock(dc->res_pool->mpc,\n\t\t\t\tpipe->stream_res.opp->inst, lock);\n}\n\nstatic bool wait_for_reset_trigger_to_occur(\n\tstruct dc_context *dc_ctx,\n\tstruct timing_generator *tg)\n{\n\tbool rc = false;\n\n\t \n\tconst uint32_t frames_to_wait_on_triggered_reset = 10;\n\tint i;\n\n\tfor (i = 0; i < frames_to_wait_on_triggered_reset; i++) {\n\n\t\tif (!tg->funcs->is_counter_moving(tg)) {\n\t\t\tDC_ERROR(\"TG counter is not moving!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tg->funcs->did_triggered_reset_occur(tg)) {\n\t\t\trc = true;\n\t\t\t \n\t\t\tDC_SYNC_INFO(\"GSL: reset occurred at wait count: %d\\n\",\n\t\t\t\t\ti);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttg->funcs->wait_for_state(tg, CRTC_STATE_VACTIVE);\n\t\ttg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);\n\t}\n\n\tif (false == rc)\n\t\tDC_ERROR(\"GSL: Timeout on reset trigger!\\n\");\n\n\treturn rc;\n}\n\nstatic uint64_t reduceSizeAndFraction(uint64_t *numerator,\n\t\t\t\t      uint64_t *denominator,\n\t\t\t\t      bool checkUint32Bounary)\n{\n\tint i;\n\tbool ret = checkUint32Bounary == false;\n\tuint64_t max_int32 = 0xffffffff;\n\tuint64_t num, denom;\n\tstatic const uint16_t prime_numbers[] = {\n\t\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n\t\t47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,\n\t\t107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n\t\t167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\n\t\t229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n\t\t283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\n\t\t359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\n\t\t431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\n\t\t491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,\n\t\t571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,\n\t\t641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n\t\t709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773,\n\t\t787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857,\n\t\t859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\n\t\t941, 947, 953, 967, 971, 977, 983, 991, 997};\n\tint count = ARRAY_SIZE(prime_numbers);\n\n\tnum = *numerator;\n\tdenom = *denominator;\n\tfor (i = 0; i < count; i++) {\n\t\tuint32_t num_remainder, denom_remainder;\n\t\tuint64_t num_result, denom_result;\n\t\tif (checkUint32Bounary &&\n\t\t\tnum <= max_int32 && denom <= max_int32) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tnum_result = div_u64_rem(num, prime_numbers[i], &num_remainder);\n\t\t\tdenom_result = div_u64_rem(denom, prime_numbers[i], &denom_remainder);\n\t\t\tif (num_remainder == 0 && denom_remainder == 0) {\n\t\t\t\tnum = num_result;\n\t\t\t\tdenom = denom_result;\n\t\t\t}\n\t\t} while (num_remainder == 0 && denom_remainder == 0);\n\t}\n\t*numerator = num;\n\t*denominator = denom;\n\treturn ret;\n}\n\nstatic bool is_low_refresh_rate(struct pipe_ctx *pipe)\n{\n\tuint32_t master_pipe_refresh_rate =\n\t\tpipe->stream->timing.pix_clk_100hz * 100 /\n\t\tpipe->stream->timing.h_total /\n\t\tpipe->stream->timing.v_total;\n\treturn master_pipe_refresh_rate <= 30;\n}\n\nstatic uint8_t get_clock_divider(struct pipe_ctx *pipe,\n\t\t\t\t bool account_low_refresh_rate)\n{\n\tuint32_t clock_divider = 1;\n\tuint32_t numpipes = 1;\n\n\tif (account_low_refresh_rate && is_low_refresh_rate(pipe))\n\t\tclock_divider *= 2;\n\n\tif (pipe->stream_res.pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tclock_divider *= 2;\n\n\twhile (pipe->next_odm_pipe) {\n\t\tpipe = pipe->next_odm_pipe;\n\t\tnumpipes++;\n\t}\n\tclock_divider *= numpipes;\n\n\treturn clock_divider;\n}\n\nstatic int dcn10_align_pixel_clocks(struct dc *dc, int group_size,\n\t\t\t\t    struct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tint i, master = -1, embedded = -1;\n\tstruct dc_crtc_timing *hw_crtc_timing;\n\tuint64_t phase[MAX_PIPES];\n\tuint64_t modulo[MAX_PIPES];\n\tunsigned int pclk;\n\n\tuint32_t embedded_pix_clk_100hz;\n\tuint16_t embedded_h_total;\n\tuint16_t embedded_v_total;\n\tuint32_t dp_ref_clk_100hz =\n\t\tdc->res_pool->dp_clock_source->ctx->dc->clk_mgr->dprefclk_khz*10;\n\n\thw_crtc_timing = kcalloc(MAX_PIPES, sizeof(*hw_crtc_timing), GFP_KERNEL);\n\tif (!hw_crtc_timing)\n\t\treturn master;\n\n\tif (dc->config.vblank_alignment_dto_params &&\n\t\tdc->res_pool->dp_clock_source->funcs->override_dp_pix_clk) {\n\t\tembedded_h_total =\n\t\t\t(dc->config.vblank_alignment_dto_params >> 32) & 0x7FFF;\n\t\tembedded_v_total =\n\t\t\t(dc->config.vblank_alignment_dto_params >> 48) & 0x7FFF;\n\t\tembedded_pix_clk_100hz =\n\t\t\tdc->config.vblank_alignment_dto_params & 0xFFFFFFFF;\n\n\t\tfor (i = 0; i < group_size; i++) {\n\t\t\tgrouped_pipes[i]->stream_res.tg->funcs->get_hw_timing(\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\t\t&hw_crtc_timing[i]);\n\t\t\tdc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(\n\t\t\t\tdc->res_pool->dp_clock_source,\n\t\t\t\tgrouped_pipes[i]->stream_res.tg->inst,\n\t\t\t\t&pclk);\n\t\t\thw_crtc_timing[i].pix_clk_100hz = pclk;\n\t\t\tif (dc_is_embedded_signal(\n\t\t\t\t\tgrouped_pipes[i]->stream->signal)) {\n\t\t\t\tembedded = i;\n\t\t\t\tmaster = i;\n\t\t\t\tphase[i] = embedded_pix_clk_100hz*100;\n\t\t\t\tmodulo[i] = dp_ref_clk_100hz*100;\n\t\t\t} else {\n\n\t\t\t\tphase[i] = (uint64_t)embedded_pix_clk_100hz*\n\t\t\t\t\thw_crtc_timing[i].h_total*\n\t\t\t\t\thw_crtc_timing[i].v_total;\n\t\t\t\tphase[i] = div_u64(phase[i], get_clock_divider(grouped_pipes[i], true));\n\t\t\t\tmodulo[i] = (uint64_t)dp_ref_clk_100hz*\n\t\t\t\t\tembedded_h_total*\n\t\t\t\t\tembedded_v_total;\n\n\t\t\t\tif (reduceSizeAndFraction(&phase[i],\n\t\t\t\t\t\t&modulo[i], true) == false) {\n\t\t\t\t\t \n\t\t\t\t\tDC_SYNC_INFO(\"Failed to reduce DTO parameters\\n\");\n\t\t\t\t\tgrouped_pipes[i]->stream->has_non_synchronizable_pclk = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < group_size; i++) {\n\t\t\tif (i != embedded && !grouped_pipes[i]->stream->has_non_synchronizable_pclk) {\n\t\t\t\tdc->res_pool->dp_clock_source->funcs->override_dp_pix_clk(\n\t\t\t\t\tdc->res_pool->dp_clock_source,\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg->inst,\n\t\t\t\t\tphase[i], modulo[i]);\n\t\t\t\tdc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(\n\t\t\t\t\tdc->res_pool->dp_clock_source,\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg->inst, &pclk);\n\t\t\t\tgrouped_pipes[i]->stream->timing.pix_clk_100hz =\n\t\t\t\t\tpclk*get_clock_divider(grouped_pipes[i], false);\n\t\t\t\tif (master == -1)\n\t\t\t\t\tmaster = i;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tkfree(hw_crtc_timing);\n\treturn master;\n}\n\nvoid dcn10_enable_vblanks_synchronization(\n\tstruct dc *dc,\n\tint group_index,\n\tint group_size,\n\tstruct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct output_pixel_processor *opp;\n\tstruct timing_generator *tg;\n\tint i, width, height, master;\n\n\tfor (i = 1; i < group_size; i++) {\n\t\topp = grouped_pipes[i]->stream_res.opp;\n\t\ttg = grouped_pipes[i]->stream_res.tg;\n\t\ttg->funcs->get_otg_active_size(tg, &width, &height);\n\n\t\tif (!tg->funcs->is_tg_enabled(tg)) {\n\t\t\tDC_SYNC_INFO(\"Skipping timing sync on disabled OTG\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (opp->funcs->opp_program_dpg_dimensions)\n\t\t\topp->funcs->opp_program_dpg_dimensions(opp, width, 2*(height) + 1);\n\t}\n\n\tfor (i = 0; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream == NULL)\n\t\t\tcontinue;\n\t\tgrouped_pipes[i]->stream->vblank_synchronized = false;\n\t\tgrouped_pipes[i]->stream->has_non_synchronizable_pclk = false;\n\t}\n\n\tDC_SYNC_INFO(\"Aligning DP DTOs\\n\");\n\n\tmaster = dcn10_align_pixel_clocks(dc, group_size, grouped_pipes);\n\n\tDC_SYNC_INFO(\"Synchronizing VBlanks\\n\");\n\n\tif (master >= 0) {\n\t\tfor (i = 0; i < group_size; i++) {\n\t\t\tif (i != master && !grouped_pipes[i]->stream->has_non_synchronizable_pclk)\n\t\t\t\tgrouped_pipes[i]->stream_res.tg->funcs->align_vblanks(\n\t\t\t\t\tgrouped_pipes[master]->stream_res.tg,\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\t\tgrouped_pipes[master]->stream->timing.pix_clk_100hz,\n\t\t\t\t\tgrouped_pipes[i]->stream->timing.pix_clk_100hz,\n\t\t\t\t\tget_clock_divider(grouped_pipes[master], false),\n\t\t\t\t\tget_clock_divider(grouped_pipes[i], false));\n\t\t\tgrouped_pipes[i]->stream->vblank_synchronized = true;\n\t\t}\n\t\tgrouped_pipes[master]->stream->vblank_synchronized = true;\n\t\tDC_SYNC_INFO(\"Sync complete\\n\");\n\t}\n\n\tfor (i = 1; i < group_size; i++) {\n\t\topp = grouped_pipes[i]->stream_res.opp;\n\t\ttg = grouped_pipes[i]->stream_res.tg;\n\t\ttg->funcs->get_otg_active_size(tg, &width, &height);\n\t\tif (opp->funcs->opp_program_dpg_dimensions)\n\t\t\topp->funcs->opp_program_dpg_dimensions(opp, width, height);\n\t}\n}\n\nvoid dcn10_enable_timing_synchronization(\n\tstruct dc *dc,\n\tint group_index,\n\tint group_size,\n\tstruct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct output_pixel_processor *opp;\n\tstruct timing_generator *tg;\n\tint i, width, height;\n\n\tDC_SYNC_INFO(\"Setting up OTG reset trigger\\n\");\n\n\tfor (i = 1; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream && grouped_pipes[i]->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\topp = grouped_pipes[i]->stream_res.opp;\n\t\ttg = grouped_pipes[i]->stream_res.tg;\n\t\ttg->funcs->get_otg_active_size(tg, &width, &height);\n\n\t\tif (!tg->funcs->is_tg_enabled(tg)) {\n\t\t\tDC_SYNC_INFO(\"Skipping timing sync on disabled OTG\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (opp->funcs->opp_program_dpg_dimensions)\n\t\t\topp->funcs->opp_program_dpg_dimensions(opp, width, 2*(height) + 1);\n\t}\n\n\tfor (i = 0; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream == NULL)\n\t\t\tcontinue;\n\n\t\tif (grouped_pipes[i]->stream && grouped_pipes[i]->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\tgrouped_pipes[i]->stream->vblank_synchronized = false;\n\t}\n\n\tfor (i = 1; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream && grouped_pipes[i]->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(\n\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\tgrouped_pipes[0]->stream_res.tg->inst);\n\t}\n\n\tDC_SYNC_INFO(\"Waiting for trigger\\n\");\n\n\t \n\n\tif (grouped_pipes[1]->stream && grouped_pipes[1]->stream->mall_stream_config.type != SUBVP_PHANTOM)\n\t\twait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->stream_res.tg);\n\n\tfor (i = 1; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream && grouped_pipes[i]->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\tgrouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(\n\t\t\t\tgrouped_pipes[i]->stream_res.tg);\n\t}\n\n\tfor (i = 1; i < group_size; i++) {\n\t\tif (grouped_pipes[i]->stream && grouped_pipes[i]->stream->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\tcontinue;\n\n\t\topp = grouped_pipes[i]->stream_res.opp;\n\t\ttg = grouped_pipes[i]->stream_res.tg;\n\t\ttg->funcs->get_otg_active_size(tg, &width, &height);\n\t\tif (opp->funcs->opp_program_dpg_dimensions)\n\t\t\topp->funcs->opp_program_dpg_dimensions(opp, width, height);\n\t}\n\n\tDC_SYNC_INFO(\"Sync complete\\n\");\n}\n\nvoid dcn10_enable_per_frame_crtc_position_reset(\n\tstruct dc *dc,\n\tint group_size,\n\tstruct pipe_ctx *grouped_pipes[])\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tint i;\n\n\tDC_SYNC_INFO(\"Setting up\\n\");\n\tfor (i = 0; i < group_size; i++)\n\t\tif (grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset)\n\t\t\tgrouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(\n\t\t\t\t\tgrouped_pipes[i]->stream_res.tg,\n\t\t\t\t\t0,\n\t\t\t\t\t&grouped_pipes[i]->stream->triggered_crtc_reset);\n\n\tDC_SYNC_INFO(\"Waiting for trigger\\n\");\n\n\tfor (i = 0; i < group_size; i++)\n\t\twait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);\n\n\tDC_SYNC_INFO(\"Multi-display sync is complete\\n\");\n}\n\nstatic void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,\n\t\tstruct vm_system_aperture_param *apt,\n\t\tstruct dce_hwseq *hws)\n{\n\tPHYSICAL_ADDRESS_LOC physical_page_number;\n\tuint32_t logical_addr_low;\n\tuint32_t logical_addr_high;\n\n\tREG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,\n\t\t\tPHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);\n\tREG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,\n\t\t\tPHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);\n\n\tREG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\tLOGICAL_ADDR, &logical_addr_low);\n\n\tREG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\tLOGICAL_ADDR, &logical_addr_high);\n\n\tapt->sys_default.quad_part =  physical_page_number.quad_part << 12;\n\tapt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;\n\tapt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;\n}\n\n \nstatic void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,\n\t\tstruct vm_context0_param *vm0,\n\t\tstruct dce_hwseq *hws)\n{\n\tPHYSICAL_ADDRESS_LOC fb_base;\n\tPHYSICAL_ADDRESS_LOC fb_offset;\n\tuint32_t fb_base_value;\n\tuint32_t fb_offset_value;\n\n\tREG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);\n\tREG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);\n\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,\n\t\t\tPAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,\n\t\t\tPAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);\n\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,\n\t\t\tLOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,\n\t\t\tLOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);\n\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,\n\t\t\tLOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);\n\tREG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,\n\t\t\tLOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);\n\n\tREG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,\n\t\t\tPHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);\n\tREG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,\n\t\t\tPHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);\n\n\t \n\tfb_base.quad_part = (uint64_t)fb_base_value << 24;\n\tfb_offset.quad_part = (uint64_t)fb_offset_value << 24;\n\tvm0->pte_base.quad_part += fb_base.quad_part;\n\tvm0->pte_base.quad_part -= fb_offset.quad_part;\n}\n\n\nstatic void dcn10_program_pte_vm(struct dce_hwseq *hws, struct hubp *hubp)\n{\n\tstruct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);\n\tstruct vm_system_aperture_param apt = {0};\n\tstruct vm_context0_param vm0 = {0};\n\n\tmmhub_read_vm_system_aperture_settings(hubp1, &apt, hws);\n\tmmhub_read_vm_context0_settings(hubp1, &vm0, hws);\n\n\thubp->funcs->hubp_set_vm_system_aperture_settings(hubp, &apt);\n\thubp->funcs->hubp_set_vm_context0_settings(hubp, &vm0);\n}\n\nstatic void dcn10_enable_plane(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe_ctx,\n\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tif (dc->debug.sanity_checks) {\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\t}\n\n\tundo_DEGVIDCN10_253_wa(dc);\n\n\tpower_on_plane_resources(dc->hwseq,\n\t\tpipe_ctx->plane_res.hubp->inst);\n\n\t \n\tpipe_ctx->plane_res.hubp->funcs->hubp_clk_cntl(pipe_ctx->plane_res.hubp, true);\n\n\t \n\tpipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\tpipe_ctx->stream_res.opp,\n\t\t\ttrue);\n\n\tif (dc->config.gpu_vm_support)\n\t\tdcn10_program_pte_vm(hws, pipe_ctx->plane_res.hubp);\n\n\tif (dc->debug.sanity_checks) {\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\t}\n\n\tif (!pipe_ctx->top_pipe\n\t\t&& pipe_ctx->plane_state\n\t\t&& pipe_ctx->plane_state->flip_int_enabled\n\t\t&& pipe_ctx->plane_res.hubp->funcs->hubp_set_flip_int)\n\t\t\tpipe_ctx->plane_res.hubp->funcs->hubp_set_flip_int(pipe_ctx->plane_res.hubp);\n\n}\n\nvoid dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)\n{\n\tint i = 0;\n\tstruct dpp_grph_csc_adjustment adjust;\n\tmemset(&adjust, 0, sizeof(adjust));\n\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;\n\n\n\tif (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {\n\t\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;\n\t\tfor (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)\n\t\t\tadjust.temperature_matrix[i] =\n\t\t\t\tpipe_ctx->stream->gamut_remap_matrix.matrix[i];\n\t} else if (pipe_ctx->plane_state &&\n\t\t   pipe_ctx->plane_state->gamut_remap_matrix.enable_remap == true) {\n\t\tadjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;\n\t\tfor (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)\n\t\t\tadjust.temperature_matrix[i] =\n\t\t\t\tpipe_ctx->plane_state->gamut_remap_matrix.matrix[i];\n\t}\n\n\tpipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);\n}\n\n\nstatic bool dcn10_is_rear_mpo_fix_required(struct pipe_ctx *pipe_ctx, enum dc_color_space colorspace)\n{\n\tif (pipe_ctx->plane_state && pipe_ctx->plane_state->layer_index > 0 && is_rgb_cspace(colorspace)) {\n\t\tif (pipe_ctx->top_pipe) {\n\t\t\tstruct pipe_ctx *top = pipe_ctx->top_pipe;\n\n\t\t\twhile (top->top_pipe)\n\t\t\t\ttop = top->top_pipe;  \n\t\t\tif (top->plane_state && top->plane_state->layer_index == 0)\n\t\t\t\treturn true;  \n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void dcn10_set_csc_adjustment_rgb_mpo_fix(struct pipe_ctx *pipe_ctx, uint16_t *matrix)\n{\n\t \n\tuint16_t rgb_bias = matrix[3];\n\n\tmatrix[3] = 0;\n\tmatrix[7] = 0;\n\tmatrix[11] = 0;\n\tpipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);\n\tmatrix[3] = rgb_bias;\n\tmatrix[7] = rgb_bias;\n\tmatrix[11] = rgb_bias;\n}\n\nvoid dcn10_program_output_csc(struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tenum dc_color_space colorspace,\n\t\tuint16_t *matrix,\n\t\tint opp_id)\n{\n\tif (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {\n\t\tif (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL) {\n\n\t\t\t \n\n\t\t\tint16_t rgb_bias = matrix[3];\n\t\t\t \n\n\t\t\tif (rgb_bias > 0 && dcn10_is_rear_mpo_fix_required(pipe_ctx, colorspace)) {\n\t\t\t\tdcn10_set_csc_adjustment_rgb_mpo_fix(pipe_ctx, matrix);\n\t\t\t} else {\n\t\t\t\tpipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default != NULL)\n\t\t\tpipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);\n\t}\n}\n\nstatic void dcn10_update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)\n{\n\tstruct dc_bias_and_scale bns_params = {0};\n\n\t \n\tdpp->funcs->dpp_setup(dpp,\n\t\t\tplane_state->format,\n\t\t\tEXPANSION_MODE_ZERO,\n\t\t\tplane_state->input_csc_color_matrix,\n\t\t\tplane_state->color_space,\n\t\t\tNULL);\n\n\t \n\tbuild_prescale_params(&bns_params, plane_state);\n\tif (dpp->funcs->dpp_program_bias_and_scale)\n\t\tdpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);\n}\n\nvoid dcn10_update_visual_confirm_color(struct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tint mpcc_id)\n{\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\n\tif (mpc->funcs->set_bg_color) {\n\t\tmemcpy(&pipe_ctx->plane_state->visual_confirm_color, &(pipe_ctx->visual_confirm_color), sizeof(struct tg_color));\n\t\tmpc->funcs->set_bg_color(mpc, &(pipe_ctx->visual_confirm_color), mpcc_id);\n\t}\n}\n\nvoid dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct mpcc_blnd_cfg blnd_cfg = {0};\n\tbool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;\n\tint mpcc_id;\n\tstruct mpcc *new_mpcc;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);\n\n\tblnd_cfg.overlap_only = false;\n\tblnd_cfg.global_gain = 0xff;\n\n\tif (per_pixel_alpha) {\n\t\t \n\t\tblnd_cfg.pre_multiplied_alpha = (is_rgb_cspace(\n\t\t\t\tpipe_ctx->stream->output_color_space)\n\t\t\t\t\t\t&& pipe_ctx->plane_state->pre_multiplied_alpha);\n\t\tif (pipe_ctx->plane_state->global_alpha) {\n\t\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA_COMBINED_GLOBAL_GAIN;\n\t\t\tblnd_cfg.global_gain = pipe_ctx->plane_state->global_alpha_value;\n\t\t} else {\n\t\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;\n\t\t}\n\t} else {\n\t\tblnd_cfg.pre_multiplied_alpha = false;\n\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA;\n\t}\n\n\tif (pipe_ctx->plane_state->global_alpha)\n\t\tblnd_cfg.global_alpha = pipe_ctx->plane_state->global_alpha_value;\n\telse\n\t\tblnd_cfg.global_alpha = 0xff;\n\n\t \n\tmpcc_id = hubp->inst;\n\n\t \n\tif (!pipe_ctx->plane_state->update_flags.bits.full_update) {\n\t\tmpc->funcs->update_blending(mpc, &blnd_cfg, mpcc_id);\n\t\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\t\treturn;\n\t}\n\n\t \n\tnew_mpcc = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, mpcc_id);\n\t \n\tif (new_mpcc != NULL)\n\t\tmpc->funcs->remove_mpcc(mpc, mpc_tree_params, new_mpcc);\n\telse\n\t\tif (dc->debug.sanity_checks)\n\t\t\tmpc->funcs->assert_mpcc_idle_before_connect(\n\t\t\t\t\tdc->res_pool->mpc, mpcc_id);\n\n\t \n\tnew_mpcc = mpc->funcs->insert_plane(dc->res_pool->mpc,\n\t\t\tmpc_tree_params,\n\t\t\t&blnd_cfg,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\thubp->inst,\n\t\t\tmpcc_id);\n\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\n\tASSERT(new_mpcc != NULL);\n\thubp->opp_id = pipe_ctx->stream_res.opp->inst;\n\thubp->mpcc_id = mpcc_id;\n}\n\nstatic void update_scaler(struct pipe_ctx *pipe_ctx)\n{\n\tbool per_pixel_alpha =\n\t\t\tpipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;\n\n\tpipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;\n\tpipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_36BPP;\n\t \n\tpipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(\n\t\t\tpipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);\n}\n\nstatic void dcn10_update_dchubp_dpp(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe_ctx,\n\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct plane_size size = plane_state->plane_size;\n\tunsigned int compat_level = 0;\n\tbool should_divided_by_2 = false;\n\n\t \n\t \n\tif (plane_state->update_flags.bits.full_update) {\n\n\t\t \n\t\tif (context->bw_ctx.bw.dcn.clk.dispclk_khz <\n\t\t\t\tdc->clk_mgr->clks.dispclk_khz)\n\t\t\tshould_divided_by_2 = false;\n\t\telse\n\t\t\tshould_divided_by_2 =\n\t\t\t\t\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz <=\n\t\t\t\t\tdc->clk_mgr->clks.dispclk_khz / 2;\n\n\t\tdpp->funcs->dpp_dppclk_control(\n\t\t\t\tdpp,\n\t\t\t\tshould_divided_by_2,\n\t\t\t\ttrue);\n\n\t\tif (dc->res_pool->dccg)\n\t\t\tdc->res_pool->dccg->funcs->update_dpp_dto(\n\t\t\t\t\tdc->res_pool->dccg,\n\t\t\t\t\tdpp->inst,\n\t\t\t\t\tpipe_ctx->plane_res.bw.dppclk_khz);\n\t\telse\n\t\t\tdc->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?\n\t\t\t\t\t\tdc->clk_mgr->clks.dispclk_khz / 2 :\n\t\t\t\t\t\t\tdc->clk_mgr->clks.dispclk_khz;\n\t}\n\n\t \n\tif (plane_state->update_flags.bits.full_update) {\n\t\thubp->funcs->hubp_vtg_sel(hubp, pipe_ctx->stream_res.tg->inst);\n\n\t\thubp->funcs->hubp_setup(\n\t\t\thubp,\n\t\t\t&pipe_ctx->dlg_regs,\n\t\t\t&pipe_ctx->ttu_regs,\n\t\t\t&pipe_ctx->rq_regs,\n\t\t\t&pipe_ctx->pipe_dlg_param);\n\t\thubp->funcs->hubp_setup_interdependent(\n\t\t\thubp,\n\t\t\t&pipe_ctx->dlg_regs,\n\t\t\t&pipe_ctx->ttu_regs);\n\t}\n\n\tsize.surface_size = pipe_ctx->plane_res.scl_data.viewport;\n\n\tif (plane_state->update_flags.bits.full_update ||\n\t\tplane_state->update_flags.bits.bpp_change)\n\t\tdcn10_update_dpp(dpp, plane_state);\n\n\tif (plane_state->update_flags.bits.full_update ||\n\t\tplane_state->update_flags.bits.per_pixel_alpha_change ||\n\t\tplane_state->update_flags.bits.global_alpha_change)\n\t\thws->funcs.update_mpcc(dc, pipe_ctx);\n\n\tif (plane_state->update_flags.bits.full_update ||\n\t\tplane_state->update_flags.bits.per_pixel_alpha_change ||\n\t\tplane_state->update_flags.bits.global_alpha_change ||\n\t\tplane_state->update_flags.bits.scaling_change ||\n\t\tplane_state->update_flags.bits.position_change) {\n\t\tupdate_scaler(pipe_ctx);\n\t}\n\n\tif (plane_state->update_flags.bits.full_update ||\n\t\tplane_state->update_flags.bits.scaling_change ||\n\t\tplane_state->update_flags.bits.position_change) {\n\t\thubp->funcs->mem_program_viewport(\n\t\t\thubp,\n\t\t\t&pipe_ctx->plane_res.scl_data.viewport,\n\t\t\t&pipe_ctx->plane_res.scl_data.viewport_c);\n\t}\n\n\tif (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {\n\t\tdc->hwss.set_cursor_position(pipe_ctx);\n\t\tdc->hwss.set_cursor_attribute(pipe_ctx);\n\n\t\tif (dc->hwss.set_cursor_sdr_white_level)\n\t\t\tdc->hwss.set_cursor_sdr_white_level(pipe_ctx);\n\t}\n\n\tif (plane_state->update_flags.bits.full_update) {\n\t\t \n\t\tdc->hwss.program_gamut_remap(pipe_ctx);\n\n\t\tdc->hwss.program_output_csc(dc,\n\t\t\t\tpipe_ctx,\n\t\t\t\tpipe_ctx->stream->output_color_space,\n\t\t\t\tpipe_ctx->stream->csc_color_matrix.matrix,\n\t\t\t\tpipe_ctx->stream_res.opp->inst);\n\t}\n\n\tif (plane_state->update_flags.bits.full_update ||\n\t\tplane_state->update_flags.bits.pixel_format_change ||\n\t\tplane_state->update_flags.bits.horizontal_mirror_change ||\n\t\tplane_state->update_flags.bits.rotation_change ||\n\t\tplane_state->update_flags.bits.swizzle_change ||\n\t\tplane_state->update_flags.bits.dcc_change ||\n\t\tplane_state->update_flags.bits.bpp_change ||\n\t\tplane_state->update_flags.bits.scaling_change ||\n\t\tplane_state->update_flags.bits.plane_size_change) {\n\t\thubp->funcs->hubp_program_surface_config(\n\t\t\thubp,\n\t\t\tplane_state->format,\n\t\t\t&plane_state->tiling_info,\n\t\t\t&size,\n\t\t\tplane_state->rotation,\n\t\t\t&plane_state->dcc,\n\t\t\tplane_state->horizontal_mirror,\n\t\t\tcompat_level);\n\t}\n\n\thubp->power_gated = false;\n\n\thws->funcs.update_plane_addr(dc, pipe_ctx);\n\n\tif (is_pipe_tree_visible(pipe_ctx))\n\t\thubp->funcs->set_blank(hubp, false);\n}\n\nvoid dcn10_blank_pixel_data(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool blank)\n{\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\tstruct stream_resource *stream_res = &pipe_ctx->stream_res;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\n\t \n\tcolor_space = stream->output_color_space;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\t \n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tblack_color.color_r_cr = black_color.color_g_y;\n\n\n\tif (stream_res->tg->funcs->set_blank_color)\n\t\tstream_res->tg->funcs->set_blank_color(\n\t\t\t\tstream_res->tg,\n\t\t\t\t&black_color);\n\n\tif (!blank) {\n\t\tif (stream_res->tg->funcs->set_blank)\n\t\t\tstream_res->tg->funcs->set_blank(stream_res->tg, blank);\n\t\tif (stream_res->abm) {\n\t\t\tdc->hwss.set_pipe(pipe_ctx);\n\t\t\tstream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);\n\t\t}\n\t} else {\n\t\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\t\tif (stream_res->tg->funcs->set_blank) {\n\t\t\tstream_res->tg->funcs->wait_for_state(stream_res->tg, CRTC_STATE_VBLANK);\n\t\t\tstream_res->tg->funcs->set_blank(stream_res->tg, blank);\n\t\t}\n\t}\n}\n\nvoid dcn10_set_hdr_multiplier(struct pipe_ctx *pipe_ctx)\n{\n\tstruct fixed31_32 multiplier = pipe_ctx->plane_state->hdr_mult;\n\tuint32_t hw_mult = 0x1f000; \n\tstruct custom_float_format fmt;\n\n\tfmt.exponenta_bits = 6;\n\tfmt.mantissa_bits = 12;\n\tfmt.sign = true;\n\n\n\tif (!dc_fixpt_eq(multiplier, dc_fixpt_from_int(0))) \n\t\tconvert_to_custom_float_format(multiplier, &fmt, &hw_mult);\n\n\tpipe_ctx->plane_res.dpp->funcs->dpp_set_hdr_multiplier(\n\t\t\tpipe_ctx->plane_res.dpp, hw_mult);\n}\n\nvoid dcn10_program_pipe(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\tif (pipe_ctx->top_pipe == NULL) {\n\t\tbool blank = !is_pipe_tree_visible(pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg->funcs->program_global_sync(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\tcalculate_vready_offset_for_group(pipe_ctx),\n\t\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start,\n\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_offset,\n\t\t\t\tpipe_ctx->pipe_dlg_param.vupdate_width);\n\n\t\tpipe_ctx->stream_res.tg->funcs->set_vtg_params(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, true);\n\n\t\tif (hws->funcs.setup_vupdate_interrupt)\n\t\t\thws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);\n\n\t\thws->funcs.blank_pixel_data(dc, pipe_ctx, blank);\n\t}\n\n\tif (pipe_ctx->plane_state->update_flags.bits.full_update)\n\t\tdcn10_enable_plane(dc, pipe_ctx, context);\n\n\tdcn10_update_dchubp_dpp(dc, pipe_ctx, context);\n\n\thws->funcs.set_hdr_multiplier(pipe_ctx);\n\n\tif (pipe_ctx->plane_state->update_flags.bits.full_update ||\n\t\t\tpipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||\n\t\t\tpipe_ctx->plane_state->update_flags.bits.gamma_change)\n\t\thws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);\n\n\t \n\tif (pipe_ctx->plane_state->update_flags.bits.full_update)\n\t\thws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);\n}\n\nvoid dcn10_wait_for_pending_cleared(struct dc *dc,\n\t\tstruct dc_state *context)\n{\n\t\tstruct pipe_ctx *pipe_ctx;\n\t\tstruct timing_generator *tg;\n\t\tint i;\n\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tpipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\t\ttg = pipe_ctx->stream_res.tg;\n\n\t\t\t \n\t\t\tif (pipe_ctx->top_pipe ||\n\t\t\t    !pipe_ctx->stream || !pipe_ctx->plane_state ||\n\t\t\t    !tg->funcs->is_tg_enabled(tg))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpipe_ctx->stream_res.tg->funcs->wait_for_state(pipe_ctx->stream_res.tg, CRTC_STATE_VBLANK);\n\t\t\tpipe_ctx->stream_res.tg->funcs->wait_for_state(pipe_ctx->stream_res.tg, CRTC_STATE_VACTIVE);\n\t\t}\n}\n\nvoid dcn10_post_unlock_program_front_end(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx->top_pipe &&\n\t\t\t!pipe_ctx->prev_odm_pipe &&\n\t\t\tpipe_ctx->stream) {\n\t\t\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\n\t\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\t\tfalse_optc_underflow_wa(dc, pipe_ctx->stream, tg);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable)\n\t\t\tdc->hwss.disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable) {\n\t\t\tdc->hwss.optimize_bandwidth(dc, context);\n\t\t\tbreak;\n\t\t}\n\n\tif (dc->hwseq->wa.DEGVIDCN10_254)\n\t\thubbub1_wm_change_req_wa(dc->res_pool->hubbub);\n}\n\nstatic void dcn10_stereo_hw_frame_pack_wa(struct dc *dc, struct dc_state *context)\n{\n\tuint8_t i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->streams[i]->timing.timing_3d_format\n\t\t\t\t== TIMING_3D_FORMAT_HW_FRAME_PACKING) {\n\t\t\t \n\t\t\thubbub1_allow_self_refresh_control(dc->res_pool->hubbub, false);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid dcn10_prepare_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tint min_fclk_khz, min_dcfclk_khz, socclk_khz;\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\n\tif (context->stream_count == 0)\n\t\tcontext->bw_ctx.bw.dcn.clk.phyclk_khz = 0;\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\tfalse);\n\n\tdc->wm_optimized_required = hubbub->funcs->program_watermarks(hubbub,\n\t\t\t&context->bw_ctx.bw.dcn.watermarks,\n\t\t\tdc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,\n\t\t\ttrue);\n\tdcn10_stereo_hw_frame_pack_wa(dc, context);\n\n\tif (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE) {\n\t\tDC_FP_START();\n\t\tdcn_get_soc_clks(\n\t\t\tdc, &min_fclk_khz, &min_dcfclk_khz, &socclk_khz);\n\t\tDC_FP_END();\n\t\tdcn_bw_notify_pplib_of_wm_ranges(\n\t\t\tdc, min_fclk_khz, min_dcfclk_khz, socclk_khz);\n\t}\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\nvoid dcn10_optimize_bandwidth(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\tint min_fclk_khz, min_dcfclk_khz, socclk_khz;\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\n\tif (context->stream_count == 0)\n\t\tcontext->bw_ctx.bw.dcn.clk.phyclk_khz = 0;\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tcontext,\n\t\t\ttrue);\n\n\thubbub->funcs->program_watermarks(hubbub,\n\t\t\t&context->bw_ctx.bw.dcn.watermarks,\n\t\t\tdc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,\n\t\t\ttrue);\n\n\tdcn10_stereo_hw_frame_pack_wa(dc, context);\n\n\tif (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE) {\n\t\tDC_FP_START();\n\t\tdcn_get_soc_clks(\n\t\t\tdc, &min_fclk_khz, &min_dcfclk_khz, &socclk_khz);\n\t\tDC_FP_END();\n\t\tdcn_bw_notify_pplib_of_wm_ranges(\n\t\t\tdc, min_fclk_khz, min_dcfclk_khz, socclk_khz);\n\t}\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\nvoid dcn10_set_drr(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, struct dc_crtc_timing_adjust adjust)\n{\n\tint i = 0;\n\tstruct drr_params params = {0};\n\t\n\tunsigned int event_triggers = 0x800;\n\t\n\tunsigned int num_frames = 2;\n\n\tparams.vertical_total_max = adjust.v_total_max;\n\tparams.vertical_total_min = adjust.v_total_min;\n\tparams.vertical_total_mid = adjust.v_total_mid;\n\tparams.vertical_total_mid_frame_num = adjust.v_total_mid_frame_num;\n\t \n\tfor (i = 0; i < num_pipes; i++) {\n\t\tif ((pipe_ctx[i]->stream_res.tg != NULL) && pipe_ctx[i]->stream_res.tg->funcs) {\n\t\t\tif (pipe_ctx[i]->stream_res.tg->funcs->set_drr)\n\t\t\t\tpipe_ctx[i]->stream_res.tg->funcs->set_drr(\n\t\t\t\t\tpipe_ctx[i]->stream_res.tg, &params);\n\t\t\tif (adjust.v_total_max != 0 && adjust.v_total_min != 0)\n\t\t\t\tif (pipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control)\n\t\t\t\t\tpipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(\n\t\t\t\t\t\tpipe_ctx[i]->stream_res.tg,\n\t\t\t\t\t\tevent_triggers, num_frames);\n\t\t}\n\t}\n}\n\nvoid dcn10_get_position(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes,\n\t\tstruct crtc_position *position)\n{\n\tint i = 0;\n\n\t \n\tfor (i = 0; i < num_pipes; i++)\n\t\tpipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);\n}\n\nvoid dcn10_set_static_screen_control(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, const struct dc_static_screen_params *params)\n{\n\tunsigned int i;\n\tunsigned int triggers = 0;\n\n\tif (params->triggers.surface_update)\n\t\ttriggers |= 0x80;\n\tif (params->triggers.cursor_update)\n\t\ttriggers |= 0x2;\n\tif (params->triggers.force_trigger)\n\t\ttriggers |= 0x1;\n\n\tfor (i = 0; i < num_pipes; i++)\n\t\tpipe_ctx[i]->stream_res.tg->funcs->\n\t\t\tset_static_screen_control(pipe_ctx[i]->stream_res.tg,\n\t\t\t\t\ttriggers, params->num_frames);\n}\n\nstatic void dcn10_config_stereo_parameters(\n\t\tstruct dc_stream_state *stream, struct crtc_stereo_flags *flags)\n{\n\tenum view_3d_format view_format = stream->view_format;\n\tenum dc_timing_3d_format timing_3d_format =\\\n\t\t\tstream->timing.timing_3d_format;\n\tbool non_stereo_timing = false;\n\n\tif (timing_3d_format == TIMING_3D_FORMAT_NONE ||\n\t\ttiming_3d_format == TIMING_3D_FORMAT_SIDE_BY_SIDE ||\n\t\ttiming_3d_format == TIMING_3D_FORMAT_TOP_AND_BOTTOM)\n\t\tnon_stereo_timing = true;\n\n\tif (non_stereo_timing == false &&\n\t\tview_format == VIEW_3D_FORMAT_FRAME_SEQUENTIAL) {\n\n\t\tflags->PROGRAM_STEREO         = 1;\n\t\tflags->PROGRAM_POLARITY       = 1;\n\t\tif (timing_3d_format == TIMING_3D_FORMAT_FRAME_ALTERNATE ||\n\t\t\ttiming_3d_format == TIMING_3D_FORMAT_INBAND_FA ||\n\t\t\ttiming_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||\n\t\t\ttiming_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {\n\n\t\t\tif (stream->link && stream->link->ddc) {\n\t\t\t\tenum display_dongle_type dongle = \\\n\t\t\t\t\t\tstream->link->ddc->dongle_type;\n\n\t\t\t\tif (dongle == DISPLAY_DONGLE_DP_VGA_CONVERTER ||\n\t\t\t\t\tdongle == DISPLAY_DONGLE_DP_DVI_CONVERTER ||\n\t\t\t\t\tdongle == DISPLAY_DONGLE_DP_HDMI_CONVERTER)\n\t\t\t\t\tflags->DISABLE_STEREO_DP_SYNC = 1;\n\t\t\t}\n\t\t}\n\t\tflags->RIGHT_EYE_POLARITY =\\\n\t\t\t\tstream->timing.flags.RIGHT_EYE_3D_POLARITY;\n\t\tif (timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\t\tflags->FRAME_PACKED = 1;\n\t}\n\n\treturn;\n}\n\nvoid dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)\n{\n\tstruct crtc_stereo_flags flags = { 0 };\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\n\tdcn10_config_stereo_parameters(stream, &flags);\n\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {\n\t\tif (!dc_set_generic_gpio_for_stereo(true, dc->ctx->gpio_service))\n\t\t\tdc_set_generic_gpio_for_stereo(false, dc->ctx->gpio_service);\n\t} else {\n\t\tdc_set_generic_gpio_for_stereo(false, dc->ctx->gpio_service);\n\t}\n\n\tpipe_ctx->stream_res.opp->funcs->opp_program_stereo(\n\t\tpipe_ctx->stream_res.opp,\n\t\tflags.PROGRAM_STEREO == 1,\n\t\t&stream->timing);\n\n\tpipe_ctx->stream_res.tg->funcs->program_stereo(\n\t\tpipe_ctx->stream_res.tg,\n\t\t&stream->timing,\n\t\t&flags);\n\n\treturn;\n}\n\nstatic struct hubp *get_hubp_by_inst(struct resource_pool *res_pool, int mpcc_inst)\n{\n\tint i;\n\n\tfor (i = 0; i < res_pool->pipe_count; i++) {\n\t\tif (res_pool->hubps[i]->inst == mpcc_inst)\n\t\t\treturn res_pool->hubps[i];\n\t}\n\tASSERT(false);\n\treturn NULL;\n}\n\nvoid dcn10_wait_for_mpcc_disconnect(\n\t\tstruct dc *dc,\n\t\tstruct resource_pool *res_pool,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tint mpcc_inst;\n\n\tif (dc->debug.sanity_checks) {\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\t}\n\n\tif (!pipe_ctx->stream_res.opp)\n\t\treturn;\n\n\tfor (mpcc_inst = 0; mpcc_inst < MAX_PIPES; mpcc_inst++) {\n\t\tif (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst]) {\n\t\t\tstruct hubp *hubp = get_hubp_by_inst(res_pool, mpcc_inst);\n\n\t\t\tif (pipe_ctx->stream_res.tg &&\n\t\t\t\tpipe_ctx->stream_res.tg->funcs->is_tg_enabled(pipe_ctx->stream_res.tg))\n\t\t\t\tres_pool->mpc->funcs->wait_for_idle(res_pool->mpc, mpcc_inst);\n\t\t\tpipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst] = false;\n\t\t\thubp->funcs->set_blank(hubp, true);\n\t\t}\n\t}\n\n\tif (dc->debug.sanity_checks) {\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\t}\n\n}\n\nbool dcn10_dummy_display_power_gating(\n\tstruct dc *dc,\n\tuint8_t controller_id,\n\tstruct dc_bios *dcb,\n\tenum pipe_gating_control power_gating)\n{\n\treturn true;\n}\n\nvoid dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tbool flip_pending;\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\tflip_pending = pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(\n\t\t\t\t\tpipe_ctx->plane_res.hubp);\n\n\tplane_state->status.is_flip_pending = plane_state->status.is_flip_pending || flip_pending;\n\n\tif (!flip_pending)\n\t\tplane_state->status.current_address = plane_state->status.requested_address;\n\n\tif (plane_state->status.current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t\ttg->funcs->is_stereo_left_eye) {\n\t\tplane_state->status.is_right_eye =\n\t\t\t\t!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);\n\t}\n\n\tif (dc->hwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied) {\n\t\tstruct dce_hwseq *hwseq = dc->hwseq;\n\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[0];\n\t\tunsigned int cur_frame = tg->funcs->get_frame_count(tg);\n\n\t\tif (cur_frame != hwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied_on_frame) {\n\t\t\tstruct hubbub *hubbub = dc->res_pool->hubbub;\n\n\t\t\thubbub->funcs->allow_self_refresh_control(hubbub, !dc->debug.disable_stutter);\n\t\t\thwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied = false;\n\t\t}\n\t}\n}\n\nvoid dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)\n{\n\tstruct hubbub *hubbub = hws->ctx->dc->res_pool->hubbub;\n\n\t \n\thubbub->funcs->update_dchub(hubbub, dh_data);\n}\n\nstatic bool dcn10_can_pipe_disable_cursor(struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *test_pipe, *split_pipe;\n\tconst struct scaler_data *scl_data = &pipe_ctx->plane_res.scl_data;\n\tstruct rect r1 = scl_data->recout, r2, r2_half;\n\tint r1_r = r1.x + r1.width, r1_b = r1.y + r1.height, r2_r, r2_b;\n\tint cur_layer = pipe_ctx->plane_state->layer_index;\n\n\t \n\tfor (test_pipe = pipe_ctx->top_pipe; test_pipe;\n\t     test_pipe = test_pipe->top_pipe) {\n\t\t\n\t\tif (!test_pipe->plane_state ||\n\t\t    !test_pipe->plane_state->visible ||\n\t\t    test_pipe->plane_state->layer_index == cur_layer)\n\t\t\tcontinue;\n\n\t\tr2 = test_pipe->plane_res.scl_data.recout;\n\t\tr2_r = r2.x + r2.width;\n\t\tr2_b = r2.y + r2.height;\n\t\tsplit_pipe = test_pipe;\n\n\t\t \n\t\tfor (split_pipe = pipe_ctx->top_pipe; split_pipe;\n\t\t     split_pipe = split_pipe->top_pipe)\n\t\t\tif (split_pipe->plane_state->layer_index == test_pipe->plane_state->layer_index) {\n\t\t\t\tr2_half = split_pipe->plane_res.scl_data.recout;\n\t\t\t\tr2.x = (r2_half.x < r2.x) ? r2_half.x : r2.x;\n\t\t\t\tr2.width = r2.width + r2_half.width;\n\t\t\t\tr2_r = r2.x + r2.width;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (r1.x >= r2.x && r1.y >= r2.y && r1_r <= r2_r && r1_b <= r2_b)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct dpp *dpp = pipe_ctx->plane_res.dpp;\n\tstruct dc_cursor_mi_param param = {\n\t\t.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,\n\t\t.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clocks.dchub_ref_clock_inKhz,\n\t\t.viewport = pipe_ctx->plane_res.scl_data.viewport,\n\t\t.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,\n\t\t.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,\n\t\t.rotation = pipe_ctx->plane_state->rotation,\n\t\t.mirror = pipe_ctx->plane_state->horizontal_mirror,\n\t\t.stream = pipe_ctx->stream,\n\t};\n\tbool pipe_split_on = false;\n\tbool odm_combine_on = (pipe_ctx->next_odm_pipe != NULL) ||\n\t\t(pipe_ctx->prev_odm_pipe != NULL);\n\n\tint x_plane = pipe_ctx->plane_state->dst_rect.x;\n\tint y_plane = pipe_ctx->plane_state->dst_rect.y;\n\tint x_pos = pos_cpy.x;\n\tint y_pos = pos_cpy.y;\n\n\tif ((pipe_ctx->top_pipe != NULL) || (pipe_ctx->bottom_pipe != NULL)) {\n\t\tif ((pipe_ctx->plane_state->src_rect.width != pipe_ctx->plane_res.scl_data.viewport.width) ||\n\t\t\t(pipe_ctx->plane_state->src_rect.height != pipe_ctx->plane_res.scl_data.viewport.height)) {\n\t\t\tpipe_split_on = true;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (param.rotation == ROTATION_ANGLE_90 || param.rotation == ROTATION_ANGLE_270) {\n\t\tx_pos = (x_pos - x_plane) * pipe_ctx->plane_state->src_rect.height /\n\t\t\t\tpipe_ctx->plane_state->dst_rect.width;\n\t\ty_pos = (y_pos - y_plane) * pipe_ctx->plane_state->src_rect.width /\n\t\t\t\tpipe_ctx->plane_state->dst_rect.height;\n\t} else {\n\t\tx_pos = (x_pos - x_plane) * pipe_ctx->plane_state->src_rect.width /\n\t\t\t\tpipe_ctx->plane_state->dst_rect.width;\n\t\ty_pos = (y_pos - y_plane) * pipe_ctx->plane_state->src_rect.height /\n\t\t\t\tpipe_ctx->plane_state->dst_rect.height;\n\t}\n\n\t \n\tif (pos_cpy.translate_by_source) {\n\t\tx_pos += pipe_ctx->plane_state->src_rect.x;\n\t\ty_pos += pipe_ctx->plane_state->src_rect.y;\n\t}\n\n\t \n\n\tif (x_pos < 0) {\n\t\tpos_cpy.x_hotspot -= x_pos;\n\t\tx_pos = 0;\n\t}\n\n\tif (y_pos < 0) {\n\t\tpos_cpy.y_hotspot -= y_pos;\n\t\ty_pos = 0;\n\t}\n\n\tpos_cpy.x = (uint32_t)x_pos;\n\tpos_cpy.y = (uint32_t)y_pos;\n\n\tif (pipe_ctx->plane_state->address.type\n\t\t\t== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)\n\t\tpos_cpy.enable = false;\n\n\tif (pos_cpy.enable && dcn10_can_pipe_disable_cursor(pipe_ctx))\n\t\tpos_cpy.enable = false;\n\n\n\tif (param.rotation == ROTATION_ANGLE_0) {\n\t\tint viewport_width =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.width;\n\t\tint viewport_x =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.x;\n\n\t\tif (param.mirror) {\n\t\t\tif (pipe_split_on || odm_combine_on) {\n\t\t\t\tif (pos_cpy.x >= viewport_width + viewport_x) {\n\t\t\t\t\tpos_cpy.x = 2 * viewport_width\n\t\t\t\t\t\t\t- pos_cpy.x + 2 * viewport_x;\n\t\t\t\t} else {\n\t\t\t\t\tuint32_t temp_x = pos_cpy.x;\n\n\t\t\t\t\tpos_cpy.x = 2 * viewport_x - pos_cpy.x;\n\t\t\t\t\tif (temp_x >= viewport_x +\n\t\t\t\t\t\t(int)hubp->curs_attr.width || pos_cpy.x\n\t\t\t\t\t\t<= (int)hubp->curs_attr.width +\n\t\t\t\t\t\tpipe_ctx->plane_state->src_rect.x) {\n\t\t\t\t\t\tpos_cpy.x = temp_x + viewport_width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos_cpy.x = viewport_width - pos_cpy.x + 2 * viewport_x;\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse if (param.rotation == ROTATION_ANGLE_90) {\n\t\tuint32_t temp_x = pos_cpy.x;\n\n\t\tpos_cpy.x = pipe_ctx->plane_res.scl_data.viewport.width -\n\t\t\t\t(pos_cpy.y - pipe_ctx->plane_res.scl_data.viewport.x) + pipe_ctx->plane_res.scl_data.viewport.x;\n\t\tpos_cpy.y = temp_x;\n\t}\n\t\n\telse if (param.rotation == ROTATION_ANGLE_270) {\n\t\tuint32_t temp_y = pos_cpy.y;\n\t\tint viewport_height =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.height;\n\t\tint viewport_y =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.y;\n\n\t\t \n\t\tif (pipe_split_on || odm_combine_on) {\n\t\t\tint pos_cpy_x_offset;\n\t\t\tint other_pipe_viewport_y;\n\n\t\t\tif (pipe_split_on) {\n\t\t\t\tif (pipe_ctx->bottom_pipe) {\n\t\t\t\t\tother_pipe_viewport_y =\n\t\t\t\t\t\tpipe_ctx->bottom_pipe->plane_res.scl_data.viewport.y;\n\t\t\t\t} else {\n\t\t\t\t\tother_pipe_viewport_y =\n\t\t\t\t\t\tpipe_ctx->top_pipe->plane_res.scl_data.viewport.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pipe_ctx->next_odm_pipe) {\n\t\t\t\t\tother_pipe_viewport_y =\n\t\t\t\t\t\tpipe_ctx->next_odm_pipe->plane_res.scl_data.viewport.y;\n\t\t\t\t} else {\n\t\t\t\t\tother_pipe_viewport_y =\n\t\t\t\t\t\tpipe_ctx->prev_odm_pipe->plane_res.scl_data.viewport.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos_cpy_x_offset = (viewport_y > other_pipe_viewport_y) ?\n\t\t\t\tother_pipe_viewport_y : viewport_y;\n\t\t\tpos_cpy.x -= pos_cpy_x_offset;\n\t\t\tif (pos_cpy.x > viewport_height) {\n\t\t\t\tpos_cpy.x = pos_cpy.x - viewport_height;\n\t\t\t\tpos_cpy.y = viewport_height - pos_cpy.x;\n\t\t\t} else {\n\t\t\t\tpos_cpy.y = 2 * viewport_height - pos_cpy.x;\n\t\t\t}\n\t\t\tpos_cpy.y += pos_cpy_x_offset;\n\t\t} else {\n\t\t\tpos_cpy.y = (2 * viewport_y) + viewport_height - pos_cpy.x;\n\t\t}\n\t\tpos_cpy.x = temp_y;\n\t}\n\t\n\telse if (param.rotation == ROTATION_ANGLE_180) {\n\t\tint viewport_width =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.width;\n\t\tint viewport_x =\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.x;\n\n\t\tif (!param.mirror) {\n\t\t\tif (pipe_split_on || odm_combine_on) {\n\t\t\t\tif (pos_cpy.x >= viewport_width + viewport_x) {\n\t\t\t\t\tpos_cpy.x = 2 * viewport_width\n\t\t\t\t\t\t\t- pos_cpy.x + 2 * viewport_x;\n\t\t\t\t} else {\n\t\t\t\t\tuint32_t temp_x = pos_cpy.x;\n\n\t\t\t\t\tpos_cpy.x = 2 * viewport_x - pos_cpy.x;\n\t\t\t\t\tif (temp_x >= viewport_x +\n\t\t\t\t\t\t(int)hubp->curs_attr.width || pos_cpy.x\n\t\t\t\t\t\t<= (int)hubp->curs_attr.width +\n\t\t\t\t\t\tpipe_ctx->plane_state->src_rect.x) {\n\t\t\t\t\t\tpos_cpy.x = 2 * viewport_width - temp_x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos_cpy.x = viewport_width - pos_cpy.x + 2 * viewport_x;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpos_cpy.y = (2 * pipe_ctx->plane_res.scl_data.viewport.y) +\n\t\t\tpipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.y;\n\t}\n\n\thubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);\n\tdpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width, hubp->curs_attr.height);\n}\n\nvoid dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;\n\n\tpipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(\n\t\t\tpipe_ctx->plane_res.hubp, attributes);\n\tpipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(\n\t\tpipe_ctx->plane_res.dpp, attributes);\n}\n\nvoid dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)\n{\n\tuint32_t sdr_white_level = pipe_ctx->stream->cursor_attributes.sdr_white_level;\n\tstruct fixed31_32 multiplier;\n\tstruct dpp_cursor_attributes opt_attr = { 0 };\n\tuint32_t hw_scale = 0x3c00; \n\tstruct custom_float_format fmt;\n\n\tif (!pipe_ctx->plane_res.dpp->funcs->set_optional_cursor_attributes)\n\t\treturn;\n\n\tfmt.exponenta_bits = 5;\n\tfmt.mantissa_bits = 10;\n\tfmt.sign = true;\n\n\tif (sdr_white_level > 80) {\n\t\tmultiplier = dc_fixpt_from_fraction(sdr_white_level, 80);\n\t\tconvert_to_custom_float_format(multiplier, &fmt, &hw_scale);\n\t}\n\n\topt_attr.scale = hw_scale;\n\topt_attr.bias = 0;\n\n\tpipe_ctx->plane_res.dpp->funcs->set_optional_cursor_attributes(\n\t\t\tpipe_ctx->plane_res.dpp, &opt_attr);\n}\n\n \nstatic void apply_front_porch_workaround(\n\tstruct dc_crtc_timing *timing)\n{\n\tif (timing->flags.INTERLACE == 1) {\n\t\tif (timing->v_front_porch < 2)\n\t\t\ttiming->v_front_porch = 2;\n\t} else {\n\t\tif (timing->v_front_porch < 1)\n\t\t\ttiming->v_front_porch = 1;\n\t}\n}\n\nint dcn10_get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)\n{\n\tconst struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;\n\tstruct dc_crtc_timing patched_crtc_timing;\n\tint vesa_sync_start;\n\tint asic_blank_end;\n\tint interlace_factor;\n\n\tpatched_crtc_timing = *dc_crtc_timing;\n\tapply_front_porch_workaround(&patched_crtc_timing);\n\n\tinterlace_factor = patched_crtc_timing.flags.INTERLACE ? 2 : 1;\n\n\tvesa_sync_start = patched_crtc_timing.v_addressable +\n\t\t\tpatched_crtc_timing.v_border_bottom +\n\t\t\tpatched_crtc_timing.v_front_porch;\n\n\tasic_blank_end = (patched_crtc_timing.v_total -\n\t\t\tvesa_sync_start -\n\t\t\tpatched_crtc_timing.v_border_top)\n\t\t\t* interlace_factor;\n\n\treturn asic_blank_end -\n\t\t\tpipe_ctx->pipe_dlg_param.vstartup_start + 1;\n}\n\nvoid dcn10_calc_vupdate_position(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tuint32_t *start_line,\n\t\tuint32_t *end_line)\n{\n\tconst struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;\n\tint vupdate_pos = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);\n\n\tif (vupdate_pos >= 0)\n\t\t*start_line = vupdate_pos - ((vupdate_pos / timing->v_total) * timing->v_total);\n\telse\n\t\t*start_line = vupdate_pos + ((-vupdate_pos / timing->v_total) + 1) * timing->v_total - 1;\n\t*end_line = (*start_line + 2) % timing->v_total;\n}\n\nstatic void dcn10_cal_vline_position(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tuint32_t *start_line,\n\t\tuint32_t *end_line)\n{\n\tconst struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;\n\tint vline_pos = pipe_ctx->stream->periodic_interrupt.lines_offset;\n\n\tif (pipe_ctx->stream->periodic_interrupt.ref_point == START_V_UPDATE) {\n\t\tif (vline_pos > 0)\n\t\t\tvline_pos--;\n\t\telse if (vline_pos < 0)\n\t\t\tvline_pos++;\n\n\t\tvline_pos += dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);\n\t\tif (vline_pos >= 0)\n\t\t\t*start_line = vline_pos - ((vline_pos / timing->v_total) * timing->v_total);\n\t\telse\n\t\t\t*start_line = vline_pos + ((-vline_pos / timing->v_total) + 1) * timing->v_total - 1;\n\t\t*end_line = (*start_line + 2) % timing->v_total;\n\t} else if (pipe_ctx->stream->periodic_interrupt.ref_point == START_V_SYNC) {\n\t\t\n\t\t*start_line = vline_pos;\n\t\t*end_line = (*start_line + 2) % timing->v_total;\n\t} else\n\t\tASSERT(0);\n}\n\nvoid dcn10_setup_periodic_interrupt(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx)\n{\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tuint32_t start_line = 0;\n\tuint32_t end_line = 0;\n\n\tdcn10_cal_vline_position(dc, pipe_ctx, &start_line, &end_line);\n\n\ttg->funcs->setup_vertical_interrupt0(tg, start_line, end_line);\n}\n\nvoid dcn10_setup_vupdate_interrupt(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tint start_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);\n\n\tif (start_line < 0) {\n\t\tASSERT(0);\n\t\tstart_line = 0;\n\t}\n\n\tif (tg->funcs->setup_vertical_interrupt2)\n\t\ttg->funcs->setup_vertical_interrupt2(tg, start_line);\n}\n\nvoid dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tstruct encoder_unblank_param params = {0};\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\n\t \n\tparams.timing = pipe_ctx->stream->timing;\n\n\tparams.link_settings.link_rate = link_settings->link_rate;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\tif (params.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\tparams.timing.pix_clk_100hz /= 2;\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_unblank(link, pipe_ctx->stream_res.stream_enc, &params);\n\t}\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\thws->funcs.edp_backlight_control(link, true);\n\t}\n}\n\nvoid dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,\n\t\t\t\tconst uint8_t *custom_sdp_message,\n\t\t\t\tunsigned int sdp_message_size)\n{\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\tpipe_ctx->stream_res.stream_enc->funcs->send_immediate_sdp_message(\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\tcustom_sdp_message,\n\t\t\t\tsdp_message_size);\n\t}\n}\nenum dc_status dcn10_set_clock(struct dc *dc,\n\t\t\tenum dc_clock_type clock_type,\n\t\t\tuint32_t clk_khz,\n\t\t\tuint32_t stepping)\n{\n\tstruct dc_state *context = dc->current_state;\n\tstruct dc_clock_config clock_cfg = {0};\n\tstruct dc_clocks *current_clocks = &context->bw_ctx.bw.dcn.clk;\n\n\tif (!dc->clk_mgr || !dc->clk_mgr->funcs->get_clock)\n\t\treturn DC_FAIL_UNSUPPORTED_1;\n\n\tdc->clk_mgr->funcs->get_clock(dc->clk_mgr,\n\t\tcontext, clock_type, &clock_cfg);\n\n\tif (clk_khz > clock_cfg.max_clock_khz)\n\t\treturn DC_FAIL_CLK_EXCEED_MAX;\n\n\tif (clk_khz < clock_cfg.min_clock_khz)\n\t\treturn DC_FAIL_CLK_BELOW_MIN;\n\n\tif (clk_khz < clock_cfg.bw_requirequired_clock_khz)\n\t\treturn DC_FAIL_CLK_BELOW_CFG_REQUIRED;\n\n\t \n\tif (clock_type == DC_CLOCK_TYPE_DISPCLK)\n\t\tcurrent_clocks->dispclk_khz = clk_khz;\n\telse if (clock_type == DC_CLOCK_TYPE_DPPCLK)\n\t\tcurrent_clocks->dppclk_khz = clk_khz;\n\telse\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc->clk_mgr->funcs->update_clocks)\n\t\t\t\tdc->clk_mgr->funcs->update_clocks(dc->clk_mgr,\n\t\t\t\tcontext, true);\n\treturn DC_OK;\n\n}\n\nvoid dcn10_get_clock(struct dc *dc,\n\t\t\tenum dc_clock_type clock_type,\n\t\t\tstruct dc_clock_config *clock_cfg)\n{\n\tstruct dc_state *context = dc->current_state;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->get_clock)\n\t\t\t\tdc->clk_mgr->funcs->get_clock(dc->clk_mgr, context, clock_type, clock_cfg);\n\n}\n\nvoid dcn10_get_dcc_en_bits(struct dc *dc, int *dcc_en_bits)\n{\n\tstruct resource_pool *pool = dc->res_pool;\n\tint i;\n\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct hubp *hubp = pool->hubps[i];\n\t\tstruct dcn_hubp_state *s = &(TO_DCN10_HUBP(hubp)->state);\n\n\t\thubp->funcs->hubp_read_state(hubp);\n\n\t\tif (!s->blank_en)\n\t\t\tdcc_en_bits[i] = s->dcc_en ? 1 : 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}