{
  "module_name": "dcn32_clk_mgr_smu_msg.c",
  "hash_id": "e66d8d7ece4a314308fe0a3284b699fd0afc27cb7eba9d845e01dea395f6865d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr_smu_msg.c",
  "human_readable_source": " \n\n#include \"dcn32_clk_mgr_smu_msg.h\"\n\n#include \"clk_mgr_internal.h\"\n#include \"reg_helper.h\"\n#include \"dalsmc.h\"\n#include \"smu13_driver_if.h\"\n\n#define mmDAL_MSG_REG  0x1628A\n#define mmDAL_ARG_REG  0x16273\n#define mmDAL_RESP_REG 0x16274\n\n#define REG(reg_name) \\\n\tmm ## reg_name\n\n#include \"logger_types.h\"\n\n#define smu_print(str, ...) {DC_LOG_SMU(str, ##__VA_ARGS__); }\n\n\n \nstatic uint32_t dcn32_smu_wait_for_response(struct clk_mgr_internal *clk_mgr, unsigned int delay_us, unsigned int max_retries)\n{\n\tuint32_t reg = 0;\n\n\tdo {\n\t\treg = REG_READ(DAL_RESP_REG);\n\t\tif (reg)\n\t\t\tbreak;\n\n\t\tif (delay_us >= 1000)\n\t\t\tmsleep(delay_us/1000);\n\t\telse if (delay_us > 0)\n\t\t\tudelay(delay_us);\n\t} while (max_retries--);\n\n\treturn reg;\n}\n\nstatic bool dcn32_smu_send_msg_with_param(struct clk_mgr_internal *clk_mgr, uint32_t msg_id, uint32_t param_in, uint32_t *param_out)\n{\n\t \n\tdcn32_smu_wait_for_response(clk_mgr, 10, 200000);\n\n\t \n\tREG_WRITE(DAL_RESP_REG, 0);\n\n\t \n\tREG_WRITE(DAL_ARG_REG, param_in);\n\n\t \n\tREG_WRITE(DAL_MSG_REG, msg_id);\n\n\t \n\tif (dcn32_smu_wait_for_response(clk_mgr, 10, 200000) == DALSMC_Result_OK) {\n\t\tif (param_out)\n\t\t\t*param_out = REG_READ(DAL_ARG_REG);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid dcn32_smu_send_fclk_pstate_message(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tsmu_print(\"FCLK P-state support value is : %d\\n\", enable);\n\n\tdcn32_smu_send_msg_with_param(clk_mgr,\n\t\t\tDALSMC_MSG_SetFclkSwitchAllow, enable ? FCLK_PSTATE_SUPPORTED : FCLK_PSTATE_NOTSUPPORTED, NULL);\n}\n\nvoid dcn32_smu_send_cab_for_uclk_message(struct clk_mgr_internal *clk_mgr, unsigned int num_ways)\n{\n\tuint32_t param = (num_ways << 1) | (num_ways > 0);\n\n\tdcn32_smu_send_msg_with_param(clk_mgr, DALSMC_MSG_SetCabForUclkPstate, param, NULL);\n\tsmu_print(\"Numways for SubVP : %d\\n\", num_ways);\n}\n\nvoid dcn32_smu_transfer_wm_table_dram_2_smu(struct clk_mgr_internal *clk_mgr)\n{\n\tsmu_print(\"SMU Transfer WM table DRAM 2 SMU\\n\");\n\n\tdcn32_smu_send_msg_with_param(clk_mgr,\n\t\t\tDALSMC_MSG_TransferTableDram2Smu, TABLE_WATERMARKS, NULL);\n}\n\nvoid dcn32_smu_set_pme_workaround(struct clk_mgr_internal *clk_mgr)\n{\n\tsmu_print(\"SMU Set PME workaround\\n\");\n\n\tdcn32_smu_send_msg_with_param(clk_mgr,\n\t\tDALSMC_MSG_BacoAudioD3PME, 0, NULL);\n}\n\n \nunsigned int dcn32_smu_set_hard_min_by_freq(struct clk_mgr_internal *clk_mgr, uint32_t clk, uint16_t freq_mhz)\n{\n\tuint32_t response = 0;\n\n\t \n\tuint32_t param = (clk << 16) | freq_mhz;\n\n\tsmu_print(\"SMU Set hard min by freq: clk = %d, freq_mhz = %d MHz\\n\", clk, freq_mhz);\n\n\tdcn32_smu_send_msg_with_param(clk_mgr,\n\t\t\tDALSMC_MSG_SetHardMinByFreq, param, &response);\n\n\tsmu_print(\"SMU Frequency set = %d KHz\\n\", response);\n\n\treturn response;\n}\n\nvoid dcn32_smu_wait_for_dmub_ack_mclk(struct clk_mgr_internal *clk_mgr, bool enable)\n{\n\tsmu_print(\"PMFW to wait for DMCUB ack for MCLK : %d\\n\", enable);\n\n\tdcn32_smu_send_msg_with_param(clk_mgr, 0x14, enable ? 1 : 0, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}