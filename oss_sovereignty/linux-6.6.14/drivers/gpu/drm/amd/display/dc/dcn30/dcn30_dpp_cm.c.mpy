{
  "module_name": "dcn30_dpp_cm.c",
  "hash_id": "a5dc4588e4e2f2f4400103885925afc4b570502704a1c0fc813a49f297a135f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dpp_cm.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n#include \"reg_helper.h\"\n#include \"dcn30_dpp.h\"\n#include \"basics/conversion.h\"\n#include \"dcn30_cm_common.h\"\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\nstatic void dpp3_enable_cm_block(\n\t\tstruct dpp *dpp_base)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tunsigned int cm_bypass_mode = 0;\n\n\t\n\tif (dpp_base->ctx->dc->debug.cm_in_bypass)\n\t\tcm_bypass_mode = 1;\n\n\tREG_UPDATE(CM_CONTROL, CM_BYPASS, cm_bypass_mode);\n}\n\nstatic enum dc_lut_mode dpp30_get_gamcor_current(struct dpp *dpp_base)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t state_mode;\n\tuint32_t lut_mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_GET(CM_GAMCOR_CONTROL, CM_GAMCOR_MODE_CURRENT, &state_mode);\n\n\tif (state_mode == 0)\n\t\tmode = LUT_BYPASS;\n\n\tif (state_mode == 2) {\n\t\tREG_GET(CM_GAMCOR_CONTROL, CM_GAMCOR_SELECT_CURRENT, &lut_mode);\n\t\tif (lut_mode == 0)\n\t\t\tmode = LUT_RAM_A;\n\t\telse\n\t\t\tmode = LUT_RAM_B;\n\t}\n\n\treturn mode;\n}\n\nstatic void dpp3_program_gammcor_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num,\n\t\tbool is_ram_a)\n{\n\tuint32_t i;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tuint32_t last_base_value_red = rgb[num-1].red_reg + rgb[num-1].delta_red_reg;\n\tuint32_t last_base_value_green = rgb[num-1].green_reg + rgb[num-1].delta_green_reg;\n\tuint32_t last_base_value_blue = rgb[num-1].blue_reg + rgb[num-1].delta_blue_reg;\n\n\t \n\tif (is_rgb_equal(rgb,  num)) {\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, rgb[i].red_reg);\n\n\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, last_base_value_red);\n\n\t} else {\n\t\tREG_UPDATE(CM_GAMCOR_LUT_CONTROL,\n\t\t\t\tCM_GAMCOR_LUT_WRITE_COLOR_MASK, 4);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, rgb[i].red_reg);\n\n\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, last_base_value_red);\n\n\t\tREG_SET(CM_GAMCOR_LUT_INDEX, 0, CM_GAMCOR_LUT_INDEX, 0);\n\n\t\tREG_UPDATE(CM_GAMCOR_LUT_CONTROL,\n\t\t\t\tCM_GAMCOR_LUT_WRITE_COLOR_MASK, 2);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, rgb[i].green_reg);\n\n\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, last_base_value_green);\n\n\t\tREG_SET(CM_GAMCOR_LUT_INDEX, 0, CM_GAMCOR_LUT_INDEX, 0);\n\n\t\tREG_UPDATE(CM_GAMCOR_LUT_CONTROL,\n\t\t\t\tCM_GAMCOR_LUT_WRITE_COLOR_MASK, 1);\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(CM_GAMCOR_LUT_DATA, 0, CM_GAMCOR_LUT_DATA, last_base_value_blue);\n\t}\n}\n\nstatic void dpp3_power_on_gamcor_lut(\n\t\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm) {\n\t\tif (power_on) {\n\t\t\tREG_UPDATE(CM_MEM_PWR_CTRL, GAMCOR_MEM_PWR_FORCE, 0);\n\t\t\tREG_WAIT(CM_MEM_PWR_STATUS, GAMCOR_MEM_PWR_STATE, 0, 1, 5);\n\t\t} else {\n\t\t\tdpp_base->ctx->dc->optimized_required = true;\n\t\t\tdpp_base->deferred_reg_writes.bits.disable_gamcor = true;\n\t\t}\n\t} else\n\t\tREG_SET(CM_MEM_PWR_CTRL, 0,\n\t\t\t\tGAMCOR_MEM_PWR_DIS, power_on == true ? 0:1);\n}\n\nvoid dpp3_program_cm_dealpha(\n\t\tstruct dpp *dpp_base,\n\tuint32_t enable, uint32_t additive_blending)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_SET_2(CM_DEALPHA, 0,\n\t\t\tCM_DEALPHA_EN, enable,\n\t\t\tCM_DEALPHA_ABLND, additive_blending);\n}\n\nvoid dpp3_program_cm_bias(\n\tstruct dpp *dpp_base,\n\tstruct CM_bias_params *bias_params)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_SET(CM_BIAS_CR_R, 0, CM_BIAS_CR_R, bias_params->cm_bias_cr_r);\n\tREG_SET_2(CM_BIAS_Y_G_CB_B, 0,\n\t\t\tCM_BIAS_Y_G, bias_params->cm_bias_y_g,\n\t\t\tCM_BIAS_CB_B, bias_params->cm_bias_cb_b);\n}\n\nstatic void dpp3_gamcor_reg_field(\n\t\tstruct dcn3_dpp *dpp,\n\t\tstruct dcn3_xfer_func_reg *reg)\n{\n\n\treg->shifts.field_region_start_base = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_START_BASE_B;\n\treg->masks.field_region_start_base = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_START_BASE_B;\n\treg->shifts.field_offset = dpp->tf_shift->CM_GAMCOR_RAMA_OFFSET_B;\n\treg->masks.field_offset = dpp->tf_mask->CM_GAMCOR_RAMA_OFFSET_B;\n\n\treg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_END_B;\n\treg->masks.field_region_end = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->masks.field_region_linear_slope = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->shifts.exp_region_start = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_GAMCOR_RAMA_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dpp->tf_mask->CM_GAMCOR_RAMA_EXP_REGION_START_SEGMENT_B;\n}\n\nstatic void dpp3_configure_gamcor_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE(CM_GAMCOR_LUT_CONTROL,\n\t\t\tCM_GAMCOR_LUT_WRITE_COLOR_MASK, 7);\n\tREG_UPDATE(CM_GAMCOR_LUT_CONTROL,\n\t\t\tCM_GAMCOR_LUT_HOST_SEL, is_ram_a == true ? 0:1);\n\tREG_SET(CM_GAMCOR_LUT_INDEX, 0, CM_GAMCOR_LUT_INDEX, 0);\n}\n\n\nbool dpp3_program_gamcor_lut(\n\tstruct dpp *dpp_base, const struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tstruct dcn3_xfer_func_reg gam_regs;\n\n\tdpp3_enable_cm_block(dpp_base);\n\n\tif (params == NULL) { \n\t\tREG_SET(CM_GAMCOR_CONTROL, 0, CM_GAMCOR_MODE, 0);\n\t\tif (dpp_base->ctx->dc->debug.enable_mem_low_power.bits.cm)\n\t\t\tdpp3_power_on_gamcor_lut(dpp_base, false);\n\t\treturn false;\n\t}\n\tdpp3_power_on_gamcor_lut(dpp_base, true);\n\tREG_SET(CM_GAMCOR_CONTROL, 0, CM_GAMCOR_MODE, 2);\n\n\tcurrent_mode = dpp30_get_gamcor_current(dpp_base);\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)\n\t\tnext_mode = LUT_RAM_B;\n\telse\n\t\tnext_mode = LUT_RAM_A;\n\n\tdpp3_power_on_gamcor_lut(dpp_base, true);\n\tdpp3_configure_gamcor_lut(dpp_base, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_B) {\n\t\tgam_regs.start_cntl_b = REG(CM_GAMCOR_RAMB_START_CNTL_B);\n\t\tgam_regs.start_cntl_g = REG(CM_GAMCOR_RAMB_START_CNTL_G);\n\t\tgam_regs.start_cntl_r = REG(CM_GAMCOR_RAMB_START_CNTL_R);\n\t\tgam_regs.start_slope_cntl_b = REG(CM_GAMCOR_RAMB_START_SLOPE_CNTL_B);\n\t\tgam_regs.start_slope_cntl_g = REG(CM_GAMCOR_RAMB_START_SLOPE_CNTL_G);\n\t\tgam_regs.start_slope_cntl_r = REG(CM_GAMCOR_RAMB_START_SLOPE_CNTL_R);\n\t\tgam_regs.start_end_cntl1_b = REG(CM_GAMCOR_RAMB_END_CNTL1_B);\n\t\tgam_regs.start_end_cntl2_b = REG(CM_GAMCOR_RAMB_END_CNTL2_B);\n\t\tgam_regs.start_end_cntl1_g = REG(CM_GAMCOR_RAMB_END_CNTL1_G);\n\t\tgam_regs.start_end_cntl2_g = REG(CM_GAMCOR_RAMB_END_CNTL2_G);\n\t\tgam_regs.start_end_cntl1_r = REG(CM_GAMCOR_RAMB_END_CNTL1_R);\n\t\tgam_regs.start_end_cntl2_r = REG(CM_GAMCOR_RAMB_END_CNTL2_R);\n\t\tgam_regs.region_start = REG(CM_GAMCOR_RAMB_REGION_0_1);\n\t\tgam_regs.region_end = REG(CM_GAMCOR_RAMB_REGION_32_33);\n\t\t\n\t\tgam_regs.offset_b =  REG(CM_GAMCOR_RAMB_OFFSET_B);\n\t\tgam_regs.offset_g =  REG(CM_GAMCOR_RAMB_OFFSET_G);\n\t\tgam_regs.offset_r =  REG(CM_GAMCOR_RAMB_OFFSET_R);\n\t\tgam_regs.start_base_cntl_b = REG(CM_GAMCOR_RAMB_START_BASE_CNTL_B);\n\t\tgam_regs.start_base_cntl_g = REG(CM_GAMCOR_RAMB_START_BASE_CNTL_G);\n\t\tgam_regs.start_base_cntl_r = REG(CM_GAMCOR_RAMB_START_BASE_CNTL_R);\n\t} else {\n\t\tgam_regs.start_cntl_b = REG(CM_GAMCOR_RAMA_START_CNTL_B);\n\t\tgam_regs.start_cntl_g = REG(CM_GAMCOR_RAMA_START_CNTL_G);\n\t\tgam_regs.start_cntl_r = REG(CM_GAMCOR_RAMA_START_CNTL_R);\n\t\tgam_regs.start_slope_cntl_b = REG(CM_GAMCOR_RAMA_START_SLOPE_CNTL_B);\n\t\tgam_regs.start_slope_cntl_g = REG(CM_GAMCOR_RAMA_START_SLOPE_CNTL_G);\n\t\tgam_regs.start_slope_cntl_r = REG(CM_GAMCOR_RAMA_START_SLOPE_CNTL_R);\n\t\tgam_regs.start_end_cntl1_b = REG(CM_GAMCOR_RAMA_END_CNTL1_B);\n\t\tgam_regs.start_end_cntl2_b = REG(CM_GAMCOR_RAMA_END_CNTL2_B);\n\t\tgam_regs.start_end_cntl1_g = REG(CM_GAMCOR_RAMA_END_CNTL1_G);\n\t\tgam_regs.start_end_cntl2_g = REG(CM_GAMCOR_RAMA_END_CNTL2_G);\n\t\tgam_regs.start_end_cntl1_r = REG(CM_GAMCOR_RAMA_END_CNTL1_R);\n\t\tgam_regs.start_end_cntl2_r = REG(CM_GAMCOR_RAMA_END_CNTL2_R);\n\t\tgam_regs.region_start = REG(CM_GAMCOR_RAMA_REGION_0_1);\n\t\tgam_regs.region_end = REG(CM_GAMCOR_RAMA_REGION_32_33);\n\t\t\n\t\tgam_regs.offset_b =  REG(CM_GAMCOR_RAMA_OFFSET_B);\n\t\tgam_regs.offset_g =  REG(CM_GAMCOR_RAMA_OFFSET_G);\n\t\tgam_regs.offset_r =  REG(CM_GAMCOR_RAMA_OFFSET_R);\n\t\tgam_regs.start_base_cntl_b = REG(CM_GAMCOR_RAMA_START_BASE_CNTL_B);\n\t\tgam_regs.start_base_cntl_g = REG(CM_GAMCOR_RAMA_START_BASE_CNTL_G);\n\t\tgam_regs.start_base_cntl_r = REG(CM_GAMCOR_RAMA_START_BASE_CNTL_R);\n\t}\n\n\t\n\tdpp3_gamcor_reg_field(dpp, &gam_regs);\n\n\t\n\tcm_helper_program_gamcor_xfer_func(dpp_base->ctx, params, &gam_regs);\n\n\tdpp3_program_gammcor_lut(dpp_base, params->rgb_resulted, params->hw_points_num,\n\t\t\t\t next_mode == LUT_RAM_A);\n\n\t\n\tREG_UPDATE(CM_GAMCOR_CONTROL, CM_GAMCOR_SELECT, next_mode == LUT_RAM_A ? 0:1);\n\n\treturn true;\n}\n\nvoid dpp3_set_hdr_multiplier(\n\t\tstruct dpp *dpp_base,\n\t\tuint32_t multiplier)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\n\tREG_UPDATE(CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, multiplier);\n}\n\n\nstatic void program_gamut_remap(\n\t\tstruct dcn3_dpp *dpp,\n\t\tconst uint16_t *regval,\n\t\tint select)\n{\n\tuint16_t selection = 0;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (regval == NULL || select == GAMUT_REMAP_BYPASS) {\n\t\tREG_SET(CM_GAMUT_REMAP_CONTROL, 0,\n\t\t\t\tCM_GAMUT_REMAP_MODE, 0);\n\t\treturn;\n\t}\n\tswitch (select) {\n\tcase GAMUT_REMAP_COEFF:\n\t\tselection = 1;\n\t\tbreak;\n\t\t \n\tcase GAMUT_REMAP_COMA_COEFF:\n\t\tselection = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_GAMUT_REMAP_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_GAMUT_REMAP_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_GAMUT_REMAP_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_GAMUT_REMAP_C12;\n\n\n\tif (select == GAMUT_REMAP_COEFF) {\n\t\tgam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\n\t} else  if (select == GAMUT_REMAP_COMA_COEFF) {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_B_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_B_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\n\t}\n\t\n\tREG_SET(\n\t\t\tCM_GAMUT_REMAP_CONTROL, 0,\n\t\t\tCM_GAMUT_REMAP_MODE, selection);\n}\n\nvoid dpp3_cm_set_gamut_remap(\n\tstruct dpp *dpp_base,\n\tconst struct dpp_grph_csc_adjustment *adjust)\n{\n\tstruct dcn3_dpp *dpp = TO_DCN30_DPP(dpp_base);\n\tint i = 0;\n\tint gamut_mode;\n\n\tif (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)\n\t\t \n\t\tprogram_gamut_remap(dpp, NULL, GAMUT_REMAP_BYPASS);\n\telse {\n\t\tstruct fixed31_32 arr_matrix[12];\n\t\tuint16_t arr_reg_val[12];\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tarr_matrix[i] = adjust->temperature_matrix[i];\n\n\t\tconvert_float_matrix(\n\t\t\tarr_reg_val, arr_matrix, 12);\n\n\t\t\n\t\tREG_GET(CM_GAMUT_REMAP_CONTROL, CM_GAMUT_REMAP_MODE_CURRENT, &gamut_mode);\n\n\t\tif (gamut_mode == 0)\n\t\t\tgamut_mode = 1; \n\t\telse if (gamut_mode == 1)\n\t\t\tgamut_mode = 2;\n\t\telse\n\t\t\tgamut_mode = 1;\n\n\t\t\n\t\tprogram_gamut_remap(dpp, arr_reg_val, gamut_mode);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}