{
  "module_name": "display_mode_vba_21.c",
  "hash_id": "1d00a83201590d60a46443ffe85f2b413ee144b002cc493a3b1670bf0bdf01fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dml/dcn21/display_mode_vba_21.c",
  "human_readable_source": " \n\n\n#include \"../display_mode_lib.h\"\n#include \"../dml_inline_defs.h\"\n#include \"../display_mode_vba.h\"\n#include \"display_mode_vba_21.h\"\n\n\n \ntypedef struct {\n\tdouble DPPCLK;\n\tdouble DISPCLK;\n\tdouble PixelClock;\n\tdouble DCFCLKDeepSleep;\n\tunsigned int DPPPerPlane;\n\tbool ScalerEnabled;\n\tenum scan_direction_class SourceScan;\n\tunsigned int BlockWidth256BytesY;\n\tunsigned int BlockHeight256BytesY;\n\tunsigned int BlockWidth256BytesC;\n\tunsigned int BlockHeight256BytesC;\n\tunsigned int InterlaceEnable;\n\tunsigned int NumberOfCursors;\n\tunsigned int VBlank;\n\tunsigned int HTotal;\n} Pipe;\n\ntypedef struct {\n\tbool Enable;\n\tunsigned int MaxPageTableLevels;\n\tunsigned int CachedPageTableLevels;\n} HostVM;\n\n#define BPP_INVALID 0\n#define BPP_BLENDED_PIPE 0xffffffff\n#define DCN21_MAX_DSC_IMAGE_WIDTH 5184\n#define DCN21_MAX_420_IMAGE_WIDTH 4096\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib);\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(\n\t\tstruct display_mode_lib *mode_lib);\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble bpp,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat);\nstatic unsigned int dscComputeDelay(enum output_format_class pixelFormat);\n \nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotal,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCFormater,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int ScalerRecoutWidth,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tHostVM *myHostVM,\n\t\tbool DynamicMetadataEnable,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tbool DCCEnable,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tdouble BytePerPixelDETC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tbool XFCEnabled,\n\t\tdouble XFCRemoteSurfaceFlipDelay,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tunsigned int *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tunsigned int *swath_width_luma_ub,\n\t\tunsigned int *swath_width_chroma_ub,\n\t\tunsigned int *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix);\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed);\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed);\nstatic double CalculateDCCConfiguration(\n\t\tbool                 DCCEnabled,\n\t\tbool                 DCCProgrammingAssumesScanDirectionUnknown,\n\t\tunsigned int         ViewportWidth,\n\t\tunsigned int         ViewportHeight,\n\t\tunsigned int         DETBufferSize,\n\t\tunsigned int         RequestHeight256Byte,\n\t\tunsigned int         SwathHeight,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int         BytePerPixel,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int        *MaxUncompressedBlock,\n\t\tunsigned int        *MaxCompressedBlock,\n\t\tunsigned int        *Independent64ByteBlock);\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath);\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int ViewportWidth,\n\t\tunsigned int ViewportHeight,\n\t\tunsigned int SwathWidthY,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxPageTableLevels,\n\t\tunsigned int HostVMCachedPageTableLevels,\n\t\tunsigned int VMMPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tunsigned int *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tunsigned int *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tunsigned int *DPDE0BytesFrame,\n\t\tunsigned int *MetaPTEBytesFrame);\n\nstatic double CalculateTWait(\n\t\tunsigned int PrefetchMode,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble SREnterPlusExitTime);\nstatic double CalculateRemoteSurfaceFlipDelay(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble SwathWidth,\n\t\tdouble Bpp,\n\t\tdouble LineTime,\n\t\tdouble XFCTSlvVupdateOffset,\n\t\tdouble XFCTSlvVupdateWidth,\n\t\tdouble XFCTSlvVreadyOffset,\n\t\tdouble XFCXBUFLatencyTolerance,\n\t\tdouble XFCFillBWOverhead,\n\t\tdouble XFCSlvChunkSize,\n\t\tdouble XFCBusTransportTime,\n\t\tdouble TCalc,\n\t\tdouble TWait,\n\t\tdouble *SrcActiveDrainRate,\n\t\tdouble *TInitXFill,\n\t\tdouble *TslvChk);\nstatic void CalculateActiveRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw);\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxPageTableLevels,\n\t\tunsigned int HostVMCachedPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow,\n\t\tdouble BandwidthAvailableForImmediateFlip,\n\t\tunsigned int TotImmediateFlipBytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble LineTime,\n\t\tdouble VRatio,\n\t\tdouble Tno_bw,\n\t\tbool DCCEnable,\n\t\tunsigned int dpte_row_height,\n\t\tunsigned int meta_row_height,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tdouble *DestinationLinesToRequestVMInImmediateFlip,\n\t\tdouble *DestinationLinesToRequestRowInImmediateFlip,\n\t\tdouble *final_flip_bw,\n\t\tbool *ImmediateFlipSupportedForPipe);\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackLumaHTaps,\n\t\tunsigned int WritebackLumaVTaps,\n\t\tunsigned int WritebackChromaHTaps,\n\t\tunsigned int WritebackChromaVTaps,\n\t\tunsigned int WritebackDestinationWidth);\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tunsigned int MaxLineBufferLines,\n\t\tunsigned int LineBufferSize,\n\t\tunsigned int DPPOutputBufferPixels,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int WritebackInterfaceLumaBufferSize,\n\t\tunsigned int WritebackInterfaceChromaBufferSize,\n\t\tdouble DCFCLK,\n\t\tdouble UrgentOutOfOrderReturn,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tint dpte_group_bytes[],\n\t\tunsigned int MetaChunkSize,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble WritebackLatency,\n\t\tdouble WritebackChunkSize,\n\t\tdouble SOCCLK,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble SRExitTime,\n\t\tdouble SREnterPlusExitTime,\n\t\tdouble DCFCLKDeepSleep,\n\t\tint DPPPerPlane[],\n\t\tbool DCCEnable[],\n\t\tdouble DPPCLK[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tunsigned int SwathHeightY[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tunsigned int SwathHeightC[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tunsigned int LBBitPerPixel[],\n\t\tdouble SwathWidthY[],\n\t\tdouble HRatio[],\n\t\tunsigned int vtaps[],\n\t\tunsigned int VTAPsChroma[],\n\t\tdouble VRatio[],\n\t\tunsigned int HTotal[],\n\t\tdouble PixelClock[],\n\t\tunsigned int BlendingAndTiming[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tbool WritebackEnable[],\n\t\tenum source_format_class WritebackPixelFormat[],\n\t\tdouble WritebackDestinationWidth[],\n\t\tdouble WritebackDestinationHeight[],\n\t\tdouble WritebackSourceHeight[],\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *UrgentWatermark,\n\t\tdouble *WritebackUrgentWatermark,\n\t\tdouble *DRAMClockChangeWatermark,\n\t\tdouble *WritebackDRAMClockChangeWatermark,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *MinActiveDRAMClockChangeLatencySupported);\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tdouble VRatio[],\n\t\tdouble SwathWidthY[],\n\t\tint DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble *DCFCLKDeepSleep);\nstatic void CalculateDETBufferSize(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tunsigned int *DETBufferSizeY,\n\t\tunsigned int *DETBufferSizeC);\nstatic void CalculateUrgentBurstFactor(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tunsigned int SwathWidthY,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioPreY,\n\t\tdouble VRatioPreC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorCursorPre,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorLumaPre,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tdouble *UrgentBurstFactorChromaPre,\n\t\tunsigned int *NotEnoughUrgentLatencyHiding,\n\t\tunsigned int *NotEnoughUrgentLatencyHidingPre);\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int           NumberOfActivePlanes,\n\t\tdouble                 VRatio[],\n\t\tdouble                 VRatioPrefetchY[],\n\t\tdouble                 VRatioPrefetchC[],\n\t\tunsigned int           swath_width_luma_ub[],\n\t\tunsigned int           swath_width_chroma_ub[],\n\t\tint                    DPPPerPlane[],\n\t\tdouble                 HRatio[],\n\t\tdouble                 PixelClock[],\n\t\tdouble                 PSCL_THROUGHPUT[],\n\t\tdouble                 PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble                 DPPCLK[],\n\t\tdouble                 BytePerPixelDETC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int           BlockWidth256BytesY[],\n\t\tunsigned int           BlockHeight256BytesY[],\n\t\tunsigned int           BlockWidth256BytesC[],\n\t\tunsigned int           BlockHeight256BytesC[],\n\t\tdouble                 DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble                 DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble                 DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble                 DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble                 DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble                 DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble                 DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble                 DisplayPipeRequestDeliveryTimeChromaPrefetch[]);\n\nstatic void CalculateMetaAndPTETimes(\n\t\tunsigned int           NumberOfActivePlanes,\n\t\tbool                   GPUVMEnable,\n\t\tunsigned int           MetaChunkSize,\n\t\tunsigned int           MinMetaChunkSizeBytes,\n\t\tunsigned int           GPUVMMaxPageTableLevels,\n\t\tunsigned int           HTotal[],\n\t\tdouble                 VRatio[],\n\t\tdouble                 VRatioPrefetchY[],\n\t\tdouble                 VRatioPrefetchC[],\n\t\tdouble                 DestinationLinesToRequestRowInVBlank[],\n\t\tdouble                 DestinationLinesToRequestRowInImmediateFlip[],\n\t\tdouble                 DestinationLinesToRequestVMInVBlank[],\n\t\tdouble                 DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool                   DCCEnable[],\n\t\tdouble                 PixelClock[],\n\t\tdouble                 BytePerPixelDETY[],\n\t\tdouble                 BytePerPixelDETC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int           dpte_row_height[],\n\t\tunsigned int           dpte_row_height_chroma[],\n\t\tunsigned int           meta_row_width[],\n\t\tunsigned int           meta_row_height[],\n\t\tunsigned int           meta_req_width[],\n\t\tunsigned int           meta_req_height[],\n\t\tint                   dpte_group_bytes[],\n\t\tunsigned int           PTERequestSizeY[],\n\t\tunsigned int           PTERequestSizeC[],\n\t\tunsigned int           PixelPTEReqWidthY[],\n\t\tunsigned int           PixelPTEReqHeightY[],\n\t\tunsigned int           PixelPTEReqWidthC[],\n\t\tunsigned int           PixelPTEReqHeightC[],\n\t\tunsigned int           dpte_row_width_luma_ub[],\n\t\tunsigned int           dpte_row_width_chroma_ub[],\n\t\tunsigned int           vm_group_bytes[],\n\t\tunsigned int           dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int           dpde0_bytes_per_frame_ub_c[],\n\t\tunsigned int           meta_pte_bytes_per_frame_ub_l[],\n\t\tunsigned int           meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble                 DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble                 DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble                 DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble                 TimePerMetaChunkNominal[],\n\t\tdouble                 TimePerMetaChunkVBlank[],\n\t\tdouble                 TimePerMetaChunkFlip[],\n\t\tdouble                 time_per_pte_group_nom_luma[],\n\t\tdouble                 time_per_pte_group_vblank_luma[],\n\t\tdouble                 time_per_pte_group_flip_luma[],\n\t\tdouble                 time_per_pte_group_nom_chroma[],\n\t\tdouble                 time_per_pte_group_vblank_chroma[],\n\t\tdouble                 time_per_pte_group_flip_chroma[],\n\t\tdouble                 TimePerVMGroupVBlank[],\n\t\tdouble                 TimePerVMGroupFlip[],\n\t\tdouble                 TimePerVMRequestVBlank[],\n\t\tdouble                 TimePerVMRequestFlip[]);\n\nstatic double CalculateExtraLatency(\n\t\tdouble UrgentRoundTripAndOutOfOrderLatency,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tint HostVMMaxPageTableLevels,\n\t\tint HostVMCachedPageTableLevels);\n\nvoid dml21_recalculate(struct display_mode_lib *mode_lib)\n{\n\tModeSupportAndSystemConfiguration(mode_lib);\n\tPixelClockAdjustmentForProgressiveToInterlaceUnit(mode_lib);\n\tDisplayPipeConfiguration(mode_lib);\n\tDISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(mode_lib);\n}\n\nstatic unsigned int dscceComputeDelay(\n\t\tunsigned int bpc,\n\t\tdouble bpp,\n\t\tunsigned int sliceWidth,\n\t\tunsigned int numSlices,\n\t\tenum output_format_class pixelFormat)\n{\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\t \n\tunsigned int rcModelSize = 8192;\n\n\t \n\tunsigned int pixelsPerClock, lstall, D, initalXmitDelay, w, S, ix, wx, p, l0, a, ax, l,\n\t\t\tDelay, pixels;\n\n\tif (pixelFormat == dm_n422 || pixelFormat == dm_420)\n\t\tpixelsPerClock = 2;\n\t \n\telse\n\t\tpixelsPerClock = 1;\n\n\t \n\tinitalXmitDelay = dml_round(rcModelSize / 2.0 / bpp / pixelsPerClock);\n\n\t \n\tif (bpc == 8)\n\t\tD = 81;\n\telse if (bpc == 10)\n\t\tD = 89;\n\telse\n\t\tD = 113;\n\n\t \n\tw = sliceWidth / pixelsPerClock;\n\n\t \n\tif (pixelFormat == dm_s422)\n\t\tS = 1;\n\telse\n\t\tS = 0;\n\n\t \n\tix = initalXmitDelay + 45;\n\twx = (w + 2) / 3;\n\tp = 3 * wx - w;\n\tl0 = ix / w;\n\ta = ix + p * l0;\n\tax = (a + 2) / 3 + D + 6 + 1;\n\tl = (ax + wx - 1) / wx;\n\tif ((ix % w) == 0 && p != 0)\n\t\tlstall = 1;\n\telse\n\t\tlstall = 0;\n\tDelay = l * wx * (numSlices - 1) + ax + S + lstall + 22;\n\n\t \n\tpixels = Delay * 3 * pixelsPerClock;\n\treturn pixels;\n}\n\nstatic unsigned int dscComputeDelay(enum output_format_class pixelFormat)\n{\n\tunsigned int Delay = 0;\n\n\tif (pixelFormat == dm_420) {\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 0;\n\t\t \n\t\tDelay = Delay + 3;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 12;\n\t\t \n\t\tDelay = Delay + 13;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 7;\n\t\t \n\t\tDelay = Delay + 3;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 1;\n\t\t \n\t\tDelay = Delay + 1;\n\t} else if (pixelFormat == dm_n422) {\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 1;\n\t\t \n\t\tDelay = Delay + 5;\n\t\t \n\t\tDelay = Delay + 25;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 10;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 1;\n\t\t \n\t\tDelay = Delay + 1;\n\t} else {\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 0;\n\t\t \n\t\tDelay = Delay + 3;\n\t\t \n\t\tDelay = Delay + 12;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 7;\n\t\t \n\t\tDelay = Delay + 1;\n\t\t \n\t\tDelay = Delay + 2;\n\t\t \n\t\tDelay = Delay + 1;\n\t}\n\n\treturn Delay;\n}\n\nstatic bool CalculatePrefetchSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tPipe *myPipe,\n\t\tunsigned int DSCDelay,\n\t\tdouble DPPCLKDelaySubtotal,\n\t\tdouble DPPCLKDelaySCL,\n\t\tdouble DPPCLKDelaySCLLBOnly,\n\t\tdouble DPPCLKDelayCNVCFormater,\n\t\tdouble DPPCLKDelayCNVCCursor,\n\t\tdouble DISPCLKDelaySubtotal,\n\t\tunsigned int ScalerRecoutWidth,\n\t\tenum output_format_class OutputFormat,\n\t\tunsigned int MaxInterDCNTileRepeaters,\n\t\tunsigned int VStartup,\n\t\tunsigned int MaxVStartup,\n\t\tunsigned int GPUVMPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tHostVM *myHostVM,\n\t\tbool DynamicMetadataEnable,\n\t\tint DynamicMetadataLinesBeforeActiveRequired,\n\t\tunsigned int DynamicMetadataTransmittedBytes,\n\t\tbool DCCEnable,\n\t\tdouble UrgentLatency,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble TCalc,\n\t\tunsigned int PDEAndMetaPTEBytesFrame,\n\t\tunsigned int MetaRowByte,\n\t\tunsigned int PixelPTEBytesPerRow,\n\t\tdouble PrefetchSourceLinesY,\n\t\tunsigned int SwathWidthY,\n\t\tdouble BytePerPixelDETY,\n\t\tdouble VInitPreFillY,\n\t\tunsigned int MaxNumSwathY,\n\t\tdouble PrefetchSourceLinesC,\n\t\tdouble BytePerPixelDETC,\n\t\tdouble VInitPreFillC,\n\t\tunsigned int MaxNumSwathC,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tdouble TWait,\n\t\tbool XFCEnabled,\n\t\tdouble XFCRemoteSurfaceFlipDelay,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tdouble *DSTXAfterScaler,\n\t\tdouble *DSTYAfterScaler,\n\t\tdouble *DestinationLinesForPrefetch,\n\t\tdouble *PrefetchBandwidth,\n\t\tdouble *DestinationLinesToRequestVMInVBlank,\n\t\tdouble *DestinationLinesToRequestRowInVBlank,\n\t\tdouble *VRatioPrefetchY,\n\t\tdouble *VRatioPrefetchC,\n\t\tdouble *RequiredPrefetchPixDataBWLuma,\n\t\tdouble *RequiredPrefetchPixDataBWChroma,\n\t\tunsigned int *VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,\n\t\tdouble *Tno_bw,\n\t\tdouble *prefetch_vmrow_bw,\n\t\tunsigned int *swath_width_luma_ub,\n\t\tunsigned int *swath_width_chroma_ub,\n\t\tunsigned int *VUpdateOffsetPix,\n\t\tdouble *VUpdateWidthPix,\n\t\tdouble *VReadyOffsetPix)\n{\n\tbool MyError = false;\n\tunsigned int DPPCycles, DISPCLKCycles;\n\tdouble DSTTotalPixelsAfterScaler, TotalRepeaterDelayTime;\n\tdouble Tdm, LineTime, Tsetup;\n\tdouble dst_y_prefetch_equ;\n\tdouble Tsw_oto;\n\tdouble prefetch_bw_oto;\n\tdouble Tvm_oto;\n\tdouble Tr0_oto;\n\tdouble Tvm_oto_lines;\n\tdouble Tr0_oto_lines;\n\tdouble Tsw_oto_lines;\n\tdouble dst_y_prefetch_oto;\n\tdouble TimeForFetchingMetaPTE = 0;\n\tdouble TimeForFetchingRowInVBlank = 0;\n\tdouble LinesToRequestPrefetchPixelData = 0;\n\tdouble HostVMInefficiencyFactor;\n\tunsigned int HostVMDynamicLevels;\n\n\tif (GPUVMEnable == true && myHostVM->Enable == true) {\n\t\tHostVMInefficiencyFactor =\n\t\t\t\tPercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData\n\t\t\t\t\t\t/ PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tHostVMDynamicLevels = myHostVM->MaxPageTableLevels\n\t\t\t\t- myHostVM->CachedPageTableLevels;\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tif (myPipe->ScalerEnabled)\n\t\tDPPCycles = DPPCLKDelaySubtotal + DPPCLKDelaySCL;\n\telse\n\t\tDPPCycles = DPPCLKDelaySubtotal + DPPCLKDelaySCLLBOnly;\n\n\tDPPCycles = DPPCycles + DPPCLKDelayCNVCFormater + myPipe->NumberOfCursors * DPPCLKDelayCNVCCursor;\n\n\tDISPCLKCycles = DISPCLKDelaySubtotal;\n\n\tif (myPipe->DPPCLK == 0.0 || myPipe->DISPCLK == 0.0)\n\t\treturn true;\n\n\t*DSTXAfterScaler = DPPCycles * myPipe->PixelClock / myPipe->DPPCLK\n\t\t\t+ DISPCLKCycles * myPipe->PixelClock / myPipe->DISPCLK + DSCDelay;\n\n\tif (myPipe->DPPPerPlane > 1)\n\t\t*DSTXAfterScaler = *DSTXAfterScaler + ScalerRecoutWidth;\n\n\tif (OutputFormat == dm_420 || (myPipe->InterlaceEnable && ProgressiveToInterlaceUnitInOPP))\n\t\t*DSTYAfterScaler = 1;\n\telse\n\t\t*DSTYAfterScaler = 0;\n\n\tDSTTotalPixelsAfterScaler = ((double) (*DSTYAfterScaler * myPipe->HTotal)) + *DSTXAfterScaler;\n\t*DSTYAfterScaler = dml_floor(DSTTotalPixelsAfterScaler / myPipe->HTotal, 1);\n\t*DSTXAfterScaler = DSTTotalPixelsAfterScaler - ((double) (*DSTYAfterScaler * myPipe->HTotal));\n\n\t*VUpdateOffsetPix = dml_ceil(myPipe->HTotal / 4.0, 1);\n\tTotalRepeaterDelayTime = MaxInterDCNTileRepeaters * (2.0 / myPipe->DPPCLK + 3.0 / myPipe->DISPCLK);\n\t*VUpdateWidthPix = (14.0 / myPipe->DCFCLKDeepSleep + 12.0 / myPipe->DPPCLK + TotalRepeaterDelayTime)\n\t\t\t* myPipe->PixelClock;\n\n\t*VReadyOffsetPix = dml_max(\n\t\t\t150.0 / myPipe->DPPCLK,\n\t\t\tTotalRepeaterDelayTime + 20.0 / myPipe->DCFCLKDeepSleep + 10.0 / myPipe->DPPCLK)\n\t\t\t* myPipe->PixelClock;\n\n\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock;\n\n\tLineTime = (double) myPipe->HTotal / myPipe->PixelClock;\n\n\tif (DynamicMetadataEnable) {\n\t\tdouble Tdmbf, Tdmec, Tdmsks;\n\n\t\tTdm = dml_max(0.0, UrgentExtraLatency - TCalc);\n\t\tTdmbf = DynamicMetadataTransmittedBytes / 4.0 / myPipe->DISPCLK;\n\t\tTdmec = LineTime;\n\t\tif (DynamicMetadataLinesBeforeActiveRequired == -1)\n\t\t\tTdmsks = myPipe->VBlank * LineTime / 2.0;\n\t\telse\n\t\t\tTdmsks = DynamicMetadataLinesBeforeActiveRequired * LineTime;\n\t\tif (myPipe->InterlaceEnable && !ProgressiveToInterlaceUnitInOPP)\n\t\t\tTdmsks = Tdmsks / 2;\n\t\tif (VStartup * LineTime\n\t\t\t\t< Tsetup + TWait + UrgentExtraLatency + Tdmbf + Tdmec + Tdmsks) {\n\t\t\tMyError = true;\n\t\t\t*VStartupRequiredWhenNotEnoughTimeForDynamicMetadata = (Tsetup + TWait\n\t\t\t\t\t+ UrgentExtraLatency + Tdmbf + Tdmec + Tdmsks) / LineTime;\n\t\t} else\n\t\t\t*VStartupRequiredWhenNotEnoughTimeForDynamicMetadata = 0.0;\n\t} else\n\t\tTdm = 0;\n\n\tif (GPUVMEnable) {\n\t\tif (GPUVMPageTableLevels >= 3)\n\t\t\t*Tno_bw = UrgentExtraLatency + UrgentLatency * ((GPUVMPageTableLevels - 2) * (myHostVM->MaxPageTableLevels + 1) - 1);\n\t\telse\n\t\t\t*Tno_bw = 0;\n\t} else if (!DCCEnable)\n\t\t*Tno_bw = LineTime;\n\telse\n\t\t*Tno_bw = LineTime / 4;\n\n\tdst_y_prefetch_equ = VStartup - dml_max(TCalc + TWait, XFCRemoteSurfaceFlipDelay) / LineTime\n\t\t\t- (Tsetup + Tdm) / LineTime\n\t\t\t- (*DSTYAfterScaler + *DSTXAfterScaler / myPipe->HTotal);\n\n\tTsw_oto = dml_max(PrefetchSourceLinesY, PrefetchSourceLinesC) * LineTime;\n\n\tif (myPipe->SourceScan == dm_horz) {\n\t\t*swath_width_luma_ub = dml_ceil(SwathWidthY - 1, myPipe->BlockWidth256BytesY) + myPipe->BlockWidth256BytesY;\n\t\tif (myPipe->BlockWidth256BytesC > 0)\n\t\t\t*swath_width_chroma_ub = dml_ceil(SwathWidthY / 2 - 1, myPipe->BlockWidth256BytesC) + myPipe->BlockWidth256BytesC;\n\t} else {\n\t\t*swath_width_luma_ub = dml_ceil(SwathWidthY - 1, myPipe->BlockHeight256BytesY) + myPipe->BlockHeight256BytesY;\n\t\tif (myPipe->BlockHeight256BytesC > 0)\n\t\t\t*swath_width_chroma_ub = dml_ceil(SwathWidthY / 2 - 1, myPipe->BlockHeight256BytesC) + myPipe->BlockHeight256BytesC;\n\t}\n\n\tprefetch_bw_oto = (PrefetchSourceLinesY * *swath_width_luma_ub * dml_ceil(BytePerPixelDETY, 1) + PrefetchSourceLinesC * *swath_width_chroma_ub * dml_ceil(BytePerPixelDETC, 2)) / Tsw_oto;\n\n\n\tif (GPUVMEnable == true) {\n\t\tTvm_oto = dml_max(*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / prefetch_bw_oto,\n\t\t\t\tdml_max(UrgentExtraLatency + UrgentLatency * (GPUVMPageTableLevels * (HostVMDynamicLevels + 1) - 1),\n\t\t\t\t\tLineTime / 4.0));\n\t} else\n\t\tTvm_oto = LineTime / 4.0;\n\n\tif ((GPUVMEnable == true || DCCEnable == true)) {\n\t\tTr0_oto = dml_max(\n\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / prefetch_bw_oto,\n\t\t\t\tdml_max(UrgentLatency * (HostVMDynamicLevels + 1), dml_max(LineTime - Tvm_oto, LineTime / 4)));\n\t} else\n\t\tTr0_oto = (LineTime - Tvm_oto) / 2.0;\n\n\tTvm_oto_lines = dml_ceil(4 * Tvm_oto / LineTime, 1) / 4.0;\n\tTr0_oto_lines = dml_ceil(4 * Tr0_oto / LineTime, 1) / 4.0;\n\tTsw_oto_lines = dml_ceil(4 * Tsw_oto / LineTime, 1) / 4.0;\n\tdst_y_prefetch_oto = Tvm_oto_lines + 2 * Tr0_oto_lines + Tsw_oto_lines + 0.75;\n\n\tdst_y_prefetch_equ = dml_floor(4.0 * (dst_y_prefetch_equ + 0.125), 1) / 4.0;\n\n\tif (dst_y_prefetch_oto < dst_y_prefetch_equ)\n\t\t*DestinationLinesForPrefetch = dst_y_prefetch_oto;\n\telse\n\t\t*DestinationLinesForPrefetch = dst_y_prefetch_equ;\n\n\t \n\t*DestinationLinesForPrefetch = dml_min(*DestinationLinesForPrefetch, 63.75);\n\n\tdml_print(\"DML: VStartup: %d\\n\", VStartup);\n\tdml_print(\"DML: TCalc: %f\\n\", TCalc);\n\tdml_print(\"DML: TWait: %f\\n\", TWait);\n\tdml_print(\"DML: XFCRemoteSurfaceFlipDelay: %f\\n\", XFCRemoteSurfaceFlipDelay);\n\tdml_print(\"DML: LineTime: %f\\n\", LineTime);\n\tdml_print(\"DML: Tsetup: %f\\n\", Tsetup);\n\tdml_print(\"DML: Tdm: %f\\n\", Tdm);\n\tdml_print(\"DML: DSTYAfterScaler: %f\\n\", *DSTYAfterScaler);\n\tdml_print(\"DML: DSTXAfterScaler: %f\\n\", *DSTXAfterScaler);\n\tdml_print(\"DML: HTotal: %d\\n\", myPipe->HTotal);\n\n\t*PrefetchBandwidth = 0;\n\t*DestinationLinesToRequestVMInVBlank = 0;\n\t*DestinationLinesToRequestRowInVBlank = 0;\n\t*VRatioPrefetchY = 0;\n\t*VRatioPrefetchC = 0;\n\t*RequiredPrefetchPixDataBWLuma = 0;\n\tif (*DestinationLinesForPrefetch > 1) {\n\t\tdouble PrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte\n\t\t\t\t+ 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor\n\t\t\t\t+ PrefetchSourceLinesY * *swath_width_luma_ub * dml_ceil(BytePerPixelDETY, 1)\n\t\t\t\t+ PrefetchSourceLinesC * *swath_width_chroma_ub * dml_ceil(BytePerPixelDETC, 2))\n\t\t\t\t/ (*DestinationLinesForPrefetch * LineTime - *Tno_bw);\n\n\t\tdouble PrefetchBandwidth2 = (PDEAndMetaPTEBytesFrame *\n\t\t\t\tHostVMInefficiencyFactor + PrefetchSourceLinesY *\n\t\t\t\t*swath_width_luma_ub * dml_ceil(BytePerPixelDETY, 1) +\n\t\t\t\tPrefetchSourceLinesC * *swath_width_chroma_ub *\n\t\t\t\tdml_ceil(BytePerPixelDETC, 2)) /\n\t\t\t\t(*DestinationLinesForPrefetch * LineTime - *Tno_bw - 2 *\n\t\t\t\tUrgentLatency * (1 + HostVMDynamicLevels));\n\n\t\tdouble PrefetchBandwidth3 = (2 * MetaRowByte + 2 * PixelPTEBytesPerRow\n\t\t\t\t* HostVMInefficiencyFactor + PrefetchSourceLinesY *\n\t\t\t\t*swath_width_luma_ub * dml_ceil(BytePerPixelDETY, 1) +\n\t\t\t\tPrefetchSourceLinesC * *swath_width_chroma_ub *\n\t\t\t\tdml_ceil(BytePerPixelDETC, 2)) /\n\t\t\t\t(*DestinationLinesForPrefetch * LineTime -\n\t\t\t\tUrgentExtraLatency - UrgentLatency * (GPUVMPageTableLevels\n\t\t\t\t* (HostVMDynamicLevels + 1) - 1));\n\n\t\tdouble PrefetchBandwidth4 = (PrefetchSourceLinesY * *swath_width_luma_ub *\n\t\t\t\tdml_ceil(BytePerPixelDETY, 1) + PrefetchSourceLinesC *\n\t\t\t\t*swath_width_chroma_ub * dml_ceil(BytePerPixelDETC, 2)) /\n\t\t\t\t(*DestinationLinesForPrefetch * LineTime -\n\t\t\t\tUrgentExtraLatency - UrgentLatency * (GPUVMPageTableLevels\n\t\t\t\t* (HostVMDynamicLevels + 1) - 1) - 2 * UrgentLatency *\n\t\t\t\t(1 + HostVMDynamicLevels));\n\n\t\tif (VStartup == MaxVStartup && (PrefetchBandwidth1 > 4 * prefetch_bw_oto) && (*DestinationLinesForPrefetch - dml_ceil(Tsw_oto_lines, 1) / 4.0 - 0.75) * LineTime - *Tno_bw > 0) {\n\t\t\tPrefetchBandwidth1 = (PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor + 2 * MetaRowByte + 2 * PixelPTEBytesPerRow * HostVMInefficiencyFactor) / ((*DestinationLinesForPrefetch - dml_ceil(Tsw_oto_lines, 1) / 4.0 - 0.75) * LineTime - *Tno_bw);\n\t\t}\n\t\tif (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth1 >= UrgentExtraLatency + UrgentLatency * (GPUVMPageTableLevels * (HostVMDynamicLevels + 1) - 1) && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth1 >= UrgentLatency * (1 + HostVMDynamicLevels)) {\n\t\t\t*PrefetchBandwidth = PrefetchBandwidth1;\n\t\t} else if (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth2 >= UrgentExtraLatency + UrgentLatency * (GPUVMPageTableLevels * (HostVMDynamicLevels + 1) - 1) && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth2 < UrgentLatency * (1 + HostVMDynamicLevels)) {\n\t\t\t*PrefetchBandwidth = PrefetchBandwidth2;\n\t\t} else if (*Tno_bw + PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / PrefetchBandwidth3 < UrgentExtraLatency + UrgentLatency * (GPUVMPageTableLevels * (HostVMDynamicLevels + 1) - 1) && (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / PrefetchBandwidth3 >= UrgentLatency * (1 + HostVMDynamicLevels)) {\n\t\t\t*PrefetchBandwidth = PrefetchBandwidth3;\n\t\t} else {\n\t\t\t*PrefetchBandwidth = PrefetchBandwidth4;\n\t\t}\n\n\t\tif (GPUVMEnable) {\n\t\t\tTimeForFetchingMetaPTE = dml_max(*Tno_bw + (double) PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / *PrefetchBandwidth,\n\t\t\t\t\tdml_max(UrgentExtraLatency + UrgentLatency * (GPUVMPageTableLevels * (HostVMDynamicLevels + 1) - 1), LineTime / 4));\n\t\t} else {\n \n \n \n\t\t\t\tTimeForFetchingMetaPTE = LineTime / 4;\n \n \n\t\t}\n\n\t\tif ((GPUVMEnable == true || DCCEnable == true)) {\n\t\t\tTimeForFetchingRowInVBlank =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t(MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor)\n\t\t\t\t\t\t\t\t\t/ *PrefetchBandwidth,\n\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\tUrgentLatency * (1 + HostVMDynamicLevels),\n\t\t\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\t\t\t(LineTime\n\t\t\t\t\t\t\t\t\t\t\t\t\t- TimeForFetchingMetaPTE) / 2.0,\n\t\t\t\t\t\t\t\t\t\t\tLineTime\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 4.0)));\n\t\t} else {\n \n \n\t\t\t\tTimeForFetchingRowInVBlank = (LineTime - TimeForFetchingMetaPTE) / 2.0;\n \n \n\t\t}\n\n\t\t*DestinationLinesToRequestVMInVBlank = dml_ceil(4.0 * TimeForFetchingMetaPTE / LineTime, 1.0) / 4.0;\n\n\t\t*DestinationLinesToRequestRowInVBlank = dml_ceil(4.0 * TimeForFetchingRowInVBlank / LineTime, 1.0) / 4.0;\n\n\t\tLinesToRequestPrefetchPixelData = *DestinationLinesForPrefetch\n \n \n\t\t\t\t\t\t- ((GPUVMEnable || DCCEnable) ?\n\t\t\t\t\t\t\t\t(*DestinationLinesToRequestVMInVBlank + 2 * *DestinationLinesToRequestRowInVBlank) :\n\t\t\t\t\t\t\t\t0.0);  \n\n\t\tif (LinesToRequestPrefetchPixelData > 0) {\n\n\t\t\t*VRatioPrefetchY = (double) PrefetchSourceLinesY\n\t\t\t\t\t/ LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\tif ((SwathHeightY > 4) && (VInitPreFillY > 3)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillY - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchY =\n\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\t(double) PrefetchSourceLinesY\n\t\t\t\t\t\t\t\t\t\t\t/ LinesToRequestPrefetchPixelData,\n\t\t\t\t\t\t\t\t\t(double) MaxNumSwathY\n\t\t\t\t\t\t\t\t\t\t\t* SwathHeightY\n\t\t\t\t\t\t\t\t\t\t\t/ (LinesToRequestPrefetchPixelData\n\t\t\t\t\t\t\t\t\t\t\t\t\t- (VInitPreFillY\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 3.0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0));\n\t\t\t\t\t*VRatioPrefetchY = dml_max(*VRatioPrefetchY, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\t*VRatioPrefetchY = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*VRatioPrefetchC = (double) PrefetchSourceLinesC\n\t\t\t\t\t/ LinesToRequestPrefetchPixelData;\n\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\n\t\t\tif ((SwathHeightC > 4)) {\n\t\t\t\tif (LinesToRequestPrefetchPixelData > (VInitPreFillC - 3.0) / 2.0) {\n\t\t\t\t\t*VRatioPrefetchC =\n\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\t*VRatioPrefetchC,\n\t\t\t\t\t\t\t\t\t(double) MaxNumSwathC\n\t\t\t\t\t\t\t\t\t\t\t* SwathHeightC\n\t\t\t\t\t\t\t\t\t\t\t/ (LinesToRequestPrefetchPixelData\n\t\t\t\t\t\t\t\t\t\t\t\t\t- (VInitPreFillC\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 3.0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0));\n\t\t\t\t\t*VRatioPrefetchC = dml_max(*VRatioPrefetchC, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tMyError = true;\n\t\t\t\t\t*VRatioPrefetchC = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*RequiredPrefetchPixDataBWLuma = myPipe->DPPPerPlane\n\t\t\t\t\t* (double) PrefetchSourceLinesY / LinesToRequestPrefetchPixelData\n\t\t\t\t\t* dml_ceil(BytePerPixelDETY, 1)\n\t\t\t\t\t* *swath_width_luma_ub / LineTime;\n\t\t\t*RequiredPrefetchPixDataBWChroma = myPipe->DPPPerPlane\n\t\t\t\t\t* (double) PrefetchSourceLinesC / LinesToRequestPrefetchPixelData\n\t\t\t\t\t* dml_ceil(BytePerPixelDETC, 2)\n\t\t\t\t\t* *swath_width_chroma_ub / LineTime;\n\t\t} else {\n\t\t\tMyError = true;\n\t\t\t*VRatioPrefetchY = 0;\n\t\t\t*VRatioPrefetchC = 0;\n\t\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t\t}\n\n\t\tdml_print(\"DML: Tvm: %fus\\n\", TimeForFetchingMetaPTE);\n\t\tdml_print(\"DML: Tr0: %fus\\n\", TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML: Tsw: %fus\\n\", (double)(*DestinationLinesForPrefetch) * LineTime - TimeForFetchingMetaPTE - TimeForFetchingRowInVBlank);\n\t\tdml_print(\"DML: Tpre: %fus\\n\", (double)(*DestinationLinesForPrefetch) * LineTime);\n\t\tdml_print(\"DML: row_bytes = dpte_row_bytes (per_pipe) = PixelPTEBytesPerRow = : %d\\n\", PixelPTEBytesPerRow);\n\n\t} else {\n\t\tMyError = true;\n\t}\n\n\t{\n\t\tdouble prefetch_vm_bw;\n\t\tdouble prefetch_row_bw;\n\n\t\tif (PDEAndMetaPTEBytesFrame == 0) {\n\t\t\tprefetch_vm_bw = 0;\n\t\t} else if (*DestinationLinesToRequestVMInVBlank > 0) {\n\t\t\tprefetch_vm_bw = PDEAndMetaPTEBytesFrame * HostVMInefficiencyFactor / (*DestinationLinesToRequestVMInVBlank * LineTime);\n\t\t} else {\n\t\t\tprefetch_vm_bw = 0;\n\t\t\tMyError = true;\n\t\t}\n\t\tif (MetaRowByte + PixelPTEBytesPerRow == 0) {\n\t\t\tprefetch_row_bw = 0;\n\t\t} else if (*DestinationLinesToRequestRowInVBlank > 0) {\n\t\t\tprefetch_row_bw = (MetaRowByte + PixelPTEBytesPerRow * HostVMInefficiencyFactor) / (*DestinationLinesToRequestRowInVBlank * LineTime);\n\t\t} else {\n\t\t\tprefetch_row_bw = 0;\n\t\t\tMyError = true;\n\t\t}\n\n\t\t*prefetch_vmrow_bw = dml_max(prefetch_vm_bw, prefetch_row_bw);\n\t}\n\n\tif (MyError) {\n\t\t*PrefetchBandwidth = 0;\n\t\tTimeForFetchingMetaPTE = 0;\n\t\tTimeForFetchingRowInVBlank = 0;\n\t\t*DestinationLinesToRequestVMInVBlank = 0;\n\t\t*DestinationLinesToRequestRowInVBlank = 0;\n\t\t*DestinationLinesForPrefetch = 0;\n\t\tLinesToRequestPrefetchPixelData = 0;\n\t\t*VRatioPrefetchY = 0;\n\t\t*VRatioPrefetchC = 0;\n\t\t*RequiredPrefetchPixDataBWLuma = 0;\n\t\t*RequiredPrefetchPixDataBWChroma = 0;\n\t}\n\n\treturn MyError;\n}\n\nstatic double RoundToDFSGranularityUp(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);\n}\n\nstatic double RoundToDFSGranularityDown(double Clock, double VCOSpeed)\n{\n\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);\n}\n\nstatic double CalculateDCCConfiguration(\n\t\tbool DCCEnabled,\n\t\tbool DCCProgrammingAssumesScanDirectionUnknown,\n\t\tunsigned int ViewportWidth,\n\t\tunsigned int ViewportHeight,\n\t\tunsigned int DETBufferSize,\n\t\tunsigned int RequestHeight256Byte,\n\t\tunsigned int SwathHeight,\n\t\tenum dm_swizzle_mode TilingFormat,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanOrientation,\n\t\tunsigned int *MaxUncompressedBlock,\n\t\tunsigned int *MaxCompressedBlock,\n\t\tunsigned int *Independent64ByteBlock)\n{\n\tdouble MaximumDCCCompressionSurface = 0.0;\n\tenum {\n\t\tREQ_256Bytes,\n\t\tREQ_128BytesNonContiguous,\n\t\tREQ_128BytesContiguous,\n\t\tREQ_NA\n\t} Request = REQ_NA;\n\n\tif (DCCEnabled == true) {\n\t\tif (DCCProgrammingAssumesScanDirectionUnknown == true) {\n\t\t\tif (DETBufferSize >= RequestHeight256Byte * ViewportWidth * BytePerPixel\n\t\t\t\t\t&& DETBufferSize\n\t\t\t\t\t\t\t>= 256 / RequestHeight256Byte\n\t\t\t\t\t\t\t\t\t* ViewportHeight) {\n\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t} else if ((DETBufferSize\n\t\t\t\t\t< RequestHeight256Byte * ViewportWidth * BytePerPixel\n\t\t\t\t\t&& (BytePerPixel == 2 || BytePerPixel == 4))\n\t\t\t\t\t|| (DETBufferSize\n\t\t\t\t\t\t\t< 256 / RequestHeight256Byte\n\t\t\t\t\t\t\t\t\t* ViewportHeight\n\t\t\t\t\t\t\t&& BytePerPixel == 8\n\t\t\t\t\t\t\t&& (TilingFormat == dm_sw_4kb_d\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_4kb_d_x\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_d\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_d_x\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_d\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_d_x\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_d_t\n\t\t\t\t\t\t\t\t\t|| TilingFormat\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_r_x))) {\n\t\t\t\tRequest = REQ_128BytesNonContiguous;\n\t\t\t} else {\n\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BytePerPixel == 1) {\n\t\t\t\tif (ScanOrientation == dm_vert || SwathHeight == 16) {\n\t\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t\t} else {\n\t\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t\t}\n\t\t\t} else if (BytePerPixel == 2) {\n\t\t\t\tif ((ScanOrientation == dm_vert && SwathHeight == 16) || (ScanOrientation != dm_vert && SwathHeight == 8)) {\n\t\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t\t} else if (ScanOrientation == dm_vert) {\n\t\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t\t} else {\n\t\t\t\t\tRequest = REQ_128BytesNonContiguous;\n\t\t\t\t}\n\t\t\t} else if (BytePerPixel == 4) {\n\t\t\t\tif (SwathHeight == 8) {\n\t\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t\t} else if (ScanOrientation == dm_vert) {\n\t\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t\t} else {\n\t\t\t\t\tRequest = REQ_128BytesNonContiguous;\n\t\t\t\t}\n\t\t\t} else if (BytePerPixel == 8) {\n\t\t\t\tif (TilingFormat == dm_sw_4kb_d || TilingFormat == dm_sw_4kb_d_x\n\t\t\t\t\t\t|| TilingFormat == dm_sw_var_d\n\t\t\t\t\t\t|| TilingFormat == dm_sw_var_d_x\n\t\t\t\t\t\t|| TilingFormat == dm_sw_64kb_d\n\t\t\t\t\t\t|| TilingFormat == dm_sw_64kb_d_x\n\t\t\t\t\t\t|| TilingFormat == dm_sw_64kb_d_t\n\t\t\t\t\t\t|| TilingFormat == dm_sw_64kb_r_x) {\n\t\t\t\t\tif ((ScanOrientation == dm_vert && SwathHeight == 8)\n\t\t\t\t\t\t\t|| (ScanOrientation != dm_vert\n\t\t\t\t\t\t\t\t\t&& SwathHeight == 4)) {\n\t\t\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t\t\t} else if (ScanOrientation != dm_vert) {\n\t\t\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRequest = REQ_128BytesNonContiguous;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ScanOrientation != dm_vert || SwathHeight == 8) {\n\t\t\t\t\t\tRequest = REQ_256Bytes;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRequest = REQ_128BytesContiguous;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tRequest = REQ_NA;\n\t}\n\n\tif (Request == REQ_256Bytes) {\n\t\t*MaxUncompressedBlock = 256;\n\t\t*MaxCompressedBlock = 256;\n\t\t*Independent64ByteBlock = false;\n\t\tMaximumDCCCompressionSurface = 4.0;\n\t} else if (Request == REQ_128BytesContiguous) {\n\t\t*MaxUncompressedBlock = 128;\n\t\t*MaxCompressedBlock = 128;\n\t\t*Independent64ByteBlock = false;\n\t\tMaximumDCCCompressionSurface = 2.0;\n\t} else if (Request == REQ_128BytesNonContiguous) {\n\t\t*MaxUncompressedBlock = 256;\n\t\t*MaxCompressedBlock = 64;\n\t\t*Independent64ByteBlock = true;\n\t\tMaximumDCCCompressionSurface = 4.0;\n\t} else {\n\t\t*MaxUncompressedBlock = 0;\n\t\t*MaxCompressedBlock = 0;\n\t\t*Independent64ByteBlock = 0;\n\t\tMaximumDCCCompressionSurface = 0.0;\n\t}\n\n\treturn MaximumDCCCompressionSurface;\n}\n\nstatic double CalculatePrefetchSourceLines(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble vtaps,\n\t\tbool Interlace,\n\t\tbool ProgressiveToInterlaceUnitInOPP,\n\t\tunsigned int SwathHeight,\n\t\tunsigned int ViewportYStart,\n\t\tdouble *VInitPreFill,\n\t\tunsigned int *MaxNumSwath)\n{\n\tunsigned int MaxPartialSwath;\n\n\tif (ProgressiveToInterlaceUnitInOPP)\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1) / 2.0, 1);\n\telse\n\t\t*VInitPreFill = dml_floor((VRatio + vtaps + 1 + Interlace * 0.5 * VRatio) / 2.0, 1);\n\n\tif (!mode_lib->vba.IgnoreViewportPositioning) {\n\n\t\t*MaxNumSwath = dml_ceil((*VInitPreFill - 1.0) / SwathHeight, 1) + 1.0;\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 2) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 2)\n\t\t\t\t\t% SwathHeight;\n\t\tMaxPartialSwath = dml_max(1U, MaxPartialSwath);\n\n\t} else {\n\n\t\tif (ViewportYStart != 0)\n\t\t\tdml_print(\n\t\t\t\t\t\"WARNING DML: using viewport y position of 0 even though actual viewport y position is non-zero in prefetch source lines calculation\\n\");\n\n\t\t*MaxNumSwath = dml_ceil(*VInitPreFill / SwathHeight, 1);\n\n\t\tif (*VInitPreFill > 1.0)\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill - 1) % SwathHeight;\n\t\telse\n\t\t\tMaxPartialSwath = (unsigned int) (*VInitPreFill + SwathHeight - 1)\n\t\t\t\t\t% SwathHeight;\n\t}\n\n\treturn *MaxNumSwath * SwathHeight + MaxPartialSwath;\n}\n\nstatic unsigned int CalculateVMAndRowBytes(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tbool DCCEnable,\n\t\tunsigned int BlockHeight256Bytes,\n\t\tunsigned int BlockWidth256Bytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tunsigned int SurfaceTiling,\n\t\tunsigned int BytePerPixel,\n\t\tenum scan_direction_class ScanDirection,\n\t\tunsigned int ViewportWidth,\n\t\tunsigned int ViewportHeight,\n\t\tunsigned int SwathWidth,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxPageTableLevels,\n\t\tunsigned int HostVMCachedPageTableLevels,\n\t\tunsigned int VMMPageSize,\n\t\tunsigned int PTEBufferSizeInRequests,\n\t\tunsigned int Pitch,\n\t\tunsigned int DCCMetaPitch,\n\t\tunsigned int *MacroTileWidth,\n\t\tunsigned int *MetaRowByte,\n\t\tunsigned int *PixelPTEBytesPerRow,\n\t\tbool *PTEBufferSizeNotExceeded,\n\t\tunsigned int *dpte_row_width_ub,\n\t\tunsigned int *dpte_row_height,\n\t\tunsigned int *MetaRequestWidth,\n\t\tunsigned int *MetaRequestHeight,\n\t\tunsigned int *meta_row_width,\n\t\tunsigned int *meta_row_height,\n\t\tunsigned int *vm_group_bytes,\n\t\tunsigned int *dpte_group_bytes,\n\t\tunsigned int *PixelPTEReqWidth,\n\t\tunsigned int *PixelPTEReqHeight,\n\t\tunsigned int *PTERequestSize,\n\t\tunsigned int *DPDE0BytesFrame,\n\t\tunsigned int *MetaPTEBytesFrame)\n{\n\tunsigned int MPDEBytesFrame;\n\tunsigned int DCCMetaSurfaceBytes;\n\tunsigned int MacroTileSizeBytes;\n\tunsigned int MacroTileHeight;\n\tunsigned int ExtraDPDEBytesFrame;\n\tunsigned int PDEAndMetaPTEBytesFrame;\n\tunsigned int PixelPTEReqHeightPTEs = 0;\n\n\tif (DCCEnable == true) {\n\t\t*MetaRequestHeight = 8 * BlockHeight256Bytes;\n\t\t*MetaRequestWidth = 8 * BlockWidth256Bytes;\n\t\tif (ScanDirection == dm_horz) {\n\t\t\t*meta_row_height = *MetaRequestHeight;\n\t\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestWidth)\n\t\t\t\t\t+ *MetaRequestWidth;\n\t\t\t*MetaRowByte = *meta_row_width * *MetaRequestHeight * BytePerPixel / 256.0;\n\t\t} else {\n\t\t\t*meta_row_height = *MetaRequestWidth;\n\t\t\t*meta_row_width = dml_ceil((double) SwathWidth - 1, *MetaRequestHeight)\n\t\t\t\t\t+ *MetaRequestHeight;\n\t\t\t*MetaRowByte = *meta_row_width * *MetaRequestWidth * BytePerPixel / 256.0;\n\t\t}\n\t\tif (ScanDirection == dm_horz) {\n\t\t\tDCCMetaSurfaceBytes = DCCMetaPitch\n\t\t\t\t\t* (dml_ceil(ViewportHeight - 1, 64 * BlockHeight256Bytes)\n\t\t\t\t\t\t\t+ 64 * BlockHeight256Bytes) * BytePerPixel\n\t\t\t\t\t/ 256;\n\t\t} else {\n\t\t\tDCCMetaSurfaceBytes = DCCMetaPitch\n\t\t\t\t\t* (dml_ceil(\n\t\t\t\t\t\t\t(double) ViewportHeight - 1,\n\t\t\t\t\t\t\t64 * BlockHeight256Bytes)\n\t\t\t\t\t\t\t+ 64 * BlockHeight256Bytes) * BytePerPixel\n\t\t\t\t\t/ 256;\n\t\t}\n\t\tif (GPUVMEnable == true) {\n\t\t\t*MetaPTEBytesFrame = (dml_ceil(\n\t\t\t\t\t(double) (DCCMetaSurfaceBytes - VMMPageSize)\n\t\t\t\t\t\t\t/ (8 * VMMPageSize),\n\t\t\t\t\t1) + 1) * 64;\n\t\t\tMPDEBytesFrame = 128 * ((mode_lib->vba.GPUVMMaxPageTableLevels + 1) * (mode_lib->vba.HostVMMaxPageTableLevels + 1) - 2);\n\t\t} else {\n\t\t\t*MetaPTEBytesFrame = 0;\n\t\t\tMPDEBytesFrame = 0;\n\t\t}\n\t} else {\n\t\t*MetaPTEBytesFrame = 0;\n\t\tMPDEBytesFrame = 0;\n\t\t*MetaRowByte = 0;\n\t}\n\n\tif (SurfaceTiling == dm_sw_linear || SurfaceTiling == dm_sw_gfx7_2d_thin_gl || SurfaceTiling == dm_sw_gfx7_2d_thin_l_vp) {\n\t\tMacroTileSizeBytes = 256;\n\t\tMacroTileHeight = BlockHeight256Bytes;\n\t} else if (SurfaceTiling == dm_sw_4kb_s || SurfaceTiling == dm_sw_4kb_s_x\n\t\t\t|| SurfaceTiling == dm_sw_4kb_d || SurfaceTiling == dm_sw_4kb_d_x) {\n\t\tMacroTileSizeBytes = 4096;\n\t\tMacroTileHeight = 4 * BlockHeight256Bytes;\n\t} else if (SurfaceTiling == dm_sw_64kb_s || SurfaceTiling == dm_sw_64kb_s_t\n\t\t\t|| SurfaceTiling == dm_sw_64kb_s_x || SurfaceTiling == dm_sw_64kb_d\n\t\t\t|| SurfaceTiling == dm_sw_64kb_d_t || SurfaceTiling == dm_sw_64kb_d_x\n\t\t\t|| SurfaceTiling == dm_sw_64kb_r_x) {\n\t\tMacroTileSizeBytes = 65536;\n\t\tMacroTileHeight = 16 * BlockHeight256Bytes;\n\t} else {\n\t\tMacroTileSizeBytes = 262144;\n\t\tMacroTileHeight = 32 * BlockHeight256Bytes;\n\t}\n\t*MacroTileWidth = MacroTileSizeBytes / BytePerPixel / MacroTileHeight;\n\n\tif (GPUVMEnable == true && (mode_lib->vba.GPUVMMaxPageTableLevels + 1) * (mode_lib->vba.HostVMMaxPageTableLevels + 1) > 2) {\n\t\tif (ScanDirection == dm_horz) {\n\t\t\t*DPDE0BytesFrame = 64 * (dml_ceil(((Pitch * (dml_ceil(ViewportHeight - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes) / (8 * 2097152), 1) + 1);\n\t\t} else {\n\t\t\t*DPDE0BytesFrame = 64 * (dml_ceil(((Pitch * (dml_ceil((double) SwathWidth - 1, MacroTileHeight) + MacroTileHeight) * BytePerPixel) - MacroTileSizeBytes) / (8 * 2097152), 1) + 1);\n\t\t}\n\t\tExtraDPDEBytesFrame = 128 * ((mode_lib->vba.GPUVMMaxPageTableLevels + 1) * (mode_lib->vba.HostVMMaxPageTableLevels + 1) - 3);\n\t} else {\n\t\t*DPDE0BytesFrame = 0;\n\t\tExtraDPDEBytesFrame = 0;\n\t}\n\n\tPDEAndMetaPTEBytesFrame = *MetaPTEBytesFrame + MPDEBytesFrame + *DPDE0BytesFrame\n\t\t\t+ ExtraDPDEBytesFrame;\n\n\tif (HostVMEnable == true) {\n\t\tPDEAndMetaPTEBytesFrame = PDEAndMetaPTEBytesFrame * (1 + 8 * (HostVMMaxPageTableLevels - HostVMCachedPageTableLevels));\n\t}\n\n\tif (GPUVMEnable == true) {\n\t\tdouble FractionOfPTEReturnDrop;\n\n\t\tif (SurfaceTiling == dm_sw_linear) {\n\t\t\tPixelPTEReqHeightPTEs = 1;\n\t\t\t*PixelPTEReqHeight = 1;\n\t\t\t*PixelPTEReqWidth = 8.0 * VMMPageSize / BytePerPixel;\n\t\t\t*PTERequestSize = 64;\n\t\t\tFractionOfPTEReturnDrop = 0;\n\t\t} else if (MacroTileSizeBytes == 4096) {\n\t\t\tPixelPTEReqHeightPTEs = 1;\n\t\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t\t*PTERequestSize = 64;\n\t\t\tif (ScanDirection == dm_horz)\n\t\t\t\tFractionOfPTEReturnDrop = 0;\n\t\t\telse\n\t\t\t\tFractionOfPTEReturnDrop = 7 / 8;\n\t\t} else if (VMMPageSize == 4096 && MacroTileSizeBytes > 4096) {\n\t\t\tPixelPTEReqHeightPTEs = 16;\n\t\t\t*PixelPTEReqHeight = 16 * BlockHeight256Bytes;\n\t\t\t*PixelPTEReqWidth = 16 * BlockWidth256Bytes;\n\t\t\t*PTERequestSize = 128;\n\t\t\tFractionOfPTEReturnDrop = 0;\n\t\t} else {\n\t\t\tPixelPTEReqHeightPTEs = 1;\n\t\t\t*PixelPTEReqHeight = MacroTileHeight;\n\t\t\t*PixelPTEReqWidth = 8 * *MacroTileWidth;\n\t\t\t*PTERequestSize = 64;\n\t\t\tFractionOfPTEReturnDrop = 0;\n\t\t}\n\n\t\tif (SurfaceTiling == dm_sw_linear) {\n\t\t\t*dpte_row_height = dml_min(128,\n\t\t\t\t\t1 << (unsigned int) dml_floor(\n\t\t\t\t\t\tdml_log2(\n\t\t\t\t\t\t\t(double) PTEBufferSizeInRequests * *PixelPTEReqWidth / Pitch),\n\t\t\t\t\t\t1));\n\t\t\t*dpte_row_width_ub = (dml_ceil((double) (Pitch * *dpte_row_height - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t\t} else if (ScanDirection == dm_horz) {\n\t\t\t*dpte_row_height = *PixelPTEReqHeight;\n\t\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqWidth, 1) + 1) * *PixelPTEReqWidth;\n\t\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqWidth * *PTERequestSize;\n\t\t} else {\n\t\t\t*dpte_row_height = dml_min(*PixelPTEReqWidth, *MacroTileWidth);\n\t\t\t*dpte_row_width_ub = (dml_ceil((double) (SwathWidth - 1) / *PixelPTEReqHeight, 1) + 1) * *PixelPTEReqHeight;\n\t\t\t*PixelPTEBytesPerRow = *dpte_row_width_ub / *PixelPTEReqHeight * *PTERequestSize;\n\t\t}\n\t\tif (*PixelPTEBytesPerRow * (1 - FractionOfPTEReturnDrop)\n\t\t\t\t<= 64 * PTEBufferSizeInRequests) {\n\t\t\t*PTEBufferSizeNotExceeded = true;\n\t\t} else {\n\t\t\t*PTEBufferSizeNotExceeded = false;\n\t\t}\n\t} else {\n\t\t*PixelPTEBytesPerRow = 0;\n\t\t*PTEBufferSizeNotExceeded = true;\n\t}\n\tdml_print(\"DML: vm_bytes = meta_pte_bytes_per_frame (per_pipe) = MetaPTEBytesFrame = : %d\\n\", *MetaPTEBytesFrame);\n\n\tif (HostVMEnable == true) {\n\t\t*PixelPTEBytesPerRow = *PixelPTEBytesPerRow * (1 + 8 * (HostVMMaxPageTableLevels - HostVMCachedPageTableLevels));\n\t}\n\n\tif (HostVMEnable == true) {\n\t\t*vm_group_bytes = 512;\n\t\t*dpte_group_bytes = 512;\n\t} else if (GPUVMEnable == true) {\n\t\t*vm_group_bytes = 2048;\n\t\tif (SurfaceTiling != dm_sw_linear && PixelPTEReqHeightPTEs == 1 && ScanDirection != dm_horz) {\n\t\t\t*dpte_group_bytes = 512;\n\t\t} else {\n\t\t\t*dpte_group_bytes = 2048;\n\t\t}\n\t} else {\n\t\t*vm_group_bytes = 0;\n\t\t*dpte_group_bytes = 0;\n\t}\n\n\treturn PDEAndMetaPTEBytesFrame;\n}\n\nstatic void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(\n\t\tstruct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *locals = &mode_lib->vba;\n\tunsigned int j, k;\n\n\tmode_lib->vba.WritebackDISPCLK = 0.0;\n\tmode_lib->vba.DISPCLKWithRamping = 0;\n\tmode_lib->vba.DISPCLKWithoutRamping = 0;\n\tmode_lib->vba.GlobalDPPCLK = 0.0;\n\n\t \n\t \n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.WritebackEnable[k]) {\n\t\t\tmode_lib->vba.WritebackDISPCLK =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.WritebackDISPCLK,\n\t\t\t\t\t\t\tCalculateWriteBackDISPCLK(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.HTotal[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaLineBufferWidth));\n\t\t}\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.HRatio[k] > 1) {\n\t\t\tlocals->PSCL_THROUGHPUT_LUMA[k] = dml_min(\n\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput\n\t\t\t\t\t\t\t* mode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t/ dml_ceil(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.htaps[k]\n\t\t\t\t\t\t\t\t\t\t\t/ 6.0,\n\t\t\t\t\t\t\t\t\t1));\n\t\t} else {\n\t\t\tlocals->PSCL_THROUGHPUT_LUMA[k] = dml_min(\n\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput);\n\t\t}\n\n\t\tmode_lib->vba.DPPCLKUsingSingleDPPLuma =\n\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t* dml_max(\n\t\t\t\t\t\t\t\tmode_lib->vba.vtaps[k] / 6.0\n\t\t\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]),\n\t\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t/ locals->PSCL_THROUGHPUT_LUMA[k],\n\t\t\t\t\t\t\t\t\t\t1.0));\n\n\t\tif ((mode_lib->vba.htaps[k] > 6 || mode_lib->vba.vtaps[k] > 6)\n\t\t\t\t&& mode_lib->vba.DPPCLKUsingSingleDPPLuma\n\t\t\t\t\t\t< 2 * mode_lib->vba.PixelClock[k]) {\n\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPLuma = 2 * mode_lib->vba.PixelClock[k];\n\t\t}\n\n\t\tif ((mode_lib->vba.SourcePixelFormat[k] != dm_420_8\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_420_10)) {\n\t\t\tlocals->PSCL_THROUGHPUT_CHROMA[k] = 0.0;\n\t\t\tlocals->DPPCLKUsingSingleDPP[k] =\n\t\t\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPLuma;\n\t\t} else {\n\t\t\tif (mode_lib->vba.HRatio[k] > 1) {\n\t\t\t\tlocals->PSCL_THROUGHPUT_CHROMA[k] =\n\t\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput\n\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t/ 2\n\t\t\t\t\t\t\t\t\t\t/ dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HTAPsChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 6.0,\n\t\t\t\t\t\t\t\t\t\t\t\t1.0));\n\t\t\t} else {\n\t\t\t\tlocals->PSCL_THROUGHPUT_CHROMA[k] = dml_min(\n\t\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPChroma =\n\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* dml_max(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.VTAPsChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t/ 6.0\n\t\t\t\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2),\n\t\t\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 4\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ locals->PSCL_THROUGHPUT_CHROMA[k],\n\t\t\t\t\t\t\t\t\t\t\t1.0));\n\n\t\t\tif ((mode_lib->vba.HTAPsChroma[k] > 6 || mode_lib->vba.VTAPsChroma[k] > 6)\n\t\t\t\t\t&& mode_lib->vba.DPPCLKUsingSingleDPPChroma\n\t\t\t\t\t\t\t< 2 * mode_lib->vba.PixelClock[k]) {\n\t\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPChroma = 2\n\t\t\t\t\t\t* mode_lib->vba.PixelClock[k];\n\t\t\t}\n\n\t\t\tlocals->DPPCLKUsingSingleDPP[k] = dml_max(\n\t\t\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPLuma,\n\t\t\t\t\tmode_lib->vba.DPPCLKUsingSingleDPPChroma);\n\t\t}\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.BlendingAndTiming[k] != k)\n\t\t\tcontinue;\n\t\tif (mode_lib->vba.ODMCombineEnabled[k]) {\n\t\t\tmode_lib->vba.DISPCLKWithRamping =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.DISPCLKWithRamping,\n\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k] / 2\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100)\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKRampingMargin\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100));\n\t\t\tmode_lib->vba.DISPCLKWithoutRamping =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.DISPCLKWithoutRamping,\n\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k] / 2\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100));\n\t\t} else if (!mode_lib->vba.ODMCombineEnabled[k]) {\n\t\t\tmode_lib->vba.DISPCLKWithRamping =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.DISPCLKWithRamping,\n\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100)\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKRampingMargin\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100));\n\t\t\tmode_lib->vba.DISPCLKWithoutRamping =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.DISPCLKWithoutRamping,\n\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t\t\t* (1\n\t\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 100));\n\t\t}\n\t}\n\n\tmode_lib->vba.DISPCLKWithRamping = dml_max(\n\t\t\tmode_lib->vba.DISPCLKWithRamping,\n\t\t\tmode_lib->vba.WritebackDISPCLK);\n\tmode_lib->vba.DISPCLKWithoutRamping = dml_max(\n\t\t\tmode_lib->vba.DISPCLKWithoutRamping,\n\t\t\tmode_lib->vba.WritebackDISPCLK);\n\n\tASSERT(mode_lib->vba.DISPCLKDPPCLKVCOSpeed != 0);\n\tmode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(\n\t\t\tmode_lib->vba.DISPCLKWithRamping,\n\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\tmode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity = RoundToDFSGranularityUp(\n\t\t\tmode_lib->vba.DISPCLKWithoutRamping,\n\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\tmode_lib->vba.MaxDispclkRoundedToDFSGranularity = RoundToDFSGranularityDown(\n\t\t\tmode_lib->vba.soc.clock_limits[mode_lib->vba.soc.num_states - 1].dispclk_mhz,\n\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\tif (mode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity\n\t\t\t> mode_lib->vba.MaxDispclkRoundedToDFSGranularity) {\n\t\tmode_lib->vba.DISPCLK_calculated =\n\t\t\t\tmode_lib->vba.DISPCLKWithoutRampingRoundedToDFSGranularity;\n\t} else if (mode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity\n\t\t\t> mode_lib->vba.MaxDispclkRoundedToDFSGranularity) {\n\t\tmode_lib->vba.DISPCLK_calculated = mode_lib->vba.MaxDispclkRoundedToDFSGranularity;\n\t} else {\n\t\tmode_lib->vba.DISPCLK_calculated =\n\t\t\t\tmode_lib->vba.DISPCLKWithRampingRoundedToDFSGranularity;\n\t}\n\tDTRACE(\"   dispclk_mhz (calculated) = %f\", mode_lib->vba.DISPCLK_calculated);\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.DPPCLK_calculated[k] = locals->DPPCLKUsingSingleDPP[k]\n\t\t\t\t/ mode_lib->vba.DPPPerPlane[k]\n\t\t\t\t* (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100);\n\t\tmode_lib->vba.GlobalDPPCLK = dml_max(\n\t\t\t\tmode_lib->vba.GlobalDPPCLK,\n\t\t\t\tmode_lib->vba.DPPCLK_calculated[k]);\n\t}\n\tmode_lib->vba.GlobalDPPCLK = RoundToDFSGranularityUp(\n\t\t\tmode_lib->vba.GlobalDPPCLK,\n\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.DPPCLK_calculated[k] = mode_lib->vba.GlobalDPPCLK / 255\n\t\t\t\t* dml_ceil(\n\t\t\t\t\t\tmode_lib->vba.DPPCLK_calculated[k] * 255\n\t\t\t\t\t\t\t\t/ mode_lib->vba.GlobalDPPCLK,\n\t\t\t\t\t\t1);\n\t\tDTRACE(\"   dppclk_mhz[%i] (calculated) = %f\", k, mode_lib->vba.DPPCLK_calculated[k]);\n\t}\n\n\t \n\tDTRACE(\"   dcfclk_mhz         = %f\", mode_lib->vba.DCFCLK);\n\tDTRACE(\"   return_bw_to_dcn   = %f\", mode_lib->vba.ReturnBandwidthToDCN);\n\tDTRACE(\"   return_bus_bw      = %f\", mode_lib->vba.ReturnBW);\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tbool MainPlaneDoesODMCombine = false;\n\n\t\tif (mode_lib->vba.SourceScan[k] == dm_horz)\n\t\t\tlocals->SwathWidthSingleDPPY[k] = mode_lib->vba.ViewportWidth[k];\n\t\telse\n\t\t\tlocals->SwathWidthSingleDPPY[k] = mode_lib->vba.ViewportHeight[k];\n\n\t\tif (mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)\n\t\t\tMainPlaneDoesODMCombine = true;\n\t\tfor (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == j\n\t\t\t\t\t&& mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1)\n\t\t\t\tMainPlaneDoesODMCombine = true;\n\n\t\tif (MainPlaneDoesODMCombine == true)\n\t\t\tlocals->SwathWidthY[k] = dml_min(\n\t\t\t\t\t(double) locals->SwathWidthSingleDPPY[k],\n\t\t\t\t\tdml_round(\n\t\t\t\t\t\t\tmode_lib->vba.HActive[k] / 2.0\n\t\t\t\t\t\t\t\t\t* mode_lib->vba.HRatio[k]));\n\t\telse\n\t\t\tlocals->SwathWidthY[k] = locals->SwathWidthSingleDPPY[k]\n\t\t\t\t\t/ mode_lib->vba.DPPPerPlane[k];\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {\n\t\t\tlocals->BytePerPixelDETY[k] = 8;\n\t\t\tlocals->BytePerPixelDETC[k] = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {\n\t\t\tlocals->BytePerPixelDETY[k] = 4;\n\t\t\tlocals->BytePerPixelDETC[k] = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16 || mode_lib->vba.SourcePixelFormat[k] == dm_mono_16) {\n\t\t\tlocals->BytePerPixelDETY[k] = 2;\n\t\t\tlocals->BytePerPixelDETC[k] = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8 || mode_lib->vba.SourcePixelFormat[k] == dm_mono_8) {\n\t\t\tlocals->BytePerPixelDETY[k] = 1;\n\t\t\tlocals->BytePerPixelDETC[k] = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {\n\t\t\tlocals->BytePerPixelDETY[k] = 1;\n\t\t\tlocals->BytePerPixelDETC[k] = 2;\n\t\t} else {  \n\t\t\tlocals->BytePerPixelDETY[k] = 4.0 / 3.0;\n\t\t\tlocals->BytePerPixelDETC[k] = 8.0 / 3.0;\n\t\t}\n\t}\n\n\tmode_lib->vba.TotalDataReadBandwidth = 0.0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tlocals->ReadBandwidthPlaneLuma[k] = locals->SwathWidthSingleDPPY[k]\n\t\t\t\t* dml_ceil(locals->BytePerPixelDETY[k], 1)\n\t\t\t\t/ (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])\n\t\t\t\t* mode_lib->vba.VRatio[k];\n\t\tlocals->ReadBandwidthPlaneChroma[k] = locals->SwathWidthSingleDPPY[k]\n\t\t\t\t/ 2 * dml_ceil(locals->BytePerPixelDETC[k], 2)\n\t\t\t\t/ (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k])\n\t\t\t\t* mode_lib->vba.VRatio[k] / 2;\n\t\tDTRACE(\n\t\t\t\t\"   read_bw[%i] = %fBps\",\n\t\t\t\tk,\n\t\t\t\tlocals->ReadBandwidthPlaneLuma[k]\n\t\t\t\t\t\t+ locals->ReadBandwidthPlaneChroma[k]);\n\t\tmode_lib->vba.TotalDataReadBandwidth += locals->ReadBandwidthPlaneLuma[k]\n\t\t\t\t+ locals->ReadBandwidthPlaneChroma[k];\n\t}\n\n\t \n\tCalculateDCFCLKDeepSleep(\n\t\tmode_lib,\n\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\tlocals->BytePerPixelDETY,\n\t\tlocals->BytePerPixelDETC,\n\t\tmode_lib->vba.VRatio,\n\t\tlocals->SwathWidthY,\n\t\tmode_lib->vba.DPPPerPlane,\n\t\tmode_lib->vba.HRatio,\n\t\tmode_lib->vba.PixelClock,\n\t\tlocals->PSCL_THROUGHPUT_LUMA,\n\t\tlocals->PSCL_THROUGHPUT_CHROMA,\n\t\tlocals->DPPCLK,\n\t\t&mode_lib->vba.DCFCLKDeepSleep);\n\n\t \n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif ((mode_lib->vba.BlendingAndTiming[k] != k) || !mode_lib->vba.DSCEnabled[k]) {\n\t\t\tlocals->DSCCLK_calculated[k] = 0.0;\n\t\t} else {\n\t\t\tif (mode_lib->vba.OutputFormat[k] == dm_420\n\t\t\t\t\t|| mode_lib->vba.OutputFormat[k] == dm_n422)\n\t\t\t\tmode_lib->vba.DSCFormatFactor = 2;\n\t\t\telse\n\t\t\t\tmode_lib->vba.DSCFormatFactor = 1;\n\t\t\tif (mode_lib->vba.ODMCombineEnabled[k])\n\t\t\t\tlocals->DSCCLK_calculated[k] =\n\t\t\t\t\t\tmode_lib->vba.PixelClockBackEnd[k] / 6\n\t\t\t\t\t\t\t\t/ mode_lib->vba.DSCFormatFactor\n\t\t\t\t\t\t\t\t/ (1\n\t\t\t\t\t\t\t\t\t\t- mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100);\n\t\t\telse\n\t\t\t\tlocals->DSCCLK_calculated[k] =\n\t\t\t\t\t\tmode_lib->vba.PixelClockBackEnd[k] / 3\n\t\t\t\t\t\t\t\t/ mode_lib->vba.DSCFormatFactor\n\t\t\t\t\t\t\t\t/ (1\n\t\t\t\t\t\t\t\t\t\t- mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100);\n\t\t}\n\t}\n\n\t \n\t \n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tdouble bpp = mode_lib->vba.OutputBpp[k];\n\t\tunsigned int slices = mode_lib->vba.NumberOfDSCSlices[k];\n\n\t\tif (mode_lib->vba.DSCEnabled[k] && bpp != 0) {\n\t\t\tif (!mode_lib->vba.ODMCombineEnabled[k]) {\n\t\t\t\tlocals->DSCDelay[k] =\n\t\t\t\t\t\tdscceComputeDelay(\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\tbpp,\n\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t(double) mode_lib->vba.HActive[k]\n\t\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\t\t1),\n\t\t\t\t\t\t\t\tslices,\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k])\n\t\t\t\t\t\t\t\t+ dscComputeDelay(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k]);\n\t\t\t} else {\n\t\t\t\tlocals->DSCDelay[k] =\n\t\t\t\t\t\t2\n\t\t\t\t\t\t\t\t* (dscceComputeDelay(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\t\tbpp,\n\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t(double) mode_lib->vba.HActive[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.NumberOfDSCSlices[k],\n\t\t\t\t\t\t\t\t\t\t\t\t1),\n\t\t\t\t\t\t\t\t\t\tslices / 2.0,\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k])\n\t\t\t\t\t\t\t\t\t\t+ dscComputeDelay(\n\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k]));\n\t\t\t}\n\t\t\tlocals->DSCDelay[k] = locals->DSCDelay[k]\n\t\t\t\t\t* mode_lib->vba.PixelClock[k]\n\t\t\t\t\t/ mode_lib->vba.PixelClockBackEnd[k];\n\t\t} else {\n\t\t\tlocals->DSCDelay[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)  \n\t\t\tif (j != k && mode_lib->vba.BlendingAndTiming[k] == j\n\t\t\t\t\t&& mode_lib->vba.DSCEnabled[j])\n\t\t\t\tlocals->DSCDelay[k] = locals->DSCDelay[j];\n\n\t \n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tunsigned int PDEAndMetaPTEBytesFrameY;\n\t\tunsigned int PixelPTEBytesPerRowY;\n\t\tunsigned int MetaRowByteY;\n\t\tunsigned int MetaRowByteC;\n\t\tunsigned int PDEAndMetaPTEBytesFrameC;\n\t\tunsigned int PixelPTEBytesPerRowC;\n\t\tbool         PTEBufferSizeNotExceededY;\n\t\tbool         PTEBufferSizeNotExceededC;\n\n\t\tCalculate256BBlockSizes(\n\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\tdml_ceil(locals->BytePerPixelDETY[k], 1),\n\t\t\t\tdml_ceil(locals->BytePerPixelDETC[k], 2),\n\t\t\t\t&locals->BlockHeight256BytesY[k],\n\t\t\t\t&locals->BlockHeight256BytesC[k],\n\t\t\t\t&locals->BlockWidth256BytesY[k],\n\t\t\t\t&locals->BlockWidth256BytesC[k]);\n\n\t\tlocals->PrefetchSourceLinesY[k] = CalculatePrefetchSourceLines(\n\t\t\t\tmode_lib,\n\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\tmode_lib->vba.vtaps[k],\n\t\t\t\tmode_lib->vba.Interlace[k],\n\t\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\t\tmode_lib->vba.ViewportYStartY[k],\n\t\t\t\t&locals->VInitPreFillY[k],\n\t\t\t\t&locals->MaxNumSwathY[k]);\n\n\t\tif ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_32\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_16\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_8)) {\n\t\t\tPDEAndMetaPTEBytesFrameC =\n\t\t\t\t\tCalculateVMAndRowBytes(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\t\tlocals->BlockHeight256BytesC[k],\n\t\t\t\t\t\t\tlocals->BlockWidth256BytesC[k],\n\t\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\tlocals->BytePerPixelDETC[k],\n\t\t\t\t\t\t\t\t\t2),\n\t\t\t\t\t\t\tmode_lib->vba.SourceScan[k],\n\t\t\t\t\t\t\tmode_lib->vba.ViewportWidth[k] / 2,\n\t\t\t\t\t\t\tmode_lib->vba.ViewportHeight[k] / 2,\n\t\t\t\t\t\t\tlocals->SwathWidthY[k] / 2,\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.VMMPageSize,\n\t\t\t\t\t\t\tmode_lib->vba.PTEBufferSizeInRequestsChroma,\n\t\t\t\t\t\t\tmode_lib->vba.PitchC[k],\n\t\t\t\t\t\t\tmode_lib->vba.DCCMetaPitchC[k],\n\t\t\t\t\t\t\t&locals->MacroTileWidthC[k],\n\t\t\t\t\t\t\t&MetaRowByteC,\n\t\t\t\t\t\t\t&PixelPTEBytesPerRowC,\n\t\t\t\t\t\t\t&PTEBufferSizeNotExceededC,\n\t\t\t\t\t\t\t&locals->dpte_row_width_chroma_ub[k],\n\t\t\t\t\t\t\t&locals->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_req_width_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_req_height_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_row_width_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t&locals->vm_group_bytes_chroma,\n\t\t\t\t\t\t\t&locals->dpte_group_bytes_chroma,\n\t\t\t\t\t\t\t&locals->PixelPTEReqWidthC[k],\n\t\t\t\t\t\t\t&locals->PixelPTEReqHeightC[k],\n\t\t\t\t\t\t\t&locals->PTERequestSizeC[k],\n\t\t\t\t\t\t\t&locals->dpde0_bytes_per_frame_ub_c[k],\n\t\t\t\t\t\t\t&locals->meta_pte_bytes_per_frame_ub_c[k]);\n\n\t\t\tlocals->PrefetchSourceLinesC[k] = CalculatePrefetchSourceLines(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tmode_lib->vba.VRatio[k] / 2,\n\t\t\t\t\tmode_lib->vba.VTAPsChroma[k],\n\t\t\t\t\tmode_lib->vba.Interlace[k],\n\t\t\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\tmode_lib->vba.SwathHeightC[k],\n\t\t\t\t\tmode_lib->vba.ViewportYStartC[k],\n\t\t\t\t\t&locals->VInitPreFillC[k],\n\t\t\t\t\t&locals->MaxNumSwathC[k]);\n\t\t} else {\n\t\t\tPixelPTEBytesPerRowC = 0;\n\t\t\tPDEAndMetaPTEBytesFrameC = 0;\n\t\t\tMetaRowByteC = 0;\n\t\t\tlocals->MaxNumSwathC[k] = 0;\n\t\t\tlocals->PrefetchSourceLinesC[k] = 0;\n\t\t\tlocals->PTEBufferSizeInRequestsForLuma = mode_lib->vba.PTEBufferSizeInRequestsLuma + mode_lib->vba.PTEBufferSizeInRequestsChroma;\n\t\t}\n\n\t\tPDEAndMetaPTEBytesFrameY = CalculateVMAndRowBytes(\n\t\t\t\tmode_lib,\n\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\tlocals->BlockHeight256BytesY[k],\n\t\t\t\tlocals->BlockWidth256BytesY[k],\n\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\tdml_ceil(locals->BytePerPixelDETY[k], 1),\n\t\t\t\tmode_lib->vba.SourceScan[k],\n\t\t\t\tmode_lib->vba.ViewportWidth[k],\n\t\t\t\tmode_lib->vba.ViewportHeight[k],\n\t\t\t\tlocals->SwathWidthY[k],\n\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\tmode_lib->vba.VMMPageSize,\n\t\t\t\tlocals->PTEBufferSizeInRequestsForLuma,\n\t\t\t\tmode_lib->vba.PitchY[k],\n\t\t\t\tmode_lib->vba.DCCMetaPitchY[k],\n\t\t\t\t&locals->MacroTileWidthY[k],\n\t\t\t\t&MetaRowByteY,\n\t\t\t\t&PixelPTEBytesPerRowY,\n\t\t\t\t&PTEBufferSizeNotExceededY,\n\t\t\t\t&locals->dpte_row_width_luma_ub[k],\n\t\t\t\t&locals->dpte_row_height[k],\n\t\t\t\t&locals->meta_req_width[k],\n\t\t\t\t&locals->meta_req_height[k],\n\t\t\t\t&locals->meta_row_width[k],\n\t\t\t\t&locals->meta_row_height[k],\n\t\t\t\t&locals->vm_group_bytes[k],\n\t\t\t\t&locals->dpte_group_bytes[k],\n\t\t\t\t&locals->PixelPTEReqWidthY[k],\n\t\t\t\t&locals->PixelPTEReqHeightY[k],\n\t\t\t\t&locals->PTERequestSizeY[k],\n\t\t\t\t&locals->dpde0_bytes_per_frame_ub_l[k],\n\t\t\t\t&locals->meta_pte_bytes_per_frame_ub_l[k]);\n\n\t\tlocals->PixelPTEBytesPerRow[k] = PixelPTEBytesPerRowY + PixelPTEBytesPerRowC;\n\t\tlocals->PDEAndMetaPTEBytesFrame[k] = PDEAndMetaPTEBytesFrameY\n\t\t\t\t+ PDEAndMetaPTEBytesFrameC;\n\t\tlocals->MetaRowByte[k] = MetaRowByteY + MetaRowByteC;\n\n\t\tCalculateActiveRowBandwidth(\n\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\tMetaRowByteY,\n\t\t\t\tMetaRowByteC,\n\t\t\t\tlocals->meta_row_height[k],\n\t\t\t\tlocals->meta_row_height_chroma[k],\n\t\t\t\tPixelPTEBytesPerRowY,\n\t\t\t\tPixelPTEBytesPerRowC,\n\t\t\t\tlocals->dpte_row_height[k],\n\t\t\t\tlocals->dpte_row_height_chroma[k],\n\t\t\t\t&locals->meta_row_bw[k],\n\t\t\t\t&locals->dpte_row_bw[k]);\n\t}\n\n\tmode_lib->vba.TotalDCCActiveDPP = 0;\n\tmode_lib->vba.TotalActiveDPP = 0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.TotalActiveDPP = mode_lib->vba.TotalActiveDPP\n\t\t\t\t+ mode_lib->vba.DPPPerPlane[k];\n\t\tif (mode_lib->vba.DCCEnable[k])\n\t\t\tmode_lib->vba.TotalDCCActiveDPP = mode_lib->vba.TotalDCCActiveDPP\n\t\t\t\t\t+ mode_lib->vba.DPPPerPlane[k];\n\t}\n\n\tmode_lib->vba.UrgentOutOfOrderReturnPerChannel = dml_max3(\n\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\n\tmode_lib->vba.UrgentRoundTripAndOutOfOrderLatency =\n\t\t\t(mode_lib->vba.RoundTripPingLatencyCycles + 32) / mode_lib->vba.DCFCLK\n\t\t\t\t\t+ mode_lib->vba.UrgentOutOfOrderReturnPerChannel\n\t\t\t\t\t\t\t* mode_lib->vba.NumberOfChannels\n\t\t\t\t\t\t\t/ mode_lib->vba.ReturnBW;\n\n\tmode_lib->vba.UrgentExtraLatency = CalculateExtraLatency(\n\t\t\tmode_lib->vba.UrgentRoundTripAndOutOfOrderLatency,\n\t\t\tmode_lib->vba.TotalActiveDPP,\n\t\t\tmode_lib->vba.PixelChunkSizeInKByte,\n\t\t\tmode_lib->vba.TotalDCCActiveDPP,\n\t\t\tmode_lib->vba.MetaChunkSize,\n\t\t\tmode_lib->vba.ReturnBW,\n\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\tmode_lib->vba.DPPPerPlane,\n\t\t\tlocals->dpte_group_bytes,\n\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\tmode_lib->vba.HostVMCachedPageTableLevels);\n\n\n\tmode_lib->vba.TCalc = 24.0 / mode_lib->vba.DCFCLKDeepSleep;\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][k] =\n\t\t\t\t\t\tmode_lib->vba.WritebackLatency\n\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[k])\n\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.DISPCLK;\n\t\t\t} else\n\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][k] = 0;\n\t\t\tfor (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j) {\n\t\t\t\tif (mode_lib->vba.BlendingAndTiming[j] == k\n\t\t\t\t\t\t&& mode_lib->vba.WritebackEnable[j] == true) {\n\t\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][k] =\n\t\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLatency\n\t\t\t\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[j])\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.DISPCLK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)\n\t\tfor (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j)\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == j)\n\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][k] =\n\t\t\t\t\t\tlocals->WritebackDelay[mode_lib->vba.VoltageLevel][j];\n\n\tmode_lib->vba.VStartupLines = 13;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tlocals->MaxVStartupLines[k] = mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k] - dml_max(1.0, dml_ceil(locals->WritebackDelay[mode_lib->vba.VoltageLevel][k] / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]), 1));\n\t}\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k)\n\t\tlocals->MaximumMaxVStartupLines = dml_max(locals->MaximumMaxVStartupLines, locals->MaxVStartupLines[k]);\n\n\t \n\t\n\tmode_lib->vba.UrgentLatency = dml_max3(mode_lib->vba.UrgentLatencyPixelDataOnly, mode_lib->vba.UrgentLatencyPixelMixedWithVMData, mode_lib->vba.UrgentLatencyVMDataOnly);\n\n\tdo {\n\t\tdouble MaxTotalRDBandwidth = 0;\n\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0;\n\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;\n\t\tbool VRatioPrefetchMoreThan4 = false;\n\t\tdouble TWait = CalculateTWait(\n\t\t\t\tmode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb],\n\t\t\t\tmode_lib->vba.DRAMClockChangeLatency,\n\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\tmode_lib->vba.SREnterPlusExitTime);\n\n\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\tPipe   myPipe;\n\t\t\tHostVM myHostVM;\n\n\t\t\tif (mode_lib->vba.XFCEnabled[k] == true) {\n\t\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay =\n\t\t\t\t\t\tCalculateRemoteSurfaceFlipDelay(\n\t\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\t\t\tlocals->SwathWidthY[k],\n\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\tlocals->BytePerPixelDETY[k],\n\t\t\t\t\t\t\t\t\t\t1),\n\t\t\t\t\t\t\t\tmode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateOffset,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateWidth,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCTSlvVreadyOffset,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCXBUFLatencyTolerance,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCFillBWOverhead,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCSlvChunkSize,\n\t\t\t\t\t\t\t\tmode_lib->vba.XFCBusTransportTime,\n\t\t\t\t\t\t\t\tmode_lib->vba.TCalc,\n\t\t\t\t\t\t\t\tTWait,\n\t\t\t\t\t\t\t\t&mode_lib->vba.SrcActiveDrainRate,\n\t\t\t\t\t\t\t\t&mode_lib->vba.TInitXFill,\n\t\t\t\t\t\t\t\t&mode_lib->vba.TslvChk);\n\t\t\t} else {\n\t\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay = 0;\n\t\t\t}\n\n\t\t\tmyPipe.DPPCLK = locals->DPPCLK[k];\n\t\t\tmyPipe.DISPCLK = mode_lib->vba.DISPCLK;\n\t\t\tmyPipe.PixelClock = mode_lib->vba.PixelClock[k];\n\t\t\tmyPipe.DCFCLKDeepSleep = mode_lib->vba.DCFCLKDeepSleep;\n\t\t\tmyPipe.DPPPerPlane = mode_lib->vba.DPPPerPlane[k];\n\t\t\tmyPipe.ScalerEnabled = mode_lib->vba.ScalerEnabled[k];\n\t\t\tmyPipe.SourceScan = mode_lib->vba.SourceScan[k];\n\t\t\tmyPipe.BlockWidth256BytesY = locals->BlockWidth256BytesY[k];\n\t\t\tmyPipe.BlockHeight256BytesY = locals->BlockHeight256BytesY[k];\n\t\t\tmyPipe.BlockWidth256BytesC = locals->BlockWidth256BytesC[k];\n\t\t\tmyPipe.BlockHeight256BytesC = locals->BlockHeight256BytesC[k];\n\t\t\tmyPipe.InterlaceEnable = mode_lib->vba.Interlace[k];\n\t\t\tmyPipe.NumberOfCursors = mode_lib->vba.NumberOfCursors[k];\n\t\t\tmyPipe.VBlank = mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k];\n\t\t\tmyPipe.HTotal = mode_lib->vba.HTotal[k];\n\n\n\t\t\tmyHostVM.Enable = mode_lib->vba.HostVMEnable;\n\t\t\tmyHostVM.MaxPageTableLevels = mode_lib->vba.HostVMMaxPageTableLevels;\n\t\t\tmyHostVM.CachedPageTableLevels = mode_lib->vba.HostVMCachedPageTableLevels;\n\n\t\t\tmode_lib->vba.ErrorResult[k] =\n\t\t\t\t\tCalculatePrefetchSchedule(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\t\t&myPipe,\n\t\t\t\t\t\t\tlocals->DSCDelay[k],\n\t\t\t\t\t\t\tmode_lib->vba.DPPCLKDelaySubtotal,\n\t\t\t\t\t\t\tmode_lib->vba.DPPCLKDelaySCL,\n\t\t\t\t\t\t\tmode_lib->vba.DPPCLKDelaySCLLBOnly,\n\t\t\t\t\t\t\tmode_lib->vba.DPPCLKDelayCNVCFormater,\n\t\t\t\t\t\t\tmode_lib->vba.DPPCLKDelayCNVCCursor,\n\t\t\t\t\t\t\tmode_lib->vba.DISPCLKDelaySubtotal,\n\t\t\t\t\t\t\t(unsigned int) (locals->SwathWidthY[k]\n\t\t\t\t\t\t\t\t\t/ mode_lib->vba.HRatio[k]),\n\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\tmode_lib->vba.MaxInterDCNTileRepeaters,\n\t\t\t\t\t\t\tdml_min(mode_lib->vba.VStartupLines, locals->MaxVStartupLines[k]),\n\t\t\t\t\t\t\tlocals->MaxVStartupLines[k],\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMMaxPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\t\t&myHostVM,\n\t\t\t\t\t\t\tmode_lib->vba.DynamicMetadataEnable[k],\n\t\t\t\t\t\t\tmode_lib->vba.DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\t\t\t\t\tmode_lib->vba.DynamicMetadataTransmittedBytes[k],\n\t\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\t\t\tmode_lib->vba.UrgentExtraLatency,\n\t\t\t\t\t\t\tmode_lib->vba.TCalc,\n\t\t\t\t\t\t\tlocals->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\t\t\tlocals->MetaRowByte[k],\n\t\t\t\t\t\t\tlocals->PixelPTEBytesPerRow[k],\n\t\t\t\t\t\t\tlocals->PrefetchSourceLinesY[k],\n\t\t\t\t\t\t\tlocals->SwathWidthY[k],\n\t\t\t\t\t\t\tlocals->BytePerPixelDETY[k],\n\t\t\t\t\t\t\tlocals->VInitPreFillY[k],\n\t\t\t\t\t\t\tlocals->MaxNumSwathY[k],\n\t\t\t\t\t\t\tlocals->PrefetchSourceLinesC[k],\n\t\t\t\t\t\t\tlocals->BytePerPixelDETC[k],\n\t\t\t\t\t\t\tlocals->VInitPreFillC[k],\n\t\t\t\t\t\t\tlocals->MaxNumSwathC[k],\n\t\t\t\t\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\t\t\t\t\tmode_lib->vba.SwathHeightC[k],\n\t\t\t\t\t\t\tTWait,\n\t\t\t\t\t\t\tmode_lib->vba.XFCEnabled[k],\n\t\t\t\t\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay,\n\t\t\t\t\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\t&locals->DSTXAfterScaler[k],\n\t\t\t\t\t\t\t&locals->DSTYAfterScaler[k],\n\t\t\t\t\t\t\t&locals->DestinationLinesForPrefetch[k],\n\t\t\t\t\t\t\t&locals->PrefetchBandwidth[k],\n\t\t\t\t\t\t\t&locals->DestinationLinesToRequestVMInVBlank[k],\n\t\t\t\t\t\t\t&locals->DestinationLinesToRequestRowInVBlank[k],\n\t\t\t\t\t\t\t&locals->VRatioPrefetchY[k],\n\t\t\t\t\t\t\t&locals->VRatioPrefetchC[k],\n\t\t\t\t\t\t\t&locals->RequiredPrefetchPixDataBWLuma[k],\n\t\t\t\t\t\t\t&locals->RequiredPrefetchPixDataBWChroma[k],\n\t\t\t\t\t\t\t&locals->VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,\n\t\t\t\t\t\t\t&locals->Tno_bw[k],\n\t\t\t\t\t\t\t&locals->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\t&locals->swath_width_luma_ub[k],\n\t\t\t\t\t\t\t&locals->swath_width_chroma_ub[k],\n\t\t\t\t\t\t\t&mode_lib->vba.VUpdateOffsetPix[k],\n\t\t\t\t\t\t\t&mode_lib->vba.VUpdateWidthPix[k],\n\t\t\t\t\t\t\t&mode_lib->vba.VReadyOffsetPix[k]);\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\t\tlocals->VStartup[k] = dml_min(\n\t\t\t\t\t\tmode_lib->vba.VStartupLines,\n\t\t\t\t\t\tlocals->MaxVStartupLines[k]);\n\t\t\t\tif (locals->VStartupRequiredWhenNotEnoughTimeForDynamicMetadata\n\t\t\t\t\t\t!= 0) {\n\t\t\t\t\tlocals->VStartup[k] =\n\t\t\t\t\t\t\tlocals->VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlocals->VStartup[k] =\n\t\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\t\tmode_lib->vba.VStartupLines,\n\t\t\t\t\t\t\t\tlocals->MaxVStartupLines[mode_lib->vba.BlendingAndTiming[k]]);\n\t\t\t}\n\t\t}\n\n\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\tunsigned int m;\n\n\t\t\tlocals->cursor_bw[k] = 0;\n\t\t\tlocals->cursor_bw_pre[k] = 0;\n\t\t\tfor (m = 0; m < mode_lib->vba.NumberOfCursors[k]; m++) {\n\t\t\t\tlocals->cursor_bw[k] += mode_lib->vba.CursorWidth[k][m] * mode_lib->vba.CursorBPP[k][m] / 8.0 / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k];\n\t\t\t\tlocals->cursor_bw_pre[k] += mode_lib->vba.CursorWidth[k][m] * mode_lib->vba.CursorBPP[k][m] / 8.0 / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * locals->VRatioPrefetchY[k];\n\t\t\t}\n\n\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\t\t\tmode_lib->vba.SwathHeightC[k],\n\t\t\t\t\tlocals->SwathWidthY[k],\n\t\t\t\t\tmode_lib->vba.HTotal[k] /\n\t\t\t\t\tmode_lib->vba.PixelClock[k],\n\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\tmode_lib->vba.CursorBufferSize,\n\t\t\t\t\tmode_lib->vba.CursorWidth[k][0] + mode_lib->vba.CursorWidth[k][1],\n\t\t\t\t\tdml_max(mode_lib->vba.CursorBPP[k][0], mode_lib->vba.CursorBPP[k][1]),\n\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\tlocals->VRatioPrefetchY[k],\n\t\t\t\t\tlocals->VRatioPrefetchC[k],\n\t\t\t\t\tlocals->BytePerPixelDETY[k],\n\t\t\t\t\tlocals->BytePerPixelDETC[k],\n\t\t\t\t\t&locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t&locals->UrgentBurstFactorCursorPre[k],\n\t\t\t\t\t&locals->UrgentBurstFactorLuma[k],\n\t\t\t\t\t&locals->UrgentBurstFactorLumaPre[k],\n\t\t\t\t\t&locals->UrgentBurstFactorChroma[k],\n\t\t\t\t\t&locals->UrgentBurstFactorChromaPre[k],\n\t\t\t\t\t&locals->NotEnoughUrgentLatencyHiding[0][0],\n\t\t\t\t\t&locals->NotEnoughUrgentLatencyHidingPre);\n\n\t\t\tif (mode_lib->vba.UseUrgentBurstBandwidth == false) {\n\t\t\t\tlocals->UrgentBurstFactorLuma[k] = 1;\n\t\t\t\tlocals->UrgentBurstFactorChroma[k] = 1;\n\t\t\t\tlocals->UrgentBurstFactorCursor[k] = 1;\n\t\t\t\tlocals->UrgentBurstFactorLumaPre[k] = 1;\n\t\t\t\tlocals->UrgentBurstFactorChromaPre[k] = 1;\n\t\t\t\tlocals->UrgentBurstFactorCursorPre[k] = 1;\n\t\t\t}\n\n\t\t\tMaxTotalRDBandwidth = MaxTotalRDBandwidth +\n\t\t\t\tdml_max3(locals->prefetch_vmrow_bw[k],\n\t\t\t\t\tlocals->ReadBandwidthPlaneLuma[k] * locals->UrgentBurstFactorLuma[k]\n\t\t\t\t\t+ locals->ReadBandwidthPlaneChroma[k] * locals->UrgentBurstFactorChroma[k] + locals->cursor_bw[k]\n\t\t\t\t\t* locals->UrgentBurstFactorCursor[k] + locals->meta_row_bw[k] + locals->dpte_row_bw[k],\n\t\t\t\t\tlocals->RequiredPrefetchPixDataBWLuma[k] * locals->UrgentBurstFactorLumaPre[k] + locals->RequiredPrefetchPixDataBWChroma[k]\n\t\t\t\t\t* locals->UrgentBurstFactorChromaPre[k] + locals->cursor_bw_pre[k] * locals->UrgentBurstFactorCursorPre[k]);\n\n\t\t\tMaxTotalRDBandwidthNoUrgentBurst = MaxTotalRDBandwidthNoUrgentBurst +\n\t\t\t\tdml_max3(locals->prefetch_vmrow_bw[k],\n\t\t\t\t\tlocals->ReadBandwidthPlaneLuma[k] + locals->ReadBandwidthPlaneChroma[k] + locals->cursor_bw[k]\n\t\t\t\t\t+ locals->meta_row_bw[k] + locals->dpte_row_bw[k],\n\t\t\t\t\tlocals->RequiredPrefetchPixDataBWLuma[k] + locals->RequiredPrefetchPixDataBWChroma[k] + locals->cursor_bw_pre[k]);\n\n\t\t\tif (locals->DestinationLinesForPrefetch[k] < 2)\n\t\t\t\tDestinationLineTimesForPrefetchLessThan2 = true;\n\t\t\tif (locals->VRatioPrefetchY[k] > 4 || locals->VRatioPrefetchC[k] > 4)\n\t\t\t\tVRatioPrefetchMoreThan4 = true;\n\t\t}\n\t\tmode_lib->vba.FractionOfUrgentBandwidth = MaxTotalRDBandwidthNoUrgentBurst / mode_lib->vba.ReturnBW;\n\n\t\tif (MaxTotalRDBandwidth <= mode_lib->vba.ReturnBW && locals->NotEnoughUrgentLatencyHiding[0][0] == 0 &&\n\t\t\t\tlocals->NotEnoughUrgentLatencyHidingPre == 0 && !VRatioPrefetchMoreThan4\n\t\t\t\t&& !DestinationLineTimesForPrefetchLessThan2)\n\t\t\tmode_lib->vba.PrefetchModeSupported = true;\n\t\telse {\n\t\t\tmode_lib->vba.PrefetchModeSupported = false;\n\t\t\tdml_print(\n\t\t\t\t\t\"DML: CalculatePrefetchSchedule ***failed***. Bandwidth violation. Results are NOT valid\\n\");\n\t\t}\n\n\t\tif (mode_lib->vba.PrefetchModeSupported == true) {\n\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip = mode_lib->vba.ReturnBW;\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip =\n\t\t\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t\t- dml_max(\n\t\t\t\t\t\t\t\tlocals->ReadBandwidthPlaneLuma[k] * locals->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t\t\t+ locals->ReadBandwidthPlaneChroma[k] * locals->UrgentBurstFactorChroma[k]\n\t\t\t\t\t\t\t\t+ locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t\t\tlocals->RequiredPrefetchPixDataBWLuma[k] * locals->UrgentBurstFactorLumaPre[k] +\n\t\t\t\t\t\t\t\tlocals->RequiredPrefetchPixDataBWChroma[k] * locals->UrgentBurstFactorChromaPre[k] +\n\t\t\t\t\t\t\t\tlocals->cursor_bw_pre[k] * locals->UrgentBurstFactorCursorPre[k]);\n\t\t\t}\n\n\t\t\tmode_lib->vba.TotImmediateFlipBytes = 0;\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tmode_lib->vba.TotImmediateFlipBytes = mode_lib->vba.TotImmediateFlipBytes + locals->PDEAndMetaPTEBytesFrame[k] + locals->MetaRowByte[k] + locals->PixelPTEBytesPerRow[k];\n\t\t\t}\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\tmode_lib->vba.UrgentExtraLatency,\n\t\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\t\tmode_lib->vba.GPUVMMaxPageTableLevels,\n\t\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\tlocals->PDEAndMetaPTEBytesFrame[k],\n\t\t\t\t\t\tlocals->MetaRowByte[k],\n\t\t\t\t\t\tlocals->PixelPTEBytesPerRow[k],\n\t\t\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip,\n\t\t\t\t\t\tmode_lib->vba.TotImmediateFlipBytes,\n\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\tlocals->Tno_bw[k],\n\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\tlocals->dpte_row_height[k],\n\t\t\t\t\t\tlocals->meta_row_height[k],\n\t\t\t\t\t\tlocals->dpte_row_height_chroma[k],\n\t\t\t\t\t\tlocals->meta_row_height_chroma[k],\n\t\t\t\t\t\t&locals->DestinationLinesToRequestVMInImmediateFlip[k],\n\t\t\t\t\t\t&locals->DestinationLinesToRequestRowInImmediateFlip[k],\n\t\t\t\t\t\t&locals->final_flip_bw[k],\n\t\t\t\t\t\t&locals->ImmediateFlipSupportedForPipe[k]);\n\t\t\t}\n\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip = 0.0;\n\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip_no_urgent_burst = 0.0;\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip =\n\t\t\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip + dml_max3(\n\t\t\t\t\t\t\tlocals->prefetch_vmrow_bw[k],\n\t\t\t\t\t\t\tlocals->final_flip_bw[k] + locals->ReadBandwidthLuma[k] * locals->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t\t+ locals->ReadBandwidthChroma[k] * locals->UrgentBurstFactorChroma[k] + locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t\tlocals->final_flip_bw[k] + locals->RequiredPrefetchPixDataBWLuma[k] * locals->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t+ locals->RequiredPrefetchPixDataBWChroma[k] * locals->UrgentBurstFactorChromaPre[k]\n\t\t\t\t\t\t\t+ locals->cursor_bw_pre[k] * locals->UrgentBurstFactorCursorPre[k]);\n\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip_no_urgent_burst =\n\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip_no_urgent_burst +\n\t\t\t\t\tdml_max3(locals->prefetch_vmrow_bw[k],\n\t\t\t\t\t\tlocals->final_flip_bw[k] + locals->ReadBandwidthPlaneLuma[k] + locals->ReadBandwidthPlaneChroma[k] + locals->cursor_bw[k],\n\t\t\t\t\t\tlocals->final_flip_bw[k] + locals->RequiredPrefetchPixDataBWLuma[k] + locals->RequiredPrefetchPixDataBWChroma[k] + locals->cursor_bw_pre[k]);\n\n\t\t\t}\n\t\t\tmode_lib->vba.FractionOfUrgentBandwidthImmediateFlip = mode_lib->vba.total_dcn_read_bw_with_flip_no_urgent_burst / mode_lib->vba.ReturnBW;\n\n\t\t\tmode_lib->vba.ImmediateFlipSupported = true;\n\t\t\tif (mode_lib->vba.total_dcn_read_bw_with_flip > mode_lib->vba.ReturnBW) {\n\t\t\t\tmode_lib->vba.ImmediateFlipSupported = false;\n\t\t\t}\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tif (locals->ImmediateFlipSupportedForPipe[k] == false) {\n\t\t\t\t\tmode_lib->vba.ImmediateFlipSupported = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmode_lib->vba.ImmediateFlipSupported = false;\n\t\t}\n\n\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\tif (mode_lib->vba.ErrorResult[k]) {\n\t\t\t\tmode_lib->vba.PrefetchModeSupported = false;\n\t\t\t\tdml_print(\n\t\t\t\t\t\t\"DML: CalculatePrefetchSchedule ***failed***. Prefetch schedule violation. Results are NOT valid\\n\");\n\t\t\t}\n\t\t}\n\n\t\tmode_lib->vba.VStartupLines = mode_lib->vba.VStartupLines + 1;\n\t} while (!((mode_lib->vba.PrefetchModeSupported\n\t\t\t&& ((!mode_lib->vba.ImmediateFlipSupport && !mode_lib->vba.HostVMEnable)\n\t\t\t\t\t|| mode_lib->vba.ImmediateFlipSupported))\n\t\t\t|| locals->MaximumMaxVStartupLines < mode_lib->vba.VStartupLines));\n\n\t\n\t{\n\t\tenum clock_change_support DRAMClockChangeSupport; \n\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\t\tmode_lib,\n\t\t\t\tmode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb],\n\t\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\t\tmode_lib->vba.MaxLineBufferLines,\n\t\t\t\tmode_lib->vba.LineBufferSize,\n\t\t\t\tmode_lib->vba.DPPOutputBufferPixels,\n\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\t\tmode_lib->vba.WritebackInterfaceLumaBufferSize,\n\t\t\t\tmode_lib->vba.WritebackInterfaceChromaBufferSize,\n\t\t\t\tmode_lib->vba.DCFCLK,\n\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannel * mode_lib->vba.NumberOfChannels,\n\t\t\t\tmode_lib->vba.ReturnBW,\n\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\tlocals->dpte_group_bytes,\n\t\t\t\tmode_lib->vba.MetaChunkSize,\n\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\tmode_lib->vba.UrgentExtraLatency,\n\t\t\t\tmode_lib->vba.WritebackLatency,\n\t\t\t\tmode_lib->vba.WritebackChunkSize,\n\t\t\t\tmode_lib->vba.SOCCLK,\n\t\t\t\tmode_lib->vba.DRAMClockChangeLatency,\n\t\t\t\tmode_lib->vba.SRExitTime,\n\t\t\t\tmode_lib->vba.SREnterPlusExitTime,\n\t\t\t\tmode_lib->vba.DCFCLKDeepSleep,\n\t\t\t\tmode_lib->vba.DPPPerPlane,\n\t\t\t\tmode_lib->vba.DCCEnable,\n\t\t\t\tlocals->DPPCLK,\n\t\t\t\tlocals->SwathWidthSingleDPPY,\n\t\t\t\tmode_lib->vba.SwathHeightY,\n\t\t\t\tlocals->ReadBandwidthPlaneLuma,\n\t\t\t\tmode_lib->vba.SwathHeightC,\n\t\t\t\tlocals->ReadBandwidthPlaneChroma,\n\t\t\t\tmode_lib->vba.LBBitPerPixel,\n\t\t\t\tlocals->SwathWidthY,\n\t\t\t\tmode_lib->vba.HRatio,\n\t\t\t\tmode_lib->vba.vtaps,\n\t\t\t\tmode_lib->vba.VTAPsChroma,\n\t\t\t\tmode_lib->vba.VRatio,\n\t\t\t\tmode_lib->vba.HTotal,\n\t\t\t\tmode_lib->vba.PixelClock,\n\t\t\t\tmode_lib->vba.BlendingAndTiming,\n\t\t\t\tlocals->BytePerPixelDETY,\n\t\t\t\tlocals->BytePerPixelDETC,\n\t\t\t\tmode_lib->vba.WritebackEnable,\n\t\t\t\tmode_lib->vba.WritebackPixelFormat,\n\t\t\t\tmode_lib->vba.WritebackDestinationWidth,\n\t\t\t\tmode_lib->vba.WritebackDestinationHeight,\n\t\t\t\tmode_lib->vba.WritebackSourceHeight,\n\t\t\t\t&DRAMClockChangeSupport,\n\t\t\t\t&mode_lib->vba.UrgentWatermark,\n\t\t\t\t&mode_lib->vba.WritebackUrgentWatermark,\n\t\t\t\t&mode_lib->vba.DRAMClockChangeWatermark,\n\t\t\t\t&mode_lib->vba.WritebackDRAMClockChangeWatermark,\n\t\t\t\t&mode_lib->vba.StutterExitWatermark,\n\t\t\t\t&mode_lib->vba.StutterEnterPlusExitWatermark,\n\t\t\t\t&mode_lib->vba.MinActiveDRAMClockChangeLatencySupported);\n\t}\n\n\n\t\n\tCalculatePixelDeliveryTimes(\n\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\tmode_lib->vba.VRatio,\n\t\tlocals->VRatioPrefetchY,\n\t\tlocals->VRatioPrefetchC,\n\t\tlocals->swath_width_luma_ub,\n\t\tlocals->swath_width_chroma_ub,\n\t\tmode_lib->vba.DPPPerPlane,\n\t\tmode_lib->vba.HRatio,\n\t\tmode_lib->vba.PixelClock,\n\t\tlocals->PSCL_THROUGHPUT_LUMA,\n\t\tlocals->PSCL_THROUGHPUT_CHROMA,\n\t\tlocals->DPPCLK,\n\t\tlocals->BytePerPixelDETC,\n\t\tmode_lib->vba.SourceScan,\n\t\tlocals->BlockWidth256BytesY,\n\t\tlocals->BlockHeight256BytesY,\n\t\tlocals->BlockWidth256BytesC,\n\t\tlocals->BlockHeight256BytesC,\n\t\tlocals->DisplayPipeLineDeliveryTimeLuma,\n\t\tlocals->DisplayPipeLineDeliveryTimeChroma,\n\t\tlocals->DisplayPipeLineDeliveryTimeLumaPrefetch,\n\t\tlocals->DisplayPipeLineDeliveryTimeChromaPrefetch,\n\t\tlocals->DisplayPipeRequestDeliveryTimeLuma,\n\t\tlocals->DisplayPipeRequestDeliveryTimeChroma,\n\t\tlocals->DisplayPipeRequestDeliveryTimeLumaPrefetch,\n\t\tlocals->DisplayPipeRequestDeliveryTimeChromaPrefetch);\n\n\tCalculateMetaAndPTETimes(\n\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\tmode_lib->vba.GPUVMEnable,\n\t\tmode_lib->vba.MetaChunkSize,\n\t\tmode_lib->vba.MinMetaChunkSizeBytes,\n\t\tmode_lib->vba.GPUVMMaxPageTableLevels,\n\t\tmode_lib->vba.HTotal,\n\t\tmode_lib->vba.VRatio,\n\t\tlocals->VRatioPrefetchY,\n\t\tlocals->VRatioPrefetchC,\n\t\tlocals->DestinationLinesToRequestRowInVBlank,\n\t\tlocals->DestinationLinesToRequestRowInImmediateFlip,\n\t\tlocals->DestinationLinesToRequestVMInVBlank,\n\t\tlocals->DestinationLinesToRequestVMInImmediateFlip,\n\t\tmode_lib->vba.DCCEnable,\n\t\tmode_lib->vba.PixelClock,\n\t\tlocals->BytePerPixelDETY,\n\t\tlocals->BytePerPixelDETC,\n\t\tmode_lib->vba.SourceScan,\n\t\tlocals->dpte_row_height,\n\t\tlocals->dpte_row_height_chroma,\n\t\tlocals->meta_row_width,\n\t\tlocals->meta_row_height,\n\t\tlocals->meta_req_width,\n\t\tlocals->meta_req_height,\n\t\tlocals->dpte_group_bytes,\n\t\tlocals->PTERequestSizeY,\n\t\tlocals->PTERequestSizeC,\n\t\tlocals->PixelPTEReqWidthY,\n\t\tlocals->PixelPTEReqHeightY,\n\t\tlocals->PixelPTEReqWidthC,\n\t\tlocals->PixelPTEReqHeightC,\n\t\tlocals->dpte_row_width_luma_ub,\n\t\tlocals->dpte_row_width_chroma_ub,\n\t\tlocals->vm_group_bytes,\n\t\tlocals->dpde0_bytes_per_frame_ub_l,\n\t\tlocals->dpde0_bytes_per_frame_ub_c,\n\t\tlocals->meta_pte_bytes_per_frame_ub_l,\n\t\tlocals->meta_pte_bytes_per_frame_ub_c,\n\t\tlocals->DST_Y_PER_PTE_ROW_NOM_L,\n\t\tlocals->DST_Y_PER_PTE_ROW_NOM_C,\n\t\tlocals->DST_Y_PER_META_ROW_NOM_L,\n\t\tlocals->TimePerMetaChunkNominal,\n\t\tlocals->TimePerMetaChunkVBlank,\n\t\tlocals->TimePerMetaChunkFlip,\n\t\tlocals->time_per_pte_group_nom_luma,\n\t\tlocals->time_per_pte_group_vblank_luma,\n\t\tlocals->time_per_pte_group_flip_luma,\n\t\tlocals->time_per_pte_group_nom_chroma,\n\t\tlocals->time_per_pte_group_vblank_chroma,\n\t\tlocals->time_per_pte_group_flip_chroma,\n\t\tlocals->TimePerVMGroupVBlank,\n\t\tlocals->TimePerVMGroupFlip,\n\t\tlocals->TimePerVMRequestVBlank,\n\t\tlocals->TimePerVMRequestFlip);\n\n\n\t\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb] == 0) {\n\t\t\tlocals->AllowDRAMClockChangeDuringVBlank[k] = true;\n\t\t\tlocals->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tlocals->MinTTUVBlank[k] = dml_max(\n\t\t\t\t\tmode_lib->vba.DRAMClockChangeWatermark,\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.StutterEnterPlusExitWatermark,\n\t\t\t\t\t\t\tmode_lib->vba.UrgentWatermark));\n\t\t} else if (mode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb] == 1) {\n\t\t\tlocals->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tlocals->AllowDRAMSelfRefreshDuringVBlank[k] = true;\n\t\t\tlocals->MinTTUVBlank[k] = dml_max(\n\t\t\t\t\tmode_lib->vba.StutterEnterPlusExitWatermark,\n\t\t\t\t\tmode_lib->vba.UrgentWatermark);\n\t\t} else {\n\t\t\tlocals->AllowDRAMClockChangeDuringVBlank[k] = false;\n\t\t\tlocals->AllowDRAMSelfRefreshDuringVBlank[k] = false;\n\t\t\tlocals->MinTTUVBlank[k] = mode_lib->vba.UrgentWatermark;\n\t\t}\n\t\tif (!mode_lib->vba.DynamicMetadataEnable[k])\n\t\t\tlocals->MinTTUVBlank[k] = mode_lib->vba.TCalc\n\t\t\t\t\t+ locals->MinTTUVBlank[k];\n\t}\n\n\t\n\tmode_lib->vba.ActiveDPPs = 0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tlocals->MaximumDCCCompressionYSurface[k] = CalculateDCCConfiguration(\n\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\tfalse, \n\t\t\tmode_lib->vba.ViewportWidth[k],\n\t\t\tmode_lib->vba.ViewportHeight[k],\n\t\t\tmode_lib->vba.DETBufferSizeInKByte[0] * 1024,\n\t\t\tlocals->BlockHeight256BytesY[k],\n\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\tlocals->BytePerPixelDETY[k],\n\t\t\tmode_lib->vba.SourceScan[k],\n\t\t\t&locals->DCCYMaxUncompressedBlock[k],\n\t\t\t&locals->DCCYMaxCompressedBlock[k],\n\t\t\t&locals->DCCYIndependent64ByteBlock[k]);\n\t}\n\n\t\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.XFCEnabled[k] == true) {\n\t\t\tdouble TWait;\n\n\t\t\tlocals->XFCSlaveVUpdateOffset[k] = mode_lib->vba.XFCTSlvVupdateOffset;\n\t\t\tlocals->XFCSlaveVupdateWidth[k] = mode_lib->vba.XFCTSlvVupdateWidth;\n\t\t\tlocals->XFCSlaveVReadyOffset[k] = mode_lib->vba.XFCTSlvVreadyOffset;\n\t\t\tTWait = CalculateTWait(\n\t\t\t\t\tmode_lib->vba.PrefetchMode[mode_lib->vba.VoltageLevel][mode_lib->vba.maxMpcComb],\n\t\t\t\t\tmode_lib->vba.DRAMClockChangeLatency,\n\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\tmode_lib->vba.SREnterPlusExitTime);\n\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay = CalculateRemoteSurfaceFlipDelay(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\tlocals->SwathWidthY[k],\n\t\t\t\t\tdml_ceil(locals->BytePerPixelDETY[k], 1),\n\t\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateOffset,\n\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateWidth,\n\t\t\t\t\tmode_lib->vba.XFCTSlvVreadyOffset,\n\t\t\t\t\tmode_lib->vba.XFCXBUFLatencyTolerance,\n\t\t\t\t\tmode_lib->vba.XFCFillBWOverhead,\n\t\t\t\t\tmode_lib->vba.XFCSlvChunkSize,\n\t\t\t\t\tmode_lib->vba.XFCBusTransportTime,\n\t\t\t\t\tmode_lib->vba.TCalc,\n\t\t\t\t\tTWait,\n\t\t\t\t\t&mode_lib->vba.SrcActiveDrainRate,\n\t\t\t\t\t&mode_lib->vba.TInitXFill,\n\t\t\t\t\t&mode_lib->vba.TslvChk);\n\t\t\tlocals->XFCRemoteSurfaceFlipLatency[k] =\n\t\t\t\t\tdml_floor(\n\t\t\t\t\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay\n\t\t\t\t\t\t\t\t\t/ (mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]),\n\t\t\t\t\t\t\t1);\n\t\t\tlocals->XFCTransferDelay[k] =\n\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\tmode_lib->vba.XFCBusTransportTime\n\t\t\t\t\t\t\t\t\t/ (mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]),\n\t\t\t\t\t\t\t1);\n\t\t\tlocals->XFCPrechargeDelay[k] =\n\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t(mode_lib->vba.XFCBusTransportTime\n\t\t\t\t\t\t\t\t\t+ mode_lib->vba.TInitXFill\n\t\t\t\t\t\t\t\t\t+ mode_lib->vba.TslvChk)\n\t\t\t\t\t\t\t\t\t/ (mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]),\n\t\t\t\t\t\t\t1);\n\t\t\tmode_lib->vba.InitFillLevel = mode_lib->vba.XFCXBUFLatencyTolerance\n\t\t\t\t\t* mode_lib->vba.SrcActiveDrainRate;\n\t\t\tmode_lib->vba.FinalFillMargin =\n\t\t\t\t\t(locals->DestinationLinesToRequestVMInVBlank[k]\n\t\t\t\t\t\t\t+ locals->DestinationLinesToRequestRowInVBlank[k])\n\t\t\t\t\t\t\t* mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* mode_lib->vba.SrcActiveDrainRate\n\t\t\t\t\t\t\t+ mode_lib->vba.XFCFillConstant;\n\t\t\tmode_lib->vba.FinalFillLevel = mode_lib->vba.XFCRemoteSurfaceFlipDelay\n\t\t\t\t\t* mode_lib->vba.SrcActiveDrainRate\n\t\t\t\t\t+ mode_lib->vba.FinalFillMargin;\n\t\t\tmode_lib->vba.RemainingFillLevel = dml_max(\n\t\t\t\t\t0.0,\n\t\t\t\t\tmode_lib->vba.FinalFillLevel - mode_lib->vba.InitFillLevel);\n\t\t\tmode_lib->vba.TFinalxFill = mode_lib->vba.RemainingFillLevel\n\t\t\t\t\t/ (mode_lib->vba.SrcActiveDrainRate\n\t\t\t\t\t\t\t* mode_lib->vba.XFCFillBWOverhead / 100);\n\t\t\tlocals->XFCPrefetchMargin[k] =\n\t\t\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay\n\t\t\t\t\t\t\t+ mode_lib->vba.TFinalxFill\n\t\t\t\t\t\t\t+ (locals->DestinationLinesToRequestVMInVBlank[k]\n\t\t\t\t\t\t\t\t\t+ locals->DestinationLinesToRequestRowInVBlank[k])\n\t\t\t\t\t\t\t\t\t* mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k];\n\t\t} else {\n\t\t\tlocals->XFCSlaveVUpdateOffset[k] = 0;\n\t\t\tlocals->XFCSlaveVupdateWidth[k] = 0;\n\t\t\tlocals->XFCSlaveVReadyOffset[k] = 0;\n\t\t\tlocals->XFCRemoteSurfaceFlipLatency[k] = 0;\n\t\t\tlocals->XFCPrechargeDelay[k] = 0;\n\t\t\tlocals->XFCTransferDelay[k] = 0;\n\t\t\tlocals->XFCPrefetchMargin[k] = 0;\n\t\t}\n\t}\n\n\t\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tCalculateDETBufferSize(\n\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\tmode_lib->vba.SwathHeightC[k],\n\t\t\t&locals->DETBufferSizeY[k],\n\t\t\t&locals->DETBufferSizeC[k]);\n\n\t\tlocals->LinesInDETY[k] = (double)locals->DETBufferSizeY[k]\n\t\t\t\t/ locals->BytePerPixelDETY[k] / locals->SwathWidthY[k];\n\t\tlocals->LinesInDETYRoundedDownToSwath[k] = dml_floor(\n\t\t\t\tlocals->LinesInDETY[k],\n\t\t\t\tmode_lib->vba.SwathHeightY[k]);\n\t\tlocals->FullDETBufferingTimeY[k] =\n\t\t\t\tlocals->LinesInDETYRoundedDownToSwath[k]\n\t\t\t\t\t\t* (mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k])\n\t\t\t\t\t\t/ mode_lib->vba.VRatio[k];\n\t}\n\n\tmode_lib->vba.StutterPeriod = 999999.0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (locals->FullDETBufferingTimeY[k] < mode_lib->vba.StutterPeriod) {\n\t\t\tmode_lib->vba.StutterPeriod = locals->FullDETBufferingTimeY[k];\n\t\t\tmode_lib->vba.FrameTimeForMinFullDETBufferingTime =\n\t\t\t\t(double) mode_lib->vba.VTotal[k] * mode_lib->vba.HTotal[k]\n\t\t\t\t/ mode_lib->vba.PixelClock[k];\n\t\t\tlocals->BytePerPixelYCriticalPlane = dml_ceil(locals->BytePerPixelDETY[k], 1);\n\t\t\tlocals->SwathWidthYCriticalPlane = locals->SwathWidthY[k];\n\t\t\tlocals->LinesToFinishSwathTransferStutterCriticalPlane =\n\t\t\t\tmode_lib->vba.SwathHeightY[k] - (locals->LinesInDETY[k] - locals->LinesInDETYRoundedDownToSwath[k]);\n\t\t}\n\t}\n\n\tmode_lib->vba.AverageReadBandwidth = 0.0;\n\tmode_lib->vba.TotalRowReadBandwidth = 0.0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tunsigned int DCCRateLimit;\n\n\t\tif (mode_lib->vba.DCCEnable[k]) {\n\t\t\tif (locals->DCCYMaxCompressedBlock[k] == 256)\n\t\t\t\tDCCRateLimit = 4;\n\t\t\telse\n\t\t\t\tDCCRateLimit = 2;\n\n\t\t\tmode_lib->vba.AverageReadBandwidth =\n\t\t\t\t\tmode_lib->vba.AverageReadBandwidth\n\t\t\t\t\t\t\t+ (locals->ReadBandwidthPlaneLuma[k] + locals->ReadBandwidthPlaneChroma[k]) /\n\t\t\t\t\t\t\t\tdml_min(mode_lib->vba.DCCRate[k], DCCRateLimit);\n\t\t} else {\n\t\t\tmode_lib->vba.AverageReadBandwidth =\n\t\t\t\t\tmode_lib->vba.AverageReadBandwidth\n\t\t\t\t\t\t\t+ locals->ReadBandwidthPlaneLuma[k]\n\t\t\t\t\t\t\t+ locals->ReadBandwidthPlaneChroma[k];\n\t\t}\n\t\tmode_lib->vba.TotalRowReadBandwidth = mode_lib->vba.TotalRowReadBandwidth +\n\t\tlocals->meta_row_bw[k] + locals->dpte_row_bw[k];\n\t}\n\n\tmode_lib->vba.AverageDCCCompressionRate = mode_lib->vba.TotalDataReadBandwidth / mode_lib->vba.AverageReadBandwidth;\n\n\tmode_lib->vba.PartOfBurstThatFitsInROB =\n\t\t\tdml_min(\n\t\t\t\t\tmode_lib->vba.StutterPeriod\n\t\t\t\t\t\t\t* mode_lib->vba.TotalDataReadBandwidth,\n\t\t\t\t\tmode_lib->vba.ROBBufferSizeInKByte * 1024\n\t\t\t\t\t\t\t* mode_lib->vba.AverageDCCCompressionRate);\n\tmode_lib->vba.StutterBurstTime = mode_lib->vba.PartOfBurstThatFitsInROB\n\t\t\t/ mode_lib->vba.AverageDCCCompressionRate / mode_lib->vba.ReturnBW\n\t\t\t+ (mode_lib->vba.StutterPeriod * mode_lib->vba.TotalDataReadBandwidth\n\t\t\t\t\t- mode_lib->vba.PartOfBurstThatFitsInROB)\n\t\t\t\t\t/ (mode_lib->vba.DCFCLK * 64)\n\t\t\t\t\t+ mode_lib->vba.StutterPeriod * mode_lib->vba.TotalRowReadBandwidth / mode_lib->vba.ReturnBW;\n\tmode_lib->vba.StutterBurstTime = dml_max(\n\t\tmode_lib->vba.StutterBurstTime,\n\t\t(locals->LinesToFinishSwathTransferStutterCriticalPlane * locals->BytePerPixelYCriticalPlane *\n\t\tlocals->SwathWidthYCriticalPlane / mode_lib->vba.ReturnBW)\n\t);\n\n\tmode_lib->vba.TotalActiveWriteback = 0;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tmode_lib->vba.TotalActiveWriteback = mode_lib->vba.TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (mode_lib->vba.TotalActiveWriteback == 0) {\n\t\tmode_lib->vba.StutterEfficiencyNotIncludingVBlank = (1\n\t\t\t\t- (mode_lib->vba.SRExitTime + mode_lib->vba.StutterBurstTime)\n\t\t\t\t\t\t/ mode_lib->vba.StutterPeriod) * 100;\n\t} else {\n\t\tmode_lib->vba.StutterEfficiencyNotIncludingVBlank = 0;\n\t}\n\n\tmode_lib->vba.SmallestVBlank = 999999;\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.SynchronizedVBlank || mode_lib->vba.NumberOfActivePlanes == 1) {\n\t\t\tmode_lib->vba.VBlankTime = (double) (mode_lib->vba.VTotal[k]\n\t\t\t\t\t- mode_lib->vba.VActive[k]) * mode_lib->vba.HTotal[k]\n\t\t\t\t\t/ mode_lib->vba.PixelClock[k];\n\t\t} else {\n\t\t\tmode_lib->vba.VBlankTime = 0;\n\t\t}\n\t\tmode_lib->vba.SmallestVBlank = dml_min(\n\t\t\t\tmode_lib->vba.SmallestVBlank,\n\t\t\t\tmode_lib->vba.VBlankTime);\n\t}\n\n\tmode_lib->vba.StutterEfficiency = (mode_lib->vba.StutterEfficiencyNotIncludingVBlank / 100\n\t\t\t* (mode_lib->vba.FrameTimeForMinFullDETBufferingTime\n\t\t\t\t\t- mode_lib->vba.SmallestVBlank)\n\t\t\t+ mode_lib->vba.SmallestVBlank)\n\t\t\t/ mode_lib->vba.FrameTimeForMinFullDETBufferingTime * 100;\n}\n\nstatic void DisplayPipeConfiguration(struct display_mode_lib *mode_lib)\n{\n\t\n\tdouble BytePerPixDETY;\n\tdouble BytePerPixDETC;\n\tdouble Read256BytesBlockHeightY;\n\tdouble Read256BytesBlockHeightC;\n\tdouble Read256BytesBlockWidthY;\n\tdouble Read256BytesBlockWidthC;\n\tdouble MaximumSwathHeightY;\n\tdouble MaximumSwathHeightC;\n\tdouble MinimumSwathHeightY;\n\tdouble MinimumSwathHeightC;\n\tdouble SwathWidth;\n\tdouble SwathWidthGranularityY;\n\tdouble SwathWidthGranularityC;\n\tdouble RoundedUpMaxSwathSizeBytesY;\n\tdouble RoundedUpMaxSwathSizeBytesC;\n\tunsigned int j, k;\n\n\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\tbool MainPlaneDoesODMCombine = false;\n\n\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {\n\t\t\tBytePerPixDETY = 8;\n\t\t\tBytePerPixDETC = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {\n\t\t\tBytePerPixDETY = 4;\n\t\t\tBytePerPixDETC = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16) {\n\t\t\tBytePerPixDETY = 2;\n\t\t\tBytePerPixDETC = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8) {\n\t\t\tBytePerPixDETY = 1;\n\t\t\tBytePerPixDETC = 0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {\n\t\t\tBytePerPixDETY = 1;\n\t\t\tBytePerPixDETC = 2;\n\t\t} else {\n\t\t\tBytePerPixDETY = 4.0 / 3.0;\n\t\t\tBytePerPixDETC = 8.0 / 3.0;\n\t\t}\n\n\t\tif ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_32\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_16\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_8)) {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tRead256BytesBlockHeightY = 1;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {\n\t\t\t\tRead256BytesBlockHeightY = 4;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32\n\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_16) {\n\t\t\t\tRead256BytesBlockHeightY = 8;\n\t\t\t} else {\n\t\t\t\tRead256BytesBlockHeightY = 16;\n\t\t\t}\n\t\t\tRead256BytesBlockWidthY = 256 / dml_ceil(BytePerPixDETY, 1)\n\t\t\t\t\t/ Read256BytesBlockHeightY;\n\t\t\tRead256BytesBlockHeightC = 0;\n\t\t\tRead256BytesBlockWidthC = 0;\n\t\t} else {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tRead256BytesBlockHeightY = 1;\n\t\t\t\tRead256BytesBlockHeightC = 1;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {\n\t\t\t\tRead256BytesBlockHeightY = 16;\n\t\t\t\tRead256BytesBlockHeightC = 8;\n\t\t\t} else {\n\t\t\t\tRead256BytesBlockHeightY = 8;\n\t\t\t\tRead256BytesBlockHeightC = 8;\n\t\t\t}\n\t\t\tRead256BytesBlockWidthY = 256 / dml_ceil(BytePerPixDETY, 1)\n\t\t\t\t\t/ Read256BytesBlockHeightY;\n\t\t\tRead256BytesBlockWidthC = 256 / dml_ceil(BytePerPixDETC, 2)\n\t\t\t\t\t/ Read256BytesBlockHeightC;\n\t\t}\n\n\t\tif (mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\tMaximumSwathHeightY = Read256BytesBlockHeightY;\n\t\t\tMaximumSwathHeightC = Read256BytesBlockHeightC;\n\t\t} else {\n\t\t\tMaximumSwathHeightY = Read256BytesBlockWidthY;\n\t\t\tMaximumSwathHeightC = Read256BytesBlockWidthC;\n\t\t}\n\n\t\tif ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_32\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_16\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_8)) {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear\n\t\t\t\t\t|| (mode_lib->vba.SourcePixelFormat[k] == dm_444_64\n\t\t\t\t\t\t\t&& (mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t== dm_sw_4kb_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_4kb_s_x\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s_t\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s_x\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_s_x)\n\t\t\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz)) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_8\n\t\t\t\t\t&& mode_lib->vba.SourceScan[k] != dm_horz) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY;\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY / 2.0;\n\t\t\t}\n\t\t\tMinimumSwathHeightC = MaximumSwathHeightC;\n\t\t} else {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8\n\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY / 2.0;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC;\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10\n\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC / 2.0;\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY;\n\t\t\t} else {\n\t\t\t\tMinimumSwathHeightY = MaximumSwathHeightY;\n\t\t\t\tMinimumSwathHeightC = MaximumSwathHeightC;\n\t\t\t}\n\t\t}\n\n\t\tif (mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\tSwathWidth = mode_lib->vba.ViewportWidth[k];\n\t\t} else {\n\t\t\tSwathWidth = mode_lib->vba.ViewportHeight[k];\n\t\t}\n\n\t\tif (mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\tMainPlaneDoesODMCombine = true;\n\t\t}\n\t\tfor (j = 0; j < mode_lib->vba.NumberOfActivePlanes; ++j) {\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == j\n\t\t\t\t\t&& mode_lib->vba.ODMCombineEnabled[k] == dm_odm_combine_mode_2to1) {\n\t\t\t\tMainPlaneDoesODMCombine = true;\n\t\t\t}\n\t\t}\n\n\t\tif (MainPlaneDoesODMCombine == true) {\n\t\t\tSwathWidth = dml_min(\n\t\t\t\t\tSwathWidth,\n\t\t\t\t\tmode_lib->vba.HActive[k] / 2.0 * mode_lib->vba.HRatio[k]);\n\t\t} else {\n\t\t\tSwathWidth = SwathWidth / mode_lib->vba.DPPPerPlane[k];\n\t\t}\n\n\t\tSwathWidthGranularityY = 256 / dml_ceil(BytePerPixDETY, 1) / MaximumSwathHeightY;\n\t\tRoundedUpMaxSwathSizeBytesY = (dml_ceil(\n\t\t\t\t(double) (SwathWidth - 1),\n\t\t\t\tSwathWidthGranularityY) + SwathWidthGranularityY) * BytePerPixDETY\n\t\t\t\t* MaximumSwathHeightY;\n\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {\n\t\t\tRoundedUpMaxSwathSizeBytesY = dml_ceil(RoundedUpMaxSwathSizeBytesY, 256)\n\t\t\t\t\t+ 256;\n\t\t}\n\t\tif (MaximumSwathHeightC > 0) {\n\t\t\tSwathWidthGranularityC = 256.0 / dml_ceil(BytePerPixDETC, 2)\n\t\t\t\t\t/ MaximumSwathHeightC;\n\t\t\tRoundedUpMaxSwathSizeBytesC = (dml_ceil(\n\t\t\t\t\t(double) (SwathWidth / 2.0 - 1),\n\t\t\t\t\tSwathWidthGranularityC) + SwathWidthGranularityC)\n\t\t\t\t\t* BytePerPixDETC * MaximumSwathHeightC;\n\t\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {\n\t\t\t\tRoundedUpMaxSwathSizeBytesC = dml_ceil(\n\t\t\t\t\t\tRoundedUpMaxSwathSizeBytesC,\n\t\t\t\t\t\t256) + 256;\n\t\t\t}\n\t\t} else\n\t\t\tRoundedUpMaxSwathSizeBytesC = 0.0;\n\n\t\tif (RoundedUpMaxSwathSizeBytesY + RoundedUpMaxSwathSizeBytesC\n\t\t\t\t<= mode_lib->vba.DETBufferSizeInKByte[0] * 1024.0 / 2.0) {\n\t\t\tmode_lib->vba.SwathHeightY[k] = MaximumSwathHeightY;\n\t\t\tmode_lib->vba.SwathHeightC[k] = MaximumSwathHeightC;\n\t\t} else {\n\t\t\tmode_lib->vba.SwathHeightY[k] = MinimumSwathHeightY;\n\t\t\tmode_lib->vba.SwathHeightC[k] = MinimumSwathHeightC;\n\t\t}\n\n\t\tCalculateDETBufferSize(\n\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\t\tmode_lib->vba.SwathHeightY[k],\n\t\t\t\tmode_lib->vba.SwathHeightC[k],\n\t\t\t\t&mode_lib->vba.DETBufferSizeY[k],\n\t\t\t\t&mode_lib->vba.DETBufferSizeC[k]);\n\t}\n}\n\nstatic double CalculateTWait(\n\t\tunsigned int PrefetchMode,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble UrgentLatency,\n\t\tdouble SREnterPlusExitTime)\n{\n\tif (PrefetchMode == 0) {\n\t\treturn dml_max(\n\t\t\t\tDRAMClockChangeLatency + UrgentLatency,\n\t\t\t\tdml_max(SREnterPlusExitTime, UrgentLatency));\n\t} else if (PrefetchMode == 1) {\n\t\treturn dml_max(SREnterPlusExitTime, UrgentLatency);\n\t} else {\n\t\treturn UrgentLatency;\n\t}\n}\n\nstatic double CalculateRemoteSurfaceFlipDelay(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble VRatio,\n\t\tdouble SwathWidth,\n\t\tdouble Bpp,\n\t\tdouble LineTime,\n\t\tdouble XFCTSlvVupdateOffset,\n\t\tdouble XFCTSlvVupdateWidth,\n\t\tdouble XFCTSlvVreadyOffset,\n\t\tdouble XFCXBUFLatencyTolerance,\n\t\tdouble XFCFillBWOverhead,\n\t\tdouble XFCSlvChunkSize,\n\t\tdouble XFCBusTransportTime,\n\t\tdouble TCalc,\n\t\tdouble TWait,\n\t\tdouble *SrcActiveDrainRate,\n\t\tdouble *TInitXFill,\n\t\tdouble *TslvChk)\n{\n\tdouble TSlvSetup, AvgfillRate, result;\n\n\t*SrcActiveDrainRate = VRatio * SwathWidth * Bpp / LineTime;\n\tTSlvSetup = XFCTSlvVupdateOffset + XFCTSlvVupdateWidth + XFCTSlvVreadyOffset;\n\t*TInitXFill = XFCXBUFLatencyTolerance / (1 + XFCFillBWOverhead / 100);\n\tAvgfillRate = *SrcActiveDrainRate * (1 + XFCFillBWOverhead / 100);\n\t*TslvChk = XFCSlvChunkSize / AvgfillRate;\n\tdml_print(\n\t\t\t\"DML::CalculateRemoteSurfaceFlipDelay: SrcActiveDrainRate: %f\\n\",\n\t\t\t*SrcActiveDrainRate);\n\tdml_print(\"DML::CalculateRemoteSurfaceFlipDelay: TSlvSetup: %f\\n\", TSlvSetup);\n\tdml_print(\"DML::CalculateRemoteSurfaceFlipDelay: TInitXFill: %f\\n\", *TInitXFill);\n\tdml_print(\"DML::CalculateRemoteSurfaceFlipDelay: AvgfillRate: %f\\n\", AvgfillRate);\n\tdml_print(\"DML::CalculateRemoteSurfaceFlipDelay: TslvChk: %f\\n\", *TslvChk);\n\tresult = 2 * XFCBusTransportTime + TSlvSetup + TCalc + TWait + *TslvChk + *TInitXFill; \n\tdml_print(\"DML::CalculateRemoteSurfaceFlipDelay: RemoteSurfaceFlipDelay: %f\\n\", result);\n\treturn result;\n}\n\nstatic double CalculateWriteBackDelay(\n\t\tenum source_format_class WritebackPixelFormat,\n\t\tdouble WritebackHRatio,\n\t\tdouble WritebackVRatio,\n\t\tunsigned int WritebackLumaHTaps,\n\t\tunsigned int WritebackLumaVTaps,\n\t\tunsigned int WritebackChromaHTaps,\n\t\tunsigned int WritebackChromaVTaps,\n\t\tunsigned int WritebackDestinationWidth)\n{\n\tdouble CalculateWriteBackDelay =\n\t\t\tdml_max(\n\t\t\t\t\tdml_ceil(WritebackLumaHTaps / 4.0, 1) / WritebackHRatio,\n\t\t\t\t\tWritebackLumaVTaps * dml_ceil(1.0 / WritebackVRatio, 1)\n\t\t\t\t\t\t\t* dml_ceil(\n\t\t\t\t\t\t\t\t\tWritebackDestinationWidth\n\t\t\t\t\t\t\t\t\t\t\t/ 4.0,\n\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t+ dml_ceil(1.0 / WritebackVRatio, 1)\n\t\t\t\t\t\t\t\t\t* (dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\tWritebackLumaVTaps\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 4.0,\n\t\t\t\t\t\t\t\t\t\t\t1) + 4));\n\n\tif (WritebackPixelFormat != dm_444_32) {\n\t\tCalculateWriteBackDelay =\n\t\t\t\tdml_max(\n\t\t\t\t\t\tCalculateWriteBackDelay,\n\t\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\tWritebackChromaHTaps\n\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0,\n\t\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t\t\t\t/ (2\n\t\t\t\t\t\t\t\t\t\t\t\t* WritebackHRatio),\n\t\t\t\t\t\t\t\tWritebackChromaVTaps\n\t\t\t\t\t\t\t\t\t\t* dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ (2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* WritebackVRatio),\n\t\t\t\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t\t\t\t* dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tWritebackDestinationWidth\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0,\n\t\t\t\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t\t\t\t+ dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ (2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* WritebackVRatio),\n\t\t\t\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t\t\t\t\t\t* (dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tWritebackChromaVTaps\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 4.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ 4)));\n\t}\n\treturn CalculateWriteBackDelay;\n}\n\nstatic void CalculateActiveRowBandwidth(\n\t\tbool GPUVMEnable,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble VRatio,\n\t\tbool DCCEnable,\n\t\tdouble LineTime,\n\t\tunsigned int MetaRowByteLuma,\n\t\tunsigned int MetaRowByteChroma,\n\t\tunsigned int meta_row_height_luma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tunsigned int PixelPTEBytesPerRowLuma,\n\t\tunsigned int PixelPTEBytesPerRowChroma,\n\t\tunsigned int dpte_row_height_luma,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tdouble *meta_row_bw,\n\t\tdouble *dpte_row_bw)\n{\n\tif (DCCEnable != true) {\n\t\t*meta_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime)\n\t\t\t\t+ VRatio / 2 * MetaRowByteChroma\n\t\t\t\t\t\t/ (meta_row_height_chroma * LineTime);\n\t} else {\n\t\t*meta_row_bw = VRatio * MetaRowByteLuma / (meta_row_height_luma * LineTime);\n\t}\n\n\tif (GPUVMEnable != true) {\n\t\t*dpte_row_bw = 0;\n\t} else if (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime)\n\t\t\t\t+ VRatio / 2 * PixelPTEBytesPerRowChroma\n\t\t\t\t\t\t/ (dpte_row_height_chroma * LineTime);\n\t} else {\n\t\t*dpte_row_bw = VRatio * PixelPTEBytesPerRowLuma / (dpte_row_height_luma * LineTime);\n\t}\n}\n\nstatic void CalculateFlipSchedule(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tdouble UrgentExtraLatency,\n\t\tdouble UrgentLatency,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tbool HostVMEnable,\n\t\tunsigned int HostVMMaxPageTableLevels,\n\t\tunsigned int HostVMCachedPageTableLevels,\n\t\tbool GPUVMEnable,\n\t\tdouble PDEAndMetaPTEBytesPerFrame,\n\t\tdouble MetaRowBytes,\n\t\tdouble DPTEBytesPerRow,\n\t\tdouble BandwidthAvailableForImmediateFlip,\n\t\tunsigned int TotImmediateFlipBytes,\n\t\tenum source_format_class SourcePixelFormat,\n\t\tdouble LineTime,\n\t\tdouble VRatio,\n\t\tdouble Tno_bw,\n\t\tbool DCCEnable,\n\t\tunsigned int dpte_row_height,\n\t\tunsigned int meta_row_height,\n\t\tunsigned int dpte_row_height_chroma,\n\t\tunsigned int meta_row_height_chroma,\n\t\tdouble *DestinationLinesToRequestVMInImmediateFlip,\n\t\tdouble *DestinationLinesToRequestRowInImmediateFlip,\n\t\tdouble *final_flip_bw,\n\t\tbool *ImmediateFlipSupportedForPipe)\n{\n\tdouble min_row_time = 0.0;\n\tunsigned int HostVMDynamicLevels;\n\tdouble TimeForFetchingMetaPTEImmediateFlip;\n\tdouble TimeForFetchingRowInVBlankImmediateFlip;\n\tdouble ImmediateFlipBW = 1.0;\n\tdouble HostVMInefficiencyFactor;\n\tdouble VRatioClamped;\n\n\tif (GPUVMEnable == true && HostVMEnable == true) {\n\t\tHostVMInefficiencyFactor =\n\t\t\t\tPercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData\n\t\t\t\t\t\t/ PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tHostVMDynamicLevels = HostVMMaxPageTableLevels - HostVMCachedPageTableLevels;\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tImmediateFlipBW = (PDEAndMetaPTEBytesPerFrame + MetaRowBytes + DPTEBytesPerRow)\n\t\t\t* BandwidthAvailableForImmediateFlip / TotImmediateFlipBytes;\n\n\tif (GPUVMEnable == true) {\n\t\tTimeForFetchingMetaPTEImmediateFlip = dml_max3(\n\t\t\tTno_bw + PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / ImmediateFlipBW,\n\t\t\tUrgentExtraLatency + UrgentLatency * (GPUVMMaxPageTableLevels * (HostVMDynamicLevels + 1) - 1),\n\t\t\tLineTime / 4.0);\n\t} else {\n\t\tTimeForFetchingMetaPTEImmediateFlip = 0;\n\t}\n\n\t*DestinationLinesToRequestVMInImmediateFlip = dml_ceil(4.0 * (TimeForFetchingMetaPTEImmediateFlip / LineTime), 1) / 4.0;\n\tif ((GPUVMEnable == true || DCCEnable == true)) {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = dml_max3((MetaRowBytes + DPTEBytesPerRow) * HostVMInefficiencyFactor / ImmediateFlipBW, UrgentLatency * (HostVMDynamicLevels + 1), LineTime / 4);\n\t} else {\n\t\tTimeForFetchingRowInVBlankImmediateFlip = 0;\n\t}\n\n\t*DestinationLinesToRequestRowInImmediateFlip = dml_ceil(4.0 * (TimeForFetchingRowInVBlankImmediateFlip / LineTime), 1) / 4.0;\n\t*final_flip_bw = dml_max(PDEAndMetaPTEBytesPerFrame * HostVMInefficiencyFactor / (*DestinationLinesToRequestVMInImmediateFlip * LineTime), (MetaRowBytes + DPTEBytesPerRow) * HostVMInefficiencyFactor / (*DestinationLinesToRequestRowInImmediateFlip * LineTime));\n\tVRatioClamped = (VRatio < 1.0) ? 1.0 : VRatio;\n\tif (SourcePixelFormat == dm_420_8 || SourcePixelFormat == dm_420_10) {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dml_min(\n\t\t\t\t\tdpte_row_height * LineTime / VRatioClamped,\n\t\t\t\t\tdpte_row_height_chroma * LineTime / (VRatioClamped / 2));\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = dml_min(\n\t\t\t\t\tmeta_row_height * LineTime / VRatioClamped,\n\t\t\t\t\tmeta_row_height_chroma * LineTime / (VRatioClamped / 2));\n\t\t} else {\n\t\t\tmin_row_time = dml_min4(\n\t\t\t\t\tdpte_row_height * LineTime / VRatioClamped,\n\t\t\t\t\tmeta_row_height * LineTime / VRatioClamped,\n\t\t\t\t\tdpte_row_height_chroma * LineTime / (VRatioClamped / 2),\n\t\t\t\t\tmeta_row_height_chroma * LineTime / (VRatioClamped / 2));\n\t\t}\n\t} else {\n\t\tif (GPUVMEnable == true && DCCEnable != true) {\n\t\t\tmin_row_time = dpte_row_height * LineTime / VRatioClamped;\n\t\t} else if (GPUVMEnable != true && DCCEnable == true) {\n\t\t\tmin_row_time = meta_row_height * LineTime / VRatioClamped;\n\t\t} else {\n\t\t\tmin_row_time = dml_min(\n\t\t\t\t\tdpte_row_height * LineTime / VRatioClamped,\n\t\t\t\t\tmeta_row_height * LineTime / VRatioClamped);\n\t\t}\n\t}\n\n\tif (*DestinationLinesToRequestVMInImmediateFlip >= 32\n\t\t\t|| *DestinationLinesToRequestRowInImmediateFlip >= 16\n\t\t\t|| TimeForFetchingMetaPTEImmediateFlip + 2 * TimeForFetchingRowInVBlankImmediateFlip > min_row_time) {\n\t\t*ImmediateFlipSupportedForPipe = false;\n\t} else {\n\t\t*ImmediateFlipSupportedForPipe = true;\n\t}\n}\n\nstatic unsigned int TruncToValidBPP(\n\t\tdouble DecimalBPP,\n\t\tdouble DesiredBPP,\n\t\tbool DSCEnabled,\n\t\tenum output_encoder_class Output,\n\t\tenum output_format_class Format,\n\t\tunsigned int DSCInputBitPerComponent)\n{\n\tif (Output == dm_hdmi) {\n\t\tif (Format == dm_420) {\n\t\t\tif (DecimalBPP >= 18 && (DesiredBPP == 0 || DesiredBPP == 18))\n\t\t\t\treturn 18;\n\t\t\telse if (DecimalBPP >= 15 && (DesiredBPP == 0 || DesiredBPP == 15))\n\t\t\t\treturn 15;\n\t\t\telse if (DecimalBPP >= 12 && (DesiredBPP == 0 || DesiredBPP == 12))\n\t\t\t\treturn 12;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t} else if (Format == dm_444) {\n\t\t\tif (DecimalBPP >= 36 && (DesiredBPP == 0 || DesiredBPP == 36))\n\t\t\t\treturn 36;\n\t\t\telse if (DecimalBPP >= 30 && (DesiredBPP == 0 || DesiredBPP == 30))\n\t\t\t\treturn 30;\n\t\t\telse if (DecimalBPP >= 24 && (DesiredBPP == 0 || DesiredBPP == 24))\n\t\t\t\treturn 24;\n\t\t\telse if (DecimalBPP >= 18 && (DesiredBPP == 0 || DesiredBPP == 18))\n\t\t\t\treturn 18;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t} else {\n\t\t\tif (DecimalBPP / 1.5 >= 24 && (DesiredBPP == 0 || DesiredBPP == 24))\n\t\t\t\treturn 24;\n\t\t\telse if (DecimalBPP / 1.5 >= 20 && (DesiredBPP == 0 || DesiredBPP == 20))\n\t\t\t\treturn 20;\n\t\t\telse if (DecimalBPP / 1.5 >= 16 && (DesiredBPP == 0 || DesiredBPP == 16))\n\t\t\t\treturn 16;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t}\n\t} else {\n\t\tif (DSCEnabled) {\n\t\t\tif (Format == dm_420) {\n\t\t\t\tif (DesiredBPP == 0) {\n\t\t\t\t\tif (DecimalBPP < 6)\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\telse if (DecimalBPP >= 1.5 * DSCInputBitPerComponent - 1.0 / 16.0)\n\t\t\t\t\t\treturn 1.5 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn dml_floor(16 * DecimalBPP, 1) / 16.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (DecimalBPP < 6\n\t\t\t\t\t\t\t|| DesiredBPP < 6\n\t\t\t\t\t\t\t|| DesiredBPP > 1.5 * DSCInputBitPerComponent - 1.0 / 16.0\n\t\t\t\t\t\t\t|| DecimalBPP < DesiredBPP) {\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn DesiredBPP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Format == dm_n422) {\n\t\t\t\tif (DesiredBPP == 0) {\n\t\t\t\t\tif (DecimalBPP < 7)\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\telse if (DecimalBPP >= 2 * DSCInputBitPerComponent - 1.0 / 16.0)\n\t\t\t\t\t\treturn 2 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn dml_floor(16 * DecimalBPP, 1) / 16.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (DecimalBPP < 7\n\t\t\t\t\t\t\t|| DesiredBPP < 7\n\t\t\t\t\t\t\t|| DesiredBPP > 2 * DSCInputBitPerComponent - 1.0 / 16.0\n\t\t\t\t\t\t\t|| DecimalBPP < DesiredBPP) {\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn DesiredBPP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (DesiredBPP == 0) {\n\t\t\t\t\tif (DecimalBPP < 8)\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\telse if (DecimalBPP >= 3 * DSCInputBitPerComponent - 1.0 / 16.0)\n\t\t\t\t\t\treturn 3 * DSCInputBitPerComponent - 1.0 / 16.0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn dml_floor(16 * DecimalBPP, 1) / 16.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (DecimalBPP < 8\n\t\t\t\t\t\t\t|| DesiredBPP < 8\n\t\t\t\t\t\t\t|| DesiredBPP > 3 * DSCInputBitPerComponent - 1.0 / 16.0\n\t\t\t\t\t\t\t|| DecimalBPP < DesiredBPP) {\n\t\t\t\t\t\treturn BPP_INVALID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn DesiredBPP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Format == dm_420) {\n\t\t\tif (DecimalBPP >= 18 && (DesiredBPP == 0 || DesiredBPP == 18))\n\t\t\t\treturn 18;\n\t\t\telse if (DecimalBPP >= 15 && (DesiredBPP == 0 || DesiredBPP == 15))\n\t\t\t\treturn 15;\n\t\t\telse if (DecimalBPP >= 12 && (DesiredBPP == 0 || DesiredBPP == 12))\n\t\t\t\treturn 12;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t} else if (Format == dm_s422 || Format == dm_n422) {\n\t\t\tif (DecimalBPP >= 24 && (DesiredBPP == 0 || DesiredBPP == 24))\n\t\t\t\treturn 24;\n\t\t\telse if (DecimalBPP >= 20 && (DesiredBPP == 0 || DesiredBPP == 20))\n\t\t\t\treturn 20;\n\t\t\telse if (DecimalBPP >= 16 && (DesiredBPP == 0 || DesiredBPP == 16))\n\t\t\t\treturn 16;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t} else {\n\t\t\tif (DecimalBPP >= 36 && (DesiredBPP == 0 || DesiredBPP == 36))\n\t\t\t\treturn 36;\n\t\t\telse if (DecimalBPP >= 30 && (DesiredBPP == 0 || DesiredBPP == 30))\n\t\t\t\treturn 30;\n\t\t\telse if (DecimalBPP >= 24 && (DesiredBPP == 0 || DesiredBPP == 24))\n\t\t\t\treturn 24;\n\t\t\telse if (DecimalBPP >= 18 && (DesiredBPP == 0 || DesiredBPP == 18))\n\t\t\t\treturn 18;\n\t\t\telse\n\t\t\t\treturn BPP_INVALID;\n\t\t}\n\t}\n}\n\n\nstatic noinline void CalculatePrefetchSchedulePerPlane(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tint i,\n\t\tunsigned j,\n\t\tunsigned k)\n{\n\tstruct vba_vars_st *locals = &mode_lib->vba;\n\tPipe myPipe;\n\tHostVM myHostVM;\n\n\tif (mode_lib->vba.XFCEnabled[k] == true) {\n\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay =\n\t\t\t\tCalculateRemoteSurfaceFlipDelay(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\tlocals->SwathWidthYThisState[k],\n\t\t\t\t\t\tdml_ceil(locals->BytePerPixelInDETY[k], 1.0),\n\t\t\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateOffset,\n\t\t\t\t\t\tmode_lib->vba.XFCTSlvVupdateWidth,\n\t\t\t\t\t\tmode_lib->vba.XFCTSlvVreadyOffset,\n\t\t\t\t\t\tmode_lib->vba.XFCXBUFLatencyTolerance,\n\t\t\t\t\t\tmode_lib->vba.XFCFillBWOverhead,\n\t\t\t\t\t\tmode_lib->vba.XFCSlvChunkSize,\n\t\t\t\t\t\tmode_lib->vba.XFCBusTransportTime,\n\t\t\t\t\t\tmode_lib->vba.TimeCalc,\n\t\t\t\t\t\tmode_lib->vba.TWait,\n\t\t\t\t\t\t&mode_lib->vba.SrcActiveDrainRate,\n\t\t\t\t\t\t&mode_lib->vba.TInitXFill,\n\t\t\t\t\t\t&mode_lib->vba.TslvChk);\n\t} else {\n\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay = 0.0;\n\t}\n\n\tmyPipe.DPPCLK = locals->RequiredDPPCLK[i][j][k];\n\tmyPipe.DISPCLK = locals->RequiredDISPCLK[i][j];\n\tmyPipe.PixelClock = mode_lib->vba.PixelClock[k];\n\tmyPipe.DCFCLKDeepSleep = mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0];\n\tmyPipe.DPPPerPlane = locals->NoOfDPP[i][j][k];\n\tmyPipe.ScalerEnabled = mode_lib->vba.ScalerEnabled[k];\n\tmyPipe.SourceScan = mode_lib->vba.SourceScan[k];\n\tmyPipe.BlockWidth256BytesY = locals->Read256BlockWidthY[k];\n\tmyPipe.BlockHeight256BytesY = locals->Read256BlockHeightY[k];\n\tmyPipe.BlockWidth256BytesC = locals->Read256BlockWidthC[k];\n\tmyPipe.BlockHeight256BytesC = locals->Read256BlockHeightC[k];\n\tmyPipe.InterlaceEnable = mode_lib->vba.Interlace[k];\n\tmyPipe.NumberOfCursors = mode_lib->vba.NumberOfCursors[k];\n\tmyPipe.VBlank = mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k];\n\tmyPipe.HTotal = mode_lib->vba.HTotal[k];\n\n\n\tmyHostVM.Enable = mode_lib->vba.HostVMEnable;\n\tmyHostVM.MaxPageTableLevels = mode_lib->vba.HostVMMaxPageTableLevels;\n\tmyHostVM.CachedPageTableLevels = mode_lib->vba.HostVMCachedPageTableLevels;\n\n\n\tmode_lib->vba.IsErrorResult[i][j][k] = CalculatePrefetchSchedule(\n\t\t\tmode_lib,\n\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t&myPipe,\n\t\t\tlocals->DSCDelayPerState[i][k],\n\t\t\tmode_lib->vba.DPPCLKDelaySubtotal,\n\t\t\tmode_lib->vba.DPPCLKDelaySCL,\n\t\t\tmode_lib->vba.DPPCLKDelaySCLLBOnly,\n\t\t\tmode_lib->vba.DPPCLKDelayCNVCFormater,\n\t\t\tmode_lib->vba.DPPCLKDelayCNVCCursor,\n\t\t\tmode_lib->vba.DISPCLKDelaySubtotal,\n\t\t\tlocals->SwathWidthYThisState[k] / mode_lib->vba.HRatio[k],\n\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\tmode_lib->vba.MaxInterDCNTileRepeaters,\n\t\t\tdml_min(mode_lib->vba.MaxVStartup, locals->MaximumVStartup[0][0][k]),\n\t\t\tlocals->MaximumVStartup[0][0][k],\n\t\t\tmode_lib->vba.GPUVMMaxPageTableLevels,\n\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t&myHostVM,\n\t\t\tmode_lib->vba.DynamicMetadataEnable[k],\n\t\t\tmode_lib->vba.DynamicMetadataLinesBeforeActiveRequired[k],\n\t\t\tmode_lib->vba.DynamicMetadataTransmittedBytes[k],\n\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\tmode_lib->vba.ExtraLatency,\n\t\t\tmode_lib->vba.TimeCalc,\n\t\t\tlocals->PDEAndMetaPTEBytesPerFrame[0][0][k],\n\t\t\tlocals->MetaRowBytes[0][0][k],\n\t\t\tlocals->DPTEBytesPerRow[0][0][k],\n\t\t\tlocals->PrefetchLinesY[0][0][k],\n\t\t\tlocals->SwathWidthYThisState[k],\n\t\t\tlocals->BytePerPixelInDETY[k],\n\t\t\tlocals->PrefillY[k],\n\t\t\tlocals->MaxNumSwY[k],\n\t\t\tlocals->PrefetchLinesC[0][0][k],\n\t\t\tlocals->BytePerPixelInDETC[k],\n\t\t\tlocals->PrefillC[k],\n\t\t\tlocals->MaxNumSwC[k],\n\t\t\tlocals->SwathHeightYThisState[k],\n\t\t\tlocals->SwathHeightCThisState[k],\n\t\t\tmode_lib->vba.TWait,\n\t\t\tmode_lib->vba.XFCEnabled[k],\n\t\t\tmode_lib->vba.XFCRemoteSurfaceFlipDelay,\n\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t&locals->dst_x_after_scaler,\n\t\t\t&locals->dst_y_after_scaler,\n\t\t\t&locals->LineTimesForPrefetch[k],\n\t\t\t&locals->PrefetchBW[k],\n\t\t\t&locals->LinesForMetaPTE[k],\n\t\t\t&locals->LinesForMetaAndDPTERow[k],\n\t\t\t&locals->VRatioPreY[i][j][k],\n\t\t\t&locals->VRatioPreC[i][j][k],\n\t\t\t&locals->RequiredPrefetchPixelDataBWLuma[i][j][k],\n\t\t\t&locals->RequiredPrefetchPixelDataBWChroma[i][j][k],\n\t\t\t&locals->VStartupRequiredWhenNotEnoughTimeForDynamicMetadata,\n\t\t\t&locals->Tno_bw[k],\n\t\t\t&locals->prefetch_vmrow_bw[k],\n\t\t\tlocals->swath_width_luma_ub,\n\t\t\tlocals->swath_width_chroma_ub,\n\t\t\t&mode_lib->vba.VUpdateOffsetPix[k],\n\t\t\t&mode_lib->vba.VUpdateWidthPix[k],\n\t\t\t&mode_lib->vba.VReadyOffsetPix[k]);\n}\nvoid dml21_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_lib)\n{\n\tstruct vba_vars_st *locals = &mode_lib->vba;\n\n\tint i;\n\tunsigned int j, k, m;\n\n\t \n\n\t \n\n\tmode_lib->vba.ScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.ScalerEnabled[k] == false\n\t\t\t\t&& ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_8)\n\t\t\t\t\t\t|| mode_lib->vba.HRatio[k] != 1.0\n\t\t\t\t\t\t|| mode_lib->vba.htaps[k] != 1.0\n\t\t\t\t\t\t|| mode_lib->vba.VRatio[k] != 1.0\n\t\t\t\t\t\t|| mode_lib->vba.vtaps[k] != 1.0)) {\n\t\t\tmode_lib->vba.ScaleRatioAndTapsSupport = false;\n\t\t} else if (mode_lib->vba.vtaps[k] < 1.0 || mode_lib->vba.vtaps[k] > 8.0\n\t\t\t\t|| mode_lib->vba.htaps[k] < 1.0 || mode_lib->vba.htaps[k] > 8.0\n\t\t\t\t|| (mode_lib->vba.htaps[k] > 1.0\n\t\t\t\t\t\t&& (mode_lib->vba.htaps[k] % 2) == 1)\n\t\t\t\t|| mode_lib->vba.HRatio[k] > mode_lib->vba.MaxHSCLRatio\n\t\t\t\t|| mode_lib->vba.VRatio[k] > mode_lib->vba.MaxVSCLRatio\n\t\t\t\t|| mode_lib->vba.HRatio[k] > mode_lib->vba.htaps[k]\n\t\t\t\t|| mode_lib->vba.VRatio[k] > mode_lib->vba.vtaps[k]\n\t\t\t\t|| (mode_lib->vba.SourcePixelFormat[k] != dm_444_64\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_8\n\t\t\t\t\t\t&& (mode_lib->vba.HRatio[k] / 2.0\n\t\t\t\t\t\t\t\t> mode_lib->vba.HTAPsChroma[k]\n\t\t\t\t\t\t\t\t|| mode_lib->vba.VRatio[k] / 2.0\n\t\t\t\t\t\t\t\t\t\t> mode_lib->vba.VTAPsChroma[k]))) {\n\t\t\tmode_lib->vba.ScaleRatioAndTapsSupport = false;\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.SourceFormatPixelAndScanSupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif ((mode_lib->vba.SurfaceTiling[k] == dm_sw_linear\n\t\t\t\t&& mode_lib->vba.SourceScan[k] != dm_horz)\n\t\t\t\t|| ((mode_lib->vba.SurfaceTiling[k] == dm_sw_4kb_d\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_4kb_d_x\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d_t\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_d_x\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_var_d\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k] == dm_sw_var_d_x)\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_64)\n\t\t\t\t|| (mode_lib->vba.SurfaceTiling[k] == dm_sw_64kb_r_x\n\t\t\t\t\t\t&& (mode_lib->vba.SourcePixelFormat[k] == dm_mono_8\n\t\t\t\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t\t\t== dm_420_8\n\t\t\t\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t\t\t== dm_420_10))\n\t\t\t\t|| (((mode_lib->vba.SurfaceTiling[k] == dm_sw_gfx7_2d_thin_gl\n\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t== dm_sw_gfx7_2d_thin_l_vp)\n\t\t\t\t\t\t&& !((mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t== dm_444_64\n\t\t\t\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t\t\t== dm_444_32)\n\t\t\t\t\t\t\t\t&& mode_lib->vba.SourceScan[k]\n\t\t\t\t\t\t\t\t\t\t== dm_horz\n\t\t\t\t\t\t\t\t&& mode_lib->vba.SupportGFX7CompatibleTilingIn32bppAnd64bpp\n\t\t\t\t\t\t\t\t\t\t== true\n\t\t\t\t\t\t\t\t&& mode_lib->vba.DCCEnable[k]\n\t\t\t\t\t\t\t\t\t\t== false))\n\t\t\t\t\t\t|| (mode_lib->vba.DCCEnable[k] == true\n\t\t\t\t\t\t\t\t&& (mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t== dm_sw_linear\n\t\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t\t\t\t\t== dm_420_8\n\t\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k]\n\t\t\t\t\t\t\t\t\t\t\t\t== dm_420_10)))) {\n\t\t\tmode_lib->vba.SourceFormatPixelAndScanSupport = false;\n\t\t}\n\t}\n\t \n\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_444_64) {\n\t\t\tlocals->BytePerPixelInDETY[k] = 8.0;\n\t\t\tlocals->BytePerPixelInDETC[k] = 0.0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_32) {\n\t\t\tlocals->BytePerPixelInDETY[k] = 4.0;\n\t\t\tlocals->BytePerPixelInDETC[k] = 0.0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_444_16\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_mono_16) {\n\t\t\tlocals->BytePerPixelInDETY[k] = 2.0;\n\t\t\tlocals->BytePerPixelInDETC[k] = 0.0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_mono_8) {\n\t\t\tlocals->BytePerPixelInDETY[k] = 1.0;\n\t\t\tlocals->BytePerPixelInDETC[k] = 0.0;\n\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8) {\n\t\t\tlocals->BytePerPixelInDETY[k] = 1.0;\n\t\t\tlocals->BytePerPixelInDETC[k] = 2.0;\n\t\t} else {\n\t\t\tlocals->BytePerPixelInDETY[k] = 4.0 / 3;\n\t\t\tlocals->BytePerPixelInDETC[k] = 8.0 / 3;\n\t\t}\n\t\tif (mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\tlocals->SwathWidthYSingleDPP[k] = mode_lib->vba.ViewportWidth[k];\n\t\t} else {\n\t\t\tlocals->SwathWidthYSingleDPP[k] = mode_lib->vba.ViewportHeight[k];\n\t\t}\n\t}\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tlocals->ReadBandwidthLuma[k] = locals->SwathWidthYSingleDPP[k] * dml_ceil(locals->BytePerPixelInDETY[k], 1.0)\n\t\t\t\t/ (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k];\n\t\tlocals->ReadBandwidthChroma[k] = locals->SwathWidthYSingleDPP[k] / 2 * dml_ceil(locals->BytePerPixelInDETC[k], 2.0)\n\t\t\t\t/ (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k] / 2.0;\n\t\tlocals->ReadBandwidth[k] = locals->ReadBandwidthLuma[k] + locals->ReadBandwidthChroma[k];\n\t}\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true\n\t\t\t\t&& mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {\n\t\t\tlocals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t* mode_lib->vba.WritebackDestinationHeight[k]\n\t\t\t\t\t/ (mode_lib->vba.WritebackSourceHeight[k]\n\t\t\t\t\t\t\t* mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]) * 4.0;\n\t\t} else if (mode_lib->vba.WritebackEnable[k] == true\n\t\t\t\t&& mode_lib->vba.WritebackPixelFormat[k] == dm_420_10) {\n\t\t\tlocals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t* mode_lib->vba.WritebackDestinationHeight[k]\n\t\t\t\t\t/ (mode_lib->vba.WritebackSourceHeight[k]\n\t\t\t\t\t\t\t* mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]) * 3.0;\n\t\t} else if (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tlocals->WriteBandwidth[k] = mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t* mode_lib->vba.WritebackDestinationHeight[k]\n\t\t\t\t\t/ (mode_lib->vba.WritebackSourceHeight[k]\n\t\t\t\t\t\t\t* mode_lib->vba.HTotal[k]\n\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]) * 1.5;\n\t\t} else {\n\t\t\tlocals->WriteBandwidth[k] = 0.0;\n\t\t}\n\t}\n\tmode_lib->vba.DCCEnabledInAnyPlane = false;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.DCCEnable[k] == true) {\n\t\t\tmode_lib->vba.DCCEnabledInAnyPlane = true;\n\t\t}\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tlocals->IdealSDPPortBandwidthPerState[i][0] = dml_min3(\n\t\t\t\tmode_lib->vba.ReturnBusWidth * mode_lib->vba.DCFCLKPerState[i],\n\t\t\t\tmode_lib->vba.DRAMSpeedPerState[i] * mode_lib->vba.NumberOfChannels\n\t\t\t\t\t\t* mode_lib->vba.DRAMChannelWidth,\n\t\t\t\tmode_lib->vba.FabricClockPerState[i]\n\t\t\t\t\t\t* mode_lib->vba.FabricDatapathToDCNDataReturn);\n\t\tif (mode_lib->vba.HostVMEnable == false) {\n\t\t\tlocals->ReturnBWPerState[i][0] = locals->IdealSDPPortBandwidthPerState[i][0]\n\t\t\t\t\t* mode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly / 100.0;\n\t\t} else {\n\t\t\tlocals->ReturnBWPerState[i][0] = locals->IdealSDPPortBandwidthPerState[i][0]\n\t\t\t\t\t* mode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData / 100.0;\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.WritebackLatencySupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tif (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {\n\t\t\t\tif (locals->WriteBandwidth[k]\n\t\t\t\t\t\t> (mode_lib->vba.WritebackInterfaceLumaBufferSize\n\t\t\t\t\t\t\t\t+ mode_lib->vba.WritebackInterfaceChromaBufferSize)\n\t\t\t\t\t\t\t\t/ mode_lib->vba.WritebackLatency) {\n\t\t\t\t\tmode_lib->vba.WritebackLatencySupport = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (locals->WriteBandwidth[k]\n\t\t\t\t\t\t> 1.5\n\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackInterfaceLumaBufferSize,\n\t\t\t\t\t\t\t\t\t\t2.0\n\t\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.WritebackInterfaceChromaBufferSize)\n\t\t\t\t\t\t\t\t/ mode_lib->vba.WritebackLatency) {\n\t\t\t\t\tmode_lib->vba.WritebackLatencySupport = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tlocals->UrgentRoundTripAndOutOfOrderLatencyPerState[i] =\n\t\t\t\t(mode_lib->vba.RoundTripPingLatencyCycles + 32.0) / mode_lib->vba.DCFCLKPerState[i]\n\t\t\t\t+ dml_max3(mode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelVMDataOnly)\n\t\t\t\t\t* mode_lib->vba.NumberOfChannels / locals->ReturnBWPerState[i][0];\n\t\tif ((mode_lib->vba.ROBBufferSizeInKByte - mode_lib->vba.PixelChunkSizeInKByte) * 1024.0 / locals->ReturnBWPerState[i][0]\n\t\t\t\t> locals->UrgentRoundTripAndOutOfOrderLatencyPerState[i]) {\n\t\t\tlocals->ROBSupport[i][0] = true;\n\t\t} else {\n\t\t\tlocals->ROBSupport[i][0] = false;\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.TotalNumberOfActiveWriteback = 0;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tif (mode_lib->vba.ActiveWritebacksPerPlane[k] == 0)\n\t\t\t\tmode_lib->vba.ActiveWritebacksPerPlane[k] = 1;\n\t\t\tmode_lib->vba.TotalNumberOfActiveWriteback =\n\t\t\t\t\tmode_lib->vba.TotalNumberOfActiveWriteback\n\t\t\t\t\t\t\t+ mode_lib->vba.ActiveWritebacksPerPlane[k];\n\t\t}\n\t}\n\tmode_lib->vba.WritebackModeSupport = true;\n\tif (mode_lib->vba.TotalNumberOfActiveWriteback > mode_lib->vba.MaxNumWriteback) {\n\t\tmode_lib->vba.WritebackModeSupport = false;\n\t}\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true\n\t\t\t\t&& mode_lib->vba.Writeback10bpc420Supported != true\n\t\t\t\t&& mode_lib->vba.WritebackPixelFormat[k] == dm_420_10) {\n\t\t\tmode_lib->vba.WritebackModeSupport = false;\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.WritebackScaleRatioAndTapsSupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tif (mode_lib->vba.WritebackLumaAndChromaScalingSupported == false\n\t\t\t\t\t&& (mode_lib->vba.WritebackHRatio[k] != 1.0\n\t\t\t\t\t\t\t|| mode_lib->vba.WritebackVRatio[k] != 1.0)) {\n\t\t\t\tmode_lib->vba.WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t\tif (mode_lib->vba.WritebackHRatio[k] > mode_lib->vba.WritebackMaxHSCLRatio\n\t\t\t\t\t|| mode_lib->vba.WritebackVRatio[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackMaxVSCLRatio\n\t\t\t\t\t|| mode_lib->vba.WritebackHRatio[k]\n\t\t\t\t\t\t\t< mode_lib->vba.WritebackMinHSCLRatio\n\t\t\t\t\t|| mode_lib->vba.WritebackVRatio[k]\n\t\t\t\t\t\t\t< mode_lib->vba.WritebackMinVSCLRatio\n\t\t\t\t\t|| mode_lib->vba.WritebackLumaHTaps[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackMaxHSCLTaps\n\t\t\t\t\t|| mode_lib->vba.WritebackLumaVTaps[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackMaxVSCLTaps\n\t\t\t\t\t|| mode_lib->vba.WritebackHRatio[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackLumaHTaps[k]\n\t\t\t\t\t|| mode_lib->vba.WritebackVRatio[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackLumaVTaps[k]\n\t\t\t\t\t|| (mode_lib->vba.WritebackLumaHTaps[k] > 2.0\n\t\t\t\t\t\t\t&& ((mode_lib->vba.WritebackLumaHTaps[k] % 2)\n\t\t\t\t\t\t\t\t\t== 1))\n\t\t\t\t\t|| (mode_lib->vba.WritebackPixelFormat[k] != dm_444_32\n\t\t\t\t\t\t\t&& (mode_lib->vba.WritebackChromaHTaps[k]\n\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackMaxHSCLTaps\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.WritebackChromaVTaps[k]\n\t\t\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackMaxVSCLTaps\n\t\t\t\t\t\t\t\t\t|| 2.0\n\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.WritebackHRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackChromaHTaps[k]\n\t\t\t\t\t\t\t\t\t|| 2.0\n\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.WritebackVRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackChromaVTaps[k]\n\t\t\t\t\t\t\t\t\t|| (mode_lib->vba.WritebackChromaHTaps[k] > 2.0\n\t\t\t\t\t\t\t\t\t\t&& ((mode_lib->vba.WritebackChromaHTaps[k] % 2) == 1))))) {\n\t\t\t\tmode_lib->vba.WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t\tif (mode_lib->vba.WritebackVRatio[k] < 1.0) {\n\t\t\t\tmode_lib->vba.WritebackLumaVExtra =\n\t\t\t\t\t\tdml_max(1.0 - 2.0 / dml_ceil(1.0 / mode_lib->vba.WritebackVRatio[k], 1.0), 0.0);\n\t\t\t} else {\n\t\t\t\tmode_lib->vba.WritebackLumaVExtra = -1;\n\t\t\t}\n\t\t\tif ((mode_lib->vba.WritebackPixelFormat[k] == dm_444_32\n\t\t\t\t\t&& mode_lib->vba.WritebackLumaVTaps[k]\n\t\t\t\t\t\t\t> (mode_lib->vba.WritebackLineBufferLumaBufferSize\n\t\t\t\t\t\t\t\t\t+ mode_lib->vba.WritebackLineBufferChromaBufferSize)\n\t\t\t\t\t\t\t\t\t/ 3.0\n\t\t\t\t\t\t\t\t\t/ mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t\t\t- mode_lib->vba.WritebackLumaVExtra)\n\t\t\t\t\t|| (mode_lib->vba.WritebackPixelFormat[k] == dm_420_8\n\t\t\t\t\t\t\t&& mode_lib->vba.WritebackLumaVTaps[k]\n\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackLineBufferLumaBufferSize\n\t\t\t\t\t\t\t\t\t\t\t* 8.0 / 10.0 / mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t\t\t\t\t- mode_lib->vba.WritebackLumaVExtra)\n\t\t\t\t\t|| (mode_lib->vba.WritebackPixelFormat[k] == dm_420_10\n\t\t\t\t\t\t\t&& mode_lib->vba.WritebackLumaVTaps[k]\n\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackLineBufferLumaBufferSize\n\t\t\t\t\t\t\t\t\t\t\t* 8.0 / 10.0\n\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t\t\t\t\t- mode_lib->vba.WritebackLumaVExtra)) {\n\t\t\t\tmode_lib->vba.WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t\tif (2.0 * mode_lib->vba.WritebackVRatio[k] < 1) {\n\t\t\t\tmode_lib->vba.WritebackChromaVExtra = 0.0;\n\t\t\t} else {\n\t\t\t\tmode_lib->vba.WritebackChromaVExtra = -1;\n\t\t\t}\n\t\t\tif ((mode_lib->vba.WritebackPixelFormat[k] == dm_420_8\n\t\t\t\t\t&& mode_lib->vba.WritebackChromaVTaps[k]\n\t\t\t\t\t\t\t> mode_lib->vba.WritebackLineBufferChromaBufferSize\n\t\t\t\t\t\t\t\t\t* 8.0 / 10.0 / mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t\t\t- mode_lib->vba.WritebackChromaVExtra)\n\t\t\t\t\t|| (mode_lib->vba.WritebackPixelFormat[k] == dm_420_10\n\t\t\t\t\t\t\t&& mode_lib->vba.WritebackChromaVTaps[k]\n\t\t\t\t\t\t\t\t\t> mode_lib->vba.WritebackLineBufferChromaBufferSize\n\t\t\t\t\t\t\t\t\t\t\t* 8.0 / 10.0\n\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t\t\t\t\t- mode_lib->vba.WritebackChromaVExtra)) {\n\t\t\t\tmode_lib->vba.WritebackScaleRatioAndTapsSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.WritebackRequiredDISPCLK = 0.0;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\tmode_lib->vba.WritebackRequiredDISPCLK =\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.WritebackRequiredDISPCLK,\n\t\t\t\t\t\t\tCalculateWriteBackDISPCLK(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.HTotal[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaLineBufferWidth));\n\t\t}\n\t}\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.HRatio[k] > 1.0) {\n\t\t\tlocals->PSCL_FACTOR[k] = dml_min(\n\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput\n\t\t\t\t\t\t\t* mode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t/ dml_ceil(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.htaps[k]\n\t\t\t\t\t\t\t\t\t\t\t/ 6.0,\n\t\t\t\t\t\t\t\t\t1.0));\n\t\t} else {\n\t\t\tlocals->PSCL_FACTOR[k] = dml_min(\n\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput);\n\t\t}\n\t\tif (locals->BytePerPixelInDETC[k] == 0.0) {\n\t\t\tlocals->PSCL_FACTOR_CHROMA[k] = 0.0;\n\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] =\n\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* dml_max3(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.vtaps[k] / 6.0\n\t\t\t\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]),\n\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t/ locals->PSCL_FACTOR[k],\n\t\t\t\t\t\t\t\t\t1.0);\n\t\t\tif ((mode_lib->vba.htaps[k] > 6.0 || mode_lib->vba.vtaps[k] > 6.0)\n\t\t\t\t\t&& locals->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t< 2.0 * mode_lib->vba.PixelClock[k]) {\n\t\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] = 2.0\n\t\t\t\t\t\t* mode_lib->vba.PixelClock[k];\n\t\t\t}\n\t\t} else {\n\t\t\tif (mode_lib->vba.HRatio[k] / 2.0 > 1.0) {\n\t\t\t\tlocals->PSCL_FACTOR_CHROMA[k] =\n\t\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput\n\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t\t\t\t/ dml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HTAPsChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 6.0,\n\t\t\t\t\t\t\t\t\t\t\t\t1.0));\n\t\t\t} else {\n\t\t\t\tlocals->PSCL_FACTOR_CHROMA[k] = dml_min(\n\t\t\t\t\t\tmode_lib->vba.MaxDCHUBToPSCLThroughput,\n\t\t\t\t\t\tmode_lib->vba.MaxPSCLToLBThroughput);\n\t\t\t}\n\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] =\n\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* dml_max5(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.vtaps[k] / 6.0\n\t\t\t\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]),\n\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t/ locals->PSCL_FACTOR[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.VTAPsChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t/ 6.0\n\t\t\t\t\t\t\t\t\t\t\t* dml_min(\n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0),\n\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t* mode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t/ 4.0\n\t\t\t\t\t\t\t\t\t\t\t/ locals->PSCL_FACTOR_CHROMA[k],\n\t\t\t\t\t\t\t\t\t1.0);\n\t\t\tif ((mode_lib->vba.htaps[k] > 6.0 || mode_lib->vba.vtaps[k] > 6.0\n\t\t\t\t\t|| mode_lib->vba.HTAPsChroma[k] > 6.0\n\t\t\t\t\t|| mode_lib->vba.VTAPsChroma[k] > 6.0)\n\t\t\t\t\t&& locals->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t< 2.0 * mode_lib->vba.PixelClock[k]) {\n\t\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] = 2.0\n\t\t\t\t\t\t* mode_lib->vba.PixelClock[k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tCalculate256BBlockSizes(\n\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\tdml_ceil(locals->BytePerPixelInDETY[k], 1.0),\n\t\t\t\tdml_ceil(locals->BytePerPixelInDETC[k], 2.0),\n\t\t\t\t&locals->Read256BlockHeightY[k],\n\t\t\t\t&locals->Read256BlockHeightC[k],\n\t\t\t\t&locals->Read256BlockWidthY[k],\n\t\t\t\t&locals->Read256BlockWidthC[k]);\n\t\tif (mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\tlocals->MaxSwathHeightY[k] = locals->Read256BlockHeightY[k];\n\t\t\tlocals->MaxSwathHeightC[k] = locals->Read256BlockHeightC[k];\n\t\t} else {\n\t\t\tlocals->MaxSwathHeightY[k] = locals->Read256BlockWidthY[k];\n\t\t\tlocals->MaxSwathHeightC[k] = locals->Read256BlockWidthC[k];\n\t\t}\n\t\tif ((mode_lib->vba.SourcePixelFormat[k] == dm_444_64\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_32\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_444_16\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_mono_16\n\t\t\t\t|| mode_lib->vba.SourcePixelFormat[k] == dm_mono_8)) {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear\n\t\t\t\t\t|| (mode_lib->vba.SourcePixelFormat[k] == dm_444_64\n\t\t\t\t\t\t\t&& (mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t== dm_sw_4kb_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_4kb_s_x\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s_t\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_64kb_s_x\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_s\n\t\t\t\t\t\t\t\t\t|| mode_lib->vba.SurfaceTiling[k]\n\t\t\t\t\t\t\t\t\t\t\t== dm_sw_var_s_x)\n\t\t\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz)) {\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];\n\t\t\t} else {\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k]\n\t\t\t\t\t\t/ 2.0;\n\t\t\t}\n\t\t\tlocals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];\n\t\t} else {\n\t\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];\n\t\t\t\tlocals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_8\n\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k]\n\t\t\t\t\t\t/ 2.0;\n\t\t\t\tlocals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];\n\t\t\t} else if (mode_lib->vba.SourcePixelFormat[k] == dm_420_10\n\t\t\t\t\t&& mode_lib->vba.SourceScan[k] == dm_horz) {\n\t\t\t\tlocals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k]\n\t\t\t\t\t\t/ 2.0;\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];\n\t\t\t} else {\n\t\t\t\tlocals->MinSwathHeightY[k] = locals->MaxSwathHeightY[k];\n\t\t\t\tlocals->MinSwathHeightC[k] = locals->MaxSwathHeightC[k];\n\t\t\t}\n\t\t}\n\t\tif (mode_lib->vba.SurfaceTiling[k] == dm_sw_linear) {\n\t\t\tmode_lib->vba.MaximumSwathWidthSupport = 8192.0;\n\t\t} else {\n\t\t\tmode_lib->vba.MaximumSwathWidthSupport = 5120.0;\n\t\t}\n\t\tmode_lib->vba.MaximumSwathWidthInDETBuffer =\n\t\t\t\tdml_min(\n\t\t\t\t\t\tmode_lib->vba.MaximumSwathWidthSupport,\n\t\t\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0] * 1024.0 / 2.0\n\t\t\t\t\t\t\t\t/ (locals->BytePerPixelInDETY[k]\n\t\t\t\t\t\t\t\t\t\t* locals->MinSwathHeightY[k]\n\t\t\t\t\t\t\t\t\t\t+ locals->BytePerPixelInDETC[k]\n\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t\t\t\t\t\t* locals->MinSwathHeightC[k]));\n\t\tif (locals->BytePerPixelInDETC[k] == 0.0) {\n\t\t\tmode_lib->vba.MaximumSwathWidthInLineBuffer =\n\t\t\t\t\tmode_lib->vba.LineBufferSize\n\t\t\t\t\t\t\t* dml_max(mode_lib->vba.HRatio[k], 1.0)\n\t\t\t\t\t\t\t/ mode_lib->vba.LBBitPerPixel[k]\n\t\t\t\t\t\t\t/ (mode_lib->vba.vtaps[k]\n\t\t\t\t\t\t\t\t\t+ dml_max(\n\t\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\t\t\t\t\t\t\t\t1.0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t- 2,\n\t\t\t\t\t\t\t\t\t\t\t0.0));\n\t\t} else {\n\t\t\tmode_lib->vba.MaximumSwathWidthInLineBuffer =\n\t\t\t\t\tdml_min(\n\t\t\t\t\t\t\tmode_lib->vba.LineBufferSize\n\t\t\t\t\t\t\t\t\t* dml_max(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k],\n\t\t\t\t\t\t\t\t\t\t\t1.0)\n\t\t\t\t\t\t\t\t\t/ mode_lib->vba.LBBitPerPixel[k]\n\t\t\t\t\t\t\t\t\t/ (mode_lib->vba.vtaps[k]\n\t\t\t\t\t\t\t\t\t\t\t+ dml_max(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1.0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0.0)),\n\t\t\t\t\t\t\t2.0 * mode_lib->vba.LineBufferSize\n\t\t\t\t\t\t\t\t\t* dml_max(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0,\n\t\t\t\t\t\t\t\t\t\t\t1.0)\n\t\t\t\t\t\t\t\t\t/ mode_lib->vba.LBBitPerPixel[k]\n\t\t\t\t\t\t\t\t\t/ (mode_lib->vba.VTAPsChroma[k]\n\t\t\t\t\t\t\t\t\t\t\t+ dml_max(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.VRatio[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/ 2.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1.0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0.0)));\n\t\t}\n\t\tlocals->MaximumSwathWidth[k] = dml_min(\n\t\t\t\tmode_lib->vba.MaximumSwathWidthInDETBuffer,\n\t\t\t\tmode_lib->vba.MaximumSwathWidthInLineBuffer);\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tdouble MaxMaxDispclkRoundedDown = RoundToDFSGranularityDown(\n\t\t\tmode_lib->vba.MaxDispclk[mode_lib->vba.soc.num_states],\n\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tmode_lib->vba.MaxDispclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(\n\t\t\t\tmode_lib->vba.MaxDispclk[i],\n\t\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\t\t\tmode_lib->vba.MaxDppclkRoundedDownToDFSGranularity = RoundToDFSGranularityDown(\n\t\t\t\tmode_lib->vba.MaxDppclk[i],\n\t\t\t\tmode_lib->vba.DISPCLKDPPCLKVCOSpeed);\n\t\t\tlocals->RequiredDISPCLK[i][j] = 0.0;\n\t\t\tlocals->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine =\n\t\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t\t* (1.0\n\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100.0)\n\t\t\t\t\t\t\t\t* (1.0\n\t\t\t\t\t\t\t\t\t\t+ mode_lib->vba.DISPCLKRampingMargin\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100.0);\n\t\t\t\tif (mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine >= mode_lib->vba.MaxDispclk[i]\n\t\t\t\t\t\t&& i == mode_lib->vba.soc.num_states)\n\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine = mode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\n\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLKWithODMCombine = mode_lib->vba.PixelClock[k] / 2\n\t\t\t\t\t* (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * (1 + mode_lib->vba.DISPCLKRampingMargin / 100.0);\n\t\t\t\tif (mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine >= mode_lib->vba.MaxDispclk[i]\n\t\t\t\t\t\t&& i == mode_lib->vba.soc.num_states)\n\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLKWithODMCombine = mode_lib->vba.PixelClock[k] / 2\n\t\t\t\t\t\t\t* (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\n\t\t\t\tlocals->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithoutODMCombine;\n\t\t\t\tif (mode_lib->vba.ODMCapability) {\n\t\t\t\t\tif (locals->PlaneRequiredDISPCLKWithoutODMCombine > MaxMaxDispclkRoundedDown) {\n\t\t\t\t\t\tlocals->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine;\n\t\t\t\t\t} else if (locals->DSCEnabled[k] && (locals->HActive[k] > DCN21_MAX_DSC_IMAGE_WIDTH)) {\n\t\t\t\t\t\tlocals->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine;\n\t\t\t\t\t} else if (locals->HActive[k] > DCN21_MAX_420_IMAGE_WIDTH && locals->OutputFormat[k] == dm_420) {\n\t\t\t\t\t\tlocals->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PlaneRequiredDISPCLKWithODMCombine;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (locals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) <= mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity\n\t\t\t\t\t\t&& locals->SwathWidthYSingleDPP[k] <= locals->MaximumSwathWidth[k]\n\t\t\t\t\t\t&& locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {\n\t\t\t\t\tlocals->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\tlocals->RequiredDPPCLK[i][j][k] =\n\t\t\t\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t} else {\n\t\t\t\t\tlocals->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\tlocals->RequiredDPPCLK[i][j][k] =\n\t\t\t\t\t\tlocals->MinDPPCLKUsingSingleDPP[k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t}\n\t\t\t\tlocals->RequiredDISPCLK[i][j] = dml_max(\n\t\t\t\t\t\tlocals->RequiredDISPCLK[i][j],\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK);\n\t\t\t\tif ((locals->MinDPPCLKUsingSingleDPP[k] / locals->NoOfDPP[i][j][k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t> mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity)\n\t\t\t\t\t\t|| (mode_lib->vba.PlaneRequiredDISPCLK > mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity)) {\n\t\t\t\t\tlocals->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlocals->TotalNumberOfActiveDPP[i][j] = 0.0;\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++)\n\t\t\t\tlocals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + locals->NoOfDPP[i][j][k];\n\t\t\tif (j == 1) {\n\t\t\t\twhile (locals->TotalNumberOfActiveDPP[i][j] < mode_lib->vba.MaxNumDPP\n\t\t\t\t\t\t&& locals->TotalNumberOfActiveDPP[i][j] < 2 * mode_lib->vba.NumberOfActivePlanes) {\n\t\t\t\t\tdouble BWOfNonSplitPlaneOfMaximumBandwidth;\n\t\t\t\t\tunsigned int NumberOfNonSplitPlaneOfMaximumBandwidth;\n\n\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = 0;\n\t\t\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\t\t\tif (locals->ReadBandwidth[k] > BWOfNonSplitPlaneOfMaximumBandwidth && locals->NoOfDPP[i][j][k] == 1) {\n\t\t\t\t\t\t\tBWOfNonSplitPlaneOfMaximumBandwidth = locals->ReadBandwidth[k];\n\t\t\t\t\t\t\tNumberOfNonSplitPlaneOfMaximumBandwidth = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlocals->NoOfDPP[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] = 2;\n\t\t\t\t\tlocals->RequiredDPPCLK[i][j][NumberOfNonSplitPlaneOfMaximumBandwidth] =\n\t\t\t\t\t\tlocals->MinDPPCLKUsingSingleDPP[NumberOfNonSplitPlaneOfMaximumBandwidth]\n\t\t\t\t\t\t\t* (1 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100) / 2;\n\t\t\t\t\tlocals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (locals->TotalNumberOfActiveDPP[i][j] > mode_lib->vba.MaxNumDPP) {\n\t\t\t\tlocals->RequiredDISPCLK[i][j] = 0.0;\n\t\t\t\tlocals->DISPCLK_DPPCLK_Support[i][j] = true;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tlocals->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;\n\t\t\t\t\tif (locals->SwathWidthYSingleDPP[k] <= locals->MaximumSwathWidth[k]) {\n\t\t\t\t\t\tlocals->NoOfDPP[i][j][k] = 1;\n\t\t\t\t\t\tlocals->RequiredDPPCLK[i][j][k] = locals->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t* (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocals->NoOfDPP[i][j][k] = 2;\n\t\t\t\t\t\tlocals->RequiredDPPCLK[i][j][k] = locals->MinDPPCLKUsingSingleDPP[k]\n\t\t\t\t\t\t\t\t\t\t* (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) / 2.0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i != mode_lib->vba.soc.num_states) {\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK =\n\t\t\t\t\t\t\t\tmode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t\t\t\t* (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t\t\t\t* (1.0 + mode_lib->vba.DISPCLKRampingMargin / 100.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK = mode_lib->vba.PixelClock[k]\n\t\t\t\t\t\t\t* (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0);\n\t\t\t\t\t}\n\t\t\t\t\tlocals->RequiredDISPCLK[i][j] = dml_max(\n\t\t\t\t\t\t\tlocals->RequiredDISPCLK[i][j],\n\t\t\t\t\t\t\tmode_lib->vba.PlaneRequiredDISPCLK);\n\t\t\t\t\tif (locals->MinDPPCLKUsingSingleDPP[k] / locals->NoOfDPP[i][j][k] * (1.0 + mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0)\n\t\t\t\t\t\t\t> mode_lib->vba.MaxDppclkRoundedDownToDFSGranularity\n\t\t\t\t\t\t\t|| mode_lib->vba.PlaneRequiredDISPCLK > mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity)\n\t\t\t\t\t\tlocals->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t\t}\n\t\t\t\tlocals->TotalNumberOfActiveDPP[i][j] = 0.0;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++)\n\t\t\t\t\tlocals->TotalNumberOfActiveDPP[i][j] = locals->TotalNumberOfActiveDPP[i][j] + locals->NoOfDPP[i][j][k];\n\t\t\t}\n\t\t\tlocals->RequiredDISPCLK[i][j] = dml_max(\n\t\t\t\t\tlocals->RequiredDISPCLK[i][j],\n\t\t\t\t\tmode_lib->vba.WritebackRequiredDISPCLK);\n\t\t\tif (mode_lib->vba.MaxDispclkRoundedDownToDFSGranularity\n\t\t\t\t\t< mode_lib->vba.WritebackRequiredDISPCLK) {\n\t\t\t\tlocals->DISPCLK_DPPCLK_Support[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tlocals->ViewportSizeSupport[i][0] = true;\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tif (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\tif (dml_min(locals->SwathWidthYSingleDPP[k], dml_round(mode_lib->vba.HActive[k] / 2.0 * mode_lib->vba.HRatio[k]))\n\t\t\t\t\t\t> locals->MaximumSwathWidth[k]) {\n\t\t\t\t\tlocals->ViewportSizeSupport[i][0] = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (locals->SwathWidthYSingleDPP[k] / 2.0 > locals->MaximumSwathWidth[k]) {\n\t\t\t\t\tlocals->ViewportSizeSupport[i][0] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (locals->TotalNumberOfActiveDPP[i][j] <= mode_lib->vba.MaxNumDPP)\n\t\t\t\tlocals->TotalAvailablePipesSupport[i][j] = true;\n\t\t\telse\n\t\t\t\tlocals->TotalAvailablePipesSupport[i][j] = false;\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.TotalNumberOfActiveOTG = 0.0;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\tmode_lib->vba.TotalNumberOfActiveOTG = mode_lib->vba.TotalNumberOfActiveOTG\n\t\t\t\t\t+ 1.0;\n\t\t}\n\t}\n\tif (mode_lib->vba.TotalNumberOfActiveOTG <= mode_lib->vba.MaxNumOTG) {\n\t\tmode_lib->vba.NumberOfOTGSupport = true;\n\t} else {\n\t\tmode_lib->vba.NumberOfOTGSupport = false;\n\t}\n\t \n\n\tmode_lib->vba.NonsupportedDSCInputBPC = false;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (!(mode_lib->vba.DSCInputBitPerComponent[k] == 12.0\n\t\t\t\t|| mode_lib->vba.DSCInputBitPerComponent[k] == 10.0\n\t\t\t\t|| mode_lib->vba.DSCInputBitPerComponent[k] == 8.0)) {\n\t\t\tmode_lib->vba.NonsupportedDSCInputBPC = true;\n\t\t}\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tlocals->RequiresDSC[i][k] = false;\n\t\t\tlocals->RequiresFEC[i][k] = 0;\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\t\tif (mode_lib->vba.Output[k] == dm_hdmi) {\n\t\t\t\t\tlocals->RequiresDSC[i][k] = false;\n\t\t\t\t\tlocals->RequiresFEC[i][k] = 0;\n\t\t\t\t\tlocals->OutputBppPerState[i][k] = TruncToValidBPP(\n\t\t\t\t\t\t\tdml_min(600.0, mode_lib->vba.PHYCLKPerState[i]) / mode_lib->vba.PixelClockBackEnd[k] * 24,\n\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t} else if (mode_lib->vba.Output[k] == dm_dp\n\t\t\t\t\t\t|| mode_lib->vba.Output[k] == dm_edp) {\n\t\t\t\t\tif (mode_lib->vba.Output[k] == dm_edp) {\n\t\t\t\t\t\tmode_lib->vba.EffectiveFECOverhead = 0.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode_lib->vba.EffectiveFECOverhead =\n\t\t\t\t\t\t\t\tmode_lib->vba.FECOverhead;\n\t\t\t\t\t}\n\t\t\t\t\tif (mode_lib->vba.PHYCLKPerState[i] >= 270.0) {\n\t\t\t\t\t\tmode_lib->vba.Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * 270.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tmode_lib->vba.OutbppDSC = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 270.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tif (mode_lib->vba.DSCEnabled[k] == true) {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\tif (mode_lib->vba.Output[k] == dm_dp) {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = false;\n\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlocals->OutputBppPerState[i][k] = mode_lib->vba.Outbpp;\n\t\t\t\t\t}\n\t\t\t\t\tif (mode_lib->vba.Outbpp == BPP_INVALID && mode_lib->vba.PHYCLKPerState[i] >= 540.0) {\n\t\t\t\t\t\tmode_lib->vba.Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * 540.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tmode_lib->vba.OutbppDSC = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 540.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tif (mode_lib->vba.DSCEnabled[k] == true) {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\tif (mode_lib->vba.Output[k] == dm_dp) {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = false;\n\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlocals->OutputBppPerState[i][k] = mode_lib->vba.Outbpp;\n\t\t\t\t\t}\n\t\t\t\t\tif (mode_lib->vba.Outbpp == BPP_INVALID\n\t\t\t\t\t\t\t&& mode_lib->vba.PHYCLKPerState[i]\n\t\t\t\t\t\t\t\t\t>= 810.0) {\n\t\t\t\t\t\tmode_lib->vba.Outbpp = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * 810.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tmode_lib->vba.OutbppDSC = TruncToValidBPP(\n\t\t\t\t\t\t\t\t(1.0 - mode_lib->vba.Downspreading / 100.0) * (1.0 - mode_lib->vba.EffectiveFECOverhead / 100.0) * 810.0\n\t\t\t\t\t\t\t\t* mode_lib->vba.OutputLinkDPLanes[k] / mode_lib->vba.PixelClockBackEnd[k] * 8.0,\n\t\t\t\t\t\t\t\tmode_lib->vba.ForcedOutputLinkBPP[k],\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tmode_lib->vba.Output[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k],\n\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k]);\n\t\t\t\t\t\tif (mode_lib->vba.DSCEnabled[k] == true || mode_lib->vba.Outbpp == BPP_INVALID) {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = true;\n\t\t\t\t\t\t\tif (mode_lib->vba.Output[k] == dm_dp) {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmode_lib->vba.Outbpp = mode_lib->vba.OutbppDSC;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocals->RequiresDSC[i][k] = false;\n\t\t\t\t\t\t\tlocals->RequiresFEC[i][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlocals->OutputBppPerState[i][k] =\n\t\t\t\t\t\t\t\tmode_lib->vba.Outbpp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlocals->OutputBppPerState[i][k] = BPP_BLENDED_PIPE;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tlocals->DIOSupport[i] = true;\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tif (!mode_lib->vba.skip_dio_check[k]\n\t\t\t\t\t&& (locals->OutputBppPerState[i][k] == BPP_INVALID\n\t\t\t\t\t\t|| (mode_lib->vba.OutputFormat[k] == dm_420\n\t\t\t\t\t\t\t&& mode_lib->vba.Interlace[k] == true\n\t\t\t\t\t\t\t&& mode_lib->vba.ProgressiveToInterlaceUnitInOPP == true))) {\n\t\t\t\tlocals->DIOSupport[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tlocals->DSCCLKRequiredMoreThanSupported[i] = false;\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\t\tif ((mode_lib->vba.Output[k] == dm_dp\n\t\t\t\t\t\t|| mode_lib->vba.Output[k] == dm_edp)) {\n\t\t\t\t\tif (mode_lib->vba.OutputFormat[k] == dm_420\n\t\t\t\t\t\t\t|| mode_lib->vba.OutputFormat[k]\n\t\t\t\t\t\t\t\t\t== dm_n422) {\n\t\t\t\t\t\tmode_lib->vba.DSCFormatFactor = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode_lib->vba.DSCFormatFactor = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (locals->RequiresDSC[i][k] == true) {\n\t\t\t\t\t\tif (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\t\t\tif (mode_lib->vba.PixelClockBackEnd[k] / 6.0 / mode_lib->vba.DSCFormatFactor\n\t\t\t\t\t\t\t\t\t> (1.0 - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * mode_lib->vba.MaxDSCCLK[i]) {\n\t\t\t\t\t\t\t\tlocals->DSCCLKRequiredMoreThanSupported[i] =\n\t\t\t\t\t\t\t\t\t\ttrue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (mode_lib->vba.PixelClockBackEnd[k] / 3.0 / mode_lib->vba.DSCFormatFactor\n\t\t\t\t\t\t\t\t\t> (1.0 - mode_lib->vba.DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * mode_lib->vba.MaxDSCCLK[i]) {\n\t\t\t\t\t\t\t\tlocals->DSCCLKRequiredMoreThanSupported[i] =\n\t\t\t\t\t\t\t\t\t\ttrue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tlocals->NotEnoughDSCUnits[i] = false;\n\t\tmode_lib->vba.TotalDSCUnitsRequired = 0.0;\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tif (locals->RequiresDSC[i][k] == true) {\n\t\t\t\tif (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tmode_lib->vba.TotalDSCUnitsRequired =\n\t\t\t\t\t\t\tmode_lib->vba.TotalDSCUnitsRequired + 2.0;\n\t\t\t\t} else {\n\t\t\t\t\tmode_lib->vba.TotalDSCUnitsRequired =\n\t\t\t\t\t\t\tmode_lib->vba.TotalDSCUnitsRequired + 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mode_lib->vba.TotalDSCUnitsRequired > mode_lib->vba.NumberOfDSC) {\n\t\t\tlocals->NotEnoughDSCUnits[i] = true;\n\t\t}\n\t}\n\t \n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tif (mode_lib->vba.BlendingAndTiming[k] != k) {\n\t\t\t\tmode_lib->vba.slices = 0;\n\t\t\t} else if (locals->RequiresDSC[i][k] == 0\n\t\t\t\t\t|| locals->RequiresDSC[i][k] == false) {\n\t\t\t\tmode_lib->vba.slices = 0;\n\t\t\t} else if (mode_lib->vba.PixelClockBackEnd[k] > 3200.0) {\n\t\t\t\tmode_lib->vba.slices = dml_ceil(\n\t\t\t\t\t\tmode_lib->vba.PixelClockBackEnd[k] / 400.0,\n\t\t\t\t\t\t4.0);\n\t\t\t} else if (mode_lib->vba.PixelClockBackEnd[k] > 1360.0) {\n\t\t\t\tmode_lib->vba.slices = 8.0;\n\t\t\t} else if (mode_lib->vba.PixelClockBackEnd[k] > 680.0) {\n\t\t\t\tmode_lib->vba.slices = 4.0;\n\t\t\t} else if (mode_lib->vba.PixelClockBackEnd[k] > 340.0) {\n\t\t\t\tmode_lib->vba.slices = 2.0;\n\t\t\t} else {\n\t\t\t\tmode_lib->vba.slices = 1.0;\n\t\t\t}\n\t\t\tif (locals->OutputBppPerState[i][k] == BPP_BLENDED_PIPE\n\t\t\t\t\t|| locals->OutputBppPerState[i][k] == BPP_INVALID) {\n\t\t\t\tmode_lib->vba.bpp = 0.0;\n\t\t\t} else {\n\t\t\t\tmode_lib->vba.bpp = locals->OutputBppPerState[i][k];\n\t\t\t}\n\t\t\tif (locals->RequiresDSC[i][k] == true && mode_lib->vba.bpp != 0.0) {\n\t\t\t\tif (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_disabled) {\n\t\t\t\t\tlocals->DSCDelayPerState[i][k] =\n\t\t\t\t\t\t\tdscceComputeDelay(\n\t\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\tmode_lib->vba.bpp,\n\t\t\t\t\t\t\t\t\tdml_ceil(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.HActive[k]\n\t\t\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.slices,\n\t\t\t\t\t\t\t\t\t\t\t1.0),\n\t\t\t\t\t\t\t\t\tmode_lib->vba.slices,\n\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k])\n\t\t\t\t\t\t\t\t\t+ dscComputeDelay(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k]);\n\t\t\t\t} else {\n\t\t\t\t\tlocals->DSCDelayPerState[i][k] =\n\t\t\t\t\t\t\t2.0 * (dscceComputeDelay(\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.DSCInputBitPerComponent[k],\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.bpp,\n\t\t\t\t\t\t\t\t\t\t\tdml_ceil(mode_lib->vba.HActive[k] / mode_lib->vba.slices, 1.0),\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.slices / 2,\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.OutputFormat[k])\n\t\t\t\t\t\t\t\t\t+ dscComputeDelay(mode_lib->vba.OutputFormat[k]));\n\t\t\t\t}\n\t\t\t\tlocals->DSCDelayPerState[i][k] =\n\t\t\t\t\t\tlocals->DSCDelayPerState[i][k] * mode_lib->vba.PixelClock[k] / mode_lib->vba.PixelClockBackEnd[k];\n\t\t\t} else {\n\t\t\t\tlocals->DSCDelayPerState[i][k] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tfor (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {\n\t\t\t\tfor (j = 0; j <= mode_lib->vba.NumberOfActivePlanes - 1; j++) {\n\t\t\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == m && locals->RequiresDSC[i][m] == true)\n\t\t\t\t\t\tlocals->DSCDelayPerState[i][k] = locals->DSCDelayPerState[i][m];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; ++i) {\n\t\tfor (j = 0; j <= 1; ++j) {\n\t\t\tlocals->TotalNumberOfDCCActiveDPP[i][j] = 0;\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tif (mode_lib->vba.DCCEnable[k] == true)\n\t\t\t\t\tlocals->TotalNumberOfDCCActiveDPP[i][j] = locals->TotalNumberOfDCCActiveDPP[i][j] + locals->NoOfDPP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tmode_lib->vba.UrgentLatency = dml_max3(\n\t\t\tmode_lib->vba.UrgentLatencyPixelDataOnly,\n\t\t\tmode_lib->vba.UrgentLatencyPixelMixedWithVMData,\n\t\t\tmode_lib->vba.UrgentLatencyVMDataOnly);\n\tmode_lib->vba.PrefetchERROR = CalculateMinAndMaxPrefetchMode(\n\t\t\tmode_lib->vba.AllowDRAMSelfRefreshOrDRAMClockChangeInVblank,\n\t\t\t&mode_lib->vba.MinPrefetchMode,\n\t\t\t&mode_lib->vba.MaxPrefetchMode);\n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tlocals->RequiredDPPCLKThisState[k] = locals->RequiredDPPCLK[i][j][k];\n\t\t\t\tlocals->NoOfDPPThisState[k]        = locals->NoOfDPP[i][j][k];\n\t\t\t\tif (locals->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {\n\t\t\t\t\tlocals->SwathWidthYThisState[k] =\n\t\t\t\t\t\tdml_min(locals->SwathWidthYSingleDPP[k], dml_round(mode_lib->vba.HActive[k] / 2.0 * mode_lib->vba.HRatio[k]));\n\t\t\t\t} else {\n\t\t\t\t\tlocals->SwathWidthYThisState[k] = locals->SwathWidthYSingleDPP[k] / locals->NoOfDPP[i][j][k];\n\t\t\t\t}\n\t\t\t\tmode_lib->vba.SwathWidthGranularityY = 256.0\n\t\t\t\t\t/ dml_ceil(locals->BytePerPixelInDETY[k], 1.0)\n\t\t\t\t\t/ locals->MaxSwathHeightY[k];\n\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesY =\n\t\t\t\t\t(dml_ceil(locals->SwathWidthYThisState[k] - 1.0, mode_lib->vba.SwathWidthGranularityY)\n\t\t\t\t\t+ mode_lib->vba.SwathWidthGranularityY) * locals->BytePerPixelInDETY[k] * locals->MaxSwathHeightY[k];\n\t\t\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {\n\t\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesY = dml_ceil(\n\t\t\t\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesY,\n\t\t\t\t\t\t\t256.0) + 256;\n\t\t\t\t}\n\t\t\t\tif (locals->MaxSwathHeightC[k] > 0.0) {\n\t\t\t\t\tmode_lib->vba.SwathWidthGranularityC = 256.0 / dml_ceil(locals->BytePerPixelInDETC[k], 2.0) / locals->MaxSwathHeightC[k];\n\t\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesC = (dml_ceil(locals->SwathWidthYThisState[k] / 2.0 - 1.0, mode_lib->vba.SwathWidthGranularityC)\n\t\t\t\t\t\t\t+ mode_lib->vba.SwathWidthGranularityC) * locals->BytePerPixelInDETC[k] * locals->MaxSwathHeightC[k];\n\t\t\t\t\tif (mode_lib->vba.SourcePixelFormat[k] == dm_420_10) {\n\t\t\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesC = dml_ceil(mode_lib->vba.RoundedUpMaxSwathSizeBytesC, 256.0) + 256;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmode_lib->vba.RoundedUpMaxSwathSizeBytesC = 0.0;\n\t\t\t\t}\n\t\t\t\tif (mode_lib->vba.RoundedUpMaxSwathSizeBytesY + mode_lib->vba.RoundedUpMaxSwathSizeBytesC\n\t\t\t\t\t\t<= mode_lib->vba.DETBufferSizeInKByte[0] * 1024.0 / 2.0) {\n\t\t\t\t\tlocals->SwathHeightYThisState[k] = locals->MaxSwathHeightY[k];\n\t\t\t\t\tlocals->SwathHeightCThisState[k] = locals->MaxSwathHeightC[k];\n\t\t\t\t} else {\n\t\t\t\t\tlocals->SwathHeightYThisState[k] =\n\t\t\t\t\t\t\tlocals->MinSwathHeightY[k];\n\t\t\t\t\tlocals->SwathHeightCThisState[k] =\n\t\t\t\t\t\t\tlocals->MinSwathHeightC[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCalculateDCFCLKDeepSleep(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\t\t\tlocals->BytePerPixelInDETY,\n\t\t\t\t\tlocals->BytePerPixelInDETC,\n\t\t\t\t\tmode_lib->vba.VRatio,\n\t\t\t\t\tlocals->SwathWidthYThisState,\n\t\t\t\t\tlocals->NoOfDPPThisState,\n\t\t\t\t\tmode_lib->vba.HRatio,\n\t\t\t\t\tmode_lib->vba.PixelClock,\n\t\t\t\t\tlocals->PSCL_FACTOR,\n\t\t\t\t\tlocals->PSCL_FACTOR_CHROMA,\n\t\t\t\t\tlocals->RequiredDPPCLKThisState,\n\t\t\t\t\t&mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0]);\n\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif ((mode_lib->vba.SourcePixelFormat[k] != dm_444_64\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_32\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_8)) {\n\t\t\t\t\tmode_lib->vba.PDEAndMetaPTEBytesPerFrameC = CalculateVMAndRowBytes(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\t\tlocals->Read256BlockHeightC[k],\n\t\t\t\t\t\t\tlocals->Read256BlockWidthC[k],\n\t\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\t\t\t\tdml_ceil(locals->BytePerPixelInDETC[k], 2.0),\n\t\t\t\t\t\t\tmode_lib->vba.SourceScan[k],\n\t\t\t\t\t\t\tmode_lib->vba.ViewportWidth[k] / 2.0,\n\t\t\t\t\t\t\tmode_lib->vba.ViewportHeight[k] / 2.0,\n\t\t\t\t\t\t\tlocals->SwathWidthYThisState[k] / 2.0,\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.VMMPageSize,\n\t\t\t\t\t\t\tmode_lib->vba.PTEBufferSizeInRequestsChroma,\n\t\t\t\t\t\t\tmode_lib->vba.PitchC[k],\n\t\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t\t&locals->MacroTileWidthC[k],\n\t\t\t\t\t\t\t&mode_lib->vba.MetaRowBytesC,\n\t\t\t\t\t\t\t&mode_lib->vba.DPTEBytesPerRowC,\n\t\t\t\t\t\t\t&locals->PTEBufferSizeNotExceededC[i][j][k],\n\t\t\t\t\t\t\tlocals->dpte_row_width_chroma_ub,\n\t\t\t\t\t\t\t&locals->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_req_width_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_req_height_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_row_width_chroma[k],\n\t\t\t\t\t\t\t&locals->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t&locals->vm_group_bytes_chroma,\n\t\t\t\t\t\t\t&locals->dpte_group_bytes_chroma,\n\t\t\t\t\t\t\tlocals->PixelPTEReqWidthC,\n\t\t\t\t\t\t\tlocals->PixelPTEReqHeightC,\n\t\t\t\t\t\t\tlocals->PTERequestSizeC,\n\t\t\t\t\t\t\tlocals->dpde0_bytes_per_frame_ub_c,\n\t\t\t\t\t\t\tlocals->meta_pte_bytes_per_frame_ub_c);\n\t\t\t\t\tlocals->PrefetchLinesC[0][0][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tmode_lib->vba.VRatio[k]/2,\n\t\t\t\t\t\t\tmode_lib->vba.VTAPsChroma[k],\n\t\t\t\t\t\t\tmode_lib->vba.Interlace[k],\n\t\t\t\t\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\t\tlocals->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tmode_lib->vba.ViewportYStartC[k],\n\t\t\t\t\t\t\t&locals->PrefillC[k],\n\t\t\t\t\t\t\t&locals->MaxNumSwC[k]);\n\t\t\t\t\tlocals->PTEBufferSizeInRequestsForLuma = mode_lib->vba.PTEBufferSizeInRequestsLuma;\n\t\t\t\t} else {\n\t\t\t\t\tmode_lib->vba.PDEAndMetaPTEBytesPerFrameC = 0.0;\n\t\t\t\t\tmode_lib->vba.MetaRowBytesC = 0.0;\n\t\t\t\t\tmode_lib->vba.DPTEBytesPerRowC = 0.0;\n\t\t\t\t\tlocals->PrefetchLinesC[0][0][k] = 0.0;\n\t\t\t\t\tlocals->PTEBufferSizeNotExceededC[i][j][k] = true;\n\t\t\t\t\tlocals->PTEBufferSizeInRequestsForLuma = mode_lib->vba.PTEBufferSizeInRequestsLuma + mode_lib->vba.PTEBufferSizeInRequestsChroma;\n\t\t\t\t}\n\t\t\t\tmode_lib->vba.PDEAndMetaPTEBytesPerFrameY = CalculateVMAndRowBytes(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\tlocals->Read256BlockHeightY[k],\n\t\t\t\t\t\tlocals->Read256BlockWidthY[k],\n\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\tmode_lib->vba.SurfaceTiling[k],\n\t\t\t\t\t\tdml_ceil(locals->BytePerPixelInDETY[k], 1.0),\n\t\t\t\t\t\tmode_lib->vba.SourceScan[k],\n\t\t\t\t\t\tmode_lib->vba.ViewportWidth[k],\n\t\t\t\t\t\tmode_lib->vba.ViewportHeight[k],\n\t\t\t\t\t\tlocals->SwathWidthYThisState[k],\n\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\t\t\tmode_lib->vba.VMMPageSize,\n\t\t\t\t\t\tlocals->PTEBufferSizeInRequestsForLuma,\n\t\t\t\t\t\tmode_lib->vba.PitchY[k],\n\t\t\t\t\t\tmode_lib->vba.DCCMetaPitchY[k],\n\t\t\t\t\t\t&locals->MacroTileWidthY[k],\n\t\t\t\t\t\t&mode_lib->vba.MetaRowBytesY,\n\t\t\t\t\t\t&mode_lib->vba.DPTEBytesPerRowY,\n\t\t\t\t\t\t&locals->PTEBufferSizeNotExceededY[i][j][k],\n\t\t\t\t\t\tlocals->dpte_row_width_luma_ub,\n\t\t\t\t\t\t&locals->dpte_row_height[k],\n\t\t\t\t\t\t&locals->meta_req_width[k],\n\t\t\t\t\t\t&locals->meta_req_height[k],\n\t\t\t\t\t\t&locals->meta_row_width[k],\n\t\t\t\t\t\t&locals->meta_row_height[k],\n\t\t\t\t\t\t&locals->vm_group_bytes[k],\n\t\t\t\t\t\t&locals->dpte_group_bytes[k],\n\t\t\t\t\t\tlocals->PixelPTEReqWidthY,\n\t\t\t\t\t\tlocals->PixelPTEReqHeightY,\n\t\t\t\t\t\tlocals->PTERequestSizeY,\n\t\t\t\t\t\tlocals->dpde0_bytes_per_frame_ub_l,\n\t\t\t\t\t\tlocals->meta_pte_bytes_per_frame_ub_l);\n\t\t\t\tlocals->PrefetchLinesY[0][0][k] = CalculatePrefetchSourceLines(\n\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\tmode_lib->vba.vtaps[k],\n\t\t\t\t\t\tmode_lib->vba.Interlace[k],\n\t\t\t\t\t\tmode_lib->vba.ProgressiveToInterlaceUnitInOPP,\n\t\t\t\t\t\tlocals->SwathHeightYThisState[k],\n\t\t\t\t\t\tmode_lib->vba.ViewportYStartY[k],\n\t\t\t\t\t\t&locals->PrefillY[k],\n\t\t\t\t\t\t&locals->MaxNumSwY[k]);\n\t\t\t\tlocals->PDEAndMetaPTEBytesPerFrame[0][0][k] =\n\t\t\t\t\t\tmode_lib->vba.PDEAndMetaPTEBytesPerFrameY + mode_lib->vba.PDEAndMetaPTEBytesPerFrameC;\n\t\t\t\tlocals->MetaRowBytes[0][0][k] = mode_lib->vba.MetaRowBytesY + mode_lib->vba.MetaRowBytesC;\n\t\t\t\tlocals->DPTEBytesPerRow[0][0][k] = mode_lib->vba.DPTEBytesPerRowY + mode_lib->vba.DPTEBytesPerRowC;\n\n\t\t\t\tCalculateActiveRowBandwidth(\n\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\tmode_lib->vba.HTotal[k] /\n\t\t\t\t\t\tmode_lib->vba.PixelClock[k],\n\t\t\t\t\t\tmode_lib->vba.MetaRowBytesY,\n\t\t\t\t\t\tmode_lib->vba.MetaRowBytesC,\n\t\t\t\t\t\tlocals->meta_row_height[k],\n\t\t\t\t\t\tlocals->meta_row_height_chroma[k],\n\t\t\t\t\t\tmode_lib->vba.DPTEBytesPerRowY,\n\t\t\t\t\t\tmode_lib->vba.DPTEBytesPerRowC,\n\t\t\t\t\t\tlocals->dpte_row_height[k],\n\t\t\t\t\t\tlocals->dpte_row_height_chroma[k],\n\t\t\t\t\t\t&locals->meta_row_bw[k],\n\t\t\t\t\t\t&locals->dpte_row_bw[k]);\n\t\t\t}\n\t\t\tmode_lib->vba.ExtraLatency = CalculateExtraLatency(\n\t\t\t\t\tlocals->UrgentRoundTripAndOutOfOrderLatencyPerState[i],\n\t\t\t\t\tlocals->TotalNumberOfActiveDPP[i][j],\n\t\t\t\t\tmode_lib->vba.PixelChunkSizeInKByte,\n\t\t\t\t\tlocals->TotalNumberOfDCCActiveDPP[i][j],\n\t\t\t\t\tmode_lib->vba.MetaChunkSize,\n\t\t\t\t\tlocals->ReturnBWPerState[i][0],\n\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\t\t\tlocals->NoOfDPPThisState,\n\t\t\t\t\tlocals->dpte_group_bytes,\n\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels);\n\n\t\t\tmode_lib->vba.TimeCalc = 24.0 / mode_lib->vba.ProjectedDCFCLKDeepSleep[0][0];\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\t\t\tif (mode_lib->vba.WritebackEnable[k] == true) {\n\t\t\t\t\t\tlocals->WritebackDelay[i][k] = mode_lib->vba.WritebackLatency\n\t\t\t\t\t\t\t\t+ CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[k],\n\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[k]) / locals->RequiredDISPCLK[i][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocals->WritebackDelay[i][k] = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {\n\t\t\t\t\t\tif (mode_lib->vba.BlendingAndTiming[m] == k\n\t\t\t\t\t\t\t\t&& mode_lib->vba.WritebackEnable[m]\n\t\t\t\t\t\t\t\t\t\t== true) {\n\t\t\t\t\t\t\tlocals->WritebackDelay[i][k] = dml_max(locals->WritebackDelay[i][k],\n\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLatency + CalculateWriteBackDelay(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackPixelFormat[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackHRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackVRatio[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaHTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackLumaVTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaHTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackChromaVTaps[m],\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth[m]) / locals->RequiredDISPCLK[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tfor (m = 0; m <= mode_lib->vba.NumberOfActivePlanes - 1; m++) {\n\t\t\t\t\tif (mode_lib->vba.BlendingAndTiming[k] == m) {\n\t\t\t\t\t\tlocals->WritebackDelay[i][k] = locals->WritebackDelay[i][m];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmode_lib->vba.MaxMaxVStartup[0][0] = 0;\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tlocals->MaximumVStartup[0][0][k] = mode_lib->vba.VTotal[k] - mode_lib->vba.VActive[k]\n\t\t\t\t\t- dml_max(1.0, dml_ceil(locals->WritebackDelay[i][k] / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]), 1.0));\n\t\t\t\tmode_lib->vba.MaxMaxVStartup[0][0] = dml_max(mode_lib->vba.MaxMaxVStartup[0][0], locals->MaximumVStartup[0][0][k]);\n\t\t\t}\n\n\t\t\tmode_lib->vba.NextPrefetchMode = mode_lib->vba.MinPrefetchMode;\n\t\t\tmode_lib->vba.NextMaxVStartup = mode_lib->vba.MaxMaxVStartup[0][0];\n\t\t\tdo {\n\t\t\t\tmode_lib->vba.PrefetchMode[i][j] = mode_lib->vba.NextPrefetchMode;\n\t\t\t\tmode_lib->vba.MaxVStartup = mode_lib->vba.NextMaxVStartup;\n\n\t\t\t\tmode_lib->vba.TWait = CalculateTWait(\n\t\t\t\t\t\tmode_lib->vba.PrefetchMode[i][j],\n\t\t\t\t\t\tmode_lib->vba.DRAMClockChangeLatency,\n\t\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\t\tmode_lib->vba.SREnterPlusExitTime);\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++)\n\t\t\t\t\tCalculatePrefetchSchedulePerPlane(mode_lib, i, j, k);\n\n\t\t\t\tmode_lib->vba.MaximumReadBandwidthWithoutPrefetch = 0.0;\n\t\t\t\tmode_lib->vba.MaximumReadBandwidthWithPrefetch = 0.0;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tunsigned int m;\n\n\t\t\t\t\tlocals->cursor_bw[k] = 0;\n\t\t\t\t\tlocals->cursor_bw_pre[k] = 0;\n\t\t\t\t\tfor (m = 0; m < mode_lib->vba.NumberOfCursors[k]; m++) {\n\t\t\t\t\t\tlocals->cursor_bw[k] = mode_lib->vba.CursorWidth[k][m] * mode_lib->vba.CursorBPP[k][m]\n\t\t\t\t\t\t\t/ 8.0 / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * mode_lib->vba.VRatio[k];\n\t\t\t\t\t\tlocals->cursor_bw_pre[k] = mode_lib->vba.CursorWidth[k][m] * mode_lib->vba.CursorBPP[k][m]\n\t\t\t\t\t\t\t/ 8.0 / (mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k]) * locals->VRatioPreY[i][j][k];\n\t\t\t\t\t}\n\n\t\t\t\t\tCalculateUrgentBurstFactor(\n\t\t\t\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\t\t\t\t\tlocals->SwathHeightYThisState[k],\n\t\t\t\t\t\t\tlocals->SwathHeightCThisState[k],\n\t\t\t\t\t\t\tlocals->SwathWidthYThisState[k],\n\t\t\t\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\t\t\tmode_lib->vba.CursorBufferSize,\n\t\t\t\t\t\t\tmode_lib->vba.CursorWidth[k][0] + mode_lib->vba.CursorWidth[k][1],\n\t\t\t\t\t\t\tdml_max(mode_lib->vba.CursorBPP[k][0], mode_lib->vba.CursorBPP[k][1]),\n\t\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\t\tlocals->VRatioPreY[i][j][k],\n\t\t\t\t\t\t\tlocals->VRatioPreC[i][j][k],\n\t\t\t\t\t\t\tlocals->BytePerPixelInDETY[k],\n\t\t\t\t\t\t\tlocals->BytePerPixelInDETC[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorCursorPre[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorLuma[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorLumaPre[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorChroma[k],\n\t\t\t\t\t\t\t&locals->UrgentBurstFactorChromaPre[k],\n\t\t\t\t\t\t\t&locals->NotEnoughUrgentLatencyHiding[0][0],\n\t\t\t\t\t\t\t&locals->NotEnoughUrgentLatencyHidingPre);\n\n\t\t\t\t\tif (mode_lib->vba.UseUrgentBurstBandwidth == false) {\n\t\t\t\t\t\tlocals->UrgentBurstFactorCursor[k] = 1;\n\t\t\t\t\t\tlocals->UrgentBurstFactorCursorPre[k] = 1;\n\t\t\t\t\t\tlocals->UrgentBurstFactorLuma[k] = 1;\n\t\t\t\t\t\tlocals->UrgentBurstFactorLumaPre[k] = 1;\n\t\t\t\t\t\tlocals->UrgentBurstFactorChroma[k] = 1;\n\t\t\t\t\t\tlocals->UrgentBurstFactorChromaPre[k] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tmode_lib->vba.MaximumReadBandwidthWithoutPrefetch = mode_lib->vba.MaximumReadBandwidthWithoutPrefetch\n\t\t\t\t\t\t+ locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k] + locals->ReadBandwidthLuma[k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorLuma[k] + locals->ReadBandwidthChroma[k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorChroma[k] + locals->meta_row_bw[k] + locals->dpte_row_bw[k];\n\t\t\t\t\tmode_lib->vba.MaximumReadBandwidthWithPrefetch = mode_lib->vba.MaximumReadBandwidthWithPrefetch\n\t\t\t\t\t\t+ dml_max3(locals->prefetch_vmrow_bw[k],\n\t\t\t\t\t\tlocals->ReadBandwidthLuma[k] * locals->UrgentBurstFactorLuma[k] + locals->ReadBandwidthChroma[k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorChroma[k] + locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k]\n\t\t\t\t\t\t+ locals->meta_row_bw[k] + locals->dpte_row_bw[k],\n\t\t\t\t\t\tlocals->RequiredPrefetchPixelDataBWLuma[i][j][k] * locals->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t+ locals->RequiredPrefetchPixelDataBWChroma[i][j][k] * locals->UrgentBurstFactorChromaPre[k]\n\t\t\t\t\t\t+ locals->cursor_bw_pre[k] * locals->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t}\n\t\t\t\tlocals->BandwidthWithoutPrefetchSupported[i][0] = true;\n\t\t\t\tif (mode_lib->vba.MaximumReadBandwidthWithoutPrefetch > locals->ReturnBWPerState[i][0]\n\t\t\t\t\t\t|| locals->NotEnoughUrgentLatencyHiding[0][0] == 1) {\n\t\t\t\t\tlocals->BandwidthWithoutPrefetchSupported[i][0] = false;\n\t\t\t\t}\n\n\t\t\t\tlocals->PrefetchSupported[i][j] = true;\n\t\t\t\tif (mode_lib->vba.MaximumReadBandwidthWithPrefetch > locals->ReturnBWPerState[i][0]\n\t\t\t\t\t\t|| locals->NotEnoughUrgentLatencyHiding[0][0] == 1\n\t\t\t\t\t\t|| locals->NotEnoughUrgentLatencyHidingPre == 1) {\n\t\t\t\t\tlocals->PrefetchSupported[i][j] = false;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (locals->LineTimesForPrefetch[k] < 2.0\n\t\t\t\t\t\t\t|| locals->LinesForMetaPTE[k] >= 32.0\n\t\t\t\t\t\t\t|| locals->LinesForMetaAndDPTERow[k] >= 16.0\n\t\t\t\t\t\t\t|| mode_lib->vba.IsErrorResult[i][j][k] == true) {\n\t\t\t\t\t\tlocals->PrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocals->VRatioInPrefetchSupported[i][j] = true;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (locals->VRatioPreY[i][j][k] > 4.0\n\t\t\t\t\t\t\t|| locals->VRatioPreC[i][j][k] > 4.0\n\t\t\t\t\t\t\t|| mode_lib->vba.IsErrorResult[i][j][k] == true) {\n\t\t\t\t\t\tlocals->VRatioInPrefetchSupported[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmode_lib->vba.AnyLinesForVMOrRowTooLarge = false;\n\t\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\t\tif (locals->LinesForMetaAndDPTERow[k] >= 16 || locals->LinesForMetaPTE[k] >= 32) {\n\t\t\t\t\t\tmode_lib->vba.AnyLinesForVMOrRowTooLarge = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mode_lib->vba.MaxVStartup <= 13 || mode_lib->vba.AnyLinesForVMOrRowTooLarge == false) {\n\t\t\t\t\tmode_lib->vba.NextMaxVStartup = mode_lib->vba.MaxMaxVStartup[0][0];\n\t\t\t\t\tmode_lib->vba.NextPrefetchMode = mode_lib->vba.NextPrefetchMode + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmode_lib->vba.NextMaxVStartup = mode_lib->vba.NextMaxVStartup - 1;\n\t\t\t\t}\n\t\t\t} while ((locals->PrefetchSupported[i][j] != true || locals->VRatioInPrefetchSupported[i][j] != true)\n\t\t\t\t\t&& (mode_lib->vba.NextMaxVStartup != mode_lib->vba.MaxMaxVStartup[0][0]\n\t\t\t\t\t\t|| mode_lib->vba.NextPrefetchMode <= mode_lib->vba.MaxPrefetchMode));\n\n\t\t\tif (locals->PrefetchSupported[i][j] == true && locals->VRatioInPrefetchSupported[i][j] == true) {\n\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip = locals->ReturnBWPerState[i][0];\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip = mode_lib->vba.BandwidthAvailableForImmediateFlip\n\t\t\t\t\t\t- dml_max(locals->ReadBandwidthLuma[k] * locals->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t\t+ locals->ReadBandwidthChroma[k] * locals->UrgentBurstFactorChroma[k]\n\t\t\t\t\t\t\t+ locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\t\tlocals->RequiredPrefetchPixelDataBWLuma[i][j][k] * locals->UrgentBurstFactorLumaPre[k]\n\t\t\t\t\t\t\t+ locals->RequiredPrefetchPixelDataBWChroma[i][j][k] * locals->UrgentBurstFactorChromaPre[k]\n\t\t\t\t\t\t\t+ locals->cursor_bw_pre[k] * locals->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t}\n\t\t\t\tmode_lib->vba.TotImmediateFlipBytes = 0.0;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tmode_lib->vba.TotImmediateFlipBytes = mode_lib->vba.TotImmediateFlipBytes\n\t\t\t\t\t\t+ locals->PDEAndMetaPTEBytesPerFrame[0][0][k] + locals->MetaRowBytes[0][0][k] + locals->DPTEBytesPerRow[0][0][k];\n\t\t\t\t}\n\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tCalculateFlipSchedule(\n\t\t\t\t\t\t\tmode_lib,\n\t\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\t\t\t\t\t\tmode_lib->vba.PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\t\t\t\t\t\tmode_lib->vba.ExtraLatency,\n\t\t\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMMaxPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMEnable,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMMaxPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.HostVMCachedPageTableLevels,\n\t\t\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\t\t\tlocals->PDEAndMetaPTEBytesPerFrame[0][0][k],\n\t\t\t\t\t\t\tlocals->MetaRowBytes[0][0][k],\n\t\t\t\t\t\t\tlocals->DPTEBytesPerRow[0][0][k],\n\t\t\t\t\t\t\tmode_lib->vba.BandwidthAvailableForImmediateFlip,\n\t\t\t\t\t\t\tmode_lib->vba.TotImmediateFlipBytes,\n\t\t\t\t\t\t\tmode_lib->vba.SourcePixelFormat[k],\n\t\t\t\t\t\t\tmode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],\n\t\t\t\t\t\t\tmode_lib->vba.VRatio[k],\n\t\t\t\t\t\t\tlocals->Tno_bw[k],\n\t\t\t\t\t\t\tmode_lib->vba.DCCEnable[k],\n\t\t\t\t\t\t\tlocals->dpte_row_height[k],\n\t\t\t\t\t\t\tlocals->meta_row_height[k],\n\t\t\t\t\t\t\tlocals->dpte_row_height_chroma[k],\n\t\t\t\t\t\t\tlocals->meta_row_height_chroma[k],\n\t\t\t\t\t\t\t&locals->DestinationLinesToRequestVMInImmediateFlip[k],\n\t\t\t\t\t\t\t&locals->DestinationLinesToRequestRowInImmediateFlip[k],\n\t\t\t\t\t\t\t&locals->final_flip_bw[k],\n\t\t\t\t\t\t\t&locals->ImmediateFlipSupportedForPipe[k]);\n\t\t\t\t}\n\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip = 0.0;\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tmode_lib->vba.total_dcn_read_bw_with_flip = mode_lib->vba.total_dcn_read_bw_with_flip + dml_max3(\n\t\t\t\t\t\tlocals->prefetch_vmrow_bw[k],\n\t\t\t\t\t\tlocals->final_flip_bw[k] +  locals->ReadBandwidthLuma[k] * locals->UrgentBurstFactorLuma[k]\n\t\t\t\t\t\t+ locals->ReadBandwidthChroma[k] * locals->UrgentBurstFactorChroma[k]\n\t\t\t\t\t\t+ locals->cursor_bw[k] * locals->UrgentBurstFactorCursor[k],\n\t\t\t\t\t\tlocals->final_flip_bw[k] + locals->RequiredPrefetchPixelDataBWLuma[i][j][k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorLumaPre[k] + locals->RequiredPrefetchPixelDataBWChroma[i][j][k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorChromaPre[k] + locals->cursor_bw_pre[k]\n\t\t\t\t\t\t* locals->UrgentBurstFactorCursorPre[k]);\n\t\t\t\t}\n\t\t\t\tlocals->ImmediateFlipSupportedForState[i][j] = true;\n\t\t\t\tif (mode_lib->vba.total_dcn_read_bw_with_flip\n\t\t\t\t\t\t> locals->ReturnBWPerState[i][0]) {\n\t\t\t\t\tlocals->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\t\tif (locals->ImmediateFlipSupportedForPipe[k] == false) {\n\t\t\t\t\t\tlocals->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlocals->ImmediateFlipSupportedForState[i][j] = false;\n\t\t\t}\n\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannel = dml_max3(\n\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelDataOnly,\n\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData,\n\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannelVMDataOnly);\n\t\t\tCalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\t\t\t\tmode_lib,\n\t\t\t\t\tmode_lib->vba.PrefetchMode[i][j],\n\t\t\t\t\tmode_lib->vba.NumberOfActivePlanes,\n\t\t\t\t\tmode_lib->vba.MaxLineBufferLines,\n\t\t\t\t\tmode_lib->vba.LineBufferSize,\n\t\t\t\t\tmode_lib->vba.DPPOutputBufferPixels,\n\t\t\t\t\tmode_lib->vba.DETBufferSizeInKByte[0],\n\t\t\t\t\tmode_lib->vba.WritebackInterfaceLumaBufferSize,\n\t\t\t\t\tmode_lib->vba.WritebackInterfaceChromaBufferSize,\n\t\t\t\t\tmode_lib->vba.DCFCLKPerState[i],\n\t\t\t\t\tmode_lib->vba.UrgentOutOfOrderReturnPerChannel * mode_lib->vba.NumberOfChannels,\n\t\t\t\t\tlocals->ReturnBWPerState[i][0],\n\t\t\t\t\tmode_lib->vba.GPUVMEnable,\n\t\t\t\t\tlocals->dpte_group_bytes,\n\t\t\t\t\tmode_lib->vba.MetaChunkSize,\n\t\t\t\t\tmode_lib->vba.UrgentLatency,\n\t\t\t\t\tmode_lib->vba.ExtraLatency,\n\t\t\t\t\tmode_lib->vba.WritebackLatency,\n\t\t\t\t\tmode_lib->vba.WritebackChunkSize,\n\t\t\t\t\tmode_lib->vba.SOCCLKPerState[i],\n\t\t\t\t\tmode_lib->vba.DRAMClockChangeLatency,\n\t\t\t\t\tmode_lib->vba.SRExitTime,\n\t\t\t\t\tmode_lib->vba.SREnterPlusExitTime,\n\t\t\t\t\tmode_lib->vba.ProjectedDCFCLKDeepSleep[0][0],\n\t\t\t\t\tlocals->NoOfDPPThisState,\n\t\t\t\t\tmode_lib->vba.DCCEnable,\n\t\t\t\t\tlocals->RequiredDPPCLKThisState,\n\t\t\t\t\tlocals->SwathWidthYSingleDPP,\n\t\t\t\t\tlocals->SwathHeightYThisState,\n\t\t\t\t\tlocals->ReadBandwidthLuma,\n\t\t\t\t\tlocals->SwathHeightCThisState,\n\t\t\t\t\tlocals->ReadBandwidthChroma,\n\t\t\t\t\tmode_lib->vba.LBBitPerPixel,\n\t\t\t\t\tlocals->SwathWidthYThisState,\n\t\t\t\t\tmode_lib->vba.HRatio,\n\t\t\t\t\tmode_lib->vba.vtaps,\n\t\t\t\t\tmode_lib->vba.VTAPsChroma,\n\t\t\t\t\tmode_lib->vba.VRatio,\n\t\t\t\t\tmode_lib->vba.HTotal,\n\t\t\t\t\tmode_lib->vba.PixelClock,\n\t\t\t\t\tmode_lib->vba.BlendingAndTiming,\n\t\t\t\t\tlocals->BytePerPixelInDETY,\n\t\t\t\t\tlocals->BytePerPixelInDETC,\n\t\t\t\t\tmode_lib->vba.WritebackEnable,\n\t\t\t\t\tmode_lib->vba.WritebackPixelFormat,\n\t\t\t\t\tmode_lib->vba.WritebackDestinationWidth,\n\t\t\t\t\tmode_lib->vba.WritebackDestinationHeight,\n\t\t\t\t\tmode_lib->vba.WritebackSourceHeight,\n\t\t\t\t\t&locals->DRAMClockChangeSupport[i][j],\n\t\t\t\t\t&mode_lib->vba.UrgentWatermark,\n\t\t\t\t\t&mode_lib->vba.WritebackUrgentWatermark,\n\t\t\t\t\t&mode_lib->vba.DRAMClockChangeWatermark,\n\t\t\t\t\t&mode_lib->vba.WritebackDRAMClockChangeWatermark,\n\t\t\t\t\t&mode_lib->vba.StutterExitWatermark,\n\t\t\t\t\t&mode_lib->vba.StutterEnterPlusExitWatermark,\n\t\t\t\t\t&mode_lib->vba.MinActiveDRAMClockChangeLatencySupported);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tdouble MaxTotalVActiveRDBandwidth = 0.0;\n\t\t\tfor (k = 0; k < mode_lib->vba.NumberOfActivePlanes; ++k) {\n\t\t\t\tMaxTotalVActiveRDBandwidth = MaxTotalVActiveRDBandwidth + locals->ReadBandwidth[k];\n\t\t}\n\t\tfor (i = 0; i <= mode_lib->vba.soc.num_states; ++i) {\n\t\t\tlocals->MaxTotalVerticalActiveAvailableBandwidth[i][0] = dml_min(\n\t\t\t\tlocals->IdealSDPPortBandwidthPerState[i][0] *\n\t\t\t\tmode_lib->vba.MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation\n\t\t\t\t/ 100.0, mode_lib->vba.DRAMSpeedPerState[i] *\n\t\t\t\tmode_lib->vba.NumberOfChannels *\n\t\t\t\tmode_lib->vba.DRAMChannelWidth *\n\t\t\t\tmode_lib->vba.MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation\n\t\t\t\t/ 100.0);\n\n\t\t\tif (MaxTotalVActiveRDBandwidth <= locals->MaxTotalVerticalActiveAvailableBandwidth[i][0]) {\n\t\t\t\tlocals->TotalVerticalActiveBandwidthSupport[i][0] = true;\n\t\t\t} else {\n\t\t\t\tlocals->TotalVerticalActiveBandwidthSupport[i][0] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i <= mode_lib->vba.soc.num_states; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tlocals->PTEBufferSizeNotExceeded[i][j] = true;\n\t\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\t\tif (locals->PTEBufferSizeNotExceededY[i][j][k] == false\n\t\t\t\t\t\t|| locals->PTEBufferSizeNotExceededC[i][j][k] == false) {\n\t\t\t\t\tlocals->PTEBufferSizeNotExceeded[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.CursorSupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.CursorWidth[k][0] > 0.0) {\n\t\t\tfor (m = 0; m < mode_lib->vba.NumberOfCursors[k]; m++) {\n\t\t\t\tif (mode_lib->vba.CursorBPP[k][m] == 64 && mode_lib->vba.Cursor64BppSupport == false) {\n\t\t\t\t\tmode_lib->vba.CursorSupport = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tmode_lib->vba.PitchSupport = true;\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tlocals->AlignedYPitch[k] = dml_ceil(\n\t\t\t\tdml_max(mode_lib->vba.PitchY[k], mode_lib->vba.ViewportWidth[k]),\n\t\t\t\tlocals->MacroTileWidthY[k]);\n\t\tif (locals->AlignedYPitch[k] > mode_lib->vba.PitchY[k]) {\n\t\t\tmode_lib->vba.PitchSupport = false;\n\t\t}\n\t\tif (mode_lib->vba.DCCEnable[k] == true) {\n\t\t\tlocals->AlignedDCCMetaPitch[k] = dml_ceil(\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.DCCMetaPitchY[k],\n\t\t\t\t\t\t\tmode_lib->vba.ViewportWidth[k]),\n\t\t\t\t\t64.0 * locals->Read256BlockWidthY[k]);\n\t\t} else {\n\t\t\tlocals->AlignedDCCMetaPitch[k] = mode_lib->vba.DCCMetaPitchY[k];\n\t\t}\n\t\tif (locals->AlignedDCCMetaPitch[k] > mode_lib->vba.DCCMetaPitchY[k]) {\n\t\t\tmode_lib->vba.PitchSupport = false;\n\t\t}\n\t\tif (mode_lib->vba.SourcePixelFormat[k] != dm_444_64\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_32\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_444_16\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_16\n\t\t\t\t&& mode_lib->vba.SourcePixelFormat[k] != dm_mono_8) {\n\t\t\tlocals->AlignedCPitch[k] = dml_ceil(\n\t\t\t\t\tdml_max(\n\t\t\t\t\t\t\tmode_lib->vba.PitchC[k],\n\t\t\t\t\t\t\tmode_lib->vba.ViewportWidth[k] / 2.0),\n\t\t\t\t\tlocals->MacroTileWidthC[k]);\n\t\t} else {\n\t\t\tlocals->AlignedCPitch[k] = mode_lib->vba.PitchC[k];\n\t\t}\n\t\tif (locals->AlignedCPitch[k] > mode_lib->vba.PitchC[k]) {\n\t\t\tmode_lib->vba.PitchSupport = false;\n\t\t}\n\t}\n\t \n\n\tfor (i = mode_lib->vba.soc.num_states; i >= 0; i--) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tenum dm_validation_status status = DML_VALIDATION_OK;\n\n\t\t\tif (!mode_lib->vba.ScaleRatioAndTapsSupport) {\n\t\t\t\tstatus = DML_FAIL_SCALE_RATIO_TAP;\n\t\t\t} else if (!mode_lib->vba.SourceFormatPixelAndScanSupport) {\n\t\t\t\tstatus = DML_FAIL_SOURCE_PIXEL_FORMAT;\n\t\t\t} else if (!locals->ViewportSizeSupport[i][0]) {\n\t\t\t\tstatus = DML_FAIL_VIEWPORT_SIZE;\n\t\t\t} else if (!locals->DIOSupport[i]) {\n\t\t\t\tstatus = DML_FAIL_DIO_SUPPORT;\n\t\t\t} else if (locals->NotEnoughDSCUnits[i]) {\n\t\t\t\tstatus = DML_FAIL_NOT_ENOUGH_DSC;\n\t\t\t} else if (locals->DSCCLKRequiredMoreThanSupported[i]) {\n\t\t\t\tstatus = DML_FAIL_DSC_CLK_REQUIRED;\n\t\t\t} else if (!locals->ROBSupport[i][0]) {\n\t\t\t\tstatus = DML_FAIL_REORDERING_BUFFER;\n\t\t\t} else if (!locals->DISPCLK_DPPCLK_Support[i][j]) {\n\t\t\t\tstatus = DML_FAIL_DISPCLK_DPPCLK;\n\t\t\t} else if (!locals->TotalAvailablePipesSupport[i][j]) {\n\t\t\t\tstatus = DML_FAIL_TOTAL_AVAILABLE_PIPES;\n\t\t\t} else if (!mode_lib->vba.NumberOfOTGSupport) {\n\t\t\t\tstatus = DML_FAIL_NUM_OTG;\n\t\t\t} else if (!mode_lib->vba.WritebackModeSupport) {\n\t\t\t\tstatus = DML_FAIL_WRITEBACK_MODE;\n\t\t\t} else if (!mode_lib->vba.WritebackLatencySupport) {\n\t\t\t\tstatus = DML_FAIL_WRITEBACK_LATENCY;\n\t\t\t} else if (!mode_lib->vba.WritebackScaleRatioAndTapsSupport) {\n\t\t\t\tstatus = DML_FAIL_WRITEBACK_SCALE_RATIO_TAP;\n\t\t\t} else if (!mode_lib->vba.CursorSupport) {\n\t\t\t\tstatus = DML_FAIL_CURSOR_SUPPORT;\n\t\t\t} else if (!mode_lib->vba.PitchSupport) {\n\t\t\t\tstatus = DML_FAIL_PITCH_SUPPORT;\n\t\t\t} else if (!locals->TotalVerticalActiveBandwidthSupport[i][0]) {\n\t\t\t\tstatus = DML_FAIL_TOTAL_V_ACTIVE_BW;\n\t\t\t} else if (!locals->PTEBufferSizeNotExceeded[i][j]) {\n\t\t\t\tstatus = DML_FAIL_PTE_BUFFER_SIZE;\n\t\t\t} else if (mode_lib->vba.NonsupportedDSCInputBPC) {\n\t\t\t\tstatus = DML_FAIL_DSC_INPUT_BPC;\n\t\t\t} else if ((mode_lib->vba.HostVMEnable\n\t\t\t\t\t&& !locals->ImmediateFlipSupportedForState[i][j])) {\n\t\t\t\tstatus = DML_FAIL_HOST_VM_IMMEDIATE_FLIP;\n\t\t\t} else if (!locals->PrefetchSupported[i][j]) {\n\t\t\t\tstatus = DML_FAIL_PREFETCH_SUPPORT;\n\t\t\t} else if (!locals->VRatioInPrefetchSupported[i][j]) {\n\t\t\t\tstatus = DML_FAIL_V_RATIO_PREFETCH;\n\t\t\t}\n\n\t\t\tif (status == DML_VALIDATION_OK) {\n\t\t\t\tlocals->ModeSupport[i][j] = true;\n\t\t\t} else {\n\t\t\t\tlocals->ModeSupport[i][j] = false;\n\t\t\t}\n\t\t\tlocals->ValidationStatus[i] = status;\n\t\t}\n\t}\n\t{\n\t\tunsigned int MaximumMPCCombine = 0;\n\t\tmode_lib->vba.VoltageLevel = mode_lib->vba.soc.num_states + 1;\n\t\tfor (i = mode_lib->vba.VoltageOverrideLevel; i <= mode_lib->vba.soc.num_states; i++) {\n\t\t\tif (locals->ModeSupport[i][0] == true || locals->ModeSupport[i][1] == true) {\n\t\t\t\tmode_lib->vba.VoltageLevel = i;\n\t\t\t\tif (locals->ModeSupport[i][1] == true && (locals->ModeSupport[i][0] == false\n\t\t\t\t\t\t|| mode_lib->vba.WhenToDoMPCCombine == dm_mpc_always_when_possible\n\t\t\t\t\t\t|| (mode_lib->vba.WhenToDoMPCCombine == dm_mpc_reduce_voltage_and_clocks\n\t\t\t\t\t\t\t&& ((locals->DRAMClockChangeSupport[i][1] == dm_dram_clock_change_vactive\n\t\t\t\t\t\t\t\t&& locals->DRAMClockChangeSupport[i][0] != dm_dram_clock_change_vactive)\n\t\t\t\t\t\t\t|| (locals->DRAMClockChangeSupport[i][1] == dm_dram_clock_change_vblank\n\t\t\t\t\t\t\t\t&& locals->DRAMClockChangeSupport[i][0] == dm_dram_clock_change_unsupported))))) {\n\t\t\t\t\tMaximumMPCCombine = 1;\n\t\t\t\t} else {\n\t\t\t\t\tMaximumMPCCombine = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmode_lib->vba.ImmediateFlipSupport =\n\t\t\tlocals->ImmediateFlipSupportedForState[mode_lib->vba.VoltageLevel][MaximumMPCCombine];\n\t\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\t\tmode_lib->vba.DPPPerPlane[k] = locals->NoOfDPP[mode_lib->vba.VoltageLevel][MaximumMPCCombine][k];\n\t\t\tlocals->DPPCLK[k] = locals->RequiredDPPCLK[mode_lib->vba.VoltageLevel][MaximumMPCCombine][k];\n\t\t}\n\t\tmode_lib->vba.DISPCLK = locals->RequiredDISPCLK[mode_lib->vba.VoltageLevel][MaximumMPCCombine];\n\t\tmode_lib->vba.maxMpcComb = MaximumMPCCombine;\n\t}\n\tmode_lib->vba.DCFCLK = mode_lib->vba.DCFCLKPerState[mode_lib->vba.VoltageLevel];\n\tmode_lib->vba.DRAMSpeed = mode_lib->vba.DRAMSpeedPerState[mode_lib->vba.VoltageLevel];\n\tmode_lib->vba.FabricClock = mode_lib->vba.FabricClockPerState[mode_lib->vba.VoltageLevel];\n\tmode_lib->vba.SOCCLK = mode_lib->vba.SOCCLKPerState[mode_lib->vba.VoltageLevel];\n\tmode_lib->vba.ReturnBW = locals->ReturnBWPerState[mode_lib->vba.VoltageLevel][0];\n\tfor (k = 0; k <= mode_lib->vba.NumberOfActivePlanes - 1; k++) {\n\t\tif (mode_lib->vba.BlendingAndTiming[k] == k) {\n\t\t\tmode_lib->vba.ODMCombineEnabled[k] =\n\t\t\t\t\tlocals->ODMCombineEnablePerState[mode_lib->vba.VoltageLevel][k];\n\t\t} else {\n\t\t\tmode_lib->vba.ODMCombineEnabled[k] = dm_odm_combine_mode_disabled;\n\t\t}\n\t\tmode_lib->vba.DSCEnabled[k] =\n\t\t\t\tlocals->RequiresDSC[mode_lib->vba.VoltageLevel][k];\n\t\tmode_lib->vba.OutputBpp[k] =\n\t\t\t\tlocals->OutputBppPerState[mode_lib->vba.VoltageLevel][k];\n\t}\n}\n\nstatic void CalculateWatermarksAndDRAMSpeedChangeSupport(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int PrefetchMode,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tunsigned int MaxLineBufferLines,\n\t\tunsigned int LineBufferSize,\n\t\tunsigned int DPPOutputBufferPixels,\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int WritebackInterfaceLumaBufferSize,\n\t\tunsigned int WritebackInterfaceChromaBufferSize,\n\t\tdouble DCFCLK,\n\t\tdouble UrgentOutOfOrderReturn,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tint dpte_group_bytes[],\n\t\tunsigned int MetaChunkSize,\n\t\tdouble UrgentLatency,\n\t\tdouble ExtraLatency,\n\t\tdouble WritebackLatency,\n\t\tdouble WritebackChunkSize,\n\t\tdouble SOCCLK,\n\t\tdouble DRAMClockChangeLatency,\n\t\tdouble SRExitTime,\n\t\tdouble SREnterPlusExitTime,\n\t\tdouble DCFCLKDeepSleep,\n\t\tint DPPPerPlane[],\n\t\tbool DCCEnable[],\n\t\tdouble DPPCLK[],\n\t\tdouble SwathWidthSingleDPPY[],\n\t\tunsigned int SwathHeightY[],\n\t\tdouble ReadBandwidthPlaneLuma[],\n\t\tunsigned int SwathHeightC[],\n\t\tdouble ReadBandwidthPlaneChroma[],\n\t\tunsigned int LBBitPerPixel[],\n\t\tdouble SwathWidthY[],\n\t\tdouble HRatio[],\n\t\tunsigned int vtaps[],\n\t\tunsigned int VTAPsChroma[],\n\t\tdouble VRatio[],\n\t\tunsigned int HTotal[],\n\t\tdouble PixelClock[],\n\t\tunsigned int BlendingAndTiming[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tbool WritebackEnable[],\n\t\tenum source_format_class WritebackPixelFormat[],\n\t\tdouble WritebackDestinationWidth[],\n\t\tdouble WritebackDestinationHeight[],\n\t\tdouble WritebackSourceHeight[],\n\t\tenum clock_change_support *DRAMClockChangeSupport,\n\t\tdouble *UrgentWatermark,\n\t\tdouble *WritebackUrgentWatermark,\n\t\tdouble *DRAMClockChangeWatermark,\n\t\tdouble *WritebackDRAMClockChangeWatermark,\n\t\tdouble *StutterExitWatermark,\n\t\tdouble *StutterEnterPlusExitWatermark,\n\t\tdouble *MinActiveDRAMClockChangeLatencySupported)\n{\n\tdouble EffectiveLBLatencyHidingY;\n\tdouble EffectiveLBLatencyHidingC;\n\tdouble DPPOutputBufferLinesY;\n\tdouble DPPOutputBufferLinesC;\n\tunsigned int DETBufferSizeY;\n\tunsigned int DETBufferSizeC;\n\tdouble LinesInDETY[DC__NUM_DPP__MAX];\n\tdouble LinesInDETC;\n\tunsigned int LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];\n\tunsigned int LinesInDETCRoundedDownToSwath;\n\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX];\n\tdouble FullDETBufferingTimeC;\n\tdouble ActiveDRAMClockChangeLatencyMarginY;\n\tdouble ActiveDRAMClockChangeLatencyMarginC;\n\tdouble WritebackDRAMClockChangeLatencyMargin;\n\tdouble PlaneWithMinActiveDRAMClockChangeMargin;\n\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;\n\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;\n\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;\n\tunsigned int k, j;\n\n\tmode_lib->vba.TotalActiveDPP = 0;\n\tmode_lib->vba.TotalDCCActiveDPP = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.TotalActiveDPP = mode_lib->vba.TotalActiveDPP + DPPPerPlane[k];\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmode_lib->vba.TotalDCCActiveDPP = mode_lib->vba.TotalDCCActiveDPP + DPPPerPlane[k];\n\t\t}\n\t}\n\n\tmode_lib->vba.TotalDataReadBandwidth = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tmode_lib->vba.TotalDataReadBandwidth = mode_lib->vba.TotalDataReadBandwidth\n\t\t\t\t+ ReadBandwidthPlaneLuma[k] + ReadBandwidthPlaneChroma[k];\n\t}\n\n\t*UrgentWatermark = UrgentLatency + ExtraLatency;\n\n\t*DRAMClockChangeWatermark = DRAMClockChangeLatency + *UrgentWatermark;\n\n\tmode_lib->vba.TotalActiveWriteback = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (WritebackEnable[k] == true) {\n\t\t\tmode_lib->vba.TotalActiveWriteback = mode_lib->vba.TotalActiveWriteback + 1;\n\t\t}\n\t}\n\n\tif (mode_lib->vba.TotalActiveWriteback <= 1) {\n\t\t*WritebackUrgentWatermark = WritebackLatency;\n\t} else {\n\t\t*WritebackUrgentWatermark = WritebackLatency\n\t\t\t\t+ WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tif (mode_lib->vba.TotalActiveWriteback <= 1) {\n\t\t*WritebackDRAMClockChangeWatermark = DRAMClockChangeLatency + WritebackLatency;\n\t} else {\n\t\t*WritebackDRAMClockChangeWatermark = DRAMClockChangeLatency + WritebackLatency\n\t\t\t\t+ WritebackChunkSize * 1024.0 / 32.0 / SOCCLK;\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\n\t\tmode_lib->vba.LBLatencyHidingSourceLinesY = dml_min((double) MaxLineBufferLines,\n\t\t\tdml_floor(LineBufferSize / LBBitPerPixel[k] / (SwathWidthY[k] / dml_max(HRatio[k], 1.0)), 1))\n\t\t\t\t- (vtaps[k] - 1);\n\n\t\tmode_lib->vba.LBLatencyHidingSourceLinesC = dml_min((double) MaxLineBufferLines,\n\t\t\tdml_floor(LineBufferSize / LBBitPerPixel[k] / (SwathWidthY[k] / 2 / dml_max(HRatio[k] / 2, 1.0)), 1))\n\t\t\t\t- (VTAPsChroma[k] - 1);\n\n\t\tEffectiveLBLatencyHidingY = mode_lib->vba.LBLatencyHidingSourceLinesY / VRatio[k]\n\t\t\t\t* (HTotal[k] / PixelClock[k]);\n\n\t\tEffectiveLBLatencyHidingC = mode_lib->vba.LBLatencyHidingSourceLinesC\n\t\t\t\t/ (VRatio[k] / 2) * (HTotal[k] / PixelClock[k]);\n\n\t\tif (SwathWidthY[k] > 2 * DPPOutputBufferPixels) {\n\t\t\tDPPOutputBufferLinesY = (double) DPPOutputBufferPixels / SwathWidthY[k];\n\t\t} else if (SwathWidthY[k] > DPPOutputBufferPixels) {\n\t\t\tDPPOutputBufferLinesY = 0.5;\n\t\t} else {\n\t\t\tDPPOutputBufferLinesY = 1;\n\t\t}\n\n\t\tif (SwathWidthY[k] / 2.0 > 2 * DPPOutputBufferPixels) {\n\t\t\tDPPOutputBufferLinesC = (double) DPPOutputBufferPixels\n\t\t\t\t\t/ (SwathWidthY[k] / 2.0);\n\t\t} else if (SwathWidthY[k] / 2.0 > DPPOutputBufferPixels) {\n\t\t\tDPPOutputBufferLinesC = 0.5;\n\t\t} else {\n\t\t\tDPPOutputBufferLinesC = 1;\n\t\t}\n\n\t\tCalculateDETBufferSize(\n\t\t\t\tDETBufferSizeInKByte,\n\t\t\t\tSwathHeightY[k],\n\t\t\t\tSwathHeightC[k],\n\t\t\t\t&DETBufferSizeY,\n\t\t\t\t&DETBufferSizeC);\n\n\t\tLinesInDETY[k] = (double)DETBufferSizeY / BytePerPixelDETY[k] / SwathWidthY[k];\n\t\tLinesInDETYRoundedDownToSwath[k] = dml_floor(LinesInDETY[k], SwathHeightY[k]);\n\t\tFullDETBufferingTimeY[k] = LinesInDETYRoundedDownToSwath[k]\n\t\t\t\t* (HTotal[k] / PixelClock[k]) / VRatio[k];\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tLinesInDETC = (double)DETBufferSizeC / BytePerPixelDETC[k] / (SwathWidthY[k] / 2.0);\n\t\t\tLinesInDETCRoundedDownToSwath = dml_floor(LinesInDETC, SwathHeightC[k]);\n\t\t\tFullDETBufferingTimeC = LinesInDETCRoundedDownToSwath\n\t\t\t\t\t* (HTotal[k] / PixelClock[k]) / (VRatio[k] / 2);\n\t\t} else {\n\t\t\tLinesInDETC = 0;\n\t\t\tFullDETBufferingTimeC = 999999;\n\t\t}\n\n\t\tActiveDRAMClockChangeLatencyMarginY = HTotal[k] / PixelClock[k]\n\t\t\t\t* DPPOutputBufferLinesY + EffectiveLBLatencyHidingY\n\t\t\t\t+ FullDETBufferingTimeY[k] - *DRAMClockChangeWatermark;\n\n\t\tif (NumberOfActivePlanes > 1) {\n\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY\n\t\t\t\t- (1 - 1.0 / NumberOfActivePlanes) * SwathHeightY[k] * HTotal[k] / PixelClock[k] / VRatio[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tActiveDRAMClockChangeLatencyMarginC = HTotal[k] / PixelClock[k]\n\t\t\t\t\t* DPPOutputBufferLinesC + EffectiveLBLatencyHidingC\n\t\t\t\t\t+ FullDETBufferingTimeC - *DRAMClockChangeWatermark;\n\t\t\tif (NumberOfActivePlanes > 1) {\n\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC\n\t\t\t\t\t- (1 - 1.0 / NumberOfActivePlanes) * SwathHeightC[k] * HTotal[k] / PixelClock[k] / (VRatio[k] / 2);\n\t\t\t}\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(\n\t\t\t\t\tActiveDRAMClockChangeLatencyMarginY,\n\t\t\t\t\tActiveDRAMClockChangeLatencyMarginC);\n\t\t} else {\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = ActiveDRAMClockChangeLatencyMarginY;\n\t\t}\n\n\t\tif (WritebackEnable[k] == true) {\n\t\t\tif (WritebackPixelFormat[k] == dm_444_32) {\n\t\t\t\tWritebackDRAMClockChangeLatencyMargin = (WritebackInterfaceLumaBufferSize\n\t\t\t\t\t+ WritebackInterfaceChromaBufferSize) / (WritebackDestinationWidth[k]\n\t\t\t\t\t* WritebackDestinationHeight[k] / (WritebackSourceHeight[k] * HTotal[k]\n\t\t\t\t\t/ PixelClock[k]) * 4) - *WritebackDRAMClockChangeWatermark;\n\t\t\t} else {\n\t\t\t\tWritebackDRAMClockChangeLatencyMargin = dml_min(\n\t\t\t\t\t\tWritebackInterfaceLumaBufferSize * 8.0 / 10,\n\t\t\t\t\t\t2 * WritebackInterfaceChromaBufferSize * 8.0 / 10) / (WritebackDestinationWidth[k]\n\t\t\t\t\t\t\t* WritebackDestinationHeight[k] / (WritebackSourceHeight[k] * HTotal[k] / PixelClock[k]))\n\t\t\t\t\t\t- *WritebackDRAMClockChangeWatermark;\n\t\t\t}\n\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k] = dml_min(\n\t\t\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k],\n\t\t\t\t\tWritebackDRAMClockChangeLatencyMargin);\n\t\t}\n\t}\n\n\tmode_lib->vba.MinActiveDRAMClockChangeMargin = 999999;\n\tPlaneWithMinActiveDRAMClockChangeMargin = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k]\n\t\t\t\t< mode_lib->vba.MinActiveDRAMClockChangeMargin) {\n\t\t\tmode_lib->vba.MinActiveDRAMClockChangeMargin =\n\t\t\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k];\n\t\t\tif (BlendingAndTiming[k] == k) {\n\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = k;\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < NumberOfActivePlanes; ++j) {\n\t\t\t\t\tif (BlendingAndTiming[k] == j) {\n\t\t\t\t\t\tPlaneWithMinActiveDRAMClockChangeMargin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*MinActiveDRAMClockChangeLatencySupported = mode_lib->vba.MinActiveDRAMClockChangeMargin + DRAMClockChangeLatency;\n\n\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 999999;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (!((k == PlaneWithMinActiveDRAMClockChangeMargin) && (BlendingAndTiming[k] == k))\n\t\t\t\t&& !(BlendingAndTiming[k] == PlaneWithMinActiveDRAMClockChangeMargin)\n\t\t\t\t&& mode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k]\n\t\t\t\t\t\t< SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank) {\n\t\t\tSecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank =\n\t\t\t\t\tmode_lib->vba.ActiveDRAMClockChangeLatencyMargin[k];\n\t\t}\n\t}\n\n\tmode_lib->vba.TotalNumberOfActiveOTG = 0;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (BlendingAndTiming[k] == k) {\n\t\t\tmode_lib->vba.TotalNumberOfActiveOTG = mode_lib->vba.TotalNumberOfActiveOTG + 1;\n\t\t}\n\t}\n\n\tif (mode_lib->vba.MinActiveDRAMClockChangeMargin > 0 && PrefetchMode == 0) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vactive;\n\t} else if (((mode_lib->vba.SynchronizedVBlank == true\n\t\t\t|| mode_lib->vba.TotalNumberOfActiveOTG == 1\n\t\t\t|| SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank > 0)\n\t\t\t&& PrefetchMode == 0)) {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_vblank;\n\t} else {\n\t\t*DRAMClockChangeSupport = dm_dram_clock_change_unsupported;\n\t}\n\n\tFullDETBufferingTimeYStutterCriticalPlane = FullDETBufferingTimeY[0];\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (FullDETBufferingTimeY[k] <= FullDETBufferingTimeYStutterCriticalPlane) {\n\t\t\tTimeToFinishSwathTransferStutterCriticalPlane = (SwathHeightY[k]\n\t\t\t\t\t- (LinesInDETY[k] - LinesInDETYRoundedDownToSwath[k]))\n\t\t\t\t\t* (HTotal[k] / PixelClock[k]) / VRatio[k];\n\t\t}\n\t}\n\n\t*StutterExitWatermark = SRExitTime + mode_lib->vba.LastPixelOfLineExtraWatermark\n\t\t\t+ ExtraLatency + 10 / DCFCLKDeepSleep;\n\t*StutterEnterPlusExitWatermark = dml_max(\n\t\t\tSREnterPlusExitTime + mode_lib->vba.LastPixelOfLineExtraWatermark\n\t\t\t\t\t+ ExtraLatency + 10 / DCFCLKDeepSleep,\n\t\t\tTimeToFinishSwathTransferStutterCriticalPlane);\n\n}\n\nstatic void CalculateDCFCLKDeepSleep(\n\t\tstruct display_mode_lib *mode_lib,\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tdouble VRatio[],\n\t\tdouble SwathWidthY[],\n\t\tint DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble *DCFCLKDeepSleep)\n{\n\tunsigned int k;\n\tdouble DisplayPipeLineDeliveryTimeLuma;\n\tdouble DisplayPipeLineDeliveryTimeChroma;\n\t\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerPlane[k]\n\t\t\t\t\t/ HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] / PSCL_THROUGHPUT[k]\n\t\t\t\t\t/ DPPCLK[k];\n\t\t}\n\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma = 0;\n\t\t} else {\n\t\t\tif (VRatio[k] / 2 <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthY[k] / 2.0\n\t\t\t\t\t\t* DPPPerPlane[k] / (HRatio[k] / 2) / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma = SwathWidthY[k] / 2.0\n\t\t\t\t\t\t/ PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = dml_max(\n\t\t\t\t\t1.1 * SwathWidthY[k] * dml_ceil(BytePerPixelDETY[k], 1)\n\t\t\t\t\t\t\t/ 32.0 / DisplayPipeLineDeliveryTimeLuma,\n\t\t\t\t\t1.1 * SwathWidthY[k] / 2.0\n\t\t\t\t\t\t\t* dml_ceil(BytePerPixelDETC[k], 2) / 32.0\n\t\t\t\t\t\t\t/ DisplayPipeLineDeliveryTimeChroma);\n\t\t} else {\n\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = 1.1 * SwathWidthY[k]\n\t\t\t\t\t* dml_ceil(BytePerPixelDETY[k], 1) / 64.0\n\t\t\t\t\t/ DisplayPipeLineDeliveryTimeLuma;\n\t\t}\n\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k] = dml_max(\n\t\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k],\n\t\t\t\tPixelClock[k] / 16);\n\n\t}\n\n\t*DCFCLKDeepSleep = 8;\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\t*DCFCLKDeepSleep = dml_max(\n\t\t\t\t*DCFCLKDeepSleep,\n\t\t\t\tmode_lib->vba.DCFCLKDeepSleepPerPlane[k]);\n\t}\n}\n\nstatic void CalculateDETBufferSize(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tunsigned int *DETBufferSizeY,\n\t\tunsigned int *DETBufferSizeC)\n{\n\tif (SwathHeightC == 0) {\n\t\t*DETBufferSizeY = DETBufferSizeInKByte * 1024;\n\t\t*DETBufferSizeC = 0;\n\t} else if (SwathHeightY <= SwathHeightC) {\n\t\t*DETBufferSizeY = DETBufferSizeInKByte * 1024 / 2;\n\t\t*DETBufferSizeC = DETBufferSizeInKByte * 1024 / 2;\n\t} else {\n\t\t*DETBufferSizeY = DETBufferSizeInKByte * 1024 * 2 / 3;\n\t\t*DETBufferSizeC = DETBufferSizeInKByte * 1024 / 3;\n\t}\n}\n\nstatic void CalculateUrgentBurstFactor(\n\t\tunsigned int DETBufferSizeInKByte,\n\t\tunsigned int SwathHeightY,\n\t\tunsigned int SwathHeightC,\n\t\tunsigned int SwathWidthY,\n\t\tdouble LineTime,\n\t\tdouble UrgentLatency,\n\t\tdouble CursorBufferSize,\n\t\tunsigned int CursorWidth,\n\t\tunsigned int CursorBPP,\n\t\tdouble VRatio,\n\t\tdouble VRatioPreY,\n\t\tdouble VRatioPreC,\n\t\tdouble BytePerPixelInDETY,\n\t\tdouble BytePerPixelInDETC,\n\t\tdouble *UrgentBurstFactorCursor,\n\t\tdouble *UrgentBurstFactorCursorPre,\n\t\tdouble *UrgentBurstFactorLuma,\n\t\tdouble *UrgentBurstFactorLumaPre,\n\t\tdouble *UrgentBurstFactorChroma,\n\t\tdouble *UrgentBurstFactorChromaPre,\n\t\tunsigned int *NotEnoughUrgentLatencyHiding,\n\t\tunsigned int *NotEnoughUrgentLatencyHidingPre)\n{\n\tdouble LinesInDETLuma;\n\tdouble LinesInDETChroma;\n\tunsigned int LinesInCursorBuffer;\n\tdouble CursorBufferSizeInTime;\n\tdouble CursorBufferSizeInTimePre;\n\tdouble DETBufferSizeInTimeLuma;\n\tdouble DETBufferSizeInTimeLumaPre;\n\tdouble DETBufferSizeInTimeChroma;\n\tdouble DETBufferSizeInTimeChromaPre;\n\tunsigned int DETBufferSizeY;\n\tunsigned int DETBufferSizeC;\n\n\t*NotEnoughUrgentLatencyHiding = 0;\n\t*NotEnoughUrgentLatencyHidingPre = 0;\n\n\tif (CursorWidth > 0) {\n\t\tLinesInCursorBuffer = 1 << (unsigned int) dml_floor(\n\t\t\tdml_log2(CursorBufferSize * 1024.0 / (CursorWidth * CursorBPP / 8.0)), 1.0);\n\t\tCursorBufferSizeInTime = LinesInCursorBuffer * LineTime / VRatio;\n\t\tif (CursorBufferSizeInTime - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t*UrgentBurstFactorCursor = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorCursor = CursorBufferSizeInTime\n\t\t\t\t\t/ (CursorBufferSizeInTime - UrgentLatency);\n\t\t}\n\t\tif (VRatioPreY > 0) {\n\t\t\tCursorBufferSizeInTimePre = LinesInCursorBuffer * LineTime / VRatioPreY;\n\t\t\tif (CursorBufferSizeInTimePre - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHidingPre = 1;\n\t\t\t\t*UrgentBurstFactorCursorPre = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorCursorPre = CursorBufferSizeInTimePre\n\t\t\t\t\t\t/ (CursorBufferSizeInTimePre - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorCursorPre = 1;\n\t\t}\n\t}\n\n\tCalculateDETBufferSize(\n\t\t\tDETBufferSizeInKByte,\n\t\t\tSwathHeightY,\n\t\t\tSwathHeightC,\n\t\t\t&DETBufferSizeY,\n\t\t\t&DETBufferSizeC);\n\n\tLinesInDETLuma = (double)DETBufferSizeY / BytePerPixelInDETY / SwathWidthY;\n\tDETBufferSizeInTimeLuma = dml_floor(LinesInDETLuma, SwathHeightY) * LineTime / VRatio;\n\tif (DETBufferSizeInTimeLuma - UrgentLatency <= 0) {\n\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t*UrgentBurstFactorLuma = 0;\n\t} else {\n\t\t*UrgentBurstFactorLuma = DETBufferSizeInTimeLuma\n\t\t\t\t/ (DETBufferSizeInTimeLuma - UrgentLatency);\n\t}\n\tif (VRatioPreY > 0) {\n\t\tDETBufferSizeInTimeLumaPre = dml_floor(LinesInDETLuma, SwathHeightY) * LineTime\n\t\t\t\t/ VRatioPreY;\n\t\tif (DETBufferSizeInTimeLumaPre - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHidingPre = 1;\n\t\t\t*UrgentBurstFactorLumaPre = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorLumaPre = DETBufferSizeInTimeLumaPre\n\t\t\t\t\t/ (DETBufferSizeInTimeLumaPre - UrgentLatency);\n\t\t}\n\t} else {\n\t\t*UrgentBurstFactorLumaPre = 1;\n\t}\n\n\tif (BytePerPixelInDETC > 0) {\n\t\tLinesInDETChroma = (double)DETBufferSizeC / BytePerPixelInDETC / (SwathWidthY / 2);\n\t\tDETBufferSizeInTimeChroma = dml_floor(LinesInDETChroma, SwathHeightC) * LineTime\n\t\t\t\t/ (VRatio / 2);\n\t\tif (DETBufferSizeInTimeChroma - UrgentLatency <= 0) {\n\t\t\t*NotEnoughUrgentLatencyHiding = 1;\n\t\t\t*UrgentBurstFactorChroma = 0;\n\t\t} else {\n\t\t\t*UrgentBurstFactorChroma = DETBufferSizeInTimeChroma\n\t\t\t\t\t/ (DETBufferSizeInTimeChroma - UrgentLatency);\n\t\t}\n\t\tif (VRatioPreC > 0) {\n\t\t\tDETBufferSizeInTimeChromaPre = dml_floor(LinesInDETChroma, SwathHeightC)\n\t\t\t\t\t* LineTime / VRatioPreC;\n\t\t\tif (DETBufferSizeInTimeChromaPre - UrgentLatency <= 0) {\n\t\t\t\t*NotEnoughUrgentLatencyHidingPre = 1;\n\t\t\t\t*UrgentBurstFactorChromaPre = 0;\n\t\t\t} else {\n\t\t\t\t*UrgentBurstFactorChromaPre = DETBufferSizeInTimeChromaPre\n\t\t\t\t\t\t/ (DETBufferSizeInTimeChromaPre - UrgentLatency);\n\t\t\t}\n\t\t} else {\n\t\t\t*UrgentBurstFactorChromaPre = 1;\n\t\t}\n\t}\n}\n\nstatic void CalculatePixelDeliveryTimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tdouble VRatio[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tunsigned int swath_width_luma_ub[],\n\t\tunsigned int swath_width_chroma_ub[],\n\t\tint DPPPerPlane[],\n\t\tdouble HRatio[],\n\t\tdouble PixelClock[],\n\t\tdouble PSCL_THROUGHPUT[],\n\t\tdouble PSCL_THROUGHPUT_CHROMA[],\n\t\tdouble DPPCLK[],\n\t\tdouble BytePerPixelDETC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int BlockWidth256BytesY[],\n\t\tunsigned int BlockHeight256BytesY[],\n\t\tunsigned int BlockWidth256BytesC[],\n\t\tunsigned int BlockHeight256BytesC[],\n\t\tdouble DisplayPipeLineDeliveryTimeLuma[],\n\t\tdouble DisplayPipeLineDeliveryTimeChroma[],\n\t\tdouble DisplayPipeLineDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeLineDeliveryTimeChromaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLuma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChroma[],\n\t\tdouble DisplayPipeRequestDeliveryTimeLumaPrefetch[],\n\t\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[])\n{\n\tdouble req_per_swath_ub;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (VRatio[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k] * DPPPerPlane[k]\n\t\t\t\t\t/ HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLuma[k] = swath_width_luma_ub[k]\n\t\t\t\t\t/ PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = 0;\n\t\t} else {\n\t\t\tif (VRatio[k] / 2 <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k]\n\t\t\t\t\t\t* DPPPerPlane[k] / (HRatio[k] / 2) / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] = swath_width_chroma_ub[k]\n\t\t\t\t\t\t/ PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\n\t\tif (VRatioPrefetchY[k] <= 1) {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k]\n\t\t\t\t\t* DPPPerPlane[k] / HRatio[k] / PixelClock[k];\n\t\t} else {\n\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] = swath_width_luma_ub[k]\n\t\t\t\t\t/ PSCL_THROUGHPUT[k] / DPPCLK[k];\n\t\t}\n\n\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (VRatioPrefetchC[k] <= 1) {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] =\n\t\t\t\t\t\tswath_width_chroma_ub[k] * DPPPerPlane[k]\n\t\t\t\t\t\t\t\t/ (HRatio[k] / 2) / PixelClock[k];\n\t\t\t} else {\n\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] =\n\t\t\t\t\t\tswath_width_chroma_ub[k] / PSCL_THROUGHPUT_CHROMA[k] / DPPCLK[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (SourceScan[k] == dm_horz) {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockWidth256BytesY[k];\n\t\t} else {\n\t\t\treq_per_swath_ub = swath_width_luma_ub[k] / BlockHeight256BytesY[k];\n\t\t}\n\t\tDisplayPipeRequestDeliveryTimeLuma[k] = DisplayPipeLineDeliveryTimeLuma[k]\n\t\t\t\t/ req_per_swath_ub;\n\t\tDisplayPipeRequestDeliveryTimeLumaPrefetch[k] =\n\t\t\t\tDisplayPipeLineDeliveryTimeLumaPrefetch[k] / req_per_swath_ub;\n\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] = 0;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] = 0;\n\t\t} else {\n\t\t\tif (SourceScan[k] == dm_horz) {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k]\n\t\t\t\t\t\t/ BlockWidth256BytesC[k];\n\t\t\t} else {\n\t\t\t\treq_per_swath_ub = swath_width_chroma_ub[k]\n\t\t\t\t\t\t/ BlockHeight256BytesC[k];\n\t\t\t}\n\t\t\tDisplayPipeRequestDeliveryTimeChroma[k] =\n\t\t\t\t\tDisplayPipeLineDeliveryTimeChroma[k] / req_per_swath_ub;\n\t\t\tDisplayPipeRequestDeliveryTimeChromaPrefetch[k] =\n\t\t\t\t\tDisplayPipeLineDeliveryTimeChromaPrefetch[k] / req_per_swath_ub;\n\t\t}\n\t}\n}\n\nstatic void CalculateMetaAndPTETimes(\n\t\tunsigned int NumberOfActivePlanes,\n\t\tbool GPUVMEnable,\n\t\tunsigned int MetaChunkSize,\n\t\tunsigned int MinMetaChunkSizeBytes,\n\t\tunsigned int GPUVMMaxPageTableLevels,\n\t\tunsigned int HTotal[],\n\t\tdouble VRatio[],\n\t\tdouble VRatioPrefetchY[],\n\t\tdouble VRatioPrefetchC[],\n\t\tdouble DestinationLinesToRequestRowInVBlank[],\n\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],\n\t\tdouble DestinationLinesToRequestVMInVBlank[],\n\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],\n\t\tbool DCCEnable[],\n\t\tdouble PixelClock[],\n\t\tdouble BytePerPixelDETY[],\n\t\tdouble BytePerPixelDETC[],\n\t\tenum scan_direction_class SourceScan[],\n\t\tunsigned int dpte_row_height[],\n\t\tunsigned int dpte_row_height_chroma[],\n\t\tunsigned int meta_row_width[],\n\t\tunsigned int meta_row_height[],\n\t\tunsigned int meta_req_width[],\n\t\tunsigned int meta_req_height[],\n\t\tint dpte_group_bytes[],\n\t\tunsigned int PTERequestSizeY[],\n\t\tunsigned int PTERequestSizeC[],\n\t\tunsigned int PixelPTEReqWidthY[],\n\t\tunsigned int PixelPTEReqHeightY[],\n\t\tunsigned int PixelPTEReqWidthC[],\n\t\tunsigned int PixelPTEReqHeightC[],\n\t\tunsigned int dpte_row_width_luma_ub[],\n\t\tunsigned int dpte_row_width_chroma_ub[],\n\t\tunsigned int vm_group_bytes[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_l[],\n\t\tunsigned int dpde0_bytes_per_frame_ub_c[],\n\t\tunsigned int meta_pte_bytes_per_frame_ub_l[],\n\t\tunsigned int meta_pte_bytes_per_frame_ub_c[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_L[],\n\t\tdouble DST_Y_PER_PTE_ROW_NOM_C[],\n\t\tdouble DST_Y_PER_META_ROW_NOM_L[],\n\t\tdouble TimePerMetaChunkNominal[],\n\t\tdouble TimePerMetaChunkVBlank[],\n\t\tdouble TimePerMetaChunkFlip[],\n\t\tdouble time_per_pte_group_nom_luma[],\n\t\tdouble time_per_pte_group_vblank_luma[],\n\t\tdouble time_per_pte_group_flip_luma[],\n\t\tdouble time_per_pte_group_nom_chroma[],\n\t\tdouble time_per_pte_group_vblank_chroma[],\n\t\tdouble time_per_pte_group_flip_chroma[],\n\t\tdouble TimePerVMGroupVBlank[],\n\t\tdouble TimePerVMGroupFlip[],\n\t\tdouble TimePerVMRequestVBlank[],\n\t\tdouble TimePerVMRequestFlip[])\n{\n\tunsigned int meta_chunk_width;\n\tunsigned int min_meta_chunk_width;\n\tunsigned int meta_chunk_per_row_int;\n\tunsigned int meta_row_remainder;\n\tunsigned int meta_chunk_threshold;\n\tunsigned int meta_chunks_per_row_ub;\n\tunsigned int dpte_group_width_luma;\n\tunsigned int dpte_group_width_chroma;\n\tunsigned int dpte_groups_per_row_luma_ub;\n\tunsigned int dpte_groups_per_row_chroma_ub;\n\tunsigned int num_group_per_lower_vm_stage;\n\tunsigned int num_req_per_lower_vm_stage;\n\tunsigned int k;\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true) {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_L[k] = dpte_row_height[k] / VRatio[k];\n\t\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = 0;\n\t\t\t} else {\n\t\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = dpte_row_height_chroma[k] / (VRatio[k] / 2);\n\t\t\t}\n\t\t} else {\n\t\t\tDST_Y_PER_PTE_ROW_NOM_L[k] = 0;\n\t\t\tDST_Y_PER_PTE_ROW_NOM_C[k] = 0;\n\t\t}\n\t\tif (DCCEnable[k] == true) {\n\t\t\tDST_Y_PER_META_ROW_NOM_L[k] = meta_row_height[k] / VRatio[k];\n\t\t} else {\n\t\t\tDST_Y_PER_META_ROW_NOM_L[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (DCCEnable[k] == true) {\n\t\t\tmeta_chunk_width = MetaChunkSize * 1024 * 256\n\t\t\t\t\t/ dml_ceil(BytePerPixelDETY[k], 1) / meta_row_height[k];\n\t\t\tmin_meta_chunk_width = MinMetaChunkSizeBytes * 256\n\t\t\t\t\t/ dml_ceil(BytePerPixelDETY[k], 1) / meta_row_height[k];\n\t\t\tmeta_chunk_per_row_int = meta_row_width[k] / meta_chunk_width;\n\t\t\tmeta_row_remainder = meta_row_width[k] % meta_chunk_width;\n\t\t\tif (SourceScan[k] == dm_horz) {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width - meta_req_width[k];\n\t\t\t} else {\n\t\t\t\tmeta_chunk_threshold = 2 * min_meta_chunk_width\n\t\t\t\t\t\t- meta_req_height[k];\n\t\t\t}\n\t\t\tif (meta_row_remainder <= meta_chunk_threshold) {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 1;\n\t\t\t} else {\n\t\t\t\tmeta_chunks_per_row_ub = meta_chunk_per_row_int + 2;\n\t\t\t}\n\t\t\tTimePerMetaChunkNominal[k] = meta_row_height[k] / VRatio[k] * HTotal[k]\n\t\t\t\t\t/ PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkVBlank[k] = DestinationLinesToRequestRowInVBlank[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t\tTimePerMetaChunkFlip[k] = DestinationLinesToRequestRowInImmediateFlip[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / meta_chunks_per_row_ub;\n\t\t} else {\n\t\t\tTimePerMetaChunkNominal[k] = 0;\n\t\t\tTimePerMetaChunkVBlank[k] = 0;\n\t\t\tTimePerMetaChunkFlip[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true) {\n\t\t\tif (SourceScan[k] == dm_horz) {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k]\n\t\t\t\t\t\t* PixelPTEReqWidthY[k];\n\t\t\t} else {\n\t\t\t\tdpte_group_width_luma = dpte_group_bytes[k] / PTERequestSizeY[k]\n\t\t\t\t\t\t* PixelPTEReqHeightY[k];\n\t\t\t}\n\t\t\tdpte_groups_per_row_luma_ub = dml_ceil(\n\t\t\t\t\t(float) dpte_row_width_luma_ub[k] / dpte_group_width_luma,\n\t\t\t\t\t1);\n\t\t\ttime_per_pte_group_nom_luma[k] = DST_Y_PER_PTE_ROW_NOM_L[k] * HTotal[k]\n\t\t\t\t\t/ PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_vblank_luma[k] = DestinationLinesToRequestRowInVBlank[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / dpte_groups_per_row_luma_ub;\n\t\t\ttime_per_pte_group_flip_luma[k] =\n\t\t\t\t\tDestinationLinesToRequestRowInImmediateFlip[k] * HTotal[k]\n\t\t\t\t\t\t\t/ PixelClock[k]\n\t\t\t\t\t\t\t/ dpte_groups_per_row_luma_ub;\n\t\t\tif (BytePerPixelDETC[k] == 0) {\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t\t} else {\n\t\t\t\tif (SourceScan[k] == dm_horz) {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k]\n\t\t\t\t\t\t\t/ PTERequestSizeC[k] * PixelPTEReqWidthC[k];\n\t\t\t\t} else {\n\t\t\t\t\tdpte_group_width_chroma = dpte_group_bytes[k]\n\t\t\t\t\t\t\t/ PTERequestSizeC[k]\n\t\t\t\t\t\t\t* PixelPTEReqHeightC[k];\n\t\t\t\t}\n\t\t\t\tdpte_groups_per_row_chroma_ub = dml_ceil(\n\t\t\t\t\t\t(float) dpte_row_width_chroma_ub[k]\n\t\t\t\t\t\t\t\t/ dpte_group_width_chroma,\n\t\t\t\t\t\t1);\n\t\t\t\ttime_per_pte_group_nom_chroma[k] = DST_Y_PER_PTE_ROW_NOM_C[k]\n\t\t\t\t\t\t* HTotal[k] / PixelClock[k]\n\t\t\t\t\t\t/ dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_vblank_chroma[k] =\n\t\t\t\t\t\tDestinationLinesToRequestRowInVBlank[k] * HTotal[k]\n\t\t\t\t\t\t\t\t/ PixelClock[k]\n\t\t\t\t\t\t\t\t/ dpte_groups_per_row_chroma_ub;\n\t\t\t\ttime_per_pte_group_flip_chroma[k] =\n\t\t\t\t\t\tDestinationLinesToRequestRowInImmediateFlip[k]\n\t\t\t\t\t\t\t\t* HTotal[k] / PixelClock[k]\n\t\t\t\t\t\t\t\t/ dpte_groups_per_row_chroma_ub;\n\t\t\t}\n\t\t} else {\n\t\t\ttime_per_pte_group_nom_luma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_luma[k] = 0;\n\t\t\ttime_per_pte_group_flip_luma[k] = 0;\n\t\t\ttime_per_pte_group_nom_chroma[k] = 0;\n\t\t\ttime_per_pte_group_vblank_chroma[k] = 0;\n\t\t\ttime_per_pte_group_flip_chroma[k] = 0;\n\t\t}\n\t}\n\n\tfor (k = 0; k < NumberOfActivePlanes; ++k) {\n\t\tif (GPUVMEnable == true && (DCCEnable[k] == true || GPUVMMaxPageTableLevels > 1)) {\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t+ dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t} else {\n\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\t\tdml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\t\tdml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (dpde0_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_c[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_group_per_lower_vm_stage =\n\t\t\t\t\t\t\tdml_ceil((double) (dpde0_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1)\n\t\t\t\t\t\t\t+ dml_ceil((double) (meta_pte_bytes_per_frame_ub_l[k]) / (double) (vm_group_bytes[k]), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DCCEnable[k] == false) {\n\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k]\n\t\t\t\t\t\t\t/ 64 + dpde0_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t} else {\n\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k]\n\t\t\t\t\t\t\t/ 64;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (GPUVMMaxPageTableLevels == 1) {\n\t\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (BytePerPixelDETC[k] > 0) {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t+ dpde0_bytes_per_frame_ub_c[k] / 64\n\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_c[k] / 64;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_req_per_lower_vm_stage = dpde0_bytes_per_frame_ub_l[k] / 64\n\t\t\t\t\t\t\t+ meta_pte_bytes_per_frame_ub_l[k] / 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTimePerVMGroupVBlank[k] = DestinationLinesToRequestVMInVBlank[k] * HTotal[k]\n\t\t\t\t\t/ PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMGroupFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / num_group_per_lower_vm_stage;\n\t\t\tTimePerVMRequestVBlank[k] = DestinationLinesToRequestVMInVBlank[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\t\t\tTimePerVMRequestFlip[k] = DestinationLinesToRequestVMInImmediateFlip[k]\n\t\t\t\t\t* HTotal[k] / PixelClock[k] / num_req_per_lower_vm_stage;\n\n\t\t\tif (GPUVMMaxPageTableLevels > 2) {\n\t\t\t\tTimePerVMGroupVBlank[k] = TimePerVMGroupVBlank[k] / 2;\n\t\t\t\tTimePerVMGroupFlip[k] = TimePerVMGroupFlip[k] / 2;\n\t\t\t\tTimePerVMRequestVBlank[k] = TimePerVMRequestVBlank[k] / 2;\n\t\t\t\tTimePerVMRequestFlip[k] = TimePerVMRequestFlip[k] / 2;\n\t\t\t}\n\n\t\t} else {\n\t\t\tTimePerVMGroupVBlank[k] = 0;\n\t\t\tTimePerVMGroupFlip[k] = 0;\n\t\t\tTimePerVMRequestVBlank[k] = 0;\n\t\t\tTimePerVMRequestFlip[k] = 0;\n\t\t}\n\t}\n}\n\nstatic double CalculateExtraLatency(\n\t\tdouble UrgentRoundTripAndOutOfOrderLatency,\n\t\tint TotalNumberOfActiveDPP,\n\t\tint PixelChunkSizeInKByte,\n\t\tint TotalNumberOfDCCActiveDPP,\n\t\tint MetaChunkSize,\n\t\tdouble ReturnBW,\n\t\tbool GPUVMEnable,\n\t\tbool HostVMEnable,\n\t\tint NumberOfActivePlanes,\n\t\tint NumberOfDPP[],\n\t\tint dpte_group_bytes[],\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData,\n\t\tdouble PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly,\n\t\tint HostVMMaxPageTableLevels,\n\t\tint HostVMCachedPageTableLevels)\n{\n\tdouble CalculateExtraLatency;\n\tdouble HostVMInefficiencyFactor;\n\tint HostVMDynamicLevels;\n\n\tif (GPUVMEnable && HostVMEnable) {\n\t\tHostVMInefficiencyFactor =\n\t\t\t\tPercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData\n\t\t\t\t\t\t/ PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly;\n\t\tHostVMDynamicLevels = HostVMMaxPageTableLevels - HostVMCachedPageTableLevels;\n\t} else {\n\t\tHostVMInefficiencyFactor = 1;\n\t\tHostVMDynamicLevels = 0;\n\t}\n\n\tCalculateExtraLatency = UrgentRoundTripAndOutOfOrderLatency\n\t\t\t+ (TotalNumberOfActiveDPP * PixelChunkSizeInKByte\n\t\t\t\t\t+ TotalNumberOfDCCActiveDPP * MetaChunkSize) * 1024.0\n\t\t\t\t\t/ ReturnBW;\n\n\tif (GPUVMEnable) {\n\t\tint k;\n\n\t\tfor (k = 0; k < NumberOfActivePlanes; k++) {\n\t\t\tCalculateExtraLatency = CalculateExtraLatency\n\t\t\t\t\t+ NumberOfDPP[k] * dpte_group_bytes[k]\n\t\t\t\t\t\t\t* (1 + 8 * HostVMDynamicLevels)\n\t\t\t\t\t\t\t* HostVMInefficiencyFactor / ReturnBW;\n\t\t}\n\t}\n\treturn CalculateExtraLatency;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}