{
  "module_name": "dce_dmcu.c",
  "hash_id": "7aefbfe08ab52ccfc3a0677ffc677e7753cbeb7435dd5e197940901a66381a63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c",
  "human_readable_source": " \n\n#include \"core_types.h\"\n#include \"link_encoder.h\"\n#include \"dce_dmcu.h\"\n#include \"dm_services.h\"\n#include \"reg_helper.h\"\n#include \"fixed31_32.h\"\n#include \"dc.h\"\n\n#define TO_DCE_DMCU(dmcu)\\\n\tcontainer_of(dmcu, struct dce_dmcu, base)\n\n#define REG(reg) \\\n\t(dmcu_dce->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdmcu_dce->dmcu_shift->field_name, dmcu_dce->dmcu_mask->field_name\n\n#define CTX \\\n\tdmcu_dce->base.ctx\n\n \n#define PSR_ENABLE 0x20\n#define PSR_EXIT 0x21\n#define PSR_SET 0x23\n#define PSR_SET_WAITLOOP 0x31\n#define MCP_INIT_DMCU 0x88\n#define MCP_INIT_IRAM 0x89\n#define MCP_SYNC_PHY_LOCK 0x90\n#define MCP_SYNC_PHY_UNLOCK 0x91\n#define MCP_BL_SET_PWM_FRAC 0x6A   \n#define CRC_WIN_NOTIFY 0x92\n#define CRC_STOP_UPDATE 0x93\n#define MCP_SEND_EDID_CEA 0xA0\n#define EDID_CEA_CMD_ACK 1\n#define EDID_CEA_CMD_NACK 2\n#define MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK   0x00000001L\n\n\n#define mmMP0_SMN_C2PMSG_58\t\t\t\t0x1607A\n\n\n#define mmMP0_SMN_C2PMSG_91\t\t\t\t0x1609B\n\nstatic const uint32_t abm_gain_stepsize = 0x0060;\n\nstatic bool dce_dmcu_init(struct dmcu *dmcu)\n{\n\t\n\treturn true;\n}\n\nstatic bool dce_dmcu_load_iram(struct dmcu *dmcu,\n\t\t\t       unsigned int start_offset,\n\t\t\t       const char *src,\n\t\t\t       unsigned int bytes)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int count = 0;\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 1,\n\t\t\tIRAM_WR_ADDR_AUTO_INC, 1);\n\n\tREG_WAIT(DCI_MEM_PWR_STATUS, DMCU_IRAM_MEM_PWR_STATE, 0, 2, 10);\n\n\tREG_WRITE(DMCU_IRAM_WR_CTRL, start_offset);\n\n\tfor (count = 0; count < bytes; count++)\n\t\tREG_WRITE(DMCU_IRAM_WR_DATA, src[count]);\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 0,\n\t\t\tIRAM_WR_ADDR_AUTO_INC, 0);\n\n\treturn true;\n}\n\nstatic void dce_get_dmcu_psr_state(struct dmcu *dmcu, enum dc_psr_state *state)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\tuint32_t psr_state_offset = 0xf0;\n\n\t \n\tREG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 1);\n\n\tREG_WAIT(DCI_MEM_PWR_STATUS, DMCU_IRAM_MEM_PWR_STATE, 0, 2, 10);\n\n\t \n\tREG_WRITE(DMCU_IRAM_RD_CTRL, psr_state_offset);\n\n\t \n\t*state = (enum dc_psr_state)REG_READ(DMCU_IRAM_RD_DATA);\n\n\t \n\tREG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 0);\n}\n\nstatic void dce_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\n\tunsigned int retryCount;\n\tenum dc_psr_state state = PSR_STATE0;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\t \n\tif (enable)\n\t\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tPSR_ENABLE);\n\telse\n\t\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tPSR_EXIT);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\tif (wait == true) {\n\t\tfor (retryCount = 0; retryCount <= 100; retryCount++) {\n\t\t\tdce_get_dmcu_psr_state(dmcu, &state);\n\t\t\tif (enable) {\n\t\t\t\tif (state != PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (state == PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t}\n\t}\n}\n\nstatic bool dce_dmcu_setup_psr(struct dmcu *dmcu,\n\t\tstruct dc_link *link,\n\t\tstruct psr_context *psr_context)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\n\tunion dce_dmcu_psr_config_data_reg1 masterCmdData1;\n\tunion dce_dmcu_psr_config_data_reg2 masterCmdData2;\n\tunion dce_dmcu_psr_config_data_reg3 masterCmdData3;\n\n\tlink->link_enc->funcs->psr_program_dp_dphy_fast_training(link->link_enc,\n\t\t\tpsr_context->psrExitLinkTrainingRequired);\n\n\t \n\t \n\tREG_UPDATE_4(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN2_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN3_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN4_INT_TO_UC_EN, 0);\n\n\tswitch (psr_context->controllerId) {\n\t \n\tcase 1:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN2_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN3_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 4:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN4_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 5:\n\t\t \n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 1);\n\t\tbreak;\n\t}\n\n\tlink->link_enc->funcs->psr_program_secondary_packet(link->link_enc,\n\t\t\tpsr_context->sdpTransmitLineNumDeadline);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\t \n\tmasterCmdData1.u32All = 0;\n\tmasterCmdData1.bits.timehyst_frames = psr_context->timehyst_frames;\n\tmasterCmdData1.bits.hyst_lines = psr_context->hyst_lines;\n\tmasterCmdData1.bits.rfb_update_auto_en =\n\t\t\tpsr_context->rfb_update_auto_en;\n\tmasterCmdData1.bits.dp_port_num = psr_context->transmitterId;\n\tmasterCmdData1.bits.dcp_sel = psr_context->controllerId;\n\tmasterCmdData1.bits.phy_type  = psr_context->phyType;\n\tmasterCmdData1.bits.frame_cap_ind =\n\t\t\tpsr_context->psrFrameCaptureIndicationReq;\n\tmasterCmdData1.bits.aux_chan = psr_context->channel;\n\tmasterCmdData1.bits.aux_repeat = psr_context->aux_repeats;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1),\n\t\t\t\t\tmasterCmdData1.u32All);\n\n\tmasterCmdData2.u32All = 0;\n\tmasterCmdData2.bits.dig_fe = psr_context->engineId;\n\tmasterCmdData2.bits.dig_be = psr_context->transmitterId;\n\tmasterCmdData2.bits.skip_wait_for_pll_lock =\n\t\t\tpsr_context->skipPsrWaitForPllLock;\n\tmasterCmdData2.bits.frame_delay = psr_context->frame_delay;\n\tmasterCmdData2.bits.smu_phy_id = psr_context->smuPhyId;\n\tmasterCmdData2.bits.num_of_controllers =\n\t\t\tpsr_context->numberOfControllers;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG2),\n\t\t\tmasterCmdData2.u32All);\n\n\tmasterCmdData3.u32All = 0;\n\tmasterCmdData3.bits.psr_level = psr_context->psr_level.u32all;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG3),\n\t\t\tmasterCmdData3.u32All);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG,\n\t\t\tMASTER_COMM_CMD_REG_BYTE0, PSR_SET);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\treturn true;\n}\n\nstatic bool dce_is_dmcu_initialized(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int dmcu_uc_reset;\n\n\t \n\tREG_GET(DMCU_STATUS, UC_IN_RESET, &dmcu_uc_reset);\n\n\t \n\tif (dmcu_uc_reset)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void dce_psr_wait_loop(\n\tstruct dmcu *dmcu,\n\tunsigned int wait_loop_number)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunion dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;\n\n\tif (dmcu->cached_wait_loop_number == wait_loop_number)\n\t\treturn;\n\n\t \n\tif (!dce_is_dmcu_initialized(dmcu))\n\t\treturn;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\tmasterCmdData1.u32 = 0;\n\tmasterCmdData1.bits.wait_loop = wait_loop_number;\n\tdmcu->cached_wait_loop_number = wait_loop_number;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1), masterCmdData1.u32);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, PSR_SET_WAITLOOP);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n}\n\nstatic void dce_get_psr_wait_loop(\n\t\tstruct dmcu *dmcu, unsigned int *psr_wait_loop_number)\n{\n\t*psr_wait_loop_number = dmcu->cached_wait_loop_number;\n\treturn;\n}\n\nstatic void dcn10_get_dmcu_version(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tuint32_t dmcu_version_offset = 0xf1;\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 1,\n\t\t\tIRAM_RD_ADDR_AUTO_INC, 1);\n\n\tREG_WAIT(DMU_MEM_PWR_CNTL, DMCU_IRAM_MEM_PWR_STATE, 0, 2, 10);\n\n\t \n\tREG_WRITE(DMCU_IRAM_RD_CTRL, dmcu_version_offset);\n\tdmcu->dmcu_version.interface_version = REG_READ(DMCU_IRAM_RD_DATA);\n\tdmcu->dmcu_version.abm_version = REG_READ(DMCU_IRAM_RD_DATA);\n\tdmcu->dmcu_version.psr_version = REG_READ(DMCU_IRAM_RD_DATA);\n\tdmcu->dmcu_version.build_version = ((REG_READ(DMCU_IRAM_RD_DATA) << 8) |\n\t\t\t\t\t\tREG_READ(DMCU_IRAM_RD_DATA));\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 0,\n\t\t\tIRAM_RD_ADDR_AUTO_INC, 0);\n}\n\nstatic void dcn10_dmcu_enable_fractional_pwm(struct dmcu *dmcu,\n\t\tuint32_t fractional_pwm)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n\n\t \n\tREG_WRITE(MASTER_COMM_DATA_REG1, fractional_pwm);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\tMCP_BL_SET_PWM_FRAC);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n}\n\nstatic bool dcn10_dmcu_init(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tconst struct dc_config *config = &dmcu->ctx->dc->config;\n\tbool status = false;\n\tstruct dc_context *ctx = dmcu->ctx;\n\tunsigned int i;\n\t\n\t\n\tunsigned int tx_interrupt_mask = 0;\n\n\tPERF_TRACE();\n\t \n\tdmcu->dmcu_state = REG_READ(DC_DMCU_SCRATCH);\n\n\tfor (i = 0; i < ctx->dc->link_count; i++) {\n\t\tif (ctx->dc->links[i]->link_enc->features.flags.bits.DP_IS_USB_C) {\n\t\t\tif (ctx->dc->links[i]->link_enc->transmitter >= TRANSMITTER_UNIPHY_A &&\n\t\t\t\t\tctx->dc->links[i]->link_enc->transmitter <= TRANSMITTER_UNIPHY_F) {\n\t\t\t\ttx_interrupt_mask |= 1 << ctx->dc->links[i]->link_enc->transmitter;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (dmcu->dmcu_state) {\n\tcase DMCU_UNLOADED:\n\t\tstatus = false;\n\t\tbreak;\n\tcase DMCU_LOADED_UNINITIALIZED:\n\t\t \n\t\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n\n\t\t \n\t\tREG_WRITE(MASTER_COMM_DATA_REG1, 0xFFFF);\n\n\t\t \n\t\tREG_WRITE(MASTER_COMM_DATA_REG2, abm_gain_stepsize);\n\n\t\tREG_WRITE(MASTER_COMM_DATA_REG3, tx_interrupt_mask);\n\n\t\t \n\t\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\tMCP_INIT_DMCU);\n\n\t\t \n\t\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t\t \n\t\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n\n\t\t\n\t\tdmcu->dmcu_state = REG_READ(DC_DMCU_SCRATCH);\n\n\t\t\n\t\tif (dmcu->dmcu_state == DMCU_RUNNING) {\n\t\t\t \n\t\t\tdcn10_get_dmcu_version(dmcu);\n\n\t\t\t \n\t\t\tdcn10_dmcu_enable_fractional_pwm(dmcu,\n\t\t\t\t(config->disable_fractional_pwm == false) ? 1 : 0);\n\t\t\tstatus = true;\n\t\t} else {\n\t\t\tstatus = false;\n\t\t}\n\n\t\tbreak;\n\tcase DMCU_RUNNING:\n\t\tstatus = true;\n\t\tbreak;\n\tdefault:\n\t\tstatus = false;\n\t\tbreak;\n\t}\n\n\tPERF_TRACE();\n\treturn status;\n}\n\nstatic bool dcn21_dmcu_init(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tuint32_t dmcub_psp_version = REG_READ(DMCUB_SCRATCH15);\n\n\tif (dmcu->auto_load_dmcu && dmcub_psp_version == 0) {\n\t\treturn false;\n\t}\n\n\treturn dcn10_dmcu_init(dmcu);\n}\n\nstatic bool dcn10_dmcu_load_iram(struct dmcu *dmcu,\n\t\tunsigned int start_offset,\n\t\tconst char *src,\n\t\tunsigned int bytes)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int count = 0;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 1,\n\t\t\tIRAM_WR_ADDR_AUTO_INC, 1);\n\n\tREG_WAIT(DMU_MEM_PWR_CNTL, DMCU_IRAM_MEM_PWR_STATE, 0, 2, 10);\n\n\tREG_WRITE(DMCU_IRAM_WR_CTRL, start_offset);\n\n\tfor (count = 0; count < bytes; count++)\n\t\tREG_WRITE(DMCU_IRAM_WR_DATA, src[count]);\n\n\t \n\tREG_UPDATE_2(DMCU_RAM_ACCESS_CTRL,\n\t\t\tIRAM_HOST_ACCESS_EN, 0,\n\t\t\tIRAM_WR_ADDR_AUTO_INC, 0);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\tMCP_INIT_IRAM);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 100, 800);\n\n\treturn true;\n}\n\nstatic void dcn10_get_dmcu_psr_state(struct dmcu *dmcu, enum dc_psr_state *state)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\tuint32_t psr_state_offset = 0xf0;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn;\n\n\t \n\tREG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 1);\n\n\tREG_WAIT(DMU_MEM_PWR_CNTL, DMCU_IRAM_MEM_PWR_STATE, 0, 2, 10);\n\n\t \n\tREG_WRITE(DMCU_IRAM_RD_CTRL, psr_state_offset);\n\n\t \n\t*state = (enum dc_psr_state)REG_READ(DMCU_IRAM_RD_DATA);\n\n\t \n\tREG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 0);\n}\n\nstatic void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\n\tunsigned int retryCount;\n\tenum dc_psr_state state = PSR_STATE0;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\t \n\tif (enable)\n\t\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tPSR_ENABLE);\n\telse\n\t\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tPSR_EXIT);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tif (wait == true) {\n\t\tfor (retryCount = 0; retryCount <= 1000; retryCount++) {\n\t\t\tdcn10_get_dmcu_psr_state(dmcu, &state);\n\t\t\tif (enable) {\n\t\t\t\tif (state != PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (state == PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tudelay(500);\n\t\t}\n\n\t\t \n\t\tif (retryCount >= 1000)\n\t\t\tASSERT(0);\n\t}\n}\n\nstatic bool dcn10_dmcu_setup_psr(struct dmcu *dmcu,\n\t\tstruct dc_link *link,\n\t\tstruct psr_context *psr_context)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\n\tunion dce_dmcu_psr_config_data_reg1 masterCmdData1;\n\tunion dce_dmcu_psr_config_data_reg2 masterCmdData2;\n\tunion dce_dmcu_psr_config_data_reg3 masterCmdData3;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\tlink->link_enc->funcs->psr_program_dp_dphy_fast_training(link->link_enc,\n\t\t\tpsr_context->psrExitLinkTrainingRequired);\n\n\t \n\t \n\tREG_UPDATE_4(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN2_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN3_INT_TO_UC_EN, 0,\n\t\t\tSTATIC_SCREEN4_INT_TO_UC_EN, 0);\n\n\tswitch (psr_context->controllerId) {\n\t \n\tcase 1:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 2:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN2_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 3:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN3_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 4:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN4_INT_TO_UC_EN, 1);\n\t\tbreak;\n\tcase 5:\n\t\t \n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tREG_UPDATE(DMCU_INTERRUPT_TO_UC_EN_MASK,\n\t\t\t\tSTATIC_SCREEN1_INT_TO_UC_EN, 1);\n\t\tbreak;\n\t}\n\n\tlink->link_enc->funcs->psr_program_secondary_packet(link->link_enc,\n\t\t\tpsr_context->sdpTransmitLineNumDeadline);\n\n\tif (psr_context->allow_smu_optimizations)\n\t\tREG_UPDATE(SMU_INTERRUPT_CONTROL, DC_SMU_INT_ENABLE, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\t \n\tmasterCmdData1.u32All = 0;\n\tmasterCmdData1.bits.timehyst_frames = psr_context->timehyst_frames;\n\tmasterCmdData1.bits.hyst_lines = psr_context->hyst_lines;\n\tmasterCmdData1.bits.rfb_update_auto_en =\n\t\t\tpsr_context->rfb_update_auto_en;\n\tmasterCmdData1.bits.dp_port_num = psr_context->transmitterId;\n\tmasterCmdData1.bits.dcp_sel = psr_context->controllerId;\n\tmasterCmdData1.bits.phy_type  = psr_context->phyType;\n\tmasterCmdData1.bits.frame_cap_ind =\n\t\t\tpsr_context->psrFrameCaptureIndicationReq;\n\tmasterCmdData1.bits.aux_chan = psr_context->channel;\n\tmasterCmdData1.bits.aux_repeat = psr_context->aux_repeats;\n\tmasterCmdData1.bits.allow_smu_optimizations = psr_context->allow_smu_optimizations;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1),\n\t\t\t\t\tmasterCmdData1.u32All);\n\n\tmasterCmdData2.u32All = 0;\n\tmasterCmdData2.bits.dig_fe = psr_context->engineId;\n\tmasterCmdData2.bits.dig_be = psr_context->transmitterId;\n\tmasterCmdData2.bits.skip_wait_for_pll_lock =\n\t\t\tpsr_context->skipPsrWaitForPllLock;\n\tmasterCmdData2.bits.frame_delay = psr_context->frame_delay;\n\tmasterCmdData2.bits.smu_phy_id = psr_context->smuPhyId;\n\tmasterCmdData2.bits.num_of_controllers =\n\t\t\tpsr_context->numberOfControllers;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG2),\n\t\t\tmasterCmdData2.u32All);\n\n\tmasterCmdData3.u32All = 0;\n\tmasterCmdData3.bits.psr_level = psr_context->psr_level.u32all;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG3),\n\t\t\tmasterCmdData3.u32All);\n\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG,\n\t\t\tMASTER_COMM_CMD_REG_BYTE0, PSR_SET);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\treturn true;\n}\n\nstatic void dcn10_psr_wait_loop(\n\tstruct dmcu *dmcu,\n\tunsigned int wait_loop_number)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunion dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn;\n\n\tif (wait_loop_number != 0) {\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\tmasterCmdData1.u32 = 0;\n\tmasterCmdData1.bits.wait_loop = wait_loop_number;\n\tdmcu->cached_wait_loop_number = wait_loop_number;\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1), masterCmdData1.u32);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, PSR_SET_WAITLOOP);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\t}\n}\n\nstatic void dcn10_get_psr_wait_loop(\n\t\tstruct dmcu *dmcu, unsigned int *psr_wait_loop_number)\n{\n\t*psr_wait_loop_number = dmcu->cached_wait_loop_number;\n\treturn;\n}\n\nstatic bool dcn10_is_dmcu_initialized(struct dmcu *dmcu)\n{\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\treturn true;\n}\n\n\n\nstatic bool dcn20_lock_phy(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, MCP_SYNC_PHY_LOCK);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\treturn true;\n}\n\nstatic bool dcn20_unlock_phy(struct dmcu *dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, MCP_SYNC_PHY_UNLOCK);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\treturn true;\n}\n\nstatic bool dcn10_send_edid_cea(struct dmcu *dmcu,\n\t\tint offset,\n\t\tint total_length,\n\t\tuint8_t *data,\n\t\tint length)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tuint32_t header, data1, data2;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\tif (length > 8 || length <= 0)\n\t\treturn false;\n\n\theader = ((uint32_t)offset & 0xFFFF) << 16 | (total_length & 0xFFFF);\n\tdata1 = (((uint32_t)data[0]) << 24) | (((uint32_t)data[1]) << 16) |\n\t\t(((uint32_t)data[2]) << 8) | ((uint32_t)data[3]);\n\tdata2 = (((uint32_t)data[4]) << 24) | (((uint32_t)data[5]) << 16) |\n\t\t(((uint32_t)data[6]) << 8) | ((uint32_t)data[7]);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0, MCP_SEND_EDID_CEA);\n\n\tREG_WRITE(MASTER_COMM_DATA_REG1, header);\n\tREG_WRITE(MASTER_COMM_DATA_REG2, data1);\n\tREG_WRITE(MASTER_COMM_DATA_REG3, data2);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);\n\n\treturn true;\n}\n\nstatic bool dcn10_get_scp_results(struct dmcu *dmcu,\n\t\tuint32_t *cmd,\n\t\tuint32_t *data1,\n\t\tuint32_t *data2,\n\t\tuint32_t *data3)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn false;\n\n\t*cmd = REG_READ(SLAVE_COMM_CMD_REG);\n\t*data1 =  REG_READ(SLAVE_COMM_DATA_REG1);\n\t*data2 =  REG_READ(SLAVE_COMM_DATA_REG2);\n\t*data3 =  REG_READ(SLAVE_COMM_DATA_REG3);\n\n\t \n\tREG_UPDATE(SLAVE_COMM_CNTL_REG, SLAVE_COMM_INTERRUPT, 0);\n\n\treturn true;\n}\n\nstatic bool dcn10_recv_amd_vsdb(struct dmcu *dmcu,\n\t\tint *version,\n\t\tint *min_frame_rate,\n\t\tint *max_frame_rate)\n{\n\tuint32_t data[4];\n\tint cmd, ack, len;\n\n\tif (!dcn10_get_scp_results(dmcu, &data[0], &data[1], &data[2], &data[3]))\n\t\treturn false;\n\n\tcmd = data[0] & 0x3FF;\n\tlen = (data[0] >> 10) & 0x3F;\n\tack = data[1];\n\n\tif (cmd != MCP_SEND_EDID_CEA || ack != EDID_CEA_CMD_ACK || len != 12)\n\t\treturn false;\n\n\tif ((data[2] & 0xFF)) {\n\t\t*version = (data[2] >> 8) & 0xFF;\n\t\t*min_frame_rate = (data[3] >> 16) & 0xFFFF;\n\t\t*max_frame_rate = data[3] & 0xFFFF;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool dcn10_recv_edid_cea_ack(struct dmcu *dmcu, int *offset)\n{\n\tuint32_t data[4];\n\tint cmd, ack;\n\n\tif (!dcn10_get_scp_results(dmcu,\n\t\t\t\t&data[0], &data[1], &data[2], &data[3]))\n\t\treturn false;\n\n\tcmd = data[0] & 0x3FF;\n\tack = data[1];\n\n\tif (cmd != MCP_SEND_EDID_CEA)\n\t\treturn false;\n\n\tif (ack == EDID_CEA_CMD_ACK)\n\t\treturn true;\n\n\t*offset = data[2];  \n\treturn false;\n}\n\n\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\nstatic void dcn10_forward_crc_window(struct dmcu *dmcu,\n\t\t\t\t\tstruct rect *rect,\n\t\t\t\t\tstruct otg_phy_mux *mux_mapping)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\tunsigned int crc_start = 0, crc_end = 0, otg_phy_mux = 0;\n\tint x_start, y_start, x_end, y_end;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn;\n\n\tif (!rect)\n\t\treturn;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\tx_start = rect->x;\n\ty_start = rect->y;\n\tx_end = x_start + rect->width;\n\ty_end = y_start + rect->height;\n\n\t \n\tcrc_start = (((unsigned int) x_start) << 16) | y_start;\n\tcrc_end = (((unsigned int) x_end) << 16) | y_end;\n\totg_phy_mux =\n\t\t(((unsigned int) mux_mapping->otg_output_num) << 16) | mux_mapping->phy_output_num;\n\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1),\n\t\t\t\t\tcrc_start);\n\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG2),\n\t\t\tcrc_end);\n\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG3),\n\t\t\totg_phy_mux);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tCRC_WIN_NOTIFY);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n}\n\nstatic void dcn10_stop_crc_win_update(struct dmcu *dmcu,\n\t\t\t\t\tstruct otg_phy_mux *mux_mapping)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);\n\tunsigned int dmcu_max_retry_on_wait_reg_ready = 801;\n\tunsigned int dmcu_wait_reg_ready_interval = 100;\n\tunsigned int otg_phy_mux = 0;\n\n\t \n\tif (dmcu->dmcu_state != DMCU_RUNNING)\n\t\treturn;\n\n\t \n\tREG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0,\n\t\t\t\tdmcu_wait_reg_ready_interval,\n\t\t\t\tdmcu_max_retry_on_wait_reg_ready);\n\n\t \n\totg_phy_mux =\n\t\t(((unsigned int) mux_mapping->otg_output_num) << 16) | mux_mapping->phy_output_num;\n\n\tdm_write_reg(dmcu->ctx, REG(MASTER_COMM_DATA_REG1),\n\t\t\t\t\totg_phy_mux);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CMD_REG, MASTER_COMM_CMD_REG_BYTE0,\n\t\t\t\tCRC_STOP_UPDATE);\n\n\t \n\tREG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);\n}\n#endif\n\nstatic const struct dmcu_funcs dce_funcs = {\n\t.dmcu_init = dce_dmcu_init,\n\t.load_iram = dce_dmcu_load_iram,\n\t.set_psr_enable = dce_dmcu_set_psr_enable,\n\t.setup_psr = dce_dmcu_setup_psr,\n\t.get_psr_state = dce_get_dmcu_psr_state,\n\t.set_psr_wait_loop = dce_psr_wait_loop,\n\t.get_psr_wait_loop = dce_get_psr_wait_loop,\n\t.is_dmcu_initialized = dce_is_dmcu_initialized\n};\n\nstatic const struct dmcu_funcs dcn10_funcs = {\n\t.dmcu_init = dcn10_dmcu_init,\n\t.load_iram = dcn10_dmcu_load_iram,\n\t.set_psr_enable = dcn10_dmcu_set_psr_enable,\n\t.setup_psr = dcn10_dmcu_setup_psr,\n\t.get_psr_state = dcn10_get_dmcu_psr_state,\n\t.set_psr_wait_loop = dcn10_psr_wait_loop,\n\t.get_psr_wait_loop = dcn10_get_psr_wait_loop,\n\t.send_edid_cea = dcn10_send_edid_cea,\n\t.recv_amd_vsdb = dcn10_recv_amd_vsdb,\n\t.recv_edid_cea_ack = dcn10_recv_edid_cea_ack,\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\n\t.forward_crc_window = dcn10_forward_crc_window,\n\t.stop_crc_win_update = dcn10_stop_crc_win_update,\n#endif\n\t.is_dmcu_initialized = dcn10_is_dmcu_initialized\n};\n\nstatic const struct dmcu_funcs dcn20_funcs = {\n\t.dmcu_init = dcn10_dmcu_init,\n\t.load_iram = dcn10_dmcu_load_iram,\n\t.set_psr_enable = dcn10_dmcu_set_psr_enable,\n\t.setup_psr = dcn10_dmcu_setup_psr,\n\t.get_psr_state = dcn10_get_dmcu_psr_state,\n\t.set_psr_wait_loop = dcn10_psr_wait_loop,\n\t.get_psr_wait_loop = dcn10_get_psr_wait_loop,\n\t.is_dmcu_initialized = dcn10_is_dmcu_initialized,\n\t.lock_phy = dcn20_lock_phy,\n\t.unlock_phy = dcn20_unlock_phy\n};\n\nstatic const struct dmcu_funcs dcn21_funcs = {\n\t.dmcu_init = dcn21_dmcu_init,\n\t.load_iram = dcn10_dmcu_load_iram,\n\t.set_psr_enable = dcn10_dmcu_set_psr_enable,\n\t.setup_psr = dcn10_dmcu_setup_psr,\n\t.get_psr_state = dcn10_get_dmcu_psr_state,\n\t.set_psr_wait_loop = dcn10_psr_wait_loop,\n\t.get_psr_wait_loop = dcn10_get_psr_wait_loop,\n\t.is_dmcu_initialized = dcn10_is_dmcu_initialized,\n\t.lock_phy = dcn20_lock_phy,\n\t.unlock_phy = dcn20_unlock_phy\n};\n\nstatic void dce_dmcu_construct(\n\tstruct dce_dmcu *dmcu_dce,\n\tstruct dc_context *ctx,\n\tconst struct dce_dmcu_registers *regs,\n\tconst struct dce_dmcu_shift *dmcu_shift,\n\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tstruct dmcu *base = &dmcu_dce->base;\n\n\tbase->ctx = ctx;\n\tbase->funcs = &dce_funcs;\n\tbase->cached_wait_loop_number = 0;\n\n\tdmcu_dce->regs = regs;\n\tdmcu_dce->dmcu_shift = dmcu_shift;\n\tdmcu_dce->dmcu_mask = dmcu_mask;\n}\n\nstatic void dcn21_dmcu_construct(\n\t\tstruct dce_dmcu *dmcu_dce,\n\t\tstruct dc_context *ctx,\n\t\tconst struct dce_dmcu_registers *regs,\n\t\tconst struct dce_dmcu_shift *dmcu_shift,\n\t\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tuint32_t psp_version = 0;\n\n\tdce_dmcu_construct(dmcu_dce, ctx, regs, dmcu_shift, dmcu_mask);\n\n\tpsp_version = dm_read_reg(ctx, mmMP0_SMN_C2PMSG_58);\n\tdmcu_dce->base.auto_load_dmcu = ((psp_version & 0x00FF00FF) > 0x00110029);\n\tdmcu_dce->base.psp_version = psp_version;\n}\n\nstruct dmcu *dce_dmcu_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_dmcu_registers *regs,\n\tconst struct dce_dmcu_shift *dmcu_shift,\n\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tstruct dce_dmcu *dmcu_dce = kzalloc(sizeof(*dmcu_dce), GFP_KERNEL);\n\n\tif (dmcu_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_dmcu_construct(\n\t\tdmcu_dce, ctx, regs, dmcu_shift, dmcu_mask);\n\n\tdmcu_dce->base.funcs = &dce_funcs;\n\n\treturn &dmcu_dce->base;\n}\n\nstruct dmcu *dcn10_dmcu_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_dmcu_registers *regs,\n\tconst struct dce_dmcu_shift *dmcu_shift,\n\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tstruct dce_dmcu *dmcu_dce = kzalloc(sizeof(*dmcu_dce), GFP_ATOMIC);\n\n\tif (dmcu_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_dmcu_construct(\n\t\tdmcu_dce, ctx, regs, dmcu_shift, dmcu_mask);\n\n\tdmcu_dce->base.funcs = &dcn10_funcs;\n\n\treturn &dmcu_dce->base;\n}\n\nstruct dmcu *dcn20_dmcu_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_dmcu_registers *regs,\n\tconst struct dce_dmcu_shift *dmcu_shift,\n\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tstruct dce_dmcu *dmcu_dce = kzalloc(sizeof(*dmcu_dce), GFP_ATOMIC);\n\n\tif (dmcu_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_dmcu_construct(\n\t\tdmcu_dce, ctx, regs, dmcu_shift, dmcu_mask);\n\n\tdmcu_dce->base.funcs = &dcn20_funcs;\n\n\treturn &dmcu_dce->base;\n}\n\nstruct dmcu *dcn21_dmcu_create(\n\tstruct dc_context *ctx,\n\tconst struct dce_dmcu_registers *regs,\n\tconst struct dce_dmcu_shift *dmcu_shift,\n\tconst struct dce_dmcu_mask *dmcu_mask)\n{\n\tstruct dce_dmcu *dmcu_dce = kzalloc(sizeof(*dmcu_dce), GFP_ATOMIC);\n\n\tif (dmcu_dce == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn21_dmcu_construct(\n\t\tdmcu_dce, ctx, regs, dmcu_shift, dmcu_mask);\n\n\tdmcu_dce->base.funcs = &dcn21_funcs;\n\n\treturn &dmcu_dce->base;\n}\n\nvoid dce_dmcu_destroy(struct dmcu **dmcu)\n{\n\tstruct dce_dmcu *dmcu_dce = TO_DCE_DMCU(*dmcu);\n\n\tkfree(dmcu_dce);\n\t*dmcu = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}