{
  "module_name": "dce110_clk_mgr.c",
  "hash_id": "37e5b8f5c442e00357da327e926accb72da1a273fc49cd5f56eeb07c6fab6157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dce110/dce110_clk_mgr.c",
  "human_readable_source": " \n\n#include \"core_types.h\"\n#include \"clk_mgr_internal.h\"\n\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n#include \"dce110_clk_mgr.h\"\n#include \"../clk_mgr/dce100/dce_clk_mgr.h\"\n\n \n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n \n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct clk_mgr_registers disp_clk_regs = {\n\t\tCLK_COMMON_REG_LIST_DCE_BASE()\n};\n\nstatic const struct clk_mgr_shift disp_clk_shift = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct clk_mgr_mask disp_clk_mask = {\n\t\tCLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct state_dependent_clocks dce110_max_clks_by_state[] = {\n \n{ .display_clk_khz = 0, .pixel_clk_khz = 0 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000 },\n \n{ .display_clk_khz = 352000, .pixel_clk_khz = 330000 },\n \n{ .display_clk_khz = 467000, .pixel_clk_khz = 400000 },\n \n{ .display_clk_khz = 643000, .pixel_clk_khz = 400000 } };\n\nstatic int determine_sclk_from_bounding_box(\n\t\tconst struct dc *dc,\n\t\tint required_sclk)\n{\n\tint i;\n\n\t \n\tif (dc->sclk_lvls.num_levels == 0)\n\t\treturn required_sclk;\n\n\tfor (i = 0; i < dc->sclk_lvls.num_levels; i++) {\n\t\tif (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)\n\t\t\treturn dc->sclk_lvls.clocks_in_khz[i];\n\t}\n\t \n\tASSERT(0);\n\treturn dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];\n}\n\nuint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)\n{\n\tuint8_t j;\n\tuint32_t min_vertical_blank_time = -1;\n\n\tfor (j = 0; j < context->stream_count; j++) {\n\t\tstruct dc_stream_state *stream = context->streams[j];\n\t\tuint32_t vertical_blank_in_pixels = 0;\n\t\tuint32_t vertical_blank_time = 0;\n\t\tuint32_t vertical_total_min = stream->timing.v_total;\n\t\tstruct dc_crtc_timing_adjust adjust = stream->adjust;\n\t\tif (adjust.v_total_max != adjust.v_total_min)\n\t\t\tvertical_total_min = adjust.v_total_min;\n\n\t\tvertical_blank_in_pixels = stream->timing.h_total *\n\t\t\t(vertical_total_min\n\t\t\t - stream->timing.v_addressable);\n\t\tvertical_blank_time = vertical_blank_in_pixels\n\t\t\t* 10000 / stream->timing.pix_clk_100hz;\n\n\t\tif (min_vertical_blank_time > vertical_blank_time)\n\t\t\tmin_vertical_blank_time = vertical_blank_time;\n\t}\n\n\treturn min_vertical_blank_time;\n}\n\nvoid dce110_fill_display_configs(\n\tconst struct dc_state *context,\n\tstruct dm_pp_display_configuration *pp_display_cfg)\n{\n\tint j;\n\tint num_cfgs = 0;\n\n\tfor (j = 0; j < context->stream_count; j++) {\n\t\tint k;\n\n\t\tconst struct dc_stream_state *stream = context->streams[j];\n\t\tstruct dm_pp_single_disp_config *cfg =\n\t\t\t&pp_display_cfg->disp_configs[num_cfgs];\n\t\tconst struct pipe_ctx *pipe_ctx = NULL;\n\n\t\tfor (k = 0; k < MAX_PIPES; k++)\n\t\t\tif (stream == context->res_ctx.pipe_ctx[k].stream) {\n\t\t\t\tpipe_ctx = &context->res_ctx.pipe_ctx[k];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tASSERT(pipe_ctx != NULL);\n\n\t\t \n\t\tif (stream->dpms_off)\n\t\t\tcontinue;\n\n\t\tnum_cfgs++;\n\t\tcfg->signal = pipe_ctx->stream->signal;\n\t\tcfg->pipe_idx = pipe_ctx->stream_res.tg->inst;\n\t\tcfg->src_height = stream->src.height;\n\t\tcfg->src_width = stream->src.width;\n\t\tcfg->ddi_channel_mapping =\n\t\t\tstream->link->ddi_channel_mapping.raw;\n\t\tcfg->transmitter =\n\t\t\tstream->link->link_enc->transmitter;\n\t\tcfg->link_settings.lane_count =\n\t\t\tstream->link->cur_link_settings.lane_count;\n\t\tcfg->link_settings.link_rate =\n\t\t\tstream->link->cur_link_settings.link_rate;\n\t\tcfg->link_settings.link_spread =\n\t\t\tstream->link->cur_link_settings.link_spread;\n\t\tcfg->sym_clock = stream->phy_pix_clk;\n\t\t \n\t\tcfg->v_refresh = stream->timing.pix_clk_100hz * 100;\n\t\tcfg->v_refresh /= stream->timing.h_total;\n\t\tcfg->v_refresh = (cfg->v_refresh + stream->timing.v_total / 2)\n\t\t\t\t\t\t\t/ stream->timing.v_total;\n\t}\n\n\tpp_display_cfg->display_count = num_cfgs;\n}\n\nvoid dce11_pplib_apply_display_requirements(\n\tstruct dc *dc,\n\tstruct dc_state *context)\n{\n\tstruct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\tif (dc->bw_vbios && dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\tpp_display_cfg->all_displays_in_sync =\n\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync;\n\tpp_display_cfg->nb_pstate_switch_disable =\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable == false;\n\tpp_display_cfg->cpu_cc6_disable =\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable == false;\n\tpp_display_cfg->cpu_pstate_disable =\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable == false;\n\tpp_display_cfg->cpu_pstate_separation_time =\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us;\n\n\t \n\tif ((dc->ctx->asic_id.chip_family == FAMILY_AI) &&\n\t     ASICREV_IS_VEGA20_P(dc->ctx->asic_id.hw_internal_rev) && (context->stream_count >= 2)) {\n\t\tpp_display_cfg->min_memory_clock_khz = max(pp_display_cfg->min_memory_clock_khz,\n\t\t\t\t\t\t\t   (uint32_t) div64_s64(\n\t\t\t\t\t\t\t\t   div64_s64(dc->bw_vbios->high_yclk.value,\n\t\t\t\t\t\t\t\t\t     memory_type_multiplier), 10000));\n\t} else {\n\t\tpp_display_cfg->min_memory_clock_khz = context->bw_ctx.bw.dce.yclk_khz\n\t\t\t/ memory_type_multiplier;\n\t}\n\n\tpp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(\n\t\t\tdc,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz);\n\n\t \n\tpp_display_cfg->min_dcfclock_khz = (context->stream_count > 4) ?\n\t\t\tpp_display_cfg->min_engine_clock_khz : 0;\n\n\tpp_display_cfg->min_engine_clock_deep_sleep_khz\n\t\t\t= context->bw_ctx.bw.dce.sclk_deep_sleep_khz;\n\n\tpp_display_cfg->avail_mclk_switch_time_us =\n\t\t\t\t\t\tdce110_get_min_vblank_time_us(context);\n\t \n\tpp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;\n\n\tpp_display_cfg->disp_clk_khz = dc->clk_mgr->clks.dispclk_khz;\n\n\tdce110_fill_display_configs(context, pp_display_cfg);\n\n\t \n\tif (pp_display_cfg->display_count == 1) {\n\t\tconst struct dc_crtc_timing *timing =\n\t\t\t&context->streams[0]->timing;\n\n\t\tpp_display_cfg->crtc_index =\n\t\t\tpp_display_cfg->disp_configs[0].pipe_idx;\n\t\tpp_display_cfg->line_time_in_us = timing->h_total * 10000 / timing->pix_clk_100hz;\n\t}\n\n\tif (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)\n\t\tdm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);\n}\n\nstatic void dce11_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\tstruct dc_state *context,\n\t\t\tbool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr_dce = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dm_pp_power_level_change_request level_change_req;\n\tint patched_disp_clk = context->bw_ctx.bw.dce.dispclk_khz;\n\n\t \n\tif (!clk_mgr_dce->dfs_bypass_active)\n\t\tpatched_disp_clk = patched_disp_clk * 115 / 100;\n\n\tlevel_change_req.power_level = dce_get_required_clocks_state(clk_mgr_base, context);\n\t \n\tif ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)\n\t\t\t|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {\n\t\tif (dm_pp_apply_power_level_change_request(clk_mgr_base->ctx, &level_change_req))\n\t\t\tclk_mgr_dce->cur_min_clks_state = level_change_req.power_level;\n\t}\n\n\tif (should_set_clock(safe_to_lower, patched_disp_clk, clk_mgr_base->clks.dispclk_khz)) {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = dce_set_clock(clk_mgr_base, patched_disp_clk);\n\t\tclk_mgr_base->clks.dispclk_khz = patched_disp_clk;\n\t}\n\tdce11_pplib_apply_display_requirements(clk_mgr_base->ctx->dc, context);\n}\n\nstatic struct clk_mgr_funcs dce110_funcs = {\n\t.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,\n\t.update_clocks = dce11_update_clocks\n};\n\nvoid dce110_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr)\n{\n\tdce_clk_mgr_construct(ctx, clk_mgr);\n\n\tmemcpy(clk_mgr->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state));\n\n\tclk_mgr->regs = &disp_clk_regs;\n\tclk_mgr->clk_mgr_shift = &disp_clk_shift;\n\tclk_mgr->clk_mgr_mask = &disp_clk_mask;\n\tclk_mgr->base.funcs = &dce110_funcs;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}