{
  "module_name": "hw_ddc.c",
  "hash_id": "b2acad3ef7586dcc6ff05539ed6dc92d46878c722db526b1d610f7cb45fc97fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/gpio/hw_ddc.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"include/gpio_interface.h\"\n#include \"include/gpio_types.h\"\n#include \"hw_gpio.h\"\n#include \"hw_ddc.h\"\n\n#include \"reg_helper.h\"\n#include \"gpio_regs.h\"\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tddc->shifts->field_name, ddc->masks->field_name\n\n#define CTX \\\n\tddc->base.base.ctx\n#define REG(reg)\\\n\t(ddc->regs->reg)\n\nstruct gpio;\n\nstatic void dal_hw_ddc_destruct(\n\tstruct hw_ddc *pin)\n{\n\tdal_hw_gpio_destruct(&pin->base);\n}\n\nstatic void dal_hw_ddc_destroy(\n\tstruct hw_gpio_pin **ptr)\n{\n\tstruct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);\n\n\tdal_hw_ddc_destruct(pin);\n\n\tkfree(pin);\n\n\t*ptr = NULL;\n}\n\nstatic enum gpio_result set_config(\n\tstruct hw_gpio_pin *ptr,\n\tconst struct gpio_config_data *config_data)\n{\n\tstruct hw_ddc *ddc = HW_DDC_FROM_BASE(ptr);\n\tstruct hw_gpio *hw_gpio = NULL;\n\tuint32_t regval;\n\tuint32_t ddc_data_pd_en = 0;\n\tuint32_t ddc_clk_pd_en = 0;\n\tuint32_t aux_pad_mode = 0;\n\n\thw_gpio = &ddc->base;\n\n\tif (hw_gpio == NULL) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn GPIO_RESULT_NULL_HANDLE;\n\t}\n\n\tregval = REG_GET_3(gpio.MASK_reg,\n\t\t\tDC_GPIO_DDC1DATA_PD_EN, &ddc_data_pd_en,\n\t\t\tDC_GPIO_DDC1CLK_PD_EN, &ddc_clk_pd_en,\n\t\t\tAUX_PAD1_MODE, &aux_pad_mode);\n\n\tswitch (config_data->config.ddc.type) {\n\tcase GPIO_DDC_CONFIG_TYPE_MODE_I2C:\n\t\t \n\t\tif (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {\n\t\t\tif (!ddc_data_pd_en || !ddc_clk_pd_en) {\n\t\t\t\tif (hw_gpio->base.en == GPIO_DDC_LINE_DDC_VGA) {\n\t\t\t\t\t\n\t\t\t\t\tREG_SET(gpio.MASK_reg, regval, DC_GPIO_DDC1DATA_PD_EN, 1);\n\t\t\t\t} else {\n\t\t\t\t\tREG_SET_2(gpio.MASK_reg, regval,\n\t\t\t\t\t\tDC_GPIO_DDC1DATA_PD_EN, 1,\n\t\t\t\t\t\tDC_GPIO_DDC1CLK_PD_EN, 1);\n\t\t\t\t}\n\t\t\t\tif (config_data->type ==\n\t\t\t\t\t\tGPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)\n\t\t\t\t\tmsleep(3);\n\t\t\t}\n\t\t} else {\n\t\t\tuint32_t sda_pd_dis = 0;\n\t\t\tuint32_t scl_pd_dis = 0;\n\n\t\t\tREG_GET_2(gpio.MASK_reg,\n\t\t\t\t  DC_GPIO_SDA_PD_DIS, &sda_pd_dis,\n\t\t\t\t  DC_GPIO_SCL_PD_DIS, &scl_pd_dis);\n\n\t\t\tif (sda_pd_dis) {\n\t\t\t\tREG_SET(gpio.MASK_reg, regval,\n\t\t\t\t\t\tDC_GPIO_SDA_PD_DIS, 0);\n\n\t\t\t\tif (config_data->type ==\n\t\t\t\t\t\tGPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)\n\t\t\t\t\tmsleep(3);\n\t\t\t}\n\n\t\t\tif (!scl_pd_dis) {\n\t\t\t\tREG_SET(gpio.MASK_reg, regval,\n\t\t\t\t\t\tDC_GPIO_SCL_PD_DIS, 1);\n\n\t\t\t\tif (config_data->type ==\n\t\t\t\t\t\tGPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)\n\t\t\t\t\tmsleep(3);\n\t\t\t}\n\t\t}\n\n\t\tif (aux_pad_mode) {\n\t\t\t \n\t\t\tif (config_data->config.ddc.data_en_bit_present ||\n\t\t\t\tconfig_data->config.ddc.clock_en_bit_present)\n\t\t\t\t \n\t\t\t\tmsleep(2);\n\n\t\t\t \n\t\t\t \n\t\t\tREG_UPDATE(gpio.MASK_reg,\n\t\t\t\t\tAUX_PAD1_MODE, 0);\n\t\t}\n\n\t\tif (ddc->regs->dc_gpio_aux_ctrl_5 != 0) {\n\t\t\t\tREG_UPDATE(dc_gpio_aux_ctrl_5, DDC_PAD_I2CMODE, 1);\n\t\t}\n\t\t\n\t\tif (ddc->regs->phy_aux_cntl != 0) {\n\t\t\t\tREG_UPDATE(phy_aux_cntl, AUX_PAD_RXSEL, 1);\n\t\t}\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_DDC_CONFIG_TYPE_MODE_AUX:\n\t\t \n\t\tif (!aux_pad_mode) {\n\t\t\tREG_SET(gpio.MASK_reg, regval,\n\t\t\t\t\tAUX_PAD1_MODE, 1);\n\t\t}\n\t\tif (ddc->regs->dc_gpio_aux_ctrl_5 != 0) {\n\t\t\tREG_UPDATE(dc_gpio_aux_ctrl_5,\n\t\t\t\t\tDDC_PAD_I2CMODE, 0);\n\t\t}\n\n\t\treturn GPIO_RESULT_OK;\n\tcase GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:\n\t\tif ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&\n\t\t\t(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {\n\t\t\tREG_UPDATE_3(ddc_setup,\n\t\t\t\tDC_I2C_DDC1_ENABLE, 1,\n\t\t\t\tDC_I2C_DDC1_EDID_DETECT_ENABLE, 1,\n\t\t\t\tDC_I2C_DDC1_EDID_DETECT_MODE, 0);\n\t\t\treturn GPIO_RESULT_OK;\n\t\t}\n\tbreak;\n\tcase GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:\n\t\tif ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&\n\t\t\t(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {\n\t\t\tREG_UPDATE_3(ddc_setup,\n\t\t\t\tDC_I2C_DDC1_ENABLE, 1,\n\t\t\t\tDC_I2C_DDC1_EDID_DETECT_ENABLE, 1,\n\t\t\t\tDC_I2C_DDC1_EDID_DETECT_MODE, 1);\n\t\t\treturn GPIO_RESULT_OK;\n\t\t}\n\tbreak;\n\tcase GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:\n\t\tif ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&\n\t\t\t(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {\n\t\t\tREG_UPDATE_2(ddc_setup,\n\t\t\t\tDC_I2C_DDC1_ENABLE, 0,\n\t\t\t\tDC_I2C_DDC1_EDID_DETECT_ENABLE, 0);\n\t\t\treturn GPIO_RESULT_OK;\n\t\t}\n\tbreak;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\n\treturn GPIO_RESULT_NON_SPECIFIC_ERROR;\n}\n\nstatic const struct hw_gpio_pin_funcs funcs = {\n\t.destroy = dal_hw_ddc_destroy,\n\t.open = dal_hw_gpio_open,\n\t.get_value = dal_hw_gpio_get_value,\n\t.set_value = dal_hw_gpio_set_value,\n\t.set_config = set_config,\n\t.change_mode = dal_hw_gpio_change_mode,\n\t.close = dal_hw_gpio_close,\n};\n\nstatic void dal_hw_ddc_construct(\n\tstruct hw_ddc *ddc,\n\tenum gpio_id id,\n\tuint32_t en,\n\tstruct dc_context *ctx)\n{\n\tdal_hw_gpio_construct(&ddc->base, id, en, ctx);\n\tddc->base.base.funcs = &funcs;\n}\n\nvoid dal_hw_ddc_init(\n\tstruct hw_ddc **hw_ddc,\n\tstruct dc_context *ctx,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tif ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {\n\t\tASSERT_CRITICAL(false);\n\t\t*hw_ddc = NULL;\n\t}\n\n\t*hw_ddc = kzalloc(sizeof(struct hw_ddc), GFP_KERNEL);\n\tif (!*hw_ddc) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tdal_hw_ddc_construct(*hw_ddc, id, en, ctx);\n}\n\nstruct hw_gpio_pin *dal_hw_ddc_get_pin(struct gpio *gpio)\n{\n\tstruct hw_ddc *hw_ddc = dal_gpio_get_ddc(gpio);\n\n\treturn &hw_ddc->base.base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}