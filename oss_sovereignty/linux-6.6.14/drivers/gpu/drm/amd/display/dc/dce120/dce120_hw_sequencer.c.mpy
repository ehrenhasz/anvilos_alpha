{
  "module_name": "dce120_hw_sequencer.c",
  "hash_id": "cd50158f771d5b55691ab7f358c30fd8b2e6a11086feed4c82ffbed6e4ebd899",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"core_types.h\"\n#include \"dce120_hw_sequencer.h\"\n#include \"dce/dce_hwseq.h\"\n\n#include \"dce110/dce110_hw_sequencer.h\"\n\n#include \"dce/dce_12_0_offset.h\"\n#include \"dce/dce_12_0_sh_mask.h\"\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n#include \"reg_helper.h\"\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstruct dce120_hw_seq_reg_offsets {\n\tuint32_t crtc;\n};\n\n#if 0\nstatic const struct dce120_hw_seq_reg_offsets reg_offsets[] = {\n{\n\t.crtc = (mmCRTC0_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC1_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC2_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC3_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC4_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC5_CRTC_GSL_CONTROL - mmCRTC0_CRTC_GSL_CONTROL),\n}\n};\n\n#define HW_REG_CRTC(reg, id)\\\n\t(reg + reg_offsets[id].crtc)\n\n#define CNTL_ID(controller_id)\\\n\tcontroller_id\n \nstatic void dce120_init_pte(struct dc_context *ctx, uint8_t controller_id)\n{\n\tuint32_t addr;\n\tuint32_t value = 0;\n\tuint32_t chunk_int = 0;\n\tuint32_t chunk_mul = 0;\n \n\n\taddr = mmDVMM_PTE_REQ;\n\tvalue = dm_read_reg(ctx, addr);\n\n\tchunk_int = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\tchunk_mul = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\tif (chunk_int != 0x4 || chunk_mul != 0x4) {\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t255,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tMAX_PTEREQ_TO_ISSUE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n}\n#endif\n\nstatic bool dce120_enable_display_power_gating(\n\tstruct dc *dc,\n\tuint8_t controller_id,\n\tstruct dc_bios *dcb,\n\tenum pipe_gating_control power_gating)\n{\n\t \n#if 0\n\tenum bp_result bp_result = BP_RESULT_OK;\n\tenum bp_pipe_control_action cntl;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tif (power_gating == PIPE_GATING_CONTROL_INIT)\n\t\tcntl = ASIC_PIPE_INIT;\n\telse if (power_gating == PIPE_GATING_CONTROL_ENABLE)\n\t\tcntl = ASIC_PIPE_ENABLE;\n\telse\n\t\tcntl = ASIC_PIPE_DISABLE;\n\n\tif (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0) {\n\n\t\tbp_result = dcb->funcs->enable_disp_power_gating(\n\t\t\t\t\t\tdcb, controller_id + 1, cntl);\n\n\t\t \n\t\tdm_write_reg(ctx,\n\t\t\tHW_REG_CRTC(mmCRTC0_CRTC_MASTER_UPDATE_MODE, controller_id),\n\t\t\t0);\n\t}\n\n\tif (power_gating != PIPE_GATING_CONTROL_ENABLE)\n\t\tdce120_init_pte(ctx, controller_id);\n\n\tif (bp_result == BP_RESULT_OK)\n\t\treturn true;\n\telse\n\t\treturn false;\n#endif\n\treturn false;\n}\n\nstatic void dce120_update_dchub(\n\tstruct dce_hwseq *hws,\n\tstruct dchub_init_data *dh_data)\n{\n\t \n\tswitch (dh_data->fb_mode) {\n\tcase FRAME_BUFFER_MODE_ZFB_ONLY:\n\t\t \n\t\tREG_UPDATE_2(DCHUB_FB_LOCATION,\n\t\t\t\tFB_TOP, 0,\n\t\t\t\tFB_BASE, 0x0FFFF);\n\n\t\tREG_UPDATE(DCHUB_AGP_BASE,\n\t\t\t\tAGP_BASE, dh_data->zfb_phys_addr_base >> 22);\n\n\t\tREG_UPDATE(DCHUB_AGP_BOT,\n\t\t\t\tAGP_BOT, dh_data->zfb_mc_base_addr >> 22);\n\n\t\tREG_UPDATE(DCHUB_AGP_TOP,\n\t\t\t\tAGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);\n\t\tbreak;\n\tcase FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:\n\t\t \n\t\tREG_UPDATE(DCHUB_AGP_BASE,\n\t\t\t\tAGP_BASE, dh_data->zfb_phys_addr_base >> 22);\n\n\t\tREG_UPDATE(DCHUB_AGP_BOT,\n\t\t\t\tAGP_BOT, dh_data->zfb_mc_base_addr >> 22);\n\n\t\tREG_UPDATE(DCHUB_AGP_TOP,\n\t\t\t\tAGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);\n\t\tbreak;\n\tcase FRAME_BUFFER_MODE_LOCAL_ONLY:\n\t\t \n\t\tREG_UPDATE(DCHUB_AGP_BASE,\n\t\t\t\tAGP_BASE, 0);\n\n\t\tREG_UPDATE(DCHUB_AGP_BOT,\n\t\t\t\tAGP_BOT, 0x03FFFF);\n\n\t\tREG_UPDATE(DCHUB_AGP_TOP,\n\t\t\t\tAGP_TOP, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdh_data->dchub_initialzied = true;\n\tdh_data->dchub_info_valid = false;\n}\n\n \nbool dce121_xgmi_enabled(struct dce_hwseq *hws)\n{\n\tuint32_t pf_max_region;\n\n\tREG_GET(MC_VM_XGMI_LFB_CNTL, PF_MAX_REGION, &pf_max_region);\n\t \n\treturn !!pf_max_region;\n}\n\nvoid dce120_hw_sequencer_construct(struct dc *dc)\n{\n\t \n\tdce110_hw_sequencer_construct(dc);\n\tdc->hwseq->funcs.enable_display_power_gating = dce120_enable_display_power_gating;\n\tdc->hwss.update_dchub = dce120_update_dchub;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}