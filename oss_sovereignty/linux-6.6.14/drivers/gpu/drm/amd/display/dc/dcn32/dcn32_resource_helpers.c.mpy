{
  "module_name": "dcn32_resource_helpers.c",
  "hash_id": "ada4781757161f6337e0d2adc19c78be809243a856c6ce85b7ef8f587232b4b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_resource_helpers.c",
  "human_readable_source": " \n\n\n#include \"dcn32_resource.h\"\n#include \"dcn20/dcn20_resource.h\"\n#include \"dml/dcn32/display_mode_vba_util_32.h\"\n#include \"dml/dcn32/dcn32_fpu.h\"\n\nstatic bool is_dual_plane(enum surface_pixel_format format)\n{\n\treturn format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN || format == SURFACE_PIXEL_FORMAT_GRPH_RGBE_ALPHA;\n}\n\n\nuint32_t dcn32_helper_mall_bytes_to_ways(\n\t\tstruct dc *dc,\n\t\tuint32_t total_size_in_mall_bytes)\n{\n\tuint32_t cache_lines_used, lines_per_way, total_cache_lines, num_ways;\n\n\t \n\tcache_lines_used = total_size_in_mall_bytes / dc->caps.cache_line_size + 2;\n\n\ttotal_cache_lines = dc->caps.max_cab_allocation_bytes / dc->caps.cache_line_size;\n\tlines_per_way = total_cache_lines / dc->caps.cache_num_ways;\n\tnum_ways = cache_lines_used / lines_per_way;\n\tif (cache_lines_used % lines_per_way > 0)\n\t\tnum_ways++;\n\n\treturn num_ways;\n}\n\nuint32_t dcn32_helper_calculate_mall_bytes_for_cursor(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tbool ignore_cursor_buf)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tuint32_t cursor_size = hubp->curs_attr.pitch * hubp->curs_attr.height;\n\tuint32_t cursor_mall_size_bytes = 0;\n\n\tswitch (pipe_ctx->stream->cursor_attributes.color_format) {\n\tcase CURSOR_MODE_MONO:\n\t\tcursor_size /= 2;\n\t\tbreak;\n\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\tcursor_size *= 4;\n\t\tbreak;\n\n\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\tcursor_size *= 8;\n\t\tbreak;\n\t}\n\n\t \n\tif (pipe_ctx->stream->cursor_position.enable && (ignore_cursor_buf ||\n\t\t\tcursor_size > 16384)) {\n\t\t \n\t\tcursor_mall_size_bytes = ((cursor_size + DCN3_2_MALL_MBLK_SIZE_BYTES - 1) /\n\t\t\t\tDCN3_2_MALL_MBLK_SIZE_BYTES + 1) * DCN3_2_MALL_MBLK_SIZE_BYTES;\n\t}\n\n\treturn cursor_mall_size_bytes;\n}\n\n \nuint32_t dcn32_helper_calculate_num_ways_for_subvp(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (context->bw_ctx.bw.dcn.mall_subvp_size_bytes > 0) {\n\t\tif (dc->debug.force_subvp_num_ways) {\n\t\t\treturn dc->debug.force_subvp_num_ways;\n\t\t} else {\n\t\t\treturn dcn32_helper_mall_bytes_to_ways(dc, context->bw_ctx.bw.dcn.mall_subvp_size_bytes);\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nvoid dcn32_merge_pipes_for_subvp(struct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tuint32_t i;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t\n\n\t\t \n\t\tif (pipe->prev_odm_pipe) {\n\t\t\t \n\t\t\tpipe->prev_odm_pipe->next_odm_pipe = pipe->next_odm_pipe;\n\t\t\tif (pipe->next_odm_pipe)\n\t\t\t\tpipe->next_odm_pipe->prev_odm_pipe = pipe->prev_odm_pipe;\n\n\t\t\tpipe->bottom_pipe = NULL;\n\t\t\tpipe->next_odm_pipe = NULL;\n\t\t\tpipe->plane_state = NULL;\n\t\t\tpipe->stream = NULL;\n\t\t\tpipe->top_pipe = NULL;\n\t\t\tpipe->prev_odm_pipe = NULL;\n\t\t\tif (pipe->stream_res.dsc)\n\t\t\t\tdcn20_release_dsc(&context->res_ctx, dc->res_pool, &pipe->stream_res.dsc);\n\t\t\tmemset(&pipe->plane_res, 0, sizeof(pipe->plane_res));\n\t\t\tmemset(&pipe->stream_res, 0, sizeof(pipe->stream_res));\n\t\t} else if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state) {\n\t\t\tstruct pipe_ctx *top_pipe = pipe->top_pipe;\n\t\t\tstruct pipe_ctx *bottom_pipe = pipe->bottom_pipe;\n\n\t\t\ttop_pipe->bottom_pipe = bottom_pipe;\n\t\t\tif (bottom_pipe)\n\t\t\t\tbottom_pipe->top_pipe = top_pipe;\n\n\t\t\tpipe->top_pipe = NULL;\n\t\t\tpipe->bottom_pipe = NULL;\n\t\t\tpipe->plane_state = NULL;\n\t\t\tpipe->stream = NULL;\n\t\t\tmemset(&pipe->plane_res, 0, sizeof(pipe->plane_res));\n\t\t\tmemset(&pipe->stream_res, 0, sizeof(pipe->stream_res));\n\t\t}\n\t}\n}\n\nbool dcn32_all_pipes_have_stream_and_plane(struct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (!pipe->plane_state)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool dcn32_subvp_in_use(struct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type != SUBVP_NONE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool dcn32_mpo_in_use(struct dc_state *context)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nbool dcn32_any_surfaces_rotated(struct dc *dc, struct dc_state *context)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe->plane_state && pipe->plane_state->rotation != ROTATION_ANGLE_0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool dcn32_is_center_timing(struct pipe_ctx *pipe)\n{\n\tbool is_center_timing = false;\n\n\tif (pipe->stream) {\n\t\tif (pipe->stream->timing.v_addressable != pipe->stream->dst.height ||\n\t\t\t\tpipe->stream->timing.v_addressable != pipe->stream->src.height) {\n\t\t\tis_center_timing = true;\n\t\t}\n\t}\n\n\tif (pipe->plane_state) {\n\t\tif (pipe->stream->timing.v_addressable != pipe->plane_state->dst_rect.height &&\n\t\t\t\tpipe->stream->timing.v_addressable != pipe->plane_state->src_rect.height) {\n\t\t\tis_center_timing = true;\n\t\t}\n\t}\n\n\treturn is_center_timing;\n}\n\nbool dcn32_is_psr_capable(struct pipe_ctx *pipe)\n{\n\tbool psr_capable = false;\n\n\tif (pipe->stream && pipe->stream->link->psr_settings.psr_version != DC_PSR_VERSION_UNSUPPORTED) {\n\t\tpsr_capable = true;\n\t}\n\treturn psr_capable;\n}\n\n \nvoid dcn32_determine_det_override(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes)\n{\n\tuint32_t i, j, k;\n\tuint8_t pipe_plane_count, stream_segments, plane_segments, pipe_segments[MAX_PIPES] = {0};\n\tuint8_t pipe_counted[MAX_PIPES] = {0};\n\tuint8_t pipe_cnt = 0;\n\tstruct dc_plane_state *current_plane = NULL;\n\tuint8_t stream_count = 0;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\t \n\t\tif (context->streams[i]->mall_stream_config.type != SUBVP_PHANTOM)\n\t\t\tstream_count++;\n\t}\n\n\tif (stream_count > 0) {\n\t\tstream_segments = 18 / stream_count;\n\t\tfor (i = 0; i < context->stream_count; i++) {\n\t\t\tif (context->streams[i]->mall_stream_config.type == SUBVP_PHANTOM)\n\t\t\t\tcontinue;\n\n\t\t\tif (context->stream_status[i].plane_count > 0)\n\t\t\t\tplane_segments = stream_segments / context->stream_status[i].plane_count;\n\t\t\telse\n\t\t\t\tplane_segments = stream_segments;\n\t\t\tfor (j = 0; j < dc->res_pool->pipe_count; j++) {\n\t\t\t\tpipe_plane_count = 0;\n\t\t\t\tif (context->res_ctx.pipe_ctx[j].stream == context->streams[i] &&\n\t\t\t\t\t\tpipe_counted[j] != 1) {\n\t\t\t\t\t \n\t\t\t\t\tpipe_plane_count++;\n\t\t\t\t\tpipe_counted[j] = 1;\n\t\t\t\t\tcurrent_plane = context->res_ctx.pipe_ctx[j].plane_state;\n\t\t\t\t\tfor (k = 0; k < dc->res_pool->pipe_count; k++) {\n\t\t\t\t\t\tif (k != j && context->res_ctx.pipe_ctx[k].stream == context->streams[i] &&\n\t\t\t\t\t\t\t\tcontext->res_ctx.pipe_ctx[k].plane_state == current_plane) {\n\t\t\t\t\t\t\tpipe_plane_count++;\n\t\t\t\t\t\t\tpipe_counted[k] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpipe_segments[j] = plane_segments / pipe_plane_count;\n\t\t\t\t\tfor (k = 0; k < dc->res_pool->pipe_count; k++) {\n\t\t\t\t\t\tif (k != j && context->res_ctx.pipe_ctx[k].stream == context->streams[i] &&\n\t\t\t\t\t\t\t\tcontext->res_ctx.pipe_ctx[k].plane_state == current_plane) {\n\t\t\t\t\t\t\tpipe_segments[k] = plane_segments / pipe_plane_count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\t\tcontinue;\n\t\t\tpipes[pipe_cnt].pipe.src.det_size_override = pipe_segments[i] * DCN3_2_DET_SEG_SIZE;\n\t\t\tpipe_cnt++;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\t\tpipes[i].pipe.src.det_size_override = 4 * DCN3_2_DET_SEG_SIZE; \n\t}\n}\n\nvoid dcn32_set_det_allocations(struct dc *dc, struct dc_state *context,\n\tdisplay_e2e_pipe_params_st *pipes)\n{\n\tint i, pipe_cnt;\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tstruct pipe_ctx *pipe;\n\tbool disable_unbounded_requesting = dc->debug.disable_z9_mpc || dc->debug.disable_unbounded_requesting;\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipe = &res_ctx->pipe_ctx[i];\n\t\tpipe_cnt++;\n\t}\n\n\t \n\tif (pipe_cnt == 1) {\n\t\tpipes[0].pipe.src.det_size_override = DCN3_2_MAX_DET_SIZE;\n\t\tif (pipe->plane_state && !disable_unbounded_requesting && pipe->plane_state->tiling_info.gfx9.swizzle != DC_SW_LINEAR) {\n\t\t\tif (!is_dual_plane(pipe->plane_state->format)) {\n\t\t\t\tpipes[0].pipe.src.det_size_override = DCN3_2_DEFAULT_DET_SIZE;\n\t\t\t\tpipes[0].pipe.src.unbounded_req_mode = true;\n\t\t\t\tif (pipe->plane_state->src_rect.width >= 5120 &&\n\t\t\t\t\tpipe->plane_state->src_rect.height >= 2880)\n\t\t\t\t\tpipes[0].pipe.src.det_size_override = 320;  \n\t\t\t}\n\t\t}\n\t} else\n\t\tdcn32_determine_det_override(dc, context, pipes);\n}\n\n \nvoid dcn32_save_mall_state(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct mall_temp_config *temp_config)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream)\n\t\t\ttemp_config->mall_stream_config[i] = pipe->stream->mall_stream_config;\n\n\t\tif (pipe->plane_state)\n\t\t\ttemp_config->is_phantom_plane[i] = pipe->plane_state->is_phantom;\n\t}\n}\n\n \nvoid dcn32_restore_mall_state(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct mall_temp_config *temp_config)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream)\n\t\t\tpipe->stream->mall_stream_config = temp_config->mall_stream_config[i];\n\n\t\tif (pipe->plane_state)\n\t\t\tpipe->plane_state->is_phantom = temp_config->is_phantom_plane[i];\n\t}\n}\n\n#define MAX_STRETCHED_V_BLANK 1000 \n \n#define V_SCALE (10000 / MAX_STRETCHED_V_BLANK)\n\nstatic int get_frame_rate_at_max_stretch_100hz(\n\t\tstruct dc_stream_state *fpo_candidate_stream,\n\t\tuint32_t fpo_vactive_margin_us)\n{\n\tstruct dc_crtc_timing *timing = NULL;\n\tuint32_t sec_per_100_lines;\n\tuint32_t max_v_blank;\n\tuint32_t curr_v_blank;\n\tuint32_t v_stretch_max;\n\tuint32_t stretched_frame_pix_cnt;\n\tuint32_t scaled_stretched_frame_pix_cnt;\n\tuint32_t scaled_refresh_rate;\n\tuint32_t v_scale;\n\n\tif (fpo_candidate_stream == NULL)\n\t\treturn 0;\n\n\t \n\ttiming = &fpo_candidate_stream->timing;\n\tif (timing == NULL)\n\t\treturn 0;\n\n\tv_scale = 10000 / (MAX_STRETCHED_V_BLANK + fpo_vactive_margin_us);\n\n\tsec_per_100_lines = timing->pix_clk_100hz / timing->h_total + 1;\n\tmax_v_blank = sec_per_100_lines / v_scale + 1;\n\tcurr_v_blank = timing->v_total - timing->v_addressable;\n\tv_stretch_max = (max_v_blank > curr_v_blank) ? (max_v_blank - curr_v_blank) : (0);\n\tstretched_frame_pix_cnt = (v_stretch_max + timing->v_total) * timing->h_total;\n\tscaled_stretched_frame_pix_cnt = stretched_frame_pix_cnt / 10000;\n\tscaled_refresh_rate = (timing->pix_clk_100hz) / scaled_stretched_frame_pix_cnt + 1;\n\n\treturn scaled_refresh_rate;\n\n}\n\nstatic bool is_refresh_rate_support_mclk_switch_using_fw_based_vblank_stretch(\n\t\tstruct dc_stream_state *fpo_candidate_stream, uint32_t fpo_vactive_margin_us)\n{\n\tint refresh_rate_max_stretch_100hz;\n\tint min_refresh_100hz;\n\n\tif (fpo_candidate_stream == NULL)\n\t\treturn false;\n\n\trefresh_rate_max_stretch_100hz = get_frame_rate_at_max_stretch_100hz(fpo_candidate_stream, fpo_vactive_margin_us);\n\tmin_refresh_100hz = fpo_candidate_stream->timing.min_refresh_in_uhz / 10000;\n\n\tif (refresh_rate_max_stretch_100hz < min_refresh_100hz)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int get_refresh_rate(struct dc_stream_state *fpo_candidate_stream)\n{\n\tint refresh_rate = 0;\n\tint h_v_total = 0;\n\tstruct dc_crtc_timing *timing = NULL;\n\n\tif (fpo_candidate_stream == NULL)\n\t\treturn 0;\n\n\t \n\ttiming = &fpo_candidate_stream->timing;\n\tif (timing == NULL)\n\t\treturn 0;\n\n\th_v_total = timing->h_total * timing->v_total;\n\tif (h_v_total == 0)\n\t\treturn 0;\n\n\trefresh_rate = ((timing->pix_clk_100hz * 100) / (h_v_total)) + 1;\n\treturn refresh_rate;\n}\n\n \nstruct dc_stream_state *dcn32_can_support_mclk_switch_using_fw_based_vblank_stretch(struct dc *dc, const struct dc_state *context)\n{\n\tint refresh_rate = 0;\n\tconst int minimum_refreshrate_supported = 120;\n\tstruct dc_stream_state *fpo_candidate_stream = NULL;\n\tbool is_fpo_vactive = false;\n\tuint32_t fpo_vactive_margin_us = 0;\n\n\tif (context == NULL)\n\t\treturn NULL;\n\n\tif (dc->debug.disable_fams)\n\t\treturn NULL;\n\n\tif (!dc->caps.dmub_caps.mclk_sw)\n\t\treturn NULL;\n\n\tif (context->bw_ctx.bw.dcn.clk.fw_based_mclk_switching_shut_down)\n\t\treturn NULL;\n\n\t \n\tif (context->stream_count > 2)\n\t\treturn NULL;\n\telse if (context->stream_count == 2) {\n\t\tDC_FP_START();\n\t\tdcn32_assign_fpo_vactive_candidate(dc, context, &fpo_candidate_stream);\n\t\tDC_FP_END();\n\n\t\tDC_FP_START();\n\t\tis_fpo_vactive = dcn32_find_vactive_pipe(dc, context, dc->debug.fpo_vactive_min_active_margin_us);\n\t\tDC_FP_END();\n\t\tif (!is_fpo_vactive || dc->debug.disable_fpo_vactive)\n\t\t\treturn NULL;\n\t} else\n\t\tfpo_candidate_stream = context->streams[0];\n\n\tif (!fpo_candidate_stream)\n\t\treturn NULL;\n\n\tif (fpo_candidate_stream->sink->edid_caps.panel_patch.disable_fams)\n\t\treturn NULL;\n\n\trefresh_rate = get_refresh_rate(fpo_candidate_stream);\n\tif (refresh_rate < minimum_refreshrate_supported)\n\t\treturn NULL;\n\n\tfpo_vactive_margin_us = is_fpo_vactive ? dc->debug.fpo_vactive_margin_us : 0; \n\tif (!is_refresh_rate_support_mclk_switch_using_fw_based_vblank_stretch(fpo_candidate_stream, fpo_vactive_margin_us))\n\t\treturn NULL;\n\n\tif (!fpo_candidate_stream->allow_freesync)\n\t\treturn NULL;\n\n\tif (fpo_candidate_stream->vrr_active_variable && dc->debug.disable_fams_gaming)\n\t\treturn NULL;\n\n\treturn fpo_candidate_stream;\n}\n\nbool dcn32_check_native_scaling_for_res(struct pipe_ctx *pipe, unsigned int width, unsigned int height)\n{\n\tbool is_native_scaling = false;\n\n\tif (pipe->stream->timing.h_addressable == width &&\n\t\t\tpipe->stream->timing.v_addressable == height &&\n\t\t\tpipe->plane_state->src_rect.width == width &&\n\t\t\tpipe->plane_state->src_rect.height == height &&\n\t\t\tpipe->plane_state->dst_rect.width == width &&\n\t\t\tpipe->plane_state->dst_rect.height == height)\n\t\tis_native_scaling = true;\n\n\treturn is_native_scaling;\n}\n\n \nbool dcn32_subvp_drr_admissable(struct dc *dc, struct dc_state *context)\n{\n\tbool result = false;\n\tuint32_t i;\n\tuint8_t subvp_count = 0;\n\tuint8_t non_subvp_pipes = 0;\n\tbool drr_pipe_found = false;\n\tbool drr_psr_capable = false;\n\tuint64_t refresh_rate = 0;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(pipe, OPP_HEAD) &&\n\t\t\t\tresource_is_pipe_type(pipe, DPP_PIPE)) {\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t\tsubvp_count++;\n\n\t\t\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - (uint64_t)1);\n\t\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.v_total);\n\t\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.h_total);\n\t\t\t}\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\t\tnon_subvp_pipes++;\n\t\t\t\tdrr_psr_capable = (drr_psr_capable || dcn32_is_psr_capable(pipe));\n\t\t\t\tif (pipe->stream->ignore_msa_timing_param &&\n\t\t\t\t\t\t(pipe->stream->allow_freesync || pipe->stream->vrr_active_variable)) {\n\t\t\t\t\tdrr_pipe_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (subvp_count == 1 && non_subvp_pipes == 1 && drr_pipe_found && !drr_psr_capable &&\n\t\t((uint32_t)refresh_rate < 120))\n\t\tresult = true;\n\n\treturn result;\n}\n\n \nbool dcn32_subvp_vblank_admissable(struct dc *dc, struct dc_state *context, int vlevel)\n{\n\tbool result = false;\n\tuint32_t i;\n\tuint8_t subvp_count = 0;\n\tuint8_t non_subvp_pipes = 0;\n\tbool drr_pipe_found = false;\n\tstruct vba_vars_st *vba = &context->bw_ctx.dml.vba;\n\tbool vblank_psr_capable = false;\n\tuint64_t refresh_rate = 0;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(pipe, OPP_HEAD) &&\n\t\t\t\tresource_is_pipe_type(pipe, DPP_PIPE)) {\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t\tsubvp_count++;\n\n\t\t\t\trefresh_rate = (pipe->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\t\tpipe->stream->timing.v_total * pipe->stream->timing.h_total - (uint64_t)1);\n\t\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.v_total);\n\t\t\t\trefresh_rate = div_u64(refresh_rate, pipe->stream->timing.h_total);\n\t\t\t}\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_NONE) {\n\t\t\t\tnon_subvp_pipes++;\n\t\t\t\tvblank_psr_capable = (vblank_psr_capable || dcn32_is_psr_capable(pipe));\n\t\t\t\tif (pipe->stream->ignore_msa_timing_param &&\n\t\t\t\t\t\t(pipe->stream->allow_freesync || pipe->stream->vrr_active_variable)) {\n\t\t\t\t\tdrr_pipe_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (subvp_count == 1 && non_subvp_pipes == 1 && !drr_pipe_found && !vblank_psr_capable &&\n\t\t((uint32_t)refresh_rate < 120) &&\n\t\tvba->DRAMClockChangeSupport[vlevel][vba->maxMpcComb] == dm_dram_clock_change_vblank_w_mall_sub_vp)\n\t\tresult = true;\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}