{
  "module_name": "dcn30_dwb_cm.c",
  "hash_id": "31138c37c3164b4a67aadd35865f99a78c33340ad528bd510e832cf7936ea37e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dwb_cm.c",
  "human_readable_source": " \n\n#include \"reg_helper.h\"\n#include \"fixed31_32.h\"\n#include \"resource.h\"\n#include \"basics/conversion.h\"\n#include \"dwb.h\"\n#include \"dcn30_dwb.h\"\n#include \"dcn30_cm_common.h\"\n#include \"dcn10/dcn10_cm_common.h\"\n\n\n#define REG(reg)\\\n\tdwbc30->dwbc_regs->reg\n\n#define CTX \\\n\tdwbc30->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdwbc30->dwbc_shift->field_name, dwbc30->dwbc_mask->field_name\n\n#define TO_DCN30_DWBC(dwbc_base) \\\n\tcontainer_of(dwbc_base, struct dcn30_dwbc, base)\n\nstatic void dwb3_get_reg_field_ogam(struct dcn30_dwbc *dwbc30,\n\tstruct dcn3_xfer_func_reg *reg)\n{\n\treg->shifts.field_region_start_base = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_START_BASE_B;\n\treg->masks.field_region_start_base = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_START_BASE_B;\n\treg->shifts.field_offset = dwbc30->dwbc_shift->DWB_OGAM_RAMA_OFFSET_B;\n\treg->masks.field_offset = dwbc30->dwbc_mask->DWB_OGAM_RAMA_OFFSET_B;\n\n\treg->shifts.exp_region0_lut_offset = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_END_B;\n\treg->masks.field_region_end = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->masks.field_region_linear_slope = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_START_SLOPE_B;\n\treg->shifts.exp_region_start = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dwbc30->dwbc_shift->DWB_OGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dwbc30->dwbc_mask->DWB_OGAM_RAMA_EXP_REGION_START_SEGMENT_B;\n}\n\n \nstatic void dwb3_program_ogam_luta_settings(\n\tstruct dcn30_dwbc *dwbc30,\n\tconst struct pwl_params *params)\n{\n\tstruct dcn3_xfer_func_reg gam_regs;\n\n\tdwb3_get_reg_field_ogam(dwbc30, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(DWB_OGAM_RAMA_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(DWB_OGAM_RAMA_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(DWB_OGAM_RAMA_START_CNTL_R);\n\tgam_regs.start_base_cntl_b = REG(DWB_OGAM_RAMA_START_BASE_CNTL_B);\n\tgam_regs.start_base_cntl_g = REG(DWB_OGAM_RAMA_START_BASE_CNTL_G);\n\tgam_regs.start_base_cntl_r = REG(DWB_OGAM_RAMA_START_BASE_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(DWB_OGAM_RAMA_START_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(DWB_OGAM_RAMA_START_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(DWB_OGAM_RAMA_START_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(DWB_OGAM_RAMA_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(DWB_OGAM_RAMA_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(DWB_OGAM_RAMA_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(DWB_OGAM_RAMA_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(DWB_OGAM_RAMA_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(DWB_OGAM_RAMA_END_CNTL2_R);\n\tgam_regs.offset_b = REG(DWB_OGAM_RAMA_OFFSET_B);\n\tgam_regs.offset_g = REG(DWB_OGAM_RAMA_OFFSET_G);\n\tgam_regs.offset_r = REG(DWB_OGAM_RAMA_OFFSET_R);\n\tgam_regs.region_start = REG(DWB_OGAM_RAMA_REGION_0_1);\n\tgam_regs.region_end = REG(DWB_OGAM_RAMA_REGION_32_33);\n\t \n\tcm_helper_program_gamcor_xfer_func(dwbc30->base.ctx, params, &gam_regs);\n}\n\n \nstatic void dwb3_program_ogam_lutb_settings(\n\tstruct dcn30_dwbc *dwbc30,\n\tconst struct pwl_params *params)\n{\n\tstruct dcn3_xfer_func_reg gam_regs;\n\n\tdwb3_get_reg_field_ogam(dwbc30, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(DWB_OGAM_RAMB_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(DWB_OGAM_RAMB_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(DWB_OGAM_RAMB_START_CNTL_R);\n\tgam_regs.start_base_cntl_b = REG(DWB_OGAM_RAMB_START_BASE_CNTL_B);\n\tgam_regs.start_base_cntl_g = REG(DWB_OGAM_RAMB_START_BASE_CNTL_G);\n\tgam_regs.start_base_cntl_r = REG(DWB_OGAM_RAMB_START_BASE_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(DWB_OGAM_RAMB_START_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(DWB_OGAM_RAMB_START_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(DWB_OGAM_RAMB_START_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(DWB_OGAM_RAMB_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(DWB_OGAM_RAMB_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(DWB_OGAM_RAMB_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(DWB_OGAM_RAMB_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(DWB_OGAM_RAMB_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(DWB_OGAM_RAMB_END_CNTL2_R);\n\tgam_regs.offset_b = REG(DWB_OGAM_RAMB_OFFSET_B);\n\tgam_regs.offset_g = REG(DWB_OGAM_RAMB_OFFSET_G);\n\tgam_regs.offset_r = REG(DWB_OGAM_RAMB_OFFSET_R);\n\tgam_regs.region_start = REG(DWB_OGAM_RAMB_REGION_0_1);\n\tgam_regs.region_end = REG(DWB_OGAM_RAMB_REGION_32_33);\n\n\tcm_helper_program_gamcor_xfer_func(dwbc30->base.ctx, params, &gam_regs);\n}\n\nstatic enum dc_lut_mode dwb3_get_ogam_current(\n\tstruct dcn30_dwbc *dwbc30)\n{\n\tenum dc_lut_mode mode;\n\tuint32_t state_mode;\n\tuint32_t ram_select;\n\n\tREG_GET_2(DWB_OGAM_CONTROL,\n\t\tDWB_OGAM_MODE_CURRENT, &state_mode,\n\t\tDWB_OGAM_SELECT_CURRENT, &ram_select);\n\n\tif (state_mode == 0) {\n\t\tmode = LUT_BYPASS;\n\t} else if (state_mode == 2) {\n\t\tif (ram_select == 0)\n\t\t\tmode = LUT_RAM_A;\n\t\telse if (ram_select == 1)\n\t\t\tmode = LUT_RAM_B;\n\t\telse\n\t\t\tmode = LUT_BYPASS;\n\t} else {\n\t\t\n\t\tmode = LUT_BYPASS;\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn mode;\n\t}\n\treturn mode;\n}\n\nstatic void dwb3_configure_ogam_lut(\n\tstruct dcn30_dwbc *dwbc30,\n\tbool is_ram_a)\n{\n\tREG_UPDATE_2(DWB_OGAM_LUT_CONTROL,\n\t\tDWB_OGAM_LUT_WRITE_COLOR_MASK, 7,\n\t\tDWB_OGAM_LUT_HOST_SEL, (is_ram_a == true) ? 0 : 1);\n\n\tREG_SET(DWB_OGAM_LUT_INDEX, 0, DWB_OGAM_LUT_INDEX, 0);\n}\n\nstatic void dwb3_program_ogam_pwl(struct dcn30_dwbc *dwbc30,\n\tconst struct pwl_result_data *rgb,\n\tuint32_t num)\n{\n\tuint32_t i;\n\n\tuint32_t last_base_value_red = rgb[num-1].red_reg + rgb[num-1].delta_red_reg;\n\tuint32_t last_base_value_green = rgb[num-1].green_reg + rgb[num-1].delta_green_reg;\n\tuint32_t last_base_value_blue = rgb[num-1].blue_reg + rgb[num-1].delta_blue_reg;\n\n\tif (is_rgb_equal(rgb,  num)) {\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, rgb[i].red_reg);\n\n\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, last_base_value_red);\n\n\t} else {\n\n\t\tREG_UPDATE(DWB_OGAM_LUT_CONTROL,\n\t\t\t\tDWB_OGAM_LUT_WRITE_COLOR_MASK, 4);\n\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, rgb[i].red_reg);\n\n\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, last_base_value_red);\n\n\t\tREG_SET(DWB_OGAM_LUT_INDEX, 0, DWB_OGAM_LUT_INDEX, 0);\n\n\t\tREG_UPDATE(DWB_OGAM_LUT_CONTROL,\n\t\t\t\tDWB_OGAM_LUT_WRITE_COLOR_MASK, 2);\n\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, rgb[i].green_reg);\n\n\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, last_base_value_green);\n\n\t\tREG_SET(DWB_OGAM_LUT_INDEX, 0, DWB_OGAM_LUT_INDEX, 0);\n\n\t\tREG_UPDATE(DWB_OGAM_LUT_CONTROL,\n\t\t\t\tDWB_OGAM_LUT_WRITE_COLOR_MASK, 1);\n\n\t\tfor (i = 0 ; i < num; i++)\n\t\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(DWB_OGAM_LUT_DATA, 0, DWB_OGAM_LUT_DATA, last_base_value_blue);\n\t}\n}\n\nstatic bool dwb3_program_ogam_lut(\n\tstruct dcn30_dwbc *dwbc30,\n\tconst struct pwl_params *params)\n{\n\tenum dc_lut_mode current_mode;\n\tenum dc_lut_mode next_mode;\n\n\tif (params == NULL) {\n\t\tREG_SET(DWB_OGAM_CONTROL, 0, DWB_OGAM_MODE, 0);\n\t\treturn false;\n\t}\n\n\tREG_SET(DWB_OGAM_CONTROL, 0, DWB_OGAM_MODE, 2);\n\n\tcurrent_mode = dwb3_get_ogam_current(dwbc30);\n\tif (current_mode == LUT_BYPASS || current_mode == LUT_RAM_A)\n\t\tnext_mode = LUT_RAM_B;\n\telse\n\t\tnext_mode = LUT_RAM_A;\n\n\tdwb3_configure_ogam_lut(dwbc30, next_mode == LUT_RAM_A);\n\n\tif (next_mode == LUT_RAM_A)\n\t\tdwb3_program_ogam_luta_settings(dwbc30, params);\n\telse\n\t\tdwb3_program_ogam_lutb_settings(dwbc30, params);\n\n\tdwb3_program_ogam_pwl(\n\t\tdwbc30, params->rgb_resulted, params->hw_points_num);\n\n\tREG_UPDATE(DWB_OGAM_CONTROL, DWB_OGAM_SELECT, next_mode == LUT_RAM_A ? 0 : 1);\n\n\treturn true;\n}\n\nbool dwb3_ogam_set_input_transfer_func(\n\tstruct dwbc *dwbc,\n\tconst struct dc_transfer_func *in_transfer_func_dwb_ogam)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\tbool result = false;\n\tstruct pwl_params *dwb_ogam_lut = NULL;\n\n\tif (in_transfer_func_dwb_ogam == NULL)\n\t\treturn result;\n\n\tdwb_ogam_lut = kzalloc(sizeof(*dwb_ogam_lut), GFP_KERNEL);\n\n\tif (dwb_ogam_lut) {\n\t\tcm_helper_translate_curve_to_hw_format(dwbc->ctx,\n\t\t\tin_transfer_func_dwb_ogam,\n\t\t\tdwb_ogam_lut, false);\n\n\t\tresult = dwb3_program_ogam_lut(\n\t\t\tdwbc30,\n\t\t\tdwb_ogam_lut);\n\t\tkfree(dwb_ogam_lut);\n\t\tdwb_ogam_lut = NULL;\n\t}\n\n\treturn result;\n}\n\nstatic void dwb3_program_gamut_remap(\n\t\tstruct dwbc *dwbc,\n\t\tconst uint16_t *regval,\n\t\tenum cm_gamut_coef_format coef_format,\n\t\tenum cm_gamut_remap_select select)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\tstruct color_matrices_reg gam_regs;\n\n\tif (regval == NULL || select == CM_GAMUT_REMAP_MODE_BYPASS) {\n\t\tREG_SET(DWB_GAMUT_REMAP_MODE, 0,\n\t\t\t\tDWB_GAMUT_REMAP_MODE, 0);\n\t\treturn;\n\t}\n\n\tREG_UPDATE(DWB_GAMUT_REMAP_COEF_FORMAT, DWB_GAMUT_REMAP_COEF_FORMAT, coef_format);\n\n\tgam_regs.shifts.csc_c11 = dwbc30->dwbc_shift->DWB_GAMUT_REMAPA_C11;\n\tgam_regs.masks.csc_c11  = dwbc30->dwbc_mask->DWB_GAMUT_REMAPA_C11;\n\tgam_regs.shifts.csc_c12 = dwbc30->dwbc_shift->DWB_GAMUT_REMAPA_C12;\n\tgam_regs.masks.csc_c12 = dwbc30->dwbc_mask->DWB_GAMUT_REMAPA_C12;\n\n\tswitch (select) {\n\tcase CM_GAMUT_REMAP_MODE_RAMA_COEFF:\n\t\tgam_regs.csc_c11_c12 = REG(DWB_GAMUT_REMAPA_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(DWB_GAMUT_REMAPA_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdwbc30->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\t\tbreak;\n\tcase CM_GAMUT_REMAP_MODE_RAMB_COEFF:\n\t\tgam_regs.csc_c11_c12 = REG(DWB_GAMUT_REMAPB_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(DWB_GAMUT_REMAPB_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdwbc30->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\t\tbreak;\n\tcase CM_GAMUT_REMAP_MODE_RESERVED:\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREG_SET(DWB_GAMUT_REMAP_MODE, 0,\n\t\t\tDWB_GAMUT_REMAP_MODE, select);\n\n}\n\nvoid dwb3_set_gamut_remap(\n\tstruct dwbc *dwbc,\n\tconst struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\tstruct cm_grph_csc_adjustment adjust = params->csc_params;\n\tint i = 0;\n\n\tif (adjust.gamut_adjust_type != CM_GAMUT_ADJUST_TYPE_SW) {\n\t\t \n\t\tdwb3_program_gamut_remap(dwbc, NULL, adjust.gamut_coef_format, CM_GAMUT_REMAP_MODE_BYPASS);\n\t} else {\n\t\tstruct fixed31_32 arr_matrix[12];\n\t\tuint16_t arr_reg_val[12];\n\t\tunsigned int current_mode;\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tarr_matrix[i] = adjust.temperature_matrix[i];\n\n\t\tconvert_float_matrix(arr_reg_val, arr_matrix, 12);\n\n\t\tREG_GET(DWB_GAMUT_REMAP_MODE, DWB_GAMUT_REMAP_MODE_CURRENT, &current_mode);\n\n\t\tif (current_mode == CM_GAMUT_REMAP_MODE_RAMA_COEFF) {\n\t\t\tdwb3_program_gamut_remap(dwbc, arr_reg_val,\n\t\t\t\t\tadjust.gamut_coef_format, CM_GAMUT_REMAP_MODE_RAMB_COEFF);\n\t\t} else {\n\t\t\tdwb3_program_gamut_remap(dwbc, arr_reg_val,\n\t\t\t\t\tadjust.gamut_coef_format, CM_GAMUT_REMAP_MODE_RAMA_COEFF);\n\t\t}\n\t}\n}\n\nvoid dwb3_program_hdr_mult(\n\tstruct dwbc *dwbc,\n\tconst struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\tREG_UPDATE(DWB_HDR_MULT_COEF, DWB_HDR_MULT_COEF, params->hdr_mult);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}