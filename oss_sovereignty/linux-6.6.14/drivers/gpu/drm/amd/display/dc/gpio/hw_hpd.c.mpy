{
  "module_name": "hw_hpd.c",
  "hash_id": "002eb56a74381c15acdd6d7681878e1afa8aac75592d00eeefd83449c66124cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/gpio/hw_hpd.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"include/gpio_interface.h\"\n#include \"include/gpio_types.h\"\n#include \"hw_gpio.h\"\n#include \"hw_hpd.h\"\n\n#include \"reg_helper.h\"\n#include \"hpd_regs.h\"\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thpd->shifts->field_name, hpd->masks->field_name\n\n#define CTX \\\n\thpd->base.base.ctx\n#define REG(reg)\\\n\t(hpd->regs->reg)\n\nstruct gpio;\n\nstatic void dal_hw_hpd_destruct(\n\tstruct hw_hpd *pin)\n{\n\tdal_hw_gpio_destruct(&pin->base);\n}\n\nstatic void dal_hw_hpd_destroy(\n\tstruct hw_gpio_pin **ptr)\n{\n\tstruct hw_hpd *hpd = HW_HPD_FROM_BASE(*ptr);\n\n\tdal_hw_hpd_destruct(hpd);\n\n\tkfree(hpd);\n\n\t*ptr = NULL;\n}\n\nstatic enum gpio_result get_value(\n\tconst struct hw_gpio_pin *ptr,\n\tuint32_t *value)\n{\n\tstruct hw_hpd *hpd = HW_HPD_FROM_BASE(ptr);\n\tuint32_t hpd_delayed = 0;\n\n\t \n\n\tif (ptr->mode == GPIO_MODE_INTERRUPT) {\n\n\t\tREG_GET(int_status,\n\t\t\tDC_HPD_SENSE_DELAYED, &hpd_delayed);\n\n\t\t*value = hpd_delayed;\n\t\treturn GPIO_RESULT_OK;\n\t}\n\n\t \n\n\treturn dal_hw_gpio_get_value(ptr, value);\n}\n\nstatic enum gpio_result set_config(\n\tstruct hw_gpio_pin *ptr,\n\tconst struct gpio_config_data *config_data)\n{\n\tstruct hw_hpd *hpd = HW_HPD_FROM_BASE(ptr);\n\n\tif (!config_data)\n\t\treturn GPIO_RESULT_INVALID_DATA;\n\n\tREG_UPDATE_2(toggle_filt_cntl,\n\t\tDC_HPD_CONNECT_INT_DELAY, config_data->config.hpd.delay_on_connect / 10,\n\t\tDC_HPD_DISCONNECT_INT_DELAY, config_data->config.hpd.delay_on_disconnect / 10);\n\n\treturn GPIO_RESULT_OK;\n}\n\nstatic const struct hw_gpio_pin_funcs funcs = {\n\t.destroy = dal_hw_hpd_destroy,\n\t.open = dal_hw_gpio_open,\n\t.get_value = get_value,\n\t.set_value = dal_hw_gpio_set_value,\n\t.set_config = set_config,\n\t.change_mode = dal_hw_gpio_change_mode,\n\t.close = dal_hw_gpio_close,\n};\n\nstatic void dal_hw_hpd_construct(\n\tstruct hw_hpd *pin,\n\tenum gpio_id id,\n\tuint32_t en,\n\tstruct dc_context *ctx)\n{\n\tdal_hw_gpio_construct(&pin->base, id, en, ctx);\n\tpin->base.base.funcs = &funcs;\n}\n\nvoid dal_hw_hpd_init(\n\tstruct hw_hpd **hw_hpd,\n\tstruct dc_context *ctx,\n\tenum gpio_id id,\n\tuint32_t en)\n{\n\tif ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {\n\t\tASSERT_CRITICAL(false);\n\t\t*hw_hpd = NULL;\n\t}\n\n\t*hw_hpd = kzalloc(sizeof(struct hw_hpd), GFP_KERNEL);\n\tif (!*hw_hpd) {\n\t\tASSERT_CRITICAL(false);\n\t\treturn;\n\t}\n\n\tdal_hw_hpd_construct(*hw_hpd, id, en, ctx);\n}\n\nstruct hw_gpio_pin *dal_hw_hpd_get_pin(struct gpio *gpio)\n{\n\tstruct hw_hpd *hw_hpd = dal_gpio_get_hpd(gpio);\n\n\treturn &hw_hpd->base.base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}