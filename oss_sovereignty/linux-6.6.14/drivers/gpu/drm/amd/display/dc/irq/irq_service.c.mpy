{
  "module_name": "irq_service.c",
  "hash_id": "de056b1bfeeb77f3d739898d162e203e5bc190a99516c38fd55ae9b98283ed74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/irq/irq_service.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"include/irq_service_interface.h\"\n#include \"include/logger_interface.h\"\n\n#include \"dce110/irq_service_dce110.h\"\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n#include \"dce60/irq_service_dce60.h\"\n#endif\n\n#include \"dce80/irq_service_dce80.h\"\n#include \"dce120/irq_service_dce120.h\"\n#include \"dcn10/irq_service_dcn10.h\"\n\n#include \"reg_helper.h\"\n#include \"irq_service.h\"\n\n\n\n#define CTX \\\n\t\tirq_service->ctx\n#define DC_LOGGER \\\n\tirq_service->ctx->logger\n\nvoid dal_irq_service_construct(\n\tstruct irq_service *irq_service,\n\tstruct irq_service_init_data *init_data)\n{\n\tif (!init_data || !init_data->ctx) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tirq_service->ctx = init_data->ctx;\n}\n\nvoid dal_irq_service_destroy(struct irq_service **irq_service)\n{\n\tif (!irq_service || !*irq_service) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tkfree(*irq_service);\n\n\t*irq_service = NULL;\n}\n\nstatic const struct irq_source_info *find_irq_source_info(\n\tstruct irq_service *irq_service,\n\tenum dc_irq_source source)\n{\n\tif (source >= DAL_IRQ_SOURCES_NUMBER || source < DC_IRQ_SOURCE_INVALID)\n\t\treturn NULL;\n\n\treturn &irq_service->info[source];\n}\n\nvoid dal_irq_service_set_generic(\n\tstruct irq_service *irq_service,\n\tconst struct irq_source_info *info,\n\tbool enable)\n{\n\tuint32_t addr = info->enable_reg;\n\tuint32_t value = dm_read_reg(irq_service->ctx, addr);\n\n\tvalue = (value & ~info->enable_mask) |\n\t\t(info->enable_value[enable ? 0 : 1] & info->enable_mask);\n\tdm_write_reg(irq_service->ctx, addr, value);\n}\n\nbool dal_irq_service_set(\n\tstruct irq_service *irq_service,\n\tenum dc_irq_source source,\n\tbool enable)\n{\n\tconst struct irq_source_info *info =\n\t\tfind_irq_source_info(irq_service, source);\n\n\tif (!info) {\n\t\tDC_LOG_ERROR(\"%s: cannot find irq info table entry for %d\\n\",\n\t\t\t__func__,\n\t\t\tsource);\n\t\treturn false;\n\t}\n\n\tdal_irq_service_ack(irq_service, source);\n\n\tif (info->funcs && info->funcs->set) {\n\t\tif (info->funcs->set == dal_irq_service_dummy_set) {\n\t\t\tDC_LOG_WARNING(\"%s: src: %d, st: %d\\n\", __func__,\n\t\t\t\t       source, enable);\n\t\t\tASSERT(0);\n\t\t}\n\n\t\treturn info->funcs->set(irq_service, info, enable);\n\t}\n\n\tdal_irq_service_set_generic(irq_service, info, enable);\n\n\treturn true;\n}\n\nvoid dal_irq_service_ack_generic(\n\tstruct irq_service *irq_service,\n\tconst struct irq_source_info *info)\n{\n\tuint32_t addr = info->ack_reg;\n\tuint32_t value = dm_read_reg(irq_service->ctx, addr);\n\n\tvalue = (value & ~info->ack_mask) |\n\t\t(info->ack_value & info->ack_mask);\n\tdm_write_reg(irq_service->ctx, addr, value);\n}\n\nbool dal_irq_service_ack(\n\tstruct irq_service *irq_service,\n\tenum dc_irq_source source)\n{\n\tconst struct irq_source_info *info =\n\t\tfind_irq_source_info(irq_service, source);\n\n\tif (!info) {\n\t\tDC_LOG_ERROR(\"%s: cannot find irq info table entry for %d\\n\",\n\t\t\t__func__,\n\t\t\tsource);\n\t\treturn false;\n\t}\n\n\tif (info->funcs && info->funcs->ack) {\n\t\tif (info->funcs->ack == dal_irq_service_dummy_ack) {\n\t\t\tDC_LOG_WARNING(\"%s: src: %d\\n\", __func__, source);\n\t\t\tASSERT(0);\n\t\t}\n\n\t\treturn info->funcs->ack(irq_service, info);\n\t}\n\n\tdal_irq_service_ack_generic(irq_service, info);\n\n\treturn true;\n}\n\nenum dc_irq_source dal_irq_service_to_irq_source(\n\t\tstruct irq_service *irq_service,\n\t\tuint32_t src_id,\n\t\tuint32_t ext_id)\n{\n\treturn irq_service->funcs->to_dal_irq_source(\n\t\tirq_service,\n\t\tsrc_id,\n\t\text_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}