{
  "module_name": "dcn10_dpp_cm.c",
  "hash_id": "91068801334c0e8b8edc46c6210b89045857f7173693e5c3ad2a3117c179ab1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"core_types.h\"\n\n#include \"reg_helper.h\"\n#include \"dcn10_dpp.h\"\n#include \"basics/conversion.h\"\n#include \"dcn10_cm_common.h\"\n\n#define NUM_PHASES    64\n#define HORZ_MAX_TAPS 8\n#define VERT_MAX_TAPS 8\n\n#define BLACK_OFFSET_RGB_Y 0x0\n#define BLACK_OFFSET_CBCR  0x8000\n\n#define REG(reg)\\\n\tdpp->tf_regs->reg\n\n#define CTX \\\n\tdpp->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdpp->tf_shift->field_name, dpp->tf_mask->field_name\n\n#define NUM_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))\n\n\nenum dcn10_coef_filter_type_sel {\n\tSCL_COEF_LUMA_VERT_FILTER = 0,\n\tSCL_COEF_LUMA_HORZ_FILTER = 1,\n\tSCL_COEF_CHROMA_VERT_FILTER = 2,\n\tSCL_COEF_CHROMA_HORZ_FILTER = 3,\n\tSCL_COEF_ALPHA_VERT_FILTER = 4,\n\tSCL_COEF_ALPHA_HORZ_FILTER = 5\n};\n\nenum dscl_autocal_mode {\n\tAUTOCAL_MODE_OFF = 0,\n\n\t \n\tAUTOCAL_MODE_AUTOSCALE = 1,\n\t \n\tAUTOCAL_MODE_AUTOCENTER = 2,\n\t \n\tAUTOCAL_MODE_AUTOREPLICATE = 3\n};\n\nenum dscl_mode_sel {\n\tDSCL_MODE_SCALING_444_BYPASS = 0,\n\tDSCL_MODE_SCALING_444_RGB_ENABLE = 1,\n\tDSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,\n\tDSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,\n\tDSCL_MODE_SCALING_420_LUMA_BYPASS = 4,\n\tDSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,\n\tDSCL_MODE_DSCL_BYPASS = 6\n};\n\nstatic void program_gamut_remap(\n\t\tstruct dcn10_dpp *dpp,\n\t\tconst uint16_t *regval,\n\t\tenum gamut_remap_select select)\n{\n\tuint16_t selection = 0;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (regval == NULL || select == GAMUT_REMAP_BYPASS) {\n\t\tREG_SET(CM_GAMUT_REMAP_CONTROL, 0,\n\t\t\t\tCM_GAMUT_REMAP_MODE, 0);\n\t\treturn;\n\t}\n\tswitch (select) {\n\tcase GAMUT_REMAP_COEFF:\n\t\tselection = 1;\n\t\tbreak;\n\tcase GAMUT_REMAP_COMA_COEFF:\n\t\tselection = 2;\n\t\tbreak;\n\tcase GAMUT_REMAP_COMB_COEFF:\n\t\tselection = 3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_GAMUT_REMAP_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_GAMUT_REMAP_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_GAMUT_REMAP_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_GAMUT_REMAP_C12;\n\n\n\tif (select == GAMUT_REMAP_COEFF) {\n\t\tgam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\n\t} else  if (select == GAMUT_REMAP_COMA_COEFF) {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_COMA_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\n\t} else {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_COMB_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);\n\n\t\tcm_helper_program_color_matrices(\n\t\t\t\tdpp->base.ctx,\n\t\t\t\tregval,\n\t\t\t\t&gam_regs);\n\t}\n\n\tREG_SET(\n\t\t\tCM_GAMUT_REMAP_CONTROL, 0,\n\t\t\tCM_GAMUT_REMAP_MODE, selection);\n\n}\n\nvoid dpp1_cm_set_gamut_remap(\n\tstruct dpp *dpp_base,\n\tconst struct dpp_grph_csc_adjustment *adjust)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tint i = 0;\n\n\tif (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)\n\t\t \n\t\tprogram_gamut_remap(dpp, NULL, GAMUT_REMAP_BYPASS);\n\telse {\n\t\tstruct fixed31_32 arr_matrix[12];\n\t\tuint16_t arr_reg_val[12];\n\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tarr_matrix[i] = adjust->temperature_matrix[i];\n\n\t\tconvert_float_matrix(\n\t\t\tarr_reg_val, arr_matrix, 12);\n\n\t\tprogram_gamut_remap(dpp, arr_reg_val, GAMUT_REMAP_COEFF);\n\t}\n}\n\nstatic void dpp1_cm_program_color_matrix(\n\t\tstruct dcn10_dpp *dpp,\n\t\tconst uint16_t *regval)\n{\n\tuint32_t ocsc_mode;\n\tuint32_t cur_mode;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (regval == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t \n\tREG_SET(CM_TEST_DEBUG_INDEX, 0,\n\t\t\tCM_TEST_DEBUG_INDEX, 9);\n\n\tREG_GET(CM_TEST_DEBUG_DATA,\n\t\t\tCM_TEST_DEBUG_DATA_ID9_OCSC_MODE, &cur_mode);\n\n\tif (cur_mode != 4)\n\t\tocsc_mode = 4;\n\telse\n\t\tocsc_mode = 5;\n\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_OCSC_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_OCSC_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_OCSC_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_OCSC_C12;\n\n\tif (ocsc_mode == 4) {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_OCSC_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_OCSC_C33_C34);\n\n\t} else {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_COMB_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);\n\n\t}\n\n\tcm_helper_program_color_matrices(\n\t\t\tdpp->base.ctx,\n\t\t\tregval,\n\t\t\t&gam_regs);\n\n\tREG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);\n\n}\n\nvoid dpp1_cm_set_output_csc_default(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_color_space colorspace)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tconst uint16_t *regval = NULL;\n\tint arr_size;\n\n\tregval = find_color_matrix(colorspace, &arr_size);\n\tif (regval == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tdpp1_cm_program_color_matrix(dpp, regval);\n}\n\nstatic void dpp1_cm_get_reg_field(\n\t\tstruct dcn10_dpp *dpp,\n\t\tstruct xfer_func_reg *reg)\n{\n\treg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;\n\treg->masks.field_region_end = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;\n\treg->masks.field_region_linear_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;\n\treg->shifts.exp_region_start = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;\n}\n\nstatic void dpp1_cm_get_degamma_reg_field(\n\t\tstruct dcn10_dpp *dpp,\n\t\tstruct xfer_func_reg *reg)\n{\n\treg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET;\n\treg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->masks.exp_region0_num_segments = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;\n\treg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET;\n\treg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\treg->masks.exp_region1_num_segments = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;\n\n\treg->shifts.field_region_end = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_B;\n\treg->masks.field_region_end = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_B;\n\treg->shifts.field_region_end_slope = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B;\n\treg->masks.field_region_end_slope = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B;\n\treg->shifts.field_region_end_base = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_BASE_B;\n\treg->masks.field_region_end_base = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_BASE_B;\n\treg->shifts.field_region_linear_slope = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;\n\treg->masks.field_region_linear_slope = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;\n\treg->shifts.exp_region_start = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_START_B;\n\treg->masks.exp_region_start = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_START_B;\n\treg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B;\n\treg->masks.exp_resion_start_segment = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B;\n}\nvoid dpp1_cm_set_output_csc_adjustment(\n\t\tstruct dpp *dpp_base,\n\t\tconst uint16_t *regval)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tdpp1_cm_program_color_matrix(dpp, regval);\n}\n\nvoid dpp1_cm_power_on_regamma_lut(struct dpp *dpp_base,\n\t\t\t\t  bool power_on)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_SET(CM_MEM_PWR_CTRL, 0,\n\t\tRGAM_MEM_PWR_FORCE, power_on == true ? 0:1);\n\n}\n\nvoid dpp1_cm_program_regamma_lut(struct dpp *dpp_base,\n\t\t\t\t const struct pwl_result_data *rgb,\n\t\t\t\t uint32_t num)\n{\n\tuint32_t i;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_SEQ_START();\n\n\tfor (i = 0 ; i < num; i++) {\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);\n\t\tREG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);\n\n\t}\n\n}\n\nvoid dpp1_cm_configure_regamma_lut(\n\t\tstruct dpp *dpp_base,\n\t\tbool is_ram_a)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,\n\t\t\tCM_RGAM_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,\n\t\t\tCM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);\n\tREG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);\n}\n\n \nvoid dpp1_cm_program_regamma_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdpp1_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_RGAM_RAMA_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMA_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMA_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMA_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMA_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMA_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMA_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMA_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMA_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMA_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);\n\tgam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n\n}\n\n \nvoid dpp1_cm_program_regamma_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdpp1_cm_get_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_RGAM_RAMB_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMB_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMB_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMB_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMB_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMB_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMB_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMB_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMB_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMB_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);\n\tgam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\nvoid dpp1_program_input_csc(\n\t\tstruct dpp *dpp_base,\n\t\tenum dc_color_space color_space,\n\t\tenum dcn10_input_csc_select input_select,\n\t\tconst struct out_csc_color_matrix *tbl_entry)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tint i;\n\tint arr_size = sizeof(dpp_input_csc_matrix)/sizeof(struct dpp_input_csc_matrix);\n\tconst uint16_t *regval = NULL;\n\tuint32_t cur_select = 0;\n\tenum dcn10_input_csc_select select;\n\tstruct color_matrices_reg gam_regs;\n\n\tif (input_select == INPUT_CSC_SELECT_BYPASS) {\n\t\tREG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);\n\t\treturn;\n\t}\n\n\tif (tbl_entry == NULL) {\n\t\tfor (i = 0; i < arr_size; i++)\n\t\t\tif (dpp_input_csc_matrix[i].color_space == color_space) {\n\t\t\t\tregval = dpp_input_csc_matrix[i].regval;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (regval == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tregval = tbl_entry->regval;\n\t}\n\n\t \n\tREG_SET(CM_TEST_DEBUG_INDEX, 0,\n\t\t\tCM_TEST_DEBUG_INDEX, 9);\n\n\tREG_GET(CM_TEST_DEBUG_DATA,\n\t\t\tCM_TEST_DEBUG_DATA_ID9_ICSC_MODE, &cur_select);\n\n\tif (cur_select != INPUT_CSC_SELECT_ICSC)\n\t\tselect = INPUT_CSC_SELECT_ICSC;\n\telse\n\t\tselect = INPUT_CSC_SELECT_COMA;\n\n\tgam_regs.shifts.csc_c11 = dpp->tf_shift->CM_ICSC_C11;\n\tgam_regs.masks.csc_c11  = dpp->tf_mask->CM_ICSC_C11;\n\tgam_regs.shifts.csc_c12 = dpp->tf_shift->CM_ICSC_C12;\n\tgam_regs.masks.csc_c12 = dpp->tf_mask->CM_ICSC_C12;\n\n\tif (select == INPUT_CSC_SELECT_ICSC) {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_ICSC_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);\n\n\t} else {\n\n\t\tgam_regs.csc_c11_c12 = REG(CM_COMA_C11_C12);\n\t\tgam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);\n\n\t}\n\n\tcm_helper_program_color_matrices(\n\t\t\tdpp->base.ctx,\n\t\t\tregval,\n\t\t\t&gam_regs);\n\n\tREG_SET(CM_ICSC_CONTROL, 0,\n\t\t\t\tCM_ICSC_MODE, select);\n}\n\n\nvoid dpp1_program_bias_and_scale(\n\tstruct dpp *dpp_base,\n\tstruct dc_bias_and_scale *params)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_SET_2(CM_BNS_VALUES_R, 0,\n\t\tCM_BNS_SCALE_R, params->scale_red,\n\t\tCM_BNS_BIAS_R, params->bias_red);\n\n\tREG_SET_2(CM_BNS_VALUES_G, 0,\n\t\tCM_BNS_SCALE_G, params->scale_green,\n\t\tCM_BNS_BIAS_G, params->bias_green);\n\n\tREG_SET_2(CM_BNS_VALUES_B, 0,\n\t\tCM_BNS_SCALE_B, params->scale_blue,\n\t\tCM_BNS_BIAS_B, params->bias_blue);\n\n}\n\n \nvoid dpp1_program_degamma_lutb_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdpp1_cm_get_degamma_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_DGAM_RAMB_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMB_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMB_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMB_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMB_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMB_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMB_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMB_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMB_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMB_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_DGAM_RAMB_REGION_0_1);\n\tgam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);\n\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\n \nvoid dpp1_program_degamma_luta_settings(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_params *params)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tstruct xfer_func_reg gam_regs;\n\n\tdpp1_cm_get_degamma_reg_field(dpp, &gam_regs);\n\n\tgam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);\n\tgam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);\n\tgam_regs.start_cntl_r = REG(CM_DGAM_RAMA_START_CNTL_R);\n\tgam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMA_SLOPE_CNTL_B);\n\tgam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMA_SLOPE_CNTL_G);\n\tgam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMA_SLOPE_CNTL_R);\n\tgam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMA_END_CNTL1_B);\n\tgam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMA_END_CNTL2_B);\n\tgam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMA_END_CNTL1_G);\n\tgam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMA_END_CNTL2_G);\n\tgam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMA_END_CNTL1_R);\n\tgam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMA_END_CNTL2_R);\n\tgam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);\n\tgam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);\n\n\tcm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);\n}\n\nvoid dpp1_power_on_degamma_lut(\n\t\tstruct dpp *dpp_base,\n\tbool power_on)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_SET(CM_MEM_PWR_CTRL, 0,\n\t\t\tSHARED_MEM_PWR_DIS, power_on ? 0:1);\n\n}\n\nstatic void dpp1_enable_cm_block(\n\t\tstruct dpp *dpp_base)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_UPDATE(CM_CMOUT_CONTROL, CM_CMOUT_ROUND_TRUNC_MODE, 8);\n\tREG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);\n}\n\nvoid dpp1_set_degamma(\n\t\tstruct dpp *dpp_base,\n\t\tenum ipp_degamma_mode mode)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tdpp1_enable_cm_block(dpp_base);\n\n\tswitch (mode) {\n\tcase IPP_DEGAMMA_MODE_BYPASS:\n\t\t \n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);\n\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_HW_sRGB:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);\n\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_HW_xvYCC:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);\n\t\t\tbreak;\n\tcase IPP_DEGAMMA_MODE_USER_PWL:\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tREG_SEQ_SUBMIT();\n\tREG_SEQ_WAIT_DONE();\n}\n\nvoid dpp1_degamma_ram_select(\n\t\tstruct dpp *dpp_base,\n\t\t\t\t\t\t\tbool use_ram_a)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tif (use_ram_a)\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);\n\telse\n\t\tREG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 4);\n\n}\n\nstatic bool dpp1_degamma_ram_inuse(\n\t\tstruct dpp *dpp_base,\n\t\t\t\t\t\t\tbool *ram_a_inuse)\n{\n\tbool ret = false;\n\tuint32_t status_reg = 0;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,\n\t\t\t&status_reg);\n\n\tif (status_reg == 9) {\n\t\t*ram_a_inuse = true;\n\t\tret = true;\n\t} else if (status_reg == 10) {\n\t\t*ram_a_inuse = false;\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nvoid dpp1_program_degamma_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct pwl_result_data *rgb,\n\t\tuint32_t num,\n\t\tbool is_ram_a)\n{\n\tuint32_t i;\n\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tREG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);\n\tREG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,\n\t\t\t\t   CM_DGAM_LUT_WRITE_EN_MASK, 7);\n\tREG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,\n\t\t\t\t\tis_ram_a == true ? 0:1);\n\n\tREG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);\n\tfor (i = 0 ; i < num; i++) {\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);\n\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_red_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_green_reg);\n\t\tREG_SET(CM_DGAM_LUT_DATA, 0,\n\t\t\t\tCM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);\n\t}\n}\n\nvoid dpp1_set_degamma_pwl(struct dpp *dpp_base,\n\t\t\t\t\t\t\t\t const struct pwl_params *params)\n{\n\tbool is_ram_a = true;\n\n\tdpp1_power_on_degamma_lut(dpp_base, true);\n\tdpp1_enable_cm_block(dpp_base);\n\tdpp1_degamma_ram_inuse(dpp_base, &is_ram_a);\n\tif (is_ram_a == true)\n\t\tdpp1_program_degamma_lutb_settings(dpp_base, params);\n\telse\n\t\tdpp1_program_degamma_luta_settings(dpp_base, params);\n\n\tdpp1_program_degamma_lut(dpp_base, params->rgb_resulted,\n\t\t\t\t\t\t\tparams->hw_points_num, !is_ram_a);\n\tdpp1_degamma_ram_select(dpp_base, !is_ram_a);\n}\n\nvoid dpp1_full_bypass(struct dpp *dpp_base)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\t \n\tREG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,\n\t\t\tCNVC_SURFACE_PIXEL_FORMAT, 0x8);\n\n\t \n\tREG_SET_3(FORMAT_CONTROL, 0,\n\t\t\tCNVC_BYPASS, 0,\n\t\t\tFORMAT_CONTROL__ALPHA_EN, 0,\n\t\t\tFORMAT_EXPANSION_MODE, 0);\n\n\t \n\tif (dpp->tf_mask->CM_BYPASS_EN)\n\t\tREG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);\n\telse\n\t\tREG_SET(CM_CONTROL, 0, CM_BYPASS, 1);\n\n\t \n\tREG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);\n}\n\nstatic bool dpp1_ingamma_ram_inuse(struct dpp *dpp_base,\n\t\t\t\t\t\t\tbool *ram_a_inuse)\n{\n\tbool in_use = false;\n\tuint32_t status_reg = 0;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,\n\t\t\t\t&status_reg);\n\n\t\n\tif (status_reg == 1 || status_reg == 3 || status_reg == 4) {\n\t\t*ram_a_inuse = true;\n\t\tin_use = true;\n\t\n\t} else if (status_reg == 2 || status_reg == 5 || status_reg == 6) {\n\t\t*ram_a_inuse = false;\n\t\tin_use = true;\n\t}\n\treturn in_use;\n}\n\n \nvoid dpp1_program_input_lut(\n\t\tstruct dpp *dpp_base,\n\t\tconst struct dc_gamma *gamma)\n{\n\tint i;\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\tbool rama_occupied = false;\n\tuint32_t ram_num;\n\t\n\tREG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);\n\tdpp1_enable_cm_block(dpp_base);\n\t\n\tdpp1_ingamma_ram_inuse(dpp_base, &rama_occupied);\n\tif (!rama_occupied)\n\t\tREG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);\n\telse\n\t\tREG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 1);\n\t\n\tREG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, 0);\n\t\n\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 0);\n\t\n\tREG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, 7);\n\t\n\tREG_UPDATE_3(\n\t\tCM_IGAM_CONTROL,\n\t\tCM_IGAM_LUT_FORMAT_R, 3,\n\t\tCM_IGAM_LUT_FORMAT_G, 3,\n\t\tCM_IGAM_LUT_FORMAT_B, 3);\n\t\n\tREG_UPDATE(CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, 0);\n\tfor (i = 0; i < gamma->num_entries; i++) {\n\t\tREG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.red[i]));\n\t\tREG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.green[i]));\n\t\tREG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,\n\t\t\t\tdc_fixpt_round(\n\t\t\t\t\tgamma->entries.blue[i]));\n\t}\n\t\n\tREG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 0);\n\t\n\tREG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);\n\tREG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);\n}\n\nvoid dpp1_set_hdr_multiplier(\n\t\tstruct dpp *dpp_base,\n\t\tuint32_t multiplier)\n{\n\tstruct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);\n\n\tREG_UPDATE(CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, multiplier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}