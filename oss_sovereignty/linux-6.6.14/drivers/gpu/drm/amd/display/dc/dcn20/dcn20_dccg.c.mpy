{
  "module_name": "dcn20_dccg.c",
  "hash_id": "84d437e2a0d8ec8095ac032bdeda383ef1839ff5b851ff3c47d813e2cada625c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dcn20_dccg.h\"\n\n#define TO_DCN_DCCG(dccg)\\\n\tcontainer_of(dccg, struct dcn_dccg, base)\n\n#define REG(reg) \\\n\t(dccg_dcn->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name\n\n#define CTX \\\n\tdccg_dcn->base.ctx\n#define DC_LOGGER \\\n\tdccg->ctx->logger\n\nvoid dccg2_update_dpp_dto(struct dccg *dccg, int dpp_inst, int req_dppclk)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tif (dccg->ref_dppclk && req_dppclk) {\n\t\tint ref_dppclk = dccg->ref_dppclk;\n\t\tint modulo, phase;\n\n\t\t\n\t\tmodulo = 0xff;   \n\t\tphase = ((modulo * req_dppclk) + ref_dppclk - 1) / ref_dppclk;\n\n\t\tif (phase > 0xff) {\n\t\t\tASSERT(false);\n\t\t\tphase = 0xff;\n\t\t}\n\n\t\tREG_SET_2(DPPCLK_DTO_PARAM[dpp_inst], 0,\n\t\t\t\tDPPCLK0_DTO_PHASE, phase,\n\t\t\t\tDPPCLK0_DTO_MODULO, modulo);\n\t\tREG_UPDATE(DPPCLK_DTO_CTRL,\n\t\t\t\tDPPCLK_DTO_ENABLE[dpp_inst], 1);\n\t} else {\n\t\tREG_UPDATE(DPPCLK_DTO_CTRL,\n\t\t\t\tDPPCLK_DTO_ENABLE[dpp_inst], 0);\n\t}\n\n\tdccg->pipe_dppclk_khz[dpp_inst] = req_dppclk;\n}\n\nvoid dccg2_get_dccg_ref_freq(struct dccg *dccg,\n\t\tunsigned int xtalin_freq_inKhz,\n\t\tunsigned int *dccg_ref_freq_inKhz)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\tuint32_t clk_en = 0;\n\tuint32_t clk_sel = 0;\n\n\tREG_GET_2(REFCLK_CNTL, REFCLK_CLOCK_EN, &clk_en, REFCLK_SRC_SEL, &clk_sel);\n\n\tif (clk_en != 0) {\n\t\t\n\t\t\n\t\t\n\t\tASSERT_CRITICAL(false);\n\t}\n\n\t*dccg_ref_freq_inKhz = xtalin_freq_inKhz;\n\n\treturn;\n}\n\nvoid dccg2_set_fifo_errdet_ovr_en(struct dccg *dccg,\n\t\tbool en)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tREG_UPDATE(DISPCLK_FREQ_CHANGE_CNTL,\n\t\t\tDCCG_FIFO_ERRDET_OVR_EN, en ? 1 : 0);\n}\n\nvoid dccg2_otg_add_pixel(struct dccg *dccg,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tREG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_ADD_PIXEL[otg_inst], 0,\n\t\t\tOTG_DROP_PIXEL[otg_inst], 0);\n\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_ADD_PIXEL[otg_inst], 1);\n}\n\nvoid dccg2_otg_drop_pixel(struct dccg *dccg,\n\t\tuint32_t otg_inst)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);\n\n\tREG_UPDATE_2(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_ADD_PIXEL[otg_inst], 0,\n\t\t\tOTG_DROP_PIXEL[otg_inst], 0);\n\tREG_UPDATE(OTG_PIXEL_RATE_CNTL[otg_inst],\n\t\t\tOTG_DROP_PIXEL[otg_inst], 1);\n}\n\nvoid dccg2_init(struct dccg *dccg)\n{\n}\n\nstatic const struct dccg_funcs dccg2_funcs = {\n\t.update_dpp_dto = dccg2_update_dpp_dto,\n\t.get_dccg_ref_freq = dccg2_get_dccg_ref_freq,\n\t.set_fifo_errdet_ovr_en = dccg2_set_fifo_errdet_ovr_en,\n\t.otg_add_pixel = dccg2_otg_add_pixel,\n\t.otg_drop_pixel = dccg2_otg_drop_pixel,\n\t.dccg_init = dccg2_init\n};\n\nstruct dccg *dccg2_create(\n\tstruct dc_context *ctx,\n\tconst struct dccg_registers *regs,\n\tconst struct dccg_shift *dccg_shift,\n\tconst struct dccg_mask *dccg_mask)\n{\n\tstruct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_ATOMIC);\n\tstruct dccg *base;\n\n\tif (dccg_dcn == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tbase = &dccg_dcn->base;\n\tbase->ctx = ctx;\n\tbase->funcs = &dccg2_funcs;\n\n\tdccg_dcn->regs = regs;\n\tdccg_dcn->dccg_shift = dccg_shift;\n\tdccg_dcn->dccg_mask = dccg_mask;\n\n\treturn &dccg_dcn->base;\n}\n\nvoid dcn_dccg_destroy(struct dccg **dccg)\n{\n\tstruct dcn_dccg *dccg_dcn = TO_DCN_DCCG(*dccg);\n\n\tkfree(dccg_dcn);\n\t*dccg = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}