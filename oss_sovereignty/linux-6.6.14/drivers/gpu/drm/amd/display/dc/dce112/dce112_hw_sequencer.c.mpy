{
  "module_name": "dce112_hw_sequencer.c",
  "hash_id": "6e2acc3885f0906087d89bb73e6968369fc6ee41c31b6b5e36a6dfce85aa6f9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"core_types.h\"\n#include \"dce112_hw_sequencer.h\"\n\n#include \"dce110/dce110_hw_sequencer.h\"\n\n \n#include \"dce/dce_11_2_d.h\"\n#include \"dce/dce_11_2_sh_mask.h\"\n\nstruct dce112_hw_seq_reg_offsets {\n\tuint32_t crtc;\n};\n\n\nstatic const struct dce112_hw_seq_reg_offsets reg_offsets[] = {\n{\n\t.crtc = (mmCRTC0_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC1_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC2_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC3_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC4_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n},\n{\n\t.crtc = (mmCRTC5_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),\n}\n};\n#define HW_REG_CRTC(reg, id)\\\n\t(reg + reg_offsets[id].crtc)\n\n \n\nstatic void dce112_init_pte(struct dc_context *ctx)\n{\n\tuint32_t addr;\n\tuint32_t value = 0;\n\tuint32_t chunk_int = 0;\n\tuint32_t chunk_mul = 0;\n\n\taddr = mmDVMM_PTE_REQ;\n\tvalue = dm_read_reg(ctx, addr);\n\n\tchunk_int = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\tchunk_mul = get_reg_field_value(\n\t\tvalue,\n\t\tDVMM_PTE_REQ,\n\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\tif (chunk_int != 0x4 || chunk_mul != 0x4) {\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t255,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tMAX_PTEREQ_TO_ISSUE);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_INT);\n\n\t\tset_reg_field_value(\n\t\t\tvalue,\n\t\t\t4,\n\t\t\tDVMM_PTE_REQ,\n\t\t\tHFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);\n\n\t\tdm_write_reg(ctx, addr, value);\n\t}\n}\n\nstatic bool dce112_enable_display_power_gating(\n\tstruct dc *dc,\n\tuint8_t controller_id,\n\tstruct dc_bios *dcb,\n\tenum pipe_gating_control power_gating)\n{\n\tenum bp_result bp_result = BP_RESULT_OK;\n\tenum bp_pipe_control_action cntl;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tif (power_gating == PIPE_GATING_CONTROL_INIT)\n\t\tcntl = ASIC_PIPE_INIT;\n\telse if (power_gating == PIPE_GATING_CONTROL_ENABLE)\n\t\tcntl = ASIC_PIPE_ENABLE;\n\telse\n\t\tcntl = ASIC_PIPE_DISABLE;\n\n\tif (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0) {\n\n\t\tbp_result = dcb->funcs->enable_disp_power_gating(\n\t\t\t\t\t\tdcb, controller_id + 1, cntl);\n\n\t\t \n\t\tdm_write_reg(ctx,\n\t\t\tHW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),\n\t\t\t0);\n\t}\n\n\tif (power_gating != PIPE_GATING_CONTROL_ENABLE)\n\t\tdce112_init_pte(ctx);\n\n\tif (bp_result == BP_RESULT_OK)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid dce112_hw_sequencer_construct(struct dc *dc)\n{\n\t \n\tdce110_hw_sequencer_construct(dc);\n\tdc->hwseq->funcs.enable_display_power_gating = dce112_enable_display_power_gating;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}