{
  "module_name": "link_detection.c",
  "hash_id": "aab4ef44fec73d93bac35d95f352d142562ff0912fd0899d0d9db19e32dd8175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/link/link_detection.c",
  "human_readable_source": " \n\n \n\n#include \"link_dpms.h\"\n#include \"link_detection.h\"\n#include \"link_hwss.h\"\n#include \"protocols/link_edp_panel_control.h\"\n#include \"protocols/link_ddc.h\"\n#include \"protocols/link_hpd.h\"\n#include \"protocols/link_dpcd.h\"\n#include \"protocols/link_dp_capability.h\"\n#include \"protocols/link_dp_dpia.h\"\n#include \"protocols/link_dp_phy.h\"\n#include \"protocols/link_dp_training.h\"\n#include \"accessories/link_dp_trace.h\"\n\n#include \"link_enc_cfg.h\"\n#include \"dm_helpers.h\"\n#include \"clk_mgr.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define LINK_INFO(...) \\\n\tDC_LOG_HW_HOTPLUG(  \\\n\t\t__VA_ARGS__)\n \n#define LINK_TRAINING_MAX_VERIFY_RETRY 2\n\nstatic const u8 DP_SINK_BRANCH_DEV_NAME_7580[] = \"7580\\x80u\";\n\nstatic const uint8_t dp_hdmi_dongle_signature_str[] = \"DP-HDMI ADAPTOR\";\n\nstatic enum ddc_transaction_type get_ddc_transaction_type(enum signal_type sink_signal)\n{\n\tenum ddc_transaction_type transaction_type = DDC_TRANSACTION_TYPE_NONE;\n\n\tswitch (sink_signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\tcase SIGNAL_TYPE_LVDS:\n\tcase SIGNAL_TYPE_RGB:\n\t\ttransaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_EDP:\n\t\ttransaction_type = DDC_TRANSACTION_TYPE_I2C_OVER_AUX;\n\t\tbreak;\n\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\t \n\t\ttransaction_type = DDC_TRANSACTION_TYPE_I2C_OVER_AUX;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn transaction_type;\n}\n\nstatic enum signal_type get_basic_signal_type(struct graphics_object_id encoder,\n\t\t\t\t\t      struct graphics_object_id downstream)\n{\n\tif (downstream.type == OBJECT_TYPE_CONNECTOR) {\n\t\tswitch (downstream.id) {\n\t\tcase CONNECTOR_ID_SINGLE_LINK_DVII:\n\t\t\tswitch (encoder.id) {\n\t\t\tcase ENCODER_ID_INTERNAL_DAC1:\n\t\t\tcase ENCODER_ID_INTERNAL_KLDSCP_DAC1:\n\t\t\tcase ENCODER_ID_INTERNAL_DAC2:\n\t\t\tcase ENCODER_ID_INTERNAL_KLDSCP_DAC2:\n\t\t\t\treturn SIGNAL_TYPE_RGB;\n\t\t\tdefault:\n\t\t\t\treturn SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\t\t}\n\t\tbreak;\n\t\tcase CONNECTOR_ID_DUAL_LINK_DVII:\n\t\t{\n\t\t\tswitch (encoder.id) {\n\t\t\tcase ENCODER_ID_INTERNAL_DAC1:\n\t\t\tcase ENCODER_ID_INTERNAL_KLDSCP_DAC1:\n\t\t\tcase ENCODER_ID_INTERNAL_DAC2:\n\t\t\tcase ENCODER_ID_INTERNAL_KLDSCP_DAC2:\n\t\t\t\treturn SIGNAL_TYPE_RGB;\n\t\t\tdefault:\n\t\t\t\treturn SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase CONNECTOR_ID_SINGLE_LINK_DVID:\n\t\t\treturn SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tcase CONNECTOR_ID_DUAL_LINK_DVID:\n\t\t\treturn SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\tcase CONNECTOR_ID_VGA:\n\t\t\treturn SIGNAL_TYPE_RGB;\n\t\tcase CONNECTOR_ID_HDMI_TYPE_A:\n\t\t\treturn SIGNAL_TYPE_HDMI_TYPE_A;\n\t\tcase CONNECTOR_ID_LVDS:\n\t\t\treturn SIGNAL_TYPE_LVDS;\n\t\tcase CONNECTOR_ID_DISPLAY_PORT:\n\t\tcase CONNECTOR_ID_USBC:\n\t\t\treturn SIGNAL_TYPE_DISPLAY_PORT;\n\t\tcase CONNECTOR_ID_EDP:\n\t\t\treturn SIGNAL_TYPE_EDP;\n\t\tdefault:\n\t\t\treturn SIGNAL_TYPE_NONE;\n\t\t}\n\t} else if (downstream.type == OBJECT_TYPE_ENCODER) {\n\t\tswitch (downstream.id) {\n\t\tcase ENCODER_ID_EXTERNAL_NUTMEG:\n\t\tcase ENCODER_ID_EXTERNAL_TRAVIS:\n\t\t\treturn SIGNAL_TYPE_DISPLAY_PORT;\n\t\tdefault:\n\t\t\treturn SIGNAL_TYPE_NONE;\n\t\t}\n\t}\n\n\treturn SIGNAL_TYPE_NONE;\n}\n\n \nstatic enum signal_type link_detect_sink_signal_type(struct dc_link *link,\n\t\t\t\t\t enum dc_detect_reason reason)\n{\n\tenum signal_type result;\n\tstruct graphics_object_id enc_id;\n\n\tif (link->is_dig_mapping_flexible)\n\t\tenc_id = (struct graphics_object_id){.id = ENCODER_ID_UNKNOWN};\n\telse\n\t\tenc_id = link->link_enc->id;\n\tresult = get_basic_signal_type(enc_id, link->link_id);\n\n\t \n\tif (link->ep_type != DISPLAY_ENDPOINT_PHY)\n\t\treturn result;\n\n\t \n\n\t \n\n\t \n\tif (link->link_id.id == CONNECTOR_ID_PCIE) {\n\t\t \n\t}\n\n\tswitch (link->link_id.id) {\n\tcase CONNECTOR_ID_HDMI_TYPE_A: {\n\t\t \n\t\tstruct audio_support *aud_support =\n\t\t\t\t\t&link->dc->res_pool->audio_support;\n\n\t\tif (!aud_support->hdmi_audio_native)\n\t\t\tif (link->link_id.id == CONNECTOR_ID_HDMI_TYPE_A)\n\t\t\t\tresult = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t}\n\tbreak;\n\tcase CONNECTOR_ID_DISPLAY_PORT:\n\tcase CONNECTOR_ID_USBC: {\n\t\t \n\t\tif (reason != DETECT_REASON_HPDRX) {\n\t\t\t \n\t\t\tif (!dm_helpers_is_dp_sink_present(link))\n\t\t\t\tresult = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic enum signal_type decide_signal_from_strap_and_dongle_type(enum display_dongle_type dongle_type,\n\t\t\t\t\t\t\t\t struct audio_support *audio_support)\n{\n\tenum signal_type signal = SIGNAL_TYPE_NONE;\n\n\tswitch (dongle_type) {\n\tcase DISPLAY_DONGLE_DP_HDMI_DONGLE:\n\t\tif (audio_support->hdmi_audio_on_dongle)\n\t\t\tsignal = SIGNAL_TYPE_HDMI_TYPE_A;\n\t\telse\n\t\t\tsignal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tbreak;\n\tcase DISPLAY_DONGLE_DP_DVI_DONGLE:\n\t\tsignal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tbreak;\n\tcase DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE:\n\t\tif (audio_support->hdmi_audio_native)\n\t\t\tsignal =  SIGNAL_TYPE_HDMI_TYPE_A;\n\t\telse\n\t\t\tsignal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tbreak;\n\tdefault:\n\t\tsignal = SIGNAL_TYPE_NONE;\n\t\tbreak;\n\t}\n\n\treturn signal;\n}\n\nstatic void read_scdc_caps(struct ddc_service *ddc_service,\n\t\tstruct dc_sink *sink)\n{\n\tuint8_t slave_address = HDMI_SCDC_ADDRESS;\n\tuint8_t offset = HDMI_SCDC_MANUFACTURER_OUI;\n\n\tlink_query_ddc_data(ddc_service, slave_address, &offset,\n\t\t\tsizeof(offset), sink->scdc_caps.manufacturer_OUI.byte,\n\t\t\tsizeof(sink->scdc_caps.manufacturer_OUI.byte));\n\n\toffset = HDMI_SCDC_DEVICE_ID;\n\n\tlink_query_ddc_data(ddc_service, slave_address, &offset,\n\t\t\tsizeof(offset), &(sink->scdc_caps.device_id.byte),\n\t\t\tsizeof(sink->scdc_caps.device_id.byte));\n}\n\nstatic bool i2c_read(\n\tstruct ddc_service *ddc,\n\tuint32_t address,\n\tuint8_t *buffer,\n\tuint32_t len)\n{\n\tuint8_t offs_data = 0;\n\tstruct i2c_payload payloads[2] = {\n\t\t{\n\t\t.write = true,\n\t\t.address = address,\n\t\t.length = 1,\n\t\t.data = &offs_data },\n\t\t{\n\t\t.write = false,\n\t\t.address = address,\n\t\t.length = len,\n\t\t.data = buffer } };\n\n\tstruct i2c_command command = {\n\t\t.payloads = payloads,\n\t\t.number_of_payloads = 2,\n\t\t.engine = DDC_I2C_COMMAND_ENGINE,\n\t\t.speed = ddc->ctx->dc->caps.i2c_speed_in_khz };\n\n\treturn dm_helpers_submit_i2c(\n\t\t\tddc->ctx,\n\t\t\tddc->link,\n\t\t\t&command);\n}\n\nenum {\n\tDP_SINK_CAP_SIZE =\n\t\tDP_EDP_CONFIGURATION_CAP - DP_DPCD_REV + 1\n};\n\nstatic void query_dp_dual_mode_adaptor(\n\tstruct ddc_service *ddc,\n\tstruct display_sink_capability *sink_cap)\n{\n\tuint8_t i;\n\tbool is_valid_hdmi_signature;\n\tenum display_dongle_type *dongle = &sink_cap->dongle_type;\n\tuint8_t type2_dongle_buf[DP_ADAPTOR_TYPE2_SIZE];\n\tbool is_type2_dongle = false;\n\tint retry_count = 2;\n\tstruct dp_hdmi_dongle_signature_data *dongle_signature;\n\n\t \n\t*dongle = DISPLAY_DONGLE_NONE;\n\tsink_cap->max_hdmi_pixel_clock = DP_ADAPTOR_HDMI_SAFE_MAX_TMDS_CLK;\n\n\t \n\tif (!i2c_read(\n\t\tddc,\n\t\tDP_HDMI_DONGLE_ADDRESS,\n\t\ttype2_dongle_buf,\n\t\tsizeof(type2_dongle_buf))) {\n\t\t \n\t\twhile (retry_count > 0) {\n\t\t\tif (i2c_read(ddc,\n\t\t\t\tDP_HDMI_DONGLE_ADDRESS,\n\t\t\t\ttype2_dongle_buf,\n\t\t\t\tsizeof(type2_dongle_buf)))\n\t\t\t\tbreak;\n\t\t\tretry_count--;\n\t\t}\n\t\tif (retry_count == 0) {\n\t\t\t*dongle = DISPLAY_DONGLE_DP_DVI_DONGLE;\n\t\t\tsink_cap->max_hdmi_pixel_clock = DP_ADAPTOR_DVI_MAX_TMDS_CLK;\n\n\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf, sizeof(type2_dongle_buf),\n\t\t\t\t\t\"DP-DVI passive dongle %dMhz: \",\n\t\t\t\t\tDP_ADAPTOR_DVI_MAX_TMDS_CLK / 1000);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (type2_dongle_buf[DP_ADAPTOR_TYPE2_REG_ID] == DP_ADAPTOR_TYPE2_ID)\n\t\tis_type2_dongle = true;\n\n\tdongle_signature =\n\t\t(struct dp_hdmi_dongle_signature_data *)type2_dongle_buf;\n\n\tis_valid_hdmi_signature = true;\n\n\t \n\tif (dongle_signature->eot != DP_HDMI_DONGLE_SIGNATURE_EOT) {\n\t\tis_valid_hdmi_signature = false;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(dongle_signature->id); ++i) {\n\t\t \n\t\tif (dongle_signature->id[i] !=\n\t\t\tdp_hdmi_dongle_signature_str[i] && i != 3) {\n\n\t\t\tif (is_type2_dongle) {\n\t\t\t\tis_valid_hdmi_signature = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (is_type2_dongle) {\n\t\tuint32_t max_tmds_clk =\n\t\t\ttype2_dongle_buf[DP_ADAPTOR_TYPE2_REG_MAX_TMDS_CLK];\n\n\t\tmax_tmds_clk = max_tmds_clk * 2 + max_tmds_clk / 2;\n\n\t\tif (0 == max_tmds_clk ||\n\t\t\t\tmax_tmds_clk < DP_ADAPTOR_TYPE2_MIN_TMDS_CLK ||\n\t\t\t\tmax_tmds_clk > DP_ADAPTOR_TYPE2_MAX_TMDS_CLK) {\n\t\t\t*dongle = DISPLAY_DONGLE_DP_DVI_DONGLE;\n\n\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf,\n\t\t\t\t\tsizeof(type2_dongle_buf),\n\t\t\t\t\t\"DP-DVI passive dongle %dMhz: \",\n\t\t\t\t\tDP_ADAPTOR_DVI_MAX_TMDS_CLK / 1000);\n\t\t} else {\n\t\t\tif (is_valid_hdmi_signature == true) {\n\t\t\t\t*dongle = DISPLAY_DONGLE_DP_HDMI_DONGLE;\n\n\t\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf,\n\t\t\t\t\t\tsizeof(type2_dongle_buf),\n\t\t\t\t\t\t\"Type 2 DP-HDMI passive dongle %dMhz: \",\n\t\t\t\t\t\tmax_tmds_clk);\n\t\t\t} else {\n\t\t\t\t*dongle = DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE;\n\n\t\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf,\n\t\t\t\t\t\tsizeof(type2_dongle_buf),\n\t\t\t\t\t\t\"Type 2 DP-HDMI passive dongle (no signature) %dMhz: \",\n\t\t\t\t\t\tmax_tmds_clk);\n\n\t\t\t}\n\n\t\t\t \n\t\t\tsink_cap->max_hdmi_pixel_clock =\n\t\t\t\tmax_tmds_clk * 1000;\n\t\t}\n\t\tsink_cap->is_dongle_type_one = false;\n\n\t} else {\n\t\tif (is_valid_hdmi_signature == true) {\n\t\t\t*dongle = DISPLAY_DONGLE_DP_HDMI_DONGLE;\n\n\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf,\n\t\t\t\t\tsizeof(type2_dongle_buf),\n\t\t\t\t\t\"Type 1 DP-HDMI passive dongle %dMhz: \",\n\t\t\t\t\tsink_cap->max_hdmi_pixel_clock / 1000);\n\t\t} else {\n\t\t\t*dongle = DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE;\n\n\t\t\tCONN_DATA_DETECT(ddc->link, type2_dongle_buf,\n\t\t\t\t\tsizeof(type2_dongle_buf),\n\t\t\t\t\t\"Type 1 DP-HDMI passive dongle (no signature) %dMhz: \",\n\t\t\t\t\tsink_cap->max_hdmi_pixel_clock / 1000);\n\t\t}\n\t\tsink_cap->is_dongle_type_one = true;\n\t}\n\n\treturn;\n}\n\nstatic enum signal_type dp_passive_dongle_detection(struct ddc_service *ddc,\n\t\t\t\t\t\t    struct display_sink_capability *sink_cap,\n\t\t\t\t\t\t    struct audio_support *audio_support)\n{\n\tquery_dp_dual_mode_adaptor(ddc, sink_cap);\n\n\treturn decide_signal_from_strap_and_dongle_type(sink_cap->dongle_type,\n\t\t\t\t\t\t\taudio_support);\n}\n\nstatic void link_disconnect_sink(struct dc_link *link)\n{\n\tif (link->local_sink) {\n\t\tdc_sink_release(link->local_sink);\n\t\tlink->local_sink = NULL;\n\t}\n\n\tlink->dpcd_sink_count = 0;\n\t\n}\n\nstatic void link_disconnect_remap(struct dc_sink *prev_sink, struct dc_link *link)\n{\n\tdc_sink_release(link->local_sink);\n\tlink->local_sink = prev_sink;\n}\n\nstatic void query_hdcp_capability(enum signal_type signal, struct dc_link *link)\n{\n\tstruct hdcp_protection_message msg22;\n\tstruct hdcp_protection_message msg14;\n\n\tmemset(&msg22, 0, sizeof(struct hdcp_protection_message));\n\tmemset(&msg14, 0, sizeof(struct hdcp_protection_message));\n\tmemset(link->hdcp_caps.rx_caps.raw, 0,\n\t\tsizeof(link->hdcp_caps.rx_caps.raw));\n\n\tif ((link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t\tlink->ddc->transaction_type ==\n\t\t\tDDC_TRANSACTION_TYPE_I2C_OVER_AUX) ||\n\t\t\tlink->connector_signal == SIGNAL_TYPE_EDP) {\n\t\tmsg22.data = link->hdcp_caps.rx_caps.raw;\n\t\tmsg22.length = sizeof(link->hdcp_caps.rx_caps.raw);\n\t\tmsg22.msg_id = HDCP_MESSAGE_ID_RX_CAPS;\n\t} else {\n\t\tmsg22.data = &link->hdcp_caps.rx_caps.fields.version;\n\t\tmsg22.length = sizeof(link->hdcp_caps.rx_caps.fields.version);\n\t\tmsg22.msg_id = HDCP_MESSAGE_ID_HDCP2VERSION;\n\t}\n\tmsg22.version = HDCP_VERSION_22;\n\tmsg22.link = HDCP_LINK_PRIMARY;\n\tmsg22.max_retries = 5;\n\tdc_process_hdcp_msg(signal, link, &msg22);\n\n\tif (signal == SIGNAL_TYPE_DISPLAY_PORT || signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\tmsg14.data = &link->hdcp_caps.bcaps.raw;\n\t\tmsg14.length = sizeof(link->hdcp_caps.bcaps.raw);\n\t\tmsg14.msg_id = HDCP_MESSAGE_ID_READ_BCAPS;\n\t\tmsg14.version = HDCP_VERSION_14;\n\t\tmsg14.link = HDCP_LINK_PRIMARY;\n\t\tmsg14.max_retries = 5;\n\n\t\tdc_process_hdcp_msg(signal, link, &msg14);\n\t}\n\n}\nstatic void read_current_link_settings_on_detect(struct dc_link *link)\n{\n\tunion lane_count_set lane_count_set = {0};\n\tuint8_t link_bw_set;\n\tuint8_t link_rate_set;\n\tuint32_t read_dpcd_retry_cnt = 10;\n\tenum dc_status status = DC_ERROR_UNEXPECTED;\n\tint i;\n\tunion max_down_spread max_down_spread = {0};\n\n\t\n\tfor (i = 0; i < read_dpcd_retry_cnt; i++) {\n\t\tstatus = core_link_read_dpcd(link,\n\t\t\t\t\t     DP_LANE_COUNT_SET,\n\t\t\t\t\t     &lane_count_set.raw,\n\t\t\t\t\t     sizeof(lane_count_set));\n\t\t \n\t\tif (status == DC_OK) {\n\t\t\tlink->cur_link_settings.lane_count =\n\t\t\t\t\tlane_count_set.bits.LANE_COUNT_SET;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(8);\n\t}\n\n\t\n\tcore_link_read_dpcd(link, DP_LINK_BW_SET,\n\t\t\t    &link_bw_set, sizeof(link_bw_set));\n\n\tif (link_bw_set == 0) {\n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\t \n\t\t\tcore_link_read_dpcd(link, DP_LINK_RATE_SET,\n\t\t\t\t\t    &link_rate_set, sizeof(link_rate_set));\n\n\t\t\t\n\t\t\tif (link_rate_set < link->dpcd_caps.edp_supported_link_rates_count) {\n\t\t\t\tlink->cur_link_settings.link_rate =\n\t\t\t\t\tlink->dpcd_caps.edp_supported_link_rates[link_rate_set];\n\t\t\t\tlink->cur_link_settings.link_rate_set = link_rate_set;\n\t\t\t\tlink->cur_link_settings.use_link_rate_set = true;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tASSERT(false);\n\t\t}\n\t} else {\n\t\tlink->cur_link_settings.link_rate = link_bw_set;\n\t\tlink->cur_link_settings.use_link_rate_set = false;\n\t}\n\t\n\tcore_link_read_dpcd(link, DP_MAX_DOWNSPREAD,\n\t\t\t    &max_down_spread.raw, sizeof(max_down_spread));\n\tlink->cur_link_settings.link_spread =\n\t\tmax_down_spread.bits.MAX_DOWN_SPREAD ?\n\t\tLINK_SPREAD_05_DOWNSPREAD_30KHZ : LINK_SPREAD_DISABLED;\n}\n\nstatic bool detect_dp(struct dc_link *link,\n\t\t      struct display_sink_capability *sink_caps,\n\t\t      enum dc_detect_reason reason)\n{\n\tstruct audio_support *audio_support = &link->dc->res_pool->audio_support;\n\n\tsink_caps->signal = link_detect_sink_signal_type(link, reason);\n\tsink_caps->transaction_type =\n\t\tget_ddc_transaction_type(sink_caps->signal);\n\n\tif (sink_caps->transaction_type == DDC_TRANSACTION_TYPE_I2C_OVER_AUX) {\n\t\tsink_caps->signal = SIGNAL_TYPE_DISPLAY_PORT;\n\t\tif (!detect_dp_sink_caps(link))\n\t\t\treturn false;\n\n\t\tif (is_dp_branch_device(link))\n\t\t\t \n\t\t\tlink->type = dc_connection_sst_branch;\n\t} else {\n\t\tif (link->dc->debug.disable_dp_plus_plus_wa &&\n\t\t\t\tlink->link_enc->features.flags.bits.IS_UHBR20_CAPABLE)\n\t\t\treturn false;\n\n\t\t \n\t\tsink_caps->signal = dp_passive_dongle_detection(link->ddc,\n\t\t\t\t\t\t\t\tsink_caps,\n\t\t\t\t\t\t\t\taudio_support);\n\t\tlink->dpcd_caps.dongle_type = sink_caps->dongle_type;\n\t\tlink->dpcd_caps.is_dongle_type_one = sink_caps->is_dongle_type_one;\n\t\tlink->dpcd_caps.dpcd_rev.raw = 0;\n\t}\n\n\treturn true;\n}\n\nstatic bool is_same_edid(struct dc_edid *old_edid, struct dc_edid *new_edid)\n{\n\tif (old_edid->length != new_edid->length)\n\t\treturn false;\n\n\tif (new_edid->length == 0)\n\t\treturn false;\n\n\treturn (memcmp(old_edid->raw_edid,\n\t\t       new_edid->raw_edid, new_edid->length) == 0);\n}\n\nstatic bool wait_for_entering_dp_alt_mode(struct dc_link *link)\n{\n\n\t \n\tunsigned int sleep_time_in_microseconds = 500;\n\tunsigned int tries_allowed = 400;\n\tbool is_in_alt_mode;\n\tunsigned long long enter_timestamp;\n\tunsigned long long finish_timestamp;\n\tunsigned long long time_taken_in_ns;\n\tint tries_taken;\n\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\t \n\tif (!link->link_enc->funcs->is_in_alt_mode)\n\t\treturn true;\n\n\tis_in_alt_mode = link->link_enc->funcs->is_in_alt_mode(link->link_enc);\n\tDC_LOG_DC(\"DP Alt mode state on HPD: %d\\n\", is_in_alt_mode);\n\n\tif (is_in_alt_mode)\n\t\treturn true;\n\n\tenter_timestamp = dm_get_timestamp(link->ctx);\n\n\tfor (tries_taken = 0; tries_taken < tries_allowed; tries_taken++) {\n\t\tudelay(sleep_time_in_microseconds);\n\t\t \n\t\tif (link->link_enc->funcs->is_in_alt_mode(link->link_enc)) {\n\t\t\tfinish_timestamp = dm_get_timestamp(link->ctx);\n\t\t\ttime_taken_in_ns =\n\t\t\t\tdm_get_elapse_time_in_ns(link->ctx,\n\t\t\t\t\t\t\t finish_timestamp,\n\t\t\t\t\t\t\t enter_timestamp);\n\t\t\tDC_LOG_WARNING(\"Alt mode entered finished after %llu ms\\n\",\n\t\t\t\t       div_u64(time_taken_in_ns, 1000000));\n\t\t\treturn true;\n\t\t}\n\t}\n\tfinish_timestamp = dm_get_timestamp(link->ctx);\n\ttime_taken_in_ns = dm_get_elapse_time_in_ns(link->ctx, finish_timestamp,\n\t\t\t\t\t\t    enter_timestamp);\n\tDC_LOG_WARNING(\"Alt mode has timed out after %llu ms\\n\",\n\t\t\tdiv_u64(time_taken_in_ns, 1000000));\n\treturn false;\n}\n\nstatic void apply_dpia_mst_dsc_always_on_wa(struct dc_link *link)\n{\n\t \n\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA &&\n\t\t\tlink->type == dc_connection_mst_branch &&\n\t\t\tlink->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_90CC24 &&\n\t\t\tlink->dpcd_caps.branch_hw_revision == DP_BRANCH_HW_REV_20 &&\n\t\t\tlink->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT &&\n\t\t\t!link->dc->debug.dpia_debug.bits.disable_mst_dsc_work_around)\n\t\tlink->wa_flags.dpia_mst_dsc_always_on = true;\n}\n\nstatic void revert_dpia_mst_dsc_always_on_wa(struct dc_link *link)\n{\n\t \n\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA)\n\t\tlink->wa_flags.dpia_mst_dsc_always_on = false;\n}\n\nstatic bool discover_dp_mst_topology(struct dc_link *link, enum dc_detect_reason reason)\n{\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tLINK_INFO(\"link=%d, mst branch is now Connected\\n\",\n\t\t  link->link_index);\n\n\tlink->type = dc_connection_mst_branch;\n\tapply_dpia_mst_dsc_always_on_wa(link);\n\n\tdm_helpers_dp_update_branch_info(link->ctx, link);\n\tif (dm_helpers_dp_mst_start_top_mgr(link->ctx,\n\t\t\tlink, (reason == DETECT_REASON_BOOT || reason == DETECT_REASON_RESUMEFROMS3S4))) {\n\t\tlink_disconnect_sink(link);\n\t} else {\n\t\tlink->type = dc_connection_sst_branch;\n\t}\n\n\treturn link->type == dc_connection_mst_branch;\n}\n\nbool link_reset_cur_dp_mst_topology(struct dc_link *link)\n{\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tLINK_INFO(\"link=%d, mst branch is now Disconnected\\n\",\n\t\t  link->link_index);\n\n\trevert_dpia_mst_dsc_always_on_wa(link);\n\treturn dm_helpers_dp_mst_stop_top_mgr(link->ctx, link);\n}\n\nstatic bool should_prepare_phy_clocks_for_link_verification(const struct dc *dc,\n\t\tenum dc_detect_reason reason)\n{\n\tint i;\n\tbool can_apply_seamless_boot = false;\n\n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tif (dc->current_state->streams[i]->apply_seamless_boot_optimization) {\n\t\t\tcan_apply_seamless_boot = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn !can_apply_seamless_boot && reason != DETECT_REASON_BOOT;\n}\n\nstatic void prepare_phy_clocks_for_destructive_link_verification(const struct dc *dc)\n{\n\tdc_z10_restore(dc);\n\tclk_mgr_exit_optimized_pwr_state(dc, dc->clk_mgr);\n}\n\nstatic void restore_phy_clocks_for_destructive_link_verification(const struct dc *dc)\n{\n\tclk_mgr_optimize_pwr_state(dc, dc->clk_mgr);\n}\n\nstatic void verify_link_capability_destructive(struct dc_link *link,\n\t\tstruct dc_sink *sink,\n\t\tenum dc_detect_reason reason)\n{\n\tbool should_prepare_phy_clocks =\n\t\t\tshould_prepare_phy_clocks_for_link_verification(link->dc, reason);\n\n\tif (should_prepare_phy_clocks)\n\t\tprepare_phy_clocks_for_destructive_link_verification(link->dc);\n\n\tif (dc_is_dp_signal(link->local_sink->sink_signal)) {\n\t\tstruct dc_link_settings known_limit_link_setting =\n\t\t\t\tdp_get_max_link_cap(link);\n\t\tlink_set_all_streams_dpms_off_for_link(link);\n\t\tdp_verify_link_cap_with_retries(\n\t\t\t\tlink, &known_limit_link_setting,\n\t\t\t\tLINK_TRAINING_MAX_VERIFY_RETRY);\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\tif (should_prepare_phy_clocks)\n\t\trestore_phy_clocks_for_destructive_link_verification(link->dc);\n}\n\nstatic void verify_link_capability_non_destructive(struct dc_link *link)\n{\n\tif (dc_is_dp_signal(link->local_sink->sink_signal)) {\n\t\tif (dc_is_embedded_signal(link->local_sink->sink_signal) ||\n\t\t\t\tlink->ep_type == DISPLAY_ENDPOINT_USB4_DPIA)\n\t\t\t \n\t\t\tlink->verified_link_cap = link->reported_link_cap;\n\t\telse\n\t\t\tlink->verified_link_cap = dp_get_max_link_cap(link);\n\t}\n}\n\nstatic bool should_verify_link_capability_destructively(struct dc_link *link,\n\t\tenum dc_detect_reason reason)\n{\n\tbool destrictive = false;\n\tstruct dc_link_settings max_link_cap;\n\tbool is_link_enc_unavailable = link->link_enc &&\n\t\t\tlink->dc->res_pool->funcs->link_encs_assign &&\n\t\t\t!link_enc_cfg_is_link_enc_avail(\n\t\t\t\t\tlink->ctx->dc,\n\t\t\t\t\tlink->link_enc->preferred_engine,\n\t\t\t\t\tlink);\n\n\tif (dc_is_dp_signal(link->local_sink->sink_signal)) {\n\t\tmax_link_cap = dp_get_max_link_cap(link);\n\t\tdestrictive = true;\n\n\t\tif (link->dc->debug.skip_detection_link_training ||\n\t\t\t\tdc_is_embedded_signal(link->local_sink->sink_signal) ||\n\t\t\t\tlink->ep_type == DISPLAY_ENDPOINT_USB4_DPIA) {\n\t\t\tdestrictive = false;\n\t\t} else if (link_dp_get_encoding_format(&max_link_cap) ==\n\t\t\t\tDP_8b_10b_ENCODING) {\n\t\t\tif (link->dpcd_caps.is_mst_capable ||\n\t\t\t\t\tis_link_enc_unavailable) {\n\t\t\t\tdestrictive = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn destrictive;\n}\n\nstatic void verify_link_capability(struct dc_link *link, struct dc_sink *sink,\n\t\tenum dc_detect_reason reason)\n{\n\tif (should_verify_link_capability_destructively(link, reason))\n\t\tverify_link_capability_destructive(link, sink, reason);\n\telse\n\t\tverify_link_capability_non_destructive(link);\n}\n\n \nstatic bool detect_link_and_local_sink(struct dc_link *link,\n\t\t\t\t  enum dc_detect_reason reason)\n{\n\tstruct dc_sink_init_data sink_init_data = { 0 };\n\tstruct display_sink_capability sink_caps = { 0 };\n\tuint32_t i;\n\tbool converter_disable_audio = false;\n\tstruct audio_support *aud_support = &link->dc->res_pool->audio_support;\n\tbool same_edid = false;\n\tenum dc_edid_status edid_status;\n\tstruct dc_context *dc_ctx = link->ctx;\n\tstruct dc *dc = dc_ctx->dc;\n\tstruct dc_sink *sink = NULL;\n\tstruct dc_sink *prev_sink = NULL;\n\tstruct dpcd_caps prev_dpcd_caps;\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tenum dc_connection_type pre_connection_type = link->type;\n\tconst uint32_t post_oui_delay = 30;  \n\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tif (dc_is_virtual_signal(link->connector_signal))\n\t\treturn false;\n\n\tif (((link->connector_signal == SIGNAL_TYPE_LVDS ||\n\t\tlink->connector_signal == SIGNAL_TYPE_EDP) &&\n\t\t(!link->dc->config.allow_edp_hotplug_detection)) &&\n\t\tlink->local_sink) {\n\t\t \n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP &&\n\t\t\t(link->dpcd_sink_ext_caps.bits.oled == 1)) {\n\t\t\tdpcd_set_source_specific_data(link);\n\t\t\tmsleep(post_oui_delay);\n\t\t\tset_default_brightness_aux(link);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif (!link_detect_connection_type(link, &new_connection_type)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tprev_sink = link->local_sink;\n\tif (prev_sink) {\n\t\tdc_sink_retain(prev_sink);\n\t\tmemcpy(&prev_dpcd_caps, &link->dpcd_caps, sizeof(struct dpcd_caps));\n\t}\n\n\tlink_disconnect_sink(link);\n\tif (new_connection_type != dc_connection_none) {\n\t\tlink->type = new_connection_type;\n\t\tlink->link_state_valid = false;\n\n\t\t \n\t\tswitch (link->connector_signal) {\n\t\tcase SIGNAL_TYPE_HDMI_TYPE_A: {\n\t\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\t\tif (aud_support->hdmi_audio_native)\n\t\t\t\tsink_caps.signal = SIGNAL_TYPE_HDMI_TYPE_A;\n\t\t\telse\n\t\t\t\tsink_caps.signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SIGNAL_TYPE_DVI_SINGLE_LINK: {\n\t\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\t\tsink_caps.signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SIGNAL_TYPE_DVI_DUAL_LINK: {\n\t\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\t\tsink_caps.signal = SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SIGNAL_TYPE_LVDS: {\n\t\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\t\tsink_caps.signal = SIGNAL_TYPE_LVDS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SIGNAL_TYPE_EDP: {\n\t\t\tdetect_edp_sink_caps(link);\n\t\t\tread_current_link_settings_on_detect(link);\n\n\t\t\t \n\t\t\tif (dc->config.enable_mipi_converter_optimization &&\n\t\t\t\tdc_ctx->dce_version == DCN_VERSION_3_01 &&\n\t\t\t\tlink->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_0022B9 &&\n\t\t\t\tmemcmp(&link->dpcd_caps.branch_dev_name, DP_SINK_BRANCH_DEV_NAME_7580,\n\t\t\t\t\tsizeof(link->dpcd_caps.branch_dev_name)) == 0) {\n\t\t\t\tdc->config.edp_no_power_sequencing = true;\n\n\t\t\t\tif (!link->dpcd_caps.set_power_state_capable_edp)\n\t\t\t\t\tlink->wa_flags.dp_keep_receiver_powered = true;\n\t\t\t}\n\n\t\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C_OVER_AUX;\n\t\t\tsink_caps.signal = SIGNAL_TYPE_EDP;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT: {\n\n\t\t\t \n\t\t\tif (link->ep_type == DISPLAY_ENDPOINT_PHY &&\n\t\t\t    link->link_enc->features.flags.bits.DP_IS_USB_C == 1) {\n\n\t\t\t\t \n\t\t\t\tif (!wait_for_entering_dp_alt_mode(link))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!detect_dp(link, &sink_caps, reason)) {\n\t\t\t\tlink->type = pre_connection_type;\n\n\t\t\t\tif (prev_sink)\n\t\t\t\t\tdc_sink_release(prev_sink);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (link->type == dc_connection_sst_branch &&\n\t\t\t    link->dpcd_caps.sink_count.bits.SINK_COUNT == 0) {\n\t\t\t\tif (prev_sink)\n\t\t\t\t\t \n\t\t\t\t\tdc_sink_release(prev_sink);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (link->type == dc_connection_sst_branch &&\n\t\t\t\t\tis_dp_active_dongle(link) &&\n\t\t\t\t\t(link->dpcd_caps.dongle_type !=\n\t\t\t\t\t\t\tDISPLAY_DONGLE_DP_HDMI_CONVERTER))\n\t\t\t\tconverter_disable_audio = true;\n\n\t\t\t \n\t\t\tif (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA &&\n\t\t\t\t\tlink->reported_link_cap.link_rate > LINK_RATE_HIGH3)\n\t\t\t\tlink->reported_link_cap.link_rate = LINK_RATE_HIGH3;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tDC_ERROR(\"Invalid connector type! signal:%d\\n\",\n\t\t\t\t link->connector_signal);\n\t\t\tif (prev_sink)\n\t\t\t\tdc_sink_release(prev_sink);\n\t\t\treturn false;\n\t\t}  \n\n\t\tif (link->dpcd_caps.sink_count.bits.SINK_COUNT)\n\t\t\tlink->dpcd_sink_count =\n\t\t\t\tlink->dpcd_caps.sink_count.bits.SINK_COUNT;\n\t\telse\n\t\t\tlink->dpcd_sink_count = 1;\n\n\t\tset_ddc_transaction_type(link->ddc,\n\t\t\t\t\t\t     sink_caps.transaction_type);\n\n\t\tlink->aux_mode =\n\t\t\tlink_is_in_aux_transaction_mode(link->ddc);\n\n\t\tsink_init_data.link = link;\n\t\tsink_init_data.sink_signal = sink_caps.signal;\n\n\t\tsink = dc_sink_create(&sink_init_data);\n\t\tif (!sink) {\n\t\t\tDC_ERROR(\"Failed to create sink!\\n\");\n\t\t\tif (prev_sink)\n\t\t\t\tdc_sink_release(prev_sink);\n\t\t\treturn false;\n\t\t}\n\n\t\tsink->link->dongle_max_pix_clk = sink_caps.max_hdmi_pixel_clock;\n\t\tsink->converter_disable_audio = converter_disable_audio;\n\n\t\t \n\t\tlink->local_sink = sink;\n\n\t\tedid_status = dm_helpers_read_local_edid(link->ctx,\n\t\t\t\t\t\t\t link, sink);\n\n\t\tswitch (edid_status) {\n\t\tcase EDID_BAD_CHECKSUM:\n\t\t\tDC_LOG_ERROR(\"EDID checksum invalid.\\n\");\n\t\t\tbreak;\n\t\tcase EDID_PARTIAL_VALID:\n\t\t\tDC_LOG_ERROR(\"Partial EDID valid, abandon invalid blocks.\\n\");\n\t\t\tbreak;\n\t\tcase EDID_NO_RESPONSE:\n\t\t\tDC_LOG_ERROR(\"No EDID read.\\n\");\n\t\t\t \n\t\t\tif (dc_is_hdmi_signal(link->connector_signal) ||\n\t\t\t    dc_is_dvi_signal(link->connector_signal)) {\n\t\t\t\tif (prev_sink)\n\t\t\t\t\tdc_sink_release(prev_sink);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (link->type == dc_connection_sst_branch &&\n\t\t\t\t\tlink->dpcd_caps.dongle_type ==\n\t\t\t\t\t\tDISPLAY_DONGLE_DP_VGA_CONVERTER &&\n\t\t\t\t\treason == DETECT_REASON_HPDRX) {\n\t\t\t\t \n\t\t\t\tif (prev_sink)\n\t\t\t\t\tdc_sink_release(prev_sink);\n\t\t\t\tlink_disconnect_sink(link);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif ((prev_sink) &&\n\t\t    (edid_status == EDID_THE_SAME || edid_status == EDID_OK))\n\t\t\tsame_edid = is_same_edid(&prev_sink->dc_edid,\n\t\t\t\t\t\t &sink->dc_edid);\n\n\t\tif (sink->edid_caps.panel_patch.skip_scdc_overwrite)\n\t\t\tlink->ctx->dc->debug.hdmi20_disable = true;\n\n\t\tif (sink->edid_caps.panel_patch.remove_sink_ext_caps)\n\t\t\tlink->dpcd_sink_ext_caps.raw = 0;\n\n\t\tif (dc_is_hdmi_signal(link->connector_signal))\n\t\t\tread_scdc_caps(link->ddc, link->local_sink);\n\n\t\tif (link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT &&\n\t\t    sink_caps.transaction_type ==\n\t\t    DDC_TRANSACTION_TYPE_I2C_OVER_AUX) {\n\t\t\t \n\t\t\tquery_hdcp_capability(sink->sink_signal, link);\n\t\t} else {\n\t\t\t \n\t\t\tif (same_edid) {\n\t\t\t\tlink_disconnect_remap(prev_sink, link);\n\t\t\t\tsink = prev_sink;\n\t\t\t\tprev_sink = NULL;\n\t\t\t}\n\t\t\tquery_hdcp_capability(sink->sink_signal, link);\n\t\t}\n\n\t\t \n\t\tif (sink->sink_signal == SIGNAL_TYPE_HDMI_TYPE_A &&\n\t\t    !sink->edid_caps.edid_hdmi)\n\t\t\tsink->sink_signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\n\t\tif (link->local_sink && dc_is_dp_signal(sink_caps.signal))\n\t\t\tdp_trace_init(link);\n\n\t\t \n\t\tfor (i = 0; i < sink->dc_edid.length / DC_EDID_BLOCK_SIZE; i++) {\n\t\t\tCONN_DATA_DETECT(link,\n\t\t\t\t\t &sink->dc_edid.raw_edid[i * DC_EDID_BLOCK_SIZE],\n\t\t\t\t\t DC_EDID_BLOCK_SIZE,\n\t\t\t\t\t \"%s: [Block %d] \", sink->edid_caps.display_name, i);\n\t\t}\n\n\t\tDC_LOG_DETECTION_EDID_PARSER(\"%s: \"\n\t\t\t\"manufacturer_id = %X, \"\n\t\t\t\"product_id = %X, \"\n\t\t\t\"serial_number = %X, \"\n\t\t\t\"manufacture_week = %d, \"\n\t\t\t\"manufacture_year = %d, \"\n\t\t\t\"display_name = %s, \"\n\t\t\t\"speaker_flag = %d, \"\n\t\t\t\"audio_mode_count = %d\\n\",\n\t\t\t__func__,\n\t\t\tsink->edid_caps.manufacturer_id,\n\t\t\tsink->edid_caps.product_id,\n\t\t\tsink->edid_caps.serial_number,\n\t\t\tsink->edid_caps.manufacture_week,\n\t\t\tsink->edid_caps.manufacture_year,\n\t\t\tsink->edid_caps.display_name,\n\t\t\tsink->edid_caps.speaker_flags,\n\t\t\tsink->edid_caps.audio_mode_count);\n\n\t\tfor (i = 0; i < sink->edid_caps.audio_mode_count; i++) {\n\t\t\tDC_LOG_DETECTION_EDID_PARSER(\"%s: mode number = %d, \"\n\t\t\t\t\"format_code = %d, \"\n\t\t\t\t\"channel_count = %d, \"\n\t\t\t\t\"sample_rate = %d, \"\n\t\t\t\t\"sample_size = %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\ti,\n\t\t\t\tsink->edid_caps.audio_modes[i].format_code,\n\t\t\t\tsink->edid_caps.audio_modes[i].channel_count,\n\t\t\t\tsink->edid_caps.audio_modes[i].sample_rate,\n\t\t\t\tsink->edid_caps.audio_modes[i].sample_size);\n\t\t}\n\n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\t \n\t\t\tif (dc_ctx->dc->res_pool->funcs->get_panel_config_defaults)\n\t\t\t\tdc_ctx->dc->res_pool->funcs->get_panel_config_defaults(&link->panel_config);\n\t\t\t \n\t\t\tdm_helpers_init_panel_settings(dc_ctx, &link->panel_config, sink);\n\t\t\t \n\t\t\tdm_helpers_override_panel_settings(dc_ctx, &link->panel_config);\n\n\t\t\t \n\t\t\tif (link->reported_link_cap.link_rate == LINK_RATE_UNKNOWN)\n\t\t\t\tlink->panel_config.ilr.optimize_edp_link_rate = true;\n\t\t\tif (edp_is_ilr_optimization_enabled(link))\n\t\t\t\tlink->reported_link_cap.link_rate = get_max_link_rate_from_ilr_table(link);\n\t\t}\n\n\t} else {\n\t\t \n\t\tlink->type = dc_connection_none;\n\t\tsink_caps.signal = SIGNAL_TYPE_NONE;\n\t\tmemset(&link->hdcp_caps, 0, sizeof(struct hdcp_caps));\n\t\t \n\t\tlink->dongle_max_pix_clk = 0;\n\n\t\tdc_link_clear_dprx_states(link);\n\t\tdp_trace_reset(link);\n\t}\n\n\tLINK_INFO(\"link=%d, dc_sink_in=%p is now %s prev_sink=%p edid same=%d\\n\",\n\t\t  link->link_index, sink,\n\t\t  (sink_caps.signal ==\n\t\t   SIGNAL_TYPE_NONE ? \"Disconnected\" : \"Connected\"),\n\t\t  prev_sink, same_edid);\n\n\tif (prev_sink)\n\t\tdc_sink_release(prev_sink);\n\n\treturn true;\n}\n\n \nbool link_detect_connection_type(struct dc_link *link, enum dc_connection_type *type)\n{\n\tuint32_t is_hpd_high = 0;\n\n\tif (link->connector_signal == SIGNAL_TYPE_LVDS) {\n\t\t*type = dc_connection_single;\n\t\treturn true;\n\t}\n\n\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t \n\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t\tlink->dc->hwss.edp_power_control(link, true);\n\t\tlink->dc->hwss.edp_wait_for_hpd_ready(link, true);\n\t}\n\n\t \n\tif (link->ep_type != DISPLAY_ENDPOINT_PHY) {\n\t\tif (link->is_hpd_pending || !dpia_query_hpd_status(link))\n\t\t\t*type = dc_connection_none;\n\t\telse\n\t\t\t*type = dc_connection_single;\n\n\t\treturn true;\n\t}\n\n\n\tif (!query_hpd_status(link, &is_hpd_high))\n\t\tgoto hpd_gpio_failure;\n\n\tif (is_hpd_high) {\n\t\t*type = dc_connection_single;\n\t\t \n\t} else {\n\t\t*type = dc_connection_none;\n\t\tif (link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\t \n\t\t\tif (!link->dc->config.edp_no_power_sequencing)\n\t\t\t\tlink->dc->hwss.edp_power_control(link, false);\n\t\t}\n\t}\n\n\treturn true;\n\nhpd_gpio_failure:\n\treturn false;\n}\n\nbool link_detect(struct dc_link *link, enum dc_detect_reason reason)\n{\n\tbool is_local_sink_detect_success;\n\tbool is_delegated_to_mst_top_mgr = false;\n\tenum dc_connection_type pre_link_type = link->type;\n\n\tDC_LOGGER_INIT(link->ctx->logger);\n\n\tis_local_sink_detect_success = detect_link_and_local_sink(link, reason);\n\n\tif (is_local_sink_detect_success && link->local_sink)\n\t\tverify_link_capability(link, link->local_sink, reason);\n\n\tDC_LOG_DC(\"%s: link_index=%d is_local_sink_detect_success=%d pre_link_type=%d link_type=%d\\n\", __func__,\n\t\t\t\tlink->link_index, is_local_sink_detect_success, pre_link_type, link->type);\n\n\tif (is_local_sink_detect_success && link->local_sink &&\n\t\t\tdc_is_dp_signal(link->local_sink->sink_signal) &&\n\t\t\tlink->dpcd_caps.is_mst_capable)\n\t\tis_delegated_to_mst_top_mgr = discover_dp_mst_topology(link, reason);\n\n\tif (is_local_sink_detect_success &&\n\t\t\tpre_link_type == dc_connection_mst_branch &&\n\t\t\tlink->type != dc_connection_mst_branch)\n\t\tis_delegated_to_mst_top_mgr = link_reset_cur_dp_mst_topology(link);\n\n\treturn is_local_sink_detect_success && !is_delegated_to_mst_top_mgr;\n}\n\nvoid link_clear_dprx_states(struct dc_link *link)\n{\n\tmemset(&link->dprx_states, 0, sizeof(link->dprx_states));\n}\n\nbool link_is_hdcp14(struct dc_link *link, enum signal_type signal)\n{\n\tbool ret = false;\n\n\tswitch (signal)\t{\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tret = link->hdcp_caps.bcaps.bits.HDCP_CAPABLE;\n\t\tbreak;\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t \n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nbool link_is_hdcp22(struct dc_link *link, enum signal_type signal)\n{\n\tbool ret = false;\n\n\tswitch (signal)\t{\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tret = (link->hdcp_caps.bcaps.bits.HDCP_CAPABLE &&\n\t\t\t\tlink->hdcp_caps.rx_caps.fields.byte0.hdcp_capable &&\n\t\t\t\t(link->hdcp_caps.rx_caps.fields.version == 0x2)) ? 1 : 0;\n\t\tbreak;\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tret = (link->hdcp_caps.rx_caps.fields.version == 0x4) ? 1:0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nconst struct dc_link_status *link_get_status(const struct dc_link *link)\n{\n\treturn &link->link_status;\n}\n\n\nstatic bool link_add_remote_sink_helper(struct dc_link *dc_link, struct dc_sink *sink)\n{\n\tif (dc_link->sink_count >= MAX_SINKS_PER_LINK) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tdc_sink_retain(sink);\n\n\tdc_link->remote_sinks[dc_link->sink_count] = sink;\n\tdc_link->sink_count++;\n\n\treturn true;\n}\n\nstruct dc_sink *link_add_remote_sink(\n\t\tstruct dc_link *link,\n\t\tconst uint8_t *edid,\n\t\tint len,\n\t\tstruct dc_sink_init_data *init_data)\n{\n\tstruct dc_sink *dc_sink;\n\tenum dc_edid_status edid_status;\n\n\tif (len > DC_MAX_EDID_BUFFER_SIZE) {\n\t\tdm_error(\"Max EDID buffer size breached!\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!init_data) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tif (!init_data->link) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdc_sink = dc_sink_create(init_data);\n\n\tif (!dc_sink)\n\t\treturn NULL;\n\n\tmemmove(dc_sink->dc_edid.raw_edid, edid, len);\n\tdc_sink->dc_edid.length = len;\n\n\tif (!link_add_remote_sink_helper(\n\t\t\tlink,\n\t\t\tdc_sink))\n\t\tgoto fail_add_sink;\n\n\tedid_status = dm_helpers_parse_edid_caps(\n\t\t\tlink,\n\t\t\t&dc_sink->dc_edid,\n\t\t\t&dc_sink->edid_caps);\n\n\t \n\tif (edid_status != EDID_OK && edid_status != EDID_PARTIAL_VALID) {\n\t\tdc_sink->dc_edid.length = 0;\n\t\tdm_error(\"Bad EDID, status%d!\\n\", edid_status);\n\t}\n\n\treturn dc_sink;\n\nfail_add_sink:\n\tdc_sink_release(dc_sink);\n\treturn NULL;\n}\n\nvoid link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)\n{\n\tint i;\n\n\tif (!link->sink_count) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < link->sink_count; i++) {\n\t\tif (link->remote_sinks[i] == sink) {\n\t\t\tdc_sink_release(sink);\n\t\t\tlink->remote_sinks[i] = NULL;\n\n\t\t\t \n\t\t\twhile (i < link->sink_count - 1) {\n\t\t\t\tlink->remote_sinks[i] = link->remote_sinks[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tlink->remote_sinks[i] = NULL;\n\t\t\tlink->sink_count--;\n\t\t\treturn;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}