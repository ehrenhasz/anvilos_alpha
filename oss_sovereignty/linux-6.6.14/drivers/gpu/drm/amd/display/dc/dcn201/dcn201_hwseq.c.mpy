{
  "module_name": "dcn201_hwseq.c",
  "hash_id": "85dd145ec47854cd6c685d131baff9823f19b2842668023da733a0bc04fd93e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn201/dcn201_hwseq.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"basics/dc_common.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dcn201_hwseq.h\"\n#include \"dcn201_optc.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"hubp.h\"\n#include \"dchubbub.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"dccg.h\"\n#include \"clk_mgr.h\"\n#include \"reg_helper.h\"\n\n#define CTX \\\n\thws->ctx\n\n#define REG(reg)\\\n\thws->regs->reg\n\n#define DC_LOGGER \\\n\tdc->ctx->logger\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstatic bool patch_address_for_sbs_tb_stereo(\n\t\tstruct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)\n{\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tbool sec_split = pipe_ctx->top_pipe &&\n\t\tpipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;\n\n\tif (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t(pipe_ctx->stream->timing.timing_3d_format ==\n\t\t\tTIMING_3D_FORMAT_SIDE_BY_SIDE ||\n\t\tpipe_ctx->stream->timing.timing_3d_format ==\n\t\t\tTIMING_3D_FORMAT_TOP_AND_BOTTOM)) {\n\t\t*addr = plane_state->address.grph_stereo.left_addr;\n\t\tplane_state->address.grph_stereo.left_addr =\n\t\t\tplane_state->address.grph_stereo.right_addr;\n\t\treturn true;\n\t} else {\n\t\tif (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&\n\t\t\tplane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {\n\t\t\tplane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;\n\t\t\tplane_state->address.grph_stereo.right_addr =\n\t\t\tplane_state->address.grph_stereo.left_addr;\n\t\t\tplane_state->address.grph_stereo.right_meta_addr =\n\t\t\tplane_state->address.grph_stereo.left_meta_addr;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool gpu_addr_to_uma(struct dce_hwseq *hwseq,\n\t\tPHYSICAL_ADDRESS_LOC *addr)\n{\n\tbool is_in_uma;\n\n\tif (hwseq->fb_base.quad_part <= addr->quad_part &&\n\t\t\taddr->quad_part < hwseq->fb_top.quad_part) {\n\t\taddr->quad_part -= hwseq->fb_base.quad_part;\n\t\taddr->quad_part += hwseq->fb_offset.quad_part;\n\t\tis_in_uma = true;\n\t} else if (hwseq->fb_offset.quad_part <= addr->quad_part &&\n\t\t\taddr->quad_part <= hwseq->uma_top.quad_part) {\n\t\tis_in_uma = true;\n\t} else {\n\t\tis_in_uma = false;\n\t}\n\treturn is_in_uma;\n}\n\nstatic void plane_address_in_gpu_space_to_uma(struct dce_hwseq *hwseq,\n\t\tstruct dc_plane_address *addr)\n{\n\tswitch (addr->type) {\n\tcase PLN_ADDR_TYPE_GRAPHICS:\n\t\tgpu_addr_to_uma(hwseq, &addr->grph.addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->grph.meta_addr);\n\t\tbreak;\n\tcase PLN_ADDR_TYPE_GRPH_STEREO:\n\t\tgpu_addr_to_uma(hwseq, &addr->grph_stereo.left_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->grph_stereo.left_meta_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->grph_stereo.right_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->grph_stereo.right_meta_addr);\n\t\tbreak;\n\tcase PLN_ADDR_TYPE_VIDEO_PROGRESSIVE:\n\t\tgpu_addr_to_uma(hwseq, &addr->video_progressive.luma_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->video_progressive.luma_meta_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->video_progressive.chroma_addr);\n\t\tgpu_addr_to_uma(hwseq, &addr->video_progressive.chroma_meta_addr);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\nvoid dcn201_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tbool addr_patched = false;\n\tPHYSICAL_ADDRESS_LOC addr;\n\tstruct dc_plane_state *plane_state = pipe_ctx->plane_state;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_plane_address uma;\n\n\tif (plane_state == NULL)\n\t\treturn;\n\n\tuma = plane_state->address;\n\taddr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);\n\n\tplane_address_in_gpu_space_to_uma(hws, &uma);\n\n\tpipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(\n\t\t\tpipe_ctx->plane_res.hubp,\n\t\t\t&uma,\n\t\t\tplane_state->flip_immediate);\n\n\tplane_state->status.requested_address = plane_state->address;\n\n\tif (plane_state->flip_immediate)\n\t\tplane_state->status.current_address = plane_state->address;\n\n\tif (addr_patched)\n\t\tpipe_ctx->plane_state->address.grph_stereo.left_addr = addr;\n}\n\n \nvoid dcn201_init_blank(\n\t\tstruct dc *dc,\n\t\tstruct timing_generator *tg)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\tstruct output_pixel_processor *opp = NULL;\n\tuint32_t num_opps, opp_id_src0, opp_id_src1;\n\tuint32_t otg_active_width, otg_active_height;\n\n\t \n\tcolor_space = COLOR_SPACE_SRGB;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\t \n\ttg->funcs->get_otg_active_size(tg,\n\t\t\t&otg_active_width,\n\t\t\t&otg_active_height);\n\n\t \n\ttg->funcs->get_optc_source(tg, &num_opps, &opp_id_src0, &opp_id_src1);\n\tASSERT(opp_id_src0 < dc->res_pool->res_cap->num_opp);\n\topp = dc->res_pool->opps[opp_id_src0];\n\n\topp->funcs->opp_set_disp_pattern_generator(\n\t\t\topp,\n\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t&black_color,\n\t\t\totg_active_width,\n\t\t\totg_active_height,\n\t\t\t0);\n\n\thws->funcs.wait_for_blank_complete(opp);\n}\n\nstatic void read_mmhub_vm_setup(struct dce_hwseq *hws)\n{\n\tuint32_t fb_base = REG_READ(MC_VM_FB_LOCATION_BASE);\n\tuint32_t fb_top = REG_READ(MC_VM_FB_LOCATION_TOP);\n\tuint32_t fb_offset = REG_READ(MC_VM_FB_OFFSET);\n\n\t \n\tfb_top++;\n\n\t \n\thws->fb_base.low_part = fb_base;\n\thws->fb_base.quad_part <<= 24;\n\n\thws->fb_top.low_part  = fb_top;\n\thws->fb_top.quad_part <<= 24;\n\thws->fb_offset.low_part = fb_offset;\n\thws->fb_offset.quad_part <<= 24;\n\n\thws->uma_top.quad_part = hws->fb_top.quad_part\n\t\t\t- hws->fb_base.quad_part + hws->fb_offset.quad_part;\n}\n\nvoid dcn201_init_hw(struct dc *dc)\n{\n\tint i, j;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tstruct dc_state  *context = dc->current_state;\n\n\tif (res_pool->dccg->funcs->dccg_init)\n\t\tres_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\thws->funcs.bios_golden_init(dc);\n\n\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\n\t\tif (res_pool->dccg && res_pool->hubbub) {\n\t\t\t(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,\n\t\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,\n\t\t\t\t\t&res_pool->ref_clocks.dccg_ref_clock_inKhz);\n\n\t\t\t(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,\n\t\t\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz,\n\t\t\t\t\t&res_pool->ref_clocks.dchub_ref_clock_inKhz);\n\t\t} else {\n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t}\n\t} else\n\t\tASSERT_CRITICAL(false);\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\t}\n\tif (hws->fb_offset.quad_part == 0)\n\t\tread_mmhub_vm_setup(hws);\n\n\t \n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg)) {\n\t\t\tdcn201_init_blank(dc, tg);\n\t\t}\n\t}\n\n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\ttg->funcs->lock(tg);\n\t}\n\n\tfor (i = 0; i < res_pool->pipe_count; i++) {\n\t\tstruct dpp *dpp = res_pool->dpps[i];\n\n\t\tdpp->funcs->dpp_reset(dpp);\n\t}\n\n\t \n\tres_pool->mpc->funcs->mpc_init(res_pool->mpc);\n\n\t \n\tfor (i = 0; i < res_pool->res_cap->num_opp; i++) {\n\t\tres_pool->opps[i]->mpc_tree_params.opp_id = res_pool->opps[i]->inst;\n\t\tres_pool->opps[i]->mpc_tree_params.opp_list = NULL;\n\t\tfor (j = 0; j < MAX_PIPES; j++)\n\t\t\tres_pool->opps[i]->mpcc_disconnect_pending[j] = false;\n\t}\n\n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = res_pool->timing_generators[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = res_pool->hubps[i];\n\t\tstruct dpp *dpp = res_pool->dpps[i];\n\n\t\tpipe_ctx->stream_res.tg = tg;\n\t\tpipe_ctx->pipe_idx = i;\n\n\t\tpipe_ctx->plane_res.hubp = hubp;\n\t\tpipe_ctx->plane_res.dpp = dpp;\n\t\tpipe_ctx->plane_res.mpcc_inst = dpp->inst;\n\t\thubp->mpcc_id = dpp->inst;\n\t\thubp->opp_id = OPP_ID_INVALID;\n\t\thubp->power_gated = false;\n\t\tpipe_ctx->stream_res.opp = NULL;\n\n\t\thubp->funcs->hubp_init(hubp);\n\n\t\tres_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;\n\t\tpipe_ctx->stream_res.opp = res_pool->opps[i];\n\t\t \n\t\thws->funcs.plane_atomic_disconnect(dc, pipe_ctx);\n\t}\n\n\t \n\tfor (i = 0; i < res_pool->res_cap->num_dwb; i++)\n\t\tres_pool->dwbc[i]->mcif = res_pool->mcif_wb[i];\n\n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = res_pool->timing_generators[i];\n\n\t\tif (tg->funcs->is_tg_enabled(tg))\n\t\t\ttg->funcs->unlock(tg);\n\t}\n\n\tfor (i = 0; i < res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tdc->hwss.disable_plane(dc, pipe_ctx);\n\n\t\tpipe_ctx->stream_res.tg = NULL;\n\t\tpipe_ctx->plane_res.hubp = NULL;\n\t}\n\n\tfor (i = 0; i < res_pool->timing_generator_count; i++) {\n\t\tstruct timing_generator *tg = res_pool->timing_generators[i];\n\n\t\ttg->funcs->tg_init(tg);\n\t}\n\n\tfor (i = 0; i < res_pool->audio_count; i++) {\n\t\tstruct audio *audio = res_pool->audios[i];\n\n\t\taudio->funcs->hw_init(audio);\n\t}\n\n\t \n\tREG_WRITE(DIO_MEM_PWR_CTRL, 0);\n\n\tif (!dc->debug.disable_clock_gate) {\n\t\t \n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);\n\n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);\n\n\t\tREG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);\n\t}\n}\n\n \nvoid dcn201_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tint dpp_id = pipe_ctx->plane_res.dpp->inst;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct mpc_tree *mpc_tree_params;\n\tstruct mpcc *mpcc_to_remove = NULL;\n\tstruct output_pixel_processor *opp = pipe_ctx->stream_res.opp;\n\tbool mpcc_removed = false;\n\n\tmpc_tree_params = &(opp->mpc_tree_params);\n\n\t \n\tif (mpc->funcs->get_mpcc_for_dpp_from_secondary)\n\t\tmpcc_to_remove = mpc->funcs->get_mpcc_for_dpp_from_secondary(mpc_tree_params, dpp_id);\n\n\t \n\tif (mpcc_to_remove != NULL && mpc->funcs->remove_mpcc_from_secondary) {\n\t\tmpc->funcs->remove_mpcc_from_secondary(mpc, mpc_tree_params, mpcc_to_remove);\n\t\tmpcc_removed = true;\n\t}\n\n\t \n\tmpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);\n\tif (mpcc_to_remove != NULL) {\n\t\tmpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);\n\t\tmpcc_removed = true;\n\t}\n\n\t \n\tif (mpcc_removed == false)\n\t\treturn;\n\n\tif (opp != NULL)\n\t\topp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;\n\n\tdc->optimized_required = true;\n\n\tif (hubp->funcs->hubp_disconnect)\n\t\thubp->funcs->hubp_disconnect(hubp);\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\nvoid dcn201_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)\n{\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\tstruct mpcc_blnd_cfg blnd_cfg;\n\tbool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;\n\tint mpcc_id, dpp_id;\n\tstruct mpcc *new_mpcc;\n\tstruct mpcc *remove_mpcc = NULL;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);\n\n\tif (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR) {\n\t\tget_hdr_visual_confirm_color(\n\t\t\t\tpipe_ctx, &blnd_cfg.black_color);\n\t} else if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE) {\n\t\tget_surface_visual_confirm_color(\n\t\t\t\tpipe_ctx, &blnd_cfg.black_color);\n\t} else {\n\t\tcolor_space_to_black_color(\n\t\t\t\tdc, pipe_ctx->stream->output_color_space,\n\t\t\t\t&blnd_cfg.black_color);\n\t}\n\n\tif (per_pixel_alpha)\n\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;\n\telse\n\t\tblnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA;\n\n\tblnd_cfg.overlap_only = false;\n\n\tif (pipe_ctx->plane_state->global_alpha_value)\n\t\tblnd_cfg.global_alpha = pipe_ctx->plane_state->global_alpha_value;\n\telse\n\t\tblnd_cfg.global_alpha = 0xff;\n\n\tblnd_cfg.global_gain = 0xff;\n\tblnd_cfg.background_color_bpc = 4;\n\tblnd_cfg.bottom_gain_mode = 0;\n\tblnd_cfg.top_gain = 0x1f000;\n\tblnd_cfg.bottom_inside_gain = 0x1f000;\n\tblnd_cfg.bottom_outside_gain = 0x1f000;\n\t \n\tblnd_cfg.black_color.color_b_cb = 0;\n\tblnd_cfg.black_color.color_g_y = 0;\n\tblnd_cfg.black_color.color_r_cr = 0;\n\n\t \n\tblnd_cfg.pre_multiplied_alpha = per_pixel_alpha;\n\n\t \n\tdpp_id = hubp->inst;\n\tmpcc_id = dpp_id;\n\n\t \n\tif (!pipe_ctx->plane_state->update_flags.bits.full_update) {\n\t\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\t\tmpc->funcs->update_blending(mpc, &blnd_cfg, mpcc_id);\n\t\treturn;\n\t}\n\n\t \n\tif (mpc->funcs->get_mpcc_for_dpp_from_secondary)\n\t\tremove_mpcc = mpc->funcs->get_mpcc_for_dpp_from_secondary(mpc_tree_params, dpp_id);\n\n\t \n\tif (remove_mpcc != NULL && mpc->funcs->remove_mpcc_from_secondary)\n\t\tmpc->funcs->remove_mpcc_from_secondary(mpc, mpc_tree_params, remove_mpcc);\n\n\t \n\tremove_mpcc = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);\n\t \n\n\tif (remove_mpcc != NULL)\n\t\tmpc->funcs->remove_mpcc(mpc, mpc_tree_params, remove_mpcc);\n\telse\n\t\tif (dc->debug.sanity_checks)\n\t\t\tmpc->funcs->assert_mpcc_idle_before_connect(\n\t\t\t\t\tdc->res_pool->mpc, mpcc_id);\n\n\t \n\tdc->hwss.update_visual_confirm_color(dc, pipe_ctx, mpcc_id);\n\tnew_mpcc = mpc->funcs->insert_plane(dc->res_pool->mpc,\n\t\t\tmpc_tree_params,\n\t\t\t&blnd_cfg,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tdpp_id,\n\t\t\tmpcc_id);\n\n\tASSERT(new_mpcc != NULL);\n\thubp->opp_id = pipe_ctx->stream_res.opp->inst;\n\thubp->mpcc_id = mpcc_id;\n}\n\nvoid dcn201_pipe_control_lock(\n\tstruct dc *dc,\n\tstruct pipe_ctx *pipe,\n\tbool lock)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\t \n\tif (pipe->top_pipe)\n\t\treturn;\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n\n\tif (pipe->plane_state != NULL && pipe->plane_state->triplebuffer_flips) {\n\t\tif (lock)\n\t\t\tpipe->stream_res.tg->funcs->triplebuffer_lock(pipe->stream_res.tg);\n\t\telse\n\t\t\tpipe->stream_res.tg->funcs->triplebuffer_unlock(pipe->stream_res.tg);\n\t} else {\n\t\tif (lock)\n\t\t\tpipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);\n\t\telse\n\t\t\tpipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);\n\t}\n\n\tif (dc->debug.sanity_checks)\n\t\thws->funcs.verify_allow_pstate_change_high(dc);\n}\n\nvoid dcn201_set_cursor_attribute(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;\n\n\tgpu_addr_to_uma(pipe_ctx->stream->ctx->dc->hwseq, &attributes->address);\n\n\tpipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(\n\t\t\tpipe_ctx->plane_res.hubp, attributes);\n\tpipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(\n\t\tpipe_ctx->plane_res.dpp, attributes);\n}\n\nvoid dcn201_set_dmdata_attributes(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_dmdata_attributes attr = { 0 };\n\tstruct hubp *hubp = pipe_ctx->plane_res.hubp;\n\n\tgpu_addr_to_uma(pipe_ctx->stream->ctx->dc->hwseq,\n\t\t\t&pipe_ctx->stream->dmdata_address);\n\n\tattr.dmdata_mode = DMDATA_HW_MODE;\n\tattr.dmdata_size =\n\t\tdc_is_hdmi_signal(pipe_ctx->stream->signal) ? 32 : 36;\n\tattr.address.quad_part =\n\t\t\tpipe_ctx->stream->dmdata_address.quad_part;\n\tattr.dmdata_dl_delta = 0;\n\tattr.dmdata_qos_mode = 0;\n\tattr.dmdata_qos_level = 0;\n\tattr.dmdata_repeat = 1;  \n\tattr.dmdata_updated = 1;\n\tattr.dmdata_sw_data = NULL;\n\n\thubp->funcs->dmdata_set_attributes(hubp, &attr);\n}\n\nvoid dcn201_unblank_stream(struct pipe_ctx *pipe_ctx,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tstruct encoder_unblank_param params = { { 0 } };\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\n\t \n\tparams.timing = pipe_ctx->stream->timing;\n\n\tparams.link_settings.link_rate = link_settings->link_rate;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\t \n\t\tif (optc201_is_two_pixels_per_containter(&stream->timing))\n\t\t\tparams.timing.pix_clk_100hz /= 2;\n\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_unblank(link, pipe_ctx->stream_res.stream_enc, &params);\n\t}\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\thws->funcs.edp_backlight_control(link, true);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}