{
  "module_name": "dcn32_hwseq.c",
  "hash_id": "512406b076ddf911f0cfc2dff355b108939015d85533eb0853b9923eca00a163",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn32/dcn32_hwseq.c",
  "human_readable_source": " \n\n\n#include \"dm_services.h\"\n#include \"dm_helpers.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dccg.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dcn30/dcn30_cm_common.h\"\n#include \"reg_helper.h\"\n#include \"abm.h\"\n#include \"hubp.h\"\n#include \"dchubbub.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"mcif_wb.h\"\n#include \"dc_dmub_srv.h\"\n#include \"link_hwss.h\"\n#include \"dpcd_defs.h\"\n#include \"dcn32_hwseq.h\"\n#include \"clk_mgr.h\"\n#include \"dsc.h\"\n#include \"dcn20/dcn20_optc.h\"\n#include \"dce/dmub_hw_lock_mgr.h\"\n#include \"dcn32_resource.h\"\n#include \"link.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nvoid dcn32_dsc_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dsc_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\treturn;\n\n\tif (!hws->ctx->dc->debug.enable_double_buffered_dsc_pg_support)\n\t\treturn;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\tswitch (dsc_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN16_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN16_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN17_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN17_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN18_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN18_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN19_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN19_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\n\nvoid dcn32_enable_power_gating_plane(\n\tstruct dce_hwseq *hws,\n\tbool enable)\n{\n\tbool force_on = true;  \n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (enable)\n\t\tforce_on = false;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\t \n\tREG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\t \n\tREG_UPDATE(DOMAIN16_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN17_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN18_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN19_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\nvoid dcn32_hubp_pg_control(struct dce_hwseq *hws, unsigned int hubp_inst, bool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\n\tif (hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\treturn;\n\n\tif (REG(DOMAIN0_PG_CONFIG) == 0)\n\t\treturn;\n\n\tswitch (hubp_inst) {\n\tcase 0:\n\t\tREG_SET(DOMAIN0_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN0_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 1:\n\t\tREG_SET(DOMAIN1_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN1_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 2:\n\t\tREG_SET(DOMAIN2_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN2_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 3:\n\t\tREG_SET(DOMAIN3_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN3_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n}\n\nstatic bool dcn32_check_no_memory_request_for_cab(struct dc *dc)\n{\n\tint i;\n\n     \n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tif ((dc->current_state->stream_status[i].plane_count) &&\n\t\t\t(dc->current_state->streams[i]->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED))\n\t\t\t \n\t\t\tbreak;\n\t}\n\n\tif (i == dc->current_state->stream_count)\n\t\treturn true;\n\n\treturn false;\n}\n\n\n \nstatic uint32_t dcn32_calculate_cab_allocation(struct dc *dc, struct dc_state *ctx)\n{\n\tint i;\n\tuint32_t num_ways = 0;\n\tuint32_t mall_ss_size_bytes = 0;\n\n\tmall_ss_size_bytes = ctx->bw_ctx.bw.dcn.mall_ss_size_bytes;\n\t\n\t\n\n\t\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &ctx->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe->stream || !pipe->plane_state)\n\t\t\tcontinue;\n\n\t\tmall_ss_size_bytes += dcn32_helper_calculate_mall_bytes_for_cursor(dc, pipe, false);\n\t}\n\n\t\n\tif (dc->debug.force_mall_ss_num_ways > 0) {\n\t\tnum_ways = dc->debug.force_mall_ss_num_ways;\n\t} else {\n\t\tnum_ways = dcn32_helper_mall_bytes_to_ways(dc, mall_ss_size_bytes);\n\t}\n\n\treturn num_ways;\n}\n\nbool dcn32_apply_idle_power_optimizations(struct dc *dc, bool enable)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint8_t i;\n\tuint32_t ways;\n\tint j;\n\tbool mall_ss_unsupported = false;\n\tstruct dc_plane_state *plane = NULL;\n\n\tif (!dc->ctx->dmub_srv)\n\t\treturn false;\n\n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\t \n\t\tif (dc->current_state->streams[i] != NULL &&\n\t\t\t\tdc->current_state->streams[i]->link->psr_settings.psr_version != DC_PSR_VERSION_UNSUPPORTED)\n\t\t\treturn false;\n\t}\n\n\tif (enable) {\n\t\tif (dc->current_state) {\n\n\t\t\t \n\t\t\tif (dcn32_check_no_memory_request_for_cab(dc)) {\n\t\t\t\t \n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.cab.header.type = DMUB_CMD__CAB_FOR_SS;\n\t\t\t\tcmd.cab.header.sub_type = DMUB_CMD__CAB_NO_DCN_REQ;\n\t\t\t\tcmd.cab.header.payload_bytes = sizeof(cmd.cab) - sizeof(cmd.cab.header);\n\n\t\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t \n\t\t\tways = dcn32_calculate_cab_allocation(dc, dc->current_state);\n\n\t\t\t \n\t\t\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\t\t\tfor (j = 0; j < dc->current_state->stream_status[i].plane_count; j++) {\n\t\t\t\t\tplane = dc->current_state->stream_status[i].plane_states[j];\n\n\t\t\t\t\tif (plane->address.type == PLN_ADDR_TYPE_GRPH_STEREO ||\n\t\t\t\t\t\t\tplane->address.tmz_surface) {\n\t\t\t\t\t\tmall_ss_unsupported = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mall_ss_unsupported)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ways <= dc->caps.cache_num_ways && !mall_ss_unsupported) {\n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.cab.header.type = DMUB_CMD__CAB_FOR_SS;\n\t\t\t\tcmd.cab.header.sub_type = DMUB_CMD__CAB_DCN_SS_FIT_IN_CAB;\n\t\t\t\tcmd.cab.header.payload_bytes = sizeof(cmd.cab) - sizeof(cmd.cab.header);\n\t\t\t\tcmd.cab.cab_alloc_ways = (uint8_t)ways;\n\n\t\t\t\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cab.header.type = DMUB_CMD__CAB_FOR_SS;\n\tcmd.cab.header.sub_type = DMUB_CMD__CAB_NO_IDLE_OPTIMIZATION;\n\tcmd.cab.header.payload_bytes =\n\t\t\tsizeof(cmd.cab) - sizeof(cmd.cab.header);\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n \nvoid dcn32_commit_subvp_config(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tbool enable_subvp = false;\n\n\tif (!dc->ctx || !dc->ctx->dmub_srv)\n\t\treturn;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream && pipe_ctx->stream->mall_stream_config.paired_stream &&\n\t\t\t\tpipe_ctx->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t\n\t\t\tenable_subvp = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdc_dmub_setup_subvp_dmub_command(dc, context, enable_subvp);\n}\n\n \nvoid dcn32_subvp_pipe_control_lock(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tbool lock,\n\t\tbool should_lock_all_pipes,\n\t\tstruct pipe_ctx *top_pipe_to_program,\n\t\tbool subvp_prev_use)\n{\n\tunsigned int i = 0;\n\tbool subvp_immediate_flip = false;\n\tbool subvp_in_use = false;\n\tstruct pipe_ctx *pipe;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->plane_state && pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\tsubvp_in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (top_pipe_to_program && top_pipe_to_program->stream && top_pipe_to_program->plane_state) {\n\t\tif (top_pipe_to_program->stream->mall_stream_config.type == SUBVP_MAIN &&\n\t\t\t\ttop_pipe_to_program->plane_state->flip_immediate)\n\t\t\tsubvp_immediate_flip = true;\n\t}\n\n\t\n\tif ((subvp_in_use && (should_lock_all_pipes || subvp_immediate_flip)) || (!subvp_in_use && subvp_prev_use)) {\n\t\tunion dmub_inbox0_cmd_lock_hw hw_lock_cmd = { 0 };\n\n\t\tif (!lock) {\n\t\t\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\t\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\t\t\t\tif (pipe->stream && pipe->plane_state && pipe->stream->mall_stream_config.type == SUBVP_MAIN &&\n\t\t\t\t\t\tshould_lock_all_pipes)\n\t\t\t\t\tpipe->stream_res.tg->funcs->wait_for_state(pipe->stream_res.tg, CRTC_STATE_VBLANK);\n\t\t\t}\n\t\t}\n\n\t\thw_lock_cmd.bits.command_code = DMUB_INBOX0_CMD__HW_LOCK;\n\t\thw_lock_cmd.bits.hw_lock_client = HW_LOCK_CLIENT_DRIVER;\n\t\thw_lock_cmd.bits.lock = lock;\n\t\thw_lock_cmd.bits.should_release = !lock;\n\t\tdmub_hw_lock_mgr_inbox0_cmd(dc->ctx->dmub_srv, hw_lock_cmd);\n\t}\n}\n\nvoid dcn32_subvp_pipe_control_lock_fast(union block_sequence_params *params)\n{\n\tstruct dc *dc = params->subvp_pipe_control_lock_fast_params.dc;\n\tbool lock = params->subvp_pipe_control_lock_fast_params.lock;\n\tstruct pipe_ctx *pipe_ctx = params->subvp_pipe_control_lock_fast_params.pipe_ctx;\n\tbool subvp_immediate_flip = false;\n\n\tif (pipe_ctx && pipe_ctx->stream && pipe_ctx->plane_state) {\n\t\tif (pipe_ctx->stream->mall_stream_config.type == SUBVP_MAIN &&\n\t\t\t\tpipe_ctx->plane_state->flip_immediate)\n\t\t\tsubvp_immediate_flip = true;\n\t}\n\n\t\n\tif (subvp_immediate_flip) {\n\t\tunion dmub_inbox0_cmd_lock_hw hw_lock_cmd = { 0 };\n\n\t\thw_lock_cmd.bits.command_code = DMUB_INBOX0_CMD__HW_LOCK;\n\t\thw_lock_cmd.bits.hw_lock_client = HW_LOCK_CLIENT_DRIVER;\n\t\thw_lock_cmd.bits.lock = lock;\n\t\thw_lock_cmd.bits.should_release = !lock;\n\t\tdmub_hw_lock_mgr_inbox0_cmd(dc->ctx->dmub_srv, hw_lock_cmd);\n\t}\n}\n\nbool dcn32_set_mpc_shaper_3dlut(\n\tstruct pipe_ctx *pipe_ctx, const struct dc_stream_state *stream)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tbool result = false;\n\n\tconst struct pwl_params *shaper_lut = NULL;\n\t\n\tif (stream->func_shaper) {\n\t\tif (stream->func_shaper->type == TF_TYPE_HWPWL)\n\t\t\tshaper_lut = &stream->func_shaper->pwl;\n\t\telse if (stream->func_shaper->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm_helper_translate_curve_to_hw_format(stream->ctx,\n\t\t\t\t\tstream->func_shaper,\n\t\t\t\t\t&dpp_base->shaper_params, true);\n\t\t\tshaper_lut = &dpp_base->shaper_params;\n\t\t}\n\t}\n\n\tif (stream->lut3d_func &&\n\t\tstream->lut3d_func->state.bits.initialized == 1) {\n\n\t\tresult = mpc->funcs->program_3dlut(mpc,\n\t\t\t\t\t\t\t\t&stream->lut3d_func->lut_3d,\n\t\t\t\t\t\t\t\tmpcc_id);\n\n\t\tresult = mpc->funcs->program_shaper(mpc,\n\t\t\t\t\t\t\t\tshaper_lut,\n\t\t\t\t\t\t\t\tmpcc_id);\n\t}\n\n\treturn result;\n}\n\nbool dcn32_set_mcm_luts(\n\tstruct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)\n{\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tbool result = true;\n\tstruct pwl_params *lut_params = NULL;\n\n\t\n\tif (plane_state->blend_tf) {\n\t\tif (plane_state->blend_tf->type == TF_TYPE_HWPWL)\n\t\t\tlut_params = &plane_state->blend_tf->pwl;\n\t\telse if (plane_state->blend_tf->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\tcm3_helper_translate_curve_to_hw_format(plane_state->blend_tf,\n\t\t\t\t\t&dpp_base->regamma_params, false);\n\t\t\tlut_params = &dpp_base->regamma_params;\n\t\t}\n\t}\n\tresult = mpc->funcs->program_1dlut(mpc, lut_params, mpcc_id);\n\n\t\n\tif (plane_state->in_shaper_func) {\n\t\tif (plane_state->in_shaper_func->type == TF_TYPE_HWPWL)\n\t\t\tlut_params = &plane_state->in_shaper_func->pwl;\n\t\telse if (plane_state->in_shaper_func->type == TF_TYPE_DISTRIBUTED_POINTS) {\n\t\t\t\n\t\t\tASSERT(false);\n\t\t\tcm3_helper_translate_curve_to_hw_format(plane_state->in_shaper_func,\n\t\t\t\t\t&dpp_base->shaper_params, true);\n\t\t\tlut_params = &dpp_base->shaper_params;\n\t\t}\n\t}\n\n\tresult = mpc->funcs->program_shaper(mpc, lut_params, mpcc_id);\n\n\t\n\tif (plane_state->lut3d_func && plane_state->lut3d_func->state.bits.initialized == 1)\n\t\tresult = mpc->funcs->program_3dlut(mpc, &plane_state->lut3d_func->lut_3d, mpcc_id);\n\telse\n\t\tresult = mpc->funcs->program_3dlut(mpc, NULL, mpcc_id);\n\n\treturn result;\n}\n\nbool dcn32_set_input_transfer_func(struct dc *dc,\n\t\t\t\tstruct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_plane_state *plane_state)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tstruct dpp *dpp_base = pipe_ctx->plane_res.dpp;\n\n\tenum dc_transfer_func_predefined tf;\n\tbool result = true;\n\tstruct pwl_params *params = NULL;\n\n\tif (mpc == NULL || plane_state == NULL)\n\t\treturn false;\n\n\ttf = TRANSFER_FUNCTION_UNITY;\n\n\tif (plane_state->in_transfer_func &&\n\t\tplane_state->in_transfer_func->type == TF_TYPE_PREDEFINED)\n\t\ttf = plane_state->in_transfer_func->tf;\n\n\tdpp_base->funcs->dpp_set_pre_degam(dpp_base, tf);\n\n\tif (plane_state->in_transfer_func) {\n\t\tif (plane_state->in_transfer_func->type == TF_TYPE_HWPWL)\n\t\t\tparams = &plane_state->in_transfer_func->pwl;\n\t\telse if (plane_state->in_transfer_func->type == TF_TYPE_DISTRIBUTED_POINTS &&\n\t\t\tcm3_helper_translate_curve_to_hw_format(plane_state->in_transfer_func,\n\t\t\t\t\t&dpp_base->degamma_params, false))\n\t\t\tparams = &dpp_base->degamma_params;\n\t}\n\n\tdpp_base->funcs->dpp_program_gamcor_lut(dpp_base, params);\n\n\tif (pipe_ctx->stream_res.opp &&\n\t\t\tpipe_ctx->stream_res.opp->ctx &&\n\t\t\thws->funcs.set_mcm_luts)\n\t\tresult = hws->funcs.set_mcm_luts(pipe_ctx, plane_state);\n\n\treturn result;\n}\n\nbool dcn32_set_output_transfer_func(struct dc *dc,\n\t\t\t\tstruct pipe_ctx *pipe_ctx,\n\t\t\t\tconst struct dc_stream_state *stream)\n{\n\tint mpcc_id = pipe_ctx->plane_res.hubp->inst;\n\tstruct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;\n\tstruct pwl_params *params = NULL;\n\tbool ret = false;\n\n\t \n\tif (resource_is_pipe_type(pipe_ctx, OPP_HEAD)) {\n\t\t \n\t\tret = dcn32_set_mpc_shaper_3dlut(pipe_ctx, stream);\n\t\tif (ret == false && mpc->funcs->set_output_gamma && stream->out_transfer_func) {\n\t\t\tif (stream->out_transfer_func->type == TF_TYPE_HWPWL)\n\t\t\t\tparams = &stream->out_transfer_func->pwl;\n\t\t\telse if (pipe_ctx->stream->out_transfer_func->type ==\n\t\t\t\t\tTF_TYPE_DISTRIBUTED_POINTS &&\n\t\t\t\t\tcm3_helper_translate_curve_to_hw_format(\n\t\t\t\t\tstream->out_transfer_func,\n\t\t\t\t\t&mpc->blender_params, false))\n\t\t\t\tparams = &mpc->blender_params;\n\t\t\t \n\t\t\tif (stream->out_transfer_func->type == TF_TYPE_PREDEFINED)\n\t\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t}\n\n\tmpc->funcs->set_output_gamma(mpc, mpcc_id, params);\n\treturn ret;\n}\n\n \nvoid dcn32_update_force_pstate(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\n\t\tif (!pipe->stream || !(pipe->stream->mall_stream_config.type == SUBVP_MAIN ||\n\t\t    pipe->stream->fpo_in_use)) {\n\t\t\tif (hubp && hubp->funcs->hubp_update_force_pstate_disallow)\n\t\t\t\thubp->funcs->hubp_update_force_pstate_disallow(hubp, false);\n\t\t}\n\n\t\t \n\t\tif (!pipe->stream || !pipe->stream->fpo_in_use) {\n\t\t\tif (hubp && hubp->funcs->hubp_update_force_cursor_pstate_disallow)\n\t\t\t\thubp->funcs->hubp_update_force_cursor_pstate_disallow(hubp, false);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\n\t\tif (pipe->stream && pipe->plane_state && pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\tif (hubp && hubp->funcs->hubp_update_force_pstate_disallow)\n\t\t\t\thubp->funcs->hubp_update_force_pstate_disallow(hubp, true);\n\t\t}\n\n\t\tif (pipe->stream && pipe->stream->fpo_in_use) {\n\t\t\tif (hubp && hubp->funcs->hubp_update_force_pstate_disallow)\n\t\t\t\thubp->funcs->hubp_update_force_pstate_disallow(hubp, true);\n\t\t\t \n\t\t\tif (hubp && hubp->funcs->hubp_update_force_cursor_pstate_disallow)\n\t\t\t\thubp->funcs->hubp_update_force_cursor_pstate_disallow(hubp, true);\n\t\t}\n\t}\n}\n\n \nvoid dcn32_update_mall_sel(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tunsigned int num_ways = dcn32_calculate_cab_allocation(dc, context);\n\tbool cache_cursor = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\n\t\tif (pipe->stream && pipe->plane_state && hubp && hubp->funcs->hubp_update_mall_sel) {\n\t\t\tint cursor_size = hubp->curs_attr.pitch * hubp->curs_attr.height;\n\n\t\t\tswitch (hubp->curs_attr.color_format) {\n\t\t\tcase CURSOR_MODE_MONO:\n\t\t\t\tcursor_size /= 2;\n\t\t\t\tbreak;\n\t\t\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\t\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\t\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\t\t\tcursor_size *= 4;\n\t\t\t\tbreak;\n\n\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\t\tdefault:\n\t\t\t\tcursor_size *= 8;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cursor_size > 16384)\n\t\t\t\tcache_cursor = true;\n\n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\t\thubp->funcs->hubp_update_mall_sel(hubp, 1, false);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\thubp->funcs->hubp_update_mall_sel(hubp,\n\t\t\t\t\tnum_ways <= dc->caps.cache_num_ways &&\n\t\t\t\t\tpipe->stream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED &&\n\t\t\t\t\tpipe->plane_state->address.type !=  PLN_ADDR_TYPE_GRPH_STEREO &&\n\t\t\t\t\t!pipe->plane_state->address.tmz_surface ? 2 : 0,\n\t\t\t\t\t\t\tcache_cursor);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid dcn32_program_mall_pipe_config(struct dc *dc, struct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t\n\n\t\n\tif (hws && hws->funcs.update_mall_sel)\n\t\thws->funcs.update_mall_sel(dc, context);\n\n\t\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\n\t\tif (pipe->stream && hubp && hubp->funcs->hubp_prepare_subvp_buffering) {\n\t\t\t \n\t\t\tif (pipe->stream->mall_stream_config.type == SUBVP_MAIN) {\n\t\t\t\thubp->funcs->hubp_prepare_subvp_buffering(hubp, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dcn32_initialize_min_clocks(struct dc *dc)\n{\n\tstruct dc_clocks *clocks = &dc->current_state->bw_ctx.bw.dcn.clk;\n\n\tclocks->dcfclk_deep_sleep_khz = DCN3_2_DCFCLK_DS_INIT_KHZ;\n\tclocks->dcfclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].dcfclk_mhz * 1000;\n\tclocks->socclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].socclk_mhz * 1000;\n\tclocks->dramclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].memclk_mhz * 1000;\n\tclocks->dppclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].dppclk_mhz * 1000;\n\tclocks->ref_dtbclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].dtbclk_mhz * 1000;\n\tclocks->fclk_p_state_change_support = true;\n\tclocks->p_state_change_support = true;\n\tif (dc->debug.disable_boot_optimizations) {\n\t\tclocks->dispclk_khz = dc->clk_mgr->bw_params->clk_table.entries[0].dispclk_mhz * 1000;\n\t} else {\n\t\t \n\t\tclocks->dispclk_khz = dc->clk_mgr->funcs->get_dispclk_from_dentist(dc->clk_mgr);\n\t}\n\n\tdc->clk_mgr->funcs->update_clocks(\n\t\t\tdc->clk_mgr,\n\t\t\tdc->current_state,\n\t\t\ttrue);\n}\n\nvoid dcn32_init_hw(struct dc *dc)\n{\n\tstruct abm **abms = dc->res_pool->multiple_abms;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tint i;\n\tint edp_num;\n\tuint32_t backlight = MAX_BACKLIGHT_LEVEL;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\t\n\tif (res_pool->dccg->funcs->dccg_init)\n\t\tres_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb)) {\n\t\thws->funcs.bios_golden_init(dc);\n\t\thws->funcs.disable_vga(dc->hwseq);\n\t}\n\n\t\n\tif (dc->debug.enable_mem_low_power.bits.optc) {\n\t\t\n\t\tREG_SET_2(ODM_MEM_PWR_CTRL3, 0, ODM_MEM_UNASSIGNED_PWR_MODE, 3, ODM_MEM_VBLANK_PWR_MODE, 1);\n\t}\n\n\tif (dc->debug.enable_mem_low_power.bits.vga) {\n\t\t\n\t\tREG_UPDATE(MMHUBBUB_MEM_PWR_CNTL, VGA_MEM_PWR_FORCE, 1);\n\t}\n\n\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\n\t\tif (res_pool->dccg && res_pool->hubbub) {\n\t\t\t(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,\n\t\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,\n\t\t\t\t\t&res_pool->ref_clocks.dccg_ref_clock_inKhz);\n\n\t\t\t(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,\n\t\t\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz,\n\t\t\t\t\t&res_pool->ref_clocks.dchub_ref_clock_inKhz);\n\t\t} else {\n\t\t\t\n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t}\n\t} else\n\t\tASSERT_CRITICAL(false);\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tlink->link_status.link_active = true;\n\t\t\tlink->phy_state.symclk_state = SYMCLK_ON_TX_ON;\n\t\t\tif (link->link_enc->funcs->fec_is_active &&\n\t\t\t\t\tlink->link_enc->funcs->fec_is_active(link->link_enc))\n\t\t\t\tlink->fec_state = dc_link_fec_enabled;\n\t\t}\n\t}\n\n\t \n\tif (hws->funcs.enable_power_gating_plane)\n\t\thws->funcs.enable_power_gating_plane(dc->hwseq, true);\n\n\t \n\tdc->link_srv->blank_all_dp_displays(dc);\n\n\t \n\tif (dcb->funcs->is_accelerated_mode(dcb) || !dc->config.seamless_boot_edp_requested) {\n\t\t \n\t\tif (dc->hwss.enable_accelerated_mode && dc->debug.disable_boot_optimizations)\n\t\t\tdc->hwss.enable_accelerated_mode(dc, dc->current_state);\n\t\telse\n\t\t\thws->funcs.init_pipes(dc, dc->current_state);\n\n\t\tif (dc->res_pool->hubbub->funcs->allow_self_refresh_control)\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,\n\t\t\t\t\t!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);\n\n\t\tdcn32_initialize_min_clocks(dc);\n\n\t\t \n\t\tdc_allow_idle_optimizations(dc, false);\n\t\tdc_allow_idle_optimizations(dc, true);\n\t}\n\n\t \n\tif (!dc->config.seamless_boot_edp_requested) {\n\t\tstruct dc_link *edp_links[MAX_NUM_EDP];\n\t\tstruct dc_link *edp_link;\n\n\t\tdc_get_edp_links(dc, edp_links, &edp_num);\n\t\tif (edp_num) {\n\t\t\tfor (i = 0; i < edp_num; i++) {\n\t\t\t\tedp_link = edp_links[i];\n\t\t\t\tif (edp_link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\t\t\tedp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc) &&\n\t\t\t\t\t\tdc->hwss.edp_backlight_control &&\n\t\t\t\t\t\tdc->hwss.power_down &&\n\t\t\t\t\t\tdc->hwss.edp_power_control) {\n\t\t\t\t\tdc->hwss.edp_backlight_control(edp_link, false);\n\t\t\t\t\tdc->hwss.power_down(dc);\n\t\t\t\t\tdc->hwss.edp_power_control(edp_link, false);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < dc->link_count; i++) {\n\t\t\t\tstruct dc_link *link = dc->links[i];\n\n\t\t\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc) &&\n\t\t\t\t\t\tdc->hwss.power_down) {\n\t\t\t\t\tdc->hwss.power_down(dc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < res_pool->audio_count; i++) {\n\t\tstruct audio *audio = res_pool->audios[i];\n\n\t\taudio->funcs->hw_init(audio);\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (link->panel_cntl)\n\t\t\tbacklight = link->panel_cntl->funcs->hw_init(link->panel_cntl);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (abms[i] != NULL && abms[i]->funcs != NULL)\n\t\t\tabms[i]->funcs->abm_init(abms[i], backlight);\n\t}\n\n\t \n\tREG_WRITE(DIO_MEM_PWR_CTRL, 0);\n\n\tif (!dc->debug.disable_clock_gate) {\n\t\t \n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);\n\n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);\n\n\t\tREG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);\n\t}\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb) && dc->res_pool->hubbub->funcs->init_watermarks)\n\t\tdc->res_pool->hubbub->funcs->init_watermarks(dc->res_pool->hubbub);\n\n\tif (dc->clk_mgr->funcs->notify_wm_ranges)\n\t\tdc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);\n\n\tif (dc->clk_mgr->funcs->set_hard_max_memclk && !dc->clk_mgr->dc_mode_softmax_enabled)\n\t\tdc->clk_mgr->funcs->set_hard_max_memclk(dc->clk_mgr);\n\n\tif (dc->res_pool->hubbub->funcs->force_pstate_change_control)\n\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control(\n\t\t\t\tdc->res_pool->hubbub, false, false);\n\n\tif (dc->res_pool->hubbub->funcs->init_crb)\n\t\tdc->res_pool->hubbub->funcs->init_crb(dc->res_pool->hubbub);\n\n\tif (dc->res_pool->hubbub->funcs->set_request_limit && dc->config.sdpif_request_limit_words_per_umc > 0)\n\t\tdc->res_pool->hubbub->funcs->set_request_limit(dc->res_pool->hubbub, dc->ctx->dc_bios->vram_info.num_chans, dc->config.sdpif_request_limit_words_per_umc);\n\n\t \n\tif (dc->ctx->dmub_srv) {\n\t\tdc_dmub_srv_query_caps_cmd(dc->ctx->dmub_srv);\n\t\tdc->caps.dmub_caps.psr = dc->ctx->dmub_srv->dmub->feature_caps.psr;\n\t\tdc->caps.dmub_caps.subvp_psr = dc->ctx->dmub_srv->dmub->feature_caps.subvp_psr_support;\n\t\tdc->caps.dmub_caps.gecc_enable = dc->ctx->dmub_srv->dmub->feature_caps.gecc_enable;\n\t\tdc->caps.dmub_caps.mclk_sw = dc->ctx->dmub_srv->dmub->feature_caps.fw_assisted_mclk_switch;\n\t}\n}\n\nstatic int calc_mpc_flow_ctrl_cnt(const struct dc_stream_state *stream,\n\t\tint opp_cnt)\n{\n\tbool hblank_halved = optc2_is_two_pixels_per_containter(&stream->timing);\n\tint flow_ctrl_cnt;\n\n\tif (opp_cnt >= 2)\n\t\thblank_halved = true;\n\n\tflow_ctrl_cnt = stream->timing.h_total - stream->timing.h_addressable -\n\t\t\tstream->timing.h_border_left -\n\t\t\tstream->timing.h_border_right;\n\n\tif (hblank_halved)\n\t\tflow_ctrl_cnt /= 2;\n\n\t \n\tif (opp_cnt == 4)\n\t\tflow_ctrl_cnt /= 2;\n\n\treturn flow_ctrl_cnt;\n}\n\nstatic void update_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\n\tASSERT(dsc);\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\topp_cnt++;\n\n\tif (enable) {\n\t\tstruct dsc_config dsc_cfg;\n\t\tstruct dsc_optc_config dsc_optc_cfg;\n\t\tenum optc_dsc_mode optc_dsc_mode;\n\n\t\t \n\t\tdsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right) / opp_cnt;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\t\tASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % opp_cnt == 0);\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;\n\n\t\tdsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\tdsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\t\tstruct display_stream_compressor *odm_dsc = odm_pipe->stream_res.dsc;\n\n\t\t\tASSERT(odm_dsc);\n\t\t\todm_dsc->funcs->dsc_set_config(odm_dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\t\todm_dsc->funcs->dsc_enable(odm_dsc, odm_pipe->stream_res.opp->inst);\n\t\t}\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h *= opp_cnt;\n\t\tdsc_cfg.pic_width *= opp_cnt;\n\n\t\toptc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;\n\n\t\t \n\t\tDC_LOG_DSC(\"Setting optc DSC config for tg instance %d:\", pipe_ctx->stream_res.tg->inst);\n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,\n\t\t\t\t\t\t\toptc_dsc_mode,\n\t\t\t\t\t\t\tdsc_optc_cfg.bytes_per_pixel,\n\t\t\t\t\t\t\tdsc_optc_cfg.slice_width);\n\t} else {\n\t\t \n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\tOPTC_DSC_DISABLED, 0, 0);\n\n\t\t \n\t\tdsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\t\tASSERT(odm_pipe->stream_res.dsc);\n\t\t\todm_pipe->stream_res.dsc->funcs->dsc_disable(odm_pipe->stream_res.dsc);\n\t\t}\n\t}\n}\n\n \nstatic unsigned int get_odm_config(struct pipe_ctx *pipe_ctx, unsigned int *opp_instances)\n{\n\tunsigned int opp_count = 1;\n\tstruct pipe_ctx *odm_pipe;\n\n\t \n\tfor (odm_pipe = pipe_ctx; odm_pipe->prev_odm_pipe; odm_pipe = odm_pipe->prev_odm_pipe)\n\t\t;\n\n\t \n\tif (opp_instances)\n\t\topp_instances[0] = odm_pipe->stream_res.opp->inst;\n\n\t \n\tfor (odm_pipe = odm_pipe->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\tif (opp_instances)\n\t\t\topp_instances[opp_count] = odm_pipe->stream_res.opp->inst;\n\t\topp_count++;\n\t}\n\n\treturn opp_count;\n}\n\nvoid dcn32_update_odm(struct dc *dc, struct dc_state *context, struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 0;\n\tint opp_inst[MAX_PIPES] = {0};\n\tbool rate_control_2x_pclk = (pipe_ctx->stream->timing.flags.INTERLACE || optc2_is_two_pixels_per_containter(&pipe_ctx->stream->timing));\n\tstruct mpc_dwb_flow_control flow_control;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tint i;\n\n\topp_cnt = get_odm_config(pipe_ctx, opp_inst);\n\n\tif (opp_cnt > 1)\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\topp_inst, opp_cnt,\n\t\t\t\t&pipe_ctx->stream->timing);\n\telse\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_bypass(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);\n\n\trate_control_2x_pclk = rate_control_2x_pclk || opp_cnt > 1;\n\tflow_control.flow_ctrl_mode = 0;\n\tflow_control.flow_ctrl_cnt0 = 0x80;\n\tflow_control.flow_ctrl_cnt1 = calc_mpc_flow_ctrl_cnt(pipe_ctx->stream, opp_cnt);\n\tif (mpc->funcs->set_out_rate_control) {\n\t\tfor (i = 0; i < opp_cnt; ++i) {\n\t\t\tmpc->funcs->set_out_rate_control(\n\t\t\t\t\tmpc, opp_inst[i],\n\t\t\t\t\ttrue,\n\t\t\t\t\trate_control_2x_pclk,\n\t\t\t\t\t&flow_control);\n\t\t}\n\t}\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\todm_pipe->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\t\todm_pipe->stream_res.opp,\n\t\t\t\ttrue);\n\t}\n\n\tif (pipe_ctx->stream_res.dsc) {\n\t\tstruct pipe_ctx *current_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];\n\n\t\tupdate_dsc_on_stream(pipe_ctx, pipe_ctx->stream->timing.flags.DSC);\n\n\t\t \n\t\tif (!pipe_ctx->next_odm_pipe && current_pipe_ctx->next_odm_pipe &&\n\t\t\t\tcurrent_pipe_ctx->next_odm_pipe->stream_res.dsc) {\n\t\t\tstruct display_stream_compressor *dsc = current_pipe_ctx->next_odm_pipe->stream_res.dsc;\n\t\t\t \n\t\t\tdsc->funcs->dsc_disconnect(dsc);\n\t\t}\n\t}\n}\n\nunsigned int dcn32_calculate_dccg_k1_k2_values(struct pipe_ctx *pipe_ctx, unsigned int *k1_div, unsigned int *k2_div)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tunsigned int odm_combine_factor = 0;\n\tbool two_pix_per_container = false;\n\n\ttwo_pix_per_container = optc2_is_two_pixels_per_containter(&stream->timing);\n\todm_combine_factor = get_odm_config(pipe_ctx, NULL);\n\n\tif (stream->ctx->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t*k2_div = PIXEL_RATE_DIV_BY_1;\n\t} else if (dc_is_hdmi_tmds_signal(stream->signal) || dc_is_dvi_signal(stream->signal)) {\n\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\telse\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_4;\n\t} else if (dc_is_dp_signal(stream->signal) || dc_is_virtual_signal(stream->signal)) {\n\t\tif (two_pix_per_container) {\n\t\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\t} else {\n\t\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_4;\n\t\t\tif ((odm_combine_factor == 2) || dcn32_is_dp_dig_pixel_rate_div_policy(pipe_ctx))\n\t\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\t}\n\t}\n\n\tif ((*k1_div == PIXEL_RATE_DIV_NA) && (*k2_div == PIXEL_RATE_DIV_NA))\n\t\tASSERT(false);\n\n\treturn odm_combine_factor;\n}\n\nvoid dcn32_set_pixels_per_cycle(struct pipe_ctx *pipe_ctx)\n{\n\tuint32_t pix_per_cycle = 1;\n\tuint32_t odm_combine_factor = 1;\n\n\tif (!pipe_ctx || !pipe_ctx->stream || !pipe_ctx->stream_res.stream_enc)\n\t\treturn;\n\n\todm_combine_factor = get_odm_config(pipe_ctx, NULL);\n\tif (optc2_is_two_pixels_per_containter(&pipe_ctx->stream->timing) || odm_combine_factor > 1\n\t\t|| dcn32_is_dp_dig_pixel_rate_div_policy(pipe_ctx))\n\t\tpix_per_cycle = 2;\n\n\tif (pipe_ctx->stream_res.stream_enc->funcs->set_input_mode)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->set_input_mode(pipe_ctx->stream_res.stream_enc,\n\t\t\t\tpix_per_cycle);\n}\n\nvoid dcn32_resync_fifo_dccg_dio(struct dce_hwseq *hws, struct dc *dc, struct dc_state *context)\n{\n\tunsigned int i;\n\tstruct pipe_ctx *pipe = NULL;\n\tbool otg_disabled[MAX_PIPES] = {false};\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER))\n\t\t\tcontinue;\n\n\t\tif ((pipe->stream->dpms_off || dc_is_virtual_signal(pipe->stream->signal))\n\t\t\t&& pipe->stream->mall_stream_config.type != SUBVP_PHANTOM) {\n\t\t\tpipe->stream_res.tg->funcs->disable_crtc(pipe->stream_res.tg);\n\t\t\treset_sync_context_for_pipe(dc, context, i);\n\t\t\totg_disabled[i] = true;\n\t\t}\n\t}\n\n\thws->ctx->dc->res_pool->dccg->funcs->trigger_dio_fifo_resync(hws->ctx->dc->res_pool->dccg);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (otg_disabled[i])\n\t\t\tpipe->stream_res.tg->funcs->enable_crtc(pipe->stream_res.tg);\n\t}\n}\n\nvoid dcn32_unblank_stream(struct pipe_ctx *pipe_ctx,\n\t\tstruct dc_link_settings *link_settings)\n{\n\tstruct encoder_unblank_param params = {0};\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dce_hwseq *hws = link->dc->hwseq;\n\tstruct pipe_ctx *odm_pipe;\n\tuint32_t pix_per_cycle = 1;\n\n\tparams.opp_cnt = 1;\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\tparams.opp_cnt++;\n\n\t \n\tparams.timing = pipe_ctx->stream->timing;\n\n\tparams.link_settings.link_rate = link_settings->link_rate;\n\n\tif (link->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t \n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->dp_unblank(\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\tpipe_ctx->stream_res.tg->inst);\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal)) {\n\t\tif (optc2_is_two_pixels_per_containter(&stream->timing) || params.opp_cnt > 1\n\t\t\t|| dcn32_is_dp_dig_pixel_rate_div_policy(pipe_ctx)) {\n\t\t\tparams.timing.pix_clk_100hz /= 2;\n\t\t\tpix_per_cycle = 2;\n\t\t}\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.stream_enc, pix_per_cycle > 1);\n\t\tpipe_ctx->stream_res.stream_enc->funcs->dp_unblank(link, pipe_ctx->stream_res.stream_enc, &params);\n\t}\n\n\tif (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP)\n\t\thws->funcs.edp_backlight_control(link, true);\n}\n\nbool dcn32_is_dp_dig_pixel_rate_div_policy(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\n\tif (!is_h_timing_divisible_by_2(pipe_ctx->stream))\n\t\treturn false;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal) && !dc->link_srv->dp_is_128b_132b_signal(pipe_ctx) &&\n\t\tdc->debug.enable_dp_dig_pixel_rate_div_policy)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void apply_symclk_on_tx_off_wa(struct dc_link *link)\n{\n\t \n\n\tstruct dc *dc = link->ctx->dc;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tuint8_t i;\n\n\tif (link->phy_state.symclk_ref_cnts.otg > 0) {\n\t\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tif (resource_is_pipe_type(pipe_ctx, OPP_HEAD) && pipe_ctx->stream->link == link) {\n\t\t\t\tpipe_ctx->clock_source->funcs->program_pix_clk(\n\t\t\t\t\t\tpipe_ctx->clock_source,\n\t\t\t\t\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t\t\t\t\tdc->link_srv->dp_get_encoding_format(\n\t\t\t\t\t\t\t\t&pipe_ctx->link_config.dp_link_settings),\n\t\t\t\t\t\t&pipe_ctx->pll_settings);\n\t\t\t\tlink->phy_state.symclk_state = SYMCLK_ON_TX_OFF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dcn32_disable_link_output(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tstruct dc *dc = link->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\n\tif (signal == SIGNAL_TYPE_EDP &&\n\t\t\tlink->dc->hwss.edp_backlight_control)\n\t\tlink->dc->hwss.edp_backlight_control(link, false);\n\telse if (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->lock_phy(dmcu);\n\n\tlink_hwss->disable_link_output(link, link_res, signal);\n\tlink->phy_state.symclk_state = SYMCLK_OFF_TX_OFF;\n\n\tif (signal == SIGNAL_TYPE_EDP &&\n\t\t\tlink->dc->hwss.edp_backlight_control)\n\t\tlink->dc->hwss.edp_power_control(link, false);\n\telse if (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->unlock_phy(dmcu);\n\n\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_DISABLE_LINK_PHY);\n\n\tapply_symclk_on_tx_off_wa(link);\n}\n\n \nvoid dcn32_update_phantom_vp_position(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct pipe_ctx *phantom_pipe)\n{\n\tuint32_t i;\n\tstruct dc_plane_state *phantom_plane = phantom_pipe->plane_state;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_MAIN &&\n\t\t\t\tpipe->stream->mall_stream_config.paired_stream == phantom_pipe->stream) {\n\t\t\tif (pipe->plane_state && pipe->plane_state->update_flags.bits.position_change) {\n\n\t\t\t\tphantom_plane->src_rect.x = pipe->plane_state->src_rect.x;\n\t\t\t\tphantom_plane->src_rect.y = pipe->plane_state->src_rect.y;\n\t\t\t\tphantom_plane->clip_rect.x = pipe->plane_state->clip_rect.x;\n\t\t\t\tphantom_plane->dst_rect.x = pipe->plane_state->dst_rect.x;\n\t\t\t\tphantom_plane->dst_rect.y = pipe->plane_state->dst_rect.y;\n\n\t\t\t\tphantom_pipe->plane_state->update_flags.bits.position_change = 1;\n\t\t\t\tresource_build_scaling_params(phantom_pipe);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid dcn32_apply_update_flags_for_phantom(struct pipe_ctx *phantom_pipe)\n{\n\tphantom_pipe->update_flags.raw = 0;\n\tif (phantom_pipe->stream && phantom_pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\tif (resource_is_pipe_type(phantom_pipe, DPP_PIPE)) {\n\t\t\tphantom_pipe->update_flags.bits.enable = 1;\n\t\t\tphantom_pipe->update_flags.bits.mpcc = 1;\n\t\t\tphantom_pipe->update_flags.bits.dppclk = 1;\n\t\t\tphantom_pipe->update_flags.bits.hubp_interdependent = 1;\n\t\t\tphantom_pipe->update_flags.bits.hubp_rq_dlg_ttu = 1;\n\t\t\tphantom_pipe->update_flags.bits.gamut_remap = 1;\n\t\t\tphantom_pipe->update_flags.bits.scaler = 1;\n\t\t\tphantom_pipe->update_flags.bits.viewport = 1;\n\t\t\tphantom_pipe->update_flags.bits.det_size = 1;\n\t\t\tif (resource_is_pipe_type(phantom_pipe, OTG_MASTER)) {\n\t\t\t\tphantom_pipe->update_flags.bits.odm = 1;\n\t\t\t\tphantom_pipe->update_flags.bits.global_sync = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool dcn32_dsc_pg_status(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dsc_inst)\n{\n\tuint32_t pwr_status = 0;\n\n\tswitch (dsc_inst) {\n\tcase 0:  \n\t\tREG_GET(DOMAIN16_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, &pwr_status);\n\t\tbreak;\n\tcase 1:  \n\n\t\tREG_GET(DOMAIN17_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, &pwr_status);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_GET(DOMAIN18_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, &pwr_status);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_GET(DOMAIN19_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, &pwr_status);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\treturn pwr_status == 0;\n}\n\nvoid dcn32_update_dsc_pg(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tbool safe_to_disable)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tint i;\n\n\tfor (i = 0; i < dc->res_pool->res_cap->num_dsc; i++) {\n\t\tstruct display_stream_compressor *dsc = dc->res_pool->dscs[i];\n\t\tbool is_dsc_ungated = hws->funcs.dsc_pg_status(hws, dsc->inst);\n\n\t\tif (context->res_ctx.is_dsc_acquired[i]) {\n\t\t\tif (!is_dsc_ungated) {\n\t\t\t\thws->funcs.dsc_pg_control(hws, dsc->inst, true);\n\t\t\t}\n\t\t} else if (safe_to_disable) {\n\t\t\tif (is_dsc_ungated) {\n\t\t\t\thws->funcs.dsc_pg_control(hws, dsc->inst, false);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dcn32_enable_phantom_streams(struct dc *dc, struct dc_state *context)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\t \n\t\tif (pipe->stream && pipe->stream->mall_stream_config.type == SUBVP_PHANTOM &&\n\t\t\t\told_pipe->stream && old_pipe->stream->mall_stream_config.type != SUBVP_PHANTOM) {\n\t\t\told_pipe->stream_res.tg->funcs->wait_for_state(\n\t\t\t\t\told_pipe->stream_res.tg,\n\t\t\t\t\tCRTC_STATE_VBLANK);\n\t\t\told_pipe->stream_res.tg->funcs->wait_for_state(\n\t\t\t\t\told_pipe->stream_res.tg,\n\t\t\t\t\tCRTC_STATE_VACTIVE);\n\t\t}\n\t}\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *new_pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (new_pipe->stream && new_pipe->stream->mall_stream_config.type == SUBVP_PHANTOM) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdc->hwss.apply_ctx_to_hw(dc, context);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid dcn32_init_blank(\n\t\tstruct dc *dc,\n\t\tstruct timing_generator *tg)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\tstruct output_pixel_processor *opp = NULL;\n\tstruct output_pixel_processor *bottom_opp = NULL;\n\tuint32_t num_opps, opp_id_src0, opp_id_src1;\n\tuint32_t otg_active_width, otg_active_height;\n\tuint32_t i;\n\n\t \n\tcolor_space = COLOR_SPACE_SRGB;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\t \n\ttg->funcs->get_otg_active_size(tg,\n\t\t\t&otg_active_width,\n\t\t\t&otg_active_height);\n\n\t \n\ttg->funcs->get_optc_source(tg, &num_opps, &opp_id_src0, &opp_id_src1);\n\n\tif (opp_id_src0 >= dc->res_pool->res_cap->num_opp) {\n\t\tASSERT(false);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {\n\t\tif (dc->res_pool->opps[i] != NULL && dc->res_pool->opps[i]->inst == opp_id_src0) {\n\t\t\topp = dc->res_pool->opps[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (num_opps == 2) {\n\t\totg_active_width = otg_active_width / 2;\n\n\t\tif (opp_id_src1 >= dc->res_pool->res_cap->num_opp) {\n\t\t\tASSERT(false);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {\n\t\t\tif (dc->res_pool->opps[i] != NULL && dc->res_pool->opps[i]->inst == opp_id_src1) {\n\t\t\t\tbottom_opp = dc->res_pool->opps[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opp && opp->funcs->opp_set_disp_pattern_generator)\n\t\topp->funcs->opp_set_disp_pattern_generator(\n\t\t\t\topp,\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t\t&black_color,\n\t\t\t\totg_active_width,\n\t\t\t\totg_active_height,\n\t\t\t\t0);\n\n\tif (num_opps == 2) {\n\t\tif (bottom_opp && bottom_opp->funcs->opp_set_disp_pattern_generator) {\n\t\t\tbottom_opp->funcs->opp_set_disp_pattern_generator(\n\t\t\t\t\tbottom_opp,\n\t\t\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t\t\t&black_color,\n\t\t\t\t\totg_active_width,\n\t\t\t\t\totg_active_height,\n\t\t\t\t\t0);\n\t\t\thws->funcs.wait_for_blank_complete(bottom_opp);\n\t\t}\n\t}\n\n\tif (opp)\n\t\thws->funcs.wait_for_blank_complete(opp);\n}\n\nvoid dcn32_blank_phantom(struct dc *dc,\n\t\tstruct timing_generator *tg,\n\t\tint width,\n\t\tint height)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tenum dc_color_space color_space;\n\tstruct tg_color black_color = {0};\n\tstruct output_pixel_processor *opp = NULL;\n\tuint32_t num_opps, opp_id_src0, opp_id_src1;\n\tuint32_t otg_active_width, otg_active_height;\n\tuint32_t i;\n\n\t \n\tcolor_space = COLOR_SPACE_SRGB;\n\tcolor_space_to_black_color(dc, color_space, &black_color);\n\n\totg_active_width = width;\n\totg_active_height = height;\n\n\t \n\ttg->funcs->get_optc_source(tg, &num_opps, &opp_id_src0, &opp_id_src1);\n\tASSERT(opp_id_src0 < dc->res_pool->res_cap->num_opp);\n\n\tfor (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {\n\t\tif (dc->res_pool->opps[i] != NULL && dc->res_pool->opps[i]->inst == opp_id_src0) {\n\t\t\topp = dc->res_pool->opps[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opp && opp->funcs->opp_set_disp_pattern_generator)\n\t\topp->funcs->opp_set_disp_pattern_generator(\n\t\t\t\topp,\n\t\t\t\tCONTROLLER_DP_TEST_PATTERN_SOLID_COLOR,\n\t\t\t\tCONTROLLER_DP_COLOR_SPACE_UDEFINED,\n\t\t\t\tCOLOR_DEPTH_UNDEFINED,\n\t\t\t\t&black_color,\n\t\t\t\totg_active_width,\n\t\t\t\totg_active_height,\n\t\t\t\t0);\n\n\tif (tg->funcs->is_tg_enabled(tg))\n\t\thws->funcs.wait_for_blank_complete(opp);\n}\n\nbool dcn32_is_pipe_topology_transition_seamless(struct dc *dc,\n\t\tconst struct dc_state *cur_ctx,\n\t\tconst struct dc_state *new_ctx)\n{\n\tint i;\n\tconst struct pipe_ctx *cur_pipe, *new_pipe;\n\tbool is_seamless = true;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tcur_pipe = &cur_ctx->res_ctx.pipe_ctx[i];\n\t\tnew_pipe = &new_ctx->res_ctx.pipe_ctx[i];\n\n\t\tif (resource_is_pipe_type(cur_pipe, FREE_PIPE) ||\n\t\t\t\tresource_is_pipe_type(new_pipe, FREE_PIPE))\n\t\t\t \n\t\t\tcontinue;\n\t\telse if (resource_is_pipe_type(cur_pipe, OTG_MASTER)) {\n\t\t\tif (resource_is_pipe_type(new_pipe, OTG_MASTER))\n\t\t\t\tif (cur_pipe->stream->stream_id == new_pipe->stream->stream_id)\n\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t} else if (resource_is_pipe_type(cur_pipe, OPP_HEAD)) {\n\t\t\tif (resource_is_pipe_type(new_pipe, OPP_HEAD)) {\n\t\t\t\tif (cur_pipe->stream_res.tg == new_pipe->stream_res.tg)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (resource_is_pipe_type(cur_pipe, DPP_PIPE)) {\n\t\t\tif (resource_is_pipe_type(new_pipe, DPP_PIPE)) {\n\t\t\t\tif (cur_pipe->stream_res.opp == new_pipe->stream_res.opp)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tis_seamless = false;\n\t\tbreak;\n\t}\n\n\treturn is_seamless;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}