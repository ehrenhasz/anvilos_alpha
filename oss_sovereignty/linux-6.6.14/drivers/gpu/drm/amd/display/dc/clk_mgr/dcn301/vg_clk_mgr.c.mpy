{
  "module_name": "vg_clk_mgr.c",
  "hash_id": "e6d2ec6665abc4016c1334cf4caa846e69dd0b0427cdf65eba58ff0ebfb7c8d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c",
  "human_readable_source": " \n\n#include \"dccg.h\"\n#include \"clk_mgr_internal.h\"\n\n\n#include \"dce100/dce_clk_mgr.h\"\n\n\n#include \"dcn20/dcn20_clk_mgr.h\"\n\n\n#include \"dml/dcn20/dcn20_fpu.h\"\n\n#include \"vg_clk_mgr.h\"\n#include \"dcn301_smu.h\"\n#include \"reg_helper.h\"\n#include \"core_types.h\"\n#include \"dm_helpers.h\"\n\n#include \"atomfirmware.h\"\n#include \"vangogh_ip_offset.h\"\n#include \"clk/clk_11_5_0_offset.h\"\n#include \"clk/clk_11_5_0_sh_mask.h\"\n\n \n\n#define LPDDR_MEM_RETRAIN_LATENCY 4.977  \n\n \n\n#define TO_CLK_MGR_VGH(clk_mgr)\\\n\tcontainer_of(clk_mgr, struct clk_mgr_vgh, base)\n\n#define REG(reg_name) \\\n\t(CLK_BASE.instance[0].segment[mm ## reg_name ## _BASE_IDX] + mm ## reg_name)\n\n \nstatic int vg_get_active_display_cnt_wa(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i, display_count;\n\tbool tmds_present = false;\n\n\tdisplay_count = 0;\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tconst struct dc_stream_state *stream = context->streams[i];\n\n\t\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||\n\t\t\t\tstream->signal == SIGNAL_TYPE_DVI_DUAL_LINK)\n\t\t\ttmds_present = true;\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tconst struct dc_link *link = dc->links[i];\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc))\n\t\t\tdisplay_count++;\n\t}\n\n\t \n\tif (display_count == 0 && tmds_present)\n\t\tdisplay_count = 1;\n\n\treturn display_count;\n}\n\nstatic void vg_update_clocks(struct clk_mgr *clk_mgr_base,\n\t\t\t     struct dc_state *context,\n\t\t\t     bool safe_to_lower)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct dc_clocks *new_clocks = &context->bw_ctx.bw.dcn.clk;\n\tstruct dc *dc = clk_mgr_base->ctx->dc;\n\tint display_count;\n\tbool update_dppclk = false;\n\tbool update_dispclk = false;\n\tbool dpp_clock_lowered = false;\n\n\tif (dc->work_arounds.skip_clock_update)\n\t\treturn;\n\n\t \n\tif (safe_to_lower) {\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_LOW_POWER) {\n\n\t\t\tdisplay_count = vg_get_active_display_cnt_wa(dc, context);\n\t\t\t \n\t\t\tif (display_count == 0) {\n\t\t\t\tunion display_idle_optimization_u idle_info = { 0 };\n\n\t\t\t\tidle_info.idle_info.df_request_disabled = 1;\n\t\t\t\tidle_info.idle_info.phy_ref_clk_off = 1;\n\n\t\t\t\tdcn301_smu_set_display_idle_optimization(clk_mgr, idle_info.data);\n\t\t\t\t \n\t\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_LOW_POWER;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (clk_mgr_base->clks.pwr_state != DCN_PWR_STATE_MISSION_MODE) {\n\t\t\tunion display_idle_optimization_u idle_info = { 0 };\n\n\t\t\tdcn301_smu_set_display_idle_optimization(clk_mgr, idle_info.data);\n\t\t\t \n\t\t\tclk_mgr_base->clks.pwr_state = DCN_PWR_STATE_MISSION_MODE;\n\t\t}\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr_base->clks.dcfclk_khz) && !dc->debug.disable_min_fclk) {\n\t\tclk_mgr_base->clks.dcfclk_khz = new_clocks->dcfclk_khz;\n\t\tdcn301_smu_set_hard_min_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_khz);\n\t}\n\n\tif (should_set_clock(safe_to_lower,\n\t\t\tnew_clocks->dcfclk_deep_sleep_khz, clk_mgr_base->clks.dcfclk_deep_sleep_khz) && !dc->debug.disable_min_fclk) {\n\t\tclk_mgr_base->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;\n\t\tdcn301_smu_set_min_deep_sleep_dcfclk(clk_mgr, clk_mgr_base->clks.dcfclk_deep_sleep_khz);\n\t}\n\n\t \n\tif (new_clocks->dppclk_khz < 100000)\n\t\tnew_clocks->dppclk_khz = 100000;\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dppclk_khz, clk_mgr->base.clks.dppclk_khz)) {\n\t\tif (clk_mgr->base.clks.dppclk_khz > new_clocks->dppclk_khz)\n\t\t\tdpp_clock_lowered = true;\n\t\tclk_mgr_base->clks.dppclk_khz = new_clocks->dppclk_khz;\n\t\tupdate_dppclk = true;\n\t}\n\n\tif (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr_base->clks.dispclk_khz)) {\n\t\tclk_mgr_base->clks.dispclk_khz = new_clocks->dispclk_khz;\n\t\tdcn301_smu_set_dispclk(clk_mgr, clk_mgr_base->clks.dispclk_khz);\n\n\t\tupdate_dispclk = true;\n\t}\n\n\tif (dpp_clock_lowered) {\n\t\t \n\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t\tdcn301_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\t} else {\n\t\t \n\t\tif (update_dppclk || update_dispclk)\n\t\t\tdcn301_smu_set_dppclk(clk_mgr, clk_mgr_base->clks.dppclk_khz);\n\t\t \n\t\tdcn20_update_clocks_update_dpp_dto(clk_mgr, context, safe_to_lower);\n\t}\n}\n\n\nstatic int get_vco_frequency_from_reg(struct clk_mgr_internal *clk_mgr)\n{\n\t \n\tstruct fixed31_32 pll_req;\n\tunsigned int fbmult_frac_val = 0;\n\tunsigned int fbmult_int_val = 0;\n\n\n\t \n\n\tREG_GET(CLK1_0_CLK1_CLK_PLL_REQ, FbMult_frac, &fbmult_frac_val);  \n\tREG_GET(CLK1_0_CLK1_CLK_PLL_REQ, FbMult_int, &fbmult_int_val);  \n\n\tpll_req = dc_fixpt_from_int(fbmult_int_val);\n\n\t \n\tpll_req.value |= fbmult_frac_val << 16;\n\n\t \n\tpll_req = dc_fixpt_mul_int(pll_req, clk_mgr->dfs_ref_freq_khz);\n\n\t \n\treturn dc_fixpt_floor(pll_req);\n}\n\nstatic void vg_dump_clk_registers_internal(struct dcn301_clk_internal *internal, struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tinternal->CLK1_CLK3_CURRENT_CNT = REG_READ(CLK1_0_CLK1_CLK3_CURRENT_CNT);\n\tinternal->CLK1_CLK3_BYPASS_CNTL = REG_READ(CLK1_0_CLK1_CLK3_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK3_DS_CNTL = REG_READ(CLK1_0_CLK1_CLK3_DS_CNTL);\t \n\tinternal->CLK1_CLK3_ALLOW_DS = REG_READ(CLK1_0_CLK1_CLK3_ALLOW_DS);\n\n\tinternal->CLK1_CLK1_CURRENT_CNT = REG_READ(CLK1_0_CLK1_CLK1_CURRENT_CNT);\n\tinternal->CLK1_CLK1_BYPASS_CNTL = REG_READ(CLK1_0_CLK1_CLK1_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK2_CURRENT_CNT = REG_READ(CLK1_0_CLK1_CLK2_CURRENT_CNT);\n\tinternal->CLK1_CLK2_BYPASS_CNTL = REG_READ(CLK1_0_CLK1_CLK2_BYPASS_CNTL);\n\n\tinternal->CLK1_CLK0_CURRENT_CNT = REG_READ(CLK1_0_CLK1_CLK0_CURRENT_CNT);\n\tinternal->CLK1_CLK0_BYPASS_CNTL = REG_READ(CLK1_0_CLK1_CLK0_BYPASS_CNTL);\n}\n\n \nstatic void vg_dump_clk_registers(struct clk_state_registers_and_bypass *regs_and_bypass,\n\t\tstruct clk_mgr *clk_mgr_base, struct clk_log_info *log_info)\n{\n\tstruct dcn301_clk_internal internal = {0};\n\tchar *bypass_clks[5] = {\"0x0 DFS\", \"0x1 REFCLK\", \"0x2 ERROR\", \"0x3 400 FCH\", \"0x4 600 FCH\"};\n\tunsigned int chars_printed = 0;\n\tunsigned int remaining_buffer = log_info->bufSize;\n\n\tvg_dump_clk_registers_internal(&internal, clk_mgr_base);\n\n\tregs_and_bypass->dcfclk = internal.CLK1_CLK3_CURRENT_CNT / 10;\n\tregs_and_bypass->dcf_deep_sleep_divider = internal.CLK1_CLK3_DS_CNTL / 10;\n\tregs_and_bypass->dcf_deep_sleep_allow = internal.CLK1_CLK3_ALLOW_DS;\n\tregs_and_bypass->dprefclk = internal.CLK1_CLK2_CURRENT_CNT / 10;\n\tregs_and_bypass->dispclk = internal.CLK1_CLK0_CURRENT_CNT / 10;\n\tregs_and_bypass->dppclk = internal.CLK1_CLK1_CURRENT_CNT / 10;\n\n\tregs_and_bypass->dppclk_bypass = internal.CLK1_CLK1_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dppclk_bypass < 0 || regs_and_bypass->dppclk_bypass > 4)\n\t\tregs_and_bypass->dppclk_bypass = 0;\n\tregs_and_bypass->dcfclk_bypass = internal.CLK1_CLK3_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dcfclk_bypass < 0 || regs_and_bypass->dcfclk_bypass > 4)\n\t\tregs_and_bypass->dcfclk_bypass = 0;\n\tregs_and_bypass->dispclk_bypass = internal.CLK1_CLK0_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dispclk_bypass < 0 || regs_and_bypass->dispclk_bypass > 4)\n\t\tregs_and_bypass->dispclk_bypass = 0;\n\tregs_and_bypass->dprefclk_bypass = internal.CLK1_CLK2_BYPASS_CNTL & 0x0007;\n\tif (regs_and_bypass->dprefclk_bypass < 0 || regs_and_bypass->dprefclk_bypass > 4)\n\t\tregs_and_bypass->dprefclk_bypass = 0;\n\n\tif (log_info->enabled) {\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"clk_type,clk_value,deepsleep_cntl,deepsleep_allow,bypass\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dcfclk,%d,%d,%d,%s\\n\",\n\t\t\tregs_and_bypass->dcfclk,\n\t\t\tregs_and_bypass->dcf_deep_sleep_divider,\n\t\t\tregs_and_bypass->dcf_deep_sleep_allow,\n\t\t\tbypass_clks[(int) regs_and_bypass->dcfclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dprefclk,%d,N/A,N/A,%s\\n\",\n\t\t\tregs_and_bypass->dprefclk,\n\t\t\tbypass_clks[(int) regs_and_bypass->dprefclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"dispclk,%d,N/A,N/A,%s\\n\",\n\t\t\tregs_and_bypass->dispclk,\n\t\t\tbypass_clks[(int) regs_and_bypass->dispclk_bypass]);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\t \n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"SPLIT\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\t \n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"reg_name,value,clk_type\\n\");\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_CURRENT_CNT,%d,dcfclk\\n\",\n\t\t\t\tinternal.CLK1_CLK3_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_DS_CNTL,%d,dcf_deep_sleep_divider\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_DS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_ALLOW_DS,%d,dcf_deep_sleep_allow\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_ALLOW_DS);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK2_CURRENT_CNT,%d,dprefclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK2_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK0_CURRENT_CNT,%d,dispclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK0_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK1_CURRENT_CNT,%d,dppclk\\n\",\n\t\t\t\t\tinternal.CLK1_CLK1_CURRENT_CNT);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK3_BYPASS_CNTL,%d,dcfclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK3_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK2_BYPASS_CNTL,%d,dprefclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK2_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK0_BYPASS_CNTL,%d,dispclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK0_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\n\t\tchars_printed = snprintf_count(log_info->pBuf, remaining_buffer, \"CLK1_CLK1_BYPASS_CNTL,%d,dppclk_bypass\\n\",\n\t\t\t\t\tinternal.CLK1_CLK1_BYPASS_CNTL);\n\t\tremaining_buffer -= chars_printed;\n\t\t*log_info->sum_chars_printed += chars_printed;\n\t\tlog_info->pBuf += chars_printed;\n\t}\n}\n\nstatic void vg_enable_pme_wa(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\n\tdcn301_smu_enable_pme_wa(clk_mgr);\n}\n\nstatic void vg_init_clocks(struct clk_mgr *clk_mgr)\n{\n\tmemset(&(clk_mgr->clks), 0, sizeof(struct dc_clocks));\n\t \n\tclk_mgr->clks.p_state_change_support = true;\n\tclk_mgr->clks.prev_p_state_change_support = true;\n\tclk_mgr->clks.pwr_state = DCN_PWR_STATE_UNKNOWN;\n}\n\nstatic void vg_build_watermark_ranges(struct clk_bw_params *bw_params, struct watermarks *table)\n{\n\tint i, num_valid_sets;\n\n\tnum_valid_sets = 0;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\t \n\t\tif (!bw_params->wm_table.entries[i].valid)\n\t\t\tcontinue;\n\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].WmSetting = bw_params->wm_table.entries[i].wm_inst;\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].WmType = bw_params->wm_table.entries[i].wm_type;\n\t\t \n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinClock = 0;\n\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxClock = 0xFFFF;\n\n\t\tif (table->WatermarkRow[WM_DCFCLK][num_valid_sets].WmType == WM_TYPE_PSTATE_CHG) {\n\t\t\tif (i == 0)\n\t\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinMclk = 0;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinMclk =\n\t\t\t\t\t\tbw_params->clk_table.entries[i - 1].dcfclk_mhz + 1;\n\t\t\t}\n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxMclk =\n\t\t\t\t\tbw_params->clk_table.entries[i].dcfclk_mhz;\n\n\t\t} else {\n\t\t\t \n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MinClock = 0;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets].MaxClock = 0xFFFF;\n\n\t\t\t \n\t\t\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxClock = 0xFFFF;\n\t\t}\n\t\tnum_valid_sets++;\n\t}\n\n\tASSERT(num_valid_sets != 0);  \n\n\t \n\ttable->WatermarkRow[WM_DCFCLK][0].MinMclk = 0;\n\ttable->WatermarkRow[WM_DCFCLK][0].MinClock = 0;\n\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxMclk = 0xFFFF;\n\ttable->WatermarkRow[WM_DCFCLK][num_valid_sets - 1].MaxClock = 0xFFFF;\n\n\t \n\ttable->WatermarkRow[WM_SOCCLK][0].WmSetting = WM_A;\n\ttable->WatermarkRow[WM_SOCCLK][0].MinClock = 0;\n\ttable->WatermarkRow[WM_SOCCLK][0].MaxClock = 0xFFFF;\n\ttable->WatermarkRow[WM_SOCCLK][0].MinMclk = 0;\n\ttable->WatermarkRow[WM_SOCCLK][0].MaxMclk = 0xFFFF;\n}\n\n\nstatic void vg_notify_wm_ranges(struct clk_mgr *clk_mgr_base)\n{\n\tstruct clk_mgr_internal *clk_mgr = TO_CLK_MGR_INTERNAL(clk_mgr_base);\n\tstruct clk_mgr_vgh *clk_mgr_vgh = TO_CLK_MGR_VGH(clk_mgr);\n\tstruct watermarks *table = clk_mgr_vgh->smu_wm_set.wm_set;\n\n\tif (!clk_mgr->smu_ver)\n\t\treturn;\n\n\tif (!table || clk_mgr_vgh->smu_wm_set.mc_address.quad_part == 0)\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\tvg_build_watermark_ranges(clk_mgr_base->bw_params, table);\n\n\tdcn301_smu_set_dram_addr_high(clk_mgr,\n\t\t\tclk_mgr_vgh->smu_wm_set.mc_address.high_part);\n\tdcn301_smu_set_dram_addr_low(clk_mgr,\n\t\t\tclk_mgr_vgh->smu_wm_set.mc_address.low_part);\n\tdcn301_smu_transfer_wm_table_dram_2_smu(clk_mgr);\n}\n\nstatic bool vg_are_clock_states_equal(struct dc_clocks *a,\n\t\tstruct dc_clocks *b)\n{\n\tif (a->dispclk_khz != b->dispclk_khz)\n\t\treturn false;\n\telse if (a->dppclk_khz != b->dppclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_khz != b->dcfclk_khz)\n\t\treturn false;\n\telse if (a->dcfclk_deep_sleep_khz != b->dcfclk_deep_sleep_khz)\n\t\treturn false;\n\n\treturn true;\n}\n\n\nstatic struct clk_mgr_funcs vg_funcs = {\n\t.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,\n\t.update_clocks = vg_update_clocks,\n\t.init_clocks = vg_init_clocks,\n\t.enable_pme_wa = vg_enable_pme_wa,\n\t.are_clock_states_equal = vg_are_clock_states_equal,\n\t.notify_wm_ranges = vg_notify_wm_ranges\n};\n\nstatic struct clk_bw_params vg_bw_params = {\n\t.vram_type = Ddr4MemType,\n\t.num_channels = 1,\n\t.clk_table = {\n\t\t.entries = {\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 400,\n\t\t\t\t.fclk_mhz = 400,\n\t\t\t\t.memclk_mhz = 800,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 483,\n\t\t\t\t.fclk_mhz = 800,\n\t\t\t\t.memclk_mhz = 1600,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 602,\n\t\t\t\t.fclk_mhz = 1067,\n\t\t\t\t.memclk_mhz = 1067,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.voltage = 0,\n\t\t\t\t.dcfclk_mhz = 738,\n\t\t\t\t.fclk_mhz = 1333,\n\t\t\t\t.memclk_mhz = 1600,\n\t\t\t\t.socclk_mhz = 0,\n\t\t\t},\n\t\t},\n\n\t\t.num_entries = 4,\n\t},\n\n};\n\nstatic uint32_t find_max_clk_value(const uint32_t clocks[], uint32_t num_clocks)\n{\n\tuint32_t max = 0;\n\tint i;\n\n\tfor (i = 0; i < num_clocks; ++i) {\n\t\tif (clocks[i] > max)\n\t\t\tmax = clocks[i];\n\t}\n\n\treturn max;\n}\n\nstatic unsigned int find_dcfclk_for_voltage(const struct vg_dpm_clocks *clock_table,\n\t\tunsigned int voltage)\n{\n\tint i;\n\n\tfor (i = 0; i < VG_NUM_SOC_VOLTAGE_LEVELS; i++) {\n\t\tif (clock_table->SocVoltage[i] == voltage)\n\t\t\treturn clock_table->DcfClocks[i];\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}\n\nstatic void vg_clk_mgr_helper_populate_bw_params(\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct integrated_info *bios_info,\n\t\tconst struct vg_dpm_clocks *clock_table)\n{\n\tint i, j;\n\tstruct clk_bw_params *bw_params = clk_mgr->base.bw_params;\n\n\tj = -1;\n\n\tASSERT(VG_NUM_FCLK_DPM_LEVELS <= MAX_NUM_DPM_LVL);\n\n\t \n\n\tfor (i = VG_NUM_FCLK_DPM_LEVELS - 1; i >= 0; i--) {\n\t\tif (clock_table->DfPstateTable[i].fclk != 0) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j == -1) {\n\t\t \n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tbw_params->clk_table.num_entries = j + 1;\n\n\tfor (i = 0; i < bw_params->clk_table.num_entries - 1; i++, j--) {\n\t\tbw_params->clk_table.entries[i].fclk_mhz = clock_table->DfPstateTable[j].fclk;\n\t\tbw_params->clk_table.entries[i].memclk_mhz = clock_table->DfPstateTable[j].memclk;\n\t\tbw_params->clk_table.entries[i].voltage = clock_table->DfPstateTable[j].voltage;\n\t\tbw_params->clk_table.entries[i].dcfclk_mhz = find_dcfclk_for_voltage(clock_table, clock_table->DfPstateTable[j].voltage);\n\t}\n\tbw_params->clk_table.entries[i].fclk_mhz = clock_table->DfPstateTable[j].fclk;\n\tbw_params->clk_table.entries[i].memclk_mhz = clock_table->DfPstateTable[j].memclk;\n\tbw_params->clk_table.entries[i].voltage = clock_table->DfPstateTable[j].voltage;\n\tbw_params->clk_table.entries[i].dcfclk_mhz = find_max_clk_value(clock_table->DcfClocks, VG_NUM_DCFCLK_DPM_LEVELS);\n\n\tbw_params->vram_type = bios_info->memory_type;\n\tbw_params->num_channels = bios_info->ma_channel_number;\n\n\tfor (i = 0; i < WM_SET_COUNT; i++) {\n\t\tbw_params->wm_table.entries[i].wm_inst = i;\n\n\t\tif (i >= bw_params->clk_table.num_entries) {\n\t\t\tbw_params->wm_table.entries[i].valid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbw_params->wm_table.entries[i].wm_type = WM_TYPE_PSTATE_CHG;\n\t\tbw_params->wm_table.entries[i].valid = true;\n\t}\n\n\tif (bw_params->vram_type == LpDdr4MemType) {\n\t\t \n\t\tDC_FP_START();\n\t\tdcn21_clk_mgr_set_bw_params_wm_table(bw_params);\n\t\tDC_FP_END();\n\t}\n\n}\n\n \nstatic struct vg_dpm_clocks dummy_clocks = {\n\t\t.DcfClocks = { 201, 403, 403, 403, 403, 403, 403 },\n\t\t.SocClocks = { 400, 600, 600, 600, 600, 600, 600 },\n\t\t.SocVoltage = { 2800, 2860, 2860, 2860, 2860, 2860, 2860, 2860 },\n\t\t.DfPstateTable = {\n\t\t\t\t{ .fclk = 400,  .memclk = 400, .voltage = 2800 },\n\t\t\t\t{ .fclk = 400,  .memclk = 400, .voltage = 2800 },\n\t\t\t\t{ .fclk = 400,  .memclk = 400, .voltage = 2800 },\n\t\t\t\t{ .fclk = 400,  .memclk = 400, .voltage = 2800 }\n\t\t}\n};\n\nstatic struct watermarks dummy_wms = { 0 };\n\nstatic void vg_get_dpm_table_from_smu(struct clk_mgr_internal *clk_mgr,\n\t\tstruct smu_dpm_clks *smu_dpm_clks)\n{\n\tstruct vg_dpm_clocks *table = smu_dpm_clks->dpm_clks;\n\n\tif (!clk_mgr->smu_ver)\n\t\treturn;\n\n\tif (!table || smu_dpm_clks->mc_address.quad_part == 0)\n\t\treturn;\n\n\tmemset(table, 0, sizeof(*table));\n\n\tdcn301_smu_set_dram_addr_high(clk_mgr,\n\t\t\tsmu_dpm_clks->mc_address.high_part);\n\tdcn301_smu_set_dram_addr_low(clk_mgr,\n\t\t\tsmu_dpm_clks->mc_address.low_part);\n\tdcn301_smu_transfer_dpm_table_smu_2_dram(clk_mgr);\n}\n\nvoid vg_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_vgh *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct smu_dpm_clks smu_dpm_clks = { 0 };\n\tstruct clk_log_info log_info = {0};\n\n\tclk_mgr->base.base.ctx = ctx;\n\tclk_mgr->base.base.funcs = &vg_funcs;\n\n\tclk_mgr->base.pp_smu = pp_smu;\n\n\tclk_mgr->base.dccg = dccg;\n\tclk_mgr->base.dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->base.dprefclk_ss_percentage = 0;\n\tclk_mgr->base.dprefclk_ss_divider = 1000;\n\tclk_mgr->base.ss_on_dprefclk = false;\n\tclk_mgr->base.dfs_ref_freq_khz = 48000;\n\n\tclk_mgr->smu_wm_set.wm_set = (struct watermarks *)dm_helpers_allocate_gpu_mem(\n\t\t\t\tclk_mgr->base.base.ctx,\n\t\t\t\tDC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsizeof(struct watermarks),\n\t\t\t\t&clk_mgr->smu_wm_set.mc_address.quad_part);\n\n\tif (!clk_mgr->smu_wm_set.wm_set) {\n\t\tclk_mgr->smu_wm_set.wm_set = &dummy_wms;\n\t\tclk_mgr->smu_wm_set.mc_address.quad_part = 0;\n\t}\n\tASSERT(clk_mgr->smu_wm_set.wm_set);\n\n\tsmu_dpm_clks.dpm_clks = (struct vg_dpm_clocks *)dm_helpers_allocate_gpu_mem(\n\t\t\t\tclk_mgr->base.base.ctx,\n\t\t\t\tDC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsizeof(struct vg_dpm_clocks),\n\t\t\t\t&smu_dpm_clks.mc_address.quad_part);\n\n\tif (smu_dpm_clks.dpm_clks == NULL) {\n\t\tsmu_dpm_clks.dpm_clks = &dummy_clocks;\n\t\tsmu_dpm_clks.mc_address.quad_part = 0;\n\t}\n\n\tASSERT(smu_dpm_clks.dpm_clks);\n\n\tclk_mgr->base.smu_ver = dcn301_smu_get_smu_version(&clk_mgr->base);\n\n\tif (clk_mgr->base.smu_ver)\n\t\tclk_mgr->base.smu_present = true;\n\n\t \n\tclk_mgr->base.base.dentist_vco_freq_khz = get_vco_frequency_from_reg(&clk_mgr->base);\n\n\t \n\tif (clk_mgr->base.base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.base.dentist_vco_freq_khz = 3600000;\n\n\tif (ctx->dc_bios->integrated_info->memory_type == LpDdr5MemType) {\n\t\tvg_bw_params.wm_table = lpddr5_wm_table;\n\t} else {\n\t\tvg_bw_params.wm_table = ddr4_wm_table;\n\t}\n\t \n\tvg_dump_clk_registers(&clk_mgr->base.base.boot_snapshot, &clk_mgr->base.base, &log_info);\n\n\tclk_mgr->base.base.dprefclk_khz = 600000;\n\tdce_clock_read_ss_info(&clk_mgr->base);\n\n\tclk_mgr->base.base.bw_params = &vg_bw_params;\n\n\tvg_get_dpm_table_from_smu(&clk_mgr->base, &smu_dpm_clks);\n\tif (ctx->dc_bios && ctx->dc_bios->integrated_info) {\n\t\tvg_clk_mgr_helper_populate_bw_params(\n\t\t\t\t&clk_mgr->base,\n\t\t\t\tctx->dc_bios->integrated_info,\n\t\t\t\tsmu_dpm_clks.dpm_clks);\n\t}\n\n\tif (smu_dpm_clks.dpm_clks && smu_dpm_clks.mc_address.quad_part != 0)\n\t\tdm_helpers_free_gpu_mem(clk_mgr->base.base.ctx, DC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tsmu_dpm_clks.dpm_clks);\n}\n\nvoid vg_clk_mgr_destroy(struct clk_mgr_internal *clk_mgr_int)\n{\n\tstruct clk_mgr_vgh *clk_mgr = TO_CLK_MGR_VGH(clk_mgr_int);\n\n\tif (clk_mgr->smu_wm_set.wm_set && clk_mgr->smu_wm_set.mc_address.quad_part != 0)\n\t\tdm_helpers_free_gpu_mem(clk_mgr_int->base.ctx, DC_MEM_ALLOC_TYPE_FRAME_BUFFER,\n\t\t\t\tclk_mgr->smu_wm_set.wm_set);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}