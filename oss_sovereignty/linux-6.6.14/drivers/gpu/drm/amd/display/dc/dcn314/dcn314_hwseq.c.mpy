{
  "module_name": "dcn314_hwseq.c",
  "hash_id": "e21ba2cde32687cdfaf5dfb7b62b2084e2c6ec6581851150283af59e281b950a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn314/dcn314_hwseq.c",
  "human_readable_source": "\n \n\n\n#include \"dm_services.h\"\n#include \"dm_helpers.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dccg.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"abm.h\"\n#include \"hubp.h\"\n#include \"dchubbub.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"mcif_wb.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dcn314_hwseq.h\"\n#include \"link_hwss.h\"\n#include \"dpcd_defs.h\"\n#include \"dce/dmub_outbox.h\"\n#include \"link.h\"\n#include \"dcn10/dcn10_hw_sequencer.h\"\n#include \"inc/link_enc_cfg.h\"\n#include \"dcn30/dcn30_vpg.h\"\n#include \"dce/dce_i2c_hw.h\"\n#include \"dsc.h\"\n#include \"dcn20/dcn20_optc.h\"\n#include \"dcn30/dcn30_cm_common.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstatic int calc_mpc_flow_ctrl_cnt(const struct dc_stream_state *stream,\n\t\tint opp_cnt)\n{\n\tbool hblank_halved = optc2_is_two_pixels_per_containter(&stream->timing);\n\tint flow_ctrl_cnt;\n\n\tif (opp_cnt >= 2)\n\t\thblank_halved = true;\n\n\tflow_ctrl_cnt = stream->timing.h_total - stream->timing.h_addressable -\n\t\t\tstream->timing.h_border_left -\n\t\t\tstream->timing.h_border_right;\n\n\tif (hblank_halved)\n\t\tflow_ctrl_cnt /= 2;\n\n\t \n\tif (opp_cnt == 4)\n\t\tflow_ctrl_cnt /= 2;\n\n\treturn flow_ctrl_cnt;\n}\n\nstatic void update_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)\n{\n\tstruct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\n\tASSERT(dsc);\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\topp_cnt++;\n\n\tif (enable) {\n\t\tstruct dsc_config dsc_cfg;\n\t\tstruct dsc_optc_config dsc_optc_cfg;\n\t\tenum optc_dsc_mode optc_dsc_mode;\n\n\t\t \n\t\tdsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right) / opp_cnt;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\t\tASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % opp_cnt == 0);\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;\n\n\t\tdsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\tdsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\t\tstruct display_stream_compressor *odm_dsc = odm_pipe->stream_res.dsc;\n\n\t\t\tASSERT(odm_dsc);\n\t\t\todm_dsc->funcs->dsc_set_config(odm_dsc, &dsc_cfg, &dsc_optc_cfg);\n\t\t\todm_dsc->funcs->dsc_enable(odm_dsc, odm_pipe->stream_res.opp->inst);\n\t\t}\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h *= opp_cnt;\n\t\tdsc_cfg.pic_width *= opp_cnt;\n\n\t\toptc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;\n\n\t\t \n\t\tDC_LOG_DSC(\"Setting optc DSC config for tg instance %d:\", pipe_ctx->stream_res.tg->inst);\n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,\n\t\t\t\t\t\t\toptc_dsc_mode,\n\t\t\t\t\t\t\tdsc_optc_cfg.bytes_per_pixel,\n\t\t\t\t\t\t\tdsc_optc_cfg.slice_width);\n\t} else {\n\t\t \n\t\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\tOPTC_DSC_DISABLED, 0, 0);\n\n\t\t \n\t\tdsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\t\tASSERT(odm_pipe->stream_res.dsc);\n\t\t\todm_pipe->stream_res.dsc->funcs->dsc_disable(odm_pipe->stream_res.dsc);\n\t\t}\n\t}\n}\n\n\n\nstatic unsigned int get_odm_config(struct pipe_ctx *pipe_ctx, unsigned int *opp_instances)\n{\n\tunsigned int opp_count = 1;\n\tstruct pipe_ctx *odm_pipe;\n\n\t\n\tfor (odm_pipe = pipe_ctx; odm_pipe->prev_odm_pipe; odm_pipe = odm_pipe->prev_odm_pipe)\n\t\t;\n\n\t\n\tif (opp_instances)\n\t\topp_instances[0] = odm_pipe->stream_res.opp->inst;\n\n\t\n\tfor (odm_pipe = odm_pipe->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\tif (opp_instances)\n\t\t\topp_instances[opp_count] = odm_pipe->stream_res.opp->inst;\n\t\topp_count++;\n\t}\n\n\treturn opp_count;\n}\n\nvoid dcn314_update_odm(struct dc *dc, struct dc_state *context, struct pipe_ctx *pipe_ctx)\n{\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 0;\n\tint opp_inst[MAX_PIPES] = {0};\n\tbool rate_control_2x_pclk = (pipe_ctx->stream->timing.flags.INTERLACE || optc2_is_two_pixels_per_containter(&pipe_ctx->stream->timing));\n\tstruct mpc_dwb_flow_control flow_control;\n\tstruct mpc *mpc = dc->res_pool->mpc;\n\tint i;\n\n\topp_cnt = get_odm_config(pipe_ctx, opp_inst);\n\n\tif (opp_cnt > 1)\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_combine(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\topp_inst, opp_cnt,\n\t\t\t\t&pipe_ctx->stream->timing);\n\telse\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_bypass(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);\n\n\trate_control_2x_pclk = rate_control_2x_pclk || opp_cnt > 1;\n\tflow_control.flow_ctrl_mode = 0;\n\tflow_control.flow_ctrl_cnt0 = 0x80;\n\tflow_control.flow_ctrl_cnt1 = calc_mpc_flow_ctrl_cnt(pipe_ctx->stream, opp_cnt);\n\tif (mpc->funcs->set_out_rate_control) {\n\t\tfor (i = 0; i < opp_cnt; ++i) {\n\t\t\tmpc->funcs->set_out_rate_control(\n\t\t\t\t\tmpc, opp_inst[i],\n\t\t\t\t\ttrue,\n\t\t\t\t\trate_control_2x_pclk,\n\t\t\t\t\t&flow_control);\n\t\t}\n\t}\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {\n\t\todm_pipe->stream_res.opp->funcs->opp_pipe_clock_control(\n\t\t\t\todm_pipe->stream_res.opp,\n\t\t\t\ttrue);\n\t}\n\n\tif (pipe_ctx->stream_res.dsc) {\n\t\tstruct pipe_ctx *current_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];\n\n\t\tupdate_dsc_on_stream(pipe_ctx, pipe_ctx->stream->timing.flags.DSC);\n\n\t\t \n\t\tif (!pipe_ctx->next_odm_pipe && current_pipe_ctx->next_odm_pipe &&\n\t\t\t\tcurrent_pipe_ctx->next_odm_pipe->stream_res.dsc) {\n\t\t\tstruct display_stream_compressor *dsc = current_pipe_ctx->next_odm_pipe->stream_res.dsc;\n\t\t\t \n\t\t\tdsc->funcs->dsc_disconnect(dsc);\n\t\t}\n\t}\n}\n\nvoid dcn314_dsc_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dsc_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\treturn;\n\n\tif (hws->ctx->dc->debug.root_clock_optimization.bits.dsc &&\n\t\thws->ctx->dc->res_pool->dccg->funcs->enable_dsc &&\n\t\tpower_on)\n\t\thws->ctx->dc->res_pool->dccg->funcs->enable_dsc(\n\t\t\thws->ctx->dc->res_pool->dccg, dsc_inst);\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\tswitch (dsc_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN16_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN16_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN17_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN17_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN18_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN18_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 3:  \n\t\tREG_UPDATE(DOMAIN19_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN19_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n\n\tif (hws->ctx->dc->debug.root_clock_optimization.bits.dsc) {\n\t\tif (hws->ctx->dc->res_pool->dccg->funcs->disable_dsc && !power_on)\n\t\t\thws->ctx->dc->res_pool->dccg->funcs->disable_dsc(\n\t\t\t\thws->ctx->dc->res_pool->dccg, dsc_inst);\n\t}\n\n}\n\nvoid dcn314_enable_power_gating_plane(struct dce_hwseq *hws, bool enable)\n{\n\tbool force_on = true;  \n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (enable && !hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\tforce_on = false;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\t \n\tREG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\t \n\tREG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\tforce_on = true;  \n\tif (enable && !hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\tforce_on = false;\n\n\t \n\tREG_UPDATE(DOMAIN16_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN17_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN18_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN19_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\nunsigned int dcn314_calculate_dccg_k1_k2_values(struct pipe_ctx *pipe_ctx, unsigned int *k1_div, unsigned int *k2_div)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tunsigned int odm_combine_factor = 0;\n\tbool two_pix_per_container = false;\n\n\ttwo_pix_per_container = optc2_is_two_pixels_per_containter(&stream->timing);\n\todm_combine_factor = get_odm_config(pipe_ctx, NULL);\n\n\tif (stream->ctx->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t*k2_div = PIXEL_RATE_DIV_BY_1;\n\t} else if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal) || dc_is_dvi_signal(pipe_ctx->stream->signal)) {\n\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\telse\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_4;\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal) || dc_is_virtual_signal(pipe_ctx->stream->signal)) {\n\t\tif (two_pix_per_container) {\n\t\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\t} else {\n\t\t\t*k1_div = PIXEL_RATE_DIV_BY_1;\n\t\t\t*k2_div = PIXEL_RATE_DIV_BY_4;\n\t\t\tif (odm_combine_factor == 2)\n\t\t\t\t*k2_div = PIXEL_RATE_DIV_BY_2;\n\t\t}\n\t}\n\n\tif ((*k1_div == PIXEL_RATE_DIV_NA) && (*k2_div == PIXEL_RATE_DIV_NA))\n\t\tASSERT(false);\n\n\treturn odm_combine_factor;\n}\n\nvoid dcn314_set_pixels_per_cycle(struct pipe_ctx *pipe_ctx)\n{\n\tuint32_t pix_per_cycle = 1;\n\tuint32_t odm_combine_factor = 1;\n\n\tif (!pipe_ctx || !pipe_ctx->stream || !pipe_ctx->stream_res.stream_enc)\n\t\treturn;\n\n\todm_combine_factor = get_odm_config(pipe_ctx, NULL);\n\tif (optc2_is_two_pixels_per_containter(&pipe_ctx->stream->timing) || odm_combine_factor > 1)\n\t\tpix_per_cycle = 2;\n\n\tif (pipe_ctx->stream_res.stream_enc->funcs->set_input_mode)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->set_input_mode(pipe_ctx->stream_res.stream_enc,\n\t\t\t\tpix_per_cycle);\n}\n\nvoid dcn314_resync_fifo_dccg_dio(struct dce_hwseq *hws, struct dc *dc, struct dc_state *context)\n{\n\tunsigned int i;\n\tstruct pipe_ctx *pipe = NULL;\n\tbool otg_disabled[MAX_PIPES] = {false};\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->top_pipe || pipe->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tif (pipe->stream && (pipe->stream->dpms_off || dc_is_virtual_signal(pipe->stream->signal))) {\n\t\t\tpipe->stream_res.tg->funcs->disable_crtc(pipe->stream_res.tg);\n\t\t\treset_sync_context_for_pipe(dc, context, i);\n\t\t\totg_disabled[i] = true;\n\t\t}\n\t}\n\n\thws->ctx->dc->res_pool->dccg->funcs->trigger_dio_fifo_resync(hws->ctx->dc->res_pool->dccg);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &dc->current_state->res_ctx.pipe_ctx[i];\n\n\t\tif (otg_disabled[i])\n\t\t\tpipe->stream_res.tg->funcs->enable_crtc(pipe->stream_res.tg);\n\t}\n}\n\nvoid dcn314_dpp_root_clock_control(struct dce_hwseq *hws, unsigned int dpp_inst, bool clock_on)\n{\n\tif (!hws->ctx->dc->debug.root_clock_optimization.bits.dpp)\n\t\treturn;\n\n\tif (hws->ctx->dc->res_pool->dccg->funcs->dpp_root_clock_control)\n\t\thws->ctx->dc->res_pool->dccg->funcs->dpp_root_clock_control(\n\t\t\thws->ctx->dc->res_pool->dccg, dpp_inst, clock_on);\n}\n\nstatic void apply_symclk_on_tx_off_wa(struct dc_link *link)\n{\n\t \n\n\tstruct dc *dc = link->ctx->dc;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tuint8_t i;\n\n\tif (link->phy_state.symclk_ref_cnts.otg > 0) {\n\t\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\t\tpipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tif (pipe_ctx->stream && pipe_ctx->stream->link == link && pipe_ctx->top_pipe == NULL) {\n\t\t\t\tpipe_ctx->clock_source->funcs->program_pix_clk(\n\t\t\t\t\t\tpipe_ctx->clock_source,\n\t\t\t\t\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t\t\t\t\tdc->link_srv->dp_get_encoding_format(\n\t\t\t\t\t\t\t\t&pipe_ctx->link_config.dp_link_settings),\n\t\t\t\t\t\t&pipe_ctx->pll_settings);\n\t\t\t\tlink->phy_state.symclk_state = SYMCLK_ON_TX_OFF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dcn314_disable_link_output(struct dc_link *link,\n\t\tconst struct link_resource *link_res,\n\t\tenum signal_type signal)\n{\n\tstruct dc *dc = link->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, link_res);\n\tstruct dmcu *dmcu = dc->res_pool->dmcu;\n\n\tif (signal == SIGNAL_TYPE_EDP &&\n\t\t\tlink->dc->hwss.edp_backlight_control &&\n\t\t\t!link->skip_implict_edp_power_control)\n\t\tlink->dc->hwss.edp_backlight_control(link, false);\n\telse if (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->lock_phy(dmcu);\n\n\tlink_hwss->disable_link_output(link, link_res, signal);\n\tlink->phy_state.symclk_state = SYMCLK_OFF_TX_OFF;\n\t \n\tif (dmcu != NULL && dmcu->funcs->lock_phy)\n\t\tdmcu->funcs->unlock_phy(dmcu);\n\tdc->link_srv->dp_trace_source_sequence(link, DPCD_SOURCE_SEQ_AFTER_DISABLE_LINK_PHY);\n\n\tapply_symclk_on_tx_off_wa(link);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}