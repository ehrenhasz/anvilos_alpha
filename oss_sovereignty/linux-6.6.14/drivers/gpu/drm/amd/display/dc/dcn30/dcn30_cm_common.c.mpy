{
  "module_name": "dcn30_cm_common.c",
  "hash_id": "b6261dc6e4af3b79e9d57f8deab3e8b5d9c99f101c28162054b8ab9fa3f7f5d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_cm_common.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"core_types.h\"\n#include \"reg_helper.h\"\n#include \"dcn30_dpp.h\"\n#include \"basics/conversion.h\"\n#include \"dcn30_cm_common.h\"\n#include \"custom_float.h\"\n\n#define REG(reg) reg\n\n#define CTX \\\n\tctx \n\n#undef FN\n#define FN(reg_name, field_name) \\\n\treg->shifts.field_name, reg->masks.field_name\n\nvoid cm_helper_program_gamcor_xfer_func(\n\t\tstruct dc_context *ctx,\n\t\tconst struct pwl_params *params,\n\t\tconst struct dcn3_xfer_func_reg *reg)\n{\n\tuint32_t reg_region_cur;\n\tunsigned int i = 0;\n\n\tREG_SET_2(reg->start_cntl_b, 0,\n\t\texp_region_start, params->corner_points[0].blue.custom_float_x,\n\t\texp_resion_start_segment, 0);\n\tREG_SET_2(reg->start_cntl_g, 0,\n\t\texp_region_start, params->corner_points[0].green.custom_float_x,\n\t\texp_resion_start_segment, 0);\n\tREG_SET_2(reg->start_cntl_r, 0,\n\t\texp_region_start, params->corner_points[0].red.custom_float_x,\n\t\texp_resion_start_segment, 0);\n\n\tREG_SET(reg->start_slope_cntl_b, 0, \n\t\tfield_region_linear_slope, params->corner_points[0].blue.custom_float_slope);\n\tREG_SET(reg->start_slope_cntl_g, 0,\n\t\tfield_region_linear_slope, params->corner_points[0].green.custom_float_slope);\n\tREG_SET(reg->start_slope_cntl_r, 0,\n\t\tfield_region_linear_slope, params->corner_points[0].red.custom_float_slope);\n\n\tREG_SET(reg->start_end_cntl1_b, 0,\n\t\tfield_region_end_base, params->corner_points[1].blue.custom_float_y);\n\tREG_SET(reg->start_end_cntl1_g, 0,\n\t\tfield_region_end_base, params->corner_points[1].green.custom_float_y);\n\tREG_SET(reg->start_end_cntl1_r, 0,\n\t\tfield_region_end_base, params->corner_points[1].red.custom_float_y);\n\n\tREG_SET_2(reg->start_end_cntl2_b, 0,\n\t\tfield_region_end_slope, params->corner_points[1].blue.custom_float_slope,\n\t\tfield_region_end, params->corner_points[1].blue.custom_float_x);\n\tREG_SET_2(reg->start_end_cntl2_g, 0,\n\t\tfield_region_end_slope, params->corner_points[1].green.custom_float_slope,\n\t\tfield_region_end, params->corner_points[1].green.custom_float_x);\n\tREG_SET_2(reg->start_end_cntl2_r, 0,\n\t\tfield_region_end_slope, params->corner_points[1].red.custom_float_slope,\n\t\tfield_region_end, params->corner_points[1].red.custom_float_x);\n\n\tfor (reg_region_cur = reg->region_start;\n\t\treg_region_cur <= reg->region_end;\n\t\treg_region_cur++) {\n\n\t\tconst struct gamma_curve *curve0 = &(params->arr_curve_points[2 * i]);\n\t\tconst struct gamma_curve *curve1 = &(params->arr_curve_points[(2 * i) + 1]);\n\n\t\tREG_SET_4(reg_region_cur, 0,\n\t\t\texp_region0_lut_offset, curve0->offset,\n\t\t\texp_region0_num_segments, curve0->segments_num,\n\t\t\texp_region1_lut_offset, curve1->offset,\n\t\t\texp_region1_num_segments, curve1->segments_num);\n\n\t\ti++;\n\t}\n}\n\n \n#define MAX_REGIONS_NUMBER 34\n#define MAX_LOW_POINT      25\n#define NUMBER_REGIONS     32\n#define NUMBER_SW_SEGMENTS 16\n\nbool cm3_helper_translate_curve_to_hw_format(\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\tstruct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\tstruct fixed31_32 end_value;\n\n\tint32_t region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params == NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr, 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf == TRANSFER_FUNCTION_GAMMA22 ||\n\t\toutput_tf->tf == TRANSFER_FUNCTION_HLG) {\n\t\t \n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i] = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS - MAX_LOW_POINT;\n\t} else {\n\t\t \n\t\tseg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3] = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\tseg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10] = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start); k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment) {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\n\t \n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\n\t\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y = rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\t\t\tcorner_points[0].blue.x);\n\n\t \n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf == TRANSFER_FUNCTION_HLG) {\n\t\t \n\n\t\tif (output_tf->tf == TRANSFER_FUNCTION_PQ)\n\t\t\tend_value = dc_fixpt_from_int(125);\n\t\telse\n\t\t\tend_value = dc_fixpt_from_fraction(125, 10);\n\n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\t}\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER; i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\trgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\t\tif (i >= hw_points - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green, rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue = dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green, rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\n\t\tif (fixpoint == true) {\n\t\t\trgb->delta_red_reg   = dc_fixpt_clamp_u0d10(rgb->delta_red);\n\t\t\trgb->delta_green_reg = dc_fixpt_clamp_u0d10(rgb->delta_green);\n\t\t\trgb->delta_blue_reg  = dc_fixpt_clamp_u0d10(rgb->delta_blue);\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1 = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm3_helper_convert_to_custom_float(rgb_resulted,\n\t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\treturn true;\n}\n\n#define NUM_DEGAMMA_REGIONS    12\n\n\nbool cm3_helper_translate_curve_to_degamma_hw_format(\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\tstruct pwl_params *lut_params)\n{\n\tstruct curve_points3 *corner_points;\n\tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct pwl_result_data *rgb_plus_1;\n\n\tint32_t region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params == NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr, 0, sizeof(seg_distr));\n\n\tregion_start = -NUM_DEGAMMA_REGIONS;\n\tregion_end   = 0;\n\n\n\tfor (i = region_end - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\t \n\tfor (i = 0; i < NUM_DEGAMMA_REGIONS ; i++)\n\t\tseg_distr[i] = 4;\n\n\tfor (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start); k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment) {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\n\t \n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];\n\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\tcorner_points[0].blue.x = corner_points[0].red.x;\n\tcorner_points[1].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y = rgb_resulted[0].blue;\n\n\t \n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ) {\n\t\t \n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one, corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER; i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\trgb_plus_1->red = rgb->red;\n\t\tif (dc_fixpt_lt(rgb_plus_1->green, rgb->green))\n\t\t\trgb_plus_1->green = rgb->green;\n\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\trgb_plus_1->blue = rgb->blue;\n\n\t\trgb->delta_red   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green, rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\n\t\t++rgb_plus_1;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm3_helper_convert_to_custom_float(rgb_resulted,\n\t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, false);\n\n\treturn true;\n}\n\nbool cm3_helper_convert_to_custom_float(\n\t\tstruct pwl_result_data *rgb_resulted,\n\t\tstruct curve_points3 *corner_points,\n\t\tuint32_t hw_points_num,\n\t\tbool fixpoint)\n{\n\tstruct custom_float_format fmt;\n\n\tstruct pwl_result_data *rgb = rgb_resulted;\n\n\tuint32_t i = 0;\n\n\tfmt.exponenta_bits = 6;\n\tfmt.mantissa_bits = 12;\n\tfmt.sign = false;\n\n\t \n\tif (!convert_to_custom_float_format(corner_points[0].red.x, &fmt,\n\t\t\t\t&corner_points[0].red.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].green.x, &fmt,\n\t\t\t\t&corner_points[0].green.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].blue.x, &fmt,\n\t\t\t\t&corner_points[0].blue.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(corner_points[0].red.offset, &fmt,\n\t\t\t\t&corner_points[0].red.custom_float_offset)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].green.offset, &fmt,\n\t\t\t\t&corner_points[0].green.custom_float_offset)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].blue.offset, &fmt,\n\t\t\t\t&corner_points[0].blue.custom_float_offset)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(corner_points[0].red.slope, &fmt,\n\t\t\t\t&corner_points[0].red.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].green.slope, &fmt,\n\t\t\t\t&corner_points[0].green.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[0].blue.slope, &fmt,\n\t\t\t\t&corner_points[0].blue.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (fixpoint == true) {\n\t\tcorner_points[1].red.custom_float_y =\n\t\t\t\tdc_fixpt_clamp_u0d14(corner_points[1].red.y);\n\t\tcorner_points[1].green.custom_float_y =\n\t\t\t\tdc_fixpt_clamp_u0d14(corner_points[1].green.y);\n\t\tcorner_points[1].blue.custom_float_y =\n\t\t\t\tdc_fixpt_clamp_u0d14(corner_points[1].blue.y);\n\t} else {\n\t\tif (!convert_to_custom_float_format(corner_points[1].red.y,\n\t\t\t\t&fmt, &corner_points[1].red.custom_float_y)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\t\tif (!convert_to_custom_float_format(corner_points[1].green.y,\n\t\t\t\t&fmt, &corner_points[1].green.custom_float_y)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\t\tif (!convert_to_custom_float_format(corner_points[1].blue.y,\n\t\t\t\t&fmt, &corner_points[1].blue.custom_float_y)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfmt.mantissa_bits = 10;\n\tfmt.sign = false;\n\n\tif (!convert_to_custom_float_format(corner_points[1].red.x, &fmt,\n\t\t\t\t&corner_points[1].red.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[1].green.x, &fmt,\n\t\t\t\t&corner_points[1].green.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[1].blue.x, &fmt,\n\t\t\t\t&corner_points[1].blue.custom_float_x)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (!convert_to_custom_float_format(corner_points[1].red.slope, &fmt,\n\t\t\t\t&corner_points[1].red.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[1].green.slope, &fmt,\n\t\t\t\t&corner_points[1].green.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\tif (!convert_to_custom_float_format(corner_points[1].blue.slope, &fmt,\n\t\t\t\t&corner_points[1].blue.custom_float_slope)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn false;\n\t}\n\n\tif (hw_points_num == 0 || rgb_resulted == NULL || fixpoint == true)\n\t\treturn true;\n\n\tfmt.mantissa_bits = 12;\n\n\twhile (i != hw_points_num) {\n\t\tif (!convert_to_custom_float_format(rgb->red, &fmt,\n\t\t\t\t\t\t    &rgb->red_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->green, &fmt,\n\t\t\t\t\t\t    &rgb->green_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->blue, &fmt,\n\t\t\t\t\t\t    &rgb->blue_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_red, &fmt,\n\t\t\t\t\t\t    &rgb->delta_red_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_green, &fmt,\n\t\t\t\t\t\t    &rgb->delta_green_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!convert_to_custom_float_format(rgb->delta_blue, &fmt,\n\t\t\t\t\t\t    &rgb->delta_blue_reg)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\t++rgb;\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\nbool is_rgb_equal(const struct pwl_result_data *rgb, uint32_t num)\n{\n\tuint32_t i;\n\tbool ret = true;\n\n\tfor (i = 0 ; i < num; i++) {\n\t\tif (rgb[i].red_reg != rgb[i].green_reg ||\n\t\trgb[i].blue_reg != rgb[i].red_reg  ||\n\t\trgb[i].blue_reg != rgb[i].green_reg) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}