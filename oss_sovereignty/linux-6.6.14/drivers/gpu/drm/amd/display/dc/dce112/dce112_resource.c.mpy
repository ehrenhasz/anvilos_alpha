{
  "module_name": "dce112_resource.c",
  "hash_id": "de14fe30a2482cd9c580722622ea738032146a03cc8817b173048088e23ce7a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce110/dce110_timing_generator.h\"\n\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_clock_source.h\"\n\n#include \"dce/dce_hwseq.h\"\n#include \"dce112/dce112_hw_sequencer.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n#include \"dce/dce_panel_cntl.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_11_2_d.h\"\n#include \"dce/dce_11_2_sh_mask.h\"\n\n#include \"dce100/dce100_resource.h\"\n#include \"dce112_resource.h\"\n\n#define DC_LOGGER\t\t\t\t\\\n\t\tdc->ctx->logger\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\nenum dce112_clk_src_array_id {\n\tDCE112_CLK_SRC_PLL0,\n\tDCE112_CLK_SRC_PLL1,\n\tDCE112_CLK_SRC_PLL2,\n\tDCE112_CLK_SRC_PLL3,\n\tDCE112_CLK_SRC_PLL4,\n\tDCE112_CLK_SRC_PLL5,\n\n\tDCE112_CLK_SRC_TOTAL\n};\n\nstatic const struct dce110_timing_generator_offsets dce112_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n \n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n \n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce110_aux_registers_shift aux_shift = {\n\tDCE_AUX_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce110_aux_registers_mask aux_mask = {\n\tDCE_AUX_MASK_SH_LIST(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\nstatic const struct dce_panel_cntl_registers panel_cntl_regs[] = {\n\t{ DCE_PANEL_CNTL_REG_LIST() }\n};\n\nstatic const struct dce_panel_cntl_shift panel_cntl_shift = {\n\tDCE_PANEL_CNTL_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_panel_cntl_mask panel_cntl_mask = {\n\tDCE_PANEL_CNTL_MASK_SH_LIST(_MASK)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE110_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_112_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5)\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(index, id)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCE_112(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps polaris_10_resource_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 8,  \n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps polaris_11_resource_cap = {\n\t\t.num_timing_generator = 5,\n\t\t.num_audio = 5,\n\t\t.num_stream_encoder = 5,\n\t\t.num_pll = 8,  \n\t\t.num_ddc = 5,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = true\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\t64,\n\t64\n};\n\nstatic const struct dc_debug_options debug_defaults = {\n\t\t.enable_legacy_fast_update = true,\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x4819\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic int map_transmitter_id_to_phy_instance(\n\tenum transmitter transmitter)\n{\n\tswitch (transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn 0;\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn 1;\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn 2;\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn 3;\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn 4;\n\tcase TRANSMITTER_UNIPHY_F:\n\t\treturn 5;\n\tcase TRANSMITTER_UNIPHY_G:\n\t\treturn 6;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn 0;\n\t}\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\n\nstatic struct timing_generator *dce112_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce112_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE112_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce112_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce112_stream_encoder_create,\n\t.create_hwseq = dce112_hwseq_create,\n};\n\n#define mi_inst_regs(id) { MI_DCE11_2_REG_LIST(id) }\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE11_2_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE11_2_MASK_SH_LIST(_MASK)\n};\n\nstatic struct mem_input *dce112_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce112_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\treturn &dce_mi->base;\n}\n\nstatic void dce112_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce112_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->lb_memory_size = 0x1404;  \n\treturn &transform->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstatic struct link_encoder *dce112_link_encoder_create(\n\tstruct dc_context *ctx,\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\tint link_regs_id;\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tlink_regs_id =\n\t\tmap_transmitter_id_to_phy_instance(enc_init_data->transmitter);\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[link_regs_id],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstatic struct panel_cntl *dce112_panel_cntl_create(const struct panel_cntl_init_data *init_data)\n{\n\tstruct dce_panel_cntl *panel_cntl =\n\t\tkzalloc(sizeof(struct dce_panel_cntl), GFP_KERNEL);\n\n\tif (!panel_cntl)\n\t\treturn NULL;\n\n\tdce_panel_cntl_construct(panel_cntl,\n\t\t\tinit_data,\n\t\t\t&panel_cntl_regs[init_data->inst],\n\t\t\t&panel_cntl_shift,\n\t\t\t&panel_cntl_mask);\n\n\treturn &panel_cntl->base;\n}\n\nstatic struct input_pixel_processor *dce112_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic struct output_pixel_processor *dce112_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstatic struct dce_aux *dce112_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst],\n\t\t\t\t\t&aux_mask,\n\t\t\t\t\t&aux_shift,\n\t\t\t\t\tctx->dc->caps.extended_aux_timeout_support);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic struct dce_i2c_hw *dce112_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstatic struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void dce112_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic void dce112_resource_destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce112_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL) {\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce112_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce112_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\nstatic struct clock_source *find_matching_pll(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct dc_stream_state *const stream)\n{\n\tswitch (stream->link->link_enc->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL0];\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL1];\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL2];\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL3];\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL4];\n\tcase TRANSMITTER_UNIPHY_F:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL5];\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_otg_master_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nbool dce112_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tbool result = false;\n\n\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\"%s: start\",\n\t\t__func__);\n\n\tif (bw_calcs(\n\t\t\tdc->ctx,\n\t\t\tdc->bw_dceip,\n\t\t\tdc->bw_vbios,\n\t\t\tcontext->res_ctx.pipe_ctx,\n\t\t\tdc->res_pool->pipe_count,\n\t\t\t&context->bw_ctx.bw.dce))\n\t\tresult = true;\n\n\tif (!result)\n\t\tDC_LOG_BANDWIDTH_VALIDATION(\n\t\t\t\"%s: Bandwidth validation failed!\",\n\t\t\t__func__);\n\n\tif (memcmp(&dc->current_state->bw_ctx.bw.dce,\n\t\t\t&context->bw_ctx.bw.dce, sizeof(context->bw_ctx.bw.dce))) {\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\t\"%s: finish,\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d stutter_mode_enable: %d\\n\"\n\t\t\t\"cstate: %d pstate: %d nbpstate: %d sync: %d dispclk: %d\\n\"\n\t\t\t\"sclk: %d sclk_sleep: %d yclk: %d blackout_recovery_time_us: %d\\n\"\n\t\t\t,\n\t\t\t__func__,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_mode_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync,\n\t\t\tcontext->bw_ctx.bw.dce.dispclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_deep_sleep_khz,\n\t\t\tcontext->bw_ctx.bw.dce.yclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us);\n\t}\n\treturn result;\n}\n\nenum dc_status resource_map_phy_clock_resources(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\n\t \n\tstruct pipe_ctx *pipe_ctx = resource_get_otg_master_for_stream(\n\t\t\t&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)\n\t\t|| dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->clock_source =\n\t\t\t\tdc->res_pool->dp_clock_source;\n\telse {\n\t\tif (stream && stream->link && stream->link->link_enc)\n\t\t\tpipe_ctx->clock_source = find_matching_pll(\n\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\tstream);\n\t}\n\n\tif (pipe_ctx->clock_source == NULL)\n\t\treturn DC_NO_CLOCK_SOURCE_RESOURCE;\n\n\tresource_reference_clock_source(\n\t\t&context->res_ctx,\n\t\tdc->res_pool,\n\t\tpipe_ctx->clock_source);\n\n\treturn DC_OK;\n}\n\nstatic bool dce112_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce112_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic enum dc_status dce112_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce112_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic void dce112_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdce112_resource_destruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce112_res_pool_funcs = {\n\t.destroy = dce112_destroy_resource_pool,\n\t.link_enc_create = dce112_link_encoder_create,\n\t.panel_cntl_create = dce112_panel_cntl_create,\n\t.validate_bandwidth = dce112_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce112_add_stream_to_ctx,\n\t.validate_global = dce112_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels_with_latency eng_clks = {0};\n\tstruct dm_pp_clock_levels_with_latency mem_clks = {0};\n\tstruct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};\n\tstruct dm_pp_clock_levels clks = {0};\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\tif (dc->bw_vbios && dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\t \n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t&eng_clks)) {\n\n\t\t \n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t\t&clks);\n\t\t \n\t\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\t\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels/8], 1000);\n\t\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*2/8], 1000);\n\t\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*3/8], 1000);\n\t\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*4/8], 1000);\n\t\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*5/8], 1000);\n\t\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*6/8], 1000);\n\t\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[0], 1000);\n\n\t\t \n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t\t&clks);\n\n\t\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0] * memory_type_multiplier, 1000);\n\t\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels>>1] * memory_type_multiplier,\n\t\t\t1000);\n\t\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1] * memory_type_multiplier,\n\t\t\t1000);\n\n\t\treturn;\n\t}\n\n\t \n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\teng_clks.data[0].clocks_in_khz, 1000);\n\n\t \n\tdm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&mem_clks);\n\n\t \n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[0].clocks_in_khz * memory_type_multiplier, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels-1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\n\t \n\tclk_ranges.num_wm_sets = 4;\n\tclk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;\n\tclk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[0].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;\n\tclk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t \n\tclk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[1].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;\n\tclk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[2].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t \n\tclk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;\n\n\tclk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;\n\tclk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t \n\tclk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[3].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t \n\tclk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;\n\n\t \n\tdm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);\n}\n\nstatic const struct resource_caps *dce112_resource_cap(\n\tstruct hw_asic_id *asic_id)\n{\n\tif (ASIC_REV_IS_POLARIS11_M(asic_id->hw_internal_rev) ||\n\t    ASIC_REV_IS_POLARIS12_V(asic_id->hw_internal_rev))\n\t\treturn &polaris_11_resource_cap;\n\telse\n\t\treturn &polaris_10_resource_cap;\n}\n\nstatic bool dce112_resource_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = dce112_resource_cap(&ctx->asic_id);\n\tpool->base.funcs = &dce112_res_pool_funcs;\n\n\t \n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.i2c_speed_in_khz_hdcp = 100;  \n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.min_horizontal_blanking_period = 80;\n\tdc->caps.dual_link_dvi = true;\n\tdc->caps.extended_aux_timeout_support = false;\n\tdc->debug = debug_defaults;\n\n\t \n\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL0] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL1] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL2] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL3] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL4] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL5] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =  dce112_clock_source_create(\n\t\tctx, ctx->dc_bios,\n\t\tCLOCK_SOURCE_ID_DP_DTO, &clk_src_regs[0], true);\n\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] =\n\t\t\t\tdce112_timing_generator_create(\n\t\t\t\t\tctx,\n\t\t\t\t\ti,\n\t\t\t\t\t&dce112_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce112_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce112_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce112_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce112_opp_create(\n\t\t\tctx,\n\t\t\ti);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce112_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce112_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t  &res_create_funcs))\n\t\tgoto res_create_fail;\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\t \n\tdce112_hw_sequencer_construct(dc);\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdce112_resource_destruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce112_resource_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}