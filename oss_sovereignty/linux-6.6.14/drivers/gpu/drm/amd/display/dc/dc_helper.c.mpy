{
  "module_name": "dc_helper.c",
  "hash_id": "410275e377c319208c4e93a03d2bdba65923f934848ddafba4ffb04cdf749465",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dc_helper.c",
  "human_readable_source": " \n \n\n#include <linux/delay.h>\n#include <linux/stdarg.h>\n\n#include \"dm_services.h\"\n\n#include \"dc.h\"\n#include \"dc_dmub_srv.h\"\n#include \"reg_helper.h\"\n\nstatic inline void submit_dmub_read_modify_write(\n\tstruct dc_reg_helper_state *offload,\n\tconst struct dc_context *ctx)\n{\n\tstruct dmub_rb_cmd_read_modify_write *cmd_buf = &offload->cmd_data.read_modify_write;\n\n\toffload->should_burst_write =\n\t\t\t(offload->same_addr_count == (DMUB_READ_MODIFY_WRITE_SEQ__MAX - 1));\n\tcmd_buf->header.payload_bytes =\n\t\t\tsizeof(struct dmub_cmd_read_modify_write_sequence) * offload->reg_seq_count;\n\n\tdm_execute_dmub_cmd(ctx, &offload->cmd_data, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\tmemset(cmd_buf, 0, sizeof(*cmd_buf));\n\n\toffload->reg_seq_count = 0;\n\toffload->same_addr_count = 0;\n}\n\nstatic inline void submit_dmub_burst_write(\n\tstruct dc_reg_helper_state *offload,\n\tconst struct dc_context *ctx)\n{\n\tstruct dmub_rb_cmd_burst_write *cmd_buf = &offload->cmd_data.burst_write;\n\n\tcmd_buf->header.payload_bytes =\n\t\t\tsizeof(uint32_t) * offload->reg_seq_count;\n\n\tdm_execute_dmub_cmd(ctx, &offload->cmd_data, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\tmemset(cmd_buf, 0, sizeof(*cmd_buf));\n\n\toffload->reg_seq_count = 0;\n}\n\nstatic inline void submit_dmub_reg_wait(\n\t\tstruct dc_reg_helper_state *offload,\n\t\tconst struct dc_context *ctx)\n{\n\tstruct dmub_rb_cmd_reg_wait *cmd_buf = &offload->cmd_data.reg_wait;\n\n\tdm_execute_dmub_cmd(ctx, &offload->cmd_data, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\tmemset(cmd_buf, 0, sizeof(*cmd_buf));\n\toffload->reg_seq_count = 0;\n}\n\nstruct dc_reg_value_masks {\n\tuint32_t value;\n\tuint32_t mask;\n};\n\nstruct dc_reg_sequence {\n\tuint32_t addr;\n\tstruct dc_reg_value_masks value_masks;\n};\n\nstatic inline void set_reg_field_value_masks(\n\tstruct dc_reg_value_masks *field_value_mask,\n\tuint32_t value,\n\tuint32_t mask,\n\tuint8_t shift)\n{\n\tASSERT(mask != 0);\n\n\tfield_value_mask->value = (field_value_mask->value & ~mask) | (mask & (value << shift));\n\tfield_value_mask->mask = field_value_mask->mask | mask;\n}\n\nstatic void set_reg_field_values(struct dc_reg_value_masks *field_value_mask,\n\t\tuint32_t addr, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1,\n\t\tva_list ap)\n{\n\tuint32_t shift, mask, field_value;\n\tint i = 1;\n\n\t \n\tset_reg_field_value_masks(field_value_mask,\n\t\t\tfield_value1, mask1, shift1);\n\n\twhile (i < n) {\n\t\tshift = va_arg(ap, uint32_t);\n\t\tmask = va_arg(ap, uint32_t);\n\t\tfield_value = va_arg(ap, uint32_t);\n\n\t\tset_reg_field_value_masks(field_value_mask,\n\t\t\t\tfield_value, mask, shift);\n\t\ti++;\n\t}\n}\n\nstatic void dmub_flush_buffer_execute(\n\t\tstruct dc_reg_helper_state *offload,\n\t\tconst struct dc_context *ctx)\n{\n\tsubmit_dmub_read_modify_write(offload, ctx);\n}\n\nstatic void dmub_flush_burst_write_buffer_execute(\n\t\tstruct dc_reg_helper_state *offload,\n\t\tconst struct dc_context *ctx)\n{\n\tsubmit_dmub_burst_write(offload, ctx);\n}\n\nstatic bool dmub_reg_value_burst_set_pack(const struct dc_context *ctx, uint32_t addr,\n\t\tuint32_t reg_val)\n{\n\tstruct dc_reg_helper_state *offload = &ctx->dmub_srv->reg_helper_offload;\n\tstruct dmub_rb_cmd_burst_write *cmd_buf = &offload->cmd_data.burst_write;\n\n\t \n\tif (offload->reg_seq_count == DMUB_BURST_WRITE_VALUES__MAX)\n\t\tdmub_flush_burst_write_buffer_execute(offload, ctx);\n\n\tif (offload->cmd_data.cmd_common.header.type == DMUB_CMD__REG_SEQ_BURST_WRITE &&\n\t\t\taddr != cmd_buf->addr) {\n\t\tdmub_flush_burst_write_buffer_execute(offload, ctx);\n\t\treturn false;\n\t}\n\n\tcmd_buf->header.type = DMUB_CMD__REG_SEQ_BURST_WRITE;\n\tcmd_buf->header.sub_type = 0;\n\tcmd_buf->addr = addr;\n\tcmd_buf->write_values[offload->reg_seq_count] = reg_val;\n\toffload->reg_seq_count++;\n\n\treturn true;\n}\n\nstatic uint32_t dmub_reg_value_pack(const struct dc_context *ctx, uint32_t addr,\n\t\tstruct dc_reg_value_masks *field_value_mask)\n{\n\tstruct dc_reg_helper_state *offload = &ctx->dmub_srv->reg_helper_offload;\n\tstruct dmub_rb_cmd_read_modify_write *cmd_buf = &offload->cmd_data.read_modify_write;\n\tstruct dmub_cmd_read_modify_write_sequence *seq;\n\n\t \n\tif (offload->cmd_data.cmd_common.header.type != DMUB_CMD__REG_SEQ_BURST_WRITE &&\n\t\t\toffload->reg_seq_count == DMUB_READ_MODIFY_WRITE_SEQ__MAX)\n\t\tdmub_flush_buffer_execute(offload, ctx);\n\n\tif (offload->should_burst_write) {\n\t\tif (dmub_reg_value_burst_set_pack(ctx, addr, field_value_mask->value))\n\t\t\treturn field_value_mask->value;\n\t\telse\n\t\t\toffload->should_burst_write = false;\n\t}\n\n\t \n\tcmd_buf->header.type = DMUB_CMD__REG_SEQ_READ_MODIFY_WRITE;\n\tcmd_buf->header.sub_type = 0;\n\tseq = &cmd_buf->seq[offload->reg_seq_count];\n\n\tif (offload->reg_seq_count) {\n\t\tif (cmd_buf->seq[offload->reg_seq_count - 1].addr == addr)\n\t\t\toffload->same_addr_count++;\n\t\telse\n\t\t\toffload->same_addr_count = 0;\n\t}\n\n\tseq->addr = addr;\n\tseq->modify_mask = field_value_mask->mask;\n\tseq->modify_value = field_value_mask->value;\n\toffload->reg_seq_count++;\n\n\treturn field_value_mask->value;\n}\n\nstatic void dmub_reg_wait_done_pack(const struct dc_context *ctx, uint32_t addr,\n\t\tuint32_t mask, uint32_t shift, uint32_t condition_value, uint32_t time_out_us)\n{\n\tstruct dc_reg_helper_state *offload = &ctx->dmub_srv->reg_helper_offload;\n\tstruct dmub_rb_cmd_reg_wait *cmd_buf = &offload->cmd_data.reg_wait;\n\n\tcmd_buf->header.type = DMUB_CMD__REG_REG_WAIT;\n\tcmd_buf->header.sub_type = 0;\n\tcmd_buf->reg_wait.addr = addr;\n\tcmd_buf->reg_wait.condition_field_value = mask & (condition_value << shift);\n\tcmd_buf->reg_wait.mask = mask;\n\tcmd_buf->reg_wait.time_out_us = time_out_us;\n}\n\nuint32_t generic_reg_update_ex(const struct dc_context *ctx,\n\t\tuint32_t addr, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1,\n\t\t...)\n{\n\tstruct dc_reg_value_masks field_value_mask = {0};\n\tuint32_t reg_val;\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\tset_reg_field_values(&field_value_mask, addr, n, shift1, mask1,\n\t\t\tfield_value1, ap);\n\n\tva_end(ap);\n\n\tif (ctx->dmub_srv &&\n\t    ctx->dmub_srv->reg_helper_offload.gather_in_progress)\n\t\treturn dmub_reg_value_pack(ctx, addr, &field_value_mask);\n\t\t \n\n\t \n\treg_val = dm_read_reg(ctx, addr);\n\treg_val = (reg_val & ~field_value_mask.mask) | field_value_mask.value;\n\tdm_write_reg(ctx, addr, reg_val);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_set_ex(const struct dc_context *ctx,\n\t\tuint32_t addr, uint32_t reg_val, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1,\n\t\t...)\n{\n\tstruct dc_reg_value_masks field_value_mask = {0};\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\tset_reg_field_values(&field_value_mask, addr, n, shift1, mask1,\n\t\t\tfield_value1, ap);\n\n\tva_end(ap);\n\n\n\t \n\treg_val = (reg_val & ~field_value_mask.mask) | field_value_mask.value;\n\n\tif (ctx->dmub_srv &&\n\t    ctx->dmub_srv->reg_helper_offload.gather_in_progress) {\n\t\treturn dmub_reg_value_burst_set_pack(ctx, addr, reg_val);\n\t\t \n\t}\n\n\tdm_write_reg(ctx, addr, reg_val);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift, uint32_t mask, uint32_t *field_value)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value = get_reg_field_value_ex(reg_val, mask, shift);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get2(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get3(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get4(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3,\n\t\tuint8_t shift4, uint32_t mask4, uint32_t *field_value4)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\t*field_value4 = get_reg_field_value_ex(reg_val, mask4, shift4);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get5(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3,\n\t\tuint8_t shift4, uint32_t mask4, uint32_t *field_value4,\n\t\tuint8_t shift5, uint32_t mask5, uint32_t *field_value5)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\t*field_value4 = get_reg_field_value_ex(reg_val, mask4, shift4);\n\t*field_value5 = get_reg_field_value_ex(reg_val, mask5, shift5);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get6(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3,\n\t\tuint8_t shift4, uint32_t mask4, uint32_t *field_value4,\n\t\tuint8_t shift5, uint32_t mask5, uint32_t *field_value5,\n\t\tuint8_t shift6, uint32_t mask6, uint32_t *field_value6)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\t*field_value4 = get_reg_field_value_ex(reg_val, mask4, shift4);\n\t*field_value5 = get_reg_field_value_ex(reg_val, mask5, shift5);\n\t*field_value6 = get_reg_field_value_ex(reg_val, mask6, shift6);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get7(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3,\n\t\tuint8_t shift4, uint32_t mask4, uint32_t *field_value4,\n\t\tuint8_t shift5, uint32_t mask5, uint32_t *field_value5,\n\t\tuint8_t shift6, uint32_t mask6, uint32_t *field_value6,\n\t\tuint8_t shift7, uint32_t mask7, uint32_t *field_value7)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\t*field_value4 = get_reg_field_value_ex(reg_val, mask4, shift4);\n\t*field_value5 = get_reg_field_value_ex(reg_val, mask5, shift5);\n\t*field_value6 = get_reg_field_value_ex(reg_val, mask6, shift6);\n\t*field_value7 = get_reg_field_value_ex(reg_val, mask7, shift7);\n\treturn reg_val;\n}\n\nuint32_t generic_reg_get8(const struct dc_context *ctx, uint32_t addr,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\tuint8_t shift2, uint32_t mask2, uint32_t *field_value2,\n\t\tuint8_t shift3, uint32_t mask3, uint32_t *field_value3,\n\t\tuint8_t shift4, uint32_t mask4, uint32_t *field_value4,\n\t\tuint8_t shift5, uint32_t mask5, uint32_t *field_value5,\n\t\tuint8_t shift6, uint32_t mask6, uint32_t *field_value6,\n\t\tuint8_t shift7, uint32_t mask7, uint32_t *field_value7,\n\t\tuint8_t shift8, uint32_t mask8, uint32_t *field_value8)\n{\n\tuint32_t reg_val = dm_read_reg(ctx, addr);\n\t*field_value1 = get_reg_field_value_ex(reg_val, mask1, shift1);\n\t*field_value2 = get_reg_field_value_ex(reg_val, mask2, shift2);\n\t*field_value3 = get_reg_field_value_ex(reg_val, mask3, shift3);\n\t*field_value4 = get_reg_field_value_ex(reg_val, mask4, shift4);\n\t*field_value5 = get_reg_field_value_ex(reg_val, mask5, shift5);\n\t*field_value6 = get_reg_field_value_ex(reg_val, mask6, shift6);\n\t*field_value7 = get_reg_field_value_ex(reg_val, mask7, shift7);\n\t*field_value8 = get_reg_field_value_ex(reg_val, mask8, shift8);\n\treturn reg_val;\n}\n \n\nvoid generic_reg_wait(const struct dc_context *ctx,\n\tuint32_t addr, uint32_t shift, uint32_t mask, uint32_t condition_value,\n\tunsigned int delay_between_poll_us, unsigned int time_out_num_tries,\n\tconst char *func_name, int line)\n{\n\tuint32_t field_value;\n\tuint32_t reg_val;\n\tint i;\n\n\tif (ctx->dmub_srv &&\n\t    ctx->dmub_srv->reg_helper_offload.gather_in_progress) {\n\t\tdmub_reg_wait_done_pack(ctx, addr, mask, shift, condition_value,\n\t\t\t\tdelay_between_poll_us * time_out_num_tries);\n\t\treturn;\n\t}\n\n\t \n\tASSERT(delay_between_poll_us * time_out_num_tries <= 3000000);\n\n\tfor (i = 0; i <= time_out_num_tries; i++) {\n\t\tif (i) {\n\t\t\tif (delay_between_poll_us >= 1000)\n\t\t\t\tmsleep(delay_between_poll_us/1000);\n\t\t\telse if (delay_between_poll_us > 0)\n\t\t\t\tudelay(delay_between_poll_us);\n\t\t}\n\n\t\treg_val = dm_read_reg(ctx, addr);\n\n\t\tfield_value = get_reg_field_value_ex(reg_val, mask, shift);\n\n\t\tif (field_value == condition_value) {\n\t\t\tif (i * delay_between_poll_us > 1000)\n\t\t\t\tDC_LOG_DC(\"REG_WAIT taking a while: %dms in %s line:%d\\n\",\n\t\t\t\t\t\tdelay_between_poll_us * i / 1000,\n\t\t\t\t\t\tfunc_name, line);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDC_LOG_WARNING(\"REG_WAIT timeout %dus * %d tries - %s line:%d\\n\",\n\t\t\tdelay_between_poll_us, time_out_num_tries,\n\t\t\tfunc_name, line);\n\n\tBREAK_TO_DEBUGGER();\n}\n\nvoid generic_write_indirect_reg(const struct dc_context *ctx,\n\t\tuint32_t addr_index, uint32_t addr_data,\n\t\tuint32_t index, uint32_t data)\n{\n\tdm_write_reg(ctx, addr_index, index);\n\tdm_write_reg(ctx, addr_data, data);\n}\n\nuint32_t generic_read_indirect_reg(const struct dc_context *ctx,\n\t\tuint32_t addr_index, uint32_t addr_data,\n\t\tuint32_t index)\n{\n\tuint32_t value = 0;\n\n\t\n\tif (ctx->dmub_srv &&\n\t    ctx->dmub_srv->reg_helper_offload.gather_in_progress) {\n\t\tASSERT(false);\n\t}\n\n\tdm_write_reg(ctx, addr_index, index);\n\tvalue = dm_read_reg(ctx, addr_data);\n\n\treturn value;\n}\n\nuint32_t generic_indirect_reg_get(const struct dc_context *ctx,\n\t\tuint32_t addr_index, uint32_t addr_data,\n\t\tuint32_t index, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\t...)\n{\n\tuint32_t shift, mask, *field_value;\n\tuint32_t value = 0;\n\tint i = 1;\n\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\tvalue = generic_read_indirect_reg(ctx, addr_index, addr_data, index);\n\t*field_value1 = get_reg_field_value_ex(value, mask1, shift1);\n\n\twhile (i < n) {\n\t\tshift = va_arg(ap, uint32_t);\n\t\tmask = va_arg(ap, uint32_t);\n\t\tfield_value = va_arg(ap, uint32_t *);\n\n\t\t*field_value = get_reg_field_value_ex(value, mask, shift);\n\t\ti++;\n\t}\n\n\tva_end(ap);\n\n\treturn value;\n}\n\nuint32_t generic_indirect_reg_update_ex(const struct dc_context *ctx,\n\t\tuint32_t addr_index, uint32_t addr_data,\n\t\tuint32_t index, uint32_t reg_val, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1,\n\t\t...)\n{\n\tuint32_t shift, mask, field_value;\n\tint i = 1;\n\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\treg_val = set_reg_field_value_ex(reg_val, field_value1, mask1, shift1);\n\n\twhile (i < n) {\n\t\tshift = va_arg(ap, uint32_t);\n\t\tmask = va_arg(ap, uint32_t);\n\t\tfield_value = va_arg(ap, uint32_t);\n\n\t\treg_val = set_reg_field_value_ex(reg_val, field_value, mask, shift);\n\t\ti++;\n\t}\n\n\tgeneric_write_indirect_reg(ctx, addr_index, addr_data, index, reg_val);\n\tva_end(ap);\n\n\treturn reg_val;\n}\n\n\nuint32_t generic_indirect_reg_update_ex_sync(const struct dc_context *ctx,\n\t\tuint32_t index, uint32_t reg_val, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t field_value1,\n\t\t...)\n{\n\tuint32_t shift, mask, field_value;\n\tint i = 1;\n\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\treg_val = set_reg_field_value_ex(reg_val, field_value1, mask1, shift1);\n\n\twhile (i < n) {\n\t\tshift = va_arg(ap, uint32_t);\n\t\tmask = va_arg(ap, uint32_t);\n\t\tfield_value = va_arg(ap, uint32_t);\n\n\t\treg_val = set_reg_field_value_ex(reg_val, field_value, mask, shift);\n\t\ti++;\n\t}\n\n\tdm_write_index_reg(ctx, CGS_IND_REG__PCIE, index, reg_val);\n\tva_end(ap);\n\n\treturn reg_val;\n}\n\nuint32_t generic_indirect_reg_get_sync(const struct dc_context *ctx,\n\t\tuint32_t index, int n,\n\t\tuint8_t shift1, uint32_t mask1, uint32_t *field_value1,\n\t\t...)\n{\n\tuint32_t shift, mask, *field_value;\n\tuint32_t value = 0;\n\tint i = 1;\n\n\tva_list ap;\n\n\tva_start(ap, field_value1);\n\n\tvalue = dm_read_index_reg(ctx, CGS_IND_REG__PCIE, index);\n\t*field_value1 = get_reg_field_value_ex(value, mask1, shift1);\n\n\twhile (i < n) {\n\t\tshift = va_arg(ap, uint32_t);\n\t\tmask = va_arg(ap, uint32_t);\n\t\tfield_value = va_arg(ap, uint32_t *);\n\n\t\t*field_value = get_reg_field_value_ex(value, mask, shift);\n\t\ti++;\n\t}\n\n\tva_end(ap);\n\n\treturn value;\n}\n\nvoid reg_sequence_start_gather(const struct dc_context *ctx)\n{\n\t \n\n\tif (ctx->dmub_srv && ctx->dc->debug.dmub_offload_enabled) {\n\t\tstruct dc_reg_helper_state *offload =\n\t\t\t&ctx->dmub_srv->reg_helper_offload;\n\n\t\t \n\t\tASSERT(!offload->gather_in_progress);\n\n\t\toffload->gather_in_progress = true;\n\t}\n}\n\nvoid reg_sequence_start_execute(const struct dc_context *ctx)\n{\n\tstruct dc_reg_helper_state *offload;\n\n\tif (!ctx->dmub_srv)\n\t\treturn;\n\n\toffload = &ctx->dmub_srv->reg_helper_offload;\n\n\tif (offload && offload->gather_in_progress) {\n\t\toffload->gather_in_progress = false;\n\t\toffload->should_burst_write = false;\n\t\tswitch (offload->cmd_data.cmd_common.header.type) {\n\t\tcase DMUB_CMD__REG_SEQ_READ_MODIFY_WRITE:\n\t\t\tsubmit_dmub_read_modify_write(offload, ctx);\n\t\t\tbreak;\n\t\tcase DMUB_CMD__REG_REG_WAIT:\n\t\t\tsubmit_dmub_reg_wait(offload, ctx);\n\t\t\tbreak;\n\t\tcase DMUB_CMD__REG_SEQ_BURST_WRITE:\n\t\t\tsubmit_dmub_burst_write(offload, ctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid reg_sequence_wait_done(const struct dc_context *ctx)\n{\n\t \n\tstruct dc_reg_helper_state *offload;\n\n\tif (!ctx->dmub_srv)\n\t\treturn;\n\n\toffload = &ctx->dmub_srv->reg_helper_offload;\n\n\tif (offload &&\n\t    ctx->dc->debug.dmub_offload_enabled &&\n\t    !ctx->dc->debug.dmcub_emulation) {\n\t\tdc_dmub_srv_wait_idle(ctx->dmub_srv);\n\t}\n}\n\nchar *dce_version_to_string(const int version)\n{\n\tswitch (version) {\n\tcase DCE_VERSION_8_0:\n\t\treturn \"DCE 8.0\";\n\tcase DCE_VERSION_8_1:\n\t\treturn \"DCE 8.1\";\n\tcase DCE_VERSION_8_3:\n\t\treturn \"DCE 8.3\";\n\tcase DCE_VERSION_10_0:\n\t\treturn \"DCE 10.0\";\n\tcase DCE_VERSION_11_0:\n\t\treturn \"DCE 11.0\";\n\tcase DCE_VERSION_11_2:\n\t\treturn \"DCE 11.2\";\n\tcase DCE_VERSION_11_22:\n\t\treturn \"DCE 11.22\";\n\tcase DCE_VERSION_12_0:\n\t\treturn \"DCE 12.0\";\n\tcase DCE_VERSION_12_1:\n\t\treturn \"DCE 12.1\";\n\tcase DCN_VERSION_1_0:\n\t\treturn \"DCN 1.0\";\n\tcase DCN_VERSION_1_01:\n\t\treturn \"DCN 1.0.1\";\n\tcase DCN_VERSION_2_0:\n\t\treturn \"DCN 2.0\";\n\tcase DCN_VERSION_2_1:\n\t\treturn \"DCN 2.1\";\n\tcase DCN_VERSION_2_01:\n\t\treturn \"DCN 2.0.1\";\n\tcase DCN_VERSION_3_0:\n\t\treturn \"DCN 3.0\";\n\tcase DCN_VERSION_3_01:\n\t\treturn \"DCN 3.0.1\";\n\tcase DCN_VERSION_3_02:\n\t\treturn \"DCN 3.0.2\";\n\tcase DCN_VERSION_3_03:\n\t\treturn \"DCN 3.0.3\";\n\tcase DCN_VERSION_3_1:\n\t\treturn \"DCN 3.1\";\n\tcase DCN_VERSION_3_14:\n\t\treturn \"DCN 3.1.4\";\n\tcase DCN_VERSION_3_15:\n\t\treturn \"DCN 3.1.5\";\n\tcase DCN_VERSION_3_16:\n\t\treturn \"DCN 3.1.6\";\n\tcase DCN_VERSION_3_2:\n\t\treturn \"DCN 3.2\";\n\tcase DCN_VERSION_3_21:\n\t\treturn \"DCN 3.2.1\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}