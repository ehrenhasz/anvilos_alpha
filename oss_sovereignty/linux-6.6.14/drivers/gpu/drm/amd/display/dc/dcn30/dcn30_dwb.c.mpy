{
  "module_name": "dcn30_dwb.c",
  "hash_id": "720ccbdbe2b3a7ebb5bd4e55959b877507eea4903364a2417ab80c8390f52c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn30/dcn30_dwb.c",
  "human_readable_source": " \n\n\n#include \"reg_helper.h\"\n#include \"resource.h\"\n#include \"dwb.h\"\n#include \"dcn30_dwb.h\"\n\n\n#define REG(reg)\\\n\tdwbc30->dwbc_regs->reg\n\n#define CTX \\\n\tdwbc30->base.ctx\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\tdwbc30->dwbc_shift->field_name, dwbc30->dwbc_mask->field_name\n\n#define DC_LOGGER \\\n\tdwbc30->base.ctx->logger\n\nstatic bool dwb3_get_caps(struct dwbc *dwbc, struct dwb_caps *caps)\n{\n\tif (caps) {\n\t\tcaps->adapter_id = 0;\t \n\t\tcaps->hw_version = DCN_VERSION_3_0;\n\t\tcaps->num_pipes = 2;\n\t\tmemset(&caps->reserved, 0, sizeof(caps->reserved));\n\t\tmemset(&caps->reserved2, 0, sizeof(caps->reserved2));\n\t\tcaps->sw_version = dwb_ver_2_0;\n\t\tcaps->caps.support_dwb = true;\n\t\tcaps->caps.support_ogam = true;\n\t\tcaps->caps.support_wbscl = true;\n\t\tcaps->caps.support_ocsc = false;\n\t\tcaps->caps.support_stereo = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvoid dwb3_config_fc(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\t \n\tREG_UPDATE_2(FC_SOURCE_SIZE, FC_SOURCE_WIDTH, params->cnv_params.src_width,\n\t\t\tFC_SOURCE_HEIGHT, params->cnv_params.src_height);\n\n\t \n\tif (params->cnv_params.crop_en) {\n\t\tREG_UPDATE(FC_MODE_CTRL,    FC_WINDOW_CROP_EN, 1);\n\t\tREG_UPDATE(FC_WINDOW_START, FC_WINDOW_START_X, params->cnv_params.crop_x);\n\t\tREG_UPDATE(FC_WINDOW_START, FC_WINDOW_START_Y, params->cnv_params.crop_y);\n\t\tREG_UPDATE(FC_WINDOW_SIZE,  FC_WINDOW_WIDTH,   params->cnv_params.crop_width);\n\t\tREG_UPDATE(FC_WINDOW_SIZE,  FC_WINDOW_HEIGHT,  params->cnv_params.crop_height);\n\t} else {\n\t\tREG_UPDATE(FC_MODE_CTRL,    FC_WINDOW_CROP_EN, 0);\n\t}\n\n\t \n\tREG_UPDATE(FC_MODE_CTRL, FC_FRAME_CAPTURE_RATE, params->capture_rate);\n\n\tdwb3_set_stereo(dwbc, &params->stereo_params);\n}\n\nbool dwb3_enable(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\tDC_LOG_DWB(\"%s dwb3_enabled at inst = %d\", __func__, dwbc->inst);\n\n\t \n\tREG_UPDATE(DWB_ENABLE_CLK_CTRL, DWB_ENABLE, 1);\n\n\t \n\tdwb3_config_fc(dwbc, params);\n\n\t \n\tdwb3_program_hdr_mult(dwbc, params);\n\tdwb3_set_gamut_remap(dwbc, params);\n\tdwb3_ogam_set_input_transfer_func(dwbc, params->out_transfer_func);\n\n\t \n\tdwb3_set_denorm(dwbc, params);\n\n\t \n\tREG_UPDATE(FC_MODE_CTRL, FC_FRAME_CAPTURE_EN, DWB_FRAME_CAPTURE_ENABLE);\n\n\t \n\tREG_UPDATE(FC_FLOW_CTRL, FC_FIRST_PIXEL_DELAY_COUNT, 96);\n\n\treturn true;\n}\n\nbool dwb3_disable(struct dwbc *dwbc)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\t \n\tREG_UPDATE(FC_MODE_CTRL, FC_FRAME_CAPTURE_EN, DWB_FRAME_CAPTURE_DISABLE);\n\n\t \n\tREG_UPDATE(DWB_ENABLE_CLK_CTRL, DWB_ENABLE, 0);\n\n\tDC_LOG_DWB(\"%s dwb3_disabled at inst = %d\", __func__, dwbc->inst);\n\treturn true;\n}\n\nbool dwb3_update(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\tunsigned int pre_locked;\n\n\t \n\tREG_GET(DWB_UPDATE_CTRL, DWB_UPDATE_LOCK, &pre_locked);\n\tDC_LOG_DWB(\"%s dwb update, inst = %d\", __func__, dwbc->inst);\n\n\tif (pre_locked == 0) {\n\t\t \n\t\tREG_UPDATE(DWB_UPDATE_CTRL, DWB_UPDATE_LOCK, 1);\n\t}\n\n\t \n\tdwb3_config_fc(dwbc, params);\n\n\t \n\tdwb3_program_hdr_mult(dwbc, params);\n\tdwb3_set_gamut_remap(dwbc, params);\n\tdwb3_ogam_set_input_transfer_func(dwbc, params->out_transfer_func);\n\n\t \n\tdwb3_set_denorm(dwbc, params);\n\n\tif (pre_locked == 0) {\n\t\t \n\t\tREG_UPDATE(DWB_UPDATE_CTRL, DWB_UPDATE_LOCK, 0);\n\t}\n\n\treturn true;\n}\n\nbool dwb3_is_enabled(struct dwbc *dwbc)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\tunsigned int dwb_enabled = 0;\n\tunsigned int fc_frame_capture_en = 0;\n\n\tREG_GET(DWB_ENABLE_CLK_CTRL, DWB_ENABLE, &dwb_enabled);\n\tREG_GET(FC_MODE_CTRL, FC_FRAME_CAPTURE_EN, &fc_frame_capture_en);\n\n\treturn ((dwb_enabled != 0) && (fc_frame_capture_en != 0));\n}\n\nvoid dwb3_set_stereo(struct dwbc *dwbc,\n\t\tstruct dwb_stereo_params *stereo_params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\tif (stereo_params->stereo_enabled) {\n\t\tREG_UPDATE(FC_MODE_CTRL, FC_EYE_SELECTION,       stereo_params->stereo_eye_select);\n\t\tREG_UPDATE(FC_MODE_CTRL, FC_STEREO_EYE_POLARITY, stereo_params->stereo_polarity);\n\t\tDC_LOG_DWB(\"%s dwb stereo enabled\", __func__);\n\t} else {\n\t\tREG_UPDATE(FC_MODE_CTRL, FC_EYE_SELECTION, 0);\n\t\tDC_LOG_DWB(\"%s dwb stereo disabled\", __func__);\n\t}\n}\n\nvoid dwb3_set_new_content(struct dwbc *dwbc,\n\t\t\t\t\t\tbool is_new_content)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\tREG_UPDATE(FC_MODE_CTRL, FC_NEW_CONTENT, is_new_content);\n}\n\nvoid dwb3_set_denorm(struct dwbc *dwbc, struct dc_dwb_params *params)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\t \n\tREG_UPDATE(DWB_OUT_CTRL, OUT_FORMAT, params->cnv_params.fc_out_format);\n\n\t \n\tif (params->cnv_params.fc_out_format == DWB_OUT_FORMAT_32BPP_ARGB ||\n\t\t\tparams->cnv_params.fc_out_format == DWB_OUT_FORMAT_32BPP_RGBA) {\n\t\tREG_UPDATE(DWB_OUT_CTRL, OUT_DENORM, params->cnv_params.out_denorm_mode);\n\t\tREG_UPDATE(DWB_OUT_CTRL, OUT_MAX,    params->cnv_params.out_max_pix_val);\n\t\tREG_UPDATE(DWB_OUT_CTRL, OUT_MIN,    params->cnv_params.out_min_pix_val);\n\t}\n}\n\n\nstatic const struct dwbc_funcs dcn30_dwbc_funcs = {\n\t.get_caps\t\t= dwb3_get_caps,\n\t.enable\t\t\t= dwb3_enable,\n\t.disable\t\t= dwb3_disable,\n\t.update\t\t\t= dwb3_update,\n\t.is_enabled\t\t= dwb3_is_enabled,\n\t.set_stereo\t\t= dwb3_set_stereo,\n\t.set_new_content\t= dwb3_set_new_content,\n\t.dwb_program_output_csc\t= NULL,\n\t.dwb_ogam_set_input_transfer_func\t= dwb3_ogam_set_input_transfer_func, \n\t.dwb_set_scaler\t\t= NULL,\n};\n\nvoid dcn30_dwbc_construct(struct dcn30_dwbc *dwbc30,\n\t\tstruct dc_context *ctx,\n\t\tconst struct dcn30_dwbc_registers *dwbc_regs,\n\t\tconst struct dcn30_dwbc_shift *dwbc_shift,\n\t\tconst struct dcn30_dwbc_mask *dwbc_mask,\n\t\tint inst)\n{\n\tdwbc30->base.ctx = ctx;\n\n\tdwbc30->base.inst = inst;\n\tdwbc30->base.funcs = &dcn30_dwbc_funcs;\n\n\tdwbc30->dwbc_regs = dwbc_regs;\n\tdwbc30->dwbc_shift = dwbc_shift;\n\tdwbc30->dwbc_mask = dwbc_mask;\n}\n\nvoid dwb3_set_host_read_rate_control(struct dwbc *dwbc, bool host_read_delay)\n{\n\tstruct dcn30_dwbc *dwbc30 = TO_DCN30_DWBC(dwbc);\n\n\t \n\tREG_UPDATE(DWB_HOST_READ_CONTROL, DWB_HOST_READ_RATE_CONTROL, host_read_delay);\n\n\tDC_LOG_DWB(\"%s dwb3_rate_control at inst = %d\", __func__, dwbc->inst);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}