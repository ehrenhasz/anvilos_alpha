{
  "module_name": "dce_transform.c",
  "hash_id": "7919b2823e014d5abd213be8befb856d2edabb9f19faceaca2661dd4066cda4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_transform.c",
  "human_readable_source": " \n\n#include \"dce_transform.h\"\n#include \"reg_helper.h\"\n#include \"opp.h\"\n#include \"basics/conversion.h\"\n#include \"dc.h\"\n\n#define REG(reg) \\\n\t(xfm_dce->regs->reg)\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\txfm_dce->xfm_shift->field_name, xfm_dce->xfm_mask->field_name\n\n#define CTX \\\n\txfm_dce->base.ctx\n#define DC_LOGGER \\\n\txfm_dce->base.ctx->logger\n\n#define IDENTITY_RATIO(ratio) (dc_fixpt_u2d19(ratio) == (1 << 19))\n#define GAMUT_MATRIX_SIZE 12\n#define SCL_PHASES 16\n\nenum dcp_out_trunc_round_mode {\n\tDCP_OUT_TRUNC_ROUND_MODE_TRUNCATE,\n\tDCP_OUT_TRUNC_ROUND_MODE_ROUND\n};\n\nenum dcp_out_trunc_round_depth {\n\tDCP_OUT_TRUNC_ROUND_DEPTH_14BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_13BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_12BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_11BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_10BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_9BIT,\n\tDCP_OUT_TRUNC_ROUND_DEPTH_8BIT\n};\n\n \nenum dcp_bit_depth_reduction_mode {\n\tDCP_BIT_DEPTH_REDUCTION_MODE_DITHER,\n\tDCP_BIT_DEPTH_REDUCTION_MODE_ROUND,\n\tDCP_BIT_DEPTH_REDUCTION_MODE_TRUNCATE,\n\tDCP_BIT_DEPTH_REDUCTION_MODE_DISABLED,\n\tDCP_BIT_DEPTH_REDUCTION_MODE_INVALID\n};\n\nenum dcp_spatial_dither_mode {\n\tDCP_SPATIAL_DITHER_MODE_AAAA,\n\tDCP_SPATIAL_DITHER_MODE_A_AA_A,\n\tDCP_SPATIAL_DITHER_MODE_AABBAABB,\n\tDCP_SPATIAL_DITHER_MODE_AABBCCAABBCC,\n\tDCP_SPATIAL_DITHER_MODE_INVALID\n};\n\nenum dcp_spatial_dither_depth {\n\tDCP_SPATIAL_DITHER_DEPTH_30BPP,\n\tDCP_SPATIAL_DITHER_DEPTH_24BPP\n};\n\nenum csc_color_mode {\n\t \n\tCSC_COLOR_MODE_GRAPHICS_BYPASS,\n\t \n\tCSC_COLOR_MODE_GRAPHICS_PREDEFINED,\n\t \n\tCSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC,\n};\n\nenum grph_color_adjust_option {\n\tGRPH_COLOR_MATRIX_HW_DEFAULT = 1,\n\tGRPH_COLOR_MATRIX_SW\n};\n\nstatic const struct out_csc_color_matrix global_color_matrix[] = {\n{ COLOR_SPACE_SRGB,\n\t{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },\n{ COLOR_SPACE_SRGB_LIMITED,\n\t{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },\n{ COLOR_SPACE_YCBCR601,\n\t{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,\n\t\t0xF6B9, 0xE00, 0x1000} },\n{ COLOR_SPACE_YCBCR709, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,\n\t0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },\n \n{ COLOR_SPACE_YCBCR601_LIMITED, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,\n\t0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },\n{ COLOR_SPACE_YCBCR709_LIMITED, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,\n\t0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} }\n};\n\nstatic bool setup_scaling_configuration(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data)\n{\n\tREG_SET(SCL_BYPASS_CONTROL, 0, SCL_BYPASS_MODE, 0);\n\n\tif (data->taps.h_taps + data->taps.v_taps <= 2) {\n\t\t \n\t\tif (xfm_dce->xfm_mask->SCL_PSCL_EN != 0)\n\t\t\tREG_UPDATE_2(SCL_MODE, SCL_MODE, 0, SCL_PSCL_EN, 0);\n\t\telse\n\t\t\tREG_UPDATE(SCL_MODE, SCL_MODE, 0);\n\t\treturn false;\n\t}\n\n\tREG_SET_2(SCL_TAP_CONTROL, 0,\n\t\t\tSCL_H_NUM_OF_TAPS, data->taps.h_taps - 1,\n\t\t\tSCL_V_NUM_OF_TAPS, data->taps.v_taps - 1);\n\n\tif (data->format <= PIXEL_FORMAT_GRPH_END)\n\t\tREG_UPDATE(SCL_MODE, SCL_MODE, 1);\n\telse\n\t\tREG_UPDATE(SCL_MODE, SCL_MODE, 2);\n\n\tif (xfm_dce->xfm_mask->SCL_PSCL_EN != 0)\n\t\tREG_UPDATE(SCL_MODE, SCL_PSCL_EN, 1);\n\n\t \n\tREG_SET(SCL_CONTROL, 0, SCL_BOUNDARY_MODE, 1);\n\n\treturn true;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic bool dce60_setup_scaling_configuration(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data)\n{\n\tREG_SET(SCL_BYPASS_CONTROL, 0, SCL_BYPASS_MODE, 0);\n\n\tif (data->taps.h_taps + data->taps.v_taps <= 2) {\n\t\t \n\n\t\t \n\n\t\treturn false;\n\t}\n\n\tREG_SET_2(SCL_TAP_CONTROL, 0,\n\t\t\tSCL_H_NUM_OF_TAPS, data->taps.h_taps - 1,\n\t\t\tSCL_V_NUM_OF_TAPS, data->taps.v_taps - 1);\n\n\t \n\n\t \n\n\treturn true;\n}\n#endif\n\nstatic void program_overscan(\n\t\tstruct dce_transform *xfm_dce,\n\t\tconst struct scaler_data *data)\n{\n\tint overscan_right = data->h_active\n\t\t\t- data->recout.x - data->recout.width;\n\tint overscan_bottom = data->v_active\n\t\t\t- data->recout.y - data->recout.height;\n\n\tif (xfm_dce->base.ctx->dc->debug.visual_confirm != VISUAL_CONFIRM_DISABLE) {\n\t\toverscan_bottom += 2;\n\t\toverscan_right += 2;\n\t}\n\n\tif (overscan_right < 0) {\n\t\tBREAK_TO_DEBUGGER();\n\t\toverscan_right = 0;\n\t}\n\tif (overscan_bottom < 0) {\n\t\tBREAK_TO_DEBUGGER();\n\t\toverscan_bottom = 0;\n\t}\n\n\tREG_SET_2(EXT_OVERSCAN_LEFT_RIGHT, 0,\n\t\t\tEXT_OVERSCAN_LEFT, data->recout.x,\n\t\t\tEXT_OVERSCAN_RIGHT, overscan_right);\n\tREG_SET_2(EXT_OVERSCAN_TOP_BOTTOM, 0,\n\t\t\tEXT_OVERSCAN_TOP, data->recout.y,\n\t\t\tEXT_OVERSCAN_BOTTOM, overscan_bottom);\n}\n\nstatic void program_multi_taps_filter(\n\tstruct dce_transform *xfm_dce,\n\tint taps,\n\tconst uint16_t *coeffs,\n\tenum ram_filter_type filter_type)\n{\n\tint phase, pair;\n\tint array_idx = 0;\n\tint taps_pairs = (taps + 1) / 2;\n\tint phases_to_program = SCL_PHASES / 2 + 1;\n\n\tuint32_t power_ctl = 0;\n\n\tif (!coeffs)\n\t\treturn;\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL)) {\n\t\tpower_ctl = REG_READ(DCFE_MEM_PWR_CTRL);\n\t\tREG_SET(DCFE_MEM_PWR_CTRL, power_ctl, SCL_COEFF_MEM_PWR_DIS, 1);\n\n\t\tREG_WAIT(DCFE_MEM_PWR_STATUS, SCL_COEFF_MEM_PWR_STATE, 0, 1, 10);\n\t}\n\tfor (phase = 0; phase < phases_to_program; phase++) {\n\t\t \n\t\tfor (pair = 0; pair < taps_pairs; pair++) {\n\t\t\tuint16_t odd_coeff = 0;\n\t\t\tuint16_t even_coeff = coeffs[array_idx];\n\n\t\t\tREG_SET_3(SCL_COEF_RAM_SELECT, 0,\n\t\t\t\t\tSCL_C_RAM_FILTER_TYPE, filter_type,\n\t\t\t\t\tSCL_C_RAM_PHASE, phase,\n\t\t\t\t\tSCL_C_RAM_TAP_PAIR_IDX, pair);\n\n\t\t\tif (taps % 2 && pair == taps_pairs - 1)\n\t\t\t\tarray_idx++;\n\t\t\telse {\n\t\t\t\todd_coeff = coeffs[array_idx + 1];\n\t\t\t\tarray_idx += 2;\n\t\t\t}\n\n\t\t\tREG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,\n\t\t\t\t\tSCL_C_RAM_EVEN_TAP_COEF_EN, 1,\n\t\t\t\t\tSCL_C_RAM_EVEN_TAP_COEF, even_coeff,\n\t\t\t\t\tSCL_C_RAM_ODD_TAP_COEF_EN, 1,\n\t\t\t\t\tSCL_C_RAM_ODD_TAP_COEF, odd_coeff);\n\t\t}\n\t}\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_WRITE(DCFE_MEM_PWR_CTRL, power_ctl);\n}\n\nstatic void program_viewport(\n\tstruct dce_transform *xfm_dce,\n\tconst struct rect *view_port)\n{\n\tREG_SET_2(VIEWPORT_START, 0,\n\t\t\tVIEWPORT_X_START, view_port->x,\n\t\t\tVIEWPORT_Y_START, view_port->y);\n\n\tREG_SET_2(VIEWPORT_SIZE, 0,\n\t\t\tVIEWPORT_HEIGHT, view_port->height,\n\t\t\tVIEWPORT_WIDTH, view_port->width);\n\n\t \n}\n\nstatic void calculate_inits(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data,\n\tstruct scl_ratios_inits *inits)\n{\n\tstruct fixed31_32 h_init;\n\tstruct fixed31_32 v_init;\n\n\tinits->h_int_scale_ratio =\n\t\tdc_fixpt_u2d19(data->ratios.horz) << 5;\n\tinits->v_int_scale_ratio =\n\t\tdc_fixpt_u2d19(data->ratios.vert) << 5;\n\n\th_init =\n\t\tdc_fixpt_div_int(\n\t\t\tdc_fixpt_add(\n\t\t\t\tdata->ratios.horz,\n\t\t\t\tdc_fixpt_from_int(data->taps.h_taps + 1)),\n\t\t\t\t2);\n\tinits->h_init.integer = dc_fixpt_floor(h_init);\n\tinits->h_init.fraction = dc_fixpt_u0d19(h_init) << 5;\n\n\tv_init =\n\t\tdc_fixpt_div_int(\n\t\t\tdc_fixpt_add(\n\t\t\t\tdata->ratios.vert,\n\t\t\t\tdc_fixpt_from_int(data->taps.v_taps + 1)),\n\t\t\t\t2);\n\tinits->v_init.integer = dc_fixpt_floor(v_init);\n\tinits->v_init.fraction = dc_fixpt_u0d19(v_init) << 5;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_calculate_inits(\n\tstruct dce_transform *xfm_dce,\n\tconst struct scaler_data *data,\n\tstruct sclh_ratios_inits *inits)\n{\n\tstruct fixed31_32 v_init;\n\n\tinits->h_int_scale_ratio =\n\t\tdc_fixpt_u2d19(data->ratios.horz) << 5;\n\tinits->v_int_scale_ratio =\n\t\tdc_fixpt_u2d19(data->ratios.vert) << 5;\n\n\t \n\tinits->h_init_luma.integer = 1;\n\n\t \n\tinits->h_init_chroma.integer = 1;\n\n\tv_init =\n\t\tdc_fixpt_div_int(\n\t\t\tdc_fixpt_add(\n\t\t\t\tdata->ratios.vert,\n\t\t\t\tdc_fixpt_from_int(data->taps.v_taps + 1)),\n\t\t\t\t2);\n\tinits->v_init.integer = dc_fixpt_floor(v_init);\n\tinits->v_init.fraction = dc_fixpt_u0d19(v_init) << 5;\n}\n#endif\n\nstatic void program_scl_ratios_inits(\n\tstruct dce_transform *xfm_dce,\n\tstruct scl_ratios_inits *inits)\n{\n\n\tREG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_H_SCALE_RATIO, inits->h_int_scale_ratio);\n\n\tREG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_V_SCALE_RATIO, inits->v_int_scale_ratio);\n\n\tREG_SET_2(SCL_HORZ_FILTER_INIT, 0,\n\t\t\tSCL_H_INIT_INT, inits->h_init.integer,\n\t\t\tSCL_H_INIT_FRAC, inits->h_init.fraction);\n\n\tREG_SET_2(SCL_VERT_FILTER_INIT, 0,\n\t\t\tSCL_V_INIT_INT, inits->v_init.integer,\n\t\t\tSCL_V_INIT_FRAC, inits->v_init.fraction);\n\n\tREG_WRITE(SCL_AUTOMATIC_MODE_CONTROL, 0);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_program_scl_ratios_inits(\n\tstruct dce_transform *xfm_dce,\n\tstruct sclh_ratios_inits *inits)\n{\n\n\tREG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_H_SCALE_RATIO, inits->h_int_scale_ratio);\n\n\tREG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,\n\t\t\tSCL_V_SCALE_RATIO, inits->v_int_scale_ratio);\n\n\t \n\tREG_SET_2(SCL_HORZ_FILTER_INIT_RGB_LUMA, 0,\n\t\t\tSCL_H_INIT_INT_RGB_Y, inits->h_init_luma.integer,\n\t\t\tSCL_H_INIT_FRAC_RGB_Y, inits->h_init_luma.fraction);\n\n\t \n\tREG_SET_2(SCL_HORZ_FILTER_INIT_CHROMA, 0,\n\t\t\tSCL_H_INIT_INT_CBCR, inits->h_init_chroma.integer,\n\t\t\tSCL_H_INIT_FRAC_CBCR, inits->h_init_chroma.fraction);\n\n\tREG_SET_2(SCL_VERT_FILTER_INIT, 0,\n\t\t\tSCL_V_INIT_INT, inits->v_init.integer,\n\t\t\tSCL_V_INIT_FRAC, inits->v_init.fraction);\n\n\tREG_WRITE(SCL_AUTOMATIC_MODE_CONTROL, 0);\n}\n#endif\n\nstatic const uint16_t *get_filter_coeffs_16p(int taps, struct fixed31_32 ratio)\n{\n\tif (taps == 4)\n\t\treturn get_filter_4tap_16p(ratio);\n\telse if (taps == 3)\n\t\treturn get_filter_3tap_16p(ratio);\n\telse if (taps == 2)\n\t\treturn get_filter_2tap_16p();\n\telse if (taps == 1)\n\t\treturn NULL;\n\telse {\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n}\n\nstatic void dce_transform_set_scaler(\n\tstruct transform *xfm,\n\tconst struct scaler_data *data)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tbool is_scaling_required;\n\tbool filter_updated = false;\n\tconst uint16_t *coeffs_v, *coeffs_h;\n\n\t \n\tREG_SET_2(LB_MEMORY_CTRL, 0,\n\t\t\tLB_MEMORY_CONFIG, 0,\n\t\t\tLB_MEMORY_SIZE, xfm_dce->lb_memory_size);\n\n\t \n\tREG_WRITE(SCL_F_SHARP_CONTROL, 0);\n\n\t \n\tprogram_overscan(xfm_dce, data);\n\n\t \n\tis_scaling_required = setup_scaling_configuration(xfm_dce, data);\n\n\tif (is_scaling_required) {\n\t\t \n\t\tstruct scl_ratios_inits inits = { 0 };\n\n\t\tcalculate_inits(xfm_dce, data, &inits);\n\n\t\tprogram_scl_ratios_inits(xfm_dce, &inits);\n\n\t\tcoeffs_v = get_filter_coeffs_16p(data->taps.v_taps, data->ratios.vert);\n\t\tcoeffs_h = get_filter_coeffs_16p(data->taps.h_taps, data->ratios.horz);\n\n\t\tif (coeffs_v != xfm_dce->filter_v || coeffs_h != xfm_dce->filter_h) {\n\t\t\t \n\t\t\tif (xfm_dce->filter_v == NULL)\n\t\t\t\tREG_SET(SCL_VERT_FILTER_CONTROL, 0,\n\t\t\t\t\t\tSCL_V_2TAP_HARDCODE_COEF_EN, 0);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps,\n\t\t\t\t\tcoeffs_v,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_VERTICAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps,\n\t\t\t\t\tcoeffs_v,\n\t\t\t\t\tFILTER_TYPE_ALPHA_VERTICAL);\n\n\t\t\t \n\t\t\tif (xfm_dce->filter_h == NULL)\n\t\t\t\tREG_SET(SCL_HORZ_FILTER_CONTROL, 0,\n\t\t\t\t\t\tSCL_H_2TAP_HARDCODE_COEF_EN, 0);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps,\n\t\t\t\t\tcoeffs_h,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_HORIZONTAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps,\n\t\t\t\t\tcoeffs_h,\n\t\t\t\t\tFILTER_TYPE_ALPHA_HORIZONTAL);\n\n\t\t\txfm_dce->filter_v = coeffs_v;\n\t\t\txfm_dce->filter_h = coeffs_h;\n\t\t\tfilter_updated = true;\n\t\t}\n\t}\n\n\t \n\tprogram_viewport(xfm_dce, &data->viewport);\n\n\t \n\tif (filter_updated)\n\t\tREG_UPDATE(SCL_UPDATE, SCL_COEF_UPDATE_COMPLETE, 1);\n\n\tREG_UPDATE(LB_DATA_FORMAT, ALPHA_EN, data->lb_params.alpha_en);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_transform_set_scaler(\n\tstruct transform *xfm,\n\tconst struct scaler_data *data)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tbool is_scaling_required;\n\tconst uint16_t *coeffs_v, *coeffs_h;\n\n\t \n\tREG_SET(DC_LB_MEMORY_SPLIT, 0,\n\t\tDC_LB_MEMORY_CONFIG, 0);\n\n\tREG_SET(DC_LB_MEM_SIZE, 0,\n\t\tDC_LB_MEM_SIZE, xfm_dce->lb_memory_size);\n\n\t \n\tREG_WRITE(SCL_F_SHARP_CONTROL, 0);\n\n\t \n\tprogram_overscan(xfm_dce, data);\n\n\t \n\tis_scaling_required = dce60_setup_scaling_configuration(xfm_dce, data);\n\n\tif (is_scaling_required) {\n\t\t \n\t\tstruct sclh_ratios_inits inits = { 0 };\n\n\t\t \n\t\tdce60_calculate_inits(xfm_dce, data, &inits);\n\n\t\t \n\t\tdce60_program_scl_ratios_inits(xfm_dce, &inits);\n\n\t\tcoeffs_v = get_filter_coeffs_16p(data->taps.v_taps, data->ratios.vert);\n\t\tcoeffs_h = get_filter_coeffs_16p(data->taps.h_taps, data->ratios.horz);\n\n\t\tif (coeffs_v != xfm_dce->filter_v || coeffs_h != xfm_dce->filter_h) {\n\t\t\t \n\t\t\tif (xfm_dce->filter_v == NULL)\n\t\t\t\tREG_SET(SCL_VERT_FILTER_CONTROL, 0,\n\t\t\t\t\t\tSCL_V_2TAP_HARDCODE_COEF_EN, 0);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps,\n\t\t\t\t\tcoeffs_v,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_VERTICAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.v_taps,\n\t\t\t\t\tcoeffs_v,\n\t\t\t\t\tFILTER_TYPE_ALPHA_VERTICAL);\n\n\t\t\t \n\t\t\tif (xfm_dce->filter_h == NULL)\n\t\t\t\tREG_SET(SCL_HORZ_FILTER_CONTROL, 0,\n\t\t\t\t\t\tSCL_H_2TAP_HARDCODE_COEF_EN, 0);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps,\n\t\t\t\t\tcoeffs_h,\n\t\t\t\t\tFILTER_TYPE_RGB_Y_HORIZONTAL);\n\t\t\tprogram_multi_taps_filter(\n\t\t\t\t\txfm_dce,\n\t\t\t\t\tdata->taps.h_taps,\n\t\t\t\t\tcoeffs_h,\n\t\t\t\t\tFILTER_TYPE_ALPHA_HORIZONTAL);\n\n\t\t\txfm_dce->filter_v = coeffs_v;\n\t\t\txfm_dce->filter_h = coeffs_h;\n\t\t}\n\t}\n\n\t \n\tprogram_viewport(xfm_dce, &data->viewport);\n\n\t \n\n\t \n}\n#endif\n\n \nstatic void set_clamp(\n\tstruct dce_transform *xfm_dce,\n\tenum dc_color_depth depth)\n{\n\tint clamp_max = 0;\n\n\t \n\tswitch (depth) {\n\tcase COLOR_DEPTH_666:\n\t\t \n\t\tclamp_max = 0x3F00;\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\t \n\t\tclamp_max = 0x3FC0;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\t \n\t\tclamp_max = 0x3FF0;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\t \n\t\tclamp_max = 0x3FFC;\n\t\tbreak;\n\tdefault:\n\t\tclamp_max = 0x3FC0;\n\t\tBREAK_TO_DEBUGGER();  \n\t}\n\tREG_SET_2(OUT_CLAMP_CONTROL_B_CB, 0,\n\t\t\tOUT_CLAMP_MIN_B_CB, 0,\n\t\t\tOUT_CLAMP_MAX_B_CB, clamp_max);\n\n\tREG_SET_2(OUT_CLAMP_CONTROL_G_Y, 0,\n\t\t\tOUT_CLAMP_MIN_G_Y, 0,\n\t\t\tOUT_CLAMP_MAX_G_Y, clamp_max);\n\n\tREG_SET_2(OUT_CLAMP_CONTROL_R_CR, 0,\n\t\t\tOUT_CLAMP_MIN_R_CR, 0,\n\t\t\tOUT_CLAMP_MAX_R_CR, clamp_max);\n}\n\n \nstatic void set_round(\n\tstruct dce_transform *xfm_dce,\n\tenum dcp_out_trunc_round_mode mode,\n\tenum dcp_out_trunc_round_depth depth)\n{\n\tint depth_bits = 0;\n\tint mode_bit = 0;\n\n\t \n\tswitch (depth) {\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_14BIT:\n\t\tdepth_bits = 6;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_13BIT:\n\t\tdepth_bits = 7;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_12BIT:\n\t\tdepth_bits = 0;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_11BIT:\n\t\tdepth_bits = 1;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_10BIT:\n\t\tdepth_bits = 2;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_9BIT:\n\t\tdepth_bits = 3;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_DEPTH_8BIT:\n\t\tdepth_bits = 4;\n\t\tbreak;\n\tdefault:\n\t\tdepth_bits = 4;\n\t\tBREAK_TO_DEBUGGER();  \n\t}\n\n\t \n\tswitch (mode) {\n\tcase DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE:\n\t\tmode_bit = 0;\n\t\tbreak;\n\tcase DCP_OUT_TRUNC_ROUND_MODE_ROUND:\n\t\tmode_bit = 1;\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();  \n\t}\n\n\tdepth_bits |= mode_bit << 3;\n\n\tREG_SET(OUT_ROUND_CONTROL, 0, OUT_ROUND_TRUNC_MODE, depth_bits);\n}\n\n \n\nstatic void set_dither(\n\tstruct dce_transform *xfm_dce,\n\tbool dither_enable,\n\tenum dcp_spatial_dither_mode dither_mode,\n\tenum dcp_spatial_dither_depth dither_depth,\n\tbool frame_random_enable,\n\tbool rgb_random_enable,\n\tbool highpass_random_enable)\n{\n\tint dither_depth_bits = 0;\n\tint dither_mode_bits = 0;\n\n\tswitch (dither_mode) {\n\tcase DCP_SPATIAL_DITHER_MODE_AAAA:\n\t\tdither_mode_bits = 0;\n\t\tbreak;\n\tcase DCP_SPATIAL_DITHER_MODE_A_AA_A:\n\t\tdither_mode_bits = 1;\n\t\tbreak;\n\tcase DCP_SPATIAL_DITHER_MODE_AABBAABB:\n\t\tdither_mode_bits = 2;\n\t\tbreak;\n\tcase DCP_SPATIAL_DITHER_MODE_AABBCCAABBCC:\n\t\tdither_mode_bits = 3;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t}\n\n\tswitch (dither_depth) {\n\tcase DCP_SPATIAL_DITHER_DEPTH_30BPP:\n\t\tdither_depth_bits = 0;\n\t\tbreak;\n\tcase DCP_SPATIAL_DITHER_DEPTH_24BPP:\n\t\tdither_depth_bits = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBREAK_TO_DEBUGGER();\n\t}\n\n\t \n\tREG_SET_6(DCP_SPATIAL_DITHER_CNTL, 0,\n\t\t\tDCP_SPATIAL_DITHER_EN, dither_enable,\n\t\t\tDCP_SPATIAL_DITHER_MODE, dither_mode_bits,\n\t\t\tDCP_SPATIAL_DITHER_DEPTH, dither_depth_bits,\n\t\t\tDCP_FRAME_RANDOM_ENABLE, frame_random_enable,\n\t\t\tDCP_RGB_RANDOM_ENABLE, rgb_random_enable,\n\t\t\tDCP_HIGHPASS_RANDOM_ENABLE, highpass_random_enable);\n}\n\n \nstatic void program_bit_depth_reduction(\n\tstruct dce_transform *xfm_dce,\n\tenum dc_color_depth depth,\n\tconst struct bit_depth_reduction_params *bit_depth_params)\n{\n\tenum dcp_out_trunc_round_depth trunc_round_depth;\n\tenum dcp_out_trunc_round_mode trunc_mode;\n\tbool spatial_dither_enable;\n\n\tASSERT(depth <= COLOR_DEPTH_121212);  \n\n\tspatial_dither_enable = bit_depth_params->flags.SPATIAL_DITHER_ENABLED;\n\t \n\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_12BIT;\n\ttrunc_mode = DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE;\n\n\tif (bit_depth_params->flags.TRUNCATE_ENABLED) {\n\t\t \n\t\tspatial_dither_enable = false;\n\t\ttrunc_mode = bit_depth_params->flags.TRUNCATE_MODE ?\n\t\t\t     DCP_OUT_TRUNC_ROUND_MODE_ROUND :\n\t\t\t     DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE;\n\n\t\tif (bit_depth_params->flags.TRUNCATE_DEPTH == 0 ||\n\t\t    bit_depth_params->flags.TRUNCATE_DEPTH == 1)\n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_8BIT;\n\t\telse if (bit_depth_params->flags.TRUNCATE_DEPTH == 2)\n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_10BIT;\n\t\telse {\n\t\t\t \n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_12BIT;\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t}\n\n\tset_clamp(xfm_dce, depth);\n\tset_round(xfm_dce, trunc_mode, trunc_round_depth);\n\tset_dither(xfm_dce,\n\t\t   spatial_dither_enable,\n\t\t   DCP_SPATIAL_DITHER_MODE_A_AA_A,\n\t\t   DCP_SPATIAL_DITHER_DEPTH_30BPP,\n\t\t   bit_depth_params->flags.FRAME_RANDOM,\n\t\t   bit_depth_params->flags.RGB_RANDOM,\n\t\t   bit_depth_params->flags.HIGHPASS_RANDOM);\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n \nstatic void dce60_program_bit_depth_reduction(\n\tstruct dce_transform *xfm_dce,\n\tenum dc_color_depth depth,\n\tconst struct bit_depth_reduction_params *bit_depth_params)\n{\n\tenum dcp_out_trunc_round_depth trunc_round_depth;\n\tenum dcp_out_trunc_round_mode trunc_mode;\n\tbool spatial_dither_enable;\n\n\tASSERT(depth <= COLOR_DEPTH_121212);  \n\n\tspatial_dither_enable = bit_depth_params->flags.SPATIAL_DITHER_ENABLED;\n\t \n\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_12BIT;\n\ttrunc_mode = DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE;\n\n\tif (bit_depth_params->flags.TRUNCATE_ENABLED) {\n\t\t \n\t\tspatial_dither_enable = false;\n\t\ttrunc_mode = bit_depth_params->flags.TRUNCATE_MODE ?\n\t\t\t     DCP_OUT_TRUNC_ROUND_MODE_ROUND :\n\t\t\t     DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE;\n\n\t\tif (bit_depth_params->flags.TRUNCATE_DEPTH == 0 ||\n\t\t    bit_depth_params->flags.TRUNCATE_DEPTH == 1)\n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_8BIT;\n\t\telse if (bit_depth_params->flags.TRUNCATE_DEPTH == 2)\n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_10BIT;\n\t\telse {\n\t\t\t \n\t\t\ttrunc_round_depth = DCP_OUT_TRUNC_ROUND_DEPTH_12BIT;\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t}\n\t}\n\n\t \n\tset_round(xfm_dce, trunc_mode, trunc_round_depth);\n\tset_dither(xfm_dce,\n\t\t   spatial_dither_enable,\n\t\t   DCP_SPATIAL_DITHER_MODE_A_AA_A,\n\t\t   DCP_SPATIAL_DITHER_DEPTH_30BPP,\n\t\t   bit_depth_params->flags.FRAME_RANDOM,\n\t\t   bit_depth_params->flags.RGB_RANDOM,\n\t\t   bit_depth_params->flags.HIGHPASS_RANDOM);\n}\n#endif\n\nstatic int dce_transform_get_max_num_of_supported_lines(\n\tstruct dce_transform *xfm_dce,\n\tenum lb_pixel_depth depth,\n\tint pixel_width)\n{\n\tint pixels_per_entries = 0;\n\tint max_pixels_supports = 0;\n\n\tASSERT(pixel_width);\n\n\t \n\tswitch (depth) {\n\tcase LB_PIXEL_DEPTH_18BPP:\n\t\tpixels_per_entries = xfm_dce->lb_bits_per_entry / 18;\n\t\tbreak;\n\n\tcase LB_PIXEL_DEPTH_24BPP:\n\t\tpixels_per_entries = xfm_dce->lb_bits_per_entry / 24;\n\t\tbreak;\n\n\tcase LB_PIXEL_DEPTH_30BPP:\n\t\tpixels_per_entries = xfm_dce->lb_bits_per_entry / 30;\n\t\tbreak;\n\n\tcase LB_PIXEL_DEPTH_36BPP:\n\t\tpixels_per_entries = xfm_dce->lb_bits_per_entry / 36;\n\t\tbreak;\n\n\tdefault:\n\t\tDC_LOG_WARNING(\"%s: Invalid LB pixel depth\",\n\t\t\t__func__);\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tASSERT(pixels_per_entries);\n\n\tmax_pixels_supports =\n\t\t\tpixels_per_entries *\n\t\t\txfm_dce->lb_memory_size;\n\n\treturn (max_pixels_supports / pixel_width);\n}\n\nstatic void set_denormalization(\n\tstruct dce_transform *xfm_dce,\n\tenum dc_color_depth depth)\n{\n\tint denorm_mode = 0;\n\n\tswitch (depth) {\n\tcase COLOR_DEPTH_666:\n\t\t \n\t\tdenorm_mode = 1;\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\t \n\t\tdenorm_mode = 0;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\t \n\t\tdenorm_mode = 3;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\t \n\t\tdenorm_mode = 5;\n\t\tbreak;\n\tcase COLOR_DEPTH_141414:\n\tcase COLOR_DEPTH_161616:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tREG_SET(DENORM_CONTROL, 0, DENORM_MODE, denorm_mode);\n}\n\nstatic void dce_transform_set_pixel_storage_depth(\n\tstruct transform *xfm,\n\tenum lb_pixel_depth depth,\n\tconst struct bit_depth_reduction_params *bit_depth_params)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tint pixel_depth, expan_mode;\n\tenum dc_color_depth color_depth;\n\n\tswitch (depth) {\n\tcase LB_PIXEL_DEPTH_18BPP:\n\t\tcolor_depth = COLOR_DEPTH_666;\n\t\tpixel_depth = 2;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_24BPP:\n\t\tcolor_depth = COLOR_DEPTH_888;\n\t\tpixel_depth = 1;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_30BPP:\n\t\tcolor_depth = COLOR_DEPTH_101010;\n\t\tpixel_depth = 0;\n\t\texpan_mode  = 1;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_36BPP:\n\t\tcolor_depth = COLOR_DEPTH_121212;\n\t\tpixel_depth = 3;\n\t\texpan_mode  = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolor_depth = COLOR_DEPTH_101010;\n\t\tpixel_depth = 0;\n\t\texpan_mode  = 1;\n\t\tDC_LOG_DC(\"The pixel depth %d is not valid, set COLOR_DEPTH_101010 instead.\", depth);\n\t\tbreak;\n\t}\n\n\tset_denormalization(xfm_dce, color_depth);\n\tprogram_bit_depth_reduction(xfm_dce, color_depth, bit_depth_params);\n\n\tREG_UPDATE_2(LB_DATA_FORMAT,\n\t\t\tPIXEL_DEPTH, pixel_depth,\n\t\t\tPIXEL_EXPAN_MODE, expan_mode);\n\n\tif (!(xfm_dce->lb_pixel_depth_supported & depth)) {\n\t\t \n\t\tDC_LOG_DC(\"%s: Capability not supported\", __func__);\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic void dce60_transform_set_pixel_storage_depth(\n\tstruct transform *xfm,\n\tenum lb_pixel_depth depth,\n\tconst struct bit_depth_reduction_params *bit_depth_params)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tenum dc_color_depth color_depth;\n\n\tswitch (depth) {\n\tcase LB_PIXEL_DEPTH_18BPP:\n\t\tcolor_depth = COLOR_DEPTH_666;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_24BPP:\n\t\tcolor_depth = COLOR_DEPTH_888;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_30BPP:\n\t\tcolor_depth = COLOR_DEPTH_101010;\n\t\tbreak;\n\tcase LB_PIXEL_DEPTH_36BPP:\n\t\tcolor_depth = COLOR_DEPTH_121212;\n\t\tbreak;\n\tdefault:\n\t\tcolor_depth = COLOR_DEPTH_101010;\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tset_denormalization(xfm_dce, color_depth);\n\tdce60_program_bit_depth_reduction(xfm_dce, color_depth, bit_depth_params);\n\n\t \n\n\tif (!(xfm_dce->lb_pixel_depth_supported & depth)) {\n\t\t \n\t\tDC_LOG_WARNING(\"%s: Capability not supported\",\n\t\t\t__func__);\n\t}\n}\n#endif\n\nstatic void program_gamut_remap(\n\tstruct dce_transform *xfm_dce,\n\tconst uint16_t *reg_val)\n{\n\tif (reg_val) {\n\t\tREG_SET_2(GAMUT_REMAP_C11_C12, 0,\n\t\t\t\tGAMUT_REMAP_C11, reg_val[0],\n\t\t\t\tGAMUT_REMAP_C12, reg_val[1]);\n\t\tREG_SET_2(GAMUT_REMAP_C13_C14, 0,\n\t\t\t\tGAMUT_REMAP_C13, reg_val[2],\n\t\t\t\tGAMUT_REMAP_C14, reg_val[3]);\n\t\tREG_SET_2(GAMUT_REMAP_C21_C22, 0,\n\t\t\t\tGAMUT_REMAP_C21, reg_val[4],\n\t\t\t\tGAMUT_REMAP_C22, reg_val[5]);\n\t\tREG_SET_2(GAMUT_REMAP_C23_C24, 0,\n\t\t\t\tGAMUT_REMAP_C23, reg_val[6],\n\t\t\t\tGAMUT_REMAP_C24, reg_val[7]);\n\t\tREG_SET_2(GAMUT_REMAP_C31_C32, 0,\n\t\t\t\tGAMUT_REMAP_C31, reg_val[8],\n\t\t\t\tGAMUT_REMAP_C32, reg_val[9]);\n\t\tREG_SET_2(GAMUT_REMAP_C33_C34, 0,\n\t\t\t\tGAMUT_REMAP_C33, reg_val[10],\n\t\t\t\tGAMUT_REMAP_C34, reg_val[11]);\n\n\t\tREG_SET(GAMUT_REMAP_CONTROL, 0, GRPH_GAMUT_REMAP_MODE, 1);\n\t} else\n\t\tREG_SET(GAMUT_REMAP_CONTROL, 0, GRPH_GAMUT_REMAP_MODE, 0);\n\n}\n\n \nstatic void dce_transform_set_gamut_remap(\n\tstruct transform *xfm,\n\tconst struct xfm_grph_csc_adjustment *adjust)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tint i = 0;\n\n\tif (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)\n\t\t \n\t\tprogram_gamut_remap(xfm_dce, NULL);\n\telse {\n\t\tstruct fixed31_32 arr_matrix[GAMUT_MATRIX_SIZE];\n\t\tuint16_t arr_reg_val[GAMUT_MATRIX_SIZE];\n\n\t\tfor (i = 0; i < GAMUT_MATRIX_SIZE; i++)\n\t\t\tarr_matrix[i] = adjust->temperature_matrix[i];\n\n\t\tconvert_float_matrix(\n\t\t\tarr_reg_val, arr_matrix, GAMUT_MATRIX_SIZE);\n\n\t\tprogram_gamut_remap(xfm_dce, arr_reg_val);\n\t}\n}\n\nstatic uint32_t decide_taps(struct fixed31_32 ratio, uint32_t in_taps, bool chroma)\n{\n\tuint32_t taps;\n\n\tif (IDENTITY_RATIO(ratio)) {\n\t\treturn 1;\n\t} else if (in_taps != 0) {\n\t\ttaps = in_taps;\n\t} else {\n\t\ttaps = 4;\n\t}\n\n\tif (chroma) {\n\t\ttaps /= 2;\n\t\tif (taps < 2)\n\t\t\ttaps = 2;\n\t}\n\n\treturn taps;\n}\n\n\nbool dce_transform_get_optimal_number_of_taps(\n\tstruct transform *xfm,\n\tstruct scaler_data *scl_data,\n\tconst struct scaling_taps *in_taps)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tint pixel_width = scl_data->viewport.width;\n\tint max_num_of_lines;\n\n\tif (xfm_dce->prescaler_on &&\n\t\t\t(scl_data->viewport.width > scl_data->recout.width))\n\t\tpixel_width = scl_data->recout.width;\n\n\tmax_num_of_lines = dce_transform_get_max_num_of_supported_lines(\n\t\txfm_dce,\n\t\tscl_data->lb_params.depth,\n\t\tpixel_width);\n\n\t \n\tif (in_taps->v_taps >= max_num_of_lines)\n\t\treturn false;\n\n\t \n\tscl_data->taps.h_taps = decide_taps(scl_data->ratios.horz, in_taps->h_taps, false);\n\tscl_data->taps.v_taps = decide_taps(scl_data->ratios.vert, in_taps->v_taps, false);\n\tscl_data->taps.h_taps_c = decide_taps(scl_data->ratios.horz_c, in_taps->h_taps, true);\n\tscl_data->taps.v_taps_c = decide_taps(scl_data->ratios.vert_c, in_taps->v_taps, true);\n\n\tif (!IDENTITY_RATIO(scl_data->ratios.vert)) {\n\t\t \n\t\tif (in_taps->v_taps == 0\n\t\t\t\t&& max_num_of_lines <= scl_data->taps.v_taps\n\t\t\t\t&& scl_data->taps.v_taps > 1) {\n\t\t\tscl_data->taps.v_taps = max_num_of_lines - 1;\n\t\t}\n\n\t\tif (scl_data->taps.v_taps <= 1)\n\t\t\treturn false;\n\t}\n\n\tif (!IDENTITY_RATIO(scl_data->ratios.vert_c)) {\n\t\t \n\t\tif (max_num_of_lines <= scl_data->taps.v_taps_c && scl_data->taps.v_taps_c > 1) {\n\t\t\tscl_data->taps.v_taps_c = max_num_of_lines - 1;\n\t\t}\n\n\t\tif (scl_data->taps.v_taps_c <= 1)\n\t\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic void dce_transform_reset(struct transform *xfm)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\n\txfm_dce->filter_h = NULL;\n\txfm_dce->filter_v = NULL;\n}\n\nstatic void program_color_matrix(\n\tstruct dce_transform *xfm_dce,\n\tconst struct out_csc_color_matrix *tbl_entry,\n\tenum grph_color_adjust_option options)\n{\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C11_C12, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[0],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[1]);\n\t}\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C13_C14, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[2],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[3]);\n\t}\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C21_C22, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[4],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[5]);\n\t}\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C23_C24, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[6],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[7]);\n\t}\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C31_C32, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[8],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[9]);\n\t}\n\t{\n\t\tREG_SET_2(OUTPUT_CSC_C33_C34, 0,\n\t\t\tOUTPUT_CSC_C11, tbl_entry->regval[10],\n\t\t\tOUTPUT_CSC_C12, tbl_entry->regval[11]);\n\t}\n}\n\nstatic bool configure_graphics_mode(\n\tstruct dce_transform *xfm_dce,\n\tenum csc_color_mode config,\n\tenum graphics_csc_adjust_type csc_adjust_type,\n\tenum dc_color_space color_space)\n{\n\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\tOUTPUT_CSC_GRPH_MODE, 0);\n\n\tif (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_SW) {\n\t\tif (config == CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC) {\n\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\tOUTPUT_CSC_GRPH_MODE, 4);\n\t\t} else {\n\n\t\t\tswitch (color_space) {\n\t\t\tcase COLOR_SPACE_SRGB:\n\t\t\t\t \n\t\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\t\tOUTPUT_CSC_GRPH_MODE, 0);\n\t\t\t\tbreak;\n\t\t\tcase COLOR_SPACE_SRGB_LIMITED:\n\t\t\t\t \n\t\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\t\tOUTPUT_CSC_GRPH_MODE, 1);\n\t\t\t\tbreak;\n\t\t\tcase COLOR_SPACE_YCBCR601:\n\t\t\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\t\t\t\t \n\t\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\t\tOUTPUT_CSC_GRPH_MODE, 2);\n\t\t\t\tbreak;\n\t\t\tcase COLOR_SPACE_YCBCR709:\n\t\t\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\t\t\t\t \n\t\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\t\tOUTPUT_CSC_GRPH_MODE, 3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else if (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_HW) {\n\t\tswitch (color_space) {\n\t\tcase COLOR_SPACE_SRGB:\n\t\t\t \n\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\tOUTPUT_CSC_GRPH_MODE, 0);\n\t\t\tbreak;\n\t\tcase COLOR_SPACE_SRGB_LIMITED:\n\t\t\t \n\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\tOUTPUT_CSC_GRPH_MODE, 1);\n\t\t\tbreak;\n\t\tcase COLOR_SPACE_YCBCR601:\n\t\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\t\t\t \n\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\tOUTPUT_CSC_GRPH_MODE, 2);\n\t\t\tbreak;\n\t\tcase COLOR_SPACE_YCBCR709:\n\t\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\t\t\t  \n\t\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\t\tOUTPUT_CSC_GRPH_MODE, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\t} else\n\t\t \n\t\tREG_SET(OUTPUT_CSC_CONTROL, 0,\n\t\t\tOUTPUT_CSC_GRPH_MODE, 0);\n\n\treturn true;\n}\n\nvoid dce110_opp_set_csc_adjustment(\n\tstruct transform *xfm,\n\tconst struct out_csc_color_matrix *tbl_entry)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tenum csc_color_mode config =\n\t\t\tCSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;\n\n\tprogram_color_matrix(\n\t\t\txfm_dce, tbl_entry, GRPH_COLOR_MATRIX_SW);\n\n\t \n\tconfigure_graphics_mode(xfm_dce, config, GRAPHICS_CSC_ADJUST_TYPE_SW,\n\t\t\ttbl_entry->color_space);\n}\n\nvoid dce110_opp_set_csc_default(\n\tstruct transform *xfm,\n\tconst struct default_adjustment *default_adjust)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\tenum csc_color_mode config =\n\t\t\tCSC_COLOR_MODE_GRAPHICS_PREDEFINED;\n\n\tif (default_adjust->force_hw_default == false) {\n\t\tconst struct out_csc_color_matrix *elm;\n\t\t \n\t\tenum grph_color_adjust_option option =\n\t\t\tGRPH_COLOR_MATRIX_HW_DEFAULT;\n\t\tuint32_t i;\n\t\t \n\t\toption = GRPH_COLOR_MATRIX_SW;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(global_color_matrix); ++i) {\n\t\t\telm = &global_color_matrix[i];\n\t\t\tif (elm->color_space != default_adjust->out_color_space)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tprogram_color_matrix(xfm_dce, elm, option);\n\t\t\tconfig = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tconfigure_graphics_mode(xfm_dce, config,\n\t\tdefault_adjust->csc_adjust_type,\n\t\tdefault_adjust->out_color_space);\n}\n\nstatic void program_pwl(struct dce_transform *xfm_dce,\n\t\t\tconst struct pwl_params *params)\n{\n\tint retval;\n\tuint8_t max_tries = 10;\n\tuint8_t counter = 0;\n\tuint32_t i = 0;\n\tconst struct pwl_result_data *rgb = params->rgb_resulted;\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_UPDATE(DCFE_MEM_PWR_CTRL,\n\t\t\t   DCP_REGAMMA_MEM_PWR_DIS, 1);\n\telse\n\t\tREG_UPDATE(DCFE_MEM_LIGHT_SLEEP_CNTL,\n\t\t\t   REGAMMA_LUT_LIGHT_SLEEP_DIS, 1);\n\n\twhile (counter < max_tries) {\n\t\tif (REG(DCFE_MEM_PWR_STATUS)) {\n\t\t\tREG_GET(DCFE_MEM_PWR_STATUS,\n\t\t\t\tDCP_REGAMMA_MEM_PWR_STATE,\n\t\t\t\t&retval);\n\n\t\t\tif (retval == 0)\n\t\t\t\tbreak;\n\t\t\t++counter;\n\t\t} else {\n\t\t\tREG_GET(DCFE_MEM_LIGHT_SLEEP_CNTL,\n\t\t\t\tREGAMMA_LUT_MEM_PWR_STATE,\n\t\t\t\t&retval);\n\n\t\t\tif (retval == 0)\n\t\t\t\tbreak;\n\t\t\t++counter;\n\t\t}\n\t}\n\n\tif (counter == max_tries) {\n\t\tDC_LOG_WARNING(\"%s: regamma lut was not powered on \"\n\t\t\t\t\"in a timely manner,\"\n\t\t\t\t\" programming still proceeds\\n\",\n\t\t\t\t__func__);\n\t}\n\n\tREG_UPDATE(REGAMMA_LUT_WRITE_EN_MASK,\n\t\t   REGAMMA_LUT_WRITE_EN_MASK, 7);\n\n\tREG_WRITE(REGAMMA_LUT_INDEX, 0);\n\n\t \n\twhile (i != params->hw_points_num) {\n\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->red_reg);\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->green_reg);\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->blue_reg);\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->delta_red_reg);\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->delta_green_reg);\n\t\tREG_WRITE(REGAMMA_LUT_DATA, rgb->delta_blue_reg);\n\n\t\t++rgb;\n\t\t++i;\n\t}\n\n\t \n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_UPDATE(DCFE_MEM_PWR_CTRL,\n\t\t\t   DCP_REGAMMA_MEM_PWR_DIS, 0);\n\telse\n\t\tREG_UPDATE(DCFE_MEM_LIGHT_SLEEP_CNTL,\n\t\t\t   REGAMMA_LUT_LIGHT_SLEEP_DIS, 0);\n}\n\nstatic void regamma_config_regions_and_segments(struct dce_transform *xfm_dce,\n\t\t\t\t\t\tconst struct pwl_params *params)\n{\n\tconst struct gamma_curve *curve;\n\n\tREG_SET_2(REGAMMA_CNTLA_START_CNTL, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION_START, params->arr_points[0].custom_float_x,\n\t\t  REGAMMA_CNTLA_EXP_REGION_START_SEGMENT, 0);\n\n\tREG_SET(REGAMMA_CNTLA_SLOPE_CNTL, 0,\n\t\tREGAMMA_CNTLA_EXP_REGION_LINEAR_SLOPE, params->arr_points[0].custom_float_slope);\n\n\tREG_SET(REGAMMA_CNTLA_END_CNTL1, 0,\n\t\tREGAMMA_CNTLA_EXP_REGION_END, params->arr_points[1].custom_float_x);\n\n\tREG_SET_2(REGAMMA_CNTLA_END_CNTL2, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION_END_BASE, params->arr_points[1].custom_float_y,\n\t\t  REGAMMA_CNTLA_EXP_REGION_END_SLOPE, params->arr_points[1].custom_float_slope);\n\n\tcurve = params->arr_curve_points;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_0_1, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_2_3, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_4_5, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_6_7, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_8_9, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_10_11, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_12_13, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n\tcurve += 2;\n\n\tREG_SET_4(REGAMMA_CNTLA_REGION_14_15, 0,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_LUT_OFFSET, curve[0].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_LUT_OFFSET, curve[1].offset,\n\t\t  REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);\n}\n\n\n\nvoid dce110_opp_program_regamma_pwl(struct transform *xfm,\n\t\t\t\t    const struct pwl_params *params)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\n\t \n\tregamma_config_regions_and_segments(xfm_dce, params);\n\n\t \n\tprogram_pwl(xfm_dce, params);\n}\n\nvoid dce110_opp_power_on_regamma_lut(struct transform *xfm,\n\t\t\t\t     bool power_on)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\n\tif (REG(DCFE_MEM_PWR_CTRL))\n\t\tREG_UPDATE_2(DCFE_MEM_PWR_CTRL,\n\t\t\t     DCP_REGAMMA_MEM_PWR_DIS, power_on,\n\t\t\t     DCP_LUT_MEM_PWR_DIS, power_on);\n\telse\n\t\tREG_UPDATE_2(DCFE_MEM_LIGHT_SLEEP_CNTL,\n\t\t\t    REGAMMA_LUT_LIGHT_SLEEP_DIS, power_on,\n\t\t\t    DCP_LUT_LIGHT_SLEEP_DIS, power_on);\n\n}\n\nvoid dce110_opp_set_regamma_mode(struct transform *xfm,\n\t\t\t\t enum opp_regamma mode)\n{\n\tstruct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);\n\n\tREG_SET(REGAMMA_CONTROL, 0,\n\t\tGRPH_REGAMMA_MODE, mode);\n}\n\nstatic const struct transform_funcs dce_transform_funcs = {\n\t.transform_reset = dce_transform_reset,\n\t.transform_set_scaler = dce_transform_set_scaler,\n\t.transform_set_gamut_remap = dce_transform_set_gamut_remap,\n\t.opp_set_csc_adjustment = dce110_opp_set_csc_adjustment,\n\t.opp_set_csc_default = dce110_opp_set_csc_default,\n\t.opp_power_on_regamma_lut = dce110_opp_power_on_regamma_lut,\n\t.opp_program_regamma_pwl = dce110_opp_program_regamma_pwl,\n\t.opp_set_regamma_mode = dce110_opp_set_regamma_mode,\n\t.transform_set_pixel_storage_depth = dce_transform_set_pixel_storage_depth,\n\t.transform_get_optimal_number_of_taps = dce_transform_get_optimal_number_of_taps\n};\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nstatic const struct transform_funcs dce60_transform_funcs = {\n\t.transform_reset = dce_transform_reset,\n\t.transform_set_scaler = dce60_transform_set_scaler,\n\t.transform_set_gamut_remap = dce_transform_set_gamut_remap,\n\t.opp_set_csc_adjustment = dce110_opp_set_csc_adjustment,\n\t.opp_set_csc_default = dce110_opp_set_csc_default,\n\t.opp_power_on_regamma_lut = dce110_opp_power_on_regamma_lut,\n\t.opp_program_regamma_pwl = dce110_opp_program_regamma_pwl,\n\t.opp_set_regamma_mode = dce110_opp_set_regamma_mode,\n\t.transform_set_pixel_storage_depth = dce60_transform_set_pixel_storage_depth,\n\t.transform_get_optimal_number_of_taps = dce_transform_get_optimal_number_of_taps\n};\n#endif\n\n \n \n \n\nvoid dce_transform_construct(\n\tstruct dce_transform *xfm_dce,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dce_transform_registers *regs,\n\tconst struct dce_transform_shift *xfm_shift,\n\tconst struct dce_transform_mask *xfm_mask)\n{\n\txfm_dce->base.ctx = ctx;\n\n\txfm_dce->base.inst = inst;\n\txfm_dce->base.funcs = &dce_transform_funcs;\n\n\txfm_dce->regs = regs;\n\txfm_dce->xfm_shift = xfm_shift;\n\txfm_dce->xfm_mask = xfm_mask;\n\n\txfm_dce->prescaler_on = true;\n\txfm_dce->lb_pixel_depth_supported =\n\t\t\tLB_PIXEL_DEPTH_18BPP |\n\t\t\tLB_PIXEL_DEPTH_24BPP |\n\t\t\tLB_PIXEL_DEPTH_30BPP |\n\t\t\tLB_PIXEL_DEPTH_36BPP;\n\n\txfm_dce->lb_bits_per_entry = LB_BITS_PER_ENTRY;\n\txfm_dce->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES;  \n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nvoid dce60_transform_construct(\n\tstruct dce_transform *xfm_dce,\n\tstruct dc_context *ctx,\n\tuint32_t inst,\n\tconst struct dce_transform_registers *regs,\n\tconst struct dce_transform_shift *xfm_shift,\n\tconst struct dce_transform_mask *xfm_mask)\n{\n\txfm_dce->base.ctx = ctx;\n\n\txfm_dce->base.inst = inst;\n\txfm_dce->base.funcs = &dce60_transform_funcs;\n\n\txfm_dce->regs = regs;\n\txfm_dce->xfm_shift = xfm_shift;\n\txfm_dce->xfm_mask = xfm_mask;\n\n\txfm_dce->prescaler_on = true;\n\txfm_dce->lb_pixel_depth_supported =\n\t\t\tLB_PIXEL_DEPTH_18BPP |\n\t\t\tLB_PIXEL_DEPTH_24BPP |\n\t\t\tLB_PIXEL_DEPTH_30BPP |\n\t\t\tLB_PIXEL_DEPTH_36BPP;\n\n\txfm_dce->lb_bits_per_entry = LB_BITS_PER_ENTRY;\n\txfm_dce->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES;  \n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}