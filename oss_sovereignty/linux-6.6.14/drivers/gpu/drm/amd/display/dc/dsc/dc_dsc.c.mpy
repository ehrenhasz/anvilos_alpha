{
  "module_name": "dc_dsc.c",
  "hash_id": "ffcb6a1c25343658b277ba8de0f60c963d667564444f1b5f73fc77553498b755",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dsc_helper.h>\n#include \"dc_hw_types.h\"\n#include \"dsc.h\"\n#include \"dc.h\"\n#include \"rc_calc.h\"\n#include \"fixed31_32.h\"\n\n \n\n \nstatic uint32_t dsc_policy_max_target_bpp_limit = 16;\n\n \nstatic bool dsc_policy_enable_dsc_when_not_needed;\n\nstatic bool dsc_policy_disable_dsc_stream_overhead;\n\nstatic bool disable_128b_132b_stream_overhead;\n\n#ifndef MAX\n#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#endif\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\n \nstatic uint32_t apply_128b_132b_stream_overhead(\n\tconst struct dc_crtc_timing *timing, const uint32_t kbps)\n{\n\tuint32_t total_kbps = kbps;\n\n\tif (disable_128b_132b_stream_overhead)\n\t\treturn kbps;\n\n\tif (!timing->flags.DSC) {\n\t\tstruct fixed31_32 bpp;\n\t\tstruct fixed31_32 overhead_factor;\n\n\t\tbpp = dc_fixpt_from_int(kbps);\n\t\tbpp = dc_fixpt_div_int(bpp, timing->pix_clk_100hz / 10);\n\n\t\t \n\t\toverhead_factor = dc_fixpt_from_int(timing->h_addressable);\n\t\toverhead_factor = dc_fixpt_mul(overhead_factor, bpp);\n\t\toverhead_factor = dc_fixpt_div_int(overhead_factor, 128);\n\t\toverhead_factor = dc_fixpt_div(\n\t\t\tdc_fixpt_from_int(dc_fixpt_ceil(overhead_factor)),\n\t\t\toverhead_factor);\n\n\t\ttotal_kbps = dc_fixpt_ceil(\n\t\t\tdc_fixpt_mul_int(overhead_factor, total_kbps));\n\t}\n\n\treturn total_kbps;\n}\n\nuint32_t dc_bandwidth_in_kbps_from_timing(\n\tconst struct dc_crtc_timing *timing,\n\tconst enum dc_link_encoding_format link_encoding)\n{\n\tuint32_t bits_per_channel = 0;\n\tuint32_t kbps;\n\n\tif (timing->flags.DSC)\n\t\treturn dc_dsc_stream_bandwidth_in_kbps(timing,\n\t\t\t\ttiming->dsc_cfg.bits_per_pixel,\n\t\t\t\ttiming->dsc_cfg.num_slices_h,\n\t\t\t\ttiming->dsc_cfg.is_dp);\n\n\tswitch (timing->display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tbits_per_channel = 6;\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tbits_per_channel = 8;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tbits_per_channel = 10;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbits_per_channel = 12;\n\t\tbreak;\n\tcase COLOR_DEPTH_141414:\n\t\tbits_per_channel = 14;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tbits_per_channel = 16;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(bits_per_channel != 0);\n\t\tbits_per_channel = 8;\n\t\tbreak;\n\t}\n\n\tkbps = timing->pix_clk_100hz / 10;\n\tkbps *= bits_per_channel;\n\n\tif (timing->flags.Y_ONLY != 1) {\n\t\t \n\t\tkbps *= 3;\n\t\tif (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\tkbps /= 2;\n\t\telse if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\t\tkbps = kbps * 2 / 3;\n\t}\n\n\tif (link_encoding == DC_LINK_ENCODING_DP_128b_132b)\n\t\tkbps = apply_128b_132b_stream_overhead(timing, kbps);\n\n\treturn kbps;\n}\n\n\n \nstatic bool decide_dsc_bandwidth_range(\n\t\tconst uint32_t min_bpp_x16,\n\t\tconst uint32_t max_bpp_x16,\n\t\tconst uint32_t num_slices_h,\n\t\tconst struct dsc_enc_caps *dsc_caps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_bw_range *range);\n\nstatic uint32_t compute_bpp_x16_from_target_bandwidth(\n\t\tconst uint32_t bandwidth_in_kbps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst uint32_t num_slices_h,\n\t\tconst uint32_t bpp_increment_div,\n\t\tconst bool is_dp);\n\nstatic void get_dsc_enc_caps(\n\t\tconst struct display_stream_compressor *dsc,\n\t\tstruct dsc_enc_caps *dsc_enc_caps,\n\t\tint pixel_clock_100Hz);\n\nstatic bool intersect_dsc_caps(\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dsc_enc_caps *dsc_enc_caps,\n\t\tenum dc_pixel_encoding pixel_encoding,\n\t\tstruct dsc_enc_caps *dsc_common_caps);\n\nstatic bool setup_dsc_config(\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dsc_enc_caps *dsc_enc_caps,\n\t\tint target_bandwidth_kbps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst struct dc_dsc_config_options *options,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_config *dsc_cfg);\n\nstatic bool dsc_buff_block_size_from_dpcd(int dpcd_buff_block_size, int *buff_block_size)\n{\n\n\tswitch (dpcd_buff_block_size) {\n\tcase DP_DSC_RC_BUF_BLK_SIZE_1:\n\t\t*buff_block_size = 1024;\n\t\tbreak;\n\tcase DP_DSC_RC_BUF_BLK_SIZE_4:\n\t\t*buff_block_size = 4 * 1024;\n\t\tbreak;\n\tcase DP_DSC_RC_BUF_BLK_SIZE_16:\n\t\t*buff_block_size = 16 * 1024;\n\t\tbreak;\n\tcase DP_DSC_RC_BUF_BLK_SIZE_64:\n\t\t*buff_block_size = 64 * 1024;\n\t\tbreak;\n\tdefault: {\n\t\t\tdm_error(\"%s: DPCD DSC buffer size not recognized.\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic bool dsc_line_buff_depth_from_dpcd(int dpcd_line_buff_bit_depth, int *line_buff_bit_depth)\n{\n\tif (0 <= dpcd_line_buff_bit_depth && dpcd_line_buff_bit_depth <= 7)\n\t\t*line_buff_bit_depth = dpcd_line_buff_bit_depth + 9;\n\telse if (dpcd_line_buff_bit_depth == 8)\n\t\t*line_buff_bit_depth = 8;\n\telse {\n\t\tdm_error(\"%s: DPCD DSC buffer depth not recognized.\\n\", __func__);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nstatic bool dsc_throughput_from_dpcd(int dpcd_throughput, int *throughput)\n{\n\tswitch (dpcd_throughput) {\n\tcase DP_DSC_THROUGHPUT_MODE_0_UNSUPPORTED:\n\t\t*throughput = 0;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_170:\n\t\t*throughput = 170;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_340:\n\t\t*throughput = 340;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_400:\n\t\t*throughput = 400;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_450:\n\t\t*throughput = 450;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_500:\n\t\t*throughput = 500;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_550:\n\t\t*throughput = 550;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_600:\n\t\t*throughput = 600;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_650:\n\t\t*throughput = 650;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_700:\n\t\t*throughput = 700;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_750:\n\t\t*throughput = 750;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_800:\n\t\t*throughput = 800;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_850:\n\t\t*throughput = 850;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_900:\n\t\t*throughput = 900;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_950:\n\t\t*throughput = 950;\n\t\tbreak;\n\tcase DP_DSC_THROUGHPUT_MODE_0_1000:\n\t\t*throughput = 1000;\n\t\tbreak;\n\tdefault: {\n\t\t\tdm_error(\"%s: DPCD DSC throughput mode not recognized.\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic bool dsc_bpp_increment_div_from_dpcd(uint8_t bpp_increment_dpcd, uint32_t *bpp_increment_div)\n{\n\t \n\tbpp_increment_dpcd &= 0x7;\n\n\tswitch (bpp_increment_dpcd) {\n\tcase 0:\n\t\t*bpp_increment_div = 16;\n\t\tbreak;\n\tcase 1:\n\t\t*bpp_increment_div = 8;\n\t\tbreak;\n\tcase 2:\n\t\t*bpp_increment_div = 4;\n\t\tbreak;\n\tcase 3:\n\t\t*bpp_increment_div = 2;\n\t\tbreak;\n\tcase 4:\n\t\t*bpp_increment_div = 1;\n\t\tbreak;\n\tdefault: {\n\t\tdm_error(\"%s: DPCD DSC bits-per-pixel increment not recognized.\\n\", __func__);\n\t\treturn false;\n\t}\n\t}\n\n\treturn true;\n}\n\n\n\nbool dc_dsc_parse_dsc_dpcd(const struct dc *dc,\n\t\tconst uint8_t *dpcd_dsc_basic_data,\n\t\tconst uint8_t *dpcd_dsc_branch_decoder_caps,\n\t\tstruct dsc_dec_dpcd_caps *dsc_sink_caps)\n{\n\tif (!dpcd_dsc_basic_data)\n\t\treturn false;\n\n\tdsc_sink_caps->is_dsc_supported =\n\t\t(dpcd_dsc_basic_data[DP_DSC_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_DECOMPRESSION_IS_SUPPORTED) != 0;\n\tif (!dsc_sink_caps->is_dsc_supported)\n\t\treturn false;\n\n\tdsc_sink_caps->dsc_version = dpcd_dsc_basic_data[DP_DSC_REV - DP_DSC_SUPPORT];\n\n\t{\n\t\tint buff_block_size;\n\t\tint buff_size;\n\n\t\tif (!dsc_buff_block_size_from_dpcd(dpcd_dsc_basic_data[DP_DSC_RC_BUF_BLK_SIZE - DP_DSC_SUPPORT],\n\t\t\t\t\t\t\t\t\t\t   &buff_block_size))\n\t\t\treturn false;\n\n\t\tbuff_size = dpcd_dsc_basic_data[DP_DSC_RC_BUF_SIZE - DP_DSC_SUPPORT] + 1;\n\t\tdsc_sink_caps->rc_buffer_size = buff_size * buff_block_size;\n\t}\n\n\tdsc_sink_caps->slice_caps1.raw = dpcd_dsc_basic_data[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];\n\tif (!dsc_line_buff_depth_from_dpcd(dpcd_dsc_basic_data[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT],\n\t\t\t\t\t\t\t\t\t   &dsc_sink_caps->lb_bit_depth))\n\t\treturn false;\n\n\tdsc_sink_caps->is_block_pred_supported =\n\t\t(dpcd_dsc_basic_data[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] &\n\t\t DP_DSC_BLK_PREDICTION_IS_SUPPORTED) != 0;\n\n\tdsc_sink_caps->edp_max_bits_per_pixel =\n\t\tdpcd_dsc_basic_data[DP_DSC_MAX_BITS_PER_PIXEL_LOW - DP_DSC_SUPPORT] |\n\t\tdpcd_dsc_basic_data[DP_DSC_MAX_BITS_PER_PIXEL_HI - DP_DSC_SUPPORT] << 8;\n\n\tdsc_sink_caps->color_formats.raw = dpcd_dsc_basic_data[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT];\n\tdsc_sink_caps->color_depth.raw = dpcd_dsc_basic_data[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];\n\n\t{\n\t\tint dpcd_throughput = dpcd_dsc_basic_data[DP_DSC_PEAK_THROUGHPUT - DP_DSC_SUPPORT];\n\n\t\tif (!dsc_throughput_from_dpcd(dpcd_throughput & DP_DSC_THROUGHPUT_MODE_0_MASK,\n\t\t\t\t\t\t\t\t\t  &dsc_sink_caps->throughput_mode_0_mps))\n\t\t\treturn false;\n\n\t\tdpcd_throughput = (dpcd_throughput & DP_DSC_THROUGHPUT_MODE_1_MASK) >> DP_DSC_THROUGHPUT_MODE_1_SHIFT;\n\t\tif (!dsc_throughput_from_dpcd(dpcd_throughput, &dsc_sink_caps->throughput_mode_1_mps))\n\t\t\treturn false;\n\t}\n\n\tdsc_sink_caps->max_slice_width = dpcd_dsc_basic_data[DP_DSC_MAX_SLICE_WIDTH - DP_DSC_SUPPORT] * 320;\n\tdsc_sink_caps->slice_caps2.raw = dpcd_dsc_basic_data[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];\n\n\tif (!dsc_bpp_increment_div_from_dpcd(dpcd_dsc_basic_data[DP_DSC_BITS_PER_PIXEL_INC - DP_DSC_SUPPORT],\n\t\t\t\t\t\t\t\t\t\t &dsc_sink_caps->bpp_increment_div))\n\t\treturn false;\n\n\tif (dc->debug.dsc_bpp_increment_div) {\n\t\t \n\t\tif (dc->debug.dsc_bpp_increment_div >= 1)\n\t\t\tdsc_sink_caps->bpp_increment_div = 1;\n\t\tif (dc->debug.dsc_bpp_increment_div >= 2)\n\t\t\tdsc_sink_caps->bpp_increment_div = 2;\n\t\tif (dc->debug.dsc_bpp_increment_div >= 4)\n\t\t\tdsc_sink_caps->bpp_increment_div = 4;\n\t\tif (dc->debug.dsc_bpp_increment_div >= 8)\n\t\t\tdsc_sink_caps->bpp_increment_div = 8;\n\t\tif (dc->debug.dsc_bpp_increment_div >= 16)\n\t\t\tdsc_sink_caps->bpp_increment_div = 16;\n\t}\n\n\t \n\tif (dpcd_dsc_branch_decoder_caps == NULL) {  \n\t\tdsc_sink_caps->branch_overall_throughput_0_mps = 0;\n\t\tdsc_sink_caps->branch_overall_throughput_1_mps = 0;\n\t\tdsc_sink_caps->branch_max_line_width = 0;\n\t\treturn true;\n\t}\n\n\tdsc_sink_caps->branch_overall_throughput_0_mps =\n\t\tdpcd_dsc_branch_decoder_caps[DP_DSC_BRANCH_OVERALL_THROUGHPUT_0 - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0];\n\tif (dsc_sink_caps->branch_overall_throughput_0_mps == 0)\n\t\tdsc_sink_caps->branch_overall_throughput_0_mps = 0;\n\telse if (dsc_sink_caps->branch_overall_throughput_0_mps == 1)\n\t\tdsc_sink_caps->branch_overall_throughput_0_mps = 680;\n\telse {\n\t\tdsc_sink_caps->branch_overall_throughput_0_mps *= 50;\n\t\tdsc_sink_caps->branch_overall_throughput_0_mps += 600;\n\t}\n\n\tdsc_sink_caps->branch_overall_throughput_1_mps =\n\t\tdpcd_dsc_branch_decoder_caps[DP_DSC_BRANCH_OVERALL_THROUGHPUT_1 - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0];\n\tif (dsc_sink_caps->branch_overall_throughput_1_mps == 0)\n\t\tdsc_sink_caps->branch_overall_throughput_1_mps = 0;\n\telse if (dsc_sink_caps->branch_overall_throughput_1_mps == 1)\n\t\tdsc_sink_caps->branch_overall_throughput_1_mps = 680;\n\telse {\n\t\tdsc_sink_caps->branch_overall_throughput_1_mps *= 50;\n\t\tdsc_sink_caps->branch_overall_throughput_1_mps += 600;\n\t}\n\n\tdsc_sink_caps->branch_max_line_width =\n\t\tdpcd_dsc_branch_decoder_caps[DP_DSC_BRANCH_MAX_LINE_WIDTH - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0] * 320;\n\tASSERT(dsc_sink_caps->branch_max_line_width == 0 || dsc_sink_caps->branch_max_line_width >= 5120);\n\n\tdsc_sink_caps->is_dp = true;\n\treturn true;\n}\n\n\n \nbool dc_dsc_compute_bandwidth_range(\n\t\tconst struct display_stream_compressor *dsc,\n\t\tuint32_t dsc_min_slice_height_override,\n\t\tuint32_t min_bpp_x16,\n\t\tuint32_t max_bpp_x16,\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_bw_range *range)\n{\n\tbool is_dsc_possible = false;\n\tstruct dsc_enc_caps dsc_enc_caps;\n\tstruct dsc_enc_caps dsc_common_caps;\n\tstruct dc_dsc_config config;\n\tstruct dc_dsc_config_options options = {0};\n\n\toptions.dsc_min_slice_height_override = dsc_min_slice_height_override;\n\toptions.max_target_bpp_limit_override_x16 = max_bpp_x16;\n\toptions.slice_height_granularity = 1;\n\n\tget_dsc_enc_caps(dsc, &dsc_enc_caps, timing->pix_clk_100hz);\n\n\tis_dsc_possible = intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps,\n\t\t\ttiming->pixel_encoding, &dsc_common_caps);\n\n\tif (is_dsc_possible)\n\t\tis_dsc_possible = setup_dsc_config(dsc_sink_caps, &dsc_enc_caps, 0, timing,\n\t\t\t\t&options, link_encoding, &config);\n\n\tif (is_dsc_possible)\n\t\tis_dsc_possible = decide_dsc_bandwidth_range(min_bpp_x16, max_bpp_x16,\n\t\t\t\tconfig.num_slices_h, &dsc_common_caps, timing, link_encoding, range);\n\n\treturn is_dsc_possible;\n}\n\nstatic void get_dsc_enc_caps(\n\t\tconst struct display_stream_compressor *dsc,\n\t\tstruct dsc_enc_caps *dsc_enc_caps,\n\t\tint pixel_clock_100Hz)\n{\n\t\n\n\tmemset(dsc_enc_caps, 0, sizeof(struct dsc_enc_caps));\n\tif (dsc) {\n\t\tif (!dsc->ctx->dc->debug.disable_dsc)\n\t\t\tdsc->funcs->dsc_get_enc_caps(dsc_enc_caps, pixel_clock_100Hz);\n\t\tif (dsc->ctx->dc->debug.native422_support)\n\t\t\tdsc_enc_caps->color_formats.bits.YCBCR_NATIVE_422 = 1;\n\t}\n}\n\n \nstatic bool intersect_dsc_caps(\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dsc_enc_caps *dsc_enc_caps,\n\t\tenum dc_pixel_encoding pixel_encoding,\n\t\tstruct dsc_enc_caps *dsc_common_caps)\n{\n\tint32_t max_slices;\n\tint32_t total_sink_throughput;\n\n\tmemset(dsc_common_caps, 0, sizeof(struct dsc_enc_caps));\n\n\tdsc_common_caps->dsc_version = min(dsc_sink_caps->dsc_version, dsc_enc_caps->dsc_version);\n\tif (!dsc_common_caps->dsc_version)\n\t\treturn false;\n\n\tdsc_common_caps->slice_caps.bits.NUM_SLICES_1 =\n\t\tdsc_sink_caps->slice_caps1.bits.NUM_SLICES_1 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_1;\n\tdsc_common_caps->slice_caps.bits.NUM_SLICES_2 =\n\t\tdsc_sink_caps->slice_caps1.bits.NUM_SLICES_2 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_2;\n\tdsc_common_caps->slice_caps.bits.NUM_SLICES_4 =\n\t\tdsc_sink_caps->slice_caps1.bits.NUM_SLICES_4 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_4;\n\tdsc_common_caps->slice_caps.bits.NUM_SLICES_8 =\n\t\tdsc_sink_caps->slice_caps1.bits.NUM_SLICES_8 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_8;\n\tif (!dsc_common_caps->slice_caps.raw)\n\t\treturn false;\n\n\tdsc_common_caps->lb_bit_depth = min(dsc_sink_caps->lb_bit_depth, dsc_enc_caps->lb_bit_depth);\n\tif (!dsc_common_caps->lb_bit_depth)\n\t\treturn false;\n\n\tdsc_common_caps->is_block_pred_supported =\n\t\tdsc_sink_caps->is_block_pred_supported && dsc_enc_caps->is_block_pred_supported;\n\n\tdsc_common_caps->color_formats.raw = dsc_sink_caps->color_formats.raw & dsc_enc_caps->color_formats.raw;\n\tif (!dsc_common_caps->color_formats.raw)\n\t\treturn false;\n\n\tdsc_common_caps->color_depth.raw = dsc_sink_caps->color_depth.raw & dsc_enc_caps->color_depth.raw;\n\tif (!dsc_common_caps->color_depth.raw)\n\t\treturn false;\n\n\tmax_slices = 0;\n\tif (dsc_common_caps->slice_caps.bits.NUM_SLICES_1)\n\t\tmax_slices = 1;\n\n\tif (dsc_common_caps->slice_caps.bits.NUM_SLICES_2)\n\t\tmax_slices = 2;\n\n\tif (dsc_common_caps->slice_caps.bits.NUM_SLICES_4)\n\t\tmax_slices = 4;\n\n\ttotal_sink_throughput = max_slices * dsc_sink_caps->throughput_mode_0_mps;\n\tif (pixel_encoding == PIXEL_ENCODING_YCBCR422 || pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\ttotal_sink_throughput = max_slices * dsc_sink_caps->throughput_mode_1_mps;\n\n\tdsc_common_caps->max_total_throughput_mps = min(total_sink_throughput, dsc_enc_caps->max_total_throughput_mps);\n\n\tdsc_common_caps->max_slice_width = min(dsc_sink_caps->max_slice_width, dsc_enc_caps->max_slice_width);\n\tif (!dsc_common_caps->max_slice_width)\n\t\treturn false;\n\n\tdsc_common_caps->bpp_increment_div = min(dsc_sink_caps->bpp_increment_div, dsc_enc_caps->bpp_increment_div);\n\n\t\n\tif (pixel_encoding == PIXEL_ENCODING_YCBCR422 || pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tdsc_common_caps->bpp_increment_div = min(dsc_common_caps->bpp_increment_div, (uint32_t)8);\n\n\tdsc_common_caps->edp_sink_max_bits_per_pixel = dsc_sink_caps->edp_max_bits_per_pixel;\n\tdsc_common_caps->is_dp = dsc_sink_caps->is_dp;\n\treturn true;\n}\n\nstatic inline uint32_t dsc_div_by_10_round_up(uint32_t value)\n{\n\treturn (value + 9) / 10;\n}\n\nstatic uint32_t compute_bpp_x16_from_target_bandwidth(\n\tconst uint32_t bandwidth_in_kbps,\n\tconst struct dc_crtc_timing *timing,\n\tconst uint32_t num_slices_h,\n\tconst uint32_t bpp_increment_div,\n\tconst bool is_dp)\n{\n\tuint32_t overhead_in_kbps;\n\tstruct fixed31_32 effective_bandwidth_in_kbps;\n\tstruct fixed31_32 bpp_x16;\n\n\toverhead_in_kbps = dc_dsc_stream_bandwidth_overhead_in_kbps(\n\t\t\t\ttiming, num_slices_h, is_dp);\n\teffective_bandwidth_in_kbps = dc_fixpt_from_int(bandwidth_in_kbps);\n\teffective_bandwidth_in_kbps = dc_fixpt_sub_int(effective_bandwidth_in_kbps,\n\t\t\toverhead_in_kbps);\n\tbpp_x16 = dc_fixpt_mul_int(effective_bandwidth_in_kbps, 10);\n\tbpp_x16 = dc_fixpt_div_int(bpp_x16, timing->pix_clk_100hz);\n\tbpp_x16 = dc_fixpt_from_int(dc_fixpt_floor(dc_fixpt_mul_int(bpp_x16, bpp_increment_div)));\n\tbpp_x16 = dc_fixpt_div_int(bpp_x16, bpp_increment_div);\n\tbpp_x16 = dc_fixpt_mul_int(bpp_x16, 16);\n\treturn dc_fixpt_floor(bpp_x16);\n}\n\n \nstatic bool decide_dsc_bandwidth_range(\n\t\tconst uint32_t min_bpp_x16,\n\t\tconst uint32_t max_bpp_x16,\n\t\tconst uint32_t num_slices_h,\n\t\tconst struct dsc_enc_caps *dsc_caps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_bw_range *range)\n{\n\tuint32_t preferred_bpp_x16 = timing->dsc_fixed_bits_per_pixel_x16;\n\n\tmemset(range, 0, sizeof(*range));\n\n\t \n\tif (preferred_bpp_x16) {\n\t\tif (preferred_bpp_x16 <= max_bpp_x16 &&\n\t\t\t\tpreferred_bpp_x16 >= min_bpp_x16) {\n\t\t\trange->max_target_bpp_x16 = preferred_bpp_x16;\n\t\t\trange->min_target_bpp_x16 = preferred_bpp_x16;\n\t\t}\n\t}\n\t \n\telse if (dsc_caps->edp_sink_max_bits_per_pixel) {\n\t\t \n\t\trange->max_target_bpp_x16 = MIN(dsc_caps->edp_sink_max_bits_per_pixel,\n\t\t\t\tmax_bpp_x16);\n\t\trange->min_target_bpp_x16 = min_bpp_x16;\n\t}\n\telse {\n\t\trange->max_target_bpp_x16 = max_bpp_x16;\n\t\trange->min_target_bpp_x16 = min_bpp_x16;\n\t}\n\n\t \n\tif (range->max_target_bpp_x16 >= range->min_target_bpp_x16 && range->min_target_bpp_x16 > 0) {\n\t\t \n\t\trange->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing, link_encoding);\n\n\t\t \n\t\trange->max_kbps = dc_dsc_stream_bandwidth_in_kbps(timing,\n\t\t\t\trange->max_target_bpp_x16, num_slices_h, dsc_caps->is_dp);\n\n\t\t \n\t\trange->min_kbps = dc_dsc_stream_bandwidth_in_kbps(timing,\n\t\t\t\trange->min_target_bpp_x16, num_slices_h, dsc_caps->is_dp);\n\t}\n\n\treturn range->max_kbps >= range->min_kbps && range->min_kbps > 0;\n}\n\n \nstatic bool decide_dsc_target_bpp_x16(\n\t\tconst struct dc_dsc_policy *policy,\n\t\tconst struct dsc_enc_caps *dsc_common_caps,\n\t\tconst int target_bandwidth_kbps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst int num_slices_h,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tint *target_bpp_x16)\n{\n\tstruct dc_dsc_bw_range range;\n\n\t*target_bpp_x16 = 0;\n\n\tif (decide_dsc_bandwidth_range(policy->min_target_bpp * 16, policy->max_target_bpp * 16,\n\t\t\tnum_slices_h, dsc_common_caps, timing, link_encoding, &range)) {\n\t\tif (target_bandwidth_kbps >= range.stream_kbps) {\n\t\t\tif (policy->enable_dsc_when_not_needed)\n\t\t\t\t \n\t\t\t\t*target_bpp_x16 = range.max_target_bpp_x16;\n\t\t} else if (target_bandwidth_kbps >= range.max_kbps) {\n\t\t\t \n\t\t\t*target_bpp_x16 = range.max_target_bpp_x16;\n\t\t} else if (target_bandwidth_kbps >= range.min_kbps) {\n\t\t\t \n\t\t\t*target_bpp_x16 = compute_bpp_x16_from_target_bandwidth(\n\t\t\t\t\ttarget_bandwidth_kbps, timing, num_slices_h,\n\t\t\t\t\tdsc_common_caps->bpp_increment_div,\n\t\t\t\t\tdsc_common_caps->is_dp);\n\t\t}\n\t}\n\n\treturn *target_bpp_x16 != 0;\n}\n\n#define MIN_AVAILABLE_SLICES_SIZE  6\n\nstatic int get_available_dsc_slices(union dsc_enc_slice_caps slice_caps, int *available_slices)\n{\n\tint idx = 0;\n\n\tif (slice_caps.bits.NUM_SLICES_1)\n\t\tavailable_slices[idx++] = 1;\n\n\tif (slice_caps.bits.NUM_SLICES_2)\n\t\tavailable_slices[idx++] = 2;\n\n\tif (slice_caps.bits.NUM_SLICES_4)\n\t\tavailable_slices[idx++] = 4;\n\n\tif (slice_caps.bits.NUM_SLICES_8)\n\t\tavailable_slices[idx++] = 8;\n\n\treturn idx;\n}\n\n\nstatic int get_max_dsc_slices(union dsc_enc_slice_caps slice_caps)\n{\n\tint max_slices = 0;\n\tint available_slices[MIN_AVAILABLE_SLICES_SIZE];\n\tint end_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);\n\n\tif (end_idx > 0)\n\t\tmax_slices = available_slices[end_idx - 1];\n\n\treturn max_slices;\n}\n\n\n\nstatic int inc_num_slices(union dsc_enc_slice_caps slice_caps, int num_slices)\n{\n\t\n\tint available_slices[MIN_AVAILABLE_SLICES_SIZE];\n\tint end_idx;\n\tint i;\n\tint new_num_slices = num_slices;\n\n\tend_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);\n\tif (end_idx == 0) {\n\t\t\n\t\tnew_num_slices++;\n\t\treturn new_num_slices;\n\t}\n\n\t\n\tfor (i = 0; i < end_idx; i++) {\n\t\tif (new_num_slices < available_slices[i]) {\n\t\t\tnew_num_slices = available_slices[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_num_slices == num_slices) \n\t\tnew_num_slices++;\n\n\treturn new_num_slices;\n}\n\n\n\nstatic int dec_num_slices(union dsc_enc_slice_caps slice_caps, int num_slices)\n{\n\t\n\tint available_slices[MIN_AVAILABLE_SLICES_SIZE];\n\tint end_idx;\n\tint i;\n\tint new_num_slices = num_slices;\n\n\tend_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);\n\tif (end_idx == 0 && new_num_slices > 0) {\n\t\t\n\t\tnew_num_slices++;\n\t\treturn new_num_slices;\n\t}\n\n\t\n\tfor (i = end_idx - 1; i >= 0; i--) {\n\t\tif (new_num_slices > available_slices[i]) {\n\t\t\tnew_num_slices = available_slices[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_num_slices == num_slices) {\n\t\t\n\t\tnew_num_slices--;\n\t\tif (new_num_slices < 0)\n\t\t\tnew_num_slices = 0;\n\t}\n\n\treturn new_num_slices;\n}\n\n\n\nstatic int fit_num_slices_up(union dsc_enc_slice_caps slice_caps, int num_slices)\n{\n\t\n\tint available_slices[MIN_AVAILABLE_SLICES_SIZE];\n\tint end_idx;\n\tint i;\n\tint new_num_slices = num_slices;\n\n\tend_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);\n\tif (end_idx == 0) {\n\t\t\n\t\tnew_num_slices++;\n\t\treturn new_num_slices;\n\t}\n\n\t\n\tfor (i = 0; i < end_idx; i++) {\n\t\tif (new_num_slices <= available_slices[i]) {\n\t\t\tnew_num_slices = available_slices[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new_num_slices;\n}\n\n\n \nstatic bool setup_dsc_config(\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dsc_enc_caps *dsc_enc_caps,\n\t\tint target_bandwidth_kbps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst struct dc_dsc_config_options *options,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_config *dsc_cfg)\n{\n\tstruct dsc_enc_caps dsc_common_caps;\n\tint max_slices_h;\n\tint min_slices_h;\n\tint num_slices_h;\n\tint pic_width;\n\tint slice_width;\n\tint target_bpp;\n\tint sink_per_slice_throughput_mps;\n\tint branch_max_throughput_mps = 0;\n\tbool is_dsc_possible = false;\n\tint pic_height;\n\tint slice_height;\n\tstruct dc_dsc_policy policy;\n\n\tmemset(dsc_cfg, 0, sizeof(struct dc_dsc_config));\n\n\tdc_dsc_get_policy_for_timing(timing, options->max_target_bpp_limit_override_x16, &policy);\n\tpic_width = timing->h_addressable + timing->h_border_left + timing->h_border_right;\n\tpic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;\n\n\tif (!dsc_sink_caps->is_dsc_supported)\n\t\tgoto done;\n\n\tif (dsc_sink_caps->branch_max_line_width && dsc_sink_caps->branch_max_line_width < pic_width)\n\t\tgoto done;\n\n\t\n\tis_dsc_possible = intersect_dsc_caps(dsc_sink_caps, dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\tsink_per_slice_throughput_mps = 0;\n\n\t\n\n\t\n\tdsc_cfg->ycbcr422_simple = false;\n\tswitch (timing->pixel_encoding)\t{\n\tcase PIXEL_ENCODING_RGB:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_formats.bits.RGB;\n\t\tsink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;\n\t\tbranch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_0_mps;\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR444:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_444;\n\t\tsink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;\n\t\tbranch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_0_mps;\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR422:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_422;\n\t\tsink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_1_mps;\n\t\tbranch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_1_mps;\n\t\tif (!is_dsc_possible) {\n\t\t\tis_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_SIMPLE_422;\n\t\t\tdsc_cfg->ycbcr422_simple = is_dsc_possible;\n\t\t\tsink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;\n\t\t}\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR420:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_420;\n\t\tsink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_1_mps;\n\t\tbranch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_1_mps;\n\t\tbreak;\n\tdefault:\n\t\tis_dsc_possible = false;\n\t}\n\n\t\n\tif (branch_max_throughput_mps && dsc_div_by_10_round_up(timing->pix_clk_100hz) > branch_max_throughput_mps * 1000)\n\t\tis_dsc_possible = false;\n\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\t\n\tswitch (timing->display_color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_8_BPC;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_10_BPC;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tis_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_12_BPC;\n\t\tbreak;\n\tdefault:\n\t\tis_dsc_possible = false;\n\t}\n\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\t\n\tmax_slices_h = get_max_dsc_slices(dsc_common_caps.slice_caps);\n\n\twhile (max_slices_h > 0) {\n\t\tif (pic_width % max_slices_h == 0)\n\t\t\tbreak;\n\n\t\tmax_slices_h = dec_num_slices(dsc_common_caps.slice_caps, max_slices_h);\n\t}\n\n\tis_dsc_possible = (dsc_common_caps.max_slice_width > 0);\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\tmin_slices_h = pic_width / dsc_common_caps.max_slice_width;\n\tif (pic_width % dsc_common_caps.max_slice_width)\n\t\tmin_slices_h++;\n\n\tmin_slices_h = fit_num_slices_up(dsc_common_caps.slice_caps, min_slices_h);\n\n\twhile (min_slices_h <= max_slices_h) {\n\t\tint pix_clk_per_slice_khz = dsc_div_by_10_round_up(timing->pix_clk_100hz) / min_slices_h;\n\t\tif (pix_clk_per_slice_khz <= sink_per_slice_throughput_mps * 1000)\n\t\t\tbreak;\n\n\t\tmin_slices_h = inc_num_slices(dsc_common_caps.slice_caps, min_slices_h);\n\t}\n\n\tis_dsc_possible = (min_slices_h <= max_slices_h);\n\n\tif (pic_width % min_slices_h != 0)\n\t\tmin_slices_h = 0; \n\n\tif (min_slices_h == 0 && max_slices_h == 0)\n\t\tis_dsc_possible = false;\n\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\tif (policy.use_min_slices_h) {\n\t\tif (min_slices_h > 0)\n\t\t\tnum_slices_h = min_slices_h;\n\t\telse if (max_slices_h > 0) { \n\t\t\tif (policy.max_slices_h)\n\t\t\t\tnum_slices_h = min(policy.max_slices_h, max_slices_h);\n\t\t\telse\n\t\t\t\tnum_slices_h = max_slices_h;\n\t\t} else\n\t\t\tis_dsc_possible = false;\n\t} else {\n\t\tif (max_slices_h > 0) {\n\t\t\tif (policy.max_slices_h)\n\t\t\t\tnum_slices_h = min(policy.max_slices_h, max_slices_h);\n\t\t\telse\n\t\t\t\tnum_slices_h = max_slices_h;\n\t\t} else if (min_slices_h > 0) \n\t\t\tnum_slices_h = min_slices_h;\n\t\telse\n\t\t\tis_dsc_possible = false;\n\t}\n\t\n\t\n\tif (options->dsc_force_odm_hslice_override) {\n\t\tnum_slices_h = fit_num_slices_up(dsc_common_caps.slice_caps, 2);\n\t\tif (num_slices_h == 0)\n\t\t\tis_dsc_possible = false;\n\t}\n\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\tdsc_cfg->num_slices_h = num_slices_h;\n\tslice_width = pic_width / num_slices_h;\n\n\tis_dsc_possible = slice_width <= dsc_common_caps.max_slice_width;\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\t\n\t\n\tif (options->dsc_min_slice_height_override == 0)\n\t\tslice_height = min(policy.min_slice_height, pic_height);\n\telse\n\t\tslice_height = min((int)(options->dsc_min_slice_height_override), pic_height);\n\n\twhile (slice_height < pic_height && (pic_height % slice_height != 0 ||\n\t\tslice_height % options->slice_height_granularity != 0 ||\n\t\t(timing->pixel_encoding == PIXEL_ENCODING_YCBCR420 && slice_height % 2 != 0)))\n\t\tslice_height++;\n\n\tif (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) \n\t\tis_dsc_possible = (slice_height % 2 == 0);\n\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\tdsc_cfg->num_slices_v = pic_height/slice_height;\n\n\tif (target_bandwidth_kbps > 0) {\n\t\tis_dsc_possible = decide_dsc_target_bpp_x16(\n\t\t\t\t&policy,\n\t\t\t\t&dsc_common_caps,\n\t\t\t\ttarget_bandwidth_kbps,\n\t\t\t\ttiming,\n\t\t\t\tnum_slices_h,\n\t\t\t\tlink_encoding,\n\t\t\t\t&target_bpp);\n\t\tdsc_cfg->bits_per_pixel = target_bpp;\n\t}\n\tif (!is_dsc_possible)\n\t\tgoto done;\n\n\t\n\tif (is_dsc_possible) {\n\t\t\n\t\tdsc_cfg->block_pred_enable = dsc_common_caps.is_block_pred_supported;\n\t\tdsc_cfg->linebuf_depth = dsc_common_caps.lb_bit_depth;\n\t\tdsc_cfg->version_minor = (dsc_common_caps.dsc_version & 0xf0) >> 4;\n\t\tdsc_cfg->is_dp = dsc_sink_caps->is_dp;\n\t}\n\ndone:\n\tif (!is_dsc_possible)\n\t\tmemset(dsc_cfg, 0, sizeof(struct dc_dsc_config));\n\n\treturn is_dsc_possible;\n}\n\nbool dc_dsc_compute_config(\n\t\tconst struct display_stream_compressor *dsc,\n\t\tconst struct dsc_dec_dpcd_caps *dsc_sink_caps,\n\t\tconst struct dc_dsc_config_options *options,\n\t\tuint32_t target_bandwidth_kbps,\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst enum dc_link_encoding_format link_encoding,\n\t\tstruct dc_dsc_config *dsc_cfg)\n{\n\tbool is_dsc_possible = false;\n\tstruct dsc_enc_caps dsc_enc_caps;\n\n\tget_dsc_enc_caps(dsc, &dsc_enc_caps, timing->pix_clk_100hz);\n\tis_dsc_possible = setup_dsc_config(dsc_sink_caps,\n\t\t&dsc_enc_caps,\n\t\ttarget_bandwidth_kbps,\n\t\ttiming, options, link_encoding, dsc_cfg);\n\treturn is_dsc_possible;\n}\n\nuint32_t dc_dsc_stream_bandwidth_in_kbps(const struct dc_crtc_timing *timing,\n\tuint32_t bpp_x16, uint32_t num_slices_h, bool is_dp)\n{\n\tuint32_t overhead_in_kbps;\n\tstruct fixed31_32 bpp;\n\tstruct fixed31_32 actual_bandwidth_in_kbps;\n\n\toverhead_in_kbps = dc_dsc_stream_bandwidth_overhead_in_kbps(\n\t\ttiming, num_slices_h, is_dp);\n\tbpp = dc_fixpt_from_fraction(bpp_x16, 16);\n\tactual_bandwidth_in_kbps = dc_fixpt_from_fraction(timing->pix_clk_100hz, 10);\n\tactual_bandwidth_in_kbps = dc_fixpt_mul(actual_bandwidth_in_kbps, bpp);\n\tactual_bandwidth_in_kbps = dc_fixpt_add_int(actual_bandwidth_in_kbps, overhead_in_kbps);\n\treturn dc_fixpt_ceil(actual_bandwidth_in_kbps);\n}\n\nuint32_t dc_dsc_stream_bandwidth_overhead_in_kbps(\n\t\tconst struct dc_crtc_timing *timing,\n\t\tconst int num_slices_h,\n\t\tconst bool is_dp)\n{\n\tstruct fixed31_32 max_dsc_overhead;\n\tstruct fixed31_32 refresh_rate;\n\n\tif (dsc_policy_disable_dsc_stream_overhead || !is_dp)\n\t\treturn 0;\n\n\t \n\trefresh_rate = dc_fixpt_from_int(timing->pix_clk_100hz);\n\trefresh_rate = dc_fixpt_div_int(refresh_rate, timing->h_total);\n\trefresh_rate = dc_fixpt_div_int(refresh_rate, timing->v_total);\n\trefresh_rate = dc_fixpt_mul_int(refresh_rate, 100);\n\n\tmax_dsc_overhead = dc_fixpt_from_int(num_slices_h);\n\tmax_dsc_overhead = dc_fixpt_mul_int(max_dsc_overhead, timing->v_total);\n\tmax_dsc_overhead = dc_fixpt_mul_int(max_dsc_overhead, 256);\n\tmax_dsc_overhead = dc_fixpt_div_int(max_dsc_overhead, 1000);\n\tmax_dsc_overhead = dc_fixpt_mul(max_dsc_overhead, refresh_rate);\n\n\treturn dc_fixpt_ceil(max_dsc_overhead);\n}\n\nvoid dc_dsc_get_policy_for_timing(const struct dc_crtc_timing *timing,\n\t\tuint32_t max_target_bpp_limit_override_x16,\n\t\tstruct dc_dsc_policy *policy)\n{\n\tuint32_t bpc = 0;\n\n\tpolicy->min_target_bpp = 0;\n\tpolicy->max_target_bpp = 0;\n\n\t \n\tpolicy->use_min_slices_h = true;\n\n\t \n\tpolicy->max_slices_h = 0;\n\n\t \n\tpolicy->min_slice_height = 108;\n\n\t \n\tswitch (timing->display_color_depth) {\n\tcase COLOR_DEPTH_888:\n\t\tbpc = 8;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tbpc = 10;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbpc = 12;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tswitch (timing->pixel_encoding) {\n\tcase PIXEL_ENCODING_RGB:\n\tcase PIXEL_ENCODING_YCBCR444:\n\tcase PIXEL_ENCODING_YCBCR422:  \n\t\t \n\t\tpolicy->min_target_bpp = 8;\n\t\t \n\t\tpolicy->max_target_bpp = 3 * bpc;\n\t\tbreak;\n\tcase PIXEL_ENCODING_YCBCR420:\n\t\t \n\t\tpolicy->min_target_bpp = 6;\n\t\t \n\t\tpolicy->max_target_bpp = bpc * 3 / 2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (policy->max_target_bpp > dsc_policy_max_target_bpp_limit)\n\t\tpolicy->max_target_bpp = dsc_policy_max_target_bpp_limit;\n\n\t \n\tif (max_target_bpp_limit_override_x16 && policy->max_target_bpp > max_target_bpp_limit_override_x16 / 16)\n\t\tpolicy->max_target_bpp = max_target_bpp_limit_override_x16 / 16;\n\n\t \n\tif (dsc_policy_enable_dsc_when_not_needed)\n\t\tpolicy->enable_dsc_when_not_needed = dsc_policy_enable_dsc_when_not_needed;\n\telse\n\t\tpolicy->enable_dsc_when_not_needed = false;\n}\n\nvoid dc_dsc_policy_set_max_target_bpp_limit(uint32_t limit)\n{\n\tdsc_policy_max_target_bpp_limit = limit;\n}\n\nvoid dc_dsc_policy_set_enable_dsc_when_not_needed(bool enable)\n{\n\tdsc_policy_enable_dsc_when_not_needed = enable;\n}\n\nvoid dc_dsc_policy_set_disable_dsc_stream_overhead(bool disable)\n{\n\tdsc_policy_disable_dsc_stream_overhead = disable;\n}\n\nvoid dc_set_disable_128b_132b_stream_overhead(bool disable)\n{\n\tdisable_128b_132b_stream_overhead = disable;\n}\n\nvoid dc_dsc_get_default_config_option(const struct dc *dc, struct dc_dsc_config_options *options)\n{\n\toptions->dsc_min_slice_height_override = dc->debug.dsc_min_slice_height_override;\n\toptions->dsc_force_odm_hslice_override = dc->debug.force_odm_combine;\n\toptions->max_target_bpp_limit_override_x16 = 0;\n\toptions->slice_height_granularity = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}