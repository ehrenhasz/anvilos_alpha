{
  "module_name": "dcn31_hwseq.c",
  "hash_id": "36d98b111ff92162f9558837708417b685e3da9ee3929329a82886472d977d5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_hwseq.c",
  "human_readable_source": " \n\n\n#include \"dm_services.h\"\n#include \"dm_helpers.h\"\n#include \"core_types.h\"\n#include \"resource.h\"\n#include \"dccg.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"clk_mgr.h\"\n#include \"reg_helper.h\"\n#include \"abm.h\"\n#include \"hubp.h\"\n#include \"dchubbub.h\"\n#include \"timing_generator.h\"\n#include \"opp.h\"\n#include \"ipp.h\"\n#include \"mpc.h\"\n#include \"mcif_wb.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dcn31_hwseq.h\"\n#include \"link_hwss.h\"\n#include \"dpcd_defs.h\"\n#include \"dce/dmub_outbox.h\"\n#include \"link.h\"\n#include \"dcn10/dcn10_hw_sequencer.h\"\n#include \"inc/link_enc_cfg.h\"\n#include \"dcn30/dcn30_vpg.h\"\n#include \"dce/dce_i2c_hw.h\"\n\n#define DC_LOGGER_INIT(logger)\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nstatic void enable_memory_low_power(struct dc *dc)\n{\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tint i;\n\n\tif (dc->debug.enable_mem_low_power.bits.dmcu) {\n\t\t\n\t\tif (dc->debug.disable_dmcu || dc->config.disable_dmcu) {\n\t\t\tREG_UPDATE(DMU_MEM_PWR_CNTL, DMCU_ERAM_MEM_PWR_FORCE, 3);\n\t\t}\n\t}\n\n\t\n\tif (dc->debug.enable_mem_low_power.bits.optc) {\n\t\t\n\t\tREG_SET_2(ODM_MEM_PWR_CTRL3, 0, ODM_MEM_UNASSIGNED_PWR_MODE, 3, ODM_MEM_VBLANK_PWR_MODE, 1);\n\t}\n\n\tif (dc->debug.enable_mem_low_power.bits.vga) {\n\t\t\n\t\tREG_UPDATE(MMHUBBUB_MEM_PWR_CNTL, VGA_MEM_PWR_FORCE, 1);\n\t}\n\n\tif (dc->debug.enable_mem_low_power.bits.mpc &&\n\t\tdc->res_pool->mpc->funcs->set_mpc_mem_lp_mode)\n\t\tdc->res_pool->mpc->funcs->set_mpc_mem_lp_mode(dc->res_pool->mpc);\n\n\n\tif (dc->debug.enable_mem_low_power.bits.vpg && dc->res_pool->stream_enc[0]->vpg->funcs->vpg_powerdown) {\n\t\t\n\t\tfor (i = 0; i < dc->res_pool->stream_enc_count; i++)\n\t\t\tdc->res_pool->stream_enc[i]->vpg->funcs->vpg_powerdown(dc->res_pool->stream_enc[i]->vpg);\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\t\tfor (i = 0; i < dc->res_pool->hpo_dp_stream_enc_count; i++)\n\t\t\tdc->res_pool->hpo_dp_stream_enc[i]->vpg->funcs->vpg_powerdown(dc->res_pool->hpo_dp_stream_enc[i]->vpg);\n#endif\n\t}\n\n}\n\nvoid dcn31_init_hw(struct dc *dc)\n{\n\tstruct abm **abms = dc->res_pool->multiple_abms;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\tstruct resource_pool *res_pool = dc->res_pool;\n\tuint32_t backlight = MAX_BACKLIGHT_LEVEL;\n\tint i;\n\n\tif (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)\n\t\tdc->clk_mgr->funcs->init_clocks(dc->clk_mgr);\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb)) {\n\t\thws->funcs.bios_golden_init(dc);\n\t\tif (hws->funcs.disable_vga)\n\t\t\thws->funcs.disable_vga(dc->hwseq);\n\t}\n\t\n\tif (res_pool->dccg->funcs->dccg_init)\n\t\tres_pool->dccg->funcs->dccg_init(res_pool->dccg);\n\n\tenable_memory_low_power(dc);\n\n\tif (dc->ctx->dc_bios->fw_info_valid) {\n\t\tres_pool->ref_clocks.xtalin_clock_inKhz =\n\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;\n\n\t\tif (res_pool->dccg && res_pool->hubbub) {\n\n\t\t\t(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,\n\t\t\t\t\tdc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,\n\t\t\t\t\t&res_pool->ref_clocks.dccg_ref_clock_inKhz);\n\n\t\t\t(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,\n\t\t\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz,\n\t\t\t\t\t&res_pool->ref_clocks.dchub_ref_clock_inKhz);\n\t\t} else {\n\t\t\t\n\t\t\tres_pool->ref_clocks.dccg_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t\tres_pool->ref_clocks.dchub_ref_clock_inKhz =\n\t\t\t\t\tres_pool->ref_clocks.xtalin_clock_inKhz;\n\t\t}\n\t} else\n\t\tASSERT_CRITICAL(false);\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\t \n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (link->ep_type != DISPLAY_ENDPOINT_PHY)\n\t\t\tcontinue;\n\n\t\tlink->link_enc->funcs->hw_init(link->link_enc);\n\n\t\t \n\t\tif (link->link_enc->funcs->is_dig_enabled &&\n\t\t\tlink->link_enc->funcs->is_dig_enabled(link->link_enc)) {\n\t\t\tlink->link_status.link_active = true;\n\t\t\tif (link->link_enc->funcs->fec_is_active &&\n\t\t\t\t\tlink->link_enc->funcs->fec_is_active(link->link_enc))\n\t\t\t\tlink->fec_state = dc_link_fec_enabled;\n\t\t}\n\t}\n\n\t \n\tdc->link_srv->blank_all_dp_displays(dc);\n\n\tif (hws->funcs.enable_power_gating_plane)\n\t\thws->funcs.enable_power_gating_plane(dc->hwseq, true);\n\n\t \n\tif (dcb->funcs->is_accelerated_mode(dcb) || !dc->config.seamless_boot_edp_requested) {\n\n\t\t\n\t\tif (!dc->caps.seamless_odm) {\n\t\t\tfor (i = 0; i < dc->res_pool->timing_generator_count; i++) {\n\t\t\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[i];\n\t\t\t\tuint32_t num_opps, opp_id_src0, opp_id_src1;\n\n\t\t\t\tnum_opps = 1;\n\t\t\t\tif (tg) {\n\t\t\t\t\tif (tg->funcs->is_tg_enabled(tg) && tg->funcs->get_optc_source) {\n\t\t\t\t\t\ttg->funcs->get_optc_source(tg, &num_opps,\n\t\t\t\t\t\t\t\t&opp_id_src0, &opp_id_src1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (num_opps > 1) {\n\t\t\t\t\tdc->link_srv->blank_all_edp_displays(dc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thws->funcs.init_pipes(dc, dc->current_state);\n\t\tif (dc->res_pool->hubbub->funcs->allow_self_refresh_control)\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,\n\t\t\t\t\t!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);\n\t}\n\n\tfor (i = 0; i < res_pool->audio_count; i++) {\n\t\tstruct audio *audio = res_pool->audios[i];\n\n\t\taudio->funcs->hw_init(audio);\n\t}\n\n\tfor (i = 0; i < dc->link_count; i++) {\n\t\tstruct dc_link *link = dc->links[i];\n\n\t\tif (link->panel_cntl)\n\t\t\tbacklight = link->panel_cntl->funcs->hw_init(link->panel_cntl);\n\t}\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (abms[i] != NULL)\n\t\t\tabms[i]->funcs->abm_init(abms[i], backlight);\n\t}\n\n\t \n\tREG_WRITE(DIO_MEM_PWR_CTRL, 0);\n\n\t\n\tif (dc->debug.enable_mem_low_power.bits.i2c)\n\t\tREG_UPDATE(DIO_MEM_PWR_CTRL, I2C_LIGHT_SLEEP_FORCE, 1);\n\n\tif (hws->funcs.setup_hpo_hw_control)\n\t\thws->funcs.setup_hpo_hw_control(hws, false);\n\n\tif (!dc->debug.disable_clock_gate) {\n\t\t \n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);\n\n\t\tREG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);\n\n\t\tREG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);\n\t}\n\n\tif (!dcb->funcs->is_accelerated_mode(dcb) && dc->res_pool->hubbub->funcs->init_watermarks)\n\t\tdc->res_pool->hubbub->funcs->init_watermarks(dc->res_pool->hubbub);\n\n\tif (dc->clk_mgr->funcs->notify_wm_ranges)\n\t\tdc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);\n\n\tif (dc->clk_mgr->funcs->set_hard_max_memclk && !dc->clk_mgr->dc_mode_softmax_enabled)\n\t\tdc->clk_mgr->funcs->set_hard_max_memclk(dc->clk_mgr);\n\n\tif (dc->res_pool->hubbub->funcs->force_pstate_change_control)\n\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control(\n\t\t\t\tdc->res_pool->hubbub, false, false);\n#if defined(CONFIG_DRM_AMD_DC_FP)\n\tif (dc->res_pool->hubbub->funcs->init_crb)\n\t\tdc->res_pool->hubbub->funcs->init_crb(dc->res_pool->hubbub);\n#endif\n\n\t\n\tdc_dmub_srv_query_caps_cmd(dc->ctx->dmub_srv);\n\tdc->caps.dmub_caps.psr = dc->ctx->dmub_srv->dmub->feature_caps.psr;\n\tdc->caps.dmub_caps.mclk_sw = dc->ctx->dmub_srv->dmub->feature_caps.fw_assisted_mclk_switch;\n}\n\nvoid dcn31_dsc_pg_control(\n\t\tstruct dce_hwseq *hws,\n\t\tunsigned int dsc_inst,\n\t\tbool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\treturn;\n\n\tif (hws->ctx->dc->debug.root_clock_optimization.bits.dsc &&\n\t\thws->ctx->dc->res_pool->dccg->funcs->enable_dsc &&\n\t\tpower_on)\n\t\thws->ctx->dc->res_pool->dccg->funcs->enable_dsc(\n\t\t\thws->ctx->dc->res_pool->dccg, dsc_inst);\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\tswitch (dsc_inst) {\n\tcase 0:  \n\t\tREG_UPDATE(DOMAIN16_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN16_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 1:  \n\t\tREG_UPDATE(DOMAIN17_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN17_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tcase 2:  \n\t\tREG_UPDATE(DOMAIN18_PG_CONFIG,\n\t\t\t\tDOMAIN_POWER_GATE, power_gate);\n\n\t\tREG_WAIT(DOMAIN18_PG_STATUS,\n\t\t\t\tDOMAIN_PGFSM_PWR_STATUS, pwr_status,\n\t\t\t\t1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n\n\tif (hws->ctx->dc->debug.root_clock_optimization.bits.dsc) {\n\t\tif (hws->ctx->dc->res_pool->dccg->funcs->disable_dsc && !power_on)\n\t\t\thws->ctx->dc->res_pool->dccg->funcs->disable_dsc(\n\t\t\t\thws->ctx->dc->res_pool->dccg, dsc_inst);\n\t}\n\n}\n\n\nvoid dcn31_enable_power_gating_plane(\n\tstruct dce_hwseq *hws,\n\tbool enable)\n{\n\tbool force_on = true;  \n\tuint32_t org_ip_request_cntl = 0;\n\n\tif (enable && !hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\tforce_on = false;\n\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\t \n\tREG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\t \n\tREG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\tforce_on = true;  \n\tif (enable && !hws->ctx->dc->debug.disable_dsc_power_gate)\n\t\tforce_on = false;\n\n\t \n\tREG_UPDATE(DOMAIN16_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN17_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\tREG_UPDATE(DOMAIN18_PG_CONFIG, DOMAIN_POWER_FORCEON, force_on);\n\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\nvoid dcn31_update_info_frame(struct pipe_ctx *pipe_ctx)\n{\n\tbool is_hdmi_tmds;\n\tbool is_dp;\n\n\tASSERT(pipe_ctx->stream);\n\n\tif (pipe_ctx->stream_res.stream_enc == NULL)\n\t\treturn;   \n\n\tis_hdmi_tmds = dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal);\n\tis_dp = dc_is_dp_signal(pipe_ctx->stream->signal);\n\n\tif (!is_hdmi_tmds && !is_dp)\n\t\treturn;\n\n\tif (is_hdmi_tmds)\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\telse if (pipe_ctx->stream->ctx->dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->update_dp_info_packets(\n\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc,\n\t\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\t\treturn;\n\t} else {\n\t\tif (pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num)\n\t\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets_sdp_line_num(\n\t\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\n\t\tpipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc,\n\t\t\t&pipe_ctx->stream_res.encoder_info_frame);\n\t}\n}\nvoid dcn31_z10_save_init(struct dc *dc)\n{\n\tunion dmub_rb_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.dcn_restore.header.type = DMUB_CMD__IDLE_OPT;\n\tcmd.dcn_restore.header.sub_type = DMUB_CMD__IDLE_OPT_DCN_SAVE_INIT;\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nvoid dcn31_z10_restore(const struct dc *dc)\n{\n\tunion dmub_rb_cmd cmd;\n\n\t \n\tif (!dc_dmub_srv_is_restore_required(dc->ctx->dmub_srv))\n\t\treturn;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.dcn_restore.header.type = DMUB_CMD__IDLE_OPT;\n\tcmd.dcn_restore.header.sub_type = DMUB_CMD__IDLE_OPT_DCN_RESTORE;\n\n\tdm_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\nvoid dcn31_hubp_pg_control(struct dce_hwseq *hws, unsigned int hubp_inst, bool power_on)\n{\n\tuint32_t power_gate = power_on ? 0 : 1;\n\tuint32_t pwr_status = power_on ? 0 : 2;\n\tuint32_t org_ip_request_cntl;\n\tif (hws->ctx->dc->debug.disable_hubp_power_gate)\n\t\treturn;\n\n\tif (REG(DOMAIN0_PG_CONFIG) == 0)\n\t\treturn;\n\tREG_GET(DC_IP_REQUEST_CNTL, IP_REQUEST_EN, &org_ip_request_cntl);\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 1);\n\n\tswitch (hubp_inst) {\n\tcase 0:\n\t\tREG_SET(DOMAIN0_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN0_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 1:\n\t\tREG_SET(DOMAIN1_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN1_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 2:\n\t\tREG_SET(DOMAIN2_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN2_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tcase 3:\n\t\tREG_SET(DOMAIN3_PG_CONFIG, 0, DOMAIN_POWER_GATE, power_gate);\n\t\tREG_WAIT(DOMAIN3_PG_STATUS, DOMAIN_PGFSM_PWR_STATUS, pwr_status, 1, 1000);\n\t\tbreak;\n\tdefault:\n\t\tBREAK_TO_DEBUGGER();\n\t\tbreak;\n\t}\n\tif (org_ip_request_cntl == 0)\n\t\tREG_SET(DC_IP_REQUEST_CNTL, 0, IP_REQUEST_EN, 0);\n}\n\nint dcn31_init_sys_ctx(struct dce_hwseq *hws, struct dc *dc, struct dc_phy_addr_space_config *pa_config)\n{\n\tstruct dcn_hubbub_phys_addr_config config;\n\n\tconfig.system_aperture.fb_top = pa_config->system_aperture.fb_top;\n\tconfig.system_aperture.fb_offset = pa_config->system_aperture.fb_offset;\n\tconfig.system_aperture.fb_base = pa_config->system_aperture.fb_base;\n\tconfig.system_aperture.agp_top = pa_config->system_aperture.agp_top;\n\tconfig.system_aperture.agp_bot = pa_config->system_aperture.agp_bot;\n\tconfig.system_aperture.agp_base = pa_config->system_aperture.agp_base;\n\tconfig.gart_config.page_table_start_addr = pa_config->gart_config.page_table_start_addr;\n\tconfig.gart_config.page_table_end_addr = pa_config->gart_config.page_table_end_addr;\n\n\tif (pa_config->gart_config.base_addr_is_mc_addr) {\n\t\t \n\t\tconfig.gart_config.page_table_base_addr = pa_config->gart_config.page_table_base_addr -\n\t\t\t\tpa_config->system_aperture.fb_base +\n\t\t\t\tpa_config->system_aperture.fb_offset;\n\t} else\n\t\tconfig.gart_config.page_table_base_addr = pa_config->gart_config.page_table_base_addr;\n\n\treturn dc->res_pool->hubbub->funcs->init_dchub_sys_ctx(dc->res_pool->hubbub, &config);\n}\n\nstatic void dcn31_reset_back_end_for_pipe(\n\t\tstruct dc *dc,\n\t\tstruct pipe_ctx *pipe_ctx,\n\t\tstruct dc_state *context)\n{\n\tstruct dc_link *link;\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\tif (pipe_ctx->stream_res.stream_enc == NULL) {\n\t\tpipe_ctx->stream = NULL;\n\t\treturn;\n\t}\n\tASSERT(!pipe_ctx->top_pipe);\n\n\tdc->hwss.set_abm_immediate_disable(pipe_ctx);\n\n\tpipe_ctx->stream_res.tg->funcs->set_dsc_config(\n\t\t\tpipe_ctx->stream_res.tg,\n\t\t\tOPTC_DSC_DISABLED, 0, 0);\n\tpipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);\n\tpipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);\n\tif (pipe_ctx->stream_res.tg->funcs->set_odm_bypass)\n\t\tpipe_ctx->stream_res.tg->funcs->set_odm_bypass(\n\t\t\t\tpipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);\n\tpipe_ctx->stream->link->phy_state.symclk_ref_cnts.otg = 0;\n\n\tif (pipe_ctx->stream_res.tg->funcs->set_drr)\n\t\tpipe_ctx->stream_res.tg->funcs->set_drr(\n\t\t\t\tpipe_ctx->stream_res.tg, NULL);\n\n\tlink = pipe_ctx->stream->link;\n\t \n\t \n\tif (!pipe_ctx->stream->dpms_off || link->link_status.link_active)\n\t\tdc->link_srv->set_dpms_off(pipe_ctx);\n\telse if (pipe_ctx->stream_res.audio)\n\t\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\t \n\tif (pipe_ctx->stream_res.audio) {\n\t\t \n\t\tpipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);\n\n\t\t \n\t\tif (dc->caps.dynamic_audio == true) {\n\t\t\t \n\t\t\t \n\t\t\tupdate_audio_usage(&dc->current_state->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe_ctx->stream_res.audio, false);\n\t\t\tpipe_ctx->stream_res.audio = NULL;\n\t\t}\n\t}\n\n\tpipe_ctx->stream = NULL;\n\tDC_LOG_DEBUG(\"Reset back end for pipe %d, tg:%d\\n\",\n\t\t\t\t\tpipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);\n}\n\nvoid dcn31_reset_hw_ctx_wrap(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tfor (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {\n\t\tstruct pipe_ctx *pipe_ctx_old =\n\t\t\t&dc->current_state->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (!pipe_ctx_old->stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_ctx_old->top_pipe || pipe_ctx_old->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tif (!pipe_ctx->stream ||\n\t\t\t\tpipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {\n\t\t\tstruct clock_source *old_clk = pipe_ctx_old->clock_source;\n\n\t\t\tdcn31_reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);\n\t\t\tif (hws->funcs.enable_stream_gating)\n\t\t\t\thws->funcs.enable_stream_gating(dc, pipe_ctx_old);\n\t\t\tif (old_clk)\n\t\t\t\told_clk->funcs->cs_power_down(old_clk);\n\t\t}\n\t}\n\n\t \n\tlink_enc_cfg_set_transient_mode(dc, dc->current_state, context);\n}\n\nvoid dcn31_setup_hpo_hw_control(const struct dce_hwseq *hws, bool enable)\n{\n\tif (hws->ctx->dc->debug.hpo_optimization)\n\t\tREG_UPDATE(HPO_TOP_HW_CONTROL, HPO_IO_EN, !!enable);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}