{
  "module_name": "dmub_psr.c",
  "hash_id": "24ebef133004e056110b7310d2de7d00d99fdf0f335fceebbd10ff392c2eba8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dmub_psr.c",
  "human_readable_source": " \n\n#include \"dmub_psr.h\"\n#include \"dc.h\"\n#include \"dc_dmub_srv.h\"\n#include \"dmub/dmub_srv.h\"\n#include \"core_types.h\"\n\n#define DC_TRACE_LEVEL_MESSAGE(...)\tdo {} while (0)  \n\n#define MAX_PIPES 6\n\nstatic const uint8_t DP_SINK_DEVICE_STR_ID_1[] = {7, 1, 8, 7, 3};\nstatic const uint8_t DP_SINK_DEVICE_STR_ID_2[] = {7, 1, 8, 7, 5};\n\n \nstatic enum dc_psr_state convert_psr_state(uint32_t raw_state)\n{\n\tenum dc_psr_state state = PSR_STATE0;\n\n\tif (raw_state == 0)\n\t\tstate = PSR_STATE0;\n\telse if (raw_state == 0x10)\n\t\tstate = PSR_STATE1;\n\telse if (raw_state == 0x11)\n\t\tstate = PSR_STATE1a;\n\telse if (raw_state == 0x20)\n\t\tstate = PSR_STATE2;\n\telse if (raw_state == 0x21)\n\t\tstate = PSR_STATE2a;\n\telse if (raw_state == 0x22)\n\t\tstate = PSR_STATE2b;\n\telse if (raw_state == 0x30)\n\t\tstate = PSR_STATE3;\n\telse if (raw_state == 0x31)\n\t\tstate = PSR_STATE3Init;\n\telse if (raw_state == 0x40)\n\t\tstate = PSR_STATE4;\n\telse if (raw_state == 0x41)\n\t\tstate = PSR_STATE4a;\n\telse if (raw_state == 0x42)\n\t\tstate = PSR_STATE4b;\n\telse if (raw_state == 0x43)\n\t\tstate = PSR_STATE4c;\n\telse if (raw_state == 0x44)\n\t\tstate = PSR_STATE4d;\n\telse if (raw_state == 0x50)\n\t\tstate = PSR_STATE5;\n\telse if (raw_state == 0x51)\n\t\tstate = PSR_STATE5a;\n\telse if (raw_state == 0x52)\n\t\tstate = PSR_STATE5b;\n\telse if (raw_state == 0x53)\n\t\tstate = PSR_STATE5c;\n\telse if (raw_state == 0x4A)\n\t\tstate = PSR_STATE4_FULL_FRAME;\n\telse if (raw_state == 0x4B)\n\t\tstate = PSR_STATE4a_FULL_FRAME;\n\telse if (raw_state == 0x4C)\n\t\tstate = PSR_STATE4b_FULL_FRAME;\n\telse if (raw_state == 0x4D)\n\t\tstate = PSR_STATE4c_FULL_FRAME;\n\telse if (raw_state == 0x4E)\n\t\tstate = PSR_STATE4_FULL_FRAME_POWERUP;\n\telse if (raw_state == 0x4F)\n\t\tstate = PSR_STATE4_FULL_FRAME_HW_LOCK;\n\telse if (raw_state == 0x60)\n\t\tstate = PSR_STATE_HWLOCK_MGR;\n\telse if (raw_state == 0x61)\n\t\tstate = PSR_STATE_POLLVUPDATE;\n\telse\n\t\tstate = PSR_STATE_INVALID;\n\n\treturn state;\n}\n\n \nstatic void dmub_psr_get_state(struct dmub_psr *dmub, enum dc_psr_state *state, uint8_t panel_inst)\n{\n\tstruct dmub_srv *srv = dmub->ctx->dmub_srv->dmub;\n\tuint32_t raw_state = 0;\n\tuint32_t retry_count = 0;\n\tenum dmub_status status;\n\n\tdo {\n\t\t\n\t\tstatus = dmub_srv_send_gpint_command(srv, DMUB_GPINT__GET_PSR_STATE, panel_inst, 30);\n\n\t\tif (status == DMUB_STATUS_OK) {\n\t\t\t\n\t\t\tdmub_srv_get_gpint_response(srv, &raw_state);\n\t\t\t*state = convert_psr_state(raw_state);\n\t\t} else\n\t\t\t\n\t\t\t*state = PSR_STATE_INVALID;\n\n\t} while (++retry_count <= 1000 && *state == PSR_STATE_INVALID);\n\n\t\n\tif (retry_count >= 1000 && *state == PSR_STATE_INVALID) {\n\t\tASSERT(0);\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_ERROR,\n\t\t\t\tWPP_BIT_FLAG_Firmware_PsrState,\n\t\t\t\t\"Unable to get PSR state from FW.\");\n\t} else\n\t\tDC_TRACE_LEVEL_MESSAGE(DAL_TRACE_LEVEL_VERBOSE,\n\t\t\t\tWPP_BIT_FLAG_Firmware_PsrState,\n\t\t\t\t\"Got PSR state from FW. PSR state: %d, Retry count: %d\",\n\t\t\t\t*state, retry_count);\n}\n\n \nstatic bool dmub_psr_set_version(struct dmub_psr *dmub, struct dc_stream_state *stream, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tif (stream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED)\n\t\treturn false;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_set_version.header.type = DMUB_CMD__PSR;\n\tcmd.psr_set_version.header.sub_type = DMUB_CMD__PSR_SET_VERSION;\n\tswitch (stream->link->psr_settings.psr_version) {\n\tcase DC_PSR_VERSION_1:\n\t\tcmd.psr_set_version.psr_set_version_data.version = PSR_VERSION_1;\n\t\tbreak;\n\tcase DC_PSR_VERSION_SU_1:\n\t\tcmd.psr_set_version.psr_set_version_data.version = PSR_VERSION_SU_1;\n\t\tbreak;\n\tcase DC_PSR_VERSION_UNSUPPORTED:\n\tdefault:\n\t\tcmd.psr_set_version.psr_set_version_data.version = PSR_VERSION_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (cmd.psr_set_version.psr_set_version_data.version == PSR_VERSION_UNSUPPORTED)\n\t\treturn false;\n\n\tcmd.psr_set_version.psr_set_version_data.cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcmd.psr_set_version.psr_set_version_data.panel_inst = panel_inst;\n\tcmd.psr_set_version.header.payload_bytes = sizeof(struct dmub_cmd_psr_set_version_data);\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n \nstatic void dmub_psr_enable(struct dmub_psr *dmub, bool enable, bool wait, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\tuint32_t retry_count;\n\tenum dc_psr_state state = PSR_STATE0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_enable.header.type = DMUB_CMD__PSR;\n\n\tcmd.psr_enable.data.cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcmd.psr_enable.data.panel_inst = panel_inst;\n\n\tif (enable)\n\t\tcmd.psr_enable.header.sub_type = DMUB_CMD__PSR_ENABLE;\n\telse\n\t\tcmd.psr_enable.header.sub_type = DMUB_CMD__PSR_DISABLE;\n\n\tcmd.psr_enable.header.payload_bytes = 0; \n\n\tdm_execute_dmub_cmd(dc->dmub_srv->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t \n\tif (wait) {\n\t\tfor (retry_count = 0; retry_count <= 1000; retry_count++) {\n\t\t\tdmub_psr_get_state(dmub, &state, panel_inst);\n\n\t\t\tif (enable) {\n\t\t\t\tif (state != PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (state == PSR_STATE0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tudelay(500);\n\t\t}\n\n\t\t \n\t\tif (retry_count >= 1000)\n\t\t\tASSERT(0);\n\t}\n}\n\n \nstatic void dmub_psr_set_level(struct dmub_psr *dmub, uint16_t psr_level, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tenum dc_psr_state state = PSR_STATE0;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tdmub_psr_get_state(dmub, &state, panel_inst);\n\n\tif (state == PSR_STATE0)\n\t\treturn;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_set_level.header.type = DMUB_CMD__PSR;\n\tcmd.psr_set_level.header.sub_type = DMUB_CMD__PSR_SET_LEVEL;\n\tcmd.psr_set_level.header.payload_bytes = sizeof(struct dmub_cmd_psr_set_level_data);\n\tcmd.psr_set_level.psr_set_level_data.psr_level = psr_level;\n\tcmd.psr_set_level.psr_set_level_data.cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcmd.psr_set_level.psr_set_level_data.panel_inst = panel_inst;\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic void dmub_psr_set_sink_vtotal_in_psr_active(struct dmub_psr *dmub,\n\t\tuint16_t psr_vtotal_idle, uint16_t psr_vtotal_su)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_set_vtotal.header.type = DMUB_CMD__PSR;\n\tcmd.psr_set_vtotal.header.sub_type = DMUB_CMD__SET_SINK_VTOTAL_IN_PSR_ACTIVE;\n\tcmd.psr_set_vtotal.header.payload_bytes = sizeof(struct dmub_cmd_psr_set_vtotal_data);\n\tcmd.psr_set_vtotal.psr_set_vtotal_data.psr_vtotal_idle = psr_vtotal_idle;\n\tcmd.psr_set_vtotal.psr_set_vtotal_data.psr_vtotal_su = psr_vtotal_su;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic void dmub_psr_set_power_opt(struct dmub_psr *dmub, unsigned int power_opt, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_set_power_opt.header.type = DMUB_CMD__PSR;\n\tcmd.psr_set_power_opt.header.sub_type = DMUB_CMD__SET_PSR_POWER_OPT;\n\tcmd.psr_set_power_opt.header.payload_bytes = sizeof(struct dmub_cmd_psr_set_power_opt_data);\n\tcmd.psr_set_power_opt.psr_set_power_opt_data.cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcmd.psr_set_power_opt.psr_set_power_opt_data.power_opt = power_opt;\n\tcmd.psr_set_power_opt.psr_set_power_opt_data.panel_inst = panel_inst;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic bool dmub_psr_copy_settings(struct dmub_psr *dmub,\n\t\tstruct dc_link *link,\n\t\tstruct psr_context *psr_context,\n\t\tuint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\tstruct dmub_cmd_psr_copy_settings_data *copy_settings_data\n\t\t= &cmd.psr_copy_settings.psr_copy_settings_data;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tstruct resource_context *res_ctx = &link->ctx->dc->current_state->res_ctx;\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (res_ctx->pipe_ctx[i].stream &&\n\t\t    res_ctx->pipe_ctx[i].stream->link == link &&\n\t\t    res_ctx->pipe_ctx[i].stream->link->connector_signal == SIGNAL_TYPE_EDP) {\n\t\t\tpipe_ctx = &res_ctx->pipe_ctx[i];\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pipe_ctx)\n\t\treturn false;\n\n\t\n\tif (!dmub_psr_set_version(dmub, pipe_ctx->stream, panel_inst))\n\t\treturn false;\n\n\t\n\tlink->link_enc->funcs->psr_program_dp_dphy_fast_training(link->link_enc,\n\t\t\tpsr_context->psrExitLinkTrainingRequired);\n\n\t\n\tlink->link_enc->funcs->psr_program_secondary_packet(link->link_enc,\n\t\t\tpsr_context->sdpTransmitLineNumDeadline);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.psr_copy_settings.header.type = DMUB_CMD__PSR;\n\tcmd.psr_copy_settings.header.sub_type = DMUB_CMD__PSR_COPY_SETTINGS;\n\tcmd.psr_copy_settings.header.payload_bytes = sizeof(struct dmub_cmd_psr_copy_settings_data);\n\n\t\n\tcopy_settings_data->dpphy_inst\t\t\t\t= psr_context->transmitterId;\n\tcopy_settings_data->aux_inst\t\t\t\t= psr_context->channel;\n\tcopy_settings_data->digfe_inst\t\t\t\t= psr_context->engineId;\n\tcopy_settings_data->digbe_inst\t\t\t\t= psr_context->transmitterId;\n\n\tcopy_settings_data->mpcc_inst\t\t\t\t= pipe_ctx->plane_res.mpcc_inst;\n\n\tif (pipe_ctx->plane_res.dpp)\n\t\tcopy_settings_data->dpp_inst\t\t\t= pipe_ctx->plane_res.dpp->inst;\n\telse\n\t\tcopy_settings_data->dpp_inst\t\t\t= 0;\n\tif (pipe_ctx->stream_res.opp)\n\t\tcopy_settings_data->opp_inst\t\t\t= pipe_ctx->stream_res.opp->inst;\n\telse\n\t\tcopy_settings_data->opp_inst\t\t\t= 0;\n\tif (pipe_ctx->stream_res.tg)\n\t\tcopy_settings_data->otg_inst\t\t\t= pipe_ctx->stream_res.tg->inst;\n\telse\n\t\tcopy_settings_data->otg_inst\t\t\t= 0;\n\n\t\n\tcopy_settings_data->use_phy_fsm             = link->ctx->dc->debug.psr_power_use_phy_fsm;\n\tcopy_settings_data->psr_level\t\t\t\t= psr_context->psr_level.u32all;\n\tcopy_settings_data->smu_optimizations_en\t\t= psr_context->allow_smu_optimizations;\n\tcopy_settings_data->multi_disp_optimizations_en\t= psr_context->allow_multi_disp_optimizations;\n\tcopy_settings_data->frame_delay\t\t\t\t= psr_context->frame_delay;\n\tcopy_settings_data->frame_cap_ind\t\t\t= psr_context->psrFrameCaptureIndicationReq;\n\tcopy_settings_data->init_sdp_deadline\t\t\t= psr_context->sdpTransmitLineNumDeadline;\n\tcopy_settings_data->debug.u32All = 0;\n\tcopy_settings_data->debug.bitfields.visual_confirm\t= dc->dc->debug.visual_confirm == VISUAL_CONFIRM_PSR;\n\tcopy_settings_data->debug.bitfields.use_hw_lock_mgr\t\t= 1;\n\tcopy_settings_data->debug.bitfields.force_full_frame_update\t= 0;\n\n\tif (psr_context->su_granularity_required == 0)\n\t\tcopy_settings_data->su_y_granularity = 0;\n\telse\n\t\tcopy_settings_data->su_y_granularity = psr_context->su_y_granularity;\n\n\tcopy_settings_data->line_capture_indication = 0;\n\tcopy_settings_data->line_time_in_us = psr_context->line_time_in_us;\n\tcopy_settings_data->rate_control_caps = psr_context->rate_control_caps;\n\tcopy_settings_data->fec_enable_status = (link->fec_state == dc_link_fec_enabled);\n\tcopy_settings_data->fec_enable_delay_in100us = link->dc->debug.fec_enable_delay_in100us;\n\tcopy_settings_data->cmd_version =  DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcopy_settings_data->panel_inst = panel_inst;\n\tcopy_settings_data->dsc_enable_status = (pipe_ctx->stream->timing.flags.DSC == 1);\n\n\t \n\tif (copy_settings_data->dsc_enable_status &&\n\t\tlink->dpcd_caps.sink_dev_id == DP_DEVICE_ID_38EC11 &&\n\t\t!memcmp(link->dpcd_caps.sink_dev_id_str, DP_SINK_DEVICE_STR_ID_1,\n\t\t\tsizeof(DP_SINK_DEVICE_STR_ID_1)))\n\t\tlink->psr_settings.force_ffu_mode = 1;\n\telse\n\t\tlink->psr_settings.force_ffu_mode = 0;\n\tcopy_settings_data->force_ffu_mode = link->psr_settings.force_ffu_mode;\n\n\tif (((link->dpcd_caps.fec_cap.bits.FEC_CAPABLE &&\n\t\t!link->dc->debug.disable_fec) &&\n\t\t(link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT &&\n\t\t!link->panel_config.dsc.disable_dsc_edp &&\n\t\tlink->dc->caps.edp_dsc_support)) &&\n\t\tlink->dpcd_caps.sink_dev_id == DP_DEVICE_ID_38EC11 &&\n\t\t(!memcmp(link->dpcd_caps.sink_dev_id_str, DP_SINK_DEVICE_STR_ID_1,\n\t\t\tsizeof(DP_SINK_DEVICE_STR_ID_1)) ||\n\t\t!memcmp(link->dpcd_caps.sink_dev_id_str, DP_SINK_DEVICE_STR_ID_2,\n\t\t\tsizeof(DP_SINK_DEVICE_STR_ID_2))))\n\t\tcopy_settings_data->debug.bitfields.force_wakeup_by_tps3 = 1;\n\telse\n\t\tcopy_settings_data->debug.bitfields.force_wakeup_by_tps3 = 0;\n\n\t\n\tcopy_settings_data->relock_delay_frame_cnt = 0;\n\tif (link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_001CF8)\n\t\tcopy_settings_data->relock_delay_frame_cnt = 2;\n\tcopy_settings_data->dsc_slice_height = psr_context->dsc_slice_height;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n\n \nstatic void dmub_psr_force_static(struct dmub_psr *dmub, uint8_t panel_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = dmub->ctx;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.psr_force_static.psr_force_static_data.panel_inst = panel_inst;\n\tcmd.psr_force_static.psr_force_static_data.cmd_version = DMUB_CMD_PSR_CONTROL_VERSION_1;\n\tcmd.psr_force_static.header.type = DMUB_CMD__PSR;\n\tcmd.psr_force_static.header.sub_type = DMUB_CMD__PSR_FORCE_STATIC;\n\tcmd.psr_enable.header.payload_bytes = 0;\n\n\tdm_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n}\n\n \nstatic void dmub_psr_get_residency(struct dmub_psr *dmub, uint32_t *residency, uint8_t panel_inst)\n{\n\tstruct dmub_srv *srv = dmub->ctx->dmub_srv->dmub;\n\tuint16_t param = (uint16_t)(panel_inst << 8);\n\n\t \n\tdmub_srv_send_gpint_command(srv, DMUB_GPINT__PSR_RESIDENCY, param, 30);\n\n\tdmub_srv_get_gpint_response(srv, residency);\n}\n\nstatic const struct dmub_psr_funcs psr_funcs = {\n\t.psr_copy_settings\t\t= dmub_psr_copy_settings,\n\t.psr_enable\t\t\t= dmub_psr_enable,\n\t.psr_get_state\t\t\t= dmub_psr_get_state,\n\t.psr_set_level\t\t\t= dmub_psr_set_level,\n\t.psr_force_static\t\t= dmub_psr_force_static,\n\t.psr_get_residency\t\t= dmub_psr_get_residency,\n\t.psr_set_sink_vtotal_in_psr_active\t= dmub_psr_set_sink_vtotal_in_psr_active,\n\t.psr_set_power_opt\t\t= dmub_psr_set_power_opt,\n};\n\n \nstatic void dmub_psr_construct(struct dmub_psr *psr, struct dc_context *ctx)\n{\n\tpsr->ctx = ctx;\n\tpsr->funcs = &psr_funcs;\n}\n\n \nstruct dmub_psr *dmub_psr_create(struct dc_context *ctx)\n{\n\tstruct dmub_psr *psr = kzalloc(sizeof(struct dmub_psr), GFP_KERNEL);\n\n\tif (psr == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdmub_psr_construct(psr, ctx);\n\n\treturn psr;\n}\n\n \nvoid dmub_psr_destroy(struct dmub_psr **dmub)\n{\n\tkfree(*dmub);\n\t*dmub = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}