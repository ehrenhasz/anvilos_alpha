{
  "module_name": "dce_hwseq.c",
  "hash_id": "cbc93aa6de7047b5b9ed6079afb458c8846053ab11b1c04fbf07a2330eeed810",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c",
  "human_readable_source": " \n\n#include \"dce_hwseq.h\"\n#include \"reg_helper.h\"\n#include \"hw_sequencer_private.h\"\n#include \"core_types.h\"\n\n#define CTX \\\n\thws->ctx\n#define REG(reg)\\\n\thws->regs->reg\n\n#undef FN\n#define FN(reg_name, field_name) \\\n\thws->shifts->field_name, hws->masks->field_name\n\nvoid dce_enable_fe_clock(struct dce_hwseq *hws,\n\t\tunsigned int fe_inst, bool enable)\n{\n\tREG_UPDATE(DCFE_CLOCK_CONTROL[fe_inst],\n\t\t\tDCFE_CLOCK_ENABLE, enable);\n}\n\nvoid dce_pipe_control_lock(struct dc *dc,\n\t\tstruct pipe_ctx *pipe,\n\t\tbool lock)\n{\n\tuint32_t lock_val = lock ? 1 : 0;\n\tuint32_t dcp_grph, scl, blnd, update_lock_mode, val;\n\tstruct dce_hwseq *hws = dc->hwseq;\n\n\t \n\tif (lock && pipe->stream_res.tg->funcs->is_blanked &&\n\t    pipe->stream_res.tg->funcs->is_blanked(pipe->stream_res.tg))\n\t\treturn;\n\n\tval = REG_GET_4(BLND_V_UPDATE_LOCK[pipe->stream_res.tg->inst],\n\t\t\tBLND_DCP_GRPH_V_UPDATE_LOCK, &dcp_grph,\n\t\t\tBLND_SCL_V_UPDATE_LOCK, &scl,\n\t\t\tBLND_BLND_V_UPDATE_LOCK, &blnd,\n\t\t\tBLND_V_UPDATE_LOCK_MODE, &update_lock_mode);\n\n\tdcp_grph = lock_val;\n\tscl = lock_val;\n\tblnd = lock_val;\n\tupdate_lock_mode = lock_val;\n\n\tREG_SET_2(BLND_V_UPDATE_LOCK[pipe->stream_res.tg->inst], val,\n\t\t\tBLND_DCP_GRPH_V_UPDATE_LOCK, dcp_grph,\n\t\t\tBLND_SCL_V_UPDATE_LOCK, scl);\n\n\tif (hws->masks->BLND_BLND_V_UPDATE_LOCK != 0)\n\t\tREG_SET_2(BLND_V_UPDATE_LOCK[pipe->stream_res.tg->inst], val,\n\t\t\t\tBLND_BLND_V_UPDATE_LOCK, blnd,\n\t\t\t\tBLND_V_UPDATE_LOCK_MODE, update_lock_mode);\n\n\tif (hws->wa.blnd_crtc_trigger) {\n\t\tif (!lock) {\n\t\t\tuint32_t value = REG_READ(CRTC_H_BLANK_START_END[pipe->stream_res.tg->inst]);\n\t\t\tREG_WRITE(CRTC_H_BLANK_START_END[pipe->stream_res.tg->inst], value);\n\t\t}\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\nvoid dce60_pipe_control_lock(struct dc *dc,\n\t\tstruct pipe_ctx *pipe,\n\t\tbool lock)\n{\n\t \n}\n#endif\n\nvoid dce_set_blender_mode(struct dce_hwseq *hws,\n\tunsigned int blnd_inst,\n\tenum blnd_mode mode)\n{\n\tuint32_t feedthrough = 1;\n\tuint32_t blnd_mode = 0;\n\tuint32_t multiplied_mode = 0;\n\tuint32_t alpha_mode = 2;\n\n\tswitch (mode) {\n\tcase BLND_MODE_OTHER_PIPE:\n\t\tfeedthrough = 0;\n\t\tblnd_mode = 1;\n\t\talpha_mode = 0;\n\t\tbreak;\n\tcase BLND_MODE_BLENDING:\n\t\tfeedthrough = 0;\n\t\tblnd_mode = 2;\n\t\talpha_mode = 0;\n\t\tmultiplied_mode = 1;\n\t\tbreak;\n\tcase BLND_MODE_CURRENT_PIPE:\n\tdefault:\n\t\tif (REG(BLND_CONTROL[blnd_inst]) == REG(BLNDV_CONTROL) ||\n\t\t\t\tblnd_inst == 0)\n\t\t\tfeedthrough = 0;\n\t\tbreak;\n\t}\n\n\tREG_UPDATE(BLND_CONTROL[blnd_inst],\n\t\tBLND_MODE, blnd_mode);\n\n\tif (hws->masks->BLND_ALPHA_MODE != 0) {\n\t\tREG_UPDATE_3(BLND_CONTROL[blnd_inst],\n\t\t\tBLND_FEEDTHROUGH_EN, feedthrough,\n\t\t\tBLND_ALPHA_MODE, alpha_mode,\n\t\t\tBLND_MULTIPLIED_MODE, multiplied_mode);\n\t}\n}\n\n\nstatic void dce_disable_sram_shut_down(struct dce_hwseq *hws)\n{\n\tif (REG(DC_MEM_GLOBAL_PWR_REQ_CNTL))\n\t\tREG_UPDATE(DC_MEM_GLOBAL_PWR_REQ_CNTL,\n\t\t\t\tDC_MEM_GLOBAL_PWR_REQ_DIS, 1);\n}\n\nstatic void dce_underlay_clock_enable(struct dce_hwseq *hws)\n{\n\t \n\tif (REG(DCFEV_CLOCK_CONTROL))\n\t\tREG_UPDATE(DCFEV_CLOCK_CONTROL,\n\t\t\t\tDCFEV_CLOCK_ENABLE, 1);\n}\n\nstatic void enable_hw_base_light_sleep(void)\n{\n\t \n}\n\nstatic void disable_sw_manual_control_light_sleep(void)\n{\n\t \n}\n\nvoid dce_clock_gating_power_up(struct dce_hwseq *hws,\n\t\tbool enable)\n{\n\tif (enable) {\n\t\tenable_hw_base_light_sleep();\n\t\tdisable_sw_manual_control_light_sleep();\n\t} else {\n\t\tdce_disable_sram_shut_down(hws);\n\t\tdce_underlay_clock_enable(hws);\n\t}\n}\n\nvoid dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,\n\t\tstruct clock_source *clk_src,\n\t\tunsigned int tg_inst)\n{\n\tif (clk_src->id == CLOCK_SOURCE_ID_DP_DTO || clk_src->dp_clk_src) {\n\t\tREG_UPDATE(PIXEL_RATE_CNTL[tg_inst],\n\t\t\t\tDP_DTO0_ENABLE, 1);\n\n\t} else if (clk_src->id >= CLOCK_SOURCE_COMBO_PHY_PLL0) {\n\t\tuint32_t rate_source = clk_src->id - CLOCK_SOURCE_COMBO_PHY_PLL0;\n\n\t\tREG_UPDATE_2(PHYPLL_PIXEL_RATE_CNTL[tg_inst],\n\t\t\t\tPHYPLL_PIXEL_RATE_SOURCE, rate_source,\n\t\t\t\tPIXEL_RATE_PLL_SOURCE, 0);\n\n\t\tREG_UPDATE(PIXEL_RATE_CNTL[tg_inst],\n\t\t\t\tDP_DTO0_ENABLE, 0);\n\n\t} else if (clk_src->id <= CLOCK_SOURCE_ID_PLL2) {\n\t\tuint32_t rate_source = clk_src->id - CLOCK_SOURCE_ID_PLL0;\n\n\t\tREG_UPDATE_2(PIXEL_RATE_CNTL[tg_inst],\n\t\t\t\tPIXEL_RATE_SOURCE, rate_source,\n\t\t\t\tDP_DTO0_ENABLE, 0);\n\n\t\tif (REG(PHYPLL_PIXEL_RATE_CNTL[tg_inst]))\n\t\t\tREG_UPDATE(PHYPLL_PIXEL_RATE_CNTL[tg_inst],\n\t\t\t\t\tPIXEL_RATE_PLL_SOURCE, 1);\n\t} else {\n\t\tDC_ERR(\"Unknown clock source. clk_src id: %d, TG_inst: %d\",\n\t\t       clk_src->id, tg_inst);\n\t}\n}\n\n \nbool dce_use_lut(enum surface_pixel_format format)\n{\n\tswitch (format) {\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:\n\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}