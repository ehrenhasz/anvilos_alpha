{
  "module_name": "amdgpu_dm_debugfs.c",
  "hash_id": "e7d1ac3c870ee8b0681a8970f6669573aec5a4f3795a69da9fde9a8eed8d7307",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c",
  "human_readable_source": " \n\n#include <linux/string_helpers.h>\n#include <linux/uaccess.h>\n\n#include \"dc.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_dm.h\"\n#include \"amdgpu_dm_debugfs.h\"\n#include \"dm_helpers.h\"\n#include \"dmub/dmub_srv.h\"\n#include \"resource.h\"\n#include \"dsc.h\"\n#include \"link_hwss.h\"\n#include \"dc/dc_dmub_srv.h\"\n#include \"link/protocols/link_dp_capability.h\"\n\n#ifdef CONFIG_DRM_AMD_SECURE_DISPLAY\n#include \"amdgpu_dm_psr.h\"\n#endif\n\nstruct dmub_debugfs_trace_header {\n\tuint32_t entry_count;\n\tuint32_t reserved[3];\n};\n\nstruct dmub_debugfs_trace_entry {\n\tuint32_t trace_code;\n\tuint32_t tick_count;\n\tuint32_t param0;\n\tuint32_t param1;\n};\n\nstatic const char *const mst_progress_status[] = {\n\t\"probe\",\n\t\"remote_edid\",\n\t\"allocate_new_payload\",\n\t\"clear_allocated_payload\",\n};\n\n \nstatic int parse_write_buffer_into_params(char *wr_buf, uint32_t wr_buf_size,\n\t\t\t\t\t  long *param, const char __user *buf,\n\t\t\t\t\t  int max_param_num,\n\t\t\t\t\t  uint8_t *param_nums)\n{\n\tchar *wr_buf_ptr = NULL;\n\tuint32_t wr_buf_count = 0;\n\tint r;\n\tchar *sub_str = NULL;\n\tconst char delimiter[3] = {' ', '\\n', '\\0'};\n\tuint8_t param_index = 0;\n\n\t*param_nums = 0;\n\n\twr_buf_ptr = wr_buf;\n\n\t \n\tif (copy_from_user(wr_buf_ptr, buf, wr_buf_size)) {\n\t\tDRM_DEBUG_DRIVER(\"user data could not be read successfully\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\twhile ((*wr_buf_ptr != 0xa) && (wr_buf_count < wr_buf_size)) {\n\t\t \n\t\twhile (isspace(*wr_buf_ptr) && (wr_buf_count < wr_buf_size)) {\n\t\t\twr_buf_ptr++;\n\t\t\twr_buf_count++;\n\t\t\t}\n\n\t\tif (wr_buf_count == wr_buf_size)\n\t\t\tbreak;\n\n\t\t \n\t\twhile ((!isspace(*wr_buf_ptr)) && (wr_buf_count < wr_buf_size)) {\n\t\t\twr_buf_ptr++;\n\t\t\twr_buf_count++;\n\t\t}\n\n\t\t(*param_nums)++;\n\n\t\tif (wr_buf_count == wr_buf_size)\n\t\t\tbreak;\n\t}\n\n\tif (*param_nums > max_param_num)\n\t\t*param_nums = max_param_num;\n\n\twr_buf_ptr = wr_buf;  \n\twr_buf_count = 0;  \n\n\twhile (isspace(*wr_buf_ptr) && (wr_buf_count < wr_buf_size)) {\n\t\twr_buf_ptr++;\n\t\twr_buf_count++;\n\t}\n\n\twhile (param_index < *param_nums) {\n\t\t \n\t\tsub_str = strsep(&wr_buf_ptr, delimiter);\n\n\t\tr = kstrtol(sub_str, 16, &(param[param_index]));\n\n\t\tif (r)\n\t\t\tDRM_DEBUG_DRIVER(\"string to int convert error code: %d\\n\", r);\n\n\t\tparam_index++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t dp_link_settings_read(struct file *f, char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tconst uint32_t rd_buf_size = 100;\n\tuint32_t result = 0;\n\tuint8_t str_len = 0;\n\tint r;\n\n\tif (*pos & 3 || size & 3)\n\t\treturn -EINVAL;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!rd_buf)\n\t\treturn 0;\n\n\trd_buf_ptr = rd_buf;\n\n\tstr_len = strlen(\"Current:  %d  0x%x  %d  \");\n\tsnprintf(rd_buf_ptr, str_len, \"Current:  %d  0x%x  %d  \",\n\t\t\tlink->cur_link_settings.lane_count,\n\t\t\tlink->cur_link_settings.link_rate,\n\t\t\tlink->cur_link_settings.link_spread);\n\trd_buf_ptr += str_len;\n\n\tstr_len = strlen(\"Verified:  %d  0x%x  %d  \");\n\tsnprintf(rd_buf_ptr, str_len, \"Verified:  %d  0x%x  %d  \",\n\t\t\tlink->verified_link_cap.lane_count,\n\t\t\tlink->verified_link_cap.link_rate,\n\t\t\tlink->verified_link_cap.link_spread);\n\trd_buf_ptr += str_len;\n\n\tstr_len = strlen(\"Reported:  %d  0x%x  %d  \");\n\tsnprintf(rd_buf_ptr, str_len, \"Reported:  %d  0x%x  %d  \",\n\t\t\tlink->reported_link_cap.lane_count,\n\t\t\tlink->reported_link_cap.link_rate,\n\t\t\tlink->reported_link_cap.link_spread);\n\trd_buf_ptr += str_len;\n\n\tstr_len = strlen(\"Preferred:  %d  0x%x  %d  \");\n\tsnprintf(rd_buf_ptr, str_len, \"Preferred:  %d  0x%x  %d\\n\",\n\t\t\tlink->preferred_link_setting.lane_count,\n\t\t\tlink->preferred_link_setting.link_rate,\n\t\t\tlink->preferred_link_setting.link_spread);\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\nstatic ssize_t dp_link_settings_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tstruct amdgpu_device *adev = drm_to_adev(connector->base.dev);\n\tstruct dc *dc = (struct dc *)link->dc;\n\tstruct dc_link_settings prefer_link_settings;\n\tchar *wr_buf = NULL;\n\tconst uint32_t wr_buf_size = 40;\n\t \n\tint max_param_num = 2;\n\tuint8_t param_nums = 0;\n\tlong param[2];\n\tbool valid_input = true;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param[0]) {\n\tcase LANE_COUNT_ONE:\n\tcase LANE_COUNT_TWO:\n\tcase LANE_COUNT_FOUR:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tswitch (param[1]) {\n\tcase LINK_RATE_LOW:\n\tcase LINK_RATE_HIGH:\n\tcase LINK_RATE_RBR2:\n\tcase LINK_RATE_HIGH2:\n\tcase LINK_RATE_HIGH3:\n\tcase LINK_RATE_UHBR10:\n\tcase LINK_RATE_UHBR13_5:\n\tcase LINK_RATE_UHBR20:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tif (!valid_input) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input value No HW will be programmed\\n\");\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tdc_link_set_preferred_training_settings(dc, NULL, NULL, link, false);\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\treturn size;\n\t}\n\n\t \n\tprefer_link_settings.link_spread = link->cur_link_settings.link_spread;\n\tprefer_link_settings.use_link_rate_set = false;\n\tprefer_link_settings.lane_count = param[0];\n\tprefer_link_settings.link_rate = param[1];\n\n\tmutex_lock(&adev->dm.dc_lock);\n\tdc_link_set_preferred_training_settings(dc, &prefer_link_settings, NULL, link, false);\n\tmutex_unlock(&adev->dm.dc_lock);\n\n\tkfree(wr_buf);\n\treturn size;\n}\n\nstatic bool dp_mst_is_end_device(struct amdgpu_dm_connector *aconnector)\n{\n\tbool is_end_device = false;\n\tstruct drm_dp_mst_topology_mgr *mgr = NULL;\n\tstruct drm_dp_mst_port *port = NULL;\n\n\tif (aconnector->mst_root && aconnector->mst_root->mst_mgr.mst_state) {\n\t\tmgr = &aconnector->mst_root->mst_mgr;\n\t\tport = aconnector->mst_output_port;\n\n\t\tdrm_modeset_lock(&mgr->base.lock, NULL);\n\t\tif (port->pdt == DP_PEER_DEVICE_SST_SINK ||\n\t\t\tport->pdt == DP_PEER_DEVICE_DP_LEGACY_CONV)\n\t\t\tis_end_device = true;\n\t\tdrm_modeset_unlock(&mgr->base.lock);\n\t}\n\n\treturn is_end_device;\n}\n\n \nstatic ssize_t dp_mst_link_setting(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct dc_link *link = aconnector->dc_link;\n\tstruct amdgpu_device *adev = drm_to_adev(aconnector->base.dev);\n\tstruct dc *dc = (struct dc *)link->dc;\n\tstruct dc_link_settings prefer_link_settings;\n\tchar *wr_buf = NULL;\n\tconst uint32_t wr_buf_size = 40;\n\t \n\tint max_param_num = 2;\n\tuint8_t param_nums = 0;\n\tlong param[2];\n\tbool valid_input = true;\n\n\tif (!dp_mst_is_end_device(aconnector))\n\t\treturn -EINVAL;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param[0]) {\n\tcase LANE_COUNT_ONE:\n\tcase LANE_COUNT_TWO:\n\tcase LANE_COUNT_FOUR:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tswitch (param[1]) {\n\tcase LINK_RATE_LOW:\n\tcase LINK_RATE_HIGH:\n\tcase LINK_RATE_RBR2:\n\tcase LINK_RATE_HIGH2:\n\tcase LINK_RATE_HIGH3:\n\tcase LINK_RATE_UHBR10:\n\tcase LINK_RATE_UHBR13_5:\n\tcase LINK_RATE_UHBR20:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tif (!valid_input) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input value No HW will be programmed\\n\");\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tdc_link_set_preferred_training_settings(dc, NULL, NULL, link, false);\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tprefer_link_settings.link_spread = link->cur_link_settings.link_spread;\n\tprefer_link_settings.use_link_rate_set = false;\n\tprefer_link_settings.lane_count = param[0];\n\tprefer_link_settings.link_rate = param[1];\n\n\t \n\tmutex_lock(&adev->dm.dc_lock);\n\tdc_link_set_preferred_training_settings(dc, &prefer_link_settings, NULL, link, true);\n\tmutex_unlock(&adev->dm.dc_lock);\n\n\tmutex_lock(&aconnector->base.dev->mode_config.mutex);\n\taconnector->base.force = DRM_FORCE_OFF;\n\tmutex_unlock(&aconnector->base.dev->mode_config.mutex);\n\tdrm_kms_helper_hotplug_event(aconnector->base.dev);\n\n\tmsleep(100);\n\n\tmutex_lock(&aconnector->base.dev->mode_config.mutex);\n\taconnector->base.force = DRM_FORCE_UNSPECIFIED;\n\tmutex_unlock(&aconnector->base.dev->mode_config.mutex);\n\tdrm_kms_helper_hotplug_event(aconnector->base.dev);\n\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_phy_settings_read(struct file *f, char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tchar *rd_buf = NULL;\n\tconst uint32_t rd_buf_size = 20;\n\tuint32_t result = 0;\n\tint r;\n\n\tif (*pos & 3 || size & 3)\n\t\treturn -EINVAL;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!rd_buf)\n\t\treturn -EINVAL;\n\n\tsnprintf(rd_buf, rd_buf_size, \"  %d  %d  %d\\n\",\n\t\t\tlink->cur_lane_setting[0].VOLTAGE_SWING,\n\t\t\tlink->cur_lane_setting[0].PRE_EMPHASIS,\n\t\t\tlink->cur_lane_setting[0].POST_CURSOR2);\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user((*(rd_buf + result)), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\nstatic int dp_lttpr_status_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector =\n\t\tto_amdgpu_dm_connector(connector);\n\tstruct dc_lttpr_caps caps = aconnector->dc_link->dpcd_caps.lttpr_caps;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"phy repeater count: %u (raw: 0x%x)\\n\",\n\t\t   dp_parse_lttpr_repeater_count(caps.phy_repeater_cnt),\n\t\t   caps.phy_repeater_cnt);\n\n\tseq_puts(m, \"phy repeater mode: \");\n\n\tswitch (caps.mode) {\n\tcase DP_PHY_REPEATER_MODE_TRANSPARENT:\n\t\tseq_puts(m, \"transparent\");\n\t\tbreak;\n\tcase DP_PHY_REPEATER_MODE_NON_TRANSPARENT:\n\t\tseq_puts(m, \"non-transparent\");\n\t\tbreak;\n\tcase 0x00:\n\t\tseq_puts(m, \"non lttpr\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"read error (raw: 0x%x)\", caps.mode);\n\t\tbreak;\n\t}\n\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\nstatic ssize_t dp_phy_settings_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tstruct dc *dc = (struct dc *)link->dc;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 40;\n\tlong param[3];\n\tbool use_prefer_link_setting;\n\tstruct link_training_settings link_lane_settings;\n\tint max_param_num = 3;\n\tuint8_t param_nums = 0;\n\tint r = 0;\n\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((param[0] > VOLTAGE_SWING_MAX_LEVEL) ||\n\t\t\t(param[1] > PRE_EMPHASIS_MAX_LEVEL) ||\n\t\t\t(param[2] > POST_CURSOR2_MAX_LEVEL)) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input No HW will be programmed\\n\");\n\t\treturn size;\n\t}\n\n\t \n\tuse_prefer_link_setting =\n\t\t((link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN) &&\n\t\t(link->test_pattern_enabled));\n\n\tmemset(&link_lane_settings, 0, sizeof(link_lane_settings));\n\n\tif (use_prefer_link_setting) {\n\t\tlink_lane_settings.link_settings.lane_count =\n\t\t\t\tlink->preferred_link_setting.lane_count;\n\t\tlink_lane_settings.link_settings.link_rate =\n\t\t\t\tlink->preferred_link_setting.link_rate;\n\t\tlink_lane_settings.link_settings.link_spread =\n\t\t\t\tlink->preferred_link_setting.link_spread;\n\t} else {\n\t\tlink_lane_settings.link_settings.lane_count =\n\t\t\t\tlink->cur_link_settings.lane_count;\n\t\tlink_lane_settings.link_settings.link_rate =\n\t\t\t\tlink->cur_link_settings.link_rate;\n\t\tlink_lane_settings.link_settings.link_spread =\n\t\t\t\tlink->cur_link_settings.link_spread;\n\t}\n\n\t \n\tfor (r = 0; r < link_lane_settings.link_settings.lane_count; r++) {\n\t\tlink_lane_settings.hw_lane_settings[r].VOLTAGE_SWING =\n\t\t\t\t(enum dc_voltage_swing) (param[0]);\n\t\tlink_lane_settings.hw_lane_settings[r].PRE_EMPHASIS =\n\t\t\t\t(enum dc_pre_emphasis) (param[1]);\n\t\tlink_lane_settings.hw_lane_settings[r].POST_CURSOR2 =\n\t\t\t\t(enum dc_post_cursor2) (param[2]);\n\t}\n\n\t \n\tdc_link_set_drive_settings(dc, &link_lane_settings, link);\n\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 100;\n\tlong param[11] = {0x0};\n\tint max_param_num = 11;\n\tenum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;\n\tbool disable_hpd = false;\n\tbool valid_test_pattern = false;\n\tuint8_t param_nums = 0;\n\t \n\tuint8_t custom_pattern[10] = {\n\t\t\t0x1f, 0x7c, 0xf0, 0xc1, 0x07,\n\t\t\t0x1f, 0x7c, 0xf0, 0xc1, 0x07\n\t\t\t};\n\tstruct dc_link_settings prefer_link_settings = {LANE_COUNT_UNKNOWN,\n\t\t\tLINK_RATE_UNKNOWN, LINK_SPREAD_DISABLED};\n\tstruct dc_link_settings cur_link_settings = {LANE_COUNT_UNKNOWN,\n\t\t\tLINK_RATE_UNKNOWN, LINK_SPREAD_DISABLED};\n\tstruct link_training_settings link_training_settings;\n\tint i;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\n\ttest_pattern = param[0];\n\n\tswitch (test_pattern) {\n\tcase DP_TEST_PATTERN_VIDEO_MODE:\n\tcase DP_TEST_PATTERN_COLOR_SQUARES:\n\tcase DP_TEST_PATTERN_COLOR_SQUARES_CEA:\n\tcase DP_TEST_PATTERN_VERTICAL_BARS:\n\tcase DP_TEST_PATTERN_HORIZONTAL_BARS:\n\tcase DP_TEST_PATTERN_COLOR_RAMP:\n\t\tvalid_test_pattern = true;\n\t\tbreak;\n\n\tcase DP_TEST_PATTERN_D102:\n\tcase DP_TEST_PATTERN_SYMBOL_ERROR:\n\tcase DP_TEST_PATTERN_PRBS7:\n\tcase DP_TEST_PATTERN_80BIT_CUSTOM:\n\tcase DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE:\n\tcase DP_TEST_PATTERN_TRAINING_PATTERN4:\n\t\tdisable_hpd = true;\n\t\tvalid_test_pattern = true;\n\t\tbreak;\n\n\tdefault:\n\t\tvalid_test_pattern = false;\n\t\ttest_pattern = DP_TEST_PATTERN_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (!valid_test_pattern) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Test Pattern Parameters\\n\");\n\t\treturn size;\n\t}\n\n\tif (test_pattern == DP_TEST_PATTERN_80BIT_CUSTOM) {\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tif ((uint8_t) param[i + 1] != 0x0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i < 10) {\n\t\t\t \n\t\t\tfor (i = 0; i < 10; i++)\n\t\t\t\tcustom_pattern[i] = (uint8_t) param[i + 1];\n\t\t}\n\t}\n\n\t \n\tif (!disable_hpd)\n\t\tdc_link_enable_hpd(link);\n\n\tprefer_link_settings.lane_count = link->verified_link_cap.lane_count;\n\tprefer_link_settings.link_rate = link->verified_link_cap.link_rate;\n\tprefer_link_settings.link_spread = link->verified_link_cap.link_spread;\n\n\tcur_link_settings.lane_count = link->cur_link_settings.lane_count;\n\tcur_link_settings.link_rate = link->cur_link_settings.link_rate;\n\tcur_link_settings.link_spread = link->cur_link_settings.link_spread;\n\n\tlink_training_settings.link_settings = cur_link_settings;\n\n\n\tif (test_pattern != DP_TEST_PATTERN_VIDEO_MODE) {\n\t\tif (prefer_link_settings.lane_count != LANE_COUNT_UNKNOWN &&\n\t\t\tprefer_link_settings.link_rate !=  LINK_RATE_UNKNOWN &&\n\t\t\t(prefer_link_settings.lane_count != cur_link_settings.lane_count ||\n\t\t\tprefer_link_settings.link_rate != cur_link_settings.link_rate))\n\t\t\tlink_training_settings.link_settings = prefer_link_settings;\n\t}\n\n\tfor (i = 0; i < (unsigned int)(link_training_settings.link_settings.lane_count); i++)\n\t\tlink_training_settings.hw_lane_settings[i] = link->cur_lane_setting[i];\n\n\tdc_link_dp_set_test_pattern(\n\t\tlink,\n\t\ttest_pattern,\n\t\tDP_TEST_PATTERN_COLOR_SPACE_RGB,\n\t\t&link_training_settings,\n\t\tcustom_pattern,\n\t\t10);\n\n\t \n\tif (valid_test_pattern && disable_hpd)\n\t\tdc_link_disable_hpd(link);\n\n\tkfree(wr_buf);\n\n\treturn size;\n}\n\n \nstatic int dmub_tracebuffer_show(struct seq_file *m, void *data)\n{\n\tstruct amdgpu_device *adev = m->private;\n\tstruct dmub_srv_fb_info *fb_info = adev->dm.dmub_fb_info;\n\tstruct dmub_debugfs_trace_entry *entries;\n\tuint8_t *tbuf_base;\n\tuint32_t tbuf_size, max_entries, num_entries, i;\n\n\tif (!fb_info)\n\t\treturn 0;\n\n\ttbuf_base = (uint8_t *)fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].cpu_addr;\n\tif (!tbuf_base)\n\t\treturn 0;\n\n\ttbuf_size = fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].size;\n\tmax_entries = (tbuf_size - sizeof(struct dmub_debugfs_trace_header)) /\n\t\t      sizeof(struct dmub_debugfs_trace_entry);\n\n\tnum_entries =\n\t\t((struct dmub_debugfs_trace_header *)tbuf_base)->entry_count;\n\n\tnum_entries = min(num_entries, max_entries);\n\n\tentries = (struct dmub_debugfs_trace_entry\n\t\t\t   *)(tbuf_base +\n\t\t\t      sizeof(struct dmub_debugfs_trace_header));\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tstruct dmub_debugfs_trace_entry *entry = &entries[i];\n\n\t\tseq_printf(m,\n\t\t\t   \"trace_code=%u tick_count=%u param0=%u param1=%u\\n\",\n\t\t\t   entry->trace_code, entry->tick_count, entry->param0,\n\t\t\t   entry->param1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dmub_fw_state_show(struct seq_file *m, void *data)\n{\n\tstruct amdgpu_device *adev = m->private;\n\tstruct dmub_srv_fb_info *fb_info = adev->dm.dmub_fb_info;\n\tuint8_t *state_base;\n\tuint32_t state_size;\n\n\tif (!fb_info)\n\t\treturn 0;\n\n\tstate_base = (uint8_t *)fb_info->fb[DMUB_WINDOW_6_FW_STATE].cpu_addr;\n\tif (!state_base)\n\t\treturn 0;\n\n\tstate_size = fb_info->fb[DMUB_WINDOW_6_FW_STATE].size;\n\n\treturn seq_write(m, state_base, state_size);\n}\n\n \nstatic int psr_capability_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct dc_link *link = aconnector->dc_link;\n\n\tif (!link)\n\t\treturn -ENODEV;\n\n\tif (link->type == dc_connection_none)\n\t\treturn -ENODEV;\n\n\tif (!(link->connector_signal & SIGNAL_TYPE_EDP))\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"Sink support: %s\", str_yes_no(link->dpcd_caps.psr_info.psr_version != 0));\n\tif (link->dpcd_caps.psr_info.psr_version)\n\t\tseq_printf(m, \" [0x%02x]\", link->dpcd_caps.psr_info.psr_version);\n\tseq_puts(m, \"\\n\");\n\n\tseq_printf(m, \"Driver support: %s\", str_yes_no(link->psr_settings.psr_feature_enabled));\n\tif (link->psr_settings.psr_version)\n\t\tseq_printf(m, \" [0x%02x]\", link->psr_settings.psr_version);\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\n \nstatic int amdgpu_current_bpc_show(struct seq_file *m, void *data)\n{\n\tstruct drm_crtc *crtc = m->private;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tint res = -ENODEV;\n\tunsigned int bpc;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\tswitch (dm_crtc_state->stream->timing.display_color_depth) {\n\tcase COLOR_DEPTH_666:\n\t\tbpc = 6;\n\t\tbreak;\n\tcase COLOR_DEPTH_888:\n\t\tbpc = 8;\n\t\tbreak;\n\tcase COLOR_DEPTH_101010:\n\t\tbpc = 10;\n\t\tbreak;\n\tcase COLOR_DEPTH_121212:\n\t\tbpc = 12;\n\t\tbreak;\n\tcase COLOR_DEPTH_161616:\n\t\tbpc = 16;\n\t\tbreak;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\n\tseq_printf(m, \"Current: %u\\n\", bpc);\n\tres = 0;\n\nunlock:\n\tdrm_modeset_unlock(&crtc->mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\treturn res;\n}\nDEFINE_SHOW_ATTRIBUTE(amdgpu_current_bpc);\n\n \nstatic int amdgpu_current_colorspace_show(struct seq_file *m, void *data)\n{\n\tstruct drm_crtc *crtc = m->private;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tint res = -ENODEV;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\tswitch (dm_crtc_state->stream->output_color_space) {\n\tcase COLOR_SPACE_SRGB:\n\t\tseq_puts(m, \"sRGB\");\n\t\tbreak;\n\tcase COLOR_SPACE_YCBCR601:\n\tcase COLOR_SPACE_YCBCR601_LIMITED:\n\t\tseq_puts(m, \"BT601_YCC\");\n\t\tbreak;\n\tcase COLOR_SPACE_YCBCR709:\n\tcase COLOR_SPACE_YCBCR709_LIMITED:\n\t\tseq_puts(m, \"BT709_YCC\");\n\t\tbreak;\n\tcase COLOR_SPACE_ADOBERGB:\n\t\tseq_puts(m, \"opRGB\");\n\t\tbreak;\n\tcase COLOR_SPACE_2020_RGB_FULLRANGE:\n\t\tseq_puts(m, \"BT2020_RGB\");\n\t\tbreak;\n\tcase COLOR_SPACE_2020_YCBCR:\n\t\tseq_puts(m, \"BT2020_YCC\");\n\t\tbreak;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\tres = 0;\n\nunlock:\n\tdrm_modeset_unlock(&crtc->mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\treturn res;\n}\nDEFINE_SHOW_ATTRIBUTE(amdgpu_current_colorspace);\n\n\n \nstatic ssize_t dp_dsc_passthrough_set(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tlong param;\n\tuint8_t param_nums = 0;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   &param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\taconnector->dsc_settings.dsc_force_disable_passthrough = param;\n\n\tkfree(wr_buf);\n\treturn 0;\n}\n\n \nstatic int hdcp_sink_capability_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tbool hdcp_cap, hdcp2_cap;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"%s:%d HDCP version: \", connector->name, connector->base.id);\n\n\thdcp_cap = dc_link_is_hdcp14(aconnector->dc_link, aconnector->dc_sink->sink_signal);\n\thdcp2_cap = dc_link_is_hdcp22(aconnector->dc_link, aconnector->dc_sink->sink_signal);\n\n\n\tif (hdcp_cap)\n\t\tseq_printf(m, \"%s \", \"HDCP1.4\");\n\tif (hdcp2_cap)\n\t\tseq_printf(m, \"%s \", \"HDCP2.2\");\n\n\tif (!hdcp_cap && !hdcp2_cap)\n\t\tseq_printf(m, \"%s \", \"None\");\n\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\n \nstatic int internal_display_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct dc_link *link = aconnector->dc_link;\n\n\tseq_printf(m, \"Internal: %u\\n\", link->is_internal_display);\n\n\treturn 0;\n}\n\n \nstatic ssize_t dp_sdp_message_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tint r;\n\tuint8_t data[36];\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dm_crtc_state *acrtc_state;\n\tuint32_t write_size = 36;\n\n\tif (connector->base.status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tacrtc_state = to_dm_crtc_state(connector->base.state->crtc->state);\n\n\tr = copy_from_user(data, buf, write_size);\n\n\twrite_size -= r;\n\n\tdc_stream_send_dp_sdp(acrtc_state->stream, data, write_size);\n\n\treturn write_size;\n}\n\n \nstatic int dp_dsc_fec_support_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tint ret = 0;\n\tbool try_again = false;\n\tbool is_fec_supported = false;\n\tbool is_dsc_supported = false;\n\tstruct dpcd_caps dpcd_caps;\n\n\tdrm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);\n\tdo {\n\t\ttry_again = false;\n\t\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);\n\t\tif (ret) {\n\t\t\tif (ret == -EDEADLK) {\n\t\t\t\tret = drm_modeset_backoff(&ctx);\n\t\t\t\tif (!ret) {\n\t\t\t\t\ttry_again = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (connector->status != connector_status_connected) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tdpcd_caps = aconnector->dc_link->dpcd_caps;\n\t\tif (aconnector->mst_output_port) {\n\t\t\t \n\t\t\tif (aconnector->dsc_aux) {\n\t\t\t\tis_fec_supported = true;\n\t\t\t\tis_dsc_supported = true;\n\t\t\t}\n\t\t} else {\n\t\t\tis_fec_supported = dpcd_caps.fec_cap.raw & 0x1;\n\t\t\tis_dsc_supported = dpcd_caps.dsc_caps.dsc_basic_caps.raw[0] & 0x1;\n\t\t}\n\t} while (try_again);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tseq_printf(m, \"FEC_Sink_Support: %s\\n\", str_yes_no(is_fec_supported));\n\tseq_printf(m, \"DSC_Sink_Support: %s\\n\", str_yes_no(is_dsc_supported));\n\n\treturn ret;\n}\n\n \nstatic ssize_t trigger_hotplug(struct file *f, const char __user *buf,\n\t\t\t\t\t\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct dc_link *link = NULL;\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tlong param[1] = {0};\n\tuint8_t param_nums = 0;\n\tbool ret = false;\n\n\tif (!aconnector || !aconnector->dc_link)\n\t\treturn -EINVAL;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t\t(long *)param, buf,\n\t\t\t\t\t\tmax_param_num,\n\t\t\t\t\t\t&param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(wr_buf);\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&aconnector->hpd_lock);\n\n\t \n\tif (aconnector->mst_root) {\n\t\tmutex_unlock(&aconnector->hpd_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param[0] == 1) {\n\n\t\tif (!dc_link_detect_connection_type(aconnector->dc_link, &new_connection_type) &&\n\t\t\tnew_connection_type != dc_connection_none)\n\t\t\tgoto unlock;\n\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tret = dc_link_detect(aconnector->dc_link, DETECT_REASON_HPD);\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\n\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\t\tdrm_modeset_lock_all(dev);\n\t\tdm_restore_drm_connector_state(dev, connector);\n\t\tdrm_modeset_unlock_all(dev);\n\n\t\tdrm_kms_helper_connector_hotplug_event(connector);\n\t} else if (param[0] == 0) {\n\t\tif (!aconnector->dc_link)\n\t\t\tgoto unlock;\n\n\t\tlink = aconnector->dc_link;\n\n\t\tif (link->local_sink) {\n\t\t\tdc_sink_release(link->local_sink);\n\t\t\tlink->local_sink = NULL;\n\t\t}\n\n\t\tlink->dpcd_sink_count = 0;\n\t\tlink->type = dc_connection_none;\n\t\tlink->dongle_max_pix_clk = 0;\n\n\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\t\t \n\t\tif (aconnector->mst_mgr.mst_state == true)\n\t\t\tdc_link_reset_cur_dp_mst_topology(link);\n\n\t\tdrm_modeset_lock_all(dev);\n\t\tdm_restore_drm_connector_state(dev, connector);\n\t\tdrm_modeset_unlock_all(dev);\n\n\t\tdrm_kms_helper_connector_hotplug_event(connector);\n\t}\n\nunlock:\n\tmutex_unlock(&aconnector->hpd_lock);\n\n\treturn size;\n}\n\n \nstatic ssize_t dp_dsc_clock_en_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 10;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_clock_en);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_clock_en_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tstruct pipe_ctx *pipe_ctx;\n\tint i;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tlong param[1] = {0};\n\tuint8_t param_nums = 0;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t    (long *)param, buf,\n\t\t\t\t\t    max_param_num,\n\t\t\t\t\t    &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tif (!pipe_ctx->stream)\n\t\tgoto done;\n\n\t\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tcrtc = connector->state->crtc;\n\tif (crtc == NULL)\n\t\tgoto unlock;\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\tif (param[0] == 1)\n\t\taconnector->dsc_settings.dsc_force_enable = DSC_CLK_FORCE_ENABLE;\n\telse if (param[0] == 2)\n\t\taconnector->dsc_settings.dsc_force_enable = DSC_CLK_FORCE_DISABLE;\n\telse\n\t\taconnector->dsc_settings.dsc_force_enable = DSC_CLK_FORCE_DEFAULT;\n\n\tdm_crtc_state->dsc_force_changed = true;\n\nunlock:\n\tif (crtc)\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\ndone:\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_dsc_slice_width_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_slice_width);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_slice_width_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct pipe_ctx *pipe_ctx;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tint i;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tlong param[1] = {0};\n\tuint8_t param_nums = 0;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t    (long *)param, buf,\n\t\t\t\t\t    max_param_num,\n\t\t\t\t\t    &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tif (!pipe_ctx->stream)\n\t\tgoto done;\n\n\t\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tcrtc = connector->state->crtc;\n\tif (crtc == NULL)\n\t\tgoto unlock;\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\tif (param[0] > 0)\n\t\taconnector->dsc_settings.dsc_num_slices_h = DIV_ROUND_UP(\n\t\t\t\t\tpipe_ctx->stream->timing.h_addressable,\n\t\t\t\t\tparam[0]);\n\telse\n\t\taconnector->dsc_settings.dsc_num_slices_h = 0;\n\n\tdm_crtc_state->dsc_force_changed = true;\n\nunlock:\n\tif (crtc)\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\ndone:\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_dsc_slice_height_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_slice_height);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_slice_height_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tstruct pipe_ctx *pipe_ctx;\n\tint i;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tuint8_t param_nums = 0;\n\tlong param[1] = {0};\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t    (long *)param, buf,\n\t\t\t\t\t    max_param_num,\n\t\t\t\t\t    &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tif (!pipe_ctx->stream)\n\t\tgoto done;\n\n\t\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tcrtc = connector->state->crtc;\n\tif (crtc == NULL)\n\t\tgoto unlock;\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\tif (param[0] > 0)\n\t\taconnector->dsc_settings.dsc_num_slices_v = DIV_ROUND_UP(\n\t\t\t\t\tpipe_ctx->stream->timing.v_addressable,\n\t\t\t\t\tparam[0]);\n\telse\n\t\taconnector->dsc_settings.dsc_num_slices_v = 0;\n\n\tdm_crtc_state->dsc_force_changed = true;\n\nunlock:\n\tif (crtc)\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\ndone:\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_dsc_bits_per_pixel_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_bits_per_pixel);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_bits_per_pixel_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct dm_crtc_state *dm_crtc_state = NULL;\n\tstruct pipe_ctx *pipe_ctx;\n\tint i;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tuint8_t param_nums = 0;\n\tlong param[1] = {0};\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t    (long *)param, buf,\n\t\t\t\t\t    max_param_num,\n\t\t\t\t\t    &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tif (!pipe_ctx->stream)\n\t\tgoto done;\n\n\t\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tcrtc = connector->state->crtc;\n\tif (crtc == NULL)\n\t\tgoto unlock;\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state == NULL)\n\t\tgoto unlock;\n\n\tdm_crtc_state = to_dm_crtc_state(crtc->state);\n\tif (dm_crtc_state->stream == NULL)\n\t\tgoto unlock;\n\n\taconnector->dsc_settings.dsc_bits_per_pixel = param[0];\n\n\tdm_crtc_state->dsc_force_changed = true;\n\nunlock:\n\tif (crtc)\n\t\tdrm_modeset_unlock(&crtc->mutex);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\ndone:\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic ssize_t dp_dsc_pic_width_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_pic_width);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\nstatic ssize_t dp_dsc_pic_height_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_pic_height);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_chunk_size_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_chunk_size);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n \nstatic ssize_t dp_dsc_slice_bpg_offset_read(struct file *f, char __user *buf,\n\t\t\t\t    size_t size, loff_t *pos)\n{\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct display_stream_compressor *dsc;\n\tstruct dcn_dsc_state dsc_state = {0};\n\tconst uint32_t rd_buf_size = 100;\n\tstruct pipe_ctx *pipe_ctx;\n\tssize_t result = 0;\n\tint i, r, str_len = 30;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\trd_buf_ptr = rd_buf;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tpipe_ctx = &aconnector->dc_link->dc->current_state->res_ctx.pipe_ctx[i];\n\t\tif (pipe_ctx->stream &&\n\t\t    pipe_ctx->stream->link == aconnector->dc_link)\n\t\t\tbreak;\n\t}\n\n\tdsc = pipe_ctx->stream_res.dsc;\n\tif (dsc)\n\t\tdsc->funcs->dsc_read_state(dsc, &dsc_state);\n\n\tsnprintf(rd_buf_ptr, str_len,\n\t\t\"%d\\n\",\n\t\tdsc_state.dsc_slice_bpg_offset);\n\trd_buf_ptr += str_len;\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\n\n \nstatic ssize_t dp_max_bpc_read(struct file *f, char __user *buf,\n\t\tsize_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct dm_connector_state *state;\n\tssize_t result = 0;\n\tchar *rd_buf = NULL;\n\tchar *rd_buf_ptr = NULL;\n\tconst uint32_t rd_buf_size = 10;\n\tint r;\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!rd_buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tstate = to_dm_connector_state(connector->state);\n\n\trd_buf_ptr = rd_buf;\n\tsnprintf(rd_buf_ptr, rd_buf_size,\n\t\t\"%u\\n\",\n\t\tstate->base.max_requested_bpc);\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tresult = r;  \n\t\t\tgoto unlock;\n\t\t}\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\nunlock:\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\tkfree(rd_buf);\n\treturn result;\n}\n\n\n \nstatic ssize_t dp_max_bpc_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *aconnector = file_inode(f)->i_private;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct dm_connector_state *state;\n\tstruct drm_device *dev = connector->dev;\n\tchar *wr_buf = NULL;\n\tuint32_t wr_buf_size = 42;\n\tint max_param_num = 1;\n\tlong param[1] = {0};\n\tuint8_t param_nums = 0;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\n\tif (!wr_buf) {\n\t\tDRM_DEBUG_DRIVER(\"no memory to allocate write buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param[0] < 6 || param[0] > 16) {\n\t\tDRM_DEBUG_DRIVER(\"bad max_bpc value\\n\");\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\n\tif (connector->state == NULL)\n\t\tgoto unlock;\n\n\tstate = to_dm_connector_state(connector->state);\n\tstate->base.max_requested_bpc = param[0];\nunlock:\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tkfree(wr_buf);\n\treturn size;\n}\n\n \nstatic int current_backlight_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(m->private);\n\tstruct dc_link *link = aconnector->dc_link;\n\tunsigned int backlight;\n\n\tbacklight = dc_link_get_backlight_level(link);\n\tseq_printf(m, \"0x%x\\n\", backlight);\n\n\treturn 0;\n}\n\n \nstatic int target_backlight_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(m->private);\n\tstruct dc_link *link = aconnector->dc_link;\n\tunsigned int backlight;\n\n\tbacklight = dc_link_get_target_backlight_pwm(link);\n\tseq_printf(m, \"0x%x\\n\", backlight);\n\n\treturn 0;\n}\n\n \nstatic int dp_is_mst_connector_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct drm_dp_mst_topology_mgr *mgr = NULL;\n\tstruct drm_dp_mst_port *port = NULL;\n\tchar *role = NULL;\n\n\tmutex_lock(&aconnector->hpd_lock);\n\n\tif (aconnector->mst_mgr.mst_state) {\n\t\trole = \"root\";\n\t} else if (aconnector->mst_root &&\n\t\taconnector->mst_root->mst_mgr.mst_state) {\n\n\t\trole = \"end\";\n\n\t\tmgr = &aconnector->mst_root->mst_mgr;\n\t\tport = aconnector->mst_output_port;\n\n\t\tdrm_modeset_lock(&mgr->base.lock, NULL);\n\t\tif (port->pdt == DP_PEER_DEVICE_MST_BRANCHING &&\n\t\t\tport->mcs)\n\t\t\trole = \"branch\";\n\t\tdrm_modeset_unlock(&mgr->base.lock);\n\n\t} else {\n\t\trole = \"no\";\n\t}\n\n\tseq_printf(m, \"%s\\n\", role);\n\n\tmutex_unlock(&aconnector->hpd_lock);\n\n\treturn 0;\n}\n\n \nstatic int dp_mst_progress_status_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct amdgpu_device *adev = drm_to_adev(connector->dev);\n\tint i;\n\n\tmutex_lock(&aconnector->hpd_lock);\n\tmutex_lock(&adev->dm.dc_lock);\n\n\tif (aconnector->mst_status == MST_STATUS_DEFAULT) {\n\t\tseq_puts(m, \"disabled\\n\");\n\t} else {\n\t\tfor (i = 0; i < sizeof(mst_progress_status)/sizeof(char *); i++)\n\t\t\tseq_printf(m, \"%s:%s\\n\",\n\t\t\t\tmst_progress_status[i],\n\t\t\t\taconnector->mst_status & BIT(i) ? \"done\" : \"not_done\");\n\t}\n\n\tmutex_unlock(&adev->dm.dc_lock);\n\tmutex_unlock(&aconnector->hpd_lock);\n\n\treturn 0;\n}\n\n \nstatic int is_dpia_link_show(struct seq_file *m, void *data)\n{\n\tstruct drm_connector *connector = m->private;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct dc_link *link = aconnector->dc_link;\n\n\tif (connector->status != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tseq_printf(m, \"%s\\n\", (link->ep_type == DISPLAY_ENDPOINT_USB4_DPIA) ? \"yes\" :\n\t\t\t\t(link->ep_type == DISPLAY_ENDPOINT_PHY) ? \"no\" : \"unknown\");\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dp_dsc_fec_support);\nDEFINE_SHOW_ATTRIBUTE(dmub_fw_state);\nDEFINE_SHOW_ATTRIBUTE(dmub_tracebuffer);\nDEFINE_SHOW_ATTRIBUTE(dp_lttpr_status);\nDEFINE_SHOW_ATTRIBUTE(hdcp_sink_capability);\nDEFINE_SHOW_ATTRIBUTE(internal_display);\nDEFINE_SHOW_ATTRIBUTE(psr_capability);\nDEFINE_SHOW_ATTRIBUTE(dp_is_mst_connector);\nDEFINE_SHOW_ATTRIBUTE(dp_mst_progress_status);\nDEFINE_SHOW_ATTRIBUTE(is_dpia_link);\n\nstatic const struct file_operations dp_dsc_clock_en_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_clock_en_read,\n\t.write = dp_dsc_clock_en_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_slice_width_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_slice_width_read,\n\t.write = dp_dsc_slice_width_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_slice_height_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_slice_height_read,\n\t.write = dp_dsc_slice_height_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_bits_per_pixel_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_bits_per_pixel_read,\n\t.write = dp_dsc_bits_per_pixel_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_pic_width_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_pic_width_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_pic_height_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_pic_height_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_chunk_size_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_chunk_size_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_slice_bpg_offset_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_dsc_slice_bpg_offset_read,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations trigger_hotplug_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.write = trigger_hotplug,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_link_settings_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_link_settings_read,\n\t.write = dp_link_settings_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_phy_settings_debugfs_fop = {\n\t.owner = THIS_MODULE,\n\t.read = dp_phy_settings_read,\n\t.write = dp_phy_settings_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_phy_test_pattern_fops = {\n\t.owner = THIS_MODULE,\n\t.write = dp_phy_test_pattern_debugfs_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations sdp_message_fops = {\n\t.owner = THIS_MODULE,\n\t.write = dp_sdp_message_debugfs_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_max_bpc_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dp_max_bpc_read,\n\t.write = dp_max_bpc_write,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_dsc_disable_passthrough_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.write = dp_dsc_passthrough_set,\n\t.llseek = default_llseek\n};\n\nstatic const struct file_operations dp_mst_link_settings_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.write = dp_mst_link_setting,\n\t.llseek = default_llseek\n};\n\nstatic const struct {\n\tchar *name;\n\tconst struct file_operations *fops;\n} dp_debugfs_entries[] = {\n\t\t{\"link_settings\", &dp_link_settings_debugfs_fops},\n\t\t{\"phy_settings\", &dp_phy_settings_debugfs_fop},\n\t\t{\"lttpr_status\", &dp_lttpr_status_fops},\n\t\t{\"test_pattern\", &dp_phy_test_pattern_fops},\n\t\t{\"hdcp_sink_capability\", &hdcp_sink_capability_fops},\n\t\t{\"sdp_message\", &sdp_message_fops},\n\t\t{\"dsc_clock_en\", &dp_dsc_clock_en_debugfs_fops},\n\t\t{\"dsc_slice_width\", &dp_dsc_slice_width_debugfs_fops},\n\t\t{\"dsc_slice_height\", &dp_dsc_slice_height_debugfs_fops},\n\t\t{\"dsc_bits_per_pixel\", &dp_dsc_bits_per_pixel_debugfs_fops},\n\t\t{\"dsc_pic_width\", &dp_dsc_pic_width_debugfs_fops},\n\t\t{\"dsc_pic_height\", &dp_dsc_pic_height_debugfs_fops},\n\t\t{\"dsc_chunk_size\", &dp_dsc_chunk_size_debugfs_fops},\n\t\t{\"dsc_slice_bpg\", &dp_dsc_slice_bpg_offset_debugfs_fops},\n\t\t{\"dp_dsc_fec_support\", &dp_dsc_fec_support_fops},\n\t\t{\"max_bpc\", &dp_max_bpc_debugfs_fops},\n\t\t{\"dsc_disable_passthrough\", &dp_dsc_disable_passthrough_debugfs_fops},\n\t\t{\"is_mst_connector\", &dp_is_mst_connector_fops},\n\t\t{\"mst_progress_status\", &dp_mst_progress_status_fops},\n\t\t{\"is_dpia_link\", &is_dpia_link_fops},\n\t\t{\"mst_link_settings\", &dp_mst_link_settings_debugfs_fops}\n};\n\nstatic const struct {\n\tchar *name;\n\tconst struct file_operations *fops;\n} hdmi_debugfs_entries[] = {\n\t\t{\"hdcp_sink_capability\", &hdcp_sink_capability_fops}\n};\n\n \nstatic int force_yuv420_output_set(void *data, u64 val)\n{\n\tstruct amdgpu_dm_connector *connector = data;\n\n\tconnector->force_yuv420_output = (bool)val;\n\n\treturn 0;\n}\n\n \nstatic int force_yuv420_output_get(void *data, u64 *val)\n{\n\tstruct amdgpu_dm_connector *connector = data;\n\n\t*val = connector->force_yuv420_output;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(force_yuv420_output_fops, force_yuv420_output_get,\n\t\t\t force_yuv420_output_set, \"%llu\\n\");\n\n \nstatic int psr_get(void *data, u64 *val)\n{\n\tstruct amdgpu_dm_connector *connector = data;\n\tstruct dc_link *link = connector->dc_link;\n\tenum dc_psr_state state = PSR_STATE0;\n\n\tdc_link_get_psr_state(link, &state);\n\n\t*val = state;\n\n\treturn 0;\n}\n\n \nstatic int psr_read_residency(void *data, u64 *val)\n{\n\tstruct amdgpu_dm_connector *connector = data;\n\tstruct dc_link *link = connector->dc_link;\n\tu32 residency;\n\n\tlink->dc->link_srv->edp_get_psr_residency(link, &residency);\n\n\t*val = (u64)residency;\n\n\treturn 0;\n}\n\n \nstatic int allow_edp_hotplug_detection_get(void *data, u64 *val)\n{\n\tstruct amdgpu_dm_connector *aconnector = data;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\t*val = adev->dm.dc->config.allow_edp_hotplug_detection;\n\n\treturn 0;\n}\n\n \nstatic int allow_edp_hotplug_detection_set(void *data, u64 val)\n{\n\tstruct amdgpu_dm_connector *aconnector = data;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tadev->dm.dc->config.allow_edp_hotplug_detection = (uint32_t) val;\n\n\treturn 0;\n}\n\n \nstatic int dmcub_trace_event_state_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tif (val == 1 || val == 0) {\n\t\tdc_dmub_trace_event_control(adev->dm.dc, val);\n\t\tadev->dm.dmcub_trace_event_en = (bool)val;\n\t} else\n\t\treturn 0;\n\n\treturn 0;\n}\n\n \nstatic int dmcub_trace_event_state_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.dmcub_trace_event_en;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(dmcub_trace_event_state_fops, dmcub_trace_event_state_get,\n\t\t\t dmcub_trace_event_state_set, \"%llu\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(psr_fops, psr_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(psr_residency_fops, psr_read_residency, NULL,\n\t\t\t \"%llu\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(allow_edp_hotplug_detection_fops,\n\t\t\tallow_edp_hotplug_detection_get,\n\t\t\tallow_edp_hotplug_detection_set, \"%llu\\n\");\n\nDEFINE_SHOW_ATTRIBUTE(current_backlight);\nDEFINE_SHOW_ATTRIBUTE(target_backlight);\n\nstatic const struct {\n\tchar *name;\n\tconst struct file_operations *fops;\n} connector_debugfs_entries[] = {\n\t\t{\"force_yuv420_output\", &force_yuv420_output_fops},\n\t\t{\"trigger_hotplug\", &trigger_hotplug_debugfs_fops},\n\t\t{\"internal_display\", &internal_display_fops}\n};\n\n \nstatic int edp_ilr_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(m->private);\n\tstruct dc_link *link = aconnector->dc_link;\n\tuint8_t supported_link_rates[16];\n\tuint32_t link_rate_in_khz;\n\tuint32_t entry = 0;\n\tuint8_t dpcd_rev;\n\n\tmemset(supported_link_rates, 0, sizeof(supported_link_rates));\n\tdm_helpers_dp_read_dpcd(link->ctx, link, DP_SUPPORTED_LINK_RATES,\n\t\tsupported_link_rates, sizeof(supported_link_rates));\n\n\tdpcd_rev = link->dpcd_caps.dpcd_rev.raw;\n\n\tif (dpcd_rev >= DP_DPCD_REV_13 &&\n\t\t(supported_link_rates[entry+1] != 0 || supported_link_rates[entry] != 0)) {\n\n\t\tfor (entry = 0; entry < 16; entry += 2) {\n\t\t\tlink_rate_in_khz = (supported_link_rates[entry+1] * 0x100 +\n\t\t\t\t\t\t\t\t\t\tsupported_link_rates[entry]) * 200;\n\t\t\tseq_printf(m, \"[%d] %d kHz\\n\", entry/2, link_rate_in_khz);\n\t\t}\n\t} else {\n\t\tseq_puts(m, \"ILR is not supported by this eDP panel.\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t edp_ilr_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tstruct amdgpu_device *adev = drm_to_adev(connector->base.dev);\n\tstruct dc *dc = (struct dc *)link->dc;\n\tstruct dc_link_settings prefer_link_settings;\n\tchar *wr_buf = NULL;\n\tconst uint32_t wr_buf_size = 40;\n\t \n\tint max_param_num = 2;\n\tuint8_t param_nums = 0;\n\tlong param[2];\n\tbool valid_input = true;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOMEM;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param[0]) {\n\tcase LANE_COUNT_ONE:\n\tcase LANE_COUNT_TWO:\n\tcase LANE_COUNT_FOUR:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tif (param[1] >= link->dpcd_caps.edp_supported_link_rates_count)\n\t\tvalid_input = false;\n\n\tif (!valid_input) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input value. No HW will be programmed\\n\");\n\t\tprefer_link_settings.use_link_rate_set = false;\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tdc_link_set_preferred_training_settings(dc, NULL, NULL, link, false);\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\treturn size;\n\t}\n\n\t \n\tprefer_link_settings.link_spread = link->cur_link_settings.link_spread;\n\tprefer_link_settings.lane_count = param[0];\n\tprefer_link_settings.use_link_rate_set = true;\n\tprefer_link_settings.link_rate_set = param[1];\n\tprefer_link_settings.link_rate = link->dpcd_caps.edp_supported_link_rates[param[1]];\n\n\tmutex_lock(&adev->dm.dc_lock);\n\tdc_link_set_preferred_training_settings(dc, &prefer_link_settings,\n\t\t\t\t\t\tNULL, link, false);\n\tmutex_unlock(&adev->dm.dc_lock);\n\n\tkfree(wr_buf);\n\treturn size;\n}\n\nstatic int edp_ilr_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, edp_ilr_show, inode->i_private);\n}\n\nstatic const struct file_operations edp_ilr_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = edp_ilr_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = edp_ilr_write\n};\n\nvoid connector_debugfs_init(struct amdgpu_dm_connector *connector)\n{\n\tint i;\n\tstruct dentry *dir = connector->base.debugfs_entry;\n\n\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->base.connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\tfor (i = 0; i < ARRAY_SIZE(dp_debugfs_entries); i++) {\n\t\t\tdebugfs_create_file(dp_debugfs_entries[i].name,\n\t\t\t\t\t    0644, dir, connector,\n\t\t\t\t\t    dp_debugfs_entries[i].fops);\n\t\t}\n\t}\n\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\tdebugfs_create_file_unsafe(\"psr_capability\", 0444, dir, connector, &psr_capability_fops);\n\t\tdebugfs_create_file_unsafe(\"psr_state\", 0444, dir, connector, &psr_fops);\n\t\tdebugfs_create_file_unsafe(\"psr_residency\", 0444, dir,\n\t\t\t\t\t   connector, &psr_residency_fops);\n\t\tdebugfs_create_file(\"amdgpu_current_backlight_pwm\", 0444, dir, connector,\n\t\t\t\t    &current_backlight_fops);\n\t\tdebugfs_create_file(\"amdgpu_target_backlight_pwm\", 0444, dir, connector,\n\t\t\t\t    &target_backlight_fops);\n\t\tdebugfs_create_file(\"ilr_setting\", 0644, dir, connector,\n\t\t\t\t\t&edp_ilr_debugfs_fops);\n\t\tdebugfs_create_file(\"allow_edp_hotplug_detection\", 0644, dir, connector,\n\t\t\t\t\t&allow_edp_hotplug_detection_fops);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(connector_debugfs_entries); i++) {\n\t\tdebugfs_create_file(connector_debugfs_entries[i].name,\n\t\t\t\t    0644, dir, connector,\n\t\t\t\t    connector_debugfs_entries[i].fops);\n\t}\n\n\tif (connector->base.connector_type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\tfor (i = 0; i < ARRAY_SIZE(hdmi_debugfs_entries); i++) {\n\t\t\tdebugfs_create_file(hdmi_debugfs_entries[i].name,\n\t\t\t\t\t    0644, dir, connector,\n\t\t\t\t\t    hdmi_debugfs_entries[i].fops);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DRM_AMD_SECURE_DISPLAY\n \nstatic int crc_win_x_start_set(void *data, u64 val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tacrtc->dm_irq_params.window_param.x_start = (uint16_t) val;\n\tacrtc->dm_irq_params.window_param.update_win = false;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\n \nstatic int crc_win_x_start_get(void *data, u64 *val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\t*val = acrtc->dm_irq_params.window_param.x_start;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(crc_win_x_start_fops, crc_win_x_start_get,\n\t\t\t crc_win_x_start_set, \"%llu\\n\");\n\n\n \nstatic int crc_win_y_start_set(void *data, u64 val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tacrtc->dm_irq_params.window_param.y_start = (uint16_t) val;\n\tacrtc->dm_irq_params.window_param.update_win = false;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\n \nstatic int crc_win_y_start_get(void *data, u64 *val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\t*val = acrtc->dm_irq_params.window_param.y_start;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(crc_win_y_start_fops, crc_win_y_start_get,\n\t\t\t crc_win_y_start_set, \"%llu\\n\");\n\n \nstatic int crc_win_x_end_set(void *data, u64 val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tacrtc->dm_irq_params.window_param.x_end = (uint16_t) val;\n\tacrtc->dm_irq_params.window_param.update_win = false;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\n \nstatic int crc_win_x_end_get(void *data, u64 *val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\t*val = acrtc->dm_irq_params.window_param.x_end;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(crc_win_x_end_fops, crc_win_x_end_get,\n\t\t\t crc_win_x_end_set, \"%llu\\n\");\n\n \nstatic int crc_win_y_end_set(void *data, u64 val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tacrtc->dm_irq_params.window_param.y_end = (uint16_t) val;\n\tacrtc->dm_irq_params.window_param.update_win = false;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\n \nstatic int crc_win_y_end_get(void *data, u64 *val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\t*val = acrtc->dm_irq_params.window_param.y_end;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(crc_win_y_end_fops, crc_win_y_end_get,\n\t\t\t crc_win_y_end_set, \"%llu\\n\");\n \nstatic int crc_win_update_set(void *data, u64 val)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct amdgpu_crtc *acrtc;\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\n\tif (val) {\n\t\tacrtc = to_amdgpu_crtc(crtc);\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\t \n\t\tamdgpu_dm_psr_disable(acrtc->dm_irq_params.stream);\n\n\t\tspin_lock_irq(&adev_to_drm(adev)->event_lock);\n\n\t\tacrtc->dm_irq_params.window_param.activated = true;\n\t\tacrtc->dm_irq_params.window_param.update_win = true;\n\t\tacrtc->dm_irq_params.window_param.skip_frame_cnt = 0;\n\n\t\tspin_unlock_irq(&adev_to_drm(adev)->event_lock);\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int crc_win_update_get(void *data, u64 *val)\n{\n\t*val = 0;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(crc_win_update_fops, crc_win_update_get,\n\t\t\t crc_win_update_set, \"%llu\\n\");\n#endif\nvoid crtc_debugfs_init(struct drm_crtc *crtc)\n{\n#ifdef CONFIG_DRM_AMD_SECURE_DISPLAY\n\tstruct dentry *dir = debugfs_lookup(\"crc\", crtc->debugfs_entry);\n\n\tif (!dir)\n\t\treturn;\n\n\tdebugfs_create_file_unsafe(\"crc_win_x_start\", 0644, dir, crtc,\n\t\t\t\t   &crc_win_x_start_fops);\n\tdebugfs_create_file_unsafe(\"crc_win_y_start\", 0644, dir, crtc,\n\t\t\t\t   &crc_win_y_start_fops);\n\tdebugfs_create_file_unsafe(\"crc_win_x_end\", 0644, dir, crtc,\n\t\t\t\t   &crc_win_x_end_fops);\n\tdebugfs_create_file_unsafe(\"crc_win_y_end\", 0644, dir, crtc,\n\t\t\t\t   &crc_win_y_end_fops);\n\tdebugfs_create_file_unsafe(\"crc_win_update\", 0644, dir, crtc,\n\t\t\t\t   &crc_win_update_fops);\n\tdput(dir);\n#endif\n\tdebugfs_create_file(\"amdgpu_current_bpc\", 0644, crtc->debugfs_entry,\n\t\t\t    crtc, &amdgpu_current_bpc_fops);\n\tdebugfs_create_file(\"amdgpu_current_colorspace\", 0644, crtc->debugfs_entry,\n\t\t\t    crtc, &amdgpu_current_colorspace_fops);\n}\n\n \nstatic ssize_t dtn_log_read(\n\tstruct file *f,\n\tchar __user *buf,\n\tsize_t size,\n\tloff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tstruct dc *dc = adev->dm.dc;\n\tstruct dc_log_buffer_ctx log_ctx = { 0 };\n\tssize_t result = 0;\n\n\tif (!buf || !size)\n\t\treturn -EINVAL;\n\n\tif (!dc->hwss.log_hw_state)\n\t\treturn 0;\n\n\tdc->hwss.log_hw_state(dc, &log_ctx);\n\n\tif (*pos < log_ctx.pos) {\n\t\tsize_t to_copy = log_ctx.pos - *pos;\n\n\t\tto_copy = min(to_copy, size);\n\n\t\tif (!copy_to_user(buf, log_ctx.buf + *pos, to_copy)) {\n\t\t\t*pos += to_copy;\n\t\t\tresult = to_copy;\n\t\t}\n\t}\n\n\tkfree(log_ctx.buf);\n\n\treturn result;\n}\n\n \nstatic ssize_t dtn_log_write(\n\tstruct file *f,\n\tconst char __user *buf,\n\tsize_t size,\n\tloff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tstruct dc *dc = adev->dm.dc;\n\n\t \n\tif (size == 0)\n\t\treturn 0;\n\n\tif (dc->hwss.log_hw_state)\n\t\tdc->hwss.log_hw_state(dc, NULL);\n\n\treturn size;\n}\n\nstatic int mst_topo_show(struct seq_file *m, void *unused)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)m->private;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct amdgpu_dm_connector *aconnector;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\t \n\t\tif (!aconnector->mst_mgr.mst_state)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"\\nMST topology for connector %d\\n\", aconnector->connector_id);\n\t\tdrm_dp_mst_dump_topology(m, &aconnector->mst_mgr);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\n\n \nstatic int trigger_hpd_mst_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_connector_list_iter iter;\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct dc_link *link = NULL;\n\n\tif (val == 1) {\n\t\tdrm_connector_list_iter_begin(dev, &iter);\n\t\tdrm_for_each_connector_iter(connector, &iter) {\n\t\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\t\tif (aconnector->dc_link->type == dc_connection_mst_branch &&\n\t\t\t    aconnector->mst_mgr.aux) {\n\t\t\t\tmutex_lock(&adev->dm.dc_lock);\n\t\t\t\tdc_link_detect(aconnector->dc_link, DETECT_REASON_HPD);\n\t\t\t\tmutex_unlock(&adev->dm.dc_lock);\n\n\t\t\t\tdrm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true);\n\t\t\t}\n\t\t}\n\t} else if (val == 0) {\n\t\tdrm_connector_list_iter_begin(dev, &iter);\n\t\tdrm_for_each_connector_iter(connector, &iter) {\n\t\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\t\tif (!aconnector->dc_link)\n\t\t\t\tcontinue;\n\n\t\t\tif (!aconnector->mst_root)\n\t\t\t\tcontinue;\n\n\t\t\tlink = aconnector->dc_link;\n\t\t\tdc_link_dp_receiver_power_ctrl(link, false);\n\t\t\tdrm_dp_mst_topology_mgr_set_mst(&aconnector->mst_root->mst_mgr, false);\n\t\t\tlink->mst_stream_alloc_table.stream_count = 0;\n\t\t\tmemset(link->mst_stream_alloc_table.stream_allocations, 0,\n\t\t\t\t\tsizeof(link->mst_stream_alloc_table.stream_allocations));\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n\tdrm_kms_helper_hotplug_event(dev);\n\n\treturn 0;\n}\n\n \nstatic int trigger_hpd_mst_get(void *data, u64 *val)\n{\n\t*val = 0;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(trigger_hpd_mst_ops, trigger_hpd_mst_get,\n\t\t\t trigger_hpd_mst_set, \"%llu\\n\");\n\n\n \nstatic int force_timing_sync_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tadev->dm.force_timing_sync = (bool)val;\n\n\tamdgpu_dm_trigger_timing_sync(adev_to_drm(adev));\n\n\treturn 0;\n}\n\n \nstatic int force_timing_sync_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.force_timing_sync;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(force_timing_sync_ops, force_timing_sync_get,\n\t\t\t force_timing_sync_set, \"%llu\\n\");\n\n\n \nstatic int disable_hpd_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tadev->dm.disable_hpd_irq = (bool)val;\n\n\treturn 0;\n}\n\n\n \nstatic int disable_hpd_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.disable_hpd_irq;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(disable_hpd_ops, disable_hpd_get,\n\t\t\t disable_hpd_set, \"%llu\\n\");\n\n \nstatic int dp_force_sst_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tadev->dm.dc->debug.set_mst_en_for_sst = val;\n\n\treturn 0;\n}\n\nstatic int dp_force_sst_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.dc->debug.set_mst_en_for_sst;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(dp_set_mst_en_for_sst_ops, dp_force_sst_get,\n\t\t\t dp_force_sst_set, \"%llu\\n\");\n\n \nstatic int dp_ignore_cable_id_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tadev->dm.dc->debug.ignore_cable_id = val;\n\n\treturn 0;\n}\n\nstatic int dp_ignore_cable_id_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.dc->debug.ignore_cable_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(dp_ignore_cable_id_ops, dp_ignore_cable_id_get,\n\t\t\t dp_ignore_cable_id_set, \"%llu\\n\");\n\n \nstatic int visual_confirm_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tadev->dm.dc->debug.visual_confirm = (enum visual_confirm)val;\n\n\treturn 0;\n}\n\n \nstatic int visual_confirm_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.dc->debug.visual_confirm;\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mst_topo);\nDEFINE_DEBUGFS_ATTRIBUTE(visual_confirm_fops, visual_confirm_get,\n\t\t\t visual_confirm_set, \"%llu\\n\");\n\n\n \nstatic int skip_detection_link_training_set(void *data, u64 val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\tif (val == 0)\n\t\tadev->dm.dc->debug.skip_detection_link_training = false;\n\telse\n\t\tadev->dm.dc->debug.skip_detection_link_training = true;\n\n\treturn 0;\n}\n\n \nstatic int skip_detection_link_training_get(void *data, u64 *val)\n{\n\tstruct amdgpu_device *adev = data;\n\n\t*val = adev->dm.dc->debug.skip_detection_link_training;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(skip_detection_link_training_fops,\n\t\t\t skip_detection_link_training_get,\n\t\t\t skip_detection_link_training_set, \"%llu\\n\");\n\n \nstatic ssize_t dcc_en_bits_read(\n\tstruct file *f,\n\tchar __user *buf,\n\tsize_t size,\n\tloff_t *pos)\n{\n\tstruct amdgpu_device *adev = file_inode(f)->i_private;\n\tstruct dc *dc = adev->dm.dc;\n\tchar *rd_buf = NULL;\n\tconst uint32_t rd_buf_size = 32;\n\tuint32_t result = 0;\n\tint offset = 0;\n\tint num_pipes = dc->res_pool->pipe_count;\n\tint *dcc_en_bits;\n\tint i, r;\n\n\tdcc_en_bits = kcalloc(num_pipes, sizeof(int), GFP_KERNEL);\n\tif (!dcc_en_bits)\n\t\treturn -ENOMEM;\n\n\tif (!dc->hwss.get_dcc_en_bits) {\n\t\tkfree(dcc_en_bits);\n\t\treturn 0;\n\t}\n\n\tdc->hwss.get_dcc_en_bits(dc, dcc_en_bits);\n\n\trd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!rd_buf) {\n\t\tkfree(dcc_en_bits);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < num_pipes; i++)\n\t\toffset += snprintf(rd_buf + offset, rd_buf_size - offset,\n\t\t\t\t   \"%d  \", dcc_en_bits[i]);\n\trd_buf[strlen(rd_buf)] = '\\n';\n\n\tkfree(dcc_en_bits);\n\n\twhile (size) {\n\t\tif (*pos >= rd_buf_size)\n\t\t\tbreak;\n\t\tr = put_user(*(rd_buf + result), buf);\n\t\tif (r) {\n\t\t\tkfree(rd_buf);\n\t\t\treturn r;  \n\t\t}\n\t\tbuf += 1;\n\t\tsize -= 1;\n\t\t*pos += 1;\n\t\tresult += 1;\n\t}\n\n\tkfree(rd_buf);\n\treturn result;\n}\n\nvoid dtn_debugfs_init(struct amdgpu_device *adev)\n{\n\tstatic const struct file_operations dtn_log_fops = {\n\t\t.owner = THIS_MODULE,\n\t\t.read = dtn_log_read,\n\t\t.write = dtn_log_write,\n\t\t.llseek = default_llseek\n\t};\n\tstatic const struct file_operations dcc_en_bits_fops = {\n\t\t.owner = THIS_MODULE,\n\t\t.read = dcc_en_bits_read,\n\t\t.llseek = default_llseek\n\t};\n\n\tstruct drm_minor *minor = adev_to_drm(adev)->primary;\n\tstruct dentry *root = minor->debugfs_root;\n\n\tdebugfs_create_file(\"amdgpu_mst_topology\", 0444, root,\n\t\t\t    adev, &mst_topo_fops);\n\tdebugfs_create_file(\"amdgpu_dm_dtn_log\", 0644, root, adev,\n\t\t\t    &dtn_log_fops);\n\tdebugfs_create_file(\"amdgpu_dm_dp_set_mst_en_for_sst\", 0644, root, adev,\n\t\t\t\t&dp_set_mst_en_for_sst_ops);\n\tdebugfs_create_file(\"amdgpu_dm_dp_ignore_cable_id\", 0644, root, adev,\n\t\t\t\t&dp_ignore_cable_id_ops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_visual_confirm\", 0644, root, adev,\n\t\t\t\t   &visual_confirm_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_skip_detection_link_training\", 0644, root, adev,\n\t\t\t\t   &skip_detection_link_training_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_dmub_tracebuffer\", 0644, root,\n\t\t\t\t   adev, &dmub_tracebuffer_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_dmub_fw_state\", 0644, root,\n\t\t\t\t   adev, &dmub_fw_state_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_force_timing_sync\", 0644, root,\n\t\t\t\t   adev, &force_timing_sync_ops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_dmcub_trace_event_en\", 0644, root,\n\t\t\t\t   adev, &dmcub_trace_event_state_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_trigger_hpd_mst\", 0644, root,\n\t\t\t\t   adev, &trigger_hpd_mst_ops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_dcc_en\", 0644, root, adev,\n\t\t\t\t   &dcc_en_bits_fops);\n\n\tdebugfs_create_file_unsafe(\"amdgpu_dm_disable_hpd\", 0644, root, adev,\n\t\t\t\t   &disable_hpd_ops);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}