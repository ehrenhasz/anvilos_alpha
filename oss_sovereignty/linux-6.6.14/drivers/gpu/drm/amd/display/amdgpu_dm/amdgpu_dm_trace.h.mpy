{
  "module_name": "amdgpu_dm_trace.h",
  "hash_id": "be49593e7f0de2387bb5ac0e9c65e2d178d3ba1fce0a2632c492050c1442c3d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_trace.h",
  "human_readable_source": " \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM amdgpu_dm\n\n#if !defined(_AMDGPU_DM_TRACE_H_) || defined(TRACE_HEADER_MULTI_READ)\n#define _AMDGPU_DM_TRACE_H_\n\n#include <linux/tracepoint.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_atomic.h>\n#include \"dcn10/dcn10_optc.h\"\n\n#include \"dc/inc/core_types.h\"\n\nDECLARE_EVENT_CLASS(amdgpu_dc_reg_template,\n\t\t    TP_PROTO(unsigned long *count, uint32_t reg, uint32_t value),\n\t\t    TP_ARGS(count, reg, value),\n\n\t\t    TP_STRUCT__entry(\n\t\t\t\t     __field(uint32_t, reg)\n\t\t\t\t     __field(uint32_t, value)\n\t\t    ),\n\n\t\t    TP_fast_assign(\n\t\t\t\t   __entry->reg = reg;\n\t\t\t\t   __entry->value = value;\n\t\t\t\t   *count = *count + 1;\n\t\t    ),\n\n\t\t    TP_printk(\"reg=0x%08lx, value=0x%08lx\",\n\t\t\t      (unsigned long)__entry->reg,\n\t\t\t      (unsigned long)__entry->value)\n);\n\nDEFINE_EVENT(amdgpu_dc_reg_template, amdgpu_dc_rreg,\n\t     TP_PROTO(unsigned long *count, uint32_t reg, uint32_t value),\n\t     TP_ARGS(count, reg, value));\n\nDEFINE_EVENT(amdgpu_dc_reg_template, amdgpu_dc_wreg,\n\t     TP_PROTO(unsigned long *count, uint32_t reg, uint32_t value),\n\t     TP_ARGS(count, reg, value));\n\nTRACE_EVENT(amdgpu_dc_performance,\n\tTP_PROTO(unsigned long read_count, unsigned long write_count,\n\t\tunsigned long *last_read, unsigned long *last_write,\n\t\tconst char *func, unsigned int line),\n\tTP_ARGS(read_count, write_count, last_read, last_write, func, line),\n\tTP_STRUCT__entry(\n\t\t\t__field(uint32_t, reads)\n\t\t\t__field(uint32_t, writes)\n\t\t\t__field(uint32_t, read_delta)\n\t\t\t__field(uint32_t, write_delta)\n\t\t\t__string(func, func)\n\t\t\t__field(uint32_t, line)\n\t\t\t),\n\tTP_fast_assign(\n\t\t\t__entry->reads = read_count;\n\t\t\t__entry->writes = write_count;\n\t\t\t__entry->read_delta = read_count - *last_read;\n\t\t\t__entry->write_delta = write_count - *last_write;\n\t\t\t__assign_str(func, func);\n\t\t\t__entry->line = line;\n\t\t\t*last_read = read_count;\n\t\t\t*last_write = write_count;\n\t\t\t),\n\tTP_printk(\"%s:%d reads=%08ld (%08ld total), writes=%08ld (%08ld total)\",\n\t\t\t__get_str(func), __entry->line,\n\t\t\t(unsigned long)__entry->read_delta,\n\t\t\t(unsigned long)__entry->reads,\n\t\t\t(unsigned long)__entry->write_delta,\n\t\t\t(unsigned long)__entry->writes)\n);\n\nTRACE_EVENT(amdgpu_dm_connector_atomic_check,\n\t    TP_PROTO(const struct drm_connector_state *state),\n\t    TP_ARGS(state),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(uint32_t, conn_id)\n\t\t\t     __field(const struct drm_connector_state *, conn_state)\n\t\t\t     __field(const struct drm_atomic_state *, state)\n\t\t\t     __field(const struct drm_crtc_commit *, commit)\n\t\t\t     __field(uint32_t, crtc_id)\n\t\t\t     __field(uint32_t, best_encoder_id)\n\t\t\t     __field(enum drm_link_status, link_status)\n\t\t\t     __field(bool, self_refresh_aware)\n\t\t\t     __field(enum hdmi_picture_aspect, picture_aspect_ratio)\n\t\t\t     __field(unsigned int, content_type)\n\t\t\t     __field(unsigned int, hdcp_content_type)\n\t\t\t     __field(unsigned int, content_protection)\n\t\t\t     __field(unsigned int, scaling_mode)\n\t\t\t     __field(u32, colorspace)\n\t\t\t     __field(u8, max_requested_bpc)\n\t\t\t     __field(u8, max_bpc)\n\t    ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->conn_id = state->connector->base.id;\n\t\t\t   __entry->conn_state = state;\n\t\t\t   __entry->state = state->state;\n\t\t\t   __entry->commit = state->commit;\n\t\t\t   __entry->crtc_id = state->crtc ? state->crtc->base.id : 0;\n\t\t\t   __entry->best_encoder_id = state->best_encoder ?\n\t\t\t\t\t\t      state->best_encoder->base.id : 0;\n\t\t\t   __entry->link_status = state->link_status;\n\t\t\t   __entry->self_refresh_aware = state->self_refresh_aware;\n\t\t\t   __entry->picture_aspect_ratio = state->picture_aspect_ratio;\n\t\t\t   __entry->content_type = state->content_type;\n\t\t\t   __entry->hdcp_content_type = state->hdcp_content_type;\n\t\t\t   __entry->content_protection = state->content_protection;\n\t\t\t   __entry->scaling_mode = state->scaling_mode;\n\t\t\t   __entry->colorspace = state->colorspace;\n\t\t\t   __entry->max_requested_bpc = state->max_requested_bpc;\n\t\t\t   __entry->max_bpc = state->max_bpc;\n\t    ),\n\n\t    TP_printk(\"conn_id=%u conn_state=%p state=%p commit=%p crtc_id=%u \"\n\t\t      \"best_encoder_id=%u link_status=%d self_refresh_aware=%d \"\n\t\t      \"picture_aspect_ratio=%d content_type=%u \"\n\t\t      \"hdcp_content_type=%u content_protection=%u scaling_mode=%u \"\n\t\t      \"colorspace=%u max_requested_bpc=%u max_bpc=%u\",\n\t\t      __entry->conn_id, __entry->conn_state, __entry->state,\n\t\t      __entry->commit, __entry->crtc_id, __entry->best_encoder_id,\n\t\t      __entry->link_status, __entry->self_refresh_aware,\n\t\t      __entry->picture_aspect_ratio, __entry->content_type,\n\t\t      __entry->hdcp_content_type, __entry->content_protection,\n\t\t      __entry->scaling_mode, __entry->colorspace,\n\t\t      __entry->max_requested_bpc, __entry->max_bpc)\n);\n\nTRACE_EVENT(amdgpu_dm_crtc_atomic_check,\n\t    TP_PROTO(const struct drm_crtc_state *state),\n\t    TP_ARGS(state),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(const struct drm_atomic_state *, state)\n\t\t\t     __field(const struct drm_crtc_state *, crtc_state)\n\t\t\t     __field(const struct drm_crtc_commit *, commit)\n\t\t\t     __field(uint32_t, crtc_id)\n\t\t\t     __field(bool, enable)\n\t\t\t     __field(bool, active)\n\t\t\t     __field(bool, planes_changed)\n\t\t\t     __field(bool, mode_changed)\n\t\t\t     __field(bool, active_changed)\n\t\t\t     __field(bool, connectors_changed)\n\t\t\t     __field(bool, zpos_changed)\n\t\t\t     __field(bool, color_mgmt_changed)\n\t\t\t     __field(bool, no_vblank)\n\t\t\t     __field(bool, async_flip)\n\t\t\t     __field(bool, vrr_enabled)\n\t\t\t     __field(bool, self_refresh_active)\n\t\t\t     __field(u32, plane_mask)\n\t\t\t     __field(u32, connector_mask)\n\t\t\t     __field(u32, encoder_mask)\n\t    ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->state = state->state;\n\t\t\t   __entry->crtc_state = state;\n\t\t\t   __entry->crtc_id = state->crtc->base.id;\n\t\t\t   __entry->commit = state->commit;\n\t\t\t   __entry->enable = state->enable;\n\t\t\t   __entry->active = state->active;\n\t\t\t   __entry->planes_changed = state->planes_changed;\n\t\t\t   __entry->mode_changed = state->mode_changed;\n\t\t\t   __entry->active_changed = state->active_changed;\n\t\t\t   __entry->connectors_changed = state->connectors_changed;\n\t\t\t   __entry->zpos_changed = state->zpos_changed;\n\t\t\t   __entry->color_mgmt_changed = state->color_mgmt_changed;\n\t\t\t   __entry->no_vblank = state->no_vblank;\n\t\t\t   __entry->async_flip = state->async_flip;\n\t\t\t   __entry->vrr_enabled = state->vrr_enabled;\n\t\t\t   __entry->self_refresh_active = state->self_refresh_active;\n\t\t\t   __entry->plane_mask = state->plane_mask;\n\t\t\t   __entry->connector_mask = state->connector_mask;\n\t\t\t   __entry->encoder_mask = state->encoder_mask;\n\t    ),\n\n\t    TP_printk(\"crtc_id=%u crtc_state=%p state=%p commit=%p changed(\"\n\t\t      \"planes=%d mode=%d active=%d conn=%d zpos=%d color_mgmt=%d) \"\n\t\t      \"state(enable=%d active=%d async_flip=%d vrr_enabled=%d \"\n\t\t      \"self_refresh_active=%d no_vblank=%d) mask(plane=%x conn=%x \"\n\t\t      \"enc=%x)\",\n\t\t      __entry->crtc_id, __entry->crtc_state, __entry->state,\n\t\t      __entry->commit, __entry->planes_changed,\n\t\t      __entry->mode_changed, __entry->active_changed,\n\t\t      __entry->connectors_changed, __entry->zpos_changed,\n\t\t      __entry->color_mgmt_changed, __entry->enable, __entry->active,\n\t\t      __entry->async_flip, __entry->vrr_enabled,\n\t\t      __entry->self_refresh_active, __entry->no_vblank,\n\t\t      __entry->plane_mask, __entry->connector_mask,\n\t\t      __entry->encoder_mask)\n);\n\nDECLARE_EVENT_CLASS(amdgpu_dm_plane_state_template,\n\t    TP_PROTO(const struct drm_plane_state *state),\n\t    TP_ARGS(state),\n\t    TP_STRUCT__entry(\n\t\t\t     __field(uint32_t, plane_id)\n\t\t\t     __field(enum drm_plane_type, plane_type)\n\t\t\t     __field(const struct drm_plane_state *, plane_state)\n\t\t\t     __field(const struct drm_atomic_state *, state)\n\t\t\t     __field(uint32_t, crtc_id)\n\t\t\t     __field(uint32_t, fb_id)\n\t\t\t     __field(uint32_t, fb_format)\n\t\t\t     __field(uint8_t, fb_planes)\n\t\t\t     __field(uint64_t, fb_modifier)\n\t\t\t     __field(const struct dma_fence *, fence)\n\t\t\t     __field(int32_t, crtc_x)\n\t\t\t     __field(int32_t, crtc_y)\n\t\t\t     __field(uint32_t, crtc_w)\n\t\t\t     __field(uint32_t, crtc_h)\n\t\t\t     __field(uint32_t, src_x)\n\t\t\t     __field(uint32_t, src_y)\n\t\t\t     __field(uint32_t, src_w)\n\t\t\t     __field(uint32_t, src_h)\n\t\t\t     __field(u32, alpha)\n\t\t\t     __field(uint32_t, pixel_blend_mode)\n\t\t\t     __field(unsigned int, rotation)\n\t\t\t     __field(unsigned int, zpos)\n\t\t\t     __field(unsigned int, normalized_zpos)\n\t\t\t     __field(enum drm_color_encoding, color_encoding)\n\t\t\t     __field(enum drm_color_range, color_range)\n\t\t\t     __field(bool, visible)\n\t    ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->plane_id = state->plane->base.id;\n\t\t\t   __entry->plane_type = state->plane->type;\n\t\t\t   __entry->plane_state = state;\n\t\t\t   __entry->state = state->state;\n\t\t\t   __entry->crtc_id = state->crtc ? state->crtc->base.id : 0;\n\t\t\t   __entry->fb_id = state->fb ? state->fb->base.id : 0;\n\t\t\t   __entry->fb_format = state->fb ? state->fb->format->format : 0;\n\t\t\t   __entry->fb_planes = state->fb ? state->fb->format->num_planes : 0;\n\t\t\t   __entry->fb_modifier = state->fb ? state->fb->modifier : 0;\n\t\t\t   __entry->fence = state->fence;\n\t\t\t   __entry->crtc_x = state->crtc_x;\n\t\t\t   __entry->crtc_y = state->crtc_y;\n\t\t\t   __entry->crtc_w = state->crtc_w;\n\t\t\t   __entry->crtc_h = state->crtc_h;\n\t\t\t   __entry->src_x = state->src_x >> 16;\n\t\t\t   __entry->src_y = state->src_y >> 16;\n\t\t\t   __entry->src_w = state->src_w >> 16;\n\t\t\t   __entry->src_h = state->src_h >> 16;\n\t\t\t   __entry->alpha = state->alpha;\n\t\t\t   __entry->pixel_blend_mode = state->pixel_blend_mode;\n\t\t\t   __entry->rotation = state->rotation;\n\t\t\t   __entry->zpos = state->zpos;\n\t\t\t   __entry->normalized_zpos = state->normalized_zpos;\n\t\t\t   __entry->color_encoding = state->color_encoding;\n\t\t\t   __entry->color_range = state->color_range;\n\t\t\t   __entry->visible = state->visible;\n\t    ),\n\n\t    TP_printk(\"plane_id=%u plane_type=%d plane_state=%p state=%p \"\n\t\t      \"crtc_id=%u fb(id=%u fmt=%c%c%c%c planes=%u mod=%llu) \"\n\t\t      \"fence=%p crtc_x=%d crtc_y=%d crtc_w=%u crtc_h=%u \"\n\t\t      \"src_x=%u src_y=%u src_w=%u src_h=%u alpha=%u \"\n\t\t      \"pixel_blend_mode=%u rotation=%u zpos=%u \"\n\t\t      \"normalized_zpos=%u color_encoding=%d color_range=%d \"\n\t\t      \"visible=%d\",\n\t\t      __entry->plane_id, __entry->plane_type, __entry->plane_state,\n\t\t      __entry->state, __entry->crtc_id, __entry->fb_id,\n\t\t      (__entry->fb_format & 0xff) ? (__entry->fb_format & 0xff) : 'N',\n\t\t      ((__entry->fb_format >> 8) & 0xff) ? ((__entry->fb_format >> 8) & 0xff) : 'O',\n\t\t      ((__entry->fb_format >> 16) & 0xff) ? ((__entry->fb_format >> 16) & 0xff) : 'N',\n\t\t      ((__entry->fb_format >> 24) & 0x7f) ? ((__entry->fb_format >> 24) & 0x7f) : 'E',\n\t\t      __entry->fb_planes,\n\t\t      __entry->fb_modifier, __entry->fence, __entry->crtc_x,\n\t\t      __entry->crtc_y, __entry->crtc_w, __entry->crtc_h,\n\t\t      __entry->src_x, __entry->src_y, __entry->src_w, __entry->src_h,\n\t\t      __entry->alpha, __entry->pixel_blend_mode, __entry->rotation,\n\t\t      __entry->zpos, __entry->normalized_zpos,\n\t\t      __entry->color_encoding, __entry->color_range,\n\t\t      __entry->visible)\n);\n\nDEFINE_EVENT(amdgpu_dm_plane_state_template, amdgpu_dm_plane_atomic_check,\n\t     TP_PROTO(const struct drm_plane_state *state),\n\t     TP_ARGS(state));\n\nDEFINE_EVENT(amdgpu_dm_plane_state_template, amdgpu_dm_atomic_update_cursor,\n\t     TP_PROTO(const struct drm_plane_state *state),\n\t     TP_ARGS(state));\n\nTRACE_EVENT(amdgpu_dm_atomic_state_template,\n\t    TP_PROTO(const struct drm_atomic_state *state),\n\t    TP_ARGS(state),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(const struct drm_atomic_state *, state)\n\t\t\t     __field(bool, allow_modeset)\n\t\t\t     __field(bool, legacy_cursor_update)\n\t\t\t     __field(bool, async_update)\n\t\t\t     __field(bool, duplicated)\n\t\t\t     __field(int, num_connector)\n\t\t\t     __field(int, num_private_objs)\n\t    ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->state = state;\n\t\t\t   __entry->allow_modeset = state->allow_modeset;\n\t\t\t   __entry->legacy_cursor_update = state->legacy_cursor_update;\n\t\t\t   __entry->async_update = state->async_update;\n\t\t\t   __entry->duplicated = state->duplicated;\n\t\t\t   __entry->num_connector = state->num_connector;\n\t\t\t   __entry->num_private_objs = state->num_private_objs;\n\t    ),\n\n\t    TP_printk(\"state=%p allow_modeset=%d legacy_cursor_update=%d \"\n\t\t      \"async_update=%d duplicated=%d num_connector=%d \"\n\t\t      \"num_private_objs=%d\",\n\t\t      __entry->state, __entry->allow_modeset, __entry->legacy_cursor_update,\n\t\t      __entry->async_update, __entry->duplicated, __entry->num_connector,\n\t\t      __entry->num_private_objs)\n);\n\nDEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_commit_tail_begin,\n\t     TP_PROTO(const struct drm_atomic_state *state),\n\t     TP_ARGS(state));\n\nDEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_commit_tail_finish,\n\t     TP_PROTO(const struct drm_atomic_state *state),\n\t     TP_ARGS(state));\n\nDEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_check_begin,\n\t     TP_PROTO(const struct drm_atomic_state *state),\n\t     TP_ARGS(state));\n\nTRACE_EVENT(amdgpu_dm_atomic_check_finish,\n\t    TP_PROTO(const struct drm_atomic_state *state, int res),\n\t    TP_ARGS(state, res),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(const struct drm_atomic_state *, state)\n\t\t\t     __field(int, res)\n\t\t\t     __field(bool, async_update)\n\t\t\t     __field(bool, allow_modeset)\n\t    ),\n\n\t    TP_fast_assign(\n\t\t\t   __entry->state = state;\n\t\t\t   __entry->res = res;\n\t\t\t   __entry->async_update = state->async_update;\n\t\t\t   __entry->allow_modeset = state->allow_modeset;\n\t    ),\n\n\t    TP_printk(\"state=%p res=%d async_update=%d allow_modeset=%d\",\n\t\t      __entry->state, __entry->res,\n\t\t      __entry->async_update, __entry->allow_modeset)\n);\n\nTRACE_EVENT(amdgpu_dm_dc_pipe_state,\n\t    TP_PROTO(int pipe_idx, const struct dc_plane_state *plane_state,\n\t\t     const struct dc_stream_state *stream,\n\t\t     const struct plane_resource *plane_res,\n\t\t     int update_flags),\n\t    TP_ARGS(pipe_idx, plane_state, stream, plane_res, update_flags),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(int, pipe_idx)\n\t\t\t     __field(const void *, stream)\n\t\t\t     __field(int, stream_w)\n\t\t\t     __field(int, stream_h)\n\t\t\t     __field(int, dst_x)\n\t\t\t     __field(int, dst_y)\n\t\t\t     __field(int, dst_w)\n\t\t\t     __field(int, dst_h)\n\t\t\t     __field(int, src_x)\n\t\t\t     __field(int, src_y)\n\t\t\t     __field(int, src_w)\n\t\t\t     __field(int, src_h)\n\t\t\t     __field(int, clip_x)\n\t\t\t     __field(int, clip_y)\n\t\t\t     __field(int, clip_w)\n\t\t\t     __field(int, clip_h)\n\t\t\t     __field(int, recout_x)\n\t\t\t     __field(int, recout_y)\n\t\t\t     __field(int, recout_w)\n\t\t\t     __field(int, recout_h)\n\t\t\t     __field(int, viewport_x)\n\t\t\t     __field(int, viewport_y)\n\t\t\t     __field(int, viewport_w)\n\t\t\t     __field(int, viewport_h)\n\t\t\t     __field(int, flip_immediate)\n\t\t\t     __field(int, surface_pitch)\n\t\t\t     __field(int, format)\n\t\t\t     __field(int, swizzle)\n\t\t\t     __field(unsigned int, update_flags)\n\t),\n\n\tTP_fast_assign(\n\t\t       __entry->pipe_idx = pipe_idx;\n\t\t       __entry->stream = stream;\n\t\t       __entry->stream_w = stream->timing.h_addressable;\n\t\t       __entry->stream_h = stream->timing.v_addressable;\n\t\t       __entry->dst_x = plane_state->dst_rect.x;\n\t\t       __entry->dst_y = plane_state->dst_rect.y;\n\t\t       __entry->dst_w = plane_state->dst_rect.width;\n\t\t       __entry->dst_h = plane_state->dst_rect.height;\n\t\t       __entry->src_x = plane_state->src_rect.x;\n\t\t       __entry->src_y = plane_state->src_rect.y;\n\t\t       __entry->src_w = plane_state->src_rect.width;\n\t\t       __entry->src_h = plane_state->src_rect.height;\n\t\t       __entry->clip_x = plane_state->clip_rect.x;\n\t\t       __entry->clip_y = plane_state->clip_rect.y;\n\t\t       __entry->clip_w = plane_state->clip_rect.width;\n\t\t       __entry->clip_h = plane_state->clip_rect.height;\n\t\t       __entry->recout_x = plane_res->scl_data.recout.x;\n\t\t       __entry->recout_y = plane_res->scl_data.recout.y;\n\t\t       __entry->recout_w = plane_res->scl_data.recout.width;\n\t\t       __entry->recout_h = plane_res->scl_data.recout.height;\n\t\t       __entry->viewport_x = plane_res->scl_data.viewport.x;\n\t\t       __entry->viewport_y = plane_res->scl_data.viewport.y;\n\t\t       __entry->viewport_w = plane_res->scl_data.viewport.width;\n\t\t       __entry->viewport_h = plane_res->scl_data.viewport.height;\n\t\t       __entry->flip_immediate = plane_state->flip_immediate;\n\t\t       __entry->surface_pitch = plane_state->plane_size.surface_pitch;\n\t\t       __entry->format = plane_state->format;\n\t\t       __entry->swizzle = plane_state->tiling_info.gfx9.swizzle;\n\t\t       __entry->update_flags = update_flags;\n\t),\n\tTP_printk(\"pipe_idx=%d stream=%p rct(%d,%d) dst=(%d,%d,%d,%d) \"\n\t\t  \"src=(%d,%d,%d,%d) clip=(%d,%d,%d,%d) recout=(%d,%d,%d,%d) \"\n\t\t  \"viewport=(%d,%d,%d,%d) flip_immediate=%d pitch=%d \"\n\t\t  \"format=%d swizzle=%d update_flags=%x\",\n\t\t  __entry->pipe_idx,\n\t\t  __entry->stream,\n\t\t  __entry->stream_w,\n\t\t  __entry->stream_h,\n\t\t  __entry->dst_x,\n\t\t  __entry->dst_y,\n\t\t  __entry->dst_w,\n\t\t  __entry->dst_h,\n\t\t  __entry->src_x,\n\t\t  __entry->src_y,\n\t\t  __entry->src_w,\n\t\t  __entry->src_h,\n\t\t  __entry->clip_x,\n\t\t  __entry->clip_y,\n\t\t  __entry->clip_w,\n\t\t  __entry->clip_h,\n\t\t  __entry->recout_x,\n\t\t  __entry->recout_y,\n\t\t  __entry->recout_w,\n\t\t  __entry->recout_h,\n\t\t  __entry->viewport_x,\n\t\t  __entry->viewport_y,\n\t\t  __entry->viewport_w,\n\t\t  __entry->viewport_h,\n\t\t  __entry->flip_immediate,\n\t\t  __entry->surface_pitch,\n\t\t  __entry->format,\n\t\t  __entry->swizzle,\n\t\t  __entry->update_flags\n\t)\n);\n\nTRACE_EVENT(amdgpu_dm_dc_clocks_state,\n\t    TP_PROTO(const struct dc_clocks *clk),\n\t    TP_ARGS(clk),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(int, dispclk_khz)\n\t\t\t     __field(int, dppclk_khz)\n\t\t\t     __field(int, disp_dpp_voltage_level_khz)\n\t\t\t     __field(int, dcfclk_khz)\n\t\t\t     __field(int, socclk_khz)\n\t\t\t     __field(int, dcfclk_deep_sleep_khz)\n\t\t\t     __field(int, fclk_khz)\n\t\t\t     __field(int, phyclk_khz)\n\t\t\t     __field(int, dramclk_khz)\n\t\t\t     __field(int, p_state_change_support)\n\t\t\t     __field(int, prev_p_state_change_support)\n\t\t\t     __field(int, pwr_state)\n\t\t\t     __field(int, dtm_level)\n\t\t\t     __field(int, max_supported_dppclk_khz)\n\t\t\t     __field(int, max_supported_dispclk_khz)\n\t\t\t     __field(int, bw_dppclk_khz)\n\t\t\t     __field(int, bw_dispclk_khz)\n\t    ),\n\t    TP_fast_assign(\n\t\t\t   __entry->dispclk_khz = clk->dispclk_khz;\n\t\t\t   __entry->dppclk_khz = clk->dppclk_khz;\n\t\t\t   __entry->dcfclk_khz = clk->dcfclk_khz;\n\t\t\t   __entry->socclk_khz = clk->socclk_khz;\n\t\t\t   __entry->dcfclk_deep_sleep_khz = clk->dcfclk_deep_sleep_khz;\n\t\t\t   __entry->fclk_khz = clk->fclk_khz;\n\t\t\t   __entry->phyclk_khz = clk->phyclk_khz;\n\t\t\t   __entry->dramclk_khz = clk->dramclk_khz;\n\t\t\t   __entry->p_state_change_support = clk->p_state_change_support;\n\t\t\t   __entry->prev_p_state_change_support = clk->prev_p_state_change_support;\n\t\t\t   __entry->pwr_state = clk->pwr_state;\n\t\t\t   __entry->prev_p_state_change_support = clk->prev_p_state_change_support;\n\t\t\t   __entry->dtm_level = clk->dtm_level;\n\t\t\t   __entry->max_supported_dppclk_khz = clk->max_supported_dppclk_khz;\n\t\t\t   __entry->max_supported_dispclk_khz = clk->max_supported_dispclk_khz;\n\t\t\t   __entry->bw_dppclk_khz = clk->bw_dppclk_khz;\n\t\t\t   __entry->bw_dispclk_khz = clk->bw_dispclk_khz;\n\t    ),\n\t    TP_printk(\"dispclk_khz=%d dppclk_khz=%d disp_dpp_voltage_level_khz=%d dcfclk_khz=%d socclk_khz=%d \"\n\t\t      \"dcfclk_deep_sleep_khz=%d fclk_khz=%d phyclk_khz=%d \"\n\t\t      \"dramclk_khz=%d p_state_change_support=%d \"\n\t\t      \"prev_p_state_change_support=%d pwr_state=%d prev_p_state_change_support=%d \"\n\t\t      \"dtm_level=%d max_supported_dppclk_khz=%d max_supported_dispclk_khz=%d \"\n\t\t      \"bw_dppclk_khz=%d bw_dispclk_khz=%d \",\n\t\t      __entry->dispclk_khz,\n\t\t      __entry->dppclk_khz,\n\t\t      __entry->disp_dpp_voltage_level_khz,\n\t\t      __entry->dcfclk_khz,\n\t\t      __entry->socclk_khz,\n\t\t      __entry->dcfclk_deep_sleep_khz,\n\t\t      __entry->fclk_khz,\n\t\t      __entry->phyclk_khz,\n\t\t      __entry->dramclk_khz,\n\t\t      __entry->p_state_change_support,\n\t\t      __entry->prev_p_state_change_support,\n\t\t      __entry->pwr_state,\n\t\t      __entry->prev_p_state_change_support,\n\t\t      __entry->dtm_level,\n\t\t      __entry->max_supported_dppclk_khz,\n\t\t      __entry->max_supported_dispclk_khz,\n\t\t      __entry->bw_dppclk_khz,\n\t\t      __entry->bw_dispclk_khz\n\t    )\n);\n\nTRACE_EVENT(amdgpu_dm_dce_clocks_state,\n\t    TP_PROTO(const struct dce_bw_output *clk),\n\t    TP_ARGS(clk),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(bool, cpuc_state_change_enable)\n\t\t\t     __field(bool, cpup_state_change_enable)\n\t\t\t     __field(bool, stutter_mode_enable)\n\t\t\t     __field(bool, nbp_state_change_enable)\n\t\t\t     __field(bool, all_displays_in_sync)\n\t\t\t     __field(int, sclk_khz)\n\t\t\t     __field(int, sclk_deep_sleep_khz)\n\t\t\t     __field(int, yclk_khz)\n\t\t\t     __field(int, dispclk_khz)\n\t\t\t     __field(int, blackout_recovery_time_us)\n\t    ),\n\t    TP_fast_assign(\n\t\t\t   __entry->cpuc_state_change_enable = clk->cpuc_state_change_enable;\n\t\t\t   __entry->cpup_state_change_enable = clk->cpup_state_change_enable;\n\t\t\t   __entry->stutter_mode_enable = clk->stutter_mode_enable;\n\t\t\t   __entry->nbp_state_change_enable = clk->nbp_state_change_enable;\n\t\t\t   __entry->all_displays_in_sync = clk->all_displays_in_sync;\n\t\t\t   __entry->sclk_khz = clk->sclk_khz;\n\t\t\t   __entry->sclk_deep_sleep_khz = clk->sclk_deep_sleep_khz;\n\t\t\t   __entry->yclk_khz = clk->yclk_khz;\n\t\t\t   __entry->dispclk_khz = clk->dispclk_khz;\n\t\t\t   __entry->blackout_recovery_time_us = clk->blackout_recovery_time_us;\n\t    ),\n\t    TP_printk(\"cpuc_state_change_enable=%d cpup_state_change_enable=%d stutter_mode_enable=%d \"\n\t\t      \"nbp_state_change_enable=%d all_displays_in_sync=%d sclk_khz=%d sclk_deep_sleep_khz=%d \"\n\t\t      \"yclk_khz=%d dispclk_khz=%d blackout_recovery_time_us=%d\",\n\t\t      __entry->cpuc_state_change_enable,\n\t\t      __entry->cpup_state_change_enable,\n\t\t      __entry->stutter_mode_enable,\n\t\t      __entry->nbp_state_change_enable,\n\t\t      __entry->all_displays_in_sync,\n\t\t      __entry->sclk_khz,\n\t\t      __entry->sclk_deep_sleep_khz,\n\t\t      __entry->yclk_khz,\n\t\t      __entry->dispclk_khz,\n\t\t      __entry->blackout_recovery_time_us\n\t    )\n);\n\nTRACE_EVENT(amdgpu_dmub_trace_high_irq,\n\tTP_PROTO(uint32_t trace_code, uint32_t tick_count, uint32_t param0,\n\t\t uint32_t param1),\n\tTP_ARGS(trace_code, tick_count, param0, param1),\n\tTP_STRUCT__entry(\n\t\t__field(uint32_t, trace_code)\n\t\t__field(uint32_t, tick_count)\n\t\t__field(uint32_t, param0)\n\t\t__field(uint32_t, param1)\n\t\t),\n\tTP_fast_assign(\n\t\t__entry->trace_code = trace_code;\n\t\t__entry->tick_count = tick_count;\n\t\t__entry->param0 = param0;\n\t\t__entry->param1 = param1;\n\t),\n\tTP_printk(\"trace_code=%u tick_count=%u param0=%u param1=%u\",\n\t\t  __entry->trace_code, __entry->tick_count,\n\t\t  __entry->param0, __entry->param1)\n);\n\nTRACE_EVENT(amdgpu_refresh_rate_track,\n\tTP_PROTO(int crtc_index, ktime_t refresh_rate_ns, uint32_t refresh_rate_hz),\n\tTP_ARGS(crtc_index, refresh_rate_ns, refresh_rate_hz),\n\tTP_STRUCT__entry(\n\t\t__field(int, crtc_index)\n\t\t__field(ktime_t, refresh_rate_ns)\n\t\t__field(uint32_t, refresh_rate_hz)\n\t\t),\n\tTP_fast_assign(\n\t\t__entry->crtc_index = crtc_index;\n\t\t__entry->refresh_rate_ns = refresh_rate_ns;\n\t\t__entry->refresh_rate_hz = refresh_rate_hz;\n\t),\n\tTP_printk(\"crtc_index=%d refresh_rate=%dHz (%lld)\",\n\t\t  __entry->crtc_index,\n\t\t  __entry->refresh_rate_hz,\n\t\t  __entry->refresh_rate_ns)\n);\n\nTRACE_EVENT(dcn_fpu,\n\t    TP_PROTO(bool begin, const char *function, const int line, const int recursion_depth),\n\t    TP_ARGS(begin, function, line, recursion_depth),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(bool, begin)\n\t\t\t     __field(const char *, function)\n\t\t\t     __field(int, line)\n\t\t\t     __field(int, recursion_depth)\n\t    ),\n\t    TP_fast_assign(\n\t\t\t   __entry->begin = begin;\n\t\t\t   __entry->function = function;\n\t\t\t   __entry->line = line;\n\t\t\t   __entry->recursion_depth = recursion_depth;\n\t    ),\n\t    TP_printk(\"%s: recursion_depth: %d: %s()+%d:\",\n\t\t      __entry->begin ? \"begin\" : \"end\",\n\t\t      __entry->recursion_depth,\n\t\t      __entry->function,\n\t\t      __entry->line\n\t    )\n);\n\nTRACE_EVENT(dcn_optc_lock_unlock_state,\n\t    TP_PROTO(const struct optc *optc_state, int instance, bool lock, const char *function, const int line),\n\t    TP_ARGS(optc_state, instance, lock, function, line),\n\n\t    TP_STRUCT__entry(\n\t\t\t     __field(const char *, function)\n\t\t\t     __field(int, instance)\n\t\t\t     __field(bool, lock)\n\t\t\t     __field(int, line)\n\t\t\t     __field(int, opp_count)\n\t\t\t     __field(int, max_h_total)\n\t\t\t     __field(int, max_v_total)\n\t\t\t     __field(int, min_h_blank)\n\t\t\t     __field(int, min_h_sync_width)\n\t\t\t     __field(int, min_v_sync_width)\n\t\t\t     __field(int, min_v_blank)\n\t\t\t     __field(int, min_v_blank_interlace)\n\t\t\t     __field(int, vstartup_start)\n\t\t\t     __field(int, vupdate_offset)\n\t\t\t     __field(int, vupdate_width)\n\t\t\t     __field(int, vready_offset)\n\t    ),\n\t    TP_fast_assign(\n\t\t\t   __entry->function = function;\n\t\t\t   __entry->instance = instance;\n\t\t\t   __entry->lock = lock;\n\t\t\t   __entry->line = line;\n\t\t\t   __entry->opp_count = optc_state->opp_count;\n\t\t\t   __entry->max_h_total = optc_state->max_h_total;\n\t\t\t   __entry->max_v_total = optc_state->max_v_total;\n\t\t\t   __entry->min_h_blank = optc_state->min_h_blank;\n\t\t\t   __entry->min_h_sync_width = optc_state->min_h_sync_width;\n\t\t\t   __entry->min_v_sync_width = optc_state->min_v_sync_width;\n\t\t\t   __entry->min_v_blank = optc_state->min_v_blank;\n\t\t\t   __entry->min_v_blank_interlace = optc_state->min_v_blank_interlace;\n\t\t\t   __entry->vstartup_start = optc_state->vstartup_start;\n\t\t\t   __entry->vupdate_offset = optc_state->vupdate_offset;\n\t\t\t   __entry->vupdate_width = optc_state->vupdate_width;\n\t\t\t   __entry->vready_offset = optc_state->vupdate_offset;\n\t    ),\n\t    TP_printk(\"%s: %s()+%d: optc_instance=%d opp_count=%d max_h_total=%d max_v_total=%d \"\n\t\t      \"min_h_blank=%d min_h_sync_width=%d min_v_sync_width=%d min_v_blank=%d \"\n\t\t      \"min_v_blank_interlace=%d vstartup_start=%d vupdate_offset=%d vupdate_width=%d \"\n\t\t      \"vready_offset=%d\",\n\t\t      __entry->lock ? \"Lock\" : \"Unlock\",\n\t\t      __entry->function,\n\t\t      __entry->line,\n\t\t      __entry->instance,\n\t\t      __entry->opp_count,\n\t\t      __entry->max_h_total,\n\t\t      __entry->max_v_total,\n\t\t      __entry->min_h_blank,\n\t\t      __entry->min_h_sync_width,\n\t\t      __entry->min_v_sync_width,\n\t\t      __entry->min_v_blank,\n\t\t      __entry->min_v_blank_interlace,\n\t\t      __entry->vstartup_start,\n\t\t      __entry->vupdate_offset,\n\t\t      __entry->vupdate_width,\n\t\t      __entry->vready_offset\n\t    )\n);\n\n#endif  \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#define TRACE_INCLUDE_FILE amdgpu_dm_trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}