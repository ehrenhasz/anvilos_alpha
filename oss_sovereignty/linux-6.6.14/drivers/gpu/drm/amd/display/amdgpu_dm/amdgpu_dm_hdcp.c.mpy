{
  "module_name": "amdgpu_dm_hdcp.c",
  "hash_id": "4d61325bf66e20bb2365ba80e5a85c4c8ed9756edc0b3b65c38f5b60440c8321",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c",
  "human_readable_source": " \n\n#include \"amdgpu_dm_hdcp.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_dm.h\"\n#include \"dm_helpers.h\"\n#include <drm/display/drm_hdcp_helper.h>\n#include \"hdcp_psp.h\"\n\n \n#define PSP_SRM_VERSION_MAX 0xFFFF\n\nstatic bool\nlp_write_i2c(void *handle, uint32_t address, const uint8_t *data, uint32_t size)\n{\n\tstruct dc_link *link = handle;\n\tstruct i2c_payload i2c_payloads[] = {{true, address, size, (void *)data} };\n\tstruct i2c_command cmd = {i2c_payloads, 1, I2C_COMMAND_ENGINE_HW,\n\t\t\t\t  link->dc->caps.i2c_speed_in_khz};\n\n\treturn dm_helpers_submit_i2c(link->ctx, link, &cmd);\n}\n\nstatic bool\nlp_read_i2c(void *handle, uint32_t address, uint8_t offset, uint8_t *data, uint32_t size)\n{\n\tstruct dc_link *link = handle;\n\n\tstruct i2c_payload i2c_payloads[] = {{true, address, 1, &offset},\n\t\t\t\t\t     {false, address, size, data} };\n\tstruct i2c_command cmd = {i2c_payloads, 2, I2C_COMMAND_ENGINE_HW,\n\t\t\t\t  link->dc->caps.i2c_speed_in_khz};\n\n\treturn dm_helpers_submit_i2c(link->ctx, link, &cmd);\n}\n\nstatic bool\nlp_write_dpcd(void *handle, uint32_t address, const uint8_t *data, uint32_t size)\n{\n\tstruct dc_link *link = handle;\n\n\treturn dm_helpers_dp_write_dpcd(link->ctx, link, address, data, size);\n}\n\nstatic bool\nlp_read_dpcd(void *handle, uint32_t address, uint8_t *data, uint32_t size)\n{\n\tstruct dc_link *link = handle;\n\n\treturn dm_helpers_dp_read_dpcd(link->ctx, link, address, data, size);\n}\n\nstatic uint8_t *psp_get_srm(struct psp_context *psp, uint32_t *srm_version, uint32_t *srm_size)\n{\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\n\tif (!psp->hdcp_context.context.initialized) {\n\t\tDRM_WARN(\"Failed to get hdcp srm. HDCP TA is not initialized.\");\n\t\treturn NULL;\n\t}\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP_GET_SRM;\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\treturn NULL;\n\n\t*srm_version = hdcp_cmd->out_msg.hdcp_get_srm.srm_version;\n\t*srm_size = hdcp_cmd->out_msg.hdcp_get_srm.srm_buf_size;\n\n\treturn hdcp_cmd->out_msg.hdcp_get_srm.srm_buf;\n}\n\nstatic int psp_set_srm(struct psp_context *psp,\n\t\t       u8 *srm, uint32_t srm_size, uint32_t *srm_version)\n{\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\n\tif (!psp->hdcp_context.context.initialized) {\n\t\tDRM_WARN(\"Failed to get hdcp srm. HDCP TA is not initialized.\");\n\t\treturn -EINVAL;\n\t}\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmemcpy(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, srm, srm_size);\n\thdcp_cmd->in_msg.hdcp_set_srm.srm_buf_size = srm_size;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP_SET_SRM;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS ||\n\t    hdcp_cmd->out_msg.hdcp_set_srm.valid_signature != 1 ||\n\t    hdcp_cmd->out_msg.hdcp_set_srm.srm_version == PSP_SRM_VERSION_MAX)\n\t\treturn -EINVAL;\n\n\t*srm_version = hdcp_cmd->out_msg.hdcp_set_srm.srm_version;\n\treturn 0;\n}\n\nstatic void process_output(struct hdcp_workqueue *hdcp_work)\n{\n\tstruct mod_hdcp_output output = hdcp_work->output;\n\n\tif (output.callback_stop)\n\t\tcancel_delayed_work(&hdcp_work->callback_dwork);\n\n\tif (output.callback_needed)\n\t\tschedule_delayed_work(&hdcp_work->callback_dwork,\n\t\t\t\t      msecs_to_jiffies(output.callback_delay));\n\n\tif (output.watchdog_timer_stop)\n\t\tcancel_delayed_work(&hdcp_work->watchdog_timer_dwork);\n\n\tif (output.watchdog_timer_needed)\n\t\tschedule_delayed_work(&hdcp_work->watchdog_timer_dwork,\n\t\t\t\t      msecs_to_jiffies(output.watchdog_timer_delay));\n\n\tschedule_delayed_work(&hdcp_work->property_validate_dwork, msecs_to_jiffies(0));\n}\n\nstatic void link_lock(struct hdcp_workqueue *work, bool lock)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < work->max_link; i++) {\n\t\tif (lock)\n\t\t\tmutex_lock(&work[i].mutex);\n\t\telse\n\t\t\tmutex_unlock(&work[i].mutex);\n\t}\n}\n\nvoid hdcp_update_display(struct hdcp_workqueue *hdcp_work,\n\t\t\t unsigned int link_index,\n\t\t\t struct amdgpu_dm_connector *aconnector,\n\t\t\t u8 content_type,\n\t\t\t bool enable_encryption)\n{\n\tstruct hdcp_workqueue *hdcp_w = &hdcp_work[link_index];\n\tstruct mod_hdcp_link_adjustment link_adjust;\n\tstruct mod_hdcp_display_adjustment display_adjust;\n\tunsigned int conn_index = aconnector->base.index;\n\n\tmutex_lock(&hdcp_w->mutex);\n\thdcp_w->aconnector[conn_index] = aconnector;\n\n\tmemset(&link_adjust, 0, sizeof(link_adjust));\n\tmemset(&display_adjust, 0, sizeof(display_adjust));\n\n\tif (enable_encryption) {\n\t\t \n\t\tif (hdcp_work->srm_size > 0)\n\t\t\tpsp_set_srm(hdcp_work->hdcp.config.psp.handle, hdcp_work->srm,\n\t\t\t\t    hdcp_work->srm_size,\n\t\t\t\t    &hdcp_work->srm_version);\n\n\t\tdisplay_adjust.disable = MOD_HDCP_DISPLAY_NOT_DISABLE;\n\n\t\tlink_adjust.auth_delay = 2;\n\n\t\tif (content_type == DRM_MODE_HDCP_CONTENT_TYPE0) {\n\t\t\tlink_adjust.hdcp2.force_type = MOD_HDCP_FORCE_TYPE_0;\n\t\t} else if (content_type == DRM_MODE_HDCP_CONTENT_TYPE1) {\n\t\t\tlink_adjust.hdcp1.disable = 1;\n\t\t\tlink_adjust.hdcp2.force_type = MOD_HDCP_FORCE_TYPE_1;\n\t\t}\n\n\t\tschedule_delayed_work(&hdcp_w->property_validate_dwork,\n\t\t\t\t      msecs_to_jiffies(DRM_HDCP_CHECK_PERIOD_MS));\n\t} else {\n\t\tdisplay_adjust.disable = MOD_HDCP_DISPLAY_DISABLE_AUTHENTICATION;\n\t\thdcp_w->encryption_status[conn_index] = MOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\t\tcancel_delayed_work(&hdcp_w->property_validate_dwork);\n\t}\n\n\tmod_hdcp_update_display(&hdcp_w->hdcp, conn_index, &link_adjust, &display_adjust, &hdcp_w->output);\n\n\tprocess_output(hdcp_w);\n\tmutex_unlock(&hdcp_w->mutex);\n}\n\nstatic void hdcp_remove_display(struct hdcp_workqueue *hdcp_work,\n\t\t\t\tunsigned int link_index,\n\t\t\t struct amdgpu_dm_connector *aconnector)\n{\n\tstruct hdcp_workqueue *hdcp_w = &hdcp_work[link_index];\n\tstruct drm_connector_state *conn_state = aconnector->base.state;\n\tunsigned int conn_index = aconnector->base.index;\n\n\tmutex_lock(&hdcp_w->mutex);\n\thdcp_w->aconnector[conn_index] = aconnector;\n\n\t \n\tif (conn_state && conn_state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\tconn_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\n\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] display %d, CP 2 -> 1, type %u, DPMS %u\\n\",\n\t\t\t\t aconnector->base.index, conn_state->hdcp_content_type,\n\t\t\t\t aconnector->base.dpms);\n\t}\n\n\tmod_hdcp_remove_display(&hdcp_w->hdcp, aconnector->base.index, &hdcp_w->output);\n\n\tprocess_output(hdcp_w);\n\tmutex_unlock(&hdcp_w->mutex);\n}\n\nvoid hdcp_reset_display(struct hdcp_workqueue *hdcp_work, unsigned int link_index)\n{\n\tstruct hdcp_workqueue *hdcp_w = &hdcp_work[link_index];\n\tunsigned int conn_index;\n\n\tmutex_lock(&hdcp_w->mutex);\n\n\tmod_hdcp_reset_connection(&hdcp_w->hdcp,  &hdcp_w->output);\n\n\tcancel_delayed_work(&hdcp_w->property_validate_dwork);\n\n\tfor (conn_index = 0; conn_index < AMDGPU_DM_MAX_DISPLAY_INDEX; conn_index++) {\n\t\thdcp_w->encryption_status[conn_index] =\n\t\t\tMOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\t}\n\n\tprocess_output(hdcp_w);\n\n\tmutex_unlock(&hdcp_w->mutex);\n}\n\nvoid hdcp_handle_cpirq(struct hdcp_workqueue *hdcp_work, unsigned int link_index)\n{\n\tstruct hdcp_workqueue *hdcp_w = &hdcp_work[link_index];\n\n\tschedule_work(&hdcp_w->cpirq_work);\n}\n\nstatic void event_callback(struct work_struct *work)\n{\n\tstruct hdcp_workqueue *hdcp_work;\n\n\thdcp_work = container_of(to_delayed_work(work), struct hdcp_workqueue,\n\t\t\t\t callback_dwork);\n\n\tmutex_lock(&hdcp_work->mutex);\n\n\tcancel_delayed_work(&hdcp_work->callback_dwork);\n\n\tmod_hdcp_process_event(&hdcp_work->hdcp, MOD_HDCP_EVENT_CALLBACK,\n\t\t\t       &hdcp_work->output);\n\n\tprocess_output(hdcp_work);\n\n\tmutex_unlock(&hdcp_work->mutex);\n}\n\nstatic void event_property_update(struct work_struct *work)\n{\n\tstruct hdcp_workqueue *hdcp_work = container_of(work, struct hdcp_workqueue,\n\t\t\t\t\t\t\tproperty_update_work);\n\tstruct amdgpu_dm_connector *aconnector = NULL;\n\tstruct drm_device *dev;\n\tlong ret;\n\tunsigned int conn_index;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tfor (conn_index = 0; conn_index < AMDGPU_DM_MAX_DISPLAY_INDEX; conn_index++) {\n\t\taconnector = hdcp_work->aconnector[conn_index];\n\n\t\tif (!aconnector)\n\t\t\tcontinue;\n\n\t\tconnector = &aconnector->base;\n\n\t\t \n\t\tif (connector->status != connector_status_connected)\n\t\t\tcontinue;\n\n\t\tconn_state = aconnector->base.state;\n\n\t\tif (!conn_state)\n\t\t\tcontinue;\n\n\t\tdev = connector->dev;\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\t\tmutex_lock(&hdcp_work->mutex);\n\n\t\tif (conn_state->commit) {\n\t\t\tret = wait_for_completion_interruptible_timeout(&conn_state->commit->hw_done,\n\t\t\t\t\t\t\t\t\t10 * HZ);\n\t\t\tif (ret == 0) {\n\t\t\t\tDRM_ERROR(\"HDCP state unknown! Setting it to DESIRED\\n\");\n\t\t\t\thdcp_work->encryption_status[conn_index] =\n\t\t\t\t\tMOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\t\t\t}\n\t\t}\n\t\tif (hdcp_work->encryption_status[conn_index] !=\n\t\t\tMOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF) {\n\t\t\tif (conn_state->hdcp_content_type ==\n\t\t\t\tDRM_MODE_HDCP_CONTENT_TYPE0 &&\n\t\t\t\thdcp_work->encryption_status[conn_index] <=\n\t\t\t\tMOD_HDCP_ENCRYPTION_STATUS_HDCP2_TYPE0_ON) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] DRM_MODE_CONTENT_PROTECTION_ENABLED\\n\");\n\t\t\t\tdrm_hdcp_update_content_protection(connector,\n\t\t\t\t\t\t\t\t   DRM_MODE_CONTENT_PROTECTION_ENABLED);\n\t\t\t} else if (conn_state->hdcp_content_type ==\n\t\t\t\t\tDRM_MODE_HDCP_CONTENT_TYPE1 &&\n\t\t\t\t\thdcp_work->encryption_status[conn_index] ==\n\t\t\t\t\tMOD_HDCP_ENCRYPTION_STATUS_HDCP2_TYPE1_ON) {\n\t\t\t\tdrm_hdcp_update_content_protection(connector,\n\t\t\t\t\t\t\t\t   DRM_MODE_CONTENT_PROTECTION_ENABLED);\n\t\t\t}\n\t\t} else {\n\t\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] DRM_MODE_CONTENT_PROTECTION_DESIRED\\n\");\n\t\t\tdrm_hdcp_update_content_protection(connector,\n\t\t\t\t\t\t\t   DRM_MODE_CONTENT_PROTECTION_DESIRED);\n\t\t}\n\t\tmutex_unlock(&hdcp_work->mutex);\n\t\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\t}\n}\n\nstatic void event_property_validate(struct work_struct *work)\n{\n\tstruct hdcp_workqueue *hdcp_work =\n\t\tcontainer_of(to_delayed_work(work), struct hdcp_workqueue, property_validate_dwork);\n\tstruct mod_hdcp_display_query query;\n\tstruct amdgpu_dm_connector *aconnector;\n\tunsigned int conn_index;\n\n\tmutex_lock(&hdcp_work->mutex);\n\n\tfor (conn_index = 0; conn_index < AMDGPU_DM_MAX_DISPLAY_INDEX;\n\t     conn_index++) {\n\t\taconnector = hdcp_work->aconnector[conn_index];\n\n\t\tif (!aconnector)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (aconnector->base.status != connector_status_connected)\n\t\t\tcontinue;\n\n\t\tif (!aconnector->base.state)\n\t\t\tcontinue;\n\n\t\tquery.encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\t\tmod_hdcp_query_display(&hdcp_work->hdcp, aconnector->base.index,\n\t\t\t\t       &query);\n\n\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] disp %d, connector->CP %u, (query, work): (%d, %d)\\n\",\n\t\t\t\t aconnector->base.index,\n\t\t\taconnector->base.state->content_protection,\n\t\t\tquery.encryption_status,\n\t\t\thdcp_work->encryption_status[conn_index]);\n\n\t\tif (query.encryption_status !=\n\t\t    hdcp_work->encryption_status[conn_index]) {\n\t\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] encryption_status change from %x to %x\\n\",\n\t\t\t\t\t hdcp_work->encryption_status[conn_index],\n\t\t\t\t\t query.encryption_status);\n\n\t\t\thdcp_work->encryption_status[conn_index] =\n\t\t\t\tquery.encryption_status;\n\n\t\t\tDRM_DEBUG_DRIVER(\"[HDCP_DM] trigger property_update_work\\n\");\n\n\t\t\tschedule_work(&hdcp_work->property_update_work);\n\t\t}\n\t}\n\n\tmutex_unlock(&hdcp_work->mutex);\n}\n\nstatic void event_watchdog_timer(struct work_struct *work)\n{\n\tstruct hdcp_workqueue *hdcp_work;\n\n\thdcp_work = container_of(to_delayed_work(work),\n\t\t\t\t struct hdcp_workqueue,\n\t\t\t\t      watchdog_timer_dwork);\n\n\tmutex_lock(&hdcp_work->mutex);\n\n\tcancel_delayed_work(&hdcp_work->watchdog_timer_dwork);\n\n\tmod_hdcp_process_event(&hdcp_work->hdcp,\n\t\t\t       MOD_HDCP_EVENT_WATCHDOG_TIMEOUT,\n\t\t\t       &hdcp_work->output);\n\n\tprocess_output(hdcp_work);\n\n\tmutex_unlock(&hdcp_work->mutex);\n}\n\nstatic void event_cpirq(struct work_struct *work)\n{\n\tstruct hdcp_workqueue *hdcp_work;\n\n\thdcp_work = container_of(work, struct hdcp_workqueue, cpirq_work);\n\n\tmutex_lock(&hdcp_work->mutex);\n\n\tmod_hdcp_process_event(&hdcp_work->hdcp, MOD_HDCP_EVENT_CPIRQ, &hdcp_work->output);\n\n\tprocess_output(hdcp_work);\n\n\tmutex_unlock(&hdcp_work->mutex);\n}\n\nvoid hdcp_destroy(struct kobject *kobj, struct hdcp_workqueue *hdcp_work)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < hdcp_work->max_link; i++) {\n\t\tcancel_delayed_work_sync(&hdcp_work[i].callback_dwork);\n\t\tcancel_delayed_work_sync(&hdcp_work[i].watchdog_timer_dwork);\n\t}\n\n\tsysfs_remove_bin_file(kobj, &hdcp_work[0].attr);\n\tkfree(hdcp_work->srm);\n\tkfree(hdcp_work->srm_temp);\n\tkfree(hdcp_work);\n}\n\nstatic bool enable_assr(void *handle, struct dc_link *link)\n{\n\tstruct hdcp_workqueue *hdcp_work = handle;\n\tstruct mod_hdcp hdcp = hdcp_work->hdcp;\n\tstruct psp_context *psp = hdcp.config.psp.handle;\n\tstruct ta_dtm_shared_memory *dtm_cmd;\n\tbool res = true;\n\n\tif (!psp->dtm_context.context.initialized) {\n\t\tDRM_INFO(\"Failed to enable ASSR, DTM TA is not initialized.\");\n\t\treturn false;\n\t}\n\n\tdtm_cmd = (struct ta_dtm_shared_memory *)psp->dtm_context.context.mem_context.shared_buf;\n\n\tmutex_lock(&psp->dtm_context.mutex);\n\tmemset(dtm_cmd, 0, sizeof(struct ta_dtm_shared_memory));\n\n\tdtm_cmd->cmd_id = TA_DTM_COMMAND__TOPOLOGY_ASSR_ENABLE;\n\tdtm_cmd->dtm_in_message.topology_assr_enable.display_topology_dig_be_index =\n\t\tlink->link_enc_hw_inst;\n\tdtm_cmd->dtm_status = TA_DTM_STATUS__GENERIC_FAILURE;\n\n\tpsp_dtm_invoke(psp, dtm_cmd->cmd_id);\n\n\tif (dtm_cmd->dtm_status != TA_DTM_STATUS__SUCCESS) {\n\t\tDRM_INFO(\"Failed to enable ASSR\");\n\t\tres = false;\n\t}\n\n\tmutex_unlock(&psp->dtm_context.mutex);\n\n\treturn res;\n}\n\nstatic void update_config(void *handle, struct cp_psp_stream_config *config)\n{\n\tstruct hdcp_workqueue *hdcp_work = handle;\n\tstruct amdgpu_dm_connector *aconnector = config->dm_stream_ctx;\n\tint link_index = aconnector->dc_link->link_index;\n\tstruct mod_hdcp_display *display = &hdcp_work[link_index].display;\n\tstruct mod_hdcp_link *link = &hdcp_work[link_index].link;\n\tstruct hdcp_workqueue *hdcp_w = &hdcp_work[link_index];\n\tstruct dc_sink *sink = NULL;\n\tbool link_is_hdcp14 = false;\n\n\tif (config->dpms_off) {\n\t\thdcp_remove_display(hdcp_work, link_index, aconnector);\n\t\treturn;\n\t}\n\n\tmemset(display, 0, sizeof(*display));\n\tmemset(link, 0, sizeof(*link));\n\n\tdisplay->index = aconnector->base.index;\n\tdisplay->state = MOD_HDCP_DISPLAY_ACTIVE;\n\n\tif (aconnector->dc_sink)\n\t\tsink = aconnector->dc_sink;\n\telse if (aconnector->dc_em_sink)\n\t\tsink = aconnector->dc_em_sink;\n\n\tif (sink)\n\t\tlink->mode = mod_hdcp_signal_type_to_operation_mode(sink->sink_signal);\n\n\tdisplay->controller = CONTROLLER_ID_D0 + config->otg_inst;\n\tdisplay->dig_fe = config->dig_fe;\n\tlink->dig_be = config->dig_be;\n\tlink->ddc_line = aconnector->dc_link->ddc_hw_inst + 1;\n\tdisplay->stream_enc_idx = config->stream_enc_idx;\n\tlink->link_enc_idx = config->link_enc_idx;\n\tlink->dio_output_id = config->dio_output_idx;\n\tlink->phy_idx = config->phy_idx;\n\n\tif (sink)\n\t\tlink_is_hdcp14 = dc_link_is_hdcp14(aconnector->dc_link, sink->sink_signal);\n\tlink->hdcp_supported_informational = link_is_hdcp14;\n\tlink->dp.rev = aconnector->dc_link->dpcd_caps.dpcd_rev.raw;\n\tlink->dp.assr_enabled = config->assr_enabled;\n\tlink->dp.mst_enabled = config->mst_enabled;\n\tlink->dp.dp2_enabled = config->dp2_enabled;\n\tlink->dp.usb4_enabled = config->usb4_enabled;\n\tdisplay->adjust.disable = MOD_HDCP_DISPLAY_DISABLE_AUTHENTICATION;\n\tlink->adjust.auth_delay = 2;\n\tlink->adjust.hdcp1.disable = 0;\n\thdcp_w->encryption_status[display->index] = MOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\n\tDRM_DEBUG_DRIVER(\"[HDCP_DM] display %d, CP %d, type %d\\n\", aconnector->base.index,\n\t\t\t (!!aconnector->base.state) ?\n\t\t\t aconnector->base.state->content_protection : -1,\n\t\t\t (!!aconnector->base.state) ?\n\t\t\t aconnector->base.state->hdcp_content_type : -1);\n\n\tmutex_lock(&hdcp_w->mutex);\n\n\tmod_hdcp_add_display(&hdcp_w->hdcp, link, display, &hdcp_w->output);\n\n\tprocess_output(hdcp_w);\n\tmutex_unlock(&hdcp_w->mutex);\n\n}\n\n \nstatic ssize_t srm_data_write(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr, char *buffer,\n\t\t\t      loff_t pos, size_t count)\n{\n\tstruct hdcp_workqueue *work;\n\tu32 srm_version = 0;\n\n\twork = container_of(bin_attr, struct hdcp_workqueue, attr);\n\tlink_lock(work, true);\n\n\tmemcpy(work->srm_temp + pos, buffer, count);\n\n\tif (!psp_set_srm(work->hdcp.config.psp.handle, work->srm_temp, pos + count, &srm_version)) {\n\t\tDRM_DEBUG_DRIVER(\"HDCP SRM SET version 0x%X\", srm_version);\n\t\tmemcpy(work->srm, work->srm_temp, pos + count);\n\t\twork->srm_size = pos + count;\n\t\twork->srm_version = srm_version;\n\t}\n\n\tlink_lock(work, false);\n\n\treturn count;\n}\n\nstatic ssize_t srm_data_read(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr, char *buffer,\n\t\t\t     loff_t pos, size_t count)\n{\n\tstruct hdcp_workqueue *work;\n\tu8 *srm = NULL;\n\tu32 srm_version;\n\tu32 srm_size;\n\tsize_t ret = count;\n\n\twork = container_of(bin_attr, struct hdcp_workqueue, attr);\n\n\tlink_lock(work, true);\n\n\tsrm = psp_get_srm(work->hdcp.config.psp.handle, &srm_version, &srm_size);\n\n\tif (!srm) {\n\t\tret = -EINVAL;\n\t\tgoto ret;\n\t}\n\n\tif (pos >= srm_size)\n\t\tret = 0;\n\n\tif (srm_size - pos < count) {\n\t\tmemcpy(buffer, srm + pos, srm_size - pos);\n\t\tret = srm_size - pos;\n\t\tgoto ret;\n\t}\n\n\tmemcpy(buffer, srm + pos, count);\n\nret:\n\tlink_lock(work, false);\n\treturn ret;\n}\n\n \nstatic const struct bin_attribute data_attr = {\n\t.attr = {.name = \"hdcp_srm\", .mode = 0664},\n\t.size = PSP_HDCP_SRM_FIRST_GEN_MAX_SIZE,  \n\t.write = srm_data_write,\n\t.read = srm_data_read,\n};\n\nstruct hdcp_workqueue *hdcp_create_workqueue(struct amdgpu_device *adev,\n\t\t\t\t\t     struct cp_psp *cp_psp, struct dc *dc)\n{\n\tint max_caps = dc->caps.max_links;\n\tstruct hdcp_workqueue *hdcp_work;\n\tint i = 0;\n\n\thdcp_work = kcalloc(max_caps, sizeof(*hdcp_work), GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(hdcp_work))\n\t\treturn NULL;\n\n\thdcp_work->srm = kcalloc(PSP_HDCP_SRM_FIRST_GEN_MAX_SIZE,\n\t\t\t\t sizeof(*hdcp_work->srm), GFP_KERNEL);\n\n\tif (!hdcp_work->srm)\n\t\tgoto fail_alloc_context;\n\n\thdcp_work->srm_temp = kcalloc(PSP_HDCP_SRM_FIRST_GEN_MAX_SIZE,\n\t\t\t\t      sizeof(*hdcp_work->srm_temp), GFP_KERNEL);\n\n\tif (!hdcp_work->srm_temp)\n\t\tgoto fail_alloc_context;\n\n\thdcp_work->max_link = max_caps;\n\n\tfor (i = 0; i < max_caps; i++) {\n\t\tmutex_init(&hdcp_work[i].mutex);\n\n\t\tINIT_WORK(&hdcp_work[i].cpirq_work, event_cpirq);\n\t\tINIT_WORK(&hdcp_work[i].property_update_work, event_property_update);\n\t\tINIT_DELAYED_WORK(&hdcp_work[i].callback_dwork, event_callback);\n\t\tINIT_DELAYED_WORK(&hdcp_work[i].watchdog_timer_dwork, event_watchdog_timer);\n\t\tINIT_DELAYED_WORK(&hdcp_work[i].property_validate_dwork, event_property_validate);\n\n\t\thdcp_work[i].hdcp.config.psp.handle = &adev->psp;\n\t\tif (dc->ctx->dce_version == DCN_VERSION_3_1 ||\n\t\t    dc->ctx->dce_version == DCN_VERSION_3_14 ||\n\t\t    dc->ctx->dce_version == DCN_VERSION_3_15 ||\n\t\t    dc->ctx->dce_version == DCN_VERSION_3_16)\n\t\t\thdcp_work[i].hdcp.config.psp.caps.dtm_v3_supported = 1;\n\t\thdcp_work[i].hdcp.config.ddc.handle = dc_get_link_at_index(dc, i);\n\t\thdcp_work[i].hdcp.config.ddc.funcs.write_i2c = lp_write_i2c;\n\t\thdcp_work[i].hdcp.config.ddc.funcs.read_i2c = lp_read_i2c;\n\t\thdcp_work[i].hdcp.config.ddc.funcs.write_dpcd = lp_write_dpcd;\n\t\thdcp_work[i].hdcp.config.ddc.funcs.read_dpcd = lp_read_dpcd;\n\n\t\tmemset(hdcp_work[i].aconnector, 0,\n\t\t       sizeof(struct amdgpu_dm_connector *) *\n\t\t\t       AMDGPU_DM_MAX_DISPLAY_INDEX);\n\t\tmemset(hdcp_work[i].encryption_status, 0,\n\t\t       sizeof(enum mod_hdcp_encryption_status) *\n\t\t\t       AMDGPU_DM_MAX_DISPLAY_INDEX);\n\t}\n\n\tcp_psp->funcs.update_stream_config = update_config;\n\tcp_psp->funcs.enable_assr = enable_assr;\n\tcp_psp->handle = hdcp_work;\n\n\t \n\thdcp_work[0].attr = data_attr;\n\tsysfs_bin_attr_init(&hdcp_work[0].attr);\n\n\tif (sysfs_create_bin_file(&adev->dev->kobj, &hdcp_work[0].attr))\n\t\tDRM_WARN(\"Failed to create device file hdcp_srm\");\n\n\treturn hdcp_work;\n\nfail_alloc_context:\n\tkfree(hdcp_work->srm);\n\tkfree(hdcp_work->srm_temp);\n\tkfree(hdcp_work);\n\n\treturn NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}