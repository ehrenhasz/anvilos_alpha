{
  "module_name": "amdgpu_dm_color.c",
  "hash_id": "3e189223b34af146d47d6fc25a78a3ed75f6ed94a1163b1f9d2ce3e2f2414916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"amdgpu_mode.h\"\n#include \"amdgpu_dm.h\"\n#include \"dc.h\"\n#include \"modules/color/color_gamma.h\"\n#include \"basics/conversion.h\"\n\n \n\n#define MAX_DRM_LUT_VALUE 0xFFFF\n\n \nvoid amdgpu_dm_init_color_mod(void)\n{\n\tsetup_x_points_distribution();\n}\n\n \nstatic const struct drm_color_lut *\n__extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)\n{\n\t*size = blob ? drm_color_lut_size(blob) : 0;\n\treturn blob ? (struct drm_color_lut *)blob->data : NULL;\n}\n\n \nstatic bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)\n{\n\tint i;\n\tuint32_t expected;\n\tint delta;\n\n\tfor (i = 0; i < size; i++) {\n\t\t \n\t\tif ((lut[i].red != lut[i].green) || (lut[i].green != lut[i].blue))\n\t\t\treturn false;\n\n\t\texpected = i * MAX_DRM_LUT_VALUE / (size-1);\n\n\t\t \n\t\tdelta = lut[i].red - expected;\n\t\tif (delta < -1 || 1 < delta)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,\n\t\t\t\t  struct dc_gamma *gamma, bool is_legacy)\n{\n\tuint32_t r, g, b;\n\tint i;\n\n\tif (is_legacy) {\n\t\tfor (i = 0; i < MAX_COLOR_LEGACY_LUT_ENTRIES; i++) {\n\t\t\tr = drm_color_lut_extract(lut[i].red, 16);\n\t\t\tg = drm_color_lut_extract(lut[i].green, 16);\n\t\t\tb = drm_color_lut_extract(lut[i].blue, 16);\n\n\t\t\tgamma->entries.red[i] = dc_fixpt_from_int(r);\n\t\t\tgamma->entries.green[i] = dc_fixpt_from_int(g);\n\t\t\tgamma->entries.blue[i] = dc_fixpt_from_int(b);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {\n\t\tr = drm_color_lut_extract(lut[i].red, 16);\n\t\tg = drm_color_lut_extract(lut[i].green, 16);\n\t\tb = drm_color_lut_extract(lut[i].blue, 16);\n\n\t\tgamma->entries.red[i] = dc_fixpt_from_fraction(r, MAX_DRM_LUT_VALUE);\n\t\tgamma->entries.green[i] = dc_fixpt_from_fraction(g, MAX_DRM_LUT_VALUE);\n\t\tgamma->entries.blue[i] = dc_fixpt_from_fraction(b, MAX_DRM_LUT_VALUE);\n\t}\n}\n\n \nstatic void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,\n\t\t\t\t   struct fixed31_32 *matrix)\n{\n\tint64_t val;\n\tint i;\n\n\t \n\tfor (i = 0; i < 12; i++) {\n\t\t \n\t\tif (i % 4 == 3) {\n\t\t\tmatrix[i] = dc_fixpt_zero;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tval = ctm->matrix[i - (i / 4)];\n\t\t \n\t\tif (val & (1ULL << 63))\n\t\t\tval = -(val & ~(1ULL << 63));\n\n\t\tmatrix[i].value = val;\n\t}\n}\n\n \nstatic int __set_legacy_tf(struct dc_transfer_func *func,\n\t\t\t   const struct drm_color_lut *lut, uint32_t lut_size,\n\t\t\t   bool has_rom)\n{\n\tstruct dc_gamma *gamma = NULL;\n\tstruct calculate_buffer cal_buffer = {0};\n\tbool res;\n\n\tASSERT(lut && lut_size == MAX_COLOR_LEGACY_LUT_ENTRIES);\n\n\tcal_buffer.buffer_index = -1;\n\n\tgamma = dc_create_gamma();\n\tif (!gamma)\n\t\treturn -ENOMEM;\n\n\tgamma->type = GAMMA_RGB_256;\n\tgamma->num_entries = lut_size;\n\t__drm_lut_to_dc_gamma(lut, gamma, true);\n\n\tres = mod_color_calculate_regamma_params(func, gamma, true, has_rom,\n\t\t\t\t\t\t NULL, &cal_buffer);\n\n\tdc_gamma_release(&gamma);\n\n\treturn res ? 0 : -ENOMEM;\n}\n\n \nstatic int __set_output_tf(struct dc_transfer_func *func,\n\t\t\t   const struct drm_color_lut *lut, uint32_t lut_size,\n\t\t\t   bool has_rom)\n{\n\tstruct dc_gamma *gamma = NULL;\n\tstruct calculate_buffer cal_buffer = {0};\n\tbool res;\n\n\tASSERT(lut && lut_size == MAX_COLOR_LUT_ENTRIES);\n\n\tcal_buffer.buffer_index = -1;\n\n\tgamma = dc_create_gamma();\n\tif (!gamma)\n\t\treturn -ENOMEM;\n\n\tgamma->num_entries = lut_size;\n\t__drm_lut_to_dc_gamma(lut, gamma, false);\n\n\tif (func->tf == TRANSFER_FUNCTION_LINEAR) {\n\t\t \n\t\tgamma->type = GAMMA_CUSTOM;\n\t\tres = mod_color_calculate_degamma_params(NULL, func,\n\t\t\t\t\t\t\tgamma, true);\n\t} else {\n\t\t \n\t\tgamma->type = GAMMA_CS_TFM_1D;\n\t\tres = mod_color_calculate_regamma_params(func, gamma, false,\n\t\t\t\t\t\t\t has_rom, NULL, &cal_buffer);\n\t}\n\n\tdc_gamma_release(&gamma);\n\n\treturn res ? 0 : -ENOMEM;\n}\n\n \nstatic int __set_input_tf(struct dc_transfer_func *func,\n\t\t\t  const struct drm_color_lut *lut, uint32_t lut_size)\n{\n\tstruct dc_gamma *gamma = NULL;\n\tbool res;\n\n\tgamma = dc_create_gamma();\n\tif (!gamma)\n\t\treturn -ENOMEM;\n\n\tgamma->type = GAMMA_CUSTOM;\n\tgamma->num_entries = lut_size;\n\n\t__drm_lut_to_dc_gamma(lut, gamma, false);\n\n\tres = mod_color_calculate_degamma_params(NULL, func, gamma, true);\n\tdc_gamma_release(&gamma);\n\n\treturn res ? 0 : -ENOMEM;\n}\n\n \nint amdgpu_dm_verify_lut_sizes(const struct drm_crtc_state *crtc_state)\n{\n\tconst struct drm_color_lut *lut = NULL;\n\tuint32_t size = 0;\n\n\tlut = __extract_blob_lut(crtc_state->degamma_lut, &size);\n\tif (lut && size != MAX_COLOR_LUT_ENTRIES) {\n\t\tDRM_DEBUG_DRIVER(\n\t\t\t\"Invalid Degamma LUT size. Should be %u but got %u.\\n\",\n\t\t\tMAX_COLOR_LUT_ENTRIES, size);\n\t\treturn -EINVAL;\n\t}\n\n\tlut = __extract_blob_lut(crtc_state->gamma_lut, &size);\n\tif (lut && size != MAX_COLOR_LUT_ENTRIES &&\n\t    size != MAX_COLOR_LEGACY_LUT_ENTRIES) {\n\t\tDRM_DEBUG_DRIVER(\n\t\t\t\"Invalid Gamma LUT size. Should be %u (or %u for legacy) but got %u.\\n\",\n\t\t\tMAX_COLOR_LUT_ENTRIES, MAX_COLOR_LEGACY_LUT_ENTRIES,\n\t\t\tsize);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)\n{\n\tstruct dc_stream_state *stream = crtc->stream;\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->base.state->dev);\n\tbool has_rom = adev->asic_type <= CHIP_RAVEN;\n\tstruct drm_color_ctm *ctm = NULL;\n\tconst struct drm_color_lut *degamma_lut, *regamma_lut;\n\tuint32_t degamma_size, regamma_size;\n\tbool has_regamma, has_degamma;\n\tbool is_legacy;\n\tint r;\n\n\tr = amdgpu_dm_verify_lut_sizes(&crtc->base);\n\tif (r)\n\t\treturn r;\n\n\tdegamma_lut = __extract_blob_lut(crtc->base.degamma_lut, &degamma_size);\n\tregamma_lut = __extract_blob_lut(crtc->base.gamma_lut, &regamma_size);\n\n\thas_degamma =\n\t\tdegamma_lut && !__is_lut_linear(degamma_lut, degamma_size);\n\n\thas_regamma =\n\t\tregamma_lut && !__is_lut_linear(regamma_lut, regamma_size);\n\n\tis_legacy = regamma_size == MAX_COLOR_LEGACY_LUT_ENTRIES;\n\n\t \n\tcrtc->cm_has_degamma = false;\n\tcrtc->cm_is_degamma_srgb = false;\n\n\t \n\tif (is_legacy) {\n\t\t \n\t\tcrtc->cm_is_degamma_srgb = true;\n\t\tstream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;\n\t\tstream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;\n\n\t\tr = __set_legacy_tf(stream->out_transfer_func, regamma_lut,\n\t\t\t\t    regamma_size, has_rom);\n\t\tif (r)\n\t\t\treturn r;\n\t} else if (has_regamma) {\n\t\t \n\t\tstream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;\n\t\tstream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;\n\n\t\tr = __set_output_tf(stream->out_transfer_func, regamma_lut,\n\t\t\t\t    regamma_size, has_rom);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\t \n\t\tstream->out_transfer_func->type = TF_TYPE_BYPASS;\n\t\tstream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;\n\t}\n\n\t \n\tcrtc->cm_has_degamma = has_degamma;\n\n\t \n\tif (crtc->base.ctm) {\n\t\tctm = (struct drm_color_ctm *)crtc->base.ctm->data;\n\n\t\t \n\t\t__drm_ctm_to_dc_matrix(ctm, stream->gamut_remap_matrix.matrix);\n\n\t\tstream->gamut_remap_matrix.enable_remap = true;\n\t\tstream->csc_color_matrix.enable_adjustment = false;\n\t} else {\n\t\t \n\t\tstream->gamut_remap_matrix.enable_remap = false;\n\t\tstream->csc_color_matrix.enable_adjustment = false;\n\t}\n\n\treturn 0;\n}\n\n \nint amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,\n\t\t\t\t      struct dc_plane_state *dc_plane_state)\n{\n\tconst struct drm_color_lut *degamma_lut;\n\tenum dc_transfer_func_predefined tf = TRANSFER_FUNCTION_SRGB;\n\tuint32_t degamma_size;\n\tint r;\n\n\t \n\tswitch (dc_plane_state->format) {\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\t \n\t\ttf = TRANSFER_FUNCTION_BT709;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (crtc->cm_has_degamma) {\n\t\tdegamma_lut = __extract_blob_lut(crtc->base.degamma_lut,\n\t\t\t\t\t\t &degamma_size);\n\t\tASSERT(degamma_size == MAX_COLOR_LUT_ENTRIES);\n\n\t\tdc_plane_state->in_transfer_func->type =\n\t\t\tTF_TYPE_DISTRIBUTED_POINTS;\n\n\t\t \n\t\tif (crtc->cm_is_degamma_srgb)\n\t\t\tdc_plane_state->in_transfer_func->tf = tf;\n\t\telse\n\t\t\tdc_plane_state->in_transfer_func->tf =\n\t\t\t\tTRANSFER_FUNCTION_LINEAR;\n\n\t\tr = __set_input_tf(dc_plane_state->in_transfer_func,\n\t\t\t\t   degamma_lut, degamma_size);\n\t\tif (r)\n\t\t\treturn r;\n\t} else if (crtc->cm_is_degamma_srgb) {\n\t\t \n\t\tdc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;\n\t\tdc_plane_state->in_transfer_func->tf = tf;\n\n\t\tif (tf != TRANSFER_FUNCTION_SRGB &&\n\t\t    !mod_color_calculate_degamma_params(NULL,\n\t\t\t    dc_plane_state->in_transfer_func, NULL, false))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tdc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;\n\t\tdc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}