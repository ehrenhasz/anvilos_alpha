{
  "module_name": "amdgpu_dm_pp_smu.c",
  "hash_id": "43b8475526fba2335746748b9a7719f05be0559c5037bcf0188835ed700bbc6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c",
  "human_readable_source": " \n#include <linux/string.h>\n#include <linux/acpi.h>\n\n#include <drm/drm_probe_helper.h>\n#include <drm/amdgpu_drm.h>\n#include \"dm_services.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_dm.h\"\n#include \"amdgpu_dm_irq.h\"\n#include \"amdgpu_pm.h\"\n#include \"dm_pp_smu.h\"\n\nbool dm_pp_apply_display_requirements(\n\t\tconst struct dc_context *ctx,\n\t\tconst struct dm_pp_display_configuration *pp_display_cfg)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint i;\n\n\tif (adev->pm.dpm_enabled) {\n\n\t\tmemset(&adev->pm.pm_display_cfg, 0,\n\t\t\t\tsizeof(adev->pm.pm_display_cfg));\n\n\t\tadev->pm.pm_display_cfg.cpu_cc6_disable =\n\t\t\tpp_display_cfg->cpu_cc6_disable;\n\n\t\tadev->pm.pm_display_cfg.cpu_pstate_disable =\n\t\t\tpp_display_cfg->cpu_pstate_disable;\n\n\t\tadev->pm.pm_display_cfg.cpu_pstate_separation_time =\n\t\t\tpp_display_cfg->cpu_pstate_separation_time;\n\n\t\tadev->pm.pm_display_cfg.nb_pstate_switch_disable =\n\t\t\tpp_display_cfg->nb_pstate_switch_disable;\n\n\t\tadev->pm.pm_display_cfg.num_display =\n\t\t\t\tpp_display_cfg->display_count;\n\t\tadev->pm.pm_display_cfg.num_path_including_non_display =\n\t\t\t\tpp_display_cfg->display_count;\n\n\t\tadev->pm.pm_display_cfg.min_core_set_clock =\n\t\t\t\tpp_display_cfg->min_engine_clock_khz/10;\n\t\tadev->pm.pm_display_cfg.min_core_set_clock_in_sr =\n\t\t\t\tpp_display_cfg->min_engine_clock_deep_sleep_khz/10;\n\t\tadev->pm.pm_display_cfg.min_mem_set_clock =\n\t\t\t\tpp_display_cfg->min_memory_clock_khz/10;\n\n\t\tadev->pm.pm_display_cfg.min_dcef_deep_sleep_set_clk =\n\t\t\t\tpp_display_cfg->min_engine_clock_deep_sleep_khz/10;\n\t\tadev->pm.pm_display_cfg.min_dcef_set_clk =\n\t\t\t\tpp_display_cfg->min_dcfclock_khz/10;\n\n\t\tadev->pm.pm_display_cfg.multi_monitor_in_sync =\n\t\t\t\tpp_display_cfg->all_displays_in_sync;\n\t\tadev->pm.pm_display_cfg.min_vblank_time =\n\t\t\t\tpp_display_cfg->avail_mclk_switch_time_us;\n\n\t\tadev->pm.pm_display_cfg.display_clk =\n\t\t\t\tpp_display_cfg->disp_clk_khz/10;\n\n\t\tadev->pm.pm_display_cfg.dce_tolerable_mclk_in_active_latency =\n\t\t\t\tpp_display_cfg->avail_mclk_switch_time_in_disp_active_us;\n\n\t\tadev->pm.pm_display_cfg.crtc_index = pp_display_cfg->crtc_index;\n\t\tadev->pm.pm_display_cfg.line_time_in_us =\n\t\t\t\tpp_display_cfg->line_time_in_us;\n\n\t\tadev->pm.pm_display_cfg.vrefresh = pp_display_cfg->disp_configs[0].v_refresh;\n\t\tadev->pm.pm_display_cfg.crossfire_display_index = -1;\n\t\tadev->pm.pm_display_cfg.min_bus_bandwidth = 0;\n\n\t\tfor (i = 0; i < pp_display_cfg->display_count; i++) {\n\t\t\tconst struct dm_pp_single_disp_config *dc_cfg =\n\t\t\t\t\t\t&pp_display_cfg->disp_configs[i];\n\t\t\tadev->pm.pm_display_cfg.displays[i].controller_id = dc_cfg->pipe_idx + 1;\n\t\t}\n\n\t\tamdgpu_dpm_display_configuration_change(adev, &adev->pm.pm_display_cfg);\n\n\t\tamdgpu_dpm_compute_clocks(adev);\n\t}\n\n\treturn true;\n}\n\nstatic void get_default_clock_levels(\n\t\tenum dm_pp_clock_type clk_type,\n\t\tstruct dm_pp_clock_levels *clks)\n{\n\tuint32_t disp_clks_in_khz[6] = {\n\t\t\t300000, 400000, 496560, 626090, 685720, 757900 };\n\tuint32_t sclks_in_khz[6] = {\n\t\t\t300000, 360000, 423530, 514290, 626090, 720000 };\n\tuint32_t mclks_in_khz[2] = { 333000, 800000 };\n\n\tswitch (clk_type) {\n\tcase DM_PP_CLOCK_TYPE_DISPLAY_CLK:\n\t\tclks->num_levels = 6;\n\t\tmemmove(clks->clocks_in_khz, disp_clks_in_khz,\n\t\t\t\tsizeof(disp_clks_in_khz));\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_ENGINE_CLK:\n\t\tclks->num_levels = 6;\n\t\tmemmove(clks->clocks_in_khz, sclks_in_khz,\n\t\t\t\tsizeof(sclks_in_khz));\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_MEMORY_CLK:\n\t\tclks->num_levels = 2;\n\t\tmemmove(clks->clocks_in_khz, mclks_in_khz,\n\t\t\t\tsizeof(mclks_in_khz));\n\t\tbreak;\n\tdefault:\n\t\tclks->num_levels = 0;\n\t\tbreak;\n\t}\n}\n\nstatic enum amd_pp_clock_type dc_to_pp_clock_type(\n\t\tenum dm_pp_clock_type dm_pp_clk_type)\n{\n\tenum amd_pp_clock_type amd_pp_clk_type = 0;\n\n\tswitch (dm_pp_clk_type) {\n\tcase DM_PP_CLOCK_TYPE_DISPLAY_CLK:\n\t\tamd_pp_clk_type = amd_pp_disp_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_ENGINE_CLK:\n\t\tamd_pp_clk_type = amd_pp_sys_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_MEMORY_CLK:\n\t\tamd_pp_clk_type = amd_pp_mem_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_DCEFCLK:\n\t\tamd_pp_clk_type  = amd_pp_dcef_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_DCFCLK:\n\t\tamd_pp_clk_type = amd_pp_dcf_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_PIXELCLK:\n\t\tamd_pp_clk_type = amd_pp_pixel_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_FCLK:\n\t\tamd_pp_clk_type = amd_pp_f_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_DISPLAYPHYCLK:\n\t\tamd_pp_clk_type = amd_pp_phy_clock;\n\t\tbreak;\n\tcase DM_PP_CLOCK_TYPE_DPPCLK:\n\t\tamd_pp_clk_type = amd_pp_dpp_clock;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"DM_PPLIB: invalid clock type: %d!\\n\",\n\t\t\t\tdm_pp_clk_type);\n\t\tbreak;\n\t}\n\n\treturn amd_pp_clk_type;\n}\n\nstatic enum dm_pp_clocks_state pp_to_dc_powerlevel_state(\n\t\t\tenum PP_DAL_POWERLEVEL max_clocks_state)\n{\n\tswitch (max_clocks_state) {\n\tcase PP_DAL_POWERLEVEL_0:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_0;\n\tcase PP_DAL_POWERLEVEL_1:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_1;\n\tcase PP_DAL_POWERLEVEL_2:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_2;\n\tcase PP_DAL_POWERLEVEL_3:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_3;\n\tcase PP_DAL_POWERLEVEL_4:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_4;\n\tcase PP_DAL_POWERLEVEL_5:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_5;\n\tcase PP_DAL_POWERLEVEL_6:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_6;\n\tcase PP_DAL_POWERLEVEL_7:\n\t\treturn DM_PP_CLOCKS_DPM_STATE_LEVEL_7;\n\tdefault:\n\t\tDRM_ERROR(\"DM_PPLIB: invalid powerlevel state: %d!\\n\",\n\t\t\t\tmax_clocks_state);\n\t\treturn DM_PP_CLOCKS_STATE_INVALID;\n\t}\n}\n\nstatic void pp_to_dc_clock_levels(\n\t\tconst struct amd_pp_clocks *pp_clks,\n\t\tstruct dm_pp_clock_levels *dc_clks,\n\t\tenum dm_pp_clock_type dc_clk_type)\n{\n\tuint32_t i;\n\n\tif (pp_clks->count > DM_PP_MAX_CLOCK_LEVELS) {\n\t\tDRM_INFO(\"DM_PPLIB: Warning: %s clock: number of levels %d exceeds maximum of %d!\\n\",\n\t\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type),\n\t\t\t\tpp_clks->count,\n\t\t\t\tDM_PP_MAX_CLOCK_LEVELS);\n\n\t\tdc_clks->num_levels = DM_PP_MAX_CLOCK_LEVELS;\n\t} else\n\t\tdc_clks->num_levels = pp_clks->count;\n\n\tDRM_INFO(\"DM_PPLIB: values for %s clock\\n\",\n\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type));\n\n\tfor (i = 0; i < dc_clks->num_levels; i++) {\n\t\tDRM_INFO(\"DM_PPLIB:\\t %d\\n\", pp_clks->clock[i]);\n\t\tdc_clks->clocks_in_khz[i] = pp_clks->clock[i];\n\t}\n}\n\nstatic void pp_to_dc_clock_levels_with_latency(\n\t\tconst struct pp_clock_levels_with_latency *pp_clks,\n\t\tstruct dm_pp_clock_levels_with_latency *clk_level_info,\n\t\tenum dm_pp_clock_type dc_clk_type)\n{\n\tuint32_t i;\n\n\tif (pp_clks->num_levels > DM_PP_MAX_CLOCK_LEVELS) {\n\t\tDRM_INFO(\"DM_PPLIB: Warning: %s clock: number of levels %d exceeds maximum of %d!\\n\",\n\t\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type),\n\t\t\t\tpp_clks->num_levels,\n\t\t\t\tDM_PP_MAX_CLOCK_LEVELS);\n\n\t\tclk_level_info->num_levels = DM_PP_MAX_CLOCK_LEVELS;\n\t} else\n\t\tclk_level_info->num_levels = pp_clks->num_levels;\n\n\tDRM_DEBUG(\"DM_PPLIB: values for %s clock\\n\",\n\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type));\n\n\tfor (i = 0; i < clk_level_info->num_levels; i++) {\n\t\tDRM_DEBUG(\"DM_PPLIB:\\t %d in kHz\\n\", pp_clks->data[i].clocks_in_khz);\n\t\tclk_level_info->data[i].clocks_in_khz = pp_clks->data[i].clocks_in_khz;\n\t\tclk_level_info->data[i].latency_in_us = pp_clks->data[i].latency_in_us;\n\t}\n}\n\nstatic void pp_to_dc_clock_levels_with_voltage(\n\t\tconst struct pp_clock_levels_with_voltage *pp_clks,\n\t\tstruct dm_pp_clock_levels_with_voltage *clk_level_info,\n\t\tenum dm_pp_clock_type dc_clk_type)\n{\n\tuint32_t i;\n\n\tif (pp_clks->num_levels > DM_PP_MAX_CLOCK_LEVELS) {\n\t\tDRM_INFO(\"DM_PPLIB: Warning: %s clock: number of levels %d exceeds maximum of %d!\\n\",\n\t\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type),\n\t\t\t\tpp_clks->num_levels,\n\t\t\t\tDM_PP_MAX_CLOCK_LEVELS);\n\n\t\tclk_level_info->num_levels = DM_PP_MAX_CLOCK_LEVELS;\n\t} else\n\t\tclk_level_info->num_levels = pp_clks->num_levels;\n\n\tDRM_INFO(\"DM_PPLIB: values for %s clock\\n\",\n\t\t\tDC_DECODE_PP_CLOCK_TYPE(dc_clk_type));\n\n\tfor (i = 0; i < clk_level_info->num_levels; i++) {\n\t\tDRM_INFO(\"DM_PPLIB:\\t %d in kHz, %d in mV\\n\", pp_clks->data[i].clocks_in_khz,\n\t\t\t pp_clks->data[i].voltage_in_mv);\n\t\tclk_level_info->data[i].clocks_in_khz = pp_clks->data[i].clocks_in_khz;\n\t\tclk_level_info->data[i].voltage_in_mv = pp_clks->data[i].voltage_in_mv;\n\t}\n}\n\nbool dm_pp_get_clock_levels_by_type(\n\t\tconst struct dc_context *ctx,\n\t\tenum dm_pp_clock_type clk_type,\n\t\tstruct dm_pp_clock_levels *dc_clks)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct amd_pp_clocks pp_clks = { 0 };\n\tstruct amd_pp_simple_clock_info validation_clks = { 0 };\n\tuint32_t i;\n\n\tif (amdgpu_dpm_get_clock_by_type(adev,\n\t\tdc_to_pp_clock_type(clk_type), &pp_clks)) {\n\t\t \n\t\tget_default_clock_levels(clk_type, dc_clks);\n\t\treturn true;\n\t}\n\n\tpp_to_dc_clock_levels(&pp_clks, dc_clks, clk_type);\n\n\tif (amdgpu_dpm_get_display_mode_validation_clks(adev, &validation_clks)) {\n\t\t \n\t\tDRM_INFO(\"DM_PPLIB: Warning: using default validation clocks!\\n\");\n\t\tvalidation_clks.engine_max_clock = 72000;\n\t\tvalidation_clks.memory_max_clock = 80000;\n\t\tvalidation_clks.level = 0;\n\t}\n\n\tDRM_INFO(\"DM_PPLIB: Validation clocks:\\n\");\n\tDRM_INFO(\"DM_PPLIB:    engine_max_clock: %d\\n\",\n\t\t\tvalidation_clks.engine_max_clock);\n\tDRM_INFO(\"DM_PPLIB:    memory_max_clock: %d\\n\",\n\t\t\tvalidation_clks.memory_max_clock);\n\tDRM_INFO(\"DM_PPLIB:    level           : %d\\n\",\n\t\t\tvalidation_clks.level);\n\n\t \n\tvalidation_clks.engine_max_clock *= 10;\n\tvalidation_clks.memory_max_clock *= 10;\n\n\t \n\tif (clk_type == DM_PP_CLOCK_TYPE_ENGINE_CLK) {\n\t\tfor (i = 0; i < dc_clks->num_levels; i++) {\n\t\t\tif (dc_clks->clocks_in_khz[i] > validation_clks.engine_max_clock) {\n\t\t\t\t \n\t\t\t\tDRM_INFO(\"DM_PPLIB: reducing engine clock level from %d to %d\\n\",\n\t\t\t\t\t\tdc_clks->num_levels, i);\n\t\t\t\tdc_clks->num_levels = i > 0 ? i : 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (clk_type == DM_PP_CLOCK_TYPE_MEMORY_CLK) {\n\t\tfor (i = 0; i < dc_clks->num_levels; i++) {\n\t\t\tif (dc_clks->clocks_in_khz[i] > validation_clks.memory_max_clock) {\n\t\t\t\tDRM_INFO(\"DM_PPLIB: reducing memory clock level from %d to %d\\n\",\n\t\t\t\t\t\tdc_clks->num_levels, i);\n\t\t\t\tdc_clks->num_levels = i > 0 ? i : 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool dm_pp_get_clock_levels_by_type_with_latency(\n\tconst struct dc_context *ctx,\n\tenum dm_pp_clock_type clk_type,\n\tstruct dm_pp_clock_levels_with_latency *clk_level_info)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_clock_levels_with_latency pp_clks = { 0 };\n\tint ret;\n\n\tret = amdgpu_dpm_get_clock_by_type_with_latency(adev,\n\t\t\t\t\tdc_to_pp_clock_type(clk_type),\n\t\t\t\t\t&pp_clks);\n\tif (ret)\n\t\treturn false;\n\n\tpp_to_dc_clock_levels_with_latency(&pp_clks, clk_level_info, clk_type);\n\n\treturn true;\n}\n\nbool dm_pp_get_clock_levels_by_type_with_voltage(\n\tconst struct dc_context *ctx,\n\tenum dm_pp_clock_type clk_type,\n\tstruct dm_pp_clock_levels_with_voltage *clk_level_info)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_clock_levels_with_voltage pp_clk_info = {0};\n\tint ret;\n\n\tret = amdgpu_dpm_get_clock_by_type_with_voltage(adev,\n\t\t\t\t\tdc_to_pp_clock_type(clk_type),\n\t\t\t\t\t&pp_clk_info);\n\tif (ret)\n\t\treturn false;\n\n\tpp_to_dc_clock_levels_with_voltage(&pp_clk_info, clk_level_info, clk_type);\n\n\treturn true;\n}\n\nbool dm_pp_notify_wm_clock_changes(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\t \n\tif ((adev->asic_type >= CHIP_POLARIS10) &&\n\t    (adev->asic_type <= CHIP_VEGAM) &&\n\t    !amdgpu_dpm_set_watermarks_for_clocks_ranges(adev,\n\t\t\t\t\t\t\t (void *)wm_with_clock_ranges))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool dm_pp_apply_power_level_change_request(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_power_level_change_request *level_change_req)\n{\n\t \n\treturn false;\n}\n\nbool dm_pp_apply_clock_for_voltage_request(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_clock_for_voltage_req *clock_for_voltage_req)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_display_clock_request pp_clock_request = {0};\n\tint ret = 0;\n\n\tpp_clock_request.clock_type = dc_to_pp_clock_type(clock_for_voltage_req->clk_type);\n\tpp_clock_request.clock_freq_in_khz = clock_for_voltage_req->clocks_in_khz;\n\n\tif (!pp_clock_request.clock_type)\n\t\treturn false;\n\n\tret = amdgpu_dpm_display_clock_voltage_request(adev, &pp_clock_request);\n\tif (ret && (ret != -EOPNOTSUPP))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool dm_pp_get_static_clocks(\n\tconst struct dc_context *ctx,\n\tstruct dm_pp_static_clock_info *static_clk_info)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct amd_pp_clock_info pp_clk_info = {0};\n\n\tif (amdgpu_dpm_get_current_clocks(adev, &pp_clk_info))\n\t\treturn false;\n\n\tstatic_clk_info->max_clocks_state = pp_to_dc_powerlevel_state(pp_clk_info.max_clocks_state);\n\tstatic_clk_info->max_mclk_khz = pp_clk_info.max_memory_clock * 10;\n\tstatic_clk_info->max_sclk_khz = pp_clk_info.max_engine_clock * 10;\n\n\treturn true;\n}\n\nstatic void pp_rv_set_wm_ranges(struct pp_smu *pp,\n\t\tstruct pp_smu_wm_range_sets *ranges)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 wm_with_clock_ranges;\n\tstruct dm_pp_clock_range_for_dmif_wm_set_soc15 *wm_dce_clocks = wm_with_clock_ranges.wm_dmif_clocks_ranges;\n\tstruct dm_pp_clock_range_for_mcif_wm_set_soc15 *wm_soc_clocks = wm_with_clock_ranges.wm_mcif_clocks_ranges;\n\tint32_t i;\n\n\twm_with_clock_ranges.num_wm_dmif_sets = ranges->num_reader_wm_sets;\n\twm_with_clock_ranges.num_wm_mcif_sets = ranges->num_writer_wm_sets;\n\n\tfor (i = 0; i < wm_with_clock_ranges.num_wm_dmif_sets; i++) {\n\t\tif (ranges->reader_wm_sets[i].wm_inst > 3)\n\t\t\twm_dce_clocks[i].wm_set_id = WM_SET_A;\n\t\telse\n\t\t\twm_dce_clocks[i].wm_set_id =\n\t\t\t\t\tranges->reader_wm_sets[i].wm_inst;\n\t\twm_dce_clocks[i].wm_max_dcfclk_clk_in_khz =\n\t\t\t\tranges->reader_wm_sets[i].max_drain_clk_mhz * 1000;\n\t\twm_dce_clocks[i].wm_min_dcfclk_clk_in_khz =\n\t\t\t\tranges->reader_wm_sets[i].min_drain_clk_mhz * 1000;\n\t\twm_dce_clocks[i].wm_max_mem_clk_in_khz =\n\t\t\t\tranges->reader_wm_sets[i].max_fill_clk_mhz * 1000;\n\t\twm_dce_clocks[i].wm_min_mem_clk_in_khz =\n\t\t\t\tranges->reader_wm_sets[i].min_fill_clk_mhz * 1000;\n\t}\n\n\tfor (i = 0; i < wm_with_clock_ranges.num_wm_mcif_sets; i++) {\n\t\tif (ranges->writer_wm_sets[i].wm_inst > 3)\n\t\t\twm_soc_clocks[i].wm_set_id = WM_SET_A;\n\t\telse\n\t\t\twm_soc_clocks[i].wm_set_id =\n\t\t\t\t\tranges->writer_wm_sets[i].wm_inst;\n\t\twm_soc_clocks[i].wm_max_socclk_clk_in_khz =\n\t\t\t\tranges->writer_wm_sets[i].max_fill_clk_mhz * 1000;\n\t\twm_soc_clocks[i].wm_min_socclk_clk_in_khz =\n\t\t\t\tranges->writer_wm_sets[i].min_fill_clk_mhz * 1000;\n\t\twm_soc_clocks[i].wm_max_mem_clk_in_khz =\n\t\t\t\tranges->writer_wm_sets[i].max_drain_clk_mhz * 1000;\n\t\twm_soc_clocks[i].wm_min_mem_clk_in_khz =\n\t\t\t\tranges->writer_wm_sets[i].min_drain_clk_mhz * 1000;\n\t}\n\n\tamdgpu_dpm_set_watermarks_for_clocks_ranges(adev,\n\t\t\t\t\t\t    &wm_with_clock_ranges);\n}\n\nstatic void pp_rv_set_pme_wa_enable(struct pp_smu *pp)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_notify_smu_enable_pwe(adev);\n}\n\nstatic void pp_rv_set_active_display_count(struct pp_smu *pp, int count)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_active_display_count(adev, count);\n}\n\nstatic void pp_rv_set_min_deep_sleep_dcfclk(struct pp_smu *pp, int clock)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_min_deep_sleep_dcefclk(adev, clock);\n}\n\nstatic void pp_rv_set_hard_min_dcefclk_by_freq(struct pp_smu *pp, int clock)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_hard_min_dcefclk_by_freq(adev, clock);\n}\n\nstatic void pp_rv_set_hard_min_fclk_by_freq(struct pp_smu *pp, int mhz)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_hard_min_fclk_by_freq(adev, mhz);\n}\n\nstatic enum pp_smu_status pp_nv_set_wm_ranges(struct pp_smu *pp,\n\t\tstruct pp_smu_wm_range_sets *ranges)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_watermarks_for_clocks_ranges(adev, ranges);\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_set_display_count(struct pp_smu *pp, int count)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint ret = 0;\n\n\tret = amdgpu_dpm_set_active_display_count(adev, count);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\t \n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status\npp_nv_set_min_deep_sleep_dcfclk(struct pp_smu *pp, int mhz)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint ret = 0;\n\n\t \n\tret = amdgpu_dpm_set_min_deep_sleep_dcefclk(adev, mhz);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_set_hard_min_dcefclk_by_freq(\n\t\tstruct pp_smu *pp, int mhz)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tclock_req.clock_type = amd_pp_dcef_clock;\n\tclock_req.clock_freq_in_khz = mhz * 1000;\n\n\t \n\tret = amdgpu_dpm_display_clock_voltage_request(adev, &clock_req);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status\npp_nv_set_hard_min_uclk_by_freq(struct pp_smu *pp, int mhz)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tclock_req.clock_type = amd_pp_mem_clock;\n\tclock_req.clock_freq_in_khz = mhz * 1000;\n\n\t \n\tret = amdgpu_dpm_display_clock_voltage_request(adev, &clock_req);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_set_pstate_handshake_support(\n\tstruct pp_smu *pp, bool pstate_handshake_supported)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tif (amdgpu_dpm_display_disable_memory_clock_switch(adev,\n\t\t\t\t\t\t\t  !pstate_handshake_supported))\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_set_voltage_by_freq(struct pp_smu *pp,\n\t\tenum pp_smu_nv_clock_id clock_id, int mhz)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tswitch (clock_id) {\n\tcase PP_SMU_NV_DISPCLK:\n\t\tclock_req.clock_type = amd_pp_disp_clock;\n\t\tbreak;\n\tcase PP_SMU_NV_PHYCLK:\n\t\tclock_req.clock_type = amd_pp_phy_clock;\n\t\tbreak;\n\tcase PP_SMU_NV_PIXELCLK:\n\t\tclock_req.clock_type = amd_pp_pixel_clock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tclock_req.clock_freq_in_khz = mhz * 1000;\n\n\t \n\tret = amdgpu_dpm_display_clock_voltage_request(adev, &clock_req);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_get_maximum_sustainable_clocks(\n\t\tstruct pp_smu *pp, struct pp_smu_nv_clock_table *max_clocks)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint ret = 0;\n\n\tret = amdgpu_dpm_get_max_sustainable_clocks_by_dc(adev,\n\t\t\t\t\t\t\t  max_clocks);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_nv_get_uclk_dpm_states(struct pp_smu *pp,\n\t\tunsigned int *clock_values_in_khz, unsigned int *num_states)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint ret = 0;\n\n\tret = amdgpu_dpm_get_uclk_dpm_states(adev,\n\t\t\t\t\t     clock_values_in_khz,\n\t\t\t\t\t    num_states);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_rn_get_dpm_clock_table(\n\t\tstruct pp_smu *pp, struct dpm_clocks *clock_table)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tint ret = 0;\n\n\tret = amdgpu_dpm_get_dpm_clock_table(adev, clock_table);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn PP_SMU_RESULT_UNSUPPORTED;\n\telse if (ret)\n\t\treturn PP_SMU_RESULT_FAIL;\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nstatic enum pp_smu_status pp_rn_set_wm_ranges(struct pp_smu *pp,\n\t\tstruct pp_smu_wm_range_sets *ranges)\n{\n\tconst struct dc_context *ctx = pp->dm;\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\n\tamdgpu_dpm_set_watermarks_for_clocks_ranges(adev, ranges);\n\n\treturn PP_SMU_RESULT_OK;\n}\n\nvoid dm_pp_get_funcs(\n\t\tstruct dc_context *ctx,\n\t\tstruct pp_smu_funcs *funcs)\n{\n\tswitch (ctx->dce_version) {\n\tcase DCN_VERSION_1_0:\n\tcase DCN_VERSION_1_01:\n\t\tfuncs->ctx.ver = PP_SMU_VER_RV;\n\t\tfuncs->rv_funcs.pp_smu.dm = ctx;\n\t\tfuncs->rv_funcs.set_wm_ranges = pp_rv_set_wm_ranges;\n\t\tfuncs->rv_funcs.set_pme_wa_enable = pp_rv_set_pme_wa_enable;\n\t\tfuncs->rv_funcs.set_display_count =\n\t\t\t\tpp_rv_set_active_display_count;\n\t\tfuncs->rv_funcs.set_min_deep_sleep_dcfclk =\n\t\t\t\tpp_rv_set_min_deep_sleep_dcfclk;\n\t\tfuncs->rv_funcs.set_hard_min_dcfclk_by_freq =\n\t\t\t\tpp_rv_set_hard_min_dcefclk_by_freq;\n\t\tfuncs->rv_funcs.set_hard_min_fclk_by_freq =\n\t\t\t\tpp_rv_set_hard_min_fclk_by_freq;\n\t\tbreak;\n\tcase DCN_VERSION_2_0:\n\t\tfuncs->ctx.ver = PP_SMU_VER_NV;\n\t\tfuncs->nv_funcs.pp_smu.dm = ctx;\n\t\tfuncs->nv_funcs.set_display_count = pp_nv_set_display_count;\n\t\tfuncs->nv_funcs.set_hard_min_dcfclk_by_freq =\n\t\t\t\tpp_nv_set_hard_min_dcefclk_by_freq;\n\t\tfuncs->nv_funcs.set_min_deep_sleep_dcfclk =\n\t\t\t\tpp_nv_set_min_deep_sleep_dcfclk;\n\t\tfuncs->nv_funcs.set_voltage_by_freq =\n\t\t\t\tpp_nv_set_voltage_by_freq;\n\t\tfuncs->nv_funcs.set_wm_ranges = pp_nv_set_wm_ranges;\n\n\t\t \n\t\tfuncs->nv_funcs.set_pme_wa_enable = NULL;\n\t\t \n\t\tfuncs->nv_funcs.set_hard_min_uclk_by_freq = pp_nv_set_hard_min_uclk_by_freq;\n\t\t \n\t\tfuncs->nv_funcs.get_maximum_sustainable_clocks = pp_nv_get_maximum_sustainable_clocks;\n\t\t \n\t\tfuncs->nv_funcs.get_uclk_dpm_states = pp_nv_get_uclk_dpm_states;\n\t\tfuncs->nv_funcs.set_pstate_handshake_support = pp_nv_set_pstate_handshake_support;\n\t\tbreak;\n\n\tcase DCN_VERSION_2_1:\n\t\tfuncs->ctx.ver = PP_SMU_VER_RN;\n\t\tfuncs->rn_funcs.pp_smu.dm = ctx;\n\t\tfuncs->rn_funcs.set_wm_ranges = pp_rn_set_wm_ranges;\n\t\tfuncs->rn_funcs.get_dpm_clock_table = pp_rn_get_dpm_clock_table;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"smu version is not supported !\\n\");\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}