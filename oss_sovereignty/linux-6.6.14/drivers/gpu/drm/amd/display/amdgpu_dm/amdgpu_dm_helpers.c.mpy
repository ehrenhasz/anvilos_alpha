{
  "module_name": "amdgpu_dm_helpers.c",
  "hash_id": "83766ab8608a167cd194f8937350d62c6ee5f7585f148d5fe97479e079396e02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/amdgpu_drm.h>\n#include <drm/drm_edid.h>\n\n#include \"dm_services.h\"\n#include \"amdgpu.h\"\n#include \"dc.h\"\n#include \"amdgpu_dm.h\"\n#include \"amdgpu_dm_irq.h\"\n#include \"amdgpu_dm_mst_types.h\"\n#include \"dpcd_defs.h\"\n#include \"dc/inc/core_types.h\"\n\n#include \"dm_helpers.h\"\n#include \"ddc_service_types.h\"\n\nstatic u32 edid_extract_panel_id(struct edid *edid)\n{\n\treturn (u32)edid->mfg_id[0] << 24   |\n\t       (u32)edid->mfg_id[1] << 16   |\n\t       (u32)EDID_PRODUCT_ID(edid);\n}\n\nstatic void apply_edid_quirks(struct edid *edid, struct dc_edid_caps *edid_caps)\n{\n\tuint32_t panel_id = edid_extract_panel_id(edid);\n\n\tswitch (panel_id) {\n\t \n\tcase drm_edid_encode_panel_id('S', 'A', 'M', 0x0E5E):\n\tcase drm_edid_encode_panel_id('S', 'A', 'M', 0x7053):\n\tcase drm_edid_encode_panel_id('S', 'A', 'M', 0x71AC):\n\t\tDRM_DEBUG_DRIVER(\"Disabling FAMS on monitor with panel id %X\\n\", panel_id);\n\t\tedid_caps->panel_patch.disable_fams = true;\n\t\tbreak;\n\t \n\tcase drm_edid_encode_panel_id('A', 'U', 'O', 0xA7AB):\n\tcase drm_edid_encode_panel_id('A', 'U', 'O', 0xE69B):\n\t\tDRM_DEBUG_DRIVER(\"Clearing DPCD 0x317 on monitor with panel id %X\\n\", panel_id);\n\t\tedid_caps->panel_patch.remove_sink_ext_caps = true;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nenum dc_edid_status dm_helpers_parse_edid_caps(\n\t\tstruct dc_link *link,\n\t\tconst struct dc_edid *edid,\n\t\tstruct dc_edid_caps *edid_caps)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct edid *edid_buf = edid ? (struct edid *) edid->raw_edid : NULL;\n\tstruct cea_sad *sads;\n\tint sad_count = -1;\n\tint sadb_count = -1;\n\tint i = 0;\n\tuint8_t *sadb = NULL;\n\n\tenum dc_edid_status result = EDID_OK;\n\n\tif (!edid_caps || !edid)\n\t\treturn EDID_BAD_INPUT;\n\n\tif (!drm_edid_is_valid(edid_buf))\n\t\tresult = EDID_BAD_CHECKSUM;\n\n\tedid_caps->manufacturer_id = (uint16_t) edid_buf->mfg_id[0] |\n\t\t\t\t\t((uint16_t) edid_buf->mfg_id[1])<<8;\n\tedid_caps->product_id = (uint16_t) edid_buf->prod_code[0] |\n\t\t\t\t\t((uint16_t) edid_buf->prod_code[1])<<8;\n\tedid_caps->serial_number = edid_buf->serial;\n\tedid_caps->manufacture_week = edid_buf->mfg_week;\n\tedid_caps->manufacture_year = edid_buf->mfg_year;\n\n\tdrm_edid_get_monitor_name(edid_buf,\n\t\t\t\t  edid_caps->display_name,\n\t\t\t\t  AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);\n\n\tedid_caps->edid_hdmi = connector->display_info.is_hdmi;\n\n\tsad_count = drm_edid_to_sad((struct edid *) edid->raw_edid, &sads);\n\tif (sad_count <= 0)\n\t\treturn result;\n\n\tedid_caps->audio_mode_count = min(sad_count, DC_MAX_AUDIO_DESC_COUNT);\n\tfor (i = 0; i < edid_caps->audio_mode_count; ++i) {\n\t\tstruct cea_sad *sad = &sads[i];\n\n\t\tedid_caps->audio_modes[i].format_code = sad->format;\n\t\tedid_caps->audio_modes[i].channel_count = sad->channels + 1;\n\t\tedid_caps->audio_modes[i].sample_rate = sad->freq;\n\t\tedid_caps->audio_modes[i].sample_size = sad->byte2;\n\t}\n\n\tsadb_count = drm_edid_to_speaker_allocation((struct edid *) edid->raw_edid, &sadb);\n\n\tif (sadb_count < 0) {\n\t\tDRM_ERROR(\"Couldn't read Speaker Allocation Data Block: %d\\n\", sadb_count);\n\t\tsadb_count = 0;\n\t}\n\n\tif (sadb_count)\n\t\tedid_caps->speaker_flags = sadb[0];\n\telse\n\t\tedid_caps->speaker_flags = DEFAULT_SPEAKER_LOCATION;\n\n\tapply_edid_quirks(edid_buf, edid_caps);\n\n\tkfree(sads);\n\tkfree(sadb);\n\n\treturn result;\n}\n\nstatic void\nfill_dc_mst_payload_table_from_drm(struct dc_link *link,\n\t\t\t\t   bool enable,\n\t\t\t\t   struct drm_dp_mst_atomic_payload *target_payload,\n\t\t\t\t   struct dc_dp_mst_stream_allocation_table *table)\n{\n\tstruct dc_dp_mst_stream_allocation_table new_table = { 0 };\n\tstruct dc_dp_mst_stream_allocation *sa;\n\tstruct link_mst_stream_allocation_table copy_of_link_table =\n\t\t\t\t\t\t\t\t\t\tlink->mst_stream_alloc_table;\n\n\tint i;\n\tint current_hw_table_stream_cnt = copy_of_link_table.stream_count;\n\tstruct link_mst_stream_allocation *dc_alloc;\n\n\t \n\tif (enable) {\n\t\tdc_alloc =\n\t\t&copy_of_link_table.stream_allocations[current_hw_table_stream_cnt];\n\t\tdc_alloc->vcp_id = target_payload->vcpi;\n\t\tdc_alloc->slot_count = target_payload->time_slots;\n\t} else {\n\t\tfor (i = 0; i < copy_of_link_table.stream_count; i++) {\n\t\t\tdc_alloc =\n\t\t\t&copy_of_link_table.stream_allocations[i];\n\n\t\t\tif (dc_alloc->vcp_id == target_payload->vcpi) {\n\t\t\t\tdc_alloc->vcp_id = 0;\n\t\t\t\tdc_alloc->slot_count = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tASSERT(i != copy_of_link_table.stream_count);\n\t}\n\n\t \n\tfor (i = 0; i < MAX_CONTROLLER_NUM; i++) {\n\t\tdc_alloc =\n\t\t\t&copy_of_link_table.stream_allocations[i];\n\t\tif (dc_alloc->vcp_id > 0 && dc_alloc->slot_count > 0) {\n\t\t\tsa = &new_table.stream_allocations[new_table.stream_count];\n\t\t\tsa->slot_count = dc_alloc->slot_count;\n\t\t\tsa->vcp_id = dc_alloc->vcp_id;\n\t\t\tnew_table.stream_count++;\n\t\t}\n\t}\n\n\t \n\t*table = new_table;\n}\n\nvoid dm_helpers_dp_update_branch_info(\n\tstruct dc_context *ctx,\n\tconst struct dc_link *link)\n{}\n\nstatic void dm_helpers_construct_old_payload(\n\t\t\tstruct dc_link *link,\n\t\t\tint pbn_per_slot,\n\t\t\tstruct drm_dp_mst_atomic_payload *new_payload,\n\t\t\tstruct drm_dp_mst_atomic_payload *old_payload)\n{\n\tstruct link_mst_stream_allocation_table current_link_table =\n\t\t\t\t\t\t\t\t\tlink->mst_stream_alloc_table;\n\tstruct link_mst_stream_allocation *dc_alloc;\n\tint i;\n\n\t*old_payload = *new_payload;\n\n\t \n\tfor (i = 0; i < current_link_table.stream_count; i++) {\n\t\tdc_alloc =\n\t\t\t&current_link_table.stream_allocations[i];\n\n\t\tif (dc_alloc->vcp_id == new_payload->vcpi) {\n\t\t\told_payload->time_slots = dc_alloc->slot_count;\n\t\t\told_payload->pbn = dc_alloc->slot_count * pbn_per_slot;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tASSERT(i != current_link_table.stream_count);\n\n}\n\n \nbool dm_helpers_dp_mst_write_payload_allocation_table(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct dc_dp_mst_stream_allocation_table *proposed_table,\n\t\tbool enable)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct drm_dp_mst_atomic_payload *target_payload, *new_payload, old_payload;\n\tstruct drm_dp_mst_topology_mgr *mst_mgr;\n\n\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\t \n\n\tif (!aconnector || !aconnector->mst_root)\n\t\treturn false;\n\n\tmst_mgr = &aconnector->mst_root->mst_mgr;\n\tmst_state = to_drm_dp_mst_topology_state(mst_mgr->base.state);\n\n\t \n\tnew_payload = drm_atomic_get_mst_payload_state(mst_state, aconnector->mst_output_port);\n\n\tif (enable) {\n\t\ttarget_payload = new_payload;\n\n\t\tdrm_dp_add_payload_part1(mst_mgr, mst_state, new_payload);\n\t} else {\n\t\t \n\t\tdm_helpers_construct_old_payload(stream->link, mst_state->pbn_div,\n\t\t\t\t\t\tnew_payload, &old_payload);\n\t\ttarget_payload = &old_payload;\n\n\t\tdrm_dp_remove_payload(mst_mgr, mst_state, &old_payload, new_payload);\n\t}\n\n\t \n\tfill_dc_mst_payload_table_from_drm(stream->link, enable, target_payload, proposed_table);\n\n\treturn true;\n}\n\n \nvoid dm_helpers_dp_mst_poll_pending_down_reply(\n\tstruct dc_context *ctx,\n\tconst struct dc_link *link)\n{}\n\n \nvoid dm_helpers_dp_mst_clear_payload_allocation_table(\n\tstruct dc_context *ctx,\n\tconst struct dc_link *link)\n{}\n\n \nenum act_return_status dm_helpers_dp_mst_poll_for_allocation_change_trigger(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_dp_mst_topology_mgr *mst_mgr;\n\tint ret;\n\n\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\n\tif (!aconnector || !aconnector->mst_root)\n\t\treturn ACT_FAILED;\n\n\tmst_mgr = &aconnector->mst_root->mst_mgr;\n\n\tif (!mst_mgr->mst_state)\n\t\treturn ACT_FAILED;\n\n\tret = drm_dp_check_act_status(mst_mgr);\n\n\tif (ret)\n\t\treturn ACT_FAILED;\n\n\treturn ACT_SUCCESS;\n}\n\nbool dm_helpers_dp_mst_send_payload_allocation(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream,\n\t\tbool enable)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct drm_dp_mst_topology_mgr *mst_mgr;\n\tstruct drm_dp_mst_atomic_payload *payload;\n\tenum mst_progress_status set_flag = MST_ALLOCATE_NEW_PAYLOAD;\n\tenum mst_progress_status clr_flag = MST_CLEAR_ALLOCATED_PAYLOAD;\n\tint ret = 0;\n\n\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\n\tif (!aconnector || !aconnector->mst_root)\n\t\treturn false;\n\n\tmst_mgr = &aconnector->mst_root->mst_mgr;\n\tmst_state = to_drm_dp_mst_topology_state(mst_mgr->base.state);\n\n\tpayload = drm_atomic_get_mst_payload_state(mst_state, aconnector->mst_output_port);\n\n\tif (!enable) {\n\t\tset_flag = MST_CLEAR_ALLOCATED_PAYLOAD;\n\t\tclr_flag = MST_ALLOCATE_NEW_PAYLOAD;\n\t}\n\n\tif (enable)\n\t\tret = drm_dp_add_payload_part2(mst_mgr, mst_state->base.state, payload);\n\n\tif (ret) {\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tset_flag, false);\n\t} else {\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tset_flag, true);\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tclr_flag, false);\n\t}\n\n\treturn true;\n}\n\nvoid dm_dtn_log_begin(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx)\n{\n\tstatic const char msg[] = \"[dtn begin]\\n\";\n\n\tif (!log_ctx) {\n\t\tpr_info(\"%s\", msg);\n\t\treturn;\n\t}\n\n\tdm_dtn_log_append_v(ctx, log_ctx, \"%s\", msg);\n}\n\n__printf(3, 4)\nvoid dm_dtn_log_append_v(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx,\n\tconst char *msg, ...)\n{\n\tva_list args;\n\tsize_t total;\n\tint n;\n\n\tif (!log_ctx) {\n\t\t \n\t\tstruct va_format vaf;\n\n\t\tvaf.fmt = msg;\n\t\tvaf.va = &args;\n\n\t\tva_start(args, msg);\n\t\tpr_info(\"%pV\", &vaf);\n\t\tva_end(args);\n\n\t\treturn;\n\t}\n\n\t \n\tva_start(args, msg);\n\tn = vsnprintf(NULL, 0, msg, args);\n\tva_end(args);\n\n\tif (n <= 0)\n\t\treturn;\n\n\t \n\ttotal = log_ctx->pos + n + 1;\n\n\tif (total > log_ctx->size) {\n\t\tchar *buf = kvcalloc(total, sizeof(char), GFP_KERNEL);\n\n\t\tif (buf) {\n\t\t\tmemcpy(buf, log_ctx->buf, log_ctx->pos);\n\t\t\tkfree(log_ctx->buf);\n\n\t\t\tlog_ctx->buf = buf;\n\t\t\tlog_ctx->size = total;\n\t\t}\n\t}\n\n\tif (!log_ctx->buf)\n\t\treturn;\n\n\t \n\tva_start(args, msg);\n\tn = vscnprintf(\n\t\tlog_ctx->buf + log_ctx->pos,\n\t\tlog_ctx->size - log_ctx->pos,\n\t\tmsg,\n\t\targs);\n\tva_end(args);\n\n\tif (n > 0)\n\t\tlog_ctx->pos += n;\n}\n\nvoid dm_dtn_log_end(struct dc_context *ctx,\n\tstruct dc_log_buffer_ctx *log_ctx)\n{\n\tstatic const char msg[] = \"[dtn end]\\n\";\n\n\tif (!log_ctx) {\n\t\tpr_info(\"%s\", msg);\n\t\treturn;\n\t}\n\n\tdm_dtn_log_append_v(ctx, log_ctx, \"%s\", msg);\n}\n\nbool dm_helpers_dp_mst_start_top_mgr(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tbool boot)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tint ret;\n\n\tif (!aconnector) {\n\t\tDRM_ERROR(\"Failed to find connector for link!\");\n\t\treturn false;\n\t}\n\n\tif (boot) {\n\t\tDRM_INFO(\"DM_MST: Differing MST start on aconnector: %p [id: %d]\\n\",\n\t\t\t\t\taconnector, aconnector->base.base.id);\n\t\treturn true;\n\t}\n\n\tDRM_INFO(\"DM_MST: starting TM on aconnector: %p [id: %d]\\n\",\n\t\t\taconnector, aconnector->base.base.id);\n\n\tret = drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"DM_MST: Failed to set the device into MST mode!\");\n\t\treturn false;\n\t}\n\n\tDRM_INFO(\"DM_MST: DP%x, %d-lane link detected\\n\", aconnector->mst_mgr.dpcd[0],\n\t\taconnector->mst_mgr.dpcd[2] & DP_MAX_LANE_COUNT_MASK);\n\n\treturn true;\n}\n\nbool dm_helpers_dp_mst_stop_top_mgr(\n\t\tstruct dc_context *ctx,\n\t\tstruct dc_link *link)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\n\tif (!aconnector) {\n\t\tDRM_ERROR(\"Failed to find connector for link!\");\n\t\treturn false;\n\t}\n\n\tDRM_INFO(\"DM_MST: stopping TM on aconnector: %p [id: %d]\\n\",\n\t\t\taconnector, aconnector->base.base.id);\n\n\tif (aconnector->mst_mgr.mst_state == true) {\n\t\tdrm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, false);\n\t\tlink->cur_link_settings.lane_count = 0;\n\t}\n\n\treturn false;\n}\n\nbool dm_helpers_dp_read_dpcd(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tuint32_t address,\n\t\tuint8_t *data,\n\t\tuint32_t size)\n{\n\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\n\tif (!aconnector) {\n\t\tDC_LOG_DC(\"Failed to find connector for link!\\n\");\n\t\treturn false;\n\t}\n\n\treturn drm_dp_dpcd_read(&aconnector->dm_dp_aux.aux, address, data,\n\t\t\t\tsize) == size;\n}\n\nbool dm_helpers_dp_write_dpcd(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tuint32_t address,\n\t\tconst uint8_t *data,\n\t\tuint32_t size)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\n\tif (!aconnector) {\n\t\tDRM_ERROR(\"Failed to find connector for link!\");\n\t\treturn false;\n\t}\n\n\treturn drm_dp_dpcd_write(&aconnector->dm_dp_aux.aux,\n\t\t\taddress, (uint8_t *)data, size) > 0;\n}\n\nbool dm_helpers_submit_i2c(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tstruct i2c_command *cmd)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tstruct i2c_msg *msgs;\n\tint i = 0;\n\tint num = cmd->number_of_payloads;\n\tbool result;\n\n\tif (!aconnector) {\n\t\tDRM_ERROR(\"Failed to find connector for link!\");\n\t\treturn false;\n\t}\n\n\tmsgs = kcalloc(num, sizeof(struct i2c_msg), GFP_KERNEL);\n\n\tif (!msgs)\n\t\treturn false;\n\n\tfor (i = 0; i < num; i++) {\n\t\tmsgs[i].flags = cmd->payloads[i].write ? 0 : I2C_M_RD;\n\t\tmsgs[i].addr = cmd->payloads[i].address;\n\t\tmsgs[i].len = cmd->payloads[i].length;\n\t\tmsgs[i].buf = cmd->payloads[i].data;\n\t}\n\n\tresult = i2c_transfer(&aconnector->i2c->base, msgs, num) == num;\n\n\tkfree(msgs);\n\n\treturn result;\n}\n\nstatic bool execute_synaptics_rc_command(struct drm_dp_aux *aux,\n\t\tbool is_write_cmd,\n\t\tunsigned char cmd,\n\t\tunsigned int length,\n\t\tunsigned int offset,\n\t\tunsigned char *data)\n{\n\tbool success = false;\n\tunsigned char rc_data[16] = {0};\n\tunsigned char rc_offset[4] = {0};\n\tunsigned char rc_length[2] = {0};\n\tunsigned char rc_cmd = 0;\n\tunsigned char rc_result = 0xFF;\n\tunsigned char i = 0;\n\tint ret;\n\n\tif (is_write_cmd) {\n\t\t\n\t\tmemmove(rc_data, data, length);\n\t\tret = drm_dp_dpcd_write(aux, SYNAPTICS_RC_DATA, rc_data, sizeof(rc_data));\n\t}\n\n\t\n\trc_offset[0] = (unsigned char) offset & 0xFF;\n\trc_offset[1] = (unsigned char) (offset >> 8) & 0xFF;\n\trc_offset[2] = (unsigned char) (offset >> 16) & 0xFF;\n\trc_offset[3] = (unsigned char) (offset >> 24) & 0xFF;\n\tret = drm_dp_dpcd_write(aux, SYNAPTICS_RC_OFFSET, rc_offset, sizeof(rc_offset));\n\n\t\n\trc_length[0] = (unsigned char) length & 0xFF;\n\trc_length[1] = (unsigned char) (length >> 8) & 0xFF;\n\tret = drm_dp_dpcd_write(aux, SYNAPTICS_RC_LENGTH, rc_length, sizeof(rc_length));\n\n\t\n\trc_cmd = cmd | 0x80;\n\tret = drm_dp_dpcd_write(aux, SYNAPTICS_RC_COMMAND, &rc_cmd, sizeof(rc_cmd));\n\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"%s: write cmd ..., err = %d\\n\",  __func__, ret);\n\t\treturn false;\n\t}\n\n\t\n\tfor (i = 0; i < 10; i++) {\n\t\tdrm_dp_dpcd_read(aux, SYNAPTICS_RC_COMMAND, &rc_cmd, sizeof(rc_cmd));\n\t\tif (rc_cmd == cmd)\n\t\t\t\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\t\n\tdrm_dp_dpcd_read(aux, SYNAPTICS_RC_RESULT, &rc_result, sizeof(rc_result));\n\tsuccess = (rc_result == 0);\n\n\tif (success && !is_write_cmd) {\n\t\t\n\t\tdrm_dp_dpcd_read(aux, SYNAPTICS_RC_DATA, data, length);\n\t}\n\n\tDC_LOG_DC(\"%s: success = %d\\n\", __func__, success);\n\n\treturn success;\n}\n\nstatic void apply_synaptics_fifo_reset_wa(struct drm_dp_aux *aux)\n{\n\tunsigned char data[16] = {0};\n\n\tDC_LOG_DC(\"Start %s\\n\", __func__);\n\n\t\n\tdata[0] = 'P';\n\tdata[1] = 'R';\n\tdata[2] = 'I';\n\tdata[3] = 'U';\n\tdata[4] = 'S';\n\n\tif (!execute_synaptics_rc_command(aux, true, 0x01, 5, 0, data))\n\t\treturn;\n\n\t\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x220998, data))\n\t\treturn;\n\n\tdata[0] &= (~(1 << 1)); \n\tif (!execute_synaptics_rc_command(aux, true, 0x21, 4, 0x220998, data))\n\t\treturn;\n\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x220D98, data))\n\t\treturn;\n\n\tdata[0] &= (~(1 << 1)); \n\tif (!execute_synaptics_rc_command(aux, true, 0x21, 4, 0x220D98, data))\n\t\treturn;\n\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x221198, data))\n\t\treturn;\n\n\tdata[0] &= (~(1 << 1)); \n\tif (!execute_synaptics_rc_command(aux, true, 0x21, 4, 0x221198, data))\n\t\treturn;\n\n\t\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x220998, data))\n\t\treturn;\n\n\tdata[0] |= (1 << 1); \n\tif (!execute_synaptics_rc_command(aux, true, 0x21, 4, 0x220998, data))\n\t\treturn;\n\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x220D98, data))\n\t\treturn;\n\n\tdata[0] |= (1 << 1); \n\n\tif (!execute_synaptics_rc_command(aux, false, 0x31, 4, 0x221198, data))\n\t\treturn;\n\n\tdata[0] |= (1 << 1); \n\tif (!execute_synaptics_rc_command(aux, true, 0x21, 4, 0x221198, data))\n\t\treturn;\n\n\t\n\tif (!execute_synaptics_rc_command(aux, true, 0x02, 0, 0, NULL))\n\t\treturn;\n\n\tDC_LOG_DC(\"Done %s\\n\", __func__);\n}\n\n \nstatic const uint8_t SYNAPTICS_DEVICE_ID[] = \"SYNA\";\n\nstatic uint8_t write_dsc_enable_synaptics_non_virtual_dpcd_mst(\n\t\tstruct drm_dp_aux *aux,\n\t\tconst struct dc_stream_state *stream,\n\t\tbool enable)\n{\n\tuint8_t ret = 0;\n\n\tDC_LOG_DC(\"Configure DSC to non-virtual dpcd synaptics\\n\");\n\n\tif (enable) {\n\t\t \n\t\tif (!stream->link->link_status.link_active &&\n\t\t\tmemcmp(stream->link->dpcd_caps.branch_dev_name,\n\t\t\t\t(int8_t *)SYNAPTICS_DEVICE_ID, 4) == 0)\n\t\t\tapply_synaptics_fifo_reset_wa(aux);\n\n\t\tret = drm_dp_dpcd_write(aux, DP_DSC_ENABLE, &enable, 1);\n\t\tDRM_INFO(\"Send DSC enable to synaptics\\n\");\n\n\t} else {\n\t\t \n\t\tif (!stream->link->link_status.link_active) {\n\t\t\tret = drm_dp_dpcd_write(aux, DP_DSC_ENABLE, &enable, 1);\n\t\t\tDRM_INFO(\"Send DSC disable to synaptics\\n\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool dm_helpers_dp_write_dsc_enable(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream,\n\t\tbool enable)\n{\n\tstatic const uint8_t DSC_DISABLE;\n\tstatic const uint8_t DSC_DECODING = 0x01;\n\tstatic const uint8_t DSC_PASSTHROUGH = 0x02;\n\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_dp_mst_port *port;\n\tuint8_t enable_dsc = enable ? DSC_DECODING : DSC_DISABLE;\n\tuint8_t enable_passthrough = enable ? DSC_PASSTHROUGH : DSC_DISABLE;\n\tuint8_t ret = 0;\n\n\tif (!stream)\n\t\treturn false;\n\n\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\n\t\tif (!aconnector->dsc_aux)\n\t\t\treturn false;\n\n\t\t\n\t\tif (needs_dsc_aux_workaround(aconnector->dc_link) &&\n\t\t    (aconnector->mst_downstream_port_present.byte & 0x7) != 0x3)\n\t\t\treturn write_dsc_enable_synaptics_non_virtual_dpcd_mst(\n\t\t\t\taconnector->dsc_aux, stream, enable_dsc);\n\n\t\tport = aconnector->mst_output_port;\n\n\t\tif (enable) {\n\t\t\tif (port->passthrough_aux) {\n\t\t\t\tret = drm_dp_dpcd_write(port->passthrough_aux,\n\t\t\t\t\t\t\tDP_DSC_ENABLE,\n\t\t\t\t\t\t\t&enable_passthrough, 1);\n\t\t\t\tDC_LOG_DC(\"Sent DSC pass-through enable to virtual dpcd port, ret = %u\\n\",\n\t\t\t\t\t  ret);\n\t\t\t}\n\n\t\t\tret = drm_dp_dpcd_write(aconnector->dsc_aux,\n\t\t\t\t\t\tDP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tDC_LOG_DC(\"Sent DSC decoding enable to %s port, ret = %u\\n\",\n\t\t\t\t  (port->passthrough_aux) ? \"remote RX\" :\n\t\t\t\t  \"virtual dpcd\",\n\t\t\t\t  ret);\n\t\t} else {\n\t\t\tret = drm_dp_dpcd_write(aconnector->dsc_aux,\n\t\t\t\t\t\tDP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tDC_LOG_DC(\"Sent DSC decoding disable to %s port, ret = %u\\n\",\n\t\t\t\t  (port->passthrough_aux) ? \"remote RX\" :\n\t\t\t\t  \"virtual dpcd\",\n\t\t\t\t  ret);\n\n\t\t\tif (port->passthrough_aux) {\n\t\t\t\tret = drm_dp_dpcd_write(port->passthrough_aux,\n\t\t\t\t\t\t\tDP_DSC_ENABLE,\n\t\t\t\t\t\t\t&enable_passthrough, 1);\n\t\t\t\tDC_LOG_DC(\"Sent DSC pass-through disable to virtual dpcd port, ret = %u\\n\",\n\t\t\t\t\t  ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT || stream->signal == SIGNAL_TYPE_EDP) {\n\t\tif (stream->sink->link->dpcd_caps.dongle_type == DISPLAY_DONGLE_NONE) {\n\t\t\tret = dm_helpers_dp_write_dpcd(ctx, stream->link, DP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tDC_LOG_DC(\"Send DSC %s to SST RX\\n\", enable_dsc ? \"enable\" : \"disable\");\n\t\t} else if (stream->sink->link->dpcd_caps.dongle_type == DISPLAY_DONGLE_DP_HDMI_CONVERTER) {\n\t\t\tret = dm_helpers_dp_write_dpcd(ctx, stream->link, DP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tDC_LOG_DC(\"Send DSC %s to DP-HDMI PCON\\n\", enable_dsc ? \"enable\" : \"disable\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool dm_helpers_is_dp_sink_present(struct dc_link *link)\n{\n\tbool dp_sink_present;\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\n\tif (!aconnector) {\n\t\tBUG_ON(\"Failed to find connector for link!\");\n\t\treturn true;\n\t}\n\n\tmutex_lock(&aconnector->dm_dp_aux.aux.hw_mutex);\n\tdp_sink_present = dc_link_is_dp_sink_present(link);\n\tmutex_unlock(&aconnector->dm_dp_aux.aux.hw_mutex);\n\treturn dp_sink_present;\n}\n\nenum dc_edid_status dm_helpers_read_local_edid(\n\t\tstruct dc_context *ctx,\n\t\tstruct dc_link *link,\n\t\tstruct dc_sink *sink)\n{\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct i2c_adapter *ddc;\n\tint retry = 3;\n\tenum dc_edid_status edid_status;\n\tstruct edid *edid;\n\n\tif (link->aux_mode)\n\t\tddc = &aconnector->dm_dp_aux.aux.ddc;\n\telse\n\t\tddc = &aconnector->i2c->base;\n\n\t \n\tdo {\n\n\t\tedid = drm_get_edid(&aconnector->base, ddc);\n\n\t\t \n\t\tif (link->aux_mode && connector->edid_corrupt)\n\t\t\tdrm_dp_send_real_edid_checksum(&aconnector->dm_dp_aux.aux, connector->real_edid_checksum);\n\n\t\tif (!edid && connector->edid_corrupt) {\n\t\t\tconnector->edid_corrupt = false;\n\t\t\treturn EDID_BAD_CHECKSUM;\n\t\t}\n\n\t\tif (!edid)\n\t\t\treturn EDID_NO_RESPONSE;\n\n\t\tsink->dc_edid.length = EDID_LENGTH * (edid->extensions + 1);\n\t\tmemmove(sink->dc_edid.raw_edid, (uint8_t *)edid, sink->dc_edid.length);\n\n\t\t \n\t\tkfree(edid);\n\n\t\tedid_status = dm_helpers_parse_edid_caps(\n\t\t\t\t\t\tlink,\n\t\t\t\t\t\t&sink->dc_edid,\n\t\t\t\t\t\t&sink->edid_caps);\n\n\t} while (edid_status == EDID_BAD_CHECKSUM && --retry > 0);\n\n\tif (edid_status != EDID_OK)\n\t\tDRM_ERROR(\"EDID err: %d, on connector: %s\",\n\t\t\t\tedid_status,\n\t\t\t\taconnector->base.name);\n\tif (link->aux_mode) {\n\t\tunion test_request test_request = {0};\n\t\tunion test_response test_response = {0};\n\n\t\tdm_helpers_dp_read_dpcd(ctx,\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_TEST_REQUEST,\n\t\t\t\t\t&test_request.raw,\n\t\t\t\t\tsizeof(union test_request));\n\n\t\tif (!test_request.bits.EDID_READ)\n\t\t\treturn edid_status;\n\n\t\ttest_response.bits.EDID_CHECKSUM_WRITE = 1;\n\n\t\tdm_helpers_dp_write_dpcd(ctx,\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_TEST_EDID_CHECKSUM,\n\t\t\t\t\t&sink->dc_edid.raw_edid[sink->dc_edid.length-1],\n\t\t\t\t\t1);\n\n\t\tdm_helpers_dp_write_dpcd(ctx,\n\t\t\t\t\tlink,\n\t\t\t\t\tDP_TEST_RESPONSE,\n\t\t\t\t\t&test_response.raw,\n\t\t\t\t\tsizeof(test_response));\n\n\t}\n\n\treturn edid_status;\n}\nint dm_helper_dmub_aux_transfer_sync(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tstruct aux_payload *payload,\n\t\tenum aux_return_code_type *operation_result)\n{\n\treturn amdgpu_dm_process_dmub_aux_transfer_sync(ctx, link->link_index, payload,\n\t\t\toperation_result);\n}\n\nint dm_helpers_dmub_set_config_sync(struct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tstruct set_config_cmd_payload *payload,\n\t\tenum set_config_status *operation_result)\n{\n\treturn amdgpu_dm_process_dmub_set_config_sync(ctx, link->link_index, payload,\n\t\t\toperation_result);\n}\n\nvoid dm_set_dcn_clocks(struct dc_context *ctx, struct dc_clocks *clks)\n{\n\t \n}\n\nvoid dm_helpers_smu_timeout(struct dc_context *ctx, unsigned int msg_id, unsigned int param, unsigned int timeout_us)\n{\n\t\n\t\n}\n\nvoid dm_helpers_init_panel_settings(\n\tstruct dc_context *ctx,\n\tstruct dc_panel_config *panel_config,\n\tstruct dc_sink *sink)\n{\n\t\n\tpanel_config->pps.extra_t3_ms = sink->edid_caps.panel_patch.extra_t3_ms;\n\tpanel_config->pps.extra_t7_ms = sink->edid_caps.panel_patch.extra_t7_ms;\n\tpanel_config->pps.extra_delay_backlight_off = sink->edid_caps.panel_patch.extra_delay_backlight_off;\n\tpanel_config->pps.extra_post_t7_ms = 0;\n\tpanel_config->pps.extra_pre_t11_ms = 0;\n\tpanel_config->pps.extra_t12_ms = sink->edid_caps.panel_patch.extra_t12_ms;\n\tpanel_config->pps.extra_post_OUI_ms = 0;\n\t\n\tpanel_config->dsc.disable_dsc_edp = false;\n\tpanel_config->dsc.force_dsc_edp_policy = 0;\n}\n\nvoid dm_helpers_override_panel_settings(\n\tstruct dc_context *ctx,\n\tstruct dc_panel_config *panel_config)\n{\n\t\n\tif (amdgpu_dc_debug_mask & DC_DISABLE_DSC)\n\t\tpanel_config->dsc.disable_dsc_edp = true;\n}\n\nvoid *dm_helpers_allocate_gpu_mem(\n\t\tstruct dc_context *ctx,\n\t\tenum dc_gpu_mem_alloc_type type,\n\t\tsize_t size,\n\t\tlong long *addr)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct dal_allocation *da;\n\tu32 domain = (type == DC_MEM_ALLOC_TYPE_GART) ?\n\t\tAMDGPU_GEM_DOMAIN_GTT : AMDGPU_GEM_DOMAIN_VRAM;\n\tint ret;\n\n\tda = kzalloc(sizeof(struct dal_allocation), GFP_KERNEL);\n\tif (!da)\n\t\treturn NULL;\n\n\tret = amdgpu_bo_create_kernel(adev, size, PAGE_SIZE,\n\t\t\t\t      domain, &da->bo,\n\t\t\t\t      &da->gpu_addr, &da->cpu_ptr);\n\n\t*addr = da->gpu_addr;\n\n\tif (ret) {\n\t\tkfree(da);\n\t\treturn NULL;\n\t}\n\n\t \n\tlist_add(&da->list, &adev->dm.da_list);\n\n\treturn da->cpu_ptr;\n}\n\nvoid dm_helpers_free_gpu_mem(\n\t\tstruct dc_context *ctx,\n\t\tenum dc_gpu_mem_alloc_type type,\n\t\tvoid *pvMem)\n{\n\tstruct amdgpu_device *adev = ctx->driver_context;\n\tstruct dal_allocation *da;\n\n\t \n\tlist_for_each_entry(da, &adev->dm.da_list, list) {\n\t\tif (pvMem == da->cpu_ptr) {\n\t\t\tamdgpu_bo_free_kernel(&da->bo, &da->gpu_addr, &da->cpu_ptr);\n\t\t\tlist_del(&da->list);\n\t\t\tkfree(da);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool dm_helpers_dmub_outbox_interrupt_control(struct dc_context *ctx, bool enable)\n{\n\tenum dc_irq_source irq_source;\n\tbool ret;\n\n\tirq_source = DC_IRQ_SOURCE_DMCUB_OUTBOX;\n\n\tret = dc_interrupt_set(ctx->dc, irq_source, enable);\n\n\tDRM_DEBUG_DRIVER(\"Dmub trace irq %sabling: r=%d\\n\",\n\t\t\t enable ? \"en\" : \"dis\", ret);\n\treturn ret;\n}\n\nvoid dm_helpers_mst_enable_stream_features(const struct dc_stream_state *stream)\n{\n\t \n\tstruct dc_link *link = stream->link;\n\tunion down_spread_ctrl old_downspread;\n\tunion down_spread_ctrl new_downspread;\n\n\tif (link->aux_access_disabled)\n\t\treturn;\n\n\tif (!dm_helpers_dp_read_dpcd(link->ctx, link, DP_DOWNSPREAD_CTRL,\n\t\t\t\t     &old_downspread.raw,\n\t\t\t\t     sizeof(old_downspread)))\n\t\treturn;\n\n\tnew_downspread.raw = old_downspread.raw;\n\tnew_downspread.bits.IGNORE_MSA_TIMING_PARAM =\n\t\t(stream->ignore_msa_timing_param) ? 1 : 0;\n\n\tif (new_downspread.raw != old_downspread.raw)\n\t\tdm_helpers_dp_write_dpcd(link->ctx, link, DP_DOWNSPREAD_CTRL,\n\t\t\t\t\t &new_downspread.raw,\n\t\t\t\t\t sizeof(new_downspread));\n}\n\nbool dm_helpers_dp_handle_test_pattern_request(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_link *link,\n\t\tunion link_test_pattern dpcd_test_pattern,\n\t\tunion test_misc dpcd_test_params)\n{\n\tenum dp_test_pattern test_pattern;\n\tenum dp_test_pattern_color_space test_pattern_color_space =\n\t\t\tDP_TEST_PATTERN_COLOR_SPACE_UNDEFINED;\n\tenum dc_color_depth requestColorDepth = COLOR_DEPTH_UNDEFINED;\n\tenum dc_pixel_encoding requestPixelEncoding = PIXEL_ENCODING_UNDEFINED;\n\tstruct pipe_ctx *pipes = link->dc->current_state->res_ctx.pipe_ctx;\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (pipes[i].stream == NULL)\n\t\t\tcontinue;\n\n\t\tif (pipes[i].stream->link == link && !pipes[i].top_pipe &&\n\t\t\t!pipes[i].prev_odm_pipe) {\n\t\t\tpipe_ctx = &pipes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pipe_ctx == NULL)\n\t\treturn false;\n\n\tswitch (dpcd_test_pattern.bits.PATTERN) {\n\tcase LINK_TEST_PATTERN_COLOR_RAMP:\n\t\ttest_pattern = DP_TEST_PATTERN_COLOR_RAMP;\n\tbreak;\n\tcase LINK_TEST_PATTERN_VERTICAL_BARS:\n\t\ttest_pattern = DP_TEST_PATTERN_VERTICAL_BARS;\n\tbreak;  \n\tcase LINK_TEST_PATTERN_COLOR_SQUARES:\n\t\ttest_pattern = (dpcd_test_params.bits.DYN_RANGE ==\n\t\t\t\tTEST_DYN_RANGE_VESA ?\n\t\t\t\tDP_TEST_PATTERN_COLOR_SQUARES :\n\t\t\t\tDP_TEST_PATTERN_COLOR_SQUARES_CEA);\n\tbreak;\n\tdefault:\n\t\ttest_pattern = DP_TEST_PATTERN_VIDEO_MODE;\n\tbreak;\n\t}\n\n\tif (dpcd_test_params.bits.CLR_FORMAT == 0)\n\t\ttest_pattern_color_space = DP_TEST_PATTERN_COLOR_SPACE_RGB;\n\telse\n\t\ttest_pattern_color_space = dpcd_test_params.bits.YCBCR_COEFS ?\n\t\t\t\tDP_TEST_PATTERN_COLOR_SPACE_YCBCR709 :\n\t\t\t\tDP_TEST_PATTERN_COLOR_SPACE_YCBCR601;\n\n\tswitch (dpcd_test_params.bits.BPC) {\n\tcase 0: \n\t\trequestColorDepth = COLOR_DEPTH_666;\n\t\tbreak;\n\tcase 1: \n\t\trequestColorDepth = COLOR_DEPTH_888;\n\t\tbreak;\n\tcase 2: \n\t\trequestColorDepth = COLOR_DEPTH_101010;\n\t\tbreak;\n\tcase 3: \n\t\trequestColorDepth = COLOR_DEPTH_121212;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (dpcd_test_params.bits.CLR_FORMAT) {\n\tcase 0:\n\t\trequestPixelEncoding = PIXEL_ENCODING_RGB;\n\t\tbreak;\n\tcase 1:\n\t\trequestPixelEncoding = PIXEL_ENCODING_YCBCR422;\n\t\tbreak;\n\tcase 2:\n\t\trequestPixelEncoding = PIXEL_ENCODING_YCBCR444;\n\t\tbreak;\n\tdefault:\n\t\trequestPixelEncoding = PIXEL_ENCODING_RGB;\n\t\tbreak;\n\t}\n\n\tif ((requestColorDepth != COLOR_DEPTH_UNDEFINED\n\t\t&& pipe_ctx->stream->timing.display_color_depth != requestColorDepth)\n\t\t|| (requestPixelEncoding != PIXEL_ENCODING_UNDEFINED\n\t\t&& pipe_ctx->stream->timing.pixel_encoding != requestPixelEncoding)) {\n\t\tDC_LOG_DEBUG(\"%s: original bpc %d pix encoding %d, changing to %d  %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tpipe_ctx->stream->timing.display_color_depth,\n\t\t\t\tpipe_ctx->stream->timing.pixel_encoding,\n\t\t\t\trequestColorDepth,\n\t\t\t\trequestPixelEncoding);\n\t\tpipe_ctx->stream->timing.display_color_depth = requestColorDepth;\n\t\tpipe_ctx->stream->timing.pixel_encoding = requestPixelEncoding;\n\n\t\tdc_link_update_dsc_config(pipe_ctx);\n\n\t\taconnector->timing_changed = true;\n\t\t \n\t\tif (aconnector->timing_requested)\n\t\t\t*aconnector->timing_requested = pipe_ctx->stream->timing;\n\t\telse\n\t\t\tDC_LOG_ERROR(\"%s: timing storage failed\\n\", __func__);\n\n\t}\n\n\tdc_link_dp_set_test_pattern(\n\t\t(struct dc_link *) link,\n\t\ttest_pattern,\n\t\ttest_pattern_color_space,\n\t\tNULL,\n\t\tNULL,\n\t\t0);\n\n\treturn false;\n}\n\nvoid dm_set_phyd32clk(struct dc_context *ctx, int freq_khz)\n{\n       \n}\n\nvoid dm_helpers_enable_periodic_detection(struct dc_context *ctx, bool enable)\n{\n\t \n}\n\nvoid dm_helpers_dp_mst_update_branch_bandwidth(\n\t\tstruct dc_context *ctx,\n\t\tstruct dc_link *link)\n{\n\t\n}\n\nstatic bool dm_is_freesync_pcon_whitelist(const uint32_t branch_dev_id)\n{\n\tbool ret_val = false;\n\n\tswitch (branch_dev_id) {\n\tcase DP_BRANCH_DEVICE_ID_0060AD:\n\tcase DP_BRANCH_DEVICE_ID_00E04C:\n\tcase DP_BRANCH_DEVICE_ID_90CC24:\n\t\tret_val = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\nenum adaptive_sync_type dm_get_adaptive_sync_support_type(struct dc_link *link)\n{\n\tstruct dpcd_caps *dpcd_caps = &link->dpcd_caps;\n\tenum adaptive_sync_type as_type = ADAPTIVE_SYNC_TYPE_NONE;\n\n\tswitch (dpcd_caps->dongle_type) {\n\tcase DISPLAY_DONGLE_DP_HDMI_CONVERTER:\n\t\tif (dpcd_caps->adaptive_sync_caps.dp_adap_sync_caps.bits.ADAPTIVE_SYNC_SDP_SUPPORT == true &&\n\t\t\tdpcd_caps->allow_invalid_MSA_timing_param == true &&\n\t\t\tdm_is_freesync_pcon_whitelist(dpcd_caps->branch_dev_id))\n\t\t\tas_type = FREESYNC_TYPE_PCON_IN_WHITELIST;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn as_type;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}