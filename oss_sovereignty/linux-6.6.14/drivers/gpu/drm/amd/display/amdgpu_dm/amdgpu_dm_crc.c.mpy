{
  "module_name": "amdgpu_dm_crc.c",
  "hash_id": "629b35d134a3f73b226bd50728aa056d54a29ac43d78ee6d01ebdecf612865db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c",
  "human_readable_source": " \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_vblank.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_dm.h\"\n#include \"dc.h\"\n#include \"amdgpu_securedisplay.h\"\n\nstatic const char *const pipe_crc_sources[] = {\n\t\"none\",\n\t\"crtc\",\n\t\"crtc dither\",\n\t\"dprx\",\n\t\"dprx dither\",\n\t\"auto\",\n};\n\nstatic enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)\n{\n\tif (!source || !strcmp(source, \"none\"))\n\t\treturn AMDGPU_DM_PIPE_CRC_SOURCE_NONE;\n\tif (!strcmp(source, \"auto\") || !strcmp(source, \"crtc\"))\n\t\treturn AMDGPU_DM_PIPE_CRC_SOURCE_CRTC;\n\tif (!strcmp(source, \"dprx\"))\n\t\treturn AMDGPU_DM_PIPE_CRC_SOURCE_DPRX;\n\tif (!strcmp(source, \"crtc dither\"))\n\t\treturn AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER;\n\tif (!strcmp(source, \"dprx dither\"))\n\t\treturn AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER;\n\n\treturn AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;\n}\n\nstatic bool dm_is_crc_source_crtc(enum amdgpu_dm_pipe_crc_source src)\n{\n\treturn (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) ||\n\t       (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER);\n}\n\nstatic bool dm_is_crc_source_dprx(enum amdgpu_dm_pipe_crc_source src)\n{\n\treturn (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) ||\n\t       (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER);\n}\n\nstatic bool dm_need_crc_dither(enum amdgpu_dm_pipe_crc_source src)\n{\n\treturn (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER) ||\n\t       (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER) ||\n\t       (src == AMDGPU_DM_PIPE_CRC_SOURCE_NONE);\n}\n\nconst char *const *amdgpu_dm_crtc_get_crc_sources(struct drm_crtc *crtc,\n\t\t\t\t\t\t  size_t *count)\n{\n\t*count = ARRAY_SIZE(pipe_crc_sources);\n\treturn pipe_crc_sources;\n}\n\n#ifdef CONFIG_DRM_AMD_SECURE_DISPLAY\nstatic void amdgpu_dm_set_crc_window_default(struct drm_crtc *crtc, struct dc_stream_state *stream)\n{\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_display_manager *dm = &drm_to_adev(drm_dev)->dm;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tbool was_activated;\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\twas_activated = acrtc->dm_irq_params.window_param.activated;\n\tacrtc->dm_irq_params.window_param.x_start = 0;\n\tacrtc->dm_irq_params.window_param.y_start = 0;\n\tacrtc->dm_irq_params.window_param.x_end = 0;\n\tacrtc->dm_irq_params.window_param.y_end = 0;\n\tacrtc->dm_irq_params.window_param.activated = false;\n\tacrtc->dm_irq_params.window_param.update_win = false;\n\tacrtc->dm_irq_params.window_param.skip_frame_cnt = 0;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\t \n\tif (was_activated) {\n\t\t \n\t\tflush_work(&dm->secure_display_ctxs[crtc->index].notify_ta_work);\n\t\tflush_work(&dm->secure_display_ctxs[crtc->index].forward_roi_work);\n\t\tdc_stream_forward_crc_window(stream, NULL, true);\n\t}\n}\n\nstatic void amdgpu_dm_crtc_notify_ta_to_read(struct work_struct *work)\n{\n\tstruct secure_display_context *secure_display_ctx;\n\tstruct psp_context *psp;\n\tstruct ta_securedisplay_cmd *securedisplay_cmd;\n\tstruct drm_crtc *crtc;\n\tstruct dc_stream_state *stream;\n\tuint8_t phy_inst;\n\tint ret;\n\n\tsecure_display_ctx = container_of(work, struct secure_display_context, notify_ta_work);\n\tcrtc = secure_display_ctx->crtc;\n\n\tif (!crtc)\n\t\treturn;\n\n\tpsp = &drm_to_adev(crtc->dev)->psp;\n\n\tif (!psp->securedisplay_context.context.initialized) {\n\t\tDRM_DEBUG_DRIVER(\"Secure Display fails to notify PSP TA\\n\");\n\t\treturn;\n\t}\n\n\tstream = to_amdgpu_crtc(crtc)->dm_irq_params.stream;\n\tphy_inst = stream->link->link_enc_hw_inst;\n\n\t \n\tmutex_lock(&psp->securedisplay_context.mutex);\n\n\tpsp_prep_securedisplay_cmd_buf(psp, &securedisplay_cmd,\n\t\t\t\t\t\tTA_SECUREDISPLAY_COMMAND__SEND_ROI_CRC);\n\n\tsecuredisplay_cmd->securedisplay_in_message.send_roi_crc.phy_id = phy_inst;\n\n\t \n\tret = psp_securedisplay_invoke(psp, TA_SECUREDISPLAY_COMMAND__SEND_ROI_CRC);\n\n\tif (!ret) {\n\t\tif (securedisplay_cmd->status != TA_SECUREDISPLAY_STATUS__SUCCESS)\n\t\t\tpsp_securedisplay_parse_resp_status(psp, securedisplay_cmd->status);\n\t}\n\n\tmutex_unlock(&psp->securedisplay_context.mutex);\n}\n\nstatic void\namdgpu_dm_forward_crc_window(struct work_struct *work)\n{\n\tstruct secure_display_context *secure_display_ctx;\n\tstruct amdgpu_display_manager *dm;\n\tstruct drm_crtc *crtc;\n\tstruct dc_stream_state *stream;\n\n\tsecure_display_ctx = container_of(work, struct secure_display_context, forward_roi_work);\n\tcrtc = secure_display_ctx->crtc;\n\n\tif (!crtc)\n\t\treturn;\n\n\tdm = &drm_to_adev(crtc->dev)->dm;\n\tstream = to_amdgpu_crtc(crtc)->dm_irq_params.stream;\n\n\tmutex_lock(&dm->dc_lock);\n\tdc_stream_forward_crc_window(stream, &secure_display_ctx->rect, false);\n\tmutex_unlock(&dm->dc_lock);\n}\n\nbool amdgpu_dm_crc_window_is_activated(struct drm_crtc *crtc)\n{\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tbool ret = false;\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tret = acrtc->dm_irq_params.window_param.activated;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\treturn ret;\n}\n#endif\n\nint\namdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,\n\t\t\t\t size_t *values_cnt)\n{\n\tenum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);\n\n\tif (source < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Unknown CRC source %s for CRTC%d\\n\",\n\t\t\t\t src_name, crtc->index);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 3;\n\treturn 0;\n}\n\nint amdgpu_dm_crtc_configure_crc_source(struct drm_crtc *crtc,\n\t\t\t\t\tstruct dm_crtc_state *dm_crtc_state,\n\t\t\t\t\tenum amdgpu_dm_pipe_crc_source source)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tstruct dc_stream_state *stream_state = dm_crtc_state->stream;\n\tbool enable = amdgpu_dm_is_valid_crc_source(source);\n\tint ret = 0;\n\n\t \n\tif (!stream_state)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adev->dm.dc_lock);\n\n\t \n\tif (dm_is_crc_source_crtc(source) || source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE) {\n\t\tif (!dc_stream_configure_crc(stream_state->ctx->dc,\n\t\t\t\t\t     stream_state, NULL, enable, enable)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\tif (!dm_need_crc_dither(source)) {\n\t\tdc_stream_set_dither_option(stream_state, DITHER_OPTION_TRUN8);\n\t\tdc_stream_set_dyn_expansion(stream_state->ctx->dc, stream_state,\n\t\t\t\t\t    DYN_EXPANSION_DISABLE);\n\t} else {\n\t\tdc_stream_set_dither_option(stream_state,\n\t\t\t\t\t    DITHER_OPTION_DEFAULT);\n\t\tdc_stream_set_dyn_expansion(stream_state->ctx->dc, stream_state,\n\t\t\t\t\t    DYN_EXPANSION_AUTO);\n\t}\n\nunlock:\n\tmutex_unlock(&adev->dm.dc_lock);\n\n\treturn ret;\n}\n\nint amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)\n{\n\tenum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);\n\tenum amdgpu_dm_pipe_crc_source cur_crc_src;\n\tstruct drm_crtc_commit *commit;\n\tstruct dm_crtc_state *crtc_state;\n\tstruct drm_device *drm_dev = crtc->dev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tstruct drm_dp_aux *aux = NULL;\n\tbool enable = false;\n\tbool enabled = false;\n\tint ret = 0;\n\n\tif (source < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Unknown CRC source %s for CRTC%d\\n\",\n\t\t\t\t src_name, crtc->index);\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_modeset_lock(&crtc->mutex, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&crtc->commit_lock);\n\tcommit = list_first_entry_or_null(&crtc->commit_list,\n\t\t\t\t\t  struct drm_crtc_commit, commit_entry);\n\tif (commit)\n\t\tdrm_crtc_commit_get(commit);\n\tspin_unlock(&crtc->commit_lock);\n\n\tif (commit) {\n\t\t \n\t\tret = wait_for_completion_interruptible_timeout(\n\t\t\t&commit->hw_done, 10 * HZ);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tenable = amdgpu_dm_is_valid_crc_source(source);\n\tcrtc_state = to_dm_crtc_state(crtc->state);\n\tspin_lock_irq(&drm_dev->event_lock);\n\tcur_crc_src = acrtc->dm_irq_params.crc_src;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\t \n\tif (dm_is_crc_source_dprx(source) ||\n\t    (source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE &&\n\t     dm_is_crc_source_dprx(cur_crc_src))) {\n\t\tstruct amdgpu_dm_connector *aconn = NULL;\n\t\tstruct drm_connector *connector;\n\t\tstruct drm_connector_list_iter conn_iter;\n\n\t\tdrm_connector_list_iter_begin(crtc->dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (!connector->state || connector->state->crtc != crtc)\n\t\t\t\tcontinue;\n\n\t\t\taconn = to_amdgpu_dm_connector(connector);\n\t\t\tbreak;\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\n\t\tif (!aconn) {\n\t\t\tDRM_DEBUG_DRIVER(\"No amd connector matching CRTC-%d\\n\", crtc->index);\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\taux = (aconn->mst_output_port) ? &aconn->mst_output_port->aux : &aconn->dm_dp_aux.aux;\n\n\t\tif (!aux) {\n\t\t\tDRM_DEBUG_DRIVER(\"No dp aux for amd connector\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ((aconn->base.connector_type != DRM_MODE_CONNECTOR_DisplayPort) &&\n\t\t\t\t(aconn->base.connector_type != DRM_MODE_CONNECTOR_eDP)) {\n\t\t\tDRM_DEBUG_DRIVER(\"No DP connector available for CRC source\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t}\n\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\n\t \n\tamdgpu_dm_set_crc_window_default(crtc, crtc_state->stream);\n#endif\n\n\tif (amdgpu_dm_crtc_configure_crc_source(crtc, crtc_state, source)) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tenabled = amdgpu_dm_is_valid_crc_source(cur_crc_src);\n\tif (!enabled && enable) {\n\t\tret = drm_crtc_vblank_get(crtc);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\n\t\tif (dm_is_crc_source_dprx(source)) {\n\t\t\tif (drm_dp_start_crc(aux, crtc)) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"dp start crc failed\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t} else if (enabled && !enable) {\n\t\tdrm_crtc_vblank_put(crtc);\n\t\tif (dm_is_crc_source_dprx(source)) {\n\t\t\tif (drm_dp_stop_crc(aux)) {\n\t\t\t\tDRM_DEBUG_DRIVER(\"dp stop crc failed\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irq(&drm_dev->event_lock);\n\tacrtc->dm_irq_params.crc_src = source;\n\tspin_unlock_irq(&drm_dev->event_lock);\n\n\t \n\tcrtc_state->crc_skip_count = 0;\n\ncleanup:\n\tif (commit)\n\t\tdrm_crtc_commit_put(commit);\n\n\tdrm_modeset_unlock(&crtc->mutex);\n\n\treturn ret;\n}\n\n \nvoid amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)\n{\n\tstruct dm_crtc_state *crtc_state;\n\tstruct dc_stream_state *stream_state;\n\tstruct drm_device *drm_dev = NULL;\n\tenum amdgpu_dm_pipe_crc_source cur_crc_src;\n\tstruct amdgpu_crtc *acrtc = NULL;\n\tuint32_t crcs[3];\n\tunsigned long flags;\n\n\tif (crtc == NULL)\n\t\treturn;\n\n\tcrtc_state = to_dm_crtc_state(crtc->state);\n\tstream_state = crtc_state->stream;\n\tacrtc = to_amdgpu_crtc(crtc);\n\tdrm_dev = crtc->dev;\n\n\tspin_lock_irqsave(&drm_dev->event_lock, flags);\n\tcur_crc_src = acrtc->dm_irq_params.crc_src;\n\tspin_unlock_irqrestore(&drm_dev->event_lock, flags);\n\n\t \n\tif (!amdgpu_dm_is_valid_crc_source(cur_crc_src))\n\t\treturn;\n\n\t \n\tif (crtc_state->crc_skip_count < 2) {\n\t\tcrtc_state->crc_skip_count += 1;\n\t\treturn;\n\t}\n\n\tif (dm_is_crc_source_crtc(cur_crc_src)) {\n\t\tif (!dc_stream_get_crc(stream_state->ctx->dc, stream_state,\n\t\t\t\t       &crcs[0], &crcs[1], &crcs[2]))\n\t\t\treturn;\n\n\t\tdrm_crtc_add_crc_entry(crtc, true,\n\t\t\t\t       drm_crtc_accurate_vblank_count(crtc), crcs);\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\nvoid amdgpu_dm_crtc_handle_crc_window_irq(struct drm_crtc *crtc)\n{\n\tstruct drm_device *drm_dev = NULL;\n\tenum amdgpu_dm_pipe_crc_source cur_crc_src;\n\tstruct amdgpu_crtc *acrtc = NULL;\n\tstruct amdgpu_device *adev = NULL;\n\tstruct secure_display_context *secure_display_ctx = NULL;\n\tunsigned long flags1;\n\n\tif (crtc == NULL)\n\t\treturn;\n\n\tacrtc = to_amdgpu_crtc(crtc);\n\tadev = drm_to_adev(crtc->dev);\n\tdrm_dev = crtc->dev;\n\n\tspin_lock_irqsave(&drm_dev->event_lock, flags1);\n\tcur_crc_src = acrtc->dm_irq_params.crc_src;\n\n\t \n\tif (!amdgpu_dm_is_valid_crc_source(cur_crc_src) ||\n\t\t!dm_is_crc_source_crtc(cur_crc_src))\n\t\tgoto cleanup;\n\n\tif (!acrtc->dm_irq_params.window_param.activated)\n\t\tgoto cleanup;\n\n\tif (acrtc->dm_irq_params.window_param.skip_frame_cnt) {\n\t\tacrtc->dm_irq_params.window_param.skip_frame_cnt -= 1;\n\t\tgoto cleanup;\n\t}\n\n\tsecure_display_ctx = &adev->dm.secure_display_ctxs[acrtc->crtc_id];\n\tif (WARN_ON(secure_display_ctx->crtc != crtc)) {\n\t\t \n\t\tsecure_display_ctx->crtc = crtc;\n\t}\n\n\tif (acrtc->dm_irq_params.window_param.update_win) {\n\t\t \n\t\tsecure_display_ctx->rect.x = acrtc->dm_irq_params.window_param.x_start;\n\t\tsecure_display_ctx->rect.y = acrtc->dm_irq_params.window_param.y_start;\n\t\tsecure_display_ctx->rect.width = acrtc->dm_irq_params.window_param.x_end -\n\t\t\t\t\t\t\t\tacrtc->dm_irq_params.window_param.x_start;\n\t\tsecure_display_ctx->rect.height = acrtc->dm_irq_params.window_param.y_end -\n\t\t\t\t\t\t\t\tacrtc->dm_irq_params.window_param.y_start;\n\t\tschedule_work(&secure_display_ctx->forward_roi_work);\n\n\t\tacrtc->dm_irq_params.window_param.update_win = false;\n\n\t\t \n\t\tacrtc->dm_irq_params.window_param.skip_frame_cnt = 1;\n\n\t} else {\n\t\t \n\t\tschedule_work(&secure_display_ctx->notify_ta_work);\n\t}\n\ncleanup:\n\tspin_unlock_irqrestore(&drm_dev->event_lock, flags1);\n}\n\nstruct secure_display_context *\namdgpu_dm_crtc_secure_display_create_contexts(struct amdgpu_device *adev)\n{\n\tstruct secure_display_context *secure_display_ctxs = NULL;\n\tint i;\n\n\tsecure_display_ctxs = kcalloc(adev->mode_info.num_crtc,\n\t\t\t\t      sizeof(struct secure_display_context),\n\t\t\t\t      GFP_KERNEL);\n\n\tif (!secure_display_ctxs)\n\t\treturn NULL;\n\n\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\tINIT_WORK(&secure_display_ctxs[i].forward_roi_work, amdgpu_dm_forward_crc_window);\n\t\tINIT_WORK(&secure_display_ctxs[i].notify_ta_work, amdgpu_dm_crtc_notify_ta_to_read);\n\t\tsecure_display_ctxs[i].crtc = &adev->mode_info.crtcs[i]->base;\n\t}\n\n\treturn secure_display_ctxs;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}