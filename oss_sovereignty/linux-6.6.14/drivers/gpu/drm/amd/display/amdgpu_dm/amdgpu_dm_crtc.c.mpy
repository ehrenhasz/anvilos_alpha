{
  "module_name": "amdgpu_dm_crtc.c",
  "hash_id": "b3ee0711f02f2b2f2b1e4fedd00602d58fd3ef8e912636e5813b8cb91aeb0547",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c",
  "human_readable_source": "\n \n#include <drm/drm_vblank.h>\n#include <drm/drm_atomic_helper.h>\n\n#include \"dc.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_dm_psr.h\"\n#include \"amdgpu_dm_replay.h\"\n#include \"amdgpu_dm_crtc.h\"\n#include \"amdgpu_dm_plane.h\"\n#include \"amdgpu_dm_trace.h\"\n#include \"amdgpu_dm_debugfs.h\"\n\nvoid amdgpu_dm_crtc_handle_vblank(struct amdgpu_crtc *acrtc)\n{\n\tstruct drm_crtc *crtc = &acrtc->base;\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tdrm_crtc_handle_vblank(crtc);\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t \n\tif (acrtc->event && acrtc->pflip_status != AMDGPU_FLIP_SUBMITTED) {\n\t\tdrm_crtc_send_vblank_event(crtc, acrtc->event);\n\t\tdrm_crtc_vblank_put(crtc);\n\t\tacrtc->event = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nbool amdgpu_dm_crtc_modeset_required(struct drm_crtc_state *crtc_state,\n\t\t\t     struct dc_stream_state *new_stream,\n\t\t\t     struct dc_stream_state *old_stream)\n{\n\treturn crtc_state->active && drm_atomic_crtc_needs_modeset(crtc_state);\n}\n\nbool amdgpu_dm_crtc_vrr_active_irq(struct amdgpu_crtc *acrtc)\n\n{\n\treturn acrtc->dm_irq_params.freesync_config.state ==\n\t\t       VRR_STATE_ACTIVE_VARIABLE ||\n\t       acrtc->dm_irq_params.freesync_config.state ==\n\t\t       VRR_STATE_ACTIVE_FIXED;\n}\n\nint amdgpu_dm_crtc_set_vupdate_irq(struct drm_crtc *crtc, bool enable)\n{\n\tenum dc_irq_source irq_source;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tint rc;\n\n\tif (acrtc->otg_inst == -1)\n\t\treturn 0;\n\n\tirq_source = IRQ_TYPE_VUPDATE + acrtc->otg_inst;\n\n\trc = dc_interrupt_set(adev->dm.dc, irq_source, enable) ? 0 : -EBUSY;\n\n\tDRM_DEBUG_VBL(\"crtc %d - vupdate irq %sabling: r=%d\\n\",\n\t\t      acrtc->crtc_id, enable ? \"en\" : \"dis\", rc);\n\treturn rc;\n}\n\nbool amdgpu_dm_crtc_vrr_active(struct dm_crtc_state *dm_state)\n{\n\treturn dm_state->freesync_config.state == VRR_STATE_ACTIVE_VARIABLE ||\n\t       dm_state->freesync_config.state == VRR_STATE_ACTIVE_FIXED;\n}\n\nstatic void vblank_control_worker(struct work_struct *work)\n{\n\tstruct vblank_control_work *vblank_work =\n\t\tcontainer_of(work, struct vblank_control_work, work);\n\tstruct amdgpu_display_manager *dm = vblank_work->dm;\n\n\tmutex_lock(&dm->dc_lock);\n\n\tif (vblank_work->enable)\n\t\tdm->active_vblank_irq_count++;\n\telse if (dm->active_vblank_irq_count)\n\t\tdm->active_vblank_irq_count--;\n\n\tdc_allow_idle_optimizations(dm->dc, dm->active_vblank_irq_count == 0);\n\n\tDRM_DEBUG_KMS(\"Allow idle optimizations (MALL): %d\\n\", dm->active_vblank_irq_count == 0);\n\n\t \n\tif (vblank_work->stream && vblank_work->stream->link) {\n\t\t \n\t\tif (vblank_work->stream->link->replay_settings.replay_feature_enabled)\n\t\t\tamdgpu_dm_replay_enable(vblank_work->stream, false);\n\t\telse if (vblank_work->enable) {\n\t\t\tif (vblank_work->stream->link->psr_settings.psr_version < DC_PSR_VERSION_SU_1 &&\n\t\t\t    vblank_work->stream->link->psr_settings.psr_allow_active)\n\t\t\t\tamdgpu_dm_psr_disable(vblank_work->stream);\n\t\t} else if (vblank_work->stream->link->psr_settings.psr_feature_enabled &&\n\t\t\t   !vblank_work->stream->link->psr_settings.psr_allow_active &&\n#ifdef CONFIG_DRM_AMD_SECURE_DISPLAY\n\t\t\t   !amdgpu_dm_crc_window_is_activated(&vblank_work->acrtc->base) &&\n#endif\n\t\t\t   vblank_work->stream->link->panel_config.psr.disallow_replay &&\n\t\t\t   vblank_work->acrtc->dm_irq_params.allow_psr_entry) {\n\t\t\tamdgpu_dm_psr_enable(vblank_work->stream);\n\t\t}\n\t}\n\n\tmutex_unlock(&dm->dc_lock);\n\n\tdc_stream_release(vblank_work->stream);\n\n\tkfree(vblank_work);\n}\n\nstatic inline int dm_set_vblank(struct drm_crtc *crtc, bool enable)\n{\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tstruct dm_crtc_state *acrtc_state = to_dm_crtc_state(crtc->state);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct vblank_control_work *work;\n\tint rc = 0;\n\n\tif (acrtc->otg_inst == -1)\n\t\tgoto skip;\n\n\tif (enable) {\n\t\t \n\t\tif (amdgpu_dm_crtc_vrr_active(acrtc_state))\n\t\t\trc = amdgpu_dm_crtc_set_vupdate_irq(crtc, true);\n\t} else {\n\t\t \n\t\trc = amdgpu_dm_crtc_set_vupdate_irq(crtc, false);\n\t}\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = (enable)\n\t\t? amdgpu_irq_get(adev, &adev->crtc_irq, acrtc->crtc_id)\n\t\t: amdgpu_irq_put(adev, &adev->crtc_irq, acrtc->crtc_id);\n\n\tif (rc)\n\t\treturn rc;\n\nskip:\n\tif (amdgpu_in_reset(adev))\n\t\treturn 0;\n\n\tif (dm->vblank_control_workqueue) {\n\t\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_WORK(&work->work, vblank_control_worker);\n\t\twork->dm = dm;\n\t\twork->acrtc = acrtc;\n\t\twork->enable = enable;\n\n\t\tif (acrtc_state->stream) {\n\t\t\tdc_stream_retain(acrtc_state->stream);\n\t\t\twork->stream = acrtc_state->stream;\n\t\t}\n\n\t\tqueue_work(dm->vblank_control_workqueue, &work->work);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_dm_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\treturn dm_set_vblank(crtc, true);\n}\n\nvoid amdgpu_dm_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tdm_set_vblank(crtc, false);\n}\n\nstatic void dm_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_crtc_state *state)\n{\n\tstruct dm_crtc_state *cur = to_dm_crtc_state(state);\n\n\t \n\tif (cur->stream)\n\t\tdc_stream_release(cur->stream);\n\n\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\n\n\tkfree(state);\n}\n\nstatic struct drm_crtc_state *dm_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct dm_crtc_state *state, *cur;\n\n\tcur = to_dm_crtc_state(crtc->state);\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tif (cur->stream) {\n\t\tstate->stream = cur->stream;\n\t\tdc_stream_retain(state->stream);\n\t}\n\n\tstate->active_planes = cur->active_planes;\n\tstate->vrr_infopacket = cur->vrr_infopacket;\n\tstate->abm_level = cur->abm_level;\n\tstate->vrr_supported = cur->vrr_supported;\n\tstate->freesync_config = cur->freesync_config;\n\tstate->cm_has_degamma = cur->cm_has_degamma;\n\tstate->cm_is_degamma_srgb = cur->cm_is_degamma_srgb;\n\tstate->crc_skip_count = cur->crc_skip_count;\n\tstate->mpo_requested = cur->mpo_requested;\n\t \n\n\treturn &state->base;\n}\n\nstatic void amdgpu_dm_crtc_destroy(struct drm_crtc *crtc)\n{\n\tdrm_crtc_cleanup(crtc);\n\tkfree(crtc);\n}\n\nstatic void dm_crtc_reset_state(struct drm_crtc *crtc)\n{\n\tstruct dm_crtc_state *state;\n\n\tif (crtc->state)\n\t\tdm_crtc_destroy_state(crtc, crtc->state);\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (WARN_ON(!state))\n\t\treturn;\n\n\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int amdgpu_dm_crtc_late_register(struct drm_crtc *crtc)\n{\n\tcrtc_debugfs_init(crtc);\n\n\treturn 0;\n}\n#endif\n\n \nstatic const struct drm_crtc_funcs amdgpu_dm_crtc_funcs = {\n\t.reset = dm_crtc_reset_state,\n\t.destroy = amdgpu_dm_crtc_destroy,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = dm_crtc_duplicate_state,\n\t.atomic_destroy_state = dm_crtc_destroy_state,\n\t.set_crc_source = amdgpu_dm_crtc_set_crc_source,\n\t.verify_crc_source = amdgpu_dm_crtc_verify_crc_source,\n\t.get_crc_sources = amdgpu_dm_crtc_get_crc_sources,\n\t.get_vblank_counter = amdgpu_get_vblank_counter_kms,\n\t.enable_vblank = amdgpu_dm_crtc_enable_vblank,\n\t.disable_vblank = amdgpu_dm_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n#if defined(CONFIG_DEBUG_FS)\n\t.late_register = amdgpu_dm_crtc_late_register,\n#endif\n};\n\nstatic void dm_crtc_helper_disable(struct drm_crtc *crtc)\n{\n}\n\nstatic int count_crtc_active_planes(struct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_atomic_state *state = new_crtc_state->state;\n\tstruct drm_plane *plane;\n\tint num_active = 0;\n\n\tdrm_for_each_plane_mask(plane, state->dev, new_crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *new_plane_state;\n\n\t\t \n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\tnew_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\n\t\tif (!new_plane_state) {\n\t\t\t \n\t\t\tnum_active += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnum_active += (new_plane_state->fb != NULL);\n\t}\n\n\treturn num_active;\n}\n\nstatic void dm_update_crtc_active_planes(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_crtc_state *new_crtc_state)\n{\n\tstruct dm_crtc_state *dm_new_crtc_state =\n\t\tto_dm_crtc_state(new_crtc_state);\n\n\tdm_new_crtc_state->active_planes = 0;\n\n\tif (!dm_new_crtc_state->stream)\n\t\treturn;\n\n\tdm_new_crtc_state->active_planes =\n\t\tcount_crtc_active_planes(new_crtc_state);\n}\n\nstatic bool dm_crtc_helper_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\treturn true;\n}\n\nstatic int dm_crtc_helper_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t\tcrtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tstruct dc *dc = adev->dm.dc;\n\tstruct dm_crtc_state *dm_crtc_state = to_dm_crtc_state(crtc_state);\n\tint ret = -EINVAL;\n\n\ttrace_amdgpu_dm_crtc_atomic_check(crtc_state);\n\n\tdm_update_crtc_active_planes(crtc, crtc_state);\n\n\tif (WARN_ON(unlikely(!dm_crtc_state->stream &&\n\t\t\tamdgpu_dm_crtc_modeset_required(crtc_state, NULL, dm_crtc_state->stream)))) {\n\t\treturn ret;\n\t}\n\n\t \n\tif (crtc_state->enable &&\n\t\t!(crtc_state->plane_mask & drm_plane_mask(crtc->primary))) {\n\t\tDRM_DEBUG_ATOMIC(\"Can't enable a CRTC without enabling the primary plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (crtc_state->async_flip &&\n\t    dm_crtc_state->update_type != UPDATE_TYPE_FAST) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] async flips are only supported for fast updates\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!dm_crtc_state->stream)\n\t\treturn 0;\n\n\tif (dc_validate_stream(dc, dm_crtc_state->stream) == DC_OK)\n\t\treturn 0;\n\n\tDRM_DEBUG_ATOMIC(\"Failed DC stream validation\\n\");\n\treturn ret;\n}\n\nstatic const struct drm_crtc_helper_funcs amdgpu_dm_crtc_helper_funcs = {\n\t.disable = dm_crtc_helper_disable,\n\t.atomic_check = dm_crtc_helper_atomic_check,\n\t.mode_fixup = dm_crtc_helper_mode_fixup,\n\t.get_scanout_position = amdgpu_crtc_get_scanout_position,\n};\n\nint amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       uint32_t crtc_index)\n{\n\tstruct amdgpu_crtc *acrtc = NULL;\n\tstruct drm_plane *cursor_plane;\n\tbool is_dcn;\n\tint res = -ENOMEM;\n\n\tcursor_plane = kzalloc(sizeof(*cursor_plane), GFP_KERNEL);\n\tif (!cursor_plane)\n\t\tgoto fail;\n\n\tcursor_plane->type = DRM_PLANE_TYPE_CURSOR;\n\tres = amdgpu_dm_plane_init(dm, cursor_plane, 0, NULL);\n\n\tacrtc = kzalloc(sizeof(struct amdgpu_crtc), GFP_KERNEL);\n\tif (!acrtc)\n\t\tgoto fail;\n\n\tres = drm_crtc_init_with_planes(\n\t\t\tdm->ddev,\n\t\t\t&acrtc->base,\n\t\t\tplane,\n\t\t\tcursor_plane,\n\t\t\t&amdgpu_dm_crtc_funcs, NULL);\n\n\tif (res)\n\t\tgoto fail;\n\n\tdrm_crtc_helper_add(&acrtc->base, &amdgpu_dm_crtc_helper_funcs);\n\n\t \n\tif (acrtc->base.funcs->reset)\n\t\tacrtc->base.funcs->reset(&acrtc->base);\n\n\tacrtc->max_cursor_width = dm->adev->dm.dc->caps.max_cursor_size;\n\tacrtc->max_cursor_height = dm->adev->dm.dc->caps.max_cursor_size;\n\n\tacrtc->crtc_id = crtc_index;\n\tacrtc->base.enabled = false;\n\tacrtc->otg_inst = -1;\n\n\tdm->adev->mode_info.crtcs[crtc_index] = acrtc;\n\n\t \n\tis_dcn = dm->adev->dm.dc->caps.color.dpp.dcn_arch;\n\tdrm_crtc_enable_color_mgmt(&acrtc->base, is_dcn ? MAX_COLOR_LUT_ENTRIES : 0,\n\t\t\t\t   true, MAX_COLOR_LUT_ENTRIES);\n\n\tdrm_mode_crtc_set_gamma_size(&acrtc->base, MAX_COLOR_LEGACY_LUT_ENTRIES);\n\n\treturn 0;\n\nfail:\n\tkfree(acrtc);\n\tkfree(cursor_plane);\n\treturn res;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}