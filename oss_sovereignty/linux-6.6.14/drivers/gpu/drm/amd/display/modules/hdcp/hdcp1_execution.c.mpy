{
  "module_name": "hdcp1_execution.c",
  "hash_id": "5c74aa1f4f37fd1cf2a5be20712422e10a7cc0f1ba9433e86e7aae8462ffcb7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c",
  "human_readable_source": " \n\n#include \"hdcp.h\"\n\nstatic inline enum mod_hdcp_status validate_bksv(struct mod_hdcp *hdcp)\n{\n\tuint64_t n = 0;\n\tuint8_t count = 0;\n\tu8 bksv[sizeof(n)] = { };\n\n\tmemcpy(bksv, hdcp->auth.msg.hdcp1.bksv, sizeof(hdcp->auth.msg.hdcp1.bksv));\n\tn = *(uint64_t *)bksv;\n\n\twhile (n) {\n\t\tcount++;\n\t\tn &= (n - 1);\n\t}\n\treturn (count == 20) ? MOD_HDCP_STATUS_SUCCESS :\n\t\t\tMOD_HDCP_STATUS_HDCP1_INVALID_BKSV;\n}\n\nstatic inline enum mod_hdcp_status check_ksv_ready(struct mod_hdcp *hdcp)\n{\n\tif (is_dp_hdcp(hdcp))\n\t\treturn (hdcp->auth.msg.hdcp1.bstatus & DP_BSTATUS_READY) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP1_KSV_LIST_NOT_READY;\n\treturn (hdcp->auth.msg.hdcp1.bcaps & DRM_HDCP_DDC_BCAPS_KSV_FIFO_READY) ?\n\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\tMOD_HDCP_STATUS_HDCP1_KSV_LIST_NOT_READY;\n}\n\nstatic inline enum mod_hdcp_status check_hdcp_capable_dp(struct mod_hdcp *hdcp)\n{\n\treturn (hdcp->auth.msg.hdcp1.bcaps & DP_BCAPS_HDCP_CAPABLE) ?\n\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\tMOD_HDCP_STATUS_HDCP1_NOT_CAPABLE;\n}\n\nstatic inline enum mod_hdcp_status check_r0p_available_dp(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tif (is_dp_hdcp(hdcp)) {\n\t\tstatus = (hdcp->auth.msg.hdcp1.bstatus &\n\t\t\t\tDP_BSTATUS_R0_PRIME_READY) ?\n\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\tMOD_HDCP_STATUS_HDCP1_R0_PRIME_PENDING;\n\t} else {\n\t\tstatus = MOD_HDCP_STATUS_INVALID_OPERATION;\n\t}\n\treturn status;\n}\n\nstatic inline enum mod_hdcp_status check_link_integrity_dp(\n\t\tstruct mod_hdcp *hdcp)\n{\n\treturn (hdcp->auth.msg.hdcp1.bstatus &\n\t\t\tDP_BSTATUS_LINK_FAILURE) ?\n\t\t\tMOD_HDCP_STATUS_HDCP1_LINK_INTEGRITY_FAILURE :\n\t\t\tMOD_HDCP_STATUS_SUCCESS;\n}\n\nstatic inline enum mod_hdcp_status check_no_reauthentication_request_dp(\n\t\tstruct mod_hdcp *hdcp)\n{\n\treturn (hdcp->auth.msg.hdcp1.bstatus & DP_BSTATUS_REAUTH_REQ) ?\n\t\t\tMOD_HDCP_STATUS_HDCP1_REAUTH_REQUEST_ISSUED :\n\t\t\tMOD_HDCP_STATUS_SUCCESS;\n}\n\nstatic inline enum mod_hdcp_status check_no_max_cascade(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tstatus = DRM_HDCP_MAX_CASCADE_EXCEEDED(hdcp->auth.msg.hdcp1.binfo_dp >> 8)\n\t\t\t\t ? MOD_HDCP_STATUS_HDCP1_MAX_CASCADE_EXCEEDED_FAILURE\n\t\t\t\t : MOD_HDCP_STATUS_SUCCESS;\n\telse\n\t\tstatus = DRM_HDCP_MAX_CASCADE_EXCEEDED(hdcp->auth.msg.hdcp1.bstatus >> 8)\n\t\t\t\t ? MOD_HDCP_STATUS_HDCP1_MAX_CASCADE_EXCEEDED_FAILURE\n\t\t\t\t : MOD_HDCP_STATUS_SUCCESS;\n\treturn status;\n}\n\nstatic inline enum mod_hdcp_status check_no_max_devs(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tstatus = DRM_HDCP_MAX_DEVICE_EXCEEDED(hdcp->auth.msg.hdcp1.binfo_dp) ?\n\t\t\t\tMOD_HDCP_STATUS_HDCP1_MAX_DEVS_EXCEEDED_FAILURE :\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS;\n\telse\n\t\tstatus = DRM_HDCP_MAX_DEVICE_EXCEEDED(hdcp->auth.msg.hdcp1.bstatus) ?\n\t\t\t\tMOD_HDCP_STATUS_HDCP1_MAX_DEVS_EXCEEDED_FAILURE :\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS;\n\treturn status;\n}\n\nstatic inline uint8_t get_device_count(struct mod_hdcp *hdcp)\n{\n\treturn is_dp_hdcp(hdcp) ?\n\t\t\tDRM_HDCP_NUM_DOWNSTREAM(hdcp->auth.msg.hdcp1.binfo_dp) :\n\t\t\tDRM_HDCP_NUM_DOWNSTREAM(hdcp->auth.msg.hdcp1.bstatus);\n}\n\nstatic inline enum mod_hdcp_status check_device_count(struct mod_hdcp *hdcp)\n{\n\t \n\tif (0 == get_device_count(hdcp)) {\n\t\treturn MOD_HDCP_STATUS_HDCP1_DEVICE_COUNT_MISMATCH_FAILURE;\n\t}\n\n\t \n\treturn ((1 + get_device_count(hdcp)) < get_active_display_count(hdcp)) ?\n\t\t\tMOD_HDCP_STATUS_HDCP1_DEVICE_COUNT_MISMATCH_FAILURE :\n\t\t\tMOD_HDCP_STATUS_SUCCESS;\n}\n\nstatic enum mod_hdcp_status wait_for_active_rx(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bksv,\n\t\t\t&input->bksv_read, &status,\n\t\t\thdcp, \"bksv_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bcaps,\n\t\t\t&input->bcaps_read, &status,\n\t\t\thdcp, \"bcaps_read\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status exchange_ksvs(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp1_create_session,\n\t\t\t&input->create_session, &status,\n\t\t\thdcp, \"create_session\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_an,\n\t\t\t&input->an_write, &status,\n\t\t\thdcp, \"an_write\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_aksv,\n\t\t\t&input->aksv_write, &status,\n\t\t\thdcp, \"aksv_write\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bksv,\n\t\t\t&input->bksv_read, &status,\n\t\t\thdcp, \"bksv_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(validate_bksv,\n\t\t\t&input->bksv_validation, &status,\n\t\t\thdcp, \"bksv_validation\"))\n\t\tgoto out;\n\tif (hdcp->auth.msg.hdcp1.ainfo) {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_ainfo,\n\t\t\t\t&input->ainfo_write, &status,\n\t\t\t\thdcp, \"ainfo_write\"))\n\t\t\tgoto out;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status computations_validate_rx_test_for_repeater(\n\t\tstruct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_r0p,\n\t\t\t&input->r0p_read, &status,\n\t\t\thdcp, \"r0p_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp1_validate_rx,\n\t\t\t&input->rx_validation, &status,\n\t\t\thdcp, \"rx_validation\"))\n\t\tgoto out;\n\tif (hdcp->connection.is_repeater) {\n\t\tif (!hdcp->connection.link.adjust.hdcp1.postpone_encryption)\n\t\t\tif (!mod_hdcp_execute_and_set(\n\t\t\t\t\tmod_hdcp_hdcp1_enable_encryption,\n\t\t\t\t\t&input->encryption, &status,\n\t\t\t\t\thdcp, \"encryption\"))\n\t\t\t\tgoto out;\n\t} else {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp1_enable_encryption,\n\t\t\t\t&input->encryption, &status,\n\t\t\t\thdcp, \"encryption\"))\n\t\t\tgoto out;\n\t\tif (is_dp_mst_hdcp(hdcp))\n\t\t\tif (!mod_hdcp_execute_and_set(\n\t\t\t\t\tmod_hdcp_hdcp1_enable_dp_stream_encryption,\n\t\t\t\t\t&input->stream_encryption_dp, &status,\n\t\t\t\t\thdcp, \"stream_encryption_dp\"))\n\t\t\t\tgoto out;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status authenticated(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tmod_hdcp_execute_and_set(mod_hdcp_hdcp1_link_maintenance,\n\t\t\t&input->link_maintenance, &status,\n\t\t\thdcp, \"link_maintenance\");\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status wait_for_ready(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,\n\t\t\t\t&input->bstatus_read, &status,\n\t\t\t\thdcp, \"bstatus_read\"))\n\t\t\tgoto out;\n\t\tif (!mod_hdcp_execute_and_set(check_link_integrity_dp,\n\t\t\t\t&input->link_integrity_check, &status,\n\t\t\t\thdcp, \"link_integrity_check\"))\n\t\t\tgoto out;\n\t\tif (!mod_hdcp_execute_and_set(check_no_reauthentication_request_dp,\n\t\t\t\t&input->reauth_request_check, &status,\n\t\t\t\thdcp, \"reauth_request_check\"))\n\t\t\tgoto out;\n\t} else {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bcaps,\n\t\t\t\t&input->bcaps_read, &status,\n\t\t\t\thdcp, \"bcaps_read\"))\n\t\t\tgoto out;\n\t}\n\tif (!mod_hdcp_execute_and_set(check_ksv_ready,\n\t\t\t&input->ready_check, &status,\n\t\t\thdcp, \"ready_check\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status read_ksv_list(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tuint8_t device_count;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_binfo,\n\t\t\t\t&input->binfo_read_dp, &status,\n\t\t\t\thdcp, \"binfo_read_dp\"))\n\t\t\tgoto out;\n\t} else {\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,\n\t\t\t\t&input->bstatus_read, &status,\n\t\t\t\thdcp, \"bstatus_read\"))\n\t\t\tgoto out;\n\t}\n\tif (!mod_hdcp_execute_and_set(check_no_max_cascade,\n\t\t\t&input->max_cascade_check, &status,\n\t\t\thdcp, \"max_cascade_check\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_no_max_devs,\n\t\t\t&input->max_devs_check, &status,\n\t\t\thdcp, \"max_devs_check\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_device_count,\n\t\t\t&input->device_count_check, &status,\n\t\t\thdcp, \"device_count_check\"))\n\t\tgoto out;\n\tdevice_count = get_device_count(hdcp);\n\thdcp->auth.msg.hdcp1.ksvlist_size = device_count*5;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_ksvlist,\n\t\t\t&input->ksvlist_read, &status,\n\t\t\thdcp, \"ksvlist_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_vp,\n\t\t\t&input->vp_read, &status,\n\t\t\thdcp, \"vp_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp1_validate_ksvlist_vp,\n\t\t\t&input->ksvlist_vp_validation, &status,\n\t\t\thdcp, \"ksvlist_vp_validation\"))\n\t\tgoto out;\n\tif (input->encryption != PASS)\n\t\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp1_enable_encryption,\n\t\t\t\t&input->encryption, &status,\n\t\t\t\thdcp, \"encryption\"))\n\t\t\tgoto out;\n\tif (is_dp_mst_hdcp(hdcp))\n\t\tif (!mod_hdcp_execute_and_set(\n\t\t\t\tmod_hdcp_hdcp1_enable_dp_stream_encryption,\n\t\t\t\t&input->stream_encryption_dp, &status,\n\t\t\t\thdcp, \"stream_encryption_dp\"))\n\t\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status determine_rx_hdcp_capable_dp(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bcaps,\n\t\t\t&input->bcaps_read, &status,\n\t\t\thdcp, \"bcaps_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_hdcp_capable_dp,\n\t\t\t&input->hdcp_capable_dp, &status,\n\t\t\thdcp, \"hdcp_capable_dp\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status wait_for_r0_prime_dp(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_bstatus,\n\t\t\t&input->bstatus_read, &status,\n\t\t\thdcp, \"bstatus_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_r0p_available_dp,\n\t\t\t&input->r0p_available_dp, &status,\n\t\t\thdcp, \"r0p_available_dp\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status authenticated_dp(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (status == MOD_HDCP_STATUS_SUCCESS)\n\t\tmod_hdcp_execute_and_set(mod_hdcp_read_bstatus,\n\t\t\t\t&input->bstatus_read, &status,\n\t\t\t\thdcp, \"bstatus_read\");\n\tif (status == MOD_HDCP_STATUS_SUCCESS)\n\t\tmod_hdcp_execute_and_set(check_link_integrity_dp,\n\t\t\t\t&input->link_integrity_check, &status,\n\t\t\t\thdcp, \"link_integrity_check\");\n\tif (status == MOD_HDCP_STATUS_SUCCESS)\n\t\tmod_hdcp_execute_and_set(check_no_reauthentication_request_dp,\n\t\t\t\t&input->reauth_request_check, &status,\n\t\t\t\thdcp, \"reauth_request_check\");\nout:\n\treturn status;\n}\n\nuint8_t mod_hdcp_execute_and_set(\n\t\tmod_hdcp_action func, uint8_t *flag,\n\t\tenum mod_hdcp_status *status, struct mod_hdcp *hdcp, char *str)\n{\n\t*status = func(hdcp);\n\tif (*status == MOD_HDCP_STATUS_SUCCESS && *flag != PASS) {\n\t\tHDCP_INPUT_PASS_TRACE(hdcp, str);\n\t\t*flag = PASS;\n\t} else if (*status != MOD_HDCP_STATUS_SUCCESS && *flag != FAIL) {\n\t\tHDCP_INPUT_FAIL_TRACE(hdcp, str);\n\t\t*flag = FAIL;\n\t}\n\treturn (*status == MOD_HDCP_STATUS_SUCCESS);\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_execution(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tswitch (current_state(hdcp)) {\n\tcase H1_A0_WAIT_FOR_ACTIVE_RX:\n\t\tstatus = wait_for_active_rx(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H1_A1_EXCHANGE_KSVS:\n\t\tstatus = exchange_ksvs(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H1_A2_COMPUTATIONS_A3_VALIDATE_RX_A6_TEST_FOR_REPEATER:\n\t\tstatus = computations_validate_rx_test_for_repeater(hdcp,\n\t\t\t\tevent_ctx, input);\n\t\tbreak;\n\tcase H1_A45_AUTHENTICATED:\n\t\tstatus = authenticated(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H1_A8_WAIT_FOR_READY:\n\t\tstatus = wait_for_ready(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H1_A9_READ_KSV_LIST:\n\t\tstatus = read_ksv_list(hdcp, event_ctx, input);\n\t\tbreak;\n\tdefault:\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_dp_execution(struct mod_hdcp *hdcp,\n\t\t\t\t\t\t struct mod_hdcp_event_context *event_ctx,\n\t\t\t\t\t\t struct mod_hdcp_transition_input_hdcp1 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tswitch (current_state(hdcp)) {\n\tcase D1_A0_DETERMINE_RX_HDCP_CAPABLE:\n\t\tstatus = determine_rx_hdcp_capable_dp(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A1_EXCHANGE_KSVS:\n\t\tstatus = exchange_ksvs(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A23_WAIT_FOR_R0_PRIME:\n\t\tstatus = wait_for_r0_prime_dp(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A2_COMPUTATIONS_A3_VALIDATE_RX_A5_TEST_FOR_REPEATER:\n\t\tstatus = computations_validate_rx_test_for_repeater(\n\t\t\t\thdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A4_AUTHENTICATED:\n\t\tstatus = authenticated_dp(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A6_WAIT_FOR_READY:\n\t\tstatus = wait_for_ready(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D1_A7_READ_KSV_LIST:\n\t\tstatus = read_ksv_list(hdcp, event_ctx, input);\n\t\tbreak;\n\tdefault:\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}