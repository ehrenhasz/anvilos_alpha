{
  "module_name": "freesync.c",
  "hash_id": "775165e6d6a17943602667076a96f1d0f30c1ca495537a0d36be380f18bf1e7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/freesync/freesync.c",
  "human_readable_source": " \n\n#include \"dm_services.h\"\n#include \"dc.h\"\n#include \"mod_freesync.h\"\n#include \"core_types.h\"\n\n#define MOD_FREESYNC_MAX_CONCURRENT_STREAMS  32\n\n#define MIN_REFRESH_RANGE 10\n \n#define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)\n \n#define RENDER_TIMES_MAX_COUNT 10\n \n#define BTR_MAX_MARGIN 2500\n \n#define BTR_DRIFT_MARGIN 2000\n \n#define FIXED_REFRESH_EXIT_MARGIN_IN_HZ 1\n \n#define FIXED_REFRESH_ENTER_FRAME_COUNT 5\n#define FIXED_REFRESH_EXIT_FRAME_COUNT 10\n \n#define VSYNCS_BETWEEN_FLIP_THRESHOLD 2\n#define FREESYNC_CONSEC_FLIP_AFTER_VSYNC 5\n#define FREESYNC_VSYNC_TO_FLIP_DELTA_IN_US 500\n\nstruct core_freesync {\n\tstruct mod_freesync public;\n\tstruct dc *dc;\n};\n\n#define MOD_FREESYNC_TO_CORE(mod_freesync)\\\n\t\tcontainer_of(mod_freesync, struct core_freesync, public)\n\nstruct mod_freesync *mod_freesync_create(struct dc *dc)\n{\n\tstruct core_freesync *core_freesync =\n\t\t\tkzalloc(sizeof(struct core_freesync), GFP_KERNEL);\n\n\tif (core_freesync == NULL)\n\t\tgoto fail_alloc_context;\n\n\tif (dc == NULL)\n\t\tgoto fail_construct;\n\n\tcore_freesync->dc = dc;\n\treturn &core_freesync->public;\n\nfail_construct:\n\tkfree(core_freesync);\n\nfail_alloc_context:\n\treturn NULL;\n}\n\nvoid mod_freesync_destroy(struct mod_freesync *mod_freesync)\n{\n\tstruct core_freesync *core_freesync = NULL;\n\tif (mod_freesync == NULL)\n\t\treturn;\n\tcore_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);\n\tkfree(core_freesync);\n}\n\n#if 0  \nstatic unsigned int calc_refresh_in_uhz_from_duration(\n\t\tunsigned int duration_in_ns)\n{\n\tunsigned int refresh_in_uhz =\n\t\t\t((unsigned int)(div64_u64((1000000000ULL * 1000000),\n\t\t\t\t\tduration_in_ns)));\n\treturn refresh_in_uhz;\n}\n#endif\n\nstatic unsigned int calc_duration_in_us_from_refresh_in_uhz(\n\t\tunsigned int refresh_in_uhz)\n{\n\tunsigned int duration_in_us =\n\t\t\t((unsigned int)(div64_u64((1000000000ULL * 1000),\n\t\t\t\t\trefresh_in_uhz)));\n\treturn duration_in_us;\n}\n\nstatic unsigned int calc_duration_in_us_from_v_total(\n\t\tconst struct dc_stream_state *stream,\n\t\tconst struct mod_vrr_params *in_vrr,\n\t\tunsigned int v_total)\n{\n\tunsigned int duration_in_us =\n\t\t\t(unsigned int)(div64_u64(((unsigned long long)(v_total)\n\t\t\t\t* 10000) * stream->timing.h_total,\n\t\t\t\t\tstream->timing.pix_clk_100hz));\n\n\treturn duration_in_us;\n}\n\nunsigned int mod_freesync_calc_v_total_from_refresh(\n\t\tconst struct dc_stream_state *stream,\n\t\tunsigned int refresh_in_uhz)\n{\n\tunsigned int v_total;\n\tunsigned int frame_duration_in_ns;\n\n\tframe_duration_in_ns =\n\t\t\t((unsigned int)(div64_u64((1000000000ULL * 1000000),\n\t\t\t\t\trefresh_in_uhz)));\n\n\tv_total = div64_u64(div64_u64(((unsigned long long)(\n\t\t\tframe_duration_in_ns) * (stream->timing.pix_clk_100hz / 10)),\n\t\t\tstream->timing.h_total), 1000000);\n\n\t \n\tif (v_total < stream->timing.v_total) {\n\t\tASSERT(v_total < stream->timing.v_total);\n\t\tv_total = stream->timing.v_total;\n\t}\n\n\treturn v_total;\n}\n\nstatic unsigned int calc_v_total_from_duration(\n\t\tconst struct dc_stream_state *stream,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tunsigned int duration_in_us)\n{\n\tunsigned int v_total = 0;\n\n\tif (duration_in_us < vrr->min_duration_in_us)\n\t\tduration_in_us = vrr->min_duration_in_us;\n\n\tif (duration_in_us > vrr->max_duration_in_us)\n\t\tduration_in_us = vrr->max_duration_in_us;\n\n\tif (dc_is_hdmi_signal(stream->signal)) {\n\t\tuint32_t h_total_up_scaled;\n\n\t\th_total_up_scaled = stream->timing.h_total * 10000;\n\t\tv_total = div_u64((unsigned long long)duration_in_us\n\t\t\t\t\t* stream->timing.pix_clk_100hz + (h_total_up_scaled - 1),\n\t\t\t\t\th_total_up_scaled);\n\t} else {\n\t\tv_total = div64_u64(div64_u64(((unsigned long long)(\n\t\t\t\t\tduration_in_us) * (stream->timing.pix_clk_100hz / 10)),\n\t\t\t\t\tstream->timing.h_total), 1000);\n\t}\n\n\t \n\tif (v_total < stream->timing.v_total) {\n\t\tASSERT(v_total < stream->timing.v_total);\n\t\tv_total = stream->timing.v_total;\n\t}\n\n\treturn v_total;\n}\n\nstatic void update_v_total_for_static_ramp(\n\t\tstruct core_freesync *core_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tunsigned int v_total = 0;\n\tunsigned int current_duration_in_us =\n\t\t\tcalc_duration_in_us_from_v_total(\n\t\t\t\tstream, in_out_vrr,\n\t\t\t\tin_out_vrr->adjust.v_total_max);\n\tunsigned int target_duration_in_us =\n\t\t\tcalc_duration_in_us_from_refresh_in_uhz(\n\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz);\n\tbool ramp_direction_is_up = (current_duration_in_us >\n\t\t\t\ttarget_duration_in_us) ? true : false;\n\n\t \n\tunsigned int frame_duration_ratio = div64_u64(1000000,\n\t\t(1000 +  div64_u64(((unsigned long long)(\n\t\tSTATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME) *\n\t\tcurrent_duration_in_us),\n\t\t1000000)));\n\n\t \n\tunsigned int frame_duration_delta = div64_u64(((unsigned long long)(\n\t\tcurrent_duration_in_us) *\n\t\t(1000 - frame_duration_ratio)), 1000);\n\n\t \n\tunsigned int ramp_rate_interpolated = div64_u64(((unsigned long long)(\n\t\tframe_duration_delta) * current_duration_in_us), 16666);\n\n\t \n\tif (ramp_direction_is_up) {\n\t\t \n\t\tcurrent_duration_in_us -= ramp_rate_interpolated;\n\n\t\t \n\t\tif (current_duration_in_us <= target_duration_in_us) {\n\t\t\tin_out_vrr->fixed.ramping_active = false;\n\t\t\tin_out_vrr->fixed.ramping_done = true;\n\t\t\tcurrent_duration_in_us =\n\t\t\t\tcalc_duration_in_us_from_refresh_in_uhz(\n\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz);\n\t\t}\n\t \n\t} else {\n\t\t \n\t\tcurrent_duration_in_us += ramp_rate_interpolated;\n\n\t\t \n\t\tif (current_duration_in_us >= target_duration_in_us) {\n\t\t\tin_out_vrr->fixed.ramping_active = false;\n\t\t\tin_out_vrr->fixed.ramping_done = true;\n\t\t\tcurrent_duration_in_us =\n\t\t\t\tcalc_duration_in_us_from_refresh_in_uhz(\n\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz);\n\t\t}\n\t}\n\n\tv_total = div64_u64(div64_u64(((unsigned long long)(\n\t\t\tcurrent_duration_in_us) * (stream->timing.pix_clk_100hz / 10)),\n\t\t\t\tstream->timing.h_total), 1000);\n\n\t \n\tif (v_total < stream->timing.v_total)\n\t\tv_total = stream->timing.v_total;\n\n\tin_out_vrr->adjust.v_total_min = v_total;\n\tin_out_vrr->adjust.v_total_max = v_total;\n}\n\nstatic void apply_below_the_range(struct core_freesync *core_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tunsigned int last_render_time_in_us,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tunsigned int inserted_frame_duration_in_us = 0;\n\tunsigned int mid_point_frames_ceil = 0;\n\tunsigned int mid_point_frames_floor = 0;\n\tunsigned int frame_time_in_us = 0;\n\tunsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;\n\tunsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;\n\tunsigned int frames_to_insert = 0;\n\tunsigned int delta_from_mid_point_delta_in_us;\n\tunsigned int max_render_time_in_us =\n\t\t\tin_out_vrr->max_duration_in_us - in_out_vrr->btr.margin_in_us;\n\n\t \n\tif ((last_render_time_in_us + in_out_vrr->btr.margin_in_us / 2) < max_render_time_in_us) {\n\t\t \n\t\tif (in_out_vrr->btr.btr_active) {\n\t\t\tin_out_vrr->btr.frame_counter = 0;\n\t\t\tin_out_vrr->btr.btr_active = false;\n\t\t}\n\t} else if (last_render_time_in_us > (max_render_time_in_us + in_out_vrr->btr.margin_in_us / 2)) {\n\t\t \n\t\tif (!in_out_vrr->btr.btr_active) {\n\t\t\tin_out_vrr->btr.btr_active = true;\n\t\t}\n\t}\n\n\t \n\tif (!in_out_vrr->btr.btr_active) {\n\t\tin_out_vrr->btr.inserted_duration_in_us = 0;\n\t\tin_out_vrr->btr.frames_to_insert = 0;\n\t\tin_out_vrr->btr.frame_counter = 0;\n\n\t\t \n\t\tin_out_vrr->adjust.v_total_min =\n\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->max_refresh_in_uhz);\n\t\tin_out_vrr->adjust.v_total_max =\n\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->min_refresh_in_uhz);\n\t \n\t} else {\n\n\t\t \n\t\tmid_point_frames_ceil = (last_render_time_in_us +\n\t\t\t\tin_out_vrr->btr.mid_point_in_us - 1) /\n\t\t\t\t\tin_out_vrr->btr.mid_point_in_us;\n\n\t\tif (mid_point_frames_ceil > 0) {\n\t\t\tframe_time_in_us = last_render_time_in_us /\n\t\t\t\tmid_point_frames_ceil;\n\t\t\tdelta_from_mid_point_in_us_1 =\n\t\t\t\t(in_out_vrr->btr.mid_point_in_us >\n\t\t\t\tframe_time_in_us) ?\n\t\t\t\t(in_out_vrr->btr.mid_point_in_us - frame_time_in_us) :\n\t\t\t\t(frame_time_in_us - in_out_vrr->btr.mid_point_in_us);\n\t\t}\n\n\t\t \n\t\tmid_point_frames_floor = last_render_time_in_us /\n\t\t\t\tin_out_vrr->btr.mid_point_in_us;\n\n\t\tif (mid_point_frames_floor > 0) {\n\n\t\t\tframe_time_in_us = last_render_time_in_us /\n\t\t\t\tmid_point_frames_floor;\n\t\t\tdelta_from_mid_point_in_us_2 =\n\t\t\t\t(in_out_vrr->btr.mid_point_in_us >\n\t\t\t\tframe_time_in_us) ?\n\t\t\t\t(in_out_vrr->btr.mid_point_in_us - frame_time_in_us) :\n\t\t\t\t(frame_time_in_us - in_out_vrr->btr.mid_point_in_us);\n\t\t}\n\n\t\t \n\t\tif (mid_point_frames_ceil &&\n\t\t    (last_render_time_in_us / mid_point_frames_ceil) <\n\t\t    in_out_vrr->min_duration_in_us) {\n\t\t\t \n\t\t\tframes_to_insert = mid_point_frames_floor;\n\t\t} else if (mid_point_frames_floor < 2) {\n\t\t\t \n\t\t\tframes_to_insert = mid_point_frames_ceil;\n\t\t} else if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {\n\t\t\t \n\t\t\tframes_to_insert = mid_point_frames_ceil;\n\t\t} else {\n\t\t\t \n\t\t\tframes_to_insert = mid_point_frames_floor;\n\t\t}\n\n\t\t \n\t\tif (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {\n\t\t\tdelta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_2 -\n\t\t\t\t\tdelta_from_mid_point_in_us_1;\n\t\t} else {\n\t\t\tdelta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_1 -\n\t\t\t\t\tdelta_from_mid_point_in_us_2;\n\t\t}\n\t\tif (in_out_vrr->btr.frames_to_insert != 0 &&\n\t\t\t\tdelta_from_mid_point_delta_in_us < BTR_DRIFT_MARGIN) {\n\t\t\tif (((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) <\n\t\t\t\t\tmax_render_time_in_us) &&\n\t\t\t\t((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) >\n\t\t\t\t\tin_out_vrr->min_duration_in_us))\n\t\t\t\tframes_to_insert = in_out_vrr->btr.frames_to_insert;\n\t\t}\n\n\t\t \n\t\tif (frames_to_insert &&\n\t\t    (last_render_time_in_us / frames_to_insert) <\n\t\t    in_out_vrr->min_duration_in_us){\n\t\t\tframes_to_insert -= (frames_to_insert > 1) ?\n\t\t\t\t\t1 : 0;\n\t\t}\n\n\t\tif (frames_to_insert > 0)\n\t\t\tinserted_frame_duration_in_us = last_render_time_in_us /\n\t\t\t\t\t\t\tframes_to_insert;\n\n\t\tif (inserted_frame_duration_in_us < in_out_vrr->min_duration_in_us)\n\t\t\tinserted_frame_duration_in_us = in_out_vrr->min_duration_in_us;\n\n\t\t \n\t\tin_out_vrr->btr.inserted_duration_in_us =\n\t\t\tinserted_frame_duration_in_us;\n\t\tin_out_vrr->btr.frames_to_insert = frames_to_insert;\n\t\tin_out_vrr->btr.frame_counter = frames_to_insert;\n\t}\n}\n\nstatic void apply_fixed_refresh(struct core_freesync *core_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tunsigned int last_render_time_in_us,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tbool update = false;\n\tunsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;\n\n\t \n\tunsigned int exit_refresh_rate_in_milli_hz = ((1000000000/max_render_time_in_us)\n\t\t\t+ (1000*FIXED_REFRESH_EXIT_MARGIN_IN_HZ));\n\tunsigned int exit_frame_duration_in_us = 1000000000/exit_refresh_rate_in_milli_hz;\n\n\tif (last_render_time_in_us < exit_frame_duration_in_us) {\n\t\t \n\t\tif (in_out_vrr->fixed.fixed_active) {\n\t\t\tin_out_vrr->fixed.frame_counter++;\n\n\t\t\tif (in_out_vrr->fixed.frame_counter >\n\t\t\t\t\tFIXED_REFRESH_EXIT_FRAME_COUNT) {\n\t\t\t\tin_out_vrr->fixed.frame_counter = 0;\n\t\t\t\tin_out_vrr->fixed.fixed_active = false;\n\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz = 0;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t} else\n\t\t\tin_out_vrr->fixed.frame_counter = 0;\n\t} else if (last_render_time_in_us > max_render_time_in_us) {\n\t\t \n\t\tif (!in_out_vrr->fixed.fixed_active) {\n\t\t\tin_out_vrr->fixed.frame_counter++;\n\n\t\t\tif (in_out_vrr->fixed.frame_counter >\n\t\t\t\t\tFIXED_REFRESH_ENTER_FRAME_COUNT) {\n\t\t\t\tin_out_vrr->fixed.frame_counter = 0;\n\t\t\t\tin_out_vrr->fixed.fixed_active = true;\n\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz =\n\t\t\t\t\t\tin_out_vrr->max_refresh_in_uhz;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t} else\n\t\t\tin_out_vrr->fixed.frame_counter = 0;\n\t}\n\n\tif (update) {\n\t\tif (in_out_vrr->fixed.fixed_active) {\n\t\t\tin_out_vrr->adjust.v_total_min =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(\n\t\t\t\tstream, in_out_vrr->max_refresh_in_uhz);\n\t\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\t\tin_out_vrr->adjust.v_total_min;\n\t\t} else {\n\t\t\tin_out_vrr->adjust.v_total_min =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\t\tin_out_vrr->max_refresh_in_uhz);\n\t\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\t\tin_out_vrr->min_refresh_in_uhz);\n\t\t}\n\t}\n}\n\nstatic void determine_flip_interval_workaround_req(struct mod_vrr_params *in_vrr,\n\t\tunsigned int curr_time_stamp_in_us)\n{\n\tin_vrr->flip_interval.vsync_to_flip_in_us = curr_time_stamp_in_us -\n\t\t\tin_vrr->flip_interval.v_update_timestamp_in_us;\n\n\t \n\tif (in_vrr->flip_interval.flip_interval_workaround_active &&\n\t\t\tin_vrr->flip_interval.vsyncs_between_flip < VSYNCS_BETWEEN_FLIP_THRESHOLD &&\n\t\t\tin_vrr->flip_interval.vsync_to_flip_in_us > FREESYNC_VSYNC_TO_FLIP_DELTA_IN_US) {\n\t\tin_vrr->flip_interval.flip_interval_detect_counter = 0;\n\t\tin_vrr->flip_interval.program_flip_interval_workaround = true;\n\t\tin_vrr->flip_interval.flip_interval_workaround_active = false;\n\t} else {\n\t\t \n\t\tif (in_vrr->flip_interval.vsyncs_between_flip >= VSYNCS_BETWEEN_FLIP_THRESHOLD &&\n\t\t\t\tin_vrr->flip_interval.vsync_to_flip_in_us < FREESYNC_VSYNC_TO_FLIP_DELTA_IN_US) {\n\t\t\t \n\t\t\tin_vrr->flip_interval.flip_interval_detect_counter++;\n\t\t\tif (in_vrr->flip_interval.flip_interval_detect_counter > FREESYNC_CONSEC_FLIP_AFTER_VSYNC) {\n\t\t\t\t \n\t\t\t\tin_vrr->flip_interval.program_flip_interval_workaround = true;\n\t\t\t\tin_vrr->flip_interval.flip_interval_workaround_active = true;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tin_vrr->flip_interval.flip_interval_detect_counter = 0;\n\t\t}\n\t}\n\n\tin_vrr->flip_interval.vsyncs_between_flip = 0;\n}\n\nstatic bool vrr_settings_require_update(struct core_freesync *core_freesync,\n\t\tstruct mod_freesync_config *in_config,\n\t\tunsigned int min_refresh_in_uhz,\n\t\tunsigned int max_refresh_in_uhz,\n\t\tstruct mod_vrr_params *in_vrr)\n{\n\tif (in_vrr->state != in_config->state) {\n\t\treturn true;\n\t} else if (in_vrr->state == VRR_STATE_ACTIVE_FIXED &&\n\t\t\tin_vrr->fixed.target_refresh_in_uhz !=\n\t\t\t\t\tin_config->fixed_refresh_in_uhz) {\n\t\treturn true;\n\t} else if (in_vrr->min_refresh_in_uhz != min_refresh_in_uhz) {\n\t\treturn true;\n\t} else if (in_vrr->max_refresh_in_uhz != max_refresh_in_uhz) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tunsigned int *vmin,\n\t\tunsigned int *vmax)\n{\n\t*vmin = stream->adjust.v_total_min;\n\t*vmax = stream->adjust.v_total_max;\n\n\treturn true;\n}\n\nbool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,\n\t\tstruct dc_stream_state *stream,\n\t\tunsigned int *nom_v_pos,\n\t\tunsigned int *v_pos)\n{\n\tstruct core_freesync *core_freesync = NULL;\n\tstruct crtc_position position;\n\n\tif (mod_freesync == NULL)\n\t\treturn false;\n\n\tcore_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);\n\n\tif (dc_stream_get_crtc_position(core_freesync->dc, &stream, 1,\n\t\t\t\t\t&position.vertical_count,\n\t\t\t\t\t&position.nominal_vcount)) {\n\n\t\t*nom_v_pos = position.nominal_vcount;\n\t\t*v_pos = position.vertical_count;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void build_vrr_infopacket_data_v1(const struct mod_vrr_params *vrr,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool freesync_on_desktop)\n{\n\t \n\tinfopacket->sb[1] = 0x1A;\n\n\t \n\tinfopacket->sb[2] = 0x00;\n\n\t \n\tinfopacket->sb[3] = 0x00;\n\n\t \n\n\t \n\n\t \n\n\t \n\tif (vrr->state != VRR_STATE_UNSUPPORTED)\n\t\tinfopacket->sb[6] |= 0x01;\n\n\t \n\tif (vrr->state != VRR_STATE_DISABLED &&\n\t\t\tvrr->state != VRR_STATE_UNSUPPORTED)\n\t\tinfopacket->sb[6] |= 0x02;\n\n\tif (freesync_on_desktop) {\n\t\t \n\t\tif (vrr->state != VRR_STATE_DISABLED &&\n\t\t\tvrr->state != VRR_STATE_UNSUPPORTED)\n\t\t\tinfopacket->sb[6] |= 0x04;\n\t} else {\n\t\tif (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||\n\t\t\tvrr->state == VRR_STATE_ACTIVE_FIXED)\n\t\t\tinfopacket->sb[6] |= 0x04;\n\t}\n\n\t \n\t \n\tif (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||\n\t\t\tvrr->state == VRR_STATE_ACTIVE_FIXED) {\n\t\tinfopacket->sb[7] = (unsigned char)((vrr->min_refresh_in_uhz + 500000) / 1000000);\n\t} else {\n\t\tinfopacket->sb[7] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);\n\t}\n\n\t \n\tinfopacket->sb[8] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);\n}\n\nstatic void build_vrr_infopacket_data_v3(const struct mod_vrr_params *vrr,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool freesync_on_desktop)\n{\n\tunsigned int min_refresh;\n\tunsigned int max_refresh;\n\tunsigned int fixed_refresh;\n\tunsigned int min_programmed;\n\tunsigned int max_programmed;\n\n\t \n\tinfopacket->sb[1] = 0x1A;\n\n\t \n\tinfopacket->sb[2] = 0x00;\n\n\t \n\tinfopacket->sb[3] = 0x00;\n\n\t \n\n\t \n\n\t \n\n\t \n\tif (vrr->state != VRR_STATE_UNSUPPORTED)\n\t\tinfopacket->sb[6] |= 0x01;\n\n\t \n\tif (vrr->state != VRR_STATE_DISABLED &&\n\t\t\tvrr->state != VRR_STATE_UNSUPPORTED)\n\t\tinfopacket->sb[6] |= 0x02;\n\n\t \n\tif (freesync_on_desktop) {\n\t\tif (vrr->state != VRR_STATE_DISABLED &&\n\t\t\tvrr->state != VRR_STATE_UNSUPPORTED)\n\t\t\tinfopacket->sb[6] |= 0x04;\n\t} else {\n\t\tif (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||\n\t\t\tvrr->state == VRR_STATE_ACTIVE_FIXED)\n\t\t\tinfopacket->sb[6] |= 0x04;\n\t}\n\n\tmin_refresh = (vrr->min_refresh_in_uhz + 500000) / 1000000;\n\tmax_refresh = (vrr->max_refresh_in_uhz + 500000) / 1000000;\n\tfixed_refresh = (vrr->fixed_refresh_in_uhz + 500000) / 1000000;\n\n\tmin_programmed = (vrr->state == VRR_STATE_ACTIVE_FIXED) ? fixed_refresh :\n\t\t\t(vrr->state == VRR_STATE_ACTIVE_VARIABLE) ? min_refresh :\n\t\t\t(vrr->state == VRR_STATE_INACTIVE) ? min_refresh :\n\t\t\tmax_refresh;  \n\n\tmax_programmed = (vrr->state == VRR_STATE_ACTIVE_FIXED) ? fixed_refresh :\n\t\t\t(vrr->state == VRR_STATE_ACTIVE_VARIABLE) ? max_refresh :\n\t\t\tmax_refresh; \n\n\t \n\tinfopacket->sb[7] = min_programmed & 0xFF;\n\n\t \n\tinfopacket->sb[8] = max_programmed & 0xFF;\n\n\t \n\tinfopacket->sb[11] = (min_programmed >> 8) & 0x03;\n\n\t \n\tinfopacket->sb[12] = (max_programmed >> 8) & 0x03;\n\n\t \n\tinfopacket->sb[16] = (vrr->state == VRR_STATE_ACTIVE_FIXED) ? 1 : 0;\n}\n\nstatic void build_vrr_infopacket_fs2_data(enum color_transfer_func app_tf,\n\t\tstruct dc_info_packet *infopacket)\n{\n\tif (app_tf != TRANSFER_FUNC_UNKNOWN) {\n\t\tinfopacket->valid = true;\n\n\t\tif (app_tf != TRANSFER_FUNC_PQ2084) {\n\t\t\tinfopacket->sb[6] |= 0x08;   \n\t\t\tif (app_tf == TRANSFER_FUNC_GAMMA_22)\n\t\t\t\tinfopacket->sb[9] |= 0x04;   \n\t\t}\n\t}\n}\n\nstatic void build_vrr_infopacket_header_v1(enum signal_type signal,\n\t\tstruct dc_info_packet *infopacket,\n\t\tunsigned int *payload_size)\n{\n\tif (dc_is_hdmi_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb1 = 0x01;\n\n\t\t \n\t\tinfopacket->hb2 = 0x08;\n\n\t\t*payload_size = 0x08;\n\n\t} else if (dc_is_dp_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = 0x00;\n\n\t\t \n\t\tinfopacket->hb1 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb2 = 0x1B;\n\n\t\t \n\t\tinfopacket->hb3 = 0x04;\n\n\t\t*payload_size = 0x1B;\n\t}\n}\n\nstatic void build_vrr_infopacket_header_v2(enum signal_type signal,\n\t\tstruct dc_info_packet *infopacket,\n\t\tunsigned int *payload_size)\n{\n\tif (dc_is_hdmi_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb1 = 0x02;\n\n\t\t \n\t\tinfopacket->hb2 = 0x09;\n\n\t\t*payload_size = 0x09;\n\t} else if (dc_is_dp_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = 0x00;\n\n\t\t \n\t\tinfopacket->hb1 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb2 = 0x1B;\n\n\t\t \n\t\tinfopacket->hb3 = 0x08;\n\n\t\t*payload_size = 0x1B;\n\t}\n}\n\nstatic void build_vrr_infopacket_header_v3(enum signal_type signal,\n\t\tstruct dc_info_packet *infopacket,\n\t\tunsigned int *payload_size)\n{\n\tunsigned char version;\n\n\tversion = 3;\n\tif (dc_is_hdmi_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb1 = version;\n\n\t\t \n\t\tinfopacket->hb2 = 0x10;\n\n\t\t*payload_size = 0x10;\n\t} else if (dc_is_dp_signal(signal)) {\n\n\t\t \n\n\t\t \n\t\tinfopacket->hb0 = 0x00;\n\n\t\t \n\t\tinfopacket->hb1 = DC_HDMI_INFOFRAME_TYPE_SPD;\n\n\t\t \n\t\tinfopacket->hb2 = 0x1B;\n\n\t\t \n\n\t\tinfopacket->hb3 = (version & 0x3F) << 2;\n\n\t\t*payload_size = 0x1B;\n\t}\n}\n\nstatic void build_vrr_infopacket_checksum(unsigned int *payload_size,\n\t\tstruct dc_info_packet *infopacket)\n{\n\t \n\tunsigned int idx = 0;\n\tunsigned char checksum = 0;\n\n\tchecksum += infopacket->hb0;\n\tchecksum += infopacket->hb1;\n\tchecksum += infopacket->hb2;\n\tchecksum += infopacket->hb3;\n\n\tfor (idx = 1; idx <= *payload_size; idx++)\n\t\tchecksum += infopacket->sb[idx];\n\n\t \n\tinfopacket->sb[0] = (unsigned char)(0x100 - checksum);\n\n\tinfopacket->valid = true;\n}\n\nstatic void build_vrr_infopacket_v1(enum signal_type signal,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool freesync_on_desktop)\n{\n\t \n\tunsigned int payload_size = 0;\n\n\tbuild_vrr_infopacket_header_v1(signal, infopacket, &payload_size);\n\tbuild_vrr_infopacket_data_v1(vrr, infopacket, freesync_on_desktop);\n\tbuild_vrr_infopacket_checksum(&payload_size, infopacket);\n\n\tinfopacket->valid = true;\n}\n\nstatic void build_vrr_infopacket_v2(enum signal_type signal,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tenum color_transfer_func app_tf,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool freesync_on_desktop)\n{\n\tunsigned int payload_size = 0;\n\n\tbuild_vrr_infopacket_header_v2(signal, infopacket, &payload_size);\n\tbuild_vrr_infopacket_data_v1(vrr, infopacket, freesync_on_desktop);\n\n\tbuild_vrr_infopacket_fs2_data(app_tf, infopacket);\n\n\tbuild_vrr_infopacket_checksum(&payload_size, infopacket);\n\n\tinfopacket->valid = true;\n}\n\nstatic void build_vrr_infopacket_v3(enum signal_type signal,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tenum color_transfer_func app_tf,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool freesync_on_desktop)\n{\n\tunsigned int payload_size = 0;\n\n\tbuild_vrr_infopacket_header_v3(signal, infopacket, &payload_size);\n\tbuild_vrr_infopacket_data_v3(vrr, infopacket, freesync_on_desktop);\n\n\tbuild_vrr_infopacket_fs2_data(app_tf, infopacket);\n\n\tbuild_vrr_infopacket_checksum(&payload_size, infopacket);\n\n\tinfopacket->valid = true;\n}\n\nstatic void build_vrr_infopacket_sdp_v1_3(enum vrr_packet_type packet_type,\n\t\t\t\t\t\t\t\t\t\tstruct dc_info_packet *infopacket)\n{\n\tuint8_t idx = 0, size = 0;\n\n\tsize = ((packet_type == PACKET_TYPE_FS_V1) ? 0x08 :\n\t\t\t(packet_type == PACKET_TYPE_FS_V3) ? 0x10 :\n\t\t\t\t\t\t\t\t\t\t\t\t0x09);\n\n\tfor (idx = infopacket->hb2; idx > 1; idx--)  \n\t\tinfopacket->sb[idx] = infopacket->sb[idx-1];\n\n\tinfopacket->sb[1] = size;                          \n\tinfopacket->sb[0] = (infopacket->hb3 >> 2) & 0x3F; \n\tinfopacket->hb3   = (0x13 << 2);                   \n\tinfopacket->hb2   = 0x1D;\n}\n\nvoid mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tenum vrr_packet_type packet_type,\n\t\tenum color_transfer_func app_tf,\n\t\tstruct dc_info_packet *infopacket,\n\t\tbool pack_sdp_v1_3)\n{\n\t \n\tif (!vrr->send_info_frame)\n\t\treturn;\n\n\tswitch (packet_type) {\n\tcase PACKET_TYPE_FS_V3:\n\t\tbuild_vrr_infopacket_v3(stream->signal, vrr, app_tf, infopacket, stream->freesync_on_desktop);\n\t\tbreak;\n\tcase PACKET_TYPE_FS_V2:\n\t\tbuild_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket, stream->freesync_on_desktop);\n\t\tbreak;\n\tcase PACKET_TYPE_VRR:\n\tcase PACKET_TYPE_FS_V1:\n\tdefault:\n\t\tbuild_vrr_infopacket_v1(stream->signal, vrr, infopacket, stream->freesync_on_desktop);\n\t}\n\n\tif (true == pack_sdp_v1_3 &&\n\t\ttrue == dc_is_dp_signal(stream->signal) &&\n\t\tpacket_type != PACKET_TYPE_VRR &&\n\t\tpacket_type != PACKET_TYPE_VTEM)\n\t\tbuild_vrr_infopacket_sdp_v1_3(packet_type, infopacket);\n}\n\nvoid mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct mod_freesync_config *in_config,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tstruct core_freesync *core_freesync = NULL;\n\tunsigned long long nominal_field_rate_in_uhz = 0;\n\tunsigned long long rounded_nominal_in_uhz = 0;\n\tunsigned int refresh_range = 0;\n\tunsigned long long min_refresh_in_uhz = 0;\n\tunsigned long long max_refresh_in_uhz = 0;\n\tunsigned long long min_hardware_refresh_in_uhz = 0;\n\n\tif (mod_freesync == NULL)\n\t\treturn;\n\n\tcore_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);\n\n\t \n\tnominal_field_rate_in_uhz =\n\t\t\tmod_freesync_calc_nominal_field_rate(stream);\n\n\tif (stream->ctx->dc->caps.max_v_total != 0 && stream->timing.h_total != 0) {\n\t\tmin_hardware_refresh_in_uhz = div64_u64((stream->timing.pix_clk_100hz * 100000000ULL),\n\t\t\t(stream->timing.h_total * stream->ctx->dc->caps.max_v_total));\n\t}\n\t \n\tmin_refresh_in_uhz = min_hardware_refresh_in_uhz > in_config->min_refresh_in_uhz ?\n\t\tmin_hardware_refresh_in_uhz : in_config->min_refresh_in_uhz;\n\tmax_refresh_in_uhz = in_config->max_refresh_in_uhz;\n\n\t \n\tif (max_refresh_in_uhz > nominal_field_rate_in_uhz)\n\t\tmax_refresh_in_uhz = nominal_field_rate_in_uhz;\n\n\t \n\tif (min_refresh_in_uhz > max_refresh_in_uhz)\n\t\tmin_refresh_in_uhz = max_refresh_in_uhz;\n\n\t \n\trounded_nominal_in_uhz =\n\t\t\tdiv_u64(nominal_field_rate_in_uhz + 50000, 100000) * 100000;\n\tif (in_config->max_refresh_in_uhz == (2 * in_config->min_refresh_in_uhz) &&\n\t\tin_config->max_refresh_in_uhz == rounded_nominal_in_uhz)\n\t\tmin_refresh_in_uhz = div_u64(nominal_field_rate_in_uhz, 2);\n\n\tif (!vrr_settings_require_update(core_freesync,\n\t\t\tin_config, (unsigned int)min_refresh_in_uhz, (unsigned int)max_refresh_in_uhz,\n\t\t\tin_out_vrr))\n\t\treturn;\n\n\tin_out_vrr->state = in_config->state;\n\tin_out_vrr->send_info_frame = in_config->vsif_supported;\n\n\tif (in_config->state == VRR_STATE_UNSUPPORTED) {\n\t\tin_out_vrr->state = VRR_STATE_UNSUPPORTED;\n\t\tin_out_vrr->supported = false;\n\t\tin_out_vrr->adjust.v_total_min = stream->timing.v_total;\n\t\tin_out_vrr->adjust.v_total_max = stream->timing.v_total;\n\n\t\treturn;\n\n\t} else {\n\t\tin_out_vrr->min_refresh_in_uhz = (unsigned int)min_refresh_in_uhz;\n\t\tin_out_vrr->max_duration_in_us =\n\t\t\t\tcalc_duration_in_us_from_refresh_in_uhz(\n\t\t\t\t\t\t(unsigned int)min_refresh_in_uhz);\n\n\t\tin_out_vrr->max_refresh_in_uhz = (unsigned int)max_refresh_in_uhz;\n\t\tin_out_vrr->min_duration_in_us =\n\t\t\t\tcalc_duration_in_us_from_refresh_in_uhz(\n\t\t\t\t\t\t(unsigned int)max_refresh_in_uhz);\n\n\t\tif (in_config->state == VRR_STATE_ACTIVE_FIXED)\n\t\t\tin_out_vrr->fixed_refresh_in_uhz = in_config->fixed_refresh_in_uhz;\n\t\telse\n\t\t\tin_out_vrr->fixed_refresh_in_uhz = 0;\n\n\t\trefresh_range = div_u64(in_out_vrr->max_refresh_in_uhz + 500000, 1000000) -\n+\t\t\t\tdiv_u64(in_out_vrr->min_refresh_in_uhz + 500000, 1000000);\n\n\t\tin_out_vrr->supported = true;\n\t}\n\n\tin_out_vrr->fixed.ramping_active = in_config->ramping;\n\n\tin_out_vrr->btr.btr_enabled = in_config->btr;\n\n\tif (in_out_vrr->max_refresh_in_uhz < (2 * in_out_vrr->min_refresh_in_uhz))\n\t\tin_out_vrr->btr.btr_enabled = false;\n\telse {\n\t\tin_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -\n\t\t\t\t2 * in_out_vrr->min_duration_in_us;\n\t\tif (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)\n\t\t\tin_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;\n\t}\n\n\tin_out_vrr->btr.btr_active = false;\n\tin_out_vrr->btr.inserted_duration_in_us = 0;\n\tin_out_vrr->btr.frames_to_insert = 0;\n\tin_out_vrr->btr.frame_counter = 0;\n\tin_out_vrr->fixed.fixed_active = false;\n\tin_out_vrr->fixed.target_refresh_in_uhz = 0;\n\n\tin_out_vrr->btr.mid_point_in_us =\n\t\t\t\t(in_out_vrr->min_duration_in_us +\n\t\t\t\t in_out_vrr->max_duration_in_us) / 2;\n\n\tif (in_out_vrr->state == VRR_STATE_UNSUPPORTED) {\n\t\tin_out_vrr->adjust.v_total_min = stream->timing.v_total;\n\t\tin_out_vrr->adjust.v_total_max = stream->timing.v_total;\n\t} else if (in_out_vrr->state == VRR_STATE_DISABLED) {\n\t\tin_out_vrr->adjust.v_total_min = stream->timing.v_total;\n\t\tin_out_vrr->adjust.v_total_max = stream->timing.v_total;\n\t} else if (in_out_vrr->state == VRR_STATE_INACTIVE) {\n\t\tin_out_vrr->adjust.v_total_min = stream->timing.v_total;\n\t\tin_out_vrr->adjust.v_total_max = stream->timing.v_total;\n\t} else if (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&\n\t\t\trefresh_range >= MIN_REFRESH_RANGE) {\n\n\t\tin_out_vrr->adjust.v_total_min =\n\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->max_refresh_in_uhz);\n\t\tin_out_vrr->adjust.v_total_max =\n\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->min_refresh_in_uhz);\n\t} else if (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED) {\n\t\tin_out_vrr->fixed.target_refresh_in_uhz =\n\t\t\t\tin_out_vrr->fixed_refresh_in_uhz;\n\t\tif (in_out_vrr->fixed.ramping_active &&\n\t\t\t\tin_out_vrr->fixed.fixed_active) {\n\t\t\t \n\t\t\tin_out_vrr->fixed.fixed_active = true;\n\t\t} else {\n\t\t\tin_out_vrr->fixed.fixed_active = true;\n\t\t\tin_out_vrr->adjust.v_total_min =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\t\tin_out_vrr->fixed.target_refresh_in_uhz);\n\t\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\tin_out_vrr->adjust.v_total_min;\n\t\t}\n\t} else {\n\t\tin_out_vrr->state = VRR_STATE_INACTIVE;\n\t\tin_out_vrr->adjust.v_total_min = stream->timing.v_total;\n\t\tin_out_vrr->adjust.v_total_max = stream->timing.v_total;\n\t}\n}\n\nvoid mod_freesync_handle_preflip(struct mod_freesync *mod_freesync,\n\t\tconst struct dc_plane_state *plane,\n\t\tconst struct dc_stream_state *stream,\n\t\tunsigned int curr_time_stamp_in_us,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tstruct core_freesync *core_freesync = NULL;\n\tunsigned int last_render_time_in_us = 0;\n\n\tif (mod_freesync == NULL)\n\t\treturn;\n\n\tcore_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);\n\n\tif (in_out_vrr->supported &&\n\t\t\tin_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE) {\n\n\t\tlast_render_time_in_us = curr_time_stamp_in_us -\n\t\t\t\tplane->time.prev_update_time_in_us;\n\n\t\tif (in_out_vrr->btr.btr_enabled) {\n\t\t\tapply_below_the_range(core_freesync,\n\t\t\t\t\tstream,\n\t\t\t\t\tlast_render_time_in_us,\n\t\t\t\t\tin_out_vrr);\n\t\t} else {\n\t\t\tapply_fixed_refresh(core_freesync,\n\t\t\t\tstream,\n\t\t\t\tlast_render_time_in_us,\n\t\t\t\tin_out_vrr);\n\t\t}\n\n\t\tdetermine_flip_interval_workaround_req(in_out_vrr,\n\t\t\t\tcurr_time_stamp_in_us);\n\n\t}\n}\n\nvoid mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,\n\t\tconst struct dc_stream_state *stream,\n\t\tstruct mod_vrr_params *in_out_vrr)\n{\n\tstruct core_freesync *core_freesync = NULL;\n\tunsigned int cur_timestamp_in_us;\n\tunsigned long long cur_tick;\n\n\tif ((mod_freesync == NULL) || (stream == NULL) || (in_out_vrr == NULL))\n\t\treturn;\n\n\tcore_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);\n\n\tif (in_out_vrr->supported == false)\n\t\treturn;\n\n\tcur_tick = dm_get_timestamp(core_freesync->dc->ctx);\n\tcur_timestamp_in_us = (unsigned int)\n\t\t\tdiv_u64(dm_get_elapse_time_in_ns(core_freesync->dc->ctx, cur_tick, 0), 1000);\n\n\tin_out_vrr->flip_interval.vsyncs_between_flip++;\n\tin_out_vrr->flip_interval.v_update_timestamp_in_us = cur_timestamp_in_us;\n\n\tif (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&\n\t\t\t(in_out_vrr->flip_interval.flip_interval_workaround_active ||\n\t\t\t(!in_out_vrr->flip_interval.flip_interval_workaround_active &&\n\t\t\tin_out_vrr->flip_interval.program_flip_interval_workaround))) {\n\t\t \n\t\tin_out_vrr->adjust.v_total_min =\n\t\t\tmod_freesync_calc_v_total_from_refresh(\n\t\t\tstream, in_out_vrr->max_refresh_in_uhz);\n\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\tin_out_vrr->adjust.v_total_min;\n\t\tin_out_vrr->flip_interval.program_flip_interval_workaround = false;\n\t\tin_out_vrr->flip_interval.do_flip_interval_workaround_cleanup = true;\n\t\treturn;\n\t}\n\n\tif (in_out_vrr->state != VRR_STATE_ACTIVE_VARIABLE &&\n\t\t\tin_out_vrr->flip_interval.do_flip_interval_workaround_cleanup) {\n\t\tin_out_vrr->flip_interval.do_flip_interval_workaround_cleanup = false;\n\t\tin_out_vrr->flip_interval.flip_interval_detect_counter = 0;\n\t\tin_out_vrr->flip_interval.vsyncs_between_flip = 0;\n\t\tin_out_vrr->flip_interval.vsync_to_flip_in_us = 0;\n\t}\n\n\t \n\n\t \n\tif (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&\n\t\t\t\t\tin_out_vrr->btr.btr_active) {\n\t\t \n\t\tif (in_out_vrr->btr.frames_to_insert ==\n\t\t\t\tin_out_vrr->btr.frame_counter) {\n\t\t\tin_out_vrr->adjust.v_total_min =\n\t\t\t\tcalc_v_total_from_duration(stream,\n\t\t\t\tin_out_vrr,\n\t\t\t\tin_out_vrr->btr.inserted_duration_in_us);\n\t\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\tin_out_vrr->adjust.v_total_min;\n\t\t}\n\n\t\tif (in_out_vrr->btr.frame_counter > 0)\n\t\t\tin_out_vrr->btr.frame_counter--;\n\n\t\t \n\t\tif (in_out_vrr->btr.frame_counter == 0) {\n\t\t\tin_out_vrr->adjust.v_total_min =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->max_refresh_in_uhz);\n\t\t\tin_out_vrr->adjust.v_total_max =\n\t\t\t\tmod_freesync_calc_v_total_from_refresh(stream,\n\t\t\t\tin_out_vrr->min_refresh_in_uhz);\n\t\t}\n\t}\n\n\t \n\tif (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE)\n\t\tin_out_vrr->fixed.ramping_active = false;\n\n\t \n\tif (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED &&\n\t\t\t\tin_out_vrr->fixed.ramping_active) {\n\t\tupdate_v_total_for_static_ramp(\n\t\t\t\tcore_freesync, stream, in_out_vrr);\n\t}\n}\n\nvoid mod_freesync_get_settings(struct mod_freesync *mod_freesync,\n\t\tconst struct mod_vrr_params *vrr,\n\t\tunsigned int *v_total_min, unsigned int *v_total_max,\n\t\tunsigned int *event_triggers,\n\t\tunsigned int *window_min, unsigned int *window_max,\n\t\tunsigned int *lfc_mid_point_in_us,\n\t\tunsigned int *inserted_frames,\n\t\tunsigned int *inserted_duration_in_us)\n{\n\tif (mod_freesync == NULL)\n\t\treturn;\n\n\tif (vrr->supported) {\n\t\t*v_total_min = vrr->adjust.v_total_min;\n\t\t*v_total_max = vrr->adjust.v_total_max;\n\t\t*event_triggers = 0;\n\t\t*lfc_mid_point_in_us = vrr->btr.mid_point_in_us;\n\t\t*inserted_frames = vrr->btr.frames_to_insert;\n\t\t*inserted_duration_in_us = vrr->btr.inserted_duration_in_us;\n\t}\n}\n\nunsigned long long mod_freesync_calc_nominal_field_rate(\n\t\t\tconst struct dc_stream_state *stream)\n{\n\tunsigned long long nominal_field_rate_in_uhz = 0;\n\tunsigned int total = stream->timing.h_total * stream->timing.v_total;\n\n\t \n\tnominal_field_rate_in_uhz = stream->timing.pix_clk_100hz;\n\tnominal_field_rate_in_uhz *= 100000000ULL;\n\n\tnominal_field_rate_in_uhz =\tdiv_u64(nominal_field_rate_in_uhz, total);\n\n\treturn nominal_field_rate_in_uhz;\n}\n\nunsigned long long mod_freesync_calc_field_rate_from_timing(\n\t\tunsigned int vtotal, unsigned int htotal, unsigned int pix_clk)\n{\n\tunsigned long long field_rate_in_uhz = 0;\n\tunsigned int total = htotal * vtotal;\n\n\t \n\tfield_rate_in_uhz = pix_clk;\n\tfield_rate_in_uhz *= 1000000ULL;\n\n\tfield_rate_in_uhz =\tdiv_u64(field_rate_in_uhz, total);\n\n\treturn field_rate_in_uhz;\n}\n\nbool mod_freesync_get_freesync_enabled(struct mod_vrr_params *pVrr)\n{\n\treturn (pVrr->state != VRR_STATE_UNSUPPORTED) && (pVrr->state != VRR_STATE_DISABLED);\n}\n\nbool mod_freesync_is_valid_range(uint32_t min_refresh_cap_in_uhz,\n\t\tuint32_t max_refresh_cap_in_uhz,\n\t\tuint32_t nominal_field_rate_in_uhz)\n{\n\n\t \n\tnominal_field_rate_in_uhz =\n\t\t\tdiv_u64(nominal_field_rate_in_uhz + 500000, 1000000);\n\tmin_refresh_cap_in_uhz /= 1000000;\n\tmax_refresh_cap_in_uhz /= 1000000;\n\n\t \n\tif (nominal_field_rate_in_uhz > max_refresh_cap_in_uhz ||\n\t\tnominal_field_rate_in_uhz < min_refresh_cap_in_uhz)\n\t\treturn false;\n\n\t \n\tif (nominal_field_rate_in_uhz < max_refresh_cap_in_uhz)\n\t\tmax_refresh_cap_in_uhz = nominal_field_rate_in_uhz;\n\n\t \n\tif (min_refresh_cap_in_uhz > max_refresh_cap_in_uhz)\n\t\treturn false;\n\n\t \n\tif (nominal_field_rate_in_uhz - min_refresh_cap_in_uhz < 10)\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}