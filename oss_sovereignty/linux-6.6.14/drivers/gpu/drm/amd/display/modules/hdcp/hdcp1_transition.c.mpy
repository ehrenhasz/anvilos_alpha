{
  "module_name": "hdcp1_transition.c",
  "hash_id": "a6195f8da70260d689168a5749815aee04a945aa57786c6ccdbc4225667a9f65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_transition.c",
  "human_readable_source": " \n\n#include \"hdcp.h\"\n\nenum mod_hdcp_status mod_hdcp_hdcp1_transition(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_connection *conn = &hdcp->connection;\n\tstruct mod_hdcp_link_adjustment *adjust = &hdcp->connection.link.adjust;\n\n\tswitch (current_state(hdcp)) {\n\tcase H1_A0_WAIT_FOR_ACTIVE_RX:\n\t\tif (input->bksv_read != PASS || input->bcaps_read != PASS) {\n\t\t\t \n\t\t\tcallback_in_ms(500, output);\n\t\t\tincrement_stay_counter(hdcp);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, H1_A1_EXCHANGE_KSVS);\n\t\tbreak;\n\tcase H1_A1_EXCHANGE_KSVS:\n\t\tif (input->create_session != PASS) {\n\t\t\t \n\t\t\tadjust->hdcp1.disable = 1;\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->an_write != PASS ||\n\t\t\t\tinput->aksv_write != PASS ||\n\t\t\t\tinput->bksv_read != PASS ||\n\t\t\t\tinput->bksv_validation != PASS ||\n\t\t\t\tinput->ainfo_write == FAIL) {\n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(300, output);\n\t\tset_state_id(hdcp, output,\n\t\t\tH1_A2_COMPUTATIONS_A3_VALIDATE_RX_A6_TEST_FOR_REPEATER);\n\t\tbreak;\n\tcase H1_A2_COMPUTATIONS_A3_VALIDATE_RX_A6_TEST_FOR_REPEATER:\n\t\tif (input->bcaps_read != PASS ||\n\t\t\t\tinput->r0p_read != PASS) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->rx_validation != PASS) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tfail_and_restart_in_ms(1000, &status, output);\n\t\t\tbreak;\n\t\t} else if (!conn->is_repeater && input->encryption != PASS) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tif (conn->is_repeater) {\n\t\t\tcallback_in_ms(0, output);\n\t\t\tset_watchdog_in_ms(hdcp, 5000, output);\n\t\t\tset_state_id(hdcp, output, H1_A8_WAIT_FOR_READY);\n\t\t} else {\n\t\t\tcallback_in_ms(0, output);\n\t\t\tset_state_id(hdcp, output, H1_A45_AUTHENTICATED);\n\t\t\tset_auth_complete(hdcp, output);\n\t\t}\n\t\tbreak;\n\tcase H1_A45_AUTHENTICATED:\n\t\tif (input->link_maintenance == FAIL) {\n\t\t\t \n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(500, output);\n\t\tincrement_stay_counter(hdcp);\n\t\tbreak;\n\tcase H1_A8_WAIT_FOR_READY:\n\t\tif (input->ready_check != PASS) {\n\t\t\tif (event_ctx->event ==\n\t\t\t\t\tMOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tadjust->hdcp1.postpone_encryption = 1;\n\t\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcallback_in_ms(500, output);\n\t\t\t\tincrement_stay_counter(hdcp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, H1_A9_READ_KSV_LIST);\n\t\tbreak;\n\tcase H1_A9_READ_KSV_LIST:\n\t\tif (input->bstatus_read != PASS ||\n\t\t\t\tinput->max_cascade_check != PASS ||\n\t\t\t\tinput->max_devs_check != PASS ||\n\t\t\t\tinput->device_count_check != PASS ||\n\t\t\t\tinput->ksvlist_read != PASS ||\n\t\t\t\tinput->vp_read != PASS ||\n\t\t\t\tinput->ksvlist_vp_validation != PASS ||\n\t\t\t\tinput->encryption != PASS) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, H1_A45_AUTHENTICATED);\n\t\tset_auth_complete(hdcp, output);\n\t\tbreak;\n\tdefault:\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t\tfail_and_restart_in_ms(0, &status, output);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_dp_transition(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp1 *input,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_connection *conn = &hdcp->connection;\n\tstruct mod_hdcp_link_adjustment *adjust = &hdcp->connection.link.adjust;\n\n\tswitch (current_state(hdcp)) {\n\tcase D1_A0_DETERMINE_RX_HDCP_CAPABLE:\n\t\tif (input->bcaps_read != PASS) {\n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->hdcp_capable_dp != PASS) {\n\t\t\tadjust->hdcp1.disable = 1;\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, D1_A1_EXCHANGE_KSVS);\n\t\tbreak;\n\tcase D1_A1_EXCHANGE_KSVS:\n\t\tif (input->create_session != PASS) {\n\t\t\t \n\t\t\tadjust->hdcp1.disable = 1;\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->an_write != PASS ||\n\t\t\t\tinput->aksv_write != PASS ||\n\t\t\t\tinput->bksv_read != PASS ||\n\t\t\t\tinput->bksv_validation != PASS ||\n\t\t\t\tinput->ainfo_write == FAIL) {\n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tset_watchdog_in_ms(hdcp, 100, output);\n\t\tset_state_id(hdcp, output, D1_A23_WAIT_FOR_R0_PRIME);\n\t\tbreak;\n\tcase D1_A23_WAIT_FOR_R0_PRIME:\n\t\tif (input->bstatus_read != PASS) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->r0p_available_dp != PASS) {\n\t\t\tif (event_ctx->event == MOD_HDCP_EVENT_WATCHDOG_TIMEOUT)\n\t\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\telse\n\t\t\t\tincrement_stay_counter(hdcp);\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, D1_A2_COMPUTATIONS_A3_VALIDATE_RX_A5_TEST_FOR_REPEATER);\n\t\tbreak;\n\tcase D1_A2_COMPUTATIONS_A3_VALIDATE_RX_A5_TEST_FOR_REPEATER:\n\t\tif (input->r0p_read != PASS) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->rx_validation != PASS) {\n\t\t\tif (hdcp->state.stay_count < 2 &&\n\t\t\t\t\t!hdcp->connection.is_hdcp1_revoked) {\n\t\t\t\t \n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tincrement_stay_counter(hdcp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tfail_and_restart_in_ms(1000, &status, output);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if ((!conn->is_repeater && input->encryption != PASS) ||\n\t\t\t\t(!conn->is_repeater && is_dp_mst_hdcp(hdcp) && input->stream_encryption_dp != PASS)) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (conn->hdcp1_retry_count < conn->link.adjust.hdcp1.min_auth_retries_wa) {\n\t\t\tfail_and_restart_in_ms(200, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tif (conn->is_repeater) {\n\t\t\tset_watchdog_in_ms(hdcp, 5000, output);\n\t\t\tset_state_id(hdcp, output, D1_A6_WAIT_FOR_READY);\n\t\t} else {\n\t\t\tset_state_id(hdcp, output, D1_A4_AUTHENTICATED);\n\t\t\tset_auth_complete(hdcp, output);\n\t\t}\n\t\tbreak;\n\tcase D1_A4_AUTHENTICATED:\n\t\tif (input->link_integrity_check == FAIL ||\n\t\t\t\tinput->reauth_request_check == FAIL) {\n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase D1_A6_WAIT_FOR_READY:\n\t\tif (input->link_integrity_check == FAIL ||\n\t\t\t\tinput->reauth_request_check == FAIL) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->ready_check != PASS) {\n\t\t\tif (event_ctx->event ==\n\t\t\t\t\tMOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tadjust->hdcp1.postpone_encryption = 1;\n\t\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\t} else {\n\t\t\t\tincrement_stay_counter(hdcp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcallback_in_ms(0, output);\n\t\tset_state_id(hdcp, output, D1_A7_READ_KSV_LIST);\n\t\tbreak;\n\tcase D1_A7_READ_KSV_LIST:\n\t\tif (input->binfo_read_dp != PASS ||\n\t\t\t\tinput->max_cascade_check != PASS ||\n\t\t\t\tinput->max_devs_check != PASS) {\n\t\t\t \n\t\t\t \n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->device_count_check != PASS) {\n\t\t\t \n\t\t\tadjust->hdcp1.postpone_encryption = 1;\n\t\t\tfail_and_restart_in_ms(1000, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->ksvlist_read != PASS ||\n\t\t\t\tinput->vp_read != PASS) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t} else if (input->ksvlist_vp_validation != PASS) {\n\t\t\tif (hdcp->state.stay_count < 2 &&\n\t\t\t\t\t!hdcp->connection.is_hdcp1_revoked) {\n\t\t\t\t \n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tincrement_stay_counter(hdcp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (input->encryption != PASS ||\n\t\t\t\t(is_dp_mst_hdcp(hdcp) && input->stream_encryption_dp != PASS)) {\n\t\t\tfail_and_restart_in_ms(0, &status, output);\n\t\t\tbreak;\n\t\t}\n\t\tset_state_id(hdcp, output, D1_A4_AUTHENTICATED);\n\t\tset_auth_complete(hdcp, output);\n\t\tbreak;\n\tdefault:\n\t\tfail_and_restart_in_ms(0, &status, output);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}