{
  "module_name": "hdcp2_execution.c",
  "hash_id": "beed8b03afeb615507535c076e2ef3d824d59e8074af8dcd7465cb904ae8d7db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp2_execution.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n\n#include \"hdcp.h\"\n\nstatic inline enum mod_hdcp_status check_receiver_id_list_ready(struct mod_hdcp *hdcp)\n{\n\tuint8_t is_ready = 0;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tis_ready = HDCP_2_2_DP_RXSTATUS_READY(hdcp->auth.msg.hdcp2.rxstatus_dp) ? 1 : 0;\n\telse\n\t\tis_ready = (HDCP_2_2_HDMI_RXSTATUS_READY(hdcp->auth.msg.hdcp2.rxstatus[1]) &&\n\t\t\t\t(HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t\t\t\t\thdcp->auth.msg.hdcp2.rxstatus[0])) ? 1 : 0;\n\treturn is_ready ? MOD_HDCP_STATUS_SUCCESS :\n\t\t\tMOD_HDCP_STATUS_HDCP2_RX_ID_LIST_NOT_READY;\n}\n\nstatic inline enum mod_hdcp_status check_hdcp2_capable(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tstatus = (hdcp->auth.msg.hdcp2.rxcaps_dp[0] == HDCP_2_2_RX_CAPS_VERSION_VAL) &&\n\t\t\t\tHDCP_2_2_DP_HDCP_CAPABLE(hdcp->auth.msg.hdcp2.rxcaps_dp[2]) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_NOT_CAPABLE;\n\telse\n\t\tstatus = (hdcp->auth.msg.hdcp2.hdcp2version_hdmi & HDCP_2_2_HDMI_SUPPORT_MASK) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_NOT_CAPABLE;\n\treturn status;\n}\n\nstatic inline enum mod_hdcp_status check_reauthentication_request(\n\t\tstruct mod_hdcp *hdcp)\n{\n\tuint8_t ret = 0;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tret = HDCP_2_2_DP_RXSTATUS_REAUTH_REQ(hdcp->auth.msg.hdcp2.rxstatus_dp) ?\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_REAUTH_REQUEST :\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS;\n\telse\n\t\tret = HDCP_2_2_HDMI_RXSTATUS_REAUTH_REQ(hdcp->auth.msg.hdcp2.rxstatus[1]) ?\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_REAUTH_REQUEST :\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS;\n\treturn ret;\n}\n\nstatic inline enum mod_hdcp_status check_link_integrity_failure_dp(\n\t\tstruct mod_hdcp *hdcp)\n{\n\treturn HDCP_2_2_DP_RXSTATUS_LINK_FAILED(hdcp->auth.msg.hdcp2.rxstatus_dp) ?\n\t\t\tMOD_HDCP_STATUS_HDCP2_REAUTH_LINK_INTEGRITY_FAILURE :\n\t\t\tMOD_HDCP_STATUS_SUCCESS;\n}\n\nstatic enum mod_hdcp_status check_ake_cert_available(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tuint16_t size;\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t} else {\n\t\tstatus = mod_hdcp_read_rxstatus(hdcp);\n\t\tif (status == MOD_HDCP_STATUS_SUCCESS) {\n\t\t\tsize = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t\t       hdcp->auth.msg.hdcp2.rxstatus[0];\n\t\t\tstatus = (size == sizeof(hdcp->auth.msg.hdcp2.ake_cert)) ?\n\t\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\t\tMOD_HDCP_STATUS_HDCP2_AKE_CERT_PENDING;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic enum mod_hdcp_status check_h_prime_available(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tuint8_t size;\n\n\tstatus = mod_hdcp_read_rxstatus(hdcp);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tstatus = HDCP_2_2_DP_RXSTATUS_H_PRIME(hdcp->auth.msg.hdcp2.rxstatus_dp) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_H_PRIME_PENDING;\n\t} else {\n\t\tsize = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t       hdcp->auth.msg.hdcp2.rxstatus[0];\n\t\tstatus = (size == sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_H_PRIME_PENDING;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status check_pairing_info_available(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tuint8_t size;\n\n\tstatus = mod_hdcp_read_rxstatus(hdcp);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tstatus = HDCP_2_2_DP_RXSTATUS_PAIRING(hdcp->auth.msg.hdcp2.rxstatus_dp) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_PAIRING_INFO_PENDING;\n\t} else {\n\t\tsize = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t       hdcp->auth.msg.hdcp2.rxstatus[0];\n\t\tstatus = (size == sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_PAIRING_INFO_PENDING;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status poll_l_prime_available(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tuint8_t size;\n\tuint16_t max_wait = 20; \n\tuint16_t num_polls = 5;\n\tuint16_t wait_time = max_wait / num_polls;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tstatus = MOD_HDCP_STATUS_INVALID_OPERATION;\n\telse\n\t\tfor (; num_polls; num_polls--) {\n\t\t\tmsleep(wait_time);\n\n\t\t\tstatus = mod_hdcp_read_rxstatus(hdcp);\n\t\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\t\tbreak;\n\n\t\t\tsize = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t\t       hdcp->auth.msg.hdcp2.rxstatus[0];\n\t\t\tstatus = (size == sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)) ?\n\t\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\t\tMOD_HDCP_STATUS_HDCP2_L_PRIME_PENDING;\n\t\t\tif (status == MOD_HDCP_STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\treturn status;\n}\n\nstatic enum mod_hdcp_status check_stream_ready_available(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status;\n\tuint8_t size;\n\n\tif (is_dp_hdcp(hdcp)) {\n\t\tstatus = MOD_HDCP_STATUS_INVALID_OPERATION;\n\t} else {\n\t\tstatus = mod_hdcp_read_rxstatus(hdcp);\n\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tgoto out;\n\t\tsize = HDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t       hdcp->auth.msg.hdcp2.rxstatus[0];\n\t\tstatus = (size == sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)) ?\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS :\n\t\t\t\tMOD_HDCP_STATUS_HDCP2_STREAM_READY_PENDING;\n\t}\nout:\n\treturn status;\n}\n\nstatic inline uint8_t get_device_count(struct mod_hdcp *hdcp)\n{\n\treturn HDCP_2_2_DEV_COUNT_LO(hdcp->auth.msg.hdcp2.rx_id_list[2]) +\n\t\t\t(HDCP_2_2_DEV_COUNT_HI(hdcp->auth.msg.hdcp2.rx_id_list[1]) << 4);\n}\n\nstatic enum mod_hdcp_status check_device_count(struct mod_hdcp *hdcp)\n{\n\t \n\tif (0 == get_device_count(hdcp)) {\n\t\treturn MOD_HDCP_STATUS_HDCP1_DEVICE_COUNT_MISMATCH_FAILURE;\n\t}\n\n\t \n\t \n\t \n\t \n\treturn ((1 + get_device_count(hdcp)) < get_active_display_count(hdcp)) ?\n\t\t\tMOD_HDCP_STATUS_HDCP2_DEVICE_COUNT_MISMATCH_FAILURE :\n\t\t\tMOD_HDCP_STATUS_SUCCESS;\n}\n\nstatic uint8_t process_rxstatus(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input,\n\t\tenum mod_hdcp_status *status)\n{\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_rxstatus,\n\t\t\t&input->rxstatus_read, status,\n\t\t\thdcp, \"rxstatus_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_reauthentication_request,\n\t\t\t&input->reauth_request_check, status,\n\t\t\thdcp, \"reauth_request_check\"))\n\t\tgoto out;\n\tif (is_dp_hdcp(hdcp)) {\n\t\tif (!mod_hdcp_execute_and_set(check_link_integrity_failure_dp,\n\t\t\t\t&input->link_integrity_check_dp, status,\n\t\t\t\thdcp, \"link_integrity_check_dp\"))\n\t\t\tgoto out;\n\t}\n\tif (hdcp->connection.is_repeater)\n\t\tif (check_receiver_id_list_ready(hdcp) ==\n\t\t\t\tMOD_HDCP_STATUS_SUCCESS) {\n\t\t\tHDCP_INPUT_PASS_TRACE(hdcp, \"rx_id_list_ready\");\n\t\t\tevent_ctx->rx_id_list_ready = 1;\n\t\t\tif (is_dp_hdcp(hdcp))\n\t\t\t\thdcp->auth.msg.hdcp2.rx_id_list_size =\n\t\t\t\t\t\tsizeof(hdcp->auth.msg.hdcp2.rx_id_list);\n\t\t\telse\n\t\t\t\thdcp->auth.msg.hdcp2.rx_id_list_size =\n\t\t\t\t\tHDCP_2_2_HDMI_RXSTATUS_MSG_SZ_HI(hdcp->auth.msg.hdcp2.rxstatus[1]) << 8 |\n\t\t\t\t\thdcp->auth.msg.hdcp2.rxstatus[0];\n\t\t}\nout:\n\treturn (*status == MOD_HDCP_STATUS_SUCCESS);\n}\n\nstatic enum mod_hdcp_status known_hdcp2_capable_rx(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_hdcp2version,\n\t\t\t&input->hdcp2version_read, &status,\n\t\t\thdcp, \"hdcp2version_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_hdcp2_capable,\n\t\t\t&input->hdcp2_capable_check, &status,\n\t\t\thdcp, \"hdcp2_capable\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status send_ake_init(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_create_session,\n\t\t\t&input->create_session, &status,\n\t\t\thdcp, \"create_session\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_prepare_ake_init,\n\t\t\t&input->ake_init_prepare, &status,\n\t\t\thdcp, \"ake_init_prepare\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_ake_init,\n\t\t\t&input->ake_init_write, &status,\n\t\t\thdcp, \"ake_init_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status validate_ake_cert(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (is_hdmi_dvi_sl_hdcp(hdcp))\n\t\tif (!mod_hdcp_execute_and_set(check_ake_cert_available,\n\t\t\t\t&input->ake_cert_available, &status,\n\t\t\t\thdcp, \"ake_cert_available\"))\n\t\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_ake_cert,\n\t\t\t&input->ake_cert_read, &status,\n\t\t\thdcp, \"ake_cert_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_ake_cert,\n\t\t\t&input->ake_cert_validation, &status,\n\t\t\thdcp, \"ake_cert_validation\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status send_no_stored_km(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_no_stored_km,\n\t\t\t&input->no_stored_km_write, &status,\n\t\t\thdcp, \"no_stored_km_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status read_h_prime(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(check_h_prime_available,\n\t\t\t&input->h_prime_available, &status,\n\t\t\thdcp, \"h_prime_available\"))\n\t\tgoto out;\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_h_prime,\n\t\t\t&input->h_prime_read, &status,\n\t\t\thdcp, \"h_prime_read\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status read_pairing_info_and_validate_h_prime(\n\t\tstruct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(check_pairing_info_available,\n\t\t\t&input->pairing_available, &status,\n\t\t\thdcp, \"pairing_available\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_pairing_info,\n\t\t\t&input->pairing_info_read, &status,\n\t\t\thdcp, \"pairing_info_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_h_prime,\n\t\t\t&input->h_prime_validation, &status,\n\t\t\thdcp, \"h_prime_validation\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status send_stored_km(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_stored_km,\n\t\t\t&input->stored_km_write, &status,\n\t\t\thdcp, \"stored_km_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status validate_h_prime(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(check_h_prime_available,\n\t\t\t&input->h_prime_available, &status,\n\t\t\thdcp, \"h_prime_available\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_h_prime,\n\t\t\t&input->h_prime_read, &status,\n\t\t\thdcp, \"h_prime_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_h_prime,\n\t\t\t&input->h_prime_validation, &status,\n\t\t\thdcp, \"h_prime_validation\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status locality_check(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_prepare_lc_init,\n\t\t\t&input->lc_init_prepare, &status,\n\t\t\thdcp, \"lc_init_prepare\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_lc_init,\n\t\t\t&input->lc_init_write, &status,\n\t\t\t hdcp, \"lc_init_write\"))\n\t\tgoto out;\n\tif (is_dp_hdcp(hdcp))\n\t\tmsleep(16);\n\telse\n\t\tif (!mod_hdcp_execute_and_set(poll_l_prime_available,\n\t\t\t\t&input->l_prime_available_poll, &status,\n\t\t\t\thdcp, \"l_prime_available_poll\"))\n\t\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_l_prime,\n\t\t\t&input->l_prime_read, &status,\n\t\t\thdcp, \"l_prime_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_l_prime,\n\t\t\t&input->l_prime_validation, &status,\n\t\t\thdcp, \"l_prime_validation\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status exchange_ks_and_test_for_repeater(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_prepare_eks,\n\t\t\t&input->eks_prepare, &status,\n\t\t\thdcp, \"eks_prepare\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_eks,\n\t\t\t&input->eks_write, &status,\n\t\t\thdcp, \"eks_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status enable_encryption(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\tif (event_ctx->event == MOD_HDCP_EVENT_CPIRQ) {\n\t\tprocess_rxstatus(hdcp, event_ctx, input, &status);\n\t\tgoto out;\n\t}\n\n\tif (is_hdmi_dvi_sl_hdcp(hdcp)) {\n\t\tif (!process_rxstatus(hdcp, event_ctx, input, &status))\n\t\t\tgoto out;\n\t\tif (event_ctx->rx_id_list_ready)\n\t\t\tgoto out;\n\t}\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_enable_encryption,\n\t\t\t&input->enable_encryption, &status,\n\t\t\thdcp, \"enable_encryption\"))\n\t\tgoto out;\n\tif (is_dp_mst_hdcp(hdcp)) {\n\t\tif (!mod_hdcp_execute_and_set(\n\t\t\t\tmod_hdcp_hdcp2_enable_dp_stream_encryption,\n\t\t\t\t&input->stream_encryption_dp, &status,\n\t\t\t\thdcp, \"stream_encryption_dp\"))\n\t\t\tgoto out;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status authenticated(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tprocess_rxstatus(hdcp, event_ctx, input, &status);\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status wait_for_rx_id_list(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!process_rxstatus(hdcp, event_ctx, input, &status))\n\t\tgoto out;\n\tif (!event_ctx->rx_id_list_ready) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_RX_ID_LIST_NOT_READY;\n\t\tgoto out;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status verify_rx_id_list_and_send_ack(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\tif (event_ctx->event == MOD_HDCP_EVENT_CPIRQ) {\n\t\tprocess_rxstatus(hdcp, event_ctx, input, &status);\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_rx_id_list,\n\t\t\t&input->rx_id_list_read,\n\t\t\t&status, hdcp, \"receiver_id_list_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_device_count,\n\t\t\t&input->device_count_check,\n\t\t\t&status, hdcp, \"device_count_check\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_rx_id_list,\n\t\t\t&input->rx_id_list_validation,\n\t\t\t&status, hdcp, \"rx_id_list_validation\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_repeater_auth_ack,\n\t\t\t&input->repeater_auth_ack_write,\n\t\t\t&status, hdcp, \"repeater_auth_ack_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status send_stream_management(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\tif (event_ctx->event == MOD_HDCP_EVENT_CPIRQ) {\n\t\tprocess_rxstatus(hdcp, event_ctx, input, &status);\n\t\tgoto out;\n\t}\n\n\tif (is_hdmi_dvi_sl_hdcp(hdcp)) {\n\t\tif (!process_rxstatus(hdcp, event_ctx, input, &status))\n\t\t\tgoto out;\n\t\tif (event_ctx->rx_id_list_ready)\n\t\t\tgoto out;\n\t}\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_prepare_stream_management,\n\t\t\t&input->prepare_stream_manage,\n\t\t\t&status, hdcp, \"prepare_stream_manage\"))\n\t\tgoto out;\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_stream_manage,\n\t\t\t&input->stream_manage_write,\n\t\t\t&status, hdcp, \"stream_manage_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status validate_stream_ready(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_WATCHDOG_TIMEOUT) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\tif (event_ctx->event == MOD_HDCP_EVENT_CPIRQ) {\n\t\tprocess_rxstatus(hdcp, event_ctx, input, &status);\n\t\tgoto out;\n\t}\n\n\tif (is_hdmi_dvi_sl_hdcp(hdcp)) {\n\t\tif (!process_rxstatus(hdcp, event_ctx, input, &status))\n\t\t\tgoto out;\n\t\tif (event_ctx->rx_id_list_ready) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (is_hdmi_dvi_sl_hdcp(hdcp))\n\t\tif (!mod_hdcp_execute_and_set(check_stream_ready_available,\n\t\t\t\t&input->stream_ready_available,\n\t\t\t\t&status, hdcp, \"stream_ready_available\"))\n\t\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_stream_ready,\n\t\t\t&input->stream_ready_read,\n\t\t\t&status, hdcp, \"stream_ready_read\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_hdcp2_validate_stream_ready,\n\t\t\t&input->stream_ready_validation,\n\t\t\t&status, hdcp, \"stream_ready_validation\"))\n\t\tgoto out;\n\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status determine_rx_hdcp_capable_dp(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_read_rxcaps,\n\t\t\t&input->rx_caps_read_dp,\n\t\t\t&status, hdcp, \"rx_caps_read_dp\"))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(check_hdcp2_capable,\n\t\t\t&input->hdcp2_capable_check, &status,\n\t\t\thdcp, \"hdcp2_capable_check\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status send_content_stream_type_dp(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK &&\n\t\t\tevent_ctx->event != MOD_HDCP_EVENT_CPIRQ) {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\n\n\tif (!process_rxstatus(hdcp, event_ctx, input, &status))\n\t\tgoto out;\n\tif (!mod_hdcp_execute_and_set(mod_hdcp_write_content_type,\n\t\t\t&input->content_stream_type_write, &status,\n\t\t\thdcp, \"content_stream_type_write\"))\n\t\tgoto out;\nout:\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tswitch (current_state(hdcp)) {\n\tcase H2_A0_KNOWN_HDCP2_CAPABLE_RX:\n\t\tstatus = known_hdcp2_capable_rx(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_SEND_AKE_INIT:\n\t\tstatus = send_ake_init(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_VALIDATE_AKE_CERT:\n\t\tstatus = validate_ake_cert(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_SEND_NO_STORED_KM:\n\t\tstatus = send_no_stored_km(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_READ_H_PRIME:\n\t\tstatus = read_h_prime(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_READ_PAIRING_INFO_AND_VALIDATE_H_PRIME:\n\t\tstatus = read_pairing_info_and_validate_h_prime(hdcp,\n\t\t\t\tevent_ctx, input);\n\t\tbreak;\n\tcase H2_A1_SEND_STORED_KM:\n\t\tstatus = send_stored_km(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A1_VALIDATE_H_PRIME:\n\t\tstatus = validate_h_prime(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A2_LOCALITY_CHECK:\n\t\tstatus = locality_check(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A3_EXCHANGE_KS_AND_TEST_FOR_REPEATER:\n\t\tstatus = exchange_ks_and_test_for_repeater(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_ENABLE_ENCRYPTION:\n\t\tstatus = enable_encryption(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A5_AUTHENTICATED:\n\t\tstatus = authenticated(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A6_WAIT_FOR_RX_ID_LIST:\n\t\tstatus = wait_for_rx_id_list(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A78_VERIFY_RX_ID_LIST_AND_SEND_ACK:\n\t\tstatus = verify_rx_id_list_and_send_ack(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A9_SEND_STREAM_MANAGEMENT:\n\t\tstatus = send_stream_management(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase H2_A9_VALIDATE_STREAM_READY:\n\t\tstatus = validate_stream_ready(hdcp, event_ctx, input);\n\t\tbreak;\n\tdefault:\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_dp_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tswitch (current_state(hdcp)) {\n\tcase D2_A0_DETERMINE_RX_HDCP_CAPABLE:\n\t\tstatus = determine_rx_hdcp_capable_dp(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_SEND_AKE_INIT:\n\t\tstatus = send_ake_init(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_VALIDATE_AKE_CERT:\n\t\tstatus = validate_ake_cert(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_SEND_NO_STORED_KM:\n\t\tstatus = send_no_stored_km(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_READ_H_PRIME:\n\t\tstatus = read_h_prime(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_READ_PAIRING_INFO_AND_VALIDATE_H_PRIME:\n\t\tstatus = read_pairing_info_and_validate_h_prime(hdcp,\n\t\t\t\tevent_ctx, input);\n\t\tbreak;\n\tcase D2_A1_SEND_STORED_KM:\n\t\tstatus = send_stored_km(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A1_VALIDATE_H_PRIME:\n\t\tstatus = validate_h_prime(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A2_LOCALITY_CHECK:\n\t\tstatus = locality_check(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A34_EXCHANGE_KS_AND_TEST_FOR_REPEATER:\n\t\tstatus = exchange_ks_and_test_for_repeater(hdcp,\n\t\t\t\tevent_ctx, input);\n\t\tbreak;\n\tcase D2_SEND_CONTENT_STREAM_TYPE:\n\t\tstatus = send_content_stream_type_dp(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_ENABLE_ENCRYPTION:\n\t\tstatus = enable_encryption(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A5_AUTHENTICATED:\n\t\tstatus = authenticated(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A6_WAIT_FOR_RX_ID_LIST:\n\t\tstatus = wait_for_rx_id_list(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A78_VERIFY_RX_ID_LIST_AND_SEND_ACK:\n\t\tstatus = verify_rx_id_list_and_send_ack(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A9_SEND_STREAM_MANAGEMENT:\n\t\tstatus = send_stream_management(hdcp, event_ctx, input);\n\t\tbreak;\n\tcase D2_A9_VALIDATE_STREAM_READY:\n\t\tstatus = validate_stream_ready(hdcp, event_ctx, input);\n\t\tbreak;\n\tdefault:\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}