{
  "module_name": "color_gamma.c",
  "hash_id": "ea71f46981035c0379785c29b7c2e507278519601389fe7231300f5ec927bae3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/color/color_gamma.c",
  "human_readable_source": " \n\n#include \"dc.h\"\n#include \"opp.h\"\n#include \"color_gamma.h\"\n\n \n#define PRECISE_LUT_REGION_START 224\n#define PRECISE_LUT_REGION_END 239\n\nstatic struct hw_x_point coordinates_x[MAX_HW_POINTS + 2];\n\n\n\n\n \n\n \n\t\t\t\t\t\t\t\t\t  \nstatic const int32_t numerator01[] = { 31308,   180000, 0,  0,  0};\nstatic const int32_t numerator02[] = { 12920,   4500,   0,  0,  0};\nstatic const int32_t numerator03[] = { 55,      99,     0,  0,  0};\nstatic const int32_t numerator04[] = { 55,      99,     0,  0,  0};\nstatic const int32_t numerator05[] = { 2400,    2222,   2200, 2400, 2600};\n\n \nvoid setup_x_points_distribution(void)\n{\n\tstruct fixed31_32 region_size = dc_fixpt_from_int(128);\n\tint32_t segment;\n\tuint32_t seg_offset;\n\tuint32_t index;\n\tstruct fixed31_32 increment;\n\n\tcoordinates_x[MAX_HW_POINTS].x = region_size;\n\tcoordinates_x[MAX_HW_POINTS + 1].x = region_size;\n\n\tfor (segment = 6; segment > (6 - NUM_REGIONS); segment--) {\n\t\tregion_size = dc_fixpt_div_int(region_size, 2);\n\t\tincrement = dc_fixpt_div_int(region_size,\n\t\t\t\t\t\tNUM_PTS_IN_REGION);\n\t\tseg_offset = (segment + (NUM_REGIONS - 7)) * NUM_PTS_IN_REGION;\n\t\tcoordinates_x[seg_offset].x = region_size;\n\n\t\tfor (index = seg_offset + 1;\n\t\t\t\tindex < seg_offset + NUM_PTS_IN_REGION;\n\t\t\t\tindex++) {\n\t\t\tcoordinates_x[index].x = dc_fixpt_add\n\t\t\t\t\t(coordinates_x[index-1].x, increment);\n\t\t}\n\t}\n}\n\nvoid log_x_points_distribution(struct dal_logger *logger)\n{\n\tint i = 0;\n\n\tif (logger != NULL) {\n\t\tLOG_GAMMA_WRITE(\"Log X Distribution\\n\");\n\n\t\tfor (i = 0; i < MAX_HW_POINTS; i++)\n\t\t\tLOG_GAMMA_WRITE(\"%llu\\n\", coordinates_x[i].x.value);\n\t}\n}\n\nstatic void compute_pq(struct fixed31_32 in_x, struct fixed31_32 *out_y)\n{\n\t \n\tconst struct fixed31_32 m1 =\n\t\tdc_fixpt_from_fraction(159301758, 1000000000);\n\tconst struct fixed31_32 m2 =\n\t\tdc_fixpt_from_fraction(7884375, 100000);\n\tconst struct fixed31_32 c1 =\n\t\tdc_fixpt_from_fraction(8359375, 10000000);\n\tconst struct fixed31_32 c2 =\n\t\tdc_fixpt_from_fraction(188515625, 10000000);\n\tconst struct fixed31_32 c3 =\n\t\tdc_fixpt_from_fraction(186875, 10000);\n\n\tstruct fixed31_32 l_pow_m1;\n\tstruct fixed31_32 base;\n\n\tif (dc_fixpt_lt(in_x, dc_fixpt_zero))\n\t\tin_x = dc_fixpt_zero;\n\n\tl_pow_m1 = dc_fixpt_pow(in_x, m1);\n\tbase = dc_fixpt_div(\n\t\t\tdc_fixpt_add(c1,\n\t\t\t\t\t(dc_fixpt_mul(c2, l_pow_m1))),\n\t\t\tdc_fixpt_add(dc_fixpt_one,\n\t\t\t\t\t(dc_fixpt_mul(c3, l_pow_m1))));\n\t*out_y = dc_fixpt_pow(base, m2);\n}\n\nstatic void compute_de_pq(struct fixed31_32 in_x, struct fixed31_32 *out_y)\n{\n\t \n\tconst struct fixed31_32 m1 =\n\t\tdc_fixpt_from_fraction(159301758, 1000000000);\n\tconst struct fixed31_32 m2 =\n\t\tdc_fixpt_from_fraction(7884375, 100000);\n\tconst struct fixed31_32 c1 =\n\t\tdc_fixpt_from_fraction(8359375, 10000000);\n\tconst struct fixed31_32 c2 =\n\t\tdc_fixpt_from_fraction(188515625, 10000000);\n\tconst struct fixed31_32 c3 =\n\t\tdc_fixpt_from_fraction(186875, 10000);\n\n\tstruct fixed31_32 l_pow_m1;\n\tstruct fixed31_32 base, div;\n\tstruct fixed31_32 base2;\n\n\n\tif (dc_fixpt_lt(in_x, dc_fixpt_zero))\n\t\tin_x = dc_fixpt_zero;\n\n\tl_pow_m1 = dc_fixpt_pow(in_x,\n\t\t\tdc_fixpt_div(dc_fixpt_one, m2));\n\tbase = dc_fixpt_sub(l_pow_m1, c1);\n\n\tdiv = dc_fixpt_sub(c2, dc_fixpt_mul(c3, l_pow_m1));\n\n\tbase2 = dc_fixpt_div(base, div);\n\t\n\tif (dc_fixpt_lt(base2, dc_fixpt_zero))\n\t\tbase2 = dc_fixpt_sub(dc_fixpt_zero, base2);\n\n\n\t*out_y = dc_fixpt_pow(base2, dc_fixpt_div(dc_fixpt_one, m1));\n\n}\n\n\n \nstatic void compute_hlg_eotf(struct fixed31_32 in_x,\n\t\tstruct fixed31_32 *out_y,\n\t\tuint32_t sdr_white_level, uint32_t max_luminance_nits)\n{\n\tstruct fixed31_32 a;\n\tstruct fixed31_32 b;\n\tstruct fixed31_32 c;\n\tstruct fixed31_32 threshold;\n\tstruct fixed31_32 x;\n\n\tstruct fixed31_32 scaling_factor =\n\t\t\tdc_fixpt_from_fraction(max_luminance_nits, sdr_white_level);\n\ta = dc_fixpt_from_fraction(17883277, 100000000);\n\tb = dc_fixpt_from_fraction(28466892, 100000000);\n\tc = dc_fixpt_from_fraction(55991073, 100000000);\n\tthreshold = dc_fixpt_from_fraction(1, 2);\n\n\tif (dc_fixpt_lt(in_x, threshold)) {\n\t\tx = dc_fixpt_mul(in_x, in_x);\n\t\tx = dc_fixpt_div_int(x, 3);\n\t} else {\n\t\tx = dc_fixpt_sub(in_x, c);\n\t\tx = dc_fixpt_div(x, a);\n\t\tx = dc_fixpt_exp(x);\n\t\tx = dc_fixpt_add(x, b);\n\t\tx = dc_fixpt_div_int(x, 12);\n\t}\n\t*out_y = dc_fixpt_mul(x, scaling_factor);\n\n}\n\n \nstatic void compute_hlg_oetf(struct fixed31_32 in_x, struct fixed31_32 *out_y,\n\t\tuint32_t sdr_white_level, uint32_t max_luminance_nits)\n{\n\tstruct fixed31_32 a;\n\tstruct fixed31_32 b;\n\tstruct fixed31_32 c;\n\tstruct fixed31_32 threshold;\n\tstruct fixed31_32 x;\n\n\tstruct fixed31_32 scaling_factor =\n\t\t\tdc_fixpt_from_fraction(sdr_white_level, max_luminance_nits);\n\ta = dc_fixpt_from_fraction(17883277, 100000000);\n\tb = dc_fixpt_from_fraction(28466892, 100000000);\n\tc = dc_fixpt_from_fraction(55991073, 100000000);\n\tthreshold = dc_fixpt_from_fraction(1, 12);\n\tx = dc_fixpt_mul(in_x, scaling_factor);\n\n\n\tif (dc_fixpt_lt(x, threshold)) {\n\t\tx = dc_fixpt_mul(x, dc_fixpt_from_fraction(3, 1));\n\t\t*out_y = dc_fixpt_pow(x, dc_fixpt_half);\n\t} else {\n\t\tx = dc_fixpt_mul(x, dc_fixpt_from_fraction(12, 1));\n\t\tx = dc_fixpt_sub(x, b);\n\t\tx = dc_fixpt_log(x);\n\t\tx = dc_fixpt_mul(a, x);\n\t\t*out_y = dc_fixpt_add(x, c);\n\t}\n}\n\n\n \nvoid precompute_pq(void)\n{\n\tint i;\n\tstruct fixed31_32 x;\n\tconst struct hw_x_point *coord_x = coordinates_x + 32;\n\tstruct fixed31_32 scaling_factor =\n\t\t\tdc_fixpt_from_fraction(80, 10000);\n\n\tstruct fixed31_32 *pq_table = mod_color_get_table(type_pq_table);\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tpq_table[i] = dc_fixpt_zero;\n\n\tfor (i = 32; i <= MAX_HW_POINTS; i++) {\n\t\tx = dc_fixpt_mul(coord_x->x, scaling_factor);\n\t\tcompute_pq(x, &pq_table[i]);\n\t\t++coord_x;\n\t}\n}\n\n \nvoid precompute_de_pq(void)\n{\n\tint i;\n\tstruct fixed31_32  y;\n\tuint32_t begin_index, end_index;\n\n\tstruct fixed31_32 scaling_factor = dc_fixpt_from_int(125);\n\tstruct fixed31_32 *de_pq_table = mod_color_get_table(type_de_pq_table);\n\t \n\tbegin_index = 13 * NUM_PTS_IN_REGION;\n\tend_index = begin_index + 12 * NUM_PTS_IN_REGION;\n\n\tfor (i = 0; i <= begin_index; i++)\n\t\tde_pq_table[i] = dc_fixpt_zero;\n\n\tfor (; i <= end_index; i++) {\n\t\tcompute_de_pq(coordinates_x[i].x, &y);\n\t\tde_pq_table[i] = dc_fixpt_mul(y, scaling_factor);\n\t}\n\n\tfor (; i <= MAX_HW_POINTS; i++)\n\t\tde_pq_table[i] = de_pq_table[i-1];\n}\nstruct dividers {\n\tstruct fixed31_32 divider1;\n\tstruct fixed31_32 divider2;\n\tstruct fixed31_32 divider3;\n};\n\n\nstatic bool build_coefficients(struct gamma_coefficients *coefficients,\n\t\tenum dc_transfer_func_predefined type)\n{\n\n\tuint32_t i = 0;\n\tuint32_t index = 0;\n\tbool ret = true;\n\n\tif (type == TRANSFER_FUNCTION_SRGB)\n\t\tindex = 0;\n\telse if (type == TRANSFER_FUNCTION_BT709)\n\t\tindex = 1;\n\telse if (type == TRANSFER_FUNCTION_GAMMA22)\n\t\tindex = 2;\n\telse if (type == TRANSFER_FUNCTION_GAMMA24)\n\t\tindex = 3;\n\telse if (type == TRANSFER_FUNCTION_GAMMA26)\n\t\tindex = 4;\n\telse {\n\t\tret = false;\n\t\tgoto release;\n\t}\n\n\tdo {\n\t\tcoefficients->a0[i] = dc_fixpt_from_fraction(\n\t\t\tnumerator01[index], 10000000);\n\t\tcoefficients->a1[i] = dc_fixpt_from_fraction(\n\t\t\tnumerator02[index], 1000);\n\t\tcoefficients->a2[i] = dc_fixpt_from_fraction(\n\t\t\tnumerator03[index], 1000);\n\t\tcoefficients->a3[i] = dc_fixpt_from_fraction(\n\t\t\tnumerator04[index], 1000);\n\t\tcoefficients->user_gamma[i] = dc_fixpt_from_fraction(\n\t\t\tnumerator05[index], 1000);\n\n\t\t++i;\n\t} while (i != ARRAY_SIZE(coefficients->a0));\nrelease:\n\treturn ret;\n}\n\nstatic struct fixed31_32 translate_from_linear_space(\n\t\tstruct translate_from_linear_space_args *args)\n{\n\tconst struct fixed31_32 one = dc_fixpt_from_int(1);\n\n\tstruct fixed31_32 scratch_1, scratch_2;\n\tstruct calculate_buffer *cal_buffer = args->cal_buffer;\n\n\tif (dc_fixpt_le(one, args->arg))\n\t\treturn one;\n\n\tif (dc_fixpt_le(args->arg, dc_fixpt_neg(args->a0))) {\n\t\tscratch_1 = dc_fixpt_add(one, args->a3);\n\t\tscratch_2 = dc_fixpt_pow(\n\t\t\t\tdc_fixpt_neg(args->arg),\n\t\t\t\tdc_fixpt_recip(args->gamma));\n\t\tscratch_1 = dc_fixpt_mul(scratch_1, scratch_2);\n\t\tscratch_1 = dc_fixpt_sub(args->a2, scratch_1);\n\n\t\treturn scratch_1;\n\t} else if (dc_fixpt_le(args->a0, args->arg)) {\n\t\tif (cal_buffer->buffer_index == 0) {\n\t\t\tcal_buffer->gamma_of_2 = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\tdc_fixpt_recip(args->gamma));\n\t\t}\n\t\tscratch_1 = dc_fixpt_add(one, args->a3);\n\t\t \n\t\tif ((cal_buffer->buffer_index >= PRECISE_LUT_REGION_START &&\n\t\t\tcal_buffer->buffer_index <= PRECISE_LUT_REGION_END) ||\n\t\t\t(cal_buffer->buffer_index < 16))\n\t\t\tscratch_2 = dc_fixpt_pow(args->arg,\n\t\t\t\t\tdc_fixpt_recip(args->gamma));\n\t\telse\n\t\t\tscratch_2 = dc_fixpt_mul(cal_buffer->gamma_of_2,\n\t\t\t\t\tcal_buffer->buffer[cal_buffer->buffer_index%16]);\n\n\t\tif (cal_buffer->buffer_index != -1) {\n\t\t\tcal_buffer->buffer[cal_buffer->buffer_index%16] = scratch_2;\n\t\t\tcal_buffer->buffer_index++;\n\t\t}\n\n\t\tscratch_1 = dc_fixpt_mul(scratch_1, scratch_2);\n\t\tscratch_1 = dc_fixpt_sub(scratch_1, args->a2);\n\n\t\treturn scratch_1;\n\t} else\n\t\treturn dc_fixpt_mul(args->arg, args->a1);\n}\n\n\nstatic struct fixed31_32 translate_from_linear_space_long(\n\t\tstruct translate_from_linear_space_args *args)\n{\n\tconst struct fixed31_32 one = dc_fixpt_from_int(1);\n\n\tif (dc_fixpt_lt(one, args->arg))\n\t\treturn one;\n\n\tif (dc_fixpt_le(args->arg, dc_fixpt_neg(args->a0)))\n\t\treturn dc_fixpt_sub(\n\t\t\targs->a2,\n\t\t\tdc_fixpt_mul(\n\t\t\t\tdc_fixpt_add(\n\t\t\t\t\tone,\n\t\t\t\t\targs->a3),\n\t\t\t\tdc_fixpt_pow(\n\t\t\t\t\tdc_fixpt_neg(args->arg),\n\t\t\t\t\tdc_fixpt_recip(args->gamma))));\n\telse if (dc_fixpt_le(args->a0, args->arg))\n\t\treturn dc_fixpt_sub(\n\t\t\tdc_fixpt_mul(\n\t\t\t\tdc_fixpt_add(\n\t\t\t\t\tone,\n\t\t\t\t\targs->a3),\n\t\t\t\tdc_fixpt_pow(\n\t\t\t\t\t\targs->arg,\n\t\t\t\t\tdc_fixpt_recip(args->gamma))),\n\t\t\t\t\targs->a2);\n\telse\n\t\treturn dc_fixpt_mul(args->arg, args->a1);\n}\n\nstatic struct fixed31_32 calculate_gamma22(struct fixed31_32 arg, bool use_eetf, struct calculate_buffer *cal_buffer)\n{\n\tstruct fixed31_32 gamma = dc_fixpt_from_fraction(22, 10);\n\tstruct translate_from_linear_space_args scratch_gamma_args;\n\n\tscratch_gamma_args.arg = arg;\n\tscratch_gamma_args.a0 = dc_fixpt_zero;\n\tscratch_gamma_args.a1 = dc_fixpt_zero;\n\tscratch_gamma_args.a2 = dc_fixpt_zero;\n\tscratch_gamma_args.a3 = dc_fixpt_zero;\n\tscratch_gamma_args.cal_buffer = cal_buffer;\n\tscratch_gamma_args.gamma = gamma;\n\n\tif (use_eetf)\n\t\treturn translate_from_linear_space_long(&scratch_gamma_args);\n\n\treturn translate_from_linear_space(&scratch_gamma_args);\n}\n\n\nstatic struct fixed31_32 translate_to_linear_space(\n\tstruct fixed31_32 arg,\n\tstruct fixed31_32 a0,\n\tstruct fixed31_32 a1,\n\tstruct fixed31_32 a2,\n\tstruct fixed31_32 a3,\n\tstruct fixed31_32 gamma)\n{\n\tstruct fixed31_32 linear;\n\n\ta0 = dc_fixpt_mul(a0, a1);\n\tif (dc_fixpt_le(arg, dc_fixpt_neg(a0)))\n\n\t\tlinear = dc_fixpt_neg(\n\t\t\t\t dc_fixpt_pow(\n\t\t\t\t dc_fixpt_div(\n\t\t\t\t dc_fixpt_sub(a2, arg),\n\t\t\t\t dc_fixpt_add(\n\t\t\t\t dc_fixpt_one, a3)), gamma));\n\n\telse if (dc_fixpt_le(dc_fixpt_neg(a0), arg) &&\n\t\t\t dc_fixpt_le(arg, a0))\n\t\tlinear = dc_fixpt_div(arg, a1);\n\telse\n\t\tlinear =  dc_fixpt_pow(\n\t\t\t\t\tdc_fixpt_div(\n\t\t\t\t\tdc_fixpt_add(a2, arg),\n\t\t\t\t\tdc_fixpt_add(\n\t\t\t\t\tdc_fixpt_one, a3)), gamma);\n\n\treturn linear;\n}\n\nstatic struct fixed31_32 translate_from_linear_space_ex(\n\tstruct fixed31_32 arg,\n\tstruct gamma_coefficients *coeff,\n\tuint32_t color_index,\n\tstruct calculate_buffer *cal_buffer)\n{\n\tstruct translate_from_linear_space_args scratch_gamma_args;\n\n\tscratch_gamma_args.arg = arg;\n\tscratch_gamma_args.a0 = coeff->a0[color_index];\n\tscratch_gamma_args.a1 = coeff->a1[color_index];\n\tscratch_gamma_args.a2 = coeff->a2[color_index];\n\tscratch_gamma_args.a3 = coeff->a3[color_index];\n\tscratch_gamma_args.gamma = coeff->user_gamma[color_index];\n\tscratch_gamma_args.cal_buffer = cal_buffer;\n\n\treturn translate_from_linear_space(&scratch_gamma_args);\n}\n\n\nstatic inline struct fixed31_32 translate_to_linear_space_ex(\n\tstruct fixed31_32 arg,\n\tstruct gamma_coefficients *coeff,\n\tuint32_t color_index)\n{\n\treturn translate_to_linear_space(\n\t\targ,\n\t\tcoeff->a0[color_index],\n\t\tcoeff->a1[color_index],\n\t\tcoeff->a2[color_index],\n\t\tcoeff->a3[color_index],\n\t\tcoeff->user_gamma[color_index]);\n}\n\n\nstatic bool find_software_points(\n\tconst struct dc_gamma *ramp,\n\tconst struct gamma_pixel *axis_x,\n\tstruct fixed31_32 hw_point,\n\tenum channel_name channel,\n\tuint32_t *index_to_start,\n\tuint32_t *index_left,\n\tuint32_t *index_right,\n\tenum hw_point_position *pos)\n{\n\tconst uint32_t max_number = ramp->num_entries + 3;\n\n\tstruct fixed31_32 left, right;\n\n\tuint32_t i = *index_to_start;\n\n\twhile (i < max_number) {\n\t\tif (channel == CHANNEL_NAME_RED) {\n\t\t\tleft = axis_x[i].r;\n\n\t\t\tif (i < max_number - 1)\n\t\t\t\tright = axis_x[i + 1].r;\n\t\t\telse\n\t\t\t\tright = axis_x[max_number - 1].r;\n\t\t} else if (channel == CHANNEL_NAME_GREEN) {\n\t\t\tleft = axis_x[i].g;\n\n\t\t\tif (i < max_number - 1)\n\t\t\t\tright = axis_x[i + 1].g;\n\t\t\telse\n\t\t\t\tright = axis_x[max_number - 1].g;\n\t\t} else {\n\t\t\tleft = axis_x[i].b;\n\n\t\t\tif (i < max_number - 1)\n\t\t\t\tright = axis_x[i + 1].b;\n\t\t\telse\n\t\t\t\tright = axis_x[max_number - 1].b;\n\t\t}\n\n\t\tif (dc_fixpt_le(left, hw_point) &&\n\t\t\tdc_fixpt_le(hw_point, right)) {\n\t\t\t*index_to_start = i;\n\t\t\t*index_left = i;\n\n\t\t\tif (i < max_number - 1)\n\t\t\t\t*index_right = i + 1;\n\t\t\telse\n\t\t\t\t*index_right = max_number - 1;\n\n\t\t\t*pos = HW_POINT_POSITION_MIDDLE;\n\n\t\t\treturn true;\n\t\t} else if ((i == *index_to_start) &&\n\t\t\tdc_fixpt_le(hw_point, left)) {\n\t\t\t*index_to_start = i;\n\t\t\t*index_left = i;\n\t\t\t*index_right = i;\n\n\t\t\t*pos = HW_POINT_POSITION_LEFT;\n\n\t\t\treturn true;\n\t\t} else if ((i == max_number - 1) &&\n\t\t\tdc_fixpt_le(right, hw_point)) {\n\t\t\t*index_to_start = i;\n\t\t\t*index_left = i;\n\t\t\t*index_right = i;\n\n\t\t\t*pos = HW_POINT_POSITION_RIGHT;\n\n\t\t\treturn true;\n\t\t}\n\n\t\t++i;\n\t}\n\n\treturn false;\n}\n\nstatic bool build_custom_gamma_mapping_coefficients_worker(\n\tconst struct dc_gamma *ramp,\n\tstruct pixel_gamma_point *coeff,\n\tconst struct hw_x_point *coordinates_x,\n\tconst struct gamma_pixel *axis_x,\n\tenum channel_name channel,\n\tuint32_t number_of_points)\n{\n\tuint32_t i = 0;\n\n\twhile (i <= number_of_points) {\n\t\tstruct fixed31_32 coord_x;\n\n\t\tuint32_t index_to_start = 0;\n\t\tuint32_t index_left = 0;\n\t\tuint32_t index_right = 0;\n\n\t\tenum hw_point_position hw_pos;\n\n\t\tstruct gamma_point *point;\n\n\t\tstruct fixed31_32 left_pos;\n\t\tstruct fixed31_32 right_pos;\n\n\t\tif (channel == CHANNEL_NAME_RED)\n\t\t\tcoord_x = coordinates_x[i].regamma_y_red;\n\t\telse if (channel == CHANNEL_NAME_GREEN)\n\t\t\tcoord_x = coordinates_x[i].regamma_y_green;\n\t\telse\n\t\t\tcoord_x = coordinates_x[i].regamma_y_blue;\n\n\t\tif (!find_software_points(\n\t\t\tramp, axis_x, coord_x, channel,\n\t\t\t&index_to_start, &index_left, &index_right, &hw_pos)) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (index_left >= ramp->num_entries + 3) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (index_right >= ramp->num_entries + 3) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (channel == CHANNEL_NAME_RED) {\n\t\t\tpoint = &coeff[i].r;\n\n\t\t\tleft_pos = axis_x[index_left].r;\n\t\t\tright_pos = axis_x[index_right].r;\n\t\t} else if (channel == CHANNEL_NAME_GREEN) {\n\t\t\tpoint = &coeff[i].g;\n\n\t\t\tleft_pos = axis_x[index_left].g;\n\t\t\tright_pos = axis_x[index_right].g;\n\t\t} else {\n\t\t\tpoint = &coeff[i].b;\n\n\t\t\tleft_pos = axis_x[index_left].b;\n\t\t\tright_pos = axis_x[index_right].b;\n\t\t}\n\n\t\tif (hw_pos == HW_POINT_POSITION_MIDDLE)\n\t\t\tpoint->coeff = dc_fixpt_div(\n\t\t\t\tdc_fixpt_sub(\n\t\t\t\t\tcoord_x,\n\t\t\t\t\tleft_pos),\n\t\t\t\tdc_fixpt_sub(\n\t\t\t\t\tright_pos,\n\t\t\t\t\tleft_pos));\n\t\telse if (hw_pos == HW_POINT_POSITION_LEFT)\n\t\t\tpoint->coeff = dc_fixpt_zero;\n\t\telse if (hw_pos == HW_POINT_POSITION_RIGHT)\n\t\t\tpoint->coeff = dc_fixpt_from_int(2);\n\t\telse {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\treturn false;\n\t\t}\n\n\t\tpoint->left_index = index_left;\n\t\tpoint->right_index = index_right;\n\t\tpoint->pos = hw_pos;\n\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\nstatic struct fixed31_32 calculate_mapped_value(\n\tstruct pwl_float_data *rgb,\n\tconst struct pixel_gamma_point *coeff,\n\tenum channel_name channel,\n\tuint32_t max_index)\n{\n\tconst struct gamma_point *point;\n\n\tstruct fixed31_32 result;\n\n\tif (channel == CHANNEL_NAME_RED)\n\t\tpoint = &coeff->r;\n\telse if (channel == CHANNEL_NAME_GREEN)\n\t\tpoint = &coeff->g;\n\telse\n\t\tpoint = &coeff->b;\n\n\tif ((point->left_index < 0) || (point->left_index > max_index)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn dc_fixpt_zero;\n\t}\n\n\tif ((point->right_index < 0) || (point->right_index > max_index)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn dc_fixpt_zero;\n\t}\n\n\tif (point->pos == HW_POINT_POSITION_MIDDLE)\n\t\tif (channel == CHANNEL_NAME_RED)\n\t\t\tresult = dc_fixpt_add(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\tpoint->coeff,\n\t\t\t\t\tdc_fixpt_sub(\n\t\t\t\t\t\trgb[point->right_index].r,\n\t\t\t\t\t\trgb[point->left_index].r)),\n\t\t\t\trgb[point->left_index].r);\n\t\telse if (channel == CHANNEL_NAME_GREEN)\n\t\t\tresult = dc_fixpt_add(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\tpoint->coeff,\n\t\t\t\t\tdc_fixpt_sub(\n\t\t\t\t\t\trgb[point->right_index].g,\n\t\t\t\t\t\trgb[point->left_index].g)),\n\t\t\t\trgb[point->left_index].g);\n\t\telse\n\t\t\tresult = dc_fixpt_add(\n\t\t\t\tdc_fixpt_mul(\n\t\t\t\t\tpoint->coeff,\n\t\t\t\t\tdc_fixpt_sub(\n\t\t\t\t\t\trgb[point->right_index].b,\n\t\t\t\t\t\trgb[point->left_index].b)),\n\t\t\t\trgb[point->left_index].b);\n\telse if (point->pos == HW_POINT_POSITION_LEFT) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tresult = dc_fixpt_zero;\n\t} else {\n\t\tresult = dc_fixpt_one;\n\t}\n\n\treturn result;\n}\n\nstatic void build_pq(struct pwl_float_data_ex *rgb_regamma,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x,\n\t\tuint32_t sdr_white_level)\n{\n\tuint32_t i, start_index;\n\n\tstruct pwl_float_data_ex *rgb = rgb_regamma;\n\tconst struct hw_x_point *coord_x = coordinate_x;\n\tstruct fixed31_32 x;\n\tstruct fixed31_32 output;\n\tstruct fixed31_32 scaling_factor =\n\t\t\tdc_fixpt_from_fraction(sdr_white_level, 10000);\n\tstruct fixed31_32 *pq_table = mod_color_get_table(type_pq_table);\n\n\tif (!mod_color_is_table_init(type_pq_table) && sdr_white_level == 80) {\n\t\tprecompute_pq();\n\t\tmod_color_set_table_init_state(type_pq_table, true);\n\t}\n\n\t \n\tstart_index = 32;\n\trgb += start_index;\n\tcoord_x += start_index;\n\n\tfor (i = start_index; i <= hw_points_num; i++) {\n\t\t \n\t\tif (sdr_white_level == 80) {\n\t\t\toutput = pq_table[i];\n\t\t} else {\n\t\t\tx = dc_fixpt_mul(coord_x->x, scaling_factor);\n\t\t\tcompute_pq(x, &output);\n\t\t}\n\n\t\t \n\t\tif (dc_fixpt_lt(output, dc_fixpt_zero))\n\t\t\toutput = dc_fixpt_zero;\n\t\telse if (dc_fixpt_lt(dc_fixpt_one, output))\n\t\t\toutput = dc_fixpt_one;\n\n\t\trgb->r = output;\n\t\trgb->g = output;\n\t\trgb->b = output;\n\n\t\t++coord_x;\n\t\t++rgb;\n\t}\n}\n\nstatic void build_de_pq(struct pwl_float_data_ex *de_pq,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x)\n{\n\tuint32_t i;\n\tstruct fixed31_32 output;\n\tstruct fixed31_32 *de_pq_table = mod_color_get_table(type_de_pq_table);\n\tstruct fixed31_32 scaling_factor = dc_fixpt_from_int(125);\n\n\tif (!mod_color_is_table_init(type_de_pq_table)) {\n\t\tprecompute_de_pq();\n\t\tmod_color_set_table_init_state(type_de_pq_table, true);\n\t}\n\n\n\tfor (i = 0; i <= hw_points_num; i++) {\n\t\toutput = de_pq_table[i];\n\t\t \n\t\tif (dc_fixpt_lt(output, dc_fixpt_zero))\n\t\t\toutput = dc_fixpt_zero;\n\t\telse if (dc_fixpt_lt(scaling_factor, output))\n\t\t\toutput = scaling_factor;\n\t\tde_pq[i].r = output;\n\t\tde_pq[i].g = output;\n\t\tde_pq[i].b = output;\n\t}\n}\n\nstatic bool build_regamma(struct pwl_float_data_ex *rgb_regamma,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x,\n\t\tenum dc_transfer_func_predefined type,\n\t\tstruct calculate_buffer *cal_buffer)\n{\n\tuint32_t i;\n\tbool ret = false;\n\n\tstruct gamma_coefficients *coeff;\n\tstruct pwl_float_data_ex *rgb = rgb_regamma;\n\tconst struct hw_x_point *coord_x = coordinate_x;\n\n\tcoeff = kvzalloc(sizeof(*coeff), GFP_KERNEL);\n\tif (!coeff)\n\t\tgoto release;\n\n\tif (!build_coefficients(coeff, type))\n\t\tgoto release;\n\n\tmemset(cal_buffer->buffer, 0, NUM_PTS_IN_REGION * sizeof(struct fixed31_32));\n\tcal_buffer->buffer_index = 0; \n\n\ti = 0;\n\twhile (i <= hw_points_num) {\n\t\t \n\t\trgb->r = translate_from_linear_space_ex(\n\t\t\tcoord_x->x, coeff, 0, cal_buffer);\n\t\trgb->g = rgb->r;\n\t\trgb->b = rgb->r;\n\t\t++coord_x;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcal_buffer->buffer_index = -1;\n\tret = true;\nrelease:\n\tkvfree(coeff);\n\treturn ret;\n}\n\nstatic void hermite_spline_eetf(struct fixed31_32 input_x,\n\t\t\t\tstruct fixed31_32 max_display,\n\t\t\t\tstruct fixed31_32 min_display,\n\t\t\t\tstruct fixed31_32 max_content,\n\t\t\t\tstruct fixed31_32 *out_x)\n{\n\tstruct fixed31_32 min_lum_pq;\n\tstruct fixed31_32 max_lum_pq;\n\tstruct fixed31_32 max_content_pq;\n\tstruct fixed31_32 ks;\n\tstruct fixed31_32 E1;\n\tstruct fixed31_32 E2;\n\tstruct fixed31_32 E3;\n\tstruct fixed31_32 t;\n\tstruct fixed31_32 t2;\n\tstruct fixed31_32 t3;\n\tstruct fixed31_32 two;\n\tstruct fixed31_32 three;\n\tstruct fixed31_32 temp1;\n\tstruct fixed31_32 temp2;\n\tstruct fixed31_32 a = dc_fixpt_from_fraction(15, 10);\n\tstruct fixed31_32 b = dc_fixpt_from_fraction(5, 10);\n\tstruct fixed31_32 epsilon = dc_fixpt_from_fraction(1, 1000000); \n\n\tif (dc_fixpt_eq(max_content, dc_fixpt_zero)) {\n\t\t*out_x = dc_fixpt_zero;\n\t\treturn;\n\t}\n\n\tcompute_pq(input_x, &E1);\n\tcompute_pq(dc_fixpt_div(min_display, max_content), &min_lum_pq);\n\tcompute_pq(dc_fixpt_div(max_display, max_content), &max_lum_pq);\n\tcompute_pq(dc_fixpt_one, &max_content_pq); \n\ta = dc_fixpt_div(dc_fixpt_add(dc_fixpt_one, b), max_content_pq); \n\tks = dc_fixpt_sub(dc_fixpt_mul(a, max_lum_pq), b); \n\n\tif (dc_fixpt_lt(E1, ks))\n\t\tE2 = E1;\n\telse if (dc_fixpt_le(ks, E1) && dc_fixpt_le(E1, dc_fixpt_one)) {\n\t\tif (dc_fixpt_lt(epsilon, dc_fixpt_sub(dc_fixpt_one, ks)))\n\t\t\t\n\t\t\tt = dc_fixpt_div(dc_fixpt_sub(E1, ks),\n\t\t\t\t\tdc_fixpt_sub(dc_fixpt_one, ks));\n\t\telse\n\t\t\tt = dc_fixpt_zero;\n\n\t\ttwo = dc_fixpt_from_int(2);\n\t\tthree = dc_fixpt_from_int(3);\n\n\t\tt2 = dc_fixpt_mul(t, t);\n\t\tt3 = dc_fixpt_mul(t2, t);\n\t\ttemp1 = dc_fixpt_mul(two, t3);\n\t\ttemp2 = dc_fixpt_mul(three, t2);\n\n\t\t\n\t\tE2 = dc_fixpt_mul(ks, dc_fixpt_add(dc_fixpt_one,\n\t\t\t\tdc_fixpt_sub(temp1, temp2)));\n\n\t\t\n\t\tE2 = dc_fixpt_add(E2, dc_fixpt_mul(max_lum_pq,\n\t\t\t\tdc_fixpt_sub(temp2, temp1)));\n\n\t\ttemp1 = dc_fixpt_mul(two, t2);\n\t\ttemp2 = dc_fixpt_sub(dc_fixpt_one, ks);\n\n\t\t\n\t\tE2 = dc_fixpt_add(E2, dc_fixpt_mul(temp2,\n\t\t\t\tdc_fixpt_add(t, dc_fixpt_sub(t3, temp1))));\n\t} else\n\t\tE2 = dc_fixpt_one;\n\n\ttemp1 = dc_fixpt_sub(dc_fixpt_one, E2);\n\ttemp2 = dc_fixpt_mul(temp1, temp1);\n\ttemp2 = dc_fixpt_mul(temp2, temp2);\n\t\n\n\tE3 =  dc_fixpt_add(E2, dc_fixpt_mul(min_lum_pq, temp2));\n\tcompute_de_pq(E3, out_x);\n\n\t*out_x = dc_fixpt_div(*out_x, dc_fixpt_div(max_display, max_content));\n}\n\nstatic bool build_freesync_hdr(struct pwl_float_data_ex *rgb_regamma,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x,\n\t\tconst struct hdr_tm_params *fs_params,\n\t\tstruct calculate_buffer *cal_buffer)\n{\n\tuint32_t i;\n\tstruct pwl_float_data_ex *rgb = rgb_regamma;\n\tconst struct hw_x_point *coord_x = coordinate_x;\n\tconst struct hw_x_point *prv_coord_x = coord_x;\n\tstruct fixed31_32 scaledX = dc_fixpt_zero;\n\tstruct fixed31_32 scaledX1 = dc_fixpt_zero;\n\tstruct fixed31_32 max_display;\n\tstruct fixed31_32 min_display;\n\tstruct fixed31_32 max_content;\n\tstruct fixed31_32 clip = dc_fixpt_one;\n\tstruct fixed31_32 output;\n\tbool use_eetf = false;\n\tbool is_clipped = false;\n\tstruct fixed31_32 sdr_white_level;\n\tstruct fixed31_32 coordX_diff;\n\tstruct fixed31_32 out_dist_max;\n\tstruct fixed31_32 bright_norm;\n\n\tif (fs_params->max_content == 0 ||\n\t\t\tfs_params->max_display == 0)\n\t\treturn false;\n\n\tmax_display = dc_fixpt_from_int(fs_params->max_display);\n\tmin_display = dc_fixpt_from_fraction(fs_params->min_display, 10000);\n\tmax_content = dc_fixpt_from_int(fs_params->max_content);\n\tsdr_white_level = dc_fixpt_from_int(fs_params->sdr_white_level);\n\n\tif (fs_params->min_display > 1000) \n\t\tmin_display = dc_fixpt_from_fraction(1, 10);\n\tif (fs_params->max_display < 100) \n\t\tmax_display = dc_fixpt_from_int(100);\n\n\t\n\tif (fs_params->max_content > fs_params->max_display)\n\t\tuse_eetf = true;\n\telse\n\t\tmax_content = max_display;\n\n\tif (!use_eetf)\n\t\tcal_buffer->buffer_index = 0; \n\trgb += 32; \n\tcoord_x += 32;\n\n\tfor (i = 32; i <= hw_points_num; i++) {\n\t\tif (!is_clipped) {\n\t\t\tif (use_eetf) {\n\t\t\t\t \n\t\t\t\tscaledX1 = dc_fixpt_div(coord_x->x,\n\t\t\t\t\t\tdc_fixpt_div(max_content, sdr_white_level));\n\t\t\t\thermite_spline_eetf(scaledX1, max_display, min_display,\n\t\t\t\t\t\tmax_content, &scaledX);\n\t\t\t} else\n\t\t\t\tscaledX = dc_fixpt_div(coord_x->x,\n\t\t\t\t\t\tdc_fixpt_div(max_display, sdr_white_level));\n\n\t\t\tif (dc_fixpt_lt(scaledX, clip)) {\n\t\t\t\tif (dc_fixpt_lt(scaledX, dc_fixpt_zero))\n\t\t\t\t\toutput = dc_fixpt_zero;\n\t\t\t\telse\n\t\t\t\t\toutput = calculate_gamma22(scaledX, use_eetf, cal_buffer);\n\n\t\t\t\t\n\t\t\t\toutput = dc_fixpt_clamp(output, dc_fixpt_zero, dc_fixpt_one);\n\n\t\t\t\trgb->r = output;\n\t\t\t\trgb->g = output;\n\t\t\t\trgb->b = output;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tis_clipped = true;\n\n\t\t\t\t \n\n\t\t\t\tcoordX_diff = dc_fixpt_sub(coord_x->x, prv_coord_x->x);\n\t\t\t\tout_dist_max = dc_fixpt_sub(dc_fixpt_one, output);\n\t\t\t\tbright_norm = dc_fixpt_div(max_display, sdr_white_level);\n\n\t\t\t\toutput = dc_fixpt_add(\n\t\t\t\t\toutput, dc_fixpt_mul(\n\t\t\t\t\t\tcoordX_diff, dc_fixpt_div(\n\t\t\t\t\t\t\tout_dist_max,\n\t\t\t\t\t\t\tdc_fixpt_sub(bright_norm, prv_coord_x->x)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t \n\t\t\t\toutput = dc_fixpt_clamp(output, dc_fixpt_zero,\n\t\t\t\t\tdc_fixpt_from_fraction(107, 100));\n\n\t\t\t\trgb->r = output;\n\t\t\t\trgb->g = output;\n\t\t\t\trgb->b = output;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trgb->r = clip;\n\t\t\trgb->g = clip;\n\t\t\trgb->b = clip;\n\t\t}\n\n\t\tprv_coord_x = coord_x;\n\t\t++coord_x;\n\t\t++rgb;\n\t}\n\tcal_buffer->buffer_index = -1;\n\n\treturn true;\n}\n\nstatic bool build_degamma(struct pwl_float_data_ex *curve,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x, enum dc_transfer_func_predefined type)\n{\n\tuint32_t i;\n\tstruct gamma_coefficients coeff;\n\tuint32_t begin_index, end_index;\n\tbool ret = false;\n\n\tif (!build_coefficients(&coeff, type))\n\t\tgoto release;\n\n\ti = 0;\n\n\t \n\tbegin_index = 13 * NUM_PTS_IN_REGION;\n\tend_index = begin_index + 12 * NUM_PTS_IN_REGION;\n\n\twhile (i != begin_index) {\n\t\tcurve[i].r = dc_fixpt_zero;\n\t\tcurve[i].g = dc_fixpt_zero;\n\t\tcurve[i].b = dc_fixpt_zero;\n\t\ti++;\n\t}\n\n\twhile (i != end_index) {\n\t\tcurve[i].r = translate_to_linear_space_ex(\n\t\t\t\tcoordinate_x[i].x, &coeff, 0);\n\t\tcurve[i].g = curve[i].r;\n\t\tcurve[i].b = curve[i].r;\n\t\ti++;\n\t}\n\twhile (i != hw_points_num + 1) {\n\t\tcurve[i].r = dc_fixpt_one;\n\t\tcurve[i].g = dc_fixpt_one;\n\t\tcurve[i].b = dc_fixpt_one;\n\t\ti++;\n\t}\n\tret = true;\nrelease:\n\treturn ret;\n}\n\n\n\n\n\nstatic void build_hlg_degamma(struct pwl_float_data_ex *degamma,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x,\n\t\tuint32_t sdr_white_level, uint32_t max_luminance_nits)\n{\n\tuint32_t i;\n\n\tstruct pwl_float_data_ex *rgb = degamma;\n\tconst struct hw_x_point *coord_x = coordinate_x;\n\n\ti = 0;\n\t\n\twhile (i != hw_points_num + 1) {\n\t\tcompute_hlg_eotf(coord_x->x, &rgb->r, sdr_white_level, max_luminance_nits);\n\t\trgb->g = rgb->r;\n\t\trgb->b = rgb->r;\n\t\t++coord_x;\n\t\t++rgb;\n\t\t++i;\n\t}\n}\n\n\nstatic void build_hlg_regamma(struct pwl_float_data_ex *regamma,\n\t\tuint32_t hw_points_num,\n\t\tconst struct hw_x_point *coordinate_x,\n\t\tuint32_t sdr_white_level, uint32_t max_luminance_nits)\n{\n\tuint32_t i;\n\n\tstruct pwl_float_data_ex *rgb = regamma;\n\tconst struct hw_x_point *coord_x = coordinate_x;\n\n\ti = 0;\n\n\t\n\twhile (i != hw_points_num + 1) {\n\t\tcompute_hlg_oetf(coord_x->x, &rgb->r, sdr_white_level, max_luminance_nits);\n\t\trgb->g = rgb->r;\n\t\trgb->b = rgb->r;\n\t\t++coord_x;\n\t\t++rgb;\n\t\t++i;\n\t}\n}\n\nstatic void scale_gamma(struct pwl_float_data *pwl_rgb,\n\t\tconst struct dc_gamma *ramp,\n\t\tstruct dividers dividers)\n{\n\tconst struct fixed31_32 max_driver = dc_fixpt_from_int(0xFFFF);\n\tconst struct fixed31_32 max_os = dc_fixpt_from_int(0xFF00);\n\tstruct fixed31_32 scaler = max_os;\n\tuint32_t i;\n\tstruct pwl_float_data *rgb = pwl_rgb;\n\tstruct pwl_float_data *rgb_last = rgb + ramp->num_entries - 1;\n\n\ti = 0;\n\n\tdo {\n\t\tif (dc_fixpt_lt(max_os, ramp->entries.red[i]) ||\n\t\t\tdc_fixpt_lt(max_os, ramp->entries.green[i]) ||\n\t\t\tdc_fixpt_lt(max_os, ramp->entries.blue[i])) {\n\t\t\tscaler = max_driver;\n\t\t\tbreak;\n\t\t}\n\t\t++i;\n\t} while (i != ramp->num_entries);\n\n\ti = 0;\n\n\tdo {\n\t\trgb->r = dc_fixpt_div(\n\t\t\tramp->entries.red[i], scaler);\n\t\trgb->g = dc_fixpt_div(\n\t\t\tramp->entries.green[i], scaler);\n\t\trgb->b = dc_fixpt_div(\n\t\t\tramp->entries.blue[i], scaler);\n\n\t\t++rgb;\n\t\t++i;\n\t} while (i != ramp->num_entries);\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider1);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider1);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider1);\n\n\t++rgb;\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider2);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider2);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider2);\n\n\t++rgb;\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider3);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider3);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider3);\n}\n\nstatic void scale_gamma_dx(struct pwl_float_data *pwl_rgb,\n\t\tconst struct dc_gamma *ramp,\n\t\tstruct dividers dividers)\n{\n\tuint32_t i;\n\tstruct fixed31_32 min = dc_fixpt_zero;\n\tstruct fixed31_32 max = dc_fixpt_one;\n\n\tstruct fixed31_32 delta = dc_fixpt_zero;\n\tstruct fixed31_32 offset = dc_fixpt_zero;\n\n\tfor (i = 0 ; i < ramp->num_entries; i++) {\n\t\tif (dc_fixpt_lt(ramp->entries.red[i], min))\n\t\t\tmin = ramp->entries.red[i];\n\n\t\tif (dc_fixpt_lt(ramp->entries.green[i], min))\n\t\t\tmin = ramp->entries.green[i];\n\n\t\tif (dc_fixpt_lt(ramp->entries.blue[i], min))\n\t\t\tmin = ramp->entries.blue[i];\n\n\t\tif (dc_fixpt_lt(max, ramp->entries.red[i]))\n\t\t\tmax = ramp->entries.red[i];\n\n\t\tif (dc_fixpt_lt(max, ramp->entries.green[i]))\n\t\t\tmax = ramp->entries.green[i];\n\n\t\tif (dc_fixpt_lt(max, ramp->entries.blue[i]))\n\t\t\tmax = ramp->entries.blue[i];\n\t}\n\n\tif (dc_fixpt_lt(min, dc_fixpt_zero))\n\t\tdelta = dc_fixpt_neg(min);\n\n\toffset = dc_fixpt_add(min, max);\n\n\tfor (i = 0 ; i < ramp->num_entries; i++) {\n\t\tpwl_rgb[i].r = dc_fixpt_div(\n\t\t\tdc_fixpt_add(\n\t\t\t\tramp->entries.red[i], delta), offset);\n\t\tpwl_rgb[i].g = dc_fixpt_div(\n\t\t\tdc_fixpt_add(\n\t\t\t\tramp->entries.green[i], delta), offset);\n\t\tpwl_rgb[i].b = dc_fixpt_div(\n\t\t\tdc_fixpt_add(\n\t\t\t\tramp->entries.blue[i], delta), offset);\n\n\t}\n\n\tpwl_rgb[i].r =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].r, 2), pwl_rgb[i-2].r);\n\tpwl_rgb[i].g =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].g, 2), pwl_rgb[i-2].g);\n\tpwl_rgb[i].b =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].b, 2), pwl_rgb[i-2].b);\n\t++i;\n\tpwl_rgb[i].r =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].r, 2), pwl_rgb[i-2].r);\n\tpwl_rgb[i].g =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].g, 2), pwl_rgb[i-2].g);\n\tpwl_rgb[i].b =  dc_fixpt_sub(dc_fixpt_mul_int(\n\t\t\t\tpwl_rgb[i-1].b, 2), pwl_rgb[i-2].b);\n}\n\n \nstatic void scale_user_regamma_ramp(struct pwl_float_data *pwl_rgb,\n\t\tconst struct regamma_ramp *ramp,\n\t\tstruct dividers dividers)\n{\n\tunsigned short max_driver = 0xFFFF;\n\tunsigned short max_os = 0xFF00;\n\tunsigned short scaler = max_os;\n\tuint32_t i;\n\tstruct pwl_float_data *rgb = pwl_rgb;\n\tstruct pwl_float_data *rgb_last = rgb + GAMMA_RGB_256_ENTRIES - 1;\n\n\ti = 0;\n\tdo {\n\t\tif (ramp->gamma[i] > max_os ||\n\t\t\t\tramp->gamma[i + 256] > max_os ||\n\t\t\t\tramp->gamma[i + 512] > max_os) {\n\t\t\tscaler = max_driver;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t} while (i != GAMMA_RGB_256_ENTRIES);\n\n\ti = 0;\n\tdo {\n\t\trgb->r = dc_fixpt_from_fraction(\n\t\t\t\tramp->gamma[i], scaler);\n\t\trgb->g = dc_fixpt_from_fraction(\n\t\t\t\tramp->gamma[i + 256], scaler);\n\t\trgb->b = dc_fixpt_from_fraction(\n\t\t\t\tramp->gamma[i + 512], scaler);\n\n\t\t++rgb;\n\t\t++i;\n\t} while (i != GAMMA_RGB_256_ENTRIES);\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider1);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider1);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider1);\n\n\t++rgb;\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider2);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider2);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider2);\n\n\t++rgb;\n\n\trgb->r = dc_fixpt_mul(rgb_last->r,\n\t\t\tdividers.divider3);\n\trgb->g = dc_fixpt_mul(rgb_last->g,\n\t\t\tdividers.divider3);\n\trgb->b = dc_fixpt_mul(rgb_last->b,\n\t\t\tdividers.divider3);\n}\n\n \nstatic void apply_lut_1d(\n\t\tconst struct dc_gamma *ramp,\n\t\tuint32_t num_hw_points,\n\t\tstruct dc_transfer_func_distributed_points *tf_pts)\n{\n\tint i = 0;\n\tint color = 0;\n\tstruct fixed31_32 *regamma_y;\n\tstruct fixed31_32 norm_y;\n\tstruct fixed31_32 lut1;\n\tstruct fixed31_32 lut2;\n\tconst int max_lut_index = 4095;\n\tconst struct fixed31_32 penult_lut_index_f =\n\t\t\tdc_fixpt_from_int(max_lut_index-1);\n\tconst struct fixed31_32 max_lut_index_f =\n\t\t\tdc_fixpt_from_int(max_lut_index);\n\tint32_t index = 0, index_next = 0;\n\tstruct fixed31_32 index_f;\n\tstruct fixed31_32 delta_lut;\n\tstruct fixed31_32 delta_index;\n\n\tif (ramp->type != GAMMA_CS_TFM_1D && ramp->type != GAMMA_CUSTOM)\n\t\treturn; \n\n\tfor (i = 0; i < num_hw_points; i++) {\n\t\tfor (color = 0; color < 3; color++) {\n\t\t\tif (color == 0)\n\t\t\t\tregamma_y = &tf_pts->red[i];\n\t\t\telse if (color == 1)\n\t\t\t\tregamma_y = &tf_pts->green[i];\n\t\t\telse\n\t\t\t\tregamma_y = &tf_pts->blue[i];\n\n\t\t\tnorm_y = dc_fixpt_mul(max_lut_index_f,\n\t\t\t\t\t\t   *regamma_y);\n\t\t\tindex = dc_fixpt_floor(norm_y);\n\t\t\tindex_f = dc_fixpt_from_int(index);\n\n\t\t\tif (index < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (index <= max_lut_index)\n\t\t\t\tindex_next = (index == max_lut_index) ? index : index+1;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tindex = max_lut_index - 1;\n\t\t\t\tindex_next = max_lut_index;\n\t\t\t\tindex_f = penult_lut_index_f;\n\t\t\t}\n\n\t\t\tif (color == 0) {\n\t\t\t\tlut1 = ramp->entries.red[index];\n\t\t\t\tlut2 = ramp->entries.red[index_next];\n\t\t\t} else if (color == 1) {\n\t\t\t\tlut1 = ramp->entries.green[index];\n\t\t\t\tlut2 = ramp->entries.green[index_next];\n\t\t\t} else {\n\t\t\t\tlut1 = ramp->entries.blue[index];\n\t\t\t\tlut2 = ramp->entries.blue[index_next];\n\t\t\t}\n\n\t\t\t\n\t\t\tdelta_lut = dc_fixpt_sub(lut2, lut1);\n\t\t\tdelta_index = dc_fixpt_sub(norm_y, index_f);\n\n\t\t\t*regamma_y = dc_fixpt_add(lut1,\n\t\t\t\tdc_fixpt_mul(delta_index, delta_lut));\n\t\t}\n\t}\n}\n\nstatic void build_evenly_distributed_points(\n\tstruct gamma_pixel *points,\n\tuint32_t numberof_points,\n\tstruct dividers dividers)\n{\n\tstruct gamma_pixel *p = points;\n\tstruct gamma_pixel *p_last;\n\n\tuint32_t i = 0;\n\n\t\n\tASSERT(numberof_points > 0);\n\tp_last = p + numberof_points - 1;\n\n\tdo {\n\t\tstruct fixed31_32 value = dc_fixpt_from_fraction(i,\n\t\t\tnumberof_points - 1);\n\n\t\tp->r = value;\n\t\tp->g = value;\n\t\tp->b = value;\n\n\t\t++p;\n\t\t++i;\n\t} while (i < numberof_points);\n\n\tp->r = dc_fixpt_div(p_last->r, dividers.divider1);\n\tp->g = dc_fixpt_div(p_last->g, dividers.divider1);\n\tp->b = dc_fixpt_div(p_last->b, dividers.divider1);\n\n\t++p;\n\n\tp->r = dc_fixpt_div(p_last->r, dividers.divider2);\n\tp->g = dc_fixpt_div(p_last->g, dividers.divider2);\n\tp->b = dc_fixpt_div(p_last->b, dividers.divider2);\n\n\t++p;\n\n\tp->r = dc_fixpt_div(p_last->r, dividers.divider3);\n\tp->g = dc_fixpt_div(p_last->g, dividers.divider3);\n\tp->b = dc_fixpt_div(p_last->b, dividers.divider3);\n}\n\nstatic inline void copy_rgb_regamma_to_coordinates_x(\n\t\tstruct hw_x_point *coordinates_x,\n\t\tuint32_t hw_points_num,\n\t\tconst struct pwl_float_data_ex *rgb_ex)\n{\n\tstruct hw_x_point *coords = coordinates_x;\n\tuint32_t i = 0;\n\tconst struct pwl_float_data_ex *rgb_regamma = rgb_ex;\n\n\twhile (i <= hw_points_num + 1) {\n\t\tcoords->regamma_y_red = rgb_regamma->r;\n\t\tcoords->regamma_y_green = rgb_regamma->g;\n\t\tcoords->regamma_y_blue = rgb_regamma->b;\n\n\t\t++coords;\n\t\t++rgb_regamma;\n\t\t++i;\n\t}\n}\n\nstatic bool calculate_interpolated_hardware_curve(\n\tconst struct dc_gamma *ramp,\n\tstruct pixel_gamma_point *coeff128,\n\tstruct pwl_float_data *rgb_user,\n\tconst struct hw_x_point *coordinates_x,\n\tconst struct gamma_pixel *axis_x,\n\tuint32_t number_of_points,\n\tstruct dc_transfer_func_distributed_points *tf_pts)\n{\n\n\tconst struct pixel_gamma_point *coeff = coeff128;\n\tuint32_t max_entries = 3 - 1;\n\n\tuint32_t i = 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!build_custom_gamma_mapping_coefficients_worker(\n\t\t\t\tramp, coeff128, coordinates_x, axis_x, i,\n\t\t\t\tnumber_of_points))\n\t\t\treturn false;\n\t}\n\n\ti = 0;\n\tmax_entries += ramp->num_entries;\n\n\t \n\n\twhile (i <= number_of_points) {\n\t\ttf_pts->red[i] = calculate_mapped_value(\n\t\t\trgb_user, coeff, CHANNEL_NAME_RED, max_entries);\n\t\ttf_pts->green[i] = calculate_mapped_value(\n\t\t\trgb_user, coeff, CHANNEL_NAME_GREEN, max_entries);\n\t\ttf_pts->blue[i] = calculate_mapped_value(\n\t\t\trgb_user, coeff, CHANNEL_NAME_BLUE, max_entries);\n\n\t\t++coeff;\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\n \nstatic void interpolate_user_regamma(uint32_t hw_points_num,\n\t\tstruct pwl_float_data *rgb_user,\n\t\tbool apply_degamma,\n\t\tstruct dc_transfer_func_distributed_points *tf_pts)\n{\n\tuint32_t i;\n\tuint32_t color = 0;\n\tint32_t index;\n\tint32_t index_next;\n\tstruct fixed31_32 *tf_point;\n\tstruct fixed31_32 hw_x;\n\tstruct fixed31_32 norm_factor =\n\t\t\tdc_fixpt_from_int(255);\n\tstruct fixed31_32 norm_x;\n\tstruct fixed31_32 index_f;\n\tstruct fixed31_32 lut1;\n\tstruct fixed31_32 lut2;\n\tstruct fixed31_32 delta_lut;\n\tstruct fixed31_32 delta_index;\n\tconst struct fixed31_32 one = dc_fixpt_from_int(1);\n\n\ti = 0;\n\t \n\twhile (i != 32) {\n\t\ttf_pts->red[i] = dc_fixpt_zero;\n\t\ttf_pts->green[i] = dc_fixpt_zero;\n\t\ttf_pts->blue[i] = dc_fixpt_zero;\n\t\t++i;\n\t}\n\twhile (i <= hw_points_num + 1) {\n\t\tfor (color = 0; color < 3; color++) {\n\t\t\tif (color == 0)\n\t\t\t\ttf_point = &tf_pts->red[i];\n\t\t\telse if (color == 1)\n\t\t\t\ttf_point = &tf_pts->green[i];\n\t\t\telse\n\t\t\t\ttf_point = &tf_pts->blue[i];\n\n\t\t\tif (apply_degamma) {\n\t\t\t\tif (color == 0)\n\t\t\t\t\thw_x = coordinates_x[i].regamma_y_red;\n\t\t\t\telse if (color == 1)\n\t\t\t\t\thw_x = coordinates_x[i].regamma_y_green;\n\t\t\t\telse\n\t\t\t\t\thw_x = coordinates_x[i].regamma_y_blue;\n\t\t\t} else\n\t\t\t\thw_x = coordinates_x[i].x;\n\n\t\t\tif (dc_fixpt_le(one, hw_x))\n\t\t\t\thw_x = one;\n\n\t\t\tnorm_x = dc_fixpt_mul(norm_factor, hw_x);\n\t\t\tindex = dc_fixpt_floor(norm_x);\n\t\t\tif (index < 0 || index > 255)\n\t\t\t\tcontinue;\n\n\t\t\tindex_f = dc_fixpt_from_int(index);\n\t\t\tindex_next = (index == 255) ? index : index + 1;\n\n\t\t\tif (color == 0) {\n\t\t\t\tlut1 = rgb_user[index].r;\n\t\t\t\tlut2 = rgb_user[index_next].r;\n\t\t\t} else if (color == 1) {\n\t\t\t\tlut1 = rgb_user[index].g;\n\t\t\t\tlut2 = rgb_user[index_next].g;\n\t\t\t} else {\n\t\t\t\tlut1 = rgb_user[index].b;\n\t\t\t\tlut2 = rgb_user[index_next].b;\n\t\t\t}\n\n\t\t\t\n\t\t\tdelta_lut = dc_fixpt_sub(lut2, lut1);\n\t\t\tdelta_index = dc_fixpt_sub(norm_x, index_f);\n\n\t\t\t*tf_point = dc_fixpt_add(lut1,\n\t\t\t\tdc_fixpt_mul(delta_index, delta_lut));\n\t\t}\n\t\t++i;\n\t}\n}\n\nstatic void build_new_custom_resulted_curve(\n\tuint32_t hw_points_num,\n\tstruct dc_transfer_func_distributed_points *tf_pts)\n{\n\tuint32_t i = 0;\n\n\twhile (i != hw_points_num + 1) {\n\t\ttf_pts->red[i] = dc_fixpt_clamp(\n\t\t\ttf_pts->red[i], dc_fixpt_zero,\n\t\t\tdc_fixpt_one);\n\t\ttf_pts->green[i] = dc_fixpt_clamp(\n\t\t\ttf_pts->green[i], dc_fixpt_zero,\n\t\t\tdc_fixpt_one);\n\t\ttf_pts->blue[i] = dc_fixpt_clamp(\n\t\t\ttf_pts->blue[i], dc_fixpt_zero,\n\t\t\tdc_fixpt_one);\n\n\t\t++i;\n\t}\n}\n\nstatic void apply_degamma_for_user_regamma(struct pwl_float_data_ex *rgb_regamma,\n\t\tuint32_t hw_points_num, struct calculate_buffer *cal_buffer)\n{\n\tuint32_t i;\n\n\tstruct gamma_coefficients coeff;\n\tstruct pwl_float_data_ex *rgb = rgb_regamma;\n\tconst struct hw_x_point *coord_x = coordinates_x;\n\n\tbuild_coefficients(&coeff, TRANSFER_FUNCTION_SRGB);\n\n\ti = 0;\n\twhile (i != hw_points_num + 1) {\n\t\trgb->r = translate_from_linear_space_ex(\n\t\t\t\tcoord_x->x, &coeff, 0, cal_buffer);\n\t\trgb->g = rgb->r;\n\t\trgb->b = rgb->r;\n\t\t++coord_x;\n\t\t++rgb;\n\t\t++i;\n\t}\n}\n\nstatic bool map_regamma_hw_to_x_user(\n\tconst struct dc_gamma *ramp,\n\tstruct pixel_gamma_point *coeff128,\n\tstruct pwl_float_data *rgb_user,\n\tstruct hw_x_point *coords_x,\n\tconst struct gamma_pixel *axis_x,\n\tconst struct pwl_float_data_ex *rgb_regamma,\n\tuint32_t hw_points_num,\n\tstruct dc_transfer_func_distributed_points *tf_pts,\n\tbool map_user_ramp,\n\tbool do_clamping)\n{\n\t \n\n\tint i = 0;\n\tstruct hw_x_point *coords = coords_x;\n\tconst struct pwl_float_data_ex *regamma = rgb_regamma;\n\n\tif (ramp && map_user_ramp) {\n\t\tcopy_rgb_regamma_to_coordinates_x(coords,\n\t\t\t\thw_points_num,\n\t\t\t\trgb_regamma);\n\n\t\tcalculate_interpolated_hardware_curve(\n\t\t\tramp, coeff128, rgb_user, coords, axis_x,\n\t\t\thw_points_num, tf_pts);\n\t} else {\n\t\t \n\t\twhile (i <= hw_points_num) {\n\t\t\ttf_pts->red[i] = regamma->r;\n\t\t\ttf_pts->green[i] = regamma->g;\n\t\t\ttf_pts->blue[i] = regamma->b;\n\n\t\t\t++regamma;\n\t\t\t++i;\n\t\t}\n\t}\n\n\tif (do_clamping) {\n\t\t \n\t\tbuild_new_custom_resulted_curve(hw_points_num, tf_pts);\n\t}\n\n\treturn true;\n}\n\n#define _EXTRA_POINTS 3\n\nbool calculate_user_regamma_coeff(struct dc_transfer_func *output_tf,\n\t\tconst struct regamma_lut *regamma,\n\t\tstruct calculate_buffer *cal_buffer,\n\t\tconst struct dc_gamma *ramp)\n{\n\tstruct gamma_coefficients coeff;\n\tconst struct hw_x_point *coord_x = coordinates_x;\n\tuint32_t i = 0;\n\n\tdo {\n\t\tcoeff.a0[i] = dc_fixpt_from_fraction(\n\t\t\t\tregamma->coeff.A0[i], 10000000);\n\t\tcoeff.a1[i] = dc_fixpt_from_fraction(\n\t\t\t\tregamma->coeff.A1[i], 1000);\n\t\tcoeff.a2[i] = dc_fixpt_from_fraction(\n\t\t\t\tregamma->coeff.A2[i], 1000);\n\t\tcoeff.a3[i] = dc_fixpt_from_fraction(\n\t\t\t\tregamma->coeff.A3[i], 1000);\n\t\tcoeff.user_gamma[i] = dc_fixpt_from_fraction(\n\t\t\t\tregamma->coeff.gamma[i], 1000);\n\n\t\t++i;\n\t} while (i != 3);\n\n\ti = 0;\n\t \n\twhile (i != 32) {\n\t\toutput_tf->tf_pts.red[i] = dc_fixpt_zero;\n\t\toutput_tf->tf_pts.green[i] = dc_fixpt_zero;\n\t\toutput_tf->tf_pts.blue[i] = dc_fixpt_zero;\n\t\t++coord_x;\n\t\t++i;\n\t}\n\twhile (i != MAX_HW_POINTS + 1) {\n\t\toutput_tf->tf_pts.red[i] = translate_from_linear_space_ex(\n\t\t\t\tcoord_x->x, &coeff, 0, cal_buffer);\n\t\toutput_tf->tf_pts.green[i] = translate_from_linear_space_ex(\n\t\t\t\tcoord_x->x, &coeff, 1, cal_buffer);\n\t\toutput_tf->tf_pts.blue[i] = translate_from_linear_space_ex(\n\t\t\t\tcoord_x->x, &coeff, 2, cal_buffer);\n\t\t++coord_x;\n\t\t++i;\n\t}\n\n\tif (ramp && ramp->type == GAMMA_CS_TFM_1D)\n\t\tapply_lut_1d(ramp, MAX_HW_POINTS, &output_tf->tf_pts);\n\n\t\n\tbuild_new_custom_resulted_curve(MAX_HW_POINTS, &output_tf->tf_pts);\n\toutput_tf->type = TF_TYPE_DISTRIBUTED_POINTS;\n\n\treturn true;\n}\n\nbool calculate_user_regamma_ramp(struct dc_transfer_func *output_tf,\n\t\tconst struct regamma_lut *regamma,\n\t\tstruct calculate_buffer *cal_buffer,\n\t\tconst struct dc_gamma *ramp)\n{\n\tstruct dc_transfer_func_distributed_points *tf_pts = &output_tf->tf_pts;\n\tstruct dividers dividers;\n\n\tstruct pwl_float_data *rgb_user = NULL;\n\tstruct pwl_float_data_ex *rgb_regamma = NULL;\n\tbool ret = false;\n\n\tif (regamma == NULL)\n\t\treturn false;\n\n\toutput_tf->type = TF_TYPE_DISTRIBUTED_POINTS;\n\n\trgb_user = kcalloc(GAMMA_RGB_256_ENTRIES + _EXTRA_POINTS,\n\t\t\t   sizeof(*rgb_user),\n\t\t\t   GFP_KERNEL);\n\tif (!rgb_user)\n\t\tgoto rgb_user_alloc_fail;\n\n\trgb_regamma = kcalloc(MAX_HW_POINTS + _EXTRA_POINTS,\n\t\t\t      sizeof(*rgb_regamma),\n\t\t\t      GFP_KERNEL);\n\tif (!rgb_regamma)\n\t\tgoto rgb_regamma_alloc_fail;\n\n\tdividers.divider1 = dc_fixpt_from_fraction(3, 2);\n\tdividers.divider2 = dc_fixpt_from_int(2);\n\tdividers.divider3 = dc_fixpt_from_fraction(5, 2);\n\n\tscale_user_regamma_ramp(rgb_user, &regamma->ramp, dividers);\n\n\tif (regamma->flags.bits.applyDegamma == 1) {\n\t\tapply_degamma_for_user_regamma(rgb_regamma, MAX_HW_POINTS, cal_buffer);\n\t\tcopy_rgb_regamma_to_coordinates_x(coordinates_x,\n\t\t\t\tMAX_HW_POINTS, rgb_regamma);\n\t}\n\n\tinterpolate_user_regamma(MAX_HW_POINTS, rgb_user,\n\t\t\tregamma->flags.bits.applyDegamma, tf_pts);\n\n\t\n\ttf_pts->end_exponent = 0;\n\ttf_pts->x_point_at_y1_red = 1;\n\ttf_pts->x_point_at_y1_green = 1;\n\ttf_pts->x_point_at_y1_blue = 1;\n\n\tif (ramp && ramp->type == GAMMA_CS_TFM_1D)\n\t\tapply_lut_1d(ramp, MAX_HW_POINTS, &output_tf->tf_pts);\n\n\t\n\tbuild_new_custom_resulted_curve(MAX_HW_POINTS, tf_pts);\n\n\tret = true;\n\n\tkfree(rgb_regamma);\nrgb_regamma_alloc_fail:\n\tkfree(rgb_user);\nrgb_user_alloc_fail:\n\treturn ret;\n}\n\nbool mod_color_calculate_degamma_params(struct dc_color_caps *dc_caps,\n\t\tstruct dc_transfer_func *input_tf,\n\t\tconst struct dc_gamma *ramp, bool map_user_ramp)\n{\n\tstruct dc_transfer_func_distributed_points *tf_pts = &input_tf->tf_pts;\n\tstruct dividers dividers;\n\tstruct pwl_float_data *rgb_user = NULL;\n\tstruct pwl_float_data_ex *curve = NULL;\n\tstruct gamma_pixel *axis_x = NULL;\n\tstruct pixel_gamma_point *coeff = NULL;\n\tenum dc_transfer_func_predefined tf;\n\tuint32_t i;\n\tbool ret = false;\n\n\tif (input_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\t \n\tif (input_tf->type == TF_TYPE_PREDEFINED) {\n\t\tif ((input_tf->tf == TRANSFER_FUNCTION_SRGB ||\n\t\t\t\tinput_tf->tf == TRANSFER_FUNCTION_LINEAR) &&\n\t\t\t\t!map_user_ramp)\n\t\t\treturn true;\n\n\t\tif (dc_caps != NULL &&\n\t\t\tdc_caps->dpp.dcn_arch == 1) {\n\n\t\t\tif (input_tf->tf == TRANSFER_FUNCTION_PQ &&\n\t\t\t\t\tdc_caps->dpp.dgam_rom_caps.pq == 1)\n\t\t\t\treturn true;\n\n\t\t\tif (input_tf->tf == TRANSFER_FUNCTION_GAMMA22 &&\n\t\t\t\t\tdc_caps->dpp.dgam_rom_caps.gamma2_2 == 1)\n\t\t\t\treturn true;\n\n\t\t\t\n\t\t\tif (input_tf->tf == TRANSFER_FUNCTION_HLG &&\n\t\t\t\t\tdc_caps->dpp.dgam_rom_caps.hlg == 1)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tinput_tf->type = TF_TYPE_DISTRIBUTED_POINTS;\n\n\tif (map_user_ramp && ramp && ramp->type == GAMMA_RGB_256) {\n\t\trgb_user = kvcalloc(ramp->num_entries + _EXTRA_POINTS,\n\t\t\t\tsizeof(*rgb_user),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!rgb_user)\n\t\t\tgoto rgb_user_alloc_fail;\n\n\t\taxis_x = kvcalloc(ramp->num_entries + _EXTRA_POINTS, sizeof(*axis_x),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!axis_x)\n\t\t\tgoto axis_x_alloc_fail;\n\n\t\tdividers.divider1 = dc_fixpt_from_fraction(3, 2);\n\t\tdividers.divider2 = dc_fixpt_from_int(2);\n\t\tdividers.divider3 = dc_fixpt_from_fraction(5, 2);\n\n\t\tbuild_evenly_distributed_points(\n\t\t\t\taxis_x,\n\t\t\t\tramp->num_entries,\n\t\t\t\tdividers);\n\n\t\tscale_gamma(rgb_user, ramp, dividers);\n\t}\n\n\tcurve = kvcalloc(MAX_HW_POINTS + _EXTRA_POINTS, sizeof(*curve),\n\t\t\tGFP_KERNEL);\n\tif (!curve)\n\t\tgoto curve_alloc_fail;\n\n\tcoeff = kvcalloc(MAX_HW_POINTS + _EXTRA_POINTS, sizeof(*coeff),\n\t\t\tGFP_KERNEL);\n\tif (!coeff)\n\t\tgoto coeff_alloc_fail;\n\n\ttf = input_tf->tf;\n\n\tif (tf == TRANSFER_FUNCTION_PQ)\n\t\tbuild_de_pq(curve,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x);\n\telse if (tf == TRANSFER_FUNCTION_SRGB ||\n\t\ttf == TRANSFER_FUNCTION_BT709 ||\n\t\ttf == TRANSFER_FUNCTION_GAMMA22 ||\n\t\ttf == TRANSFER_FUNCTION_GAMMA24 ||\n\t\ttf == TRANSFER_FUNCTION_GAMMA26)\n\t\tbuild_degamma(curve,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\ttf);\n\telse if (tf == TRANSFER_FUNCTION_HLG)\n\t\tbuild_hlg_degamma(curve,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\t80, 1000);\n\telse if (tf == TRANSFER_FUNCTION_LINEAR) {\n\t\t\n\t\ti = 0;\n\t\twhile (i != MAX_HW_POINTS + 1) {\n\t\t\tcurve[i].r = coordinates_x[i].x;\n\t\t\tcurve[i].g = curve[i].r;\n\t\t\tcurve[i].b = curve[i].r;\n\t\t\ti++;\n\t\t}\n\t} else\n\t\tgoto invalid_tf_fail;\n\n\ttf_pts->end_exponent = 0;\n\ttf_pts->x_point_at_y1_red = 1;\n\ttf_pts->x_point_at_y1_green = 1;\n\ttf_pts->x_point_at_y1_blue = 1;\n\n\tif (input_tf->tf == TRANSFER_FUNCTION_PQ) {\n\t\t \n\t\tstruct pwl_float_data_ex *curvePt = curve;\n\t\tint i = 0;\n\n\t\twhile (i <= MAX_HW_POINTS) {\n\t\t\ttf_pts->red[i]   = curvePt->r;\n\t\t\ttf_pts->green[i] = curvePt->g;\n\t\t\ttf_pts->blue[i]  = curvePt->b;\n\t\t\t++curvePt;\n\t\t\t++i;\n\t\t}\n\t} else {\n\t\t\n\t\tmap_regamma_hw_to_x_user(ramp, coeff, rgb_user,\n\t\t\t\tcoordinates_x, axis_x, curve,\n\t\t\t\tMAX_HW_POINTS, tf_pts,\n\t\t\t\tmap_user_ramp && ramp && ramp->type == GAMMA_RGB_256,\n\t\t\t\ttrue);\n\t}\n\n\n\n\tif (ramp && ramp->type == GAMMA_CUSTOM)\n\t\tapply_lut_1d(ramp, MAX_HW_POINTS, tf_pts);\n\n\tret = true;\n\ninvalid_tf_fail:\n\tkvfree(coeff);\ncoeff_alloc_fail:\n\tkvfree(curve);\ncurve_alloc_fail:\n\tkvfree(axis_x);\naxis_x_alloc_fail:\n\tkvfree(rgb_user);\nrgb_user_alloc_fail:\n\n\treturn ret;\n}\n\nstatic bool calculate_curve(enum dc_transfer_func_predefined trans,\n\t\t\t\tstruct dc_transfer_func_distributed_points *points,\n\t\t\t\tstruct pwl_float_data_ex *rgb_regamma,\n\t\t\t\tconst struct hdr_tm_params *fs_params,\n\t\t\t\tuint32_t sdr_ref_white_level,\n\t\t\t\tstruct calculate_buffer *cal_buffer)\n{\n\tuint32_t i;\n\tbool ret = false;\n\n\tif (trans == TRANSFER_FUNCTION_UNITY ||\n\t\ttrans == TRANSFER_FUNCTION_LINEAR) {\n\t\tpoints->end_exponent = 0;\n\t\tpoints->x_point_at_y1_red = 1;\n\t\tpoints->x_point_at_y1_green = 1;\n\t\tpoints->x_point_at_y1_blue = 1;\n\n\t\tfor (i = 0; i <= MAX_HW_POINTS ; i++) {\n\t\t\trgb_regamma[i].r = coordinates_x[i].x;\n\t\t\trgb_regamma[i].g = coordinates_x[i].x;\n\t\t\trgb_regamma[i].b = coordinates_x[i].x;\n\t\t}\n\n\t\tret = true;\n\t} else if (trans == TRANSFER_FUNCTION_PQ) {\n\t\tpoints->end_exponent = 7;\n\t\tpoints->x_point_at_y1_red = 125;\n\t\tpoints->x_point_at_y1_green = 125;\n\t\tpoints->x_point_at_y1_blue = 125;\n\n\t\tbuild_pq(rgb_regamma,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\tsdr_ref_white_level);\n\n\t\tret = true;\n\t} else if (trans == TRANSFER_FUNCTION_GAMMA22 &&\n\t\t\tfs_params != NULL && fs_params->skip_tm == 0) {\n\t\tbuild_freesync_hdr(rgb_regamma,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\tfs_params,\n\t\t\t\tcal_buffer);\n\n\t\tret = true;\n\t} else if (trans == TRANSFER_FUNCTION_HLG) {\n\t\tpoints->end_exponent = 4;\n\t\tpoints->x_point_at_y1_red = 12;\n\t\tpoints->x_point_at_y1_green = 12;\n\t\tpoints->x_point_at_y1_blue = 12;\n\n\t\tbuild_hlg_regamma(rgb_regamma,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\t80, 1000);\n\n\t\tret = true;\n\t} else {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpoints->end_exponent = 0;\n\t\tpoints->x_point_at_y1_red = 1;\n\t\tpoints->x_point_at_y1_green = 1;\n\t\tpoints->x_point_at_y1_blue = 1;\n\n\t\tbuild_regamma(rgb_regamma,\n\t\t\t\tMAX_HW_POINTS,\n\t\t\t\tcoordinates_x,\n\t\t\t\ttrans,\n\t\t\t\tcal_buffer);\n\n\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\nbool mod_color_calculate_regamma_params(struct dc_transfer_func *output_tf,\n\t\t\t\t\tconst struct dc_gamma *ramp,\n\t\t\t\t\tbool map_user_ramp,\n\t\t\t\t\tbool can_rom_be_used,\n\t\t\t\t\tconst struct hdr_tm_params *fs_params,\n\t\t\t\t\tstruct calculate_buffer *cal_buffer)\n{\n\tstruct dc_transfer_func_distributed_points *tf_pts = &output_tf->tf_pts;\n\tstruct dividers dividers;\n\n\tstruct pwl_float_data *rgb_user = NULL;\n\tstruct pwl_float_data_ex *rgb_regamma = NULL;\n\tstruct gamma_pixel *axis_x = NULL;\n\tstruct pixel_gamma_point *coeff = NULL;\n\tenum dc_transfer_func_predefined tf;\n\tbool do_clamping = true;\n\tbool ret = false;\n\n\tif (output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\t \n\tif (output_tf->type == TF_TYPE_PREDEFINED && can_rom_be_used == true &&\n\t\t\toutput_tf->tf == TRANSFER_FUNCTION_SRGB) {\n\t\tif (ramp == NULL)\n\t\t\treturn true;\n\t\tif ((ramp->is_identity && ramp->type != GAMMA_CS_TFM_1D) ||\n\t\t    (!map_user_ramp && ramp->type == GAMMA_RGB_256))\n\t\t\treturn true;\n\t}\n\n\toutput_tf->type = TF_TYPE_DISTRIBUTED_POINTS;\n\n\tif (ramp && ramp->type != GAMMA_CS_TFM_1D &&\n\t    (map_user_ramp || ramp->type != GAMMA_RGB_256)) {\n\t\trgb_user = kvcalloc(ramp->num_entries + _EXTRA_POINTS,\n\t\t\t    sizeof(*rgb_user),\n\t\t\t    GFP_KERNEL);\n\t\tif (!rgb_user)\n\t\t\tgoto rgb_user_alloc_fail;\n\n\t\taxis_x = kvcalloc(ramp->num_entries + 3, sizeof(*axis_x),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!axis_x)\n\t\t\tgoto axis_x_alloc_fail;\n\n\t\tdividers.divider1 = dc_fixpt_from_fraction(3, 2);\n\t\tdividers.divider2 = dc_fixpt_from_int(2);\n\t\tdividers.divider3 = dc_fixpt_from_fraction(5, 2);\n\n\t\tbuild_evenly_distributed_points(\n\t\t\t\taxis_x,\n\t\t\t\tramp->num_entries,\n\t\t\t\tdividers);\n\n\t\tif (ramp->type == GAMMA_RGB_256 && map_user_ramp)\n\t\t\tscale_gamma(rgb_user, ramp, dividers);\n\t\telse if (ramp->type == GAMMA_RGB_FLOAT_1024)\n\t\t\tscale_gamma_dx(rgb_user, ramp, dividers);\n\t}\n\n\trgb_regamma = kvcalloc(MAX_HW_POINTS + _EXTRA_POINTS,\n\t\t\t       sizeof(*rgb_regamma),\n\t\t\t       GFP_KERNEL);\n\tif (!rgb_regamma)\n\t\tgoto rgb_regamma_alloc_fail;\n\n\tcoeff = kvcalloc(MAX_HW_POINTS + _EXTRA_POINTS, sizeof(*coeff),\n\t\t\t GFP_KERNEL);\n\tif (!coeff)\n\t\tgoto coeff_alloc_fail;\n\n\ttf = output_tf->tf;\n\n\tret = calculate_curve(tf,\n\t\t\ttf_pts,\n\t\t\trgb_regamma,\n\t\t\tfs_params,\n\t\t\toutput_tf->sdr_ref_white_level,\n\t\t\tcal_buffer);\n\n\tif (ret) {\n\t\tdo_clamping = !(output_tf->tf == TRANSFER_FUNCTION_GAMMA22 &&\n\t\t\t\tfs_params != NULL && fs_params->skip_tm == 0);\n\n\t\tmap_regamma_hw_to_x_user(ramp, coeff, rgb_user,\n\t\t\t\t\t coordinates_x, axis_x, rgb_regamma,\n\t\t\t\t\t MAX_HW_POINTS, tf_pts,\n\t\t\t\t\t (map_user_ramp || (ramp && ramp->type != GAMMA_RGB_256)) &&\n\t\t\t\t\t (ramp && ramp->type != GAMMA_CS_TFM_1D),\n\t\t\t\t\t do_clamping);\n\n\t\tif (ramp && ramp->type == GAMMA_CS_TFM_1D)\n\t\t\tapply_lut_1d(ramp, MAX_HW_POINTS, tf_pts);\n\t}\n\n\tkvfree(coeff);\ncoeff_alloc_fail:\n\tkvfree(rgb_regamma);\nrgb_regamma_alloc_fail:\n\tkvfree(axis_x);\naxis_x_alloc_fail:\n\tkvfree(rgb_user);\nrgb_user_alloc_fail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}