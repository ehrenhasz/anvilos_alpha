{
  "module_name": "hdcp.h",
  "hash_id": "cf644f487317d50b7890bfb231363941fd2869eb0bc6823146f7884232938602",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.h",
  "human_readable_source": " \n\n#ifndef HDCP_H_\n#define HDCP_H_\n\n#include \"mod_hdcp.h\"\n#include \"hdcp_log.h\"\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_hdcp_helper.h>\n\nenum mod_hdcp_trans_input_result {\n\tUNKNOWN = 0,\n\tPASS,\n\tFAIL\n};\n\nstruct mod_hdcp_transition_input_hdcp1 {\n\tuint8_t bksv_read;\n\tuint8_t bksv_validation;\n\tuint8_t create_session;\n\tuint8_t an_write;\n\tuint8_t aksv_write;\n\tuint8_t ainfo_write;\n\tuint8_t bcaps_read;\n\tuint8_t r0p_read;\n\tuint8_t rx_validation;\n\tuint8_t encryption;\n\tuint8_t link_maintenance;\n\tuint8_t ready_check;\n\tuint8_t bstatus_read;\n\tuint8_t max_cascade_check;\n\tuint8_t max_devs_check;\n\tuint8_t device_count_check;\n\tuint8_t ksvlist_read;\n\tuint8_t vp_read;\n\tuint8_t ksvlist_vp_validation;\n\n\tuint8_t hdcp_capable_dp;\n\tuint8_t binfo_read_dp;\n\tuint8_t r0p_available_dp;\n\tuint8_t link_integrity_check;\n\tuint8_t reauth_request_check;\n\tuint8_t stream_encryption_dp;\n};\n\nstruct mod_hdcp_transition_input_hdcp2 {\n\tuint8_t hdcp2version_read;\n\tuint8_t hdcp2_capable_check;\n\tuint8_t create_session;\n\tuint8_t ake_init_prepare;\n\tuint8_t ake_init_write;\n\tuint8_t rxstatus_read;\n\tuint8_t ake_cert_available;\n\tuint8_t ake_cert_read;\n\tuint8_t ake_cert_validation;\n\tuint8_t stored_km_write;\n\tuint8_t no_stored_km_write;\n\tuint8_t h_prime_available;\n\tuint8_t h_prime_read;\n\tuint8_t pairing_available;\n\tuint8_t pairing_info_read;\n\tuint8_t h_prime_validation;\n\tuint8_t lc_init_prepare;\n\tuint8_t lc_init_write;\n\tuint8_t l_prime_available_poll;\n\tuint8_t l_prime_read;\n\tuint8_t l_prime_validation;\n\tuint8_t eks_prepare;\n\tuint8_t eks_write;\n\tuint8_t enable_encryption;\n\tuint8_t reauth_request_check;\n\tuint8_t rx_id_list_read;\n\tuint8_t device_count_check;\n\tuint8_t rx_id_list_validation;\n\tuint8_t repeater_auth_ack_write;\n\tuint8_t prepare_stream_manage;\n\tuint8_t stream_manage_write;\n\tuint8_t stream_ready_available;\n\tuint8_t stream_ready_read;\n\tuint8_t stream_ready_validation;\n\n\tuint8_t rx_caps_read_dp;\n\tuint8_t content_stream_type_write;\n\tuint8_t link_integrity_check_dp;\n\tuint8_t stream_encryption_dp;\n};\n\nunion mod_hdcp_transition_input {\n\tstruct mod_hdcp_transition_input_hdcp1 hdcp1;\n\tstruct mod_hdcp_transition_input_hdcp2 hdcp2;\n};\n\nstruct mod_hdcp_message_hdcp1 {\n\tuint8_t\t\tan[8];\n\tuint8_t\t\taksv[5];\n\tuint8_t\t\tainfo;\n\tuint8_t\t\tbksv[5];\n\tuint16_t\tr0p;\n\tuint8_t\t\tbcaps;\n\tuint16_t\tbstatus;\n\tuint8_t\t\tksvlist[635];\n\tuint16_t\tksvlist_size;\n\tuint8_t\t\tvp[20];\n\n\tuint16_t\tbinfo_dp;\n};\n\nstruct mod_hdcp_message_hdcp2 {\n\tuint8_t\t\thdcp2version_hdmi;\n\tuint8_t\t\trxcaps_dp[3];\n\tuint8_t\t\trxstatus[2];\n\n\tuint8_t\t\take_init[12];\n\tuint8_t\t\take_cert[534];\n\tuint8_t\t\take_no_stored_km[129];\n\tuint8_t\t\take_stored_km[33];\n\tuint8_t\t\take_h_prime[33];\n\tuint8_t\t\take_pairing_info[17];\n\tuint8_t\t\tlc_init[9];\n\tuint8_t\t\tlc_l_prime[33];\n\tuint8_t\t\tske_eks[25];\n\tuint8_t\t\trx_id_list[177]; \n\tuint16_t\trx_id_list_size;\n\tuint8_t\t\trepeater_auth_ack[17];\n\tuint8_t\t\trepeater_auth_stream_manage[68]; \n\tuint16_t\tstream_manage_size;\n\tuint8_t\t\trepeater_auth_stream_ready[33];\n\tuint8_t\t\trxstatus_dp;\n\tuint8_t\t\tcontent_stream_type_dp[2];\n};\n\nunion mod_hdcp_message {\n\tstruct mod_hdcp_message_hdcp1 hdcp1;\n\tstruct mod_hdcp_message_hdcp2 hdcp2;\n};\n\nstruct mod_hdcp_auth_counters {\n\tuint8_t stream_management_retry_count;\n};\n\n \nstruct mod_hdcp_connection {\n\tstruct mod_hdcp_link link;\n\tuint8_t is_repeater;\n\tuint8_t is_km_stored;\n\tuint8_t is_hdcp1_revoked;\n\tuint8_t is_hdcp2_revoked;\n\tstruct mod_hdcp_trace trace;\n\tuint8_t hdcp1_retry_count;\n\tuint8_t hdcp2_retry_count;\n};\n\n \nstruct mod_hdcp_authentication {\n\tuint32_t id;\n\tunion mod_hdcp_message msg;\n\tunion mod_hdcp_transition_input trans_input;\n\tstruct mod_hdcp_auth_counters count;\n};\n\n \nstruct mod_hdcp_state {\n\tuint8_t id;\n\tuint32_t stay_count;\n};\n\n \nstruct mod_hdcp_event_context {\n\tenum mod_hdcp_event event;\n\tuint8_t rx_id_list_ready;\n\tuint8_t unexpected_event;\n};\n\nstruct mod_hdcp {\n\t \n\tstruct mod_hdcp_config config;\n\t \n\tstruct mod_hdcp_connection connection;\n\t \n\tstruct mod_hdcp_display displays[MAX_NUM_OF_DISPLAYS];\n\t \n\tstruct mod_hdcp_authentication auth;\n\t \n\tstruct mod_hdcp_state state;\n\t \n\tuint8_t buf[2025];\n};\n\nenum mod_hdcp_initial_state_id {\n\tHDCP_UNINITIALIZED = 0x0,\n\tHDCP_INITIAL_STATE_START = HDCP_UNINITIALIZED,\n\tHDCP_INITIALIZED,\n\tHDCP_CP_NOT_DESIRED,\n\tHDCP_INITIAL_STATE_END = HDCP_CP_NOT_DESIRED\n};\n\nenum mod_hdcp_hdcp1_state_id {\n\tHDCP1_STATE_START = HDCP_INITIAL_STATE_END,\n\tH1_A0_WAIT_FOR_ACTIVE_RX,\n\tH1_A1_EXCHANGE_KSVS,\n\tH1_A2_COMPUTATIONS_A3_VALIDATE_RX_A6_TEST_FOR_REPEATER,\n\tH1_A45_AUTHENTICATED,\n\tH1_A8_WAIT_FOR_READY,\n\tH1_A9_READ_KSV_LIST,\n\tHDCP1_STATE_END = H1_A9_READ_KSV_LIST\n};\n\nenum mod_hdcp_hdcp1_dp_state_id {\n\tHDCP1_DP_STATE_START = HDCP1_STATE_END,\n\tD1_A0_DETERMINE_RX_HDCP_CAPABLE,\n\tD1_A1_EXCHANGE_KSVS,\n\tD1_A23_WAIT_FOR_R0_PRIME,\n\tD1_A2_COMPUTATIONS_A3_VALIDATE_RX_A5_TEST_FOR_REPEATER,\n\tD1_A4_AUTHENTICATED,\n\tD1_A6_WAIT_FOR_READY,\n\tD1_A7_READ_KSV_LIST,\n\tHDCP1_DP_STATE_END = D1_A7_READ_KSV_LIST,\n};\n\nenum mod_hdcp_hdcp2_state_id {\n\tHDCP2_STATE_START = HDCP1_DP_STATE_END,\n\tH2_A0_KNOWN_HDCP2_CAPABLE_RX,\n\tH2_A1_SEND_AKE_INIT,\n\tH2_A1_VALIDATE_AKE_CERT,\n\tH2_A1_SEND_NO_STORED_KM,\n\tH2_A1_READ_H_PRIME,\n\tH2_A1_READ_PAIRING_INFO_AND_VALIDATE_H_PRIME,\n\tH2_A1_SEND_STORED_KM,\n\tH2_A1_VALIDATE_H_PRIME,\n\tH2_A2_LOCALITY_CHECK,\n\tH2_A3_EXCHANGE_KS_AND_TEST_FOR_REPEATER,\n\tH2_ENABLE_ENCRYPTION,\n\tH2_A5_AUTHENTICATED,\n\tH2_A6_WAIT_FOR_RX_ID_LIST,\n\tH2_A78_VERIFY_RX_ID_LIST_AND_SEND_ACK,\n\tH2_A9_SEND_STREAM_MANAGEMENT,\n\tH2_A9_VALIDATE_STREAM_READY,\n\tHDCP2_STATE_END = H2_A9_VALIDATE_STREAM_READY,\n};\n\nenum mod_hdcp_hdcp2_dp_state_id {\n\tHDCP2_DP_STATE_START = HDCP2_STATE_END,\n\tD2_A0_DETERMINE_RX_HDCP_CAPABLE,\n\tD2_A1_SEND_AKE_INIT,\n\tD2_A1_VALIDATE_AKE_CERT,\n\tD2_A1_SEND_NO_STORED_KM,\n\tD2_A1_READ_H_PRIME,\n\tD2_A1_READ_PAIRING_INFO_AND_VALIDATE_H_PRIME,\n\tD2_A1_SEND_STORED_KM,\n\tD2_A1_VALIDATE_H_PRIME,\n\tD2_A2_LOCALITY_CHECK,\n\tD2_A34_EXCHANGE_KS_AND_TEST_FOR_REPEATER,\n\tD2_SEND_CONTENT_STREAM_TYPE,\n\tD2_ENABLE_ENCRYPTION,\n\tD2_A5_AUTHENTICATED,\n\tD2_A6_WAIT_FOR_RX_ID_LIST,\n\tD2_A78_VERIFY_RX_ID_LIST_AND_SEND_ACK,\n\tD2_A9_SEND_STREAM_MANAGEMENT,\n\tD2_A9_VALIDATE_STREAM_READY,\n\tHDCP2_DP_STATE_END = D2_A9_VALIDATE_STREAM_READY,\n\tHDCP_STATE_END = HDCP2_DP_STATE_END,\n};\n\n \ntypedef enum mod_hdcp_status (*mod_hdcp_action)(struct mod_hdcp *hdcp);\nuint8_t mod_hdcp_execute_and_set(\n\t\tmod_hdcp_action func, uint8_t *flag,\n\t\tenum mod_hdcp_status *status, struct mod_hdcp *hdcp, char *str);\nenum mod_hdcp_status mod_hdcp_hdcp1_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp1 *input);\nenum mod_hdcp_status mod_hdcp_hdcp1_dp_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp1 *input);\nenum mod_hdcp_status mod_hdcp_hdcp1_transition(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp1 *input,\n\tstruct mod_hdcp_output *output);\nenum mod_hdcp_status mod_hdcp_hdcp1_dp_transition(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp1 *input,\n\tstruct mod_hdcp_output *output);\n\n \nenum mod_hdcp_status mod_hdcp_hdcp2_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input);\nenum mod_hdcp_status mod_hdcp_hdcp2_dp_execution(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input);\nenum mod_hdcp_status mod_hdcp_hdcp2_transition(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input,\n\tstruct mod_hdcp_output *output);\nenum mod_hdcp_status mod_hdcp_hdcp2_dp_transition(struct mod_hdcp *hdcp,\n\tstruct mod_hdcp_event_context *event_ctx,\n\tstruct mod_hdcp_transition_input_hdcp2 *input,\n\tstruct mod_hdcp_output *output);\n\n \nvoid mod_hdcp_dump_binary_message(uint8_t *msg, uint32_t msg_size,\n\t\tuint8_t *buf, uint32_t buf_size);\nvoid mod_hdcp_log_ddc_trace(struct mod_hdcp *hdcp);\n \n\n \nenum mod_hdcp_status mod_hdcp_add_display_to_topology(\n\t\tstruct mod_hdcp *hdcp, struct mod_hdcp_display *display);\nenum mod_hdcp_status mod_hdcp_remove_display_from_topology(\n\t\tstruct mod_hdcp *hdcp, uint8_t index);\nenum mod_hdcp_status mod_hdcp_hdcp1_create_session(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_destroy_session(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_validate_rx(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_enable_encryption(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_validate_ksvlist_vp(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_enable_dp_stream_encryption(\n\tstruct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp1_link_maintenance(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_create_session(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_destroy_session(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_ake_init(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_ake_cert(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_h_prime(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_lc_init(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_l_prime(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_eks(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_enable_encryption(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_rx_id_list(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_enable_dp_stream_encryption(\n\t\tstruct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_stream_management(\n\t\tstruct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_stream_ready(\n\t\tstruct mod_hdcp *hdcp);\n\n \nenum mod_hdcp_status mod_hdcp_read_bksv(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_bcaps(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_bstatus(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_r0p(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_ksvlist(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_vp(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_binfo(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_aksv(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_ainfo(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_an(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_hdcp2version(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_rxcaps(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_rxstatus(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_ake_cert(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_h_prime(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_pairing_info(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_l_prime(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_rx_id_list(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_read_stream_ready(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_ake_init(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_no_stored_km(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_stored_km(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_lc_init(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_eks(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_repeater_auth_ack(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_stream_manage(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_write_content_type(struct mod_hdcp *hdcp);\nenum mod_hdcp_status mod_hdcp_clear_cp_irq_status(struct mod_hdcp *hdcp);\n\n \nstatic inline uint8_t is_dp_hdcp(struct mod_hdcp *hdcp)\n{\n\treturn (hdcp->connection.link.mode == MOD_HDCP_MODE_DP);\n}\n\nstatic inline uint8_t is_dp_mst_hdcp(struct mod_hdcp *hdcp)\n{\n\treturn (hdcp->connection.link.mode == MOD_HDCP_MODE_DP &&\n\t\t\thdcp->connection.link.dp.mst_enabled);\n}\n\nstatic inline uint8_t is_hdmi_dvi_sl_hdcp(struct mod_hdcp *hdcp)\n{\n\treturn (hdcp->connection.link.mode == MOD_HDCP_MODE_DEFAULT);\n}\n\n \nstatic inline uint8_t current_state(struct mod_hdcp *hdcp)\n{\n\treturn hdcp->state.id;\n}\n\nstatic inline void set_state_id(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_output *output, uint8_t id)\n{\n\tmemset(&hdcp->state, 0, sizeof(hdcp->state));\n\thdcp->state.id = id;\n\t \n\toutput->callback_stop = 1;\n\toutput->watchdog_timer_stop = 1;\n\tHDCP_NEXT_STATE_TRACE(hdcp, id, output);\n}\n\nstatic inline uint8_t is_in_hdcp1_states(struct mod_hdcp *hdcp)\n{\n\treturn (current_state(hdcp) > HDCP1_STATE_START &&\n\t\t\tcurrent_state(hdcp) <= HDCP1_STATE_END);\n}\n\nstatic inline uint8_t is_in_hdcp1_dp_states(struct mod_hdcp *hdcp)\n{\n\treturn (current_state(hdcp) > HDCP1_DP_STATE_START &&\n\t\t\tcurrent_state(hdcp) <= HDCP1_DP_STATE_END);\n}\n\nstatic inline uint8_t is_in_hdcp2_states(struct mod_hdcp *hdcp)\n{\n\treturn (current_state(hdcp) > HDCP2_STATE_START &&\n\t\t\tcurrent_state(hdcp) <= HDCP2_STATE_END);\n}\n\nstatic inline uint8_t is_in_hdcp2_dp_states(struct mod_hdcp *hdcp)\n{\n\treturn (current_state(hdcp) > HDCP2_DP_STATE_START &&\n\t\t\tcurrent_state(hdcp) <= HDCP2_DP_STATE_END);\n}\n\nstatic inline uint8_t is_in_authenticated_states(struct mod_hdcp *hdcp)\n{\n\treturn (current_state(hdcp) == D1_A4_AUTHENTICATED ||\n\tcurrent_state(hdcp) == H1_A45_AUTHENTICATED ||\n\tcurrent_state(hdcp) == D2_A5_AUTHENTICATED ||\n\tcurrent_state(hdcp) == H2_A5_AUTHENTICATED);\n}\n\nstatic inline uint8_t is_hdcp1(struct mod_hdcp *hdcp)\n{\n\treturn (is_in_hdcp1_states(hdcp) || is_in_hdcp1_dp_states(hdcp));\n}\n\nstatic inline uint8_t is_hdcp2(struct mod_hdcp *hdcp)\n{\n\treturn (is_in_hdcp2_states(hdcp) || is_in_hdcp2_dp_states(hdcp));\n}\n\nstatic inline uint8_t is_in_cp_not_desired_state(struct mod_hdcp *hdcp)\n{\n\treturn current_state(hdcp) == HDCP_CP_NOT_DESIRED;\n}\n\nstatic inline uint8_t is_in_initialized_state(struct mod_hdcp *hdcp)\n{\n\treturn current_state(hdcp) == HDCP_INITIALIZED;\n}\n\n \nstatic inline void increment_stay_counter(struct mod_hdcp *hdcp)\n{\n\thdcp->state.stay_count++;\n}\n\nstatic inline void fail_and_restart_in_ms(uint16_t time,\n\t\tenum mod_hdcp_status *status,\n\t\tstruct mod_hdcp_output *output)\n{\n\toutput->callback_needed = 1;\n\toutput->callback_delay = time;\n\toutput->watchdog_timer_needed = 0;\n\toutput->watchdog_timer_delay = 0;\n\t*status = MOD_HDCP_STATUS_RESET_NEEDED;\n}\n\nstatic inline void callback_in_ms(uint16_t time, struct mod_hdcp_output *output)\n{\n\toutput->callback_needed = 1;\n\toutput->callback_delay = time;\n}\n\nstatic inline void set_watchdog_in_ms(struct mod_hdcp *hdcp, uint16_t time,\n\t\tstruct mod_hdcp_output *output)\n{\n\toutput->watchdog_timer_needed = 1;\n\toutput->watchdog_timer_delay = time;\n}\n\nstatic inline void set_auth_complete(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_output *output)\n{\n\toutput->auth_complete = 1;\n\tmod_hdcp_log_ddc_trace(hdcp);\n}\n\n \nstatic inline uint8_t is_display_active(struct mod_hdcp_display *display)\n{\n\treturn display->state >= MOD_HDCP_DISPLAY_ACTIVE;\n}\n\nstatic inline uint8_t is_display_encryption_enabled(struct mod_hdcp_display *display)\n{\n\treturn display->state >= MOD_HDCP_DISPLAY_ENCRYPTION_ENABLED;\n}\n\nstatic inline uint8_t get_active_display_count(struct mod_hdcp *hdcp)\n{\n\tuint8_t active_count = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\tif (is_display_active(&hdcp->displays[i]))\n\t\t\tactive_count++;\n\treturn active_count;\n}\n\nstatic inline struct mod_hdcp_display *get_first_active_display(\n\t\tstruct mod_hdcp *hdcp)\n{\n\tuint8_t i;\n\tstruct mod_hdcp_display *display = NULL;\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\tif (is_display_active(&hdcp->displays[i])) {\n\t\t\tdisplay = &hdcp->displays[i];\n\t\t\tbreak;\n\t\t}\n\treturn display;\n}\n\nstatic inline struct mod_hdcp_display *get_active_display_at_index(\n\t\tstruct mod_hdcp *hdcp, uint8_t index)\n{\n\tuint8_t i;\n\tstruct mod_hdcp_display *display = NULL;\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\tif (hdcp->displays[i].index == index &&\n\t\t\t\tis_display_active(&hdcp->displays[i])) {\n\t\t\tdisplay = &hdcp->displays[i];\n\t\t\tbreak;\n\t\t}\n\treturn display;\n}\n\nstatic inline struct mod_hdcp_display *get_empty_display_container(\n\t\tstruct mod_hdcp *hdcp)\n{\n\tuint8_t i;\n\tstruct mod_hdcp_display *display = NULL;\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\tif (!is_display_active(&hdcp->displays[i])) {\n\t\t\tdisplay = &hdcp->displays[i];\n\t\t\tbreak;\n\t\t}\n\treturn display;\n}\n\nstatic inline void reset_retry_counts(struct mod_hdcp *hdcp)\n{\n\thdcp->connection.hdcp1_retry_count = 0;\n\thdcp->connection.hdcp2_retry_count = 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}