{
  "module_name": "info_packet.c",
  "hash_id": "6c14bd4eb5aa46ebfe44ae1b5121cde5591383af74b81592610990770c381b2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c",
  "human_readable_source": " \n\n#include \"mod_info_packet.h\"\n#include \"core_types.h\"\n#include \"dc_types.h\"\n#include \"mod_shared.h\"\n#include \"mod_freesync.h\"\n#include \"dc.h\"\n\nenum vsc_packet_revision {\n\tvsc_packet_undefined = 0,\n\t\n\tvsc_packet_rev1 = 1,\n\t\n\tvsc_packet_rev2 = 2,\n\t\n\tvsc_packet_rev3 = 3,\n\t\n\tvsc_packet_rev4 = 4,\n\t\n\tvsc_packet_rev5 = 5,\n};\n\n#define HDMI_INFOFRAME_TYPE_VENDOR 0x81\n#define HF_VSIF_VERSION 1\n\n\n#define VTEM_PB0\t\t0\n#define VTEM_PB1\t\t1\n#define VTEM_PB2\t\t2\n#define VTEM_PB3\t\t3\n#define VTEM_PB4\t\t4\n#define VTEM_PB5\t\t5\n#define VTEM_PB6\t\t6\n\n#define VTEM_MD0\t\t7\n#define VTEM_MD1\t\t8\n#define VTEM_MD2\t\t9\n#define VTEM_MD3\t\t10\n\n\n\n\n#define MASK_VTEM_PB0__RESERVED0  0x01\n#define MASK_VTEM_PB0__SYNC       0x02\n#define MASK_VTEM_PB0__VFR        0x04\n#define MASK_VTEM_PB0__AFR        0x08\n#define MASK_VTEM_PB0__DS_TYPE    0x30\n\t\n\t\n\t\n\t\n#define MASK_VTEM_PB0__END        0x40\n#define MASK_VTEM_PB0__NEW        0x80\n\n\n#define MASK_VTEM_PB1__RESERVED1 0xFF\n\n\n#define MASK_VTEM_PB2__ORGANIZATION_ID 0xFF\n\t\n\t\n\t\n\t\n\n#define MASK_VTEM_PB3__DATA_SET_TAG_MSB    0xFF\n\n#define MASK_VTEM_PB4__DATA_SET_TAG_LSB    0xFF\n\n#define MASK_VTEM_PB5__DATA_SET_LENGTH_MSB 0xFF\n\n#define MASK_VTEM_PB6__DATA_SET_LENGTH_LSB 0xFF\n\n\n\n\n\n#define MASK_VTEM_MD0__VRR_EN         0x01\n#define MASK_VTEM_MD0__M_CONST        0x02\n#define MASK_VTEM_MD0__QMS_EN         0x04\n#define MASK_VTEM_MD0__RESERVED2      0x08\n#define MASK_VTEM_MD0__FVA_FACTOR_M1  0xF0\n\n\n#define MASK_VTEM_MD1__BASE_VFRONT    0xFF\n\n\n#define MASK_VTEM_MD2__BASE_REFRESH_RATE_98  0x03\n#define MASK_VTEM_MD2__RB                    0x04\n#define MASK_VTEM_MD2__NEXT_TFR              0xF8\n\n\n#define MASK_VTEM_MD3__BASE_REFRESH_RATE_07  0xFF\n\nenum ColorimetryRGBDP {\n\tColorimetryRGB_DP_sRGB               = 0,\n\tColorimetryRGB_DP_AdobeRGB           = 3,\n\tColorimetryRGB_DP_P3                 = 4,\n\tColorimetryRGB_DP_CustomColorProfile = 5,\n\tColorimetryRGB_DP_ITU_R_BT2020RGB    = 6,\n};\nenum ColorimetryYCCDP {\n\tColorimetryYCC_DP_ITU601        = 0,\n\tColorimetryYCC_DP_ITU709        = 1,\n\tColorimetryYCC_DP_AdobeYCC      = 5,\n\tColorimetryYCC_DP_ITU2020YCC    = 6,\n\tColorimetryYCC_DP_ITU2020YCbCr  = 7,\n};\n\nvoid mod_build_vsc_infopacket(const struct dc_stream_state *stream,\n\t\tstruct dc_info_packet *info_packet,\n\t\tenum dc_color_space cs,\n\t\tenum color_transfer_func tf)\n{\n\tunsigned int vsc_packet_revision = vsc_packet_undefined;\n\tunsigned int i;\n\tunsigned int pixelEncoding = 0;\n\tunsigned int colorimetryFormat = 0;\n\tbool stereo3dSupport = false;\n\n\tif (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE) {\n\t\tvsc_packet_revision = vsc_packet_rev1;\n\t\tstereo3dSupport = true;\n\t}\n\n\t \n\tif (stream->link->psr_settings.psr_feature_enabled) {\n\t\tif (stream->link->psr_settings.psr_version == DC_PSR_VERSION_SU_1)\n\t\t\tvsc_packet_revision = vsc_packet_rev4;\n\t\telse if (stream->link->psr_settings.psr_version == DC_PSR_VERSION_1)\n\t\t\tvsc_packet_revision = vsc_packet_rev2;\n\t}\n\n\tif (stream->link->replay_settings.config.replay_supported)\n\t\tvsc_packet_revision = vsc_packet_rev4;\n\n\t \n\tif (stream->use_vsc_sdp_for_colorimetry)\n\t\tvsc_packet_revision = vsc_packet_rev5;\n\n\t \n\tif (vsc_packet_revision == vsc_packet_undefined)\n\t\treturn;\n\n\tif (vsc_packet_revision == vsc_packet_rev4) {\n\t\t \n\t\tinfo_packet->hb0 = 0x00;\n\t\t \n\t\tinfo_packet->hb1 = 0x07;\n\t\t \n\t\tinfo_packet->hb2 = 0x04;\n\t\t \n\t\tinfo_packet->hb3 = 0x0E;\n\n\t\tfor (i = 0; i < 28; i++)\n\t\t\tinfo_packet->sb[i] = 0;\n\n\t\tinfo_packet->valid = true;\n\t}\n\n\tif (vsc_packet_revision == vsc_packet_rev2) {\n\t\t \n\t\tinfo_packet->hb0 = 0x00;\n\t\t \n\t\tinfo_packet->hb1 = 0x07;\n\t\t \n\t\tinfo_packet->hb2 = 0x02;\n\t\t \n\t\tinfo_packet->hb3 = 0x08;\n\n\t\tfor (i = 0; i < 28; i++)\n\t\t\tinfo_packet->sb[i] = 0;\n\n\t\tinfo_packet->valid = true;\n\t}\n\n\tif (vsc_packet_revision == vsc_packet_rev1) {\n\n\t\tinfo_packet->hb0 = 0x00;\t\n\t\tinfo_packet->hb1 = 0x07;\t\n\t\tinfo_packet->hb2 = 0x01;\t\n\t\tinfo_packet->hb3 = 0x01;\t\n\n\t\tinfo_packet->valid = true;\n\t}\n\n\tif (stereo3dSupport) {\n\t\t \n\t\tswitch (stream->timing.timing_3d_format) {\n\t\tcase TIMING_3D_FORMAT_HW_FRAME_PACKING:\n\t\tcase TIMING_3D_FORMAT_SW_FRAME_PACKING:\n\t\tcase TIMING_3D_FORMAT_TOP_AND_BOTTOM:\n\t\tcase TIMING_3D_FORMAT_TB_SW_PACKED:\n\t\t\tinfo_packet->sb[0] = 0x02; \n\t\t\tbreak;\n\t\tcase TIMING_3D_FORMAT_DP_HDMI_INBAND_FA:\n\t\tcase TIMING_3D_FORMAT_INBAND_FA:\n\t\t\tinfo_packet->sb[0] = 0x01; \n\t\t\tbreak;\n\t\tcase TIMING_3D_FORMAT_SIDE_BY_SIDE:\n\t\tcase TIMING_3D_FORMAT_SBS_SW_PACKED:\n\t\t\tinfo_packet->sb[0] = 0x04; \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo_packet->sb[0] = 0x00; \n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t \n\tif (vsc_packet_revision == vsc_packet_rev5) {\n\t\t \n\t\tinfo_packet->hb0 = 0x00;\n\t\t \n\t\tinfo_packet->hb1 = 0x07;\n\t\t \n\t\tinfo_packet->hb2 = 0x05;\n\t\t \n\t\tinfo_packet->hb3 = 0x13;\n\n\t\tinfo_packet->valid = true;\n\n\t\t \n\n\t\t \n\t\tswitch (stream->timing.pixel_encoding) {\n\t\tcase PIXEL_ENCODING_RGB:\n\t\t\tpixelEncoding = 0x0;   \n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR444:\n\t\t\tpixelEncoding = 0x1;   \n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\t\tpixelEncoding = 0x2;   \n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR420:\n\t\t\tpixelEncoding = 0x3;   \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpixelEncoding = 0x0;   \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (stream->timing.pixel_encoding) {\n\t\tcase PIXEL_ENCODING_RGB:\n\t\t\tif ((cs == COLOR_SPACE_SRGB) ||\n\t\t\t\t\t(cs == COLOR_SPACE_SRGB_LIMITED))\n\t\t\t\tcolorimetryFormat = ColorimetryRGB_DP_sRGB;\n\t\t\telse if (cs == COLOR_SPACE_ADOBERGB)\n\t\t\t\tcolorimetryFormat = ColorimetryRGB_DP_AdobeRGB;\n\t\t\telse if ((cs == COLOR_SPACE_2020_RGB_FULLRANGE) ||\n\t\t\t\t\t(cs == COLOR_SPACE_2020_RGB_LIMITEDRANGE))\n\t\t\t\tcolorimetryFormat = ColorimetryRGB_DP_ITU_R_BT2020RGB;\n\t\t\tbreak;\n\n\t\tcase PIXEL_ENCODING_YCBCR444:\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\tcase PIXEL_ENCODING_YCBCR420:\n\t\t\t \n\t\t\tif (cs == COLOR_SPACE_YCBCR601)\n\t\t\t\tcolorimetryFormat = ColorimetryYCC_DP_ITU601;\n\t\t\telse if (cs == COLOR_SPACE_YCBCR709)\n\t\t\t\tcolorimetryFormat = ColorimetryYCC_DP_ITU709;\n\t\t\telse if (cs == COLOR_SPACE_ADOBERGB)\n\t\t\t\tcolorimetryFormat = ColorimetryYCC_DP_AdobeYCC;\n\t\t\telse if (cs == COLOR_SPACE_2020_YCBCR)\n\t\t\t\tcolorimetryFormat = ColorimetryYCC_DP_ITU2020YCbCr;\n\n\t\t\tif (cs == COLOR_SPACE_2020_YCBCR && tf == TRANSFER_FUNC_GAMMA_22)\n\t\t\t\tcolorimetryFormat = ColorimetryYCC_DP_ITU709;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcolorimetryFormat = ColorimetryRGB_DP_sRGB;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo_packet->sb[16] = (pixelEncoding << 4) | colorimetryFormat;\n\n\t\t \n\t\tswitch (stream->timing.display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\t\t \n\t\t\tinfo_packet->sb[17] = 0;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_888:\n\t\t\tinfo_packet->sb[17] = 1;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tinfo_packet->sb[17] = 2;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tinfo_packet->sb[17] = 3;\n\t\t\tbreak;\n\t\t \n\t\tcase COLOR_DEPTH_161616:\n\t\t\tinfo_packet->sb[17] = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo_packet->sb[17] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((cs == COLOR_SPACE_SRGB_LIMITED) ||\n\t\t\t\t(cs == COLOR_SPACE_2020_RGB_LIMITEDRANGE) ||\n\t\t\t\t(pixelEncoding != 0x0)) {\n\t\t\tinfo_packet->sb[17] |= 0x80;  \n\t\t}\n\n\t\t \n\t\tinfo_packet->sb[18] = 0;\n\t}\n}\n\n \nvoid mod_build_hf_vsif_infopacket(const struct dc_stream_state *stream,\n\t\tstruct dc_info_packet *info_packet)\n{\n\t\tunsigned int length = 5;\n\t\tbool hdmi_vic_mode = false;\n\t\tuint8_t checksum = 0;\n\t\tuint32_t i = 0;\n\t\tenum dc_timing_3d_format format;\n\n\t\tinfo_packet->valid = false;\n\t\tformat = stream->timing.timing_3d_format;\n\t\tif (stream->view_format == VIEW_3D_FORMAT_NONE)\n\t\t\tformat = TIMING_3D_FORMAT_NONE;\n\n\t\tif (stream->timing.hdmi_vic != 0\n\t\t\t\t&& stream->timing.h_total >= 3840\n\t\t\t\t&& stream->timing.v_total >= 2160\n\t\t\t\t&& format == TIMING_3D_FORMAT_NONE)\n\t\t\thdmi_vic_mode = true;\n\n\t\tif ((format == TIMING_3D_FORMAT_NONE) && !hdmi_vic_mode)\n\t\t\treturn;\n\n\t\tinfo_packet->sb[1] = 0x03;\n\t\tinfo_packet->sb[2] = 0x0C;\n\t\tinfo_packet->sb[3] = 0x00;\n\n\t\tif (format != TIMING_3D_FORMAT_NONE)\n\t\t\tinfo_packet->sb[4] = (2 << 5);\n\n\t\telse if (hdmi_vic_mode)\n\t\t\tinfo_packet->sb[4] = (1 << 5);\n\n\t\tswitch (format) {\n\t\tcase TIMING_3D_FORMAT_HW_FRAME_PACKING:\n\t\tcase TIMING_3D_FORMAT_SW_FRAME_PACKING:\n\t\t\tinfo_packet->sb[5] = (0x0 << 4);\n\t\t\tbreak;\n\n\t\tcase TIMING_3D_FORMAT_SIDE_BY_SIDE:\n\t\tcase TIMING_3D_FORMAT_SBS_SW_PACKED:\n\t\t\tinfo_packet->sb[5] = (0x8 << 4);\n\t\t\tlength = 6;\n\t\t\tbreak;\n\n\t\tcase TIMING_3D_FORMAT_TOP_AND_BOTTOM:\n\t\tcase TIMING_3D_FORMAT_TB_SW_PACKED:\n\t\t\tinfo_packet->sb[5] = (0x6 << 4);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hdmi_vic_mode)\n\t\t\tinfo_packet->sb[5] = stream->timing.hdmi_vic;\n\n\t\tinfo_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR;\n\t\tinfo_packet->hb1 = 0x01;\n\t\tinfo_packet->hb2 = (uint8_t) (length);\n\n\t\tchecksum += info_packet->hb0;\n\t\tchecksum += info_packet->hb1;\n\t\tchecksum += info_packet->hb2;\n\n\t\tfor (i = 1; i <= length; i++)\n\t\t\tchecksum += info_packet->sb[i];\n\n\t\tinfo_packet->sb[0] = (uint8_t) (0x100 - checksum);\n\n\t\tinfo_packet->valid = true;\n}\n\nvoid mod_build_adaptive_sync_infopacket(const struct dc_stream_state *stream,\n\t\tenum adaptive_sync_type asType,\n\t\tconst struct AS_Df_params *param,\n\t\tstruct dc_info_packet *info_packet)\n{\n\tinfo_packet->valid = false;\n\n\tmemset(info_packet, 0, sizeof(struct dc_info_packet));\n\n\tswitch (asType) {\n\tcase ADAPTIVE_SYNC_TYPE_DP:\n\t\tif (stream != NULL)\n\t\t\tmod_build_adaptive_sync_infopacket_v2(stream, param, info_packet);\n\t\tbreak;\n\tcase FREESYNC_TYPE_PCON_IN_WHITELIST:\n\t\tmod_build_adaptive_sync_infopacket_v1(info_packet);\n\t\tbreak;\n\tcase ADAPTIVE_SYNC_TYPE_EDP:\n\t\tmod_build_adaptive_sync_infopacket_v1(info_packet);\n\t\tbreak;\n\tcase ADAPTIVE_SYNC_TYPE_NONE:\n\tcase FREESYNC_TYPE_PCON_NOT_IN_WHITELIST:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid mod_build_adaptive_sync_infopacket_v1(struct dc_info_packet *info_packet)\n{\n\tinfo_packet->valid = true;\n\t\n\tinfo_packet->hb0 = 0x00;\n\tinfo_packet->hb1 = 0x22;\n\tinfo_packet->hb2 = AS_SDP_VER_1;\n\tinfo_packet->hb3 = 0x00;\n}\n\nvoid mod_build_adaptive_sync_infopacket_v2(const struct dc_stream_state *stream,\n\t\tconst struct AS_Df_params *param,\n\t\tstruct dc_info_packet *info_packet)\n{\n\tinfo_packet->valid = true;\n\t\n\tinfo_packet->hb0 = 0x00;\n\tinfo_packet->hb1 = 0x22;\n\tinfo_packet->hb2 = AS_SDP_VER_2;\n\tinfo_packet->hb3 = AS_DP_SDP_LENGTH;\n\n\t\n\tinfo_packet->sb[0] = param->supportMode; \n\tinfo_packet->sb[1] = (stream->timing.v_total & 0x00FF);\n\tinfo_packet->sb[2] = (stream->timing.v_total & 0xFF00) >> 8;\n\t\n\tinfo_packet->sb[4] = (param->increase.support << 6 | param->decrease.support << 7);\n\tinfo_packet->sb[5] = param->increase.frame_duration_hex;\n\tinfo_packet->sb[6] = param->decrease.frame_duration_hex;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}