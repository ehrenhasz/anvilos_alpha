{
  "module_name": "hdcp.c",
  "hash_id": "4100a3b20cf167d660042b106a7d98b97e48620fcbd89dde6b9661ef0df91cc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp.c",
  "human_readable_source": " \n\n#include \"hdcp.h\"\n\nstatic void push_error_status(struct mod_hdcp *hdcp,\n\t\tenum mod_hdcp_status status)\n{\n\tstruct mod_hdcp_trace *trace = &hdcp->connection.trace;\n\n\tif (trace->error_count < MAX_NUM_OF_ERROR_TRACE) {\n\t\ttrace->errors[trace->error_count].status = status;\n\t\ttrace->errors[trace->error_count].state_id = hdcp->state.id;\n\t\ttrace->error_count++;\n\t\tHDCP_ERROR_TRACE(hdcp, status);\n\t}\n\n\tif (is_hdcp1(hdcp)) {\n\t\thdcp->connection.hdcp1_retry_count++;\n\t\tif (hdcp->connection.hdcp1_retry_count == MAX_NUM_OF_ATTEMPTS)\n\t\t\thdcp->connection.link.adjust.hdcp1.disable = 1;\n\t} else if (is_hdcp2(hdcp)) {\n\t\thdcp->connection.hdcp2_retry_count++;\n\t\tif (hdcp->connection.hdcp2_retry_count == MAX_NUM_OF_ATTEMPTS)\n\t\t\thdcp->connection.link.adjust.hdcp2.disable = 1;\n\t}\n}\n\nstatic uint8_t is_cp_desired_hdcp1(struct mod_hdcp *hdcp)\n{\n\tint i, is_auth_needed = 0;\n\n\t \n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++) {\n\t\tif (hdcp->displays[i].state != MOD_HDCP_DISPLAY_INACTIVE &&\n\t\t\t\thdcp->displays[i].adjust.disable != MOD_HDCP_DISPLAY_DISABLE_AUTHENTICATION) {\n\t\t\tis_auth_needed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn is_auth_needed &&\n\t\t\t!hdcp->connection.link.adjust.hdcp1.disable &&\n\t\t\t!hdcp->connection.is_hdcp1_revoked;\n}\n\nstatic uint8_t is_cp_desired_hdcp2(struct mod_hdcp *hdcp)\n{\n\tint i, is_auth_needed = 0;\n\n\t \n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++) {\n\t\tif (hdcp->displays[i].state != MOD_HDCP_DISPLAY_INACTIVE &&\n\t\t\t\thdcp->displays[i].adjust.disable != MOD_HDCP_DISPLAY_DISABLE_AUTHENTICATION) {\n\t\t\tis_auth_needed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn is_auth_needed &&\n\t\t\t!hdcp->connection.link.adjust.hdcp2.disable &&\n\t\t\t!hdcp->connection.is_hdcp2_revoked;\n}\n\nstatic enum mod_hdcp_status execution(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tunion mod_hdcp_transition_input *input)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (is_in_initialized_state(hdcp)) {\n\t\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\t\tevent_ctx->unexpected_event = 1;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tmemset(input, 0, sizeof(union mod_hdcp_transition_input));\n\t} else if (is_in_cp_not_desired_state(hdcp)) {\n\t\tif (event_ctx->event != MOD_HDCP_EVENT_CALLBACK) {\n\t\t\tevent_ctx->unexpected_event = 1;\n\t\t\tgoto out;\n\t\t}\n\t} else if (is_in_hdcp1_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp1_execution(hdcp, event_ctx, &input->hdcp1);\n\t} else if (is_in_hdcp1_dp_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp1_dp_execution(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp1);\n\t} else if (is_in_hdcp2_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp2_execution(hdcp, event_ctx, &input->hdcp2);\n\t} else if (is_in_hdcp2_dp_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp2_dp_execution(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp2);\n\t} else {\n\t\tevent_ctx->unexpected_event = 1;\n\t\tgoto out;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status transition(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_event_context *event_ctx,\n\t\tunion mod_hdcp_transition_input *input,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (event_ctx->unexpected_event)\n\t\tgoto out;\n\n\tif (is_in_initialized_state(hdcp)) {\n\t\tif (is_dp_hdcp(hdcp))\n\t\t\tif (is_cp_desired_hdcp2(hdcp)) {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, D2_A0_DETERMINE_RX_HDCP_CAPABLE);\n\t\t\t} else if (is_cp_desired_hdcp1(hdcp)) {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, D1_A0_DETERMINE_RX_HDCP_CAPABLE);\n\t\t\t} else {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, HDCP_CP_NOT_DESIRED);\n\t\t\t\tset_auth_complete(hdcp, output);\n\t\t\t}\n\t\telse if (is_hdmi_dvi_sl_hdcp(hdcp))\n\t\t\tif (is_cp_desired_hdcp2(hdcp)) {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, H2_A0_KNOWN_HDCP2_CAPABLE_RX);\n\t\t\t} else if (is_cp_desired_hdcp1(hdcp)) {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, H1_A0_WAIT_FOR_ACTIVE_RX);\n\t\t\t} else {\n\t\t\t\tcallback_in_ms(0, output);\n\t\t\t\tset_state_id(hdcp, output, HDCP_CP_NOT_DESIRED);\n\t\t\t\tset_auth_complete(hdcp, output);\n\t\t\t}\n\t\telse {\n\t\t\tcallback_in_ms(0, output);\n\t\t\tset_state_id(hdcp, output, HDCP_CP_NOT_DESIRED);\n\t\t\tset_auth_complete(hdcp, output);\n\t\t}\n\t} else if (is_in_cp_not_desired_state(hdcp)) {\n\t\tincrement_stay_counter(hdcp);\n\t} else if (is_in_hdcp1_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp1_transition(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp1, output);\n\t} else if (is_in_hdcp1_dp_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp1_dp_transition(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp1, output);\n\t} else if (is_in_hdcp2_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp2_transition(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp2, output);\n\t} else if (is_in_hdcp2_dp_states(hdcp)) {\n\t\tstatus = mod_hdcp_hdcp2_dp_transition(hdcp,\n\t\t\t\tevent_ctx, &input->hdcp2, output);\n\t} else {\n\t\tstatus = MOD_HDCP_STATUS_INVALID_STATE;\n\t}\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status reset_authentication(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (is_hdcp1(hdcp)) {\n\t\tif (hdcp->auth.trans_input.hdcp1.create_session != UNKNOWN) {\n\t\t\t \n\t\t\tmod_hdcp_hdcp1_destroy_session(hdcp);\n\n\t\t}\n\n\t\tHDCP_TOP_RESET_AUTH_TRACE(hdcp);\n\t\tmemset(&hdcp->auth, 0, sizeof(struct mod_hdcp_authentication));\n\t\tmemset(&hdcp->state, 0, sizeof(struct mod_hdcp_state));\n\t\tset_state_id(hdcp, output, HDCP_INITIALIZED);\n\t} else if (is_hdcp2(hdcp)) {\n\t\tif (hdcp->auth.trans_input.hdcp2.create_session == PASS) {\n\t\t\tstatus = mod_hdcp_hdcp2_destroy_session(hdcp);\n\t\t\tif (status != MOD_HDCP_STATUS_SUCCESS) {\n\t\t\t\toutput->callback_needed = 0;\n\t\t\t\toutput->watchdog_timer_needed = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tHDCP_TOP_RESET_AUTH_TRACE(hdcp);\n\t\tmemset(&hdcp->auth, 0, sizeof(struct mod_hdcp_authentication));\n\t\tmemset(&hdcp->state, 0, sizeof(struct mod_hdcp_state));\n\t\tset_state_id(hdcp, output, HDCP_INITIALIZED);\n\t} else if (is_in_cp_not_desired_state(hdcp)) {\n\t\tHDCP_TOP_RESET_AUTH_TRACE(hdcp);\n\t\tmemset(&hdcp->auth, 0, sizeof(struct mod_hdcp_authentication));\n\t\tmemset(&hdcp->state, 0, sizeof(struct mod_hdcp_state));\n\t\tset_state_id(hdcp, output, HDCP_INITIALIZED);\n\t}\n\nout:\n\t \n\toutput->watchdog_timer_stop = 1;\n\toutput->callback_stop = 1;\n\treturn status;\n}\n\nstatic enum mod_hdcp_status reset_connection(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmemset(output, 0, sizeof(struct mod_hdcp_output));\n\n\tstatus = reset_authentication(hdcp, output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\tif (current_state(hdcp) != HDCP_UNINITIALIZED) {\n\t\tHDCP_TOP_RESET_CONN_TRACE(hdcp);\n\t\tset_state_id(hdcp, output, HDCP_UNINITIALIZED);\n\t}\n\tmemset(&hdcp->connection, 0, sizeof(hdcp->connection));\nout:\n\treturn status;\n}\n\nstatic enum mod_hdcp_status update_display_adjustments(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_display *display,\n\t\tstruct mod_hdcp_display_adjustment *adj)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_NOT_IMPLEMENTED;\n\n\tif (is_in_authenticated_states(hdcp) &&\n\t\t\tis_dp_mst_hdcp(hdcp) &&\n\t\t\tdisplay->adjust.disable == true &&\n\t\t\tadj->disable == false) {\n\t\tdisplay->adjust.disable = false;\n\t\tif (is_hdcp1(hdcp))\n\t\t\tstatus = mod_hdcp_hdcp1_enable_dp_stream_encryption(hdcp);\n\t\telse if (is_hdcp2(hdcp))\n\t\t\tstatus = mod_hdcp_hdcp2_enable_dp_stream_encryption(hdcp);\n\n\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tdisplay->adjust.disable = true;\n\t}\n\n\tif (status == MOD_HDCP_STATUS_SUCCESS &&\n\t\tmemcmp(adj, &display->adjust,\n\t\tsizeof(struct mod_hdcp_display_adjustment)) != 0)\n\t\tstatus = MOD_HDCP_STATUS_NOT_IMPLEMENTED;\n\n\treturn status;\n}\n \nsize_t mod_hdcp_get_memory_size(void)\n{\n\treturn sizeof(struct mod_hdcp);\n}\n\nenum mod_hdcp_status mod_hdcp_setup(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_config *config)\n{\n\tstruct mod_hdcp_output output;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmemset(&output, 0, sizeof(output));\n\thdcp->config = *config;\n\tHDCP_TOP_INTERFACE_TRACE(hdcp);\n\tstatus = reset_connection(hdcp, &output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tpush_error_status(hdcp, status);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_teardown(struct mod_hdcp *hdcp)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_output output;\n\n\tHDCP_TOP_INTERFACE_TRACE(hdcp);\n\tmemset(&output, 0,  sizeof(output));\n\tstatus = reset_connection(hdcp, &output);\n\tif (status == MOD_HDCP_STATUS_SUCCESS)\n\t\tmemset(hdcp, 0, sizeof(struct mod_hdcp));\n\telse\n\t\tpush_error_status(hdcp, status);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_add_display(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_link *link, struct mod_hdcp_display *display,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_display *display_container = NULL;\n\n\tHDCP_TOP_INTERFACE_TRACE_WITH_INDEX(hdcp, display->index);\n\tmemset(output, 0, sizeof(struct mod_hdcp_output));\n\n\t \n\tif (display->state != MOD_HDCP_DISPLAY_ACTIVE) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (get_active_display_at_index(hdcp, display->index)) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tdisplay_container = get_empty_display_container(hdcp);\n\tif (!display_container) {\n\t\tstatus = MOD_HDCP_STATUS_DISPLAY_OUT_OF_BOUND;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = reset_authentication(hdcp, output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\t \n\treset_retry_counts(hdcp);\n\n\t \n\tmemset(&hdcp->connection.trace, 0, sizeof(hdcp->connection.trace));\n\n\t \n\thdcp->connection.link = *link;\n\t*display_container = *display;\n\tstatus = mod_hdcp_add_display_to_topology(hdcp, display_container);\n\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\t \n\tif (current_state(hdcp) != HDCP_INITIALIZED)\n\t\tset_state_id(hdcp, output, HDCP_INITIALIZED);\n\tcallback_in_ms(hdcp->connection.link.adjust.auth_delay * 1000, output);\nout:\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tpush_error_status(hdcp, status);\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_remove_display(struct mod_hdcp *hdcp,\n\t\tuint8_t index, struct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_display *display = NULL;\n\n\tHDCP_TOP_INTERFACE_TRACE_WITH_INDEX(hdcp, index);\n\tmemset(output, 0, sizeof(struct mod_hdcp_output));\n\n\t \n\tdisplay = get_active_display_at_index(hdcp, index);\n\tif (!display) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = reset_authentication(hdcp, output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\t \n\treset_retry_counts(hdcp);\n\n\t \n\tmemset(&hdcp->connection.trace, 0, sizeof(hdcp->connection.trace));\n\n\t \n\tstatus = mod_hdcp_remove_display_from_topology(hdcp, index);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\tmemset(display, 0, sizeof(struct mod_hdcp_display));\n\n\t \n\tif (current_state(hdcp) != HDCP_UNINITIALIZED)\n\t\tcallback_in_ms(hdcp->connection.link.adjust.auth_delay * 1000,\n\t\t\t\toutput);\nout:\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tpush_error_status(hdcp, status);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_update_display(struct mod_hdcp *hdcp,\n\t\tuint8_t index,\n\t\tstruct mod_hdcp_link_adjustment *link_adjust,\n\t\tstruct mod_hdcp_display_adjustment *display_adjust,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_display *display = NULL;\n\n\tHDCP_TOP_INTERFACE_TRACE_WITH_INDEX(hdcp, index);\n\tmemset(output, 0, sizeof(struct mod_hdcp_output));\n\n\t \n\tdisplay = get_active_display_at_index(hdcp, index);\n\tif (!display) {\n\t\tstatus = MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\t \n\tif (memcmp(link_adjust, &hdcp->connection.link.adjust,\n\t\t\tsizeof(struct mod_hdcp_link_adjustment)) == 0 &&\n\t\t\tmemcmp(display_adjust, &display->adjust,\n\t\t\t\t\tsizeof(struct mod_hdcp_display_adjustment)) == 0) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(link_adjust, &hdcp->connection.link.adjust,\n\t\t\tsizeof(struct mod_hdcp_link_adjustment)) == 0 &&\n\t\t\tmemcmp(display_adjust, &display->adjust,\n\t\t\t\t\tsizeof(struct mod_hdcp_display_adjustment)) != 0) {\n\t\tstatus = update_display_adjustments(hdcp, display, display_adjust);\n\t\tif (status != MOD_HDCP_STATUS_NOT_IMPLEMENTED)\n\t\t\tgoto out;\n\t}\n\n\t \n\tstatus = reset_authentication(hdcp, output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tgoto out;\n\n\t \n\treset_retry_counts(hdcp);\n\n\t \n\tmemset(&hdcp->connection.trace, 0, sizeof(hdcp->connection.trace));\n\n\t \n\thdcp->connection.link.adjust = *link_adjust;\n\tdisplay->adjust = *display_adjust;\n\n\t \n\tif (current_state(hdcp) != HDCP_UNINITIALIZED)\n\t\t \n\t\tcallback_in_ms(100, output);\n\nout:\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tpush_error_status(hdcp, status);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_query_display(struct mod_hdcp *hdcp,\n\t\tuint8_t index, struct mod_hdcp_display_query *query)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\tstruct mod_hdcp_display *display = NULL;\n\n\t \n\tdisplay = get_active_display_at_index(hdcp, index);\n\tif (!display) {\n\t\tstatus = MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\t \n\tquery->link = &hdcp->connection.link;\n\tquery->display = display;\n\tquery->trace = &hdcp->connection.trace;\n\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\n\tif (is_display_encryption_enabled(display)) {\n\t\tif (is_hdcp1(hdcp)) {\n\t\t\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP1_ON;\n\t\t} else if (is_hdcp2(hdcp)) {\n\t\t\tif (query->link->adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_0)\n\t\t\t\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP2_TYPE0_ON;\n\t\t\telse if (query->link->adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_1)\n\t\t\t\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP2_TYPE1_ON;\n\t\t\telse\n\t\t\t\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP2_ON;\n\t\t}\n\t} else {\n\t\tquery->encryption_status = MOD_HDCP_ENCRYPTION_STATUS_HDCP_OFF;\n\t}\n\nout:\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_reset_connection(struct mod_hdcp *hdcp,\n\t\tstruct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tHDCP_TOP_INTERFACE_TRACE(hdcp);\n\tstatus = reset_connection(hdcp, output);\n\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\tpush_error_status(hdcp, status);\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_process_event(struct mod_hdcp *hdcp,\n\t\tenum mod_hdcp_event event, struct mod_hdcp_output *output)\n{\n\tenum mod_hdcp_status exec_status, trans_status, reset_status, status;\n\tstruct mod_hdcp_event_context event_ctx;\n\n\tHDCP_EVENT_TRACE(hdcp, event);\n\tmemset(output, 0, sizeof(struct mod_hdcp_output));\n\tmemset(&event_ctx, 0, sizeof(struct mod_hdcp_event_context));\n\tevent_ctx.event = event;\n\n\t \n\texec_status = execution(hdcp, &event_ctx, &hdcp->auth.trans_input);\n\ttrans_status = transition(\n\t\t\thdcp, &event_ctx, &hdcp->auth.trans_input, output);\n\tif (trans_status == MOD_HDCP_STATUS_SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t} else if (exec_status == MOD_HDCP_STATUS_SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_INTERNAL_POLICY_FAILURE;\n\t\tpush_error_status(hdcp, status);\n\t} else {\n\t\tstatus = exec_status;\n\t\tpush_error_status(hdcp, status);\n\t}\n\n\t \n\tif (trans_status == MOD_HDCP_STATUS_RESET_NEEDED) {\n\t\tmod_hdcp_log_ddc_trace(hdcp);\n\t\treset_status = reset_authentication(hdcp, output);\n\t\tif (reset_status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tpush_error_status(hdcp, reset_status);\n\t}\n\n\t \n\tif (event_ctx.event == MOD_HDCP_EVENT_CPIRQ) {\n\t\tstatus = mod_hdcp_clear_cp_irq_status(hdcp);\n\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tpush_error_status(hdcp, status);\n\t}\n\n\treturn status;\n}\n\nenum mod_hdcp_operation_mode mod_hdcp_signal_type_to_operation_mode(\n\t\tenum signal_type signal)\n{\n\tenum mod_hdcp_operation_mode mode = MOD_HDCP_MODE_OFF;\n\n\tswitch (signal) {\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tmode = MOD_HDCP_MODE_DEFAULT;\n\t\tbreak;\n\tcase SIGNAL_TYPE_EDP:\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tmode = MOD_HDCP_MODE_DP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}