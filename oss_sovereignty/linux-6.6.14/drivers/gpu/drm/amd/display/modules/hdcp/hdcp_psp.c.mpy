{
  "module_name": "hdcp_psp.c",
  "hash_id": "04639489b51ca415783b3a03c360a57820a0c6505eb57dcfae912d1295ca5a24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c",
  "human_readable_source": " \n\n#define MAX_NUM_DISPLAYS 24\n\n\n#include \"hdcp.h\"\n\n#include \"amdgpu.h\"\n#include \"hdcp_psp.h\"\n\nstatic void hdcp2_message_init(struct mod_hdcp *hdcp,\n\t\t\t       struct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *in)\n{\n\tin->session_handle = hdcp->auth.id;\n\tin->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__NULL_MESSAGE;\n\tin->prepare.msg2_id = TA_HDCP_HDCP2_MSG_ID__NULL_MESSAGE;\n\tin->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__NULL_MESSAGE;\n\tin->process.msg1_desc.msg_size = 0;\n\tin->process.msg2_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__NULL_MESSAGE;\n\tin->process.msg2_desc.msg_size = 0;\n\tin->process.msg3_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__NULL_MESSAGE;\n\tin->process.msg3_desc.msg_size = 0;\n}\n\nstatic enum mod_hdcp_status remove_display_from_topology_v2(\n\t\tstruct mod_hdcp *hdcp, uint8_t index)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_dtm_shared_memory *dtm_cmd;\n\tstruct mod_hdcp_display *display =\n\t\t\tget_active_display_at_index(hdcp, index);\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tdtm_cmd = (struct ta_dtm_shared_memory *)psp->dtm_context.context.mem_context.shared_buf;\n\n\tif (!display || !is_display_active(display))\n\t\treturn MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\n\tmutex_lock(&psp->dtm_context.mutex);\n\n\tmemset(dtm_cmd, 0, sizeof(struct ta_dtm_shared_memory));\n\n\tdtm_cmd->cmd_id = TA_DTM_COMMAND__TOPOLOGY_UPDATE_V2;\n\tdtm_cmd->dtm_in_message.topology_update_v2.display_handle = display->index;\n\tdtm_cmd->dtm_in_message.topology_update_v2.is_active = 0;\n\tdtm_cmd->dtm_status = TA_DTM_STATUS__GENERIC_FAILURE;\n\n\tpsp_dtm_invoke(psp, dtm_cmd->cmd_id);\n\n\tif (dtm_cmd->dtm_status != TA_DTM_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_UPDATE_TOPOLOGY_FAILURE;\n\t} else {\n\t\tdisplay->state = MOD_HDCP_DISPLAY_ACTIVE;\n\t\tHDCP_TOP_REMOVE_DISPLAY_TRACE(hdcp, display->index);\n\t}\n\n\tmutex_unlock(&psp->dtm_context.mutex);\n\treturn status;\n}\n\nstatic enum mod_hdcp_status remove_display_from_topology_v3(\n\t\tstruct mod_hdcp *hdcp, uint8_t index)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_dtm_shared_memory *dtm_cmd;\n\tstruct mod_hdcp_display *display =\n\t\tget_active_display_at_index(hdcp, index);\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tdtm_cmd = (struct ta_dtm_shared_memory *)psp->dtm_context.context.mem_context.shared_buf;\n\n\tif (!display || !is_display_active(display))\n\t\treturn MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\n\tmutex_lock(&psp->dtm_context.mutex);\n\n\tmemset(dtm_cmd, 0, sizeof(struct ta_dtm_shared_memory));\n\n\tdtm_cmd->cmd_id = TA_DTM_COMMAND__TOPOLOGY_UPDATE_V3;\n\tdtm_cmd->dtm_in_message.topology_update_v3.display_handle = display->index;\n\tdtm_cmd->dtm_in_message.topology_update_v3.is_active = 0;\n\tdtm_cmd->dtm_status = TA_DTM_STATUS__GENERIC_FAILURE;\n\n\tpsp_dtm_invoke(psp, dtm_cmd->cmd_id);\n\tmutex_unlock(&psp->dtm_context.mutex);\n\n\tif (dtm_cmd->dtm_status != TA_DTM_STATUS__SUCCESS) {\n\t\tstatus = remove_display_from_topology_v2(hdcp, index);\n\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tdisplay->state = MOD_HDCP_DISPLAY_INACTIVE;\n\t} else {\n\t\tdisplay->state = MOD_HDCP_DISPLAY_ACTIVE;\n\t\tHDCP_TOP_REMOVE_DISPLAY_TRACE(hdcp, display->index);\n\t}\n\n\treturn status;\n}\n\nstatic enum mod_hdcp_status add_display_to_topology_v2(\n\t\tstruct mod_hdcp *hdcp, struct mod_hdcp_display *display)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_dtm_shared_memory *dtm_cmd;\n\tstruct mod_hdcp_link *link = &hdcp->connection.link;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (!psp->dtm_context.context.initialized) {\n\t\tDRM_INFO(\"Failed to add display topology, DTM TA is not initialized.\");\n\t\tdisplay->state = MOD_HDCP_DISPLAY_INACTIVE;\n\t\treturn MOD_HDCP_STATUS_FAILURE;\n\t}\n\n\tdtm_cmd = (struct ta_dtm_shared_memory *)psp->dtm_context.context.mem_context.shared_buf;\n\n\tmutex_lock(&psp->dtm_context.mutex);\n\tmemset(dtm_cmd, 0, sizeof(struct ta_dtm_shared_memory));\n\n\tdtm_cmd->cmd_id = TA_DTM_COMMAND__TOPOLOGY_UPDATE_V2;\n\tdtm_cmd->dtm_in_message.topology_update_v2.display_handle = display->index;\n\tdtm_cmd->dtm_in_message.topology_update_v2.is_active = 1;\n\tdtm_cmd->dtm_in_message.topology_update_v2.controller = display->controller;\n\tdtm_cmd->dtm_in_message.topology_update_v2.ddc_line = link->ddc_line;\n\tdtm_cmd->dtm_in_message.topology_update_v2.dig_be = link->dig_be;\n\tdtm_cmd->dtm_in_message.topology_update_v2.dig_fe = display->dig_fe;\n\tif (is_dp_hdcp(hdcp))\n\t\tdtm_cmd->dtm_in_message.topology_update_v2.is_assr = link->dp.assr_enabled;\n\n\tdtm_cmd->dtm_in_message.topology_update_v2.dp_mst_vcid = display->vc_id;\n\tdtm_cmd->dtm_in_message.topology_update_v2.max_hdcp_supported_version =\n\t\t\tTA_DTM_HDCP_VERSION_MAX_SUPPORTED__2_2;\n\tdtm_cmd->dtm_status = TA_DTM_STATUS__GENERIC_FAILURE;\n\n\tpsp_dtm_invoke(psp, dtm_cmd->cmd_id);\n\n\tif (dtm_cmd->dtm_status != TA_DTM_STATUS__SUCCESS) {\n\t\tdisplay->state = MOD_HDCP_DISPLAY_INACTIVE;\n\t\tstatus = MOD_HDCP_STATUS_UPDATE_TOPOLOGY_FAILURE;\n\t} else {\n\t\tHDCP_TOP_ADD_DISPLAY_TRACE(hdcp, display->index);\n\t}\n\n\tmutex_unlock(&psp->dtm_context.mutex);\n\treturn status;\n}\n\nstatic enum mod_hdcp_status add_display_to_topology_v3(\n\t\tstruct mod_hdcp *hdcp, struct mod_hdcp_display *display)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_dtm_shared_memory *dtm_cmd;\n\tstruct mod_hdcp_link *link = &hdcp->connection.link;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (!psp->dtm_context.context.initialized) {\n\t\tDRM_INFO(\"Failed to add display topology, DTM TA is not initialized.\");\n\t\tdisplay->state = MOD_HDCP_DISPLAY_INACTIVE;\n\t\treturn MOD_HDCP_STATUS_FAILURE;\n\t}\n\n\tdtm_cmd = (struct ta_dtm_shared_memory *)psp->dtm_context.context.mem_context.shared_buf;\n\n\tmutex_lock(&psp->dtm_context.mutex);\n\tmemset(dtm_cmd, 0, sizeof(struct ta_dtm_shared_memory));\n\n\tdtm_cmd->cmd_id = TA_DTM_COMMAND__TOPOLOGY_UPDATE_V3;\n\tdtm_cmd->dtm_in_message.topology_update_v3.display_handle = display->index;\n\tdtm_cmd->dtm_in_message.topology_update_v3.is_active = 1;\n\tdtm_cmd->dtm_in_message.topology_update_v3.controller = display->controller;\n\tdtm_cmd->dtm_in_message.topology_update_v3.ddc_line = link->ddc_line;\n\tdtm_cmd->dtm_in_message.topology_update_v3.link_enc = link->link_enc_idx;\n\tdtm_cmd->dtm_in_message.topology_update_v3.stream_enc = display->stream_enc_idx;\n\tif (is_dp_hdcp(hdcp))\n\t\tdtm_cmd->dtm_in_message.topology_update_v3.is_assr = link->dp.assr_enabled;\n\n\tdtm_cmd->dtm_in_message.topology_update_v3.dp_mst_vcid = display->vc_id;\n\tdtm_cmd->dtm_in_message.topology_update_v3.max_hdcp_supported_version =\n\t\t\tTA_DTM_HDCP_VERSION_MAX_SUPPORTED__2_3;\n\tdtm_cmd->dtm_in_message.topology_update_v3.encoder_type = TA_DTM_ENCODER_TYPE__DIG;\n\tdtm_cmd->dtm_status = TA_DTM_STATUS__GENERIC_FAILURE;\n\tdtm_cmd->dtm_in_message.topology_update_v3.phy_id = link->phy_idx;\n\tdtm_cmd->dtm_in_message.topology_update_v3.link_hdcp_cap = link->hdcp_supported_informational;\n\tdtm_cmd->dtm_in_message.topology_update_v3.dio_output_type = link->dp.usb4_enabled ?\n\t\t\tTA_DTM_DIO_OUTPUT_TYPE__DPIA :\n\t\t\tTA_DTM_DIO_OUTPUT_TYPE__DIRECT;\n\tdtm_cmd->dtm_in_message.topology_update_v3.dio_output_id = link->dio_output_id;\n\n\tpsp_dtm_invoke(psp, dtm_cmd->cmd_id);\n\tmutex_unlock(&psp->dtm_context.mutex);\n\n\tif (dtm_cmd->dtm_status != TA_DTM_STATUS__SUCCESS) {\n\t\tstatus = add_display_to_topology_v2(hdcp, display);\n\t\tif (status != MOD_HDCP_STATUS_SUCCESS)\n\t\t\tdisplay->state = MOD_HDCP_DISPLAY_INACTIVE;\n\t} else {\n\t\tHDCP_TOP_ADD_DISPLAY_TRACE(hdcp, display->index);\n\t}\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_remove_display_from_topology(\n\t\tstruct mod_hdcp *hdcp, uint8_t index)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_UPDATE_TOPOLOGY_FAILURE;\n\n\tif (hdcp->config.psp.caps.dtm_v3_supported)\n\t\tstatus = remove_display_from_topology_v3(hdcp, index);\n\telse\n\t\tstatus = remove_display_from_topology_v2(hdcp, index);\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_add_display_to_topology(struct mod_hdcp *hdcp,\n\t\t\t\t\t       struct mod_hdcp_display *display)\n{\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (hdcp->config.psp.caps.dtm_v3_supported)\n\t\tstatus = add_display_to_topology_v3(hdcp, display);\n\telse\n\t\tstatus = add_display_to_topology_v2(hdcp, display);\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_create_session(struct mod_hdcp *hdcp)\n{\n\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct mod_hdcp_display *display = get_first_active_display(hdcp);\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (!psp->hdcp_context.context.initialized) {\n\t\tDRM_ERROR(\"Failed to create hdcp session. HDCP TA is not initialized.\");\n\t\treturn MOD_HDCP_STATUS_FAILURE;\n\t}\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_create_session.display_handle = display->index;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_CREATE_SESSION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\thdcp->auth.id = hdcp_cmd->out_msg.hdcp1_create_session.session_handle;\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_CREATE_SESSION_FAILURE;\n\t} else {\n\t\thdcp->auth.msg.hdcp1.ainfo = hdcp_cmd->out_msg.hdcp1_create_session.ainfo_primary;\n\t\tmemcpy(hdcp->auth.msg.hdcp1.aksv, hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.aksv));\n\t\tmemcpy(hdcp->auth.msg.hdcp1.an, hdcp_cmd->out_msg.hdcp1_create_session.an_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.an));\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_destroy_session(struct mod_hdcp *hdcp)\n{\n\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tuint8_t i = 0;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_destroy_session.session_handle = hdcp->auth.id;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_DESTROY_SESSION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_DESTROY_SESSION_FAILURE;\n\t} else {\n\t\tHDCP_TOP_HDCP1_DESTROY_SESSION_TRACE(hdcp);\n\t\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\t\tif (is_display_encryption_enabled(&hdcp->displays[i])) {\n\t\t\t\thdcp->displays[i].state =\n\t\t\t\t\t\t\tMOD_HDCP_DISPLAY_ACTIVE;\n\t\t\t\tHDCP_HDCP1_DISABLED_TRACE(\n\t\t\t\t\thdcp, hdcp->displays[i].index);\n\t\t\t}\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_validate_rx(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_first_part_authentication.session_handle = hdcp->auth.id;\n\n\tmemcpy(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, hdcp->auth.msg.hdcp1.bksv,\n\t\tTA_HDCP__HDCP1_KSV_SIZE);\n\n\thdcp_cmd->in_msg.hdcp1_first_part_authentication.r0_prime_primary = hdcp->auth.msg.hdcp1.r0p;\n\thdcp_cmd->in_msg.hdcp1_first_part_authentication.bcaps = hdcp->auth.msg.hdcp1.bcaps;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_FIRST_PART_AUTHENTICATION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_VALIDATE_RX_FAILURE;\n\t} else if (hdcp_cmd->out_msg.hdcp1_first_part_authentication.authentication_status ==\n\t    TA_HDCP_AUTHENTICATION_STATUS__HDCP1_FIRST_PART_COMPLETE) {\n\t\t \n\t\thdcp->connection.is_repeater = 1;\n\t} else if (hdcp_cmd->out_msg.hdcp1_first_part_authentication.authentication_status ==\n\t\t   TA_HDCP_AUTHENTICATION_STATUS__HDCP1_AUTHENTICATED) {\n\t\thdcp->connection.is_repeater = 0;\n\t} else if (hdcp_cmd->out_msg.hdcp1_first_part_authentication.authentication_status ==\n\t\t   TA_HDCP_AUTHENTICATION_STATUS__HDCP1_KSV_REVOKED) {\n\t\thdcp->connection.is_hdcp1_revoked = 1;\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_BKSV_REVOKED;\n\t} else\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_VALIDATE_RX_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_enable_encryption(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct mod_hdcp_display *display = get_first_active_display(hdcp);\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_enable_encryption.session_handle = hdcp->auth.id;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_ENABLE_ENCRYPTION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_ENABLE_ENCRYPTION_FAILURE;\n\t} else if (!is_dp_mst_hdcp(hdcp)) {\n\t\tdisplay->state = MOD_HDCP_DISPLAY_ENCRYPTION_ENABLED;\n\t\tHDCP_HDCP1_ENABLED_TRACE(hdcp, display->index);\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_validate_ksvlist_vp(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_second_part_authentication.session_handle = hdcp->auth.id;\n\n\thdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list_size = hdcp->auth.msg.hdcp1.ksvlist_size;\n\tmemcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, hdcp->auth.msg.hdcp1.ksvlist,\n\t       hdcp->auth.msg.hdcp1.ksvlist_size);\n\n\tmemcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, hdcp->auth.msg.hdcp1.vp,\n\t       sizeof(hdcp->auth.msg.hdcp1.vp));\n\n\thdcp_cmd->in_msg.hdcp1_second_part_authentication.bstatus_binfo =\n\t\tis_dp_hdcp(hdcp) ? hdcp->auth.msg.hdcp1.binfo_dp : hdcp->auth.msg.hdcp1.bstatus;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_SECOND_PART_AUTHENTICATION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status == TA_HDCP_STATUS__SUCCESS &&\n\t    hdcp_cmd->out_msg.hdcp1_second_part_authentication.authentication_status ==\n\t\t    TA_HDCP_AUTHENTICATION_STATUS__HDCP1_AUTHENTICATED) {\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t} else if (hdcp_cmd->out_msg.hdcp1_second_part_authentication.authentication_status ==\n\t\t   TA_HDCP_AUTHENTICATION_STATUS__HDCP1_KSV_REVOKED) {\n\t\thdcp->connection.is_hdcp1_revoked = 1;\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_KSV_LIST_REVOKED;\n\t} else {\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_VALIDATE_KSV_LIST_FAILURE;\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_enable_dp_stream_encryption(struct mod_hdcp *hdcp)\n{\n\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tint i = 0;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++) {\n\n\t\tif (hdcp->displays[i].adjust.disable || hdcp->displays[i].state != MOD_HDCP_DISPLAY_ACTIVE)\n\t\t\t\tcontinue;\n\n\t\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\t\thdcp_cmd->in_msg.hdcp1_enable_dp_stream_encryption.session_handle = hdcp->auth.id;\n\t\thdcp_cmd->in_msg.hdcp1_enable_dp_stream_encryption.display_handle = hdcp->displays[i].index;\n\t\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_ENABLE_DP_STREAM_ENCRYPTION;\n\n\t\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\t\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\t\tstatus = MOD_HDCP_STATUS_HDCP1_ENABLE_STREAM_ENCRYPTION_FAILURE;\n\t\t\tbreak;\n\t\t}\n\n\t\thdcp->displays[i].state = MOD_HDCP_DISPLAY_ENCRYPTION_ENABLED;\n\t\tHDCP_HDCP1_ENABLED_TRACE(hdcp, hdcp->displays[i].index);\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp1_link_maintenance(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp1_get_encryption_status.session_handle = hdcp->auth.id;\n\n\thdcp_cmd->out_msg.hdcp1_get_encryption_status.protection_level = 0;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP1_GET_ENCRYPTION_STATUS;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS ||\n\t\t\thdcp_cmd->out_msg.hdcp1_get_encryption_status.protection_level != 1)\n\t\tstatus = MOD_HDCP_STATUS_HDCP1_LINK_MAINTENANCE_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_create_session(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct mod_hdcp_display *display = get_first_active_display(hdcp);\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\n\tif (!psp->hdcp_context.context.initialized) {\n\t\tDRM_ERROR(\"Failed to create hdcp session, HDCP TA is not initialized\");\n\t\treturn MOD_HDCP_STATUS_FAILURE;\n\t}\n\n\tif (!display)\n\t\treturn MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp2_create_session_v2.display_handle = display->index;\n\n\tif (hdcp->connection.link.adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_0)\n\t\thdcp_cmd->in_msg.hdcp2_create_session_v2.negotiate_content_type =\n\t\t\tTA_HDCP2_CONTENT_TYPE_NEGOTIATION_TYPE__FORCE_TYPE0;\n\telse if (hdcp->connection.link.adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_1)\n\t\thdcp_cmd->in_msg.hdcp2_create_session_v2.negotiate_content_type =\n\t\t\tTA_HDCP2_CONTENT_TYPE_NEGOTIATION_TYPE__FORCE_TYPE1;\n\telse if (hdcp->connection.link.adjust.hdcp2.force_type == MOD_HDCP_FORCE_TYPE_MAX)\n\t\thdcp_cmd->in_msg.hdcp2_create_session_v2.negotiate_content_type =\n\t\t\tTA_HDCP2_CONTENT_TYPE_NEGOTIATION_TYPE__MAX_SUPPORTED;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_CREATE_SESSION_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_CREATE_SESSION_FAILURE;\n\telse\n\t\thdcp->auth.id = hdcp_cmd->out_msg.hdcp2_create_session_v2.session_handle;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_destroy_session(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tuint8_t i = 0;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp2_destroy_session.session_handle = hdcp->auth.id;\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_DESTROY_SESSION;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_DESTROY_SESSION_FAILURE;\n\t} else {\n\t\tHDCP_TOP_HDCP2_DESTROY_SESSION_TRACE(hdcp);\n\t\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++)\n\t\t\tif (is_display_encryption_enabled(&hdcp->displays[i])) {\n\t\t\t\thdcp->displays[i].state =\n\t\t\t\t\t\t\tMOD_HDCP_DISPLAY_ACTIVE;\n\t\t\t\tHDCP_HDCP2_DISABLED_TRACE(\n\t\t\t\t\thdcp, hdcp->displays[i].index);\n\t\t\t}\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_ake_init(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__AKE_INIT;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_PREP_AKE_INIT_FAILURE;\n\telse\n\t\tmemcpy(&hdcp->auth.msg.hdcp2.ake_init[0], &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_init));\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_ake_cert(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__AKE_SEND_CERT;\n\tmsg_in->process.msg1_desc.msg_size = TA_HDCP_HDCP2_MSG_ID_MAX_SIZE__AKE_SEND_CERT;\n\n\tmemcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_cert,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_cert));\n\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__AKE_NO_STORED_KM;\n\tmsg_in->prepare.msg2_id = TA_HDCP_HDCP2_MSG_ID__AKE_STORED_KM;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_AKE_CERT_FAILURE;\n\t} else {\n\t\tmemcpy(hdcp->auth.msg.hdcp2.ake_no_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km));\n\n\t\tmemcpy(hdcp->auth.msg.hdcp2.ake_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_stored_km));\n\n\t\tif (msg_out->process.msg1_status ==\n\t\t    TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS) {\n\t\t\thdcp->connection.is_km_stored =\n\t\t\t\tmsg_out->process.is_km_stored ? 1 : 0;\n\t\t\thdcp->connection.is_repeater =\n\t\t\t\tmsg_out->process.is_repeater ? 1 : 0;\n\t\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\t} else if (msg_out->process.msg1_status ==\n\t\t\t   TA_HDCP2_MSG_AUTHENTICATION_STATUS__RECEIVERID_REVOKED) {\n\t\t\thdcp->connection.is_hdcp2_revoked = 1;\n\t\t\tstatus = MOD_HDCP_STATUS_HDCP2_AKE_CERT_REVOKED;\n\t\t}  else {\n\t\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_AKE_CERT_FAILURE;\n\t\t}\n\t}\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_h_prime(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__AKE_SEND_H_PRIME;\n\tmsg_in->process.msg1_desc.msg_size = TA_HDCP_HDCP2_MSG_ID_MAX_SIZE__AKE_SEND_H_PRIME;\n\n\tmemcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_h_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_h_prime));\n\n\tif (!hdcp->connection.is_km_stored) {\n\t\tmsg_in->process.msg2_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__AKE_SEND_PAIRING_INFO;\n\t\tmsg_in->process.msg2_desc.msg_size = TA_HDCP_HDCP2_MSG_ID_MAX_SIZE__AKE_SEND_PAIRING_INFO;\n\t\tmemcpy(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)],\n\t\t       hdcp->auth.msg.hdcp2.ake_pairing_info, sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info));\n\t}\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_H_PRIME_FAILURE;\n\telse if (msg_out->process.msg1_status != TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_H_PRIME_FAILURE;\n\telse if (!hdcp->connection.is_km_stored &&\n\t\t   msg_out->process.msg2_status != TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_PAIRING_INFO_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_lc_init(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__LC_INIT;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_PREP_LC_INIT_FAILURE;\n\telse\n\t\tmemcpy(hdcp->auth.msg.hdcp2.lc_init, &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.lc_init));\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_l_prime(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__LC_SEND_L_PRIME;\n\tmsg_in->process.msg1_desc.msg_size = TA_HDCP_HDCP2_MSG_ID_MAX_SIZE__LC_SEND_L_PRIME;\n\n\tmemcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.lc_l_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.lc_l_prime));\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS ||\n\t\t\tmsg_out->process.msg1_status != TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_L_PRIME_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_eks(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__SKE_SEND_EKS;\n\n\tif (is_dp_hdcp(hdcp))\n\t\tmsg_in->prepare.msg2_id = TA_HDCP_HDCP2_MSG_ID__SIGNAL_CONTENT_STREAM_TYPE_DP;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_PREP_EKS_FAILURE;\n\t} else {\n\t\tmemcpy(hdcp->auth.msg.hdcp2.ske_eks,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ske_eks));\n\t\tmsg_out->prepare.msg1_desc.msg_size =\n\t\t\tsizeof(hdcp->auth.msg.hdcp2.ske_eks);\n\n\t\tif (is_dp_hdcp(hdcp)) {\n\t\t\tmemcpy(hdcp->auth.msg.hdcp2.content_stream_type_dp,\n\t\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)],\n\t\t\t       sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp));\n\t\t}\n\t}\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_enable_encryption(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct mod_hdcp_display *display = get_first_active_display(hdcp);\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tif (!display)\n\t\treturn MOD_HDCP_STATUS_DISPLAY_NOT_FOUND;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\thdcp_cmd->in_msg.hdcp2_set_encryption.session_handle = hdcp->auth.id;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_SET_ENCRYPTION;\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_ENABLE_ENCRYPTION_FAILURE;\n\t} else if (!is_dp_mst_hdcp(hdcp)) {\n\t\tdisplay->state = MOD_HDCP_DISPLAY_ENCRYPTION_ENABLED;\n\t\tHDCP_HDCP2_ENABLED_TRACE(hdcp, display->index);\n\t}\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_rx_id_list(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__REPEATERAUTH_SEND_RECEIVERID_LIST;\n\tmsg_in->process.msg1_desc.msg_size = sizeof(hdcp->auth.msg.hdcp2.rx_id_list);\n\tmemcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.rx_id_list,\n\t       sizeof(hdcp->auth.msg.hdcp2.rx_id_list));\n\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__REPEATERAUTH_SEND_ACK;\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_RX_ID_LIST_FAILURE;\n\t} else {\n\t\tmemcpy(hdcp->auth.msg.hdcp2.repeater_auth_ack,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack));\n\n\t\tif (msg_out->process.msg1_status ==\n\t\t    TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS) {\n\t\t\thdcp->connection.is_km_stored = msg_out->process.is_km_stored ? 1 : 0;\n\t\t\thdcp->connection.is_repeater = msg_out->process.is_repeater ? 1 : 0;\n\t\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\t\t} else if (msg_out->process.msg1_status ==\n\t\t\t   TA_HDCP2_MSG_AUTHENTICATION_STATUS__RECEIVERID_REVOKED) {\n\t\t\thdcp->connection.is_hdcp2_revoked = 1;\n\t\t\tstatus = MOD_HDCP_STATUS_HDCP2_RX_ID_LIST_REVOKED;\n\t\t} else {\n\t\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_RX_ID_LIST_FAILURE;\n\t\t}\n\t}\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_enable_dp_stream_encryption(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tuint8_t i;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\n\tfor (i = 0; i < MAX_NUM_OF_DISPLAYS; i++) {\n\t\tif (hdcp->displays[i].adjust.disable || hdcp->displays[i].state != MOD_HDCP_DISPLAY_ACTIVE)\n\t\t\t\tcontinue;\n\n\t\thdcp_cmd->in_msg.hdcp2_enable_dp_stream_encryption.display_handle = hdcp->displays[i].index;\n\t\thdcp_cmd->in_msg.hdcp2_enable_dp_stream_encryption.session_handle = hdcp->auth.id;\n\n\t\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_ENABLE_DP_STREAM_ENCRYPTION;\n\t\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\t\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS)\n\t\t\tbreak;\n\n\t\thdcp->displays[i].state = MOD_HDCP_DISPLAY_ENCRYPTION_ENABLED;\n\t\tHDCP_HDCP2_ENABLED_TRACE(hdcp, hdcp->displays[i].index);\n\t}\n\n\tif (hdcp_cmd->hdcp_status == TA_HDCP_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\telse\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_ENABLE_STREAM_ENCRYPTION_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_prepare_stream_management(struct mod_hdcp *hdcp)\n{\n\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->prepare.msg1_id = TA_HDCP_HDCP2_MSG_ID__REPEATERAUTH_STREAM_MANAGE;\n\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status != TA_HDCP_STATUS__SUCCESS) {\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_PREPARE_STREAM_MANAGEMENT_FAILURE;\n\t} else {\n\t\thdcp->auth.msg.hdcp2.stream_manage_size = msg_out->prepare.msg1_desc.msg_size;\n\n\t\tmemcpy(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage));\n\t}\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n\nenum mod_hdcp_status mod_hdcp_hdcp2_validate_stream_ready(struct mod_hdcp *hdcp)\n{\n\tstruct psp_context *psp = hdcp->config.psp.handle;\n\tstruct ta_hdcp_shared_memory *hdcp_cmd;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_input_v2 *msg_in;\n\tstruct ta_hdcp_cmd_hdcp2_process_prepare_authentication_message_output_v2 *msg_out;\n\tenum mod_hdcp_status status = MOD_HDCP_STATUS_SUCCESS;\n\n\tmutex_lock(&psp->hdcp_context.mutex);\n\thdcp_cmd = (struct ta_hdcp_shared_memory *)psp->hdcp_context.context.mem_context.shared_buf;\n\tmemset(hdcp_cmd, 0, sizeof(struct ta_hdcp_shared_memory));\n\n\tmsg_in = &hdcp_cmd->in_msg.hdcp2_prepare_process_authentication_message_v2;\n\tmsg_out = &hdcp_cmd->out_msg.hdcp2_prepare_process_authentication_message_v2;\n\n\thdcp2_message_init(hdcp, msg_in);\n\n\tmsg_in->process.msg1_desc.msg_id = TA_HDCP_HDCP2_MSG_ID__REPEATERAUTH_STREAM_READY;\n\n\tmsg_in->process.msg1_desc.msg_size = sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready);\n\n\tmemcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.repeater_auth_stream_ready,\n\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready));\n\n\thdcp_cmd->cmd_id = TA_HDCP_COMMAND__HDCP2_PREPARE_PROCESS_AUTHENTICATION_MSG_V2;\n\tpsp_hdcp_invoke(psp, hdcp_cmd->cmd_id);\n\n\tif (hdcp_cmd->hdcp_status == TA_HDCP_STATUS__SUCCESS &&\n\t    msg_out->process.msg1_status == TA_HDCP2_MSG_AUTHENTICATION_STATUS__SUCCESS)\n\t\tstatus = MOD_HDCP_STATUS_SUCCESS;\n\telse\n\t\tstatus = MOD_HDCP_STATUS_HDCP2_VALIDATE_STREAM_READY_FAILURE;\n\n\tmutex_unlock(&psp->hdcp_context.mutex);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}