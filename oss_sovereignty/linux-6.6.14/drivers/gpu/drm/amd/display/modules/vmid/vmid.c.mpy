{
  "module_name": "vmid.c",
  "hash_id": "75a53d2c91a7ffe0a740f3c4ce0944d42f1178f1ff435a017e20dc47808cba9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/modules/vmid/vmid.c",
  "human_readable_source": " \n\n#include \"mod_vmid.h\"\n\nstruct core_vmid {\n\tstruct mod_vmid public;\n\tstruct dc *dc;\n\n\tunsigned int num_vmid;\n\tunsigned int num_vmids_available;\n\tuint64_t ptb_assigned_to_vmid[MAX_VMID];\n\tstruct dc_virtual_addr_space_config base_config;\n};\n\n#define MOD_VMID_TO_CORE(mod_vmid)\\\n\t\tcontainer_of(mod_vmid, struct core_vmid, public)\n\nstatic void add_ptb_to_table(struct core_vmid *core_vmid, unsigned int vmid, uint64_t ptb)\n{\n\tif (vmid < MAX_VMID) {\n\t\tcore_vmid->ptb_assigned_to_vmid[vmid] = ptb;\n\t\tcore_vmid->num_vmids_available--;\n\t}\n}\n\nstatic void clear_entry_from_vmid_table(struct core_vmid *core_vmid, unsigned int vmid)\n{\n\tif (vmid < MAX_VMID) {\n\t\tcore_vmid->ptb_assigned_to_vmid[vmid] = 0;\n\t\tcore_vmid->num_vmids_available++;\n\t}\n}\n\nstatic void evict_vmids(struct core_vmid *core_vmid)\n{\n\tint i;\n\tuint16_t ord = dc_get_vmid_use_vector(core_vmid->dc);\n\n\t\n\tfor (i = 1; i < core_vmid->num_vmid; i++) {\n\t\tif (!(ord & (1u << i)))\n\t\t\tclear_entry_from_vmid_table(core_vmid, i);\n\t}\n}\n\n\nstatic int get_existing_vmid_for_ptb(struct core_vmid *core_vmid, uint64_t ptb)\n{\n\tint i;\n\n\tfor (i = 0; i < core_vmid->num_vmid; i++) {\n\t\tif (core_vmid->ptb_assigned_to_vmid[i] == ptb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n\nstatic int get_next_available_vmid(struct core_vmid *core_vmid)\n{\n\tint i;\n\n\tfor (i = 1; i < core_vmid->num_vmid; i++) {\n\t\tif (core_vmid->ptb_assigned_to_vmid[i] == 0)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nuint8_t mod_vmid_get_for_ptb(struct mod_vmid *mod_vmid, uint64_t ptb)\n{\n\tstruct core_vmid *core_vmid = MOD_VMID_TO_CORE(mod_vmid);\n\tint vmid = 0;\n\n\t\n\tif (ptb == 0)\n\t\treturn 0;\n\n\tvmid = get_existing_vmid_for_ptb(core_vmid, ptb);\n\n\tif (vmid == -1) {\n\t\tstruct dc_virtual_addr_space_config va_config = core_vmid->base_config;\n\n\t\tva_config.page_table_base_addr = ptb;\n\n\t\tif (core_vmid->num_vmids_available == 0)\n\t\t\tevict_vmids(core_vmid);\n\n\t\tvmid = get_next_available_vmid(core_vmid);\n\t\tif (vmid != -1) {\n\t\t\tadd_ptb_to_table(core_vmid, vmid, ptb);\n\n\t\t\tdc_setup_vm_context(core_vmid->dc, &va_config, vmid);\n\t\t} else\n\t\t\tASSERT(0);\n\t}\n\n\treturn vmid;\n}\n\nvoid mod_vmid_reset(struct mod_vmid *mod_vmid)\n{\n\tstruct core_vmid *core_vmid = MOD_VMID_TO_CORE(mod_vmid);\n\n\tcore_vmid->num_vmids_available = core_vmid->num_vmid - 1;\n\tmemset(core_vmid->ptb_assigned_to_vmid, 0, sizeof(core_vmid->ptb_assigned_to_vmid[0]) * MAX_VMID);\n}\n\nstruct mod_vmid *mod_vmid_create(\n\t\tstruct dc *dc,\n\t\tunsigned int num_vmid,\n\t\tstruct dc_virtual_addr_space_config *va_config)\n{\n\tstruct core_vmid *core_vmid;\n\n\tif (num_vmid <= 1)\n\t\tgoto fail_no_vm_ctx;\n\n\tif (dc == NULL)\n\t\tgoto fail_dc_null;\n\n\tcore_vmid = kzalloc(sizeof(struct core_vmid), GFP_KERNEL);\n\n\tif (core_vmid == NULL)\n\t\tgoto fail_alloc_context;\n\n\tcore_vmid->dc = dc;\n\tcore_vmid->num_vmid = num_vmid;\n\tcore_vmid->num_vmids_available = num_vmid - 1;\n\tcore_vmid->base_config = *va_config;\n\n\tmemset(core_vmid->ptb_assigned_to_vmid, 0, sizeof(core_vmid->ptb_assigned_to_vmid[0]) * MAX_VMID);\n\n\treturn &core_vmid->public;\n\nfail_no_vm_ctx:\nfail_alloc_context:\nfail_dc_null:\n\treturn NULL;\n}\n\nvoid mod_vmid_destroy(struct mod_vmid *mod_vmid)\n{\n\tif (mod_vmid != NULL) {\n\t\tstruct core_vmid *core_vmid = MOD_VMID_TO_CORE(mod_vmid);\n\n\t\tkfree(core_vmid);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}