{
  "module_name": "dmub_srv.c",
  "hash_id": "aee8802330ee6eaaabf05a4e6befd6ced8cbeebb36f8c50b993631a7dc84ecdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c",
  "human_readable_source": " \n\n#include \"../dmub_srv.h\"\n#include \"dmub_dcn20.h\"\n#include \"dmub_dcn21.h\"\n#include \"dmub_cmd.h\"\n#include \"dmub_dcn30.h\"\n#include \"dmub_dcn301.h\"\n#include \"dmub_dcn302.h\"\n#include \"dmub_dcn303.h\"\n#include \"dmub_dcn31.h\"\n#include \"dmub_dcn314.h\"\n#include \"dmub_dcn315.h\"\n#include \"dmub_dcn316.h\"\n#include \"dmub_dcn32.h\"\n#include \"os_types.h\"\n \n\n \n#define DMUB_FB_ALIGNMENT (1024 * 1024)\n\n \n#define DMUB_STACK_SIZE (128 * 1024)\n\n \n#define DMUB_CONTEXT_SIZE (512 * 1024)\n\n \n#define DMUB_MAILBOX_SIZE ((2 * DMUB_RB_SIZE))\n\n \n#define DMUB_FW_STATE_SIZE (64 * 1024)\n\n \n#define DMUB_TRACE_BUFFER_SIZE (64 * 1024)\n\n\n \n#define DMUB_SCRATCH_MEM_SIZE (256)\n\n \n#define DMUB_NUM_WINDOWS (DMUB_WINDOW_TOTAL)\n \n\n#define DMUB_CW0_BASE (0x60000000)\n#define DMUB_CW1_BASE (0x61000000)\n#define DMUB_CW3_BASE (0x63000000)\n#define DMUB_CW4_BASE (0x64000000)\n#define DMUB_CW5_BASE (0x65000000)\n#define DMUB_CW6_BASE (0x66000000)\n\n#define DMUB_REGION5_BASE (0xA0000000)\n\nstatic inline uint32_t dmub_align(uint32_t val, uint32_t factor)\n{\n\treturn (val + factor - 1) / factor * factor;\n}\n\nvoid dmub_flush_buffer_mem(const struct dmub_fb *fb)\n{\n\tconst uint8_t *base = (const uint8_t *)fb->cpu_addr;\n\tuint8_t buf[64];\n\tuint32_t pos, end;\n\n\t \n\tend = fb->size / sizeof(buf) * sizeof(buf);\n\n\tfor (pos = 0; pos < end; pos += sizeof(buf))\n\t\tdmub_memcpy(buf, base + pos, sizeof(buf));\n\n\t \n\tif (end < fb->size)\n\t\tdmub_memcpy(buf, base + pos, fb->size - end);\n}\n\nstatic const struct dmub_fw_meta_info *\ndmub_get_fw_meta_info_from_blob(const uint8_t *blob, uint32_t blob_size, uint32_t meta_offset)\n{\n\tconst union dmub_fw_meta *meta;\n\n\tif (!blob || !blob_size)\n\t\treturn NULL;\n\n\tif (blob_size < sizeof(union dmub_fw_meta) + meta_offset)\n\t\treturn NULL;\n\n\tmeta = (const union dmub_fw_meta *)(blob + blob_size - meta_offset -\n\t\t\t\t\t    sizeof(union dmub_fw_meta));\n\n\tif (meta->info.magic_value != DMUB_FW_META_MAGIC)\n\t\treturn NULL;\n\n\treturn &meta->info;\n}\n\nstatic const struct dmub_fw_meta_info *\ndmub_get_fw_meta_info(const struct dmub_srv_region_params *params)\n{\n\tconst struct dmub_fw_meta_info *info = NULL;\n\n\tif (params->fw_bss_data && params->bss_data_size) {\n\t\t \n\t\tinfo = dmub_get_fw_meta_info_from_blob(params->fw_bss_data,\n\t\t\t\t\t\t       params->bss_data_size,\n\t\t\t\t\t\t       DMUB_FW_META_OFFSET);\n\t} else if (params->fw_inst_const && params->inst_const_size) {\n\t\t \n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < 16; ++i) {\n\t\t\tinfo = dmub_get_fw_meta_info_from_blob(\n\t\t\t\tparams->fw_inst_const, params->inst_const_size, i);\n\n\t\t\tif (info)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn info;\n}\n\nstatic bool dmub_srv_hw_setup(struct dmub_srv *dmub, enum dmub_asic asic)\n{\n\tstruct dmub_srv_hw_funcs *funcs = &dmub->hw_funcs;\n\n\tswitch (asic) {\n\tcase DMUB_ASIC_DCN20:\n\tcase DMUB_ASIC_DCN21:\n\tcase DMUB_ASIC_DCN30:\n\tcase DMUB_ASIC_DCN301:\n\tcase DMUB_ASIC_DCN302:\n\tcase DMUB_ASIC_DCN303:\n\t\tdmub->regs = &dmub_srv_dcn20_regs;\n\n\t\tfuncs->reset = dmub_dcn20_reset;\n\t\tfuncs->reset_release = dmub_dcn20_reset_release;\n\t\tfuncs->backdoor_load = dmub_dcn20_backdoor_load;\n\t\tfuncs->setup_windows = dmub_dcn20_setup_windows;\n\t\tfuncs->setup_mailbox = dmub_dcn20_setup_mailbox;\n\t\tfuncs->get_inbox1_wptr = dmub_dcn20_get_inbox1_wptr;\n\t\tfuncs->get_inbox1_rptr = dmub_dcn20_get_inbox1_rptr;\n\t\tfuncs->set_inbox1_wptr = dmub_dcn20_set_inbox1_wptr;\n\t\tfuncs->is_supported = dmub_dcn20_is_supported;\n\t\tfuncs->is_hw_init = dmub_dcn20_is_hw_init;\n\t\tfuncs->set_gpint = dmub_dcn20_set_gpint;\n\t\tfuncs->is_gpint_acked = dmub_dcn20_is_gpint_acked;\n\t\tfuncs->get_gpint_response = dmub_dcn20_get_gpint_response;\n\t\tfuncs->get_fw_status = dmub_dcn20_get_fw_boot_status;\n\t\tfuncs->enable_dmub_boot_options = dmub_dcn20_enable_dmub_boot_options;\n\t\tfuncs->skip_dmub_panel_power_sequence = dmub_dcn20_skip_dmub_panel_power_sequence;\n\t\tfuncs->get_current_time = dmub_dcn20_get_current_time;\n\n\t\t \n\t\tfuncs->setup_out_mailbox = dmub_dcn20_setup_out_mailbox;\n\t\tfuncs->get_outbox1_wptr = dmub_dcn20_get_outbox1_wptr;\n\t\tfuncs->set_outbox1_rptr = dmub_dcn20_set_outbox1_rptr;\n\n\t\t \n\t\tfuncs->setup_outbox0 = dmub_dcn20_setup_outbox0;\n\t\tfuncs->get_outbox0_wptr = dmub_dcn20_get_outbox0_wptr;\n\t\tfuncs->set_outbox0_rptr = dmub_dcn20_set_outbox0_rptr;\n\n\t\tfuncs->get_diagnostic_data = dmub_dcn20_get_diagnostic_data;\n\n\t\tif (asic == DMUB_ASIC_DCN21)\n\t\t\tdmub->regs = &dmub_srv_dcn21_regs;\n\n\t\tif (asic == DMUB_ASIC_DCN30) {\n\t\t\tdmub->regs = &dmub_srv_dcn30_regs;\n\n\t\t\tfuncs->backdoor_load = dmub_dcn30_backdoor_load;\n\t\t\tfuncs->setup_windows = dmub_dcn30_setup_windows;\n\t\t}\n\t\tif (asic == DMUB_ASIC_DCN301) {\n\t\t\tdmub->regs = &dmub_srv_dcn301_regs;\n\n\t\t\tfuncs->backdoor_load = dmub_dcn30_backdoor_load;\n\t\t\tfuncs->setup_windows = dmub_dcn30_setup_windows;\n\t\t}\n\t\tif (asic == DMUB_ASIC_DCN302) {\n\t\t\tdmub->regs = &dmub_srv_dcn302_regs;\n\n\t\t\tfuncs->backdoor_load = dmub_dcn30_backdoor_load;\n\t\t\tfuncs->setup_windows = dmub_dcn30_setup_windows;\n\t\t}\n\t\tif (asic == DMUB_ASIC_DCN303) {\n\t\t\tdmub->regs = &dmub_srv_dcn303_regs;\n\n\t\t\tfuncs->backdoor_load = dmub_dcn30_backdoor_load;\n\t\t\tfuncs->setup_windows = dmub_dcn30_setup_windows;\n\t\t}\n\t\tbreak;\n\n\tcase DMUB_ASIC_DCN31:\n\tcase DMUB_ASIC_DCN31B:\n\tcase DMUB_ASIC_DCN314:\n\tcase DMUB_ASIC_DCN315:\n\tcase DMUB_ASIC_DCN316:\n\t\tif (asic == DMUB_ASIC_DCN314) {\n\t\t\tdmub->regs_dcn31 = &dmub_srv_dcn314_regs;\n\t\t\tfuncs->is_psrsu_supported = dmub_dcn314_is_psrsu_supported;\n\t\t} else if (asic == DMUB_ASIC_DCN315) {\n\t\t\tdmub->regs_dcn31 = &dmub_srv_dcn315_regs;\n\t\t} else if (asic == DMUB_ASIC_DCN316) {\n\t\t\tdmub->regs_dcn31 = &dmub_srv_dcn316_regs;\n\t\t} else {\n\t\t\tdmub->regs_dcn31 = &dmub_srv_dcn31_regs;\n\t\t\tfuncs->is_psrsu_supported = dmub_dcn31_is_psrsu_supported;\n\t\t}\n\t\tfuncs->reset = dmub_dcn31_reset;\n\t\tfuncs->reset_release = dmub_dcn31_reset_release;\n\t\tfuncs->backdoor_load = dmub_dcn31_backdoor_load;\n\t\tfuncs->setup_windows = dmub_dcn31_setup_windows;\n\t\tfuncs->setup_mailbox = dmub_dcn31_setup_mailbox;\n\t\tfuncs->get_inbox1_wptr = dmub_dcn31_get_inbox1_wptr;\n\t\tfuncs->get_inbox1_rptr = dmub_dcn31_get_inbox1_rptr;\n\t\tfuncs->set_inbox1_wptr = dmub_dcn31_set_inbox1_wptr;\n\t\tfuncs->setup_out_mailbox = dmub_dcn31_setup_out_mailbox;\n\t\tfuncs->get_outbox1_wptr = dmub_dcn31_get_outbox1_wptr;\n\t\tfuncs->set_outbox1_rptr = dmub_dcn31_set_outbox1_rptr;\n\t\tfuncs->is_supported = dmub_dcn31_is_supported;\n\t\tfuncs->is_hw_init = dmub_dcn31_is_hw_init;\n\t\tfuncs->set_gpint = dmub_dcn31_set_gpint;\n\t\tfuncs->is_gpint_acked = dmub_dcn31_is_gpint_acked;\n\t\tfuncs->get_gpint_response = dmub_dcn31_get_gpint_response;\n\t\tfuncs->get_gpint_dataout = dmub_dcn31_get_gpint_dataout;\n\t\tfuncs->get_fw_status = dmub_dcn31_get_fw_boot_status;\n\t\tfuncs->get_fw_boot_option = dmub_dcn31_get_fw_boot_option;\n\t\tfuncs->enable_dmub_boot_options = dmub_dcn31_enable_dmub_boot_options;\n\t\tfuncs->skip_dmub_panel_power_sequence = dmub_dcn31_skip_dmub_panel_power_sequence;\n\t\t \n\t\tfuncs->setup_outbox0 = dmub_dcn31_setup_outbox0;\n\t\tfuncs->get_outbox0_wptr = dmub_dcn31_get_outbox0_wptr;\n\t\tfuncs->set_outbox0_rptr = dmub_dcn31_set_outbox0_rptr;\n\n\t\tfuncs->get_diagnostic_data = dmub_dcn31_get_diagnostic_data;\n\t\tfuncs->should_detect = dmub_dcn31_should_detect;\n\t\tfuncs->get_current_time = dmub_dcn31_get_current_time;\n\n\t\tbreak;\n\n\tcase DMUB_ASIC_DCN32:\n\tcase DMUB_ASIC_DCN321:\n\t\tdmub->regs_dcn32 = &dmub_srv_dcn32_regs;\n\t\tfuncs->configure_dmub_in_system_memory = dmub_dcn32_configure_dmub_in_system_memory;\n\t\tfuncs->send_inbox0_cmd = dmub_dcn32_send_inbox0_cmd;\n\t\tfuncs->clear_inbox0_ack_register = dmub_dcn32_clear_inbox0_ack_register;\n\t\tfuncs->read_inbox0_ack_register = dmub_dcn32_read_inbox0_ack_register;\n\t\tfuncs->reset = dmub_dcn32_reset;\n\t\tfuncs->reset_release = dmub_dcn32_reset_release;\n\t\tfuncs->backdoor_load = dmub_dcn32_backdoor_load;\n\t\tfuncs->backdoor_load_zfb_mode = dmub_dcn32_backdoor_load_zfb_mode;\n\t\tfuncs->setup_windows = dmub_dcn32_setup_windows;\n\t\tfuncs->setup_mailbox = dmub_dcn32_setup_mailbox;\n\t\tfuncs->get_inbox1_wptr = dmub_dcn32_get_inbox1_wptr;\n\t\tfuncs->get_inbox1_rptr = dmub_dcn32_get_inbox1_rptr;\n\t\tfuncs->set_inbox1_wptr = dmub_dcn32_set_inbox1_wptr;\n\t\tfuncs->setup_out_mailbox = dmub_dcn32_setup_out_mailbox;\n\t\tfuncs->get_outbox1_wptr = dmub_dcn32_get_outbox1_wptr;\n\t\tfuncs->set_outbox1_rptr = dmub_dcn32_set_outbox1_rptr;\n\t\tfuncs->is_supported = dmub_dcn32_is_supported;\n\t\tfuncs->is_hw_init = dmub_dcn32_is_hw_init;\n\t\tfuncs->set_gpint = dmub_dcn32_set_gpint;\n\t\tfuncs->is_gpint_acked = dmub_dcn32_is_gpint_acked;\n\t\tfuncs->get_gpint_response = dmub_dcn32_get_gpint_response;\n\t\tfuncs->get_gpint_dataout = dmub_dcn32_get_gpint_dataout;\n\t\tfuncs->get_fw_status = dmub_dcn32_get_fw_boot_status;\n\t\tfuncs->enable_dmub_boot_options = dmub_dcn32_enable_dmub_boot_options;\n\t\tfuncs->skip_dmub_panel_power_sequence = dmub_dcn32_skip_dmub_panel_power_sequence;\n\n\t\t \n\t\tfuncs->setup_outbox0 = dmub_dcn32_setup_outbox0;\n\t\tfuncs->get_outbox0_wptr = dmub_dcn32_get_outbox0_wptr;\n\t\tfuncs->set_outbox0_rptr = dmub_dcn32_set_outbox0_rptr;\n\t\tfuncs->get_current_time = dmub_dcn32_get_current_time;\n\t\tfuncs->get_diagnostic_data = dmub_dcn32_get_diagnostic_data;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dmub_status dmub_srv_create(struct dmub_srv *dmub,\n\t\t\t\t const struct dmub_srv_create_params *params)\n{\n\tenum dmub_status status = DMUB_STATUS_OK;\n\n\tdmub_memset(dmub, 0, sizeof(*dmub));\n\n\tdmub->funcs = params->funcs;\n\tdmub->user_ctx = params->user_ctx;\n\tdmub->asic = params->asic;\n\tdmub->fw_version = params->fw_version;\n\tdmub->is_virtual = params->is_virtual;\n\n\t \n\tif (!dmub_srv_hw_setup(dmub, params->asic)) {\n\t\tstatus = DMUB_STATUS_INVALID;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (params->hw_funcs) {\n\t\tif (params->hw_funcs->emul_get_inbox1_rptr)\n\t\t\tdmub->hw_funcs.emul_get_inbox1_rptr =\n\t\t\t\tparams->hw_funcs->emul_get_inbox1_rptr;\n\n\t\tif (params->hw_funcs->emul_set_inbox1_wptr)\n\t\t\tdmub->hw_funcs.emul_set_inbox1_wptr =\n\t\t\t\tparams->hw_funcs->emul_set_inbox1_wptr;\n\n\t\tif (params->hw_funcs->is_supported)\n\t\t\tdmub->hw_funcs.is_supported =\n\t\t\t\tparams->hw_funcs->is_supported;\n\t}\n\n\t \n\tif (!dmub->hw_funcs.get_inbox1_rptr ||\n\t    !dmub->hw_funcs.set_inbox1_wptr) {\n\t\tstatus = DMUB_STATUS_INVALID;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (status == DMUB_STATUS_OK)\n\t\tdmub->sw_init = true;\n\telse\n\t\tdmub_srv_destroy(dmub);\n\n\treturn status;\n}\n\nvoid dmub_srv_destroy(struct dmub_srv *dmub)\n{\n\tdmub_memset(dmub, 0, sizeof(*dmub));\n}\n\nenum dmub_status\ndmub_srv_calc_region_info(struct dmub_srv *dmub,\n\t\t\t  const struct dmub_srv_region_params *params,\n\t\t\t  struct dmub_srv_region_info *out)\n{\n\tstruct dmub_region *inst = &out->regions[DMUB_WINDOW_0_INST_CONST];\n\tstruct dmub_region *stack = &out->regions[DMUB_WINDOW_1_STACK];\n\tstruct dmub_region *data = &out->regions[DMUB_WINDOW_2_BSS_DATA];\n\tstruct dmub_region *bios = &out->regions[DMUB_WINDOW_3_VBIOS];\n\tstruct dmub_region *mail = &out->regions[DMUB_WINDOW_4_MAILBOX];\n\tstruct dmub_region *trace_buff = &out->regions[DMUB_WINDOW_5_TRACEBUFF];\n\tstruct dmub_region *fw_state = &out->regions[DMUB_WINDOW_6_FW_STATE];\n\tstruct dmub_region *scratch_mem = &out->regions[DMUB_WINDOW_7_SCRATCH_MEM];\n\tconst struct dmub_fw_meta_info *fw_info;\n\tuint32_t fw_state_size = DMUB_FW_STATE_SIZE;\n\tuint32_t trace_buffer_size = DMUB_TRACE_BUFFER_SIZE;\n\tuint32_t scratch_mem_size = DMUB_SCRATCH_MEM_SIZE;\n\tuint32_t previous_top = 0;\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tout->num_regions = DMUB_NUM_WINDOWS;\n\n\tinst->base = 0x0;\n\tinst->top = inst->base + params->inst_const_size;\n\n\tdata->base = dmub_align(inst->top, 256);\n\tdata->top = data->base + params->bss_data_size;\n\n\t \n\n\tstack->base = dmub_align(data->top, 256);\n\tstack->top = stack->base + DMUB_STACK_SIZE + DMUB_CONTEXT_SIZE;\n\n\tbios->base = dmub_align(stack->top, 256);\n\tbios->top = bios->base + params->vbios_size;\n\n\tif (params->is_mailbox_in_inbox) {\n\t\tmail->base = 0;\n\t\tmail->top = mail->base + DMUB_MAILBOX_SIZE;\n\t\tprevious_top = bios->top;\n\t} else {\n\t\tmail->base = dmub_align(bios->top, 256);\n\t\tmail->top = mail->base + DMUB_MAILBOX_SIZE;\n\t\tprevious_top = mail->top;\n\t}\n\n\tfw_info = dmub_get_fw_meta_info(params);\n\n\tif (fw_info) {\n\t\tfw_state_size = fw_info->fw_region_size;\n\t\ttrace_buffer_size = fw_info->trace_buffer_size;\n\n\t\t \n\t\tif (dmub->fw_version == 0)\n\t\t\tdmub->fw_version = fw_info->fw_version;\n\t}\n\n\ttrace_buff->base = dmub_align(previous_top, 256);\n\ttrace_buff->top = trace_buff->base + dmub_align(trace_buffer_size, 64);\n\n\tfw_state->base = dmub_align(trace_buff->top, 256);\n\tfw_state->top = fw_state->base + dmub_align(fw_state_size, 64);\n\n\tscratch_mem->base = dmub_align(fw_state->top, 256);\n\tscratch_mem->top = scratch_mem->base + dmub_align(scratch_mem_size, 64);\n\n\tout->fb_size = dmub_align(scratch_mem->top, 4096);\n\n\tif (params->is_mailbox_in_inbox)\n\t\tout->inbox_size = dmub_align(mail->top, 4096);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_calc_mem_info(struct dmub_srv *dmub,\n\t\t\t\t       const struct dmub_srv_memory_params *params,\n\t\t\t\t       struct dmub_srv_fb_info *out)\n{\n\tuint8_t *cpu_base;\n\tuint64_t gpu_base;\n\tuint32_t i;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (params->region_info->num_regions != DMUB_NUM_WINDOWS)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tcpu_base = (uint8_t *)params->cpu_fb_addr;\n\tgpu_base = params->gpu_fb_addr;\n\n\tfor (i = 0; i < DMUB_NUM_WINDOWS; ++i) {\n\t\tconst struct dmub_region *reg =\n\t\t\t&params->region_info->regions[i];\n\n\t\tout->fb[i].cpu_addr = cpu_base + reg->base;\n\t\tout->fb[i].gpu_addr = gpu_base + reg->base;\n\n\t\tif (i == DMUB_WINDOW_4_MAILBOX && params->cpu_inbox_addr != 0) {\n\t\t\tout->fb[i].cpu_addr = (uint8_t *)params->cpu_inbox_addr + reg->base;\n\t\t\tout->fb[i].gpu_addr = params->gpu_inbox_addr + reg->base;\n\t\t}\n\n\t\tout->fb[i].size = reg->top - reg->base;\n\t}\n\n\tout->num_fb = DMUB_NUM_WINDOWS;\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_has_hw_support(struct dmub_srv *dmub,\n\t\t\t\t\t bool *is_supported)\n{\n\t*is_supported = false;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.is_supported)\n\t\t*is_supported = dmub->hw_funcs.is_supported(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_is_hw_init(struct dmub_srv *dmub, bool *is_hw_init)\n{\n\t*is_hw_init = false;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!dmub->hw_init)\n\t\treturn DMUB_STATUS_OK;\n\n\tif (dmub->hw_funcs.is_hw_init)\n\t\t*is_hw_init = dmub->hw_funcs.is_hw_init(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_hw_init(struct dmub_srv *dmub,\n\t\t\t\t  const struct dmub_srv_hw_params *params)\n{\n\tstruct dmub_fb *inst_fb = params->fb[DMUB_WINDOW_0_INST_CONST];\n\tstruct dmub_fb *stack_fb = params->fb[DMUB_WINDOW_1_STACK];\n\tstruct dmub_fb *data_fb = params->fb[DMUB_WINDOW_2_BSS_DATA];\n\tstruct dmub_fb *bios_fb = params->fb[DMUB_WINDOW_3_VBIOS];\n\tstruct dmub_fb *mail_fb = params->fb[DMUB_WINDOW_4_MAILBOX];\n\tstruct dmub_fb *tracebuff_fb = params->fb[DMUB_WINDOW_5_TRACEBUFF];\n\tstruct dmub_fb *fw_state_fb = params->fb[DMUB_WINDOW_6_FW_STATE];\n\tstruct dmub_fb *scratch_mem_fb = params->fb[DMUB_WINDOW_7_SCRATCH_MEM];\n\n\tstruct dmub_rb_init_params rb_params, outbox0_rb_params;\n\tstruct dmub_window cw0, cw1, cw2, cw3, cw4, cw5, cw6;\n\tstruct dmub_region inbox1, outbox1, outbox0;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!inst_fb || !stack_fb || !data_fb || !bios_fb || !mail_fb ||\n\t\t!tracebuff_fb || !fw_state_fb || !scratch_mem_fb) {\n\t\tASSERT(0);\n\t\treturn DMUB_STATUS_INVALID;\n\t}\n\n\tdmub->fb_base = params->fb_base;\n\tdmub->fb_offset = params->fb_offset;\n\tdmub->psp_version = params->psp_version;\n\n\tif (dmub->hw_funcs.reset)\n\t\tdmub->hw_funcs.reset(dmub);\n\n\t \n\tdmub->inbox1_last_wptr = 0;\n\n\tcw0.offset.quad_part = inst_fb->gpu_addr;\n\tcw0.region.base = DMUB_CW0_BASE;\n\tcw0.region.top = cw0.region.base + inst_fb->size - 1;\n\n\tcw1.offset.quad_part = stack_fb->gpu_addr;\n\tcw1.region.base = DMUB_CW1_BASE;\n\tcw1.region.top = cw1.region.base + stack_fb->size - 1;\n\n\tif (params->fw_in_system_memory && dmub->hw_funcs.configure_dmub_in_system_memory)\n\t\tdmub->hw_funcs.configure_dmub_in_system_memory(dmub);\n\n\tif (params->load_inst_const && dmub->hw_funcs.backdoor_load) {\n\t\t \n\t\tdmub_flush_buffer_mem(inst_fb);\n\n\t\tif (params->fw_in_system_memory && dmub->hw_funcs.backdoor_load_zfb_mode)\n\t\t\tdmub->hw_funcs.backdoor_load_zfb_mode(dmub, &cw0, &cw1);\n\t\telse\n\t\t\tdmub->hw_funcs.backdoor_load(dmub, &cw0, &cw1);\n\t}\n\n\tcw2.offset.quad_part = data_fb->gpu_addr;\n\tcw2.region.base = DMUB_CW0_BASE + inst_fb->size;\n\tcw2.region.top = cw2.region.base + data_fb->size;\n\n\tcw3.offset.quad_part = bios_fb->gpu_addr;\n\tcw3.region.base = DMUB_CW3_BASE;\n\tcw3.region.top = cw3.region.base + bios_fb->size;\n\n\tcw4.offset.quad_part = mail_fb->gpu_addr;\n\tcw4.region.base = DMUB_CW4_BASE;\n\tcw4.region.top = cw4.region.base + mail_fb->size;\n\n\t \n\tinbox1.base = cw4.region.base;\n\tinbox1.top = cw4.region.base + DMUB_RB_SIZE;\n\toutbox1.base = inbox1.top;\n\toutbox1.top = cw4.region.top;\n\n\tcw5.offset.quad_part = tracebuff_fb->gpu_addr;\n\tcw5.region.base = DMUB_CW5_BASE;\n\tcw5.region.top = cw5.region.base + tracebuff_fb->size;\n\n\toutbox0.base = DMUB_REGION5_BASE + TRACE_BUFFER_ENTRY_OFFSET;\n\toutbox0.top = outbox0.base + tracebuff_fb->size - TRACE_BUFFER_ENTRY_OFFSET;\n\n\tcw6.offset.quad_part = fw_state_fb->gpu_addr;\n\tcw6.region.base = DMUB_CW6_BASE;\n\tcw6.region.top = cw6.region.base + fw_state_fb->size;\n\n\tdmub->fw_state = fw_state_fb->cpu_addr;\n\n\tdmub->scratch_mem_fb = *scratch_mem_fb;\n\n\tif (dmub->hw_funcs.setup_windows)\n\t\tdmub->hw_funcs.setup_windows(dmub, &cw2, &cw3, &cw4, &cw5, &cw6);\n\n\tif (dmub->hw_funcs.setup_outbox0)\n\t\tdmub->hw_funcs.setup_outbox0(dmub, &outbox0);\n\n\tif (dmub->hw_funcs.setup_mailbox)\n\t\tdmub->hw_funcs.setup_mailbox(dmub, &inbox1);\n\tif (dmub->hw_funcs.setup_out_mailbox)\n\t\tdmub->hw_funcs.setup_out_mailbox(dmub, &outbox1);\n\n\tdmub_memset(&rb_params, 0, sizeof(rb_params));\n\trb_params.ctx = dmub;\n\trb_params.base_address = mail_fb->cpu_addr;\n\trb_params.capacity = DMUB_RB_SIZE;\n\tdmub_rb_init(&dmub->inbox1_rb, &rb_params);\n\n\t\n\trb_params.ctx = dmub;\n\trb_params.base_address = (void *) ((uint8_t *) (mail_fb->cpu_addr) + DMUB_RB_SIZE);\n\trb_params.capacity = DMUB_RB_SIZE;\n\tdmub_rb_init(&dmub->outbox1_rb, &rb_params);\n\n\tdmub_memset(&outbox0_rb_params, 0, sizeof(outbox0_rb_params));\n\toutbox0_rb_params.ctx = dmub;\n\toutbox0_rb_params.base_address = (void *)((uintptr_t)(tracebuff_fb->cpu_addr) + TRACE_BUFFER_ENTRY_OFFSET);\n\toutbox0_rb_params.capacity = tracebuff_fb->size - dmub_align(TRACE_BUFFER_ENTRY_OFFSET, 64);\n\tdmub_rb_init(&dmub->outbox0_rb, &outbox0_rb_params);\n\n\t \n\tif (dmub->hw_funcs.enable_dmub_boot_options)\n\t\tdmub->hw_funcs.enable_dmub_boot_options(dmub, params);\n\n\tif (dmub->hw_funcs.skip_dmub_panel_power_sequence && !dmub->is_virtual)\n\t\tdmub->hw_funcs.skip_dmub_panel_power_sequence(dmub,\n\t\t\tparams->skip_panel_power_sequence);\n\n\tif (dmub->hw_funcs.reset_release && !dmub->is_virtual)\n\t\tdmub->hw_funcs.reset_release(dmub);\n\n\tdmub->hw_init = true;\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_sync_inbox1(struct dmub_srv *dmub)\n{\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.get_inbox1_rptr && dmub->hw_funcs.get_inbox1_wptr) {\n\t\tuint32_t rptr = dmub->hw_funcs.get_inbox1_rptr(dmub);\n\t\tuint32_t wptr = dmub->hw_funcs.get_inbox1_wptr(dmub);\n\n\t\tif (rptr > dmub->inbox1_rb.capacity || wptr > dmub->inbox1_rb.capacity) {\n\t\t\treturn DMUB_STATUS_HW_FAILURE;\n\t\t} else {\n\t\t\tdmub->inbox1_rb.rptr = rptr;\n\t\t\tdmub->inbox1_rb.wrpt = wptr;\n\t\t\tdmub->inbox1_last_wptr = dmub->inbox1_rb.wrpt;\n\t\t}\n\t}\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_hw_reset(struct dmub_srv *dmub)\n{\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.reset)\n\t\tdmub->hw_funcs.reset(dmub);\n\n\t \n\tdmub->inbox1_last_wptr = 0;\n\tdmub->inbox1_rb.wrpt = 0;\n\tdmub->inbox1_rb.rptr = 0;\n\tdmub->outbox0_rb.wrpt = 0;\n\tdmub->outbox0_rb.rptr = 0;\n\tdmub->outbox1_rb.wrpt = 0;\n\tdmub->outbox1_rb.rptr = 0;\n\n\tdmub->hw_init = false;\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_cmd_queue(struct dmub_srv *dmub,\n\t\t\t\t    const union dmub_rb_cmd *cmd)\n{\n\tif (!dmub->hw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->inbox1_rb.rptr > dmub->inbox1_rb.capacity ||\n\t    dmub->inbox1_rb.wrpt > dmub->inbox1_rb.capacity) {\n\t\treturn DMUB_STATUS_HW_FAILURE;\n\t}\n\n\tif (dmub_rb_push_front(&dmub->inbox1_rb, cmd))\n\t\treturn DMUB_STATUS_OK;\n\n\treturn DMUB_STATUS_QUEUE_FULL;\n}\n\nenum dmub_status dmub_srv_cmd_execute(struct dmub_srv *dmub)\n{\n\tstruct dmub_rb flush_rb;\n\n\tif (!dmub->hw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\t \n\tflush_rb = dmub->inbox1_rb;\n\tflush_rb.rptr = dmub->inbox1_last_wptr;\n\tdmub_rb_flush_pending(&flush_rb);\n\n\tdmub->hw_funcs.set_inbox1_wptr(dmub, dmub->inbox1_rb.wrpt);\n\n\tdmub->inbox1_last_wptr = dmub->inbox1_rb.wrpt;\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_wait_for_auto_load(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t timeout_us)\n{\n\tuint32_t i;\n\n\tif (!dmub->hw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tfor (i = 0; i <= timeout_us; i += 100) {\n\t\tunion dmub_fw_boot_status status = dmub->hw_funcs.get_fw_status(dmub);\n\n\t\tif (status.bits.dal_fw && status.bits.mailbox_rdy)\n\t\t\treturn DMUB_STATUS_OK;\n\n\t\tudelay(100);\n\t}\n\n\treturn DMUB_STATUS_TIMEOUT;\n}\n\nenum dmub_status dmub_srv_wait_for_idle(struct dmub_srv *dmub,\n\t\t\t\t\tuint32_t timeout_us)\n{\n\tuint32_t i, rptr;\n\n\tif (!dmub->hw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tfor (i = 0; i <= timeout_us; ++i) {\n\t\trptr = dmub->hw_funcs.get_inbox1_rptr(dmub);\n\n\t\tif (rptr > dmub->inbox1_rb.capacity)\n\t\t\treturn DMUB_STATUS_HW_FAILURE;\n\n\t\tdmub->inbox1_rb.rptr = rptr;\n\n\t\tif (dmub_rb_empty(&dmub->inbox1_rb))\n\t\t\treturn DMUB_STATUS_OK;\n\n\t\tudelay(1);\n\t}\n\n\treturn DMUB_STATUS_TIMEOUT;\n}\n\nenum dmub_status\ndmub_srv_send_gpint_command(struct dmub_srv *dmub,\n\t\t\t    enum dmub_gpint_command command_code,\n\t\t\t    uint16_t param, uint32_t timeout_us)\n{\n\tunion dmub_gpint_data_register reg;\n\tuint32_t i;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!dmub->hw_funcs.set_gpint)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!dmub->hw_funcs.is_gpint_acked)\n\t\treturn DMUB_STATUS_INVALID;\n\n\treg.bits.status = 1;\n\treg.bits.command_code = command_code;\n\treg.bits.param = param;\n\n\tdmub->hw_funcs.set_gpint(dmub, reg);\n\n\tfor (i = 0; i < timeout_us; ++i) {\n\t\tudelay(1);\n\n\t\tif (dmub->hw_funcs.is_gpint_acked(dmub, reg))\n\t\t\treturn DMUB_STATUS_OK;\n\t}\n\n\treturn DMUB_STATUS_TIMEOUT;\n}\n\nenum dmub_status dmub_srv_get_gpint_response(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t *response)\n{\n\t*response = 0;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!dmub->hw_funcs.get_gpint_response)\n\t\treturn DMUB_STATUS_INVALID;\n\n\t*response = dmub->hw_funcs.get_gpint_response(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_get_gpint_dataout(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t *dataout)\n{\n\t*dataout = 0;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (!dmub->hw_funcs.get_gpint_dataout)\n\t\treturn DMUB_STATUS_INVALID;\n\n\t*dataout = dmub->hw_funcs.get_gpint_dataout(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_get_fw_boot_status(struct dmub_srv *dmub,\n\t\t\t\t\t     union dmub_fw_boot_status *status)\n{\n\tstatus->all = 0;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.get_fw_status)\n\t\t*status = dmub->hw_funcs.get_fw_status(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_get_fw_boot_option(struct dmub_srv *dmub,\n\t\t\t\t\t     union dmub_fw_boot_options *option)\n{\n\toption->all = 0;\n\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.get_fw_boot_option)\n\t\t*option = dmub->hw_funcs.get_fw_boot_option(dmub);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_set_skip_panel_power_sequence(struct dmub_srv *dmub,\n\t\t\t\t\t     bool skip)\n{\n\tif (!dmub->sw_init)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tif (dmub->hw_funcs.skip_dmub_panel_power_sequence && !dmub->is_virtual)\n\t\tdmub->hw_funcs.skip_dmub_panel_power_sequence(dmub, skip);\n\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_cmd_with_reply_data(struct dmub_srv *dmub,\n\t\t\t\t\t      union dmub_rb_cmd *cmd)\n{\n\tenum dmub_status status = DMUB_STATUS_OK;\n\n\t\n\tstatus = dmub_srv_cmd_queue(dmub, cmd);\n\n\tif (status != DMUB_STATUS_OK)\n\t\treturn status;\n\n\t\n\tstatus = dmub_srv_cmd_execute(dmub);\n\n\tif (status != DMUB_STATUS_OK)\n\t\treturn status;\n\n\t\n\tstatus = dmub_srv_wait_for_idle(dmub, 100000);\n\n\tif (status != DMUB_STATUS_OK)\n\t\treturn status;\n\n\t\n\tdmub_rb_get_return_data(&dmub->inbox1_rb, cmd);\n\n\treturn status;\n}\n\nstatic inline bool dmub_rb_out_trace_buffer_front(struct dmub_rb *rb,\n\t\t\t\t void *entry)\n{\n\tconst uint64_t *src = (const uint64_t *)(rb->base_address) + rb->rptr / sizeof(uint64_t);\n\tuint64_t *dst = (uint64_t *)entry;\n\tuint8_t i;\n\tuint8_t loop_count;\n\n\tif (rb->rptr == rb->wrpt)\n\t\treturn false;\n\n\tloop_count = sizeof(struct dmcub_trace_buf_entry) / sizeof(uint64_t);\n\t\n\tfor (i = 0; i < loop_count; i++)\n\t\t*dst++ = *src++;\n\n\trb->rptr += sizeof(struct dmcub_trace_buf_entry);\n\n\trb->rptr %= rb->capacity;\n\n\treturn true;\n}\n\nbool dmub_srv_get_outbox0_msg(struct dmub_srv *dmub, struct dmcub_trace_buf_entry *entry)\n{\n\tdmub->outbox0_rb.wrpt = dmub->hw_funcs.get_outbox0_wptr(dmub);\n\n\treturn dmub_rb_out_trace_buffer_front(&dmub->outbox0_rb, (void *)entry);\n}\n\nbool dmub_srv_get_diagnostic_data(struct dmub_srv *dmub, struct dmub_diagnostic_data *diag_data)\n{\n\tif (!dmub || !dmub->hw_funcs.get_diagnostic_data || !diag_data)\n\t\treturn false;\n\tdmub->hw_funcs.get_diagnostic_data(dmub, diag_data);\n\treturn true;\n}\n\nbool dmub_srv_should_detect(struct dmub_srv *dmub)\n{\n\tif (!dmub->hw_init || !dmub->hw_funcs.should_detect)\n\t\treturn false;\n\n\treturn dmub->hw_funcs.should_detect(dmub);\n}\n\nenum dmub_status dmub_srv_clear_inbox0_ack(struct dmub_srv *dmub)\n{\n\tif (!dmub->hw_init || !dmub->hw_funcs.clear_inbox0_ack_register)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tdmub->hw_funcs.clear_inbox0_ack_register(dmub);\n\treturn DMUB_STATUS_OK;\n}\n\nenum dmub_status dmub_srv_wait_for_inbox0_ack(struct dmub_srv *dmub, uint32_t timeout_us)\n{\n\tuint32_t i = 0;\n\tuint32_t ack = 0;\n\n\tif (!dmub->hw_init || !dmub->hw_funcs.read_inbox0_ack_register)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tfor (i = 0; i <= timeout_us; i++) {\n\t\tack = dmub->hw_funcs.read_inbox0_ack_register(dmub);\n\t\tif (ack)\n\t\t\treturn DMUB_STATUS_OK;\n\t\tudelay(1);\n\t}\n\treturn DMUB_STATUS_TIMEOUT;\n}\n\nenum dmub_status dmub_srv_send_inbox0_cmd(struct dmub_srv *dmub,\n\t\tunion dmub_inbox0_data_register data)\n{\n\tif (!dmub->hw_init || !dmub->hw_funcs.send_inbox0_cmd)\n\t\treturn DMUB_STATUS_INVALID;\n\n\tdmub->hw_funcs.send_inbox0_cmd(dmub, data);\n\treturn DMUB_STATUS_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}