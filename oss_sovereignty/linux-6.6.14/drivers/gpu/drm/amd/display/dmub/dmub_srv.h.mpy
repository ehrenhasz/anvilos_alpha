{
  "module_name": "dmub_srv.h",
  "hash_id": "a89cbf7b302e0e05c81c1b129611267d1a289e5dbea51e1c776677fb310463fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/display/dmub/dmub_srv.h",
  "human_readable_source": " \n\n#ifndef _DMUB_SRV_H_\n#define _DMUB_SRV_H_\n\n \n\n#include \"inc/dmub_cmd.h\"\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n \nstruct dmub_srv;\nstruct dmub_srv_common_regs;\nstruct dmub_srv_dcn31_regs;\n\nstruct dmcub_trace_buf_entry;\n\n \nenum dmub_status {\n\tDMUB_STATUS_OK = 0,\n\tDMUB_STATUS_NO_CTX,\n\tDMUB_STATUS_QUEUE_FULL,\n\tDMUB_STATUS_TIMEOUT,\n\tDMUB_STATUS_INVALID,\n\tDMUB_STATUS_HW_FAILURE,\n};\n\n \nenum dmub_asic {\n\tDMUB_ASIC_NONE = 0,\n\tDMUB_ASIC_DCN20,\n\tDMUB_ASIC_DCN21,\n\tDMUB_ASIC_DCN30,\n\tDMUB_ASIC_DCN301,\n\tDMUB_ASIC_DCN302,\n\tDMUB_ASIC_DCN303,\n\tDMUB_ASIC_DCN31,\n\tDMUB_ASIC_DCN31B,\n\tDMUB_ASIC_DCN314,\n\tDMUB_ASIC_DCN315,\n\tDMUB_ASIC_DCN316,\n\tDMUB_ASIC_DCN32,\n\tDMUB_ASIC_DCN321,\n\tDMUB_ASIC_MAX,\n};\n\n \nenum dmub_window_id {\n\tDMUB_WINDOW_0_INST_CONST = 0,\n\tDMUB_WINDOW_1_STACK,\n\tDMUB_WINDOW_2_BSS_DATA,\n\tDMUB_WINDOW_3_VBIOS,\n\tDMUB_WINDOW_4_MAILBOX,\n\tDMUB_WINDOW_5_TRACEBUFF,\n\tDMUB_WINDOW_6_FW_STATE,\n\tDMUB_WINDOW_7_SCRATCH_MEM,\n\tDMUB_WINDOW_TOTAL,\n};\n\n \nenum dmub_notification_type {\n\tDMUB_NOTIFICATION_NO_DATA = 0,\n\tDMUB_NOTIFICATION_AUX_REPLY,\n\tDMUB_NOTIFICATION_HPD,\n\tDMUB_NOTIFICATION_HPD_IRQ,\n\tDMUB_NOTIFICATION_SET_CONFIG_REPLY,\n\tDMUB_NOTIFICATION_DPIA_NOTIFICATION,\n\tDMUB_NOTIFICATION_MAX\n};\n\n \nenum dpia_notify_bw_alloc_status {\n\n\tDPIA_BW_REQ_FAILED = 0,\n\tDPIA_BW_REQ_SUCCESS,\n\tDPIA_EST_BW_CHANGED,\n\tDPIA_BW_ALLOC_CAPS_CHANGED\n};\n\n \nstruct dmub_region {\n\tuint32_t base;\n\tuint32_t top;\n};\n\n \nstruct dmub_window {\n\tunion dmub_addr offset;\n\tstruct dmub_region region;\n};\n\n \nstruct dmub_fb {\n\tvoid *cpu_addr;\n\tuint64_t gpu_addr;\n\tuint32_t size;\n};\n\n \nstruct dmub_srv_region_params {\n\tuint32_t inst_const_size;\n\tuint32_t bss_data_size;\n\tuint32_t vbios_size;\n\tconst uint8_t *fw_inst_const;\n\tconst uint8_t *fw_bss_data;\n\tbool is_mailbox_in_inbox;\n};\n\n \nstruct dmub_srv_region_info {\n\tuint32_t fb_size;\n\tuint32_t inbox_size;\n\tuint8_t num_regions;\n\tstruct dmub_region regions[DMUB_WINDOW_TOTAL];\n};\n\n \nstruct dmub_srv_memory_params {\n\tconst struct dmub_srv_region_info *region_info;\n\tvoid *cpu_fb_addr;\n\tvoid *cpu_inbox_addr;\n\tuint64_t gpu_fb_addr;\n\tuint64_t gpu_inbox_addr;\n};\n\n \nstruct dmub_srv_fb_info {\n\tuint8_t num_fb;\n\tstruct dmub_fb fb[DMUB_WINDOW_TOTAL];\n};\n\n \nstruct dmub_srv_hw_params {\n\tstruct dmub_fb *fb[DMUB_WINDOW_TOTAL];\n\tuint64_t fb_base;\n\tuint64_t fb_offset;\n\tuint32_t psp_version;\n\tbool load_inst_const;\n\tbool skip_panel_power_sequence;\n\tbool disable_z10;\n\tbool power_optimization;\n\tbool dpia_supported;\n\tbool disable_dpia;\n\tbool usb4_cm_version;\n\tbool fw_in_system_memory;\n\tbool dpia_hpd_int_enable_supported;\n\tbool disable_clock_gate;\n\tbool disallow_dispclk_dppclk_ds;\n};\n\n \nstruct dmub_diagnostic_data {\n\tuint32_t dmcub_version;\n\tuint32_t scratch[17];\n\tuint32_t pc;\n\tuint32_t undefined_address_fault_addr;\n\tuint32_t inst_fetch_fault_addr;\n\tuint32_t data_write_fault_addr;\n\tuint32_t inbox1_rptr;\n\tuint32_t inbox1_wptr;\n\tuint32_t inbox1_size;\n\tuint32_t inbox0_rptr;\n\tuint32_t inbox0_wptr;\n\tuint32_t inbox0_size;\n\tuint32_t gpint_datain0;\n\tuint8_t is_dmcub_enabled : 1;\n\tuint8_t is_dmcub_soft_reset : 1;\n\tuint8_t is_dmcub_secure_reset : 1;\n\tuint8_t is_traceport_en : 1;\n\tuint8_t is_cw0_enabled : 1;\n\tuint8_t is_cw6_enabled : 1;\n};\n\n \nstruct dmub_srv_base_funcs {\n\t \n\tuint32_t (*reg_read)(void *ctx, uint32_t address);\n\n\t \n\tvoid (*reg_write)(void *ctx, uint32_t address, uint32_t value);\n};\n\n \nstruct dmub_srv_hw_funcs {\n\t \n\n\tvoid (*init)(struct dmub_srv *dmub);\n\n\tvoid (*reset)(struct dmub_srv *dmub);\n\n\tvoid (*reset_release)(struct dmub_srv *dmub);\n\n\tvoid (*backdoor_load)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_window *cw0,\n\t\t\t      const struct dmub_window *cw1);\n\n\tvoid (*backdoor_load_zfb_mode)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_window *cw0,\n\t\t\t      const struct dmub_window *cw1);\n\tvoid (*setup_windows)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_window *cw2,\n\t\t\t      const struct dmub_window *cw3,\n\t\t\t      const struct dmub_window *cw4,\n\t\t\t      const struct dmub_window *cw5,\n\t\t\t      const struct dmub_window *cw6);\n\n\tvoid (*setup_mailbox)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_region *inbox1);\n\n\tuint32_t (*get_inbox1_wptr)(struct dmub_srv *dmub);\n\n\tuint32_t (*get_inbox1_rptr)(struct dmub_srv *dmub);\n\n\tvoid (*set_inbox1_wptr)(struct dmub_srv *dmub, uint32_t wptr_offset);\n\n\tvoid (*setup_out_mailbox)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_region *outbox1);\n\n\tuint32_t (*get_outbox1_wptr)(struct dmub_srv *dmub);\n\n\tvoid (*set_outbox1_rptr)(struct dmub_srv *dmub, uint32_t rptr_offset);\n\n\tvoid (*setup_outbox0)(struct dmub_srv *dmub,\n\t\t\t      const struct dmub_region *outbox0);\n\n\tuint32_t (*get_outbox0_wptr)(struct dmub_srv *dmub);\n\n\tvoid (*set_outbox0_rptr)(struct dmub_srv *dmub, uint32_t rptr_offset);\n\n\tuint32_t (*emul_get_inbox1_rptr)(struct dmub_srv *dmub);\n\n\tvoid (*emul_set_inbox1_wptr)(struct dmub_srv *dmub, uint32_t wptr_offset);\n\n\tbool (*is_supported)(struct dmub_srv *dmub);\n\n\tbool (*is_psrsu_supported)(struct dmub_srv *dmub);\n\n\tbool (*is_hw_init)(struct dmub_srv *dmub);\n\n\tvoid (*enable_dmub_boot_options)(struct dmub_srv *dmub,\n\t\t\t\tconst struct dmub_srv_hw_params *params);\n\n\tvoid (*skip_dmub_panel_power_sequence)(struct dmub_srv *dmub, bool skip);\n\n\tunion dmub_fw_boot_status (*get_fw_status)(struct dmub_srv *dmub);\n\n\tunion dmub_fw_boot_options (*get_fw_boot_option)(struct dmub_srv *dmub);\n\n\tvoid (*set_gpint)(struct dmub_srv *dmub,\n\t\t\t  union dmub_gpint_data_register reg);\n\n\tbool (*is_gpint_acked)(struct dmub_srv *dmub,\n\t\t\t       union dmub_gpint_data_register reg);\n\n\tuint32_t (*get_gpint_response)(struct dmub_srv *dmub);\n\n\tuint32_t (*get_gpint_dataout)(struct dmub_srv *dmub);\n\n\tvoid (*configure_dmub_in_system_memory)(struct dmub_srv *dmub);\n\tvoid (*clear_inbox0_ack_register)(struct dmub_srv *dmub);\n\tuint32_t (*read_inbox0_ack_register)(struct dmub_srv *dmub);\n\tvoid (*send_inbox0_cmd)(struct dmub_srv *dmub, union dmub_inbox0_data_register data);\n\tuint32_t (*get_current_time)(struct dmub_srv *dmub);\n\n\tvoid (*get_diagnostic_data)(struct dmub_srv *dmub, struct dmub_diagnostic_data *dmub_oca);\n\n\tbool (*should_detect)(struct dmub_srv *dmub);\n};\n\n \nstruct dmub_srv_create_params {\n\tstruct dmub_srv_base_funcs funcs;\n\tstruct dmub_srv_hw_funcs *hw_funcs;\n\tvoid *user_ctx;\n\tenum dmub_asic asic;\n\tuint32_t fw_version;\n\tbool is_virtual;\n};\n\n \nstruct dmub_srv {\n\tenum dmub_asic asic;\n\tvoid *user_ctx;\n\tuint32_t fw_version;\n\tbool is_virtual;\n\tstruct dmub_fb scratch_mem_fb;\n\tvolatile const struct dmub_fw_state *fw_state;\n\n\t \n\tconst struct dmub_srv_common_regs *regs;\n\tconst struct dmub_srv_dcn31_regs *regs_dcn31;\n\tconst struct dmub_srv_dcn32_regs *regs_dcn32;\n\n\tstruct dmub_srv_base_funcs funcs;\n\tstruct dmub_srv_hw_funcs hw_funcs;\n\tstruct dmub_rb inbox1_rb;\n\tuint32_t inbox1_last_wptr;\n\t \n\tstruct dmub_rb outbox1_rb;\n\n\tstruct dmub_rb outbox0_rb;\n\n\tbool sw_init;\n\tbool hw_init;\n\n\tuint64_t fb_base;\n\tuint64_t fb_offset;\n\tuint32_t psp_version;\n\n\t \n\tstruct dmub_feature_caps feature_caps;\n\tstruct dmub_visual_confirm_color visual_confirm_color;\n};\n\n \nstruct dmub_notification {\n\tenum dmub_notification_type type;\n\tuint8_t link_index;\n\tuint8_t result;\n\tbool pending_notification;\n\tunion {\n\t\tstruct aux_reply_data aux_reply;\n\t\tenum dp_hpd_status hpd_status;\n\t\tenum set_config_status sc_status;\n\t\t \n\t\tstruct dmub_rb_cmd_dpia_notification dpia_notification;\n\t};\n};\n\n \n#define DMUB_FW_VERSION(major, minor, revision) \\\n\t((((major) & 0xFF) << 24) | (((minor) & 0xFF) << 16) | (((revision) & 0xFF) << 8))\n\n \nenum dmub_status dmub_srv_create(struct dmub_srv *dmub,\n\t\t\t\t const struct dmub_srv_create_params *params);\n\n \nvoid dmub_srv_destroy(struct dmub_srv *dmub);\n\n \nenum dmub_status\ndmub_srv_calc_region_info(struct dmub_srv *dmub,\n\t\t\t  const struct dmub_srv_region_params *params,\n\t\t\t  struct dmub_srv_region_info *out);\n\n \nenum dmub_status dmub_srv_calc_mem_info(struct dmub_srv *dmub,\n\t\t\t\t       const struct dmub_srv_memory_params *params,\n\t\t\t\t       struct dmub_srv_fb_info *out);\n\n \nenum dmub_status dmub_srv_has_hw_support(struct dmub_srv *dmub,\n\t\t\t\t\t bool *is_supported);\n\n \nenum dmub_status dmub_srv_is_hw_init(struct dmub_srv *dmub, bool *is_hw_init);\n\n \nenum dmub_status dmub_srv_hw_init(struct dmub_srv *dmub,\n\t\t\t\t  const struct dmub_srv_hw_params *params);\n\n \nenum dmub_status dmub_srv_hw_reset(struct dmub_srv *dmub);\n\n \nenum dmub_status dmub_srv_sync_inbox1(struct dmub_srv *dmub);\n\n \nenum dmub_status dmub_srv_cmd_queue(struct dmub_srv *dmub,\n\t\t\t\t    const union dmub_rb_cmd *cmd);\n\n \nenum dmub_status dmub_srv_cmd_execute(struct dmub_srv *dmub);\n\n \nenum dmub_status dmub_srv_wait_for_auto_load(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t timeout_us);\n\n \nenum dmub_status dmub_srv_wait_for_phy_init(struct dmub_srv *dmub,\n\t\t\t\t\t    uint32_t timeout_us);\n\n \nenum dmub_status dmub_srv_wait_for_idle(struct dmub_srv *dmub,\n\t\t\t\t\tuint32_t timeout_us);\n\n \nenum dmub_status\ndmub_srv_send_gpint_command(struct dmub_srv *dmub,\n\t\t\t    enum dmub_gpint_command command_code,\n\t\t\t    uint16_t param, uint32_t timeout_us);\n\n \nenum dmub_status dmub_srv_get_gpint_response(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t *response);\n\n \nenum dmub_status dmub_srv_get_gpint_dataout(struct dmub_srv *dmub,\n\t\t\t\t\t     uint32_t *dataout);\n\n \nvoid dmub_flush_buffer_mem(const struct dmub_fb *fb);\n\n \nenum dmub_status dmub_srv_get_fw_boot_status(struct dmub_srv *dmub,\n\t\t\t\t\t     union dmub_fw_boot_status *status);\n\nenum dmub_status dmub_srv_get_fw_boot_option(struct dmub_srv *dmub,\n\t\t\t\t\t     union dmub_fw_boot_options *option);\n\nenum dmub_status dmub_srv_cmd_with_reply_data(struct dmub_srv *dmub,\n\t\t\t\t\t      union dmub_rb_cmd *cmd);\n\nenum dmub_status dmub_srv_set_skip_panel_power_sequence(struct dmub_srv *dmub,\n\t\t\t\t\t     bool skip);\n\nbool dmub_srv_get_outbox0_msg(struct dmub_srv *dmub, struct dmcub_trace_buf_entry *entry);\n\nbool dmub_srv_get_diagnostic_data(struct dmub_srv *dmub, struct dmub_diagnostic_data *diag_data);\n\nbool dmub_srv_should_detect(struct dmub_srv *dmub);\n\n \nenum dmub_status dmub_srv_send_inbox0_cmd(struct dmub_srv *dmub, union dmub_inbox0_data_register data);\n\n \nenum dmub_status dmub_srv_wait_for_inbox0_ack(struct dmub_srv *dmub, uint32_t timeout_us);\n\n \nenum dmub_status dmub_srv_clear_inbox0_ack(struct dmub_srv *dmub);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}