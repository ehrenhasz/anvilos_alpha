{
  "module_name": "kfd_mqd_manager_v9.c",
  "hash_id": "e3c7fe54b5fbddc0ac97fa379ffaed8fd79e946f41dca05230d46fd26cd34c5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c",
  "human_readable_source": "\n \n\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"kfd_priv.h\"\n#include \"kfd_mqd_manager.h\"\n#include \"v9_structs.h\"\n#include \"gc/gc_9_0_offset.h\"\n#include \"gc/gc_9_0_sh_mask.h\"\n#include \"sdma0/sdma0_4_0_sh_mask.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"kfd_device_queue_manager.h\"\n\nstatic void update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t       struct queue_properties *q,\n\t\t       struct mqd_update_info *minfo);\n\nstatic uint64_t mqd_stride_v9(struct mqd_manager *mm,\n\t\t\t\tstruct queue_properties *q)\n{\n\tif (mm->dev->kfd->cwsr_enabled &&\n\t    q->type == KFD_QUEUE_TYPE_COMPUTE)\n\t\treturn ALIGN(q->ctl_stack_size, PAGE_SIZE) +\n\t\t\tALIGN(sizeof(struct v9_mqd), PAGE_SIZE);\n\n\treturn mm->mqd_size;\n}\n\nstatic inline struct v9_mqd *get_mqd(void *mqd)\n{\n\treturn (struct v9_mqd *)mqd;\n}\n\nstatic inline struct v9_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct v9_sdma_mqd *)mqd;\n}\n\nstatic void update_cu_mask(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct mqd_update_info *minfo, uint32_t inst)\n{\n\tstruct v9_mqd *m;\n\tuint32_t se_mask[KFD_MAX_NUM_SE] = {0};\n\n\tif (!minfo || !minfo->cu_mask.ptr)\n\t\treturn;\n\n\tmqd_symmetrically_map_cu_mask(mm,\n\t\tminfo->cu_mask.ptr, minfo->cu_mask.count, se_mask, inst);\n\n\tm = get_mqd(mqd);\n\n\tm->compute_static_thread_mgmt_se0 = se_mask[0];\n\tm->compute_static_thread_mgmt_se1 = se_mask[1];\n\tm->compute_static_thread_mgmt_se2 = se_mask[2];\n\tm->compute_static_thread_mgmt_se3 = se_mask[3];\n\tif (KFD_GC_VERSION(mm->dev) != IP_VERSION(9, 4, 3)) {\n\t\tm->compute_static_thread_mgmt_se4 = se_mask[4];\n\t\tm->compute_static_thread_mgmt_se5 = se_mask[5];\n\t\tm->compute_static_thread_mgmt_se6 = se_mask[6];\n\t\tm->compute_static_thread_mgmt_se7 = se_mask[7];\n\n\t\tpr_debug(\"update cu mask to %#x %#x %#x %#x %#x %#x %#x %#x\\n\",\n\t\t\tm->compute_static_thread_mgmt_se0,\n\t\t\tm->compute_static_thread_mgmt_se1,\n\t\t\tm->compute_static_thread_mgmt_se2,\n\t\t\tm->compute_static_thread_mgmt_se3,\n\t\t\tm->compute_static_thread_mgmt_se4,\n\t\t\tm->compute_static_thread_mgmt_se5,\n\t\t\tm->compute_static_thread_mgmt_se6,\n\t\t\tm->compute_static_thread_mgmt_se7);\n\t} else {\n\t\tpr_debug(\"inst: %u, update cu mask to %#x %#x %#x %#x\\n\",\n\t\t\tinst, m->compute_static_thread_mgmt_se0,\n\t\t\tm->compute_static_thread_mgmt_se1,\n\t\t\tm->compute_static_thread_mgmt_se2,\n\t\t\tm->compute_static_thread_mgmt_se3);\n\t}\n}\n\nstatic void set_priority(struct v9_mqd *m, struct queue_properties *q)\n{\n\tm->cp_hqd_pipe_priority = pipe_priority_map[q->priority];\n\tm->cp_hqd_queue_priority = q->priority;\n}\n\nstatic struct kfd_mem_obj *allocate_mqd(struct kfd_node *node,\n\t\tstruct queue_properties *q)\n{\n\tint retval;\n\tstruct kfd_mem_obj *mqd_mem_obj = NULL;\n\n\t \n\tif (node->kfd->cwsr_enabled && (q->type == KFD_QUEUE_TYPE_COMPUTE)) {\n\t\tmqd_mem_obj = kzalloc(sizeof(struct kfd_mem_obj), GFP_KERNEL);\n\t\tif (!mqd_mem_obj)\n\t\t\treturn NULL;\n\t\tretval = amdgpu_amdkfd_alloc_gtt_mem(node->adev,\n\t\t\t(ALIGN(q->ctl_stack_size, PAGE_SIZE) +\n\t\t\tALIGN(sizeof(struct v9_mqd), PAGE_SIZE)) *\n\t\t\tNUM_XCC(node->xcc_mask),\n\t\t\t&(mqd_mem_obj->gtt_mem),\n\t\t\t&(mqd_mem_obj->gpu_addr),\n\t\t\t(void *)&(mqd_mem_obj->cpu_ptr), true);\n\n\t\tif (retval) {\n\t\t\tkfree(mqd_mem_obj);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tretval = kfd_gtt_sa_allocate(node, sizeof(struct v9_mqd),\n\t\t\t\t&mqd_mem_obj);\n\t\tif (retval)\n\t\t\treturn NULL;\n\t}\n\n\treturn mqd_mem_obj;\n}\n\nstatic void init_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tuint64_t addr;\n\tstruct v9_mqd *m;\n\n\tm = (struct v9_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemset(m, 0, sizeof(struct v9_mqd));\n\n\tm->header = 0xC0310800;\n\tm->compute_pipelinestat_enable = 1;\n\tm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se4 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se5 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se6 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se7 = 0xFFFFFFFF;\n\n\tm->cp_hqd_persistent_state = CP_HQD_PERSISTENT_STATE__PRELOAD_REQ_MASK |\n\t\t\t0x53 << CP_HQD_PERSISTENT_STATE__PRELOAD_SIZE__SHIFT;\n\n\tm->cp_mqd_control = 1 << CP_MQD_CONTROL__PRIV_STATE__SHIFT;\n\n\tm->cp_mqd_base_addr_lo        = lower_32_bits(addr);\n\tm->cp_mqd_base_addr_hi        = upper_32_bits(addr);\n\n\tm->cp_hqd_quantum = 1 << CP_HQD_QUANTUM__QUANTUM_EN__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_SCALE__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_DURATION__SHIFT;\n\n\t \n\tm->cp_hqd_hq_status0 = 1 << 14;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL)\n\t\tm->cp_hqd_aql_control =\n\t\t\t1 << CP_HQD_AQL_CONTROL__CONTROL0__SHIFT;\n\n\tif (q->tba_addr) {\n\t\tm->compute_pgm_rsrc2 |=\n\t\t\t(1 << COMPUTE_PGM_RSRC2__TRAP_PRESENT__SHIFT);\n\t}\n\n\tif (mm->dev->kfd->cwsr_enabled && q->ctx_save_restore_area_address) {\n\t\tm->cp_hqd_persistent_state |=\n\t\t\t(1 << CP_HQD_PERSISTENT_STATE__QSWITCH_MODE__SHIFT);\n\t\tm->cp_hqd_ctx_save_base_addr_lo =\n\t\t\tlower_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_base_addr_hi =\n\t\t\tupper_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_size = q->ctx_save_restore_area_size;\n\t\tm->cp_hqd_cntl_stack_size = q->ctl_stack_size;\n\t\tm->cp_hqd_cntl_stack_offset = q->ctl_stack_size;\n\t\tm->cp_hqd_wg_state_offset = q->ctl_stack_size;\n\t}\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\tupdate_mqd(mm, m, q, NULL);\n}\n\nstatic int load_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tstruct queue_properties *p, struct mm_struct *mms)\n{\n\t \n\tuint32_t wptr_shift = (p->format == KFD_QUEUE_FORMAT_AQL ? 4 : 0);\n\n\treturn mm->dev->kfd2kgd->hqd_load(mm->dev->adev, mqd, pipe_id, queue_id,\n\t\t\t\t\t  (uint32_t __user *)p->write_ptr,\n\t\t\t\t\t  wptr_shift, 0, mms, 0);\n}\n\nstatic void update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct v9_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tm->cp_hqd_pq_control = 5 << CP_HQD_PQ_CONTROL__RPTR_BLOCK_SIZE__SHIFT;\n\tm->cp_hqd_pq_control |= order_base_2(q->queue_size / 4) - 1;\n\tpr_debug(\"cp_hqd_pq_control 0x%x\\n\", m->cp_hqd_pq_control);\n\n\tm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\n\n\tm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_lo = lower_32_bits((uint64_t)q->write_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits((uint64_t)q->write_ptr);\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tq->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tm->cp_hqd_ib_control =\n\t\t3 << CP_HQD_IB_CONTROL__MIN_IB_AVAIL_SIZE__SHIFT |\n\t\t1 << CP_HQD_IB_CONTROL__IB_EXE_DISABLE__SHIFT;\n\n\t \n\tm->cp_hqd_eop_control = q->eop_ring_buffer_size ?\n\t\tmin(0xA, order_base_2(q->eop_ring_buffer_size / 4) - 1) : 0;\n\n\tm->cp_hqd_eop_base_addr_lo =\n\t\t\tlower_32_bits(q->eop_ring_buffer_address >> 8);\n\tm->cp_hqd_eop_base_addr_hi =\n\t\t\tupper_32_bits(q->eop_ring_buffer_address >> 8);\n\n\tm->cp_hqd_iq_timer = 0;\n\n\tm->cp_hqd_vmid = q->vmid;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\tm->cp_hqd_pq_control |= CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK |\n\t\t\t\t2 << CP_HQD_PQ_CONTROL__SLOT_BASED_WPTR__SHIFT |\n\t\t\t\t1 << CP_HQD_PQ_CONTROL__QUEUE_FULL_EN__SHIFT |\n\t\t\t\t1 << CP_HQD_PQ_CONTROL__WPP_CLAMP_EN__SHIFT;\n\t\tm->cp_hqd_pq_doorbell_control |= 1 <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_BIF_DROP__SHIFT;\n\t}\n\tif (mm->dev->kfd->cwsr_enabled && q->ctx_save_restore_area_address)\n\t\tm->cp_hqd_ctx_save_control = 0;\n\n\tif (KFD_GC_VERSION(mm->dev) != IP_VERSION(9, 4, 3))\n\t\tupdate_cu_mask(mm, mqd, minfo, 0);\n\tset_priority(m, q);\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\n\nstatic uint32_t read_doorbell_id(void *mqd)\n{\n\tstruct v9_mqd *m = (struct v9_mqd *)mqd;\n\n\treturn m->queue_doorbell_id0;\n}\n\nstatic int get_wave_state(struct mqd_manager *mm, void *mqd,\n\t\t\t  struct queue_properties *q,\n\t\t\t  void __user *ctl_stack,\n\t\t\t  u32 *ctl_stack_used_size,\n\t\t\t  u32 *save_area_used_size)\n{\n\tstruct v9_mqd *m;\n\tstruct kfd_context_save_area_header header;\n\n\t \n\tvoid *mqd_ctl_stack = (void *)((uintptr_t)mqd + PAGE_SIZE);\n\n\tm = get_mqd(mqd);\n\n\t*ctl_stack_used_size = m->cp_hqd_cntl_stack_size -\n\t\tm->cp_hqd_cntl_stack_offset;\n\t*save_area_used_size = m->cp_hqd_wg_state_offset -\n\t\tm->cp_hqd_cntl_stack_size;\n\n\theader.wave_state.control_stack_size = *ctl_stack_used_size;\n\theader.wave_state.wave_state_size = *save_area_used_size;\n\n\theader.wave_state.wave_state_offset = m->cp_hqd_wg_state_offset;\n\theader.wave_state.control_stack_offset = m->cp_hqd_cntl_stack_offset;\n\n\tif (copy_to_user(ctl_stack, &header, sizeof(header.wave_state)))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(ctl_stack + m->cp_hqd_cntl_stack_offset,\n\t\t\t\tmqd_ctl_stack + m->cp_hqd_cntl_stack_offset,\n\t\t\t\t*ctl_stack_used_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void get_checkpoint_info(struct mqd_manager *mm, void *mqd, u32 *ctl_stack_size)\n{\n\tstruct v9_mqd *m = get_mqd(mqd);\n\n\t*ctl_stack_size = m->cp_hqd_cntl_stack_size;\n}\n\nstatic void checkpoint_mqd(struct mqd_manager *mm, void *mqd, void *mqd_dst, void *ctl_stack_dst)\n{\n\tstruct v9_mqd *m;\n\t \n\tvoid *ctl_stack = (void *)((uintptr_t)mqd + PAGE_SIZE);\n\n\tm = get_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct v9_mqd));\n\tmemcpy(ctl_stack_dst, ctl_stack, m->cp_hqd_cntl_stack_size);\n}\n\nstatic void restore_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *qp,\n\t\t\tconst void *mqd_src,\n\t\t\tconst void *ctl_stack_src, u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct v9_mqd *m;\n\tvoid *ctl_stack;\n\n\tm = (struct v9_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\t \n\tctl_stack = (void *)((uintptr_t)*mqd + PAGE_SIZE);\n\tmemcpy(ctl_stack, ctl_stack_src, ctl_stack_size);\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tqp->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tqp->is_active = 0;\n}\n\nstatic void init_mqd_hiq(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct v9_mqd *m;\n\n\tinit_mqd(mm, mqd, mqd_mem_obj, gart_addr, q);\n\n\tm = get_mqd(*mqd);\n\n\tm->cp_hqd_pq_control |= 1 << CP_HQD_PQ_CONTROL__PRIV_STATE__SHIFT |\n\t\t\t1 << CP_HQD_PQ_CONTROL__KMD_QUEUE__SHIFT;\n}\n\nstatic int destroy_hiq_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tenum kfd_preempt_type type, unsigned int timeout,\n\t\t\tuint32_t pipe_id, uint32_t queue_id)\n{\n\tint err;\n\tstruct v9_mqd *m;\n\tu32 doorbell_off;\n\n\tm = get_mqd(mqd);\n\n\tdoorbell_off = m->cp_hqd_pq_doorbell_control >>\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\terr = amdgpu_amdkfd_unmap_hiq(mm->dev->adev, doorbell_off, 0);\n\tif (err)\n\t\tpr_debug(\"Destroy HIQ MQD failed: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void init_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\tstruct queue_properties *q)\n{\n\tstruct v9_sdma_mqd *m;\n\n\tm = (struct v9_sdma_mqd *) mqd_mem_obj->cpu_ptr;\n\n\tmemset(m, 0, sizeof(struct v9_sdma_mqd));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = mqd_mem_obj->gpu_addr;\n\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\n#define SDMA_RLC_DUMMY_DEFAULT 0xf\n\nstatic void update_mqd_sdma(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct v9_sdma_mqd *m;\n\n\tm = get_sdma_mqd(mqd);\n\tm->sdmax_rlcx_rb_cntl = order_base_2(q->queue_size / 4)\n\t\t<< SDMA0_RLC0_RB_CNTL__RB_SIZE__SHIFT |\n\t\tq->vmid << SDMA0_RLC0_RB_CNTL__RB_VMID__SHIFT |\n\t\t1 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_ENABLE__SHIFT |\n\t\t6 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_TIMER__SHIFT;\n\n\tm->sdmax_rlcx_rb_base = lower_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_base_hi = upper_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_rptr_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_rb_rptr_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_doorbell_offset =\n\t\tq->doorbell_off << SDMA0_RLC0_DOORBELL_OFFSET__OFFSET__SHIFT;\n\n\tm->sdma_engine_id = q->sdma_engine_id;\n\tm->sdma_queue_id = q->sdma_queue_id;\n\tm->sdmax_rlcx_dummy_reg = SDMA_RLC_DUMMY_DEFAULT;\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic void checkpoint_mqd_sdma(struct mqd_manager *mm,\n\t\t\t\tvoid *mqd,\n\t\t\t\tvoid *mqd_dst,\n\t\t\t\tvoid *ctl_stack_dst)\n{\n\tstruct v9_sdma_mqd *m;\n\n\tm = get_sdma_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct v9_sdma_mqd));\n}\n\nstatic void restore_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\t\t     struct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\t     struct queue_properties *qp,\n\t\t\t     const void *mqd_src,\n\t\t\t     const void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct v9_sdma_mqd *m;\n\n\tm = (struct v9_sdma_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\tm->sdmax_rlcx_doorbell_offset =\n\t\tqp->doorbell_off << SDMA0_RLC0_DOORBELL_OFFSET__OFFSET__SHIFT;\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tqp->is_active = 0;\n}\n\nstatic void init_mqd_hiq_v9_4_3(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct v9_mqd *m;\n\tint xcc = 0;\n\tstruct kfd_mem_obj xcc_mqd_mem_obj;\n\tuint64_t xcc_gart_addr = 0;\n\n\tmemset(&xcc_mqd_mem_obj, 0x0, sizeof(struct kfd_mem_obj));\n\n\tfor (xcc = 0; xcc < NUM_XCC(mm->dev->xcc_mask); xcc++) {\n\t\tkfd_get_hiq_xcc_mqd(mm->dev, &xcc_mqd_mem_obj, xcc);\n\n\t\tinit_mqd(mm, (void **)&m, &xcc_mqd_mem_obj, &xcc_gart_addr, q);\n\n\t\tm->cp_hqd_pq_control |= CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK |\n\t\t\t\t\t1 << CP_HQD_PQ_CONTROL__PRIV_STATE__SHIFT |\n\t\t\t\t\t1 << CP_HQD_PQ_CONTROL__KMD_QUEUE__SHIFT;\n\t\tm->cp_mqd_stride_size = kfd_hiq_mqd_stride(mm->dev);\n\t\tif (xcc == 0) {\n\t\t\t \n\t\t\tm->cp_hqd_pq_control &= ~CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK;\n\n\t\t\t \n\t\t\t*mqd = m;\n\t\t\t*gart_addr = xcc_gart_addr;\n\t\t}\n\t}\n}\n\nstatic int hiq_load_mqd_kiq_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tstruct queue_properties *p, struct mm_struct *mms)\n{\n\tuint32_t xcc_mask = mm->dev->xcc_mask;\n\tint xcc_id, err, inst = 0;\n\tvoid *xcc_mqd;\n\tuint64_t hiq_mqd_size = kfd_hiq_mqd_stride(mm->dev);\n\n\tfor_each_inst(xcc_id, xcc_mask) {\n\t\txcc_mqd = mqd + hiq_mqd_size * inst;\n\t\terr = mm->dev->kfd2kgd->hiq_mqd_load(mm->dev->adev, xcc_mqd,\n\t\t\t\t\t\t     pipe_id, queue_id,\n\t\t\t\t\t\t     p->doorbell_off, xcc_id);\n\t\tif (err) {\n\t\t\tpr_debug(\"Failed to load HIQ MQD for XCC: %d\\n\", inst);\n\t\t\tbreak;\n\t\t}\n\t\t++inst;\n\t}\n\n\treturn err;\n}\n\nstatic int destroy_hiq_mqd_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t\tenum kfd_preempt_type type, unsigned int timeout,\n\t\t\tuint32_t pipe_id, uint32_t queue_id)\n{\n\tuint32_t xcc_mask = mm->dev->xcc_mask;\n\tint xcc_id, err, inst = 0;\n\tuint64_t hiq_mqd_size = kfd_hiq_mqd_stride(mm->dev);\n\tstruct v9_mqd *m;\n\tu32 doorbell_off;\n\n\tfor_each_inst(xcc_id, xcc_mask) {\n\t\tm = get_mqd(mqd + hiq_mqd_size * inst);\n\n\t\tdoorbell_off = m->cp_hqd_pq_doorbell_control >>\n\t\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\n\t\terr = amdgpu_amdkfd_unmap_hiq(mm->dev->adev, doorbell_off, xcc_id);\n\t\tif (err) {\n\t\t\tpr_debug(\"Destroy HIQ MQD failed for xcc: %d\\n\", inst);\n\t\t\tbreak;\n\t\t}\n\t\t++inst;\n\t}\n\n\treturn err;\n}\n\nstatic void get_xcc_mqd(struct kfd_mem_obj *mqd_mem_obj,\n\t\t\t       struct kfd_mem_obj *xcc_mqd_mem_obj,\n\t\t\t       uint64_t offset)\n{\n\txcc_mqd_mem_obj->gtt_mem = (offset == 0) ?\n\t\t\t\t\tmqd_mem_obj->gtt_mem : NULL;\n\txcc_mqd_mem_obj->gpu_addr = mqd_mem_obj->gpu_addr + offset;\n\txcc_mqd_mem_obj->cpu_ptr = (uint32_t *)((uintptr_t)mqd_mem_obj->cpu_ptr\n\t\t\t\t\t\t+ offset);\n}\n\nstatic void init_mqd_v9_4_3(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct v9_mqd *m;\n\tint xcc = 0;\n\tstruct kfd_mem_obj xcc_mqd_mem_obj;\n\tuint64_t xcc_gart_addr = 0;\n\tuint64_t xcc_ctx_save_restore_area_address;\n\tuint64_t offset = mm->mqd_stride(mm, q);\n\tuint32_t local_xcc_start = mm->dev->dqm->current_logical_xcc_start++;\n\n\tmemset(&xcc_mqd_mem_obj, 0x0, sizeof(struct kfd_mem_obj));\n\tfor (xcc = 0; xcc < NUM_XCC(mm->dev->xcc_mask); xcc++) {\n\t\tget_xcc_mqd(mqd_mem_obj, &xcc_mqd_mem_obj, offset*xcc);\n\n\t\tinit_mqd(mm, (void **)&m, &xcc_mqd_mem_obj, &xcc_gart_addr, q);\n\n\t\tm->cp_mqd_stride_size = offset;\n\n\t\t \n\t\tif (mm->dev->kfd->cwsr_enabled &&\n\t\t    q->ctx_save_restore_area_address) {\n\t\t\txcc_ctx_save_restore_area_address =\n\t\t\t\tq->ctx_save_restore_area_address +\n\t\t\t\t(xcc * q->ctx_save_restore_area_size);\n\n\t\t\tm->cp_hqd_ctx_save_base_addr_lo =\n\t\t\t\tlower_32_bits(xcc_ctx_save_restore_area_address);\n\t\t\tm->cp_hqd_ctx_save_base_addr_hi =\n\t\t\t\tupper_32_bits(xcc_ctx_save_restore_area_address);\n\t\t}\n\n\t\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\t\tm->compute_tg_chunk_size = 1;\n\t\t\tm->compute_current_logic_xcc_id =\n\t\t\t\t\t(local_xcc_start + xcc) %\n\t\t\t\t\tNUM_XCC(mm->dev->xcc_mask);\n\n\t\t\tswitch (xcc) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tm->cp_hqd_pq_control &=\n\t\t\t\t\t~CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tm->compute_current_logic_xcc_id = 0;\n\t\t\tm->compute_tg_chunk_size = 0;\n\t\t\tm->pm4_target_xcc_in_xcp = q->pm4_target_xcc;\n\t\t}\n\n\t\tif (xcc == 0) {\n\t\t\t \n\t\t\t*mqd = m;\n\t\t\t*gart_addr = xcc_gart_addr;\n\t\t}\n\t}\n}\n\nstatic void update_mqd_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t      struct queue_properties *q, struct mqd_update_info *minfo)\n{\n\tstruct v9_mqd *m;\n\tint xcc = 0;\n\tuint64_t size = mm->mqd_stride(mm, q);\n\n\tfor (xcc = 0; xcc < NUM_XCC(mm->dev->xcc_mask); xcc++) {\n\t\tm = get_mqd(mqd + size * xcc);\n\t\tupdate_mqd(mm, m, q, minfo);\n\n\t\tupdate_cu_mask(mm, mqd, minfo, xcc);\n\n\t\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\t\tswitch (xcc) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tm->cp_hqd_pq_control &=\n\t\t\t\t\t~CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm->compute_tg_chunk_size = 1;\n\t\t} else {\n\t\t\t \n\t\t\tm->compute_current_logic_xcc_id = 0;\n\t\t\tm->compute_tg_chunk_size = 0;\n\t\t\tm->pm4_target_xcc_in_xcp = q->pm4_target_xcc;\n\t\t}\n\t}\n}\n\nstatic int destroy_mqd_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t   enum kfd_preempt_type type, unsigned int timeout,\n\t\t   uint32_t pipe_id, uint32_t queue_id)\n{\n\tuint32_t xcc_mask = mm->dev->xcc_mask;\n\tint xcc_id, err, inst = 0;\n\tvoid *xcc_mqd;\n\tstruct v9_mqd *m;\n\tuint64_t mqd_offset;\n\n\tm = get_mqd(mqd);\n\tmqd_offset = m->cp_mqd_stride_size;\n\n\tfor_each_inst(xcc_id, xcc_mask) {\n\t\txcc_mqd = mqd + mqd_offset * inst;\n\t\terr = mm->dev->kfd2kgd->hqd_destroy(mm->dev->adev, xcc_mqd,\n\t\t\t\t\t\t    type, timeout, pipe_id,\n\t\t\t\t\t\t    queue_id, xcc_id);\n\t\tif (err) {\n\t\t\tpr_debug(\"Destroy MQD failed for xcc: %d\\n\", inst);\n\t\t\tbreak;\n\t\t}\n\t\t++inst;\n\t}\n\n\treturn err;\n}\n\nstatic int load_mqd_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tstruct queue_properties *p, struct mm_struct *mms)\n{\n\t \n\tuint32_t wptr_shift = (p->format == KFD_QUEUE_FORMAT_AQL ? 4 : 0);\n\tuint32_t xcc_mask = mm->dev->xcc_mask;\n\tint xcc_id, err, inst = 0;\n\tvoid *xcc_mqd;\n\tuint64_t mqd_stride_size = mm->mqd_stride(mm, p);\n\n\tfor_each_inst(xcc_id, xcc_mask) {\n\t\txcc_mqd = mqd + mqd_stride_size * inst;\n\t\terr = mm->dev->kfd2kgd->hqd_load(\n\t\t\tmm->dev->adev, xcc_mqd, pipe_id, queue_id,\n\t\t\t(uint32_t __user *)p->write_ptr, wptr_shift, 0, mms,\n\t\t\txcc_id);\n\t\tif (err) {\n\t\t\tpr_debug(\"Load MQD failed for xcc: %d\\n\", inst);\n\t\t\tbreak;\n\t\t}\n\t\t++inst;\n\t}\n\n\treturn err;\n}\n\nstatic int get_wave_state_v9_4_3(struct mqd_manager *mm, void *mqd,\n\t\t\t\t struct queue_properties *q,\n\t\t\t\t void __user *ctl_stack,\n\t\t\t\t u32 *ctl_stack_used_size,\n\t\t\t\t u32 *save_area_used_size)\n{\n\tint xcc, err = 0;\n\tvoid *xcc_mqd;\n\tvoid __user *xcc_ctl_stack;\n\tuint64_t mqd_stride_size = mm->mqd_stride(mm, q);\n\tu32 tmp_ctl_stack_used_size = 0, tmp_save_area_used_size = 0;\n\n\tfor (xcc = 0; xcc < NUM_XCC(mm->dev->xcc_mask); xcc++) {\n\t\txcc_mqd = mqd + mqd_stride_size * xcc;\n\t\txcc_ctl_stack = (void __user *)((uintptr_t)ctl_stack +\n\t\t\t\t\tq->ctx_save_restore_area_size * xcc);\n\n\t\terr = get_wave_state(mm, xcc_mqd, q, xcc_ctl_stack,\n\t\t\t\t     &tmp_ctl_stack_used_size,\n\t\t\t\t     &tmp_save_area_used_size);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tif (xcc == 0) {\n\t\t\t*ctl_stack_used_size = tmp_ctl_stack_used_size;\n\t\t\t*save_area_used_size = tmp_save_area_used_size;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic int debugfs_show_mqd(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct v9_mqd), false);\n\treturn 0;\n}\n\nstatic int debugfs_show_mqd_sdma(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct v9_sdma_mqd), false);\n\treturn 0;\n}\n\n#endif\n\nstruct mqd_manager *mqd_manager_init_v9(enum KFD_MQD_TYPE type,\n\t\tstruct kfd_node *dev)\n{\n\tstruct mqd_manager *mqd;\n\n\tif (WARN_ON(type >= KFD_MQD_TYPE_MAX))\n\t\treturn NULL;\n\n\tmqd = kzalloc(sizeof(*mqd), GFP_KERNEL);\n\tif (!mqd)\n\t\treturn NULL;\n\n\tmqd->dev = dev;\n\n\tswitch (type) {\n\tcase KFD_MQD_TYPE_CP:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->get_checkpoint_info = get_checkpoint_info;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd;\n\t\tmqd->restore_mqd = restore_mqd;\n\t\tmqd->mqd_size = sizeof(struct v9_mqd);\n\t\tmqd->mqd_stride = mqd_stride_v9;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tif (KFD_GC_VERSION(dev) == IP_VERSION(9, 4, 3)) {\n\t\t\tmqd->init_mqd = init_mqd_v9_4_3;\n\t\t\tmqd->load_mqd = load_mqd_v9_4_3;\n\t\t\tmqd->update_mqd = update_mqd_v9_4_3;\n\t\t\tmqd->destroy_mqd = destroy_mqd_v9_4_3;\n\t\t\tmqd->get_wave_state = get_wave_state_v9_4_3;\n\t\t} else {\n\t\t\tmqd->init_mqd = init_mqd;\n\t\t\tmqd->load_mqd = load_mqd;\n\t\t\tmqd->update_mqd = update_mqd;\n\t\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\t\tmqd->get_wave_state = get_wave_state;\n\t\t}\n\t\tbreak;\n\tcase KFD_MQD_TYPE_HIQ:\n\t\tmqd->allocate_mqd = allocate_hiq_mqd;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct v9_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tmqd->read_doorbell_id = read_doorbell_id;\n\t\tif (KFD_GC_VERSION(dev) == IP_VERSION(9, 4, 3)) {\n\t\t\tmqd->init_mqd = init_mqd_hiq_v9_4_3;\n\t\t\tmqd->load_mqd = hiq_load_mqd_kiq_v9_4_3;\n\t\t\tmqd->destroy_mqd = destroy_hiq_mqd_v9_4_3;\n\t\t} else {\n\t\t\tmqd->init_mqd = init_mqd_hiq;\n\t\t\tmqd->load_mqd = kfd_hiq_load_mqd_kiq;\n\t\t\tmqd->destroy_mqd = destroy_hiq_mqd;\n\t\t}\n\t\tbreak;\n\tcase KFD_MQD_TYPE_DIQ:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct v9_mqd);\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_SDMA:\n\t\tmqd->allocate_mqd = allocate_sdma_mqd;\n\t\tmqd->init_mqd = init_mqd_sdma;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = kfd_load_mqd_sdma;\n\t\tmqd->update_mqd = update_mqd_sdma;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_sdma;\n\t\tmqd->is_occupied = kfd_is_occupied_sdma;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd_sdma;\n\t\tmqd->restore_mqd = restore_mqd_sdma;\n\t\tmqd->mqd_size = sizeof(struct v9_sdma_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd_sdma;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tkfree(mqd);\n\t\treturn NULL;\n\t}\n\n\treturn mqd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}