{
  "module_name": "kfd_events.c",
  "hash_id": "4aa94ccfcea4b3507dac43c7e09f18e17b315f351cd7a17272cf6dcd7984bad1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_events.c",
  "human_readable_source": "\n \n\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/mm.h>\n#include <linux/uaccess.h>\n#include <linux/mman.h>\n#include <linux/memory.h>\n#include \"kfd_priv.h\"\n#include \"kfd_events.h\"\n#include <linux/device.h>\n\n \nstruct kfd_event_waiter {\n\twait_queue_entry_t wait;\n\tstruct kfd_event *event;  \n\tbool activated;\t\t  \n\tbool event_age_enabled;   \n};\n\n \nstruct kfd_signal_page {\n\tuint64_t *kernel_address;\n\tuint64_t __user *user_address;\n\tbool need_to_free_pages;\n};\n\nstatic uint64_t *page_slots(struct kfd_signal_page *page)\n{\n\treturn page->kernel_address;\n}\n\nstatic struct kfd_signal_page *allocate_signal_page(struct kfd_process *p)\n{\n\tvoid *backing_store;\n\tstruct kfd_signal_page *page;\n\n\tpage = kzalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page)\n\t\treturn NULL;\n\n\tbacking_store = (void *) __get_free_pages(GFP_KERNEL,\n\t\t\t\t\tget_order(KFD_SIGNAL_EVENT_LIMIT * 8));\n\tif (!backing_store)\n\t\tgoto fail_alloc_signal_store;\n\n\t \n\tmemset(backing_store, (uint8_t) UNSIGNALED_EVENT_SLOT,\n\t       KFD_SIGNAL_EVENT_LIMIT * 8);\n\n\tpage->kernel_address = backing_store;\n\tpage->need_to_free_pages = true;\n\tpr_debug(\"Allocated new event signal page at %p, for process %p\\n\",\n\t\t\tpage, p);\n\n\treturn page;\n\nfail_alloc_signal_store:\n\tkfree(page);\n\treturn NULL;\n}\n\nstatic int allocate_event_notification_slot(struct kfd_process *p,\n\t\t\t\t\t    struct kfd_event *ev,\n\t\t\t\t\t    const int *restore_id)\n{\n\tint id;\n\n\tif (!p->signal_page) {\n\t\tp->signal_page = allocate_signal_page(p);\n\t\tif (!p->signal_page)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tp->signal_mapped_size = 256*8;\n\t}\n\n\tif (restore_id) {\n\t\tid = idr_alloc(&p->event_idr, ev, *restore_id, *restore_id + 1,\n\t\t\t\tGFP_KERNEL);\n\t} else {\n\t\t \n\t\tid = idr_alloc(&p->event_idr, ev, 0, p->signal_mapped_size / 8,\n\t\t\t\tGFP_KERNEL);\n\t}\n\tif (id < 0)\n\t\treturn id;\n\n\tev->event_id = id;\n\tpage_slots(p->signal_page)[id] = UNSIGNALED_EVENT_SLOT;\n\n\treturn 0;\n}\n\n \nstatic struct kfd_event *lookup_event_by_id(struct kfd_process *p, uint32_t id)\n{\n\treturn idr_find(&p->event_idr, id);\n}\n\n \nstatic struct kfd_event *lookup_signaled_event_by_partial_id(\n\tstruct kfd_process *p, uint32_t id, uint32_t bits)\n{\n\tstruct kfd_event *ev;\n\n\tif (!p->signal_page || id >= KFD_SIGNAL_EVENT_LIMIT)\n\t\treturn NULL;\n\n\t \n\tif (bits > 31 || (1U << bits) >= KFD_SIGNAL_EVENT_LIMIT) {\n\t\tif (page_slots(p->signal_page)[id] == UNSIGNALED_EVENT_SLOT)\n\t\t\treturn NULL;\n\n\t\treturn idr_find(&p->event_idr, id);\n\t}\n\n\t \n\tfor (ev = NULL; id < KFD_SIGNAL_EVENT_LIMIT && !ev; id += 1U << bits) {\n\t\tif (page_slots(p->signal_page)[id] == UNSIGNALED_EVENT_SLOT)\n\t\t\tcontinue;\n\n\t\tev = idr_find(&p->event_idr, id);\n\t}\n\n\treturn ev;\n}\n\nstatic int create_signal_event(struct file *devkfd, struct kfd_process *p,\n\t\t\t\tstruct kfd_event *ev, const int *restore_id)\n{\n\tint ret;\n\n\tif (p->signal_mapped_size &&\n\t    p->signal_event_count == p->signal_mapped_size / 8) {\n\t\tif (!p->signal_event_limit_reached) {\n\t\t\tpr_debug(\"Signal event wasn't created because limit was reached\\n\");\n\t\t\tp->signal_event_limit_reached = true;\n\t\t}\n\t\treturn -ENOSPC;\n\t}\n\n\tret = allocate_event_notification_slot(p, ev, restore_id);\n\tif (ret) {\n\t\tpr_warn(\"Signal event wasn't created because out of kernel memory\\n\");\n\t\treturn ret;\n\t}\n\n\tp->signal_event_count++;\n\n\tev->user_signal_address = &p->signal_page->user_address[ev->event_id];\n\tpr_debug(\"Signal event number %zu created with id %d, address %p\\n\",\n\t\t\tp->signal_event_count, ev->event_id,\n\t\t\tev->user_signal_address);\n\n\treturn 0;\n}\n\nstatic int create_other_event(struct kfd_process *p, struct kfd_event *ev, const int *restore_id)\n{\n\tint id;\n\n\tif (restore_id)\n\t\tid = idr_alloc(&p->event_idr, ev, *restore_id, *restore_id + 1,\n\t\t\tGFP_KERNEL);\n\telse\n\t\t \n\t\tid = idr_alloc(&p->event_idr, ev, KFD_FIRST_NONSIGNAL_EVENT_ID,\n\t\t\t\t(uint32_t)KFD_LAST_NONSIGNAL_EVENT_ID + 1,\n\t\t\t\tGFP_KERNEL);\n\n\tif (id < 0)\n\t\treturn id;\n\tev->event_id = id;\n\n\treturn 0;\n}\n\nint kfd_event_init_process(struct kfd_process *p)\n{\n\tint id;\n\n\tmutex_init(&p->event_mutex);\n\tidr_init(&p->event_idr);\n\tp->signal_page = NULL;\n\tp->signal_event_count = 1;\n\t \n\tid = idr_alloc(&p->event_idr, NULL, 0, 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tidr_destroy(&p->event_idr);\n\t\tmutex_destroy(&p->event_mutex);\n\t\treturn id;\n\t}\n\treturn 0;\n}\n\nstatic void destroy_event(struct kfd_process *p, struct kfd_event *ev)\n{\n\tstruct kfd_event_waiter *waiter;\n\n\t \n\tspin_lock(&ev->lock);\n\tlist_for_each_entry(waiter, &ev->wq.head, wait.entry)\n\t\tWRITE_ONCE(waiter->event, NULL);\n\twake_up_all(&ev->wq);\n\tspin_unlock(&ev->lock);\n\n\tif (ev->type == KFD_EVENT_TYPE_SIGNAL ||\n\t    ev->type == KFD_EVENT_TYPE_DEBUG)\n\t\tp->signal_event_count--;\n\n\tidr_remove(&p->event_idr, ev->event_id);\n\tkfree_rcu(ev, rcu);\n}\n\nstatic void destroy_events(struct kfd_process *p)\n{\n\tstruct kfd_event *ev;\n\tuint32_t id;\n\n\tidr_for_each_entry(&p->event_idr, ev, id)\n\t\tif (ev)\n\t\t\tdestroy_event(p, ev);\n\tidr_destroy(&p->event_idr);\n\tmutex_destroy(&p->event_mutex);\n}\n\n \nstatic void shutdown_signal_page(struct kfd_process *p)\n{\n\tstruct kfd_signal_page *page = p->signal_page;\n\n\tif (page) {\n\t\tif (page->need_to_free_pages)\n\t\t\tfree_pages((unsigned long)page->kernel_address,\n\t\t\t\t   get_order(KFD_SIGNAL_EVENT_LIMIT * 8));\n\t\tkfree(page);\n\t}\n}\n\nvoid kfd_event_free_process(struct kfd_process *p)\n{\n\tdestroy_events(p);\n\tshutdown_signal_page(p);\n}\n\nstatic bool event_can_be_gpu_signaled(const struct kfd_event *ev)\n{\n\treturn ev->type == KFD_EVENT_TYPE_SIGNAL ||\n\t\t\t\t\tev->type == KFD_EVENT_TYPE_DEBUG;\n}\n\nstatic bool event_can_be_cpu_signaled(const struct kfd_event *ev)\n{\n\treturn ev->type == KFD_EVENT_TYPE_SIGNAL;\n}\n\nstatic int kfd_event_page_set(struct kfd_process *p, void *kernel_address,\n\t\t       uint64_t size, uint64_t user_handle)\n{\n\tstruct kfd_signal_page *page;\n\n\tif (p->signal_page)\n\t\treturn -EBUSY;\n\n\tpage = kzalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(kernel_address, (uint8_t) UNSIGNALED_EVENT_SLOT,\n\t       KFD_SIGNAL_EVENT_LIMIT * 8);\n\n\tpage->kernel_address = kernel_address;\n\n\tp->signal_page = page;\n\tp->signal_mapped_size = size;\n\tp->signal_handle = user_handle;\n\treturn 0;\n}\n\nint kfd_kmap_event_page(struct kfd_process *p, uint64_t event_page_offset)\n{\n\tstruct kfd_node *kfd;\n\tstruct kfd_process_device *pdd;\n\tvoid *mem, *kern_addr;\n\tuint64_t size;\n\tint err = 0;\n\n\tif (p->signal_page) {\n\t\tpr_err(\"Event page is already set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdd = kfd_process_device_data_by_id(p, GET_GPU_ID(event_page_offset));\n\tif (!pdd) {\n\t\tpr_err(\"Getting device by id failed in %s\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tkfd = pdd->dev;\n\n\tpdd = kfd_bind_process_to_device(kfd, p);\n\tif (IS_ERR(pdd))\n\t\treturn PTR_ERR(pdd);\n\n\tmem = kfd_process_device_translate_handle(pdd,\n\t\t\tGET_IDR_HANDLE(event_page_offset));\n\tif (!mem) {\n\t\tpr_err(\"Can't find BO, offset is 0x%llx\\n\", event_page_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = amdgpu_amdkfd_gpuvm_map_gtt_bo_to_kernel(mem, &kern_addr, &size);\n\tif (err) {\n\t\tpr_err(\"Failed to map event page to kernel\\n\");\n\t\treturn err;\n\t}\n\n\terr = kfd_event_page_set(p, kern_addr, size, event_page_offset);\n\tif (err) {\n\t\tpr_err(\"Failed to set event page\\n\");\n\t\tamdgpu_amdkfd_gpuvm_unmap_gtt_bo_from_kernel(mem);\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nint kfd_event_create(struct file *devkfd, struct kfd_process *p,\n\t\t     uint32_t event_type, bool auto_reset, uint32_t node_id,\n\t\t     uint32_t *event_id, uint32_t *event_trigger_data,\n\t\t     uint64_t *event_page_offset, uint32_t *event_slot_index)\n{\n\tint ret = 0;\n\tstruct kfd_event *ev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = event_type;\n\tev->auto_reset = auto_reset;\n\tev->signaled = false;\n\n\tspin_lock_init(&ev->lock);\n\tinit_waitqueue_head(&ev->wq);\n\n\t*event_page_offset = 0;\n\n\tmutex_lock(&p->event_mutex);\n\n\tswitch (event_type) {\n\tcase KFD_EVENT_TYPE_SIGNAL:\n\tcase KFD_EVENT_TYPE_DEBUG:\n\t\tret = create_signal_event(devkfd, p, ev, NULL);\n\t\tif (!ret) {\n\t\t\t*event_page_offset = KFD_MMAP_TYPE_EVENTS;\n\t\t\t*event_slot_index = ev->event_id;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = create_other_event(p, ev, NULL);\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\t*event_id = ev->event_id;\n\t\t*event_trigger_data = ev->event_id;\n\t\tev->event_age = 1;\n\t} else {\n\t\tkfree(ev);\n\t}\n\n\tmutex_unlock(&p->event_mutex);\n\n\treturn ret;\n}\n\nint kfd_criu_restore_event(struct file *devkfd,\n\t\t\t   struct kfd_process *p,\n\t\t\t   uint8_t __user *user_priv_ptr,\n\t\t\t   uint64_t *priv_data_offset,\n\t\t\t   uint64_t max_priv_data_size)\n{\n\tstruct kfd_criu_event_priv_data *ev_priv;\n\tstruct kfd_event *ev = NULL;\n\tint ret = 0;\n\n\tev_priv = kmalloc(sizeof(*ev_priv), GFP_KERNEL);\n\tif (!ev_priv)\n\t\treturn -ENOMEM;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tif (*priv_data_offset + sizeof(*ev_priv) > max_priv_data_size) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tret = copy_from_user(ev_priv, user_priv_ptr + *priv_data_offset, sizeof(*ev_priv));\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\t*priv_data_offset += sizeof(*ev_priv);\n\n\tif (ev_priv->user_handle) {\n\t\tret = kfd_kmap_event_page(p, ev_priv->user_handle);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tev->type = ev_priv->type;\n\tev->auto_reset = ev_priv->auto_reset;\n\tev->signaled = ev_priv->signaled;\n\n\tspin_lock_init(&ev->lock);\n\tinit_waitqueue_head(&ev->wq);\n\n\tmutex_lock(&p->event_mutex);\n\tswitch (ev->type) {\n\tcase KFD_EVENT_TYPE_SIGNAL:\n\tcase KFD_EVENT_TYPE_DEBUG:\n\t\tret = create_signal_event(devkfd, p, ev, &ev_priv->event_id);\n\t\tbreak;\n\tcase KFD_EVENT_TYPE_MEMORY:\n\t\tmemcpy(&ev->memory_exception_data,\n\t\t\t&ev_priv->memory_exception_data,\n\t\t\tsizeof(struct kfd_hsa_memory_exception_data));\n\n\t\tret = create_other_event(p, ev, &ev_priv->event_id);\n\t\tbreak;\n\tcase KFD_EVENT_TYPE_HW_EXCEPTION:\n\t\tmemcpy(&ev->hw_exception_data,\n\t\t\t&ev_priv->hw_exception_data,\n\t\t\tsizeof(struct kfd_hsa_hw_exception_data));\n\n\t\tret = create_other_event(p, ev, &ev_priv->event_id);\n\t\tbreak;\n\t}\n\tmutex_unlock(&p->event_mutex);\n\nexit:\n\tif (ret)\n\t\tkfree(ev);\n\n\tkfree(ev_priv);\n\n\treturn ret;\n}\n\nint kfd_criu_checkpoint_events(struct kfd_process *p,\n\t\t\t uint8_t __user *user_priv_data,\n\t\t\t uint64_t *priv_data_offset)\n{\n\tstruct kfd_criu_event_priv_data *ev_privs;\n\tint i = 0;\n\tint ret =  0;\n\tstruct kfd_event *ev;\n\tuint32_t ev_id;\n\n\tuint32_t num_events = kfd_get_num_events(p);\n\n\tif (!num_events)\n\t\treturn 0;\n\n\tev_privs = kvzalloc(num_events * sizeof(*ev_privs), GFP_KERNEL);\n\tif (!ev_privs)\n\t\treturn -ENOMEM;\n\n\n\tidr_for_each_entry(&p->event_idr, ev, ev_id) {\n\t\tstruct kfd_criu_event_priv_data *ev_priv;\n\n\t\t \n\t\tev_priv = &ev_privs[i];\n\n\t\tev_priv->object_type = KFD_CRIU_OBJECT_TYPE_EVENT;\n\n\t\t \n\t\tif (i == 0 && p->signal_page)\n\t\t\tev_priv->user_handle = p->signal_handle;\n\n\t\tev_priv->event_id = ev->event_id;\n\t\tev_priv->auto_reset = ev->auto_reset;\n\t\tev_priv->type = ev->type;\n\t\tev_priv->signaled = ev->signaled;\n\n\t\tif (ev_priv->type == KFD_EVENT_TYPE_MEMORY)\n\t\t\tmemcpy(&ev_priv->memory_exception_data,\n\t\t\t\t&ev->memory_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_memory_exception_data));\n\t\telse if (ev_priv->type == KFD_EVENT_TYPE_HW_EXCEPTION)\n\t\t\tmemcpy(&ev_priv->hw_exception_data,\n\t\t\t\t&ev->hw_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_hw_exception_data));\n\n\t\tpr_debug(\"Checkpointed event[%d] id = 0x%08x auto_reset = %x type = %x signaled = %x\\n\",\n\t\t\t  i,\n\t\t\t  ev_priv->event_id,\n\t\t\t  ev_priv->auto_reset,\n\t\t\t  ev_priv->type,\n\t\t\t  ev_priv->signaled);\n\t\ti++;\n\t}\n\n\tret = copy_to_user(user_priv_data + *priv_data_offset,\n\t\t\t   ev_privs, num_events * sizeof(*ev_privs));\n\tif (ret) {\n\t\tpr_err(\"Failed to copy events priv to user\\n\");\n\t\tret = -EFAULT;\n\t}\n\n\t*priv_data_offset += num_events * sizeof(*ev_privs);\n\n\tkvfree(ev_privs);\n\treturn ret;\n}\n\nint kfd_get_num_events(struct kfd_process *p)\n{\n\tstruct kfd_event *ev;\n\tuint32_t id;\n\tu32 num_events = 0;\n\n\tidr_for_each_entry(&p->event_idr, ev, id)\n\t\tnum_events++;\n\n\treturn num_events;\n}\n\n \nint kfd_event_destroy(struct kfd_process *p, uint32_t event_id)\n{\n\tstruct kfd_event *ev;\n\tint ret = 0;\n\n\tmutex_lock(&p->event_mutex);\n\n\tev = lookup_event_by_id(p, event_id);\n\n\tif (ev)\n\t\tdestroy_event(p, ev);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&p->event_mutex);\n\treturn ret;\n}\n\nstatic void set_event(struct kfd_event *ev)\n{\n\tstruct kfd_event_waiter *waiter;\n\n\t \n\tev->signaled = !ev->auto_reset || !waitqueue_active(&ev->wq);\n\tif (!(++ev->event_age)) {\n\t\t \n\t\tev->event_age = 2;\n\t\tWARN_ONCE(1, \"event_age wrap back!\");\n\t}\n\n\tlist_for_each_entry(waiter, &ev->wq.head, wait.entry)\n\t\tWRITE_ONCE(waiter->activated, true);\n\n\twake_up_all(&ev->wq);\n}\n\n \nint kfd_set_event(struct kfd_process *p, uint32_t event_id)\n{\n\tint ret = 0;\n\tstruct kfd_event *ev;\n\n\trcu_read_lock();\n\n\tev = lookup_event_by_id(p, event_id);\n\tif (!ev) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_rcu;\n\t}\n\tspin_lock(&ev->lock);\n\n\tif (event_can_be_cpu_signaled(ev))\n\t\tset_event(ev);\n\telse\n\t\tret = -EINVAL;\n\n\tspin_unlock(&ev->lock);\nunlock_rcu:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic void reset_event(struct kfd_event *ev)\n{\n\tev->signaled = false;\n}\n\n \nint kfd_reset_event(struct kfd_process *p, uint32_t event_id)\n{\n\tint ret = 0;\n\tstruct kfd_event *ev;\n\n\trcu_read_lock();\n\n\tev = lookup_event_by_id(p, event_id);\n\tif (!ev) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_rcu;\n\t}\n\tspin_lock(&ev->lock);\n\n\tif (event_can_be_cpu_signaled(ev))\n\t\treset_event(ev);\n\telse\n\t\tret = -EINVAL;\n\n\tspin_unlock(&ev->lock);\nunlock_rcu:\n\trcu_read_unlock();\n\treturn ret;\n\n}\n\nstatic void acknowledge_signal(struct kfd_process *p, struct kfd_event *ev)\n{\n\tWRITE_ONCE(page_slots(p->signal_page)[ev->event_id], UNSIGNALED_EVENT_SLOT);\n}\n\nstatic void set_event_from_interrupt(struct kfd_process *p,\n\t\t\t\t\tstruct kfd_event *ev)\n{\n\tif (ev && event_can_be_gpu_signaled(ev)) {\n\t\tacknowledge_signal(p, ev);\n\t\tspin_lock(&ev->lock);\n\t\tset_event(ev);\n\t\tspin_unlock(&ev->lock);\n\t}\n}\n\nvoid kfd_signal_event_interrupt(u32 pasid, uint32_t partial_id,\n\t\t\t\tuint32_t valid_id_bits)\n{\n\tstruct kfd_event *ev = NULL;\n\n\t \n\tstruct kfd_process *p = kfd_lookup_process_by_pasid(pasid);\n\n\tif (!p)\n\t\treturn;  \n\n\trcu_read_lock();\n\n\tif (valid_id_bits)\n\t\tev = lookup_signaled_event_by_partial_id(p, partial_id,\n\t\t\t\t\t\t\t valid_id_bits);\n\tif (ev) {\n\t\tset_event_from_interrupt(p, ev);\n\t} else if (p->signal_page) {\n\t\t \n\t\tuint64_t *slots = page_slots(p->signal_page);\n\t\tuint32_t id;\n\n\t\tif (valid_id_bits)\n\t\t\tpr_debug_ratelimited(\"Partial ID invalid: %u (%u valid bits)\\n\",\n\t\t\t\t\t     partial_id, valid_id_bits);\n\n\t\tif (p->signal_event_count < KFD_SIGNAL_EVENT_LIMIT / 64) {\n\t\t\t \n\t\t\tidr_for_each_entry(&p->event_idr, ev, id) {\n\t\t\t\tif (id >= KFD_SIGNAL_EVENT_LIMIT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (READ_ONCE(slots[id]) != UNSIGNALED_EVENT_SLOT)\n\t\t\t\t\tset_event_from_interrupt(p, ev);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tfor (id = 1; id < KFD_SIGNAL_EVENT_LIMIT; id++)\n\t\t\t\tif (READ_ONCE(slots[id]) != UNSIGNALED_EVENT_SLOT) {\n\t\t\t\t\tev = lookup_event_by_id(p, id);\n\t\t\t\t\tset_event_from_interrupt(p, ev);\n\t\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tkfd_unref_process(p);\n}\n\nstatic struct kfd_event_waiter *alloc_event_waiters(uint32_t num_events)\n{\n\tstruct kfd_event_waiter *event_waiters;\n\tuint32_t i;\n\n\tevent_waiters = kcalloc(num_events, sizeof(struct kfd_event_waiter),\n\t\t\t\tGFP_KERNEL);\n\tif (!event_waiters)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_events; i++)\n\t\tinit_wait(&event_waiters[i].wait);\n\n\treturn event_waiters;\n}\n\nstatic int init_event_waiter(struct kfd_process *p,\n\t\tstruct kfd_event_waiter *waiter,\n\t\tstruct kfd_event_data *event_data)\n{\n\tstruct kfd_event *ev = lookup_event_by_id(p, event_data->event_id);\n\n\tif (!ev)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ev->lock);\n\twaiter->event = ev;\n\twaiter->activated = ev->signaled;\n\tev->signaled = ev->signaled && !ev->auto_reset;\n\n\t \n\tif (waiter->event->type == KFD_EVENT_TYPE_SIGNAL &&\n\t\tevent_data->signal_event_data.last_event_age) {\n\t\twaiter->event_age_enabled = true;\n\t\tif (ev->event_age != event_data->signal_event_data.last_event_age)\n\t\t\twaiter->activated = true;\n\t}\n\n\tif (!waiter->activated)\n\t\tadd_wait_queue(&ev->wq, &waiter->wait);\n\tspin_unlock(&ev->lock);\n\n\treturn 0;\n}\n\n \nstatic uint32_t test_event_condition(bool all, uint32_t num_events,\n\t\t\t\tstruct kfd_event_waiter *event_waiters)\n{\n\tuint32_t i;\n\tuint32_t activated_count = 0;\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tif (!READ_ONCE(event_waiters[i].event))\n\t\t\treturn KFD_IOC_WAIT_RESULT_FAIL;\n\n\t\tif (READ_ONCE(event_waiters[i].activated)) {\n\t\t\tif (!all)\n\t\t\t\treturn KFD_IOC_WAIT_RESULT_COMPLETE;\n\n\t\t\tactivated_count++;\n\t\t}\n\t}\n\n\treturn activated_count == num_events ?\n\t\tKFD_IOC_WAIT_RESULT_COMPLETE : KFD_IOC_WAIT_RESULT_TIMEOUT;\n}\n\n \nstatic int copy_signaled_event_data(uint32_t num_events,\n\t\tstruct kfd_event_waiter *event_waiters,\n\t\tstruct kfd_event_data __user *data)\n{\n\tvoid *src;\n\tvoid __user *dst;\n\tstruct kfd_event_waiter *waiter;\n\tstruct kfd_event *event;\n\tuint32_t i, size = 0;\n\n\tfor (i = 0; i < num_events; i++) {\n\t\twaiter = &event_waiters[i];\n\t\tevent = waiter->event;\n\t\tif (!event)\n\t\t\treturn -EINVAL;  \n\t\tif (waiter->activated) {\n\t\t\tif (event->type == KFD_EVENT_TYPE_MEMORY) {\n\t\t\t\tdst = &data[i].memory_exception_data;\n\t\t\t\tsrc = &event->memory_exception_data;\n\t\t\t\tsize = sizeof(struct kfd_hsa_memory_exception_data);\n\t\t\t} else if (event->type == KFD_EVENT_TYPE_SIGNAL &&\n\t\t\t\twaiter->event_age_enabled) {\n\t\t\t\tdst = &data[i].signal_event_data.last_event_age;\n\t\t\t\tsrc = &event->event_age;\n\t\t\t\tsize = sizeof(u64);\n\t\t\t}\n\t\t\tif (size && copy_to_user(dst, src, size))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long user_timeout_to_jiffies(uint32_t user_timeout_ms)\n{\n\tif (user_timeout_ms == KFD_EVENT_TIMEOUT_IMMEDIATE)\n\t\treturn 0;\n\n\tif (user_timeout_ms == KFD_EVENT_TIMEOUT_INFINITE)\n\t\treturn MAX_SCHEDULE_TIMEOUT;\n\n\t \n\tuser_timeout_ms = min_t(uint32_t, user_timeout_ms, 0x7FFFFFFF);\n\n\treturn msecs_to_jiffies(user_timeout_ms) + 1;\n}\n\nstatic void free_waiters(uint32_t num_events, struct kfd_event_waiter *waiters,\n\t\t\t bool undo_auto_reset)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < num_events; i++)\n\t\tif (waiters[i].event) {\n\t\t\tspin_lock(&waiters[i].event->lock);\n\t\t\tremove_wait_queue(&waiters[i].event->wq,\n\t\t\t\t\t  &waiters[i].wait);\n\t\t\tif (undo_auto_reset && waiters[i].activated &&\n\t\t\t    waiters[i].event && waiters[i].event->auto_reset)\n\t\t\t\tset_event(waiters[i].event);\n\t\t\tspin_unlock(&waiters[i].event->lock);\n\t\t}\n\n\tkfree(waiters);\n}\n\nint kfd_wait_on_events(struct kfd_process *p,\n\t\t       uint32_t num_events, void __user *data,\n\t\t       bool all, uint32_t *user_timeout_ms,\n\t\t       uint32_t *wait_result)\n{\n\tstruct kfd_event_data __user *events =\n\t\t\t(struct kfd_event_data __user *) data;\n\tuint32_t i;\n\tint ret = 0;\n\n\tstruct kfd_event_waiter *event_waiters = NULL;\n\tlong timeout = user_timeout_to_jiffies(*user_timeout_ms);\n\n\tevent_waiters = alloc_event_waiters(num_events);\n\tif (!event_waiters) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&p->event_mutex);\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tstruct kfd_event_data event_data;\n\n\t\tif (copy_from_user(&event_data, &events[i],\n\t\t\t\tsizeof(struct kfd_event_data))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tret = init_event_waiter(p, &event_waiters[i], &event_data);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\t*wait_result = test_event_condition(all, num_events, event_waiters);\n\tif (*wait_result == KFD_IOC_WAIT_RESULT_COMPLETE) {\n\t\tret = copy_signaled_event_data(num_events,\n\t\t\t\t\t       event_waiters, events);\n\t\tgoto out_unlock;\n\t} else if (WARN_ON(*wait_result == KFD_IOC_WAIT_RESULT_FAIL)) {\n\t\t \n\t\tgoto out_unlock;\n\t}\n\n\tmutex_unlock(&p->event_mutex);\n\n\twhile (true) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tif (*user_timeout_ms != KFD_EVENT_TIMEOUT_IMMEDIATE &&\n\t\t\t    *user_timeout_ms != KFD_EVENT_TIMEOUT_INFINITE)\n\t\t\t\t*user_timeout_ms = jiffies_to_msecs(\n\t\t\t\t\tmax(0l, timeout-1));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t*wait_result = test_event_condition(all, num_events,\n\t\t\t\t\t\t    event_waiters);\n\t\tif (*wait_result != KFD_IOC_WAIT_RESULT_TIMEOUT)\n\t\t\tbreak;\n\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\n\t\ttimeout = schedule_timeout(timeout);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tmutex_lock(&p->event_mutex);\n\t \n\tif (!ret && *wait_result == KFD_IOC_WAIT_RESULT_COMPLETE)\n\t\tret = copy_signaled_event_data(num_events,\n\t\t\t\t\t       event_waiters, events);\n\nout_unlock:\n\tfree_waiters(num_events, event_waiters, ret == -ERESTARTSYS);\n\tmutex_unlock(&p->event_mutex);\nout:\n\tif (ret)\n\t\t*wait_result = KFD_IOC_WAIT_RESULT_FAIL;\n\telse if (*wait_result == KFD_IOC_WAIT_RESULT_FAIL)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nint kfd_event_mmap(struct kfd_process *p, struct vm_area_struct *vma)\n{\n\tunsigned long pfn;\n\tstruct kfd_signal_page *page;\n\tint ret;\n\n\t \n\tif (get_order(KFD_SIGNAL_EVENT_LIMIT * 8) <\n\t\t\tget_order(vma->vm_end - vma->vm_start)) {\n\t\tpr_err(\"Event page mmap requested illegal size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpage = p->signal_page;\n\tif (!page) {\n\t\t \n\t\tpr_debug(\"Signal page could not be found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpfn = __pa(page->kernel_address);\n\tpfn >>= PAGE_SHIFT;\n\n\tvm_flags_set(vma, VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_NORESERVE\n\t\t       | VM_DONTDUMP | VM_PFNMAP);\n\n\tpr_debug(\"Mapping signal page\\n\");\n\tpr_debug(\"     start user address  == 0x%08lx\\n\", vma->vm_start);\n\tpr_debug(\"     end user address    == 0x%08lx\\n\", vma->vm_end);\n\tpr_debug(\"     pfn                 == 0x%016lX\\n\", pfn);\n\tpr_debug(\"     vm_flags            == 0x%08lX\\n\", vma->vm_flags);\n\tpr_debug(\"     size                == 0x%08lX\\n\",\n\t\t\tvma->vm_end - vma->vm_start);\n\n\tpage->user_address = (uint64_t __user *)vma->vm_start;\n\n\t \n\tret = remap_pfn_range(vma, vma->vm_start, pfn,\n\t\t\tvma->vm_end - vma->vm_start, vma->vm_page_prot);\n\tif (!ret)\n\t\tp->signal_mapped_size = vma->vm_end - vma->vm_start;\n\n\treturn ret;\n}\n\n \nstatic void lookup_events_by_type_and_signal(struct kfd_process *p,\n\t\tint type, void *event_data)\n{\n\tstruct kfd_hsa_memory_exception_data *ev_data;\n\tstruct kfd_event *ev;\n\tuint32_t id;\n\tbool send_signal = true;\n\n\tev_data = (struct kfd_hsa_memory_exception_data *) event_data;\n\n\trcu_read_lock();\n\n\tid = KFD_FIRST_NONSIGNAL_EVENT_ID;\n\tidr_for_each_entry_continue(&p->event_idr, ev, id)\n\t\tif (ev->type == type) {\n\t\t\tsend_signal = false;\n\t\t\tdev_dbg(kfd_device,\n\t\t\t\t\t\"Event found: id %X type %d\",\n\t\t\t\t\tev->event_id, ev->type);\n\t\t\tspin_lock(&ev->lock);\n\t\t\tset_event(ev);\n\t\t\tif (ev->type == KFD_EVENT_TYPE_MEMORY && ev_data)\n\t\t\t\tev->memory_exception_data = *ev_data;\n\t\t\tspin_unlock(&ev->lock);\n\t\t}\n\n\tif (type == KFD_EVENT_TYPE_MEMORY) {\n\t\tdev_warn(kfd_device,\n\t\t\t\"Sending SIGSEGV to process %d (pasid 0x%x)\",\n\t\t\t\tp->lead_thread->pid, p->pasid);\n\t\tsend_sig(SIGSEGV, p->lead_thread, 0);\n\t}\n\n\t \n\tif (send_signal) {\n\t\tif (send_sigterm) {\n\t\t\tdev_warn(kfd_device,\n\t\t\t\t\"Sending SIGTERM to process %d (pasid 0x%x)\",\n\t\t\t\t\tp->lead_thread->pid, p->pasid);\n\t\t\tsend_sig(SIGTERM, p->lead_thread, 0);\n\t\t} else {\n\t\t\tdev_err(kfd_device,\n\t\t\t\t\"Process %d (pasid 0x%x) got unhandled exception\",\n\t\t\t\tp->lead_thread->pid, p->pasid);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid kfd_signal_hw_exception_event(u32 pasid)\n{\n\t \n\tstruct kfd_process *p = kfd_lookup_process_by_pasid(pasid);\n\n\tif (!p)\n\t\treturn;  \n\n\tlookup_events_by_type_and_signal(p, KFD_EVENT_TYPE_HW_EXCEPTION, NULL);\n\tkfd_unref_process(p);\n}\n\nvoid kfd_signal_vm_fault_event(struct kfd_node *dev, u32 pasid,\n\t\t\t\tstruct kfd_vm_fault_info *info,\n\t\t\t\tstruct kfd_hsa_memory_exception_data *data)\n{\n\tstruct kfd_event *ev;\n\tuint32_t id;\n\tstruct kfd_process *p = kfd_lookup_process_by_pasid(pasid);\n\tstruct kfd_hsa_memory_exception_data memory_exception_data;\n\tint user_gpu_id;\n\n\tif (!p)\n\t\treturn;  \n\n\tuser_gpu_id = kfd_process_get_user_gpu_id(p, dev->id);\n\tif (unlikely(user_gpu_id == -EINVAL)) {\n\t\tWARN_ONCE(1, \"Could not get user_gpu_id from dev->id:%x\\n\", dev->id);\n\t\treturn;\n\t}\n\n\t \n\tif (!data) {\n\t\tmemset(&memory_exception_data, 0, sizeof(memory_exception_data));\n\t\tmemory_exception_data.gpu_id = user_gpu_id;\n\t\tmemory_exception_data.failure.imprecise = true;\n\n\t\t \n\t\tif (info) {\n\t\t\tmemory_exception_data.va = (info->page_addr) <<\n\t\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\tmemory_exception_data.failure.NotPresent =\n\t\t\t\tinfo->prot_valid ? 1 : 0;\n\t\t\tmemory_exception_data.failure.NoExecute =\n\t\t\t\tinfo->prot_exec ? 1 : 0;\n\t\t\tmemory_exception_data.failure.ReadOnly =\n\t\t\t\tinfo->prot_write ? 1 : 0;\n\t\t\tmemory_exception_data.failure.imprecise = 0;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\n\tid = KFD_FIRST_NONSIGNAL_EVENT_ID;\n\tidr_for_each_entry_continue(&p->event_idr, ev, id)\n\t\tif (ev->type == KFD_EVENT_TYPE_MEMORY) {\n\t\t\tspin_lock(&ev->lock);\n\t\t\tev->memory_exception_data = data ? *data :\n\t\t\t\t\t\t\tmemory_exception_data;\n\t\t\tset_event(ev);\n\t\t\tspin_unlock(&ev->lock);\n\t\t}\n\n\trcu_read_unlock();\n\tkfd_unref_process(p);\n}\n\nvoid kfd_signal_reset_event(struct kfd_node *dev)\n{\n\tstruct kfd_hsa_hw_exception_data hw_exception_data;\n\tstruct kfd_hsa_memory_exception_data memory_exception_data;\n\tstruct kfd_process *p;\n\tstruct kfd_event *ev;\n\tunsigned int temp;\n\tuint32_t id, idx;\n\tint reset_cause = atomic_read(&dev->sram_ecc_flag) ?\n\t\t\tKFD_HW_EXCEPTION_ECC :\n\t\t\tKFD_HW_EXCEPTION_GPU_HANG;\n\n\t \n\tmemset(&hw_exception_data, 0, sizeof(hw_exception_data));\n\thw_exception_data.memory_lost = 1;\n\thw_exception_data.reset_cause = reset_cause;\n\n\tmemset(&memory_exception_data, 0, sizeof(memory_exception_data));\n\tmemory_exception_data.ErrorType = KFD_MEM_ERR_SRAM_ECC;\n\tmemory_exception_data.failure.imprecise = true;\n\n\tidx = srcu_read_lock(&kfd_processes_srcu);\n\thash_for_each_rcu(kfd_processes_table, temp, p, kfd_processes) {\n\t\tint user_gpu_id = kfd_process_get_user_gpu_id(p, dev->id);\n\n\t\tif (unlikely(user_gpu_id == -EINVAL)) {\n\t\t\tWARN_ONCE(1, \"Could not get user_gpu_id from dev->id:%x\\n\", dev->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\trcu_read_lock();\n\n\t\tid = KFD_FIRST_NONSIGNAL_EVENT_ID;\n\t\tidr_for_each_entry_continue(&p->event_idr, ev, id) {\n\t\t\tif (ev->type == KFD_EVENT_TYPE_HW_EXCEPTION) {\n\t\t\t\tspin_lock(&ev->lock);\n\t\t\t\tev->hw_exception_data = hw_exception_data;\n\t\t\t\tev->hw_exception_data.gpu_id = user_gpu_id;\n\t\t\t\tset_event(ev);\n\t\t\t\tspin_unlock(&ev->lock);\n\t\t\t}\n\t\t\tif (ev->type == KFD_EVENT_TYPE_MEMORY &&\n\t\t\t    reset_cause == KFD_HW_EXCEPTION_ECC) {\n\t\t\t\tspin_lock(&ev->lock);\n\t\t\t\tev->memory_exception_data = memory_exception_data;\n\t\t\t\tev->memory_exception_data.gpu_id = user_gpu_id;\n\t\t\t\tset_event(ev);\n\t\t\t\tspin_unlock(&ev->lock);\n\t\t\t}\n\t\t}\n\n\t\trcu_read_unlock();\n\t}\n\tsrcu_read_unlock(&kfd_processes_srcu, idx);\n}\n\nvoid kfd_signal_poison_consumed_event(struct kfd_node *dev, u32 pasid)\n{\n\tstruct kfd_process *p = kfd_lookup_process_by_pasid(pasid);\n\tstruct kfd_hsa_memory_exception_data memory_exception_data;\n\tstruct kfd_hsa_hw_exception_data hw_exception_data;\n\tstruct kfd_event *ev;\n\tuint32_t id = KFD_FIRST_NONSIGNAL_EVENT_ID;\n\tint user_gpu_id;\n\n\tif (!p)\n\t\treturn;  \n\n\tuser_gpu_id = kfd_process_get_user_gpu_id(p, dev->id);\n\tif (unlikely(user_gpu_id == -EINVAL)) {\n\t\tWARN_ONCE(1, \"Could not get user_gpu_id from dev->id:%x\\n\", dev->id);\n\t\treturn;\n\t}\n\n\tmemset(&hw_exception_data, 0, sizeof(hw_exception_data));\n\thw_exception_data.gpu_id = user_gpu_id;\n\thw_exception_data.memory_lost = 1;\n\thw_exception_data.reset_cause = KFD_HW_EXCEPTION_ECC;\n\n\tmemset(&memory_exception_data, 0, sizeof(memory_exception_data));\n\tmemory_exception_data.ErrorType = KFD_MEM_ERR_POISON_CONSUMED;\n\tmemory_exception_data.gpu_id = user_gpu_id;\n\tmemory_exception_data.failure.imprecise = true;\n\n\trcu_read_lock();\n\n\tidr_for_each_entry_continue(&p->event_idr, ev, id) {\n\t\tif (ev->type == KFD_EVENT_TYPE_HW_EXCEPTION) {\n\t\t\tspin_lock(&ev->lock);\n\t\t\tev->hw_exception_data = hw_exception_data;\n\t\t\tset_event(ev);\n\t\t\tspin_unlock(&ev->lock);\n\t\t}\n\n\t\tif (ev->type == KFD_EVENT_TYPE_MEMORY) {\n\t\t\tspin_lock(&ev->lock);\n\t\t\tev->memory_exception_data = memory_exception_data;\n\t\t\tset_event(ev);\n\t\t\tspin_unlock(&ev->lock);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tsend_sig(SIGBUS, p->lead_thread, 0);\n\n\tkfd_unref_process(p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}