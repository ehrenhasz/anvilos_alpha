{
  "module_name": "cwsr_trap_handler_gfx10.asm",
  "hash_id": "aac5bc5ed7918947a8ac78498c62e077d8977563043af4bcf0410cb07b2db470",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/cwsr_trap_handler_gfx10.asm",
  "human_readable_source": "/*\n * Copyright 2018 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* To compile this assembly code:\n *\n * Navi1x:\n *   cpp -DASIC_FAMILY=CHIP_NAVI10 cwsr_trap_handler_gfx10.asm -P -o nv1x.sp3\n *   sp3 nv1x.sp3 -hex nv1x.hex\n *\n * gfx10:\n *   cpp -DASIC_FAMILY=CHIP_SIENNA_CICHLID cwsr_trap_handler_gfx10.asm -P -o gfx10.sp3\n *   sp3 gfx10.sp3 -hex gfx10.hex\n *\n * gfx11:\n *   cpp -DASIC_FAMILY=CHIP_PLUM_BONITO cwsr_trap_handler_gfx10.asm -P -o gfx11.sp3\n *   sp3 gfx11.sp3 -hex gfx11.hex\n */\n\n#define CHIP_NAVI10 26\n#define CHIP_SIENNA_CICHLID 30\n#define CHIP_PLUM_BONITO 36\n\n#define NO_SQC_STORE (ASIC_FAMILY >= CHIP_SIENNA_CICHLID)\n#define HAVE_XNACK (ASIC_FAMILY < CHIP_SIENNA_CICHLID)\n#define HAVE_SENDMSG_RTN (ASIC_FAMILY >= CHIP_PLUM_BONITO)\n#define HAVE_BUFFER_LDS_LOAD (ASIC_FAMILY < CHIP_PLUM_BONITO)\n#define SW_SA_TRAP (ASIC_FAMILY >= CHIP_PLUM_BONITO)\n\nvar SINGLE_STEP_MISSED_WORKAROUND\t\t= 1\t//workaround for lost MODE.DEBUG_EN exception when SAVECTX raised\n\nvar SQ_WAVE_STATUS_SPI_PRIO_MASK\t\t= 0x00000006\nvar SQ_WAVE_STATUS_HALT_MASK\t\t\t= 0x2000\nvar SQ_WAVE_STATUS_ECC_ERR_MASK\t\t\t= 0x20000\nvar SQ_WAVE_STATUS_TRAP_EN_SHIFT\t\t= 6\n\nvar SQ_WAVE_LDS_ALLOC_LDS_SIZE_SHIFT\t\t= 12\nvar SQ_WAVE_LDS_ALLOC_LDS_SIZE_SIZE\t\t= 9\nvar SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SIZE\t\t= 8\nvar SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SHIFT\t= 24\nvar SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SIZE\t= 4\nvar SQ_WAVE_IB_STS2_WAVE64_SHIFT\t\t= 11\nvar SQ_WAVE_IB_STS2_WAVE64_SIZE\t\t\t= 1\n\n#if ASIC_FAMILY < CHIP_PLUM_BONITO\nvar SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SHIFT\t\t= 8\n#else\nvar SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SHIFT\t\t= 12\n#endif\n\nvar SQ_WAVE_TRAPSTS_SAVECTX_MASK\t\t= 0x400\nvar SQ_WAVE_TRAPSTS_EXCP_MASK\t\t\t= 0x1FF\nvar SQ_WAVE_TRAPSTS_SAVECTX_SHIFT\t\t= 10\nvar SQ_WAVE_TRAPSTS_ADDR_WATCH_MASK\t\t= 0x80\nvar SQ_WAVE_TRAPSTS_ADDR_WATCH_SHIFT\t\t= 7\nvar SQ_WAVE_TRAPSTS_MEM_VIOL_MASK\t\t= 0x100\nvar SQ_WAVE_TRAPSTS_MEM_VIOL_SHIFT\t\t= 8\nvar SQ_WAVE_TRAPSTS_PRE_SAVECTX_MASK\t\t= 0x3FF\nvar SQ_WAVE_TRAPSTS_PRE_SAVECTX_SHIFT\t\t= 0x0\nvar SQ_WAVE_TRAPSTS_PRE_SAVECTX_SIZE\t\t= 10\nvar SQ_WAVE_TRAPSTS_POST_SAVECTX_MASK\t\t= 0xFFFFF800\nvar SQ_WAVE_TRAPSTS_POST_SAVECTX_SHIFT\t\t= 11\nvar SQ_WAVE_TRAPSTS_POST_SAVECTX_SIZE\t\t= 21\nvar SQ_WAVE_TRAPSTS_ILLEGAL_INST_MASK\t\t= 0x800\nvar SQ_WAVE_TRAPSTS_EXCP_HI_MASK\t\t= 0x7000\n\nvar SQ_WAVE_MODE_EXCP_EN_SHIFT\t\t\t= 12\nvar SQ_WAVE_MODE_EXCP_EN_ADDR_WATCH_SHIFT\t= 19\n\nvar SQ_WAVE_IB_STS_FIRST_REPLAY_SHIFT\t\t= 15\nvar SQ_WAVE_IB_STS_REPLAY_W64H_SHIFT\t\t= 25\nvar SQ_WAVE_IB_STS_REPLAY_W64H_MASK\t\t= 0x02000000\nvar SQ_WAVE_IB_STS_RCNT_FIRST_REPLAY_MASK\t= 0x003F8000\n\nvar SQ_WAVE_MODE_DEBUG_EN_MASK\t\t\t= 0x800\n\n// bits [31:24] unused by SPI debug data\nvar TTMP11_SAVE_REPLAY_W64H_SHIFT\t\t= 31\nvar TTMP11_SAVE_REPLAY_W64H_MASK\t\t= 0x80000000\nvar TTMP11_SAVE_RCNT_FIRST_REPLAY_SHIFT\t\t= 24\nvar TTMP11_SAVE_RCNT_FIRST_REPLAY_MASK\t\t= 0x7F000000\nvar TTMP11_DEBUG_TRAP_ENABLED_SHIFT\t\t= 23\nvar TTMP11_DEBUG_TRAP_ENABLED_MASK\t\t= 0x800000\n\n// SQ_SEL_X/Y/Z/W, BUF_NUM_FORMAT_FLOAT, (0 for MUBUF stride[17:14]\n// when ADD_TID_ENABLE and BUF_DATA_FORMAT_32 for MTBUF), ADD_TID_ENABLE\nvar S_SAVE_BUF_RSRC_WORD1_STRIDE\t\t= 0x00040000\nvar S_SAVE_BUF_RSRC_WORD3_MISC\t\t\t= 0x10807FAC\nvar S_SAVE_PC_HI_TRAP_ID_MASK\t\t\t= 0x00FF0000\nvar S_SAVE_PC_HI_HT_MASK\t\t\t= 0x01000000\nvar S_SAVE_SPI_INIT_FIRST_WAVE_MASK\t\t= 0x04000000\nvar S_SAVE_SPI_INIT_FIRST_WAVE_SHIFT\t\t= 26\n\nvar S_SAVE_PC_HI_FIRST_WAVE_MASK\t\t= 0x80000000\nvar S_SAVE_PC_HI_FIRST_WAVE_SHIFT\t\t= 31\n\nvar s_sgpr_save_num\t\t\t\t= 108\n\nvar s_save_spi_init_lo\t\t\t\t= exec_lo\nvar s_save_spi_init_hi\t\t\t\t= exec_hi\nvar s_save_pc_lo\t\t\t\t= ttmp0\nvar s_save_pc_hi\t\t\t\t= ttmp1\nvar s_save_exec_lo\t\t\t\t= ttmp2\nvar s_save_exec_hi\t\t\t\t= ttmp3\nvar s_save_status\t\t\t\t= ttmp12\nvar s_save_trapsts\t\t\t\t= ttmp15\nvar s_save_xnack_mask\t\t\t\t= s_save_trapsts\nvar s_wave_size\t\t\t\t\t= ttmp7\nvar s_save_buf_rsrc0\t\t\t\t= ttmp8\nvar s_save_buf_rsrc1\t\t\t\t= ttmp9\nvar s_save_buf_rsrc2\t\t\t\t= ttmp10\nvar s_save_buf_rsrc3\t\t\t\t= ttmp11\nvar s_save_mem_offset\t\t\t\t= ttmp4\nvar s_save_alloc_size\t\t\t\t= s_save_trapsts\nvar s_save_tmp\t\t\t\t\t= ttmp14\nvar s_save_m0\t\t\t\t\t= ttmp5\nvar s_save_ttmps_lo\t\t\t\t= s_save_tmp\nvar s_save_ttmps_hi\t\t\t\t= s_save_trapsts\n\nvar S_RESTORE_BUF_RSRC_WORD1_STRIDE\t\t= S_SAVE_BUF_RSRC_WORD1_STRIDE\nvar S_RESTORE_BUF_RSRC_WORD3_MISC\t\t= S_SAVE_BUF_RSRC_WORD3_MISC\n\nvar S_RESTORE_SPI_INIT_FIRST_WAVE_MASK\t\t= 0x04000000\nvar S_RESTORE_SPI_INIT_FIRST_WAVE_SHIFT\t\t= 26\nvar S_WAVE_SIZE\t\t\t\t\t= 25\n\nvar s_restore_spi_init_lo\t\t\t= exec_lo\nvar s_restore_spi_init_hi\t\t\t= exec_hi\nvar s_restore_mem_offset\t\t\t= ttmp12\nvar s_restore_alloc_size\t\t\t= ttmp3\nvar s_restore_tmp\t\t\t\t= ttmp2\nvar s_restore_mem_offset_save\t\t\t= s_restore_tmp\nvar s_restore_m0\t\t\t\t= s_restore_alloc_size\nvar s_restore_mode\t\t\t\t= ttmp7\nvar s_restore_flat_scratch\t\t\t= s_restore_tmp\nvar s_restore_pc_lo\t\t\t\t= ttmp0\nvar s_restore_pc_hi\t\t\t\t= ttmp1\nvar s_restore_exec_lo\t\t\t\t= ttmp4\nvar s_restore_exec_hi\t\t\t\t= ttmp5\nvar s_restore_status\t\t\t\t= ttmp14\nvar s_restore_trapsts\t\t\t\t= ttmp15\nvar s_restore_xnack_mask\t\t\t= ttmp13\nvar s_restore_buf_rsrc0\t\t\t\t= ttmp8\nvar s_restore_buf_rsrc1\t\t\t\t= ttmp9\nvar s_restore_buf_rsrc2\t\t\t\t= ttmp10\nvar s_restore_buf_rsrc3\t\t\t\t= ttmp11\nvar s_restore_size\t\t\t\t= ttmp6\nvar s_restore_ttmps_lo\t\t\t\t= s_restore_tmp\nvar s_restore_ttmps_hi\t\t\t\t= s_restore_alloc_size\n\nshader main\n\tasic(DEFAULT)\n\ttype(CS)\n\twave_size(32)\n\n\ts_branch\tL_SKIP_RESTORE\t\t\t\t\t\t//NOT restore. might be a regular trap or save\n\nL_JUMP_TO_RESTORE:\n\ts_branch\tL_RESTORE\n\nL_SKIP_RESTORE:\n\ts_getreg_b32\ts_save_status, hwreg(HW_REG_STATUS)\t\t\t//save STATUS since we will change SCC\n\n\t// Clear SPI_PRIO: do not save with elevated priority.\n\t// Clear ECC_ERR: prevents SQC store and triggers FATAL_HALT if setreg'd.\n\ts_andn2_b32\ts_save_status, s_save_status, SQ_WAVE_STATUS_SPI_PRIO_MASK|SQ_WAVE_STATUS_ECC_ERR_MASK\n\n\ts_getreg_b32\ts_save_trapsts, hwreg(HW_REG_TRAPSTS)\n\n#if SW_SA_TRAP\n\t// If ttmp1[30] is set then issue s_barrier to unblock dependent waves.\n\ts_bitcmp1_b32\ts_save_pc_hi, 30\n\ts_cbranch_scc0\tL_TRAP_NO_BARRIER\n\ts_barrier\n\nL_TRAP_NO_BARRIER:\n\t// If ttmp1[31] is set then trap may occur early.\n\t// Spin wait until SAVECTX exception is raised.\n\ts_bitcmp1_b32\ts_save_pc_hi, 31\n\ts_cbranch_scc1  L_CHECK_SAVE\n#endif\n\n\ts_and_b32       ttmp2, s_save_status, SQ_WAVE_STATUS_HALT_MASK\n\ts_cbranch_scc0\tL_NOT_HALTED\n\nL_HALTED:\n\t// Host trap may occur while wave is halted.\n\ts_and_b32\tttmp2, s_save_pc_hi, S_SAVE_PC_HI_TRAP_ID_MASK\n\ts_cbranch_scc1\tL_FETCH_2ND_TRAP\n\nL_CHECK_SAVE:\n\ts_and_b32\tttmp2, s_save_trapsts, SQ_WAVE_TRAPSTS_SAVECTX_MASK\n\ts_cbranch_scc1\tL_SAVE\n\n\t// Wave is halted but neither host trap nor SAVECTX is raised.\n\t// Caused by instruction fetch memory violation.\n\t// Spin wait until context saved to prevent interrupt storm.\n\ts_sleep\t\t0x10\n\ts_getreg_b32\ts_save_trapsts, hwreg(HW_REG_TRAPSTS)\n\ts_branch\tL_CHECK_SAVE\n\nL_NOT_HALTED:\n\t// Let second-level handle non-SAVECTX exception or trap.\n\t// Any concurrent SAVECTX will be handled upon re-entry once halted.\n\n\t// Check non-maskable exceptions. memory_violation, illegal_instruction\n\t// and xnack_error exceptions always cause the wave to enter the trap\n\t// handler.\n\ts_and_b32\tttmp2, s_save_trapsts, SQ_WAVE_TRAPSTS_MEM_VIOL_MASK|SQ_WAVE_TRAPSTS_ILLEGAL_INST_MASK\n\ts_cbranch_scc1\tL_FETCH_2ND_TRAP\n\n\t// Check for maskable exceptions in trapsts.excp and trapsts.excp_hi.\n\t// Maskable exceptions only cause the wave to enter the trap handler if\n\t// their respective bit in mode.excp_en is set.\n\ts_and_b32\tttmp2, s_save_trapsts, SQ_WAVE_TRAPSTS_EXCP_MASK|SQ_WAVE_TRAPSTS_EXCP_HI_MASK\n\ts_cbranch_scc0\tL_CHECK_TRAP_ID\n\n\ts_and_b32\tttmp3, s_save_trapsts, SQ_WAVE_TRAPSTS_ADDR_WATCH_MASK|SQ_WAVE_TRAPSTS_EXCP_HI_MASK\n\ts_cbranch_scc0\tL_NOT_ADDR_WATCH\n\ts_bitset1_b32\tttmp2, SQ_WAVE_TRAPSTS_ADDR_WATCH_SHIFT // Check all addr_watch[123] exceptions against excp_en.addr_watch\n\nL_NOT_ADDR_WATCH:\n\ts_getreg_b32\tttmp3, hwreg(HW_REG_MODE)\n\ts_lshl_b32\tttmp2, ttmp2, SQ_WAVE_MODE_EXCP_EN_SHIFT\n\ts_and_b32\tttmp2, ttmp2, ttmp3\n\ts_cbranch_scc1\tL_FETCH_2ND_TRAP\n\nL_CHECK_TRAP_ID:\n\t// Check trap_id != 0\n\ts_and_b32\tttmp2, s_save_pc_hi, S_SAVE_PC_HI_TRAP_ID_MASK\n\ts_cbranch_scc1\tL_FETCH_2ND_TRAP\n\nif SINGLE_STEP_MISSED_WORKAROUND\n\t// Prioritize single step exception over context save.\n\t// Second-level trap will halt wave and RFE, re-entering for SAVECTX.\n\ts_getreg_b32\tttmp2, hwreg(HW_REG_MODE)\n\ts_and_b32\tttmp2, ttmp2, SQ_WAVE_MODE_DEBUG_EN_MASK\n\ts_cbranch_scc1\tL_FETCH_2ND_TRAP\nend\n\n\ts_and_b32\tttmp2, s_save_trapsts, SQ_WAVE_TRAPSTS_SAVECTX_MASK\n\ts_cbranch_scc1\tL_SAVE\n\nL_FETCH_2ND_TRAP:\n#if HAVE_XNACK\n\tsave_and_clear_ib_sts(ttmp14, ttmp15)\n#endif\n\n\t// Read second-level TBA/TMA from first-level TMA and jump if available.\n\t// ttmp[2:5] and ttmp12 can be used (others hold SPI-initialized debug data)\n\t// ttmp12 holds SQ_WAVE_STATUS\n#if HAVE_SENDMSG_RTN\n\ts_sendmsg_rtn_b64       [ttmp14, ttmp15], sendmsg(MSG_RTN_GET_TMA)\n\ts_waitcnt       lgkmcnt(0)\n#else\n\ts_getreg_b32\tttmp14, hwreg(HW_REG_SHADER_TMA_LO)\n\ts_getreg_b32\tttmp15, hwreg(HW_REG_SHADER_TMA_HI)\n#endif\n\ts_lshl_b64\t[ttmp14, ttmp15], [ttmp14, ttmp15], 0x8\n\n\ts_bitcmp1_b32\tttmp15, 0xF\n\ts_cbranch_scc0\tL_NO_SIGN_EXTEND_TMA\n\ts_or_b32\tttmp15, ttmp15, 0xFFFF0000\nL_NO_SIGN_EXTEND_TMA:\n\n\ts_load_dword    ttmp2, [ttmp14, ttmp15], 0x10 glc:1\t\t\t// debug trap enabled flag\n\ts_waitcnt       lgkmcnt(0)\n\ts_lshl_b32      ttmp2, ttmp2, TTMP11_DEBUG_TRAP_ENABLED_SHIFT\n\ts_andn2_b32     ttmp11, ttmp11, TTMP11_DEBUG_TRAP_ENABLED_MASK\n\ts_or_b32        ttmp11, ttmp11, ttmp2\n\n\ts_load_dwordx2\t[ttmp2, ttmp3], [ttmp14, ttmp15], 0x0 glc:1\t\t// second-level TBA\n\ts_waitcnt\tlgkmcnt(0)\n\ts_load_dwordx2\t[ttmp14, ttmp15], [ttmp14, ttmp15], 0x8 glc:1\t\t// second-level TMA\n\ts_waitcnt\tlgkmcnt(0)\n\n\ts_and_b64\t[ttmp2, ttmp3], [ttmp2, ttmp3], [ttmp2, ttmp3]\n\ts_cbranch_scc0\tL_NO_NEXT_TRAP\t\t\t\t\t\t// second-level trap handler not been set\n\ts_setpc_b64\t[ttmp2, ttmp3]\t\t\t\t\t\t// jump to second-level trap handler\n\nL_NO_NEXT_TRAP:\n\t// If not caused by trap then halt wave to prevent re-entry.\n\ts_and_b32\tttmp2, s_save_pc_hi, (S_SAVE_PC_HI_TRAP_ID_MASK|S_SAVE_PC_HI_HT_MASK)\n\ts_cbranch_scc1\tL_TRAP_CASE\n\ts_or_b32\ts_save_status, s_save_status, SQ_WAVE_STATUS_HALT_MASK\n\n\t// If the PC points to S_ENDPGM then context save will fail if STATUS.HALT is set.\n\t// Rewind the PC to prevent this from occurring.\n\ts_sub_u32\tttmp0, ttmp0, 0x8\n\ts_subb_u32\tttmp1, ttmp1, 0x0\n\n\ts_branch\tL_EXIT_TRAP\n\nL_TRAP_CASE:\n\t// Host trap will not cause trap re-entry.\n\ts_and_b32\tttmp2, s_save_pc_hi, S_SAVE_PC_HI_HT_MASK\n\ts_cbranch_scc1\tL_EXIT_TRAP\n\n\t// Advance past trap instruction to prevent re-entry.\n\ts_add_u32\tttmp0, ttmp0, 0x4\n\ts_addc_u32\tttmp1, ttmp1, 0x0\n\nL_EXIT_TRAP:\n\ts_and_b32\tttmp1, ttmp1, 0xFFFF\n\n#if HAVE_XNACK\n\trestore_ib_sts(ttmp14, ttmp15)\n#endif\n\n\t// Restore SQ_WAVE_STATUS.\n\ts_and_b64\texec, exec, exec\t\t\t\t\t// Restore STATUS.EXECZ, not writable by s_setreg_b32\n\ts_and_b64\tvcc, vcc, vcc\t\t\t\t\t\t// Restore STATUS.VCCZ, not writable by s_setreg_b32\n\ts_setreg_b32\thwreg(HW_REG_STATUS), s_save_status\n\n\ts_rfe_b64\t[ttmp0, ttmp1]\n\nL_SAVE:\n\ts_and_b32\ts_save_pc_hi, s_save_pc_hi, 0x0000ffff\t\t\t//pc[47:32]\n\ts_mov_b32\ts_save_tmp, 0\n\ts_setreg_b32\thwreg(HW_REG_TRAPSTS, SQ_WAVE_TRAPSTS_SAVECTX_SHIFT, 1), s_save_tmp\t//clear saveCtx bit\n\n#if HAVE_XNACK\n\tsave_and_clear_ib_sts(s_save_tmp, s_save_trapsts)\n#endif\n\n\t/* inform SPI the readiness and wait for SPI's go signal */\n\ts_mov_b32\ts_save_exec_lo, exec_lo\t\t\t\t\t//save EXEC and use EXEC for the go signal from SPI\n\ts_mov_b32\ts_save_exec_hi, exec_hi\n\ts_mov_b64\texec, 0x0\t\t\t\t\t\t//clear EXEC to get ready to receive\n\n#if HAVE_SENDMSG_RTN\n\ts_sendmsg_rtn_b64       [exec_lo, exec_hi], sendmsg(MSG_RTN_SAVE_WAVE)\n#else\n\ts_sendmsg\tsendmsg(MSG_SAVEWAVE)\t\t\t\t\t//send SPI a message and wait for SPI's write to EXEC\n#endif\n\n#if ASIC_FAMILY < CHIP_SIENNA_CICHLID\nL_SLEEP:\n\t// sleep 1 (64clk) is not enough for 8 waves per SIMD, which will cause\n\t// SQ hang, since the 7,8th wave could not get arbit to exec inst, while\n\t// other waves are stuck into the sleep-loop and waiting for wrexec!=0\n\ts_sleep\t\t0x2\n\ts_cbranch_execz\tL_SLEEP\n#else\n\ts_waitcnt\tlgkmcnt(0)\n#endif\n\n\t// Save first_wave flag so we can clear high bits of save address.\n\ts_and_b32\ts_save_tmp, s_save_spi_init_hi, S_SAVE_SPI_INIT_FIRST_WAVE_MASK\n\ts_lshl_b32\ts_save_tmp, s_save_tmp, (S_SAVE_PC_HI_FIRST_WAVE_SHIFT - S_SAVE_SPI_INIT_FIRST_WAVE_SHIFT)\n\ts_or_b32\ts_save_pc_hi, s_save_pc_hi, s_save_tmp\n\n#if NO_SQC_STORE\n\t// Trap temporaries must be saved via VGPR but all VGPRs are in use.\n\t// There is no ttmp space to hold the resource constant for VGPR save.\n\t// Save v0 by itself since it requires only two SGPRs.\n\ts_mov_b32\ts_save_ttmps_lo, exec_lo\n\ts_and_b32\ts_save_ttmps_hi, exec_hi, 0xFFFF\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\n\tglobal_store_dword_addtid\tv0, [s_save_ttmps_lo, s_save_ttmps_hi] slc:1 glc:1\n\tv_mov_b32\tv0, 0x0\n\ts_mov_b32\texec_lo, s_save_ttmps_lo\n\ts_mov_b32\texec_hi, s_save_ttmps_hi\n#endif\n\n\t// Save trap temporaries 4-11, 13 initialized by SPI debug dispatch logic\n\t// ttmp SR memory offset : size(VGPR)+size(SVGPR)+size(SGPR)+0x40\n\tget_wave_size(s_save_ttmps_hi)\n\tget_vgpr_size_bytes(s_save_ttmps_lo, s_save_ttmps_hi)\n\tget_svgpr_size_bytes(s_save_ttmps_hi)\n\ts_add_u32\ts_save_ttmps_lo, s_save_ttmps_lo, s_save_ttmps_hi\n\ts_and_b32\ts_save_ttmps_hi, s_save_spi_init_hi, 0xFFFF\n\ts_add_u32\ts_save_ttmps_lo, s_save_ttmps_lo, get_sgpr_size_bytes()\n\ts_add_u32\ts_save_ttmps_lo, s_save_ttmps_lo, s_save_spi_init_lo\n\ts_addc_u32\ts_save_ttmps_hi, s_save_ttmps_hi, 0x0\n\n#if NO_SQC_STORE\n\tv_writelane_b32\tv0, ttmp4, 0x4\n\tv_writelane_b32\tv0, ttmp5, 0x5\n\tv_writelane_b32\tv0, ttmp6, 0x6\n\tv_writelane_b32\tv0, ttmp7, 0x7\n\tv_writelane_b32\tv0, ttmp8, 0x8\n\tv_writelane_b32\tv0, ttmp9, 0x9\n\tv_writelane_b32\tv0, ttmp10, 0xA\n\tv_writelane_b32\tv0, ttmp11, 0xB\n\tv_writelane_b32\tv0, ttmp13, 0xD\n\tv_writelane_b32\tv0, exec_lo, 0xE\n\tv_writelane_b32\tv0, exec_hi, 0xF\n\n\ts_mov_b32\texec_lo, 0x3FFF\n\ts_mov_b32\texec_hi, 0x0\n\tglobal_store_dword_addtid\tv0, [s_save_ttmps_lo, s_save_ttmps_hi] inst_offset:0x40 slc:1 glc:1\n\tv_readlane_b32\tttmp14, v0, 0xE\n\tv_readlane_b32\tttmp15, v0, 0xF\n\ts_mov_b32\texec_lo, ttmp14\n\ts_mov_b32\texec_hi, ttmp15\n#else\n\ts_store_dwordx4\t[ttmp4, ttmp5, ttmp6, ttmp7], [s_save_ttmps_lo, s_save_ttmps_hi], 0x50 glc:1\n\ts_store_dwordx4\t[ttmp8, ttmp9, ttmp10, ttmp11], [s_save_ttmps_lo, s_save_ttmps_hi], 0x60 glc:1\n\ts_store_dword   ttmp13, [s_save_ttmps_lo, s_save_ttmps_hi], 0x74 glc:1\n#endif\n\n\t/* setup Resource Contants */\n\ts_mov_b32\ts_save_buf_rsrc0, s_save_spi_init_lo\t\t\t//base_addr_lo\n\ts_and_b32\ts_save_buf_rsrc1, s_save_spi_init_hi, 0x0000FFFF\t//base_addr_hi\n\ts_or_b32\ts_save_buf_rsrc1, s_save_buf_rsrc1, S_SAVE_BUF_RSRC_WORD1_STRIDE\n\ts_mov_b32\ts_save_buf_rsrc2, 0\t\t\t\t\t//NUM_RECORDS initial value = 0 (in bytes) although not neccessarily inited\n\ts_mov_b32\ts_save_buf_rsrc3, S_SAVE_BUF_RSRC_WORD3_MISC\n\n\ts_mov_b32\ts_save_m0, m0\n\n\t/* global mem offset */\n\ts_mov_b32\ts_save_mem_offset, 0x0\n\tget_wave_size(s_wave_size)\n\n#if HAVE_XNACK\n\t// Save and clear vector XNACK state late to free up SGPRs.\n\ts_getreg_b32\ts_save_xnack_mask, hwreg(HW_REG_SHADER_XNACK_MASK)\n\ts_setreg_imm32_b32\thwreg(HW_REG_SHADER_XNACK_MASK), 0x0\n#endif\n\n\t/* save first 4 VGPRs, needed for SGPR save */\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\t\t\t\t\t//need every thread from now on\n\ts_lshr_b32\tm0, s_wave_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_ENABLE_SAVE_4VGPR_EXEC_HI\n\ts_mov_b32\texec_hi, 0x00000000\n\ts_branch\tL_SAVE_4VGPR_WAVE32\nL_ENABLE_SAVE_4VGPR_EXEC_HI:\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\n\ts_branch\tL_SAVE_4VGPR_WAVE64\nL_SAVE_4VGPR_WAVE32:\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR Allocated in 4-GPR granularity\n\n#if !NO_SQC_STORE\n\tbuffer_store_dword\tv0, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n#endif\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128*2\n\tbuffer_store_dword\tv3, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128*3\n\ts_branch\tL_SAVE_HWREG\n\nL_SAVE_4VGPR_WAVE64:\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR Allocated in 4-GPR granularity\n\n#if !NO_SQC_STORE\n\tbuffer_store_dword\tv0, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n#endif\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256*2\n\tbuffer_store_dword\tv3, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256*3\n\n\t/* save HW registers */\n\nL_SAVE_HWREG:\n\t// HWREG SR memory offset : size(VGPR)+size(SVGPR)+size(SGPR)\n\tget_vgpr_size_bytes(s_save_mem_offset, s_wave_size)\n\tget_svgpr_size_bytes(s_save_tmp)\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, s_save_tmp\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, get_sgpr_size_bytes()\n\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n#if NO_SQC_STORE\n\tv_mov_b32\tv0, 0x0\t\t\t\t\t\t\t//Offset[31:0] from buffer resource\n\tv_mov_b32\tv1, 0x0\t\t\t\t\t\t\t//Offset[63:32] from buffer resource\n\tv_mov_b32\tv2, 0x0\t\t\t\t\t\t\t//Set of SGPRs for TCP store\n\ts_mov_b32\tm0, 0x0\t\t\t\t\t\t\t//Next lane of v2 to write to\n#endif\n\n\twrite_hwreg_to_mem(s_save_m0, s_save_buf_rsrc0, s_save_mem_offset)\n\twrite_hwreg_to_mem(s_save_pc_lo, s_save_buf_rsrc0, s_save_mem_offset)\n\ts_andn2_b32\ts_save_tmp, s_save_pc_hi, S_SAVE_PC_HI_FIRST_WAVE_MASK\n\twrite_hwreg_to_mem(s_save_tmp, s_save_buf_rsrc0, s_save_mem_offset)\n\twrite_hwreg_to_mem(s_save_exec_lo, s_save_buf_rsrc0, s_save_mem_offset)\n\twrite_hwreg_to_mem(s_save_exec_hi, s_save_buf_rsrc0, s_save_mem_offset)\n\twrite_hwreg_to_mem(s_save_status, s_save_buf_rsrc0, s_save_mem_offset)\n\n\ts_getreg_b32\ts_save_tmp, hwreg(HW_REG_TRAPSTS)\n\twrite_hwreg_to_mem(s_save_tmp, s_save_buf_rsrc0, s_save_mem_offset)\n\n\t// Not used on Sienna_Cichlid but keep layout same for debugger.\n\twrite_hwreg_to_mem(s_save_xnack_mask, s_save_buf_rsrc0, s_save_mem_offset)\n\n\ts_getreg_b32\ts_save_m0, hwreg(HW_REG_MODE)\n\twrite_hwreg_to_mem(s_save_m0, s_save_buf_rsrc0, s_save_mem_offset)\n\n\ts_getreg_b32\ts_save_m0, hwreg(HW_REG_SHADER_FLAT_SCRATCH_LO)\n\twrite_hwreg_to_mem(s_save_m0, s_save_buf_rsrc0, s_save_mem_offset)\n\n\ts_getreg_b32\ts_save_m0, hwreg(HW_REG_SHADER_FLAT_SCRATCH_HI)\n\twrite_hwreg_to_mem(s_save_m0, s_save_buf_rsrc0, s_save_mem_offset)\n\n#if NO_SQC_STORE\n\t// Write HWREGs with 16 VGPR lanes. TTMPs occupy space after this.\n\ts_mov_b32       exec_lo, 0xFFFF\n\ts_mov_b32\texec_hi, 0x0\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\n\t// Write SGPRs with 32 VGPR lanes. This works in wave32 and wave64 mode.\n\ts_mov_b32       exec_lo, 0xFFFFFFFF\n#endif\n\n\t/* save SGPRs */\n\t// Save SGPR before LDS save, then the s0 to s4 can be used during LDS save...\n\n\t// SGPR SR memory offset : size(VGPR)+size(SVGPR)\n\tget_vgpr_size_bytes(s_save_mem_offset, s_wave_size)\n\tget_svgpr_size_bytes(s_save_tmp)\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, s_save_tmp\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n#if NO_SQC_STORE\n\ts_mov_b32\tttmp13, 0x0\t\t\t\t\t\t//next VGPR lane to copy SGPR into\n#else\n\t// backup s_save_buf_rsrc0,1 to s_save_pc_lo/hi, since write_16sgpr_to_mem function will change the rsrc0\n\ts_mov_b32\ts_save_xnack_mask, s_save_buf_rsrc0\n\ts_add_u32\ts_save_buf_rsrc0, s_save_buf_rsrc0, s_save_mem_offset\n\ts_addc_u32\ts_save_buf_rsrc1, s_save_buf_rsrc1, 0\n#endif\n\n\ts_mov_b32\tm0, 0x0\t\t\t\t\t\t\t//SGPR initial index value =0\n\ts_nop\t\t0x0\t\t\t\t\t\t\t//Manually inserted wait states\nL_SAVE_SGPR_LOOP:\n\t// SGPR is allocated in 16 SGPR granularity\n\ts_movrels_b64\ts0, s0\t\t\t\t\t\t\t//s0 = s[0+m0], s1 = s[1+m0]\n\ts_movrels_b64\ts2, s2\t\t\t\t\t\t\t//s2 = s[2+m0], s3 = s[3+m0]\n\ts_movrels_b64\ts4, s4\t\t\t\t\t\t\t//s4 = s[4+m0], s5 = s[5+m0]\n\ts_movrels_b64\ts6, s6\t\t\t\t\t\t\t//s6 = s[6+m0], s7 = s[7+m0]\n\ts_movrels_b64\ts8, s8\t\t\t\t\t\t\t//s8 = s[8+m0], s9 = s[9+m0]\n\ts_movrels_b64\ts10, s10\t\t\t\t\t\t//s10 = s[10+m0], s11 = s[11+m0]\n\ts_movrels_b64\ts12, s12\t\t\t\t\t\t//s12 = s[12+m0], s13 = s[13+m0]\n\ts_movrels_b64\ts14, s14\t\t\t\t\t\t//s14 = s[14+m0], s15 = s[15+m0]\n\n\twrite_16sgpr_to_mem(s0, s_save_buf_rsrc0, s_save_mem_offset)\n\n#if NO_SQC_STORE\n\ts_cmp_eq_u32\tttmp13, 0x20\t\t\t\t\t\t//have 32 VGPR lanes filled?\n\ts_cbranch_scc0\tL_SAVE_SGPR_SKIP_TCP_STORE\n\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, 0x80\n\ts_mov_b32\tttmp13, 0x0\n\tv_mov_b32\tv2, 0x0\nL_SAVE_SGPR_SKIP_TCP_STORE:\n#endif\n\n\ts_add_u32\tm0, m0, 16\t\t\t\t\t\t//next sgpr index\n\ts_cmp_lt_u32\tm0, 96\t\t\t\t\t\t\t//scc = (m0 < first 96 SGPR) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_SGPR_LOOP\t\t\t\t\t//first 96 SGPR save is complete?\n\n\t//save the rest 12 SGPR\n\ts_movrels_b64\ts0, s0\t\t\t\t\t\t\t//s0 = s[0+m0], s1 = s[1+m0]\n\ts_movrels_b64\ts2, s2\t\t\t\t\t\t\t//s2 = s[2+m0], s3 = s[3+m0]\n\ts_movrels_b64\ts4, s4\t\t\t\t\t\t\t//s4 = s[4+m0], s5 = s[5+m0]\n\ts_movrels_b64\ts6, s6\t\t\t\t\t\t\t//s6 = s[6+m0], s7 = s[7+m0]\n\ts_movrels_b64\ts8, s8\t\t\t\t\t\t\t//s8 = s[8+m0], s9 = s[9+m0]\n\ts_movrels_b64\ts10, s10\t\t\t\t\t\t//s10 = s[10+m0], s11 = s[11+m0]\n\twrite_12sgpr_to_mem(s0, s_save_buf_rsrc0, s_save_mem_offset)\n\n#if NO_SQC_STORE\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n#else\n\t// restore s_save_buf_rsrc0,1\n\ts_mov_b32\ts_save_buf_rsrc0, s_save_xnack_mask\n#endif\n\n\t/* save LDS */\n\nL_SAVE_LDS:\n\t// Change EXEC to all threads...\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\t\t\t\t\t//need every thread from now on\n\ts_lshr_b32\tm0, s_wave_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_ENABLE_SAVE_LDS_EXEC_HI\n\ts_mov_b32\texec_hi, 0x00000000\n\ts_branch\tL_SAVE_LDS_NORMAL\nL_ENABLE_SAVE_LDS_EXEC_HI:\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\nL_SAVE_LDS_NORMAL:\n\ts_getreg_b32\ts_save_alloc_size, hwreg(HW_REG_LDS_ALLOC,SQ_WAVE_LDS_ALLOC_LDS_SIZE_SHIFT,SQ_WAVE_LDS_ALLOC_LDS_SIZE_SIZE)\n\ts_and_b32\ts_save_alloc_size, s_save_alloc_size, 0xFFFFFFFF\t//lds_size is zero?\n\ts_cbranch_scc0\tL_SAVE_LDS_DONE\t\t\t\t\t\t//no lds used? jump to L_SAVE_DONE\n\n\ts_barrier\t\t\t\t\t\t\t\t//LDS is used? wait for other waves in the same TG\n\ts_and_b32\ts_save_tmp, s_save_pc_hi, S_SAVE_PC_HI_FIRST_WAVE_MASK\n\ts_cbranch_scc0\tL_SAVE_LDS_DONE\n\n\t// first wave do LDS save;\n\n\ts_lshl_b32\ts_save_alloc_size, s_save_alloc_size, 6\t\t\t//LDS size in dwords = lds_size * 64dw\n\ts_lshl_b32\ts_save_alloc_size, s_save_alloc_size, 2\t\t\t//LDS size in bytes\n\ts_mov_b32\ts_save_buf_rsrc2, s_save_alloc_size\t\t\t//NUM_RECORDS in bytes\n\n\t// LDS at offset: size(VGPR)+size(SVGPR)+SIZE(SGPR)+SIZE(HWREG)\n\t//\n\tget_vgpr_size_bytes(s_save_mem_offset, s_wave_size)\n\tget_svgpr_size_bytes(s_save_tmp)\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, s_save_tmp\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, get_sgpr_size_bytes()\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, get_hwreg_size_bytes()\n\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t//load 0~63*4(byte address) to vgpr v0\n\tv_mbcnt_lo_u32_b32\tv0, -1, 0\n\tv_mbcnt_hi_u32_b32\tv0, -1, v0\n\tv_mul_u32_u24\tv0, 4, v0\n\n\ts_lshr_b32\tm0, s_wave_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_mov_b32\tm0, 0x0\n\ts_cbranch_scc1\tL_SAVE_LDS_W64\n\nL_SAVE_LDS_W32:\n\ts_mov_b32\ts3, 128\n\ts_nop\t\t0\n\ts_nop\t\t0\n\ts_nop\t\t0\nL_SAVE_LDS_LOOP_W32:\n\tds_read_b32\tv1, v0\n\ts_waitcnt\t0\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\n\ts_add_u32\tm0, m0, s3\t\t\t\t\t\t//every buffer_store_lds does 256 bytes\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, s3\n\tv_add_nc_u32\tv0, v0, 128\t\t\t\t\t\t//mem offset increased by 128 bytes\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\t\t\t\t\t//scc=(m0 < s_save_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_LDS_LOOP_W32\t\t\t\t\t//LDS save is complete?\n\n\ts_branch\tL_SAVE_LDS_DONE\n\nL_SAVE_LDS_W64:\n\ts_mov_b32\ts3, 256\n\ts_nop\t\t0\n\ts_nop\t\t0\n\ts_nop\t\t0\nL_SAVE_LDS_LOOP_W64:\n\tds_read_b32\tv1, v0\n\ts_waitcnt\t0\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\n\ts_add_u32\tm0, m0, s3\t\t\t\t\t\t//every buffer_store_lds does 256 bytes\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, s3\n\tv_add_nc_u32\tv0, v0, 256\t\t\t\t\t\t//mem offset increased by 256 bytes\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\t\t\t\t\t//scc=(m0 < s_save_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_LDS_LOOP_W64\t\t\t\t\t//LDS save is complete?\n\nL_SAVE_LDS_DONE:\n\t/* save VGPRs  - set the Rest VGPRs */\nL_SAVE_VGPR:\n\t// VGPR SR memory offset: 0\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\t\t\t\t\t//need every thread from now on\n\ts_lshr_b32\tm0, s_wave_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_ENABLE_SAVE_VGPR_EXEC_HI\n\ts_mov_b32\ts_save_mem_offset, (0+128*4)\t\t\t\t// for the rest VGPRs\n\ts_mov_b32\texec_hi, 0x00000000\n\ts_branch\tL_SAVE_VGPR_NORMAL\nL_ENABLE_SAVE_VGPR_EXEC_HI:\n\ts_mov_b32\ts_save_mem_offset, (0+256*4)\t\t\t\t// for the rest VGPRs\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\nL_SAVE_VGPR_NORMAL:\n\ts_getreg_b32\ts_save_alloc_size, hwreg(HW_REG_GPR_ALLOC,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SHIFT,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SIZE)\n\ts_add_u32\ts_save_alloc_size, s_save_alloc_size, 1\n\ts_lshl_b32\ts_save_alloc_size, s_save_alloc_size, 2\t\t\t//Number of VGPRs = (vgpr_size + 1) * 4    (non-zero value)\n\t//determine it is wave32 or wave64\n\ts_lshr_b32\tm0, s_wave_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_SAVE_VGPR_WAVE64\n\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR Allocated in 4-GPR granularity\n\n\t// VGPR store using dw burst\n\ts_mov_b32\tm0, 0x4\t\t\t\t\t\t\t//VGPR initial index value =4\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\n\ts_cbranch_scc0\tL_SAVE_VGPR_END\n\nL_SAVE_VGPR_W32_LOOP:\n\tv_movrels_b32\tv0, v0\t\t\t\t\t\t\t//v0 = v[0+m0]\n\tv_movrels_b32\tv1, v1\t\t\t\t\t\t\t//v1 = v[1+m0]\n\tv_movrels_b32\tv2, v2\t\t\t\t\t\t\t//v2 = v[2+m0]\n\tv_movrels_b32\tv3, v3\t\t\t\t\t\t\t//v3 = v[3+m0]\n\n\tbuffer_store_dword\tv0, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128*2\n\tbuffer_store_dword\tv3, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:128*3\n\n\ts_add_u32\tm0, m0, 4\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, 128*4\t\t//every buffer_store_dword does 128 bytes\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\t\t\t\t\t//scc = (m0 < s_save_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_VGPR_W32_LOOP\t\t\t\t\t//VGPR save is complete?\n\n\ts_branch\tL_SAVE_VGPR_END\n\nL_SAVE_VGPR_WAVE64:\n\ts_mov_b32\ts_save_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR store using dw burst\n\ts_mov_b32\tm0, 0x4\t\t\t\t\t\t\t//VGPR initial index value =4\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\n\ts_cbranch_scc0\tL_SAVE_SHARED_VGPR\n\nL_SAVE_VGPR_W64_LOOP:\n\tv_movrels_b32\tv0, v0\t\t\t\t\t\t\t//v0 = v[0+m0]\n\tv_movrels_b32\tv1, v1\t\t\t\t\t\t\t//v1 = v[1+m0]\n\tv_movrels_b32\tv2, v2\t\t\t\t\t\t\t//v2 = v[2+m0]\n\tv_movrels_b32\tv3, v3\t\t\t\t\t\t\t//v3 = v[3+m0]\n\n\tbuffer_store_dword\tv0, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\tbuffer_store_dword\tv1, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256\n\tbuffer_store_dword\tv2, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256*2\n\tbuffer_store_dword\tv3, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1 offset:256*3\n\n\ts_add_u32\tm0, m0, 4\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, 256*4\t\t//every buffer_store_dword does 256 bytes\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\t\t\t\t\t//scc = (m0 < s_save_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_VGPR_W64_LOOP\t\t\t\t\t//VGPR save is complete?\n\nL_SAVE_SHARED_VGPR:\n\t//Below part will be the save shared vgpr part (new for gfx10)\n\ts_getreg_b32\ts_save_alloc_size, hwreg(HW_REG_LDS_ALLOC,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SHIFT,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SIZE)\n\ts_and_b32\ts_save_alloc_size, s_save_alloc_size, 0xFFFFFFFF\t//shared_vgpr_size is zero?\n\ts_cbranch_scc0\tL_SAVE_VGPR_END\t\t\t\t\t\t//no shared_vgpr used? jump to L_SAVE_LDS\n\ts_lshl_b32\ts_save_alloc_size, s_save_alloc_size, 3\t\t\t//Number of SHARED_VGPRs = shared_vgpr_size * 8    (non-zero value)\n\t//m0 now has the value of normal vgpr count, just add the m0 with shared_vgpr count to get the total count.\n\t//save shared_vgpr will start from the index of m0\n\ts_add_u32\ts_save_alloc_size, s_save_alloc_size, m0\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\n\ts_mov_b32\texec_hi, 0x00000000\nL_SAVE_SHARED_VGPR_WAVE64_LOOP:\n\tv_movrels_b32\tv0, v0\t\t\t\t\t\t\t//v0 = v[0+m0]\n\tbuffer_store_dword\tv0, v0, s_save_buf_rsrc0, s_save_mem_offset slc:1 glc:1\n\ts_add_u32\tm0, m0, 1\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_save_mem_offset, s_save_mem_offset, 128\n\ts_cmp_lt_u32\tm0, s_save_alloc_size\t\t\t\t\t//scc = (m0 < s_save_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_SAVE_SHARED_VGPR_WAVE64_LOOP\t\t\t\t//SHARED_VGPR save is complete?\n\nL_SAVE_VGPR_END:\n\ts_branch\tL_END_PGM\n\nL_RESTORE:\n\t/* Setup Resource Contants */\n\ts_mov_b32\ts_restore_buf_rsrc0, s_restore_spi_init_lo\t\t//base_addr_lo\n\ts_and_b32\ts_restore_buf_rsrc1, s_restore_spi_init_hi, 0x0000FFFF\t//base_addr_hi\n\ts_or_b32\ts_restore_buf_rsrc1, s_restore_buf_rsrc1, S_RESTORE_BUF_RSRC_WORD1_STRIDE\n\ts_mov_b32\ts_restore_buf_rsrc2, 0\t\t\t\t\t//NUM_RECORDS initial value = 0 (in bytes)\n\ts_mov_b32\ts_restore_buf_rsrc3, S_RESTORE_BUF_RSRC_WORD3_MISC\n\n\t//determine it is wave32 or wave64\n\tget_wave_size(s_restore_size)\n\n\ts_and_b32\ts_restore_tmp, s_restore_spi_init_hi, S_RESTORE_SPI_INIT_FIRST_WAVE_MASK\n\ts_cbranch_scc0\tL_RESTORE_VGPR\n\n\t/* restore LDS */\nL_RESTORE_LDS:\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\t\t\t\t\t//need every thread from now on\n\ts_lshr_b32\tm0, s_restore_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_ENABLE_RESTORE_LDS_EXEC_HI\n\ts_mov_b32\texec_hi, 0x00000000\n\ts_branch\tL_RESTORE_LDS_NORMAL\nL_ENABLE_RESTORE_LDS_EXEC_HI:\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\nL_RESTORE_LDS_NORMAL:\n\ts_getreg_b32\ts_restore_alloc_size, hwreg(HW_REG_LDS_ALLOC,SQ_WAVE_LDS_ALLOC_LDS_SIZE_SHIFT,SQ_WAVE_LDS_ALLOC_LDS_SIZE_SIZE)\n\ts_and_b32\ts_restore_alloc_size, s_restore_alloc_size, 0xFFFFFFFF\t//lds_size is zero?\n\ts_cbranch_scc0\tL_RESTORE_VGPR\t\t\t\t\t\t//no lds used? jump to L_RESTORE_VGPR\n\ts_lshl_b32\ts_restore_alloc_size, s_restore_alloc_size, 6\t\t//LDS size in dwords = lds_size * 64dw\n\ts_lshl_b32\ts_restore_alloc_size, s_restore_alloc_size, 2\t\t//LDS size in bytes\n\ts_mov_b32\ts_restore_buf_rsrc2, s_restore_alloc_size\t\t//NUM_RECORDS in bytes\n\n\t// LDS at offset: size(VGPR)+size(SVGPR)+SIZE(SGPR)+SIZE(HWREG)\n\t//\n\tget_vgpr_size_bytes(s_restore_mem_offset, s_restore_size)\n\tget_svgpr_size_bytes(s_restore_tmp)\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, s_restore_tmp\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, get_sgpr_size_bytes()\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, get_hwreg_size_bytes()\n\n\ts_mov_b32\ts_restore_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\ts_lshr_b32\tm0, s_restore_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_mov_b32\tm0, 0x0\n\ts_cbranch_scc1\tL_RESTORE_LDS_LOOP_W64\n\nL_RESTORE_LDS_LOOP_W32:\n#if HAVE_BUFFER_LDS_LOAD\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset lds:1\t// first 64DW\n#else\n\tbuffer_load_dword       v0, v0, s_restore_buf_rsrc0, s_restore_mem_offset\n\ts_waitcnt\tvmcnt(0)\n\tds_store_addtid_b32     v0\n#endif\n\ts_add_u32\tm0, m0, 128\t\t\t\t\t\t// 128 DW\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 128\t\t//mem offset increased by 128DW\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\t\t\t\t//scc=(m0 < s_restore_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_RESTORE_LDS_LOOP_W32\t\t\t\t\t//LDS restore is complete?\n\ts_branch\tL_RESTORE_VGPR\n\nL_RESTORE_LDS_LOOP_W64:\n#if HAVE_BUFFER_LDS_LOAD\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset lds:1\t// first 64DW\n#else\n\tbuffer_load_dword       v0, v0, s_restore_buf_rsrc0, s_restore_mem_offset\n\ts_waitcnt\tvmcnt(0)\n\tds_store_addtid_b32     v0\n#endif\n\ts_add_u32\tm0, m0, 256\t\t\t\t\t\t// 256 DW\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 256\t\t//mem offset increased by 256DW\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\t\t\t\t//scc=(m0 < s_restore_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_RESTORE_LDS_LOOP_W64\t\t\t\t\t//LDS restore is complete?\n\n\t/* restore VGPRs */\nL_RESTORE_VGPR:\n\t// VGPR SR memory offset : 0\n\ts_mov_b32\ts_restore_mem_offset, 0x0\n \ts_mov_b32\texec_lo, 0xFFFFFFFF\t\t\t\t\t//need every thread from now on\n\ts_lshr_b32\tm0, s_restore_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_ENABLE_RESTORE_VGPR_EXEC_HI\n\ts_mov_b32\texec_hi, 0x00000000\n\ts_branch\tL_RESTORE_VGPR_NORMAL\nL_ENABLE_RESTORE_VGPR_EXEC_HI:\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\nL_RESTORE_VGPR_NORMAL:\n\ts_getreg_b32\ts_restore_alloc_size, hwreg(HW_REG_GPR_ALLOC,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SHIFT,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SIZE)\n\ts_add_u32\ts_restore_alloc_size, s_restore_alloc_size, 1\n\ts_lshl_b32\ts_restore_alloc_size, s_restore_alloc_size, 2\t\t//Number of VGPRs = (vgpr_size + 1) * 4    (non-zero value)\n\t//determine it is wave32 or wave64\n\ts_lshr_b32\tm0, s_restore_size, S_WAVE_SIZE\n\ts_and_b32\tm0, m0, 1\n\ts_cmp_eq_u32\tm0, 1\n\ts_cbranch_scc1\tL_RESTORE_VGPR_WAVE64\n\n\ts_mov_b32\ts_restore_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR load using dw burst\n\ts_mov_b32\ts_restore_mem_offset_save, s_restore_mem_offset\t\t// restore start with v1, v0 will be the last\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 128*4\n\ts_mov_b32\tm0, 4\t\t\t\t\t\t\t//VGPR initial index value = 4\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\n\ts_cbranch_scc0\tL_RESTORE_SGPR\n\nL_RESTORE_VGPR_WAVE32_LOOP:\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1\n\tbuffer_load_dword\tv1, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:128\n\tbuffer_load_dword\tv2, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:128*2\n\tbuffer_load_dword\tv3, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:128*3\n\ts_waitcnt\tvmcnt(0)\n\tv_movreld_b32\tv0, v0\t\t\t\t\t\t\t//v[0+m0] = v0\n\tv_movreld_b32\tv1, v1\n\tv_movreld_b32\tv2, v2\n\tv_movreld_b32\tv3, v3\n\ts_add_u32\tm0, m0, 4\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 128*4\t//every buffer_load_dword does 128 bytes\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\t\t\t\t//scc = (m0 < s_restore_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_RESTORE_VGPR_WAVE32_LOOP\t\t\t\t//VGPR restore (except v0) is complete?\n\n\t/* VGPR restore on v0 */\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1\n\tbuffer_load_dword\tv1, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:128\n\tbuffer_load_dword\tv2, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:128*2\n\tbuffer_load_dword\tv3, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:128*3\n\ts_waitcnt\tvmcnt(0)\n\n\ts_branch\tL_RESTORE_SGPR\n\nL_RESTORE_VGPR_WAVE64:\n\ts_mov_b32\ts_restore_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\t// VGPR load using dw burst\n\ts_mov_b32\ts_restore_mem_offset_save, s_restore_mem_offset\t\t// restore start with v4, v0 will be the last\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 256*4\n\ts_mov_b32\tm0, 4\t\t\t\t\t\t\t//VGPR initial index value = 4\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\n\ts_cbranch_scc0\tL_RESTORE_SHARED_VGPR\n\nL_RESTORE_VGPR_WAVE64_LOOP:\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1\n\tbuffer_load_dword\tv1, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:256\n\tbuffer_load_dword\tv2, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:256*2\n\tbuffer_load_dword\tv3, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1 offset:256*3\n\ts_waitcnt\tvmcnt(0)\n\tv_movreld_b32\tv0, v0\t\t\t\t\t\t\t//v[0+m0] = v0\n\tv_movreld_b32\tv1, v1\n\tv_movreld_b32\tv2, v2\n\tv_movreld_b32\tv3, v3\n\ts_add_u32\tm0, m0, 4\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 256*4\t//every buffer_load_dword does 256 bytes\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\t\t\t\t//scc = (m0 < s_restore_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_RESTORE_VGPR_WAVE64_LOOP\t\t\t\t//VGPR restore (except v0) is complete?\n\nL_RESTORE_SHARED_VGPR:\n\t//Below part will be the restore shared vgpr part (new for gfx10)\n\ts_getreg_b32\ts_restore_alloc_size, hwreg(HW_REG_LDS_ALLOC,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SHIFT,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SIZE)\t//shared_vgpr_size\n\ts_and_b32\ts_restore_alloc_size, s_restore_alloc_size, 0xFFFFFFFF\t//shared_vgpr_size is zero?\n\ts_cbranch_scc0\tL_RESTORE_V0\t\t\t\t\t\t//no shared_vgpr used?\n\ts_lshl_b32\ts_restore_alloc_size, s_restore_alloc_size, 3\t\t//Number of SHARED_VGPRs = shared_vgpr_size * 8    (non-zero value)\n\t//m0 now has the value of normal vgpr count, just add the m0 with shared_vgpr count to get the total count.\n\t//restore shared_vgpr will start from the index of m0\n\ts_add_u32\ts_restore_alloc_size, s_restore_alloc_size, m0\n\ts_mov_b32\texec_lo, 0xFFFFFFFF\n\ts_mov_b32\texec_hi, 0x00000000\nL_RESTORE_SHARED_VGPR_WAVE64_LOOP:\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset slc:1 glc:1\n\ts_waitcnt\tvmcnt(0)\n\tv_movreld_b32\tv0, v0\t\t\t\t\t\t\t//v[0+m0] = v0\n\ts_add_u32\tm0, m0, 1\t\t\t\t\t\t//next vgpr index\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, 128\n\ts_cmp_lt_u32\tm0, s_restore_alloc_size\t\t\t\t//scc = (m0 < s_restore_alloc_size) ? 1 : 0\n\ts_cbranch_scc1\tL_RESTORE_SHARED_VGPR_WAVE64_LOOP\t\t\t//VGPR restore (except v0) is complete?\n\n\ts_mov_b32\texec_hi, 0xFFFFFFFF\t\t\t\t\t//restore back exec_hi before restoring V0!!\n\n\t/* VGPR restore on v0 */\nL_RESTORE_V0:\n\tbuffer_load_dword\tv0, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1\n\tbuffer_load_dword\tv1, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:256\n\tbuffer_load_dword\tv2, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:256*2\n\tbuffer_load_dword\tv3, v0, s_restore_buf_rsrc0, s_restore_mem_offset_save slc:1 glc:1 offset:256*3\n\ts_waitcnt\tvmcnt(0)\n\n\t/* restore SGPRs */\n\t//will be 2+8+16*6\n\t// SGPR SR memory offset : size(VGPR)+size(SVGPR)\nL_RESTORE_SGPR:\n\tget_vgpr_size_bytes(s_restore_mem_offset, s_restore_size)\n\tget_svgpr_size_bytes(s_restore_tmp)\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, s_restore_tmp\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, get_sgpr_size_bytes()\n\ts_sub_u32\ts_restore_mem_offset, s_restore_mem_offset, 20*4\t//s108~s127 is not saved\n\n\ts_mov_b32\ts_restore_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\ts_mov_b32\tm0, s_sgpr_save_num\n\n\tread_4sgpr_from_mem(s0, s_restore_buf_rsrc0, s_restore_mem_offset)\n\ts_waitcnt\tlgkmcnt(0)\n\n\ts_sub_u32\tm0, m0, 4\t\t\t\t\t\t// Restore from S[0] to S[104]\n\ts_nop\t\t0\t\t\t\t\t\t\t// hazard SALU M0=> S_MOVREL\n\n\ts_movreld_b64\ts0, s0\t\t\t\t\t\t\t//s[0+m0] = s0\n\ts_movreld_b64\ts2, s2\n\n\tread_8sgpr_from_mem(s0, s_restore_buf_rsrc0, s_restore_mem_offset)\n\ts_waitcnt\tlgkmcnt(0)\n\n\ts_sub_u32\tm0, m0, 8\t\t\t\t\t\t// Restore from S[0] to S[96]\n\ts_nop\t\t0\t\t\t\t\t\t\t// hazard SALU M0=> S_MOVREL\n\n\ts_movreld_b64\ts0, s0\t\t\t\t\t\t\t//s[0+m0] = s0\n\ts_movreld_b64\ts2, s2\n\ts_movreld_b64\ts4, s4\n\ts_movreld_b64\ts6, s6\n\n L_RESTORE_SGPR_LOOP:\n\tread_16sgpr_from_mem(s0, s_restore_buf_rsrc0, s_restore_mem_offset)\n\ts_waitcnt\tlgkmcnt(0)\n\n\ts_sub_u32\tm0, m0, 16\t\t\t\t\t\t// Restore from S[n] to S[0]\n\ts_nop\t\t0\t\t\t\t\t\t\t// hazard SALU M0=> S_MOVREL\n\n\ts_movreld_b64\ts0, s0\t\t\t\t\t\t\t//s[0+m0] = s0\n\ts_movreld_b64\ts2, s2\n\ts_movreld_b64\ts4, s4\n\ts_movreld_b64\ts6, s6\n\ts_movreld_b64\ts8, s8\n\ts_movreld_b64\ts10, s10\n\ts_movreld_b64\ts12, s12\n\ts_movreld_b64\ts14, s14\n\n\ts_cmp_eq_u32\tm0, 0\t\t\t\t\t\t\t//scc = (m0 < s_sgpr_save_num) ? 1 : 0\n\ts_cbranch_scc0\tL_RESTORE_SGPR_LOOP\n\n\t// s_barrier with MODE.DEBUG_EN=1, STATUS.PRIV=1 incorrectly asserts debug exception.\n\t// Clear DEBUG_EN before and restore MODE after the barrier.\n\ts_setreg_imm32_b32\thwreg(HW_REG_MODE), 0\n\ts_barrier\t\t\t\t\t\t\t\t//barrier to ensure the readiness of LDS before access attemps from any other wave in the same TG\n\n\t/* restore HW registers */\nL_RESTORE_HWREG:\n\t// HWREG SR memory offset : size(VGPR)+size(SVGPR)+size(SGPR)\n\tget_vgpr_size_bytes(s_restore_mem_offset, s_restore_size)\n\tget_svgpr_size_bytes(s_restore_tmp)\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, s_restore_tmp\n\ts_add_u32\ts_restore_mem_offset, s_restore_mem_offset, get_sgpr_size_bytes()\n\n\ts_mov_b32\ts_restore_buf_rsrc2, 0x1000000\t\t\t\t//NUM_RECORDS in bytes\n\n\tread_hwreg_from_mem(s_restore_m0, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_pc_lo, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_pc_hi, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_exec_lo, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_exec_hi, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_status, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_trapsts, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_xnack_mask, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_mode, s_restore_buf_rsrc0, s_restore_mem_offset)\n\tread_hwreg_from_mem(s_restore_flat_scratch, s_restore_buf_rsrc0, s_restore_mem_offset)\n\ts_waitcnt\tlgkmcnt(0)\n\n\ts_setreg_b32\thwreg(HW_REG_SHADER_FLAT_SCRATCH_LO), s_restore_flat_scratch\n\n\tread_hwreg_from_mem(s_restore_flat_scratch, s_restore_buf_rsrc0, s_restore_mem_offset)\n\ts_waitcnt\tlgkmcnt(0)\t\t\t\t\t\t//from now on, it is safe to restore STATUS and IB_STS\n\n\ts_setreg_b32\thwreg(HW_REG_SHADER_FLAT_SCRATCH_HI), s_restore_flat_scratch\n\n\ts_mov_b32\tm0, s_restore_m0\n\ts_mov_b32\texec_lo, s_restore_exec_lo\n\ts_mov_b32\texec_hi, s_restore_exec_hi\n\n\ts_and_b32\ts_restore_m0, SQ_WAVE_TRAPSTS_PRE_SAVECTX_MASK, s_restore_trapsts\n\ts_setreg_b32\thwreg(HW_REG_TRAPSTS, SQ_WAVE_TRAPSTS_PRE_SAVECTX_SHIFT, SQ_WAVE_TRAPSTS_PRE_SAVECTX_SIZE), s_restore_m0\n\n#if HAVE_XNACK\n\ts_setreg_b32\thwreg(HW_REG_SHADER_XNACK_MASK), s_restore_xnack_mask\n#endif\n\n\ts_and_b32\ts_restore_m0, SQ_WAVE_TRAPSTS_POST_SAVECTX_MASK, s_restore_trapsts\n\ts_lshr_b32\ts_restore_m0, s_restore_m0, SQ_WAVE_TRAPSTS_POST_SAVECTX_SHIFT\n\ts_setreg_b32\thwreg(HW_REG_TRAPSTS, SQ_WAVE_TRAPSTS_POST_SAVECTX_SHIFT, SQ_WAVE_TRAPSTS_POST_SAVECTX_SIZE), s_restore_m0\n\ts_setreg_b32\thwreg(HW_REG_MODE), s_restore_mode\n\n\t// Restore trap temporaries 4-11, 13 initialized by SPI debug dispatch logic\n\t// ttmp SR memory offset : size(VGPR)+size(SVGPR)+size(SGPR)+0x40\n\tget_vgpr_size_bytes(s_restore_ttmps_lo, s_restore_size)\n\tget_svgpr_size_bytes(s_restore_ttmps_hi)\n\ts_add_u32\ts_restore_ttmps_lo, s_restore_ttmps_lo, s_restore_ttmps_hi\n\ts_add_u32\ts_restore_ttmps_lo, s_restore_ttmps_lo, get_sgpr_size_bytes()\n\ts_add_u32\ts_restore_ttmps_lo, s_restore_ttmps_lo, s_restore_buf_rsrc0\n\ts_addc_u32\ts_restore_ttmps_hi, s_restore_buf_rsrc1, 0x0\n\ts_and_b32\ts_restore_ttmps_hi, s_restore_ttmps_hi, 0xFFFF\n\ts_load_dwordx4\t[ttmp4, ttmp5, ttmp6, ttmp7], [s_restore_ttmps_lo, s_restore_ttmps_hi], 0x50 glc:1\n\ts_load_dwordx4\t[ttmp8, ttmp9, ttmp10, ttmp11], [s_restore_ttmps_lo, s_restore_ttmps_hi], 0x60 glc:1\n\ts_load_dword\tttmp13, [s_restore_ttmps_lo, s_restore_ttmps_hi], 0x74 glc:1\n\ts_waitcnt\tlgkmcnt(0)\n\n#if HAVE_XNACK\n\trestore_ib_sts(s_restore_tmp, s_restore_m0)\n#endif\n\n\ts_and_b32\ts_restore_pc_hi, s_restore_pc_hi, 0x0000ffff\t\t//pc[47:32] //Do it here in order not to affect STATUS\n\ts_and_b64\texec, exec, exec\t\t\t\t\t// Restore STATUS.EXECZ, not writable by s_setreg_b32\n\ts_and_b64\tvcc, vcc, vcc\t\t\t\t\t\t// Restore STATUS.VCCZ, not writable by s_setreg_b32\n\n#if SW_SA_TRAP\n\t// If traps are enabled then return to the shader with PRIV=0.\n\t// Otherwise retain PRIV=1 for subsequent context save requests.\n\ts_getreg_b32\ts_restore_tmp, hwreg(HW_REG_STATUS)\n\ts_bitcmp1_b32\ts_restore_tmp, SQ_WAVE_STATUS_TRAP_EN_SHIFT\n\ts_cbranch_scc1\tL_RETURN_WITHOUT_PRIV\n\n\ts_setreg_b32\thwreg(HW_REG_STATUS), s_restore_status\t\t\t// SCC is included, which is changed by previous salu\n\ts_setpc_b64\t[s_restore_pc_lo, s_restore_pc_hi]\nL_RETURN_WITHOUT_PRIV:\n#endif\n\n\ts_setreg_b32\thwreg(HW_REG_STATUS), s_restore_status\t\t\t// SCC is included, which is changed by previous salu\n\ts_rfe_b64\ts_restore_pc_lo\t\t\t\t\t\t//Return to the main shader program and resume execution\n\nL_END_PGM:\n\ts_endpgm\nend\n\nfunction write_hwreg_to_mem(s, s_rsrc, s_mem_offset)\n#if NO_SQC_STORE\n\t// Copy into VGPR for later TCP store.\n\tv_writelane_b32\tv2, s, m0\n\ts_add_u32\tm0, m0, 0x1\n#else\n\ts_mov_b32\texec_lo, m0\n\ts_mov_b32\tm0, s_mem_offset\n\ts_buffer_store_dword\ts, s_rsrc, m0 glc:1\n\ts_add_u32\ts_mem_offset, s_mem_offset, 4\n\ts_mov_b32\tm0, exec_lo\n#endif\nend\n\n\nfunction write_16sgpr_to_mem(s, s_rsrc, s_mem_offset)\n#if NO_SQC_STORE\n\t// Copy into VGPR for later TCP store.\n\tfor var sgpr_idx = 0; sgpr_idx < 16; sgpr_idx ++\n\t\tv_writelane_b32\tv2, s[sgpr_idx], ttmp13\n\t\ts_add_u32\tttmp13, ttmp13, 0x1\n\tend\n#else\n\ts_buffer_store_dwordx4\ts[0], s_rsrc, 0 glc:1\n\ts_buffer_store_dwordx4\ts[4], s_rsrc, 16 glc:1\n\ts_buffer_store_dwordx4\ts[8], s_rsrc, 32 glc:1\n\ts_buffer_store_dwordx4\ts[12], s_rsrc, 48 glc:1\n\ts_add_u32\ts_rsrc[0], s_rsrc[0], 4*16\n\ts_addc_u32\ts_rsrc[1], s_rsrc[1], 0x0\n#endif\nend\n\nfunction write_12sgpr_to_mem(s, s_rsrc, s_mem_offset)\n#if NO_SQC_STORE\n\t// Copy into VGPR for later TCP store.\n\tfor var sgpr_idx = 0; sgpr_idx < 12; sgpr_idx ++\n\t\tv_writelane_b32\tv2, s[sgpr_idx], ttmp13\n\t\ts_add_u32\tttmp13, ttmp13, 0x1\n\tend\n#else\n\ts_buffer_store_dwordx4\ts[0], s_rsrc, 0 glc:1\n\ts_buffer_store_dwordx4\ts[4], s_rsrc, 16 glc:1\n\ts_buffer_store_dwordx4\ts[8], s_rsrc, 32 glc:1\n\ts_add_u32\ts_rsrc[0], s_rsrc[0], 4*12\n\ts_addc_u32\ts_rsrc[1], s_rsrc[1], 0x0\n#endif\nend\n\nfunction read_hwreg_from_mem(s, s_rsrc, s_mem_offset)\n\ts_buffer_load_dword\ts, s_rsrc, s_mem_offset glc:1\n\ts_add_u32\ts_mem_offset, s_mem_offset, 4\nend\n\nfunction read_16sgpr_from_mem(s, s_rsrc, s_mem_offset)\n\ts_sub_u32\ts_mem_offset, s_mem_offset, 4*16\n\ts_buffer_load_dwordx16\ts, s_rsrc, s_mem_offset glc:1\nend\n\nfunction read_8sgpr_from_mem(s, s_rsrc, s_mem_offset)\n\ts_sub_u32\ts_mem_offset, s_mem_offset, 4*8\n\ts_buffer_load_dwordx8\ts, s_rsrc, s_mem_offset glc:1\nend\n\nfunction read_4sgpr_from_mem(s, s_rsrc, s_mem_offset)\n\ts_sub_u32\ts_mem_offset, s_mem_offset, 4*4\n\ts_buffer_load_dwordx4\ts, s_rsrc, s_mem_offset glc:1\nend\n\n\nfunction get_lds_size_bytes(s_lds_size_byte)\n\ts_getreg_b32\ts_lds_size_byte, hwreg(HW_REG_LDS_ALLOC, SQ_WAVE_LDS_ALLOC_LDS_SIZE_SHIFT, SQ_WAVE_LDS_ALLOC_LDS_SIZE_SIZE)\n\ts_lshl_b32\ts_lds_size_byte, s_lds_size_byte, 8\t\t\t//LDS size in dwords = lds_size * 64 *4Bytes // granularity 64DW\nend\n\nfunction get_vgpr_size_bytes(s_vgpr_size_byte, s_size)\n\ts_getreg_b32\ts_vgpr_size_byte, hwreg(HW_REG_GPR_ALLOC,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SHIFT,SQ_WAVE_GPR_ALLOC_VGPR_SIZE_SIZE)\n\ts_add_u32\ts_vgpr_size_byte, s_vgpr_size_byte, 1\n\ts_bitcmp1_b32\ts_size, S_WAVE_SIZE\n\ts_cbranch_scc1\tL_ENABLE_SHIFT_W64\n\ts_lshl_b32\ts_vgpr_size_byte, s_vgpr_size_byte, (2+7)\t\t//Number of VGPRs = (vgpr_size + 1) * 4 * 32 * 4   (non-zero value)\n\ts_branch\tL_SHIFT_DONE\nL_ENABLE_SHIFT_W64:\n\ts_lshl_b32\ts_vgpr_size_byte, s_vgpr_size_byte, (2+8)\t\t//Number of VGPRs = (vgpr_size + 1) * 4 * 64 * 4   (non-zero value)\nL_SHIFT_DONE:\nend\n\nfunction get_svgpr_size_bytes(s_svgpr_size_byte)\n\ts_getreg_b32\ts_svgpr_size_byte, hwreg(HW_REG_LDS_ALLOC,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SHIFT,SQ_WAVE_LDS_ALLOC_VGPR_SHARED_SIZE_SIZE)\n\ts_lshl_b32\ts_svgpr_size_byte, s_svgpr_size_byte, (3+7)\nend\n\nfunction get_sgpr_size_bytes\n\treturn 512\nend\n\nfunction get_hwreg_size_bytes\n\treturn 128\nend\n\nfunction get_wave_size(s_reg)\n\ts_getreg_b32\ts_reg, hwreg(HW_REG_IB_STS2,SQ_WAVE_IB_STS2_WAVE64_SHIFT,SQ_WAVE_IB_STS2_WAVE64_SIZE)\n\ts_lshl_b32\ts_reg, s_reg, S_WAVE_SIZE\nend\n\nfunction save_and_clear_ib_sts(tmp1, tmp2)\n\t// Preserve and clear scalar XNACK state before issuing scalar loads.\n\t// Save IB_STS.REPLAY_W64H[25], RCNT[21:16], FIRST_REPLAY[15] into\n\t// unused space ttmp11[31:24].\n\ts_andn2_b32\tttmp11, ttmp11, (TTMP11_SAVE_REPLAY_W64H_MASK | TTMP11_SAVE_RCNT_FIRST_REPLAY_MASK)\n\ts_getreg_b32\ttmp1, hwreg(HW_REG_IB_STS)\n\ts_and_b32\ttmp2, tmp1, SQ_WAVE_IB_STS_REPLAY_W64H_MASK\n\ts_lshl_b32\ttmp2, tmp2, (TTMP11_SAVE_REPLAY_W64H_SHIFT - SQ_WAVE_IB_STS_REPLAY_W64H_SHIFT)\n\ts_or_b32\tttmp11, ttmp11, tmp2\n\ts_and_b32\ttmp2, tmp1, SQ_WAVE_IB_STS_RCNT_FIRST_REPLAY_MASK\n\ts_lshl_b32\ttmp2, tmp2, (TTMP11_SAVE_RCNT_FIRST_REPLAY_SHIFT - SQ_WAVE_IB_STS_FIRST_REPLAY_SHIFT)\n\ts_or_b32\tttmp11, ttmp11, tmp2\n\ts_andn2_b32\ttmp1, tmp1, (SQ_WAVE_IB_STS_REPLAY_W64H_MASK | SQ_WAVE_IB_STS_RCNT_FIRST_REPLAY_MASK)\n\ts_setreg_b32\thwreg(HW_REG_IB_STS), tmp1\nend\n\nfunction restore_ib_sts(tmp1, tmp2)\n\ts_lshr_b32\ttmp1, ttmp11, (TTMP11_SAVE_RCNT_FIRST_REPLAY_SHIFT - SQ_WAVE_IB_STS_FIRST_REPLAY_SHIFT)\n\ts_and_b32\ttmp2, tmp1, SQ_WAVE_IB_STS_RCNT_FIRST_REPLAY_MASK\n\ts_lshr_b32\ttmp1, ttmp11, (TTMP11_SAVE_REPLAY_W64H_SHIFT - SQ_WAVE_IB_STS_REPLAY_W64H_SHIFT)\n\ts_and_b32\ttmp1, tmp1, SQ_WAVE_IB_STS_REPLAY_W64H_MASK\n\ts_or_b32\ttmp1, tmp1, tmp2\n\ts_setreg_b32\thwreg(HW_REG_IB_STS), tmp1\nend\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}