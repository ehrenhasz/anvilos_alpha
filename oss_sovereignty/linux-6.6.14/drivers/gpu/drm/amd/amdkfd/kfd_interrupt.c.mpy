{
  "module_name": "kfd_interrupt.c",
  "hash_id": "43d311a90822938c30f89d70b86dc279ec971b998e34f83ca517bb7c4ca6136b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kfifo.h>\n#include \"kfd_priv.h\"\n\n#define KFD_IH_NUM_ENTRIES 8192\n\nstatic void interrupt_wq(struct work_struct *);\n\nint kfd_interrupt_init(struct kfd_node *node)\n{\n\tint r;\n\n\tr = kfifo_alloc(&node->ih_fifo,\n\t\tKFD_IH_NUM_ENTRIES * node->kfd->device_info.ih_ring_entry_size,\n\t\tGFP_KERNEL);\n\tif (r) {\n\t\tdev_err(node->adev->dev, \"Failed to allocate IH fifo\\n\");\n\t\treturn r;\n\t}\n\n\tnode->ih_wq = alloc_workqueue(\"KFD IH\", WQ_HIGHPRI, 1);\n\tif (unlikely(!node->ih_wq)) {\n\t\tkfifo_free(&node->ih_fifo);\n\t\tdev_err(node->adev->dev, \"Failed to allocate KFD IH workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_init(&node->interrupt_lock);\n\n\tINIT_WORK(&node->interrupt_work, interrupt_wq);\n\n\tnode->interrupts_active = true;\n\n\t \n\tsmp_wmb();\n\n\treturn 0;\n}\n\nvoid kfd_interrupt_exit(struct kfd_node *node)\n{\n\t \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&node->interrupt_lock, flags);\n\tnode->interrupts_active = false;\n\tspin_unlock_irqrestore(&node->interrupt_lock, flags);\n\n\t \n\tflush_workqueue(node->ih_wq);\n\n\tkfifo_free(&node->ih_fifo);\n}\n\n \nbool enqueue_ih_ring_entry(struct kfd_node *node, const void *ih_ring_entry)\n{\n\tint count;\n\n\tcount = kfifo_in(&node->ih_fifo, ih_ring_entry,\n\t\t\t\tnode->kfd->device_info.ih_ring_entry_size);\n\tif (count != node->kfd->device_info.ih_ring_entry_size) {\n\t\tdev_dbg_ratelimited(node->adev->dev,\n\t\t\t\"Interrupt ring overflow, dropping interrupt %d\\n\",\n\t\t\tcount);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool dequeue_ih_ring_entry(struct kfd_node *node, void *ih_ring_entry)\n{\n\tint count;\n\n\tcount = kfifo_out(&node->ih_fifo, ih_ring_entry,\n\t\t\t\tnode->kfd->device_info.ih_ring_entry_size);\n\n\tWARN_ON(count && count != node->kfd->device_info.ih_ring_entry_size);\n\n\treturn count == node->kfd->device_info.ih_ring_entry_size;\n}\n\nstatic void interrupt_wq(struct work_struct *work)\n{\n\tstruct kfd_node *dev = container_of(work, struct kfd_node,\n\t\t\t\t\t\tinterrupt_work);\n\tuint32_t ih_ring_entry[KFD_MAX_RING_ENTRY_SIZE];\n\tunsigned long start_jiffies = jiffies;\n\n\tif (dev->kfd->device_info.ih_ring_entry_size > sizeof(ih_ring_entry)) {\n\t\tdev_err_once(dev->adev->dev, \"Ring entry too small\\n\");\n\t\treturn;\n\t}\n\n\twhile (dequeue_ih_ring_entry(dev, ih_ring_entry)) {\n\t\tdev->kfd->device_info.event_interrupt_class->interrupt_wq(dev,\n\t\t\t\t\t\t\t\tih_ring_entry);\n\t\tif (time_is_before_jiffies(start_jiffies + HZ)) {\n\t\t\t \n\t\t\tqueue_work(dev->ih_wq, &dev->interrupt_work);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool interrupt_is_wanted(struct kfd_node *dev,\n\t\t\tconst uint32_t *ih_ring_entry,\n\t\t\tuint32_t *patched_ihre, bool *flag)\n{\n\t \n\tunsigned int wanted = 0;\n\n\twanted |= dev->kfd->device_info.event_interrupt_class->interrupt_isr(dev,\n\t\t\t\t\t ih_ring_entry, patched_ihre, flag);\n\n\treturn wanted != 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}