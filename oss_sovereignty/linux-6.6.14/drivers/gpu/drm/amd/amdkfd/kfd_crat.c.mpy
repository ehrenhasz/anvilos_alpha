{
  "module_name": "kfd_crat.c",
  "hash_id": "0ac348b7bc939725ad8a61aeb83ee5130b9f86933af575485bc1e5c6accd0892",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_crat.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include \"kfd_crat.h\"\n#include \"kfd_priv.h\"\n#include \"kfd_topology.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_amdkfd.h\"\n\n \nstatic uint32_t gpu_processor_id_low = 0x80001000;\n\n \nstatic inline unsigned int get_and_inc_gpu_processor_id(\n\t\t\t\tunsigned int total_cu_count)\n{\n\tint current_id = gpu_processor_id_low;\n\n\tgpu_processor_id_low += total_cu_count;\n\treturn current_id;\n}\n\n\nstatic struct kfd_gpu_cache_info kaveri_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 8,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\n\t \n};\n\n\nstatic struct kfd_gpu_cache_info carrizo_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 8,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 4,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 4,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 4,\n\t},\n\n\t \n};\n\n#define hawaii_cache_info kaveri_cache_info\n#define tonga_cache_info carrizo_cache_info\n#define fiji_cache_info  carrizo_cache_info\n#define polaris10_cache_info carrizo_cache_info\n#define polaris11_cache_info carrizo_cache_info\n#define polaris12_cache_info carrizo_cache_info\n#define vegam_cache_info carrizo_cache_info\n\n \n\nstatic struct kfd_gpu_cache_info vega10_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 4096,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 16,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info raven_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 1024,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 11,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info renoir_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 1024,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info vega12_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 2048,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 5,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info vega20_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 3,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 8192,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 16,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info aldebaran_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 8192,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 14,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info navi10_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 4096,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info vangogh_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 1024,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info navi14_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 12,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 2048,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 12,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info sienna_cichlid_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 4096,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128*1024,\n\t\t.cache_level = 3,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info navy_flounder_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 3072,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 96*1024,\n\t\t.cache_level = 3,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 10,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info dimgrey_cavefish_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 2048,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32*1024,\n\t\t.cache_level = 3,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info beige_goby_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 1024,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16*1024,\n\t\t.cache_level = 3,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 8,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info yellow_carp_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 6,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 2048,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 6,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info gfx1037_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 256,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info gc_10_3_6_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t  CRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t  CRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t  CRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t  CRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t  CRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t  CRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t  CRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t  CRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 256,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t  CRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t  CRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n};\n\nstatic struct kfd_gpu_cache_info dummy_cache_info[] = {\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 1,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 32,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 16,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 2,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 128,\n\t\t.cache_level = 1,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 6,\n\t},\n\t{\n\t\t \n\t\t.cache_size = 2048,\n\t\t.cache_level = 2,\n\t\t.flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE),\n\t\t.num_cu_shared = 6,\n\t},\n};\n\nstatic void kfd_populated_cu_info_cpu(struct kfd_topology_device *dev,\n\t\tstruct crat_subtype_computeunit *cu)\n{\n\tdev->node_props.cpu_cores_count = cu->num_cpu_cores;\n\tdev->node_props.cpu_core_id_base = cu->processor_id_low;\n\tif (cu->hsa_capability & CRAT_CU_FLAGS_IOMMU_PRESENT)\n\t\tdev->node_props.capability |= HSA_CAP_ATS_PRESENT;\n\n\tpr_debug(\"CU CPU: cores=%d id_base=%d\\n\", cu->num_cpu_cores,\n\t\t\tcu->processor_id_low);\n}\n\nstatic void kfd_populated_cu_info_gpu(struct kfd_topology_device *dev,\n\t\tstruct crat_subtype_computeunit *cu)\n{\n\tdev->node_props.simd_id_base = cu->processor_id_low;\n\tdev->node_props.simd_count = cu->num_simd_cores;\n\tdev->node_props.lds_size_in_kb = cu->lds_size_in_kb;\n\tdev->node_props.max_waves_per_simd = cu->max_waves_simd;\n\tdev->node_props.wave_front_size = cu->wave_front_size;\n\tdev->node_props.array_count = cu->array_count;\n\tdev->node_props.cu_per_simd_array = cu->num_cu_per_array;\n\tdev->node_props.simd_per_cu = cu->num_simd_per_cu;\n\tdev->node_props.max_slots_scratch_cu = cu->max_slots_scatch_cu;\n\tif (cu->hsa_capability & CRAT_CU_FLAGS_HOT_PLUGGABLE)\n\t\tdev->node_props.capability |= HSA_CAP_HOT_PLUGGABLE;\n\tpr_debug(\"CU GPU: id_base=%d\\n\", cu->processor_id_low);\n}\n\n \nstatic int kfd_parse_subtype_cu(struct crat_subtype_computeunit *cu,\n\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_topology_device *dev;\n\n\tpr_debug(\"Found CU entry in CRAT table with proximity_domain=%d caps=%x\\n\",\n\t\t\tcu->proximity_domain, cu->hsa_capability);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (cu->proximity_domain == dev->proximity_domain) {\n\t\t\tif (cu->flags & CRAT_CU_FLAGS_CPU_PRESENT)\n\t\t\t\tkfd_populated_cu_info_cpu(dev, cu);\n\n\t\t\tif (cu->flags & CRAT_CU_FLAGS_GPU_PRESENT)\n\t\t\t\tkfd_populated_cu_info_gpu(dev, cu);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct kfd_mem_properties *\nfind_subtype_mem(uint32_t heap_type, uint32_t flags, uint32_t width,\n\t\tstruct kfd_topology_device *dev)\n{\n\tstruct kfd_mem_properties *props;\n\n\tlist_for_each_entry(props, &dev->mem_props, list) {\n\t\tif (props->heap_type == heap_type\n\t\t\t\t&& props->flags == flags\n\t\t\t\t&& props->width == width)\n\t\t\treturn props;\n\t}\n\n\treturn NULL;\n}\n \nstatic int kfd_parse_subtype_mem(struct crat_subtype_memory *mem,\n\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_mem_properties *props;\n\tstruct kfd_topology_device *dev;\n\tuint32_t heap_type;\n\tuint64_t size_in_bytes;\n\tuint32_t flags = 0;\n\tuint32_t width;\n\n\tpr_debug(\"Found memory entry in CRAT table with proximity_domain=%d\\n\",\n\t\t\tmem->proximity_domain);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (mem->proximity_domain == dev->proximity_domain) {\n\t\t\t \n\t\t\tif (dev->node_props.cpu_cores_count == 0) {\n\t\t\t\t \n\t\t\t\tif (mem->visibility_type == 0)\n\t\t\t\t\theap_type =\n\t\t\t\t\t\tHSA_MEM_HEAP_TYPE_FB_PRIVATE;\n\t\t\t\t \n\t\t\t\telse\n\t\t\t\t\theap_type = mem->visibility_type;\n\t\t\t} else\n\t\t\t\theap_type = HSA_MEM_HEAP_TYPE_SYSTEM;\n\n\t\t\tif (mem->flags & CRAT_MEM_FLAGS_HOT_PLUGGABLE)\n\t\t\t\tflags |= HSA_MEM_FLAGS_HOT_PLUGGABLE;\n\t\t\tif (mem->flags & CRAT_MEM_FLAGS_NON_VOLATILE)\n\t\t\t\tflags |= HSA_MEM_FLAGS_NON_VOLATILE;\n\n\t\t\tsize_in_bytes =\n\t\t\t\t((uint64_t)mem->length_high << 32) +\n\t\t\t\t\t\t\tmem->length_low;\n\t\t\twidth = mem->width;\n\n\t\t\t \n\t\t\tprops = find_subtype_mem(heap_type, flags, width, dev);\n\t\t\tif (props) {\n\t\t\t\tprops->size_in_bytes += size_in_bytes;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->heap_type = heap_type;\n\t\t\tprops->flags = flags;\n\t\t\tprops->size_in_bytes = size_in_bytes;\n\t\t\tprops->width = width;\n\n\t\t\tdev->node_props.mem_banks_count++;\n\t\t\tlist_add_tail(&props->list, &dev->mem_props);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kfd_parse_subtype_cache(struct crat_subtype_cache *cache,\n\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_cache_properties *props;\n\tstruct kfd_topology_device *dev;\n\tuint32_t id;\n\tuint32_t total_num_of_cu;\n\n\tid = cache->processor_id_low;\n\n\tpr_debug(\"Found cache entry in CRAT table with processor_id=%d\\n\", id);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\ttotal_num_of_cu = (dev->node_props.array_count *\n\t\t\t\t\tdev->node_props.cu_per_simd_array);\n\n\t\t \n\t\tif ((id >= dev->node_props.cpu_core_id_base &&\n\t\t\tid <= dev->node_props.cpu_core_id_base +\n\t\t\t\tdev->node_props.cpu_cores_count) ||\n\t\t\t(id >= dev->node_props.simd_id_base &&\n\t\t\tid < dev->node_props.simd_id_base +\n\t\t\t\ttotal_num_of_cu)) {\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->processor_id_low = id;\n\t\t\tprops->cache_level = cache->cache_level;\n\t\t\tprops->cache_size = cache->cache_size;\n\t\t\tprops->cacheline_size = cache->cache_line_size;\n\t\t\tprops->cachelines_per_tag = cache->lines_per_tag;\n\t\t\tprops->cache_assoc = cache->associativity;\n\t\t\tprops->cache_latency = cache->cache_latency;\n\n\t\t\tmemcpy(props->sibling_map, cache->sibling_map,\n\t\t\t\t\tCRAT_SIBLINGMAP_SIZE);\n\n\t\t\t \n\t\t\tprops->sibling_map_size = CRAT_SIBLINGMAP_SIZE;\n\n\t\t\tif (cache->flags & CRAT_CACHE_FLAGS_DATA_CACHE)\n\t\t\t\tprops->cache_type |= HSA_CACHE_TYPE_DATA;\n\t\t\tif (cache->flags & CRAT_CACHE_FLAGS_INST_CACHE)\n\t\t\t\tprops->cache_type |= HSA_CACHE_TYPE_INSTRUCTION;\n\t\t\tif (cache->flags & CRAT_CACHE_FLAGS_CPU_CACHE)\n\t\t\t\tprops->cache_type |= HSA_CACHE_TYPE_CPU;\n\t\t\tif (cache->flags & CRAT_CACHE_FLAGS_SIMD_CACHE)\n\t\t\t\tprops->cache_type |= HSA_CACHE_TYPE_HSACU;\n\n\t\t\tdev->node_props.caches_count++;\n\t\t\tlist_add_tail(&props->list, &dev->cache_props);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,\n\t\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_iolink_properties *props = NULL, *props2;\n\tstruct kfd_topology_device *dev, *to_dev;\n\tuint32_t id_from;\n\tuint32_t id_to;\n\n\tid_from = iolink->proximity_domain_from;\n\tid_to = iolink->proximity_domain_to;\n\n\tpr_debug(\"Found IO link entry in CRAT table with id_from=%d, id_to %d\\n\",\n\t\t\tid_from, id_to);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (id_from == dev->proximity_domain) {\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->node_from = id_from;\n\t\t\tprops->node_to = id_to;\n\t\t\tprops->ver_maj = iolink->version_major;\n\t\t\tprops->ver_min = iolink->version_minor;\n\t\t\tprops->iolink_type = iolink->io_interface_type;\n\n\t\t\tif (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)\n\t\t\t\tprops->weight = 20;\n\t\t\telse if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)\n\t\t\t\tprops->weight = iolink->weight_xgmi;\n\t\t\telse\n\t\t\t\tprops->weight = node_distance(id_from, id_to);\n\n\t\t\tprops->min_latency = iolink->minimum_latency;\n\t\t\tprops->max_latency = iolink->maximum_latency;\n\t\t\tprops->min_bandwidth = iolink->minimum_bandwidth_mbs;\n\t\t\tprops->max_bandwidth = iolink->maximum_bandwidth_mbs;\n\t\t\tprops->rec_transfer_size =\n\t\t\t\t\tiolink->recommended_transfer_size;\n\n\t\t\tdev->node_props.io_links_count++;\n\t\t\tlist_add_tail(&props->list, &dev->io_link_props);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {\n\t\tto_dev = kfd_topology_device_by_proximity_domain_no_lock(id_to);\n\t\tif (!to_dev)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tprops2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);\n\t\tif (!props2)\n\t\t\treturn -ENOMEM;\n\n\t\tprops2->node_from = id_to;\n\t\tprops2->node_to = id_from;\n\t\tprops2->kobj = NULL;\n\t\tto_dev->node_props.io_links_count++;\n\t\tlist_add_tail(&props2->list, &to_dev->io_link_props);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kfd_parse_subtype(struct crat_subtype_generic *sub_type_hdr,\n\t\t\t\tstruct list_head *device_list)\n{\n\tstruct crat_subtype_computeunit *cu;\n\tstruct crat_subtype_memory *mem;\n\tstruct crat_subtype_cache *cache;\n\tstruct crat_subtype_iolink *iolink;\n\tint ret = 0;\n\n\tswitch (sub_type_hdr->type) {\n\tcase CRAT_SUBTYPE_COMPUTEUNIT_AFFINITY:\n\t\tcu = (struct crat_subtype_computeunit *)sub_type_hdr;\n\t\tret = kfd_parse_subtype_cu(cu, device_list);\n\t\tbreak;\n\tcase CRAT_SUBTYPE_MEMORY_AFFINITY:\n\t\tmem = (struct crat_subtype_memory *)sub_type_hdr;\n\t\tret = kfd_parse_subtype_mem(mem, device_list);\n\t\tbreak;\n\tcase CRAT_SUBTYPE_CACHE_AFFINITY:\n\t\tcache = (struct crat_subtype_cache *)sub_type_hdr;\n\t\tret = kfd_parse_subtype_cache(cache, device_list);\n\t\tbreak;\n\tcase CRAT_SUBTYPE_TLB_AFFINITY:\n\t\t \n\t\tpr_debug(\"Found TLB entry in CRAT table (not processing)\\n\");\n\t\tbreak;\n\tcase CRAT_SUBTYPE_CCOMPUTE_AFFINITY:\n\t\t \n\t\tpr_debug(\"Found CCOMPUTE entry in CRAT table (not processing)\\n\");\n\t\tbreak;\n\tcase CRAT_SUBTYPE_IOLINK_AFFINITY:\n\t\tiolink = (struct crat_subtype_iolink *)sub_type_hdr;\n\t\tret = kfd_parse_subtype_iolink(iolink, device_list);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unknown subtype %d in CRAT\\n\",\n\t\t\t\tsub_type_hdr->type);\n\t}\n\n\treturn ret;\n}\n\n \nint kfd_parse_crat_table(void *crat_image, struct list_head *device_list,\n\t\t\t uint32_t proximity_domain)\n{\n\tstruct kfd_topology_device *top_dev = NULL;\n\tstruct crat_subtype_generic *sub_type_hdr;\n\tuint16_t node_id;\n\tint ret = 0;\n\tstruct crat_header *crat_table = (struct crat_header *)crat_image;\n\tuint16_t num_nodes;\n\tuint32_t image_len;\n\n\tif (!crat_image)\n\t\treturn -EINVAL;\n\n\tif (!list_empty(device_list)) {\n\t\tpr_warn(\"Error device list should be empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_nodes = crat_table->num_domains;\n\timage_len = crat_table->length;\n\n\tpr_debug(\"Parsing CRAT table with %d nodes\\n\", num_nodes);\n\n\tfor (node_id = 0; node_id < num_nodes; node_id++) {\n\t\ttop_dev = kfd_create_topology_device(device_list);\n\t\tif (!top_dev)\n\t\t\tbreak;\n\t\ttop_dev->proximity_domain = proximity_domain++;\n\t}\n\n\tif (!top_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmemcpy(top_dev->oem_id, crat_table->oem_id, CRAT_OEMID_LENGTH);\n\tmemcpy(top_dev->oem_table_id, crat_table->oem_table_id,\n\t\t\tCRAT_OEMTABLEID_LENGTH);\n\ttop_dev->oem_revision = crat_table->oem_revision;\n\n\tsub_type_hdr = (struct crat_subtype_generic *)(crat_table+1);\n\twhile ((char *)sub_type_hdr + sizeof(struct crat_subtype_generic) <\n\t\t\t((char *)crat_image) + image_len) {\n\t\tif (sub_type_hdr->flags & CRAT_SUBTYPE_FLAGS_ENABLED) {\n\t\t\tret = kfd_parse_subtype(sub_type_hdr, device_list);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\t\t\tsub_type_hdr->length);\n\t}\n\nerr:\n\tif (ret)\n\t\tkfd_release_topology_device_list(device_list);\n\n\treturn ret;\n}\n\n\nstatic int kfd_fill_gpu_cache_info_from_gfx_config(struct kfd_dev *kdev,\n\t\t\t\t\t\t   struct kfd_gpu_cache_info *pcache_info)\n{\n\tstruct amdgpu_device *adev = kdev->adev;\n\tint i = 0;\n\n\t \n\tif (adev->gfx.config.gc_tcp_l1_size) {\n\t\tpcache_info[i].cache_size = adev->gfx.config.gc_tcp_l1_size;\n\t\tpcache_info[i].cache_level = 1;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[0].num_cu_shared = adev->gfx.config.gc_num_tcp_per_wpg / 2;\n\t\ti++;\n\t}\n\t \n\tif (adev->gfx.config.gc_l1_instruction_cache_size_per_sqc) {\n\t\tpcache_info[i].cache_size =\n\t\t\tadev->gfx.config.gc_l1_instruction_cache_size_per_sqc;\n\t\tpcache_info[i].cache_level = 1;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_INST_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[i].num_cu_shared = adev->gfx.config.gc_num_sqc_per_wgp * 2;\n\t\ti++;\n\t}\n\t \n\tif (adev->gfx.config.gc_l1_data_cache_size_per_sqc) {\n\t\tpcache_info[i].cache_size = adev->gfx.config.gc_l1_data_cache_size_per_sqc;\n\t\tpcache_info[i].cache_level = 1;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[i].num_cu_shared = adev->gfx.config.gc_num_sqc_per_wgp * 2;\n\t\ti++;\n\t}\n\t \n\tif (adev->gfx.config.gc_gl1c_per_sa &&\n\t    adev->gfx.config.gc_gl1c_size_per_instance) {\n\t\tpcache_info[i].cache_size = adev->gfx.config.gc_gl1c_per_sa *\n\t\t\tadev->gfx.config.gc_gl1c_size_per_instance;\n\t\tpcache_info[i].cache_level = 1;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[i].num_cu_shared = adev->gfx.config.max_cu_per_sh;\n\t\ti++;\n\t}\n\t \n\tif (adev->gfx.config.gc_gl2c_per_gpu) {\n\t\tpcache_info[i].cache_size = adev->gfx.config.gc_gl2c_per_gpu;\n\t\tpcache_info[i].cache_level = 2;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[i].num_cu_shared = adev->gfx.config.max_cu_per_sh;\n\t\ti++;\n\t}\n\t \n\tif (adev->gmc.mall_size) {\n\t\tpcache_info[i].cache_size = adev->gmc.mall_size / 1024;\n\t\tpcache_info[i].cache_level = 3;\n\t\tpcache_info[i].flags = (CRAT_CACHE_FLAGS_ENABLED |\n\t\t\t\t\tCRAT_CACHE_FLAGS_DATA_CACHE |\n\t\t\t\t\tCRAT_CACHE_FLAGS_SIMD_CACHE);\n\t\tpcache_info[i].num_cu_shared = adev->gfx.config.max_cu_per_sh;\n\t\ti++;\n\t}\n\treturn i;\n}\n\nint kfd_get_gpu_cache_info(struct kfd_node *kdev, struct kfd_gpu_cache_info **pcache_info)\n{\n\tint num_of_cache_types = 0;\n\n\tswitch (kdev->adev->asic_type) {\n\tcase CHIP_KAVERI:\n\t\t*pcache_info = kaveri_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(kaveri_cache_info);\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\t*pcache_info = hawaii_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(hawaii_cache_info);\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\t*pcache_info = carrizo_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(carrizo_cache_info);\n\t\tbreak;\n\tcase CHIP_TONGA:\n\t\t*pcache_info = tonga_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(tonga_cache_info);\n\t\tbreak;\n\tcase CHIP_FIJI:\n\t\t*pcache_info = fiji_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(fiji_cache_info);\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\t\t*pcache_info = polaris10_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(polaris10_cache_info);\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\t\t*pcache_info = polaris11_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(polaris11_cache_info);\n\t\tbreak;\n\tcase CHIP_POLARIS12:\n\t\t*pcache_info = polaris12_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(polaris12_cache_info);\n\t\tbreak;\n\tcase CHIP_VEGAM:\n\t\t*pcache_info = vegam_cache_info;\n\t\tnum_of_cache_types = ARRAY_SIZE(vegam_cache_info);\n\t\tbreak;\n\tdefault:\n\t\tswitch (KFD_GC_VERSION(kdev)) {\n\t\tcase IP_VERSION(9, 0, 1):\n\t\t\t*pcache_info = vega10_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(vega10_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(9, 2, 1):\n\t\t\t*pcache_info = vega12_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(vega12_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(9, 4, 0):\n\t\tcase IP_VERSION(9, 4, 1):\n\t\t\t*pcache_info = vega20_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(vega20_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(9, 4, 2):\n\t\tcase IP_VERSION(9, 4, 3):\n\t\t\t*pcache_info = aldebaran_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(aldebaran_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(9, 1, 0):\n\t\tcase IP_VERSION(9, 2, 2):\n\t\t\t*pcache_info = raven_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(raven_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(9, 3, 0):\n\t\t\t*pcache_info = renoir_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(renoir_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 1, 10):\n\t\tcase IP_VERSION(10, 1, 2):\n\t\tcase IP_VERSION(10, 1, 3):\n\t\tcase IP_VERSION(10, 1, 4):\n\t\t\t*pcache_info = navi10_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(navi10_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 1, 1):\n\t\t\t*pcache_info = navi14_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(navi14_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 0):\n\t\t\t*pcache_info = sienna_cichlid_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(sienna_cichlid_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 2):\n\t\t\t*pcache_info = navy_flounder_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(navy_flounder_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 4):\n\t\t\t*pcache_info = dimgrey_cavefish_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(dimgrey_cavefish_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 1):\n\t\t\t*pcache_info = vangogh_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(vangogh_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 5):\n\t\t\t*pcache_info = beige_goby_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(beige_goby_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 3):\n\t\t\t*pcache_info = yellow_carp_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(yellow_carp_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 6):\n\t\t\t*pcache_info = gc_10_3_6_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(gc_10_3_6_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(10, 3, 7):\n\t\t\t*pcache_info = gfx1037_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(gfx1037_cache_info);\n\t\t\tbreak;\n\t\tcase IP_VERSION(11, 0, 0):\n\t\tcase IP_VERSION(11, 0, 1):\n\t\tcase IP_VERSION(11, 0, 2):\n\t\tcase IP_VERSION(11, 0, 3):\n\t\tcase IP_VERSION(11, 0, 4):\n\t\t\tnum_of_cache_types =\n\t\t\t\tkfd_fill_gpu_cache_info_from_gfx_config(kdev->kfd, *pcache_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*pcache_info = dummy_cache_info;\n\t\t\tnum_of_cache_types = ARRAY_SIZE(dummy_cache_info);\n\t\t\tpr_warn(\"dummy cache info is used temporarily and real cache info need update later.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_of_cache_types;\n}\n\n \n#define VCRAT_SIZE_FOR_GPU\t(4 * PAGE_SIZE)\n\n \nstatic int kfd_fill_cu_for_cpu(int numa_node_id, int *avail_size,\n\t\t\t\tint proximity_domain,\n\t\t\t\tstruct crat_subtype_computeunit *sub_type_hdr)\n{\n\tconst struct cpumask *cpumask;\n\n\t*avail_size -= sizeof(struct crat_subtype_computeunit);\n\tif (*avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset(sub_type_hdr, 0, sizeof(struct crat_subtype_computeunit));\n\n\t \n\tsub_type_hdr->type = CRAT_SUBTYPE_COMPUTEUNIT_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_computeunit);\n\tsub_type_hdr->flags = CRAT_SUBTYPE_FLAGS_ENABLED;\n\n\tcpumask = cpumask_of_node(numa_node_id);\n\n\t \n\tsub_type_hdr->flags |= CRAT_CU_FLAGS_CPU_PRESENT;\n\tsub_type_hdr->proximity_domain = proximity_domain;\n\tsub_type_hdr->processor_id_low = kfd_numa_node_to_apic_id(numa_node_id);\n\tif (sub_type_hdr->processor_id_low == -1)\n\t\treturn -EINVAL;\n\n\tsub_type_hdr->num_cpu_cores = cpumask_weight(cpumask);\n\n\treturn 0;\n}\n\n \nstatic int kfd_fill_mem_info_for_cpu(int numa_node_id, int *avail_size,\n\t\t\tint proximity_domain,\n\t\t\tstruct crat_subtype_memory *sub_type_hdr)\n{\n\tuint64_t mem_in_bytes = 0;\n\tpg_data_t *pgdat;\n\tint zone_type;\n\n\t*avail_size -= sizeof(struct crat_subtype_memory);\n\tif (*avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset(sub_type_hdr, 0, sizeof(struct crat_subtype_memory));\n\n\t \n\tsub_type_hdr->type = CRAT_SUBTYPE_MEMORY_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_memory);\n\tsub_type_hdr->flags = CRAT_SUBTYPE_FLAGS_ENABLED;\n\n\t \n\n\t \n\tpgdat = NODE_DATA(numa_node_id);\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmem_in_bytes += zone_managed_pages(&pgdat->node_zones[zone_type]);\n\tmem_in_bytes <<= PAGE_SHIFT;\n\n\tsub_type_hdr->length_low = lower_32_bits(mem_in_bytes);\n\tsub_type_hdr->length_high = upper_32_bits(mem_in_bytes);\n\tsub_type_hdr->proximity_domain = proximity_domain;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\nstatic int kfd_fill_iolink_info_for_cpu(int numa_node_id, int *avail_size,\n\t\t\t\tuint32_t *num_entries,\n\t\t\t\tstruct crat_subtype_iolink *sub_type_hdr)\n{\n\tint nid;\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tuint8_t link_type;\n\n\tif (c->x86_vendor == X86_VENDOR_AMD)\n\t\tlink_type = CRAT_IOLINK_TYPE_HYPERTRANSPORT;\n\telse\n\t\tlink_type = CRAT_IOLINK_TYPE_QPI_1_1;\n\n\t*num_entries = 0;\n\n\t \n\tfor_each_online_node(nid) {\n\t\tif (nid == numa_node_id)  \n\t\t\tcontinue;\n\n\t\t*avail_size -= sizeof(struct crat_subtype_iolink);\n\t\tif (*avail_size < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(sub_type_hdr, 0, sizeof(struct crat_subtype_iolink));\n\n\t\t \n\t\tsub_type_hdr->type = CRAT_SUBTYPE_IOLINK_AFFINITY;\n\t\tsub_type_hdr->length = sizeof(struct crat_subtype_iolink);\n\t\tsub_type_hdr->flags = CRAT_SUBTYPE_FLAGS_ENABLED;\n\n\t\t \n\t\tsub_type_hdr->proximity_domain_from = numa_node_id;\n\t\tsub_type_hdr->proximity_domain_to = nid;\n\t\tsub_type_hdr->io_interface_type = link_type;\n\n\t\t(*num_entries)++;\n\t\tsub_type_hdr++;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nstatic int kfd_create_vcrat_image_cpu(void *pcrat_image, size_t *size)\n{\n\tstruct crat_header *crat_table = (struct crat_header *)pcrat_image;\n\tstruct acpi_table_header *acpi_table;\n\tacpi_status status;\n\tstruct crat_subtype_generic *sub_type_hdr;\n\tint avail_size = *size;\n\tint numa_node_id;\n#ifdef CONFIG_X86_64\n\tuint32_t entries = 0;\n#endif\n\tint ret = 0;\n\n\tif (!pcrat_image)\n\t\treturn -EINVAL;\n\n\t \n\tavail_size -= sizeof(struct crat_header);\n\tif (avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset(crat_table, 0, sizeof(struct crat_header));\n\tmemcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature));\n\tcrat_table->length = sizeof(struct crat_header);\n\n\tstatus = acpi_get_table(\"DSDT\", 0, &acpi_table);\n\tif (status != AE_OK)\n\t\tpr_warn(\"DSDT table not found for OEM information\\n\");\n\telse {\n\t\tcrat_table->oem_revision = acpi_table->revision;\n\t\tmemcpy(crat_table->oem_id, acpi_table->oem_id,\n\t\t\t\tCRAT_OEMID_LENGTH);\n\t\tmemcpy(crat_table->oem_table_id, acpi_table->oem_table_id,\n\t\t\t\tCRAT_OEMTABLEID_LENGTH);\n\t\tacpi_put_table(acpi_table);\n\t}\n\tcrat_table->total_entries = 0;\n\tcrat_table->num_domains = 0;\n\n\tsub_type_hdr = (struct crat_subtype_generic *)(crat_table+1);\n\n\tfor_each_online_node(numa_node_id) {\n\t\tif (kfd_numa_node_to_apic_id(numa_node_id) == -1)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = kfd_fill_cu_for_cpu(numa_node_id, &avail_size,\n\t\t\tcrat_table->num_domains,\n\t\t\t(struct crat_subtype_computeunit *)sub_type_hdr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcrat_table->length += sub_type_hdr->length;\n\t\tcrat_table->total_entries++;\n\n\t\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\t\tsub_type_hdr->length);\n\n\t\t \n\t\tret = kfd_fill_mem_info_for_cpu(numa_node_id, &avail_size,\n\t\t\tcrat_table->num_domains,\n\t\t\t(struct crat_subtype_memory *)sub_type_hdr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcrat_table->length += sub_type_hdr->length;\n\t\tcrat_table->total_entries++;\n\n\t\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\t\tsub_type_hdr->length);\n\n\t\t \n#ifdef CONFIG_X86_64\n\t\tret = kfd_fill_iolink_info_for_cpu(numa_node_id, &avail_size,\n\t\t\t\t&entries,\n\t\t\t\t(struct crat_subtype_iolink *)sub_type_hdr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (entries) {\n\t\t\tcrat_table->length += (sub_type_hdr->length * entries);\n\t\t\tcrat_table->total_entries += entries;\n\n\t\t\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\t\t\t\tsub_type_hdr->length * entries);\n\t\t}\n#else\n\t\tpr_info(\"IO link not available for non x86 platforms\\n\");\n#endif\n\n\t\tcrat_table->num_domains++;\n\t}\n\n\t \n\n\t*size = crat_table->length;\n\tpr_info(\"Virtual CRAT table created for CPU\\n\");\n\n\treturn 0;\n}\n\nstatic int kfd_fill_gpu_memory_affinity(int *avail_size,\n\t\tstruct kfd_node *kdev, uint8_t type, uint64_t size,\n\t\tstruct crat_subtype_memory *sub_type_hdr,\n\t\tuint32_t proximity_domain,\n\t\tconst struct kfd_local_mem_info *local_mem_info)\n{\n\t*avail_size -= sizeof(struct crat_subtype_memory);\n\tif (*avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset((void *)sub_type_hdr, 0, sizeof(struct crat_subtype_memory));\n\tsub_type_hdr->type = CRAT_SUBTYPE_MEMORY_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_memory);\n\tsub_type_hdr->flags |= CRAT_SUBTYPE_FLAGS_ENABLED;\n\n\tsub_type_hdr->proximity_domain = proximity_domain;\n\n\tpr_debug(\"Fill gpu memory affinity - type 0x%x size 0x%llx\\n\",\n\t\t\ttype, size);\n\n\tsub_type_hdr->length_low = lower_32_bits(size);\n\tsub_type_hdr->length_high = upper_32_bits(size);\n\n\tsub_type_hdr->width = local_mem_info->vram_width;\n\tsub_type_hdr->visibility_type = type;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI_NUMA\nstatic void kfd_find_numa_node_in_srat(struct kfd_node *kdev)\n{\n\tstruct acpi_table_header *table_header = NULL;\n\tstruct acpi_subtable_header *sub_header = NULL;\n\tunsigned long table_end, subtable_len;\n\tu32 pci_id = pci_domain_nr(kdev->adev->pdev->bus) << 16 |\n\t\t\tpci_dev_id(kdev->adev->pdev);\n\tu32 bdf;\n\tacpi_status status;\n\tstruct acpi_srat_cpu_affinity *cpu;\n\tstruct acpi_srat_generic_affinity *gpu;\n\tint pxm = 0, max_pxm = 0;\n\tint numa_node = NUMA_NO_NODE;\n\tbool found = false;\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_SRAT, 0, &table_header);\n\tif (status == AE_NOT_FOUND) {\n\t\tpr_warn(\"SRAT table not found\\n\");\n\t\treturn;\n\t} else if (ACPI_FAILURE(status)) {\n\t\tconst char *err = acpi_format_exception(status);\n\t\tpr_err(\"SRAT table error: %s\\n\", err);\n\t\treturn;\n\t}\n\n\ttable_end = (unsigned long)table_header + table_header->length;\n\n\t \n\tsub_header = (struct acpi_subtable_header *)\n\t\t\t((unsigned long)table_header +\n\t\t\tsizeof(struct acpi_table_srat));\n\tsubtable_len = sub_header->length;\n\n\twhile (((unsigned long)sub_header) + subtable_len  < table_end) {\n\t\t \n\t\tif (subtable_len == 0) {\n\t\t\tpr_err(\"SRAT invalid zero length\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (sub_header->type) {\n\t\tcase ACPI_SRAT_TYPE_CPU_AFFINITY:\n\t\t\tcpu = (struct acpi_srat_cpu_affinity *)sub_header;\n\t\t\tpxm = *((u32 *)cpu->proximity_domain_hi) << 8 |\n\t\t\t\t\tcpu->proximity_domain_lo;\n\t\t\tif (pxm > max_pxm)\n\t\t\t\tmax_pxm = pxm;\n\t\t\tbreak;\n\t\tcase ACPI_SRAT_TYPE_GENERIC_AFFINITY:\n\t\t\tgpu = (struct acpi_srat_generic_affinity *)sub_header;\n\t\t\tbdf = *((u16 *)(&gpu->device_handle[0])) << 16 |\n\t\t\t\t\t*((u16 *)(&gpu->device_handle[2]));\n\t\t\tif (bdf == pci_id) {\n\t\t\t\tfound = true;\n\t\t\t\tnuma_node = pxm_to_node(gpu->proximity_domain);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\n\t\tsub_header = (struct acpi_subtable_header *)\n\t\t\t\t((unsigned long)sub_header + subtable_len);\n\t\tsubtable_len = sub_header->length;\n\t}\n\n\tacpi_put_table(table_header);\n\n\t \n\tif (found && (numa_node < 0 ||\n\t\t\tnuma_node > pxm_to_node(max_pxm)))\n\t\tnuma_node = 0;\n\n\tif (numa_node != NUMA_NO_NODE)\n\t\tset_dev_node(&kdev->adev->pdev->dev, numa_node);\n}\n#endif\n\n#define KFD_CRAT_INTRA_SOCKET_WEIGHT\t13\n#define KFD_CRAT_XGMI_WEIGHT\t\t15\n\n \nstatic int kfd_fill_gpu_direct_io_link_to_cpu(int *avail_size,\n\t\t\tstruct kfd_node *kdev,\n\t\t\tstruct crat_subtype_iolink *sub_type_hdr,\n\t\t\tuint32_t proximity_domain)\n{\n\t*avail_size -= sizeof(struct crat_subtype_iolink);\n\tif (*avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset((void *)sub_type_hdr, 0, sizeof(struct crat_subtype_iolink));\n\n\t \n\tsub_type_hdr->type = CRAT_SUBTYPE_IOLINK_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_iolink);\n\tsub_type_hdr->flags |= CRAT_SUBTYPE_FLAGS_ENABLED;\n\tif (kfd_dev_is_large_bar(kdev))\n\t\tsub_type_hdr->flags |= CRAT_IOLINK_FLAGS_BI_DIRECTIONAL;\n\n\t \n\tif (kdev->adev->gmc.xgmi.connected_to_cpu ||\n\t    (KFD_GC_VERSION(kdev) == IP_VERSION(9, 4, 3) &&\n\t     kdev->adev->smuio.funcs->get_pkg_type(kdev->adev) ==\n\t     AMDGPU_PKG_TYPE_APU)) {\n\t\tbool ext_cpu = KFD_GC_VERSION(kdev) != IP_VERSION(9, 4, 3);\n\t\tint mem_bw = 819200, weight = ext_cpu ? KFD_CRAT_XGMI_WEIGHT :\n\t\t\t\t\t\t\tKFD_CRAT_INTRA_SOCKET_WEIGHT;\n\t\tuint32_t bandwidth = ext_cpu ? amdgpu_amdkfd_get_xgmi_bandwidth_mbytes(\n\t\t\t\t\t\t\tkdev->adev, NULL, true) : mem_bw;\n\n\t\t \n\t\tsub_type_hdr->flags |= CRAT_IOLINK_FLAGS_BI_DIRECTIONAL;\n\t\tsub_type_hdr->io_interface_type = CRAT_IOLINK_TYPE_XGMI;\n\t\tsub_type_hdr->weight_xgmi = weight;\n\t\tsub_type_hdr->minimum_bandwidth_mbs = bandwidth;\n\t\tsub_type_hdr->maximum_bandwidth_mbs = bandwidth;\n\t} else {\n\t\tsub_type_hdr->io_interface_type = CRAT_IOLINK_TYPE_PCIEXPRESS;\n\t\tsub_type_hdr->minimum_bandwidth_mbs =\n\t\t\t\tamdgpu_amdkfd_get_pcie_bandwidth_mbytes(kdev->adev, true);\n\t\tsub_type_hdr->maximum_bandwidth_mbs =\n\t\t\t\tamdgpu_amdkfd_get_pcie_bandwidth_mbytes(kdev->adev, false);\n\t}\n\n\tsub_type_hdr->proximity_domain_from = proximity_domain;\n\n#ifdef CONFIG_ACPI_NUMA\n\tif (kdev->adev->pdev->dev.numa_node == NUMA_NO_NODE &&\n\t    num_possible_nodes() > 1)\n\t\tkfd_find_numa_node_in_srat(kdev);\n#endif\n#ifdef CONFIG_NUMA\n\tif (kdev->adev->pdev->dev.numa_node == NUMA_NO_NODE)\n\t\tsub_type_hdr->proximity_domain_to = 0;\n\telse\n\t\tsub_type_hdr->proximity_domain_to = kdev->adev->pdev->dev.numa_node;\n#else\n\tsub_type_hdr->proximity_domain_to = 0;\n#endif\n\treturn 0;\n}\n\nstatic int kfd_fill_gpu_xgmi_link_to_gpu(int *avail_size,\n\t\t\tstruct kfd_node *kdev,\n\t\t\tstruct kfd_node *peer_kdev,\n\t\t\tstruct crat_subtype_iolink *sub_type_hdr,\n\t\t\tuint32_t proximity_domain_from,\n\t\t\tuint32_t proximity_domain_to)\n{\n\tbool use_ta_info = kdev->kfd->num_nodes == 1;\n\n\t*avail_size -= sizeof(struct crat_subtype_iolink);\n\tif (*avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset((void *)sub_type_hdr, 0, sizeof(struct crat_subtype_iolink));\n\n\tsub_type_hdr->type = CRAT_SUBTYPE_IOLINK_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_iolink);\n\tsub_type_hdr->flags |= CRAT_SUBTYPE_FLAGS_ENABLED |\n\t\t\t       CRAT_IOLINK_FLAGS_BI_DIRECTIONAL;\n\n\tsub_type_hdr->io_interface_type = CRAT_IOLINK_TYPE_XGMI;\n\tsub_type_hdr->proximity_domain_from = proximity_domain_from;\n\tsub_type_hdr->proximity_domain_to = proximity_domain_to;\n\n\tif (use_ta_info) {\n\t\tsub_type_hdr->weight_xgmi = KFD_CRAT_XGMI_WEIGHT *\n\t\t\tamdgpu_amdkfd_get_xgmi_hops_count(kdev->adev, peer_kdev->adev);\n\t\tsub_type_hdr->maximum_bandwidth_mbs =\n\t\t\tamdgpu_amdkfd_get_xgmi_bandwidth_mbytes(kdev->adev,\n\t\t\t\t\t\t\tpeer_kdev->adev, false);\n\t\tsub_type_hdr->minimum_bandwidth_mbs = sub_type_hdr->maximum_bandwidth_mbs ?\n\t\t\tamdgpu_amdkfd_get_xgmi_bandwidth_mbytes(kdev->adev, NULL, true) : 0;\n\t} else {\n\t\tbool is_single_hop = kdev->kfd == peer_kdev->kfd;\n\t\tint weight = is_single_hop ? KFD_CRAT_INTRA_SOCKET_WEIGHT :\n\t\t\t(2 * KFD_CRAT_INTRA_SOCKET_WEIGHT) + KFD_CRAT_XGMI_WEIGHT;\n\t\tint mem_bw = 819200;\n\n\t\tsub_type_hdr->weight_xgmi = weight;\n\t\tsub_type_hdr->maximum_bandwidth_mbs = is_single_hop ? mem_bw : 0;\n\t\tsub_type_hdr->minimum_bandwidth_mbs = is_single_hop ? mem_bw : 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kfd_create_vcrat_image_gpu(void *pcrat_image,\n\t\t\t\t      size_t *size, struct kfd_node *kdev,\n\t\t\t\t      uint32_t proximity_domain)\n{\n\tstruct crat_header *crat_table = (struct crat_header *)pcrat_image;\n\tstruct crat_subtype_generic *sub_type_hdr;\n\tstruct kfd_local_mem_info local_mem_info;\n\tstruct kfd_topology_device *peer_dev;\n\tstruct crat_subtype_computeunit *cu;\n\tstruct kfd_cu_info cu_info;\n\tint avail_size = *size;\n\tuint32_t total_num_of_cu;\n\tuint32_t nid = 0;\n\tint ret = 0;\n\n\tif (!pcrat_image || avail_size < VCRAT_SIZE_FOR_GPU)\n\t\treturn -EINVAL;\n\n\t \n\tavail_size -= sizeof(struct crat_header);\n\tif (avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tmemset(crat_table, 0, sizeof(struct crat_header));\n\n\tmemcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature));\n\t \n\tcrat_table->length = sizeof(struct crat_header);\n\tcrat_table->num_domains = 1;\n\tcrat_table->total_entries = 0;\n\n\t \n\tavail_size -= sizeof(struct crat_subtype_computeunit);\n\tif (avail_size < 0)\n\t\treturn -ENOMEM;\n\n\tsub_type_hdr = (struct crat_subtype_generic *)(crat_table + 1);\n\tmemset(sub_type_hdr, 0, sizeof(struct crat_subtype_computeunit));\n\n\tsub_type_hdr->type = CRAT_SUBTYPE_COMPUTEUNIT_AFFINITY;\n\tsub_type_hdr->length = sizeof(struct crat_subtype_computeunit);\n\tsub_type_hdr->flags = CRAT_SUBTYPE_FLAGS_ENABLED;\n\n\t \n\tcu = (struct crat_subtype_computeunit *)sub_type_hdr;\n\tcu->flags |= CRAT_CU_FLAGS_GPU_PRESENT;\n\tcu->proximity_domain = proximity_domain;\n\n\tamdgpu_amdkfd_get_cu_info(kdev->adev, &cu_info);\n\tcu->num_simd_per_cu = cu_info.simd_per_cu;\n\tcu->num_simd_cores = cu_info.simd_per_cu *\n\t\t\t(cu_info.cu_active_number / kdev->kfd->num_nodes);\n\tcu->max_waves_simd = cu_info.max_waves_per_simd;\n\n\tcu->wave_front_size = cu_info.wave_front_size;\n\tcu->array_count = cu_info.num_shader_arrays_per_engine *\n\t\tcu_info.num_shader_engines;\n\ttotal_num_of_cu = (cu->array_count * cu_info.num_cu_per_sh);\n\tcu->processor_id_low = get_and_inc_gpu_processor_id(total_num_of_cu);\n\tcu->num_cu_per_array = cu_info.num_cu_per_sh;\n\tcu->max_slots_scatch_cu = cu_info.max_scratch_slots_per_cu;\n\tcu->num_banks = cu_info.num_shader_engines;\n\tcu->lds_size_in_kb = cu_info.lds_size;\n\n\tcu->hsa_capability = 0;\n\n\tcrat_table->length += sub_type_hdr->length;\n\tcrat_table->total_entries++;\n\n\t \n\tlocal_mem_info = kdev->local_mem_info;\n\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\t\tsub_type_hdr->length);\n\n\tif (debug_largebar)\n\t\tlocal_mem_info.local_mem_size_private = 0;\n\n\tif (local_mem_info.local_mem_size_private == 0)\n\t\tret = kfd_fill_gpu_memory_affinity(&avail_size,\n\t\t\t\tkdev, HSA_MEM_HEAP_TYPE_FB_PUBLIC,\n\t\t\t\tlocal_mem_info.local_mem_size_public,\n\t\t\t\t(struct crat_subtype_memory *)sub_type_hdr,\n\t\t\t\tproximity_domain,\n\t\t\t\t&local_mem_info);\n\telse\n\t\tret = kfd_fill_gpu_memory_affinity(&avail_size,\n\t\t\t\tkdev, HSA_MEM_HEAP_TYPE_FB_PRIVATE,\n\t\t\t\tlocal_mem_info.local_mem_size_public +\n\t\t\t\tlocal_mem_info.local_mem_size_private,\n\t\t\t\t(struct crat_subtype_memory *)sub_type_hdr,\n\t\t\t\tproximity_domain,\n\t\t\t\t&local_mem_info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcrat_table->length += sizeof(struct crat_subtype_memory);\n\tcrat_table->total_entries++;\n\n\t \n\tsub_type_hdr = (typeof(sub_type_hdr))((char *)sub_type_hdr +\n\t\tsub_type_hdr->length);\n\tret = kfd_fill_gpu_direct_io_link_to_cpu(&avail_size, kdev,\n\t\t(struct crat_subtype_iolink *)sub_type_hdr, proximity_domain);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcrat_table->length += sub_type_hdr->length;\n\tcrat_table->total_entries++;\n\n\n\t \n\tif (kdev->kfd->hive_id) {\n\t\tfor (nid = 0; nid < proximity_domain; ++nid) {\n\t\t\tpeer_dev = kfd_topology_device_by_proximity_domain_no_lock(nid);\n\t\t\tif (!peer_dev->gpu)\n\t\t\t\tcontinue;\n\t\t\tif (peer_dev->gpu->kfd->hive_id != kdev->kfd->hive_id)\n\t\t\t\tcontinue;\n\t\t\tsub_type_hdr = (typeof(sub_type_hdr))(\n\t\t\t\t(char *)sub_type_hdr +\n\t\t\t\tsizeof(struct crat_subtype_iolink));\n\t\t\tret = kfd_fill_gpu_xgmi_link_to_gpu(\n\t\t\t\t&avail_size, kdev, peer_dev->gpu,\n\t\t\t\t(struct crat_subtype_iolink *)sub_type_hdr,\n\t\t\t\tproximity_domain, nid);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tcrat_table->length += sub_type_hdr->length;\n\t\t\tcrat_table->total_entries++;\n\t\t}\n\t}\n\t*size = crat_table->length;\n\tpr_info(\"Virtual CRAT table created for GPU\\n\");\n\n\treturn ret;\n}\n\n \nint kfd_create_crat_image_virtual(void **crat_image, size_t *size,\n\t\t\t\t  int flags, struct kfd_node *kdev,\n\t\t\t\t  uint32_t proximity_domain)\n{\n\tvoid *pcrat_image = NULL;\n\tint ret = 0, num_nodes;\n\tsize_t dyn_size;\n\n\tif (!crat_image)\n\t\treturn -EINVAL;\n\n\t*crat_image = NULL;\n\n\t \n\tswitch (flags) {\n\tcase COMPUTE_UNIT_CPU:\n\t\tnum_nodes = num_online_nodes();\n\t\tdyn_size = sizeof(struct crat_header) +\n\t\t\tnum_nodes * (sizeof(struct crat_subtype_computeunit) +\n\t\t\tsizeof(struct crat_subtype_memory) +\n\t\t\t(num_nodes - 1) * sizeof(struct crat_subtype_iolink));\n\t\tpcrat_image = kvmalloc(dyn_size, GFP_KERNEL);\n\t\tif (!pcrat_image)\n\t\t\treturn -ENOMEM;\n\t\t*size = dyn_size;\n\t\tpr_debug(\"CRAT size is %ld\", dyn_size);\n\t\tret = kfd_create_vcrat_image_cpu(pcrat_image, size);\n\t\tbreak;\n\tcase COMPUTE_UNIT_GPU:\n\t\tif (!kdev)\n\t\t\treturn -EINVAL;\n\t\tpcrat_image = kvmalloc(VCRAT_SIZE_FOR_GPU, GFP_KERNEL);\n\t\tif (!pcrat_image)\n\t\t\treturn -ENOMEM;\n\t\t*size = VCRAT_SIZE_FOR_GPU;\n\t\tret = kfd_create_vcrat_image_gpu(pcrat_image, size, kdev,\n\t\t\t\t\t\t proximity_domain);\n\t\tbreak;\n\tcase (COMPUTE_UNIT_CPU | COMPUTE_UNIT_GPU):\n\t\t \n\t\tret = -EINVAL;\n\t\tpr_err(\"VCRAT not implemented for APU\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\t*crat_image = pcrat_image;\n\telse\n\t\tkvfree(pcrat_image);\n\n\treturn ret;\n}\n\n\n \nvoid kfd_destroy_crat_image(void *crat_image)\n{\n\tkvfree(crat_image);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}