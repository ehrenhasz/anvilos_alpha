{
  "module_name": "kfd_device_queue_manager_cik.c",
  "hash_id": "541329a70d8a4f9c3aa025eb558fe9f99a345af9008b32996d7712de3e4e2b45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager_cik.c",
  "human_readable_source": "\n \n\n#include \"kfd_device_queue_manager.h\"\n#include \"cik_regs.h\"\n#include \"oss/oss_2_4_sh_mask.h\"\n#include \"gca/gfx_7_2_sh_mask.h\"\n\nstatic bool set_cache_memory_policy_cik(struct device_queue_manager *dqm,\n\t\t\t\t   struct qcm_process_device *qpd,\n\t\t\t\t   enum cache_policy default_policy,\n\t\t\t\t   enum cache_policy alternate_policy,\n\t\t\t\t   void __user *alternate_aperture_base,\n\t\t\t\t   uint64_t alternate_aperture_size);\nstatic int update_qpd_cik(struct device_queue_manager *dqm,\n\t\t\t  struct qcm_process_device *qpd);\nstatic void init_sdma_vm(struct device_queue_manager *dqm,\n\t\t\t struct queue *q,\n\t\t\t struct qcm_process_device *qpd);\n\nvoid device_queue_manager_init_cik(\n\tstruct device_queue_manager_asic_ops *asic_ops)\n{\n\tasic_ops->set_cache_memory_policy = set_cache_memory_policy_cik;\n\tasic_ops->update_qpd = update_qpd_cik;\n\tasic_ops->init_sdma_vm = init_sdma_vm;\n\tasic_ops->mqd_manager_init = mqd_manager_init_cik;\n}\n\nstatic uint32_t compute_sh_mem_bases_64bit(unsigned int top_address_nybble)\n{\n\t \n\n\tWARN_ON((top_address_nybble & 1) || top_address_nybble > 0xE ||\n\t\ttop_address_nybble == 0);\n\n\treturn PRIVATE_BASE(top_address_nybble << 12) |\n\t\t\tSHARED_BASE(top_address_nybble << 12);\n}\n\nstatic bool set_cache_memory_policy_cik(struct device_queue_manager *dqm,\n\t\t\t\t   struct qcm_process_device *qpd,\n\t\t\t\t   enum cache_policy default_policy,\n\t\t\t\t   enum cache_policy alternate_policy,\n\t\t\t\t   void __user *alternate_aperture_base,\n\t\t\t\t   uint64_t alternate_aperture_size)\n{\n\tuint32_t default_mtype;\n\tuint32_t ape1_mtype;\n\n\tdefault_mtype = (default_policy == cache_policy_coherent) ?\n\t\t\tMTYPE_NONCACHED :\n\t\t\tMTYPE_CACHED;\n\n\tape1_mtype = (alternate_policy == cache_policy_coherent) ?\n\t\t\tMTYPE_NONCACHED :\n\t\t\tMTYPE_CACHED;\n\n\tqpd->sh_mem_config = (qpd->sh_mem_config & PTR32)\n\t\t\t| ALIGNMENT_MODE(SH_MEM_ALIGNMENT_MODE_UNALIGNED)\n\t\t\t| DEFAULT_MTYPE(default_mtype)\n\t\t\t| APE1_MTYPE(ape1_mtype);\n\n\treturn true;\n}\n\nstatic int update_qpd_cik(struct device_queue_manager *dqm,\n\t\t\t  struct qcm_process_device *qpd)\n{\n\tstruct kfd_process_device *pdd;\n\tunsigned int temp;\n\n\tpdd = qpd_to_pdd(qpd);\n\n\t \n\tif (qpd->sh_mem_config == 0) {\n\t\tqpd->sh_mem_config =\n\t\t\tALIGNMENT_MODE(SH_MEM_ALIGNMENT_MODE_UNALIGNED) |\n\t\t\tDEFAULT_MTYPE(MTYPE_NONCACHED) |\n\t\t\tAPE1_MTYPE(MTYPE_NONCACHED);\n\t\tqpd->sh_mem_ape1_limit = 0;\n\t\tqpd->sh_mem_ape1_base = 0;\n\t}\n\n\t \n\ttemp = get_sh_mem_bases_nybble_64(pdd);\n\tqpd->sh_mem_bases = compute_sh_mem_bases_64bit(temp);\n\n\tpr_debug(\"is32bit process: %d sh_mem_bases nybble: 0x%X and register 0x%X\\n\",\n\t\tqpd->pqm->process->is_32bit_user_mode, temp, qpd->sh_mem_bases);\n\n\treturn 0;\n}\n\nstatic void init_sdma_vm(struct device_queue_manager *dqm,\n\t\t\t struct queue *q,\n\t\t\t struct qcm_process_device *qpd)\n{\n\t \n\tq->properties.sdma_vm_addr =\n\t\t((get_sh_mem_bases_nybble_64(qpd_to_pdd(qpd))) <<\n\t\t SDMA0_RLC0_VIRTUAL_ADDR__SHARED_BASE__SHIFT) &\n\t\tSDMA0_RLC0_VIRTUAL_ADDR__SHARED_BASE_MASK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}