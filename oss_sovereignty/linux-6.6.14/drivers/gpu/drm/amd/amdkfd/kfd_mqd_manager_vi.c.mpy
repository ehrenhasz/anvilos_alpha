{
  "module_name": "kfd_mqd_manager_vi.c",
  "hash_id": "b6d7cac6da760351a06ddc5bb768b020383c36325723266a6db6b759ea23c433",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c",
  "human_readable_source": "\n \n\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/mm_types.h>\n\n#include \"kfd_priv.h\"\n#include \"kfd_mqd_manager.h\"\n#include \"vi_structs.h\"\n#include \"gca/gfx_8_0_sh_mask.h\"\n#include \"gca/gfx_8_0_enum.h\"\n#include \"oss/oss_3_0_sh_mask.h\"\n\n#define CP_MQD_CONTROL__PRIV_STATE__SHIFT 0x8\n\nstatic inline struct vi_mqd *get_mqd(void *mqd)\n{\n\treturn (struct vi_mqd *)mqd;\n}\n\nstatic inline struct vi_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct vi_sdma_mqd *)mqd;\n}\n\nstatic void update_cu_mask(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct vi_mqd *m;\n\tuint32_t se_mask[4] = {0};  \n\n\tif (!minfo || !minfo->cu_mask.ptr)\n\t\treturn;\n\n\tmqd_symmetrically_map_cu_mask(mm,\n\t\tminfo->cu_mask.ptr, minfo->cu_mask.count, se_mask, 0);\n\n\tm = get_mqd(mqd);\n\tm->compute_static_thread_mgmt_se0 = se_mask[0];\n\tm->compute_static_thread_mgmt_se1 = se_mask[1];\n\tm->compute_static_thread_mgmt_se2 = se_mask[2];\n\tm->compute_static_thread_mgmt_se3 = se_mask[3];\n\n\tpr_debug(\"Update cu mask to %#x %#x %#x %#x\\n\",\n\t\tm->compute_static_thread_mgmt_se0,\n\t\tm->compute_static_thread_mgmt_se1,\n\t\tm->compute_static_thread_mgmt_se2,\n\t\tm->compute_static_thread_mgmt_se3);\n}\n\nstatic void set_priority(struct vi_mqd *m, struct queue_properties *q)\n{\n\tm->cp_hqd_pipe_priority = pipe_priority_map[q->priority];\n\tm->cp_hqd_queue_priority = q->priority;\n}\n\nstatic struct kfd_mem_obj *allocate_mqd(struct kfd_node *kfd,\n\t\t\t\t\tstruct queue_properties *q)\n{\n\tstruct kfd_mem_obj *mqd_mem_obj;\n\n\tif (kfd_gtt_sa_allocate(kfd, sizeof(struct vi_mqd),\n\t\t\t&mqd_mem_obj))\n\t\treturn NULL;\n\n\treturn mqd_mem_obj;\n}\n\nstatic void init_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tuint64_t addr;\n\tstruct vi_mqd *m;\n\n\tm = (struct vi_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemset(m, 0, sizeof(struct vi_mqd));\n\n\tm->header = 0xC0310800;\n\tm->compute_pipelinestat_enable = 1;\n\tm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\n\n\tm->cp_hqd_persistent_state = CP_HQD_PERSISTENT_STATE__PRELOAD_REQ_MASK |\n\t\t\t0x53 << CP_HQD_PERSISTENT_STATE__PRELOAD_SIZE__SHIFT;\n\n\tm->cp_mqd_control = 1 << CP_MQD_CONTROL__PRIV_STATE__SHIFT |\n\t\t\tMTYPE_UC << CP_MQD_CONTROL__MTYPE__SHIFT;\n\n\tm->cp_mqd_base_addr_lo        = lower_32_bits(addr);\n\tm->cp_mqd_base_addr_hi        = upper_32_bits(addr);\n\n\tm->cp_hqd_quantum = 1 << CP_HQD_QUANTUM__QUANTUM_EN__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_SCALE__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_DURATION__SHIFT;\n\n\tset_priority(m, q);\n\tm->cp_hqd_eop_rptr = 1 << CP_HQD_EOP_RPTR__INIT_FETCHER__SHIFT;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL)\n\t\tm->cp_hqd_iq_rptr = 1;\n\n\tif (q->tba_addr) {\n\t\tm->compute_tba_lo = lower_32_bits(q->tba_addr >> 8);\n\t\tm->compute_tba_hi = upper_32_bits(q->tba_addr >> 8);\n\t\tm->compute_tma_lo = lower_32_bits(q->tma_addr >> 8);\n\t\tm->compute_tma_hi = upper_32_bits(q->tma_addr >> 8);\n\t\tm->compute_pgm_rsrc2 |=\n\t\t\t(1 << COMPUTE_PGM_RSRC2__TRAP_PRESENT__SHIFT);\n\t}\n\n\tif (mm->dev->kfd->cwsr_enabled && q->ctx_save_restore_area_address) {\n\t\tm->cp_hqd_persistent_state |=\n\t\t\t(1 << CP_HQD_PERSISTENT_STATE__QSWITCH_MODE__SHIFT);\n\t\tm->cp_hqd_ctx_save_base_addr_lo =\n\t\t\tlower_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_base_addr_hi =\n\t\t\tupper_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_size = q->ctx_save_restore_area_size;\n\t\tm->cp_hqd_cntl_stack_size = q->ctl_stack_size;\n\t\tm->cp_hqd_cntl_stack_offset = q->ctl_stack_size;\n\t\tm->cp_hqd_wg_state_offset = q->ctl_stack_size;\n\t}\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\nstatic int load_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tstruct queue_properties *p, struct mm_struct *mms)\n{\n\t \n\tuint32_t wptr_shift = (p->format == KFD_QUEUE_FORMAT_AQL ? 4 : 0);\n\tuint32_t wptr_mask = (uint32_t)((p->queue_size / 4) - 1);\n\n\treturn mm->dev->kfd2kgd->hqd_load(mm->dev->adev, mqd, pipe_id, queue_id,\n\t\t\t\t\t  (uint32_t __user *)p->write_ptr,\n\t\t\t\t\t  wptr_shift, wptr_mask, mms, 0);\n}\n\nstatic void __update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q, struct mqd_update_info *minfo,\n\t\t\tunsigned int mtype, unsigned int atc_bit)\n{\n\tstruct vi_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tm->cp_hqd_pq_control = 5 << CP_HQD_PQ_CONTROL__RPTR_BLOCK_SIZE__SHIFT |\n\t\t\tatc_bit << CP_HQD_PQ_CONTROL__PQ_ATC__SHIFT |\n\t\t\tmtype << CP_HQD_PQ_CONTROL__MTYPE__SHIFT;\n\tm->cp_hqd_pq_control |=\torder_base_2(q->queue_size / 4) - 1;\n\tpr_debug(\"cp_hqd_pq_control 0x%x\\n\", m->cp_hqd_pq_control);\n\n\tm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\n\n\tm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_lo = lower_32_bits((uint64_t)q->write_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits((uint64_t)q->write_ptr);\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tq->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tm->cp_hqd_eop_control = atc_bit << CP_HQD_EOP_CONTROL__EOP_ATC__SHIFT |\n\t\t\tmtype << CP_HQD_EOP_CONTROL__MTYPE__SHIFT;\n\n\tm->cp_hqd_ib_control = atc_bit << CP_HQD_IB_CONTROL__IB_ATC__SHIFT |\n\t\t\t3 << CP_HQD_IB_CONTROL__MIN_IB_AVAIL_SIZE__SHIFT |\n\t\t\tmtype << CP_HQD_IB_CONTROL__MTYPE__SHIFT;\n\n\t \n\tm->cp_hqd_eop_control |= min(0xA,\n\t\torder_base_2(q->eop_ring_buffer_size / 4) - 1);\n\tm->cp_hqd_eop_base_addr_lo =\n\t\t\tlower_32_bits(q->eop_ring_buffer_address >> 8);\n\tm->cp_hqd_eop_base_addr_hi =\n\t\t\tupper_32_bits(q->eop_ring_buffer_address >> 8);\n\n\tm->cp_hqd_iq_timer = atc_bit << CP_HQD_IQ_TIMER__IQ_ATC__SHIFT |\n\t\t\tmtype << CP_HQD_IQ_TIMER__MTYPE__SHIFT;\n\n\tm->cp_hqd_vmid = q->vmid;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\tm->cp_hqd_pq_control |= CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK |\n\t\t\t\t2 << CP_HQD_PQ_CONTROL__SLOT_BASED_WPTR__SHIFT;\n\t}\n\n\tif (mm->dev->kfd->cwsr_enabled && q->ctx_save_restore_area_address)\n\t\tm->cp_hqd_ctx_save_control =\n\t\t\tatc_bit << CP_HQD_CTX_SAVE_CONTROL__ATC__SHIFT |\n\t\t\tmtype << CP_HQD_CTX_SAVE_CONTROL__MTYPE__SHIFT;\n\n\tupdate_cu_mask(mm, mqd, minfo);\n\tset_priority(m, q);\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic uint32_t read_doorbell_id(void *mqd)\n{\n\tstruct vi_mqd *m = (struct vi_mqd *)mqd;\n\n\treturn m->queue_doorbell_id0;\n}\n\nstatic void update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t       struct queue_properties *q,\n\t\t       struct mqd_update_info *minfo)\n{\n\t__update_mqd(mm, mqd, q, minfo, MTYPE_UC, 0);\n}\n\nstatic int get_wave_state(struct mqd_manager *mm, void *mqd,\n\t\t\t  struct queue_properties *q,\n\t\t\t  void __user *ctl_stack,\n\t\t\t  u32 *ctl_stack_used_size,\n\t\t\t  u32 *save_area_used_size)\n{\n\tstruct vi_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\t*ctl_stack_used_size = m->cp_hqd_cntl_stack_size -\n\t\tm->cp_hqd_cntl_stack_offset;\n\t*save_area_used_size = m->cp_hqd_wg_state_offset -\n\t\tm->cp_hqd_cntl_stack_size;\n\n\t \n\n\treturn 0;\n}\n\nstatic void get_checkpoint_info(struct mqd_manager *mm, void *mqd, u32 *ctl_stack_size)\n{\n\t \n\t*ctl_stack_size = 0;\n}\n\nstatic void checkpoint_mqd(struct mqd_manager *mm, void *mqd, void *mqd_dst, void *ctl_stack_dst)\n{\n\tstruct vi_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct vi_mqd));\n}\n\nstatic void restore_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *qp,\n\t\t\tconst void *mqd_src,\n\t\t\tconst void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct vi_mqd *m;\n\n\tm = (struct vi_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tqp->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tqp->is_active = 0;\n}\n\nstatic void init_mqd_hiq(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct vi_mqd *m;\n\n\tinit_mqd(mm, mqd, mqd_mem_obj, gart_addr, q);\n\n\tm = get_mqd(*mqd);\n\n\tm->cp_hqd_pq_control |= 1 << CP_HQD_PQ_CONTROL__PRIV_STATE__SHIFT |\n\t\t\t1 << CP_HQD_PQ_CONTROL__KMD_QUEUE__SHIFT;\n}\n\nstatic void update_mqd_hiq(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\t__update_mqd(mm, mqd, q, minfo, MTYPE_UC, 0);\n}\n\nstatic void init_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\tstruct queue_properties *q)\n{\n\tstruct vi_sdma_mqd *m;\n\n\tm = (struct vi_sdma_mqd *) mqd_mem_obj->cpu_ptr;\n\n\tmemset(m, 0, sizeof(struct vi_sdma_mqd));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = mqd_mem_obj->gpu_addr;\n\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\nstatic void update_mqd_sdma(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct vi_sdma_mqd *m;\n\n\tm = get_sdma_mqd(mqd);\n\tm->sdmax_rlcx_rb_cntl = order_base_2(q->queue_size / 4)\n\t\t<< SDMA0_RLC0_RB_CNTL__RB_SIZE__SHIFT |\n\t\tq->vmid << SDMA0_RLC0_RB_CNTL__RB_VMID__SHIFT |\n\t\t1 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_ENABLE__SHIFT |\n\t\t6 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_TIMER__SHIFT;\n\n\tm->sdmax_rlcx_rb_base = lower_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_base_hi = upper_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_rptr_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_rb_rptr_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_doorbell =\n\t\tq->doorbell_off << SDMA0_RLC0_DOORBELL__OFFSET__SHIFT;\n\n\tm->sdmax_rlcx_virtual_addr = q->sdma_vm_addr;\n\n\tm->sdma_engine_id = q->sdma_engine_id;\n\tm->sdma_queue_id = q->sdma_queue_id;\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic void checkpoint_mqd_sdma(struct mqd_manager *mm,\n\t\t\t\tvoid *mqd,\n\t\t\t\tvoid *mqd_dst,\n\t\t\t\tvoid *ctl_stack_dst)\n{\n\tstruct vi_sdma_mqd *m;\n\n\tm = get_sdma_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd));\n}\n\nstatic void restore_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\t\t     struct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\t     struct queue_properties *qp,\n\t\t\t     const void *mqd_src,\n\t\t\t     const void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct vi_sdma_mqd *m;\n\n\tm = (struct vi_sdma_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\tm->sdmax_rlcx_doorbell =\n\t\tqp->doorbell_off << SDMA0_RLC0_DOORBELL__OFFSET__SHIFT;\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tqp->is_active = 0;\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\n\nstatic int debugfs_show_mqd(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct vi_mqd), false);\n\treturn 0;\n}\n\nstatic int debugfs_show_mqd_sdma(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct vi_sdma_mqd), false);\n\treturn 0;\n}\n\n#endif\n\nstruct mqd_manager *mqd_manager_init_vi(enum KFD_MQD_TYPE type,\n\t\tstruct kfd_node *dev)\n{\n\tstruct mqd_manager *mqd;\n\n\tif (WARN_ON(type >= KFD_MQD_TYPE_MAX))\n\t\treturn NULL;\n\n\tmqd = kzalloc(sizeof(*mqd), GFP_KERNEL);\n\tif (!mqd)\n\t\treturn NULL;\n\n\tmqd->dev = dev;\n\n\tswitch (type) {\n\tcase KFD_MQD_TYPE_CP:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->get_wave_state = get_wave_state;\n\t\tmqd->get_checkpoint_info = get_checkpoint_info;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd;\n\t\tmqd->restore_mqd = restore_mqd;\n\t\tmqd->mqd_size = sizeof(struct vi_mqd);\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_HIQ:\n\t\tmqd->allocate_mqd = allocate_hiq_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd_hiq;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct vi_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tmqd->read_doorbell_id = read_doorbell_id;\n\t\tbreak;\n\tcase KFD_MQD_TYPE_DIQ:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd_hiq;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct vi_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_SDMA:\n\t\tmqd->allocate_mqd = allocate_sdma_mqd;\n\t\tmqd->init_mqd = init_mqd_sdma;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = kfd_load_mqd_sdma;\n\t\tmqd->update_mqd = update_mqd_sdma;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_sdma;\n\t\tmqd->is_occupied = kfd_is_occupied_sdma;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd_sdma;\n\t\tmqd->restore_mqd = restore_mqd_sdma;\n\t\tmqd->mqd_size = sizeof(struct vi_sdma_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd_sdma;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tkfree(mqd);\n\t\treturn NULL;\n\t}\n\n\treturn mqd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}