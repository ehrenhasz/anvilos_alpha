{
  "module_name": "kfd_mqd_manager_cik.c",
  "hash_id": "d9519f8bb3998eaaa93dd6d3aafc6c4b41e0d01c2d3a2b95db63a3061c225747",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c",
  "human_readable_source": "\n \n\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/mm_types.h>\n\n#include \"kfd_priv.h\"\n#include \"kfd_mqd_manager.h\"\n#include \"cik_regs.h\"\n#include \"cik_structs.h\"\n#include \"oss/oss_2_4_sh_mask.h\"\n\nstatic inline struct cik_mqd *get_mqd(void *mqd)\n{\n\treturn (struct cik_mqd *)mqd;\n}\n\nstatic inline struct cik_sdma_rlc_registers *get_sdma_mqd(void *mqd)\n{\n\treturn (struct cik_sdma_rlc_registers *)mqd;\n}\n\nstatic void update_cu_mask(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct cik_mqd *m;\n\tuint32_t se_mask[4] = {0};  \n\n\tif (!minfo || !minfo->cu_mask.ptr)\n\t\treturn;\n\n\tmqd_symmetrically_map_cu_mask(mm,\n\t\tminfo->cu_mask.ptr, minfo->cu_mask.count, se_mask, 0);\n\n\tm = get_mqd(mqd);\n\tm->compute_static_thread_mgmt_se0 = se_mask[0];\n\tm->compute_static_thread_mgmt_se1 = se_mask[1];\n\tm->compute_static_thread_mgmt_se2 = se_mask[2];\n\tm->compute_static_thread_mgmt_se3 = se_mask[3];\n\n\tpr_debug(\"Update cu mask to %#x %#x %#x %#x\\n\",\n\t\tm->compute_static_thread_mgmt_se0,\n\t\tm->compute_static_thread_mgmt_se1,\n\t\tm->compute_static_thread_mgmt_se2,\n\t\tm->compute_static_thread_mgmt_se3);\n}\n\nstatic void set_priority(struct cik_mqd *m, struct queue_properties *q)\n{\n\tm->cp_hqd_pipe_priority = pipe_priority_map[q->priority];\n\tm->cp_hqd_queue_priority = q->priority;\n}\n\nstatic struct kfd_mem_obj *allocate_mqd(struct kfd_node *kfd,\n\t\t\t\t\tstruct queue_properties *q)\n{\n\tstruct kfd_mem_obj *mqd_mem_obj;\n\n\tif (kfd_gtt_sa_allocate(kfd, sizeof(struct cik_mqd),\n\t\t\t&mqd_mem_obj))\n\t\treturn NULL;\n\n\treturn mqd_mem_obj;\n}\n\nstatic void init_mqd(struct mqd_manager *mm, void **mqd,\n\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\tstruct queue_properties *q)\n{\n\tuint64_t addr;\n\tstruct cik_mqd *m;\n\n\tm = (struct cik_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemset(m, 0, ALIGN(sizeof(struct cik_mqd), 256));\n\n\tm->header = 0xC0310800;\n\tm->compute_pipelinestat_enable = 1;\n\tm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\n\tm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\n\n\t \n\tm->cp_hqd_persistent_state =\n\t\t\t\tDEFAULT_CP_HQD_PERSISTENT_STATE | PRELOAD_REQ;\n\n\tm->cp_mqd_control             = MQD_CONTROL_PRIV_STATE_EN;\n\tm->cp_mqd_base_addr_lo        = lower_32_bits(addr);\n\tm->cp_mqd_base_addr_hi        = upper_32_bits(addr);\n\n\tm->cp_hqd_quantum = QUANTUM_EN | QUANTUM_SCALE_1MS |\n\t\t\t\tQUANTUM_DURATION(10);\n\n\t \n\tset_priority(m, q);\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL)\n\t\tm->cp_hqd_iq_rptr = AQL_ENABLE;\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\nstatic void init_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct cik_sdma_rlc_registers *m;\n\n\tm = (struct cik_sdma_rlc_registers *) mqd_mem_obj->cpu_ptr;\n\n\tmemset(m, 0, sizeof(struct cik_sdma_rlc_registers));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = mqd_mem_obj->gpu_addr;\n\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\nstatic int load_mqd(struct mqd_manager *mm, void *mqd, uint32_t pipe_id,\n\t\t    uint32_t queue_id, struct queue_properties *p,\n\t\t    struct mm_struct *mms)\n{\n\t \n\tuint32_t wptr_shift = (p->format == KFD_QUEUE_FORMAT_AQL ? 4 : 0);\n\tuint32_t wptr_mask = (uint32_t)((p->queue_size / 4) - 1);\n\n\treturn mm->dev->kfd2kgd->hqd_load(mm->dev->adev, mqd, pipe_id, queue_id,\n\t\t\t\t\t  (uint32_t __user *)p->write_ptr,\n\t\t\t\t\t  wptr_shift, wptr_mask, mms, 0);\n}\n\nstatic void __update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q, struct mqd_update_info *minfo,\n\t\t\tunsigned int atc_bit)\n{\n\tstruct cik_mqd *m;\n\n\tm = get_mqd(mqd);\n\tm->cp_hqd_pq_control = DEFAULT_RPTR_BLOCK_SIZE |\n\t\t\t\tDEFAULT_MIN_AVAIL_SIZE;\n\tm->cp_hqd_ib_control = DEFAULT_MIN_IB_AVAIL_SIZE;\n\tif (atc_bit) {\n\t\tm->cp_hqd_pq_control |= PQ_ATC_EN;\n\t\tm->cp_hqd_ib_control |= IB_ATC_EN;\n\t}\n\n\t \n\tm->cp_hqd_pq_control |= order_base_2(q->queue_size / 4) - 1;\n\tm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_doorbell_control = DOORBELL_OFFSET(q->doorbell_off);\n\n\tm->cp_hqd_vmid = q->vmid;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL)\n\t\tm->cp_hqd_pq_control |= NO_UPDATE_RPTR;\n\n\tupdate_cu_mask(mm, mqd, minfo);\n\tset_priority(m, q);\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic uint32_t read_doorbell_id(void *mqd)\n{\n\tstruct cik_mqd *m = (struct cik_mqd *)mqd;\n\n\treturn m->queue_doorbell_id0;\n}\n\nstatic void update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t       struct queue_properties *q,\n\t\t       struct mqd_update_info *minfo)\n{\n\t__update_mqd(mm, mqd, q, minfo, 0);\n}\n\nstatic void update_mqd_sdma(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct cik_sdma_rlc_registers *m;\n\n\tm = get_sdma_mqd(mqd);\n\tm->sdma_rlc_rb_cntl = order_base_2(q->queue_size / 4)\n\t\t\t<< SDMA0_RLC0_RB_CNTL__RB_SIZE__SHIFT |\n\t\t\tq->vmid << SDMA0_RLC0_RB_CNTL__RB_VMID__SHIFT |\n\t\t\t1 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_ENABLE__SHIFT |\n\t\t\t6 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_TIMER__SHIFT;\n\n\tm->sdma_rlc_rb_base = lower_32_bits(q->queue_address >> 8);\n\tm->sdma_rlc_rb_base_hi = upper_32_bits(q->queue_address >> 8);\n\tm->sdma_rlc_rb_rptr_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->sdma_rlc_rb_rptr_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->sdma_rlc_doorbell =\n\t\tq->doorbell_off << SDMA0_RLC0_DOORBELL__OFFSET__SHIFT;\n\n\tm->sdma_rlc_virtual_addr = q->sdma_vm_addr;\n\n\tm->sdma_engine_id = q->sdma_engine_id;\n\tm->sdma_queue_id = q->sdma_queue_id;\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic void checkpoint_mqd(struct mqd_manager *mm, void *mqd, void *mqd_dst, void *ctl_stack_dst)\n{\n\tstruct cik_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct cik_mqd));\n}\n\nstatic void restore_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *qp,\n\t\t\tconst void *mqd_src,\n\t\t\tconst void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct cik_mqd *m;\n\n\tm = (struct cik_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tm->cp_hqd_pq_doorbell_control = DOORBELL_OFFSET(qp->doorbell_off);\n\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tqp->is_active = 0;\n}\n\nstatic void checkpoint_mqd_sdma(struct mqd_manager *mm,\n\t\t\t\tvoid *mqd,\n\t\t\t\tvoid *mqd_dst,\n\t\t\t\tvoid *ctl_stack_dst)\n{\n\tstruct cik_sdma_rlc_registers *m;\n\n\tm = get_sdma_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct cik_sdma_rlc_registers));\n}\n\nstatic void restore_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\t\tstruct queue_properties *qp,\n\t\t\t\tconst void *mqd_src,\n\t\t\t\tconst void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct cik_sdma_rlc_registers *m;\n\n\tm = (struct cik_sdma_rlc_registers *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\tm->sdma_rlc_doorbell =\n\t\tqp->doorbell_off << SDMA0_RLC0_DOORBELL__OFFSET__SHIFT;\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tqp->is_active = 0;\n}\n\n \n\nstatic void init_mqd_hiq(struct mqd_manager *mm, void **mqd,\n\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\tstruct queue_properties *q)\n{\n\tinit_mqd(mm, mqd, mqd_mem_obj, gart_addr, q);\n}\n\nstatic void update_mqd_hiq(struct mqd_manager *mm, void *mqd,\n\t\t\tstruct queue_properties *q,\n\t\t\tstruct mqd_update_info *minfo)\n{\n\tstruct cik_mqd *m;\n\n\tm = get_mqd(mqd);\n\tm->cp_hqd_pq_control = DEFAULT_RPTR_BLOCK_SIZE |\n\t\t\t\tDEFAULT_MIN_AVAIL_SIZE |\n\t\t\t\tPRIV_STATE |\n\t\t\t\tKMD_QUEUE;\n\n\t \n\tm->cp_hqd_pq_control |= order_base_2(q->queue_size / 4) - 1;\n\tm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_doorbell_control = DOORBELL_OFFSET(q->doorbell_off);\n\n\tm->cp_hqd_vmid = q->vmid;\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n\n\tset_priority(m, q);\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic int debugfs_show_mqd(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct cik_mqd), false);\n\treturn 0;\n}\n\nstatic int debugfs_show_mqd_sdma(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct cik_sdma_rlc_registers), false);\n\treturn 0;\n}\n\n#endif\n\nstruct mqd_manager *mqd_manager_init_cik(enum KFD_MQD_TYPE type,\n\t\tstruct kfd_node *dev)\n{\n\tstruct mqd_manager *mqd;\n\n\tif (WARN_ON(type >= KFD_MQD_TYPE_MAX))\n\t\treturn NULL;\n\n\tmqd = kzalloc(sizeof(*mqd), GFP_KERNEL);\n\tif (!mqd)\n\t\treturn NULL;\n\n\tmqd->dev = dev;\n\n\tswitch (type) {\n\tcase KFD_MQD_TYPE_CP:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd;\n\t\tmqd->restore_mqd = restore_mqd;\n\t\tmqd->mqd_size = sizeof(struct cik_mqd);\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_HIQ:\n\t\tmqd->allocate_mqd = allocate_hiq_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd_hiq;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct cik_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tmqd->read_doorbell_id = read_doorbell_id;\n\t\tbreak;\n\tcase KFD_MQD_TYPE_DIQ:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd_hiq;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct cik_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_SDMA:\n\t\tmqd->allocate_mqd = allocate_sdma_mqd;\n\t\tmqd->init_mqd = init_mqd_sdma;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = kfd_load_mqd_sdma;\n\t\tmqd->update_mqd = update_mqd_sdma;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_sdma;\n\t\tmqd->is_occupied = kfd_is_occupied_sdma;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd_sdma;\n\t\tmqd->restore_mqd = restore_mqd_sdma;\n\t\tmqd->mqd_size = sizeof(struct cik_sdma_rlc_registers);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd_sdma;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tkfree(mqd);\n\t\treturn NULL;\n\t}\n\n\treturn mqd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}