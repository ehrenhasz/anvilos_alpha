{
  "module_name": "kfd_kernel_queue.c",
  "hash_id": "04dd157ca400ad370c46666c4771546648d616fdf5b6868beb5fd2f2aed3dbf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include \"kfd_kernel_queue.h\"\n#include \"kfd_priv.h\"\n#include \"kfd_device_queue_manager.h\"\n#include \"kfd_pm4_headers.h\"\n#include \"kfd_pm4_opcodes.h\"\n\n#define PM4_COUNT_ZERO (((1 << 15) - 1) << 16)\n\n \nstatic bool kq_initialize(struct kernel_queue *kq, struct kfd_node *dev,\n\t\tenum kfd_queue_type type, unsigned int queue_size)\n{\n\tstruct queue_properties prop;\n\tint retval;\n\tunion PM4_MES_TYPE_3_HEADER nop;\n\n\tif (WARN_ON(type != KFD_QUEUE_TYPE_DIQ && type != KFD_QUEUE_TYPE_HIQ))\n\t\treturn false;\n\n\tpr_debug(\"Initializing queue type %d size %d\\n\", KFD_QUEUE_TYPE_HIQ,\n\t\t\tqueue_size);\n\n\tmemset(&prop, 0, sizeof(prop));\n\tmemset(&nop, 0, sizeof(nop));\n\n\tnop.opcode = IT_NOP;\n\tnop.type = PM4_TYPE_3;\n\tnop.u32all |= PM4_COUNT_ZERO;\n\n\tkq->dev = dev;\n\tkq->nop_packet = nop.u32all;\n\tswitch (type) {\n\tcase KFD_QUEUE_TYPE_DIQ:\n\t\tkq->mqd_mgr = dev->dqm->mqd_mgrs[KFD_MQD_TYPE_DIQ];\n\t\tbreak;\n\tcase KFD_QUEUE_TYPE_HIQ:\n\t\tkq->mqd_mgr = dev->dqm->mqd_mgrs[KFD_MQD_TYPE_HIQ];\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid queue type %d\\n\", type);\n\t\treturn false;\n\t}\n\n\tif (!kq->mqd_mgr)\n\t\treturn false;\n\n\tprop.doorbell_ptr = kfd_get_kernel_doorbell(dev->kfd, &prop.doorbell_off);\n\n\tif (!prop.doorbell_ptr) {\n\t\tpr_err(\"Failed to initialize doorbell\");\n\t\tgoto err_get_kernel_doorbell;\n\t}\n\n\tretval = kfd_gtt_sa_allocate(dev, queue_size, &kq->pq);\n\tif (retval != 0) {\n\t\tpr_err(\"Failed to init pq queues size %d\\n\", queue_size);\n\t\tgoto err_pq_allocate_vidmem;\n\t}\n\n\tkq->pq_kernel_addr = kq->pq->cpu_ptr;\n\tkq->pq_gpu_addr = kq->pq->gpu_addr;\n\n\t \n\tif (dev->adev->asic_type > CHIP_MULLINS) {\n\t\tretval = kfd_gtt_sa_allocate(dev, PAGE_SIZE, &kq->eop_mem);\n\t\tif (retval != 0)\n\t\t\tgoto err_eop_allocate_vidmem;\n\n\t\tkq->eop_gpu_addr = kq->eop_mem->gpu_addr;\n\t\tkq->eop_kernel_addr = kq->eop_mem->cpu_ptr;\n\n\t\tmemset(kq->eop_kernel_addr, 0, PAGE_SIZE);\n\t}\n\n\tretval = kfd_gtt_sa_allocate(dev, sizeof(*kq->rptr_kernel),\n\t\t\t\t\t&kq->rptr_mem);\n\n\tif (retval != 0)\n\t\tgoto err_rptr_allocate_vidmem;\n\n\tkq->rptr_kernel = kq->rptr_mem->cpu_ptr;\n\tkq->rptr_gpu_addr = kq->rptr_mem->gpu_addr;\n\n\tretval = kfd_gtt_sa_allocate(dev, dev->kfd->device_info.doorbell_size,\n\t\t\t\t\t&kq->wptr_mem);\n\n\tif (retval != 0)\n\t\tgoto err_wptr_allocate_vidmem;\n\n\tkq->wptr_kernel = kq->wptr_mem->cpu_ptr;\n\tkq->wptr_gpu_addr = kq->wptr_mem->gpu_addr;\n\n\tmemset(kq->pq_kernel_addr, 0, queue_size);\n\tmemset(kq->rptr_kernel, 0, sizeof(*kq->rptr_kernel));\n\tmemset(kq->wptr_kernel, 0, sizeof(*kq->wptr_kernel));\n\n\tprop.queue_size = queue_size;\n\tprop.is_interop = false;\n\tprop.is_gws = false;\n\tprop.priority = 1;\n\tprop.queue_percent = 100;\n\tprop.type = type;\n\tprop.vmid = 0;\n\tprop.queue_address = kq->pq_gpu_addr;\n\tprop.read_ptr = (uint32_t *) kq->rptr_gpu_addr;\n\tprop.write_ptr = (uint32_t *) kq->wptr_gpu_addr;\n\tprop.eop_ring_buffer_address = kq->eop_gpu_addr;\n\tprop.eop_ring_buffer_size = PAGE_SIZE;\n\n\tif (init_queue(&kq->queue, &prop) != 0)\n\t\tgoto err_init_queue;\n\n\tkq->queue->device = dev;\n\tkq->queue->process = kfd_get_process(current);\n\n\tkq->queue->mqd_mem_obj = kq->mqd_mgr->allocate_mqd(kq->mqd_mgr->dev,\n\t\t\t\t\t&kq->queue->properties);\n\tif (!kq->queue->mqd_mem_obj)\n\t\tgoto err_allocate_mqd;\n\tkq->mqd_mgr->init_mqd(kq->mqd_mgr, &kq->queue->mqd,\n\t\t\t\t\tkq->queue->mqd_mem_obj,\n\t\t\t\t\t&kq->queue->gart_mqd_addr,\n\t\t\t\t\t&kq->queue->properties);\n\t \n\tif (type == KFD_QUEUE_TYPE_HIQ) {\n\t\tpr_debug(\"Assigning hiq to hqd\\n\");\n\t\tkq->queue->pipe = KFD_CIK_HIQ_PIPE;\n\t\tkq->queue->queue = KFD_CIK_HIQ_QUEUE;\n\t\tkq->mqd_mgr->load_mqd(kq->mqd_mgr, kq->queue->mqd,\n\t\t\t\tkq->queue->pipe, kq->queue->queue,\n\t\t\t\t&kq->queue->properties, NULL);\n\t} else {\n\t\t \n\n\t\tretval = kfd_gtt_sa_allocate(dev, sizeof(uint32_t),\n\t\t\t\t\t\t&kq->fence_mem_obj);\n\n\t\tif (retval != 0)\n\t\t\tgoto err_alloc_fence;\n\n\t\tkq->fence_kernel_address = kq->fence_mem_obj->cpu_ptr;\n\t\tkq->fence_gpu_addr = kq->fence_mem_obj->gpu_addr;\n\t}\n\n\tprint_queue(kq->queue);\n\n\treturn true;\nerr_alloc_fence:\n\tkq->mqd_mgr->free_mqd(kq->mqd_mgr, kq->queue->mqd, kq->queue->mqd_mem_obj);\nerr_allocate_mqd:\n\tuninit_queue(kq->queue);\nerr_init_queue:\n\tkfd_gtt_sa_free(dev, kq->wptr_mem);\nerr_wptr_allocate_vidmem:\n\tkfd_gtt_sa_free(dev, kq->rptr_mem);\nerr_rptr_allocate_vidmem:\n\tkfd_gtt_sa_free(dev, kq->eop_mem);\nerr_eop_allocate_vidmem:\n\tkfd_gtt_sa_free(dev, kq->pq);\nerr_pq_allocate_vidmem:\n\tkfd_release_kernel_doorbell(dev->kfd, prop.doorbell_ptr);\nerr_get_kernel_doorbell:\n\treturn false;\n\n}\n\n \nstatic void kq_uninitialize(struct kernel_queue *kq, bool hanging)\n{\n\tif (kq->queue->properties.type == KFD_QUEUE_TYPE_HIQ && !hanging)\n\t\tkq->mqd_mgr->destroy_mqd(kq->mqd_mgr,\n\t\t\t\t\tkq->queue->mqd,\n\t\t\t\t\tKFD_PREEMPT_TYPE_WAVEFRONT_RESET,\n\t\t\t\t\tKFD_UNMAP_LATENCY_MS,\n\t\t\t\t\tkq->queue->pipe,\n\t\t\t\t\tkq->queue->queue);\n\telse if (kq->queue->properties.type == KFD_QUEUE_TYPE_DIQ)\n\t\tkfd_gtt_sa_free(kq->dev, kq->fence_mem_obj);\n\n\tkq->mqd_mgr->free_mqd(kq->mqd_mgr, kq->queue->mqd,\n\t\t\t\tkq->queue->mqd_mem_obj);\n\n\tkfd_gtt_sa_free(kq->dev, kq->rptr_mem);\n\tkfd_gtt_sa_free(kq->dev, kq->wptr_mem);\n\n\t \n\tkfd_gtt_sa_free(kq->dev, kq->eop_mem);\n\n\tkfd_gtt_sa_free(kq->dev, kq->pq);\n\tkfd_release_kernel_doorbell(kq->dev->kfd,\n\t\t\t\t\tkq->queue->properties.doorbell_ptr);\n\tuninit_queue(kq->queue);\n}\n\nint kq_acquire_packet_buffer(struct kernel_queue *kq,\n\t\tsize_t packet_size_in_dwords, unsigned int **buffer_ptr)\n{\n\tsize_t available_size;\n\tsize_t queue_size_dwords;\n\tuint32_t wptr, rptr;\n\tuint64_t wptr64;\n\tunsigned int *queue_address;\n\n\t \n\trptr = *kq->rptr_kernel;\n\twptr = kq->pending_wptr;\n\twptr64 = kq->pending_wptr64;\n\tqueue_address = (unsigned int *)kq->pq_kernel_addr;\n\tqueue_size_dwords = kq->queue->properties.queue_size / 4;\n\n\tpr_debug(\"rptr: %d\\n\", rptr);\n\tpr_debug(\"wptr: %d\\n\", wptr);\n\tpr_debug(\"queue_address 0x%p\\n\", queue_address);\n\n\tavailable_size = (rptr + queue_size_dwords - 1 - wptr) %\n\t\t\t\t\t\t\tqueue_size_dwords;\n\n\tif (packet_size_in_dwords > available_size) {\n\t\t \n\t\tgoto err_no_space;\n\t}\n\n\tif (wptr + packet_size_in_dwords >= queue_size_dwords) {\n\t\t \n\t\tif (packet_size_in_dwords >= rptr)\n\t\t\tgoto err_no_space;\n\n\t\t \n\t\twhile (wptr > 0) {\n\t\t\tqueue_address[wptr] = kq->nop_packet;\n\t\t\twptr = (wptr + 1) % queue_size_dwords;\n\t\t\twptr64++;\n\t\t}\n\t}\n\n\t*buffer_ptr = &queue_address[wptr];\n\tkq->pending_wptr = wptr + packet_size_in_dwords;\n\tkq->pending_wptr64 = wptr64 + packet_size_in_dwords;\n\n\treturn 0;\n\nerr_no_space:\n\t*buffer_ptr = NULL;\n\treturn -ENOMEM;\n}\n\nvoid kq_submit_packet(struct kernel_queue *kq)\n{\n#ifdef DEBUG\n\tint i;\n\n\tfor (i = *kq->wptr_kernel; i < kq->pending_wptr; i++) {\n\t\tpr_debug(\"0x%2X \", kq->pq_kernel_addr[i]);\n\t\tif (i % 15 == 0)\n\t\t\tpr_debug(\"\\n\");\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tif (kq->dev->kfd->device_info.doorbell_size == 8) {\n\t\t*kq->wptr64_kernel = kq->pending_wptr64;\n\t\twrite_kernel_doorbell64(kq->queue->properties.doorbell_ptr,\n\t\t\t\t\tkq->pending_wptr64);\n\t} else {\n\t\t*kq->wptr_kernel = kq->pending_wptr;\n\t\twrite_kernel_doorbell(kq->queue->properties.doorbell_ptr,\n\t\t\t\t\tkq->pending_wptr);\n\t}\n}\n\nvoid kq_rollback_packet(struct kernel_queue *kq)\n{\n\tif (kq->dev->kfd->device_info.doorbell_size == 8) {\n\t\tkq->pending_wptr64 = *kq->wptr64_kernel;\n\t\tkq->pending_wptr = *kq->wptr_kernel %\n\t\t\t(kq->queue->properties.queue_size / 4);\n\t} else {\n\t\tkq->pending_wptr = *kq->wptr_kernel;\n\t}\n}\n\nstruct kernel_queue *kernel_queue_init(struct kfd_node *dev,\n\t\t\t\t\tenum kfd_queue_type type)\n{\n\tstruct kernel_queue *kq;\n\n\tkq = kzalloc(sizeof(*kq), GFP_KERNEL);\n\tif (!kq)\n\t\treturn NULL;\n\n\tif (kq_initialize(kq, dev, type, KFD_KERNEL_QUEUE_SIZE))\n\t\treturn kq;\n\n\tpr_err(\"Failed to init kernel queue\\n\");\n\n\tkfree(kq);\n\treturn NULL;\n}\n\nvoid kernel_queue_uninit(struct kernel_queue *kq, bool hanging)\n{\n\tkq_uninitialize(kq, hanging);\n\tkfree(kq);\n}\n\n \nstatic __attribute__((unused)) void test_kq(struct kfd_node *dev)\n{\n\tstruct kernel_queue *kq;\n\tuint32_t *buffer, i;\n\tint retval;\n\n\tpr_err(\"Starting kernel queue test\\n\");\n\n\tkq = kernel_queue_init(dev, KFD_QUEUE_TYPE_HIQ);\n\tif (unlikely(!kq)) {\n\t\tpr_err(\"  Failed to initialize HIQ\\n\");\n\t\tpr_err(\"Kernel queue test failed\\n\");\n\t\treturn;\n\t}\n\n\tretval = kq_acquire_packet_buffer(kq, 5, &buffer);\n\tif (unlikely(retval != 0)) {\n\t\tpr_err(\"  Failed to acquire packet buffer\\n\");\n\t\tpr_err(\"Kernel queue test failed\\n\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < 5; i++)\n\t\tbuffer[i] = kq->nop_packet;\n\tkq_submit_packet(kq);\n\n\tpr_err(\"Ending kernel queue test\\n\");\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}