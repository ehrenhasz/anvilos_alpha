{
  "module_name": "kfd_flat_memory.c",
  "hash_id": "b0baf6ed830732f8481d12ee11d0896e4299ea5ba51cd0d3c179785d084697ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <uapi/linux/kfd_ioctl.h>\n#include <linux/time.h>\n#include \"kfd_priv.h\"\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/processor.h>\n\n \n\n#define MAKE_GPUVM_APP_BASE_VI(gpu_num) \\\n\t(((uint64_t)(gpu_num) << 61) + 0x1000000000000L)\n\n#define MAKE_GPUVM_APP_LIMIT(base, size) \\\n\t(((uint64_t)(base) & 0xFFFFFF0000000000UL) + (size) - 1)\n\n#define MAKE_SCRATCH_APP_BASE_VI() \\\n\t(((uint64_t)(0x1UL) << 61) + 0x100000000L)\n\n#define MAKE_SCRATCH_APP_LIMIT(base) \\\n\t(((uint64_t)base & 0xFFFFFFFF00000000UL) | 0xFFFFFFFF)\n\n#define MAKE_LDS_APP_BASE_VI() \\\n\t(((uint64_t)(0x1UL) << 61) + 0x0)\n#define MAKE_LDS_APP_LIMIT(base) \\\n\t(((uint64_t)(base) & 0xFFFFFFFF00000000UL) | 0xFFFFFFFF)\n\n \n#define MAKE_LDS_APP_BASE_V9() ((uint64_t)(0x1UL) << 48)\n#define MAKE_SCRATCH_APP_BASE_V9() ((uint64_t)(0x2UL) << 48)\n\n \n#define SVM_USER_BASE (u64)(KFD_CWSR_TBA_TMA_SIZE + 2*PAGE_SIZE)\n#define SVM_CWSR_BASE (SVM_USER_BASE - KFD_CWSR_TBA_TMA_SIZE)\n#define SVM_IB_BASE   (SVM_CWSR_BASE - PAGE_SIZE)\n\nstatic void kfd_init_apertures_vi(struct kfd_process_device *pdd, uint8_t id)\n{\n\t \n\tpdd->lds_base = MAKE_LDS_APP_BASE_VI();\n\tpdd->lds_limit = MAKE_LDS_APP_LIMIT(pdd->lds_base);\n\n\t \n\tpdd->gpuvm_base = SVM_USER_BASE;\n\tpdd->gpuvm_limit =\n\t\tpdd->dev->kfd->shared_resources.gpuvm_size - 1;\n\n\tpdd->scratch_base = MAKE_SCRATCH_APP_BASE_VI();\n\tpdd->scratch_limit = MAKE_SCRATCH_APP_LIMIT(pdd->scratch_base);\n}\n\nstatic void kfd_init_apertures_v9(struct kfd_process_device *pdd, uint8_t id)\n{\n\tpdd->lds_base = MAKE_LDS_APP_BASE_V9();\n\tpdd->lds_limit = MAKE_LDS_APP_LIMIT(pdd->lds_base);\n\n         \n        pdd->gpuvm_base = SVM_USER_BASE;\n\tpdd->gpuvm_limit =\n\t\tpdd->dev->kfd->shared_resources.gpuvm_size - 1;\n\n\tpdd->scratch_base = MAKE_SCRATCH_APP_BASE_V9();\n\tpdd->scratch_limit = MAKE_SCRATCH_APP_LIMIT(pdd->scratch_base);\n}\n\nint kfd_init_apertures(struct kfd_process *process)\n{\n\tuint8_t id  = 0;\n\tstruct kfd_node *dev;\n\tstruct kfd_process_device *pdd;\n\n\t \n\twhile (kfd_topology_enum_kfd_devices(id, &dev) == 0) {\n\t\tif (!dev || kfd_devcgroup_check_permission(dev)) {\n\t\t\t \n\t\t\tid++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpdd = kfd_create_process_device_data(dev, process);\n\t\tif (!pdd) {\n\t\t\tpr_err(\"Failed to create process device data\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tif (process->is_32bit_user_mode) {\n\t\t\tpdd->lds_base = pdd->lds_limit = 0;\n\t\t\tpdd->gpuvm_base = pdd->gpuvm_limit = 0;\n\t\t\tpdd->scratch_base = pdd->scratch_limit = 0;\n\t\t} else {\n\t\t\tswitch (dev->adev->asic_type) {\n\t\t\tcase CHIP_KAVERI:\n\t\t\tcase CHIP_HAWAII:\n\t\t\tcase CHIP_CARRIZO:\n\t\t\tcase CHIP_TONGA:\n\t\t\tcase CHIP_FIJI:\n\t\t\tcase CHIP_POLARIS10:\n\t\t\tcase CHIP_POLARIS11:\n\t\t\tcase CHIP_POLARIS12:\n\t\t\tcase CHIP_VEGAM:\n\t\t\t\tkfd_init_apertures_vi(pdd, id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (KFD_GC_VERSION(dev) >= IP_VERSION(9, 0, 1))\n\t\t\t\t\tkfd_init_apertures_v9(pdd, id);\n\t\t\t\telse {\n\t\t\t\t\tWARN(1, \"Unexpected ASIC family %u\",\n\t\t\t\t\t     dev->adev->asic_type);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n                         \n                        pdd->qpd.cwsr_base = SVM_CWSR_BASE;\n                        pdd->qpd.ib_base = SVM_IB_BASE;\n\t\t}\n\n\t\tdev_dbg(kfd_device, \"node id %u\\n\", id);\n\t\tdev_dbg(kfd_device, \"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device, \"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device, \"lds_limit %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device, \"gpuvm_base %llX\\n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device, \"gpuvm_limit %llX\\n\", pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device, \"scratch_base %llX\\n\", pdd->scratch_base);\n\t\tdev_dbg(kfd_device, \"scratch_limit %llX\\n\", pdd->scratch_limit);\n\n\t\tid++;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}