{
  "module_name": "kfd_doorbell.c",
  "hash_id": "ebb12a0ec3bd2dffca073f5f56fd22e5f9d2b6035f15f9c229f346f02cea22b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_doorbell.c",
  "human_readable_source": "\n \n#include \"kfd_priv.h\"\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/idr.h>\n\n \n\n \n\n \nsize_t kfd_doorbell_process_slice(struct kfd_dev *kfd)\n{\n\tif (!kfd->shared_resources.enable_mes)\n\t\treturn roundup(kfd->device_info.doorbell_size *\n\t\t\t\tKFD_MAX_NUM_OF_QUEUES_PER_PROCESS,\n\t\t\t\tPAGE_SIZE);\n\telse\n\t\treturn amdgpu_mes_doorbell_process_slice(\n\t\t\t\t\t(struct amdgpu_device *)kfd->adev);\n}\n\n \nint kfd_doorbell_init(struct kfd_dev *kfd)\n{\n\tint size = PAGE_SIZE;\n\tint r;\n\n\t \n\n\t \n\tkfd->doorbell_bitmap = bitmap_zalloc(size / sizeof(u32), GFP_KERNEL);\n\tif (!kfd->doorbell_bitmap) {\n\t\tDRM_ERROR(\"Failed to allocate kernel doorbell bitmap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tr = amdgpu_bo_create_kernel(kfd->adev,\n\t\t\t\t    size,\n\t\t\t\t    PAGE_SIZE,\n\t\t\t\t    AMDGPU_GEM_DOMAIN_DOORBELL,\n\t\t\t\t    &kfd->doorbells,\n\t\t\t\t    NULL,\n\t\t\t\t    (void **)&kfd->doorbell_kernel_ptr);\n\tif (r) {\n\t\tpr_err(\"failed to allocate kernel doorbells\\n\");\n\t\tbitmap_free(kfd->doorbell_bitmap);\n\t\treturn r;\n\t}\n\n\tpr_debug(\"Doorbell kernel address == %p\\n\", kfd->doorbell_kernel_ptr);\n\treturn 0;\n}\n\nvoid kfd_doorbell_fini(struct kfd_dev *kfd)\n{\n\tbitmap_free(kfd->doorbell_bitmap);\n\tamdgpu_bo_free_kernel(&kfd->doorbells, NULL,\n\t\t\t     (void **)&kfd->doorbell_kernel_ptr);\n}\n\nint kfd_doorbell_mmap(struct kfd_node *dev, struct kfd_process *process,\n\t\t      struct vm_area_struct *vma)\n{\n\tphys_addr_t address;\n\tstruct kfd_process_device *pdd;\n\n\t \n\tif (vma->vm_end - vma->vm_start != kfd_doorbell_process_slice(dev->kfd))\n\t\treturn -EINVAL;\n\n\tpdd = kfd_get_process_device_data(dev, process);\n\tif (!pdd)\n\t\treturn -EINVAL;\n\n\t \n\taddress = kfd_get_process_doorbells(pdd);\n\tif (!address)\n\t\treturn -ENOMEM;\n\tvm_flags_set(vma, VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_NORESERVE |\n\t\t\t\tVM_DONTDUMP | VM_PFNMAP);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\tpr_debug(\"Mapping doorbell page\\n\"\n\t\t \"     target user address == 0x%08llX\\n\"\n\t\t \"     physical address    == 0x%08llX\\n\"\n\t\t \"     vm_flags            == 0x%04lX\\n\"\n\t\t \"     size                == 0x%04lX\\n\",\n\t\t (unsigned long long) vma->vm_start, address, vma->vm_flags,\n\t\t kfd_doorbell_process_slice(dev->kfd));\n\n\n\treturn io_remap_pfn_range(vma,\n\t\t\t\tvma->vm_start,\n\t\t\t\taddress >> PAGE_SHIFT,\n\t\t\t\tkfd_doorbell_process_slice(dev->kfd),\n\t\t\t\tvma->vm_page_prot);\n}\n\n\n \nvoid __iomem *kfd_get_kernel_doorbell(struct kfd_dev *kfd,\n\t\t\t\t\tunsigned int *doorbell_off)\n{\n\tu32 inx;\n\n\tmutex_lock(&kfd->doorbell_mutex);\n\tinx = find_first_zero_bit(kfd->doorbell_bitmap, PAGE_SIZE / sizeof(u32));\n\n\t__set_bit(inx, kfd->doorbell_bitmap);\n\tmutex_unlock(&kfd->doorbell_mutex);\n\n\tif (inx >= KFD_MAX_NUM_OF_QUEUES_PER_PROCESS)\n\t\treturn NULL;\n\n\t*doorbell_off = amdgpu_doorbell_index_on_bar(kfd->adev,\n\t\t\t\t\t\t     kfd->doorbells,\n\t\t\t\t\t\t     inx,\n\t\t\t\t\t\t     kfd->device_info.doorbell_size);\n\tinx *= 2;\n\n\tpr_debug(\"Get kernel queue doorbell\\n\"\n\t\t\t\"     doorbell offset   == 0x%08X\\n\"\n\t\t\t\"     doorbell index    == 0x%x\\n\",\n\t\t*doorbell_off, inx);\n\n\treturn kfd->doorbell_kernel_ptr + inx;\n}\n\nvoid kfd_release_kernel_doorbell(struct kfd_dev *kfd, u32 __iomem *db_addr)\n{\n\tunsigned int inx;\n\n\tinx = (unsigned int)(db_addr - kfd->doorbell_kernel_ptr);\n\tinx /= 2;\n\n\tmutex_lock(&kfd->doorbell_mutex);\n\t__clear_bit(inx, kfd->doorbell_bitmap);\n\tmutex_unlock(&kfd->doorbell_mutex);\n}\n\nvoid write_kernel_doorbell(void __iomem *db, u32 value)\n{\n\tif (db) {\n\t\twritel(value, db);\n\t\tpr_debug(\"Writing %d to doorbell address %p\\n\", value, db);\n\t}\n}\n\nvoid write_kernel_doorbell64(void __iomem *db, u64 value)\n{\n\tif (db) {\n\t\tWARN(((unsigned long)db & 7) != 0,\n\t\t     \"Unaligned 64-bit doorbell\");\n\t\twriteq(value, (u64 __iomem *)db);\n\t\tpr_debug(\"writing %llu to doorbell address %p\\n\", value, db);\n\t}\n}\n\nstatic int init_doorbell_bitmap(struct qcm_process_device *qpd,\n\t\t\t\tstruct kfd_dev *dev)\n{\n\tunsigned int i;\n\tint range_start = dev->shared_resources.non_cp_doorbells_start;\n\tint range_end = dev->shared_resources.non_cp_doorbells_end;\n\n\tif (!KFD_IS_SOC15(dev))\n\t\treturn 0;\n\n\t \n\tpr_debug(\"reserved doorbell 0x%03x - 0x%03x\\n\", range_start, range_end);\n\tpr_debug(\"reserved doorbell 0x%03x - 0x%03x\\n\",\n\t\t\trange_start + KFD_QUEUE_DOORBELL_MIRROR_OFFSET,\n\t\t\trange_end + KFD_QUEUE_DOORBELL_MIRROR_OFFSET);\n\n\tfor (i = 0; i < KFD_MAX_NUM_OF_QUEUES_PER_PROCESS / 2; i++) {\n\t\tif (i >= range_start && i <= range_end) {\n\t\t\t__set_bit(i, qpd->doorbell_bitmap);\n\t\t\t__set_bit(i + KFD_QUEUE_DOORBELL_MIRROR_OFFSET,\n\t\t\t\t  qpd->doorbell_bitmap);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nphys_addr_t kfd_get_process_doorbells(struct kfd_process_device *pdd)\n{\n\tstruct amdgpu_device *adev = pdd->dev->adev;\n\tuint32_t first_db_index;\n\n\tif (!pdd->qpd.proc_doorbells) {\n\t\tif (kfd_alloc_process_doorbells(pdd->dev->kfd, pdd))\n\t\t\t \n\t\t\treturn 0;\n\t}\n\n\tfirst_db_index = amdgpu_doorbell_index_on_bar(adev,\n\t\t\t\t\t\t      pdd->qpd.proc_doorbells,\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      pdd->dev->kfd->device_info.doorbell_size);\n\treturn adev->doorbell.base + first_db_index * sizeof(uint32_t);\n}\n\nint kfd_alloc_process_doorbells(struct kfd_dev *kfd, struct kfd_process_device *pdd)\n{\n\tint r;\n\tstruct qcm_process_device *qpd = &pdd->qpd;\n\n\t \n\tqpd->doorbell_bitmap = bitmap_zalloc(KFD_MAX_NUM_OF_QUEUES_PER_PROCESS,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!qpd->doorbell_bitmap) {\n\t\tDRM_ERROR(\"Failed to allocate process doorbell bitmap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = init_doorbell_bitmap(&pdd->qpd, kfd);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to initialize process doorbells\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tr = amdgpu_bo_create_kernel(kfd->adev,\n\t\t\t\t    kfd_doorbell_process_slice(kfd),\n\t\t\t\t    PAGE_SIZE,\n\t\t\t\t    AMDGPU_GEM_DOMAIN_DOORBELL,\n\t\t\t\t    &qpd->proc_doorbells,\n\t\t\t\t    NULL,\n\t\t\t\t    NULL);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to allocate process doorbells\\n\");\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tbitmap_free(qpd->doorbell_bitmap);\n\tqpd->doorbell_bitmap = NULL;\n\treturn r;\n}\n\nvoid kfd_free_process_doorbells(struct kfd_dev *kfd, struct kfd_process_device *pdd)\n{\n\tstruct qcm_process_device *qpd = &pdd->qpd;\n\n\tif (qpd->doorbell_bitmap) {\n\t\tbitmap_free(qpd->doorbell_bitmap);\n\t\tqpd->doorbell_bitmap = NULL;\n\t}\n\n\tamdgpu_bo_free_kernel(&qpd->proc_doorbells, NULL, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}