{
  "module_name": "kfd_debug.h",
  "hash_id": "c8618282539c8a8a504e5043d253ee634a205b745694e67a8eeb1cbaf8ff2beb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_debug.h",
  "human_readable_source": " \n\n#ifndef KFD_DEBUG_EVENTS_H_INCLUDED\n#define KFD_DEBUG_EVENTS_H_INCLUDED\n\n#include \"kfd_priv.h\"\n\nvoid kfd_dbg_trap_deactivate(struct kfd_process *target, bool unwind, int unwind_count);\nint kfd_dbg_trap_activate(struct kfd_process *target);\nint kfd_dbg_ev_query_debug_event(struct kfd_process *process,\n\t\t\tunsigned int *queue_id,\n\t\t\tunsigned int *gpu_id,\n\t\t\tuint64_t exception_clear_mask,\n\t\t\tuint64_t *event_status);\nbool kfd_set_dbg_ev_from_interrupt(struct kfd_node *dev,\n\t\t\t\t   unsigned int pasid,\n\t\t\t\t   uint32_t doorbell_id,\n\t\t\t\t   uint64_t trap_mask,\n\t\t\t\t   void *exception_data,\n\t\t\t\t   size_t exception_data_size);\nbool kfd_dbg_ev_raise(uint64_t event_mask,\n\t\t\tstruct kfd_process *process, struct kfd_node *dev,\n\t\t\tunsigned int source_id, bool use_worker,\n\t\t\tvoid *exception_data,\n\t\t\tsize_t exception_data_size);\nint kfd_dbg_trap_disable(struct kfd_process *target);\nint kfd_dbg_trap_enable(struct kfd_process *target, uint32_t fd,\n\t\t\tvoid __user *runtime_info,\n\t\t\tuint32_t *runtime_info_size);\nint kfd_dbg_trap_set_wave_launch_override(struct kfd_process *target,\n\t\t\t\t\tuint32_t trap_override,\n\t\t\t\t\tuint32_t trap_mask_bits,\n\t\t\t\t\tuint32_t trap_mask_request,\n\t\t\t\t\tuint32_t *trap_mask_prev,\n\t\t\t\t\tuint32_t *trap_mask_supported);\nint kfd_dbg_trap_set_wave_launch_mode(struct kfd_process *target,\n\t\t\t\t\tuint8_t wave_launch_mode);\nint kfd_dbg_trap_clear_dev_address_watch(struct kfd_process_device *pdd,\n\t\t\t\t\tuint32_t watch_id);\nint kfd_dbg_trap_set_dev_address_watch(struct kfd_process_device *pdd,\n\t\t\t\t\tuint64_t watch_address,\n\t\t\t\t\tuint32_t watch_address_mask,\n\t\t\t\t\tuint32_t *watch_id,\n\t\t\t\t\tuint32_t watch_mode);\nint kfd_dbg_trap_set_flags(struct kfd_process *target, uint32_t *flags);\nint kfd_dbg_trap_query_exception_info(struct kfd_process *target,\n\t\tuint32_t source_id,\n\t\tuint32_t exception_code,\n\t\tbool clear_exception,\n\t\tvoid __user *info,\n\t\tuint32_t *info_size);\nint kfd_dbg_send_exception_to_runtime(struct kfd_process *p,\n\t\t\t\t\tunsigned int dev_id,\n\t\t\t\t\tunsigned int queue_id,\n\t\t\t\t\tuint64_t error_reason);\n\nstatic inline bool kfd_dbg_is_per_vmid_supported(struct kfd_node *dev)\n{\n\treturn (KFD_GC_VERSION(dev) == IP_VERSION(9, 4, 2) ||\n\t\tKFD_GC_VERSION(dev) == IP_VERSION(9, 4, 3) ||\n\t\tKFD_GC_VERSION(dev) >= IP_VERSION(11, 0, 0));\n}\n\nvoid debug_event_write_work_handler(struct work_struct *work);\nint kfd_dbg_trap_device_snapshot(struct kfd_process *target,\n\t\tuint64_t exception_clear_mask,\n\t\tvoid __user *user_info,\n\t\tuint32_t *number_of_device_infos,\n\t\tuint32_t *entry_size);\n\nvoid kfd_dbg_set_enabled_debug_exception_mask(struct kfd_process *target,\n\t\t\t\t\tuint64_t exception_set_mask);\n \nstatic inline bool kfd_dbg_is_rlc_restore_supported(struct kfd_node *dev)\n{\n\treturn !(KFD_GC_VERSION(dev) == IP_VERSION(10, 1, 10) ||\n\t\t KFD_GC_VERSION(dev) == IP_VERSION(10, 1, 1));\n}\n\nstatic inline bool kfd_dbg_has_cwsr_workaround(struct kfd_node *dev)\n{\n\treturn KFD_GC_VERSION(dev) >= IP_VERSION(11, 0, 0) &&\n\t       KFD_GC_VERSION(dev) <= IP_VERSION(11, 0, 3);\n}\n\nstatic inline bool kfd_dbg_has_gws_support(struct kfd_node *dev)\n{\n\tif ((KFD_GC_VERSION(dev) == IP_VERSION(9, 0, 1)\n\t\t\t&& dev->kfd->mec2_fw_version < 0x81b6) ||\n\t\t(KFD_GC_VERSION(dev) >= IP_VERSION(9, 1, 0)\n\t\t\t&& KFD_GC_VERSION(dev) <= IP_VERSION(9, 2, 2)\n\t\t\t&& dev->kfd->mec2_fw_version < 0x1b6) ||\n\t\t(KFD_GC_VERSION(dev) == IP_VERSION(9, 4, 0)\n\t\t\t&& dev->kfd->mec2_fw_version < 0x1b6) ||\n\t\t(KFD_GC_VERSION(dev) == IP_VERSION(9, 4, 1)\n\t\t\t&& dev->kfd->mec2_fw_version < 0x30) ||\n\t\t(KFD_GC_VERSION(dev) >= IP_VERSION(11, 0, 0) &&\n\t\t\tKFD_GC_VERSION(dev) < IP_VERSION(12, 0, 0)))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nint kfd_dbg_set_mes_debug_mode(struct kfd_process_device *pdd, bool sq_trap_en);\n\nstatic inline bool kfd_dbg_has_ttmps_always_setup(struct kfd_node *dev)\n{\n\treturn (KFD_GC_VERSION(dev) < IP_VERSION(11, 0, 0) &&\n\t\t\tKFD_GC_VERSION(dev) != IP_VERSION(9, 4, 2)) ||\n\t       (KFD_GC_VERSION(dev) >= IP_VERSION(11, 0, 0) &&\n\t\t\tKFD_GC_VERSION(dev) < IP_VERSION(12, 0, 0) &&\n\t\t\t(dev->adev->mes.sched_version & AMDGPU_MES_VERSION_MASK) >= 70);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}