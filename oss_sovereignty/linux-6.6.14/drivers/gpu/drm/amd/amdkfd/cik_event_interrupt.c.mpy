{
  "module_name": "cik_event_interrupt.c",
  "hash_id": "dc940158afcb702c4949cbece2f312ec7b7606e9ba2abce265002d3ad8e22c2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c",
  "human_readable_source": " \n\n#include \"kfd_priv.h\"\n#include \"kfd_events.h\"\n#include \"cik_int.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"kfd_smi_events.h\"\n\nstatic bool cik_event_interrupt_isr(struct kfd_node *dev,\n\t\t\t\t\tconst uint32_t *ih_ring_entry,\n\t\t\t\t\tuint32_t *patched_ihre,\n\t\t\t\t\tbool *patched_flag)\n{\n\tconst struct cik_ih_ring_entry *ihre =\n\t\t\t(const struct cik_ih_ring_entry *)ih_ring_entry;\n\tconst struct kfd2kgd_calls *f2g = dev->kfd2kgd;\n\tunsigned int vmid;\n\tuint16_t pasid;\n\tbool ret;\n\n\t \n\tif ((ihre->source_id == CIK_INTSRC_GFX_PAGE_INV_FAULT ||\n\t\tihre->source_id == CIK_INTSRC_GFX_MEM_PROT_FAULT) &&\n\t\tdev->adev->asic_type == CHIP_HAWAII) {\n\t\tstruct cik_ih_ring_entry *tmp_ihre =\n\t\t\t(struct cik_ih_ring_entry *)patched_ihre;\n\n\t\t*patched_flag = true;\n\t\t*tmp_ihre = *ihre;\n\n\t\tvmid = f2g->read_vmid_from_vmfault_reg(dev->adev);\n\t\tret = f2g->get_atc_vmid_pasid_mapping_info(dev->adev, vmid, &pasid);\n\n\t\ttmp_ihre->ring_id &= 0x000000ff;\n\t\ttmp_ihre->ring_id |= vmid << 8;\n\t\ttmp_ihre->ring_id |= pasid << 16;\n\n\t\treturn ret && (pasid != 0) &&\n\t\t\tvmid >= dev->vm_info.first_vmid_kfd &&\n\t\t\tvmid <= dev->vm_info.last_vmid_kfd;\n\t}\n\n\t \n\tvmid  = (ihre->ring_id & 0x0000ff00) >> 8;\n\tif (vmid < dev->vm_info.first_vmid_kfd ||\n\t    vmid > dev->vm_info.last_vmid_kfd)\n\t\treturn false;\n\n\t \n\tpasid = (ihre->ring_id & 0xffff0000) >> 16;\n\tif (WARN_ONCE(pasid == 0, \"FW bug: No PASID in KFD interrupt\"))\n\t\treturn false;\n\n\t \n\treturn ihre->source_id == CIK_INTSRC_CP_END_OF_PIPE ||\n\t\tihre->source_id == CIK_INTSRC_SDMA_TRAP ||\n\t\tihre->source_id == CIK_INTSRC_SQ_INTERRUPT_MSG ||\n\t\tihre->source_id == CIK_INTSRC_CP_BAD_OPCODE ||\n\t\t((ihre->source_id == CIK_INTSRC_GFX_PAGE_INV_FAULT ||\n\t\tihre->source_id == CIK_INTSRC_GFX_MEM_PROT_FAULT) &&\n\t\t!amdgpu_no_queue_eviction_on_vm_fault);\n}\n\nstatic void cik_event_interrupt_wq(struct kfd_node *dev,\n\t\t\t\t\tconst uint32_t *ih_ring_entry)\n{\n\tconst struct cik_ih_ring_entry *ihre =\n\t\t\t(const struct cik_ih_ring_entry *)ih_ring_entry;\n\tuint32_t context_id = ihre->data & 0xfffffff;\n\tunsigned int vmid  = (ihre->ring_id & 0x0000ff00) >> 8;\n\tu32 pasid = (ihre->ring_id & 0xffff0000) >> 16;\n\n\tif (pasid == 0)\n\t\treturn;\n\n\tif (ihre->source_id == CIK_INTSRC_CP_END_OF_PIPE)\n\t\tkfd_signal_event_interrupt(pasid, context_id, 28);\n\telse if (ihre->source_id == CIK_INTSRC_SDMA_TRAP)\n\t\tkfd_signal_event_interrupt(pasid, context_id, 28);\n\telse if (ihre->source_id == CIK_INTSRC_SQ_INTERRUPT_MSG)\n\t\tkfd_signal_event_interrupt(pasid, context_id & 0xff, 8);\n\telse if (ihre->source_id == CIK_INTSRC_CP_BAD_OPCODE)\n\t\tkfd_signal_hw_exception_event(pasid);\n\telse if (ihre->source_id == CIK_INTSRC_GFX_PAGE_INV_FAULT ||\n\t\tihre->source_id == CIK_INTSRC_GFX_MEM_PROT_FAULT) {\n\t\tstruct kfd_vm_fault_info info;\n\n\t\tkfd_smi_event_update_vmfault(dev, pasid);\n\t\tkfd_dqm_evict_pasid(dev->dqm, pasid);\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tamdgpu_amdkfd_gpuvm_get_vm_fault_info(dev->adev, &info);\n\t\tif (!info.page_addr && !info.status)\n\t\t\treturn;\n\n\t\tif (info.vmid == vmid)\n\t\t\tkfd_signal_vm_fault_event(dev, pasid, &info, NULL);\n\t\telse\n\t\t\tkfd_signal_vm_fault_event(dev, pasid, NULL, NULL);\n\t}\n}\n\nconst struct kfd_event_interrupt_class event_interrupt_class_cik = {\n\t.interrupt_isr = cik_event_interrupt_isr,\n\t.interrupt_wq = cik_event_interrupt_wq,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}