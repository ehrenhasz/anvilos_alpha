{
  "module_name": "kfd_topology.c",
  "hash_id": "5b34a00e66c7ab9c46bae48e29e0f83188f4e155dec0b73a5d2c7a1640c87b0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_topology.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/acpi.h>\n#include <linux/hash.h>\n#include <linux/cpufreq.h>\n#include <linux/log2.h>\n#include <linux/dmi.h>\n#include <linux/atomic.h>\n\n#include \"kfd_priv.h\"\n#include \"kfd_crat.h\"\n#include \"kfd_topology.h\"\n#include \"kfd_device_queue_manager.h\"\n#include \"kfd_svm.h\"\n#include \"kfd_debug.h\"\n#include \"amdgpu_amdkfd.h\"\n#include \"amdgpu_ras.h\"\n#include \"amdgpu.h\"\n\n \nstatic struct list_head topology_device_list;\nstatic struct kfd_system_properties sys_props;\n\nstatic DECLARE_RWSEM(topology_lock);\nstatic uint32_t topology_crat_proximity_domain;\n\nstruct kfd_topology_device *kfd_topology_device_by_proximity_domain_no_lock(\n\t\t\t\t\t\tuint32_t proximity_domain)\n{\n\tstruct kfd_topology_device *top_dev;\n\tstruct kfd_topology_device *device = NULL;\n\n\tlist_for_each_entry(top_dev, &topology_device_list, list)\n\t\tif (top_dev->proximity_domain == proximity_domain) {\n\t\t\tdevice = top_dev;\n\t\t\tbreak;\n\t\t}\n\n\treturn device;\n}\n\nstruct kfd_topology_device *kfd_topology_device_by_proximity_domain(\n\t\t\t\t\t\tuint32_t proximity_domain)\n{\n\tstruct kfd_topology_device *device = NULL;\n\n\tdown_read(&topology_lock);\n\n\tdevice = kfd_topology_device_by_proximity_domain_no_lock(\n\t\t\t\t\t\t\tproximity_domain);\n\tup_read(&topology_lock);\n\n\treturn device;\n}\n\nstruct kfd_topology_device *kfd_topology_device_by_id(uint32_t gpu_id)\n{\n\tstruct kfd_topology_device *top_dev = NULL;\n\tstruct kfd_topology_device *ret = NULL;\n\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(top_dev, &topology_device_list, list)\n\t\tif (top_dev->gpu_id == gpu_id) {\n\t\t\tret = top_dev;\n\t\t\tbreak;\n\t\t}\n\n\tup_read(&topology_lock);\n\n\treturn ret;\n}\n\nstruct kfd_node *kfd_device_by_id(uint32_t gpu_id)\n{\n\tstruct kfd_topology_device *top_dev;\n\n\ttop_dev = kfd_topology_device_by_id(gpu_id);\n\tif (!top_dev)\n\t\treturn NULL;\n\n\treturn top_dev->gpu;\n}\n\nstruct kfd_node *kfd_device_by_pci_dev(const struct pci_dev *pdev)\n{\n\tstruct kfd_topology_device *top_dev;\n\tstruct kfd_node *device = NULL;\n\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(top_dev, &topology_device_list, list)\n\t\tif (top_dev->gpu && top_dev->gpu->adev->pdev == pdev) {\n\t\t\tdevice = top_dev->gpu;\n\t\t\tbreak;\n\t\t}\n\n\tup_read(&topology_lock);\n\n\treturn device;\n}\n\n \nstatic void kfd_release_topology_device(struct kfd_topology_device *dev)\n{\n\tstruct kfd_mem_properties *mem;\n\tstruct kfd_cache_properties *cache;\n\tstruct kfd_iolink_properties *iolink;\n\tstruct kfd_iolink_properties *p2plink;\n\tstruct kfd_perf_properties *perf;\n\n\tlist_del(&dev->list);\n\n\twhile (dev->mem_props.next != &dev->mem_props) {\n\t\tmem = container_of(dev->mem_props.next,\n\t\t\t\tstruct kfd_mem_properties, list);\n\t\tlist_del(&mem->list);\n\t\tkfree(mem);\n\t}\n\n\twhile (dev->cache_props.next != &dev->cache_props) {\n\t\tcache = container_of(dev->cache_props.next,\n\t\t\t\tstruct kfd_cache_properties, list);\n\t\tlist_del(&cache->list);\n\t\tkfree(cache);\n\t}\n\n\twhile (dev->io_link_props.next != &dev->io_link_props) {\n\t\tiolink = container_of(dev->io_link_props.next,\n\t\t\t\tstruct kfd_iolink_properties, list);\n\t\tlist_del(&iolink->list);\n\t\tkfree(iolink);\n\t}\n\n\twhile (dev->p2p_link_props.next != &dev->p2p_link_props) {\n\t\tp2plink = container_of(dev->p2p_link_props.next,\n\t\t\t\tstruct kfd_iolink_properties, list);\n\t\tlist_del(&p2plink->list);\n\t\tkfree(p2plink);\n\t}\n\n\twhile (dev->perf_props.next != &dev->perf_props) {\n\t\tperf = container_of(dev->perf_props.next,\n\t\t\t\tstruct kfd_perf_properties, list);\n\t\tlist_del(&perf->list);\n\t\tkfree(perf);\n\t}\n\n\tkfree(dev);\n}\n\nvoid kfd_release_topology_device_list(struct list_head *device_list)\n{\n\tstruct kfd_topology_device *dev;\n\n\twhile (!list_empty(device_list)) {\n\t\tdev = list_first_entry(device_list,\n\t\t\t\t       struct kfd_topology_device, list);\n\t\tkfd_release_topology_device(dev);\n\t}\n}\n\nstatic void kfd_release_live_view(void)\n{\n\tkfd_release_topology_device_list(&topology_device_list);\n\tmemset(&sys_props, 0, sizeof(sys_props));\n}\n\nstruct kfd_topology_device *kfd_create_topology_device(\n\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_topology_device *dev;\n\n\tdev = kfd_alloc_struct(dev);\n\tif (!dev) {\n\t\tpr_err(\"No memory to allocate a topology device\");\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&dev->mem_props);\n\tINIT_LIST_HEAD(&dev->cache_props);\n\tINIT_LIST_HEAD(&dev->io_link_props);\n\tINIT_LIST_HEAD(&dev->p2p_link_props);\n\tINIT_LIST_HEAD(&dev->perf_props);\n\n\tlist_add_tail(&dev->list, device_list);\n\n\treturn dev;\n}\n\n\n#define sysfs_show_gen_prop(buffer, offs, fmt, ...)\t\t\\\n\t\t(offs += snprintf(buffer+offs, PAGE_SIZE-offs,\t\\\n\t\t\t\t  fmt, __VA_ARGS__))\n#define sysfs_show_32bit_prop(buffer, offs, name, value) \\\n\t\tsysfs_show_gen_prop(buffer, offs, \"%s %u\\n\", name, value)\n#define sysfs_show_64bit_prop(buffer, offs, name, value) \\\n\t\tsysfs_show_gen_prop(buffer, offs, \"%s %llu\\n\", name, value)\n#define sysfs_show_32bit_val(buffer, offs, value) \\\n\t\tsysfs_show_gen_prop(buffer, offs, \"%u\\n\", value)\n#define sysfs_show_str_val(buffer, offs, value) \\\n\t\tsysfs_show_gen_prop(buffer, offs, \"%s\\n\", value)\n\nstatic ssize_t sysprops_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buffer)\n{\n\tint offs = 0;\n\n\t \n\tbuffer[0] = 0;\n\n\tif (attr == &sys_props.attr_genid) {\n\t\tsysfs_show_32bit_val(buffer, offs,\n\t\t\t\t     sys_props.generation_count);\n\t} else if (attr == &sys_props.attr_props) {\n\t\tsysfs_show_64bit_prop(buffer, offs, \"platform_oem\",\n\t\t\t\t      sys_props.platform_oem);\n\t\tsysfs_show_64bit_prop(buffer, offs, \"platform_id\",\n\t\t\t\t      sys_props.platform_id);\n\t\tsysfs_show_64bit_prop(buffer, offs, \"platform_rev\",\n\t\t\t\t      sys_props.platform_rev);\n\t} else {\n\t\toffs = -EINVAL;\n\t}\n\n\treturn offs;\n}\n\nstatic void kfd_topology_kobj_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct sysfs_ops sysprops_ops = {\n\t.show = sysprops_show,\n};\n\nstatic const struct kobj_type sysprops_type = {\n\t.release = kfd_topology_kobj_release,\n\t.sysfs_ops = &sysprops_ops,\n};\n\nstatic ssize_t iolink_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buffer)\n{\n\tint offs = 0;\n\tstruct kfd_iolink_properties *iolink;\n\n\t \n\tbuffer[0] = 0;\n\n\tiolink = container_of(attr, struct kfd_iolink_properties, attr);\n\tif (iolink->gpu && kfd_devcgroup_check_permission(iolink->gpu))\n\t\treturn -EPERM;\n\tsysfs_show_32bit_prop(buffer, offs, \"type\", iolink->iolink_type);\n\tsysfs_show_32bit_prop(buffer, offs, \"version_major\", iolink->ver_maj);\n\tsysfs_show_32bit_prop(buffer, offs, \"version_minor\", iolink->ver_min);\n\tsysfs_show_32bit_prop(buffer, offs, \"node_from\", iolink->node_from);\n\tsysfs_show_32bit_prop(buffer, offs, \"node_to\", iolink->node_to);\n\tsysfs_show_32bit_prop(buffer, offs, \"weight\", iolink->weight);\n\tsysfs_show_32bit_prop(buffer, offs, \"min_latency\", iolink->min_latency);\n\tsysfs_show_32bit_prop(buffer, offs, \"max_latency\", iolink->max_latency);\n\tsysfs_show_32bit_prop(buffer, offs, \"min_bandwidth\",\n\t\t\t      iolink->min_bandwidth);\n\tsysfs_show_32bit_prop(buffer, offs, \"max_bandwidth\",\n\t\t\t      iolink->max_bandwidth);\n\tsysfs_show_32bit_prop(buffer, offs, \"recommended_transfer_size\",\n\t\t\t      iolink->rec_transfer_size);\n\tsysfs_show_32bit_prop(buffer, offs, \"flags\", iolink->flags);\n\n\treturn offs;\n}\n\nstatic const struct sysfs_ops iolink_ops = {\n\t.show = iolink_show,\n};\n\nstatic const struct kobj_type iolink_type = {\n\t.release = kfd_topology_kobj_release,\n\t.sysfs_ops = &iolink_ops,\n};\n\nstatic ssize_t mem_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buffer)\n{\n\tint offs = 0;\n\tstruct kfd_mem_properties *mem;\n\n\t \n\tbuffer[0] = 0;\n\n\tmem = container_of(attr, struct kfd_mem_properties, attr);\n\tif (mem->gpu && kfd_devcgroup_check_permission(mem->gpu))\n\t\treturn -EPERM;\n\tsysfs_show_32bit_prop(buffer, offs, \"heap_type\", mem->heap_type);\n\tsysfs_show_64bit_prop(buffer, offs, \"size_in_bytes\",\n\t\t\t      mem->size_in_bytes);\n\tsysfs_show_32bit_prop(buffer, offs, \"flags\", mem->flags);\n\tsysfs_show_32bit_prop(buffer, offs, \"width\", mem->width);\n\tsysfs_show_32bit_prop(buffer, offs, \"mem_clk_max\",\n\t\t\t      mem->mem_clk_max);\n\n\treturn offs;\n}\n\nstatic const struct sysfs_ops mem_ops = {\n\t.show = mem_show,\n};\n\nstatic const struct kobj_type mem_type = {\n\t.release = kfd_topology_kobj_release,\n\t.sysfs_ops = &mem_ops,\n};\n\nstatic ssize_t kfd_cache_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buffer)\n{\n\tint offs = 0;\n\tuint32_t i, j;\n\tstruct kfd_cache_properties *cache;\n\n\t \n\tbuffer[0] = 0;\n\tcache = container_of(attr, struct kfd_cache_properties, attr);\n\tif (cache->gpu && kfd_devcgroup_check_permission(cache->gpu))\n\t\treturn -EPERM;\n\tsysfs_show_32bit_prop(buffer, offs, \"processor_id_low\",\n\t\t\tcache->processor_id_low);\n\tsysfs_show_32bit_prop(buffer, offs, \"level\", cache->cache_level);\n\tsysfs_show_32bit_prop(buffer, offs, \"size\", cache->cache_size);\n\tsysfs_show_32bit_prop(buffer, offs, \"cache_line_size\",\n\t\t\t      cache->cacheline_size);\n\tsysfs_show_32bit_prop(buffer, offs, \"cache_lines_per_tag\",\n\t\t\t      cache->cachelines_per_tag);\n\tsysfs_show_32bit_prop(buffer, offs, \"association\", cache->cache_assoc);\n\tsysfs_show_32bit_prop(buffer, offs, \"latency\", cache->cache_latency);\n\tsysfs_show_32bit_prop(buffer, offs, \"type\", cache->cache_type);\n\n\toffs += snprintf(buffer+offs, PAGE_SIZE-offs, \"sibling_map \");\n\tfor (i = 0; i < cache->sibling_map_size; i++)\n\t\tfor (j = 0; j < sizeof(cache->sibling_map[0])*8; j++)\n\t\t\t \n\t\t\toffs += snprintf(buffer+offs, PAGE_SIZE-offs, \"%d,\",\n\t\t\t\t\t\t(cache->sibling_map[i] >> j) & 1);\n\n\t \n\tbuffer[offs-1] = '\\n';\n\treturn offs;\n}\n\nstatic const struct sysfs_ops cache_ops = {\n\t.show = kfd_cache_show,\n};\n\nstatic const struct kobj_type cache_type = {\n\t.release = kfd_topology_kobj_release,\n\t.sysfs_ops = &cache_ops,\n};\n\n \n\nstruct kfd_perf_attr {\n\tstruct kobj_attribute attr;\n\tuint32_t data;\n};\n\nstatic ssize_t perf_show(struct kobject *kobj, struct kobj_attribute *attrs,\n\t\t\tchar *buf)\n{\n\tint offs = 0;\n\tstruct kfd_perf_attr *attr;\n\n\tbuf[0] = 0;\n\tattr = container_of(attrs, struct kfd_perf_attr, attr);\n\tif (!attr->data)  \n\t\treturn 0;\n\telse\n\t\treturn sysfs_show_32bit_val(buf, offs, attr->data);\n}\n\n#define KFD_PERF_DESC(_name, _data)\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.attr  = __ATTR(_name, 0444, perf_show, NULL),\t\\\n\t.data = _data,\t\t\t\t\t\\\n}\n\nstatic struct kfd_perf_attr perf_attr_iommu[] = {\n\tKFD_PERF_DESC(max_concurrent, 0),\n\tKFD_PERF_DESC(num_counters, 0),\n\tKFD_PERF_DESC(counter_ids, 0),\n};\n \n\nstatic ssize_t node_show(struct kobject *kobj, struct attribute *attr,\n\t\tchar *buffer)\n{\n\tint offs = 0;\n\tstruct kfd_topology_device *dev;\n\tuint32_t log_max_watch_addr;\n\n\t \n\tbuffer[0] = 0;\n\n\tif (strcmp(attr->name, \"gpu_id\") == 0) {\n\t\tdev = container_of(attr, struct kfd_topology_device,\n\t\t\t\tattr_gpuid);\n\t\tif (dev->gpu && kfd_devcgroup_check_permission(dev->gpu))\n\t\t\treturn -EPERM;\n\t\treturn sysfs_show_32bit_val(buffer, offs, dev->gpu_id);\n\t}\n\n\tif (strcmp(attr->name, \"name\") == 0) {\n\t\tdev = container_of(attr, struct kfd_topology_device,\n\t\t\t\tattr_name);\n\n\t\tif (dev->gpu && kfd_devcgroup_check_permission(dev->gpu))\n\t\t\treturn -EPERM;\n\t\treturn sysfs_show_str_val(buffer, offs, dev->node_props.name);\n\t}\n\n\tdev = container_of(attr, struct kfd_topology_device,\n\t\t\tattr_props);\n\tif (dev->gpu && kfd_devcgroup_check_permission(dev->gpu))\n\t\treturn -EPERM;\n\tsysfs_show_32bit_prop(buffer, offs, \"cpu_cores_count\",\n\t\t\t      dev->node_props.cpu_cores_count);\n\tsysfs_show_32bit_prop(buffer, offs, \"simd_count\",\n\t\t\t      dev->gpu ? dev->node_props.simd_count : 0);\n\tsysfs_show_32bit_prop(buffer, offs, \"mem_banks_count\",\n\t\t\t      dev->node_props.mem_banks_count);\n\tsysfs_show_32bit_prop(buffer, offs, \"caches_count\",\n\t\t\t      dev->node_props.caches_count);\n\tsysfs_show_32bit_prop(buffer, offs, \"io_links_count\",\n\t\t\t      dev->node_props.io_links_count);\n\tsysfs_show_32bit_prop(buffer, offs, \"p2p_links_count\",\n\t\t\t      dev->node_props.p2p_links_count);\n\tsysfs_show_32bit_prop(buffer, offs, \"cpu_core_id_base\",\n\t\t\t      dev->node_props.cpu_core_id_base);\n\tsysfs_show_32bit_prop(buffer, offs, \"simd_id_base\",\n\t\t\t      dev->node_props.simd_id_base);\n\tsysfs_show_32bit_prop(buffer, offs, \"max_waves_per_simd\",\n\t\t\t      dev->node_props.max_waves_per_simd);\n\tsysfs_show_32bit_prop(buffer, offs, \"lds_size_in_kb\",\n\t\t\t      dev->node_props.lds_size_in_kb);\n\tsysfs_show_32bit_prop(buffer, offs, \"gds_size_in_kb\",\n\t\t\t      dev->node_props.gds_size_in_kb);\n\tsysfs_show_32bit_prop(buffer, offs, \"num_gws\",\n\t\t\t      dev->node_props.num_gws);\n\tsysfs_show_32bit_prop(buffer, offs, \"wave_front_size\",\n\t\t\t      dev->node_props.wave_front_size);\n\tsysfs_show_32bit_prop(buffer, offs, \"array_count\",\n\t\t\t      dev->gpu ? (dev->node_props.array_count *\n\t\t\t\t\t  NUM_XCC(dev->gpu->xcc_mask)) : 0);\n\tsysfs_show_32bit_prop(buffer, offs, \"simd_arrays_per_engine\",\n\t\t\t      dev->node_props.simd_arrays_per_engine);\n\tsysfs_show_32bit_prop(buffer, offs, \"cu_per_simd_array\",\n\t\t\t      dev->node_props.cu_per_simd_array);\n\tsysfs_show_32bit_prop(buffer, offs, \"simd_per_cu\",\n\t\t\t      dev->node_props.simd_per_cu);\n\tsysfs_show_32bit_prop(buffer, offs, \"max_slots_scratch_cu\",\n\t\t\t      dev->node_props.max_slots_scratch_cu);\n\tsysfs_show_32bit_prop(buffer, offs, \"gfx_target_version\",\n\t\t\t      dev->node_props.gfx_target_version);\n\tsysfs_show_32bit_prop(buffer, offs, \"vendor_id\",\n\t\t\t      dev->node_props.vendor_id);\n\tsysfs_show_32bit_prop(buffer, offs, \"device_id\",\n\t\t\t      dev->node_props.device_id);\n\tsysfs_show_32bit_prop(buffer, offs, \"location_id\",\n\t\t\t      dev->node_props.location_id);\n\tsysfs_show_32bit_prop(buffer, offs, \"domain\",\n\t\t\t      dev->node_props.domain);\n\tsysfs_show_32bit_prop(buffer, offs, \"drm_render_minor\",\n\t\t\t      dev->node_props.drm_render_minor);\n\tsysfs_show_64bit_prop(buffer, offs, \"hive_id\",\n\t\t\t      dev->node_props.hive_id);\n\tsysfs_show_32bit_prop(buffer, offs, \"num_sdma_engines\",\n\t\t\t      dev->node_props.num_sdma_engines);\n\tsysfs_show_32bit_prop(buffer, offs, \"num_sdma_xgmi_engines\",\n\t\t\t      dev->node_props.num_sdma_xgmi_engines);\n\tsysfs_show_32bit_prop(buffer, offs, \"num_sdma_queues_per_engine\",\n\t\t\t      dev->node_props.num_sdma_queues_per_engine);\n\tsysfs_show_32bit_prop(buffer, offs, \"num_cp_queues\",\n\t\t\t      dev->node_props.num_cp_queues);\n\n\tif (dev->gpu) {\n\t\tlog_max_watch_addr =\n\t\t\t__ilog2_u32(dev->gpu->kfd->device_info.num_of_watch_points);\n\n\t\tif (log_max_watch_addr) {\n\t\t\tdev->node_props.capability |=\n\t\t\t\t\tHSA_CAP_WATCH_POINTS_SUPPORTED;\n\n\t\t\tdev->node_props.capability |=\n\t\t\t\t((log_max_watch_addr <<\n\t\t\t\t\tHSA_CAP_WATCH_POINTS_TOTALBITS_SHIFT) &\n\t\t\t\tHSA_CAP_WATCH_POINTS_TOTALBITS_MASK);\n\t\t}\n\n\t\tif (dev->gpu->adev->asic_type == CHIP_TONGA)\n\t\t\tdev->node_props.capability |=\n\t\t\t\t\tHSA_CAP_AQL_QUEUE_DOUBLE_MAP;\n\n\t\tsysfs_show_32bit_prop(buffer, offs, \"max_engine_clk_fcompute\",\n\t\t\tdev->node_props.max_engine_clk_fcompute);\n\n\t\tsysfs_show_64bit_prop(buffer, offs, \"local_mem_size\", 0ULL);\n\n\t\tsysfs_show_32bit_prop(buffer, offs, \"fw_version\",\n\t\t\t\t      dev->gpu->kfd->mec_fw_version);\n\t\tsysfs_show_32bit_prop(buffer, offs, \"capability\",\n\t\t\t\t      dev->node_props.capability);\n\t\tsysfs_show_64bit_prop(buffer, offs, \"debug_prop\",\n\t\t\t\t      dev->node_props.debug_prop);\n\t\tsysfs_show_32bit_prop(buffer, offs, \"sdma_fw_version\",\n\t\t\t\t      dev->gpu->kfd->sdma_fw_version);\n\t\tsysfs_show_64bit_prop(buffer, offs, \"unique_id\",\n\t\t\t\t      dev->gpu->adev->unique_id);\n\t\tsysfs_show_32bit_prop(buffer, offs, \"num_xcc\",\n\t\t\t\t      NUM_XCC(dev->gpu->xcc_mask));\n\t}\n\n\treturn sysfs_show_32bit_prop(buffer, offs, \"max_engine_clk_ccompute\",\n\t\t\t\t     cpufreq_quick_get_max(0)/1000);\n}\n\nstatic const struct sysfs_ops node_ops = {\n\t.show = node_show,\n};\n\nstatic const struct kobj_type node_type = {\n\t.release = kfd_topology_kobj_release,\n\t.sysfs_ops = &node_ops,\n};\n\nstatic void kfd_remove_sysfs_file(struct kobject *kobj, struct attribute *attr)\n{\n\tsysfs_remove_file(kobj, attr);\n\tkobject_del(kobj);\n\tkobject_put(kobj);\n}\n\nstatic void kfd_remove_sysfs_node_entry(struct kfd_topology_device *dev)\n{\n\tstruct kfd_iolink_properties *p2plink;\n\tstruct kfd_iolink_properties *iolink;\n\tstruct kfd_cache_properties *cache;\n\tstruct kfd_mem_properties *mem;\n\tstruct kfd_perf_properties *perf;\n\n\tif (dev->kobj_iolink) {\n\t\tlist_for_each_entry(iolink, &dev->io_link_props, list)\n\t\t\tif (iolink->kobj) {\n\t\t\t\tkfd_remove_sysfs_file(iolink->kobj,\n\t\t\t\t\t\t\t&iolink->attr);\n\t\t\t\tiolink->kobj = NULL;\n\t\t\t}\n\t\tkobject_del(dev->kobj_iolink);\n\t\tkobject_put(dev->kobj_iolink);\n\t\tdev->kobj_iolink = NULL;\n\t}\n\n\tif (dev->kobj_p2plink) {\n\t\tlist_for_each_entry(p2plink, &dev->p2p_link_props, list)\n\t\t\tif (p2plink->kobj) {\n\t\t\t\tkfd_remove_sysfs_file(p2plink->kobj,\n\t\t\t\t\t\t\t&p2plink->attr);\n\t\t\t\tp2plink->kobj = NULL;\n\t\t\t}\n\t\tkobject_del(dev->kobj_p2plink);\n\t\tkobject_put(dev->kobj_p2plink);\n\t\tdev->kobj_p2plink = NULL;\n\t}\n\n\tif (dev->kobj_cache) {\n\t\tlist_for_each_entry(cache, &dev->cache_props, list)\n\t\t\tif (cache->kobj) {\n\t\t\t\tkfd_remove_sysfs_file(cache->kobj,\n\t\t\t\t\t\t\t&cache->attr);\n\t\t\t\tcache->kobj = NULL;\n\t\t\t}\n\t\tkobject_del(dev->kobj_cache);\n\t\tkobject_put(dev->kobj_cache);\n\t\tdev->kobj_cache = NULL;\n\t}\n\n\tif (dev->kobj_mem) {\n\t\tlist_for_each_entry(mem, &dev->mem_props, list)\n\t\t\tif (mem->kobj) {\n\t\t\t\tkfd_remove_sysfs_file(mem->kobj, &mem->attr);\n\t\t\t\tmem->kobj = NULL;\n\t\t\t}\n\t\tkobject_del(dev->kobj_mem);\n\t\tkobject_put(dev->kobj_mem);\n\t\tdev->kobj_mem = NULL;\n\t}\n\n\tif (dev->kobj_perf) {\n\t\tlist_for_each_entry(perf, &dev->perf_props, list) {\n\t\t\tkfree(perf->attr_group);\n\t\t\tperf->attr_group = NULL;\n\t\t}\n\t\tkobject_del(dev->kobj_perf);\n\t\tkobject_put(dev->kobj_perf);\n\t\tdev->kobj_perf = NULL;\n\t}\n\n\tif (dev->kobj_node) {\n\t\tsysfs_remove_file(dev->kobj_node, &dev->attr_gpuid);\n\t\tsysfs_remove_file(dev->kobj_node, &dev->attr_name);\n\t\tsysfs_remove_file(dev->kobj_node, &dev->attr_props);\n\t\tkobject_del(dev->kobj_node);\n\t\tkobject_put(dev->kobj_node);\n\t\tdev->kobj_node = NULL;\n\t}\n}\n\nstatic int kfd_build_sysfs_node_entry(struct kfd_topology_device *dev,\n\t\tuint32_t id)\n{\n\tstruct kfd_iolink_properties *p2plink;\n\tstruct kfd_iolink_properties *iolink;\n\tstruct kfd_cache_properties *cache;\n\tstruct kfd_mem_properties *mem;\n\tstruct kfd_perf_properties *perf;\n\tint ret;\n\tuint32_t i, num_attrs;\n\tstruct attribute **attrs;\n\n\tif (WARN_ON(dev->kobj_node))\n\t\treturn -EEXIST;\n\n\t \n\tdev->kobj_node = kfd_alloc_struct(dev->kobj_node);\n\tif (!dev->kobj_node)\n\t\treturn -ENOMEM;\n\n\tret = kobject_init_and_add(dev->kobj_node, &node_type,\n\t\t\tsys_props.kobj_nodes, \"%d\", id);\n\tif (ret < 0) {\n\t\tkobject_put(dev->kobj_node);\n\t\treturn ret;\n\t}\n\n\tdev->kobj_mem = kobject_create_and_add(\"mem_banks\", dev->kobj_node);\n\tif (!dev->kobj_mem)\n\t\treturn -ENOMEM;\n\n\tdev->kobj_cache = kobject_create_and_add(\"caches\", dev->kobj_node);\n\tif (!dev->kobj_cache)\n\t\treturn -ENOMEM;\n\n\tdev->kobj_iolink = kobject_create_and_add(\"io_links\", dev->kobj_node);\n\tif (!dev->kobj_iolink)\n\t\treturn -ENOMEM;\n\n\tdev->kobj_p2plink = kobject_create_and_add(\"p2p_links\", dev->kobj_node);\n\tif (!dev->kobj_p2plink)\n\t\treturn -ENOMEM;\n\n\tdev->kobj_perf = kobject_create_and_add(\"perf\", dev->kobj_node);\n\tif (!dev->kobj_perf)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->attr_gpuid.name = \"gpu_id\";\n\tdev->attr_gpuid.mode = KFD_SYSFS_FILE_MODE;\n\tsysfs_attr_init(&dev->attr_gpuid);\n\tdev->attr_name.name = \"name\";\n\tdev->attr_name.mode = KFD_SYSFS_FILE_MODE;\n\tsysfs_attr_init(&dev->attr_name);\n\tdev->attr_props.name = \"properties\";\n\tdev->attr_props.mode = KFD_SYSFS_FILE_MODE;\n\tsysfs_attr_init(&dev->attr_props);\n\tret = sysfs_create_file(dev->kobj_node, &dev->attr_gpuid);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sysfs_create_file(dev->kobj_node, &dev->attr_name);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sysfs_create_file(dev->kobj_node, &dev->attr_props);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti = 0;\n\tlist_for_each_entry(mem, &dev->mem_props, list) {\n\t\tmem->kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\t\tif (!mem->kobj)\n\t\t\treturn -ENOMEM;\n\t\tret = kobject_init_and_add(mem->kobj, &mem_type,\n\t\t\t\tdev->kobj_mem, \"%d\", i);\n\t\tif (ret < 0) {\n\t\t\tkobject_put(mem->kobj);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmem->attr.name = \"properties\";\n\t\tmem->attr.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&mem->attr);\n\t\tret = sysfs_create_file(mem->kobj, &mem->attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(cache, &dev->cache_props, list) {\n\t\tcache->kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\t\tif (!cache->kobj)\n\t\t\treturn -ENOMEM;\n\t\tret = kobject_init_and_add(cache->kobj, &cache_type,\n\t\t\t\tdev->kobj_cache, \"%d\", i);\n\t\tif (ret < 0) {\n\t\t\tkobject_put(cache->kobj);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcache->attr.name = \"properties\";\n\t\tcache->attr.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&cache->attr);\n\t\tret = sysfs_create_file(cache->kobj, &cache->attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(iolink, &dev->io_link_props, list) {\n\t\tiolink->kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\t\tif (!iolink->kobj)\n\t\t\treturn -ENOMEM;\n\t\tret = kobject_init_and_add(iolink->kobj, &iolink_type,\n\t\t\t\tdev->kobj_iolink, \"%d\", i);\n\t\tif (ret < 0) {\n\t\t\tkobject_put(iolink->kobj);\n\t\t\treturn ret;\n\t\t}\n\n\t\tiolink->attr.name = \"properties\";\n\t\tiolink->attr.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&iolink->attr);\n\t\tret = sysfs_create_file(iolink->kobj, &iolink->attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(p2plink, &dev->p2p_link_props, list) {\n\t\tp2plink->kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\t\tif (!p2plink->kobj)\n\t\t\treturn -ENOMEM;\n\t\tret = kobject_init_and_add(p2plink->kobj, &iolink_type,\n\t\t\t\tdev->kobj_p2plink, \"%d\", i);\n\t\tif (ret < 0) {\n\t\t\tkobject_put(p2plink->kobj);\n\t\t\treturn ret;\n\t\t}\n\n\t\tp2plink->attr.name = \"properties\";\n\t\tp2plink->attr.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&p2plink->attr);\n\t\tret = sysfs_create_file(p2plink->kobj, &p2plink->attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\t \n\tnum_attrs = ARRAY_SIZE(perf_attr_iommu);\n\tlist_for_each_entry(perf, &dev->perf_props, list) {\n\t\tperf->attr_group = kzalloc(sizeof(struct kfd_perf_attr)\n\t\t\t* num_attrs + sizeof(struct attribute_group),\n\t\t\tGFP_KERNEL);\n\t\tif (!perf->attr_group)\n\t\t\treturn -ENOMEM;\n\n\t\tattrs = (struct attribute **)(perf->attr_group + 1);\n\t\tif (!strcmp(perf->block_name, \"iommu\")) {\n\t\t \n\t\t\tperf_attr_iommu[0].data = perf->max_concurrent;\n\t\t\tfor (i = 0; i < num_attrs; i++)\n\t\t\t\tattrs[i] = &perf_attr_iommu[i].attr.attr;\n\t\t}\n\t\tperf->attr_group->name = perf->block_name;\n\t\tperf->attr_group->attrs = attrs;\n\t\tret = sysfs_create_group(dev->kobj_perf, perf->attr_group);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kfd_build_sysfs_node_tree(void)\n{\n\tstruct kfd_topology_device *dev;\n\tint ret;\n\tuint32_t i = 0;\n\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\tret = kfd_build_sysfs_node_entry(dev, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void kfd_remove_sysfs_node_tree(void)\n{\n\tstruct kfd_topology_device *dev;\n\n\tlist_for_each_entry(dev, &topology_device_list, list)\n\t\tkfd_remove_sysfs_node_entry(dev);\n}\n\nstatic int kfd_topology_update_sysfs(void)\n{\n\tint ret;\n\n\tif (!sys_props.kobj_topology) {\n\t\tsys_props.kobj_topology =\n\t\t\t\tkfd_alloc_struct(sys_props.kobj_topology);\n\t\tif (!sys_props.kobj_topology)\n\t\t\treturn -ENOMEM;\n\n\t\tret = kobject_init_and_add(sys_props.kobj_topology,\n\t\t\t\t&sysprops_type,  &kfd_device->kobj,\n\t\t\t\t\"topology\");\n\t\tif (ret < 0) {\n\t\t\tkobject_put(sys_props.kobj_topology);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsys_props.kobj_nodes = kobject_create_and_add(\"nodes\",\n\t\t\t\tsys_props.kobj_topology);\n\t\tif (!sys_props.kobj_nodes)\n\t\t\treturn -ENOMEM;\n\n\t\tsys_props.attr_genid.name = \"generation_id\";\n\t\tsys_props.attr_genid.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&sys_props.attr_genid);\n\t\tret = sysfs_create_file(sys_props.kobj_topology,\n\t\t\t\t&sys_props.attr_genid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsys_props.attr_props.name = \"system_properties\";\n\t\tsys_props.attr_props.mode = KFD_SYSFS_FILE_MODE;\n\t\tsysfs_attr_init(&sys_props.attr_props);\n\t\tret = sysfs_create_file(sys_props.kobj_topology,\n\t\t\t\t&sys_props.attr_props);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tkfd_remove_sysfs_node_tree();\n\n\treturn kfd_build_sysfs_node_tree();\n}\n\nstatic void kfd_topology_release_sysfs(void)\n{\n\tkfd_remove_sysfs_node_tree();\n\tif (sys_props.kobj_topology) {\n\t\tsysfs_remove_file(sys_props.kobj_topology,\n\t\t\t\t&sys_props.attr_genid);\n\t\tsysfs_remove_file(sys_props.kobj_topology,\n\t\t\t\t&sys_props.attr_props);\n\t\tif (sys_props.kobj_nodes) {\n\t\t\tkobject_del(sys_props.kobj_nodes);\n\t\t\tkobject_put(sys_props.kobj_nodes);\n\t\t\tsys_props.kobj_nodes = NULL;\n\t\t}\n\t\tkobject_del(sys_props.kobj_topology);\n\t\tkobject_put(sys_props.kobj_topology);\n\t\tsys_props.kobj_topology = NULL;\n\t}\n}\n\n \nstatic void kfd_topology_update_device_list(struct list_head *temp_list,\n\t\t\t\t\tstruct list_head *master_list)\n{\n\twhile (!list_empty(temp_list)) {\n\t\tlist_move_tail(temp_list->next, master_list);\n\t\tsys_props.num_devices++;\n\t}\n}\n\nstatic void kfd_debug_print_topology(void)\n{\n\tstruct kfd_topology_device *dev;\n\n\tdown_read(&topology_lock);\n\n\tdev = list_last_entry(&topology_device_list,\n\t\t\tstruct kfd_topology_device, list);\n\tif (dev) {\n\t\tif (dev->node_props.cpu_cores_count &&\n\t\t\t\tdev->node_props.simd_count) {\n\t\t\tpr_info(\"Topology: Add APU node [0x%0x:0x%0x]\\n\",\n\t\t\t\tdev->node_props.device_id,\n\t\t\t\tdev->node_props.vendor_id);\n\t\t} else if (dev->node_props.cpu_cores_count)\n\t\t\tpr_info(\"Topology: Add CPU node\\n\");\n\t\telse if (dev->node_props.simd_count)\n\t\t\tpr_info(\"Topology: Add dGPU node [0x%0x:0x%0x]\\n\",\n\t\t\t\tdev->node_props.device_id,\n\t\t\t\tdev->node_props.vendor_id);\n\t}\n\tup_read(&topology_lock);\n}\n\n \nstatic void kfd_update_system_properties(void)\n{\n\tstruct kfd_topology_device *dev;\n\n\tdown_read(&topology_lock);\n\tdev = list_last_entry(&topology_device_list,\n\t\t\tstruct kfd_topology_device, list);\n\tif (dev) {\n\t\tsys_props.platform_id =\n\t\t\t(*((uint64_t *)dev->oem_id)) & CRAT_OEMID_64BIT_MASK;\n\t\tsys_props.platform_oem = *((uint64_t *)dev->oem_table_id);\n\t\tsys_props.platform_rev = dev->oem_revision;\n\t}\n\tup_read(&topology_lock);\n}\n\nstatic void find_system_memory(const struct dmi_header *dm,\n\tvoid *private)\n{\n\tstruct kfd_mem_properties *mem;\n\tu16 mem_width, mem_clock;\n\tstruct kfd_topology_device *kdev =\n\t\t(struct kfd_topology_device *)private;\n\tconst u8 *dmi_data = (const u8 *)(dm + 1);\n\n\tif (dm->type == DMI_ENTRY_MEM_DEVICE && dm->length >= 0x15) {\n\t\tmem_width = (u16)(*(const u16 *)(dmi_data + 0x6));\n\t\tmem_clock = (u16)(*(const u16 *)(dmi_data + 0x11));\n\t\tlist_for_each_entry(mem, &kdev->mem_props, list) {\n\t\t\tif (mem_width != 0xFFFF && mem_width != 0)\n\t\t\t\tmem->width = mem_width;\n\t\t\tif (mem_clock != 0)\n\t\t\t\tmem->mem_clk_max = mem_clock;\n\t\t}\n\t}\n}\n\n \nstatic void kfd_add_non_crat_information(struct kfd_topology_device *kdev)\n{\n\t \n\tif (!kdev->gpu) {\n\t\t \n\t\tdmi_walk(find_system_memory, kdev);\n\t}\n\t \n}\n\nint kfd_topology_init(void)\n{\n\tvoid *crat_image = NULL;\n\tsize_t image_size = 0;\n\tint ret;\n\tstruct list_head temp_topology_device_list;\n\tint cpu_only_node = 0;\n\tstruct kfd_topology_device *kdev;\n\tint proximity_domain;\n\n\t \n\n\t \n\tINIT_LIST_HEAD(&topology_device_list);\n\tINIT_LIST_HEAD(&temp_topology_device_list);\n\tinit_rwsem(&topology_lock);\n\n\tmemset(&sys_props, 0, sizeof(sys_props));\n\n\t \n\tproximity_domain = 0;\n\n\tret = kfd_create_crat_image_virtual(&crat_image, &image_size,\n\t\t\t\t\t    COMPUTE_UNIT_CPU, NULL,\n\t\t\t\t\t    proximity_domain);\n\tcpu_only_node = 1;\n\tif (ret) {\n\t\tpr_err(\"Error creating VCRAT table for CPU\\n\");\n\t\treturn ret;\n\t}\n\n\tret = kfd_parse_crat_table(crat_image,\n\t\t\t\t   &temp_topology_device_list,\n\t\t\t\t   proximity_domain);\n\tif (ret) {\n\t\tpr_err(\"Error parsing VCRAT table for CPU\\n\");\n\t\tgoto err;\n\t}\n\n\tkdev = list_first_entry(&temp_topology_device_list,\n\t\t\t\tstruct kfd_topology_device, list);\n\n\tdown_write(&topology_lock);\n\tkfd_topology_update_device_list(&temp_topology_device_list,\n\t\t\t\t\t&topology_device_list);\n\ttopology_crat_proximity_domain = sys_props.num_devices-1;\n\tret = kfd_topology_update_sysfs();\n\tup_write(&topology_lock);\n\n\tif (!ret) {\n\t\tsys_props.generation_count++;\n\t\tkfd_update_system_properties();\n\t\tkfd_debug_print_topology();\n\t} else\n\t\tpr_err(\"Failed to update topology in sysfs ret=%d\\n\", ret);\n\n\t \n\tif (cpu_only_node) {\n\t\t \n\t\tdown_write(&topology_lock);\n\t\tkdev = list_first_entry(&topology_device_list,\n\t\t\t\tstruct kfd_topology_device, list);\n\t\tup_write(&topology_lock);\n\t\tkfd_add_non_crat_information(kdev);\n\t}\n\nerr:\n\tkfd_destroy_crat_image(crat_image);\n\treturn ret;\n}\n\nvoid kfd_topology_shutdown(void)\n{\n\tdown_write(&topology_lock);\n\tkfd_topology_release_sysfs();\n\tkfd_release_live_view();\n\tup_write(&topology_lock);\n}\n\nstatic uint32_t kfd_generate_gpu_id(struct kfd_node *gpu)\n{\n\tuint32_t hashout;\n\tuint32_t buf[8];\n\tuint64_t local_mem_size;\n\tint i;\n\n\tif (!gpu)\n\t\treturn 0;\n\n\tlocal_mem_size = gpu->local_mem_info.local_mem_size_private +\n\t\t\tgpu->local_mem_info.local_mem_size_public;\n\tbuf[0] = gpu->adev->pdev->devfn;\n\tbuf[1] = gpu->adev->pdev->subsystem_vendor |\n\t\t(gpu->adev->pdev->subsystem_device << 16);\n\tbuf[2] = pci_domain_nr(gpu->adev->pdev->bus);\n\tbuf[3] = gpu->adev->pdev->device;\n\tbuf[4] = gpu->adev->pdev->bus->number;\n\tbuf[5] = lower_32_bits(local_mem_size);\n\tbuf[6] = upper_32_bits(local_mem_size);\n\tbuf[7] = (ffs(gpu->xcc_mask) - 1) | (NUM_XCC(gpu->xcc_mask) << 16);\n\n\tfor (i = 0, hashout = 0; i < 8; i++)\n\t\thashout ^= hash_32(buf[i], KFD_GPU_ID_HASH_WIDTH);\n\n\treturn hashout;\n}\n \nstatic struct kfd_topology_device *kfd_assign_gpu(struct kfd_node *gpu)\n{\n\tstruct kfd_topology_device *dev;\n\tstruct kfd_topology_device *out_dev = NULL;\n\tstruct kfd_mem_properties *mem;\n\tstruct kfd_cache_properties *cache;\n\tstruct kfd_iolink_properties *iolink;\n\tstruct kfd_iolink_properties *p2plink;\n\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\t \n\t\tif (dev->node_props.cpu_cores_count)\n\t\t\tcontinue;\n\n\t\tif (!dev->gpu && (dev->node_props.simd_count > 0)) {\n\t\t\tdev->gpu = gpu;\n\t\t\tout_dev = dev;\n\n\t\t\tlist_for_each_entry(mem, &dev->mem_props, list)\n\t\t\t\tmem->gpu = dev->gpu;\n\t\t\tlist_for_each_entry(cache, &dev->cache_props, list)\n\t\t\t\tcache->gpu = dev->gpu;\n\t\t\tlist_for_each_entry(iolink, &dev->io_link_props, list)\n\t\t\t\tiolink->gpu = dev->gpu;\n\t\t\tlist_for_each_entry(p2plink, &dev->p2p_link_props, list)\n\t\t\t\tp2plink->gpu = dev->gpu;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out_dev;\n}\n\nstatic void kfd_notify_gpu_change(uint32_t gpu_id, int arrival)\n{\n\t \n}\n\n \nstatic void kfd_fill_mem_clk_max_info(struct kfd_topology_device *dev)\n{\n\tstruct kfd_mem_properties *mem;\n\tstruct kfd_local_mem_info local_mem_info;\n\n\tif (!dev)\n\t\treturn;\n\n\t \n\tamdgpu_amdkfd_get_local_mem_info(dev->gpu->adev, &local_mem_info,\n\t\t\t\t\t dev->gpu->xcp);\n\n\tlist_for_each_entry(mem, &dev->mem_props, list)\n\t\tmem->mem_clk_max = local_mem_info.mem_clk_max;\n}\n\nstatic void kfd_set_iolink_no_atomics(struct kfd_topology_device *dev,\n\t\t\t\t\tstruct kfd_topology_device *target_gpu_dev,\n\t\t\t\t\tstruct kfd_iolink_properties *link)\n{\n\t \n\tif (link->iolink_type == CRAT_IOLINK_TYPE_XGMI)\n\t\treturn;\n\n\t \n\tif (target_gpu_dev) {\n\t\tuint32_t cap;\n\n\t\tpcie_capability_read_dword(target_gpu_dev->gpu->adev->pdev,\n\t\t\t\tPCI_EXP_DEVCAP2, &cap);\n\n\t\tif (!(cap & (PCI_EXP_DEVCAP2_ATOMIC_COMP32 |\n\t\t\t     PCI_EXP_DEVCAP2_ATOMIC_COMP64)))\n\t\t\tlink->flags |= CRAT_IOLINK_FLAGS_NO_ATOMICS_32_BIT |\n\t\t\t\tCRAT_IOLINK_FLAGS_NO_ATOMICS_64_BIT;\n\t \n\t} else {\n\t\tif (!dev->gpu->kfd->pci_atomic_requested ||\n\t\t\t\tdev->gpu->adev->asic_type == CHIP_HAWAII)\n\t\t\tlink->flags |= CRAT_IOLINK_FLAGS_NO_ATOMICS_32_BIT |\n\t\t\t\tCRAT_IOLINK_FLAGS_NO_ATOMICS_64_BIT;\n\t}\n}\n\nstatic void kfd_set_iolink_non_coherent(struct kfd_topology_device *to_dev,\n\t\tstruct kfd_iolink_properties *outbound_link,\n\t\tstruct kfd_iolink_properties *inbound_link)\n{\n\t \n\tif (!to_dev->gpu &&\n\t    inbound_link->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)\n\t\tinbound_link->flags |= CRAT_IOLINK_FLAGS_NON_COHERENT;\n\n\tif (to_dev->gpu) {\n\t\t \n\t\tif (inbound_link->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS ||\n\t\t    (inbound_link->iolink_type == CRAT_IOLINK_TYPE_XGMI &&\n\t\t    KFD_GC_VERSION(to_dev->gpu) == IP_VERSION(9, 4, 0))) {\n\t\t\toutbound_link->flags |= CRAT_IOLINK_FLAGS_NON_COHERENT;\n\t\t\tinbound_link->flags |= CRAT_IOLINK_FLAGS_NON_COHERENT;\n\t\t}\n\t}\n}\n\nstatic void kfd_fill_iolink_non_crat_info(struct kfd_topology_device *dev)\n{\n\tstruct kfd_iolink_properties *link, *inbound_link;\n\tstruct kfd_topology_device *peer_dev;\n\n\tif (!dev || !dev->gpu)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(link, &dev->io_link_props, list) {\n\t\tlink->flags = CRAT_IOLINK_FLAGS_ENABLED;\n\t\tkfd_set_iolink_no_atomics(dev, NULL, link);\n\t\tpeer_dev = kfd_topology_device_by_proximity_domain(\n\t\t\t\tlink->node_to);\n\n\t\tif (!peer_dev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!peer_dev->gpu &&\n\t\t    link->iolink_type == CRAT_IOLINK_TYPE_XGMI) {\n\t\t\t \n\t\t\tif (!dev->node_props.hive_id)\n\t\t\t\tdev->node_props.hive_id = pci_dev_id(dev->gpu->adev->pdev);\n\t\t\tpeer_dev->node_props.hive_id = dev->node_props.hive_id;\n\t\t}\n\n\t\tlist_for_each_entry(inbound_link, &peer_dev->io_link_props,\n\t\t\t\t\t\t\t\t\tlist) {\n\t\t\tif (inbound_link->node_to != link->node_from)\n\t\t\t\tcontinue;\n\n\t\t\tinbound_link->flags = CRAT_IOLINK_FLAGS_ENABLED;\n\t\t\tkfd_set_iolink_no_atomics(peer_dev, dev, inbound_link);\n\t\t\tkfd_set_iolink_non_coherent(peer_dev, link, inbound_link);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(link, &dev->p2p_link_props, list) {\n\t\tlink->flags = CRAT_IOLINK_FLAGS_ENABLED;\n\t\tkfd_set_iolink_no_atomics(dev, NULL, link);\n\t\tpeer_dev = kfd_topology_device_by_proximity_domain(\n\t\t\t\tlink->node_to);\n\n\t\tif (!peer_dev)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(inbound_link, &peer_dev->p2p_link_props,\n\t\t\t\t\t\t\t\t\tlist) {\n\t\t\tif (inbound_link->node_to != link->node_from)\n\t\t\t\tcontinue;\n\n\t\t\tinbound_link->flags = CRAT_IOLINK_FLAGS_ENABLED;\n\t\t\tkfd_set_iolink_no_atomics(peer_dev, dev, inbound_link);\n\t\t\tkfd_set_iolink_non_coherent(peer_dev, link, inbound_link);\n\t\t}\n\t}\n}\n\nstatic int kfd_build_p2p_node_entry(struct kfd_topology_device *dev,\n\t\t\t\tstruct kfd_iolink_properties *p2plink)\n{\n\tint ret;\n\n\tp2plink->kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\tif (!p2plink->kobj)\n\t\treturn -ENOMEM;\n\n\tret = kobject_init_and_add(p2plink->kobj, &iolink_type,\n\t\t\tdev->kobj_p2plink, \"%d\", dev->node_props.p2p_links_count - 1);\n\tif (ret < 0) {\n\t\tkobject_put(p2plink->kobj);\n\t\treturn ret;\n\t}\n\n\tp2plink->attr.name = \"properties\";\n\tp2plink->attr.mode = KFD_SYSFS_FILE_MODE;\n\tsysfs_attr_init(&p2plink->attr);\n\tret = sysfs_create_file(p2plink->kobj, &p2plink->attr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int kfd_create_indirect_link_prop(struct kfd_topology_device *kdev, int gpu_node)\n{\n\tstruct kfd_iolink_properties *gpu_link, *tmp_link, *cpu_link;\n\tstruct kfd_iolink_properties *props = NULL, *props2 = NULL;\n\tstruct kfd_topology_device *cpu_dev;\n\tint ret = 0;\n\tint i, num_cpu;\n\n\tnum_cpu = 0;\n\tlist_for_each_entry(cpu_dev, &topology_device_list, list) {\n\t\tif (cpu_dev->gpu)\n\t\t\tbreak;\n\t\tnum_cpu++;\n\t}\n\n\tif (list_empty(&kdev->io_link_props))\n\t\treturn -ENODATA;\n\n\tgpu_link = list_first_entry(&kdev->io_link_props,\n\t\t\t\t    struct kfd_iolink_properties, list);\n\n\tfor (i = 0; i < num_cpu; i++) {\n\t\t \n\t\tif (gpu_link->node_to == i)\n\t\t\tcontinue;\n\n\t\t \n\t\tcpu_link = NULL;\n\t\tcpu_dev = kfd_topology_device_by_proximity_domain(i);\n\t\tif (cpu_dev) {\n\t\t\tlist_for_each_entry(tmp_link,\n\t\t\t\t\t&cpu_dev->io_link_props, list) {\n\t\t\t\tif (tmp_link->node_to == gpu_link->node_to) {\n\t\t\t\t\tcpu_link = tmp_link;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!cpu_link)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tprops = kfd_alloc_struct(props);\n\t\tif (!props)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(props, gpu_link, sizeof(struct kfd_iolink_properties));\n\t\tprops->weight = gpu_link->weight + cpu_link->weight;\n\t\tprops->min_latency = gpu_link->min_latency + cpu_link->min_latency;\n\t\tprops->max_latency = gpu_link->max_latency + cpu_link->max_latency;\n\t\tprops->min_bandwidth = min(gpu_link->min_bandwidth, cpu_link->min_bandwidth);\n\t\tprops->max_bandwidth = min(gpu_link->max_bandwidth, cpu_link->max_bandwidth);\n\n\t\tprops->node_from = gpu_node;\n\t\tprops->node_to = i;\n\t\tkdev->node_props.p2p_links_count++;\n\t\tlist_add_tail(&props->list, &kdev->p2p_link_props);\n\t\tret = kfd_build_p2p_node_entry(kdev, props);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (kfd_dev_is_large_bar(kdev->gpu)) {\n\t\t\t \n\t\t\tprops2 = kfd_alloc_struct(props2);\n\t\t\tif (!props2)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(props2, props, sizeof(struct kfd_iolink_properties));\n\t\t\tprops2->node_from = i;\n\t\t\tprops2->node_to = gpu_node;\n\t\t\tprops2->kobj = NULL;\n\t\t\tcpu_dev->node_props.p2p_links_count++;\n\t\t\tlist_add_tail(&props2->list, &cpu_dev->p2p_link_props);\n\t\t\tret = kfd_build_p2p_node_entry(cpu_dev, props2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n#if defined(CONFIG_HSA_AMD_P2P)\nstatic int kfd_add_peer_prop(struct kfd_topology_device *kdev,\n\t\tstruct kfd_topology_device *peer, int from, int to)\n{\n\tstruct kfd_iolink_properties *props = NULL;\n\tstruct kfd_iolink_properties *iolink1, *iolink2, *iolink3;\n\tstruct kfd_topology_device *cpu_dev;\n\tint ret = 0;\n\n\tif (!amdgpu_device_is_peer_accessible(\n\t\t\t\tkdev->gpu->adev,\n\t\t\t\tpeer->gpu->adev))\n\t\treturn ret;\n\n\tif (list_empty(&kdev->io_link_props))\n\t\treturn -ENODATA;\n\n\tiolink1 = list_first_entry(&kdev->io_link_props,\n\t\t\t\t   struct kfd_iolink_properties, list);\n\n\tif (list_empty(&peer->io_link_props))\n\t\treturn -ENODATA;\n\n\tiolink2 = list_first_entry(&peer->io_link_props,\n\t\t\t\t   struct kfd_iolink_properties, list);\n\n\tprops = kfd_alloc_struct(props);\n\tif (!props)\n\t\treturn -ENOMEM;\n\n\tmemcpy(props, iolink1, sizeof(struct kfd_iolink_properties));\n\n\tprops->weight = iolink1->weight + iolink2->weight;\n\tprops->min_latency = iolink1->min_latency + iolink2->min_latency;\n\tprops->max_latency = iolink1->max_latency + iolink2->max_latency;\n\tprops->min_bandwidth = min(iolink1->min_bandwidth, iolink2->min_bandwidth);\n\tprops->max_bandwidth = min(iolink2->max_bandwidth, iolink2->max_bandwidth);\n\n\tif (iolink1->node_to != iolink2->node_to) {\n\t\t \n\t\tcpu_dev = kfd_topology_device_by_proximity_domain(iolink1->node_to);\n\t\tif (cpu_dev) {\n\t\t\tlist_for_each_entry(iolink3, &cpu_dev->io_link_props, list)\n\t\t\t\tif (iolink3->node_to == iolink2->node_to)\n\t\t\t\t\tbreak;\n\n\t\t\tprops->weight += iolink3->weight;\n\t\t\tprops->min_latency += iolink3->min_latency;\n\t\t\tprops->max_latency += iolink3->max_latency;\n\t\t\tprops->min_bandwidth = min(props->min_bandwidth,\n\t\t\t\t\t\t\tiolink3->min_bandwidth);\n\t\t\tprops->max_bandwidth = min(props->max_bandwidth,\n\t\t\t\t\t\t\tiolink3->max_bandwidth);\n\t\t} else {\n\t\t\tWARN(1, \"CPU node not found\");\n\t\t}\n\t}\n\n\tprops->node_from = from;\n\tprops->node_to = to;\n\tpeer->node_props.p2p_links_count++;\n\tlist_add_tail(&props->list, &peer->p2p_link_props);\n\tret = kfd_build_p2p_node_entry(peer, props);\n\n\treturn ret;\n}\n#endif\n\nstatic int kfd_dev_create_p2p_links(void)\n{\n\tstruct kfd_topology_device *dev;\n\tstruct kfd_topology_device *new_dev;\n#if defined(CONFIG_HSA_AMD_P2P)\n\tuint32_t i;\n#endif\n\tuint32_t k;\n\tint ret = 0;\n\n\tk = 0;\n\tlist_for_each_entry(dev, &topology_device_list, list)\n\t\tk++;\n\tif (k < 2)\n\t\treturn 0;\n\n\tnew_dev = list_last_entry(&topology_device_list, struct kfd_topology_device, list);\n\tif (WARN_ON(!new_dev->gpu))\n\t\treturn 0;\n\n\tk--;\n\n\t \n\tret = kfd_create_indirect_link_prop(new_dev, k);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n#if defined(CONFIG_HSA_AMD_P2P)\n\ti = 0;\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\tif (dev == new_dev)\n\t\t\tbreak;\n\t\tif (!dev->gpu || !dev->gpu->adev ||\n\t\t    (dev->gpu->kfd->hive_id &&\n\t\t     dev->gpu->kfd->hive_id == new_dev->gpu->kfd->hive_id))\n\t\t\tgoto next;\n\n\t\t \n\t\tret = kfd_add_peer_prop(new_dev, dev, i, k);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = kfd_add_peer_prop(dev, new_dev, k, i);\n\t\tif (ret < 0)\n\t\t\tgoto out;\nnext:\n\t\ti++;\n\t}\n#endif\n\nout:\n\treturn ret;\n}\n\n \nstatic int fill_in_l1_pcache(struct kfd_cache_properties **props_ext,\n\t\t\t\tstruct kfd_gpu_cache_info *pcache_info,\n\t\t\t\tstruct kfd_cu_info *cu_info,\n\t\t\t\tint cu_bitmask,\n\t\t\t\tint cache_type, unsigned int cu_processor_id,\n\t\t\t\tint cu_block)\n{\n\tunsigned int cu_sibling_map_mask;\n\tint first_active_cu;\n\tstruct kfd_cache_properties *pcache = NULL;\n\n\tcu_sibling_map_mask = cu_bitmask;\n\tcu_sibling_map_mask >>= cu_block;\n\tcu_sibling_map_mask &= ((1 << pcache_info[cache_type].num_cu_shared) - 1);\n\tfirst_active_cu = ffs(cu_sibling_map_mask);\n\n\t \n\tif (first_active_cu) {\n\t\tpcache = kfd_alloc_struct(pcache);\n\t\tif (!pcache)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(pcache, 0, sizeof(struct kfd_cache_properties));\n\t\tpcache->processor_id_low = cu_processor_id + (first_active_cu - 1);\n\t\tpcache->cache_level = pcache_info[cache_type].cache_level;\n\t\tpcache->cache_size = pcache_info[cache_type].cache_size;\n\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_DATA_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_DATA;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_INST_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_INSTRUCTION;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_CPU_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_CPU;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_SIMD_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_HSACU;\n\n\t\t \n\t\tcu_sibling_map_mask =\n\t\t\tcu_sibling_map_mask >> (first_active_cu - 1);\n\n\t\tpcache->sibling_map[0] = (uint8_t)(cu_sibling_map_mask & 0xFF);\n\t\tpcache->sibling_map[1] =\n\t\t\t\t(uint8_t)((cu_sibling_map_mask >> 8) & 0xFF);\n\t\tpcache->sibling_map[2] =\n\t\t\t\t(uint8_t)((cu_sibling_map_mask >> 16) & 0xFF);\n\t\tpcache->sibling_map[3] =\n\t\t\t\t(uint8_t)((cu_sibling_map_mask >> 24) & 0xFF);\n\n\t\tpcache->sibling_map_size = 4;\n\t\t*props_ext = pcache;\n\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int fill_in_l2_l3_pcache(struct kfd_cache_properties **props_ext,\n\t\t\t\tstruct kfd_gpu_cache_info *pcache_info,\n\t\t\t\tstruct kfd_cu_info *cu_info,\n\t\t\t\tint cache_type, unsigned int cu_processor_id,\n\t\t\t\tstruct kfd_node *knode)\n{\n\tunsigned int cu_sibling_map_mask;\n\tint first_active_cu;\n\tint i, j, k, xcc, start, end;\n\tstruct kfd_cache_properties *pcache = NULL;\n\n\tstart = ffs(knode->xcc_mask) - 1;\n\tend = start + NUM_XCC(knode->xcc_mask);\n\tcu_sibling_map_mask = cu_info->cu_bitmap[start][0][0];\n\tcu_sibling_map_mask &=\n\t\t((1 << pcache_info[cache_type].num_cu_shared) - 1);\n\tfirst_active_cu = ffs(cu_sibling_map_mask);\n\n\t \n\tif (first_active_cu) {\n\t\tpcache = kfd_alloc_struct(pcache);\n\t\tif (!pcache)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(pcache, 0, sizeof(struct kfd_cache_properties));\n\t\tpcache->processor_id_low = cu_processor_id\n\t\t\t\t\t+ (first_active_cu - 1);\n\t\tpcache->cache_level = pcache_info[cache_type].cache_level;\n\t\tpcache->cache_size = pcache_info[cache_type].cache_size;\n\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_DATA_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_DATA;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_INST_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_INSTRUCTION;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_CPU_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_CPU;\n\t\tif (pcache_info[cache_type].flags & CRAT_CACHE_FLAGS_SIMD_CACHE)\n\t\t\tpcache->cache_type |= HSA_CACHE_TYPE_HSACU;\n\n\t\t \n\t\tcu_sibling_map_mask = cu_sibling_map_mask >> (first_active_cu - 1);\n\t\tk = 0;\n\n\t\tfor (xcc = start; xcc < end; xcc++) {\n\t\t\tfor (i = 0; i < cu_info->num_shader_engines; i++) {\n\t\t\t\tfor (j = 0; j < cu_info->num_shader_arrays_per_engine; j++) {\n\t\t\t\t\tpcache->sibling_map[k] = (uint8_t)(cu_sibling_map_mask & 0xFF);\n\t\t\t\t\tpcache->sibling_map[k+1] = (uint8_t)((cu_sibling_map_mask >> 8) & 0xFF);\n\t\t\t\t\tpcache->sibling_map[k+2] = (uint8_t)((cu_sibling_map_mask >> 16) & 0xFF);\n\t\t\t\t\tpcache->sibling_map[k+3] = (uint8_t)((cu_sibling_map_mask >> 24) & 0xFF);\n\t\t\t\t\tk += 4;\n\n\t\t\t\t\tcu_sibling_map_mask = cu_info->cu_bitmap[xcc][i % 4][j + i / 4];\n\t\t\t\t\tcu_sibling_map_mask &= ((1 << pcache_info[cache_type].num_cu_shared) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpcache->sibling_map_size = k;\n\t\t*props_ext = pcache;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n#define KFD_MAX_CACHE_TYPES 6\n\n \nstatic void kfd_fill_cache_non_crat_info(struct kfd_topology_device *dev, struct kfd_node *kdev)\n{\n\tstruct kfd_gpu_cache_info *pcache_info = NULL;\n\tint i, j, k, xcc, start, end;\n\tint ct = 0;\n\tunsigned int cu_processor_id;\n\tint ret;\n\tunsigned int num_cu_shared;\n\tstruct kfd_cu_info cu_info;\n\tstruct kfd_cu_info *pcu_info;\n\tint gpu_processor_id;\n\tstruct kfd_cache_properties *props_ext;\n\tint num_of_entries = 0;\n\tint num_of_cache_types = 0;\n\tstruct kfd_gpu_cache_info cache_info[KFD_MAX_CACHE_TYPES];\n\n\tamdgpu_amdkfd_get_cu_info(kdev->adev, &cu_info);\n\tpcu_info = &cu_info;\n\n\tgpu_processor_id = dev->node_props.simd_id_base;\n\n\tpcache_info = cache_info;\n\tnum_of_cache_types = kfd_get_gpu_cache_info(kdev, &pcache_info);\n\tif (!num_of_cache_types) {\n\t\tpr_warn(\"no cache info found\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstart = ffs(kdev->xcc_mask) - 1;\n\tend = start + NUM_XCC(kdev->xcc_mask);\n\n\tfor (ct = 0; ct < num_of_cache_types; ct++) {\n\t\tcu_processor_id = gpu_processor_id;\n\t\tif (pcache_info[ct].cache_level == 1) {\n\t\t\tfor (xcc = start; xcc < end; xcc++) {\n\t\t\t\tfor (i = 0; i < pcu_info->num_shader_engines; i++) {\n\t\t\t\t\tfor (j = 0; j < pcu_info->num_shader_arrays_per_engine; j++) {\n\t\t\t\t\t\tfor (k = 0; k < pcu_info->num_cu_per_sh; k += pcache_info[ct].num_cu_shared) {\n\n\t\t\t\t\t\t\tret = fill_in_l1_pcache(&props_ext, pcache_info, pcu_info,\n\t\t\t\t\t\t\t\t\t\tpcu_info->cu_bitmap[xcc][i % 4][j + i / 4], ct,\n\t\t\t\t\t\t\t\t\t\tcu_processor_id, k);\n\n\t\t\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tif (!ret) {\n\t\t\t\t\t\t\t\tnum_of_entries++;\n\t\t\t\t\t\t\t\tlist_add_tail(&props_ext->list, &dev->cache_props);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tnum_cu_shared = ((k + pcache_info[ct].num_cu_shared) <=\n\t\t\t\t\t\t\t\tpcu_info->num_cu_per_sh) ?\n\t\t\t\t\t\t\t\tpcache_info[ct].num_cu_shared :\n\t\t\t\t\t\t\t\t(pcu_info->num_cu_per_sh - k);\n\t\t\t\t\t\t\tcu_processor_id += num_cu_shared;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = fill_in_l2_l3_pcache(&props_ext, pcache_info,\n\t\t\t\t\tpcu_info, ct, cu_processor_id, kdev);\n\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (!ret) {\n\t\t\t\tnum_of_entries++;\n\t\t\t\tlist_add_tail(&props_ext->list, &dev->cache_props);\n\t\t\t}\n\t\t}\n\t}\n\tdev->node_props.caches_count += num_of_entries;\n\tpr_debug(\"Added [%d] GPU cache entries\\n\", num_of_entries);\n}\n\nstatic int kfd_topology_add_device_locked(struct kfd_node *gpu, uint32_t gpu_id,\n\t\t\t\t\t  struct kfd_topology_device **dev)\n{\n\tint proximity_domain = ++topology_crat_proximity_domain;\n\tstruct list_head temp_topology_device_list;\n\tvoid *crat_image = NULL;\n\tsize_t image_size = 0;\n\tint res;\n\n\tres = kfd_create_crat_image_virtual(&crat_image, &image_size,\n\t\t\t\t\t    COMPUTE_UNIT_GPU, gpu,\n\t\t\t\t\t    proximity_domain);\n\tif (res) {\n\t\tpr_err(\"Error creating VCRAT for GPU (ID: 0x%x)\\n\",\n\t\t       gpu_id);\n\t\ttopology_crat_proximity_domain--;\n\t\tgoto err;\n\t}\n\n\tINIT_LIST_HEAD(&temp_topology_device_list);\n\n\tres = kfd_parse_crat_table(crat_image,\n\t\t\t\t   &temp_topology_device_list,\n\t\t\t\t   proximity_domain);\n\tif (res) {\n\t\tpr_err(\"Error parsing VCRAT for GPU (ID: 0x%x)\\n\",\n\t\t       gpu_id);\n\t\ttopology_crat_proximity_domain--;\n\t\tgoto err;\n\t}\n\n\tkfd_topology_update_device_list(&temp_topology_device_list,\n\t\t\t\t\t&topology_device_list);\n\n\t*dev = kfd_assign_gpu(gpu);\n\tif (WARN_ON(!*dev)) {\n\t\tres = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tkfd_fill_cache_non_crat_info(*dev, gpu);\n\n\t \n\tres = kfd_topology_update_sysfs();\n\tif (!res)\n\t\tsys_props.generation_count++;\n\telse\n\t\tpr_err(\"Failed to update GPU (ID: 0x%x) to sysfs topology. res=%d\\n\",\n\t\t       gpu_id, res);\n\nerr:\n\tkfd_destroy_crat_image(crat_image);\n\treturn res;\n}\n\nstatic void kfd_topology_set_dbg_firmware_support(struct kfd_topology_device *dev)\n{\n\tbool firmware_supported = true;\n\n\tif (KFD_GC_VERSION(dev->gpu) >= IP_VERSION(11, 0, 0) &&\n\t\t\tKFD_GC_VERSION(dev->gpu) < IP_VERSION(12, 0, 0)) {\n\t\tuint32_t mes_api_rev = (dev->gpu->adev->mes.sched_version &\n\t\t\t\t\t\tAMDGPU_MES_API_VERSION_MASK) >>\n\t\t\t\t\t\tAMDGPU_MES_API_VERSION_SHIFT;\n\t\tuint32_t mes_rev = dev->gpu->adev->mes.sched_version &\n\t\t\t\t\t\tAMDGPU_MES_VERSION_MASK;\n\n\t\tfirmware_supported = (mes_api_rev >= 14) && (mes_rev >= 64);\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (KFD_GC_VERSION(dev->gpu)) {\n\tcase IP_VERSION(9, 0, 1):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 459 + 32768;\n\t\tbreak;\n\tcase IP_VERSION(9, 1, 0):\n\tcase IP_VERSION(9, 2, 1):\n\tcase IP_VERSION(9, 2, 2):\n\tcase IP_VERSION(9, 3, 0):\n\tcase IP_VERSION(9, 4, 0):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 459;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 1):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 60;\n\t\tbreak;\n\tcase IP_VERSION(9, 4, 2):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 51;\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 10):\n\tcase IP_VERSION(10, 1, 2):\n\tcase IP_VERSION(10, 1, 1):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 144;\n\t\tbreak;\n\tcase IP_VERSION(10, 3, 0):\n\tcase IP_VERSION(10, 3, 2):\n\tcase IP_VERSION(10, 3, 1):\n\tcase IP_VERSION(10, 3, 4):\n\tcase IP_VERSION(10, 3, 5):\n\t\tfirmware_supported = dev->gpu->kfd->mec_fw_version >= 89;\n\t\tbreak;\n\tcase IP_VERSION(10, 1, 3):\n\tcase IP_VERSION(10, 3, 3):\n\t\tfirmware_supported = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tif (firmware_supported)\n\t\tdev->node_props.capability |= HSA_CAP_TRAP_DEBUG_FIRMWARE_SUPPORTED;\n}\n\nstatic void kfd_topology_set_capabilities(struct kfd_topology_device *dev)\n{\n\tdev->node_props.capability |= ((HSA_CAP_DOORBELL_TYPE_2_0 <<\n\t\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_SHIFT) &\n\t\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_MASK);\n\n\tdev->node_props.capability |= HSA_CAP_TRAP_DEBUG_SUPPORT |\n\t\t\tHSA_CAP_TRAP_DEBUG_WAVE_LAUNCH_TRAP_OVERRIDE_SUPPORTED |\n\t\t\tHSA_CAP_TRAP_DEBUG_WAVE_LAUNCH_MODE_SUPPORTED;\n\n\tif (kfd_dbg_has_ttmps_always_setup(dev->gpu))\n\t\tdev->node_props.debug_prop |= HSA_DBG_DISPATCH_INFO_ALWAYS_VALID;\n\n\tif (KFD_GC_VERSION(dev->gpu) < IP_VERSION(10, 0, 0)) {\n\t\tif (KFD_GC_VERSION(dev->gpu) == IP_VERSION(9, 4, 3))\n\t\t\tdev->node_props.debug_prop |=\n\t\t\t\tHSA_DBG_WATCH_ADDR_MASK_LO_BIT_GFX9_4_3 |\n\t\t\t\tHSA_DBG_WATCH_ADDR_MASK_HI_BIT_GFX9_4_3;\n\t\telse\n\t\t\tdev->node_props.debug_prop |=\n\t\t\t\tHSA_DBG_WATCH_ADDR_MASK_LO_BIT_GFX9 |\n\t\t\t\tHSA_DBG_WATCH_ADDR_MASK_HI_BIT;\n\n\t\tif (KFD_GC_VERSION(dev->gpu) >= IP_VERSION(9, 4, 2))\n\t\t\tdev->node_props.capability |=\n\t\t\t\tHSA_CAP_TRAP_DEBUG_PRECISE_MEMORY_OPERATIONS_SUPPORTED;\n\t} else {\n\t\tdev->node_props.debug_prop |= HSA_DBG_WATCH_ADDR_MASK_LO_BIT_GFX10 |\n\t\t\t\t\tHSA_DBG_WATCH_ADDR_MASK_HI_BIT;\n\n\t\tif (KFD_GC_VERSION(dev->gpu) >= IP_VERSION(11, 0, 0))\n\t\t\tdev->node_props.capability |=\n\t\t\t\tHSA_CAP_TRAP_DEBUG_PRECISE_MEMORY_OPERATIONS_SUPPORTED;\n\t}\n\n\tkfd_topology_set_dbg_firmware_support(dev);\n}\n\nint kfd_topology_add_device(struct kfd_node *gpu)\n{\n\tuint32_t gpu_id;\n\tstruct kfd_topology_device *dev;\n\tstruct kfd_cu_info cu_info;\n\tint res = 0;\n\tint i;\n\tconst char *asic_name = amdgpu_asic_name[gpu->adev->asic_type];\n\n\tgpu_id = kfd_generate_gpu_id(gpu);\n\tif (gpu->xcp && !gpu->xcp->ddev) {\n\t\tdev_warn(gpu->adev->dev,\n\t\t\"Won't add GPU (ID: 0x%x) to topology since it has no drm node assigned.\",\n\t\tgpu_id);\n\t\treturn 0;\n\t} else {\n\t\tpr_debug(\"Adding new GPU (ID: 0x%x) to topology\\n\", gpu_id);\n\t}\n\n\t \n\tdown_write(&topology_lock);\n\tdev = kfd_assign_gpu(gpu);\n\tif (!dev)\n\t\tres = kfd_topology_add_device_locked(gpu, gpu_id, &dev);\n\tup_write(&topology_lock);\n\tif (res)\n\t\treturn res;\n\n\tdev->gpu_id = gpu_id;\n\tgpu->id = gpu_id;\n\n\tkfd_dev_create_p2p_links();\n\n\t \n\n\t \n\n\tamdgpu_amdkfd_get_cu_info(dev->gpu->adev, &cu_info);\n\n\tfor (i = 0; i < KFD_TOPOLOGY_PUBLIC_NAME_SIZE-1; i++) {\n\t\tdev->node_props.name[i] = __tolower(asic_name[i]);\n\t\tif (asic_name[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tdev->node_props.name[i] = '\\0';\n\n\tdev->node_props.simd_arrays_per_engine =\n\t\tcu_info.num_shader_arrays_per_engine;\n\n\tdev->node_props.gfx_target_version =\n\t\t\t\tgpu->kfd->device_info.gfx_target_version;\n\tdev->node_props.vendor_id = gpu->adev->pdev->vendor;\n\tdev->node_props.device_id = gpu->adev->pdev->device;\n\tdev->node_props.capability |=\n\t\t((dev->gpu->adev->rev_id << HSA_CAP_ASIC_REVISION_SHIFT) &\n\t\t\tHSA_CAP_ASIC_REVISION_MASK);\n\n\tdev->node_props.location_id = pci_dev_id(gpu->adev->pdev);\n\tif (KFD_GC_VERSION(dev->gpu->kfd) == IP_VERSION(9, 4, 3))\n\t\tdev->node_props.location_id |= dev->gpu->node_id;\n\n\tdev->node_props.domain = pci_domain_nr(gpu->adev->pdev->bus);\n\tdev->node_props.max_engine_clk_fcompute =\n\t\tamdgpu_amdkfd_get_max_engine_clock_in_mhz(dev->gpu->adev);\n\tdev->node_props.max_engine_clk_ccompute =\n\t\tcpufreq_quick_get_max(0) / 1000;\n\n\tif (gpu->xcp)\n\t\tdev->node_props.drm_render_minor = gpu->xcp->ddev->render->index;\n\telse\n\t\tdev->node_props.drm_render_minor =\n\t\t\t\tgpu->kfd->shared_resources.drm_render_minor;\n\n\tdev->node_props.hive_id = gpu->kfd->hive_id;\n\tdev->node_props.num_sdma_engines = kfd_get_num_sdma_engines(gpu);\n\tdev->node_props.num_sdma_xgmi_engines =\n\t\t\t\t\tkfd_get_num_xgmi_sdma_engines(gpu);\n\tdev->node_props.num_sdma_queues_per_engine =\n\t\t\t\tgpu->kfd->device_info.num_sdma_queues_per_engine -\n\t\t\t\tgpu->kfd->device_info.num_reserved_sdma_queues_per_engine;\n\tdev->node_props.num_gws = (dev->gpu->gws &&\n\t\tdev->gpu->dqm->sched_policy != KFD_SCHED_POLICY_NO_HWS) ?\n\t\tdev->gpu->adev->gds.gws_size : 0;\n\tdev->node_props.num_cp_queues = get_cp_queues_num(dev->gpu->dqm);\n\n\tkfd_fill_mem_clk_max_info(dev);\n\tkfd_fill_iolink_non_crat_info(dev);\n\n\tswitch (dev->gpu->adev->asic_type) {\n\tcase CHIP_KAVERI:\n\tcase CHIP_HAWAII:\n\tcase CHIP_TONGA:\n\t\tdev->node_props.capability |= ((HSA_CAP_DOORBELL_TYPE_PRE_1_0 <<\n\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_SHIFT) &\n\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_MASK);\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\tcase CHIP_FIJI:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\t\tpr_debug(\"Adding doorbell packet type capability\\n\");\n\t\tdev->node_props.capability |= ((HSA_CAP_DOORBELL_TYPE_1_0 <<\n\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_SHIFT) &\n\t\t\tHSA_CAP_DOORBELL_TYPE_TOTALBITS_MASK);\n\t\tbreak;\n\tdefault:\n\t\tif (KFD_GC_VERSION(dev->gpu) < IP_VERSION(9, 0, 1))\n\t\t\tWARN(1, \"Unexpected ASIC family %u\",\n\t\t\t     dev->gpu->adev->asic_type);\n\t\telse\n\t\t\tkfd_topology_set_capabilities(dev);\n\t}\n\n\t \n\tdev->node_props.capability &= ~HSA_CAP_ATS_PRESENT;\n\n\t \n\tif (dev->gpu->adev->asic_type == CHIP_CARRIZO) {\n\t\tdev->node_props.simd_count =\n\t\t\tcu_info.simd_per_cu * cu_info.cu_active_number;\n\t\tdev->node_props.max_waves_per_simd = 10;\n\t}\n\n\t \n\tdev->node_props.capability |=\n\t\t((dev->gpu->adev->ras_enabled & BIT(AMDGPU_RAS_BLOCK__GFX)) != 0) ?\n\t\tHSA_CAP_SRAM_EDCSUPPORTED : 0;\n\tdev->node_props.capability |=\n\t\t((dev->gpu->adev->ras_enabled & BIT(AMDGPU_RAS_BLOCK__UMC)) != 0) ?\n\t\tHSA_CAP_MEM_EDCSUPPORTED : 0;\n\n\tif (KFD_GC_VERSION(dev->gpu) != IP_VERSION(9, 0, 1))\n\t\tdev->node_props.capability |= (dev->gpu->adev->ras_enabled != 0) ?\n\t\t\tHSA_CAP_RASEVENTNOTIFY : 0;\n\n\tif (KFD_IS_SVM_API_SUPPORTED(dev->gpu->adev))\n\t\tdev->node_props.capability |= HSA_CAP_SVMAPI_SUPPORTED;\n\n\tif (dev->gpu->adev->gmc.is_app_apu ||\n\t\tdev->gpu->adev->gmc.xgmi.connected_to_cpu)\n\t\tdev->node_props.capability |= HSA_CAP_FLAGS_COHERENTHOSTACCESS;\n\n\tkfd_debug_print_topology();\n\n\tkfd_notify_gpu_change(gpu_id, 1);\n\n\treturn 0;\n}\n\n \nstatic void kfd_topology_update_io_links(int proximity_domain)\n{\n\tstruct kfd_topology_device *dev;\n\tstruct kfd_iolink_properties *iolink, *p2plink, *tmp;\n\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\tif (dev->proximity_domain > proximity_domain)\n\t\t\tdev->proximity_domain--;\n\n\t\tlist_for_each_entry_safe(iolink, tmp, &dev->io_link_props, list) {\n\t\t\t \n\t\t\tif (iolink->node_to == proximity_domain) {\n\t\t\t\tlist_del(&iolink->list);\n\t\t\t\tdev->node_props.io_links_count--;\n\t\t\t} else {\n\t\t\t\tif (iolink->node_from > proximity_domain)\n\t\t\t\t\tiolink->node_from--;\n\t\t\t\tif (iolink->node_to > proximity_domain)\n\t\t\t\t\tiolink->node_to--;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(p2plink, tmp, &dev->p2p_link_props, list) {\n\t\t\t \n\t\t\tif (p2plink->node_to == proximity_domain) {\n\t\t\t\tlist_del(&p2plink->list);\n\t\t\t\tdev->node_props.p2p_links_count--;\n\t\t\t} else {\n\t\t\t\tif (p2plink->node_from > proximity_domain)\n\t\t\t\t\tp2plink->node_from--;\n\t\t\t\tif (p2plink->node_to > proximity_domain)\n\t\t\t\t\tp2plink->node_to--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint kfd_topology_remove_device(struct kfd_node *gpu)\n{\n\tstruct kfd_topology_device *dev, *tmp;\n\tuint32_t gpu_id;\n\tint res = -ENODEV;\n\tint i = 0;\n\n\tdown_write(&topology_lock);\n\n\tlist_for_each_entry_safe(dev, tmp, &topology_device_list, list) {\n\t\tif (dev->gpu == gpu) {\n\t\t\tgpu_id = dev->gpu_id;\n\t\t\tkfd_remove_sysfs_node_entry(dev);\n\t\t\tkfd_release_topology_device(dev);\n\t\t\tsys_props.num_devices--;\n\t\t\tkfd_topology_update_io_links(i);\n\t\t\ttopology_crat_proximity_domain = sys_props.num_devices-1;\n\t\t\tsys_props.generation_count++;\n\t\t\tres = 0;\n\t\t\tif (kfd_topology_update_sysfs() < 0)\n\t\t\t\tkfd_topology_release_sysfs();\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tup_write(&topology_lock);\n\n\tif (!res)\n\t\tkfd_notify_gpu_change(gpu_id, 0);\n\n\treturn res;\n}\n\n \nint kfd_topology_enum_kfd_devices(uint8_t idx, struct kfd_node **kdev)\n{\n\n\tstruct kfd_topology_device *top_dev;\n\tuint8_t device_idx = 0;\n\n\t*kdev = NULL;\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(top_dev, &topology_device_list, list) {\n\t\tif (device_idx == idx) {\n\t\t\t*kdev = top_dev->gpu;\n\t\t\tup_read(&topology_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdevice_idx++;\n\t}\n\n\tup_read(&topology_lock);\n\n\treturn -1;\n\n}\n\nstatic int kfd_cpumask_to_apic_id(const struct cpumask *cpumask)\n{\n\tint first_cpu_of_numa_node;\n\n\tif (!cpumask || cpumask == cpu_none_mask)\n\t\treturn -1;\n\tfirst_cpu_of_numa_node = cpumask_first(cpumask);\n\tif (first_cpu_of_numa_node >= nr_cpu_ids)\n\t\treturn -1;\n#ifdef CONFIG_X86_64\n\treturn cpu_data(first_cpu_of_numa_node).apicid;\n#else\n\treturn first_cpu_of_numa_node;\n#endif\n}\n\n \nint kfd_numa_node_to_apic_id(int numa_node_id)\n{\n\tif (numa_node_id == -1) {\n\t\tpr_warn(\"Invalid NUMA Node. Use online CPU mask\\n\");\n\t\treturn kfd_cpumask_to_apic_id(cpu_online_mask);\n\t}\n\treturn kfd_cpumask_to_apic_id(cpumask_of_node(numa_node_id));\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nint kfd_debugfs_hqds_by_device(struct seq_file *m, void *data)\n{\n\tstruct kfd_topology_device *dev;\n\tunsigned int i = 0;\n\tint r = 0;\n\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\tif (!dev->gpu) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"Node %u, gpu_id %x:\\n\", i++, dev->gpu->id);\n\t\tr = dqm_debugfs_hqds(m, dev->gpu->dqm);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tup_read(&topology_lock);\n\n\treturn r;\n}\n\nint kfd_debugfs_rls_by_device(struct seq_file *m, void *data)\n{\n\tstruct kfd_topology_device *dev;\n\tunsigned int i = 0;\n\tint r = 0;\n\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(dev, &topology_device_list, list) {\n\t\tif (!dev->gpu) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"Node %u, gpu_id %x:\\n\", i++, dev->gpu->id);\n\t\tr = pm_debugfs_runlist(m, &dev->gpu->dqm->packet_mgr);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tup_read(&topology_lock);\n\n\treturn r;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}