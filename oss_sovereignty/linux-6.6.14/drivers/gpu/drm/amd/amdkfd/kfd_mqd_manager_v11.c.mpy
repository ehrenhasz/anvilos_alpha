{
  "module_name": "kfd_mqd_manager_v11.c",
  "hash_id": "f6d8e2c1c29a762ca025f989d02778a3133042974ea73bd1330c2e503550adca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v11.c",
  "human_readable_source": " \n\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"kfd_priv.h\"\n#include \"kfd_mqd_manager.h\"\n#include \"v11_structs.h\"\n#include \"gc/gc_11_0_0_offset.h\"\n#include \"gc/gc_11_0_0_sh_mask.h\"\n#include \"amdgpu_amdkfd.h\"\n\nstatic inline struct v11_compute_mqd *get_mqd(void *mqd)\n{\n\treturn (struct v11_compute_mqd *)mqd;\n}\n\nstatic inline struct v11_sdma_mqd *get_sdma_mqd(void *mqd)\n{\n\treturn (struct v11_sdma_mqd *)mqd;\n}\n\nstatic void update_cu_mask(struct mqd_manager *mm, void *mqd,\n\t\t\t   struct mqd_update_info *minfo)\n{\n\tstruct v11_compute_mqd *m;\n\tuint32_t se_mask[KFD_MAX_NUM_SE] = {0};\n\tbool has_wa_flag = minfo && (minfo->update_flag & (UPDATE_FLAG_DBG_WA_ENABLE |\n\t\t\tUPDATE_FLAG_DBG_WA_DISABLE));\n\n\tif (!minfo || !(has_wa_flag || minfo->cu_mask.ptr))\n\t\treturn;\n\n\tm = get_mqd(mqd);\n\n\tif (has_wa_flag) {\n\t\tuint32_t wa_mask = minfo->update_flag == UPDATE_FLAG_DBG_WA_ENABLE ?\n\t\t\t\t\t\t0xffff : 0xffffffff;\n\n\t\tm->compute_static_thread_mgmt_se0 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se1 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se2 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se3 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se4 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se5 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se6 = wa_mask;\n\t\tm->compute_static_thread_mgmt_se7 = wa_mask;\n\n\t\treturn;\n\t}\n\n\tmqd_symmetrically_map_cu_mask(mm,\n\t\tminfo->cu_mask.ptr, minfo->cu_mask.count, se_mask, 0);\n\n\tm->compute_static_thread_mgmt_se0 = se_mask[0];\n\tm->compute_static_thread_mgmt_se1 = se_mask[1];\n\tm->compute_static_thread_mgmt_se2 = se_mask[2];\n\tm->compute_static_thread_mgmt_se3 = se_mask[3];\n\tm->compute_static_thread_mgmt_se4 = se_mask[4];\n\tm->compute_static_thread_mgmt_se5 = se_mask[5];\n\tm->compute_static_thread_mgmt_se6 = se_mask[6];\n\tm->compute_static_thread_mgmt_se7 = se_mask[7];\n\n\tpr_debug(\"update cu mask to %#x %#x %#x %#x %#x %#x %#x %#x\\n\",\n\t\tm->compute_static_thread_mgmt_se0,\n\t\tm->compute_static_thread_mgmt_se1,\n\t\tm->compute_static_thread_mgmt_se2,\n\t\tm->compute_static_thread_mgmt_se3,\n\t\tm->compute_static_thread_mgmt_se4,\n\t\tm->compute_static_thread_mgmt_se5,\n\t\tm->compute_static_thread_mgmt_se6,\n\t\tm->compute_static_thread_mgmt_se7);\n}\n\nstatic void set_priority(struct v11_compute_mqd *m, struct queue_properties *q)\n{\n\tm->cp_hqd_pipe_priority = pipe_priority_map[q->priority];\n\tm->cp_hqd_queue_priority = q->priority;\n}\n\nstatic struct kfd_mem_obj *allocate_mqd(struct kfd_node *node,\n\t\tstruct queue_properties *q)\n{\n\tstruct kfd_mem_obj *mqd_mem_obj;\n\tint size;\n\n\t \n\tif (node->kfd->shared_resources.enable_mes)\n\t\tsize = PAGE_SIZE;\n\telse\n\t\tsize = sizeof(struct v11_compute_mqd);\n\n\tif (kfd_gtt_sa_allocate(node, size, &mqd_mem_obj))\n\t\treturn NULL;\n\n\treturn mqd_mem_obj;\n}\n\nstatic void init_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tuint64_t addr;\n\tstruct v11_compute_mqd *m;\n\tint size;\n\tuint32_t wa_mask = q->is_dbg_wa ? 0xffff : 0xffffffff;\n\n\tm = (struct v11_compute_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tif (mm->dev->kfd->shared_resources.enable_mes)\n\t\tsize = PAGE_SIZE;\n\telse\n\t\tsize = sizeof(struct v11_compute_mqd);\n\n\tmemset(m, 0, size);\n\n\tm->header = 0xC0310800;\n\tm->compute_pipelinestat_enable = 1;\n\n\tm->compute_static_thread_mgmt_se0 = wa_mask;\n\tm->compute_static_thread_mgmt_se1 = wa_mask;\n\tm->compute_static_thread_mgmt_se2 = wa_mask;\n\tm->compute_static_thread_mgmt_se3 = wa_mask;\n\tm->compute_static_thread_mgmt_se4 = wa_mask;\n\tm->compute_static_thread_mgmt_se5 = wa_mask;\n\tm->compute_static_thread_mgmt_se6 = wa_mask;\n\tm->compute_static_thread_mgmt_se7 = wa_mask;\n\n\tm->cp_hqd_persistent_state = CP_HQD_PERSISTENT_STATE__PRELOAD_REQ_MASK |\n\t\t\t0x55 << CP_HQD_PERSISTENT_STATE__PRELOAD_SIZE__SHIFT;\n\n\tm->cp_mqd_control = 1 << CP_MQD_CONTROL__PRIV_STATE__SHIFT;\n\n\tm->cp_mqd_base_addr_lo        = lower_32_bits(addr);\n\tm->cp_mqd_base_addr_hi        = upper_32_bits(addr);\n\n\tm->cp_hqd_quantum = 1 << CP_HQD_QUANTUM__QUANTUM_EN__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_SCALE__SHIFT |\n\t\t\t1 << CP_HQD_QUANTUM__QUANTUM_DURATION__SHIFT;\n\n\t \n\tm->cp_hqd_hq_status0 = 1 << 14;\n\n\t \n\tif (amdgpu_amdkfd_have_atomics_support(mm->dev->adev))\n\t\tm->cp_hqd_hq_status0 |= 1 << 29;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\tm->cp_hqd_aql_control =\n\t\t\t1 << CP_HQD_AQL_CONTROL__CONTROL0__SHIFT;\n\t}\n\n\tif (mm->dev->kfd->cwsr_enabled) {\n\t\tm->cp_hqd_persistent_state |=\n\t\t\t(1 << CP_HQD_PERSISTENT_STATE__QSWITCH_MODE__SHIFT);\n\t\tm->cp_hqd_ctx_save_base_addr_lo =\n\t\t\tlower_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_base_addr_hi =\n\t\t\tupper_32_bits(q->ctx_save_restore_area_address);\n\t\tm->cp_hqd_ctx_save_size = q->ctx_save_restore_area_size;\n\t\tm->cp_hqd_cntl_stack_size = q->ctl_stack_size;\n\t\tm->cp_hqd_cntl_stack_offset = q->ctl_stack_size;\n\t\tm->cp_hqd_wg_state_offset = q->ctl_stack_size;\n\t}\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\nstatic int load_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tuint32_t pipe_id, uint32_t queue_id,\n\t\t\tstruct queue_properties *p, struct mm_struct *mms)\n{\n\tint r = 0;\n\t \n\tuint32_t wptr_shift = (p->format == KFD_QUEUE_FORMAT_AQL ? 4 : 0);\n\n\tr = mm->dev->kfd2kgd->hqd_load(mm->dev->adev, mqd, pipe_id, queue_id,\n\t\t\t\t\t  (uint32_t __user *)p->write_ptr,\n\t\t\t\t\t  wptr_shift, 0, mms, 0);\n\treturn r;\n}\n\nstatic void update_mqd(struct mqd_manager *mm, void *mqd,\n\t\t       struct queue_properties *q,\n\t\t       struct mqd_update_info *minfo)\n{\n\tstruct v11_compute_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tm->cp_hqd_pq_control = 5 << CP_HQD_PQ_CONTROL__RPTR_BLOCK_SIZE__SHIFT;\n\tm->cp_hqd_pq_control |=\n\t\t\tffs(q->queue_size / sizeof(unsigned int)) - 1 - 1;\n\tpr_debug(\"cp_hqd_pq_control 0x%x\\n\", m->cp_hqd_pq_control);\n\n\tm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\n\tm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\n\n\tm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_lo = lower_32_bits((uint64_t)q->write_ptr);\n\tm->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits((uint64_t)q->write_ptr);\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tq->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tm->cp_hqd_ib_control = 3 << CP_HQD_IB_CONTROL__MIN_IB_AVAIL_SIZE__SHIFT;\n\n\t \n\tm->cp_hqd_eop_control = min(0xA,\n\t\tffs(q->eop_ring_buffer_size / sizeof(unsigned int)) - 1 - 1);\n\tm->cp_hqd_eop_base_addr_lo =\n\t\t\tlower_32_bits(q->eop_ring_buffer_address >> 8);\n\tm->cp_hqd_eop_base_addr_hi =\n\t\t\tupper_32_bits(q->eop_ring_buffer_address >> 8);\n\n\tm->cp_hqd_iq_timer = 0;\n\n\tm->cp_hqd_vmid = q->vmid;\n\n\tif (q->format == KFD_QUEUE_FORMAT_AQL) {\n\t\t \n\t\tm->cp_hqd_pq_control |= CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK |\n\t\t\t\t2 << CP_HQD_PQ_CONTROL__SLOT_BASED_WPTR__SHIFT |\n\t\t\t\t1 << CP_HQD_PQ_CONTROL__QUEUE_FULL_EN__SHIFT ;\n\t\tm->cp_hqd_pq_doorbell_control |=\n\t\t\t1 << CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_BIF_DROP__SHIFT;\n\t}\n\tif (mm->dev->kfd->cwsr_enabled)\n\t\tm->cp_hqd_ctx_save_control = 0;\n\n\tupdate_cu_mask(mm, mqd, minfo);\n\tset_priority(m, q);\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\nstatic uint32_t read_doorbell_id(void *mqd)\n{\n\tstruct v11_compute_mqd *m = (struct v11_compute_mqd *)mqd;\n\n\treturn m->queue_doorbell_id0;\n}\n\nstatic int get_wave_state(struct mqd_manager *mm, void *mqd,\n\t\t\t  struct queue_properties *q,\n\t\t\t  void __user *ctl_stack,\n\t\t\t  u32 *ctl_stack_used_size,\n\t\t\t  u32 *save_area_used_size)\n{\n\tstruct v11_compute_mqd *m;\n\tstruct kfd_context_save_area_header header;\n\n\tm = get_mqd(mqd);\n\n\t \n\t*ctl_stack_used_size = m->cp_hqd_cntl_stack_size -\n\t\tm->cp_hqd_cntl_stack_offset;\n\t*save_area_used_size = m->cp_hqd_wg_state_offset -\n\t\tm->cp_hqd_cntl_stack_size;\n\n\t \n\theader.wave_state.control_stack_size = *ctl_stack_used_size;\n\theader.wave_state.wave_state_size = *save_area_used_size;\n\n\theader.wave_state.wave_state_offset = m->cp_hqd_wg_state_offset;\n\theader.wave_state.control_stack_offset = m->cp_hqd_cntl_stack_offset;\n\n\tif (copy_to_user(ctl_stack, &header, sizeof(header.wave_state)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void checkpoint_mqd(struct mqd_manager *mm, void *mqd, void *mqd_dst, void *ctl_stack_dst)\n{\n\tstruct v11_compute_mqd *m;\n\n\tm = get_mqd(mqd);\n\n\tmemcpy(mqd_dst, m, sizeof(struct v11_compute_mqd));\n}\n\nstatic void restore_mqd(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *qp,\n\t\t\tconst void *mqd_src,\n\t\t\tconst void *ctl_stack_src, const u32 ctl_stack_size)\n{\n\tuint64_t addr;\n\tstruct v11_compute_mqd *m;\n\n\tm = (struct v11_compute_mqd *) mqd_mem_obj->cpu_ptr;\n\taddr = mqd_mem_obj->gpu_addr;\n\n\tmemcpy(m, mqd_src, sizeof(*m));\n\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = addr;\n\n\tm->cp_hqd_pq_doorbell_control =\n\t\tqp->doorbell_off <<\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\tpr_debug(\"cp_hqd_pq_doorbell_control 0x%x\\n\",\n\t\t\tm->cp_hqd_pq_doorbell_control);\n\n\tqp->is_active = 0;\n}\n\n\nstatic void init_mqd_hiq(struct mqd_manager *mm, void **mqd,\n\t\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\t\tstruct queue_properties *q)\n{\n\tstruct v11_compute_mqd *m;\n\n\tinit_mqd(mm, mqd, mqd_mem_obj, gart_addr, q);\n\n\tm = get_mqd(*mqd);\n\n\tm->cp_hqd_pq_control |= 1 << CP_HQD_PQ_CONTROL__PRIV_STATE__SHIFT |\n\t\t\t1 << CP_HQD_PQ_CONTROL__KMD_QUEUE__SHIFT;\n}\n\nstatic int destroy_hiq_mqd(struct mqd_manager *mm, void *mqd,\n\t\t\tenum kfd_preempt_type type, unsigned int timeout,\n\t\t\tuint32_t pipe_id, uint32_t queue_id)\n{\n\tint err;\n\tstruct v11_compute_mqd *m;\n\tu32 doorbell_off;\n\n\tm = get_mqd(mqd);\n\n\tdoorbell_off = m->cp_hqd_pq_doorbell_control >>\n\t\t\tCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\n\n\terr = amdgpu_amdkfd_unmap_hiq(mm->dev->adev, doorbell_off, 0);\n\tif (err)\n\t\tpr_debug(\"Destroy HIQ MQD failed: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void init_mqd_sdma(struct mqd_manager *mm, void **mqd,\n\t\tstruct kfd_mem_obj *mqd_mem_obj, uint64_t *gart_addr,\n\t\tstruct queue_properties *q)\n{\n\tstruct v11_sdma_mqd *m;\n\tint size;\n\n\tm = (struct v11_sdma_mqd *) mqd_mem_obj->cpu_ptr;\n\n\tif (mm->dev->kfd->shared_resources.enable_mes)\n\t\tsize = PAGE_SIZE;\n\telse\n\t\tsize = sizeof(struct v11_sdma_mqd);\n\n\tmemset(m, 0, size);\n\t*mqd = m;\n\tif (gart_addr)\n\t\t*gart_addr = mqd_mem_obj->gpu_addr;\n\n\tmm->update_mqd(mm, m, q, NULL);\n}\n\n#define SDMA_RLC_DUMMY_DEFAULT 0xf\n\nstatic void update_mqd_sdma(struct mqd_manager *mm, void *mqd,\n\t\tstruct queue_properties *q,\n\t\tstruct mqd_update_info *minfo)\n{\n\tstruct v11_sdma_mqd *m;\n\n\tm = get_sdma_mqd(mqd);\n\tm->sdmax_rlcx_rb_cntl = (ffs(q->queue_size / sizeof(unsigned int)) - 1)\n\t\t<< SDMA0_QUEUE0_RB_CNTL__RB_SIZE__SHIFT |\n\t\tq->vmid << SDMA0_QUEUE0_RB_CNTL__RB_VMID__SHIFT |\n\t\t1 << SDMA0_QUEUE0_RB_CNTL__RPTR_WRITEBACK_ENABLE__SHIFT |\n\t\t6 << SDMA0_QUEUE0_RB_CNTL__RPTR_WRITEBACK_TIMER__SHIFT |\n\t\t1 << SDMA0_QUEUE0_RB_CNTL__F32_WPTR_POLL_ENABLE__SHIFT;\n\n\tm->sdmax_rlcx_rb_base = lower_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_base_hi = upper_32_bits(q->queue_address >> 8);\n\tm->sdmax_rlcx_rb_rptr_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_rb_rptr_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\n\tm->sdmax_rlcx_rb_wptr_poll_addr_lo = lower_32_bits((uint64_t)q->write_ptr);\n\tm->sdmax_rlcx_rb_wptr_poll_addr_hi = upper_32_bits((uint64_t)q->write_ptr);\n\tm->sdmax_rlcx_doorbell_offset =\n\t\tq->doorbell_off << SDMA0_QUEUE0_DOORBELL_OFFSET__OFFSET__SHIFT;\n\n\tm->sdmax_rlcx_sched_cntl = (amdgpu_sdma_phase_quantum\n\t\t<< SDMA0_QUEUE0_SCHEDULE_CNTL__CONTEXT_QUANTUM__SHIFT)\n\t\t & SDMA0_QUEUE0_SCHEDULE_CNTL__CONTEXT_QUANTUM_MASK;\n\n\tm->sdma_engine_id = q->sdma_engine_id;\n\tm->sdma_queue_id = q->sdma_queue_id;\n\tm->sdmax_rlcx_dummy_reg = SDMA_RLC_DUMMY_DEFAULT;\n\n\tq->is_active = QUEUE_IS_ACTIVE(*q);\n}\n\n#if defined(CONFIG_DEBUG_FS)\n\nstatic int debugfs_show_mqd(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct v11_compute_mqd), false);\n\treturn 0;\n}\n\nstatic int debugfs_show_mqd_sdma(struct seq_file *m, void *data)\n{\n\tseq_hex_dump(m, \"    \", DUMP_PREFIX_OFFSET, 32, 4,\n\t\t     data, sizeof(struct v11_sdma_mqd), false);\n\treturn 0;\n}\n\n#endif\n\nstruct mqd_manager *mqd_manager_init_v11(enum KFD_MQD_TYPE type,\n\t\tstruct kfd_node *dev)\n{\n\tstruct mqd_manager *mqd;\n\n\tif (WARN_ON(type >= KFD_MQD_TYPE_MAX))\n\t\treturn NULL;\n\n\tmqd = kzalloc(sizeof(*mqd), GFP_KERNEL);\n\tif (!mqd)\n\t\treturn NULL;\n\n\tmqd->dev = dev;\n\n\tswitch (type) {\n\tcase KFD_MQD_TYPE_CP:\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct v11_compute_mqd);\n\t\tmqd->get_wave_state = get_wave_state;\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd;\n\t\tmqd->restore_mqd = restore_mqd;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tbreak;\n\tcase KFD_MQD_TYPE_HIQ:\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tmqd->allocate_mqd = allocate_hiq_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = kfd_hiq_load_mqd_kiq;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = destroy_hiq_mqd;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct v11_compute_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tmqd->read_doorbell_id = read_doorbell_id;\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tbreak;\n\tcase KFD_MQD_TYPE_DIQ:\n\t\tmqd->allocate_mqd = allocate_mqd;\n\t\tmqd->init_mqd = init_mqd_hiq;\n\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\tmqd->load_mqd = load_mqd;\n\t\tmqd->update_mqd = update_mqd;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_cp;\n\t\tmqd->is_occupied = kfd_is_occupied_cp;\n\t\tmqd->mqd_size = sizeof(struct v11_compute_mqd);\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd;\n#endif\n\t\tbreak;\n\tcase KFD_MQD_TYPE_SDMA:\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tmqd->allocate_mqd = allocate_sdma_mqd;\n\t\tmqd->init_mqd = init_mqd_sdma;\n\t\tmqd->free_mqd = free_mqd_hiq_sdma;\n\t\tmqd->load_mqd = kfd_load_mqd_sdma;\n\t\tmqd->update_mqd = update_mqd_sdma;\n\t\tmqd->destroy_mqd = kfd_destroy_mqd_sdma;\n\t\tmqd->is_occupied = kfd_is_occupied_sdma;\n\t\tmqd->checkpoint_mqd = checkpoint_mqd;\n\t\tmqd->restore_mqd = restore_mqd;\n\t\tmqd->mqd_size = sizeof(struct v11_sdma_mqd);\n\t\tmqd->mqd_stride = kfd_mqd_stride;\n#if defined(CONFIG_DEBUG_FS)\n\t\tmqd->debugfs_show_mqd = debugfs_show_mqd_sdma;\n#endif\n\t\t \n\t\tif (dev->kfd->shared_resources.enable_mes) {\n\t\t\tmqd->allocate_mqd = allocate_mqd;\n\t\t\tmqd->free_mqd = kfd_free_mqd_cp;\n\t\t}\n\t\tpr_debug(\"%s@%i\\n\", __func__, __LINE__);\n\t\tbreak;\n\tdefault:\n\t\tkfree(mqd);\n\t\treturn NULL;\n\t}\n\n\treturn mqd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}