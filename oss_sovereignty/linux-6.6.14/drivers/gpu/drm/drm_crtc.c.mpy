{
  "module_name": "drm_crtc.c",
  "hash_id": "3d2ab61c7ca6e1e3f9d414dbf7a76d7eec11f756d9a53d9c5e81182a30b95213",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_crtc.c",
  "human_readable_source": " \n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/dma-fence.h>\n#include <linux/uaccess.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_auth.h>\n#include <drm/drm_debugfs_crc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n#include <drm/drm_file.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n \n\n \nstruct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx)\n{\n\tstruct drm_crtc *crtc;\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tif (idx == crtc->index)\n\t\t\treturn crtc;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_crtc_from_index);\n\nint drm_crtc_force_disable(struct drm_crtc *crtc)\n{\n\tstruct drm_mode_set set = {\n\t\t.crtc = crtc,\n\t};\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(crtc->dev));\n\n\treturn drm_mode_set_config_internal(&set);\n}\n\nstatic unsigned int drm_num_crtcs(struct drm_device *dev)\n{\n\tunsigned int num = 0;\n\tstruct drm_crtc *tmp;\n\n\tdrm_for_each_crtc(tmp, dev) {\n\t\tnum++;\n\t}\n\n\treturn num;\n}\n\nint drm_crtc_register_all(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\tint ret = 0;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tdrm_debugfs_crtc_add(crtc);\n\n\t\tif (crtc->funcs->late_register)\n\t\t\tret = crtc->funcs->late_register(crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid drm_crtc_unregister_all(struct drm_device *dev)\n{\n\tstruct drm_crtc *crtc;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tif (crtc->funcs->early_unregister)\n\t\t\tcrtc->funcs->early_unregister(crtc);\n\t\tdrm_debugfs_crtc_remove(crtc);\n\t}\n}\n\nstatic int drm_crtc_crc_init(struct drm_crtc *crtc)\n{\n#ifdef CONFIG_DEBUG_FS\n\tspin_lock_init(&crtc->crc.lock);\n\tinit_waitqueue_head(&crtc->crc.wq);\n\tcrtc->crc.source = kstrdup(\"auto\", GFP_KERNEL);\n\tif (!crtc->crc.source)\n\t\treturn -ENOMEM;\n#endif\n\treturn 0;\n}\n\nstatic void drm_crtc_crc_fini(struct drm_crtc *crtc)\n{\n#ifdef CONFIG_DEBUG_FS\n\tkfree(crtc->crc.source);\n#endif\n}\n\nstatic const struct dma_fence_ops drm_crtc_fence_ops;\n\nstatic struct drm_crtc *fence_to_crtc(struct dma_fence *fence)\n{\n\tBUG_ON(fence->ops != &drm_crtc_fence_ops);\n\treturn container_of(fence->lock, struct drm_crtc, fence_lock);\n}\n\nstatic const char *drm_crtc_fence_get_driver_name(struct dma_fence *fence)\n{\n\tstruct drm_crtc *crtc = fence_to_crtc(fence);\n\n\treturn crtc->dev->driver->name;\n}\n\nstatic const char *drm_crtc_fence_get_timeline_name(struct dma_fence *fence)\n{\n\tstruct drm_crtc *crtc = fence_to_crtc(fence);\n\n\treturn crtc->timeline_name;\n}\n\nstatic const struct dma_fence_ops drm_crtc_fence_ops = {\n\t.get_driver_name = drm_crtc_fence_get_driver_name,\n\t.get_timeline_name = drm_crtc_fence_get_timeline_name,\n};\n\nstruct dma_fence *drm_crtc_create_fence(struct drm_crtc *crtc)\n{\n\tstruct dma_fence *fence;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn NULL;\n\n\tdma_fence_init(fence, &drm_crtc_fence_ops, &crtc->fence_lock,\n\t\t       crtc->fence_context, ++crtc->fence_seqno);\n\n\treturn fence;\n}\n\n \n\n__printf(6, 0)\nstatic int __drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t\t       struct drm_plane *primary,\n\t\t\t\t       struct drm_plane *cursor,\n\t\t\t\t       const struct drm_crtc_funcs *funcs,\n\t\t\t\t       const char *name, va_list ap)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret;\n\n\tWARN_ON(primary && primary->type != DRM_PLANE_TYPE_PRIMARY);\n\tWARN_ON(cursor && cursor->type != DRM_PLANE_TYPE_CURSOR);\n\n\t \n\tif (WARN_ON(config->num_crtc >= 32))\n\t\treturn -EINVAL;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev) &&\n\t\t(!funcs->atomic_destroy_state ||\n\t\t !funcs->atomic_duplicate_state));\n\n\tcrtc->dev = dev;\n\tcrtc->funcs = funcs;\n\n\tINIT_LIST_HEAD(&crtc->commit_list);\n\tspin_lock_init(&crtc->commit_lock);\n\n\tdrm_modeset_lock_init(&crtc->mutex);\n\tret = drm_mode_object_add(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);\n\tif (ret)\n\t\treturn ret;\n\n\tif (name) {\n\t\tcrtc->name = kvasprintf(GFP_KERNEL, name, ap);\n\t} else {\n\t\tcrtc->name = kasprintf(GFP_KERNEL, \"crtc-%d\",\n\t\t\t\t       drm_num_crtcs(dev));\n\t}\n\tif (!crtc->name) {\n\t\tdrm_mode_object_unregister(dev, &crtc->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tcrtc->fence_context = dma_fence_context_alloc(1);\n\tspin_lock_init(&crtc->fence_lock);\n\tsnprintf(crtc->timeline_name, sizeof(crtc->timeline_name),\n\t\t \"CRTC:%d-%s\", crtc->base.id, crtc->name);\n\n\tcrtc->base.properties = &crtc->properties;\n\n\tlist_add_tail(&crtc->head, &config->crtc_list);\n\tcrtc->index = config->num_crtc++;\n\n\tcrtc->primary = primary;\n\tcrtc->cursor = cursor;\n\tif (primary && !primary->possible_crtcs)\n\t\tprimary->possible_crtcs = drm_crtc_mask(crtc);\n\tif (cursor && !cursor->possible_crtcs)\n\t\tcursor->possible_crtcs = drm_crtc_mask(crtc);\n\n\tret = drm_crtc_crc_init(crtc);\n\tif (ret) {\n\t\tdrm_mode_object_unregister(dev, &crtc->base);\n\t\treturn ret;\n\t}\n\n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\n\t\tdrm_object_attach_property(&crtc->base, config->prop_active, 0);\n\t\tdrm_object_attach_property(&crtc->base, config->prop_mode_id, 0);\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->prop_out_fence_ptr, 0);\n\t\tdrm_object_attach_property(&crtc->base,\n\t\t\t\t\t   config->prop_vrr_enabled, 0);\n\t}\n\n\treturn 0;\n}\n\n \nint drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t      struct drm_plane *primary,\n\t\t\t      struct drm_plane *cursor,\n\t\t\t      const struct drm_crtc_funcs *funcs,\n\t\t\t      const char *name, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tWARN_ON(!funcs->destroy);\n\n\tva_start(ap, name);\n\tret = __drm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs,\n\t\t\t\t\t  name, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_crtc_init_with_planes);\n\nstatic void drmm_crtc_init_with_planes_cleanup(struct drm_device *dev,\n\t\t\t\t\t       void *ptr)\n{\n\tstruct drm_crtc *crtc = ptr;\n\n\tdrm_crtc_cleanup(crtc);\n}\n\n__printf(6, 0)\nstatic int __drmm_crtc_init_with_planes(struct drm_device *dev,\n\t\t\t\t\tstruct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_plane *primary,\n\t\t\t\t\tstruct drm_plane *cursor,\n\t\t\t\t\tconst struct drm_crtc_funcs *funcs,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tva_list args)\n{\n\tint ret;\n\n\tdrm_WARN_ON(dev, funcs && funcs->destroy);\n\n\tret = __drm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs,\n\t\t\t\t\t  name, args);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_add_action_or_reset(dev, drmm_crtc_init_with_planes_cleanup,\n\t\t\t\t       crtc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint drmm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t\t       struct drm_plane *primary,\n\t\t\t       struct drm_plane *cursor,\n\t\t\t       const struct drm_crtc_funcs *funcs,\n\t\t\t       const char *name, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, name);\n\tret = __drmm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs,\n\t\t\t\t\t   name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drmm_crtc_init_with_planes);\n\nvoid *__drmm_crtc_alloc_with_planes(struct drm_device *dev,\n\t\t\t\t    size_t size, size_t offset,\n\t\t\t\t    struct drm_plane *primary,\n\t\t\t\t    struct drm_plane *cursor,\n\t\t\t\t    const struct drm_crtc_funcs *funcs,\n\t\t\t\t    const char *name, ...)\n{\n\tvoid *container;\n\tstruct drm_crtc *crtc;\n\tva_list ap;\n\tint ret;\n\n\tif (WARN_ON(!funcs || funcs->destroy))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcontainer = drmm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc = container + offset;\n\n\tva_start(ap, name);\n\tret = __drmm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs,\n\t\t\t\t\t   name, ap);\n\tva_end(ap);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn container;\n}\nEXPORT_SYMBOL(__drmm_crtc_alloc_with_planes);\n\n \nvoid drm_crtc_cleanup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\n\t \n\n\tdrm_crtc_crc_fini(crtc);\n\n\tkfree(crtc->gamma_store);\n\tcrtc->gamma_store = NULL;\n\n\tdrm_modeset_lock_fini(&crtc->mutex);\n\n\tdrm_mode_object_unregister(dev, &crtc->base);\n\tlist_del(&crtc->head);\n\tdev->mode_config.num_crtc--;\n\n\tWARN_ON(crtc->state && !crtc->funcs->atomic_destroy_state);\n\tif (crtc->state && crtc->funcs->atomic_destroy_state)\n\t\tcrtc->funcs->atomic_destroy_state(crtc, crtc->state);\n\n\tkfree(crtc->name);\n\n\tmemset(crtc, 0, sizeof(*crtc));\n}\nEXPORT_SYMBOL(drm_crtc_cleanup);\n\n \nint drm_mode_getcrtc(struct drm_device *dev,\n\t\t     void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_crtc *crtc_resp = data;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tcrtc = drm_crtc_find(dev, file_priv, crtc_resp->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\tplane = crtc->primary;\n\n\tcrtc_resp->gamma_size = crtc->gamma_size;\n\n\tdrm_modeset_lock(&plane->mutex, NULL);\n\tif (plane->state && plane->state->fb)\n\t\tcrtc_resp->fb_id = plane->state->fb->base.id;\n\telse if (!plane->state && plane->fb)\n\t\tcrtc_resp->fb_id = plane->fb->base.id;\n\telse\n\t\tcrtc_resp->fb_id = 0;\n\n\tif (plane->state) {\n\t\tcrtc_resp->x = plane->state->src_x >> 16;\n\t\tcrtc_resp->y = plane->state->src_y >> 16;\n\t}\n\tdrm_modeset_unlock(&plane->mutex);\n\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state) {\n\t\tif (crtc->state->enable) {\n\t\t\tdrm_mode_convert_to_umode(&crtc_resp->mode, &crtc->state->mode);\n\t\t\tcrtc_resp->mode_valid = 1;\n\t\t} else {\n\t\t\tcrtc_resp->mode_valid = 0;\n\t\t}\n\t} else {\n\t\tcrtc_resp->x = crtc->x;\n\t\tcrtc_resp->y = crtc->y;\n\n\t\tif (crtc->enabled) {\n\t\t\tdrm_mode_convert_to_umode(&crtc_resp->mode, &crtc->mode);\n\t\t\tcrtc_resp->mode_valid = 1;\n\n\t\t} else {\n\t\t\tcrtc_resp->mode_valid = 0;\n\t\t}\n\t}\n\tif (!file_priv->aspect_ratio_allowed)\n\t\tcrtc_resp->mode.flags &= ~DRM_MODE_FLAG_PIC_AR_MASK;\n\tdrm_modeset_unlock(&crtc->mutex);\n\n\treturn 0;\n}\n\nstatic int __drm_mode_set_config_internal(struct drm_mode_set *set,\n\t\t\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_crtc *crtc = set->crtc;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_crtc *tmp;\n\tint ret;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(crtc->dev));\n\n\t \n\tdrm_for_each_crtc(tmp, crtc->dev) {\n\t\tstruct drm_plane *plane = tmp->primary;\n\n\t\tplane->old_fb = plane->fb;\n\t}\n\n\tfb = set->fb;\n\n\tret = crtc->funcs->set_config(set, ctx);\n\tif (ret == 0) {\n\t\tstruct drm_plane *plane = crtc->primary;\n\n\t\tplane->crtc = fb ? crtc : NULL;\n\t\tplane->fb = fb;\n\t}\n\n\tdrm_for_each_crtc(tmp, crtc->dev) {\n\t\tstruct drm_plane *plane = tmp->primary;\n\n\t\tif (plane->fb)\n\t\t\tdrm_framebuffer_get(plane->fb);\n\t\tif (plane->old_fb)\n\t\t\tdrm_framebuffer_put(plane->old_fb);\n\t\tplane->old_fb = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nint drm_mode_set_config_internal(struct drm_mode_set *set)\n{\n\tWARN_ON(drm_drv_uses_atomic_modeset(set->crtc->dev));\n\n\treturn __drm_mode_set_config_internal(set, NULL);\n}\nEXPORT_SYMBOL(drm_mode_set_config_internal);\n\n \nint drm_crtc_check_viewport(const struct drm_crtc *crtc,\n\t\t\t    int x, int y,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    const struct drm_framebuffer *fb)\n\n{\n\tint hdisplay, vdisplay;\n\n\tdrm_mode_get_hv_timing(mode, &hdisplay, &vdisplay);\n\n\tif (crtc->state &&\n\t    drm_rotation_90_or_270(crtc->primary->state->rotation))\n\t\tswap(hdisplay, vdisplay);\n\n\treturn drm_framebuffer_check_src_coords(x << 16, y << 16,\n\t\t\t\t\t\thdisplay << 16, vdisplay << 16,\n\t\t\t\t\t\tfb);\n}\nEXPORT_SYMBOL(drm_crtc_check_viewport);\n\n \nint drm_mode_setcrtc(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_mode_crtc *crtc_req = data;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\tstruct drm_connector **connector_set = NULL, *connector;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_mode_set set;\n\tuint32_t __user *set_connectors_ptr;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret, i, num_connectors = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (crtc_req->x & 0xffff0000 || crtc_req->y & 0xffff0000)\n\t\treturn -ERANGE;\n\n\tcrtc = drm_crtc_find(dev, file_priv, crtc_req->crtc_id);\n\tif (!crtc) {\n\t\tDRM_DEBUG_KMS(\"Unknown CRTC ID %d\\n\", crtc_req->crtc_id);\n\t\treturn -ENOENT;\n\t}\n\tDRM_DEBUG_KMS(\"[CRTC:%d:%s]\\n\", crtc->base.id, crtc->name);\n\n\tplane = crtc->primary;\n\n\t \n\tif (crtc_req->mode_valid && !drm_lease_held(file_priv, plane->base.id))\n\t\treturn -EACCES;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx,\n\t\t\t\t   DRM_MODESET_ACQUIRE_INTERRUPTIBLE, ret);\n\n\tif (crtc_req->mode_valid) {\n\t\t \n\t\t \n\t\tif (crtc_req->fb_id == -1) {\n\t\t\tstruct drm_framebuffer *old_fb;\n\n\t\t\tif (plane->state)\n\t\t\t\told_fb = plane->state->fb;\n\t\t\telse\n\t\t\t\told_fb = plane->fb;\n\n\t\t\tif (!old_fb) {\n\t\t\t\tDRM_DEBUG_KMS(\"CRTC doesn't have current FB\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfb = old_fb;\n\t\t\t \n\t\t\tdrm_framebuffer_get(fb);\n\t\t} else {\n\t\t\tfb = drm_framebuffer_lookup(dev, file_priv, crtc_req->fb_id);\n\t\t\tif (!fb) {\n\t\t\t\tDRM_DEBUG_KMS(\"Unknown FB ID%d\\n\",\n\t\t\t\t\t\tcrtc_req->fb_id);\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tmode = drm_mode_create(dev);\n\t\tif (!mode) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!file_priv->aspect_ratio_allowed &&\n\t\t    (crtc_req->mode.flags & DRM_MODE_FLAG_PIC_AR_MASK) != DRM_MODE_FLAG_PIC_AR_NONE) {\n\t\t\tDRM_DEBUG_KMS(\"Unexpected aspect-ratio flag bits\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\n\t\tret = drm_mode_convert_umode(dev, mode, &crtc_req->mode);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_KMS(\"Invalid mode (ret=%d, status=%s)\\n\",\n\t\t\t\t      ret, drm_get_mode_status_name(mode->status));\n\t\t\tdrm_mode_debug_printmodeline(mode);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!plane->format_default) {\n\t\t\tret = drm_plane_check_pixel_format(plane,\n\t\t\t\t\t\t\t   fb->format->format,\n\t\t\t\t\t\t\t   fb->modifier);\n\t\t\tif (ret) {\n\t\t\t\tDRM_DEBUG_KMS(\"Invalid pixel format %p4cc, modifier 0x%llx\\n\",\n\t\t\t\t\t      &fb->format->format,\n\t\t\t\t\t      fb->modifier);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = drm_crtc_check_viewport(crtc, crtc_req->x, crtc_req->y,\n\t\t\t\t\t      mode, fb);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t}\n\n\tif (crtc_req->count_connectors == 0 && mode) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is 0 but mode set\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0 && (!mode || !fb)) {\n\t\tDRM_DEBUG_KMS(\"Count connectors is %d but no mode or fb set\\n\",\n\t\t\t  crtc_req->count_connectors);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crtc_req->count_connectors > 0) {\n\t\tu32 out_id;\n\n\t\t \n\t\tif (crtc_req->count_connectors > config->num_connector) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconnector_set = kmalloc_array(crtc_req->count_connectors,\n\t\t\t\t\t      sizeof(struct drm_connector *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!connector_set) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < crtc_req->count_connectors; i++) {\n\t\t\tconnector_set[i] = NULL;\n\t\t\tset_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;\n\t\t\tif (get_user(out_id, &set_connectors_ptr[i])) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tconnector = drm_connector_lookup(dev, file_priv, out_id);\n\t\t\tif (!connector) {\n\t\t\t\tDRM_DEBUG_KMS(\"Connector id %d unknown\\n\",\n\t\t\t\t\t\tout_id);\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\",\n\t\t\t\t\tconnector->base.id,\n\t\t\t\t\tconnector->name);\n\n\t\t\tconnector_set[i] = connector;\n\t\t\tnum_connectors++;\n\t\t}\n\t}\n\n\tset.crtc = crtc;\n\tset.x = crtc_req->x;\n\tset.y = crtc_req->y;\n\tset.mode = mode;\n\tset.connectors = connector_set;\n\tset.num_connectors = num_connectors;\n\tset.fb = fb;\n\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = crtc->funcs->set_config(&set, &ctx);\n\telse\n\t\tret = __drm_mode_set_config_internal(&set, &ctx);\n\nout:\n\tif (fb)\n\t\tdrm_framebuffer_put(fb);\n\n\tif (connector_set) {\n\t\tfor (i = 0; i < num_connectors; i++) {\n\t\t\tif (connector_set[i])\n\t\t\t\tdrm_connector_put(connector_set[i]);\n\t\t}\n\t}\n\tkfree(connector_set);\n\tdrm_mode_destroy(dev, mode);\n\n\t \n\tconnector_set = NULL;\n\tfb = NULL;\n\tmode = NULL;\n\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n\n\treturn ret;\n}\n\nint drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,\n\t\t\t       struct drm_property *property,\n\t\t\t       uint64_t value)\n{\n\tint ret = -EINVAL;\n\tstruct drm_crtc *crtc = obj_to_crtc(obj);\n\n\tif (crtc->funcs->set_property)\n\t\tret = crtc->funcs->set_property(crtc, property, value);\n\tif (!ret)\n\t\tdrm_object_property_set_value(obj, property, value);\n\n\treturn ret;\n}\n\n \nint drm_crtc_create_scaling_filter_property(struct drm_crtc *crtc,\n\t\t\t\t\t    unsigned int supported_filters)\n{\n\tstruct drm_property *prop =\n\t\tdrm_create_scaling_filter_prop(crtc->dev, supported_filters);\n\n\tif (IS_ERR(prop))\n\t\treturn PTR_ERR(prop);\n\n\tdrm_object_attach_property(&crtc->base, prop,\n\t\t\t\t   DRM_SCALING_FILTER_DEFAULT);\n\tcrtc->scaling_filter_property = prop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_crtc_create_scaling_filter_property);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}