{
  "module_name": "ch7006_drv.c",
  "hash_id": "e9af4973971ab860a2e6cd1ce3b375d75c92ec1f7966c8919c4a50f478a3b3c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i2c/ch7006_drv.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <drm/drm_crtc_helper.h>\n\n#include \"ch7006_priv.h\"\n\n \n\nstatic void ch7006_encoder_set_config(struct drm_encoder *encoder,\n\t\t\t\t      void *params)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\n\tpriv->params = *(struct ch7006_encoder_params *)params;\n}\n\nstatic void ch7006_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\n\tdrm_property_destroy(encoder->dev, priv->scale_property);\n\n\tkfree(priv);\n\tto_encoder_slave(encoder)->slave_priv = NULL;\n\n\tdrm_i2c_encoder_destroy(encoder);\n}\n\nstatic void  ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_state *state = &priv->state;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tif (mode == priv->last_dpms)\n\t\treturn;\n\tpriv->last_dpms = mode;\n\n\tch7006_setup_power_state(encoder);\n\n\tch7006_load_reg(client, state, CH7006_POWER);\n}\n\nstatic void ch7006_encoder_save(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\n\tch7006_dbg(client, \"\\n\");\n\n\tch7006_state_save(client, &priv->saved_state);\n}\n\nstatic void ch7006_encoder_restore(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\n\tch7006_dbg(client, \"\\n\");\n\n\tch7006_state_load(client, &priv->saved_state);\n}\n\nstatic bool ch7006_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\n\t \n\n\tpriv->mode = ch7006_lookup_mode(encoder, mode);\n\n\treturn !!priv->mode;\n}\n\nstatic int ch7006_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tif (ch7006_lookup_mode(encoder, mode))\n\t\treturn MODE_OK;\n\telse\n\t\treturn MODE_BAD;\n}\n\nstatic void ch7006_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t     struct drm_display_mode *drm_mode,\n\t\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_encoder_params *params = &priv->params;\n\tstruct ch7006_state *state = &priv->state;\n\tuint8_t *regs = state->regs;\n\tconst struct ch7006_mode *mode = priv->mode;\n\tconst struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\n\tint start_active;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tregs[CH7006_DISPMODE] = norm->dispmode | mode->dispmode;\n\tregs[CH7006_BWIDTH] = 0;\n\tregs[CH7006_INPUT_FORMAT] = bitf(CH7006_INPUT_FORMAT_FORMAT,\n\t\t\t\t\t params->input_format);\n\n\tregs[CH7006_CLKMODE] = CH7006_CLKMODE_SUBC_LOCK\n\t\t| bitf(CH7006_CLKMODE_XCM, params->xcm)\n\t\t| bitf(CH7006_CLKMODE_PCM, params->pcm);\n\tif (params->clock_mode)\n\t\tregs[CH7006_CLKMODE] |= CH7006_CLKMODE_MASTER;\n\tif (params->clock_edge)\n\t\tregs[CH7006_CLKMODE] |= CH7006_CLKMODE_POS_EDGE;\n\n\tstart_active = (drm_mode->htotal & ~0x7) - (drm_mode->hsync_start & ~0x7);\n\tregs[CH7006_POV] = bitf(CH7006_POV_START_ACTIVE_8, start_active);\n\tregs[CH7006_START_ACTIVE] = bitf(CH7006_START_ACTIVE_0, start_active);\n\n\tregs[CH7006_INPUT_SYNC] = 0;\n\tif (params->sync_direction)\n\t\tregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_OUTPUT;\n\tif (params->sync_encoding)\n\t\tregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_EMBEDDED;\n\tif (drm_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PVSYNC;\n\tif (drm_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PHSYNC;\n\n\tregs[CH7006_DETECT] = 0;\n\tregs[CH7006_BCLKOUT] = 0;\n\n\tregs[CH7006_SUBC_INC3] = 0;\n\tif (params->pout_level)\n\t\tregs[CH7006_SUBC_INC3] |= CH7006_SUBC_INC3_POUT_3_3V;\n\n\tregs[CH7006_SUBC_INC4] = 0;\n\tif (params->active_detect)\n\t\tregs[CH7006_SUBC_INC4] |= CH7006_SUBC_INC4_DS_INPUT;\n\n\tregs[CH7006_PLL_CONTROL] = priv->saved_state.regs[CH7006_PLL_CONTROL];\n\n\tch7006_setup_levels(encoder);\n\tch7006_setup_subcarrier(encoder);\n\tch7006_setup_pll(encoder);\n\tch7006_setup_power_state(encoder);\n\tch7006_setup_properties(encoder);\n\n\tch7006_state_load(client, state);\n}\n\nstatic enum drm_connector_status ch7006_encoder_detect(struct drm_encoder *encoder,\n\t\t\t\t\t\t       struct drm_connector *connector)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_state *state = &priv->state;\n\tint det;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tch7006_save_reg(client, state, CH7006_DETECT);\n\tch7006_save_reg(client, state, CH7006_POWER);\n\tch7006_save_reg(client, state, CH7006_CLKMODE);\n\n\tch7006_write(client, CH7006_POWER, CH7006_POWER_RESET |\n\t\t\t\t\t   bitfs(CH7006_POWER_LEVEL, NORMAL));\n\tch7006_write(client, CH7006_CLKMODE, CH7006_CLKMODE_MASTER);\n\n\tch7006_write(client, CH7006_DETECT, CH7006_DETECT_SENSE);\n\n\tch7006_write(client, CH7006_DETECT, 0);\n\n\tdet = ch7006_read(client, CH7006_DETECT);\n\n\tch7006_load_reg(client, state, CH7006_CLKMODE);\n\tch7006_load_reg(client, state, CH7006_POWER);\n\tch7006_load_reg(client, state, CH7006_DETECT);\n\n\tif ((det & (CH7006_DETECT_SVIDEO_Y_TEST|\n\t\t    CH7006_DETECT_SVIDEO_C_TEST|\n\t\t    CH7006_DETECT_CVBS_TEST)) == 0)\n\t\tpriv->subconnector = DRM_MODE_SUBCONNECTOR_SCART;\n\telse if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|\n\t\t\t CH7006_DETECT_SVIDEO_C_TEST)) == 0)\n\t\tpriv->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;\n\telse if ((det & CH7006_DETECT_CVBS_TEST) == 0)\n\t\tpriv->subconnector = DRM_MODE_SUBCONNECTOR_Composite;\n\telse\n\t\tpriv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\n\tdrm_object_property_set_value(&connector->base,\n\t\t\tencoder->dev->mode_config.tv_subconnector_property,\n\t\t\t\t\t\t\tpriv->subconnector);\n\n\treturn priv->subconnector ? connector_status_connected :\n\t\t\t\t\tconnector_status_disconnected;\n}\n\nstatic int ch7006_encoder_get_modes(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tconst struct ch7006_mode *mode;\n\tint n = 0;\n\n\tfor (mode = ch7006_modes; mode->mode.clock; mode++) {\n\t\tif (~mode->valid_scales & 1<<priv->scale ||\n\t\t    ~mode->valid_norms & 1<<priv->norm)\n\t\t\tcontinue;\n\n\t\tdrm_mode_probed_add(connector,\n\t\t\t\tdrm_mode_duplicate(encoder->dev, &mode->mode));\n\n\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic int ch7006_encoder_create_resources(struct drm_encoder *encoder,\n\t\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_mode_config *conf = &dev->mode_config;\n\n\tdrm_mode_create_tv_properties_legacy(dev, NUM_TV_NORMS, ch7006_tv_norm_names);\n\n\tpriv->scale_property = drm_property_create_range(dev, 0, \"scale\", 0, 2);\n\tif (!priv->scale_property)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&connector->base, conf->tv_select_subconnector_property,\n\t\t\t\t      priv->select_subconnector);\n\tdrm_object_attach_property(&connector->base, conf->tv_subconnector_property,\n\t\t\t\t      priv->subconnector);\n\tdrm_object_attach_property(&connector->base, conf->tv_left_margin_property,\n\t\t\t\t      priv->hmargin);\n\tdrm_object_attach_property(&connector->base, conf->tv_bottom_margin_property,\n\t\t\t\t      priv->vmargin);\n\tdrm_object_attach_property(&connector->base, conf->legacy_tv_mode_property,\n\t\t\t\t   priv->norm);\n\tdrm_object_attach_property(&connector->base, conf->tv_brightness_property,\n\t\t\t\t      priv->brightness);\n\tdrm_object_attach_property(&connector->base, conf->tv_contrast_property,\n\t\t\t\t      priv->contrast);\n\tdrm_object_attach_property(&connector->base, conf->tv_flicker_reduction_property,\n\t\t\t\t      priv->flicker);\n\tdrm_object_attach_property(&connector->base, priv->scale_property,\n\t\t\t\t      priv->scale);\n\n\treturn 0;\n}\n\nstatic int ch7006_encoder_set_property(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_connector *connector,\n\t\t\t\t       struct drm_property *property,\n\t\t\t\t       uint64_t val)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_state *state = &priv->state;\n\tstruct drm_mode_config *conf = &encoder->dev->mode_config;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tbool modes_changed = false;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tif (property == conf->tv_select_subconnector_property) {\n\t\tpriv->select_subconnector = val;\n\n\t\tch7006_setup_power_state(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_POWER);\n\n\t} else if (property == conf->tv_left_margin_property) {\n\t\tpriv->hmargin = val;\n\n\t\tch7006_setup_properties(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_POV);\n\t\tch7006_load_reg(client, state, CH7006_HPOS);\n\n\t} else if (property == conf->tv_bottom_margin_property) {\n\t\tpriv->vmargin = val;\n\n\t\tch7006_setup_properties(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_POV);\n\t\tch7006_load_reg(client, state, CH7006_VPOS);\n\n\t} else if (property == conf->legacy_tv_mode_property) {\n\t\tif (connector->dpms != DRM_MODE_DPMS_OFF)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->norm = val;\n\n\t\tmodes_changed = true;\n\n\t} else if (property == conf->tv_brightness_property) {\n\t\tpriv->brightness = val;\n\n\t\tch7006_setup_levels(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_BLACK_LEVEL);\n\n\t} else if (property == conf->tv_contrast_property) {\n\t\tpriv->contrast = val;\n\n\t\tch7006_setup_properties(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_CONTRAST);\n\n\t} else if (property == conf->tv_flicker_reduction_property) {\n\t\tpriv->flicker = val;\n\n\t\tch7006_setup_properties(encoder);\n\n\t\tch7006_load_reg(client, state, CH7006_FFILTER);\n\n\t} else if (property == priv->scale_property) {\n\t\tif (connector->dpms != DRM_MODE_DPMS_OFF)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->scale = val;\n\n\t\tmodes_changed = true;\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (modes_changed) {\n\t\tdrm_helper_probe_single_connector_modes(connector, 0, 0);\n\n\t\tif (crtc)\n\t\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t\t crtc->x, crtc->y,\n\t\t\t\t\t\t crtc->primary->fb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_slave_funcs ch7006_encoder_funcs = {\n\t.set_config = ch7006_encoder_set_config,\n\t.destroy = ch7006_encoder_destroy,\n\t.dpms = ch7006_encoder_dpms,\n\t.save = ch7006_encoder_save,\n\t.restore = ch7006_encoder_restore,\n\t.mode_fixup = ch7006_encoder_mode_fixup,\n\t.mode_valid = ch7006_encoder_mode_valid,\n\t.mode_set = ch7006_encoder_mode_set,\n\t.detect = ch7006_encoder_detect,\n\t.get_modes = ch7006_encoder_get_modes,\n\t.create_resources = ch7006_encoder_create_resources,\n\t.set_property = ch7006_encoder_set_property,\n};\n\n\n \n\nstatic int ch7006_probe(struct i2c_client *client)\n{\n\tuint8_t addr = CH7006_VERSION_ID;\n\tuint8_t val;\n\tint ret;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tret = i2c_master_send(client, &addr, sizeof(addr));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_master_recv(client, &val, sizeof(val));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tch7006_info(client, \"Detected version ID: %x\\n\", val);\n\n\t \n\tch7006_write(client, 0x3d, 0x0);\n\n\treturn 0;\n\nfail:\n\tch7006_err(client, \"Error %d reading version ID\\n\", ret);\n\n\treturn -ENODEV;\n}\n\nstatic void ch7006_remove(struct i2c_client *client)\n{\n\tch7006_dbg(client, \"\\n\");\n}\n\nstatic int ch7006_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tch7006_dbg(client, \"\\n\");\n\n\tch7006_write(client, 0x3d, 0x0);\n\n\treturn 0;\n}\n\nstatic int ch7006_encoder_init(struct i2c_client *client,\n\t\t\t       struct drm_device *dev,\n\t\t\t       struct drm_encoder_slave *encoder)\n{\n\tstruct ch7006_priv *priv;\n\tint i;\n\n\tch7006_dbg(client, \"\\n\");\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tencoder->slave_priv = priv;\n\tencoder->slave_funcs = &ch7006_encoder_funcs;\n\n\tpriv->norm = TV_NORM_PAL;\n\tpriv->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;\n\tpriv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\tpriv->scale = 1;\n\tpriv->contrast = 50;\n\tpriv->brightness = 50;\n\tpriv->flicker = 50;\n\tpriv->hmargin = 50;\n\tpriv->vmargin = 50;\n\tpriv->last_dpms = -1;\n\tpriv->chip_version = ch7006_read(client, CH7006_VERSION_ID);\n\n\tif (ch7006_tv_norm) {\n\t\tfor (i = 0; i < NUM_TV_NORMS; i++) {\n\t\t\tif (!strcmp(ch7006_tv_norm_names[i], ch7006_tv_norm)) {\n\t\t\t\tpriv->norm = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == NUM_TV_NORMS)\n\t\t\tch7006_err(client, \"Invalid TV norm setting \\\"%s\\\".\\n\",\n\t\t\t\t   ch7006_tv_norm);\n\t}\n\n\tif (ch7006_scale >= 0 && ch7006_scale <= 2)\n\t\tpriv->scale = ch7006_scale;\n\telse\n\t\tch7006_err(client, \"Invalid scale setting \\\"%d\\\".\\n\",\n\t\t\t   ch7006_scale);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ch7006_ids[] = {\n\t{ \"ch7006\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ch7006_ids);\n\nstatic const struct dev_pm_ops ch7006_pm_ops = {\n\t.resume = ch7006_resume,\n};\n\nstatic struct drm_i2c_encoder_driver ch7006_driver = {\n\t.i2c_driver = {\n\t\t.probe = ch7006_probe,\n\t\t.remove = ch7006_remove,\n\n\t\t.driver = {\n\t\t\t.name = \"ch7006\",\n\t\t\t.pm = &ch7006_pm_ops,\n\t\t},\n\n\t\t.id_table = ch7006_ids,\n\t},\n\n\t.encoder_init = ch7006_encoder_init,\n};\n\n\n \n\nstatic int __init ch7006_init(void)\n{\n\treturn drm_i2c_encoder_register(THIS_MODULE, &ch7006_driver);\n}\n\nstatic void __exit ch7006_exit(void)\n{\n\tdrm_i2c_encoder_unregister(&ch7006_driver);\n}\n\nint ch7006_debug;\nmodule_param_named(debug, ch7006_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"Enable debug output.\");\n\nchar *ch7006_tv_norm;\nmodule_param_named(tv_norm, ch7006_tv_norm, charp, 0600);\nMODULE_PARM_DESC(tv_norm, \"Default TV norm.\\n\"\n\t\t \"\\t\\tSupported: PAL, PAL-M, PAL-N, PAL-Nc, PAL-60, NTSC-M, NTSC-J.\\n\"\n\t\t \"\\t\\tDefault: PAL\");\n\nint ch7006_scale = 1;\nmodule_param_named(scale, ch7006_scale, int, 0600);\nMODULE_PARM_DESC(scale, \"Default scale.\\n\"\n\t\t \"\\t\\tSupported: 0 -> Select video modes with a higher blanking ratio.\\n\"\n\t\t \"\\t\\t\\t1 -> Select default video modes.\\n\"\n\t\t \"\\t\\t\\t2 -> Select video modes with a lower blanking ratio.\");\n\nMODULE_AUTHOR(\"Francisco Jerez <currojerez@riseup.net>\");\nMODULE_DESCRIPTION(\"Chrontel ch7006 TV encoder driver\");\nMODULE_LICENSE(\"GPL and additional rights\");\n\nmodule_init(ch7006_init);\nmodule_exit(ch7006_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}