{
  "module_name": "tda9950.c",
  "hash_id": "7c5c00113b926b3c15fd549f75d06fa2af450d625e323e3c761d3e2406c6d65b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i2c/tda9950.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_data/tda9950.h>\n#include <linux/slab.h>\n#include <drm/drm_edid.h>\n#include <media/cec.h>\n#include <media/cec-notifier.h>\n\nenum {\n\tREG_CSR = 0x00,\n\tCSR_BUSY = BIT(7),\n\tCSR_INT  = BIT(6),\n\tCSR_ERR  = BIT(5),\n\n\tREG_CER = 0x01,\n\n\tREG_CVR = 0x02,\n\n\tREG_CCR = 0x03,\n\tCCR_RESET = BIT(7),\n\tCCR_ON    = BIT(6),\n\n\tREG_ACKH = 0x04,\n\tREG_ACKL = 0x05,\n\n\tREG_CCONR = 0x06,\n\tCCONR_ENABLE_ERROR = BIT(4),\n\tCCONR_RETRY_MASK = 7,\n\n\tREG_CDR0 = 0x07,\n\n\tCDR1_REQ = 0x00,\n\tCDR1_CNF = 0x01,\n\tCDR1_IND = 0x81,\n\tCDR1_ERR = 0x82,\n\tCDR1_IER = 0x83,\n\n\tCDR2_CNF_SUCCESS    = 0x00,\n\tCDR2_CNF_OFF_STATE  = 0x80,\n\tCDR2_CNF_BAD_REQ    = 0x81,\n\tCDR2_CNF_CEC_ACCESS = 0x82,\n\tCDR2_CNF_ARB_ERROR  = 0x83,\n\tCDR2_CNF_BAD_TIMING = 0x84,\n\tCDR2_CNF_NACK_ADDR  = 0x85,\n\tCDR2_CNF_NACK_DATA  = 0x86,\n};\n\nstruct tda9950_priv {\n\tstruct i2c_client *client;\n\tstruct device *hdmi;\n\tstruct cec_adapter *adap;\n\tstruct tda9950_glue *glue;\n\tu16 addresses;\n\tstruct cec_msg rx_msg;\n\tstruct cec_notifier *notify;\n\tbool open;\n};\n\nstatic int tda9950_write_range(struct i2c_client *client, u8 addr, u8 *p, int cnt)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[CEC_MAX_MSG_SIZE + 3];\n\tint ret;\n\n\tif (WARN_ON(cnt > sizeof(buf) - 1))\n\t\treturn -EINVAL;\n\n\tbuf[0] = addr;\n\tmemcpy(buf + 1, p, cnt);\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = cnt + 1;\n\tmsg.buf = buf;\n\n\tdev_dbg(&client->dev, \"wr 0x%02x: %*ph\\n\", addr, cnt, p);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error %d writing to cec:0x%x\\n\", ret, addr);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void tda9950_write(struct i2c_client *client, u8 addr, u8 val)\n{\n\ttda9950_write_range(client, addr, &val, 1);\n}\n\nstatic int tda9950_read_range(struct i2c_client *client, u8 addr, u8 *p, int cnt)\n{\n\tstruct i2c_msg msg[2];\n\tint ret;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = &addr;\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = cnt;\n\tmsg[1].buf = p;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error %d reading from cec:0x%x\\n\", ret, addr);\n\n\tdev_dbg(&client->dev, \"rd 0x%02x: %*ph\\n\", addr, cnt, p);\n\n\treturn ret;\n}\n\nstatic u8 tda9950_read(struct i2c_client *client, u8 addr)\n{\n\tint ret;\n\tu8 val;\n\n\tret = tda9950_read_range(client, addr, &val, 1);\n\tif (ret < 0)\n\t\tval = 0;\n\n\treturn val;\n}\n\nstatic irqreturn_t tda9950_irq(int irq, void *data)\n{\n\tstruct tda9950_priv *priv = data;\n\tunsigned int tx_status;\n\tu8 csr, cconr, buf[19];\n\tu8 arb_lost_cnt, nack_cnt, err_cnt;\n\n\tif (!priv->open)\n\t\treturn IRQ_NONE;\n\n\tcsr = tda9950_read(priv->client, REG_CSR);\n\tif (!(csr & CSR_INT))\n\t\treturn IRQ_NONE;\n\n\tcconr = tda9950_read(priv->client, REG_CCONR) & CCONR_RETRY_MASK;\n\n\ttda9950_read_range(priv->client, REG_CDR0, buf, sizeof(buf));\n\n\t \n\tif (buf[0] == 0) {\n\t\tdev_warn(&priv->client->dev, \"interrupt pending, but no message?\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tswitch (buf[1]) {\n\tcase CDR1_CNF:  \n\t\tarb_lost_cnt = nack_cnt = err_cnt = 0;\n\t\tswitch (buf[2]) {\n\t\tcase CDR2_CNF_SUCCESS:\n\t\t\ttx_status = CEC_TX_STATUS_OK;\n\t\t\tbreak;\n\n\t\tcase CDR2_CNF_ARB_ERROR:\n\t\t\ttx_status = CEC_TX_STATUS_ARB_LOST;\n\t\t\tarb_lost_cnt = cconr;\n\t\t\tbreak;\n\n\t\tcase CDR2_CNF_NACK_ADDR:\n\t\t\ttx_status = CEC_TX_STATUS_NACK;\n\t\t\tnack_cnt = cconr;\n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\tdev_err(&priv->client->dev, \"CNF reply error 0x%02x\\n\",\n\t\t\t\tbuf[2]);\n\t\t\ttx_status = CEC_TX_STATUS_ERROR;\n\t\t\terr_cnt = cconr;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (tx_status != CEC_TX_STATUS_OK)\n\t\t\ttx_status |= CEC_TX_STATUS_MAX_RETRIES;\n\t\tcec_transmit_done(priv->adap, tx_status, arb_lost_cnt,\n\t\t\t\t  nack_cnt, 0, err_cnt);\n\t\tbreak;\n\n\tcase CDR1_IND:\n\t\tpriv->rx_msg.len = buf[0] - 2;\n\t\tif (priv->rx_msg.len > CEC_MAX_MSG_SIZE)\n\t\t\tpriv->rx_msg.len = CEC_MAX_MSG_SIZE;\n\n\t\tmemcpy(priv->rx_msg.msg, buf + 2, priv->rx_msg.len);\n\t\tcec_received_msg(priv->adap, &priv->rx_msg);\n\t\tbreak;\n\n\tdefault:  \n\t\tdev_err(&priv->client->dev, \"unknown service id 0x%02x\\n\",\n\t\t\tbuf[1]);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tda9950_cec_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\tu32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct tda9950_priv *priv = adap->priv;\n\tu8 buf[CEC_MAX_MSG_SIZE + 2];\n\n\tbuf[0] = 2 + msg->len;\n\tbuf[1] = CDR1_REQ;\n\tmemcpy(buf + 2, msg->msg, msg->len);\n\n\tif (attempts > 5)\n\t\tattempts = 5;\n\n\ttda9950_write(priv->client, REG_CCONR, attempts);\n\n\treturn tda9950_write_range(priv->client, REG_CDR0, buf, 2 + msg->len);\n}\n\nstatic int tda9950_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct tda9950_priv *priv = adap->priv;\n\tu16 addresses;\n\tu8 buf[2];\n\n\tif (addr == CEC_LOG_ADDR_INVALID)\n\t\taddresses = priv->addresses = 0;\n\telse\n\t\taddresses = priv->addresses |= BIT(addr);\n\n\t \n\taddresses &= 0x7fff;\n\tbuf[0] = addresses >> 8;\n\tbuf[1] = addresses;\n\n\treturn tda9950_write_range(priv->client, REG_ACKH, buf, 2);\n}\n\n \nstatic int tda9950_glue_open(struct tda9950_priv *priv)\n{\n\tint ret = 0;\n\n\tif (priv->glue && priv->glue->open)\n\t\tret = priv->glue->open(priv->glue->data);\n\n\tpriv->open = true;\n\n\treturn ret;\n}\n\nstatic void tda9950_glue_release(struct tda9950_priv *priv)\n{\n\tpriv->open = false;\n\n\tif (priv->glue && priv->glue->release)\n\t\tpriv->glue->release(priv->glue->data);\n}\n\nstatic int tda9950_open(struct tda9950_priv *priv)\n{\n\tstruct i2c_client *client = priv->client;\n\tint ret;\n\n\tret = tda9950_glue_open(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttda9950_write(client, REG_CCR, CCR_RESET);\n\tmsleep(250);\n\n\ttda9950_cec_adap_log_addr(priv->adap, CEC_LOG_ADDR_INVALID);\n\n\t \n\ttda9950_write(client, REG_CCR, CCR_ON);\n\n\treturn 0;\n}\n\nstatic void tda9950_release(struct tda9950_priv *priv)\n{\n\tstruct i2c_client *client = priv->client;\n\tint timeout = 50;\n\tu8 csr;\n\n\t \n\ttda9950_write(client, REG_CCR, 0);\n\n\t \n\tdo {\n\t\tcsr = tda9950_read(client, REG_CSR);\n\t\tif (!(csr & CSR_BUSY) || !--timeout)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t} while (1);\n\n\t \n\tif (csr & CSR_BUSY)\n\t\tdev_warn(&client->dev, \"command processor failed to stop, irq%d may die (csr=0x%02x)\\n\",\n\t\t\t client->irq, csr);\n\n\ttda9950_glue_release(priv);\n}\n\nstatic int tda9950_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct tda9950_priv *priv = adap->priv;\n\n\tif (!enable) {\n\t\ttda9950_release(priv);\n\t\treturn 0;\n\t} else {\n\t\treturn tda9950_open(priv);\n\t}\n}\n\nstatic const struct cec_adap_ops tda9950_cec_ops = {\n\t.adap_enable = tda9950_cec_adap_enable,\n\t.adap_log_addr = tda9950_cec_adap_log_addr,\n\t.adap_transmit = tda9950_cec_transmit,\n};\n\n \nstatic void tda9950_devm_glue_exit(void *data)\n{\n\tstruct tda9950_glue *glue = data;\n\n\tif (glue && glue->exit)\n\t\tglue->exit(glue->data);\n}\n\nstatic int tda9950_devm_glue_init(struct device *dev, struct tda9950_glue *glue)\n{\n\tint ret;\n\n\tif (glue && glue->init) {\n\t\tret = glue->init(glue->data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_add_action(dev, tda9950_devm_glue_exit, glue);\n\tif (ret)\n\t\ttda9950_devm_glue_exit(glue);\n\n\treturn ret;\n}\n\nstatic void tda9950_cec_del(void *data)\n{\n\tstruct tda9950_priv *priv = data;\n\n\tcec_delete_adapter(priv->adap);\n}\n\nstatic int tda9950_probe(struct i2c_client *client)\n{\n\tstruct tda9950_glue *glue = client->dev.platform_data;\n\tstruct device *dev = &client->dev;\n\tstruct tda9950_priv *priv;\n\tunsigned long irqflags;\n\tint ret;\n\tu8 cvr;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"adapter does not support I2C functionality\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (client->irq <= 0) {\n\t\tdev_err(&client->dev, \"driver requires an interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\tpriv->glue = glue;\n\n\ti2c_set_clientdata(client, priv);\n\n\t \n\tpriv->hdmi = dev;\n\tif (glue && glue->parent)\n\t\tpriv->hdmi = glue->parent;\n\n\tpriv->adap = cec_allocate_adapter(&tda9950_cec_ops, priv, \"tda9950\",\n\t\t\t\t\t  CEC_CAP_DEFAULTS |\n\t\t\t\t\t  CEC_CAP_CONNECTOR_INFO,\n\t\t\t\t\t  CEC_MAX_LOG_ADDRS);\n\tif (IS_ERR(priv->adap))\n\t\treturn PTR_ERR(priv->adap);\n\n\tret = devm_add_action(dev, tda9950_cec_del, priv);\n\tif (ret) {\n\t\tcec_delete_adapter(priv->adap);\n\t\treturn ret;\n\t}\n\n\tret = tda9950_devm_glue_init(dev, glue);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tda9950_glue_open(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tcvr = tda9950_read(client, REG_CVR);\n\n\tdev_info(&client->dev,\n\t\t \"TDA9950 CEC interface, hardware version %u.%u\\n\",\n\t\t cvr >> 4, cvr & 15);\n\n\ttda9950_glue_release(priv);\n\n\tirqflags = IRQF_TRIGGER_FALLING;\n\tif (glue)\n\t\tirqflags = glue->irq_flags;\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL, tda9950_irq,\n\t\t\t\t\tirqflags | IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&client->dev), priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->notify = cec_notifier_cec_adap_register(priv->hdmi, NULL,\n\t\t\t\t\t\t      priv->adap);\n\tif (!priv->notify)\n\t\treturn -ENOMEM;\n\n\tret = cec_register_adapter(priv->adap, priv->hdmi);\n\tif (ret < 0) {\n\t\tcec_notifier_cec_adap_unregister(priv->notify, priv->adap);\n\t\treturn ret;\n\t}\n\n\t \n\tdevm_remove_action(dev, tda9950_cec_del, priv);\n\n\treturn 0;\n}\n\nstatic void tda9950_remove(struct i2c_client *client)\n{\n\tstruct tda9950_priv *priv = i2c_get_clientdata(client);\n\n\tcec_notifier_cec_adap_unregister(priv->notify, priv->adap);\n\tcec_unregister_adapter(priv->adap);\n}\n\nstatic struct i2c_device_id tda9950_ids[] = {\n\t{ \"tda9950\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tda9950_ids);\n\nstatic struct i2c_driver tda9950_driver = {\n\t.probe = tda9950_probe,\n\t.remove = tda9950_remove,\n\t.driver = {\n\t\t.name = \"tda9950\",\n\t},\n\t.id_table = tda9950_ids,\n};\n\nmodule_i2c_driver(tda9950_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk+kernel@armlinux.org.uk>\");\nMODULE_DESCRIPTION(\"TDA9950/TDA998x Consumer Electronics Control Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}