{
  "module_name": "sil164_drv.c",
  "hash_id": "8a3ef0589c79655231691892eef0a42a7365d16ac320f7c30ee74019d269b511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i2c/sil164_drv.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder_slave.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/i2c/sil164.h>\n\nstruct sil164_priv {\n\tstruct sil164_encoder_params config;\n\tstruct i2c_client *duallink_slave;\n\n\tuint8_t saved_state[0x10];\n\tuint8_t saved_slave_state[0x10];\n};\n\n#define to_sil164_priv(x) \\\n\t((struct sil164_priv *)to_encoder_slave(x)->slave_priv)\n\n#define sil164_dbg(client, format, ...) do {\t\t\t\t\\\n\t\tif (drm_debug_enabled(DRM_UT_KMS))\t\t\t\\\n\t\t\tdev_printk(KERN_DEBUG, &client->dev,\t\t\\\n\t\t\t\t   \"%s: \" format, __func__, ## __VA_ARGS__); \\\n\t} while (0)\n#define sil164_info(client, format, ...)\t\t\\\n\tdev_info(&client->dev, format, __VA_ARGS__)\n#define sil164_err(client, format, ...)\t\t\t\\\n\tdev_err(&client->dev, format, __VA_ARGS__)\n\n#define SIL164_I2C_ADDR_MASTER\t\t\t0x38\n#define SIL164_I2C_ADDR_SLAVE\t\t\t0x39\n\n \n\n#define SIL164_VENDOR_LO\t\t\t0x0\n#define SIL164_VENDOR_HI\t\t\t0x1\n#define SIL164_DEVICE_LO\t\t\t0x2\n#define SIL164_DEVICE_HI\t\t\t0x3\n#define SIL164_REVISION\t\t\t\t0x4\n#define SIL164_FREQ_MIN\t\t\t\t0x6\n#define SIL164_FREQ_MAX\t\t\t\t0x7\n#define SIL164_CONTROL0\t\t\t\t0x8\n#  define SIL164_CONTROL0_POWER_ON\t\t0x01\n#  define SIL164_CONTROL0_EDGE_RISING\t\t0x02\n#  define SIL164_CONTROL0_INPUT_24BIT\t\t0x04\n#  define SIL164_CONTROL0_DUAL_EDGE\t\t0x08\n#  define SIL164_CONTROL0_HSYNC_ON\t\t0x10\n#  define SIL164_CONTROL0_VSYNC_ON\t\t0x20\n#define SIL164_DETECT\t\t\t\t0x9\n#  define SIL164_DETECT_INTR_STAT\t\t0x01\n#  define SIL164_DETECT_HOTPLUG_STAT\t\t0x02\n#  define SIL164_DETECT_RECEIVER_STAT\t\t0x04\n#  define SIL164_DETECT_INTR_MODE_RECEIVER\t0x00\n#  define SIL164_DETECT_INTR_MODE_HOTPLUG\t0x08\n#  define SIL164_DETECT_OUT_MODE_HIGH\t\t0x00\n#  define SIL164_DETECT_OUT_MODE_INTR\t\t0x10\n#  define SIL164_DETECT_OUT_MODE_RECEIVER\t0x20\n#  define SIL164_DETECT_OUT_MODE_HOTPLUG\t0x30\n#  define SIL164_DETECT_VSWING_STAT\t\t0x80\n#define SIL164_CONTROL1\t\t\t\t0xa\n#  define SIL164_CONTROL1_DESKEW_ENABLE\t\t0x10\n#  define SIL164_CONTROL1_DESKEW_INCR_SHIFT\t5\n#define SIL164_GPIO\t\t\t\t0xb\n#define SIL164_CONTROL2\t\t\t\t0xc\n#  define SIL164_CONTROL2_FILTER_ENABLE\t\t0x01\n#  define SIL164_CONTROL2_FILTER_SETTING_SHIFT\t1\n#  define SIL164_CONTROL2_DUALLINK_MASTER\t0x40\n#  define SIL164_CONTROL2_SYNC_CONT\t\t0x80\n#define SIL164_DUALLINK\t\t\t\t0xd\n#  define SIL164_DUALLINK_ENABLE\t\t0x10\n#  define SIL164_DUALLINK_SKEW_SHIFT\t\t5\n#define SIL164_PLLZONE\t\t\t\t0xe\n#  define SIL164_PLLZONE_STAT\t\t\t0x08\n#  define SIL164_PLLZONE_FORCE_ON\t\t0x10\n#  define SIL164_PLLZONE_FORCE_HIGH\t\t0x20\n\n \n\nstatic void\nsil164_write(struct i2c_client *client, uint8_t addr, uint8_t val)\n{\n\tuint8_t buf[] = {addr, val};\n\tint ret;\n\n\tret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\n\tif (ret < 0)\n\t\tsil164_err(client, \"Error %d writing to subaddress 0x%x\\n\",\n\t\t\t   ret, addr);\n}\n\nstatic uint8_t\nsil164_read(struct i2c_client *client, uint8_t addr)\n{\n\tuint8_t val;\n\tint ret;\n\n\tret = i2c_master_send(client, &addr, sizeof(addr));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_master_recv(client, &val, sizeof(val));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn val;\n\nfail:\n\tsil164_err(client, \"Error %d reading from subaddress 0x%x\\n\",\n\t\t   ret, addr);\n\treturn 0;\n}\n\nstatic void\nsil164_save_state(struct i2c_client *client, uint8_t *state)\n{\n\tint i;\n\n\tfor (i = 0x8; i <= 0xe; i++)\n\t\tstate[i] = sil164_read(client, i);\n}\n\nstatic void\nsil164_restore_state(struct i2c_client *client, uint8_t *state)\n{\n\tint i;\n\n\tfor (i = 0x8; i <= 0xe; i++)\n\t\tsil164_write(client, i, state[i]);\n}\n\nstatic void\nsil164_set_power_state(struct i2c_client *client, bool on)\n{\n\tuint8_t control0 = sil164_read(client, SIL164_CONTROL0);\n\n\tif (on)\n\t\tcontrol0 |= SIL164_CONTROL0_POWER_ON;\n\telse\n\t\tcontrol0 &= ~SIL164_CONTROL0_POWER_ON;\n\n\tsil164_write(client, SIL164_CONTROL0, control0);\n}\n\nstatic void\nsil164_init_state(struct i2c_client *client,\n\t\t  struct sil164_encoder_params *config,\n\t\t  bool duallink)\n{\n\tsil164_write(client, SIL164_CONTROL0,\n\t\t     SIL164_CONTROL0_HSYNC_ON |\n\t\t     SIL164_CONTROL0_VSYNC_ON |\n\t\t     (config->input_edge ? SIL164_CONTROL0_EDGE_RISING : 0) |\n\t\t     (config->input_width ? SIL164_CONTROL0_INPUT_24BIT : 0) |\n\t\t     (config->input_dual ? SIL164_CONTROL0_DUAL_EDGE : 0));\n\n\tsil164_write(client, SIL164_DETECT,\n\t\t     SIL164_DETECT_INTR_STAT |\n\t\t     SIL164_DETECT_OUT_MODE_RECEIVER);\n\n\tsil164_write(client, SIL164_CONTROL1,\n\t\t     (config->input_skew ? SIL164_CONTROL1_DESKEW_ENABLE : 0) |\n\t\t     (((config->input_skew + 4) & 0x7)\n\t\t      << SIL164_CONTROL1_DESKEW_INCR_SHIFT));\n\n\tsil164_write(client, SIL164_CONTROL2,\n\t\t     SIL164_CONTROL2_SYNC_CONT |\n\t\t     (config->pll_filter ? 0 : SIL164_CONTROL2_FILTER_ENABLE) |\n\t\t     (4 << SIL164_CONTROL2_FILTER_SETTING_SHIFT));\n\n\tsil164_write(client, SIL164_PLLZONE, 0);\n\n\tif (duallink)\n\t\tsil164_write(client, SIL164_DUALLINK,\n\t\t\t     SIL164_DUALLINK_ENABLE |\n\t\t\t     (((config->duallink_skew + 4) & 0x7)\n\t\t\t      << SIL164_DUALLINK_SKEW_SHIFT));\n\telse\n\t\tsil164_write(client, SIL164_DUALLINK, 0);\n}\n\n \n\nstatic void\nsil164_encoder_set_config(struct drm_encoder *encoder, void *params)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\n\tpriv->config = *(struct sil164_encoder_params *)params;\n}\n\nstatic void\nsil164_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\tbool on = (mode == DRM_MODE_DPMS_ON);\n\tbool duallink = (on && encoder->crtc->mode.clock > 165000);\n\n\tsil164_set_power_state(drm_i2c_encoder_get_client(encoder), on);\n\n\tif (priv->duallink_slave)\n\t\tsil164_set_power_state(priv->duallink_slave, duallink);\n}\n\nstatic void\nsil164_encoder_save(struct drm_encoder *encoder)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\n\tsil164_save_state(drm_i2c_encoder_get_client(encoder),\n\t\t\t  priv->saved_state);\n\n\tif (priv->duallink_slave)\n\t\tsil164_save_state(priv->duallink_slave,\n\t\t\t\t  priv->saved_slave_state);\n}\n\nstatic void\nsil164_encoder_restore(struct drm_encoder *encoder)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\n\tsil164_restore_state(drm_i2c_encoder_get_client(encoder),\n\t\t\t     priv->saved_state);\n\n\tif (priv->duallink_slave)\n\t\tsil164_restore_state(priv->duallink_slave,\n\t\t\t\t     priv->saved_slave_state);\n}\n\nstatic int\nsil164_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\n\tif (mode->clock < 32000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->clock > 330000 ||\n\t    (mode->clock > 165000 && !priv->duallink_slave))\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void\nsil164_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\tstruct drm_display_mode *mode,\n\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\tbool duallink = adjusted_mode->clock > 165000;\n\n\tsil164_init_state(drm_i2c_encoder_get_client(encoder),\n\t\t\t  &priv->config, duallink);\n\n\tif (priv->duallink_slave)\n\t\tsil164_init_state(priv->duallink_slave,\n\t\t\t\t  &priv->config, duallink);\n\n\tsil164_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\n}\n\nstatic enum drm_connector_status\nsil164_encoder_detect(struct drm_encoder *encoder,\n\t\t      struct drm_connector *connector)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\n\tif (sil164_read(client, SIL164_DETECT) & SIL164_DETECT_HOTPLUG_STAT)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic int\nsil164_encoder_get_modes(struct drm_encoder *encoder,\n\t\t\t struct drm_connector *connector)\n{\n\treturn 0;\n}\n\nstatic int\nsil164_encoder_create_resources(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector)\n{\n\treturn 0;\n}\n\nstatic int\nsil164_encoder_set_property(struct drm_encoder *encoder,\n\t\t\t    struct drm_connector *connector,\n\t\t\t    struct drm_property *property,\n\t\t\t    uint64_t val)\n{\n\treturn 0;\n}\n\nstatic void\nsil164_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct sil164_priv *priv = to_sil164_priv(encoder);\n\n\ti2c_unregister_device(priv->duallink_slave);\n\n\tkfree(priv);\n\tdrm_i2c_encoder_destroy(encoder);\n}\n\nstatic const struct drm_encoder_slave_funcs sil164_encoder_funcs = {\n\t.set_config = sil164_encoder_set_config,\n\t.destroy = sil164_encoder_destroy,\n\t.dpms = sil164_encoder_dpms,\n\t.save = sil164_encoder_save,\n\t.restore = sil164_encoder_restore,\n\t.mode_valid = sil164_encoder_mode_valid,\n\t.mode_set = sil164_encoder_mode_set,\n\t.detect = sil164_encoder_detect,\n\t.get_modes = sil164_encoder_get_modes,\n\t.create_resources = sil164_encoder_create_resources,\n\t.set_property = sil164_encoder_set_property,\n};\n\n \n\nstatic int\nsil164_probe(struct i2c_client *client)\n{\n\tint vendor = sil164_read(client, SIL164_VENDOR_HI) << 8 |\n\t\tsil164_read(client, SIL164_VENDOR_LO);\n\tint device = sil164_read(client, SIL164_DEVICE_HI) << 8 |\n\t\tsil164_read(client, SIL164_DEVICE_LO);\n\tint rev = sil164_read(client, SIL164_REVISION);\n\n\tif (vendor != 0x1 || device != 0x6) {\n\t\tsil164_dbg(client, \"Unknown device %x:%x.%x\\n\",\n\t\t\t   vendor, device, rev);\n\t\treturn -ENODEV;\n\t}\n\n\tsil164_info(client, \"Detected device %x:%x.%x\\n\",\n\t\t    vendor, device, rev);\n\n\treturn 0;\n}\n\nstatic struct i2c_client *\nsil164_detect_slave(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_msg msg = {\n\t\t.addr = SIL164_I2C_ADDR_SLAVE,\n\t\t.len = 0,\n\t};\n\tconst struct i2c_board_info info = {\n\t\tI2C_BOARD_INFO(\"sil164\", SIL164_I2C_ADDR_SLAVE)\n\t};\n\n\tif (i2c_transfer(adap, &msg, 1) != 1) {\n\t\tsil164_dbg(adap, \"No dual-link slave found.\");\n\t\treturn NULL;\n\t}\n\n\treturn i2c_new_client_device(adap, &info);\n}\n\nstatic int\nsil164_encoder_init(struct i2c_client *client,\n\t\t    struct drm_device *dev,\n\t\t    struct drm_encoder_slave *encoder)\n{\n\tstruct sil164_priv *priv;\n\tstruct i2c_client *slave_client;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tencoder->slave_priv = priv;\n\tencoder->slave_funcs = &sil164_encoder_funcs;\n\n\tslave_client = sil164_detect_slave(client);\n\tif (!IS_ERR(slave_client))\n\t\tpriv->duallink_slave = slave_client;\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id sil164_ids[] = {\n\t{ \"sil164\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sil164_ids);\n\nstatic struct drm_i2c_encoder_driver sil164_driver = {\n\t.i2c_driver = {\n\t\t.probe = sil164_probe,\n\t\t.driver = {\n\t\t\t.name = \"sil164\",\n\t\t},\n\t\t.id_table = sil164_ids,\n\t},\n\t.encoder_init = sil164_encoder_init,\n};\n\n \n\nstatic int __init\nsil164_init(void)\n{\n\treturn drm_i2c_encoder_register(THIS_MODULE, &sil164_driver);\n}\n\nstatic void __exit\nsil164_exit(void)\n{\n\tdrm_i2c_encoder_unregister(&sil164_driver);\n}\n\nMODULE_AUTHOR(\"Francisco Jerez <currojerez@riseup.net>\");\nMODULE_DESCRIPTION(\"Silicon Image sil164 TMDS transmitter driver\");\nMODULE_LICENSE(\"GPL and additional rights\");\n\nmodule_init(sil164_init);\nmodule_exit(sil164_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}