{
  "module_name": "ch7006_mode.c",
  "hash_id": "dffc3197fe899a8e4c96766a3c0329e3b11590f320e76697037be3823749ef9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i2c/ch7006_mode.c",
  "human_readable_source": " \n\n#include \"ch7006_priv.h\"\n\nconst char * const ch7006_tv_norm_names[] = {\n\t[TV_NORM_PAL] = \"PAL\",\n\t[TV_NORM_PAL_M] = \"PAL-M\",\n\t[TV_NORM_PAL_N] = \"PAL-N\",\n\t[TV_NORM_PAL_NC] = \"PAL-Nc\",\n\t[TV_NORM_PAL_60] = \"PAL-60\",\n\t[TV_NORM_NTSC_M] = \"NTSC-M\",\n\t[TV_NORM_NTSC_J] = \"NTSC-J\",\n};\n\n#define NTSC_LIKE_TIMINGS .vrefresh = 60 * fixed1/1.001,\t\t\\\n\t\t.vdisplay = 480,\t\t\t\t\t\\\n\t\t.vtotal = 525,\t\t\t\t\t\t\\\n\t\t.hvirtual = 660\n\n#define PAL_LIKE_TIMINGS .vrefresh = 50 * fixed1,\t\t\\\n\t\t.vdisplay = 576,\t\t\t\t\\\n\t\t.vtotal = 625,\t\t\t\t\t\\\n\t\t.hvirtual = 810\n\nconst struct ch7006_tv_norm_info ch7006_tv_norms[] = {\n\t[TV_NORM_NTSC_M] = {\n\t\tNTSC_LIKE_TIMINGS,\n\t\t.black_level = 0.339 * fixed1,\n\t\t.subc_freq = 3579545 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC),\n\t\t.voffset = 0,\n\t},\n\t[TV_NORM_NTSC_J] = {\n\t\tNTSC_LIKE_TIMINGS,\n\t\t.black_level = 0.286 * fixed1,\n\t\t.subc_freq = 3579545 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, NTSC_J),\n\t\t.voffset = 0,\n\t},\n\t[TV_NORM_PAL] = {\n\t\tPAL_LIKE_TIMINGS,\n\t\t.black_level = 0.3 * fixed1,\n\t\t.subc_freq = 4433618.75 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),\n\t\t.voffset = 0,\n\t},\n\t[TV_NORM_PAL_M] = {\n\t\tNTSC_LIKE_TIMINGS,\n\t\t.black_level = 0.339 * fixed1,\n\t\t.subc_freq = 3575611.433 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),\n\t\t.voffset = 16,\n\t},\n\n\t \n\n\t[TV_NORM_PAL_N] = {\n\t\tPAL_LIKE_TIMINGS,\n\t\t.black_level = 0.339 * fixed1,\n\t\t.subc_freq = 4433618.75 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),\n\t\t.voffset = 0,\n\t},\n\t[TV_NORM_PAL_NC] = {\n\t\tPAL_LIKE_TIMINGS,\n\t\t.black_level = 0.3 * fixed1,\n\t\t.subc_freq = 3582056.25 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL),\n\t\t.voffset = 0,\n\t},\n\t[TV_NORM_PAL_60] = {\n\t\tNTSC_LIKE_TIMINGS,\n\t\t.black_level = 0.3 * fixed1,\n\t\t.subc_freq = 4433618.75 * fixed1,\n\t\t.dispmode = bitfs(CH7006_DISPMODE_OUTPUT_STD, PAL_M),\n\t\t.voffset = 16,\n\t},\n};\n\n#define __MODE(f, hd, vd, ht, vt, hsynp, vsynp,\t\t\t\t\\\n\t       subc, scale, scale_mask, norm_mask, e_hd, e_vd) {\t\\\n\t\t.mode = {\t\t\t\t\t\t\\\n\t\t\t.name = #hd \"x\" #vd,\t\t\t\t\\\n\t\t\t.status = 0,\t\t\t\t\t\\\n\t\t\t.type = DRM_MODE_TYPE_DRIVER,\t\t\t\\\n\t\t\t.clock = f,\t\t\t\t\t\\\n\t\t\t.hdisplay = hd,\t\t\t\t\t\\\n\t\t\t.hsync_start = e_hd + 16,\t\t\t\\\n\t\t\t.hsync_end = e_hd + 80,\t\t\t\t\\\n\t\t\t.htotal = ht,\t\t\t\t\t\\\n\t\t\t.hskew = 0,\t\t\t\t\t\\\n\t\t\t.vdisplay = vd,\t\t\t\t\t\\\n\t\t\t.vsync_start = vd + 10,\t\t\t\t\\\n\t\t\t.vsync_end = vd + 26,\t\t\t\t\\\n\t\t\t.vtotal = vt,\t\t\t\t\t\\\n\t\t\t.vscan = 0,\t\t\t\t\t\\\n\t\t\t.flags = DRM_MODE_FLAG_##hsynp##HSYNC |\t\t\\\n\t\t\t\tDRM_MODE_FLAG_##vsynp##VSYNC,\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.enc_hdisp = e_hd,\t\t\t\t\t\\\n\t\t.enc_vdisp = e_vd,\t\t\t\t\t\\\n\t\t.subc_coeff = subc * fixed1,\t\t\t\t\\\n\t\t.dispmode = bitfs(CH7006_DISPMODE_SCALING_RATIO, scale) | \\\n\t\t\t    bitfs(CH7006_DISPMODE_INPUT_RES, e_hd##x##e_vd), \\\n\t\t.valid_scales = scale_mask,\t\t\t\t\\\n\t\t.valid_norms = norm_mask\t\t\t\t\\\n\t }\n\n#define MODE(f, hd, vd, ht, vt, hsynp, vsynp,\t\t\t\t\\\n\t     subc, scale, scale_mask, norm_mask)\t\t\t\\\n\t__MODE(f, hd, vd, ht, vt, hsynp, vsynp, subc, scale,\t\t\\\n\t       scale_mask, norm_mask, hd, vd)\n\n#define NTSC_LIKE (1 << TV_NORM_NTSC_M | 1 << TV_NORM_NTSC_J |\t\t\\\n\t\t   1 << TV_NORM_PAL_M | 1 << TV_NORM_PAL_60)\n\n#define PAL_LIKE (1 << TV_NORM_PAL | 1 << TV_NORM_PAL_N | 1 << TV_NORM_PAL_NC)\n\nconst struct ch7006_mode ch7006_modes[] = {\n\tMODE(21000, 512, 384, 840, 500, N, N, 181.797557582, 5_4, 0x6, PAL_LIKE),\n\tMODE(26250, 512, 384, 840, 625, N, N, 145.438046066, 1_1, 0x1, PAL_LIKE),\n\tMODE(20140, 512, 384, 800, 420, N, N, 213.257083791, 5_4, 0x4, NTSC_LIKE),\n\tMODE(24671, 512, 384, 784, 525, N, N, 174.0874153, 1_1, 0x3, NTSC_LIKE),\n\tMODE(28125, 720, 400, 1125, 500, N, N, 135.742176298, 5_4, 0x6, PAL_LIKE),\n\tMODE(34875, 720, 400, 1116, 625, N, N, 109.469496898, 1_1, 0x1, PAL_LIKE),\n\tMODE(23790, 720, 400, 945, 420, N, N, 160.475642016, 5_4, 0x4, NTSC_LIKE),\n\tMODE(29455, 720, 400, 936, 525, N, N, 129.614941843, 1_1, 0x3, NTSC_LIKE),\n\tMODE(25000, 640, 400, 1000, 500, N, N, 152.709948279, 5_4, 0x6, PAL_LIKE),\n\tMODE(31500, 640, 400, 1008, 625, N, N, 121.198371646, 1_1, 0x1, PAL_LIKE),\n\tMODE(21147, 640, 400, 840, 420, N, N, 180.535097338, 5_4, 0x4, NTSC_LIKE),\n\tMODE(26434, 640, 400, 840, 525, N, N, 144.42807787, 1_1, 0x2, NTSC_LIKE),\n\tMODE(30210, 640, 400, 840, 600, N, N, 126.374568276, 7_8, 0x1, NTSC_LIKE),\n\tMODE(21000, 640, 480, 840, 500, N, N, 181.797557582, 5_4, 0x4, PAL_LIKE),\n\tMODE(26250, 640, 480, 840, 625, N, N, 145.438046066, 1_1, 0x2, PAL_LIKE),\n\tMODE(31500, 640, 480, 840, 750, N, N, 121.198371646, 5_6, 0x1, PAL_LIKE),\n\tMODE(24671, 640, 480, 784, 525, N, N, 174.0874153, 1_1, 0x4, NTSC_LIKE),\n\tMODE(28196, 640, 480, 784, 600, N, N, 152.326488422, 7_8, 0x2, NTSC_LIKE),\n\tMODE(30210, 640, 480, 800, 630, N, N, 142.171389101, 5_6, 0x1, NTSC_LIKE),\n\t__MODE(29500, 720, 576, 944, 625, P, P, 145.592111636, 1_1, 0x7, PAL_LIKE, 800, 600),\n\tMODE(36000, 800, 600, 960, 750, P, P, 119.304647022, 5_6, 0x6, PAL_LIKE),\n\tMODE(39000, 800, 600, 936, 836, P, P, 110.127366499, 3_4, 0x1, PAL_LIKE),\n\tMODE(39273, 800, 600, 1040, 630, P, P, 145.816809399, 5_6, 0x4, NTSC_LIKE),\n\tMODE(43636, 800, 600, 1040, 700, P, P, 131.235128487, 3_4, 0x2, NTSC_LIKE),\n\tMODE(47832, 800, 600, 1064, 750, P, P, 119.723275165, 7_10, 0x1, NTSC_LIKE),\n\t{}\n};\n\nconst struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,\n\t\t\t\t\t     const struct drm_display_mode *drm_mode)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tconst struct ch7006_mode *mode;\n\n\tfor (mode = ch7006_modes; mode->mode.clock; mode++) {\n\n\t\tif (~mode->valid_norms & 1<<priv->norm)\n\t\t\tcontinue;\n\n\t\tif (mode->mode.hdisplay != drm_mode->hdisplay ||\n\t\t    mode->mode.vdisplay != drm_mode->vdisplay ||\n\t\t    mode->mode.vtotal != drm_mode->vtotal ||\n\t\t    mode->mode.htotal != drm_mode->htotal ||\n\t\t    mode->mode.clock != drm_mode->clock)\n\t\t\tcontinue;\n\n\t\treturn mode;\n\t}\n\n\treturn NULL;\n}\n\n \n\nvoid ch7006_setup_levels(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tuint8_t *regs = priv->state.regs;\n\tconst struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\n\tint gain;\n\tint black_level;\n\n\t \n\tif (norm->black_level < 339*fixed1/1000) {\n\t\tgain = 76;\n\n\t\tregs[CH7006_INPUT_FORMAT] |= CH7006_INPUT_FORMAT_DAC_GAIN;\n\t} else {\n\t\tgain = 71;\n\n\t\tregs[CH7006_INPUT_FORMAT] &= ~CH7006_INPUT_FORMAT_DAC_GAIN;\n\t}\n\n\tblack_level = round_fixed(norm->black_level*26625)/gain;\n\n\t \n\tblack_level = interpolate(90, black_level, 208, priv->brightness);\n\n\tregs[CH7006_BLACK_LEVEL] = bitf(CH7006_BLACK_LEVEL_0, black_level);\n\n\tch7006_dbg(client, \"black level: %d\\n\", black_level);\n}\n\nvoid ch7006_setup_subcarrier(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_state *state = &priv->state;\n\tconst struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\n\tconst struct ch7006_mode *mode = priv->mode;\n\tuint32_t subc_inc;\n\n\tsubc_inc = round_fixed((mode->subc_coeff >> 8)\n\t\t\t       * (norm->subc_freq >> 24));\n\n\tsetbitf(state, CH7006_SUBC_INC0, 28, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC1, 24, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC2, 20, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC3, 16, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC4, 12, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC5, 8, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC6, 4, subc_inc);\n\tsetbitf(state, CH7006_SUBC_INC7, 0, subc_inc);\n\n\tch7006_dbg(client, \"subcarrier inc: %u\\n\", subc_inc);\n}\n\nvoid ch7006_setup_pll(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tuint8_t *regs = priv->state.regs;\n\tconst struct ch7006_mode *mode = priv->mode;\n\tint n, best_n = 0;\n\tint m, best_m = 0;\n\tint freq, best_freq = 0;\n\n\tfor (n = 0; n < CH7006_MAXN; n++) {\n\t\tfor (m = 0; m < CH7006_MAXM; m++) {\n\t\t\tfreq = CH7006_FREQ0*(n+2)/(m+2);\n\n\t\t\tif (abs(freq - mode->mode.clock) <\n\t\t\t    abs(best_freq - mode->mode.clock)) {\n\t\t\t\tbest_freq = freq;\n\t\t\t\tbest_n = n;\n\t\t\t\tbest_m = m;\n\t\t\t}\n\t\t}\n\t}\n\n\tregs[CH7006_PLLOV] = bitf(CH7006_PLLOV_N_8, best_n) |\n\t\tbitf(CH7006_PLLOV_M_8, best_m);\n\n\tregs[CH7006_PLLM] = bitf(CH7006_PLLM_0, best_m);\n\tregs[CH7006_PLLN] = bitf(CH7006_PLLN_0, best_n);\n\n\tif (best_n < 108)\n\t\tregs[CH7006_PLL_CONTROL] |= CH7006_PLL_CONTROL_CAPACITOR;\n\telse\n\t\tregs[CH7006_PLL_CONTROL] &= ~CH7006_PLL_CONTROL_CAPACITOR;\n\n\tch7006_dbg(client, \"n=%d m=%d f=%d c=%d\\n\",\n\t\t   best_n, best_m, best_freq, best_n < 108);\n}\n\nvoid ch7006_setup_power_state(struct drm_encoder *encoder)\n{\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tuint8_t *power = &priv->state.regs[CH7006_POWER];\n\tint subconnector;\n\n\tsubconnector = priv->select_subconnector ? priv->select_subconnector :\n\t\t\t\t\t\t\tpriv->subconnector;\n\n\t*power = CH7006_POWER_RESET;\n\n\tif (priv->last_dpms == DRM_MODE_DPMS_ON) {\n\t\tswitch (subconnector) {\n\t\tcase DRM_MODE_SUBCONNECTOR_SVIDEO:\n\t\t\t*power |= bitfs(CH7006_POWER_LEVEL, CVBS_OFF);\n\t\t\tbreak;\n\t\tcase DRM_MODE_SUBCONNECTOR_Composite:\n\t\t\t*power |= bitfs(CH7006_POWER_LEVEL, SVIDEO_OFF);\n\t\t\tbreak;\n\t\tcase DRM_MODE_SUBCONNECTOR_SCART:\n\t\t\t*power |= bitfs(CH7006_POWER_LEVEL, NORMAL) |\n\t\t\t\tCH7006_POWER_SCART;\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tif (priv->chip_version >= 0x20)\n\t\t\t*power |= bitfs(CH7006_POWER_LEVEL, FULL_POWER_OFF);\n\t\telse\n\t\t\t*power |= bitfs(CH7006_POWER_LEVEL, POWER_OFF);\n\t}\n}\n\nvoid ch7006_setup_properties(struct drm_encoder *encoder)\n{\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\n\tstruct ch7006_priv *priv = to_ch7006_priv(encoder);\n\tstruct ch7006_state *state = &priv->state;\n\tconst struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\n\tconst struct ch7006_mode *ch_mode = priv->mode;\n\tconst struct drm_display_mode *mode = &ch_mode->mode;\n\tuint8_t *regs = state->regs;\n\tint flicker, contrast, hpos, vpos;\n\tuint64_t scale, aspect;\n\n\tflicker = interpolate(0, 2, 3, priv->flicker);\n\tregs[CH7006_FFILTER] = bitf(CH7006_FFILTER_TEXT, flicker) |\n\t\tbitf(CH7006_FFILTER_LUMA, flicker) |\n\t\tbitf(CH7006_FFILTER_CHROMA, 1);\n\n\tcontrast = interpolate(0, 5, 7, priv->contrast);\n\tregs[CH7006_CONTRAST] = bitf(CH7006_CONTRAST_0, contrast);\n\n\tscale = norm->vtotal*fixed1;\n\tdo_div(scale, mode->vtotal);\n\n\taspect = ch_mode->enc_hdisp*fixed1;\n\tdo_div(aspect, ch_mode->enc_vdisp);\n\n\thpos = round_fixed((norm->hvirtual * aspect - mode->hdisplay * scale)\n\t\t\t   * priv->hmargin * mode->vtotal) / norm->vtotal / 100 / 4;\n\n\tsetbitf(state, CH7006_POV, HPOS_8, hpos);\n\tsetbitf(state, CH7006_HPOS, 0, hpos);\n\n\tvpos = max(0, norm->vdisplay - round_fixed(mode->vdisplay*scale)\n\t\t   + norm->voffset) * priv->vmargin / 100 / 2;\n\n\tsetbitf(state, CH7006_POV, VPOS_8, vpos);\n\tsetbitf(state, CH7006_VPOS, 0, vpos);\n\n\tch7006_dbg(client, \"hpos: %d, vpos: %d\\n\", hpos, vpos);\n}\n\n \n\nvoid ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val)\n{\n\tuint8_t buf[] = {addr, val};\n\tint ret;\n\n\tret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\n\tif (ret < 0)\n\t\tch7006_err(client, \"Error %d writing to subaddress 0x%x\\n\",\n\t\t\t   ret, addr);\n}\n\nuint8_t ch7006_read(struct i2c_client *client, uint8_t addr)\n{\n\tuint8_t val;\n\tint ret;\n\n\tret = i2c_master_send(client, &addr, sizeof(addr));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_master_recv(client, &val, sizeof(val));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn val;\n\nfail:\n\tch7006_err(client, \"Error %d reading from subaddress 0x%x\\n\",\n\t\t   ret, addr);\n\treturn 0;\n}\n\nvoid ch7006_state_load(struct i2c_client *client,\n\t\t       struct ch7006_state *state)\n{\n\tch7006_load_reg(client, state, CH7006_POWER);\n\n\tch7006_load_reg(client, state, CH7006_DISPMODE);\n\tch7006_load_reg(client, state, CH7006_FFILTER);\n\tch7006_load_reg(client, state, CH7006_BWIDTH);\n\tch7006_load_reg(client, state, CH7006_INPUT_FORMAT);\n\tch7006_load_reg(client, state, CH7006_CLKMODE);\n\tch7006_load_reg(client, state, CH7006_START_ACTIVE);\n\tch7006_load_reg(client, state, CH7006_POV);\n\tch7006_load_reg(client, state, CH7006_BLACK_LEVEL);\n\tch7006_load_reg(client, state, CH7006_HPOS);\n\tch7006_load_reg(client, state, CH7006_VPOS);\n\tch7006_load_reg(client, state, CH7006_INPUT_SYNC);\n\tch7006_load_reg(client, state, CH7006_DETECT);\n\tch7006_load_reg(client, state, CH7006_CONTRAST);\n\tch7006_load_reg(client, state, CH7006_PLLOV);\n\tch7006_load_reg(client, state, CH7006_PLLM);\n\tch7006_load_reg(client, state, CH7006_PLLN);\n\tch7006_load_reg(client, state, CH7006_BCLKOUT);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC0);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC1);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC2);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC3);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC4);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC5);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC6);\n\tch7006_load_reg(client, state, CH7006_SUBC_INC7);\n\tch7006_load_reg(client, state, CH7006_PLL_CONTROL);\n\tch7006_load_reg(client, state, CH7006_CALC_SUBC_INC0);\n}\n\nvoid ch7006_state_save(struct i2c_client *client,\n\t\t       struct ch7006_state *state)\n{\n\tch7006_save_reg(client, state, CH7006_POWER);\n\n\tch7006_save_reg(client, state, CH7006_DISPMODE);\n\tch7006_save_reg(client, state, CH7006_FFILTER);\n\tch7006_save_reg(client, state, CH7006_BWIDTH);\n\tch7006_save_reg(client, state, CH7006_INPUT_FORMAT);\n\tch7006_save_reg(client, state, CH7006_CLKMODE);\n\tch7006_save_reg(client, state, CH7006_START_ACTIVE);\n\tch7006_save_reg(client, state, CH7006_POV);\n\tch7006_save_reg(client, state, CH7006_BLACK_LEVEL);\n\tch7006_save_reg(client, state, CH7006_HPOS);\n\tch7006_save_reg(client, state, CH7006_VPOS);\n\tch7006_save_reg(client, state, CH7006_INPUT_SYNC);\n\tch7006_save_reg(client, state, CH7006_DETECT);\n\tch7006_save_reg(client, state, CH7006_CONTRAST);\n\tch7006_save_reg(client, state, CH7006_PLLOV);\n\tch7006_save_reg(client, state, CH7006_PLLM);\n\tch7006_save_reg(client, state, CH7006_PLLN);\n\tch7006_save_reg(client, state, CH7006_BCLKOUT);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC0);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC1);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC2);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC3);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC4);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC5);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC6);\n\tch7006_save_reg(client, state, CH7006_SUBC_INC7);\n\tch7006_save_reg(client, state, CH7006_PLL_CONTROL);\n\tch7006_save_reg(client, state, CH7006_CALC_SUBC_INC0);\n\n\tstate->regs[CH7006_FFILTER] = (state->regs[CH7006_FFILTER] & 0xf0) |\n\t\t(state->regs[CH7006_FFILTER] & 0x0c) >> 2 |\n\t\t(state->regs[CH7006_FFILTER] & 0x03) << 2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}