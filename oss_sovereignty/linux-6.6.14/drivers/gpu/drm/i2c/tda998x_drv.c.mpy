{
  "module_name": "tda998x_drv.c",
  "hash_id": "0bccfc3240cc9b526a1182b2443ffd44f39801a98ff7ead86eefec18e6b6f619",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/i2c/tda998x_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_data/tda9950.h>\n#include <linux/irq.h>\n#include <sound/asoundef.h>\n#include <sound/hdmi-codec.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/i2c/tda998x.h>\n\n#include <media/cec-notifier.h>\n\n#define DBG(fmt, ...) DRM_DEBUG(fmt\"\\n\", ##__VA_ARGS__)\n\nenum {\n\tAUDIO_ROUTE_I2S,\n\tAUDIO_ROUTE_SPDIF,\n\tAUDIO_ROUTE_NUM\n};\n\nstruct tda998x_audio_route {\n\tu8 ena_aclk;\n\tu8 mux_ap;\n\tu8 aip_clksel;\n};\n\nstruct tda998x_audio_settings {\n\tconst struct tda998x_audio_route *route;\n\tstruct hdmi_audio_infoframe cea;\n\tunsigned int sample_rate;\n\tu8 status[5];\n\tu8 ena_ap;\n\tu8 i2s_format;\n\tu8 cts_n;\n};\n\nstruct tda998x_priv {\n\tstruct i2c_client *cec;\n\tstruct i2c_client *hdmi;\n\tstruct mutex mutex;\n\tu16 rev;\n\tu8 cec_addr;\n\tu8 current_page;\n\tbool is_on;\n\tbool supports_infoframes;\n\tbool sink_has_audio;\n\tenum hdmi_quantization_range rgb_quant_range;\n\tu8 vip_cntrl_0;\n\tu8 vip_cntrl_1;\n\tu8 vip_cntrl_2;\n\tunsigned long tmds_clock;\n\tstruct tda998x_audio_settings audio;\n\n\tstruct platform_device *audio_pdev;\n\tstruct mutex audio_mutex;\n\n\tstruct mutex edid_mutex;\n\twait_queue_head_t wq_edid;\n\tvolatile int wq_edid_wait;\n\n\tstruct work_struct detect_work;\n\tstruct timer_list edid_delay_timer;\n\twait_queue_head_t edid_delay_waitq;\n\tbool edid_delay_active;\n\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct drm_connector connector;\n\n\tu8 audio_port_enable[AUDIO_ROUTE_NUM];\n\tstruct tda9950_glue cec_glue;\n\tstruct gpio_desc *calib;\n\tstruct cec_notifier *cec_notify;\n};\n\n#define conn_to_tda998x_priv(x) \\\n\tcontainer_of(x, struct tda998x_priv, connector)\n#define enc_to_tda998x_priv(x) \\\n\tcontainer_of(x, struct tda998x_priv, encoder)\n#define bridge_to_tda998x_priv(x) \\\n\tcontainer_of(x, struct tda998x_priv, bridge)\n\n \n\n#define REG(page, addr) (((page) << 8) | (addr))\n#define REG2ADDR(reg)   ((reg) & 0xff)\n#define REG2PAGE(reg)   (((reg) >> 8) & 0xff)\n\n#define REG_CURPAGE               0xff                 \n\n\n \n#define REG_VERSION_LSB           REG(0x00, 0x00)      \n#define REG_MAIN_CNTRL0           REG(0x00, 0x01)      \n# define MAIN_CNTRL0_SR           (1 << 0)\n# define MAIN_CNTRL0_DECS         (1 << 1)\n# define MAIN_CNTRL0_DEHS         (1 << 2)\n# define MAIN_CNTRL0_CECS         (1 << 3)\n# define MAIN_CNTRL0_CEHS         (1 << 4)\n# define MAIN_CNTRL0_SCALER       (1 << 7)\n#define REG_VERSION_MSB           REG(0x00, 0x02)      \n#define REG_SOFTRESET             REG(0x00, 0x0a)      \n# define SOFTRESET_AUDIO          (1 << 0)\n# define SOFTRESET_I2C_MASTER     (1 << 1)\n#define REG_DDC_DISABLE           REG(0x00, 0x0b)      \n#define REG_CCLK_ON               REG(0x00, 0x0c)      \n#define REG_I2C_MASTER            REG(0x00, 0x0d)      \n# define I2C_MASTER_DIS_MM        (1 << 0)\n# define I2C_MASTER_DIS_FILT      (1 << 1)\n# define I2C_MASTER_APP_STRT_LAT  (1 << 2)\n#define REG_FEAT_POWERDOWN        REG(0x00, 0x0e)      \n# define FEAT_POWERDOWN_PREFILT   BIT(0)\n# define FEAT_POWERDOWN_CSC       BIT(1)\n# define FEAT_POWERDOWN_SPDIF     (1 << 3)\n#define REG_INT_FLAGS_0           REG(0x00, 0x0f)      \n#define REG_INT_FLAGS_1           REG(0x00, 0x10)      \n#define REG_INT_FLAGS_2           REG(0x00, 0x11)      \n# define INT_FLAGS_2_EDID_BLK_RD  (1 << 1)\n#define REG_ENA_ACLK              REG(0x00, 0x16)      \n#define REG_ENA_VP_0              REG(0x00, 0x18)      \n#define REG_ENA_VP_1              REG(0x00, 0x19)      \n#define REG_ENA_VP_2              REG(0x00, 0x1a)      \n#define REG_ENA_AP                REG(0x00, 0x1e)      \n#define REG_VIP_CNTRL_0           REG(0x00, 0x20)      \n# define VIP_CNTRL_0_MIRR_A       (1 << 7)\n# define VIP_CNTRL_0_SWAP_A(x)    (((x) & 7) << 4)\n# define VIP_CNTRL_0_MIRR_B       (1 << 3)\n# define VIP_CNTRL_0_SWAP_B(x)    (((x) & 7) << 0)\n#define REG_VIP_CNTRL_1           REG(0x00, 0x21)      \n# define VIP_CNTRL_1_MIRR_C       (1 << 7)\n# define VIP_CNTRL_1_SWAP_C(x)    (((x) & 7) << 4)\n# define VIP_CNTRL_1_MIRR_D       (1 << 3)\n# define VIP_CNTRL_1_SWAP_D(x)    (((x) & 7) << 0)\n#define REG_VIP_CNTRL_2           REG(0x00, 0x22)      \n# define VIP_CNTRL_2_MIRR_E       (1 << 7)\n# define VIP_CNTRL_2_SWAP_E(x)    (((x) & 7) << 4)\n# define VIP_CNTRL_2_MIRR_F       (1 << 3)\n# define VIP_CNTRL_2_SWAP_F(x)    (((x) & 7) << 0)\n#define REG_VIP_CNTRL_3           REG(0x00, 0x23)      \n# define VIP_CNTRL_3_X_TGL        (1 << 0)\n# define VIP_CNTRL_3_H_TGL        (1 << 1)\n# define VIP_CNTRL_3_V_TGL        (1 << 2)\n# define VIP_CNTRL_3_EMB          (1 << 3)\n# define VIP_CNTRL_3_SYNC_DE      (1 << 4)\n# define VIP_CNTRL_3_SYNC_HS      (1 << 5)\n# define VIP_CNTRL_3_DE_INT       (1 << 6)\n# define VIP_CNTRL_3_EDGE         (1 << 7)\n#define REG_VIP_CNTRL_4           REG(0x00, 0x24)      \n# define VIP_CNTRL_4_BLC(x)       (((x) & 3) << 0)\n# define VIP_CNTRL_4_BLANKIT(x)   (((x) & 3) << 2)\n# define VIP_CNTRL_4_CCIR656      (1 << 4)\n# define VIP_CNTRL_4_656_ALT      (1 << 5)\n# define VIP_CNTRL_4_TST_656      (1 << 6)\n# define VIP_CNTRL_4_TST_PAT      (1 << 7)\n#define REG_VIP_CNTRL_5           REG(0x00, 0x25)      \n# define VIP_CNTRL_5_CKCASE       (1 << 0)\n# define VIP_CNTRL_5_SP_CNT(x)    (((x) & 3) << 1)\n#define REG_MUX_AP                REG(0x00, 0x26)      \n# define MUX_AP_SELECT_I2S\t  0x64\n# define MUX_AP_SELECT_SPDIF\t  0x40\n#define REG_MUX_VP_VIP_OUT        REG(0x00, 0x27)      \n#define REG_MAT_CONTRL            REG(0x00, 0x80)      \n# define MAT_CONTRL_MAT_SC(x)     (((x) & 3) << 0)\n# define MAT_CONTRL_MAT_BP        (1 << 2)\n#define REG_VIDFORMAT             REG(0x00, 0xa0)      \n#define REG_REFPIX_MSB            REG(0x00, 0xa1)      \n#define REG_REFPIX_LSB            REG(0x00, 0xa2)      \n#define REG_REFLINE_MSB           REG(0x00, 0xa3)      \n#define REG_REFLINE_LSB           REG(0x00, 0xa4)      \n#define REG_NPIX_MSB              REG(0x00, 0xa5)      \n#define REG_NPIX_LSB              REG(0x00, 0xa6)      \n#define REG_NLINE_MSB             REG(0x00, 0xa7)      \n#define REG_NLINE_LSB             REG(0x00, 0xa8)      \n#define REG_VS_LINE_STRT_1_MSB    REG(0x00, 0xa9)      \n#define REG_VS_LINE_STRT_1_LSB    REG(0x00, 0xaa)      \n#define REG_VS_PIX_STRT_1_MSB     REG(0x00, 0xab)      \n#define REG_VS_PIX_STRT_1_LSB     REG(0x00, 0xac)      \n#define REG_VS_LINE_END_1_MSB     REG(0x00, 0xad)      \n#define REG_VS_LINE_END_1_LSB     REG(0x00, 0xae)      \n#define REG_VS_PIX_END_1_MSB      REG(0x00, 0xaf)      \n#define REG_VS_PIX_END_1_LSB      REG(0x00, 0xb0)      \n#define REG_VS_LINE_STRT_2_MSB    REG(0x00, 0xb1)      \n#define REG_VS_LINE_STRT_2_LSB    REG(0x00, 0xb2)      \n#define REG_VS_PIX_STRT_2_MSB     REG(0x00, 0xb3)      \n#define REG_VS_PIX_STRT_2_LSB     REG(0x00, 0xb4)      \n#define REG_VS_LINE_END_2_MSB     REG(0x00, 0xb5)      \n#define REG_VS_LINE_END_2_LSB     REG(0x00, 0xb6)      \n#define REG_VS_PIX_END_2_MSB      REG(0x00, 0xb7)      \n#define REG_VS_PIX_END_2_LSB      REG(0x00, 0xb8)      \n#define REG_HS_PIX_START_MSB      REG(0x00, 0xb9)      \n#define REG_HS_PIX_START_LSB      REG(0x00, 0xba)      \n#define REG_HS_PIX_STOP_MSB       REG(0x00, 0xbb)      \n#define REG_HS_PIX_STOP_LSB       REG(0x00, 0xbc)      \n#define REG_VWIN_START_1_MSB      REG(0x00, 0xbd)      \n#define REG_VWIN_START_1_LSB      REG(0x00, 0xbe)      \n#define REG_VWIN_END_1_MSB        REG(0x00, 0xbf)      \n#define REG_VWIN_END_1_LSB        REG(0x00, 0xc0)      \n#define REG_VWIN_START_2_MSB      REG(0x00, 0xc1)      \n#define REG_VWIN_START_2_LSB      REG(0x00, 0xc2)      \n#define REG_VWIN_END_2_MSB        REG(0x00, 0xc3)      \n#define REG_VWIN_END_2_LSB        REG(0x00, 0xc4)      \n#define REG_DE_START_MSB          REG(0x00, 0xc5)      \n#define REG_DE_START_LSB          REG(0x00, 0xc6)      \n#define REG_DE_STOP_MSB           REG(0x00, 0xc7)      \n#define REG_DE_STOP_LSB           REG(0x00, 0xc8)      \n#define REG_TBG_CNTRL_0           REG(0x00, 0xca)      \n# define TBG_CNTRL_0_TOP_TGL      (1 << 0)\n# define TBG_CNTRL_0_TOP_SEL      (1 << 1)\n# define TBG_CNTRL_0_DE_EXT       (1 << 2)\n# define TBG_CNTRL_0_TOP_EXT      (1 << 3)\n# define TBG_CNTRL_0_FRAME_DIS    (1 << 5)\n# define TBG_CNTRL_0_SYNC_MTHD    (1 << 6)\n# define TBG_CNTRL_0_SYNC_ONCE    (1 << 7)\n#define REG_TBG_CNTRL_1           REG(0x00, 0xcb)      \n# define TBG_CNTRL_1_H_TGL        (1 << 0)\n# define TBG_CNTRL_1_V_TGL        (1 << 1)\n# define TBG_CNTRL_1_TGL_EN       (1 << 2)\n# define TBG_CNTRL_1_X_EXT        (1 << 3)\n# define TBG_CNTRL_1_H_EXT        (1 << 4)\n# define TBG_CNTRL_1_V_EXT        (1 << 5)\n# define TBG_CNTRL_1_DWIN_DIS     (1 << 6)\n#define REG_ENABLE_SPACE          REG(0x00, 0xd6)      \n#define REG_HVF_CNTRL_0           REG(0x00, 0xe4)      \n# define HVF_CNTRL_0_SM           (1 << 7)\n# define HVF_CNTRL_0_RWB          (1 << 6)\n# define HVF_CNTRL_0_PREFIL(x)    (((x) & 3) << 2)\n# define HVF_CNTRL_0_INTPOL(x)    (((x) & 3) << 0)\n#define REG_HVF_CNTRL_1           REG(0x00, 0xe5)      \n# define HVF_CNTRL_1_FOR          (1 << 0)\n# define HVF_CNTRL_1_YUVBLK       (1 << 1)\n# define HVF_CNTRL_1_VQR(x)       (((x) & 3) << 2)\n# define HVF_CNTRL_1_PAD(x)       (((x) & 3) << 4)\n# define HVF_CNTRL_1_SEMI_PLANAR  (1 << 6)\n#define REG_RPT_CNTRL             REG(0x00, 0xf0)      \n# define RPT_CNTRL_REPEAT(x)      ((x) & 15)\n#define REG_I2S_FORMAT            REG(0x00, 0xfc)      \n# define I2S_FORMAT_PHILIPS       (0 << 0)\n# define I2S_FORMAT_LEFT_J        (2 << 0)\n# define I2S_FORMAT_RIGHT_J       (3 << 0)\n#define REG_AIP_CLKSEL            REG(0x00, 0xfd)      \n# define AIP_CLKSEL_AIP_SPDIF\t  (0 << 3)\n# define AIP_CLKSEL_AIP_I2S\t  (1 << 3)\n# define AIP_CLKSEL_FS_ACLK\t  (0 << 0)\n# define AIP_CLKSEL_FS_MCLK\t  (1 << 0)\n# define AIP_CLKSEL_FS_FS64SPDIF  (2 << 0)\n\n \n#define REG_PLL_SERIAL_1          REG(0x02, 0x00)      \n# define PLL_SERIAL_1_SRL_FDN     (1 << 0)\n# define PLL_SERIAL_1_SRL_IZ(x)   (((x) & 3) << 1)\n# define PLL_SERIAL_1_SRL_MAN_IZ  (1 << 6)\n#define REG_PLL_SERIAL_2          REG(0x02, 0x01)      \n# define PLL_SERIAL_2_SRL_NOSC(x) ((x) << 0)\n# define PLL_SERIAL_2_SRL_PR(x)   (((x) & 0xf) << 4)\n#define REG_PLL_SERIAL_3          REG(0x02, 0x02)      \n# define PLL_SERIAL_3_SRL_CCIR    (1 << 0)\n# define PLL_SERIAL_3_SRL_DE      (1 << 2)\n# define PLL_SERIAL_3_SRL_PXIN_SEL (1 << 4)\n#define REG_SERIALIZER            REG(0x02, 0x03)      \n#define REG_BUFFER_OUT            REG(0x02, 0x04)      \n#define REG_PLL_SCG1              REG(0x02, 0x05)      \n#define REG_PLL_SCG2              REG(0x02, 0x06)      \n#define REG_PLL_SCGN1             REG(0x02, 0x07)      \n#define REG_PLL_SCGN2             REG(0x02, 0x08)      \n#define REG_PLL_SCGR1             REG(0x02, 0x09)      \n#define REG_PLL_SCGR2             REG(0x02, 0x0a)      \n#define REG_AUDIO_DIV             REG(0x02, 0x0e)      \n# define AUDIO_DIV_SERCLK_1       0\n# define AUDIO_DIV_SERCLK_2       1\n# define AUDIO_DIV_SERCLK_4       2\n# define AUDIO_DIV_SERCLK_8       3\n# define AUDIO_DIV_SERCLK_16      4\n# define AUDIO_DIV_SERCLK_32      5\n#define REG_SEL_CLK               REG(0x02, 0x11)      \n# define SEL_CLK_SEL_CLK1         (1 << 0)\n# define SEL_CLK_SEL_VRF_CLK(x)   (((x) & 3) << 1)\n# define SEL_CLK_ENA_SC_CLK       (1 << 3)\n#define REG_ANA_GENERAL           REG(0x02, 0x12)      \n\n\n \n#define REG_EDID_DATA_0           REG(0x09, 0x00)      \n \n#define REG_EDID_CTRL             REG(0x09, 0xfa)      \n#define REG_DDC_ADDR              REG(0x09, 0xfb)      \n#define REG_DDC_OFFS              REG(0x09, 0xfc)      \n#define REG_DDC_SEGM_ADDR         REG(0x09, 0xfd)      \n#define REG_DDC_SEGM              REG(0x09, 0xfe)      \n\n\n \n#define REG_IF1_HB0               REG(0x10, 0x20)      \n#define REG_IF2_HB0               REG(0x10, 0x40)      \n#define REG_IF3_HB0               REG(0x10, 0x60)      \n#define REG_IF4_HB0               REG(0x10, 0x80)      \n#define REG_IF5_HB0               REG(0x10, 0xa0)      \n\n\n \n#define REG_AIP_CNTRL_0           REG(0x11, 0x00)      \n# define AIP_CNTRL_0_RST_FIFO     (1 << 0)\n# define AIP_CNTRL_0_SWAP         (1 << 1)\n# define AIP_CNTRL_0_LAYOUT       (1 << 2)\n# define AIP_CNTRL_0_ACR_MAN      (1 << 5)\n# define AIP_CNTRL_0_RST_CTS      (1 << 6)\n#define REG_CA_I2S                REG(0x11, 0x01)      \n# define CA_I2S_CA_I2S(x)         (((x) & 31) << 0)\n# define CA_I2S_HBR_CHSTAT        (1 << 6)\n#define REG_LATENCY_RD            REG(0x11, 0x04)      \n#define REG_ACR_CTS_0             REG(0x11, 0x05)      \n#define REG_ACR_CTS_1             REG(0x11, 0x06)      \n#define REG_ACR_CTS_2             REG(0x11, 0x07)      \n#define REG_ACR_N_0               REG(0x11, 0x08)      \n#define REG_ACR_N_1               REG(0x11, 0x09)      \n#define REG_ACR_N_2               REG(0x11, 0x0a)      \n#define REG_CTS_N                 REG(0x11, 0x0c)      \n# define CTS_N_K(x)               (((x) & 7) << 0)\n# define CTS_N_M(x)               (((x) & 3) << 4)\n#define REG_ENC_CNTRL             REG(0x11, 0x0d)      \n# define ENC_CNTRL_RST_ENC        (1 << 0)\n# define ENC_CNTRL_RST_SEL        (1 << 1)\n# define ENC_CNTRL_CTL_CODE(x)    (((x) & 3) << 2)\n#define REG_DIP_FLAGS             REG(0x11, 0x0e)      \n# define DIP_FLAGS_ACR            (1 << 0)\n# define DIP_FLAGS_GC             (1 << 1)\n#define REG_DIP_IF_FLAGS          REG(0x11, 0x0f)      \n# define DIP_IF_FLAGS_IF1         (1 << 1)\n# define DIP_IF_FLAGS_IF2         (1 << 2)\n# define DIP_IF_FLAGS_IF3         (1 << 3)\n# define DIP_IF_FLAGS_IF4         (1 << 4)\n# define DIP_IF_FLAGS_IF5         (1 << 5)\n#define REG_CH_STAT_B(x)          REG(0x11, 0x14 + (x))  \n\n\n \n#define REG_TX3                   REG(0x12, 0x9a)      \n#define REG_TX4                   REG(0x12, 0x9b)      \n# define TX4_PD_RAM               (1 << 1)\n#define REG_TX33                  REG(0x12, 0xb8)      \n# define TX33_HDMI                (1 << 1)\n\n\n \n\n\n\n \n#define REG_CEC_INTSTATUS\t  0xee\t\t       \n# define CEC_INTSTATUS_CEC\t  (1 << 0)\n# define CEC_INTSTATUS_HDMI\t  (1 << 1)\n#define REG_CEC_CAL_XOSC_CTRL1    0xf2\n# define CEC_CAL_XOSC_CTRL1_ENA_CAL\tBIT(0)\n#define REG_CEC_DES_FREQ2         0xf5\n# define CEC_DES_FREQ2_DIS_AUTOCAL BIT(7)\n#define REG_CEC_CLK               0xf6\n# define CEC_CLK_FRO              0x11\n#define REG_CEC_FRO_IM_CLK_CTRL   0xfb                 \n# define CEC_FRO_IM_CLK_CTRL_GHOST_DIS (1 << 7)\n# define CEC_FRO_IM_CLK_CTRL_ENA_OTP   (1 << 6)\n# define CEC_FRO_IM_CLK_CTRL_IMCLK_SEL (1 << 1)\n# define CEC_FRO_IM_CLK_CTRL_FRO_DIV   (1 << 0)\n#define REG_CEC_RXSHPDINTENA\t  0xfc\t\t       \n#define REG_CEC_RXSHPDINT\t  0xfd\t\t       \n# define CEC_RXSHPDINT_RXSENS     BIT(0)\n# define CEC_RXSHPDINT_HPD        BIT(1)\n#define REG_CEC_RXSHPDLEV         0xfe                 \n# define CEC_RXSHPDLEV_RXSENS     (1 << 0)\n# define CEC_RXSHPDLEV_HPD        (1 << 1)\n\n#define REG_CEC_ENAMODS           0xff                 \n# define CEC_ENAMODS_EN_CEC_CLK   (1 << 7)\n# define CEC_ENAMODS_DIS_FRO      (1 << 6)\n# define CEC_ENAMODS_DIS_CCLK     (1 << 5)\n# define CEC_ENAMODS_EN_RXSENS    (1 << 2)\n# define CEC_ENAMODS_EN_HDMI      (1 << 1)\n# define CEC_ENAMODS_EN_CEC       (1 << 0)\n\n\n \n#define TDA9989N2                 0x0101\n#define TDA19989                  0x0201\n#define TDA19989N2                0x0202\n#define TDA19988                  0x0301\n\nstatic void\ncec_write(struct tda998x_priv *priv, u16 addr, u8 val)\n{\n\tu8 buf[] = {addr, val};\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cec_addr,\n\t\t.len = 2,\n\t\t.buf = buf,\n\t};\n\tint ret;\n\n\tret = i2c_transfer(priv->hdmi->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tdev_err(&priv->hdmi->dev, \"Error %d writing to cec:0x%x\\n\",\n\t\t\tret, addr);\n}\n\nstatic u8\ncec_read(struct tda998x_priv *priv, u8 addr)\n{\n\tu8 val;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->cec_addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr,\n\t\t}, {\n\t\t\t.addr = priv->cec_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &val,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(priv->hdmi->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret < 0) {\n\t\tdev_err(&priv->hdmi->dev, \"Error %d reading from cec:0x%x\\n\",\n\t\t\tret, addr);\n\t\tval = 0;\n\t}\n\n\treturn val;\n}\n\nstatic void cec_enamods(struct tda998x_priv *priv, u8 mods, bool enable)\n{\n\tint val = cec_read(priv, REG_CEC_ENAMODS);\n\n\tif (val < 0)\n\t\treturn;\n\n\tif (enable)\n\t\tval |= mods;\n\telse\n\t\tval &= ~mods;\n\n\tcec_write(priv, REG_CEC_ENAMODS, val);\n}\n\nstatic void tda998x_cec_set_calibration(struct tda998x_priv *priv, bool enable)\n{\n\tif (enable) {\n\t\tu8 val;\n\n\t\tcec_write(priv, 0xf3, 0xc0);\n\t\tcec_write(priv, 0xf4, 0xd4);\n\n\t\t \n\t\tval = cec_read(priv, REG_CEC_DES_FREQ2);\n\t\tval &= ~CEC_DES_FREQ2_DIS_AUTOCAL;\n\t\tcec_write(priv, REG_CEC_DES_FREQ2, val);\n\n\t\t \n\t\tcec_write(priv, REG_CEC_CLK, CEC_CLK_FRO);\n\t\tcec_enamods(priv, CEC_ENAMODS_DIS_FRO, false);\n\n\t\tcec_write(priv, REG_CEC_CAL_XOSC_CTRL1,\n\t\t\t  CEC_CAL_XOSC_CTRL1_ENA_CAL);\n\t} else {\n\t\tcec_write(priv, REG_CEC_CAL_XOSC_CTRL1, 0);\n\t}\n}\n\n \nstatic void tda998x_cec_calibration(struct tda998x_priv *priv)\n{\n\tstruct gpio_desc *calib = priv->calib;\n\n\tmutex_lock(&priv->edid_mutex);\n\tif (priv->hdmi->irq > 0)\n\t\tdisable_irq(priv->hdmi->irq);\n\tgpiod_direction_output(calib, 1);\n\ttda998x_cec_set_calibration(priv, true);\n\n\tlocal_irq_disable();\n\tgpiod_set_value(calib, 0);\n\tmdelay(10);\n\tgpiod_set_value(calib, 1);\n\tlocal_irq_enable();\n\n\ttda998x_cec_set_calibration(priv, false);\n\tgpiod_direction_input(calib);\n\tif (priv->hdmi->irq > 0)\n\t\tenable_irq(priv->hdmi->irq);\n\tmutex_unlock(&priv->edid_mutex);\n}\n\nstatic int tda998x_cec_hook_init(void *data)\n{\n\tstruct tda998x_priv *priv = data;\n\tstruct gpio_desc *calib;\n\n\tcalib = gpiod_get(&priv->hdmi->dev, \"nxp,calib\", GPIOD_ASIS);\n\tif (IS_ERR(calib)) {\n\t\tdev_warn(&priv->hdmi->dev, \"failed to get calibration gpio: %ld\\n\",\n\t\t\t PTR_ERR(calib));\n\t\treturn PTR_ERR(calib);\n\t}\n\n\tpriv->calib = calib;\n\n\treturn 0;\n}\n\nstatic void tda998x_cec_hook_exit(void *data)\n{\n\tstruct tda998x_priv *priv = data;\n\n\tgpiod_put(priv->calib);\n\tpriv->calib = NULL;\n}\n\nstatic int tda998x_cec_hook_open(void *data)\n{\n\tstruct tda998x_priv *priv = data;\n\n\tcec_enamods(priv, CEC_ENAMODS_EN_CEC_CLK | CEC_ENAMODS_EN_CEC, true);\n\ttda998x_cec_calibration(priv);\n\n\treturn 0;\n}\n\nstatic void tda998x_cec_hook_release(void *data)\n{\n\tstruct tda998x_priv *priv = data;\n\n\tcec_enamods(priv, CEC_ENAMODS_EN_CEC_CLK | CEC_ENAMODS_EN_CEC, false);\n}\n\nstatic int\nset_page(struct tda998x_priv *priv, u16 reg)\n{\n\tif (REG2PAGE(reg) != priv->current_page) {\n\t\tstruct i2c_client *client = priv->hdmi;\n\t\tu8 buf[] = {\n\t\t\t\tREG_CURPAGE, REG2PAGE(reg)\n\t\t};\n\t\tint ret = i2c_master_send(client, buf, sizeof(buf));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"%s %04x err %d\\n\", __func__,\n\t\t\t\t\treg, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpriv->current_page = REG2PAGE(reg);\n\t}\n\treturn 0;\n}\n\nstatic int\nreg_read_range(struct tda998x_priv *priv, u16 reg, char *buf, int cnt)\n{\n\tstruct i2c_client *client = priv->hdmi;\n\tu8 addr = REG2ADDR(reg);\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tret = set_page(priv, reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = i2c_master_send(client, &addr, sizeof(addr));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_master_recv(client, buf, cnt);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tgoto out;\n\nfail:\n\tdev_err(&client->dev, \"Error %d reading from 0x%x\\n\", ret, reg);\nout:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\n#define MAX_WRITE_RANGE_BUF 32\n\nstatic void\nreg_write_range(struct tda998x_priv *priv, u16 reg, u8 *p, int cnt)\n{\n\tstruct i2c_client *client = priv->hdmi;\n\t \n\tu8 buf[MAX_WRITE_RANGE_BUF + 1];\n\tint ret;\n\n\tif (cnt > MAX_WRITE_RANGE_BUF) {\n\t\tdev_err(&client->dev, \"Fixed write buffer too small (%d)\\n\",\n\t\t\t\tMAX_WRITE_RANGE_BUF);\n\t\treturn;\n\t}\n\n\tbuf[0] = REG2ADDR(reg);\n\tmemcpy(&buf[1], p, cnt);\n\n\tmutex_lock(&priv->mutex);\n\tret = set_page(priv, reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = i2c_master_send(client, buf, cnt + 1);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error %d writing to 0x%x\\n\", ret, reg);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int\nreg_read(struct tda998x_priv *priv, u16 reg)\n{\n\tu8 val = 0;\n\tint ret;\n\n\tret = reg_read_range(priv, reg, &val, sizeof(val));\n\tif (ret < 0)\n\t\treturn ret;\n\treturn val;\n}\n\nstatic void\nreg_write(struct tda998x_priv *priv, u16 reg, u8 val)\n{\n\tstruct i2c_client *client = priv->hdmi;\n\tu8 buf[] = {REG2ADDR(reg), val};\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tret = set_page(priv, reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = i2c_master_send(client, buf, sizeof(buf));\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error %d writing to 0x%x\\n\", ret, reg);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void\nreg_write16(struct tda998x_priv *priv, u16 reg, u16 val)\n{\n\tstruct i2c_client *client = priv->hdmi;\n\tu8 buf[] = {REG2ADDR(reg), val >> 8, val};\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tret = set_page(priv, reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = i2c_master_send(client, buf, sizeof(buf));\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error %d writing to 0x%x\\n\", ret, reg);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void\nreg_set(struct tda998x_priv *priv, u16 reg, u8 val)\n{\n\tint old_val;\n\n\told_val = reg_read(priv, reg);\n\tif (old_val >= 0)\n\t\treg_write(priv, reg, old_val | val);\n}\n\nstatic void\nreg_clear(struct tda998x_priv *priv, u16 reg, u8 val)\n{\n\tint old_val;\n\n\told_val = reg_read(priv, reg);\n\tif (old_val >= 0)\n\t\treg_write(priv, reg, old_val & ~val);\n}\n\nstatic void\ntda998x_reset(struct tda998x_priv *priv)\n{\n\t \n\treg_write(priv, REG_SOFTRESET, SOFTRESET_AUDIO | SOFTRESET_I2C_MASTER);\n\tmsleep(50);\n\treg_write(priv, REG_SOFTRESET, 0);\n\tmsleep(50);\n\n\t \n\treg_set(priv, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\n\treg_clear(priv, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\n\n\t \n\treg_write(priv, REG_PLL_SERIAL_1, 0x00);\n\treg_write(priv, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(1));\n\treg_write(priv, REG_PLL_SERIAL_3, 0x00);\n\treg_write(priv, REG_SERIALIZER,   0x00);\n\treg_write(priv, REG_BUFFER_OUT,   0x00);\n\treg_write(priv, REG_PLL_SCG1,     0x00);\n\treg_write(priv, REG_AUDIO_DIV,    AUDIO_DIV_SERCLK_8);\n\treg_write(priv, REG_SEL_CLK,      SEL_CLK_SEL_CLK1 | SEL_CLK_ENA_SC_CLK);\n\treg_write(priv, REG_PLL_SCGN1,    0xfa);\n\treg_write(priv, REG_PLL_SCGN2,    0x00);\n\treg_write(priv, REG_PLL_SCGR1,    0x5b);\n\treg_write(priv, REG_PLL_SCGR2,    0x00);\n\treg_write(priv, REG_PLL_SCG2,     0x10);\n\n\t \n\treg_write(priv, REG_MUX_VP_VIP_OUT, 0x24);\n}\n\n \nstatic void tda998x_edid_delay_done(struct timer_list *t)\n{\n\tstruct tda998x_priv *priv = from_timer(priv, t, edid_delay_timer);\n\n\tpriv->edid_delay_active = false;\n\twake_up(&priv->edid_delay_waitq);\n\tschedule_work(&priv->detect_work);\n}\n\nstatic void tda998x_edid_delay_start(struct tda998x_priv *priv)\n{\n\tpriv->edid_delay_active = true;\n\tmod_timer(&priv->edid_delay_timer, jiffies + HZ/10);\n}\n\nstatic int tda998x_edid_delay_wait(struct tda998x_priv *priv)\n{\n\treturn wait_event_killable(priv->edid_delay_waitq, !priv->edid_delay_active);\n}\n\n \nstatic void tda998x_detect_work(struct work_struct *work)\n{\n\tstruct tda998x_priv *priv =\n\t\tcontainer_of(work, struct tda998x_priv, detect_work);\n\tstruct drm_device *dev = priv->connector.dev;\n\n\tif (dev)\n\t\tdrm_kms_helper_hotplug_event(dev);\n}\n\n \nstatic irqreturn_t tda998x_irq_thread(int irq, void *data)\n{\n\tstruct tda998x_priv *priv = data;\n\tu8 sta, cec, lvl, flag0, flag1, flag2;\n\tbool handled = false;\n\n\tsta = cec_read(priv, REG_CEC_INTSTATUS);\n\tif (sta & CEC_INTSTATUS_HDMI) {\n\t\tcec = cec_read(priv, REG_CEC_RXSHPDINT);\n\t\tlvl = cec_read(priv, REG_CEC_RXSHPDLEV);\n\t\tflag0 = reg_read(priv, REG_INT_FLAGS_0);\n\t\tflag1 = reg_read(priv, REG_INT_FLAGS_1);\n\t\tflag2 = reg_read(priv, REG_INT_FLAGS_2);\n\t\tDRM_DEBUG_DRIVER(\n\t\t\t\"tda irq sta %02x cec %02x lvl %02x f0 %02x f1 %02x f2 %02x\\n\",\n\t\t\tsta, cec, lvl, flag0, flag1, flag2);\n\n\t\tif (cec & CEC_RXSHPDINT_HPD) {\n\t\t\tif (lvl & CEC_RXSHPDLEV_HPD) {\n\t\t\t\ttda998x_edid_delay_start(priv);\n\t\t\t} else {\n\t\t\t\tschedule_work(&priv->detect_work);\n\t\t\t\tcec_notifier_phys_addr_invalidate(\n\t\t\t\t\t\tpriv->cec_notify);\n\t\t\t}\n\n\t\t\thandled = true;\n\t\t}\n\n\t\tif ((flag2 & INT_FLAGS_2_EDID_BLK_RD) && priv->wq_edid_wait) {\n\t\t\tpriv->wq_edid_wait = 0;\n\t\t\twake_up(&priv->wq_edid);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void\ntda998x_write_if(struct tda998x_priv *priv, u8 bit, u16 addr,\n\t\t union hdmi_infoframe *frame)\n{\n\tu8 buf[MAX_WRITE_RANGE_BUF];\n\tssize_t len;\n\n\tlen = hdmi_infoframe_pack(frame, buf, sizeof(buf));\n\tif (len < 0) {\n\t\tdev_err(&priv->hdmi->dev,\n\t\t\t\"hdmi_infoframe_pack() type=0x%02x failed: %zd\\n\",\n\t\t\tframe->any.type, len);\n\t\treturn;\n\t}\n\n\treg_clear(priv, REG_DIP_IF_FLAGS, bit);\n\treg_write_range(priv, addr, buf, len);\n\treg_set(priv, REG_DIP_IF_FLAGS, bit);\n}\n\nstatic void tda998x_write_aif(struct tda998x_priv *priv,\n\t\t\t      const struct hdmi_audio_infoframe *cea)\n{\n\tunion hdmi_infoframe frame;\n\n\tframe.audio = *cea;\n\n\ttda998x_write_if(priv, DIP_IF_FLAGS_IF4, REG_IF4_HB0, &frame);\n}\n\nstatic void\ntda998x_write_avi(struct tda998x_priv *priv, const struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe frame;\n\n\tdrm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t &priv->connector, mode);\n\tframe.avi.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;\n\tdrm_hdmi_avi_infoframe_quant_range(&frame.avi, &priv->connector, mode,\n\t\t\t\t\t   priv->rgb_quant_range);\n\n\ttda998x_write_if(priv, DIP_IF_FLAGS_IF2, REG_IF2_HB0, &frame);\n}\n\nstatic void tda998x_write_vsi(struct tda998x_priv *priv,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe frame;\n\n\tif (drm_hdmi_vendor_infoframe_from_display_mode(&frame.vendor.hdmi,\n\t\t\t\t\t\t\t&priv->connector,\n\t\t\t\t\t\t\tmode))\n\t\treg_clear(priv, REG_DIP_IF_FLAGS, DIP_IF_FLAGS_IF1);\n\telse\n\t\ttda998x_write_if(priv, DIP_IF_FLAGS_IF1, REG_IF1_HB0, &frame);\n}\n\n \n\nstatic const struct tda998x_audio_route tda998x_audio_route[AUDIO_ROUTE_NUM] = {\n\t[AUDIO_ROUTE_I2S] = {\n\t\t.ena_aclk = 1,\n\t\t.mux_ap = MUX_AP_SELECT_I2S,\n\t\t.aip_clksel = AIP_CLKSEL_AIP_I2S | AIP_CLKSEL_FS_ACLK,\n\t},\n\t[AUDIO_ROUTE_SPDIF] = {\n\t\t.ena_aclk = 0,\n\t\t.mux_ap = MUX_AP_SELECT_SPDIF,\n\t\t.aip_clksel = AIP_CLKSEL_AIP_SPDIF | AIP_CLKSEL_FS_FS64SPDIF,\n\t},\n};\n\n \nstatic int tda998x_derive_routing(struct tda998x_priv *priv,\n\t\t\t\t  struct tda998x_audio_settings *s,\n\t\t\t\t  unsigned int route)\n{\n\ts->route = &tda998x_audio_route[route];\n\ts->ena_ap = priv->audio_port_enable[route];\n\tif (s->ena_ap == 0) {\n\t\tdev_err(&priv->hdmi->dev, \"no audio configuration found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 tda998x_get_adiv(struct tda998x_priv *priv, unsigned int fs)\n{\n\tunsigned long min_audio_clk = fs * 128;\n\tunsigned long ser_clk = priv->tmds_clock * 1000;\n\tu8 adiv;\n\n\tfor (adiv = AUDIO_DIV_SERCLK_32; adiv != AUDIO_DIV_SERCLK_1; adiv--)\n\t\tif (ser_clk > min_audio_clk << adiv)\n\t\t\tbreak;\n\n\tdev_dbg(&priv->hdmi->dev,\n\t\t\"ser_clk=%luHz fs=%uHz min_aclk=%luHz adiv=%d\\n\",\n\t\tser_clk, fs, min_audio_clk, adiv);\n\n\treturn adiv;\n}\n\n \nstatic int tda998x_derive_cts_n(struct tda998x_priv *priv,\n\t\t\t\tstruct tda998x_audio_settings *settings,\n\t\t\t\tunsigned int ratio)\n{\n\tswitch (ratio) {\n\tcase 16:\n\t\tsettings->cts_n = CTS_N_M(3) | CTS_N_K(0);\n\t\tbreak;\n\tcase 32:\n\t\tsettings->cts_n = CTS_N_M(3) | CTS_N_K(1);\n\t\tbreak;\n\tcase 48:\n\t\tsettings->cts_n = CTS_N_M(3) | CTS_N_K(2);\n\t\tbreak;\n\tcase 64:\n\t\tsettings->cts_n = CTS_N_M(3) | CTS_N_K(3);\n\t\tbreak;\n\tcase 128:\n\t\tsettings->cts_n = CTS_N_M(0) | CTS_N_K(0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->hdmi->dev, \"unsupported bclk ratio %ufs\\n\",\n\t\t\tratio);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void tda998x_audio_mute(struct tda998x_priv *priv, bool on)\n{\n\tif (on) {\n\t\treg_set(priv, REG_SOFTRESET, SOFTRESET_AUDIO);\n\t\treg_clear(priv, REG_SOFTRESET, SOFTRESET_AUDIO);\n\t\treg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\n\t} else {\n\t\treg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\n\t}\n}\n\nstatic void tda998x_configure_audio(struct tda998x_priv *priv)\n{\n\tconst struct tda998x_audio_settings *settings = &priv->audio;\n\tu8 buf[6], adiv;\n\tu32 n;\n\n\t \n\tif (settings->ena_ap == 0)\n\t\treturn;\n\n\tadiv = tda998x_get_adiv(priv, settings->sample_rate);\n\n\t \n\treg_write(priv, REG_ENA_AP, settings->ena_ap);\n\treg_write(priv, REG_ENA_ACLK, settings->route->ena_aclk);\n\treg_write(priv, REG_MUX_AP, settings->route->mux_ap);\n\treg_write(priv, REG_I2S_FORMAT, settings->i2s_format);\n\treg_write(priv, REG_AIP_CLKSEL, settings->route->aip_clksel);\n\treg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_LAYOUT |\n\t\t\t\t\tAIP_CNTRL_0_ACR_MAN);\t \n\treg_write(priv, REG_CTS_N, settings->cts_n);\n\treg_write(priv, REG_AUDIO_DIV, adiv);\n\n\t \n\tn = 128 * settings->sample_rate / 1000;\n\n\t \n\tbuf[0] = 0x44;\n\tbuf[1] = 0x42;\n\tbuf[2] = 0x01;\n\tbuf[3] = n;\n\tbuf[4] = n >> 8;\n\tbuf[5] = n >> 16;\n\treg_write_range(priv, REG_ACR_CTS_0, buf, 6);\n\n\t \n\treg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_CTS);\n\treg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_CTS);\n\n\t \n\tbuf[0] = settings->status[0];\n\tbuf[1] = settings->status[1];\n\tbuf[2] = settings->status[3];\n\tbuf[3] = settings->status[4];\n\treg_write_range(priv, REG_CH_STAT_B(0), buf, 4);\n\n\ttda998x_audio_mute(priv, true);\n\tmsleep(20);\n\ttda998x_audio_mute(priv, false);\n\n\ttda998x_write_aif(priv, &settings->cea);\n}\n\nstatic int tda998x_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t   struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t   struct hdmi_codec_params *params)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\tunsigned int bclk_ratio;\n\tbool spdif = daifmt->fmt == HDMI_SPDIF;\n\tint ret;\n\tstruct tda998x_audio_settings audio = {\n\t\t.sample_rate = params->sample_rate,\n\t\t.cea = params->cea,\n\t};\n\n\tmemcpy(audio.status, params->iec.status,\n\t       min(sizeof(audio.status), sizeof(params->iec.status)));\n\n\tswitch (daifmt->fmt) {\n\tcase HDMI_I2S:\n\t\taudio.i2s_format = I2S_FORMAT_PHILIPS;\n\t\tbreak;\n\tcase HDMI_LEFT_J:\n\t\taudio.i2s_format = I2S_FORMAT_LEFT_J;\n\t\tbreak;\n\tcase HDMI_RIGHT_J:\n\t\taudio.i2s_format = I2S_FORMAT_RIGHT_J;\n\t\tbreak;\n\tcase HDMI_SPDIF:\n\t\taudio.i2s_format = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s: Invalid format %d\\n\", __func__, daifmt->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!spdif &&\n\t    (daifmt->bit_clk_inv || daifmt->frame_clk_inv ||\n\t     daifmt->bit_clk_provider || daifmt->frame_clk_provider)) {\n\t\tdev_err(dev, \"%s: Bad flags %d %d %d %d\\n\", __func__,\n\t\t\tdaifmt->bit_clk_inv, daifmt->frame_clk_inv,\n\t\t\tdaifmt->bit_clk_provider,\n\t\t\tdaifmt->frame_clk_provider);\n\t\treturn -EINVAL;\n\t}\n\n\tret = tda998x_derive_routing(priv, &audio, AUDIO_ROUTE_I2S + spdif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbclk_ratio = spdif ? 64 : params->sample_width * 2;\n\tret = tda998x_derive_cts_n(priv, &audio, bclk_ratio);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&priv->audio_mutex);\n\tpriv->audio = audio;\n\tif (priv->supports_infoframes && priv->sink_has_audio)\n\t\ttda998x_configure_audio(priv);\n\tmutex_unlock(&priv->audio_mutex);\n\n\treturn 0;\n}\n\nstatic void tda998x_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->audio_mutex);\n\n\treg_write(priv, REG_ENA_AP, 0);\n\tpriv->audio.ena_ap = 0;\n\n\tmutex_unlock(&priv->audio_mutex);\n}\n\nstatic int tda998x_audio_mute_stream(struct device *dev, void *data,\n\t\t\t\t     bool enable, int direction)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->audio_mutex);\n\n\ttda998x_audio_mute(priv, enable);\n\n\tmutex_unlock(&priv->audio_mutex);\n\treturn 0;\n}\n\nstatic int tda998x_audio_get_eld(struct device *dev, void *data,\n\t\t\t\t uint8_t *buf, size_t len)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\n\tmutex_lock(&priv->audio_mutex);\n\tmemcpy(buf, priv->connector.eld,\n\t       min(sizeof(priv->connector.eld), len));\n\tmutex_unlock(&priv->audio_mutex);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops audio_codec_ops = {\n\t.hw_params = tda998x_audio_hw_params,\n\t.audio_shutdown = tda998x_audio_shutdown,\n\t.mute_stream = tda998x_audio_mute_stream,\n\t.get_eld = tda998x_audio_get_eld,\n\t.no_capture_mute = 1,\n};\n\nstatic int tda998x_audio_codec_init(struct tda998x_priv *priv,\n\t\t\t\t    struct device *dev)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &audio_codec_ops,\n\t\t.max_i2s_channels = 2,\n\t\t.no_i2s_capture = 1,\n\t\t.no_spdif_capture = 1,\n\t};\n\n\tif (priv->audio_port_enable[AUDIO_ROUTE_I2S])\n\t\tcodec_data.i2s = 1;\n\tif (priv->audio_port_enable[AUDIO_ROUTE_SPDIF])\n\t\tcodec_data.spdif = 1;\n\n\tpriv->audio_pdev = platform_device_register_data(\n\t\tdev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,\n\t\t&codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(priv->audio_pdev);\n}\n\n \n\nstatic enum drm_connector_status\ntda998x_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\n\tu8 val = cec_read(priv, REG_CEC_RXSHPDLEV);\n\n\treturn (val & CEC_RXSHPDLEV_HPD) ? connector_status_connected :\n\t\t\tconnector_status_disconnected;\n}\n\nstatic void tda998x_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs tda998x_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = tda998x_connector_detect,\n\t.destroy = tda998x_connector_destroy,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int read_edid_block(void *data, u8 *buf, unsigned int blk, size_t length)\n{\n\tstruct tda998x_priv *priv = data;\n\tu8 offset, segptr;\n\tint ret, i;\n\n\toffset = (blk & 1) ? 128 : 0;\n\tsegptr = blk / 2;\n\n\tmutex_lock(&priv->edid_mutex);\n\n\treg_write(priv, REG_DDC_ADDR, 0xa0);\n\treg_write(priv, REG_DDC_OFFS, offset);\n\treg_write(priv, REG_DDC_SEGM_ADDR, 0x60);\n\treg_write(priv, REG_DDC_SEGM, segptr);\n\n\t \n\tpriv->wq_edid_wait = 1;\n\treg_write(priv, REG_EDID_CTRL, 0x1);\n\n\t \n\treg_write(priv, REG_EDID_CTRL, 0x0);\n\n\t \n\tif (priv->hdmi->irq) {\n\t\ti = wait_event_timeout(priv->wq_edid,\n\t\t\t\t\t!priv->wq_edid_wait,\n\t\t\t\t\tmsecs_to_jiffies(100));\n\t\tif (i < 0) {\n\t\t\tdev_err(&priv->hdmi->dev, \"read edid wait err %d\\n\", i);\n\t\t\tret = i;\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tfor (i = 100; i > 0; i--) {\n\t\t\tmsleep(1);\n\t\t\tret = reg_read(priv, REG_INT_FLAGS_2);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto failed;\n\t\t\tif (ret & INT_FLAGS_2_EDID_BLK_RD)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(&priv->hdmi->dev, \"read edid timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto failed;\n\t}\n\n\tret = reg_read_range(priv, REG_EDID_DATA_0, buf, length);\n\tif (ret != length) {\n\t\tdev_err(&priv->hdmi->dev, \"failed to read edid block %d: %d\\n\",\n\t\t\tblk, ret);\n\t\tgoto failed;\n\t}\n\n\tret = 0;\n\n failed:\n\tmutex_unlock(&priv->edid_mutex);\n\treturn ret;\n}\n\nstatic int tda998x_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\n\tstruct edid *edid;\n\tint n;\n\n\t \n\tif (tda998x_edid_delay_wait(priv))\n\t\treturn 0;\n\n\tif (priv->rev == TDA19988)\n\t\treg_clear(priv, REG_TX4, TX4_PD_RAM);\n\n\tedid = drm_do_get_edid(connector, read_edid_block, priv);\n\n\tif (priv->rev == TDA19988)\n\t\treg_set(priv, REG_TX4, TX4_PD_RAM);\n\n\tif (!edid) {\n\t\tdev_warn(&priv->hdmi->dev, \"failed to read EDID\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcec_notifier_set_phys_addr_from_edid(priv->cec_notify, edid);\n\n\tmutex_lock(&priv->audio_mutex);\n\tn = drm_add_edid_modes(connector, edid);\n\tpriv->sink_has_audio = drm_detect_monitor_audio(edid);\n\tmutex_unlock(&priv->audio_mutex);\n\n\tkfree(edid);\n\n\treturn n;\n}\n\nstatic struct drm_encoder *\ntda998x_connector_best_encoder(struct drm_connector *connector)\n{\n\tstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\n\n\treturn priv->bridge.encoder;\n}\n\nstatic\nconst struct drm_connector_helper_funcs tda998x_connector_helper_funcs = {\n\t.get_modes = tda998x_connector_get_modes,\n\t.best_encoder = tda998x_connector_best_encoder,\n};\n\nstatic int tda998x_connector_init(struct tda998x_priv *priv,\n\t\t\t\t  struct drm_device *drm)\n{\n\tstruct drm_connector *connector = &priv->connector;\n\tint ret;\n\n\tconnector->interlace_allowed = 1;\n\n\tif (priv->hdmi->irq)\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\telse\n\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\n\tdrm_connector_helper_add(connector, &tda998x_connector_helper_funcs);\n\tret = drm_connector_init(drm, connector, &tda998x_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_HDMIA);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_attach_encoder(&priv->connector,\n\t\t\t\t     priv->bridge.encoder);\n\n\treturn 0;\n}\n\n \n\nstatic int tda998x_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {\n\t\tDRM_ERROR(\"Fix bridge driver to make connector optional!\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn tda998x_connector_init(priv, bridge->dev);\n}\n\nstatic void tda998x_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\n\tdrm_connector_cleanup(&priv->connector);\n}\n\nstatic enum drm_mode_status tda998x_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t     const struct drm_display_info *info,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\t \n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\n\tif (mode->clock > ((priv->rev == TDA19988) ? 165000 : 150000))\n\t\treturn MODE_CLOCK_HIGH;\n\tif (mode->htotal >= BIT(13))\n\t\treturn MODE_BAD_HVALUE;\n\tif (mode->vtotal >= BIT(11))\n\t\treturn MODE_BAD_VVALUE;\n\treturn MODE_OK;\n}\n\nstatic void tda998x_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\n\tif (!priv->is_on) {\n\t\t \n\t\treg_write(priv, REG_ENA_VP_0, 0xff);\n\t\treg_write(priv, REG_ENA_VP_1, 0xff);\n\t\treg_write(priv, REG_ENA_VP_2, 0xff);\n\t\t \n\t\treg_write(priv, REG_VIP_CNTRL_0, priv->vip_cntrl_0);\n\t\treg_write(priv, REG_VIP_CNTRL_1, priv->vip_cntrl_1);\n\t\treg_write(priv, REG_VIP_CNTRL_2, priv->vip_cntrl_2);\n\n\t\tpriv->is_on = true;\n\t}\n}\n\nstatic void tda998x_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\n\tif (priv->is_on) {\n\t\t \n\t\treg_write(priv, REG_ENA_VP_0, 0x00);\n\t\treg_write(priv, REG_ENA_VP_1, 0x00);\n\t\treg_write(priv, REG_ENA_VP_2, 0x00);\n\n\t\tpriv->is_on = false;\n\t}\n}\n\nstatic void tda998x_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\tstruct tda998x_priv *priv = bridge_to_tda998x_priv(bridge);\n\tunsigned long tmds_clock;\n\tu16 ref_pix, ref_line, n_pix, n_line;\n\tu16 hs_pix_s, hs_pix_e;\n\tu16 vs1_pix_s, vs1_pix_e, vs1_line_s, vs1_line_e;\n\tu16 vs2_pix_s, vs2_pix_e, vs2_line_s, vs2_line_e;\n\tu16 vwin1_line_s, vwin1_line_e;\n\tu16 vwin2_line_s, vwin2_line_e;\n\tu16 de_pix_s, de_pix_e;\n\tu8 reg, div, rep, sel_clk;\n\n\t \n\tpriv->rgb_quant_range =\n\t\tpriv->connector.display_info.rgb_quant_range_selectable ?\n\t\tHDMI_QUANTIZATION_RANGE_FULL :\n\t\tdrm_default_rgb_quant_range(adjusted_mode);\n\n\t \n\tn_pix        = mode->htotal;\n\tn_line       = mode->vtotal;\n\n\ths_pix_e     = mode->hsync_end - mode->hdisplay;\n\ths_pix_s     = mode->hsync_start - mode->hdisplay;\n\tde_pix_e     = mode->htotal;\n\tde_pix_s     = mode->htotal - mode->hdisplay;\n\tref_pix      = 3 + hs_pix_s;\n\n\t \n\tif (adjusted_mode->flags & DRM_MODE_FLAG_HSKEW)\n\t\tref_pix += adjusted_mode->hskew;\n\n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) == 0) {\n\t\tref_line     = 1 + mode->vsync_start - mode->vdisplay;\n\t\tvwin1_line_s = mode->vtotal - mode->vdisplay - 1;\n\t\tvwin1_line_e = vwin1_line_s + mode->vdisplay;\n\t\tvs1_pix_s    = vs1_pix_e = hs_pix_s;\n\t\tvs1_line_s   = mode->vsync_start - mode->vdisplay;\n\t\tvs1_line_e   = vs1_line_s +\n\t\t\t       mode->vsync_end - mode->vsync_start;\n\t\tvwin2_line_s = vwin2_line_e = 0;\n\t\tvs2_pix_s    = vs2_pix_e  = 0;\n\t\tvs2_line_s   = vs2_line_e = 0;\n\t} else {\n\t\tref_line     = 1 + (mode->vsync_start - mode->vdisplay)/2;\n\t\tvwin1_line_s = (mode->vtotal - mode->vdisplay)/2;\n\t\tvwin1_line_e = vwin1_line_s + mode->vdisplay/2;\n\t\tvs1_pix_s    = vs1_pix_e = hs_pix_s;\n\t\tvs1_line_s   = (mode->vsync_start - mode->vdisplay)/2;\n\t\tvs1_line_e   = vs1_line_s +\n\t\t\t       (mode->vsync_end - mode->vsync_start)/2;\n\t\tvwin2_line_s = vwin1_line_s + mode->vtotal/2;\n\t\tvwin2_line_e = vwin2_line_s + mode->vdisplay/2;\n\t\tvs2_pix_s    = vs2_pix_e = hs_pix_s + mode->htotal/2;\n\t\tvs2_line_s   = vs1_line_s + mode->vtotal/2 ;\n\t\tvs2_line_e   = vs2_line_s +\n\t\t\t       (mode->vsync_end - mode->vsync_start)/2;\n\t}\n\n\t \n\trep = mode->flags & DRM_MODE_FLAG_DBLCLK ? 1 : 0;\n\tsel_clk = SEL_CLK_ENA_SC_CLK | SEL_CLK_SEL_CLK1 |\n\t\t  SEL_CLK_SEL_VRF_CLK(rep ? 2 : 0);\n\n\t \n\ttmds_clock = mode->clock * (1 + rep);\n\n\t \n\tfor (div = 0; div < 3; div++)\n\t\tif (80000 >> div <= tmds_clock)\n\t\t\tbreak;\n\n\tmutex_lock(&priv->audio_mutex);\n\n\tpriv->tmds_clock = tmds_clock;\n\n\t \n\treg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\n\n\t \n\treg_write(priv, REG_TBG_CNTRL_1, TBG_CNTRL_1_DWIN_DIS);\n\treg_clear(priv, REG_TX33, TX33_HDMI);\n\treg_write(priv, REG_ENC_CNTRL, ENC_CNTRL_CTL_CODE(0));\n\n\t \n\treg_write(priv, REG_HVF_CNTRL_0, HVF_CNTRL_0_PREFIL(0) |\n\t\t\tHVF_CNTRL_0_INTPOL(0));\n\treg_set(priv, REG_FEAT_POWERDOWN, FEAT_POWERDOWN_PREFILT);\n\treg_write(priv, REG_VIP_CNTRL_5, VIP_CNTRL_5_SP_CNT(0));\n\treg_write(priv, REG_VIP_CNTRL_4, VIP_CNTRL_4_BLANKIT(0) |\n\t\t\tVIP_CNTRL_4_BLC(0));\n\n\treg_clear(priv, REG_PLL_SERIAL_1, PLL_SERIAL_1_SRL_MAN_IZ);\n\treg_clear(priv, REG_PLL_SERIAL_3, PLL_SERIAL_3_SRL_CCIR |\n\t\t\t\t\t  PLL_SERIAL_3_SRL_DE);\n\treg_write(priv, REG_SERIALIZER, 0);\n\treg_write(priv, REG_HVF_CNTRL_1, HVF_CNTRL_1_VQR(0));\n\n\treg_write(priv, REG_RPT_CNTRL, RPT_CNTRL_REPEAT(rep));\n\treg_write(priv, REG_SEL_CLK, sel_clk);\n\treg_write(priv, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(div) |\n\t\t\tPLL_SERIAL_2_SRL_PR(rep));\n\n\t \n\tif (priv->rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED) {\n\t\tstatic u8 tda998x_full_to_limited_range[] = {\n\t\t\tMAT_CONTRL_MAT_SC(2),\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x03, 0x6f, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x03, 0x6f, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x03, 0x6f,\n\t\t\t0x00, 0x40, 0x00, 0x40, 0x00, 0x40\n\t\t};\n\t\treg_clear(priv, REG_FEAT_POWERDOWN, FEAT_POWERDOWN_CSC);\n\t\treg_write_range(priv, REG_MAT_CONTRL,\n\t\t\t\ttda998x_full_to_limited_range,\n\t\t\t\tsizeof(tda998x_full_to_limited_range));\n\t} else {\n\t\treg_write(priv, REG_MAT_CONTRL, MAT_CONTRL_MAT_BP |\n\t\t\t\t\tMAT_CONTRL_MAT_SC(1));\n\t\treg_set(priv, REG_FEAT_POWERDOWN, FEAT_POWERDOWN_CSC);\n\t}\n\n\t \n\treg_write(priv, REG_ANA_GENERAL, 0x09);\n\n\t \n\treg = VIP_CNTRL_3_SYNC_HS;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\treg |= VIP_CNTRL_3_H_TGL;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\treg |= VIP_CNTRL_3_V_TGL;\n\treg_write(priv, REG_VIP_CNTRL_3, reg);\n\n\treg_write(priv, REG_VIDFORMAT, 0x00);\n\treg_write16(priv, REG_REFPIX_MSB, ref_pix);\n\treg_write16(priv, REG_REFLINE_MSB, ref_line);\n\treg_write16(priv, REG_NPIX_MSB, n_pix);\n\treg_write16(priv, REG_NLINE_MSB, n_line);\n\treg_write16(priv, REG_VS_LINE_STRT_1_MSB, vs1_line_s);\n\treg_write16(priv, REG_VS_PIX_STRT_1_MSB, vs1_pix_s);\n\treg_write16(priv, REG_VS_LINE_END_1_MSB, vs1_line_e);\n\treg_write16(priv, REG_VS_PIX_END_1_MSB, vs1_pix_e);\n\treg_write16(priv, REG_VS_LINE_STRT_2_MSB, vs2_line_s);\n\treg_write16(priv, REG_VS_PIX_STRT_2_MSB, vs2_pix_s);\n\treg_write16(priv, REG_VS_LINE_END_2_MSB, vs2_line_e);\n\treg_write16(priv, REG_VS_PIX_END_2_MSB, vs2_pix_e);\n\treg_write16(priv, REG_HS_PIX_START_MSB, hs_pix_s);\n\treg_write16(priv, REG_HS_PIX_STOP_MSB, hs_pix_e);\n\treg_write16(priv, REG_VWIN_START_1_MSB, vwin1_line_s);\n\treg_write16(priv, REG_VWIN_END_1_MSB, vwin1_line_e);\n\treg_write16(priv, REG_VWIN_START_2_MSB, vwin2_line_s);\n\treg_write16(priv, REG_VWIN_END_2_MSB, vwin2_line_e);\n\treg_write16(priv, REG_DE_START_MSB, de_pix_s);\n\treg_write16(priv, REG_DE_STOP_MSB, de_pix_e);\n\n\tif (priv->rev == TDA19988) {\n\t\t \n\t\treg_write(priv, REG_ENABLE_SPACE, 0x00);\n\t}\n\n\t \n\treg = TBG_CNTRL_1_DWIN_DIS | TBG_CNTRL_1_TGL_EN;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\treg |= TBG_CNTRL_1_H_TGL;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\treg |= TBG_CNTRL_1_V_TGL;\n\treg_write(priv, REG_TBG_CNTRL_1, reg);\n\n\t \n\treg_write(priv, REG_TBG_CNTRL_0, 0);\n\n\t \n\tpriv->supports_infoframes = priv->connector.display_info.cea_rev >= 3;\n\n\tif (priv->supports_infoframes) {\n\t\t \n\t\treg &= ~TBG_CNTRL_1_DWIN_DIS;\n\t\treg_write(priv, REG_TBG_CNTRL_1, reg);\n\t\treg_write(priv, REG_ENC_CNTRL, ENC_CNTRL_CTL_CODE(1));\n\t\treg_set(priv, REG_TX33, TX33_HDMI);\n\n\t\ttda998x_write_avi(priv, adjusted_mode);\n\t\ttda998x_write_vsi(priv, adjusted_mode);\n\n\t\tif (priv->sink_has_audio)\n\t\t\ttda998x_configure_audio(priv);\n\t}\n\n\tmutex_unlock(&priv->audio_mutex);\n}\n\nstatic const struct drm_bridge_funcs tda998x_bridge_funcs = {\n\t.attach = tda998x_bridge_attach,\n\t.detach = tda998x_bridge_detach,\n\t.mode_valid = tda998x_bridge_mode_valid,\n\t.disable = tda998x_bridge_disable,\n\t.mode_set = tda998x_bridge_mode_set,\n\t.enable = tda998x_bridge_enable,\n};\n\n \n\nstatic int tda998x_get_audio_ports(struct tda998x_priv *priv,\n\t\t\t\t   struct device_node *np)\n{\n\tconst u32 *port_data;\n\tu32 size;\n\tint i;\n\n\tport_data = of_get_property(np, \"audio-ports\", &size);\n\tif (!port_data)\n\t\treturn 0;\n\n\tsize /= sizeof(u32);\n\tif (size > 2 * ARRAY_SIZE(priv->audio_port_enable) || size % 2 != 0) {\n\t\tdev_err(&priv->hdmi->dev,\n\t\t\t\"Bad number of elements in audio-ports dt-property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize /= 2;\n\n\tfor (i = 0; i < size; i++) {\n\t\tunsigned int route;\n\t\tu8 afmt = be32_to_cpup(&port_data[2*i]);\n\t\tu8 ena_ap = be32_to_cpup(&port_data[2*i+1]);\n\n\t\tswitch (afmt) {\n\t\tcase AFMT_I2S:\n\t\t\troute = AUDIO_ROUTE_I2S;\n\t\t\tbreak;\n\t\tcase AFMT_SPDIF:\n\t\t\troute = AUDIO_ROUTE_SPDIF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&priv->hdmi->dev,\n\t\t\t\t\"Bad audio format %u\\n\", afmt);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ena_ap) {\n\t\t\tdev_err(&priv->hdmi->dev, \"invalid zero port config\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (priv->audio_port_enable[route]) {\n\t\t\tdev_err(&priv->hdmi->dev,\n\t\t\t\t\"%s format already configured\\n\",\n\t\t\t\troute == AUDIO_ROUTE_SPDIF ? \"SPDIF\" : \"I2S\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->audio_port_enable[route] = ena_ap;\n\t}\n\treturn 0;\n}\n\nstatic int tda998x_set_config(struct tda998x_priv *priv,\n\t\t\t      const struct tda998x_encoder_params *p)\n{\n\tpriv->vip_cntrl_0 = VIP_CNTRL_0_SWAP_A(p->swap_a) |\n\t\t\t    (p->mirr_a ? VIP_CNTRL_0_MIRR_A : 0) |\n\t\t\t    VIP_CNTRL_0_SWAP_B(p->swap_b) |\n\t\t\t    (p->mirr_b ? VIP_CNTRL_0_MIRR_B : 0);\n\tpriv->vip_cntrl_1 = VIP_CNTRL_1_SWAP_C(p->swap_c) |\n\t\t\t    (p->mirr_c ? VIP_CNTRL_1_MIRR_C : 0) |\n\t\t\t    VIP_CNTRL_1_SWAP_D(p->swap_d) |\n\t\t\t    (p->mirr_d ? VIP_CNTRL_1_MIRR_D : 0);\n\tpriv->vip_cntrl_2 = VIP_CNTRL_2_SWAP_E(p->swap_e) |\n\t\t\t    (p->mirr_e ? VIP_CNTRL_2_MIRR_E : 0) |\n\t\t\t    VIP_CNTRL_2_SWAP_F(p->swap_f) |\n\t\t\t    (p->mirr_f ? VIP_CNTRL_2_MIRR_F : 0);\n\n\tif (p->audio_params.format != AFMT_UNUSED) {\n\t\tunsigned int ratio, route;\n\t\tbool spdif = p->audio_params.format == AFMT_SPDIF;\n\n\t\troute = AUDIO_ROUTE_I2S + spdif;\n\n\t\tpriv->audio.route = &tda998x_audio_route[route];\n\t\tpriv->audio.cea = p->audio_params.cea;\n\t\tpriv->audio.sample_rate = p->audio_params.sample_rate;\n\t\tmemcpy(priv->audio.status, p->audio_params.status,\n\t\t       min(sizeof(priv->audio.status),\n\t\t\t   sizeof(p->audio_params.status)));\n\t\tpriv->audio.ena_ap = p->audio_params.config;\n\t\tpriv->audio.i2s_format = I2S_FORMAT_PHILIPS;\n\n\t\tratio = spdif ? 64 : p->audio_params.sample_width * 2;\n\t\treturn tda998x_derive_cts_n(priv, &priv->audio, ratio);\n\t}\n\n\treturn 0;\n}\n\nstatic void tda998x_destroy(struct device *dev)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\n\tdrm_bridge_remove(&priv->bridge);\n\n\t \n\tcec_write(priv, REG_CEC_RXSHPDINTENA, 0);\n\treg_clear(priv, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\n\n\tif (priv->audio_pdev)\n\t\tplatform_device_unregister(priv->audio_pdev);\n\n\tif (priv->hdmi->irq)\n\t\tfree_irq(priv->hdmi->irq, priv);\n\n\tdel_timer_sync(&priv->edid_delay_timer);\n\tcancel_work_sync(&priv->detect_work);\n\n\ti2c_unregister_device(priv->cec);\n\n\tcec_notifier_conn_unregister(priv->cec_notify);\n}\n\nstatic int tda998x_create(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct device_node *np = client->dev.of_node;\n\tstruct i2c_board_info cec_info;\n\tstruct tda998x_priv *priv;\n\tu32 video;\n\tint rev_lo, rev_hi, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\n\tmutex_init(&priv->mutex);\t \n\tmutex_init(&priv->audio_mutex);  \n\tmutex_init(&priv->edid_mutex);\n\tINIT_LIST_HEAD(&priv->bridge.list);\n\tinit_waitqueue_head(&priv->edid_delay_waitq);\n\ttimer_setup(&priv->edid_delay_timer, tda998x_edid_delay_done, 0);\n\tINIT_WORK(&priv->detect_work, tda998x_detect_work);\n\n\tpriv->vip_cntrl_0 = VIP_CNTRL_0_SWAP_A(2) | VIP_CNTRL_0_SWAP_B(3);\n\tpriv->vip_cntrl_1 = VIP_CNTRL_1_SWAP_C(0) | VIP_CNTRL_1_SWAP_D(1);\n\tpriv->vip_cntrl_2 = VIP_CNTRL_2_SWAP_E(4) | VIP_CNTRL_2_SWAP_F(5);\n\n\t \n\tpriv->cec_addr = 0x34 + (client->addr & 0x03);\n\tpriv->current_page = 0xff;\n\tpriv->hdmi = client;\n\n\t \n\tcec_write(priv, REG_CEC_ENAMODS,\n\t\t\tCEC_ENAMODS_EN_RXSENS | CEC_ENAMODS_EN_HDMI);\n\n\ttda998x_reset(priv);\n\n\t \n\trev_lo = reg_read(priv, REG_VERSION_LSB);\n\tif (rev_lo < 0) {\n\t\tdev_err(dev, \"failed to read version: %d\\n\", rev_lo);\n\t\treturn rev_lo;\n\t}\n\n\trev_hi = reg_read(priv, REG_VERSION_MSB);\n\tif (rev_hi < 0) {\n\t\tdev_err(dev, \"failed to read version: %d\\n\", rev_hi);\n\t\treturn rev_hi;\n\t}\n\n\tpriv->rev = rev_lo | rev_hi << 8;\n\n\t \n\tpriv->rev &= ~0x30;  \n\n\tswitch (priv->rev) {\n\tcase TDA9989N2:\n\t\tdev_info(dev, \"found TDA9989 n2\");\n\t\tbreak;\n\tcase TDA19989:\n\t\tdev_info(dev, \"found TDA19989\");\n\t\tbreak;\n\tcase TDA19989N2:\n\t\tdev_info(dev, \"found TDA19989 n2\");\n\t\tbreak;\n\tcase TDA19988:\n\t\tdev_info(dev, \"found TDA19988\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"found unsupported device: %04x\\n\", priv->rev);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\treg_write(priv, REG_DDC_DISABLE, 0x00);\n\n\t \n\treg_write(priv, REG_TX3, 39);\n\n\t \n\tif (priv->rev == TDA19989)\n\t\treg_set(priv, REG_I2C_MASTER, I2C_MASTER_DIS_MM);\n\n\tcec_write(priv, REG_CEC_FRO_IM_CLK_CTRL,\n\t\t\tCEC_FRO_IM_CLK_CTRL_GHOST_DIS | CEC_FRO_IM_CLK_CTRL_IMCLK_SEL);\n\n\t \n\tcec_write(priv, REG_CEC_RXSHPDINTENA, 0);\n\n\t \n\tcec_read(priv, REG_CEC_RXSHPDINT);\n\treg_read(priv, REG_INT_FLAGS_0);\n\treg_read(priv, REG_INT_FLAGS_1);\n\treg_read(priv, REG_INT_FLAGS_2);\n\n\t \n\tif (client->irq) {\n\t\tunsigned long irq_flags;\n\n\t\t \n\t\tinit_waitqueue_head(&priv->wq_edid);\n\n\t\tirq_flags =\n\t\t\tirqd_get_trigger_type(irq_get_irq_data(client->irq));\n\n\t\tpriv->cec_glue.irq_flags = irq_flags;\n\n\t\tirq_flags |= IRQF_SHARED | IRQF_ONESHOT;\n\t\tret = request_threaded_irq(client->irq, NULL,\n\t\t\t\t\t   tda998x_irq_thread, irq_flags,\n\t\t\t\t\t   \"tda998x\", priv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request IRQ#%u: %d\\n\",\n\t\t\t\tclient->irq, ret);\n\t\t\tgoto err_irq;\n\t\t}\n\n\t\t \n\t\tcec_write(priv, REG_CEC_RXSHPDINTENA, CEC_RXSHPDLEV_HPD);\n\t}\n\n\tpriv->cec_notify = cec_notifier_conn_register(dev, NULL, NULL);\n\tif (!priv->cec_notify) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tpriv->cec_glue.parent = dev;\n\tpriv->cec_glue.data = priv;\n\tpriv->cec_glue.init = tda998x_cec_hook_init;\n\tpriv->cec_glue.exit = tda998x_cec_hook_exit;\n\tpriv->cec_glue.open = tda998x_cec_hook_open;\n\tpriv->cec_glue.release = tda998x_cec_hook_release;\n\n\t \n\tmemset(&cec_info, 0, sizeof(cec_info));\n\tstrscpy(cec_info.type, \"tda9950\", sizeof(cec_info.type));\n\tcec_info.addr = priv->cec_addr;\n\tcec_info.platform_data = &priv->cec_glue;\n\tcec_info.irq = client->irq;\n\n\tpriv->cec = i2c_new_client_device(client->adapter, &cec_info);\n\tif (IS_ERR(priv->cec)) {\n\t\tret = PTR_ERR(priv->cec);\n\t\tgoto fail;\n\t}\n\n\t \n\treg_set(priv, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\n\n\tif (np) {\n\t\t \n\t\tret = of_property_read_u32(np, \"video-ports\", &video);\n\t\tif (ret == 0) {\n\t\t\tpriv->vip_cntrl_0 = video >> 16;\n\t\t\tpriv->vip_cntrl_1 = video >> 8;\n\t\t\tpriv->vip_cntrl_2 = video;\n\t\t}\n\n\t\tret = tda998x_get_audio_ports(priv, np);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (priv->audio_port_enable[AUDIO_ROUTE_I2S] ||\n\t\t    priv->audio_port_enable[AUDIO_ROUTE_SPDIF])\n\t\t\ttda998x_audio_codec_init(priv, &client->dev);\n\t} else if (dev->platform_data) {\n\t\tret = tda998x_set_config(priv, dev->platform_data);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tpriv->bridge.funcs = &tda998x_bridge_funcs;\n#ifdef CONFIG_OF\n\tpriv->bridge.of_node = dev->of_node;\n#endif\n\n\tdrm_bridge_add(&priv->bridge);\n\n\treturn 0;\n\nfail:\n\ttda998x_destroy(dev);\nerr_irq:\n\treturn ret;\n}\n\n \n\nstatic int tda998x_encoder_init(struct device *dev, struct drm_device *drm)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\tu32 crtcs = 0;\n\tint ret;\n\n\tif (dev->of_node)\n\t\tcrtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\n\n\t \n\tif (crtcs == 0) {\n\t\tdev_warn(dev, \"Falling back to first CRTC\\n\");\n\t\tcrtcs = 1 << 0;\n\t}\n\n\tpriv->encoder.possible_crtcs = crtcs;\n\n\tret = drm_simple_encoder_init(drm, &priv->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret)\n\t\tgoto err_encoder;\n\n\tret = drm_bridge_attach(&priv->encoder, &priv->bridge, NULL, 0);\n\tif (ret)\n\t\tgoto err_bridge;\n\n\treturn 0;\n\nerr_bridge:\n\tdrm_encoder_cleanup(&priv->encoder);\nerr_encoder:\n\treturn ret;\n}\n\nstatic int tda998x_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct drm_device *drm = data;\n\n\treturn tda998x_encoder_init(dev, drm);\n}\n\nstatic void tda998x_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct tda998x_priv *priv = dev_get_drvdata(dev);\n\n\tdrm_encoder_cleanup(&priv->encoder);\n}\n\nstatic const struct component_ops tda998x_ops = {\n\t.bind = tda998x_bind,\n\t.unbind = tda998x_unbind,\n};\n\nstatic int\ntda998x_probe(struct i2c_client *client)\n{\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_warn(&client->dev, \"adapter does not support I2C\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = tda998x_create(&client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = component_add(&client->dev, &tda998x_ops);\n\tif (ret)\n\t\ttda998x_destroy(&client->dev);\n\treturn ret;\n}\n\nstatic void tda998x_remove(struct i2c_client *client)\n{\n\tcomponent_del(&client->dev, &tda998x_ops);\n\ttda998x_destroy(&client->dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tda998x_dt_ids[] = {\n\t{ .compatible = \"nxp,tda998x\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tda998x_dt_ids);\n#endif\n\nstatic const struct i2c_device_id tda998x_ids[] = {\n\t{ \"tda998x\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tda998x_ids);\n\nstatic struct i2c_driver tda998x_driver = {\n\t.probe = tda998x_probe,\n\t.remove = tda998x_remove,\n\t.driver = {\n\t\t.name = \"tda998x\",\n\t\t.of_match_table = of_match_ptr(tda998x_dt_ids),\n\t},\n\t.id_table = tda998x_ids,\n};\n\nmodule_i2c_driver(tda998x_driver);\n\nMODULE_AUTHOR(\"Rob Clark <robdclark@gmail.com\");\nMODULE_DESCRIPTION(\"NXP Semiconductors TDA998X HDMI Encoder\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}