{
  "module_name": "drm_damage_helper.c",
  "hash_id": "22d3bc01d15f6f1955dbe9e78386e795ec8e2feff34817b898906d0b2ebd6420",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_damage_helper.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_framebuffer.h>\n\nstatic void convert_clip_rect_to_rect(const struct drm_clip_rect *src,\n\t\t\t\t      struct drm_mode_rect *dest,\n\t\t\t\t      uint32_t num_clips, uint32_t src_inc)\n{\n\twhile (num_clips > 0) {\n\t\tdest->x1 = src->x1;\n\t\tdest->y1 = src->y1;\n\t\tdest->x2 = src->x2;\n\t\tdest->y2 = src->y2;\n\t\tsrc += src_inc;\n\t\tdest++;\n\t\tnum_clips--;\n\t}\n}\n\n \nvoid drm_atomic_helper_check_plane_damage(struct drm_atomic_state *state,\n\t\t\t\t\t  struct drm_plane_state *plane_state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (plane_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t   plane_state->crtc);\n\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn;\n\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\t\tdrm_property_blob_put(plane_state->fb_damage_clips);\n\t\t\tplane_state->fb_damage_clips = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_plane_damage);\n\n \nint drm_atomic_helper_dirtyfb(struct drm_framebuffer *fb,\n\t\t\t      struct drm_file *file_priv, unsigned int flags,\n\t\t\t      unsigned int color, struct drm_clip_rect *clips,\n\t\t\t      unsigned int num_clips)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_property_blob *damage = NULL;\n\tstruct drm_mode_rect *rects = NULL;\n\tstruct drm_atomic_state *state;\n\tstruct drm_plane *plane;\n\tint ret = 0;\n\n\t \n\tdrm_modeset_acquire_init(&ctx,\n\t\tfile_priv ? DRM_MODESET_ACQUIRE_INTERRUPTIBLE : 0);\n\n\tstate = drm_atomic_state_alloc(fb->dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_drop_locks;\n\t}\n\tstate->acquire_ctx = &ctx;\n\n\tif (clips) {\n\t\tuint32_t inc = 1;\n\n\t\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\n\t\t\tinc = 2;\n\t\t\tnum_clips /= 2;\n\t\t}\n\n\t\trects = kcalloc(num_clips, sizeof(*rects), GFP_KERNEL);\n\t\tif (!rects) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconvert_clip_rect_to_rect(clips, rects, num_clips, inc);\n\t\tdamage = drm_property_create_blob(fb->dev,\n\t\t\t\t\t\t  num_clips * sizeof(*rects),\n\t\t\t\t\t\t  rects);\n\t\tif (IS_ERR(damage)) {\n\t\t\tret = PTR_ERR(damage);\n\t\t\tdamage = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nretry:\n\tdrm_for_each_plane(plane, fb->dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tret = drm_modeset_lock(&plane->mutex, state->acquire_ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (plane->state->fb != fb) {\n\t\t\tdrm_modeset_unlock(&plane->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tret = PTR_ERR(plane_state);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdrm_property_replace_blob(&plane_state->fb_damage_clips,\n\t\t\t\t\t  damage);\n\t}\n\n\tret = drm_atomic_commit(state);\n\nout:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tret = drm_modeset_backoff(&ctx);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\tdrm_property_blob_put(damage);\n\tkfree(rects);\n\tdrm_atomic_state_put(state);\n\nout_drop_locks:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n\n}\nEXPORT_SYMBOL(drm_atomic_helper_dirtyfb);\n\n \nvoid\ndrm_atomic_helper_damage_iter_init(struct drm_atomic_helper_damage_iter *iter,\n\t\t\t\t   const struct drm_plane_state *old_state,\n\t\t\t\t   const struct drm_plane_state *state)\n{\n\tstruct drm_rect src;\n\tmemset(iter, 0, sizeof(*iter));\n\n\tif (!state || !state->crtc || !state->fb || !state->visible)\n\t\treturn;\n\n\titer->clips = (struct drm_rect *)drm_plane_get_damage_clips(state);\n\titer->num_clips = drm_plane_get_damage_clips_count(state);\n\n\t \n\tsrc = drm_plane_state_src(state);\n\n\titer->plane_src.x1 = src.x1 >> 16;\n\titer->plane_src.y1 = src.y1 >> 16;\n\titer->plane_src.x2 = (src.x2 >> 16) + !!(src.x2 & 0xFFFF);\n\titer->plane_src.y2 = (src.y2 >> 16) + !!(src.y2 & 0xFFFF);\n\n\tif (!iter->clips || !drm_rect_equals(&state->src, &old_state->src)) {\n\t\titer->clips = NULL;\n\t\titer->num_clips = 0;\n\t\titer->full_update = true;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_damage_iter_init);\n\n \nbool\ndrm_atomic_helper_damage_iter_next(struct drm_atomic_helper_damage_iter *iter,\n\t\t\t\t   struct drm_rect *rect)\n{\n\tbool ret = false;\n\n\tif (iter->full_update) {\n\t\t*rect = iter->plane_src;\n\t\titer->full_update = false;\n\t\treturn true;\n\t}\n\n\twhile (iter->curr_clip < iter->num_clips) {\n\t\t*rect = iter->clips[iter->curr_clip];\n\t\titer->curr_clip++;\n\n\t\tif (drm_rect_intersect(rect, &iter->plane_src)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_damage_iter_next);\n\n \nbool drm_atomic_helper_damage_merged(const struct drm_plane_state *old_state,\n\t\t\t\t     struct drm_plane_state *state,\n\t\t\t\t     struct drm_rect *rect)\n{\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect clip;\n\tbool valid = false;\n\n\trect->x1 = INT_MAX;\n\trect->y1 = INT_MAX;\n\trect->x2 = 0;\n\trect->y2 = 0;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_state, state);\n\tdrm_atomic_for_each_plane_damage(&iter, &clip) {\n\t\trect->x1 = min(rect->x1, clip.x1);\n\t\trect->y1 = min(rect->y1, clip.y1);\n\t\trect->x2 = max(rect->x2, clip.x2);\n\t\trect->y2 = max(rect->y2, clip.y2);\n\t\tvalid = true;\n\t}\n\n\treturn valid;\n}\nEXPORT_SYMBOL(drm_atomic_helper_damage_merged);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}