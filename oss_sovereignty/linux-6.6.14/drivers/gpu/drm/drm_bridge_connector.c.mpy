{
  "module_name": "drm_bridge_connector.c",
  "hash_id": "94c849a69f1db01b1d1e9254b358451e0ecdc63d2acb2625236f20755e6f4bf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_bridge_connector.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n\n \n\n \nstruct drm_bridge_connector {\n\t \n\tstruct drm_connector base;\n\t \n\tstruct drm_encoder *encoder;\n\t \n\tstruct drm_bridge *bridge_edid;\n\t \n\tstruct drm_bridge *bridge_hpd;\n\t \n\tstruct drm_bridge *bridge_detect;\n\t \n\tstruct drm_bridge *bridge_modes;\n};\n\n#define to_drm_bridge_connector(x) \\\n\tcontainer_of(x, struct drm_bridge_connector, base)\n\n \n\nstatic void drm_bridge_connector_hpd_notify(struct drm_connector *connector,\n\t\t\t\t\t    enum drm_connector_status status)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_bridge *bridge;\n\n\t \n\tdrm_for_each_bridge_in_chain(bridge_connector->encoder, bridge) {\n\t\tif (bridge->funcs->hpd_notify)\n\t\t\tbridge->funcs->hpd_notify(bridge, status);\n\t}\n}\n\nstatic void drm_bridge_connector_hpd_cb(void *cb_data,\n\t\t\t\t\tenum drm_connector_status status)\n{\n\tstruct drm_bridge_connector *drm_bridge_connector = cb_data;\n\tstruct drm_connector *connector = &drm_bridge_connector->base;\n\tstruct drm_device *dev = connector->dev;\n\tenum drm_connector_status old_status;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\told_status = connector->status;\n\tconnector->status = status;\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tif (old_status == status)\n\t\treturn;\n\n\tdrm_bridge_connector_hpd_notify(connector, status);\n\n\tdrm_kms_helper_connector_hotplug_event(connector);\n}\n\nstatic void drm_bridge_connector_enable_hpd(struct drm_connector *connector)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_bridge *hpd = bridge_connector->bridge_hpd;\n\n\tif (hpd)\n\t\tdrm_bridge_hpd_enable(hpd, drm_bridge_connector_hpd_cb,\n\t\t\t\t      bridge_connector);\n}\n\nstatic void drm_bridge_connector_disable_hpd(struct drm_connector *connector)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_bridge *hpd = bridge_connector->bridge_hpd;\n\n\tif (hpd)\n\t\tdrm_bridge_hpd_disable(hpd);\n}\n\n \n\nstatic enum drm_connector_status\ndrm_bridge_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_bridge *detect = bridge_connector->bridge_detect;\n\tenum drm_connector_status status;\n\n\tif (detect) {\n\t\tstatus = detect->funcs->detect(detect);\n\n\t\tdrm_bridge_connector_hpd_notify(connector, status);\n\t} else {\n\t\tswitch (connector->connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_DPI:\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tcase DRM_MODE_CONNECTOR_DSI:\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\tstatus = connector_status_connected;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = connector_status_unknown;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void drm_bridge_connector_destroy(struct drm_connector *connector)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\n\tif (bridge_connector->bridge_hpd) {\n\t\tstruct drm_bridge *hpd = bridge_connector->bridge_hpd;\n\n\t\tdrm_bridge_hpd_disable(hpd);\n\t}\n\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\n\tkfree(bridge_connector);\n}\n\nstatic void drm_bridge_connector_debugfs_init(struct drm_connector *connector,\n\t\t\t\t\t      struct dentry *root)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_encoder *encoder = bridge_connector->encoder;\n\tstruct drm_bridge *bridge;\n\n\tlist_for_each_entry(bridge, &encoder->bridge_chain, chain_node) {\n\t\tif (bridge->funcs->debugfs_init)\n\t\t\tbridge->funcs->debugfs_init(bridge, root);\n\t}\n}\n\nstatic const struct drm_connector_funcs drm_bridge_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.detect = drm_bridge_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_bridge_connector_destroy,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.debugfs_init = drm_bridge_connector_debugfs_init,\n};\n\n \n\nstatic int drm_bridge_connector_get_modes_edid(struct drm_connector *connector,\n\t\t\t\t\t       struct drm_bridge *bridge)\n{\n\tenum drm_connector_status status;\n\tstruct edid *edid;\n\tint n;\n\n\tstatus = drm_bridge_connector_detect(connector, false);\n\tif (status != connector_status_connected)\n\t\tgoto no_edid;\n\n\tedid = bridge->funcs->get_edid(bridge, connector);\n\tif (!drm_edid_is_valid(edid)) {\n\t\tkfree(edid);\n\t\tgoto no_edid;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tn = drm_add_edid_modes(connector, edid);\n\n\tkfree(edid);\n\treturn n;\n\nno_edid:\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic int drm_bridge_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_bridge_connector *bridge_connector =\n\t\tto_drm_bridge_connector(connector);\n\tstruct drm_bridge *bridge;\n\n\t \n\tbridge = bridge_connector->bridge_edid;\n\tif (bridge)\n\t\treturn drm_bridge_connector_get_modes_edid(connector, bridge);\n\n\t \n\tbridge = bridge_connector->bridge_modes;\n\tif (bridge)\n\t\treturn bridge->funcs->get_modes(bridge, connector);\n\n\t \n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs drm_bridge_connector_helper_funcs = {\n\t.get_modes = drm_bridge_connector_get_modes,\n\t \n\t.enable_hpd = drm_bridge_connector_enable_hpd,\n\t.disable_hpd = drm_bridge_connector_disable_hpd,\n};\n\n \n\n \nstruct drm_connector *drm_bridge_connector_init(struct drm_device *drm,\n\t\t\t\t\t\tstruct drm_encoder *encoder)\n{\n\tstruct drm_bridge_connector *bridge_connector;\n\tstruct drm_connector *connector;\n\tstruct i2c_adapter *ddc = NULL;\n\tstruct drm_bridge *bridge, *panel_bridge = NULL;\n\tint connector_type;\n\tint ret;\n\n\tbridge_connector = kzalloc(sizeof(*bridge_connector), GFP_KERNEL);\n\tif (!bridge_connector)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbridge_connector->encoder = encoder;\n\n\t \n\tconnector = &bridge_connector->base;\n\tconnector->interlace_allowed = true;\n\n\t \n\tconnector_type = DRM_MODE_CONNECTOR_Unknown;\n\tdrm_for_each_bridge_in_chain(encoder, bridge) {\n\t\tif (!bridge->interlace_allowed)\n\t\t\tconnector->interlace_allowed = false;\n\n\t\tif (bridge->ops & DRM_BRIDGE_OP_EDID)\n\t\t\tbridge_connector->bridge_edid = bridge;\n\t\tif (bridge->ops & DRM_BRIDGE_OP_HPD)\n\t\t\tbridge_connector->bridge_hpd = bridge;\n\t\tif (bridge->ops & DRM_BRIDGE_OP_DETECT)\n\t\t\tbridge_connector->bridge_detect = bridge;\n\t\tif (bridge->ops & DRM_BRIDGE_OP_MODES)\n\t\t\tbridge_connector->bridge_modes = bridge;\n\n\t\tif (!drm_bridge_get_next_bridge(bridge))\n\t\t\tconnector_type = bridge->type;\n\n\t\tif (bridge->ddc)\n\t\t\tddc = bridge->ddc;\n\n\t\tif (drm_bridge_is_panel(bridge))\n\t\t\tpanel_bridge = bridge;\n\t}\n\n\tif (connector_type == DRM_MODE_CONNECTOR_Unknown) {\n\t\tkfree(bridge_connector);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = drm_connector_init_with_ddc(drm, connector,\n\t\t\t\t\t  &drm_bridge_connector_funcs,\n\t\t\t\t\t  connector_type, ddc);\n\tif (ret) {\n\t\tkfree(bridge_connector);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_connector_helper_add(connector, &drm_bridge_connector_helper_funcs);\n\n\tif (bridge_connector->bridge_hpd)\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\telse if (bridge_connector->bridge_detect)\n\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT\n\t\t\t\t  | DRM_CONNECTOR_POLL_DISCONNECT;\n\n\tif (panel_bridge)\n\t\tdrm_panel_bridge_set_orientation(connector, panel_bridge);\n\n\treturn connector;\n}\nEXPORT_SYMBOL_GPL(drm_bridge_connector_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}