{
  "module_name": "mtk_drm_gem.c",
  "hash_id": "5b89609e76770201e159fe4ad3c6a2cb854c73e6be645a1929942423762d135b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_drm_gem.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n\n#include <drm/drm.h>\n#include <drm/drm_device.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_prime.h>\n\n#include \"mtk_drm_drv.h\"\n#include \"mtk_drm_gem.h\"\n\nstatic int mtk_drm_gem_object_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma);\n\nstatic const struct vm_operations_struct vm_ops = {\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\n\nstatic const struct drm_gem_object_funcs mtk_drm_gem_object_funcs = {\n\t.free = mtk_drm_gem_free_object,\n\t.get_sg_table = mtk_gem_prime_get_sg_table,\n\t.vmap = mtk_drm_gem_prime_vmap,\n\t.vunmap = mtk_drm_gem_prime_vunmap,\n\t.mmap = mtk_drm_gem_object_mmap,\n\t.vm_ops = &vm_ops,\n};\n\nstatic struct mtk_drm_gem_obj *mtk_drm_gem_init(struct drm_device *dev,\n\t\t\t\t\t\tunsigned long size)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem_obj;\n\tint ret;\n\n\tsize = round_up(size, PAGE_SIZE);\n\n\tmtk_gem_obj = kzalloc(sizeof(*mtk_gem_obj), GFP_KERNEL);\n\tif (!mtk_gem_obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmtk_gem_obj->base.funcs = &mtk_drm_gem_object_funcs;\n\n\tret = drm_gem_object_init(dev, &mtk_gem_obj->base, size);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to initialize gem object\\n\");\n\t\tkfree(mtk_gem_obj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mtk_gem_obj;\n}\n\nstruct mtk_drm_gem_obj *mtk_drm_gem_create(struct drm_device *dev,\n\t\t\t\t\t   size_t size, bool alloc_kmap)\n{\n\tstruct mtk_drm_private *priv = dev->dev_private;\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tmtk_gem = mtk_drm_gem_init(dev, size);\n\tif (IS_ERR(mtk_gem))\n\t\treturn ERR_CAST(mtk_gem);\n\n\tobj = &mtk_gem->base;\n\n\tmtk_gem->dma_attrs = DMA_ATTR_WRITE_COMBINE;\n\n\tif (!alloc_kmap)\n\t\tmtk_gem->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\n\n\tmtk_gem->cookie = dma_alloc_attrs(priv->dma_dev, obj->size,\n\t\t\t\t\t  &mtk_gem->dma_addr, GFP_KERNEL,\n\t\t\t\t\t  mtk_gem->dma_attrs);\n\tif (!mtk_gem->cookie) {\n\t\tDRM_ERROR(\"failed to allocate %zx byte dma buffer\", obj->size);\n\t\tret = -ENOMEM;\n\t\tgoto err_gem_free;\n\t}\n\n\tif (alloc_kmap)\n\t\tmtk_gem->kvaddr = mtk_gem->cookie;\n\n\tDRM_DEBUG_DRIVER(\"cookie = %p dma_addr = %pad size = %zu\\n\",\n\t\t\t mtk_gem->cookie, &mtk_gem->dma_addr,\n\t\t\t size);\n\n\treturn mtk_gem;\n\nerr_gem_free:\n\tdrm_gem_object_release(obj);\n\tkfree(mtk_gem);\n\treturn ERR_PTR(ret);\n}\n\nvoid mtk_drm_gem_free_object(struct drm_gem_object *obj)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\n\tstruct mtk_drm_private *priv = obj->dev->dev_private;\n\n\tif (mtk_gem->sg)\n\t\tdrm_prime_gem_destroy(obj, mtk_gem->sg);\n\telse\n\t\tdma_free_attrs(priv->dma_dev, obj->size, mtk_gem->cookie,\n\t\t\t       mtk_gem->dma_addr, mtk_gem->dma_attrs);\n\n\t \n\tdrm_gem_object_release(obj);\n\n\tkfree(mtk_gem);\n}\n\nint mtk_drm_gem_dumb_create(struct drm_file *file_priv, struct drm_device *dev,\n\t\t\t    struct drm_mode_create_dumb *args)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\tint ret;\n\n\targs->pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\n\t \n\targs->size = args->pitch;\n\targs->size *= args->height;\n\n\tmtk_gem = mtk_drm_gem_create(dev, args->size, false);\n\tif (IS_ERR(mtk_gem))\n\t\treturn PTR_ERR(mtk_gem);\n\n\t \n\tret = drm_gem_handle_create(file_priv, &mtk_gem->base, &args->handle);\n\tif (ret)\n\t\tgoto err_handle_create;\n\n\t \n\tdrm_gem_object_put(&mtk_gem->base);\n\n\treturn 0;\n\nerr_handle_create:\n\tmtk_drm_gem_free_object(&mtk_gem->base);\n\treturn ret;\n}\n\nstatic int mtk_drm_gem_object_mmap(struct drm_gem_object *obj,\n\t\t\t\t   struct vm_area_struct *vma)\n\n{\n\tint ret;\n\tstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\n\tstruct mtk_drm_private *priv = obj->dev->dev_private;\n\n\t \n\tvma->vm_pgoff = 0;\n\n\t \n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));\n\tvma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n\n\tret = dma_mmap_attrs(priv->dma_dev, vma, mtk_gem->cookie,\n\t\t\t     mtk_gem->dma_addr, obj->size, mtk_gem->dma_attrs);\n\n\treturn ret;\n}\n\n \nstruct sg_table *mtk_gem_prime_get_sg_table(struct drm_gem_object *obj)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\n\tstruct mtk_drm_private *priv = obj->dev->dev_private;\n\tstruct sg_table *sgt;\n\tint ret;\n\n\tsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = dma_get_sgtable_attrs(priv->dma_dev, sgt, mtk_gem->cookie,\n\t\t\t\t    mtk_gem->dma_addr, obj->size,\n\t\t\t\t    mtk_gem->dma_attrs);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to allocate sgt, %d\\n\", ret);\n\t\tkfree(sgt);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn sgt;\n}\n\nstruct drm_gem_object *mtk_gem_prime_import_sg_table(struct drm_device *dev,\n\t\t\tstruct dma_buf_attachment *attach, struct sg_table *sg)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\n\t \n\tif (drm_prime_get_contiguous_size(sg) < attach->dmabuf->size) {\n\t\tDRM_ERROR(\"sg_table is not contiguous\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmtk_gem = mtk_drm_gem_init(dev, attach->dmabuf->size);\n\tif (IS_ERR(mtk_gem))\n\t\treturn ERR_CAST(mtk_gem);\n\n\tmtk_gem->dma_addr = sg_dma_address(sg->sgl);\n\tmtk_gem->sg = sg;\n\n\treturn &mtk_gem->base;\n}\n\nint mtk_drm_gem_prime_vmap(struct drm_gem_object *obj, struct iosys_map *map)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\n\tstruct sg_table *sgt = NULL;\n\tunsigned int npages;\n\n\tif (mtk_gem->kvaddr)\n\t\tgoto out;\n\n\tsgt = mtk_gem_prime_get_sg_table(obj);\n\tif (IS_ERR(sgt))\n\t\treturn PTR_ERR(sgt);\n\n\tnpages = obj->size >> PAGE_SHIFT;\n\tmtk_gem->pages = kcalloc(npages, sizeof(*mtk_gem->pages), GFP_KERNEL);\n\tif (!mtk_gem->pages) {\n\t\tsg_free_table(sgt);\n\t\tkfree(sgt);\n\t\treturn -ENOMEM;\n\t}\n\n\tdrm_prime_sg_to_page_array(sgt, mtk_gem->pages, npages);\n\n\tmtk_gem->kvaddr = vmap(mtk_gem->pages, npages, VM_MAP,\n\t\t\t       pgprot_writecombine(PAGE_KERNEL));\n\tif (!mtk_gem->kvaddr) {\n\t\tsg_free_table(sgt);\n\t\tkfree(sgt);\n\t\tkfree(mtk_gem->pages);\n\t\treturn -ENOMEM;\n\t}\n\tsg_free_table(sgt);\n\tkfree(sgt);\n\nout:\n\tiosys_map_set_vaddr(map, mtk_gem->kvaddr);\n\n\treturn 0;\n}\n\nvoid mtk_drm_gem_prime_vunmap(struct drm_gem_object *obj,\n\t\t\t      struct iosys_map *map)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\n\tvoid *vaddr = map->vaddr;\n\n\tif (!mtk_gem->pages)\n\t\treturn;\n\n\tvunmap(vaddr);\n\tmtk_gem->kvaddr = NULL;\n\tkfree(mtk_gem->pages);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}