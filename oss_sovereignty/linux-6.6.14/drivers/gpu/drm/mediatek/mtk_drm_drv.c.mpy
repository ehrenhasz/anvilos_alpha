{
  "module_name": "mtk_drm_drv.c",
  "hash_id": "3584e16b40c777a0f7e12b959c113592a04c0010e8294250f06719f6b2d537ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_drm_gem.h\"\n\n#define DRIVER_NAME \"mediatek\"\n#define DRIVER_DESC \"Mediatek SoC DRM\"\n#define DRIVER_DATE \"20150513\"\n#define DRIVER_MAJOR 1\n#define DRIVER_MINOR 0\n\nstatic const struct drm_mode_config_helper_funcs mtk_drm_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic struct drm_framebuffer *\nmtk_drm_mode_fb_create(struct drm_device *dev,\n\t\t       struct drm_file *file,\n\t\t       const struct drm_mode_fb_cmd2 *cmd)\n{\n\tconst struct drm_format_info *info = drm_get_format_info(dev, cmd);\n\n\tif (info->num_planes != 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn drm_gem_fb_create(dev, file, cmd);\n}\n\nstatic const struct drm_mode_config_funcs mtk_drm_mode_config_funcs = {\n\t.fb_create = mtk_drm_mode_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const unsigned int mt2701_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_BLS,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt2701_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt7623_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_BLS,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt7623_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt2712_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_OD0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_DPI0,\n\tDDP_COMPONENT_PWM0,\n};\n\nstatic const unsigned int mt2712_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_OVL1,\n\tDDP_COMPONENT_COLOR1,\n\tDDP_COMPONENT_AAL1,\n\tDDP_COMPONENT_OD1,\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DPI1,\n\tDDP_COMPONENT_PWM1,\n};\n\nstatic const unsigned int mt2712_mtk_ddp_third[] = {\n\tDDP_COMPONENT_RDMA2,\n\tDDP_COMPONENT_DSI3,\n\tDDP_COMPONENT_PWM2,\n};\n\nstatic unsigned int mt8167_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt8173_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_OD0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_UFOE,\n\tDDP_COMPONENT_DSI0,\n\tDDP_COMPONENT_PWM0,\n};\n\nstatic const unsigned int mt8173_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_OVL1,\n\tDDP_COMPONENT_COLOR1,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt8183_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_OVL_2L0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt8183_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_OVL_2L1,\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt8186_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_POSTMASK0,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt8186_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_OVL_2L0,\n\tDDP_COMPONENT_RDMA1,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt8188_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_POSTMASK0,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_DP_INTF0,\n};\n\nstatic const unsigned int mt8192_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_OVL_2L0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_POSTMASK0,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_DSI0,\n};\n\nstatic const unsigned int mt8192_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_OVL_2L2,\n\tDDP_COMPONENT_RDMA4,\n\tDDP_COMPONENT_DPI0,\n};\n\nstatic const unsigned int mt8195_mtk_ddp_main[] = {\n\tDDP_COMPONENT_OVL0,\n\tDDP_COMPONENT_RDMA0,\n\tDDP_COMPONENT_COLOR0,\n\tDDP_COMPONENT_CCORR,\n\tDDP_COMPONENT_AAL0,\n\tDDP_COMPONENT_GAMMA,\n\tDDP_COMPONENT_DITHER0,\n\tDDP_COMPONENT_DSC0,\n\tDDP_COMPONENT_MERGE0,\n\tDDP_COMPONENT_DP_INTF0,\n};\n\nstatic const unsigned int mt8195_mtk_ddp_ext[] = {\n\tDDP_COMPONENT_DRM_OVL_ADAPTOR,\n\tDDP_COMPONENT_MERGE5,\n\tDDP_COMPONENT_DP_INTF1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt2701_mmsys_driver_data = {\n\t.main_path = mt2701_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt2701_mtk_ddp_main),\n\t.ext_path = mt2701_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt2701_mtk_ddp_ext),\n\t.shadow_register = true,\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt7623_mmsys_driver_data = {\n\t.main_path = mt7623_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt7623_mtk_ddp_main),\n\t.ext_path = mt7623_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt7623_mtk_ddp_ext),\n\t.shadow_register = true,\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt2712_mmsys_driver_data = {\n\t.main_path = mt2712_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt2712_mtk_ddp_main),\n\t.ext_path = mt2712_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt2712_mtk_ddp_ext),\n\t.third_path = mt2712_mtk_ddp_third,\n\t.third_len = ARRAY_SIZE(mt2712_mtk_ddp_third),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8167_mmsys_driver_data = {\n\t.main_path = mt8167_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8167_mtk_ddp_main),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8173_mmsys_driver_data = {\n\t.main_path = mt8173_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8173_mtk_ddp_main),\n\t.ext_path = mt8173_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt8173_mtk_ddp_ext),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8183_mmsys_driver_data = {\n\t.main_path = mt8183_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8183_mtk_ddp_main),\n\t.ext_path = mt8183_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt8183_mtk_ddp_ext),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8186_mmsys_driver_data = {\n\t.main_path = mt8186_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8186_mtk_ddp_main),\n\t.ext_path = mt8186_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt8186_mtk_ddp_ext),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8188_vdosys0_driver_data = {\n\t.main_path = mt8188_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8188_mtk_ddp_main),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8192_mmsys_driver_data = {\n\t.main_path = mt8192_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8192_mtk_ddp_main),\n\t.ext_path = mt8192_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt8192_mtk_ddp_ext),\n\t.mmsys_dev_num = 1,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vdosys0_driver_data = {\n\t.main_path = mt8195_mtk_ddp_main,\n\t.main_len = ARRAY_SIZE(mt8195_mtk_ddp_main),\n\t.mmsys_dev_num = 2,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vdosys1_driver_data = {\n\t.ext_path = mt8195_mtk_ddp_ext,\n\t.ext_len = ARRAY_SIZE(mt8195_mtk_ddp_ext),\n\t.mmsys_id = 1,\n\t.mmsys_dev_num = 2,\n};\n\nstatic const struct of_device_id mtk_drm_of_ids[] = {\n\t{ .compatible = \"mediatek,mt2701-mmsys\",\n\t  .data = &mt2701_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt7623-mmsys\",\n\t  .data = &mt7623_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt2712-mmsys\",\n\t  .data = &mt2712_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8167-mmsys\",\n\t  .data = &mt8167_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8173-mmsys\",\n\t  .data = &mt8173_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8183-mmsys\",\n\t  .data = &mt8183_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8186-mmsys\",\n\t  .data = &mt8186_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8188-vdosys0\",\n\t  .data = &mt8188_vdosys0_driver_data},\n\t{ .compatible = \"mediatek,mt8192-mmsys\",\n\t  .data = &mt8192_mmsys_driver_data},\n\t{ .compatible = \"mediatek,mt8195-mmsys\",\n\t  .data = &mt8195_vdosys0_driver_data},\n\t{ .compatible = \"mediatek,mt8195-vdosys0\",\n\t  .data = &mt8195_vdosys0_driver_data},\n\t{ .compatible = \"mediatek,mt8195-vdosys1\",\n\t  .data = &mt8195_vdosys1_driver_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mtk_drm_of_ids);\n\nstatic int mtk_drm_match(struct device *dev, void *data)\n{\n\tif (!strncmp(dev_name(dev), \"mediatek-drm\", sizeof(\"mediatek-drm\") - 1))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool mtk_drm_get_all_drm_priv(struct device *dev)\n{\n\tstruct mtk_drm_private *drm_priv = dev_get_drvdata(dev);\n\tstruct mtk_drm_private *all_drm_priv[MAX_CRTC];\n\tstruct device_node *phandle = dev->parent->of_node;\n\tconst struct of_device_id *of_id;\n\tstruct device_node *node;\n\tstruct device *drm_dev;\n\tunsigned int cnt = 0;\n\tint i, j;\n\n\tfor_each_child_of_node(phandle->parent, node) {\n\t\tstruct platform_device *pdev;\n\n\t\tof_id = of_match_node(mtk_drm_of_ids, node);\n\t\tif (!of_id)\n\t\t\tcontinue;\n\n\t\tpdev = of_find_device_by_node(node);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tdrm_dev = device_find_child(&pdev->dev, NULL, mtk_drm_match);\n\t\tif (!drm_dev || !dev_get_drvdata(drm_dev))\n\t\t\tcontinue;\n\n\t\tall_drm_priv[cnt] = dev_get_drvdata(drm_dev);\n\t\tif (all_drm_priv[cnt] && all_drm_priv[cnt]->mtk_drm_bound)\n\t\t\tcnt++;\n\n\t\tif (cnt == MAX_CRTC)\n\t\t\tbreak;\n\t}\n\n\tif (drm_priv->data->mmsys_dev_num == cnt) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tfor (j = 0; j < cnt; j++)\n\t\t\t\tall_drm_priv[j]->all_drm_private[i] = all_drm_priv[i];\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool mtk_drm_find_mmsys_comp(struct mtk_drm_private *private, int comp_id)\n{\n\tconst struct mtk_mmsys_driver_data *drv_data = private->data;\n\tint i;\n\n\tif (drv_data->main_path)\n\t\tfor (i = 0; i < drv_data->main_len; i++)\n\t\t\tif (drv_data->main_path[i] == comp_id)\n\t\t\t\treturn true;\n\n\tif (drv_data->ext_path)\n\t\tfor (i = 0; i < drv_data->ext_len; i++)\n\t\t\tif (drv_data->ext_path[i] == comp_id)\n\t\t\t\treturn true;\n\n\tif (drv_data->third_path)\n\t\tfor (i = 0; i < drv_data->third_len; i++)\n\t\t\tif (drv_data->third_path[i] == comp_id)\n\t\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int mtk_drm_kms_init(struct drm_device *drm)\n{\n\tstruct mtk_drm_private *private = drm->dev_private;\n\tstruct mtk_drm_private *priv_n;\n\tstruct device *dma_dev = NULL;\n\tstruct drm_crtc *crtc;\n\tint ret, i, j;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\tgoto put_mutex_dev;\n\n\tdrm->mode_config.min_width = 64;\n\tdrm->mode_config.min_height = 64;\n\n\t \n\tdrm->mode_config.max_width = 4096;\n\tdrm->mode_config.max_height = 4096;\n\tdrm->mode_config.funcs = &mtk_drm_mode_config_funcs;\n\tdrm->mode_config.helper_private = &mtk_drm_mode_config_helpers;\n\n\tfor (i = 0; i < private->data->mmsys_dev_num; i++) {\n\t\tdrm->dev_private = private->all_drm_private[i];\n\t\tret = component_bind_all(private->all_drm_private[i]->dev, drm);\n\t\tif (ret)\n\t\t\tgoto put_mutex_dev;\n\t}\n\n\t \n\tdrm_helper_move_panel_connectors_to_head(drm);\n\n\t \n\tfor (i = 0; i < MAX_CRTC; i++) {\n\t\tfor (j = 0; j < private->data->mmsys_dev_num; j++) {\n\t\t\tpriv_n = private->all_drm_private[j];\n\n\t\t\tif (i == 0 && priv_n->data->main_len) {\n\t\t\t\tret = mtk_drm_crtc_create(drm, priv_n->data->main_path,\n\t\t\t\t\t\t\t  priv_n->data->main_len, j);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_component_unbind;\n\n\t\t\t\tcontinue;\n\t\t\t} else if (i == 1 && priv_n->data->ext_len) {\n\t\t\t\tret = mtk_drm_crtc_create(drm, priv_n->data->ext_path,\n\t\t\t\t\t\t\t  priv_n->data->ext_len, j);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_component_unbind;\n\n\t\t\t\tcontinue;\n\t\t\t} else if (i == 2 && priv_n->data->third_len) {\n\t\t\t\tret = mtk_drm_crtc_create(drm, priv_n->data->third_path,\n\t\t\t\t\t\t\t  priv_n->data->third_len, j);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_component_unbind;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tcrtc = drm_crtc_from_index(drm, 0);\n\tif (crtc)\n\t\tdma_dev = mtk_drm_crtc_dma_dev_get(crtc);\n\tif (!dma_dev) {\n\t\tret = -ENODEV;\n\t\tdev_err(drm->dev, \"Need at least one OVL device\\n\");\n\t\tgoto err_component_unbind;\n\t}\n\n\tfor (i = 0; i < private->data->mmsys_dev_num; i++)\n\t\tprivate->all_drm_private[i]->dma_dev = dma_dev;\n\n\t \n\tret = dma_set_max_seg_size(dma_dev, UINT_MAX);\n\tif (ret) {\n\t\tdev_err(dma_dev, \"Failed to set DMA segment size\\n\");\n\t\tgoto err_component_unbind;\n\t}\n\n\tret = drm_vblank_init(drm, MAX_CRTC);\n\tif (ret < 0)\n\t\tgoto err_component_unbind;\n\n\tdrm_kms_helper_poll_init(drm);\n\tdrm_mode_config_reset(drm);\n\n\treturn 0;\n\nerr_component_unbind:\n\tfor (i = 0; i < private->data->mmsys_dev_num; i++)\n\t\tcomponent_unbind_all(private->all_drm_private[i]->dev, drm);\nput_mutex_dev:\n\tfor (i = 0; i < private->data->mmsys_dev_num; i++)\n\t\tput_device(private->all_drm_private[i]->mutex_dev);\n\n\treturn ret;\n}\n\nstatic void mtk_drm_kms_deinit(struct drm_device *drm)\n{\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\n\tcomponent_unbind_all(drm->dev, drm);\n}\n\nDEFINE_DRM_GEM_FOPS(mtk_drm_fops);\n\n \nstatic struct drm_gem_object *mtk_drm_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t\t       struct dma_buf *dma_buf)\n{\n\tstruct mtk_drm_private *private = dev->dev_private;\n\n\treturn drm_gem_prime_import_dev(dev, dma_buf, private->dma_dev);\n}\n\nstatic const struct drm_driver mtk_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\n\t.dumb_create = mtk_drm_gem_dumb_create,\n\n\t.gem_prime_import = mtk_drm_gem_prime_import,\n\t.gem_prime_import_sg_table = mtk_gem_prime_import_sg_table,\n\t.fops = &mtk_drm_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n};\n\nstatic int compare_dev(struct device *dev, void *data)\n{\n\treturn dev == (struct device *)data;\n}\n\nstatic int mtk_drm_bind(struct device *dev)\n{\n\tstruct mtk_drm_private *private = dev_get_drvdata(dev);\n\tstruct platform_device *pdev;\n\tstruct drm_device *drm;\n\tint ret, i;\n\n\tif (!iommu_present(&platform_bus_type))\n\t\treturn -EPROBE_DEFER;\n\n\tpdev = of_find_device_by_node(private->mutex_node);\n\tif (!pdev) {\n\t\tdev_err(dev, \"Waiting for disp-mutex device %pOF\\n\",\n\t\t\tprivate->mutex_node);\n\t\tof_node_put(private->mutex_node);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tprivate->mutex_dev = &pdev->dev;\n\tprivate->mtk_drm_bound = true;\n\tprivate->dev = dev;\n\n\tif (!mtk_drm_get_all_drm_priv(dev))\n\t\treturn 0;\n\n\tdrm = drm_dev_alloc(&mtk_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tprivate->drm_master = true;\n\tdrm->dev_private = private;\n\tfor (i = 0; i < private->data->mmsys_dev_num; i++)\n\t\tprivate->all_drm_private[i]->drm = drm;\n\n\tret = mtk_drm_kms_init(drm);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto err_deinit;\n\n\tdrm_fbdev_generic_setup(drm, 32);\n\n\treturn 0;\n\nerr_deinit:\n\tmtk_drm_kms_deinit(drm);\nerr_free:\n\tprivate->drm = NULL;\n\tdrm_dev_put(drm);\n\treturn ret;\n}\n\nstatic void mtk_drm_unbind(struct device *dev)\n{\n\tstruct mtk_drm_private *private = dev_get_drvdata(dev);\n\n\t \n\tif (private->drm_master) {\n\t\tdrm_dev_unregister(private->drm);\n\t\tmtk_drm_kms_deinit(private->drm);\n\t\tdrm_dev_put(private->drm);\n\t}\n\tprivate->mtk_drm_bound = false;\n\tprivate->drm_master = false;\n\tprivate->drm = NULL;\n}\n\nstatic const struct component_master_ops mtk_drm_ops = {\n\t.bind\t\t= mtk_drm_bind,\n\t.unbind\t\t= mtk_drm_unbind,\n};\n\nstatic const struct of_device_id mtk_ddp_comp_dt_ids[] = {\n\t{ .compatible = \"mediatek,mt8167-disp-aal\",\n\t  .data = (void *)MTK_DISP_AAL},\n\t{ .compatible = \"mediatek,mt8173-disp-aal\",\n\t  .data = (void *)MTK_DISP_AAL},\n\t{ .compatible = \"mediatek,mt8183-disp-aal\",\n\t  .data = (void *)MTK_DISP_AAL},\n\t{ .compatible = \"mediatek,mt8192-disp-aal\",\n\t  .data = (void *)MTK_DISP_AAL},\n\t{ .compatible = \"mediatek,mt8167-disp-ccorr\",\n\t  .data = (void *)MTK_DISP_CCORR },\n\t{ .compatible = \"mediatek,mt8183-disp-ccorr\",\n\t  .data = (void *)MTK_DISP_CCORR },\n\t{ .compatible = \"mediatek,mt8192-disp-ccorr\",\n\t  .data = (void *)MTK_DISP_CCORR },\n\t{ .compatible = \"mediatek,mt2701-disp-color\",\n\t  .data = (void *)MTK_DISP_COLOR },\n\t{ .compatible = \"mediatek,mt8167-disp-color\",\n\t  .data = (void *)MTK_DISP_COLOR },\n\t{ .compatible = \"mediatek,mt8173-disp-color\",\n\t  .data = (void *)MTK_DISP_COLOR },\n\t{ .compatible = \"mediatek,mt8167-disp-dither\",\n\t  .data = (void *)MTK_DISP_DITHER },\n\t{ .compatible = \"mediatek,mt8183-disp-dither\",\n\t  .data = (void *)MTK_DISP_DITHER },\n\t{ .compatible = \"mediatek,mt8195-disp-dsc\",\n\t  .data = (void *)MTK_DISP_DSC },\n\t{ .compatible = \"mediatek,mt8167-disp-gamma\",\n\t  .data = (void *)MTK_DISP_GAMMA, },\n\t{ .compatible = \"mediatek,mt8173-disp-gamma\",\n\t  .data = (void *)MTK_DISP_GAMMA, },\n\t{ .compatible = \"mediatek,mt8183-disp-gamma\",\n\t  .data = (void *)MTK_DISP_GAMMA, },\n\t{ .compatible = \"mediatek,mt8195-disp-merge\",\n\t  .data = (void *)MTK_DISP_MERGE },\n\t{ .compatible = \"mediatek,mt2701-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt2712-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8167-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8173-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8183-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8186-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8188-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8192-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8195-disp-mutex\",\n\t  .data = (void *)MTK_DISP_MUTEX },\n\t{ .compatible = \"mediatek,mt8173-disp-od\",\n\t  .data = (void *)MTK_DISP_OD },\n\t{ .compatible = \"mediatek,mt2701-disp-ovl\",\n\t  .data = (void *)MTK_DISP_OVL },\n\t{ .compatible = \"mediatek,mt8167-disp-ovl\",\n\t  .data = (void *)MTK_DISP_OVL },\n\t{ .compatible = \"mediatek,mt8173-disp-ovl\",\n\t  .data = (void *)MTK_DISP_OVL },\n\t{ .compatible = \"mediatek,mt8183-disp-ovl\",\n\t  .data = (void *)MTK_DISP_OVL },\n\t{ .compatible = \"mediatek,mt8192-disp-ovl\",\n\t  .data = (void *)MTK_DISP_OVL },\n\t{ .compatible = \"mediatek,mt8183-disp-ovl-2l\",\n\t  .data = (void *)MTK_DISP_OVL_2L },\n\t{ .compatible = \"mediatek,mt8192-disp-ovl-2l\",\n\t  .data = (void *)MTK_DISP_OVL_2L },\n\t{ .compatible = \"mediatek,mt8192-disp-postmask\",\n\t  .data = (void *)MTK_DISP_POSTMASK },\n\t{ .compatible = \"mediatek,mt2701-disp-pwm\",\n\t  .data = (void *)MTK_DISP_BLS },\n\t{ .compatible = \"mediatek,mt8167-disp-pwm\",\n\t  .data = (void *)MTK_DISP_PWM },\n\t{ .compatible = \"mediatek,mt8173-disp-pwm\",\n\t  .data = (void *)MTK_DISP_PWM },\n\t{ .compatible = \"mediatek,mt2701-disp-rdma\",\n\t  .data = (void *)MTK_DISP_RDMA },\n\t{ .compatible = \"mediatek,mt8167-disp-rdma\",\n\t  .data = (void *)MTK_DISP_RDMA },\n\t{ .compatible = \"mediatek,mt8173-disp-rdma\",\n\t  .data = (void *)MTK_DISP_RDMA },\n\t{ .compatible = \"mediatek,mt8183-disp-rdma\",\n\t  .data = (void *)MTK_DISP_RDMA },\n\t{ .compatible = \"mediatek,mt8195-disp-rdma\",\n\t  .data = (void *)MTK_DISP_RDMA },\n\t{ .compatible = \"mediatek,mt8173-disp-ufoe\",\n\t  .data = (void *)MTK_DISP_UFOE },\n\t{ .compatible = \"mediatek,mt8173-disp-wdma\",\n\t  .data = (void *)MTK_DISP_WDMA },\n\t{ .compatible = \"mediatek,mt2701-dpi\",\n\t  .data = (void *)MTK_DPI },\n\t{ .compatible = \"mediatek,mt8167-dsi\",\n\t  .data = (void *)MTK_DSI },\n\t{ .compatible = \"mediatek,mt8173-dpi\",\n\t  .data = (void *)MTK_DPI },\n\t{ .compatible = \"mediatek,mt8183-dpi\",\n\t  .data = (void *)MTK_DPI },\n\t{ .compatible = \"mediatek,mt8186-dpi\",\n\t  .data = (void *)MTK_DPI },\n\t{ .compatible = \"mediatek,mt8188-dp-intf\",\n\t  .data = (void *)MTK_DP_INTF },\n\t{ .compatible = \"mediatek,mt8192-dpi\",\n\t  .data = (void *)MTK_DPI },\n\t{ .compatible = \"mediatek,mt8195-dp-intf\",\n\t  .data = (void *)MTK_DP_INTF },\n\t{ .compatible = \"mediatek,mt2701-dsi\",\n\t  .data = (void *)MTK_DSI },\n\t{ .compatible = \"mediatek,mt8173-dsi\",\n\t  .data = (void *)MTK_DSI },\n\t{ .compatible = \"mediatek,mt8183-dsi\",\n\t  .data = (void *)MTK_DSI },\n\t{ .compatible = \"mediatek,mt8186-dsi\",\n\t  .data = (void *)MTK_DSI },\n\t{ }\n};\n\nstatic int mtk_drm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *phandle = dev->parent->of_node;\n\tconst struct of_device_id *of_id;\n\tstruct mtk_drm_private *private;\n\tstruct device_node *node;\n\tstruct component_match *match = NULL;\n\tstruct platform_device *ovl_adaptor;\n\tint ret;\n\tint i;\n\n\tprivate = devm_kzalloc(dev, sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tprivate->mmsys_dev = dev->parent;\n\tif (!private->mmsys_dev) {\n\t\tdev_err(dev, \"Failed to get MMSYS device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tof_id = of_match_node(mtk_drm_of_ids, phandle);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tprivate->data = of_id->data;\n\n\tprivate->all_drm_private = devm_kmalloc_array(dev, private->data->mmsys_dev_num,\n\t\t\t\t\t\t      sizeof(*private->all_drm_private),\n\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!private->all_drm_private)\n\t\treturn -ENOMEM;\n\n\t \n\tif (mtk_drm_find_mmsys_comp(private, DDP_COMPONENT_DRM_OVL_ADAPTOR)) {\n\t\tovl_adaptor = platform_device_register_data(dev, \"mediatek-disp-ovl-adaptor\",\n\t\t\t\t\t\t\t    PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t    (void *)private->mmsys_dev,\n\t\t\t\t\t\t\t    sizeof(*private->mmsys_dev));\n\t\tprivate->ddp_comp[DDP_COMPONENT_DRM_OVL_ADAPTOR].dev = &ovl_adaptor->dev;\n\t\tmtk_ddp_comp_init(NULL, &private->ddp_comp[DDP_COMPONENT_DRM_OVL_ADAPTOR],\n\t\t\t\t  DDP_COMPONENT_DRM_OVL_ADAPTOR);\n\t\tcomponent_match_add(dev, &match, compare_dev, &ovl_adaptor->dev);\n\t}\n\n\t \n\tfor_each_child_of_node(phandle->parent, node) {\n\t\tconst struct of_device_id *of_id;\n\t\tenum mtk_ddp_comp_type comp_type;\n\t\tint comp_id;\n\n\t\tof_id = of_match_node(mtk_ddp_comp_dt_ids, node);\n\t\tif (!of_id)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(node)) {\n\t\t\tdev_dbg(dev, \"Skipping disabled component %pOF\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomp_type = (enum mtk_ddp_comp_type)(uintptr_t)of_id->data;\n\n\t\tif (comp_type == MTK_DISP_MUTEX) {\n\t\t\tint id;\n\n\t\t\tid = of_alias_get_id(node, \"mutex\");\n\t\t\tif (id < 0 || id == private->data->mmsys_id) {\n\t\t\t\tprivate->mutex_node = of_node_get(node);\n\t\t\t\tdev_dbg(dev, \"get mutex for mmsys %d\", private->data->mmsys_id);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomp_id = mtk_ddp_comp_get_id(node, comp_type);\n\t\tif (comp_id < 0) {\n\t\t\tdev_warn(dev, \"Skipping unknown component %pOF\\n\",\n\t\t\t\t node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mtk_drm_find_mmsys_comp(private, comp_id))\n\t\t\tcontinue;\n\n\t\tprivate->comp_node[comp_id] = of_node_get(node);\n\n\t\t \n\t\tif (comp_type == MTK_DISP_AAL ||\n\t\t    comp_type == MTK_DISP_CCORR ||\n\t\t    comp_type == MTK_DISP_COLOR ||\n\t\t    comp_type == MTK_DISP_GAMMA ||\n\t\t    comp_type == MTK_DISP_MERGE ||\n\t\t    comp_type == MTK_DISP_OVL ||\n\t\t    comp_type == MTK_DISP_OVL_2L ||\n\t\t    comp_type == MTK_DISP_OVL_ADAPTOR ||\n\t\t    comp_type == MTK_DISP_RDMA ||\n\t\t    comp_type == MTK_DP_INTF ||\n\t\t    comp_type == MTK_DPI ||\n\t\t    comp_type == MTK_DSI) {\n\t\t\tdev_info(dev, \"Adding component match for %pOF\\n\",\n\t\t\t\t node);\n\t\t\tdrm_of_component_match_add(dev, &match, component_compare_of,\n\t\t\t\t\t\t   node);\n\t\t}\n\n\t\tret = mtk_ddp_comp_init(node, &private->ddp_comp[comp_id], comp_id);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\tgoto err_node;\n\t\t}\n\t}\n\n\tif (!private->mutex_node) {\n\t\tdev_err(dev, \"Failed to find disp-mutex node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_node;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tplatform_set_drvdata(pdev, private);\n\n\tret = component_master_add_with_match(dev, &mtk_drm_ops, match);\n\tif (ret)\n\t\tgoto err_pm;\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev);\nerr_node:\n\tof_node_put(private->mutex_node);\n\tfor (i = 0; i < DDP_COMPONENT_DRM_ID_MAX; i++)\n\t\tof_node_put(private->comp_node[i]);\n\treturn ret;\n}\n\nstatic void mtk_drm_remove(struct platform_device *pdev)\n{\n\tstruct mtk_drm_private *private = platform_get_drvdata(pdev);\n\tint i;\n\n\tcomponent_master_del(&pdev->dev, &mtk_drm_ops);\n\tpm_runtime_disable(&pdev->dev);\n\tof_node_put(private->mutex_node);\n\tfor (i = 0; i < DDP_COMPONENT_DRM_ID_MAX; i++)\n\t\tof_node_put(private->comp_node[i]);\n}\n\nstatic int mtk_drm_sys_prepare(struct device *dev)\n{\n\tstruct mtk_drm_private *private = dev_get_drvdata(dev);\n\tstruct drm_device *drm = private->drm;\n\n\tif (private->drm_master)\n\t\treturn drm_mode_config_helper_suspend(drm);\n\telse\n\t\treturn 0;\n}\n\nstatic void mtk_drm_sys_complete(struct device *dev)\n{\n\tstruct mtk_drm_private *private = dev_get_drvdata(dev);\n\tstruct drm_device *drm = private->drm;\n\tint ret = 0;\n\n\tif (private->drm_master)\n\t\tret = drm_mode_config_helper_resume(drm);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to resume\\n\");\n}\n\nstatic const struct dev_pm_ops mtk_drm_pm_ops = {\n\t.prepare = mtk_drm_sys_prepare,\n\t.complete = mtk_drm_sys_complete,\n};\n\nstatic struct platform_driver mtk_drm_platform_driver = {\n\t.probe\t= mtk_drm_probe,\n\t.remove_new = mtk_drm_remove,\n\t.driver\t= {\n\t\t.name\t= \"mediatek-drm\",\n\t\t.pm     = &mtk_drm_pm_ops,\n\t},\n};\n\nstatic struct platform_driver * const mtk_drm_drivers[] = {\n\t&mtk_disp_aal_driver,\n\t&mtk_disp_ccorr_driver,\n\t&mtk_disp_color_driver,\n\t&mtk_disp_gamma_driver,\n\t&mtk_disp_merge_driver,\n\t&mtk_disp_ovl_adaptor_driver,\n\t&mtk_disp_ovl_driver,\n\t&mtk_disp_rdma_driver,\n\t&mtk_dpi_driver,\n\t&mtk_drm_platform_driver,\n\t&mtk_dsi_driver,\n\t&mtk_ethdr_driver,\n\t&mtk_mdp_rdma_driver,\n};\n\nstatic int __init mtk_drm_init(void)\n{\n\treturn platform_register_drivers(mtk_drm_drivers,\n\t\t\t\t\t ARRAY_SIZE(mtk_drm_drivers));\n}\n\nstatic void __exit mtk_drm_exit(void)\n{\n\tplatform_unregister_drivers(mtk_drm_drivers,\n\t\t\t\t    ARRAY_SIZE(mtk_drm_drivers));\n}\n\nmodule_init(mtk_drm_init);\nmodule_exit(mtk_drm_exit);\n\nMODULE_AUTHOR(\"YT SHEN <yt.shen@mediatek.com>\");\nMODULE_DESCRIPTION(\"Mediatek SoC DRM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}