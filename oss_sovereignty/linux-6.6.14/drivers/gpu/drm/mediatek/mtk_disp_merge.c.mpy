{
  "module_name": "mtk_disp_merge.c",
  "hash_id": "3ab7103dfaf7405ca13d1c5b0cfa40d87eef9d9e0bbdad513916836d426c0192",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_disp_merge.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_disp_drv.h\"\n\n#define DISP_REG_MERGE_CTRL\t\t0x000\n#define MERGE_EN\t\t\t\t1\n#define DISP_REG_MERGE_CFG_0\t\t0x010\n#define DISP_REG_MERGE_CFG_1\t\t0x014\n#define DISP_REG_MERGE_CFG_4\t\t0x020\n#define DISP_REG_MERGE_CFG_10\t\t0x038\n \n#define SWAP_MODE\t\t\t\t0\n#define FLD_SWAP_MODE\t\t\t\tGENMASK(4, 0)\n#define DISP_REG_MERGE_CFG_12\t\t0x040\n#define CFG_10_10_1PI_2PO_BUF_MODE\t\t6\n#define CFG_10_10_2PI_2PO_BUF_MODE\t\t8\n#define CFG_11_10_1PI_2PO_MERGE\t\t\t18\n#define FLD_CFG_MERGE_MODE\t\t\tGENMASK(4, 0)\n#define DISP_REG_MERGE_CFG_24\t\t0x070\n#define DISP_REG_MERGE_CFG_25\t\t0x074\n#define DISP_REG_MERGE_CFG_26\t\t0x078\n#define DISP_REG_MERGE_CFG_27\t\t0x07c\n#define DISP_REG_MERGE_CFG_36\t\t0x0a0\n#define ULTRA_EN\t\t\t\tBIT(0)\n#define PREULTRA_EN\t\t\t\tBIT(4)\n#define DISP_REG_MERGE_CFG_37\t\t0x0a4\n \n#define BUFFER_MODE\t\t\t\t3\n#define FLD_BUFFER_MODE\t\t\t\tGENMASK(1, 0)\n \n#define DISP_REG_MERGE_CFG_40\t\t0x0b0\n \n#define ULTRA_TH_LOW\t\t\t\t(6 * 594)\n \n#define ULTRA_TH_HIGH\t\t\t\t(8 * 594)\n#define FLD_ULTRA_TH_LOW\t\t\tGENMASK(15, 0)\n#define FLD_ULTRA_TH_HIGH\t\t\tGENMASK(31, 16)\n#define DISP_REG_MERGE_CFG_41\t\t0x0b4\n \n#define PREULTRA_TH_LOW\t\t\t\t(8 * 594)\n \n#define PREULTRA_TH_HIGH\t\t\t(9 * 594)\n#define FLD_PREULTRA_TH_LOW\t\t\tGENMASK(15, 0)\n#define FLD_PREULTRA_TH_HIGH\t\t\tGENMASK(31, 16)\n\n#define DISP_REG_MERGE_MUTE_0\t\t0xf00\n\nstruct mtk_disp_merge {\n\tvoid __iomem\t\t\t*regs;\n\tstruct clk\t\t\t*clk;\n\tstruct clk\t\t\t*async_clk;\n\tstruct cmdq_client_reg\t\tcmdq_reg;\n\tbool\t\t\t\tfifo_en;\n\tbool\t\t\t\tmute_support;\n\tstruct reset_control\t\t*reset_ctl;\n};\n\nvoid mtk_merge_start(struct device *dev)\n{\n\tmtk_merge_start_cmdq(dev, NULL);\n}\n\nvoid mtk_merge_stop(struct device *dev)\n{\n\tmtk_merge_stop_cmdq(dev, NULL);\n}\n\nvoid mtk_merge_start_cmdq(struct device *dev, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_merge *priv = dev_get_drvdata(dev);\n\n\tif (priv->mute_support)\n\t\tmtk_ddp_write(cmdq_pkt, 0x0, &priv->cmdq_reg, priv->regs,\n\t\t\t      DISP_REG_MERGE_MUTE_0);\n\n\tmtk_ddp_write(cmdq_pkt, 1, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CTRL);\n}\n\nvoid mtk_merge_stop_cmdq(struct device *dev, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_merge *priv = dev_get_drvdata(dev);\n\n\tif (priv->mute_support)\n\t\tmtk_ddp_write(cmdq_pkt, 0x1, &priv->cmdq_reg, priv->regs,\n\t\t\t      DISP_REG_MERGE_MUTE_0);\n\n\tmtk_ddp_write(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CTRL);\n\n\tif (!cmdq_pkt && priv->async_clk)\n\t\treset_control_reset(priv->reset_ctl);\n}\n\nstatic void mtk_merge_fifo_setting(struct mtk_disp_merge *priv,\n\t\t\t\t   struct cmdq_pkt *cmdq_pkt)\n{\n\tmtk_ddp_write(cmdq_pkt, ULTRA_EN | PREULTRA_EN,\n\t\t      &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_36);\n\n\tmtk_ddp_write_mask(cmdq_pkt, BUFFER_MODE,\n\t\t\t   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_37,\n\t\t\t   FLD_BUFFER_MODE);\n\n\tmtk_ddp_write_mask(cmdq_pkt, ULTRA_TH_LOW | ULTRA_TH_HIGH << 16,\n\t\t\t   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_40,\n\t\t\t   FLD_ULTRA_TH_LOW | FLD_ULTRA_TH_HIGH);\n\n\tmtk_ddp_write_mask(cmdq_pkt, PREULTRA_TH_LOW | PREULTRA_TH_HIGH << 16,\n\t\t\t   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_41,\n\t\t\t   FLD_PREULTRA_TH_LOW | FLD_PREULTRA_TH_HIGH);\n}\n\nvoid mtk_merge_config(struct device *dev, unsigned int w,\n\t\t      unsigned int h, unsigned int vrefresh,\n\t\t      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)\n{\n\tmtk_merge_advance_config(dev, w, 0, h, vrefresh, bpc, cmdq_pkt);\n}\n\nvoid mtk_merge_advance_config(struct device *dev, unsigned int l_w, unsigned int r_w,\n\t\t\t      unsigned int h, unsigned int vrefresh, unsigned int bpc,\n\t\t\t      struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_merge *priv = dev_get_drvdata(dev);\n\tunsigned int mode = CFG_10_10_1PI_2PO_BUF_MODE;\n\n\tif (!h || !l_w) {\n\t\tdev_err(dev, \"%s: input width(%d) or height(%d) is invalid\\n\", __func__, l_w, h);\n\t\treturn;\n\t}\n\n\tif (priv->fifo_en) {\n\t\tmtk_merge_fifo_setting(priv, cmdq_pkt);\n\t\tmode = CFG_10_10_2PI_2PO_BUF_MODE;\n\t}\n\n\tif (r_w)\n\t\tmode = CFG_11_10_1PI_2PO_MERGE;\n\n\tmtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_0);\n\tmtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_1);\n\tmtk_ddp_write(cmdq_pkt, h << 16 | (l_w + r_w), &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_4);\n\t \n\tmtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_24);\n\tif (r_w)\n\t\tmtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,\n\t\t\t      DISP_REG_MERGE_CFG_25);\n\telse\n\t\tmtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,\n\t\t\t      DISP_REG_MERGE_CFG_25);\n\n\t \n\tmtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_26);\n\tmtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,\n\t\t      DISP_REG_MERGE_CFG_27);\n\n\tmtk_ddp_write_mask(cmdq_pkt, SWAP_MODE, &priv->cmdq_reg, priv->regs,\n\t\t\t   DISP_REG_MERGE_CFG_10, FLD_SWAP_MODE);\n\tmtk_ddp_write_mask(cmdq_pkt, mode, &priv->cmdq_reg, priv->regs,\n\t\t\t   DISP_REG_MERGE_CFG_12, FLD_CFG_MERGE_MODE);\n}\n\nint mtk_merge_clk_enable(struct device *dev)\n{\n\tint ret = 0;\n\tstruct mtk_disp_merge *priv = dev_get_drvdata(dev);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"merge clk prepare enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(priv->async_clk);\n\tif (ret) {\n\t\t \n\t\tclk_disable_unprepare(priv->clk);\n\n\t\tdev_err(dev, \"async clk prepare enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid mtk_merge_clk_disable(struct device *dev)\n{\n\tstruct mtk_disp_merge *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->async_clk);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic int mtk_disp_merge_bind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\treturn 0;\n}\n\nstatic void mtk_disp_merge_unbind(struct device *dev, struct device *master,\n\t\t\t\t  void *data)\n{\n}\n\nstatic const struct component_ops mtk_disp_merge_component_ops = {\n\t.bind\t= mtk_disp_merge_bind,\n\t.unbind = mtk_disp_merge_unbind,\n};\n\nstatic int mtk_disp_merge_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct mtk_disp_merge *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"failed to ioremap merge\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get merge clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->async_clk = devm_clk_get_optional(dev, \"merge_async\");\n\tif (IS_ERR(priv->async_clk)) {\n\t\tdev_err(dev, \"failed to get merge async clock\\n\");\n\t\treturn PTR_ERR(priv->async_clk);\n\t}\n\n\tif (priv->async_clk) {\n\t\tpriv->reset_ctl = devm_reset_control_get_optional_exclusive(dev, NULL);\n\t\tif (IS_ERR(priv->reset_ctl))\n\t\t\treturn PTR_ERR(priv->reset_ctl);\n\t}\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);\n\tif (ret)\n\t\tdev_dbg(dev, \"get mediatek,gce-client-reg fail!\\n\");\n#endif\n\n\tpriv->fifo_en = of_property_read_bool(dev->of_node,\n\t\t\t\t\t      \"mediatek,merge-fifo-en\");\n\n\tpriv->mute_support = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t   \"mediatek,merge-mute\");\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = component_add(dev, &mtk_disp_merge_component_ops);\n\tif (ret != 0)\n\t\tdev_err(dev, \"Failed to add component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mtk_disp_merge_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_disp_merge_component_ops);\n}\n\nstatic const struct of_device_id mtk_disp_merge_driver_dt_match[] = {\n\t{ .compatible = \"mediatek,mt8195-disp-merge\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mtk_disp_merge_driver_dt_match);\n\nstruct platform_driver mtk_disp_merge_driver = {\n\t.probe = mtk_disp_merge_probe,\n\t.remove_new = mtk_disp_merge_remove,\n\t.driver = {\n\t\t.name = \"mediatek-disp-merge\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = mtk_disp_merge_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}