{
  "module_name": "mtk_drm_plane.c",
  "hash_id": "ed145f51115ff5c1417010401989783bc1c2109ab771a594d5610f706a8ae024",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_drm_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <linux/align.h>\n\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_drm_gem.h\"\n#include \"mtk_drm_plane.h\"\n\nstatic const u64 modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE),\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nstatic void mtk_plane_reset(struct drm_plane *plane)\n{\n\tstruct mtk_plane_state *state;\n\n\tif (plane->state) {\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\n\t\tstate = to_mtk_plane_state(plane->state);\n\t\tmemset(state, 0, sizeof(*state));\n\t} else {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state)\n\t\t\treturn;\n\t}\n\n\t__drm_atomic_helper_plane_reset(plane, &state->base);\n\n\tstate->base.plane = plane;\n\tstate->pending.format = DRM_FORMAT_RGB565;\n\tstate->pending.modifier = DRM_FORMAT_MOD_LINEAR;\n}\n\nstatic struct drm_plane_state *mtk_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct mtk_plane_state *old_state = to_mtk_plane_state(plane->state);\n\tstruct mtk_plane_state *state;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\n\n\tWARN_ON(state->base.plane != plane);\n\n\tstate->pending = old_state->pending;\n\n\treturn &state->base;\n}\n\nstatic bool mtk_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t   uint32_t format,\n\t\t\t\t\t   uint64_t modifier)\n{\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\tif (modifier != DRM_FORMAT_MOD_ARM_AFBC(\n\t\t\t\tAFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE))\n\t\treturn false;\n\n\tif (format != DRM_FORMAT_XRGB8888 &&\n\t    format != DRM_FORMAT_ARGB8888 &&\n\t    format != DRM_FORMAT_BGRX8888 &&\n\t    format != DRM_FORMAT_BGRA8888 &&\n\t    format != DRM_FORMAT_ABGR8888 &&\n\t    format != DRM_FORMAT_XBGR8888 &&\n\t    format != DRM_FORMAT_RGB888 &&\n\t    format != DRM_FORMAT_BGR888)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void mtk_drm_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(to_mtk_plane_state(state));\n}\n\nstatic int mtk_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (plane != new_plane_state->crtc->cursor)\n\t\treturn -EINVAL;\n\n\tif (!plane->state)\n\t\treturn -EINVAL;\n\n\tif (!plane->state->fb)\n\t\treturn -EINVAL;\n\n\tret = mtk_drm_crtc_plane_check(new_plane_state->crtc, plane,\n\t\t\t\t       to_mtk_plane_state(new_plane_state));\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, new_plane_state->crtc);\n\n\treturn drm_atomic_helper_check_plane_state(plane->state, crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void mtk_plane_update_new_state(struct drm_plane_state *new_state,\n\t\t\t\t       struct mtk_plane_state *mtk_plane_state)\n{\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_gem_object *gem;\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\tunsigned int pitch, format;\n\tu64 modifier;\n\tdma_addr_t addr;\n\tdma_addr_t hdr_addr = 0;\n\tunsigned int hdr_pitch = 0;\n\tint offset;\n\n\tgem = fb->obj[0];\n\tmtk_gem = to_mtk_gem_obj(gem);\n\taddr = mtk_gem->dma_addr;\n\tpitch = fb->pitches[0];\n\tformat = fb->format->format;\n\tmodifier = fb->modifier;\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\t \n\t\toffset = (new_state->src.x1 >> 16) * fb->format->cpp[0];\n\t\taddr += offset;\n\t\toffset = (new_state->src.y1 >> 16) * pitch;\n\t\taddr += offset;\n\t} else {\n\t\tint width_in_blocks = ALIGN(fb->width, AFBC_DATA_BLOCK_WIDTH)\n\t\t\t\t      / AFBC_DATA_BLOCK_WIDTH;\n\t\tint height_in_blocks = ALIGN(fb->height, AFBC_DATA_BLOCK_HEIGHT)\n\t\t\t\t       / AFBC_DATA_BLOCK_HEIGHT;\n\t\tint x_offset_in_blocks = (new_state->src.x1 >> 16) / AFBC_DATA_BLOCK_WIDTH;\n\t\tint y_offset_in_blocks = (new_state->src.y1 >> 16) / AFBC_DATA_BLOCK_HEIGHT;\n\t\tint hdr_size, hdr_offset;\n\n\t\thdr_pitch = width_in_blocks * AFBC_HEADER_BLOCK_SIZE;\n\t\tpitch = width_in_blocks * AFBC_DATA_BLOCK_WIDTH *\n\t\t\tAFBC_DATA_BLOCK_HEIGHT * fb->format->cpp[0];\n\n\t\thdr_size = ALIGN(hdr_pitch * height_in_blocks, AFBC_HEADER_ALIGNMENT);\n\t\thdr_offset = hdr_pitch * y_offset_in_blocks +\n\t\t\tAFBC_HEADER_BLOCK_SIZE * x_offset_in_blocks;\n\n\t\t \n\t\thdr_addr = addr + hdr_offset;\n\n\t\t \n\t\toffset = pitch * y_offset_in_blocks +\n\t\t\t AFBC_DATA_BLOCK_WIDTH * AFBC_DATA_BLOCK_HEIGHT *\n\t\t\t fb->format->cpp[0] * (x_offset_in_blocks + 1);\n\n\t\t \n\t\taddr = addr + hdr_size + offset;\n\t}\n\n\tmtk_plane_state->pending.enable = true;\n\tmtk_plane_state->pending.pitch = pitch;\n\tmtk_plane_state->pending.hdr_pitch = hdr_pitch;\n\tmtk_plane_state->pending.format = format;\n\tmtk_plane_state->pending.modifier = modifier;\n\tmtk_plane_state->pending.addr = addr;\n\tmtk_plane_state->pending.hdr_addr = hdr_addr;\n\tmtk_plane_state->pending.x = new_state->dst.x1;\n\tmtk_plane_state->pending.y = new_state->dst.y1;\n\tmtk_plane_state->pending.width = drm_rect_width(&new_state->dst);\n\tmtk_plane_state->pending.height = drm_rect_height(&new_state->dst);\n\tmtk_plane_state->pending.rotation = new_state->rotation;\n\tmtk_plane_state->pending.color_encoding = new_state->color_encoding;\n}\n\nstatic void mtk_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct mtk_plane_state *new_plane_state = to_mtk_plane_state(plane->state);\n\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\tplane->state->crtc_h = new_state->crtc_h;\n\tplane->state->crtc_w = new_state->crtc_w;\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->src_h = new_state->src_h;\n\tplane->state->src_w = new_state->src_w;\n\n\tmtk_plane_update_new_state(new_state, new_plane_state);\n\tswap(plane->state->fb, new_state->fb);\n\twmb();  \n\tnew_plane_state->pending.async_dirty = true;\n\tmtk_drm_crtc_async_update(new_state->crtc, plane, state);\n}\n\nstatic const struct drm_plane_funcs mtk_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = mtk_plane_reset,\n\t.atomic_duplicate_state = mtk_plane_duplicate_state,\n\t.atomic_destroy_state = mtk_drm_plane_destroy_state,\n\t.format_mod_supported = mtk_plane_format_mod_supported,\n};\n\nstatic int mtk_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tif (WARN_ON(!new_plane_state->crtc))\n\t\treturn 0;\n\n\tret = mtk_drm_crtc_plane_check(new_plane_state->crtc, plane,\n\t\t\t\t       to_mtk_plane_state(new_plane_state));\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic void mtk_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct mtk_plane_state *mtk_plane_state = to_mtk_plane_state(new_state);\n\tmtk_plane_state->pending.enable = false;\n\twmb();  \n\tmtk_plane_state->pending.dirty = true;\n}\n\nstatic void mtk_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct mtk_plane_state *mtk_plane_state = to_mtk_plane_state(new_state);\n\n\tif (!new_state->crtc || WARN_ON(!new_state->fb))\n\t\treturn;\n\n\tif (!new_state->visible) {\n\t\tmtk_plane_atomic_disable(plane, state);\n\t\treturn;\n\t}\n\n\tmtk_plane_update_new_state(new_state, mtk_plane_state);\n\twmb();  \n\tmtk_plane_state->pending.dirty = true;\n}\n\nstatic const struct drm_plane_helper_funcs mtk_plane_helper_funcs = {\n\t.atomic_check = mtk_plane_atomic_check,\n\t.atomic_update = mtk_plane_atomic_update,\n\t.atomic_disable = mtk_plane_atomic_disable,\n\t.atomic_async_update = mtk_plane_atomic_async_update,\n\t.atomic_async_check = mtk_plane_atomic_async_check,\n};\n\nint mtk_plane_init(struct drm_device *dev, struct drm_plane *plane,\n\t\t   unsigned long possible_crtcs, enum drm_plane_type type,\n\t\t   unsigned int supported_rotations, const u32 *formats,\n\t\t   size_t num_formats)\n{\n\tint err;\n\n\tif (!formats || !num_formats) {\n\t\tDRM_ERROR(\"no formats for plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = drm_universal_plane_init(dev, plane, possible_crtcs,\n\t\t\t\t       &mtk_plane_funcs, formats,\n\t\t\t\t       num_formats, modifiers, type, NULL);\n\tif (err) {\n\t\tDRM_ERROR(\"failed to initialize plane\\n\");\n\t\treturn err;\n\t}\n\n\tif (supported_rotations & ~DRM_MODE_ROTATE_0) {\n\t\terr = drm_plane_create_rotation_property(plane,\n\t\t\t\t\t\t\t DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t\t supported_rotations);\n\t\tif (err)\n\t\t\tDRM_INFO(\"Create rotation property failed\\n\");\n\t}\n\n\tdrm_plane_helper_add(plane, &mtk_plane_helper_funcs);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}