{
  "module_name": "mtk_cec.c",
  "hash_id": "3008e3541d4f54c1bafb850321f798a77b92949390d397efdf07fdaa7fe50b13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_cec.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#include \"mtk_cec.h\"\n#include \"mtk_hdmi.h\"\n#include \"mtk_drm_drv.h\"\n\n#define TR_CONFIG\t\t0x00\n#define CLEAR_CEC_IRQ\t\t\tBIT(15)\n\n#define CEC_CKGEN\t\t0x04\n#define CEC_32K_PDN\t\t\tBIT(19)\n#define PDN\t\t\t\tBIT(16)\n\n#define RX_EVENT\t\t0x54\n#define HDMI_PORD\t\t\tBIT(25)\n#define HDMI_HTPLG\t\t\tBIT(24)\n#define HDMI_PORD_INT_EN\t\tBIT(9)\n#define HDMI_HTPLG_INT_EN\t\tBIT(8)\n\n#define RX_GEN_WD\t\t0x58\n#define HDMI_PORD_INT_32K_STATUS\tBIT(26)\n#define RX_RISC_INT_32K_STATUS\t\tBIT(25)\n#define HDMI_HTPLG_INT_32K_STATUS\tBIT(24)\n#define HDMI_PORD_INT_32K_CLR\t\tBIT(18)\n#define RX_INT_32K_CLR\t\t\tBIT(17)\n#define HDMI_HTPLG_INT_32K_CLR\t\tBIT(16)\n#define HDMI_PORD_INT_32K_STA_MASK\tBIT(10)\n#define RX_RISC_INT_32K_STA_MASK\tBIT(9)\n#define HDMI_HTPLG_INT_32K_STA_MASK\tBIT(8)\n#define HDMI_PORD_INT_32K_EN\t\tBIT(2)\n#define RX_INT_32K_EN\t\t\tBIT(1)\n#define HDMI_HTPLG_INT_32K_EN\t\tBIT(0)\n\n#define NORMAL_INT_CTRL\t\t0x5C\n#define HDMI_HTPLG_INT_STA\t\tBIT(0)\n#define HDMI_PORD_INT_STA\t\tBIT(1)\n#define HDMI_HTPLG_INT_CLR\t\tBIT(16)\n#define HDMI_PORD_INT_CLR\t\tBIT(17)\n#define HDMI_FULL_INT_CLR\t\tBIT(20)\n\nstruct mtk_cec {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tint irq;\n\tbool hpd;\n\tvoid (*hpd_event)(bool hpd, struct device *dev);\n\tstruct device *hdmi_dev;\n\tspinlock_t lock;\n};\n\nstatic void mtk_cec_clear_bits(struct mtk_cec *cec, unsigned int offset,\n\t\t\t       unsigned int bits)\n{\n\tvoid __iomem *reg = cec->regs + offset;\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp &= ~bits;\n\twritel(tmp, reg);\n}\n\nstatic void mtk_cec_set_bits(struct mtk_cec *cec, unsigned int offset,\n\t\t\t     unsigned int bits)\n{\n\tvoid __iomem *reg = cec->regs + offset;\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp |= bits;\n\twritel(tmp, reg);\n}\n\nstatic void mtk_cec_mask(struct mtk_cec *cec, unsigned int offset,\n\t\t\t unsigned int val, unsigned int mask)\n{\n\tu32 tmp = readl(cec->regs + offset) & ~mask;\n\n\ttmp |= val & mask;\n\twritel(tmp, cec->regs + offset);\n}\n\nvoid mtk_cec_set_hpd_event(struct device *dev,\n\t\t\t   void (*hpd_event)(bool hpd, struct device *dev),\n\t\t\t   struct device *hdmi_dev)\n{\n\tstruct mtk_cec *cec = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cec->lock, flags);\n\tcec->hdmi_dev = hdmi_dev;\n\tcec->hpd_event = hpd_event;\n\tspin_unlock_irqrestore(&cec->lock, flags);\n}\n\nbool mtk_cec_hpd_high(struct device *dev)\n{\n\tstruct mtk_cec *cec = dev_get_drvdata(dev);\n\tunsigned int status;\n\n\tstatus = readl(cec->regs + RX_EVENT);\n\n\treturn (status & (HDMI_PORD | HDMI_HTPLG)) == (HDMI_PORD | HDMI_HTPLG);\n}\n\nstatic void mtk_cec_htplg_irq_init(struct mtk_cec *cec)\n{\n\tmtk_cec_mask(cec, CEC_CKGEN, 0 | CEC_32K_PDN, PDN | CEC_32K_PDN);\n\tmtk_cec_set_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\n\t\t\t RX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\n\tmtk_cec_mask(cec, RX_GEN_WD, 0, HDMI_PORD_INT_32K_CLR | RX_INT_32K_CLR |\n\t\t     HDMI_HTPLG_INT_32K_CLR | HDMI_PORD_INT_32K_EN |\n\t\t     RX_INT_32K_EN | HDMI_HTPLG_INT_32K_EN);\n}\n\nstatic void mtk_cec_htplg_irq_enable(struct mtk_cec *cec)\n{\n\tmtk_cec_set_bits(cec, RX_EVENT, HDMI_PORD_INT_EN | HDMI_HTPLG_INT_EN);\n}\n\nstatic void mtk_cec_htplg_irq_disable(struct mtk_cec *cec)\n{\n\tmtk_cec_clear_bits(cec, RX_EVENT, HDMI_PORD_INT_EN | HDMI_HTPLG_INT_EN);\n}\n\nstatic void mtk_cec_clear_htplg_irq(struct mtk_cec *cec)\n{\n\tmtk_cec_set_bits(cec, TR_CONFIG, CLEAR_CEC_IRQ);\n\tmtk_cec_set_bits(cec, NORMAL_INT_CTRL, HDMI_HTPLG_INT_CLR |\n\t\t\t HDMI_PORD_INT_CLR | HDMI_FULL_INT_CLR);\n\tmtk_cec_set_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\n\t\t\t RX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\n\tusleep_range(5, 10);\n\tmtk_cec_clear_bits(cec, NORMAL_INT_CTRL, HDMI_HTPLG_INT_CLR |\n\t\t\t   HDMI_PORD_INT_CLR | HDMI_FULL_INT_CLR);\n\tmtk_cec_clear_bits(cec, TR_CONFIG, CLEAR_CEC_IRQ);\n\tmtk_cec_clear_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\n\t\t\t   RX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\n}\n\nstatic void mtk_cec_hpd_event(struct mtk_cec *cec, bool hpd)\n{\n\tvoid (*hpd_event)(bool hpd, struct device *dev);\n\tstruct device *hdmi_dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cec->lock, flags);\n\thpd_event = cec->hpd_event;\n\thdmi_dev = cec->hdmi_dev;\n\tspin_unlock_irqrestore(&cec->lock, flags);\n\n\tif (hpd_event)\n\t\thpd_event(hpd, hdmi_dev);\n}\n\nstatic irqreturn_t mtk_cec_htplg_isr_thread(int irq, void *arg)\n{\n\tstruct device *dev = arg;\n\tstruct mtk_cec *cec = dev_get_drvdata(dev);\n\tbool hpd;\n\n\tmtk_cec_clear_htplg_irq(cec);\n\thpd = mtk_cec_hpd_high(dev);\n\n\tif (cec->hpd != hpd) {\n\t\tdev_dbg(dev, \"hotplug event! cur hpd = %d, hpd = %d\\n\",\n\t\t\tcec->hpd, hpd);\n\t\tcec->hpd = hpd;\n\t\tmtk_cec_hpd_event(cec, hpd);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_cec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_cec *cec;\n\tstruct resource *res;\n\tint ret;\n\n\tcec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);\n\tif (!cec)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, cec);\n\tspin_lock_init(&cec->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tcec->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(cec->regs)) {\n\t\tret = PTR_ERR(cec->regs);\n\t\tdev_err(dev, \"Failed to ioremap cec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcec->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cec->clk)) {\n\t\tret = PTR_ERR(cec->clk);\n\t\tdev_err(dev, \"Failed to get cec clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcec->irq = platform_get_irq(pdev, 0);\n\tif (cec->irq < 0)\n\t\treturn cec->irq;\n\n\tret = devm_request_threaded_irq(dev, cec->irq, NULL,\n\t\t\t\t\tmtk_cec_htplg_isr_thread,\n\t\t\t\t\tIRQF_SHARED | IRQF_TRIGGER_LOW |\n\t\t\t\t\tIRQF_ONESHOT, \"hdmi hpd\", dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register cec irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(cec->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable cec clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmtk_cec_htplg_irq_init(cec);\n\tmtk_cec_htplg_irq_enable(cec);\n\n\treturn 0;\n}\n\nstatic void mtk_cec_remove(struct platform_device *pdev)\n{\n\tstruct mtk_cec *cec = platform_get_drvdata(pdev);\n\n\tmtk_cec_htplg_irq_disable(cec);\n\tclk_disable_unprepare(cec->clk);\n}\n\nstatic const struct of_device_id mtk_cec_of_ids[] = {\n\t{ .compatible = \"mediatek,mt8173-cec\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_cec_of_ids);\n\nstruct platform_driver mtk_cec_driver = {\n\t.probe = mtk_cec_probe,\n\t.remove_new = mtk_cec_remove,\n\t.driver = {\n\t\t.name = \"mediatek-cec\",\n\t\t.of_match_table = mtk_cec_of_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}