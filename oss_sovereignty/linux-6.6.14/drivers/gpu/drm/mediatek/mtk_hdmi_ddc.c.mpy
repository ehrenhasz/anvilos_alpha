{
  "module_name": "mtk_hdmi_ddc.c",
  "hash_id": "d0b3d8d67469e15120fd46a9915e72e6de03991f05ff3ad32dd53dbdde1dd6e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_hdmi_ddc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/time.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n\n#include \"mtk_drm_drv.h\"\n#include \"mtk_hdmi.h\"\n\n#define SIF1_CLOK\t\t(288)\n#define DDC_DDCMCTL0\t\t(0x0)\n#define DDCM_ODRAIN\t\t\tBIT(31)\n#define DDCM_CLK_DIV_OFFSET\t\t(16)\n#define DDCM_CLK_DIV_MASK\t\t(0xfff << 16)\n#define DDCM_CS_STATUS\t\t\tBIT(4)\n#define DDCM_SCL_STATE\t\t\tBIT(3)\n#define DDCM_SDA_STATE\t\t\tBIT(2)\n#define DDCM_SM0EN\t\t\tBIT(1)\n#define DDCM_SCL_STRECH\t\t\tBIT(0)\n#define DDC_DDCMCTL1\t\t(0x4)\n#define DDCM_ACK_OFFSET\t\t\t(16)\n#define DDCM_ACK_MASK\t\t\t(0xff << 16)\n#define DDCM_PGLEN_OFFSET\t\t(8)\n#define DDCM_PGLEN_MASK\t\t\t(0x7 << 8)\n#define DDCM_SIF_MODE_OFFSET\t\t(4)\n#define DDCM_SIF_MODE_MASK\t\t(0x7 << 4)\n#define DDCM_START\t\t\t(0x1)\n#define DDCM_WRITE_DATA\t\t\t(0x2)\n#define DDCM_STOP\t\t\t(0x3)\n#define DDCM_READ_DATA_NO_ACK\t\t(0x4)\n#define DDCM_READ_DATA_ACK\t\t(0x5)\n#define DDCM_TRI\t\t\tBIT(0)\n#define DDC_DDCMD0\t\t(0x8)\n#define DDCM_DATA3\t\t\t(0xff << 24)\n#define DDCM_DATA2\t\t\t(0xff << 16)\n#define DDCM_DATA1\t\t\t(0xff << 8)\n#define DDCM_DATA0\t\t\t(0xff << 0)\n#define DDC_DDCMD1\t\t(0xc)\n#define DDCM_DATA7\t\t\t(0xff << 24)\n#define DDCM_DATA6\t\t\t(0xff << 16)\n#define DDCM_DATA5\t\t\t(0xff << 8)\n#define DDCM_DATA4\t\t\t(0xff << 0)\n\nstruct mtk_hdmi_ddc {\n\tstruct i2c_adapter adap;\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n};\n\nstatic inline void sif_set_bit(struct mtk_hdmi_ddc *ddc, unsigned int offset,\n\t\t\t       unsigned int val)\n{\n\twritel(readl(ddc->regs + offset) | val, ddc->regs + offset);\n}\n\nstatic inline void sif_clr_bit(struct mtk_hdmi_ddc *ddc, unsigned int offset,\n\t\t\t       unsigned int val)\n{\n\twritel(readl(ddc->regs + offset) & ~val, ddc->regs + offset);\n}\n\nstatic inline bool sif_bit_is_set(struct mtk_hdmi_ddc *ddc, unsigned int offset,\n\t\t\t\t  unsigned int val)\n{\n\treturn (readl(ddc->regs + offset) & val) == val;\n}\n\nstatic inline void sif_write_mask(struct mtk_hdmi_ddc *ddc, unsigned int offset,\n\t\t\t\t  unsigned int mask, unsigned int shift,\n\t\t\t\t  unsigned int val)\n{\n\tunsigned int tmp;\n\n\ttmp = readl(ddc->regs + offset);\n\ttmp &= ~mask;\n\ttmp |= (val << shift) & mask;\n\twritel(tmp, ddc->regs + offset);\n}\n\nstatic inline unsigned int sif_read_mask(struct mtk_hdmi_ddc *ddc,\n\t\t\t\t\t unsigned int offset, unsigned int mask,\n\t\t\t\t\t unsigned int shift)\n{\n\treturn (readl(ddc->regs + offset) & mask) >> shift;\n}\n\nstatic void ddcm_trigger_mode(struct mtk_hdmi_ddc *ddc, int mode)\n{\n\tu32 val;\n\n\tsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_SIF_MODE_MASK,\n\t\t       DDCM_SIF_MODE_OFFSET, mode);\n\tsif_set_bit(ddc, DDC_DDCMCTL1, DDCM_TRI);\n\treadl_poll_timeout(ddc->regs + DDC_DDCMCTL1, val,\n\t\t\t   (val & DDCM_TRI) != DDCM_TRI, 4, 20000);\n}\n\nstatic int mtk_hdmi_ddc_read_msg(struct mtk_hdmi_ddc *ddc, struct i2c_msg *msg)\n{\n\tstruct device *dev = ddc->adap.dev.parent;\n\tu32 remain_count, ack_count, ack_final, read_count, temp_count;\n\tu32 index = 0;\n\tu32 ack;\n\tint i;\n\n\tddcm_trigger_mode(ddc, DDCM_START);\n\tsif_write_mask(ddc, DDC_DDCMD0, 0xff, 0, (msg->addr << 1) | 0x01);\n\tsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK, DDCM_PGLEN_OFFSET,\n\t\t       0x00);\n\tddcm_trigger_mode(ddc, DDCM_WRITE_DATA);\n\tack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK, DDCM_ACK_OFFSET);\n\tdev_dbg(dev, \"ack = 0x%x\\n\", ack);\n\tif (ack != 0x01) {\n\t\tdev_err(dev, \"i2c ack err!\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tremain_count = msg->len;\n\tack_count = (msg->len - 1) / 8;\n\tack_final = 0;\n\n\twhile (remain_count > 0) {\n\t\tif (ack_count > 0) {\n\t\t\tread_count = 8;\n\t\t\tack_final = 0;\n\t\t\tack_count--;\n\t\t} else {\n\t\t\tread_count = remain_count;\n\t\t\tack_final = 1;\n\t\t}\n\n\t\tsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK,\n\t\t\t       DDCM_PGLEN_OFFSET, read_count - 1);\n\t\tddcm_trigger_mode(ddc, (ack_final == 1) ?\n\t\t\t\t  DDCM_READ_DATA_NO_ACK :\n\t\t\t\t  DDCM_READ_DATA_ACK);\n\n\t\tack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK,\n\t\t\t\t    DDCM_ACK_OFFSET);\n\t\ttemp_count = 0;\n\t\twhile (((ack & (1 << temp_count)) != 0) && (temp_count < 8))\n\t\t\ttemp_count++;\n\t\tif (((ack_final == 1) && (temp_count != (read_count - 1))) ||\n\t\t    ((ack_final == 0) && (temp_count != read_count))) {\n\t\t\tdev_err(dev, \"Address NACK! ACK(0x%x)\\n\", ack);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = read_count; i >= 1; i--) {\n\t\t\tint shift;\n\t\t\tint offset;\n\n\t\t\tif (i > 4) {\n\t\t\t\toffset = DDC_DDCMD1;\n\t\t\t\tshift = (i - 5) * 8;\n\t\t\t} else {\n\t\t\t\toffset = DDC_DDCMD0;\n\t\t\t\tshift = (i - 1) * 8;\n\t\t\t}\n\n\t\t\tmsg->buf[index + i - 1] = sif_read_mask(ddc, offset,\n\t\t\t\t\t\t\t\t0xff << shift,\n\t\t\t\t\t\t\t\tshift);\n\t\t}\n\n\t\tremain_count -= read_count;\n\t\tindex += read_count;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_ddc_write_msg(struct mtk_hdmi_ddc *ddc, struct i2c_msg *msg)\n{\n\tstruct device *dev = ddc->adap.dev.parent;\n\tu32 ack;\n\n\tddcm_trigger_mode(ddc, DDCM_START);\n\tsif_write_mask(ddc, DDC_DDCMD0, DDCM_DATA0, 0, msg->addr << 1);\n\tsif_write_mask(ddc, DDC_DDCMD0, DDCM_DATA1, 8, msg->buf[0]);\n\tsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK, DDCM_PGLEN_OFFSET,\n\t\t       0x1);\n\tddcm_trigger_mode(ddc, DDCM_WRITE_DATA);\n\n\tack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK, DDCM_ACK_OFFSET);\n\tdev_dbg(dev, \"ack = %d\\n\", ack);\n\n\tif (ack != 0x03) {\n\t\tdev_err(dev, \"i2c ack err!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_ddc_xfer(struct i2c_adapter *adapter,\n\t\t\t     struct i2c_msg *msgs, int num)\n{\n\tstruct mtk_hdmi_ddc *ddc = adapter->algo_data;\n\tstruct device *dev = adapter->dev.parent;\n\tint ret;\n\tint i;\n\n\tif (!ddc) {\n\t\tdev_err(dev, \"invalid arguments\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsif_set_bit(ddc, DDC_DDCMCTL0, DDCM_SCL_STRECH);\n\tsif_set_bit(ddc, DDC_DDCMCTL0, DDCM_SM0EN);\n\tsif_clr_bit(ddc, DDC_DDCMCTL0, DDCM_ODRAIN);\n\n\tif (sif_bit_is_set(ddc, DDC_DDCMCTL1, DDCM_TRI)) {\n\t\tdev_err(dev, \"ddc line is busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsif_write_mask(ddc, DDC_DDCMCTL0, DDCM_CLK_DIV_MASK,\n\t\t       DDCM_CLK_DIV_OFFSET, SIF1_CLOK);\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct i2c_msg *msg = &msgs[i];\n\n\t\tdev_dbg(dev, \"i2c msg, adr:0x%x, flags:%d, len :0x%x\\n\",\n\t\t\tmsg->addr, msg->flags, msg->len);\n\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tret = mtk_hdmi_ddc_read_msg(ddc, msg);\n\t\telse\n\t\t\tret = mtk_hdmi_ddc_write_msg(ddc, msg);\n\t\tif (ret < 0)\n\t\t\tgoto xfer_end;\n\t}\n\n\tddcm_trigger_mode(ddc, DDCM_STOP);\n\n\treturn i;\n\nxfer_end:\n\tddcm_trigger_mode(ddc, DDCM_STOP);\n\tdev_err(dev, \"ddc failed!\\n\");\n\treturn ret;\n}\n\nstatic u32 mtk_hdmi_ddc_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm mtk_hdmi_ddc_algorithm = {\n\t.master_xfer = mtk_hdmi_ddc_xfer,\n\t.functionality = mtk_hdmi_ddc_func,\n};\n\nstatic int mtk_hdmi_ddc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_hdmi_ddc *ddc;\n\tstruct resource *mem;\n\tint ret;\n\n\tddc = devm_kzalloc(dev, sizeof(struct mtk_hdmi_ddc), GFP_KERNEL);\n\tif (!ddc)\n\t\treturn -ENOMEM;\n\n\tddc->clk = devm_clk_get(dev, \"ddc-i2c\");\n\tif (IS_ERR(ddc->clk)) {\n\t\tdev_err(dev, \"get ddc_clk failed: %p ,\\n\", ddc->clk);\n\t\treturn PTR_ERR(ddc->clk);\n\t}\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tddc->regs = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(ddc->regs))\n\t\treturn PTR_ERR(ddc->regs);\n\n\tret = clk_prepare_enable(ddc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"enable ddc clk failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tstrscpy(ddc->adap.name, \"mediatek-hdmi-ddc\", sizeof(ddc->adap.name));\n\tddc->adap.owner = THIS_MODULE;\n\tddc->adap.class = I2C_CLASS_DDC;\n\tddc->adap.algo = &mtk_hdmi_ddc_algorithm;\n\tddc->adap.retries = 3;\n\tddc->adap.dev.of_node = dev->of_node;\n\tddc->adap.algo_data = ddc;\n\tddc->adap.dev.parent = &pdev->dev;\n\n\tret = i2c_add_adapter(&ddc->adap);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to add bus to i2c core\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tplatform_set_drvdata(pdev, ddc);\n\n\tdev_dbg(dev, \"ddc->adap: %p\\n\", &ddc->adap);\n\tdev_dbg(dev, \"ddc->clk: %p\\n\", ddc->clk);\n\tdev_dbg(dev, \"physical adr: %pa, end: %pa\\n\", &mem->start,\n\t\t&mem->end);\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(ddc->clk);\n\treturn ret;\n}\n\nstatic void mtk_hdmi_ddc_remove(struct platform_device *pdev)\n{\n\tstruct mtk_hdmi_ddc *ddc = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&ddc->adap);\n\tclk_disable_unprepare(ddc->clk);\n}\n\nstatic const struct of_device_id mtk_hdmi_ddc_match[] = {\n\t{ .compatible = \"mediatek,mt8173-hdmi-ddc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_hdmi_ddc_match);\n\nstruct platform_driver mtk_hdmi_ddc_driver = {\n\t.probe = mtk_hdmi_ddc_probe,\n\t.remove_new = mtk_hdmi_ddc_remove,\n\t.driver = {\n\t\t.name = \"mediatek-hdmi-ddc\",\n\t\t.of_match_table = mtk_hdmi_ddc_match,\n\t},\n};\n\nMODULE_AUTHOR(\"Jie Qiu <jie.qiu@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek HDMI DDC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}