{
  "module_name": "mtk_disp_gamma.c",
  "hash_id": "718641eacc69e64af252af5ec1df044c32c6fc99cd23d38946492e8c92739e11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_disp_gamma.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n\n#define DISP_GAMMA_EN\t\t\t\t0x0000\n#define GAMMA_EN\t\t\t\t\tBIT(0)\n#define DISP_GAMMA_CFG\t\t\t\t0x0020\n#define GAMMA_LUT_EN\t\t\t\t\tBIT(1)\n#define GAMMA_DITHERING\t\t\t\t\tBIT(2)\n#define DISP_GAMMA_SIZE\t\t\t\t0x0030\n#define DISP_GAMMA_LUT\t\t\t\t0x0700\n\n#define LUT_10BIT_MASK\t\t\t\t0x03ff\n\nstruct mtk_disp_gamma_data {\n\tbool has_dither;\n\tbool lut_diff;\n};\n\n \nstruct mtk_disp_gamma {\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n\tstruct cmdq_client_reg cmdq_reg;\n\tconst struct mtk_disp_gamma_data *data;\n};\n\nint mtk_gamma_clk_enable(struct device *dev)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(gamma->clk);\n}\n\nvoid mtk_gamma_clk_disable(struct device *dev)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(gamma->clk);\n}\n\nvoid mtk_gamma_set_common(void __iomem *regs, struct drm_crtc_state *state, bool lut_diff)\n{\n\tunsigned int i, reg;\n\tstruct drm_color_lut *lut;\n\tvoid __iomem *lut_base;\n\tu32 word;\n\tu32 diff[3] = {0};\n\n\tif (state->gamma_lut) {\n\t\treg = readl(regs + DISP_GAMMA_CFG);\n\t\treg = reg | GAMMA_LUT_EN;\n\t\twritel(reg, regs + DISP_GAMMA_CFG);\n\t\tlut_base = regs + DISP_GAMMA_LUT;\n\t\tlut = (struct drm_color_lut *)state->gamma_lut->data;\n\t\tfor (i = 0; i < MTK_LUT_SIZE; i++) {\n\n\t\t\tif (!lut_diff || (i % 2 == 0)) {\n\t\t\t\tword = (((lut[i].red >> 6) & LUT_10BIT_MASK) << 20) +\n\t\t\t\t\t(((lut[i].green >> 6) & LUT_10BIT_MASK) << 10) +\n\t\t\t\t\t((lut[i].blue >> 6) & LUT_10BIT_MASK);\n\t\t\t} else {\n\t\t\t\tdiff[0] = (lut[i].red >> 6) - (lut[i - 1].red >> 6);\n\t\t\t\tdiff[1] = (lut[i].green >> 6) - (lut[i - 1].green >> 6);\n\t\t\t\tdiff[2] = (lut[i].blue >> 6) - (lut[i - 1].blue >> 6);\n\n\t\t\t\tword = ((diff[0] & LUT_10BIT_MASK) << 20) +\n\t\t\t\t\t((diff[1] & LUT_10BIT_MASK) << 10) +\n\t\t\t\t\t(diff[2] & LUT_10BIT_MASK);\n\t\t\t}\n\t\t\twritel(word, (lut_base + i * 4));\n\t\t}\n\t}\n}\n\nvoid mtk_gamma_set(struct device *dev, struct drm_crtc_state *state)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\tbool lut_diff = false;\n\n\tif (gamma->data)\n\t\tlut_diff = gamma->data->lut_diff;\n\n\tmtk_gamma_set_common(gamma->regs, state, lut_diff);\n}\n\nvoid mtk_gamma_config(struct device *dev, unsigned int w,\n\t\t      unsigned int h, unsigned int vrefresh,\n\t\t      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\n\tmtk_ddp_write(cmdq_pkt, h << 16 | w, &gamma->cmdq_reg, gamma->regs,\n\t\t      DISP_GAMMA_SIZE);\n\tif (gamma->data && gamma->data->has_dither)\n\t\tmtk_dither_set_common(gamma->regs, &gamma->cmdq_reg, bpc,\n\t\t\t\t      DISP_GAMMA_CFG, GAMMA_DITHERING, cmdq_pkt);\n}\n\nvoid mtk_gamma_start(struct device *dev)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\n\twritel(GAMMA_EN, gamma->regs + DISP_GAMMA_EN);\n}\n\nvoid mtk_gamma_stop(struct device *dev)\n{\n\tstruct mtk_disp_gamma *gamma = dev_get_drvdata(dev);\n\n\twritel_relaxed(0x0, gamma->regs + DISP_GAMMA_EN);\n}\n\nstatic int mtk_disp_gamma_bind(struct device *dev, struct device *master,\n\t\t\t       void *data)\n{\n\treturn 0;\n}\n\nstatic void mtk_disp_gamma_unbind(struct device *dev, struct device *master,\n\t\t\t\t  void *data)\n{\n}\n\nstatic const struct component_ops mtk_disp_gamma_component_ops = {\n\t.bind\t= mtk_disp_gamma_bind,\n\t.unbind = mtk_disp_gamma_unbind,\n};\n\nstatic int mtk_disp_gamma_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_disp_gamma *priv;\n\tstruct resource *res;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get gamma clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"failed to ioremap gamma\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);\n\tif (ret)\n\t\tdev_dbg(dev, \"get mediatek,gce-client-reg fail!\\n\");\n#endif\n\n\tpriv->data = of_device_get_match_data(dev);\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = component_add(dev, &mtk_disp_gamma_component_ops);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mtk_disp_gamma_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_disp_gamma_component_ops);\n}\n\nstatic const struct mtk_disp_gamma_data mt8173_gamma_driver_data = {\n\t.has_dither = true,\n};\n\nstatic const struct mtk_disp_gamma_data mt8183_gamma_driver_data = {\n\t.lut_diff = true,\n};\n\nstatic const struct of_device_id mtk_disp_gamma_driver_dt_match[] = {\n\t{ .compatible = \"mediatek,mt8173-disp-gamma\",\n\t  .data = &mt8173_gamma_driver_data},\n\t{ .compatible = \"mediatek,mt8183-disp-gamma\",\n\t  .data = &mt8183_gamma_driver_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_disp_gamma_driver_dt_match);\n\nstruct platform_driver mtk_disp_gamma_driver = {\n\t.probe\t\t= mtk_disp_gamma_probe,\n\t.remove_new\t= mtk_disp_gamma_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mediatek-disp-gamma\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.of_match_table = mtk_disp_gamma_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}