{
  "module_name": "mtk_ethdr.c",
  "hash_id": "acf145034204e6b52d4281a8e0eb7895129b90127435405b517afa1346817f1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_ethdr.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n#include <linux/soc/mediatek/mtk-mmsys.h>\n\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_ethdr.h\"\n\n#define MIX_INTEN\t\t\t0x4\n#define MIX_FME_CPL_INTEN\t\t\tBIT(1)\n#define MIX_INTSTA\t\t\t0x8\n#define MIX_EN\t\t\t\t0xc\n#define MIX_RST\t\t\t\t0x14\n#define MIX_ROI_SIZE\t\t\t0x18\n#define MIX_DATAPATH_CON\t\t0x1c\n#define OUTPUT_NO_RND\t\t\t\tBIT(3)\n#define SOURCE_RGB_SEL\t\t\t\tBIT(7)\n#define BACKGROUND_RELAY\t\t\t(4 << 9)\n#define MIX_ROI_BGCLR\t\t\t0x20\n#define BGCLR_BLACK\t\t\t\t0xff000000\n#define MIX_SRC_CON\t\t\t0x24\n#define MIX_SRC_L0_EN\t\t\t\tBIT(0)\n#define MIX_L_SRC_CON(n)\t\t(0x28 + 0x18 * (n))\n#define NON_PREMULTI_SOURCE\t\t\t(2 << 12)\n#define MIX_L_SRC_SIZE(n)\t\t(0x30 + 0x18 * (n))\n#define MIX_L_SRC_OFFSET(n)\t\t(0x34 + 0x18 * (n))\n#define MIX_FUNC_DCM0\t\t\t0x120\n#define MIX_FUNC_DCM1\t\t\t0x124\n#define MIX_FUNC_DCM_ENABLE\t\t\t0xffffffff\n\n#define HDR_VDO_FE_0804_HDR_DM_FE\t0x804\n#define HDR_VDO_FE_0804_BYPASS_ALL\t\t0xfd\n#define HDR_GFX_FE_0204_GFX_HDR_FE\t0x204\n#define HDR_GFX_FE_0204_BYPASS_ALL\t\t0xfd\n#define HDR_VDO_BE_0204_VDO_DM_BE\t0x204\n#define HDR_VDO_BE_0204_BYPASS_ALL\t\t0x7e\n\n#define MIXER_INX_MODE_BYPASS\t\t\t0\n#define MIXER_INX_MODE_EVEN_EXTEND\t\t1\n#define DEFAULT_9BIT_ALPHA\t\t\t0x100\n#define\tMIXER_ALPHA_AEN\t\t\t\tBIT(8)\n#define\tMIXER_ALPHA\t\t\t\t0xff\n#define ETHDR_CLK_NUM\t\t\t\t13\n\nenum mtk_ethdr_comp_id {\n\tETHDR_MIXER,\n\tETHDR_VDO_FE0,\n\tETHDR_VDO_FE1,\n\tETHDR_GFX_FE0,\n\tETHDR_GFX_FE1,\n\tETHDR_VDO_BE,\n\tETHDR_ADL_DS,\n\tETHDR_ID_MAX\n};\n\nstruct mtk_ethdr_comp {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*regs;\n\tstruct cmdq_client_reg\tcmdq_base;\n};\n\nstruct mtk_ethdr {\n\tstruct mtk_ethdr_comp\tethdr_comp[ETHDR_ID_MAX];\n\tstruct clk_bulk_data\tethdr_clk[ETHDR_CLK_NUM];\n\tstruct device\t\t*mmsys_dev;\n\tvoid\t\t\t(*vblank_cb)(void *data);\n\tvoid\t\t\t*vblank_cb_data;\n\tint\t\t\tirq;\n\tstruct reset_control\t*reset_ctl;\n};\n\nstatic const char * const ethdr_clk_str[] = {\n\t\"ethdr_top\",\n\t\"mixer\",\n\t\"vdo_fe0\",\n\t\"vdo_fe1\",\n\t\"gfx_fe0\",\n\t\"gfx_fe1\",\n\t\"vdo_be\",\n\t\"adl_ds\",\n\t\"vdo_fe0_async\",\n\t\"vdo_fe1_async\",\n\t\"gfx_fe0_async\",\n\t\"gfx_fe1_async\",\n\t\"vdo_be_async\",\n};\n\nvoid mtk_ethdr_register_vblank_cb(struct device *dev,\n\t\t\t\t  void (*vblank_cb)(void *),\n\t\t\t\t  void *vblank_cb_data)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\tpriv->vblank_cb = vblank_cb;\n\tpriv->vblank_cb_data = vblank_cb_data;\n}\n\nvoid mtk_ethdr_unregister_vblank_cb(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\tpriv->vblank_cb = NULL;\n\tpriv->vblank_cb_data = NULL;\n}\n\nvoid mtk_ethdr_enable_vblank(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\twritel(MIX_FME_CPL_INTEN, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTEN);\n}\n\nvoid mtk_ethdr_disable_vblank(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\twritel(0x0, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTEN);\n}\n\nstatic irqreturn_t mtk_ethdr_irq_handler(int irq, void *dev_id)\n{\n\tstruct mtk_ethdr *priv = dev_id;\n\n\twritel(0x0, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTSTA);\n\n\tif (!priv->vblank_cb)\n\t\treturn IRQ_NONE;\n\n\tpriv->vblank_cb(priv->vblank_cb_data);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid mtk_ethdr_layer_config(struct device *dev, unsigned int idx,\n\t\t\t    struct mtk_plane_state *state,\n\t\t\t    struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\tstruct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];\n\tstruct mtk_plane_pending_state *pending = &state->pending;\n\tunsigned int offset = (pending->x & 1) << 31 | pending->y << 16 | pending->x;\n\tunsigned int align_width = ALIGN_DOWN(pending->width, 2);\n\tunsigned int alpha_con = 0;\n\n\tdev_dbg(dev, \"%s+ idx:%d\", __func__, idx);\n\n\tif (idx >= 4)\n\t\treturn;\n\n\tif (!pending->enable) {\n\t\tmtk_ddp_write(cmdq_pkt, 0, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_SIZE(idx));\n\t\treturn;\n\t}\n\n\tif (state->base.fb && state->base.fb->format->has_alpha)\n\t\talpha_con = MIXER_ALPHA_AEN | MIXER_ALPHA;\n\n\tmtk_mmsys_mixer_in_config(priv->mmsys_dev, idx + 1, alpha_con ? false : true,\n\t\t\t\t  DEFAULT_9BIT_ALPHA,\n\t\t\t\t  pending->x & 1 ? MIXER_INX_MODE_EVEN_EXTEND :\n\t\t\t\t  MIXER_INX_MODE_BYPASS, align_width / 2 - 1, cmdq_pkt);\n\n\tmtk_ddp_write(cmdq_pkt, pending->height << 16 | align_width, &mixer->cmdq_base,\n\t\t      mixer->regs, MIX_L_SRC_SIZE(idx));\n\tmtk_ddp_write(cmdq_pkt, offset, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_OFFSET(idx));\n\tmtk_ddp_write_mask(cmdq_pkt, alpha_con, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_CON(idx),\n\t\t\t   0x1ff);\n\tmtk_ddp_write_mask(cmdq_pkt, BIT(idx), &mixer->cmdq_base, mixer->regs, MIX_SRC_CON,\n\t\t\t   BIT(idx));\n}\n\nvoid mtk_ethdr_config(struct device *dev, unsigned int w,\n\t\t      unsigned int h, unsigned int vrefresh,\n\t\t      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\tstruct mtk_ethdr_comp *vdo_fe0 = &priv->ethdr_comp[ETHDR_VDO_FE0];\n\tstruct mtk_ethdr_comp *vdo_fe1 = &priv->ethdr_comp[ETHDR_VDO_FE1];\n\tstruct mtk_ethdr_comp *gfx_fe0 = &priv->ethdr_comp[ETHDR_GFX_FE0];\n\tstruct mtk_ethdr_comp *gfx_fe1 = &priv->ethdr_comp[ETHDR_GFX_FE1];\n\tstruct mtk_ethdr_comp *vdo_be = &priv->ethdr_comp[ETHDR_VDO_BE];\n\tstruct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];\n\n\tdev_dbg(dev, \"%s-w:%d, h:%d\\n\", __func__, w, h);\n\n\tmtk_ddp_write(cmdq_pkt, HDR_VDO_FE_0804_BYPASS_ALL, &vdo_fe0->cmdq_base,\n\t\t      vdo_fe0->regs, HDR_VDO_FE_0804_HDR_DM_FE);\n\n\tmtk_ddp_write(cmdq_pkt, HDR_VDO_FE_0804_BYPASS_ALL, &vdo_fe1->cmdq_base,\n\t\t      vdo_fe1->regs, HDR_VDO_FE_0804_HDR_DM_FE);\n\n\tmtk_ddp_write(cmdq_pkt, HDR_GFX_FE_0204_BYPASS_ALL, &gfx_fe0->cmdq_base,\n\t\t      gfx_fe0->regs, HDR_GFX_FE_0204_GFX_HDR_FE);\n\n\tmtk_ddp_write(cmdq_pkt, HDR_GFX_FE_0204_BYPASS_ALL, &gfx_fe1->cmdq_base,\n\t\t      gfx_fe1->regs, HDR_GFX_FE_0204_GFX_HDR_FE);\n\n\tmtk_ddp_write(cmdq_pkt, HDR_VDO_BE_0204_BYPASS_ALL, &vdo_be->cmdq_base,\n\t\t      vdo_be->regs, HDR_VDO_BE_0204_VDO_DM_BE);\n\n\tmtk_ddp_write(cmdq_pkt, MIX_FUNC_DCM_ENABLE, &mixer->cmdq_base, mixer->regs, MIX_FUNC_DCM0);\n\tmtk_ddp_write(cmdq_pkt, MIX_FUNC_DCM_ENABLE, &mixer->cmdq_base, mixer->regs, MIX_FUNC_DCM1);\n\tmtk_ddp_write(cmdq_pkt, h << 16 | w, &mixer->cmdq_base, mixer->regs, MIX_ROI_SIZE);\n\tmtk_ddp_write(cmdq_pkt, BGCLR_BLACK, &mixer->cmdq_base, mixer->regs, MIX_ROI_BGCLR);\n\tmtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,\n\t\t      MIX_L_SRC_CON(0));\n\tmtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,\n\t\t      MIX_L_SRC_CON(1));\n\tmtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,\n\t\t      MIX_L_SRC_CON(2));\n\tmtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,\n\t\t      MIX_L_SRC_CON(3));\n\tmtk_ddp_write(cmdq_pkt, 0x0, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_SIZE(0));\n\tmtk_ddp_write(cmdq_pkt, OUTPUT_NO_RND | SOURCE_RGB_SEL | BACKGROUND_RELAY,\n\t\t      &mixer->cmdq_base, mixer->regs, MIX_DATAPATH_CON);\n\tmtk_ddp_write_mask(cmdq_pkt, MIX_SRC_L0_EN, &mixer->cmdq_base, mixer->regs,\n\t\t\t   MIX_SRC_CON, MIX_SRC_L0_EN);\n\n\tmtk_mmsys_hdr_config(priv->mmsys_dev, w / 2, h, cmdq_pkt);\n\tmtk_mmsys_mixer_in_channel_swap(priv->mmsys_dev, 4, 0, cmdq_pkt);\n}\n\nvoid mtk_ethdr_start(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\tstruct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];\n\n\twritel(1, mixer->regs + MIX_EN);\n}\n\nvoid mtk_ethdr_stop(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\tstruct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];\n\n\twritel(0, mixer->regs + MIX_EN);\n\twritel(1, mixer->regs + MIX_RST);\n\treset_control_reset(priv->reset_ctl);\n\twritel(0, mixer->regs + MIX_RST);\n}\n\nint mtk_ethdr_clk_enable(struct device *dev)\n{\n\tint ret;\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\tret = clk_bulk_prepare_enable(ETHDR_CLK_NUM, priv->ethdr_clk);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"ethdr_clk prepare enable failed\\n\");\n\treturn ret;\n}\n\nvoid mtk_ethdr_clk_disable(struct device *dev)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(ETHDR_CLK_NUM, priv->ethdr_clk);\n}\n\nstatic int mtk_ethdr_bind(struct device *dev, struct device *master,\n\t\t\t  void *data)\n{\n\tstruct mtk_ethdr *priv = dev_get_drvdata(dev);\n\n\tpriv->mmsys_dev = data;\n\treturn 0;\n}\n\nstatic void mtk_ethdr_unbind(struct device *dev, struct device *master, void *data)\n{\n}\n\nstatic const struct component_ops mtk_ethdr_component_ops = {\n\t.bind\t= mtk_ethdr_bind,\n\t.unbind = mtk_ethdr_unbind,\n};\n\nstatic int mtk_ethdr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_ethdr *priv;\n\tint ret;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ETHDR_ID_MAX; i++) {\n\t\tpriv->ethdr_comp[i].dev = dev;\n\t\tpriv->ethdr_comp[i].regs = of_iomap(dev->of_node, i);\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\t\tret = cmdq_dev_get_client_reg(dev,\n\t\t\t\t\t      &priv->ethdr_comp[i].cmdq_base, i);\n\t\tif (ret)\n\t\t\tdev_dbg(dev, \"get mediatek,gce-client-reg fail!\\n\");\n#endif\n\t\tdev_dbg(dev, \"[DRM]regs:0x%p, node:%d\\n\", priv->ethdr_comp[i].regs, i);\n\t}\n\n\tfor (i = 0; i < ETHDR_CLK_NUM; i++)\n\t\tpriv->ethdr_clk[i].id = ethdr_clk_str[i];\n\tret = devm_clk_bulk_get_optional(dev, ETHDR_CLK_NUM, priv->ethdr_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\tpriv->irq = 0;\n\n\tif (priv->irq) {\n\t\tret = devm_request_irq(dev, priv->irq, mtk_ethdr_irq_handler,\n\t\t\t\t       IRQF_TRIGGER_NONE, dev_name(dev), priv);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to request irq %d: %d\\n\", priv->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->reset_ctl = devm_reset_control_array_get_optional_exclusive(dev);\n\tif (IS_ERR(priv->reset_ctl)) {\n\t\tdev_err_probe(dev, PTR_ERR(priv->reset_ctl), \"cannot get ethdr reset control\\n\");\n\t\treturn PTR_ERR(priv->reset_ctl);\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = component_add(dev, &mtk_ethdr_component_ops);\n\tif (ret)\n\t\tdev_notice(dev, \"Failed to add component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int mtk_ethdr_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_ethdr_component_ops);\n\treturn 0;\n}\n\nstatic const struct of_device_id mtk_ethdr_driver_dt_match[] = {\n\t{ .compatible = \"mediatek,mt8195-disp-ethdr\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mtk_ethdr_driver_dt_match);\n\nstruct platform_driver mtk_ethdr_driver = {\n\t.probe\t\t= mtk_ethdr_probe,\n\t.remove\t\t= mtk_ethdr_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mediatek-disp-ethdr\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.of_match_table = mtk_ethdr_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}