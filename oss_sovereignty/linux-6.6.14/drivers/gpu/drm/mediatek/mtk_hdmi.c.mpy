{
  "module_name": "mtk_hdmi.c",
  "hash_id": "b7b2fbaed777ae20a80199a0be4a5e42c3b2d22c6d81c930055d54d70bf5a788",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <sound/hdmi-codec.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"mtk_cec.h\"\n#include \"mtk_hdmi.h\"\n#include \"mtk_hdmi_regs.h\"\n\n#define NCTS_BYTES\t7\n\nenum mtk_hdmi_clk_id {\n\tMTK_HDMI_CLK_HDMI_PIXEL,\n\tMTK_HDMI_CLK_HDMI_PLL,\n\tMTK_HDMI_CLK_AUD_BCLK,\n\tMTK_HDMI_CLK_AUD_SPDIF,\n\tMTK_HDMI_CLK_COUNT\n};\n\nenum hdmi_aud_input_type {\n\tHDMI_AUD_INPUT_I2S = 0,\n\tHDMI_AUD_INPUT_SPDIF,\n};\n\nenum hdmi_aud_i2s_fmt {\n\tHDMI_I2S_MODE_RJT_24BIT = 0,\n\tHDMI_I2S_MODE_RJT_16BIT,\n\tHDMI_I2S_MODE_LJT_24BIT,\n\tHDMI_I2S_MODE_LJT_16BIT,\n\tHDMI_I2S_MODE_I2S_24BIT,\n\tHDMI_I2S_MODE_I2S_16BIT\n};\n\nenum hdmi_aud_mclk {\n\tHDMI_AUD_MCLK_128FS,\n\tHDMI_AUD_MCLK_192FS,\n\tHDMI_AUD_MCLK_256FS,\n\tHDMI_AUD_MCLK_384FS,\n\tHDMI_AUD_MCLK_512FS,\n\tHDMI_AUD_MCLK_768FS,\n\tHDMI_AUD_MCLK_1152FS,\n};\n\nenum hdmi_aud_channel_type {\n\tHDMI_AUD_CHAN_TYPE_1_0 = 0,\n\tHDMI_AUD_CHAN_TYPE_1_1,\n\tHDMI_AUD_CHAN_TYPE_2_0,\n\tHDMI_AUD_CHAN_TYPE_2_1,\n\tHDMI_AUD_CHAN_TYPE_3_0,\n\tHDMI_AUD_CHAN_TYPE_3_1,\n\tHDMI_AUD_CHAN_TYPE_4_0,\n\tHDMI_AUD_CHAN_TYPE_4_1,\n\tHDMI_AUD_CHAN_TYPE_5_0,\n\tHDMI_AUD_CHAN_TYPE_5_1,\n\tHDMI_AUD_CHAN_TYPE_6_0,\n\tHDMI_AUD_CHAN_TYPE_6_1,\n\tHDMI_AUD_CHAN_TYPE_7_0,\n\tHDMI_AUD_CHAN_TYPE_7_1,\n\tHDMI_AUD_CHAN_TYPE_3_0_LRS,\n\tHDMI_AUD_CHAN_TYPE_3_1_LRS,\n\tHDMI_AUD_CHAN_TYPE_4_0_CLRS,\n\tHDMI_AUD_CHAN_TYPE_4_1_CLRS,\n\tHDMI_AUD_CHAN_TYPE_6_1_CS,\n\tHDMI_AUD_CHAN_TYPE_6_1_CH,\n\tHDMI_AUD_CHAN_TYPE_6_1_OH,\n\tHDMI_AUD_CHAN_TYPE_6_1_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_1_LH_RH,\n\tHDMI_AUD_CHAN_TYPE_7_1_LSR_RSR,\n\tHDMI_AUD_CHAN_TYPE_7_1_LC_RC,\n\tHDMI_AUD_CHAN_TYPE_7_1_LW_RW,\n\tHDMI_AUD_CHAN_TYPE_7_1_LSD_RSD,\n\tHDMI_AUD_CHAN_TYPE_7_1_LSS_RSS,\n\tHDMI_AUD_CHAN_TYPE_7_1_LHS_RHS,\n\tHDMI_AUD_CHAN_TYPE_7_1_CS_CH,\n\tHDMI_AUD_CHAN_TYPE_7_1_CS_OH,\n\tHDMI_AUD_CHAN_TYPE_7_1_CS_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_1_CH_OH,\n\tHDMI_AUD_CHAN_TYPE_7_1_CH_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_1_OH_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_1_LSS_RSS_LSR_RSR,\n\tHDMI_AUD_CHAN_TYPE_6_0_CS,\n\tHDMI_AUD_CHAN_TYPE_6_0_CH,\n\tHDMI_AUD_CHAN_TYPE_6_0_OH,\n\tHDMI_AUD_CHAN_TYPE_6_0_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_0_LH_RH,\n\tHDMI_AUD_CHAN_TYPE_7_0_LSR_RSR,\n\tHDMI_AUD_CHAN_TYPE_7_0_LC_RC,\n\tHDMI_AUD_CHAN_TYPE_7_0_LW_RW,\n\tHDMI_AUD_CHAN_TYPE_7_0_LSD_RSD,\n\tHDMI_AUD_CHAN_TYPE_7_0_LSS_RSS,\n\tHDMI_AUD_CHAN_TYPE_7_0_LHS_RHS,\n\tHDMI_AUD_CHAN_TYPE_7_0_CS_CH,\n\tHDMI_AUD_CHAN_TYPE_7_0_CS_OH,\n\tHDMI_AUD_CHAN_TYPE_7_0_CS_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_0_CH_OH,\n\tHDMI_AUD_CHAN_TYPE_7_0_CH_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_0_OH_CHR,\n\tHDMI_AUD_CHAN_TYPE_7_0_LSS_RSS_LSR_RSR,\n\tHDMI_AUD_CHAN_TYPE_8_0_LH_RH_CS,\n\tHDMI_AUD_CHAN_TYPE_UNKNOWN = 0xFF\n};\n\nenum hdmi_aud_channel_swap_type {\n\tHDMI_AUD_SWAP_LR,\n\tHDMI_AUD_SWAP_LFE_CC,\n\tHDMI_AUD_SWAP_LSRS,\n\tHDMI_AUD_SWAP_RLS_RRS,\n\tHDMI_AUD_SWAP_LR_STATUS,\n};\n\nstruct hdmi_audio_param {\n\tenum hdmi_audio_coding_type aud_codec;\n\tenum hdmi_audio_sample_size aud_sampe_size;\n\tenum hdmi_aud_input_type aud_input_type;\n\tenum hdmi_aud_i2s_fmt aud_i2s_fmt;\n\tenum hdmi_aud_mclk aud_mclk;\n\tenum hdmi_aud_channel_type aud_input_chan_type;\n\tstruct hdmi_codec_params codec_params;\n};\n\nstruct mtk_hdmi_conf {\n\tbool tz_disabled;\n\tbool cea_modes_only;\n\tunsigned long max_mode_clock;\n};\n\nstruct mtk_hdmi {\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *curr_conn; \n\tstruct device *dev;\n\tconst struct mtk_hdmi_conf *conf;\n\tstruct phy *phy;\n\tstruct device *cec_dev;\n\tstruct i2c_adapter *ddc_adpt;\n\tstruct clk *clk[MTK_HDMI_CLK_COUNT];\n\tstruct drm_display_mode mode;\n\tbool dvi_mode;\n\tu32 min_clock;\n\tu32 max_clock;\n\tu32 max_hdisplay;\n\tu32 max_vdisplay;\n\tu32 ibias;\n\tu32 ibias_up;\n\tstruct regmap *sys_regmap;\n\tunsigned int sys_offset;\n\tvoid __iomem *regs;\n\tenum hdmi_colorspace csp;\n\tstruct hdmi_audio_param aud_param;\n\tbool audio_enable;\n\tbool powered;\n\tbool enabled;\n\thdmi_codec_plugged_cb plugged_cb;\n\tstruct device *codec_dev;\n\tstruct mutex update_plugged_status_lock;\n};\n\nstatic inline struct mtk_hdmi *hdmi_ctx_from_bridge(struct drm_bridge *b)\n{\n\treturn container_of(b, struct mtk_hdmi, bridge);\n}\n\nstatic u32 mtk_hdmi_read(struct mtk_hdmi *hdmi, u32 offset)\n{\n\treturn readl(hdmi->regs + offset);\n}\n\nstatic void mtk_hdmi_write(struct mtk_hdmi *hdmi, u32 offset, u32 val)\n{\n\twritel(val, hdmi->regs + offset);\n}\n\nstatic void mtk_hdmi_clear_bits(struct mtk_hdmi *hdmi, u32 offset, u32 bits)\n{\n\tvoid __iomem *reg = hdmi->regs + offset;\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp &= ~bits;\n\twritel(tmp, reg);\n}\n\nstatic void mtk_hdmi_set_bits(struct mtk_hdmi *hdmi, u32 offset, u32 bits)\n{\n\tvoid __iomem *reg = hdmi->regs + offset;\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp |= bits;\n\twritel(tmp, reg);\n}\n\nstatic void mtk_hdmi_mask(struct mtk_hdmi *hdmi, u32 offset, u32 val, u32 mask)\n{\n\tvoid __iomem *reg = hdmi->regs + offset;\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp = (tmp & ~mask) | (val & mask);\n\twritel(tmp, reg);\n}\n\nstatic void mtk_hdmi_hw_vid_black(struct mtk_hdmi *hdmi, bool black)\n{\n\tmtk_hdmi_mask(hdmi, VIDEO_CFG_4, black ? GEN_RGB : NORMAL_PATH,\n\t\t      VIDEO_SOURCE_SEL);\n}\n\nstatic void mtk_hdmi_hw_make_reg_writable(struct mtk_hdmi *hdmi, bool enable)\n{\n\tstruct arm_smccc_res res;\n\n\t \n\tif (hdmi->conf && hdmi->conf->tz_disabled)\n\t\tregmap_update_bits(hdmi->sys_regmap,\n\t\t\t\t   hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t\t   0x80008005, enable ? 0x80000005 : 0x8000);\n\telse\n\t\tarm_smccc_smc(MTK_SIP_SET_AUTHORIZED_SECURE_REG, 0x14000904,\n\t\t\t      0x80000000, 0, 0, 0, 0, 0, &res);\n\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t   HDMI_PCLK_FREE_RUN, enable ? HDMI_PCLK_FREE_RUN : 0);\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG1C,\n\t\t\t   HDMI_ON | ANLG_ON, enable ? (HDMI_ON | ANLG_ON) : 0);\n}\n\nstatic void mtk_hdmi_hw_1p4_version_enable(struct mtk_hdmi *hdmi, bool enable)\n{\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t   HDMI2P0_EN, enable ? 0 : HDMI2P0_EN);\n}\n\nstatic void mtk_hdmi_hw_aud_mute(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_set_bits(hdmi, GRL_AUDIO_CFG, AUDIO_ZERO);\n}\n\nstatic void mtk_hdmi_hw_aud_unmute(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_clear_bits(hdmi, GRL_AUDIO_CFG, AUDIO_ZERO);\n}\n\nstatic void mtk_hdmi_hw_reset(struct mtk_hdmi *hdmi)\n{\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG1C,\n\t\t\t   HDMI_RST, HDMI_RST);\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG1C,\n\t\t\t   HDMI_RST, 0);\n\tmtk_hdmi_clear_bits(hdmi, GRL_CFG3, CFG3_CONTROL_PACKET_DELAY);\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG1C,\n\t\t\t   ANLG_ON, ANLG_ON);\n}\n\nstatic void mtk_hdmi_hw_enable_notice(struct mtk_hdmi *hdmi, bool enable_notice)\n{\n\tmtk_hdmi_mask(hdmi, GRL_CFG2, enable_notice ? CFG2_NOTICE_EN : 0,\n\t\t      CFG2_NOTICE_EN);\n}\n\nstatic void mtk_hdmi_hw_write_int_mask(struct mtk_hdmi *hdmi, u32 int_mask)\n{\n\tmtk_hdmi_write(hdmi, GRL_INT_MASK, int_mask);\n}\n\nstatic void mtk_hdmi_hw_enable_dvi_mode(struct mtk_hdmi *hdmi, bool enable)\n{\n\tmtk_hdmi_mask(hdmi, GRL_CFG1, enable ? CFG1_DVI : 0, CFG1_DVI);\n}\n\nstatic void mtk_hdmi_hw_send_info_frame(struct mtk_hdmi *hdmi, u8 *buffer,\n\t\t\t\t\tu8 len)\n{\n\tu32 ctrl_reg = GRL_CTRL;\n\tint i;\n\tu8 *frame_data;\n\tenum hdmi_infoframe_type frame_type;\n\tu8 frame_ver;\n\tu8 frame_len;\n\tu8 checksum;\n\tint ctrl_frame_en = 0;\n\n\tframe_type = *buffer++;\n\tframe_ver = *buffer++;\n\tframe_len = *buffer++;\n\tchecksum = *buffer++;\n\tframe_data = buffer;\n\n\tdev_dbg(hdmi->dev,\n\t\t\"frame_type:0x%x,frame_ver:0x%x,frame_len:0x%x,checksum:0x%x\\n\",\n\t\tframe_type, frame_ver, frame_len, checksum);\n\n\tswitch (frame_type) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tctrl_frame_en = CTRL_AVI_EN;\n\t\tctrl_reg = GRL_CTRL;\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_SPD:\n\t\tctrl_frame_en = CTRL_SPD_EN;\n\t\tctrl_reg = GRL_CTRL;\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\tctrl_frame_en = CTRL_AUDIO_EN;\n\t\tctrl_reg = GRL_CTRL;\n\t\tbreak;\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\tctrl_frame_en = VS_EN;\n\t\tctrl_reg = GRL_ACP_ISRC_CTRL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdmi->dev, \"Unknown infoframe type %d\\n\", frame_type);\n\t\treturn;\n\t}\n\tmtk_hdmi_clear_bits(hdmi, ctrl_reg, ctrl_frame_en);\n\tmtk_hdmi_write(hdmi, GRL_INFOFRM_TYPE, frame_type);\n\tmtk_hdmi_write(hdmi, GRL_INFOFRM_VER, frame_ver);\n\tmtk_hdmi_write(hdmi, GRL_INFOFRM_LNG, frame_len);\n\n\tmtk_hdmi_write(hdmi, GRL_IFM_PORT, checksum);\n\tfor (i = 0; i < frame_len; i++)\n\t\tmtk_hdmi_write(hdmi, GRL_IFM_PORT, frame_data[i]);\n\n\tmtk_hdmi_set_bits(hdmi, ctrl_reg, ctrl_frame_en);\n}\n\nstatic void mtk_hdmi_hw_send_aud_packet(struct mtk_hdmi *hdmi, bool enable)\n{\n\tmtk_hdmi_mask(hdmi, GRL_SHIFT_R2, enable ? 0 : AUDIO_PACKET_OFF,\n\t\t      AUDIO_PACKET_OFF);\n}\n\nstatic void mtk_hdmi_hw_config_sys(struct mtk_hdmi *hdmi)\n{\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t   HDMI_OUT_FIFO_EN | MHL_MODE_ON, 0);\n\tusleep_range(2000, 4000);\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t   HDMI_OUT_FIFO_EN | MHL_MODE_ON, HDMI_OUT_FIFO_EN);\n}\n\nstatic void mtk_hdmi_hw_set_deep_color_mode(struct mtk_hdmi *hdmi)\n{\n\tregmap_update_bits(hdmi->sys_regmap, hdmi->sys_offset + HDMI_SYS_CFG20,\n\t\t\t   DEEP_COLOR_MODE_MASK | DEEP_COLOR_EN,\n\t\t\t   COLOR_8BIT_MODE);\n}\n\nstatic void mtk_hdmi_hw_send_av_mute(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_clear_bits(hdmi, GRL_CFG4, CTRL_AVMUTE);\n\tusleep_range(2000, 4000);\n\tmtk_hdmi_set_bits(hdmi, GRL_CFG4, CTRL_AVMUTE);\n}\n\nstatic void mtk_hdmi_hw_send_av_unmute(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_mask(hdmi, GRL_CFG4, CFG4_AV_UNMUTE_EN,\n\t\t      CFG4_AV_UNMUTE_EN | CFG4_AV_UNMUTE_SET);\n\tusleep_range(2000, 4000);\n\tmtk_hdmi_mask(hdmi, GRL_CFG4, CFG4_AV_UNMUTE_SET,\n\t\t      CFG4_AV_UNMUTE_EN | CFG4_AV_UNMUTE_SET);\n}\n\nstatic void mtk_hdmi_hw_ncts_enable(struct mtk_hdmi *hdmi, bool on)\n{\n\tmtk_hdmi_mask(hdmi, GRL_CTS_CTRL, on ? 0 : CTS_CTRL_SOFT,\n\t\t      CTS_CTRL_SOFT);\n}\n\nstatic void mtk_hdmi_hw_ncts_auto_write_enable(struct mtk_hdmi *hdmi,\n\t\t\t\t\t       bool enable)\n{\n\tmtk_hdmi_mask(hdmi, GRL_CTS_CTRL, enable ? NCTS_WRI_ANYTIME : 0,\n\t\t      NCTS_WRI_ANYTIME);\n}\n\nstatic void mtk_hdmi_hw_msic_setting(struct mtk_hdmi *hdmi,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tmtk_hdmi_clear_bits(hdmi, GRL_CFG4, CFG4_MHL_MODE);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE &&\n\t    mode->clock == 74250 &&\n\t    mode->vdisplay == 1080)\n\t\tmtk_hdmi_clear_bits(hdmi, GRL_CFG2, CFG2_MHL_DE_SEL);\n\telse\n\t\tmtk_hdmi_set_bits(hdmi, GRL_CFG2, CFG2_MHL_DE_SEL);\n}\n\nstatic void mtk_hdmi_hw_aud_set_channel_swap(struct mtk_hdmi *hdmi,\n\t\t\t\t\tenum hdmi_aud_channel_swap_type swap)\n{\n\tu8 swap_bit;\n\n\tswitch (swap) {\n\tcase HDMI_AUD_SWAP_LR:\n\t\tswap_bit = LR_SWAP;\n\t\tbreak;\n\tcase HDMI_AUD_SWAP_LFE_CC:\n\t\tswap_bit = LFE_CC_SWAP;\n\t\tbreak;\n\tcase HDMI_AUD_SWAP_LSRS:\n\t\tswap_bit = LSRS_SWAP;\n\t\tbreak;\n\tcase HDMI_AUD_SWAP_RLS_RRS:\n\t\tswap_bit = RLS_RRS_SWAP;\n\t\tbreak;\n\tcase HDMI_AUD_SWAP_LR_STATUS:\n\t\tswap_bit = LR_STATUS_SWAP;\n\t\tbreak;\n\tdefault:\n\t\tswap_bit = LFE_CC_SWAP;\n\t\tbreak;\n\t}\n\tmtk_hdmi_mask(hdmi, GRL_CH_SWAP, swap_bit, 0xff);\n}\n\nstatic void mtk_hdmi_hw_aud_set_bit_num(struct mtk_hdmi *hdmi,\n\t\t\t\t\tenum hdmi_audio_sample_size bit_num)\n{\n\tu32 val;\n\n\tswitch (bit_num) {\n\tcase HDMI_AUDIO_SAMPLE_SIZE_16:\n\t\tval = AOUT_16BIT;\n\t\tbreak;\n\tcase HDMI_AUDIO_SAMPLE_SIZE_20:\n\t\tval = AOUT_20BIT;\n\t\tbreak;\n\tcase HDMI_AUDIO_SAMPLE_SIZE_24:\n\tcase HDMI_AUDIO_SAMPLE_SIZE_STREAM:\n\t\tval = AOUT_24BIT;\n\t\tbreak;\n\t}\n\n\tmtk_hdmi_mask(hdmi, GRL_AOUT_CFG, val, AOUT_BNUM_SEL_MASK);\n}\n\nstatic void mtk_hdmi_hw_aud_set_i2s_fmt(struct mtk_hdmi *hdmi,\n\t\t\t\t\tenum hdmi_aud_i2s_fmt i2s_fmt)\n{\n\tu32 val;\n\n\tval = mtk_hdmi_read(hdmi, GRL_CFG0);\n\tval &= ~(CFG0_W_LENGTH_MASK | CFG0_I2S_MODE_MASK);\n\n\tswitch (i2s_fmt) {\n\tcase HDMI_I2S_MODE_RJT_24BIT:\n\t\tval |= CFG0_I2S_MODE_RTJ | CFG0_W_LENGTH_24BIT;\n\t\tbreak;\n\tcase HDMI_I2S_MODE_RJT_16BIT:\n\t\tval |= CFG0_I2S_MODE_RTJ | CFG0_W_LENGTH_16BIT;\n\t\tbreak;\n\tcase HDMI_I2S_MODE_LJT_24BIT:\n\tdefault:\n\t\tval |= CFG0_I2S_MODE_LTJ | CFG0_W_LENGTH_24BIT;\n\t\tbreak;\n\tcase HDMI_I2S_MODE_LJT_16BIT:\n\t\tval |= CFG0_I2S_MODE_LTJ | CFG0_W_LENGTH_16BIT;\n\t\tbreak;\n\tcase HDMI_I2S_MODE_I2S_24BIT:\n\t\tval |= CFG0_I2S_MODE_I2S | CFG0_W_LENGTH_24BIT;\n\t\tbreak;\n\tcase HDMI_I2S_MODE_I2S_16BIT:\n\t\tval |= CFG0_I2S_MODE_I2S | CFG0_W_LENGTH_16BIT;\n\t\tbreak;\n\t}\n\tmtk_hdmi_write(hdmi, GRL_CFG0, val);\n}\n\nstatic void mtk_hdmi_hw_audio_config(struct mtk_hdmi *hdmi, bool dst)\n{\n\tconst u8 mask = HIGH_BIT_RATE | DST_NORMAL_DOUBLE | SACD_DST | DSD_SEL;\n\tu8 val;\n\n\t \n\tmtk_hdmi_clear_bits(hdmi, GRL_AOUT_CFG, HIGH_BIT_RATE_PACKET_ALIGN);\n\n\tif (dst)\n\t\tval = DST_NORMAL_DOUBLE | SACD_DST;\n\telse\n\t\tval = 0;\n\n\tmtk_hdmi_mask(hdmi, GRL_AUDIO_CFG, val, mask);\n}\n\nstatic void mtk_hdmi_hw_aud_set_i2s_chan_num(struct mtk_hdmi *hdmi,\n\t\t\t\t\tenum hdmi_aud_channel_type channel_type,\n\t\t\t\t\tu8 channel_count)\n{\n\tunsigned int ch_switch;\n\tu8 i2s_uv;\n\n\tch_switch = CH_SWITCH(7, 7) | CH_SWITCH(6, 6) |\n\t\t    CH_SWITCH(5, 5) | CH_SWITCH(4, 4) |\n\t\t    CH_SWITCH(3, 3) | CH_SWITCH(1, 2) |\n\t\t    CH_SWITCH(2, 1) | CH_SWITCH(0, 0);\n\n\tif (channel_count == 2) {\n\t\ti2s_uv = I2S_UV_CH_EN(0);\n\t} else if (channel_count == 3 || channel_count == 4) {\n\t\tif (channel_count == 4 &&\n\t\t    (channel_type == HDMI_AUD_CHAN_TYPE_3_0_LRS ||\n\t\t    channel_type == HDMI_AUD_CHAN_TYPE_4_0))\n\t\t\ti2s_uv = I2S_UV_CH_EN(2) | I2S_UV_CH_EN(0);\n\t\telse\n\t\t\ti2s_uv = I2S_UV_CH_EN(3) | I2S_UV_CH_EN(2);\n\t} else if (channel_count == 6 || channel_count == 5) {\n\t\tif (channel_count == 6 &&\n\t\t    channel_type != HDMI_AUD_CHAN_TYPE_5_1 &&\n\t\t    channel_type != HDMI_AUD_CHAN_TYPE_4_1_CLRS) {\n\t\t\ti2s_uv = I2S_UV_CH_EN(3) | I2S_UV_CH_EN(2) |\n\t\t\t\t I2S_UV_CH_EN(1) | I2S_UV_CH_EN(0);\n\t\t} else {\n\t\t\ti2s_uv = I2S_UV_CH_EN(2) | I2S_UV_CH_EN(1) |\n\t\t\t\t I2S_UV_CH_EN(0);\n\t\t}\n\t} else if (channel_count == 8 || channel_count == 7) {\n\t\ti2s_uv = I2S_UV_CH_EN(3) | I2S_UV_CH_EN(2) |\n\t\t\t I2S_UV_CH_EN(1) | I2S_UV_CH_EN(0);\n\t} else {\n\t\ti2s_uv = I2S_UV_CH_EN(0);\n\t}\n\n\tmtk_hdmi_write(hdmi, GRL_CH_SW0, ch_switch & 0xff);\n\tmtk_hdmi_write(hdmi, GRL_CH_SW1, (ch_switch >> 8) & 0xff);\n\tmtk_hdmi_write(hdmi, GRL_CH_SW2, (ch_switch >> 16) & 0xff);\n\tmtk_hdmi_write(hdmi, GRL_I2S_UV, i2s_uv);\n}\n\nstatic void mtk_hdmi_hw_aud_set_input_type(struct mtk_hdmi *hdmi,\n\t\t\t\t\t   enum hdmi_aud_input_type input_type)\n{\n\tu32 val;\n\n\tval = mtk_hdmi_read(hdmi, GRL_CFG1);\n\tif (input_type == HDMI_AUD_INPUT_I2S &&\n\t    (val & CFG1_SPDIF) == CFG1_SPDIF) {\n\t\tval &= ~CFG1_SPDIF;\n\t} else if (input_type == HDMI_AUD_INPUT_SPDIF &&\n\t\t(val & CFG1_SPDIF) == 0) {\n\t\tval |= CFG1_SPDIF;\n\t}\n\tmtk_hdmi_write(hdmi, GRL_CFG1, val);\n}\n\nstatic void mtk_hdmi_hw_aud_set_channel_status(struct mtk_hdmi *hdmi,\n\t\t\t\t\t       u8 *channel_status)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tmtk_hdmi_write(hdmi, GRL_I2S_C_STA0 + i * 4, channel_status[i]);\n\t\tmtk_hdmi_write(hdmi, GRL_L_STATUS_0 + i * 4, channel_status[i]);\n\t\tmtk_hdmi_write(hdmi, GRL_R_STATUS_0 + i * 4, channel_status[i]);\n\t}\n\tfor (; i < 24; i++) {\n\t\tmtk_hdmi_write(hdmi, GRL_L_STATUS_0 + i * 4, 0);\n\t\tmtk_hdmi_write(hdmi, GRL_R_STATUS_0 + i * 4, 0);\n\t}\n}\n\nstatic void mtk_hdmi_hw_aud_src_reenable(struct mtk_hdmi *hdmi)\n{\n\tu32 val;\n\n\tval = mtk_hdmi_read(hdmi, GRL_MIX_CTRL);\n\tif (val & MIX_CTRL_SRC_EN) {\n\t\tval &= ~MIX_CTRL_SRC_EN;\n\t\tmtk_hdmi_write(hdmi, GRL_MIX_CTRL, val);\n\t\tusleep_range(255, 512);\n\t\tval |= MIX_CTRL_SRC_EN;\n\t\tmtk_hdmi_write(hdmi, GRL_MIX_CTRL, val);\n\t}\n}\n\nstatic void mtk_hdmi_hw_aud_src_disable(struct mtk_hdmi *hdmi)\n{\n\tu32 val;\n\n\tval = mtk_hdmi_read(hdmi, GRL_MIX_CTRL);\n\tval &= ~MIX_CTRL_SRC_EN;\n\tmtk_hdmi_write(hdmi, GRL_MIX_CTRL, val);\n\tmtk_hdmi_write(hdmi, GRL_SHIFT_L1, 0x00);\n}\n\nstatic void mtk_hdmi_hw_aud_set_mclk(struct mtk_hdmi *hdmi,\n\t\t\t\t     enum hdmi_aud_mclk mclk)\n{\n\tu32 val;\n\n\tval = mtk_hdmi_read(hdmi, GRL_CFG5);\n\tval &= CFG5_CD_RATIO_MASK;\n\n\tswitch (mclk) {\n\tcase HDMI_AUD_MCLK_128FS:\n\t\tval |= CFG5_FS128;\n\t\tbreak;\n\tcase HDMI_AUD_MCLK_256FS:\n\t\tval |= CFG5_FS256;\n\t\tbreak;\n\tcase HDMI_AUD_MCLK_384FS:\n\t\tval |= CFG5_FS384;\n\t\tbreak;\n\tcase HDMI_AUD_MCLK_512FS:\n\t\tval |= CFG5_FS512;\n\t\tbreak;\n\tcase HDMI_AUD_MCLK_768FS:\n\t\tval |= CFG5_FS768;\n\t\tbreak;\n\tdefault:\n\t\tval |= CFG5_FS256;\n\t\tbreak;\n\t}\n\tmtk_hdmi_write(hdmi, GRL_CFG5, val);\n}\n\nstruct hdmi_acr_n {\n\tunsigned int clock;\n\tunsigned int n[3];\n};\n\n \nstatic const struct hdmi_acr_n hdmi_rec_n_table[] = {\n\t \n\t{  25175, {  4576,  7007,  6864 } },\n\t{  74176, { 11648, 17836, 11648 } },\n\t{ 148352, { 11648,  8918,  5824 } },\n\t{ 296703, {  5824,  4459,  5824 } },\n\t{ 297000, {  3072,  4704,  5120 } },\n\t{      0, {  4096,  6272,  6144 } },  \n};\n\n \nstatic unsigned int hdmi_recommended_n(unsigned int freq, unsigned int clock)\n{\n\tconst struct hdmi_acr_n *recommended;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_rec_n_table) - 1; i++) {\n\t\tif (clock == hdmi_rec_n_table[i].clock)\n\t\t\tbreak;\n\t}\n\trecommended = hdmi_rec_n_table + i;\n\n\tswitch (freq) {\n\tcase 32000:\n\t\treturn recommended->n[0];\n\tcase 44100:\n\t\treturn recommended->n[1];\n\tcase 48000:\n\t\treturn recommended->n[2];\n\tcase 88200:\n\t\treturn recommended->n[1] * 2;\n\tcase 96000:\n\t\treturn recommended->n[2] * 2;\n\tcase 176400:\n\t\treturn recommended->n[1] * 4;\n\tcase 192000:\n\t\treturn recommended->n[2] * 4;\n\tdefault:\n\t\treturn (128 * freq) / 1000;\n\t}\n}\n\nstatic unsigned int hdmi_mode_clock_to_hz(unsigned int clock)\n{\n\tswitch (clock) {\n\tcase 25175:\n\t\treturn 25174825;\t \n\tcase 74176:\n\t\treturn 74175824;\t \n\tcase 148352:\n\t\treturn 148351648;\t \n\tcase 296703:\n\t\treturn 296703297;\t \n\tdefault:\n\t\treturn clock * 1000;\n\t}\n}\n\nstatic unsigned int hdmi_expected_cts(unsigned int audio_sample_rate,\n\t\t\t\t      unsigned int tmds_clock, unsigned int n)\n{\n\treturn DIV_ROUND_CLOSEST_ULL((u64)hdmi_mode_clock_to_hz(tmds_clock) * n,\n\t\t\t\t     128 * audio_sample_rate);\n}\n\nstatic void do_hdmi_hw_aud_set_ncts(struct mtk_hdmi *hdmi, unsigned int n,\n\t\t\t\t    unsigned int cts)\n{\n\tunsigned char val[NCTS_BYTES];\n\tint i;\n\n\tmtk_hdmi_write(hdmi, GRL_NCTS, 0);\n\tmtk_hdmi_write(hdmi, GRL_NCTS, 0);\n\tmtk_hdmi_write(hdmi, GRL_NCTS, 0);\n\tmemset(val, 0, sizeof(val));\n\n\tval[0] = (cts >> 24) & 0xff;\n\tval[1] = (cts >> 16) & 0xff;\n\tval[2] = (cts >> 8) & 0xff;\n\tval[3] = cts & 0xff;\n\n\tval[4] = (n >> 16) & 0xff;\n\tval[5] = (n >> 8) & 0xff;\n\tval[6] = n & 0xff;\n\n\tfor (i = 0; i < NCTS_BYTES; i++)\n\t\tmtk_hdmi_write(hdmi, GRL_NCTS, val[i]);\n}\n\nstatic void mtk_hdmi_hw_aud_set_ncts(struct mtk_hdmi *hdmi,\n\t\t\t\t     unsigned int sample_rate,\n\t\t\t\t     unsigned int clock)\n{\n\tunsigned int n, cts;\n\n\tn = hdmi_recommended_n(sample_rate, clock);\n\tcts = hdmi_expected_cts(sample_rate, clock, n);\n\n\tdev_dbg(hdmi->dev, \"%s: sample_rate=%u, clock=%d, cts=%u, n=%u\\n\",\n\t\t__func__, sample_rate, clock, n, cts);\n\n\tmtk_hdmi_mask(hdmi, DUMMY_304, AUDIO_I2S_NCTS_SEL_64,\n\t\t      AUDIO_I2S_NCTS_SEL);\n\tdo_hdmi_hw_aud_set_ncts(hdmi, n, cts);\n}\n\nstatic u8 mtk_hdmi_aud_get_chnl_count(enum hdmi_aud_channel_type channel_type)\n{\n\tswitch (channel_type) {\n\tcase HDMI_AUD_CHAN_TYPE_1_0:\n\tcase HDMI_AUD_CHAN_TYPE_1_1:\n\tcase HDMI_AUD_CHAN_TYPE_2_0:\n\t\treturn 2;\n\tcase HDMI_AUD_CHAN_TYPE_2_1:\n\tcase HDMI_AUD_CHAN_TYPE_3_0:\n\t\treturn 3;\n\tcase HDMI_AUD_CHAN_TYPE_3_1:\n\tcase HDMI_AUD_CHAN_TYPE_4_0:\n\tcase HDMI_AUD_CHAN_TYPE_3_0_LRS:\n\t\treturn 4;\n\tcase HDMI_AUD_CHAN_TYPE_4_1:\n\tcase HDMI_AUD_CHAN_TYPE_5_0:\n\tcase HDMI_AUD_CHAN_TYPE_3_1_LRS:\n\tcase HDMI_AUD_CHAN_TYPE_4_0_CLRS:\n\t\treturn 5;\n\tcase HDMI_AUD_CHAN_TYPE_5_1:\n\tcase HDMI_AUD_CHAN_TYPE_6_0:\n\tcase HDMI_AUD_CHAN_TYPE_4_1_CLRS:\n\tcase HDMI_AUD_CHAN_TYPE_6_0_CS:\n\tcase HDMI_AUD_CHAN_TYPE_6_0_CH:\n\tcase HDMI_AUD_CHAN_TYPE_6_0_OH:\n\tcase HDMI_AUD_CHAN_TYPE_6_0_CHR:\n\t\treturn 6;\n\tcase HDMI_AUD_CHAN_TYPE_6_1:\n\tcase HDMI_AUD_CHAN_TYPE_6_1_CS:\n\tcase HDMI_AUD_CHAN_TYPE_6_1_CH:\n\tcase HDMI_AUD_CHAN_TYPE_6_1_OH:\n\tcase HDMI_AUD_CHAN_TYPE_6_1_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_0:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LH_RH:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LSR_RSR:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LC_RC:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LW_RW:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LSD_RSD:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LHS_RHS:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_CS_CH:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_CS_OH:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_CS_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_CH_OH:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_CH_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_OH_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS_LSR_RSR:\n\tcase HDMI_AUD_CHAN_TYPE_8_0_LH_RH_CS:\n\t\treturn 7;\n\tcase HDMI_AUD_CHAN_TYPE_7_1:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LH_RH:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LSR_RSR:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LC_RC:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LW_RW:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LSD_RSD:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LHS_RHS:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_CS_CH:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_CS_OH:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_CS_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_CH_OH:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_CH_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_OH_CHR:\n\tcase HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS_LSR_RSR:\n\t\treturn 8;\n\tdefault:\n\t\treturn 2;\n\t}\n}\n\nstatic int mtk_hdmi_video_change_vpll(struct mtk_hdmi *hdmi, u32 clock)\n{\n\tunsigned long rate;\n\tint ret;\n\n\t \n\tret = clk_set_rate(hdmi->clk[MTK_HDMI_CLK_HDMI_PLL], clock);\n\tif (ret) {\n\t\tdev_err(hdmi->dev, \"Failed to set PLL to %u Hz: %d\\n\", clock,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trate = clk_get_rate(hdmi->clk[MTK_HDMI_CLK_HDMI_PLL]);\n\n\tif (DIV_ROUND_CLOSEST(rate, 1000) != DIV_ROUND_CLOSEST(clock, 1000))\n\t\tdev_warn(hdmi->dev, \"Want PLL %u Hz, got %lu Hz\\n\", clock,\n\t\t\t rate);\n\telse\n\t\tdev_dbg(hdmi->dev, \"Want PLL %u Hz, got %lu Hz\\n\", clock, rate);\n\n\tmtk_hdmi_hw_config_sys(hdmi);\n\tmtk_hdmi_hw_set_deep_color_mode(hdmi);\n\treturn 0;\n}\n\nstatic void mtk_hdmi_video_set_display_mode(struct mtk_hdmi *hdmi,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tmtk_hdmi_hw_reset(hdmi);\n\tmtk_hdmi_hw_enable_notice(hdmi, true);\n\tmtk_hdmi_hw_write_int_mask(hdmi, 0xff);\n\tmtk_hdmi_hw_enable_dvi_mode(hdmi, hdmi->dvi_mode);\n\tmtk_hdmi_hw_ncts_auto_write_enable(hdmi, true);\n\n\tmtk_hdmi_hw_msic_setting(hdmi, mode);\n}\n\n\nstatic void mtk_hdmi_aud_set_input(struct mtk_hdmi *hdmi)\n{\n\tenum hdmi_aud_channel_type chan_type;\n\tu8 chan_count;\n\tbool dst;\n\n\tmtk_hdmi_hw_aud_set_channel_swap(hdmi, HDMI_AUD_SWAP_LFE_CC);\n\tmtk_hdmi_set_bits(hdmi, GRL_MIX_CTRL, MIX_CTRL_FLAT);\n\n\tif (hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_SPDIF &&\n\t    hdmi->aud_param.aud_codec == HDMI_AUDIO_CODING_TYPE_DST) {\n\t\tmtk_hdmi_hw_aud_set_bit_num(hdmi, HDMI_AUDIO_SAMPLE_SIZE_24);\n\t} else if (hdmi->aud_param.aud_i2s_fmt == HDMI_I2S_MODE_LJT_24BIT) {\n\t\thdmi->aud_param.aud_i2s_fmt = HDMI_I2S_MODE_LJT_16BIT;\n\t}\n\n\tmtk_hdmi_hw_aud_set_i2s_fmt(hdmi, hdmi->aud_param.aud_i2s_fmt);\n\tmtk_hdmi_hw_aud_set_bit_num(hdmi, HDMI_AUDIO_SAMPLE_SIZE_24);\n\n\tdst = ((hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_SPDIF) &&\n\t       (hdmi->aud_param.aud_codec == HDMI_AUDIO_CODING_TYPE_DST));\n\tmtk_hdmi_hw_audio_config(hdmi, dst);\n\n\tif (hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_SPDIF)\n\t\tchan_type = HDMI_AUD_CHAN_TYPE_2_0;\n\telse\n\t\tchan_type = hdmi->aud_param.aud_input_chan_type;\n\tchan_count = mtk_hdmi_aud_get_chnl_count(chan_type);\n\tmtk_hdmi_hw_aud_set_i2s_chan_num(hdmi, chan_type, chan_count);\n\tmtk_hdmi_hw_aud_set_input_type(hdmi, hdmi->aud_param.aud_input_type);\n}\n\nstatic int mtk_hdmi_aud_set_src(struct mtk_hdmi *hdmi,\n\t\t\t\tstruct drm_display_mode *display_mode)\n{\n\tunsigned int sample_rate = hdmi->aud_param.codec_params.sample_rate;\n\n\tmtk_hdmi_hw_ncts_enable(hdmi, false);\n\tmtk_hdmi_hw_aud_src_disable(hdmi);\n\tmtk_hdmi_clear_bits(hdmi, GRL_CFG2, CFG2_ACLK_INV);\n\n\tif (hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_I2S) {\n\t\tswitch (sample_rate) {\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\tcase 88200:\n\t\tcase 96000:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmtk_hdmi_hw_aud_set_mclk(hdmi, hdmi->aud_param.aud_mclk);\n\t} else {\n\t\tswitch (sample_rate) {\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmtk_hdmi_hw_aud_set_mclk(hdmi, HDMI_AUD_MCLK_128FS);\n\t}\n\n\tmtk_hdmi_hw_aud_set_ncts(hdmi, sample_rate, display_mode->clock);\n\n\tmtk_hdmi_hw_aud_src_reenable(hdmi);\n\treturn 0;\n}\n\nstatic int mtk_hdmi_aud_output_config(struct mtk_hdmi *hdmi,\n\t\t\t\t      struct drm_display_mode *display_mode)\n{\n\tmtk_hdmi_hw_aud_mute(hdmi);\n\tmtk_hdmi_hw_send_aud_packet(hdmi, false);\n\n\tmtk_hdmi_aud_set_input(hdmi);\n\tmtk_hdmi_aud_set_src(hdmi, display_mode);\n\tmtk_hdmi_hw_aud_set_channel_status(hdmi,\n\t\t\thdmi->aud_param.codec_params.iec.status);\n\n\tusleep_range(50, 100);\n\n\tmtk_hdmi_hw_ncts_enable(hdmi, true);\n\tmtk_hdmi_hw_send_aud_packet(hdmi, true);\n\tmtk_hdmi_hw_aud_unmute(hdmi);\n\treturn 0;\n}\n\nstatic int mtk_hdmi_setup_avi_infoframe(struct mtk_hdmi *hdmi,\n\t\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct hdmi_avi_infoframe frame;\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\n\tssize_t err;\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       hdmi->curr_conn, mode);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev,\n\t\t\t\"Failed to get AVI infoframe from mode: %zd\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack AVI infoframe: %zd\\n\", err);\n\t\treturn err;\n\t}\n\n\tmtk_hdmi_hw_send_info_frame(hdmi, buffer, sizeof(buffer));\n\treturn 0;\n}\n\nstatic int mtk_hdmi_setup_spd_infoframe(struct mtk_hdmi *hdmi,\n\t\t\t\t\tconst char *vendor,\n\t\t\t\t\tconst char *product)\n{\n\tstruct hdmi_spd_infoframe frame;\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_SPD_INFOFRAME_SIZE];\n\tssize_t err;\n\n\terr = hdmi_spd_infoframe_init(&frame, vendor, product);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to initialize SPD infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = hdmi_spd_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack SDP infoframe: %zd\\n\", err);\n\t\treturn err;\n\t}\n\n\tmtk_hdmi_hw_send_info_frame(hdmi, buffer, sizeof(buffer));\n\treturn 0;\n}\n\nstatic int mtk_hdmi_setup_audio_infoframe(struct mtk_hdmi *hdmi)\n{\n\tstruct hdmi_audio_infoframe frame;\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\n\tssize_t err;\n\n\terr = hdmi_audio_infoframe_init(&frame);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to setup audio infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tframe.coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;\n\tframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;\n\tframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;\n\tframe.channels = mtk_hdmi_aud_get_chnl_count(\n\t\t\t\t\thdmi->aud_param.aud_input_chan_type);\n\n\terr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack audio infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tmtk_hdmi_hw_send_info_frame(hdmi, buffer, sizeof(buffer));\n\treturn 0;\n}\n\nstatic int mtk_hdmi_setup_vendor_specific_infoframe(struct mtk_hdmi *hdmi,\n\t\t\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct hdmi_vendor_infoframe frame;\n\tu8 buffer[10];\n\tssize_t err;\n\n\terr = drm_hdmi_vendor_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t\t  hdmi->curr_conn, mode);\n\tif (err) {\n\t\tdev_err(hdmi->dev,\n\t\t\t\"Failed to get vendor infoframe from mode: %zd\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"Failed to pack vendor infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tmtk_hdmi_hw_send_info_frame(hdmi, buffer, sizeof(buffer));\n\treturn 0;\n}\n\nstatic int mtk_hdmi_output_init(struct mtk_hdmi *hdmi)\n{\n\tstruct hdmi_audio_param *aud_param = &hdmi->aud_param;\n\n\thdmi->csp = HDMI_COLORSPACE_RGB;\n\taud_param->aud_codec = HDMI_AUDIO_CODING_TYPE_PCM;\n\taud_param->aud_sampe_size = HDMI_AUDIO_SAMPLE_SIZE_16;\n\taud_param->aud_input_type = HDMI_AUD_INPUT_I2S;\n\taud_param->aud_i2s_fmt = HDMI_I2S_MODE_I2S_24BIT;\n\taud_param->aud_mclk = HDMI_AUD_MCLK_128FS;\n\taud_param->aud_input_chan_type = HDMI_AUD_CHAN_TYPE_2_0;\n\n\treturn 0;\n}\n\nstatic void mtk_hdmi_audio_enable(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_hw_send_aud_packet(hdmi, true);\n\thdmi->audio_enable = true;\n}\n\nstatic void mtk_hdmi_audio_disable(struct mtk_hdmi *hdmi)\n{\n\tmtk_hdmi_hw_send_aud_packet(hdmi, false);\n\thdmi->audio_enable = false;\n}\n\nstatic int mtk_hdmi_audio_set_param(struct mtk_hdmi *hdmi,\n\t\t\t\t    struct hdmi_audio_param *param)\n{\n\tif (!hdmi->audio_enable) {\n\t\tdev_err(hdmi->dev, \"hdmi audio is in disable state!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(hdmi->dev, \"codec:%d, input:%d, channel:%d, fs:%d\\n\",\n\t\tparam->aud_codec, param->aud_input_type,\n\t\tparam->aud_input_chan_type, param->codec_params.sample_rate);\n\tmemcpy(&hdmi->aud_param, param, sizeof(*param));\n\treturn mtk_hdmi_aud_output_config(hdmi, &hdmi->mode);\n}\n\nstatic int mtk_hdmi_output_set_display_mode(struct mtk_hdmi *hdmi,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tint ret;\n\n\tmtk_hdmi_hw_vid_black(hdmi, true);\n\tmtk_hdmi_hw_aud_mute(hdmi);\n\tmtk_hdmi_hw_send_av_mute(hdmi);\n\tphy_power_off(hdmi->phy);\n\n\tret = mtk_hdmi_video_change_vpll(hdmi,\n\t\t\t\t\t mode->clock * 1000);\n\tif (ret) {\n\t\tdev_err(hdmi->dev, \"Failed to set vpll: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmtk_hdmi_video_set_display_mode(hdmi, mode);\n\n\tphy_power_on(hdmi->phy);\n\tmtk_hdmi_aud_output_config(hdmi, mode);\n\n\tmtk_hdmi_hw_vid_black(hdmi, false);\n\tmtk_hdmi_hw_aud_unmute(hdmi);\n\tmtk_hdmi_hw_send_av_unmute(hdmi);\n\n\treturn 0;\n}\n\nstatic const char * const mtk_hdmi_clk_names[MTK_HDMI_CLK_COUNT] = {\n\t[MTK_HDMI_CLK_HDMI_PIXEL] = \"pixel\",\n\t[MTK_HDMI_CLK_HDMI_PLL] = \"pll\",\n\t[MTK_HDMI_CLK_AUD_BCLK] = \"bclk\",\n\t[MTK_HDMI_CLK_AUD_SPDIF] = \"spdif\",\n};\n\nstatic int mtk_hdmi_get_all_clk(struct mtk_hdmi *hdmi,\n\t\t\t\tstruct device_node *np)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtk_hdmi_clk_names); i++) {\n\t\thdmi->clk[i] = of_clk_get_by_name(np,\n\t\t\t\t\t\t  mtk_hdmi_clk_names[i]);\n\t\tif (IS_ERR(hdmi->clk[i]))\n\t\t\treturn PTR_ERR(hdmi->clk[i]);\n\t}\n\treturn 0;\n}\n\nstatic int mtk_hdmi_clk_enable_audio(struct mtk_hdmi *hdmi)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(hdmi->clk[MTK_HDMI_CLK_AUD_BCLK]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(hdmi->clk[MTK_HDMI_CLK_AUD_SPDIF]);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tclk_disable_unprepare(hdmi->clk[MTK_HDMI_CLK_AUD_BCLK]);\n\treturn ret;\n}\n\nstatic void mtk_hdmi_clk_disable_audio(struct mtk_hdmi *hdmi)\n{\n\tclk_disable_unprepare(hdmi->clk[MTK_HDMI_CLK_AUD_BCLK]);\n\tclk_disable_unprepare(hdmi->clk[MTK_HDMI_CLK_AUD_SPDIF]);\n}\n\nstatic enum drm_connector_status\nmtk_hdmi_update_plugged_status(struct mtk_hdmi *hdmi)\n{\n\tbool connected;\n\n\tmutex_lock(&hdmi->update_plugged_status_lock);\n\tconnected = mtk_cec_hpd_high(hdmi->cec_dev);\n\tif (hdmi->plugged_cb && hdmi->codec_dev)\n\t\thdmi->plugged_cb(hdmi->codec_dev, connected);\n\tmutex_unlock(&hdmi->update_plugged_status_lock);\n\n\treturn connected ?\n\t       connector_status_connected : connector_status_disconnected;\n}\n\nstatic enum drm_connector_status mtk_hdmi_detect(struct mtk_hdmi *hdmi)\n{\n\treturn mtk_hdmi_update_plugged_status(hdmi);\n}\n\nstatic enum drm_mode_status\nmtk_hdmi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_info *info,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\tstruct drm_bridge *next_bridge;\n\n\tdev_dbg(hdmi->dev, \"xres=%d, yres=%d, refresh=%d, intl=%d clock=%d\\n\",\n\t\tmode->hdisplay, mode->vdisplay, drm_mode_vrefresh(mode),\n\t\t!!(mode->flags & DRM_MODE_FLAG_INTERLACE), mode->clock * 1000);\n\n\tnext_bridge = drm_bridge_get_next_bridge(&hdmi->bridge);\n\tif (next_bridge) {\n\t\tstruct drm_display_mode adjusted_mode;\n\n\t\tdrm_mode_init(&adjusted_mode, mode);\n\t\tif (!drm_bridge_chain_mode_fixup(next_bridge, mode,\n\t\t\t\t\t\t &adjusted_mode))\n\t\t\treturn MODE_BAD;\n\t}\n\n\tif (hdmi->conf) {\n\t\tif (hdmi->conf->cea_modes_only && !drm_match_cea_mode(mode))\n\t\t\treturn MODE_BAD;\n\n\t\tif (hdmi->conf->max_mode_clock &&\n\t\t    mode->clock > hdmi->conf->max_mode_clock)\n\t\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\tif (mode->clock < 27000)\n\t\treturn MODE_CLOCK_LOW;\n\tif (mode->clock > 297000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn drm_mode_validate_size(mode, 0x1fff, 0x1fff);\n}\n\nstatic void mtk_hdmi_hpd_event(bool hpd, struct device *dev)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tif (hdmi && hdmi->bridge.encoder && hdmi->bridge.encoder->dev) {\n\t\tstatic enum drm_connector_status status;\n\n\t\tstatus = mtk_hdmi_detect(hdmi);\n\t\tdrm_helper_hpd_irq_event(hdmi->bridge.encoder->dev);\n\t\tdrm_bridge_hpd_notify(&hdmi->bridge, status);\n\t}\n}\n\n \n\nstatic enum drm_connector_status mtk_hdmi_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\treturn mtk_hdmi_detect(hdmi);\n}\n\nstatic struct edid *mtk_hdmi_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\tstruct edid *edid;\n\n\tif (!hdmi->ddc_adpt)\n\t\treturn NULL;\n\tedid = drm_get_edid(connector, hdmi->ddc_adpt);\n\tif (!edid)\n\t\treturn NULL;\n\thdmi->dvi_mode = !drm_detect_monitor_audio(edid);\n\treturn edid;\n}\n\nstatic int mtk_hdmi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_ERROR(\"%s: The flag DRM_BRIDGE_ATTACH_NO_CONNECTOR must be supplied\\n\",\n\t\t\t  __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdmi->next_bridge) {\n\t\tret = drm_bridge_attach(bridge->encoder, hdmi->next_bridge,\n\t\t\t\t\tbridge, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmtk_cec_set_hpd_event(hdmi->cec_dev, mtk_hdmi_hpd_event, hdmi->dev);\n\n\treturn 0;\n}\n\nstatic bool mtk_hdmi_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t       const struct drm_display_mode *mode,\n\t\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\treturn true;\n}\n\nstatic void mtk_hdmi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\tif (!hdmi->enabled)\n\t\treturn;\n\n\tphy_power_off(hdmi->phy);\n\tclk_disable_unprepare(hdmi->clk[MTK_HDMI_CLK_HDMI_PIXEL]);\n\tclk_disable_unprepare(hdmi->clk[MTK_HDMI_CLK_HDMI_PLL]);\n\n\thdmi->curr_conn = NULL;\n\n\thdmi->enabled = false;\n}\n\nstatic void mtk_hdmi_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t\tstruct drm_bridge_state *old_state)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\tif (!hdmi->powered)\n\t\treturn;\n\n\tmtk_hdmi_hw_1p4_version_enable(hdmi, true);\n\tmtk_hdmi_hw_make_reg_writable(hdmi, false);\n\n\thdmi->powered = false;\n}\n\nstatic void mtk_hdmi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\tdev_dbg(hdmi->dev, \"cur info: name:%s, hdisplay:%d\\n\",\n\t\tadjusted_mode->name, adjusted_mode->hdisplay);\n\tdev_dbg(hdmi->dev, \"hsync_start:%d,hsync_end:%d, htotal:%d\",\n\t\tadjusted_mode->hsync_start, adjusted_mode->hsync_end,\n\t\tadjusted_mode->htotal);\n\tdev_dbg(hdmi->dev, \"hskew:%d, vdisplay:%d\\n\",\n\t\tadjusted_mode->hskew, adjusted_mode->vdisplay);\n\tdev_dbg(hdmi->dev, \"vsync_start:%d, vsync_end:%d, vtotal:%d\",\n\t\tadjusted_mode->vsync_start, adjusted_mode->vsync_end,\n\t\tadjusted_mode->vtotal);\n\tdev_dbg(hdmi->dev, \"vscan:%d, flag:%d\\n\",\n\t\tadjusted_mode->vscan, adjusted_mode->flags);\n\n\tdrm_mode_copy(&hdmi->mode, adjusted_mode);\n}\n\nstatic void mtk_hdmi_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_bridge_state *old_state)\n{\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\tmtk_hdmi_hw_make_reg_writable(hdmi, true);\n\tmtk_hdmi_hw_1p4_version_enable(hdmi, true);\n\n\thdmi->powered = true;\n}\n\nstatic void mtk_hdmi_send_infoframe(struct mtk_hdmi *hdmi,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tmtk_hdmi_setup_audio_infoframe(hdmi);\n\tmtk_hdmi_setup_avi_infoframe(hdmi, mode);\n\tmtk_hdmi_setup_spd_infoframe(hdmi, \"mediatek\", \"On-chip HDMI\");\n\tif (mode->flags & DRM_MODE_FLAG_3D_MASK)\n\t\tmtk_hdmi_setup_vendor_specific_infoframe(hdmi, mode);\n}\n\nstatic void mtk_hdmi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *old_state)\n{\n\tstruct drm_atomic_state *state = old_state->base.state;\n\tstruct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);\n\n\t \n\thdmi->curr_conn = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t\t   bridge->encoder);\n\n\tmtk_hdmi_output_set_display_mode(hdmi, &hdmi->mode);\n\tclk_prepare_enable(hdmi->clk[MTK_HDMI_CLK_HDMI_PLL]);\n\tclk_prepare_enable(hdmi->clk[MTK_HDMI_CLK_HDMI_PIXEL]);\n\tphy_power_on(hdmi->phy);\n\tmtk_hdmi_send_infoframe(hdmi, &hdmi->mode);\n\n\thdmi->enabled = true;\n}\n\nstatic const struct drm_bridge_funcs mtk_hdmi_bridge_funcs = {\n\t.mode_valid = mtk_hdmi_bridge_mode_valid,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = mtk_hdmi_bridge_attach,\n\t.mode_fixup = mtk_hdmi_bridge_mode_fixup,\n\t.atomic_disable = mtk_hdmi_bridge_atomic_disable,\n\t.atomic_post_disable = mtk_hdmi_bridge_atomic_post_disable,\n\t.mode_set = mtk_hdmi_bridge_mode_set,\n\t.atomic_pre_enable = mtk_hdmi_bridge_atomic_pre_enable,\n\t.atomic_enable = mtk_hdmi_bridge_atomic_enable,\n\t.detect = mtk_hdmi_bridge_detect,\n\t.get_edid = mtk_hdmi_bridge_get_edid,\n};\n\nstatic int mtk_hdmi_dt_parse_pdata(struct mtk_hdmi *hdmi,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *cec_np, *remote, *i2c_np;\n\tstruct platform_device *cec_pdev;\n\tstruct regmap *regmap;\n\tstruct resource *mem;\n\tint ret;\n\n\tret = mtk_hdmi_get_all_clk(hdmi, np);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get clocks: %d\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\t \n\tcec_np = of_get_compatible_child(np->parent, \"mediatek,mt8173-cec\");\n\tif (!cec_np) {\n\t\tdev_err(dev, \"Failed to find CEC node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcec_pdev = of_find_device_by_node(cec_np);\n\tif (!cec_pdev) {\n\t\tdev_err(hdmi->dev, \"Waiting for CEC device %pOF\\n\",\n\t\t\tcec_np);\n\t\tof_node_put(cec_np);\n\t\treturn -EPROBE_DEFER;\n\t}\n\tof_node_put(cec_np);\n\thdmi->cec_dev = &cec_pdev->dev;\n\n\t \n\tregmap = syscon_regmap_lookup_by_phandle(np, \"mediatek,syscon-hdmi\");\n\tret = of_property_read_u32_index(np, \"mediatek,syscon-hdmi\", 1,\n\t\t\t\t\t &hdmi->sys_offset);\n\tif (IS_ERR(regmap))\n\t\tret = PTR_ERR(regmap);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to get system configuration registers: %d\\n\",\n\t\t\tret);\n\t\tgoto put_device;\n\t}\n\thdmi->sys_regmap = regmap;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\thdmi->regs = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(hdmi->regs)) {\n\t\tret = PTR_ERR(hdmi->regs);\n\t\tgoto put_device;\n\t}\n\n\tremote = of_graph_get_remote_node(np, 1, 0);\n\tif (!remote) {\n\t\tret = -EINVAL;\n\t\tgoto put_device;\n\t}\n\n\tif (!of_device_is_compatible(remote, \"hdmi-connector\")) {\n\t\thdmi->next_bridge = of_drm_find_bridge(remote);\n\t\tif (!hdmi->next_bridge) {\n\t\t\tdev_err(dev, \"Waiting for external bridge\\n\");\n\t\t\tof_node_put(remote);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto put_device;\n\t\t}\n\t}\n\n\ti2c_np = of_parse_phandle(remote, \"ddc-i2c-bus\", 0);\n\tif (!i2c_np) {\n\t\tdev_err(dev, \"Failed to find ddc-i2c-bus node in %pOF\\n\",\n\t\t\tremote);\n\t\tof_node_put(remote);\n\t\tret = -EINVAL;\n\t\tgoto put_device;\n\t}\n\tof_node_put(remote);\n\n\thdmi->ddc_adpt = of_find_i2c_adapter_by_node(i2c_np);\n\tof_node_put(i2c_np);\n\tif (!hdmi->ddc_adpt) {\n\t\tdev_err(dev, \"Failed to get ddc i2c adapter by node\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_device;\n\t}\n\n\treturn 0;\nput_device:\n\tput_device(hdmi->cec_dev);\n\treturn ret;\n}\n\n \n\nstatic int mtk_hdmi_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t    struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t    struct hdmi_codec_params *params)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\tstruct hdmi_audio_param hdmi_params;\n\tunsigned int chan = params->cea.channels;\n\n\tdev_dbg(hdmi->dev, \"%s: %u Hz, %d bit, %d channels\\n\", __func__,\n\t\tparams->sample_rate, params->sample_width, chan);\n\n\tif (!hdmi->bridge.encoder)\n\t\treturn -ENODEV;\n\n\tswitch (chan) {\n\tcase 2:\n\t\thdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_2_0;\n\t\tbreak;\n\tcase 4:\n\t\thdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_4_0;\n\t\tbreak;\n\tcase 6:\n\t\thdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_5_1;\n\t\tbreak;\n\tcase 8:\n\t\thdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_7_1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdmi->dev, \"channel[%d] not supported!\\n\", chan);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params->sample_rate) {\n\tcase 32000:\n\tcase 44100:\n\tcase 48000:\n\tcase 88200:\n\tcase 96000:\n\tcase 176400:\n\tcase 192000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdmi->dev, \"rate[%d] not supported!\\n\",\n\t\t\tparams->sample_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (daifmt->fmt) {\n\tcase HDMI_I2S:\n\t\thdmi_params.aud_codec = HDMI_AUDIO_CODING_TYPE_PCM;\n\t\thdmi_params.aud_sampe_size = HDMI_AUDIO_SAMPLE_SIZE_16;\n\t\thdmi_params.aud_input_type = HDMI_AUD_INPUT_I2S;\n\t\thdmi_params.aud_i2s_fmt = HDMI_I2S_MODE_I2S_24BIT;\n\t\thdmi_params.aud_mclk = HDMI_AUD_MCLK_128FS;\n\t\tbreak;\n\tcase HDMI_SPDIF:\n\t\thdmi_params.aud_codec = HDMI_AUDIO_CODING_TYPE_PCM;\n\t\thdmi_params.aud_sampe_size = HDMI_AUDIO_SAMPLE_SIZE_16;\n\t\thdmi_params.aud_input_type = HDMI_AUD_INPUT_SPDIF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdmi->dev, \"%s: Invalid DAI format %d\\n\", __func__,\n\t\t\tdaifmt->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&hdmi_params.codec_params, params,\n\t       sizeof(hdmi_params.codec_params));\n\n\tmtk_hdmi_audio_set_param(hdmi, &hdmi_params);\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_audio_startup(struct device *dev, void *data)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tmtk_hdmi_audio_enable(hdmi);\n\n\treturn 0;\n}\n\nstatic void mtk_hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tmtk_hdmi_audio_disable(hdmi);\n}\n\nstatic int\nmtk_hdmi_audio_mute(struct device *dev, void *data,\n\t\t    bool enable, int direction)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tif (enable)\n\t\tmtk_hdmi_hw_aud_mute(hdmi);\n\telse\n\t\tmtk_hdmi_hw_aud_unmute(hdmi);\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_audio_get_eld(struct device *dev, void *data, uint8_t *buf, size_t len)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tif (hdmi->enabled)\n\t\tmemcpy(buf, hdmi->curr_conn->eld, min(sizeof(hdmi->curr_conn->eld), len));\n\telse\n\t\tmemset(buf, 0, len);\n\treturn 0;\n}\n\nstatic int mtk_hdmi_audio_hook_plugged_cb(struct device *dev, void *data,\n\t\t\t\t\t  hdmi_codec_plugged_cb fn,\n\t\t\t\t\t  struct device *codec_dev)\n{\n\tstruct mtk_hdmi *hdmi = data;\n\n\tmutex_lock(&hdmi->update_plugged_status_lock);\n\thdmi->plugged_cb = fn;\n\thdmi->codec_dev = codec_dev;\n\tmutex_unlock(&hdmi->update_plugged_status_lock);\n\n\tmtk_hdmi_update_plugged_status(hdmi);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops mtk_hdmi_audio_codec_ops = {\n\t.hw_params = mtk_hdmi_audio_hw_params,\n\t.audio_startup = mtk_hdmi_audio_startup,\n\t.audio_shutdown = mtk_hdmi_audio_shutdown,\n\t.mute_stream = mtk_hdmi_audio_mute,\n\t.get_eld = mtk_hdmi_audio_get_eld,\n\t.hook_plugged_cb = mtk_hdmi_audio_hook_plugged_cb,\n\t.no_capture_mute = 1,\n};\n\nstatic int mtk_hdmi_register_audio_driver(struct device *dev)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &mtk_hdmi_audio_codec_ops,\n\t\t.max_i2s_channels = 2,\n\t\t.i2s = 1,\n\t\t.data = hdmi,\n\t};\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t     PLATFORM_DEVID_AUTO, &codec_data,\n\t\t\t\t\t     sizeof(codec_data));\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tDRM_INFO(\"%s driver bound to HDMI\\n\", HDMI_CODEC_DRV_NAME);\n\treturn 0;\n}\n\nstatic int mtk_drm_hdmi_probe(struct platform_device *pdev)\n{\n\tstruct mtk_hdmi *hdmi;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\thdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->dev = dev;\n\thdmi->conf = of_device_get_match_data(dev);\n\n\tret = mtk_hdmi_dt_parse_pdata(hdmi, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\thdmi->phy = devm_phy_get(dev, \"hdmi\");\n\tif (IS_ERR(hdmi->phy)) {\n\t\tret = PTR_ERR(hdmi->phy);\n\t\tdev_err(dev, \"Failed to get HDMI PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&hdmi->update_plugged_status_lock);\n\tplatform_set_drvdata(pdev, hdmi);\n\n\tret = mtk_hdmi_output_init(hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize hdmi output\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mtk_hdmi_register_audio_driver(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register audio driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdmi->bridge.funcs = &mtk_hdmi_bridge_funcs;\n\thdmi->bridge.of_node = pdev->dev.of_node;\n\thdmi->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID\n\t\t\t | DRM_BRIDGE_OP_HPD;\n\thdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\tdrm_bridge_add(&hdmi->bridge);\n\n\tret = mtk_hdmi_clk_enable_audio(hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable audio clocks: %d\\n\", ret);\n\t\tgoto err_bridge_remove;\n\t}\n\n\treturn 0;\n\nerr_bridge_remove:\n\tdrm_bridge_remove(&hdmi->bridge);\n\treturn ret;\n}\n\nstatic void mtk_drm_hdmi_remove(struct platform_device *pdev)\n{\n\tstruct mtk_hdmi *hdmi = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&hdmi->bridge);\n\tmtk_hdmi_clk_disable_audio(hdmi);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_hdmi_suspend(struct device *dev)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tmtk_hdmi_clk_disable_audio(hdmi);\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_resume(struct device *dev)\n{\n\tstruct mtk_hdmi *hdmi = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = mtk_hdmi_clk_enable_audio(hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"hdmi resume failed!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(mtk_hdmi_pm_ops,\n\t\t\t mtk_hdmi_suspend, mtk_hdmi_resume);\n\nstatic const struct mtk_hdmi_conf mtk_hdmi_conf_mt2701 = {\n\t.tz_disabled = true,\n};\n\nstatic const struct mtk_hdmi_conf mtk_hdmi_conf_mt8167 = {\n\t.max_mode_clock = 148500,\n\t.cea_modes_only = true,\n};\n\nstatic const struct of_device_id mtk_drm_hdmi_of_ids[] = {\n\t{ .compatible = \"mediatek,mt2701-hdmi\",\n\t  .data = &mtk_hdmi_conf_mt2701,\n\t},\n\t{ .compatible = \"mediatek,mt8167-hdmi\",\n\t  .data = &mtk_hdmi_conf_mt8167,\n\t},\n\t{ .compatible = \"mediatek,mt8173-hdmi\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_drm_hdmi_of_ids);\n\nstatic struct platform_driver mtk_hdmi_driver = {\n\t.probe = mtk_drm_hdmi_probe,\n\t.remove_new = mtk_drm_hdmi_remove,\n\t.driver = {\n\t\t.name = \"mediatek-drm-hdmi\",\n\t\t.of_match_table = mtk_drm_hdmi_of_ids,\n\t\t.pm = &mtk_hdmi_pm_ops,\n\t},\n};\n\nstatic struct platform_driver * const mtk_hdmi_drivers[] = {\n\t&mtk_hdmi_ddc_driver,\n\t&mtk_cec_driver,\n\t&mtk_hdmi_driver,\n};\n\nstatic int __init mtk_hdmitx_init(void)\n{\n\treturn platform_register_drivers(mtk_hdmi_drivers,\n\t\t\t\t\t ARRAY_SIZE(mtk_hdmi_drivers));\n}\n\nstatic void __exit mtk_hdmitx_exit(void)\n{\n\tplatform_unregister_drivers(mtk_hdmi_drivers,\n\t\t\t\t    ARRAY_SIZE(mtk_hdmi_drivers));\n}\n\nmodule_init(mtk_hdmitx_init);\nmodule_exit(mtk_hdmitx_exit);\n\nMODULE_AUTHOR(\"Jie Qiu <jie.qiu@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek HDMI Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}