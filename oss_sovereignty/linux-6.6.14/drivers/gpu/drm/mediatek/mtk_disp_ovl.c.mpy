{
  "module_name": "mtk_disp_ovl.c",
  "hash_id": "157bcac5dda439fe8e0f0322e0713ef22bdd832eba7d9b689102cc5a9abd1923",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_disp_ovl.c",
  "human_readable_source": "\n \n\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n\n#define DISP_REG_OVL_INTEN\t\t\t0x0004\n#define OVL_FME_CPL_INT\t\t\t\t\tBIT(1)\n#define DISP_REG_OVL_INTSTA\t\t\t0x0008\n#define DISP_REG_OVL_EN\t\t\t\t0x000c\n#define DISP_REG_OVL_RST\t\t\t0x0014\n#define DISP_REG_OVL_ROI_SIZE\t\t\t0x0020\n#define DISP_REG_OVL_DATAPATH_CON\t\t0x0024\n#define OVL_LAYER_SMI_ID_EN\t\t\t\tBIT(0)\n#define OVL_BGCLR_SEL_IN\t\t\t\tBIT(2)\n#define OVL_LAYER_AFBC_EN(n)\t\t\t\tBIT(4+n)\n#define DISP_REG_OVL_ROI_BGCLR\t\t\t0x0028\n#define DISP_REG_OVL_SRC_CON\t\t\t0x002c\n#define DISP_REG_OVL_CON(n)\t\t\t(0x0030 + 0x20 * (n))\n#define DISP_REG_OVL_SRC_SIZE(n)\t\t(0x0038 + 0x20 * (n))\n#define DISP_REG_OVL_OFFSET(n)\t\t\t(0x003c + 0x20 * (n))\n#define DISP_REG_OVL_PITCH_MSB(n)\t\t(0x0040 + 0x20 * (n))\n#define OVL_PITCH_MSB_2ND_SUBBUF\t\t\tBIT(16)\n#define DISP_REG_OVL_PITCH(n)\t\t\t(0x0044 + 0x20 * (n))\n#define DISP_REG_OVL_RDMA_CTRL(n)\t\t(0x00c0 + 0x20 * (n))\n#define DISP_REG_OVL_RDMA_GMC(n)\t\t(0x00c8 + 0x20 * (n))\n#define DISP_REG_OVL_ADDR_MT2701\t\t0x0040\n#define DISP_REG_OVL_CLRFMT_EXT\t\t\t0x02D0\n#define DISP_REG_OVL_ADDR_MT8173\t\t0x0f40\n#define DISP_REG_OVL_ADDR(ovl, n)\t\t((ovl)->data->addr + 0x20 * (n))\n#define DISP_REG_OVL_HDR_ADDR(ovl, n)\t\t((ovl)->data->addr + 0x20 * (n) + 0x04)\n#define DISP_REG_OVL_HDR_PITCH(ovl, n)\t\t((ovl)->data->addr + 0x20 * (n) + 0x08)\n\n#define GMC_THRESHOLD_BITS\t16\n#define GMC_THRESHOLD_HIGH\t((1 << GMC_THRESHOLD_BITS) / 4)\n#define GMC_THRESHOLD_LOW\t((1 << GMC_THRESHOLD_BITS) / 8)\n\n#define OVL_CON_BYTE_SWAP\tBIT(24)\n#define OVL_CON_MTX_YUV_TO_RGB\t(6 << 16)\n#define OVL_CON_CLRFMT_RGB\t(1 << 12)\n#define OVL_CON_CLRFMT_RGBA8888\t(2 << 12)\n#define OVL_CON_CLRFMT_ARGB8888\t(3 << 12)\n#define OVL_CON_CLRFMT_UYVY\t(4 << 12)\n#define OVL_CON_CLRFMT_YUYV\t(5 << 12)\n#define OVL_CON_CLRFMT_RGB565(ovl)\t((ovl)->data->fmt_rgb565_is_0 ? \\\n\t\t\t\t\t0 : OVL_CON_CLRFMT_RGB)\n#define OVL_CON_CLRFMT_RGB888(ovl)\t((ovl)->data->fmt_rgb565_is_0 ? \\\n\t\t\t\t\tOVL_CON_CLRFMT_RGB : 0)\n#define OVL_CON_CLRFMT_BIT_DEPTH_MASK(ovl)\t(0xFF << 4 * (ovl))\n#define OVL_CON_CLRFMT_BIT_DEPTH(depth, ovl)\t(depth << 4 * (ovl))\n#define OVL_CON_CLRFMT_8_BIT\t\t\t0x00\n#define OVL_CON_CLRFMT_10_BIT\t\t\t0x01\n#define\tOVL_CON_AEN\t\tBIT(8)\n#define\tOVL_CON_ALPHA\t\t0xff\n#define\tOVL_CON_VIRT_FLIP\tBIT(9)\n#define\tOVL_CON_HORZ_FLIP\tBIT(10)\n\nstatic const u32 mt8173_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n};\n\nstatic const u32 mt8195_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRA1010102,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n};\n\nstruct mtk_disp_ovl_data {\n\tunsigned int addr;\n\tunsigned int gmc_bits;\n\tunsigned int layer_nr;\n\tbool fmt_rgb565_is_0;\n\tbool smi_id_en;\n\tbool supports_afbc;\n\tconst u32 *formats;\n\tsize_t num_formats;\n\tbool supports_clrfmt_ext;\n};\n\n \nstruct mtk_disp_ovl {\n\tstruct drm_crtc\t\t\t*crtc;\n\tstruct clk\t\t\t*clk;\n\tvoid __iomem\t\t\t*regs;\n\tstruct cmdq_client_reg\t\tcmdq_reg;\n\tconst struct mtk_disp_ovl_data\t*data;\n\tvoid\t\t\t\t(*vblank_cb)(void *data);\n\tvoid\t\t\t\t*vblank_cb_data;\n};\n\nstatic irqreturn_t mtk_disp_ovl_irq_handler(int irq, void *dev_id)\n{\n\tstruct mtk_disp_ovl *priv = dev_id;\n\n\t \n\twritel(0x0, priv->regs + DISP_REG_OVL_INTSTA);\n\n\tif (!priv->vblank_cb)\n\t\treturn IRQ_NONE;\n\n\tpriv->vblank_cb(priv->vblank_cb_data);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid mtk_ovl_register_vblank_cb(struct device *dev,\n\t\t\t\tvoid (*vblank_cb)(void *),\n\t\t\t\tvoid *vblank_cb_data)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tovl->vblank_cb = vblank_cb;\n\tovl->vblank_cb_data = vblank_cb_data;\n}\n\nvoid mtk_ovl_unregister_vblank_cb(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tovl->vblank_cb = NULL;\n\tovl->vblank_cb_data = NULL;\n}\n\nvoid mtk_ovl_enable_vblank(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\twritel(0x0, ovl->regs + DISP_REG_OVL_INTSTA);\n\twritel_relaxed(OVL_FME_CPL_INT, ovl->regs + DISP_REG_OVL_INTEN);\n}\n\nvoid mtk_ovl_disable_vblank(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\twritel_relaxed(0x0, ovl->regs + DISP_REG_OVL_INTEN);\n}\n\nconst u32 *mtk_ovl_get_formats(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\treturn ovl->data->formats;\n}\n\nsize_t mtk_ovl_get_num_formats(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\treturn ovl->data->num_formats;\n}\n\nint mtk_ovl_clk_enable(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(ovl->clk);\n}\n\nvoid mtk_ovl_clk_disable(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ovl->clk);\n}\n\nvoid mtk_ovl_start(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tif (ovl->data->smi_id_en) {\n\t\tunsigned int reg;\n\n\t\treg = readl(ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\t\treg = reg | OVL_LAYER_SMI_ID_EN;\n\t\twritel_relaxed(reg, ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\t}\n\twritel_relaxed(0x1, ovl->regs + DISP_REG_OVL_EN);\n}\n\nvoid mtk_ovl_stop(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\twritel_relaxed(0x0, ovl->regs + DISP_REG_OVL_EN);\n\tif (ovl->data->smi_id_en) {\n\t\tunsigned int reg;\n\n\t\treg = readl(ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\t\treg = reg & ~OVL_LAYER_SMI_ID_EN;\n\t\twritel_relaxed(reg, ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\t}\n}\n\nstatic void mtk_ovl_set_afbc(struct mtk_disp_ovl *ovl, struct cmdq_pkt *cmdq_pkt,\n\t\t\t     int idx, bool enabled)\n{\n\tmtk_ddp_write_mask(cmdq_pkt, enabled ? OVL_LAYER_AFBC_EN(idx) : 0,\n\t\t\t   &ovl->cmdq_reg, ovl->regs,\n\t\t\t   DISP_REG_OVL_DATAPATH_CON, OVL_LAYER_AFBC_EN(idx));\n}\n\nstatic void mtk_ovl_set_bit_depth(struct device *dev, int idx, u32 format,\n\t\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tunsigned int bit_depth = OVL_CON_CLRFMT_8_BIT;\n\n\tif (!ovl->data->supports_clrfmt_ext)\n\t\treturn;\n\n\treg = readl(ovl->regs + DISP_REG_OVL_CLRFMT_EXT);\n\treg &= ~OVL_CON_CLRFMT_BIT_DEPTH_MASK(idx);\n\n\tif (format == DRM_FORMAT_RGBA1010102 ||\n\t    format == DRM_FORMAT_BGRA1010102 ||\n\t    format == DRM_FORMAT_ARGB2101010)\n\t\tbit_depth = OVL_CON_CLRFMT_10_BIT;\n\n\treg |= OVL_CON_CLRFMT_BIT_DEPTH(bit_depth, idx);\n\n\tmtk_ddp_write(cmdq_pkt, reg, &ovl->cmdq_reg,\n\t\t      ovl->regs, DISP_REG_OVL_CLRFMT_EXT);\n}\n\nvoid mtk_ovl_config(struct device *dev, unsigned int w,\n\t\t    unsigned int h, unsigned int vrefresh,\n\t\t    unsigned int bpc, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tif (w != 0 && h != 0)\n\t\tmtk_ddp_write_relaxed(cmdq_pkt, h << 16 | w, &ovl->cmdq_reg, ovl->regs,\n\t\t\t\t      DISP_REG_OVL_ROI_SIZE);\n\tmtk_ddp_write_relaxed(cmdq_pkt, 0x0, &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_ROI_BGCLR);\n\n\tmtk_ddp_write(cmdq_pkt, 0x1, &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_RST);\n\tmtk_ddp_write(cmdq_pkt, 0x0, &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_RST);\n}\n\nunsigned int mtk_ovl_layer_nr(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\treturn ovl->data->layer_nr;\n}\n\nunsigned int mtk_ovl_supported_rotations(struct device *dev)\n{\n\treturn DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t       DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;\n}\n\nint mtk_ovl_layer_check(struct device *dev, unsigned int idx,\n\t\t\tstruct mtk_plane_state *mtk_state)\n{\n\tstruct drm_plane_state *state = &mtk_state->base;\n\tunsigned int rotation = 0;\n\n\trotation = drm_rotation_simplify(state->rotation,\n\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\trotation &= ~DRM_MODE_ROTATE_0;\n\n\t \n\tif ((rotation & DRM_MODE_ROTATE_MASK) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (state->fb->format->is_yuv && rotation != 0)\n\t\treturn -EINVAL;\n\n\tstate->rotation = rotation;\n\n\treturn 0;\n}\n\nvoid mtk_ovl_layer_on(struct device *dev, unsigned int idx,\n\t\t      struct cmdq_pkt *cmdq_pkt)\n{\n\tunsigned int gmc_thrshd_l;\n\tunsigned int gmc_thrshd_h;\n\tunsigned int gmc_value;\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tmtk_ddp_write(cmdq_pkt, 0x1, &ovl->cmdq_reg, ovl->regs,\n\t\t      DISP_REG_OVL_RDMA_CTRL(idx));\n\tgmc_thrshd_l = GMC_THRESHOLD_LOW >>\n\t\t      (GMC_THRESHOLD_BITS - ovl->data->gmc_bits);\n\tgmc_thrshd_h = GMC_THRESHOLD_HIGH >>\n\t\t      (GMC_THRESHOLD_BITS - ovl->data->gmc_bits);\n\tif (ovl->data->gmc_bits == 10)\n\t\tgmc_value = gmc_thrshd_h | gmc_thrshd_h << 16;\n\telse\n\t\tgmc_value = gmc_thrshd_l | gmc_thrshd_l << 8 |\n\t\t\t    gmc_thrshd_h << 16 | gmc_thrshd_h << 24;\n\tmtk_ddp_write(cmdq_pkt, gmc_value,\n\t\t      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_RDMA_GMC(idx));\n\tmtk_ddp_write_mask(cmdq_pkt, BIT(idx), &ovl->cmdq_reg, ovl->regs,\n\t\t\t   DISP_REG_OVL_SRC_CON, BIT(idx));\n}\n\nvoid mtk_ovl_layer_off(struct device *dev, unsigned int idx,\n\t\t       struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\n\tmtk_ddp_write_mask(cmdq_pkt, 0, &ovl->cmdq_reg, ovl->regs,\n\t\t\t   DISP_REG_OVL_SRC_CON, BIT(idx));\n\tmtk_ddp_write(cmdq_pkt, 0, &ovl->cmdq_reg, ovl->regs,\n\t\t      DISP_REG_OVL_RDMA_CTRL(idx));\n}\n\nstatic unsigned int ovl_fmt_convert(struct mtk_disp_ovl *ovl, unsigned int fmt)\n{\n\t \n\tswitch (fmt) {\n\tdefault:\n\tcase DRM_FORMAT_RGB565:\n\t\treturn OVL_CON_CLRFMT_RGB565(ovl);\n\tcase DRM_FORMAT_BGR565:\n\t\treturn OVL_CON_CLRFMT_RGB565(ovl) | OVL_CON_BYTE_SWAP;\n\tcase DRM_FORMAT_RGB888:\n\t\treturn OVL_CON_CLRFMT_RGB888(ovl);\n\tcase DRM_FORMAT_BGR888:\n\t\treturn OVL_CON_CLRFMT_RGB888(ovl) | OVL_CON_BYTE_SWAP;\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_RGBA8888:\n\t\treturn OVL_CON_CLRFMT_ARGB8888;\n\tcase DRM_FORMAT_BGRX8888:\n\tcase DRM_FORMAT_BGRA8888:\n\tcase DRM_FORMAT_BGRA1010102:\n\t\treturn OVL_CON_CLRFMT_ARGB8888 | OVL_CON_BYTE_SWAP;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\treturn OVL_CON_CLRFMT_RGBA8888;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn OVL_CON_CLRFMT_RGBA8888 | OVL_CON_BYTE_SWAP;\n\tcase DRM_FORMAT_UYVY:\n\t\treturn OVL_CON_CLRFMT_UYVY | OVL_CON_MTX_YUV_TO_RGB;\n\tcase DRM_FORMAT_YUYV:\n\t\treturn OVL_CON_CLRFMT_YUYV | OVL_CON_MTX_YUV_TO_RGB;\n\t}\n}\n\nvoid mtk_ovl_layer_config(struct device *dev, unsigned int idx,\n\t\t\t  struct mtk_plane_state *state,\n\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\tstruct mtk_plane_pending_state *pending = &state->pending;\n\tunsigned int addr = pending->addr;\n\tunsigned int hdr_addr = pending->hdr_addr;\n\tunsigned int pitch = pending->pitch;\n\tunsigned int hdr_pitch = pending->hdr_pitch;\n\tunsigned int fmt = pending->format;\n\tunsigned int offset = (pending->y << 16) | pending->x;\n\tunsigned int src_size = (pending->height << 16) | pending->width;\n\tunsigned int con;\n\tbool is_afbc = pending->modifier != DRM_FORMAT_MOD_LINEAR;\n\tunion overlay_pitch {\n\t\tstruct split_pitch {\n\t\t\tu16 lsb;\n\t\t\tu16 msb;\n\t\t} split_pitch;\n\t\tu32 pitch;\n\t} overlay_pitch;\n\n\toverlay_pitch.pitch = pitch;\n\n\tif (!pending->enable) {\n\t\tmtk_ovl_layer_off(dev, idx, cmdq_pkt);\n\t\treturn;\n\t}\n\n\tcon = ovl_fmt_convert(ovl, fmt);\n\tif (state->base.fb && state->base.fb->format->has_alpha)\n\t\tcon |= OVL_CON_AEN | OVL_CON_ALPHA;\n\n\tif (pending->rotation & DRM_MODE_REFLECT_Y) {\n\t\tcon |= OVL_CON_VIRT_FLIP;\n\t\taddr += (pending->height - 1) * pending->pitch;\n\t}\n\n\tif (pending->rotation & DRM_MODE_REFLECT_X) {\n\t\tcon |= OVL_CON_HORZ_FLIP;\n\t\taddr += pending->pitch - 1;\n\t}\n\n\tif (ovl->data->supports_afbc)\n\t\tmtk_ovl_set_afbc(ovl, cmdq_pkt, idx, is_afbc);\n\n\tmtk_ddp_write_relaxed(cmdq_pkt, con, &ovl->cmdq_reg, ovl->regs,\n\t\t\t      DISP_REG_OVL_CON(idx));\n\tmtk_ddp_write_relaxed(cmdq_pkt, overlay_pitch.split_pitch.lsb, &ovl->cmdq_reg, ovl->regs,\n\t\t\t      DISP_REG_OVL_PITCH(idx));\n\tmtk_ddp_write_relaxed(cmdq_pkt, src_size, &ovl->cmdq_reg, ovl->regs,\n\t\t\t      DISP_REG_OVL_SRC_SIZE(idx));\n\tmtk_ddp_write_relaxed(cmdq_pkt, offset, &ovl->cmdq_reg, ovl->regs,\n\t\t\t      DISP_REG_OVL_OFFSET(idx));\n\tmtk_ddp_write_relaxed(cmdq_pkt, addr, &ovl->cmdq_reg, ovl->regs,\n\t\t\t      DISP_REG_OVL_ADDR(ovl, idx));\n\n\tif (is_afbc) {\n\t\tmtk_ddp_write_relaxed(cmdq_pkt, hdr_addr, &ovl->cmdq_reg, ovl->regs,\n\t\t\t\t      DISP_REG_OVL_HDR_ADDR(ovl, idx));\n\t\tmtk_ddp_write_relaxed(cmdq_pkt,\n\t\t\t\t      OVL_PITCH_MSB_2ND_SUBBUF | overlay_pitch.split_pitch.msb,\n\t\t\t\t      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));\n\t\tmtk_ddp_write_relaxed(cmdq_pkt, hdr_pitch, &ovl->cmdq_reg, ovl->regs,\n\t\t\t\t      DISP_REG_OVL_HDR_PITCH(ovl, idx));\n\t} else {\n\t\tmtk_ddp_write_relaxed(cmdq_pkt,\n\t\t\t\t      overlay_pitch.split_pitch.msb,\n\t\t\t\t      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));\n\t}\n\n\tmtk_ovl_set_bit_depth(dev, idx, fmt, cmdq_pkt);\n\tmtk_ovl_layer_on(dev, idx, cmdq_pkt);\n}\n\nvoid mtk_ovl_bgclr_in_on(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\tunsigned int reg;\n\n\treg = readl(ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\treg = reg | OVL_BGCLR_SEL_IN;\n\twritel(reg, ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n}\n\nvoid mtk_ovl_bgclr_in_off(struct device *dev)\n{\n\tstruct mtk_disp_ovl *ovl = dev_get_drvdata(dev);\n\tunsigned int reg;\n\n\treg = readl(ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n\treg = reg & ~OVL_BGCLR_SEL_IN;\n\twritel(reg, ovl->regs + DISP_REG_OVL_DATAPATH_CON);\n}\n\nstatic int mtk_disp_ovl_bind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\treturn 0;\n}\n\nstatic void mtk_disp_ovl_unbind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n}\n\nstatic const struct component_ops mtk_disp_ovl_component_ops = {\n\t.bind\t= mtk_disp_ovl_bind,\n\t.unbind = mtk_disp_ovl_unbind,\n};\n\nstatic int mtk_disp_ovl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_disp_ovl *priv;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get ovl clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"failed to ioremap ovl\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);\n\tif (ret)\n\t\tdev_dbg(dev, \"get mediatek,gce-client-reg fail!\\n\");\n#endif\n\n\tpriv->data = of_device_get_match_data(dev);\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = devm_request_irq(dev, irq, mtk_disp_ovl_irq_handler,\n\t\t\t       IRQF_TRIGGER_NONE, dev_name(dev), priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request irq %d: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &mtk_disp_ovl_component_ops);\n\tif (ret) {\n\t\tpm_runtime_disable(dev);\n\t\tdev_err(dev, \"Failed to add component: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void mtk_disp_ovl_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_disp_ovl_component_ops);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct mtk_disp_ovl_data mt2701_ovl_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT2701,\n\t.gmc_bits = 8,\n\t.layer_nr = 4,\n\t.fmt_rgb565_is_0 = false,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8173_ovl_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 8,\n\t.layer_nr = 4,\n\t.fmt_rgb565_is_0 = true,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8183_ovl_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 10,\n\t.layer_nr = 4,\n\t.fmt_rgb565_is_0 = true,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8183_ovl_2l_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 10,\n\t.layer_nr = 2,\n\t.fmt_rgb565_is_0 = true,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8192_ovl_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 10,\n\t.layer_nr = 4,\n\t.fmt_rgb565_is_0 = true,\n\t.smi_id_en = true,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8192_ovl_2l_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 10,\n\t.layer_nr = 2,\n\t.fmt_rgb565_is_0 = true,\n\t.smi_id_en = true,\n\t.formats = mt8173_formats,\n\t.num_formats = ARRAY_SIZE(mt8173_formats),\n};\n\nstatic const struct mtk_disp_ovl_data mt8195_ovl_driver_data = {\n\t.addr = DISP_REG_OVL_ADDR_MT8173,\n\t.gmc_bits = 10,\n\t.layer_nr = 4,\n\t.fmt_rgb565_is_0 = true,\n\t.smi_id_en = true,\n\t.supports_afbc = true,\n\t.formats = mt8195_formats,\n\t.num_formats = ARRAY_SIZE(mt8195_formats),\n\t.supports_clrfmt_ext = true,\n};\n\nstatic const struct of_device_id mtk_disp_ovl_driver_dt_match[] = {\n\t{ .compatible = \"mediatek,mt2701-disp-ovl\",\n\t  .data = &mt2701_ovl_driver_data},\n\t{ .compatible = \"mediatek,mt8173-disp-ovl\",\n\t  .data = &mt8173_ovl_driver_data},\n\t{ .compatible = \"mediatek,mt8183-disp-ovl\",\n\t  .data = &mt8183_ovl_driver_data},\n\t{ .compatible = \"mediatek,mt8183-disp-ovl-2l\",\n\t  .data = &mt8183_ovl_2l_driver_data},\n\t{ .compatible = \"mediatek,mt8192-disp-ovl\",\n\t  .data = &mt8192_ovl_driver_data},\n\t{ .compatible = \"mediatek,mt8192-disp-ovl-2l\",\n\t  .data = &mt8192_ovl_2l_driver_data},\n\t{ .compatible = \"mediatek,mt8195-disp-ovl\",\n\t  .data = &mt8195_ovl_driver_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_disp_ovl_driver_dt_match);\n\nstruct platform_driver mtk_disp_ovl_driver = {\n\t.probe\t\t= mtk_disp_ovl_probe,\n\t.remove_new\t= mtk_disp_ovl_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mediatek-disp-ovl\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.of_match_table = mtk_disp_ovl_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}