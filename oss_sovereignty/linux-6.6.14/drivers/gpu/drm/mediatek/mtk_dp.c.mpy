{
  "module_name": "mtk_dp.c",
  "hash_id": "07ce8565702e3356f2e8380bd6e91d655aa81c039f9e92f81c93f37c7794f613",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_dp.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/soc/mediatek/mtk_sip_svc.h>\n#include <sound/hdmi-codec.h>\n#include <video/videomode.h>\n\n#include \"mtk_dp_reg.h\"\n\n#define MTK_DP_SIP_CONTROL_AARCH32\tMTK_SIP_SMC_CMD(0x523)\n#define MTK_DP_SIP_ATF_EDP_VIDEO_UNMUTE\t(BIT(0) | BIT(5))\n#define MTK_DP_SIP_ATF_VIDEO_UNMUTE\tBIT(5)\n\n#define MTK_DP_THREAD_CABLE_STATE_CHG\tBIT(0)\n#define MTK_DP_THREAD_HPD_EVENT\t\tBIT(1)\n\n#define MTK_DP_4P1T 4\n#define MTK_DP_HDE 2\n#define MTK_DP_PIX_PER_ADDR 2\n#define MTK_DP_AUX_WAIT_REPLY_COUNT 20\n#define MTK_DP_TBC_BUF_READ_START_ADDR 0x8\n#define MTK_DP_TRAIN_VOLTAGE_LEVEL_RETRY 5\n#define MTK_DP_TRAIN_DOWNSCALE_RETRY 10\n#define MTK_DP_VERSION 0x11\n#define MTK_DP_SDP_AUI 0x4\n\nenum {\n\tMTK_DP_CAL_GLB_BIAS_TRIM = 0,\n\tMTK_DP_CAL_CLKTX_IMPSE,\n\tMTK_DP_CAL_LN_TX_IMPSEL_PMOS_0,\n\tMTK_DP_CAL_LN_TX_IMPSEL_PMOS_1,\n\tMTK_DP_CAL_LN_TX_IMPSEL_PMOS_2,\n\tMTK_DP_CAL_LN_TX_IMPSEL_PMOS_3,\n\tMTK_DP_CAL_LN_TX_IMPSEL_NMOS_0,\n\tMTK_DP_CAL_LN_TX_IMPSEL_NMOS_1,\n\tMTK_DP_CAL_LN_TX_IMPSEL_NMOS_2,\n\tMTK_DP_CAL_LN_TX_IMPSEL_NMOS_3,\n\tMTK_DP_CAL_MAX,\n};\n\nstruct mtk_dp_train_info {\n\tbool sink_ssc;\n\tbool cable_plugged_in;\n\t \n\tint link_rate;\n\tint lane_count;\n\tunsigned int channel_eq_pattern;\n};\n\nstruct mtk_dp_audio_cfg {\n\tbool detect_monitor;\n\tint sad_count;\n\tint sample_rate;\n\tint word_length_bits;\n\tint channels;\n};\n\nstruct mtk_dp_info {\n\tenum dp_pixelformat format;\n\tstruct videomode vm;\n\tstruct mtk_dp_audio_cfg audio_cur_cfg;\n};\n\nstruct mtk_dp_efuse_fmt {\n\tunsigned short idx;\n\tunsigned short shift;\n\tunsigned short mask;\n\tunsigned short min_val;\n\tunsigned short max_val;\n\tunsigned short default_val;\n};\n\nstruct mtk_dp {\n\tbool enabled;\n\tbool need_debounce;\n\tint irq;\n\tu8 max_lanes;\n\tu8 max_linkrate;\n\tu8 rx_cap[DP_RECEIVER_CAP_SIZE];\n\tu32 cal_data[MTK_DP_CAL_MAX];\n\tu32 irq_thread_handle;\n\t \n\tspinlock_t irq_thread_lock;\n\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *conn;\n\tstruct drm_device *drm_dev;\n\tstruct drm_dp_aux aux;\n\n\tconst struct mtk_dp_data *data;\n\tstruct mtk_dp_info info;\n\tstruct mtk_dp_train_info train_info;\n\n\tstruct platform_device *phy_dev;\n\tstruct phy *phy;\n\tstruct regmap *regs;\n\tstruct timer_list debounce_timer;\n\n\t \n\tbool audio_enable;\n\thdmi_codec_plugged_cb plugged_cb;\n\tstruct platform_device *audio_pdev;\n\n\tstruct device *codec_dev;\n\t \n\tstruct mutex update_plugged_status_lock;\n};\n\nstruct mtk_dp_data {\n\tint bridge_type;\n\tunsigned int smc_cmd;\n\tconst struct mtk_dp_efuse_fmt *efuse_fmt;\n\tbool audio_supported;\n};\n\nstatic const struct mtk_dp_efuse_fmt mt8195_edp_efuse_fmt[MTK_DP_CAL_MAX] = {\n\t[MTK_DP_CAL_GLB_BIAS_TRIM] = {\n\t\t.idx = 3,\n\t\t.shift = 27,\n\t\t.mask = 0x1f,\n\t\t.min_val = 1,\n\t\t.max_val = 0x1e,\n\t\t.default_val = 0xf,\n\t},\n\t[MTK_DP_CAL_CLKTX_IMPSE] = {\n\t\t.idx = 0,\n\t\t.shift = 9,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_0] = {\n\t\t.idx = 2,\n\t\t.shift = 28,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_1] = {\n\t\t.idx = 2,\n\t\t.shift = 20,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_2] = {\n\t\t.idx = 2,\n\t\t.shift = 12,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_3] = {\n\t\t.idx = 2,\n\t\t.shift = 4,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_0] = {\n\t\t.idx = 2,\n\t\t.shift = 24,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_1] = {\n\t\t.idx = 2,\n\t\t.shift = 16,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_2] = {\n\t\t.idx = 2,\n\t\t.shift = 8,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_3] = {\n\t\t.idx = 2,\n\t\t.shift = 0,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n};\n\nstatic const struct mtk_dp_efuse_fmt mt8195_dp_efuse_fmt[MTK_DP_CAL_MAX] = {\n\t[MTK_DP_CAL_GLB_BIAS_TRIM] = {\n\t\t.idx = 0,\n\t\t.shift = 27,\n\t\t.mask = 0x1f,\n\t\t.min_val = 1,\n\t\t.max_val = 0x1e,\n\t\t.default_val = 0xf,\n\t},\n\t[MTK_DP_CAL_CLKTX_IMPSE] = {\n\t\t.idx = 0,\n\t\t.shift = 13,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_0] = {\n\t\t.idx = 1,\n\t\t.shift = 28,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_1] = {\n\t\t.idx = 1,\n\t\t.shift = 20,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_2] = {\n\t\t.idx = 1,\n\t\t.shift = 12,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_3] = {\n\t\t.idx = 1,\n\t\t.shift = 4,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_0] = {\n\t\t.idx = 1,\n\t\t.shift = 24,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_1] = {\n\t\t.idx = 1,\n\t\t.shift = 16,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_2] = {\n\t\t.idx = 1,\n\t\t.shift = 8,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n\t[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_3] = {\n\t\t.idx = 1,\n\t\t.shift = 0,\n\t\t.mask = 0xf,\n\t\t.min_val = 1,\n\t\t.max_val = 0xe,\n\t\t.default_val = 0x8,\n\t},\n};\n\nstatic struct regmap_config mtk_dp_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = SEC_OFFSET + 0x90,\n\t.name = \"mtk-dp-registers\",\n};\n\nstatic struct mtk_dp *mtk_dp_from_bridge(struct drm_bridge *b)\n{\n\treturn container_of(b, struct mtk_dp, bridge);\n}\n\nstatic u32 mtk_dp_read(struct mtk_dp *mtk_dp, u32 offset)\n{\n\tu32 read_val;\n\tint ret;\n\n\tret = regmap_read(mtk_dp->regs, offset, &read_val);\n\tif (ret) {\n\t\tdev_err(mtk_dp->dev, \"Failed to read register 0x%x: %d\\n\",\n\t\t\toffset, ret);\n\t\treturn 0;\n\t}\n\n\treturn read_val;\n}\n\nstatic int mtk_dp_write(struct mtk_dp *mtk_dp, u32 offset, u32 val)\n{\n\tint ret = regmap_write(mtk_dp->regs, offset, val);\n\n\tif (ret)\n\t\tdev_err(mtk_dp->dev,\n\t\t\t\"Failed to write register 0x%x with value 0x%x\\n\",\n\t\t\toffset, val);\n\treturn ret;\n}\n\nstatic int mtk_dp_update_bits(struct mtk_dp *mtk_dp, u32 offset,\n\t\t\t      u32 val, u32 mask)\n{\n\tint ret = regmap_update_bits(mtk_dp->regs, offset, mask, val);\n\n\tif (ret)\n\t\tdev_err(mtk_dp->dev,\n\t\t\t\"Failed to update register 0x%x with value 0x%x, mask 0x%x\\n\",\n\t\t\toffset, val, mask);\n\treturn ret;\n}\n\nstatic void mtk_dp_bulk_16bit_write(struct mtk_dp *mtk_dp, u32 offset, u8 *buf,\n\t\t\t\t    size_t length)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < length; i += 2) {\n\t\tu32 val = buf[i] | (i + 1 < length ? buf[i + 1] << 8 : 0);\n\n\t\tif (mtk_dp_write(mtk_dp, offset + i * 2, val))\n\t\t\treturn;\n\t}\n}\n\nstatic void mtk_dp_msa_bypass_enable(struct mtk_dp *mtk_dp, bool enable)\n{\n\tu32 mask = HTOTAL_SEL_DP_ENC0_P0 | VTOTAL_SEL_DP_ENC0_P0 |\n\t\t   HSTART_SEL_DP_ENC0_P0 | VSTART_SEL_DP_ENC0_P0 |\n\t\t   HWIDTH_SEL_DP_ENC0_P0 | VHEIGHT_SEL_DP_ENC0_P0 |\n\t\t   HSP_SEL_DP_ENC0_P0 | HSW_SEL_DP_ENC0_P0 |\n\t\t   VSP_SEL_DP_ENC0_P0 | VSW_SEL_DP_ENC0_P0;\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3030, enable ? 0 : mask, mask);\n}\n\nstatic void mtk_dp_set_msa(struct mtk_dp *mtk_dp)\n{\n\tstruct drm_display_mode mode;\n\tstruct videomode *vm = &mtk_dp->info.vm;\n\n\tdrm_display_mode_from_videomode(vm, &mode);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3010,\n\t\t\t   mode.htotal, HTOTAL_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3018,\n\t\t\t   vm->hsync_len + vm->hback_porch,\n\t\t\t   HSTART_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3028,\n\t\t\t   vm->hsync_len, HSW_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3028,\n\t\t\t   0, HSP_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3020,\n\t\t\t   vm->hactive, HWIDTH_SW_DP_ENC0_P0_MASK);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3014,\n\t\t\t   mode.vtotal, VTOTAL_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_301C,\n\t\t\t   vm->vsync_len + vm->vback_porch,\n\t\t\t   VSTART_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_302C,\n\t\t\t   vm->vsync_len, VSW_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_302C,\n\t\t\t   0, VSP_SW_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3024,\n\t\t\t   vm->vactive, VHEIGHT_SW_DP_ENC0_P0_MASK);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3064,\n\t\t\t   vm->hactive, HDE_NUM_LAST_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3154,\n\t\t\t   mode.htotal, PGEN_HTOTAL_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3158,\n\t\t\t   vm->hfront_porch,\n\t\t\t   PGEN_HSYNC_RISING_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_315C,\n\t\t\t   vm->hsync_len,\n\t\t\t   PGEN_HSYNC_PULSE_WIDTH_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3160,\n\t\t\t   vm->hback_porch + vm->hsync_len,\n\t\t\t   PGEN_HFDE_START_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3164,\n\t\t\t   vm->hactive,\n\t\t\t   PGEN_HFDE_ACTIVE_WIDTH_DP_ENC0_P0_MASK);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3168,\n\t\t\t   mode.vtotal,\n\t\t\t   PGEN_VTOTAL_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_316C,\n\t\t\t   vm->vfront_porch,\n\t\t\t   PGEN_VSYNC_RISING_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3170,\n\t\t\t   vm->vsync_len,\n\t\t\t   PGEN_VSYNC_PULSE_WIDTH_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3174,\n\t\t\t   vm->vback_porch + vm->vsync_len,\n\t\t\t   PGEN_VFDE_START_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3178,\n\t\t\t   vm->vactive,\n\t\t\t   PGEN_VFDE_ACTIVE_WIDTH_DP_ENC0_P0_MASK);\n}\n\nstatic int mtk_dp_set_color_format(struct mtk_dp *mtk_dp,\n\t\t\t\t   enum dp_pixelformat color_format)\n{\n\tu32 val;\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3034,\n\t\t\t   color_format << DP_TEST_COLOR_FORMAT_SHIFT,\n\t\t\t   DP_TEST_COLOR_FORMAT_MASK);\n\n\tswitch (color_format) {\n\tcase DP_PIXELFORMAT_YUV422:\n\t\tval = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_YCBCR422;\n\t\tbreak;\n\tcase DP_PIXELFORMAT_RGB:\n\t\tval = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_RGB;\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn(mtk_dp->drm_dev, \"Unsupported color format: %d\\n\",\n\t\t\t color_format);\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_303C,\n\t\t\t   val, PIXEL_ENCODE_FORMAT_DP_ENC0_P0_MASK);\n\treturn 0;\n}\n\nstatic void mtk_dp_set_color_depth(struct mtk_dp *mtk_dp)\n{\n\t \n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3034,\n\t\t\t   DP_MSA_MISC_8_BPC, DP_TEST_BIT_DEPTH_MASK);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_303C,\n\t\t\t   VIDEO_COLOR_DEPTH_DP_ENC0_P0_8BIT,\n\t\t\t   VIDEO_COLOR_DEPTH_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_config_mn_mode(struct mtk_dp *mtk_dp)\n{\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3004,\n\t\t\t   0, VIDEO_M_CODE_SEL_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_set_sram_read_start(struct mtk_dp *mtk_dp, u32 val)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_303C,\n\t\t\t   val, SRAM_START_READ_THRD_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_setup_encoder(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_303C,\n\t\t\t   VIDEO_MN_GEN_EN_DP_ENC0_P0,\n\t\t\t   VIDEO_MN_GEN_EN_DP_ENC0_P0);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3040,\n\t\t\t   SDP_DOWN_CNT_DP_ENC0_P0_VAL,\n\t\t\t   SDP_DOWN_CNT_INIT_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3364,\n\t\t\t   SDP_DOWN_CNT_IN_HBLANK_DP_ENC1_P0_VAL,\n\t\t\t   SDP_DOWN_CNT_INIT_IN_HBLANK_DP_ENC1_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3300,\n\t\t\t   VIDEO_AFIFO_RDY_SEL_DP_ENC1_P0_VAL << 8,\n\t\t\t   VIDEO_AFIFO_RDY_SEL_DP_ENC1_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3364,\n\t\t\t   FIFO_READ_START_POINT_DP_ENC1_P0_VAL << 12,\n\t\t\t   FIFO_READ_START_POINT_DP_ENC1_P0_MASK);\n\tmtk_dp_write(mtk_dp, MTK_DP_ENC1_P0_3368, DP_ENC1_P0_3368_VAL);\n}\n\nstatic void mtk_dp_pg_enable(struct mtk_dp *mtk_dp, bool enable)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3038,\n\t\t\t   enable ? VIDEO_SOURCE_SEL_DP_ENC0_P0_MASK : 0,\n\t\t\t   VIDEO_SOURCE_SEL_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_31B0,\n\t\t\t   PGEN_PATTERN_SEL_VAL << 4, PGEN_PATTERN_SEL_MASK);\n}\n\nstatic void mtk_dp_audio_setup_channels(struct mtk_dp *mtk_dp,\n\t\t\t\t\tstruct mtk_dp_audio_cfg *cfg)\n{\n\tu32 channel_enable_bits;\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3324,\n\t\t\t   AUDIO_SOURCE_MUX_DP_ENC1_P0_DPRX,\n\t\t\t   AUDIO_SOURCE_MUX_DP_ENC1_P0_MASK);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_33F4,\n\t\t\t   DP_ENC_DUMMY_RW_1, DP_ENC_DUMMY_RW_1);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3304,\n\t\t\t   AU_PRTY_REGEN_DP_ENC1_P0_MASK |\n\t\t\t   AU_CH_STS_REGEN_DP_ENC1_P0_MASK |\n\t\t\t   AUDIO_SAMPLE_PRSENT_REGEN_DP_ENC1_P0_MASK,\n\t\t\t   AU_PRTY_REGEN_DP_ENC1_P0_MASK |\n\t\t\t   AU_CH_STS_REGEN_DP_ENC1_P0_MASK |\n\t\t\t   AUDIO_SAMPLE_PRSENT_REGEN_DP_ENC1_P0_MASK);\n\n\tswitch (cfg->channels) {\n\tcase 2:\n\t\tchannel_enable_bits = AUDIO_2CH_SEL_DP_ENC0_P0_MASK |\n\t\t\t\t      AUDIO_2CH_EN_DP_ENC0_P0_MASK;\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\tchannel_enable_bits = AUDIO_8CH_SEL_DP_ENC0_P0_MASK |\n\t\t\t\t      AUDIO_8CH_EN_DP_ENC0_P0_MASK;\n\t\tbreak;\n\t}\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3088,\n\t\t\t   channel_enable_bits | AU_EN_DP_ENC0_P0,\n\t\t\t   AUDIO_2CH_SEL_DP_ENC0_P0_MASK |\n\t\t\t   AUDIO_2CH_EN_DP_ENC0_P0_MASK |\n\t\t\t   AUDIO_8CH_SEL_DP_ENC0_P0_MASK |\n\t\t\t   AUDIO_8CH_EN_DP_ENC0_P0_MASK |\n\t\t\t   AU_EN_DP_ENC0_P0);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_33F4, 0, DP_ENC_DUMMY_RW_1);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_33F4,\n\t\t\t   DP_ENC_DUMMY_RW_1_AUDIO_RST_EN,\n\t\t\t   DP_ENC_DUMMY_RW_1_AUDIO_RST_EN);\n}\n\nstatic void mtk_dp_audio_channel_status_set(struct mtk_dp *mtk_dp,\n\t\t\t\t\t    struct mtk_dp_audio_cfg *cfg)\n{\n\tstruct snd_aes_iec958 iec = { 0 };\n\n\tswitch (cfg->sample_rate) {\n\tcase 32000:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 192000:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tdefault:\n\t\tiec.status[3] = IEC958_AES3_CON_FS_NOTID;\n\t\tbreak;\n\t}\n\n\tswitch (cfg->word_length_bits) {\n\tcase 16:\n\t\tiec.status[4] = IEC958_AES4_CON_WORDLEN_20_16;\n\t\tbreak;\n\tcase 20:\n\t\tiec.status[4] = IEC958_AES4_CON_WORDLEN_20_16 |\n\t\t\t\tIEC958_AES4_CON_MAX_WORDLEN_24;\n\t\tbreak;\n\tcase 24:\n\t\tiec.status[4] = IEC958_AES4_CON_WORDLEN_24_20 |\n\t\t\t\tIEC958_AES4_CON_MAX_WORDLEN_24;\n\t\tbreak;\n\tdefault:\n\t\tiec.status[4] = IEC958_AES4_CON_WORDLEN_NOTID;\n\t}\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_308C,\n\t\t\t   0, CH_STATUS_0_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3090,\n\t\t\t   iec.status[3] << 8, CH_STATUS_1_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3094,\n\t\t\t   iec.status[4], CH_STATUS_2_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_audio_sdp_asp_set_channels(struct mtk_dp *mtk_dp,\n\t\t\t\t\t      int channels)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_312C,\n\t\t\t   (min(8, channels) - 1) << 8,\n\t\t\t   ASP_HB2_DP_ENC0_P0_MASK | ASP_HB3_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_audio_set_divider(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_30BC,\n\t\t\t   AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_DIV_2,\n\t\t\t   AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_sdp_trigger_aui(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3280,\n\t\t\t   MTK_DP_SDP_AUI, SDP_PACKET_TYPE_DP_ENC1_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3280,\n\t\t\t   SDP_PACKET_W_DP_ENC1_P0, SDP_PACKET_W_DP_ENC1_P0);\n}\n\nstatic void mtk_dp_sdp_set_data(struct mtk_dp *mtk_dp, u8 *data_bytes)\n{\n\tmtk_dp_bulk_16bit_write(mtk_dp, MTK_DP_ENC1_P0_3200,\n\t\t\t\tdata_bytes, 0x10);\n}\n\nstatic void mtk_dp_sdp_set_header_aui(struct mtk_dp *mtk_dp,\n\t\t\t\t      struct dp_sdp_header *header)\n{\n\tu32 db_addr = MTK_DP_ENC0_P0_30D8 + (MTK_DP_SDP_AUI - 1) * 8;\n\n\tmtk_dp_bulk_16bit_write(mtk_dp, db_addr, (u8 *)header, 4);\n}\n\nstatic void mtk_dp_disable_sdp_aui(struct mtk_dp *mtk_dp)\n{\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_30A8 & 0xfffc, 0,\n\t\t\t   0xff << ((MTK_DP_ENC0_P0_30A8 & 3) * 8));\n}\n\nstatic void mtk_dp_setup_sdp_aui(struct mtk_dp *mtk_dp,\n\t\t\t\t struct dp_sdp *sdp)\n{\n\tu32 shift;\n\n\tmtk_dp_sdp_set_data(mtk_dp, sdp->db);\n\tmtk_dp_sdp_set_header_aui(mtk_dp, &sdp->sdp_header);\n\tmtk_dp_disable_sdp_aui(mtk_dp);\n\n\tshift = (MTK_DP_ENC0_P0_30A8 & 3) * 8;\n\n\tmtk_dp_sdp_trigger_aui(mtk_dp);\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_30A8 & 0xfffc,\n\t\t\t   0x05 << shift, 0xff << shift);\n}\n\nstatic void mtk_dp_aux_irq_clear(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_write(mtk_dp, MTK_DP_AUX_P0_3640, DP_AUX_P0_3640_VAL);\n}\n\nstatic void mtk_dp_aux_set_cmd(struct mtk_dp *mtk_dp, u8 cmd, u32 addr)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3644,\n\t\t\t   cmd, MCU_REQUEST_COMMAND_AUX_TX_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3648,\n\t\t\t   addr, MCU_REQUEST_ADDRESS_LSB_AUX_TX_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_364C,\n\t\t\t   addr >> 16, MCU_REQUEST_ADDRESS_MSB_AUX_TX_P0_MASK);\n}\n\nstatic void mtk_dp_aux_clear_fifo(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3650,\n\t\t\t   MCU_ACK_TRAN_COMPLETE_AUX_TX_P0,\n\t\t\t   MCU_ACK_TRAN_COMPLETE_AUX_TX_P0 |\n\t\t\t   PHY_FIFO_RST_AUX_TX_P0_MASK |\n\t\t\t   MCU_REQ_DATA_NUM_AUX_TX_P0_MASK);\n}\n\nstatic void mtk_dp_aux_request_ready(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3630,\n\t\t\t   AUX_TX_REQUEST_READY_AUX_TX_P0,\n\t\t\t   AUX_TX_REQUEST_READY_AUX_TX_P0);\n}\n\nstatic void mtk_dp_aux_fill_write_fifo(struct mtk_dp *mtk_dp, u8 *buf,\n\t\t\t\t       size_t length)\n{\n\tmtk_dp_bulk_16bit_write(mtk_dp, MTK_DP_AUX_P0_3708, buf, length);\n}\n\nstatic void mtk_dp_aux_read_rx_fifo(struct mtk_dp *mtk_dp, u8 *buf,\n\t\t\t\t    size_t length, int read_delay)\n{\n\tint read_pos;\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3620,\n\t\t\t   0, AUX_RD_MODE_AUX_TX_P0_MASK);\n\n\tfor (read_pos = 0; read_pos < length; read_pos++) {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3620,\n\t\t\t\t   AUX_RX_FIFO_READ_PULSE_TX_P0,\n\t\t\t\t   AUX_RX_FIFO_READ_PULSE_TX_P0);\n\n\t\t \n\t\tusleep_range(read_delay, read_delay * 2);\n\t\tbuf[read_pos] = (u8)(mtk_dp_read(mtk_dp, MTK_DP_AUX_P0_3620) &\n\t\t\t\t     AUX_RX_FIFO_READ_DATA_AUX_TX_P0_MASK);\n\t}\n}\n\nstatic void mtk_dp_aux_set_length(struct mtk_dp *mtk_dp, size_t length)\n{\n\tif (length > 0) {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3650,\n\t\t\t\t   (length - 1) << 12,\n\t\t\t\t   MCU_REQ_DATA_NUM_AUX_TX_P0_MASK);\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_362C,\n\t\t\t\t   0,\n\t\t\t\t   AUX_NO_LENGTH_AUX_TX_P0 |\n\t\t\t\t   AUX_TX_AUXTX_OV_EN_AUX_TX_P0_MASK |\n\t\t\t\t   AUX_RESERVED_RW_0_AUX_TX_P0_MASK);\n\t} else {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_362C,\n\t\t\t\t   AUX_NO_LENGTH_AUX_TX_P0,\n\t\t\t\t   AUX_NO_LENGTH_AUX_TX_P0 |\n\t\t\t\t   AUX_TX_AUXTX_OV_EN_AUX_TX_P0_MASK |\n\t\t\t\t   AUX_RESERVED_RW_0_AUX_TX_P0_MASK);\n\t}\n}\n\nstatic int mtk_dp_aux_wait_for_completion(struct mtk_dp *mtk_dp, bool is_read)\n{\n\tint wait_reply = MTK_DP_AUX_WAIT_REPLY_COUNT;\n\n\twhile (--wait_reply) {\n\t\tu32 aux_irq_status;\n\n\t\tif (is_read) {\n\t\t\tu32 fifo_status = mtk_dp_read(mtk_dp, MTK_DP_AUX_P0_3618);\n\n\t\t\tif (fifo_status &\n\t\t\t    (AUX_RX_FIFO_WRITE_POINTER_AUX_TX_P0_MASK |\n\t\t\t     AUX_RX_FIFO_FULL_AUX_TX_P0_MASK)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\taux_irq_status = mtk_dp_read(mtk_dp, MTK_DP_AUX_P0_3640);\n\t\tif (aux_irq_status & AUX_RX_AUX_RECV_COMPLETE_IRQ_AUX_TX_P0)\n\t\t\treturn 0;\n\n\t\tif (aux_irq_status & AUX_400US_TIMEOUT_IRQ_AUX_TX_P0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\t \n\t\tusleep_range(100, 500);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mtk_dp_aux_do_transfer(struct mtk_dp *mtk_dp, bool is_read, u8 cmd,\n\t\t\t\t  u32 addr, u8 *buf, size_t length, u8 *reply_cmd)\n{\n\tint ret;\n\n\tif (is_read && (length > DP_AUX_MAX_PAYLOAD_BYTES ||\n\t\t\t(cmd == DP_AUX_NATIVE_READ && !length)))\n\t\treturn -EINVAL;\n\n\tif (!is_read)\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3704,\n\t\t\t\t   AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0,\n\t\t\t\t   AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0);\n\n\t \n\tmtk_dp_aux_clear_fifo(mtk_dp);\n\tmtk_dp_aux_irq_clear(mtk_dp);\n\n\tmtk_dp_aux_set_cmd(mtk_dp, cmd, addr);\n\tmtk_dp_aux_set_length(mtk_dp, length);\n\n\tif (!is_read) {\n\t\tif (length)\n\t\t\tmtk_dp_aux_fill_write_fifo(mtk_dp, buf, length);\n\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3704,\n\t\t\t\t   AUX_TX_FIFO_WDATA_NEW_MODE_T_AUX_TX_P0_MASK,\n\t\t\t\t   AUX_TX_FIFO_WDATA_NEW_MODE_T_AUX_TX_P0_MASK);\n\t}\n\n\tmtk_dp_aux_request_ready(mtk_dp);\n\n\t \n\tret = mtk_dp_aux_wait_for_completion(mtk_dp, is_read);\n\n\t*reply_cmd = mtk_dp_read(mtk_dp, MTK_DP_AUX_P0_3624) &\n\t\t     AUX_RX_REPLY_COMMAND_AUX_TX_P0_MASK;\n\n\tif (ret) {\n\t\tu32 phy_status = mtk_dp_read(mtk_dp, MTK_DP_AUX_P0_3628) &\n\t\t\t\t AUX_RX_PHY_STATE_AUX_TX_P0_MASK;\n\t\tif (phy_status != AUX_RX_PHY_STATE_AUX_TX_P0_RX_IDLE) {\n\t\t\tdev_err(mtk_dp->dev,\n\t\t\t\t\"AUX Rx Aux hang, need SW reset\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!length) {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_362C,\n\t\t\t\t   0,\n\t\t\t\t   AUX_NO_LENGTH_AUX_TX_P0 |\n\t\t\t\t   AUX_TX_AUXTX_OV_EN_AUX_TX_P0_MASK |\n\t\t\t\t   AUX_RESERVED_RW_0_AUX_TX_P0_MASK);\n\t} else if (is_read) {\n\t\tint read_delay;\n\n\t\tif (cmd == (DP_AUX_I2C_READ | DP_AUX_I2C_MOT) ||\n\t\t    cmd == DP_AUX_I2C_READ)\n\t\t\tread_delay = 500;\n\t\telse\n\t\t\tread_delay = 100;\n\n\t\tmtk_dp_aux_read_rx_fifo(mtk_dp, buf, length, read_delay);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_dp_set_swing_pre_emphasis(struct mtk_dp *mtk_dp, int lane_num,\n\t\t\t\t\t  int swing_val, int preemphasis)\n{\n\tu32 lane_shift = lane_num * DP_TX1_VOLT_SWING_SHIFT;\n\n\tdev_dbg(mtk_dp->dev,\n\t\t\"link training: swing_val = 0x%x, pre-emphasis = 0x%x\\n\",\n\t\tswing_val, preemphasis);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_SWING_EMP,\n\t\t\t   swing_val << (DP_TX0_VOLT_SWING_SHIFT + lane_shift),\n\t\t\t   DP_TX0_VOLT_SWING_MASK << lane_shift);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_SWING_EMP,\n\t\t\t   preemphasis << (DP_TX0_PRE_EMPH_SHIFT + lane_shift),\n\t\t\t   DP_TX0_PRE_EMPH_MASK << lane_shift);\n}\n\nstatic void mtk_dp_reset_swing_pre_emphasis(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_SWING_EMP,\n\t\t\t   0,\n\t\t\t   DP_TX0_VOLT_SWING_MASK |\n\t\t\t   DP_TX1_VOLT_SWING_MASK |\n\t\t\t   DP_TX2_VOLT_SWING_MASK |\n\t\t\t   DP_TX3_VOLT_SWING_MASK |\n\t\t\t   DP_TX0_PRE_EMPH_MASK |\n\t\t\t   DP_TX1_PRE_EMPH_MASK |\n\t\t\t   DP_TX2_PRE_EMPH_MASK |\n\t\t\t   DP_TX3_PRE_EMPH_MASK);\n}\n\nstatic u32 mtk_dp_swirq_get_clear(struct mtk_dp *mtk_dp)\n{\n\tu32 irq_status = mtk_dp_read(mtk_dp, MTK_DP_TRANS_P0_35D0) &\n\t\t\t SW_IRQ_FINAL_STATUS_DP_TRANS_P0_MASK;\n\n\tif (irq_status) {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_35C8,\n\t\t\t\t   irq_status, SW_IRQ_CLR_DP_TRANS_P0_MASK);\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_35C8,\n\t\t\t\t   0, SW_IRQ_CLR_DP_TRANS_P0_MASK);\n\t}\n\n\treturn irq_status;\n}\n\nstatic u32 mtk_dp_hwirq_get_clear(struct mtk_dp *mtk_dp)\n{\n\tu32 irq_status = (mtk_dp_read(mtk_dp, MTK_DP_TRANS_P0_3418) &\n\t\t\t  IRQ_STATUS_DP_TRANS_P0_MASK) >> 12;\n\n\tif (irq_status) {\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3418,\n\t\t\t\t   irq_status, IRQ_CLR_DP_TRANS_P0_MASK);\n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3418,\n\t\t\t\t   0, IRQ_CLR_DP_TRANS_P0_MASK);\n\t}\n\n\treturn irq_status;\n}\n\nstatic void mtk_dp_hwirq_enable(struct mtk_dp *mtk_dp, bool enable)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3418,\n\t\t\t   enable ? 0 :\n\t\t\t   IRQ_MASK_DP_TRANS_P0_DISC_IRQ |\n\t\t\t   IRQ_MASK_DP_TRANS_P0_CONN_IRQ |\n\t\t\t   IRQ_MASK_DP_TRANS_P0_INT_IRQ,\n\t\t\t   IRQ_MASK_DP_TRANS_P0_MASK);\n}\n\nstatic void mtk_dp_initialize_settings(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_342C,\n\t\t\t   XTAL_FREQ_DP_TRANS_P0_DEFAULT,\n\t\t\t   XTAL_FREQ_DP_TRANS_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3540,\n\t\t\t   FEC_CLOCK_EN_MODE_DP_TRANS_P0,\n\t\t\t   FEC_CLOCK_EN_MODE_DP_TRANS_P0);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_31EC,\n\t\t\t   AUDIO_CH_SRC_SEL_DP_ENC0_P0,\n\t\t\t   AUDIO_CH_SRC_SEL_DP_ENC0_P0);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_304C,\n\t\t\t   0, SDP_VSYNC_RISING_MASK_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_IRQ_MASK,\n\t\t\t   IRQ_MASK_AUX_TOP_IRQ, IRQ_MASK_AUX_TOP_IRQ);\n}\n\nstatic void mtk_dp_initialize_hpd_detect_settings(struct mtk_dp *mtk_dp)\n{\n\tu32 val;\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3410,\n\t\t\t   8, HPD_DEB_THD_DP_TRANS_P0_MASK);\n\n\tval = (HPD_INT_THD_DP_TRANS_P0_LOWER_500US |\n\t       HPD_INT_THD_DP_TRANS_P0_UPPER_1100US) << 4;\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3410,\n\t\t\t   val, HPD_INT_THD_DP_TRANS_P0_MASK);\n\n\t \n\tval = (5 << 8) | (5 << 12);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3410,\n\t\t\t   val,\n\t\t\t   HPD_DISC_THD_DP_TRANS_P0_MASK |\n\t\t\t   HPD_CONN_THD_DP_TRANS_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3430,\n\t\t\t   HPD_INT_THD_ECO_DP_TRANS_P0_HIGH_BOUND_EXT,\n\t\t\t   HPD_INT_THD_ECO_DP_TRANS_P0_MASK);\n}\n\nstatic void mtk_dp_initialize_aux_settings(struct mtk_dp *mtk_dp)\n{\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_360C,\n\t\t\t   AUX_TIMEOUT_THR_AUX_TX_P0_VAL,\n\t\t\t   AUX_TIMEOUT_THR_AUX_TX_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3658,\n\t\t\t   0, AUX_TX_OV_EN_AUX_TX_P0_MASK);\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3634,\n\t\t\t   AUX_TX_OVER_SAMPLE_RATE_FOR_26M << 8,\n\t\t\t   AUX_TX_OVER_SAMPLE_RATE_AUX_TX_P0_MASK);\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3614,\n\t\t\t   AUX_RX_UI_CNT_THR_AUX_FOR_26M,\n\t\t\t   AUX_RX_UI_CNT_THR_AUX_TX_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_37C8,\n\t\t\t   MTK_ATOP_EN_AUX_TX_P0,\n\t\t\t   MTK_ATOP_EN_AUX_TX_P0);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3690,\n\t\t\t   RX_REPLY_COMPLETE_MODE_AUX_TX_P0,\n\t\t\t   RX_REPLY_COMPLETE_MODE_AUX_TX_P0);\n}\n\nstatic void mtk_dp_initialize_digital_settings(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_304C,\n\t\t\t   0, VBID_VIDEO_MUTE_DP_ENC0_P0_MASK);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3368,\n\t\t\t   BS2BS_MODE_DP_ENC1_P0_VAL << 12,\n\t\t\t   BS2BS_MODE_DP_ENC1_P0_MASK);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3004,\n\t\t\t   DP_TX_ENCODER_4P_RESET_SW_DP_ENC0_P0,\n\t\t\t   DP_TX_ENCODER_4P_RESET_SW_DP_ENC0_P0);\n\n\t \n\tusleep_range(1000, 5000);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3004,\n\t\t\t   0, DP_TX_ENCODER_4P_RESET_SW_DP_ENC0_P0);\n}\n\nstatic void mtk_dp_digital_sw_reset(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_340C,\n\t\t\t   DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0,\n\t\t\t   DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0);\n\n\t \n\tusleep_range(1000, 5000);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_340C,\n\t\t\t   0, DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0);\n}\n\nstatic void mtk_dp_set_lanes(struct mtk_dp *mtk_dp, int lanes)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_35F0,\n\t\t\t   lanes == 0 ? 0 : DP_TRANS_DUMMY_RW_0,\n\t\t\t   DP_TRANS_DUMMY_RW_0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3000,\n\t\t\t   lanes, LANE_NUM_DP_ENC0_P0_MASK);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_34A4,\n\t\t\t   lanes << 2, LANE_NUM_DP_TRANS_P0_MASK);\n}\n\nstatic void mtk_dp_get_calibration_data(struct mtk_dp *mtk_dp)\n{\n\tconst struct mtk_dp_efuse_fmt *fmt;\n\tstruct device *dev = mtk_dp->dev;\n\tstruct nvmem_cell *cell;\n\tu32 *cal_data = mtk_dp->cal_data;\n\tu32 *buf;\n\tint i;\n\tsize_t len;\n\n\tcell = nvmem_cell_get(dev, \"dp_calibration_data\");\n\tif (IS_ERR(cell)) {\n\t\tdev_warn(dev, \"Failed to get nvmem cell dp_calibration_data\\n\");\n\t\tgoto use_default_val;\n\t}\n\n\tbuf = (u32 *)nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf) || ((len / sizeof(u32)) != 4)) {\n\t\tdev_warn(dev, \"Failed to read nvmem_cell_read\\n\");\n\n\t\tif (!IS_ERR(buf))\n\t\t\tkfree(buf);\n\n\t\tgoto use_default_val;\n\t}\n\n\tfor (i = 0; i < MTK_DP_CAL_MAX; i++) {\n\t\tfmt = &mtk_dp->data->efuse_fmt[i];\n\t\tcal_data[i] = (buf[fmt->idx] >> fmt->shift) & fmt->mask;\n\n\t\tif (cal_data[i] < fmt->min_val || cal_data[i] > fmt->max_val) {\n\t\t\tdev_warn(mtk_dp->dev, \"Invalid efuse data, idx = %d\\n\", i);\n\t\t\tkfree(buf);\n\t\t\tgoto use_default_val;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn;\n\nuse_default_val:\n\tdev_warn(mtk_dp->dev, \"Use default calibration data\\n\");\n\tfor (i = 0; i < MTK_DP_CAL_MAX; i++)\n\t\tcal_data[i] = mtk_dp->data->efuse_fmt[i].default_val;\n}\n\nstatic void mtk_dp_set_calibration_data(struct mtk_dp *mtk_dp)\n{\n\tu32 *cal_data = mtk_dp->cal_data;\n\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_GLB_DPAUX_TX,\n\t\t\t   cal_data[MTK_DP_CAL_CLKTX_IMPSE] << 20,\n\t\t\t   RG_CKM_PT0_CKTX_IMPSEL);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_GLB_BIAS_GEN_00,\n\t\t\t   cal_data[MTK_DP_CAL_GLB_BIAS_TRIM] << 16,\n\t\t\t   RG_XTP_GLB_BIAS_INTR_CTRL);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_0,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_0] << 12,\n\t\t\t   RG_XTP_LN0_TX_IMPSEL_PMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_0,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_0] << 16,\n\t\t\t   RG_XTP_LN0_TX_IMPSEL_NMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_1,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_1] << 12,\n\t\t\t   RG_XTP_LN1_TX_IMPSEL_PMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_1,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_1] << 16,\n\t\t\t   RG_XTP_LN1_TX_IMPSEL_NMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_2,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_2] << 12,\n\t\t\t   RG_XTP_LN2_TX_IMPSEL_PMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_2,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_2] << 16,\n\t\t\t   RG_XTP_LN2_TX_IMPSEL_NMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_3,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_3] << 12,\n\t\t\t   RG_XTP_LN3_TX_IMPSEL_PMOS);\n\tmtk_dp_update_bits(mtk_dp, DP_PHY_LANE_TX_3,\n\t\t\t   cal_data[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_3] << 16,\n\t\t\t   RG_XTP_LN3_TX_IMPSEL_NMOS);\n}\n\nstatic int mtk_dp_phy_configure(struct mtk_dp *mtk_dp,\n\t\t\t\tu32 link_rate, int lane_count)\n{\n\tint ret;\n\tunion phy_configure_opts phy_opts = {\n\t\t.dp = {\n\t\t\t.link_rate = drm_dp_bw_code_to_link_rate(link_rate) / 100,\n\t\t\t.set_rate = 1,\n\t\t\t.lanes = lane_count,\n\t\t\t.set_lanes = 1,\n\t\t\t.ssc = mtk_dp->train_info.sink_ssc,\n\t\t}\n\t};\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE, DP_PWR_STATE_BANDGAP,\n\t\t\t   DP_PWR_STATE_MASK);\n\n\tret = phy_configure(mtk_dp->phy, &phy_opts);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_dp_set_calibration_data(mtk_dp);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t   DP_PWR_STATE_BANDGAP_TPLL_LANE, DP_PWR_STATE_MASK);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_set_idle_pattern(struct mtk_dp *mtk_dp, bool enable)\n{\n\tu32 val = POST_MISC_DATA_LANE0_OV_DP_TRANS_P0_MASK |\n\t\t  POST_MISC_DATA_LANE1_OV_DP_TRANS_P0_MASK |\n\t\t  POST_MISC_DATA_LANE2_OV_DP_TRANS_P0_MASK |\n\t\t  POST_MISC_DATA_LANE3_OV_DP_TRANS_P0_MASK;\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3580,\n\t\t\t   enable ? val : 0, val);\n}\n\nstatic void mtk_dp_train_set_pattern(struct mtk_dp *mtk_dp, int pattern)\n{\n\t \n\tif (pattern == 1)\n\t\tmtk_dp_set_idle_pattern(mtk_dp, false);\n\n\tmtk_dp_update_bits(mtk_dp,\n\t\t\t   MTK_DP_TRANS_P0_3400,\n\t\t\t   pattern ? BIT(pattern - 1) << 12 : 0,\n\t\t\t   PATTERN1_EN_DP_TRANS_P0_MASK |\n\t\t\t   PATTERN2_EN_DP_TRANS_P0_MASK |\n\t\t\t   PATTERN3_EN_DP_TRANS_P0_MASK |\n\t\t\t   PATTERN4_EN_DP_TRANS_P0_MASK);\n}\n\nstatic void mtk_dp_set_enhanced_frame_mode(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3000,\n\t\t\t   ENHANCED_FRAME_EN_DP_ENC0_P0,\n\t\t\t   ENHANCED_FRAME_EN_DP_ENC0_P0);\n}\n\nstatic void mtk_dp_training_set_scramble(struct mtk_dp *mtk_dp, bool enable)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3404,\n\t\t\t   enable ? DP_SCR_EN_DP_TRANS_P0_MASK : 0,\n\t\t\t   DP_SCR_EN_DP_TRANS_P0_MASK);\n}\n\nstatic void mtk_dp_video_mute(struct mtk_dp *mtk_dp, bool enable)\n{\n\tstruct arm_smccc_res res;\n\tu32 val = VIDEO_MUTE_SEL_DP_ENC0_P0 |\n\t\t  (enable ? VIDEO_MUTE_SW_DP_ENC0_P0 : 0);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3000,\n\t\t\t   val,\n\t\t\t   VIDEO_MUTE_SEL_DP_ENC0_P0 |\n\t\t\t   VIDEO_MUTE_SW_DP_ENC0_P0);\n\n\tarm_smccc_smc(MTK_DP_SIP_CONTROL_AARCH32,\n\t\t      mtk_dp->data->smc_cmd, enable,\n\t\t      0, 0, 0, 0, 0, &res);\n\n\tdev_dbg(mtk_dp->dev, \"smc cmd: 0x%x, p1: %s, ret: 0x%lx-0x%lx\\n\",\n\t\tmtk_dp->data->smc_cmd, enable ? \"enable\" : \"disable\", res.a0, res.a1);\n}\n\nstatic void mtk_dp_audio_mute(struct mtk_dp *mtk_dp, bool mute)\n{\n\tu32 val[3];\n\n\tif (mute) {\n\t\tval[0] = VBID_AUDIO_MUTE_FLAG_SW_DP_ENC0_P0 |\n\t\t\t VBID_AUDIO_MUTE_FLAG_SEL_DP_ENC0_P0;\n\t\tval[1] = 0;\n\t\tval[2] = 0;\n\t} else {\n\t\tval[0] = 0;\n\t\tval[1] = AU_EN_DP_ENC0_P0;\n\t\t \n\t\tval[2] = 0x0F;\n\t}\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3030,\n\t\t\t   val[0],\n\t\t\t   VBID_AUDIO_MUTE_FLAG_SW_DP_ENC0_P0 |\n\t\t\t   VBID_AUDIO_MUTE_FLAG_SEL_DP_ENC0_P0);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3088,\n\t\t\t   val[1], AU_EN_DP_ENC0_P0);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_30A4,\n\t\t\t   val[2], AU_TS_CFG_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_aux_panel_poweron(struct mtk_dp *mtk_dp, bool pwron)\n{\n\tif (pwron) {\n\t\t \n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t\t   DP_PWR_STATE_BANDGAP_TPLL_LANE,\n\t\t\t\t   DP_PWR_STATE_MASK);\n\n\t\t \n\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_SET_POWER, DP_SET_POWER_D0);\n\t\tusleep_range(2000, 5000);\n\t} else {\n\t\t \n\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_SET_POWER, DP_SET_POWER_D3);\n\t\tusleep_range(2000, 3000);\n\n\t\t \n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t\t   DP_PWR_STATE_BANDGAP_TPLL,\n\t\t\t\t   DP_PWR_STATE_MASK);\n\t}\n}\n\nstatic void mtk_dp_power_enable(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_RESET_AND_PROBE,\n\t\t\t   0, SW_RST_B_PHYD);\n\n\t \n\tusleep_range(10, 200);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_RESET_AND_PROBE,\n\t\t\t   SW_RST_B_PHYD, SW_RST_B_PHYD);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t   DP_PWR_STATE_BANDGAP_TPLL, DP_PWR_STATE_MASK);\n\tmtk_dp_write(mtk_dp, MTK_DP_1040,\n\t\t     RG_DPAUX_RX_VALID_DEGLITCH_EN | RG_XTP_GLB_CKDET_EN |\n\t\t     RG_DPAUX_RX_EN);\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_0034, 0, DA_CKM_CKTX0_EN_FORCE_EN);\n}\n\nstatic void mtk_dp_power_disable(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_write(mtk_dp, MTK_DP_TOP_PWR_STATE, 0);\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_0034,\n\t\t\t   DA_CKM_CKTX0_EN_FORCE_EN, DA_CKM_CKTX0_EN_FORCE_EN);\n\n\t \n\tmtk_dp_write(mtk_dp, MTK_DP_1040, 0);\n\tmtk_dp_write(mtk_dp, MTK_DP_TOP_MEM_PD,\n\t\t     0x550 | FUSE_SEL | MEM_ISO_EN);\n}\n\nstatic void mtk_dp_initialize_priv_data(struct mtk_dp *mtk_dp)\n{\n\tbool plugged_in = (mtk_dp->bridge.type == DRM_MODE_CONNECTOR_eDP);\n\n\tmtk_dp->train_info.link_rate = DP_LINK_BW_5_4;\n\tmtk_dp->train_info.lane_count = mtk_dp->max_lanes;\n\tmtk_dp->train_info.cable_plugged_in = plugged_in;\n\n\tmtk_dp->info.format = DP_PIXELFORMAT_RGB;\n\tmemset(&mtk_dp->info.vm, 0, sizeof(struct videomode));\n\tmtk_dp->audio_enable = false;\n}\n\nstatic void mtk_dp_sdp_set_down_cnt_init(struct mtk_dp *mtk_dp,\n\t\t\t\t\t u32 sram_read_start)\n{\n\tu32 sdp_down_cnt_init = 0;\n\tstruct drm_display_mode mode;\n\tstruct videomode *vm = &mtk_dp->info.vm;\n\n\tdrm_display_mode_from_videomode(vm, &mode);\n\n\tif (mode.clock > 0)\n\t\tsdp_down_cnt_init = sram_read_start *\n\t\t\t\t    mtk_dp->train_info.link_rate * 2700 * 8 /\n\t\t\t\t    (mode.clock * 4);\n\n\tswitch (mtk_dp->train_info.lane_count) {\n\tcase 1:\n\t\tsdp_down_cnt_init = max_t(u32, sdp_down_cnt_init, 0x1A);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tsdp_down_cnt_init = max_t(u32, sdp_down_cnt_init, 0x10);\n\t\tsdp_down_cnt_init += mode.vtotal <= 525 ? 4 : 0;\n\t\tbreak;\n\tcase 4:\n\tdefault:\n\t\tsdp_down_cnt_init = max_t(u32, sdp_down_cnt_init, 6);\n\t\tbreak;\n\t}\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3040,\n\t\t\t   sdp_down_cnt_init,\n\t\t\t   SDP_DOWN_CNT_INIT_DP_ENC0_P0_MASK);\n}\n\nstatic void mtk_dp_sdp_set_down_cnt_init_in_hblank(struct mtk_dp *mtk_dp)\n{\n\tint pix_clk_mhz;\n\tu32 dc_offset;\n\tu32 spd_down_cnt_init = 0;\n\tstruct drm_display_mode mode;\n\tstruct videomode *vm = &mtk_dp->info.vm;\n\n\tdrm_display_mode_from_videomode(vm, &mode);\n\n\tpix_clk_mhz = mtk_dp->info.format == DP_PIXELFORMAT_YUV420 ?\n\t\t      mode.clock / 2000 : mode.clock / 1000;\n\n\tswitch (mtk_dp->train_info.lane_count) {\n\tcase 1:\n\t\tspd_down_cnt_init = 0x20;\n\t\tbreak;\n\tcase 2:\n\t\tdc_offset = (mode.vtotal <= 525) ? 0x14 : 0x00;\n\t\tspd_down_cnt_init = 0x18 + dc_offset;\n\t\tbreak;\n\tcase 4:\n\tdefault:\n\t\tdc_offset = (mode.vtotal <= 525) ? 0x08 : 0x00;\n\t\tif (pix_clk_mhz > mtk_dp->train_info.link_rate * 27)\n\t\t\tspd_down_cnt_init = 0x8;\n\t\telse\n\t\t\tspd_down_cnt_init = 0x10 + dc_offset;\n\t\tbreak;\n\t}\n\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3364, spd_down_cnt_init,\n\t\t\t   SDP_DOWN_CNT_INIT_IN_HBLANK_DP_ENC1_P0_MASK);\n}\n\nstatic void mtk_dp_setup_tu(struct mtk_dp *mtk_dp)\n{\n\tu32 sram_read_start = min_t(u32, MTK_DP_TBC_BUF_READ_START_ADDR,\n\t\t\t\t    mtk_dp->info.vm.hactive /\n\t\t\t\t    mtk_dp->train_info.lane_count /\n\t\t\t\t    MTK_DP_4P1T / MTK_DP_HDE /\n\t\t\t\t    MTK_DP_PIX_PER_ADDR);\n\tmtk_dp_set_sram_read_start(mtk_dp, sram_read_start);\n\tmtk_dp_setup_encoder(mtk_dp);\n\tmtk_dp_sdp_set_down_cnt_init_in_hblank(mtk_dp);\n\tmtk_dp_sdp_set_down_cnt_init(mtk_dp, sram_read_start);\n}\n\nstatic void mtk_dp_set_tx_out(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_setup_tu(mtk_dp);\n}\n\nstatic void mtk_dp_train_update_swing_pre(struct mtk_dp *mtk_dp, int lanes,\n\t\t\t\t\t  u8 dpcd_adjust_req[2])\n{\n\tint lane;\n\n\tfor (lane = 0; lane < lanes; ++lane) {\n\t\tu8 val;\n\t\tu8 swing;\n\t\tu8 preemphasis;\n\t\tint index = lane / 2;\n\t\tint shift = lane % 2 ? DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT : 0;\n\n\t\tswing = (dpcd_adjust_req[index] >> shift) &\n\t\t\tDP_ADJUST_VOLTAGE_SWING_LANE0_MASK;\n\t\tpreemphasis = ((dpcd_adjust_req[index] >> shift) &\n\t\t\t       DP_ADJUST_PRE_EMPHASIS_LANE0_MASK) >>\n\t\t\t      DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT;\n\t\tval = swing << DP_TRAIN_VOLTAGE_SWING_SHIFT |\n\t\t      preemphasis << DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t\tif (swing == DP_TRAIN_VOLTAGE_SWING_LEVEL_3)\n\t\t\tval |= DP_TRAIN_MAX_SWING_REACHED;\n\t\tif (preemphasis == 3)\n\t\t\tval |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\t\tmtk_dp_set_swing_pre_emphasis(mtk_dp, lane, swing, preemphasis);\n\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_TRAINING_LANE0_SET + lane,\n\t\t\t\t   val);\n\t}\n}\n\nstatic void mtk_dp_pattern(struct mtk_dp *mtk_dp, bool is_tps1)\n{\n\tint pattern;\n\tunsigned int aux_offset;\n\n\tif (is_tps1) {\n\t\tpattern = 1;\n\t\taux_offset = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_1;\n\t} else {\n\t\taux_offset = mtk_dp->train_info.channel_eq_pattern;\n\n\t\tswitch (mtk_dp->train_info.channel_eq_pattern) {\n\t\tcase DP_TRAINING_PATTERN_4:\n\t\t\tpattern = 4;\n\t\t\tbreak;\n\t\tcase DP_TRAINING_PATTERN_3:\n\t\t\tpattern = 3;\n\t\t\taux_offset |= DP_LINK_SCRAMBLING_DISABLE;\n\t\t\tbreak;\n\t\tcase DP_TRAINING_PATTERN_2:\n\t\tdefault:\n\t\t\tpattern = 2;\n\t\t\taux_offset |= DP_LINK_SCRAMBLING_DISABLE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmtk_dp_train_set_pattern(mtk_dp, pattern);\n\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_TRAINING_PATTERN_SET, aux_offset);\n}\n\nstatic int mtk_dp_train_setting(struct mtk_dp *mtk_dp, u8 target_link_rate,\n\t\t\t\tu8 target_lane_count)\n{\n\tint ret;\n\n\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_LINK_BW_SET, target_link_rate);\n\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_LANE_COUNT_SET,\n\t\t\t   target_lane_count | DP_LANE_COUNT_ENHANCED_FRAME_EN);\n\n\tif (mtk_dp->train_info.sink_ssc)\n\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_DOWNSPREAD_CTRL,\n\t\t\t\t   DP_SPREAD_AMP_0_5);\n\n\tmtk_dp_set_lanes(mtk_dp, target_lane_count / 2);\n\tret = mtk_dp_phy_configure(mtk_dp, target_link_rate, target_lane_count);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(mtk_dp->dev,\n\t\t\"Link train target_link_rate = 0x%x, target_lane_count = 0x%x\\n\",\n\t\ttarget_link_rate, target_lane_count);\n\n\treturn 0;\n}\n\nstatic int mtk_dp_train_cr(struct mtk_dp *mtk_dp, u8 target_lane_count)\n{\n\tu8 lane_adjust[2] = {};\n\tu8 link_status[DP_LINK_STATUS_SIZE] = {};\n\tu8 prev_lane_adjust = 0xff;\n\tint train_retries = 0;\n\tint voltage_retries = 0;\n\n\tmtk_dp_pattern(mtk_dp, true);\n\n\t \n\tdo {\n\t\ttrain_retries++;\n\t\tif (!mtk_dp->train_info.cable_plugged_in) {\n\t\t\tmtk_dp_train_set_pattern(mtk_dp, 0);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdrm_dp_dpcd_read(&mtk_dp->aux, DP_ADJUST_REQUEST_LANE0_1,\n\t\t\t\t lane_adjust, sizeof(lane_adjust));\n\t\tmtk_dp_train_update_swing_pre(mtk_dp, target_lane_count,\n\t\t\t\t\t      lane_adjust);\n\n\t\tdrm_dp_link_train_clock_recovery_delay(&mtk_dp->aux,\n\t\t\t\t\t\t       mtk_dp->rx_cap);\n\n\t\t \n\t\tdrm_dp_dpcd_read_link_status(&mtk_dp->aux, link_status);\n\t\tif (drm_dp_clock_recovery_ok(link_status,\n\t\t\t\t\t     target_lane_count)) {\n\t\t\tdev_dbg(mtk_dp->dev, \"Link train CR pass\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (prev_lane_adjust == link_status[4]) {\n\t\t\tvoltage_retries++;\n\t\t\t \n\t\t\tif (voltage_retries > MTK_DP_TRAIN_VOLTAGE_LEVEL_RETRY ||\n\t\t\t    (prev_lane_adjust & DP_ADJUST_VOLTAGE_SWING_LANE0_MASK) == 3) {\n\t\t\t\tdev_dbg(mtk_dp->dev, \"Link train CR fail\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tvoltage_retries = 0;\n\t\t}\n\t\tprev_lane_adjust = link_status[4];\n\t} while (train_retries < MTK_DP_TRAIN_DOWNSCALE_RETRY);\n\n\t \n\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\tmtk_dp_train_set_pattern(mtk_dp, 0);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mtk_dp_train_eq(struct mtk_dp *mtk_dp, u8 target_lane_count)\n{\n\tu8 lane_adjust[2] = {};\n\tu8 link_status[DP_LINK_STATUS_SIZE] = {};\n\tint train_retries = 0;\n\n\tmtk_dp_pattern(mtk_dp, false);\n\n\tdo {\n\t\ttrain_retries++;\n\t\tif (!mtk_dp->train_info.cable_plugged_in) {\n\t\t\tmtk_dp_train_set_pattern(mtk_dp, 0);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdrm_dp_dpcd_read(&mtk_dp->aux, DP_ADJUST_REQUEST_LANE0_1,\n\t\t\t\t lane_adjust, sizeof(lane_adjust));\n\t\tmtk_dp_train_update_swing_pre(mtk_dp, target_lane_count,\n\t\t\t\t\t      lane_adjust);\n\n\t\tdrm_dp_link_train_channel_eq_delay(&mtk_dp->aux,\n\t\t\t\t\t\t   mtk_dp->rx_cap);\n\n\t\t \n\t\tdrm_dp_dpcd_read_link_status(&mtk_dp->aux, link_status);\n\t\tif (drm_dp_channel_eq_ok(link_status, target_lane_count)) {\n\t\t\tdev_dbg(mtk_dp->dev, \"Link train EQ pass\\n\");\n\n\t\t\t \n\t\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\t\t\tmtk_dp_train_set_pattern(mtk_dp, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tdev_dbg(mtk_dp->dev, \"Link train EQ fail\\n\");\n\t} while (train_retries < MTK_DP_TRAIN_DOWNSCALE_RETRY);\n\n\t \n\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\tmtk_dp_train_set_pattern(mtk_dp, 0);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mtk_dp_parse_capabilities(struct mtk_dp *mtk_dp)\n{\n\tu8 val;\n\tssize_t ret;\n\n\t \n\tif (mtk_dp->bridge.type == DRM_MODE_CONNECTOR_eDP &&\n\t    mtk_dp->rx_cap[DP_MAX_LINK_RATE] &&\n\t    mtk_dp->train_info.sink_ssc)\n\t\treturn 0;\n\n\tret = drm_dp_read_dpcd_caps(&mtk_dp->aux, mtk_dp->rx_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (drm_dp_tps4_supported(mtk_dp->rx_cap))\n\t\tmtk_dp->train_info.channel_eq_pattern = DP_TRAINING_PATTERN_4;\n\telse if (drm_dp_tps3_supported(mtk_dp->rx_cap))\n\t\tmtk_dp->train_info.channel_eq_pattern = DP_TRAINING_PATTERN_3;\n\telse\n\t\tmtk_dp->train_info.channel_eq_pattern = DP_TRAINING_PATTERN_2;\n\n\tmtk_dp->train_info.sink_ssc = drm_dp_max_downspread(mtk_dp->rx_cap);\n\n\tret = drm_dp_dpcd_readb(&mtk_dp->aux, DP_MSTM_CAP, &val);\n\tif (ret < 1) {\n\t\tdrm_err(mtk_dp->drm_dev, \"Read mstm cap failed\\n\");\n\t\treturn ret == 0 ? -EIO : ret;\n\t}\n\n\tif (val & DP_MST_CAP) {\n\t\t \n\t\tret = drm_dp_dpcd_readb(&mtk_dp->aux,\n\t\t\t\t\tDP_DEVICE_SERVICE_IRQ_VECTOR_ESI0,\n\t\t\t\t\t&val);\n\t\tif (ret < 1) {\n\t\t\tdrm_err(mtk_dp->drm_dev, \"Read irq vector failed\\n\");\n\t\t\treturn ret == 0 ? -EIO : ret;\n\t\t}\n\n\t\tif (val) {\n\t\t\tret = drm_dp_dpcd_writeb(&mtk_dp->aux,\n\t\t\t\t\t\t DP_DEVICE_SERVICE_IRQ_VECTOR_ESI0,\n\t\t\t\t\t\t val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool mtk_dp_edid_parse_audio_capabilities(struct mtk_dp *mtk_dp,\n\t\t\t\t\t\t struct mtk_dp_audio_cfg *cfg)\n{\n\tif (!mtk_dp->data->audio_supported)\n\t\treturn false;\n\n\tif (mtk_dp->info.audio_cur_cfg.sad_count <= 0) {\n\t\tdrm_info(mtk_dp->drm_dev, \"The SADs is NULL\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void mtk_dp_train_change_mode(struct mtk_dp *mtk_dp)\n{\n\tphy_reset(mtk_dp->phy);\n\tmtk_dp_reset_swing_pre_emphasis(mtk_dp);\n}\n\nstatic int mtk_dp_training(struct mtk_dp *mtk_dp)\n{\n\tint ret;\n\tu8 lane_count, link_rate, train_limit, max_link_rate;\n\n\tlink_rate = min_t(u8, mtk_dp->max_linkrate,\n\t\t\t  mtk_dp->rx_cap[DP_MAX_LINK_RATE]);\n\tmax_link_rate = link_rate;\n\tlane_count = min_t(u8, mtk_dp->max_lanes,\n\t\t\t   drm_dp_max_lane_count(mtk_dp->rx_cap));\n\n\t \n\tmtk_dp_training_set_scramble(mtk_dp, false);\n\n\tfor (train_limit = 6; train_limit > 0; train_limit--) {\n\t\tmtk_dp_train_change_mode(mtk_dp);\n\n\t\tret = mtk_dp_train_setting(mtk_dp, link_rate, lane_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mtk_dp_train_cr(mtk_dp, lane_count);\n\t\tif (ret == -ENODEV) {\n\t\t\treturn ret;\n\t\t} else if (ret) {\n\t\t\t \n\t\t\tswitch (link_rate) {\n\t\t\tcase DP_LINK_BW_1_62:\n\t\t\t\tlane_count = lane_count / 2;\n\t\t\t\tlink_rate = max_link_rate;\n\t\t\t\tif (lane_count == 0)\n\t\t\t\t\treturn -EIO;\n\t\t\t\tbreak;\n\t\t\tcase DP_LINK_BW_2_7:\n\t\t\t\tlink_rate = DP_LINK_BW_1_62;\n\t\t\t\tbreak;\n\t\t\tcase DP_LINK_BW_5_4:\n\t\t\t\tlink_rate = DP_LINK_BW_2_7;\n\t\t\t\tbreak;\n\t\t\tcase DP_LINK_BW_8_1:\n\t\t\t\tlink_rate = DP_LINK_BW_5_4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = mtk_dp_train_eq(mtk_dp, lane_count);\n\t\tif (ret == -ENODEV) {\n\t\t\treturn ret;\n\t\t} else if (ret) {\n\t\t\t \n\t\t\tif (lane_count == 0)\n\t\t\t\treturn -EIO;\n\t\t\tlane_count /= 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t}\n\n\tif (train_limit == 0)\n\t\treturn -ETIMEDOUT;\n\n\tmtk_dp->train_info.link_rate = link_rate;\n\tmtk_dp->train_info.lane_count = lane_count;\n\n\t \n\tmtk_dp_training_set_scramble(mtk_dp, true);\n\tmtk_dp_set_enhanced_frame_mode(mtk_dp);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_video_enable(struct mtk_dp *mtk_dp, bool enable)\n{\n\t \n\tif (enable) {\n\t\tmtk_dp_msa_bypass_enable(mtk_dp, false);\n\t\tmtk_dp_pg_enable(mtk_dp, false);\n\t\tmtk_dp_set_tx_out(mtk_dp);\n\t\tmtk_dp_video_mute(mtk_dp, false);\n\t} else {\n\t\tmtk_dp_video_mute(mtk_dp, true);\n\t\tmtk_dp_pg_enable(mtk_dp, true);\n\t\tmtk_dp_msa_bypass_enable(mtk_dp, true);\n\t}\n}\n\nstatic void mtk_dp_audio_sdp_setup(struct mtk_dp *mtk_dp,\n\t\t\t\t   struct mtk_dp_audio_cfg *cfg)\n{\n\tstruct dp_sdp sdp;\n\tstruct hdmi_audio_infoframe frame;\n\n\thdmi_audio_infoframe_init(&frame);\n\tframe.coding_type = HDMI_AUDIO_CODING_TYPE_PCM;\n\tframe.channels = cfg->channels;\n\tframe.sample_frequency = cfg->sample_rate;\n\n\tswitch (cfg->word_length_bits) {\n\tcase 16:\n\t\tframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_16;\n\t\tbreak;\n\tcase 20:\n\t\tframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_20;\n\t\tbreak;\n\tcase 24:\n\tdefault:\n\t\tframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_24;\n\t\tbreak;\n\t}\n\n\thdmi_audio_infoframe_pack_for_dp(&frame, &sdp, MTK_DP_VERSION);\n\n\tmtk_dp_audio_sdp_asp_set_channels(mtk_dp, cfg->channels);\n\tmtk_dp_setup_sdp_aui(mtk_dp, &sdp);\n}\n\nstatic void mtk_dp_audio_setup(struct mtk_dp *mtk_dp,\n\t\t\t       struct mtk_dp_audio_cfg *cfg)\n{\n\tmtk_dp_audio_sdp_setup(mtk_dp, cfg);\n\tmtk_dp_audio_channel_status_set(mtk_dp, cfg);\n\n\tmtk_dp_audio_setup_channels(mtk_dp, cfg);\n\tmtk_dp_audio_set_divider(mtk_dp);\n}\n\nstatic int mtk_dp_video_config(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_config_mn_mode(mtk_dp);\n\tmtk_dp_set_msa(mtk_dp);\n\tmtk_dp_set_color_depth(mtk_dp);\n\treturn mtk_dp_set_color_format(mtk_dp, mtk_dp->info.format);\n}\n\nstatic void mtk_dp_init_port(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_set_idle_pattern(mtk_dp, true);\n\tmtk_dp_initialize_priv_data(mtk_dp);\n\n\tmtk_dp_initialize_settings(mtk_dp);\n\tmtk_dp_initialize_aux_settings(mtk_dp);\n\tmtk_dp_initialize_digital_settings(mtk_dp);\n\tmtk_dp_initialize_hpd_detect_settings(mtk_dp);\n\n\tmtk_dp_digital_sw_reset(mtk_dp);\n}\n\nstatic irqreturn_t mtk_dp_hpd_event_thread(int hpd, void *dev)\n{\n\tstruct mtk_dp *mtk_dp = dev;\n\tunsigned long flags;\n\tu32 status;\n\n\tif (mtk_dp->need_debounce && mtk_dp->train_info.cable_plugged_in)\n\t\tmsleep(100);\n\n\tspin_lock_irqsave(&mtk_dp->irq_thread_lock, flags);\n\tstatus = mtk_dp->irq_thread_handle;\n\tmtk_dp->irq_thread_handle = 0;\n\tspin_unlock_irqrestore(&mtk_dp->irq_thread_lock, flags);\n\n\tif (status & MTK_DP_THREAD_CABLE_STATE_CHG) {\n\t\tif (mtk_dp->bridge.dev)\n\t\t\tdrm_helper_hpd_irq_event(mtk_dp->bridge.dev);\n\n\t\tif (!mtk_dp->train_info.cable_plugged_in) {\n\t\t\tmtk_dp_disable_sdp_aui(mtk_dp);\n\t\t\tmemset(&mtk_dp->info.audio_cur_cfg, 0,\n\t\t\t       sizeof(mtk_dp->info.audio_cur_cfg));\n\n\t\t\tmtk_dp->need_debounce = false;\n\t\t\tmod_timer(&mtk_dp->debounce_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(100) - 1);\n\t\t}\n\t}\n\n\tif (status & MTK_DP_THREAD_HPD_EVENT)\n\t\tdev_dbg(mtk_dp->dev, \"Receive IRQ from sink devices\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtk_dp_hpd_event(int hpd, void *dev)\n{\n\tstruct mtk_dp *mtk_dp = dev;\n\tbool cable_sta_chg = false;\n\tunsigned long flags;\n\tu32 irq_status = mtk_dp_swirq_get_clear(mtk_dp) |\n\t\t\t mtk_dp_hwirq_get_clear(mtk_dp);\n\n\tif (!irq_status)\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&mtk_dp->irq_thread_lock, flags);\n\n\tif (irq_status & MTK_DP_HPD_INTERRUPT)\n\t\tmtk_dp->irq_thread_handle |= MTK_DP_THREAD_HPD_EVENT;\n\n\t \n\tif (irq_status != MTK_DP_HPD_INTERRUPT) {\n\t\tmtk_dp->irq_thread_handle |= MTK_DP_THREAD_CABLE_STATE_CHG;\n\t\tcable_sta_chg = true;\n\t}\n\n\tspin_unlock_irqrestore(&mtk_dp->irq_thread_lock, flags);\n\n\tif (cable_sta_chg) {\n\t\tif (!!(mtk_dp_read(mtk_dp, MTK_DP_TRANS_P0_3414) &\n\t\t       HPD_DB_DP_TRANS_P0_MASK))\n\t\t\tmtk_dp->train_info.cable_plugged_in = true;\n\t\telse\n\t\t\tmtk_dp->train_info.cable_plugged_in = false;\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int mtk_dp_wait_hpd_asserted(struct drm_dp_aux *mtk_aux, unsigned long wait_us)\n{\n\tstruct mtk_dp *mtk_dp = container_of(mtk_aux, struct mtk_dp, aux);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(mtk_dp->regs, MTK_DP_TRANS_P0_3414,\n\t\t\t\t       val, !!(val & HPD_DB_DP_TRANS_P0_MASK),\n\t\t\t\t       wait_us / 100, wait_us);\n\tif (ret) {\n\t\tmtk_dp->train_info.cable_plugged_in = false;\n\t\treturn ret;\n\t}\n\n\tmtk_dp->train_info.cable_plugged_in = true;\n\n\tret = mtk_dp_parse_capabilities(mtk_dp);\n\tif (ret) {\n\t\tdrm_err(mtk_dp->drm_dev, \"Can't parse capabilities\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dp_dt_parse(struct mtk_dp *mtk_dp,\n\t\t\t   struct platform_device *pdev)\n{\n\tstruct device_node *endpoint;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tvoid __iomem *base;\n\tu32 linkrate;\n\tint len;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmtk_dp->regs = devm_regmap_init_mmio(dev, base, &mtk_dp_regmap_config);\n\tif (IS_ERR(mtk_dp->regs))\n\t\treturn PTR_ERR(mtk_dp->regs);\n\n\tendpoint = of_graph_get_endpoint_by_regs(pdev->dev.of_node, 1, -1);\n\tlen = of_property_count_elems_of_size(endpoint,\n\t\t\t\t\t      \"data-lanes\", sizeof(u32));\n\tif (len < 0 || len > 4 || len == 3) {\n\t\tdev_err(dev, \"invalid data lane size: %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_dp->max_lanes = len;\n\n\tret = device_property_read_u32(dev, \"max-linkrate-mhz\", &linkrate);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read max linkrate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmtk_dp->max_linkrate = drm_dp_link_rate_to_bw_code(linkrate * 100);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_update_plugged_status(struct mtk_dp *mtk_dp)\n{\n\tif (!mtk_dp->data->audio_supported || !mtk_dp->audio_enable)\n\t\treturn;\n\n\tmutex_lock(&mtk_dp->update_plugged_status_lock);\n\tif (mtk_dp->plugged_cb && mtk_dp->codec_dev)\n\t\tmtk_dp->plugged_cb(mtk_dp->codec_dev,\n\t\t\t\t   mtk_dp->enabled &\n\t\t\t\t   mtk_dp->info.audio_cur_cfg.detect_monitor);\n\tmutex_unlock(&mtk_dp->update_plugged_status_lock);\n}\n\nstatic enum drm_connector_status mtk_dp_bdg_detect(struct drm_bridge *bridge)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tbool enabled = mtk_dp->enabled;\n\tu8 sink_count = 0;\n\n\tif (!mtk_dp->train_info.cable_plugged_in)\n\t\treturn ret;\n\n\tif (!enabled)\n\t\tmtk_dp_aux_panel_poweron(mtk_dp, true);\n\n\t \n\tdrm_dp_dpcd_readb(&mtk_dp->aux, DP_SINK_COUNT, &sink_count);\n\tif (DP_GET_SINK_COUNT(sink_count))\n\t\tret = connector_status_connected;\n\n\tif (!enabled)\n\t\tmtk_dp_aux_panel_poweron(mtk_dp, false);\n\n\treturn ret;\n}\n\nstatic struct edid *mtk_dp_get_edid(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tbool enabled = mtk_dp->enabled;\n\tstruct edid *new_edid = NULL;\n\tstruct mtk_dp_audio_cfg *audio_caps = &mtk_dp->info.audio_cur_cfg;\n\n\tif (!enabled) {\n\t\tdrm_atomic_bridge_chain_pre_enable(bridge, connector->state->state);\n\t\tmtk_dp_aux_panel_poweron(mtk_dp, true);\n\t}\n\n\tnew_edid = drm_get_edid(connector, &mtk_dp->aux.ddc);\n\n\t \n\tif (mtk_dp_parse_capabilities(mtk_dp)) {\n\t\tdrm_err(mtk_dp->drm_dev, \"Can't parse capabilities\\n\");\n\t\tkfree(new_edid);\n\t\tnew_edid = NULL;\n\t}\n\n\tif (new_edid) {\n\t\tstruct cea_sad *sads;\n\n\t\taudio_caps->sad_count = drm_edid_to_sad(new_edid, &sads);\n\t\tkfree(sads);\n\n\t\taudio_caps->detect_monitor = drm_detect_monitor_audio(new_edid);\n\t}\n\n\tif (!enabled) {\n\t\tmtk_dp_aux_panel_poweron(mtk_dp, false);\n\t\tdrm_atomic_bridge_chain_post_disable(bridge, connector->state->state);\n\t}\n\n\treturn new_edid;\n}\n\nstatic ssize_t mtk_dp_aux_transfer(struct drm_dp_aux *mtk_aux,\n\t\t\t\t   struct drm_dp_aux_msg *msg)\n{\n\tstruct mtk_dp *mtk_dp = container_of(mtk_aux, struct mtk_dp, aux);\n\tbool is_read;\n\tu8 request;\n\tsize_t accessed_bytes = 0;\n\tint ret;\n\n\tif (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP &&\n\t    !mtk_dp->train_info.cable_plugged_in) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (msg->request) {\n\tcase DP_AUX_I2C_MOT:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE | DP_AUX_I2C_MOT:\n\t\trequest = msg->request & ~DP_AUX_I2C_WRITE_STATUS_UPDATE;\n\t\tis_read = false;\n\t\tbreak;\n\tcase DP_AUX_I2C_READ:\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ | DP_AUX_I2C_MOT:\n\t\trequest = msg->request;\n\t\tis_read = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mtk_dp->dev, \"invalid aux cmd = %d\\n\",\n\t\t\tmsg->request);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdo {\n\t\tsize_t to_access = min_t(size_t, DP_AUX_MAX_PAYLOAD_BYTES,\n\t\t\t\t\t msg->size - accessed_bytes);\n\n\t\tret = mtk_dp_aux_do_transfer(mtk_dp, is_read, request,\n\t\t\t\t\t     msg->address + accessed_bytes,\n\t\t\t\t\t     msg->buffer + accessed_bytes,\n\t\t\t\t\t     to_access, &msg->reply);\n\n\t\tif (ret) {\n\t\t\tdev_info(mtk_dp->dev,\n\t\t\t\t \"Failed to do AUX transfer: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t\taccessed_bytes += to_access;\n\t} while (accessed_bytes < msg->size);\n\n\treturn msg->size;\nerr:\n\tmsg->reply = DP_AUX_NATIVE_REPLY_NACK | DP_AUX_I2C_REPLY_NACK;\n\treturn ret;\n}\n\nstatic int mtk_dp_poweron(struct mtk_dp *mtk_dp)\n{\n\tint ret;\n\n\tret = phy_init(mtk_dp->phy);\n\tif (ret) {\n\t\tdev_err(mtk_dp->dev, \"Failed to initialize phy: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmtk_dp_init_port(mtk_dp);\n\tmtk_dp_power_enable(mtk_dp);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_poweroff(struct mtk_dp *mtk_dp)\n{\n\tmtk_dp_power_disable(mtk_dp);\n\tphy_exit(mtk_dp->phy);\n}\n\nstatic int mtk_dp_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tdev_err(mtk_dp->dev, \"Driver does not provide a connector!\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_dp->aux.drm_dev = bridge->dev;\n\tret = drm_dp_aux_register(&mtk_dp->aux);\n\tif (ret) {\n\t\tdev_err(mtk_dp->dev,\n\t\t\t\"failed to register DP AUX channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtk_dp_poweron(mtk_dp);\n\tif (ret)\n\t\tgoto err_aux_register;\n\n\tif (mtk_dp->next_bridge) {\n\t\tret = drm_bridge_attach(bridge->encoder, mtk_dp->next_bridge,\n\t\t\t\t\t&mtk_dp->bridge, flags);\n\t\tif (ret) {\n\t\t\tdrm_warn(mtk_dp->drm_dev,\n\t\t\t\t \"Failed to attach external bridge: %d\\n\", ret);\n\t\t\tgoto err_bridge_attach;\n\t\t}\n\t}\n\n\tmtk_dp->drm_dev = bridge->dev;\n\n\tif (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP) {\n\t\tirq_clear_status_flags(mtk_dp->irq, IRQ_NOAUTOEN);\n\t\tenable_irq(mtk_dp->irq);\n\t\tmtk_dp_hwirq_enable(mtk_dp, true);\n\t}\n\n\treturn 0;\n\nerr_bridge_attach:\n\tmtk_dp_poweroff(mtk_dp);\nerr_aux_register:\n\tdrm_dp_aux_unregister(&mtk_dp->aux);\n\treturn ret;\n}\n\nstatic void mtk_dp_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\n\tif (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP) {\n\t\tmtk_dp_hwirq_enable(mtk_dp, false);\n\t\tdisable_irq(mtk_dp->irq);\n\t}\n\tmtk_dp->drm_dev = NULL;\n\tmtk_dp_poweroff(mtk_dp);\n\tdrm_dp_aux_unregister(&mtk_dp->aux);\n}\n\nstatic void mtk_dp_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_state)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tint ret;\n\n\tmtk_dp->conn = drm_atomic_get_new_connector_for_encoder(old_state->base.state,\n\t\t\t\t\t\t\t\tbridge->encoder);\n\tif (!mtk_dp->conn) {\n\t\tdrm_err(mtk_dp->drm_dev,\n\t\t\t\"Can't enable bridge as connector is missing\\n\");\n\t\treturn;\n\t}\n\n\tmtk_dp_aux_panel_poweron(mtk_dp, true);\n\n\t \n\tret = mtk_dp_training(mtk_dp);\n\tif (ret) {\n\t\tdrm_err(mtk_dp->drm_dev, \"Training failed, %d\\n\", ret);\n\t\tgoto power_off_aux;\n\t}\n\n\tret = mtk_dp_video_config(mtk_dp);\n\tif (ret)\n\t\tgoto power_off_aux;\n\n\tmtk_dp_video_enable(mtk_dp, true);\n\n\tmtk_dp->audio_enable =\n\t\tmtk_dp_edid_parse_audio_capabilities(mtk_dp,\n\t\t\t\t\t\t     &mtk_dp->info.audio_cur_cfg);\n\tif (mtk_dp->audio_enable) {\n\t\tmtk_dp_audio_setup(mtk_dp, &mtk_dp->info.audio_cur_cfg);\n\t\tmtk_dp_audio_mute(mtk_dp, false);\n\t} else {\n\t\tmemset(&mtk_dp->info.audio_cur_cfg, 0,\n\t\t       sizeof(mtk_dp->info.audio_cur_cfg));\n\t}\n\n\tmtk_dp->enabled = true;\n\tmtk_dp_update_plugged_status(mtk_dp);\n\n\treturn;\npower_off_aux:\n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t   DP_PWR_STATE_BANDGAP_TPLL,\n\t\t\t   DP_PWR_STATE_MASK);\n}\n\nstatic void mtk_dp_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_state)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\n\tmtk_dp->enabled = false;\n\tmtk_dp_update_plugged_status(mtk_dp);\n\tmtk_dp_video_enable(mtk_dp, false);\n\tmtk_dp_audio_mute(mtk_dp, true);\n\n\tif (mtk_dp->train_info.cable_plugged_in) {\n\t\tdrm_dp_dpcd_writeb(&mtk_dp->aux, DP_SET_POWER, DP_SET_POWER_D3);\n\t\tusleep_range(2000, 3000);\n\t}\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t   DP_PWR_STATE_BANDGAP_TPLL,\n\t\t\t   DP_PWR_STATE_MASK);\n\n\t \n\tmsleep(20);\n}\n\nstatic enum drm_mode_status\nmtk_dp_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t const struct drm_display_info *info,\n\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tu32 bpp = info->color_formats & DRM_COLOR_FORMAT_YCBCR422 ? 16 : 24;\n\tu32 rate = min_t(u32, drm_dp_max_link_rate(mtk_dp->rx_cap) *\n\t\t\t      drm_dp_max_lane_count(mtk_dp->rx_cap),\n\t\t\t drm_dp_bw_code_to_link_rate(mtk_dp->max_linkrate) *\n\t\t\t mtk_dp->max_lanes);\n\n\tif (rate < mode->clock * bpp / 8)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic u32 *mtk_dp_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t\t     unsigned int *num_output_fmts)\n{\n\tu32 *output_fmts;\n\n\t*num_output_fmts = 0;\n\toutput_fmts = kmalloc(sizeof(*output_fmts), GFP_KERNEL);\n\tif (!output_fmts)\n\t\treturn NULL;\n\t*num_output_fmts = 1;\n\toutput_fmts[0] = MEDIA_BUS_FMT_FIXED;\n\treturn output_fmts;\n}\n\nstatic const u32 mt8195_input_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_YUV8_1X24,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\nstatic u32 *mtk_dp_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t\t\t    u32 output_fmt,\n\t\t\t\t\t\t    unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tstruct drm_display_info *display_info =\n\t\t&conn_state->connector->display_info;\n\tu32 rate = min_t(u32, drm_dp_max_link_rate(mtk_dp->rx_cap) *\n\t\t\t      drm_dp_max_lane_count(mtk_dp->rx_cap),\n\t\t\t drm_dp_bw_code_to_link_rate(mtk_dp->max_linkrate) *\n\t\t\t mtk_dp->max_lanes);\n\n\t*num_input_fmts = 0;\n\n\t \n\tif ((rate < (mode->clock * 24 / 8)) &&\n\t    (rate > (mode->clock * 16 / 8)) &&\n\t    (display_info->color_formats & DRM_COLOR_FORMAT_YCBCR422)) {\n\t\tinput_fmts = kcalloc(1, sizeof(*input_fmts), GFP_KERNEL);\n\t\tif (!input_fmts)\n\t\t\treturn NULL;\n\t\t*num_input_fmts = 1;\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_YUYV8_1X16;\n\t} else {\n\t\tinput_fmts = kcalloc(ARRAY_SIZE(mt8195_input_fmts),\n\t\t\t\t     sizeof(*input_fmts),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!input_fmts)\n\t\t\treturn NULL;\n\n\t\t*num_input_fmts = ARRAY_SIZE(mt8195_input_fmts);\n\t\tmemcpy(input_fmts, mt8195_input_fmts, sizeof(mt8195_input_fmts));\n\t}\n\n\treturn input_fmts;\n}\n\nstatic int mtk_dp_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t      struct drm_connector_state *conn_state)\n{\n\tstruct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);\n\tstruct drm_crtc *crtc = conn_state->crtc;\n\tunsigned int input_bus_format;\n\n\tinput_bus_format = bridge_state->input_bus_cfg.format;\n\n\tdev_dbg(mtk_dp->dev, \"input format 0x%04x, output format 0x%04x\\n\",\n\t\tbridge_state->input_bus_cfg.format,\n\t\t bridge_state->output_bus_cfg.format);\n\n\tif (input_bus_format == MEDIA_BUS_FMT_YUYV8_1X16)\n\t\tmtk_dp->info.format = DP_PIXELFORMAT_YUV422;\n\telse\n\t\tmtk_dp->info.format = DP_PIXELFORMAT_RGB;\n\n\tif (!crtc) {\n\t\tdrm_err(mtk_dp->drm_dev,\n\t\t\t\"Can't enable bridge as connector state doesn't have a crtc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_display_mode_to_videomode(&crtc_state->adjusted_mode, &mtk_dp->info.vm);\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_funcs mtk_dp_bridge_funcs = {\n\t.atomic_check = mtk_dp_bridge_atomic_check,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_output_bus_fmts = mtk_dp_bridge_atomic_get_output_bus_fmts,\n\t.atomic_get_input_bus_fmts = mtk_dp_bridge_atomic_get_input_bus_fmts,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = mtk_dp_bridge_attach,\n\t.detach = mtk_dp_bridge_detach,\n\t.atomic_enable = mtk_dp_bridge_atomic_enable,\n\t.atomic_disable = mtk_dp_bridge_atomic_disable,\n\t.mode_valid = mtk_dp_bridge_mode_valid,\n\t.get_edid = mtk_dp_get_edid,\n\t.detect = mtk_dp_bdg_detect,\n};\n\nstatic void mtk_dp_debounce_timer(struct timer_list *t)\n{\n\tstruct mtk_dp *mtk_dp = from_timer(mtk_dp, t, debounce_timer);\n\n\tmtk_dp->need_debounce = true;\n}\n\n \nstatic int mtk_dp_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t  struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t  struct hdmi_codec_params *params)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tif (!mtk_dp->enabled) {\n\t\tdev_err(mtk_dp->dev, \"%s, DP is not ready!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tmtk_dp->info.audio_cur_cfg.channels = params->cea.channels;\n\tmtk_dp->info.audio_cur_cfg.sample_rate = params->sample_rate;\n\n\tmtk_dp_audio_setup(mtk_dp, &mtk_dp->info.audio_cur_cfg);\n\n\treturn 0;\n}\n\nstatic int mtk_dp_audio_startup(struct device *dev, void *data)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tmtk_dp_audio_mute(mtk_dp, false);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tmtk_dp_audio_mute(mtk_dp, true);\n}\n\nstatic int mtk_dp_audio_get_eld(struct device *dev, void *data, uint8_t *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tif (mtk_dp->enabled)\n\t\tmemcpy(buf, mtk_dp->conn->eld, len);\n\telse\n\t\tmemset(buf, 0, len);\n\n\treturn 0;\n}\n\nstatic int mtk_dp_audio_hook_plugged_cb(struct device *dev, void *data,\n\t\t\t\t\thdmi_codec_plugged_cb fn,\n\t\t\t\t\tstruct device *codec_dev)\n{\n\tstruct mtk_dp *mtk_dp = data;\n\n\tmutex_lock(&mtk_dp->update_plugged_status_lock);\n\tmtk_dp->plugged_cb = fn;\n\tmtk_dp->codec_dev = codec_dev;\n\tmutex_unlock(&mtk_dp->update_plugged_status_lock);\n\n\tmtk_dp_update_plugged_status(mtk_dp);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops mtk_dp_audio_codec_ops = {\n\t.hw_params = mtk_dp_audio_hw_params,\n\t.audio_startup = mtk_dp_audio_startup,\n\t.audio_shutdown = mtk_dp_audio_shutdown,\n\t.get_eld = mtk_dp_audio_get_eld,\n\t.hook_plugged_cb = mtk_dp_audio_hook_plugged_cb,\n\t.no_capture_mute = 1,\n};\n\nstatic int mtk_dp_register_audio_driver(struct device *dev)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &mtk_dp_audio_codec_ops,\n\t\t.max_i2s_channels = 8,\n\t\t.i2s = 1,\n\t\t.data = mtk_dp,\n\t};\n\n\tmtk_dp->audio_pdev = platform_device_register_data(dev,\n\t\t\t\t\t\t\t   HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t\t   PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t   &codec_data,\n\t\t\t\t\t\t\t   sizeof(codec_data));\n\treturn PTR_ERR_OR_ZERO(mtk_dp->audio_pdev);\n}\n\nstatic int mtk_dp_register_phy(struct mtk_dp *mtk_dp)\n{\n\tstruct device *dev = mtk_dp->dev;\n\n\tmtk_dp->phy_dev = platform_device_register_data(dev, \"mediatek-dp-phy\",\n\t\t\t\t\t\t\tPLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t&mtk_dp->regs,\n\t\t\t\t\t\t\tsizeof(struct regmap *));\n\tif (IS_ERR(mtk_dp->phy_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(mtk_dp->phy_dev),\n\t\t\t\t     \"Failed to create device mediatek-dp-phy\\n\");\n\n\tmtk_dp_get_calibration_data(mtk_dp);\n\n\tmtk_dp->phy = devm_phy_get(&mtk_dp->phy_dev->dev, \"dp\");\n\tif (IS_ERR(mtk_dp->phy)) {\n\t\tplatform_device_unregister(mtk_dp->phy_dev);\n\t\treturn dev_err_probe(dev, PTR_ERR(mtk_dp->phy), \"Failed to get phy\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dp_edp_link_panel(struct drm_dp_aux *mtk_aux)\n{\n\tstruct mtk_dp *mtk_dp = container_of(mtk_aux, struct mtk_dp, aux);\n\tstruct device *dev = mtk_aux->dev;\n\tint ret;\n\n\tmtk_dp->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\n\t \n\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t   DP_PWR_STATE_BANDGAP_TPLL,\n\t\t\t   DP_PWR_STATE_MASK);\n\tmtk_dp_power_disable(mtk_dp);\n\n\tif (IS_ERR(mtk_dp->next_bridge)) {\n\t\tret = PTR_ERR(mtk_dp->next_bridge);\n\t\tmtk_dp->next_bridge = NULL;\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_drm_bridge_add(dev, &mtk_dp->bridge);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mtk_dp_probe(struct platform_device *pdev)\n{\n\tstruct mtk_dp *mtk_dp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tmtk_dp = devm_kzalloc(dev, sizeof(*mtk_dp), GFP_KERNEL);\n\tif (!mtk_dp)\n\t\treturn -ENOMEM;\n\n\tmtk_dp->dev = dev;\n\tmtk_dp->data = (struct mtk_dp_data *)of_device_get_match_data(dev);\n\n\tret = mtk_dp_dt_parse(mtk_dp, pdev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to parse dt\\n\");\n\n\t \n\tif (mtk_dp->data->bridge_type != DRM_MODE_CONNECTOR_eDP) {\n\t\tmtk_dp->irq = platform_get_irq(pdev, 0);\n\t\tif (mtk_dp->irq < 0)\n\t\t\treturn dev_err_probe(dev, mtk_dp->irq,\n\t\t\t\t\t     \"failed to request dp irq resource\\n\");\n\n\t\tspin_lock_init(&mtk_dp->irq_thread_lock);\n\n\t\tirq_set_status_flags(mtk_dp->irq, IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(dev, mtk_dp->irq, mtk_dp_hpd_event,\n\t\t\t\t\t\tmtk_dp_hpd_event_thread,\n\t\t\t\t\t\tIRQ_TYPE_LEVEL_HIGH, dev_name(dev),\n\t\t\t\t\t\tmtk_dp);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"failed to request mediatek dptx irq\\n\");\n\n\t\tmtk_dp->need_debounce = true;\n\t\ttimer_setup(&mtk_dp->debounce_timer, mtk_dp_debounce_timer, 0);\n\t}\n\n\tmtk_dp->aux.name = \"aux_mtk_dp\";\n\tmtk_dp->aux.dev = dev;\n\tmtk_dp->aux.transfer = mtk_dp_aux_transfer;\n\tmtk_dp->aux.wait_hpd_asserted = mtk_dp_wait_hpd_asserted;\n\tdrm_dp_aux_init(&mtk_dp->aux);\n\n\tplatform_set_drvdata(pdev, mtk_dp);\n\n\tif (mtk_dp->data->audio_supported) {\n\t\tmutex_init(&mtk_dp->update_plugged_status_lock);\n\n\t\tret = mtk_dp_register_audio_driver(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register audio driver: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mtk_dp_register_phy(mtk_dp);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_dp->bridge.funcs = &mtk_dp_bridge_funcs;\n\tmtk_dp->bridge.of_node = dev->of_node;\n\tmtk_dp->bridge.type = mtk_dp->data->bridge_type;\n\n\tif (mtk_dp->bridge.type == DRM_MODE_CONNECTOR_eDP) {\n\t\t \n\t\tmtk_dp_set_idle_pattern(mtk_dp, true);\n\t\tmtk_dp_initialize_aux_settings(mtk_dp);\n\t\tmtk_dp_power_enable(mtk_dp);\n\n\t\t \n\t\tmtk_dp_hwirq_enable(mtk_dp, false);\n\n\t\t \n\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t\t   DP_PWR_STATE_BANDGAP_TPLL_LANE,\n\t\t\t\t   DP_PWR_STATE_MASK);\n\n\t\tret = devm_of_dp_aux_populate_bus(&mtk_dp->aux, mtk_dp_edp_link_panel);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tret = mtk_dp_edp_link_panel(&mtk_dp->aux);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tmtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,\n\t\t\t\t\t\t   DP_PWR_STATE_BANDGAP_TPLL,\n\t\t\t\t\t\t   DP_PWR_STATE_MASK);\n\t\t\t\tmtk_dp_power_disable(mtk_dp);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmtk_dp->bridge.ops = DRM_BRIDGE_OP_DETECT |\n\t\t\t\t     DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_HPD;\n\t\tret = devm_drm_bridge_add(dev, &mtk_dp->bridge);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to add bridge\\n\");\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\treturn 0;\n}\n\nstatic void mtk_dp_remove(struct platform_device *pdev)\n{\n\tstruct mtk_dp *mtk_dp = platform_get_drvdata(pdev);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tif (mtk_dp->data->bridge_type != DRM_MODE_CONNECTOR_eDP)\n\t\tdel_timer_sync(&mtk_dp->debounce_timer);\n\tplatform_device_unregister(mtk_dp->phy_dev);\n\tif (mtk_dp->audio_pdev)\n\t\tplatform_device_unregister(mtk_dp->audio_pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_dp_suspend(struct device *dev)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tmtk_dp_power_disable(mtk_dp);\n\tif (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP)\n\t\tmtk_dp_hwirq_enable(mtk_dp, false);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int mtk_dp_resume(struct device *dev)\n{\n\tstruct mtk_dp *mtk_dp = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tmtk_dp_init_port(mtk_dp);\n\tif (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP)\n\t\tmtk_dp_hwirq_enable(mtk_dp, true);\n\tmtk_dp_power_enable(mtk_dp);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mtk_dp_pm_ops, mtk_dp_suspend, mtk_dp_resume);\n\nstatic const struct mtk_dp_data mt8195_edp_data = {\n\t.bridge_type = DRM_MODE_CONNECTOR_eDP,\n\t.smc_cmd = MTK_DP_SIP_ATF_EDP_VIDEO_UNMUTE,\n\t.efuse_fmt = mt8195_edp_efuse_fmt,\n\t.audio_supported = false,\n};\n\nstatic const struct mtk_dp_data mt8195_dp_data = {\n\t.bridge_type = DRM_MODE_CONNECTOR_DisplayPort,\n\t.smc_cmd = MTK_DP_SIP_ATF_VIDEO_UNMUTE,\n\t.efuse_fmt = mt8195_dp_efuse_fmt,\n\t.audio_supported = true,\n};\n\nstatic const struct of_device_id mtk_dp_of_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8195-edp-tx\",\n\t\t.data = &mt8195_edp_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8195-dp-tx\",\n\t\t.data = &mt8195_dp_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_dp_of_match);\n\nstatic struct platform_driver mtk_dp_driver = {\n\t.probe = mtk_dp_probe,\n\t.remove_new = mtk_dp_remove,\n\t.driver = {\n\t\t.name = \"mediatek-drm-dp\",\n\t\t.of_match_table = mtk_dp_of_match,\n\t\t.pm = &mtk_dp_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mtk_dp_driver);\n\nMODULE_AUTHOR(\"Jitao Shi <jitao.shi@mediatek.com>\");\nMODULE_AUTHOR(\"Markus Schneider-Pargmann <msp@baylibre.com>\");\nMODULE_AUTHOR(\"Bo-Chen Chen <rex-bc.chen@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek DisplayPort Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: phy_mtk_dp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}