{
  "module_name": "mtk_drm_crtc.c",
  "hash_id": "281e466cd11b14d52bfaf1ddbf8da639fffe0fee366b70b0422ef34842a70c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_drm_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/mailbox_controller.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n#include <linux/soc/mediatek/mtk-mmsys.h>\n#include <linux/soc/mediatek/mtk-mutex.h>\n\n#include <asm/barrier.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"mtk_drm_drv.h\"\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_gem.h\"\n#include \"mtk_drm_plane.h\"\n\n \nstruct mtk_drm_crtc {\n\tstruct drm_crtc\t\t\tbase;\n\tbool\t\t\t\tenabled;\n\n\tbool\t\t\t\tpending_needs_vblank;\n\tstruct drm_pending_vblank_event\t*event;\n\n\tstruct drm_plane\t\t*planes;\n\tunsigned int\t\t\tlayer_nr;\n\tbool\t\t\t\tpending_planes;\n\tbool\t\t\t\tpending_async_planes;\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tstruct cmdq_client\t\tcmdq_client;\n\tstruct cmdq_pkt\t\t\tcmdq_handle;\n\tu32\t\t\t\tcmdq_event;\n\tu32\t\t\t\tcmdq_vblank_cnt;\n\twait_queue_head_t\t\tcb_blocking_queue;\n#endif\n\n\tstruct device\t\t\t*mmsys_dev;\n\tstruct device\t\t\t*dma_dev;\n\tstruct mtk_mutex\t\t*mutex;\n\tunsigned int\t\t\tddp_comp_nr;\n\tstruct mtk_ddp_comp\t\t**ddp_comp;\n\n\t \n\tstruct mutex\t\t\thw_lock;\n\tbool\t\t\t\tconfig_updating;\n};\n\nstruct mtk_crtc_state {\n\tstruct drm_crtc_state\t\tbase;\n\n\tbool\t\t\t\tpending_config;\n\tunsigned int\t\t\tpending_width;\n\tunsigned int\t\t\tpending_height;\n\tunsigned int\t\t\tpending_vrefresh;\n};\n\nstatic inline struct mtk_drm_crtc *to_mtk_crtc(struct drm_crtc *c)\n{\n\treturn container_of(c, struct mtk_drm_crtc, base);\n}\n\nstatic inline struct mtk_crtc_state *to_mtk_crtc_state(struct drm_crtc_state *s)\n{\n\treturn container_of(s, struct mtk_crtc_state, base);\n}\n\nstatic void mtk_drm_crtc_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)\n{\n\tstruct drm_crtc *crtc = &mtk_crtc->base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\tdrm_crtc_send_vblank_event(crtc, mtk_crtc->event);\n\tdrm_crtc_vblank_put(crtc);\n\tmtk_crtc->event = NULL;\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n}\n\nstatic void mtk_drm_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)\n{\n\tdrm_crtc_handle_vblank(&mtk_crtc->base);\n\tif (!mtk_crtc->config_updating && mtk_crtc->pending_needs_vblank) {\n\t\tmtk_drm_crtc_finish_page_flip(mtk_crtc);\n\t\tmtk_crtc->pending_needs_vblank = false;\n\t}\n}\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\nstatic int mtk_drm_cmdq_pkt_create(struct cmdq_client *client, struct cmdq_pkt *pkt,\n\t\t\t\t   size_t size)\n{\n\tstruct device *dev;\n\tdma_addr_t dma_addr;\n\n\tpkt->va_base = kzalloc(size, GFP_KERNEL);\n\tif (!pkt->va_base)\n\t\treturn -ENOMEM;\n\n\tpkt->buf_size = size;\n\tpkt->cl = (void *)client;\n\n\tdev = client->chan->mbox->dev;\n\tdma_addr = dma_map_single(dev, pkt->va_base, pkt->buf_size,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_addr)) {\n\t\tdev_err(dev, \"dma map failed, size=%u\\n\", (u32)(u64)size);\n\t\tkfree(pkt->va_base);\n\t\treturn -ENOMEM;\n\t}\n\n\tpkt->pa_base = dma_addr;\n\n\treturn 0;\n}\n\nstatic void mtk_drm_cmdq_pkt_destroy(struct cmdq_pkt *pkt)\n{\n\tstruct cmdq_client *client = (struct cmdq_client *)pkt->cl;\n\n\tdma_unmap_single(client->chan->mbox->dev, pkt->pa_base, pkt->buf_size,\n\t\t\t DMA_TO_DEVICE);\n\tkfree(pkt->va_base);\n}\n#endif\n\nstatic void mtk_drm_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tint i;\n\n\tmtk_mutex_put(mtk_crtc->mutex);\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tmtk_drm_cmdq_pkt_destroy(&mtk_crtc->cmdq_handle);\n\n\tif (mtk_crtc->cmdq_client.chan) {\n\t\tmbox_free_channel(mtk_crtc->cmdq_client.chan);\n\t\tmtk_crtc->cmdq_client.chan = NULL;\n\t}\n#endif\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tstruct mtk_ddp_comp *comp;\n\n\t\tcomp = mtk_crtc->ddp_comp[i];\n\t\tmtk_ddp_comp_unregister_vblank_cb(comp);\n\t}\n\n\tdrm_crtc_cleanup(crtc);\n}\n\nstatic void mtk_drm_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct mtk_crtc_state *state;\n\n\tif (crtc->state)\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\tkfree(to_mtk_crtc_state(crtc->state));\n\tcrtc->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *mtk_drm_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct mtk_crtc_state *state;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tWARN_ON(state->base.crtc != crtc);\n\tstate->base.crtc = crtc;\n\tstate->pending_config = false;\n\n\treturn &state->base;\n}\n\nstatic void mtk_drm_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(to_mtk_crtc_state(state));\n}\n\nstatic bool mtk_drm_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted_mode)\n{\n\t \n\treturn true;\n}\n\nstatic void mtk_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct mtk_crtc_state *state = to_mtk_crtc_state(crtc->state);\n\n\tstate->pending_width = crtc->mode.hdisplay;\n\tstate->pending_height = crtc->mode.vdisplay;\n\tstate->pending_vrefresh = drm_mode_vrefresh(&crtc->mode);\n\twmb();\t \n\tstate->pending_config = true;\n}\n\nstatic int mtk_crtc_ddp_clk_enable(struct mtk_drm_crtc *mtk_crtc)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tret = mtk_ddp_comp_clk_enable(mtk_crtc->ddp_comp[i]);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to enable clock %d: %d\\n\", i, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\twhile (--i >= 0)\n\t\tmtk_ddp_comp_clk_disable(mtk_crtc->ddp_comp[i]);\n\treturn ret;\n}\n\nstatic void mtk_crtc_ddp_clk_disable(struct mtk_drm_crtc *mtk_crtc)\n{\n\tint i;\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\n\t\tmtk_ddp_comp_clk_disable(mtk_crtc->ddp_comp[i]);\n}\n\nstatic\nstruct mtk_ddp_comp *mtk_drm_ddp_comp_for_plane(struct drm_crtc *crtc,\n\t\t\t\t\t\tstruct drm_plane *plane,\n\t\t\t\t\t\tunsigned int *local_layer)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_ddp_comp *comp;\n\tint i, count = 0;\n\tunsigned int local_index = plane - mtk_crtc->planes;\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tcomp = mtk_crtc->ddp_comp[i];\n\t\tif (local_index < (count + mtk_ddp_comp_layer_nr(comp))) {\n\t\t\t*local_layer = local_index - count;\n\t\t\treturn comp;\n\t\t}\n\t\tcount += mtk_ddp_comp_layer_nr(comp);\n\t}\n\n\tWARN(1, \"Failed to find component for plane %d\\n\", plane->index);\n\treturn NULL;\n}\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\nstatic void ddp_cmdq_cb(struct mbox_client *cl, void *mssg)\n{\n\tstruct cmdq_cb_data *data = mssg;\n\tstruct cmdq_client *cmdq_cl = container_of(cl, struct cmdq_client, client);\n\tstruct mtk_drm_crtc *mtk_crtc = container_of(cmdq_cl, struct mtk_drm_crtc, cmdq_client);\n\tstruct mtk_crtc_state *state;\n\tunsigned int i;\n\n\tif (data->sta < 0)\n\t\treturn;\n\n\tstate = to_mtk_crtc_state(mtk_crtc->base.state);\n\n\tstate->pending_config = false;\n\n\tif (mtk_crtc->pending_planes) {\n\t\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\t\tstruct mtk_plane_state *plane_state;\n\n\t\t\tplane_state = to_mtk_plane_state(plane->state);\n\n\t\t\tplane_state->pending.config = false;\n\t\t}\n\t\tmtk_crtc->pending_planes = false;\n\t}\n\n\tif (mtk_crtc->pending_async_planes) {\n\t\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\t\tstruct mtk_plane_state *plane_state;\n\n\t\t\tplane_state = to_mtk_plane_state(plane->state);\n\n\t\t\tplane_state->pending.async_config = false;\n\t\t}\n\t\tmtk_crtc->pending_async_planes = false;\n\t}\n\n\tmtk_crtc->cmdq_vblank_cnt = 0;\n\twake_up(&mtk_crtc->cb_blocking_queue);\n}\n#endif\n\nstatic int mtk_crtc_ddp_hw_init(struct mtk_drm_crtc *mtk_crtc)\n{\n\tstruct drm_crtc *crtc = &mtk_crtc->base;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector_list_iter conn_iter;\n\tunsigned int width, height, vrefresh, bpc = MTK_MAX_BPC;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn -EINVAL;\n\n\twidth = crtc->state->adjusted_mode.hdisplay;\n\theight = crtc->state->adjusted_mode.vdisplay;\n\tvrefresh = drm_mode_vrefresh(&crtc->state->adjusted_mode);\n\n\tdrm_for_each_encoder(encoder, crtc->dev) {\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tdrm_connector_list_iter_begin(crtc->dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (connector->encoder != encoder)\n\t\t\t\tcontinue;\n\t\t\tif (connector->display_info.bpc != 0 &&\n\t\t\t    bpc > connector->display_info.bpc)\n\t\t\t\tbpc = connector->display_info.bpc;\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\tret = pm_runtime_resume_and_get(crtc->dev->dev);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to enable power domain: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtk_mutex_prepare(mtk_crtc->mutex);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to enable mutex clock: %d\\n\", ret);\n\t\tgoto err_pm_runtime_put;\n\t}\n\n\tret = mtk_crtc_ddp_clk_enable(mtk_crtc);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to enable component clocks: %d\\n\", ret);\n\t\tgoto err_mutex_unprepare;\n\t}\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr - 1; i++) {\n\t\tif (!mtk_ddp_comp_connect(mtk_crtc->ddp_comp[i], mtk_crtc->mmsys_dev,\n\t\t\t\t\t  mtk_crtc->ddp_comp[i + 1]->id))\n\t\t\tmtk_mmsys_ddp_connect(mtk_crtc->mmsys_dev,\n\t\t\t\t\t      mtk_crtc->ddp_comp[i]->id,\n\t\t\t\t\t      mtk_crtc->ddp_comp[i + 1]->id);\n\t\tif (!mtk_ddp_comp_add(mtk_crtc->ddp_comp[i], mtk_crtc->mutex))\n\t\t\tmtk_mutex_add_comp(mtk_crtc->mutex,\n\t\t\t\t\t   mtk_crtc->ddp_comp[i]->id);\n\t}\n\tif (!mtk_ddp_comp_add(mtk_crtc->ddp_comp[i], mtk_crtc->mutex))\n\t\tmtk_mutex_add_comp(mtk_crtc->mutex, mtk_crtc->ddp_comp[i]->id);\n\tmtk_mutex_enable(mtk_crtc->mutex);\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[i];\n\n\t\tif (i == 1)\n\t\t\tmtk_ddp_comp_bgclr_in_on(comp);\n\n\t\tmtk_ddp_comp_config(comp, width, height, vrefresh, bpc, NULL);\n\t\tmtk_ddp_comp_start(comp);\n\t}\n\n\t \n\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\tstruct mtk_plane_state *plane_state;\n\t\tstruct mtk_ddp_comp *comp;\n\t\tunsigned int local_layer;\n\n\t\tplane_state = to_mtk_plane_state(plane->state);\n\n\t\t \n\t\tplane_state->pending.enable = false;\n\t\tcomp = mtk_drm_ddp_comp_for_plane(crtc, plane, &local_layer);\n\t\tif (comp)\n\t\t\tmtk_ddp_comp_layer_config(comp, local_layer,\n\t\t\t\t\t\t  plane_state, NULL);\n\t}\n\n\treturn 0;\n\nerr_mutex_unprepare:\n\tmtk_mutex_unprepare(mtk_crtc->mutex);\nerr_pm_runtime_put:\n\tpm_runtime_put(crtc->dev->dev);\n\treturn ret;\n}\n\nstatic void mtk_crtc_ddp_hw_fini(struct mtk_drm_crtc *mtk_crtc)\n{\n\tstruct drm_device *drm = mtk_crtc->base.dev;\n\tstruct drm_crtc *crtc = &mtk_crtc->base;\n\tint i;\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tmtk_ddp_comp_stop(mtk_crtc->ddp_comp[i]);\n\t\tif (i == 1)\n\t\t\tmtk_ddp_comp_bgclr_in_off(mtk_crtc->ddp_comp[i]);\n\t}\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\n\t\tif (!mtk_ddp_comp_remove(mtk_crtc->ddp_comp[i], mtk_crtc->mutex))\n\t\t\tmtk_mutex_remove_comp(mtk_crtc->mutex,\n\t\t\t\t\t      mtk_crtc->ddp_comp[i]->id);\n\tmtk_mutex_disable(mtk_crtc->mutex);\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr - 1; i++) {\n\t\tif (!mtk_ddp_comp_disconnect(mtk_crtc->ddp_comp[i], mtk_crtc->mmsys_dev,\n\t\t\t\t\t     mtk_crtc->ddp_comp[i + 1]->id))\n\t\t\tmtk_mmsys_ddp_disconnect(mtk_crtc->mmsys_dev,\n\t\t\t\t\t\t mtk_crtc->ddp_comp[i]->id,\n\t\t\t\t\t\t mtk_crtc->ddp_comp[i + 1]->id);\n\t\tif (!mtk_ddp_comp_remove(mtk_crtc->ddp_comp[i], mtk_crtc->mutex))\n\t\t\tmtk_mutex_remove_comp(mtk_crtc->mutex,\n\t\t\t\t\t      mtk_crtc->ddp_comp[i]->id);\n\t}\n\tif (!mtk_ddp_comp_remove(mtk_crtc->ddp_comp[i], mtk_crtc->mutex))\n\t\tmtk_mutex_remove_comp(mtk_crtc->mutex, mtk_crtc->ddp_comp[i]->id);\n\tmtk_crtc_ddp_clk_disable(mtk_crtc);\n\tmtk_mutex_unprepare(mtk_crtc->mutex);\n\n\tpm_runtime_put(drm->dev);\n\n\tif (crtc->state->event && !crtc->state->active) {\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic void mtk_crtc_ddp_config(struct drm_crtc *crtc,\n\t\t\t\tstruct cmdq_pkt *cmdq_handle)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_crtc_state *state = to_mtk_crtc_state(mtk_crtc->base.state);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];\n\tunsigned int i;\n\tunsigned int local_layer;\n\n\t \n\tif (state->pending_config) {\n\t\tmtk_ddp_comp_config(comp, state->pending_width,\n\t\t\t\t    state->pending_height,\n\t\t\t\t    state->pending_vrefresh, 0,\n\t\t\t\t    cmdq_handle);\n\n\t\tif (!cmdq_handle)\n\t\t\tstate->pending_config = false;\n\t}\n\n\tif (mtk_crtc->pending_planes) {\n\t\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\t\tstruct mtk_plane_state *plane_state;\n\n\t\t\tplane_state = to_mtk_plane_state(plane->state);\n\n\t\t\tif (!plane_state->pending.config)\n\t\t\t\tcontinue;\n\n\t\t\tcomp = mtk_drm_ddp_comp_for_plane(crtc, plane,\n\t\t\t\t\t\t\t  &local_layer);\n\n\t\t\tif (comp)\n\t\t\t\tmtk_ddp_comp_layer_config(comp, local_layer,\n\t\t\t\t\t\t\t  plane_state,\n\t\t\t\t\t\t\t  cmdq_handle);\n\t\t\tif (!cmdq_handle)\n\t\t\t\tplane_state->pending.config = false;\n\t\t}\n\n\t\tif (!cmdq_handle)\n\t\t\tmtk_crtc->pending_planes = false;\n\t}\n\n\tif (mtk_crtc->pending_async_planes) {\n\t\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\t\tstruct mtk_plane_state *plane_state;\n\n\t\t\tplane_state = to_mtk_plane_state(plane->state);\n\n\t\t\tif (!plane_state->pending.async_config)\n\t\t\t\tcontinue;\n\n\t\t\tcomp = mtk_drm_ddp_comp_for_plane(crtc, plane,\n\t\t\t\t\t\t\t  &local_layer);\n\n\t\t\tif (comp)\n\t\t\t\tmtk_ddp_comp_layer_config(comp, local_layer,\n\t\t\t\t\t\t\t  plane_state,\n\t\t\t\t\t\t\t  cmdq_handle);\n\t\t\tif (!cmdq_handle)\n\t\t\t\tplane_state->pending.async_config = false;\n\t\t}\n\n\t\tif (!cmdq_handle)\n\t\t\tmtk_crtc->pending_async_planes = false;\n\t}\n}\n\nstatic void mtk_drm_crtc_update_config(struct mtk_drm_crtc *mtk_crtc,\n\t\t\t\t       bool needs_vblank)\n{\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tstruct cmdq_pkt *cmdq_handle = &mtk_crtc->cmdq_handle;\n#endif\n\tstruct drm_crtc *crtc = &mtk_crtc->base;\n\tstruct mtk_drm_private *priv = crtc->dev->dev_private;\n\tunsigned int pending_planes = 0, pending_async_planes = 0;\n\tint i;\n\n\tmutex_lock(&mtk_crtc->hw_lock);\n\tmtk_crtc->config_updating = true;\n\tif (needs_vblank)\n\t\tmtk_crtc->pending_needs_vblank = true;\n\n\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\tstruct mtk_plane_state *plane_state;\n\n\t\tplane_state = to_mtk_plane_state(plane->state);\n\t\tif (plane_state->pending.dirty) {\n\t\t\tplane_state->pending.config = true;\n\t\t\tplane_state->pending.dirty = false;\n\t\t\tpending_planes |= BIT(i);\n\t\t} else if (plane_state->pending.async_dirty) {\n\t\t\tplane_state->pending.async_config = true;\n\t\t\tplane_state->pending.async_dirty = false;\n\t\t\tpending_async_planes |= BIT(i);\n\t\t}\n\t}\n\tif (pending_planes)\n\t\tmtk_crtc->pending_planes = true;\n\tif (pending_async_planes)\n\t\tmtk_crtc->pending_async_planes = true;\n\n\tif (priv->data->shadow_register) {\n\t\tmtk_mutex_acquire(mtk_crtc->mutex);\n\t\tmtk_crtc_ddp_config(crtc, NULL);\n\t\tmtk_mutex_release(mtk_crtc->mutex);\n\t}\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tif (mtk_crtc->cmdq_client.chan) {\n\t\tmbox_flush(mtk_crtc->cmdq_client.chan, 2000);\n\t\tcmdq_handle->cmd_buf_size = 0;\n\t\tcmdq_pkt_clear_event(cmdq_handle, mtk_crtc->cmdq_event);\n\t\tcmdq_pkt_wfe(cmdq_handle, mtk_crtc->cmdq_event, false);\n\t\tmtk_crtc_ddp_config(crtc, cmdq_handle);\n\t\tcmdq_pkt_finalize(cmdq_handle);\n\t\tdma_sync_single_for_device(mtk_crtc->cmdq_client.chan->mbox->dev,\n\t\t\t\t\t   cmdq_handle->pa_base,\n\t\t\t\t\t   cmdq_handle->cmd_buf_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\t \n\t\tmtk_crtc->cmdq_vblank_cnt = 3;\n\n\t\tmbox_send_message(mtk_crtc->cmdq_client.chan, cmdq_handle);\n\t\tmbox_client_txdone(mtk_crtc->cmdq_client.chan, 0);\n\t}\n#endif\n\tmtk_crtc->config_updating = false;\n\tmutex_unlock(&mtk_crtc->hw_lock);\n}\n\nstatic void mtk_crtc_ddp_irq(void *data)\n{\n\tstruct drm_crtc *crtc = data;\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_drm_private *priv = crtc->dev->dev_private;\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tif (!priv->data->shadow_register && !mtk_crtc->cmdq_client.chan)\n\t\tmtk_crtc_ddp_config(crtc, NULL);\n\telse if (mtk_crtc->cmdq_vblank_cnt > 0 && --mtk_crtc->cmdq_vblank_cnt == 0)\n\t\tDRM_ERROR(\"mtk_crtc %d CMDQ execute command timeout!\\n\",\n\t\t\t  drm_crtc_index(&mtk_crtc->base));\n#else\n\tif (!priv->data->shadow_register)\n\t\tmtk_crtc_ddp_config(crtc, NULL);\n#endif\n\tmtk_drm_finish_page_flip(mtk_crtc);\n}\n\nstatic int mtk_drm_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];\n\n\tmtk_ddp_comp_enable_vblank(comp);\n\n\treturn 0;\n}\n\nstatic void mtk_drm_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];\n\n\tmtk_ddp_comp_disable_vblank(comp);\n}\n\nint mtk_drm_crtc_plane_check(struct drm_crtc *crtc, struct drm_plane *plane,\n\t\t\t     struct mtk_plane_state *state)\n{\n\tunsigned int local_layer;\n\tstruct mtk_ddp_comp *comp;\n\n\tcomp = mtk_drm_ddp_comp_for_plane(crtc, plane, &local_layer);\n\tif (comp)\n\t\treturn mtk_ddp_comp_layer_check(comp, local_layer, state);\n\treturn 0;\n}\n\nvoid mtk_drm_crtc_async_update(struct drm_crtc *crtc, struct drm_plane *plane,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\n\tif (!mtk_crtc->enabled)\n\t\treturn;\n\n\tmtk_drm_crtc_update_config(mtk_crtc, false);\n}\n\nstatic void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"%s %d\\n\", __func__, crtc->base.id);\n\n\tret = pm_runtime_resume_and_get(comp->dev);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(comp->dev, \"Failed to enable power domain: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = mtk_crtc_ddp_hw_init(mtk_crtc);\n\tif (ret) {\n\t\tpm_runtime_put(comp->dev);\n\t\treturn;\n\t}\n\n\tdrm_crtc_vblank_on(crtc);\n\tmtk_crtc->enabled = true;\n}\n\nstatic void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];\n\tint i, ret;\n\n\tDRM_DEBUG_DRIVER(\"%s %d\\n\", __func__, crtc->base.id);\n\tif (!mtk_crtc->enabled)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\tstruct drm_plane *plane = &mtk_crtc->planes[i];\n\t\tstruct mtk_plane_state *plane_state;\n\n\t\tplane_state = to_mtk_plane_state(plane->state);\n\t\tplane_state->pending.enable = false;\n\t\tplane_state->pending.config = true;\n\t}\n\tmtk_crtc->pending_planes = true;\n\n\tmtk_drm_crtc_update_config(mtk_crtc, false);\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\t \n\tif (mtk_crtc->cmdq_client.chan)\n\t\twait_event_timeout(mtk_crtc->cb_blocking_queue,\n\t\t\t\t   mtk_crtc->cmdq_vblank_cnt == 0,\n\t\t\t\t   msecs_to_jiffies(500));\n#endif\n\t \n\tdrm_crtc_wait_one_vblank(crtc);\n\n\tdrm_crtc_vblank_off(crtc);\n\tmtk_crtc_ddp_hw_fini(mtk_crtc);\n\tret = pm_runtime_put(comp->dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(comp->dev, \"Failed to disable power domain: %d\\n\", ret);\n\n\tmtk_crtc->enabled = false;\n}\n\nstatic void mtk_drm_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct mtk_crtc_state *mtk_crtc_state = to_mtk_crtc_state(crtc_state);\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tunsigned long flags;\n\n\tif (mtk_crtc->event && mtk_crtc_state->base.event)\n\t\tDRM_ERROR(\"new event while there is still a pending event\\n\");\n\n\tif (mtk_crtc_state->base.event) {\n\t\tmtk_crtc_state->base.event->pipe = drm_crtc_index(crtc);\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\tmtk_crtc->event = mtk_crtc_state->base.event;\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\t\tmtk_crtc_state->base.event = NULL;\n\t}\n}\n\nstatic void mtk_drm_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);\n\tint i;\n\n\tif (crtc->state->color_mgmt_changed)\n\t\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\t\tmtk_ddp_gamma_set(mtk_crtc->ddp_comp[i], crtc->state);\n\t\t\tmtk_ddp_ctm_set(mtk_crtc->ddp_comp[i], crtc->state);\n\t\t}\n\tmtk_drm_crtc_update_config(mtk_crtc, !!mtk_crtc->event);\n}\n\nstatic const struct drm_crtc_funcs mtk_crtc_funcs = {\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.destroy\t\t= mtk_drm_crtc_destroy,\n\t.reset\t\t\t= mtk_drm_crtc_reset,\n\t.atomic_duplicate_state\t= mtk_drm_crtc_duplicate_state,\n\t.atomic_destroy_state\t= mtk_drm_crtc_destroy_state,\n\t.enable_vblank\t\t= mtk_drm_crtc_enable_vblank,\n\t.disable_vblank\t\t= mtk_drm_crtc_disable_vblank,\n};\n\nstatic const struct drm_crtc_helper_funcs mtk_crtc_helper_funcs = {\n\t.mode_fixup\t= mtk_drm_crtc_mode_fixup,\n\t.mode_set_nofb\t= mtk_drm_crtc_mode_set_nofb,\n\t.atomic_begin\t= mtk_drm_crtc_atomic_begin,\n\t.atomic_flush\t= mtk_drm_crtc_atomic_flush,\n\t.atomic_enable\t= mtk_drm_crtc_atomic_enable,\n\t.atomic_disable\t= mtk_drm_crtc_atomic_disable,\n};\n\nstatic int mtk_drm_crtc_init(struct drm_device *drm,\n\t\t\t     struct mtk_drm_crtc *mtk_crtc,\n\t\t\t     unsigned int pipe)\n{\n\tstruct drm_plane *primary = NULL;\n\tstruct drm_plane *cursor = NULL;\n\tint i, ret;\n\n\tfor (i = 0; i < mtk_crtc->layer_nr; i++) {\n\t\tif (mtk_crtc->planes[i].type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\tprimary = &mtk_crtc->planes[i];\n\t\telse if (mtk_crtc->planes[i].type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcursor = &mtk_crtc->planes[i];\n\t}\n\n\tret = drm_crtc_init_with_planes(drm, &mtk_crtc->base, primary, cursor,\n\t\t\t\t\t&mtk_crtc_funcs, NULL);\n\tif (ret)\n\t\tgoto err_cleanup_crtc;\n\n\tdrm_crtc_helper_add(&mtk_crtc->base, &mtk_crtc_helper_funcs);\n\n\treturn 0;\n\nerr_cleanup_crtc:\n\tdrm_crtc_cleanup(&mtk_crtc->base);\n\treturn ret;\n}\n\nstatic int mtk_drm_crtc_num_comp_planes(struct mtk_drm_crtc *mtk_crtc,\n\t\t\t\t\tint comp_idx)\n{\n\tstruct mtk_ddp_comp *comp;\n\n\tif (comp_idx > 1)\n\t\treturn 0;\n\n\tcomp = mtk_crtc->ddp_comp[comp_idx];\n\tif (!comp->funcs)\n\t\treturn 0;\n\n\tif (comp_idx == 1 && !comp->funcs->bgclr_in_on)\n\t\treturn 0;\n\n\treturn mtk_ddp_comp_layer_nr(comp);\n}\n\nstatic inline\nenum drm_plane_type mtk_drm_crtc_plane_type(unsigned int plane_idx,\n\t\t\t\t\t    unsigned int num_planes)\n{\n\tif (plane_idx == 0)\n\t\treturn DRM_PLANE_TYPE_PRIMARY;\n\telse if (plane_idx == (num_planes - 1))\n\t\treturn DRM_PLANE_TYPE_CURSOR;\n\telse\n\t\treturn DRM_PLANE_TYPE_OVERLAY;\n\n}\n\nstatic int mtk_drm_crtc_init_comp_planes(struct drm_device *drm_dev,\n\t\t\t\t\t struct mtk_drm_crtc *mtk_crtc,\n\t\t\t\t\t int comp_idx, int pipe)\n{\n\tint num_planes = mtk_drm_crtc_num_comp_planes(mtk_crtc, comp_idx);\n\tstruct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[comp_idx];\n\tint i, ret;\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tret = mtk_plane_init(drm_dev,\n\t\t\t\t&mtk_crtc->planes[mtk_crtc->layer_nr],\n\t\t\t\tBIT(pipe),\n\t\t\t\tmtk_drm_crtc_plane_type(mtk_crtc->layer_nr,\n\t\t\t\t\t\t\tnum_planes),\n\t\t\t\tmtk_ddp_comp_supported_rotations(comp),\n\t\t\t\tmtk_ddp_comp_get_formats(comp),\n\t\t\t\tmtk_ddp_comp_get_num_formats(comp));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmtk_crtc->layer_nr++;\n\t}\n\treturn 0;\n}\n\nstruct device *mtk_drm_crtc_dma_dev_get(struct drm_crtc *crtc)\n{\n\tstruct mtk_drm_crtc *mtk_crtc = NULL;\n\n\tif (!crtc)\n\t\treturn NULL;\n\n\tmtk_crtc = to_mtk_crtc(crtc);\n\tif (!mtk_crtc)\n\t\treturn NULL;\n\n\treturn mtk_crtc->dma_dev;\n}\n\nint mtk_drm_crtc_create(struct drm_device *drm_dev,\n\t\t\tconst unsigned int *path, unsigned int path_len,\n\t\t\tint priv_data_index)\n{\n\tstruct mtk_drm_private *priv = drm_dev->dev_private;\n\tstruct device *dev = drm_dev->dev;\n\tstruct mtk_drm_crtc *mtk_crtc;\n\tunsigned int num_comp_planes = 0;\n\tint ret;\n\tint i;\n\tbool has_ctm = false;\n\tuint gamma_lut_size = 0;\n\tstruct drm_crtc *tmp;\n\tint crtc_i = 0;\n\n\tif (!path)\n\t\treturn 0;\n\n\tpriv = priv->all_drm_private[priv_data_index];\n\n\tdrm_for_each_crtc(tmp, drm_dev)\n\t\tcrtc_i++;\n\n\tfor (i = 0; i < path_len; i++) {\n\t\tenum mtk_ddp_comp_id comp_id = path[i];\n\t\tstruct device_node *node;\n\t\tstruct mtk_ddp_comp *comp;\n\n\t\tnode = priv->comp_node[comp_id];\n\t\tcomp = &priv->ddp_comp[comp_id];\n\n\t\t \n\t\tif (!node && comp_id != DDP_COMPONENT_DRM_OVL_ADAPTOR) {\n\t\t\tdev_info(dev,\n\t\t\t\t\"Not creating crtc %d because component %d is disabled or missing\\n\",\n\t\t\t\tcrtc_i, comp_id);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!comp->dev) {\n\t\t\tdev_err(dev, \"Component %pOF not initialized\\n\", node);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tmtk_crtc = devm_kzalloc(dev, sizeof(*mtk_crtc), GFP_KERNEL);\n\tif (!mtk_crtc)\n\t\treturn -ENOMEM;\n\n\tmtk_crtc->mmsys_dev = priv->mmsys_dev;\n\tmtk_crtc->ddp_comp_nr = path_len;\n\tmtk_crtc->ddp_comp = devm_kmalloc_array(dev, mtk_crtc->ddp_comp_nr,\n\t\t\t\t\t\tsizeof(*mtk_crtc->ddp_comp),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!mtk_crtc->ddp_comp)\n\t\treturn -ENOMEM;\n\n\tmtk_crtc->mutex = mtk_mutex_get(priv->mutex_dev);\n\tif (IS_ERR(mtk_crtc->mutex)) {\n\t\tret = PTR_ERR(mtk_crtc->mutex);\n\t\tdev_err(dev, \"Failed to get mutex: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tunsigned int comp_id = path[i];\n\t\tstruct mtk_ddp_comp *comp;\n\n\t\tcomp = &priv->ddp_comp[comp_id];\n\t\tmtk_crtc->ddp_comp[i] = comp;\n\n\t\tif (comp->funcs) {\n\t\t\tif (comp->funcs->gamma_set)\n\t\t\t\tgamma_lut_size = MTK_LUT_SIZE;\n\n\t\t\tif (comp->funcs->ctm_set)\n\t\t\t\thas_ctm = true;\n\t\t}\n\n\t\tmtk_ddp_comp_register_vblank_cb(comp, mtk_crtc_ddp_irq,\n\t\t\t\t\t\t&mtk_crtc->base);\n\t}\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++)\n\t\tnum_comp_planes += mtk_drm_crtc_num_comp_planes(mtk_crtc, i);\n\n\tmtk_crtc->planes = devm_kcalloc(dev, num_comp_planes,\n\t\t\t\t\tsizeof(struct drm_plane), GFP_KERNEL);\n\tif (!mtk_crtc->planes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {\n\t\tret = mtk_drm_crtc_init_comp_planes(drm_dev, mtk_crtc, i,\n\t\t\t\t\t\t    crtc_i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmtk_crtc->dma_dev = mtk_ddp_comp_dma_dev_get(&priv->ddp_comp[path[0]]);\n\n\tret = mtk_drm_crtc_init(drm_dev, mtk_crtc, crtc_i);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (gamma_lut_size)\n\t\tdrm_mode_crtc_set_gamma_size(&mtk_crtc->base, gamma_lut_size);\n\tdrm_crtc_enable_color_mgmt(&mtk_crtc->base, 0, has_ctm, gamma_lut_size);\n\tmutex_init(&mtk_crtc->hw_lock);\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\ti = priv->mbox_index++;\n\tmtk_crtc->cmdq_client.client.dev = mtk_crtc->mmsys_dev;\n\tmtk_crtc->cmdq_client.client.tx_block = false;\n\tmtk_crtc->cmdq_client.client.knows_txdone = true;\n\tmtk_crtc->cmdq_client.client.rx_callback = ddp_cmdq_cb;\n\tmtk_crtc->cmdq_client.chan =\n\t\t\tmbox_request_channel(&mtk_crtc->cmdq_client.client, i);\n\tif (IS_ERR(mtk_crtc->cmdq_client.chan)) {\n\t\tdev_dbg(dev, \"mtk_crtc %d failed to create mailbox client, writing register by CPU now\\n\",\n\t\t\tdrm_crtc_index(&mtk_crtc->base));\n\t\tmtk_crtc->cmdq_client.chan = NULL;\n\t}\n\n\tif (mtk_crtc->cmdq_client.chan) {\n\t\tret = of_property_read_u32_index(priv->mutex_node,\n\t\t\t\t\t\t \"mediatek,gce-events\",\n\t\t\t\t\t\t i,\n\t\t\t\t\t\t &mtk_crtc->cmdq_event);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"mtk_crtc %d failed to get mediatek,gce-events property\\n\",\n\t\t\t\tdrm_crtc_index(&mtk_crtc->base));\n\t\t\tmbox_free_channel(mtk_crtc->cmdq_client.chan);\n\t\t\tmtk_crtc->cmdq_client.chan = NULL;\n\t\t} else {\n\t\t\tret = mtk_drm_cmdq_pkt_create(&mtk_crtc->cmdq_client,\n\t\t\t\t\t\t      &mtk_crtc->cmdq_handle,\n\t\t\t\t\t\t      PAGE_SIZE);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(dev, \"mtk_crtc %d failed to create cmdq packet\\n\",\n\t\t\t\t\tdrm_crtc_index(&mtk_crtc->base));\n\t\t\t\tmbox_free_channel(mtk_crtc->cmdq_client.chan);\n\t\t\t\tmtk_crtc->cmdq_client.chan = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tinit_waitqueue_head(&mtk_crtc->cb_blocking_queue);\n\t}\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}