{
  "module_name": "mtk_dsi.c",
  "hash_id": "267056bd39b5c7435ef4201951c95676fdc1294a703f9bc7a0439641e80b334e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <video/mipi_display.h>\n#include <video/videomode.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n\n#define DSI_START\t\t0x00\n\n#define DSI_INTEN\t\t0x08\n\n#define DSI_INTSTA\t\t0x0c\n#define LPRX_RD_RDY_INT_FLAG\t\tBIT(0)\n#define CMD_DONE_INT_FLAG\t\tBIT(1)\n#define TE_RDY_INT_FLAG\t\t\tBIT(2)\n#define VM_DONE_INT_FLAG\t\tBIT(3)\n#define EXT_TE_RDY_INT_FLAG\t\tBIT(4)\n#define DSI_BUSY\t\t\tBIT(31)\n\n#define DSI_CON_CTRL\t\t0x10\n#define DSI_RESET\t\t\tBIT(0)\n#define DSI_EN\t\t\t\tBIT(1)\n#define DPHY_RESET\t\t\tBIT(2)\n\n#define DSI_MODE_CTRL\t\t0x14\n#define MODE\t\t\t\t(3)\n#define CMD_MODE\t\t\t0\n#define SYNC_PULSE_MODE\t\t\t1\n#define SYNC_EVENT_MODE\t\t\t2\n#define BURST_MODE\t\t\t3\n#define FRM_MODE\t\t\tBIT(16)\n#define MIX_MODE\t\t\tBIT(17)\n\n#define DSI_TXRX_CTRL\t\t0x18\n#define VC_NUM\t\t\t\tBIT(1)\n#define LANE_NUM\t\t\t(0xf << 2)\n#define DIS_EOT\t\t\t\tBIT(6)\n#define NULL_EN\t\t\t\tBIT(7)\n#define TE_FREERUN\t\t\tBIT(8)\n#define EXT_TE_EN\t\t\tBIT(9)\n#define EXT_TE_EDGE\t\t\tBIT(10)\n#define MAX_RTN_SIZE\t\t\t(0xf << 12)\n#define HSTX_CKLP_EN\t\t\tBIT(16)\n\n#define DSI_PSCTRL\t\t0x1c\n#define DSI_PS_WC\t\t\t0x3fff\n#define DSI_PS_SEL\t\t\t(3 << 16)\n#define PACKED_PS_16BIT_RGB565\t\t(0 << 16)\n#define LOOSELY_PS_18BIT_RGB666\t\t(1 << 16)\n#define PACKED_PS_18BIT_RGB666\t\t(2 << 16)\n#define PACKED_PS_24BIT_RGB888\t\t(3 << 16)\n\n#define DSI_VSA_NL\t\t0x20\n#define DSI_VBP_NL\t\t0x24\n#define DSI_VFP_NL\t\t0x28\n#define DSI_VACT_NL\t\t0x2C\n#define DSI_SIZE_CON\t\t0x38\n#define DSI_HSA_WC\t\t0x50\n#define DSI_HBP_WC\t\t0x54\n#define DSI_HFP_WC\t\t0x58\n\n#define DSI_CMDQ_SIZE\t\t0x60\n#define CMDQ_SIZE\t\t\t0x3f\n\n#define DSI_HSTX_CKL_WC\t\t0x64\n\n#define DSI_RX_DATA0\t\t0x74\n#define DSI_RX_DATA1\t\t0x78\n#define DSI_RX_DATA2\t\t0x7c\n#define DSI_RX_DATA3\t\t0x80\n\n#define DSI_RACK\t\t0x84\n#define RACK\t\t\t\tBIT(0)\n\n#define DSI_PHY_LCCON\t\t0x104\n#define LC_HS_TX_EN\t\t\tBIT(0)\n#define LC_ULPM_EN\t\t\tBIT(1)\n#define LC_WAKEUP_EN\t\t\tBIT(2)\n\n#define DSI_PHY_LD0CON\t\t0x108\n#define LD0_HS_TX_EN\t\t\tBIT(0)\n#define LD0_ULPM_EN\t\t\tBIT(1)\n#define LD0_WAKEUP_EN\t\t\tBIT(2)\n\n#define DSI_PHY_TIMECON0\t0x110\n#define LPX\t\t\t\t(0xff << 0)\n#define HS_PREP\t\t\t\t(0xff << 8)\n#define HS_ZERO\t\t\t\t(0xff << 16)\n#define HS_TRAIL\t\t\t(0xff << 24)\n\n#define DSI_PHY_TIMECON1\t0x114\n#define TA_GO\t\t\t\t(0xff << 0)\n#define TA_SURE\t\t\t\t(0xff << 8)\n#define TA_GET\t\t\t\t(0xff << 16)\n#define DA_HS_EXIT\t\t\t(0xff << 24)\n\n#define DSI_PHY_TIMECON2\t0x118\n#define CONT_DET\t\t\t(0xff << 0)\n#define CLK_ZERO\t\t\t(0xff << 16)\n#define CLK_TRAIL\t\t\t(0xff << 24)\n\n#define DSI_PHY_TIMECON3\t0x11c\n#define CLK_HS_PREP\t\t\t(0xff << 0)\n#define CLK_HS_POST\t\t\t(0xff << 8)\n#define CLK_HS_EXIT\t\t\t(0xff << 16)\n\n#define DSI_VM_CMD_CON\t\t0x130\n#define VM_CMD_EN\t\t\tBIT(0)\n#define TS_VFP_EN\t\t\tBIT(5)\n\n#define DSI_SHADOW_DEBUG\t0x190U\n#define FORCE_COMMIT\t\t\tBIT(0)\n#define BYPASS_SHADOW\t\t\tBIT(1)\n\n#define CONFIG\t\t\t\t(0xff << 0)\n#define SHORT_PACKET\t\t\t0\n#define LONG_PACKET\t\t\t2\n#define BTA\t\t\t\tBIT(2)\n#define DATA_ID\t\t\t\t(0xff << 8)\n#define DATA_0\t\t\t\t(0xff << 16)\n#define DATA_1\t\t\t\t(0xff << 24)\n\n#define NS_TO_CYCLE(n, c)    ((n) / (c) + (((n) % (c)) ? 1 : 0))\n\n#define MTK_DSI_HOST_IS_READ(type) \\\n\t((type == MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM) || \\\n\t(type == MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM) || \\\n\t(type == MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM) || \\\n\t(type == MIPI_DSI_DCS_READ))\n\nstruct mtk_phy_timing {\n\tu32 lpx;\n\tu32 da_hs_prepare;\n\tu32 da_hs_zero;\n\tu32 da_hs_trail;\n\n\tu32 ta_go;\n\tu32 ta_sure;\n\tu32 ta_get;\n\tu32 da_hs_exit;\n\n\tu32 clk_hs_zero;\n\tu32 clk_hs_trail;\n\n\tu32 clk_hs_prepare;\n\tu32 clk_hs_post;\n\tu32 clk_hs_exit;\n};\n\nstruct phy;\n\nstruct mtk_dsi_driver_data {\n\tconst u32 reg_cmdq_off;\n\tbool has_shadow_ctl;\n\tbool has_size_ctl;\n};\n\nstruct mtk_dsi {\n\tstruct device *dev;\n\tstruct mipi_dsi_host host;\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *connector;\n\tstruct phy *phy;\n\n\tvoid __iomem *regs;\n\n\tstruct clk *engine_clk;\n\tstruct clk *digital_clk;\n\tstruct clk *hs_clk;\n\n\tu32 data_rate;\n\n\tunsigned long mode_flags;\n\tenum mipi_dsi_pixel_format format;\n\tunsigned int lanes;\n\tstruct videomode vm;\n\tstruct mtk_phy_timing phy_timing;\n\tint refcount;\n\tbool enabled;\n\tbool lanes_ready;\n\tu32 irq_data;\n\twait_queue_head_t irq_wait_queue;\n\tconst struct mtk_dsi_driver_data *driver_data;\n};\n\nstatic inline struct mtk_dsi *bridge_to_dsi(struct drm_bridge *b)\n{\n\treturn container_of(b, struct mtk_dsi, bridge);\n}\n\nstatic inline struct mtk_dsi *host_to_dsi(struct mipi_dsi_host *h)\n{\n\treturn container_of(h, struct mtk_dsi, host);\n}\n\nstatic void mtk_dsi_mask(struct mtk_dsi *dsi, u32 offset, u32 mask, u32 data)\n{\n\tu32 temp = readl(dsi->regs + offset);\n\n\twritel((temp & ~mask) | (data & mask), dsi->regs + offset);\n}\n\nstatic void mtk_dsi_phy_timconfig(struct mtk_dsi *dsi)\n{\n\tu32 timcon0, timcon1, timcon2, timcon3;\n\tu32 data_rate_mhz = DIV_ROUND_UP(dsi->data_rate, 1000000);\n\tstruct mtk_phy_timing *timing = &dsi->phy_timing;\n\n\ttiming->lpx = (60 * data_rate_mhz / (8 * 1000)) + 1;\n\ttiming->da_hs_prepare = (80 * data_rate_mhz + 4 * 1000) / 8000;\n\ttiming->da_hs_zero = (170 * data_rate_mhz + 10 * 1000) / 8000 + 1 -\n\t\t\t     timing->da_hs_prepare;\n\ttiming->da_hs_trail = timing->da_hs_prepare + 1;\n\n\ttiming->ta_go = 4 * timing->lpx - 2;\n\ttiming->ta_sure = timing->lpx + 2;\n\ttiming->ta_get = 4 * timing->lpx;\n\ttiming->da_hs_exit = 2 * timing->lpx + 1;\n\n\ttiming->clk_hs_prepare = 70 * data_rate_mhz / (8 * 1000);\n\ttiming->clk_hs_post = timing->clk_hs_prepare + 8;\n\ttiming->clk_hs_trail = timing->clk_hs_prepare;\n\ttiming->clk_hs_zero = timing->clk_hs_trail * 4;\n\ttiming->clk_hs_exit = 2 * timing->clk_hs_trail;\n\n\ttimcon0 = timing->lpx | timing->da_hs_prepare << 8 |\n\t\t  timing->da_hs_zero << 16 | timing->da_hs_trail << 24;\n\ttimcon1 = timing->ta_go | timing->ta_sure << 8 |\n\t\t  timing->ta_get << 16 | timing->da_hs_exit << 24;\n\ttimcon2 = 1 << 8 | timing->clk_hs_zero << 16 |\n\t\t  timing->clk_hs_trail << 24;\n\ttimcon3 = timing->clk_hs_prepare | timing->clk_hs_post << 8 |\n\t\t  timing->clk_hs_exit << 16;\n\n\twritel(timcon0, dsi->regs + DSI_PHY_TIMECON0);\n\twritel(timcon1, dsi->regs + DSI_PHY_TIMECON1);\n\twritel(timcon2, dsi->regs + DSI_PHY_TIMECON2);\n\twritel(timcon3, dsi->regs + DSI_PHY_TIMECON3);\n}\n\nstatic void mtk_dsi_enable(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DSI_EN, DSI_EN);\n}\n\nstatic void mtk_dsi_disable(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DSI_EN, 0);\n}\n\nstatic void mtk_dsi_reset_engine(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DSI_RESET, DSI_RESET);\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DSI_RESET, 0);\n}\n\nstatic void mtk_dsi_reset_dphy(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DPHY_RESET, DPHY_RESET);\n\tmtk_dsi_mask(dsi, DSI_CON_CTRL, DPHY_RESET, 0);\n}\n\nstatic void mtk_dsi_clk_ulp_mode_enter(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_HS_TX_EN, 0);\n\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_ULPM_EN, 0);\n}\n\nstatic void mtk_dsi_clk_ulp_mode_leave(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_ULPM_EN, 0);\n\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_WAKEUP_EN, LC_WAKEUP_EN);\n\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_WAKEUP_EN, 0);\n}\n\nstatic void mtk_dsi_lane0_ulp_mode_enter(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_PHY_LD0CON, LD0_HS_TX_EN, 0);\n\tmtk_dsi_mask(dsi, DSI_PHY_LD0CON, LD0_ULPM_EN, 0);\n}\n\nstatic void mtk_dsi_lane0_ulp_mode_leave(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_PHY_LD0CON, LD0_ULPM_EN, 0);\n\tmtk_dsi_mask(dsi, DSI_PHY_LD0CON, LD0_WAKEUP_EN, LD0_WAKEUP_EN);\n\tmtk_dsi_mask(dsi, DSI_PHY_LD0CON, LD0_WAKEUP_EN, 0);\n}\n\nstatic bool mtk_dsi_clk_hs_state(struct mtk_dsi *dsi)\n{\n\treturn readl(dsi->regs + DSI_PHY_LCCON) & LC_HS_TX_EN;\n}\n\nstatic void mtk_dsi_clk_hs_mode(struct mtk_dsi *dsi, bool enter)\n{\n\tif (enter && !mtk_dsi_clk_hs_state(dsi))\n\t\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_HS_TX_EN, LC_HS_TX_EN);\n\telse if (!enter && mtk_dsi_clk_hs_state(dsi))\n\t\tmtk_dsi_mask(dsi, DSI_PHY_LCCON, LC_HS_TX_EN, 0);\n}\n\nstatic void mtk_dsi_set_mode(struct mtk_dsi *dsi)\n{\n\tu32 vid_mode = CMD_MODE;\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\t\tvid_mode = BURST_MODE;\n\t\telse if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\t\tvid_mode = SYNC_PULSE_MODE;\n\t\telse\n\t\t\tvid_mode = SYNC_EVENT_MODE;\n\t}\n\n\twritel(vid_mode, dsi->regs + DSI_MODE_CTRL);\n}\n\nstatic void mtk_dsi_set_vm_cmd(struct mtk_dsi *dsi)\n{\n\tmtk_dsi_mask(dsi, DSI_VM_CMD_CON, VM_CMD_EN, VM_CMD_EN);\n\tmtk_dsi_mask(dsi, DSI_VM_CMD_CON, TS_VFP_EN, TS_VFP_EN);\n}\n\nstatic void mtk_dsi_ps_control_vact(struct mtk_dsi *dsi)\n{\n\tstruct videomode *vm = &dsi->vm;\n\tu32 dsi_buf_bpp, ps_wc;\n\tu32 ps_bpp_mode;\n\n\tif (dsi->format == MIPI_DSI_FMT_RGB565)\n\t\tdsi_buf_bpp = 2;\n\telse\n\t\tdsi_buf_bpp = 3;\n\n\tps_wc = vm->hactive * dsi_buf_bpp;\n\tps_bpp_mode = ps_wc;\n\n\tswitch (dsi->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tps_bpp_mode |= PACKED_PS_24BIT_RGB888;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tps_bpp_mode |= PACKED_PS_18BIT_RGB666;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tps_bpp_mode |= LOOSELY_PS_18BIT_RGB666;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tps_bpp_mode |= PACKED_PS_16BIT_RGB565;\n\t\tbreak;\n\t}\n\n\twritel(vm->vactive, dsi->regs + DSI_VACT_NL);\n\twritel(ps_bpp_mode, dsi->regs + DSI_PSCTRL);\n\twritel(ps_wc, dsi->regs + DSI_HSTX_CKL_WC);\n}\n\nstatic void mtk_dsi_rxtx_control(struct mtk_dsi *dsi)\n{\n\tu32 tmp_reg;\n\n\tswitch (dsi->lanes) {\n\tcase 1:\n\t\ttmp_reg = 1 << 2;\n\t\tbreak;\n\tcase 2:\n\t\ttmp_reg = 3 << 2;\n\t\tbreak;\n\tcase 3:\n\t\ttmp_reg = 7 << 2;\n\t\tbreak;\n\tcase 4:\n\t\ttmp_reg = 0xf << 2;\n\t\tbreak;\n\tdefault:\n\t\ttmp_reg = 0xf << 2;\n\t\tbreak;\n\t}\n\n\tif (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)\n\t\ttmp_reg |= HSTX_CKLP_EN;\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET)\n\t\ttmp_reg |= DIS_EOT;\n\n\twritel(tmp_reg, dsi->regs + DSI_TXRX_CTRL);\n}\n\nstatic void mtk_dsi_ps_control(struct mtk_dsi *dsi)\n{\n\tu32 dsi_tmp_buf_bpp;\n\tu32 tmp_reg;\n\n\tswitch (dsi->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\ttmp_reg = PACKED_PS_24BIT_RGB888;\n\t\tdsi_tmp_buf_bpp = 3;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\ttmp_reg = LOOSELY_PS_18BIT_RGB666;\n\t\tdsi_tmp_buf_bpp = 3;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\ttmp_reg = PACKED_PS_18BIT_RGB666;\n\t\tdsi_tmp_buf_bpp = 3;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\ttmp_reg = PACKED_PS_16BIT_RGB565;\n\t\tdsi_tmp_buf_bpp = 2;\n\t\tbreak;\n\tdefault:\n\t\ttmp_reg = PACKED_PS_24BIT_RGB888;\n\t\tdsi_tmp_buf_bpp = 3;\n\t\tbreak;\n\t}\n\n\ttmp_reg += dsi->vm.hactive * dsi_tmp_buf_bpp & DSI_PS_WC;\n\twritel(tmp_reg, dsi->regs + DSI_PSCTRL);\n}\n\nstatic void mtk_dsi_config_vdo_timing(struct mtk_dsi *dsi)\n{\n\tu32 horizontal_sync_active_byte;\n\tu32 horizontal_backporch_byte;\n\tu32 horizontal_frontporch_byte;\n\tu32 horizontal_front_back_byte;\n\tu32 data_phy_cycles_byte;\n\tu32 dsi_tmp_buf_bpp, data_phy_cycles;\n\tu32 delta;\n\tstruct mtk_phy_timing *timing = &dsi->phy_timing;\n\n\tstruct videomode *vm = &dsi->vm;\n\n\tif (dsi->format == MIPI_DSI_FMT_RGB565)\n\t\tdsi_tmp_buf_bpp = 2;\n\telse\n\t\tdsi_tmp_buf_bpp = 3;\n\n\twritel(vm->vsync_len, dsi->regs + DSI_VSA_NL);\n\twritel(vm->vback_porch, dsi->regs + DSI_VBP_NL);\n\twritel(vm->vfront_porch, dsi->regs + DSI_VFP_NL);\n\twritel(vm->vactive, dsi->regs + DSI_VACT_NL);\n\n\tif (dsi->driver_data->has_size_ctl)\n\t\twritel(vm->vactive << 16 | vm->hactive,\n\t\t       dsi->regs + DSI_SIZE_CON);\n\n\thorizontal_sync_active_byte = (vm->hsync_len * dsi_tmp_buf_bpp - 10);\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\thorizontal_backporch_byte = vm->hback_porch * dsi_tmp_buf_bpp - 10;\n\telse\n\t\thorizontal_backporch_byte = (vm->hback_porch + vm->hsync_len) *\n\t\t\t\t\t    dsi_tmp_buf_bpp - 10;\n\n\tdata_phy_cycles = timing->lpx + timing->da_hs_prepare +\n\t\t\t  timing->da_hs_zero + timing->da_hs_exit + 3;\n\n\tdelta = dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST ? 18 : 12;\n\tdelta += dsi->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET ? 0 : 2;\n\n\thorizontal_frontporch_byte = vm->hfront_porch * dsi_tmp_buf_bpp;\n\thorizontal_front_back_byte = horizontal_frontporch_byte + horizontal_backporch_byte;\n\tdata_phy_cycles_byte = data_phy_cycles * dsi->lanes + delta;\n\n\tif (horizontal_front_back_byte > data_phy_cycles_byte) {\n\t\thorizontal_frontporch_byte -= data_phy_cycles_byte *\n\t\t\t\t\t      horizontal_frontporch_byte /\n\t\t\t\t\t      horizontal_front_back_byte;\n\n\t\thorizontal_backporch_byte -= data_phy_cycles_byte *\n\t\t\t\t\t     horizontal_backporch_byte /\n\t\t\t\t\t     horizontal_front_back_byte;\n\t} else {\n\t\tDRM_WARN(\"HFP + HBP less than d-phy, FPS will under 60Hz\\n\");\n\t}\n\n\tif ((dsi->mode_flags & MIPI_DSI_HS_PKT_END_ALIGNED) &&\n\t    (dsi->lanes == 4)) {\n\t\thorizontal_sync_active_byte =\n\t\t\troundup(horizontal_sync_active_byte, dsi->lanes) - 2;\n\t\thorizontal_frontporch_byte =\n\t\t\troundup(horizontal_frontporch_byte, dsi->lanes) - 2;\n\t\thorizontal_backporch_byte =\n\t\t\troundup(horizontal_backporch_byte, dsi->lanes) - 2;\n\t\thorizontal_backporch_byte -=\n\t\t\t(vm->hactive * dsi_tmp_buf_bpp + 2) % dsi->lanes;\n\t}\n\n\twritel(horizontal_sync_active_byte, dsi->regs + DSI_HSA_WC);\n\twritel(horizontal_backporch_byte, dsi->regs + DSI_HBP_WC);\n\twritel(horizontal_frontporch_byte, dsi->regs + DSI_HFP_WC);\n\n\tmtk_dsi_ps_control(dsi);\n}\n\nstatic void mtk_dsi_start(struct mtk_dsi *dsi)\n{\n\twritel(0, dsi->regs + DSI_START);\n\twritel(1, dsi->regs + DSI_START);\n}\n\nstatic void mtk_dsi_stop(struct mtk_dsi *dsi)\n{\n\twritel(0, dsi->regs + DSI_START);\n}\n\nstatic void mtk_dsi_set_cmd_mode(struct mtk_dsi *dsi)\n{\n\twritel(CMD_MODE, dsi->regs + DSI_MODE_CTRL);\n}\n\nstatic void mtk_dsi_set_interrupt_enable(struct mtk_dsi *dsi)\n{\n\tu32 inten = LPRX_RD_RDY_INT_FLAG | CMD_DONE_INT_FLAG | VM_DONE_INT_FLAG;\n\n\twritel(inten, dsi->regs + DSI_INTEN);\n}\n\nstatic void mtk_dsi_irq_data_set(struct mtk_dsi *dsi, u32 irq_bit)\n{\n\tdsi->irq_data |= irq_bit;\n}\n\nstatic void mtk_dsi_irq_data_clear(struct mtk_dsi *dsi, u32 irq_bit)\n{\n\tdsi->irq_data &= ~irq_bit;\n}\n\nstatic s32 mtk_dsi_wait_for_irq_done(struct mtk_dsi *dsi, u32 irq_flag,\n\t\t\t\t     unsigned int timeout)\n{\n\ts32 ret = 0;\n\tunsigned long jiffies = msecs_to_jiffies(timeout);\n\n\tret = wait_event_interruptible_timeout(dsi->irq_wait_queue,\n\t\t\t\t\t       dsi->irq_data & irq_flag,\n\t\t\t\t\t       jiffies);\n\tif (ret == 0) {\n\t\tDRM_WARN(\"Wait DSI IRQ(0x%08x) Timeout\\n\", irq_flag);\n\n\t\tmtk_dsi_enable(dsi);\n\t\tmtk_dsi_reset_engine(dsi);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t mtk_dsi_irq(int irq, void *dev_id)\n{\n\tstruct mtk_dsi *dsi = dev_id;\n\tu32 status, tmp;\n\tu32 flag = LPRX_RD_RDY_INT_FLAG | CMD_DONE_INT_FLAG | VM_DONE_INT_FLAG;\n\n\tstatus = readl(dsi->regs + DSI_INTSTA) & flag;\n\n\tif (status) {\n\t\tdo {\n\t\t\tmtk_dsi_mask(dsi, DSI_RACK, RACK, RACK);\n\t\t\ttmp = readl(dsi->regs + DSI_INTSTA);\n\t\t} while (tmp & DSI_BUSY);\n\n\t\tmtk_dsi_mask(dsi, DSI_INTSTA, status, 0);\n\t\tmtk_dsi_irq_data_set(dsi, status);\n\t\twake_up_interruptible(&dsi->irq_wait_queue);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic s32 mtk_dsi_switch_to_cmd_mode(struct mtk_dsi *dsi, u8 irq_flag, u32 t)\n{\n\tmtk_dsi_irq_data_clear(dsi, irq_flag);\n\tmtk_dsi_set_cmd_mode(dsi);\n\n\tif (!mtk_dsi_wait_for_irq_done(dsi, irq_flag, t)) {\n\t\tDRM_ERROR(\"failed to switch cmd mode\\n\");\n\t\treturn -ETIME;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int mtk_dsi_poweron(struct mtk_dsi *dsi)\n{\n\tstruct device *dev = dsi->host.dev;\n\tint ret;\n\tu32 bit_per_pixel;\n\n\tif (++dsi->refcount != 1)\n\t\treturn 0;\n\n\tswitch (dsi->format) {\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tbit_per_pixel = 16;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tbit_per_pixel = 18;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\tcase MIPI_DSI_FMT_RGB888:\n\tdefault:\n\t\tbit_per_pixel = 24;\n\t\tbreak;\n\t}\n\n\tdsi->data_rate = DIV_ROUND_UP_ULL(dsi->vm.pixelclock * bit_per_pixel,\n\t\t\t\t\t  dsi->lanes);\n\n\tret = clk_set_rate(dsi->hs_clk, dsi->data_rate);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set data rate: %d\\n\", ret);\n\t\tgoto err_refcount;\n\t}\n\n\tphy_power_on(dsi->phy);\n\n\tret = clk_prepare_enable(dsi->engine_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable engine clock: %d\\n\", ret);\n\t\tgoto err_phy_power_off;\n\t}\n\n\tret = clk_prepare_enable(dsi->digital_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable digital clock: %d\\n\", ret);\n\t\tgoto err_disable_engine_clk;\n\t}\n\n\tmtk_dsi_enable(dsi);\n\n\tif (dsi->driver_data->has_shadow_ctl)\n\t\twritel(FORCE_COMMIT | BYPASS_SHADOW,\n\t\t       dsi->regs + DSI_SHADOW_DEBUG);\n\n\tmtk_dsi_reset_engine(dsi);\n\tmtk_dsi_phy_timconfig(dsi);\n\n\tmtk_dsi_ps_control_vact(dsi);\n\tmtk_dsi_set_vm_cmd(dsi);\n\tmtk_dsi_config_vdo_timing(dsi);\n\tmtk_dsi_set_interrupt_enable(dsi);\n\n\treturn 0;\nerr_disable_engine_clk:\n\tclk_disable_unprepare(dsi->engine_clk);\nerr_phy_power_off:\n\tphy_power_off(dsi->phy);\nerr_refcount:\n\tdsi->refcount--;\n\treturn ret;\n}\n\nstatic void mtk_dsi_poweroff(struct mtk_dsi *dsi)\n{\n\tif (WARN_ON(dsi->refcount == 0))\n\t\treturn;\n\n\tif (--dsi->refcount != 0)\n\t\treturn;\n\n\t \n\tmtk_dsi_stop(dsi);\n\n\tmtk_dsi_switch_to_cmd_mode(dsi, VM_DONE_INT_FLAG, 500);\n\tmtk_dsi_reset_engine(dsi);\n\tmtk_dsi_lane0_ulp_mode_enter(dsi);\n\tmtk_dsi_clk_ulp_mode_enter(dsi);\n\t \n\twritel(0, dsi->regs + DSI_TXRX_CTRL);\n\n\tmtk_dsi_disable(dsi);\n\n\tclk_disable_unprepare(dsi->engine_clk);\n\tclk_disable_unprepare(dsi->digital_clk);\n\n\tphy_power_off(dsi->phy);\n\n\tdsi->lanes_ready = false;\n}\n\nstatic void mtk_dsi_lane_ready(struct mtk_dsi *dsi)\n{\n\tif (!dsi->lanes_ready) {\n\t\tdsi->lanes_ready = true;\n\t\tmtk_dsi_rxtx_control(dsi);\n\t\tusleep_range(30, 100);\n\t\tmtk_dsi_reset_dphy(dsi);\n\t\tmtk_dsi_clk_ulp_mode_leave(dsi);\n\t\tmtk_dsi_lane0_ulp_mode_leave(dsi);\n\t\tmtk_dsi_clk_hs_mode(dsi, 0);\n\t\tusleep_range(1000, 3000);\n\t\t \n\t}\n}\n\nstatic void mtk_output_dsi_enable(struct mtk_dsi *dsi)\n{\n\tif (dsi->enabled)\n\t\treturn;\n\n\tmtk_dsi_lane_ready(dsi);\n\tmtk_dsi_set_mode(dsi);\n\tmtk_dsi_clk_hs_mode(dsi, 1);\n\n\tmtk_dsi_start(dsi);\n\n\tdsi->enabled = true;\n}\n\nstatic void mtk_output_dsi_disable(struct mtk_dsi *dsi)\n{\n\tif (!dsi->enabled)\n\t\treturn;\n\n\tdsi->enabled = false;\n}\n\nstatic int mtk_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\n\t \n\treturn drm_bridge_attach(bridge->encoder, dsi->next_bridge,\n\t\t\t\t &dsi->bridge, flags);\n}\n\nstatic void mtk_dsi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    const struct drm_display_mode *adjusted)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\n\tdrm_display_mode_to_videomode(adjusted, &dsi->vm);\n}\n\nstatic void mtk_dsi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\n\tmtk_output_dsi_disable(dsi);\n}\n\nstatic void mtk_dsi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\n\tif (dsi->refcount == 0)\n\t\treturn;\n\n\tmtk_output_dsi_enable(dsi);\n}\n\nstatic void mtk_dsi_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\tint ret;\n\n\tret = mtk_dsi_poweron(dsi);\n\tif (ret < 0)\n\t\tDRM_ERROR(\"failed to power on dsi\\n\");\n}\n\nstatic void mtk_dsi_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t       struct drm_bridge_state *old_bridge_state)\n{\n\tstruct mtk_dsi *dsi = bridge_to_dsi(bridge);\n\n\tmtk_dsi_poweroff(dsi);\n}\n\nstatic const struct drm_bridge_funcs mtk_dsi_bridge_funcs = {\n\t.attach = mtk_dsi_bridge_attach,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_disable = mtk_dsi_bridge_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_enable = mtk_dsi_bridge_atomic_enable,\n\t.atomic_pre_enable = mtk_dsi_bridge_atomic_pre_enable,\n\t.atomic_post_disable = mtk_dsi_bridge_atomic_post_disable,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.mode_set = mtk_dsi_bridge_mode_set,\n};\n\nvoid mtk_dsi_ddp_start(struct device *dev)\n{\n\tstruct mtk_dsi *dsi = dev_get_drvdata(dev);\n\n\tmtk_dsi_poweron(dsi);\n}\n\nvoid mtk_dsi_ddp_stop(struct device *dev)\n{\n\tstruct mtk_dsi *dsi = dev_get_drvdata(dev);\n\n\tmtk_dsi_poweroff(dsi);\n}\n\nstatic int mtk_dsi_encoder_init(struct drm_device *drm, struct mtk_dsi *dsi)\n{\n\tint ret;\n\n\tret = drm_simple_encoder_init(drm, &dsi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_DSI);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to encoder init to drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdsi->encoder.possible_crtcs = mtk_drm_find_possible_crtc_by_comp(drm, dsi->host.dev);\n\n\tret = drm_bridge_attach(&dsi->encoder, &dsi->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\tgoto err_cleanup_encoder;\n\n\tdsi->connector = drm_bridge_connector_init(drm, &dsi->encoder);\n\tif (IS_ERR(dsi->connector)) {\n\t\tDRM_ERROR(\"Unable to create bridge connector\\n\");\n\t\tret = PTR_ERR(dsi->connector);\n\t\tgoto err_cleanup_encoder;\n\t}\n\tdrm_connector_attach_encoder(dsi->connector, &dsi->encoder);\n\n\treturn 0;\n\nerr_cleanup_encoder:\n\tdrm_encoder_cleanup(&dsi->encoder);\n\treturn ret;\n}\n\nstatic int mtk_dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tint ret;\n\tstruct drm_device *drm = data;\n\tstruct mtk_dsi *dsi = dev_get_drvdata(dev);\n\n\tret = mtk_dsi_encoder_init(drm, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn device_reset_optional(dev);\n}\n\nstatic void mtk_dsi_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct mtk_dsi *dsi = dev_get_drvdata(dev);\n\n\tdrm_encoder_cleanup(&dsi->encoder);\n}\n\nstatic const struct component_ops mtk_dsi_component_ops = {\n\t.bind = mtk_dsi_bind,\n\t.unbind = mtk_dsi_unbind,\n};\n\nstatic int mtk_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *device)\n{\n\tstruct mtk_dsi *dsi = host_to_dsi(host);\n\tstruct device *dev = host->dev;\n\tint ret;\n\n\tdsi->lanes = device->lanes;\n\tdsi->format = device->format;\n\tdsi->mode_flags = device->mode_flags;\n\tdsi->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);\n\tif (IS_ERR(dsi->next_bridge))\n\t\treturn PTR_ERR(dsi->next_bridge);\n\n\tdrm_bridge_add(&dsi->bridge);\n\n\tret = component_add(host->dev, &mtk_dsi_component_ops);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to add dsi_host component: %d\\n\", ret);\n\t\tdrm_bridge_remove(&dsi->bridge);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *device)\n{\n\tstruct mtk_dsi *dsi = host_to_dsi(host);\n\n\tcomponent_del(host->dev, &mtk_dsi_component_ops);\n\tdrm_bridge_remove(&dsi->bridge);\n\treturn 0;\n}\n\nstatic void mtk_dsi_wait_for_idle(struct mtk_dsi *dsi)\n{\n\tint ret;\n\tu32 val;\n\n\tret = readl_poll_timeout(dsi->regs + DSI_INTSTA, val, !(val & DSI_BUSY),\n\t\t\t\t 4, 2000000);\n\tif (ret) {\n\t\tDRM_WARN(\"polling dsi wait not busy timeout!\\n\");\n\n\t\tmtk_dsi_enable(dsi);\n\t\tmtk_dsi_reset_engine(dsi);\n\t}\n}\n\nstatic u32 mtk_dsi_recv_cnt(u8 type, u8 *read_data)\n{\n\tswitch (type) {\n\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\n\t\treturn 1;\n\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\n\t\treturn 2;\n\tcase MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:\n\tcase MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:\n\t\treturn read_data[1] + read_data[2] * 16;\n\tcase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\n\t\tDRM_INFO(\"type is 0x02, try again\\n\");\n\t\tbreak;\n\tdefault:\n\t\tDRM_INFO(\"type(0x%x) not recognized\\n\", type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_dsi_cmdq(struct mtk_dsi *dsi, const struct mipi_dsi_msg *msg)\n{\n\tconst char *tx_buf = msg->tx_buf;\n\tu8 config, cmdq_size, cmdq_off, type = msg->type;\n\tu32 reg_val, cmdq_mask, i;\n\tu32 reg_cmdq_off = dsi->driver_data->reg_cmdq_off;\n\n\tif (MTK_DSI_HOST_IS_READ(type))\n\t\tconfig = BTA;\n\telse\n\t\tconfig = (msg->tx_len > 2) ? LONG_PACKET : SHORT_PACKET;\n\n\tif (msg->tx_len > 2) {\n\t\tcmdq_size = 1 + (msg->tx_len + 3) / 4;\n\t\tcmdq_off = 4;\n\t\tcmdq_mask = CONFIG | DATA_ID | DATA_0 | DATA_1;\n\t\treg_val = (msg->tx_len << 16) | (type << 8) | config;\n\t} else {\n\t\tcmdq_size = 1;\n\t\tcmdq_off = 2;\n\t\tcmdq_mask = CONFIG | DATA_ID;\n\t\treg_val = (type << 8) | config;\n\t}\n\n\tfor (i = 0; i < msg->tx_len; i++)\n\t\tmtk_dsi_mask(dsi, (reg_cmdq_off + cmdq_off + i) & (~0x3U),\n\t\t\t     (0xffUL << (((i + cmdq_off) & 3U) * 8U)),\n\t\t\t     tx_buf[i] << (((i + cmdq_off) & 3U) * 8U));\n\n\tmtk_dsi_mask(dsi, reg_cmdq_off, cmdq_mask, reg_val);\n\tmtk_dsi_mask(dsi, DSI_CMDQ_SIZE, CMDQ_SIZE, cmdq_size);\n}\n\nstatic ssize_t mtk_dsi_host_send_cmd(struct mtk_dsi *dsi,\n\t\t\t\t     const struct mipi_dsi_msg *msg, u8 flag)\n{\n\tmtk_dsi_wait_for_idle(dsi);\n\tmtk_dsi_irq_data_clear(dsi, flag);\n\tmtk_dsi_cmdq(dsi, msg);\n\tmtk_dsi_start(dsi);\n\n\tif (!mtk_dsi_wait_for_irq_done(dsi, flag, 2000))\n\t\treturn -ETIME;\n\telse\n\t\treturn 0;\n}\n\nstatic ssize_t mtk_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tstruct mtk_dsi *dsi = host_to_dsi(host);\n\tu32 recv_cnt, i;\n\tu8 read_data[16];\n\tvoid *src_addr;\n\tu8 irq_flag = CMD_DONE_INT_FLAG;\n\tu32 dsi_mode;\n\tint ret;\n\n\tdsi_mode = readl(dsi->regs + DSI_MODE_CTRL);\n\tif (dsi_mode & MODE) {\n\t\tmtk_dsi_stop(dsi);\n\t\tret = mtk_dsi_switch_to_cmd_mode(dsi, VM_DONE_INT_FLAG, 500);\n\t\tif (ret)\n\t\t\tgoto restore_dsi_mode;\n\t}\n\n\tif (MTK_DSI_HOST_IS_READ(msg->type))\n\t\tirq_flag |= LPRX_RD_RDY_INT_FLAG;\n\n\tmtk_dsi_lane_ready(dsi);\n\n\tret = mtk_dsi_host_send_cmd(dsi, msg, irq_flag);\n\tif (ret)\n\t\tgoto restore_dsi_mode;\n\n\tif (!MTK_DSI_HOST_IS_READ(msg->type)) {\n\t\trecv_cnt = 0;\n\t\tgoto restore_dsi_mode;\n\t}\n\n\tif (!msg->rx_buf) {\n\t\tDRM_ERROR(\"dsi receive buffer size may be NULL\\n\");\n\t\tret = -EINVAL;\n\t\tgoto restore_dsi_mode;\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\t*(read_data + i) = readb(dsi->regs + DSI_RX_DATA0 + i);\n\n\trecv_cnt = mtk_dsi_recv_cnt(read_data[0], read_data);\n\n\tif (recv_cnt > 2)\n\t\tsrc_addr = &read_data[4];\n\telse\n\t\tsrc_addr = &read_data[1];\n\n\tif (recv_cnt > 10)\n\t\trecv_cnt = 10;\n\n\tif (recv_cnt > msg->rx_len)\n\t\trecv_cnt = msg->rx_len;\n\n\tif (recv_cnt)\n\t\tmemcpy(msg->rx_buf, src_addr, recv_cnt);\n\n\tDRM_INFO(\"dsi get %d byte data from the panel address(0x%x)\\n\",\n\t\t recv_cnt, *((u8 *)(msg->tx_buf)));\n\nrestore_dsi_mode:\n\tif (dsi_mode & MODE) {\n\t\tmtk_dsi_set_mode(dsi);\n\t\tmtk_dsi_start(dsi);\n\t}\n\n\treturn ret < 0 ? ret : recv_cnt;\n}\n\nstatic const struct mipi_dsi_host_ops mtk_dsi_ops = {\n\t.attach = mtk_dsi_host_attach,\n\t.detach = mtk_dsi_host_detach,\n\t.transfer = mtk_dsi_host_transfer,\n};\n\nstatic int mtk_dsi_probe(struct platform_device *pdev)\n{\n\tstruct mtk_dsi *dsi;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *regs;\n\tint irq_num;\n\tint ret;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->host.ops = &mtk_dsi_ops;\n\tdsi->host.dev = dev;\n\tret = mipi_dsi_host_register(&dsi->host);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register DSI host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->driver_data = of_device_get_match_data(dev);\n\n\tdsi->engine_clk = devm_clk_get(dev, \"engine\");\n\tif (IS_ERR(dsi->engine_clk)) {\n\t\tret = PTR_ERR(dsi->engine_clk);\n\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get engine clock: %d\\n\", ret);\n\t\tgoto err_unregister_host;\n\t}\n\n\tdsi->digital_clk = devm_clk_get(dev, \"digital\");\n\tif (IS_ERR(dsi->digital_clk)) {\n\t\tret = PTR_ERR(dsi->digital_clk);\n\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get digital clock: %d\\n\", ret);\n\t\tgoto err_unregister_host;\n\t}\n\n\tdsi->hs_clk = devm_clk_get(dev, \"hs\");\n\tif (IS_ERR(dsi->hs_clk)) {\n\t\tret = PTR_ERR(dsi->hs_clk);\n\t\tdev_err(dev, \"Failed to get hs clock: %d\\n\", ret);\n\t\tgoto err_unregister_host;\n\t}\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tdsi->regs = devm_ioremap_resource(dev, regs);\n\tif (IS_ERR(dsi->regs)) {\n\t\tret = PTR_ERR(dsi->regs);\n\t\tdev_err(dev, \"Failed to ioremap memory: %d\\n\", ret);\n\t\tgoto err_unregister_host;\n\t}\n\n\tdsi->phy = devm_phy_get(dev, \"dphy\");\n\tif (IS_ERR(dsi->phy)) {\n\t\tret = PTR_ERR(dsi->phy);\n\t\tdev_err(dev, \"Failed to get MIPI-DPHY: %d\\n\", ret);\n\t\tgoto err_unregister_host;\n\t}\n\n\tirq_num = platform_get_irq(pdev, 0);\n\tif (irq_num < 0) {\n\t\tret = irq_num;\n\t\tgoto err_unregister_host;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq_num, mtk_dsi_irq,\n\t\t\t       IRQF_TRIGGER_NONE, dev_name(&pdev->dev), dsi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request mediatek dsi irq\\n\");\n\t\tgoto err_unregister_host;\n\t}\n\n\tinit_waitqueue_head(&dsi->irq_wait_queue);\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tdsi->bridge.funcs = &mtk_dsi_bridge_funcs;\n\tdsi->bridge.of_node = dev->of_node;\n\tdsi->bridge.type = DRM_MODE_CONNECTOR_DSI;\n\n\treturn 0;\n\nerr_unregister_host:\n\tmipi_dsi_host_unregister(&dsi->host);\n\treturn ret;\n}\n\nstatic void mtk_dsi_remove(struct platform_device *pdev)\n{\n\tstruct mtk_dsi *dsi = platform_get_drvdata(pdev);\n\n\tmtk_output_dsi_disable(dsi);\n\tmipi_dsi_host_unregister(&dsi->host);\n}\n\nstatic const struct mtk_dsi_driver_data mt8173_dsi_driver_data = {\n\t.reg_cmdq_off = 0x200,\n};\n\nstatic const struct mtk_dsi_driver_data mt2701_dsi_driver_data = {\n\t.reg_cmdq_off = 0x180,\n};\n\nstatic const struct mtk_dsi_driver_data mt8183_dsi_driver_data = {\n\t.reg_cmdq_off = 0x200,\n\t.has_shadow_ctl = true,\n\t.has_size_ctl = true,\n};\n\nstatic const struct mtk_dsi_driver_data mt8186_dsi_driver_data = {\n\t.reg_cmdq_off = 0xd00,\n\t.has_shadow_ctl = true,\n\t.has_size_ctl = true,\n};\n\nstatic const struct of_device_id mtk_dsi_of_match[] = {\n\t{ .compatible = \"mediatek,mt2701-dsi\",\n\t  .data = &mt2701_dsi_driver_data },\n\t{ .compatible = \"mediatek,mt8173-dsi\",\n\t  .data = &mt8173_dsi_driver_data },\n\t{ .compatible = \"mediatek,mt8183-dsi\",\n\t  .data = &mt8183_dsi_driver_data },\n\t{ .compatible = \"mediatek,mt8186-dsi\",\n\t  .data = &mt8186_dsi_driver_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_dsi_of_match);\n\nstruct platform_driver mtk_dsi_driver = {\n\t.probe = mtk_dsi_probe,\n\t.remove_new = mtk_dsi_remove,\n\t.driver = {\n\t\t.name = \"mtk-dsi\",\n\t\t.of_match_table = mtk_dsi_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}