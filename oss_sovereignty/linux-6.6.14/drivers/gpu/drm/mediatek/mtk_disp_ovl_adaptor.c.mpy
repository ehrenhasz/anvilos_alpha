{
  "module_name": "mtk_disp_ovl_adaptor.c",
  "hash_id": "e1dc595bf9dfc5abce71f926e25c89397da3fcb414e1663818fe28ba7c761c7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_of.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n#include <linux/soc/mediatek/mtk-mmsys.h>\n#include <linux/soc/mediatek/mtk-mutex.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_drm_crtc.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_ethdr.h\"\n\n#define MTK_OVL_ADAPTOR_RDMA_MAX_WIDTH 1920\n#define MTK_OVL_ADAPTOR_LAYER_NUM 4\n\nenum mtk_ovl_adaptor_comp_type {\n\tOVL_ADAPTOR_TYPE_RDMA = 0,\n\tOVL_ADAPTOR_TYPE_MERGE,\n\tOVL_ADAPTOR_TYPE_ETHDR,\n\tOVL_ADAPTOR_TYPE_NUM,\n};\n\nenum mtk_ovl_adaptor_comp_id {\n\tOVL_ADAPTOR_MDP_RDMA0,\n\tOVL_ADAPTOR_MDP_RDMA1,\n\tOVL_ADAPTOR_MDP_RDMA2,\n\tOVL_ADAPTOR_MDP_RDMA3,\n\tOVL_ADAPTOR_MDP_RDMA4,\n\tOVL_ADAPTOR_MDP_RDMA5,\n\tOVL_ADAPTOR_MDP_RDMA6,\n\tOVL_ADAPTOR_MDP_RDMA7,\n\tOVL_ADAPTOR_MERGE0,\n\tOVL_ADAPTOR_MERGE1,\n\tOVL_ADAPTOR_MERGE2,\n\tOVL_ADAPTOR_MERGE3,\n\tOVL_ADAPTOR_ETHDR0,\n\tOVL_ADAPTOR_ID_MAX\n};\n\nstruct ovl_adaptor_comp_match {\n\tenum mtk_ovl_adaptor_comp_type type;\n\tint alias_id;\n};\n\nstruct mtk_disp_ovl_adaptor {\n\tstruct device *ovl_adaptor_comp[OVL_ADAPTOR_ID_MAX];\n\tstruct device *mmsys_dev;\n\tbool children_bound;\n};\n\nstatic const char * const private_comp_stem[OVL_ADAPTOR_TYPE_NUM] = {\n\t[OVL_ADAPTOR_TYPE_RDMA]\t\t= \"vdo1-rdma\",\n\t[OVL_ADAPTOR_TYPE_MERGE]\t= \"merge\",\n\t[OVL_ADAPTOR_TYPE_ETHDR]\t= \"ethdr\",\n};\n\nstatic const struct ovl_adaptor_comp_match comp_matches[OVL_ADAPTOR_ID_MAX] = {\n\t[OVL_ADAPTOR_MDP_RDMA0]\t= { OVL_ADAPTOR_TYPE_RDMA, 0 },\n\t[OVL_ADAPTOR_MDP_RDMA1]\t= { OVL_ADAPTOR_TYPE_RDMA, 1 },\n\t[OVL_ADAPTOR_MDP_RDMA2]\t= { OVL_ADAPTOR_TYPE_RDMA, 2 },\n\t[OVL_ADAPTOR_MDP_RDMA3]\t= { OVL_ADAPTOR_TYPE_RDMA, 3 },\n\t[OVL_ADAPTOR_MDP_RDMA4]\t= { OVL_ADAPTOR_TYPE_RDMA, 4 },\n\t[OVL_ADAPTOR_MDP_RDMA5]\t= { OVL_ADAPTOR_TYPE_RDMA, 5 },\n\t[OVL_ADAPTOR_MDP_RDMA6]\t= { OVL_ADAPTOR_TYPE_RDMA, 6 },\n\t[OVL_ADAPTOR_MDP_RDMA7]\t= { OVL_ADAPTOR_TYPE_RDMA, 7 },\n\t[OVL_ADAPTOR_MERGE0]\t= { OVL_ADAPTOR_TYPE_MERGE, 1 },\n\t[OVL_ADAPTOR_MERGE1]\t= { OVL_ADAPTOR_TYPE_MERGE, 2 },\n\t[OVL_ADAPTOR_MERGE2]\t= { OVL_ADAPTOR_TYPE_MERGE, 3 },\n\t[OVL_ADAPTOR_MERGE3]\t= { OVL_ADAPTOR_TYPE_MERGE, 4 },\n\t[OVL_ADAPTOR_ETHDR0]\t= { OVL_ADAPTOR_TYPE_ETHDR, 0 },\n};\n\nvoid mtk_ovl_adaptor_layer_config(struct device *dev, unsigned int idx,\n\t\t\t\t  struct mtk_plane_state *state,\n\t\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\tstruct mtk_plane_pending_state *pending = &state->pending;\n\tstruct mtk_mdp_rdma_cfg rdma_config = {0};\n\tstruct device *rdma_l;\n\tstruct device *rdma_r;\n\tstruct device *merge;\n\tstruct device *ethdr;\n\tconst struct drm_format_info *fmt_info = drm_format_info(pending->format);\n\tbool use_dual_pipe = false;\n\tunsigned int align_width;\n\tunsigned int l_w = 0;\n\tunsigned int r_w = 0;\n\n\tdev_dbg(dev, \"%s+ idx:%d, enable:%d, fmt:0x%x\\n\", __func__, idx,\n\t\tpending->enable, pending->format);\n\tdev_dbg(dev, \"addr 0x%pad, fb w:%d, {%d,%d,%d,%d}\\n\",\n\t\t&pending->addr, (pending->pitch / fmt_info->cpp[0]),\n\t\tpending->x, pending->y, pending->width, pending->height);\n\n\trdma_l = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * idx];\n\trdma_r = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * idx + 1];\n\tmerge = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MERGE0 + idx];\n\tethdr = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0];\n\n\tif (!pending->enable) {\n\t\tmtk_merge_stop_cmdq(merge, cmdq_pkt);\n\t\tmtk_mdp_rdma_stop(rdma_l, cmdq_pkt);\n\t\tmtk_mdp_rdma_stop(rdma_r, cmdq_pkt);\n\t\tmtk_ethdr_layer_config(ethdr, idx, state, cmdq_pkt);\n\t\treturn;\n\t}\n\n\t \n\talign_width = ALIGN_DOWN(pending->width, 2);\n\n\tif (align_width > MTK_OVL_ADAPTOR_RDMA_MAX_WIDTH)\n\t\tuse_dual_pipe = true;\n\n\tif (use_dual_pipe) {\n\t\tl_w = (align_width / 2) + ((pending->width / 2) % 2);\n\t\tr_w = align_width - l_w;\n\t} else {\n\t\tl_w = align_width;\n\t}\n\tmtk_merge_advance_config(merge, l_w, r_w, pending->height, 0, 0, cmdq_pkt);\n\tmtk_mmsys_merge_async_config(ovl_adaptor->mmsys_dev, idx, align_width / 2,\n\t\t\t\t     pending->height, cmdq_pkt);\n\n\trdma_config.width = l_w;\n\trdma_config.height = pending->height;\n\trdma_config.addr0 = pending->addr;\n\trdma_config.pitch = pending->pitch;\n\trdma_config.fmt = pending->format;\n\trdma_config.color_encoding = pending->color_encoding;\n\tmtk_mdp_rdma_config(rdma_l, &rdma_config, cmdq_pkt);\n\n\tif (use_dual_pipe) {\n\t\trdma_config.x_left = l_w;\n\t\trdma_config.width = r_w;\n\t\tmtk_mdp_rdma_config(rdma_r, &rdma_config, cmdq_pkt);\n\t}\n\n\tmtk_merge_start_cmdq(merge, cmdq_pkt);\n\n\tmtk_mdp_rdma_start(rdma_l, cmdq_pkt);\n\tif (use_dual_pipe)\n\t\tmtk_mdp_rdma_start(rdma_r, cmdq_pkt);\n\telse\n\t\tmtk_mdp_rdma_stop(rdma_r, cmdq_pkt);\n\n\tmtk_ethdr_layer_config(ethdr, idx, state, cmdq_pkt);\n}\n\nvoid mtk_ovl_adaptor_config(struct device *dev, unsigned int w,\n\t\t\t    unsigned int h, unsigned int vrefresh,\n\t\t\t    unsigned int bpc, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_config(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0], w, h,\n\t\t\t vrefresh, bpc, cmdq_pkt);\n}\n\nvoid mtk_ovl_adaptor_start(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_start(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);\n}\n\nvoid mtk_ovl_adaptor_stop(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_stop(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);\n}\n\nint mtk_ovl_adaptor_clk_enable(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\tstruct device *comp;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < OVL_ADAPTOR_MERGE0; i++) {\n\t\tcomp = ovl_adaptor->ovl_adaptor_comp[i];\n\t\tret = pm_runtime_get_sync(comp);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to enable power domain %d, err %d\\n\", i, ret);\n\t\t\tgoto pwr_err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {\n\t\tcomp = ovl_adaptor->ovl_adaptor_comp[i];\n\n\t\tif (i < OVL_ADAPTOR_MERGE0)\n\t\t\tret = mtk_mdp_rdma_clk_enable(comp);\n\t\telse if (i < OVL_ADAPTOR_ETHDR0)\n\t\t\tret = mtk_merge_clk_enable(comp);\n\t\telse\n\t\t\tret = mtk_ethdr_clk_enable(comp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable clock %d, err %d\\n\", i, ret);\n\t\t\tgoto clk_err;\n\t\t}\n\t}\n\n\treturn ret;\n\nclk_err:\n\twhile (--i >= 0) {\n\t\tcomp = ovl_adaptor->ovl_adaptor_comp[i];\n\t\tif (i < OVL_ADAPTOR_MERGE0)\n\t\t\tmtk_mdp_rdma_clk_disable(comp);\n\t\telse if (i < OVL_ADAPTOR_ETHDR0)\n\t\t\tmtk_merge_clk_disable(comp);\n\t\telse\n\t\t\tmtk_ethdr_clk_disable(comp);\n\t}\n\ti = OVL_ADAPTOR_MERGE0;\n\npwr_err:\n\twhile (--i >= 0)\n\t\tpm_runtime_put(ovl_adaptor->ovl_adaptor_comp[i]);\n\n\treturn ret;\n}\n\nvoid mtk_ovl_adaptor_clk_disable(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\tstruct device *comp;\n\tint i;\n\n\tfor (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {\n\t\tcomp = ovl_adaptor->ovl_adaptor_comp[i];\n\n\t\tif (i < OVL_ADAPTOR_MERGE0) {\n\t\t\tmtk_mdp_rdma_clk_disable(comp);\n\t\t\tpm_runtime_put(comp);\n\t\t} else if (i < OVL_ADAPTOR_ETHDR0) {\n\t\t\tmtk_merge_clk_disable(comp);\n\t\t} else {\n\t\t\tmtk_ethdr_clk_disable(comp);\n\t\t}\n\t}\n}\n\nunsigned int mtk_ovl_adaptor_layer_nr(struct device *dev)\n{\n\treturn MTK_OVL_ADAPTOR_LAYER_NUM;\n}\n\nstruct device *mtk_ovl_adaptor_dma_dev_get(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\treturn ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0];\n}\n\nvoid mtk_ovl_adaptor_register_vblank_cb(struct device *dev, void (*vblank_cb)(void *),\n\t\t\t\t\tvoid *vblank_cb_data)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_register_vblank_cb(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0],\n\t\t\t\t     vblank_cb, vblank_cb_data);\n}\n\nvoid mtk_ovl_adaptor_unregister_vblank_cb(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_unregister_vblank_cb(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);\n}\n\nvoid mtk_ovl_adaptor_enable_vblank(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_enable_vblank(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);\n}\n\nvoid mtk_ovl_adaptor_disable_vblank(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\tmtk_ethdr_disable_vblank(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);\n}\n\nconst u32 *mtk_ovl_adaptor_get_formats(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\treturn mtk_mdp_rdma_get_formats(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0]);\n}\n\nsize_t mtk_ovl_adaptor_get_num_formats(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);\n\n\treturn mtk_mdp_rdma_get_num_formats(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0]);\n}\n\nvoid mtk_ovl_adaptor_add_comp(struct device *dev, struct mtk_mutex *mutex)\n{\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA0);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA1);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA2);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA3);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA4);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA5);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA6);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA7);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE1);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE2);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE3);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE4);\n\tmtk_mutex_add_comp(mutex, DDP_COMPONENT_ETHDR_MIXER);\n}\n\nvoid mtk_ovl_adaptor_remove_comp(struct device *dev, struct mtk_mutex *mutex)\n{\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA0);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA1);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA2);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA3);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA4);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA5);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA6);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA7);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE1);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE2);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE3);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE4);\n\tmtk_mutex_remove_comp(mutex, DDP_COMPONENT_ETHDR_MIXER);\n}\n\nvoid mtk_ovl_adaptor_connect(struct device *dev, struct device *mmsys_dev, unsigned int next)\n{\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA0, DDP_COMPONENT_MERGE1);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA1, DDP_COMPONENT_MERGE1);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA2, DDP_COMPONENT_MERGE2);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE1, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);\n}\n\nvoid mtk_ovl_adaptor_disconnect(struct device *dev, struct device *mmsys_dev, unsigned int next)\n{\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA0, DDP_COMPONENT_MERGE1);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA1, DDP_COMPONENT_MERGE1);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA2, DDP_COMPONENT_MERGE2);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE1, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER);\n\tmtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);\n}\n\nstatic int ovl_adaptor_comp_get_id(struct device *dev, struct device_node *node,\n\t\t\t\t   enum mtk_ovl_adaptor_comp_type type)\n{\n\tint alias_id = of_alias_get_id(node, private_comp_stem[type]);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(comp_matches); i++)\n\t\tif (comp_matches[i].type == type &&\n\t\t    comp_matches[i].alias_id == alias_id)\n\t\t\treturn i;\n\n\tdev_warn(dev, \"Failed to get id. type: %d, alias: %d\\n\", type, alias_id);\n\treturn -EINVAL;\n}\n\nstatic const struct of_device_id mtk_ovl_adaptor_comp_dt_ids[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8195-vdo1-rdma\",\n\t\t.data = (void *)OVL_ADAPTOR_TYPE_RDMA,\n\t}, {\n\t\t.compatible = \"mediatek,mt8195-disp-merge\",\n\t\t.data = (void *)OVL_ADAPTOR_TYPE_MERGE,\n\t}, {\n\t\t.compatible = \"mediatek,mt8195-disp-ethdr\",\n\t\t.data = (void *)OVL_ADAPTOR_TYPE_ETHDR,\n\t},\n\t{},\n};\n\nstatic int compare_of(struct device *dev, void *data)\n{\n\treturn dev->of_node == data;\n}\n\nstatic int ovl_adaptor_comp_init(struct device *dev, struct component_match **match)\n{\n\tstruct mtk_disp_ovl_adaptor *priv = dev_get_drvdata(dev);\n\tstruct device_node *node, *parent;\n\tstruct platform_device *comp_pdev;\n\n\tparent = dev->parent->parent->of_node->parent;\n\n\tfor_each_child_of_node(parent, node) {\n\t\tconst struct of_device_id *of_id;\n\t\tenum mtk_ovl_adaptor_comp_type type;\n\t\tint id;\n\n\t\tof_id = of_match_node(mtk_ovl_adaptor_comp_dt_ids, node);\n\t\tif (!of_id)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(node)) {\n\t\t\tdev_dbg(dev, \"Skipping disabled component %pOF\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype = (enum mtk_ovl_adaptor_comp_type)(uintptr_t)of_id->data;\n\t\tid = ovl_adaptor_comp_get_id(dev, node, type);\n\t\tif (id < 0) {\n\t\t\tdev_warn(dev, \"Skipping unknown component %pOF\\n\",\n\t\t\t\t node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomp_pdev = of_find_device_by_node(node);\n\t\tif (!comp_pdev)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tpriv->ovl_adaptor_comp[id] = &comp_pdev->dev;\n\n\t\tdrm_of_component_match_add(dev, match, compare_of, node);\n\t\tdev_dbg(dev, \"Adding component match for %pOF\\n\", node);\n\t}\n\n\tif (!*match) {\n\t\tdev_err(dev, \"No match device for ovl_adaptor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_disp_ovl_adaptor_comp_bind(struct device *dev, struct device *master,\n\t\t\t\t\t  void *data)\n{\n\tstruct mtk_disp_ovl_adaptor *priv = dev_get_drvdata(dev);\n\n\tif (!priv->children_bound)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\n\nstatic void mtk_disp_ovl_adaptor_comp_unbind(struct device *dev, struct device *master,\n\t\t\t\t\t     void *data)\n{\n}\n\nstatic const struct component_ops mtk_disp_ovl_adaptor_comp_ops = {\n\t.bind\t= mtk_disp_ovl_adaptor_comp_bind,\n\t.unbind = mtk_disp_ovl_adaptor_comp_unbind,\n};\n\nstatic int mtk_disp_ovl_adaptor_master_bind(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = component_bind_all(dev, priv->mmsys_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"component_bind_all failed!\\n\");\n\n\tpriv->children_bound = true;\n\treturn 0;\n}\n\nstatic void mtk_disp_ovl_adaptor_master_unbind(struct device *dev)\n{\n\tstruct mtk_disp_ovl_adaptor *priv = dev_get_drvdata(dev);\n\n\tpriv->children_bound = false;\n}\n\nstatic const struct component_master_ops mtk_disp_ovl_adaptor_master_ops = {\n\t.bind\t\t= mtk_disp_ovl_adaptor_master_bind,\n\t.unbind\t\t= mtk_disp_ovl_adaptor_master_unbind,\n};\n\nstatic int mtk_disp_ovl_adaptor_probe(struct platform_device *pdev)\n{\n\tstruct mtk_disp_ovl_adaptor *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct component_match *match = NULL;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = ovl_adaptor_comp_init(dev, &match);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->mmsys_dev = pdev->dev.platform_data;\n\n\tcomponent_master_add_with_match(dev, &mtk_disp_ovl_adaptor_master_ops, match);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &mtk_disp_ovl_adaptor_comp_ops);\n\tif (ret != 0) {\n\t\tpm_runtime_disable(dev);\n\t\tdev_err(dev, \"Failed to add component: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_disp_ovl_adaptor_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &mtk_disp_ovl_adaptor_master_ops);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstruct platform_driver mtk_disp_ovl_adaptor_driver = {\n\t.probe\t\t= mtk_disp_ovl_adaptor_probe,\n\t.remove\t\t= mtk_disp_ovl_adaptor_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mediatek-disp-ovl-adaptor\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}