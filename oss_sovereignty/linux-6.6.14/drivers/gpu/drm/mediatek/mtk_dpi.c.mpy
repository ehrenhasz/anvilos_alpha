{
  "module_name": "mtk_dpi.c",
  "hash_id": "012cdceca92656db741daa7dca9e2f77e8bf61d4d9882ecc74740d13fdb9dbdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_dpi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/soc/mediatek/mtk-mmsys.h>\n#include <linux/types.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_dpi_regs.h\"\n#include \"mtk_drm_ddp_comp.h\"\n#include \"mtk_drm_drv.h\"\n\nenum mtk_dpi_out_bit_num {\n\tMTK_DPI_OUT_BIT_NUM_8BITS,\n\tMTK_DPI_OUT_BIT_NUM_10BITS,\n\tMTK_DPI_OUT_BIT_NUM_12BITS,\n\tMTK_DPI_OUT_BIT_NUM_16BITS\n};\n\nenum mtk_dpi_out_yc_map {\n\tMTK_DPI_OUT_YC_MAP_RGB,\n\tMTK_DPI_OUT_YC_MAP_CYCY,\n\tMTK_DPI_OUT_YC_MAP_YCYC,\n\tMTK_DPI_OUT_YC_MAP_CY,\n\tMTK_DPI_OUT_YC_MAP_YC\n};\n\nenum mtk_dpi_out_channel_swap {\n\tMTK_DPI_OUT_CHANNEL_SWAP_RGB,\n\tMTK_DPI_OUT_CHANNEL_SWAP_GBR,\n\tMTK_DPI_OUT_CHANNEL_SWAP_BRG,\n\tMTK_DPI_OUT_CHANNEL_SWAP_RBG,\n\tMTK_DPI_OUT_CHANNEL_SWAP_GRB,\n\tMTK_DPI_OUT_CHANNEL_SWAP_BGR\n};\n\nenum mtk_dpi_out_color_format {\n\tMTK_DPI_COLOR_FORMAT_RGB,\n\tMTK_DPI_COLOR_FORMAT_YCBCR_422\n};\n\nstruct mtk_dpi {\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *connector;\n\tvoid __iomem *regs;\n\tstruct device *dev;\n\tstruct device *mmsys_dev;\n\tstruct clk *engine_clk;\n\tstruct clk *pixel_clk;\n\tstruct clk *tvd_clk;\n\tint irq;\n\tstruct drm_display_mode mode;\n\tconst struct mtk_dpi_conf *conf;\n\tenum mtk_dpi_out_color_format color_format;\n\tenum mtk_dpi_out_yc_map yc_map;\n\tenum mtk_dpi_out_bit_num bit_num;\n\tenum mtk_dpi_out_channel_swap channel_swap;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_gpio;\n\tstruct pinctrl_state *pins_dpi;\n\tu32 output_fmt;\n\tint refcount;\n};\n\nstatic inline struct mtk_dpi *bridge_to_dpi(struct drm_bridge *b)\n{\n\treturn container_of(b, struct mtk_dpi, bridge);\n}\n\nenum mtk_dpi_polarity {\n\tMTK_DPI_POLARITY_RISING,\n\tMTK_DPI_POLARITY_FALLING,\n};\n\nstruct mtk_dpi_polarities {\n\tenum mtk_dpi_polarity de_pol;\n\tenum mtk_dpi_polarity ck_pol;\n\tenum mtk_dpi_polarity hsync_pol;\n\tenum mtk_dpi_polarity vsync_pol;\n};\n\nstruct mtk_dpi_sync_param {\n\tu32 sync_width;\n\tu32 front_porch;\n\tu32 back_porch;\n\tbool shift_half_line;\n};\n\nstruct mtk_dpi_yc_limit {\n\tu16 y_top;\n\tu16 y_bottom;\n\tu16 c_top;\n\tu16 c_bottom;\n};\n\n \nstruct mtk_dpi_conf {\n\tunsigned int (*cal_factor)(int clock);\n\tu32 reg_h_fre_con;\n\tu32 max_clock_khz;\n\tbool edge_sel_en;\n\tconst u32 *output_fmts;\n\tu32 num_output_fmts;\n\tbool is_ck_de_pol;\n\tbool swap_input_support;\n\tbool support_direct_pin;\n\tbool input_2pixel;\n\tu32 dimension_mask;\n\tu32 hvsize_mask;\n\tu32 channel_swap_shift;\n\tu32 yuv422_en_bit;\n\tu32 csc_enable_bit;\n\tu32 pixels_per_iter;\n\tbool edge_cfg_in_mmsys;\n};\n\nstatic void mtk_dpi_mask(struct mtk_dpi *dpi, u32 offset, u32 val, u32 mask)\n{\n\tu32 tmp = readl(dpi->regs + offset) & ~mask;\n\n\ttmp |= (val & mask);\n\twritel(tmp, dpi->regs + offset);\n}\n\nstatic void mtk_dpi_sw_reset(struct mtk_dpi *dpi, bool reset)\n{\n\tmtk_dpi_mask(dpi, DPI_RET, reset ? RST : 0, RST);\n}\n\nstatic void mtk_dpi_enable(struct mtk_dpi *dpi)\n{\n\tmtk_dpi_mask(dpi, DPI_EN, EN, EN);\n}\n\nstatic void mtk_dpi_disable(struct mtk_dpi *dpi)\n{\n\tmtk_dpi_mask(dpi, DPI_EN, 0, EN);\n}\n\nstatic void mtk_dpi_config_hsync(struct mtk_dpi *dpi,\n\t\t\t\t struct mtk_dpi_sync_param *sync)\n{\n\tmtk_dpi_mask(dpi, DPI_TGEN_HWIDTH, sync->sync_width << HPW,\n\t\t     dpi->conf->dimension_mask << HPW);\n\tmtk_dpi_mask(dpi, DPI_TGEN_HPORCH, sync->back_porch << HBP,\n\t\t     dpi->conf->dimension_mask << HBP);\n\tmtk_dpi_mask(dpi, DPI_TGEN_HPORCH, sync->front_porch << HFP,\n\t\t     dpi->conf->dimension_mask << HFP);\n}\n\nstatic void mtk_dpi_config_vsync(struct mtk_dpi *dpi,\n\t\t\t\t struct mtk_dpi_sync_param *sync,\n\t\t\t\t u32 width_addr, u32 porch_addr)\n{\n\tmtk_dpi_mask(dpi, width_addr,\n\t\t     sync->shift_half_line << VSYNC_HALF_LINE_SHIFT,\n\t\t     VSYNC_HALF_LINE_MASK);\n\tmtk_dpi_mask(dpi, width_addr,\n\t\t     sync->sync_width << VSYNC_WIDTH_SHIFT,\n\t\t     dpi->conf->dimension_mask << VSYNC_WIDTH_SHIFT);\n\tmtk_dpi_mask(dpi, porch_addr,\n\t\t     sync->back_porch << VSYNC_BACK_PORCH_SHIFT,\n\t\t     dpi->conf->dimension_mask << VSYNC_BACK_PORCH_SHIFT);\n\tmtk_dpi_mask(dpi, porch_addr,\n\t\t     sync->front_porch << VSYNC_FRONT_PORCH_SHIFT,\n\t\t     dpi->conf->dimension_mask << VSYNC_FRONT_PORCH_SHIFT);\n}\n\nstatic void mtk_dpi_config_vsync_lodd(struct mtk_dpi *dpi,\n\t\t\t\t      struct mtk_dpi_sync_param *sync)\n{\n\tmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH, DPI_TGEN_VPORCH);\n}\n\nstatic void mtk_dpi_config_vsync_leven(struct mtk_dpi *dpi,\n\t\t\t\t       struct mtk_dpi_sync_param *sync)\n{\n\tmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_LEVEN,\n\t\t\t     DPI_TGEN_VPORCH_LEVEN);\n}\n\nstatic void mtk_dpi_config_vsync_rodd(struct mtk_dpi *dpi,\n\t\t\t\t      struct mtk_dpi_sync_param *sync)\n{\n\tmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_RODD,\n\t\t\t     DPI_TGEN_VPORCH_RODD);\n}\n\nstatic void mtk_dpi_config_vsync_reven(struct mtk_dpi *dpi,\n\t\t\t\t       struct mtk_dpi_sync_param *sync)\n{\n\tmtk_dpi_config_vsync(dpi, sync, DPI_TGEN_VWIDTH_REVEN,\n\t\t\t     DPI_TGEN_VPORCH_REVEN);\n}\n\nstatic void mtk_dpi_config_pol(struct mtk_dpi *dpi,\n\t\t\t       struct mtk_dpi_polarities *dpi_pol)\n{\n\tunsigned int pol;\n\tunsigned int mask;\n\n\tmask = HSYNC_POL | VSYNC_POL;\n\tpol = (dpi_pol->hsync_pol == MTK_DPI_POLARITY_RISING ? 0 : HSYNC_POL) |\n\t      (dpi_pol->vsync_pol == MTK_DPI_POLARITY_RISING ? 0 : VSYNC_POL);\n\tif (dpi->conf->is_ck_de_pol) {\n\t\tmask |= CK_POL | DE_POL;\n\t\tpol |= (dpi_pol->ck_pol == MTK_DPI_POLARITY_RISING ?\n\t\t\t0 : CK_POL) |\n\t\t       (dpi_pol->de_pol == MTK_DPI_POLARITY_RISING ?\n\t\t\t0 : DE_POL);\n\t}\n\n\tmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, pol, mask);\n}\n\nstatic void mtk_dpi_config_3d(struct mtk_dpi *dpi, bool en_3d)\n{\n\tmtk_dpi_mask(dpi, DPI_CON, en_3d ? TDFP_EN : 0, TDFP_EN);\n}\n\nstatic void mtk_dpi_config_interface(struct mtk_dpi *dpi, bool inter)\n{\n\tmtk_dpi_mask(dpi, DPI_CON, inter ? INTL_EN : 0, INTL_EN);\n}\n\nstatic void mtk_dpi_config_fb_size(struct mtk_dpi *dpi, u32 width, u32 height)\n{\n\tmtk_dpi_mask(dpi, DPI_SIZE, width << HSIZE,\n\t\t     dpi->conf->hvsize_mask << HSIZE);\n\tmtk_dpi_mask(dpi, DPI_SIZE, height << VSIZE,\n\t\t     dpi->conf->hvsize_mask << VSIZE);\n}\n\nstatic void mtk_dpi_config_channel_limit(struct mtk_dpi *dpi)\n{\n\tstruct mtk_dpi_yc_limit limit;\n\n\tif (drm_default_rgb_quant_range(&dpi->mode) ==\n\t    HDMI_QUANTIZATION_RANGE_LIMITED) {\n\t\tlimit.y_bottom = 0x10;\n\t\tlimit.y_top = 0xfe0;\n\t\tlimit.c_bottom = 0x10;\n\t\tlimit.c_top = 0xfe0;\n\t} else {\n\t\tlimit.y_bottom = 0;\n\t\tlimit.y_top = 0xfff;\n\t\tlimit.c_bottom = 0;\n\t\tlimit.c_top = 0xfff;\n\t}\n\n\tmtk_dpi_mask(dpi, DPI_Y_LIMIT, limit.y_bottom << Y_LIMINT_BOT,\n\t\t     Y_LIMINT_BOT_MASK);\n\tmtk_dpi_mask(dpi, DPI_Y_LIMIT, limit.y_top << Y_LIMINT_TOP,\n\t\t     Y_LIMINT_TOP_MASK);\n\tmtk_dpi_mask(dpi, DPI_C_LIMIT, limit.c_bottom << C_LIMIT_BOT,\n\t\t     C_LIMIT_BOT_MASK);\n\tmtk_dpi_mask(dpi, DPI_C_LIMIT, limit.c_top << C_LIMIT_TOP,\n\t\t     C_LIMIT_TOP_MASK);\n}\n\nstatic void mtk_dpi_config_bit_num(struct mtk_dpi *dpi,\n\t\t\t\t   enum mtk_dpi_out_bit_num num)\n{\n\tu32 val;\n\n\tswitch (num) {\n\tcase MTK_DPI_OUT_BIT_NUM_8BITS:\n\t\tval = OUT_BIT_8;\n\t\tbreak;\n\tcase MTK_DPI_OUT_BIT_NUM_10BITS:\n\t\tval = OUT_BIT_10;\n\t\tbreak;\n\tcase MTK_DPI_OUT_BIT_NUM_12BITS:\n\t\tval = OUT_BIT_12;\n\t\tbreak;\n\tcase MTK_DPI_OUT_BIT_NUM_16BITS:\n\t\tval = OUT_BIT_16;\n\t\tbreak;\n\tdefault:\n\t\tval = OUT_BIT_8;\n\t\tbreak;\n\t}\n\tmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, val << OUT_BIT,\n\t\t     OUT_BIT_MASK);\n}\n\nstatic void mtk_dpi_config_yc_map(struct mtk_dpi *dpi,\n\t\t\t\t  enum mtk_dpi_out_yc_map map)\n{\n\tu32 val;\n\n\tswitch (map) {\n\tcase MTK_DPI_OUT_YC_MAP_RGB:\n\t\tval = YC_MAP_RGB;\n\t\tbreak;\n\tcase MTK_DPI_OUT_YC_MAP_CYCY:\n\t\tval = YC_MAP_CYCY;\n\t\tbreak;\n\tcase MTK_DPI_OUT_YC_MAP_YCYC:\n\t\tval = YC_MAP_YCYC;\n\t\tbreak;\n\tcase MTK_DPI_OUT_YC_MAP_CY:\n\t\tval = YC_MAP_CY;\n\t\tbreak;\n\tcase MTK_DPI_OUT_YC_MAP_YC:\n\t\tval = YC_MAP_YC;\n\t\tbreak;\n\tdefault:\n\t\tval = YC_MAP_RGB;\n\t\tbreak;\n\t}\n\n\tmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING, val << YC_MAP, YC_MAP_MASK);\n}\n\nstatic void mtk_dpi_config_channel_swap(struct mtk_dpi *dpi,\n\t\t\t\t\tenum mtk_dpi_out_channel_swap swap)\n{\n\tu32 val;\n\n\tswitch (swap) {\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_RGB:\n\t\tval = SWAP_RGB;\n\t\tbreak;\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_GBR:\n\t\tval = SWAP_GBR;\n\t\tbreak;\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_BRG:\n\t\tval = SWAP_BRG;\n\t\tbreak;\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_RBG:\n\t\tval = SWAP_RBG;\n\t\tbreak;\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_GRB:\n\t\tval = SWAP_GRB;\n\t\tbreak;\n\tcase MTK_DPI_OUT_CHANNEL_SWAP_BGR:\n\t\tval = SWAP_BGR;\n\t\tbreak;\n\tdefault:\n\t\tval = SWAP_RGB;\n\t\tbreak;\n\t}\n\n\tmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING,\n\t\t     val << dpi->conf->channel_swap_shift,\n\t\t     CH_SWAP_MASK << dpi->conf->channel_swap_shift);\n}\n\nstatic void mtk_dpi_config_yuv422_enable(struct mtk_dpi *dpi, bool enable)\n{\n\tmtk_dpi_mask(dpi, DPI_CON, enable ? dpi->conf->yuv422_en_bit : 0,\n\t\t     dpi->conf->yuv422_en_bit);\n}\n\nstatic void mtk_dpi_config_csc_enable(struct mtk_dpi *dpi, bool enable)\n{\n\tmtk_dpi_mask(dpi, DPI_CON, enable ? dpi->conf->csc_enable_bit : 0,\n\t\t     dpi->conf->csc_enable_bit);\n}\n\nstatic void mtk_dpi_config_swap_input(struct mtk_dpi *dpi, bool enable)\n{\n\tmtk_dpi_mask(dpi, DPI_CON, enable ? IN_RB_SWAP : 0, IN_RB_SWAP);\n}\n\nstatic void mtk_dpi_config_2n_h_fre(struct mtk_dpi *dpi)\n{\n\tmtk_dpi_mask(dpi, dpi->conf->reg_h_fre_con, H_FRE_2N, H_FRE_2N);\n}\n\nstatic void mtk_dpi_config_disable_edge(struct mtk_dpi *dpi)\n{\n\tif (dpi->conf->edge_sel_en)\n\t\tmtk_dpi_mask(dpi, dpi->conf->reg_h_fre_con, 0, EDGE_SEL_EN);\n}\n\nstatic void mtk_dpi_config_color_format(struct mtk_dpi *dpi,\n\t\t\t\t\tenum mtk_dpi_out_color_format format)\n{\n\tmtk_dpi_config_channel_swap(dpi, MTK_DPI_OUT_CHANNEL_SWAP_RGB);\n\n\tif (format == MTK_DPI_COLOR_FORMAT_YCBCR_422) {\n\t\tmtk_dpi_config_yuv422_enable(dpi, true);\n\t\tmtk_dpi_config_csc_enable(dpi, true);\n\n\t\t \n\t\tmtk_dpi_mask(dpi, DPI_MATRIX_SET, dpi->mode.hdisplay <= 720 ?\n\t\t\t     MATRIX_SEL_RGB_TO_BT601 : MATRIX_SEL_RGB_TO_JPEG,\n\t\t\t     INT_MATRIX_SEL_MASK);\n\t} else {\n\t\tmtk_dpi_config_yuv422_enable(dpi, false);\n\t\tmtk_dpi_config_csc_enable(dpi, false);\n\t\tif (dpi->conf->swap_input_support)\n\t\t\tmtk_dpi_config_swap_input(dpi, false);\n\t}\n}\n\nstatic void mtk_dpi_dual_edge(struct mtk_dpi *dpi)\n{\n\tif ((dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE) ||\n\t    (dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_BE)) {\n\t\tmtk_dpi_mask(dpi, DPI_DDR_SETTING, DDR_EN | DDR_4PHASE,\n\t\t\t     DDR_EN | DDR_4PHASE);\n\t\tmtk_dpi_mask(dpi, DPI_OUTPUT_SETTING,\n\t\t\t     dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE ?\n\t\t\t     EDGE_SEL : 0, EDGE_SEL);\n\t\tif (dpi->conf->edge_cfg_in_mmsys)\n\t\t\tmtk_mmsys_ddp_dpi_fmt_config(dpi->mmsys_dev, MTK_DPI_RGB888_DDR_CON);\n\t} else {\n\t\tmtk_dpi_mask(dpi, DPI_DDR_SETTING, DDR_EN | DDR_4PHASE, 0);\n\t\tif (dpi->conf->edge_cfg_in_mmsys)\n\t\t\tmtk_mmsys_ddp_dpi_fmt_config(dpi->mmsys_dev, MTK_DPI_RGB888_SDR_CON);\n\t}\n}\n\nstatic void mtk_dpi_power_off(struct mtk_dpi *dpi)\n{\n\tif (WARN_ON(dpi->refcount == 0))\n\t\treturn;\n\n\tif (--dpi->refcount != 0)\n\t\treturn;\n\n\tmtk_dpi_disable(dpi);\n\tclk_disable_unprepare(dpi->pixel_clk);\n\tclk_disable_unprepare(dpi->engine_clk);\n}\n\nstatic int mtk_dpi_power_on(struct mtk_dpi *dpi)\n{\n\tint ret;\n\n\tif (++dpi->refcount != 1)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(dpi->engine_clk);\n\tif (ret) {\n\t\tdev_err(dpi->dev, \"Failed to enable engine clock: %d\\n\", ret);\n\t\tgoto err_refcount;\n\t}\n\n\tret = clk_prepare_enable(dpi->pixel_clk);\n\tif (ret) {\n\t\tdev_err(dpi->dev, \"Failed to enable pixel clock: %d\\n\", ret);\n\t\tgoto err_pixel;\n\t}\n\n\treturn 0;\n\nerr_pixel:\n\tclk_disable_unprepare(dpi->engine_clk);\nerr_refcount:\n\tdpi->refcount--;\n\treturn ret;\n}\n\nstatic int mtk_dpi_set_display_mode(struct mtk_dpi *dpi,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct mtk_dpi_polarities dpi_pol;\n\tstruct mtk_dpi_sync_param hsync;\n\tstruct mtk_dpi_sync_param vsync_lodd = { 0 };\n\tstruct mtk_dpi_sync_param vsync_leven = { 0 };\n\tstruct mtk_dpi_sync_param vsync_rodd = { 0 };\n\tstruct mtk_dpi_sync_param vsync_reven = { 0 };\n\tstruct videomode vm = { 0 };\n\tunsigned long pll_rate;\n\tunsigned int factor;\n\n\t \n\tfactor = dpi->conf->cal_factor(mode->clock);\n\tdrm_display_mode_to_videomode(mode, &vm);\n\tpll_rate = vm.pixelclock * factor;\n\n\tdev_dbg(dpi->dev, \"Want PLL %lu Hz, pixel clock %lu Hz\\n\",\n\t\tpll_rate, vm.pixelclock);\n\n\tclk_set_rate(dpi->tvd_clk, pll_rate);\n\tpll_rate = clk_get_rate(dpi->tvd_clk);\n\n\t \n\tvm.pixelclock = pll_rate / factor;\n\tvm.pixelclock /= dpi->conf->pixels_per_iter;\n\n\tif ((dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE) ||\n\t    (dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_BE))\n\t\tclk_set_rate(dpi->pixel_clk, vm.pixelclock * 2);\n\telse\n\t\tclk_set_rate(dpi->pixel_clk, vm.pixelclock);\n\n\n\tvm.pixelclock = clk_get_rate(dpi->pixel_clk);\n\n\tdev_dbg(dpi->dev, \"Got  PLL %lu Hz, pixel clock %lu Hz\\n\",\n\t\tpll_rate, vm.pixelclock);\n\n\tdpi_pol.ck_pol = MTK_DPI_POLARITY_FALLING;\n\tdpi_pol.de_pol = MTK_DPI_POLARITY_RISING;\n\tdpi_pol.hsync_pol = vm.flags & DISPLAY_FLAGS_HSYNC_HIGH ?\n\t\t\t    MTK_DPI_POLARITY_FALLING : MTK_DPI_POLARITY_RISING;\n\tdpi_pol.vsync_pol = vm.flags & DISPLAY_FLAGS_VSYNC_HIGH ?\n\t\t\t    MTK_DPI_POLARITY_FALLING : MTK_DPI_POLARITY_RISING;\n\n\t \n\thsync.sync_width = vm.hsync_len / dpi->conf->pixels_per_iter;\n\thsync.back_porch = vm.hback_porch / dpi->conf->pixels_per_iter;\n\thsync.front_porch = vm.hfront_porch / dpi->conf->pixels_per_iter;\n\n\thsync.shift_half_line = false;\n\tvsync_lodd.sync_width = vm.vsync_len;\n\tvsync_lodd.back_porch = vm.vback_porch;\n\tvsync_lodd.front_porch = vm.vfront_porch;\n\tvsync_lodd.shift_half_line = false;\n\n\tif (vm.flags & DISPLAY_FLAGS_INTERLACED &&\n\t    mode->flags & DRM_MODE_FLAG_3D_MASK) {\n\t\tvsync_leven = vsync_lodd;\n\t\tvsync_rodd = vsync_lodd;\n\t\tvsync_reven = vsync_lodd;\n\t\tvsync_leven.shift_half_line = true;\n\t\tvsync_reven.shift_half_line = true;\n\t} else if (vm.flags & DISPLAY_FLAGS_INTERLACED &&\n\t\t   !(mode->flags & DRM_MODE_FLAG_3D_MASK)) {\n\t\tvsync_leven = vsync_lodd;\n\t\tvsync_leven.shift_half_line = true;\n\t} else if (!(vm.flags & DISPLAY_FLAGS_INTERLACED) &&\n\t\t   mode->flags & DRM_MODE_FLAG_3D_MASK) {\n\t\tvsync_rodd = vsync_lodd;\n\t}\n\tmtk_dpi_sw_reset(dpi, true);\n\tmtk_dpi_config_pol(dpi, &dpi_pol);\n\n\tmtk_dpi_config_hsync(dpi, &hsync);\n\tmtk_dpi_config_vsync_lodd(dpi, &vsync_lodd);\n\tmtk_dpi_config_vsync_rodd(dpi, &vsync_rodd);\n\tmtk_dpi_config_vsync_leven(dpi, &vsync_leven);\n\tmtk_dpi_config_vsync_reven(dpi, &vsync_reven);\n\n\tmtk_dpi_config_3d(dpi, !!(mode->flags & DRM_MODE_FLAG_3D_MASK));\n\tmtk_dpi_config_interface(dpi, !!(vm.flags &\n\t\t\t\t\t DISPLAY_FLAGS_INTERLACED));\n\tif (vm.flags & DISPLAY_FLAGS_INTERLACED)\n\t\tmtk_dpi_config_fb_size(dpi, vm.hactive, vm.vactive >> 1);\n\telse\n\t\tmtk_dpi_config_fb_size(dpi, vm.hactive, vm.vactive);\n\n\tmtk_dpi_config_channel_limit(dpi);\n\tmtk_dpi_config_bit_num(dpi, dpi->bit_num);\n\tmtk_dpi_config_channel_swap(dpi, dpi->channel_swap);\n\tmtk_dpi_config_color_format(dpi, dpi->color_format);\n\tif (dpi->conf->support_direct_pin) {\n\t\tmtk_dpi_config_yc_map(dpi, dpi->yc_map);\n\t\tmtk_dpi_config_2n_h_fre(dpi);\n\t\tmtk_dpi_dual_edge(dpi);\n\t\tmtk_dpi_config_disable_edge(dpi);\n\t}\n\tif (dpi->conf->input_2pixel) {\n\t\tmtk_dpi_mask(dpi, DPI_CON, DPINTF_INPUT_2P_EN,\n\t\t\t     DPINTF_INPUT_2P_EN);\n\t}\n\tmtk_dpi_sw_reset(dpi, false);\n\n\treturn 0;\n}\n\nstatic u32 *mtk_dpi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t      struct drm_connector_state *conn_state,\n\t\t\t\t\t\t      unsigned int *num_output_fmts)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\tu32 *output_fmts;\n\n\t*num_output_fmts = 0;\n\n\tif (!dpi->conf->output_fmts) {\n\t\tdev_err(dpi->dev, \"output_fmts should not be null\\n\");\n\t\treturn NULL;\n\t}\n\n\toutput_fmts = kcalloc(dpi->conf->num_output_fmts, sizeof(*output_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!output_fmts)\n\t\treturn NULL;\n\n\t*num_output_fmts = dpi->conf->num_output_fmts;\n\n\tmemcpy(output_fmts, dpi->conf->output_fmts,\n\t       sizeof(*output_fmts) * dpi->conf->num_output_fmts);\n\n\treturn output_fmts;\n}\n\nstatic u32 *mtk_dpi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t\t     u32 output_fmt,\n\t\t\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(1, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\n\treturn input_fmts;\n}\n\nstatic int mtk_dpi_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\tunsigned int out_bus_format;\n\n\tout_bus_format = bridge_state->output_bus_cfg.format;\n\n\tif (out_bus_format == MEDIA_BUS_FMT_FIXED)\n\t\tif (dpi->conf->num_output_fmts)\n\t\t\tout_bus_format = dpi->conf->output_fmts[0];\n\n\tdev_dbg(dpi->dev, \"input format 0x%04x, output format 0x%04x\\n\",\n\t\tbridge_state->input_bus_cfg.format,\n\t\tbridge_state->output_bus_cfg.format);\n\n\tdpi->output_fmt = out_bus_format;\n\tdpi->bit_num = MTK_DPI_OUT_BIT_NUM_8BITS;\n\tdpi->channel_swap = MTK_DPI_OUT_CHANNEL_SWAP_RGB;\n\tdpi->yc_map = MTK_DPI_OUT_YC_MAP_RGB;\n\tif (out_bus_format == MEDIA_BUS_FMT_YUYV8_1X16)\n\t\tdpi->color_format = MTK_DPI_COLOR_FORMAT_YCBCR_422;\n\telse\n\t\tdpi->color_format = MTK_DPI_COLOR_FORMAT_RGB;\n\n\treturn 0;\n}\n\nstatic int mtk_dpi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, dpi->next_bridge,\n\t\t\t\t &dpi->bridge, flags);\n}\n\nstatic void mtk_dpi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\n\tdrm_mode_copy(&dpi->mode, adjusted_mode);\n}\n\nstatic void mtk_dpi_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\n\tmtk_dpi_power_off(dpi);\n\n\tif (dpi->pinctrl && dpi->pins_gpio)\n\t\tpinctrl_select_state(dpi->pinctrl, dpi->pins_gpio);\n}\n\nstatic void mtk_dpi_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\n\tif (dpi->pinctrl && dpi->pins_dpi)\n\t\tpinctrl_select_state(dpi->pinctrl, dpi->pins_dpi);\n\n\tmtk_dpi_power_on(dpi);\n\tmtk_dpi_set_display_mode(dpi, &dpi->mode);\n\tmtk_dpi_enable(dpi);\n}\n\nstatic enum drm_mode_status\nmtk_dpi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct mtk_dpi *dpi = bridge_to_dpi(bridge);\n\n\tif (mode->clock > dpi->conf->max_clock_khz)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs mtk_dpi_bridge_funcs = {\n\t.attach = mtk_dpi_bridge_attach,\n\t.mode_set = mtk_dpi_bridge_mode_set,\n\t.mode_valid = mtk_dpi_bridge_mode_valid,\n\t.disable = mtk_dpi_bridge_disable,\n\t.enable = mtk_dpi_bridge_enable,\n\t.atomic_check = mtk_dpi_bridge_atomic_check,\n\t.atomic_get_output_bus_fmts = mtk_dpi_bridge_atomic_get_output_bus_fmts,\n\t.atomic_get_input_bus_fmts = mtk_dpi_bridge_atomic_get_input_bus_fmts,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nvoid mtk_dpi_start(struct device *dev)\n{\n\tstruct mtk_dpi *dpi = dev_get_drvdata(dev);\n\n\tmtk_dpi_power_on(dpi);\n}\n\nvoid mtk_dpi_stop(struct device *dev)\n{\n\tstruct mtk_dpi *dpi = dev_get_drvdata(dev);\n\n\tmtk_dpi_power_off(dpi);\n}\n\nstatic int mtk_dpi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct mtk_dpi *dpi = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = data;\n\tstruct mtk_drm_private *priv = drm_dev->dev_private;\n\tint ret;\n\n\tdpi->mmsys_dev = priv->mmsys_dev;\n\tret = drm_simple_encoder_init(drm_dev, &dpi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize decoder: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdpi->encoder.possible_crtcs = mtk_drm_find_possible_crtc_by_comp(drm_dev, dpi->dev);\n\n\tret = drm_bridge_attach(&dpi->encoder, &dpi->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\tdpi->connector = drm_bridge_connector_init(drm_dev, &dpi->encoder);\n\tif (IS_ERR(dpi->connector)) {\n\t\tdev_err(dev, \"Unable to create bridge connector\\n\");\n\t\tret = PTR_ERR(dpi->connector);\n\t\tgoto err_cleanup;\n\t}\n\tdrm_connector_attach_encoder(dpi->connector, &dpi->encoder);\n\n\treturn 0;\n\nerr_cleanup:\n\tdrm_encoder_cleanup(&dpi->encoder);\n\treturn ret;\n}\n\nstatic void mtk_dpi_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct mtk_dpi *dpi = dev_get_drvdata(dev);\n\n\tdrm_encoder_cleanup(&dpi->encoder);\n}\n\nstatic const struct component_ops mtk_dpi_component_ops = {\n\t.bind = mtk_dpi_bind,\n\t.unbind = mtk_dpi_unbind,\n};\n\nstatic unsigned int mt8173_calculate_factor(int clock)\n{\n\tif (clock <= 27000)\n\t\treturn 3 << 4;\n\telse if (clock <= 84000)\n\t\treturn 3 << 3;\n\telse if (clock <= 167000)\n\t\treturn 3 << 2;\n\telse\n\t\treturn 3 << 1;\n}\n\nstatic unsigned int mt2701_calculate_factor(int clock)\n{\n\tif (clock <= 64000)\n\t\treturn 4;\n\telse if (clock <= 128000)\n\t\treturn 2;\n\telse\n\t\treturn 1;\n}\n\nstatic unsigned int mt8183_calculate_factor(int clock)\n{\n\tif (clock <= 27000)\n\t\treturn 8;\n\telse if (clock <= 167000)\n\t\treturn 4;\n\telse\n\t\treturn 2;\n}\n\nstatic unsigned int mt8195_dpintf_calculate_factor(int clock)\n{\n\tif (clock < 70000)\n\t\treturn 4;\n\telse if (clock < 200000)\n\t\treturn 2;\n\telse\n\t\treturn 1;\n}\n\nstatic const u32 mt8173_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n};\n\nstatic const u32 mt8183_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_2X12_LE,\n\tMEDIA_BUS_FMT_RGB888_2X12_BE,\n};\n\nstatic const u32 mt8195_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\nstatic const struct mtk_dpi_conf mt8173_conf = {\n\t.cal_factor = mt8173_calculate_factor,\n\t.reg_h_fre_con = 0xe0,\n\t.max_clock_khz = 300000,\n\t.output_fmts = mt8173_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8173_output_fmts),\n\t.pixels_per_iter = 1,\n\t.is_ck_de_pol = true,\n\t.swap_input_support = true,\n\t.support_direct_pin = true,\n\t.dimension_mask = HPW_MASK,\n\t.hvsize_mask = HSIZE_MASK,\n\t.channel_swap_shift = CH_SWAP,\n\t.yuv422_en_bit = YUV422_EN,\n\t.csc_enable_bit = CSC_ENABLE,\n};\n\nstatic const struct mtk_dpi_conf mt2701_conf = {\n\t.cal_factor = mt2701_calculate_factor,\n\t.reg_h_fre_con = 0xb0,\n\t.edge_sel_en = true,\n\t.max_clock_khz = 150000,\n\t.output_fmts = mt8173_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8173_output_fmts),\n\t.pixels_per_iter = 1,\n\t.is_ck_de_pol = true,\n\t.swap_input_support = true,\n\t.support_direct_pin = true,\n\t.dimension_mask = HPW_MASK,\n\t.hvsize_mask = HSIZE_MASK,\n\t.channel_swap_shift = CH_SWAP,\n\t.yuv422_en_bit = YUV422_EN,\n\t.csc_enable_bit = CSC_ENABLE,\n};\n\nstatic const struct mtk_dpi_conf mt8183_conf = {\n\t.cal_factor = mt8183_calculate_factor,\n\t.reg_h_fre_con = 0xe0,\n\t.max_clock_khz = 100000,\n\t.output_fmts = mt8183_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8183_output_fmts),\n\t.pixels_per_iter = 1,\n\t.is_ck_de_pol = true,\n\t.swap_input_support = true,\n\t.support_direct_pin = true,\n\t.dimension_mask = HPW_MASK,\n\t.hvsize_mask = HSIZE_MASK,\n\t.channel_swap_shift = CH_SWAP,\n\t.yuv422_en_bit = YUV422_EN,\n\t.csc_enable_bit = CSC_ENABLE,\n};\n\nstatic const struct mtk_dpi_conf mt8186_conf = {\n\t.cal_factor = mt8183_calculate_factor,\n\t.reg_h_fre_con = 0xe0,\n\t.max_clock_khz = 150000,\n\t.output_fmts = mt8183_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8183_output_fmts),\n\t.edge_cfg_in_mmsys = true,\n\t.pixels_per_iter = 1,\n\t.is_ck_de_pol = true,\n\t.swap_input_support = true,\n\t.support_direct_pin = true,\n\t.dimension_mask = HPW_MASK,\n\t.hvsize_mask = HSIZE_MASK,\n\t.channel_swap_shift = CH_SWAP,\n\t.yuv422_en_bit = YUV422_EN,\n\t.csc_enable_bit = CSC_ENABLE,\n};\n\nstatic const struct mtk_dpi_conf mt8192_conf = {\n\t.cal_factor = mt8183_calculate_factor,\n\t.reg_h_fre_con = 0xe0,\n\t.max_clock_khz = 150000,\n\t.output_fmts = mt8183_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8183_output_fmts),\n\t.pixels_per_iter = 1,\n\t.is_ck_de_pol = true,\n\t.swap_input_support = true,\n\t.support_direct_pin = true,\n\t.dimension_mask = HPW_MASK,\n\t.hvsize_mask = HSIZE_MASK,\n\t.channel_swap_shift = CH_SWAP,\n\t.yuv422_en_bit = YUV422_EN,\n\t.csc_enable_bit = CSC_ENABLE,\n};\n\nstatic const struct mtk_dpi_conf mt8195_dpintf_conf = {\n\t.cal_factor = mt8195_dpintf_calculate_factor,\n\t.max_clock_khz = 600000,\n\t.output_fmts = mt8195_output_fmts,\n\t.num_output_fmts = ARRAY_SIZE(mt8195_output_fmts),\n\t.pixels_per_iter = 4,\n\t.input_2pixel = true,\n\t.dimension_mask = DPINTF_HPW_MASK,\n\t.hvsize_mask = DPINTF_HSIZE_MASK,\n\t.channel_swap_shift = DPINTF_CH_SWAP,\n\t.yuv422_en_bit = DPINTF_YUV422_EN,\n\t.csc_enable_bit = DPINTF_CSC_ENABLE,\n};\n\nstatic int mtk_dpi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_dpi *dpi;\n\tint ret;\n\n\tdpi = devm_kzalloc(dev, sizeof(*dpi), GFP_KERNEL);\n\tif (!dpi)\n\t\treturn -ENOMEM;\n\n\tdpi->dev = dev;\n\tdpi->conf = (struct mtk_dpi_conf *)of_device_get_match_data(dev);\n\tdpi->output_fmt = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tdpi->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(dpi->pinctrl)) {\n\t\tdpi->pinctrl = NULL;\n\t\tdev_dbg(&pdev->dev, \"Cannot find pinctrl!\\n\");\n\t}\n\tif (dpi->pinctrl) {\n\t\tdpi->pins_gpio = pinctrl_lookup_state(dpi->pinctrl, \"sleep\");\n\t\tif (IS_ERR(dpi->pins_gpio)) {\n\t\t\tdpi->pins_gpio = NULL;\n\t\t\tdev_dbg(&pdev->dev, \"Cannot find pinctrl idle!\\n\");\n\t\t}\n\t\tif (dpi->pins_gpio)\n\t\t\tpinctrl_select_state(dpi->pinctrl, dpi->pins_gpio);\n\n\t\tdpi->pins_dpi = pinctrl_lookup_state(dpi->pinctrl, \"default\");\n\t\tif (IS_ERR(dpi->pins_dpi)) {\n\t\t\tdpi->pins_dpi = NULL;\n\t\t\tdev_dbg(&pdev->dev, \"Cannot find pinctrl active!\\n\");\n\t\t}\n\t}\n\tdpi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dpi->regs))\n\t\treturn dev_err_probe(dev, PTR_ERR(dpi->regs),\n\t\t\t\t     \"Failed to ioremap mem resource\\n\");\n\n\tdpi->engine_clk = devm_clk_get(dev, \"engine\");\n\tif (IS_ERR(dpi->engine_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(dpi->engine_clk),\n\t\t\t\t     \"Failed to get engine clock\\n\");\n\n\tdpi->pixel_clk = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(dpi->pixel_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(dpi->pixel_clk),\n\t\t\t\t     \"Failed to get pixel clock\\n\");\n\n\tdpi->tvd_clk = devm_clk_get(dev, \"pll\");\n\tif (IS_ERR(dpi->tvd_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(dpi->tvd_clk),\n\t\t\t\t     \"Failed to get tvdpll clock\\n\");\n\n\tdpi->irq = platform_get_irq(pdev, 0);\n\tif (dpi->irq < 0)\n\t\treturn dpi->irq;\n\n\tdpi->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);\n\tif (IS_ERR(dpi->next_bridge))\n\t\treturn dev_err_probe(dev, PTR_ERR(dpi->next_bridge),\n\t\t\t\t     \"Failed to get bridge\\n\");\n\n\tdev_info(dev, \"Found bridge node: %pOF\\n\", dpi->next_bridge->of_node);\n\n\tplatform_set_drvdata(pdev, dpi);\n\n\tdpi->bridge.funcs = &mtk_dpi_bridge_funcs;\n\tdpi->bridge.of_node = dev->of_node;\n\tdpi->bridge.type = DRM_MODE_CONNECTOR_DPI;\n\n\tret = devm_drm_bridge_add(dev, &dpi->bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tret = component_add(dev, &mtk_dpi_component_ops);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add component.\\n\");\n\n\treturn 0;\n}\n\nstatic void mtk_dpi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_dpi_component_ops);\n}\n\nstatic const struct of_device_id mtk_dpi_of_ids[] = {\n\t{ .compatible = \"mediatek,mt2701-dpi\", .data = &mt2701_conf },\n\t{ .compatible = \"mediatek,mt8173-dpi\", .data = &mt8173_conf },\n\t{ .compatible = \"mediatek,mt8183-dpi\", .data = &mt8183_conf },\n\t{ .compatible = \"mediatek,mt8186-dpi\", .data = &mt8186_conf },\n\t{ .compatible = \"mediatek,mt8188-dp-intf\", .data = &mt8195_dpintf_conf },\n\t{ .compatible = \"mediatek,mt8192-dpi\", .data = &mt8192_conf },\n\t{ .compatible = \"mediatek,mt8195-dp-intf\", .data = &mt8195_dpintf_conf },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mtk_dpi_of_ids);\n\nstruct platform_driver mtk_dpi_driver = {\n\t.probe = mtk_dpi_probe,\n\t.remove_new = mtk_dpi_remove,\n\t.driver = {\n\t\t.name = \"mediatek-dpi\",\n\t\t.of_match_table = mtk_dpi_of_ids,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}