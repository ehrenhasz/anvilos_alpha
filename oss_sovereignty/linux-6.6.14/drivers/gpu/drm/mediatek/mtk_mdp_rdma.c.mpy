{
  "module_name": "mtk_mdp_rdma.c",
  "hash_id": "0f9e66c049a84182adc13a6de8bab93098a9f090f86a74e5904bbefc611a360c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c",
  "human_readable_source": "\n \n\n#include <drm/drm_fourcc.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n\n#include \"mtk_disp_drv.h\"\n#include \"mtk_drm_drv.h\"\n#include \"mtk_mdp_rdma.h\"\n\n#define MDP_RDMA_EN\t\t\t0x000\n#define FLD_ROT_ENABLE\t\t\t\tBIT(0)\n#define MDP_RDMA_RESET\t\t\t0x008\n#define MDP_RDMA_CON\t\t\t0x020\n#define FLD_OUTPUT_10B\t\t\t\tBIT(5)\n#define FLD_SIMPLE_MODE\t\t\t\tBIT(4)\n#define MDP_RDMA_GMCIF_CON\t\t0x028\n#define FLD_COMMAND_DIV\t\t\t\tBIT(0)\n#define FLD_EXT_PREULTRA_EN\t\t\tBIT(3)\n#define FLD_RD_REQ_TYPE\t\t\t\tGENMASK(7, 4)\n#define VAL_RD_REQ_TYPE_BURST_8_ACCESS\t\t7\n#define FLD_ULTRA_EN\t\t\t\tGENMASK(13, 12)\n#define VAL_ULTRA_EN_ENABLE\t\t\t1\n#define FLD_PRE_ULTRA_EN\t\t\tGENMASK(17, 16)\n#define VAL_PRE_ULTRA_EN_ENABLE\t\t\t1\n#define FLD_EXT_ULTRA_EN\t\t\tBIT(18)\n#define MDP_RDMA_SRC_CON\t\t0x030\n#define FLD_OUTPUT_ARGB\t\t\t\tBIT(25)\n#define FLD_BIT_NUMBER\t\t\t\tGENMASK(19, 18)\n#define FLD_SWAP\t\t\t\tBIT(14)\n#define FLD_UNIFORM_CONFIG\t\t\tBIT(17)\n#define RDMA_INPUT_10BIT\t\t\tBIT(18)\n#define FLD_SRC_FORMAT\t\t\t\tGENMASK(3, 0)\n#define MDP_RDMA_COMP_CON\t\t0x038\n#define FLD_AFBC_EN\t\t\t\tBIT(22)\n#define FLD_AFBC_YUV_TRANSFORM\t\t\tBIT(21)\n#define FLD_UFBDC_EN\t\t\t\tBIT(12)\n#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE\t0x060\n#define FLD_MF_BKGD_WB\t\t\t\tGENMASK(22, 0)\n#define MDP_RDMA_MF_SRC_SIZE\t\t0x070\n#define FLD_MF_SRC_H\t\t\t\tGENMASK(30, 16)\n#define FLD_MF_SRC_W\t\t\t\tGENMASK(14, 0)\n#define MDP_RDMA_MF_CLIP_SIZE\t\t0x078\n#define FLD_MF_CLIP_H\t\t\t\tGENMASK(30, 16)\n#define FLD_MF_CLIP_W\t\t\t\tGENMASK(14, 0)\n#define MDP_RDMA_SRC_OFFSET_0\t\t0x118\n#define FLD_SRC_OFFSET_0\t\t\tGENMASK(31, 0)\n#define MDP_RDMA_TRANSFORM_0\t\t0x200\n#define FLD_INT_MATRIX_SEL\t\t\tGENMASK(27, 23)\n#define FLD_TRANS_EN\t\t\t\tBIT(16)\n#define MDP_RDMA_SRC_BASE_0\t\t0xf00\n#define FLD_SRC_BASE_0\t\t\t\tGENMASK(31, 0)\n\n#define RDMA_CSC_FULL709_TO_RGB\t\t\t5\n#define RDMA_CSC_BT601_TO_RGB\t\t\t6\n\nstatic const u32 formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n};\n\nenum rdma_format {\n\tRDMA_INPUT_FORMAT_RGB565 = 0,\n\tRDMA_INPUT_FORMAT_RGB888 = 1,\n\tRDMA_INPUT_FORMAT_RGBA8888 = 2,\n\tRDMA_INPUT_FORMAT_ARGB8888 = 3,\n\tRDMA_INPUT_FORMAT_UYVY = 4,\n\tRDMA_INPUT_FORMAT_YUY2 = 5,\n\tRDMA_INPUT_FORMAT_Y8 = 7,\n\tRDMA_INPUT_FORMAT_YV12 = 8,\n\tRDMA_INPUT_FORMAT_UYVY_3PL = 9,\n\tRDMA_INPUT_FORMAT_NV12 = 12,\n\tRDMA_INPUT_FORMAT_UYVY_2PL = 13,\n\tRDMA_INPUT_FORMAT_Y410 = 14\n};\n\nstruct mtk_mdp_rdma {\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\tstruct cmdq_client_reg\tcmdq_reg;\n};\n\nstatic unsigned int rdma_fmt_convert(unsigned int fmt)\n{\n\tswitch (fmt) {\n\tdefault:\n\tcase DRM_FORMAT_RGB565:\n\t\treturn RDMA_INPUT_FORMAT_RGB565;\n\tcase DRM_FORMAT_BGR565:\n\t\treturn RDMA_INPUT_FORMAT_RGB565 | FLD_SWAP;\n\tcase DRM_FORMAT_RGB888:\n\t\treturn RDMA_INPUT_FORMAT_RGB888;\n\tcase DRM_FORMAT_BGR888:\n\t\treturn RDMA_INPUT_FORMAT_RGB888 | FLD_SWAP;\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_RGBA8888:\n\t\treturn RDMA_INPUT_FORMAT_ARGB8888;\n\tcase DRM_FORMAT_BGRX8888:\n\tcase DRM_FORMAT_BGRA8888:\n\t\treturn RDMA_INPUT_FORMAT_ARGB8888 | FLD_SWAP;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn RDMA_INPUT_FORMAT_RGBA8888;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn RDMA_INPUT_FORMAT_RGBA8888 | FLD_SWAP;\n\tcase DRM_FORMAT_ABGR2101010:\n\t\treturn RDMA_INPUT_FORMAT_RGBA8888 | FLD_SWAP | RDMA_INPUT_10BIT;\n\tcase DRM_FORMAT_ARGB2101010:\n\t\treturn RDMA_INPUT_FORMAT_RGBA8888 | RDMA_INPUT_10BIT;\n\tcase DRM_FORMAT_RGBA1010102:\n\t\treturn RDMA_INPUT_FORMAT_ARGB8888 | FLD_SWAP | RDMA_INPUT_10BIT;\n\tcase DRM_FORMAT_BGRA1010102:\n\t\treturn RDMA_INPUT_FORMAT_ARGB8888 | RDMA_INPUT_10BIT;\n\tcase DRM_FORMAT_UYVY:\n\t\treturn RDMA_INPUT_FORMAT_UYVY;\n\tcase DRM_FORMAT_YUYV:\n\t\treturn RDMA_INPUT_FORMAT_YUY2;\n\t}\n}\n\nstatic unsigned int rdma_color_convert(unsigned int color_encoding)\n{\n\tswitch (color_encoding) {\n\tdefault:\n\tcase DRM_COLOR_YCBCR_BT709:\n\t\treturn RDMA_CSC_FULL709_TO_RGB;\n\tcase DRM_COLOR_YCBCR_BT601:\n\t\treturn RDMA_CSC_BT601_TO_RGB;\n\t}\n}\n\nstatic void mtk_mdp_rdma_fifo_config(struct device *dev, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_mdp_rdma *priv = dev_get_drvdata(dev);\n\n\tmtk_ddp_write_mask(cmdq_pkt, FLD_EXT_ULTRA_EN | VAL_PRE_ULTRA_EN_ENABLE << 16 |\n\t\t\t   VAL_ULTRA_EN_ENABLE << 12 | VAL_RD_REQ_TYPE_BURST_8_ACCESS << 4 |\n\t\t\t   FLD_EXT_PREULTRA_EN | FLD_COMMAND_DIV, &priv->cmdq_reg,\n\t\t\t   priv->regs, MDP_RDMA_GMCIF_CON, FLD_EXT_ULTRA_EN |\n\t\t\t   FLD_PRE_ULTRA_EN | FLD_ULTRA_EN | FLD_RD_REQ_TYPE |\n\t\t\t   FLD_EXT_PREULTRA_EN | FLD_COMMAND_DIV);\n}\n\nvoid mtk_mdp_rdma_start(struct device *dev, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_mdp_rdma *priv = dev_get_drvdata(dev);\n\n\tmtk_ddp_write_mask(cmdq_pkt, FLD_ROT_ENABLE, &priv->cmdq_reg,\n\t\t\t   priv->regs, MDP_RDMA_EN, FLD_ROT_ENABLE);\n}\n\nvoid mtk_mdp_rdma_stop(struct device *dev, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_mdp_rdma *priv = dev_get_drvdata(dev);\n\n\tmtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg,\n\t\t\t   priv->regs, MDP_RDMA_EN, FLD_ROT_ENABLE);\n\tmtk_ddp_write(cmdq_pkt, 1, &priv->cmdq_reg, priv->regs, MDP_RDMA_RESET);\n\tmtk_ddp_write(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_RESET);\n}\n\nvoid mtk_mdp_rdma_config(struct device *dev, struct mtk_mdp_rdma_cfg *cfg,\n\t\t\t struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_mdp_rdma *priv = dev_get_drvdata(dev);\n\tconst struct drm_format_info *fmt_info = drm_format_info(cfg->fmt);\n\tbool csc_enable = fmt_info->is_yuv ? true : false;\n\tunsigned int src_pitch_y = cfg->pitch;\n\tunsigned int offset_y = 0;\n\n\tmtk_mdp_rdma_fifo_config(dev, cmdq_pkt);\n\n\tmtk_ddp_write_mask(cmdq_pkt, FLD_UNIFORM_CONFIG, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_SRC_CON, FLD_UNIFORM_CONFIG);\n\tmtk_ddp_write_mask(cmdq_pkt, rdma_fmt_convert(cfg->fmt), &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_SRC_CON, FLD_SWAP | FLD_SRC_FORMAT | FLD_BIT_NUMBER);\n\n\tif (!csc_enable && fmt_info->has_alpha)\n\t\tmtk_ddp_write_mask(cmdq_pkt, FLD_OUTPUT_ARGB, &priv->cmdq_reg,\n\t\t\t\t   priv->regs, MDP_RDMA_SRC_CON, FLD_OUTPUT_ARGB);\n\telse\n\t\tmtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs,\n\t\t\t\t   MDP_RDMA_SRC_CON, FLD_OUTPUT_ARGB);\n\n\tmtk_ddp_write_mask(cmdq_pkt, cfg->addr0, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_SRC_BASE_0, FLD_SRC_BASE_0);\n\n\tmtk_ddp_write_mask(cmdq_pkt, src_pitch_y, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_MF_BKGD_SIZE_IN_BYTE, FLD_MF_BKGD_WB);\n\n\tmtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_COMP_CON,\n\t\t\t   FLD_AFBC_YUV_TRANSFORM | FLD_UFBDC_EN | FLD_AFBC_EN);\n\tmtk_ddp_write_mask(cmdq_pkt, FLD_OUTPUT_10B, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_CON, FLD_OUTPUT_10B);\n\tmtk_ddp_write_mask(cmdq_pkt, FLD_SIMPLE_MODE, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_CON, FLD_SIMPLE_MODE);\n\tif (csc_enable)\n\t\tmtk_ddp_write_mask(cmdq_pkt, rdma_color_convert(cfg->color_encoding) << 23,\n\t\t\t\t   &priv->cmdq_reg, priv->regs, MDP_RDMA_TRANSFORM_0,\n\t\t\t\t   FLD_INT_MATRIX_SEL);\n\tmtk_ddp_write_mask(cmdq_pkt, csc_enable << 16, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_TRANSFORM_0, FLD_TRANS_EN);\n\n\toffset_y  = cfg->x_left * fmt_info->cpp[0] + cfg->y_top * src_pitch_y;\n\n\tmtk_ddp_write_mask(cmdq_pkt, offset_y, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_SRC_OFFSET_0, FLD_SRC_OFFSET_0);\n\tmtk_ddp_write_mask(cmdq_pkt, cfg->width, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_MF_SRC_SIZE, FLD_MF_SRC_W);\n\tmtk_ddp_write_mask(cmdq_pkt, cfg->height << 16, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_MF_SRC_SIZE, FLD_MF_SRC_H);\n\tmtk_ddp_write_mask(cmdq_pkt, cfg->width, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_MF_CLIP_SIZE, FLD_MF_CLIP_W);\n\tmtk_ddp_write_mask(cmdq_pkt, cfg->height << 16, &priv->cmdq_reg, priv->regs,\n\t\t\t   MDP_RDMA_MF_CLIP_SIZE, FLD_MF_CLIP_H);\n}\n\nconst u32 *mtk_mdp_rdma_get_formats(struct device *dev)\n{\n\treturn formats;\n}\n\nsize_t mtk_mdp_rdma_get_num_formats(struct device *dev)\n{\n\treturn ARRAY_SIZE(formats);\n}\n\nint mtk_mdp_rdma_clk_enable(struct device *dev)\n{\n\tstruct mtk_mdp_rdma *rdma = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(rdma->clk);\n}\n\nvoid mtk_mdp_rdma_clk_disable(struct device *dev)\n{\n\tstruct mtk_mdp_rdma *rdma = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(rdma->clk);\n}\n\nstatic int mtk_mdp_rdma_bind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\treturn 0;\n}\n\nstatic void mtk_mdp_rdma_unbind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n}\n\nstatic const struct component_ops mtk_mdp_rdma_component_ops = {\n\t.bind\t= mtk_mdp_rdma_bind,\n\t.unbind = mtk_mdp_rdma_unbind,\n};\n\nstatic int mtk_mdp_rdma_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct mtk_mdp_rdma *priv;\n\tint ret = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"failed to ioremap rdma\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get rdma clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n#if IS_REACHABLE(CONFIG_MTK_CMDQ)\n\tret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);\n\tif (ret)\n\t\tdev_dbg(dev, \"get mediatek,gce-client-reg fail!\\n\");\n#endif\n\tplatform_set_drvdata(pdev, priv);\n\n\tpm_runtime_enable(dev);\n\n\tret = component_add(dev, &mtk_mdp_rdma_component_ops);\n\tif (ret != 0) {\n\t\tpm_runtime_disable(dev);\n\t\tdev_err(dev, \"Failed to add component: %d\\n\", ret);\n\t}\n\treturn ret;\n}\n\nstatic void mtk_mdp_rdma_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &mtk_mdp_rdma_component_ops);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id mtk_mdp_rdma_driver_dt_match[] = {\n\t{ .compatible = \"mediatek,mt8195-vdo1-rdma\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_mdp_rdma_driver_dt_match);\n\nstruct platform_driver mtk_mdp_rdma_driver = {\n\t.probe = mtk_mdp_rdma_probe,\n\t.remove_new = mtk_mdp_rdma_remove,\n\t.driver = {\n\t\t.name = \"mediatek-mdp-rdma\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = mtk_mdp_rdma_driver_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}