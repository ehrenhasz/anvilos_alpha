{
  "module_name": "udl_main.c",
  "hash_id": "5eb45a15da0bc1a24f393aafb050f0d6c137f0d2aca06e15dce4928391a5fa48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/udl/udl_main.c",
  "human_readable_source": "\n \n\n#include <drm/drm.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"udl_drv.h\"\n\n \n#define BULK_SIZE 512\n\n#define NR_USB_REQUEST_CHANNEL 0x12\n\n#define MAX_TRANSFER (PAGE_SIZE*16 - BULK_SIZE)\n#define WRITES_IN_FLIGHT (20)\n#define MAX_VENDOR_DESCRIPTOR_SIZE 256\n\nstatic struct urb *udl_get_urb_locked(struct udl_device *udl, long timeout);\n\nstatic int udl_parse_vendor_descriptor(struct udl_device *udl)\n{\n\tstruct usb_device *udev = udl_to_usb_device(udl);\n\tchar *desc;\n\tchar *buf;\n\tchar *desc_end;\n\n\tu8 total_len = 0;\n\n\tbuf = kzalloc(MAX_VENDOR_DESCRIPTOR_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\tdesc = buf;\n\n\ttotal_len = usb_get_descriptor(udev, 0x5f,  \n\t\t\t\t    0, desc, MAX_VENDOR_DESCRIPTOR_SIZE);\n\tif (total_len > 5) {\n\t\tDRM_INFO(\"vendor descriptor length:%x data:%11ph\\n\",\n\t\t\ttotal_len, desc);\n\n\t\tif ((desc[0] != total_len) ||  \n\t\t    (desc[1] != 0x5f) ||    \n\t\t    (desc[2] != 0x01) ||    \n\t\t    (desc[3] != 0x00) ||\n\t\t    (desc[4] != total_len - 2))  \n\t\t\tgoto unrecognized;\n\n\t\tdesc_end = desc + total_len;\n\t\tdesc += 5;  \n\n\t\twhile (desc < desc_end) {\n\t\t\tu8 length;\n\t\t\tu16 key;\n\n\t\t\tkey = le16_to_cpu(*((u16 *) desc));\n\t\t\tdesc += sizeof(u16);\n\t\t\tlength = *desc;\n\t\t\tdesc++;\n\n\t\t\tswitch (key) {\n\t\t\tcase 0x0200: {  \n\t\t\t\tu32 max_area;\n\t\t\t\tmax_area = le32_to_cpu(*((u32 *)desc));\n\t\t\t\tDRM_DEBUG(\"DL chip limited to %d pixel modes\\n\",\n\t\t\t\t\tmax_area);\n\t\t\t\tudl->sku_pixel_limit = max_area;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc += length;\n\t\t}\n\t}\n\n\tgoto success;\n\nunrecognized:\n\t \n\tDRM_ERROR(\"Unrecognized vendor firmware descriptor\\n\");\n\nsuccess:\n\tkfree(buf);\n\treturn true;\n}\n\n \nint udl_select_std_channel(struct udl_device *udl)\n{\n\tstatic const u8 set_def_chn[] = {0x57, 0xCD, 0xDC, 0xA7,\n\t\t\t\t\t 0x1C, 0x88, 0x5E, 0x15,\n\t\t\t\t\t 0x60, 0xFE, 0xC6, 0x97,\n\t\t\t\t\t 0x16, 0x3D, 0x47, 0xF2};\n\n\tvoid *sendbuf;\n\tint ret;\n\tstruct usb_device *udev = udl_to_usb_device(udl);\n\n\tsendbuf = kmemdup(set_def_chn, sizeof(set_def_chn), GFP_KERNEL);\n\tif (!sendbuf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      NR_USB_REQUEST_CHANNEL,\n\t\t\t      (USB_DIR_OUT | USB_TYPE_VENDOR), 0, 0,\n\t\t\t      sendbuf, sizeof(set_def_chn),\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tkfree(sendbuf);\n\treturn ret < 0 ? ret : 0;\n}\n\nvoid udl_urb_completion(struct urb *urb)\n{\n\tstruct urb_node *unode = urb->context;\n\tstruct udl_device *udl = unode->dev;\n\tunsigned long flags;\n\n\t \n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t    urb->status == -ECONNRESET ||\n\t\t    urb->status == -EPROTO ||\n\t\t    urb->status == -ESHUTDOWN)) {\n\t\t\tDRM_ERROR(\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\t}\n\t}\n\n\turb->transfer_buffer_length = udl->urbs.size;  \n\n\tspin_lock_irqsave(&udl->urbs.lock, flags);\n\tlist_add_tail(&unode->entry, &udl->urbs.list);\n\tudl->urbs.available++;\n\tspin_unlock_irqrestore(&udl->urbs.lock, flags);\n\n\twake_up(&udl->urbs.sleep);\n}\n\nstatic void udl_free_urb_list(struct drm_device *dev)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\tstruct urb_node *unode;\n\tstruct urb *urb;\n\n\tDRM_DEBUG(\"Waiting for completes and freeing all render urbs\\n\");\n\n\t \n\twhile (udl->urbs.count) {\n\t\tspin_lock_irq(&udl->urbs.lock);\n\t\turb = udl_get_urb_locked(udl, MAX_SCHEDULE_TIMEOUT);\n\t\tudl->urbs.count--;\n\t\tspin_unlock_irq(&udl->urbs.lock);\n\t\tif (WARN_ON(!urb))\n\t\t\tbreak;\n\t\tunode = urb->context;\n\t\t \n\t\tusb_free_coherent(urb->dev, udl->urbs.size,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t\tkfree(unode);\n\t}\n\n\twake_up_all(&udl->urbs.sleep);\n}\n\nstatic int udl_alloc_urb_list(struct drm_device *dev, int count, size_t size)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\tstruct urb *urb;\n\tstruct urb_node *unode;\n\tchar *buf;\n\tsize_t wanted_size = count * size;\n\tstruct usb_device *udev = udl_to_usb_device(udl);\n\n\tspin_lock_init(&udl->urbs.lock);\n\tINIT_LIST_HEAD(&udl->urbs.list);\n\tinit_waitqueue_head(&udl->urbs.sleep);\n\tudl->urbs.count = 0;\n\tudl->urbs.available = 0;\n\nretry:\n\tudl->urbs.size = size;\n\n\twhile (udl->urbs.count * size < wanted_size) {\n\t\tunode = kzalloc(sizeof(struct urb_node), GFP_KERNEL);\n\t\tif (!unode)\n\t\t\tbreak;\n\t\tunode->dev = udl;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tkfree(unode);\n\t\t\tbreak;\n\t\t}\n\t\tunode->urb = urb;\n\n\t\tbuf = usb_alloc_coherent(udev, size, GFP_KERNEL,\n\t\t\t\t\t &urb->transfer_dma);\n\t\tif (!buf) {\n\t\t\tkfree(unode);\n\t\t\tusb_free_urb(urb);\n\t\t\tif (size > PAGE_SIZE) {\n\t\t\t\tsize /= 2;\n\t\t\t\tudl_free_urb_list(dev);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, 1),\n\t\t\t\t  buf, size, udl_urb_completion, unode);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\tlist_add_tail(&unode->entry, &udl->urbs.list);\n\n\t\tudl->urbs.count++;\n\t\tudl->urbs.available++;\n\t}\n\n\tDRM_DEBUG(\"allocated %d %d byte urbs\\n\", udl->urbs.count, (int) size);\n\n\treturn udl->urbs.count;\n}\n\nstatic struct urb *udl_get_urb_locked(struct udl_device *udl, long timeout)\n{\n\tstruct urb_node *unode;\n\n\tassert_spin_locked(&udl->urbs.lock);\n\n\t \n\tif (!wait_event_lock_irq_timeout(udl->urbs.sleep,\n\t\t\t\t\t !udl->urbs.count ||\n\t\t\t\t\t !list_empty(&udl->urbs.list),\n\t\t\t\t\t udl->urbs.lock, timeout)) {\n\t\tDRM_INFO(\"wait for urb interrupted: available: %d\\n\",\n\t\t\t udl->urbs.available);\n\t\treturn NULL;\n\t}\n\n\tif (!udl->urbs.count)\n\t\treturn NULL;\n\n\tunode = list_first_entry(&udl->urbs.list, struct urb_node, entry);\n\tlist_del_init(&unode->entry);\n\tudl->urbs.available--;\n\n\treturn unode->urb;\n}\n\n#define GET_URB_TIMEOUT\tHZ\nstruct urb *udl_get_urb(struct drm_device *dev)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\tstruct urb *urb;\n\n\tspin_lock_irq(&udl->urbs.lock);\n\turb = udl_get_urb_locked(udl, GET_URB_TIMEOUT);\n\tspin_unlock_irq(&udl->urbs.lock);\n\treturn urb;\n}\n\nint udl_submit_urb(struct drm_device *dev, struct urb *urb, size_t len)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\tint ret;\n\n\tif (WARN_ON(len > udl->urbs.size)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\turb->transfer_buffer_length = len;  \n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n error:\n\tif (ret) {\n\t\tudl_urb_completion(urb);  \n\t\tDRM_ERROR(\"usb_submit_urb error %x\\n\", ret);\n\t}\n\treturn ret;\n}\n\n \nvoid udl_sync_pending_urbs(struct drm_device *dev)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\n\tspin_lock_irq(&udl->urbs.lock);\n\t \n\tif (!wait_event_lock_irq_timeout(udl->urbs.sleep,\n\t\t\t\t\t udl->urbs.available == udl->urbs.count,\n\t\t\t\t\t udl->urbs.lock,\n\t\t\t\t\t msecs_to_jiffies(2000)))\n\t\tdrm_err(dev, \"Timeout for syncing pending URBs\\n\");\n\tspin_unlock_irq(&udl->urbs.lock);\n}\n\nint udl_init(struct udl_device *udl)\n{\n\tstruct drm_device *dev = &udl->drm;\n\tint ret = -ENOMEM;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tudl->dmadev = usb_intf_get_dma_device(to_usb_interface(dev->dev));\n\tif (!udl->dmadev)\n\t\tdrm_warn(dev, \"buffer sharing not supported\");  \n\n\tmutex_init(&udl->gem_lock);\n\n\tif (!udl_parse_vendor_descriptor(udl)) {\n\t\tret = -ENODEV;\n\t\tDRM_ERROR(\"firmware not recognized. Assume incompatible device\\n\");\n\t\tgoto err;\n\t}\n\n\tif (udl_select_std_channel(udl))\n\t\tDRM_ERROR(\"Selecting channel failed\\n\");\n\n\tif (!udl_alloc_urb_list(dev, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\n\t\tDRM_ERROR(\"udl_alloc_urb_list failed\\n\");\n\t\tgoto err;\n\t}\n\n\tDRM_DEBUG(\"\\n\");\n\tret = udl_modeset_init(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tdrm_kms_helper_poll_init(dev);\n\n\treturn 0;\n\nerr:\n\tif (udl->urbs.count)\n\t\tudl_free_urb_list(dev);\n\tput_device(udl->dmadev);\n\tDRM_ERROR(\"%d\\n\", ret);\n\treturn ret;\n}\n\nint udl_drop_usb(struct drm_device *dev)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\n\tudl_free_urb_list(dev);\n\tput_device(udl->dmadev);\n\tudl->dmadev = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}