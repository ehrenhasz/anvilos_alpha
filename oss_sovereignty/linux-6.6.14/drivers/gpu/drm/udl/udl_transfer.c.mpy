{
  "module_name": "udl_transfer.c",
  "hash_id": "7ab1e1152cb393a58e419495608ad740b53ccca16295b025c94e52fc7df84577",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/udl/udl_transfer.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include \"udl_drv.h\"\n#include \"udl_proto.h\"\n\n#define MAX_CMD_PIXELS\t\t255\n\n#define RLX_HEADER_BYTES\t7\n#define MIN_RLX_PIX_BYTES       4\n#define MIN_RLX_CMD_BYTES\t(RLX_HEADER_BYTES + MIN_RLX_PIX_BYTES)\n\n#define RLE_HEADER_BYTES\t6\n#define MIN_RLE_PIX_BYTES\t3\n#define MIN_RLE_CMD_BYTES\t(RLE_HEADER_BYTES + MIN_RLE_PIX_BYTES)\n\n#define RAW_HEADER_BYTES\t6\n#define MIN_RAW_PIX_BYTES\t2\n#define MIN_RAW_CMD_BYTES\t(RAW_HEADER_BYTES + MIN_RAW_PIX_BYTES)\n\nstatic inline u16 pixel32_to_be16(const uint32_t pixel)\n{\n\treturn (((pixel >> 3) & 0x001f) |\n\t\t((pixel >> 5) & 0x07e0) |\n\t\t((pixel >> 8) & 0xf800));\n}\n\nstatic inline u16 get_pixel_val16(const uint8_t *pixel, int log_bpp)\n{\n\tu16 pixel_val16;\n\tif (log_bpp == 1)\n\t\tpixel_val16 = *(const uint16_t *)pixel;\n\telse\n\t\tpixel_val16 = pixel32_to_be16(*(const uint32_t *)pixel);\n\treturn pixel_val16;\n}\n\n \nstatic void udl_compress_hline16(\n\tconst u8 **pixel_start_ptr,\n\tconst u8 *const pixel_end,\n\tuint32_t *device_address_ptr,\n\tuint8_t **command_buffer_ptr,\n\tconst uint8_t *const cmd_buffer_end, int log_bpp)\n{\n\tconst int bpp = 1 << log_bpp;\n\tconst u8 *pixel = *pixel_start_ptr;\n\tuint32_t dev_addr  = *device_address_ptr;\n\tuint8_t *cmd = *command_buffer_ptr;\n\n\twhile ((pixel_end > pixel) &&\n\t       (cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {\n\t\tuint8_t *raw_pixels_count_byte = NULL;\n\t\tuint8_t *cmd_pixels_count_byte = NULL;\n\t\tconst u8 *raw_pixel_start = NULL;\n\t\tconst u8 *cmd_pixel_start, *cmd_pixel_end = NULL;\n\t\tuint16_t pixel_val16;\n\n\t\t*cmd++ = UDL_MSG_BULK;\n\t\t*cmd++ = UDL_CMD_WRITERLX16;\n\t\t*cmd++ = (uint8_t) ((dev_addr >> 16) & 0xFF);\n\t\t*cmd++ = (uint8_t) ((dev_addr >> 8) & 0xFF);\n\t\t*cmd++ = (uint8_t) ((dev_addr) & 0xFF);\n\n\t\tcmd_pixels_count_byte = cmd++;  \n\t\tcmd_pixel_start = pixel;\n\n\t\traw_pixels_count_byte = cmd++;  \n\t\traw_pixel_start = pixel;\n\n\t\tcmd_pixel_end = pixel + (min3(MAX_CMD_PIXELS + 1UL,\n\t\t\t\t\t(unsigned long)(pixel_end - pixel) >> log_bpp,\n\t\t\t\t\t(unsigned long)(cmd_buffer_end - 1 - cmd) / 2) << log_bpp);\n\n\t\tpixel_val16 = get_pixel_val16(pixel, log_bpp);\n\n\t\twhile (pixel < cmd_pixel_end) {\n\t\t\tconst u8 *const start = pixel;\n\t\t\tconst uint16_t repeating_pixel_val16 = pixel_val16;\n\n\t\t\tput_unaligned_be16(pixel_val16, cmd);\n\n\t\t\tcmd += 2;\n\t\t\tpixel += bpp;\n\n\t\t\twhile (pixel < cmd_pixel_end) {\n\t\t\t\tpixel_val16 = get_pixel_val16(pixel, log_bpp);\n\t\t\t\tif (pixel_val16 != repeating_pixel_val16)\n\t\t\t\t\tbreak;\n\t\t\t\tpixel += bpp;\n\t\t\t}\n\n\t\t\tif (unlikely(pixel > start + bpp)) {\n\t\t\t\t \n\t\t\t\t*raw_pixels_count_byte = (((start -\n\t\t\t\t\t\traw_pixel_start) >> log_bpp) + 1) & 0xFF;\n\n\t\t\t\t \n\t\t\t\t*cmd++ = (((pixel - start) >> log_bpp) - 1) & 0xFF;\n\n\t\t\t\t \n\t\t\t\traw_pixel_start = pixel;\n\t\t\t\traw_pixels_count_byte = cmd++;\n\t\t\t}\n\t\t}\n\n\t\tif (pixel > raw_pixel_start) {\n\t\t\t \n\t\t\t*raw_pixels_count_byte = ((pixel - raw_pixel_start) >> log_bpp) & 0xFF;\n\t\t} else {\n\t\t\t \n\t\t\tcmd--;\n\t\t}\n\n\t\t*cmd_pixels_count_byte = ((pixel - cmd_pixel_start) >> log_bpp) & 0xFF;\n\t\tdev_addr += ((pixel - cmd_pixel_start) >> log_bpp) * 2;\n\t}\n\n\tif (cmd_buffer_end <= MIN_RLX_CMD_BYTES + cmd) {\n\t\t \n\t\tif (cmd_buffer_end > cmd)\n\t\t\tmemset(cmd, UDL_MSG_BULK, cmd_buffer_end - cmd);\n\t\tcmd = (uint8_t *) cmd_buffer_end;\n\t}\n\n\t*command_buffer_ptr = cmd;\n\t*pixel_start_ptr = pixel;\n\t*device_address_ptr = dev_addr;\n\n\treturn;\n}\n\n \nint udl_render_hline(struct drm_device *dev, int log_bpp, struct urb **urb_ptr,\n\t\t     const char *front, char **urb_buf_ptr,\n\t\t     u32 byte_offset, u32 device_byte_offset,\n\t\t     u32 byte_width)\n{\n\tconst u8 *line_start, *line_end, *next_pixel;\n\tu32 base16 = 0 + (device_byte_offset >> log_bpp) * 2;\n\tstruct urb *urb = *urb_ptr;\n\tu8 *cmd = *urb_buf_ptr;\n\tu8 *cmd_end = (u8 *) urb->transfer_buffer + urb->transfer_buffer_length;\n\n\tif (WARN_ON(!(log_bpp == 1 || log_bpp == 2))) {\n\t\t \n\t\tudl_urb_completion(urb);\n\t\treturn -EINVAL;\n\t}\n\n\tline_start = (u8 *) (front + byte_offset);\n\tnext_pixel = line_start;\n\tline_end = next_pixel + byte_width;\n\n\twhile (next_pixel < line_end) {\n\n\t\tudl_compress_hline16(&next_pixel,\n\t\t\t     line_end, &base16,\n\t\t\t     (u8 **) &cmd, (u8 *) cmd_end, log_bpp);\n\n\t\tif (cmd >= cmd_end) {\n\t\t\tint len = cmd - (u8 *) urb->transfer_buffer;\n\t\t\tint ret = udl_submit_urb(dev, urb, len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\turb = udl_get_urb(dev);\n\t\t\tif (!urb)\n\t\t\t\treturn -EAGAIN;\n\t\t\t*urb_ptr = urb;\n\t\t\tcmd = urb->transfer_buffer;\n\t\t\tcmd_end = &cmd[urb->transfer_buffer_length];\n\t\t}\n\t}\n\n\t*urb_buf_ptr = cmd;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}