{
  "module_name": "udl_drv.c",
  "hash_id": "f05c2c832d0c5d55ed326ab902f16ed6f7ba2c5d66fe85761ad7077c3855e3c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/udl/udl_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_print.h>\n\n#include \"udl_drv.h\"\n\nstatic int udl_usb_suspend(struct usb_interface *interface,\n\t\t\t   pm_message_t message)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\tint ret;\n\n\tret = drm_mode_config_helper_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tudl_sync_pending_urbs(dev);\n\treturn 0;\n}\n\nstatic int udl_usb_resume(struct usb_interface *interface)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\n\treturn drm_mode_config_helper_resume(dev);\n}\n\nstatic int udl_usb_reset_resume(struct usb_interface *interface)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\tstruct udl_device *udl = to_udl(dev);\n\n\tudl_select_std_channel(udl);\n\n\treturn drm_mode_config_helper_resume(dev);\n}\n\n \nstatic struct drm_gem_object *udl_driver_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t\t\t  struct dma_buf *dma_buf)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\n\tif (!udl->dmadev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn drm_gem_prime_import_dev(dev, dma_buf, udl->dmadev);\n}\n\nDEFINE_DRM_GEM_FOPS(udl_driver_fops);\n\nstatic const struct drm_driver driver = {\n\t.driver_features = DRIVER_ATOMIC | DRIVER_GEM | DRIVER_MODESET,\n\n\t \n\t.fops = &udl_driver_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.gem_prime_import = udl_driver_gem_prime_import,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nstatic struct udl_device *udl_driver_create(struct usb_interface *interface)\n{\n\tstruct udl_device *udl;\n\tint r;\n\n\tudl = devm_drm_dev_alloc(&interface->dev, &driver,\n\t\t\t\t struct udl_device, drm);\n\tif (IS_ERR(udl))\n\t\treturn udl;\n\n\tr = udl_init(udl);\n\tif (r)\n\t\treturn ERR_PTR(r);\n\n\tusb_set_intfdata(interface, udl);\n\n\treturn udl;\n}\n\nstatic int udl_usb_probe(struct usb_interface *interface,\n\t\t\t const struct usb_device_id *id)\n{\n\tint r;\n\tstruct udl_device *udl;\n\n\tudl = udl_driver_create(interface);\n\tif (IS_ERR(udl))\n\t\treturn PTR_ERR(udl);\n\n\tr = drm_dev_register(&udl->drm, 0);\n\tif (r)\n\t\treturn r;\n\n\tDRM_INFO(\"Initialized udl on minor %d\\n\", udl->drm.primary->index);\n\n\tdrm_fbdev_generic_setup(&udl->drm, 0);\n\n\treturn 0;\n}\n\nstatic void udl_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct drm_device *dev = usb_get_intfdata(interface);\n\n\tdrm_kms_helper_poll_fini(dev);\n\tudl_drop_usb(dev);\n\tdrm_dev_unplug(dev);\n}\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{.idVendor = 0x17e9, .bInterfaceClass = 0xff,\n\t .bInterfaceSubClass = 0x00,\n\t .bInterfaceProtocol = 0x00,\n\t .match_flags = USB_DEVICE_ID_MATCH_VENDOR |\n\t\t\tUSB_DEVICE_ID_MATCH_INT_CLASS |\n\t\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS |\n\t\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL,},\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver udl_driver = {\n\t.name = \"udl\",\n\t.probe = udl_usb_probe,\n\t.disconnect = udl_usb_disconnect,\n\t.suspend = udl_usb_suspend,\n\t.resume = udl_usb_resume,\n\t.reset_resume = udl_usb_reset_resume,\n\t.id_table = id_table,\n};\nmodule_usb_driver(udl_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}