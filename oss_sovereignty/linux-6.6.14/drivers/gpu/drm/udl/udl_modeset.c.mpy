{
  "module_name": "udl_modeset.c",
  "hash_id": "e097eb0a71fe769905aea889a1d95c23d0d4aa6f8feeb42aeab80cb66f0b095f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/udl/udl_modeset.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"udl_drv.h\"\n#include \"udl_proto.h\"\n\n \nstatic char *udl_set_register(char *buf, u8 reg, u8 val)\n{\n\t*buf++ = UDL_MSG_BULK;\n\t*buf++ = UDL_CMD_WRITEREG;\n\t*buf++ = reg;\n\t*buf++ = val;\n\n\treturn buf;\n}\n\nstatic char *udl_vidreg_lock(char *buf)\n{\n\treturn udl_set_register(buf, UDL_REG_VIDREG, UDL_VIDREG_LOCK);\n}\n\nstatic char *udl_vidreg_unlock(char *buf)\n{\n\treturn udl_set_register(buf, UDL_REG_VIDREG, UDL_VIDREG_UNLOCK);\n}\n\nstatic char *udl_set_blank_mode(char *buf, u8 mode)\n{\n\treturn udl_set_register(buf, UDL_REG_BLANKMODE, mode);\n}\n\nstatic char *udl_set_color_depth(char *buf, u8 selection)\n{\n\treturn udl_set_register(buf, UDL_REG_COLORDEPTH, selection);\n}\n\nstatic char *udl_set_base16bpp(char *buf, u32 base)\n{\n\t \n\tu8 reg20 = FIELD_GET(UDL_BASE_ADDR2_MASK, base);\n\tu8 reg21 = FIELD_GET(UDL_BASE_ADDR1_MASK, base);\n\tu8 reg22 = FIELD_GET(UDL_BASE_ADDR0_MASK, base);\n\n\tbuf = udl_set_register(buf, UDL_REG_BASE16BPP_ADDR2, reg20);\n\tbuf = udl_set_register(buf, UDL_REG_BASE16BPP_ADDR1, reg21);\n\tbuf = udl_set_register(buf, UDL_REG_BASE16BPP_ADDR0, reg22);\n\n\treturn buf;\n}\n\n \nstatic char *udl_set_base8bpp(char *buf, u32 base)\n{\n\t \n\tu8 reg26 = FIELD_GET(UDL_BASE_ADDR2_MASK, base);\n\tu8 reg27 = FIELD_GET(UDL_BASE_ADDR1_MASK, base);\n\tu8 reg28 = FIELD_GET(UDL_BASE_ADDR0_MASK, base);\n\n\tbuf = udl_set_register(buf, UDL_REG_BASE8BPP_ADDR2, reg26);\n\tbuf = udl_set_register(buf, UDL_REG_BASE8BPP_ADDR1, reg27);\n\tbuf = udl_set_register(buf, UDL_REG_BASE8BPP_ADDR0, reg28);\n\n\treturn buf;\n}\n\nstatic char *udl_set_register_16(char *wrptr, u8 reg, u16 value)\n{\n\twrptr = udl_set_register(wrptr, reg, value >> 8);\n\treturn udl_set_register(wrptr, reg+1, value);\n}\n\n \nstatic char *udl_set_register_16be(char *wrptr, u8 reg, u16 value)\n{\n\twrptr = udl_set_register(wrptr, reg, value);\n\treturn udl_set_register(wrptr, reg+1, value >> 8);\n}\n\n \nstatic u16 udl_lfsr16(u16 actual_count)\n{\n\tu32 lv = 0xFFFF;  \n\n\twhile (actual_count--) {\n\t\tlv =\t ((lv << 1) |\n\t\t\t(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))\n\t\t\t& 0xFFFF;\n\t}\n\n\treturn (u16) lv;\n}\n\n \nstatic char *udl_set_register_lfsr16(char *wrptr, u8 reg, u16 value)\n{\n\treturn udl_set_register_16(wrptr, reg, udl_lfsr16(value));\n}\n\n \nstatic char *udl_set_display_mode(char *buf, struct drm_display_mode *mode)\n{\n\tu16 reg01 = mode->crtc_htotal - mode->crtc_hsync_start;\n\tu16 reg03 = reg01 + mode->crtc_hdisplay;\n\tu16 reg05 = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tu16 reg07 = reg05 + mode->crtc_vdisplay;\n\tu16 reg09 = mode->crtc_htotal - 1;\n\tu16 reg0b = 1;  \n\tu16 reg0d = mode->crtc_hsync_end - mode->crtc_hsync_start + 1;\n\tu16 reg0f = mode->hdisplay;\n\tu16 reg11 = mode->crtc_vtotal;\n\tu16 reg13 = 0;  \n\tu16 reg15 = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tu16 reg17 = mode->crtc_vdisplay;\n\tu16 reg1b = mode->clock / 5;\n\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_XDISPLAYSTART, reg01);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_XDISPLAYEND, reg03);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_YDISPLAYSTART, reg05);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_YDISPLAYEND, reg07);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_XENDCOUNT, reg09);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_HSYNCSTART, reg0b);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_HSYNCEND, reg0d);\n\tbuf = udl_set_register_16(buf, UDL_REG_HPIXELS, reg0f);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_YENDCOUNT, reg11);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_VSYNCSTART, reg13);\n\tbuf = udl_set_register_lfsr16(buf, UDL_REG_VSYNCEND, reg15);\n\tbuf = udl_set_register_16(buf, UDL_REG_VPIXELS, reg17);\n\tbuf = udl_set_register_16be(buf, UDL_REG_PIXELCLOCK5KHZ, reg1b);\n\n\treturn buf;\n}\n\nstatic char *udl_dummy_render(char *wrptr)\n{\n\t*wrptr++ = UDL_MSG_BULK;\n\t*wrptr++ = UDL_CMD_WRITECOPY16;\n\t*wrptr++ = 0x00;  \n\t*wrptr++ = 0x00;\n\t*wrptr++ = 0x00;\n\t*wrptr++ = 0x01;  \n\t*wrptr++ = 0x00;  \n\t*wrptr++ = 0x00;\n\t*wrptr++ = 0x00;\n\treturn wrptr;\n}\n\nstatic long udl_log_cpp(unsigned int cpp)\n{\n\tif (WARN_ON(!is_power_of_2(cpp)))\n\t\treturn -EINVAL;\n\treturn __ffs(cpp);\n}\n\nstatic int udl_handle_damage(struct drm_framebuffer *fb,\n\t\t\t     const struct iosys_map *map,\n\t\t\t     const struct drm_rect *clip)\n{\n\tstruct drm_device *dev = fb->dev;\n\tvoid *vaddr = map->vaddr;  \n\tint i, ret;\n\tchar *cmd;\n\tstruct urb *urb;\n\tint log_bpp;\n\n\tret = udl_log_cpp(fb->format->cpp[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\tlog_bpp = ret;\n\n\turb = udl_get_urb(dev);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tcmd = urb->transfer_buffer;\n\n\tfor (i = clip->y1; i < clip->y2; i++) {\n\t\tconst int line_offset = fb->pitches[0] * i;\n\t\tconst int byte_offset = line_offset + (clip->x1 << log_bpp);\n\t\tconst int dev_byte_offset = (fb->width * i + clip->x1) << log_bpp;\n\t\tconst int byte_width = drm_rect_width(clip) << log_bpp;\n\t\tret = udl_render_hline(dev, log_bpp, &urb, (char *)vaddr,\n\t\t\t\t       &cmd, byte_offset, dev_byte_offset,\n\t\t\t\t       byte_width);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cmd > (char *)urb->transfer_buffer) {\n\t\t \n\t\tint len;\n\t\tif (cmd < (char *)urb->transfer_buffer + urb->transfer_buffer_length)\n\t\t\t*cmd++ = UDL_MSG_BULK;\n\t\tlen = cmd - (char *)urb->transfer_buffer;\n\t\tret = udl_submit_urb(dev, urb, len);\n\t} else {\n\t\tudl_urb_completion(urb);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const uint32_t udl_primary_plane_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const uint64_t udl_primary_plane_fmtmods[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic void udl_primary_plane_helper_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_plane_state *plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(plane_state);\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_atomic_helper_damage_iter iter;\n\tstruct drm_rect damage;\n\tint ret, idx;\n\n\tif (!fb)\n\t\treturn;  \n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\tgoto out_drm_gem_fb_end_cpu_access;\n\n\tdrm_atomic_helper_damage_iter_init(&iter, old_plane_state, plane_state);\n\tdrm_atomic_for_each_plane_damage(&iter, &damage) {\n\t\tudl_handle_damage(fb, &shadow_plane_state->data[0], &damage);\n\t}\n\n\tdrm_dev_exit(idx);\n\nout_drm_gem_fb_end_cpu_access:\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n}\n\nstatic const struct drm_plane_helper_funcs udl_primary_plane_helper_funcs = {\n\tDRM_GEM_SHADOW_PLANE_HELPER_FUNCS,\n\t.atomic_check = drm_plane_helper_atomic_check,\n\t.atomic_update = udl_primary_plane_helper_atomic_update,\n};\n\nstatic const struct drm_plane_funcs udl_primary_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\tDRM_GEM_SHADOW_PLANE_FUNCS,\n};\n\n \n\nstatic void udl_crtc_helper_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\tstruct urb *urb;\n\tchar *buf;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\turb = udl_get_urb(dev);\n\tif (!urb)\n\t\tgoto out;\n\n\tbuf = (char *)urb->transfer_buffer;\n\tbuf = udl_vidreg_lock(buf);\n\tbuf = udl_set_color_depth(buf, UDL_COLORDEPTH_16BPP);\n\t \n\tbuf = udl_set_base16bpp(buf, 0);\n\t \n\tbuf = udl_set_base8bpp(buf, 2 * mode->vdisplay * mode->hdisplay);\n\tbuf = udl_set_display_mode(buf, mode);\n\tbuf = udl_set_blank_mode(buf, UDL_BLANKMODE_ON);\n\tbuf = udl_vidreg_unlock(buf);\n\tbuf = udl_dummy_render(buf);\n\n\tudl_submit_urb(dev, urb, buf - (char *)urb->transfer_buffer);\n\nout:\n\tdrm_dev_exit(idx);\n}\n\nstatic void udl_crtc_helper_atomic_disable(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct urb *urb;\n\tchar *buf;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\turb = udl_get_urb(dev);\n\tif (!urb)\n\t\tgoto out;\n\n\tbuf = (char *)urb->transfer_buffer;\n\tbuf = udl_vidreg_lock(buf);\n\tbuf = udl_set_blank_mode(buf, UDL_BLANKMODE_POWERDOWN);\n\tbuf = udl_vidreg_unlock(buf);\n\tbuf = udl_dummy_render(buf);\n\n\tudl_submit_urb(dev, urb, buf - (char *)urb->transfer_buffer);\n\nout:\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_crtc_helper_funcs udl_crtc_helper_funcs = {\n\t.atomic_check = drm_crtc_helper_atomic_check,\n\t.atomic_enable = udl_crtc_helper_atomic_enable,\n\t.atomic_disable = udl_crtc_helper_atomic_disable,\n};\n\nstatic const struct drm_crtc_funcs udl_crtc_funcs = {\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n};\n\n \n\nstatic const struct drm_encoder_funcs udl_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\n \n\nstatic int udl_connector_helper_get_modes(struct drm_connector *connector)\n{\n\tstruct udl_connector *udl_connector = to_udl_connector(connector);\n\n\tdrm_connector_update_edid_property(connector, udl_connector->edid);\n\tif (udl_connector->edid)\n\t\treturn drm_add_edid_modes(connector, udl_connector->edid);\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs udl_connector_helper_funcs = {\n\t.get_modes = udl_connector_helper_get_modes,\n};\n\nstatic int udl_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct udl_device *udl = data;\n\tstruct drm_device *dev = &udl->drm;\n\tstruct usb_device *udev = udl_to_usb_device(udl);\n\tu8 *read_buff;\n\tint ret;\n\tsize_t i;\n\n\tread_buff = kmalloc(2, GFP_KERNEL);\n\tif (!read_buff)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < len; i++) {\n\t\tint bval = (i + block * EDID_LENGTH) << 8;\n\n\t\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t      0x02, (0x80 | (0x02 << 5)), bval,\n\t\t\t\t      0xA1, read_buff, 2, USB_CTRL_GET_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\tdrm_err(dev, \"Read EDID byte %zu failed err %x\\n\", i, ret);\n\t\t\tgoto err_kfree;\n\t\t} else if (ret < 1) {\n\t\t\tret = -EIO;\n\t\t\tdrm_err(dev, \"Read EDID byte %zu failed\\n\", i);\n\t\t\tgoto err_kfree;\n\t\t}\n\n\t\tbuf[i] = read_buff[1];\n\t}\n\n\tkfree(read_buff);\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(read_buff);\n\treturn ret;\n}\n\nstatic enum drm_connector_status udl_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct udl_device *udl = to_udl(dev);\n\tstruct udl_connector *udl_connector = to_udl_connector(connector);\n\tenum drm_connector_status status = connector_status_disconnected;\n\tint idx;\n\n\t \n\tkfree(udl_connector->edid);\n\tudl_connector->edid = NULL;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn connector_status_disconnected;\n\n\tudl_connector->edid = drm_do_get_edid(connector, udl_get_edid_block, udl);\n\tif (udl_connector->edid)\n\t\tstatus = connector_status_connected;\n\n\tdrm_dev_exit(idx);\n\n\treturn status;\n}\n\nstatic void udl_connector_destroy(struct drm_connector *connector)\n{\n\tstruct udl_connector *udl_connector = to_udl_connector(connector);\n\n\tdrm_connector_cleanup(connector);\n\tkfree(udl_connector->edid);\n\tkfree(udl_connector);\n}\n\nstatic const struct drm_connector_funcs udl_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.detect = udl_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = udl_connector_destroy,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstruct drm_connector *udl_connector_init(struct drm_device *dev)\n{\n\tstruct udl_connector *udl_connector;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tudl_connector = kzalloc(sizeof(*udl_connector), GFP_KERNEL);\n\tif (!udl_connector)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconnector = &udl_connector->connector;\n\tret = drm_connector_init(dev, connector, &udl_connector_funcs, DRM_MODE_CONNECTOR_VGA);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tdrm_connector_helper_add(connector, &udl_connector_helper_funcs);\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD |\n\t\t\t    DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t    DRM_CONNECTOR_POLL_DISCONNECT;\n\n\treturn connector;\n\nerr_kfree:\n\tkfree(udl_connector);\n\treturn ERR_PTR(ret);\n}\n\n \n\nstatic enum drm_mode_status udl_mode_config_mode_valid(struct drm_device *dev,\n\t\t\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\n\tif (udl->sku_pixel_limit) {\n\t\tif (mode->vdisplay * mode->hdisplay > udl->sku_pixel_limit)\n\t\t\treturn MODE_MEM;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs udl_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.mode_valid = udl_mode_config_mode_valid,\n\t.atomic_check  = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nint udl_modeset_init(struct drm_device *dev)\n{\n\tstruct udl_device *udl = to_udl(dev);\n\tstruct drm_plane *primary_plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.min_width = 640;\n\tdev->mode_config.min_height = 480;\n\tdev->mode_config.max_width = 2048;\n\tdev->mode_config.max_height = 2048;\n\tdev->mode_config.preferred_depth = 16;\n\tdev->mode_config.funcs = &udl_mode_config_funcs;\n\n\tprimary_plane = &udl->primary_plane;\n\tret = drm_universal_plane_init(dev, primary_plane, 0,\n\t\t\t\t       &udl_primary_plane_funcs,\n\t\t\t\t       udl_primary_plane_formats,\n\t\t\t\t       ARRAY_SIZE(udl_primary_plane_formats),\n\t\t\t\t       udl_primary_plane_fmtmods,\n\t\t\t\t       DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdrm_plane_helper_add(primary_plane, &udl_primary_plane_helper_funcs);\n\tdrm_plane_enable_fb_damage_clips(primary_plane);\n\n\tcrtc = &udl->crtc;\n\tret = drm_crtc_init_with_planes(dev, crtc, primary_plane, NULL,\n\t\t\t\t\t&udl_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdrm_crtc_helper_add(crtc, &udl_crtc_helper_funcs);\n\n\tencoder = &udl->encoder;\n\tret = drm_encoder_init(dev, encoder, &udl_encoder_funcs, DRM_MODE_ENCODER_DAC, NULL);\n\tif (ret)\n\t\treturn ret;\n\tencoder->possible_crtcs = drm_crtc_mask(crtc);\n\n\tconnector = udl_connector_init(dev);\n\tif (IS_ERR(connector))\n\t\treturn PTR_ERR(connector);\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}