{
  "module_name": "meson_plane.c",
  "hash_id": "00d291fed1ce6ed6a89a9c760ba75a62659b5b8b36d1c0d609f65c977dad8f1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_plane.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"meson_plane.h\"\n#include \"meson_registers.h\"\n#include \"meson_viu.h\"\n#include \"meson_osd_afbcd.h\"\n\n \n#define SCI_WH_M1_W(w)\t\t\tFIELD_PREP(GENMASK(28, 16), w)\n#define SCI_WH_M1_H(h)\t\t\tFIELD_PREP(GENMASK(12, 0), h)\n\n \n \n#define SCO_HV_START(start)\t\tFIELD_PREP(GENMASK(27, 16), start)\n#define SCO_HV_END(end)\t\t\tFIELD_PREP(GENMASK(11, 0), end)\n\n \n#define SC_CTRL0_PATH_EN\t\tBIT(3)\n#define SC_CTRL0_SEL_OSD1\t\tBIT(2)\n\n \n#define VSC_BANK_LEN(value)\t\tFIELD_PREP(GENMASK(2, 0), value)\n#define VSC_TOP_INI_RCV_NUM(value)\tFIELD_PREP(GENMASK(6, 3), value)\n#define VSC_TOP_RPT_L0_NUM(value)\tFIELD_PREP(GENMASK(9, 8), value)\n#define VSC_BOT_INI_RCV_NUM(value)\tFIELD_PREP(GENMASK(14, 11), value)\n#define VSC_BOT_RPT_L0_NUM(value)\tFIELD_PREP(GENMASK(17, 16), value)\n#define VSC_PROG_INTERLACE\t\tBIT(23)\n#define VSC_VERTICAL_SCALER_EN\t\tBIT(24)\n\n \n#define VSC_INI_PHASE_BOT(bottom)\tFIELD_PREP(GENMASK(31, 16), bottom)\n#define VSC_INI_PHASE_TOP(top)\t\tFIELD_PREP(GENMASK(15, 0), top)\n\n \n#define HSC_BANK_LENGTH(value)\t\tFIELD_PREP(GENMASK(2, 0), value)\n#define HSC_INI_RCV_NUM0(value)\t\tFIELD_PREP(GENMASK(6, 3), value)\n#define HSC_RPT_P0_NUM0(value)\t\tFIELD_PREP(GENMASK(9, 8), value)\n#define HSC_HORIZ_SCALER_EN\t\tBIT(22)\n\n \n \n#define SC_PHASE_STEP(value)\t\tFIELD_PREP(GENMASK(27, 0), value)\n\nstruct meson_plane {\n\tstruct drm_plane base;\n\tstruct meson_drm *priv;\n\tbool enabled;\n};\n#define to_meson_plane(x) container_of(x, struct meson_plane, base)\n\n#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))\n\nstatic int meson_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (!new_plane_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\t \n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   FRAC_16_16(1, 5),\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, true);\n}\n\n#define MESON_MOD_AFBC_VALID_BITS (AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 |\t\\\n\t\t\t\t   AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\t\\\n\t\t\t\t   AFBC_FORMAT_MOD_YTR |\t\t\\\n\t\t\t\t   AFBC_FORMAT_MOD_SPARSE |\t\t\\\n\t\t\t\t   AFBC_FORMAT_MOD_SPLIT)\n\n \nstatic inline int64_t fixed16_to_int(int64_t value)\n{\n\treturn value >> 16;\n}\n\nstatic u32 meson_g12a_afbcd_line_stride(struct meson_drm *priv)\n{\n\tu32 line_stride = 0;\n\n\tswitch (priv->afbcd.format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tline_stride = ((priv->viu.osd1_width << 4) + 127) >> 7;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tline_stride = ((priv->viu.osd1_width << 5) + 127) >> 7;\n\t\tbreak;\n\t}\n\n\treturn ((line_stride + 1) >> 1) << 1;\n}\n\nstatic void meson_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct meson_plane *meson_plane = to_meson_plane(plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_rect dest = drm_plane_state_dest(new_state);\n\tstruct meson_drm *priv = meson_plane->priv;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct drm_gem_dma_object *gem;\n\tunsigned long flags;\n\tint vsc_ini_rcv_num, vsc_ini_rpt_p0_num;\n\tint vsc_bot_rcv_num, vsc_bot_rpt_p0_num;\n\tint hsc_ini_rcv_num, hsc_ini_rpt_p0_num;\n\tint hf_phase_step, vf_phase_step;\n\tint src_w, src_h, dst_w, dst_h;\n\tint bot_ini_phase;\n\tint hf_bank_len;\n\tint vf_bank_len;\n\tu8 canvas_id_osd1;\n\n\t \n\tspin_lock_irqsave(&priv->drm->event_lock, flags);\n\n\t \n\tif ((meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t     meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) &&\n\t    fb->modifier & DRM_FORMAT_MOD_ARM_AFBC(MESON_MOD_AFBC_VALID_BITS))\n\t\tpriv->viu.osd1_afbcd = true;\n\telse\n\t\tpriv->viu.osd1_afbcd = false;\n\n\t \n\tpriv->viu.osd1_ctrl_stat = OSD_ENABLE |\n\t\t\t\t   (0x100 << OSD_GLOBAL_ALPHA_SHIFT) |\n\t\t\t\t   OSD_BLK0_ENABLE;\n\n\tpriv->viu.osd1_ctrl_stat2 = readl(priv->io_base +\n\t\t\t\t\t  _REG(VIU_OSD1_CTRL_STAT2));\n\n\tcanvas_id_osd1 = priv->canvas_id_osd1;\n\n\t \n\tpriv->viu.osd1_blk0_cfg[0] = canvas_id_osd1 << OSD_CANVAS_SEL;\n\n\tif (priv->viu.osd1_afbcd) {\n\t\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\t\t \n\t\t\tpriv->viu.osd1_blk1_cfg4 = MESON_G12A_AFBCD_OUT_ADDR;\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_ENDIANNESS_BE;\n\t\t\tpriv->viu.osd1_ctrl_stat2 |= OSD_PENDING_STAT_CLEAN;\n\t\t\tpriv->viu.osd1_ctrl_stat |= VIU_OSD1_CFG_SYN_EN;\n\t\t}\n\n\t\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM)) {\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_ENDIANNESS_LE;\n\t\t\tpriv->viu.osd1_ctrl_stat2 |= OSD_DPATH_MALI_AFBCD;\n\t\t}\n\t} else {\n\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_ENDIANNESS_LE;\n\n\t\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM))\n\t\t\tpriv->viu.osd1_ctrl_stat2 &= ~OSD_DPATH_MALI_AFBCD;\n\t}\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))\n\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;\n\n\tif (priv->viu.osd1_afbcd &&\n\t    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_MALI_SRC_EN |\n\t\t\tpriv->afbcd.ops->fmt_to_blk_mode(fb->modifier,\n\t\t\t\t\t\t\t  fb->format->format);\n\t} else {\n\t\tswitch (fb->format->format) {\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_32 |\n\t\t\t\t\t\tOSD_COLOR_MATRIX_32_ARGB;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XBGR8888:\n\t\tcase DRM_FORMAT_ABGR8888:\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_32 |\n\t\t\t\t\t\tOSD_COLOR_MATRIX_32_ABGR;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_24 |\n\t\t\t\t\t\tOSD_COLOR_MATRIX_24_RGB;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tpriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_16 |\n\t\t\t\t\t\tOSD_COLOR_MATRIX_16_RGB565;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\t\t \n\t\tpriv->viu.osd1_ctrl_stat2 |= OSD_REPLACE_EN;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\t \n\t\tpriv->viu.osd1_ctrl_stat2 &= ~OSD_REPLACE_EN;\n\t\tbreak;\n\t}\n\n\t \n\tvsc_bot_rcv_num = 0;\n\tvsc_bot_rpt_p0_num = 0;\n\thf_bank_len = 4;\n\tvf_bank_len = 4;\n\n\tif (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tvsc_bot_rcv_num = 6;\n\t\tvsc_bot_rpt_p0_num = 2;\n\t}\n\n\thsc_ini_rcv_num = hf_bank_len;\n\tvsc_ini_rcv_num = vf_bank_len;\n\thsc_ini_rpt_p0_num = (hf_bank_len / 2) - 1;\n\tvsc_ini_rpt_p0_num = (vf_bank_len / 2) - 1;\n\n\tsrc_w = fixed16_to_int(new_state->src_w);\n\tsrc_h = fixed16_to_int(new_state->src_h);\n\tdst_w = new_state->crtc_w;\n\tdst_h = new_state->crtc_h;\n\n\t \n\tif (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tdest.y1 /= 2;\n\t\tdest.y2 /= 2;\n\t\tdst_h /= 2;\n\t}\n\n\thf_phase_step = ((src_w << 18) / dst_w) << 6;\n\tvf_phase_step = (src_h << 20) / dst_h;\n\n\tif (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tbot_ini_phase = ((vf_phase_step / 2) >> 4);\n\telse\n\t\tbot_ini_phase = 0;\n\n\tvf_phase_step = (vf_phase_step << 4);\n\n\t \n\tif (src_h != dst_h || src_w != dst_w) {\n\t\tpriv->viu.osd_sc_i_wh_m1 = SCI_WH_M1_W(src_w - 1) |\n\t\t\t\t\t   SCI_WH_M1_H(src_h - 1);\n\t\tpriv->viu.osd_sc_o_h_start_end = SCO_HV_START(dest.x1) |\n\t\t\t\t\t\t SCO_HV_END(dest.x2 - 1);\n\t\tpriv->viu.osd_sc_o_v_start_end = SCO_HV_START(dest.y1) |\n\t\t\t\t\t\t SCO_HV_END(dest.y2 - 1);\n\t\t \n\t\tpriv->viu.osd_sc_ctrl0 = SC_CTRL0_PATH_EN | SC_CTRL0_SEL_OSD1;\n\t} else {\n\t\tpriv->viu.osd_sc_i_wh_m1 = 0;\n\t\tpriv->viu.osd_sc_o_h_start_end = 0;\n\t\tpriv->viu.osd_sc_o_v_start_end = 0;\n\t\tpriv->viu.osd_sc_ctrl0 = 0;\n\t}\n\n\t \n\tif (src_h != dst_h) {\n\t\tpriv->viu.osd_sc_v_ctrl0 =\n\t\t\t\t\tVSC_BANK_LEN(vf_bank_len) |\n\t\t\t\t\tVSC_TOP_INI_RCV_NUM(vsc_ini_rcv_num) |\n\t\t\t\t\tVSC_TOP_RPT_L0_NUM(vsc_ini_rpt_p0_num) |\n\t\t\t\t\tVSC_VERTICAL_SCALER_EN;\n\n\t\tif (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\tpriv->viu.osd_sc_v_ctrl0 |=\n\t\t\t\t\tVSC_BOT_INI_RCV_NUM(vsc_bot_rcv_num) |\n\t\t\t\t\tVSC_BOT_RPT_L0_NUM(vsc_bot_rpt_p0_num) |\n\t\t\t\t\tVSC_PROG_INTERLACE;\n\n\t\tpriv->viu.osd_sc_v_phase_step = SC_PHASE_STEP(vf_phase_step);\n\t\tpriv->viu.osd_sc_v_ini_phase = VSC_INI_PHASE_BOT(bot_ini_phase);\n\t} else {\n\t\tpriv->viu.osd_sc_v_ctrl0 = 0;\n\t\tpriv->viu.osd_sc_v_phase_step = 0;\n\t\tpriv->viu.osd_sc_v_ini_phase = 0;\n\t}\n\n\t \n\tif (src_w != dst_w) {\n\t\tpriv->viu.osd_sc_h_ctrl0 =\n\t\t\t\t\tHSC_BANK_LENGTH(hf_bank_len) |\n\t\t\t\t\tHSC_INI_RCV_NUM0(hsc_ini_rcv_num) |\n\t\t\t\t\tHSC_RPT_P0_NUM0(hsc_ini_rpt_p0_num) |\n\t\t\t\t\tHSC_HORIZ_SCALER_EN;\n\t\tpriv->viu.osd_sc_h_phase_step = SC_PHASE_STEP(hf_phase_step);\n\t\tpriv->viu.osd_sc_h_ini_phase = 0;\n\t} else {\n\t\tpriv->viu.osd_sc_h_ctrl0 = 0;\n\t\tpriv->viu.osd_sc_h_phase_step = 0;\n\t\tpriv->viu.osd_sc_h_ini_phase = 0;\n\t}\n\n\t \n\tpriv->viu.osd1_blk0_cfg[1] =\n\t\t\t\t((fixed16_to_int(new_state->src.x2) - 1) << 16) |\n\t\t\t\tfixed16_to_int(new_state->src.x1);\n\tpriv->viu.osd1_blk0_cfg[2] =\n\t\t\t\t((fixed16_to_int(new_state->src.y2) - 1) << 16) |\n\t\t\t\tfixed16_to_int(new_state->src.y1);\n\tpriv->viu.osd1_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;\n\tpriv->viu.osd1_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tpriv->viu.osd_blend_din0_scope_h = ((dest.x2 - 1) << 16) | dest.x1;\n\t\tpriv->viu.osd_blend_din0_scope_v = ((dest.y2 - 1) << 16) | dest.y1;\n\t\tpriv->viu.osb_blend0_size = dst_h << 16 | dst_w;\n\t\tpriv->viu.osb_blend1_size = dst_h << 16 | dst_w;\n\t}\n\n\t \n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tpriv->viu.osd1_addr = gem->dma_addr;\n\tpriv->viu.osd1_stride = fb->pitches[0];\n\tpriv->viu.osd1_height = fb->height;\n\tpriv->viu.osd1_width = fb->width;\n\n\tif (priv->viu.osd1_afbcd) {\n\t\tpriv->afbcd.modifier = fb->modifier;\n\t\tpriv->afbcd.format = fb->format->format;\n\n\t\t \n\t\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\t\tpriv->viu.osd1_blk2_cfg4 =\n\t\t\t\tmeson_g12a_afbcd_line_stride(priv);\n\t}\n\n\tif (!meson_plane->enabled) {\n\t\t \n\t\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))\n\t\t\tmeson_viu_osd1_reset(priv);\n\n\t\tmeson_plane->enabled = true;\n\t}\n\n\tpriv->viu.osd1_enabled = true;\n\n\tspin_unlock_irqrestore(&priv->drm->event_lock, flags);\n}\n\nstatic void meson_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct meson_plane *meson_plane = to_meson_plane(plane);\n\tstruct meson_drm *priv = meson_plane->priv;\n\n\tif (priv->afbcd.ops) {\n\t\tpriv->afbcd.ops->reset(priv);\n\t\tpriv->afbcd.ops->disable(priv);\n\t}\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\twritel_bits_relaxed(VIU_OSD1_POSTBLD_SRC_OSD1, 0,\n\t\t\t\t    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));\n\telse\n\t\twritel_bits_relaxed(VPP_OSD1_POSTBLEND, 0,\n\t\t\t\t    priv->io_base + _REG(VPP_MISC));\n\n\tmeson_plane->enabled = false;\n\tpriv->viu.osd1_enabled = false;\n}\n\nstatic const struct drm_plane_helper_funcs meson_plane_helper_funcs = {\n\t.atomic_check\t= meson_plane_atomic_check,\n\t.atomic_disable\t= meson_plane_atomic_disable,\n\t.atomic_update\t= meson_plane_atomic_update,\n};\n\nstatic bool meson_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t     u32 format, u64 modifier)\n{\n\tstruct meson_plane *meson_plane = to_meson_plane(plane);\n\tstruct meson_drm *priv = meson_plane->priv;\n\tint i;\n\n\tif (modifier == DRM_FORMAT_MOD_INVALID)\n\t\treturn false;\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\tif (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) &&\n\t    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\treturn false;\n\n\tif (modifier & ~DRM_FORMAT_MOD_ARM_AFBC(MESON_MOD_AFBC_VALID_BITS))\n\t\treturn false;\n\n\tfor (i = 0 ; i < plane->modifier_count ; ++i)\n\t\tif (plane->modifiers[i] == modifier)\n\t\t\tbreak;\n\n\tif (i == plane->modifier_count) {\n\t\tDRM_DEBUG_KMS(\"Unsupported modifier\\n\");\n\t\treturn false;\n\t}\n\n\tif (priv->afbcd.ops && priv->afbcd.ops->supported_fmt)\n\t\treturn priv->afbcd.ops->supported_fmt(modifier, format);\n\n\tDRM_DEBUG_KMS(\"AFBC Unsupported\\n\");\n\treturn false;\n}\n\nstatic const struct drm_plane_funcs meson_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\t.format_mod_supported   = meson_plane_format_mod_supported,\n};\n\nstatic const uint32_t supported_drm_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGB565,\n};\n\nstatic const uint64_t format_modifiers_afbc_gxm[] = {\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_YTR),\n\t \n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 |\n\t\t\t\tAFBC_FORMAT_MOD_YTR |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nstatic const uint64_t format_modifiers_afbc_g12a[] = {\n\t \n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT),\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 |\n\t\t\t\tAFBC_FORMAT_MOD_YTR |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT),\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE),\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_YTR |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE),\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT),\n\tDRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8 |\n\t\t\t\tAFBC_FORMAT_MOD_YTR |\n\t\t\t\tAFBC_FORMAT_MOD_SPARSE |\n\t\t\t\tAFBC_FORMAT_MOD_SPLIT),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nstatic const uint64_t format_modifiers_default[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nint meson_plane_create(struct meson_drm *priv)\n{\n\tstruct meson_plane *meson_plane;\n\tstruct drm_plane *plane;\n\tconst uint64_t *format_modifiers = format_modifiers_default;\n\n\tmeson_plane = devm_kzalloc(priv->drm->dev, sizeof(*meson_plane),\n\t\t\t\t   GFP_KERNEL);\n\tif (!meson_plane)\n\t\treturn -ENOMEM;\n\n\tmeson_plane->priv = priv;\n\tplane = &meson_plane->base;\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM))\n\t\tformat_modifiers = format_modifiers_afbc_gxm;\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tformat_modifiers = format_modifiers_afbc_g12a;\n\n\tdrm_universal_plane_init(priv->drm, plane, 0xFF,\n\t\t\t\t &meson_plane_funcs,\n\t\t\t\t supported_drm_formats,\n\t\t\t\t ARRAY_SIZE(supported_drm_formats),\n\t\t\t\t format_modifiers,\n\t\t\t\t DRM_PLANE_TYPE_PRIMARY, \"meson_primary_plane\");\n\n\tdrm_plane_helper_add(plane, &meson_plane_helper_funcs);\n\n\t \n\tdrm_plane_create_zpos_immutable_property(plane, 1);\n\n\tpriv->primary_plane = plane;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}