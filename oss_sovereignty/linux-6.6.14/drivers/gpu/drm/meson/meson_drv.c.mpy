{
  "module_name": "meson_drv.c",
  "hash_id": "ba2f154b69db8e5d9001204c3f31f56122310a23cf641c17b1426249fe9787d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/sys_soc.h>\n#include <linux/platform_device.h>\n#include <linux/soc/amlogic/meson-canvas.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"meson_crtc.h\"\n#include \"meson_drv.h\"\n#include \"meson_overlay.h\"\n#include \"meson_plane.h\"\n#include \"meson_osd_afbcd.h\"\n#include \"meson_registers.h\"\n#include \"meson_encoder_cvbs.h\"\n#include \"meson_encoder_hdmi.h\"\n#include \"meson_encoder_dsi.h\"\n#include \"meson_viu.h\"\n#include \"meson_vpp.h\"\n#include \"meson_rdma.h\"\n\n#define DRIVER_NAME \"meson\"\n#define DRIVER_DESC \"Amlogic Meson DRM driver\"\n\n \n\nstatic const struct drm_mode_config_funcs meson_mode_config_funcs = {\n\t.atomic_check        = drm_atomic_helper_check,\n\t.atomic_commit       = drm_atomic_helper_commit,\n\t.fb_create           = drm_gem_fb_create,\n};\n\nstatic const struct drm_mode_config_helper_funcs meson_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,\n};\n\nstatic irqreturn_t meson_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct meson_drm *priv = dev->dev_private;\n\n\t(void)readl_relaxed(priv->io_base + _REG(VENC_INTFLAG));\n\n\tmeson_crtc_irq(priv);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int meson_dumb_create(struct drm_file *file, struct drm_device *dev,\n\t\t\t     struct drm_mode_create_dumb *args)\n{\n\t \n\targs->pitch = ALIGN(DIV_ROUND_UP(args->width * args->bpp, 8), SZ_64);\n\targs->size = PAGE_ALIGN(args->pitch * args->height);\n\n\treturn drm_gem_dma_dumb_create_internal(file, dev, args);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver meson_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\n\t \n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(meson_dumb_create),\n\n\t \n\t.fops\t\t\t= &fops,\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= \"20161109\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic bool meson_vpu_has_available_connectors(struct device *dev)\n{\n\tstruct device_node *ep, *remote;\n\n\t \n\tfor_each_endpoint_of_node(dev->of_node, ep) {\n\t\t \n\t\tremote = of_graph_get_remote_port(ep);\n\t\tif (remote) {\n\t\t\tof_node_put(remote);\n\t\t\tof_node_put(ep);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct regmap_config meson_regmap_config = {\n\t.reg_bits       = 32,\n\t.val_bits       = 32,\n\t.reg_stride     = 4,\n\t.max_register   = 0x1000,\n};\n\nstatic void meson_vpu_init(struct meson_drm *priv)\n{\n\tu32 value;\n\n\t \n\tvalue = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1) |\n\t\tVPU_RDARB_SLAVE_TO_MASTER_PORT(5, 1);\n\twritel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C1));\n\n\t \n\tvalue = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1);\n\twritel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C2));\n\n\t \n\tvalue = VPU_RDARB_SLAVE_TO_MASTER_PORT(4, 1) |\n\t\tVPU_RDARB_SLAVE_TO_MASTER_PORT(7, 1);\n\twritel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L2C1));\n\n\t \n\tvalue = VPU_RDARB_SLAVE_TO_MASTER_PORT(1, 1);\n\twritel_relaxed(value, priv->io_base + _REG(VPU_WRARB_MODE_L2C1));\n}\n\nstruct meson_drm_soc_attr {\n\tstruct meson_drm_soc_limits limits;\n\tconst struct soc_device_attribute *attrs;\n};\n\nstatic const struct meson_drm_soc_attr meson_drm_soc_attrs[] = {\n\t \n\t{\n\t\t.limits = {\n\t\t\t.max_hdmi_phy_freq = 1650000,\n\t\t},\n\t\t.attrs = (const struct soc_device_attribute []) {\n\t\t\t{ .soc_id = \"GXL (S805*)\", },\n\t\t\t{   }\n\t\t}\n\t},\n};\n\nstatic int meson_drv_bind_master(struct device *dev, bool has_components)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct meson_drm_match_data *match;\n\tstruct meson_drm *priv;\n\tstruct drm_device *drm;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint ret, i;\n\n\t \n\tif (!meson_vpu_has_available_connectors(dev)) {\n\t\tdev_err(dev, \"No output connector available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_device_get_match_data(dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tdrm = drm_dev_alloc(&meson_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto free_drm;\n\t}\n\tdrm->dev_private = priv;\n\tpriv->drm = drm;\n\tpriv->dev = dev;\n\tpriv->compat = match->compat;\n\tpriv->afbcd.ops = match->afbcd_ops;\n\n\tregs = devm_platform_ioremap_resource_byname(pdev, \"vpu\");\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\tgoto free_drm;\n\t}\n\n\tpriv->io_base = regs;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hhi\");\n\tif (!res) {\n\t\tret = -EINVAL;\n\t\tgoto free_drm;\n\t}\n\t \n\tregs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!regs) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto free_drm;\n\t}\n\n\tpriv->hhi = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t  &meson_regmap_config);\n\tif (IS_ERR(priv->hhi)) {\n\t\tdev_err(&pdev->dev, \"Couldn't create the HHI regmap\\n\");\n\t\tret = PTR_ERR(priv->hhi);\n\t\tgoto free_drm;\n\t}\n\n\tpriv->canvas = meson_canvas_get(dev);\n\tif (IS_ERR(priv->canvas)) {\n\t\tret = PTR_ERR(priv->canvas);\n\t\tgoto free_drm;\n\t}\n\n\tret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd1);\n\tif (ret)\n\t\tgoto free_drm;\n\tret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_0);\n\tif (ret) {\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_osd1);\n\t\tgoto free_drm;\n\t}\n\tret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_1);\n\tif (ret) {\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_osd1);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_0);\n\t\tgoto free_drm;\n\t}\n\tret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_2);\n\tif (ret) {\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_osd1);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_0);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_1);\n\t\tgoto free_drm;\n\t}\n\n\tpriv->vsync_irq = platform_get_irq(pdev, 0);\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret)\n\t\tgoto free_drm;\n\n\t \n\tfor (i = 0 ; i < ARRAY_SIZE(meson_drm_soc_attrs) ; ++i) {\n\t\tif (soc_device_match(meson_drm_soc_attrs[i].attrs)) {\n\t\t\tpriv->limits = &meson_drm_soc_attrs[i].limits;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tret = drm_aperture_remove_framebuffers(&meson_driver);\n\tif (ret)\n\t\tgoto free_drm;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\tgoto free_drm;\n\tdrm->mode_config.max_width = 3840;\n\tdrm->mode_config.max_height = 2160;\n\tdrm->mode_config.funcs = &meson_mode_config_funcs;\n\tdrm->mode_config.helper_private\t= &meson_mode_config_helpers;\n\n\t \n\n\tmeson_vpu_init(priv);\n\tmeson_venc_init(priv);\n\tmeson_vpp_init(priv);\n\tmeson_viu_init(priv);\n\tif (priv->afbcd.ops) {\n\t\tret = priv->afbcd.ops->init(priv);\n\t\tif (ret)\n\t\t\tgoto free_drm;\n\t}\n\n\t \n\n\tret = meson_encoder_cvbs_init(priv);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tif (has_components) {\n\t\tret = component_bind_all(dev, drm);\n\t\tif (ret) {\n\t\t\tdev_err(drm->dev, \"Couldn't bind all components\\n\");\n\t\t\t \n\t\t\thas_components = false;\n\t\t\tgoto exit_afbcd;\n\t\t}\n\t}\n\n\tret = meson_encoder_hdmi_init(priv);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tret = meson_encoder_dsi_init(priv);\n\t\tif (ret)\n\t\t\tgoto exit_afbcd;\n\t}\n\n\tret = meson_plane_create(priv);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tret = meson_overlay_create(priv);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tret = meson_crtc_create(priv);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tret = request_irq(priv->vsync_irq, meson_irq, 0, drm->driver->name, drm);\n\tif (ret)\n\t\tgoto exit_afbcd;\n\n\tdrm_mode_config_reset(drm);\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto uninstall_irq;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nuninstall_irq:\n\tfree_irq(priv->vsync_irq, drm);\nexit_afbcd:\n\tif (priv->afbcd.ops)\n\t\tpriv->afbcd.ops->exit(priv);\nfree_drm:\n\tdrm_dev_put(drm);\n\n\tmeson_encoder_dsi_remove(priv);\n\tmeson_encoder_hdmi_remove(priv);\n\tmeson_encoder_cvbs_remove(priv);\n\n\tif (has_components)\n\t\tcomponent_unbind_all(dev, drm);\n\n\treturn ret;\n}\n\nstatic int meson_drv_bind(struct device *dev)\n{\n\treturn meson_drv_bind_master(dev, true);\n}\n\nstatic void meson_drv_unbind(struct device *dev)\n{\n\tstruct meson_drm *priv = dev_get_drvdata(dev);\n\tstruct drm_device *drm = priv->drm;\n\n\tif (priv->canvas) {\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_osd1);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_0);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_1);\n\t\tmeson_canvas_free(priv->canvas, priv->canvas_id_vd1_2);\n\t}\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tfree_irq(priv->vsync_irq, drm);\n\tdrm_dev_put(drm);\n\n\tmeson_encoder_dsi_remove(priv);\n\tmeson_encoder_hdmi_remove(priv);\n\tmeson_encoder_cvbs_remove(priv);\n\n\tcomponent_unbind_all(dev, drm);\n\n\tif (priv->afbcd.ops)\n\t\tpriv->afbcd.ops->exit(priv);\n}\n\nstatic const struct component_master_ops meson_drv_master_ops = {\n\t.bind\t= meson_drv_bind,\n\t.unbind\t= meson_drv_unbind,\n};\n\nstatic int __maybe_unused meson_drv_pm_suspend(struct device *dev)\n{\n\tstruct meson_drm *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn 0;\n\n\treturn drm_mode_config_helper_suspend(priv->drm);\n}\n\nstatic int __maybe_unused meson_drv_pm_resume(struct device *dev)\n{\n\tstruct meson_drm *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn 0;\n\n\tmeson_vpu_init(priv);\n\tmeson_venc_init(priv);\n\tmeson_vpp_init(priv);\n\tmeson_viu_init(priv);\n\tif (priv->afbcd.ops)\n\t\tpriv->afbcd.ops->init(priv);\n\n\treturn drm_mode_config_helper_resume(priv->drm);\n}\n\nstatic void meson_drv_shutdown(struct platform_device *pdev)\n{\n\tstruct meson_drm *priv = dev_get_drvdata(&pdev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdrm_kms_helper_poll_fini(priv->drm);\n\tdrm_atomic_helper_shutdown(priv->drm);\n}\n\n \nstatic const struct of_device_id components_dev_match[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-dw-hdmi\" },\n\t{ .compatible = \"amlogic,meson-gxl-dw-hdmi\" },\n\t{ .compatible = \"amlogic,meson-gxm-dw-hdmi\" },\n\t{ .compatible = \"amlogic,meson-g12a-dw-hdmi\" },\n\t{}\n};\n\nstatic int meson_drv_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ep, *remote;\n\tint count = 0;\n\n\tfor_each_endpoint_of_node(np, ep) {\n\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\tif (!remote || !of_device_is_available(remote)) {\n\t\t\tof_node_put(remote);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_match_node(components_dev_match, remote)) {\n\t\t\tcomponent_match_add(&pdev->dev, &match, component_compare_of, remote);\n\n\t\t\tdev_dbg(&pdev->dev, \"parent %pOF remote match add %pOF parent %s\\n\",\n\t\t\t\tnp, remote, dev_name(&pdev->dev));\n\t\t}\n\n\t\tof_node_put(remote);\n\n\t\t++count;\n\t}\n\n\tif (count && !match)\n\t\treturn meson_drv_bind_master(&pdev->dev, false);\n\n\t \n\tif (count) {\n\t\tdev_info(&pdev->dev, \"Queued %d outputs on vpu\\n\", count);\n\n\t\treturn component_master_add_with_match(&pdev->dev,\n\t\t\t\t\t\t       &meson_drv_master_ops,\n\t\t\t\t\t\t       match);\n\t}\n\n\t \n\treturn 0;\n};\n\nstatic void meson_drv_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &meson_drv_master_ops);\n}\n\nstatic struct meson_drm_match_data meson_drm_gxbb_data = {\n\t.compat = VPU_COMPATIBLE_GXBB,\n};\n\nstatic struct meson_drm_match_data meson_drm_gxl_data = {\n\t.compat = VPU_COMPATIBLE_GXL,\n};\n\nstatic struct meson_drm_match_data meson_drm_gxm_data = {\n\t.compat = VPU_COMPATIBLE_GXM,\n\t.afbcd_ops = &meson_afbcd_gxm_ops,\n};\n\nstatic struct meson_drm_match_data meson_drm_g12a_data = {\n\t.compat = VPU_COMPATIBLE_G12A,\n\t.afbcd_ops = &meson_afbcd_g12a_ops,\n};\n\nstatic const struct of_device_id dt_match[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-vpu\",\n\t  .data       = (void *)&meson_drm_gxbb_data },\n\t{ .compatible = \"amlogic,meson-gxl-vpu\",\n\t  .data       = (void *)&meson_drm_gxl_data },\n\t{ .compatible = \"amlogic,meson-gxm-vpu\",\n\t  .data       = (void *)&meson_drm_gxm_data },\n\t{ .compatible = \"amlogic,meson-g12a-vpu\",\n\t  .data       = (void *)&meson_drm_g12a_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dt_match);\n\nstatic const struct dev_pm_ops meson_drv_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(meson_drv_pm_suspend, meson_drv_pm_resume)\n};\n\nstatic struct platform_driver meson_drm_platform_driver = {\n\t.probe      = meson_drv_probe,\n\t.remove_new = meson_drv_remove,\n\t.shutdown   = meson_drv_shutdown,\n\t.driver     = {\n\t\t.name\t= \"meson-drm\",\n\t\t.of_match_table = dt_match,\n\t\t.pm = &meson_drv_pm_ops,\n\t},\n};\n\ndrm_module_platform_driver(meson_drm_platform_driver);\n\nMODULE_AUTHOR(\"Jasper St. Pierre <jstpierre@mecheye.net>\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}