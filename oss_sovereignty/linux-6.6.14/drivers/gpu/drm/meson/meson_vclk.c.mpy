{
  "module_name": "meson_vclk.c",
  "hash_id": "6c44f07831a3299465bb483f378419e98fa229e21ef44ceb4f0a1947a922eaf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_vclk.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n\n#include <drm/drm_print.h>\n\n#include \"meson_drv.h\"\n#include \"meson_vclk.h\"\n\n \n\n \n#define HHI_VID_PLL_CLK_DIV\t0x1a0  \n#define VID_PLL_EN\t\tBIT(19)\n#define VID_PLL_BYPASS\t\tBIT(18)\n#define VID_PLL_PRESET\t\tBIT(15)\n#define HHI_VIID_CLK_DIV\t0x128  \n#define VCLK2_DIV_MASK\t\t0xff\n#define VCLK2_DIV_EN\t\tBIT(16)\n#define VCLK2_DIV_RESET\t\tBIT(17)\n#define CTS_VDAC_SEL_MASK\t(0xf << 28)\n#define CTS_VDAC_SEL_SHIFT\t28\n#define HHI_VIID_CLK_CNTL\t0x12c  \n#define VCLK2_EN\t\tBIT(19)\n#define VCLK2_SEL_MASK\t\t(0x7 << 16)\n#define VCLK2_SEL_SHIFT\t\t16\n#define VCLK2_SOFT_RESET\tBIT(15)\n#define VCLK2_DIV1_EN\t\tBIT(0)\n#define HHI_VID_CLK_DIV\t\t0x164  \n#define VCLK_DIV_MASK\t\t0xff\n#define VCLK_DIV_EN\t\tBIT(16)\n#define VCLK_DIV_RESET\t\tBIT(17)\n#define CTS_ENCP_SEL_MASK\t(0xf << 24)\n#define CTS_ENCP_SEL_SHIFT\t24\n#define CTS_ENCI_SEL_MASK\t(0xf << 28)\n#define CTS_ENCI_SEL_SHIFT\t28\n#define HHI_VID_CLK_CNTL\t0x17c  \n#define VCLK_EN\t\t\tBIT(19)\n#define VCLK_SEL_MASK\t\t(0x7 << 16)\n#define VCLK_SEL_SHIFT\t\t16\n#define VCLK_SOFT_RESET\t\tBIT(15)\n#define VCLK_DIV1_EN\t\tBIT(0)\n#define VCLK_DIV2_EN\t\tBIT(1)\n#define VCLK_DIV4_EN\t\tBIT(2)\n#define VCLK_DIV6_EN\t\tBIT(3)\n#define VCLK_DIV12_EN\t\tBIT(4)\n#define HHI_VID_CLK_CNTL2\t0x194  \n#define CTS_ENCI_EN\t\tBIT(0)\n#define CTS_ENCP_EN\t\tBIT(2)\n#define CTS_VDAC_EN\t\tBIT(4)\n#define HDMI_TX_PIXEL_EN\tBIT(5)\n#define HHI_HDMI_CLK_CNTL\t0x1cc  \n#define HDMI_TX_PIXEL_SEL_MASK\t(0xf << 16)\n#define HDMI_TX_PIXEL_SEL_SHIFT\t16\n#define CTS_HDMI_SYS_SEL_MASK\t(0x7 << 9)\n#define CTS_HDMI_SYS_DIV_MASK\t(0x7f)\n#define CTS_HDMI_SYS_EN\t\tBIT(8)\n\n#define HHI_VDAC_CNTL0\t\t0x2F4  \n#define HHI_VDAC_CNTL1\t\t0x2F8  \n\n#define HHI_HDMI_PLL_CNTL\t0x320  \n#define HHI_HDMI_PLL_CNTL_EN\tBIT(30)\n#define HHI_HDMI_PLL_CNTL2\t0x324  \n#define HHI_HDMI_PLL_CNTL3\t0x328  \n#define HHI_HDMI_PLL_CNTL4\t0x32C  \n#define HHI_HDMI_PLL_CNTL5\t0x330  \n#define HHI_HDMI_PLL_CNTL6\t0x334  \n#define HHI_HDMI_PLL_CNTL7\t0x338  \n\n#define HDMI_PLL_RESET\t\tBIT(28)\n#define HDMI_PLL_RESET_G12A\tBIT(29)\n#define HDMI_PLL_LOCK\t\tBIT(31)\n#define HDMI_PLL_LOCK_G12A\t(3 << 30)\n\n#define FREQ_1000_1001(_freq)\tDIV_ROUND_CLOSEST(_freq * 1000, 1001)\n\n \nenum {\n\tVID_PLL_DIV_1 = 0,\n\tVID_PLL_DIV_2,\n\tVID_PLL_DIV_2p5,\n\tVID_PLL_DIV_3,\n\tVID_PLL_DIV_3p5,\n\tVID_PLL_DIV_3p75,\n\tVID_PLL_DIV_4,\n\tVID_PLL_DIV_5,\n\tVID_PLL_DIV_6,\n\tVID_PLL_DIV_6p25,\n\tVID_PLL_DIV_7,\n\tVID_PLL_DIV_7p5,\n\tVID_PLL_DIV_12,\n\tVID_PLL_DIV_14,\n\tVID_PLL_DIV_15,\n};\n\nstatic void meson_vid_pll_set(struct meson_drm *priv, unsigned int div)\n{\n\tunsigned int shift_val = 0;\n\tunsigned int shift_sel = 0;\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV, VID_PLL_EN, 0);\n\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV, VID_PLL_PRESET, 0);\n\n\tswitch (div) {\n\tcase VID_PLL_DIV_2:\n\t\tshift_val = 0x0aaa;\n\t\tshift_sel = 0;\n\t\tbreak;\n\tcase VID_PLL_DIV_2p5:\n\t\tshift_val = 0x5294;\n\t\tshift_sel = 2;\n\t\tbreak;\n\tcase VID_PLL_DIV_3:\n\t\tshift_val = 0x0db6;\n\t\tshift_sel = 0;\n\t\tbreak;\n\tcase VID_PLL_DIV_3p5:\n\t\tshift_val = 0x36cc;\n\t\tshift_sel = 1;\n\t\tbreak;\n\tcase VID_PLL_DIV_3p75:\n\t\tshift_val = 0x6666;\n\t\tshift_sel = 2;\n\t\tbreak;\n\tcase VID_PLL_DIV_4:\n\t\tshift_val = 0x0ccc;\n\t\tshift_sel = 0;\n\t\tbreak;\n\tcase VID_PLL_DIV_5:\n\t\tshift_val = 0x739c;\n\t\tshift_sel = 2;\n\t\tbreak;\n\tcase VID_PLL_DIV_6:\n\t\tshift_val = 0x0e38;\n\t\tshift_sel = 0;\n\t\tbreak;\n\tcase VID_PLL_DIV_6p25:\n\t\tshift_val = 0x0000;\n\t\tshift_sel = 3;\n\t\tbreak;\n\tcase VID_PLL_DIV_7:\n\t\tshift_val = 0x3c78;\n\t\tshift_sel = 1;\n\t\tbreak;\n\tcase VID_PLL_DIV_7p5:\n\t\tshift_val = 0x78f0;\n\t\tshift_sel = 2;\n\t\tbreak;\n\tcase VID_PLL_DIV_12:\n\t\tshift_val = 0x0fc0;\n\t\tshift_sel = 0;\n\t\tbreak;\n\tcase VID_PLL_DIV_14:\n\t\tshift_val = 0x3f80;\n\t\tshift_sel = 1;\n\t\tbreak;\n\tcase VID_PLL_DIV_15:\n\t\tshift_val = 0x7f80;\n\t\tshift_sel = 2;\n\t\tbreak;\n\t}\n\n\tif (div == VID_PLL_DIV_1)\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   VID_PLL_BYPASS, VID_PLL_BYPASS);\n\telse {\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   VID_PLL_BYPASS, 0);\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   3 << 16, 0);\n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   VID_PLL_PRESET, 0);\n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   0x7fff, 0);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   3 << 16, shift_sel << 16);\n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   VID_PLL_PRESET, VID_PLL_PRESET);\n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   0x7fff, shift_val);\n\n\t\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\t   VID_PLL_PRESET, 0);\n\t}\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_PLL_CLK_DIV,\n\t\t\t\tVID_PLL_EN, VID_PLL_EN);\n}\n\n \nstatic void meson_venci_cvbs_clock_config(struct meson_drm *priv)\n{\n\tunsigned int val;\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x5800023d);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2, 0x00404e00);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0x0d5c5091);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x801da72c);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x71486980);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x00000e55);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x4800023d);\n\n\t\t \n\t\tregmap_read_poll_timeout(priv->hhi, HHI_HDMI_PLL_CNTL, val,\n\t\t\t\t\t (val & HDMI_PLL_LOCK), 10, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t   meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x4000027b);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2, 0x800cb300);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0xa6212844);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x0c4d000c);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x001fa729);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x01a31500);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t\tHDMI_PLL_RESET, HDMI_PLL_RESET);\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t\tHDMI_PLL_RESET, 0);\n\n\t\t \n\t\tregmap_read_poll_timeout(priv->hhi, HHI_HDMI_PLL_CNTL, val,\n\t\t\t\t\t (val & HDMI_PLL_LOCK), 10, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x1a0504f7);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2, 0x00010000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0x00000000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x6a28dc00);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x65771290);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x39272000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL7, 0x56540000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x3a0504f7);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x1a0504f7);\n\n\t\t \n\t\tregmap_read_poll_timeout(priv->hhi, HHI_HDMI_PLL_CNTL, val,\n\t\t\t((val & HDMI_PLL_LOCK_G12A) == HDMI_PLL_LOCK_G12A),\n\t\t\t10, 0);\n\t}\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_EN, 0);\n\n\t \n\tmeson_vid_pll_set(priv, VID_PLL_DIV_1);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV,\n\t\t\t\tVCLK2_DIV_MASK, (55 - 1));\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,\n\t\t\t\t\tVCLK2_SEL_MASK, (0 << VCLK2_SEL_SHIFT));\n\telse\n\t\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,\n\t\t\t\t\tVCLK2_SEL_MASK, (4 << VCLK2_SEL_SHIFT));\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_EN, VCLK2_EN);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCI_SEL_MASK, (8 << CTS_ENCI_SEL_SHIFT));\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV,\n\t\t\t\tCTS_VDAC_SEL_MASK, (8 << CTS_VDAC_SEL_SHIFT));\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV,\n\t\t\t\tVCLK2_DIV_EN | VCLK2_DIV_RESET, VCLK2_DIV_EN);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,\n\t\t\t\tVCLK2_DIV1_EN, VCLK2_DIV1_EN);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,\n\t\t\t\tVCLK2_SOFT_RESET, VCLK2_SOFT_RESET);\n\tregmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,\n\t\t\t\tVCLK2_SOFT_RESET, 0);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2,\n\t\t\t\tCTS_ENCI_EN, CTS_ENCI_EN);\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2,\n\t\t\t\tCTS_VDAC_EN, CTS_VDAC_EN);\n}\n\nenum {\n \n \n\tMESON_VCLK_HDMI_ENCI_54000 = 0,\n \n\tMESON_VCLK_HDMI_DDR_54000,\n \n\tMESON_VCLK_HDMI_DDR_148500,\n \n\tMESON_VCLK_HDMI_74250,\n \n\tMESON_VCLK_HDMI_148500,\n \n\tMESON_VCLK_HDMI_297000,\n \n\tMESON_VCLK_HDMI_594000,\n \n\tMESON_VCLK_HDMI_594000_YUV420,\n};\n\nstruct meson_vclk_params {\n\tunsigned int pll_freq;\n\tunsigned int phy_freq;\n\tunsigned int vclk_freq;\n\tunsigned int venc_freq;\n\tunsigned int pixel_freq;\n\tunsigned int pll_od1;\n\tunsigned int pll_od2;\n\tunsigned int pll_od3;\n\tunsigned int vid_pll_div;\n\tunsigned int vclk_div;\n} params[] = {\n\t[MESON_VCLK_HDMI_ENCI_54000] = {\n\t\t.pll_freq = 4320000,\n\t\t.phy_freq = 270000,\n\t\t.vclk_freq = 54000,\n\t\t.venc_freq = 54000,\n\t\t.pixel_freq = 54000,\n\t\t.pll_od1 = 4,\n\t\t.pll_od2 = 4,\n\t\t.pll_od3 = 1,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_DDR_54000] = {\n\t\t.pll_freq = 4320000,\n\t\t.phy_freq = 270000,\n\t\t.vclk_freq = 54000,\n\t\t.venc_freq = 54000,\n\t\t.pixel_freq = 27000,\n\t\t.pll_od1 = 4,\n\t\t.pll_od2 = 4,\n\t\t.pll_od3 = 1,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_DDR_148500] = {\n\t\t.pll_freq = 2970000,\n\t\t.phy_freq = 742500,\n\t\t.vclk_freq = 148500,\n\t\t.venc_freq = 148500,\n\t\t.pixel_freq = 74250,\n\t\t.pll_od1 = 4,\n\t\t.pll_od2 = 1,\n\t\t.pll_od3 = 1,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_74250] = {\n\t\t.pll_freq = 2970000,\n\t\t.phy_freq = 742500,\n\t\t.vclk_freq = 74250,\n\t\t.venc_freq = 74250,\n\t\t.pixel_freq = 74250,\n\t\t.pll_od1 = 2,\n\t\t.pll_od2 = 2,\n\t\t.pll_od3 = 2,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_148500] = {\n\t\t.pll_freq = 2970000,\n\t\t.phy_freq = 1485000,\n\t\t.vclk_freq = 148500,\n\t\t.venc_freq = 148500,\n\t\t.pixel_freq = 148500,\n\t\t.pll_od1 = 1,\n\t\t.pll_od2 = 2,\n\t\t.pll_od3 = 2,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_297000] = {\n\t\t.pll_freq = 5940000,\n\t\t.phy_freq = 2970000,\n\t\t.venc_freq = 297000,\n\t\t.vclk_freq = 297000,\n\t\t.pixel_freq = 297000,\n\t\t.pll_od1 = 2,\n\t\t.pll_od2 = 1,\n\t\t.pll_od3 = 1,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 2,\n\t},\n\t[MESON_VCLK_HDMI_594000] = {\n\t\t.pll_freq = 5940000,\n\t\t.phy_freq = 5940000,\n\t\t.venc_freq = 594000,\n\t\t.vclk_freq = 594000,\n\t\t.pixel_freq = 594000,\n\t\t.pll_od1 = 1,\n\t\t.pll_od2 = 1,\n\t\t.pll_od3 = 2,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t[MESON_VCLK_HDMI_594000_YUV420] = {\n\t\t.pll_freq = 5940000,\n\t\t.phy_freq = 2970000,\n\t\t.venc_freq = 594000,\n\t\t.vclk_freq = 594000,\n\t\t.pixel_freq = 297000,\n\t\t.pll_od1 = 2,\n\t\t.pll_od2 = 1,\n\t\t.pll_od3 = 1,\n\t\t.vid_pll_div = VID_PLL_DIV_5,\n\t\t.vclk_div = 1,\n\t},\n\t{   },\n};\n\nstatic inline unsigned int pll_od_to_reg(unsigned int od)\n{\n\tswitch (od) {\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\treturn 1;\n\tcase 4:\n\t\treturn 2;\n\tcase 8:\n\t\treturn 3;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void meson_hdmi_pll_set_params(struct meson_drm *priv, unsigned int m,\n\t\t\t\t      unsigned int frac, unsigned int od1,\n\t\t\t\t      unsigned int od2, unsigned int od3)\n{\n\tunsigned int val;\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x58000200 | m);\n\t\tif (frac)\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2,\n\t\t\t\t     0x00004000 | frac);\n\t\telse\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2,\n\t\t\t\t     0x00000000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0x0d5c5091);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x801da72c);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x71486980);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x00000e55);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t   0x7 << 28, HHI_HDMI_PLL_CNTL_EN);\n\n\t\t \n\t\tregmap_read_poll_timeout(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t\t val, (val & HDMI_PLL_LOCK), 10, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t   meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x40000200 | m);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2, 0x800cb000 | frac);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0x860f30c4);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x0c8e0000);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x001fa729);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x01a31500);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\tHDMI_PLL_RESET, HDMI_PLL_RESET);\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\tHDMI_PLL_RESET, 0);\n\n\t\t \n\t\tregmap_read_poll_timeout(priv->hhi, HHI_HDMI_PLL_CNTL, val,\n\t\t\t\t(val & HDMI_PLL_LOCK), 10, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL, 0x0b3a0400 | m);\n\n\t\t \n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t   0x3 << 28, 0x3 << 28);\n\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL2, frac);\n\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL3, 0x00000000);\n\n\t\t \n\t\tif (m >= 0xf7) {\n\t\t\tif (frac < 0x10000) {\n\t\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4,\n\t\t\t\t\t\t\t0x6a685c00);\n\t\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5,\n\t\t\t\t\t\t\t0x11551293);\n\t\t\t} else {\n\t\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4,\n\t\t\t\t\t\t\t0xea68dc00);\n\t\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5,\n\t\t\t\t\t\t\t0x65771290);\n\t\t\t}\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x39272000);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL7, 0x55540000);\n\t\t} else {\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL4, 0x0a691c00);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL5, 0x33771290);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL6, 0x39270000);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PLL_CNTL7, 0x50540000);\n\t\t}\n\n\t\tdo {\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t\tHDMI_PLL_RESET_G12A, HDMI_PLL_RESET_G12A);\n\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t\tHDMI_PLL_RESET_G12A, 0);\n\n\t\t\t \n\t\t\tif (!regmap_read_poll_timeout(priv->hhi,\n\t\t\t\t\t\t      HHI_HDMI_PLL_CNTL, val,\n\t\t\t\t\t\t      ((val & HDMI_PLL_LOCK_G12A)\n\t\t\t\t\t\t        == HDMI_PLL_LOCK_G12A),\n\t\t\t\t\t\t      10, 100))\n\t\t\t\tbreak;\n\t\t} while(1);\n\t}\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL2,\n\t\t\t\t3 << 16, pll_od_to_reg(od1) << 16);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL3,\n\t\t\t\t3 << 21, pll_od_to_reg(od1) << 21);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t3 << 16, pll_od_to_reg(od1) << 16);\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL2,\n\t\t\t\t3 << 22, pll_od_to_reg(od2) << 22);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL3,\n\t\t\t\t3 << 23, pll_od_to_reg(od2) << 23);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t3 << 18, pll_od_to_reg(od2) << 18);\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL2,\n\t\t\t\t3 << 18, pll_od_to_reg(od3) << 18);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL3,\n\t\t\t\t3 << 19, pll_od_to_reg(od3) << 19);\n\telse if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PLL_CNTL,\n\t\t\t\t3 << 20, pll_od_to_reg(od3) << 20);\n}\n\n#define XTAL_FREQ 24000\n\nstatic unsigned int meson_hdmi_pll_get_m(struct meson_drm *priv,\n\t\t\t\t\t unsigned int pll_freq)\n{\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))\n\t\tpll_freq /= 2;\n\n\treturn pll_freq / XTAL_FREQ;\n}\n\n#define HDMI_FRAC_MAX_GXBB\t4096\n#define HDMI_FRAC_MAX_GXL\t1024\n#define HDMI_FRAC_MAX_G12A\t131072\n\nstatic unsigned int meson_hdmi_pll_get_frac(struct meson_drm *priv,\n\t\t\t\t\t    unsigned int m,\n\t\t\t\t\t    unsigned int pll_freq)\n{\n\tunsigned int parent_freq = XTAL_FREQ;\n\tunsigned int frac_max = HDMI_FRAC_MAX_GXL;\n\tunsigned int frac_m;\n\tunsigned int frac;\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\tfrac_max = HDMI_FRAC_MAX_GXBB;\n\t\tparent_freq *= 2;\n\t}\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tfrac_max = HDMI_FRAC_MAX_G12A;\n\n\t \n\tif (pll_freq / m == parent_freq &&\n\t    pll_freq % m == 0)\n\t\treturn 0;\n\n\tfrac = div_u64((u64)pll_freq * (u64)frac_max, parent_freq);\n\tfrac_m = m * frac_max;\n\tif (frac_m > frac)\n\t\treturn frac_max;\n\tfrac -= frac_m;\n\n\treturn min((u16)frac, (u16)(frac_max - 1));\n}\n\nstatic bool meson_hdmi_pll_validate_params(struct meson_drm *priv,\n\t\t\t\t\t   unsigned int m,\n\t\t\t\t\t   unsigned int frac)\n{\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\t \n\t\tif (m < 53 || m > 123)\n\t\t\treturn false;\n\t\tif (frac >= HDMI_FRAC_MAX_GXBB)\n\t\t\treturn false;\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t   meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {\n\t\t \n\t\tif (m < 106 || m > 247)\n\t\t\treturn false;\n\t\tif (frac >= HDMI_FRAC_MAX_GXL)\n\t\t\treturn false;\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\t \n\t\tif (m < 106 || m > 247)\n\t\t\treturn false;\n\t\tif (frac >= HDMI_FRAC_MAX_G12A)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool meson_hdmi_pll_find_params(struct meson_drm *priv,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       unsigned int *m,\n\t\t\t\t       unsigned int *frac,\n\t\t\t\t       unsigned int *od)\n{\n\t \n\tfor (*od = 16 ; *od > 1 ; *od >>= 1) {\n\t\t*m = meson_hdmi_pll_get_m(priv, freq * *od);\n\t\tif (!*m)\n\t\t\tcontinue;\n\t\t*frac = meson_hdmi_pll_get_frac(priv, *m, freq * *od);\n\n\t\tDRM_DEBUG_DRIVER(\"PLL params for %dkHz: m=%x frac=%x od=%d\\n\",\n\t\t\t\t freq, *m, *frac, *od);\n\n\t\tif (meson_hdmi_pll_validate_params(priv, *m, *frac))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nenum drm_mode_status\nmeson_vclk_dmt_supported_freq(struct meson_drm *priv, unsigned int freq)\n{\n\tunsigned int od, m, frac;\n\n\t \n\tfreq *= 10;\n\n\t \n\tif (priv->limits) {\n\t\tif (priv->limits->max_hdmi_phy_freq &&\n\t\t    freq > priv->limits->max_hdmi_phy_freq)\n\t\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\tif (meson_hdmi_pll_find_params(priv, freq, &m, &frac, &od))\n\t\treturn MODE_OK;\n\n\treturn MODE_CLOCK_RANGE;\n}\nEXPORT_SYMBOL_GPL(meson_vclk_dmt_supported_freq);\n\n \nstatic void meson_hdmi_pll_generic_set(struct meson_drm *priv,\n\t\t\t\t       unsigned int pll_freq)\n{\n\tunsigned int od, m, frac, od1, od2, od3;\n\n\tif (meson_hdmi_pll_find_params(priv, pll_freq, &m, &frac, &od)) {\n\t\t \n\t\tod3 = 1;\n\t\tif (od < 4) {\n\t\t\tod1 = 2;\n\t\t\tod2 = 1;\n\t\t} else {\n\t\t\tod2 = od / 4;\n\t\t\tod1 = od / od2;\n\t\t}\n\n\t\tDRM_DEBUG_DRIVER(\"PLL params for %dkHz: m=%x frac=%x od=%d/%d/%d\\n\",\n\t\t\t\t pll_freq, m, frac, od1, od2, od3);\n\n\t\tmeson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);\n\n\t\treturn;\n\t}\n\n\tDRM_ERROR(\"Fatal, unable to find parameters for PLL freq %d\\n\",\n\t\t  pll_freq);\n}\n\nenum drm_mode_status\nmeson_vclk_vic_supported_freq(struct meson_drm *priv, unsigned int phy_freq,\n\t\t\t      unsigned int vclk_freq)\n{\n\tint i;\n\n\tDRM_DEBUG_DRIVER(\"phy_freq = %d vclk_freq = %d\\n\",\n\t\t\t phy_freq, vclk_freq);\n\n\t \n\tif (priv->limits) {\n\t\tif (priv->limits->max_hdmi_phy_freq &&\n\t\t    phy_freq > priv->limits->max_hdmi_phy_freq)\n\t\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\tfor (i = 0 ; params[i].pixel_freq ; ++i) {\n\t\tDRM_DEBUG_DRIVER(\"i = %d pixel_freq = %d alt = %d\\n\",\n\t\t\t\t i, params[i].pixel_freq,\n\t\t\t\t FREQ_1000_1001(params[i].pixel_freq));\n\t\tDRM_DEBUG_DRIVER(\"i = %d phy_freq = %d alt = %d\\n\",\n\t\t\t\t i, params[i].phy_freq,\n\t\t\t\t FREQ_1000_1001(params[i].phy_freq/10)*10);\n\t\t \n\t\tif (phy_freq == params[i].phy_freq &&\n\t\t    vclk_freq == params[i].vclk_freq)\n\t\t\treturn MODE_OK;\n\t\t \n\t\tif (phy_freq == (FREQ_1000_1001(params[i].phy_freq/10)*10) &&\n\t\t    vclk_freq == FREQ_1000_1001(params[i].vclk_freq))\n\t\t\treturn MODE_OK;\n\t}\n\n\treturn MODE_CLOCK_RANGE;\n}\nEXPORT_SYMBOL_GPL(meson_vclk_vic_supported_freq);\n\nstatic void meson_vclk_set(struct meson_drm *priv, unsigned int pll_base_freq,\n\t\t\t   unsigned int od1, unsigned int od2, unsigned int od3,\n\t\t\t   unsigned int vid_pll_div, unsigned int vclk_div,\n\t\t\t   unsigned int hdmi_tx_div, unsigned int venc_div,\n\t\t\t   bool hdmi_use_enci, bool vic_alternate_clock)\n{\n\tunsigned int m = 0, frac = 0;\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\t   CTS_HDMI_SYS_SEL_MASK, 0);\n\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\t   CTS_HDMI_SYS_DIV_MASK, 0);\n\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\t   CTS_HDMI_SYS_EN, CTS_HDMI_SYS_EN);\n\n\t \n\tif (!od1 && !od2 && !od3) {\n\t\tmeson_hdmi_pll_generic_set(priv, pll_base_freq);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\tswitch (pll_base_freq) {\n\t\tcase 2970000:\n\t\t\tm = 0x3d;\n\t\t\tfrac = vic_alternate_clock ? 0xd02 : 0xe00;\n\t\t\tbreak;\n\t\tcase 4320000:\n\t\t\tm = vic_alternate_clock ? 0x59 : 0x5a;\n\t\t\tfrac = vic_alternate_clock ? 0xe8f : 0;\n\t\t\tbreak;\n\t\tcase 5940000:\n\t\t\tm = 0x7b;\n\t\t\tfrac = vic_alternate_clock ? 0xa05 : 0xc00;\n\t\t\tbreak;\n\t\t}\n\n\t\tmeson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t   meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {\n\t\tswitch (pll_base_freq) {\n\t\tcase 2970000:\n\t\t\tm = 0x7b;\n\t\t\tfrac = vic_alternate_clock ? 0x281 : 0x300;\n\t\t\tbreak;\n\t\tcase 4320000:\n\t\t\tm = vic_alternate_clock ? 0xb3 : 0xb4;\n\t\t\tfrac = vic_alternate_clock ? 0x347 : 0;\n\t\t\tbreak;\n\t\tcase 5940000:\n\t\t\tm = 0xf7;\n\t\t\tfrac = vic_alternate_clock ? 0x102 : 0x200;\n\t\t\tbreak;\n\t\t}\n\n\t\tmeson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tswitch (pll_base_freq) {\n\t\tcase 2970000:\n\t\t\tm = 0x7b;\n\t\t\tfrac = vic_alternate_clock ? 0x140b4 : 0x18000;\n\t\t\tbreak;\n\t\tcase 4320000:\n\t\t\tm = vic_alternate_clock ? 0xb3 : 0xb4;\n\t\t\tfrac = vic_alternate_clock ? 0x1a3ee : 0;\n\t\t\tbreak;\n\t\tcase 5940000:\n\t\t\tm = 0xf7;\n\t\t\tfrac = vic_alternate_clock ? 0x8148 : 0x10000;\n\t\t\tbreak;\n\t\t}\n\n\t\tmeson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);\n\t}\n\n\t \n\tmeson_vid_pll_set(priv, vid_pll_div);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t   VCLK_SEL_MASK, 0);\n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t   VCLK_DIV_MASK, vclk_div - 1);\n\n\t \n\tswitch (hdmi_tx_div) {\n\tcase 1:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV1_EN, VCLK_DIV1_EN);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\t\t   HDMI_TX_PIXEL_SEL_MASK, 0);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV2_EN, VCLK_DIV2_EN);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\tHDMI_TX_PIXEL_SEL_MASK, 1 << HDMI_TX_PIXEL_SEL_SHIFT);\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV4_EN, VCLK_DIV4_EN);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\tHDMI_TX_PIXEL_SEL_MASK, 2 << HDMI_TX_PIXEL_SEL_SHIFT);\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV6_EN, VCLK_DIV6_EN);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\tHDMI_TX_PIXEL_SEL_MASK, 3 << HDMI_TX_PIXEL_SEL_SHIFT);\n\t\tbreak;\n\tcase 12:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV12_EN, VCLK_DIV12_EN);\n\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL,\n\t\t\tHDMI_TX_PIXEL_SEL_MASK, 4 << HDMI_TX_PIXEL_SEL_SHIFT);\n\t\tbreak;\n\t}\n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2,\n\t\t\t\t   HDMI_TX_PIXEL_EN, HDMI_TX_PIXEL_EN);\n\n\t \n\tswitch (venc_div) {\n\tcase 1:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV1_EN, VCLK_DIV1_EN);\n\n\t\tif (hdmi_use_enci)\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\t\t   CTS_ENCI_SEL_MASK, 0);\n\t\telse\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\t\t   CTS_ENCP_SEL_MASK, 0);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV2_EN, VCLK_DIV2_EN);\n\n\t\tif (hdmi_use_enci)\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCI_SEL_MASK, 1 << CTS_ENCI_SEL_SHIFT);\n\t\telse\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCP_SEL_MASK, 1 << CTS_ENCP_SEL_SHIFT);\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV4_EN, VCLK_DIV4_EN);\n\n\t\tif (hdmi_use_enci)\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCI_SEL_MASK, 2 << CTS_ENCI_SEL_SHIFT);\n\t\telse\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCP_SEL_MASK, 2 << CTS_ENCP_SEL_SHIFT);\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV6_EN, VCLK_DIV6_EN);\n\n\t\tif (hdmi_use_enci)\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCI_SEL_MASK, 3 << CTS_ENCI_SEL_SHIFT);\n\t\telse\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCP_SEL_MASK, 3 << CTS_ENCP_SEL_SHIFT);\n\t\tbreak;\n\tcase 12:\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL,\n\t\t\t\t   VCLK_DIV12_EN, VCLK_DIV12_EN);\n\n\t\tif (hdmi_use_enci)\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCI_SEL_MASK, 4 << CTS_ENCI_SEL_SHIFT);\n\t\telse\n\t\t\t \n\t\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_DIV,\n\t\t\t\tCTS_ENCP_SEL_MASK, 4 << CTS_ENCP_SEL_SHIFT);\n\t\tbreak;\n\t}\n\n\tif (hdmi_use_enci)\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2,\n\t\t\t\t   CTS_ENCI_EN, CTS_ENCI_EN);\n\telse\n\t\t \n\t\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2,\n\t\t\t\t   CTS_ENCP_EN, CTS_ENCP_EN);\n\n\tregmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL, VCLK_EN, VCLK_EN);\n}\n\nvoid meson_vclk_setup(struct meson_drm *priv, unsigned int target,\n\t\t      unsigned int phy_freq, unsigned int vclk_freq,\n\t\t      unsigned int venc_freq, unsigned int dac_freq,\n\t\t      bool hdmi_use_enci)\n{\n\tbool vic_alternate_clock = false;\n\tunsigned int freq;\n\tunsigned int hdmi_tx_div;\n\tunsigned int venc_div;\n\n\tif (target == MESON_VCLK_TARGET_CVBS) {\n\t\tmeson_venci_cvbs_clock_config(priv);\n\t\treturn;\n\t} else if (target == MESON_VCLK_TARGET_DMT) {\n\t\t \n\t\tmeson_vclk_set(priv, phy_freq, 0, 0, 0,\n\t\t\t       VID_PLL_DIV_5, 2, 1, 1, false, false);\n\t\treturn;\n\t}\n\n\thdmi_tx_div = vclk_freq / dac_freq;\n\n\tif (hdmi_tx_div == 0) {\n\t\tpr_err(\"Fatal Error, invalid HDMI-TX freq %d\\n\",\n\t\t       dac_freq);\n\t\treturn;\n\t}\n\n\tvenc_div = vclk_freq / venc_freq;\n\n\tif (venc_div == 0) {\n\t\tpr_err(\"Fatal Error, invalid HDMI venc freq %d\\n\",\n\t\t       venc_freq);\n\t\treturn;\n\t}\n\n\tfor (freq = 0 ; params[freq].pixel_freq ; ++freq) {\n\t\tif ((phy_freq == params[freq].phy_freq ||\n\t\t     phy_freq == FREQ_1000_1001(params[freq].phy_freq/10)*10) &&\n\t\t    (vclk_freq == params[freq].vclk_freq ||\n\t\t     vclk_freq == FREQ_1000_1001(params[freq].vclk_freq))) {\n\t\t\tif (vclk_freq != params[freq].vclk_freq)\n\t\t\t\tvic_alternate_clock = true;\n\t\t\telse\n\t\t\t\tvic_alternate_clock = false;\n\n\t\t\tif (freq == MESON_VCLK_HDMI_ENCI_54000 &&\n\t\t\t    !hdmi_use_enci)\n\t\t\t\tcontinue;\n\n\t\t\tif (freq == MESON_VCLK_HDMI_DDR_54000 &&\n\t\t\t    hdmi_use_enci)\n\t\t\t\tcontinue;\n\n\t\t\tif (freq == MESON_VCLK_HDMI_DDR_148500 &&\n\t\t\t    dac_freq == vclk_freq)\n\t\t\t\tcontinue;\n\n\t\t\tif (freq == MESON_VCLK_HDMI_148500 &&\n\t\t\t    dac_freq != vclk_freq)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!params[freq].pixel_freq) {\n\t\tpr_err(\"Fatal Error, invalid HDMI vclk freq %d\\n\", vclk_freq);\n\t\treturn;\n\t}\n\n\tmeson_vclk_set(priv, params[freq].pll_freq,\n\t\t       params[freq].pll_od1, params[freq].pll_od2,\n\t\t       params[freq].pll_od3, params[freq].vid_pll_div,\n\t\t       params[freq].vclk_div, hdmi_tx_div, venc_div,\n\t\t       hdmi_use_enci, vic_alternate_clock);\n}\nEXPORT_SYMBOL_GPL(meson_vclk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}