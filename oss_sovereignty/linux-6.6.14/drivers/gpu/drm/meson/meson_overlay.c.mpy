{
  "module_name": "meson_overlay.c",
  "hash_id": "da0308899367ca6f18e6ec45e39517278b03933334f52020ec3862498f8ec4f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_overlay.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n\n#include \"meson_overlay.h\"\n#include \"meson_registers.h\"\n#include \"meson_viu.h\"\n#include \"meson_vpp.h\"\n\n \n#define VD_URGENT_CHROMA\t\tBIT(28)\n#define VD_URGENT_LUMA\t\t\tBIT(27)\n#define VD_HOLD_LINES(lines)\t\tFIELD_PREP(GENMASK(24, 19), lines)\n#define VD_DEMUX_MODE_RGB\t\tBIT(16)\n#define VD_BYTES_PER_PIXEL(val)\t\tFIELD_PREP(GENMASK(15, 14), val)\n#define VD_CHRO_RPT_LASTL_CTRL\t\tBIT(6)\n#define VD_LITTLE_ENDIAN\t\tBIT(4)\n#define VD_SEPARATE_EN\t\t\tBIT(1)\n#define VD_ENABLE\t\t\tBIT(0)\n\n \n#define CANVAS_ADDR2(addr)\t\tFIELD_PREP(GENMASK(23, 16), addr)\n#define CANVAS_ADDR1(addr)\t\tFIELD_PREP(GENMASK(15, 8), addr)\n#define CANVAS_ADDR0(addr)\t\tFIELD_PREP(GENMASK(7, 0), addr)\n\n \n#define VD_X_START(value)\t\tFIELD_PREP(GENMASK(14, 0), value)\n#define VD_X_END(value)\t\t\tFIELD_PREP(GENMASK(30, 16), value)\n\n \n#define VD_Y_START(value)\t\tFIELD_PREP(GENMASK(12, 0), value)\n#define VD_Y_END(value)\t\t\tFIELD_PREP(GENMASK(28, 16), value)\n\n \n#define VD_COLOR_MAP(value)\t\tFIELD_PREP(GENMASK(1, 0), value)\n\n \n#define VD_HORZ_Y_C_RATIO(value)\tFIELD_PREP(GENMASK(22, 21), value)\n#define VD_HORZ_FMT_EN\t\t\tBIT(20)\n#define VD_VERT_RPT_LINE0\t\tBIT(16)\n#define VD_VERT_INITIAL_PHASE(value)\tFIELD_PREP(GENMASK(11, 8), value)\n#define VD_VERT_PHASE_STEP(value)\tFIELD_PREP(GENMASK(7, 1), value)\n#define VD_VERT_FMT_EN\t\t\tBIT(0)\n\n \n#define VD_H_END(value)\t\t\tFIELD_PREP(GENMASK(11, 0), value)\n#define VD_H_START(value)\t\tFIELD_PREP(GENMASK(27, 16), \\\n\t\t\t\t\t\t   ((value) & GENMASK(13, 0)))\n\n \n#define VD_V_END(value)\t\t\tFIELD_PREP(GENMASK(11, 0), value)\n#define VD_V_START(value)\t\tFIELD_PREP(GENMASK(27, 16), value)\n\n \n#define VD2_V_END(value)\t\tFIELD_PREP(GENMASK(11, 0), value)\n#define VD2_V_START(value)\t\tFIELD_PREP(GENMASK(27, 16), value)\n\n \n#define VD_V_WIDTH(value)\t\tFIELD_PREP(GENMASK(11, 0), value)\n#define VD_H_WIDTH(value)\t\tFIELD_PREP(GENMASK(27, 16), value)\n\n \n#define VD_REGION24_START(value)\tFIELD_PREP(GENMASK(11, 0), value)\n#define VD_REGION13_END(value)\t\tFIELD_PREP(GENMASK(27, 16), value)\n\n \n#define AFBC_DEC_ENABLE\t\t\tBIT(8)\n#define AFBC_FRM_START\t\t\tBIT(0)\n\n \n#define AFBC_HORZ_SKIP_UV(value)\tFIELD_PREP(GENMASK(1, 0), value)\n#define AFBC_VERT_SKIP_UV(value)\tFIELD_PREP(GENMASK(3, 2), value)\n#define AFBC_HORZ_SKIP_Y(value)\t\tFIELD_PREP(GENMASK(5, 4), value)\n#define AFBC_VERT_SKIP_Y(value)\t\tFIELD_PREP(GENMASK(7, 6), value)\n#define AFBC_COMPBITS_YUV(value)\tFIELD_PREP(GENMASK(13, 8), value)\n#define AFBC_COMPBITS_8BIT\t\t0\n#define AFBC_COMPBITS_10BIT\t\t(2 | (2 << 2) | (2 << 4))\n#define AFBC_BURST_LEN(value)\t\tFIELD_PREP(GENMASK(15, 14), value)\n#define AFBC_HOLD_LINE_NUM(value)\tFIELD_PREP(GENMASK(22, 16), value)\n#define AFBC_MIF_URGENT(value)\t\tFIELD_PREP(GENMASK(25, 24), value)\n#define AFBC_REV_MODE(value)\t\tFIELD_PREP(GENMASK(27, 26), value)\n#define AFBC_BLK_MEM_MODE\t\tBIT(28)\n#define AFBC_SCATTER_MODE\t\tBIT(29)\n#define AFBC_SOFT_RESET\t\t\tBIT(31)\n\n \n#define AFBC_HSIZE_IN(value)\t\tFIELD_PREP(GENMASK(28, 16), value)\n#define AFBC_VSIZE_IN(value)\t\tFIELD_PREP(GENMASK(12, 0), value)\n\n \n#define AFBC_DEF_COLOR_Y(value)\t\tFIELD_PREP(GENMASK(29, 20), value)\n#define AFBC_DEF_COLOR_U(value)\t\tFIELD_PREP(GENMASK(19, 10), value)\n#define AFBC_DEF_COLOR_V(value)\t\tFIELD_PREP(GENMASK(9, 0), value)\n\n \n#define AFBC_CONV_LBUF_LEN(value)\tFIELD_PREP(GENMASK(11, 0), value)\n\n \n#define AFBC_DEC_LBUF_DEPTH(value)\tFIELD_PREP(GENMASK(27, 16), value)\n#define AFBC_MIF_LBUF_DEPTH(value)\tFIELD_PREP(GENMASK(11, 0), value)\n\n \n#define AFBC_HSIZE_OUT(value)\t\tFIELD_PREP(GENMASK(28, 16), value)\n#define AFBC_VSIZE_OUT(value)\t\tFIELD_PREP(GENMASK(12, 0), value)\n#define AFBC_OUT_HORZ_BGN(value)\tFIELD_PREP(GENMASK(28, 16), value)\n#define AFBC_OUT_HORZ_END(value)\tFIELD_PREP(GENMASK(12, 0), value)\n\n \n#define AFBC_OUT_VERT_BGN(value)\tFIELD_PREP(GENMASK(28, 16), value)\n#define AFBC_OUT_VERT_END(value)\tFIELD_PREP(GENMASK(12, 0), value)\n\n \n#define AFBC_HORZ_RPT_PIXEL0\t\tBIT(23)\n#define AFBC_HORZ_Y_C_RATIO(value)\tFIELD_PREP(GENMASK(22, 21), value)\n#define AFBC_HORZ_FMT_EN\t\tBIT(20)\n#define AFBC_VERT_RPT_LINE0\t\tBIT(16)\n#define AFBC_VERT_INITIAL_PHASE(value)\tFIELD_PREP(GENMASK(11, 8), value)\n#define AFBC_VERT_PHASE_STEP(value)\tFIELD_PREP(GENMASK(7, 1), value)\n#define AFBC_VERT_FMT_EN\t\tBIT(0)\n\n \n#define AFBC_VD_V_WIDTH(value)\t\tFIELD_PREP(GENMASK(11, 0), value)\n#define AFBC_VD_H_WIDTH(value)\t\tFIELD_PREP(GENMASK(27, 16), value)\n\n \n#define AFBC_MIF_BLK_BGN_H(value)\tFIELD_PREP(GENMASK(25, 16), value)\n#define AFBC_MIF_BLK_END_H(value)\tFIELD_PREP(GENMASK(9, 0), value)\n\n \n#define AFBC_MIF_BLK_BGN_V(value)\tFIELD_PREP(GENMASK(27, 16), value)\n#define AFBC_MIF_BLK_END_V(value)\tFIELD_PREP(GENMASK(11, 0), value)\n\n \n#define AFBC_DEC_PIXEL_BGN_H(value)\tFIELD_PREP(GENMASK(28, 16), \\\n\t\t\t\t\t\t   ((value) & GENMASK(12, 0)))\n#define AFBC_DEC_PIXEL_END_H(value)\tFIELD_PREP(GENMASK(12, 0), value)\n\n \n#define AFBC_DEC_PIXEL_BGN_V(value)\tFIELD_PREP(GENMASK(28, 16), value)\n#define AFBC_DEC_PIXEL_END_V(value)\tFIELD_PREP(GENMASK(12, 0), value)\n\n \n#define AFBC_VD_HEIGHT(value)\t\tFIELD_PREP(GENMASK(12, 0), value)\n\nstruct meson_overlay {\n\tstruct drm_plane base;\n\tstruct meson_drm *priv;\n};\n#define to_meson_overlay(x) container_of(x, struct meson_overlay, base)\n\n#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))\n\nstatic int meson_overlay_atomic_check(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (!new_plane_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   FRAC_16_16(1, 5),\n\t\t\t\t\t\t   FRAC_16_16(5, 1),\n\t\t\t\t\t\t   true, true);\n}\n\n \nstatic inline int64_t fixed16_to_int(int64_t value)\n{\n\treturn value >> 16;\n}\n\nstatic const uint8_t skip_tab[6] = {\n\t0x24, 0x04, 0x68, 0x48, 0x28, 0x08,\n};\n\nstatic void meson_overlay_get_vertical_phase(unsigned int ratio_y, int *phase,\n\t\t\t\t\t     int *repeat, bool interlace)\n{\n\tint offset_in = 0;\n\tint offset_out = 0;\n\tint repeat_skip = 0;\n\n\tif (!interlace && ratio_y > (1 << 18))\n\t\toffset_out = (1 * ratio_y) >> 10;\n\n\twhile ((offset_in + (4 << 8)) <= offset_out) {\n\t\trepeat_skip++;\n\t\toffset_in += 4 << 8;\n\t}\n\n\t*phase = (offset_out - offset_in) >> 2;\n\n\tif (*phase > 0x100)\n\t\trepeat_skip++;\n\n\t*phase = *phase & 0xff;\n\n\tif (repeat_skip > 5)\n\t\trepeat_skip = 5;\n\n\t*repeat = skip_tab[repeat_skip];\n}\n\nstatic void meson_overlay_setup_scaler_params(struct meson_drm *priv,\n\t\t\t\t\t      struct drm_plane *plane,\n\t\t\t\t\t      bool interlace_mode)\n{\n\tstruct drm_crtc_state *crtc_state = priv->crtc->state;\n\tint video_top, video_left, video_width, video_height;\n\tstruct drm_plane_state *state = plane->state;\n\tunsigned int vd_start_lines, vd_end_lines;\n\tunsigned int hd_start_lines, hd_end_lines;\n\tunsigned int crtc_height, crtc_width;\n\tunsigned int vsc_startp, vsc_endp;\n\tunsigned int hsc_startp, hsc_endp;\n\tunsigned int crop_top, crop_left;\n\tint vphase, vphase_repeat_skip;\n\tunsigned int ratio_x, ratio_y;\n\tint temp_height, temp_width;\n\tunsigned int w_in, h_in;\n\tint afbc_left, afbc_right;\n\tint afbc_top_src, afbc_bottom_src;\n\tint afbc_top, afbc_bottom;\n\tint temp, start, end;\n\n\tif (!crtc_state) {\n\t\tDRM_ERROR(\"Invalid crtc_state\\n\");\n\t\treturn;\n\t}\n\n\tcrtc_height = crtc_state->mode.vdisplay;\n\tcrtc_width = crtc_state->mode.hdisplay;\n\n\tw_in = fixed16_to_int(state->src_w);\n\th_in = fixed16_to_int(state->src_h);\n\tcrop_top = fixed16_to_int(state->src_y);\n\tcrop_left = fixed16_to_int(state->src_x);\n\n\tvideo_top = state->crtc_y;\n\tvideo_left = state->crtc_x;\n\tvideo_width = state->crtc_w;\n\tvideo_height = state->crtc_h;\n\n\tDRM_DEBUG(\"crtc_width %d crtc_height %d interlace %d\\n\",\n\t\t  crtc_width, crtc_height, interlace_mode);\n\tDRM_DEBUG(\"w_in %d h_in %d crop_top %d crop_left %d\\n\",\n\t\t  w_in, h_in, crop_top, crop_left);\n\tDRM_DEBUG(\"video top %d left %d width %d height %d\\n\",\n\t\t  video_top, video_left, video_width, video_height);\n\n\tratio_x = (w_in << 18) / video_width;\n\tratio_y = (h_in << 18) / video_height;\n\n\tif (ratio_x * video_width < (w_in << 18))\n\t\tratio_x++;\n\n\tDRM_DEBUG(\"ratio x 0x%x y 0x%x\\n\", ratio_x, ratio_y);\n\n\tmeson_overlay_get_vertical_phase(ratio_y, &vphase, &vphase_repeat_skip,\n\t\t\t\t\t interlace_mode);\n\n\tDRM_DEBUG(\"vphase 0x%x skip %d\\n\", vphase, vphase_repeat_skip);\n\n\t \n\n\tstart = video_top + video_height / 2 - ((h_in << 17) / ratio_y);\n\tend = (h_in << 18) / ratio_y + start - 1;\n\n\tif (video_top < 0 && start < 0)\n\t\tvd_start_lines = (-(start) * ratio_y) >> 18;\n\telse if (start < video_top)\n\t\tvd_start_lines = ((video_top - start) * ratio_y) >> 18;\n\telse\n\t\tvd_start_lines = 0;\n\n\tif (video_top < 0)\n\t\ttemp_height = min_t(unsigned int,\n\t\t\t\t    video_top + video_height - 1,\n\t\t\t\t    crtc_height - 1);\n\telse\n\t\ttemp_height = min_t(unsigned int,\n\t\t\t\t    video_top + video_height - 1,\n\t\t\t\t    crtc_height - 1) - video_top + 1;\n\n\ttemp = vd_start_lines + (temp_height * ratio_y >> 18);\n\tvd_end_lines = (temp <= (h_in - 1)) ? temp : (h_in - 1);\n\n\tvd_start_lines += crop_left;\n\tvd_end_lines += crop_left;\n\n\t \n\tif (interlace_mode) {\n\t\tstart >>= 1;\n\t\tend >>= 1;\n\t}\n\n\tvsc_startp = max_t(int, start,\n\t\t\t   max_t(int, 0, video_top));\n\tvsc_endp = min_t(int, end,\n\t\t\t min_t(int, crtc_height - 1,\n\t\t\t       video_top + video_height - 1));\n\n\tDRM_DEBUG(\"vsc startp %d endp %d start_lines %d end_lines %d\\n\",\n\t\t vsc_startp, vsc_endp, vd_start_lines, vd_end_lines);\n\n\tafbc_top = round_down(vd_start_lines, 4);\n\tafbc_bottom = round_up(vd_end_lines + 1, 4);\n\tafbc_top_src = 0;\n\tafbc_bottom_src = round_up(h_in + 1, 4);\n\n\tDRM_DEBUG(\"afbc top %d (src %d) bottom %d (src %d)\\n\",\n\t\t  afbc_top, afbc_top_src, afbc_bottom, afbc_bottom_src);\n\n\t \n\n\tstart = video_left + video_width / 2 - ((w_in << 17) / ratio_x);\n\tend = (w_in << 18) / ratio_x + start - 1;\n\n\tif (video_left < 0 && start < 0)\n\t\thd_start_lines = (-(start) * ratio_x) >> 18;\n\telse if (start < video_left)\n\t\thd_start_lines = ((video_left - start) * ratio_x) >> 18;\n\telse\n\t\thd_start_lines = 0;\n\n\tif (video_left < 0)\n\t\ttemp_width = min_t(unsigned int,\n\t\t\t\t   video_left + video_width - 1,\n\t\t\t\t   crtc_width - 1);\n\telse\n\t\ttemp_width = min_t(unsigned int,\n\t\t\t\t   video_left + video_width - 1,\n\t\t\t\t   crtc_width - 1) - video_left + 1;\n\n\ttemp = hd_start_lines + (temp_width * ratio_x >> 18);\n\thd_end_lines = (temp <= (w_in - 1)) ? temp : (w_in - 1);\n\n\tpriv->viu.vpp_line_in_length = hd_end_lines - hd_start_lines + 1;\n\thsc_startp = max_t(int, start, max_t(int, 0, video_left));\n\thsc_endp = min_t(int, end, min_t(int, crtc_width - 1,\n\t\t\t\t\t video_left + video_width - 1));\n\n\thd_start_lines += crop_top;\n\thd_end_lines += crop_top;\n\n\tDRM_DEBUG(\"hsc startp %d endp %d start_lines %d end_lines %d\\n\",\n\t\t hsc_startp, hsc_endp, hd_start_lines, hd_end_lines);\n\n\tif (hd_start_lines > 0 || (hd_end_lines < w_in)) {\n\t\tafbc_left = 0;\n\t\tafbc_right = round_up(w_in, 32);\n\t} else {\n\t\tafbc_left = round_down(hd_start_lines, 32);\n\t\tafbc_right = round_up(hd_end_lines + 1, 32);\n\t}\n\n\tDRM_DEBUG(\"afbc left %d right %d\\n\", afbc_left, afbc_right);\n\n\tpriv->viu.vpp_vsc_start_phase_step = ratio_y << 6;\n\n\tpriv->viu.vpp_vsc_ini_phase = vphase << 8;\n\tpriv->viu.vpp_vsc_phase_ctrl = (1 << 13) | (4 << 8) |\n\t\t\t\t       vphase_repeat_skip;\n\n\tpriv->viu.vd1_if0_luma_x0 = VD_X_START(hd_start_lines) |\n\t\t\t\t    VD_X_END(hd_end_lines);\n\tpriv->viu.vd1_if0_chroma_x0 = VD_X_START(hd_start_lines >> 1) |\n\t\t\t\t      VD_X_END(hd_end_lines >> 1);\n\n\tpriv->viu.viu_vd1_fmt_w =\n\t\t\tVD_H_WIDTH(hd_end_lines - hd_start_lines + 1) |\n\t\t\tVD_V_WIDTH(hd_end_lines/2 - hd_start_lines/2 + 1);\n\n\tpriv->viu.vd1_afbc_vd_cfmt_w =\n\t\t\tAFBC_VD_H_WIDTH(afbc_right - afbc_left) |\n\t\t\tAFBC_VD_V_WIDTH(afbc_right / 2 - afbc_left / 2);\n\n\tpriv->viu.vd1_afbc_vd_cfmt_h =\n\t\t\tAFBC_VD_HEIGHT((afbc_bottom - afbc_top) / 2);\n\n\tpriv->viu.vd1_afbc_mif_hor_scope = AFBC_MIF_BLK_BGN_H(afbc_left / 32) |\n\t\t\t\tAFBC_MIF_BLK_END_H((afbc_right / 32) - 1);\n\n\tpriv->viu.vd1_afbc_mif_ver_scope = AFBC_MIF_BLK_BGN_V(afbc_top / 4) |\n\t\t\t\tAFBC_MIF_BLK_END_H((afbc_bottom / 4) - 1);\n\n\tpriv->viu.vd1_afbc_size_out =\n\t\t\tAFBC_HSIZE_OUT(afbc_right - afbc_left) |\n\t\t\tAFBC_VSIZE_OUT(afbc_bottom - afbc_top);\n\n\tpriv->viu.vd1_afbc_pixel_hor_scope =\n\t\t\tAFBC_DEC_PIXEL_BGN_H(hd_start_lines - afbc_left) |\n\t\t\tAFBC_DEC_PIXEL_END_H(hd_end_lines - afbc_left);\n\n\tpriv->viu.vd1_afbc_pixel_ver_scope =\n\t\t\tAFBC_DEC_PIXEL_BGN_V(vd_start_lines - afbc_top) |\n\t\t\tAFBC_DEC_PIXEL_END_V(vd_end_lines - afbc_top);\n\n\tpriv->viu.vd1_afbc_size_in =\n\t\t\t\tAFBC_HSIZE_IN(afbc_right - afbc_left) |\n\t\t\t\tAFBC_VSIZE_IN(afbc_bottom_src - afbc_top_src);\n\n\tpriv->viu.vd1_if0_luma_y0 = VD_Y_START(vd_start_lines) |\n\t\t\t\t    VD_Y_END(vd_end_lines);\n\n\tpriv->viu.vd1_if0_chroma_y0 = VD_Y_START(vd_start_lines >> 1) |\n\t\t\t\t      VD_Y_END(vd_end_lines >> 1);\n\n\tpriv->viu.vpp_pic_in_height = h_in;\n\n\tpriv->viu.vpp_postblend_vd1_h_start_end = VD_H_START(hsc_startp) |\n\t\t\t\t\t\t  VD_H_END(hsc_endp);\n\tpriv->viu.vpp_blend_vd2_h_start_end = VD_H_START(hd_start_lines) |\n\t\t\t\t\t      VD_H_END(hd_end_lines);\n\tpriv->viu.vpp_hsc_region12_startp = VD_REGION13_END(0) |\n\t\t\t\t\t    VD_REGION24_START(hsc_startp);\n\tpriv->viu.vpp_hsc_region34_startp =\n\t\t\t\tVD_REGION13_END(hsc_startp) |\n\t\t\t\tVD_REGION24_START(hsc_endp - hsc_startp);\n\tpriv->viu.vpp_hsc_region4_endp = hsc_endp - hsc_startp;\n\tpriv->viu.vpp_hsc_start_phase_step = ratio_x << 6;\n\tpriv->viu.vpp_hsc_region1_phase_slope = 0;\n\tpriv->viu.vpp_hsc_region3_phase_slope = 0;\n\tpriv->viu.vpp_hsc_phase_ctrl = (1 << 21) | (4 << 16);\n\n\tpriv->viu.vpp_line_in_length = hd_end_lines - hd_start_lines + 1;\n\tpriv->viu.vpp_preblend_h_size = hd_end_lines - hd_start_lines + 1;\n\n\tpriv->viu.vpp_postblend_vd1_v_start_end = VD_V_START(vsc_startp) |\n\t\t\t\t\t\t  VD_V_END(vsc_endp);\n\tpriv->viu.vpp_blend_vd2_v_start_end =\n\t\t\t\tVD2_V_START((vd_end_lines + 1) >> 1) |\n\t\t\t\tVD2_V_END(vd_end_lines);\n\n\tpriv->viu.vpp_vsc_region12_startp = 0;\n\tpriv->viu.vpp_vsc_region34_startp =\n\t\t\t\tVD_REGION13_END(vsc_endp - vsc_startp) |\n\t\t\t\tVD_REGION24_START(vsc_endp - vsc_startp);\n\tpriv->viu.vpp_vsc_region4_endp = vsc_endp - vsc_startp;\n\tpriv->viu.vpp_vsc_start_phase_step = ratio_y << 6;\n}\n\nstatic void meson_overlay_atomic_update(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct meson_overlay *meson_overlay = to_meson_overlay(plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct meson_drm *priv = meson_overlay->priv;\n\tstruct drm_gem_dma_object *gem;\n\tunsigned long flags;\n\tbool interlace_mode;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tinterlace_mode = new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE;\n\n\tspin_lock_irqsave(&priv->drm->event_lock, flags);\n\n\tif ((fb->modifier & DRM_FORMAT_MOD_AMLOGIC_FBC(0, 0)) ==\n\t\t\t    DRM_FORMAT_MOD_AMLOGIC_FBC(0, 0)) {\n\t\tpriv->viu.vd1_afbc = true;\n\n\t\tpriv->viu.vd1_afbc_mode = AFBC_MIF_URGENT(3) |\n\t\t\t\t\t  AFBC_HOLD_LINE_NUM(8) |\n\t\t\t\t\t  AFBC_BURST_LEN(2);\n\n\t\tif (fb->modifier & DRM_FORMAT_MOD_AMLOGIC_FBC(0,\n\t\t\t\t\t\tAMLOGIC_FBC_OPTION_MEM_SAVING))\n\t\t\tpriv->viu.vd1_afbc_mode |= AFBC_BLK_MEM_MODE;\n\n\t\tif ((fb->modifier & __fourcc_mod_amlogic_layout_mask) ==\n\t\t\t\tAMLOGIC_FBC_LAYOUT_SCATTER)\n\t\t\tpriv->viu.vd1_afbc_mode |= AFBC_SCATTER_MODE;\n\n\t\tpriv->viu.vd1_afbc_en = 0x1600 | AFBC_DEC_ENABLE;\n\n\t\tpriv->viu.vd1_afbc_conv_ctrl = AFBC_CONV_LBUF_LEN(256);\n\n\t\tpriv->viu.vd1_afbc_dec_def_color = AFBC_DEF_COLOR_Y(1023);\n\n\t\t \n\t\tpriv->viu.vd1_afbc_vd_cfmt_ctrl = AFBC_HORZ_RPT_PIXEL0 |\n\t\t\t\t\t\t  AFBC_HORZ_Y_C_RATIO(1) |\n\t\t\t\t\t\t  AFBC_HORZ_FMT_EN |\n\t\t\t\t\t\t  AFBC_VERT_RPT_LINE0 |\n\t\t\t\t\t\t  AFBC_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\t\t  AFBC_VERT_PHASE_STEP(8) |\n\t\t\t\t\t\t  AFBC_VERT_FMT_EN;\n\n\t\tswitch (fb->format->format) {\n\t\t \n\t\tcase DRM_FORMAT_YUV420_10BIT:\n\t\t\tpriv->viu.vd1_afbc_mode |=\n\t\t\t\tAFBC_COMPBITS_YUV(AFBC_COMPBITS_10BIT);\n\t\t\tpriv->viu.vd1_afbc_dec_def_color |=\n\t\t\t\t\tAFBC_DEF_COLOR_U(512) |\n\t\t\t\t\tAFBC_DEF_COLOR_V(512);\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUV420_8BIT:\n\t\t\tpriv->viu.vd1_afbc_dec_def_color |=\n\t\t\t\t\tAFBC_DEF_COLOR_U(128) |\n\t\t\t\t\tAFBC_DEF_COLOR_V(128);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->viu.vd1_if0_gen_reg = 0;\n\t\tpriv->viu.vd1_if0_canvas0 = 0;\n\t\tpriv->viu.viu_vd1_fmt_ctrl = 0;\n\t} else {\n\t\tpriv->viu.vd1_afbc = false;\n\n\t\tpriv->viu.vd1_if0_gen_reg = VD_URGENT_CHROMA |\n\t\t\t\t\t    VD_URGENT_LUMA |\n\t\t\t\t\t    VD_HOLD_LINES(9) |\n\t\t\t\t\t    VD_CHRO_RPT_LASTL_CTRL |\n\t\t\t\t\t    VD_ENABLE;\n\t}\n\n\t \n\tmeson_overlay_setup_scaler_params(priv, plane, interlace_mode);\n\n\tpriv->viu.vd1_if0_repeat_loop = 0;\n\tpriv->viu.vd1_if0_luma0_rpt_pat = interlace_mode ? 8 : 0;\n\tpriv->viu.vd1_if0_chroma0_rpt_pat = interlace_mode ? 8 : 0;\n\tpriv->viu.vd1_range_map_y = 0;\n\tpriv->viu.vd1_range_map_cb = 0;\n\tpriv->viu.vd1_range_map_cr = 0;\n\n\t \n\tpriv->viu.vd1_if0_gen_reg2 = 0;\n\tpriv->viu.viu_vd1_fmt_ctrl = 0;\n\n\t \n\tswitch (fb->format->format) {\n\t \n\tcase DRM_FORMAT_YUYV:\n\t\tpriv->viu.vd1_if0_gen_reg |= VD_BYTES_PER_PIXEL(1);\n\t\tpriv->viu.vd1_if0_canvas0 =\n\t\t\t\t\tCANVAS_ADDR2(priv->canvas_id_vd1_0) |\n\t\t\t\t\tCANVAS_ADDR1(priv->canvas_id_vd1_0) |\n\t\t\t\t\tCANVAS_ADDR0(priv->canvas_id_vd1_0);\n\t\tpriv->viu.viu_vd1_fmt_ctrl = VD_HORZ_Y_C_RATIO(1) |  \n\t\t\t\t\t     VD_HORZ_FMT_EN |\n\t\t\t\t\t     VD_VERT_RPT_LINE0 |\n\t\t\t\t\t     VD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\t     VD_VERT_PHASE_STEP(16) |  \n\t\t\t\t\t     VD_VERT_FMT_EN;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\tpriv->viu.vd1_if0_gen_reg |= VD_SEPARATE_EN;\n\t\tpriv->viu.vd1_if0_canvas0 =\n\t\t\t\t\tCANVAS_ADDR2(priv->canvas_id_vd1_1) |\n\t\t\t\t\tCANVAS_ADDR1(priv->canvas_id_vd1_1) |\n\t\t\t\t\tCANVAS_ADDR0(priv->canvas_id_vd1_0);\n\t\tif (fb->format->format == DRM_FORMAT_NV12)\n\t\t\tpriv->viu.vd1_if0_gen_reg2 = VD_COLOR_MAP(1);\n\t\telse\n\t\t\tpriv->viu.vd1_if0_gen_reg2 = VD_COLOR_MAP(2);\n\t\tpriv->viu.viu_vd1_fmt_ctrl = VD_HORZ_Y_C_RATIO(1) |  \n\t\t\t\t\t     VD_HORZ_FMT_EN |\n\t\t\t\t\t     VD_VERT_RPT_LINE0 |\n\t\t\t\t\t     VD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\t     VD_VERT_PHASE_STEP(8) |  \n\t\t\t\t\t     VD_VERT_FMT_EN;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV444:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YUV411:\n\tcase DRM_FORMAT_YUV410:\n\t\tpriv->viu.vd1_if0_gen_reg |= VD_SEPARATE_EN;\n\t\tpriv->viu.vd1_if0_canvas0 =\n\t\t\t\t\tCANVAS_ADDR2(priv->canvas_id_vd1_2) |\n\t\t\t\t\tCANVAS_ADDR1(priv->canvas_id_vd1_1) |\n\t\t\t\t\tCANVAS_ADDR0(priv->canvas_id_vd1_0);\n\t\tswitch (fb->format->format) {\n\t\tcase DRM_FORMAT_YUV422:\n\t\t\tpriv->viu.viu_vd1_fmt_ctrl =\n\t\t\t\t\tVD_HORZ_Y_C_RATIO(1) |  \n\t\t\t\t\tVD_HORZ_FMT_EN |\n\t\t\t\t\tVD_VERT_RPT_LINE0 |\n\t\t\t\t\tVD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\tVD_VERT_PHASE_STEP(16) |  \n\t\t\t\t\tVD_VERT_FMT_EN;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUV420:\n\t\t\tpriv->viu.viu_vd1_fmt_ctrl =\n\t\t\t\t\tVD_HORZ_Y_C_RATIO(1) |  \n\t\t\t\t\tVD_HORZ_FMT_EN |\n\t\t\t\t\tVD_VERT_RPT_LINE0 |\n\t\t\t\t\tVD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\tVD_VERT_PHASE_STEP(8) |  \n\t\t\t\t\tVD_VERT_FMT_EN;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUV411:\n\t\t\tpriv->viu.viu_vd1_fmt_ctrl =\n\t\t\t\t\tVD_HORZ_Y_C_RATIO(2) |  \n\t\t\t\t\tVD_HORZ_FMT_EN |\n\t\t\t\t\tVD_VERT_RPT_LINE0 |\n\t\t\t\t\tVD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\tVD_VERT_PHASE_STEP(16) |  \n\t\t\t\t\tVD_VERT_FMT_EN;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUV410:\n\t\t\tpriv->viu.viu_vd1_fmt_ctrl =\n\t\t\t\t\tVD_HORZ_Y_C_RATIO(2) |  \n\t\t\t\t\tVD_HORZ_FMT_EN |\n\t\t\t\t\tVD_VERT_RPT_LINE0 |\n\t\t\t\t\tVD_VERT_INITIAL_PHASE(12) |\n\t\t\t\t\tVD_VERT_PHASE_STEP(8) |  \n\t\t\t\t\tVD_VERT_FMT_EN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tpriv->viu.vd1_planes = fb->format->num_planes;\n\n\tswitch (priv->viu.vd1_planes) {\n\tcase 3:\n\t\tgem = drm_fb_dma_get_gem_obj(fb, 2);\n\t\tpriv->viu.vd1_addr2 = gem->dma_addr + fb->offsets[2];\n\t\tpriv->viu.vd1_stride2 = fb->pitches[2];\n\t\tpriv->viu.vd1_height2 =\n\t\t\tdrm_format_info_plane_height(fb->format,\n\t\t\t\t\t\tfb->height, 2);\n\t\tDRM_DEBUG(\"plane 2 addr 0x%x stride %d height %d\\n\",\n\t\t\t priv->viu.vd1_addr2,\n\t\t\t priv->viu.vd1_stride2,\n\t\t\t priv->viu.vd1_height2);\n\t\tfallthrough;\n\tcase 2:\n\t\tgem = drm_fb_dma_get_gem_obj(fb, 1);\n\t\tpriv->viu.vd1_addr1 = gem->dma_addr + fb->offsets[1];\n\t\tpriv->viu.vd1_stride1 = fb->pitches[1];\n\t\tpriv->viu.vd1_height1 =\n\t\t\tdrm_format_info_plane_height(fb->format,\n\t\t\t\t\t\tfb->height, 1);\n\t\tDRM_DEBUG(\"plane 1 addr 0x%x stride %d height %d\\n\",\n\t\t\t priv->viu.vd1_addr1,\n\t\t\t priv->viu.vd1_stride1,\n\t\t\t priv->viu.vd1_height1);\n\t\tfallthrough;\n\tcase 1:\n\t\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\t\tpriv->viu.vd1_addr0 = gem->dma_addr + fb->offsets[0];\n\t\tpriv->viu.vd1_stride0 = fb->pitches[0];\n\t\tpriv->viu.vd1_height0 =\n\t\t\tdrm_format_info_plane_height(fb->format,\n\t\t\t\t\t\t     fb->height, 0);\n\t\tDRM_DEBUG(\"plane 0 addr 0x%x stride %d height %d\\n\",\n\t\t\t priv->viu.vd1_addr0,\n\t\t\t priv->viu.vd1_stride0,\n\t\t\t priv->viu.vd1_height0);\n\t}\n\n\tif (priv->viu.vd1_afbc) {\n\t\tif (priv->viu.vd1_afbc_mode & AFBC_SCATTER_MODE) {\n\t\t\t \n\t\t\tpriv->viu.vd1_afbc_head_addr = priv->viu.vd1_addr0 >> 4;\n\t\t\tpriv->viu.vd1_afbc_body_addr = 0;\n\t\t} else {\n\t\t\t \n\t\t\tunsigned long block_size = 4096;\n\t\t\tunsigned long body_size;\n\n\t\t\t \n\t\t\tif (priv->viu.vd1_afbc_mode & AFBC_BLK_MEM_MODE)\n\t\t\t\tblock_size = 3072;\n\n\t\t\tbody_size = (ALIGN(priv->viu.vd1_stride0, 64) / 64) *\n\t\t\t\t    (ALIGN(priv->viu.vd1_height0, 32) / 32) *\n\t\t\t\t    block_size;\n\n\t\t\tpriv->viu.vd1_afbc_body_addr = priv->viu.vd1_addr0 >> 4;\n\t\t\t \n\t\t\tpriv->viu.vd1_afbc_head_addr = (priv->viu.vd1_addr0 +\n\t\t\t\t\t\t\tbody_size) >> 4;\n\t\t}\n\t}\n\n\tpriv->viu.vd1_enabled = true;\n\n\tspin_unlock_irqrestore(&priv->drm->event_lock, flags);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n}\n\nstatic void meson_overlay_atomic_disable(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct meson_overlay *meson_overlay = to_meson_overlay(plane);\n\tstruct meson_drm *priv = meson_overlay->priv;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tpriv->viu.vd1_enabled = false;\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\twritel_relaxed(0, priv->io_base + _REG(VD1_BLEND_SRC_CTRL));\n\t\twritel_relaxed(0, priv->io_base + _REG(VD2_BLEND_SRC_CTRL));\n\t\twritel_relaxed(0, priv->io_base + _REG(VD1_IF0_GEN_REG + 0x17b0));\n\t\twritel_relaxed(0, priv->io_base + _REG(VD2_IF0_GEN_REG + 0x17b0));\n\t} else\n\t\twritel_bits_relaxed(VPP_VD1_POSTBLEND | VPP_VD1_PREBLEND, 0,\n\t\t\t\t    priv->io_base + _REG(VPP_MISC));\n\n}\n\nstatic const struct drm_plane_helper_funcs meson_overlay_helper_funcs = {\n\t.atomic_check\t= meson_overlay_atomic_check,\n\t.atomic_disable\t= meson_overlay_atomic_disable,\n\t.atomic_update\t= meson_overlay_atomic_update,\n};\n\nstatic bool meson_overlay_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t       u32 format, u64 modifier)\n{\n\tif (modifier == DRM_FORMAT_MOD_LINEAR &&\n\t    format != DRM_FORMAT_YUV420_8BIT &&\n\t    format != DRM_FORMAT_YUV420_10BIT)\n\t\treturn true;\n\n\tif ((modifier & DRM_FORMAT_MOD_AMLOGIC_FBC(0, 0)) ==\n\t\t\tDRM_FORMAT_MOD_AMLOGIC_FBC(0, 0)) {\n\t\tunsigned int layout = modifier &\n\t\t\tDRM_FORMAT_MOD_AMLOGIC_FBC(\n\t\t\t\t__fourcc_mod_amlogic_layout_mask, 0);\n\t\tunsigned int options =\n\t\t\t(modifier >> __fourcc_mod_amlogic_options_shift) &\n\t\t\t__fourcc_mod_amlogic_options_mask;\n\n\t\tif (format != DRM_FORMAT_YUV420_8BIT &&\n\t\t    format != DRM_FORMAT_YUV420_10BIT) {\n\t\t\tDRM_DEBUG_KMS(\"%llx invalid format 0x%08x\\n\",\n\t\t\t\t      modifier, format);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (layout != AMLOGIC_FBC_LAYOUT_BASIC &&\n\t\t    layout != AMLOGIC_FBC_LAYOUT_SCATTER) {\n\t\t\tDRM_DEBUG_KMS(\"%llx invalid layout %x\\n\",\n\t\t\t\t      modifier, layout);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (options &&\n\t\t    options != AMLOGIC_FBC_OPTION_MEM_SAVING) {\n\t\t\tDRM_DEBUG_KMS(\"%llx invalid layout %x\\n\",\n\t\t\t\t      modifier, layout);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tDRM_DEBUG_KMS(\"invalid modifier %llx for format 0x%08x\\n\",\n\t\t      modifier, format);\n\n\treturn false;\n}\n\nstatic const struct drm_plane_funcs meson_overlay_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\t.format_mod_supported   = meson_overlay_format_mod_supported,\n};\n\nstatic const uint32_t supported_drm_formats[] = {\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV410,\n\tDRM_FORMAT_YUV420_8BIT,  \n\tDRM_FORMAT_YUV420_10BIT,  \n};\n\nstatic const uint64_t format_modifiers[] = {\n\tDRM_FORMAT_MOD_AMLOGIC_FBC(AMLOGIC_FBC_LAYOUT_SCATTER,\n\t\t\t\t   AMLOGIC_FBC_OPTION_MEM_SAVING),\n\tDRM_FORMAT_MOD_AMLOGIC_FBC(AMLOGIC_FBC_LAYOUT_BASIC,\n\t\t\t\t   AMLOGIC_FBC_OPTION_MEM_SAVING),\n\tDRM_FORMAT_MOD_AMLOGIC_FBC(AMLOGIC_FBC_LAYOUT_SCATTER, 0),\n\tDRM_FORMAT_MOD_AMLOGIC_FBC(AMLOGIC_FBC_LAYOUT_BASIC, 0),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nint meson_overlay_create(struct meson_drm *priv)\n{\n\tstruct meson_overlay *meson_overlay;\n\tstruct drm_plane *plane;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tmeson_overlay = devm_kzalloc(priv->drm->dev, sizeof(*meson_overlay),\n\t\t\t\t   GFP_KERNEL);\n\tif (!meson_overlay)\n\t\treturn -ENOMEM;\n\n\tmeson_overlay->priv = priv;\n\tplane = &meson_overlay->base;\n\n\tdrm_universal_plane_init(priv->drm, plane, 0xFF,\n\t\t\t\t &meson_overlay_funcs,\n\t\t\t\t supported_drm_formats,\n\t\t\t\t ARRAY_SIZE(supported_drm_formats),\n\t\t\t\t format_modifiers,\n\t\t\t\t DRM_PLANE_TYPE_OVERLAY, \"meson_overlay_plane\");\n\n\tdrm_plane_helper_add(plane, &meson_overlay_helper_funcs);\n\n\t \n\tdrm_plane_create_zpos_immutable_property(plane, 0);\n\n\tpriv->overlay_plane = plane;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}