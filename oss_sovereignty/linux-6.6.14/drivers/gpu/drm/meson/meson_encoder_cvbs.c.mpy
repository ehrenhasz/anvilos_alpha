{
  "module_name": "meson_encoder_cvbs.c",
  "hash_id": "9601688cdd4ea69277e0976b4dec3b978363d10a1a4b70fa77127c940d75e9ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_encoder_cvbs.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"meson_registers.h\"\n#include \"meson_vclk.h\"\n#include \"meson_encoder_cvbs.h\"\n\n \n#define HHI_VDAC_CNTL0\t\t0x2F4  \n#define HHI_VDAC_CNTL0_G12A\t0x2EC  \n#define HHI_VDAC_CNTL1\t\t0x2F8  \n#define HHI_VDAC_CNTL1_G12A\t0x2F0  \n\nstruct meson_encoder_cvbs {\n\tstruct drm_encoder\tencoder;\n\tstruct drm_bridge\tbridge;\n\tstruct drm_bridge\t*next_bridge;\n\tstruct meson_drm\t*priv;\n};\n\n#define bridge_to_meson_encoder_cvbs(x) \\\n\tcontainer_of(x, struct meson_encoder_cvbs, bridge)\n\n \n\nstruct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT] = {\n\t{  \n\t\t.enci = &meson_cvbs_enci_pal,\n\t\t.mode = {\n\t\t\tDRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 13500,\n\t\t\t\t 720, 732, 795, 864, 0, 576, 580, 586, 625, 0,\n\t\t\t\t DRM_MODE_FLAG_INTERLACE),\n\t\t\t.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,\n\t\t},\n\t},\n\t{  \n\t\t.enci = &meson_cvbs_enci_ntsc,\n\t\t.mode = {\n\t\t\tDRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 13500,\n\t\t\t\t720, 739, 801, 858, 0, 480, 488, 494, 525, 0,\n\t\t\t\tDRM_MODE_FLAG_INTERLACE),\n\t\t\t.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,\n\t\t},\n\t},\n};\n\nstatic const struct meson_cvbs_mode *\nmeson_cvbs_get_mode(const struct drm_display_mode *req_mode)\n{\n\tint i;\n\n\tfor (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {\n\t\tstruct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];\n\n\t\tif (drm_mode_match(req_mode, &meson_mode->mode,\n\t\t\t\t   DRM_MODE_MATCH_TIMINGS |\n\t\t\t\t   DRM_MODE_MATCH_CLOCK |\n\t\t\t\t   DRM_MODE_MATCH_FLAGS |\n\t\t\t\t   DRM_MODE_MATCH_3D_FLAGS))\n\t\t\treturn meson_mode;\n\t}\n\n\treturn NULL;\n}\n\nstatic int meson_encoder_cvbs_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct meson_encoder_cvbs *meson_encoder_cvbs =\n\t\t\t\t\tbridge_to_meson_encoder_cvbs(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, meson_encoder_cvbs->next_bridge,\n\t\t\t\t &meson_encoder_cvbs->bridge, flags);\n}\n\nstatic int meson_encoder_cvbs_get_modes(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct meson_encoder_cvbs *meson_encoder_cvbs =\n\t\t\t\t\tbridge_to_meson_encoder_cvbs(bridge);\n\tstruct meson_drm *priv = meson_encoder_cvbs->priv;\n\tstruct drm_display_mode *mode;\n\tint i;\n\n\tfor (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {\n\t\tstruct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];\n\n\t\tmode = drm_mode_duplicate(priv->drm, &meson_mode->mode);\n\t\tif (!mode) {\n\t\t\tdev_err(priv->dev, \"Failed to create a new display mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\treturn i;\n}\n\nstatic enum drm_mode_status\nmeson_encoder_cvbs_mode_valid(struct drm_bridge *bridge,\n\t\t\t      const struct drm_display_info *display_info,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tif (meson_cvbs_get_mode(mode))\n\t\treturn MODE_OK;\n\n\treturn MODE_BAD;\n}\n\nstatic int meson_encoder_cvbs_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tif (meson_cvbs_get_mode(&crtc_state->mode))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void meson_encoder_cvbs_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_cvbs *encoder_cvbs = bridge_to_meson_encoder_cvbs(bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tstruct meson_drm *priv = encoder_cvbs->priv;\n\tconst struct meson_cvbs_mode *meson_mode;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\treturn;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\tmeson_mode = meson_cvbs_get_mode(&crtc_state->adjusted_mode);\n\tif (WARN_ON(!meson_mode))\n\t\treturn;\n\n\tmeson_venci_cvbs_mode_set(priv, meson_mode->enci);\n\n\t \n\tmeson_vclk_setup(priv, MESON_VCLK_TARGET_CVBS,\n\t\t\t MESON_VCLK_CVBS, MESON_VCLK_CVBS,\n\t\t\t MESON_VCLK_CVBS, MESON_VCLK_CVBS,\n\t\t\t true);\n\n\t \n\twritel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,\n\t\t\t    priv->io_base + _REG(VENC_VDAC_DACSEL0));\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t\t meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);\n\t} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);\n\t}\n}\n\nstatic void meson_encoder_cvbs_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_cvbs *meson_encoder_cvbs =\n\t\t\t\t\tbridge_to_meson_encoder_cvbs(bridge);\n\tstruct meson_drm *priv = meson_encoder_cvbs->priv;\n\n\t \n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);\n\t} else {\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);\n\t\tregmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);\n\t}\n}\n\nstatic const struct drm_bridge_funcs meson_encoder_cvbs_bridge_funcs = {\n\t.attach = meson_encoder_cvbs_attach,\n\t.mode_valid = meson_encoder_cvbs_mode_valid,\n\t.get_modes = meson_encoder_cvbs_get_modes,\n\t.atomic_enable = meson_encoder_cvbs_atomic_enable,\n\t.atomic_disable = meson_encoder_cvbs_atomic_disable,\n\t.atomic_check = meson_encoder_cvbs_atomic_check,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nint meson_encoder_cvbs_init(struct meson_drm *priv)\n{\n\tstruct drm_device *drm = priv->drm;\n\tstruct meson_encoder_cvbs *meson_encoder_cvbs;\n\tstruct drm_connector *connector;\n\tstruct device_node *remote;\n\tint ret;\n\n\tmeson_encoder_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_encoder_cvbs), GFP_KERNEL);\n\tif (!meson_encoder_cvbs)\n\t\treturn -ENOMEM;\n\n\t \n\tremote = of_graph_get_remote_node(priv->dev->of_node, 0, 0);\n\tif (!remote) {\n\t\tdev_info(drm->dev, \"CVBS Output connector not available\\n\");\n\t\treturn 0;\n\t}\n\n\tmeson_encoder_cvbs->next_bridge = of_drm_find_bridge(remote);\n\tof_node_put(remote);\n\tif (!meson_encoder_cvbs->next_bridge) {\n\t\tdev_err(priv->dev, \"Failed to find CVBS Connector bridge\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tmeson_encoder_cvbs->bridge.funcs = &meson_encoder_cvbs_bridge_funcs;\n\tmeson_encoder_cvbs->bridge.of_node = priv->dev->of_node;\n\tmeson_encoder_cvbs->bridge.type = DRM_MODE_CONNECTOR_Composite;\n\tmeson_encoder_cvbs->bridge.ops = DRM_BRIDGE_OP_MODES;\n\tmeson_encoder_cvbs->bridge.interlace_allowed = true;\n\n\tdrm_bridge_add(&meson_encoder_cvbs->bridge);\n\n\tmeson_encoder_cvbs->priv = priv;\n\n\t \n\tret = drm_simple_encoder_init(priv->drm, &meson_encoder_cvbs->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TVDAC);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to init CVBS encoder: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmeson_encoder_cvbs->encoder.possible_crtcs = BIT(0);\n\n\t \n\tret = drm_bridge_attach(&meson_encoder_cvbs->encoder, &meson_encoder_cvbs->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to attach bridge: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tconnector = drm_bridge_connector_init(priv->drm, &meson_encoder_cvbs->encoder);\n\tif (IS_ERR(connector)) {\n\t\tdev_err(priv->dev, \"Unable to create CVBS bridge connector\\n\");\n\t\treturn PTR_ERR(connector);\n\t}\n\tdrm_connector_attach_encoder(connector, &meson_encoder_cvbs->encoder);\n\n\tpriv->encoders[MESON_ENC_CVBS] = meson_encoder_cvbs;\n\n\treturn 0;\n}\n\nvoid meson_encoder_cvbs_remove(struct meson_drm *priv)\n{\n\tstruct meson_encoder_cvbs *meson_encoder_cvbs;\n\n\tif (priv->encoders[MESON_ENC_CVBS]) {\n\t\tmeson_encoder_cvbs = priv->encoders[MESON_ENC_CVBS];\n\t\tdrm_bridge_remove(&meson_encoder_cvbs->bridge);\n\t\tdrm_bridge_remove(meson_encoder_cvbs->next_bridge);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}