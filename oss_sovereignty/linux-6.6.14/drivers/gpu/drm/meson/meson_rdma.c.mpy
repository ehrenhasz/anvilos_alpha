{
  "module_name": "meson_rdma.c",
  "hash_id": "a42e80d481a7f15eeaf4311ca3d3fa87c5b2aa305b5f7f9a923b98ae58cf93f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_rdma.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/dma-mapping.h>\n\n#include \"meson_drv.h\"\n#include \"meson_registers.h\"\n#include \"meson_rdma.h\"\n\n \n\n#define RDMA_DESC_SIZE\t(sizeof(uint32_t) * 2)\n\nint meson_rdma_init(struct meson_drm *priv)\n{\n\tif (!priv->rdma.addr) {\n\t\t \n\t\tpriv->rdma.addr =\n\t\t\tdma_alloc_coherent(priv->dev, SZ_4K,\n\t\t\t\t\t   &priv->rdma.addr_dma,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!priv->rdma.addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpriv->rdma.offset = 0;\n\n\twritel_relaxed(RDMA_CTRL_SW_RESET,\n\t\t       priv->io_base + _REG(RDMA_CTRL));\n\twritel_relaxed(RDMA_DEFAULT_CONFIG |\n\t\t       FIELD_PREP(RDMA_CTRL_AHB_WR_BURST, 3) |\n\t\t       FIELD_PREP(RDMA_CTRL_AHB_RD_BURST, 0),\n\t\t       priv->io_base + _REG(RDMA_CTRL));\n\n\treturn 0;\n}\n\nvoid meson_rdma_free(struct meson_drm *priv)\n{\n\tif (!priv->rdma.addr && !priv->rdma.addr_dma)\n\t\treturn;\n\n\tmeson_rdma_stop(priv);\n\n\tdma_free_coherent(priv->dev, SZ_4K,\n\t\t\t  priv->rdma.addr, priv->rdma.addr_dma);\n\n\tpriv->rdma.addr = NULL;\n\tpriv->rdma.addr_dma = (dma_addr_t)0;\n}\n\nvoid meson_rdma_setup(struct meson_drm *priv)\n{\n\t \n\twritel_bits_relaxed(RDMA_ACCESS_RW_FLAG_CHAN1 |\n\t\t\t    RDMA_ACCESS_ADDR_INC_CHAN1,\n\t\t\t    RDMA_ACCESS_RW_FLAG_CHAN1,\n\t\t\t    priv->io_base + _REG(RDMA_ACCESS_AUTO));\n}\n\nvoid meson_rdma_stop(struct meson_drm *priv)\n{\n\twritel_bits_relaxed(RDMA_IRQ_CLEAR_CHAN1,\n\t\t\t    RDMA_IRQ_CLEAR_CHAN1,\n\t\t\t    priv->io_base + _REG(RDMA_CTRL));\n\n\t \n\twritel_bits_relaxed(RDMA_ACCESS_TRIGGER_CHAN1,\n\t\t\t    FIELD_PREP(RDMA_ACCESS_ADDR_INC_CHAN1,\n\t\t\t\t       RDMA_ACCESS_TRIGGER_STOP),\n\t\t\t    priv->io_base + _REG(RDMA_ACCESS_AUTO));\n}\n\nvoid meson_rdma_reset(struct meson_drm *priv)\n{\n\tmeson_rdma_stop(priv);\n\n\tpriv->rdma.offset = 0;\n}\n\nstatic void meson_rdma_writel(struct meson_drm *priv, uint32_t val,\n\t\t\t      uint32_t reg)\n{\n\tif (priv->rdma.offset >= (SZ_4K / RDMA_DESC_SIZE)) {\n\t\tdev_warn_once(priv->dev, \"%s: overflow\\n\", __func__);\n\t\treturn;\n\t}\n\n\tpriv->rdma.addr[priv->rdma.offset++] = reg;\n\tpriv->rdma.addr[priv->rdma.offset++] = val;\n}\n\n \nvoid meson_rdma_writel_sync(struct meson_drm *priv, uint32_t val, uint32_t reg)\n{\n\tmeson_rdma_writel(priv, val, reg);\n\n\twritel_relaxed(val, priv->io_base + _REG(reg));\n}\n\nvoid meson_rdma_flush(struct meson_drm *priv)\n{\n\tmeson_rdma_stop(priv);\n\n\t \n\twritel(priv->rdma.addr_dma,\n\t       priv->io_base + _REG(RDMA_AHB_START_ADDR_1));\n\n\t \n\twritel(priv->rdma.addr_dma + (priv->rdma.offset * RDMA_DESC_SIZE) - 1,\n\t       priv->io_base + _REG(RDMA_AHB_END_ADDR_1));\n\n\t \n\twritel_bits_relaxed(RDMA_ACCESS_TRIGGER_CHAN1,\n\t\t\t    FIELD_PREP(RDMA_ACCESS_TRIGGER_CHAN1,\n\t\t\t\t       RDMA_ACCESS_TRIGGER_VSYNC),\n\t\t\t    priv->io_base + _REG(RDMA_ACCESS_AUTO));\n\n\tpriv->rdma.offset = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}