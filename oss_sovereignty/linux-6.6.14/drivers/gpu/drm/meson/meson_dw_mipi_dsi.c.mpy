{
  "module_name": "meson_dw_mipi_dsi.c",
  "hash_id": "da6a40f8c82f8cdd7dcd50a3ab771629eb26c7fb5141e4170dfad21a82f6d0a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_dw_mipi_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/phy/phy.h>\n#include <linux/bitfield.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/bridge/dw_mipi_dsi.h>\n#include <drm/drm_mipi_dsi.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_print.h>\n\n#include \"meson_drv.h\"\n#include \"meson_dw_mipi_dsi.h\"\n#include \"meson_registers.h\"\n#include \"meson_venc.h\"\n\n#define DRIVER_NAME \"meson-dw-mipi-dsi\"\n#define DRIVER_DESC \"Amlogic Meson MIPI-DSI DRM driver\"\n\nstruct meson_dw_mipi_dsi {\n\tstruct meson_drm *priv;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct phy *phy;\n\tunion phy_configure_opts phy_opts;\n\tstruct dw_mipi_dsi *dmd;\n\tstruct dw_mipi_dsi_plat_data pdata;\n\tstruct mipi_dsi_device *dsi_device;\n\tconst struct drm_display_mode *mode;\n\tstruct clk *bit_clk;\n\tstruct clk *px_clk;\n\tstruct reset_control *top_rst;\n};\n\n#define encoder_to_meson_dw_mipi_dsi(x) \\\n\tcontainer_of(x, struct meson_dw_mipi_dsi, encoder)\n\nstatic void meson_dw_mipi_dsi_hw_init(struct meson_dw_mipi_dsi *mipi_dsi)\n{\n\t \n\twritel_bits_relaxed(MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |\n\t\t\t    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,\n\t\t\t    MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |\n\t\t\t    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,\n\t\t\t    mipi_dsi->base + MIPI_DSI_TOP_SW_RESET);\n\twritel_bits_relaxed(MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |\n\t\t\t    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,\n\t\t\t    0, mipi_dsi->base + MIPI_DSI_TOP_SW_RESET);\n\n\t \n\twritel_bits_relaxed(MIPI_DSI_TOP_CLK_SYSCLK_EN | MIPI_DSI_TOP_CLK_PIXCLK_EN,\n\t\t\t    MIPI_DSI_TOP_CLK_SYSCLK_EN | MIPI_DSI_TOP_CLK_PIXCLK_EN,\n\t\t\t    mipi_dsi->base + MIPI_DSI_TOP_CLK_CNTL);\n\n\t \n\twritel_relaxed(0, mipi_dsi->base + MIPI_DSI_TOP_MEM_PD);\n}\n\nstatic int dw_mipi_dsi_phy_init(void *priv_data)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\tunsigned int dpi_data_format, venc_data_width;\n\tint ret;\n\n\t \n\tret = clk_set_rate(mipi_dsi->bit_clk,\n\t\t\t   mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate);\n\tif (ret) {\n\t\tdev_err(mipi_dsi->dev, \"Failed to set DSI Bit clock rate %lu (ret %d)\\n\",\n\t\t\tmipi_dsi->phy_opts.mipi_dphy.hs_clk_rate, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_rate_exclusive_get(mipi_dsi->bit_clk);\n\tif (ret) {\n\t\tdev_err(mipi_dsi->dev,\n\t\t\t\"Failed to set the exclusivity on the bit clock rate (ret %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(mipi_dsi->px_clk, mipi_dsi->mode->clock * 1000);\n\n\tif (ret) {\n\t\tdev_err(mipi_dsi->dev, \"Failed to set DSI Pixel clock rate %u (%d)\\n\",\n\t\t\tmipi_dsi->mode->clock * 1000, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (mipi_dsi->dsi_device->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tdpi_data_format = DPI_COLOR_24BIT;\n\t\tvenc_data_width = VENC_IN_COLOR_24B;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tdpi_data_format = DPI_COLOR_18BIT_CFG_2;\n\t\tvenc_data_width = VENC_IN_COLOR_18B;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twritel_relaxed(FIELD_PREP(MIPI_DSI_TOP_DPI_COLOR_MODE, dpi_data_format) |\n\t\t       FIELD_PREP(MIPI_DSI_TOP_IN_COLOR_MODE, venc_data_width) |\n\t\t       FIELD_PREP(MIPI_DSI_TOP_COMP2_SEL, 2) |\n\t\t       FIELD_PREP(MIPI_DSI_TOP_COMP1_SEL, 1) |\n\t\t       FIELD_PREP(MIPI_DSI_TOP_COMP0_SEL, 0),\n\t\t\tmipi_dsi->base + MIPI_DSI_TOP_CNTL);\n\n\treturn phy_configure(mipi_dsi->phy, &mipi_dsi->phy_opts);\n}\n\nstatic void dw_mipi_dsi_phy_power_on(void *priv_data)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\n\tif (phy_power_on(mipi_dsi->phy))\n\t\tdev_warn(mipi_dsi->dev, \"Failed to power on PHY\\n\");\n}\n\nstatic void dw_mipi_dsi_phy_power_off(void *priv_data)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\n\tif (phy_power_off(mipi_dsi->phy))\n\t\tdev_warn(mipi_dsi->dev, \"Failed to power off PHY\\n\");\n\n\t \n\tclk_rate_exclusive_put(mipi_dsi->bit_clk);\n}\n\nstatic int\ndw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,\n\t\t\t  unsigned long mode_flags, u32 lanes, u32 format,\n\t\t\t  unsigned int *lane_mbps)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\tint bpp;\n\n\tmipi_dsi->mode = mode;\n\n\tbpp = mipi_dsi_pixel_format_to_bpp(mipi_dsi->dsi_device->format);\n\n\tphy_mipi_dphy_get_default_config(mode->clock * 1000,\n\t\t\t\t\t bpp, mipi_dsi->dsi_device->lanes,\n\t\t\t\t\t &mipi_dsi->phy_opts.mipi_dphy);\n\n\t*lane_mbps = DIV_ROUND_UP(mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate, USEC_PER_SEC);\n\n\treturn 0;\n}\n\nstatic int\ndw_mipi_dsi_phy_get_timing(void *priv_data, unsigned int lane_mbps,\n\t\t\t   struct dw_mipi_dsi_dphy_timing *timing)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\n\tswitch (mipi_dsi->mode->hdisplay) {\n\tcase 240:\n\tcase 768:\n\tcase 1920:\n\tcase 2560:\n\t\ttiming->clk_lp2hs = 23;\n\t\ttiming->clk_hs2lp = 38;\n\t\ttiming->data_lp2hs = 15;\n\t\ttiming->data_hs2lp = 9;\n\t\tbreak;\n\n\tdefault:\n\t\ttiming->clk_lp2hs = 37;\n\t\ttiming->clk_hs2lp = 135;\n\t\ttiming->data_lp2hs = 50;\n\t\ttiming->data_hs2lp = 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndw_mipi_dsi_get_esc_clk_rate(void *priv_data, unsigned int *esc_clk_rate)\n{\n\t*esc_clk_rate = 4;  \n\n\treturn 0;\n}\n\nstatic const struct dw_mipi_dsi_phy_ops meson_dw_mipi_dsi_phy_ops = {\n\t.init = dw_mipi_dsi_phy_init,\n\t.power_on = dw_mipi_dsi_phy_power_on,\n\t.power_off = dw_mipi_dsi_phy_power_off,\n\t.get_lane_mbps = dw_mipi_dsi_get_lane_mbps,\n\t.get_timing = dw_mipi_dsi_phy_get_timing,\n\t.get_esc_clk_rate = dw_mipi_dsi_get_esc_clk_rate,\n};\n\nstatic int meson_dw_mipi_dsi_host_attach(void *priv_data,\n\t\t\t\t\t struct mipi_dsi_device *device)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\tint ret;\n\n\tmipi_dsi->dsi_device = device;\n\n\tswitch (device->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tdev_err(mipi_dsi->dev, \"invalid pixel format %d\\n\", device->format);\n\t\treturn -EINVAL;\n\t}\n\n\tret = phy_init(mipi_dsi->phy);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_dw_mipi_dsi_hw_init(mipi_dsi);\n\n\treturn 0;\n}\n\nstatic int meson_dw_mipi_dsi_host_detach(void *priv_data,\n\t\t\t\t\t struct mipi_dsi_device *device)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = priv_data;\n\n\tif (device == mipi_dsi->dsi_device)\n\t\tmipi_dsi->dsi_device = NULL;\n\telse\n\t\treturn -EINVAL;\n\n\treturn phy_exit(mipi_dsi->phy);\n}\n\nstatic const struct dw_mipi_dsi_host_ops meson_dw_mipi_dsi_host_ops = {\n\t.attach = meson_dw_mipi_dsi_host_attach,\n\t.detach = meson_dw_mipi_dsi_host_detach,\n};\n\nstatic int meson_dw_mipi_dsi_probe(struct platform_device *pdev)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi;\n\tstruct device *dev = &pdev->dev;\n\n\tmipi_dsi = devm_kzalloc(dev, sizeof(*mipi_dsi), GFP_KERNEL);\n\tif (!mipi_dsi)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mipi_dsi->base))\n\t\treturn PTR_ERR(mipi_dsi->base);\n\n\tmipi_dsi->phy = devm_phy_get(dev, \"dphy\");\n\tif (IS_ERR(mipi_dsi->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(mipi_dsi->phy),\n\t\t\t\t     \"failed to get mipi dphy\\n\");\n\n\tmipi_dsi->bit_clk = devm_clk_get_enabled(dev, \"bit\");\n\tif (IS_ERR(mipi_dsi->bit_clk)) {\n\t\tint ret = PTR_ERR(mipi_dsi->bit_clk);\n\n\t\t \n\t\tif (ret == -EIO)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\treturn dev_err_probe(dev, ret, \"Unable to get enabled bit_clk\\n\");\n\t}\n\n\tmipi_dsi->px_clk = devm_clk_get_enabled(dev, \"px\");\n\tif (IS_ERR(mipi_dsi->px_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(mipi_dsi->px_clk),\n\t\t\t\t     \"Unable to get enabled px_clk\\n\");\n\n\t \n\tmipi_dsi->top_rst = devm_reset_control_get_exclusive(dev, \"top\");\n\tif (IS_ERR(mipi_dsi->top_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(mipi_dsi->top_rst),\n\t\t\t\t     \"Unable to get reset control\\n\");\n\n\treset_control_assert(mipi_dsi->top_rst);\n\tusleep_range(10, 20);\n\treset_control_deassert(mipi_dsi->top_rst);\n\n\t \n\n\tmipi_dsi->dev = dev;\n\tmipi_dsi->pdata.base = mipi_dsi->base;\n\tmipi_dsi->pdata.max_data_lanes = 4;\n\tmipi_dsi->pdata.phy_ops = &meson_dw_mipi_dsi_phy_ops;\n\tmipi_dsi->pdata.host_ops = &meson_dw_mipi_dsi_host_ops;\n\tmipi_dsi->pdata.priv_data = mipi_dsi;\n\tplatform_set_drvdata(pdev, mipi_dsi);\n\n\tmipi_dsi->dmd = dw_mipi_dsi_probe(pdev, &mipi_dsi->pdata);\n\tif (IS_ERR(mipi_dsi->dmd))\n\t\treturn dev_err_probe(dev, PTR_ERR(mipi_dsi->dmd),\n\t\t\t\t     \"Failed to probe dw_mipi_dsi\\n\");\n\n\treturn 0;\n}\n\nstatic int meson_dw_mipi_dsi_remove(struct platform_device *pdev)\n{\n\tstruct meson_dw_mipi_dsi *mipi_dsi = platform_get_drvdata(pdev);\n\n\tdw_mipi_dsi_remove(mipi_dsi->dmd);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id meson_dw_mipi_dsi_of_table[] = {\n\t{ .compatible = \"amlogic,meson-g12a-dw-mipi-dsi\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, meson_dw_mipi_dsi_of_table);\n\nstatic struct platform_driver meson_dw_mipi_dsi_platform_driver = {\n\t.probe\t\t= meson_dw_mipi_dsi_probe,\n\t.remove\t\t= meson_dw_mipi_dsi_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= meson_dw_mipi_dsi_of_table,\n\t},\n};\nmodule_platform_driver(meson_dw_mipi_dsi_platform_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}