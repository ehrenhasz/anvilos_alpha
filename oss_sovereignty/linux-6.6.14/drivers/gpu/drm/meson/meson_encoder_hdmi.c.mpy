{
  "module_name": "meson_encoder_hdmi.c",
  "hash_id": "d5bfc3152e193d7db1a24138c9f2b66c8e17eeb3bf478f905dda84c753e49917",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_encoder_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <media/cec-notifier.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include <linux/media-bus-format.h>\n#include <linux/videodev2.h>\n\n#include \"meson_drv.h\"\n#include \"meson_registers.h\"\n#include \"meson_vclk.h\"\n#include \"meson_venc.h\"\n#include \"meson_encoder_hdmi.h\"\n\nstruct meson_encoder_hdmi {\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *connector;\n\tstruct meson_drm *priv;\n\tunsigned long output_bus_fmt;\n\tstruct cec_notifier *cec_notifier;\n};\n\n#define bridge_to_meson_encoder_hdmi(x) \\\n\tcontainer_of(x, struct meson_encoder_hdmi, bridge)\n\nstatic int meson_encoder_hdmi_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, encoder_hdmi->next_bridge,\n\t\t\t\t &encoder_hdmi->bridge, flags);\n}\n\nstatic void meson_encoder_hdmi_detach(struct drm_bridge *bridge)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\n\tcec_notifier_conn_unregister(encoder_hdmi->cec_notifier);\n\tencoder_hdmi->cec_notifier = NULL;\n}\n\nstatic void meson_encoder_hdmi_set_vclk(struct meson_encoder_hdmi *encoder_hdmi,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct meson_drm *priv = encoder_hdmi->priv;\n\tint vic = drm_match_cea_mode(mode);\n\tunsigned int phy_freq;\n\tunsigned int vclk_freq;\n\tunsigned int venc_freq;\n\tunsigned int hdmi_freq;\n\n\tvclk_freq = mode->clock;\n\n\t \n\tif (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)\n\t\tvclk_freq /= 2;\n\n\t \n\tphy_freq = vclk_freq * 10;\n\n\tif (!vic) {\n\t\tmeson_vclk_setup(priv, MESON_VCLK_TARGET_DMT, phy_freq,\n\t\t\t\t vclk_freq, vclk_freq, vclk_freq, false);\n\t\treturn;\n\t}\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tvclk_freq *= 2;\n\n\tvenc_freq = vclk_freq;\n\thdmi_freq = vclk_freq;\n\n\t \n\tif (meson_venc_hdmi_venc_repeat(vic) ||\n\t    encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)\n\t\tvenc_freq *= 2;\n\n\tvclk_freq = max(venc_freq, hdmi_freq);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tvenc_freq /= 2;\n\n\tdev_dbg(priv->dev, \"vclk:%d phy=%d venc=%d hdmi=%d enci=%d\\n\",\n\t\tphy_freq, vclk_freq, venc_freq, hdmi_freq,\n\t\tpriv->venc.hdmi_use_enci);\n\n\tmeson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, phy_freq, vclk_freq,\n\t\t\t venc_freq, hdmi_freq, priv->venc.hdmi_use_enci);\n}\n\nstatic enum drm_mode_status meson_encoder_hdmi_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\tconst struct drm_display_info *display_info,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\tstruct meson_drm *priv = encoder_hdmi->priv;\n\tbool is_hdmi2_sink = display_info->hdmi.scdc.supported;\n\tunsigned int phy_freq;\n\tunsigned int vclk_freq;\n\tunsigned int venc_freq;\n\tunsigned int hdmi_freq;\n\tint vic = drm_match_cea_mode(mode);\n\tenum drm_mode_status status;\n\n\tdev_dbg(priv->dev, \"Modeline \" DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(mode));\n\n\t \n\tif (display_info->max_tmds_clock &&\n\t    mode->clock > display_info->max_tmds_clock &&\n\t    !drm_mode_is_420_only(display_info, mode) &&\n\t    !drm_mode_is_420_also(display_info, mode))\n\t\treturn MODE_BAD;\n\n\t \n\tif (!vic) {\n\t\tstatus = meson_venc_hdmi_supported_mode(mode);\n\t\tif (status != MODE_OK)\n\t\t\treturn status;\n\n\t\treturn meson_vclk_dmt_supported_freq(priv, mode->clock);\n\t \n\t} else if (!meson_venc_hdmi_supported_vic(vic))\n\t\treturn MODE_BAD;\n\n\tvclk_freq = mode->clock;\n\n\t \n\tif (drm_mode_is_420_only(display_info, mode) ||\n\t    (!is_hdmi2_sink &&\n\t     drm_mode_is_420_also(display_info, mode)))\n\t\tvclk_freq /= 2;\n\n\t \n\tphy_freq = vclk_freq * 10;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tvclk_freq *= 2;\n\n\tvenc_freq = vclk_freq;\n\thdmi_freq = vclk_freq;\n\n\t \n\tif (meson_venc_hdmi_venc_repeat(vic) ||\n\t    drm_mode_is_420_only(display_info, mode) ||\n\t    (!is_hdmi2_sink &&\n\t     drm_mode_is_420_also(display_info, mode)))\n\t\tvenc_freq *= 2;\n\n\tvclk_freq = max(venc_freq, hdmi_freq);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tvenc_freq /= 2;\n\n\tdev_dbg(priv->dev, \"%s: vclk:%d phy=%d venc=%d hdmi=%d\\n\",\n\t\t__func__, phy_freq, vclk_freq, venc_freq, hdmi_freq);\n\n\treturn meson_vclk_vic_supported_freq(priv, phy_freq, vclk_freq);\n}\n\nstatic void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tunsigned int ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;\n\tstruct meson_drm *priv = encoder_hdmi->priv;\n\tstruct drm_connector_state *conn_state;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tbool yuv420_mode = false;\n\tint vic;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\treturn;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tvic = drm_match_cea_mode(mode);\n\n\tdev_dbg(priv->dev, \"\\\"%s\\\" vic %d\\n\", mode->name, vic);\n\n\tif (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {\n\t\tycrcb_map = VPU_HDMI_OUTPUT_CRYCB;\n\t\tyuv420_mode = true;\n\t} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)\n\t\tycrcb_map = VPU_HDMI_OUTPUT_CRYCB;\n\n\t \n\tmeson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);\n\n\t \n\tmeson_encoder_hdmi_set_vclk(encoder_hdmi, mode);\n\n\tif (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)\n\t\t \n\t\twritel_relaxed(2 | (2 << 2),\n\t\t\t       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));\n\telse if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)\n\t\t \n\t\twritel_relaxed(1 | (2 << 2),\n\t\t\t\tpriv->io_base + _REG(VPU_HDMI_FMT_CTRL));\n\telse\n\t\t \n\t\twritel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));\n\n\tdev_dbg(priv->dev, \"%s\\n\", priv->venc.hdmi_use_enci ? \"VENCI\" : \"VENCP\");\n\n\tif (priv->venc.hdmi_use_enci)\n\t\twritel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));\n\telse\n\t\twritel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));\n}\n\nstatic void meson_encoder_hdmi_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\tstruct meson_drm *priv = encoder_hdmi->priv;\n\n\twritel_bits_relaxed(0x3, 0,\n\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\n\twritel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));\n\twritel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));\n}\n\nstatic const u32 meson_encoder_hdmi_out_bus_fmts[] = {\n\tMEDIA_BUS_FMT_YUV8_1X24,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_UYYVYY8_0_5X24,\n};\n\nstatic u32 *\nmeson_encoder_hdmi_get_inp_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts)\n{\n\tu32 *input_fmts = NULL;\n\tint i;\n\n\t*num_input_fmts = 0;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(meson_encoder_hdmi_out_bus_fmts) ; ++i) {\n\t\tif (output_fmt == meson_encoder_hdmi_out_bus_fmts[i]) {\n\t\t\t*num_input_fmts = 1;\n\t\t\tinput_fmts = kcalloc(*num_input_fmts,\n\t\t\t\t\t     sizeof(*input_fmts),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!input_fmts)\n\t\t\t\treturn NULL;\n\n\t\t\tinput_fmts[0] = output_fmt;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn input_fmts;\n}\n\nstatic int meson_encoder_hdmi_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\tstruct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(conn_state->state, conn_state->connector);\n\tstruct meson_drm *priv = encoder_hdmi->priv;\n\n\tencoder_hdmi->output_bus_fmt = bridge_state->output_bus_cfg.format;\n\n\tdev_dbg(priv->dev, \"output_bus_fmt %lx\\n\", encoder_hdmi->output_bus_fmt);\n\n\tif (!drm_connector_atomic_hdr_metadata_equal(old_conn_state, conn_state))\n\t\tcrtc_state->mode_changed = true;\n\n\treturn 0;\n}\n\nstatic void meson_encoder_hdmi_hpd_notify(struct drm_bridge *bridge,\n\t\t\t\t\t  enum drm_connector_status status)\n{\n\tstruct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);\n\tstruct edid *edid;\n\n\tif (!encoder_hdmi->cec_notifier)\n\t\treturn;\n\n\tif (status == connector_status_connected) {\n\t\tedid = drm_bridge_get_edid(encoder_hdmi->next_bridge, encoder_hdmi->connector);\n\t\tif (!edid)\n\t\t\treturn;\n\n\t\tcec_notifier_set_phys_addr_from_edid(encoder_hdmi->cec_notifier, edid);\n\n\t\tkfree(edid);\n\t} else\n\t\tcec_notifier_phys_addr_invalidate(encoder_hdmi->cec_notifier);\n}\n\nstatic const struct drm_bridge_funcs meson_encoder_hdmi_bridge_funcs = {\n\t.attach = meson_encoder_hdmi_attach,\n\t.detach = meson_encoder_hdmi_detach,\n\t.mode_valid = meson_encoder_hdmi_mode_valid,\n\t.hpd_notify = meson_encoder_hdmi_hpd_notify,\n\t.atomic_enable = meson_encoder_hdmi_atomic_enable,\n\t.atomic_disable = meson_encoder_hdmi_atomic_disable,\n\t.atomic_get_input_bus_fmts = meson_encoder_hdmi_get_inp_bus_fmts,\n\t.atomic_check = meson_encoder_hdmi_atomic_check,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nint meson_encoder_hdmi_init(struct meson_drm *priv)\n{\n\tstruct meson_encoder_hdmi *meson_encoder_hdmi;\n\tstruct platform_device *pdev;\n\tstruct device_node *remote;\n\tint ret;\n\n\tmeson_encoder_hdmi = devm_kzalloc(priv->dev, sizeof(*meson_encoder_hdmi), GFP_KERNEL);\n\tif (!meson_encoder_hdmi)\n\t\treturn -ENOMEM;\n\n\t \n\tremote = of_graph_get_remote_node(priv->dev->of_node, 1, 0);\n\tif (!remote) {\n\t\tdev_err(priv->dev, \"HDMI transceiver device is disabled\");\n\t\treturn 0;\n\t}\n\n\tmeson_encoder_hdmi->next_bridge = of_drm_find_bridge(remote);\n\tif (!meson_encoder_hdmi->next_bridge) {\n\t\tdev_err(priv->dev, \"Failed to find HDMI transceiver bridge\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_put_node;\n\t}\n\n\t \n\tmeson_encoder_hdmi->bridge.funcs = &meson_encoder_hdmi_bridge_funcs;\n\tmeson_encoder_hdmi->bridge.of_node = priv->dev->of_node;\n\tmeson_encoder_hdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\tmeson_encoder_hdmi->bridge.interlace_allowed = true;\n\n\tdrm_bridge_add(&meson_encoder_hdmi->bridge);\n\n\tmeson_encoder_hdmi->priv = priv;\n\n\t \n\tret = drm_simple_encoder_init(priv->drm, &meson_encoder_hdmi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to init HDMI encoder: %d\\n\", ret);\n\t\tgoto err_put_node;\n\t}\n\n\tmeson_encoder_hdmi->encoder.possible_crtcs = BIT(0);\n\n\t \n\tret = drm_bridge_attach(&meson_encoder_hdmi->encoder, &meson_encoder_hdmi->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to attach bridge: %d\\n\", ret);\n\t\tgoto err_put_node;\n\t}\n\n\t \n\tmeson_encoder_hdmi->connector = drm_bridge_connector_init(priv->drm,\n\t\t\t\t\t\t\t&meson_encoder_hdmi->encoder);\n\tif (IS_ERR(meson_encoder_hdmi->connector)) {\n\t\tdev_err(priv->dev, \"Unable to create HDMI bridge connector\\n\");\n\t\tret = PTR_ERR(meson_encoder_hdmi->connector);\n\t\tgoto err_put_node;\n\t}\n\tdrm_connector_attach_encoder(meson_encoder_hdmi->connector,\n\t\t\t\t     &meson_encoder_hdmi->encoder);\n\n\t \n\n\t \n\tdrm_atomic_helper_connector_reset(meson_encoder_hdmi->connector);\n\n\tif (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL) ||\n\t    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||\n\t    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))\n\t\tdrm_connector_attach_hdr_output_metadata_property(meson_encoder_hdmi->connector);\n\n\tdrm_connector_attach_max_bpc_property(meson_encoder_hdmi->connector, 8, 8);\n\n\t \n\tmeson_encoder_hdmi->connector->ycbcr_420_allowed = true;\n\n\tpdev = of_find_device_by_node(remote);\n\tof_node_put(remote);\n\tif (pdev) {\n\t\tstruct cec_connector_info conn_info;\n\t\tstruct cec_notifier *notifier;\n\n\t\tcec_fill_conn_info_from_drm(&conn_info, meson_encoder_hdmi->connector);\n\n\t\tnotifier = cec_notifier_conn_register(&pdev->dev, NULL, &conn_info);\n\t\tif (!notifier) {\n\t\t\tput_device(&pdev->dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmeson_encoder_hdmi->cec_notifier = notifier;\n\t}\n\n\tpriv->encoders[MESON_ENC_HDMI] = meson_encoder_hdmi;\n\n\tdev_dbg(priv->dev, \"HDMI encoder initialized\\n\");\n\n\treturn 0;\n\nerr_put_node:\n\tof_node_put(remote);\n\treturn ret;\n}\n\nvoid meson_encoder_hdmi_remove(struct meson_drm *priv)\n{\n\tstruct meson_encoder_hdmi *meson_encoder_hdmi;\n\n\tif (priv->encoders[MESON_ENC_HDMI]) {\n\t\tmeson_encoder_hdmi = priv->encoders[MESON_ENC_HDMI];\n\t\tdrm_bridge_remove(&meson_encoder_hdmi->bridge);\n\t\tdrm_bridge_remove(meson_encoder_hdmi->next_bridge);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}