{
  "module_name": "meson_encoder_dsi.c",
  "hash_id": "dbcaea61cf0ee5fa154b848448180a5477f6a3a9c9e8da4e8e1400b80c3f0fe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_encoder_dsi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"meson_drv.h\"\n#include \"meson_encoder_dsi.h\"\n#include \"meson_registers.h\"\n#include \"meson_venc.h\"\n#include \"meson_vclk.h\"\n\nstruct meson_encoder_dsi {\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct meson_drm *priv;\n};\n\n#define bridge_to_meson_encoder_dsi(x) \\\n\tcontainer_of(x, struct meson_encoder_dsi, bridge)\n\nstatic int meson_encoder_dsi_attach(struct drm_bridge *bridge,\n\t\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct meson_encoder_dsi *encoder_dsi = bridge_to_meson_encoder_dsi(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, encoder_dsi->next_bridge,\n\t\t\t\t &encoder_dsi->bridge, flags);\n}\n\nstatic void meson_encoder_dsi_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_dsi *encoder_dsi = bridge_to_meson_encoder_dsi(bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tstruct meson_drm *priv = encoder_dsi->priv;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\treturn;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\t \n\n\tmeson_venc_mipi_dsi_mode_set(priv, &crtc_state->adjusted_mode);\n\tmeson_encl_load_gamma(priv);\n\n\twritel_relaxed(0, priv->io_base + _REG(ENCL_VIDEO_EN));\n\n\twritel_bits_relaxed(ENCL_VIDEO_MODE_ADV_VFIFO_EN, ENCL_VIDEO_MODE_ADV_VFIFO_EN,\n\t\t\t    priv->io_base + _REG(ENCL_VIDEO_MODE_ADV));\n\twritel_relaxed(0, priv->io_base + _REG(ENCL_TST_EN));\n\n\twritel_bits_relaxed(BIT(0), 0, priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_EN_CTRL));\n\n\twritel_relaxed(1, priv->io_base + _REG(ENCL_VIDEO_EN));\n}\n\nstatic void meson_encoder_dsi_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state)\n{\n\tstruct meson_encoder_dsi *meson_encoder_dsi =\n\t\t\t\t\tbridge_to_meson_encoder_dsi(bridge);\n\tstruct meson_drm *priv = meson_encoder_dsi->priv;\n\n\twritel_relaxed(0, priv->io_base + _REG(ENCL_VIDEO_EN));\n\n\twritel_bits_relaxed(BIT(0), BIT(0), priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_EN_CTRL));\n}\n\nstatic const struct drm_bridge_funcs meson_encoder_dsi_bridge_funcs = {\n\t.attach\t= meson_encoder_dsi_attach,\n\t.atomic_enable = meson_encoder_dsi_atomic_enable,\n\t.atomic_disable\t= meson_encoder_dsi_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nint meson_encoder_dsi_init(struct meson_drm *priv)\n{\n\tstruct meson_encoder_dsi *meson_encoder_dsi;\n\tstruct device_node *remote;\n\tint ret;\n\n\tmeson_encoder_dsi = devm_kzalloc(priv->dev, sizeof(*meson_encoder_dsi), GFP_KERNEL);\n\tif (!meson_encoder_dsi)\n\t\treturn -ENOMEM;\n\n\t \n\tremote = of_graph_get_remote_node(priv->dev->of_node, 2, 0);\n\tif (!remote) {\n\t\tdev_err(priv->dev, \"DSI transceiver device is disabled\");\n\t\treturn 0;\n\t}\n\n\tmeson_encoder_dsi->next_bridge = of_drm_find_bridge(remote);\n\tif (!meson_encoder_dsi->next_bridge) {\n\t\tdev_dbg(priv->dev, \"Failed to find DSI transceiver bridge\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tmeson_encoder_dsi->bridge.funcs = &meson_encoder_dsi_bridge_funcs;\n\tmeson_encoder_dsi->bridge.of_node = priv->dev->of_node;\n\tmeson_encoder_dsi->bridge.type = DRM_MODE_CONNECTOR_DSI;\n\n\tdrm_bridge_add(&meson_encoder_dsi->bridge);\n\n\tmeson_encoder_dsi->priv = priv;\n\n\t \n\tret = drm_simple_encoder_init(priv->drm, &meson_encoder_dsi->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_DSI);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to init DSI encoder: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmeson_encoder_dsi->encoder.possible_crtcs = BIT(0);\n\n\t \n\tret = drm_bridge_attach(&meson_encoder_dsi->encoder, &meson_encoder_dsi->bridge, NULL, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to attach bridge: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tpriv->encoders[MESON_ENC_DSI] = meson_encoder_dsi;\n\n\tdev_dbg(priv->dev, \"DSI encoder initialized\\n\");\n\n\treturn 0;\n}\n\nvoid meson_encoder_dsi_remove(struct meson_drm *priv)\n{\n\tstruct meson_encoder_dsi *meson_encoder_dsi;\n\n\tif (priv->encoders[MESON_ENC_DSI]) {\n\t\tmeson_encoder_dsi = priv->encoders[MESON_ENC_DSI];\n\t\tdrm_bridge_remove(&meson_encoder_dsi->bridge);\n\t\tdrm_bridge_remove(meson_encoder_dsi->next_bridge);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}