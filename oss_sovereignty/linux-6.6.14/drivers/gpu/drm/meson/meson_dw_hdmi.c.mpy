{
  "module_name": "meson_dw_hdmi.c",
  "hash_id": "7ba51c125e93b7bc9d8376ae2f2c28114c825fed93a824b289e2d37ca1a9d322",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/meson/meson_dw_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <drm/bridge/dw_hdmi.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_print.h>\n\n#include <linux/videodev2.h>\n\n#include \"meson_drv.h\"\n#include \"meson_dw_hdmi.h\"\n#include \"meson_registers.h\"\n\n#define DRIVER_NAME \"meson-dw-hdmi\"\n#define DRIVER_DESC \"Amlogic Meson HDMI-TX DRM driver\"\n\n \n\n \n#define HDMITX_TOP_ADDR_REG\t0x0\n#define HDMITX_TOP_DATA_REG\t0x4\n#define HDMITX_TOP_CTRL_REG\t0x8\n#define HDMITX_TOP_G12A_OFFSET\t0x8000\n\n \n#define HDMITX_DWC_ADDR_REG\t0x10\n#define HDMITX_DWC_DATA_REG\t0x14\n#define HDMITX_DWC_CTRL_REG\t0x18\n\n \n#define HHI_MEM_PD_REG0\t\t0x100  \n#define HHI_HDMI_CLK_CNTL\t0x1cc  \n#define HHI_HDMI_PHY_CNTL0\t0x3a0  \n#define HHI_HDMI_PHY_CNTL1\t0x3a4  \n#define HHI_HDMI_PHY_CNTL2\t0x3a8  \n#define HHI_HDMI_PHY_CNTL3\t0x3ac  \n#define HHI_HDMI_PHY_CNTL4\t0x3b0  \n#define HHI_HDMI_PHY_CNTL5\t0x3b4  \n\nstatic DEFINE_SPINLOCK(reg_lock);\n\nenum meson_venc_source {\n\tMESON_VENC_SOURCE_NONE = 0,\n\tMESON_VENC_SOURCE_ENCI = 1,\n\tMESON_VENC_SOURCE_ENCP = 2,\n};\n\nstruct meson_dw_hdmi;\n\nstruct meson_dw_hdmi_data {\n\tunsigned int\t(*top_read)(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t    unsigned int addr);\n\tvoid\t\t(*top_write)(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr, unsigned int data);\n\tunsigned int\t(*dwc_read)(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t    unsigned int addr);\n\tvoid\t\t(*dwc_write)(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr, unsigned int data);\n};\n\nstruct meson_dw_hdmi {\n\tstruct dw_hdmi_plat_data dw_plat_data;\n\tstruct meson_drm *priv;\n\tstruct device *dev;\n\tvoid __iomem *hdmitx;\n\tconst struct meson_dw_hdmi_data *data;\n\tstruct reset_control *hdmitx_apb;\n\tstruct reset_control *hdmitx_ctrl;\n\tstruct reset_control *hdmitx_phy;\n\tu32 irq_stat;\n\tstruct dw_hdmi *hdmi;\n\tstruct drm_bridge *bridge;\n};\n\nstatic inline int dw_hdmi_is_compatible(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\tconst char *compat)\n{\n\treturn of_device_is_compatible(dw_hdmi->dev->of_node, compat);\n}\n\n \n\nstatic unsigned int dw_hdmi_top_read(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr)\n{\n\tunsigned long flags;\n\tunsigned int data;\n\n\tspin_lock_irqsave(&reg_lock, flags);\n\n\t \n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\n\n\t \n\tdata = readl(dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\n\tdata = readl(dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\n\n\tspin_unlock_irqrestore(&reg_lock, flags);\n\n\treturn data;\n}\n\nstatic unsigned int dw_hdmi_g12a_top_read(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr)\n{\n\treturn readl(dw_hdmi->hdmitx + HDMITX_TOP_G12A_OFFSET + (addr << 2));\n}\n\nstatic inline void dw_hdmi_top_write(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr, unsigned int data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&reg_lock, flags);\n\n\t \n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\n\n\t \n\twritel(data, dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\n\n\tspin_unlock_irqrestore(&reg_lock, flags);\n}\n\nstatic inline void dw_hdmi_g12a_top_write(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr, unsigned int data)\n{\n\twritel(data, dw_hdmi->hdmitx + HDMITX_TOP_G12A_OFFSET + (addr << 2));\n}\n\n \nstatic inline void dw_hdmi_top_write_bits(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr,\n\t\t\t\t\t  unsigned int mask,\n\t\t\t\t\t  unsigned int val)\n{\n\tunsigned int data = dw_hdmi->data->top_read(dw_hdmi, addr);\n\n\tdata &= ~mask;\n\tdata |= val;\n\n\tdw_hdmi->data->top_write(dw_hdmi, addr, data);\n}\n\nstatic unsigned int dw_hdmi_dwc_read(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr)\n{\n\tunsigned long flags;\n\tunsigned int data;\n\n\tspin_lock_irqsave(&reg_lock, flags);\n\n\t \n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\n\n\t \n\tdata = readl(dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\n\tdata = readl(dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\n\n\tspin_unlock_irqrestore(&reg_lock, flags);\n\n\treturn data;\n}\n\nstatic unsigned int dw_hdmi_g12a_dwc_read(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr)\n{\n\treturn readb(dw_hdmi->hdmitx + addr);\n}\n\nstatic inline void dw_hdmi_dwc_write(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t     unsigned int addr, unsigned int data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&reg_lock, flags);\n\n\t \n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\n\twritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\n\n\t \n\twritel(data, dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\n\n\tspin_unlock_irqrestore(&reg_lock, flags);\n}\n\nstatic inline void dw_hdmi_g12a_dwc_write(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr, unsigned int data)\n{\n\twriteb(data, dw_hdmi->hdmitx + addr);\n}\n\n \nstatic inline void dw_hdmi_dwc_write_bits(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t\t  unsigned int addr,\n\t\t\t\t\t  unsigned int mask,\n\t\t\t\t\t  unsigned int val)\n{\n\tunsigned int data = dw_hdmi->data->dwc_read(dw_hdmi, addr);\n\n\tdata &= ~mask;\n\tdata |= val;\n\n\tdw_hdmi->data->dwc_write(dw_hdmi, addr, data);\n}\n\n \n\n \nstatic void meson_hdmi_phy_setup_mode(struct meson_dw_hdmi *dw_hdmi,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      bool mode_is_420)\n{\n\tstruct meson_drm *priv = dw_hdmi->priv;\n\tunsigned int pixel_clock = mode->clock;\n\n\t \n\tif (mode_is_420) pixel_clock /= 2;\n\n\tif (dw_hdmi_is_compatible(dw_hdmi, \"amlogic,meson-gxl-dw-hdmi\") ||\n\t    dw_hdmi_is_compatible(dw_hdmi, \"amlogic,meson-gxm-dw-hdmi\")) {\n\t\tif (pixel_clock >= 371250) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x333d3282);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2136315b);\n\t\t} else if (pixel_clock >= 297000) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33303382);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2036315b);\n\t\t} else if (pixel_clock >= 148500) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33303362);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2016315b);\n\t\t} else {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33604142);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x0016315b);\n\t\t}\n\t} else if (dw_hdmi_is_compatible(dw_hdmi,\n\t\t\t\t\t \"amlogic,meson-gxbb-dw-hdmi\")) {\n\t\tif (pixel_clock >= 371250) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33353245);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2100115b);\n\t\t} else if (pixel_clock >= 297000) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33634283);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0xb000115b);\n\t\t} else {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33632122);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2000115b);\n\t\t}\n\t} else if (dw_hdmi_is_compatible(dw_hdmi,\n\t\t\t\t\t \"amlogic,meson-g12a-dw-hdmi\")) {\n\t\tif (pixel_clock >= 371250) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x37eb65c4);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2ab0ff3b);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL5, 0x0000080b);\n\t\t} else if (pixel_clock >= 297000) {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33eb6262);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2ab0ff3b);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL5, 0x00000003);\n\t\t} else {\n\t\t\t \n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33eb4242);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2ab0ff3b);\n\t\t\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL5, 0x00000003);\n\t\t}\n\t}\n}\n\nstatic inline void meson_dw_hdmi_phy_reset(struct meson_dw_hdmi *dw_hdmi)\n{\n\tstruct meson_drm *priv = dw_hdmi->priv;\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0xf);\n\n\tmdelay(2);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0xe);\n\n\tmdelay(2);\n}\n\nstatic int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data,\n\t\t\t    const struct drm_display_info *display,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\n\tbool is_hdmi2_sink = display->hdmi.scdc.supported;\n\tstruct meson_drm *priv = dw_hdmi->priv;\n\tunsigned int wr_clk =\n\t\treadl_relaxed(priv->io_base + _REG(VPU_HDMI_SETTING));\n\tbool mode_is_420 = false;\n\n\tDRM_DEBUG_DRIVER(\"\\\"%s\\\" div%d\\n\", mode->name,\n\t\t\t mode->clock > 340000 ? 40 : 10);\n\n\tif (drm_mode_is_420_only(display, mode) ||\n\t    (!is_hdmi2_sink && drm_mode_is_420_also(display, mode)) ||\n\t    dw_hdmi_bus_fmt_is_420(hdmi))\n\t\tmode_is_420 = true;\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_MEM_PD_REG0, 0xff << 8, 0);\n\n\t \n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_SW_RESET,  0);\n\n\t \n\tdw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_CLK_CNTL,\n\t\t\t       0x3, 0x3);\n\n\t \n\tdw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_CLK_CNTL,\n\t\t\t       0x3 << 4, 0x3 << 4);\n\n\t \n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_BIST_CNTL, BIT(12));\n\n\t \n\tif (mode->clock > 340000 && !mode_is_420) {\n\t\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_01,\n\t\t\t\t  0);\n\t\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_23,\n\t\t\t\t  0x03ff03ff);\n\t} else {\n\t\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_01,\n\t\t\t\t  0x001f001f);\n\t\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_23,\n\t\t\t\t  0x001f001f);\n\t}\n\n\t \n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x1);\n\tmsleep(20);\n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);\n\n\t \n\tmeson_hdmi_phy_setup_mode(dw_hdmi, mode, mode_is_420);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\n\t\t\t   0xffff << 16, 0x0390 << 16);\n\n\t \n\tif (dw_hdmi_is_compatible(dw_hdmi, \"amlogic,meson-gxl-dw-hdmi\") ||\n\t    dw_hdmi_is_compatible(dw_hdmi, \"amlogic,meson-gxm-dw-hdmi\") ||\n\t    dw_hdmi_is_compatible(dw_hdmi, \"amlogic,meson-g12a-dw-hdmi\"))\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\n\t\t\t\t   BIT(17), 0);\n\telse\n\t\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\n\t\t\t\t   BIT(17), BIT(17));\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0);\n\n\tdw_hdmi_set_high_tmds_clock_ratio(hdmi, display);\n\n\tmsleep(100);\n\n\t \n\tmeson_dw_hdmi_phy_reset(dw_hdmi);\n\tmeson_dw_hdmi_phy_reset(dw_hdmi);\n\tmeson_dw_hdmi_phy_reset(dw_hdmi);\n\n\t \n\tif (priv->venc.hdmi_use_enci)\n\t\twritel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));\n\telse\n\t\twritel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));\n\n\t \n\twritel_bits_relaxed(0x3, 0,\n\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\twritel_bits_relaxed(0xf << 8, 0,\n\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\n\t \n\tif (priv->venc.hdmi_use_enci)\n\t\twritel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));\n\telse\n\t\twritel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));\n\n\t \n\twritel_bits_relaxed(0xf << 8, wr_clk & (0xf << 8),\n\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\n\t \n\tif (priv->venc.hdmi_use_enci)\n\t\twritel_bits_relaxed(0x3, MESON_VENC_SOURCE_ENCI,\n\t\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\telse\n\t\twritel_bits_relaxed(0x3, MESON_VENC_SOURCE_ENCP,\n\t\t\t\t    priv->io_base + _REG(VPU_HDMI_SETTING));\n\n\treturn 0;\n}\n\nstatic void dw_hdmi_phy_disable(struct dw_hdmi *hdmi,\n\t\t\t\tvoid *data)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\n\tstruct meson_drm *priv = dw_hdmi->priv;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);\n}\n\nstatic enum drm_connector_status dw_hdmi_read_hpd(struct dw_hdmi *hdmi,\n\t\t\t     void *data)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\n\n\treturn !!dw_hdmi->data->top_read(dw_hdmi, HDMITX_TOP_STAT0) ?\n\t\tconnector_status_connected : connector_status_disconnected;\n}\n\nstatic void dw_hdmi_setup_hpd(struct dw_hdmi *hdmi,\n\t\t\t      void *data)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\n\n\t \n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_HPD_FILTER,\n\t\t\t  (0xa << 12) | 0xa0);\n\n\t \n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_INTR_STAT_CLR,\n\t\t\t  HDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL);\n\n\t \n\tdw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_INTR_MASKN,\n\t\t\tHDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL,\n\t\t\tHDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL);\n}\n\nstatic const struct dw_hdmi_phy_ops meson_dw_hdmi_phy_ops = {\n\t.init = dw_hdmi_phy_init,\n\t.disable = dw_hdmi_phy_disable,\n\t.read_hpd = dw_hdmi_read_hpd,\n\t.setup_hpd = dw_hdmi_setup_hpd,\n};\n\nstatic irqreturn_t dw_hdmi_top_irq(int irq, void *dev_id)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = dev_id;\n\tu32 stat;\n\n\tstat = dw_hdmi->data->top_read(dw_hdmi, HDMITX_TOP_INTR_STAT);\n\tdw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_INTR_STAT_CLR, stat);\n\n\t \n\tif (stat & (HDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL)) {\n\t\tdw_hdmi->irq_stat = stat;\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\t \n\tif (stat & 1)\n\t\treturn IRQ_NONE;\n\n\t \n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t dw_hdmi_top_thread_irq(int irq, void *dev_id)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = dev_id;\n\tu32 stat = dw_hdmi->irq_stat;\n\n\t \n\tif (stat & (HDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL)) {\n\t\tbool hpd_connected = false;\n\n\t\tif (stat & HDMITX_TOP_INTR_HPD_RISE)\n\t\t\thpd_connected = true;\n\n\t\tdw_hdmi_setup_rx_sense(dw_hdmi->hdmi, hpd_connected,\n\t\t\t\t       hpd_connected);\n\n\t\tdrm_helper_hpd_irq_event(dw_hdmi->bridge->dev);\n\t\tdrm_bridge_hpd_notify(dw_hdmi->bridge,\n\t\t\t\t      hpd_connected ? connector_status_connected\n\t\t\t\t\t\t    : connector_status_disconnected);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int meson_dw_hdmi_reg_read(void *context, unsigned int reg,\n\t\t\t\t  unsigned int *result)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = context;\n\n\t*result = dw_hdmi->data->dwc_read(dw_hdmi, reg);\n\n\treturn 0;\n\n}\n\nstatic int meson_dw_hdmi_reg_write(void *context, unsigned int reg,\n\t\t\t\t   unsigned int val)\n{\n\tstruct meson_dw_hdmi *dw_hdmi = context;\n\n\tdw_hdmi->data->dwc_write(dw_hdmi, reg, val);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config meson_dw_hdmi_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.reg_read = meson_dw_hdmi_reg_read,\n\t.reg_write = meson_dw_hdmi_reg_write,\n\t.max_register = 0x10000,\n\t.fast_io = true,\n};\n\nstatic const struct meson_dw_hdmi_data meson_dw_hdmi_gx_data = {\n\t.top_read = dw_hdmi_top_read,\n\t.top_write = dw_hdmi_top_write,\n\t.dwc_read = dw_hdmi_dwc_read,\n\t.dwc_write = dw_hdmi_dwc_write,\n};\n\nstatic const struct meson_dw_hdmi_data meson_dw_hdmi_g12a_data = {\n\t.top_read = dw_hdmi_g12a_top_read,\n\t.top_write = dw_hdmi_g12a_top_write,\n\t.dwc_read = dw_hdmi_g12a_dwc_read,\n\t.dwc_write = dw_hdmi_g12a_dwc_write,\n};\n\nstatic void meson_dw_hdmi_init(struct meson_dw_hdmi *meson_dw_hdmi)\n{\n\tstruct meson_drm *priv = meson_dw_hdmi->priv;\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);\n\n\t \n\tregmap_update_bits(priv->hhi, HHI_MEM_PD_REG0, 0xff << 8, 0);\n\n\t \n\treset_control_reset(meson_dw_hdmi->hdmitx_apb);\n\treset_control_reset(meson_dw_hdmi->hdmitx_ctrl);\n\treset_control_reset(meson_dw_hdmi->hdmitx_phy);\n\n\t \n\tif (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {\n\t\twritel_bits_relaxed(BIT(15), BIT(15),\n\t\t\t\t    meson_dw_hdmi->hdmitx + HDMITX_TOP_CTRL_REG);\n\t\twritel_bits_relaxed(BIT(15), BIT(15),\n\t\t\t\t    meson_dw_hdmi->hdmitx + HDMITX_DWC_CTRL_REG);\n\t}\n\n\t \n\tmeson_dw_hdmi->data->top_write(meson_dw_hdmi,\n\t\t\t\t       HDMITX_TOP_SW_RESET,  0);\n\n\tmsleep(20);\n\n\tmeson_dw_hdmi->data->top_write(meson_dw_hdmi,\n\t\t\t\t       HDMITX_TOP_CLK_CNTL, 0xff);\n\n\t \n\tmeson_dw_hdmi->data->top_write(meson_dw_hdmi, HDMITX_TOP_INTR_STAT_CLR,\n\t\t\t\t       HDMITX_TOP_INTR_CORE);\n\n\tmeson_dw_hdmi->data->top_write(meson_dw_hdmi, HDMITX_TOP_INTR_MASKN,\n\t\t\t\t       HDMITX_TOP_INTR_CORE);\n\n}\n\nstatic void meson_disable_clk(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int meson_enable_clk(struct device *dev, char *name)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = devm_clk_get(dev, name);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"Unable to get %s pclk\\n\", name);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (!ret)\n\t\tret = devm_add_action_or_reset(dev, meson_disable_clk, clk);\n\n\treturn ret;\n}\n\nstatic int meson_dw_hdmi_bind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct meson_dw_hdmi_data *match;\n\tstruct meson_dw_hdmi *meson_dw_hdmi;\n\tstruct drm_device *drm = data;\n\tstruct meson_drm *priv = drm->dev_private;\n\tstruct dw_hdmi_plat_data *dw_plat_data;\n\tint irq;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tmatch = of_device_get_match_data(&pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmeson_dw_hdmi = devm_kzalloc(dev, sizeof(*meson_dw_hdmi),\n\t\t\t\t     GFP_KERNEL);\n\tif (!meson_dw_hdmi)\n\t\treturn -ENOMEM;\n\n\tmeson_dw_hdmi->priv = priv;\n\tmeson_dw_hdmi->dev = dev;\n\tmeson_dw_hdmi->data = match;\n\tdw_plat_data = &meson_dw_hdmi->dw_plat_data;\n\n\tret = devm_regulator_get_enable_optional(dev, \"hdmi\");\n\tif (ret < 0 && ret != -ENODEV)\n\t\treturn ret;\n\n\tmeson_dw_hdmi->hdmitx_apb = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\"hdmitx_apb\");\n\tif (IS_ERR(meson_dw_hdmi->hdmitx_apb)) {\n\t\tdev_err(dev, \"Failed to get hdmitx_apb reset\\n\");\n\t\treturn PTR_ERR(meson_dw_hdmi->hdmitx_apb);\n\t}\n\n\tmeson_dw_hdmi->hdmitx_ctrl = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\"hdmitx\");\n\tif (IS_ERR(meson_dw_hdmi->hdmitx_ctrl)) {\n\t\tdev_err(dev, \"Failed to get hdmitx reset\\n\");\n\t\treturn PTR_ERR(meson_dw_hdmi->hdmitx_ctrl);\n\t}\n\n\tmeson_dw_hdmi->hdmitx_phy = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\"hdmitx_phy\");\n\tif (IS_ERR(meson_dw_hdmi->hdmitx_phy)) {\n\t\tdev_err(dev, \"Failed to get hdmitx_phy reset\\n\");\n\t\treturn PTR_ERR(meson_dw_hdmi->hdmitx_phy);\n\t}\n\n\tmeson_dw_hdmi->hdmitx = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(meson_dw_hdmi->hdmitx))\n\t\treturn PTR_ERR(meson_dw_hdmi->hdmitx);\n\n\tret = meson_enable_clk(dev, \"isfr\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_enable_clk(dev, \"iahb\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_enable_clk(dev, \"venci\");\n\tif (ret)\n\t\treturn ret;\n\n\tdw_plat_data->regm = devm_regmap_init(dev, NULL, meson_dw_hdmi,\n\t\t\t\t\t      &meson_dw_hdmi_regmap_config);\n\tif (IS_ERR(dw_plat_data->regm))\n\t\treturn PTR_ERR(dw_plat_data->regm);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, dw_hdmi_top_irq,\n\t\t\t\t\tdw_hdmi_top_thread_irq, IRQF_SHARED,\n\t\t\t\t\t\"dw_hdmi_top_irq\", meson_dw_hdmi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request hdmi top irq\\n\");\n\t\treturn ret;\n\t}\n\n\tmeson_dw_hdmi_init(meson_dw_hdmi);\n\n\t \n\n\tdw_plat_data->priv_data = meson_dw_hdmi;\n\tdw_plat_data->phy_ops = &meson_dw_hdmi_phy_ops;\n\tdw_plat_data->phy_name = \"meson_dw_hdmi_phy\";\n\tdw_plat_data->phy_data = meson_dw_hdmi;\n\tdw_plat_data->input_bus_encoding = V4L2_YCBCR_ENC_709;\n\tdw_plat_data->ycbcr_420_allowed = true;\n\tdw_plat_data->disable_cec = true;\n\tdw_plat_data->output_port = 1;\n\n\tif (dw_hdmi_is_compatible(meson_dw_hdmi, \"amlogic,meson-gxl-dw-hdmi\") ||\n\t    dw_hdmi_is_compatible(meson_dw_hdmi, \"amlogic,meson-gxm-dw-hdmi\") ||\n\t    dw_hdmi_is_compatible(meson_dw_hdmi, \"amlogic,meson-g12a-dw-hdmi\"))\n\t\tdw_plat_data->use_drm_infoframe = true;\n\n\tplatform_set_drvdata(pdev, meson_dw_hdmi);\n\n\tmeson_dw_hdmi->hdmi = dw_hdmi_probe(pdev, &meson_dw_hdmi->dw_plat_data);\n\tif (IS_ERR(meson_dw_hdmi->hdmi))\n\t\treturn PTR_ERR(meson_dw_hdmi->hdmi);\n\n\tmeson_dw_hdmi->bridge = of_drm_find_bridge(pdev->dev.of_node);\n\n\tDRM_DEBUG_DRIVER(\"HDMI controller initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void meson_dw_hdmi_unbind(struct device *dev, struct device *master,\n\t\t\t\t   void *data)\n{\n\tstruct meson_dw_hdmi *meson_dw_hdmi = dev_get_drvdata(dev);\n\n\tdw_hdmi_unbind(meson_dw_hdmi->hdmi);\n}\n\nstatic const struct component_ops meson_dw_hdmi_ops = {\n\t.bind\t= meson_dw_hdmi_bind,\n\t.unbind\t= meson_dw_hdmi_unbind,\n};\n\nstatic int __maybe_unused meson_dw_hdmi_pm_suspend(struct device *dev)\n{\n\tstruct meson_dw_hdmi *meson_dw_hdmi = dev_get_drvdata(dev);\n\n\tif (!meson_dw_hdmi)\n\t\treturn 0;\n\n\t \n\tmeson_dw_hdmi->data->top_write(meson_dw_hdmi,\n\t\t\t\t       HDMITX_TOP_SW_RESET, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused meson_dw_hdmi_pm_resume(struct device *dev)\n{\n\tstruct meson_dw_hdmi *meson_dw_hdmi = dev_get_drvdata(dev);\n\n\tif (!meson_dw_hdmi)\n\t\treturn 0;\n\n\tmeson_dw_hdmi_init(meson_dw_hdmi);\n\n\tdw_hdmi_resume(meson_dw_hdmi->hdmi);\n\n\treturn 0;\n}\n\nstatic int meson_dw_hdmi_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &meson_dw_hdmi_ops);\n}\n\nstatic void meson_dw_hdmi_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &meson_dw_hdmi_ops);\n}\n\nstatic const struct dev_pm_ops meson_dw_hdmi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(meson_dw_hdmi_pm_suspend,\n\t\t\t\tmeson_dw_hdmi_pm_resume)\n};\n\nstatic const struct of_device_id meson_dw_hdmi_of_table[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-dw-hdmi\",\n\t  .data = &meson_dw_hdmi_gx_data },\n\t{ .compatible = \"amlogic,meson-gxl-dw-hdmi\",\n\t  .data = &meson_dw_hdmi_gx_data },\n\t{ .compatible = \"amlogic,meson-gxm-dw-hdmi\",\n\t  .data = &meson_dw_hdmi_gx_data },\n\t{ .compatible = \"amlogic,meson-g12a-dw-hdmi\",\n\t  .data = &meson_dw_hdmi_g12a_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, meson_dw_hdmi_of_table);\n\nstatic struct platform_driver meson_dw_hdmi_platform_driver = {\n\t.probe\t\t= meson_dw_hdmi_probe,\n\t.remove_new\t= meson_dw_hdmi_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= meson_dw_hdmi_of_table,\n\t\t.pm = &meson_dw_hdmi_pm_ops,\n\t},\n};\nmodule_platform_driver(meson_dw_hdmi_platform_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}