{
  "module_name": "drm_client.c",
  "hash_id": "3ebe204dd36481587f6378d1bc178bd59a7139c7b487265216f71f76653fcb9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_client.c",
  "human_readable_source": "\n \n\n#include <linux/iosys-map.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <drm/drm_client.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n \n\nstatic int drm_client_open(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_file *file;\n\n\tfile = drm_file_alloc(dev->primary);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tmutex_lock(&dev->filelist_mutex);\n\tlist_add(&file->lhead, &dev->filelist_internal);\n\tmutex_unlock(&dev->filelist_mutex);\n\n\tclient->file = file;\n\n\treturn 0;\n}\n\nstatic void drm_client_close(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\n\tmutex_lock(&dev->filelist_mutex);\n\tlist_del(&client->file->lhead);\n\tmutex_unlock(&dev->filelist_mutex);\n\n\tdrm_file_free(client->file);\n}\n\n \nint drm_client_init(struct drm_device *dev, struct drm_client_dev *client,\n\t\t    const char *name, const struct drm_client_funcs *funcs)\n{\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET) || !dev->driver->dumb_create)\n\t\treturn -EOPNOTSUPP;\n\n\tif (funcs && !try_module_get(funcs->owner))\n\t\treturn -ENODEV;\n\n\tclient->dev = dev;\n\tclient->name = name;\n\tclient->funcs = funcs;\n\n\tret = drm_client_modeset_create(client);\n\tif (ret)\n\t\tgoto err_put_module;\n\n\tret = drm_client_open(client);\n\tif (ret)\n\t\tgoto err_free;\n\n\tdrm_dev_get(dev);\n\n\treturn 0;\n\nerr_free:\n\tdrm_client_modeset_free(client);\nerr_put_module:\n\tif (funcs)\n\t\tmodule_put(funcs->owner);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_client_init);\n\n \nvoid drm_client_register(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tmutex_lock(&dev->clientlist_mutex);\n\tlist_add(&client->list, &dev->clientlist);\n\n\tif (client->funcs && client->funcs->hotplug) {\n\t\t \n\t\tret = client->funcs->hotplug(client);\n\t\tif (ret)\n\t\t\tdrm_dbg_kms(dev, \"client hotplug ret=%d\\n\", ret);\n\t}\n\tmutex_unlock(&dev->clientlist_mutex);\n}\nEXPORT_SYMBOL(drm_client_register);\n\n \nvoid drm_client_release(struct drm_client_dev *client)\n{\n\tstruct drm_device *dev = client->dev;\n\n\tdrm_dbg_kms(dev, \"%s\\n\", client->name);\n\n\tdrm_client_modeset_free(client);\n\tdrm_client_close(client);\n\tdrm_dev_put(dev);\n\tif (client->funcs)\n\t\tmodule_put(client->funcs->owner);\n}\nEXPORT_SYMBOL(drm_client_release);\n\nvoid drm_client_dev_unregister(struct drm_device *dev)\n{\n\tstruct drm_client_dev *client, *tmp;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn;\n\n\tmutex_lock(&dev->clientlist_mutex);\n\tlist_for_each_entry_safe(client, tmp, &dev->clientlist, list) {\n\t\tlist_del(&client->list);\n\t\tif (client->funcs && client->funcs->unregister) {\n\t\t\tclient->funcs->unregister(client);\n\t\t} else {\n\t\t\tdrm_client_release(client);\n\t\t\tkfree(client);\n\t\t}\n\t}\n\tmutex_unlock(&dev->clientlist_mutex);\n}\n\n \nvoid drm_client_dev_hotplug(struct drm_device *dev)\n{\n\tstruct drm_client_dev *client;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn;\n\n\tif (!dev->mode_config.num_connector) {\n\t\tdrm_dbg_kms(dev, \"No connectors found, will not send hotplug events!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev->clientlist_mutex);\n\tlist_for_each_entry(client, &dev->clientlist, list) {\n\t\tif (!client->funcs || !client->funcs->hotplug)\n\t\t\tcontinue;\n\n\t\tif (client->hotplug_failed)\n\t\t\tcontinue;\n\n\t\tret = client->funcs->hotplug(client);\n\t\tdrm_dbg_kms(dev, \"%s: ret=%d\\n\", client->name, ret);\n\t\tif (ret)\n\t\t\tclient->hotplug_failed = true;\n\t}\n\tmutex_unlock(&dev->clientlist_mutex);\n}\nEXPORT_SYMBOL(drm_client_dev_hotplug);\n\nvoid drm_client_dev_restore(struct drm_device *dev)\n{\n\tstruct drm_client_dev *client;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn;\n\n\tmutex_lock(&dev->clientlist_mutex);\n\tlist_for_each_entry(client, &dev->clientlist, list) {\n\t\tif (!client->funcs || !client->funcs->restore)\n\t\t\tcontinue;\n\n\t\tret = client->funcs->restore(client);\n\t\tdrm_dbg_kms(dev, \"%s: ret=%d\\n\", client->name, ret);\n\t\tif (!ret)  \n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dev->clientlist_mutex);\n}\n\nstatic void drm_client_buffer_delete(struct drm_client_buffer *buffer)\n{\n\tif (buffer->gem) {\n\t\tdrm_gem_vunmap_unlocked(buffer->gem, &buffer->map);\n\t\tdrm_gem_object_put(buffer->gem);\n\t}\n\n\tkfree(buffer);\n}\n\nstatic struct drm_client_buffer *\ndrm_client_buffer_create(struct drm_client_dev *client, u32 width, u32 height,\n\t\t\t u32 format, u32 *handle)\n{\n\tconst struct drm_format_info *info = drm_format_info(format);\n\tstruct drm_mode_create_dumb dumb_args = { };\n\tstruct drm_device *dev = client->dev;\n\tstruct drm_client_buffer *buffer;\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbuffer->client = client;\n\n\tdumb_args.width = width;\n\tdumb_args.height = height;\n\tdumb_args.bpp = drm_format_info_bpp(info, 0);\n\tret = drm_mode_create_dumb(dev, &dumb_args, client->file);\n\tif (ret)\n\t\tgoto err_delete;\n\n\tobj = drm_gem_object_lookup(client->file, dumb_args.handle);\n\tif (!obj)  {\n\t\tret = -ENOENT;\n\t\tgoto err_delete;\n\t}\n\n\tbuffer->pitch = dumb_args.pitch;\n\tbuffer->gem = obj;\n\t*handle = dumb_args.handle;\n\n\treturn buffer;\n\nerr_delete:\n\tdrm_client_buffer_delete(buffer);\n\n\treturn ERR_PTR(ret);\n}\n\n \nint\ndrm_client_buffer_vmap(struct drm_client_buffer *buffer,\n\t\t       struct iosys_map *map_copy)\n{\n\tstruct iosys_map *map = &buffer->map;\n\tint ret;\n\n\t \n\tret = drm_gem_vmap_unlocked(buffer->gem, map);\n\tif (ret)\n\t\treturn ret;\n\n\t*map_copy = *map;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_client_buffer_vmap);\n\n \nvoid drm_client_buffer_vunmap(struct drm_client_buffer *buffer)\n{\n\tstruct iosys_map *map = &buffer->map;\n\n\tdrm_gem_vunmap_unlocked(buffer->gem, map);\n}\nEXPORT_SYMBOL(drm_client_buffer_vunmap);\n\nstatic void drm_client_buffer_rmfb(struct drm_client_buffer *buffer)\n{\n\tint ret;\n\n\tif (!buffer->fb)\n\t\treturn;\n\n\tret = drm_mode_rmfb(buffer->client->dev, buffer->fb->base.id, buffer->client->file);\n\tif (ret)\n\t\tdrm_err(buffer->client->dev,\n\t\t\t\"Error removing FB:%u (%d)\\n\", buffer->fb->base.id, ret);\n\n\tbuffer->fb = NULL;\n}\n\nstatic int drm_client_buffer_addfb(struct drm_client_buffer *buffer,\n\t\t\t\t   u32 width, u32 height, u32 format,\n\t\t\t\t   u32 handle)\n{\n\tstruct drm_client_dev *client = buffer->client;\n\tstruct drm_mode_fb_cmd fb_req = { };\n\tconst struct drm_format_info *info;\n\tint ret;\n\n\tinfo = drm_format_info(format);\n\tfb_req.bpp = drm_format_info_bpp(info, 0);\n\tfb_req.depth = info->depth;\n\tfb_req.width = width;\n\tfb_req.height = height;\n\tfb_req.handle = handle;\n\tfb_req.pitch = buffer->pitch;\n\n\tret = drm_mode_addfb(client->dev, &fb_req, client->file);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer->fb = drm_framebuffer_lookup(client->dev, buffer->client->file, fb_req.fb_id);\n\tif (WARN_ON(!buffer->fb))\n\t\treturn -ENOENT;\n\n\t \n\tdrm_framebuffer_put(buffer->fb);\n\n\tstrscpy(buffer->fb->comm, client->name, TASK_COMM_LEN);\n\n\treturn 0;\n}\n\n \nstruct drm_client_buffer *\ndrm_client_framebuffer_create(struct drm_client_dev *client, u32 width, u32 height, u32 format)\n{\n\tstruct drm_client_buffer *buffer;\n\tu32 handle;\n\tint ret;\n\n\tbuffer = drm_client_buffer_create(client, width, height, format,\n\t\t\t\t\t  &handle);\n\tif (IS_ERR(buffer))\n\t\treturn buffer;\n\n\tret = drm_client_buffer_addfb(buffer, width, height, format, handle);\n\n\t \n\tdrm_mode_destroy_dumb(client->dev, handle, client->file);\n\n\tif (ret) {\n\t\tdrm_client_buffer_delete(buffer);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn buffer;\n}\nEXPORT_SYMBOL(drm_client_framebuffer_create);\n\n \nvoid drm_client_framebuffer_delete(struct drm_client_buffer *buffer)\n{\n\tif (!buffer)\n\t\treturn;\n\n\tdrm_client_buffer_rmfb(buffer);\n\tdrm_client_buffer_delete(buffer);\n}\nEXPORT_SYMBOL(drm_client_framebuffer_delete);\n\n \nint drm_client_framebuffer_flush(struct drm_client_buffer *buffer, struct drm_rect *rect)\n{\n\tif (!buffer || !buffer->fb || !buffer->fb->funcs->dirty)\n\t\treturn 0;\n\n\tif (rect) {\n\t\tstruct drm_clip_rect clip = {\n\t\t\t.x1 = rect->x1,\n\t\t\t.y1 = rect->y1,\n\t\t\t.x2 = rect->x2,\n\t\t\t.y2 = rect->y2,\n\t\t};\n\n\t\treturn buffer->fb->funcs->dirty(buffer->fb, buffer->client->file,\n\t\t\t\t\t\t0, 0, &clip, 1);\n\t}\n\n\treturn buffer->fb->funcs->dirty(buffer->fb, buffer->client->file,\n\t\t\t\t\t0, 0, NULL, 0);\n}\nEXPORT_SYMBOL(drm_client_framebuffer_flush);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int drm_client_debugfs_internal_clients(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct drm_client_dev *client;\n\n\tmutex_lock(&dev->clientlist_mutex);\n\tlist_for_each_entry(client, &dev->clientlist, list)\n\t\tdrm_printf(&p, \"%s\\n\", client->name);\n\tmutex_unlock(&dev->clientlist_mutex);\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info drm_client_debugfs_list[] = {\n\t{ \"internal_clients\", drm_client_debugfs_internal_clients, 0 },\n};\n\nvoid drm_client_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_client_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_client_debugfs_list));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}