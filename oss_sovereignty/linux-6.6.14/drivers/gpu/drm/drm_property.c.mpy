{
  "module_name": "drm_property.c",
  "hash_id": "9f70f39739315c5e2dfc684ab5bd3e76a7c9bfe4e93c4f5b40674e73041f9091",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_property.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_property.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\nstatic bool drm_property_flags_valid(u32 flags)\n{\n\tu32 legacy_type = flags & DRM_MODE_PROP_LEGACY_TYPE;\n\tu32 ext_type = flags & DRM_MODE_PROP_EXTENDED_TYPE;\n\n\t \n\tif (flags & ~(DRM_MODE_PROP_LEGACY_TYPE |\n\t\t      DRM_MODE_PROP_EXTENDED_TYPE |\n\t\t      DRM_MODE_PROP_IMMUTABLE |\n\t\t      DRM_MODE_PROP_ATOMIC))\n\t\treturn false;\n\n\t \n\tif (!legacy_type == !ext_type)\n\t\treturn false;\n\n\t \n\tif (legacy_type && !is_power_of_2(legacy_type))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstruct drm_property *drm_property_create(struct drm_device *dev,\n\t\t\t\t\t u32 flags, const char *name,\n\t\t\t\t\t int num_values)\n{\n\tstruct drm_property *property = NULL;\n\tint ret;\n\n\tif (WARN_ON(!drm_property_flags_valid(flags)))\n\t\treturn NULL;\n\n\tif (WARN_ON(strlen(name) >= DRM_PROP_NAME_LEN))\n\t\treturn NULL;\n\n\tproperty = kzalloc(sizeof(struct drm_property), GFP_KERNEL);\n\tif (!property)\n\t\treturn NULL;\n\n\tproperty->dev = dev;\n\n\tif (num_values) {\n\t\tproperty->values = kcalloc(num_values, sizeof(uint64_t),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!property->values)\n\t\t\tgoto fail;\n\t}\n\n\tret = drm_mode_object_add(dev, &property->base, DRM_MODE_OBJECT_PROPERTY);\n\tif (ret)\n\t\tgoto fail;\n\n\tproperty->flags = flags;\n\tproperty->num_values = num_values;\n\tINIT_LIST_HEAD(&property->enum_list);\n\n\tstrscpy_pad(property->name, name, DRM_PROP_NAME_LEN);\n\n\tlist_add_tail(&property->head, &dev->mode_config.property_list);\n\n\treturn property;\nfail:\n\tkfree(property->values);\n\tkfree(property);\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_property_create);\n\n \nstruct drm_property *drm_property_create_enum(struct drm_device *dev,\n\t\t\t\t\t      u32 flags, const char *name,\n\t\t\t\t\t      const struct drm_prop_enum_list *props,\n\t\t\t\t\t      int num_values)\n{\n\tstruct drm_property *property;\n\tint i, ret;\n\n\tflags |= DRM_MODE_PROP_ENUM;\n\n\tproperty = drm_property_create(dev, flags, name, num_values);\n\tif (!property)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_values; i++) {\n\t\tret = drm_property_add_enum(property,\n\t\t\t\t\t    props[i].type,\n\t\t\t\t\t    props[i].name);\n\t\tif (ret) {\n\t\t\tdrm_property_destroy(dev, property);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn property;\n}\nEXPORT_SYMBOL(drm_property_create_enum);\n\n \nstruct drm_property *drm_property_create_bitmask(struct drm_device *dev,\n\t\t\t\t\t\t u32 flags, const char *name,\n\t\t\t\t\t\t const struct drm_prop_enum_list *props,\n\t\t\t\t\t\t int num_props,\n\t\t\t\t\t\t uint64_t supported_bits)\n{\n\tstruct drm_property *property;\n\tint i, ret;\n\tint num_values = hweight64(supported_bits);\n\n\tflags |= DRM_MODE_PROP_BITMASK;\n\n\tproperty = drm_property_create(dev, flags, name, num_values);\n\tif (!property)\n\t\treturn NULL;\n\tfor (i = 0; i < num_props; i++) {\n\t\tif (!(supported_bits & (1ULL << props[i].type)))\n\t\t\tcontinue;\n\n\t\tret = drm_property_add_enum(property,\n\t\t\t\t\t    props[i].type,\n\t\t\t\t\t    props[i].name);\n\t\tif (ret) {\n\t\t\tdrm_property_destroy(dev, property);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn property;\n}\nEXPORT_SYMBOL(drm_property_create_bitmask);\n\nstatic struct drm_property *property_create_range(struct drm_device *dev,\n\t\t\t\t\t\t  u32 flags, const char *name,\n\t\t\t\t\t\t  uint64_t min, uint64_t max)\n{\n\tstruct drm_property *property;\n\n\tproperty = drm_property_create(dev, flags, name, 2);\n\tif (!property)\n\t\treturn NULL;\n\n\tproperty->values[0] = min;\n\tproperty->values[1] = max;\n\n\treturn property;\n}\n\n \nstruct drm_property *drm_property_create_range(struct drm_device *dev,\n\t\t\t\t\t       u32 flags, const char *name,\n\t\t\t\t\t       uint64_t min, uint64_t max)\n{\n\treturn property_create_range(dev, DRM_MODE_PROP_RANGE | flags,\n\t\t\tname, min, max);\n}\nEXPORT_SYMBOL(drm_property_create_range);\n\n \nstruct drm_property *drm_property_create_signed_range(struct drm_device *dev,\n\t\t\t\t\t\t      u32 flags, const char *name,\n\t\t\t\t\t\t      int64_t min, int64_t max)\n{\n\treturn property_create_range(dev, DRM_MODE_PROP_SIGNED_RANGE | flags,\n\t\t\tname, I642U64(min), I642U64(max));\n}\nEXPORT_SYMBOL(drm_property_create_signed_range);\n\n \nstruct drm_property *drm_property_create_object(struct drm_device *dev,\n\t\t\t\t\t\tu32 flags, const char *name,\n\t\t\t\t\t\tuint32_t type)\n{\n\tstruct drm_property *property;\n\n\tflags |= DRM_MODE_PROP_OBJECT;\n\n\tif (WARN_ON(!(flags & DRM_MODE_PROP_ATOMIC)))\n\t\treturn NULL;\n\n\tproperty = drm_property_create(dev, flags, name, 1);\n\tif (!property)\n\t\treturn NULL;\n\n\tproperty->values[0] = type;\n\n\treturn property;\n}\nEXPORT_SYMBOL(drm_property_create_object);\n\n \nstruct drm_property *drm_property_create_bool(struct drm_device *dev,\n\t\t\t\t\t      u32 flags, const char *name)\n{\n\treturn drm_property_create_range(dev, flags, name, 0, 1);\n}\nEXPORT_SYMBOL(drm_property_create_bool);\n\n \nint drm_property_add_enum(struct drm_property *property,\n\t\t\t  uint64_t value, const char *name)\n{\n\tstruct drm_property_enum *prop_enum;\n\tint index = 0;\n\n\tif (WARN_ON(strlen(name) >= DRM_PROP_NAME_LEN))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!drm_property_type_is(property, DRM_MODE_PROP_ENUM) &&\n\t\t    !drm_property_type_is(property, DRM_MODE_PROP_BITMASK)))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(drm_property_type_is(property, DRM_MODE_PROP_BITMASK) &&\n\t\t    value > 63))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(prop_enum, &property->enum_list, head) {\n\t\tif (WARN_ON(prop_enum->value == value))\n\t\t\treturn -EINVAL;\n\t\tindex++;\n\t}\n\n\tif (WARN_ON(index >= property->num_values))\n\t\treturn -EINVAL;\n\n\tprop_enum = kzalloc(sizeof(struct drm_property_enum), GFP_KERNEL);\n\tif (!prop_enum)\n\t\treturn -ENOMEM;\n\n\tstrscpy_pad(prop_enum->name, name, DRM_PROP_NAME_LEN);\n\tprop_enum->value = value;\n\n\tproperty->values[index] = value;\n\tlist_add_tail(&prop_enum->head, &property->enum_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_property_add_enum);\n\n \nvoid drm_property_destroy(struct drm_device *dev, struct drm_property *property)\n{\n\tstruct drm_property_enum *prop_enum, *pt;\n\n\tlist_for_each_entry_safe(prop_enum, pt, &property->enum_list, head) {\n\t\tlist_del(&prop_enum->head);\n\t\tkfree(prop_enum);\n\t}\n\n\tif (property->num_values)\n\t\tkfree(property->values);\n\tdrm_mode_object_unregister(dev, &property->base);\n\tlist_del(&property->head);\n\tkfree(property);\n}\nEXPORT_SYMBOL(drm_property_destroy);\n\nint drm_mode_getproperty_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_property *out_resp = data;\n\tstruct drm_property *property;\n\tint enum_count = 0;\n\tint value_count = 0;\n\tint i, copied;\n\tstruct drm_property_enum *prop_enum;\n\tstruct drm_mode_property_enum __user *enum_ptr;\n\tuint64_t __user *values_ptr;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tproperty = drm_property_find(dev, file_priv, out_resp->prop_id);\n\tif (!property)\n\t\treturn -ENOENT;\n\n\tstrscpy_pad(out_resp->name, property->name, DRM_PROP_NAME_LEN);\n\tout_resp->flags = property->flags;\n\n\tvalue_count = property->num_values;\n\tvalues_ptr = u64_to_user_ptr(out_resp->values_ptr);\n\n\tfor (i = 0; i < value_count; i++) {\n\t\tif (i < out_resp->count_values &&\n\t\t    put_user(property->values[i], values_ptr + i)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tout_resp->count_values = value_count;\n\n\tcopied = 0;\n\tenum_ptr = u64_to_user_ptr(out_resp->enum_blob_ptr);\n\n\tif (drm_property_type_is(property, DRM_MODE_PROP_ENUM) ||\n\t    drm_property_type_is(property, DRM_MODE_PROP_BITMASK)) {\n\t\tlist_for_each_entry(prop_enum, &property->enum_list, head) {\n\t\t\tenum_count++;\n\t\t\tif (out_resp->count_enum_blobs < enum_count)\n\t\t\t\tcontinue;\n\n\t\t\tif (copy_to_user(&enum_ptr[copied].value,\n\t\t\t\t\t &prop_enum->value, sizeof(uint64_t)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (copy_to_user(&enum_ptr[copied].name,\n\t\t\t\t\t &prop_enum->name, DRM_PROP_NAME_LEN))\n\t\t\t\treturn -EFAULT;\n\t\t\tcopied++;\n\t\t}\n\t\tout_resp->count_enum_blobs = enum_count;\n\t}\n\n\t \n\tif (drm_property_type_is(property, DRM_MODE_PROP_BLOB))\n\t\tout_resp->count_enum_blobs = 0;\n\n\treturn 0;\n}\n\nstatic void drm_property_free_blob(struct kref *kref)\n{\n\tstruct drm_property_blob *blob =\n\t\tcontainer_of(kref, struct drm_property_blob, base.refcount);\n\n\tmutex_lock(&blob->dev->mode_config.blob_lock);\n\tlist_del(&blob->head_global);\n\tmutex_unlock(&blob->dev->mode_config.blob_lock);\n\n\tdrm_mode_object_unregister(blob->dev, &blob->base);\n\n\tkvfree(blob);\n}\n\n \nstruct drm_property_blob *\ndrm_property_create_blob(struct drm_device *dev, size_t length,\n\t\t\t const void *data)\n{\n\tstruct drm_property_blob *blob;\n\tint ret;\n\n\tif (!length || length > INT_MAX - sizeof(struct drm_property_blob))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tblob = kvzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);\n\tif (!blob)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tINIT_LIST_HEAD(&blob->head_file);\n\tblob->data = (void *)blob + sizeof(*blob);\n\tblob->length = length;\n\tblob->dev = dev;\n\n\tif (data)\n\t\tmemcpy(blob->data, data, length);\n\n\tret = __drm_mode_object_add(dev, &blob->base, DRM_MODE_OBJECT_BLOB,\n\t\t\t\t    true, drm_property_free_blob);\n\tif (ret) {\n\t\tkvfree(blob);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmutex_lock(&dev->mode_config.blob_lock);\n\tlist_add_tail(&blob->head_global,\n\t              &dev->mode_config.property_blob_list);\n\tmutex_unlock(&dev->mode_config.blob_lock);\n\n\treturn blob;\n}\nEXPORT_SYMBOL(drm_property_create_blob);\n\n \nvoid drm_property_blob_put(struct drm_property_blob *blob)\n{\n\tif (!blob)\n\t\treturn;\n\n\tdrm_mode_object_put(&blob->base);\n}\nEXPORT_SYMBOL(drm_property_blob_put);\n\nvoid drm_property_destroy_user_blobs(struct drm_device *dev,\n\t\t\t\t     struct drm_file *file_priv)\n{\n\tstruct drm_property_blob *blob, *bt;\n\n\t \n\tlist_for_each_entry_safe(blob, bt, &file_priv->blobs, head_file) {\n\t\tlist_del_init(&blob->head_file);\n\t\tdrm_property_blob_put(blob);\n\t}\n}\n\n \nstruct drm_property_blob *drm_property_blob_get(struct drm_property_blob *blob)\n{\n\tdrm_mode_object_get(&blob->base);\n\treturn blob;\n}\nEXPORT_SYMBOL(drm_property_blob_get);\n\n \nstruct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,\n\t\t\t\t\t           uint32_t id)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_property_blob *blob = NULL;\n\n\tobj = __drm_mode_object_find(dev, NULL, id, DRM_MODE_OBJECT_BLOB);\n\tif (obj)\n\t\tblob = obj_to_blob(obj);\n\treturn blob;\n}\nEXPORT_SYMBOL(drm_property_lookup_blob);\n\n \nint drm_property_replace_global_blob(struct drm_device *dev,\n\t\t\t\t     struct drm_property_blob **replace,\n\t\t\t\t     size_t length,\n\t\t\t\t     const void *data,\n\t\t\t\t     struct drm_mode_object *obj_holds_id,\n\t\t\t\t     struct drm_property *prop_holds_id)\n{\n\tstruct drm_property_blob *new_blob = NULL;\n\tstruct drm_property_blob *old_blob = NULL;\n\tint ret;\n\n\tWARN_ON(replace == NULL);\n\n\told_blob = *replace;\n\n\tif (length && data) {\n\t\tnew_blob = drm_property_create_blob(dev, length, data);\n\t\tif (IS_ERR(new_blob))\n\t\t\treturn PTR_ERR(new_blob);\n\t}\n\n\tif (obj_holds_id) {\n\t\tret = drm_object_property_set_value(obj_holds_id,\n\t\t\t\t\t\t    prop_holds_id,\n\t\t\t\t\t\t    new_blob ?\n\t\t\t\t\t\t        new_blob->base.id : 0);\n\t\tif (ret != 0)\n\t\t\tgoto err_created;\n\t}\n\n\tdrm_property_blob_put(old_blob);\n\t*replace = new_blob;\n\n\treturn 0;\n\nerr_created:\n\tdrm_property_blob_put(new_blob);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_property_replace_global_blob);\n\n \nbool drm_property_replace_blob(struct drm_property_blob **blob,\n\t\t\t       struct drm_property_blob *new_blob)\n{\n\tstruct drm_property_blob *old_blob = *blob;\n\n\tif (old_blob == new_blob)\n\t\treturn false;\n\n\tdrm_property_blob_put(old_blob);\n\tif (new_blob)\n\t\tdrm_property_blob_get(new_blob);\n\t*blob = new_blob;\n\treturn true;\n}\nEXPORT_SYMBOL(drm_property_replace_blob);\n\nint drm_mode_getblob_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_get_blob *out_resp = data;\n\tstruct drm_property_blob *blob;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tblob = drm_property_lookup_blob(dev, out_resp->blob_id);\n\tif (!blob)\n\t\treturn -ENOENT;\n\n\tif (out_resp->length == blob->length) {\n\t\tif (copy_to_user(u64_to_user_ptr(out_resp->data),\n\t\t\t\t blob->data,\n\t\t\t\t blob->length)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unref;\n\t\t}\n\t}\n\tout_resp->length = blob->length;\nunref:\n\tdrm_property_blob_put(blob);\n\n\treturn ret;\n}\n\nint drm_mode_createblob_ioctl(struct drm_device *dev,\n\t\t\t      void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_create_blob *out_resp = data;\n\tstruct drm_property_blob *blob;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tblob = drm_property_create_blob(dev, out_resp->length, NULL);\n\tif (IS_ERR(blob))\n\t\treturn PTR_ERR(blob);\n\n\tif (copy_from_user(blob->data,\n\t\t\t   u64_to_user_ptr(out_resp->data),\n\t\t\t   out_resp->length)) {\n\t\tret = -EFAULT;\n\t\tgoto out_blob;\n\t}\n\n\t \n\tmutex_lock(&dev->mode_config.blob_lock);\n\tout_resp->blob_id = blob->base.id;\n\tlist_add_tail(&blob->head_file, &file_priv->blobs);\n\tmutex_unlock(&dev->mode_config.blob_lock);\n\n\treturn 0;\n\nout_blob:\n\tdrm_property_blob_put(blob);\n\treturn ret;\n}\n\nint drm_mode_destroyblob_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_destroy_blob *out_resp = data;\n\tstruct drm_property_blob *blob = NULL, *bt;\n\tbool found = false;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tblob = drm_property_lookup_blob(dev, out_resp->blob_id);\n\tif (!blob)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&dev->mode_config.blob_lock);\n\t \n\tlist_for_each_entry(bt, &file_priv->blobs, head_file) {\n\t\tif (bt == blob) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tret = -EPERM;\n\t\tgoto err;\n\t}\n\n\t \n\tlist_del_init(&blob->head_file);\n\tmutex_unlock(&dev->mode_config.blob_lock);\n\n\t \n\tdrm_property_blob_put(blob);\n\tdrm_property_blob_put(blob);\n\n\treturn 0;\n\nerr:\n\tmutex_unlock(&dev->mode_config.blob_lock);\n\tdrm_property_blob_put(blob);\n\n\treturn ret;\n}\n\n \nbool drm_property_change_valid_get(struct drm_property *property,\n\t\t\t\t   uint64_t value, struct drm_mode_object **ref)\n{\n\tint i;\n\n\tif (property->flags & DRM_MODE_PROP_IMMUTABLE)\n\t\treturn false;\n\n\t*ref = NULL;\n\n\tif (drm_property_type_is(property, DRM_MODE_PROP_RANGE)) {\n\t\tif (value < property->values[0] || value > property->values[1])\n\t\t\treturn false;\n\t\treturn true;\n\t} else if (drm_property_type_is(property, DRM_MODE_PROP_SIGNED_RANGE)) {\n\t\tint64_t svalue = U642I64(value);\n\n\t\tif (svalue < U642I64(property->values[0]) ||\n\t\t\t\tsvalue > U642I64(property->values[1]))\n\t\t\treturn false;\n\t\treturn true;\n\t} else if (drm_property_type_is(property, DRM_MODE_PROP_BITMASK)) {\n\t\tuint64_t valid_mask = 0;\n\n\t\tfor (i = 0; i < property->num_values; i++)\n\t\t\tvalid_mask |= (1ULL << property->values[i]);\n\t\treturn !(value & ~valid_mask);\n\t} else if (drm_property_type_is(property, DRM_MODE_PROP_BLOB)) {\n\t\tstruct drm_property_blob *blob;\n\n\t\tif (value == 0)\n\t\t\treturn true;\n\n\t\tblob = drm_property_lookup_blob(property->dev, value);\n\t\tif (blob) {\n\t\t\t*ref = &blob->base;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else if (drm_property_type_is(property, DRM_MODE_PROP_OBJECT)) {\n\t\t \n\t\tif (value == 0)\n\t\t\treturn true;\n\n\t\t*ref = __drm_mode_object_find(property->dev, NULL, value,\n\t\t\t\t\t      property->values[0]);\n\t\treturn *ref != NULL;\n\t}\n\n\tfor (i = 0; i < property->num_values; i++)\n\t\tif (property->values[i] == value)\n\t\t\treturn true;\n\treturn false;\n}\n\nvoid drm_property_change_valid_put(struct drm_property *property,\n\t\tstruct drm_mode_object *ref)\n{\n\tif (!ref)\n\t\treturn;\n\n\tif (drm_property_type_is(property, DRM_MODE_PROP_OBJECT)) {\n\t\tdrm_mode_object_put(ref);\n\t} else if (drm_property_type_is(property, DRM_MODE_PROP_BLOB))\n\t\tdrm_property_blob_put(obj_to_blob(ref));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}