{
  "module_name": "drm_managed.c",
  "hash_id": "10c68cd8edbc3e076191f8d4a214e57ef4878a2eba001e2276af7c1b4ecfc508",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_managed.c",
  "human_readable_source": "\n \n\n#include <drm/drm_managed.h>\n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n\n#include \"drm_internal.h\"\n\n \n\nstruct drmres_node {\n\tstruct list_head\tentry;\n\tdrmres_release_t\trelease;\n\tconst char\t\t*name;\n\tsize_t\t\t\tsize;\n};\n\nstruct drmres {\n\tstruct drmres_node\t\tnode;\n\t \n\tu8 __aligned(ARCH_DMA_MINALIGN) data[];\n};\n\nstatic void free_dr(struct drmres *dr)\n{\n\tkfree_const(dr->node.name);\n\tkfree(dr);\n}\n\nvoid drm_managed_release(struct drm_device *dev)\n{\n\tstruct drmres *dr, *tmp;\n\n\tdrm_dbg_drmres(dev, \"drmres release begin\\n\");\n\tlist_for_each_entry_safe(dr, tmp, &dev->managed.resources, node.entry) {\n\t\tdrm_dbg_drmres(dev, \"REL %p %s (%zu bytes)\\n\",\n\t\t\t       dr, dr->node.name, dr->node.size);\n\n\t\tif (dr->node.release)\n\t\t\tdr->node.release(dev, dr->node.size ? *(void **)&dr->data : NULL);\n\n\t\tlist_del(&dr->node.entry);\n\t\tfree_dr(dr);\n\t}\n\tdrm_dbg_drmres(dev, \"drmres release end\\n\");\n}\n\n \nstatic __always_inline struct drmres * alloc_dr(drmres_release_t release,\n\t\t\t\t\t\tsize_t size, gfp_t gfp, int nid)\n{\n\tsize_t tot_size;\n\tstruct drmres *dr;\n\n\t \n\tif (unlikely(check_add_overflow(sizeof(*dr), size, &tot_size)))\n\t\treturn NULL;\n\n\tdr = kmalloc_node_track_caller(tot_size, gfp, nid);\n\tif (unlikely(!dr))\n\t\treturn NULL;\n\n\tmemset(dr, 0, offsetof(struct drmres, data));\n\n\tINIT_LIST_HEAD(&dr->node.entry);\n\tdr->node.release = release;\n\tdr->node.size = size;\n\n\treturn dr;\n}\n\nstatic void del_dr(struct drm_device *dev, struct drmres *dr)\n{\n\tlist_del_init(&dr->node.entry);\n\n\tdrm_dbg_drmres(dev, \"DEL %p %s (%lu bytes)\\n\",\n\t\t       dr, dr->node.name, (unsigned long) dr->node.size);\n}\n\nstatic void add_dr(struct drm_device *dev, struct drmres *dr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->managed.lock, flags);\n\tlist_add(&dr->node.entry, &dev->managed.resources);\n\tspin_unlock_irqrestore(&dev->managed.lock, flags);\n\n\tdrm_dbg_drmres(dev, \"ADD %p %s (%lu bytes)\\n\",\n\t\t       dr, dr->node.name, (unsigned long) dr->node.size);\n}\n\nvoid drmm_add_final_kfree(struct drm_device *dev, void *container)\n{\n\tWARN_ON(dev->managed.final_kfree);\n\tWARN_ON(dev < (struct drm_device *) container);\n\tWARN_ON(dev + 1 > (struct drm_device *) (container + ksize(container)));\n\tdev->managed.final_kfree = container;\n}\n\nint __drmm_add_action(struct drm_device *dev,\n\t\t      drmres_release_t action,\n\t\t      void *data, const char *name)\n{\n\tstruct drmres *dr;\n\tvoid **void_ptr;\n\n\tdr = alloc_dr(action, data ? sizeof(void*) : 0,\n\t\t      GFP_KERNEL | __GFP_ZERO,\n\t\t      dev_to_node(dev->dev));\n\tif (!dr) {\n\t\tdrm_dbg_drmres(dev, \"failed to add action %s for %p\\n\",\n\t\t\t       name, data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdr->node.name = kstrdup_const(name, GFP_KERNEL);\n\tif (data) {\n\t\tvoid_ptr = (void **)&dr->data;\n\t\t*void_ptr = data;\n\t}\n\n\tadd_dr(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__drmm_add_action);\n\nint __drmm_add_action_or_reset(struct drm_device *dev,\n\t\t\t       drmres_release_t action,\n\t\t\t       void *data, const char *name)\n{\n\tint ret;\n\n\tret = __drmm_add_action(dev, action, data, name);\n\tif (ret)\n\t\taction(dev, data);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__drmm_add_action_or_reset);\n\n \nvoid *drmm_kmalloc(struct drm_device *dev, size_t size, gfp_t gfp)\n{\n\tstruct drmres *dr;\n\n\tdr = alloc_dr(NULL, size, gfp, dev_to_node(dev->dev));\n\tif (!dr) {\n\t\tdrm_dbg_drmres(dev, \"failed to allocate %zu bytes, %u flags\\n\",\n\t\t\t       size, gfp);\n\t\treturn NULL;\n\t}\n\tdr->node.name = kstrdup_const(\"kmalloc\", gfp);\n\n\tadd_dr(dev, dr);\n\n\treturn dr->data;\n}\nEXPORT_SYMBOL(drmm_kmalloc);\n\n \nchar *drmm_kstrdup(struct drm_device *dev, const char *s, gfp_t gfp)\n{\n\tsize_t size;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tsize = strlen(s) + 1;\n\tbuf = drmm_kmalloc(dev, size, gfp);\n\tif (buf)\n\t\tmemcpy(buf, s, size);\n\treturn buf;\n}\nEXPORT_SYMBOL_GPL(drmm_kstrdup);\n\n \nvoid drmm_kfree(struct drm_device *dev, void *data)\n{\n\tstruct drmres *dr_match = NULL, *dr;\n\tunsigned long flags;\n\n\tif (!data)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->managed.lock, flags);\n\tlist_for_each_entry(dr, &dev->managed.resources, node.entry) {\n\t\tif (dr->data == data) {\n\t\t\tdr_match = dr;\n\t\t\tdel_dr(dev, dr_match);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->managed.lock, flags);\n\n\tif (WARN_ON(!dr_match))\n\t\treturn;\n\n\tfree_dr(dr_match);\n}\nEXPORT_SYMBOL(drmm_kfree);\n\nvoid __drmm_mutex_release(struct drm_device *dev, void *res)\n{\n\tstruct mutex *lock = res;\n\n\tmutex_destroy(lock);\n}\nEXPORT_SYMBOL(__drmm_mutex_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}