{
  "module_name": "drm_lease.c",
  "hash_id": "688b36742b4b2c310b44ad06cb6cb8ef7efea075a3f164c44411b0c56d1259fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_lease.c",
  "human_readable_source": "\n \n#include <linux/file.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_auth.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_lease.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n \n\n#define drm_for_each_lessee(lessee, lessor) \\\n\tlist_for_each_entry((lessee), &(lessor)->lessees, lessee_list)\n\nstatic uint64_t drm_lease_idr_object;\n\nstruct drm_master *drm_lease_owner(struct drm_master *master)\n{\n\twhile (master->lessor != NULL)\n\t\tmaster = master->lessor;\n\treturn master;\n}\n\nstatic struct drm_master*\n_drm_find_lessee(struct drm_master *master, int lessee_id)\n{\n\tlockdep_assert_held(&master->dev->mode_config.idr_mutex);\n\treturn idr_find(&drm_lease_owner(master)->lessee_idr, lessee_id);\n}\n\nstatic int _drm_lease_held_master(struct drm_master *master, int id)\n{\n\tlockdep_assert_held(&master->dev->mode_config.idr_mutex);\n\tif (master->lessor)\n\t\treturn idr_find(&master->leases, id) != NULL;\n\treturn true;\n}\n\n \nstatic bool _drm_has_leased(struct drm_master *master, int id)\n{\n\tstruct drm_master *lessee;\n\n\tlockdep_assert_held(&master->dev->mode_config.idr_mutex);\n\tdrm_for_each_lessee(lessee, master)\n\t\tif (_drm_lease_held_master(lessee, id))\n\t\t\treturn true;\n\treturn false;\n}\n\n \nbool _drm_lease_held(struct drm_file *file_priv, int id)\n{\n\tbool ret;\n\tstruct drm_master *master;\n\n\tif (!file_priv)\n\t\treturn true;\n\n\tmaster = drm_file_get_master(file_priv);\n\tif (!master)\n\t\treturn true;\n\tret = _drm_lease_held_master(master, id);\n\tdrm_master_put(&master);\n\n\treturn ret;\n}\n\nbool drm_lease_held(struct drm_file *file_priv, int id)\n{\n\tstruct drm_master *master;\n\tbool ret;\n\n\tif (!file_priv)\n\t\treturn true;\n\n\tmaster = drm_file_get_master(file_priv);\n\tif (!master)\n\t\treturn true;\n\tif (!master->lessor) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\tmutex_lock(&master->dev->mode_config.idr_mutex);\n\tret = _drm_lease_held_master(master, id);\n\tmutex_unlock(&master->dev->mode_config.idr_mutex);\n\nout:\n\tdrm_master_put(&master);\n\treturn ret;\n}\n\n \nuint32_t drm_lease_filter_crtcs(struct drm_file *file_priv, uint32_t crtcs_in)\n{\n\tstruct drm_master *master;\n\tstruct drm_device *dev;\n\tstruct drm_crtc *crtc;\n\tint count_in, count_out;\n\tuint32_t crtcs_out = 0;\n\n\tif (!file_priv)\n\t\treturn crtcs_in;\n\n\tmaster = drm_file_get_master(file_priv);\n\tif (!master)\n\t\treturn crtcs_in;\n\tif (!master->lessor) {\n\t\tcrtcs_out = crtcs_in;\n\t\tgoto out;\n\t}\n\tdev = master->dev;\n\n\tcount_in = count_out = 0;\n\tmutex_lock(&master->dev->mode_config.idr_mutex);\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (_drm_lease_held_master(master, crtc->base.id)) {\n\t\t\tuint32_t mask_in = 1ul << count_in;\n\n\t\t\tif ((crtcs_in & mask_in) != 0) {\n\t\t\t\tuint32_t mask_out = 1ul << count_out;\n\n\t\t\t\tcrtcs_out |= mask_out;\n\t\t\t}\n\t\t\tcount_out++;\n\t\t}\n\t\tcount_in++;\n\t}\n\tmutex_unlock(&master->dev->mode_config.idr_mutex);\n\nout:\n\tdrm_master_put(&master);\n\treturn crtcs_out;\n}\n\n \nstatic struct drm_master *drm_lease_create(struct drm_master *lessor, struct idr *leases)\n{\n\tstruct drm_device *dev = lessor->dev;\n\tint error;\n\tstruct drm_master *lessee;\n\tint object;\n\tint id;\n\tvoid *entry;\n\n\tdrm_dbg_lease(dev, \"lessor %d\\n\", lessor->lessee_id);\n\n\tlessee = drm_master_create(lessor->dev);\n\tif (!lessee) {\n\t\tdrm_dbg_lease(dev, \"drm_master_create failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\n\tidr_for_each_entry(leases, entry, object) {\n\t\terror = 0;\n\t\tif (!idr_find(&dev->mode_config.object_idr, object))\n\t\t\terror = -ENOENT;\n\t\telse if (_drm_has_leased(lessor, object))\n\t\t\terror = -EBUSY;\n\n\t\tif (error != 0) {\n\t\t\tdrm_dbg_lease(dev, \"object %d failed %d\\n\", object, error);\n\t\t\tgoto out_lessee;\n\t\t}\n\t}\n\n\t \n\tid = idr_alloc(&(drm_lease_owner(lessor)->lessee_idr), lessee, 1, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\terror = id;\n\t\tgoto out_lessee;\n\t}\n\n\tlessee->lessee_id = id;\n\tlessee->lessor = drm_master_get(lessor);\n\tlist_add_tail(&lessee->lessee_list, &lessor->lessees);\n\n\t \n\tlessee->leases = *leases;\n\tdrm_dbg_lease(dev, \"new lessee %d %p, lessor %d %p\\n\",\n\t\t      lessee->lessee_id, lessee, lessor->lessee_id, lessor);\n\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\treturn lessee;\n\nout_lessee:\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\tdrm_master_put(&lessee);\n\n\treturn ERR_PTR(error);\n}\n\nvoid drm_lease_destroy(struct drm_master *master)\n{\n\tstruct drm_device *dev = master->dev;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\n\tdrm_dbg_lease(dev, \"drm_lease_destroy %d\\n\", master->lessee_id);\n\n\t \n\tWARN_ON(!list_empty(&master->lessees));\n\n\t \n\tif (master->lessee_id != 0) {\n\t\tdrm_dbg_lease(dev, \"remove master %d from device list of lessees\\n\",\n\t\t\t      master->lessee_id);\n\t\tidr_remove(&(drm_lease_owner(master)->lessee_idr), master->lessee_id);\n\t}\n\n\t \n\tlist_del(&master->lessee_list);\n\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\tif (master->lessor) {\n\t\t \n\t\tdrm_sysfs_lease_event(dev);\n\t\tdrm_master_put(&master->lessor);\n\t}\n\n\tdrm_dbg_lease(dev, \"drm_lease_destroy done %d\\n\", master->lessee_id);\n}\n\nstatic void _drm_lease_revoke(struct drm_master *top)\n{\n\tint object;\n\tvoid *entry;\n\tstruct drm_master *master = top;\n\n\tlockdep_assert_held(&top->dev->mode_config.idr_mutex);\n\n\t \n\tfor (;;) {\n\t\tdrm_dbg_lease(master->dev, \"revoke leases for %p %d\\n\",\n\t\t\t      master, master->lessee_id);\n\n\t\t \n\t\tidr_for_each_entry(&master->leases, entry, object)\n\t\t\tidr_remove(&master->leases, object);\n\n\t\t \n\n\t\t \n\t\tif (!list_empty(&master->lessees)) {\n\t\t\tmaster = list_first_entry(&master->lessees, struct drm_master, lessee_list);\n\t\t} else {\n\t\t\t \n\t\t\twhile (master != top && master == list_last_entry(&master->lessor->lessees, struct drm_master, lessee_list))\n\t\t\t\tmaster = master->lessor;\n\n\t\t\tif (master == top)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmaster = list_next_entry(master, lessee_list);\n\t\t}\n\t}\n}\n\nvoid drm_lease_revoke(struct drm_master *top)\n{\n\tmutex_lock(&top->dev->mode_config.idr_mutex);\n\t_drm_lease_revoke(top);\n\tmutex_unlock(&top->dev->mode_config.idr_mutex);\n}\n\nstatic int validate_lease(struct drm_device *dev,\n\t\t\t  int object_count,\n\t\t\t  struct drm_mode_object **objects,\n\t\t\t  bool universal_planes)\n{\n\tint o;\n\tint has_crtc = -1;\n\tint has_connector = -1;\n\tint has_plane = -1;\n\n\t \n\n\tfor (o = 0; o < object_count; o++) {\n\t\tif (objects[o]->type == DRM_MODE_OBJECT_CRTC && has_crtc == -1) {\n\t\t\thas_crtc = o;\n\t\t}\n\t\tif (objects[o]->type == DRM_MODE_OBJECT_CONNECTOR && has_connector == -1)\n\t\t\thas_connector = o;\n\n\t\tif (universal_planes) {\n\t\t\tif (objects[o]->type == DRM_MODE_OBJECT_PLANE && has_plane == -1)\n\t\t\t\thas_plane = o;\n\t\t}\n\t}\n\tif (has_crtc == -1 || has_connector == -1)\n\t\treturn -EINVAL;\n\tif (universal_planes && has_plane == -1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int fill_object_idr(struct drm_device *dev,\n\t\t\t   struct drm_file *lessor_priv,\n\t\t\t   struct idr *leases,\n\t\t\t   int object_count,\n\t\t\t   u32 *object_ids)\n{\n\tstruct drm_mode_object **objects;\n\tu32 o;\n\tint ret;\n\tbool universal_planes = READ_ONCE(lessor_priv->universal_planes);\n\n\tobjects = kcalloc(object_count, sizeof(struct drm_mode_object *),\n\t\t\t  GFP_KERNEL);\n\tif (!objects)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (o = 0; o < object_count; o++) {\n\t\tobjects[o] = drm_mode_object_find(dev, lessor_priv,\n\t\t\t\t\t\t  object_ids[o],\n\t\t\t\t\t\t  DRM_MODE_OBJECT_ANY);\n\t\tif (!objects[o]) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_free_objects;\n\t\t}\n\n\t\tif (!drm_mode_object_lease_required(objects[o]->type)) {\n\t\t\tDRM_DEBUG_KMS(\"invalid object for lease\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_objects;\n\t\t}\n\t}\n\n\tret = validate_lease(dev, object_count, objects, universal_planes);\n\tif (ret) {\n\t\tdrm_dbg_lease(dev, \"lease validation failed\\n\");\n\t\tgoto out_free_objects;\n\t}\n\n\t \n\tfor (o = 0; o < object_count; o++) {\n\t\tstruct drm_mode_object *obj = objects[o];\n\t\tu32 object_id = objects[o]->id;\n\n\t\tdrm_dbg_lease(dev, \"Adding object %d to lease\\n\", object_id);\n\n\t\t \n\t\tret = idr_alloc(leases, &drm_lease_idr_object , object_id, object_id + 1, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tdrm_dbg_lease(dev, \"Object %d cannot be inserted into leases (%d)\\n\",\n\t\t\t\t      object_id, ret);\n\t\t\tgoto out_free_objects;\n\t\t}\n\t\tif (obj->type == DRM_MODE_OBJECT_CRTC && !universal_planes) {\n\t\t\tstruct drm_crtc *crtc = obj_to_crtc(obj);\n\n\t\t\tret = idr_alloc(leases, &drm_lease_idr_object, crtc->primary->base.id, crtc->primary->base.id + 1, GFP_KERNEL);\n\t\t\tif (ret < 0) {\n\t\t\t\tdrm_dbg_lease(dev, \"Object primary plane %d cannot be inserted into leases (%d)\\n\",\n\t\t\t\t\t      object_id, ret);\n\t\t\t\tgoto out_free_objects;\n\t\t\t}\n\t\t\tif (crtc->cursor) {\n\t\t\t\tret = idr_alloc(leases, &drm_lease_idr_object, crtc->cursor->base.id, crtc->cursor->base.id + 1, GFP_KERNEL);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdrm_dbg_lease(dev, \"Object cursor plane %d cannot be inserted into leases (%d)\\n\",\n\t\t\t\t\t\t      object_id, ret);\n\t\t\t\t\tgoto out_free_objects;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\nout_free_objects:\n\tfor (o = 0; o < object_count; o++) {\n\t\tif (objects[o])\n\t\t\tdrm_mode_object_put(objects[o]);\n\t}\n\tkfree(objects);\n\treturn ret;\n}\n\n \nint drm_mode_create_lease_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *lessor_priv)\n{\n\tstruct drm_mode_create_lease *cl = data;\n\tsize_t object_count;\n\tint ret = 0;\n\tstruct idr leases;\n\tstruct drm_master *lessor;\n\tstruct drm_master *lessee = NULL;\n\tstruct file *lessee_file = NULL;\n\tstruct file *lessor_file = lessor_priv->filp;\n\tstruct drm_file *lessee_priv;\n\tint fd = -1;\n\tuint32_t *object_ids;\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cl->flags && (cl->flags & ~(O_CLOEXEC | O_NONBLOCK))) {\n\t\tdrm_dbg_lease(dev, \"invalid flags\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlessor = drm_file_get_master(lessor_priv);\n\t \n\tif (lessor->lessor) {\n\t\tdrm_dbg_lease(dev, \"recursive leasing not allowed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_lessor;\n\t}\n\n\tobject_count = cl->object_count;\n\n\t \n\tidr_init(&leases);\n\tif (object_count != 0) {\n\t\tobject_ids = memdup_array_user(u64_to_user_ptr(cl->object_ids),\n\t\t\t\t\t       object_count, sizeof(__u32));\n\t\tif (IS_ERR(object_ids)) {\n\t\t\tret = PTR_ERR(object_ids);\n\t\t\tidr_destroy(&leases);\n\t\t\tgoto out_lessor;\n\t\t}\n\n\t\t \n\t\tret = fill_object_idr(dev, lessor_priv, &leases,\n\t\t\t\t      object_count, object_ids);\n\t\tkfree(object_ids);\n\t\tif (ret) {\n\t\t\tdrm_dbg_lease(dev, \"lease object lookup failed: %i\\n\", ret);\n\t\t\tidr_destroy(&leases);\n\t\t\tgoto out_lessor;\n\t\t}\n\t}\n\n\t \n\tfd = get_unused_fd_flags(cl->flags & (O_CLOEXEC | O_NONBLOCK));\n\tif (fd < 0) {\n\t\tidr_destroy(&leases);\n\t\tret = fd;\n\t\tgoto out_lessor;\n\t}\n\n\tdrm_dbg_lease(dev, \"Creating lease\\n\");\n\t \n\tlessee = drm_lease_create(lessor, &leases);\n\n\tif (IS_ERR(lessee)) {\n\t\tret = PTR_ERR(lessee);\n\t\tidr_destroy(&leases);\n\t\tgoto out_leases;\n\t}\n\n\t \n\tdrm_dbg_lease(dev, \"Allocating lease file\\n\");\n\tlessee_file = file_clone_open(lessor_file);\n\tif (IS_ERR(lessee_file)) {\n\t\tret = PTR_ERR(lessee_file);\n\t\tgoto out_lessee;\n\t}\n\n\tlessee_priv = lessee_file->private_data;\n\t \n\tdrm_master_put(&lessee_priv->master);\n\tlessee_priv->master = lessee;\n\tlessee_priv->is_master = 1;\n\tlessee_priv->authenticated = 1;\n\n\t \n\tdrm_dbg_lease(dev, \"Returning fd %d id %d\\n\", fd, lessee->lessee_id);\n\tcl->fd = fd;\n\tcl->lessee_id = lessee->lessee_id;\n\n\t \n\tfd_install(fd, lessee_file);\n\n\tdrm_master_put(&lessor);\n\tdrm_dbg_lease(dev, \"drm_mode_create_lease_ioctl succeeded\\n\");\n\treturn 0;\n\nout_lessee:\n\tdrm_master_put(&lessee);\n\nout_leases:\n\tput_unused_fd(fd);\n\nout_lessor:\n\tdrm_master_put(&lessor);\n\tdrm_dbg_lease(dev, \"drm_mode_create_lease_ioctl failed: %d\\n\", ret);\n\treturn ret;\n}\n\nint drm_mode_list_lessees_ioctl(struct drm_device *dev,\n\t\t\t       void *data, struct drm_file *lessor_priv)\n{\n\tstruct drm_mode_list_lessees *arg = data;\n\t__u32 __user *lessee_ids = (__u32 __user *) (uintptr_t) (arg->lessees_ptr);\n\t__u32 count_lessees = arg->count_lessees;\n\tstruct drm_master *lessor, *lessee;\n\tint count;\n\tint ret = 0;\n\n\tif (arg->pad)\n\t\treturn -EINVAL;\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tlessor = drm_file_get_master(lessor_priv);\n\tdrm_dbg_lease(dev, \"List lessees for %d\\n\", lessor->lessee_id);\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\n\tcount = 0;\n\tdrm_for_each_lessee(lessee, lessor) {\n\t\t \n\t\tif (!idr_is_empty(&lessee->leases)) {\n\t\t\tif (count_lessees > count) {\n\t\t\t\tdrm_dbg_lease(dev, \"Add lessee %d\\n\",\n\t\t\t\t\t      lessee->lessee_id);\n\t\t\t\tret = put_user(lessee->lessee_id, lessee_ids + count);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tdrm_dbg_lease(dev, \"Lessor leases to %d\\n\", count);\n\tif (ret == 0)\n\t\targ->count_lessees = count;\n\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tdrm_master_put(&lessor);\n\n\treturn ret;\n}\n\n \nint drm_mode_get_lease_ioctl(struct drm_device *dev,\n\t\t\t     void *data, struct drm_file *lessee_priv)\n{\n\tstruct drm_mode_get_lease *arg = data;\n\t__u32 __user *object_ids = (__u32 __user *) (uintptr_t) (arg->objects_ptr);\n\t__u32 count_objects = arg->count_objects;\n\tstruct drm_master *lessee;\n\tstruct idr *object_idr;\n\tint count;\n\tvoid *entry;\n\tint object;\n\tint ret = 0;\n\n\tif (arg->pad)\n\t\treturn -EINVAL;\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tlessee = drm_file_get_master(lessee_priv);\n\tdrm_dbg_lease(dev, \"get lease for %d\\n\", lessee->lessee_id);\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\n\tif (lessee->lessor == NULL)\n\t\t \n\t\tobject_idr = &lessee->dev->mode_config.object_idr;\n\telse\n\t\t \n\t\tobject_idr = &lessee->leases;\n\n\tcount = 0;\n\tidr_for_each_entry(object_idr, entry, object) {\n\t\tif (count_objects > count) {\n\t\t\tdrm_dbg_lease(dev, \"adding object %d\\n\", object);\n\t\t\tret = put_user(object, object_ids + count);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t}\n\n\tDRM_DEBUG(\"lease holds %d objects\\n\", count);\n\tif (ret == 0)\n\t\targ->count_objects = count;\n\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tdrm_master_put(&lessee);\n\n\treturn ret;\n}\n\n \nint drm_mode_revoke_lease_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *lessor_priv)\n{\n\tstruct drm_mode_revoke_lease *arg = data;\n\tstruct drm_master *lessor;\n\tstruct drm_master *lessee;\n\tint ret = 0;\n\n\tdrm_dbg_lease(dev, \"revoke lease for %d\\n\", arg->lessee_id);\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tlessor = drm_file_get_master(lessor_priv);\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\n\tlessee = _drm_find_lessee(lessor, arg->lessee_id);\n\n\t \n\tif (!lessee) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (lessee->lessor != lessor) {\n\t\tret = -EACCES;\n\t\tgoto fail;\n\t}\n\n\t_drm_lease_revoke(lessee);\n\nfail:\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\tdrm_master_put(&lessor);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}