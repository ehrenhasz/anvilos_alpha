{
  "module_name": "drm_agpsupport.c",
  "hash_id": "1e7b109e49b28e765bee23b03a3737553150d6f1e1c9cdcf6ba53c5ee5365a0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_agpsupport.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#if IS_ENABLED(CONFIG_AGP)\n#include <asm/agp.h>\n#endif\n\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_print.h>\n\n#include \"drm_legacy.h\"\n\n#if IS_ENABLED(CONFIG_AGP)\n\n \nint drm_legacy_agp_info(struct drm_device *dev, struct drm_agp_info *info)\n{\n\tstruct agp_kern_info *kern;\n\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\n\tkern = &dev->agp->agp_info;\n\tinfo->agp_version_major = kern->version.major;\n\tinfo->agp_version_minor = kern->version.minor;\n\tinfo->mode = kern->mode;\n\tinfo->aperture_base = kern->aper_base;\n\tinfo->aperture_size = kern->aper_size * 1024 * 1024;\n\tinfo->memory_allowed = kern->max_memory << PAGE_SHIFT;\n\tinfo->memory_used = kern->current_memory << PAGE_SHIFT;\n\tinfo->id_vendor = kern->device->vendor;\n\tinfo->id_device = kern->device->device;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_info);\n\nint drm_legacy_agp_info_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_agp_info *info = data;\n\tint err;\n\n\terr = drm_legacy_agp_info(dev, info);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nint drm_legacy_agp_acquire(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tif (!dev->agp)\n\t\treturn -ENODEV;\n\tif (dev->agp->acquired)\n\t\treturn -EBUSY;\n\tdev->agp->bridge = agp_backend_acquire(pdev);\n\tif (!dev->agp->bridge)\n\t\treturn -ENODEV;\n\tdev->agp->acquired = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_acquire);\n\n \nint drm_legacy_agp_acquire_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\treturn drm_legacy_agp_acquire((struct drm_device *)file_priv->minor->dev);\n}\n\n \nint drm_legacy_agp_release(struct drm_device *dev)\n{\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\tagp_backend_release(dev->agp->bridge);\n\tdev->agp->acquired = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_release);\n\nint drm_legacy_agp_release_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\treturn drm_legacy_agp_release(dev);\n}\n\n \nint drm_legacy_agp_enable(struct drm_device *dev, struct drm_agp_mode mode)\n{\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\n\tdev->agp->mode = mode.mode;\n\tagp_enable(dev->agp->bridge, mode.mode);\n\tdev->agp->enabled = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_enable);\n\nint drm_legacy_agp_enable_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_agp_mode *mode = data;\n\n\treturn drm_legacy_agp_enable(dev, *mode);\n}\n\n \nint drm_legacy_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request)\n{\n\tstruct drm_agp_mem *entry;\n\tstruct agp_memory *memory;\n\tunsigned long pages;\n\tu32 type;\n\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tpages = DIV_ROUND_UP(request->size, PAGE_SIZE);\n\ttype = (u32) request->type;\n\tmemory = agp_allocate_memory(dev->agp->bridge, pages, type);\n\tif (!memory) {\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tentry->handle = (unsigned long)memory->key + 1;\n\tentry->memory = memory;\n\tentry->bound = 0;\n\tentry->pages = pages;\n\tlist_add(&entry->head, &dev->agp->memory);\n\n\trequest->handle = entry->handle;\n\trequest->physical = memory->physical;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_alloc);\n\n\nint drm_legacy_agp_alloc_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_agp_buffer *request = data;\n\n\treturn drm_legacy_agp_alloc(dev, request);\n}\n\n \nstatic struct drm_agp_mem *drm_legacy_agp_lookup_entry(struct drm_device *dev,\n\t\t\t\t\t\t       unsigned long handle)\n{\n\tstruct drm_agp_mem *entry;\n\n\tlist_for_each_entry(entry, &dev->agp->memory, head) {\n\t\tif (entry->handle == handle)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\n \nint drm_legacy_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request)\n{\n\tstruct drm_agp_mem *entry;\n\tint ret;\n\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\tentry = drm_legacy_agp_lookup_entry(dev, request->handle);\n\tif (!entry || !entry->bound)\n\t\treturn -EINVAL;\n\tret = agp_unbind_memory(entry->memory);\n\tif (ret == 0)\n\t\tentry->bound = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_legacy_agp_unbind);\n\n\nint drm_legacy_agp_unbind_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_agp_binding *request = data;\n\n\treturn drm_legacy_agp_unbind(dev, request);\n}\n\n \nint drm_legacy_agp_bind(struct drm_device *dev, struct drm_agp_binding *request)\n{\n\tstruct drm_agp_mem *entry;\n\tint retcode;\n\tint page;\n\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\tentry = drm_legacy_agp_lookup_entry(dev, request->handle);\n\tif (!entry || entry->bound)\n\t\treturn -EINVAL;\n\tpage = DIV_ROUND_UP(request->offset, PAGE_SIZE);\n\tretcode = agp_bind_memory(entry->memory, page);\n\tif (retcode)\n\t\treturn retcode;\n\tentry->bound = dev->agp->base + (page << PAGE_SHIFT);\n\tDRM_DEBUG(\"base = 0x%lx entry->bound = 0x%lx\\n\",\n\t\t  dev->agp->base, entry->bound);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_bind);\n\n\nint drm_legacy_agp_bind_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_agp_binding *request = data;\n\n\treturn drm_legacy_agp_bind(dev, request);\n}\n\n \nint drm_legacy_agp_free(struct drm_device *dev, struct drm_agp_buffer *request)\n{\n\tstruct drm_agp_mem *entry;\n\n\tif (!dev->agp || !dev->agp->acquired)\n\t\treturn -EINVAL;\n\tentry = drm_legacy_agp_lookup_entry(dev, request->handle);\n\tif (!entry)\n\t\treturn -EINVAL;\n\tif (entry->bound)\n\t\tagp_unbind_memory(entry->memory);\n\n\tlist_del(&entry->head);\n\n\tagp_free_memory(entry->memory);\n\tkfree(entry);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_legacy_agp_free);\n\n\nint drm_legacy_agp_free_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_agp_buffer *request = data;\n\n\treturn drm_legacy_agp_free(dev, request);\n}\n\n \nstruct drm_agp_head *drm_legacy_agp_init(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct drm_agp_head *head = NULL;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (!head)\n\t\treturn NULL;\n\thead->bridge = agp_find_bridge(pdev);\n\tif (!head->bridge) {\n\t\thead->bridge = agp_backend_acquire(pdev);\n\t\tif (!head->bridge) {\n\t\t\tkfree(head);\n\t\t\treturn NULL;\n\t\t}\n\t\tagp_copy_info(head->bridge, &head->agp_info);\n\t\tagp_backend_release(head->bridge);\n\t} else {\n\t\tagp_copy_info(head->bridge, &head->agp_info);\n\t}\n\tif (head->agp_info.chipset == NOT_SUPPORTED) {\n\t\tkfree(head);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&head->memory);\n\thead->cant_use_aperture = head->agp_info.cant_use_aperture;\n\thead->page_mask = head->agp_info.page_mask;\n\thead->base = head->agp_info.aper_base;\n\treturn head;\n}\n \nEXPORT_SYMBOL(drm_legacy_agp_init);\n\n \nvoid drm_legacy_agp_clear(struct drm_device *dev)\n{\n\tstruct drm_agp_mem *entry, *tempe;\n\n\tif (!dev->agp)\n\t\treturn;\n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn;\n\n\tlist_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {\n\t\tif (entry->bound)\n\t\t\tagp_unbind_memory(entry->memory);\n\t\tagp_free_memory(entry->memory);\n\t\tkfree(entry);\n\t}\n\tINIT_LIST_HEAD(&dev->agp->memory);\n\n\tif (dev->agp->acquired)\n\t\tdrm_legacy_agp_release(dev);\n\n\tdev->agp->acquired = 0;\n\tdev->agp->enabled = 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}