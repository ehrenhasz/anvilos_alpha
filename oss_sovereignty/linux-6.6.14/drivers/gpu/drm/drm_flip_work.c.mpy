{
  "module_name": "drm_flip_work.c",
  "hash_id": "94490e8751bccab5ae2891132a5931f30a10d35a4be0a567493dec3303c99b52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_flip_work.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include <drm/drm_flip_work.h>\n#include <drm/drm_print.h>\n#include <drm/drm_util.h>\n\n \nstruct drm_flip_task *drm_flip_work_allocate_task(void *data, gfp_t flags)\n{\n\tstruct drm_flip_task *task;\n\n\ttask = kzalloc(sizeof(*task), flags);\n\tif (task)\n\t\ttask->data = data;\n\n\treturn task;\n}\nEXPORT_SYMBOL(drm_flip_work_allocate_task);\n\n \nvoid drm_flip_work_queue_task(struct drm_flip_work *work,\n\t\t\t      struct drm_flip_task *task)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&work->lock, flags);\n\tlist_add_tail(&task->node, &work->queued);\n\tspin_unlock_irqrestore(&work->lock, flags);\n}\nEXPORT_SYMBOL(drm_flip_work_queue_task);\n\n \nvoid drm_flip_work_queue(struct drm_flip_work *work, void *val)\n{\n\tstruct drm_flip_task *task;\n\n\ttask = drm_flip_work_allocate_task(val,\n\t\t\t\tdrm_can_sleep() ? GFP_KERNEL : GFP_ATOMIC);\n\tif (task) {\n\t\tdrm_flip_work_queue_task(work, task);\n\t} else {\n\t\tDRM_ERROR(\"%s could not allocate task!\\n\", work->name);\n\t\twork->func(work, val);\n\t}\n}\nEXPORT_SYMBOL(drm_flip_work_queue);\n\n \nvoid drm_flip_work_commit(struct drm_flip_work *work,\n\t\tstruct workqueue_struct *wq)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&work->lock, flags);\n\tlist_splice_tail(&work->queued, &work->commited);\n\tINIT_LIST_HEAD(&work->queued);\n\tspin_unlock_irqrestore(&work->lock, flags);\n\tqueue_work(wq, &work->worker);\n}\nEXPORT_SYMBOL(drm_flip_work_commit);\n\nstatic void flip_worker(struct work_struct *w)\n{\n\tstruct drm_flip_work *work = container_of(w, struct drm_flip_work, worker);\n\tstruct list_head tasks;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tstruct drm_flip_task *task, *tmp;\n\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tspin_lock_irqsave(&work->lock, flags);\n\t\tlist_splice_tail(&work->commited, &tasks);\n\t\tINIT_LIST_HEAD(&work->commited);\n\t\tspin_unlock_irqrestore(&work->lock, flags);\n\n\t\tif (list_empty(&tasks))\n\t\t\tbreak;\n\n\t\tlist_for_each_entry_safe(task, tmp, &tasks, node) {\n\t\t\twork->func(work, task->data);\n\t\t\tkfree(task);\n\t\t}\n\t}\n}\n\n \nvoid drm_flip_work_init(struct drm_flip_work *work,\n\t\tconst char *name, drm_flip_func_t func)\n{\n\twork->name = name;\n\tINIT_LIST_HEAD(&work->queued);\n\tINIT_LIST_HEAD(&work->commited);\n\tspin_lock_init(&work->lock);\n\twork->func = func;\n\n\tINIT_WORK(&work->worker, flip_worker);\n}\nEXPORT_SYMBOL(drm_flip_work_init);\n\n \nvoid drm_flip_work_cleanup(struct drm_flip_work *work)\n{\n\tWARN_ON(!list_empty(&work->queued) || !list_empty(&work->commited));\n}\nEXPORT_SYMBOL(drm_flip_work_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}