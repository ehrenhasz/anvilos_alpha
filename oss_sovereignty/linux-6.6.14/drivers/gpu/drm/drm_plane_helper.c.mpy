{
  "module_name": "drm_plane_helper.c",
  "hash_id": "f494e569142d2c6d2e5d6eca14f49bd9e630956d783fe63a553d37aae116338e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_plane_helper.c",
  "human_readable_source": " \n\n#include <linux/list.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_rect.h>\n\n#define SUBPIXEL_MASK 0xffff\n\n \n\n \nstatic int get_connectors_for_crtc(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_connector **connector_list,\n\t\t\t\t   int num_connectors)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint count = 0;\n\n\t \n\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder && connector->encoder->crtc == crtc) {\n\t\t\tif (connector_list != NULL && count < num_connectors)\n\t\t\t\t*(connector_list++) = connector;\n\n\t\t\tcount++;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn count;\n}\n\nstatic int drm_plane_helper_check_update(struct drm_plane *plane,\n\t\t\t\t\t struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_framebuffer *fb,\n\t\t\t\t\t struct drm_rect *src,\n\t\t\t\t\t struct drm_rect *dst,\n\t\t\t\t\t unsigned int rotation,\n\t\t\t\t\t int min_scale,\n\t\t\t\t\t int max_scale,\n\t\t\t\t\t bool can_position,\n\t\t\t\t\t bool can_update_disabled,\n\t\t\t\t\t bool *visible)\n{\n\tstruct drm_plane_state plane_state = {\n\t\t.plane = plane,\n\t\t.crtc = crtc,\n\t\t.fb = fb,\n\t\t.src_x = src->x1,\n\t\t.src_y = src->y1,\n\t\t.src_w = drm_rect_width(src),\n\t\t.src_h = drm_rect_height(src),\n\t\t.crtc_x = dst->x1,\n\t\t.crtc_y = dst->y1,\n\t\t.crtc_w = drm_rect_width(dst),\n\t\t.crtc_h = drm_rect_height(dst),\n\t\t.rotation = rotation,\n\t};\n\tstruct drm_crtc_state crtc_state = {\n\t\t.crtc = crtc,\n\t\t.enable = crtc->enabled,\n\t\t.mode = crtc->mode,\n\t};\n\tint ret;\n\n\tret = drm_atomic_helper_check_plane_state(&plane_state, &crtc_state,\n\t\t\t\t\t\t  min_scale, max_scale,\n\t\t\t\t\t\t  can_position,\n\t\t\t\t\t\t  can_update_disabled);\n\tif (ret)\n\t\treturn ret;\n\n\t*src = plane_state.src;\n\t*dst = plane_state.dst;\n\t*visible = plane_state.visible;\n\n\treturn 0;\n}\n\n \nint drm_plane_helper_update_primary(struct drm_plane *plane, struct drm_crtc *crtc,\n\t\t\t\t    struct drm_framebuffer *fb,\n\t\t\t\t    int crtc_x, int crtc_y,\n\t\t\t\t    unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t\t    uint32_t src_x, uint32_t src_y,\n\t\t\t\t    uint32_t src_w, uint32_t src_h,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_mode_set set = {\n\t\t.crtc = crtc,\n\t\t.fb = fb,\n\t\t.mode = &crtc->mode,\n\t\t.x = src_x >> 16,\n\t\t.y = src_y >> 16,\n\t};\n\tstruct drm_rect src = {\n\t\t.x1 = src_x,\n\t\t.y1 = src_y,\n\t\t.x2 = src_x + src_w,\n\t\t.y2 = src_y + src_h,\n\t};\n\tstruct drm_rect dest = {\n\t\t.x1 = crtc_x,\n\t\t.y1 = crtc_y,\n\t\t.x2 = crtc_x + crtc_w,\n\t\t.y2 = crtc_y + crtc_h,\n\t};\n\tstruct drm_device *dev = plane->dev;\n\tstruct drm_connector **connector_list;\n\tint num_connectors, ret;\n\tbool visible;\n\n\tif (drm_WARN_ON_ONCE(dev, drm_drv_uses_atomic_modeset(dev)))\n\t\treturn -EINVAL;\n\n\tret = drm_plane_helper_check_update(plane, crtc, fb,\n\t\t\t\t\t    &src, &dest,\n\t\t\t\t\t    DRM_MODE_ROTATE_0,\n\t\t\t\t\t    DRM_PLANE_NO_SCALING,\n\t\t\t\t\t    DRM_PLANE_NO_SCALING,\n\t\t\t\t\t    false, false, &visible);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!visible)\n\t\t \n\t\treturn plane->funcs->disable_plane(plane, ctx);\n\n\t \n\tnum_connectors = get_connectors_for_crtc(crtc, NULL, 0);\n\tBUG_ON(num_connectors == 0);\n\tconnector_list = kcalloc(num_connectors, sizeof(*connector_list),\n\t\t\t\t GFP_KERNEL);\n\tif (!connector_list)\n\t\treturn -ENOMEM;\n\tget_connectors_for_crtc(crtc, connector_list, num_connectors);\n\n\tset.connectors = connector_list;\n\tset.num_connectors = num_connectors;\n\n\t \n\tret = crtc->funcs->set_config(&set, ctx);\n\n\tkfree(connector_list);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_plane_helper_update_primary);\n\n \nint drm_plane_helper_disable_primary(struct drm_plane *plane,\n\t\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = plane->dev;\n\n\tdrm_WARN_ON_ONCE(dev, drm_drv_uses_atomic_modeset(dev));\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_plane_helper_disable_primary);\n\n \nvoid drm_plane_helper_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n\tkfree(plane);\n}\nEXPORT_SYMBOL(drm_plane_helper_destroy);\n\n \nint drm_plane_helper_atomic_check(struct drm_plane *plane, struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_crtc *new_crtc = new_plane_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\n\tif (new_crtc)\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_crtc);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state, new_crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, false);\n}\nEXPORT_SYMBOL(drm_plane_helper_atomic_check);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}