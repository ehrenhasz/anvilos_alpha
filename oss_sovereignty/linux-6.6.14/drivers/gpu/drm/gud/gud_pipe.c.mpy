{
  "module_name": "gud_pipe.c",
  "hash_id": "9e7b73980086300e07a1074db5bee44dfcd28f90eddd62f8e1f991df0f7797f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gud/gud_pipe.c",
  "human_readable_source": "\n \n\n#include <linux/lz4.h>\n#include <linux/usb.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/gud.h>\n\n#include \"gud_internal.h\"\n\n \nstatic bool gud_async_flush;\nmodule_param_named(async_flush, gud_async_flush, bool, 0644);\nMODULE_PARM_DESC(async_flush, \"Enable asynchronous flushing [default=0]\");\n\n \n\nstatic bool gud_is_big_endian(void)\n{\n#if defined(__BIG_ENDIAN)\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic size_t gud_xrgb8888_to_r124(u8 *dst, const struct drm_format_info *format,\n\t\t\t\t   void *src, struct drm_framebuffer *fb,\n\t\t\t\t   struct drm_rect *rect)\n{\n\tunsigned int block_width = drm_format_info_block_width(format, 0);\n\tunsigned int bits_per_pixel = 8 / block_width;\n\tunsigned int x, y, width, height;\n\tu8 pix, *pix8, *block = dst;  \n\tstruct iosys_map dst_map, vmap;\n\tsize_t len;\n\tvoid *buf;\n\n\tWARN_ON_ONCE(format->char_per_block[0] != 1);\n\n\t \n\trect->x1 = ALIGN_DOWN(rect->x1, block_width);\n\twidth = drm_rect_width(rect);\n\theight = drm_rect_height(rect);\n\tlen = drm_format_info_min_pitch(format, 0, width) * height;\n\n\tbuf = kmalloc(width * height, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\n\tiosys_map_set_vaddr(&dst_map, buf);\n\tiosys_map_set_vaddr(&vmap, src);\n\tdrm_fb_xrgb8888_to_gray8(&dst_map, NULL, &vmap, fb, rect);\n\tpix8 = buf;\n\n\tfor (y = 0; y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tunsigned int pixpos = x % block_width;  \n\t\t\tunsigned int pixshift = (block_width - pixpos - 1) * bits_per_pixel;\n\n\t\t\tif (!pixpos) {\n\t\t\t\tblock = dst++;\n\t\t\t\t*block = 0;\n\t\t\t}\n\n\t\t\tpix = (*pix8++) >> (8 - bits_per_pixel);\n\t\t\t*block |= pix << pixshift;\n\t\t}\n\t}\n\n\tkfree(buf);\n\n\treturn len;\n}\n\nstatic size_t gud_xrgb8888_to_color(u8 *dst, const struct drm_format_info *format,\n\t\t\t\t    void *src, struct drm_framebuffer *fb,\n\t\t\t\t    struct drm_rect *rect)\n{\n\tunsigned int block_width = drm_format_info_block_width(format, 0);\n\tunsigned int bits_per_pixel = 8 / block_width;\n\tu8 r, g, b, pix, *block = dst;  \n\tunsigned int x, y, width;\n\t__le32 *sbuf32;\n\tu32 pix32;\n\tsize_t len;\n\n\t \n\trect->x1 = ALIGN_DOWN(rect->x1, block_width);\n\twidth = drm_rect_width(rect);\n\tlen = drm_format_info_min_pitch(format, 0, width) * drm_rect_height(rect);\n\n\tfor (y = rect->y1; y < rect->y2; y++) {\n\t\tsbuf32 = src + (y * fb->pitches[0]);\n\t\tsbuf32 += rect->x1;\n\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tunsigned int pixpos = x % block_width;  \n\t\t\tunsigned int pixshift = (block_width - pixpos - 1) * bits_per_pixel;\n\n\t\t\tif (!pixpos) {\n\t\t\t\tblock = dst++;\n\t\t\t\t*block = 0;\n\t\t\t}\n\n\t\t\tpix32 = le32_to_cpu(*sbuf32++);\n\t\t\tr = pix32 >> 16;\n\t\t\tg = pix32 >> 8;\n\t\t\tb = pix32;\n\n\t\t\tswitch (format->format) {\n\t\t\tcase GUD_DRM_FORMAT_XRGB1111:\n\t\t\t\tpix = ((r >> 7) << 2) | ((g >> 7) << 1) | (b >> 7);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn len;\n\t\t\t}\n\n\t\t\t*block |= pix << pixshift;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic int gud_prep_flush(struct gud_device *gdrm, struct drm_framebuffer *fb,\n\t\t\t  const struct iosys_map *src, bool cached_reads,\n\t\t\t  const struct drm_format_info *format, struct drm_rect *rect,\n\t\t\t  struct gud_set_buffer_req *req)\n{\n\tu8 compression = gdrm->compression;\n\tstruct iosys_map dst;\n\tvoid *vaddr, *buf;\n\tsize_t pitch, len;\n\n\tpitch = drm_format_info_min_pitch(format, 0, drm_rect_width(rect));\n\tlen = pitch * drm_rect_height(rect);\n\tif (len > gdrm->bulk_len)\n\t\treturn -E2BIG;\n\n\tvaddr = src[0].vaddr;\nretry:\n\tif (compression)\n\t\tbuf = gdrm->compress_buf;\n\telse\n\t\tbuf = gdrm->bulk_buf;\n\tiosys_map_set_vaddr(&dst, buf);\n\n\t \n\tif (format != fb->format) {\n\t\tif (format->format == GUD_DRM_FORMAT_R1) {\n\t\t\tlen = gud_xrgb8888_to_r124(buf, format, vaddr, fb, rect);\n\t\t\tif (!len)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (format->format == DRM_FORMAT_R8) {\n\t\t\tdrm_fb_xrgb8888_to_gray8(&dst, NULL, src, fb, rect);\n\t\t} else if (format->format == DRM_FORMAT_RGB332) {\n\t\t\tdrm_fb_xrgb8888_to_rgb332(&dst, NULL, src, fb, rect);\n\t\t} else if (format->format == DRM_FORMAT_RGB565) {\n\t\t\tdrm_fb_xrgb8888_to_rgb565(&dst, NULL, src, fb, rect,\n\t\t\t\t\t\t  gud_is_big_endian());\n\t\t} else if (format->format == DRM_FORMAT_RGB888) {\n\t\t\tdrm_fb_xrgb8888_to_rgb888(&dst, NULL, src, fb, rect);\n\t\t} else {\n\t\t\tlen = gud_xrgb8888_to_color(buf, format, vaddr, fb, rect);\n\t\t}\n\t} else if (gud_is_big_endian() && format->cpp[0] > 1) {\n\t\tdrm_fb_swab(&dst, NULL, src, fb, rect, cached_reads);\n\t} else if (compression && cached_reads && pitch == fb->pitches[0]) {\n\t\t \n\t\tbuf = vaddr + rect->y1 * pitch;\n\t} else {\n\t\tdrm_fb_memcpy(&dst, NULL, src, fb, rect);\n\t}\n\n\tmemset(req, 0, sizeof(*req));\n\treq->x = cpu_to_le32(rect->x1);\n\treq->y = cpu_to_le32(rect->y1);\n\treq->width = cpu_to_le32(drm_rect_width(rect));\n\treq->height = cpu_to_le32(drm_rect_height(rect));\n\treq->length = cpu_to_le32(len);\n\n\tif (compression & GUD_COMPRESSION_LZ4) {\n\t\tint complen;\n\n\t\tcomplen = LZ4_compress_default(buf, gdrm->bulk_buf, len, len, gdrm->lz4_comp_mem);\n\t\tif (complen <= 0) {\n\t\t\tcompression = 0;\n\t\t\tgoto retry;\n\t\t}\n\n\t\treq->compression = GUD_COMPRESSION_LZ4;\n\t\treq->compressed_length = cpu_to_le32(complen);\n\t}\n\n\treturn 0;\n}\n\nstruct gud_usb_bulk_context {\n\tstruct timer_list timer;\n\tstruct usb_sg_request sgr;\n};\n\nstatic void gud_usb_bulk_timeout(struct timer_list *t)\n{\n\tstruct gud_usb_bulk_context *ctx = from_timer(ctx, t, timer);\n\n\tusb_sg_cancel(&ctx->sgr);\n}\n\nstatic int gud_usb_bulk(struct gud_device *gdrm, size_t len)\n{\n\tstruct gud_usb_bulk_context ctx;\n\tint ret;\n\n\tret = usb_sg_init(&ctx.sgr, gud_to_usb_device(gdrm), gdrm->bulk_pipe, 0,\n\t\t\t  gdrm->bulk_sgt.sgl, gdrm->bulk_sgt.nents, len, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\ttimer_setup_on_stack(&ctx.timer, gud_usb_bulk_timeout, 0);\n\tmod_timer(&ctx.timer, jiffies + msecs_to_jiffies(3000));\n\n\tusb_sg_wait(&ctx.sgr);\n\n\tif (!del_timer_sync(&ctx.timer))\n\t\tret = -ETIMEDOUT;\n\telse if (ctx.sgr.status < 0)\n\t\tret = ctx.sgr.status;\n\telse if (ctx.sgr.bytes != len)\n\t\tret = -EIO;\n\n\tdestroy_timer_on_stack(&ctx.timer);\n\n\treturn ret;\n}\n\nstatic int gud_flush_rect(struct gud_device *gdrm, struct drm_framebuffer *fb,\n\t\t\t  const struct iosys_map *src, bool cached_reads,\n\t\t\t  const struct drm_format_info *format, struct drm_rect *rect)\n{\n\tstruct gud_set_buffer_req req;\n\tsize_t len, trlen;\n\tint ret;\n\n\tdrm_dbg(&gdrm->drm, \"Flushing [FB:%d] \" DRM_RECT_FMT \"\\n\", fb->base.id, DRM_RECT_ARG(rect));\n\n\tret = gud_prep_flush(gdrm, fb, src, cached_reads, format, rect, &req);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = le32_to_cpu(req.length);\n\n\tif (req.compression)\n\t\ttrlen = le32_to_cpu(req.compressed_length);\n\telse\n\t\ttrlen = len;\n\n\tgdrm->stats_length += len;\n\t \n\tif (gdrm->stats_length <= len && gdrm->stats_actual_length) {\n\t\tgdrm->stats_length = len;\n\t\tgdrm->stats_actual_length = 0;\n\t}\n\tgdrm->stats_actual_length += trlen;\n\n\tif (!(gdrm->flags & GUD_DISPLAY_FLAG_FULL_UPDATE) || gdrm->prev_flush_failed) {\n\t\tret = gud_usb_set(gdrm, GUD_REQ_SET_BUFFER, 0, &req, sizeof(req));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = gud_usb_bulk(gdrm, trlen);\n\tif (ret)\n\t\tgdrm->stats_num_errors++;\n\n\treturn ret;\n}\n\nvoid gud_clear_damage(struct gud_device *gdrm)\n{\n\tgdrm->damage.x1 = INT_MAX;\n\tgdrm->damage.y1 = INT_MAX;\n\tgdrm->damage.x2 = 0;\n\tgdrm->damage.y2 = 0;\n}\n\nstatic void gud_flush_damage(struct gud_device *gdrm, struct drm_framebuffer *fb,\n\t\t\t     const struct iosys_map *src, bool cached_reads,\n\t\t\t     struct drm_rect *damage)\n{\n\tconst struct drm_format_info *format;\n\tunsigned int i, lines;\n\tsize_t pitch;\n\tint ret;\n\n\tformat = fb->format;\n\tif (format->format == DRM_FORMAT_XRGB8888 && gdrm->xrgb8888_emulation_format)\n\t\tformat = gdrm->xrgb8888_emulation_format;\n\n\t \n\tpitch = drm_format_info_min_pitch(format, 0, drm_rect_width(damage));\n\tlines = drm_rect_height(damage);\n\n\tif (gdrm->bulk_len < lines * pitch)\n\t\tlines = gdrm->bulk_len / pitch;\n\n\tfor (i = 0; i < DIV_ROUND_UP(drm_rect_height(damage), lines); i++) {\n\t\tstruct drm_rect rect = *damage;\n\n\t\trect.y1 += i * lines;\n\t\trect.y2 = min_t(u32, rect.y1 + lines, damage->y2);\n\n\t\tret = gud_flush_rect(gdrm, fb, src, cached_reads, format, &rect);\n\t\tif (ret) {\n\t\t\tif (ret != -ENODEV && ret != -ECONNRESET &&\n\t\t\t    ret != -ESHUTDOWN && ret != -EPROTO)\n\t\t\t\tdev_err_ratelimited(fb->dev->dev,\n\t\t\t\t\t\t    \"Failed to flush framebuffer: error=%d\\n\", ret);\n\t\t\tgdrm->prev_flush_failed = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid gud_flush_work(struct work_struct *work)\n{\n\tstruct gud_device *gdrm = container_of(work, struct gud_device, work);\n\tstruct iosys_map shadow_map;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_rect damage;\n\tint idx;\n\n\tif (!drm_dev_enter(&gdrm->drm, &idx))\n\t\treturn;\n\n\tmutex_lock(&gdrm->damage_lock);\n\tfb = gdrm->fb;\n\tgdrm->fb = NULL;\n\tiosys_map_set_vaddr(&shadow_map, gdrm->shadow_buf);\n\tdamage = gdrm->damage;\n\tgud_clear_damage(gdrm);\n\tmutex_unlock(&gdrm->damage_lock);\n\n\tif (!fb)\n\t\tgoto out;\n\n\tgud_flush_damage(gdrm, fb, &shadow_map, true, &damage);\n\n\tdrm_framebuffer_put(fb);\nout:\n\tdrm_dev_exit(idx);\n}\n\nstatic int gud_fb_queue_damage(struct gud_device *gdrm, struct drm_framebuffer *fb,\n\t\t\t       const struct iosys_map *src, struct drm_rect *damage)\n{\n\tstruct drm_framebuffer *old_fb = NULL;\n\tstruct iosys_map shadow_map;\n\n\tmutex_lock(&gdrm->damage_lock);\n\n\tif (!gdrm->shadow_buf) {\n\t\tgdrm->shadow_buf = vcalloc(fb->pitches[0], fb->height);\n\t\tif (!gdrm->shadow_buf) {\n\t\t\tmutex_unlock(&gdrm->damage_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tiosys_map_set_vaddr(&shadow_map, gdrm->shadow_buf);\n\tiosys_map_incr(&shadow_map, drm_fb_clip_offset(fb->pitches[0], fb->format, damage));\n\tdrm_fb_memcpy(&shadow_map, fb->pitches, src, fb, damage);\n\n\tif (fb != gdrm->fb) {\n\t\told_fb = gdrm->fb;\n\t\tdrm_framebuffer_get(fb);\n\t\tgdrm->fb = fb;\n\t}\n\n\tgdrm->damage.x1 = min(gdrm->damage.x1, damage->x1);\n\tgdrm->damage.y1 = min(gdrm->damage.y1, damage->y1);\n\tgdrm->damage.x2 = max(gdrm->damage.x2, damage->x2);\n\tgdrm->damage.y2 = max(gdrm->damage.y2, damage->y2);\n\n\tmutex_unlock(&gdrm->damage_lock);\n\n\tqueue_work(system_long_wq, &gdrm->work);\n\n\tif (old_fb)\n\t\tdrm_framebuffer_put(old_fb);\n\n\treturn 0;\n}\n\nstatic void gud_fb_handle_damage(struct gud_device *gdrm, struct drm_framebuffer *fb,\n\t\t\t\t const struct iosys_map *src, struct drm_rect *damage)\n{\n\tint ret;\n\n\tif (gdrm->flags & GUD_DISPLAY_FLAG_FULL_UPDATE)\n\t\tdrm_rect_init(damage, 0, 0, fb->width, fb->height);\n\n\tif (gud_async_flush) {\n\t\tret = gud_fb_queue_damage(gdrm, fb, src, damage);\n\t\tif (ret != -ENOMEM)\n\t\t\treturn;\n\t}\n\n\t \n\tgud_flush_damage(gdrm, fb, src, !fb->obj[0]->import_attach, damage);\n}\n\nint gud_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t   struct drm_plane_state *new_plane_state,\n\t\t   struct drm_crtc_state *new_crtc_state)\n{\n\tstruct gud_device *gdrm = to_gud_device(pipe->crtc.dev);\n\tstruct drm_plane_state *old_plane_state = pipe->plane.state;\n\tconst struct drm_display_mode *mode = &new_crtc_state->mode;\n\tstruct drm_atomic_state *state = new_plane_state->state;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tstruct drm_connector_state *connector_state = NULL;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_connector *connector;\n\tunsigned int i, num_properties;\n\tstruct gud_state_req *req;\n\tint idx, ret;\n\tsize_t len;\n\n\tif (WARN_ON_ONCE(!fb))\n\t\treturn -EINVAL;\n\n\tif (old_plane_state->rotation != new_plane_state->rotation)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (old_fb && old_fb->format != format)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (!new_crtc_state->mode_changed && !new_crtc_state->connectors_changed)\n\t\treturn 0;\n\n\t \n\tif (hweight32(new_crtc_state->connector_mask) != 1)\n\t\treturn -EINVAL;\n\n\tif (format->format == DRM_FORMAT_XRGB8888 && gdrm->xrgb8888_emulation_format)\n\t\tformat = gdrm->xrgb8888_emulation_format;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!connector_state) {\n\t\tstruct drm_connector_list_iter conn_iter;\n\n\t\tdrm_connector_list_iter_begin(pipe->crtc.dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (connector->state->crtc) {\n\t\t\t\tconnector_state = connector->state;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\tif (WARN_ON_ONCE(!connector_state))\n\t\treturn -ENOENT;\n\n\tlen = struct_size(req, properties,\n\t\t\t  GUD_PROPERTIES_MAX_NUM + GUD_CONNECTOR_PROPERTIES_MAX_NUM);\n\treq = kzalloc(len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tgud_from_display_mode(&req->mode, mode);\n\n\treq->format = gud_from_fourcc(format->format);\n\tif (WARN_ON_ONCE(!req->format)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq->connector = drm_connector_index(connector_state->connector);\n\n\tret = gud_connector_fill_properties(connector_state, req->properties);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnum_properties = ret;\n\tfor (i = 0; i < gdrm->num_properties; i++) {\n\t\tu16 prop = gdrm->properties[i];\n\t\tu64 val;\n\n\t\tswitch (prop) {\n\t\tcase GUD_PROPERTY_ROTATION:\n\t\t\t \n\t\t\tval = new_plane_state->rotation;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->properties[num_properties + i].prop = cpu_to_le16(prop);\n\t\treq->properties[num_properties + i].val = cpu_to_le64(val);\n\t\tnum_properties++;\n\t}\n\n\tif (drm_dev_enter(fb->dev, &idx)) {\n\t\tlen = struct_size(req, properties, num_properties);\n\t\tret = gud_usb_set(gdrm, GUD_REQ_SET_STATE_CHECK, 0, req, len);\n\t\tdrm_dev_exit(idx);\n\t}  else {\n\t\tret = -ENODEV;\n\t}\nout:\n\tkfree(req);\n\n\treturn ret;\n}\n\nvoid gud_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t     struct drm_plane_state *old_state)\n{\n\tstruct drm_device *drm = pipe->crtc.dev;\n\tstruct gud_device *gdrm = to_gud_device(drm);\n\tstruct drm_plane_state *state = pipe->plane.state;\n\tstruct drm_shadow_plane_state *shadow_plane_state = to_drm_shadow_plane_state(state);\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_rect damage;\n\tint ret, idx;\n\n\tif (crtc->state->mode_changed || !crtc->state->enable) {\n\t\tcancel_work_sync(&gdrm->work);\n\t\tmutex_lock(&gdrm->damage_lock);\n\t\tif (gdrm->fb) {\n\t\t\tdrm_framebuffer_put(gdrm->fb);\n\t\t\tgdrm->fb = NULL;\n\t\t}\n\t\tgud_clear_damage(gdrm);\n\t\tvfree(gdrm->shadow_buf);\n\t\tgdrm->shadow_buf = NULL;\n\t\tmutex_unlock(&gdrm->damage_lock);\n\t}\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tif (!old_state->fb)\n\t\tgud_usb_set_u8(gdrm, GUD_REQ_SET_CONTROLLER_ENABLE, 1);\n\n\tif (fb && (crtc->state->mode_changed || crtc->state->connectors_changed))\n\t\tgud_usb_set(gdrm, GUD_REQ_SET_STATE_COMMIT, 0, NULL, 0);\n\n\tif (crtc->state->active_changed)\n\t\tgud_usb_set_u8(gdrm, GUD_REQ_SET_DISPLAY_ENABLE, crtc->state->active);\n\n\tif (!fb)\n\t\tgoto ctrl_disable;\n\n\tret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);\n\tif (ret)\n\t\tgoto ctrl_disable;\n\n\tif (drm_atomic_helper_damage_merged(old_state, state, &damage))\n\t\tgud_fb_handle_damage(gdrm, fb, &shadow_plane_state->data[0], &damage);\n\n\tdrm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);\n\nctrl_disable:\n\tif (!crtc->state->enable)\n\t\tgud_usb_set_u8(gdrm, GUD_REQ_SET_CONTROLLER_ENABLE, 0);\n\n\tdrm_dev_exit(idx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}