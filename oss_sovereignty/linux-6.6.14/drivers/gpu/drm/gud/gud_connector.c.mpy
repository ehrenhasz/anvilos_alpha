{
  "module_name": "gud_connector.c",
  "hash_id": "3c2caf29d01a5584c8464d3e4671b043ac055db9717ccb9853b91d80be52ab14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gud/gud_connector.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_file.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/gud.h>\n\n#include \"gud_internal.h\"\n\nstruct gud_connector {\n\tstruct drm_connector connector;\n\tstruct drm_encoder encoder;\n\tstruct backlight_device *backlight;\n\tstruct work_struct backlight_work;\n\n\t \n\tu16 *properties;\n\tunsigned int num_properties;\n\n\t \n\tstruct drm_tv_connector_state initial_tv_state;\n\n\t \n\tint initial_brightness;\n};\n\nstatic inline struct gud_connector *to_gud_connector(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct gud_connector, connector);\n}\n\nstatic void gud_conn_err(struct drm_connector *connector, const char *msg, int ret)\n{\n\tdev_err(connector->dev->dev, \"%s: %s (ret=%d)\\n\", connector->name, msg, ret);\n}\n\n \nstatic void gud_connector_backlight_update_status_work(struct work_struct *work)\n{\n\tstruct gud_connector *gconn = container_of(work, struct gud_connector, backlight_work);\n\tstruct drm_connector *connector = &gconn->connector;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_device *drm = connector->dev;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_atomic_state *state;\n\tint idx, ret;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tstate = drm_atomic_state_alloc(drm);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\tstate->acquire_ctx = &ctx;\nretry:\n\tconnector_state = drm_atomic_get_connector_state(state, connector);\n\tif (IS_ERR(connector_state)) {\n\t\tret = PTR_ERR(connector_state);\n\t\tgoto out;\n\t}\n\n\t \n\tconnector_state->tv.brightness = gconn->backlight->props.brightness;\n\n\tret = drm_atomic_commit(state);\nout:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\nexit:\n\tdrm_dev_exit(idx);\n\n\tif (ret)\n\t\tdev_err(drm->dev, \"Failed to update backlight, err=%d\\n\", ret);\n}\n\nstatic int gud_connector_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct drm_connector *connector = bl_get_data(bd);\n\tstruct gud_connector *gconn = to_gud_connector(connector);\n\n\t \n\tqueue_work(system_long_wq, &gconn->backlight_work);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops gud_connector_backlight_ops = {\n\t.update_status\t= gud_connector_backlight_update_status,\n};\n\nstatic int gud_connector_backlight_register(struct gud_connector *gconn)\n{\n\tstruct drm_connector *connector = &gconn->connector;\n\tstruct backlight_device *bd;\n\tconst char *name;\n\tconst struct backlight_properties props = {\n\t\t.type = BACKLIGHT_RAW,\n\t\t.scale = BACKLIGHT_SCALE_NON_LINEAR,\n\t\t.max_brightness = 100,\n\t\t.brightness = gconn->initial_brightness,\n\t};\n\n\tname = kasprintf(GFP_KERNEL, \"card%d-%s-backlight\",\n\t\t\t connector->dev->primary->index, connector->name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tbd = backlight_device_register(name, connector->kdev, connector,\n\t\t\t\t       &gud_connector_backlight_ops, &props);\n\tkfree(name);\n\tif (IS_ERR(bd))\n\t\treturn PTR_ERR(bd);\n\n\tgconn->backlight = bd;\n\n\treturn 0;\n}\n\nstatic int gud_connector_detect(struct drm_connector *connector,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx, bool force)\n{\n\tstruct gud_device *gdrm = to_gud_device(connector->dev);\n\tint idx, ret;\n\tu8 status;\n\n\tif (!drm_dev_enter(connector->dev, &idx))\n\t\treturn connector_status_disconnected;\n\n\tif (force) {\n\t\tret = gud_usb_set(gdrm, GUD_REQ_SET_CONNECTOR_FORCE_DETECT,\n\t\t\t\t  connector->index, NULL, 0);\n\t\tif (ret) {\n\t\t\tret = connector_status_unknown;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = gud_usb_get_u8(gdrm, GUD_REQ_GET_CONNECTOR_STATUS, connector->index, &status);\n\tif (ret) {\n\t\tret = connector_status_unknown;\n\t\tgoto exit;\n\t}\n\n\tswitch (status & GUD_CONNECTOR_STATUS_CONNECTED_MASK) {\n\tcase GUD_CONNECTOR_STATUS_DISCONNECTED:\n\t\tret = connector_status_disconnected;\n\t\tbreak;\n\tcase GUD_CONNECTOR_STATUS_CONNECTED:\n\t\tret = connector_status_connected;\n\t\tbreak;\n\tdefault:\n\t\tret = connector_status_unknown;\n\t\tbreak;\n\t}\n\n\tif (status & GUD_CONNECTOR_STATUS_CHANGED)\n\t\tconnector->epoch_counter += 1;\nexit:\n\tdrm_dev_exit(idx);\n\n\treturn ret;\n}\n\nstruct gud_connector_get_edid_ctx {\n\tvoid *buf;\n\tsize_t len;\n\tbool edid_override;\n};\n\nstatic int gud_connector_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct gud_connector_get_edid_ctx *ctx = data;\n\tsize_t start = block * EDID_LENGTH;\n\n\tctx->edid_override = false;\n\n\tif (start + len > ctx->len)\n\t\treturn -1;\n\n\tmemcpy(buf, ctx->buf + start, len);\n\n\treturn 0;\n}\n\nstatic int gud_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct gud_device *gdrm = to_gud_device(connector->dev);\n\tstruct gud_display_mode_req *reqmodes = NULL;\n\tstruct gud_connector_get_edid_ctx edid_ctx;\n\tunsigned int i, num_modes = 0;\n\tstruct edid *edid = NULL;\n\tint idx, ret;\n\n\tif (!drm_dev_enter(connector->dev, &idx))\n\t\treturn 0;\n\n\tedid_ctx.edid_override = true;\n\tedid_ctx.buf = kmalloc(GUD_CONNECTOR_MAX_EDID_LEN, GFP_KERNEL);\n\tif (!edid_ctx.buf)\n\t\tgoto out;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_CONNECTOR_EDID, connector->index,\n\t\t\t  edid_ctx.buf, GUD_CONNECTOR_MAX_EDID_LEN);\n\tif (ret > 0 && ret % EDID_LENGTH) {\n\t\tgud_conn_err(connector, \"Invalid EDID size\", ret);\n\t} else if (ret > 0) {\n\t\tedid_ctx.len = ret;\n\t\tedid = drm_do_get_edid(connector, gud_connector_get_edid_block, &edid_ctx);\n\t}\n\n\tkfree(edid_ctx.buf);\n\tdrm_connector_update_edid_property(connector, edid);\n\n\tif (edid && edid_ctx.edid_override)\n\t\tgoto out;\n\n\treqmodes = kmalloc_array(GUD_CONNECTOR_MAX_NUM_MODES, sizeof(*reqmodes), GFP_KERNEL);\n\tif (!reqmodes)\n\t\tgoto out;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_CONNECTOR_MODES, connector->index,\n\t\t\t  reqmodes, GUD_CONNECTOR_MAX_NUM_MODES * sizeof(*reqmodes));\n\tif (ret <= 0)\n\t\tgoto out;\n\tif (ret % sizeof(*reqmodes)) {\n\t\tgud_conn_err(connector, \"Invalid display mode array size\", ret);\n\t\tgoto out;\n\t}\n\n\tnum_modes = ret / sizeof(*reqmodes);\n\n\tfor (i = 0; i < num_modes; i++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_create(connector->dev);\n\t\tif (!mode) {\n\t\t\tnum_modes = i;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgud_to_display_mode(mode, &reqmodes[i]);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\nout:\n\tif (!num_modes)\n\t\tnum_modes = drm_add_edid_modes(connector, edid);\n\n\tkfree(reqmodes);\n\tkfree(edid);\n\tdrm_dev_exit(idx);\n\n\treturn num_modes;\n}\n\nstatic int gud_connector_atomic_check(struct drm_connector *connector,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *new_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector_state *old_state;\n\n\tnew_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!new_state->crtc)\n\t\treturn 0;\n\n\told_state = drm_atomic_get_old_connector_state(state, connector);\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_state->crtc);\n\n\tif (old_state->tv.margins.left != new_state->tv.margins.left ||\n\t    old_state->tv.margins.right != new_state->tv.margins.right ||\n\t    old_state->tv.margins.top != new_state->tv.margins.top ||\n\t    old_state->tv.margins.bottom != new_state->tv.margins.bottom ||\n\t    old_state->tv.legacy_mode != new_state->tv.legacy_mode ||\n\t    old_state->tv.brightness != new_state->tv.brightness ||\n\t    old_state->tv.contrast != new_state->tv.contrast ||\n\t    old_state->tv.flicker_reduction != new_state->tv.flicker_reduction ||\n\t    old_state->tv.overscan != new_state->tv.overscan ||\n\t    old_state->tv.saturation != new_state->tv.saturation ||\n\t    old_state->tv.hue != new_state->tv.hue)\n\t\tnew_crtc_state->connectors_changed = true;\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs gud_connector_helper_funcs = {\n\t.detect_ctx = gud_connector_detect,\n\t.get_modes = gud_connector_get_modes,\n\t.atomic_check = gud_connector_atomic_check,\n};\n\nstatic int gud_connector_late_register(struct drm_connector *connector)\n{\n\tstruct gud_connector *gconn = to_gud_connector(connector);\n\n\tif (gconn->initial_brightness < 0)\n\t\treturn 0;\n\n\treturn gud_connector_backlight_register(gconn);\n}\n\nstatic void gud_connector_early_unregister(struct drm_connector *connector)\n{\n\tstruct gud_connector *gconn = to_gud_connector(connector);\n\n\tbacklight_device_unregister(gconn->backlight);\n\tcancel_work_sync(&gconn->backlight_work);\n}\n\nstatic void gud_connector_destroy(struct drm_connector *connector)\n{\n\tstruct gud_connector *gconn = to_gud_connector(connector);\n\n\tdrm_connector_cleanup(connector);\n\tkfree(gconn->properties);\n\tkfree(gconn);\n}\n\nstatic void gud_connector_reset(struct drm_connector *connector)\n{\n\tstruct gud_connector *gconn = to_gud_connector(connector);\n\n\tdrm_atomic_helper_connector_reset(connector);\n\tconnector->state->tv = gconn->initial_tv_state;\n\t \n\tdrm_atomic_helper_connector_tv_margins_reset(connector);\n\tif (gconn->initial_brightness >= 0)\n\t\tconnector->state->tv.brightness = gconn->initial_brightness;\n}\n\nstatic const struct drm_connector_funcs gud_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.late_register = gud_connector_late_register,\n\t.early_unregister = gud_connector_early_unregister,\n\t.destroy = gud_connector_destroy,\n\t.reset = gud_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\n \nstatic int gud_connector_add_tv_mode(struct gud_device *gdrm, struct drm_connector *connector)\n{\n\tsize_t buf_len = GUD_CONNECTOR_TV_MODE_MAX_NUM * GUD_CONNECTOR_TV_MODE_NAME_LEN;\n\tconst char *modes[GUD_CONNECTOR_TV_MODE_MAX_NUM];\n\tunsigned int i, num_modes;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_CONNECTOR_TV_MODE_VALUES,\n\t\t\t  connector->index, buf, buf_len);\n\tif (ret < 0)\n\t\tgoto free;\n\tif (!ret || ret % GUD_CONNECTOR_TV_MODE_NAME_LEN) {\n\t\tret = -EIO;\n\t\tgoto free;\n\t}\n\n\tnum_modes = ret / GUD_CONNECTOR_TV_MODE_NAME_LEN;\n\tfor (i = 0; i < num_modes; i++)\n\t\tmodes[i] = &buf[i * GUD_CONNECTOR_TV_MODE_NAME_LEN];\n\n\tret = drm_mode_create_tv_properties_legacy(connector->dev, num_modes, modes);\nfree:\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgud_conn_err(connector, \"Failed to add TV modes\", ret);\n\n\treturn ret;\n}\n\nstatic struct drm_property *\ngud_connector_property_lookup(struct drm_connector *connector, u16 prop)\n{\n\tstruct drm_mode_config *config = &connector->dev->mode_config;\n\n\tswitch (prop) {\n\tcase GUD_PROPERTY_TV_LEFT_MARGIN:\n\t\treturn config->tv_left_margin_property;\n\tcase GUD_PROPERTY_TV_RIGHT_MARGIN:\n\t\treturn config->tv_right_margin_property;\n\tcase GUD_PROPERTY_TV_TOP_MARGIN:\n\t\treturn config->tv_top_margin_property;\n\tcase GUD_PROPERTY_TV_BOTTOM_MARGIN:\n\t\treturn config->tv_bottom_margin_property;\n\tcase GUD_PROPERTY_TV_MODE:\n\t\treturn config->legacy_tv_mode_property;\n\tcase GUD_PROPERTY_TV_BRIGHTNESS:\n\t\treturn config->tv_brightness_property;\n\tcase GUD_PROPERTY_TV_CONTRAST:\n\t\treturn config->tv_contrast_property;\n\tcase GUD_PROPERTY_TV_FLICKER_REDUCTION:\n\t\treturn config->tv_flicker_reduction_property;\n\tcase GUD_PROPERTY_TV_OVERSCAN:\n\t\treturn config->tv_overscan_property;\n\tcase GUD_PROPERTY_TV_SATURATION:\n\t\treturn config->tv_saturation_property;\n\tcase GUD_PROPERTY_TV_HUE:\n\t\treturn config->tv_hue_property;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic unsigned int *gud_connector_tv_state_val(u16 prop, struct drm_tv_connector_state *state)\n{\n\tswitch (prop) {\n\tcase GUD_PROPERTY_TV_LEFT_MARGIN:\n\t\treturn &state->margins.left;\n\tcase GUD_PROPERTY_TV_RIGHT_MARGIN:\n\t\treturn &state->margins.right;\n\tcase GUD_PROPERTY_TV_TOP_MARGIN:\n\t\treturn &state->margins.top;\n\tcase GUD_PROPERTY_TV_BOTTOM_MARGIN:\n\t\treturn &state->margins.bottom;\n\tcase GUD_PROPERTY_TV_MODE:\n\t\treturn &state->legacy_mode;\n\tcase GUD_PROPERTY_TV_BRIGHTNESS:\n\t\treturn &state->brightness;\n\tcase GUD_PROPERTY_TV_CONTRAST:\n\t\treturn &state->contrast;\n\tcase GUD_PROPERTY_TV_FLICKER_REDUCTION:\n\t\treturn &state->flicker_reduction;\n\tcase GUD_PROPERTY_TV_OVERSCAN:\n\t\treturn &state->overscan;\n\tcase GUD_PROPERTY_TV_SATURATION:\n\t\treturn &state->saturation;\n\tcase GUD_PROPERTY_TV_HUE:\n\t\treturn &state->hue;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int gud_connector_add_properties(struct gud_device *gdrm, struct gud_connector *gconn)\n{\n\tstruct drm_connector *connector = &gconn->connector;\n\tstruct drm_device *drm = &gdrm->drm;\n\tstruct gud_property_req *properties;\n\tunsigned int i, num_properties;\n\tint ret;\n\n\tproperties = kcalloc(GUD_CONNECTOR_PROPERTIES_MAX_NUM, sizeof(*properties), GFP_KERNEL);\n\tif (!properties)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_CONNECTOR_PROPERTIES, connector->index,\n\t\t\t  properties, GUD_CONNECTOR_PROPERTIES_MAX_NUM * sizeof(*properties));\n\tif (ret <= 0)\n\t\tgoto out;\n\tif (ret % sizeof(*properties)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tnum_properties = ret / sizeof(*properties);\n\tret = 0;\n\n\tgconn->properties = kcalloc(num_properties, sizeof(*gconn->properties), GFP_KERNEL);\n\tif (!gconn->properties) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_properties; i++) {\n\t\tu16 prop = le16_to_cpu(properties[i].prop);\n\t\tu64 val = le64_to_cpu(properties[i].val);\n\t\tstruct drm_property *property;\n\t\tunsigned int *state_val;\n\n\t\tdrm_dbg(drm, \"property: %u = %llu(0x%llx)\\n\", prop, val, val);\n\n\t\tswitch (prop) {\n\t\tcase GUD_PROPERTY_TV_LEFT_MARGIN:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_RIGHT_MARGIN:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_TOP_MARGIN:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_BOTTOM_MARGIN:\n\t\t\tret = drm_mode_create_tv_margin_properties(drm);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase GUD_PROPERTY_TV_MODE:\n\t\t\tret = gud_connector_add_tv_mode(gdrm, connector);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase GUD_PROPERTY_TV_BRIGHTNESS:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_CONTRAST:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_FLICKER_REDUCTION:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_OVERSCAN:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_SATURATION:\n\t\t\tfallthrough;\n\t\tcase GUD_PROPERTY_TV_HUE:\n\t\t\t \n\t\t\tret = drm_mode_create_tv_properties_legacy(drm, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase GUD_PROPERTY_BACKLIGHT_BRIGHTNESS:\n\t\t\tif (val > 100) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgconn->initial_brightness = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdrm_dbg(drm, \"Ignoring unknown property: %u\\n\", prop);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgconn->properties[gconn->num_properties++] = prop;\n\n\t\tif (prop == GUD_PROPERTY_BACKLIGHT_BRIGHTNESS)\n\t\t\tcontinue;  \n\n\t\tproperty = gud_connector_property_lookup(connector, prop);\n\t\tif (WARN_ON(IS_ERR(property)))\n\t\t\tcontinue;\n\n\t\tstate_val = gud_connector_tv_state_val(prop, &gconn->initial_tv_state);\n\t\tif (WARN_ON(IS_ERR(state_val)))\n\t\t\tcontinue;\n\n\t\t*state_val = val;\n\t\tdrm_object_attach_property(&connector->base, property, 0);\n\t}\nout:\n\tkfree(properties);\n\n\treturn ret;\n}\n\nint gud_connector_fill_properties(struct drm_connector_state *connector_state,\n\t\t\t\t  struct gud_property_req *properties)\n{\n\tstruct gud_connector *gconn = to_gud_connector(connector_state->connector);\n\tunsigned int i;\n\n\tfor (i = 0; i < gconn->num_properties; i++) {\n\t\tu16 prop = gconn->properties[i];\n\t\tu64 val;\n\n\t\tif (prop == GUD_PROPERTY_BACKLIGHT_BRIGHTNESS) {\n\t\t\tval = connector_state->tv.brightness;\n\t\t} else {\n\t\t\tunsigned int *state_val;\n\n\t\t\tstate_val = gud_connector_tv_state_val(prop, &connector_state->tv);\n\t\t\tif (WARN_ON_ONCE(IS_ERR(state_val)))\n\t\t\t\treturn PTR_ERR(state_val);\n\n\t\t\tval = *state_val;\n\t\t}\n\n\t\tproperties[i].prop = cpu_to_le16(prop);\n\t\tproperties[i].val = cpu_to_le64(val);\n\t}\n\n\treturn gconn->num_properties;\n}\n\nstatic int gud_connector_create(struct gud_device *gdrm, unsigned int index,\n\t\t\t\tstruct gud_connector_descriptor_req *desc)\n{\n\tstruct drm_device *drm = &gdrm->drm;\n\tstruct gud_connector *gconn;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tint ret, connector_type;\n\tu32 flags;\n\n\tgconn = kzalloc(sizeof(*gconn), GFP_KERNEL);\n\tif (!gconn)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&gconn->backlight_work, gud_connector_backlight_update_status_work);\n\tgconn->initial_brightness = -ENODEV;\n\tflags = le32_to_cpu(desc->flags);\n\tconnector = &gconn->connector;\n\n\tdrm_dbg(drm, \"Connector: index=%u type=%u flags=0x%x\\n\", index, desc->connector_type, flags);\n\n\tswitch (desc->connector_type) {\n\tcase GUD_CONNECTOR_TYPE_PANEL:\n\t\tconnector_type = DRM_MODE_CONNECTOR_USB;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_VGA:\n\t\tconnector_type = DRM_MODE_CONNECTOR_VGA;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_DVI:\n\t\tconnector_type = DRM_MODE_CONNECTOR_DVID;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_COMPOSITE:\n\t\tconnector_type = DRM_MODE_CONNECTOR_Composite;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_SVIDEO:\n\t\tconnector_type = DRM_MODE_CONNECTOR_SVIDEO;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_COMPONENT:\n\t\tconnector_type = DRM_MODE_CONNECTOR_Component;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_DISPLAYPORT:\n\t\tconnector_type = DRM_MODE_CONNECTOR_DisplayPort;\n\t\tbreak;\n\tcase GUD_CONNECTOR_TYPE_HDMI:\n\t\tconnector_type = DRM_MODE_CONNECTOR_HDMIA;\n\t\tbreak;\n\tdefault:  \n\t\tconnector_type = DRM_MODE_CONNECTOR_USB;\n\t\tbreak;\n\t}\n\n\tdrm_connector_helper_add(connector, &gud_connector_helper_funcs);\n\tret = drm_connector_init(drm, connector, &gud_connector_funcs, connector_type);\n\tif (ret) {\n\t\tkfree(connector);\n\t\treturn ret;\n\t}\n\n\tif (WARN_ON(connector->index != index))\n\t\treturn -EINVAL;\n\n\tif (flags & GUD_CONNECTOR_FLAGS_POLL_STATUS)\n\t\tconnector->polled = (DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT);\n\tif (flags & GUD_CONNECTOR_FLAGS_INTERLACE)\n\t\tconnector->interlace_allowed = true;\n\tif (flags & GUD_CONNECTOR_FLAGS_DOUBLESCAN)\n\t\tconnector->doublescan_allowed = true;\n\n\tret = gud_connector_add_properties(gdrm, gconn);\n\tif (ret) {\n\t\tgud_conn_err(connector, \"Failed to add properties\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!connector->index) {\n\t\tencoder = &gdrm->pipe.encoder;\n\t} else {\n\t\tencoder = &gconn->encoder;\n\n\t\tret = drm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_NONE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tencoder->possible_crtcs = 1;\n\t}\n\n\treturn drm_connector_attach_encoder(connector, encoder);\n}\n\nint gud_get_connectors(struct gud_device *gdrm)\n{\n\tstruct gud_connector_descriptor_req *descs;\n\tunsigned int i, num_connectors;\n\tint ret;\n\n\tdescs = kmalloc_array(GUD_CONNECTORS_MAX_NUM, sizeof(*descs), GFP_KERNEL);\n\tif (!descs)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_CONNECTORS, 0,\n\t\t\t  descs, GUD_CONNECTORS_MAX_NUM * sizeof(*descs));\n\tif (ret < 0)\n\t\tgoto free;\n\tif (!ret || ret % sizeof(*descs)) {\n\t\tret = -EIO;\n\t\tgoto free;\n\t}\n\n\tnum_connectors = ret / sizeof(*descs);\n\n\tfor (i = 0; i < num_connectors; i++) {\n\t\tret = gud_connector_create(gdrm, i, &descs[i]);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\nfree:\n\tkfree(descs);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}