{
  "module_name": "gud_internal.h",
  "hash_id": "62675311560614d4fcbc951cca28f85bf9613a210738e77b37c12b9ab1fca5c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gud/gud_internal.h",
  "human_readable_source": " \n\n#ifndef __LINUX_GUD_INTERNAL_H\n#define __LINUX_GUD_INTERNAL_H\n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/scatterlist.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <uapi/drm/drm_fourcc.h>\n\n#include <drm/drm_modes.h>\n#include <drm/drm_simple_kms_helper.h>\n\nstruct gud_device {\n\tstruct drm_device drm;\n\tstruct drm_simple_display_pipe pipe;\n\tstruct device *dmadev;\n\tstruct work_struct work;\n\tu32 flags;\n\tconst struct drm_format_info *xrgb8888_emulation_format;\n\n\tu16 *properties;\n\tunsigned int num_properties;\n\n\tunsigned int bulk_pipe;\n\tvoid *bulk_buf;\n\tsize_t bulk_len;\n\tstruct sg_table bulk_sgt;\n\n\tu8 compression;\n\tvoid *lz4_comp_mem;\n\tvoid *compress_buf;\n\n\tu64 stats_length;\n\tu64 stats_actual_length;\n\tunsigned int stats_num_errors;\n\n\tstruct mutex ctrl_lock;  \n\n\tstruct mutex damage_lock;  \n\tstruct drm_framebuffer *fb;\n\tstruct drm_rect damage;\n\tbool prev_flush_failed;\n\tvoid *shadow_buf;\n};\n\nstatic inline struct gud_device *to_gud_device(struct drm_device *drm)\n{\n\treturn container_of(drm, struct gud_device, drm);\n}\n\nstatic inline struct usb_device *gud_to_usb_device(struct gud_device *gdrm)\n{\n\treturn interface_to_usbdev(to_usb_interface(gdrm->drm.dev));\n}\n\nint gud_usb_get(struct gud_device *gdrm, u8 request, u16 index, void *buf, size_t len);\nint gud_usb_set(struct gud_device *gdrm, u8 request, u16 index, void *buf, size_t len);\nint gud_usb_get_u8(struct gud_device *gdrm, u8 request, u16 index, u8 *val);\nint gud_usb_set_u8(struct gud_device *gdrm, u8 request, u8 val);\n\nvoid gud_clear_damage(struct gud_device *gdrm);\nvoid gud_flush_work(struct work_struct *work);\nint gud_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t   struct drm_plane_state *new_plane_state,\n\t\t   struct drm_crtc_state *new_crtc_state);\nvoid gud_pipe_update(struct drm_simple_display_pipe *pipe,\n\t\t     struct drm_plane_state *old_state);\nint gud_connector_fill_properties(struct drm_connector_state *connector_state,\n\t\t\t\t  struct gud_property_req *properties);\nint gud_get_connectors(struct gud_device *gdrm);\n\n \n#define GUD_DRM_FORMAT_R1\t\t0x00000122\n#define GUD_DRM_FORMAT_XRGB1111\t\t0x03121722\n\nstatic inline u8 gud_from_fourcc(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase GUD_DRM_FORMAT_R1:\n\t\treturn GUD_PIXEL_FORMAT_R1;\n\tcase DRM_FORMAT_R8:\n\t\treturn GUD_PIXEL_FORMAT_R8;\n\tcase GUD_DRM_FORMAT_XRGB1111:\n\t\treturn GUD_PIXEL_FORMAT_XRGB1111;\n\tcase DRM_FORMAT_RGB332:\n\t\treturn GUD_PIXEL_FORMAT_RGB332;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn GUD_PIXEL_FORMAT_RGB565;\n\tcase DRM_FORMAT_RGB888:\n\t\treturn GUD_PIXEL_FORMAT_RGB888;\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn GUD_PIXEL_FORMAT_XRGB8888;\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn GUD_PIXEL_FORMAT_ARGB8888;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 gud_to_fourcc(u8 format)\n{\n\tswitch (format) {\n\tcase GUD_PIXEL_FORMAT_R1:\n\t\treturn GUD_DRM_FORMAT_R1;\n\tcase GUD_PIXEL_FORMAT_R8:\n\t\treturn DRM_FORMAT_R8;\n\tcase GUD_PIXEL_FORMAT_XRGB1111:\n\t\treturn GUD_DRM_FORMAT_XRGB1111;\n\tcase GUD_PIXEL_FORMAT_RGB332:\n\t\treturn DRM_FORMAT_RGB332;\n\tcase GUD_PIXEL_FORMAT_RGB565:\n\t\treturn DRM_FORMAT_RGB565;\n\tcase GUD_PIXEL_FORMAT_RGB888:\n\t\treturn DRM_FORMAT_RGB888;\n\tcase GUD_PIXEL_FORMAT_XRGB8888:\n\t\treturn DRM_FORMAT_XRGB8888;\n\tcase GUD_PIXEL_FORMAT_ARGB8888:\n\t\treturn DRM_FORMAT_ARGB8888;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void gud_from_display_mode(struct gud_display_mode_req *dst,\n\t\t\t\t\t const struct drm_display_mode *src)\n{\n\tu32 flags = src->flags & GUD_DISPLAY_MODE_FLAG_USER_MASK;\n\n\tif (src->type & DRM_MODE_TYPE_PREFERRED)\n\t\tflags |= GUD_DISPLAY_MODE_FLAG_PREFERRED;\n\n\tdst->clock = cpu_to_le32(src->clock);\n\tdst->hdisplay = cpu_to_le16(src->hdisplay);\n\tdst->hsync_start = cpu_to_le16(src->hsync_start);\n\tdst->hsync_end = cpu_to_le16(src->hsync_end);\n\tdst->htotal = cpu_to_le16(src->htotal);\n\tdst->vdisplay = cpu_to_le16(src->vdisplay);\n\tdst->vsync_start = cpu_to_le16(src->vsync_start);\n\tdst->vsync_end = cpu_to_le16(src->vsync_end);\n\tdst->vtotal = cpu_to_le16(src->vtotal);\n\tdst->flags = cpu_to_le32(flags);\n}\n\nstatic inline void gud_to_display_mode(struct drm_display_mode *dst,\n\t\t\t\t       const struct gud_display_mode_req *src)\n{\n\tu32 flags = le32_to_cpu(src->flags);\n\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->clock = le32_to_cpu(src->clock);\n\tdst->hdisplay = le16_to_cpu(src->hdisplay);\n\tdst->hsync_start = le16_to_cpu(src->hsync_start);\n\tdst->hsync_end = le16_to_cpu(src->hsync_end);\n\tdst->htotal = le16_to_cpu(src->htotal);\n\tdst->vdisplay = le16_to_cpu(src->vdisplay);\n\tdst->vsync_start = le16_to_cpu(src->vsync_start);\n\tdst->vsync_end = le16_to_cpu(src->vsync_end);\n\tdst->vtotal = le16_to_cpu(src->vtotal);\n\tdst->flags = flags & GUD_DISPLAY_MODE_FLAG_USER_MASK;\n\tdst->type = DRM_MODE_TYPE_DRIVER;\n\tif (flags & GUD_DISPLAY_MODE_FLAG_PREFERRED)\n\t\tdst->type |= DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(dst);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}