{
  "module_name": "gud_drv.c",
  "hash_id": "d55f7299284640f679be83afb47b71c31d6be850737a498eb04318ff9f924136",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/gud/gud_drv.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n#include <linux/dma-mapping.h>\n#include <linux/lz4.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/string_helpers.h>\n#include <linux/usb.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/gud.h>\n\n#include \"gud_internal.h\"\n\n \nstatic const struct drm_format_info gud_drm_format_r1 = {\n\t.format = GUD_DRM_FORMAT_R1,\n\t.num_planes = 1,\n\t.char_per_block = { 1, 0, 0 },\n\t.block_w = { 8, 0, 0 },\n\t.block_h = { 1, 0, 0 },\n\t.hsub = 1,\n\t.vsub = 1,\n};\n\nstatic const struct drm_format_info gud_drm_format_xrgb1111 = {\n\t.format = GUD_DRM_FORMAT_XRGB1111,\n\t.num_planes = 1,\n\t.char_per_block = { 1, 0, 0 },\n\t.block_w = { 2, 0, 0 },\n\t.block_h = { 1, 0, 0 },\n\t.hsub = 1,\n\t.vsub = 1,\n};\n\nstatic int gud_usb_control_msg(struct usb_interface *intf, bool in,\n\t\t\t       u8 request, u16 value, void *buf, size_t len)\n{\n\tu8 requesttype = USB_TYPE_VENDOR | USB_RECIP_INTERFACE;\n\tu8 ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tunsigned int pipe;\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (in) {\n\t\tpipe = usb_rcvctrlpipe(usb, 0);\n\t\trequesttype |= USB_DIR_IN;\n\t} else {\n\t\tpipe = usb_sndctrlpipe(usb, 0);\n\t\trequesttype |= USB_DIR_OUT;\n\t}\n\n\treturn usb_control_msg(usb, pipe, request, requesttype, value,\n\t\t\t       ifnum, buf, len, USB_CTRL_GET_TIMEOUT);\n}\n\nstatic int gud_get_display_descriptor(struct usb_interface *intf,\n\t\t\t\t      struct gud_display_descriptor_req *desc)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_control_msg(intf, true, GUD_REQ_GET_DESCRIPTOR, 0, buf, sizeof(*desc));\n\tmemcpy(desc, buf, sizeof(*desc));\n\tkfree(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(*desc))\n\t\treturn -EIO;\n\n\tif (desc->magic != le32_to_cpu(GUD_DISPLAY_MAGIC))\n\t\treturn -ENODATA;\n\n\tDRM_DEV_DEBUG_DRIVER(&intf->dev,\n\t\t\t     \"version=%u flags=0x%x compression=0x%x max_buffer_size=%u\\n\",\n\t\t\t     desc->version, le32_to_cpu(desc->flags), desc->compression,\n\t\t\t     le32_to_cpu(desc->max_buffer_size));\n\n\tif (!desc->version || !desc->max_width || !desc->max_height ||\n\t    le32_to_cpu(desc->min_width) > le32_to_cpu(desc->max_width) ||\n\t    le32_to_cpu(desc->min_height) > le32_to_cpu(desc->max_height))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int gud_status_to_errno(u8 status)\n{\n\tswitch (status) {\n\tcase GUD_STATUS_OK:\n\t\treturn 0;\n\tcase GUD_STATUS_BUSY:\n\t\treturn -EBUSY;\n\tcase GUD_STATUS_REQUEST_NOT_SUPPORTED:\n\t\treturn -EOPNOTSUPP;\n\tcase GUD_STATUS_PROTOCOL_ERROR:\n\t\treturn -EPROTO;\n\tcase GUD_STATUS_INVALID_PARAMETER:\n\t\treturn -EINVAL;\n\tcase GUD_STATUS_ERROR:\n\t\treturn -EREMOTEIO;\n\tdefault:\n\t\treturn -EREMOTEIO;\n\t}\n}\n\nstatic int gud_usb_get_status(struct usb_interface *intf)\n{\n\tint ret, status = -EIO;\n\tu8 *buf;\n\n\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_control_msg(intf, true, GUD_REQ_GET_STATUS, 0, buf, sizeof(*buf));\n\tif (ret == sizeof(*buf))\n\t\tstatus = gud_status_to_errno(*buf);\n\tkfree(buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn status;\n}\n\nstatic int gud_usb_transfer(struct gud_device *gdrm, bool in, u8 request, u16 index,\n\t\t\t    void *buf, size_t len)\n{\n\tstruct usb_interface *intf = to_usb_interface(gdrm->drm.dev);\n\tint idx, ret;\n\n\tdrm_dbg(&gdrm->drm, \"%s: request=0x%x index=%u len=%zu\\n\",\n\t\tin ? \"get\" : \"set\", request, index, len);\n\n\tif (!drm_dev_enter(&gdrm->drm, &idx))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&gdrm->ctrl_lock);\n\n\tret = gud_usb_control_msg(intf, in, request, index, buf, len);\n\tif (ret == -EPIPE || ((gdrm->flags & GUD_DISPLAY_FLAG_STATUS_ON_SET) && !in && ret >= 0)) {\n\t\tint status;\n\n\t\tstatus = gud_usb_get_status(intf);\n\t\tif (status < 0) {\n\t\t\tret = status;\n\t\t} else if (ret < 0) {\n\t\t\tdev_err_once(gdrm->drm.dev,\n\t\t\t\t     \"Unexpected status OK for failed transfer\\n\");\n\t\t\tret = -EPIPE;\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tdrm_dbg(&gdrm->drm, \"ret=%d\\n\", ret);\n\t\tgdrm->stats_num_errors++;\n\t}\n\n\tmutex_unlock(&gdrm->ctrl_lock);\n\tdrm_dev_exit(idx);\n\n\treturn ret;\n}\n\n \nint gud_usb_get(struct gud_device *gdrm, u8 request, u16 index, void *buf, size_t max_len)\n{\n\treturn gud_usb_transfer(gdrm, true, request, index, buf, max_len);\n}\n\n \nint gud_usb_set(struct gud_device *gdrm, u8 request, u16 index, void *buf, size_t len)\n{\n\tvoid *trbuf = NULL;\n\tint ret;\n\n\tif (buf && len) {\n\t\ttrbuf = kmemdup(buf, len, GFP_KERNEL);\n\t\tif (!trbuf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = gud_usb_transfer(gdrm, false, request, index, trbuf, len);\n\tkfree(trbuf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret != len ? -EIO : 0;\n}\n\n \nint gud_usb_get_u8(struct gud_device *gdrm, u8 request, u16 index, u8 *val)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(sizeof(*val), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, request, index, buf, sizeof(*val));\n\t*val = *buf;\n\tkfree(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret != sizeof(*val) ? -EIO : 0;\n}\n\n \nint gud_usb_set_u8(struct gud_device *gdrm, u8 request, u8 val)\n{\n\treturn gud_usb_set(gdrm, request, 0, &val, sizeof(val));\n}\n\nstatic int gud_get_properties(struct gud_device *gdrm)\n{\n\tstruct gud_property_req *properties;\n\tunsigned int i, num_properties;\n\tint ret;\n\n\tproperties = kcalloc(GUD_PROPERTIES_MAX_NUM, sizeof(*properties), GFP_KERNEL);\n\tif (!properties)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_PROPERTIES, 0,\n\t\t\t  properties, GUD_PROPERTIES_MAX_NUM * sizeof(*properties));\n\tif (ret <= 0)\n\t\tgoto out;\n\tif (ret % sizeof(*properties)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tnum_properties = ret / sizeof(*properties);\n\tret = 0;\n\n\tgdrm->properties = drmm_kcalloc(&gdrm->drm, num_properties, sizeof(*gdrm->properties),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!gdrm->properties) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_properties; i++) {\n\t\tu16 prop = le16_to_cpu(properties[i].prop);\n\t\tu64 val = le64_to_cpu(properties[i].val);\n\n\t\tswitch (prop) {\n\t\tcase GUD_PROPERTY_ROTATION:\n\t\t\t \n\t\t\tval &= GUD_ROTATION_MASK;\n\t\t\tret = drm_plane_create_rotation_property(&gdrm->pipe.plane,\n\t\t\t\t\t\t\t\t DRM_MODE_ROTATE_0, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdrm_dbg(&gdrm->drm, \"Ignoring unknown property: %u\\n\", prop);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tgdrm->properties[gdrm->num_properties++] = prop;\n\t}\nout:\n\tkfree(properties);\n\n\treturn ret;\n}\n\n \nstatic struct drm_gem_object *gud_gem_prime_import(struct drm_device *drm, struct dma_buf *dma_buf)\n{\n\tstruct gud_device *gdrm = to_gud_device(drm);\n\n\tif (!gdrm->dmadev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn drm_gem_prime_import_dev(drm, dma_buf, gdrm->dmadev);\n}\n\nstatic int gud_stats_debugfs(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct gud_device *gdrm = to_gud_device(entry->dev);\n\tchar buf[10];\n\n\tstring_get_size(gdrm->bulk_len, 1, STRING_UNITS_2, buf, sizeof(buf));\n\tseq_printf(m, \"Max buffer size: %s\\n\", buf);\n\tseq_printf(m, \"Number of errors:  %u\\n\", gdrm->stats_num_errors);\n\n\tseq_puts(m, \"Compression:      \");\n\tif (gdrm->compression & GUD_COMPRESSION_LZ4)\n\t\tseq_puts(m, \" lz4\");\n\tif (!gdrm->compression)\n\t\tseq_puts(m, \" none\");\n\tseq_puts(m, \"\\n\");\n\n\tif (gdrm->compression) {\n\t\tu64 remainder;\n\t\tu64 ratio = div64_u64_rem(gdrm->stats_length, gdrm->stats_actual_length,\n\t\t\t\t\t  &remainder);\n\t\tu64 ratio_frac = div64_u64(remainder * 10, gdrm->stats_actual_length);\n\n\t\tseq_printf(m, \"Compression ratio: %llu.%llu\\n\", ratio, ratio_frac);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_simple_display_pipe_funcs gud_pipe_funcs = {\n\t.check      = gud_pipe_check,\n\t.update\t    = gud_pipe_update,\n\tDRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS\n};\n\nstatic const struct drm_mode_config_funcs gud_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create_with_dirty,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const u64 gud_pipe_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nDEFINE_DRM_GEM_FOPS(gud_fops);\n\nstatic const struct drm_driver gud_drm_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.fops\t\t\t= &gud_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\t.gem_prime_import\t= gud_gem_prime_import,\n\n\t.name\t\t\t= \"gud\",\n\t.desc\t\t\t= \"Generic USB Display\",\n\t.date\t\t\t= \"20200422\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 0,\n};\n\nstatic int gud_alloc_bulk_buffer(struct gud_device *gdrm)\n{\n\tunsigned int i, num_pages;\n\tstruct page **pages;\n\tvoid *ptr;\n\tint ret;\n\n\tgdrm->bulk_buf = vmalloc_32(gdrm->bulk_len);\n\tif (!gdrm->bulk_buf)\n\t\treturn -ENOMEM;\n\n\tnum_pages = DIV_ROUND_UP(gdrm->bulk_len, PAGE_SIZE);\n\tpages = kmalloc_array(num_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = gdrm->bulk_buf; i < num_pages; i++, ptr += PAGE_SIZE)\n\t\tpages[i] = vmalloc_to_page(ptr);\n\n\tret = sg_alloc_table_from_pages(&gdrm->bulk_sgt, pages, num_pages,\n\t\t\t\t\t0, gdrm->bulk_len, GFP_KERNEL);\n\tkfree(pages);\n\n\treturn ret;\n}\n\nstatic void gud_free_buffers_and_mutex(void *data)\n{\n\tstruct gud_device *gdrm = data;\n\n\tvfree(gdrm->compress_buf);\n\tgdrm->compress_buf = NULL;\n\tsg_free_table(&gdrm->bulk_sgt);\n\tvfree(gdrm->bulk_buf);\n\tgdrm->bulk_buf = NULL;\n\tmutex_destroy(&gdrm->ctrl_lock);\n}\n\nstatic int gud_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tconst struct drm_format_info *xrgb8888_emulation_format = NULL;\n\tbool rgb565_supported = false, xrgb8888_supported = false;\n\tunsigned int num_formats_dev, num_formats = 0;\n\tstruct usb_endpoint_descriptor *bulk_out;\n\tstruct gud_display_descriptor_req desc;\n\tstruct device *dev = &intf->dev;\n\tsize_t max_buffer_size = 0;\n\tstruct gud_device *gdrm;\n\tstruct drm_device *drm;\n\tu8 *formats_dev;\n\tu32 *formats;\n\tint ret, i;\n\n\tret = usb_find_bulk_out_endpoint(intf->cur_altsetting, &bulk_out);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gud_get_display_descriptor(intf, &desc);\n\tif (ret) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Not a display interface: ret=%d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tif (desc.version > 1) {\n\t\tdev_err(dev, \"Protocol version %u is not supported\\n\", desc.version);\n\t\treturn -ENODEV;\n\t}\n\n\tgdrm = devm_drm_dev_alloc(dev, &gud_drm_driver, struct gud_device, drm);\n\tif (IS_ERR(gdrm))\n\t\treturn PTR_ERR(gdrm);\n\n\tdrm = &gdrm->drm;\n\tdrm->mode_config.funcs = &gud_mode_config_funcs;\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tgdrm->flags = le32_to_cpu(desc.flags);\n\tgdrm->compression = desc.compression & GUD_COMPRESSION_LZ4;\n\n\tif (gdrm->flags & GUD_DISPLAY_FLAG_FULL_UPDATE && gdrm->compression)\n\t\treturn -EINVAL;\n\n\tmutex_init(&gdrm->ctrl_lock);\n\tmutex_init(&gdrm->damage_lock);\n\tINIT_WORK(&gdrm->work, gud_flush_work);\n\tgud_clear_damage(gdrm);\n\n\tret = devm_add_action(dev, gud_free_buffers_and_mutex, gdrm);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm->mode_config.min_width = le32_to_cpu(desc.min_width);\n\tdrm->mode_config.max_width = le32_to_cpu(desc.max_width);\n\tdrm->mode_config.min_height = le32_to_cpu(desc.min_height);\n\tdrm->mode_config.max_height = le32_to_cpu(desc.max_height);\n\n\tformats_dev = devm_kmalloc(dev, GUD_FORMATS_MAX_NUM, GFP_KERNEL);\n\t \n\tformats = devm_kmalloc_array(dev, GUD_FORMATS_MAX_NUM + 1, sizeof(*formats), GFP_KERNEL);\n\tif (!formats_dev || !formats)\n\t\treturn -ENOMEM;\n\n\tret = gud_usb_get(gdrm, GUD_REQ_GET_FORMATS, 0, formats_dev, GUD_FORMATS_MAX_NUM);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_formats_dev = ret;\n\tfor (i = 0; i < num_formats_dev; i++) {\n\t\tconst struct drm_format_info *info;\n\t\tsize_t fmt_buf_size;\n\t\tu32 format;\n\n\t\tformat = gud_to_fourcc(formats_dev[i]);\n\t\tif (!format) {\n\t\t\tdrm_dbg(drm, \"Unsupported format: 0x%02x\\n\", formats_dev[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (format == GUD_DRM_FORMAT_R1)\n\t\t\tinfo = &gud_drm_format_r1;\n\t\telse if (format == GUD_DRM_FORMAT_XRGB1111)\n\t\t\tinfo = &gud_drm_format_xrgb1111;\n\t\telse\n\t\t\tinfo = drm_format_info(format);\n\n\t\tswitch (format) {\n\t\tcase GUD_DRM_FORMAT_R1:\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_R8:\n\t\t\tfallthrough;\n\t\tcase GUD_DRM_FORMAT_XRGB1111:\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_RGB332:\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tif (!xrgb8888_emulation_format)\n\t\t\t\txrgb8888_emulation_format = info;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\trgb565_supported = true;\n\t\t\tif (!xrgb8888_emulation_format)\n\t\t\t\txrgb8888_emulation_format = info;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\txrgb8888_supported = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfmt_buf_size = drm_format_info_min_pitch(info, 0, drm->mode_config.max_width) *\n\t\t\t       drm->mode_config.max_height;\n\t\tmax_buffer_size = max(max_buffer_size, fmt_buf_size);\n\n\t\tif (format == GUD_DRM_FORMAT_R1 || format == GUD_DRM_FORMAT_XRGB1111)\n\t\t\tcontinue;  \n\n\t\tformats[num_formats++] = format;\n\t}\n\n\tif (!num_formats && !xrgb8888_emulation_format) {\n\t\tdev_err(dev, \"No supported pixel formats found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rgb565_supported)\n\t\tdrm->mode_config.preferred_depth = 16;\n\n\tif (!xrgb8888_supported && xrgb8888_emulation_format) {\n\t\tgdrm->xrgb8888_emulation_format = xrgb8888_emulation_format;\n\t\tformats[num_formats++] = DRM_FORMAT_XRGB8888;\n\t}\n\n\tif (desc.max_buffer_size)\n\t\tmax_buffer_size = le32_to_cpu(desc.max_buffer_size);\n\t \n\tif (max_buffer_size > SZ_64M)\n\t\tmax_buffer_size = SZ_64M;\n\n\tgdrm->bulk_pipe = usb_sndbulkpipe(interface_to_usbdev(intf), usb_endpoint_num(bulk_out));\n\tgdrm->bulk_len = max_buffer_size;\n\n\tret = gud_alloc_bulk_buffer(gdrm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gdrm->compression & GUD_COMPRESSION_LZ4) {\n\t\tgdrm->lz4_comp_mem = devm_kmalloc(dev, LZ4_MEM_COMPRESS, GFP_KERNEL);\n\t\tif (!gdrm->lz4_comp_mem)\n\t\t\treturn -ENOMEM;\n\n\t\tgdrm->compress_buf = vmalloc(gdrm->bulk_len);\n\t\tif (!gdrm->compress_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = drm_simple_display_pipe_init(drm, &gdrm->pipe, &gud_pipe_funcs,\n\t\t\t\t\t   formats, num_formats,\n\t\t\t\t\t   gud_pipe_modifiers, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdevm_kfree(dev, formats);\n\tdevm_kfree(dev, formats_dev);\n\n\tret = gud_get_properties(gdrm);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get properties (error=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_plane_enable_fb_damage_clips(&gdrm->pipe.plane);\n\n\tret = gud_get_connectors(gdrm);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get connectors (error=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\n\tusb_set_intfdata(intf, gdrm);\n\n\tgdrm->dmadev = usb_intf_get_dma_device(intf);\n\tif (!gdrm->dmadev)\n\t\tdev_warn(dev, \"buffer sharing not supported\");\n\n\tdrm_debugfs_add_file(drm, \"stats\", gud_stats_debugfs, NULL);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret) {\n\t\tput_device(gdrm->dmadev);\n\t\treturn ret;\n\t}\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tdrm_fbdev_generic_setup(drm, 0);\n\n\treturn 0;\n}\n\nstatic void gud_disconnect(struct usb_interface *interface)\n{\n\tstruct gud_device *gdrm = usb_get_intfdata(interface);\n\tstruct drm_device *drm = &gdrm->drm;\n\n\tdrm_dbg(drm, \"%s:\\n\", __func__);\n\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tput_device(gdrm->dmadev);\n\tgdrm->dmadev = NULL;\n}\n\nstatic int gud_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct gud_device *gdrm = usb_get_intfdata(intf);\n\n\treturn drm_mode_config_helper_suspend(&gdrm->drm);\n}\n\nstatic int gud_resume(struct usb_interface *intf)\n{\n\tstruct gud_device *gdrm = usb_get_intfdata(intf);\n\n\tdrm_mode_config_helper_resume(&gdrm->drm);\n\n\treturn 0;\n}\n\nstatic const struct usb_device_id gud_id_table[] = {\n\t{ USB_DEVICE_INTERFACE_CLASS(0x1d50, 0x614d, USB_CLASS_VENDOR_SPEC) },\n\t{ USB_DEVICE_INTERFACE_CLASS(0x16d0, 0x10a9, USB_CLASS_VENDOR_SPEC) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, gud_id_table);\n\nstatic struct usb_driver gud_usb_driver = {\n\t.name\t\t= \"gud\",\n\t.probe\t\t= gud_probe,\n\t.disconnect\t= gud_disconnect,\n\t.id_table\t= gud_id_table,\n\t.suspend\t= gud_suspend,\n\t.resume\t\t= gud_resume,\n\t.reset_resume\t= gud_resume,\n};\n\nmodule_usb_driver(gud_usb_driver);\n\nMODULE_AUTHOR(\"Noralf Tr\u00f8nnes\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}