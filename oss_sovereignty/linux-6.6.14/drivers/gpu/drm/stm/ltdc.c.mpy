{
  "module_name": "ltdc.c",
  "hash_id": "01388f3644cd7e9e4cbfedbca81c5f5fa505b6522278b8a0afcf88749bb9c803",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/stm/ltdc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <video/videomode.h>\n\n#include \"ltdc.h\"\n\n#define NB_CRTC 1\n#define CRTC_MASK GENMASK(NB_CRTC - 1, 0)\n\n#define MAX_IRQ 4\n\n#define HWVER_10200 0x010200\n#define HWVER_10300 0x010300\n#define HWVER_20101 0x020101\n#define HWVER_40100 0x040100\n\n \n#define LAY_OFS_0\t0x80\n#define LAY_OFS_1\t0x100\n#define LAY_OFS\t(ldev->caps.layer_ofs)\n\n \n#define LTDC_IDR\t0x0000\t\t \n#define LTDC_LCR\t0x0004\t\t \n#define LTDC_SSCR\t0x0008\t\t \n#define LTDC_BPCR\t0x000C\t\t \n#define LTDC_AWCR\t0x0010\t\t \n#define LTDC_TWCR\t0x0014\t\t \n#define LTDC_GCR\t0x0018\t\t \n#define LTDC_GC1R\t0x001C\t\t \n#define LTDC_GC2R\t0x0020\t\t \n#define LTDC_SRCR\t0x0024\t\t \n#define LTDC_GACR\t0x0028\t\t \n#define LTDC_BCCR\t0x002C\t\t \n#define LTDC_IER\t0x0034\t\t \n#define LTDC_ISR\t0x0038\t\t \n#define LTDC_ICR\t0x003C\t\t \n#define LTDC_LIPCR\t0x0040\t\t \n#define LTDC_CPSR\t0x0044\t\t \n#define LTDC_CDSR\t0x0048\t\t \n#define LTDC_EDCR\t0x0060\t\t \n#define LTDC_CCRCR\t0x007C\t\t \n#define LTDC_FUT\t0x0090\t\t \n\n \n#define LTDC_L1C0R\t(ldev->caps.layer_regs[0])\t \n#define LTDC_L1C1R\t(ldev->caps.layer_regs[1])\t \n#define LTDC_L1RCR\t(ldev->caps.layer_regs[2])\t \n#define LTDC_L1CR\t(ldev->caps.layer_regs[3])\t \n#define LTDC_L1WHPCR\t(ldev->caps.layer_regs[4])\t \n#define LTDC_L1WVPCR\t(ldev->caps.layer_regs[5])\t \n#define LTDC_L1CKCR\t(ldev->caps.layer_regs[6])\t \n#define LTDC_L1PFCR\t(ldev->caps.layer_regs[7])\t \n#define LTDC_L1CACR\t(ldev->caps.layer_regs[8])\t \n#define LTDC_L1DCCR\t(ldev->caps.layer_regs[9])\t \n#define LTDC_L1BFCR\t(ldev->caps.layer_regs[10])\t \n#define LTDC_L1BLCR\t(ldev->caps.layer_regs[11])\t \n#define LTDC_L1PCR\t(ldev->caps.layer_regs[12])\t \n#define LTDC_L1CFBAR\t(ldev->caps.layer_regs[13])\t \n#define LTDC_L1CFBLR\t(ldev->caps.layer_regs[14])\t \n#define LTDC_L1CFBLNR\t(ldev->caps.layer_regs[15])\t \n#define LTDC_L1AFBA0R\t(ldev->caps.layer_regs[16])\t \n#define LTDC_L1AFBA1R\t(ldev->caps.layer_regs[17])\t \n#define LTDC_L1AFBLR\t(ldev->caps.layer_regs[18])\t \n#define LTDC_L1AFBLNR\t(ldev->caps.layer_regs[19])\t \n#define LTDC_L1CLUTWR\t(ldev->caps.layer_regs[20])\t \n#define LTDC_L1CYR0R\t(ldev->caps.layer_regs[21])\t \n#define LTDC_L1CYR1R\t(ldev->caps.layer_regs[22])\t \n#define LTDC_L1FPF0R\t(ldev->caps.layer_regs[23])\t \n#define LTDC_L1FPF1R\t(ldev->caps.layer_regs[24])\t \n\n \n#define SSCR_VSH\tGENMASK(10, 0)\t \n#define SSCR_HSW\tGENMASK(27, 16)\t \n\n#define BPCR_AVBP\tGENMASK(10, 0)\t \n#define BPCR_AHBP\tGENMASK(27, 16)\t \n\n#define AWCR_AAH\tGENMASK(10, 0)\t \n#define AWCR_AAW\tGENMASK(27, 16)\t \n\n#define TWCR_TOTALH\tGENMASK(10, 0)\t \n#define TWCR_TOTALW\tGENMASK(27, 16)\t \n\n#define GCR_LTDCEN\tBIT(0)\t\t \n#define GCR_DEN\t\tBIT(16)\t\t \n#define GCR_CRCEN\tBIT(19)\t\t \n#define GCR_PCPOL\tBIT(28)\t\t \n#define GCR_DEPOL\tBIT(29)\t\t \n#define GCR_VSPOL\tBIT(30)\t\t \n#define GCR_HSPOL\tBIT(31)\t\t \n\n#define GC1R_WBCH\tGENMASK(3, 0)\t \n#define GC1R_WGCH\tGENMASK(7, 4)\t \n#define GC1R_WRCH\tGENMASK(11, 8)\t \n#define GC1R_PBEN\tBIT(12)\t\t \n#define GC1R_DT\t\tGENMASK(15, 14)\t \n#define GC1R_GCT\tGENMASK(19, 17)\t \n#define GC1R_SHREN\tBIT(21)\t\t \n#define GC1R_BCP\tBIT(22)\t\t \n#define GC1R_BBEN\tBIT(23)\t\t \n#define GC1R_LNIP\tBIT(24)\t\t \n#define GC1R_TP\t\tBIT(25)\t\t \n#define GC1R_IPP\tBIT(26)\t\t \n#define GC1R_SPP\tBIT(27)\t\t \n#define GC1R_DWP\tBIT(28)\t\t \n#define GC1R_STREN\tBIT(29)\t\t \n#define GC1R_BMEN\tBIT(31)\t\t \n\n#define GC2R_EDCA\tBIT(0)\t\t \n#define GC2R_STSAEN\tBIT(1)\t\t \n#define GC2R_DVAEN\tBIT(2)\t\t \n#define GC2R_DPAEN\tBIT(3)\t\t \n#define GC2R_BW\t\tGENMASK(6, 4)\t \n#define GC2R_EDCEN\tBIT(7)\t\t \n\n#define SRCR_IMR\tBIT(0)\t\t \n#define SRCR_VBR\tBIT(1)\t\t \n\n#define BCCR_BCBLACK\t0x00\t\t \n#define BCCR_BCBLUE\tGENMASK(7, 0)\t \n#define BCCR_BCGREEN\tGENMASK(15, 8)\t \n#define BCCR_BCRED\tGENMASK(23, 16)\t \n#define BCCR_BCWHITE\tGENMASK(23, 0)\t \n\n#define IER_LIE\t\tBIT(0)\t\t \n#define IER_FUWIE\tBIT(1)\t\t \n#define IER_TERRIE\tBIT(2)\t\t \n#define IER_RRIE\tBIT(3)\t\t \n#define IER_FUEIE\tBIT(6)\t\t \n#define IER_CRCIE\tBIT(7)\t\t \n\n#define CPSR_CYPOS\tGENMASK(15, 0)\t \n\n#define ISR_LIF\t\tBIT(0)\t\t \n#define ISR_FUWIF\tBIT(1)\t\t \n#define ISR_TERRIF\tBIT(2)\t\t \n#define ISR_RRIF\tBIT(3)\t\t \n#define ISR_FUEIF\tBIT(6)\t\t \n#define ISR_CRCIF\tBIT(7)\t\t \n\n#define EDCR_OCYEN\tBIT(25)\t\t \n#define EDCR_OCYSEL\tBIT(26)\t\t \n#define EDCR_OCYCO\tBIT(27)\t\t \n\n#define LXCR_LEN\tBIT(0)\t\t \n#define LXCR_COLKEN\tBIT(1)\t\t \n#define LXCR_CLUTEN\tBIT(4)\t\t \n#define LXCR_HMEN\tBIT(8)\t\t \n\n#define LXWHPCR_WHSTPOS\tGENMASK(11, 0)\t \n#define LXWHPCR_WHSPPOS\tGENMASK(27, 16)\t \n\n#define LXWVPCR_WVSTPOS\tGENMASK(10, 0)\t \n#define LXWVPCR_WVSPPOS\tGENMASK(26, 16)\t \n\n#define LXPFCR_PF\tGENMASK(2, 0)\t \n#define PF_FLEXIBLE\t0x7\t\t \n\n#define LXCACR_CONSTA\tGENMASK(7, 0)\t \n\n#define LXBFCR_BF2\tGENMASK(2, 0)\t \n#define LXBFCR_BF1\tGENMASK(10, 8)\t \n#define LXBFCR_BOR\tGENMASK(18, 16)  \n\n#define LXCFBLR_CFBLL\tGENMASK(12, 0)\t \n#define LXCFBLR_CFBP\tGENMASK(31, 16)  \n\n#define LXCFBLNR_CFBLN\tGENMASK(10, 0)\t \n\n#define LXCR_C1R_YIA\tBIT(0)\t\t \n#define LXCR_C1R_YSPA\tBIT(1)\t\t \n#define LXCR_C1R_YFPA\tBIT(2)\t\t \n#define LXCR_C1R_SCA\tBIT(31)\t\t \n\n#define LxPCR_YREN\tBIT(9)\t\t \n#define LxPCR_OF\tBIT(8)\t\t \n#define LxPCR_CBF\tBIT(7)\t\t \n#define LxPCR_YF\tBIT(6)\t\t \n#define LxPCR_YCM\tGENMASK(5, 4)\t \n#define YCM_I\t\t0x0\t\t \n#define YCM_SP\t\t0x1\t\t \n#define YCM_FP\t\t0x2\t\t \n#define LxPCR_YCEN\tBIT(3)\t\t \n\n#define LXRCR_IMR\tBIT(0)\t\t \n#define LXRCR_VBR\tBIT(1)\t\t \n#define LXRCR_GRMSK\tBIT(2)\t\t \n\n#define CLUT_SIZE\t256\n\n#define CONSTA_MAX\t0xFF\t\t \n#define BF1_PAXCA\t0x600\t\t \n#define BF1_CA\t\t0x400\t\t \n#define BF2_1PAXCA\t0x007\t\t \n#define BF2_1CA\t\t0x005\t\t \n\n#define NB_PF\t\t8\t\t \n\n#define FUT_DFT\t\t128\t\t \n\n \n#define CRC_SKIP_FRAMES 2\n\nenum ltdc_pix_fmt {\n\tPF_NONE,\n\t \n\tPF_ARGB8888,\t\t \n\tPF_RGBA8888,\t\t \n\tPF_ABGR8888,\t\t \n\tPF_BGRA8888,\t\t \n\tPF_RGB888,\t\t \n\tPF_BGR888,\t\t \n\tPF_RGB565,\t\t \n\tPF_BGR565,\t\t \n\tPF_ARGB1555,\t\t \n\tPF_ARGB4444,\t\t \n\t \n\tPF_L8,\t\t\t \n\tPF_AL44,\t\t \n\tPF_AL88\t\t\t \n};\n\n \nstatic const enum ltdc_pix_fmt ltdc_pix_fmt_a0[NB_PF] = {\n\tPF_ARGB8888,\t\t \n\tPF_RGB888,\t\t \n\tPF_RGB565,\t\t \n\tPF_ARGB1555,\t\t \n\tPF_ARGB4444,\t\t \n\tPF_L8,\t\t\t \n\tPF_AL44,\t\t \n\tPF_AL88\t\t\t \n};\n\nstatic const enum ltdc_pix_fmt ltdc_pix_fmt_a1[NB_PF] = {\n\tPF_ARGB8888,\t\t \n\tPF_RGB888,\t\t \n\tPF_RGB565,\t\t \n\tPF_RGBA8888,\t\t \n\tPF_AL44,\t\t \n\tPF_L8,\t\t\t \n\tPF_ARGB1555,\t\t \n\tPF_ARGB4444\t\t \n};\n\nstatic const enum ltdc_pix_fmt ltdc_pix_fmt_a2[NB_PF] = {\n\tPF_ARGB8888,\t\t \n\tPF_ABGR8888,\t\t \n\tPF_RGBA8888,\t\t \n\tPF_BGRA8888,\t\t \n\tPF_RGB565,\t\t \n\tPF_BGR565,\t\t \n\tPF_RGB888,\t\t \n\tPF_NONE\t\t\t \n};\n\nstatic const u32 ltdc_drm_fmt_a0[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_C8\n};\n\nstatic const u32 ltdc_drm_fmt_a1[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_C8\n};\n\nstatic const u32 ltdc_drm_fmt_a2[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_C8\n};\n\nstatic const u32 ltdc_drm_fmt_ycbcr_cp[] = {\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY\n};\n\nstatic const u32 ltdc_drm_fmt_ycbcr_sp[] = {\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21\n};\n\nstatic const u32 ltdc_drm_fmt_ycbcr_fp[] = {\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YVU420\n};\n\n \nstatic const u32 ltdc_layer_regs_a0[] = {\n\t0x80,\t \n\t0x00,\t \n\t0x00,\t \n\t0x84,\t \n\t0x88,\t \n\t0x8c,\t \n\t0x90,\t \n\t0x94,\t \n\t0x98,\t \n\t0x9c,\t \n\t0xa0,\t \n\t0x00,\t \n\t0x00,\t \n\t0xac,\t \n\t0xb0,\t \n\t0xb4,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0xc4,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00\t \n};\n\nstatic const u32 ltdc_layer_regs_a1[] = {\n\t0x80,\t \n\t0x84,\t \n\t0x00,\t \n\t0x88,\t \n\t0x8c,\t \n\t0x90,\t \n\t0x94,\t \n\t0x98,\t \n\t0x9c,\t \n\t0xa0,\t \n\t0xa4,\t \n\t0xa8,\t \n\t0x00,\t \n\t0xac,\t \n\t0xb0,\t \n\t0xb4,\t \n\t0xb8,\t \n\t0xbc,\t \n\t0xc0,\t \n\t0xc4,\t \n\t0xc8,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00\t \n};\n\nstatic const u32 ltdc_layer_regs_a2[] = {\n\t0x100,\t \n\t0x104,\t \n\t0x108,\t \n\t0x10c,\t \n\t0x110,\t \n\t0x114,\t \n\t0x118,\t \n\t0x11c,\t \n\t0x120,\t \n\t0x124,\t \n\t0x128,\t \n\t0x12c,\t \n\t0x130,\t \n\t0x134,\t \n\t0x138,\t \n\t0x13c,\t \n\t0x140,\t \n\t0x144,\t \n\t0x148,\t \n\t0x14c,\t \n\t0x150,\t \n\t0x16c,\t \n\t0x170,\t \n\t0x174,\t \n\t0x178\t \n};\n\nstatic const u64 ltdc_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic const struct regmap_config stm32_ltdc_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = 0x400,\n\t.use_relaxed_mmio = true,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const u32 ltdc_ycbcr2rgb_coeffs[DRM_COLOR_ENCODING_MAX][DRM_COLOR_RANGE_MAX][2] = {\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t0x02040199,\t \n\t\t0x006400D0\t \n\t},\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t0x01C60167,\t \n\t\t0x005800B7\t \n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t0x021D01CB,\t \n\t\t0x00370089\t \n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t0x01DB0193,\t \n\t\t0x00300078\t \n\t}\n\t \n};\n\nstatic inline struct ltdc_device *crtc_to_ltdc(struct drm_crtc *crtc)\n{\n\treturn (struct ltdc_device *)crtc->dev->dev_private;\n}\n\nstatic inline struct ltdc_device *plane_to_ltdc(struct drm_plane *plane)\n{\n\treturn (struct ltdc_device *)plane->dev->dev_private;\n}\n\nstatic inline struct ltdc_device *encoder_to_ltdc(struct drm_encoder *enc)\n{\n\treturn (struct ltdc_device *)enc->dev->dev_private;\n}\n\nstatic inline enum ltdc_pix_fmt to_ltdc_pixelformat(u32 drm_fmt)\n{\n\tenum ltdc_pix_fmt pf;\n\n\tswitch (drm_fmt) {\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB8888:\n\t\tpf = PF_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XBGR8888:\n\t\tpf = PF_ABGR8888;\n\t\tbreak;\n\tcase DRM_FORMAT_RGBA8888:\n\tcase DRM_FORMAT_RGBX8888:\n\t\tpf = PF_RGBA8888;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRA8888:\n\tcase DRM_FORMAT_BGRX8888:\n\t\tpf = PF_BGRA8888;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\tpf = PF_RGB888;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR888:\n\t\tpf = PF_BGR888;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tpf = PF_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tpf = PF_BGR565;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\t\tpf = PF_ARGB1555;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XRGB4444:\n\t\tpf = PF_ARGB4444;\n\t\tbreak;\n\tcase DRM_FORMAT_C8:\n\t\tpf = PF_L8;\n\t\tbreak;\n\tdefault:\n\t\tpf = PF_NONE;\n\t\tbreak;\n\t\t \n\t}\n\n\treturn pf;\n}\n\nstatic inline u32 ltdc_set_flexible_pixel_format(struct drm_plane *plane, enum ltdc_pix_fmt pix_fmt)\n{\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tu32 lofs = plane->index * LAY_OFS, ret = PF_FLEXIBLE;\n\tint psize, alen, apos, rlen, rpos, glen, gpos, blen, bpos;\n\n\tswitch (pix_fmt) {\n\tcase PF_BGR888:\n\t\tpsize = 3;\n\t\talen = 0; apos = 0; rlen = 8; rpos = 0;\n\t\tglen = 8; gpos = 8; blen = 8; bpos = 16;\n\tbreak;\n\tcase PF_ARGB1555:\n\t\tpsize = 2;\n\t\talen = 1; apos = 15; rlen = 5; rpos = 10;\n\t\tglen = 5; gpos = 5;  blen = 5; bpos = 0;\n\tbreak;\n\tcase PF_ARGB4444:\n\t\tpsize = 2;\n\t\talen = 4; apos = 12; rlen = 4; rpos = 8;\n\t\tglen = 4; gpos = 4; blen = 4; bpos = 0;\n\tbreak;\n\tcase PF_L8:\n\t\tpsize = 1;\n\t\talen = 0; apos = 0; rlen = 8; rpos = 0;\n\t\tglen = 8; gpos = 0; blen = 8; bpos = 0;\n\tbreak;\n\tcase PF_AL44:\n\t\tpsize = 1;\n\t\talen = 4; apos = 4; rlen = 4; rpos = 0;\n\t\tglen = 4; gpos = 0; blen = 4; bpos = 0;\n\tbreak;\n\tcase PF_AL88:\n\t\tpsize = 2;\n\t\talen = 8; apos = 8; rlen = 8; rpos = 0;\n\t\tglen = 8; gpos = 0; blen = 8; bpos = 0;\n\tbreak;\n\tdefault:\n\t\tret = NB_PF;  \n\tbreak;\n\t}\n\n\tif (ret == PF_FLEXIBLE) {\n\t\tregmap_write(ldev->regmap, LTDC_L1FPF0R + lofs,\n\t\t\t     (rlen << 14)  + (rpos << 9) + (alen << 5) + apos);\n\n\t\tregmap_write(ldev->regmap, LTDC_L1FPF1R + lofs,\n\t\t\t     (psize << 18) + (blen << 14)  + (bpos << 9) + (glen << 5) + gpos);\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline u32 is_xrgb(u32 drm)\n{\n\treturn ((drm & 0xFF) == 'X' || ((drm >> 8) & 0xFF) == 'X');\n}\n\nstatic inline void ltdc_set_ycbcr_config(struct drm_plane *plane, u32 drm_pix_fmt)\n{\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tstruct drm_plane_state *state = plane->state;\n\tu32 lofs = plane->index * LAY_OFS;\n\tu32 val;\n\n\tswitch (drm_pix_fmt) {\n\tcase DRM_FORMAT_YUYV:\n\t\tval = (YCM_I << 4) | LxPCR_YF | LxPCR_CBF;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tval = (YCM_I << 4) | LxPCR_YF;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tval = (YCM_I << 4) | LxPCR_CBF;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tval = (YCM_I << 4);\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\tval = (YCM_SP << 4) | LxPCR_CBF;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\tval = (YCM_SP << 4);\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\t\tval = (YCM_FP << 4);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDRM_ERROR(\"Unsupported pixel format: %u\\n\", drm_pix_fmt);\n\t\treturn;\n\t}\n\n\t \n\tif (state->color_range == DRM_COLOR_YCBCR_LIMITED_RANGE)\n\t\tval |= LxPCR_YREN;\n\n\t \n\tval |= LxPCR_YCEN;\n\n\tregmap_write(ldev->regmap, LTDC_L1PCR + lofs, val);\n}\n\nstatic inline void ltdc_set_ycbcr_coeffs(struct drm_plane *plane)\n{\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tstruct drm_plane_state *state = plane->state;\n\tenum drm_color_encoding enc = state->color_encoding;\n\tenum drm_color_range ran = state->color_range;\n\tu32 lofs = plane->index * LAY_OFS;\n\n\tif (enc != DRM_COLOR_YCBCR_BT601 && enc != DRM_COLOR_YCBCR_BT709) {\n\t\tDRM_ERROR(\"color encoding %d not supported, use bt601 by default\\n\", enc);\n\t\t \n\t\tenc = DRM_COLOR_YCBCR_BT601;\n\t}\n\n\tif (ran != DRM_COLOR_YCBCR_LIMITED_RANGE && ran != DRM_COLOR_YCBCR_FULL_RANGE) {\n\t\tDRM_ERROR(\"color range %d not supported, use limited range by default\\n\", ran);\n\t\t \n\t\tran = DRM_COLOR_YCBCR_LIMITED_RANGE;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"Color encoding=%d, range=%d\\n\", enc, ran);\n\tregmap_write(ldev->regmap, LTDC_L1CYR0R + lofs,\n\t\t     ltdc_ycbcr2rgb_coeffs[enc][ran][0]);\n\tregmap_write(ldev->regmap, LTDC_L1CYR1R + lofs,\n\t\t     ltdc_ycbcr2rgb_coeffs[enc][ran][1]);\n}\n\nstatic inline void ltdc_irq_crc_handle(struct ltdc_device *ldev,\n\t\t\t\t       struct drm_crtc *crtc)\n{\n\tu32 crc;\n\tint ret;\n\n\tif (ldev->crc_skip_count < CRC_SKIP_FRAMES) {\n\t\tldev->crc_skip_count++;\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_read(ldev->regmap, LTDC_CCRCR, &crc);\n\tif (ret)\n\t\treturn;\n\n\t \n\tdrm_crtc_add_crc_entry(crtc, true, drm_crtc_accurate_vblank_count(crtc), &crc);\n}\n\nstatic irqreturn_t ltdc_irq_thread(int irq, void *arg)\n{\n\tstruct drm_device *ddev = arg;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tstruct drm_crtc *crtc = drm_crtc_from_index(ddev, 0);\n\n\t \n\tif (ldev->irq_status & ISR_LIF) {\n\t\tdrm_crtc_handle_vblank(crtc);\n\n\t\t \n\t\tif (ldev->crc_active)\n\t\t\tltdc_irq_crc_handle(ldev, crtc);\n\t}\n\n\tmutex_lock(&ldev->err_lock);\n\tif (ldev->irq_status & ISR_TERRIF)\n\t\tldev->transfer_err++;\n\tif (ldev->irq_status & ISR_FUEIF)\n\t\tldev->fifo_err++;\n\tif (ldev->irq_status & ISR_FUWIF)\n\t\tldev->fifo_warn++;\n\tmutex_unlock(&ldev->err_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ltdc_irq(int irq, void *arg)\n{\n\tstruct drm_device *ddev = arg;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\n\t \n\tldev->irq_status = readl_relaxed(ldev->regs + LTDC_ISR);\n\twritel_relaxed(ldev->irq_status, ldev->regs + LTDC_ICR);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \n\nstatic void ltdc_crtc_update_clut(struct drm_crtc *crtc)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_color_lut *lut;\n\tu32 val;\n\tint i;\n\n\tif (!crtc->state->color_mgmt_changed || !crtc->state->gamma_lut)\n\t\treturn;\n\n\tlut = (struct drm_color_lut *)crtc->state->gamma_lut->data;\n\n\tfor (i = 0; i < CLUT_SIZE; i++, lut++) {\n\t\tval = ((lut->red << 8) & 0xff0000) | (lut->green & 0xff00) |\n\t\t\t(lut->blue >> 8) | (i << 24);\n\t\tregmap_write(ldev->regmap, LTDC_L1CLUTWR, val);\n\t}\n}\n\nstatic void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tpm_runtime_get_sync(ddev->dev);\n\n\t \n\tregmap_write(ldev->regmap, LTDC_BCCR, BCCR_BCBLACK);\n\n\t \n\tregmap_set_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);\n\n\t \n\tif (!ldev->caps.plane_reg_shadow)\n\t\tregmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tint layer_index = 0;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\tfor (layer_index = 0; layer_index < ldev->caps.nb_layers; layer_index++)\n\t\tregmap_write_bits(ldev->regmap, LTDC_L1CR + layer_index * LAY_OFS,\n\t\t\t\t  LXCR_CLUTEN | LXCR_LEN, 0);\n\n\t \n\tregmap_clear_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);\n\n\t \n\tif (!ldev->caps.plane_reg_shadow)\n\t\tregmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_IMR);\n\n\tpm_runtime_put_sync(ddev->dev);\n\n\t \n\tmutex_lock(&ldev->err_lock);\n\tldev->transfer_err = 0;\n\tldev->fifo_err = 0;\n\tldev->fifo_warn = 0;\n\tmutex_unlock(&ldev->err_lock);\n}\n\n#define CLK_TOLERANCE_HZ 50\n\nstatic enum drm_mode_status\nltdc_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t     const struct drm_display_mode *mode)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tint target = mode->clock * 1000;\n\tint target_min = target - CLK_TOLERANCE_HZ;\n\tint target_max = target + CLK_TOLERANCE_HZ;\n\tint result;\n\n\tresult = clk_round_rate(ldev->pixel_clk, target);\n\n\tDRM_DEBUG_DRIVER(\"clk rate target %d, available %d\\n\", target, result);\n\n\t \n\tif (result > ldev->caps.pad_max_freq_hz)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (mode->type & DRM_MODE_TYPE_PREFERRED)\n\t\treturn MODE_OK;\n\n\t \n\tif (result < target_min || result > target_max)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic bool ltdc_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adjusted_mode)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tint rate = mode->clock * 1000;\n\n\tif (clk_set_rate(ldev->pixel_clk, rate) < 0) {\n\t\tDRM_ERROR(\"Cannot set rate (%dHz) for pixel clk\\n\", rate);\n\t\treturn false;\n\t}\n\n\tadjusted_mode->clock = clk_get_rate(ldev->pixel_clk) / 1000;\n\n\tDRM_DEBUG_DRIVER(\"requested clock %dkHz, adjusted clock %dkHz\\n\",\n\t\t\t mode->clock, adjusted_mode->clock);\n\n\treturn true;\n}\n\nstatic void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct drm_connector_list_iter iter;\n\tstruct drm_connector *connector = NULL;\n\tstruct drm_encoder *encoder = NULL, *en_iter;\n\tstruct drm_bridge *bridge = NULL, *br_iter;\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tu32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;\n\tu32 total_width, total_height;\n\tu32 bus_formats = MEDIA_BUS_FMT_RGB888_1X24;\n\tu32 bus_flags = 0;\n\tu32 val;\n\tint ret;\n\n\t \n\tdrm_for_each_encoder(en_iter, ddev)\n\t\tif (en_iter->crtc == crtc) {\n\t\t\tencoder = en_iter;\n\t\t\tbreak;\n\t\t}\n\n\tif (encoder) {\n\t\t \n\t\tlist_for_each_entry(br_iter, &encoder->bridge_chain, chain_node)\n\t\t\tif (br_iter->encoder == encoder) {\n\t\t\t\tbridge = br_iter;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t \n\t\tdrm_connector_list_iter_begin(ddev, &iter);\n\t\tdrm_for_each_connector_iter(connector, &iter)\n\t\t\tif (connector->encoder == encoder)\n\t\t\t\tbreak;\n\t\tdrm_connector_list_iter_end(&iter);\n\t}\n\n\tif (bridge && bridge->timings) {\n\t\tbus_flags = bridge->timings->input_bus_flags;\n\t} else if (connector) {\n\t\tbus_flags = connector->display_info.bus_flags;\n\t\tif (connector->display_info.num_bus_formats)\n\t\t\tbus_formats = connector->display_info.bus_formats[0];\n\t}\n\n\tif (!pm_runtime_active(ddev->dev)) {\n\t\tret = pm_runtime_get_sync(ddev->dev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to set mode, cannot get sync\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d mode:%s\\n\", crtc->base.id, mode->name);\n\tDRM_DEBUG_DRIVER(\"Video mode: %dx%d\", mode->hdisplay, mode->vdisplay);\n\tDRM_DEBUG_DRIVER(\" hfp %d hbp %d hsl %d vfp %d vbp %d vsl %d\\n\",\n\t\t\t mode->hsync_start - mode->hdisplay,\n\t\t\t mode->htotal - mode->hsync_end,\n\t\t\t mode->hsync_end - mode->hsync_start,\n\t\t\t mode->vsync_start - mode->vdisplay,\n\t\t\t mode->vtotal - mode->vsync_end,\n\t\t\t mode->vsync_end - mode->vsync_start);\n\n\t \n\thsync = mode->hsync_end - mode->hsync_start - 1;\n\tvsync = mode->vsync_end - mode->vsync_start - 1;\n\taccum_hbp = mode->htotal - mode->hsync_start - 1;\n\taccum_vbp = mode->vtotal - mode->vsync_start - 1;\n\taccum_act_w = accum_hbp + mode->hdisplay;\n\taccum_act_h = accum_vbp + mode->vdisplay;\n\ttotal_width = mode->htotal - 1;\n\ttotal_height = mode->vtotal - 1;\n\n\t \n\tval = 0;\n\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tval |= GCR_HSPOL;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tval |= GCR_VSPOL;\n\n\tif (bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\tval |= GCR_DEPOL;\n\n\tif (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tval |= GCR_PCPOL;\n\n\tregmap_update_bits(ldev->regmap, LTDC_GCR,\n\t\t\t   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL, val);\n\n\t \n\tval = (hsync << 16) | vsync;\n\tregmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);\n\n\t \n\tval = (accum_hbp << 16) | accum_vbp;\n\tregmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);\n\n\t \n\tval = (accum_act_w << 16) | accum_act_h;\n\tregmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);\n\n\t \n\tval = (total_width << 16) | total_height;\n\tregmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);\n\n\tregmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));\n\n\t \n\tif (ldev->caps.ycbcr_output) {\n\t\t \n\t\tint vic = drm_match_cea_mode(mode);\n\t\tu32 val;\n\n\t\tif (vic == 6 || vic == 7 || vic == 21 || vic == 22 ||\n\t\t    vic == 2 || vic == 3 || vic == 17 || vic == 18)\n\t\t\t \n\t\t\tval = 0;\n\t\telse\n\t\t\t \n\t\t\tval = EDCR_OCYSEL;\n\n\t\tswitch (bus_formats) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\t\t \n\t\t\tregmap_write(ldev->regmap, LTDC_EDCR, EDCR_OCYEN | val);\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\t\t\t \n\t\t\tregmap_write(ldev->regmap, LTDC_EDCR, EDCR_OCYEN | EDCR_OCYCO | val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tregmap_write(ldev->regmap, LTDC_EDCR, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\n\tDRM_DEBUG_ATOMIC(\"\\n\");\n\n\tltdc_crtc_update_clut(crtc);\n\n\t \n\tif (!ldev->caps.plane_reg_shadow)\n\t\tregmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&ddev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&ddev->event_lock);\n\t}\n}\n\nstatic bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t\t   bool in_vblank_irq,\n\t\t\t\t\t   int *vpos, int *hpos,\n\t\t\t\t\t   ktime_t *stime, ktime_t *etime,\n\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct drm_device *ddev = crtc->dev;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tint line, vactive_start, vactive_end, vtotal;\n\n\tif (stime)\n\t\t*stime = ktime_get();\n\n\t \n\tif (pm_runtime_active(ddev->dev)) {\n\t\tregmap_read(ldev->regmap, LTDC_CPSR, &line);\n\t\tline &= CPSR_CYPOS;\n\t\tregmap_read(ldev->regmap, LTDC_BPCR, &vactive_start);\n\t\tvactive_start &= BPCR_AVBP;\n\t\tregmap_read(ldev->regmap, LTDC_AWCR, &vactive_end);\n\t\tvactive_end &= AWCR_AAH;\n\t\tregmap_read(ldev->regmap, LTDC_TWCR, &vtotal);\n\t\tvtotal &= TWCR_TOTALH;\n\n\t\tif (line > vactive_end)\n\t\t\t*vpos = line - vtotal - vactive_start;\n\t\telse\n\t\t\t*vpos = line - vactive_start;\n\t} else {\n\t\t*vpos = 0;\n\t}\n\n\t*hpos = 0;\n\n\tif (etime)\n\t\t*etime = ktime_get();\n\n\treturn true;\n}\n\nstatic const struct drm_crtc_helper_funcs ltdc_crtc_helper_funcs = {\n\t.mode_valid = ltdc_crtc_mode_valid,\n\t.mode_fixup = ltdc_crtc_mode_fixup,\n\t.mode_set_nofb = ltdc_crtc_mode_set_nofb,\n\t.atomic_flush = ltdc_crtc_atomic_flush,\n\t.atomic_enable = ltdc_crtc_atomic_enable,\n\t.atomic_disable = ltdc_crtc_atomic_disable,\n\t.get_scanout_position = ltdc_crtc_get_scanout_position,\n};\n\nstatic int ltdc_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\tstruct drm_crtc_state *state = crtc->state;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (state->enable)\n\t\tregmap_set_bits(ldev->regmap, LTDC_IER, IER_LIE);\n\telse\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic void ltdc_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\tregmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE);\n}\n\nstatic int ltdc_crtc_set_crc_source(struct drm_crtc *crtc, const char *source)\n{\n\tstruct ltdc_device *ldev;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (!crtc)\n\t\treturn -ENODEV;\n\n\tldev = crtc_to_ltdc(crtc);\n\n\tif (source && strcmp(source, \"auto\") == 0) {\n\t\tldev->crc_active = true;\n\t\tret = regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);\n\t} else if (!source) {\n\t\tldev->crc_active = false;\n\t\tret = regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tldev->crc_skip_count = 0;\n\treturn ret;\n}\n\nstatic int ltdc_crtc_verify_crc_source(struct drm_crtc *crtc,\n\t\t\t\t       const char *source, size_t *values_cnt)\n{\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (!crtc)\n\t\treturn -ENODEV;\n\n\tif (source && strcmp(source, \"auto\") != 0) {\n\t\tDRM_DEBUG_DRIVER(\"Unknown CRC source %s for %s\\n\",\n\t\t\t\t source, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 1;\n\treturn 0;\n}\n\nstatic void ltdc_crtc_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t const struct drm_crtc_state *state)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\tstruct ltdc_device *ldev = crtc_to_ltdc(crtc);\n\n\tdrm_printf(p, \"\\ttransfer_error=%d\\n\", ldev->transfer_err);\n\tdrm_printf(p, \"\\tfifo_underrun_error=%d\\n\", ldev->fifo_err);\n\tdrm_printf(p, \"\\tfifo_underrun_warning=%d\\n\", ldev->fifo_warn);\n\tdrm_printf(p, \"\\tfifo_underrun_threshold=%d\\n\", ldev->fifo_threshold);\n}\n\nstatic const struct drm_crtc_funcs ltdc_crtc_funcs = {\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = ltdc_crtc_enable_vblank,\n\t.disable_vblank = ltdc_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.atomic_print_state = ltdc_crtc_atomic_print_state,\n};\n\nstatic const struct drm_crtc_funcs ltdc_crtc_with_crc_support_funcs = {\n\t.destroy = drm_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = ltdc_crtc_enable_vblank,\n\t.disable_vblank = ltdc_crtc_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.set_crc_source = ltdc_crtc_set_crc_source,\n\t.verify_crc_source = ltdc_crtc_verify_crc_source,\n\t.atomic_print_state = ltdc_crtc_atomic_print_state,\n};\n\n \n\nstatic int ltdc_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tu32 src_w, src_h;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tif (!fb)\n\t\treturn 0;\n\n\t \n\tsrc_w = new_plane_state->src_w >> 16;\n\tsrc_h = new_plane_state->src_h >> 16;\n\n\t \n\tif (src_w != new_plane_state->crtc_w || src_h != new_plane_state->crtc_h) {\n\t\tDRM_DEBUG_DRIVER(\"Scaling is not supported\");\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ltdc_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t  plane);\n\tstruct drm_framebuffer *fb = newstate->fb;\n\tu32 lofs = plane->index * LAY_OFS;\n\tu32 x0 = newstate->crtc_x;\n\tu32 x1 = newstate->crtc_x + newstate->crtc_w - 1;\n\tu32 y0 = newstate->crtc_y;\n\tu32 y1 = newstate->crtc_y + newstate->crtc_h - 1;\n\tu32 src_x, src_y, src_w, src_h;\n\tu32 val, pitch_in_bytes, line_length, line_number, ahbp, avbp, bpcr;\n\tu32 paddr, paddr1, paddr2;\n\tenum ltdc_pix_fmt pf;\n\n\tif (!newstate->crtc || !fb) {\n\t\tDRM_DEBUG_DRIVER(\"fb or crtc NULL\");\n\t\treturn;\n\t}\n\n\t \n\tsrc_x = newstate->src_x >> 16;\n\tsrc_y = newstate->src_y >> 16;\n\tsrc_w = newstate->src_w >> 16;\n\tsrc_h = newstate->src_h >> 16;\n\n\tDRM_DEBUG_DRIVER(\"plane:%d fb:%d (%dx%d)@(%d,%d) -> (%dx%d)@(%d,%d)\\n\",\n\t\t\t plane->base.id, fb->base.id,\n\t\t\t src_w, src_h, src_x, src_y,\n\t\t\t newstate->crtc_w, newstate->crtc_h,\n\t\t\t newstate->crtc_x, newstate->crtc_y);\n\n\tregmap_read(ldev->regmap, LTDC_BPCR, &bpcr);\n\n\tahbp = (bpcr & BPCR_AHBP) >> 16;\n\tavbp = bpcr & BPCR_AVBP;\n\n\t \n\tval = ((x1 + 1 + ahbp) << 16) + (x0 + 1 + ahbp);\n\tregmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,\n\t\t\t  LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);\n\n\t \n\tval = ((y1 + 1 + avbp) << 16) + (y0 + 1 + avbp);\n\tregmap_write_bits(ldev->regmap, LTDC_L1WVPCR + lofs,\n\t\t\t  LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);\n\n\t \n\tpf = to_ltdc_pixelformat(fb->format->format);\n\tfor (val = 0; val < NB_PF; val++)\n\t\tif (ldev->caps.pix_fmt_hw[val] == pf)\n\t\t\tbreak;\n\n\t \n\tif (ldev->caps.pix_fmt_flex && val == NB_PF)\n\t\tval = ltdc_set_flexible_pixel_format(plane, pf);\n\n\tif (val == NB_PF) {\n\t\tDRM_ERROR(\"Pixel format %.4s not supported\\n\",\n\t\t\t  (char *)&fb->format->format);\n\t\tval = 0;\t \n\t}\n\tregmap_write_bits(ldev->regmap, LTDC_L1PFCR + lofs, LXPFCR_PF, val);\n\n\t \n\tval = newstate->alpha >> 8;\n\tregmap_write_bits(ldev->regmap, LTDC_L1CACR + lofs, LXCACR_CONSTA, val);\n\n\t \n\tval = BF1_PAXCA | BF2_1PAXCA;\n\tif (!fb->format->has_alpha)\n\t\tval = BF1_CA | BF2_1CA;\n\n\t \n\tif (ldev->caps.non_alpha_only_l1 &&\n\t    plane->type != DRM_PLANE_TYPE_PRIMARY)\n\t\tval = BF1_PAXCA | BF2_1PAXCA;\n\n\tif (ldev->caps.dynamic_zorder) {\n\t\tval |= (newstate->normalized_zpos << 16);\n\t\tregmap_write_bits(ldev->regmap, LTDC_L1BFCR + lofs,\n\t\t\t\t  LXBFCR_BF2 | LXBFCR_BF1 | LXBFCR_BOR, val);\n\t} else {\n\t\tregmap_write_bits(ldev->regmap, LTDC_L1BFCR + lofs,\n\t\t\t\t  LXBFCR_BF2 | LXBFCR_BF1, val);\n\t}\n\n\t \n\tpaddr = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 0);\n\n\tif (newstate->rotation & DRM_MODE_REFLECT_X)\n\t\tpaddr += (fb->format->cpp[0] * (x1 - x0 + 1)) - 1;\n\n\tif (newstate->rotation & DRM_MODE_REFLECT_Y)\n\t\tpaddr += (fb->pitches[0] * (y1 - y0));\n\n\tDRM_DEBUG_DRIVER(\"fb: phys 0x%08x\", paddr);\n\tregmap_write(ldev->regmap, LTDC_L1CFBAR + lofs, paddr);\n\n\t \n\tline_length = fb->format->cpp[0] *\n\t\t      (x1 - x0 + 1) + (ldev->caps.bus_width >> 3) - 1;\n\n\tif (newstate->rotation & DRM_MODE_REFLECT_Y)\n\t\t \n\t\tpitch_in_bytes = 0x10000 - fb->pitches[0];\n\telse\n\t\tpitch_in_bytes = fb->pitches[0];\n\n\tval = (pitch_in_bytes << 16) | line_length;\n\tregmap_write_bits(ldev->regmap, LTDC_L1CFBLR + lofs, LXCFBLR_CFBLL | LXCFBLR_CFBP, val);\n\n\t \n\tline_number = y1 - y0 + 1;\n\tregmap_write_bits(ldev->regmap, LTDC_L1CFBLNR + lofs, LXCFBLNR_CFBLN, line_number);\n\n\tif (ldev->caps.ycbcr_input) {\n\t\tif (fb->format->is_yuv) {\n\t\t\tswitch (fb->format->format) {\n\t\t\tcase DRM_FORMAT_NV12:\n\t\t\tcase DRM_FORMAT_NV21:\n\t\t\t \n\t\t\tpaddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_X)\n\t\t\t\tpaddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_Y)\n\t\t\t\tpaddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;\n\n\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);\n\t\t\tbreak;\n\t\t\tcase DRM_FORMAT_YUV420:\n\t\t\t \n\t\t\tpaddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);\n\t\t\tpaddr2 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 2);\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_X) {\n\t\t\t\tpaddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;\n\t\t\t\tpaddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;\n\t\t\t}\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_Y) {\n\t\t\t\tpaddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;\n\t\t\t\tpaddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;\n\t\t\t}\n\n\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);\n\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBA1R + lofs, paddr2);\n\t\t\tbreak;\n\t\t\tcase DRM_FORMAT_YVU420:\n\t\t\t \n\t\t\tpaddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 2);\n\t\t\tpaddr2 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_X) {\n\t\t\t\tpaddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;\n\t\t\t\tpaddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;\n\t\t\t}\n\n\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_Y) {\n\t\t\t\tpaddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;\n\t\t\t\tpaddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;\n\t\t\t}\n\n\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);\n\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBA1R + lofs, paddr2);\n\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (fb->format->num_planes > 1) {\n\t\t\t\tif (newstate->rotation & DRM_MODE_REFLECT_Y)\n\t\t\t\t\t \n\t\t\t\t\tpitch_in_bytes = 0x10000 - fb->pitches[1];\n\t\t\t\telse\n\t\t\t\t\tpitch_in_bytes = fb->pitches[1];\n\n\t\t\t\tline_length = ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) +\n\t\t\t\t\t      (ldev->caps.bus_width >> 3) - 1;\n\n\t\t\t\t \n\t\t\t\tval = (pitch_in_bytes << 16) | line_length;\n\t\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBLR + lofs, val);\n\n\t\t\t\t \n\t\t\t\tval = line_number >> 1;\n\t\t\t\tregmap_write(ldev->regmap, LTDC_L1AFBLNR + lofs, val);\n\t\t\t}\n\n\t\t\t \n\t\t\tltdc_set_ycbcr_coeffs(plane);\n\n\t\t\t \n\t\t\tltdc_set_ycbcr_config(plane, fb->format->format);\n\t\t} else {\n\t\t\t \n\t\t\tregmap_write(ldev->regmap, LTDC_L1PCR + lofs, 0);\n\t\t}\n\t}\n\n\t \n\tval = fb->format->format == DRM_FORMAT_C8 ? LXCR_CLUTEN : 0;\n\tval |= LXCR_LEN;\n\n\t \n\tif (newstate->rotation & DRM_MODE_REFLECT_X)\n\t\tval |= LXCR_HMEN;\n\n\tregmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN | LXCR_HMEN, val);\n\n\t \n\tif (ldev->caps.plane_reg_shadow)\n\t\tregmap_write_bits(ldev->regmap, LTDC_L1RCR + lofs,\n\t\t\t\t  LXRCR_IMR | LXRCR_VBR | LXRCR_GRMSK, LXRCR_VBR);\n\n\tldev->plane_fpsi[plane->index].counter++;\n\n\tmutex_lock(&ldev->err_lock);\n\tif (ldev->transfer_err) {\n\t\tDRM_WARN(\"ltdc transfer error: %d\\n\", ldev->transfer_err);\n\t\tldev->transfer_err = 0;\n\t}\n\n\tif (ldev->caps.fifo_threshold) {\n\t\tif (ldev->fifo_err) {\n\t\t\tDRM_WARN(\"ltdc fifo underrun: please verify display mode\\n\");\n\t\t\tldev->fifo_err = 0;\n\t\t}\n\t} else {\n\t\tif (ldev->fifo_warn >= ldev->fifo_threshold) {\n\t\t\tDRM_WARN(\"ltdc fifo underrun: please verify display mode\\n\");\n\t\t\tldev->fifo_warn = 0;\n\t\t}\n\t}\n\tmutex_unlock(&ldev->err_lock);\n}\n\nstatic void ltdc_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t  plane);\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tu32 lofs = plane->index * LAY_OFS;\n\n\t \n\tregmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN |  LXCR_HMEN, 0);\n\n\t \n\tif (ldev->caps.plane_reg_shadow)\n\t\tregmap_write_bits(ldev->regmap, LTDC_L1RCR + lofs,\n\t\t\t\t  LXRCR_IMR | LXRCR_VBR | LXRCR_GRMSK, LXRCR_VBR);\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d plane:%d\\n\",\n\t\t\t oldstate->crtc->base.id, plane->base.id);\n}\n\nstatic void ltdc_plane_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t  const struct drm_plane_state *state)\n{\n\tstruct drm_plane *plane = state->plane;\n\tstruct ltdc_device *ldev = plane_to_ltdc(plane);\n\tstruct fps_info *fpsi = &ldev->plane_fpsi[plane->index];\n\tint ms_since_last;\n\tktime_t now;\n\n\tnow = ktime_get();\n\tms_since_last = ktime_to_ms(ktime_sub(now, fpsi->last_timestamp));\n\n\tdrm_printf(p, \"\\tuser_updates=%dfps\\n\",\n\t\t   DIV_ROUND_CLOSEST(fpsi->counter * 1000, ms_since_last));\n\n\tfpsi->last_timestamp = now;\n\tfpsi->counter = 0;\n}\n\nstatic const struct drm_plane_funcs ltdc_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = drm_plane_cleanup,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.atomic_print_state = ltdc_plane_atomic_print_state,\n};\n\nstatic const struct drm_plane_helper_funcs ltdc_plane_helper_funcs = {\n\t.atomic_check = ltdc_plane_atomic_check,\n\t.atomic_update = ltdc_plane_atomic_update,\n\t.atomic_disable = ltdc_plane_atomic_disable,\n};\n\nstatic struct drm_plane *ltdc_plane_create(struct drm_device *ddev,\n\t\t\t\t\t   enum drm_plane_type type,\n\t\t\t\t\t   int index)\n{\n\tunsigned long possible_crtcs = CRTC_MASK;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tstruct device *dev = ddev->dev;\n\tstruct drm_plane *plane;\n\tunsigned int i, nb_fmt = 0;\n\tu32 *formats;\n\tu32 drm_fmt;\n\tconst u64 *modifiers = ltdc_format_modifiers;\n\tu32 lofs = index * LAY_OFS;\n\tu32 val;\n\tint ret;\n\n\t \n\tformats = devm_kzalloc(dev, (ldev->caps.pix_fmt_nb +\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp) +\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) +\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp)) *\n\t\t\t       sizeof(*formats), GFP_KERNEL);\n\n\tfor (i = 0; i < ldev->caps.pix_fmt_nb; i++) {\n\t\tdrm_fmt = ldev->caps.pix_fmt_drm[i];\n\n\t\t \n\t\tif (ldev->caps.non_alpha_only_l1)\n\t\t\t \n\t\t\tif (type != DRM_PLANE_TYPE_PRIMARY && is_xrgb(drm_fmt))\n\t\t\t\tcontinue;\n\n\t\tformats[nb_fmt++] = drm_fmt;\n\t}\n\n\t \n\tif (ldev->caps.ycbcr_input) {\n\t\tregmap_read(ldev->regmap, LTDC_L1C1R + lofs, &val);\n\t\tif (val & LXCR_C1R_YIA) {\n\t\t\tmemcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_cp,\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp) * sizeof(*formats));\n\t\t\tnb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp);\n\t\t}\n\t\tif (val & LXCR_C1R_YSPA) {\n\t\t\tmemcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_sp,\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) * sizeof(*formats));\n\t\t\tnb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp);\n\t\t}\n\t\tif (val & LXCR_C1R_YFPA) {\n\t\t\tmemcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_fp,\n\t\t\t       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp) * sizeof(*formats));\n\t\t\tnb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp);\n\t\t}\n\t}\n\n\tplane = devm_kzalloc(dev, sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn NULL;\n\n\tret = drm_universal_plane_init(ddev, plane, possible_crtcs,\n\t\t\t\t       &ltdc_plane_funcs, formats, nb_fmt,\n\t\t\t\t       modifiers, type, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (ldev->caps.ycbcr_input) {\n\t\tif (val & (LXCR_C1R_YIA | LXCR_C1R_YSPA | LXCR_C1R_YFPA))\n\t\t\tdrm_plane_create_color_properties(plane,\n\t\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT709),\n\t\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\t\t\t  DRM_COLOR_YCBCR_BT601,\n\t\t\t\t\t\t\t  DRM_COLOR_YCBCR_LIMITED_RANGE);\n\t}\n\n\tdrm_plane_helper_add(plane, &ltdc_plane_helper_funcs);\n\n\tdrm_plane_create_alpha_property(plane);\n\n\tDRM_DEBUG_DRIVER(\"plane:%d created\\n\", plane->base.id);\n\n\treturn plane;\n}\n\nstatic void ltdc_plane_destroy_all(struct drm_device *ddev)\n{\n\tstruct drm_plane *plane, *plane_temp;\n\n\tlist_for_each_entry_safe(plane, plane_temp,\n\t\t\t\t &ddev->mode_config.plane_list, head)\n\t\tdrm_plane_cleanup(plane);\n}\n\nstatic int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)\n{\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tstruct drm_plane *primary, *overlay;\n\tint supported_rotations = DRM_MODE_ROTATE_0 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;\n\tunsigned int i;\n\tint ret;\n\n\tprimary = ltdc_plane_create(ddev, DRM_PLANE_TYPE_PRIMARY, 0);\n\tif (!primary) {\n\t\tDRM_ERROR(\"Can not create primary plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ldev->caps.dynamic_zorder)\n\t\tdrm_plane_create_zpos_property(primary, 0, 0, ldev->caps.nb_layers - 1);\n\telse\n\t\tdrm_plane_create_zpos_immutable_property(primary, 0);\n\n\tif (ldev->caps.plane_rotation)\n\t\tdrm_plane_create_rotation_property(primary, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   supported_rotations);\n\n\t \n\tif (ldev->caps.crc)\n\t\tret = drm_crtc_init_with_planes(ddev, crtc, primary, NULL,\n\t\t\t\t\t\t&ltdc_crtc_with_crc_support_funcs, NULL);\n\telse\n\t\tret = drm_crtc_init_with_planes(ddev, crtc, primary, NULL,\n\t\t\t\t\t\t&ltdc_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Can not initialize CRTC\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &ltdc_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(crtc, CLUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, CLUT_SIZE);\n\n\tDRM_DEBUG_DRIVER(\"CRTC:%d created\\n\", crtc->base.id);\n\n\t \n\tfor (i = 1; i < ldev->caps.nb_layers; i++) {\n\t\toverlay = ltdc_plane_create(ddev, DRM_PLANE_TYPE_OVERLAY, i);\n\t\tif (!overlay) {\n\t\t\tret = -ENOMEM;\n\t\t\tDRM_ERROR(\"Can not create overlay plane %d\\n\", i);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ldev->caps.dynamic_zorder)\n\t\t\tdrm_plane_create_zpos_property(overlay, i, 0, ldev->caps.nb_layers - 1);\n\t\telse\n\t\t\tdrm_plane_create_zpos_immutable_property(overlay, i);\n\n\t\tif (ldev->caps.plane_rotation)\n\t\t\tdrm_plane_create_rotation_property(overlay, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t\t   supported_rotations);\n\t}\n\n\treturn 0;\n\ncleanup:\n\tltdc_plane_destroy_all(ddev);\n\treturn ret;\n}\n\nstatic void ltdc_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tregmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);\n\n\t \n\tpinctrl_pm_select_sleep_state(ddev->dev);\n}\n\nstatic void ltdc_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tif (ldev->caps.fifo_threshold)\n\t\tregmap_write(ldev->regmap, LTDC_FUT, ldev->fifo_threshold);\n\n\t \n\tregmap_set_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);\n}\n\nstatic void ltdc_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t  struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *ddev = encoder->dev;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tif (encoder->encoder_type == DRM_MODE_ENCODER_DPI)\n\t\tpinctrl_pm_select_default_state(ddev->dev);\n}\n\nstatic const struct drm_encoder_helper_funcs ltdc_encoder_helper_funcs = {\n\t.disable = ltdc_encoder_disable,\n\t.enable = ltdc_encoder_enable,\n\t.mode_set = ltdc_encoder_mode_set,\n};\n\nstatic int ltdc_encoder_init(struct drm_device *ddev, struct drm_bridge *bridge)\n{\n\tstruct drm_encoder *encoder;\n\tint ret;\n\n\tencoder = devm_kzalloc(ddev->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (!encoder)\n\t\treturn -ENOMEM;\n\n\tencoder->possible_crtcs = CRTC_MASK;\n\tencoder->possible_clones = 0;\t \n\n\tdrm_simple_encoder_init(ddev, encoder, DRM_MODE_ENCODER_DPI);\n\n\tdrm_encoder_helper_add(encoder, &ltdc_encoder_helper_funcs);\n\n\tret = drm_bridge_attach(encoder, bridge, NULL, 0);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdrm_encoder_cleanup(encoder);\n\t\treturn ret;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"Bridge encoder:%d created\\n\", encoder->base.id);\n\n\treturn 0;\n}\n\nstatic int ltdc_get_caps(struct drm_device *ddev)\n{\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tu32 bus_width_log2, lcr, gc2r;\n\n\t \n\tregmap_read(ldev->regmap, LTDC_LCR, &lcr);\n\n\tldev->caps.nb_layers = clamp((int)lcr, 1, LTDC_MAX_LAYER);\n\n\t \n\tregmap_read(ldev->regmap, LTDC_GC2R, &gc2r);\n\tbus_width_log2 = (gc2r & GC2R_BW) >> 4;\n\tldev->caps.bus_width = 8 << bus_width_log2;\n\tregmap_read(ldev->regmap, LTDC_IDR, &ldev->caps.hw_version);\n\n\tswitch (ldev->caps.hw_version) {\n\tcase HWVER_10200:\n\tcase HWVER_10300:\n\t\tldev->caps.layer_ofs = LAY_OFS_0;\n\t\tldev->caps.layer_regs = ltdc_layer_regs_a0;\n\t\tldev->caps.pix_fmt_hw = ltdc_pix_fmt_a0;\n\t\tldev->caps.pix_fmt_drm = ltdc_drm_fmt_a0;\n\t\tldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a0);\n\t\tldev->caps.pix_fmt_flex = false;\n\t\t \n\t\tldev->caps.non_alpha_only_l1 = true;\n\t\tldev->caps.pad_max_freq_hz = 90000000;\n\t\tif (ldev->caps.hw_version == HWVER_10200)\n\t\t\tldev->caps.pad_max_freq_hz = 65000000;\n\t\tldev->caps.nb_irq = 2;\n\t\tldev->caps.ycbcr_input = false;\n\t\tldev->caps.ycbcr_output = false;\n\t\tldev->caps.plane_reg_shadow = false;\n\t\tldev->caps.crc = false;\n\t\tldev->caps.dynamic_zorder = false;\n\t\tldev->caps.plane_rotation = false;\n\t\tldev->caps.fifo_threshold = false;\n\t\tbreak;\n\tcase HWVER_20101:\n\t\tldev->caps.layer_ofs = LAY_OFS_0;\n\t\tldev->caps.layer_regs = ltdc_layer_regs_a1;\n\t\tldev->caps.pix_fmt_hw = ltdc_pix_fmt_a1;\n\t\tldev->caps.pix_fmt_drm = ltdc_drm_fmt_a1;\n\t\tldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a1);\n\t\tldev->caps.pix_fmt_flex = false;\n\t\tldev->caps.non_alpha_only_l1 = false;\n\t\tldev->caps.pad_max_freq_hz = 150000000;\n\t\tldev->caps.nb_irq = 4;\n\t\tldev->caps.ycbcr_input = false;\n\t\tldev->caps.ycbcr_output = false;\n\t\tldev->caps.plane_reg_shadow = false;\n\t\tldev->caps.crc = false;\n\t\tldev->caps.dynamic_zorder = false;\n\t\tldev->caps.plane_rotation = false;\n\t\tldev->caps.fifo_threshold = false;\n\t\tbreak;\n\tcase HWVER_40100:\n\t\tldev->caps.layer_ofs = LAY_OFS_1;\n\t\tldev->caps.layer_regs = ltdc_layer_regs_a2;\n\t\tldev->caps.pix_fmt_hw = ltdc_pix_fmt_a2;\n\t\tldev->caps.pix_fmt_drm = ltdc_drm_fmt_a2;\n\t\tldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a2);\n\t\tldev->caps.pix_fmt_flex = true;\n\t\tldev->caps.non_alpha_only_l1 = false;\n\t\tldev->caps.pad_max_freq_hz = 90000000;\n\t\tldev->caps.nb_irq = 2;\n\t\tldev->caps.ycbcr_input = true;\n\t\tldev->caps.ycbcr_output = true;\n\t\tldev->caps.plane_reg_shadow = true;\n\t\tldev->caps.crc = true;\n\t\tldev->caps.dynamic_zorder = true;\n\t\tldev->caps.plane_rotation = true;\n\t\tldev->caps.fifo_threshold = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid ltdc_suspend(struct drm_device *ddev)\n{\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\tclk_disable_unprepare(ldev->pixel_clk);\n}\n\nint ltdc_resume(struct drm_device *ddev)\n{\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tret = clk_prepare_enable(ldev->pixel_clk);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to enable pixel clock (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ltdc_load(struct drm_device *ddev)\n{\n\tstruct platform_device *pdev = to_platform_device(ddev->dev);\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tstruct device *dev = ddev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tstruct drm_crtc *crtc;\n\tstruct reset_control *rstc;\n\tstruct resource *res;\n\tint irq, i, nb_endpoints;\n\tint ret = -ENODEV;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tnb_endpoints = of_graph_get_endpoint_count(np);\n\tif (!nb_endpoints)\n\t\treturn -ENODEV;\n\n\tldev->pixel_clk = devm_clk_get(dev, \"lcd\");\n\tif (IS_ERR(ldev->pixel_clk)) {\n\t\tif (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Unable to get lcd clock\\n\");\n\t\treturn PTR_ERR(ldev->pixel_clk);\n\t}\n\n\tif (clk_prepare_enable(ldev->pixel_clk)) {\n\t\tDRM_ERROR(\"Unable to prepare pixel clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < nb_endpoints; i++) {\n\t\tret = drm_of_find_panel_or_bridge(np, 0, i, &panel, &bridge);\n\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tcontinue;\n\t\telse if (ret)\n\t\t\tgoto err;\n\n\t\tif (panel) {\n\t\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t\t    DRM_MODE_CONNECTOR_DPI);\n\t\t\tif (IS_ERR(bridge)) {\n\t\t\t\tDRM_ERROR(\"panel-bridge endpoint %d\\n\", i);\n\t\t\t\tret = PTR_ERR(bridge);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (bridge) {\n\t\t\tret = ltdc_encoder_init(ddev, bridge);\n\t\t\tif (ret) {\n\t\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\t\tDRM_ERROR(\"init encoder endpoint %d\\n\", i);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\trstc = devm_reset_control_get_exclusive(dev, NULL);\n\n\tmutex_init(&ldev->err_lock);\n\n\tif (!IS_ERR(rstc)) {\n\t\treset_control_assert(rstc);\n\t\tusleep_range(10, 20);\n\t\treset_control_deassert(rstc);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tldev->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ldev->regs)) {\n\t\tDRM_ERROR(\"Unable to get ltdc registers\\n\");\n\t\tret = PTR_ERR(ldev->regs);\n\t\tgoto err;\n\t}\n\n\tldev->regmap = devm_regmap_init_mmio(&pdev->dev, ldev->regs, &stm32_ltdc_regmap_cfg);\n\tif (IS_ERR(ldev->regmap)) {\n\t\tDRM_ERROR(\"Unable to regmap ltdc registers\\n\");\n\t\tret = PTR_ERR(ldev->regmap);\n\t\tgoto err;\n\t}\n\n\tret = ltdc_get_caps(ddev);\n\tif (ret) {\n\t\tDRM_ERROR(\"hardware identifier (0x%08x) not supported!\\n\",\n\t\t\t  ldev->caps.hw_version);\n\t\tgoto err;\n\t}\n\n\t \n\tif (ldev->caps.fifo_threshold)\n\t\tregmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |\n\t\t\t\t  IER_TERRIE);\n\telse\n\t\tregmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |\n\t\t\t\t  IER_TERRIE | IER_FUEIE);\n\n\tDRM_DEBUG_DRIVER(\"ltdc hw version 0x%08x\\n\", ldev->caps.hw_version);\n\n\t \n\tldev->transfer_err = 0;\n\tldev->fifo_err = 0;\n\tldev->fifo_warn = 0;\n\tldev->fifo_threshold = FUT_DFT;\n\n\tfor (i = 0; i < ldev->caps.nb_irq; i++) {\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, irq, ltdc_irq,\n\t\t\t\t\t\tltdc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), ddev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to register LTDC interrupt\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tcrtc = devm_kzalloc(dev, sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc) {\n\t\tDRM_ERROR(\"Failed to allocate crtc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = ltdc_crtc_init(ddev, crtc);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init crtc\\n\");\n\t\tgoto err;\n\t}\n\n\tret = drm_vblank_init(ddev, NB_CRTC);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed calling drm_vblank_init()\\n\");\n\t\tgoto err;\n\t}\n\n\tclk_disable_unprepare(ldev->pixel_clk);\n\n\tpinctrl_pm_select_sleep_state(ddev->dev);\n\n\tpm_runtime_enable(ddev->dev);\n\n\treturn 0;\nerr:\n\tfor (i = 0; i < nb_endpoints; i++)\n\t\tdrm_of_panel_bridge_remove(ddev->dev->of_node, 0, i);\n\n\tclk_disable_unprepare(ldev->pixel_clk);\n\n\treturn ret;\n}\n\nvoid ltdc_unload(struct drm_device *ddev)\n{\n\tstruct device *dev = ddev->dev;\n\tint nb_endpoints, i;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tnb_endpoints = of_graph_get_endpoint_count(dev->of_node);\n\n\tfor (i = 0; i < nb_endpoints; i++)\n\t\tdrm_of_panel_bridge_remove(ddev->dev->of_node, 0, i);\n\n\tpm_runtime_disable(ddev->dev);\n}\n\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_AUTHOR(\"Mickael Reulier <mickael.reulier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics ST DRM LTDC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}