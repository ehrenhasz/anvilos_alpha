{
  "module_name": "drv.c",
  "hash_id": "c3e8e4473ffc5360d4f2cf218432549661914fe2d9682b6b1cfcfdd95e92ffe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/stm/drv.c",
  "human_readable_source": "\n \n\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"ltdc.h\"\n\n#define STM_MAX_FB_WIDTH\t2048\n#define STM_MAX_FB_HEIGHT\t2048  \n\nstatic const struct drm_mode_config_funcs drv_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int stm_gem_dma_dumb_create(struct drm_file *file,\n\t\t\t\t   struct drm_device *dev,\n\t\t\t\t   struct drm_mode_create_dumb *args)\n{\n\tunsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\n\t \n\targs->pitch = roundup(min_pitch, 128);\n\targs->height = roundup(args->height, 4);\n\n\treturn drm_gem_dma_dumb_create_internal(file, dev, args);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(drv_driver_fops);\n\nstatic const struct drm_driver drv_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.name = \"stm\",\n\t.desc = \"STMicroelectronics SoC DRM\",\n\t.date = \"20170330\",\n\t.major = 1,\n\t.minor = 0,\n\t.patchlevel = 0,\n\t.fops = &drv_driver_fops,\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(stm_gem_dma_dumb_create),\n};\n\nstatic int drv_load(struct drm_device *ddev)\n{\n\tstruct platform_device *pdev = to_platform_device(ddev->dev);\n\tstruct ltdc_device *ldev;\n\tint ret;\n\n\tDRM_DEBUG(\"%s\\n\", __func__);\n\n\tldev = devm_kzalloc(ddev->dev, sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev)\n\t\treturn -ENOMEM;\n\n\tddev->dev_private = (void *)ldev;\n\n\tret = drmm_mode_config_init(ddev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tddev->mode_config.min_width = 0;\n\tddev->mode_config.min_height = 0;\n\tddev->mode_config.max_width = STM_MAX_FB_WIDTH;\n\tddev->mode_config.max_height = STM_MAX_FB_HEIGHT;\n\tddev->mode_config.funcs = &drv_mode_config_funcs;\n\tddev->mode_config.normalize_zpos = true;\n\n\tret = ltdc_load(ddev);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_mode_config_reset(ddev);\n\tdrm_kms_helper_poll_init(ddev);\n\n\tplatform_set_drvdata(pdev, ddev);\n\n\treturn 0;\n}\n\nstatic void drv_unload(struct drm_device *ddev)\n{\n\tDRM_DEBUG(\"%s\\n\", __func__);\n\n\tdrm_kms_helper_poll_fini(ddev);\n\tdrm_atomic_helper_shutdown(ddev);\n\tltdc_unload(ddev);\n}\n\nstatic __maybe_unused int drv_suspend(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tstruct drm_atomic_state *state;\n\n\tWARN_ON(ldev->suspend_state);\n\n\tstate = drm_atomic_helper_suspend(ddev);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tldev->suspend_state = state;\n\tpm_runtime_force_suspend(dev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int drv_resume(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct ltdc_device *ldev = ddev->dev_private;\n\tint ret;\n\n\tif (WARN_ON(!ldev->suspend_state))\n\t\treturn -ENOENT;\n\n\tpm_runtime_force_resume(dev);\n\tret = drm_atomic_helper_resume(ddev, ldev->suspend_state);\n\tif (ret)\n\t\tpm_runtime_force_suspend(dev);\n\n\tldev->suspend_state = NULL;\n\n\treturn ret;\n}\n\nstatic __maybe_unused int drv_runtime_suspend(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\tltdc_suspend(ddev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int drv_runtime_resume(struct device *dev)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\treturn ltdc_resume(ddev);\n}\n\nstatic const struct dev_pm_ops drv_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(drv_suspend, drv_resume)\n\tSET_RUNTIME_PM_OPS(drv_runtime_suspend,\n\t\t\t   drv_runtime_resume, NULL)\n};\n\nstatic int stm_drm_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *ddev;\n\tint ret;\n\n\tDRM_DEBUG(\"%s\\n\", __func__);\n\n\tret = drm_aperture_remove_framebuffers(&drv_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\n\tddev = drm_dev_alloc(&drv_driver, dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tret = drv_load(ddev);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\tgoto err_put;\n\n\tdrm_fbdev_dma_setup(ddev, 16);\n\n\treturn 0;\n\nerr_put:\n\tdrm_dev_put(ddev);\n\n\treturn ret;\n}\n\nstatic void stm_drm_platform_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *ddev = platform_get_drvdata(pdev);\n\n\tDRM_DEBUG(\"%s\\n\", __func__);\n\n\tdrm_dev_unregister(ddev);\n\tdrv_unload(ddev);\n\tdrm_dev_put(ddev);\n}\n\nstatic void stm_drm_platform_shutdown(struct platform_device *pdev)\n{\n\tdrm_atomic_helper_shutdown(platform_get_drvdata(pdev));\n}\n\nstatic const struct of_device_id drv_dt_ids[] = {\n\t{ .compatible = \"st,stm32-ltdc\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, drv_dt_ids);\n\nstatic struct platform_driver stm_drm_platform_driver = {\n\t.probe = stm_drm_platform_probe,\n\t.remove_new = stm_drm_platform_remove,\n\t.shutdown = stm_drm_platform_shutdown,\n\t.driver = {\n\t\t.name = \"stm32-display\",\n\t\t.of_match_table = drv_dt_ids,\n\t\t.pm = &drv_pm_ops,\n\t},\n};\n\ndrm_module_platform_driver(stm_drm_platform_driver);\n\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_AUTHOR(\"Mickael Reulier <mickael.reulier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics ST DRM LTDC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}