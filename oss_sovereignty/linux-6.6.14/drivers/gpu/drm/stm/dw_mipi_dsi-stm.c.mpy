{
  "module_name": "dw_mipi_dsi-stm.c",
  "hash_id": "25bb4af78e83cc071d84fb9dd9781ca0c55dd5a21fc2aeb0122d5d23a4a75f1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/bridge/dw_mipi_dsi.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_print.h>\n\n#define HWVER_130\t\t\t0x31333000\t \n#define HWVER_131\t\t\t0x31333100\t \n\n \n#define DSI_VERSION\t\t\t0x00\n#define VERSION\t\t\t\tGENMASK(31, 8)\n\n \n \n#define DSI_WCFGR\t0x0400\t\t \n#define WCFGR_DSIM\tBIT(0)\t\t \n#define WCFGR_COLMUX\tGENMASK(3, 1)\t \n\n#define DSI_WCR\t\t0x0404\t\t \n#define WCR_DSIEN\tBIT(3)\t\t \n\n#define DSI_WISR\t0x040C\t\t \n#define WISR_PLLLS\tBIT(8)\t\t \n#define WISR_RRS\tBIT(12)\t\t \n\n#define DSI_WPCR0\t0x0418\t\t \n#define WPCR0_UIX4\tGENMASK(5, 0)\t \n#define WPCR0_TDDL\tBIT(16)\t\t \n\n#define DSI_WRPCR\t0x0430\t\t \n#define WRPCR_PLLEN\tBIT(0)\t\t \n#define WRPCR_NDIV\tGENMASK(8, 2)\t \n#define WRPCR_IDF\tGENMASK(14, 11)\t \n#define WRPCR_ODF\tGENMASK(17, 16)\t \n#define WRPCR_REGEN\tBIT(24)\t\t \n#define WRPCR_BGREN\tBIT(28)\t\t \n#define IDF_MIN\t\t1\n#define IDF_MAX\t\t7\n#define NDIV_MIN\t10\n#define NDIV_MAX\t125\n#define ODF_MIN\t\t1\n#define ODF_MAX\t\t8\n\n \nenum dsi_color {\n\tDSI_RGB565_CONF1,\n\tDSI_RGB565_CONF2,\n\tDSI_RGB565_CONF3,\n\tDSI_RGB666_CONF1,\n\tDSI_RGB666_CONF2,\n\tDSI_RGB888,\n};\n\n#define LANE_MIN_KBPS\t31250\n#define LANE_MAX_KBPS\t500000\n\n \n#define SLEEP_US\t1000\n#define TIMEOUT_US\t200000\n\nstruct dw_mipi_dsi_stm {\n\tvoid __iomem *base;\n\tstruct clk *pllref_clk;\n\tstruct dw_mipi_dsi *dsi;\n\tu32 hw_version;\n\tint lane_min_kbps;\n\tint lane_max_kbps;\n\tstruct regulator *vdd_supply;\n};\n\nstatic inline void dsi_write(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 val)\n{\n\twritel(val, dsi->base + reg);\n}\n\nstatic inline u32 dsi_read(struct dw_mipi_dsi_stm *dsi, u32 reg)\n{\n\treturn readl(dsi->base + reg);\n}\n\nstatic inline void dsi_set(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 mask)\n{\n\tdsi_write(dsi, reg, dsi_read(dsi, reg) | mask);\n}\n\nstatic inline void dsi_clear(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 mask)\n{\n\tdsi_write(dsi, reg, dsi_read(dsi, reg) & ~mask);\n}\n\nstatic inline void dsi_update_bits(struct dw_mipi_dsi_stm *dsi, u32 reg,\n\t\t\t\t   u32 mask, u32 val)\n{\n\tdsi_write(dsi, reg, (dsi_read(dsi, reg) & ~mask) | val);\n}\n\nstatic enum dsi_color dsi_color_from_mipi(enum mipi_dsi_pixel_format fmt)\n{\n\tswitch (fmt) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treturn DSI_RGB888;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\treturn DSI_RGB666_CONF2;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treturn DSI_RGB666_CONF1;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn DSI_RGB565_CONF1;\n\tdefault:\n\t\tDRM_DEBUG_DRIVER(\"MIPI color invalid, so we use rgb888\\n\");\n\t}\n\treturn DSI_RGB888;\n}\n\nstatic int dsi_pll_get_clkout_khz(int clkin_khz, int idf, int ndiv, int odf)\n{\n\tint divisor = idf * odf;\n\n\t \n\tif (!divisor)\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST(clkin_khz * ndiv, divisor);\n}\n\nstatic int dsi_pll_get_params(struct dw_mipi_dsi_stm *dsi,\n\t\t\t      int clkin_khz, int clkout_khz,\n\t\t\t      int *idf, int *ndiv, int *odf)\n{\n\tint i, o, n, n_min, n_max;\n\tint fvco_min, fvco_max, delta, best_delta;  \n\n\t \n\tif (clkin_khz <= 0 || clkout_khz <= 0)\n\t\treturn -EINVAL;\n\n\tfvco_min = dsi->lane_min_kbps * 2 * ODF_MAX;\n\tfvco_max = dsi->lane_max_kbps * 2 * ODF_MIN;\n\n\tbest_delta = 1000000;  \n\n\tfor (i = IDF_MIN; i <= IDF_MAX; i++) {\n\t\t \n\t\tn_min = ((fvco_min * i) / (2 * clkin_khz)) + 1;\n\t\tn_max = (fvco_max * i) / (2 * clkin_khz);\n\n\t\t \n\t\tif (n_min >= NDIV_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tif (n_min < NDIV_MIN)\n\t\t\tn_min = NDIV_MIN;\n\t\tif (n_max > NDIV_MAX)\n\t\t\tn_max = NDIV_MAX;\n\n\t\tfor (o = ODF_MIN; o <= ODF_MAX; o *= 2) {\n\t\t\tn = DIV_ROUND_CLOSEST(i * o * clkout_khz, clkin_khz);\n\t\t\t \n\t\t\tif (n < n_min || n > n_max)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdelta = dsi_pll_get_clkout_khz(clkin_khz, i, n, o) -\n\t\t\t\tclkout_khz;\n\t\t\tif (delta < 0)\n\t\t\t\tdelta = -delta;\n\t\t\tif (delta < best_delta) {\n\t\t\t\t*idf = i;\n\t\t\t\t*ndiv = n;\n\t\t\t\t*odf = o;\n\t\t\t\tbest_delta = delta;\n\t\t\t}\n\t\t\t \n\t\t\tif (!delta)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_mipi_dsi_phy_init(void *priv_data)\n{\n\tstruct dw_mipi_dsi_stm *dsi = priv_data;\n\tu32 val;\n\tint ret;\n\n\t \n\tdsi_set(dsi, DSI_WRPCR, WRPCR_REGEN | WRPCR_BGREN);\n\tret = readl_poll_timeout(dsi->base + DSI_WISR, val, val & WISR_RRS,\n\t\t\t\t SLEEP_US, TIMEOUT_US);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"!TIMEOUT! waiting REGU, let's continue\\n\");\n\n\t \n\tdsi_set(dsi, DSI_WRPCR, WRPCR_PLLEN);\n\tret = readl_poll_timeout(dsi->base + DSI_WISR, val, val & WISR_PLLLS,\n\t\t\t\t SLEEP_US, TIMEOUT_US);\n\tif (ret)\n\t\tDRM_DEBUG_DRIVER(\"!TIMEOUT! waiting PLL, let's continue\\n\");\n\n\treturn 0;\n}\n\nstatic void dw_mipi_dsi_phy_power_on(void *priv_data)\n{\n\tstruct dw_mipi_dsi_stm *dsi = priv_data;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tdsi_set(dsi, DSI_WCR, WCR_DSIEN);\n}\n\nstatic void dw_mipi_dsi_phy_power_off(void *priv_data)\n{\n\tstruct dw_mipi_dsi_stm *dsi = priv_data;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\t \n\tdsi_clear(dsi, DSI_WCR, WCR_DSIEN);\n}\n\nstatic int\ndw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,\n\t\t\t  unsigned long mode_flags, u32 lanes, u32 format,\n\t\t\t  unsigned int *lane_mbps)\n{\n\tstruct dw_mipi_dsi_stm *dsi = priv_data;\n\tunsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;\n\tint ret, bpp;\n\tu32 val;\n\n\tpll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);\n\n\t \n\tbpp = mipi_dsi_pixel_format_to_bpp(format);\n\tpll_out_khz = mode->clock * bpp / lanes;\n\n\t \n\tif (mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\tpll_out_khz = (pll_out_khz * 12) / 10;\n\n\tif (pll_out_khz > dsi->lane_max_kbps) {\n\t\tpll_out_khz = dsi->lane_max_kbps;\n\t\tDRM_WARN(\"Warning max phy mbps is used\\n\");\n\t}\n\tif (pll_out_khz < dsi->lane_min_kbps) {\n\t\tpll_out_khz = dsi->lane_min_kbps;\n\t\tDRM_WARN(\"Warning min phy mbps is used\\n\");\n\t}\n\n\t \n\tidf = 0;\n\tndiv = 0;\n\todf = 0;\n\tret = dsi_pll_get_params(dsi, pll_in_khz, pll_out_khz,\n\t\t\t\t &idf, &ndiv, &odf);\n\tif (ret)\n\t\tDRM_WARN(\"Warning dsi_pll_get_params(): bad params\\n\");\n\n\t \n\tpll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);\n\n\t \n\tdsi_update_bits(dsi, DSI_WRPCR,\tWRPCR_NDIV | WRPCR_IDF | WRPCR_ODF,\n\t\t\t(ndiv << 2) | (idf << 11) | ((ffs(odf) - 1) << 16));\n\n\t \n\tval = 4000000 / pll_out_khz;\n\tdsi_update_bits(dsi, DSI_WPCR0, WPCR0_UIX4, val);\n\n\t \n\tdsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);\n\n\t \n\tdsi_update_bits(dsi, DSI_WCFGR, WCFGR_COLMUX,\n\t\t\tdsi_color_from_mipi(format) << 1);\n\n\t*lane_mbps = pll_out_khz / 1000;\n\n\tDRM_DEBUG_DRIVER(\"pll_in %ukHz pll_out %ukHz lane_mbps %uMHz\\n\",\n\t\t\t pll_in_khz, pll_out_khz, *lane_mbps);\n\n\treturn 0;\n}\n\n#define DSI_PHY_DELAY(fp, vp, mbps) DIV_ROUND_UP((fp) * (mbps) + 1000 * (vp), 8000)\n\nstatic int\ndw_mipi_dsi_phy_get_timing(void *priv_data, unsigned int lane_mbps,\n\t\t\t   struct dw_mipi_dsi_dphy_timing *timing)\n{\n\t \n\ttiming->clk_hs2lp = DSI_PHY_DELAY(272, 136, lane_mbps);\n\ttiming->clk_lp2hs = DSI_PHY_DELAY(512, 40, lane_mbps);\n\ttiming->data_hs2lp = DSI_PHY_DELAY(192, 64, lane_mbps);\n\ttiming->data_lp2hs = DSI_PHY_DELAY(256, 32, lane_mbps);\n\n\treturn 0;\n}\n\n#define CLK_TOLERANCE_HZ 50\n\nstatic enum drm_mode_status\ndw_mipi_dsi_stm_mode_valid(void *priv_data,\n\t\t\t   const struct drm_display_mode *mode,\n\t\t\t   unsigned long mode_flags, u32 lanes, u32 format)\n{\n\tstruct dw_mipi_dsi_stm *dsi = priv_data;\n\tunsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;\n\tint ret, bpp;\n\n\tbpp = mipi_dsi_pixel_format_to_bpp(format);\n\tif (bpp < 0)\n\t\treturn MODE_BAD;\n\n\t \n\tpll_out_khz = mode->clock * bpp / lanes;\n\n\tif (pll_out_khz > dsi->lane_max_kbps)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {\n\t\t \n\t\tpll_out_khz = (pll_out_khz * 12) / 10;\n\t} else {\n\t\tif (pll_out_khz < dsi->lane_min_kbps)\n\t\t\treturn MODE_CLOCK_LOW;\n\t}\n\n\t \n\tidf = 0;\n\tndiv = 0;\n\todf = 0;\n\tpll_in_khz = clk_get_rate(dsi->pllref_clk) / 1000;\n\tret = dsi_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);\n\tif (ret) {\n\t\tDRM_WARN(\"Warning dsi_pll_get_params(): bad params\\n\");\n\t\treturn MODE_ERROR;\n\t}\n\n\tif (!(mode_flags & MIPI_DSI_MODE_VIDEO_BURST)) {\n\t\tunsigned int px_clock_hz, target_px_clock_hz, lane_mbps;\n\t\tint dsi_short_packet_size_px, hfp, hsync, hbp, delay_to_lp;\n\t\tstruct dw_mipi_dsi_dphy_timing dphy_timing;\n\n\t\t \n\t\tpll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);\n\n\t\tpx_clock_hz = DIV_ROUND_CLOSEST_ULL(1000ULL * pll_out_khz * lanes, bpp);\n\t\ttarget_px_clock_hz = mode->clock * 1000;\n\t\t \n\t\tif (px_clock_hz < target_px_clock_hz - CLK_TOLERANCE_HZ ||\n\t\t    px_clock_hz > target_px_clock_hz + CLK_TOLERANCE_HZ)\n\t\t\treturn MODE_CLOCK_RANGE;\n\n\t\t \n\t\tdsi_short_packet_size_px = DIV_ROUND_UP(4 * BITS_PER_BYTE, bpp);\n\n\t\thfp = mode->hsync_start - mode->hdisplay;\n\t\thsync = mode->hsync_end - mode->hsync_start;\n\t\thbp = mode->htotal - mode->hsync_end;\n\n\t\t \n\t\tif (hsync < dsi_short_packet_size_px)\n\t\t\treturn MODE_HSYNC_NARROW;\n\n\t\tif (mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\t\t \n\t\t\tif (hbp < dsi_short_packet_size_px)\n\t\t\t\treturn MODE_HSYNC_NARROW;\n\t\t\thbp -= dsi_short_packet_size_px;\n\t\t} else {\n\t\t\t \n\t\t\thbp += hsync - dsi_short_packet_size_px;\n\t\t}\n\n\t\tlane_mbps = pll_out_khz / 1000;\n\t\tret = dw_mipi_dsi_phy_get_timing(priv_data, lane_mbps, &dphy_timing);\n\t\tif (ret)\n\t\t\treturn MODE_ERROR;\n\t\t \n\t\tdelay_to_lp = DIV_ROUND_UP((dphy_timing.data_hs2lp + dphy_timing.data_lp2hs) *\n\t\t\t\t\t   lanes * BITS_PER_BYTE, bpp);\n\t\tif (hfp < delay_to_lp && hbp < delay_to_lp)\n\t\t\treturn MODE_HSYNC;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_ops = {\n\t.init = dw_mipi_dsi_phy_init,\n\t.power_on = dw_mipi_dsi_phy_power_on,\n\t.power_off = dw_mipi_dsi_phy_power_off,\n\t.get_lane_mbps = dw_mipi_dsi_get_lane_mbps,\n\t.get_timing = dw_mipi_dsi_phy_get_timing,\n};\n\nstatic struct dw_mipi_dsi_plat_data dw_mipi_dsi_stm_plat_data = {\n\t.max_data_lanes = 2,\n\t.mode_valid = dw_mipi_dsi_stm_mode_valid,\n\t.phy_ops = &dw_mipi_dsi_stm_phy_ops,\n};\n\nstatic const struct of_device_id dw_mipi_dsi_stm_dt_ids[] = {\n\t{ .compatible = \"st,stm32-dsi\", .data = &dw_mipi_dsi_stm_plat_data, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, dw_mipi_dsi_stm_dt_ids);\n\nstatic int dw_mipi_dsi_stm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_mipi_dsi_stm *dsi;\n\tstruct clk *pclk;\n\tint ret;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dsi->base)) {\n\t\tret = PTR_ERR(dsi->base);\n\t\tDRM_ERROR(\"Unable to get dsi registers %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->vdd_supply = devm_regulator_get(dev, \"phy-dsi\");\n\tif (IS_ERR(dsi->vdd_supply)) {\n\t\tret = PTR_ERR(dsi->vdd_supply);\n\t\tdev_err_probe(dev, ret, \"Failed to request regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(dsi->vdd_supply);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to enable regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->pllref_clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(dsi->pllref_clk)) {\n\t\tret = PTR_ERR(dsi->pllref_clk);\n\t\tdev_err_probe(dev, ret, \"Unable to get pll reference clock\\n\");\n\t\tgoto err_clk_get;\n\t}\n\n\tret = clk_prepare_enable(dsi->pllref_clk);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to enable pllref_clk: %d\\n\", ret);\n\t\tgoto err_clk_get;\n\t}\n\n\tpclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(pclk)) {\n\t\tret = PTR_ERR(pclk);\n\t\tDRM_ERROR(\"Unable to get peripheral clock: %d\\n\", ret);\n\t\tgoto err_dsi_probe;\n\t}\n\n\tret = clk_prepare_enable(pclk);\n\tif (ret) {\n\t\tDRM_ERROR(\"%s: Failed to enable peripheral clk\\n\", __func__);\n\t\tgoto err_dsi_probe;\n\t}\n\n\tdsi->hw_version = dsi_read(dsi, DSI_VERSION) & VERSION;\n\tclk_disable_unprepare(pclk);\n\n\tif (dsi->hw_version != HWVER_130 && dsi->hw_version != HWVER_131) {\n\t\tret = -ENODEV;\n\t\tDRM_ERROR(\"bad dsi hardware version\\n\");\n\t\tgoto err_dsi_probe;\n\t}\n\n\t \n\tdsi->lane_min_kbps = LANE_MIN_KBPS;\n\tdsi->lane_max_kbps = LANE_MAX_KBPS;\n\tif (dsi->hw_version == HWVER_131) {\n\t\tdsi->lane_min_kbps *= 2;\n\t\tdsi->lane_max_kbps *= 2;\n\t}\n\n\tdw_mipi_dsi_stm_plat_data.base = dsi->base;\n\tdw_mipi_dsi_stm_plat_data.priv_data = dsi;\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tdsi->dsi = dw_mipi_dsi_probe(pdev, &dw_mipi_dsi_stm_plat_data);\n\tif (IS_ERR(dsi->dsi)) {\n\t\tret = PTR_ERR(dsi->dsi);\n\t\tdev_err_probe(dev, ret, \"Failed to initialize mipi dsi host\\n\");\n\t\tgoto err_dsi_probe;\n\t}\n\n\treturn 0;\n\nerr_dsi_probe:\n\tclk_disable_unprepare(dsi->pllref_clk);\nerr_clk_get:\n\tregulator_disable(dsi->vdd_supply);\n\n\treturn ret;\n}\n\nstatic void dw_mipi_dsi_stm_remove(struct platform_device *pdev)\n{\n\tstruct dw_mipi_dsi_stm *dsi = platform_get_drvdata(pdev);\n\n\tdw_mipi_dsi_remove(dsi->dsi);\n\tclk_disable_unprepare(dsi->pllref_clk);\n\tregulator_disable(dsi->vdd_supply);\n}\n\nstatic int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)\n{\n\tstruct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tclk_disable_unprepare(dsi->pllref_clk);\n\tregulator_disable(dsi->vdd_supply);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)\n{\n\tstruct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;\n\tint ret;\n\n\tDRM_DEBUG_DRIVER(\"\\n\");\n\n\tret = regulator_enable(dsi->vdd_supply);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to enable regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dsi->pllref_clk);\n\tif (ret) {\n\t\tregulator_disable(dsi->vdd_supply);\n\t\tDRM_ERROR(\"Failed to enable pllref_clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw_mipi_dsi_stm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dw_mipi_dsi_stm_suspend,\n\t\t\t\tdw_mipi_dsi_stm_resume)\n};\n\nstatic struct platform_driver dw_mipi_dsi_stm_driver = {\n\t.probe\t\t= dw_mipi_dsi_stm_probe,\n\t.remove_new\t= dw_mipi_dsi_stm_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = dw_mipi_dsi_stm_dt_ids,\n\t\t.name\t= \"stm32-display-dsi\",\n\t\t.pm = &dw_mipi_dsi_stm_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dw_mipi_dsi_stm_driver);\n\nMODULE_AUTHOR(\"Philippe Cornu <philippe.cornu@st.com>\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics DW MIPI DSI host controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}