{
  "module_name": "drm_framebuffer.c",
  "hash_id": "648631ee79c7f1f880a27527adc3a4f76a1fbe4fc7846bc3a1626ca4090502cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_framebuffer.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_auth.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_print.h>\n#include <drm/drm_util.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\n \n\nint drm_framebuffer_check_src_coords(uint32_t src_x, uint32_t src_y,\n\t\t\t\t     uint32_t src_w, uint32_t src_h,\n\t\t\t\t     const struct drm_framebuffer *fb)\n{\n\tunsigned int fb_width, fb_height;\n\n\tfb_width = fb->width << 16;\n\tfb_height = fb->height << 16;\n\n\t \n\tif (src_w > fb_width ||\n\t    src_x > fb_width - src_w ||\n\t    src_h > fb_height ||\n\t    src_y > fb_height - src_h) {\n\t\tdrm_dbg_kms(fb->dev, \"Invalid source coordinates \"\n\t\t\t    \"%u.%06ux%u.%06u+%u.%06u+%u.%06u (fb %ux%u)\\n\",\n\t\t\t    src_w >> 16, ((src_w & 0xffff) * 15625) >> 10,\n\t\t\t    src_h >> 16, ((src_h & 0xffff) * 15625) >> 10,\n\t\t\t    src_x >> 16, ((src_x & 0xffff) * 15625) >> 10,\n\t\t\t    src_y >> 16, ((src_y & 0xffff) * 15625) >> 10,\n\t\t\t    fb->width, fb->height);\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}\n\n \nint drm_mode_addfb(struct drm_device *dev, struct drm_mode_fb_cmd *or,\n\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd2 r = {};\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tr.pixel_format = drm_driver_legacy_fb_format(dev, or->bpp, or->depth);\n\tif (r.pixel_format == DRM_FORMAT_INVALID) {\n\t\tdrm_dbg_kms(dev, \"bad {bpp:%d, depth:%d}\\n\", or->bpp, or->depth);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tr.fb_id = or->fb_id;\n\tr.width = or->width;\n\tr.height = or->height;\n\tr.pitches[0] = or->pitch;\n\tr.handles[0] = or->handle;\n\n\tret = drm_mode_addfb2(dev, &r, file_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tor->fb_id = r.fb_id;\n\n\treturn 0;\n}\n\nint drm_mode_addfb_ioctl(struct drm_device *dev,\n\t\t\t void *data, struct drm_file *file_priv)\n{\n\treturn drm_mode_addfb(dev, data, file_priv);\n}\n\nstatic int fb_plane_width(int width,\n\t\t\t  const struct drm_format_info *format, int plane)\n{\n\tif (plane == 0)\n\t\treturn width;\n\n\treturn DIV_ROUND_UP(width, format->hsub);\n}\n\nstatic int fb_plane_height(int height,\n\t\t\t   const struct drm_format_info *format, int plane)\n{\n\tif (plane == 0)\n\t\treturn height;\n\n\treturn DIV_ROUND_UP(height, format->vsub);\n}\n\nstatic int framebuffer_check(struct drm_device *dev,\n\t\t\t     const struct drm_mode_fb_cmd2 *r)\n{\n\tconst struct drm_format_info *info;\n\tint i;\n\n\t \n\tif (!__drm_format_info(r->pixel_format)) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer format %p4cc\\n\",\n\t\t\t    &r->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->width == 0) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer width %u\\n\", r->width);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->height == 0) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer height %u\\n\", r->height);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinfo = drm_get_format_info(dev, r);\n\n\tfor (i = 0; i < info->num_planes; i++) {\n\t\tunsigned int width = fb_plane_width(r->width, info, i);\n\t\tunsigned int height = fb_plane_height(r->height, info, i);\n\t\tunsigned int block_size = info->char_per_block[i];\n\t\tu64 min_pitch = drm_format_info_min_pitch(info, i, width);\n\n\t\tif (!block_size && (r->modifier[i] == DRM_FORMAT_MOD_LINEAR)) {\n\t\t\tdrm_dbg_kms(dev, \"Format requires non-linear modifier for plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!r->handles[i]) {\n\t\t\tdrm_dbg_kms(dev, \"no buffer object handle for plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (min_pitch > UINT_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tif ((uint64_t) height * r->pitches[i] + r->offsets[i] > UINT_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tif (block_size && r->pitches[i] < min_pitch) {\n\t\t\tdrm_dbg_kms(dev, \"bad pitch %u for plane %d\\n\", r->pitches[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->modifier[i] && !(r->flags & DRM_MODE_FB_MODIFIERS)) {\n\t\t\tdrm_dbg_kms(dev, \"bad fb modifier %llu for plane %d\\n\",\n\t\t\t\t    r->modifier[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->flags & DRM_MODE_FB_MODIFIERS &&\n\t\t    r->modifier[i] != r->modifier[0]) {\n\t\t\tdrm_dbg_kms(dev, \"bad fb modifier %llu for plane %d\\n\",\n\t\t\t\t    r->modifier[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tswitch (r->modifier[i]) {\n\t\tcase DRM_FORMAT_MOD_SAMSUNG_64_32_TILE:\n\t\t\t \n\t\t\tif (r->pixel_format != DRM_FORMAT_NV12 ||\n\t\t\t\t\twidth % 128 || height % 32 ||\n\t\t\t\t\tr->pitches[i] % 128) {\n\t\t\t\tdrm_dbg_kms(dev, \"bad modifier data for plane %d\\n\", i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = info->num_planes; i < 4; i++) {\n\t\tif (r->modifier[i]) {\n\t\t\tdrm_dbg_kms(dev, \"non-zero modifier for unused plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!(r->flags & DRM_MODE_FB_MODIFIERS))\n\t\t\tcontinue;\n\n\t\tif (r->handles[i]) {\n\t\t\tdrm_dbg_kms(dev, \"buffer object handle for unused plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->pitches[i]) {\n\t\t\tdrm_dbg_kms(dev, \"non-zero pitch for unused plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->offsets[i]) {\n\t\t\tdrm_dbg_kms(dev, \"non-zero offset for unused plane %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct drm_framebuffer *\ndrm_internal_framebuffer_create(struct drm_device *dev,\n\t\t\t\tconst struct drm_mode_fb_cmd2 *r,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\n\tif (r->flags & ~(DRM_MODE_FB_INTERLACED | DRM_MODE_FB_MODIFIERS)) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer flags 0x%08x\\n\", r->flags);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif ((config->min_width > r->width) || (r->width > config->max_width)) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer width %d, should be >= %d && <= %d\\n\",\n\t\t\t    r->width, config->min_width, config->max_width);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif ((config->min_height > r->height) || (r->height > config->max_height)) {\n\t\tdrm_dbg_kms(dev, \"bad framebuffer height %d, should be >= %d && <= %d\\n\",\n\t\t\t    r->height, config->min_height, config->max_height);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (r->flags & DRM_MODE_FB_MODIFIERS &&\n\t    dev->mode_config.fb_modifiers_not_supported) {\n\t\tdrm_dbg_kms(dev, \"driver does not support fb modifiers\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = framebuffer_check(dev, r);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfb = dev->mode_config.funcs->fb_create(dev, file_priv, r);\n\tif (IS_ERR(fb)) {\n\t\tdrm_dbg_kms(dev, \"could not create framebuffer\\n\");\n\t\treturn fb;\n\t}\n\n\treturn fb;\n}\nEXPORT_SYMBOL_FOR_TESTS_ONLY(drm_internal_framebuffer_create);\n\n \nint drm_mode_addfb2(struct drm_device *dev,\n\t\t    void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd2 *r = data;\n\tstruct drm_framebuffer *fb;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tfb = drm_internal_framebuffer_create(dev, r, file_priv);\n\tif (IS_ERR(fb))\n\t\treturn PTR_ERR(fb);\n\n\tdrm_dbg_kms(dev, \"[FB:%d]\\n\", fb->base.id);\n\tr->fb_id = fb->base.id;\n\n\t \n\tmutex_lock(&file_priv->fbs_lock);\n\tlist_add(&fb->filp_head, &file_priv->fbs);\n\tmutex_unlock(&file_priv->fbs_lock);\n\n\treturn 0;\n}\n\nint drm_mode_addfb2_ioctl(struct drm_device *dev,\n\t\t\t  void *data, struct drm_file *file_priv)\n{\n#ifdef __BIG_ENDIAN\n\tif (!dev->mode_config.quirk_addfb_prefer_host_byte_order) {\n\t\t \n\t\tdrm_dbg_kms(dev, \"addfb2 broken on bigendian\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\treturn drm_mode_addfb2(dev, data, file_priv);\n}\n\nstruct drm_mode_rmfb_work {\n\tstruct work_struct work;\n\tstruct list_head fbs;\n};\n\nstatic void drm_mode_rmfb_work_fn(struct work_struct *w)\n{\n\tstruct drm_mode_rmfb_work *arg = container_of(w, typeof(*arg), work);\n\n\twhile (!list_empty(&arg->fbs)) {\n\t\tstruct drm_framebuffer *fb =\n\t\t\tlist_first_entry(&arg->fbs, typeof(*fb), filp_head);\n\n\t\tdrm_dbg_kms(fb->dev,\n\t\t\t    \"Removing [FB:%d] from all active usage due to RMFB ioctl\\n\",\n\t\t\t    fb->base.id);\n\t\tlist_del_init(&fb->filp_head);\n\t\tdrm_framebuffer_remove(fb);\n\t}\n}\n\n \nint drm_mode_rmfb(struct drm_device *dev, u32 fb_id,\n\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_framebuffer *fbl = NULL;\n\tint found = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, fb_id);\n\tif (!fb)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&file_priv->fbs_lock);\n\tlist_for_each_entry(fbl, &file_priv->fbs, filp_head)\n\t\tif (fb == fbl)\n\t\t\tfound = 1;\n\tif (!found) {\n\t\tmutex_unlock(&file_priv->fbs_lock);\n\t\tgoto fail_unref;\n\t}\n\n\tlist_del_init(&fb->filp_head);\n\tmutex_unlock(&file_priv->fbs_lock);\n\n\t \n\tdrm_framebuffer_put(fb);\n\n\t \n\tif (drm_framebuffer_read_refcount(fb) > 1) {\n\t\tstruct drm_mode_rmfb_work arg;\n\n\t\tINIT_WORK_ONSTACK(&arg.work, drm_mode_rmfb_work_fn);\n\t\tINIT_LIST_HEAD(&arg.fbs);\n\t\tlist_add_tail(&fb->filp_head, &arg.fbs);\n\n\t\tschedule_work(&arg.work);\n\t\tflush_work(&arg.work);\n\t\tdestroy_work_on_stack(&arg.work);\n\t} else\n\t\tdrm_framebuffer_put(fb);\n\n\treturn 0;\n\nfail_unref:\n\tdrm_framebuffer_put(fb);\n\treturn -ENOENT;\n}\n\nint drm_mode_rmfb_ioctl(struct drm_device *dev,\n\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tuint32_t *fb_id = data;\n\n\treturn drm_mode_rmfb(dev, *fb_id, file_priv);\n}\n\n \nint drm_mode_getfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);\n\tif (!fb)\n\t\treturn -ENOENT;\n\n\t \n\tif (fb->format->num_planes > 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!fb->funcs->create_handle) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tr->height = fb->height;\n\tr->width = fb->width;\n\tr->depth = fb->format->depth;\n\tr->bpp = drm_format_info_bpp(fb->format, 0);\n\tr->pitch = fb->pitches[0];\n\n\t \n\tif (!drm_is_current_master(file_priv) && !capable(CAP_SYS_ADMIN)) {\n\t\tr->handle = 0;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = fb->funcs->create_handle(fb, file_priv, &r->handle);\n\nout:\n\tdrm_framebuffer_put(fb);\n\treturn ret;\n}\n\n \nint drm_mode_getfb2_ioctl(struct drm_device *dev,\n\t\t\t  void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd2 *r = data;\n\tstruct drm_framebuffer *fb;\n\tunsigned int i;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);\n\tif (!fb)\n\t\treturn -ENOENT;\n\n\t \n\tif (!fb->obj[0] &&\n\t    (fb->format->num_planes > 1 || !fb->funcs->create_handle)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tr->height = fb->height;\n\tr->width = fb->width;\n\tr->pixel_format = fb->format->format;\n\n\tr->flags = 0;\n\tif (!dev->mode_config.fb_modifiers_not_supported)\n\t\tr->flags |= DRM_MODE_FB_MODIFIERS;\n\n\tfor (i = 0; i < ARRAY_SIZE(r->handles); i++) {\n\t\tr->handles[i] = 0;\n\t\tr->pitches[i] = 0;\n\t\tr->offsets[i] = 0;\n\t\tr->modifier[i] = 0;\n\t}\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tr->pitches[i] = fb->pitches[i];\n\t\tr->offsets[i] = fb->offsets[i];\n\t\tif (!dev->mode_config.fb_modifiers_not_supported)\n\t\t\tr->modifier[i] = fb->modifier;\n\t}\n\n\t \n\tif (!drm_is_current_master(file_priv) && !capable(CAP_SYS_ADMIN)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tint j;\n\n\t\t \n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (fb->obj[i] == fb->obj[j]) {\n\t\t\t\tr->handles[i] = r->handles[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (r->handles[i])\n\t\t\tcontinue;\n\n\t\tif (fb->obj[i]) {\n\t\t\tret = drm_gem_handle_create(file_priv, fb->obj[i],\n\t\t\t\t\t\t    &r->handles[i]);\n\t\t} else {\n\t\t\tWARN_ON(i > 0);\n\t\t\tret = fb->funcs->create_handle(fb, file_priv,\n\t\t\t\t\t\t       &r->handles[i]);\n\t\t}\n\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (ret != 0) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(r->handles); i++) {\n\t\t\tint j;\n\n\t\t\tif (r->handles[i])\n\t\t\t\tdrm_gem_handle_delete(file_priv, r->handles[i]);\n\n\t\t\t \n\t\t\tfor (j = i + 1; j < ARRAY_SIZE(r->handles); j++) {\n\t\t\t\tif (r->handles[j] == r->handles[i])\n\t\t\t\t\tr->handles[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tdrm_framebuffer_put(fb);\n\treturn ret;\n}\n\n \nint drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tfb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);\n\tif (!fb)\n\t\treturn -ENOENT;\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t \n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tdrm_framebuffer_put(fb);\n\n\treturn ret;\n}\n\n \nvoid drm_fb_release(struct drm_file *priv)\n{\n\tstruct drm_framebuffer *fb, *tfb;\n\tstruct drm_mode_rmfb_work arg;\n\n\tINIT_LIST_HEAD(&arg.fbs);\n\n\t \n\tlist_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {\n\t\tif (drm_framebuffer_read_refcount(fb) > 1) {\n\t\t\tlist_move_tail(&fb->filp_head, &arg.fbs);\n\t\t} else {\n\t\t\tlist_del_init(&fb->filp_head);\n\n\t\t\t \n\t\t\tdrm_framebuffer_put(fb);\n\t\t}\n\t}\n\n\tif (!list_empty(&arg.fbs)) {\n\t\tINIT_WORK_ONSTACK(&arg.work, drm_mode_rmfb_work_fn);\n\n\t\tschedule_work(&arg.work);\n\t\tflush_work(&arg.work);\n\t\tdestroy_work_on_stack(&arg.work);\n\t}\n}\n\nvoid drm_framebuffer_free(struct kref *kref)\n{\n\tstruct drm_framebuffer *fb =\n\t\t\tcontainer_of(kref, struct drm_framebuffer, base.refcount);\n\tstruct drm_device *dev = fb->dev;\n\n\t \n\tdrm_mode_object_unregister(dev, &fb->base);\n\n\tfb->funcs->destroy(fb);\n}\n\n \nint drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n\t\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(fb->dev != dev || !fb->format))\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&fb->filp_head);\n\n\tfb->funcs = funcs;\n\tstrcpy(fb->comm, current->comm);\n\n\tret = __drm_mode_object_add(dev, &fb->base, DRM_MODE_OBJECT_FB,\n\t\t\t\t    false, drm_framebuffer_free);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_lock(&dev->mode_config.fb_lock);\n\tdev->mode_config.num_fb++;\n\tlist_add(&fb->head, &dev->mode_config.fb_list);\n\tmutex_unlock(&dev->mode_config.fb_lock);\n\n\tdrm_mode_object_register(dev, &fb->base);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_framebuffer_init);\n\n \nstruct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,\n\t\t\t\t\t       struct drm_file *file_priv,\n\t\t\t\t\t       uint32_t id)\n{\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb = NULL;\n\n\tobj = __drm_mode_object_find(dev, file_priv, id, DRM_MODE_OBJECT_FB);\n\tif (obj)\n\t\tfb = obj_to_fb(obj);\n\treturn fb;\n}\nEXPORT_SYMBOL(drm_framebuffer_lookup);\n\n \nvoid drm_framebuffer_unregister_private(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev;\n\n\tif (!fb)\n\t\treturn;\n\n\tdev = fb->dev;\n\n\t \n\tdrm_mode_object_unregister(dev, &fb->base);\n}\nEXPORT_SYMBOL(drm_framebuffer_unregister_private);\n\n \nvoid drm_framebuffer_cleanup(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev = fb->dev;\n\n\tmutex_lock(&dev->mode_config.fb_lock);\n\tlist_del(&fb->head);\n\tdev->mode_config.num_fb--;\n\tmutex_unlock(&dev->mode_config.fb_lock);\n}\nEXPORT_SYMBOL(drm_framebuffer_cleanup);\n\nstatic int atomic_remove_fb(struct drm_framebuffer *fb)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_device *dev = fb->dev;\n\tstruct drm_atomic_state *state;\n\tstruct drm_plane *plane;\n\tstruct drm_connector *conn __maybe_unused;\n\tstruct drm_connector_state *conn_state;\n\tint i, ret;\n\tunsigned plane_mask;\n\tbool disable_crtcs = false;\n\nretry_disable:\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tstate->acquire_ctx = &ctx;\n\nretry:\n\tplane_mask = 0;\n\tret = drm_modeset_lock_all_ctx(dev, &ctx);\n\tif (ret)\n\t\tgoto unlock;\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tif (plane->state->fb != fb)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(dev,\n\t\t\t    \"Disabling [PLANE:%d:%s] because [FB:%d] is removed\\n\",\n\t\t\t    plane->base.id, plane->name, fb->base.id);\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\tret = PTR_ERR(plane_state);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (disable_crtcs && plane_state->crtc->primary == plane) {\n\t\t\tstruct drm_crtc_state *crtc_state;\n\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"Disabling [CRTC:%d:%s] because [FB:%d] is removed\\n\",\n\t\t\t\t    plane_state->crtc->base.id,\n\t\t\t\t    plane_state->crtc->name, fb->base.id);\n\n\t\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state, plane_state->crtc);\n\n\t\t\tret = drm_atomic_add_affected_connectors(state, plane_state->crtc);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\n\t\t\tcrtc_state->active = false;\n\t\t\tret = drm_atomic_set_mode_for_crtc(crtc_state, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\t\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tplane_mask |= drm_plane_mask(plane);\n\t}\n\n\t \n\tfor_each_new_connector_in_state(state, conn, conn_state, i) {\n\t\tret = drm_atomic_set_crtc_for_connector(conn_state, NULL);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tif (plane_mask)\n\t\tret = drm_atomic_commit(state);\n\nunlock:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\nout:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tif (ret == -EINVAL && !disable_crtcs) {\n\t\tdisable_crtcs = true;\n\t\tgoto retry_disable;\n\t}\n\n\treturn ret;\n}\n\nstatic void legacy_remove_fb(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev = fb->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane *plane;\n\n\tdrm_modeset_lock_all(dev);\n\t \n\tdrm_for_each_crtc(crtc, dev) {\n\t\tif (crtc->primary->fb == fb) {\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"Disabling [CRTC:%d:%s] because [FB:%d] is removed\\n\",\n\t\t\t\t    crtc->base.id, crtc->name, fb->base.id);\n\n\t\t\t \n\t\t\tif (drm_crtc_force_disable(crtc))\n\t\t\t\tDRM_ERROR(\"failed to reset crtc %p when fb was deleted\\n\", crtc);\n\t\t}\n\t}\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tif (plane->fb == fb) {\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"Disabling [PLANE:%d:%s] because [FB:%d] is removed\\n\",\n\t\t\t\t    plane->base.id, plane->name, fb->base.id);\n\t\t\tdrm_plane_force_disable(plane);\n\t\t}\n\t}\n\tdrm_modeset_unlock_all(dev);\n}\n\n \nvoid drm_framebuffer_remove(struct drm_framebuffer *fb)\n{\n\tstruct drm_device *dev;\n\n\tif (!fb)\n\t\treturn;\n\n\tdev = fb->dev;\n\n\tWARN_ON(!list_empty(&fb->filp_head));\n\n\t \n\tif (drm_framebuffer_read_refcount(fb) > 1) {\n\t\tif (drm_drv_uses_atomic_modeset(dev)) {\n\t\t\tint ret = atomic_remove_fb(fb);\n\n\t\t\tWARN(ret, \"atomic remove_fb failed with %i\\n\", ret);\n\t\t} else\n\t\t\tlegacy_remove_fb(fb);\n\t}\n\n\tdrm_framebuffer_put(fb);\n}\nEXPORT_SYMBOL(drm_framebuffer_remove);\n\n \nint drm_framebuffer_plane_width(int width,\n\t\t\t\tconst struct drm_framebuffer *fb, int plane)\n{\n\tif (plane >= fb->format->num_planes)\n\t\treturn 0;\n\n\treturn fb_plane_width(width, fb->format, plane);\n}\nEXPORT_SYMBOL(drm_framebuffer_plane_width);\n\n \nint drm_framebuffer_plane_height(int height,\n\t\t\t\t const struct drm_framebuffer *fb, int plane)\n{\n\tif (plane >= fb->format->num_planes)\n\t\treturn 0;\n\n\treturn fb_plane_height(height, fb->format, plane);\n}\nEXPORT_SYMBOL(drm_framebuffer_plane_height);\n\nvoid drm_framebuffer_print_info(struct drm_printer *p, unsigned int indent,\n\t\t\t\tconst struct drm_framebuffer *fb)\n{\n\tunsigned int i;\n\n\tdrm_printf_indent(p, indent, \"allocated by = %s\\n\", fb->comm);\n\tdrm_printf_indent(p, indent, \"refcount=%u\\n\",\n\t\t\t  drm_framebuffer_read_refcount(fb));\n\tdrm_printf_indent(p, indent, \"format=%p4cc\\n\", &fb->format->format);\n\tdrm_printf_indent(p, indent, \"modifier=0x%llx\\n\", fb->modifier);\n\tdrm_printf_indent(p, indent, \"size=%ux%u\\n\", fb->width, fb->height);\n\tdrm_printf_indent(p, indent, \"layers:\\n\");\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tdrm_printf_indent(p, indent + 1, \"size[%u]=%dx%d\\n\", i,\n\t\t\t\t  drm_framebuffer_plane_width(fb->width, fb, i),\n\t\t\t\t  drm_framebuffer_plane_height(fb->height, fb, i));\n\t\tdrm_printf_indent(p, indent + 1, \"pitch[%u]=%u\\n\", i, fb->pitches[i]);\n\t\tdrm_printf_indent(p, indent + 1, \"offset[%u]=%u\\n\", i, fb->offsets[i]);\n\t\tdrm_printf_indent(p, indent + 1, \"obj[%u]:%s\\n\", i,\n\t\t\t\t  fb->obj[i] ? \"\" : \"(null)\");\n\t\tif (fb->obj[i])\n\t\t\tdrm_gem_print_info(p, indent + 2, fb->obj[i]);\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int drm_framebuffer_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct drm_framebuffer *fb;\n\n\tmutex_lock(&dev->mode_config.fb_lock);\n\tdrm_for_each_fb(fb, dev) {\n\t\tdrm_printf(&p, \"framebuffer[%u]:\\n\", fb->base.id);\n\t\tdrm_framebuffer_print_info(&p, 1, fb);\n\t}\n\tmutex_unlock(&dev->mode_config.fb_lock);\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info drm_framebuffer_debugfs_list[] = {\n\t{ \"framebuffer\", drm_framebuffer_info, 0 },\n};\n\nvoid drm_framebuffer_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_framebuffer_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_framebuffer_debugfs_list));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}