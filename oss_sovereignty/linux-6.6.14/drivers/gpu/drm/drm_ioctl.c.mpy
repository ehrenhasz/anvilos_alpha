{
  "module_name": "drm_ioctl.c",
  "hash_id": "7345f0f2eb46553b5a1fff3d259604af094214895b141e6cb5ddf039b616acd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_ioctl.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/nospec.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_auth.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\n \n\n \nint drm_getunique(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_unique *u = data;\n\tstruct drm_master *master;\n\n\tmutex_lock(&dev->master_mutex);\n\tmaster = file_priv->master;\n\tif (u->unique_len >= master->unique_len) {\n\t\tif (copy_to_user(u->unique, master->unique, master->unique_len)) {\n\t\t\tmutex_unlock(&dev->master_mutex);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tu->unique_len = master->unique_len;\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn 0;\n}\n\nstatic void\ndrm_unset_busid(struct drm_device *dev,\n\t\tstruct drm_master *master)\n{\n\tkfree(master->unique);\n\tmaster->unique = NULL;\n\tmaster->unique_len = 0;\n}\n\nstatic int drm_set_busid(struct drm_device *dev, struct drm_file *file_priv)\n{\n\tstruct drm_master *master = file_priv->master;\n\tint ret;\n\n\tif (master->unique != NULL)\n\t\tdrm_unset_busid(dev, master);\n\n\tif (dev->dev && dev_is_pci(dev->dev)) {\n\t\tret = drm_pci_set_busid(dev, master);\n\t\tif (ret) {\n\t\t\tdrm_unset_busid(dev, master);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tWARN_ON(!dev->unique);\n\t\tmaster->unique = kstrdup(dev->unique, GFP_KERNEL);\n\t\tif (master->unique)\n\t\t\tmaster->unique_len = strlen(dev->unique);\n\t}\n\n\treturn 0;\n}\n\n \nint drm_getclient(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_client *client = data;\n\n\t \n\tif (client->idx == 0) {\n\t\tclient->auth = file_priv->authenticated;\n\t\tclient->pid = task_pid_vnr(current);\n\t\tclient->uid = overflowuid;\n\t\tclient->magic = 0;\n\t\tclient->iocs = 0;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int drm_getstats(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_stats *stats = data;\n\n\t \n\tmemset(stats, 0, sizeof(*stats));\n\n\treturn 0;\n}\n\n \nstatic int drm_getcap(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct drm_get_cap *req = data;\n\tstruct drm_crtc *crtc;\n\n\treq->value = 0;\n\n\t \n\tswitch (req->capability) {\n\tcase DRM_CAP_TIMESTAMP_MONOTONIC:\n\t\treq->value = 1;\n\t\treturn 0;\n\tcase DRM_CAP_PRIME:\n\t\treq->value = DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT;\n\t\treturn 0;\n\tcase DRM_CAP_SYNCOBJ:\n\t\treq->value = drm_core_check_feature(dev, DRIVER_SYNCOBJ);\n\t\treturn 0;\n\tcase DRM_CAP_SYNCOBJ_TIMELINE:\n\t\treq->value = drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (req->capability) {\n\tcase DRM_CAP_DUMB_BUFFER:\n\t\tif (dev->driver->dumb_create)\n\t\t\treq->value = 1;\n\t\tbreak;\n\tcase DRM_CAP_VBLANK_HIGH_CRTC:\n\t\treq->value = 1;\n\t\tbreak;\n\tcase DRM_CAP_DUMB_PREFERRED_DEPTH:\n\t\treq->value = dev->mode_config.preferred_depth;\n\t\tbreak;\n\tcase DRM_CAP_DUMB_PREFER_SHADOW:\n\t\treq->value = dev->mode_config.prefer_shadow;\n\t\tbreak;\n\tcase DRM_CAP_ASYNC_PAGE_FLIP:\n\t\treq->value = dev->mode_config.async_page_flip;\n\t\tbreak;\n\tcase DRM_CAP_PAGE_FLIP_TARGET:\n\t\treq->value = 1;\n\t\tdrm_for_each_crtc(crtc, dev) {\n\t\t\tif (!crtc->funcs->page_flip_target)\n\t\t\t\treq->value = 0;\n\t\t}\n\t\tbreak;\n\tcase DRM_CAP_CURSOR_WIDTH:\n\t\tif (dev->mode_config.cursor_width)\n\t\t\treq->value = dev->mode_config.cursor_width;\n\t\telse\n\t\t\treq->value = 64;\n\t\tbreak;\n\tcase DRM_CAP_CURSOR_HEIGHT:\n\t\tif (dev->mode_config.cursor_height)\n\t\t\treq->value = dev->mode_config.cursor_height;\n\t\telse\n\t\t\treq->value = 64;\n\t\tbreak;\n\tcase DRM_CAP_ADDFB2_MODIFIERS:\n\t\treq->value = !dev->mode_config.fb_modifiers_not_supported;\n\t\tbreak;\n\tcase DRM_CAP_CRTC_IN_VBLANK_EVENT:\n\t\treq->value = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ndrm_setclientcap(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct drm_set_client_cap *req = data;\n\n\t \n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (req->capability) {\n\tcase DRM_CLIENT_CAP_STEREO_3D:\n\t\tif (req->value > 1)\n\t\t\treturn -EINVAL;\n\t\tfile_priv->stereo_allowed = req->value;\n\t\tbreak;\n\tcase DRM_CLIENT_CAP_UNIVERSAL_PLANES:\n\t\tif (req->value > 1)\n\t\t\treturn -EINVAL;\n\t\tfile_priv->universal_planes = req->value;\n\t\tbreak;\n\tcase DRM_CLIENT_CAP_ATOMIC:\n\t\tif (!drm_core_check_feature(dev, DRIVER_ATOMIC))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tif (current->comm[0] == 'X' && req->value == 1) {\n\t\t\tpr_info(\"broken atomic modeset userspace detected, disabling atomic\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (req->value > 2)\n\t\t\treturn -EINVAL;\n\t\tfile_priv->atomic = req->value;\n\t\tfile_priv->universal_planes = req->value;\n\t\t \n\t\tfile_priv->aspect_ratio_allowed = req->value;\n\t\tbreak;\n\tcase DRM_CLIENT_CAP_ASPECT_RATIO:\n\t\tif (req->value > 1)\n\t\t\treturn -EINVAL;\n\t\tfile_priv->aspect_ratio_allowed = req->value;\n\t\tbreak;\n\tcase DRM_CLIENT_CAP_WRITEBACK_CONNECTORS:\n\t\tif (!file_priv->atomic)\n\t\t\treturn -EINVAL;\n\t\tif (req->value > 1)\n\t\t\treturn -EINVAL;\n\t\tfile_priv->writeback_connectors = req->value;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drm_setversion(struct drm_device *dev, void *data, struct drm_file *file_priv)\n{\n\tstruct drm_set_version *sv = data;\n\tint if_version, retcode = 0;\n\n\tmutex_lock(&dev->master_mutex);\n\tif (sv->drm_di_major != -1) {\n\t\tif (sv->drm_di_major != DRM_IF_MAJOR ||\n\t\t    sv->drm_di_minor < 0 || sv->drm_di_minor > DRM_IF_MINOR) {\n\t\t\tretcode = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tif_version = DRM_IF_VERSION(sv->drm_di_major,\n\t\t\t\t\t    sv->drm_di_minor);\n\t\tdev->if_version = max(if_version, dev->if_version);\n\t\tif (sv->drm_di_minor >= 1) {\n\t\t\t \n\t\t\tretcode = drm_set_busid(dev, file_priv);\n\t\t\tif (retcode)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (sv->drm_dd_major != -1) {\n\t\tif (sv->drm_dd_major != dev->driver->major ||\n\t\t    sv->drm_dd_minor < 0 || sv->drm_dd_minor >\n\t\t    dev->driver->minor) {\n\t\t\tretcode = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tsv->drm_di_major = DRM_IF_MAJOR;\n\tsv->drm_di_minor = DRM_IF_MINOR;\n\tsv->drm_dd_major = dev->driver->major;\n\tsv->drm_dd_minor = dev->driver->minor;\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn retcode;\n}\n\n \nint drm_noop(struct drm_device *dev, void *data,\n\t     struct drm_file *file_priv)\n{\n\tdrm_dbg_core(dev, \"\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_noop);\n\n \nint drm_invalid_op(struct drm_device *dev, void *data,\n\t\t   struct drm_file *file_priv)\n{\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_invalid_op);\n\n \nstatic int drm_copy_field(char __user *buf, size_t *buf_len, const char *value)\n{\n\tsize_t len;\n\n\t \n\tif (WARN_ONCE(!value, \"BUG: the value to copy was not set!\")) {\n\t\t*buf_len = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tlen = strlen(value);\n\tif (len > *buf_len)\n\t\tlen = *buf_len;\n\n\t \n\t*buf_len = strlen(value);\n\n\t \n\tif (len && buf)\n\t\tif (copy_to_user(buf, value, len))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nint drm_version(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tstruct drm_version *version = data;\n\tint err;\n\n\tversion->version_major = dev->driver->major;\n\tversion->version_minor = dev->driver->minor;\n\tversion->version_patchlevel = dev->driver->patchlevel;\n\terr = drm_copy_field(version->name, &version->name_len,\n\t\t\tdev->driver->name);\n\tif (!err)\n\t\terr = drm_copy_field(version->date, &version->date_len,\n\t\t\t\tdev->driver->date);\n\tif (!err)\n\t\terr = drm_copy_field(version->desc, &version->desc_len,\n\t\t\t\tdev->driver->desc);\n\n\treturn err;\n}\n\nstatic int drm_ioctl_permit(u32 flags, struct drm_file *file_priv)\n{\n\t \n\tif (unlikely((flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EACCES;\n\n\t \n\tif (unlikely((flags & DRM_AUTH) && !drm_is_render_client(file_priv) &&\n\t\t     !file_priv->authenticated))\n\t\treturn -EACCES;\n\n\t \n\tif (unlikely((flags & DRM_MASTER) &&\n\t\t     !drm_is_current_master(file_priv)))\n\t\treturn -EACCES;\n\n\t \n\tif (unlikely(!(flags & DRM_RENDER_ALLOW) &&\n\t\t     drm_is_render_client(file_priv)))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n#define DRM_IOCTL_DEF(ioctl, _func, _flags)\t\\\n\t[DRM_IOCTL_NR(ioctl)] = {\t\t\\\n\t\t.cmd = ioctl,\t\t\t\\\n\t\t.func = _func,\t\t\t\\\n\t\t.flags = _flags,\t\t\\\n\t\t.name = #ioctl\t\t\t\\\n\t}\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n#define DRM_LEGACY_IOCTL_DEF(ioctl, _func, _flags)  DRM_IOCTL_DEF(ioctl, _func, _flags)\n#else\n#define DRM_LEGACY_IOCTL_DEF(ioctl, _func, _flags) DRM_IOCTL_DEF(ioctl, drm_invalid_op, _flags)\n#endif\n\n \nstatic const struct drm_ioctl_desc drm_ioctls[] = {\n\tDRM_IOCTL_DEF(DRM_IOCTL_VERSION, drm_version, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GET_UNIQUE, drm_getunique, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GET_MAGIC, drm_getmagic, 0),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_IRQ_BUSID, drm_legacy_irq_by_busid,\n\t\t\t     DRM_MASTER|DRM_ROOT_ONLY),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_GET_MAP, drm_legacy_getmap_ioctl, 0),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_GET_CLIENT, drm_getclient, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GET_STATS, drm_getstats, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GET_CAP, drm_getcap, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SET_CLIENT_CAP, drm_setclientcap, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SET_VERSION, drm_setversion, DRM_MASTER),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_SET_UNIQUE, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF(DRM_IOCTL_BLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF(DRM_IOCTL_UNBLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF(DRM_IOCTL_AUTH_MAGIC, drm_authmagic, DRM_MASTER),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_ADD_MAP, drm_legacy_addmap_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_RM_MAP, drm_legacy_rmmap_ioctl, DRM_AUTH),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_legacy_setsareactx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_GET_SAREA_CTX, drm_legacy_getsareactx, DRM_AUTH),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_SET_MASTER, drm_setmaster_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_DROP_MASTER, drm_dropmaster_ioctl, 0),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_ADD_CTX, drm_legacy_addctx, DRM_AUTH|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_RM_CTX, drm_legacy_rmctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_GET_CTX, drm_legacy_getctx, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_legacy_switchctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_legacy_newctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_RES_CTX, drm_legacy_resctx, DRM_AUTH),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_ADD_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF(DRM_IOCTL_RM_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_LOCK, drm_legacy_lock, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_UNLOCK, drm_legacy_unlock, DRM_AUTH),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_FINISH, drm_noop, DRM_AUTH),\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_ADD_BUFS, drm_legacy_addbufs, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_MARK_BUFS, drm_legacy_markbufs, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_INFO_BUFS, drm_legacy_infobufs, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_MAP_BUFS, drm_legacy_mapbufs, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_FREE_BUFS, drm_legacy_freebufs, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_DMA, drm_legacy_dma_ioctl, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_CONTROL, drm_legacy_irq_control, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\n#if IS_ENABLED(CONFIG_AGP)\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_ACQUIRE, drm_legacy_agp_acquire_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_RELEASE, drm_legacy_agp_release_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_ENABLE, drm_legacy_agp_enable_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_INFO, drm_legacy_agp_info_ioctl, DRM_AUTH),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_ALLOC, drm_legacy_agp_alloc_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_FREE, drm_legacy_agp_free_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_BIND, drm_legacy_agp_bind_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_AGP_UNBIND, drm_legacy_agp_unbind_ioctl,\n\t\t\t     DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n#endif\n\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_SG_ALLOC, drm_legacy_sg_alloc, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_LEGACY_IOCTL_DEF(DRM_IOCTL_SG_FREE, drm_legacy_sg_free, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_WAIT_VBLANK, drm_wait_vblank_ioctl, DRM_UNLOCKED),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODESET_CTL, drm_legacy_modeset_ctl_ioctl, 0),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_UPDATE_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_GEM_CLOSE, drm_gem_close_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GEM_FLINK, drm_gem_flink_ioctl, DRM_AUTH),\n\tDRM_IOCTL_DEF(DRM_IOCTL_GEM_OPEN, drm_gem_open_ioctl, DRM_AUTH),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETRESOURCES, drm_mode_getresources, 0),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_PRIME_HANDLE_TO_FD, drm_prime_handle_to_fd_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_PRIME_FD_TO_HANDLE, drm_prime_fd_to_handle_ioctl, DRM_RENDER_ALLOW),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPLANERESOURCES, drm_mode_getplane_res, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETCRTC, drm_mode_getcrtc, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_SETCRTC, drm_mode_setcrtc, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPLANE, drm_mode_getplane, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_SETPLANE, drm_mode_setplane, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR, drm_mode_cursor_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETGAMMA, drm_mode_gamma_get_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_SETGAMMA, drm_mode_gamma_set_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETENCODER, drm_mode_getencoder, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETCONNECTOR, drm_mode_getconnector, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_ATTACHMODE, drm_noop, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_DETACHMODE, drm_noop, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPERTY, drm_mode_getproperty_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_SETPROPERTY, drm_connector_property_set_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPBLOB, drm_mode_getblob_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETFB, drm_mode_getfb, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GETFB2, drm_mode_getfb2_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_ADDFB, drm_mode_addfb_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_ADDFB2, drm_mode_addfb2_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_RMFB, drm_mode_rmfb_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_PAGE_FLIP, drm_mode_page_flip_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_DIRTYFB, drm_mode_dirtyfb_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_GETPROPERTIES, drm_mode_obj_get_properties_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_SETPROPERTY, drm_mode_obj_set_property_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR2, drm_mode_cursor2_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_ATOMIC, drm_mode_atomic_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATEPROPBLOB, drm_mode_createblob_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROYPROPBLOB, drm_mode_destroyblob_ioctl, 0),\n\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_CREATE, drm_syncobj_create_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_DESTROY, drm_syncobj_destroy_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD, drm_syncobj_handle_to_fd_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE, drm_syncobj_fd_to_handle_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_TRANSFER, drm_syncobj_transfer_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_WAIT, drm_syncobj_wait_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT, drm_syncobj_timeline_wait_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_EVENTFD, drm_syncobj_eventfd_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_RESET, drm_syncobj_reset_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_SIGNAL, drm_syncobj_signal_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_TIMELINE_SIGNAL, drm_syncobj_timeline_signal_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_SYNCOBJ_QUERY, drm_syncobj_query_ioctl,\n\t\t      DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF(DRM_IOCTL_CRTC_GET_SEQUENCE, drm_crtc_get_sequence_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_CRTC_QUEUE_SEQUENCE, drm_crtc_queue_sequence_ioctl, 0),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_LEASE, drm_mode_create_lease_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_LIST_LESSEES, drm_mode_list_lessees_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_GET_LEASE, drm_mode_get_lease_ioctl, DRM_MASTER),\n\tDRM_IOCTL_DEF(DRM_IOCTL_MODE_REVOKE_LEASE, drm_mode_revoke_lease_ioctl, DRM_MASTER),\n};\n\n#define DRM_CORE_IOCTL_COUNT\tARRAY_SIZE(drm_ioctls)\n\n \n\nlong drm_ioctl_kernel(struct file *file, drm_ioctl_t *func, void *kdata,\n\t\t      u32 flags)\n{\n\tstruct drm_file *file_priv = file->private_data;\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tint retcode;\n\n\t \n\tdrm_file_update_pid(file_priv);\n\n\tif (drm_dev_is_unplugged(dev))\n\t\treturn -ENODEV;\n\n\tretcode = drm_ioctl_permit(flags, file_priv);\n\tif (unlikely(retcode))\n\t\treturn retcode;\n\n\t \n\tif (likely(!drm_core_check_feature(dev, DRIVER_LEGACY)) ||\n\t    (flags & DRM_UNLOCKED))\n\t\tretcode = func(dev, kdata, file_priv);\n\telse {\n\t\tmutex_lock(&drm_global_mutex);\n\t\tretcode = func(dev, kdata, file_priv);\n\t\tmutex_unlock(&drm_global_mutex);\n\t}\n\treturn retcode;\n}\nEXPORT_SYMBOL(drm_ioctl_kernel);\n\n \nlong drm_ioctl(struct file *filp,\n\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tconst struct drm_ioctl_desc *ioctl = NULL;\n\tdrm_ioctl_t *func;\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\tint retcode = -EINVAL;\n\tchar stack_kdata[128];\n\tchar *kdata = NULL;\n\tunsigned int in_size, out_size, drv_size, ksize;\n\tbool is_driver_ioctl;\n\n\tdev = file_priv->minor->dev;\n\n\tif (drm_dev_is_unplugged(dev))\n\t\treturn -ENODEV;\n\n\tif (DRM_IOCTL_TYPE(cmd) != DRM_IOCTL_BASE)\n\t\treturn -ENOTTY;\n\n\tis_driver_ioctl = nr >= DRM_COMMAND_BASE && nr < DRM_COMMAND_END;\n\n\tif (is_driver_ioctl) {\n\t\t \n\t\tunsigned int index = nr - DRM_COMMAND_BASE;\n\n\t\tif (index >= dev->driver->num_ioctls)\n\t\t\tgoto err_i1;\n\t\tindex = array_index_nospec(index, dev->driver->num_ioctls);\n\t\tioctl = &dev->driver->ioctls[index];\n\t} else {\n\t\t \n\t\tif (nr >= DRM_CORE_IOCTL_COUNT)\n\t\t\tgoto err_i1;\n\t\tnr = array_index_nospec(nr, DRM_CORE_IOCTL_COUNT);\n\t\tioctl = &drm_ioctls[nr];\n\t}\n\n\tdrv_size = _IOC_SIZE(ioctl->cmd);\n\tout_size = in_size = _IOC_SIZE(cmd);\n\tif ((cmd & ioctl->cmd & IOC_IN) == 0)\n\t\tin_size = 0;\n\tif ((cmd & ioctl->cmd & IOC_OUT) == 0)\n\t\tout_size = 0;\n\tksize = max(max(in_size, out_size), drv_size);\n\n\tdrm_dbg_core(dev, \"comm=\\\"%s\\\" pid=%d, dev=0x%lx, auth=%d, %s\\n\",\n\t\t     current->comm, task_pid_nr(current),\n\t\t     (long)old_encode_dev(file_priv->minor->kdev->devt),\n\t\t     file_priv->authenticated, ioctl->name);\n\n\t \n\tfunc = ioctl->func;\n\n\tif (unlikely(!func)) {\n\t\tdrm_dbg_core(dev, \"no function\\n\");\n\t\tretcode = -EINVAL;\n\t\tgoto err_i1;\n\t}\n\n\tif (ksize <= sizeof(stack_kdata)) {\n\t\tkdata = stack_kdata;\n\t} else {\n\t\tkdata = kmalloc(ksize, GFP_KERNEL);\n\t\tif (!kdata) {\n\t\t\tretcode = -ENOMEM;\n\t\t\tgoto err_i1;\n\t\t}\n\t}\n\n\tif (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {\n\t\tretcode = -EFAULT;\n\t\tgoto err_i1;\n\t}\n\n\tif (ksize > in_size)\n\t\tmemset(kdata + in_size, 0, ksize - in_size);\n\n\tretcode = drm_ioctl_kernel(filp, func, kdata, ioctl->flags);\n\tif (copy_to_user((void __user *)arg, kdata, out_size) != 0)\n\t\tretcode = -EFAULT;\n\n      err_i1:\n\tif (!ioctl)\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"invalid ioctl: comm=\\\"%s\\\", pid=%d, dev=0x%lx, auth=%d, cmd=0x%02x, nr=0x%02x\\n\",\n\t\t\t     current->comm, task_pid_nr(current),\n\t\t\t     (long)old_encode_dev(file_priv->minor->kdev->devt),\n\t\t\t     file_priv->authenticated, cmd, nr);\n\n\tif (kdata != stack_kdata)\n\t\tkfree(kdata);\n\tif (retcode)\n\t\tdrm_dbg_core(dev, \"comm=\\\"%s\\\", pid=%d, ret=%d\\n\",\n\t\t\t     current->comm, task_pid_nr(current), retcode);\n\treturn retcode;\n}\nEXPORT_SYMBOL(drm_ioctl);\n\n \nbool drm_ioctl_flags(unsigned int nr, unsigned int *flags)\n{\n\tif (nr >= DRM_COMMAND_BASE && nr < DRM_COMMAND_END)\n\t\treturn false;\n\n\tif (nr >= DRM_CORE_IOCTL_COUNT)\n\t\treturn false;\n\tnr = array_index_nospec(nr, DRM_CORE_IOCTL_COUNT);\n\n\t*flags = drm_ioctls[nr].flags;\n\treturn true;\n}\nEXPORT_SYMBOL(drm_ioctl_flags);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}