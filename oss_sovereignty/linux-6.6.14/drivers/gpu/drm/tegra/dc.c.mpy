{
  "module_name": "dc.c",
  "hash_id": "4181716bb55d12a8d789996f746a758d2df3493658a6e6f6a818f2e7f1119bbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/dc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/iommu.h>\n#include <linux/interconnect.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/pmc.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n\n#include \"dc.h\"\n#include \"drm.h\"\n#include \"gem.h\"\n#include \"hub.h\"\n#include \"plane.h\"\n\nstatic void tegra_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_crtc_state *state);\n\nstatic void tegra_dc_stats_reset(struct tegra_dc_stats *stats)\n{\n\tstats->frames = 0;\n\tstats->vblank = 0;\n\tstats->underflow = 0;\n\tstats->overflow = 0;\n}\n\n \nstatic u32 tegra_dc_readl_active(struct tegra_dc *dc, unsigned long offset)\n{\n\tu32 value;\n\n\ttegra_dc_writel(dc, READ_MUX, DC_CMD_STATE_ACCESS);\n\tvalue = tegra_dc_readl(dc, offset);\n\ttegra_dc_writel(dc, 0, DC_CMD_STATE_ACCESS);\n\n\treturn value;\n}\n\nstatic inline unsigned int tegra_plane_offset(struct tegra_plane *plane,\n\t\t\t\t\t      unsigned int offset)\n{\n\tif (offset >= 0x500 && offset <= 0x638) {\n\t\toffset = 0x000 + (offset - 0x500);\n\t\treturn plane->offset + offset;\n\t}\n\n\tif (offset >= 0x700 && offset <= 0x719) {\n\t\toffset = 0x180 + (offset - 0x700);\n\t\treturn plane->offset + offset;\n\t}\n\n\tif (offset >= 0x800 && offset <= 0x839) {\n\t\toffset = 0x1c0 + (offset - 0x800);\n\t\treturn plane->offset + offset;\n\t}\n\n\tdev_WARN(plane->dc->dev, \"invalid offset: %x\\n\", offset);\n\n\treturn plane->offset + offset;\n}\n\nstatic inline u32 tegra_plane_readl(struct tegra_plane *plane,\n\t\t\t\t    unsigned int offset)\n{\n\treturn tegra_dc_readl(plane->dc, tegra_plane_offset(plane, offset));\n}\n\nstatic inline void tegra_plane_writel(struct tegra_plane *plane, u32 value,\n\t\t\t\t      unsigned int offset)\n{\n\ttegra_dc_writel(plane->dc, value, tegra_plane_offset(plane, offset));\n}\n\nbool tegra_dc_has_output(struct tegra_dc *dc, struct device *dev)\n{\n\tstruct device_node *np = dc->dev->of_node;\n\tstruct of_phandle_iterator it;\n\tint err;\n\n\tof_for_each_phandle(&it, err, np, \"nvidia,outputs\", NULL, 0)\n\t\tif (it.node == dev->of_node)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nvoid tegra_dc_commit(struct tegra_dc *dc)\n{\n\ttegra_dc_writel(dc, GENERAL_ACT_REQ << 8, DC_CMD_STATE_CONTROL);\n\ttegra_dc_writel(dc, GENERAL_ACT_REQ, DC_CMD_STATE_CONTROL);\n}\n\nstatic inline u32 compute_dda_inc(unsigned int in, unsigned int out, bool v,\n\t\t\t\t  unsigned int bpp)\n{\n\tfixed20_12 outf = dfixed_init(out);\n\tfixed20_12 inf = dfixed_init(in);\n\tu32 dda_inc;\n\tint max;\n\n\tif (v)\n\t\tmax = 15;\n\telse {\n\t\tswitch (bpp) {\n\t\tcase 2:\n\t\t\tmax = 8;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tmax = 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toutf.full = max_t(u32, outf.full - dfixed_const(1), dfixed_const(1));\n\tinf.full -= dfixed_const(1);\n\n\tdda_inc = dfixed_div(inf, outf);\n\tdda_inc = min_t(u32, dda_inc, dfixed_const(max));\n\n\treturn dda_inc;\n}\n\nstatic inline u32 compute_initial_dda(unsigned int in)\n{\n\tfixed20_12 inf = dfixed_init(in);\n\treturn dfixed_frac(inf);\n}\n\nstatic void tegra_plane_setup_blending_legacy(struct tegra_plane *plane)\n{\n\tu32 background[3] = {\n\t\tBLEND_WEIGHT1(0) | BLEND_WEIGHT0(0) | BLEND_COLOR_KEY_NONE,\n\t\tBLEND_WEIGHT1(0) | BLEND_WEIGHT0(0) | BLEND_COLOR_KEY_NONE,\n\t\tBLEND_WEIGHT1(0) | BLEND_WEIGHT0(0) | BLEND_COLOR_KEY_NONE,\n\t};\n\tu32 foreground = BLEND_WEIGHT1(255) | BLEND_WEIGHT0(255) |\n\t\t\t BLEND_COLOR_KEY_NONE;\n\tu32 blendnokey = BLEND_WEIGHT1(255) | BLEND_WEIGHT0(255);\n\tstruct tegra_plane_state *state;\n\tu32 blending[2];\n\tunsigned int i;\n\n\t \n\ttegra_plane_writel(plane, blendnokey, DC_WIN_BLEND_NOKEY);\n\ttegra_plane_writel(plane, foreground, DC_WIN_BLEND_1WIN);\n\n\tstate = to_tegra_plane_state(plane->base.state);\n\n\tif (state->opaque) {\n\t\t \n\t\tbackground[0] |= BLEND_CONTROL_DEPENDENT;\n\t\tbackground[1] |= BLEND_CONTROL_DEPENDENT;\n\n\t\t \n\t\tswitch (state->base.normalized_zpos) {\n\t\tcase 0:\n\t\t\tif (state->blending[0].alpha &&\n\t\t\t    state->blending[1].alpha)\n\t\t\t\tbackground[2] |= BLEND_CONTROL_DEPENDENT;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tbackground[2] |= BLEND_CONTROL_DEPENDENT;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tforeground |= BLEND_CONTROL_ALPHA;\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tif (state->blending[i].alpha &&\n\t\t\t    state->blending[i].top)\n\t\t\t\tbackground[i] |= BLEND_CONTROL_DEPENDENT;\n\t\t}\n\n\t\tswitch (state->base.normalized_zpos) {\n\t\tcase 0:\n\t\t\tif (state->blending[0].alpha &&\n\t\t\t    state->blending[1].alpha)\n\t\t\t\tbackground[2] |= BLEND_CONTROL_DEPENDENT;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tif (state->blending[0].alpha &&\n\t\t\t    state->blending[0].top)\n\t\t\t\tbackground[2] |= BLEND_CONTROL_ALPHA;\n\n\t\t\tif (state->blending[1].alpha &&\n\t\t\t    state->blending[1].top)\n\t\t\t\tbackground[2] |= BLEND_CONTROL_ALPHA;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (state->base.normalized_zpos) {\n\tcase 0:\n\t\ttegra_plane_writel(plane, background[0], DC_WIN_BLEND_2WIN_X);\n\t\ttegra_plane_writel(plane, background[1], DC_WIN_BLEND_2WIN_Y);\n\t\ttegra_plane_writel(plane, background[2], DC_WIN_BLEND_3WIN_XY);\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tif (!state->blending[0].top && state->blending[1].top) {\n\t\t\tblending[0] = foreground;\n\t\t\tblending[1] = background[1];\n\t\t} else {\n\t\t\tblending[0] = background[0];\n\t\t\tblending[1] = foreground;\n\t\t}\n\n\t\ttegra_plane_writel(plane, blending[0], DC_WIN_BLEND_2WIN_X);\n\t\ttegra_plane_writel(plane, blending[1], DC_WIN_BLEND_2WIN_Y);\n\t\ttegra_plane_writel(plane, background[2], DC_WIN_BLEND_3WIN_XY);\n\t\tbreak;\n\n\tcase 2:\n\t\ttegra_plane_writel(plane, foreground, DC_WIN_BLEND_2WIN_X);\n\t\ttegra_plane_writel(plane, foreground, DC_WIN_BLEND_2WIN_Y);\n\t\ttegra_plane_writel(plane, foreground, DC_WIN_BLEND_3WIN_XY);\n\t\tbreak;\n\t}\n}\n\nstatic void tegra_plane_setup_blending(struct tegra_plane *plane,\n\t\t\t\t       const struct tegra_dc_window *window)\n{\n\tu32 value;\n\n\tvalue = BLEND_FACTOR_DST_ALPHA_ZERO | BLEND_FACTOR_SRC_ALPHA_K2 |\n\t\tBLEND_FACTOR_DST_COLOR_NEG_K1_TIMES_SRC |\n\t\tBLEND_FACTOR_SRC_COLOR_K1_TIMES_SRC;\n\ttegra_plane_writel(plane, value, DC_WIN_BLEND_MATCH_SELECT);\n\n\tvalue = BLEND_FACTOR_DST_ALPHA_ZERO | BLEND_FACTOR_SRC_ALPHA_K2 |\n\t\tBLEND_FACTOR_DST_COLOR_NEG_K1_TIMES_SRC |\n\t\tBLEND_FACTOR_SRC_COLOR_K1_TIMES_SRC;\n\ttegra_plane_writel(plane, value, DC_WIN_BLEND_NOMATCH_SELECT);\n\n\tvalue = K2(255) | K1(255) | WINDOW_LAYER_DEPTH(255 - window->zpos);\n\ttegra_plane_writel(plane, value, DC_WIN_BLEND_LAYER_CONTROL);\n}\n\nstatic bool\ntegra_plane_use_horizontal_filtering(struct tegra_plane *plane,\n\t\t\t\t     const struct tegra_dc_window *window)\n{\n\tstruct tegra_dc *dc = plane->dc;\n\n\tif (window->src.w == window->dst.w)\n\t\treturn false;\n\n\tif (plane->index == 0 && dc->soc->has_win_a_without_filters)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\ntegra_plane_use_vertical_filtering(struct tegra_plane *plane,\n\t\t\t\t   const struct tegra_dc_window *window)\n{\n\tstruct tegra_dc *dc = plane->dc;\n\n\tif (window->src.h == window->dst.h)\n\t\treturn false;\n\n\tif (plane->index == 0 && dc->soc->has_win_a_without_filters)\n\t\treturn false;\n\n\tif (plane->index == 2 && dc->soc->has_win_c_without_vert_filter)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void tegra_dc_setup_window(struct tegra_plane *plane,\n\t\t\t\t  const struct tegra_dc_window *window)\n{\n\tunsigned h_offset, v_offset, h_size, v_size, h_dda, v_dda, bpp;\n\tstruct tegra_dc *dc = plane->dc;\n\tunsigned int planes;\n\tu32 value;\n\tbool yuv;\n\n\t \n\tyuv = tegra_plane_format_is_yuv(window->format, &planes, NULL);\n\tif (!yuv)\n\t\tbpp = window->bits_per_pixel / 8;\n\telse\n\t\tbpp = (planes > 1) ? 1 : 2;\n\n\ttegra_plane_writel(plane, window->format, DC_WIN_COLOR_DEPTH);\n\ttegra_plane_writel(plane, window->swap, DC_WIN_BYTE_SWAP);\n\n\tvalue = V_POSITION(window->dst.y) | H_POSITION(window->dst.x);\n\ttegra_plane_writel(plane, value, DC_WIN_POSITION);\n\n\tvalue = V_SIZE(window->dst.h) | H_SIZE(window->dst.w);\n\ttegra_plane_writel(plane, value, DC_WIN_SIZE);\n\n\th_offset = window->src.x * bpp;\n\tv_offset = window->src.y;\n\th_size = window->src.w * bpp;\n\tv_size = window->src.h;\n\n\tif (window->reflect_x)\n\t\th_offset += (window->src.w - 1) * bpp;\n\n\tif (window->reflect_y)\n\t\tv_offset += window->src.h - 1;\n\n\tvalue = V_PRESCALED_SIZE(v_size) | H_PRESCALED_SIZE(h_size);\n\ttegra_plane_writel(plane, value, DC_WIN_PRESCALED_SIZE);\n\n\t \n\tif (yuv && planes > 1)\n\t\tbpp = 2;\n\n\th_dda = compute_dda_inc(window->src.w, window->dst.w, false, bpp);\n\tv_dda = compute_dda_inc(window->src.h, window->dst.h, true, bpp);\n\n\tvalue = V_DDA_INC(v_dda) | H_DDA_INC(h_dda);\n\ttegra_plane_writel(plane, value, DC_WIN_DDA_INC);\n\n\th_dda = compute_initial_dda(window->src.x);\n\tv_dda = compute_initial_dda(window->src.y);\n\n\ttegra_plane_writel(plane, h_dda, DC_WIN_H_INITIAL_DDA);\n\ttegra_plane_writel(plane, v_dda, DC_WIN_V_INITIAL_DDA);\n\n\ttegra_plane_writel(plane, 0, DC_WIN_UV_BUF_STRIDE);\n\ttegra_plane_writel(plane, 0, DC_WIN_BUF_STRIDE);\n\n\ttegra_plane_writel(plane, window->base[0], DC_WINBUF_START_ADDR);\n\n\tif (yuv && planes > 1) {\n\t\ttegra_plane_writel(plane, window->base[1], DC_WINBUF_START_ADDR_U);\n\n\t\tif (planes > 2)\n\t\t\ttegra_plane_writel(plane, window->base[2], DC_WINBUF_START_ADDR_V);\n\n\t\tvalue = window->stride[1] << 16 | window->stride[0];\n\t\ttegra_plane_writel(plane, value, DC_WIN_LINE_STRIDE);\n\t} else {\n\t\ttegra_plane_writel(plane, window->stride[0], DC_WIN_LINE_STRIDE);\n\t}\n\n\ttegra_plane_writel(plane, h_offset, DC_WINBUF_ADDR_H_OFFSET);\n\ttegra_plane_writel(plane, v_offset, DC_WINBUF_ADDR_V_OFFSET);\n\n\tif (dc->soc->supports_block_linear) {\n\t\tunsigned long height = window->tiling.value;\n\n\t\tswitch (window->tiling.mode) {\n\t\tcase TEGRA_BO_TILING_MODE_PITCH:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_PITCH;\n\t\t\tbreak;\n\n\t\tcase TEGRA_BO_TILING_MODE_TILED:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_TILED;\n\t\t\tbreak;\n\n\t\tcase TEGRA_BO_TILING_MODE_BLOCK:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_BLOCK_HEIGHT(height) |\n\t\t\t\tDC_WINBUF_SURFACE_KIND_BLOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\ttegra_plane_writel(plane, value, DC_WINBUF_SURFACE_KIND);\n\t} else {\n\t\tswitch (window->tiling.mode) {\n\t\tcase TEGRA_BO_TILING_MODE_PITCH:\n\t\t\tvalue = DC_WIN_BUFFER_ADDR_MODE_LINEAR_UV |\n\t\t\t\tDC_WIN_BUFFER_ADDR_MODE_LINEAR;\n\t\t\tbreak;\n\n\t\tcase TEGRA_BO_TILING_MODE_TILED:\n\t\t\tvalue = DC_WIN_BUFFER_ADDR_MODE_TILE_UV |\n\t\t\t\tDC_WIN_BUFFER_ADDR_MODE_TILE;\n\t\t\tbreak;\n\n\t\tcase TEGRA_BO_TILING_MODE_BLOCK:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\ttegra_plane_writel(plane, value, DC_WIN_BUFFER_ADDR_MODE);\n\t}\n\n\tvalue = WIN_ENABLE;\n\n\tif (yuv) {\n\t\t \n\t\ttegra_plane_writel(plane, 0x00f0, DC_WIN_CSC_YOF);\n\t\ttegra_plane_writel(plane, 0x012a, DC_WIN_CSC_KYRGB);\n\t\ttegra_plane_writel(plane, 0x0000, DC_WIN_CSC_KUR);\n\t\ttegra_plane_writel(plane, 0x0198, DC_WIN_CSC_KVR);\n\t\ttegra_plane_writel(plane, 0x039b, DC_WIN_CSC_KUG);\n\t\ttegra_plane_writel(plane, 0x032f, DC_WIN_CSC_KVG);\n\t\ttegra_plane_writel(plane, 0x0204, DC_WIN_CSC_KUB);\n\t\ttegra_plane_writel(plane, 0x0000, DC_WIN_CSC_KVB);\n\n\t\tvalue |= CSC_ENABLE;\n\t} else if (window->bits_per_pixel < 24) {\n\t\tvalue |= COLOR_EXPAND;\n\t}\n\n\tif (window->reflect_x)\n\t\tvalue |= H_DIRECTION;\n\n\tif (window->reflect_y)\n\t\tvalue |= V_DIRECTION;\n\n\tif (tegra_plane_use_horizontal_filtering(plane, window)) {\n\t\t \n\t\ttegra_plane_writel(plane, 0x00008000, DC_WIN_H_FILTER_P(0));\n\t\ttegra_plane_writel(plane, 0x3e087ce1, DC_WIN_H_FILTER_P(1));\n\t\ttegra_plane_writel(plane, 0x3b117ac1, DC_WIN_H_FILTER_P(2));\n\t\ttegra_plane_writel(plane, 0x591b73aa, DC_WIN_H_FILTER_P(3));\n\t\ttegra_plane_writel(plane, 0x57256d9a, DC_WIN_H_FILTER_P(4));\n\t\ttegra_plane_writel(plane, 0x552f668b, DC_WIN_H_FILTER_P(5));\n\t\ttegra_plane_writel(plane, 0x73385e8b, DC_WIN_H_FILTER_P(6));\n\t\ttegra_plane_writel(plane, 0x72435583, DC_WIN_H_FILTER_P(7));\n\t\ttegra_plane_writel(plane, 0x714c4c8b, DC_WIN_H_FILTER_P(8));\n\t\ttegra_plane_writel(plane, 0x70554393, DC_WIN_H_FILTER_P(9));\n\t\ttegra_plane_writel(plane, 0x715e389b, DC_WIN_H_FILTER_P(10));\n\t\ttegra_plane_writel(plane, 0x71662faa, DC_WIN_H_FILTER_P(11));\n\t\ttegra_plane_writel(plane, 0x536d25ba, DC_WIN_H_FILTER_P(12));\n\t\ttegra_plane_writel(plane, 0x55731bca, DC_WIN_H_FILTER_P(13));\n\t\ttegra_plane_writel(plane, 0x387a11d9, DC_WIN_H_FILTER_P(14));\n\t\ttegra_plane_writel(plane, 0x3c7c08f1, DC_WIN_H_FILTER_P(15));\n\n\t\tvalue |= H_FILTER;\n\t}\n\n\tif (tegra_plane_use_vertical_filtering(plane, window)) {\n\t\tunsigned int i, k;\n\n\t\t \n\t\tfor (i = 0, k = 128; i < 16; i++, k -= 8)\n\t\t\ttegra_plane_writel(plane, k, DC_WIN_V_FILTER_P(i));\n\n\t\tvalue |= V_FILTER;\n\t}\n\n\ttegra_plane_writel(plane, value, DC_WIN_WIN_OPTIONS);\n\n\tif (dc->soc->has_legacy_blending)\n\t\ttegra_plane_setup_blending_legacy(plane);\n\telse\n\t\ttegra_plane_setup_blending(plane, window);\n}\n\nstatic const u32 tegra20_primary_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const u64 tegra20_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_NVIDIA_TEGRA_TILED,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic const u32 tegra114_primary_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n};\n\nstatic const u32 tegra124_primary_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\t \n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRX8888,\n};\n\nstatic const u64 tegra124_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(0),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(1),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(2),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(3),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(4),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(5),\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic int tegra_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct tegra_plane_state *plane_state = to_tegra_plane_state(new_plane_state);\n\tunsigned int supported_rotation = DRM_MODE_ROTATE_0 |\n\t\t\t\t\t  DRM_MODE_REFLECT_X |\n\t\t\t\t\t  DRM_MODE_REFLECT_Y;\n\tunsigned int rotation = new_plane_state->rotation;\n\tstruct tegra_bo_tiling *tiling = &plane_state->tiling;\n\tstruct tegra_plane *tegra = to_tegra_plane(plane);\n\tstruct tegra_dc *dc = to_tegra_dc(new_plane_state->crtc);\n\tint err;\n\n\tplane_state->peak_memory_bandwidth = 0;\n\tplane_state->avg_memory_bandwidth = 0;\n\n\t \n\tif (!new_plane_state->crtc) {\n\t\tplane_state->total_peak_memory_bandwidth = 0;\n\t\treturn 0;\n\t}\n\n\terr = tegra_plane_format(new_plane_state->fb->format->format,\n\t\t\t\t &plane_state->format,\n\t\t\t\t &plane_state->swap);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (dc->soc->has_legacy_blending) {\n\t\terr = tegra_plane_setup_legacy_state(tegra, plane_state);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = tegra_fb_get_tiling(new_plane_state->fb, tiling);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tiling->mode == TEGRA_BO_TILING_MODE_BLOCK &&\n\t    !dc->soc->supports_block_linear) {\n\t\tDRM_ERROR(\"hardware doesn't support block linear mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tegra_fb_is_bottom_up(new_plane_state->fb))\n\t\trotation |= DRM_MODE_REFLECT_Y;\n\n\trotation = drm_rotation_simplify(rotation, supported_rotation);\n\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tplane_state->reflect_x = true;\n\telse\n\t\tplane_state->reflect_x = false;\n\n\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\tplane_state->reflect_y = true;\n\telse\n\t\tplane_state->reflect_y = false;\n\n\t \n\tif (new_plane_state->fb->format->num_planes > 2) {\n\t\tif (new_plane_state->fb->pitches[2] != new_plane_state->fb->pitches[1]) {\n\t\t\tDRM_ERROR(\"unsupported UV-plane configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = tegra_plane_state_add(tegra, new_plane_state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void tegra_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\tu32 value;\n\n\t \n\tif (!old_state || !old_state->crtc)\n\t\treturn;\n\n\tvalue = tegra_plane_readl(p, DC_WIN_WIN_OPTIONS);\n\tvalue &= ~WIN_ENABLE;\n\ttegra_plane_writel(p, value, DC_WIN_WIN_OPTIONS);\n}\n\nstatic void tegra_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct tegra_plane_state *tegra_plane_state = to_tegra_plane_state(new_state);\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\tstruct tegra_dc_window window;\n\tunsigned int i;\n\n\t \n\tif (!new_state->crtc || !new_state->fb)\n\t\treturn;\n\n\tif (!new_state->visible)\n\t\treturn tegra_plane_atomic_disable(plane, state);\n\n\tmemset(&window, 0, sizeof(window));\n\twindow.src.x = new_state->src.x1 >> 16;\n\twindow.src.y = new_state->src.y1 >> 16;\n\twindow.src.w = drm_rect_width(&new_state->src) >> 16;\n\twindow.src.h = drm_rect_height(&new_state->src) >> 16;\n\twindow.dst.x = new_state->dst.x1;\n\twindow.dst.y = new_state->dst.y1;\n\twindow.dst.w = drm_rect_width(&new_state->dst);\n\twindow.dst.h = drm_rect_height(&new_state->dst);\n\twindow.bits_per_pixel = fb->format->cpp[0] * 8;\n\twindow.reflect_x = tegra_plane_state->reflect_x;\n\twindow.reflect_y = tegra_plane_state->reflect_y;\n\n\t \n\twindow.zpos = new_state->normalized_zpos;\n\twindow.tiling = tegra_plane_state->tiling;\n\twindow.format = tegra_plane_state->format;\n\twindow.swap = tegra_plane_state->swap;\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\twindow.base[i] = tegra_plane_state->iova[i] + fb->offsets[i];\n\n\t\t \n\t\tif (i < 2)\n\t\t\twindow.stride[i] = fb->pitches[i];\n\t}\n\n\ttegra_dc_setup_window(p, &window);\n}\n\nstatic const struct drm_plane_helper_funcs tegra_plane_helper_funcs = {\n\t.prepare_fb = tegra_plane_prepare_fb,\n\t.cleanup_fb = tegra_plane_cleanup_fb,\n\t.atomic_check = tegra_plane_atomic_check,\n\t.atomic_disable = tegra_plane_atomic_disable,\n\t.atomic_update = tegra_plane_atomic_update,\n};\n\nstatic unsigned long tegra_plane_get_possible_crtcs(struct drm_device *drm)\n{\n\t \n\treturn 1 << drm->mode_config.num_crtc;\n}\n\nstatic struct drm_plane *tegra_primary_plane_create(struct drm_device *drm,\n\t\t\t\t\t\t    struct tegra_dc *dc)\n{\n\tunsigned long possible_crtcs = tegra_plane_get_possible_crtcs(drm);\n\tenum drm_plane_type type = DRM_PLANE_TYPE_PRIMARY;\n\tstruct tegra_plane *plane;\n\tunsigned int num_formats;\n\tconst u64 *modifiers;\n\tconst u32 *formats;\n\tint err;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tplane->offset = 0xa00;\n\tplane->index = 0;\n\tplane->dc = dc;\n\n\tnum_formats = dc->soc->num_primary_formats;\n\tformats = dc->soc->primary_formats;\n\tmodifiers = dc->soc->modifiers;\n\n\terr = tegra_plane_interconnect_init(plane);\n\tif (err) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = drm_universal_plane_init(drm, &plane->base, possible_crtcs,\n\t\t\t\t       &tegra_plane_funcs, formats,\n\t\t\t\t       num_formats, modifiers, type, NULL);\n\tif (err < 0) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdrm_plane_helper_add(&plane->base, &tegra_plane_helper_funcs);\n\tdrm_plane_create_zpos_property(&plane->base, plane->index, 0, 255);\n\n\terr = drm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t\t DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t DRM_MODE_ROTATE_180 |\n\t\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\tif (err < 0)\n\t\tdev_err(dc->dev, \"failed to create rotation property: %d\\n\",\n\t\t\terr);\n\n\treturn &plane->base;\n}\n\nstatic const u32 tegra_legacy_cursor_plane_formats[] = {\n\tDRM_FORMAT_RGBA8888,\n};\n\nstatic const u32 tegra_cursor_plane_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic int tegra_cursor_atomic_check(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct tegra_plane_state *plane_state = to_tegra_plane_state(new_plane_state);\n\tstruct tegra_plane *tegra = to_tegra_plane(plane);\n\tint err;\n\n\tplane_state->peak_memory_bandwidth = 0;\n\tplane_state->avg_memory_bandwidth = 0;\n\n\t \n\tif (!new_plane_state->crtc) {\n\t\tplane_state->total_peak_memory_bandwidth = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((new_plane_state->src_w >> 16 != new_plane_state->crtc_w) ||\n\t    (new_plane_state->src_h >> 16 != new_plane_state->crtc_h))\n\t\treturn -EINVAL;\n\n\t \n\tif (new_plane_state->src_w != new_plane_state->src_h)\n\t\treturn -EINVAL;\n\n\tif (new_plane_state->crtc_w != 32 && new_plane_state->crtc_w != 64 &&\n\t    new_plane_state->crtc_w != 128 && new_plane_state->crtc_w != 256)\n\t\treturn -EINVAL;\n\n\terr = tegra_plane_state_add(tegra, new_plane_state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void __tegra_cursor_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t struct drm_plane_state *new_state)\n{\n\tstruct tegra_plane_state *tegra_plane_state = to_tegra_plane_state(new_state);\n\tstruct tegra_dc *dc = to_tegra_dc(new_state->crtc);\n\tstruct tegra_drm *tegra = plane->dev->dev_private;\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tu64 dma_mask = *dc->dev->dma_mask;\n#endif\n\tunsigned int x, y;\n\tu32 value = 0;\n\n\t \n\tif (!new_state->crtc || !new_state->fb)\n\t\treturn;\n\n\t \n\tif (!dc->soc->has_nvdisplay)\n\t\tvalue |= CURSOR_CLIP_DISPLAY;\n\n\tswitch (new_state->crtc_w) {\n\tcase 32:\n\t\tvalue |= CURSOR_SIZE_32x32;\n\t\tbreak;\n\n\tcase 64:\n\t\tvalue |= CURSOR_SIZE_64x64;\n\t\tbreak;\n\n\tcase 128:\n\t\tvalue |= CURSOR_SIZE_128x128;\n\t\tbreak;\n\n\tcase 256:\n\t\tvalue |= CURSOR_SIZE_256x256;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"cursor size %ux%u not supported\\n\",\n\t\t     new_state->crtc_w, new_state->crtc_h);\n\t\treturn;\n\t}\n\n\tvalue |= (tegra_plane_state->iova[0] >> 10) & 0x3fffff;\n\ttegra_dc_writel(dc, value, DC_DISP_CURSOR_START_ADDR);\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tvalue = (tegra_plane_state->iova[0] >> 32) & (dma_mask >> 32);\n\ttegra_dc_writel(dc, value, DC_DISP_CURSOR_START_ADDR_HI);\n#endif\n\n\t \n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue |= CURSOR_ENABLE;\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_BLEND_CURSOR_CONTROL);\n\tvalue &= ~CURSOR_DST_BLEND_MASK;\n\tvalue &= ~CURSOR_SRC_BLEND_MASK;\n\n\tif (dc->soc->has_nvdisplay)\n\t\tvalue &= ~CURSOR_COMPOSITION_MODE_XOR;\n\telse\n\t\tvalue |= CURSOR_MODE_NORMAL;\n\n\tvalue |= CURSOR_DST_BLEND_NEG_K1_TIMES_SRC;\n\tvalue |= CURSOR_SRC_BLEND_K1_TIMES_SRC;\n\tvalue |= CURSOR_ALPHA;\n\ttegra_dc_writel(dc, value, DC_DISP_BLEND_CURSOR_CONTROL);\n\n\t \n\tif (dc->soc->has_nvdisplay) {\n\t\tstruct drm_rect src;\n\n\t\tx = new_state->dst.x1;\n\t\ty = new_state->dst.y1;\n\n\t\tdrm_rect_fp_to_int(&src, &new_state->src);\n\n\t\tvalue = (src.y1 & tegra->vmask) << 16 | (src.x1 & tegra->hmask);\n\t\ttegra_dc_writel(dc, value, DC_DISP_PCALC_HEAD_SET_CROPPED_POINT_IN_CURSOR);\n\n\t\tvalue = (drm_rect_height(&src) & tegra->vmask) << 16 |\n\t\t\t(drm_rect_width(&src) & tegra->hmask);\n\t\ttegra_dc_writel(dc, value, DC_DISP_PCALC_HEAD_SET_CROPPED_SIZE_IN_CURSOR);\n\t} else {\n\t\tx = new_state->crtc_x;\n\t\ty = new_state->crtc_y;\n\t}\n\n\t \n\tvalue = ((y & tegra->vmask) << 16) | (x & tegra->hmask);\n\ttegra_dc_writel(dc, value, DC_DISP_CURSOR_POSITION);\n}\n\nstatic void tegra_cursor_atomic_update(struct drm_plane *plane,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\n\t__tegra_cursor_atomic_update(plane, new_state);\n}\n\nstatic void tegra_cursor_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct tegra_dc *dc;\n\tu32 value;\n\n\t \n\tif (!old_state || !old_state->crtc)\n\t\treturn;\n\n\tdc = to_tegra_dc(old_state->crtc);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue &= ~CURSOR_ENABLE;\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n}\n\nstatic int tegra_cursor_atomic_async_check(struct drm_plane *plane, struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_crtc_state *crtc_state;\n\tint min_scale, max_scale;\n\tint err;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, new_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tif (!crtc_state->active)\n\t\treturn -EINVAL;\n\n\tif (plane->state->crtc != new_state->crtc ||\n\t    plane->state->src_w != new_state->src_w ||\n\t    plane->state->src_h != new_state->src_h ||\n\t    plane->state->crtc_w != new_state->crtc_w ||\n\t    plane->state->crtc_h != new_state->crtc_h ||\n\t    plane->state->fb != new_state->fb ||\n\t    plane->state->fb == NULL)\n\t\treturn -EINVAL;\n\n\tmin_scale = (1 << 16) / 8;\n\tmax_scale = (8 << 16) / 1;\n\n\terr = drm_atomic_helper_check_plane_state(new_state, crtc_state, min_scale, max_scale,\n\t\t\t\t\t\t  true, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (new_state->visible != plane->state->visible)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tegra_cursor_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct tegra_dc *dc = to_tegra_dc(new_state->crtc);\n\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\n\tif (new_state->visible) {\n\t\tstruct tegra_plane *p = to_tegra_plane(plane);\n\t\tu32 value;\n\n\t\t__tegra_cursor_atomic_update(plane, new_state);\n\n\t\tvalue = (WIN_A_ACT_REQ << p->index) << 8 | GENERAL_UPDATE;\n\t\ttegra_dc_writel(dc, value, DC_CMD_STATE_CONTROL);\n\t\t(void)tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\n\t\tvalue = (WIN_A_ACT_REQ << p->index) | GENERAL_ACT_REQ;\n\t\ttegra_dc_writel(dc, value, DC_CMD_STATE_CONTROL);\n\t\t(void)tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\t}\n}\n\nstatic const struct drm_plane_helper_funcs tegra_cursor_plane_helper_funcs = {\n\t.prepare_fb = tegra_plane_prepare_fb,\n\t.cleanup_fb = tegra_plane_cleanup_fb,\n\t.atomic_check = tegra_cursor_atomic_check,\n\t.atomic_update = tegra_cursor_atomic_update,\n\t.atomic_disable = tegra_cursor_atomic_disable,\n\t.atomic_async_check = tegra_cursor_atomic_async_check,\n\t.atomic_async_update = tegra_cursor_atomic_async_update,\n};\n\nstatic const uint64_t linear_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic struct drm_plane *tegra_dc_cursor_plane_create(struct drm_device *drm,\n\t\t\t\t\t\t      struct tegra_dc *dc)\n{\n\tunsigned long possible_crtcs = tegra_plane_get_possible_crtcs(drm);\n\tstruct tegra_plane *plane;\n\tunsigned int num_formats;\n\tconst u32 *formats;\n\tint err;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tplane->index = 6;\n\tplane->dc = dc;\n\n\tif (!dc->soc->has_nvdisplay) {\n\t\tnum_formats = ARRAY_SIZE(tegra_legacy_cursor_plane_formats);\n\t\tformats = tegra_legacy_cursor_plane_formats;\n\n\t\terr = tegra_plane_interconnect_init(plane);\n\t\tif (err) {\n\t\t\tkfree(plane);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t} else {\n\t\tnum_formats = ARRAY_SIZE(tegra_cursor_plane_formats);\n\t\tformats = tegra_cursor_plane_formats;\n\t}\n\n\terr = drm_universal_plane_init(drm, &plane->base, possible_crtcs,\n\t\t\t\t       &tegra_plane_funcs, formats,\n\t\t\t\t       num_formats, linear_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_CURSOR, NULL);\n\tif (err < 0) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdrm_plane_helper_add(&plane->base, &tegra_cursor_plane_helper_funcs);\n\tdrm_plane_create_zpos_immutable_property(&plane->base, 255);\n\n\treturn &plane->base;\n}\n\nstatic const u32 tegra20_overlay_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB8888,\n\t \n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n};\n\nstatic const u32 tegra114_overlay_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\t \n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\t \n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_NV24,\n\tDRM_FORMAT_NV42,\n};\n\nstatic const u32 tegra124_overlay_formats[] = {\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_ARGB8888,\n\t \n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_BGRA8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\t \n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRX8888,\n\t \n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YUV420,  \n\tDRM_FORMAT_YUV422,  \n\tDRM_FORMAT_YUV444,  \n\t \n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n\tDRM_FORMAT_NV16,\n\tDRM_FORMAT_NV61,\n\tDRM_FORMAT_NV24,\n\tDRM_FORMAT_NV42,\n};\n\nstatic struct drm_plane *tegra_dc_overlay_plane_create(struct drm_device *drm,\n\t\t\t\t\t\t       struct tegra_dc *dc,\n\t\t\t\t\t\t       unsigned int index,\n\t\t\t\t\t\t       bool cursor)\n{\n\tunsigned long possible_crtcs = tegra_plane_get_possible_crtcs(drm);\n\tstruct tegra_plane *plane;\n\tunsigned int num_formats;\n\tenum drm_plane_type type;\n\tconst u32 *formats;\n\tint err;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tplane->offset = 0xa00 + 0x200 * index;\n\tplane->index = index;\n\tplane->dc = dc;\n\n\tnum_formats = dc->soc->num_overlay_formats;\n\tformats = dc->soc->overlay_formats;\n\n\terr = tegra_plane_interconnect_init(plane);\n\tif (err) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tif (!cursor)\n\t\ttype = DRM_PLANE_TYPE_OVERLAY;\n\telse\n\t\ttype = DRM_PLANE_TYPE_CURSOR;\n\n\terr = drm_universal_plane_init(drm, &plane->base, possible_crtcs,\n\t\t\t\t       &tegra_plane_funcs, formats,\n\t\t\t\t       num_formats, linear_modifiers,\n\t\t\t\t       type, NULL);\n\tif (err < 0) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdrm_plane_helper_add(&plane->base, &tegra_plane_helper_funcs);\n\tdrm_plane_create_zpos_property(&plane->base, plane->index, 0, 255);\n\n\terr = drm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t\t DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t DRM_MODE_ROTATE_180 |\n\t\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\tif (err < 0)\n\t\tdev_err(dc->dev, \"failed to create rotation property: %d\\n\",\n\t\t\terr);\n\n\treturn &plane->base;\n}\n\nstatic struct drm_plane *tegra_dc_add_shared_planes(struct drm_device *drm,\n\t\t\t\t\t\t    struct tegra_dc *dc)\n{\n\tstruct drm_plane *plane, *primary = NULL;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < dc->soc->num_wgrps; i++) {\n\t\tconst struct tegra_windowgroup_soc *wgrp = &dc->soc->wgrps[i];\n\n\t\tif (wgrp->dc == dc->pipe) {\n\t\t\tfor (j = 0; j < wgrp->num_windows; j++) {\n\t\t\t\tunsigned int index = wgrp->windows[j];\n\n\t\t\t\tplane = tegra_shared_plane_create(drm, dc,\n\t\t\t\t\t\t\t\t  wgrp->index,\n\t\t\t\t\t\t\t\t  index);\n\t\t\t\tif (IS_ERR(plane))\n\t\t\t\t\treturn plane;\n\n\t\t\t\t \n\t\t\t\tif (!primary) {\n\t\t\t\t\tplane->type = DRM_PLANE_TYPE_PRIMARY;\n\t\t\t\t\tprimary = plane;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn primary;\n}\n\nstatic struct drm_plane *tegra_dc_add_planes(struct drm_device *drm,\n\t\t\t\t\t     struct tegra_dc *dc)\n{\n\tstruct drm_plane *planes[2], *primary;\n\tunsigned int planes_num;\n\tunsigned int i;\n\tint err;\n\n\tprimary = tegra_primary_plane_create(drm, dc);\n\tif (IS_ERR(primary))\n\t\treturn primary;\n\n\tif (dc->soc->supports_cursor)\n\t\tplanes_num = 2;\n\telse\n\t\tplanes_num = 1;\n\n\tfor (i = 0; i < planes_num; i++) {\n\t\tplanes[i] = tegra_dc_overlay_plane_create(drm, dc, 1 + i,\n\t\t\t\t\t\t\t  false);\n\t\tif (IS_ERR(planes[i])) {\n\t\t\terr = PTR_ERR(planes[i]);\n\n\t\t\twhile (i--)\n\t\t\t\tplanes[i]->funcs->destroy(planes[i]);\n\n\t\t\tprimary->funcs->destroy(primary);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn primary;\n}\n\nstatic void tegra_dc_destroy(struct drm_crtc *crtc)\n{\n\tdrm_crtc_cleanup(crtc);\n}\n\nstatic void tegra_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct tegra_dc_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\ttegra_crtc_atomic_destroy_state(crtc, crtc->state);\n\n\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\ntegra_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct tegra_dc_state *state = to_dc_state(crtc->state);\n\tstruct tegra_dc_state *copy;\n\n\tcopy = kmalloc(sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &copy->base);\n\tcopy->clk = state->clk;\n\tcopy->pclk = state->pclk;\n\tcopy->div = state->div;\n\tcopy->planes = state->planes;\n\n\treturn &copy->base;\n}\n\nstatic void tegra_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(state);\n}\n\n#define DEBUGFS_REG32(_name) { .name = #_name, .offset = _name }\n\nstatic const struct debugfs_reg32 tegra_dc_regs[] = {\n\tDEBUGFS_REG32(DC_CMD_GENERAL_INCR_SYNCPT),\n\tDEBUGFS_REG32(DC_CMD_GENERAL_INCR_SYNCPT_CNTRL),\n\tDEBUGFS_REG32(DC_CMD_GENERAL_INCR_SYNCPT_ERROR),\n\tDEBUGFS_REG32(DC_CMD_WIN_A_INCR_SYNCPT),\n\tDEBUGFS_REG32(DC_CMD_WIN_A_INCR_SYNCPT_CNTRL),\n\tDEBUGFS_REG32(DC_CMD_WIN_A_INCR_SYNCPT_ERROR),\n\tDEBUGFS_REG32(DC_CMD_WIN_B_INCR_SYNCPT),\n\tDEBUGFS_REG32(DC_CMD_WIN_B_INCR_SYNCPT_CNTRL),\n\tDEBUGFS_REG32(DC_CMD_WIN_B_INCR_SYNCPT_ERROR),\n\tDEBUGFS_REG32(DC_CMD_WIN_C_INCR_SYNCPT),\n\tDEBUGFS_REG32(DC_CMD_WIN_C_INCR_SYNCPT_CNTRL),\n\tDEBUGFS_REG32(DC_CMD_WIN_C_INCR_SYNCPT_ERROR),\n\tDEBUGFS_REG32(DC_CMD_CONT_SYNCPT_VSYNC),\n\tDEBUGFS_REG32(DC_CMD_DISPLAY_COMMAND_OPTION0),\n\tDEBUGFS_REG32(DC_CMD_DISPLAY_COMMAND),\n\tDEBUGFS_REG32(DC_CMD_SIGNAL_RAISE),\n\tDEBUGFS_REG32(DC_CMD_DISPLAY_POWER_CONTROL),\n\tDEBUGFS_REG32(DC_CMD_INT_STATUS),\n\tDEBUGFS_REG32(DC_CMD_INT_MASK),\n\tDEBUGFS_REG32(DC_CMD_INT_ENABLE),\n\tDEBUGFS_REG32(DC_CMD_INT_TYPE),\n\tDEBUGFS_REG32(DC_CMD_INT_POLARITY),\n\tDEBUGFS_REG32(DC_CMD_SIGNAL_RAISE1),\n\tDEBUGFS_REG32(DC_CMD_SIGNAL_RAISE2),\n\tDEBUGFS_REG32(DC_CMD_SIGNAL_RAISE3),\n\tDEBUGFS_REG32(DC_CMD_STATE_ACCESS),\n\tDEBUGFS_REG32(DC_CMD_STATE_CONTROL),\n\tDEBUGFS_REG32(DC_CMD_DISPLAY_WINDOW_HEADER),\n\tDEBUGFS_REG32(DC_CMD_REG_ACT_CONTROL),\n\tDEBUGFS_REG32(DC_COM_CRC_CONTROL),\n\tDEBUGFS_REG32(DC_COM_CRC_CHECKSUM),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_ENABLE(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_ENABLE(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_ENABLE(2)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_ENABLE(3)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_POLARITY(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_POLARITY(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_POLARITY(2)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_POLARITY(3)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_DATA(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_DATA(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_DATA(2)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_DATA(3)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_ENABLE(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_ENABLE(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_ENABLE(2)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_ENABLE(3)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_DATA(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_INPUT_DATA(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(0)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(1)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(2)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(3)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(4)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(5)),\n\tDEBUGFS_REG32(DC_COM_PIN_OUTPUT_SELECT(6)),\n\tDEBUGFS_REG32(DC_COM_PIN_MISC_CONTROL),\n\tDEBUGFS_REG32(DC_COM_PIN_PM0_CONTROL),\n\tDEBUGFS_REG32(DC_COM_PIN_PM0_DUTY_CYCLE),\n\tDEBUGFS_REG32(DC_COM_PIN_PM1_CONTROL),\n\tDEBUGFS_REG32(DC_COM_PIN_PM1_DUTY_CYCLE),\n\tDEBUGFS_REG32(DC_COM_SPI_CONTROL),\n\tDEBUGFS_REG32(DC_COM_SPI_START_BYTE),\n\tDEBUGFS_REG32(DC_COM_HSPI_WRITE_DATA_AB),\n\tDEBUGFS_REG32(DC_COM_HSPI_WRITE_DATA_CD),\n\tDEBUGFS_REG32(DC_COM_HSPI_CS_DC),\n\tDEBUGFS_REG32(DC_COM_SCRATCH_REGISTER_A),\n\tDEBUGFS_REG32(DC_COM_SCRATCH_REGISTER_B),\n\tDEBUGFS_REG32(DC_COM_GPIO_CTRL),\n\tDEBUGFS_REG32(DC_COM_GPIO_DEBOUNCE_COUNTER),\n\tDEBUGFS_REG32(DC_COM_CRC_CHECKSUM_LATCHED),\n\tDEBUGFS_REG32(DC_DISP_DISP_SIGNAL_OPTIONS0),\n\tDEBUGFS_REG32(DC_DISP_DISP_SIGNAL_OPTIONS1),\n\tDEBUGFS_REG32(DC_DISP_DISP_WIN_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_DISP_MEM_HIGH_PRIORITY),\n\tDEBUGFS_REG32(DC_DISP_DISP_MEM_HIGH_PRIORITY_TIMER),\n\tDEBUGFS_REG32(DC_DISP_DISP_TIMING_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_REF_TO_SYNC),\n\tDEBUGFS_REG32(DC_DISP_SYNC_WIDTH),\n\tDEBUGFS_REG32(DC_DISP_BACK_PORCH),\n\tDEBUGFS_REG32(DC_DISP_ACTIVE),\n\tDEBUGFS_REG32(DC_DISP_FRONT_PORCH),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE0_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE0_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE0_POSITION_B),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE0_POSITION_C),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE0_POSITION_D),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE1_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE1_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE1_POSITION_B),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE1_POSITION_C),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE1_POSITION_D),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE2_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE2_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE2_POSITION_B),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE2_POSITION_C),\n\tDEBUGFS_REG32(DC_DISP_H_PULSE2_POSITION_D),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE0_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE0_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE0_POSITION_B),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE0_POSITION_C),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE1_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE1_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE1_POSITION_B),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE1_POSITION_C),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE2_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE2_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE3_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_V_PULSE3_POSITION_A),\n\tDEBUGFS_REG32(DC_DISP_M0_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_M1_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_DI_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_PP_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_PP_SELECT_A),\n\tDEBUGFS_REG32(DC_DISP_PP_SELECT_B),\n\tDEBUGFS_REG32(DC_DISP_PP_SELECT_C),\n\tDEBUGFS_REG32(DC_DISP_PP_SELECT_D),\n\tDEBUGFS_REG32(DC_DISP_DISP_CLOCK_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_DISP_INTERFACE_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_DISP_COLOR_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_SHIFT_CLOCK_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_DATA_ENABLE_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_SERIAL_INTERFACE_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_LCD_SPI_OPTIONS),\n\tDEBUGFS_REG32(DC_DISP_BORDER_COLOR),\n\tDEBUGFS_REG32(DC_DISP_COLOR_KEY0_LOWER),\n\tDEBUGFS_REG32(DC_DISP_COLOR_KEY0_UPPER),\n\tDEBUGFS_REG32(DC_DISP_COLOR_KEY1_LOWER),\n\tDEBUGFS_REG32(DC_DISP_COLOR_KEY1_UPPER),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_FOREGROUND),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_BACKGROUND),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_START_ADDR),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_START_ADDR_NS),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_POSITION),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_POSITION_NS),\n\tDEBUGFS_REG32(DC_DISP_INIT_SEQ_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_SPI_INIT_SEQ_DATA_A),\n\tDEBUGFS_REG32(DC_DISP_SPI_INIT_SEQ_DATA_B),\n\tDEBUGFS_REG32(DC_DISP_SPI_INIT_SEQ_DATA_C),\n\tDEBUGFS_REG32(DC_DISP_SPI_INIT_SEQ_DATA_D),\n\tDEBUGFS_REG32(DC_DISP_DC_MCCIF_FIFOCTRL),\n\tDEBUGFS_REG32(DC_DISP_MCCIF_DISPLAY0A_HYST),\n\tDEBUGFS_REG32(DC_DISP_MCCIF_DISPLAY0B_HYST),\n\tDEBUGFS_REG32(DC_DISP_MCCIF_DISPLAY1A_HYST),\n\tDEBUGFS_REG32(DC_DISP_MCCIF_DISPLAY1B_HYST),\n\tDEBUGFS_REG32(DC_DISP_DAC_CRT_CTRL),\n\tDEBUGFS_REG32(DC_DISP_DISP_MISC_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_SD_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_SD_CSC_COEFF),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(0)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(1)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(2)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(3)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(4)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(5)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(6)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(7)),\n\tDEBUGFS_REG32(DC_DISP_SD_LUT(8)),\n\tDEBUGFS_REG32(DC_DISP_SD_FLICKER_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_DC_PIXEL_COUNT),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(0)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(1)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(2)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(3)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(4)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(5)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(6)),\n\tDEBUGFS_REG32(DC_DISP_SD_HISTOGRAM(7)),\n\tDEBUGFS_REG32(DC_DISP_SD_BL_TF(0)),\n\tDEBUGFS_REG32(DC_DISP_SD_BL_TF(1)),\n\tDEBUGFS_REG32(DC_DISP_SD_BL_TF(2)),\n\tDEBUGFS_REG32(DC_DISP_SD_BL_TF(3)),\n\tDEBUGFS_REG32(DC_DISP_SD_BL_CONTROL),\n\tDEBUGFS_REG32(DC_DISP_SD_HW_K_VALUES),\n\tDEBUGFS_REG32(DC_DISP_SD_MAN_K_VALUES),\n\tDEBUGFS_REG32(DC_DISP_CURSOR_START_ADDR_HI),\n\tDEBUGFS_REG32(DC_DISP_BLEND_CURSOR_CONTROL),\n\tDEBUGFS_REG32(DC_WIN_WIN_OPTIONS),\n\tDEBUGFS_REG32(DC_WIN_BYTE_SWAP),\n\tDEBUGFS_REG32(DC_WIN_BUFFER_CONTROL),\n\tDEBUGFS_REG32(DC_WIN_COLOR_DEPTH),\n\tDEBUGFS_REG32(DC_WIN_POSITION),\n\tDEBUGFS_REG32(DC_WIN_SIZE),\n\tDEBUGFS_REG32(DC_WIN_PRESCALED_SIZE),\n\tDEBUGFS_REG32(DC_WIN_H_INITIAL_DDA),\n\tDEBUGFS_REG32(DC_WIN_V_INITIAL_DDA),\n\tDEBUGFS_REG32(DC_WIN_DDA_INC),\n\tDEBUGFS_REG32(DC_WIN_LINE_STRIDE),\n\tDEBUGFS_REG32(DC_WIN_BUF_STRIDE),\n\tDEBUGFS_REG32(DC_WIN_UV_BUF_STRIDE),\n\tDEBUGFS_REG32(DC_WIN_BUFFER_ADDR_MODE),\n\tDEBUGFS_REG32(DC_WIN_DV_CONTROL),\n\tDEBUGFS_REG32(DC_WIN_BLEND_NOKEY),\n\tDEBUGFS_REG32(DC_WIN_BLEND_1WIN),\n\tDEBUGFS_REG32(DC_WIN_BLEND_2WIN_X),\n\tDEBUGFS_REG32(DC_WIN_BLEND_2WIN_Y),\n\tDEBUGFS_REG32(DC_WIN_BLEND_3WIN_XY),\n\tDEBUGFS_REG32(DC_WIN_HP_FETCH_CONTROL),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR_NS),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR_U),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR_U_NS),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR_V),\n\tDEBUGFS_REG32(DC_WINBUF_START_ADDR_V_NS),\n\tDEBUGFS_REG32(DC_WINBUF_ADDR_H_OFFSET),\n\tDEBUGFS_REG32(DC_WINBUF_ADDR_H_OFFSET_NS),\n\tDEBUGFS_REG32(DC_WINBUF_ADDR_V_OFFSET),\n\tDEBUGFS_REG32(DC_WINBUF_ADDR_V_OFFSET_NS),\n\tDEBUGFS_REG32(DC_WINBUF_UFLOW_STATUS),\n\tDEBUGFS_REG32(DC_WINBUF_AD_UFLOW_STATUS),\n\tDEBUGFS_REG32(DC_WINBUF_BD_UFLOW_STATUS),\n\tDEBUGFS_REG32(DC_WINBUF_CD_UFLOW_STATUS),\n};\n\nstatic int tegra_dc_show_regs(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_dc *dc = node->info_ent->data;\n\tunsigned int i;\n\tint err = 0;\n\n\tdrm_modeset_lock(&dc->base.mutex, NULL);\n\n\tif (!dc->base.state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_dc_regs); i++) {\n\t\tunsigned int offset = tegra_dc_regs[i].offset;\n\n\t\tseq_printf(s, \"%-40s %#05x %08x\\n\", tegra_dc_regs[i].name,\n\t\t\t   offset, tegra_dc_readl(dc, offset));\n\t}\n\nunlock:\n\tdrm_modeset_unlock(&dc->base.mutex);\n\treturn err;\n}\n\nstatic int tegra_dc_show_crc(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_dc *dc = node->info_ent->data;\n\tint err = 0;\n\tu32 value;\n\n\tdrm_modeset_lock(&dc->base.mutex, NULL);\n\n\tif (!dc->base.state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tvalue = DC_COM_CRC_CONTROL_ACTIVE_DATA | DC_COM_CRC_CONTROL_ENABLE;\n\ttegra_dc_writel(dc, value, DC_COM_CRC_CONTROL);\n\ttegra_dc_commit(dc);\n\n\tdrm_crtc_wait_one_vblank(&dc->base);\n\tdrm_crtc_wait_one_vblank(&dc->base);\n\n\tvalue = tegra_dc_readl(dc, DC_COM_CRC_CHECKSUM);\n\tseq_printf(s, \"%08x\\n\", value);\n\n\ttegra_dc_writel(dc, 0, DC_COM_CRC_CONTROL);\n\nunlock:\n\tdrm_modeset_unlock(&dc->base.mutex);\n\treturn err;\n}\n\nstatic int tegra_dc_show_stats(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_dc *dc = node->info_ent->data;\n\n\tseq_printf(s, \"frames: %lu\\n\", dc->stats.frames);\n\tseq_printf(s, \"vblank: %lu\\n\", dc->stats.vblank);\n\tseq_printf(s, \"underflow: %lu\\n\", dc->stats.underflow);\n\tseq_printf(s, \"overflow: %lu\\n\", dc->stats.overflow);\n\n\tseq_printf(s, \"frames total: %lu\\n\", dc->stats.frames_total);\n\tseq_printf(s, \"vblank total: %lu\\n\", dc->stats.vblank_total);\n\tseq_printf(s, \"underflow total: %lu\\n\", dc->stats.underflow_total);\n\tseq_printf(s, \"overflow total: %lu\\n\", dc->stats.overflow_total);\n\n\treturn 0;\n}\n\nstatic struct drm_info_list debugfs_files[] = {\n\t{ \"regs\", tegra_dc_show_regs, 0, NULL },\n\t{ \"crc\", tegra_dc_show_crc, 0, NULL },\n\t{ \"stats\", tegra_dc_show_stats, 0, NULL },\n};\n\nstatic int tegra_dc_late_register(struct drm_crtc *crtc)\n{\n\tunsigned int i, count = ARRAY_SIZE(debugfs_files);\n\tstruct drm_minor *minor = crtc->dev->primary;\n\tstruct dentry *root;\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\n#ifdef CONFIG_DEBUG_FS\n\troot = crtc->debugfs_entry;\n#else\n\troot = NULL;\n#endif\n\n\tdc->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\n\t\t\t\t    GFP_KERNEL);\n\tif (!dc->debugfs_files)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++)\n\t\tdc->debugfs_files[i].data = dc;\n\n\tdrm_debugfs_create_files(dc->debugfs_files, count, root, minor);\n\n\treturn 0;\n}\n\nstatic void tegra_dc_early_unregister(struct drm_crtc *crtc)\n{\n\tunsigned int count = ARRAY_SIZE(debugfs_files);\n\tstruct drm_minor *minor = crtc->dev->primary;\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\n\tdrm_debugfs_remove_files(dc->debugfs_files, count, minor);\n\tkfree(dc->debugfs_files);\n\tdc->debugfs_files = NULL;\n}\n\nstatic u32 tegra_dc_get_vblank_counter(struct drm_crtc *crtc)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\n\t \n\tif (dc->syncpt && !dc->soc->has_nvdisplay)\n\t\treturn host1x_syncpt_read(dc->syncpt);\n\n\t \n\treturn (u32)drm_crtc_vblank_count(&dc->base);\n}\n\nstatic int tegra_dc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_INT_MASK);\n\tvalue |= VBLANK_INT;\n\ttegra_dc_writel(dc, value, DC_CMD_INT_MASK);\n\n\treturn 0;\n}\n\nstatic void tegra_dc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_INT_MASK);\n\tvalue &= ~VBLANK_INT;\n\ttegra_dc_writel(dc, value, DC_CMD_INT_MASK);\n}\n\nstatic const struct drm_crtc_funcs tegra_crtc_funcs = {\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = tegra_dc_destroy,\n\t.reset = tegra_crtc_reset,\n\t.atomic_duplicate_state = tegra_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state = tegra_crtc_atomic_destroy_state,\n\t.late_register = tegra_dc_late_register,\n\t.early_unregister = tegra_dc_early_unregister,\n\t.get_vblank_counter = tegra_dc_get_vblank_counter,\n\t.enable_vblank = tegra_dc_enable_vblank,\n\t.disable_vblank = tegra_dc_disable_vblank,\n};\n\nstatic int tegra_dc_set_timings(struct tegra_dc *dc,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tunsigned int h_ref_to_sync = 1;\n\tunsigned int v_ref_to_sync = 1;\n\tunsigned long value;\n\n\tif (!dc->soc->has_nvdisplay) {\n\t\ttegra_dc_writel(dc, 0x0, DC_DISP_DISP_TIMING_OPTIONS);\n\n\t\tvalue = (v_ref_to_sync << 16) | h_ref_to_sync;\n\t\ttegra_dc_writel(dc, value, DC_DISP_REF_TO_SYNC);\n\t}\n\n\tvalue = ((mode->vsync_end - mode->vsync_start) << 16) |\n\t\t((mode->hsync_end - mode->hsync_start) <<  0);\n\ttegra_dc_writel(dc, value, DC_DISP_SYNC_WIDTH);\n\n\tvalue = ((mode->vtotal - mode->vsync_end) << 16) |\n\t\t((mode->htotal - mode->hsync_end) <<  0);\n\ttegra_dc_writel(dc, value, DC_DISP_BACK_PORCH);\n\n\tvalue = ((mode->vsync_start - mode->vdisplay) << 16) |\n\t\t((mode->hsync_start - mode->hdisplay) <<  0);\n\ttegra_dc_writel(dc, value, DC_DISP_FRONT_PORCH);\n\n\tvalue = (mode->vdisplay << 16) | mode->hdisplay;\n\ttegra_dc_writel(dc, value, DC_DISP_ACTIVE);\n\n\treturn 0;\n}\n\n \nint tegra_dc_state_setup_clock(struct tegra_dc *dc,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct clk *clk, unsigned long pclk,\n\t\t\t       unsigned int div)\n{\n\tstruct tegra_dc_state *state = to_dc_state(crtc_state);\n\n\tif (!clk_has_parent(dc->clk, clk))\n\t\treturn -EINVAL;\n\n\tstate->clk = clk;\n\tstate->pclk = pclk;\n\tstate->div = div;\n\n\treturn 0;\n}\n\nstatic void tegra_dc_update_voltage_state(struct tegra_dc *dc,\n\t\t\t\t\t  struct tegra_dc_state *state)\n{\n\tunsigned long rate, pstate;\n\tstruct dev_pm_opp *opp;\n\tint err;\n\n\tif (!dc->has_opp_table)\n\t\treturn;\n\n\t \n\trate = DIV_ROUND_UP(clk_get_rate(dc->clk) * 2, state->div + 2);\n\n\t \n\topp = dev_pm_opp_find_freq_ceil(dc->dev, &rate);\n\n\t \n\tif (opp == ERR_PTR(-ERANGE))\n\t\topp = dev_pm_opp_find_freq_floor(dc->dev, &rate);\n\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dc->dev, \"failed to find OPP for %luHz: %pe\\n\",\n\t\t\trate, opp);\n\t\treturn;\n\t}\n\n\tpstate = dev_pm_opp_get_required_pstate(opp, 0);\n\tdev_pm_opp_put(opp);\n\n\t \n\terr = dev_pm_genpd_set_performance_state(dc->dev, pstate);\n\tif (err)\n\t\tdev_err(dc->dev, \"failed to set power domain state to %lu: %d\\n\",\n\t\t\tpstate, err);\n}\n\nstatic void tegra_dc_set_clock_rate(struct tegra_dc *dc,\n\t\t\t\t    struct tegra_dc_state *state)\n{\n\tint err;\n\n\terr = clk_set_parent(dc->clk, state->clk);\n\tif (err < 0)\n\t\tdev_err(dc->dev, \"failed to set parent clock: %d\\n\", err);\n\n\t \n\tif (state->pclk > 0) {\n\t\terr = clk_set_rate(state->clk, state->pclk);\n\t\tif (err < 0)\n\t\t\tdev_err(dc->dev,\n\t\t\t\t\"failed to set clock rate to %lu Hz\\n\",\n\t\t\t\tstate->pclk);\n\n\t\terr = clk_set_rate(dc->clk, state->pclk);\n\t\tif (err < 0)\n\t\t\tdev_err(dc->dev, \"failed to set clock %pC to %lu Hz: %d\\n\",\n\t\t\t\tdc->clk, state->pclk, err);\n\t}\n\n\tDRM_DEBUG_KMS(\"rate: %lu, div: %u\\n\", clk_get_rate(dc->clk),\n\t\t      state->div);\n\tDRM_DEBUG_KMS(\"pclk: %lu\\n\", state->pclk);\n\n\ttegra_dc_update_voltage_state(dc, state);\n}\n\nstatic void tegra_dc_stop(struct tegra_dc *dc)\n{\n\tu32 value;\n\n\t \n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\n\ttegra_dc_commit(dc);\n}\n\nstatic bool tegra_dc_idle(struct tegra_dc *dc)\n{\n\tu32 value;\n\n\tvalue = tegra_dc_readl_active(dc, DC_CMD_DISPLAY_COMMAND);\n\n\treturn (value & DISP_CTRL_MODE_MASK) == 0;\n}\n\nstatic int tegra_dc_wait_idle(struct tegra_dc *dc, unsigned long timeout)\n{\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (tegra_dc_idle(dc))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tdev_dbg(dc->dev, \"timeout waiting for DC to become idle\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic void\ntegra_crtc_update_memory_bandwidth(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state,\n\t\t\t\t   bool prepare_bandwidth_transition)\n{\n\tconst struct tegra_plane_state *old_tegra_state, *new_tegra_state;\n\tu32 i, new_avg_bw, old_avg_bw, new_peak_bw, old_peak_bw;\n\tconst struct drm_plane_state *old_plane_state;\n\tconst struct drm_crtc_state *old_crtc_state;\n\tstruct tegra_dc_window window, old_window;\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tstruct tegra_plane *tegra;\n\tstruct drm_plane *plane;\n\n\tif (dc->soc->has_nvdisplay)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(state, crtc);\n\n\tif (!crtc->state->active) {\n\t\tif (!old_crtc_state->active)\n\t\t\treturn;\n\n\t\t \n\t\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\t\ttegra = to_tegra_plane(plane);\n\n\t\t\ticc_set_bw(tegra->icc_mem, 0, 0);\n\t\t\ticc_set_bw(tegra->icc_mem_vfilter, 0, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor_each_old_plane_in_state(old_crtc_state->state, plane,\n\t\t\t\t    old_plane_state, i) {\n\t\told_tegra_state = to_const_tegra_plane_state(old_plane_state);\n\t\tnew_tegra_state = to_const_tegra_plane_state(plane->state);\n\t\ttegra = to_tegra_plane(plane);\n\n\t\t \n\t\tif (tegra->dc != dc)\n\t\t\tcontinue;\n\n\t\tnew_avg_bw = new_tegra_state->avg_memory_bandwidth;\n\t\told_avg_bw = old_tegra_state->avg_memory_bandwidth;\n\n\t\tnew_peak_bw = new_tegra_state->total_peak_memory_bandwidth;\n\t\told_peak_bw = old_tegra_state->total_peak_memory_bandwidth;\n\n\t\t \n\t\tif (new_avg_bw == old_avg_bw && new_peak_bw == old_peak_bw &&\n\t\t    old_crtc_state->active)\n\t\t\tcontinue;\n\n\t\twindow.src.h = drm_rect_height(&plane->state->src) >> 16;\n\t\twindow.dst.h = drm_rect_height(&plane->state->dst);\n\n\t\told_window.src.h = drm_rect_height(&old_plane_state->src) >> 16;\n\t\told_window.dst.h = drm_rect_height(&old_plane_state->dst);\n\n\t\t \n\t\tif (prepare_bandwidth_transition) {\n\t\t\tnew_avg_bw = max(old_avg_bw, new_avg_bw);\n\t\t\tnew_peak_bw = max(old_peak_bw, new_peak_bw);\n\n\t\t\tif (tegra_plane_use_vertical_filtering(tegra, &old_window))\n\t\t\t\twindow = old_window;\n\t\t}\n\n\t\ticc_set_bw(tegra->icc_mem, new_avg_bw, new_peak_bw);\n\n\t\tif (tegra_plane_use_vertical_filtering(tegra, &window))\n\t\t\ticc_set_bw(tegra->icc_mem_vfilter, new_avg_bw, new_peak_bw);\n\t\telse\n\t\t\ticc_set_bw(tegra->icc_mem_vfilter, 0, 0);\n\t}\n}\n\nstatic void tegra_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\tint err;\n\n\tif (!tegra_dc_idle(dc)) {\n\t\ttegra_dc_stop(dc);\n\n\t\t \n\t\ttegra_dc_wait_idle(dc, 100);\n\t}\n\n\t \n\tif (dc->rgb) {\n\t\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\t\tvalue &= ~(PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t\t   PW4_ENABLE | PM0_ENABLE | PM1_ENABLE);\n\t\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\t}\n\n\ttegra_dc_stats_reset(&dc->stats);\n\tdrm_crtc_vblank_off(crtc);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\terr = host1x_client_suspend(&dc->client);\n\tif (err < 0)\n\t\tdev_err(dc->dev, \"failed to suspend: %d\\n\", err);\n\n\tif (dc->has_opp_table) {\n\t\terr = dev_pm_genpd_set_performance_state(dc->dev, 0);\n\t\tif (err)\n\t\t\tdev_err(dc->dev,\n\t\t\t\t\"failed to clear power domain state: %d\\n\", err);\n\t}\n}\n\nstatic void tegra_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct tegra_dc_state *crtc_state = to_dc_state(crtc->state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\tint err;\n\n\t \n\ttegra_dc_set_clock_rate(dc, crtc_state);\n\n\terr = host1x_client_resume(&dc->client);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\t \n\tif (dc->syncpt) {\n\t\tu32 syncpt = host1x_syncpt_id(dc->syncpt), enable;\n\n\t\tif (dc->soc->has_nvdisplay)\n\t\t\tenable = 1 << 31;\n\t\telse\n\t\t\tenable = 1 << 8;\n\n\t\tvalue = SYNCPT_CNTRL_NO_STALL;\n\t\ttegra_dc_writel(dc, value, DC_CMD_GENERAL_INCR_SYNCPT_CNTRL);\n\n\t\tvalue = enable | syncpt;\n\t\ttegra_dc_writel(dc, value, DC_CMD_CONT_SYNCPT_VSYNC);\n\t}\n\n\tif (dc->soc->has_nvdisplay) {\n\t\tvalue = DSC_TO_UF_INT | DSC_BBUF_UF_INT | DSC_RBUF_UF_INT |\n\t\t\tDSC_OBUF_UF_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_TYPE);\n\n\t\tvalue = DSC_TO_UF_INT | DSC_BBUF_UF_INT | DSC_RBUF_UF_INT |\n\t\t\tDSC_OBUF_UF_INT | SD3_BUCKET_WALK_DONE_INT |\n\t\t\tHEAD_UF_INT | MSF_INT | REG_TMOUT_INT |\n\t\t\tREGION_CRC_INT | V_PULSE2_INT | V_PULSE3_INT |\n\t\t\tVBLANK_INT | FRAME_END_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_POLARITY);\n\n\t\tvalue = SD3_BUCKET_WALK_DONE_INT | HEAD_UF_INT | VBLANK_INT |\n\t\t\tFRAME_END_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_ENABLE);\n\n\t\tvalue = HEAD_UF_INT | REG_TMOUT_INT | FRAME_END_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_MASK);\n\n\t\ttegra_dc_writel(dc, READ_MUX, DC_CMD_STATE_ACCESS);\n\t} else {\n\t\tvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT |\n\t\t\tWIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_TYPE);\n\n\t\tvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT |\n\t\t\tWIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_POLARITY);\n\n\t\t \n\t\tvalue = CURSOR_THRESHOLD(0) | WINDOW_A_THRESHOLD(0x20) |\n\t\t\tWINDOW_B_THRESHOLD(0x20) | WINDOW_C_THRESHOLD(0x20);\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_MEM_HIGH_PRIORITY);\n\n\t\tvalue = CURSOR_THRESHOLD(0) | WINDOW_A_THRESHOLD(1) |\n\t\t\tWINDOW_B_THRESHOLD(1) | WINDOW_C_THRESHOLD(1);\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_MEM_HIGH_PRIORITY_TIMER);\n\n\t\tvalue = VBLANK_INT | WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT |\n\t\t\tWIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_ENABLE);\n\n\t\tvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT |\n\t\t\tWIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT;\n\t\ttegra_dc_writel(dc, value, DC_CMD_INT_MASK);\n\t}\n\n\tif (dc->soc->supports_background_color)\n\t\ttegra_dc_writel(dc, 0, DC_DISP_BLEND_BACKGROUND_COLOR);\n\telse\n\t\ttegra_dc_writel(dc, 0, DC_DISP_BORDER_COLOR);\n\n\t \n\tif (!dc->soc->has_nvdisplay) {\n\t\tvalue = SHIFT_CLK_DIVIDER(crtc_state->div) | PIXEL_CLK_DIVIDER_PCD1;\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_CLOCK_CONTROL);\n\t}\n\n\t \n\ttegra_dc_set_timings(dc, mode);\n\n\t \n\tif (dc->soc->supports_interlacing) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\n\t\tvalue &= ~INTERLACE_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\n\t}\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\n\tvalue &= ~DISP_CTRL_MODE_MASK;\n\tvalue |= DISP_CTRL_MODE_C_DISPLAY;\n\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\n\n\tif (!dc->soc->has_nvdisplay) {\n\t\tvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\n\t\tvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\n\t\t\t PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\n\t}\n\n\t \n\tif (dc->soc->has_nvdisplay) {\n\t\tvalue = UNDERFLOW_MODE_RED | UNDERFLOW_REPORT_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_COM_RG_UNDERFLOW);\n\t}\n\n\tif (dc->rgb) {\n\t\t \n\t\tvalue = SC0_H_QUALIFIER_NONE | SC1_H_QUALIFIER_NONE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_SHIFT_CLOCK_OPTIONS);\n\t}\n\n\ttegra_dc_commit(dc);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void tegra_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tunsigned long flags;\n\n\ttegra_crtc_update_memory_bandwidth(crtc, state, true);\n\n\tif (crtc->state->event) {\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\n\t\tif (drm_crtc_vblank_get(crtc) != 0)\n\t\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\telse\n\t\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic void tegra_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct tegra_dc_state *dc_state = to_dc_state(crtc_state);\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tu32 value;\n\n\tvalue = dc_state->planes << 8 | GENERAL_UPDATE;\n\ttegra_dc_writel(dc, value, DC_CMD_STATE_CONTROL);\n\tvalue = tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\n\tvalue = dc_state->planes | GENERAL_ACT_REQ;\n\ttegra_dc_writel(dc, value, DC_CMD_STATE_CONTROL);\n\tvalue = tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n}\n\nstatic bool tegra_plane_is_cursor(const struct drm_plane_state *state)\n{\n\tconst struct tegra_dc_soc_info *soc = to_tegra_dc(state->crtc)->soc;\n\tconst struct drm_format_info *fmt = state->fb->format;\n\tunsigned int src_w = drm_rect_width(&state->src) >> 16;\n\tunsigned int dst_w = drm_rect_width(&state->dst);\n\n\tif (state->plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\treturn false;\n\n\tif (soc->supports_cursor)\n\t\treturn true;\n\n\tif (src_w != dst_w || fmt->num_planes != 1 || src_w * fmt->cpp[0] > 256)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic unsigned long\ntegra_plane_overlap_mask(struct drm_crtc_state *state,\n\t\t\t const struct drm_plane_state *plane_state)\n{\n\tconst struct drm_plane_state *other_state;\n\tconst struct tegra_plane *tegra;\n\tunsigned long overlap_mask = 0;\n\tstruct drm_plane *plane;\n\tstruct drm_rect rect;\n\n\tif (!plane_state->visible || !plane_state->fb)\n\t\treturn 0;\n\n\t \n\tif (tegra_plane_is_cursor(plane_state))\n\t\treturn 0;\n\n\tdrm_atomic_crtc_state_for_each_plane_state(plane, other_state, state) {\n\t\trect = plane_state->dst;\n\n\t\ttegra = to_tegra_plane(other_state->plane);\n\n\t\tif (!other_state->visible || !other_state->fb)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tegra_plane_is_cursor(other_state))\n\t\t\tcontinue;\n\n\t\tif (drm_rect_intersect(&rect, &other_state->dst))\n\t\t\toverlap_mask |= BIT(tegra->index);\n\t}\n\n\treturn overlap_mask;\n}\n\nstatic int tegra_crtc_calculate_memory_bandwidth(struct drm_crtc *crtc,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tulong overlap_mask[TEGRA_DC_LEGACY_PLANES_NUM] = {}, mask;\n\tu32 plane_peak_bw[TEGRA_DC_LEGACY_PLANES_NUM] = {};\n\tbool all_planes_overlap_simultaneously = true;\n\tconst struct tegra_plane_state *tegra_state;\n\tconst struct drm_plane_state *plane_state;\n\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\tstruct drm_crtc_state *new_state;\n\tstruct tegra_plane *tegra;\n\tstruct drm_plane *plane;\n\n\t \n\tif (dc->soc->has_nvdisplay)\n\t\treturn 0;\n\n\tnew_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\t \n\tdrm_atomic_crtc_state_for_each_plane_state(plane, plane_state, new_state) {\n\t\ttegra_state = to_const_tegra_plane_state(plane_state);\n\t\ttegra = to_tegra_plane(plane);\n\n\t\tif (WARN_ON_ONCE(tegra->index >= TEGRA_DC_LEGACY_PLANES_NUM))\n\t\t\treturn -EINVAL;\n\n\t\tplane_peak_bw[tegra->index] = tegra_state->peak_memory_bandwidth;\n\t\tmask = tegra_plane_overlap_mask(new_state, plane_state);\n\t\toverlap_mask[tegra->index] = mask;\n\n\t\tif (hweight_long(mask) != 3)\n\t\t\tall_planes_overlap_simultaneously = false;\n\t}\n\n\t \n\tdrm_atomic_crtc_state_for_each_plane_state(plane, plane_state, new_state) {\n\t\tu32 i, old_peak_bw, new_peak_bw, overlap_bw = 0;\n\n\t\t \n\t\ttegra_state = to_const_tegra_plane_state(plane_state);\n\t\ttegra = to_tegra_plane(plane);\n\n\t\tfor_each_set_bit(i, &overlap_mask[tegra->index], 3) {\n\t\t\tif (i == tegra->index)\n\t\t\t\tcontinue;\n\n\t\t\tif (all_planes_overlap_simultaneously)\n\t\t\t\toverlap_bw += plane_peak_bw[i];\n\t\t\telse\n\t\t\t\toverlap_bw = max(overlap_bw, plane_peak_bw[i]);\n\t\t}\n\n\t\tnew_peak_bw = plane_peak_bw[tegra->index] + overlap_bw;\n\t\told_peak_bw = tegra_state->total_peak_memory_bandwidth;\n\n\t\t \n\t\tif (old_peak_bw != new_peak_bw) {\n\t\t\tstruct tegra_plane_state *new_tegra_state;\n\t\t\tstruct drm_plane_state *new_plane_state;\n\n\t\t\tnew_plane_state = drm_atomic_get_plane_state(state, plane);\n\t\t\tif (IS_ERR(new_plane_state))\n\t\t\t\treturn PTR_ERR(new_plane_state);\n\n\t\t\tnew_tegra_state = to_tegra_plane_state(new_plane_state);\n\t\t\tnew_tegra_state->total_peak_memory_bandwidth = new_peak_bw;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tint err;\n\n\terr = tegra_crtc_calculate_memory_bandwidth(crtc, state);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nvoid tegra_crtc_atomic_post_commit(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\t \n\ttegra_crtc_update_memory_bandwidth(crtc, state, false);\n}\n\nstatic const struct drm_crtc_helper_funcs tegra_crtc_helper_funcs = {\n\t.atomic_check = tegra_crtc_atomic_check,\n\t.atomic_begin = tegra_crtc_atomic_begin,\n\t.atomic_flush = tegra_crtc_atomic_flush,\n\t.atomic_enable = tegra_crtc_atomic_enable,\n\t.atomic_disable = tegra_crtc_atomic_disable,\n};\n\nstatic irqreturn_t tegra_dc_irq(int irq, void *data)\n{\n\tstruct tegra_dc *dc = data;\n\tunsigned long status;\n\n\tstatus = tegra_dc_readl(dc, DC_CMD_INT_STATUS);\n\ttegra_dc_writel(dc, status, DC_CMD_INT_STATUS);\n\n\tif (status & FRAME_END_INT) {\n\t\t \n\t\tdc->stats.frames_total++;\n\t\tdc->stats.frames++;\n\t}\n\n\tif (status & VBLANK_INT) {\n\t\t \n\t\tdrm_crtc_handle_vblank(&dc->base);\n\t\tdc->stats.vblank_total++;\n\t\tdc->stats.vblank++;\n\t}\n\n\tif (status & (WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT)) {\n\t\t \n\t\tdc->stats.underflow_total++;\n\t\tdc->stats.underflow++;\n\t}\n\n\tif (status & (WIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT)) {\n\t\t \n\t\tdc->stats.overflow_total++;\n\t\tdc->stats.overflow++;\n\t}\n\n\tif (status & HEAD_UF_INT) {\n\t\tdev_dbg_ratelimited(dc->dev, \"%s(): head underflow\\n\", __func__);\n\t\tdc->stats.underflow_total++;\n\t\tdc->stats.underflow++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool tegra_dc_has_window_groups(struct tegra_dc *dc)\n{\n\tunsigned int i;\n\n\tif (!dc->soc->wgrps)\n\t\treturn true;\n\n\tfor (i = 0; i < dc->soc->num_wgrps; i++) {\n\t\tconst struct tegra_windowgroup_soc *wgrp = &dc->soc->wgrps[i];\n\n\t\tif (wgrp->dc == dc->pipe && wgrp->num_windows > 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_dc_early_init(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\n\ttegra->num_crtcs++;\n\n\treturn 0;\n}\n\nstatic int tegra_dc_init(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tunsigned long flags = HOST1X_SYNCPT_CLIENT_MANAGED;\n\tstruct tegra_dc *dc = host1x_client_to_dc(client);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct drm_plane *primary = NULL;\n\tstruct drm_plane *cursor = NULL;\n\tint err;\n\n\t \n\thost1x_syncpt_release_vblank_reservation(client, 26 + dc->pipe);\n\n\t \n\tif (!tegra_dc_has_window_groups(dc))\n\t\treturn 0;\n\n\t \n\tif (dc->soc->has_nvdisplay)\n\t\tclient->parent = &tegra->hub->client;\n\n\tdc->syncpt = host1x_syncpt_request(client, flags);\n\tif (!dc->syncpt)\n\t\tdev_warn(dc->dev, \"failed to allocate syncpoint\\n\");\n\n\terr = host1x_client_iommu_attach(client);\n\tif (err < 0 && err != -ENODEV) {\n\t\tdev_err(client->dev, \"failed to attach to domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (dc->soc->wgrps)\n\t\tprimary = tegra_dc_add_shared_planes(drm, dc);\n\telse\n\t\tprimary = tegra_dc_add_planes(drm, dc);\n\n\tif (IS_ERR(primary)) {\n\t\terr = PTR_ERR(primary);\n\t\tgoto cleanup;\n\t}\n\n\tif (dc->soc->supports_cursor) {\n\t\tcursor = tegra_dc_cursor_plane_create(drm, dc);\n\t\tif (IS_ERR(cursor)) {\n\t\t\terr = PTR_ERR(cursor);\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\t \n\t\tcursor = tegra_dc_overlay_plane_create(drm, dc, 2, true);\n\t\tif (IS_ERR(cursor)) {\n\t\t\terr = PTR_ERR(cursor);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\terr = drm_crtc_init_with_planes(drm, &dc->base, primary, cursor,\n\t\t\t\t\t&tegra_crtc_funcs, NULL);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\tdrm_crtc_helper_add(&dc->base, &tegra_crtc_helper_funcs);\n\n\t \n\tif (dc->soc->pitch_align > tegra->pitch_align)\n\t\ttegra->pitch_align = dc->soc->pitch_align;\n\n\t \n\tif (dc->soc->has_nvdisplay)\n\t\tdrm->mode_config.max_width = drm->mode_config.max_height = 16384;\n\telse\n\t\tdrm->mode_config.max_width = drm->mode_config.max_height = 4096;\n\n\terr = tegra_dc_rgb_init(drm, dc);\n\tif (err < 0 && err != -ENODEV) {\n\t\tdev_err(dc->dev, \"failed to initialize RGB output: %d\\n\", err);\n\t\tgoto cleanup;\n\t}\n\n\terr = devm_request_irq(dc->dev, dc->irq, tegra_dc_irq, 0,\n\t\t\t       dev_name(dc->dev), dc);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to request IRQ#%u: %d\\n\", dc->irq,\n\t\t\terr);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tclient->dev->dma_parms = client->host->dma_parms;\n\n\treturn 0;\n\ncleanup:\n\tif (!IS_ERR_OR_NULL(cursor))\n\t\tdrm_plane_cleanup(cursor);\n\n\tif (!IS_ERR(primary))\n\t\tdrm_plane_cleanup(primary);\n\n\thost1x_client_iommu_detach(client);\n\thost1x_syncpt_put(dc->syncpt);\n\n\treturn err;\n}\n\nstatic int tegra_dc_exit(struct host1x_client *client)\n{\n\tstruct tegra_dc *dc = host1x_client_to_dc(client);\n\tint err;\n\n\tif (!tegra_dc_has_window_groups(dc))\n\t\treturn 0;\n\n\t \n\tclient->dev->dma_parms = NULL;\n\n\tdevm_free_irq(dc->dev, dc->irq, dc);\n\n\terr = tegra_dc_rgb_exit(dc);\n\tif (err) {\n\t\tdev_err(dc->dev, \"failed to shutdown RGB output: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thost1x_client_iommu_detach(client);\n\thost1x_syncpt_put(dc->syncpt);\n\n\treturn 0;\n}\n\nstatic int tegra_dc_late_exit(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\n\ttegra->num_crtcs--;\n\n\treturn 0;\n}\n\nstatic int tegra_dc_runtime_suspend(struct host1x_client *client)\n{\n\tstruct tegra_dc *dc = host1x_client_to_dc(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = reset_control_assert(dc->rst);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (dc->soc->has_powergate)\n\t\ttegra_powergate_power_off(dc->powergate);\n\n\tclk_disable_unprepare(dc->clk);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int tegra_dc_runtime_resume(struct host1x_client *client)\n{\n\tstruct tegra_dc *dc = host1x_client_to_dc(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get runtime PM: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (dc->soc->has_powergate) {\n\t\terr = tegra_powergate_sequence_power_up(dc->powergate, dc->clk,\n\t\t\t\t\t\t\tdc->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to power partition: %d\\n\", err);\n\t\t\tgoto put_rpm;\n\t\t}\n\t} else {\n\t\terr = clk_prepare_enable(dc->clk);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\t\tgoto put_rpm;\n\t\t}\n\n\t\terr = reset_control_deassert(dc->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(dc->clk);\nput_rpm:\n\tpm_runtime_put_sync(dev);\n\treturn err;\n}\n\nstatic const struct host1x_client_ops dc_client_ops = {\n\t.early_init = tegra_dc_early_init,\n\t.init = tegra_dc_init,\n\t.exit = tegra_dc_exit,\n\t.late_exit = tegra_dc_late_exit,\n\t.suspend = tegra_dc_runtime_suspend,\n\t.resume = tegra_dc_runtime_resume,\n};\n\nstatic const struct tegra_dc_soc_info tegra20_dc_soc_info = {\n\t.supports_background_color = false,\n\t.supports_interlacing = false,\n\t.supports_cursor = false,\n\t.supports_block_linear = false,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = true,\n\t.pitch_align = 8,\n\t.has_powergate = false,\n\t.coupled_pm = true,\n\t.has_nvdisplay = false,\n\t.num_primary_formats = ARRAY_SIZE(tegra20_primary_formats),\n\t.primary_formats = tegra20_primary_formats,\n\t.num_overlay_formats = ARRAY_SIZE(tegra20_overlay_formats),\n\t.overlay_formats = tegra20_overlay_formats,\n\t.modifiers = tegra20_modifiers,\n\t.has_win_a_without_filters = true,\n\t.has_win_b_vfilter_mem_client = true,\n\t.has_win_c_without_vert_filter = true,\n\t.plane_tiled_memory_bandwidth_x2 = false,\n\t.has_pll_d2_out0 = false,\n};\n\nstatic const struct tegra_dc_soc_info tegra30_dc_soc_info = {\n\t.supports_background_color = false,\n\t.supports_interlacing = false,\n\t.supports_cursor = false,\n\t.supports_block_linear = false,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = true,\n\t.pitch_align = 8,\n\t.has_powergate = false,\n\t.coupled_pm = false,\n\t.has_nvdisplay = false,\n\t.num_primary_formats = ARRAY_SIZE(tegra20_primary_formats),\n\t.primary_formats = tegra20_primary_formats,\n\t.num_overlay_formats = ARRAY_SIZE(tegra20_overlay_formats),\n\t.overlay_formats = tegra20_overlay_formats,\n\t.modifiers = tegra20_modifiers,\n\t.has_win_a_without_filters = false,\n\t.has_win_b_vfilter_mem_client = true,\n\t.has_win_c_without_vert_filter = false,\n\t.plane_tiled_memory_bandwidth_x2 = true,\n\t.has_pll_d2_out0 = true,\n};\n\nstatic const struct tegra_dc_soc_info tegra114_dc_soc_info = {\n\t.supports_background_color = false,\n\t.supports_interlacing = false,\n\t.supports_cursor = false,\n\t.supports_block_linear = false,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = true,\n\t.pitch_align = 64,\n\t.has_powergate = true,\n\t.coupled_pm = false,\n\t.has_nvdisplay = false,\n\t.num_primary_formats = ARRAY_SIZE(tegra114_primary_formats),\n\t.primary_formats = tegra114_primary_formats,\n\t.num_overlay_formats = ARRAY_SIZE(tegra114_overlay_formats),\n\t.overlay_formats = tegra114_overlay_formats,\n\t.modifiers = tegra20_modifiers,\n\t.has_win_a_without_filters = false,\n\t.has_win_b_vfilter_mem_client = false,\n\t.has_win_c_without_vert_filter = false,\n\t.plane_tiled_memory_bandwidth_x2 = true,\n\t.has_pll_d2_out0 = true,\n};\n\nstatic const struct tegra_dc_soc_info tegra124_dc_soc_info = {\n\t.supports_background_color = true,\n\t.supports_interlacing = true,\n\t.supports_cursor = true,\n\t.supports_block_linear = true,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = false,\n\t.pitch_align = 64,\n\t.has_powergate = true,\n\t.coupled_pm = false,\n\t.has_nvdisplay = false,\n\t.num_primary_formats = ARRAY_SIZE(tegra124_primary_formats),\n\t.primary_formats = tegra124_primary_formats,\n\t.num_overlay_formats = ARRAY_SIZE(tegra124_overlay_formats),\n\t.overlay_formats = tegra124_overlay_formats,\n\t.modifiers = tegra124_modifiers,\n\t.has_win_a_without_filters = false,\n\t.has_win_b_vfilter_mem_client = false,\n\t.has_win_c_without_vert_filter = false,\n\t.plane_tiled_memory_bandwidth_x2 = false,\n\t.has_pll_d2_out0 = true,\n};\n\nstatic const struct tegra_dc_soc_info tegra210_dc_soc_info = {\n\t.supports_background_color = true,\n\t.supports_interlacing = true,\n\t.supports_cursor = true,\n\t.supports_block_linear = true,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = false,\n\t.pitch_align = 64,\n\t.has_powergate = true,\n\t.coupled_pm = false,\n\t.has_nvdisplay = false,\n\t.num_primary_formats = ARRAY_SIZE(tegra114_primary_formats),\n\t.primary_formats = tegra114_primary_formats,\n\t.num_overlay_formats = ARRAY_SIZE(tegra114_overlay_formats),\n\t.overlay_formats = tegra114_overlay_formats,\n\t.modifiers = tegra124_modifiers,\n\t.has_win_a_without_filters = false,\n\t.has_win_b_vfilter_mem_client = false,\n\t.has_win_c_without_vert_filter = false,\n\t.plane_tiled_memory_bandwidth_x2 = false,\n\t.has_pll_d2_out0 = true,\n};\n\nstatic const struct tegra_windowgroup_soc tegra186_dc_wgrps[] = {\n\t{\n\t\t.index = 0,\n\t\t.dc = 0,\n\t\t.windows = (const unsigned int[]) { 0 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 1,\n\t\t.dc = 1,\n\t\t.windows = (const unsigned int[]) { 1 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 2,\n\t\t.dc = 1,\n\t\t.windows = (const unsigned int[]) { 2 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 3,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 3 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 4,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 4 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 5,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 5 },\n\t\t.num_windows = 1,\n\t},\n};\n\nstatic const struct tegra_dc_soc_info tegra186_dc_soc_info = {\n\t.supports_background_color = true,\n\t.supports_interlacing = true,\n\t.supports_cursor = true,\n\t.supports_block_linear = true,\n\t.supports_sector_layout = false,\n\t.has_legacy_blending = false,\n\t.pitch_align = 64,\n\t.has_powergate = false,\n\t.coupled_pm = false,\n\t.has_nvdisplay = true,\n\t.wgrps = tegra186_dc_wgrps,\n\t.num_wgrps = ARRAY_SIZE(tegra186_dc_wgrps),\n\t.plane_tiled_memory_bandwidth_x2 = false,\n\t.has_pll_d2_out0 = false,\n};\n\nstatic const struct tegra_windowgroup_soc tegra194_dc_wgrps[] = {\n\t{\n\t\t.index = 0,\n\t\t.dc = 0,\n\t\t.windows = (const unsigned int[]) { 0 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 1,\n\t\t.dc = 1,\n\t\t.windows = (const unsigned int[]) { 1 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 2,\n\t\t.dc = 1,\n\t\t.windows = (const unsigned int[]) { 2 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 3,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 3 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 4,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 4 },\n\t\t.num_windows = 1,\n\t}, {\n\t\t.index = 5,\n\t\t.dc = 2,\n\t\t.windows = (const unsigned int[]) { 5 },\n\t\t.num_windows = 1,\n\t},\n};\n\nstatic const struct tegra_dc_soc_info tegra194_dc_soc_info = {\n\t.supports_background_color = true,\n\t.supports_interlacing = true,\n\t.supports_cursor = true,\n\t.supports_block_linear = true,\n\t.supports_sector_layout = true,\n\t.has_legacy_blending = false,\n\t.pitch_align = 64,\n\t.has_powergate = false,\n\t.coupled_pm = false,\n\t.has_nvdisplay = true,\n\t.wgrps = tegra194_dc_wgrps,\n\t.num_wgrps = ARRAY_SIZE(tegra194_dc_wgrps),\n\t.plane_tiled_memory_bandwidth_x2 = false,\n\t.has_pll_d2_out0 = false,\n};\n\nstatic const struct of_device_id tegra_dc_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra194-dc\",\n\t\t.data = &tegra194_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra186-dc\",\n\t\t.data = &tegra186_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra210-dc\",\n\t\t.data = &tegra210_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra124-dc\",\n\t\t.data = &tegra124_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra114-dc\",\n\t\t.data = &tegra114_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra30-dc\",\n\t\t.data = &tegra30_dc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra20-dc\",\n\t\t.data = &tegra20_dc_soc_info,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, tegra_dc_of_match);\n\nstatic int tegra_dc_parse_dt(struct tegra_dc *dc)\n{\n\tstruct device_node *np;\n\tu32 value = 0;\n\tint err;\n\n\terr = of_property_read_u32(dc->dev->of_node, \"nvidia,head\", &value);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"missing \\\"nvidia,head\\\" property\\n\");\n\n\t\t \n\t\tfor_each_matching_node(np, tegra_dc_of_match) {\n\t\t\tif (np == dc->dev->of_node) {\n\t\t\t\tof_node_put(np);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvalue++;\n\t\t}\n\t}\n\n\tdc->pipe = value;\n\n\treturn 0;\n}\n\nstatic int tegra_dc_match_by_pipe(struct device *dev, const void *data)\n{\n\tstruct tegra_dc *dc = dev_get_drvdata(dev);\n\tunsigned int pipe = (unsigned long)(void *)data;\n\n\treturn dc->pipe == pipe;\n}\n\nstatic int tegra_dc_couple(struct tegra_dc *dc)\n{\n\t \n\tif (dc->soc->coupled_pm && dc->pipe == 1) {\n\t\tstruct device *companion;\n\t\tstruct tegra_dc *parent;\n\n\t\tcompanion = driver_find_device(dc->dev->driver, NULL, (const void *)0,\n\t\t\t\t\t       tegra_dc_match_by_pipe);\n\t\tif (!companion)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tparent = dev_get_drvdata(companion);\n\t\tdc->client.parent = &parent->client;\n\n\t\tdev_dbg(dc->dev, \"coupled to %s\\n\", dev_name(companion));\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_dc_init_opp_table(struct tegra_dc *dc)\n{\n\tstruct tegra_core_opp_params opp_params = {};\n\tint err;\n\n\terr = devm_tegra_core_dev_init_opp_table(dc->dev, &opp_params);\n\tif (err && err != -ENODEV)\n\t\treturn err;\n\n\tif (err)\n\t\tdc->has_opp_table = false;\n\telse\n\t\tdc->has_opp_table = true;\n\n\treturn 0;\n}\n\nstatic int tegra_dc_probe(struct platform_device *pdev)\n{\n\tu64 dma_mask = dma_get_mask(pdev->dev.parent);\n\tstruct tegra_dc *dc;\n\tint err;\n\n\terr = dma_coerce_mask_and_coherent(&pdev->dev, dma_mask);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdc = devm_kzalloc(&pdev->dev, sizeof(*dc), GFP_KERNEL);\n\tif (!dc)\n\t\treturn -ENOMEM;\n\n\tdc->soc = of_device_get_match_data(&pdev->dev);\n\n\tINIT_LIST_HEAD(&dc->list);\n\tdc->dev = &pdev->dev;\n\n\terr = tegra_dc_parse_dt(dc);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_dc_couple(dc);\n\tif (err < 0)\n\t\treturn err;\n\n\tdc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dc->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(dc->clk);\n\t}\n\n\tdc->rst = devm_reset_control_get(&pdev->dev, \"dc\");\n\tif (IS_ERR(dc->rst)) {\n\t\tdev_err(&pdev->dev, \"failed to get reset\\n\");\n\t\treturn PTR_ERR(dc->rst);\n\t}\n\n\t \n\terr = clk_prepare_enable(dc->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(2000, 4000);\n\n\terr = reset_control_assert(dc->rst);\n\tif (err < 0) {\n\t\tclk_disable_unprepare(dc->clk);\n\t\treturn err;\n\t}\n\n\tusleep_range(2000, 4000);\n\n\tclk_disable_unprepare(dc->clk);\n\n\tif (dc->soc->has_powergate) {\n\t\tif (dc->pipe == 0)\n\t\t\tdc->powergate = TEGRA_POWERGATE_DIS;\n\t\telse\n\t\t\tdc->powergate = TEGRA_POWERGATE_DISB;\n\n\t\ttegra_powergate_power_off(dc->powergate);\n\t}\n\n\terr = tegra_dc_init_opp_table(dc);\n\tif (err < 0)\n\t\treturn err;\n\n\tdc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dc->regs))\n\t\treturn PTR_ERR(dc->regs);\n\n\tdc->irq = platform_get_irq(pdev, 0);\n\tif (dc->irq < 0)\n\t\treturn -ENXIO;\n\n\terr = tegra_dc_rgb_probe(dc);\n\tif (err < 0 && err != -ENODEV)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"failed to probe RGB output\\n\");\n\n\tplatform_set_drvdata(pdev, dc);\n\tpm_runtime_enable(&pdev->dev);\n\n\tINIT_LIST_HEAD(&dc->client.list);\n\tdc->client.ops = &dc_client_ops;\n\tdc->client.dev = &pdev->dev;\n\n\terr = host1x_client_register(&dc->client);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\t\tgoto disable_pm;\n\t}\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(&pdev->dev);\n\ttegra_dc_rgb_remove(dc);\n\n\treturn err;\n}\n\nstatic void tegra_dc_remove(struct platform_device *pdev)\n{\n\tstruct tegra_dc *dc = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&dc->client);\n\n\ttegra_dc_rgb_remove(dc);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstruct platform_driver tegra_dc_driver = {\n\t.driver = {\n\t\t.name = \"tegra-dc\",\n\t\t.of_match_table = tegra_dc_of_match,\n\t},\n\t.probe = tegra_dc_probe,\n\t.remove_new = tegra_dc_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}