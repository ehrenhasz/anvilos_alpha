{
  "module_name": "rgb.c",
  "hash_id": "44de9a151b8e91457db82aabf583d4a59d8b9a4e24d36b10a220950d700fc65f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/rgb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"drm.h\"\n#include \"dc.h\"\n\nstruct tegra_rgb {\n\tstruct tegra_output output;\n\tstruct tegra_dc *dc;\n\n\tstruct clk *pll_d_out0;\n\tstruct clk *pll_d2_out0;\n\tstruct clk *clk_parent;\n\tstruct clk *clk;\n};\n\nstatic inline struct tegra_rgb *to_rgb(struct tegra_output *output)\n{\n\treturn container_of(output, struct tegra_rgb, output);\n}\n\nstruct reg_entry {\n\tunsigned long offset;\n\tunsigned long value;\n};\n\nstatic const struct reg_entry rgb_enable[] = {\n\t{ DC_COM_PIN_OUTPUT_ENABLE(0),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(1),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(2),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(3),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(0), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(1), 0x01000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(2), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(3), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_DATA(0),     0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_DATA(1),     0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_DATA(2),     0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_DATA(3),     0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(0),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(1),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(2),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(3),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(4),   0x00210222 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(5),   0x00002200 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(6),   0x00020000 },\n};\n\nstatic const struct reg_entry rgb_disable[] = {\n\t{ DC_COM_PIN_OUTPUT_SELECT(6),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(5),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(4),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(3),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(2),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(1),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_SELECT(0),   0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_DATA(3),     0xaaaaaaaa },\n\t{ DC_COM_PIN_OUTPUT_DATA(2),     0xaaaaaaaa },\n\t{ DC_COM_PIN_OUTPUT_DATA(1),     0xaaaaaaaa },\n\t{ DC_COM_PIN_OUTPUT_DATA(0),     0xaaaaaaaa },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(3), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(2), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(1), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_POLARITY(0), 0x00000000 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(3),   0x55555555 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(2),   0x55555555 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(1),   0x55150005 },\n\t{ DC_COM_PIN_OUTPUT_ENABLE(0),   0x55555555 },\n};\n\nstatic void tegra_dc_write_regs(struct tegra_dc *dc,\n\t\t\t\tconst struct reg_entry *table,\n\t\t\t\tunsigned int num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\ttegra_dc_writel(dc, table[i].value, table[i].offset);\n}\n\nstatic void tegra_rgb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_rgb *rgb = to_rgb(output);\n\n\ttegra_dc_write_regs(rgb->dc, rgb_disable, ARRAY_SIZE(rgb_disable));\n\ttegra_dc_commit(rgb->dc);\n}\n\nstatic void tegra_rgb_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_rgb *rgb = to_rgb(output);\n\tu32 value;\n\n\ttegra_dc_write_regs(rgb->dc, rgb_enable, ARRAY_SIZE(rgb_enable));\n\n\tvalue = DE_SELECT_ACTIVE | DE_CONTROL_NORMAL;\n\ttegra_dc_writel(rgb->dc, value, DC_DISP_DATA_ENABLE_OPTIONS);\n\n\t \n\tvalue = tegra_dc_readl(rgb->dc, DC_COM_PIN_OUTPUT_POLARITY(1));\n\tvalue &= ~LVS_OUTPUT_POLARITY_LOW;\n\tvalue &= ~LHS_OUTPUT_POLARITY_LOW;\n\ttegra_dc_writel(rgb->dc, value, DC_COM_PIN_OUTPUT_POLARITY(1));\n\n\t \n\tvalue = DISP_DATA_FORMAT_DF1P1C | DISP_ALIGNMENT_MSB |\n\t\tDISP_ORDER_RED_BLUE;\n\ttegra_dc_writel(rgb->dc, value, DC_DISP_DISP_INTERFACE_CONTROL);\n\n\ttegra_dc_commit(rgb->dc);\n}\n\nstatic bool tegra_rgb_pll_rate_change_allowed(struct tegra_rgb *rgb)\n{\n\tif (!rgb->pll_d2_out0)\n\t\treturn false;\n\n\tif (!clk_is_match(rgb->clk_parent, rgb->pll_d_out0) &&\n\t    !clk_is_match(rgb->clk_parent, rgb->pll_d2_out0))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\ntegra_rgb_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\n\tunsigned long pclk = crtc_state->mode.clock * 1000;\n\tstruct tegra_rgb *rgb = to_rgb(output);\n\tunsigned int div;\n\tint err;\n\n\t \n\tif (tegra_rgb_pll_rate_change_allowed(rgb)) {\n\t\t \n\t\tdiv = 2;\n\t\tpclk *= 2;\n\t} else {\n\t\tdiv = ((clk_get_rate(rgb->clk) * 2) / pclk) - 2;\n\t\tpclk = 0;\n\t}\n\n\terr = tegra_dc_state_setup_clock(dc, crtc_state, rgb->clk_parent,\n\t\t\t\t\t pclk, div);\n\tif (err < 0) {\n\t\tdev_err(output->dev, \"failed to setup CRTC state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic const struct drm_encoder_helper_funcs tegra_rgb_encoder_helper_funcs = {\n\t.disable = tegra_rgb_encoder_disable,\n\t.enable = tegra_rgb_encoder_enable,\n\t.atomic_check = tegra_rgb_encoder_atomic_check,\n};\n\nint tegra_dc_rgb_probe(struct tegra_dc *dc)\n{\n\tstruct device_node *np;\n\tstruct tegra_rgb *rgb;\n\tint err;\n\n\tnp = of_get_child_by_name(dc->dev->of_node, \"rgb\");\n\tif (!np || !of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\trgb = devm_kzalloc(dc->dev, sizeof(*rgb), GFP_KERNEL);\n\tif (!rgb)\n\t\treturn -ENOMEM;\n\n\trgb->output.dev = dc->dev;\n\trgb->output.of_node = np;\n\trgb->dc = dc;\n\n\terr = tegra_output_probe(&rgb->output);\n\tif (err < 0)\n\t\treturn err;\n\n\trgb->clk = devm_clk_get(dc->dev, NULL);\n\tif (IS_ERR(rgb->clk)) {\n\t\tdev_err(dc->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(rgb->clk);\n\t}\n\n\trgb->clk_parent = devm_clk_get(dc->dev, \"parent\");\n\tif (IS_ERR(rgb->clk_parent)) {\n\t\tdev_err(dc->dev, \"failed to get parent clock\\n\");\n\t\treturn PTR_ERR(rgb->clk_parent);\n\t}\n\n\terr = clk_set_parent(rgb->clk, rgb->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to set parent clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\trgb->pll_d_out0 = clk_get_sys(NULL, \"pll_d_out0\");\n\tif (IS_ERR(rgb->pll_d_out0)) {\n\t\terr = PTR_ERR(rgb->pll_d_out0);\n\t\tdev_err(dc->dev, \"failed to get pll_d_out0: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (dc->soc->has_pll_d2_out0) {\n\t\trgb->pll_d2_out0 = clk_get_sys(NULL, \"pll_d2_out0\");\n\t\tif (IS_ERR(rgb->pll_d2_out0)) {\n\t\t\terr = PTR_ERR(rgb->pll_d2_out0);\n\t\t\tdev_err(dc->dev, \"failed to get pll_d2_out0: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdc->rgb = &rgb->output;\n\n\treturn 0;\n}\n\nvoid tegra_dc_rgb_remove(struct tegra_dc *dc)\n{\n\tstruct tegra_rgb *rgb;\n\n\tif (!dc->rgb)\n\t\treturn;\n\n\trgb = to_rgb(dc->rgb);\n\tclk_put(rgb->pll_d2_out0);\n\tclk_put(rgb->pll_d_out0);\n\n\ttegra_output_remove(dc->rgb);\n\tdc->rgb = NULL;\n}\n\nint tegra_dc_rgb_init(struct drm_device *drm, struct tegra_dc *dc)\n{\n\tstruct tegra_output *output = dc->rgb;\n\tstruct drm_connector *connector;\n\tint err;\n\n\tif (!dc->rgb)\n\t\treturn -ENODEV;\n\n\tdrm_simple_encoder_init(drm, &output->encoder, DRM_MODE_ENCODER_LVDS);\n\tdrm_encoder_helper_add(&output->encoder,\n\t\t\t       &tegra_rgb_encoder_helper_funcs);\n\n\t \n\tif (output->panel) {\n\t\toutput->bridge = devm_drm_panel_bridge_add(output->dev,\n\t\t\t\t\t\t\t   output->panel);\n\t\tif (IS_ERR(output->bridge)) {\n\t\t\tdev_err(output->dev,\n\t\t\t\t\"failed to wrap panel into bridge: %pe\\n\",\n\t\t\t\toutput->bridge);\n\t\t\treturn PTR_ERR(output->bridge);\n\t\t}\n\n\t\toutput->panel = NULL;\n\t}\n\n\t \n\tif (output->bridge) {\n\t\terr = drm_bridge_attach(&output->encoder, output->bridge,\n\t\t\t\t\tNULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tconnector = drm_bridge_connector_init(drm, &output->encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tdev_err(output->dev,\n\t\t\t\t\"failed to initialize bridge connector: %pe\\n\",\n\t\t\t\tconnector);\n\t\t\treturn PTR_ERR(connector);\n\t\t}\n\n\t\tdrm_connector_attach_encoder(connector, &output->encoder);\n\t}\n\n\terr = tegra_output_init(drm, output);\n\tif (err < 0) {\n\t\tdev_err(output->dev, \"failed to initialize output: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\toutput->encoder.possible_crtcs = drm_crtc_mask(&dc->base);\n\n\treturn 0;\n}\n\nint tegra_dc_rgb_exit(struct tegra_dc *dc)\n{\n\tif (dc->rgb)\n\t\ttegra_output_exit(dc->rgb);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}