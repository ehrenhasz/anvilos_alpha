{
  "module_name": "nvdec.c",
  "hash_id": "7ecec86dc8d1564633d9fec5ac81430bdd0d9dda8c340878904a38aa48e54c26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/nvdec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/mc.h>\n\n#include \"drm.h\"\n#include \"falcon.h\"\n#include \"riscv.h\"\n#include \"vic.h\"\n\n#define NVDEC_FALCON_DEBUGINFO\t\t\t0x1094\n#define NVDEC_TFBIF_TRANSCFG\t\t\t0x2c44\n\nstruct nvdec_config {\n\tconst char *firmware;\n\tunsigned int version;\n\tbool supports_sid;\n\tbool has_riscv;\n\tbool has_extra_clocks;\n};\n\nstruct nvdec {\n\tstruct falcon falcon;\n\n\tvoid __iomem *regs;\n\tstruct tegra_drm_client client;\n\tstruct host1x_channel *channel;\n\tstruct device *dev;\n\tstruct clk_bulk_data clks[3];\n\tunsigned int num_clks;\n\tstruct reset_control *reset;\n\n\t \n\tconst struct nvdec_config *config;\n\n\t \n\tstruct tegra_drm_riscv riscv;\n\tphys_addr_t carveout_base;\n};\n\nstatic inline struct nvdec *to_nvdec(struct tegra_drm_client *client)\n{\n\treturn container_of(client, struct nvdec, client);\n}\n\nstatic inline void nvdec_writel(struct nvdec *nvdec, u32 value,\n\t\t\t\tunsigned int offset)\n{\n\twritel(value, nvdec->regs + offset);\n}\n\nstatic int nvdec_boot_falcon(struct nvdec *nvdec)\n{\n\tu32 stream_id;\n\tint err;\n\n\tif (nvdec->config->supports_sid && tegra_dev_iommu_get_stream_id(nvdec->dev, &stream_id)) {\n\t\tu32 value;\n\n\t\tvalue = TRANSCFG_ATT(1, TRANSCFG_SID_FALCON) | TRANSCFG_ATT(0, TRANSCFG_SID_HW);\n\t\tnvdec_writel(nvdec, value, NVDEC_TFBIF_TRANSCFG);\n\n\t\tnvdec_writel(nvdec, stream_id, VIC_THI_STREAMID0);\n\t\tnvdec_writel(nvdec, stream_id, VIC_THI_STREAMID1);\n\t}\n\n\terr = falcon_boot(&nvdec->falcon);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = falcon_wait_idle(&nvdec->falcon);\n\tif (err < 0) {\n\t\tdev_err(nvdec->dev, \"falcon boot timed out\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nvdec_wait_debuginfo(struct nvdec *nvdec, const char *phase)\n{\n\tint err;\n\tu32 val;\n\n\terr = readl_poll_timeout(nvdec->regs + NVDEC_FALCON_DEBUGINFO, val, val == 0x0, 10, 100000);\n\tif (err) {\n\t\tdev_err(nvdec->dev, \"failed to boot %s, debuginfo=0x%x\\n\", phase, val);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nvdec_boot_riscv(struct nvdec *nvdec)\n{\n\tint err;\n\n\terr = reset_control_acquire(nvdec->reset);\n\tif (err)\n\t\treturn err;\n\n\tnvdec_writel(nvdec, 0xabcd1234, NVDEC_FALCON_DEBUGINFO);\n\n\terr = tegra_drm_riscv_boot_bootrom(&nvdec->riscv, nvdec->carveout_base, 1,\n\t\t\t\t\t   &nvdec->riscv.bl_desc);\n\tif (err) {\n\t\tdev_err(nvdec->dev, \"failed to execute bootloader\\n\");\n\t\tgoto release_reset;\n\t}\n\n\terr = nvdec_wait_debuginfo(nvdec, \"bootloader\");\n\tif (err)\n\t\tgoto release_reset;\n\n\terr = reset_control_reset(nvdec->reset);\n\tif (err)\n\t\tgoto release_reset;\n\n\tnvdec_writel(nvdec, 0xabcd1234, NVDEC_FALCON_DEBUGINFO);\n\n\terr = tegra_drm_riscv_boot_bootrom(&nvdec->riscv, nvdec->carveout_base, 1,\n\t\t\t\t\t   &nvdec->riscv.os_desc);\n\tif (err) {\n\t\tdev_err(nvdec->dev, \"failed to execute firmware\\n\");\n\t\tgoto release_reset;\n\t}\n\n\terr = nvdec_wait_debuginfo(nvdec, \"firmware\");\n\tif (err)\n\t\tgoto release_reset;\n\nrelease_reset:\n\treset_control_release(nvdec->reset);\n\n\treturn err;\n}\n\nstatic int nvdec_init(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = dev->dev_private;\n\tstruct nvdec *nvdec = to_nvdec(drm);\n\tint err;\n\n\terr = host1x_client_iommu_attach(client);\n\tif (err < 0 && err != -ENODEV) {\n\t\tdev_err(nvdec->dev, \"failed to attach to domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnvdec->channel = host1x_channel_request(client);\n\tif (!nvdec->channel) {\n\t\terr = -ENOMEM;\n\t\tgoto detach;\n\t}\n\n\tclient->syncpts[0] = host1x_syncpt_request(client, 0);\n\tif (!client->syncpts[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto free_channel;\n\t}\n\n\terr = tegra_drm_register_client(tegra, drm);\n\tif (err < 0)\n\t\tgoto free_syncpt;\n\n\t \n\tclient->dev->dma_parms = client->host->dma_parms;\n\n\treturn 0;\n\nfree_syncpt:\n\thost1x_syncpt_put(client->syncpts[0]);\nfree_channel:\n\thost1x_channel_put(nvdec->channel);\ndetach:\n\thost1x_client_iommu_detach(client);\n\n\treturn err;\n}\n\nstatic int nvdec_exit(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = dev->dev_private;\n\tstruct nvdec *nvdec = to_nvdec(drm);\n\tint err;\n\n\t \n\tclient->dev->dma_parms = NULL;\n\n\terr = tegra_drm_unregister_client(tegra, drm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpm_runtime_dont_use_autosuspend(client->dev);\n\tpm_runtime_force_suspend(client->dev);\n\n\thost1x_syncpt_put(client->syncpts[0]);\n\thost1x_channel_put(nvdec->channel);\n\thost1x_client_iommu_detach(client);\n\n\tnvdec->channel = NULL;\n\n\tif (client->group) {\n\t\tdma_unmap_single(nvdec->dev, nvdec->falcon.firmware.phys,\n\t\t\t\t nvdec->falcon.firmware.size, DMA_TO_DEVICE);\n\t\ttegra_drm_free(tegra, nvdec->falcon.firmware.size,\n\t\t\t       nvdec->falcon.firmware.virt,\n\t\t\t       nvdec->falcon.firmware.iova);\n\t} else {\n\t\tdma_free_coherent(nvdec->dev, nvdec->falcon.firmware.size,\n\t\t\t\t  nvdec->falcon.firmware.virt,\n\t\t\t\t  nvdec->falcon.firmware.iova);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops nvdec_client_ops = {\n\t.init = nvdec_init,\n\t.exit = nvdec_exit,\n};\n\nstatic int nvdec_load_falcon_firmware(struct nvdec *nvdec)\n{\n\tstruct host1x_client *client = &nvdec->client.base;\n\tstruct tegra_drm *tegra = nvdec->client.drm;\n\tdma_addr_t iova;\n\tsize_t size;\n\tvoid *virt;\n\tint err;\n\n\tif (nvdec->falcon.firmware.virt)\n\t\treturn 0;\n\n\terr = falcon_read_firmware(&nvdec->falcon, nvdec->config->firmware);\n\tif (err < 0)\n\t\treturn err;\n\n\tsize = nvdec->falcon.firmware.size;\n\n\tif (!client->group) {\n\t\tvirt = dma_alloc_coherent(nvdec->dev, size, &iova, GFP_KERNEL);\n\n\t\terr = dma_mapping_error(nvdec->dev, iova);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tvirt = tegra_drm_alloc(tegra, size, &iova);\n\t\tif (IS_ERR(virt))\n\t\t\treturn PTR_ERR(virt);\n\t}\n\n\tnvdec->falcon.firmware.virt = virt;\n\tnvdec->falcon.firmware.iova = iova;\n\n\terr = falcon_load_firmware(&nvdec->falcon);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\t \n\tif (client->group) {\n\t\tdma_addr_t phys;\n\n\t\tphys = dma_map_single(nvdec->dev, virt, size, DMA_TO_DEVICE);\n\n\t\terr = dma_mapping_error(nvdec->dev, phys);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\n\t\tnvdec->falcon.firmware.phys = phys;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tif (!client->group)\n\t\tdma_free_coherent(nvdec->dev, size, virt, iova);\n\telse\n\t\ttegra_drm_free(tegra, size, virt, iova);\n\n\treturn err;\n}\n\nstatic __maybe_unused int nvdec_runtime_resume(struct device *dev)\n{\n\tstruct nvdec *nvdec = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_bulk_prepare_enable(nvdec->num_clks, nvdec->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\tif (nvdec->config->has_riscv) {\n\t\terr = nvdec_boot_riscv(nvdec);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t} else {\n\t\terr = nvdec_load_falcon_firmware(nvdec);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\n\t\terr = nvdec_boot_falcon(nvdec);\n\t\tif (err < 0)\n\t\t\tgoto disable;\n\t}\n\n\treturn 0;\n\ndisable:\n\tclk_bulk_disable_unprepare(nvdec->num_clks, nvdec->clks);\n\treturn err;\n}\n\nstatic __maybe_unused int nvdec_runtime_suspend(struct device *dev)\n{\n\tstruct nvdec *nvdec = dev_get_drvdata(dev);\n\n\thost1x_channel_stop(nvdec->channel);\n\n\tclk_bulk_disable_unprepare(nvdec->num_clks, nvdec->clks);\n\n\treturn 0;\n}\n\nstatic int nvdec_open_channel(struct tegra_drm_client *client,\n\t\t\t    struct tegra_drm_context *context)\n{\n\tstruct nvdec *nvdec = to_nvdec(client);\n\n\tcontext->channel = host1x_channel_get(nvdec->channel);\n\tif (!context->channel)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nvdec_close_channel(struct tegra_drm_context *context)\n{\n\thost1x_channel_put(context->channel);\n}\n\nstatic int nvdec_can_use_memory_ctx(struct tegra_drm_client *client, bool *supported)\n{\n\t*supported = true;\n\n\treturn 0;\n}\n\nstatic const struct tegra_drm_client_ops nvdec_ops = {\n\t.open_channel = nvdec_open_channel,\n\t.close_channel = nvdec_close_channel,\n\t.submit = tegra_drm_submit,\n\t.get_streamid_offset = tegra_drm_get_streamid_offset_thi,\n\t.can_use_memory_ctx = nvdec_can_use_memory_ctx,\n};\n\n#define NVIDIA_TEGRA_210_NVDEC_FIRMWARE \"nvidia/tegra210/nvdec.bin\"\n\nstatic const struct nvdec_config nvdec_t210_config = {\n\t.firmware = NVIDIA_TEGRA_210_NVDEC_FIRMWARE,\n\t.version = 0x21,\n\t.supports_sid = false,\n};\n\n#define NVIDIA_TEGRA_186_NVDEC_FIRMWARE \"nvidia/tegra186/nvdec.bin\"\n\nstatic const struct nvdec_config nvdec_t186_config = {\n\t.firmware = NVIDIA_TEGRA_186_NVDEC_FIRMWARE,\n\t.version = 0x18,\n\t.supports_sid = true,\n};\n\n#define NVIDIA_TEGRA_194_NVDEC_FIRMWARE \"nvidia/tegra194/nvdec.bin\"\n\nstatic const struct nvdec_config nvdec_t194_config = {\n\t.firmware = NVIDIA_TEGRA_194_NVDEC_FIRMWARE,\n\t.version = 0x19,\n\t.supports_sid = true,\n};\n\nstatic const struct nvdec_config nvdec_t234_config = {\n\t.version = 0x23,\n\t.supports_sid = true,\n\t.has_riscv = true,\n\t.has_extra_clocks = true,\n};\n\nstatic const struct of_device_id tegra_nvdec_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-nvdec\", .data = &nvdec_t210_config },\n\t{ .compatible = \"nvidia,tegra186-nvdec\", .data = &nvdec_t186_config },\n\t{ .compatible = \"nvidia,tegra194-nvdec\", .data = &nvdec_t194_config },\n\t{ .compatible = \"nvidia,tegra234-nvdec\", .data = &nvdec_t234_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_nvdec_of_match);\n\nstatic int nvdec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct host1x_syncpt **syncpts;\n\tstruct nvdec *nvdec;\n\tu32 host_class;\n\tint err;\n\n\t \n\terr = dma_coerce_mask_and_coherent(dev, *dev->parent->dma_mask);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnvdec = devm_kzalloc(dev, sizeof(*nvdec), GFP_KERNEL);\n\tif (!nvdec)\n\t\treturn -ENOMEM;\n\n\tnvdec->config = of_device_get_match_data(dev);\n\n\tsyncpts = devm_kzalloc(dev, sizeof(*syncpts), GFP_KERNEL);\n\tif (!syncpts)\n\t\treturn -ENOMEM;\n\n\tnvdec->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(nvdec->regs))\n\t\treturn PTR_ERR(nvdec->regs);\n\n\tnvdec->clks[0].id = \"nvdec\";\n\tnvdec->num_clks = 1;\n\n\tif (nvdec->config->has_extra_clocks) {\n\t\tnvdec->num_clks = 3;\n\t\tnvdec->clks[1].id = \"fuse\";\n\t\tnvdec->clks[2].id = \"tsec_pka\";\n\t}\n\n\terr = devm_clk_bulk_get(dev, nvdec->num_clks, nvdec->clks);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to get clock(s)\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_set_rate(nvdec->clks[0].clk, ULONG_MAX);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set clock rate\\n\");\n\t\treturn err;\n\t}\n\n\terr = of_property_read_u32(dev->of_node, \"nvidia,host1x-class\", &host_class);\n\tif (err < 0)\n\t\thost_class = HOST1X_CLASS_NVDEC;\n\n\tif (nvdec->config->has_riscv) {\n\t\tstruct tegra_mc *mc;\n\n\t\tmc = devm_tegra_memory_controller_get(dev);\n\t\tif (IS_ERR(mc)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(mc),\n\t\t\t\t\"failed to get memory controller handle\\n\");\n\t\t\treturn PTR_ERR(mc);\n\t\t}\n\n\t\terr = tegra_mc_get_carveout_info(mc, 1, &nvdec->carveout_base, NULL);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to get carveout info: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tnvdec->reset = devm_reset_control_get_exclusive_released(dev, \"nvdec\");\n\t\tif (IS_ERR(nvdec->reset)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(nvdec->reset), \"failed to get reset\\n\");\n\t\t\treturn PTR_ERR(nvdec->reset);\n\t\t}\n\n\t\tnvdec->riscv.dev = dev;\n\t\tnvdec->riscv.regs = nvdec->regs;\n\n\t\terr = tegra_drm_riscv_read_descriptors(&nvdec->riscv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tnvdec->falcon.dev = dev;\n\t\tnvdec->falcon.regs = nvdec->regs;\n\n\t\terr = falcon_init(&nvdec->falcon);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, nvdec);\n\n\tINIT_LIST_HEAD(&nvdec->client.base.list);\n\tnvdec->client.base.ops = &nvdec_client_ops;\n\tnvdec->client.base.dev = dev;\n\tnvdec->client.base.class = host_class;\n\tnvdec->client.base.syncpts = syncpts;\n\tnvdec->client.base.num_syncpts = 1;\n\tnvdec->dev = dev;\n\n\tINIT_LIST_HEAD(&nvdec->client.list);\n\tnvdec->client.version = nvdec->config->version;\n\tnvdec->client.ops = &nvdec_ops;\n\n\terr = host1x_client_register(&nvdec->client.base);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register host1x client: %d\\n\", err);\n\t\tgoto exit_falcon;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 500);\n\n\treturn 0;\n\nexit_falcon:\n\tfalcon_exit(&nvdec->falcon);\n\n\treturn err;\n}\n\nstatic void nvdec_remove(struct platform_device *pdev)\n{\n\tstruct nvdec *nvdec = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\thost1x_client_unregister(&nvdec->client.base);\n\tfalcon_exit(&nvdec->falcon);\n}\n\nstatic const struct dev_pm_ops nvdec_pm_ops = {\n\tSET_RUNTIME_PM_OPS(nvdec_runtime_suspend, nvdec_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstruct platform_driver tegra_nvdec_driver = {\n\t.driver = {\n\t\t.name = \"tegra-nvdec\",\n\t\t.of_match_table = tegra_nvdec_of_match,\n\t\t.pm = &nvdec_pm_ops\n\t},\n\t.probe = nvdec_probe,\n\t.remove_new = nvdec_remove,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_210_NVDEC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_186_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_186_NVDEC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_194_NVDEC_FIRMWARE);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}