{
  "module_name": "falcon.c",
  "hash_id": "f80111f3ad645f62ebd5f1f23daab9db557b6ddb96a136450509c4f45b0602b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/falcon.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/pci_ids.h>\n#include <linux/iopoll.h>\n\n#include \"falcon.h\"\n#include \"drm.h\"\n\nenum falcon_memory {\n\tFALCON_MEMORY_IMEM,\n\tFALCON_MEMORY_DATA,\n};\n\nstatic void falcon_writel(struct falcon *falcon, u32 value, u32 offset)\n{\n\twritel(value, falcon->regs + offset);\n}\n\nint falcon_wait_idle(struct falcon *falcon)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout(falcon->regs + FALCON_IDLESTATE, value,\n\t\t\t\t  (value == 0), 10, 100000);\n}\n\nstatic int falcon_dma_wait_idle(struct falcon *falcon)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout(falcon->regs + FALCON_DMATRFCMD, value,\n\t\t\t\t  (value & FALCON_DMATRFCMD_IDLE), 10, 100000);\n}\n\nstatic int falcon_copy_chunk(struct falcon *falcon,\n\t\t\t     phys_addr_t base,\n\t\t\t     unsigned long offset,\n\t\t\t     enum falcon_memory target)\n{\n\tu32 cmd = FALCON_DMATRFCMD_SIZE_256B;\n\n\tif (target == FALCON_MEMORY_IMEM)\n\t\tcmd |= FALCON_DMATRFCMD_IMEM;\n\n\t \n\tcmd |= FALCON_DMATRFCMD_DMACTX(1);\n\n\tfalcon_writel(falcon, offset, FALCON_DMATRFMOFFS);\n\tfalcon_writel(falcon, base, FALCON_DMATRFFBOFFS);\n\tfalcon_writel(falcon, cmd, FALCON_DMATRFCMD);\n\n\treturn falcon_dma_wait_idle(falcon);\n}\n\nstatic void falcon_copy_firmware_image(struct falcon *falcon,\n\t\t\t\t       const struct firmware *firmware)\n{\n\tu32 *virt = falcon->firmware.virt;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < firmware->size / sizeof(u32); i++)\n\t\tvirt[i] = le32_to_cpu(((__le32 *)firmware->data)[i]);\n}\n\nstatic int falcon_parse_firmware_image(struct falcon *falcon)\n{\n\tstruct falcon_fw_bin_header_v1 *bin = (void *)falcon->firmware.virt;\n\tstruct falcon_fw_os_header_v1 *os;\n\n\t \n\tif (bin->magic != PCI_VENDOR_ID_NVIDIA && bin->magic != 0x10fe) {\n\t\tdev_err(falcon->dev, \"incorrect firmware magic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bin->version != 1) {\n\t\tdev_err(falcon->dev, \"unsupported firmware version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bin->size > falcon->firmware.size) {\n\t\tdev_err(falcon->dev, \"firmware image size inconsistency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tos = falcon->firmware.virt + bin->os_header_offset;\n\n\tfalcon->firmware.bin_data.size = bin->os_size;\n\tfalcon->firmware.bin_data.offset = bin->os_data_offset;\n\tfalcon->firmware.code.offset = os->code_offset;\n\tfalcon->firmware.code.size = os->code_size;\n\tfalcon->firmware.data.offset = os->data_offset;\n\tfalcon->firmware.data.size = os->data_size;\n\n\treturn 0;\n}\n\nint falcon_read_firmware(struct falcon *falcon, const char *name)\n{\n\tint err;\n\n\t \n\terr = request_firmware(&falcon->firmware.firmware, name, falcon->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tfalcon->firmware.size = falcon->firmware.firmware->size;\n\n\treturn 0;\n}\n\nint falcon_load_firmware(struct falcon *falcon)\n{\n\tconst struct firmware *firmware = falcon->firmware.firmware;\n\tint err;\n\n\t \n\tfalcon_copy_firmware_image(falcon, firmware);\n\n\t \n\terr = falcon_parse_firmware_image(falcon);\n\tif (err < 0) {\n\t\tdev_err(falcon->dev, \"failed to parse firmware image\\n\");\n\t\treturn err;\n\t}\n\n\trelease_firmware(firmware);\n\tfalcon->firmware.firmware = NULL;\n\n\treturn 0;\n}\n\nint falcon_init(struct falcon *falcon)\n{\n\tfalcon->firmware.virt = NULL;\n\n\treturn 0;\n}\n\nvoid falcon_exit(struct falcon *falcon)\n{\n\tif (falcon->firmware.firmware)\n\t\trelease_firmware(falcon->firmware.firmware);\n}\n\nint falcon_boot(struct falcon *falcon)\n{\n\tunsigned long offset;\n\tu32 value;\n\tint err;\n\n\tif (!falcon->firmware.virt)\n\t\treturn -EINVAL;\n\n\terr = readl_poll_timeout(falcon->regs + FALCON_DMACTL, value,\n\t\t\t\t (value & (FALCON_DMACTL_IMEM_SCRUBBING |\n\t\t\t\t\t   FALCON_DMACTL_DMEM_SCRUBBING)) == 0,\n\t\t\t\t 10, 10000);\n\tif (err < 0)\n\t\treturn err;\n\n\tfalcon_writel(falcon, 0, FALCON_DMACTL);\n\n\t \n\tfalcon_writel(falcon, (falcon->firmware.iova +\n\t\t\t       falcon->firmware.bin_data.offset) >> 8,\n\t\t      FALCON_DMATRFBASE);\n\n\t \n\tfor (offset = 0; offset < falcon->firmware.data.size; offset += 256)\n\t\tfalcon_copy_chunk(falcon,\n\t\t\t\t  falcon->firmware.data.offset + offset,\n\t\t\t\t  offset, FALCON_MEMORY_DATA);\n\n\t \n\tfor (offset = 0; offset < falcon->firmware.code.size; offset += 256)\n\t\tfalcon_copy_chunk(falcon, falcon->firmware.code.offset + offset,\n\t\t\t\t  offset, FALCON_MEMORY_IMEM);\n\n\t \n\tfalcon_writel(falcon, FALCON_IRQMSET_EXT(0xff) |\n\t\t\t      FALCON_IRQMSET_SWGEN1 |\n\t\t\t      FALCON_IRQMSET_SWGEN0 |\n\t\t\t      FALCON_IRQMSET_EXTERR |\n\t\t\t      FALCON_IRQMSET_HALT |\n\t\t\t      FALCON_IRQMSET_WDTMR,\n\t\t      FALCON_IRQMSET);\n\tfalcon_writel(falcon, FALCON_IRQDEST_EXT(0xff) |\n\t\t\t      FALCON_IRQDEST_SWGEN1 |\n\t\t\t      FALCON_IRQDEST_SWGEN0 |\n\t\t\t      FALCON_IRQDEST_EXTERR |\n\t\t\t      FALCON_IRQDEST_HALT,\n\t\t      FALCON_IRQDEST);\n\n\t \n\tfalcon_writel(falcon, FALCON_ITFEN_MTHDEN |\n\t\t\t      FALCON_ITFEN_CTXEN,\n\t\t      FALCON_ITFEN);\n\n\t \n\tfalcon_writel(falcon, 0x00000000, FALCON_BOOTVEC);\n\tfalcon_writel(falcon, FALCON_CPUCTL_STARTCPU, FALCON_CPUCTL);\n\n\terr = falcon_wait_idle(falcon);\n\tif (err < 0) {\n\t\tdev_err(falcon->dev, \"Falcon boot failed due to timeout\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid falcon_execute_method(struct falcon *falcon, u32 method, u32 data)\n{\n\tfalcon_writel(falcon, method >> 2, FALCON_UCLASS_METHOD_OFFSET);\n\tfalcon_writel(falcon, data, FALCON_UCLASS_METHOD_DATA);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}