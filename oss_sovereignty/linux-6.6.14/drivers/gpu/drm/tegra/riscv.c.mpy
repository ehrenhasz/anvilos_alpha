{
  "module_name": "riscv.c",
  "hash_id": "74a8baa364da68f7a03eab891b670f2bf2a5e61d54531c1a78d1612f92c4ab25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/riscv.c",
  "human_readable_source": "\n \n\n#include <linux/dev_printk.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n\n#include \"riscv.h\"\n\n#define RISCV_CPUCTL\t\t\t\t\t0x4388\n#define RISCV_CPUCTL_STARTCPU_TRUE\t\t\t(1 << 0)\n#define RISCV_BR_RETCODE\t\t\t\t0x465c\n#define RISCV_BR_RETCODE_RESULT_V(x)\t\t\t((x) & 0x3)\n#define RISCV_BR_RETCODE_RESULT_PASS_V\t\t\t3\n#define RISCV_BCR_CTRL\t\t\t\t\t0x4668\n#define RISCV_BCR_CTRL_CORE_SELECT_RISCV\t\t(1 << 4)\n#define RISCV_BCR_DMACFG\t\t\t\t0x466c\n#define RISCV_BCR_DMACFG_TARGET_LOCAL_FB\t\t(0 << 0)\n#define RISCV_BCR_DMACFG_LOCK_LOCKED\t\t\t(1 << 31)\n#define RISCV_BCR_DMAADDR_PKCPARAM_LO\t\t\t0x4670\n#define RISCV_BCR_DMAADDR_PKCPARAM_HI\t\t\t0x4674\n#define RISCV_BCR_DMAADDR_FMCCODE_LO\t\t\t0x4678\n#define RISCV_BCR_DMAADDR_FMCCODE_HI\t\t\t0x467c\n#define RISCV_BCR_DMAADDR_FMCDATA_LO\t\t\t0x4680\n#define RISCV_BCR_DMAADDR_FMCDATA_HI\t\t\t0x4684\n#define RISCV_BCR_DMACFG_SEC\t\t\t\t0x4694\n#define RISCV_BCR_DMACFG_SEC_GSCID(v)\t\t\t((v) << 16)\n\nstatic void riscv_writel(struct tegra_drm_riscv *riscv, u32 value, u32 offset)\n{\n\twritel(value, riscv->regs + offset);\n}\n\nint tegra_drm_riscv_read_descriptors(struct tegra_drm_riscv *riscv)\n{\n\tstruct tegra_drm_riscv_descriptor *bl = &riscv->bl_desc;\n\tstruct tegra_drm_riscv_descriptor *os = &riscv->os_desc;\n\tconst struct device_node *np = riscv->dev->of_node;\n\tint err;\n\n#define READ_PROP(name, location) \\\n\terr = of_property_read_u32(np, name, location); \\\n\tif (err) { \\\n\t\tdev_err(riscv->dev, \"failed to read \" name \": %d\\n\", err); \\\n\t\treturn err; \\\n\t}\n\n\tREAD_PROP(\"nvidia,bl-manifest-offset\", &bl->manifest_offset);\n\tREAD_PROP(\"nvidia,bl-code-offset\", &bl->code_offset);\n\tREAD_PROP(\"nvidia,bl-data-offset\", &bl->data_offset);\n\tREAD_PROP(\"nvidia,os-manifest-offset\", &os->manifest_offset);\n\tREAD_PROP(\"nvidia,os-code-offset\", &os->code_offset);\n\tREAD_PROP(\"nvidia,os-data-offset\", &os->data_offset);\n#undef READ_PROP\n\n\tif (bl->manifest_offset == 0 && bl->code_offset == 0 &&\n\t    bl->data_offset == 0 && os->manifest_offset == 0 &&\n\t    os->code_offset == 0 && os->data_offset == 0) {\n\t\tdev_err(riscv->dev, \"descriptors not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint tegra_drm_riscv_boot_bootrom(struct tegra_drm_riscv *riscv, phys_addr_t image_address,\n\t\t\t\t u32 gscid, const struct tegra_drm_riscv_descriptor *desc)\n{\n\tphys_addr_t addr;\n\tint err;\n\tu32 val;\n\n\triscv_writel(riscv, RISCV_BCR_CTRL_CORE_SELECT_RISCV, RISCV_BCR_CTRL);\n\n\taddr = image_address + desc->manifest_offset;\n\triscv_writel(riscv, lower_32_bits(addr >> 8), RISCV_BCR_DMAADDR_PKCPARAM_LO);\n\triscv_writel(riscv, upper_32_bits(addr >> 8), RISCV_BCR_DMAADDR_PKCPARAM_HI);\n\n\taddr = image_address + desc->code_offset;\n\triscv_writel(riscv, lower_32_bits(addr >> 8), RISCV_BCR_DMAADDR_FMCCODE_LO);\n\triscv_writel(riscv, upper_32_bits(addr >> 8), RISCV_BCR_DMAADDR_FMCCODE_HI);\n\n\taddr = image_address + desc->data_offset;\n\triscv_writel(riscv, lower_32_bits(addr >> 8), RISCV_BCR_DMAADDR_FMCDATA_LO);\n\triscv_writel(riscv, upper_32_bits(addr >> 8), RISCV_BCR_DMAADDR_FMCDATA_HI);\n\n\triscv_writel(riscv, RISCV_BCR_DMACFG_SEC_GSCID(gscid), RISCV_BCR_DMACFG_SEC);\n\triscv_writel(riscv,\n\t\tRISCV_BCR_DMACFG_TARGET_LOCAL_FB | RISCV_BCR_DMACFG_LOCK_LOCKED, RISCV_BCR_DMACFG);\n\n\triscv_writel(riscv, RISCV_CPUCTL_STARTCPU_TRUE, RISCV_CPUCTL);\n\n\terr = readl_poll_timeout(\n\t\triscv->regs + RISCV_BR_RETCODE, val,\n\t\tRISCV_BR_RETCODE_RESULT_V(val) == RISCV_BR_RETCODE_RESULT_PASS_V,\n\t\t10, 100000);\n\tif (err) {\n\t\tdev_err(riscv->dev, \"error during bootrom execution. BR_RETCODE=%d\\n\", val);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}