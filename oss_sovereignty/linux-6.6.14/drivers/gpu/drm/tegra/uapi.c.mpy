{
  "module_name": "uapi.c",
  "hash_id": "6af12e61864b29252384f725b64d16c9f6d120fd3072c1c7164a964c163f0039",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/uapi.c",
  "human_readable_source": "\n \n\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/list.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_utils.h>\n\n#include \"drm.h\"\n#include \"uapi.h\"\n\nstatic void tegra_drm_mapping_release(struct kref *ref)\n{\n\tstruct tegra_drm_mapping *mapping =\n\t\tcontainer_of(ref, struct tegra_drm_mapping, ref);\n\n\thost1x_bo_unpin(mapping->map);\n\thost1x_bo_put(mapping->bo);\n\n\tkfree(mapping);\n}\n\nvoid tegra_drm_mapping_put(struct tegra_drm_mapping *mapping)\n{\n\tkref_put(&mapping->ref, tegra_drm_mapping_release);\n}\n\nstatic void tegra_drm_channel_context_close(struct tegra_drm_context *context)\n{\n\tstruct tegra_drm_mapping *mapping;\n\tunsigned long id;\n\n\tif (context->memory_context)\n\t\thost1x_memory_context_put(context->memory_context);\n\n\txa_for_each(&context->mappings, id, mapping)\n\t\ttegra_drm_mapping_put(mapping);\n\n\txa_destroy(&context->mappings);\n\n\thost1x_channel_put(context->channel);\n\n\tkfree(context);\n}\n\nvoid tegra_drm_uapi_close_file(struct tegra_drm_file *file)\n{\n\tstruct tegra_drm_context *context;\n\tstruct host1x_syncpt *sp;\n\tunsigned long id;\n\n\txa_for_each(&file->contexts, id, context)\n\t\ttegra_drm_channel_context_close(context);\n\n\txa_for_each(&file->syncpoints, id, sp)\n\t\thost1x_syncpt_put(sp);\n\n\txa_destroy(&file->contexts);\n\txa_destroy(&file->syncpoints);\n}\n\nstatic struct tegra_drm_client *tegra_drm_find_client(struct tegra_drm *tegra, u32 class)\n{\n\tstruct tegra_drm_client *client;\n\n\tlist_for_each_entry(client, &tegra->clients, list)\n\t\tif (client->base.class == class)\n\t\t\treturn client;\n\n\treturn NULL;\n}\n\nint tegra_drm_ioctl_channel_open(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct host1x *host = tegra_drm_to_host1x(drm->dev_private);\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct drm_tegra_channel_open *args = data;\n\tstruct tegra_drm_client *client = NULL;\n\tstruct tegra_drm_context *context;\n\tint err;\n\n\tif (args->flags)\n\t\treturn -EINVAL;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tclient = tegra_drm_find_client(tegra, args->host1x_class);\n\tif (!client) {\n\t\terr = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tif (client->shared_channel) {\n\t\tcontext->channel = host1x_channel_get(client->shared_channel);\n\t} else {\n\t\tcontext->channel = host1x_channel_request(&client->base);\n\t\tif (!context->channel) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\t \n\tif (device_iommu_mapped(client->base.dev) && client->ops->can_use_memory_ctx) {\n\t\tbool supported;\n\n\t\terr = client->ops->can_use_memory_ctx(client, &supported);\n\t\tif (err)\n\t\t\tgoto put_channel;\n\n\t\tif (supported)\n\t\t\tcontext->memory_context = host1x_memory_context_alloc(\n\t\t\t\thost, client->base.dev, get_task_pid(current, PIDTYPE_TGID));\n\n\t\tif (IS_ERR(context->memory_context)) {\n\t\t\tif (PTR_ERR(context->memory_context) != -EOPNOTSUPP) {\n\t\t\t\terr = PTR_ERR(context->memory_context);\n\t\t\t\tgoto put_channel;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcontext->memory_context = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = xa_alloc(&fpriv->contexts, &args->context, context, XA_LIMIT(1, U32_MAX),\n\t\t       GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto put_memctx;\n\n\tcontext->client = client;\n\txa_init_flags(&context->mappings, XA_FLAGS_ALLOC1);\n\n\targs->version = client->version;\n\targs->capabilities = 0;\n\n\tif (device_get_dma_attr(client->base.dev) == DEV_DMA_COHERENT)\n\t\targs->capabilities |= DRM_TEGRA_CHANNEL_CAP_CACHE_COHERENT;\n\n\treturn 0;\n\nput_memctx:\n\tif (context->memory_context)\n\t\thost1x_memory_context_put(context->memory_context);\nput_channel:\n\thost1x_channel_put(context->channel);\nfree:\n\tkfree(context);\n\n\treturn err;\n}\n\nint tegra_drm_ioctl_channel_close(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_channel_close *args = data;\n\tstruct tegra_drm_context *context;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = xa_load(&fpriv->contexts, args->context);\n\tif (!context) {\n\t\tmutex_unlock(&fpriv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\txa_erase(&fpriv->contexts, args->context);\n\n\tmutex_unlock(&fpriv->lock);\n\n\ttegra_drm_channel_context_close(context);\n\n\treturn 0;\n}\n\nint tegra_drm_ioctl_channel_map(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_channel_map *args = data;\n\tstruct tegra_drm_mapping *mapping;\n\tstruct tegra_drm_context *context;\n\tenum dma_data_direction direction;\n\tstruct device *mapping_dev;\n\tint err = 0;\n\n\tif (args->flags & ~DRM_TEGRA_CHANNEL_MAP_READ_WRITE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = xa_load(&fpriv->contexts, args->context);\n\tif (!context) {\n\t\tmutex_unlock(&fpriv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\tif (!mapping) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tkref_init(&mapping->ref);\n\n\tif (context->memory_context)\n\t\tmapping_dev = &context->memory_context->dev;\n\telse\n\t\tmapping_dev = context->client->base.dev;\n\n\tmapping->bo = tegra_gem_lookup(file, args->handle);\n\tif (!mapping->bo) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tswitch (args->flags & DRM_TEGRA_CHANNEL_MAP_READ_WRITE) {\n\tcase DRM_TEGRA_CHANNEL_MAP_READ_WRITE:\n\t\tdirection = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\n\tcase DRM_TEGRA_CHANNEL_MAP_WRITE:\n\t\tdirection = DMA_FROM_DEVICE;\n\t\tbreak;\n\n\tcase DRM_TEGRA_CHANNEL_MAP_READ:\n\t\tdirection = DMA_TO_DEVICE;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto put_gem;\n\t}\n\n\tmapping->map = host1x_bo_pin(mapping_dev, mapping->bo, direction, NULL);\n\tif (IS_ERR(mapping->map)) {\n\t\terr = PTR_ERR(mapping->map);\n\t\tgoto put_gem;\n\t}\n\n\tmapping->iova = mapping->map->phys;\n\tmapping->iova_end = mapping->iova + host1x_to_tegra_bo(mapping->bo)->gem.size;\n\n\terr = xa_alloc(&context->mappings, &args->mapping, mapping, XA_LIMIT(1, U32_MAX),\n\t\t       GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto unpin;\n\n\tmutex_unlock(&fpriv->lock);\n\n\treturn 0;\n\nunpin:\n\thost1x_bo_unpin(mapping->map);\nput_gem:\n\thost1x_bo_put(mapping->bo);\nfree:\n\tkfree(mapping);\nunlock:\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nint tegra_drm_ioctl_channel_unmap(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_channel_unmap *args = data;\n\tstruct tegra_drm_mapping *mapping;\n\tstruct tegra_drm_context *context;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = xa_load(&fpriv->contexts, args->context);\n\tif (!context) {\n\t\tmutex_unlock(&fpriv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmapping = xa_erase(&context->mappings, args->mapping);\n\n\tmutex_unlock(&fpriv->lock);\n\n\tif (!mapping)\n\t\treturn -EINVAL;\n\n\ttegra_drm_mapping_put(mapping);\n\treturn 0;\n}\n\nint tegra_drm_ioctl_syncpoint_allocate(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct host1x *host1x = tegra_drm_to_host1x(drm->dev_private);\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_syncpoint_allocate *args = data;\n\tstruct host1x_syncpt *sp;\n\tint err;\n\n\tif (args->id)\n\t\treturn -EINVAL;\n\n\tsp = host1x_syncpt_alloc(host1x, HOST1X_SYNCPT_CLIENT_MANAGED, current->comm);\n\tif (!sp)\n\t\treturn -EBUSY;\n\n\targs->id = host1x_syncpt_id(sp);\n\n\terr = xa_insert(&fpriv->syncpoints, args->id, sp, GFP_KERNEL);\n\tif (err) {\n\t\thost1x_syncpt_put(sp);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint tegra_drm_ioctl_syncpoint_free(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_syncpoint_allocate *args = data;\n\tstruct host1x_syncpt *sp;\n\n\tmutex_lock(&fpriv->lock);\n\tsp = xa_erase(&fpriv->syncpoints, args->id);\n\tmutex_unlock(&fpriv->lock);\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\thost1x_syncpt_put(sp);\n\n\treturn 0;\n}\n\nint tegra_drm_ioctl_syncpoint_wait(struct drm_device *drm, void *data, struct drm_file *file)\n{\n\tstruct host1x *host1x = tegra_drm_to_host1x(drm->dev_private);\n\tstruct drm_tegra_syncpoint_wait *args = data;\n\tsigned long timeout_jiffies;\n\tstruct host1x_syncpt *sp;\n\n\tif (args->padding != 0)\n\t\treturn -EINVAL;\n\n\tsp = host1x_syncpt_get_by_id_noref(host1x, args->id);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\ttimeout_jiffies = drm_timeout_abs_to_jiffies(args->timeout_ns);\n\n\treturn host1x_syncpt_wait(sp, args->threshold, timeout_jiffies, &args->value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}