{
  "module_name": "hub.c",
  "hash_id": "2fe0b64a1785d64ab63dec4e9d05ff9fd7fa423cb519ccda3b81dbe49a61777a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/hub.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/host1x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"drm.h\"\n#include \"dc.h\"\n#include \"plane.h\"\n\n#define NFB 24\n\nstatic const u32 tegra_shared_plane_formats[] = {\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGBA5551,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\t \n\tDRM_FORMAT_ABGR4444,\n\tDRM_FORMAT_ABGR1555,\n\tDRM_FORMAT_BGRA5551,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGBX5551,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_BGRX5551,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\t \n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n};\n\nstatic const u64 tegra_shared_plane_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(0),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(1),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(2),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(3),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(4),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(5),\n\t \n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(0) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(1) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(2) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(3) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(4) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(5) | DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT,\n\t \n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic inline unsigned int tegra_plane_offset(struct tegra_plane *plane,\n\t\t\t\t\t      unsigned int offset)\n{\n\tif (offset >= 0x500 && offset <= 0x581) {\n\t\toffset = 0x000 + (offset - 0x500);\n\t\treturn plane->offset + offset;\n\t}\n\n\tif (offset >= 0x700 && offset <= 0x73c) {\n\t\toffset = 0x180 + (offset - 0x700);\n\t\treturn plane->offset + offset;\n\t}\n\n\tif (offset >= 0x800 && offset <= 0x83e) {\n\t\toffset = 0x1c0 + (offset - 0x800);\n\t\treturn plane->offset + offset;\n\t}\n\n\tdev_WARN(plane->dc->dev, \"invalid offset: %x\\n\", offset);\n\n\treturn plane->offset + offset;\n}\n\nstatic inline u32 tegra_plane_readl(struct tegra_plane *plane,\n\t\t\t\t    unsigned int offset)\n{\n\treturn tegra_dc_readl(plane->dc, tegra_plane_offset(plane, offset));\n}\n\nstatic inline void tegra_plane_writel(struct tegra_plane *plane, u32 value,\n\t\t\t\t      unsigned int offset)\n{\n\ttegra_dc_writel(plane->dc, value, tegra_plane_offset(plane, offset));\n}\n\nstatic int tegra_windowgroup_enable(struct tegra_windowgroup *wgrp)\n{\n\tint err = 0;\n\n\tmutex_lock(&wgrp->lock);\n\n\tif (wgrp->usecount == 0) {\n\t\terr = host1x_client_resume(wgrp->parent);\n\t\tif (err < 0) {\n\t\t\tdev_err(wgrp->parent->dev, \"failed to resume: %d\\n\", err);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\treset_control_deassert(wgrp->rst);\n\t}\n\n\twgrp->usecount++;\n\nunlock:\n\tmutex_unlock(&wgrp->lock);\n\treturn err;\n}\n\nstatic void tegra_windowgroup_disable(struct tegra_windowgroup *wgrp)\n{\n\tint err;\n\n\tmutex_lock(&wgrp->lock);\n\n\tif (wgrp->usecount == 1) {\n\t\terr = reset_control_assert(wgrp->rst);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"failed to assert reset for window group %u\\n\",\n\t\t\t       wgrp->index);\n\t\t}\n\n\t\thost1x_client_suspend(wgrp->parent);\n\t}\n\n\twgrp->usecount--;\n\tmutex_unlock(&wgrp->lock);\n}\n\nint tegra_display_hub_prepare(struct tegra_display_hub *hub)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < hub->soc->num_wgrps; i++) {\n\t\tstruct tegra_windowgroup *wgrp = &hub->wgrps[i];\n\n\t\t \n\t\tif (wgrp->parent)\n\t\t\ttegra_windowgroup_enable(wgrp);\n\t}\n\n\treturn 0;\n}\n\nvoid tegra_display_hub_cleanup(struct tegra_display_hub *hub)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < hub->soc->num_wgrps; i++) {\n\t\tstruct tegra_windowgroup *wgrp = &hub->wgrps[i];\n\n\t\t \n\t\tif (wgrp->parent)\n\t\t\ttegra_windowgroup_disable(wgrp);\n\t}\n}\n\nstatic void tegra_shared_plane_update(struct tegra_plane *plane)\n{\n\tstruct tegra_dc *dc = plane->dc;\n\tunsigned long timeout;\n\tu32 mask, value;\n\n\tmask = COMMON_UPDATE | WIN_A_UPDATE << plane->base.index;\n\ttegra_dc_writel(dc, mask, DC_CMD_STATE_CONTROL);\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\t\tif ((value & mask) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(100, 400);\n\t}\n}\n\nstatic void tegra_shared_plane_activate(struct tegra_plane *plane)\n{\n\tstruct tegra_dc *dc = plane->dc;\n\tunsigned long timeout;\n\tu32 mask, value;\n\n\tmask = COMMON_ACTREQ | WIN_A_ACT_REQ << plane->base.index;\n\ttegra_dc_writel(dc, mask, DC_CMD_STATE_CONTROL);\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\t\tif ((value & mask) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(100, 400);\n\t}\n}\n\nstatic unsigned int\ntegra_shared_plane_get_owner(struct tegra_plane *plane, struct tegra_dc *dc)\n{\n\tunsigned int offset =\n\t\ttegra_plane_offset(plane, DC_WIN_CORE_WINDOWGROUP_SET_CONTROL);\n\n\treturn tegra_dc_readl(dc, offset) & OWNER_MASK;\n}\n\nstatic bool tegra_dc_owns_shared_plane(struct tegra_dc *dc,\n\t\t\t\t       struct tegra_plane *plane)\n{\n\tstruct device *dev = dc->dev;\n\n\tif (tegra_shared_plane_get_owner(plane, dc) == dc->pipe) {\n\t\tif (plane->dc == dc)\n\t\t\treturn true;\n\n\t\tdev_WARN(dev, \"head %u owns window %u but is not attached\\n\",\n\t\t\t dc->pipe, plane->index);\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_shared_plane_set_owner(struct tegra_plane *plane,\n\t\t\t\t\tstruct tegra_dc *new)\n{\n\tunsigned int offset =\n\t\ttegra_plane_offset(plane, DC_WIN_CORE_WINDOWGROUP_SET_CONTROL);\n\tstruct tegra_dc *old = plane->dc, *dc = new ? new : old;\n\tstruct device *dev = new ? new->dev : old->dev;\n\tunsigned int owner, index = plane->index;\n\tu32 value;\n\n\tvalue = tegra_dc_readl(dc, offset);\n\towner = value & OWNER_MASK;\n\n\tif (new && (owner != OWNER_MASK && owner != new->pipe)) {\n\t\tdev_WARN(dev, \"window %u owned by head %u\\n\", index, owner);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (old && owner == OWNER_MASK)\n\t\tdev_dbg(dev, \"window %u not owned by head %u but %u\\n\", index,\n\t\t\told->pipe, owner);\n\n\tvalue &= ~OWNER_MASK;\n\n\tif (new)\n\t\tvalue |= OWNER(new->pipe);\n\telse\n\t\tvalue |= OWNER_MASK;\n\n\ttegra_dc_writel(dc, value, offset);\n\n\tplane->dc = new;\n\n\treturn 0;\n}\n\nstatic void tegra_shared_plane_setup_scaler(struct tegra_plane *plane)\n{\n\tstatic const unsigned int coeffs[192] = {\n\t\t0x00000000, 0x3c70e400, 0x3bb037e4, 0x0c51cc9c,\n\t\t0x00100001, 0x3bf0dbfa, 0x3d00f406, 0x3fe003ff,\n\t\t0x00300002, 0x3b80cbf5, 0x3da1040d, 0x3fb003fe,\n\t\t0x00400002, 0x3b20bff1, 0x3e511015, 0x3f9003fc,\n\t\t0x00500002, 0x3ad0b3ed, 0x3f21201d, 0x3f5003fb,\n\t\t0x00500003, 0x3aa0a3e9, 0x3ff13026, 0x3f2007f9,\n\t\t0x00500403, 0x3a7097e6, 0x00e1402f, 0x3ee007f7,\n\t\t0x00500403, 0x3a608be4, 0x01d14c38, 0x3ea00bf6,\n\t\t0x00500403, 0x3a507fe2, 0x02e15c42, 0x3e500ff4,\n\t\t0x00500402, 0x3a6073e1, 0x03f16c4d, 0x3e000ff2,\n\t\t0x00400402, 0x3a706be0, 0x05117858, 0x3db013f0,\n\t\t0x00300402, 0x3a905fe0, 0x06318863, 0x3d6017ee,\n\t\t0x00300402, 0x3ab057e0, 0x0771986e, 0x3d001beb,\n\t\t0x00200001, 0x3af04fe1, 0x08a1a47a, 0x3cb023e9,\n\t\t0x00100001, 0x3b2047e2, 0x09e1b485, 0x3c6027e7,\n\t\t0x00100000, 0x3b703fe2, 0x0b11c091, 0x3c002fe6,\n\t\t0x3f203800, 0x0391103f, 0x3ff0a014, 0x0811606c,\n\t\t0x3f2037ff, 0x0351083c, 0x03e11842, 0x3f203c00,\n\t\t0x3f302fff, 0x03010439, 0x04311c45, 0x3f104401,\n\t\t0x3f302fff, 0x02c0fc35, 0x04812448, 0x3f104802,\n\t\t0x3f4027ff, 0x0270f832, 0x04c1284b, 0x3f205003,\n\t\t0x3f4023ff, 0x0230f030, 0x0511304e, 0x3f205403,\n\t\t0x3f601fff, 0x01f0e82d, 0x05613451, 0x3f205c04,\n\t\t0x3f701bfe, 0x01b0e02a, 0x05a13c54, 0x3f306006,\n\t\t0x3f7017fe, 0x0170d827, 0x05f14057, 0x3f406807,\n\t\t0x3f8017ff, 0x0140d424, 0x0641445a, 0x3f406c08,\n\t\t0x3fa013ff, 0x0100cc22, 0x0681485d, 0x3f507409,\n\t\t0x3fa00fff, 0x00d0c41f, 0x06d14c60, 0x3f607c0b,\n\t\t0x3fc00fff, 0x0090bc1c, 0x07115063, 0x3f80840c,\n\t\t0x3fd00bff, 0x0070b41a, 0x07515465, 0x3f908c0e,\n\t\t0x3fe007ff, 0x0040b018, 0x07915868, 0x3fb0900f,\n\t\t0x3ff00400, 0x0010a816, 0x07d15c6a, 0x3fd09811,\n\t\t0x00a04c0e, 0x0460f442, 0x0240a827, 0x05c15859,\n\t\t0x0090440d, 0x0440f040, 0x0480fc43, 0x00b05010,\n\t\t0x0080400c, 0x0410ec3e, 0x04910044, 0x00d05411,\n\t\t0x0070380b, 0x03f0e83d, 0x04b10846, 0x00e05812,\n\t\t0x0060340a, 0x03d0e43b, 0x04d10c48, 0x00f06013,\n\t\t0x00503009, 0x03b0e039, 0x04e11449, 0x01106415,\n\t\t0x00402c08, 0x0390d838, 0x05011c4b, 0x01206c16,\n\t\t0x00302807, 0x0370d436, 0x0511204c, 0x01407018,\n\t\t0x00302406, 0x0340d034, 0x0531244e, 0x01507419,\n\t\t0x00202005, 0x0320cc32, 0x05412c50, 0x01707c1b,\n\t\t0x00101c04, 0x0300c431, 0x05613451, 0x0180801d,\n\t\t0x00101803, 0x02e0c02f, 0x05713853, 0x01a0881e,\n\t\t0x00101002, 0x02b0bc2d, 0x05814054, 0x01c08c20,\n\t\t0x00000c02, 0x02a0b82c, 0x05914455, 0x01e09421,\n\t\t0x00000801, 0x0280b02a, 0x05a14c57, 0x02009c23,\n\t\t0x00000400, 0x0260ac28, 0x05b15458, 0x0220a025,\n\t};\n\tunsigned int ratio, row, column;\n\n\tfor (ratio = 0; ratio <= 2; ratio++) {\n\t\tfor (row = 0; row <= 15; row++) {\n\t\t\tfor (column = 0; column <= 3; column++) {\n\t\t\t\tunsigned int index = (ratio << 6) + (row << 2) + column;\n\t\t\t\tu32 value;\n\n\t\t\t\tvalue = COEFF_INDEX(index) | COEFF_DATA(coeffs[index]);\n\t\t\t\ttegra_plane_writel(plane, value,\n\t\t\t\t\t\t   DC_WIN_WINDOWGROUP_SET_INPUT_SCALER_COEFF);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void tegra_dc_assign_shared_plane(struct tegra_dc *dc,\n\t\t\t\t\t struct tegra_plane *plane)\n{\n\tu32 value;\n\tint err;\n\n\tif (!tegra_dc_owns_shared_plane(dc, plane)) {\n\t\terr = tegra_shared_plane_set_owner(plane, dc);\n\t\tif (err < 0)\n\t\t\treturn;\n\t}\n\n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_LINEBUF_CONFIG);\n\tvalue |= MODE_FOUR_LINES;\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_LINEBUF_CONFIG);\n\n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_WGRP_FETCH_METER);\n\tvalue = SLOTS(1);\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_WGRP_FETCH_METER);\n\n\t \n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_WGRP_LATENCY_CTLA);\n\tvalue &= ~LATENCY_CTL_MODE_ENABLE;\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_WGRP_LATENCY_CTLA);\n\n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_WGRP_LATENCY_CTLB);\n\tvalue |= WATERMARK_MASK;\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_WGRP_LATENCY_CTLB);\n\n\t \n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_PRECOMP_WGRP_PIPE_METER);\n\tvalue = PIPE_METER_INT(0) | PIPE_METER_FRAC(0);\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_PRECOMP_WGRP_PIPE_METER);\n\n\t \n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_WGRP_POOL_CONFIG);\n\tvalue = MEMPOOL_ENTRIES(0x331);\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_WGRP_POOL_CONFIG);\n\n\tvalue = tegra_plane_readl(plane, DC_WIN_CORE_IHUB_THREAD_GROUP);\n\tvalue &= ~THREAD_NUM_MASK;\n\tvalue |= THREAD_NUM(plane->base.index);\n\tvalue |= THREAD_GROUP_ENABLE;\n\ttegra_plane_writel(plane, value, DC_WIN_CORE_IHUB_THREAD_GROUP);\n\n\ttegra_shared_plane_setup_scaler(plane);\n\n\ttegra_shared_plane_update(plane);\n\ttegra_shared_plane_activate(plane);\n}\n\nstatic void tegra_dc_remove_shared_plane(struct tegra_dc *dc,\n\t\t\t\t\t struct tegra_plane *plane)\n{\n\ttegra_shared_plane_set_owner(plane, NULL);\n}\n\nstatic int tegra_shared_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct tegra_plane_state *plane_state = to_tegra_plane_state(new_plane_state);\n\tstruct tegra_shared_plane *tegra = to_tegra_shared_plane(plane);\n\tstruct tegra_bo_tiling *tiling = &plane_state->tiling;\n\tstruct tegra_dc *dc = to_tegra_dc(new_plane_state->crtc);\n\tint err;\n\n\t \n\tif (!new_plane_state->crtc || !new_plane_state->fb)\n\t\treturn 0;\n\n\terr = tegra_plane_format(new_plane_state->fb->format->format,\n\t\t\t\t &plane_state->format,\n\t\t\t\t &plane_state->swap);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_fb_get_tiling(new_plane_state->fb, tiling);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tiling->mode == TEGRA_BO_TILING_MODE_BLOCK &&\n\t    !dc->soc->supports_block_linear) {\n\t\tDRM_ERROR(\"hardware doesn't support block linear mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tiling->sector_layout == TEGRA_BO_SECTOR_LAYOUT_GPU &&\n\t    !dc->soc->supports_sector_layout) {\n\t\tDRM_ERROR(\"hardware doesn't support GPU sector layout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (new_plane_state->fb->format->num_planes > 2) {\n\t\tif (new_plane_state->fb->pitches[2] != new_plane_state->fb->pitches[1]) {\n\t\t\tDRM_ERROR(\"unsupported UV-plane configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\terr = tegra_plane_state_add(&tegra->base, new_plane_state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void tegra_shared_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\tstruct tegra_dc *dc;\n\tu32 value;\n\tint err;\n\n\t \n\tif (!old_state || !old_state->crtc)\n\t\treturn;\n\n\tdc = to_tegra_dc(old_state->crtc);\n\n\terr = host1x_client_resume(&dc->client);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\t \n\tif (WARN_ON(p->dc == NULL))\n\t\tp->dc = dc;\n\n\tvalue = tegra_plane_readl(p, DC_WIN_WIN_OPTIONS);\n\tvalue &= ~WIN_ENABLE;\n\ttegra_plane_writel(p, value, DC_WIN_WIN_OPTIONS);\n\n\ttegra_dc_remove_shared_plane(dc, p);\n\n\thost1x_client_suspend(&dc->client);\n}\n\nstatic inline u32 compute_phase_incr(fixed20_12 in, unsigned int out)\n{\n\tu64 tmp, tmp1, tmp2;\n\n\ttmp = (u64)dfixed_trunc(in);\n\ttmp2 = (u64)out;\n\ttmp1 = (tmp << NFB) + (tmp2 >> 1);\n\tdo_div(tmp1, tmp2);\n\n\treturn lower_32_bits(tmp1);\n}\n\nstatic void tegra_shared_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct tegra_plane_state *tegra_plane_state = to_tegra_plane_state(new_state);\n\tstruct tegra_dc *dc = to_tegra_dc(new_state->crtc);\n\tunsigned int zpos = new_state->normalized_zpos;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\tu32 value, min_width, bypass = 0;\n\tdma_addr_t base, addr_flag = 0;\n\tunsigned int bpc, planes;\n\tbool yuv;\n\tint err;\n\n\t \n\tif (!new_state->crtc || !new_state->fb)\n\t\treturn;\n\n\tif (!new_state->visible) {\n\t\ttegra_shared_plane_atomic_disable(plane, state);\n\t\treturn;\n\t}\n\n\terr = host1x_client_resume(&dc->client);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tyuv = tegra_plane_format_is_yuv(tegra_plane_state->format, &planes, &bpc);\n\n\ttegra_dc_assign_shared_plane(dc, p);\n\n\ttegra_plane_writel(p, VCOUNTER, DC_WIN_CORE_ACT_CONTROL);\n\n\t \n\tvalue = BLEND_FACTOR_DST_ALPHA_ZERO | BLEND_FACTOR_SRC_ALPHA_K2 |\n\t\tBLEND_FACTOR_DST_COLOR_NEG_K1_TIMES_SRC |\n\t\tBLEND_FACTOR_SRC_COLOR_K1_TIMES_SRC;\n\ttegra_plane_writel(p, value, DC_WIN_BLEND_MATCH_SELECT);\n\n\tvalue = BLEND_FACTOR_DST_ALPHA_ZERO | BLEND_FACTOR_SRC_ALPHA_K2 |\n\t\tBLEND_FACTOR_DST_COLOR_NEG_K1_TIMES_SRC |\n\t\tBLEND_FACTOR_SRC_COLOR_K1_TIMES_SRC;\n\ttegra_plane_writel(p, value, DC_WIN_BLEND_NOMATCH_SELECT);\n\n\tvalue = K2(255) | K1(255) | WINDOW_LAYER_DEPTH(255 - zpos);\n\ttegra_plane_writel(p, value, DC_WIN_BLEND_LAYER_CONTROL);\n\n\t \n\tmin_width = min(new_state->src_w >> 16, new_state->crtc_w);\n\n\tvalue = tegra_plane_readl(p, DC_WINC_PRECOMP_WGRP_PIPE_CAPC);\n\n\tif (min_width < MAX_PIXELS_5TAP444(value)) {\n\t\tvalue = HORIZONTAL_TAPS_5 | VERTICAL_TAPS_5;\n\t} else {\n\t\tvalue = tegra_plane_readl(p, DC_WINC_PRECOMP_WGRP_PIPE_CAPE);\n\n\t\tif (min_width < MAX_PIXELS_2TAP444(value))\n\t\t\tvalue = HORIZONTAL_TAPS_2 | VERTICAL_TAPS_2;\n\t\telse\n\t\t\tdev_err(dc->dev, \"invalid minimum width: %u\\n\", min_width);\n\t}\n\n\tvalue = HORIZONTAL_TAPS_5 | VERTICAL_TAPS_5;\n\ttegra_plane_writel(p, value, DC_WIN_WINDOWGROUP_SET_CONTROL_INPUT_SCALER);\n\n\tif (new_state->src_w != new_state->crtc_w << 16) {\n\t\tfixed20_12 width = dfixed_init(new_state->src_w >> 16);\n\t\tu32 incr = compute_phase_incr(width, new_state->crtc_w) & ~0x1;\n\t\tu32 init = (1 << (NFB - 1)) + (incr >> 1);\n\n\t\ttegra_plane_writel(p, incr, DC_WIN_SET_INPUT_SCALER_HPHASE_INCR);\n\t\ttegra_plane_writel(p, init, DC_WIN_SET_INPUT_SCALER_H_START_PHASE);\n\t} else {\n\t\tbypass |= INPUT_SCALER_HBYPASS;\n\t}\n\n\tif (new_state->src_h != new_state->crtc_h << 16) {\n\t\tfixed20_12 height = dfixed_init(new_state->src_h >> 16);\n\t\tu32 incr = compute_phase_incr(height, new_state->crtc_h) & ~0x1;\n\t\tu32 init = (1 << (NFB - 1)) + (incr >> 1);\n\n\t\ttegra_plane_writel(p, incr, DC_WIN_SET_INPUT_SCALER_VPHASE_INCR);\n\t\ttegra_plane_writel(p, init, DC_WIN_SET_INPUT_SCALER_V_START_PHASE);\n\t} else {\n\t\tbypass |= INPUT_SCALER_VBYPASS;\n\t}\n\n\ttegra_plane_writel(p, bypass, DC_WIN_WINDOWGROUP_SET_INPUT_SCALER_USAGE);\n\n\t \n\ttegra_plane_writel(p, 0, DC_WINBUF_CDE_CONTROL);\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\t \n\tif (tegra_plane_state->tiling.sector_layout == TEGRA_BO_SECTOR_LAYOUT_GPU)\n\t\taddr_flag = BIT_ULL(39);\n#endif\n\n\tbase = tegra_plane_state->iova[0] + fb->offsets[0];\n\tbase |= addr_flag;\n\n\ttegra_plane_writel(p, tegra_plane_state->format, DC_WIN_COLOR_DEPTH);\n\ttegra_plane_writel(p, 0, DC_WIN_PRECOMP_WGRP_PARAMS);\n\n\tvalue = V_POSITION(new_state->crtc_y) |\n\t\tH_POSITION(new_state->crtc_x);\n\ttegra_plane_writel(p, value, DC_WIN_POSITION);\n\n\tvalue = V_SIZE(new_state->crtc_h) | H_SIZE(new_state->crtc_w);\n\ttegra_plane_writel(p, value, DC_WIN_SIZE);\n\n\tvalue = WIN_ENABLE | COLOR_EXPAND;\n\ttegra_plane_writel(p, value, DC_WIN_WIN_OPTIONS);\n\n\tvalue = V_SIZE(new_state->src_h >> 16) | H_SIZE(new_state->src_w >> 16);\n\ttegra_plane_writel(p, value, DC_WIN_CROPPED_SIZE);\n\n\ttegra_plane_writel(p, upper_32_bits(base), DC_WINBUF_START_ADDR_HI);\n\ttegra_plane_writel(p, lower_32_bits(base), DC_WINBUF_START_ADDR);\n\n\tvalue = PITCH(fb->pitches[0]);\n\ttegra_plane_writel(p, value, DC_WIN_PLANAR_STORAGE);\n\n\tif (yuv && planes > 1) {\n\t\tbase = tegra_plane_state->iova[1] + fb->offsets[1];\n\t\tbase |= addr_flag;\n\n\t\ttegra_plane_writel(p, upper_32_bits(base), DC_WINBUF_START_ADDR_HI_U);\n\t\ttegra_plane_writel(p, lower_32_bits(base), DC_WINBUF_START_ADDR_U);\n\n\t\tif (planes > 2) {\n\t\t\tbase = tegra_plane_state->iova[2] + fb->offsets[2];\n\t\t\tbase |= addr_flag;\n\n\t\t\ttegra_plane_writel(p, upper_32_bits(base), DC_WINBUF_START_ADDR_HI_V);\n\t\t\ttegra_plane_writel(p, lower_32_bits(base), DC_WINBUF_START_ADDR_V);\n\t\t}\n\n\t\tvalue = PITCH_U(fb->pitches[1]);\n\n\t\tif (planes > 2)\n\t\t\tvalue |= PITCH_V(fb->pitches[2]);\n\n\t\ttegra_plane_writel(p, value, DC_WIN_PLANAR_STORAGE_UV);\n\t} else {\n\t\ttegra_plane_writel(p, 0, DC_WINBUF_START_ADDR_U);\n\t\ttegra_plane_writel(p, 0, DC_WINBUF_START_ADDR_HI_U);\n\t\ttegra_plane_writel(p, 0, DC_WINBUF_START_ADDR_V);\n\t\ttegra_plane_writel(p, 0, DC_WINBUF_START_ADDR_HI_V);\n\t\ttegra_plane_writel(p, 0, DC_WIN_PLANAR_STORAGE_UV);\n\t}\n\n\tvalue = CLAMP_BEFORE_BLEND | INPUT_RANGE_FULL;\n\n\tif (yuv) {\n\t\tif (bpc < 12)\n\t\t\tvalue |= DEGAMMA_YUV8_10;\n\t\telse\n\t\t\tvalue |= DEGAMMA_YUV12;\n\n\t\t \n\t\tvalue |= COLOR_SPACE_YUV_2020;\n\t} else {\n\t\tif (!tegra_plane_format_is_indexed(tegra_plane_state->format))\n\t\t\tvalue |= DEGAMMA_SRGB;\n\t}\n\n\ttegra_plane_writel(p, value, DC_WIN_SET_PARAMS);\n\n\tvalue = OFFSET_X(new_state->src_y >> 16) |\n\t\tOFFSET_Y(new_state->src_x >> 16);\n\ttegra_plane_writel(p, value, DC_WINBUF_CROPPED_POINT);\n\n\tif (dc->soc->supports_block_linear) {\n\t\tunsigned long height = tegra_plane_state->tiling.value;\n\n\t\t \n\t\tswitch (tegra_plane_state->tiling.mode) {\n\t\tcase TEGRA_BO_TILING_MODE_PITCH:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_BLOCK_HEIGHT(0) |\n\t\t\t\tDC_WINBUF_SURFACE_KIND_PITCH;\n\t\t\tbreak;\n\n\t\t \n\t\tcase TEGRA_BO_TILING_MODE_TILED:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_TILED;\n\t\t\tbreak;\n\n\t\tcase TEGRA_BO_TILING_MODE_BLOCK:\n\t\t\tvalue = DC_WINBUF_SURFACE_KIND_BLOCK_HEIGHT(height) |\n\t\t\t\tDC_WINBUF_SURFACE_KIND_BLOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\ttegra_plane_writel(p, value, DC_WINBUF_SURFACE_KIND);\n\t}\n\n\t \n\tvalue = tegra_plane_readl(p, DC_WIN_WINDOW_SET_CONTROL);\n\tvalue &= ~CONTROL_CSC_ENABLE;\n\ttegra_plane_writel(p, value, DC_WIN_WINDOW_SET_CONTROL);\n\n\thost1x_client_suspend(&dc->client);\n}\n\nstatic const struct drm_plane_helper_funcs tegra_shared_plane_helper_funcs = {\n\t.prepare_fb = tegra_plane_prepare_fb,\n\t.cleanup_fb = tegra_plane_cleanup_fb,\n\t.atomic_check = tegra_shared_plane_atomic_check,\n\t.atomic_update = tegra_shared_plane_atomic_update,\n\t.atomic_disable = tegra_shared_plane_atomic_disable,\n};\n\nstruct drm_plane *tegra_shared_plane_create(struct drm_device *drm,\n\t\t\t\t\t    struct tegra_dc *dc,\n\t\t\t\t\t    unsigned int wgrp,\n\t\t\t\t\t    unsigned int index)\n{\n\tenum drm_plane_type type = DRM_PLANE_TYPE_OVERLAY;\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct tegra_display_hub *hub = tegra->hub;\n\tstruct tegra_shared_plane *plane;\n\tunsigned int possible_crtcs;\n\tunsigned int num_formats;\n\tconst u64 *modifiers;\n\tstruct drm_plane *p;\n\tconst u32 *formats;\n\tint err;\n\n\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\tif (!plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tplane->base.offset = 0x0a00 + 0x0300 * index;\n\tplane->base.index = index;\n\n\tplane->wgrp = &hub->wgrps[wgrp];\n\tplane->wgrp->parent = &dc->client;\n\n\tp = &plane->base.base;\n\n\t \n\tpossible_crtcs = BIT(tegra->num_crtcs) - 1;\n\n\tnum_formats = ARRAY_SIZE(tegra_shared_plane_formats);\n\tformats = tegra_shared_plane_formats;\n\tmodifiers = tegra_shared_plane_modifiers;\n\n\terr = drm_universal_plane_init(drm, p, possible_crtcs,\n\t\t\t\t       &tegra_plane_funcs, formats,\n\t\t\t\t       num_formats, modifiers, type, NULL);\n\tif (err < 0) {\n\t\tkfree(plane);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tdrm_plane_helper_add(p, &tegra_shared_plane_helper_funcs);\n\tdrm_plane_create_zpos_property(p, 0, 0, 255);\n\n\treturn p;\n}\n\nstatic struct drm_private_state *\ntegra_display_hub_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct tegra_display_hub_state *state;\n\n\tstate = kmemdup(obj->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void tegra_display_hub_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t\t    struct drm_private_state *state)\n{\n\tstruct tegra_display_hub_state *hub_state =\n\t\tto_tegra_display_hub_state(state);\n\n\tkfree(hub_state);\n}\n\nstatic const struct drm_private_state_funcs tegra_display_hub_state_funcs = {\n\t.atomic_duplicate_state = tegra_display_hub_duplicate_state,\n\t.atomic_destroy_state = tegra_display_hub_destroy_state,\n};\n\nstatic struct tegra_display_hub_state *\ntegra_display_hub_get_state(struct tegra_display_hub *hub,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv;\n\n\tpriv = drm_atomic_get_private_obj_state(state, &hub->base);\n\tif (IS_ERR(priv))\n\t\treturn ERR_CAST(priv);\n\n\treturn to_tegra_display_hub_state(priv);\n}\n\nint tegra_display_hub_atomic_check(struct drm_device *drm,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct tegra_display_hub_state *hub_state;\n\tstruct drm_crtc_state *old, *new;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\n\tif (!tegra->hub)\n\t\treturn 0;\n\n\thub_state = tegra_display_hub_get_state(tegra->hub, state);\n\tif (IS_ERR(hub_state))\n\t\treturn PTR_ERR(hub_state);\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old, new, i) {\n\t\tstruct tegra_dc_state *dc = to_dc_state(new);\n\n\t\tif (new->active) {\n\t\t\tif (!hub_state->clk || dc->pclk > hub_state->rate) {\n\t\t\t\thub_state->dc = to_tegra_dc(dc->base.crtc);\n\t\t\t\thub_state->clk = hub_state->dc->clk;\n\t\t\t\thub_state->rate = dc->pclk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_display_hub_update(struct tegra_dc *dc)\n{\n\tu32 value;\n\tint err;\n\n\terr = host1x_client_resume(&dc->client);\n\tif (err < 0) {\n\t\tdev_err(dc->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tvalue = tegra_dc_readl(dc, DC_CMD_IHUB_COMMON_MISC_CTL);\n\tvalue &= ~LATENCY_EVENT;\n\ttegra_dc_writel(dc, value, DC_CMD_IHUB_COMMON_MISC_CTL);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_IHUB_COMMON_DISPLAY_FETCH_METER);\n\tvalue = CURS_SLOTS(1) | WGRP_SLOTS(1);\n\ttegra_dc_writel(dc, value, DC_DISP_IHUB_COMMON_DISPLAY_FETCH_METER);\n\n\ttegra_dc_writel(dc, COMMON_UPDATE, DC_CMD_STATE_CONTROL);\n\ttegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\ttegra_dc_writel(dc, COMMON_ACTREQ, DC_CMD_STATE_CONTROL);\n\ttegra_dc_readl(dc, DC_CMD_STATE_CONTROL);\n\n\thost1x_client_suspend(&dc->client);\n}\n\nvoid tegra_display_hub_atomic_commit(struct drm_device *drm,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct tegra_display_hub *hub = tegra->hub;\n\tstruct tegra_display_hub_state *hub_state;\n\tstruct device *dev = hub->client.dev;\n\tint err;\n\n\thub_state = to_tegra_display_hub_state(hub->base.state);\n\n\tif (hub_state->clk) {\n\t\terr = clk_set_rate(hub_state->clk, hub_state->rate);\n\t\tif (err < 0)\n\t\t\tdev_err(dev, \"failed to set rate of %pC to %lu Hz\\n\",\n\t\t\t\thub_state->clk, hub_state->rate);\n\n\t\terr = clk_set_parent(hub->clk_disp, hub_state->clk);\n\t\tif (err < 0)\n\t\t\tdev_err(dev, \"failed to set parent of %pC to %pC: %d\\n\",\n\t\t\t\thub->clk_disp, hub_state->clk, err);\n\t}\n\n\tif (hub_state->dc)\n\t\ttegra_display_hub_update(hub_state->dc);\n}\n\nstatic int tegra_display_hub_init(struct host1x_client *client)\n{\n\tstruct tegra_display_hub *hub = to_tegra_display_hub(client);\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct tegra_display_hub_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_atomic_private_obj_init(drm, &hub->base, &state->base,\n\t\t\t\t    &tegra_display_hub_state_funcs);\n\n\ttegra->hub = hub;\n\n\treturn 0;\n}\n\nstatic int tegra_display_hub_exit(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\n\tdrm_atomic_private_obj_fini(&tegra->hub->base);\n\ttegra->hub = NULL;\n\n\treturn 0;\n}\n\nstatic int tegra_display_hub_runtime_suspend(struct host1x_client *client)\n{\n\tstruct tegra_display_hub *hub = to_tegra_display_hub(client);\n\tstruct device *dev = client->dev;\n\tunsigned int i = hub->num_heads;\n\tint err;\n\n\terr = reset_control_assert(hub->rst);\n\tif (err < 0)\n\t\treturn err;\n\n\twhile (i--)\n\t\tclk_disable_unprepare(hub->clk_heads[i]);\n\n\tclk_disable_unprepare(hub->clk_hub);\n\tclk_disable_unprepare(hub->clk_dsc);\n\tclk_disable_unprepare(hub->clk_disp);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int tegra_display_hub_runtime_resume(struct host1x_client *client)\n{\n\tstruct tegra_display_hub *hub = to_tegra_display_hub(client);\n\tstruct device *dev = client->dev;\n\tunsigned int i;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get runtime PM: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(hub->clk_disp);\n\tif (err < 0)\n\t\tgoto put_rpm;\n\n\terr = clk_prepare_enable(hub->clk_dsc);\n\tif (err < 0)\n\t\tgoto disable_disp;\n\n\terr = clk_prepare_enable(hub->clk_hub);\n\tif (err < 0)\n\t\tgoto disable_dsc;\n\n\tfor (i = 0; i < hub->num_heads; i++) {\n\t\terr = clk_prepare_enable(hub->clk_heads[i]);\n\t\tif (err < 0)\n\t\t\tgoto disable_heads;\n\t}\n\n\terr = reset_control_deassert(hub->rst);\n\tif (err < 0)\n\t\tgoto disable_heads;\n\n\treturn 0;\n\ndisable_heads:\n\twhile (i--)\n\t\tclk_disable_unprepare(hub->clk_heads[i]);\n\n\tclk_disable_unprepare(hub->clk_hub);\ndisable_dsc:\n\tclk_disable_unprepare(hub->clk_dsc);\ndisable_disp:\n\tclk_disable_unprepare(hub->clk_disp);\nput_rpm:\n\tpm_runtime_put_sync(dev);\n\treturn err;\n}\n\nstatic const struct host1x_client_ops tegra_display_hub_ops = {\n\t.init = tegra_display_hub_init,\n\t.exit = tegra_display_hub_exit,\n\t.suspend = tegra_display_hub_runtime_suspend,\n\t.resume = tegra_display_hub_runtime_resume,\n};\n\nstatic int tegra_display_hub_probe(struct platform_device *pdev)\n{\n\tu64 dma_mask = dma_get_mask(pdev->dev.parent);\n\tstruct device_node *child = NULL;\n\tstruct tegra_display_hub *hub;\n\tstruct clk *clk;\n\tunsigned int i;\n\tint err;\n\n\terr = dma_coerce_mask_and_coherent(&pdev->dev, dma_mask);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thub = devm_kzalloc(&pdev->dev, sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\thub->soc = of_device_get_match_data(&pdev->dev);\n\n\thub->clk_disp = devm_clk_get(&pdev->dev, \"disp\");\n\tif (IS_ERR(hub->clk_disp)) {\n\t\terr = PTR_ERR(hub->clk_disp);\n\t\treturn err;\n\t}\n\n\tif (hub->soc->supports_dsc) {\n\t\thub->clk_dsc = devm_clk_get(&pdev->dev, \"dsc\");\n\t\tif (IS_ERR(hub->clk_dsc)) {\n\t\t\terr = PTR_ERR(hub->clk_dsc);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\thub->clk_hub = devm_clk_get(&pdev->dev, \"hub\");\n\tif (IS_ERR(hub->clk_hub)) {\n\t\terr = PTR_ERR(hub->clk_hub);\n\t\treturn err;\n\t}\n\n\thub->rst = devm_reset_control_get(&pdev->dev, \"misc\");\n\tif (IS_ERR(hub->rst)) {\n\t\terr = PTR_ERR(hub->rst);\n\t\treturn err;\n\t}\n\n\thub->wgrps = devm_kcalloc(&pdev->dev, hub->soc->num_wgrps,\n\t\t\t\t  sizeof(*hub->wgrps), GFP_KERNEL);\n\tif (!hub->wgrps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hub->soc->num_wgrps; i++) {\n\t\tstruct tegra_windowgroup *wgrp = &hub->wgrps[i];\n\t\tchar id[8];\n\n\t\tsnprintf(id, sizeof(id), \"wgrp%u\", i);\n\t\tmutex_init(&wgrp->lock);\n\t\twgrp->usecount = 0;\n\t\twgrp->index = i;\n\n\t\twgrp->rst = devm_reset_control_get(&pdev->dev, id);\n\t\tif (IS_ERR(wgrp->rst))\n\t\t\treturn PTR_ERR(wgrp->rst);\n\n\t\terr = reset_control_assert(wgrp->rst);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\thub->num_heads = of_get_child_count(pdev->dev.of_node);\n\n\thub->clk_heads = devm_kcalloc(&pdev->dev, hub->num_heads, sizeof(clk),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hub->clk_heads)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hub->num_heads; i++) {\n\t\tchild = of_get_next_child(pdev->dev.of_node, child);\n\t\tif (!child) {\n\t\t\tdev_err(&pdev->dev, \"failed to find node for head %u\\n\",\n\t\t\t\ti);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tclk = devm_get_clk_from_child(&pdev->dev, child, \"dc\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get clock for head %u\\n\",\n\t\t\t\ti);\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\thub->clk_heads[i] = clk;\n\t}\n\n\tof_node_put(child);\n\n\t \n\terr = reset_control_assert(hub->rst);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, hub);\n\tpm_runtime_enable(&pdev->dev);\n\n\tINIT_LIST_HEAD(&hub->client.list);\n\thub->client.ops = &tegra_display_hub_ops;\n\thub->client.dev = &pdev->dev;\n\n\terr = host1x_client_register(&hub->client);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\n\terr = devm_of_platform_populate(&pdev->dev);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\treturn err;\n\nunregister:\n\thost1x_client_unregister(&hub->client);\n\tpm_runtime_disable(&pdev->dev);\n\treturn err;\n}\n\nstatic void tegra_display_hub_remove(struct platform_device *pdev)\n{\n\tstruct tegra_display_hub *hub = platform_get_drvdata(pdev);\n\tunsigned int i;\n\n\thost1x_client_unregister(&hub->client);\n\n\tfor (i = 0; i < hub->soc->num_wgrps; i++) {\n\t\tstruct tegra_windowgroup *wgrp = &hub->wgrps[i];\n\n\t\tmutex_destroy(&wgrp->lock);\n\t}\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct tegra_display_hub_soc tegra186_display_hub = {\n\t.num_wgrps = 6,\n\t.supports_dsc = true,\n};\n\nstatic const struct tegra_display_hub_soc tegra194_display_hub = {\n\t.num_wgrps = 6,\n\t.supports_dsc = false,\n};\n\nstatic const struct of_device_id tegra_display_hub_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra194-display\",\n\t\t.data = &tegra194_display_hub\n\t}, {\n\t\t.compatible = \"nvidia,tegra186-display\",\n\t\t.data = &tegra186_display_hub\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, tegra_display_hub_of_match);\n\nstruct platform_driver tegra_display_hub_driver = {\n\t.driver = {\n\t\t.name = \"tegra-display-hub\",\n\t\t.of_match_table = tegra_display_hub_of_match,\n\t},\n\t.probe = tegra_display_hub_probe,\n\t.remove_new = tegra_display_hub_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}