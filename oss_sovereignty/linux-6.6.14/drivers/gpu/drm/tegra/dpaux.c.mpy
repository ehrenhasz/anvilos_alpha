{
  "module_name": "dpaux.c",
  "hash_id": "53288b219276d6c5379fd31fea568b8dab96298680c09cb78bd829d7c4bb65ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/dpaux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/workqueue.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/drm_panel.h>\n\n#include \"dp.h\"\n#include \"dpaux.h\"\n#include \"drm.h\"\n#include \"trace.h\"\n\nstatic DEFINE_MUTEX(dpaux_lock);\nstatic LIST_HEAD(dpaux_list);\n\nstruct tegra_dpaux_soc {\n\tunsigned int cmh;\n\tunsigned int drvz;\n\tunsigned int drvi;\n};\n\nstruct tegra_dpaux {\n\tstruct drm_dp_aux aux;\n\tstruct device *dev;\n\n\tconst struct tegra_dpaux_soc *soc;\n\n\tvoid __iomem *regs;\n\tint irq;\n\n\tstruct tegra_output *output;\n\n\tstruct reset_control *rst;\n\tstruct clk *clk_parent;\n\tstruct clk *clk;\n\n\tstruct regulator *vdd;\n\n\tstruct completion complete;\n\tstruct work_struct work;\n\tstruct list_head list;\n\n#ifdef CONFIG_GENERIC_PINCONF\n\tstruct pinctrl_dev *pinctrl;\n\tstruct pinctrl_desc desc;\n#endif\n};\n\nstatic inline struct tegra_dpaux *to_dpaux(struct drm_dp_aux *aux)\n{\n\treturn container_of(aux, struct tegra_dpaux, aux);\n}\n\nstatic inline struct tegra_dpaux *work_to_dpaux(struct work_struct *work)\n{\n\treturn container_of(work, struct tegra_dpaux, work);\n}\n\nstatic inline u32 tegra_dpaux_readl(struct tegra_dpaux *dpaux,\n\t\t\t\t    unsigned int offset)\n{\n\tu32 value = readl(dpaux->regs + (offset << 2));\n\n\ttrace_dpaux_readl(dpaux->dev, offset, value);\n\n\treturn value;\n}\n\nstatic inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,\n\t\t\t\t      u32 value, unsigned int offset)\n{\n\ttrace_dpaux_writel(dpaux->dev, offset, value);\n\twritel(value, dpaux->regs + (offset << 2));\n}\n\nstatic void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,\n\t\t\t\t   size_t size)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < DIV_ROUND_UP(size, 4); i++) {\n\t\tsize_t num = min_t(size_t, size - i * 4, 4);\n\t\tu32 value = 0;\n\n\t\tfor (j = 0; j < num; j++)\n\t\t\tvalue |= buffer[i * 4 + j] << (j * 8);\n\n\t\ttegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXDATA_WRITE(i));\n\t}\n}\n\nstatic void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,\n\t\t\t\t  size_t size)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < DIV_ROUND_UP(size, 4); i++) {\n\t\tsize_t num = min_t(size_t, size - i * 4, 4);\n\t\tu32 value;\n\n\t\tvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXDATA_READ(i));\n\n\t\tfor (j = 0; j < num; j++)\n\t\t\tbuffer[i * 4 + j] = value >> (j * 8);\n\t}\n}\n\nstatic ssize_t tegra_dpaux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t    struct drm_dp_aux_msg *msg)\n{\n\tunsigned long timeout = msecs_to_jiffies(250);\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\tunsigned long status;\n\tssize_t ret = 0;\n\tu8 reply = 0;\n\tu32 value;\n\n\t \n\tif (msg->size > 16)\n\t\treturn -EINVAL;\n\n\t \n\tif (msg->size < 1) {\n\t\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\t\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\t\tcase DP_AUX_I2C_WRITE:\n\t\tcase DP_AUX_I2C_READ:\n\t\t\tvalue = DPAUX_DP_AUXCTL_CMD_ADDRESS_ONLY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tvalue = DPAUX_DP_AUXCTL_CMDLEN(msg->size - 1);\n\t}\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_I2C_WRITE:\n\t\tif (msg->request & DP_AUX_I2C_MOT)\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_MOT_WR;\n\t\telse\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_I2C_WR;\n\n\t\tbreak;\n\n\tcase DP_AUX_I2C_READ:\n\t\tif (msg->request & DP_AUX_I2C_MOT)\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RD;\n\t\telse\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RD;\n\n\t\tbreak;\n\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\t\tif (msg->request & DP_AUX_I2C_MOT)\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RQ;\n\t\telse\n\t\t\tvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RQ;\n\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_WRITE:\n\t\tvalue |= DPAUX_DP_AUXCTL_CMD_AUX_WR;\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_READ:\n\t\tvalue |= DPAUX_DP_AUXCTL_CMD_AUX_RD;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttegra_dpaux_writel(dpaux, msg->address, DPAUX_DP_AUXADDR);\n\ttegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\n\n\tif ((msg->request & DP_AUX_I2C_READ) == 0) {\n\t\ttegra_dpaux_write_fifo(dpaux, msg->buffer, msg->size);\n\t\tret = msg->size;\n\t}\n\n\t \n\tvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXCTL);\n\tvalue |= DPAUX_DP_AUXCTL_TRANSACTREQ;\n\ttegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\n\n\tstatus = wait_for_completion_timeout(&dpaux->complete, timeout);\n\tif (!status)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\n\ttegra_dpaux_writel(dpaux, 0xf00, DPAUX_DP_AUXSTAT);\n\n\tif (value & DPAUX_DP_AUXSTAT_TIMEOUT_ERROR)\n\t\treturn -ETIMEDOUT;\n\n\tif ((value & DPAUX_DP_AUXSTAT_RX_ERROR) ||\n\t    (value & DPAUX_DP_AUXSTAT_SINKSTAT_ERROR) ||\n\t    (value & DPAUX_DP_AUXSTAT_NO_STOP_ERROR))\n\t\treturn -EIO;\n\n\tswitch ((value & DPAUX_DP_AUXSTAT_REPLY_TYPE_MASK) >> 16) {\n\tcase 0x00:\n\t\treply = DP_AUX_NATIVE_REPLY_ACK;\n\t\tbreak;\n\n\tcase 0x01:\n\t\treply = DP_AUX_NATIVE_REPLY_NACK;\n\t\tbreak;\n\n\tcase 0x02:\n\t\treply = DP_AUX_NATIVE_REPLY_DEFER;\n\t\tbreak;\n\n\tcase 0x04:\n\t\treply = DP_AUX_I2C_REPLY_NACK;\n\t\tbreak;\n\n\tcase 0x08:\n\t\treply = DP_AUX_I2C_REPLY_DEFER;\n\t\tbreak;\n\t}\n\n\tif ((msg->size > 0) && (msg->reply == DP_AUX_NATIVE_REPLY_ACK)) {\n\t\tif (msg->request & DP_AUX_I2C_READ) {\n\t\t\tsize_t count = value & DPAUX_DP_AUXSTAT_REPLY_MASK;\n\n\t\t\t \n\t\t\tif (count != msg->size) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttegra_dpaux_read_fifo(dpaux, msg->buffer, count);\n\t\t\tret = count;\n\t\t}\n\t}\n\n\tmsg->reply = reply;\n\nout:\n\treturn ret;\n}\n\nstatic void tegra_dpaux_hotplug(struct work_struct *work)\n{\n\tstruct tegra_dpaux *dpaux = work_to_dpaux(work);\n\n\tif (dpaux->output)\n\t\tdrm_helper_hpd_irq_event(dpaux->output->connector.dev);\n}\n\nstatic irqreturn_t tegra_dpaux_irq(int irq, void *data)\n{\n\tstruct tegra_dpaux *dpaux = data;\n\tu32 value;\n\n\t \n\tvalue = tegra_dpaux_readl(dpaux, DPAUX_INTR_AUX);\n\ttegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\n\n\tif (value & (DPAUX_INTR_PLUG_EVENT | DPAUX_INTR_UNPLUG_EVENT))\n\t\tschedule_work(&dpaux->work);\n\n\tif (value & DPAUX_INTR_IRQ_EVENT) {\n\t\t \n\t}\n\n\tif (value & DPAUX_INTR_AUX_DONE)\n\t\tcomplete(&dpaux->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nenum tegra_dpaux_functions {\n\tDPAUX_PADCTL_FUNC_AUX,\n\tDPAUX_PADCTL_FUNC_I2C,\n\tDPAUX_PADCTL_FUNC_OFF,\n};\n\nstatic void tegra_dpaux_pad_power_down(struct tegra_dpaux *dpaux)\n{\n\tu32 value = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\n\n\tvalue |= DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\n\n\ttegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\n}\n\nstatic void tegra_dpaux_pad_power_up(struct tegra_dpaux *dpaux)\n{\n\tu32 value = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\n\n\tvalue &= ~DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\n\n\ttegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\n}\n\nstatic int tegra_dpaux_pad_config(struct tegra_dpaux *dpaux, unsigned function)\n{\n\tu32 value;\n\n\tswitch (function) {\n\tcase DPAUX_PADCTL_FUNC_AUX:\n\t\tvalue = DPAUX_HYBRID_PADCTL_AUX_CMH(dpaux->soc->cmh) |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_DRVZ(dpaux->soc->drvz) |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_DRVI(dpaux->soc->drvi) |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_INPUT_RCV |\n\t\t\tDPAUX_HYBRID_PADCTL_MODE_AUX;\n\t\tbreak;\n\n\tcase DPAUX_PADCTL_FUNC_I2C:\n\t\tvalue = DPAUX_HYBRID_PADCTL_I2C_SDA_INPUT_RCV |\n\t\t\tDPAUX_HYBRID_PADCTL_I2C_SCL_INPUT_RCV |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_CMH(dpaux->soc->cmh) |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_DRVZ(dpaux->soc->drvz) |\n\t\t\tDPAUX_HYBRID_PADCTL_AUX_DRVI(dpaux->soc->drvi) |\n\t\t\tDPAUX_HYBRID_PADCTL_MODE_I2C;\n\t\tbreak;\n\n\tcase DPAUX_PADCTL_FUNC_OFF:\n\t\ttegra_dpaux_pad_power_down(dpaux);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\ttegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_PADCTL);\n\ttegra_dpaux_pad_power_up(dpaux);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_GENERIC_PINCONF\nstatic const struct pinctrl_pin_desc tegra_dpaux_pins[] = {\n\tPINCTRL_PIN(0, \"DP_AUX_CHx_P\"),\n\tPINCTRL_PIN(1, \"DP_AUX_CHx_N\"),\n};\n\nstatic const unsigned tegra_dpaux_pin_numbers[] = { 0, 1 };\n\nstatic const char * const tegra_dpaux_groups[] = {\n\t\"dpaux-io\",\n};\n\nstatic const char * const tegra_dpaux_functions[] = {\n\t\"aux\",\n\t\"i2c\",\n\t\"off\",\n};\n\nstatic int tegra_dpaux_get_groups_count(struct pinctrl_dev *pinctrl)\n{\n\treturn ARRAY_SIZE(tegra_dpaux_groups);\n}\n\nstatic const char *tegra_dpaux_get_group_name(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t      unsigned int group)\n{\n\treturn tegra_dpaux_groups[group];\n}\n\nstatic int tegra_dpaux_get_group_pins(struct pinctrl_dev *pinctrl,\n\t\t\t\t      unsigned group, const unsigned **pins,\n\t\t\t\t      unsigned *num_pins)\n{\n\t*pins = tegra_dpaux_pin_numbers;\n\t*num_pins = ARRAY_SIZE(tegra_dpaux_pin_numbers);\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops tegra_dpaux_pinctrl_ops = {\n\t.get_groups_count = tegra_dpaux_get_groups_count,\n\t.get_group_name = tegra_dpaux_get_group_name,\n\t.get_group_pins = tegra_dpaux_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\nstatic int tegra_dpaux_get_functions_count(struct pinctrl_dev *pinctrl)\n{\n\treturn ARRAY_SIZE(tegra_dpaux_functions);\n}\n\nstatic const char *tegra_dpaux_get_function_name(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t\t unsigned int function)\n{\n\treturn tegra_dpaux_functions[function];\n}\n\nstatic int tegra_dpaux_get_function_groups(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t   unsigned int function,\n\t\t\t\t\t   const char * const **groups,\n\t\t\t\t\t   unsigned * const num_groups)\n{\n\t*num_groups = ARRAY_SIZE(tegra_dpaux_groups);\n\t*groups = tegra_dpaux_groups;\n\n\treturn 0;\n}\n\nstatic int tegra_dpaux_set_mux(struct pinctrl_dev *pinctrl,\n\t\t\t       unsigned int function, unsigned int group)\n{\n\tstruct tegra_dpaux *dpaux = pinctrl_dev_get_drvdata(pinctrl);\n\n\treturn tegra_dpaux_pad_config(dpaux, function);\n}\n\nstatic const struct pinmux_ops tegra_dpaux_pinmux_ops = {\n\t.get_functions_count = tegra_dpaux_get_functions_count,\n\t.get_function_name = tegra_dpaux_get_function_name,\n\t.get_function_groups = tegra_dpaux_get_function_groups,\n\t.set_mux = tegra_dpaux_set_mux,\n};\n#endif\n\nstatic int tegra_dpaux_probe(struct platform_device *pdev)\n{\n\tstruct tegra_dpaux *dpaux;\n\tu32 value;\n\tint err;\n\n\tdpaux = devm_kzalloc(&pdev->dev, sizeof(*dpaux), GFP_KERNEL);\n\tif (!dpaux)\n\t\treturn -ENOMEM;\n\n\tdpaux->soc = of_device_get_match_data(&pdev->dev);\n\tINIT_WORK(&dpaux->work, tegra_dpaux_hotplug);\n\tinit_completion(&dpaux->complete);\n\tINIT_LIST_HEAD(&dpaux->list);\n\tdpaux->dev = &pdev->dev;\n\n\tdpaux->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dpaux->regs))\n\t\treturn PTR_ERR(dpaux->regs);\n\n\tdpaux->irq = platform_get_irq(pdev, 0);\n\tif (dpaux->irq < 0)\n\t\treturn dpaux->irq;\n\n\tif (!pdev->dev.pm_domain) {\n\t\tdpaux->rst = devm_reset_control_get(&pdev->dev, \"dpaux\");\n\t\tif (IS_ERR(dpaux->rst)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get reset control: %ld\\n\",\n\t\t\t\tPTR_ERR(dpaux->rst));\n\t\t\treturn PTR_ERR(dpaux->rst);\n\t\t}\n\t}\n\n\tdpaux->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dpaux->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get module clock: %ld\\n\",\n\t\t\tPTR_ERR(dpaux->clk));\n\t\treturn PTR_ERR(dpaux->clk);\n\t}\n\n\tdpaux->clk_parent = devm_clk_get(&pdev->dev, \"parent\");\n\tif (IS_ERR(dpaux->clk_parent)) {\n\t\tdev_err(&pdev->dev, \"failed to get parent clock: %ld\\n\",\n\t\t\tPTR_ERR(dpaux->clk_parent));\n\t\treturn PTR_ERR(dpaux->clk_parent);\n\t}\n\n\terr = clk_set_rate(dpaux->clk_parent, 270000000);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set clock to 270 MHz: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tdpaux->vdd = devm_regulator_get_optional(&pdev->dev, \"vdd\");\n\tif (IS_ERR(dpaux->vdd)) {\n\t\tif (PTR_ERR(dpaux->vdd) != -ENODEV) {\n\t\t\tif (PTR_ERR(dpaux->vdd) != -EPROBE_DEFER)\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"failed to get VDD supply: %ld\\n\",\n\t\t\t\t\tPTR_ERR(dpaux->vdd));\n\n\t\t\treturn PTR_ERR(dpaux->vdd);\n\t\t}\n\n\t\tdpaux->vdd = NULL;\n\t}\n\n\tplatform_set_drvdata(pdev, dpaux);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\terr = devm_request_irq(dpaux->dev, dpaux->irq, tegra_dpaux_irq, 0,\n\t\t\t       dev_name(dpaux->dev), dpaux);\n\tif (err < 0) {\n\t\tdev_err(dpaux->dev, \"failed to request IRQ#%u: %d\\n\",\n\t\t\tdpaux->irq, err);\n\t\treturn err;\n\t}\n\n\tdisable_irq(dpaux->irq);\n\n\tdpaux->aux.transfer = tegra_dpaux_transfer;\n\tdpaux->aux.dev = &pdev->dev;\n\n\tdrm_dp_aux_init(&dpaux->aux);\n\n\t \n\terr = tegra_dpaux_pad_config(dpaux, DPAUX_PADCTL_FUNC_I2C);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CONFIG_GENERIC_PINCONF\n\tdpaux->desc.name = dev_name(&pdev->dev);\n\tdpaux->desc.pins = tegra_dpaux_pins;\n\tdpaux->desc.npins = ARRAY_SIZE(tegra_dpaux_pins);\n\tdpaux->desc.pctlops = &tegra_dpaux_pinctrl_ops;\n\tdpaux->desc.pmxops = &tegra_dpaux_pinmux_ops;\n\tdpaux->desc.owner = THIS_MODULE;\n\n\tdpaux->pinctrl = devm_pinctrl_register(&pdev->dev, &dpaux->desc, dpaux);\n\tif (IS_ERR(dpaux->pinctrl)) {\n\t\tdev_err(&pdev->dev, \"failed to register pincontrol\\n\");\n\t\treturn PTR_ERR(dpaux->pinctrl);\n\t}\n#endif\n\t \n\tvalue = DPAUX_INTR_AUX_DONE | DPAUX_INTR_IRQ_EVENT |\n\t\tDPAUX_INTR_UNPLUG_EVENT | DPAUX_INTR_PLUG_EVENT;\n\ttegra_dpaux_writel(dpaux, value, DPAUX_INTR_EN_AUX);\n\ttegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\n\n\tmutex_lock(&dpaux_lock);\n\tlist_add_tail(&dpaux->list, &dpaux_list);\n\tmutex_unlock(&dpaux_lock);\n\n\terr = devm_of_dp_aux_populate_ep_devices(&dpaux->aux);\n\tif (err < 0) {\n\t\tdev_err(dpaux->dev, \"failed to populate AUX bus: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_dpaux_remove(struct platform_device *pdev)\n{\n\tstruct tegra_dpaux *dpaux = platform_get_drvdata(pdev);\n\n\tcancel_work_sync(&dpaux->work);\n\n\t \n\ttegra_dpaux_pad_power_down(dpaux);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tmutex_lock(&dpaux_lock);\n\tlist_del(&dpaux->list);\n\tmutex_unlock(&dpaux_lock);\n}\n\nstatic int tegra_dpaux_suspend(struct device *dev)\n{\n\tstruct tegra_dpaux *dpaux = dev_get_drvdata(dev);\n\tint err = 0;\n\n\tif (dpaux->rst) {\n\t\terr = reset_control_assert(dpaux->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tclk_disable_unprepare(dpaux->clk_parent);\n\tclk_disable_unprepare(dpaux->clk);\n\n\treturn err;\n}\n\nstatic int tegra_dpaux_resume(struct device *dev)\n{\n\tstruct tegra_dpaux *dpaux = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(dpaux->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(dpaux->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable parent clock: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tif (dpaux->rst) {\n\t\terr = reset_control_deassert(dpaux->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\t\tgoto disable_parent;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n\ndisable_parent:\n\tclk_disable_unprepare(dpaux->clk_parent);\ndisable_clk:\n\tclk_disable_unprepare(dpaux->clk);\n\treturn err;\n}\n\nstatic const struct dev_pm_ops tegra_dpaux_pm_ops = {\n\tRUNTIME_PM_OPS(tegra_dpaux_suspend, tegra_dpaux_resume, NULL)\n};\n\nstatic const struct tegra_dpaux_soc tegra124_dpaux_soc = {\n\t.cmh = 0x02,\n\t.drvz = 0x04,\n\t.drvi = 0x18,\n};\n\nstatic const struct tegra_dpaux_soc tegra210_dpaux_soc = {\n\t.cmh = 0x02,\n\t.drvz = 0x04,\n\t.drvi = 0x30,\n};\n\nstatic const struct tegra_dpaux_soc tegra194_dpaux_soc = {\n\t.cmh = 0x02,\n\t.drvz = 0x04,\n\t.drvi = 0x2c,\n};\n\nstatic const struct of_device_id tegra_dpaux_of_match[] = {\n\t{ .compatible = \"nvidia,tegra194-dpaux\", .data = &tegra194_dpaux_soc },\n\t{ .compatible = \"nvidia,tegra186-dpaux\", .data = &tegra210_dpaux_soc },\n\t{ .compatible = \"nvidia,tegra210-dpaux\", .data = &tegra210_dpaux_soc },\n\t{ .compatible = \"nvidia,tegra124-dpaux\", .data = &tegra124_dpaux_soc },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_dpaux_of_match);\n\nstruct platform_driver tegra_dpaux_driver = {\n\t.driver = {\n\t\t.name = \"tegra-dpaux\",\n\t\t.of_match_table = tegra_dpaux_of_match,\n\t\t.pm = pm_ptr(&tegra_dpaux_pm_ops),\n\t},\n\t.probe = tegra_dpaux_probe,\n\t.remove_new = tegra_dpaux_remove,\n};\n\nstruct drm_dp_aux *drm_dp_aux_find_by_of_node(struct device_node *np)\n{\n\tstruct tegra_dpaux *dpaux;\n\n\tmutex_lock(&dpaux_lock);\n\n\tlist_for_each_entry(dpaux, &dpaux_list, list)\n\t\tif (np == dpaux->dev->of_node) {\n\t\t\tmutex_unlock(&dpaux_lock);\n\t\t\treturn &dpaux->aux;\n\t\t}\n\n\tmutex_unlock(&dpaux_lock);\n\n\treturn NULL;\n}\n\nint drm_dp_aux_attach(struct drm_dp_aux *aux, struct tegra_output *output)\n{\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\tunsigned long timeout;\n\tint err;\n\n\taux->drm_dev = output->connector.dev;\n\terr = drm_dp_aux_register(aux);\n\tif (err < 0)\n\t\treturn err;\n\n\toutput->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\tdpaux->output = output;\n\n\tif (output->panel) {\n\t\tenum drm_connector_status status;\n\n\t\tif (dpaux->vdd) {\n\t\t\terr = regulator_enable(dpaux->vdd);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\t\twhile (time_before(jiffies, timeout)) {\n\t\t\tstatus = drm_dp_aux_detect(aux);\n\n\t\t\tif (status == connector_status_connected)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\n\t\tif (status != connector_status_connected)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tenable_irq(dpaux->irq);\n\treturn 0;\n}\n\nint drm_dp_aux_detach(struct drm_dp_aux *aux)\n{\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\tunsigned long timeout;\n\tint err;\n\n\tdrm_dp_aux_unregister(aux);\n\tdisable_irq(dpaux->irq);\n\n\tif (dpaux->output->panel) {\n\t\tenum drm_connector_status status;\n\n\t\tif (dpaux->vdd) {\n\t\t\terr = regulator_disable(dpaux->vdd);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\t\twhile (time_before(jiffies, timeout)) {\n\t\t\tstatus = drm_dp_aux_detect(aux);\n\n\t\t\tif (status == connector_status_disconnected)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\n\t\tif (status != connector_status_disconnected)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tdpaux->output = NULL;\n\t}\n\n\treturn 0;\n}\n\nenum drm_connector_status drm_dp_aux_detect(struct drm_dp_aux *aux)\n{\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\tu32 value;\n\n\tvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\n\n\tif (value & DPAUX_DP_AUXSTAT_HPD_STATUS)\n\t\treturn connector_status_connected;\n\n\treturn connector_status_disconnected;\n}\n\nint drm_dp_aux_enable(struct drm_dp_aux *aux)\n{\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\n\treturn tegra_dpaux_pad_config(dpaux, DPAUX_PADCTL_FUNC_AUX);\n}\n\nint drm_dp_aux_disable(struct drm_dp_aux *aux)\n{\n\tstruct tegra_dpaux *dpaux = to_dpaux(aux);\n\n\ttegra_dpaux_pad_power_down(dpaux);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}