{
  "module_name": "gr3d.c",
  "hash_id": "3d01520960d763089e012515c9783ed4ec51367d9b1fb4c15eaaf3cae72e8212",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/gr3d.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/pmc.h>\n\n#include \"drm.h\"\n#include \"gem.h\"\n#include \"gr3d.h\"\n\nenum {\n\tRST_MC,\n\tRST_GR3D,\n\tRST_MC2,\n\tRST_GR3D2,\n\tRST_GR3D_MAX,\n};\n\nstruct gr3d_soc {\n\tunsigned int version;\n\tunsigned int num_clocks;\n\tunsigned int num_resets;\n};\n\nstruct gr3d {\n\tstruct tegra_drm_client client;\n\tstruct host1x_channel *channel;\n\n\tconst struct gr3d_soc *soc;\n\tstruct clk_bulk_data *clocks;\n\tunsigned int nclocks;\n\tstruct reset_control_bulk_data resets[RST_GR3D_MAX];\n\tunsigned int nresets;\n\n\tDECLARE_BITMAP(addr_regs, GR3D_NUM_REGS);\n};\n\nstatic inline struct gr3d *to_gr3d(struct tegra_drm_client *client)\n{\n\treturn container_of(client, struct gr3d, client);\n}\n\nstatic int gr3d_init(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tunsigned long flags = HOST1X_SYNCPT_HAS_BASE;\n\tstruct gr3d *gr3d = to_gr3d(drm);\n\tint err;\n\n\tgr3d->channel = host1x_channel_request(client);\n\tif (!gr3d->channel)\n\t\treturn -ENOMEM;\n\n\tclient->syncpts[0] = host1x_syncpt_request(client, flags);\n\tif (!client->syncpts[0]) {\n\t\terr = -ENOMEM;\n\t\tdev_err(client->dev, \"failed to request syncpoint: %d\\n\", err);\n\t\tgoto put;\n\t}\n\n\terr = host1x_client_iommu_attach(client);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to attach to domain: %d\\n\", err);\n\t\tgoto free;\n\t}\n\n\terr = tegra_drm_register_client(dev->dev_private, drm);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to register client: %d\\n\", err);\n\t\tgoto detach_iommu;\n\t}\n\n\treturn 0;\n\ndetach_iommu:\n\thost1x_client_iommu_detach(client);\nfree:\n\thost1x_syncpt_put(client->syncpts[0]);\nput:\n\thost1x_channel_put(gr3d->channel);\n\treturn err;\n}\n\nstatic int gr3d_exit(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct gr3d *gr3d = to_gr3d(drm);\n\tint err;\n\n\terr = tegra_drm_unregister_client(dev->dev_private, drm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpm_runtime_dont_use_autosuspend(client->dev);\n\tpm_runtime_force_suspend(client->dev);\n\n\thost1x_client_iommu_detach(client);\n\thost1x_syncpt_put(client->syncpts[0]);\n\thost1x_channel_put(gr3d->channel);\n\n\tgr3d->channel = NULL;\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops gr3d_client_ops = {\n\t.init = gr3d_init,\n\t.exit = gr3d_exit,\n};\n\nstatic int gr3d_open_channel(struct tegra_drm_client *client,\n\t\t\t     struct tegra_drm_context *context)\n{\n\tstruct gr3d *gr3d = to_gr3d(client);\n\n\tcontext->channel = host1x_channel_get(gr3d->channel);\n\tif (!context->channel)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void gr3d_close_channel(struct tegra_drm_context *context)\n{\n\thost1x_channel_put(context->channel);\n}\n\nstatic int gr3d_is_addr_reg(struct device *dev, u32 class, u32 offset)\n{\n\tstruct gr3d *gr3d = dev_get_drvdata(dev);\n\n\tswitch (class) {\n\tcase HOST1X_CLASS_HOST1X:\n\t\tif (offset == 0x2b)\n\t\t\treturn 1;\n\n\t\tbreak;\n\n\tcase HOST1X_CLASS_GR3D:\n\t\tif (offset >= GR3D_NUM_REGS)\n\t\t\tbreak;\n\n\t\tif (test_bit(offset, gr3d->addr_regs))\n\t\t\treturn 1;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tegra_drm_client_ops gr3d_ops = {\n\t.open_channel = gr3d_open_channel,\n\t.close_channel = gr3d_close_channel,\n\t.is_addr_reg = gr3d_is_addr_reg,\n\t.submit = tegra_drm_submit,\n};\n\nstatic const struct gr3d_soc tegra20_gr3d_soc = {\n\t.version = 0x20,\n\t.num_clocks = 1,\n\t.num_resets = 2,\n};\n\nstatic const struct gr3d_soc tegra30_gr3d_soc = {\n\t.version = 0x30,\n\t.num_clocks = 2,\n\t.num_resets = 4,\n};\n\nstatic const struct gr3d_soc tegra114_gr3d_soc = {\n\t.version = 0x35,\n\t.num_clocks = 1,\n\t.num_resets = 2,\n};\n\nstatic const struct of_device_id tegra_gr3d_match[] = {\n\t{ .compatible = \"nvidia,tegra114-gr3d\", .data = &tegra114_gr3d_soc },\n\t{ .compatible = \"nvidia,tegra30-gr3d\", .data = &tegra30_gr3d_soc },\n\t{ .compatible = \"nvidia,tegra20-gr3d\", .data = &tegra20_gr3d_soc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_gr3d_match);\n\nstatic const u32 gr3d_addr_regs[] = {\n\tGR3D_IDX_ATTRIBUTE( 0),\n\tGR3D_IDX_ATTRIBUTE( 1),\n\tGR3D_IDX_ATTRIBUTE( 2),\n\tGR3D_IDX_ATTRIBUTE( 3),\n\tGR3D_IDX_ATTRIBUTE( 4),\n\tGR3D_IDX_ATTRIBUTE( 5),\n\tGR3D_IDX_ATTRIBUTE( 6),\n\tGR3D_IDX_ATTRIBUTE( 7),\n\tGR3D_IDX_ATTRIBUTE( 8),\n\tGR3D_IDX_ATTRIBUTE( 9),\n\tGR3D_IDX_ATTRIBUTE(10),\n\tGR3D_IDX_ATTRIBUTE(11),\n\tGR3D_IDX_ATTRIBUTE(12),\n\tGR3D_IDX_ATTRIBUTE(13),\n\tGR3D_IDX_ATTRIBUTE(14),\n\tGR3D_IDX_ATTRIBUTE(15),\n\tGR3D_IDX_INDEX_BASE,\n\tGR3D_QR_ZTAG_ADDR,\n\tGR3D_QR_CTAG_ADDR,\n\tGR3D_QR_CZ_ADDR,\n\tGR3D_TEX_TEX_ADDR( 0),\n\tGR3D_TEX_TEX_ADDR( 1),\n\tGR3D_TEX_TEX_ADDR( 2),\n\tGR3D_TEX_TEX_ADDR( 3),\n\tGR3D_TEX_TEX_ADDR( 4),\n\tGR3D_TEX_TEX_ADDR( 5),\n\tGR3D_TEX_TEX_ADDR( 6),\n\tGR3D_TEX_TEX_ADDR( 7),\n\tGR3D_TEX_TEX_ADDR( 8),\n\tGR3D_TEX_TEX_ADDR( 9),\n\tGR3D_TEX_TEX_ADDR(10),\n\tGR3D_TEX_TEX_ADDR(11),\n\tGR3D_TEX_TEX_ADDR(12),\n\tGR3D_TEX_TEX_ADDR(13),\n\tGR3D_TEX_TEX_ADDR(14),\n\tGR3D_TEX_TEX_ADDR(15),\n\tGR3D_DW_MEMORY_OUTPUT_ADDRESS,\n\tGR3D_GLOBAL_SURFADDR( 0),\n\tGR3D_GLOBAL_SURFADDR( 1),\n\tGR3D_GLOBAL_SURFADDR( 2),\n\tGR3D_GLOBAL_SURFADDR( 3),\n\tGR3D_GLOBAL_SURFADDR( 4),\n\tGR3D_GLOBAL_SURFADDR( 5),\n\tGR3D_GLOBAL_SURFADDR( 6),\n\tGR3D_GLOBAL_SURFADDR( 7),\n\tGR3D_GLOBAL_SURFADDR( 8),\n\tGR3D_GLOBAL_SURFADDR( 9),\n\tGR3D_GLOBAL_SURFADDR(10),\n\tGR3D_GLOBAL_SURFADDR(11),\n\tGR3D_GLOBAL_SURFADDR(12),\n\tGR3D_GLOBAL_SURFADDR(13),\n\tGR3D_GLOBAL_SURFADDR(14),\n\tGR3D_GLOBAL_SURFADDR(15),\n\tGR3D_GLOBAL_SPILLSURFADDR,\n\tGR3D_GLOBAL_SURFOVERADDR( 0),\n\tGR3D_GLOBAL_SURFOVERADDR( 1),\n\tGR3D_GLOBAL_SURFOVERADDR( 2),\n\tGR3D_GLOBAL_SURFOVERADDR( 3),\n\tGR3D_GLOBAL_SURFOVERADDR( 4),\n\tGR3D_GLOBAL_SURFOVERADDR( 5),\n\tGR3D_GLOBAL_SURFOVERADDR( 6),\n\tGR3D_GLOBAL_SURFOVERADDR( 7),\n\tGR3D_GLOBAL_SURFOVERADDR( 8),\n\tGR3D_GLOBAL_SURFOVERADDR( 9),\n\tGR3D_GLOBAL_SURFOVERADDR(10),\n\tGR3D_GLOBAL_SURFOVERADDR(11),\n\tGR3D_GLOBAL_SURFOVERADDR(12),\n\tGR3D_GLOBAL_SURFOVERADDR(13),\n\tGR3D_GLOBAL_SURFOVERADDR(14),\n\tGR3D_GLOBAL_SURFOVERADDR(15),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 0),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 1),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 2),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 3),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 4),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 5),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 6),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 7),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 8),\n\tGR3D_GLOBAL_SAMP01SURFADDR( 9),\n\tGR3D_GLOBAL_SAMP01SURFADDR(10),\n\tGR3D_GLOBAL_SAMP01SURFADDR(11),\n\tGR3D_GLOBAL_SAMP01SURFADDR(12),\n\tGR3D_GLOBAL_SAMP01SURFADDR(13),\n\tGR3D_GLOBAL_SAMP01SURFADDR(14),\n\tGR3D_GLOBAL_SAMP01SURFADDR(15),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 0),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 1),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 2),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 3),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 4),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 5),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 6),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 7),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 8),\n\tGR3D_GLOBAL_SAMP23SURFADDR( 9),\n\tGR3D_GLOBAL_SAMP23SURFADDR(10),\n\tGR3D_GLOBAL_SAMP23SURFADDR(11),\n\tGR3D_GLOBAL_SAMP23SURFADDR(12),\n\tGR3D_GLOBAL_SAMP23SURFADDR(13),\n\tGR3D_GLOBAL_SAMP23SURFADDR(14),\n\tGR3D_GLOBAL_SAMP23SURFADDR(15),\n};\n\nstatic int gr3d_power_up_legacy_domain(struct device *dev, const char *name,\n\t\t\t\t       unsigned int id)\n{\n\tstruct gr3d *gr3d = dev_get_drvdata(dev);\n\tstruct reset_control *reset;\n\tstruct clk *clk;\n\tunsigned int i;\n\tint err;\n\n\t \n\tif (gr3d->nclocks == 1) {\n\t\tif (id == TEGRA_POWERGATE_3D1)\n\t\t\treturn 0;\n\n\t\tclk = gr3d->clocks[0].clk;\n\t} else {\n\t\tfor (i = 0; i < gr3d->nclocks; i++) {\n\t\t\tif (WARN_ON(!gr3d->clocks[i].id))\n\t\t\t\tcontinue;\n\n\t\t\tif (!strcmp(gr3d->clocks[i].id, name)) {\n\t\t\t\tclk = gr3d->clocks[i].clk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON(i == gr3d->nclocks))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\treset = reset_control_get_exclusive_released(dev, name);\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\terr = reset_control_acquire(reset);\n\tif (err) {\n\t\tdev_err(dev, \"failed to acquire %s reset: %d\\n\", name, err);\n\t} else {\n\t\terr = tegra_powergate_sequence_power_up(id, clk, reset);\n\t\treset_control_release(reset);\n\t}\n\n\treset_control_put(reset);\n\tif (err)\n\t\treturn err;\n\n\t \n\tclk_disable_unprepare(clk);\n\n\treturn 0;\n}\n\nstatic void gr3d_del_link(void *link)\n{\n\tdevice_link_del(link);\n}\n\nstatic int gr3d_init_power(struct device *dev, struct gr3d *gr3d)\n{\n\tstatic const char * const opp_genpd_names[] = { \"3d0\", \"3d1\", NULL };\n\tconst u32 link_flags = DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME;\n\tstruct device **opp_virt_devs, *pd_dev;\n\tstruct device_link *link;\n\tunsigned int i;\n\tint err;\n\n\terr = of_count_phandle_with_args(dev->of_node, \"power-domains\",\n\t\t\t\t\t \"#power-domain-cells\");\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\treturn err;\n\n\t\t \n\t\terr = gr3d_power_up_legacy_domain(dev, \"3d\",\n\t\t\t\t\t\t  TEGRA_POWERGATE_3D);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = gr3d_power_up_legacy_domain(dev, \"3d2\",\n\t\t\t\t\t\t  TEGRA_POWERGATE_3D1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (dev->pm_domain)\n\t\treturn 0;\n\n\terr = devm_pm_opp_attach_genpd(dev, opp_genpd_names, &opp_virt_devs);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; opp_genpd_names[i]; i++) {\n\t\tpd_dev = opp_virt_devs[i];\n\t\tif (!pd_dev) {\n\t\t\tdev_err(dev, \"failed to get %s power domain\\n\",\n\t\t\t\topp_genpd_names[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlink = device_link_add(dev, pd_dev, link_flags);\n\t\tif (!link) {\n\t\t\tdev_err(dev, \"failed to link to %s\\n\", dev_name(pd_dev));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = devm_add_action_or_reset(dev, gr3d_del_link, link);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int gr3d_get_clocks(struct device *dev, struct gr3d *gr3d)\n{\n\tint err;\n\n\terr = devm_clk_bulk_get_all(dev, &gr3d->clocks);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\tgr3d->nclocks = err;\n\n\tif (gr3d->nclocks != gr3d->soc->num_clocks) {\n\t\tdev_err(dev, \"invalid number of clocks: %u\\n\", gr3d->nclocks);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int gr3d_get_resets(struct device *dev, struct gr3d *gr3d)\n{\n\tint err;\n\n\tgr3d->resets[RST_MC].id = \"mc\";\n\tgr3d->resets[RST_MC2].id = \"mc2\";\n\tgr3d->resets[RST_GR3D].id = \"3d\";\n\tgr3d->resets[RST_GR3D2].id = \"3d2\";\n\tgr3d->nresets = gr3d->soc->num_resets;\n\n\terr = devm_reset_control_bulk_get_optional_exclusive_released(\n\t\t\t\tdev, gr3d->nresets, gr3d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (WARN_ON(!gr3d->resets[RST_GR3D].rstc) ||\n\t    WARN_ON(!gr3d->resets[RST_GR3D2].rstc && gr3d->nresets == 4))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int gr3d_probe(struct platform_device *pdev)\n{\n\tstruct host1x_syncpt **syncpts;\n\tstruct gr3d *gr3d;\n\tunsigned int i;\n\tint err;\n\n\tgr3d = devm_kzalloc(&pdev->dev, sizeof(*gr3d), GFP_KERNEL);\n\tif (!gr3d)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, gr3d);\n\n\tgr3d->soc = of_device_get_match_data(&pdev->dev);\n\n\tsyncpts = devm_kzalloc(&pdev->dev, sizeof(*syncpts), GFP_KERNEL);\n\tif (!syncpts)\n\t\treturn -ENOMEM;\n\n\terr = gr3d_get_clocks(&pdev->dev, gr3d);\n\tif (err)\n\t\treturn err;\n\n\terr = gr3d_get_resets(&pdev->dev, gr3d);\n\tif (err)\n\t\treturn err;\n\n\terr = gr3d_init_power(&pdev->dev, gr3d);\n\tif (err)\n\t\treturn err;\n\n\tINIT_LIST_HEAD(&gr3d->client.base.list);\n\tgr3d->client.base.ops = &gr3d_client_ops;\n\tgr3d->client.base.dev = &pdev->dev;\n\tgr3d->client.base.class = HOST1X_CLASS_GR3D;\n\tgr3d->client.base.syncpts = syncpts;\n\tgr3d->client.base.num_syncpts = 1;\n\n\tINIT_LIST_HEAD(&gr3d->client.list);\n\tgr3d->client.version = gr3d->soc->version;\n\tgr3d->client.ops = &gr3d_ops;\n\n\terr = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = host1x_client_register(&gr3d->client.base);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gr3d_addr_regs); i++)\n\t\tset_bit(gr3d_addr_regs[i], gr3d->addr_regs);\n\n\treturn 0;\n}\n\nstatic void gr3d_remove(struct platform_device *pdev)\n{\n\tstruct gr3d *gr3d = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\thost1x_client_unregister(&gr3d->client.base);\n}\n\nstatic int __maybe_unused gr3d_runtime_suspend(struct device *dev)\n{\n\tstruct gr3d *gr3d = dev_get_drvdata(dev);\n\tint err;\n\n\thost1x_channel_stop(gr3d->channel);\n\n\terr = reset_control_bulk_assert(gr3d->nresets, gr3d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusleep_range(10, 20);\n\n\t \n\n\tclk_bulk_disable_unprepare(gr3d->nclocks, gr3d->clocks);\n\treset_control_bulk_release(gr3d->nresets, gr3d->resets);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused gr3d_runtime_resume(struct device *dev)\n{\n\tstruct gr3d *gr3d = dev_get_drvdata(dev);\n\tint err;\n\n\terr = reset_control_bulk_acquire(gr3d->nresets, gr3d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to acquire reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_bulk_prepare_enable(gr3d->nclocks, gr3d->clocks);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\tgoto release_reset;\n\t}\n\n\terr = reset_control_bulk_deassert(gr3d->nresets, gr3d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 500);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_bulk_disable_unprepare(gr3d->nclocks, gr3d->clocks);\nrelease_reset:\n\treset_control_bulk_release(gr3d->nresets, gr3d->resets);\n\n\treturn err;\n}\n\nstatic const struct dev_pm_ops tegra_gr3d_pm = {\n\tSET_RUNTIME_PM_OPS(gr3d_runtime_suspend, gr3d_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstruct platform_driver tegra_gr3d_driver = {\n\t.driver = {\n\t\t.name = \"tegra-gr3d\",\n\t\t.of_match_table = tegra_gr3d_match,\n\t\t.pm = &tegra_gr3d_pm,\n\t},\n\t.probe = gr3d_probe,\n\t.remove_new = gr3d_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}