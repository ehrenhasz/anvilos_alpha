{
  "module_name": "output.c",
  "hash_id": "fa738a3fb5b9b481627900221c5206a43668fb8b598a303b579b3db7ca158be5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/output.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/of.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"drm.h\"\n#include \"dc.h\"\n\n#include <media/cec-notifier.h>\n\nint tegra_output_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct edid *edid = NULL;\n\tint err = 0;\n\n\t \n\tif (output->panel) {\n\t\terr = drm_panel_get_modes(output->panel, connector);\n\t\tif (err > 0)\n\t\t\treturn err;\n\t}\n\n\tif (output->edid)\n\t\tedid = kmemdup(output->edid, sizeof(*edid), GFP_KERNEL);\n\telse if (output->ddc)\n\t\tedid = drm_get_edid(connector, output->ddc);\n\n\tcec_notifier_set_phys_addr_from_edid(output->cec, edid);\n\tdrm_connector_update_edid_property(connector, edid);\n\n\tif (edid) {\n\t\terr = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn err;\n}\n\nenum drm_connector_status\ntegra_output_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tenum drm_connector_status status = connector_status_unknown;\n\n\tif (output->hpd_gpio) {\n\t\tif (gpiod_get_value(output->hpd_gpio) == 0)\n\t\t\tstatus = connector_status_disconnected;\n\t\telse\n\t\t\tstatus = connector_status_connected;\n\t} else {\n\t\tif (!output->panel)\n\t\t\tstatus = connector_status_disconnected;\n\t\telse\n\t\t\tstatus = connector_status_connected;\n\t}\n\n\tif (status != connector_status_connected)\n\t\tcec_notifier_phys_addr_invalidate(output->cec);\n\n\treturn status;\n}\n\nvoid tegra_output_connector_destroy(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\n\tif (output->cec)\n\t\tcec_notifier_conn_unregister(output->cec);\n\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic irqreturn_t hpd_irq(int irq, void *data)\n{\n\tstruct tegra_output *output = data;\n\n\tif (output->connector.dev)\n\t\tdrm_helper_hpd_irq_event(output->connector.dev);\n\n\treturn IRQ_HANDLED;\n}\n\nint tegra_output_probe(struct tegra_output *output)\n{\n\tstruct device_node *ddc, *panel;\n\tunsigned long flags;\n\tint err, size;\n\n\tif (!output->of_node)\n\t\toutput->of_node = output->dev->of_node;\n\n\terr = drm_of_find_panel_or_bridge(output->of_node, -1, -1,\n\t\t\t\t\t  &output->panel, &output->bridge);\n\tif (err && err != -ENODEV)\n\t\treturn err;\n\n\tpanel = of_parse_phandle(output->of_node, \"nvidia,panel\", 0);\n\tif (panel) {\n\t\t \n\t\tWARN_ON(output->panel || output->bridge);\n\n\t\toutput->panel = of_drm_find_panel(panel);\n\t\tof_node_put(panel);\n\n\t\tif (IS_ERR(output->panel))\n\t\t\treturn PTR_ERR(output->panel);\n\t}\n\n\toutput->edid = of_get_property(output->of_node, \"nvidia,edid\", &size);\n\n\tddc = of_parse_phandle(output->of_node, \"nvidia,ddc-i2c-bus\", 0);\n\tif (ddc) {\n\t\toutput->ddc = of_get_i2c_adapter_by_node(ddc);\n\t\tof_node_put(ddc);\n\n\t\tif (!output->ddc) {\n\t\t\terr = -EPROBE_DEFER;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\toutput->hpd_gpio = devm_fwnode_gpiod_get(output->dev,\n\t\t\t\t\tof_fwnode_handle(output->of_node),\n\t\t\t\t\t\"nvidia,hpd\",\n\t\t\t\t\tGPIOD_IN,\n\t\t\t\t\t\"HDMI hotplug detect\");\n\tif (IS_ERR(output->hpd_gpio)) {\n\t\tif (PTR_ERR(output->hpd_gpio) != -ENOENT)\n\t\t\treturn PTR_ERR(output->hpd_gpio);\n\n\t\toutput->hpd_gpio = NULL;\n\t}\n\n\tif (output->hpd_gpio) {\n\t\terr = gpiod_to_irq(output->hpd_gpio);\n\t\tif (err < 0) {\n\t\t\tdev_err(output->dev, \"gpiod_to_irq(): %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\toutput->hpd_irq = err;\n\n\t\tflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\n\t\t\tIRQF_ONESHOT;\n\n\t\terr = request_threaded_irq(output->hpd_irq, NULL, hpd_irq,\n\t\t\t\t\t   flags, \"hpd\", output);\n\t\tif (err < 0) {\n\t\t\tdev_err(output->dev, \"failed to request IRQ#%u: %d\\n\",\n\t\t\t\toutput->hpd_irq, err);\n\t\t\treturn err;\n\t\t}\n\n\t\toutput->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\t\t \n\t\tdisable_irq(output->hpd_irq);\n\t}\n\n\treturn 0;\n}\n\nvoid tegra_output_remove(struct tegra_output *output)\n{\n\tif (output->hpd_gpio)\n\t\tfree_irq(output->hpd_irq, output);\n\n\tif (output->ddc)\n\t\ti2c_put_adapter(output->ddc);\n}\n\nint tegra_output_init(struct drm_device *drm, struct tegra_output *output)\n{\n\tint connector_type;\n\n\t \n\tif (output->hpd_gpio)\n\t\tenable_irq(output->hpd_irq);\n\n\tconnector_type = output->connector.connector_type;\n\t \n\tif (connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    connector_type == DRM_MODE_CONNECTOR_HDMIB) {\n\t\tstruct cec_connector_info conn_info;\n\n\t\tcec_fill_conn_info_from_drm(&conn_info, &output->connector);\n\t\toutput->cec = cec_notifier_conn_register(output->dev, NULL,\n\t\t\t\t\t\t\t &conn_info);\n\t\tif (!output->cec)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid tegra_output_exit(struct tegra_output *output)\n{\n\t \n\tif (output->hpd_gpio)\n\t\tdisable_irq(output->hpd_irq);\n}\n\nvoid tegra_output_find_possible_crtcs(struct tegra_output *output,\n\t\t\t\t      struct drm_device *drm)\n{\n\tstruct device *dev = output->dev;\n\tstruct drm_crtc *crtc;\n\tunsigned int mask = 0;\n\n\tdrm_for_each_crtc(crtc, drm) {\n\t\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\n\t\tif (tegra_dc_has_output(dc, dev))\n\t\t\tmask |= drm_crtc_mask(crtc);\n\t}\n\n\tif (mask == 0) {\n\t\tdev_warn(dev, \"missing output definition for heads in DT\\n\");\n\t\tmask = 0x3;\n\t}\n\n\toutput->encoder.possible_crtcs = mask;\n}\n\nint tegra_output_suspend(struct tegra_output *output)\n{\n\tif (output->hpd_irq)\n\t\tdisable_irq(output->hpd_irq);\n\n\treturn 0;\n}\n\nint tegra_output_resume(struct tegra_output *output)\n{\n\tif (output->hpd_irq)\n\t\tenable_irq(output->hpd_irq);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}