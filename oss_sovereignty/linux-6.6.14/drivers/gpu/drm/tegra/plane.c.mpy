{
  "module_name": "plane.c",
  "hash_id": "44af38502548d3f660aaeb76e4d587ef2a4621cf4f478737429f0e7e382f5bae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/plane.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/iommu.h>\n#include <linux/interconnect.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n\n#include \"dc.h\"\n#include \"plane.h\"\n\nstatic void tegra_plane_destroy(struct drm_plane *plane)\n{\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\n\tdrm_plane_cleanup(plane);\n\tkfree(p);\n}\n\nstatic void tegra_plane_reset(struct drm_plane *plane)\n{\n\tstruct tegra_plane *p = to_tegra_plane(plane);\n\tstruct tegra_plane_state *state;\n\tunsigned int i;\n\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\n\tkfree(plane->state);\n\tplane->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state) {\n\t\tplane->state = &state->base;\n\t\tplane->state->plane = plane;\n\t\tplane->state->zpos = p->index;\n\t\tplane->state->normalized_zpos = p->index;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tstate->iova[i] = DMA_MAPPING_ERROR;\n\t}\n}\n\nstatic struct drm_plane_state *\ntegra_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct tegra_plane_state *state = to_tegra_plane_state(plane->state);\n\tstruct tegra_plane_state *copy;\n\tunsigned int i;\n\n\tcopy = kmalloc(sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);\n\tcopy->tiling = state->tiling;\n\tcopy->format = state->format;\n\tcopy->swap = state->swap;\n\tcopy->reflect_x = state->reflect_x;\n\tcopy->reflect_y = state->reflect_y;\n\tcopy->opaque = state->opaque;\n\tcopy->total_peak_memory_bandwidth = state->total_peak_memory_bandwidth;\n\tcopy->peak_memory_bandwidth = state->peak_memory_bandwidth;\n\tcopy->avg_memory_bandwidth = state->avg_memory_bandwidth;\n\n\tfor (i = 0; i < 2; i++)\n\t\tcopy->blending[i] = state->blending[i];\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcopy->iova[i] = DMA_MAPPING_ERROR;\n\t\tcopy->map[i] = NULL;\n\t}\n\n\treturn &copy->base;\n}\n\nstatic void tegra_plane_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(state);\n}\n\nstatic bool tegra_plane_supports_sector_layout(struct drm_plane *plane)\n{\n\tstruct drm_crtc *crtc;\n\n\tdrm_for_each_crtc(crtc, plane->dev) {\n\t\tif (plane->possible_crtcs & drm_crtc_mask(crtc)) {\n\t\t\tstruct tegra_dc *dc = to_tegra_dc(crtc);\n\n\t\t\tif (!dc->soc->supports_sector_layout)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool tegra_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t     uint32_t format,\n\t\t\t\t\t     uint64_t modifier)\n{\n\tconst struct drm_format_info *info = drm_format_info(format);\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\t \n\tif (fourcc_mod_is_vendor(modifier, NVIDIA)) {\n\t\tif (modifier & DRM_FORMAT_MOD_NVIDIA_SECTOR_LAYOUT) {\n\t\t\tif (!tegra_plane_supports_sector_layout(plane))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (info->num_planes == 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nconst struct drm_plane_funcs tegra_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = tegra_plane_destroy,\n\t.reset = tegra_plane_reset,\n\t.atomic_duplicate_state = tegra_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = tegra_plane_atomic_destroy_state,\n\t.format_mod_supported = tegra_plane_format_mod_supported,\n};\n\nstatic int tegra_dc_pin(struct tegra_dc *dc, struct tegra_plane_state *state)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < state->base.fb->format->num_planes; i++) {\n\t\tstruct tegra_bo *bo = tegra_fb_get_plane(state->base.fb, i);\n\t\tstruct host1x_bo_mapping *map;\n\n\t\tmap = host1x_bo_pin(dc->dev, &bo->base, DMA_TO_DEVICE, &dc->client.cache);\n\t\tif (IS_ERR(map)) {\n\t\t\terr = PTR_ERR(map);\n\t\t\tgoto unpin;\n\t\t}\n\n\t\tif (!dc->client.group) {\n\t\t\t \n\t\t\tif (map->chunks > 1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto unpin;\n\t\t\t}\n\n\t\t\tstate->iova[i] = map->phys;\n\t\t} else {\n\t\t\tstate->iova[i] = bo->iova;\n\t\t}\n\n\t\tstate->map[i] = map;\n\t}\n\n\treturn 0;\n\nunpin:\n\tdev_err(dc->dev, \"failed to map plane %u: %d\\n\", i, err);\n\n\twhile (i--) {\n\t\thost1x_bo_unpin(state->map[i]);\n\t\tstate->iova[i] = DMA_MAPPING_ERROR;\n\t\tstate->map[i] = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic void tegra_dc_unpin(struct tegra_dc *dc, struct tegra_plane_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < state->base.fb->format->num_planes; i++) {\n\t\thost1x_bo_unpin(state->map[i]);\n\t\tstate->iova[i] = DMA_MAPPING_ERROR;\n\t\tstate->map[i] = NULL;\n\t}\n}\n\nint tegra_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t   struct drm_plane_state *state)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(state->crtc);\n\tint err;\n\n\tif (!state->fb)\n\t\treturn 0;\n\n\terr = drm_gem_plane_helper_prepare_fb(plane, state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn tegra_dc_pin(dc, to_tegra_plane_state(state));\n}\n\nvoid tegra_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t    struct drm_plane_state *state)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(state->crtc);\n\n\tif (dc)\n\t\ttegra_dc_unpin(dc, to_tegra_plane_state(state));\n}\n\nstatic int tegra_plane_calculate_memory_bandwidth(struct drm_plane_state *state)\n{\n\tstruct tegra_plane_state *tegra_state = to_tegra_plane_state(state);\n\tunsigned int i, bpp, dst_w, dst_h, src_w, src_h, mul;\n\tconst struct tegra_dc_soc_info *soc;\n\tconst struct drm_format_info *fmt;\n\tstruct drm_crtc_state *crtc_state;\n\tu64 avg_bandwidth, peak_bandwidth;\n\n\tif (!state->visible)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state->state, state->crtc);\n\tif (!crtc_state)\n\t\treturn -EINVAL;\n\n\tsrc_w = drm_rect_width(&state->src) >> 16;\n\tsrc_h = drm_rect_height(&state->src) >> 16;\n\tdst_w = drm_rect_width(&state->dst);\n\tdst_h = drm_rect_height(&state->dst);\n\n\tfmt = state->fb->format;\n\tsoc = to_tegra_dc(state->crtc)->soc;\n\n\t \n\tfor (i = 0, bpp = 0; i < fmt->num_planes; i++) {\n\t\tunsigned int bpp_plane = fmt->cpp[i] * 8;\n\n\t\t \n\t\tif (i > 0)\n\t\t\tbpp_plane /= fmt->hsub;\n\n\t\tbpp += bpp_plane;\n\t}\n\n\t \n\tavg_bandwidth  = min(src_w, dst_w) * min(src_h, dst_h);\n\tavg_bandwidth *= drm_mode_vrefresh(&crtc_state->adjusted_mode);\n\tavg_bandwidth  = DIV_ROUND_UP(avg_bandwidth * bpp, 8) + 999;\n\tdo_div(avg_bandwidth, 1000);\n\n\t \n\tpeak_bandwidth = DIV_ROUND_UP(crtc_state->adjusted_mode.clock * bpp, 8);\n\n\t \n\tif (soc->plane_tiled_memory_bandwidth_x2 &&\n\t    tegra_state->tiling.mode == TEGRA_BO_TILING_MODE_TILED)\n\t\tmul = 2;\n\telse\n\t\tmul = 1;\n\n\t \n\ttegra_state->peak_memory_bandwidth = kBps_to_icc(peak_bandwidth) * mul;\n\ttegra_state->avg_memory_bandwidth  = kBps_to_icc(avg_bandwidth)  * mul;\n\n\treturn 0;\n}\n\nint tegra_plane_state_add(struct tegra_plane *plane,\n\t\t\t  struct drm_plane_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct tegra_dc_state *tegra;\n\tint err;\n\n\t \n\tcrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\t \n\terr = drm_atomic_helper_check_plane_state(state, crtc_state,\n\t\t\t\t\t\t  0, INT_MAX, true, true);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_plane_calculate_memory_bandwidth(state);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra = to_dc_state(crtc_state);\n\n\ttegra->planes |= WIN_A_ACT_REQ << plane->index;\n\n\treturn 0;\n}\n\nint tegra_plane_format(u32 fourcc, u32 *format, u32 *swap)\n{\n\t \n\tif (swap)\n\t\t*swap = BYTE_SWAP_NOSWAP;\n\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_ARGB4444:\n\t\t*format = WIN_COLOR_DEPTH_B4G4R4A4;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ARGB1555:\n\t\t*format = WIN_COLOR_DEPTH_B5G5R5A1;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGB565:\n\t\t*format = WIN_COLOR_DEPTH_B5G6R5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBA5551:\n\t\t*format = WIN_COLOR_DEPTH_A1B5G5R5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ARGB8888:\n\t\t*format = WIN_COLOR_DEPTH_B8G8R8A8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ABGR8888:\n\t\t*format = WIN_COLOR_DEPTH_R8G8B8A8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ABGR4444:\n\t\t*format = WIN_COLOR_DEPTH_R4G4B4A4;\n\t\tbreak;\n\n\tcase DRM_FORMAT_ABGR1555:\n\t\t*format = WIN_COLOR_DEPTH_R5G5B5A;\n\t\tbreak;\n\n\tcase DRM_FORMAT_BGRA5551:\n\t\t*format = WIN_COLOR_DEPTH_AR5G5B5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB1555:\n\t\t*format = WIN_COLOR_DEPTH_B5G5R5X1;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBX5551:\n\t\t*format = WIN_COLOR_DEPTH_X1B5G5R5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XBGR1555:\n\t\t*format = WIN_COLOR_DEPTH_R5G5B5X1;\n\t\tbreak;\n\n\tcase DRM_FORMAT_BGRX5551:\n\t\t*format = WIN_COLOR_DEPTH_X1R5G5B5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_BGR565:\n\t\t*format = WIN_COLOR_DEPTH_R5G6B5;\n\t\tbreak;\n\n\tcase DRM_FORMAT_BGRA8888:\n\t\t*format = WIN_COLOR_DEPTH_A8R8G8B8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_RGBA8888:\n\t\t*format = WIN_COLOR_DEPTH_A8B8G8R8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB8888:\n\t\t*format = WIN_COLOR_DEPTH_B8G8R8X8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XBGR8888:\n\t\t*format = WIN_COLOR_DEPTH_R8G8B8X8;\n\t\tbreak;\n\n\tcase DRM_FORMAT_UYVY:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YUYV:\n\t\tif (!swap)\n\t\t\treturn -EINVAL;\n\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422;\n\t\t*swap = BYTE_SWAP_SWAP2;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YVYU:\n\t\tif (!swap)\n\t\t\treturn -EINVAL;\n\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422;\n\t\t*swap = BYTE_SWAP_SWAP4;\n\t\tbreak;\n\n\tcase DRM_FORMAT_VYUY:\n\t\tif (!swap)\n\t\t\treturn -EINVAL;\n\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422;\n\t\t*swap = BYTE_SWAP_SWAP4HW;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YUV420:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr420P;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YUV422:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422P;\n\t\tbreak;\n\n\tcase DRM_FORMAT_YUV444:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr444P;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV12:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr420SP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV21:\n\t\t*format = WIN_COLOR_DEPTH_YCrCb420SP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV16:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr422SP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV61:\n\t\t*format = WIN_COLOR_DEPTH_YCrCb422SP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV24:\n\t\t*format = WIN_COLOR_DEPTH_YCbCr444SP;\n\t\tbreak;\n\n\tcase DRM_FORMAT_NV42:\n\t\t*format = WIN_COLOR_DEPTH_YCrCb444SP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nbool tegra_plane_format_is_indexed(unsigned int format)\n{\n\tswitch (format) {\n\tcase WIN_COLOR_DEPTH_P1:\n\tcase WIN_COLOR_DEPTH_P2:\n\tcase WIN_COLOR_DEPTH_P4:\n\tcase WIN_COLOR_DEPTH_P8:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool tegra_plane_format_is_yuv(unsigned int format, unsigned int *planes, unsigned int *bpc)\n{\n\tswitch (format) {\n\tcase WIN_COLOR_DEPTH_YCbCr422:\n\tcase WIN_COLOR_DEPTH_YUV422:\n\t\tif (planes)\n\t\t\t*planes = 1;\n\n\t\tif (bpc)\n\t\t\t*bpc = 8;\n\n\t\treturn true;\n\n\tcase WIN_COLOR_DEPTH_YCbCr420P:\n\tcase WIN_COLOR_DEPTH_YUV420P:\n\tcase WIN_COLOR_DEPTH_YCbCr422P:\n\tcase WIN_COLOR_DEPTH_YUV422P:\n\tcase WIN_COLOR_DEPTH_YCbCr422R:\n\tcase WIN_COLOR_DEPTH_YUV422R:\n\tcase WIN_COLOR_DEPTH_YCbCr422RA:\n\tcase WIN_COLOR_DEPTH_YUV422RA:\n\tcase WIN_COLOR_DEPTH_YCbCr444P:\n\t\tif (planes)\n\t\t\t*planes = 3;\n\n\t\tif (bpc)\n\t\t\t*bpc = 8;\n\n\t\treturn true;\n\n\tcase WIN_COLOR_DEPTH_YCrCb420SP:\n\tcase WIN_COLOR_DEPTH_YCbCr420SP:\n\tcase WIN_COLOR_DEPTH_YCrCb422SP:\n\tcase WIN_COLOR_DEPTH_YCbCr422SP:\n\tcase WIN_COLOR_DEPTH_YCrCb444SP:\n\tcase WIN_COLOR_DEPTH_YCbCr444SP:\n\t\tif (planes)\n\t\t\t*planes = 2;\n\n\t\tif (bpc)\n\t\t\t*bpc = 8;\n\n\t\treturn true;\n\t}\n\n\tif (planes)\n\t\t*planes = 1;\n\n\treturn false;\n}\n\nstatic bool __drm_format_has_alpha(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_RGBA5551:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_plane_format_get_alpha(unsigned int opaque,\n\t\t\t\t\tunsigned int *alpha)\n{\n\tif (tegra_plane_format_is_yuv(opaque, NULL, NULL)) {\n\t\t*alpha = opaque;\n\t\treturn 0;\n\t}\n\n\tswitch (opaque) {\n\tcase WIN_COLOR_DEPTH_B5G5R5X1:\n\t\t*alpha = WIN_COLOR_DEPTH_B5G5R5A1;\n\t\treturn 0;\n\n\tcase WIN_COLOR_DEPTH_X1B5G5R5:\n\t\t*alpha = WIN_COLOR_DEPTH_A1B5G5R5;\n\t\treturn 0;\n\n\tcase WIN_COLOR_DEPTH_R8G8B8X8:\n\t\t*alpha = WIN_COLOR_DEPTH_R8G8B8A8;\n\t\treturn 0;\n\n\tcase WIN_COLOR_DEPTH_B8G8R8X8:\n\t\t*alpha = WIN_COLOR_DEPTH_B8G8R8A8;\n\t\treturn 0;\n\n\tcase WIN_COLOR_DEPTH_B5G6R5:\n\t\t*alpha = opaque;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int tegra_plane_setup_opacity(struct tegra_plane *tegra,\n\t\t\t\t     struct tegra_plane_state *state)\n{\n\tunsigned int format;\n\tint err;\n\n\tswitch (state->format) {\n\tcase WIN_COLOR_DEPTH_B5G5R5A1:\n\tcase WIN_COLOR_DEPTH_A1B5G5R5:\n\tcase WIN_COLOR_DEPTH_R8G8B8A8:\n\tcase WIN_COLOR_DEPTH_B8G8R8A8:\n\t\tstate->opaque = false;\n\t\tbreak;\n\n\tdefault:\n\t\terr = tegra_plane_format_get_alpha(state->format, &format);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tstate->format = format;\n\t\tstate->opaque = true;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_plane_check_transparency(struct tegra_plane *tegra,\n\t\t\t\t\t  struct tegra_plane_state *state)\n{\n\tstruct drm_plane_state *old, *plane_state;\n\tstruct drm_plane *plane;\n\n\told = drm_atomic_get_old_plane_state(state->base.state, &tegra->base);\n\n\t \n\tif (old->normalized_zpos == state->base.normalized_zpos &&\n\t    to_tegra_plane_state(old)->opaque == state->opaque)\n\t\treturn 0;\n\n\t \n\tdrm_for_each_plane(plane, tegra->base.dev) {\n\t\tstruct tegra_plane *p = to_tegra_plane(plane);\n\n\t\t \n\t\tif (p == tegra || p->dc != tegra->dc)\n\t\t\tcontinue;\n\n\t\tplane_state = drm_atomic_get_plane_state(state->base.state,\n\t\t\t\t\t\t\t plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\n\treturn 1;\n}\n\nstatic unsigned int tegra_plane_get_overlap_index(struct tegra_plane *plane,\n\t\t\t\t\t\t  struct tegra_plane *other)\n{\n\tunsigned int index = 0, i;\n\n\tWARN_ON(plane == other);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i == plane->index)\n\t\t\tcontinue;\n\n\t\tif (i == other->index)\n\t\t\tbreak;\n\n\t\tindex++;\n\t}\n\n\treturn index;\n}\n\nstatic void tegra_plane_update_transparency(struct tegra_plane *tegra,\n\t\t\t\t\t    struct tegra_plane_state *state)\n{\n\tstruct drm_plane_state *new;\n\tstruct drm_plane *plane;\n\tunsigned int i;\n\n\tfor_each_new_plane_in_state(state->base.state, plane, new, i) {\n\t\tstruct tegra_plane *p = to_tegra_plane(plane);\n\t\tunsigned index;\n\n\t\t \n\t\tif (p == tegra || p->dc != tegra->dc)\n\t\t\tcontinue;\n\n\t\tindex = tegra_plane_get_overlap_index(tegra, p);\n\n\t\tif (new->fb && __drm_format_has_alpha(new->fb->format->format))\n\t\t\tstate->blending[index].alpha = true;\n\t\telse\n\t\t\tstate->blending[index].alpha = false;\n\n\t\tif (new->normalized_zpos > state->base.normalized_zpos)\n\t\t\tstate->blending[index].top = true;\n\t\telse\n\t\t\tstate->blending[index].top = false;\n\n\t\t \n\t\tif (!new->fb)\n\t\t\tstate->blending[index].top = (index == 1);\n\t}\n}\n\nstatic int tegra_plane_setup_transparency(struct tegra_plane *tegra,\n\t\t\t\t\t  struct tegra_plane_state *state)\n{\n\tstruct tegra_plane_state *tegra_state;\n\tstruct drm_plane_state *new;\n\tstruct drm_plane *plane;\n\tint err;\n\n\t \n\terr = tegra_plane_check_transparency(tegra, state);\n\tif (err <= 0)\n\t\treturn err;\n\n\t \n\tdrm_for_each_plane(plane, tegra->base.dev) {\n\t\tstruct tegra_plane *p = to_tegra_plane(plane);\n\n\t\t \n\t\tif (p->dc != tegra->dc)\n\t\t\tcontinue;\n\n\t\tnew = drm_atomic_get_new_plane_state(state->base.state, plane);\n\t\ttegra_state = to_tegra_plane_state(new);\n\n\t\t \n\t\tif (new->fb)\n\t\t\ttegra_plane_update_transparency(p, tegra_state);\n\t}\n\n\treturn 0;\n}\n\nint tegra_plane_setup_legacy_state(struct tegra_plane *tegra,\n\t\t\t\t   struct tegra_plane_state *state)\n{\n\tint err;\n\n\terr = tegra_plane_setup_opacity(tegra, state);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_plane_setup_transparency(tegra, state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const char * const tegra_plane_icc_names[TEGRA_DC_LEGACY_PLANES_NUM] = {\n\t\"wina\", \"winb\", \"winc\", NULL, NULL, NULL, \"cursor\",\n};\n\nint tegra_plane_interconnect_init(struct tegra_plane *plane)\n{\n\tconst char *icc_name = tegra_plane_icc_names[plane->index];\n\tstruct device *dev = plane->dc->dev;\n\tstruct tegra_dc *dc = plane->dc;\n\tint err;\n\n\tif (WARN_ON(plane->index >= TEGRA_DC_LEGACY_PLANES_NUM) ||\n\t    WARN_ON(!tegra_plane_icc_names[plane->index]))\n\t\treturn -EINVAL;\n\n\tplane->icc_mem = devm_of_icc_get(dev, icc_name);\n\terr = PTR_ERR_OR_ZERO(plane->icc_mem);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to get %s interconnect\\n\",\n\t\t\t\t     icc_name);\n\n\t \n\tif (plane->index == 1 && dc->soc->has_win_b_vfilter_mem_client) {\n\t\tplane->icc_mem_vfilter = devm_of_icc_get(dev, \"winb-vfilter\");\n\t\terr = PTR_ERR_OR_ZERO(plane->icc_mem_vfilter);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err, \"failed to get %s interconnect\\n\",\n\t\t\t\t\t     \"winb-vfilter\");\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}