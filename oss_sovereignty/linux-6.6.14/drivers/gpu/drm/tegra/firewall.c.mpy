{
  "module_name": "firewall.c",
  "hash_id": "9957f78c9b0f846857d56a1cd3332cb93a44db49e1c363ecf72db86c22bf23c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/firewall.c",
  "human_readable_source": "\n \n\n#include \"drm.h\"\n#include \"submit.h\"\n#include \"uapi.h\"\n\nstruct tegra_drm_firewall {\n\tstruct tegra_drm_submit_data *submit;\n\tstruct tegra_drm_client *client;\n\tu32 *data;\n\tu32 pos;\n\tu32 end;\n\tu32 class;\n};\n\nstatic int fw_next(struct tegra_drm_firewall *fw, u32 *word)\n{\n\tif (fw->pos == fw->end)\n\t\treturn -EINVAL;\n\n\t*word = fw->data[fw->pos++];\n\n\treturn 0;\n}\n\nstatic bool fw_check_addr_valid(struct tegra_drm_firewall *fw, u32 offset)\n{\n\tu32 i;\n\n\tfor (i = 0; i < fw->submit->num_used_mappings; i++) {\n\t\tstruct tegra_drm_mapping *m = fw->submit->used_mappings[i].mapping;\n\n\t\tif (offset >= m->iova && offset <= m->iova_end)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int fw_check_reg(struct tegra_drm_firewall *fw, u32 offset)\n{\n\tbool is_addr;\n\tu32 word;\n\tint err;\n\n\terr = fw_next(fw, &word);\n\tif (err)\n\t\treturn err;\n\n\tif (!fw->client->ops->is_addr_reg)\n\t\treturn 0;\n\n\tis_addr = fw->client->ops->is_addr_reg(fw->client->base.dev, fw->class,\n\t\t\t\t\t       offset);\n\n\tif (!is_addr)\n\t\treturn 0;\n\n\tif (!fw_check_addr_valid(fw, word))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fw_check_regs_seq(struct tegra_drm_firewall *fw, u32 offset,\n\t\t\t     u32 count, bool incr)\n{\n\tu32 i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (fw_check_reg(fw, offset))\n\t\t\treturn -EINVAL;\n\n\t\tif (incr)\n\t\t\toffset++;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_check_regs_mask(struct tegra_drm_firewall *fw, u32 offset,\n\t\t\t      u16 mask)\n{\n\tunsigned long bmask = mask;\n\tunsigned int bit;\n\n\tfor_each_set_bit(bit, &bmask, 16) {\n\t\tif (fw_check_reg(fw, offset+bit))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_check_regs_imm(struct tegra_drm_firewall *fw, u32 offset)\n{\n\tbool is_addr;\n\n\tif (!fw->client->ops->is_addr_reg)\n\t\treturn 0;\n\n\tis_addr = fw->client->ops->is_addr_reg(fw->client->base.dev, fw->class,\n\t\t\t\t\t       offset);\n\tif (is_addr)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fw_check_class(struct tegra_drm_firewall *fw, u32 class)\n{\n\tif (!fw->client->ops->is_valid_class) {\n\t\tif (class == fw->client->base.class)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!fw->client->ops->is_valid_class(class))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nenum {\n\tHOST1X_OPCODE_SETCLASS  = 0x00,\n\tHOST1X_OPCODE_INCR      = 0x01,\n\tHOST1X_OPCODE_NONINCR   = 0x02,\n\tHOST1X_OPCODE_MASK      = 0x03,\n\tHOST1X_OPCODE_IMM       = 0x04,\n\tHOST1X_OPCODE_RESTART   = 0x05,\n\tHOST1X_OPCODE_GATHER    = 0x06,\n\tHOST1X_OPCODE_SETSTRMID = 0x07,\n\tHOST1X_OPCODE_SETAPPID  = 0x08,\n\tHOST1X_OPCODE_SETPYLD   = 0x09,\n\tHOST1X_OPCODE_INCR_W    = 0x0a,\n\tHOST1X_OPCODE_NONINCR_W = 0x0b,\n\tHOST1X_OPCODE_GATHER_W  = 0x0c,\n\tHOST1X_OPCODE_RESTART_W = 0x0d,\n\tHOST1X_OPCODE_EXTEND    = 0x0e,\n};\n\nint tegra_drm_fw_validate(struct tegra_drm_client *client, u32 *data, u32 start,\n\t\t\t  u32 words, struct tegra_drm_submit_data *submit,\n\t\t\t  u32 *job_class)\n{\n\tstruct tegra_drm_firewall fw = {\n\t\t.submit = submit,\n\t\t.client = client,\n\t\t.data = data,\n\t\t.pos = start,\n\t\t.end = start+words,\n\t\t.class = *job_class,\n\t};\n\tbool payload_valid = false;\n\tu32 payload;\n\tint err;\n\n\twhile (fw.pos != fw.end) {\n\t\tu32 word, opcode, offset, count, mask, class;\n\n\t\terr = fw_next(&fw, &word);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\topcode = (word & 0xf0000000) >> 28;\n\n\t\tswitch (opcode) {\n\t\tcase HOST1X_OPCODE_SETCLASS:\n\t\t\toffset = word >> 16 & 0xfff;\n\t\t\tmask = word & 0x3f;\n\t\t\tclass = (word >> 6) & 0x3ff;\n\t\t\terr = fw_check_class(&fw, class);\n\t\t\tfw.class = class;\n\t\t\t*job_class = class;\n\t\t\tif (!err)\n\t\t\t\terr = fw_check_regs_mask(&fw, offset, mask);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal SETCLASS(offset=0x%x, mask=0x%x, class=0x%x) at word %u\",\n\t\t\t\t\t offset, mask, class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_INCR:\n\t\t\toffset = (word >> 16) & 0xfff;\n\t\t\tcount = word & 0xffff;\n\t\t\terr = fw_check_regs_seq(&fw, offset, count, true);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal INCR(offset=0x%x, count=%u) in class 0x%x at word %u\",\n\t\t\t\t\t offset, count, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_NONINCR:\n\t\t\toffset = (word >> 16) & 0xfff;\n\t\t\tcount = word & 0xffff;\n\t\t\terr = fw_check_regs_seq(&fw, offset, count, false);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal NONINCR(offset=0x%x, count=%u) in class 0x%x at word %u\",\n\t\t\t\t\t offset, count, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_MASK:\n\t\t\toffset = (word >> 16) & 0xfff;\n\t\t\tmask = word & 0xffff;\n\t\t\terr = fw_check_regs_mask(&fw, offset, mask);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal MASK(offset=0x%x, mask=0x%x) in class 0x%x at word %u\",\n\t\t\t\t\t offset, mask, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_IMM:\n\t\t\t \n\t\t\toffset = (word >> 16) & 0xfff;\n\t\t\terr = fw_check_regs_imm(&fw, offset);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal IMM(offset=0x%x) in class 0x%x at word %u\",\n\t\t\t\t\t offset, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_SETPYLD:\n\t\t\tpayload = word & 0xffff;\n\t\t\tpayload_valid = true;\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_INCR_W:\n\t\t\tif (!payload_valid)\n\t\t\t\treturn -EINVAL;\n\n\t\t\toffset = word & 0x3fffff;\n\t\t\terr = fw_check_regs_seq(&fw, offset, payload, true);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal INCR_W(offset=0x%x) in class 0x%x at word %u\",\n\t\t\t\t\t offset, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tcase HOST1X_OPCODE_NONINCR_W:\n\t\t\tif (!payload_valid)\n\t\t\t\treturn -EINVAL;\n\n\t\t\toffset = word & 0x3fffff;\n\t\t\terr = fw_check_regs_seq(&fw, offset, payload, false);\n\t\t\tif (err)\n\t\t\t\tdev_warn(client->base.dev,\n\t\t\t\t\t \"illegal NONINCR(offset=0x%x) in class 0x%x at word %u\",\n\t\t\t\t\t offset, fw.class, fw.pos-1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(client->base.dev, \"illegal opcode at word %u\",\n\t\t\t\t fw.pos-1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}