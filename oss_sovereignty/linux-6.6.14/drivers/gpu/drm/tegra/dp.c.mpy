{
  "module_name": "dp.c",
  "hash_id": "7afdcbb211a72b2376cd031feb5184529ac276f9ecf5e6bc150916ce0efadeed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/dp.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_print.h>\n\n#include \"dp.h\"\n\nstatic const u8 drm_dp_edp_revisions[] = { 0x11, 0x12, 0x13, 0x14 };\n\nstatic void drm_dp_link_caps_reset(struct drm_dp_link_caps *caps)\n{\n\tcaps->enhanced_framing = false;\n\tcaps->tps3_supported = false;\n\tcaps->fast_training = false;\n\tcaps->channel_coding = false;\n\tcaps->alternate_scrambler_reset = false;\n}\n\nvoid drm_dp_link_caps_copy(struct drm_dp_link_caps *dest,\n\t\t\t   const struct drm_dp_link_caps *src)\n{\n\tdest->enhanced_framing = src->enhanced_framing;\n\tdest->tps3_supported = src->tps3_supported;\n\tdest->fast_training = src->fast_training;\n\tdest->channel_coding = src->channel_coding;\n\tdest->alternate_scrambler_reset = src->alternate_scrambler_reset;\n}\n\nstatic void drm_dp_link_reset(struct drm_dp_link *link)\n{\n\tunsigned int i;\n\n\tif (!link)\n\t\treturn;\n\n\tlink->revision = 0;\n\tlink->max_rate = 0;\n\tlink->max_lanes = 0;\n\n\tdrm_dp_link_caps_reset(&link->caps);\n\tlink->aux_rd_interval.cr = 0;\n\tlink->aux_rd_interval.ce = 0;\n\tlink->edp = 0;\n\n\tlink->rate = 0;\n\tlink->lanes = 0;\n\n\tfor (i = 0; i < DP_MAX_SUPPORTED_RATES; i++)\n\t\tlink->rates[i] = 0;\n\n\tlink->num_rates = 0;\n}\n\n \nint drm_dp_link_add_rate(struct drm_dp_link *link, unsigned long rate)\n{\n\tunsigned int i, pivot;\n\n\tif (link->num_rates == DP_MAX_SUPPORTED_RATES)\n\t\treturn -ENOSPC;\n\n\tfor (pivot = 0; pivot < link->num_rates; pivot++)\n\t\tif (rate <= link->rates[pivot])\n\t\t\tbreak;\n\n\tif (pivot != link->num_rates && rate == link->rates[pivot])\n\t\treturn -EEXIST;\n\n\tfor (i = link->num_rates; i > pivot; i--)\n\t\tlink->rates[i] = link->rates[i - 1];\n\n\tlink->rates[pivot] = rate;\n\tlink->num_rates++;\n\n\treturn 0;\n}\n\n \nint drm_dp_link_remove_rate(struct drm_dp_link *link, unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < link->num_rates; i++)\n\t\tif (rate == link->rates[i])\n\t\t\tbreak;\n\n\tif (i == link->num_rates)\n\t\treturn -EINVAL;\n\n\tlink->num_rates--;\n\n\twhile (i < link->num_rates) {\n\t\tlink->rates[i] = link->rates[i + 1];\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nvoid drm_dp_link_update_rates(struct drm_dp_link *link)\n{\n\tunsigned int i, count = 0;\n\n\tfor (i = 0; i < link->num_rates; i++) {\n\t\tif (link->rates[i] != 0)\n\t\t\tlink->rates[count++] = link->rates[i];\n\t}\n\n\tfor (i = count; i < link->num_rates; i++)\n\t\tlink->rates[i] = 0;\n\n\tlink->num_rates = count;\n}\n\n \nint drm_dp_link_probe(struct drm_dp_aux *aux, struct drm_dp_link *link)\n{\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE], value;\n\tunsigned int rd_interval;\n\tint err;\n\n\tdrm_dp_link_reset(link);\n\n\terr = drm_dp_dpcd_read(aux, DP_DPCD_REV, dpcd, sizeof(dpcd));\n\tif (err < 0)\n\t\treturn err;\n\n\tlink->revision = dpcd[DP_DPCD_REV];\n\tlink->max_rate = drm_dp_max_link_rate(dpcd);\n\tlink->max_lanes = drm_dp_max_lane_count(dpcd);\n\n\tlink->caps.enhanced_framing = drm_dp_enhanced_frame_cap(dpcd);\n\tlink->caps.tps3_supported = drm_dp_tps3_supported(dpcd);\n\tlink->caps.fast_training = drm_dp_fast_training_cap(dpcd);\n\tlink->caps.channel_coding = drm_dp_channel_coding_supported(dpcd);\n\n\tif (drm_dp_alternate_scrambler_reset_cap(dpcd)) {\n\t\tlink->caps.alternate_scrambler_reset = true;\n\n\t\terr = drm_dp_dpcd_readb(aux, DP_EDP_DPCD_REV, &value);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (value >= ARRAY_SIZE(drm_dp_edp_revisions))\n\t\t\tDRM_ERROR(\"unsupported eDP version: %02x\\n\", value);\n\t\telse\n\t\t\tlink->edp = drm_dp_edp_revisions[value];\n\t}\n\n\t \n\trd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &\n\t\t\t   DP_TRAINING_AUX_RD_MASK;\n\n\tif (rd_interval > 4) {\n\t\tDRM_DEBUG_KMS(\"AUX interval %u out of range (max. 4)\\n\",\n\t\t\t      rd_interval);\n\t\trd_interval = 4;\n\t}\n\n\trd_interval *= 4 * USEC_PER_MSEC;\n\n\tif (rd_interval == 0 || link->revision >= DP_DPCD_REV_14)\n\t\tlink->aux_rd_interval.cr = 100;\n\n\tif (rd_interval == 0)\n\t\tlink->aux_rd_interval.ce = 400;\n\n\tlink->rate = link->max_rate;\n\tlink->lanes = link->max_lanes;\n\n\t \n\tif (link->edp >= 0x14) {\n\t\tu8 supported_rates[DP_MAX_SUPPORTED_RATES * 2];\n\t\tunsigned int i;\n\t\tu16 rate;\n\n\t\terr = drm_dp_dpcd_read(aux, DP_SUPPORTED_LINK_RATES,\n\t\t\t\t       supported_rates,\n\t\t\t\t       sizeof(supported_rates));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tfor (i = 0; i < DP_MAX_SUPPORTED_RATES; i++) {\n\t\t\trate = supported_rates[i * 2 + 1] << 8 |\n\t\t\t       supported_rates[i * 2 + 0];\n\n\t\t\tdrm_dp_link_add_rate(link, rate * 200);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)\n{\n\tu8 value;\n\tint err;\n\n\t \n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D0;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(1000, 2000);\n\n\treturn 0;\n}\n\n \nint drm_dp_link_power_down(struct drm_dp_aux *aux, struct drm_dp_link *link)\n{\n\tu8 value;\n\tint err;\n\n\t \n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D3;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nint drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)\n{\n\tu8 values[2], value;\n\tint err;\n\n\tif (link->ops && link->ops->configure) {\n\t\terr = link->ops->configure(link);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"failed to configure DP link: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tvalues[0] = drm_dp_link_rate_to_bw_code(link->rate);\n\tvalues[1] = link->lanes;\n\n\tif (link->caps.enhanced_framing)\n\t\tvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->caps.channel_coding)\n\t\tvalue = DP_SET_ANSI_8B10B;\n\telse\n\t\tvalue = 0;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_MAIN_LINK_CHANNEL_CODING_SET, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->caps.alternate_scrambler_reset) {\n\t\terr = drm_dp_dpcd_writeb(aux, DP_EDP_CONFIGURATION_SET,\n\t\t\t\t\t DP_ALTERNATE_SCRAMBLER_RESET_ENABLE);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nint drm_dp_link_choose(struct drm_dp_link *link,\n\t\t       const struct drm_display_mode *mode,\n\t\t       const struct drm_display_info *info)\n{\n\t \n\tstatic const unsigned int rates[3] = { 162000, 270000, 540000 };\n\t \n\tstatic const unsigned int lanes[3] = { 1, 2, 4 };\n\tunsigned long requirement, capacity;\n\tunsigned int rate = link->max_rate;\n\tunsigned int i, j;\n\n\t \n\trequirement = mode->clock * info->bpc * 3;\n\n\tfor (i = 0; i < ARRAY_SIZE(lanes) && lanes[i] <= link->max_lanes; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(rates) && rates[j] <= rate; j++) {\n\t\t\t \n\t\t\tcapacity = lanes[i] * (rates[j] * 10) * 8 / 10;\n\n\t\t\tif (capacity >= requirement) {\n\t\t\t\tDRM_DEBUG_KMS(\"using %u lanes at %u kHz (%lu/%lu kbps)\\n\",\n\t\t\t\t\t      lanes[i], rates[j], requirement,\n\t\t\t\t\t      capacity);\n\t\t\t\tlink->lanes = lanes[i];\n\t\t\t\tlink->rate = rates[j];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -ERANGE;\n}\n\n \n\n \nvoid drm_dp_link_train_init(struct drm_dp_link_train *train)\n{\n\tstruct drm_dp_link_train_set *request = &train->request;\n\tstruct drm_dp_link_train_set *adjust = &train->adjust;\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\trequest->voltage_swing[i] = 0;\n\t\tadjust->voltage_swing[i] = 0;\n\n\t\trequest->pre_emphasis[i] = 0;\n\t\tadjust->pre_emphasis[i] = 0;\n\n\t\trequest->post_cursor[i] = 0;\n\t\tadjust->post_cursor[i] = 0;\n\t}\n\n\ttrain->pattern = DP_TRAINING_PATTERN_DISABLE;\n\ttrain->clock_recovered = false;\n\ttrain->channel_equalized = false;\n}\n\nstatic bool drm_dp_link_train_valid(const struct drm_dp_link_train *train)\n{\n\treturn train->clock_recovered && train->channel_equalized;\n}\n\nstatic int drm_dp_link_apply_training(struct drm_dp_link *link)\n{\n\tstruct drm_dp_link_train_set *request = &link->train.request;\n\tunsigned int lanes = link->lanes, *vs, *pe, *pc, i;\n\tstruct drm_dp_aux *aux = link->aux;\n\tu8 values[4], pattern = 0;\n\tint err;\n\n\terr = link->ops->apply_training(link);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to apply link training: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvs = request->voltage_swing;\n\tpe = request->pre_emphasis;\n\tpc = request->post_cursor;\n\n\t \n\tfor (i = 0; i < lanes; i++)\n\t\tvalues[i] = DP_TRAIN_VOLTAGE_SWING_LEVEL(vs[i]) |\n\t\t\t    DP_TRAIN_PRE_EMPHASIS_LEVEL(pe[i]);\n\n\terr = drm_dp_dpcd_write(aux, DP_TRAINING_LANE0_SET, values, lanes);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to set training parameters: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (link->revision >= 0x12 && link->rate == 540000) {\n\t\tvalues[0] = values[1] = 0;\n\n\t\tfor (i = 0; i < lanes; i++)\n\t\t\tvalues[i / 2] |= DP_LANE_POST_CURSOR(i, pc[i]);\n\n\t\terr = drm_dp_dpcd_write(aux, DP_TRAINING_LANE0_1_SET2, values,\n\t\t\t\t\tDIV_ROUND_UP(lanes, 2));\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"failed to set post-cursor: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (link->train.pattern != DP_TRAINING_PATTERN_DISABLE)\n\t\tpattern |= DP_LINK_SCRAMBLING_DISABLE;\n\n\tpattern |= link->train.pattern;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET, pattern);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to set training pattern: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_dp_link_train_wait(struct drm_dp_link *link)\n{\n\tunsigned long min = 0;\n\n\tswitch (link->train.pattern) {\n\tcase DP_TRAINING_PATTERN_1:\n\t\tmin = link->aux_rd_interval.cr;\n\t\tbreak;\n\n\tcase DP_TRAINING_PATTERN_2:\n\tcase DP_TRAINING_PATTERN_3:\n\t\tmin = link->aux_rd_interval.ce;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (min > 0)\n\t\tusleep_range(min, 2 * min);\n}\n\nstatic void drm_dp_link_get_adjustments(struct drm_dp_link *link,\n\t\t\t\t\tu8 status[DP_LINK_STATUS_SIZE])\n{\n\tstruct drm_dp_link_train_set *adjust = &link->train.adjust;\n\tunsigned int i;\n\tu8 post_cursor;\n\tint err;\n\n\terr = drm_dp_dpcd_read(link->aux, DP_ADJUST_REQUEST_POST_CURSOR2,\n\t\t\t       &post_cursor, sizeof(post_cursor));\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to read post_cursor2: %d\\n\", err);\n\t\tpost_cursor = 0;\n\t}\n\n\tfor (i = 0; i < link->lanes; i++) {\n\t\tadjust->voltage_swing[i] =\n\t\t\tdrm_dp_get_adjust_request_voltage(status, i) >>\n\t\t\t\tDP_TRAIN_VOLTAGE_SWING_SHIFT;\n\n\t\tadjust->pre_emphasis[i] =\n\t\t\tdrm_dp_get_adjust_request_pre_emphasis(status, i) >>\n\t\t\t\tDP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t\tadjust->post_cursor[i] =\n\t\t\t(post_cursor >> (i << 1)) & 0x3;\n\t}\n}\n\nstatic void drm_dp_link_train_adjust(struct drm_dp_link_train *train)\n{\n\tstruct drm_dp_link_train_set *request = &train->request;\n\tstruct drm_dp_link_train_set *adjust = &train->adjust;\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (request->voltage_swing[i] != adjust->voltage_swing[i])\n\t\t\trequest->voltage_swing[i] = adjust->voltage_swing[i];\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (request->pre_emphasis[i] != adjust->pre_emphasis[i])\n\t\t\trequest->pre_emphasis[i] = adjust->pre_emphasis[i];\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (request->post_cursor[i] != adjust->post_cursor[i])\n\t\t\trequest->post_cursor[i] = adjust->post_cursor[i];\n}\n\nstatic int drm_dp_link_recover_clock(struct drm_dp_link *link)\n{\n\tu8 status[DP_LINK_STATUS_SIZE];\n\tint err;\n\n\terr = drm_dp_link_apply_training(link);\n\tif (err < 0)\n\t\treturn err;\n\n\tdrm_dp_link_train_wait(link);\n\n\terr = drm_dp_dpcd_read_link_status(link->aux, status);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to read link status: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!drm_dp_clock_recovery_ok(status, link->lanes))\n\t\tdrm_dp_link_get_adjustments(link, status);\n\telse\n\t\tlink->train.clock_recovered = true;\n\n\treturn 0;\n}\n\nstatic int drm_dp_link_clock_recovery(struct drm_dp_link *link)\n{\n\tunsigned int repeat;\n\tint err;\n\n\t \n\tlink->train.pattern = DP_TRAINING_PATTERN_1;\n\n\tfor (repeat = 1; repeat < 5; repeat++) {\n\t\terr = drm_dp_link_recover_clock(link);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"failed to recover clock: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (link->train.clock_recovered)\n\t\t\tbreak;\n\n\t\tdrm_dp_link_train_adjust(&link->train);\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_dp_link_equalize_channel(struct drm_dp_link *link)\n{\n\tstruct drm_dp_aux *aux = link->aux;\n\tu8 status[DP_LINK_STATUS_SIZE];\n\tint err;\n\n\terr = drm_dp_link_apply_training(link);\n\tif (err < 0)\n\t\treturn err;\n\n\tdrm_dp_link_train_wait(link);\n\n\terr = drm_dp_dpcd_read_link_status(aux, status);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to read link status: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!drm_dp_clock_recovery_ok(status, link->lanes)) {\n\t\tDRM_ERROR(\"clock recovery lost while equalizing channel\\n\");\n\t\tlink->train.clock_recovered = false;\n\t\treturn 0;\n\t}\n\n\tif (!drm_dp_channel_eq_ok(status, link->lanes))\n\t\tdrm_dp_link_get_adjustments(link, status);\n\telse\n\t\tlink->train.channel_equalized = true;\n\n\treturn 0;\n}\n\nstatic int drm_dp_link_channel_equalization(struct drm_dp_link *link)\n{\n\tunsigned int repeat;\n\tint err;\n\n\t \n\tif (link->caps.tps3_supported)\n\t\tlink->train.pattern = DP_TRAINING_PATTERN_3;\n\telse\n\t\tlink->train.pattern = DP_TRAINING_PATTERN_2;\n\n\tfor (repeat = 1; repeat < 5; repeat++) {\n\t\terr = drm_dp_link_equalize_channel(link);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"failed to equalize channel: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (link->train.channel_equalized)\n\t\t\tbreak;\n\n\t\tdrm_dp_link_train_adjust(&link->train);\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_dp_link_downgrade(struct drm_dp_link *link)\n{\n\tswitch (link->rate) {\n\tcase 162000:\n\t\treturn -EINVAL;\n\n\tcase 270000:\n\t\tlink->rate = 162000;\n\t\tbreak;\n\n\tcase 540000:\n\t\tlink->rate = 270000;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_dp_link_train_disable(struct drm_dp_link *link)\n{\n\tint err;\n\n\tlink->train.pattern = DP_TRAINING_PATTERN_DISABLE;\n\n\terr = drm_dp_link_apply_training(link);\n\tif (err < 0)\n\t\tDRM_ERROR(\"failed to disable link training: %d\\n\", err);\n}\n\nstatic int drm_dp_link_train_full(struct drm_dp_link *link)\n{\n\tint err;\n\nretry:\n\tDRM_DEBUG_KMS(\"full-training link: %u lane%s at %u MHz\\n\",\n\t\t      link->lanes, (link->lanes > 1) ? \"s\" : \"\",\n\t\t      link->rate / 100);\n\n\terr = drm_dp_link_configure(link->aux, link);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to configure DP link: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = drm_dp_link_clock_recovery(link);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"clock recovery failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (!link->train.clock_recovered) {\n\t\tDRM_ERROR(\"clock recovery failed, downgrading link\\n\");\n\n\t\terr = drm_dp_link_downgrade(link);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\tDRM_DEBUG_KMS(\"clock recovery succeeded\\n\");\n\n\terr = drm_dp_link_channel_equalization(link);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"channel equalization failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (!link->train.channel_equalized) {\n\t\tDRM_ERROR(\"channel equalization failed, downgrading link\\n\");\n\n\t\terr = drm_dp_link_downgrade(link);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\tDRM_DEBUG_KMS(\"channel equalization succeeded\\n\");\n\nout:\n\tdrm_dp_link_train_disable(link);\n\treturn err;\n}\n\nstatic int drm_dp_link_train_fast(struct drm_dp_link *link)\n{\n\tu8 status[DP_LINK_STATUS_SIZE];\n\tint err;\n\n\tDRM_DEBUG_KMS(\"fast-training link: %u lane%s at %u MHz\\n\",\n\t\t      link->lanes, (link->lanes > 1) ? \"s\" : \"\",\n\t\t      link->rate / 100);\n\n\terr = drm_dp_link_configure(link->aux, link);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to configure DP link: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tlink->train.pattern = DP_TRAINING_PATTERN_1;\n\n\terr = drm_dp_link_apply_training(link);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusleep_range(500, 1000);\n\n\t \n\tif (link->caps.tps3_supported)\n\t\tlink->train.pattern = DP_TRAINING_PATTERN_3;\n\telse\n\t\tlink->train.pattern = DP_TRAINING_PATTERN_2;\n\n\terr = drm_dp_link_apply_training(link);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusleep_range(500, 1000);\n\n\terr = drm_dp_dpcd_read_link_status(link->aux, status);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to read link status: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (!drm_dp_clock_recovery_ok(status, link->lanes)) {\n\t\tDRM_ERROR(\"clock recovery failed\\n\");\n\t\terr = -EIO;\n\t}\n\n\tif (!drm_dp_channel_eq_ok(status, link->lanes)) {\n\t\tDRM_ERROR(\"channel equalization failed\\n\");\n\t\terr = -EIO;\n\t}\n\nout:\n\tdrm_dp_link_train_disable(link);\n\treturn err;\n}\n\n \nint drm_dp_link_train(struct drm_dp_link *link)\n{\n\tint err;\n\n\tdrm_dp_link_train_init(&link->train);\n\n\tif (link->caps.fast_training) {\n\t\tif (drm_dp_link_train_valid(&link->train)) {\n\t\t\terr = drm_dp_link_train_fast(link);\n\t\t\tif (err < 0)\n\t\t\t\tDRM_ERROR(\"fast link training failed: %d\\n\",\n\t\t\t\t\t  err);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"training parameters not available\\n\");\n\t\t}\n\t} else {\n\t\tDRM_DEBUG_KMS(\"fast link training not supported\\n\");\n\t}\n\n\terr = drm_dp_link_train_full(link);\n\tif (err < 0)\n\t\tDRM_ERROR(\"full link training failed: %d\\n\", err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}