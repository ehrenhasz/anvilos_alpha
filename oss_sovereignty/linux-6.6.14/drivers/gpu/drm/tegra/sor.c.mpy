{
  "module_name": "sor.c",
  "hash_id": "8bb7286e69a3e99fc6123146adabd83180ab04cfb1203bdd7e9814f5636b764b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/sor.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/pmc.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"dc.h\"\n#include \"dp.h\"\n#include \"drm.h\"\n#include \"hda.h\"\n#include \"sor.h\"\n#include \"trace.h\"\n\n#define SOR_REKEY 0x38\n\nstruct tegra_sor_hdmi_settings {\n\tunsigned long frequency;\n\n\tu8 vcocap;\n\tu8 filter;\n\tu8 ichpmp;\n\tu8 loadadj;\n\tu8 tmds_termadj;\n\tu8 tx_pu_value;\n\tu8 bg_temp_coef;\n\tu8 bg_vref_level;\n\tu8 avdd10_level;\n\tu8 avdd14_level;\n\tu8 sparepll;\n\n\tu8 drive_current[4];\n\tu8 preemphasis[4];\n};\n\n#if 1\nstatic const struct tegra_sor_hdmi_settings tegra210_sor_hdmi_defaults[] = {\n\t{\n\t\t.frequency = 54000000,\n\t\t.vcocap = 0x0,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x10,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x33, 0x3a, 0x3a, 0x3a },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 75000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x40,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x33, 0x3a, 0x3a, 0x3a },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 150000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x33, 0x3a, 0x3a, 0x3a },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 300000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0xa,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x33, 0x3f, 0x3f, 0x3f },\n\t\t.preemphasis = { 0x00, 0x17, 0x17, 0x17 },\n\t}, {\n\t\t.frequency = 600000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x33, 0x3f, 0x3f, 0x3f },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t},\n};\n#else\nstatic const struct tegra_sor_hdmi_settings tegra210_sor_hdmi_defaults[] = {\n\t{\n\t\t.frequency = 75000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x40,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x29, 0x29, 0x29, 0x29 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 150000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x1,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0x8,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x30, 0x37, 0x37, 0x37 },\n\t\t.preemphasis = { 0x01, 0x02, 0x02, 0x02 },\n\t}, {\n\t\t.frequency = 300000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0x6,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0x9,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0xf,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x30, 0x37, 0x37, 0x37 },\n\t\t.preemphasis = { 0x10, 0x3e, 0x3e, 0x3e },\n\t}, {\n\t\t.frequency = 600000000,\n\t\t.vcocap = 0x3,\n\t\t.filter = 0x0,\n\t\t.ichpmp = 0xa,\n\t\t.loadadj = 0x3,\n\t\t.tmds_termadj = 0xb,\n\t\t.tx_pu_value = 0x66,\n\t\t.bg_temp_coef = 0x3,\n\t\t.bg_vref_level = 0xe,\n\t\t.avdd10_level = 0x4,\n\t\t.avdd14_level = 0x4,\n\t\t.sparepll = 0x0,\n\t\t.drive_current = { 0x35, 0x3e, 0x3e, 0x3e },\n\t\t.preemphasis = { 0x02, 0x3f, 0x3f, 0x3f },\n\t},\n};\n#endif\n\nstatic const struct tegra_sor_hdmi_settings tegra186_sor_hdmi_defaults[] = {\n\t{\n\t\t.frequency = 54000000,\n\t\t.vcocap = 0,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 0xf,\n\t\t.tx_pu_value = 0,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x54,\n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 75000000,\n\t\t.vcocap = 1,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 0xf,\n\t\t.tx_pu_value = 0,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x44,\n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 150000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 15,\n\t\t.tx_pu_value = 0x66  ,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x00,  \n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x37 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 300000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 15,\n\t\t.tx_pu_value = 64,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x34,\n\t\t.drive_current = { 0x3d, 0x3d, 0x3d, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 600000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 12,\n\t\t.tx_pu_value = 96,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x34,\n\t\t.drive_current = { 0x3d, 0x3d, 0x3d, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}\n};\n\nstatic const struct tegra_sor_hdmi_settings tegra194_sor_hdmi_defaults[] = {\n\t{\n\t\t.frequency = 54000000,\n\t\t.vcocap = 0,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 0xf,\n\t\t.tx_pu_value = 0,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x54,\n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 75000000,\n\t\t.vcocap = 1,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 0xf,\n\t\t.tx_pu_value = 0,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x44,\n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 150000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 15,\n\t\t.tx_pu_value = 0x66  ,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x00,  \n\t\t.drive_current = { 0x3a, 0x3a, 0x3a, 0x37 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 300000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 15,\n\t\t.tx_pu_value = 64,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x34,\n\t\t.drive_current = { 0x3d, 0x3d, 0x3d, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}, {\n\t\t.frequency = 600000000,\n\t\t.vcocap = 3,\n\t\t.filter = 5,\n\t\t.ichpmp = 5,\n\t\t.loadadj = 3,\n\t\t.tmds_termadj = 12,\n\t\t.tx_pu_value = 96,\n\t\t.bg_temp_coef = 3,\n\t\t.bg_vref_level = 8,\n\t\t.avdd10_level = 4,\n\t\t.avdd14_level = 4,\n\t\t.sparepll = 0x34,\n\t\t.drive_current = { 0x3d, 0x3d, 0x3d, 0x33 },\n\t\t.preemphasis = { 0x00, 0x00, 0x00, 0x00 },\n\t}\n};\n\nstruct tegra_sor_regs {\n\tunsigned int head_state0;\n\tunsigned int head_state1;\n\tunsigned int head_state2;\n\tunsigned int head_state3;\n\tunsigned int head_state4;\n\tunsigned int head_state5;\n\tunsigned int pll0;\n\tunsigned int pll1;\n\tunsigned int pll2;\n\tunsigned int pll3;\n\tunsigned int dp_padctl0;\n\tunsigned int dp_padctl2;\n};\n\nstruct tegra_sor_soc {\n\tbool supports_lvds;\n\tbool supports_hdmi;\n\tbool supports_dp;\n\tbool supports_audio;\n\tbool supports_hdcp;\n\n\tconst struct tegra_sor_regs *regs;\n\tbool has_nvdisplay;\n\n\tconst struct tegra_sor_hdmi_settings *settings;\n\tunsigned int num_settings;\n\n\tconst u8 *xbar_cfg;\n\tconst u8 *lane_map;\n\n\tconst u8 (*voltage_swing)[4][4];\n\tconst u8 (*pre_emphasis)[4][4];\n\tconst u8 (*post_cursor)[4][4];\n\tconst u8 (*tx_pu)[4][4];\n};\n\nstruct tegra_sor;\n\nstruct tegra_sor_ops {\n\tconst char *name;\n\tint (*probe)(struct tegra_sor *sor);\n\tvoid (*audio_enable)(struct tegra_sor *sor);\n\tvoid (*audio_disable)(struct tegra_sor *sor);\n};\n\nstruct tegra_sor {\n\tstruct host1x_client client;\n\tstruct tegra_output output;\n\tstruct device *dev;\n\n\tconst struct tegra_sor_soc *soc;\n\tvoid __iomem *regs;\n\tunsigned int index;\n\tunsigned int irq;\n\n\tstruct reset_control *rst;\n\tstruct clk *clk_parent;\n\tstruct clk *clk_safe;\n\tstruct clk *clk_out;\n\tstruct clk *clk_pad;\n\tstruct clk *clk_dp;\n\tstruct clk *clk;\n\n\tu8 xbar_cfg[5];\n\n\tstruct drm_dp_link link;\n\tstruct drm_dp_aux *aux;\n\n\tstruct drm_info_list *debugfs_files;\n\n\tconst struct tegra_sor_ops *ops;\n\tenum tegra_io_pad pad;\n\n\t \n\tstruct tegra_sor_hdmi_settings *settings;\n\tunsigned int num_settings;\n\n\tstruct regulator *avdd_io_supply;\n\tstruct regulator *vdd_pll_supply;\n\tstruct regulator *hdmi_supply;\n\n\tstruct delayed_work scdc;\n\tbool scdc_enabled;\n\n\tstruct tegra_hda_format format;\n};\n\nstruct tegra_sor_state {\n\tstruct drm_connector_state base;\n\n\tunsigned int link_speed;\n\tunsigned long pclk;\n\tunsigned int bpc;\n};\n\nstatic inline struct tegra_sor_state *\nto_sor_state(struct drm_connector_state *state)\n{\n\treturn container_of(state, struct tegra_sor_state, base);\n}\n\nstruct tegra_sor_config {\n\tu32 bits_per_pixel;\n\n\tu32 active_polarity;\n\tu32 active_count;\n\tu32 tu_size;\n\tu32 active_frac;\n\tu32 watermark;\n\n\tu32 hblank_symbols;\n\tu32 vblank_symbols;\n};\n\nstatic inline struct tegra_sor *\nhost1x_client_to_sor(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_sor, client);\n}\n\nstatic inline struct tegra_sor *to_sor(struct tegra_output *output)\n{\n\treturn container_of(output, struct tegra_sor, output);\n}\n\nstatic inline u32 tegra_sor_readl(struct tegra_sor *sor, unsigned int offset)\n{\n\tu32 value = readl(sor->regs + (offset << 2));\n\n\ttrace_sor_readl(sor->dev, offset, value);\n\n\treturn value;\n}\n\nstatic inline void tegra_sor_writel(struct tegra_sor *sor, u32 value,\n\t\t\t\t    unsigned int offset)\n{\n\ttrace_sor_writel(sor->dev, offset, value);\n\twritel(value, sor->regs + (offset << 2));\n}\n\nstatic int tegra_sor_set_parent_clock(struct tegra_sor *sor, struct clk *parent)\n{\n\tint err;\n\n\tclk_disable_unprepare(sor->clk);\n\n\terr = clk_set_parent(sor->clk_out, parent);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = clk_prepare_enable(sor->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstruct tegra_clk_sor_pad {\n\tstruct clk_hw hw;\n\tstruct tegra_sor *sor;\n};\n\nstatic inline struct tegra_clk_sor_pad *to_pad(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct tegra_clk_sor_pad, hw);\n}\n\nstatic const char * const tegra_clk_sor_pad_parents[2][2] = {\n\t{ \"pll_d_out0\", \"pll_dp\" },\n\t{ \"pll_d2_out0\", \"pll_dp\" },\n};\n\n \n\nstatic int tegra_clk_sor_pad_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_clk_sor_pad *pad = to_pad(hw);\n\tstruct tegra_sor *sor = pad->sor;\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\n\tvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\n\n\tswitch (index) {\n\tcase 0:\n\t\tvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK;\n\t\tbreak;\n\n\tcase 1:\n\t\tvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK;\n\t\tbreak;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_CLK_CNTRL);\n\n\treturn 0;\n}\n\nstatic u8 tegra_clk_sor_pad_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_clk_sor_pad *pad = to_pad(hw);\n\tstruct tegra_sor *sor = pad->sor;\n\tu8 parent = U8_MAX;\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\n\n\tswitch (value & SOR_CLK_CNTRL_DP_CLK_SEL_MASK) {\n\tcase SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK:\n\tcase SOR_CLK_CNTRL_DP_CLK_SEL_DIFF_PCLK:\n\t\tparent = 0;\n\t\tbreak;\n\n\tcase SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK:\n\tcase SOR_CLK_CNTRL_DP_CLK_SEL_DIFF_DPCLK:\n\t\tparent = 1;\n\t\tbreak;\n\t}\n\n\treturn parent;\n}\n\nstatic const struct clk_ops tegra_clk_sor_pad_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = tegra_clk_sor_pad_set_parent,\n\t.get_parent = tegra_clk_sor_pad_get_parent,\n};\n\nstatic struct clk *tegra_clk_sor_pad_register(struct tegra_sor *sor,\n\t\t\t\t\t      const char *name)\n{\n\tstruct tegra_clk_sor_pad *pad;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tpad = devm_kzalloc(sor->dev, sizeof(*pad), GFP_KERNEL);\n\tif (!pad)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad->sor = sor;\n\n\tinit.name = name;\n\tinit.flags = 0;\n\tinit.parent_names = tegra_clk_sor_pad_parents[sor->index];\n\tinit.num_parents = ARRAY_SIZE(tegra_clk_sor_pad_parents[sor->index]);\n\tinit.ops = &tegra_clk_sor_pad_ops;\n\n\tpad->hw.init = &init;\n\n\tclk = devm_clk_register(sor->dev, &pad->hw);\n\n\treturn clk;\n}\n\nstatic void tegra_sor_filter_rates(struct tegra_sor *sor)\n{\n\tstruct drm_dp_link *link = &sor->link;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < link->num_rates; i++) {\n\t\tswitch (link->rates[i]) {\n\t\tcase 1620000:\n\t\tcase 2700000:\n\t\tcase 5400000:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDRM_DEBUG_KMS(\"link rate %lu kHz not supported\\n\",\n\t\t\t\t      link->rates[i]);\n\t\t\tlink->rates[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrm_dp_link_update_rates(link);\n}\n\nstatic int tegra_sor_power_up_lanes(struct tegra_sor *sor, unsigned int lanes)\n{\n\tunsigned long timeout;\n\tu32 value;\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\n\tif (lanes <= 2)\n\t\tvalue &= ~(SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[3]) |\n\t\t\t   SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[2]));\n\telse\n\t\tvalue |= SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[3]) |\n\t\t\t SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[2]);\n\n\tif (lanes <= 1)\n\t\tvalue &= ~SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[1]);\n\telse\n\t\tvalue |= SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[1]);\n\n\tif (lanes == 0)\n\t\tvalue &= ~SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[0]);\n\telse\n\t\tvalue |= SOR_DP_PADCTL_PD_TXD(sor->soc->lane_map[0]);\n\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\t \n\tvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_DOWN |\n\t\tSOR_LANE_SEQ_CTL_POWER_STATE_UP;\n\ttegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\n\t\tif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(250, 1000);\n\t}\n\n\tif ((value & SOR_LANE_SEQ_CTL_TRIGGER) != 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int tegra_sor_power_down_lanes(struct tegra_sor *sor)\n{\n\tunsigned long timeout;\n\tu32 value;\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~(SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_0 |\n\t\t   SOR_DP_PADCTL_PD_TXD_1 | SOR_DP_PADCTL_PD_TXD_2);\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\t \n\tvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_UP |\n\t\tSOR_LANE_SEQ_CTL_POWER_STATE_DOWN;\n\ttegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\n\t\tif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\tif ((value & SOR_LANE_SEQ_CTL_TRIGGER) != 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void tegra_sor_dp_precharge(struct tegra_sor *sor, unsigned int lanes)\n{\n\tu32 value;\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\n\tif (lanes <= 2)\n\t\tvalue &= ~(SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[3]) |\n\t\t\t   SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[2]));\n\telse\n\t\tvalue |= SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[3]) |\n\t\t\t SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[2]);\n\n\tif (lanes <= 1)\n\t\tvalue &= ~SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[1]);\n\telse\n\t\tvalue |= SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[1]);\n\n\tif (lanes == 0)\n\t\tvalue &= ~SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[0]);\n\telse\n\t\tvalue |= SOR_DP_PADCTL_CM_TXD(sor->soc->lane_map[0]);\n\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\tusleep_range(15, 100);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\n\t\t   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n}\n\nstatic void tegra_sor_dp_term_calibrate(struct tegra_sor *sor)\n{\n\tu32 mask = 0x08, adj = 0, value;\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\tvalue |= SOR_PLL1_TMDS_TERM;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll1);\n\n\twhile (mask) {\n\t\tadj |= mask;\n\n\t\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\t\tvalue &= ~SOR_PLL1_TMDS_TERMADJ_MASK;\n\t\tvalue |= SOR_PLL1_TMDS_TERMADJ(adj);\n\t\ttegra_sor_writel(sor, value, sor->soc->regs->pll1);\n\n\t\tusleep_range(100, 200);\n\n\t\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\t\tif (value & SOR_PLL1_TERM_COMPOUT)\n\t\t\tadj &= ~mask;\n\n\t\tmask >>= 1;\n\t}\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\tvalue &= ~SOR_PLL1_TMDS_TERMADJ_MASK;\n\tvalue |= SOR_PLL1_TMDS_TERMADJ(adj);\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll1);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n}\n\nstatic int tegra_sor_dp_link_apply_training(struct drm_dp_link *link)\n{\n\tstruct tegra_sor *sor = container_of(link, struct tegra_sor, link);\n\tu32 voltage_swing = 0, pre_emphasis = 0, post_cursor = 0;\n\tconst struct tegra_sor_soc *soc = sor->soc;\n\tu32 pattern = 0, tx_pu = 0, value;\n\tunsigned int i;\n\n\tfor (value = 0, i = 0; i < link->lanes; i++) {\n\t\tu8 vs = link->train.request.voltage_swing[i];\n\t\tu8 pe = link->train.request.pre_emphasis[i];\n\t\tu8 pc = link->train.request.post_cursor[i];\n\t\tu8 shift = sor->soc->lane_map[i] << 3;\n\n\t\tvoltage_swing |= soc->voltage_swing[pc][vs][pe] << shift;\n\t\tpre_emphasis |= soc->pre_emphasis[pc][vs][pe] << shift;\n\t\tpost_cursor |= soc->post_cursor[pc][vs][pe] << shift;\n\n\t\tif (sor->soc->tx_pu[pc][vs][pe] > tx_pu)\n\t\t\ttx_pu = sor->soc->tx_pu[pc][vs][pe];\n\n\t\tswitch (link->train.pattern) {\n\t\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\t\tvalue = SOR_DP_TPG_SCRAMBLER_GALIOS |\n\t\t\t\tSOR_DP_TPG_PATTERN_NONE;\n\t\t\tbreak;\n\n\t\tcase DP_TRAINING_PATTERN_1:\n\t\t\tvalue = SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\tSOR_DP_TPG_PATTERN_TRAIN1;\n\t\t\tbreak;\n\n\t\tcase DP_TRAINING_PATTERN_2:\n\t\t\tvalue = SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\tSOR_DP_TPG_PATTERN_TRAIN2;\n\t\t\tbreak;\n\n\t\tcase DP_TRAINING_PATTERN_3:\n\t\t\tvalue = SOR_DP_TPG_SCRAMBLER_NONE |\n\t\t\t\tSOR_DP_TPG_PATTERN_TRAIN3;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (link->caps.channel_coding)\n\t\t\tvalue |= SOR_DP_TPG_CHANNEL_CODING;\n\n\t\tpattern = pattern << 8 | value;\n\t}\n\n\ttegra_sor_writel(sor, voltage_swing, SOR_LANE_DRIVE_CURRENT0);\n\ttegra_sor_writel(sor, pre_emphasis, SOR_LANE_PREEMPHASIS0);\n\n\tif (link->caps.tps3_supported)\n\t\ttegra_sor_writel(sor, post_cursor, SOR_LANE_POSTCURSOR0);\n\n\ttegra_sor_writel(sor, pattern, SOR_DP_TPG);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue |= SOR_DP_PADCTL_TX_PU(tx_pu);\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\tusleep_range(20, 100);\n\n\treturn 0;\n}\n\nstatic int tegra_sor_dp_link_configure(struct drm_dp_link *link)\n{\n\tstruct tegra_sor *sor = container_of(link, struct tegra_sor, link);\n\tunsigned int rate, lanes;\n\tu32 value;\n\tint err;\n\n\trate = drm_dp_link_rate_to_bw_code(link->rate);\n\tlanes = link->lanes;\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\n\tvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\n\tvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED(rate);\n\ttegra_sor_writel(sor, value, SOR_CLK_CNTRL);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\n\tvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\n\tvalue |= SOR_DP_LINKCTL_LANE_COUNT(lanes);\n\n\tif (link->caps.enhanced_framing)\n\t\tvalue |= SOR_DP_LINKCTL_ENHANCED_FRAME;\n\n\ttegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\n\n\tusleep_range(400, 1000);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\tvalue &= ~SOR_PLL1_LOADADJ_MASK;\n\n\tswitch (rate) {\n\tcase DP_LINK_BW_1_62:\n\t\tvalue |= SOR_PLL1_LOADADJ(0x3);\n\t\tbreak;\n\n\tcase DP_LINK_BW_2_7:\n\t\tvalue |= SOR_PLL1_LOADADJ(0x4);\n\t\tbreak;\n\n\tcase DP_LINK_BW_5_4:\n\t\tvalue |= SOR_PLL1_LOADADJ(0x6);\n\t\tbreak;\n\t}\n\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll1);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\n\n\tif (link->edp == 0)\n\t\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\telse\n\t\tvalue |= SOR_DP_SPARE_PANEL_INTERNAL;\n\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE0);\n\n\terr = tegra_sor_power_down_lanes(sor);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to power down lanes: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = tegra_sor_power_up_lanes(sor, lanes);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to power up %u lane%s: %d\\n\",\n\t\t\tlanes, (lanes != 1) ? \"s\" : \"\", err);\n\t\treturn err;\n\t}\n\n\ttegra_sor_dp_precharge(sor, lanes);\n\n\treturn 0;\n}\n\nstatic const struct drm_dp_link_ops tegra_sor_dp_link_ops = {\n\t.apply_training = tegra_sor_dp_link_apply_training,\n\t.configure = tegra_sor_dp_link_configure,\n};\n\nstatic void tegra_sor_super_update(struct tegra_sor *sor)\n{\n\ttegra_sor_writel(sor, 0, SOR_SUPER_STATE0);\n\ttegra_sor_writel(sor, 1, SOR_SUPER_STATE0);\n\ttegra_sor_writel(sor, 0, SOR_SUPER_STATE0);\n}\n\nstatic void tegra_sor_update(struct tegra_sor *sor)\n{\n\ttegra_sor_writel(sor, 0, SOR_STATE0);\n\ttegra_sor_writel(sor, 1, SOR_STATE0);\n\ttegra_sor_writel(sor, 0, SOR_STATE0);\n}\n\nstatic int tegra_sor_setup_pwm(struct tegra_sor *sor, unsigned long timeout)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_PWM_DIV);\n\tvalue &= ~SOR_PWM_DIV_MASK;\n\tvalue |= 0x400;  \n\ttegra_sor_writel(sor, value, SOR_PWM_DIV);\n\n\tvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\n\tvalue &= ~SOR_PWM_CTL_DUTY_CYCLE_MASK;\n\tvalue |= 0x400;  \n\tvalue &= ~SOR_PWM_CTL_CLK_SEL;  \n\tvalue |= SOR_PWM_CTL_TRIGGER;\n\ttegra_sor_writel(sor, value, SOR_PWM_CTL);\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\n\t\tif ((value & SOR_PWM_CTL_TRIGGER) == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_sor_attach(struct tegra_sor *sor)\n{\n\tunsigned long value, timeout;\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\n\tvalue |= SOR_SUPER_STATE_HEAD_MODE_AWAKE;\n\tvalue |= SOR_SUPER_STATE_MODE_NORMAL;\n\ttegra_sor_writel(sor, value, SOR_SUPER_STATE1);\n\ttegra_sor_super_update(sor);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\n\tvalue |= SOR_SUPER_STATE_ATTACHED;\n\ttegra_sor_writel(sor, value, SOR_SUPER_STATE1);\n\ttegra_sor_super_update(sor);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_TEST);\n\t\tif ((value & SOR_TEST_ATTACHED) != 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_sor_wakeup(struct tegra_sor *sor)\n{\n\tunsigned long value, timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_TEST);\n\t\tvalue &= SOR_TEST_HEAD_MODE_MASK;\n\n\t\tif (value == SOR_TEST_HEAD_MODE_AWAKE)\n\t\t\treturn 0;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_sor_power_up(struct tegra_sor *sor, unsigned long timeout)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_PWR);\n\tvalue |= SOR_PWR_TRIGGER | SOR_PWR_NORMAL_STATE_PU;\n\ttegra_sor_writel(sor, value, SOR_PWR);\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_PWR);\n\t\tif ((value & SOR_PWR_TRIGGER) == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstruct tegra_sor_params {\n\t \n\tunsigned int num_clocks;\n\t \n\tu64 ratio;\n\t \n\tu64 precision;\n\n\tunsigned int active_polarity;\n\tunsigned int active_count;\n\tunsigned int active_frac;\n\tunsigned int tu_size;\n\tunsigned int error;\n};\n\nstatic int tegra_sor_compute_params(struct tegra_sor *sor,\n\t\t\t\t    struct tegra_sor_params *params,\n\t\t\t\t    unsigned int tu_size)\n{\n\tu64 active_sym, active_count, frac, approx;\n\tu32 active_polarity, active_frac = 0;\n\tconst u64 f = params->precision;\n\ts64 error;\n\n\tactive_sym = params->ratio * tu_size;\n\tactive_count = div_u64(active_sym, f) * f;\n\tfrac = active_sym - active_count;\n\n\t \n\tif (frac >= (f / 2)) {\n\t\tactive_polarity = 1;\n\t\tfrac = f - frac;\n\t} else {\n\t\tactive_polarity = 0;\n\t}\n\n\tif (frac != 0) {\n\t\tfrac = div_u64(f * f,  frac);  \n\t\tif (frac <= (15 * f)) {\n\t\t\tactive_frac = div_u64(frac, f);\n\n\t\t\t \n\t\t\tif (active_polarity)\n\t\t\t\tactive_frac++;\n\t\t} else {\n\t\t\tactive_frac = active_polarity ? 1 : 15;\n\t\t}\n\t}\n\n\tif (active_frac == 1)\n\t\tactive_polarity = 0;\n\n\tif (active_polarity == 1) {\n\t\tif (active_frac) {\n\t\t\tapprox = active_count + (active_frac * (f - 1)) * f;\n\t\t\tapprox = div_u64(approx, active_frac * f);\n\t\t} else {\n\t\t\tapprox = active_count + f;\n\t\t}\n\t} else {\n\t\tif (active_frac)\n\t\t\tapprox = active_count + div_u64(f, active_frac);\n\t\telse\n\t\t\tapprox = active_count;\n\t}\n\n\terror = div_s64(active_sym - approx, tu_size);\n\terror *= params->num_clocks;\n\n\tif (error <= 0 && abs(error) < params->error) {\n\t\tparams->active_count = div_u64(active_count, f);\n\t\tparams->active_polarity = active_polarity;\n\t\tparams->active_frac = active_frac;\n\t\tparams->error = abs(error);\n\t\tparams->tu_size = tu_size;\n\n\t\tif (error == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_sor_compute_config(struct tegra_sor *sor,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    struct tegra_sor_config *config,\n\t\t\t\t    struct drm_dp_link *link)\n{\n\tconst u64 f = 100000, link_rate = link->rate * 1000;\n\tconst u64 pclk = (u64)mode->clock * 1000;\n\tu64 input, output, watermark, num;\n\tstruct tegra_sor_params params;\n\tu32 num_syms_per_line;\n\tunsigned int i;\n\n\tif (!link_rate || !link->lanes || !pclk || !config->bits_per_pixel)\n\t\treturn -EINVAL;\n\n\tinput = pclk * config->bits_per_pixel;\n\toutput = link_rate * 8 * link->lanes;\n\n\tif (input >= output)\n\t\treturn -ERANGE;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.ratio = div64_u64(input * f, output);\n\tparams.num_clocks = div_u64(link_rate * mode->hdisplay, pclk);\n\tparams.precision = f;\n\tparams.error = 64 * f;\n\tparams.tu_size = 64;\n\n\tfor (i = params.tu_size; i >= 32; i--)\n\t\tif (tegra_sor_compute_params(sor, &params, i))\n\t\t\tbreak;\n\n\tif (params.active_frac == 0) {\n\t\tconfig->active_polarity = 0;\n\t\tconfig->active_count = params.active_count;\n\n\t\tif (!params.active_polarity)\n\t\t\tconfig->active_count--;\n\n\t\tconfig->tu_size = params.tu_size;\n\t\tconfig->active_frac = 1;\n\t} else {\n\t\tconfig->active_polarity = params.active_polarity;\n\t\tconfig->active_count = params.active_count;\n\t\tconfig->active_frac = params.active_frac;\n\t\tconfig->tu_size = params.tu_size;\n\t}\n\n\tdev_dbg(sor->dev,\n\t\t\"polarity: %d active count: %d tu size: %d active frac: %d\\n\",\n\t\tconfig->active_polarity, config->active_count,\n\t\tconfig->tu_size, config->active_frac);\n\n\twatermark = params.ratio * config->tu_size * (f - params.ratio);\n\twatermark = div_u64(watermark, f);\n\n\twatermark = div_u64(watermark + params.error, f);\n\tconfig->watermark = watermark + (config->bits_per_pixel / 8) + 2;\n\tnum_syms_per_line = (mode->hdisplay * config->bits_per_pixel) *\n\t\t\t    (link->lanes * 8);\n\n\tif (config->watermark > 30) {\n\t\tconfig->watermark = 30;\n\t\tdev_err(sor->dev,\n\t\t\t\"unable to compute TU size, forcing watermark to %u\\n\",\n\t\t\tconfig->watermark);\n\t} else if (config->watermark > num_syms_per_line) {\n\t\tconfig->watermark = num_syms_per_line;\n\t\tdev_err(sor->dev, \"watermark too high, forcing to %u\\n\",\n\t\t\tconfig->watermark);\n\t}\n\n\t \n\tnum = ((mode->htotal - mode->hdisplay) - 7) * link_rate;\n\tconfig->hblank_symbols = div_u64(num, pclk);\n\n\tif (link->caps.enhanced_framing)\n\t\tconfig->hblank_symbols -= 3;\n\n\tconfig->hblank_symbols -= 12 / link->lanes;\n\n\t \n\tnum = (mode->hdisplay - 25) * link_rate;\n\tconfig->vblank_symbols = div_u64(num, pclk);\n\tconfig->vblank_symbols -= 36 / link->lanes + 4;\n\n\tdev_dbg(sor->dev, \"blank symbols: H:%u V:%u\\n\", config->hblank_symbols,\n\t\tconfig->vblank_symbols);\n\n\treturn 0;\n}\n\nstatic void tegra_sor_apply_config(struct tegra_sor *sor,\n\t\t\t\t   const struct tegra_sor_config *config)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\n\tvalue &= ~SOR_DP_LINKCTL_TU_SIZE_MASK;\n\tvalue |= SOR_DP_LINKCTL_TU_SIZE(config->tu_size);\n\ttegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_CONFIG0);\n\tvalue &= ~SOR_DP_CONFIG_WATERMARK_MASK;\n\tvalue |= SOR_DP_CONFIG_WATERMARK(config->watermark);\n\n\tvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_COUNT_MASK;\n\tvalue |= SOR_DP_CONFIG_ACTIVE_SYM_COUNT(config->active_count);\n\n\tvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_FRAC_MASK;\n\tvalue |= SOR_DP_CONFIG_ACTIVE_SYM_FRAC(config->active_frac);\n\n\tif (config->active_polarity)\n\t\tvalue |= SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\n\telse\n\t\tvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\n\n\tvalue |= SOR_DP_CONFIG_ACTIVE_SYM_ENABLE;\n\tvalue |= SOR_DP_CONFIG_DISPARITY_NEGATIVE;\n\ttegra_sor_writel(sor, value, SOR_DP_CONFIG0);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_HBLANK_SYMBOLS);\n\tvalue &= ~SOR_DP_AUDIO_HBLANK_SYMBOLS_MASK;\n\tvalue |= config->hblank_symbols & 0xffff;\n\ttegra_sor_writel(sor, value, SOR_DP_AUDIO_HBLANK_SYMBOLS);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_VBLANK_SYMBOLS);\n\tvalue &= ~SOR_DP_AUDIO_VBLANK_SYMBOLS_MASK;\n\tvalue |= config->vblank_symbols & 0xffff;\n\ttegra_sor_writel(sor, value, SOR_DP_AUDIO_VBLANK_SYMBOLS);\n}\n\nstatic void tegra_sor_mode_set(struct tegra_sor *sor,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       struct tegra_sor_state *state)\n{\n\tstruct tegra_dc *dc = to_tegra_dc(sor->output.encoder.crtc);\n\tunsigned int vbe, vse, hbe, hse, vbs, hbs;\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_PIXELDEPTH_MASK;\n\tvalue &= ~SOR_STATE_ASY_CRC_MODE_MASK;\n\tvalue &= ~SOR_STATE_ASY_OWNER_MASK;\n\n\tvalue |= SOR_STATE_ASY_CRC_MODE_COMPLETE |\n\t\t SOR_STATE_ASY_OWNER(dc->pipe + 1);\n\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tvalue &= ~SOR_STATE_ASY_HSYNCPOL;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tvalue |= SOR_STATE_ASY_HSYNCPOL;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tvalue &= ~SOR_STATE_ASY_VSYNCPOL;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tvalue |= SOR_STATE_ASY_VSYNCPOL;\n\n\tswitch (state->bpc) {\n\tcase 16:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_48_444;\n\t\tbreak;\n\n\tcase 12:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_36_444;\n\t\tbreak;\n\n\tcase 10:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_30_444;\n\t\tbreak;\n\n\tcase 8:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_24_444;\n\t\tbreak;\n\n\tcase 6:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_18_444;\n\t\tbreak;\n\n\tdefault:\n\t\tvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_24_444;\n\t\tbreak;\n\t}\n\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\n\t \n\n\tvalue = ((mode->vtotal & 0x7fff) << 16) | (mode->htotal & 0x7fff);\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state1 + dc->pipe);\n\n\t \n\tvse = mode->vsync_end - mode->vsync_start - 1;\n\thse = mode->hsync_end - mode->hsync_start - 1;\n\n\tvalue = ((vse & 0x7fff) << 16) | (hse & 0x7fff);\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state2 + dc->pipe);\n\n\t \n\tvbe = vse + (mode->vtotal - mode->vsync_end);\n\thbe = hse + (mode->htotal - mode->hsync_end);\n\n\tvalue = ((vbe & 0x7fff) << 16) | (hbe & 0x7fff);\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state3 + dc->pipe);\n\n\t \n\tvbs = vbe + mode->vdisplay;\n\thbs = hbe + mode->hdisplay;\n\n\tvalue = ((vbs & 0x7fff) << 16) | (hbs & 0x7fff);\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state4 + dc->pipe);\n\n\t \n\ttegra_sor_writel(sor, 0x001, sor->soc->regs->head_state5 + dc->pipe);\n}\n\nstatic int tegra_sor_detach(struct tegra_sor *sor)\n{\n\tunsigned long value, timeout;\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\n\tvalue &= ~SOR_SUPER_STATE_MODE_NORMAL;\n\ttegra_sor_writel(sor, value, SOR_SUPER_STATE1);\n\ttegra_sor_super_update(sor);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_PWR);\n\t\tif (value & SOR_PWR_MODE_SAFE)\n\t\t\tbreak;\n\t}\n\n\tif ((value & SOR_PWR_MODE_SAFE) == 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\n\tvalue &= ~SOR_SUPER_STATE_HEAD_MODE_MASK;\n\ttegra_sor_writel(sor, value, SOR_SUPER_STATE1);\n\ttegra_sor_super_update(sor);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\n\tvalue &= ~SOR_SUPER_STATE_ATTACHED;\n\ttegra_sor_writel(sor, value, SOR_SUPER_STATE1);\n\ttegra_sor_super_update(sor);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_TEST);\n\t\tif ((value & SOR_TEST_ATTACHED) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\tif ((value & SOR_TEST_ATTACHED) != 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int tegra_sor_power_down(struct tegra_sor *sor)\n{\n\tunsigned long value, timeout;\n\tint err;\n\n\tvalue = tegra_sor_readl(sor, SOR_PWR);\n\tvalue &= ~SOR_PWR_NORMAL_STATE_PU;\n\tvalue |= SOR_PWR_TRIGGER;\n\ttegra_sor_writel(sor, value, SOR_PWR);\n\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_PWR);\n\t\tif ((value & SOR_PWR_TRIGGER) == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(25, 100);\n\t}\n\n\tif ((value & SOR_PWR_TRIGGER) != 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to set safe parent clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue |= SOR_PLL2_PORT_POWERDOWN;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(20, 100);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll0);\n\tvalue |= SOR_PLL0_VCOPD | SOR_PLL0_PWR;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue |= SOR_PLL2_SEQ_PLLCAPPD;\n\tvalue |= SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(20, 100);\n\n\treturn 0;\n}\n\nstatic int tegra_sor_crc_wait(struct tegra_sor *sor, unsigned long timeout)\n{\n\tu32 value;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_sor_readl(sor, SOR_CRCA);\n\t\tif (value & SOR_CRCA_VALID)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_sor_show_crc(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_sor *sor = node->info_ent->data;\n\tstruct drm_crtc *crtc = sor->output.encoder.crtc;\n\tstruct drm_device *drm = node->minor->dev;\n\tint err = 0;\n\tu32 value;\n\n\tdrm_modeset_lock_all(drm);\n\n\tif (!crtc || !crtc->state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_CRC_MODE_MASK;\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\n\tvalue = tegra_sor_readl(sor, SOR_CRC_CNTRL);\n\tvalue |= SOR_CRC_CNTRL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_CRC_CNTRL);\n\n\tvalue = tegra_sor_readl(sor, SOR_TEST);\n\tvalue &= ~SOR_TEST_CRC_POST_SERIALIZE;\n\ttegra_sor_writel(sor, value, SOR_TEST);\n\n\terr = tegra_sor_crc_wait(sor, 100);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\ttegra_sor_writel(sor, SOR_CRCA_RESET, SOR_CRCA);\n\tvalue = tegra_sor_readl(sor, SOR_CRCB);\n\n\tseq_printf(s, \"%08x\\n\", value);\n\nunlock:\n\tdrm_modeset_unlock_all(drm);\n\treturn err;\n}\n\n#define DEBUGFS_REG32(_name) { .name = #_name, .offset = _name }\n\nstatic const struct debugfs_reg32 tegra_sor_regs[] = {\n\tDEBUGFS_REG32(SOR_CTXSW),\n\tDEBUGFS_REG32(SOR_SUPER_STATE0),\n\tDEBUGFS_REG32(SOR_SUPER_STATE1),\n\tDEBUGFS_REG32(SOR_STATE0),\n\tDEBUGFS_REG32(SOR_STATE1),\n\tDEBUGFS_REG32(SOR_HEAD_STATE0(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE0(1)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE1(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE1(1)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE2(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE2(1)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE3(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE3(1)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE4(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE4(1)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE5(0)),\n\tDEBUGFS_REG32(SOR_HEAD_STATE5(1)),\n\tDEBUGFS_REG32(SOR_CRC_CNTRL),\n\tDEBUGFS_REG32(SOR_DP_DEBUG_MVID),\n\tDEBUGFS_REG32(SOR_CLK_CNTRL),\n\tDEBUGFS_REG32(SOR_CAP),\n\tDEBUGFS_REG32(SOR_PWR),\n\tDEBUGFS_REG32(SOR_TEST),\n\tDEBUGFS_REG32(SOR_PLL0),\n\tDEBUGFS_REG32(SOR_PLL1),\n\tDEBUGFS_REG32(SOR_PLL2),\n\tDEBUGFS_REG32(SOR_PLL3),\n\tDEBUGFS_REG32(SOR_CSTM),\n\tDEBUGFS_REG32(SOR_LVDS),\n\tDEBUGFS_REG32(SOR_CRCA),\n\tDEBUGFS_REG32(SOR_CRCB),\n\tDEBUGFS_REG32(SOR_BLANK),\n\tDEBUGFS_REG32(SOR_SEQ_CTL),\n\tDEBUGFS_REG32(SOR_LANE_SEQ_CTL),\n\tDEBUGFS_REG32(SOR_SEQ_INST(0)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(1)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(2)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(3)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(4)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(5)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(6)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(7)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(8)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(9)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(10)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(11)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(12)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(13)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(14)),\n\tDEBUGFS_REG32(SOR_SEQ_INST(15)),\n\tDEBUGFS_REG32(SOR_PWM_DIV),\n\tDEBUGFS_REG32(SOR_PWM_CTL),\n\tDEBUGFS_REG32(SOR_VCRC_A0),\n\tDEBUGFS_REG32(SOR_VCRC_A1),\n\tDEBUGFS_REG32(SOR_VCRC_B0),\n\tDEBUGFS_REG32(SOR_VCRC_B1),\n\tDEBUGFS_REG32(SOR_CCRC_A0),\n\tDEBUGFS_REG32(SOR_CCRC_A1),\n\tDEBUGFS_REG32(SOR_CCRC_B0),\n\tDEBUGFS_REG32(SOR_CCRC_B1),\n\tDEBUGFS_REG32(SOR_EDATA_A0),\n\tDEBUGFS_REG32(SOR_EDATA_A1),\n\tDEBUGFS_REG32(SOR_EDATA_B0),\n\tDEBUGFS_REG32(SOR_EDATA_B1),\n\tDEBUGFS_REG32(SOR_COUNT_A0),\n\tDEBUGFS_REG32(SOR_COUNT_A1),\n\tDEBUGFS_REG32(SOR_COUNT_B0),\n\tDEBUGFS_REG32(SOR_COUNT_B1),\n\tDEBUGFS_REG32(SOR_DEBUG_A0),\n\tDEBUGFS_REG32(SOR_DEBUG_A1),\n\tDEBUGFS_REG32(SOR_DEBUG_B0),\n\tDEBUGFS_REG32(SOR_DEBUG_B1),\n\tDEBUGFS_REG32(SOR_TRIG),\n\tDEBUGFS_REG32(SOR_MSCHECK),\n\tDEBUGFS_REG32(SOR_XBAR_CTRL),\n\tDEBUGFS_REG32(SOR_XBAR_POL),\n\tDEBUGFS_REG32(SOR_DP_LINKCTL0),\n\tDEBUGFS_REG32(SOR_DP_LINKCTL1),\n\tDEBUGFS_REG32(SOR_LANE_DRIVE_CURRENT0),\n\tDEBUGFS_REG32(SOR_LANE_DRIVE_CURRENT1),\n\tDEBUGFS_REG32(SOR_LANE4_DRIVE_CURRENT0),\n\tDEBUGFS_REG32(SOR_LANE4_DRIVE_CURRENT1),\n\tDEBUGFS_REG32(SOR_LANE_PREEMPHASIS0),\n\tDEBUGFS_REG32(SOR_LANE_PREEMPHASIS1),\n\tDEBUGFS_REG32(SOR_LANE4_PREEMPHASIS0),\n\tDEBUGFS_REG32(SOR_LANE4_PREEMPHASIS1),\n\tDEBUGFS_REG32(SOR_LANE_POSTCURSOR0),\n\tDEBUGFS_REG32(SOR_LANE_POSTCURSOR1),\n\tDEBUGFS_REG32(SOR_DP_CONFIG0),\n\tDEBUGFS_REG32(SOR_DP_CONFIG1),\n\tDEBUGFS_REG32(SOR_DP_MN0),\n\tDEBUGFS_REG32(SOR_DP_MN1),\n\tDEBUGFS_REG32(SOR_DP_PADCTL0),\n\tDEBUGFS_REG32(SOR_DP_PADCTL1),\n\tDEBUGFS_REG32(SOR_DP_PADCTL2),\n\tDEBUGFS_REG32(SOR_DP_DEBUG0),\n\tDEBUGFS_REG32(SOR_DP_DEBUG1),\n\tDEBUGFS_REG32(SOR_DP_SPARE0),\n\tDEBUGFS_REG32(SOR_DP_SPARE1),\n\tDEBUGFS_REG32(SOR_DP_AUDIO_CTRL),\n\tDEBUGFS_REG32(SOR_DP_AUDIO_HBLANK_SYMBOLS),\n\tDEBUGFS_REG32(SOR_DP_AUDIO_VBLANK_SYMBOLS),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_HEADER),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK0),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK1),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK2),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK3),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK4),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK5),\n\tDEBUGFS_REG32(SOR_DP_GENERIC_INFOFRAME_SUBPACK6),\n\tDEBUGFS_REG32(SOR_DP_TPG),\n\tDEBUGFS_REG32(SOR_DP_TPG_CONFIG),\n\tDEBUGFS_REG32(SOR_DP_LQ_CSTM0),\n\tDEBUGFS_REG32(SOR_DP_LQ_CSTM1),\n\tDEBUGFS_REG32(SOR_DP_LQ_CSTM2),\n};\n\nstatic int tegra_sor_show_regs(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_sor *sor = node->info_ent->data;\n\tstruct drm_crtc *crtc = sor->output.encoder.crtc;\n\tstruct drm_device *drm = node->minor->dev;\n\tunsigned int i;\n\tint err = 0;\n\n\tdrm_modeset_lock_all(drm);\n\n\tif (!crtc || !crtc->state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_sor_regs); i++) {\n\t\tunsigned int offset = tegra_sor_regs[i].offset;\n\n\t\tseq_printf(s, \"%-38s %#05x %08x\\n\", tegra_sor_regs[i].name,\n\t\t\t   offset, tegra_sor_readl(sor, offset));\n\t}\n\nunlock:\n\tdrm_modeset_unlock_all(drm);\n\treturn err;\n}\n\nstatic const struct drm_info_list debugfs_files[] = {\n\t{ \"crc\", tegra_sor_show_crc, 0, NULL },\n\t{ \"regs\", tegra_sor_show_regs, 0, NULL },\n};\n\nstatic int tegra_sor_late_register(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tunsigned int i, count = ARRAY_SIZE(debugfs_files);\n\tstruct drm_minor *minor = connector->dev->primary;\n\tstruct dentry *root = connector->debugfs_entry;\n\tstruct tegra_sor *sor = to_sor(output);\n\n\tsor->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\n\t\t\t\t     GFP_KERNEL);\n\tif (!sor->debugfs_files)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++)\n\t\tsor->debugfs_files[i].data = sor;\n\n\tdrm_debugfs_create_files(sor->debugfs_files, count, root, minor);\n\n\treturn 0;\n}\n\nstatic void tegra_sor_early_unregister(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tunsigned int count = ARRAY_SIZE(debugfs_files);\n\tstruct tegra_sor *sor = to_sor(output);\n\n\tdrm_debugfs_remove_files(sor->debugfs_files, count,\n\t\t\t\t connector->dev->primary);\n\tkfree(sor->debugfs_files);\n\tsor->debugfs_files = NULL;\n}\n\nstatic void tegra_sor_connector_reset(struct drm_connector *connector)\n{\n\tstruct tegra_sor_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn;\n\n\tif (connector->state) {\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\t\tkfree(connector->state);\n\t}\n\n\t__drm_atomic_helper_connector_reset(connector, &state->base);\n}\n\nstatic enum drm_connector_status\ntegra_sor_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct tegra_sor *sor = to_sor(output);\n\n\tif (sor->aux)\n\t\treturn drm_dp_aux_detect(sor->aux);\n\n\treturn tegra_output_connector_detect(connector, force);\n}\n\nstatic struct drm_connector_state *\ntegra_sor_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct tegra_sor_state *state = to_sor_state(connector->state);\n\tstruct tegra_sor_state *copy;\n\n\tcopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &copy->base);\n\n\treturn &copy->base;\n}\n\nstatic const struct drm_connector_funcs tegra_sor_connector_funcs = {\n\t.reset = tegra_sor_connector_reset,\n\t.detect = tegra_sor_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = tegra_output_connector_destroy,\n\t.atomic_duplicate_state = tegra_sor_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = tegra_sor_late_register,\n\t.early_unregister = tegra_sor_early_unregister,\n};\n\nstatic int tegra_sor_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct tegra_sor *sor = to_sor(output);\n\tint err;\n\n\tif (sor->aux)\n\t\tdrm_dp_aux_enable(sor->aux);\n\n\terr = tegra_output_connector_get_modes(connector);\n\n\tif (sor->aux)\n\t\tdrm_dp_aux_disable(sor->aux);\n\n\treturn err;\n}\n\nstatic enum drm_mode_status\ntegra_sor_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs tegra_sor_connector_helper_funcs = {\n\t.get_modes = tegra_sor_connector_get_modes,\n\t.mode_valid = tegra_sor_connector_mode_valid,\n};\n\nstatic int\ntegra_sor_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_sor_state *state = to_sor_state(conn_state);\n\tstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\n\tunsigned long pclk = crtc_state->mode.clock * 1000;\n\tstruct tegra_sor *sor = to_sor(output);\n\tstruct drm_display_info *info;\n\tint err;\n\n\tinfo = &output->connector.display_info;\n\n\t \n\tif (pclk >= 340000000) {\n\t\tstate->link_speed = 20;\n\t\tstate->pclk = pclk / 2;\n\t} else {\n\t\tstate->link_speed = 10;\n\t\tstate->pclk = pclk;\n\t}\n\n\terr = tegra_dc_state_setup_clock(dc, crtc_state, sor->clk_parent,\n\t\t\t\t\t pclk, 0);\n\tif (err < 0) {\n\t\tdev_err(output->dev, \"failed to setup CRTC state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tswitch (info->bpc) {\n\tcase 8:\n\tcase 6:\n\t\tstate->bpc = info->bpc;\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"%u bits-per-color not supported\\n\", info->bpc);\n\t\tstate->bpc = 8;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 tegra_sor_hdmi_subpack(const u8 *ptr, size_t size)\n{\n\tu32 value = 0;\n\tsize_t i;\n\n\tfor (i = size; i > 0; i--)\n\t\tvalue = (value << 8) | ptr[i - 1];\n\n\treturn value;\n}\n\nstatic void tegra_sor_hdmi_write_infopack(struct tegra_sor *sor,\n\t\t\t\t\t  const void *data, size_t size)\n{\n\tconst u8 *ptr = data;\n\tunsigned long offset;\n\tsize_t i, j;\n\tu32 value;\n\n\tswitch (ptr[0]) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\toffset = SOR_HDMI_AVI_INFOFRAME_HEADER;\n\t\tbreak;\n\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\toffset = SOR_HDMI_AUDIO_INFOFRAME_HEADER;\n\t\tbreak;\n\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\toffset = SOR_HDMI_VSI_INFOFRAME_HEADER;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(sor->dev, \"unsupported infoframe type: %02x\\n\",\n\t\t\tptr[0]);\n\t\treturn;\n\t}\n\n\tvalue = INFOFRAME_HEADER_TYPE(ptr[0]) |\n\t\tINFOFRAME_HEADER_VERSION(ptr[1]) |\n\t\tINFOFRAME_HEADER_LEN(ptr[2]);\n\ttegra_sor_writel(sor, value, offset);\n\toffset++;\n\n\t \n\tfor (i = 3, j = 0; i < size; i += 7, j += 8) {\n\t\tsize_t rem = size - i, num = min_t(size_t, rem, 4);\n\n\t\tvalue = tegra_sor_hdmi_subpack(&ptr[i], num);\n\t\ttegra_sor_writel(sor, value, offset++);\n\n\t\tnum = min_t(size_t, rem - num, 3);\n\n\t\tvalue = tegra_sor_hdmi_subpack(&ptr[i + 4], num);\n\t\ttegra_sor_writel(sor, value, offset++);\n\t}\n}\n\nstatic int\ntegra_sor_hdmi_setup_avi_infoframe(struct tegra_sor *sor,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\n\tstruct hdmi_avi_infoframe frame;\n\tu32 value;\n\tint err;\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_HDMI_AVI_INFOFRAME_CTRL);\n\tvalue &= ~INFOFRAME_CTRL_SINGLE;\n\tvalue &= ~INFOFRAME_CTRL_OTHER;\n\tvalue &= ~INFOFRAME_CTRL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AVI_INFOFRAME_CTRL);\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       &sor->output.connector, mode);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to setup AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to pack AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_sor_hdmi_write_infopack(sor, buffer, err);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_HDMI_AVI_INFOFRAME_CTRL);\n\tvalue |= INFOFRAME_CTRL_CHECKSUM_ENABLE;\n\tvalue |= INFOFRAME_CTRL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AVI_INFOFRAME_CTRL);\n\n\treturn 0;\n}\n\nstatic void tegra_sor_write_eld(struct tegra_sor *sor)\n{\n\tsize_t length = drm_eld_size(sor->output.connector.eld), i;\n\n\tfor (i = 0; i < length; i++)\n\t\ttegra_sor_writel(sor, i << 8 | sor->output.connector.eld[i],\n\t\t\t\t SOR_AUDIO_HDA_ELD_BUFWR);\n\n\t \n\tfor (i = length; i < 96; i++)\n\t\ttegra_sor_writel(sor, i << 8 | 0, SOR_AUDIO_HDA_ELD_BUFWR);\n}\n\nstatic void tegra_sor_audio_prepare(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\t \n\tvalue = SOR_INT_CODEC_SCRATCH1 | SOR_INT_CODEC_SCRATCH0;\n\ttegra_sor_writel(sor, value, SOR_INT_ENABLE);\n\ttegra_sor_writel(sor, value, SOR_INT_MASK);\n\n\ttegra_sor_write_eld(sor);\n\n\tvalue = SOR_AUDIO_HDA_PRESENSE_ELDV | SOR_AUDIO_HDA_PRESENSE_PD;\n\ttegra_sor_writel(sor, value, SOR_AUDIO_HDA_PRESENSE);\n}\n\nstatic void tegra_sor_audio_unprepare(struct tegra_sor *sor)\n{\n\ttegra_sor_writel(sor, 0, SOR_AUDIO_HDA_PRESENSE);\n\ttegra_sor_writel(sor, 0, SOR_INT_MASK);\n\ttegra_sor_writel(sor, 0, SOR_INT_ENABLE);\n}\n\nstatic void tegra_sor_audio_enable(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_AUDIO_CNTRL);\n\n\t \n\tvalue &= ~SOR_AUDIO_CNTRL_SOURCE_SELECT(SOURCE_SELECT_MASK);\n\tvalue |= SOR_AUDIO_CNTRL_SOURCE_SELECT(SOURCE_SELECT_HDA);\n\n\t \n\tif (sor->format.channels != 2)\n\t\tvalue &= ~SOR_AUDIO_CNTRL_INJECT_NULLSMPL;\n\telse\n\t\tvalue |= SOR_AUDIO_CNTRL_INJECT_NULLSMPL;\n\n\tvalue |= SOR_AUDIO_CNTRL_AFIFO_FLUSH;\n\n\ttegra_sor_writel(sor, value, SOR_AUDIO_CNTRL);\n\n\t \n\ttegra_sor_writel(sor, SOR_AUDIO_SPARE_HBR_ENABLE, SOR_AUDIO_SPARE);\n}\n\nstatic int tegra_sor_hdmi_enable_audio_infoframe(struct tegra_sor *sor)\n{\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AUDIO)];\n\tstruct hdmi_audio_infoframe frame;\n\tu32 value;\n\tint err;\n\n\terr = hdmi_audio_infoframe_init(&frame);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to setup audio infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tframe.channels = sor->format.channels;\n\n\terr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to pack audio infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_sor_hdmi_write_infopack(sor, buffer, err);\n\n\tvalue = tegra_sor_readl(sor, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\n\tvalue |= INFOFRAME_CTRL_CHECKSUM_ENABLE;\n\tvalue |= INFOFRAME_CTRL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\n\n\treturn 0;\n}\n\nstatic void tegra_sor_hdmi_audio_enable(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\ttegra_sor_audio_enable(sor);\n\n\ttegra_sor_writel(sor, 0, SOR_HDMI_ACR_CTRL);\n\n\tvalue = SOR_HDMI_SPARE_ACR_PRIORITY_HIGH |\n\t\tSOR_HDMI_SPARE_CTS_RESET(1) |\n\t\tSOR_HDMI_SPARE_HW_CTS_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_SPARE);\n\n\t \n\tvalue = SOR_HDMI_ACR_SUBPACK_LOW_SB1(0);\n\ttegra_sor_writel(sor, value, SOR_HDMI_ACR_0441_SUBPACK_LOW);\n\n\t \n\tvalue = SOR_HDMI_ACR_SUBPACK_HIGH_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_ACR_0441_SUBPACK_HIGH);\n\n\t \n\tvalue = SOR_HDMI_AUDIO_N_RESET | SOR_HDMI_AUDIO_N_LOOKUP;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AUDIO_N);\n\n\tvalue = (24000 * 4096) / (128 * sor->format.sample_rate / 1000);\n\ttegra_sor_writel(sor, value, SOR_AUDIO_AVAL_0320);\n\ttegra_sor_writel(sor, 4096, SOR_AUDIO_NVAL_0320);\n\n\ttegra_sor_writel(sor, 20000, SOR_AUDIO_AVAL_0441);\n\ttegra_sor_writel(sor, 4704, SOR_AUDIO_NVAL_0441);\n\n\ttegra_sor_writel(sor, 20000, SOR_AUDIO_AVAL_0882);\n\ttegra_sor_writel(sor, 9408, SOR_AUDIO_NVAL_0882);\n\n\ttegra_sor_writel(sor, 20000, SOR_AUDIO_AVAL_1764);\n\ttegra_sor_writel(sor, 18816, SOR_AUDIO_NVAL_1764);\n\n\tvalue = (24000 * 6144) / (128 * sor->format.sample_rate / 1000);\n\ttegra_sor_writel(sor, value, SOR_AUDIO_AVAL_0480);\n\ttegra_sor_writel(sor, 6144, SOR_AUDIO_NVAL_0480);\n\n\tvalue = (24000 * 12288) / (128 * sor->format.sample_rate / 1000);\n\ttegra_sor_writel(sor, value, SOR_AUDIO_AVAL_0960);\n\ttegra_sor_writel(sor, 12288, SOR_AUDIO_NVAL_0960);\n\n\tvalue = (24000 * 24576) / (128 * sor->format.sample_rate / 1000);\n\ttegra_sor_writel(sor, value, SOR_AUDIO_AVAL_1920);\n\ttegra_sor_writel(sor, 24576, SOR_AUDIO_NVAL_1920);\n\n\tvalue = tegra_sor_readl(sor, SOR_HDMI_AUDIO_N);\n\tvalue &= ~SOR_HDMI_AUDIO_N_RESET;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AUDIO_N);\n\n\ttegra_sor_hdmi_enable_audio_infoframe(sor);\n}\n\nstatic void tegra_sor_hdmi_disable_audio_infoframe(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\n\tvalue &= ~INFOFRAME_CTRL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\n}\n\nstatic void tegra_sor_hdmi_audio_disable(struct tegra_sor *sor)\n{\n\ttegra_sor_hdmi_disable_audio_infoframe(sor);\n}\n\nstatic struct tegra_sor_hdmi_settings *\ntegra_sor_hdmi_find_settings(struct tegra_sor *sor, unsigned long frequency)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sor->num_settings; i++)\n\t\tif (frequency <= sor->settings[i].frequency)\n\t\t\treturn &sor->settings[i];\n\n\treturn NULL;\n}\n\nstatic void tegra_sor_hdmi_disable_scrambling(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_HDMI2_CTRL);\n\tvalue &= ~SOR_HDMI2_CTRL_CLOCK_MODE_DIV_BY_4;\n\tvalue &= ~SOR_HDMI2_CTRL_SCRAMBLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI2_CTRL);\n}\n\nstatic void tegra_sor_hdmi_scdc_disable(struct tegra_sor *sor)\n{\n\tdrm_scdc_set_high_tmds_clock_ratio(&sor->output.connector, false);\n\tdrm_scdc_set_scrambling(&sor->output.connector, false);\n\n\ttegra_sor_hdmi_disable_scrambling(sor);\n}\n\nstatic void tegra_sor_hdmi_scdc_stop(struct tegra_sor *sor)\n{\n\tif (sor->scdc_enabled) {\n\t\tcancel_delayed_work_sync(&sor->scdc);\n\t\ttegra_sor_hdmi_scdc_disable(sor);\n\t}\n}\n\nstatic void tegra_sor_hdmi_enable_scrambling(struct tegra_sor *sor)\n{\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_HDMI2_CTRL);\n\tvalue |= SOR_HDMI2_CTRL_CLOCK_MODE_DIV_BY_4;\n\tvalue |= SOR_HDMI2_CTRL_SCRAMBLE;\n\ttegra_sor_writel(sor, value, SOR_HDMI2_CTRL);\n}\n\nstatic void tegra_sor_hdmi_scdc_enable(struct tegra_sor *sor)\n{\n\tdrm_scdc_set_high_tmds_clock_ratio(&sor->output.connector, true);\n\tdrm_scdc_set_scrambling(&sor->output.connector, true);\n\n\ttegra_sor_hdmi_enable_scrambling(sor);\n}\n\nstatic void tegra_sor_hdmi_scdc_work(struct work_struct *work)\n{\n\tstruct tegra_sor *sor = container_of(work, struct tegra_sor, scdc.work);\n\n\tif (!drm_scdc_get_scrambling_status(&sor->output.connector)) {\n\t\tDRM_DEBUG_KMS(\"SCDC not scrambled\\n\");\n\t\ttegra_sor_hdmi_scdc_enable(sor);\n\t}\n\n\tschedule_delayed_work(&sor->scdc, msecs_to_jiffies(5000));\n}\n\nstatic void tegra_sor_hdmi_scdc_start(struct tegra_sor *sor)\n{\n\tstruct drm_scdc *scdc = &sor->output.connector.display_info.hdmi.scdc;\n\tstruct drm_display_mode *mode;\n\n\tmode = &sor->output.encoder.crtc->state->adjusted_mode;\n\n\tif (mode->clock >= 340000 && scdc->supported) {\n\t\tschedule_delayed_work(&sor->scdc, msecs_to_jiffies(5000));\n\t\ttegra_sor_hdmi_scdc_enable(sor);\n\t\tsor->scdc_enabled = true;\n\t}\n}\n\nstatic void tegra_sor_hdmi_disable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_sor *sor = to_sor(output);\n\tu32 value;\n\tint err;\n\n\ttegra_sor_audio_unprepare(sor);\n\ttegra_sor_hdmi_scdc_stop(sor);\n\n\terr = tegra_sor_detach(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to detach SOR: %d\\n\", err);\n\n\ttegra_sor_writel(sor, 0, SOR_STATE1);\n\ttegra_sor_update(sor);\n\n\t \n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\n\tif (!sor->soc->has_nvdisplay)\n\t\tvalue &= ~SOR1_TIMING_CYA;\n\n\tvalue &= ~SOR_ENABLE(sor->index);\n\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\ttegra_dc_commit(dc);\n\n\terr = tegra_sor_power_down(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power down SOR: %d\\n\", err);\n\n\terr = tegra_io_pad_power_disable(sor->pad);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power off I/O pad: %d\\n\", err);\n\n\thost1x_client_suspend(&sor->client);\n}\n\nstatic void tegra_sor_hdmi_enable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tunsigned int h_ref_to_sync = 1, pulse_start, max_ac;\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_sor_hdmi_settings *settings;\n\tstruct tegra_sor *sor = to_sor(output);\n\tstruct tegra_sor_state *state;\n\tstruct drm_display_mode *mode;\n\tunsigned long rate, pclk;\n\tunsigned int div, i;\n\tu32 value;\n\tint err;\n\n\tstate = to_sor_state(output->connector.state);\n\tmode = &encoder->crtc->state->adjusted_mode;\n\tpclk = mode->clock * 1000;\n\n\terr = host1x_client_resume(&sor->client);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to set safe parent clock: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tdiv = clk_get_rate(sor->clk) / 1000000 * 4;\n\n\terr = tegra_io_pad_power_enable(sor->pad);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power on I/O pad: %d\\n\", err);\n\n\tusleep_range(20, 100);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_BANDGAP_POWERDOWN;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(20, 100);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll3);\n\tvalue &= ~SOR_PLL3_PLL_VDD_MODE_3V3;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll3);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll0);\n\tvalue &= ~SOR_PLL0_VCOPD;\n\tvalue &= ~SOR_PLL0_PWR;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(200, 400);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_POWERDOWN_OVERRIDE;\n\tvalue &= ~SOR_PLL2_PORT_POWERDOWN;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(20, 100);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue |= SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_0 |\n\t\t SOR_DP_PADCTL_PD_TXD_1 | SOR_DP_PADCTL_PD_TXD_2;\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\twhile (true) {\n\t\tvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\n\t\tif ((value & SOR_LANE_SEQ_CTL_STATE_BUSY) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(250, 1000);\n\t}\n\n\tvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_DOWN |\n\t\tSOR_LANE_SEQ_CTL_POWER_STATE_UP | SOR_LANE_SEQ_CTL_DELAY(5);\n\ttegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\n\n\twhile (true) {\n\t\tvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\n\t\tif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(250, 1000);\n\t}\n\n\tvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\n\tvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\n\tvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\n\n\tif (mode->clock < 340000) {\n\t\tDRM_DEBUG_KMS(\"setting 2.7 GHz link speed\\n\");\n\t\tvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G2_70;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"setting 5.4 GHz link speed\\n\");\n\t\tvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G5_40;\n\t}\n\n\tvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK;\n\ttegra_sor_writel(sor, value, SOR_CLK_CNTRL);\n\n\t \n\tusleep_range(250, 1000);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\n\tvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\n\tvalue |= SOR_DP_LINKCTL_LANE_COUNT(4);\n\ttegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\n\tvalue &= ~SOR_DP_SPARE_DISP_VIDEO_PREAMBLE;\n\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\tvalue &= ~SOR_DP_SPARE_SEQ_ENABLE;\n\tvalue &= ~SOR_DP_SPARE_MACRO_SOR_CLK;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE0);\n\n\tvalue = SOR_SEQ_CTL_PU_PC(0) | SOR_SEQ_CTL_PU_PC_ALT(0) |\n\t\tSOR_SEQ_CTL_PD_PC(8) | SOR_SEQ_CTL_PD_PC_ALT(8);\n\ttegra_sor_writel(sor, value, SOR_SEQ_CTL);\n\n\tvalue = SOR_SEQ_INST_DRIVE_PWM_OUT_LO | SOR_SEQ_INST_HALT |\n\t\tSOR_SEQ_INST_WAIT_VSYNC | SOR_SEQ_INST_WAIT(1);\n\ttegra_sor_writel(sor, value, SOR_SEQ_INST(0));\n\ttegra_sor_writel(sor, value, SOR_SEQ_INST(8));\n\n\tif (!sor->soc->has_nvdisplay) {\n\t\t \n\t\tvalue = SOR_REFCLK_DIV_INT(div) | SOR_REFCLK_DIV_FRAC(div);\n\t\ttegra_sor_writel(sor, value, SOR_REFCLK);\n\t}\n\n\t \n\tfor (value = 0, i = 0; i < 5; i++)\n\t\tvalue |= SOR_XBAR_CTRL_LINK0_XSEL(i, sor->xbar_cfg[i]) |\n\t\t\t SOR_XBAR_CTRL_LINK1_XSEL(i, i);\n\n\ttegra_sor_writel(sor, 0x00000000, SOR_XBAR_POL);\n\ttegra_sor_writel(sor, value, SOR_XBAR_CTRL);\n\n\t \n#if 0\n\terr = clk_set_parent(sor->clk_pad, sor->clk_dp);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select pad parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n#endif\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_pad);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select SOR parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\t \n\terr = clk_set_parent(sor->clk, sor->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select output parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\t \n\trate = clk_get_rate(sor->clk_parent);\n\n\tif (mode->clock >= 340000)\n\t\trate /= 2;\n\n\tDRM_DEBUG_KMS(\"setting clock to %lu Hz, mode: %lu Hz\\n\", rate, pclk);\n\n\tclk_set_rate(sor->clk, rate);\n\n\tif (!sor->soc->has_nvdisplay) {\n\t\tvalue = SOR_INPUT_CONTROL_HDMI_SRC_SELECT(dc->pipe);\n\n\t\t \n\t\tif (mode->clock < 75000)\n\t\t\tvalue |= SOR_INPUT_CONTROL_ARM_VIDEO_RANGE_LIMITED;\n\n\t\ttegra_sor_writel(sor, value, SOR_INPUT_CONTROL);\n\t}\n\n\tmax_ac = ((mode->htotal - mode->hdisplay) - SOR_REKEY - 18) / 32;\n\n\tvalue = SOR_HDMI_CTRL_ENABLE | SOR_HDMI_CTRL_MAX_AC_PACKET(max_ac) |\n\t\tSOR_HDMI_CTRL_AUDIO_LAYOUT | SOR_HDMI_CTRL_REKEY(SOR_REKEY);\n\ttegra_sor_writel(sor, value, SOR_HDMI_CTRL);\n\n\tif (!dc->soc->has_nvdisplay) {\n\t\t \n\t\tpulse_start = h_ref_to_sync +\n\t\t\t      (mode->hsync_end - mode->hsync_start) +\n\t\t\t      (mode->htotal - mode->hsync_end) - 10;\n\n\t\tvalue = PULSE_LAST_END_A | PULSE_QUAL_VACTIVE |\n\t\t\tPULSE_POLARITY_HIGH | PULSE_MODE_NORMAL;\n\t\ttegra_dc_writel(dc, value, DC_DISP_H_PULSE2_CONTROL);\n\n\t\tvalue = PULSE_END(pulse_start + 8) | PULSE_START(pulse_start);\n\t\ttegra_dc_writel(dc, value, DC_DISP_H_PULSE2_POSITION_A);\n\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_SIGNAL_OPTIONS0);\n\t\tvalue |= H_PULSE2_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_SIGNAL_OPTIONS0);\n\t}\n\n\t \n\terr = tegra_sor_hdmi_setup_avi_infoframe(sor, mode);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to setup AVI infoframe: %d\\n\", err);\n\n\t \n\ttegra_sor_hdmi_disable_audio_infoframe(sor);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_PROTOCOL_MASK;\n\tvalue |= SOR_STATE_ASY_PROTOCOL_SINGLE_TMDS_A;\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\t \n\tsettings = tegra_sor_hdmi_find_settings(sor, mode->clock * 1000);\n\tif (!settings) {\n\t\tdev_err(sor->dev, \"no settings for pixel clock %d Hz\\n\",\n\t\t\tmode->clock * 1000);\n\t\treturn;\n\t}\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll0);\n\tvalue &= ~SOR_PLL0_ICHPMP_MASK;\n\tvalue &= ~SOR_PLL0_FILTER_MASK;\n\tvalue &= ~SOR_PLL0_VCOCAP_MASK;\n\tvalue |= SOR_PLL0_ICHPMP(settings->ichpmp);\n\tvalue |= SOR_PLL0_FILTER(settings->filter);\n\tvalue |= SOR_PLL0_VCOCAP(settings->vcocap);\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll0);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll1);\n\tvalue &= ~SOR_PLL1_LOADADJ_MASK;\n\tvalue &= ~SOR_PLL1_TMDS_TERMADJ_MASK;\n\tvalue |= SOR_PLL1_LOADADJ(settings->loadadj);\n\tvalue |= SOR_PLL1_TMDS_TERMADJ(settings->tmds_termadj);\n\tvalue |= SOR_PLL1_TMDS_TERM;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll1);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll3);\n\tvalue &= ~SOR_PLL3_BG_TEMP_COEF_MASK;\n\tvalue &= ~SOR_PLL3_BG_VREF_LEVEL_MASK;\n\tvalue &= ~SOR_PLL3_AVDD10_LEVEL_MASK;\n\tvalue &= ~SOR_PLL3_AVDD14_LEVEL_MASK;\n\tvalue |= SOR_PLL3_BG_TEMP_COEF(settings->bg_temp_coef);\n\tvalue |= SOR_PLL3_BG_VREF_LEVEL(settings->bg_vref_level);\n\tvalue |= SOR_PLL3_AVDD10_LEVEL(settings->avdd10_level);\n\tvalue |= SOR_PLL3_AVDD14_LEVEL(settings->avdd14_level);\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll3);\n\n\tvalue = settings->drive_current[3] << 24 |\n\t\tsettings->drive_current[2] << 16 |\n\t\tsettings->drive_current[1] <<  8 |\n\t\tsettings->drive_current[0] <<  0;\n\ttegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT0);\n\n\tvalue = settings->preemphasis[3] << 24 |\n\t\tsettings->preemphasis[2] << 16 |\n\t\tsettings->preemphasis[1] <<  8 |\n\t\tsettings->preemphasis[0] <<  0;\n\ttegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\n\tvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\n\tvalue |= SOR_DP_PADCTL_TX_PU(settings->tx_pu_value);\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl2);\n\tvalue &= ~SOR_DP_PADCTL_SPAREPLL_MASK;\n\tvalue |= SOR_DP_PADCTL_SPAREPLL(settings->sparepll);\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl2);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->dp_padctl0);\n\tvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\n\ttegra_sor_writel(sor, value, sor->soc->regs->dp_padctl0);\n\n\tif (!dc->soc->has_nvdisplay) {\n\t\t \n\t\tvalue = VSYNC_H_POSITION(1);\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_TIMING_OPTIONS);\n\t}\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_COLOR_CONTROL);\n\tvalue &= ~DITHER_CONTROL_MASK;\n\tvalue &= ~BASE_COLOR_SIZE_MASK;\n\n\tswitch (state->bpc) {\n\tcase 6:\n\t\tvalue |= BASE_COLOR_SIZE_666;\n\t\tbreak;\n\n\tcase 8:\n\t\tvalue |= BASE_COLOR_SIZE_888;\n\t\tbreak;\n\n\tcase 10:\n\t\tvalue |= BASE_COLOR_SIZE_101010;\n\t\tbreak;\n\n\tcase 12:\n\t\tvalue |= BASE_COLOR_SIZE_121212;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"%u bits-per-color not supported\\n\", state->bpc);\n\t\tvalue |= BASE_COLOR_SIZE_888;\n\t\tbreak;\n\t}\n\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_COLOR_CONTROL);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_OWNER_MASK;\n\tvalue |= SOR_STATE_ASY_OWNER(1 + dc->pipe);\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\n\terr = tegra_sor_power_up(sor, 250);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power up SOR: %d\\n\", err);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->head_state0 + dc->pipe);\n\tvalue &= ~SOR_HEAD_STATE_RANGECOMPRESS_MASK;\n\tvalue &= ~SOR_HEAD_STATE_DYNRANGE_MASK;\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state0 + dc->pipe);\n\n\t \n\tvalue = tegra_sor_readl(sor, sor->soc->regs->head_state0 + dc->pipe);\n\tvalue &= ~SOR_HEAD_STATE_COLORSPACE_MASK;\n\tvalue |= SOR_HEAD_STATE_COLORSPACE_RGB;\n\ttegra_sor_writel(sor, value, sor->soc->regs->head_state0 + dc->pipe);\n\n\ttegra_sor_mode_set(sor, mode, state);\n\n\ttegra_sor_update(sor);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\n\tvalue &= ~SOR_DP_SPARE_DISP_VIDEO_PREAMBLE;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE0);\n\n\terr = tegra_sor_attach(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to attach SOR: %d\\n\", err);\n\n\t \n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\n\tif (!sor->soc->has_nvdisplay)\n\t\tvalue |= SOR1_TIMING_CYA;\n\n\tvalue |= SOR_ENABLE(sor->index);\n\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\tif (dc->soc->has_nvdisplay) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_CORE_SOR_SET_CONTROL(sor->index));\n\t\tvalue &= ~PROTOCOL_MASK;\n\t\tvalue |= PROTOCOL_SINGLE_TMDS_A;\n\t\ttegra_dc_writel(dc, value, DC_DISP_CORE_SOR_SET_CONTROL(sor->index));\n\t}\n\n\ttegra_dc_commit(dc);\n\n\terr = tegra_sor_wakeup(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to wakeup SOR: %d\\n\", err);\n\n\ttegra_sor_hdmi_scdc_start(sor);\n\ttegra_sor_audio_prepare(sor);\n}\n\nstatic const struct drm_encoder_helper_funcs tegra_sor_hdmi_helpers = {\n\t.disable = tegra_sor_hdmi_disable,\n\t.enable = tegra_sor_hdmi_enable,\n\t.atomic_check = tegra_sor_encoder_atomic_check,\n};\n\nstatic void tegra_sor_dp_disable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_sor *sor = to_sor(output);\n\tu32 value;\n\tint err;\n\n\tif (output->panel)\n\t\tdrm_panel_disable(output->panel);\n\n\t \n\tif (output->connector.status != connector_status_disconnected) {\n\t\terr = drm_dp_link_power_down(sor->aux, &sor->link);\n\t\tif (err < 0)\n\t\t\tdev_err(sor->dev, \"failed to power down link: %d\\n\",\n\t\t\t\terr);\n\t}\n\n\terr = tegra_sor_detach(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to detach SOR: %d\\n\", err);\n\n\ttegra_sor_writel(sor, 0, SOR_STATE1);\n\ttegra_sor_update(sor);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue &= ~SOR_ENABLE(sor->index);\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\ttegra_dc_commit(dc);\n\n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_PROTOCOL_MASK;\n\tvalue &= ~SOR_STATE_ASY_SUBOWNER_MASK;\n\tvalue &= ~SOR_STATE_ASY_OWNER_MASK;\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\ttegra_sor_update(sor);\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to set safe clock: %d\\n\", err);\n\n\terr = tegra_sor_power_down(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power down SOR: %d\\n\", err);\n\n\terr = tegra_io_pad_power_disable(sor->pad);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power off I/O pad: %d\\n\", err);\n\n\terr = drm_dp_aux_disable(sor->aux);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed disable DPAUX: %d\\n\", err);\n\n\tif (output->panel)\n\t\tdrm_panel_unprepare(output->panel);\n\n\thost1x_client_suspend(&sor->client);\n}\n\nstatic void tegra_sor_dp_enable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_sor *sor = to_sor(output);\n\tstruct tegra_sor_config config;\n\tstruct tegra_sor_state *state;\n\tstruct drm_display_mode *mode;\n\tstruct drm_display_info *info;\n\tunsigned int i;\n\tu32 value;\n\tint err;\n\n\tstate = to_sor_state(output->connector.state);\n\tmode = &encoder->crtc->state->adjusted_mode;\n\tinfo = &output->connector.display_info;\n\n\terr = host1x_client_resume(&sor->client);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to set safe parent clock: %d\\n\", err);\n\n\terr = tegra_io_pad_power_enable(sor->pad);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power on LVDS rail: %d\\n\", err);\n\n\tusleep_range(20, 100);\n\n\terr = drm_dp_aux_enable(sor->aux);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to enable DPAUX: %d\\n\", err);\n\n\terr = drm_dp_link_probe(sor->aux, &sor->link);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to probe DP link: %d\\n\", err);\n\n\ttegra_sor_filter_rates(sor);\n\n\terr = drm_dp_link_choose(&sor->link, mode, info);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to choose link: %d\\n\", err);\n\n\tif (output->panel)\n\t\tdrm_panel_prepare(output->panel);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_BANDGAP_POWERDOWN;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(20, 40);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll3);\n\tvalue |= SOR_PLL3_PLL_VDD_MODE_3V3;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll3);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll0);\n\tvalue &= ~(SOR_PLL0_VCOPD | SOR_PLL0_PWR);\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll0);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\n\tvalue |= SOR_PLL2_SEQ_PLLCAPPD;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tusleep_range(200, 400);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll2);\n\tvalue &= ~SOR_PLL2_POWERDOWN_OVERRIDE;\n\tvalue &= ~SOR_PLL2_PORT_POWERDOWN;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll2);\n\n\tvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\n\tvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\n\n\tif (output->panel)\n\t\tvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK;\n\telse\n\t\tvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_DIFF_DPCLK;\n\n\ttegra_sor_writel(sor, value, SOR_CLK_CNTRL);\n\n\tusleep_range(200, 400);\n\n\tvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\n\t \n\tif (output->panel)\n\t\tvalue |= SOR_DP_SPARE_PANEL_INTERNAL;\n\telse\n\t\tvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\n\n\tvalue |= SOR_DP_SPARE_SEQ_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_DP_SPARE0);\n\n\t \n\ttegra_sor_writel(sor, 0, SOR_LVDS);\n\n\tvalue = tegra_sor_readl(sor, sor->soc->regs->pll0);\n\tvalue &= ~SOR_PLL0_ICHPMP_MASK;\n\tvalue &= ~SOR_PLL0_VCOCAP_MASK;\n\tvalue |= SOR_PLL0_ICHPMP(0x1);\n\tvalue |= SOR_PLL0_VCOCAP(0x3);\n\tvalue |= SOR_PLL0_RESISTOR_EXT;\n\ttegra_sor_writel(sor, value, sor->soc->regs->pll0);\n\n\t \n\tfor (value = 0, i = 0; i < 5; i++)\n\t\tvalue |= SOR_XBAR_CTRL_LINK0_XSEL(i, sor->soc->xbar_cfg[i]) |\n\t\t\t SOR_XBAR_CTRL_LINK1_XSEL(i, i);\n\n\ttegra_sor_writel(sor, 0x00000000, SOR_XBAR_POL);\n\ttegra_sor_writel(sor, value, SOR_XBAR_CTRL);\n\n\t \n#if 0\n\terr = clk_set_parent(sor->clk_pad, sor->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select pad parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n#endif\n\n\t \n\terr = tegra_sor_set_parent_clock(sor, sor->clk_pad);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select SOR parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\t \n\terr = clk_set_parent(sor->clk, sor->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to select output parent clock: %d\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_STATE1);\n\tvalue &= ~SOR_STATE_ASY_PROTOCOL_MASK;\n\tvalue |= SOR_STATE_ASY_PROTOCOL_DP_A;\n\ttegra_sor_writel(sor, value, SOR_STATE1);\n\n\t \n\tvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\n\tvalue |= SOR_DP_LINKCTL_ENABLE;\n\ttegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\n\n\ttegra_sor_dp_term_calibrate(sor);\n\n\terr = drm_dp_link_train(&sor->link);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"link training failed: %d\\n\", err);\n\telse\n\t\tdev_dbg(sor->dev, \"link training succeeded\\n\");\n\n\terr = drm_dp_link_power_up(sor->aux, &sor->link);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power up DP link: %d\\n\", err);\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.bits_per_pixel = state->bpc * 3;\n\n\terr = tegra_sor_compute_config(sor, mode, &config, &sor->link);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to compute configuration: %d\\n\", err);\n\n\ttegra_sor_apply_config(sor, &config);\n\ttegra_sor_mode_set(sor, mode, state);\n\n\tif (output->panel) {\n\t\t \n\t\tvalue = SOR_CSTM_LVDS | SOR_CSTM_LINK_ACT_A | SOR_CSTM_LINK_ACT_B |\n\t\t\tSOR_CSTM_UPPER;\n\t\ttegra_sor_writel(sor, value, SOR_CSTM);\n\n\t\t \n\t\terr = tegra_sor_setup_pwm(sor, 250);\n\t\tif (err < 0)\n\t\t\tdev_err(sor->dev, \"failed to setup PWM: %d\\n\", err);\n\t}\n\n\ttegra_sor_update(sor);\n\n\terr = tegra_sor_power_up(sor, 250);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to power up SOR: %d\\n\", err);\n\n\t \n\terr = tegra_sor_attach(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to attach SOR: %d\\n\", err);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue |= SOR_ENABLE(sor->index);\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\ttegra_dc_commit(dc);\n\n\terr = tegra_sor_wakeup(sor);\n\tif (err < 0)\n\t\tdev_err(sor->dev, \"failed to wakeup SOR: %d\\n\", err);\n\n\tif (output->panel)\n\t\tdrm_panel_enable(output->panel);\n}\n\nstatic const struct drm_encoder_helper_funcs tegra_sor_dp_helpers = {\n\t.disable = tegra_sor_dp_disable,\n\t.enable = tegra_sor_dp_enable,\n\t.atomic_check = tegra_sor_encoder_atomic_check,\n};\n\nstatic void tegra_sor_disable_regulator(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic int tegra_sor_enable_regulator(struct tegra_sor *sor, struct regulator *reg)\n{\n\tint err;\n\n\terr = regulator_enable(reg);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_add_action_or_reset(sor->dev, tegra_sor_disable_regulator, reg);\n}\n\nstatic int tegra_sor_hdmi_probe(struct tegra_sor *sor)\n{\n\tint err;\n\n\tsor->avdd_io_supply = devm_regulator_get(sor->dev, \"avdd-io-hdmi-dp\");\n\tif (IS_ERR(sor->avdd_io_supply))\n\t\treturn dev_err_probe(sor->dev, PTR_ERR(sor->avdd_io_supply),\n\t\t\t\t     \"cannot get AVDD I/O supply\\n\");\n\n\terr = tegra_sor_enable_regulator(sor, sor->avdd_io_supply);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to enable AVDD I/O supply: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tsor->vdd_pll_supply = devm_regulator_get(sor->dev, \"vdd-hdmi-dp-pll\");\n\tif (IS_ERR(sor->vdd_pll_supply))\n\t\treturn dev_err_probe(sor->dev, PTR_ERR(sor->vdd_pll_supply),\n\t\t\t\t     \"cannot get VDD PLL supply\\n\");\n\n\terr = tegra_sor_enable_regulator(sor, sor->vdd_pll_supply);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to enable VDD PLL supply: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tsor->hdmi_supply = devm_regulator_get(sor->dev, \"hdmi\");\n\tif (IS_ERR(sor->hdmi_supply))\n\t\treturn dev_err_probe(sor->dev, PTR_ERR(sor->hdmi_supply),\n\t\t\t\t     \"cannot get HDMI supply\\n\");\n\n\terr = tegra_sor_enable_regulator(sor, sor->hdmi_supply);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to enable HDMI supply: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tINIT_DELAYED_WORK(&sor->scdc, tegra_sor_hdmi_scdc_work);\n\n\treturn 0;\n}\n\nstatic const struct tegra_sor_ops tegra_sor_hdmi_ops = {\n\t.name = \"HDMI\",\n\t.probe = tegra_sor_hdmi_probe,\n\t.audio_enable = tegra_sor_hdmi_audio_enable,\n\t.audio_disable = tegra_sor_hdmi_audio_disable,\n};\n\nstatic int tegra_sor_dp_probe(struct tegra_sor *sor)\n{\n\tint err;\n\n\tsor->avdd_io_supply = devm_regulator_get(sor->dev, \"avdd-io-hdmi-dp\");\n\tif (IS_ERR(sor->avdd_io_supply))\n\t\treturn PTR_ERR(sor->avdd_io_supply);\n\n\terr = tegra_sor_enable_regulator(sor, sor->avdd_io_supply);\n\tif (err < 0)\n\t\treturn err;\n\n\tsor->vdd_pll_supply = devm_regulator_get(sor->dev, \"vdd-hdmi-dp-pll\");\n\tif (IS_ERR(sor->vdd_pll_supply))\n\t\treturn PTR_ERR(sor->vdd_pll_supply);\n\n\terr = tegra_sor_enable_regulator(sor, sor->vdd_pll_supply);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct tegra_sor_ops tegra_sor_dp_ops = {\n\t.name = \"DP\",\n\t.probe = tegra_sor_dp_probe,\n};\n\nstatic int tegra_sor_init(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tconst struct drm_encoder_helper_funcs *helpers = NULL;\n\tstruct tegra_sor *sor = host1x_client_to_sor(client);\n\tint connector = DRM_MODE_CONNECTOR_Unknown;\n\tint encoder = DRM_MODE_ENCODER_NONE;\n\tint err;\n\n\tif (!sor->aux) {\n\t\tif (sor->ops == &tegra_sor_hdmi_ops) {\n\t\t\tconnector = DRM_MODE_CONNECTOR_HDMIA;\n\t\t\tencoder = DRM_MODE_ENCODER_TMDS;\n\t\t\thelpers = &tegra_sor_hdmi_helpers;\n\t\t} else if (sor->soc->supports_lvds) {\n\t\t\tconnector = DRM_MODE_CONNECTOR_LVDS;\n\t\t\tencoder = DRM_MODE_ENCODER_LVDS;\n\t\t}\n\t} else {\n\t\tif (sor->output.panel) {\n\t\t\tconnector = DRM_MODE_CONNECTOR_eDP;\n\t\t\tencoder = DRM_MODE_ENCODER_TMDS;\n\t\t\thelpers = &tegra_sor_dp_helpers;\n\t\t} else {\n\t\t\tconnector = DRM_MODE_CONNECTOR_DisplayPort;\n\t\t\tencoder = DRM_MODE_ENCODER_TMDS;\n\t\t\thelpers = &tegra_sor_dp_helpers;\n\t\t}\n\n\t\tsor->link.ops = &tegra_sor_dp_link_ops;\n\t\tsor->link.aux = sor->aux;\n\t}\n\n\tsor->output.dev = sor->dev;\n\n\tdrm_connector_init_with_ddc(drm, &sor->output.connector,\n\t\t\t\t    &tegra_sor_connector_funcs,\n\t\t\t\t    connector,\n\t\t\t\t    sor->output.ddc);\n\tdrm_connector_helper_add(&sor->output.connector,\n\t\t\t\t &tegra_sor_connector_helper_funcs);\n\tsor->output.connector.dpms = DRM_MODE_DPMS_OFF;\n\n\tdrm_simple_encoder_init(drm, &sor->output.encoder, encoder);\n\tdrm_encoder_helper_add(&sor->output.encoder, helpers);\n\n\tdrm_connector_attach_encoder(&sor->output.connector,\n\t\t\t\t\t  &sor->output.encoder);\n\tdrm_connector_register(&sor->output.connector);\n\n\terr = tegra_output_init(drm, &sor->output);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to initialize output: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_output_find_possible_crtcs(&sor->output, drm);\n\n\tif (sor->aux) {\n\t\terr = drm_dp_aux_attach(sor->aux, &sor->output);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to attach DP: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (sor->rst) {\n\t\terr = pm_runtime_resume_and_get(sor->dev);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to get runtime PM: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = reset_control_acquire(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to acquire SOR reset: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto rpm_put;\n\t\t}\n\n\t\terr = reset_control_assert(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to assert SOR reset: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto rpm_put;\n\t\t}\n\t}\n\n\terr = clk_prepare_enable(sor->clk);\n\tif (err < 0) {\n\t\tdev_err(sor->dev, \"failed to enable clock: %d\\n\", err);\n\t\tgoto rpm_put;\n\t}\n\n\tusleep_range(1000, 3000);\n\n\tif (sor->rst) {\n\t\terr = reset_control_deassert(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to deassert SOR reset: %d\\n\",\n\t\t\t\terr);\n\t\t\tclk_disable_unprepare(sor->clk);\n\t\t\tgoto rpm_put;\n\t\t}\n\n\t\treset_control_release(sor->rst);\n\t\tpm_runtime_put(sor->dev);\n\t}\n\n\terr = clk_prepare_enable(sor->clk_safe);\n\tif (err < 0) {\n\t\tclk_disable_unprepare(sor->clk);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(sor->clk_dp);\n\tif (err < 0) {\n\t\tclk_disable_unprepare(sor->clk_safe);\n\t\tclk_disable_unprepare(sor->clk);\n\t\treturn err;\n\t}\n\n\treturn 0;\n\nrpm_put:\n\tif (sor->rst)\n\t\tpm_runtime_put(sor->dev);\n\n\treturn err;\n}\n\nstatic int tegra_sor_exit(struct host1x_client *client)\n{\n\tstruct tegra_sor *sor = host1x_client_to_sor(client);\n\tint err;\n\n\ttegra_output_exit(&sor->output);\n\n\tif (sor->aux) {\n\t\terr = drm_dp_aux_detach(sor->aux);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to detach DP: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tclk_disable_unprepare(sor->clk_safe);\n\tclk_disable_unprepare(sor->clk_dp);\n\tclk_disable_unprepare(sor->clk);\n\n\treturn 0;\n}\n\nstatic int tegra_sor_runtime_suspend(struct host1x_client *client)\n{\n\tstruct tegra_sor *sor = host1x_client_to_sor(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\tif (sor->rst) {\n\t\terr = reset_control_assert(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\treset_control_release(sor->rst);\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tclk_disable_unprepare(sor->clk);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int tegra_sor_runtime_resume(struct host1x_client *client)\n{\n\tstruct tegra_sor *sor = host1x_client_to_sor(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get runtime PM: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(sor->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\tgoto put_rpm;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tif (sor->rst) {\n\t\terr = reset_control_acquire(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to acquire reset: %d\\n\", err);\n\t\t\tgoto disable_clk;\n\t\t}\n\n\t\terr = reset_control_deassert(sor->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\t\tgoto release_reset;\n\t\t}\n\t}\n\n\treturn 0;\n\nrelease_reset:\n\treset_control_release(sor->rst);\ndisable_clk:\n\tclk_disable_unprepare(sor->clk);\nput_rpm:\n\tpm_runtime_put_sync(dev);\n\treturn err;\n}\n\nstatic const struct host1x_client_ops sor_client_ops = {\n\t.init = tegra_sor_init,\n\t.exit = tegra_sor_exit,\n\t.suspend = tegra_sor_runtime_suspend,\n\t.resume = tegra_sor_runtime_resume,\n};\n\nstatic const u8 tegra124_sor_xbar_cfg[5] = {\n\t0, 1, 2, 3, 4\n};\n\nstatic const struct tegra_sor_regs tegra124_sor_regs = {\n\t.head_state0 = 0x05,\n\t.head_state1 = 0x07,\n\t.head_state2 = 0x09,\n\t.head_state3 = 0x0b,\n\t.head_state4 = 0x0d,\n\t.head_state5 = 0x0f,\n\t.pll0 = 0x17,\n\t.pll1 = 0x18,\n\t.pll2 = 0x19,\n\t.pll3 = 0x1a,\n\t.dp_padctl0 = 0x5c,\n\t.dp_padctl2 = 0x73,\n};\n\n \nstatic const u8 tegra124_sor_lane_map[4] = {\n\t2, 1, 0, 3,\n};\n\nstatic const u8 tegra124_sor_voltage_swing[4][4][4] = {\n\t{\n\t\t{ 0x13, 0x19, 0x1e, 0x28 },\n\t\t{ 0x1e, 0x25, 0x2d, },\n\t\t{ 0x28, 0x32, },\n\t\t{ 0x3c, },\n\t}, {\n\t\t{ 0x12, 0x17, 0x1b, 0x25 },\n\t\t{ 0x1c, 0x23, 0x2a, },\n\t\t{ 0x25, 0x2f, },\n\t\t{ 0x39, }\n\t}, {\n\t\t{ 0x12, 0x16, 0x1a, 0x22 },\n\t\t{ 0x1b, 0x20, 0x27, },\n\t\t{ 0x24, 0x2d, },\n\t\t{ 0x36, },\n\t}, {\n\t\t{ 0x11, 0x14, 0x17, 0x1f },\n\t\t{ 0x19, 0x1e, 0x24, },\n\t\t{ 0x22, 0x2a, },\n\t\t{ 0x32, },\n\t},\n};\n\nstatic const u8 tegra124_sor_pre_emphasis[4][4][4] = {\n\t{\n\t\t{ 0x00, 0x09, 0x13, 0x25 },\n\t\t{ 0x00, 0x0f, 0x1e, },\n\t\t{ 0x00, 0x14, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x0a, 0x14, 0x28 },\n\t\t{ 0x00, 0x0f, 0x1e, },\n\t\t{ 0x00, 0x14, },\n\t\t{ 0x00 },\n\t}, {\n\t\t{ 0x00, 0x0a, 0x14, 0x28 },\n\t\t{ 0x00, 0x0f, 0x1e, },\n\t\t{ 0x00, 0x14, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x0a, 0x14, 0x28 },\n\t\t{ 0x00, 0x0f, 0x1e, },\n\t\t{ 0x00, 0x14, },\n\t\t{ 0x00, },\n\t},\n};\n\nstatic const u8 tegra124_sor_post_cursor[4][4][4] = {\n\t{\n\t\t{ 0x00, 0x00, 0x00, 0x00 },\n\t\t{ 0x00, 0x00, 0x00, },\n\t\t{ 0x00, 0x00, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x02, 0x02, 0x04, 0x05 },\n\t\t{ 0x02, 0x04, 0x05, },\n\t\t{ 0x04, 0x05, },\n\t\t{ 0x05, },\n\t}, {\n\t\t{ 0x04, 0x05, 0x08, 0x0b },\n\t\t{ 0x05, 0x09, 0x0b, },\n\t\t{ 0x08, 0x0a, },\n\t\t{ 0x0b, },\n\t}, {\n\t\t{ 0x05, 0x09, 0x0b, 0x12 },\n\t\t{ 0x09, 0x0d, 0x12, },\n\t\t{ 0x0b, 0x0f, },\n\t\t{ 0x12, },\n\t},\n};\n\nstatic const u8 tegra124_sor_tx_pu[4][4][4] = {\n\t{\n\t\t{ 0x20, 0x30, 0x40, 0x60 },\n\t\t{ 0x30, 0x40, 0x60, },\n\t\t{ 0x40, 0x60, },\n\t\t{ 0x60, },\n\t}, {\n\t\t{ 0x20, 0x20, 0x30, 0x50 },\n\t\t{ 0x30, 0x40, 0x50, },\n\t\t{ 0x40, 0x50, },\n\t\t{ 0x60, },\n\t}, {\n\t\t{ 0x20, 0x20, 0x30, 0x40, },\n\t\t{ 0x30, 0x30, 0x40, },\n\t\t{ 0x40, 0x50, },\n\t\t{ 0x60, },\n\t}, {\n\t\t{ 0x20, 0x20, 0x20, 0x40, },\n\t\t{ 0x30, 0x30, 0x40, },\n\t\t{ 0x40, 0x40, },\n\t\t{ 0x60, },\n\t},\n};\n\nstatic const struct tegra_sor_soc tegra124_sor = {\n\t.supports_lvds = true,\n\t.supports_hdmi = false,\n\t.supports_dp = true,\n\t.supports_audio = false,\n\t.supports_hdcp = false,\n\t.regs = &tegra124_sor_regs,\n\t.has_nvdisplay = false,\n\t.xbar_cfg = tegra124_sor_xbar_cfg,\n\t.lane_map = tegra124_sor_lane_map,\n\t.voltage_swing = tegra124_sor_voltage_swing,\n\t.pre_emphasis = tegra124_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const u8 tegra132_sor_pre_emphasis[4][4][4] = {\n\t{\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x01, 0x0e, 0x1d, },\n\t\t{ 0x01, 0x13, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00 },\n\t}, {\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00, },\n\t},\n};\n\nstatic const struct tegra_sor_soc tegra132_sor = {\n\t.supports_lvds = true,\n\t.supports_hdmi = false,\n\t.supports_dp = true,\n\t.supports_audio = false,\n\t.supports_hdcp = false,\n\t.regs = &tegra124_sor_regs,\n\t.has_nvdisplay = false,\n\t.xbar_cfg = tegra124_sor_xbar_cfg,\n\t.lane_map = tegra124_sor_lane_map,\n\t.voltage_swing = tegra124_sor_voltage_swing,\n\t.pre_emphasis = tegra132_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const struct tegra_sor_regs tegra210_sor_regs = {\n\t.head_state0 = 0x05,\n\t.head_state1 = 0x07,\n\t.head_state2 = 0x09,\n\t.head_state3 = 0x0b,\n\t.head_state4 = 0x0d,\n\t.head_state5 = 0x0f,\n\t.pll0 = 0x17,\n\t.pll1 = 0x18,\n\t.pll2 = 0x19,\n\t.pll3 = 0x1a,\n\t.dp_padctl0 = 0x5c,\n\t.dp_padctl2 = 0x73,\n};\n\nstatic const u8 tegra210_sor_xbar_cfg[5] = {\n\t2, 1, 0, 3, 4\n};\n\nstatic const u8 tegra210_sor_lane_map[4] = {\n\t0, 1, 2, 3,\n};\n\nstatic const struct tegra_sor_soc tegra210_sor = {\n\t.supports_lvds = false,\n\t.supports_hdmi = false,\n\t.supports_dp = true,\n\t.supports_audio = false,\n\t.supports_hdcp = false,\n\n\t.regs = &tegra210_sor_regs,\n\t.has_nvdisplay = false,\n\n\t.xbar_cfg = tegra210_sor_xbar_cfg,\n\t.lane_map = tegra210_sor_lane_map,\n\t.voltage_swing = tegra124_sor_voltage_swing,\n\t.pre_emphasis = tegra124_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const struct tegra_sor_soc tegra210_sor1 = {\n\t.supports_lvds = false,\n\t.supports_hdmi = true,\n\t.supports_dp = true,\n\t.supports_audio = true,\n\t.supports_hdcp = true,\n\n\t.regs = &tegra210_sor_regs,\n\t.has_nvdisplay = false,\n\n\t.num_settings = ARRAY_SIZE(tegra210_sor_hdmi_defaults),\n\t.settings = tegra210_sor_hdmi_defaults,\n\t.xbar_cfg = tegra210_sor_xbar_cfg,\n\t.lane_map = tegra210_sor_lane_map,\n\t.voltage_swing = tegra124_sor_voltage_swing,\n\t.pre_emphasis = tegra124_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const struct tegra_sor_regs tegra186_sor_regs = {\n\t.head_state0 = 0x151,\n\t.head_state1 = 0x154,\n\t.head_state2 = 0x157,\n\t.head_state3 = 0x15a,\n\t.head_state4 = 0x15d,\n\t.head_state5 = 0x160,\n\t.pll0 = 0x163,\n\t.pll1 = 0x164,\n\t.pll2 = 0x165,\n\t.pll3 = 0x166,\n\t.dp_padctl0 = 0x168,\n\t.dp_padctl2 = 0x16a,\n};\n\nstatic const u8 tegra186_sor_voltage_swing[4][4][4] = {\n\t{\n\t\t{ 0x13, 0x19, 0x1e, 0x28 },\n\t\t{ 0x1e, 0x25, 0x2d, },\n\t\t{ 0x28, 0x32, },\n\t\t{ 0x39, },\n\t}, {\n\t\t{ 0x12, 0x16, 0x1b, 0x25 },\n\t\t{ 0x1c, 0x23, 0x2a, },\n\t\t{ 0x25, 0x2f, },\n\t\t{ 0x37, }\n\t}, {\n\t\t{ 0x12, 0x16, 0x1a, 0x22 },\n\t\t{ 0x1b, 0x20, 0x27, },\n\t\t{ 0x24, 0x2d, },\n\t\t{ 0x35, },\n\t}, {\n\t\t{ 0x11, 0x14, 0x17, 0x1f },\n\t\t{ 0x19, 0x1e, 0x24, },\n\t\t{ 0x22, 0x2a, },\n\t\t{ 0x32, },\n\t},\n};\n\nstatic const u8 tegra186_sor_pre_emphasis[4][4][4] = {\n\t{\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x01, 0x0e, 0x1d, },\n\t\t{ 0x01, 0x13, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00 },\n\t}, {\n\t\t{ 0x00, 0x08, 0x14, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00, },\n\t}, {\n\t\t{ 0x00, 0x08, 0x12, 0x24 },\n\t\t{ 0x00, 0x0e, 0x1d, },\n\t\t{ 0x00, 0x13, },\n\t\t{ 0x00, },\n\t},\n};\n\nstatic const struct tegra_sor_soc tegra186_sor = {\n\t.supports_lvds = false,\n\t.supports_hdmi = true,\n\t.supports_dp = true,\n\t.supports_audio = true,\n\t.supports_hdcp = true,\n\n\t.regs = &tegra186_sor_regs,\n\t.has_nvdisplay = true,\n\n\t.num_settings = ARRAY_SIZE(tegra186_sor_hdmi_defaults),\n\t.settings = tegra186_sor_hdmi_defaults,\n\t.xbar_cfg = tegra124_sor_xbar_cfg,\n\t.lane_map = tegra124_sor_lane_map,\n\t.voltage_swing = tegra186_sor_voltage_swing,\n\t.pre_emphasis = tegra186_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const struct tegra_sor_regs tegra194_sor_regs = {\n\t.head_state0 = 0x151,\n\t.head_state1 = 0x155,\n\t.head_state2 = 0x159,\n\t.head_state3 = 0x15d,\n\t.head_state4 = 0x161,\n\t.head_state5 = 0x165,\n\t.pll0 = 0x169,\n\t.pll1 = 0x16a,\n\t.pll2 = 0x16b,\n\t.pll3 = 0x16c,\n\t.dp_padctl0 = 0x16e,\n\t.dp_padctl2 = 0x16f,\n};\n\nstatic const struct tegra_sor_soc tegra194_sor = {\n\t.supports_lvds = false,\n\t.supports_hdmi = true,\n\t.supports_dp = true,\n\t.supports_audio = true,\n\t.supports_hdcp = true,\n\n\t.regs = &tegra194_sor_regs,\n\t.has_nvdisplay = true,\n\n\t.num_settings = ARRAY_SIZE(tegra194_sor_hdmi_defaults),\n\t.settings = tegra194_sor_hdmi_defaults,\n\n\t.xbar_cfg = tegra210_sor_xbar_cfg,\n\t.lane_map = tegra124_sor_lane_map,\n\t.voltage_swing = tegra186_sor_voltage_swing,\n\t.pre_emphasis = tegra186_sor_pre_emphasis,\n\t.post_cursor = tegra124_sor_post_cursor,\n\t.tx_pu = tegra124_sor_tx_pu,\n};\n\nstatic const struct of_device_id tegra_sor_of_match[] = {\n\t{ .compatible = \"nvidia,tegra194-sor\", .data = &tegra194_sor },\n\t{ .compatible = \"nvidia,tegra186-sor\", .data = &tegra186_sor },\n\t{ .compatible = \"nvidia,tegra210-sor1\", .data = &tegra210_sor1 },\n\t{ .compatible = \"nvidia,tegra210-sor\", .data = &tegra210_sor },\n\t{ .compatible = \"nvidia,tegra132-sor\", .data = &tegra132_sor },\n\t{ .compatible = \"nvidia,tegra124-sor\", .data = &tegra124_sor },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_sor_of_match);\n\nstatic int tegra_sor_parse_dt(struct tegra_sor *sor)\n{\n\tstruct device_node *np = sor->dev->of_node;\n\tu32 xbar_cfg[5];\n\tunsigned int i;\n\tu32 value;\n\tint err;\n\n\tif (sor->soc->has_nvdisplay) {\n\t\terr = of_property_read_u32(np, \"nvidia,interface\", &value);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tsor->index = value;\n\n\t\t \n\t\tsor->pad = TEGRA_IO_PAD_HDMI_DP0 + sor->index;\n\t} else {\n\t\tif (!sor->soc->supports_audio)\n\t\t\tsor->index = 0;\n\t\telse\n\t\t\tsor->index = 1;\n\t}\n\n\terr = of_property_read_u32_array(np, \"nvidia,xbar-cfg\", xbar_cfg, 5);\n\tif (err < 0) {\n\t\t \n\t\tfor (i = 0; i < 5; i++)\n\t\t\tsor->xbar_cfg[i] = sor->soc->xbar_cfg[i];\n\t} else {\n\t\t \n\t\tfor (i = 0; i < 5; i++)\n\t\t\tsor->xbar_cfg[i] = xbar_cfg[i];\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_sor_irq(int irq, void *data)\n{\n\tstruct tegra_sor *sor = data;\n\tu32 value;\n\n\tvalue = tegra_sor_readl(sor, SOR_INT_STATUS);\n\ttegra_sor_writel(sor, value, SOR_INT_STATUS);\n\n\tif (value & SOR_INT_CODEC_SCRATCH0) {\n\t\tvalue = tegra_sor_readl(sor, SOR_AUDIO_HDA_CODEC_SCRATCH0);\n\n\t\tif (value & SOR_AUDIO_HDA_CODEC_SCRATCH0_VALID) {\n\t\t\tunsigned int format;\n\n\t\t\tformat = value & SOR_AUDIO_HDA_CODEC_SCRATCH0_FMT_MASK;\n\n\t\t\ttegra_hda_parse_format(format, &sor->format);\n\n\t\t\tif (sor->ops->audio_enable)\n\t\t\t\tsor->ops->audio_enable(sor);\n\t\t} else {\n\t\t\tif (sor->ops->audio_disable)\n\t\t\t\tsor->ops->audio_disable(sor);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_sor_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct tegra_sor *sor;\n\tint err;\n\n\tsor = devm_kzalloc(&pdev->dev, sizeof(*sor), GFP_KERNEL);\n\tif (!sor)\n\t\treturn -ENOMEM;\n\n\tsor->soc = of_device_get_match_data(&pdev->dev);\n\tsor->output.dev = sor->dev = &pdev->dev;\n\n\tsor->settings = devm_kmemdup(&pdev->dev, sor->soc->settings,\n\t\t\t\t     sor->soc->num_settings *\n\t\t\t\t\tsizeof(*sor->settings),\n\t\t\t\t     GFP_KERNEL);\n\tif (!sor->settings)\n\t\treturn -ENOMEM;\n\n\tsor->num_settings = sor->soc->num_settings;\n\n\tnp = of_parse_phandle(pdev->dev.of_node, \"nvidia,dpaux\", 0);\n\tif (np) {\n\t\tsor->aux = drm_dp_aux_find_by_of_node(np);\n\t\tof_node_put(np);\n\n\t\tif (!sor->aux)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (get_device(sor->aux->dev))\n\t\t\tsor->output.ddc = &sor->aux->ddc;\n\t}\n\n\tif (!sor->aux) {\n\t\tif (sor->soc->supports_hdmi) {\n\t\t\tsor->ops = &tegra_sor_hdmi_ops;\n\t\t\tsor->pad = TEGRA_IO_PAD_HDMI;\n\t\t} else if (sor->soc->supports_lvds) {\n\t\t\tdev_err(&pdev->dev, \"LVDS not supported yet\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"unknown (non-DP) support\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tnp = of_parse_phandle(pdev->dev.of_node, \"nvidia,panel\", 0);\n\t\t \n\t\tof_node_put(np);\n\n\t\tsor->ops = &tegra_sor_dp_ops;\n\t\tsor->pad = TEGRA_IO_PAD_LVDS;\n\t}\n\n\terr = tegra_sor_parse_dt(sor);\n\tif (err < 0)\n\t\tgoto put_aux;\n\n\terr = tegra_output_probe(&sor->output);\n\tif (err < 0) {\n\t\tdev_err_probe(&pdev->dev, err, \"failed to probe output\\n\");\n\t\tgoto put_aux;\n\t}\n\n\tif (sor->ops && sor->ops->probe) {\n\t\terr = sor->ops->probe(sor);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to probe %s: %d\\n\",\n\t\t\t\tsor->ops->name, err);\n\t\t\tgoto remove;\n\t\t}\n\t}\n\n\tsor->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sor->regs)) {\n\t\terr = PTR_ERR(sor->regs);\n\t\tgoto remove;\n\t}\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\tgoto remove;\n\n\tsor->irq = err;\n\n\terr = devm_request_irq(sor->dev, sor->irq, tegra_sor_irq, 0,\n\t\t\t       dev_name(sor->dev), sor);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\tsor->rst = devm_reset_control_get_exclusive_released(&pdev->dev, \"sor\");\n\tif (IS_ERR(sor->rst)) {\n\t\terr = PTR_ERR(sor->rst);\n\n\t\tif (err != -EBUSY || WARN_ON(!pdev->dev.pm_domain)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get reset control: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto remove;\n\t\t}\n\n\t\t \n\t\tsor->rst = NULL;\n\t}\n\n\tsor->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sor->clk)) {\n\t\terr = PTR_ERR(sor->clk);\n\t\tdev_err(&pdev->dev, \"failed to get module clock: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\tif (sor->soc->supports_hdmi || sor->soc->supports_dp) {\n\t\tstruct device_node *np = pdev->dev.of_node;\n\t\tconst char *name;\n\n\t\t \n\t\tif (of_property_match_string(np, \"clock-names\", \"out\") < 0)\n\t\t\tname = \"source\";\n\t\telse\n\t\t\tname = \"out\";\n\n\t\tsor->clk_out = devm_clk_get(&pdev->dev, name);\n\t\tif (IS_ERR(sor->clk_out)) {\n\t\t\terr = PTR_ERR(sor->clk_out);\n\t\t\tdev_err(sor->dev, \"failed to get %s clock: %d\\n\",\n\t\t\t\tname, err);\n\t\t\tgoto remove;\n\t\t}\n\t} else {\n\t\t \n\t\tsor->clk_out = sor->clk;\n\t}\n\n\tsor->clk_parent = devm_clk_get(&pdev->dev, \"parent\");\n\tif (IS_ERR(sor->clk_parent)) {\n\t\terr = PTR_ERR(sor->clk_parent);\n\t\tdev_err(&pdev->dev, \"failed to get parent clock: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\tsor->clk_safe = devm_clk_get(&pdev->dev, \"safe\");\n\tif (IS_ERR(sor->clk_safe)) {\n\t\terr = PTR_ERR(sor->clk_safe);\n\t\tdev_err(&pdev->dev, \"failed to get safe clock: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\tsor->clk_dp = devm_clk_get(&pdev->dev, \"dp\");\n\tif (IS_ERR(sor->clk_dp)) {\n\t\terr = PTR_ERR(sor->clk_dp);\n\t\tdev_err(&pdev->dev, \"failed to get DP clock: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\t \n\tsor->clk_pad = devm_clk_get(&pdev->dev, \"pad\");\n\tif (IS_ERR(sor->clk_pad)) {\n\t\tif (sor->clk_pad != ERR_PTR(-ENOENT)) {\n\t\t\terr = PTR_ERR(sor->clk_pad);\n\t\t\tgoto remove;\n\t\t}\n\n\t\t \n\t\tsor->clk_pad = NULL;\n\t}\n\n\t \n\terr = clk_set_parent(sor->clk_out, sor->clk_safe);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to use safe clock: %d\\n\", err);\n\t\tgoto remove;\n\t}\n\n\tplatform_set_drvdata(pdev, sor);\n\tpm_runtime_enable(&pdev->dev);\n\n\thost1x_client_init(&sor->client);\n\tsor->client.ops = &sor_client_ops;\n\tsor->client.dev = &pdev->dev;\n\n\t \n\tif (!sor->clk_pad) {\n\t\tchar *name;\n\n\t\tname = devm_kasprintf(sor->dev, GFP_KERNEL, \"sor%u_pad_clkout\",\n\t\t\t\t      sor->index);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto uninit;\n\t\t}\n\n\t\terr = host1x_client_resume(&sor->client);\n\t\tif (err < 0) {\n\t\t\tdev_err(sor->dev, \"failed to resume: %d\\n\", err);\n\t\t\tgoto uninit;\n\t\t}\n\n\t\tsor->clk_pad = tegra_clk_sor_pad_register(sor, name);\n\t\thost1x_client_suspend(&sor->client);\n\t}\n\n\tif (IS_ERR(sor->clk_pad)) {\n\t\terr = PTR_ERR(sor->clk_pad);\n\t\tdev_err(sor->dev, \"failed to register SOR pad clock: %d\\n\",\n\t\t\terr);\n\t\tgoto uninit;\n\t}\n\n\terr = __host1x_client_register(&sor->client);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\t\tgoto uninit;\n\t}\n\n\treturn 0;\n\nuninit:\n\thost1x_client_exit(&sor->client);\n\tpm_runtime_disable(&pdev->dev);\nremove:\n\tif (sor->aux)\n\t\tsor->output.ddc = NULL;\n\n\ttegra_output_remove(&sor->output);\nput_aux:\n\tif (sor->aux)\n\t\tput_device(sor->aux->dev);\n\n\treturn err;\n}\n\nstatic void tegra_sor_remove(struct platform_device *pdev)\n{\n\tstruct tegra_sor *sor = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&sor->client);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (sor->aux) {\n\t\tput_device(sor->aux->dev);\n\t\tsor->output.ddc = NULL;\n\t}\n\n\ttegra_output_remove(&sor->output);\n}\n\nstatic int __maybe_unused tegra_sor_suspend(struct device *dev)\n{\n\tstruct tegra_sor *sor = dev_get_drvdata(dev);\n\tint err;\n\n\terr = tegra_output_suspend(&sor->output);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to suspend output: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (sor->hdmi_supply) {\n\t\terr = regulator_disable(sor->hdmi_supply);\n\t\tif (err < 0) {\n\t\t\ttegra_output_resume(&sor->output);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_sor_resume(struct device *dev)\n{\n\tstruct tegra_sor *sor = dev_get_drvdata(dev);\n\tint err;\n\n\tif (sor->hdmi_supply) {\n\t\terr = regulator_enable(sor->hdmi_supply);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = tegra_output_resume(&sor->output);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to resume output: %d\\n\", err);\n\n\t\tif (sor->hdmi_supply)\n\t\t\tregulator_disable(sor->hdmi_supply);\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_sor_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_sor_suspend, tegra_sor_resume)\n};\n\nstruct platform_driver tegra_sor_driver = {\n\t.driver = {\n\t\t.name = \"tegra-sor\",\n\t\t.of_match_table = tegra_sor_of_match,\n\t\t.pm = &tegra_sor_pm_ops,\n\t},\n\t.probe = tegra_sor_probe,\n\t.remove_new = tegra_sor_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}