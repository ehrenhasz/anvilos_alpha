{
  "module_name": "fbdev.c",
  "hash_id": "2a2843eb976f04a1561cc8e5319a93c620f8153938e8a3678b905f6db0d3468e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/fbdev.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper.h>\n\n#include \"drm.h\"\n#include \"gem.h\"\n\nstatic int tegra_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tstruct tegra_bo *bo;\n\tint err;\n\n\tbo = tegra_fb_get_plane(helper->fb, 0);\n\n\terr = drm_gem_mmap_obj(&bo->gem, bo->gem.size, vma);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn __tegra_gem_mmap(&bo->gem, vma);\n}\n\nstatic void tegra_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tstruct drm_framebuffer *fb = helper->fb;\n\tstruct tegra_bo *bo = tegra_fb_get_plane(fb, 0);\n\n\tdrm_fb_helper_fini(helper);\n\n\t \n\tif (bo->pages) {\n\t\tvunmap(bo->vaddr);\n\t\tbo->vaddr = NULL;\n\t}\n\tdrm_framebuffer_remove(fb);\n\n\tdrm_client_release(&helper->client);\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(helper);\n}\n\nstatic const struct fb_ops tegra_fb_ops = {\n\t.owner = THIS_MODULE,\n\t__FB_DEFAULT_DMAMEM_OPS_RDWR,\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t__FB_DEFAULT_DMAMEM_OPS_DRAW,\n\t.fb_mmap = tegra_fb_mmap,\n\t.fb_destroy = tegra_fbdev_fb_destroy,\n};\n\nstatic int tegra_fbdev_probe(struct drm_fb_helper *helper,\n\t\t\t     struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct tegra_drm *tegra = helper->dev->dev_private;\n\tstruct drm_device *drm = helper->dev;\n\tstruct drm_mode_fb_cmd2 cmd = { 0 };\n\tunsigned int bytes_per_pixel;\n\tstruct drm_framebuffer *fb;\n\tunsigned long offset;\n\tstruct fb_info *info;\n\tstruct tegra_bo *bo;\n\tsize_t size;\n\tint err;\n\n\tbytes_per_pixel = DIV_ROUND_UP(sizes->surface_bpp, 8);\n\n\tcmd.width = sizes->surface_width;\n\tcmd.height = sizes->surface_height;\n\tcmd.pitches[0] = round_up(sizes->surface_width * bytes_per_pixel,\n\t\t\t\t  tegra->pitch_align);\n\n\tcmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\t\t     sizes->surface_depth);\n\n\tsize = cmd.pitches[0] * cmd.height;\n\n\tbo = tegra_bo_create(drm, size, 0);\n\tif (IS_ERR(bo))\n\t\treturn PTR_ERR(bo);\n\n\tinfo = drm_fb_helper_alloc_info(helper);\n\tif (IS_ERR(info)) {\n\t\tdev_err(drm->dev, \"failed to allocate framebuffer info\\n\");\n\t\tdrm_gem_object_put(&bo->gem);\n\t\treturn PTR_ERR(info);\n\t}\n\n\tfb = tegra_fb_alloc(drm, &cmd, &bo, 1);\n\tif (IS_ERR(fb)) {\n\t\terr = PTR_ERR(fb);\n\t\tdev_err(drm->dev, \"failed to allocate DRM framebuffer: %d\\n\",\n\t\t\terr);\n\t\tdrm_gem_object_put(&bo->gem);\n\t\treturn PTR_ERR(fb);\n\t}\n\n\thelper->fb = fb;\n\thelper->info = info;\n\n\tinfo->fbops = &tegra_fb_ops;\n\n\tdrm_fb_helper_fill_info(info, helper, sizes);\n\n\toffset = info->var.xoffset * bytes_per_pixel +\n\t\t info->var.yoffset * fb->pitches[0];\n\n\tif (bo->pages) {\n\t\tbo->vaddr = vmap(bo->pages, bo->num_pages, VM_MAP,\n\t\t\t\t pgprot_writecombine(PAGE_KERNEL));\n\t\tif (!bo->vaddr) {\n\t\t\tdev_err(drm->dev, \"failed to vmap() framebuffer\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto destroy;\n\t\t}\n\t}\n\n\tinfo->flags |= FBINFO_VIRTFB;\n\tinfo->screen_buffer = bo->vaddr + offset;\n\tinfo->screen_size = size;\n\tinfo->fix.smem_start = (unsigned long)(bo->iova + offset);\n\tinfo->fix.smem_len = size;\n\n\treturn 0;\n\ndestroy:\n\tdrm_framebuffer_remove(fb);\n\treturn err;\n}\n\nstatic const struct drm_fb_helper_funcs tegra_fb_helper_funcs = {\n\t.fb_probe = tegra_fbdev_probe,\n};\n\n \n\nstatic void tegra_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\n\tif (fb_helper->info) {\n\t\tdrm_fb_helper_unregister_info(fb_helper);\n\t} else {\n\t\tdrm_client_release(&fb_helper->client);\n\t\tdrm_fb_helper_unprepare(fb_helper);\n\t\tkfree(fb_helper);\n\t}\n}\n\nstatic int tegra_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fb_helper);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\tdrm_helper_disable_unused_functions(dev);\n\n\tret = drm_fb_helper_initial_config(fb_helper);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fb_helper);\nerr_drm_err:\n\tdrm_err(dev, \"Failed to setup fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs tegra_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= tegra_fbdev_client_unregister,\n\t.restore\t= tegra_fbdev_client_restore,\n\t.hotplug\t= tegra_fbdev_client_hotplug,\n};\n\nvoid tegra_fbdev_setup(struct drm_device *dev)\n{\n\tstruct drm_fb_helper *helper;\n\tint ret;\n\n\tdrm_WARN(dev, !dev->registered, \"Device has not been registered.\\n\");\n\tdrm_WARN(dev, dev->fb_helper, \"fb_helper is already set!\\n\");\n\n\thelper = kzalloc(sizeof(*helper), GFP_KERNEL);\n\tif (!helper)\n\t\treturn;\n\tdrm_fb_helper_prepare(dev, helper, 32, &tegra_fb_helper_funcs);\n\n\tret = drm_client_init(dev, &helper->client, \"fbdev\", &tegra_fbdev_client_funcs);\n\tif (ret)\n\t\tgoto err_drm_client_init;\n\n\tdrm_client_register(&helper->client);\n\n\treturn;\n\nerr_drm_client_init:\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(helper);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}