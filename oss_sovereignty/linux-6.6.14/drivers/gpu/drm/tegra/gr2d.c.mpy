{
  "module_name": "gr2d.c",
  "hash_id": "706f09dc553b6f8830abae360842904f80e6b67c95cda2988a1005e522a73d7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/gr2d.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n\n#include \"drm.h\"\n#include \"gem.h\"\n#include \"gr2d.h\"\n\nenum {\n\tRST_MC,\n\tRST_GR2D,\n\tRST_GR2D_MAX,\n};\n\nstruct gr2d_soc {\n\tunsigned int version;\n};\n\nstruct gr2d {\n\tstruct tegra_drm_client client;\n\tstruct host1x_channel *channel;\n\tstruct clk *clk;\n\n\tstruct reset_control_bulk_data resets[RST_GR2D_MAX];\n\tunsigned int nresets;\n\n\tconst struct gr2d_soc *soc;\n\n\tDECLARE_BITMAP(addr_regs, GR2D_NUM_REGS);\n};\n\nstatic inline struct gr2d *to_gr2d(struct tegra_drm_client *client)\n{\n\treturn container_of(client, struct gr2d, client);\n}\n\nstatic int gr2d_init(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tunsigned long flags = HOST1X_SYNCPT_HAS_BASE;\n\tstruct gr2d *gr2d = to_gr2d(drm);\n\tint err;\n\n\tgr2d->channel = host1x_channel_request(client);\n\tif (!gr2d->channel)\n\t\treturn -ENOMEM;\n\n\tclient->syncpts[0] = host1x_syncpt_request(client, flags);\n\tif (!client->syncpts[0]) {\n\t\terr = -ENOMEM;\n\t\tdev_err(client->dev, \"failed to request syncpoint: %d\\n\", err);\n\t\tgoto put;\n\t}\n\n\terr = host1x_client_iommu_attach(client);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to attach to domain: %d\\n\", err);\n\t\tgoto free;\n\t}\n\n\terr = tegra_drm_register_client(dev->dev_private, drm);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to register client: %d\\n\", err);\n\t\tgoto detach_iommu;\n\t}\n\n\treturn 0;\n\ndetach_iommu:\n\thost1x_client_iommu_detach(client);\nfree:\n\thost1x_syncpt_put(client->syncpts[0]);\nput:\n\thost1x_channel_put(gr2d->channel);\n\treturn err;\n}\n\nstatic int gr2d_exit(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = dev->dev_private;\n\tstruct gr2d *gr2d = to_gr2d(drm);\n\tint err;\n\n\terr = tegra_drm_unregister_client(tegra, drm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpm_runtime_dont_use_autosuspend(client->dev);\n\tpm_runtime_force_suspend(client->dev);\n\n\thost1x_client_iommu_detach(client);\n\thost1x_syncpt_put(client->syncpts[0]);\n\thost1x_channel_put(gr2d->channel);\n\n\tgr2d->channel = NULL;\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops gr2d_client_ops = {\n\t.init = gr2d_init,\n\t.exit = gr2d_exit,\n};\n\nstatic int gr2d_open_channel(struct tegra_drm_client *client,\n\t\t\t     struct tegra_drm_context *context)\n{\n\tstruct gr2d *gr2d = to_gr2d(client);\n\n\tcontext->channel = host1x_channel_get(gr2d->channel);\n\tif (!context->channel)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void gr2d_close_channel(struct tegra_drm_context *context)\n{\n\thost1x_channel_put(context->channel);\n}\n\nstatic int gr2d_is_addr_reg(struct device *dev, u32 class, u32 offset)\n{\n\tstruct gr2d *gr2d = dev_get_drvdata(dev);\n\n\tswitch (class) {\n\tcase HOST1X_CLASS_HOST1X:\n\t\tif (offset == 0x2b)\n\t\t\treturn 1;\n\n\t\tbreak;\n\n\tcase HOST1X_CLASS_GR2D:\n\tcase HOST1X_CLASS_GR2D_SB:\n\t\tif (offset >= GR2D_NUM_REGS)\n\t\t\tbreak;\n\n\t\tif (test_bit(offset, gr2d->addr_regs))\n\t\t\treturn 1;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gr2d_is_valid_class(u32 class)\n{\n\treturn (class == HOST1X_CLASS_GR2D ||\n\t\tclass == HOST1X_CLASS_GR2D_SB);\n}\n\nstatic const struct tegra_drm_client_ops gr2d_ops = {\n\t.open_channel = gr2d_open_channel,\n\t.close_channel = gr2d_close_channel,\n\t.is_addr_reg = gr2d_is_addr_reg,\n\t.is_valid_class = gr2d_is_valid_class,\n\t.submit = tegra_drm_submit,\n};\n\nstatic const struct gr2d_soc tegra20_gr2d_soc = {\n\t.version = 0x20,\n};\n\nstatic const struct gr2d_soc tegra30_gr2d_soc = {\n\t.version = 0x30,\n};\n\nstatic const struct gr2d_soc tegra114_gr2d_soc = {\n\t.version = 0x35,\n};\n\nstatic const struct of_device_id gr2d_match[] = {\n\t{ .compatible = \"nvidia,tegra114-gr2d\", .data = &tegra114_gr2d_soc },\n\t{ .compatible = \"nvidia,tegra30-gr2d\", .data = &tegra30_gr2d_soc },\n\t{ .compatible = \"nvidia,tegra20-gr2d\", .data = &tegra20_gr2d_soc },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gr2d_match);\n\nstatic const u32 gr2d_addr_regs[] = {\n\tGR2D_UA_BASE_ADDR,\n\tGR2D_VA_BASE_ADDR,\n\tGR2D_PAT_BASE_ADDR,\n\tGR2D_DSTA_BASE_ADDR,\n\tGR2D_DSTB_BASE_ADDR,\n\tGR2D_DSTC_BASE_ADDR,\n\tGR2D_SRCA_BASE_ADDR,\n\tGR2D_SRCB_BASE_ADDR,\n\tGR2D_PATBASE_ADDR,\n\tGR2D_SRC_BASE_ADDR_SB,\n\tGR2D_DSTA_BASE_ADDR_SB,\n\tGR2D_DSTB_BASE_ADDR_SB,\n\tGR2D_UA_BASE_ADDR_SB,\n\tGR2D_VA_BASE_ADDR_SB,\n};\n\nstatic int gr2d_get_resets(struct device *dev, struct gr2d *gr2d)\n{\n\tint err;\n\n\tgr2d->resets[RST_MC].id = \"mc\";\n\tgr2d->resets[RST_GR2D].id = \"2d\";\n\tgr2d->nresets = RST_GR2D_MAX;\n\n\terr = devm_reset_control_bulk_get_optional_exclusive_released(\n\t\t\t\tdev, gr2d->nresets, gr2d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (WARN_ON(!gr2d->resets[RST_GR2D].rstc))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int gr2d_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct host1x_syncpt **syncpts;\n\tstruct gr2d *gr2d;\n\tunsigned int i;\n\tint err;\n\n\tgr2d = devm_kzalloc(dev, sizeof(*gr2d), GFP_KERNEL);\n\tif (!gr2d)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, gr2d);\n\n\tgr2d->soc = of_device_get_match_data(dev);\n\n\tsyncpts = devm_kzalloc(dev, sizeof(*syncpts), GFP_KERNEL);\n\tif (!syncpts)\n\t\treturn -ENOMEM;\n\n\tgr2d->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(gr2d->clk)) {\n\t\tdev_err(dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(gr2d->clk);\n\t}\n\n\terr = gr2d_get_resets(dev, gr2d);\n\tif (err)\n\t\treturn err;\n\n\tINIT_LIST_HEAD(&gr2d->client.base.list);\n\tgr2d->client.base.ops = &gr2d_client_ops;\n\tgr2d->client.base.dev = dev;\n\tgr2d->client.base.class = HOST1X_CLASS_GR2D;\n\tgr2d->client.base.syncpts = syncpts;\n\tgr2d->client.base.num_syncpts = 1;\n\n\tINIT_LIST_HEAD(&gr2d->client.list);\n\tgr2d->client.version = gr2d->soc->version;\n\tgr2d->client.ops = &gr2d_ops;\n\n\terr = devm_tegra_core_dev_init_opp_table_common(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = host1x_client_register(&gr2d->client.base);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register host1x client: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gr2d_addr_regs); i++)\n\t\tset_bit(gr2d_addr_regs[i], gr2d->addr_regs);\n\n\treturn 0;\n}\n\nstatic void gr2d_remove(struct platform_device *pdev)\n{\n\tstruct gr2d *gr2d = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\thost1x_client_unregister(&gr2d->client.base);\n}\n\nstatic int __maybe_unused gr2d_runtime_suspend(struct device *dev)\n{\n\tstruct gr2d *gr2d = dev_get_drvdata(dev);\n\tint err;\n\n\thost1x_channel_stop(gr2d->channel);\n\treset_control_bulk_release(gr2d->nresets, gr2d->resets);\n\n\t \n\terr = reset_control_acquire(gr2d->resets[RST_MC].rstc);\n\tif (err) {\n\t\tdev_err(dev, \"failed to acquire MC reset: %d\\n\", err);\n\t\tgoto acquire_reset;\n\t}\n\n\terr = reset_control_assert(gr2d->resets[RST_MC].rstc);\n\treset_control_release(gr2d->resets[RST_MC].rstc);\n\tif (err) {\n\t\tdev_err(dev, \"failed to assert MC reset: %d\\n\", err);\n\t\tgoto acquire_reset;\n\t}\n\n\tclk_disable_unprepare(gr2d->clk);\n\n\treturn 0;\n\nacquire_reset:\n\treset_control_bulk_acquire(gr2d->nresets, gr2d->resets);\n\treset_control_bulk_deassert(gr2d->nresets, gr2d->resets);\n\n\treturn err;\n}\n\nstatic int __maybe_unused gr2d_runtime_resume(struct device *dev)\n{\n\tstruct gr2d *gr2d = dev_get_drvdata(dev);\n\tint err;\n\n\terr = reset_control_bulk_acquire(gr2d->nresets, gr2d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to acquire reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(gr2d->clk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\tgoto release_reset;\n\t}\n\n\tusleep_range(2000, 4000);\n\n\t \n\terr = reset_control_bulk_deassert(gr2d->nresets, gr2d->resets);\n\tif (err) {\n\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 500);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(gr2d->clk);\nrelease_reset:\n\treset_control_bulk_release(gr2d->nresets, gr2d->resets);\n\n\treturn err;\n}\n\nstatic const struct dev_pm_ops tegra_gr2d_pm = {\n\tSET_RUNTIME_PM_OPS(gr2d_runtime_suspend, gr2d_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstruct platform_driver tegra_gr2d_driver = {\n\t.driver = {\n\t\t.name = \"tegra-gr2d\",\n\t\t.of_match_table = gr2d_match,\n\t\t.pm = &tegra_gr2d_pm,\n\t},\n\t.probe = gr2d_probe,\n\t.remove_new = gr2d_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}