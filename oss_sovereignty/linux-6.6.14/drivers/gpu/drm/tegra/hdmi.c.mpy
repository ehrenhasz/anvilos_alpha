{
  "module_name": "hdmi.c",
  "hash_id": "9b87d8c3274733e275692c03923ff70a98134057ee2187a054ffaad1121e2a1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/hdmi.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n#include <sound/hdmi-codec.h>\n\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"hda.h\"\n#include \"hdmi.h\"\n#include \"drm.h\"\n#include \"dc.h\"\n#include \"trace.h\"\n\n#define HDMI_ELD_BUFFER_SIZE 96\n\nstruct tmds_config {\n\tunsigned int pclk;\n\tu32 pll0;\n\tu32 pll1;\n\tu32 pe_current;\n\tu32 drive_current;\n\tu32 peak_current;\n};\n\nstruct tegra_hdmi_config {\n\tconst struct tmds_config *tmds;\n\tunsigned int num_tmds;\n\n\tunsigned long fuse_override_offset;\n\tu32 fuse_override_value;\n\n\tbool has_sor_io_peak_current;\n\tbool has_hda;\n\tbool has_hbr;\n};\n\nstruct tegra_hdmi {\n\tstruct host1x_client client;\n\tstruct tegra_output output;\n\tstruct device *dev;\n\n\tstruct regulator *hdmi;\n\tstruct regulator *pll;\n\tstruct regulator *vdd;\n\n\tvoid __iomem *regs;\n\tunsigned int irq;\n\n\tstruct clk *clk_parent;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\n\tconst struct tegra_hdmi_config *config;\n\n\tunsigned int audio_source;\n\tstruct tegra_hda_format format;\n\n\tunsigned int pixel_clock;\n\tbool stereo;\n\tbool dvi;\n\n\tstruct drm_info_list *debugfs_files;\n\n\tstruct platform_device *audio_pdev;\n\tstruct mutex audio_lock;\n};\n\nstatic inline struct tegra_hdmi *\nhost1x_client_to_hdmi(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_hdmi, client);\n}\n\nstatic inline struct tegra_hdmi *to_hdmi(struct tegra_output *output)\n{\n\treturn container_of(output, struct tegra_hdmi, output);\n}\n\n#define HDMI_AUDIOCLK_FREQ 216000000\n#define HDMI_REKEY_DEFAULT 56\n\nenum {\n\tAUTO = 0,\n\tSPDIF,\n\tHDA,\n};\n\nstatic inline u32 tegra_hdmi_readl(struct tegra_hdmi *hdmi,\n\t\t\t\t   unsigned int offset)\n{\n\tu32 value = readl(hdmi->regs + (offset << 2));\n\n\ttrace_hdmi_readl(hdmi->dev, offset, value);\n\n\treturn value;\n}\n\nstatic inline void tegra_hdmi_writel(struct tegra_hdmi *hdmi, u32 value,\n\t\t\t\t     unsigned int offset)\n{\n\ttrace_hdmi_writel(hdmi->dev, offset, value);\n\twritel(value, hdmi->regs + (offset << 2));\n}\n\nstruct tegra_hdmi_audio_config {\n\tunsigned int n;\n\tunsigned int cts;\n\tunsigned int aval;\n};\n\nstatic const struct tmds_config tegra20_tmds_config[] = {\n\t{  \n\t\t.pclk = 27000000,\n\t\t.pll0 = SOR_PLL_BG_V17_S(3) | SOR_PLL_ICHPMP(1) |\n\t\t\tSOR_PLL_RESISTORSEL | SOR_PLL_VCOCAP(0) |\n\t\t\tSOR_PLL_TX_REG_LOAD(3),\n\t\t.pll1 = SOR_PLL_TMDS_TERM_ENABLE,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_0_mA),\n\t\t.drive_current = DRIVE_CURRENT_LANE0(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE1(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE2(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE3(DRIVE_CURRENT_7_125_mA),\n\t},\n\t{  \n\t\t.pclk = UINT_MAX,\n\t\t.pll0 = SOR_PLL_BG_V17_S(3) | SOR_PLL_ICHPMP(1) |\n\t\t\tSOR_PLL_RESISTORSEL | SOR_PLL_VCOCAP(1) |\n\t\t\tSOR_PLL_TX_REG_LOAD(3),\n\t\t.pll1 = SOR_PLL_TMDS_TERM_ENABLE | SOR_PLL_PE_EN,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_6_0_mA) |\n\t\t\tPE_CURRENT1(PE_CURRENT_6_0_mA) |\n\t\t\tPE_CURRENT2(PE_CURRENT_6_0_mA) |\n\t\t\tPE_CURRENT3(PE_CURRENT_6_0_mA),\n\t\t.drive_current = DRIVE_CURRENT_LANE0(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE1(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE2(DRIVE_CURRENT_7_125_mA) |\n\t\t\tDRIVE_CURRENT_LANE3(DRIVE_CURRENT_7_125_mA),\n\t},\n};\n\nstatic const struct tmds_config tegra30_tmds_config[] = {\n\t{  \n\t\t.pclk = 27000000,\n\t\t.pll0 = SOR_PLL_BG_V17_S(3) | SOR_PLL_ICHPMP(1) |\n\t\t\tSOR_PLL_RESISTORSEL | SOR_PLL_VCOCAP(0) |\n\t\t\tSOR_PLL_TX_REG_LOAD(0),\n\t\t.pll1 = SOR_PLL_TMDS_TERM_ENABLE,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_0_mA) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_0_mA),\n\t\t.drive_current = DRIVE_CURRENT_LANE0(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE1(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE2(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE3(DRIVE_CURRENT_5_250_mA),\n\t}, {  \n\t\t.pclk = 74250000,\n\t\t.pll0 = SOR_PLL_BG_V17_S(3) | SOR_PLL_ICHPMP(1) |\n\t\t\tSOR_PLL_RESISTORSEL | SOR_PLL_VCOCAP(1) |\n\t\t\tSOR_PLL_TX_REG_LOAD(0),\n\t\t.pll1 = SOR_PLL_TMDS_TERM_ENABLE | SOR_PLL_PE_EN,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT1(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT2(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT3(PE_CURRENT_5_0_mA),\n\t\t.drive_current = DRIVE_CURRENT_LANE0(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE1(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE2(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE3(DRIVE_CURRENT_5_250_mA),\n\t}, {  \n\t\t.pclk = UINT_MAX,\n\t\t.pll0 = SOR_PLL_BG_V17_S(3) | SOR_PLL_ICHPMP(1) |\n\t\t\tSOR_PLL_RESISTORSEL | SOR_PLL_VCOCAP(3) |\n\t\t\tSOR_PLL_TX_REG_LOAD(0),\n\t\t.pll1 = SOR_PLL_TMDS_TERM_ENABLE | SOR_PLL_PE_EN,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT1(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT2(PE_CURRENT_5_0_mA) |\n\t\t\tPE_CURRENT3(PE_CURRENT_5_0_mA),\n\t\t.drive_current = DRIVE_CURRENT_LANE0(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE1(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE2(DRIVE_CURRENT_5_250_mA) |\n\t\t\tDRIVE_CURRENT_LANE3(DRIVE_CURRENT_5_250_mA),\n\t},\n};\n\nstatic const struct tmds_config tegra114_tmds_config[] = {\n\t{  \n\t\t.pclk = 27000000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(0) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_LOADADJ(3) | SOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_10_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = 74250000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(1) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_PE_EN | SOR_PLL_LOADADJ(3) |\n\t\t\tSOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_15_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_10_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = 148500000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(3) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_PE_EN | SOR_PLL_LOADADJ(3) |\n\t\t\tSOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_10_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_12_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = UINT_MAX,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(0xf) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_LOADADJ(3) | SOR_PLL_TMDS_TERMADJ(7)\n\t\t\t| SOR_PLL_TMDS_TERM_ENABLE,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_19_200_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_800_mA),\n\t},\n};\n\nstatic const struct tmds_config tegra124_tmds_config[] = {\n\t{  \n\t\t.pclk = 27000000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(0) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_LOADADJ(3) | SOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_10_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = 74250000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(1) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_PE_EN | SOR_PLL_LOADADJ(3) |\n\t\t\tSOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_15_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_15_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_10_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_10_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = 148500000,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(3) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_PE_EN | SOR_PLL_LOADADJ(3) |\n\t\t\tSOR_PLL_TMDS_TERMADJ(0),\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_10_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_10_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_12_400_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_12_400_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_0_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_000_mA),\n\t}, {  \n\t\t.pclk = UINT_MAX,\n\t\t.pll0 = SOR_PLL_ICHPMP(1) | SOR_PLL_BG_V17_S(3) |\n\t\t\tSOR_PLL_VCOCAP(0xf) | SOR_PLL_RESISTORSEL,\n\t\t.pll1 = SOR_PLL_LOADADJ(3) | SOR_PLL_TMDS_TERMADJ(7)\n\t\t\t| SOR_PLL_TMDS_TERM_ENABLE,\n\t\t.pe_current = PE_CURRENT0(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT1(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT2(PE_CURRENT_0_mA_T114) |\n\t\t\tPE_CURRENT3(PE_CURRENT_0_mA_T114),\n\t\t.drive_current =\n\t\t\tDRIVE_CURRENT_LANE0_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE1_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE2_T114(DRIVE_CURRENT_25_200_mA_T114) |\n\t\t\tDRIVE_CURRENT_LANE3_T114(DRIVE_CURRENT_19_200_mA_T114),\n\t\t.peak_current = PEAK_CURRENT_LANE0(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE1(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE2(PEAK_CURRENT_3_000_mA) |\n\t\t\tPEAK_CURRENT_LANE3(PEAK_CURRENT_0_800_mA),\n\t},\n};\n\nstatic void tegra_hdmi_audio_lock(struct tegra_hdmi *hdmi)\n{\n\tmutex_lock(&hdmi->audio_lock);\n\tdisable_irq(hdmi->irq);\n}\n\nstatic void tegra_hdmi_audio_unlock(struct tegra_hdmi *hdmi)\n{\n\tenable_irq(hdmi->irq);\n\tmutex_unlock(&hdmi->audio_lock);\n}\n\nstatic int\ntegra_hdmi_get_audio_config(unsigned int audio_freq, unsigned int pix_clock,\n\t\t\t    struct tegra_hdmi_audio_config *config)\n{\n\tconst unsigned int afreq = 128 * audio_freq;\n\tconst unsigned int min_n = afreq / 1500;\n\tconst unsigned int max_n = afreq / 300;\n\tconst unsigned int ideal_n = afreq / 1000;\n\tint64_t min_err = (uint64_t)-1 >> 1;\n\tunsigned int min_delta = -1;\n\tint n;\n\n\tmemset(config, 0, sizeof(*config));\n\tconfig->n = -1;\n\n\tfor (n = min_n; n <= max_n; n++) {\n\t\tuint64_t cts_f, aval_f;\n\t\tunsigned int delta;\n\t\tint64_t cts, err;\n\n\t\t \n\t\taval_f = ((int64_t)24000000 << 16) * n;\n\t\tdo_div(aval_f, afreq);\n\t\t \n\t\tif (aval_f & 0xFFFF)\n\t\t\tcontinue;\n\n\t\t \n\t\tcts_f = ((int64_t)pix_clock << 16) * n;\n\t\tdo_div(cts_f, afreq);\n\t\t \n\t\tcts = (cts_f & ~0xFFFF) + ((cts_f & BIT(15)) << 1);\n\n\t\tdelta = abs(n - ideal_n);\n\n\t\t \n\t\terr = abs((int64_t)cts_f - cts);\n\t\tif (err < min_err || (err == min_err && delta < min_delta)) {\n\t\t\tconfig->n = n;\n\t\t\tconfig->cts = cts >> 16;\n\t\t\tconfig->aval = aval_f >> 16;\n\t\t\tmin_delta = delta;\n\t\t\tmin_err = err;\n\t\t}\n\t}\n\n\treturn config->n != -1 ? 0 : -EINVAL;\n}\n\nstatic void tegra_hdmi_setup_audio_fs_tables(struct tegra_hdmi *hdmi)\n{\n\tconst unsigned int freqs[] = {\n\t\t32000, 44100, 48000, 88200, 96000, 176400, 192000\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(freqs); i++) {\n\t\tunsigned int f = freqs[i];\n\t\tunsigned int eight_half;\n\t\tunsigned int delta;\n\t\tu32 value;\n\n\t\tif (f > 96000)\n\t\t\tdelta = 2;\n\t\telse if (f > 48000)\n\t\t\tdelta = 6;\n\t\telse\n\t\t\tdelta = 9;\n\n\t\teight_half = (8 * HDMI_AUDIOCLK_FREQ) / (f * 128);\n\t\tvalue = AUDIO_FS_LOW(eight_half - delta) |\n\t\t\tAUDIO_FS_HIGH(eight_half + delta);\n\t\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_AUDIO_FS(i));\n\t}\n}\n\nstatic void tegra_hdmi_write_aval(struct tegra_hdmi *hdmi, u32 value)\n{\n\tstatic const struct {\n\t\tunsigned int sample_rate;\n\t\tunsigned int offset;\n\t} regs[] = {\n\t\t{  32000, HDMI_NV_PDISP_SOR_AUDIO_AVAL_0320 },\n\t\t{  44100, HDMI_NV_PDISP_SOR_AUDIO_AVAL_0441 },\n\t\t{  48000, HDMI_NV_PDISP_SOR_AUDIO_AVAL_0480 },\n\t\t{  88200, HDMI_NV_PDISP_SOR_AUDIO_AVAL_0882 },\n\t\t{  96000, HDMI_NV_PDISP_SOR_AUDIO_AVAL_0960 },\n\t\t{ 176400, HDMI_NV_PDISP_SOR_AUDIO_AVAL_1764 },\n\t\t{ 192000, HDMI_NV_PDISP_SOR_AUDIO_AVAL_1920 },\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\tif (regs[i].sample_rate == hdmi->format.sample_rate) {\n\t\t\ttegra_hdmi_writel(hdmi, value, regs[i].offset);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int tegra_hdmi_setup_audio(struct tegra_hdmi *hdmi)\n{\n\tstruct tegra_hdmi_audio_config config;\n\tu32 source, value;\n\tint err;\n\n\tswitch (hdmi->audio_source) {\n\tcase HDA:\n\t\tif (hdmi->config->has_hda)\n\t\t\tsource = SOR_AUDIO_CNTRL0_SOURCE_SELECT_HDAL;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase SPDIF:\n\t\tif (hdmi->config->has_hda)\n\t\t\tsource = SOR_AUDIO_CNTRL0_SOURCE_SELECT_SPDIF;\n\t\telse\n\t\t\tsource = AUDIO_CNTRL0_SOURCE_SELECT_SPDIF;\n\t\tbreak;\n\n\tdefault:\n\t\tif (hdmi->config->has_hda)\n\t\t\tsource = SOR_AUDIO_CNTRL0_SOURCE_SELECT_AUTO;\n\t\telse\n\t\t\tsource = AUDIO_CNTRL0_SOURCE_SELECT_AUTO;\n\t\tbreak;\n\t}\n\n\t \n\tif (hdmi->config->has_hda) {\n\t\t \n\t\tif (hdmi->format.channels == 2)\n\t\t\tvalue = SOR_AUDIO_CNTRL0_INJECT_NULLSMPL;\n\t\telse\n\t\t\tvalue = 0;\n\n\t\tvalue |= source;\n\n\t\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_AUDIO_CNTRL0);\n\t}\n\n\t \n\tvalue = AUDIO_CNTRL0_FRAMES_PER_BLOCK(0xc0) |\n\t\tAUDIO_CNTRL0_ERROR_TOLERANCE(6);\n\n\tif (!hdmi->config->has_hda)\n\t\tvalue |= source;\n\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_AUDIO_CNTRL0);\n\n\t \n\tif (hdmi->config->has_hbr) {\n\t\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_AUDIO_SPARE0);\n\t\tvalue |= SOR_AUDIO_SPARE0_HBR_ENABLE;\n\t\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_AUDIO_SPARE0);\n\t}\n\n\terr = tegra_hdmi_get_audio_config(hdmi->format.sample_rate,\n\t\t\t\t\t  hdmi->pixel_clock, &config);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev,\n\t\t\t\"cannot set audio to %u Hz at %u Hz pixel clock\\n\",\n\t\t\thdmi->format.sample_rate, hdmi->pixel_clock);\n\t\treturn err;\n\t}\n\n\tdev_dbg(hdmi->dev, \"audio: pixclk=%u, n=%u, cts=%u, aval=%u\\n\",\n\t\thdmi->pixel_clock, config.n, config.cts, config.aval);\n\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_HDMI_ACR_CTRL);\n\n\tvalue = AUDIO_N_RESETF | AUDIO_N_GENERATE_ALTERNATE |\n\t\tAUDIO_N_VALUE(config.n - 1);\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_AUDIO_N);\n\n\ttegra_hdmi_writel(hdmi, ACR_SUBPACK_N(config.n) | ACR_ENABLE,\n\t\t\t  HDMI_NV_PDISP_HDMI_ACR_0441_SUBPACK_HIGH);\n\n\ttegra_hdmi_writel(hdmi, ACR_SUBPACK_CTS(config.cts),\n\t\t\t  HDMI_NV_PDISP_HDMI_ACR_0441_SUBPACK_LOW);\n\n\tvalue = SPARE_HW_CTS | SPARE_FORCE_SW_CTS | SPARE_CTS_RESET_VAL(1);\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_SPARE);\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_AUDIO_N);\n\tvalue &= ~AUDIO_N_RESETF;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_AUDIO_N);\n\n\tif (hdmi->config->has_hda)\n\t\ttegra_hdmi_write_aval(hdmi, config.aval);\n\n\ttegra_hdmi_setup_audio_fs_tables(hdmi);\n\n\treturn 0;\n}\n\nstatic void tegra_hdmi_disable_audio(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n\tvalue &= ~GENERIC_CTRL_AUDIO;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n}\n\nstatic void tegra_hdmi_enable_audio(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n\tvalue |= GENERIC_CTRL_AUDIO;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n}\n\nstatic void tegra_hdmi_write_eld(struct tegra_hdmi *hdmi)\n{\n\tsize_t length = drm_eld_size(hdmi->output.connector.eld), i;\n\tu32 value;\n\n\tfor (i = 0; i < length; i++)\n\t\ttegra_hdmi_writel(hdmi, i << 8 | hdmi->output.connector.eld[i],\n\t\t\t\t  HDMI_NV_PDISP_SOR_AUDIO_HDA_ELD_BUFWR);\n\n\t \n\tfor (i = length; i < HDMI_ELD_BUFFER_SIZE; i++)\n\t\ttegra_hdmi_writel(hdmi, i << 8 | 0,\n\t\t\t\t  HDMI_NV_PDISP_SOR_AUDIO_HDA_ELD_BUFWR);\n\n\tvalue = SOR_AUDIO_HDA_PRESENSE_VALID | SOR_AUDIO_HDA_PRESENSE_PRESENT;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_AUDIO_HDA_PRESENSE);\n}\n\nstatic inline u32 tegra_hdmi_subpack(const u8 *ptr, size_t size)\n{\n\tu32 value = 0;\n\tsize_t i;\n\n\tfor (i = size; i > 0; i--)\n\t\tvalue = (value << 8) | ptr[i - 1];\n\n\treturn value;\n}\n\nstatic void tegra_hdmi_write_infopack(struct tegra_hdmi *hdmi, const void *data,\n\t\t\t\t      size_t size)\n{\n\tconst u8 *ptr = data;\n\tunsigned long offset;\n\tsize_t i, j;\n\tu32 value;\n\n\tswitch (ptr[0]) {\n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\toffset = HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_HEADER;\n\t\tbreak;\n\n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\toffset = HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_HEADER;\n\t\tbreak;\n\n\tcase HDMI_INFOFRAME_TYPE_VENDOR:\n\t\toffset = HDMI_NV_PDISP_HDMI_GENERIC_HEADER;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdmi->dev, \"unsupported infoframe type: %02x\\n\",\n\t\t\tptr[0]);\n\t\treturn;\n\t}\n\n\tvalue = INFOFRAME_HEADER_TYPE(ptr[0]) |\n\t\tINFOFRAME_HEADER_VERSION(ptr[1]) |\n\t\tINFOFRAME_HEADER_LEN(ptr[2]);\n\ttegra_hdmi_writel(hdmi, value, offset);\n\toffset++;\n\n\t \n\tfor (i = 3, j = 0; i < size; i += 7, j += 8) {\n\t\tsize_t rem = size - i, num = min_t(size_t, rem, 4);\n\n\t\tvalue = tegra_hdmi_subpack(&ptr[i], num);\n\t\ttegra_hdmi_writel(hdmi, value, offset++);\n\n\t\tnum = min_t(size_t, rem - num, 3);\n\n\t\tvalue = tegra_hdmi_subpack(&ptr[i + 4], num);\n\t\ttegra_hdmi_writel(hdmi, value, offset++);\n\t}\n}\n\nstatic void tegra_hdmi_setup_avi_infoframe(struct tegra_hdmi *hdmi,\n\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct hdmi_avi_infoframe frame;\n\tu8 buffer[17];\n\tssize_t err;\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       &hdmi->output.connector, mode);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to setup AVI infoframe: %zd\\n\", err);\n\t\treturn;\n\t}\n\n\terr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to pack AVI infoframe: %zd\\n\", err);\n\t\treturn;\n\t}\n\n\ttegra_hdmi_write_infopack(hdmi, buffer, err);\n}\n\nstatic void tegra_hdmi_disable_avi_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL);\n\tvalue &= ~INFOFRAME_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL);\n}\n\nstatic void tegra_hdmi_enable_avi_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL);\n\tvalue |= INFOFRAME_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL);\n}\n\nstatic void tegra_hdmi_setup_audio_infoframe(struct tegra_hdmi *hdmi)\n{\n\tstruct hdmi_audio_infoframe frame;\n\tu8 buffer[14];\n\tssize_t err;\n\n\terr = hdmi_audio_infoframe_init(&frame);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to setup audio infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\tframe.channels = hdmi->format.channels;\n\n\terr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to pack audio infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\t \n\ttegra_hdmi_write_infopack(hdmi, buffer, min_t(size_t, 10, err));\n}\n\nstatic void tegra_hdmi_disable_audio_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_CTRL);\n\tvalue &= ~INFOFRAME_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_CTRL);\n}\n\nstatic void tegra_hdmi_enable_audio_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_CTRL);\n\tvalue |= INFOFRAME_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_CTRL);\n}\n\nstatic void tegra_hdmi_setup_stereo_infoframe(struct tegra_hdmi *hdmi)\n{\n\tstruct hdmi_vendor_infoframe frame;\n\tu8 buffer[10];\n\tssize_t err;\n\n\thdmi_vendor_infoframe_init(&frame);\n\tframe.s3d_struct = HDMI_3D_STRUCTURE_FRAME_PACKING;\n\n\terr = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to pack vendor infoframe: %zd\\n\",\n\t\t\terr);\n\t\treturn;\n\t}\n\n\ttegra_hdmi_write_infopack(hdmi, buffer, err);\n}\n\nstatic void tegra_hdmi_disable_stereo_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n\tvalue &= ~GENERIC_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n}\n\nstatic void tegra_hdmi_enable_stereo_infoframe(struct tegra_hdmi *hdmi)\n{\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n\tvalue |= GENERIC_CTRL_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_GENERIC_CTRL);\n}\n\nstatic void tegra_hdmi_setup_tmds(struct tegra_hdmi *hdmi,\n\t\t\t\t  const struct tmds_config *tmds)\n{\n\tu32 value;\n\n\ttegra_hdmi_writel(hdmi, tmds->pll0, HDMI_NV_PDISP_SOR_PLL0);\n\ttegra_hdmi_writel(hdmi, tmds->pll1, HDMI_NV_PDISP_SOR_PLL1);\n\ttegra_hdmi_writel(hdmi, tmds->pe_current, HDMI_NV_PDISP_PE_CURRENT);\n\n\ttegra_hdmi_writel(hdmi, tmds->drive_current,\n\t\t\t  HDMI_NV_PDISP_SOR_LANE_DRIVE_CURRENT);\n\n\tvalue = tegra_hdmi_readl(hdmi, hdmi->config->fuse_override_offset);\n\tvalue |= hdmi->config->fuse_override_value;\n\ttegra_hdmi_writel(hdmi, value, hdmi->config->fuse_override_offset);\n\n\tif (hdmi->config->has_sor_io_peak_current)\n\t\ttegra_hdmi_writel(hdmi, tmds->peak_current,\n\t\t\t\t  HDMI_NV_PDISP_SOR_IO_PEAK_CURRENT);\n}\n\nstatic int tegra_hdmi_reconfigure_audio(struct tegra_hdmi *hdmi)\n{\n\tint err;\n\n\terr = tegra_hdmi_setup_audio(hdmi);\n\tif (err < 0) {\n\t\ttegra_hdmi_disable_audio_infoframe(hdmi);\n\t\ttegra_hdmi_disable_audio(hdmi);\n\t} else {\n\t\ttegra_hdmi_setup_audio_infoframe(hdmi);\n\t\ttegra_hdmi_enable_audio_infoframe(hdmi);\n\t\ttegra_hdmi_enable_audio(hdmi);\n\t}\n\n\treturn err;\n}\n\nstatic bool tegra_output_is_hdmi(struct tegra_output *output)\n{\n\treturn output->connector.display_info.is_hdmi;\n}\n\nstatic enum drm_connector_status\ntegra_hdmi_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\tenum drm_connector_status status;\n\n\tstatus = tegra_output_connector_detect(connector, force);\n\tif (status == connector_status_connected)\n\t\treturn status;\n\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_SOR_AUDIO_HDA_PRESENSE);\n\treturn status;\n}\n\n#define DEBUGFS_REG32(_name) { .name = #_name, .offset = _name }\n\nstatic const struct debugfs_reg32 tegra_hdmi_regs[] = {\n\tDEBUGFS_REG32(HDMI_CTXSW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_STATE0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_STATE1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_STATE2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_AN_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_AN_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CN_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CN_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_AKSV_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_AKSV_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_BKSV_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_BKSV_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CKSV_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CKSV_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_DKSV_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_DKSV_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CMODE),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_MPRIME_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_MPRIME_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_SPRIME_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_SPRIME_LSB2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_SPRIME_LSB1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_RI),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CS_MSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_RG_HDCP_CS_LSB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_EMU0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_EMU_RDATA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_EMU1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_EMU2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_STATUS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_HEADER),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_SUBPACK0_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AUDIO_INFOFRAME_SUBPACK0_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_STATUS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_HEADER),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_SUBPACK0_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_SUBPACK0_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_SUBPACK1_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_AVI_INFOFRAME_SUBPACK1_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_STATUS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_HEADER),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK0_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK0_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK1_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK1_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK2_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK2_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK3_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GENERIC_SUBPACK3_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0320_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0320_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0441_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0441_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0882_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0882_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_1764_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_1764_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0480_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0480_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0960_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_0960_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_1920_SUBPACK_LOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_ACR_1920_SUBPACK_HIGH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_VSYNC_KEEPOUT),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_VSYNC_WINDOW),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GCP_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GCP_STATUS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_GCP_SUBPACK),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_CHANNEL_STATUS1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_CHANNEL_STATUS2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_EMU0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_EMU1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_EMU1_RDATA),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_SPARE),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_SPDIF_CHN_STATUS1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_SPDIF_CHN_STATUS2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDMI_HDCPRIF_ROM_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CAP),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_PWR),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_TEST),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_PLL0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_PLL1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_PLL2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CSTM),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_LVDS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CRCA),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CRCB),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_BLANK),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_CTL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(0)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(1)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(2)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(3)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(4)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(5)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(6)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(7)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(8)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(9)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(10)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(11)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(12)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(13)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(14)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_SEQ_INST(15)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_VCRCA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_VCRCA1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CCRCA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_CCRCA1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_EDATAA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_EDATAA1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_COUNTA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_COUNTA1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_DEBUGA0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_DEBUGA1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_TRIG),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_MSCHECK),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_LANE_DRIVE_CURRENT),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_DEBUG0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_DEBUG1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_DEBUG2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(0)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(1)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(2)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(3)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(4)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(5)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_FS(6)),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_PULSE_WIDTH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_THRESHOLD),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_CNTRL0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_AUDIO_N),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_HDCPRIF_ROM_TIMING),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_REFCLK),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_CRC_CONTROL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_INPUT_CONTROL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SCRATCH),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_PE_CURRENT),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_CTRL),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_DEBUG0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_DEBUG1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_DEBUG2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_HDCP_KEY_0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_HDCP_KEY_1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_HDCP_KEY_2),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_HDCP_KEY_3),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_HDCP_KEY_TRIG),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_KEY_SKEY_INDEX),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_CNTRL0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_SPARE0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_HDA_CODEC_SCRATCH0),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_HDA_CODEC_SCRATCH1),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_HDA_ELD_BUFWR),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_AUDIO_HDA_PRESENSE),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_INT_STATUS),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_INT_MASK),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_INT_ENABLE),\n\tDEBUGFS_REG32(HDMI_NV_PDISP_SOR_IO_PEAK_CURRENT),\n};\n\nstatic int tegra_hdmi_show_regs(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_hdmi *hdmi = node->info_ent->data;\n\tstruct drm_crtc *crtc = hdmi->output.encoder.crtc;\n\tstruct drm_device *drm = node->minor->dev;\n\tunsigned int i;\n\tint err = 0;\n\n\tdrm_modeset_lock_all(drm);\n\n\tif (!crtc || !crtc->state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_hdmi_regs); i++) {\n\t\tunsigned int offset = tegra_hdmi_regs[i].offset;\n\n\t\tseq_printf(s, \"%-56s %#05x %08x\\n\", tegra_hdmi_regs[i].name,\n\t\t\t   offset, tegra_hdmi_readl(hdmi, offset));\n\t}\n\nunlock:\n\tdrm_modeset_unlock_all(drm);\n\treturn err;\n}\n\nstatic struct drm_info_list debugfs_files[] = {\n\t{ \"regs\", tegra_hdmi_show_regs, 0, NULL },\n};\n\nstatic int tegra_hdmi_late_register(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tunsigned int i, count = ARRAY_SIZE(debugfs_files);\n\tstruct drm_minor *minor = connector->dev->primary;\n\tstruct dentry *root = connector->debugfs_entry;\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\n\thdmi->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdmi->debugfs_files)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++)\n\t\thdmi->debugfs_files[i].data = hdmi;\n\n\tdrm_debugfs_create_files(hdmi->debugfs_files, count, root, minor);\n\n\treturn 0;\n}\n\nstatic void tegra_hdmi_early_unregister(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct drm_minor *minor = connector->dev->primary;\n\tunsigned int count = ARRAY_SIZE(debugfs_files);\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\n\tdrm_debugfs_remove_files(hdmi->debugfs_files, count, minor);\n\tkfree(hdmi->debugfs_files);\n\thdmi->debugfs_files = NULL;\n}\n\nstatic const struct drm_connector_funcs tegra_hdmi_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.detect = tegra_hdmi_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = tegra_output_connector_destroy,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = tegra_hdmi_late_register,\n\t.early_unregister = tegra_hdmi_early_unregister,\n};\n\nstatic enum drm_mode_status\ntegra_hdmi_connector_mode_valid(struct drm_connector *connector,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\tunsigned long pclk = mode->clock * 1000;\n\tenum drm_mode_status status = MODE_OK;\n\tstruct clk *parent;\n\tlong err;\n\n\tparent = clk_get_parent(hdmi->clk_parent);\n\n\terr = clk_round_rate(parent, pclk * 4);\n\tif (err <= 0)\n\t\tstatus = MODE_NOCLOCK;\n\n\treturn status;\n}\n\nstatic const struct drm_connector_helper_funcs\ntegra_hdmi_connector_helper_funcs = {\n\t.get_modes = tegra_output_connector_get_modes,\n\t.mode_valid = tegra_hdmi_connector_mode_valid,\n};\n\nstatic void tegra_hdmi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\tu32 value;\n\tint err;\n\n\ttegra_hdmi_audio_lock(hdmi);\n\n\t \n\tif (dc) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\t\tvalue &= ~HDMI_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\t\ttegra_dc_commit(dc);\n\t}\n\n\tif (!hdmi->dvi) {\n\t\tif (hdmi->stereo)\n\t\t\ttegra_hdmi_disable_stereo_infoframe(hdmi);\n\n\t\ttegra_hdmi_disable_audio_infoframe(hdmi);\n\t\ttegra_hdmi_disable_avi_infoframe(hdmi);\n\t\ttegra_hdmi_disable_audio(hdmi);\n\t}\n\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_INT_ENABLE);\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_INT_MASK);\n\n\thdmi->pixel_clock = 0;\n\n\ttegra_hdmi_audio_unlock(hdmi);\n\n\terr = host1x_client_suspend(&hdmi->client);\n\tif (err < 0)\n\t\tdev_err(hdmi->dev, \"failed to suspend: %d\\n\", err);\n}\n\nstatic void tegra_hdmi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tunsigned int h_sync_width, h_front_porch, h_back_porch, i, rekey;\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\tunsigned int pulse_start, div82;\n\tint retries = 1000;\n\tu32 value;\n\tint err;\n\n\terr = host1x_client_resume(&hdmi->client);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to resume: %d\\n\", err);\n\t\treturn;\n\t}\n\n\ttegra_hdmi_audio_lock(hdmi);\n\n\t \n\ttegra_hdmi_writel(hdmi, INT_CODEC_SCRATCH0, HDMI_NV_PDISP_INT_ENABLE);\n\ttegra_hdmi_writel(hdmi, INT_CODEC_SCRATCH0, HDMI_NV_PDISP_INT_MASK);\n\n\thdmi->pixel_clock = mode->clock * 1000;\n\th_sync_width = mode->hsync_end - mode->hsync_start;\n\th_back_porch = mode->htotal - mode->hsync_end;\n\th_front_porch = mode->hsync_start - mode->hdisplay;\n\n\terr = dev_pm_opp_set_rate(hdmi->dev, hdmi->pixel_clock);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to set HDMI clock frequency: %d\\n\",\n\t\t\terr);\n\t}\n\n\tDRM_DEBUG_KMS(\"HDMI clock rate: %lu Hz\\n\", clk_get_rate(hdmi->clk));\n\n\t \n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_PLL0);\n\tvalue &= ~SOR_PLL_PDBG;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_PLL0);\n\n\tusleep_range(10, 20);\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_PLL0);\n\tvalue &= ~SOR_PLL_PWR;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_PLL0);\n\n\ttegra_dc_writel(dc, VSYNC_H_POSITION(1),\n\t\t\tDC_DISP_DISP_TIMING_OPTIONS);\n\ttegra_dc_writel(dc, DITHER_CONTROL_DISABLE | BASE_COLOR_SIZE_888,\n\t\t\tDC_DISP_DISP_COLOR_CONTROL);\n\n\t \n\tpulse_start = 1 + h_sync_width + h_back_porch - 10;\n\n\ttegra_dc_writel(dc, H_PULSE2_ENABLE, DC_DISP_DISP_SIGNAL_OPTIONS0);\n\n\tvalue = PULSE_MODE_NORMAL | PULSE_POLARITY_HIGH | PULSE_QUAL_VACTIVE |\n\t\tPULSE_LAST_END_A;\n\ttegra_dc_writel(dc, value, DC_DISP_H_PULSE2_CONTROL);\n\n\tvalue = PULSE_START(pulse_start) | PULSE_END(pulse_start + 8);\n\ttegra_dc_writel(dc, value, DC_DISP_H_PULSE2_POSITION_A);\n\n\tvalue = VSYNC_WINDOW_END(0x210) | VSYNC_WINDOW_START(0x200) |\n\t\tVSYNC_WINDOW_ENABLE;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_VSYNC_WINDOW);\n\n\tif (dc->pipe)\n\t\tvalue = HDMI_SRC_DISPLAYB;\n\telse\n\t\tvalue = HDMI_SRC_DISPLAYA;\n\n\tif ((mode->hdisplay == 720) && ((mode->vdisplay == 480) ||\n\t\t\t\t\t(mode->vdisplay == 576)))\n\t\ttegra_hdmi_writel(hdmi,\n\t\t\t\t  value | ARM_VIDEO_RANGE_FULL,\n\t\t\t\t  HDMI_NV_PDISP_INPUT_CONTROL);\n\telse\n\t\ttegra_hdmi_writel(hdmi,\n\t\t\t\t  value | ARM_VIDEO_RANGE_LIMITED,\n\t\t\t\t  HDMI_NV_PDISP_INPUT_CONTROL);\n\n\tdiv82 = clk_get_rate(hdmi->clk) / 1000000 * 4;\n\tvalue = SOR_REFCLK_DIV_INT(div82 >> 2) | SOR_REFCLK_DIV_FRAC(div82);\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_REFCLK);\n\n\thdmi->dvi = !tegra_output_is_hdmi(output);\n\tif (!hdmi->dvi) {\n\t\t \n\t\tif (hdmi->format.sample_rate > 0) {\n\t\t\terr = tegra_hdmi_setup_audio(hdmi);\n\t\t\tif (err < 0)\n\t\t\t\thdmi->dvi = true;\n\t\t}\n\t}\n\n\tif (hdmi->config->has_hda)\n\t\ttegra_hdmi_write_eld(hdmi);\n\n\trekey = HDMI_REKEY_DEFAULT;\n\tvalue = HDMI_CTRL_REKEY(rekey);\n\tvalue |= HDMI_CTRL_MAX_AC_PACKET((h_sync_width + h_back_porch +\n\t\t\t\t\t  h_front_porch - rekey - 18) / 32);\n\n\tif (!hdmi->dvi)\n\t\tvalue |= HDMI_CTRL_ENABLE;\n\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_HDMI_CTRL);\n\n\tif (!hdmi->dvi) {\n\t\ttegra_hdmi_setup_avi_infoframe(hdmi, mode);\n\t\ttegra_hdmi_setup_audio_infoframe(hdmi);\n\n\t\tif (hdmi->stereo)\n\t\t\ttegra_hdmi_setup_stereo_infoframe(hdmi);\n\t}\n\n\t \n\tfor (i = 0; i < hdmi->config->num_tmds; i++) {\n\t\tif (hdmi->pixel_clock <= hdmi->config->tmds[i].pclk) {\n\t\t\ttegra_hdmi_setup_tmds(hdmi, &hdmi->config->tmds[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttegra_hdmi_writel(hdmi,\n\t\t\t  SOR_SEQ_PU_PC(0) |\n\t\t\t  SOR_SEQ_PU_PC_ALT(0) |\n\t\t\t  SOR_SEQ_PD_PC(8) |\n\t\t\t  SOR_SEQ_PD_PC_ALT(8),\n\t\t\t  HDMI_NV_PDISP_SOR_SEQ_CTL);\n\n\tvalue = SOR_SEQ_INST_WAIT_TIME(1) |\n\t\tSOR_SEQ_INST_WAIT_UNITS_VSYNC |\n\t\tSOR_SEQ_INST_HALT |\n\t\tSOR_SEQ_INST_PIN_A_LOW |\n\t\tSOR_SEQ_INST_PIN_B_LOW |\n\t\tSOR_SEQ_INST_DRIVE_PWM_OUT_LO;\n\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_SEQ_INST(0));\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_SEQ_INST(8));\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_CSTM);\n\tvalue &= ~SOR_CSTM_ROTCLK(~0);\n\tvalue |= SOR_CSTM_ROTCLK(2);\n\tvalue |= SOR_CSTM_PLLDIV;\n\tvalue &= ~SOR_CSTM_LVDS_ENABLE;\n\tvalue &= ~SOR_CSTM_MODE_MASK;\n\tvalue |= SOR_CSTM_MODE_TMDS;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_CSTM);\n\n\t \n\ttegra_hdmi_writel(hdmi,\n\t\t\t  SOR_PWR_NORMAL_STATE_PU |\n\t\t\t  SOR_PWR_NORMAL_START_NORMAL |\n\t\t\t  SOR_PWR_SAFE_STATE_PD |\n\t\t\t  SOR_PWR_SETTING_NEW_TRIGGER,\n\t\t\t  HDMI_NV_PDISP_SOR_PWR);\n\ttegra_hdmi_writel(hdmi,\n\t\t\t  SOR_PWR_NORMAL_STATE_PU |\n\t\t\t  SOR_PWR_NORMAL_START_NORMAL |\n\t\t\t  SOR_PWR_SAFE_STATE_PD |\n\t\t\t  SOR_PWR_SETTING_NEW_DONE,\n\t\t\t  HDMI_NV_PDISP_SOR_PWR);\n\n\tdo {\n\t\tBUG_ON(--retries < 0);\n\t\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_PWR);\n\t} while (value & SOR_PWR_SETTING_NEW_PENDING);\n\n\tvalue = SOR_STATE_ASY_CRCMODE_COMPLETE |\n\t\tSOR_STATE_ASY_OWNER_HEAD0 |\n\t\tSOR_STATE_ASY_SUBOWNER_BOTH |\n\t\tSOR_STATE_ASY_PROTOCOL_SINGLE_TMDS_A |\n\t\tSOR_STATE_ASY_DEPOL_POS;\n\n\t \n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tvalue |= SOR_STATE_ASY_HSYNCPOL_POS;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tvalue |= SOR_STATE_ASY_HSYNCPOL_NEG;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tvalue |= SOR_STATE_ASY_VSYNCPOL_POS;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tvalue |= SOR_STATE_ASY_VSYNCPOL_NEG;\n\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_STATE2);\n\n\tvalue = SOR_STATE_ASY_HEAD_OPMODE_AWAKE | SOR_STATE_ASY_ORMODE_NORMAL;\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_SOR_STATE1);\n\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_SOR_STATE0);\n\ttegra_hdmi_writel(hdmi, SOR_STATE_UPDATE, HDMI_NV_PDISP_SOR_STATE0);\n\ttegra_hdmi_writel(hdmi, value | SOR_STATE_ATTACHED,\n\t\t\t  HDMI_NV_PDISP_SOR_STATE1);\n\ttegra_hdmi_writel(hdmi, 0, HDMI_NV_PDISP_SOR_STATE0);\n\n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue |= HDMI_ENABLE;\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\ttegra_dc_commit(dc);\n\n\tif (!hdmi->dvi) {\n\t\ttegra_hdmi_enable_avi_infoframe(hdmi);\n\t\ttegra_hdmi_enable_audio_infoframe(hdmi);\n\t\ttegra_hdmi_enable_audio(hdmi);\n\n\t\tif (hdmi->stereo)\n\t\t\ttegra_hdmi_enable_stereo_infoframe(hdmi);\n\t}\n\n\t \n\n\ttegra_hdmi_audio_unlock(hdmi);\n}\n\nstatic int\ntegra_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\n\tunsigned long pclk = crtc_state->mode.clock * 1000;\n\tstruct tegra_hdmi *hdmi = to_hdmi(output);\n\tint err;\n\n\terr = tegra_dc_state_setup_clock(dc, crtc_state, hdmi->clk_parent,\n\t\t\t\t\t pclk, 0);\n\tif (err < 0) {\n\t\tdev_err(output->dev, \"failed to setup CRTC state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic const struct drm_encoder_helper_funcs tegra_hdmi_encoder_helper_funcs = {\n\t.disable = tegra_hdmi_encoder_disable,\n\t.enable = tegra_hdmi_encoder_enable,\n\t.atomic_check = tegra_hdmi_encoder_atomic_check,\n};\n\nstatic int tegra_hdmi_hw_params(struct device *dev, void *data,\n\t\t\t\tstruct hdmi_codec_daifmt *fmt,\n\t\t\t\tstruct hdmi_codec_params *hparms)\n{\n\tstruct tegra_hdmi *hdmi = data;\n\tint ret = 0;\n\n\ttegra_hdmi_audio_lock(hdmi);\n\n\thdmi->format.sample_rate = hparms->sample_rate;\n\thdmi->format.channels = hparms->channels;\n\n\tif (hdmi->pixel_clock && !hdmi->dvi)\n\t\tret = tegra_hdmi_reconfigure_audio(hdmi);\n\n\ttegra_hdmi_audio_unlock(hdmi);\n\n\treturn ret;\n}\n\nstatic int tegra_hdmi_audio_startup(struct device *dev, void *data)\n{\n\tstruct tegra_hdmi *hdmi = data;\n\tint ret;\n\n\tret = host1x_client_resume(&hdmi->client);\n\tif (ret < 0)\n\t\tdev_err(hdmi->dev, \"failed to resume: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void tegra_hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct tegra_hdmi *hdmi = data;\n\tint ret;\n\n\ttegra_hdmi_audio_lock(hdmi);\n\n\thdmi->format.sample_rate = 0;\n\thdmi->format.channels = 0;\n\n\ttegra_hdmi_audio_unlock(hdmi);\n\n\tret = host1x_client_suspend(&hdmi->client);\n\tif (ret < 0)\n\t\tdev_err(hdmi->dev, \"failed to suspend: %d\\n\", ret);\n}\n\nstatic const struct hdmi_codec_ops tegra_hdmi_codec_ops = {\n\t.hw_params = tegra_hdmi_hw_params,\n\t.audio_startup = tegra_hdmi_audio_startup,\n\t.audio_shutdown = tegra_hdmi_audio_shutdown,\n};\n\nstatic int tegra_hdmi_codec_register(struct tegra_hdmi *hdmi)\n{\n\tstruct hdmi_codec_pdata codec_data = {};\n\n\tif (hdmi->config->has_hda)\n\t\treturn 0;\n\n\tcodec_data.ops = &tegra_hdmi_codec_ops;\n\tcodec_data.data = hdmi;\n\tcodec_data.spdif = 1;\n\n\thdmi->audio_pdev = platform_device_register_data(hdmi->dev,\n\t\t\t\t\t\t\t HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t\t PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t &codec_data,\n\t\t\t\t\t\t\t sizeof(codec_data));\n\tif (IS_ERR(hdmi->audio_pdev))\n\t\treturn PTR_ERR(hdmi->audio_pdev);\n\n\thdmi->format.channels = 2;\n\n\treturn 0;\n}\n\nstatic void tegra_hdmi_codec_unregister(struct tegra_hdmi *hdmi)\n{\n\tif (hdmi->audio_pdev)\n\t\tplatform_device_unregister(hdmi->audio_pdev);\n}\n\nstatic int tegra_hdmi_init(struct host1x_client *client)\n{\n\tstruct tegra_hdmi *hdmi = host1x_client_to_hdmi(client);\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct drm_connector *connector;\n\tint err;\n\n\thdmi->output.dev = client->dev;\n\n\tdrm_simple_encoder_init(drm, &hdmi->output.encoder,\n\t\t\t\tDRM_MODE_ENCODER_TMDS);\n\tdrm_encoder_helper_add(&hdmi->output.encoder,\n\t\t\t       &tegra_hdmi_encoder_helper_funcs);\n\n\tif (hdmi->output.bridge) {\n\t\terr = drm_bridge_attach(&hdmi->output.encoder, hdmi->output.bridge,\n\t\t\t\t\tNULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (err) {\n\t\t\tdev_err(client->dev, \"failed to attach bridge: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\tconnector = drm_bridge_connector_init(drm, &hdmi->output.encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tdev_err(client->dev,\n\t\t\t\t\"failed to initialize bridge connector: %pe\\n\",\n\t\t\t\tconnector);\n\t\t\treturn PTR_ERR(connector);\n\t\t}\n\n\t\tdrm_connector_attach_encoder(connector, &hdmi->output.encoder);\n\t} else {\n\t\tdrm_connector_init_with_ddc(drm, &hdmi->output.connector,\n\t\t\t\t\t    &tegra_hdmi_connector_funcs,\n\t\t\t\t\t    DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t\t    hdmi->output.ddc);\n\t\tdrm_connector_helper_add(&hdmi->output.connector,\n\t\t\t\t\t &tegra_hdmi_connector_helper_funcs);\n\t\thdmi->output.connector.dpms = DRM_MODE_DPMS_OFF;\n\n\t\tdrm_connector_attach_encoder(&hdmi->output.connector,\n\t\t\t\t\t     &hdmi->output.encoder);\n\t\tdrm_connector_register(&hdmi->output.connector);\n\t}\n\n\terr = tegra_output_init(drm, &hdmi->output);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to initialize output: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thdmi->output.encoder.possible_crtcs = 0x3;\n\n\terr = regulator_enable(hdmi->hdmi);\n\tif (err < 0) {\n\t\tdev_err(client->dev, \"failed to enable HDMI regulator: %d\\n\",\n\t\t\terr);\n\t\tgoto output_exit;\n\t}\n\n\terr = regulator_enable(hdmi->pll);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to enable PLL regulator: %d\\n\", err);\n\t\tgoto disable_hdmi;\n\t}\n\n\terr = regulator_enable(hdmi->vdd);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to enable VDD regulator: %d\\n\", err);\n\t\tgoto disable_pll;\n\t}\n\n\terr = tegra_hdmi_codec_register(hdmi);\n\tif (err < 0) {\n\t\tdev_err(hdmi->dev, \"failed to register audio codec: %d\\n\", err);\n\t\tgoto disable_vdd;\n\t}\n\n\treturn 0;\n\ndisable_vdd:\n\tregulator_disable(hdmi->vdd);\ndisable_pll:\n\tregulator_disable(hdmi->pll);\ndisable_hdmi:\n\tregulator_disable(hdmi->hdmi);\noutput_exit:\n\ttegra_output_exit(&hdmi->output);\n\n\treturn err;\n}\n\nstatic int tegra_hdmi_exit(struct host1x_client *client)\n{\n\tstruct tegra_hdmi *hdmi = host1x_client_to_hdmi(client);\n\n\ttegra_hdmi_codec_unregister(hdmi);\n\n\ttegra_output_exit(&hdmi->output);\n\n\tregulator_disable(hdmi->vdd);\n\tregulator_disable(hdmi->pll);\n\tregulator_disable(hdmi->hdmi);\n\n\treturn 0;\n}\n\nstatic int tegra_hdmi_runtime_suspend(struct host1x_client *client)\n{\n\tstruct tegra_hdmi *hdmi = host1x_client_to_hdmi(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = reset_control_assert(hdmi->rst);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tclk_disable_unprepare(hdmi->clk);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int tegra_hdmi_runtime_resume(struct host1x_client *client)\n{\n\tstruct tegra_hdmi *hdmi = host1x_client_to_hdmi(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get runtime PM: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(hdmi->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\tgoto put_rpm;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\terr = reset_control_deassert(hdmi->rst);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to deassert reset: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(hdmi->clk);\nput_rpm:\n\tpm_runtime_put_sync(dev);\n\treturn err;\n}\n\nstatic const struct host1x_client_ops hdmi_client_ops = {\n\t.init = tegra_hdmi_init,\n\t.exit = tegra_hdmi_exit,\n\t.suspend = tegra_hdmi_runtime_suspend,\n\t.resume = tegra_hdmi_runtime_resume,\n};\n\nstatic const struct tegra_hdmi_config tegra20_hdmi_config = {\n\t.tmds = tegra20_tmds_config,\n\t.num_tmds = ARRAY_SIZE(tegra20_tmds_config),\n\t.fuse_override_offset = HDMI_NV_PDISP_SOR_LANE_DRIVE_CURRENT,\n\t.fuse_override_value = 1 << 31,\n\t.has_sor_io_peak_current = false,\n\t.has_hda = false,\n\t.has_hbr = false,\n};\n\nstatic const struct tegra_hdmi_config tegra30_hdmi_config = {\n\t.tmds = tegra30_tmds_config,\n\t.num_tmds = ARRAY_SIZE(tegra30_tmds_config),\n\t.fuse_override_offset = HDMI_NV_PDISP_SOR_LANE_DRIVE_CURRENT,\n\t.fuse_override_value = 1 << 31,\n\t.has_sor_io_peak_current = false,\n\t.has_hda = true,\n\t.has_hbr = false,\n};\n\nstatic const struct tegra_hdmi_config tegra114_hdmi_config = {\n\t.tmds = tegra114_tmds_config,\n\t.num_tmds = ARRAY_SIZE(tegra114_tmds_config),\n\t.fuse_override_offset = HDMI_NV_PDISP_SOR_PAD_CTLS0,\n\t.fuse_override_value = 1 << 31,\n\t.has_sor_io_peak_current = true,\n\t.has_hda = true,\n\t.has_hbr = true,\n};\n\nstatic const struct tegra_hdmi_config tegra124_hdmi_config = {\n\t.tmds = tegra124_tmds_config,\n\t.num_tmds = ARRAY_SIZE(tegra124_tmds_config),\n\t.fuse_override_offset = HDMI_NV_PDISP_SOR_PAD_CTLS0,\n\t.fuse_override_value = 1 << 31,\n\t.has_sor_io_peak_current = true,\n\t.has_hda = true,\n\t.has_hbr = true,\n};\n\nstatic const struct of_device_id tegra_hdmi_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-hdmi\", .data = &tegra124_hdmi_config },\n\t{ .compatible = \"nvidia,tegra114-hdmi\", .data = &tegra114_hdmi_config },\n\t{ .compatible = \"nvidia,tegra30-hdmi\", .data = &tegra30_hdmi_config },\n\t{ .compatible = \"nvidia,tegra20-hdmi\", .data = &tegra20_hdmi_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_hdmi_of_match);\n\nstatic irqreturn_t tegra_hdmi_irq(int irq, void *data)\n{\n\tstruct tegra_hdmi *hdmi = data;\n\tu32 value;\n\n\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_INT_STATUS);\n\ttegra_hdmi_writel(hdmi, value, HDMI_NV_PDISP_INT_STATUS);\n\n\tif (value & INT_CODEC_SCRATCH0) {\n\t\tunsigned int format;\n\t\tu32 value;\n\n\t\tvalue = tegra_hdmi_readl(hdmi, HDMI_NV_PDISP_SOR_AUDIO_HDA_CODEC_SCRATCH0);\n\n\t\tif (value & SOR_AUDIO_HDA_CODEC_SCRATCH0_VALID) {\n\t\t\tformat = value & SOR_AUDIO_HDA_CODEC_SCRATCH0_FMT_MASK;\n\n\t\t\ttegra_hda_parse_format(format, &hdmi->format);\n\t\t\ttegra_hdmi_reconfigure_audio(hdmi);\n\t\t} else {\n\t\t\ttegra_hdmi_disable_audio_infoframe(hdmi);\n\t\t\ttegra_hdmi_disable_audio(hdmi);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_hdmi_probe(struct platform_device *pdev)\n{\n\tstruct tegra_hdmi *hdmi;\n\tint err;\n\n\thdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->config = of_device_get_match_data(&pdev->dev);\n\thdmi->dev = &pdev->dev;\n\n\thdmi->audio_source = AUTO;\n\thdmi->stereo = false;\n\thdmi->dvi = false;\n\n\tmutex_init(&hdmi->audio_lock);\n\n\thdmi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(hdmi->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(hdmi->clk);\n\t}\n\n\thdmi->rst = devm_reset_control_get(&pdev->dev, \"hdmi\");\n\tif (IS_ERR(hdmi->rst)) {\n\t\tdev_err(&pdev->dev, \"failed to get reset\\n\");\n\t\treturn PTR_ERR(hdmi->rst);\n\t}\n\n\thdmi->clk_parent = devm_clk_get(&pdev->dev, \"parent\");\n\tif (IS_ERR(hdmi->clk_parent))\n\t\treturn PTR_ERR(hdmi->clk_parent);\n\n\terr = clk_set_parent(hdmi->clk, hdmi->clk_parent);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to setup clocks: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thdmi->hdmi = devm_regulator_get(&pdev->dev, \"hdmi\");\n\terr = PTR_ERR_OR_ZERO(hdmi->hdmi);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"failed to get HDMI regulator\\n\");\n\n\thdmi->pll = devm_regulator_get(&pdev->dev, \"pll\");\n\terr = PTR_ERR_OR_ZERO(hdmi->pll);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"failed to get PLL regulator\\n\");\n\n\thdmi->vdd = devm_regulator_get(&pdev->dev, \"vdd\");\n\terr = PTR_ERR_OR_ZERO(hdmi->vdd);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"failed to get VDD regulator\\n\");\n\n\thdmi->output.dev = &pdev->dev;\n\n\terr = tegra_output_probe(&hdmi->output);\n\tif (err < 0)\n\t\treturn err;\n\n\thdmi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdmi->regs))\n\t\treturn PTR_ERR(hdmi->regs);\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\thdmi->irq = err;\n\n\terr = devm_request_irq(hdmi->dev, hdmi->irq, tegra_hdmi_irq, 0,\n\t\t\t       dev_name(hdmi->dev), hdmi);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ#%u: %d\\n\",\n\t\t\thdmi->irq, err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, hdmi);\n\n\terr = devm_pm_runtime_enable(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tINIT_LIST_HEAD(&hdmi->client.list);\n\thdmi->client.ops = &hdmi_client_ops;\n\thdmi->client.dev = &pdev->dev;\n\n\terr = host1x_client_register(&hdmi->client);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_hdmi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_hdmi *hdmi = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&hdmi->client);\n\n\ttegra_output_remove(&hdmi->output);\n}\n\nstruct platform_driver tegra_hdmi_driver = {\n\t.driver = {\n\t\t.name = \"tegra-hdmi\",\n\t\t.of_match_table = tegra_hdmi_of_match,\n\t},\n\t.probe = tegra_hdmi_probe,\n\t.remove_new = tegra_hdmi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}