{
  "module_name": "vic.c",
  "hash_id": "9e1ced62491bd9438289b2cf0e0108e8f1a7d8e6c9b2140ca0bd21e493da3325",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/vic.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/host1x.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/pmc.h>\n\n#include \"drm.h\"\n#include \"falcon.h\"\n#include \"vic.h\"\n\nstruct vic_config {\n\tconst char *firmware;\n\tunsigned int version;\n\tbool supports_sid;\n};\n\nstruct vic {\n\tstruct falcon falcon;\n\n\tvoid __iomem *regs;\n\tstruct tegra_drm_client client;\n\tstruct host1x_channel *channel;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\n\tbool can_use_context;\n\n\t \n\tconst struct vic_config *config;\n};\n\nstatic inline struct vic *to_vic(struct tegra_drm_client *client)\n{\n\treturn container_of(client, struct vic, client);\n}\n\nstatic void vic_writel(struct vic *vic, u32 value, unsigned int offset)\n{\n\twritel(value, vic->regs + offset);\n}\n\nstatic int vic_boot(struct vic *vic)\n{\n\tu32 fce_ucode_size, fce_bin_data_offset, stream_id;\n\tvoid *hdr;\n\tint err = 0;\n\n\tif (vic->config->supports_sid && tegra_dev_iommu_get_stream_id(vic->dev, &stream_id)) {\n\t\tu32 value;\n\n\t\tvalue = TRANSCFG_ATT(1, TRANSCFG_SID_FALCON) |\n\t\t\tTRANSCFG_ATT(0, TRANSCFG_SID_HW);\n\t\tvic_writel(vic, value, VIC_TFBIF_TRANSCFG);\n\n\t\t \n\t\tvic_writel(vic, stream_id, VIC_THI_STREAMID0);\n\n\t\t \n\t\tvic_writel(vic, stream_id, VIC_THI_STREAMID1);\n\t}\n\n\t \n\tvic_writel(vic, CG_IDLE_CG_DLY_CNT(4) |\n\t\t\tCG_IDLE_CG_EN |\n\t\t\tCG_WAKEUP_DLY_CNT(4),\n\t\t   NV_PVIC_MISC_PRI_VIC_CG);\n\n\terr = falcon_boot(&vic->falcon);\n\tif (err < 0)\n\t\treturn err;\n\n\thdr = vic->falcon.firmware.virt;\n\tfce_bin_data_offset = *(u32 *)(hdr + VIC_UCODE_FCE_DATA_OFFSET);\n\n\t \n\tif (fce_bin_data_offset != 0x0 && fce_bin_data_offset != 0xa5a5a5a5) {\n\t\thdr = vic->falcon.firmware.virt +\n\t\t\t*(u32 *)(hdr + VIC_UCODE_FCE_HEADER_OFFSET);\n\t\tfce_ucode_size = *(u32 *)(hdr + FCE_UCODE_SIZE_OFFSET);\n\n\t\tfalcon_execute_method(&vic->falcon, VIC_SET_FCE_UCODE_SIZE,\n\t\t\t\t      fce_ucode_size);\n\t\tfalcon_execute_method(\n\t\t\t&vic->falcon, VIC_SET_FCE_UCODE_OFFSET,\n\t\t\t(vic->falcon.firmware.iova + fce_bin_data_offset) >> 8);\n\t}\n\n\terr = falcon_wait_idle(&vic->falcon);\n\tif (err < 0) {\n\t\tdev_err(vic->dev,\n\t\t\t\"failed to set application ID and FCE base\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int vic_init(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = dev->dev_private;\n\tstruct vic *vic = to_vic(drm);\n\tint err;\n\n\terr = host1x_client_iommu_attach(client);\n\tif (err < 0 && err != -ENODEV) {\n\t\tdev_err(vic->dev, \"failed to attach to domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvic->channel = host1x_channel_request(client);\n\tif (!vic->channel) {\n\t\terr = -ENOMEM;\n\t\tgoto detach;\n\t}\n\n\tclient->syncpts[0] = host1x_syncpt_request(client, 0);\n\tif (!client->syncpts[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto free_channel;\n\t}\n\n\terr = tegra_drm_register_client(tegra, drm);\n\tif (err < 0)\n\t\tgoto free_syncpt;\n\n\t \n\tclient->dev->dma_parms = client->host->dma_parms;\n\n\treturn 0;\n\nfree_syncpt:\n\thost1x_syncpt_put(client->syncpts[0]);\nfree_channel:\n\thost1x_channel_put(vic->channel);\ndetach:\n\thost1x_client_iommu_detach(client);\n\n\treturn err;\n}\n\nstatic int vic_exit(struct host1x_client *client)\n{\n\tstruct tegra_drm_client *drm = host1x_to_drm_client(client);\n\tstruct drm_device *dev = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = dev->dev_private;\n\tstruct vic *vic = to_vic(drm);\n\tint err;\n\n\t \n\tclient->dev->dma_parms = NULL;\n\n\terr = tegra_drm_unregister_client(tegra, drm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpm_runtime_dont_use_autosuspend(client->dev);\n\tpm_runtime_force_suspend(client->dev);\n\n\thost1x_syncpt_put(client->syncpts[0]);\n\thost1x_channel_put(vic->channel);\n\thost1x_client_iommu_detach(client);\n\n\tvic->channel = NULL;\n\n\tif (client->group) {\n\t\tdma_unmap_single(vic->dev, vic->falcon.firmware.phys,\n\t\t\t\t vic->falcon.firmware.size, DMA_TO_DEVICE);\n\t\ttegra_drm_free(tegra, vic->falcon.firmware.size,\n\t\t\t       vic->falcon.firmware.virt,\n\t\t\t       vic->falcon.firmware.iova);\n\t} else {\n\t\tdma_free_coherent(vic->dev, vic->falcon.firmware.size,\n\t\t\t\t  vic->falcon.firmware.virt,\n\t\t\t\t  vic->falcon.firmware.iova);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops vic_client_ops = {\n\t.init = vic_init,\n\t.exit = vic_exit,\n};\n\nstatic int vic_load_firmware(struct vic *vic)\n{\n\tstruct host1x_client *client = &vic->client.base;\n\tstruct tegra_drm *tegra = vic->client.drm;\n\tstatic DEFINE_MUTEX(lock);\n\tu32 fce_bin_data_offset;\n\tdma_addr_t iova;\n\tsize_t size;\n\tvoid *virt;\n\tint err;\n\n\tmutex_lock(&lock);\n\n\tif (vic->falcon.firmware.virt) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\terr = falcon_read_firmware(&vic->falcon, vic->config->firmware);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tsize = vic->falcon.firmware.size;\n\n\tif (!client->group) {\n\t\tvirt = dma_alloc_coherent(vic->dev, size, &iova, GFP_KERNEL);\n\t\tif (!virt) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tvirt = tegra_drm_alloc(tegra, size, &iova);\n\t\tif (IS_ERR(virt)) {\n\t\t\terr = PTR_ERR(virt);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tvic->falcon.firmware.virt = virt;\n\tvic->falcon.firmware.iova = iova;\n\n\terr = falcon_load_firmware(&vic->falcon);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\t \n\tif (client->group) {\n\t\tdma_addr_t phys;\n\n\t\tphys = dma_map_single(vic->dev, virt, size, DMA_TO_DEVICE);\n\n\t\terr = dma_mapping_error(vic->dev, phys);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\n\t\tvic->falcon.firmware.phys = phys;\n\t}\n\n\t \n\tfce_bin_data_offset = *(u32 *)(virt + VIC_UCODE_FCE_DATA_OFFSET);\n\n\tif (!vic->config->supports_sid) {\n\t\tvic->can_use_context = false;\n\t} else if (fce_bin_data_offset != 0x0 && fce_bin_data_offset != 0xa5a5a5a5) {\n\t\t \n\t\tvic->can_use_context = false;\n\t\tdev_warn_once(vic->dev, \"context isolation disabled due to old firmware\\n\");\n\t} else {\n\t\tvic->can_use_context = true;\n\t}\n\nunlock:\n\tmutex_unlock(&lock);\n\treturn err;\n\ncleanup:\n\tif (!client->group)\n\t\tdma_free_coherent(vic->dev, size, virt, iova);\n\telse\n\t\ttegra_drm_free(tegra, size, virt, iova);\n\n\tmutex_unlock(&lock);\n\treturn err;\n}\n\n\nstatic int __maybe_unused vic_runtime_resume(struct device *dev)\n{\n\tstruct vic *vic = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(vic->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\terr = reset_control_deassert(vic->rst);\n\tif (err < 0)\n\t\tgoto disable;\n\n\tusleep_range(10, 20);\n\n\terr = vic_load_firmware(vic);\n\tif (err < 0)\n\t\tgoto assert;\n\n\terr = vic_boot(vic);\n\tif (err < 0)\n\t\tgoto assert;\n\n\treturn 0;\n\nassert:\n\treset_control_assert(vic->rst);\ndisable:\n\tclk_disable_unprepare(vic->clk);\n\treturn err;\n}\n\nstatic int __maybe_unused vic_runtime_suspend(struct device *dev)\n{\n\tstruct vic *vic = dev_get_drvdata(dev);\n\tint err;\n\n\thost1x_channel_stop(vic->channel);\n\n\terr = reset_control_assert(vic->rst);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(2000, 4000);\n\n\tclk_disable_unprepare(vic->clk);\n\n\treturn 0;\n}\n\nstatic int vic_open_channel(struct tegra_drm_client *client,\n\t\t\t    struct tegra_drm_context *context)\n{\n\tstruct vic *vic = to_vic(client);\n\n\tcontext->channel = host1x_channel_get(vic->channel);\n\tif (!context->channel)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void vic_close_channel(struct tegra_drm_context *context)\n{\n\thost1x_channel_put(context->channel);\n}\n\nstatic int vic_can_use_memory_ctx(struct tegra_drm_client *client, bool *supported)\n{\n\tstruct vic *vic = to_vic(client);\n\tint err;\n\n\t \n\terr = vic_load_firmware(vic);\n\tif (err < 0)\n\t\treturn err;\n\n\t*supported = vic->can_use_context;\n\n\treturn 0;\n}\n\nstatic const struct tegra_drm_client_ops vic_ops = {\n\t.open_channel = vic_open_channel,\n\t.close_channel = vic_close_channel,\n\t.submit = tegra_drm_submit,\n\t.get_streamid_offset = tegra_drm_get_streamid_offset_thi,\n\t.can_use_memory_ctx = vic_can_use_memory_ctx,\n};\n\n#define NVIDIA_TEGRA_124_VIC_FIRMWARE \"nvidia/tegra124/vic03_ucode.bin\"\n\nstatic const struct vic_config vic_t124_config = {\n\t.firmware = NVIDIA_TEGRA_124_VIC_FIRMWARE,\n\t.version = 0x40,\n\t.supports_sid = false,\n};\n\n#define NVIDIA_TEGRA_210_VIC_FIRMWARE \"nvidia/tegra210/vic04_ucode.bin\"\n\nstatic const struct vic_config vic_t210_config = {\n\t.firmware = NVIDIA_TEGRA_210_VIC_FIRMWARE,\n\t.version = 0x21,\n\t.supports_sid = false,\n};\n\n#define NVIDIA_TEGRA_186_VIC_FIRMWARE \"nvidia/tegra186/vic04_ucode.bin\"\n\nstatic const struct vic_config vic_t186_config = {\n\t.firmware = NVIDIA_TEGRA_186_VIC_FIRMWARE,\n\t.version = 0x18,\n\t.supports_sid = true,\n};\n\n#define NVIDIA_TEGRA_194_VIC_FIRMWARE \"nvidia/tegra194/vic.bin\"\n\nstatic const struct vic_config vic_t194_config = {\n\t.firmware = NVIDIA_TEGRA_194_VIC_FIRMWARE,\n\t.version = 0x19,\n\t.supports_sid = true,\n};\n\n#define NVIDIA_TEGRA_234_VIC_FIRMWARE \"nvidia/tegra234/vic.bin\"\n\nstatic const struct vic_config vic_t234_config = {\n\t.firmware = NVIDIA_TEGRA_234_VIC_FIRMWARE,\n\t.version = 0x23,\n\t.supports_sid = true,\n};\n\nstatic const struct of_device_id tegra_vic_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-vic\", .data = &vic_t124_config },\n\t{ .compatible = \"nvidia,tegra210-vic\", .data = &vic_t210_config },\n\t{ .compatible = \"nvidia,tegra186-vic\", .data = &vic_t186_config },\n\t{ .compatible = \"nvidia,tegra194-vic\", .data = &vic_t194_config },\n\t{ .compatible = \"nvidia,tegra234-vic\", .data = &vic_t234_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_vic_of_match);\n\nstatic int vic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct host1x_syncpt **syncpts;\n\tstruct vic *vic;\n\tint err;\n\n\t \n\terr = dma_coerce_mask_and_coherent(dev, *dev->parent->dma_mask);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvic = devm_kzalloc(dev, sizeof(*vic), GFP_KERNEL);\n\tif (!vic)\n\t\treturn -ENOMEM;\n\n\tvic->config = of_device_get_match_data(dev);\n\n\tsyncpts = devm_kzalloc(dev, sizeof(*syncpts), GFP_KERNEL);\n\tif (!syncpts)\n\t\treturn -ENOMEM;\n\n\tvic->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vic->regs))\n\t\treturn PTR_ERR(vic->regs);\n\n\tvic->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(vic->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(vic->clk);\n\t}\n\n\terr = clk_set_rate(vic->clk, ULONG_MAX);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set clock rate\\n\");\n\t\treturn err;\n\t}\n\n\tif (!dev->pm_domain) {\n\t\tvic->rst = devm_reset_control_get(dev, \"vic\");\n\t\tif (IS_ERR(vic->rst)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get reset\\n\");\n\t\t\treturn PTR_ERR(vic->rst);\n\t\t}\n\t}\n\n\tvic->falcon.dev = dev;\n\tvic->falcon.regs = vic->regs;\n\n\terr = falcon_init(&vic->falcon);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, vic);\n\n\tINIT_LIST_HEAD(&vic->client.base.list);\n\tvic->client.base.ops = &vic_client_ops;\n\tvic->client.base.dev = dev;\n\tvic->client.base.class = HOST1X_CLASS_VIC;\n\tvic->client.base.syncpts = syncpts;\n\tvic->client.base.num_syncpts = 1;\n\tvic->dev = dev;\n\n\tINIT_LIST_HEAD(&vic->client.list);\n\tvic->client.version = vic->config->version;\n\tvic->client.ops = &vic_ops;\n\n\terr = host1x_client_register(&vic->client.base);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register host1x client: %d\\n\", err);\n\t\tgoto exit_falcon;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 500);\n\n\treturn 0;\n\nexit_falcon:\n\tfalcon_exit(&vic->falcon);\n\n\treturn err;\n}\n\nstatic void vic_remove(struct platform_device *pdev)\n{\n\tstruct vic *vic = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\thost1x_client_unregister(&vic->client.base);\n\tfalcon_exit(&vic->falcon);\n}\n\nstatic const struct dev_pm_ops vic_pm_ops = {\n\tRUNTIME_PM_OPS(vic_runtime_suspend, vic_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\nstruct platform_driver tegra_vic_driver = {\n\t.driver = {\n\t\t.name = \"tegra-vic\",\n\t\t.of_match_table = tegra_vic_of_match,\n\t\t.pm = &vic_pm_ops\n\t},\n\t.probe = vic_probe,\n\t.remove_new = vic_remove,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_124_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_124_VIC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_210_VIC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_186_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_186_VIC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_194_VIC_FIRMWARE);\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)\nMODULE_FIRMWARE(NVIDIA_TEGRA_234_VIC_FIRMWARE);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}