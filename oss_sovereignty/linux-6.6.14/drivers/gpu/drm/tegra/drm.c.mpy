{
  "module_name": "drm.c",
  "hash_id": "1aab13893f0ab4eae8acccba56558f1bfe545fbbc106cef825969a000124f4df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/drm.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/host1x.h>\n#include <linux/idr.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_prime.h>\n#include <drm/drm_vblank.h>\n\n#if IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)\n#include <asm/dma-iommu.h>\n#endif\n\n#include \"dc.h\"\n#include \"drm.h\"\n#include \"gem.h\"\n#include \"uapi.h\"\n\n#define DRIVER_NAME \"tegra\"\n#define DRIVER_DESC \"NVIDIA Tegra graphics\"\n#define DRIVER_DATE \"20120330\"\n#define DRIVER_MAJOR 1\n#define DRIVER_MINOR 0\n#define DRIVER_PATCHLEVEL 0\n\n#define CARVEOUT_SZ SZ_64M\n#define CDMA_GATHER_FETCHES_MAX_NB 16383\n\nstatic int tegra_atomic_check(struct drm_device *drm,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tint err;\n\n\terr = drm_atomic_helper_check(drm, state);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn tegra_display_hub_atomic_check(drm, state);\n}\n\nstatic const struct drm_mode_config_funcs tegra_drm_mode_config_funcs = {\n\t.fb_create = tegra_fb_create,\n\t.atomic_check = tegra_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic void tegra_atomic_post_commit(struct drm_device *drm,\n\t\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc_state *old_crtc_state __maybe_unused;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\n\tfor_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i)\n\t\ttegra_crtc_atomic_post_commit(crtc, old_state);\n}\n\nstatic void tegra_atomic_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *drm = old_state->dev;\n\tstruct tegra_drm *tegra = drm->dev_private;\n\n\tif (tegra->hub) {\n\t\tbool fence_cookie = dma_fence_begin_signalling();\n\n\t\tdrm_atomic_helper_commit_modeset_disables(drm, old_state);\n\t\ttegra_display_hub_atomic_commit(drm, old_state);\n\t\tdrm_atomic_helper_commit_planes(drm, old_state, 0);\n\t\tdrm_atomic_helper_commit_modeset_enables(drm, old_state);\n\t\tdrm_atomic_helper_commit_hw_done(old_state);\n\t\tdma_fence_end_signalling(fence_cookie);\n\t\tdrm_atomic_helper_wait_for_vblanks(drm, old_state);\n\t\tdrm_atomic_helper_cleanup_planes(drm, old_state);\n\t} else {\n\t\tdrm_atomic_helper_commit_tail_rpm(old_state);\n\t}\n\n\ttegra_atomic_post_commit(drm, old_state);\n}\n\nstatic const struct drm_mode_config_helper_funcs\ntegra_drm_mode_config_helpers = {\n\t.atomic_commit_tail = tegra_atomic_commit_tail,\n};\n\nstatic int tegra_drm_open(struct drm_device *drm, struct drm_file *filp)\n{\n\tstruct tegra_drm_file *fpriv;\n\n\tfpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);\n\tif (!fpriv)\n\t\treturn -ENOMEM;\n\n\tidr_init_base(&fpriv->legacy_contexts, 1);\n\txa_init_flags(&fpriv->contexts, XA_FLAGS_ALLOC1);\n\txa_init(&fpriv->syncpoints);\n\tmutex_init(&fpriv->lock);\n\tfilp->driver_priv = fpriv;\n\n\treturn 0;\n}\n\nstatic void tegra_drm_context_free(struct tegra_drm_context *context)\n{\n\tcontext->client->ops->close_channel(context);\n\tpm_runtime_put(context->client->base.dev);\n\tkfree(context);\n}\n\nstatic int host1x_reloc_copy_from_user(struct host1x_reloc *dest,\n\t\t\t\t       struct drm_tegra_reloc __user *src,\n\t\t\t\t       struct drm_device *drm,\n\t\t\t\t       struct drm_file *file)\n{\n\tu32 cmdbuf, target;\n\tint err;\n\n\terr = get_user(cmdbuf, &src->cmdbuf.handle);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_user(dest->cmdbuf.offset, &src->cmdbuf.offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_user(target, &src->target.handle);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_user(dest->target.offset, &src->target.offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_user(dest->shift, &src->shift);\n\tif (err < 0)\n\t\treturn err;\n\n\tdest->flags = HOST1X_RELOC_READ | HOST1X_RELOC_WRITE;\n\n\tdest->cmdbuf.bo = tegra_gem_lookup(file, cmdbuf);\n\tif (!dest->cmdbuf.bo)\n\t\treturn -ENOENT;\n\n\tdest->target.bo = tegra_gem_lookup(file, target);\n\tif (!dest->target.bo)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nint tegra_drm_submit(struct tegra_drm_context *context,\n\t\t     struct drm_tegra_submit *args, struct drm_device *drm,\n\t\t     struct drm_file *file)\n{\n\tstruct host1x_client *client = &context->client->base;\n\tunsigned int num_cmdbufs = args->num_cmdbufs;\n\tunsigned int num_relocs = args->num_relocs;\n\tstruct drm_tegra_cmdbuf __user *user_cmdbufs;\n\tstruct drm_tegra_reloc __user *user_relocs;\n\tstruct drm_tegra_syncpt __user *user_syncpt;\n\tstruct drm_tegra_syncpt syncpt;\n\tstruct host1x *host1x = dev_get_drvdata(drm->dev->parent);\n\tstruct drm_gem_object **refs;\n\tstruct host1x_syncpt *sp = NULL;\n\tstruct host1x_job *job;\n\tunsigned int num_refs;\n\tint err;\n\n\tuser_cmdbufs = u64_to_user_ptr(args->cmdbufs);\n\tuser_relocs = u64_to_user_ptr(args->relocs);\n\tuser_syncpt = u64_to_user_ptr(args->syncpts);\n\n\t \n\tif (args->num_syncpts != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (args->num_waitchks != 0)\n\t\treturn -EINVAL;\n\n\tjob = host1x_job_alloc(context->channel, args->num_cmdbufs,\n\t\t\t       args->num_relocs, false);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tjob->num_relocs = args->num_relocs;\n\tjob->client = client;\n\tjob->class = client->class;\n\tjob->serialize = true;\n\tjob->syncpt_recovery = true;\n\n\t \n\tnum_refs = num_cmdbufs + num_relocs * 2;\n\n\trefs = kmalloc_array(num_refs, sizeof(*refs), GFP_KERNEL);\n\tif (!refs) {\n\t\terr = -ENOMEM;\n\t\tgoto put;\n\t}\n\n\t \n\tnum_refs = 0;\n\n\twhile (num_cmdbufs) {\n\t\tstruct drm_tegra_cmdbuf cmdbuf;\n\t\tstruct host1x_bo *bo;\n\t\tstruct tegra_bo *obj;\n\t\tu64 offset;\n\n\t\tif (copy_from_user(&cmdbuf, user_cmdbufs, sizeof(cmdbuf))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (cmdbuf.words > CDMA_GATHER_FETCHES_MAX_NB) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbo = tegra_gem_lookup(file, cmdbuf.handle);\n\t\tif (!bo) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\n\t\toffset = (u64)cmdbuf.offset + (u64)cmdbuf.words * sizeof(u32);\n\t\tobj = host1x_to_tegra_bo(bo);\n\t\trefs[num_refs++] = &obj->gem;\n\n\t\t \n\t\tif (offset & 3 || offset > obj->gem.size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\thost1x_job_add_gather(job, bo, cmdbuf.words, cmdbuf.offset);\n\t\tnum_cmdbufs--;\n\t\tuser_cmdbufs++;\n\t}\n\n\t \n\twhile (num_relocs--) {\n\t\tstruct host1x_reloc *reloc;\n\t\tstruct tegra_bo *obj;\n\n\t\terr = host1x_reloc_copy_from_user(&job->relocs[num_relocs],\n\t\t\t\t\t\t  &user_relocs[num_relocs], drm,\n\t\t\t\t\t\t  file);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\treloc = &job->relocs[num_relocs];\n\t\tobj = host1x_to_tegra_bo(reloc->cmdbuf.bo);\n\t\trefs[num_refs++] = &obj->gem;\n\n\t\t \n\t\tif (reloc->cmdbuf.offset & 3 ||\n\t\t    reloc->cmdbuf.offset >= obj->gem.size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tobj = host1x_to_tegra_bo(reloc->target.bo);\n\t\trefs[num_refs++] = &obj->gem;\n\n\t\tif (reloc->target.offset >= obj->gem.size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (copy_from_user(&syncpt, user_syncpt, sizeof(syncpt))) {\n\t\terr = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\t \n\tsp = host1x_syncpt_get_by_id(host1x, syncpt.id);\n\tif (!sp) {\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tjob->is_addr_reg = context->client->ops->is_addr_reg;\n\tjob->is_valid_class = context->client->ops->is_valid_class;\n\tjob->syncpt_incrs = syncpt.incrs;\n\tjob->syncpt = sp;\n\tjob->timeout = 10000;\n\n\tif (args->timeout && args->timeout < 10000)\n\t\tjob->timeout = args->timeout;\n\n\terr = host1x_job_pin(job, context->client->base.dev);\n\tif (err)\n\t\tgoto fail;\n\n\terr = host1x_job_submit(job);\n\tif (err) {\n\t\thost1x_job_unpin(job);\n\t\tgoto fail;\n\t}\n\n\targs->fence = job->syncpt_end;\n\nfail:\n\twhile (num_refs--)\n\t\tdrm_gem_object_put(refs[num_refs]);\n\n\tkfree(refs);\n\nput:\n\thost1x_job_put(job);\n\treturn err;\n}\n\n\n#ifdef CONFIG_DRM_TEGRA_STAGING\nstatic int tegra_gem_create(struct drm_device *drm, void *data,\n\t\t\t    struct drm_file *file)\n{\n\tstruct drm_tegra_gem_create *args = data;\n\tstruct tegra_bo *bo;\n\n\tbo = tegra_bo_create_with_handle(file, drm, args->size, args->flags,\n\t\t\t\t\t &args->handle);\n\tif (IS_ERR(bo))\n\t\treturn PTR_ERR(bo);\n\n\treturn 0;\n}\n\nstatic int tegra_gem_mmap(struct drm_device *drm, void *data,\n\t\t\t  struct drm_file *file)\n{\n\tstruct drm_tegra_gem_mmap *args = data;\n\tstruct drm_gem_object *gem;\n\tstruct tegra_bo *bo;\n\n\tgem = drm_gem_object_lookup(file, args->handle);\n\tif (!gem)\n\t\treturn -EINVAL;\n\n\tbo = to_tegra_bo(gem);\n\n\targs->offset = drm_vma_node_offset_addr(&bo->gem.vma_node);\n\n\tdrm_gem_object_put(gem);\n\n\treturn 0;\n}\n\nstatic int tegra_syncpt_read(struct drm_device *drm, void *data,\n\t\t\t     struct drm_file *file)\n{\n\tstruct host1x *host = dev_get_drvdata(drm->dev->parent);\n\tstruct drm_tegra_syncpt_read *args = data;\n\tstruct host1x_syncpt *sp;\n\n\tsp = host1x_syncpt_get_by_id_noref(host, args->id);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\targs->value = host1x_syncpt_read_min(sp);\n\treturn 0;\n}\n\nstatic int tegra_syncpt_incr(struct drm_device *drm, void *data,\n\t\t\t     struct drm_file *file)\n{\n\tstruct host1x *host1x = dev_get_drvdata(drm->dev->parent);\n\tstruct drm_tegra_syncpt_incr *args = data;\n\tstruct host1x_syncpt *sp;\n\n\tsp = host1x_syncpt_get_by_id_noref(host1x, args->id);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\treturn host1x_syncpt_incr(sp);\n}\n\nstatic int tegra_syncpt_wait(struct drm_device *drm, void *data,\n\t\t\t     struct drm_file *file)\n{\n\tstruct host1x *host1x = dev_get_drvdata(drm->dev->parent);\n\tstruct drm_tegra_syncpt_wait *args = data;\n\tstruct host1x_syncpt *sp;\n\n\tsp = host1x_syncpt_get_by_id_noref(host1x, args->id);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\treturn host1x_syncpt_wait(sp, args->thresh,\n\t\t\t\t  msecs_to_jiffies(args->timeout),\n\t\t\t\t  &args->value);\n}\n\nstatic int tegra_client_open(struct tegra_drm_file *fpriv,\n\t\t\t     struct tegra_drm_client *client,\n\t\t\t     struct tegra_drm_context *context)\n{\n\tint err;\n\n\terr = pm_runtime_resume_and_get(client->base.dev);\n\tif (err)\n\t\treturn err;\n\n\terr = client->ops->open_channel(client, context);\n\tif (err < 0) {\n\t\tpm_runtime_put(client->base.dev);\n\t\treturn err;\n\t}\n\n\terr = idr_alloc(&fpriv->legacy_contexts, context, 1, 0, GFP_KERNEL);\n\tif (err < 0) {\n\t\tclient->ops->close_channel(context);\n\t\tpm_runtime_put(client->base.dev);\n\t\treturn err;\n\t}\n\n\tcontext->client = client;\n\tcontext->id = err;\n\n\treturn 0;\n}\n\nstatic int tegra_open_channel(struct drm_device *drm, void *data,\n\t\t\t      struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct drm_tegra_open_channel *args = data;\n\tstruct tegra_drm_context *context;\n\tstruct tegra_drm_client *client;\n\tint err = -ENODEV;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fpriv->lock);\n\n\tlist_for_each_entry(client, &tegra->clients, list)\n\t\tif (client->base.class == args->client) {\n\t\t\terr = tegra_client_open(fpriv, client, context);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\targs->context = context->id;\n\t\t\tbreak;\n\t\t}\n\n\tif (err < 0)\n\t\tkfree(context);\n\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nstatic int tegra_close_channel(struct drm_device *drm, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_close_channel *args = data;\n\tstruct tegra_drm_context *context;\n\tint err = 0;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = idr_find(&fpriv->legacy_contexts, args->context);\n\tif (!context) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tidr_remove(&fpriv->legacy_contexts, context->id);\n\ttegra_drm_context_free(context);\n\nunlock:\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nstatic int tegra_get_syncpt(struct drm_device *drm, void *data,\n\t\t\t    struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_get_syncpt *args = data;\n\tstruct tegra_drm_context *context;\n\tstruct host1x_syncpt *syncpt;\n\tint err = 0;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = idr_find(&fpriv->legacy_contexts, args->context);\n\tif (!context) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (args->index >= context->client->base.num_syncpts) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tsyncpt = context->client->base.syncpts[args->index];\n\targs->id = host1x_syncpt_id(syncpt);\n\nunlock:\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nstatic int tegra_submit(struct drm_device *drm, void *data,\n\t\t\tstruct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_submit *args = data;\n\tstruct tegra_drm_context *context;\n\tint err;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = idr_find(&fpriv->legacy_contexts, args->context);\n\tif (!context) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\terr = context->client->ops->submit(context, args, drm, file);\n\nunlock:\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nstatic int tegra_get_syncpt_base(struct drm_device *drm, void *data,\n\t\t\t\t struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\tstruct drm_tegra_get_syncpt_base *args = data;\n\tstruct tegra_drm_context *context;\n\tstruct host1x_syncpt_base *base;\n\tstruct host1x_syncpt *syncpt;\n\tint err = 0;\n\n\tmutex_lock(&fpriv->lock);\n\n\tcontext = idr_find(&fpriv->legacy_contexts, args->context);\n\tif (!context) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (args->syncpt >= context->client->base.num_syncpts) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tsyncpt = context->client->base.syncpts[args->syncpt];\n\n\tbase = host1x_syncpt_get_base(syncpt);\n\tif (!base) {\n\t\terr = -ENXIO;\n\t\tgoto unlock;\n\t}\n\n\targs->id = host1x_syncpt_base_id(base);\n\nunlock:\n\tmutex_unlock(&fpriv->lock);\n\treturn err;\n}\n\nstatic int tegra_gem_set_tiling(struct drm_device *drm, void *data,\n\t\t\t\tstruct drm_file *file)\n{\n\tstruct drm_tegra_gem_set_tiling *args = data;\n\tenum tegra_bo_tiling_mode mode;\n\tstruct drm_gem_object *gem;\n\tunsigned long value = 0;\n\tstruct tegra_bo *bo;\n\n\tswitch (args->mode) {\n\tcase DRM_TEGRA_GEM_TILING_MODE_PITCH:\n\t\tmode = TEGRA_BO_TILING_MODE_PITCH;\n\n\t\tif (args->value != 0)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase DRM_TEGRA_GEM_TILING_MODE_TILED:\n\t\tmode = TEGRA_BO_TILING_MODE_TILED;\n\n\t\tif (args->value != 0)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase DRM_TEGRA_GEM_TILING_MODE_BLOCK:\n\t\tmode = TEGRA_BO_TILING_MODE_BLOCK;\n\n\t\tif (args->value > 5)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = args->value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tgem = drm_gem_object_lookup(file, args->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\n\tbo = to_tegra_bo(gem);\n\n\tbo->tiling.mode = mode;\n\tbo->tiling.value = value;\n\n\tdrm_gem_object_put(gem);\n\n\treturn 0;\n}\n\nstatic int tegra_gem_get_tiling(struct drm_device *drm, void *data,\n\t\t\t\tstruct drm_file *file)\n{\n\tstruct drm_tegra_gem_get_tiling *args = data;\n\tstruct drm_gem_object *gem;\n\tstruct tegra_bo *bo;\n\tint err = 0;\n\n\tgem = drm_gem_object_lookup(file, args->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\n\tbo = to_tegra_bo(gem);\n\n\tswitch (bo->tiling.mode) {\n\tcase TEGRA_BO_TILING_MODE_PITCH:\n\t\targs->mode = DRM_TEGRA_GEM_TILING_MODE_PITCH;\n\t\targs->value = 0;\n\t\tbreak;\n\n\tcase TEGRA_BO_TILING_MODE_TILED:\n\t\targs->mode = DRM_TEGRA_GEM_TILING_MODE_TILED;\n\t\targs->value = 0;\n\t\tbreak;\n\n\tcase TEGRA_BO_TILING_MODE_BLOCK:\n\t\targs->mode = DRM_TEGRA_GEM_TILING_MODE_BLOCK;\n\t\targs->value = bo->tiling.value;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tdrm_gem_object_put(gem);\n\n\treturn err;\n}\n\nstatic int tegra_gem_set_flags(struct drm_device *drm, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_tegra_gem_set_flags *args = data;\n\tstruct drm_gem_object *gem;\n\tstruct tegra_bo *bo;\n\n\tif (args->flags & ~DRM_TEGRA_GEM_FLAGS)\n\t\treturn -EINVAL;\n\n\tgem = drm_gem_object_lookup(file, args->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\n\tbo = to_tegra_bo(gem);\n\tbo->flags = 0;\n\n\tif (args->flags & DRM_TEGRA_GEM_BOTTOM_UP)\n\t\tbo->flags |= TEGRA_BO_BOTTOM_UP;\n\n\tdrm_gem_object_put(gem);\n\n\treturn 0;\n}\n\nstatic int tegra_gem_get_flags(struct drm_device *drm, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct drm_tegra_gem_get_flags *args = data;\n\tstruct drm_gem_object *gem;\n\tstruct tegra_bo *bo;\n\n\tgem = drm_gem_object_lookup(file, args->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\n\tbo = to_tegra_bo(gem);\n\targs->flags = 0;\n\n\tif (bo->flags & TEGRA_BO_BOTTOM_UP)\n\t\targs->flags |= DRM_TEGRA_GEM_BOTTOM_UP;\n\n\tdrm_gem_object_put(gem);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct drm_ioctl_desc tegra_drm_ioctls[] = {\n#ifdef CONFIG_DRM_TEGRA_STAGING\n\tDRM_IOCTL_DEF_DRV(TEGRA_CHANNEL_OPEN, tegra_drm_ioctl_channel_open,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_CHANNEL_CLOSE, tegra_drm_ioctl_channel_close,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_CHANNEL_MAP, tegra_drm_ioctl_channel_map,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_CHANNEL_UNMAP, tegra_drm_ioctl_channel_unmap,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_CHANNEL_SUBMIT, tegra_drm_ioctl_channel_submit,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPOINT_ALLOCATE, tegra_drm_ioctl_syncpoint_allocate,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPOINT_FREE, tegra_drm_ioctl_syncpoint_free,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPOINT_WAIT, tegra_drm_ioctl_syncpoint_wait,\n\t\t\t  DRM_RENDER_ALLOW),\n\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_CREATE, tegra_gem_create, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_MMAP, tegra_gem_mmap, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPT_READ, tegra_syncpt_read,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPT_INCR, tegra_syncpt_incr,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SYNCPT_WAIT, tegra_syncpt_wait,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_OPEN_CHANNEL, tegra_open_channel,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_CLOSE_CHANNEL, tegra_close_channel,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GET_SYNCPT, tegra_get_syncpt,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_SUBMIT, tegra_submit,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GET_SYNCPT_BASE, tegra_get_syncpt_base,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_SET_TILING, tegra_gem_set_tiling,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_GET_TILING, tegra_gem_get_tiling,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_SET_FLAGS, tegra_gem_set_flags,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(TEGRA_GEM_GET_FLAGS, tegra_gem_get_flags,\n\t\t\t  DRM_RENDER_ALLOW),\n#endif\n};\n\nstatic const struct file_operations tegra_drm_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.release = drm_release,\n\t.unlocked_ioctl = drm_ioctl,\n\t.mmap = tegra_drm_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n\t.compat_ioctl = drm_compat_ioctl,\n\t.llseek = noop_llseek,\n};\n\nstatic int tegra_drm_context_cleanup(int id, void *p, void *data)\n{\n\tstruct tegra_drm_context *context = p;\n\n\ttegra_drm_context_free(context);\n\n\treturn 0;\n}\n\nstatic void tegra_drm_postclose(struct drm_device *drm, struct drm_file *file)\n{\n\tstruct tegra_drm_file *fpriv = file->driver_priv;\n\n\tmutex_lock(&fpriv->lock);\n\tidr_for_each(&fpriv->legacy_contexts, tegra_drm_context_cleanup, NULL);\n\ttegra_drm_uapi_close_file(fpriv);\n\tmutex_unlock(&fpriv->lock);\n\n\tidr_destroy(&fpriv->legacy_contexts);\n\tmutex_destroy(&fpriv->lock);\n\tkfree(fpriv);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int tegra_debugfs_framebuffers(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)s->private;\n\tstruct drm_device *drm = node->minor->dev;\n\tstruct drm_framebuffer *fb;\n\n\tmutex_lock(&drm->mode_config.fb_lock);\n\n\tlist_for_each_entry(fb, &drm->mode_config.fb_list, head) {\n\t\tseq_printf(s, \"%3d: user size: %d x %d, depth %d, %d bpp, refcount %d\\n\",\n\t\t\t   fb->base.id, fb->width, fb->height,\n\t\t\t   fb->format->depth,\n\t\t\t   fb->format->cpp[0] * 8,\n\t\t\t   drm_framebuffer_read_refcount(fb));\n\t}\n\n\tmutex_unlock(&drm->mode_config.fb_lock);\n\n\treturn 0;\n}\n\nstatic int tegra_debugfs_iova(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *)s->private;\n\tstruct drm_device *drm = node->minor->dev;\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct drm_printer p = drm_seq_file_printer(s);\n\n\tif (tegra->domain) {\n\t\tmutex_lock(&tegra->mm_lock);\n\t\tdrm_mm_print(&tegra->mm, &p);\n\t\tmutex_unlock(&tegra->mm_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic struct drm_info_list tegra_debugfs_list[] = {\n\t{ \"framebuffers\", tegra_debugfs_framebuffers, 0 },\n\t{ \"iova\", tegra_debugfs_iova, 0 },\n};\n\nstatic void tegra_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_create_files(tegra_debugfs_list,\n\t\t\t\t ARRAY_SIZE(tegra_debugfs_list),\n\t\t\t\t minor->debugfs_root, minor);\n}\n#endif\n\nstatic const struct drm_driver tegra_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM |\n\t\t\t   DRIVER_ATOMIC | DRIVER_RENDER | DRIVER_SYNCOBJ,\n\t.open = tegra_drm_open,\n\t.postclose = tegra_drm_postclose,\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = tegra_debugfs_init,\n#endif\n\n\t.gem_prime_import = tegra_gem_prime_import,\n\n\t.dumb_create = tegra_bo_dumb_create,\n\n\t.ioctls = tegra_drm_ioctls,\n\t.num_ioctls = ARRAY_SIZE(tegra_drm_ioctls),\n\t.fops = &tegra_drm_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nint tegra_drm_register_client(struct tegra_drm *tegra,\n\t\t\t      struct tegra_drm_client *client)\n{\n\t \n\tclient->shared_channel = host1x_channel_request(&client->base);\n\tif (!client->shared_channel)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&tegra->clients_lock);\n\tlist_add_tail(&client->list, &tegra->clients);\n\tclient->drm = tegra;\n\tmutex_unlock(&tegra->clients_lock);\n\n\treturn 0;\n}\n\nint tegra_drm_unregister_client(struct tegra_drm *tegra,\n\t\t\t\tstruct tegra_drm_client *client)\n{\n\tmutex_lock(&tegra->clients_lock);\n\tlist_del_init(&client->list);\n\tclient->drm = NULL;\n\tmutex_unlock(&tegra->clients_lock);\n\n\tif (client->shared_channel)\n\t\thost1x_channel_put(client->shared_channel);\n\n\treturn 0;\n}\n\nint host1x_client_iommu_attach(struct host1x_client *client)\n{\n\tstruct iommu_domain *domain = iommu_get_domain_for_dev(client->dev);\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct iommu_group *group = NULL;\n\tint err;\n\n#if IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)\n\tif (client->dev->archdata.mapping) {\n\t\tstruct dma_iommu_mapping *mapping =\n\t\t\t\tto_dma_iommu_mapping(client->dev);\n\t\tarm_iommu_detach_device(client->dev);\n\t\tarm_iommu_release_mapping(mapping);\n\n\t\tdomain = iommu_get_domain_for_dev(client->dev);\n\t}\n#endif\n\n\t \n\tif (domain && domain != tegra->domain)\n\t\treturn 0;\n\n\tif (tegra->domain) {\n\t\tgroup = iommu_group_get(client->dev);\n\t\tif (!group)\n\t\t\treturn -ENODEV;\n\n\t\tif (domain != tegra->domain) {\n\t\t\terr = iommu_attach_group(tegra->domain, group);\n\t\t\tif (err < 0) {\n\t\t\t\tiommu_group_put(group);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\ttegra->use_explicit_iommu = true;\n\t}\n\n\tclient->group = group;\n\n\treturn 0;\n}\n\nvoid host1x_client_iommu_detach(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tstruct iommu_domain *domain;\n\n\tif (client->group) {\n\t\t \n\t\tdomain = iommu_get_domain_for_dev(client->dev);\n\t\tif (domain)\n\t\t\tiommu_detach_group(tegra->domain, client->group);\n\n\t\tiommu_group_put(client->group);\n\t\tclient->group = NULL;\n\t}\n}\n\nvoid *tegra_drm_alloc(struct tegra_drm *tegra, size_t size, dma_addr_t *dma)\n{\n\tstruct iova *alloc;\n\tvoid *virt;\n\tgfp_t gfp;\n\tint err;\n\n\tif (tegra->domain)\n\t\tsize = iova_align(&tegra->carveout.domain, size);\n\telse\n\t\tsize = PAGE_ALIGN(size);\n\n\tgfp = GFP_KERNEL | __GFP_ZERO;\n\tif (!tegra->domain) {\n\t\t \n\t\tgfp |= GFP_DMA;\n\t}\n\n\tvirt = (void *)__get_free_pages(gfp, get_order(size));\n\tif (!virt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!tegra->domain) {\n\t\t \n\t\t*dma = virt_to_phys(virt);\n\t\treturn virt;\n\t}\n\n\talloc = alloc_iova(&tegra->carveout.domain,\n\t\t\t   size >> tegra->carveout.shift,\n\t\t\t   tegra->carveout.limit, true);\n\tif (!alloc) {\n\t\terr = -EBUSY;\n\t\tgoto free_pages;\n\t}\n\n\t*dma = iova_dma_addr(&tegra->carveout.domain, alloc);\n\terr = iommu_map(tegra->domain, *dma, virt_to_phys(virt),\n\t\t\tsize, IOMMU_READ | IOMMU_WRITE, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto free_iova;\n\n\treturn virt;\n\nfree_iova:\n\t__free_iova(&tegra->carveout.domain, alloc);\nfree_pages:\n\tfree_pages((unsigned long)virt, get_order(size));\n\n\treturn ERR_PTR(err);\n}\n\nvoid tegra_drm_free(struct tegra_drm *tegra, size_t size, void *virt,\n\t\t    dma_addr_t dma)\n{\n\tif (tegra->domain)\n\t\tsize = iova_align(&tegra->carveout.domain, size);\n\telse\n\t\tsize = PAGE_ALIGN(size);\n\n\tif (tegra->domain) {\n\t\tiommu_unmap(tegra->domain, dma, size);\n\t\tfree_iova(&tegra->carveout.domain,\n\t\t\t  iova_pfn(&tegra->carveout.domain, dma));\n\t}\n\n\tfree_pages((unsigned long)virt, get_order(size));\n}\n\nstatic bool host1x_drm_wants_iommu(struct host1x_device *dev)\n{\n\tstruct host1x *host1x = dev_get_drvdata(dev->dev.parent);\n\tstruct iommu_domain *domain;\n\n\t \n\tif (of_machine_is_compatible(\"nvidia,tegra20\"))\n\t\treturn false;\n\n\t \n\tdomain = iommu_get_domain_for_dev(dev->dev.parent);\n\n\t \n\tif (!domain && host1x_get_dma_mask(host1x) <= DMA_BIT_MASK(32))\n\t\treturn true;\n\n\treturn domain != NULL;\n}\n\nstatic int host1x_drm_probe(struct host1x_device *dev)\n{\n\tstruct tegra_drm *tegra;\n\tstruct drm_device *drm;\n\tint err;\n\n\tdrm = drm_dev_alloc(&tegra_drm_driver, &dev->dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\n\ttegra = kzalloc(sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra) {\n\t\terr = -ENOMEM;\n\t\tgoto put;\n\t}\n\n\tif (host1x_drm_wants_iommu(dev) && iommu_present(&platform_bus_type)) {\n\t\ttegra->domain = iommu_domain_alloc(&platform_bus_type);\n\t\tif (!tegra->domain) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\n\t\terr = iova_cache_get();\n\t\tif (err < 0)\n\t\t\tgoto domain;\n\t}\n\n\tmutex_init(&tegra->clients_lock);\n\tINIT_LIST_HEAD(&tegra->clients);\n\n\tdev_set_drvdata(&dev->dev, drm);\n\tdrm->dev_private = tegra;\n\ttegra->drm = drm;\n\n\tdrm_mode_config_init(drm);\n\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = 0;\n\tdrm->mode_config.max_height = 0;\n\n\tdrm->mode_config.normalize_zpos = true;\n\n\tdrm->mode_config.funcs = &tegra_drm_mode_config_funcs;\n\tdrm->mode_config.helper_private = &tegra_drm_mode_config_helpers;\n\n\tdrm_kms_helper_poll_init(drm);\n\n\terr = host1x_device_init(dev);\n\tif (err < 0)\n\t\tgoto poll;\n\n\t \n\ttegra->hmask = drm->mode_config.max_width - 1;\n\ttegra->vmask = drm->mode_config.max_height - 1;\n\n\tif (tegra->use_explicit_iommu) {\n\t\tu64 carveout_start, carveout_end, gem_start, gem_end;\n\t\tu64 dma_mask = dma_get_mask(&dev->dev);\n\t\tdma_addr_t start, end;\n\t\tunsigned long order;\n\n\t\tstart = tegra->domain->geometry.aperture_start & dma_mask;\n\t\tend = tegra->domain->geometry.aperture_end & dma_mask;\n\n\t\tgem_start = start;\n\t\tgem_end = end - CARVEOUT_SZ;\n\t\tcarveout_start = gem_end + 1;\n\t\tcarveout_end = end;\n\n\t\torder = __ffs(tegra->domain->pgsize_bitmap);\n\t\tinit_iova_domain(&tegra->carveout.domain, 1UL << order,\n\t\t\t\t carveout_start >> order);\n\n\t\ttegra->carveout.shift = iova_shift(&tegra->carveout.domain);\n\t\ttegra->carveout.limit = carveout_end >> tegra->carveout.shift;\n\n\t\tdrm_mm_init(&tegra->mm, gem_start, gem_end - gem_start + 1);\n\t\tmutex_init(&tegra->mm_lock);\n\n\t\tDRM_DEBUG_DRIVER(\"IOMMU apertures:\\n\");\n\t\tDRM_DEBUG_DRIVER(\"  GEM: %#llx-%#llx\\n\", gem_start, gem_end);\n\t\tDRM_DEBUG_DRIVER(\"  Carveout: %#llx-%#llx\\n\", carveout_start,\n\t\t\t\t carveout_end);\n\t} else if (tegra->domain) {\n\t\tiommu_domain_free(tegra->domain);\n\t\ttegra->domain = NULL;\n\t\tiova_cache_put();\n\t}\n\n\tif (tegra->hub) {\n\t\terr = tegra_display_hub_prepare(tegra->hub);\n\t\tif (err < 0)\n\t\t\tgoto device;\n\t}\n\n\t \n\tdrm->max_vblank_count = 0xffffffff;\n\n\terr = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (err < 0)\n\t\tgoto hub;\n\n\tdrm_mode_config_reset(drm);\n\n\terr = drm_aperture_remove_framebuffers(&tegra_drm_driver);\n\tif (err < 0)\n\t\tgoto hub;\n\n\terr = drm_dev_register(drm, 0);\n\tif (err < 0)\n\t\tgoto hub;\n\n\ttegra_fbdev_setup(drm);\n\n\treturn 0;\n\nhub:\n\tif (tegra->hub)\n\t\ttegra_display_hub_cleanup(tegra->hub);\ndevice:\n\tif (tegra->domain) {\n\t\tmutex_destroy(&tegra->mm_lock);\n\t\tdrm_mm_takedown(&tegra->mm);\n\t\tput_iova_domain(&tegra->carveout.domain);\n\t\tiova_cache_put();\n\t}\n\n\thost1x_device_exit(dev);\npoll:\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_mode_config_cleanup(drm);\ndomain:\n\tif (tegra->domain)\n\t\tiommu_domain_free(tegra->domain);\nfree:\n\tkfree(tegra);\nput:\n\tdrm_dev_put(drm);\n\treturn err;\n}\n\nstatic int host1x_drm_remove(struct host1x_device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(&dev->dev);\n\tstruct tegra_drm *tegra = drm->dev_private;\n\tint err;\n\n\tdrm_dev_unregister(drm);\n\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tdrm_mode_config_cleanup(drm);\n\n\tif (tegra->hub)\n\t\ttegra_display_hub_cleanup(tegra->hub);\n\n\terr = host1x_device_exit(dev);\n\tif (err < 0)\n\t\tdev_err(&dev->dev, \"host1x device cleanup failed: %d\\n\", err);\n\n\tif (tegra->domain) {\n\t\tmutex_destroy(&tegra->mm_lock);\n\t\tdrm_mm_takedown(&tegra->mm);\n\t\tput_iova_domain(&tegra->carveout.domain);\n\t\tiova_cache_put();\n\t\tiommu_domain_free(tegra->domain);\n\t}\n\n\tkfree(tegra);\n\tdrm_dev_put(drm);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int host1x_drm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int host1x_drm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(drm);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(host1x_drm_pm_ops, host1x_drm_suspend,\n\t\t\t host1x_drm_resume);\n\nstatic const struct of_device_id host1x_drm_subdevs[] = {\n\t{ .compatible = \"nvidia,tegra20-dc\", },\n\t{ .compatible = \"nvidia,tegra20-hdmi\", },\n\t{ .compatible = \"nvidia,tegra20-gr2d\", },\n\t{ .compatible = \"nvidia,tegra20-gr3d\", },\n\t{ .compatible = \"nvidia,tegra30-dc\", },\n\t{ .compatible = \"nvidia,tegra30-hdmi\", },\n\t{ .compatible = \"nvidia,tegra30-gr2d\", },\n\t{ .compatible = \"nvidia,tegra30-gr3d\", },\n\t{ .compatible = \"nvidia,tegra114-dc\", },\n\t{ .compatible = \"nvidia,tegra114-dsi\", },\n\t{ .compatible = \"nvidia,tegra114-hdmi\", },\n\t{ .compatible = \"nvidia,tegra114-gr2d\", },\n\t{ .compatible = \"nvidia,tegra114-gr3d\", },\n\t{ .compatible = \"nvidia,tegra124-dc\", },\n\t{ .compatible = \"nvidia,tegra124-sor\", },\n\t{ .compatible = \"nvidia,tegra124-hdmi\", },\n\t{ .compatible = \"nvidia,tegra124-dsi\", },\n\t{ .compatible = \"nvidia,tegra124-vic\", },\n\t{ .compatible = \"nvidia,tegra132-dsi\", },\n\t{ .compatible = \"nvidia,tegra210-dc\", },\n\t{ .compatible = \"nvidia,tegra210-dsi\", },\n\t{ .compatible = \"nvidia,tegra210-sor\", },\n\t{ .compatible = \"nvidia,tegra210-sor1\", },\n\t{ .compatible = \"nvidia,tegra210-vic\", },\n\t{ .compatible = \"nvidia,tegra210-nvdec\", },\n\t{ .compatible = \"nvidia,tegra186-display\", },\n\t{ .compatible = \"nvidia,tegra186-dc\", },\n\t{ .compatible = \"nvidia,tegra186-sor\", },\n\t{ .compatible = \"nvidia,tegra186-sor1\", },\n\t{ .compatible = \"nvidia,tegra186-vic\", },\n\t{ .compatible = \"nvidia,tegra186-nvdec\", },\n\t{ .compatible = \"nvidia,tegra194-display\", },\n\t{ .compatible = \"nvidia,tegra194-dc\", },\n\t{ .compatible = \"nvidia,tegra194-sor\", },\n\t{ .compatible = \"nvidia,tegra194-vic\", },\n\t{ .compatible = \"nvidia,tegra194-nvdec\", },\n\t{ .compatible = \"nvidia,tegra234-vic\", },\n\t{ .compatible = \"nvidia,tegra234-nvdec\", },\n\t{   }\n};\n\nstatic struct host1x_driver host1x_drm_driver = {\n\t.driver = {\n\t\t.name = \"drm\",\n\t\t.pm = &host1x_drm_pm_ops,\n\t},\n\t.probe = host1x_drm_probe,\n\t.remove = host1x_drm_remove,\n\t.subdevs = host1x_drm_subdevs,\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&tegra_display_hub_driver,\n\t&tegra_dc_driver,\n\t&tegra_hdmi_driver,\n\t&tegra_dsi_driver,\n\t&tegra_dpaux_driver,\n\t&tegra_sor_driver,\n\t&tegra_gr2d_driver,\n\t&tegra_gr3d_driver,\n\t&tegra_vic_driver,\n\t&tegra_nvdec_driver,\n};\n\nstatic int __init host1x_drm_init(void)\n{\n\tint err;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\terr = host1x_driver_register(&host1x_drm_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n\tif (err < 0)\n\t\tgoto unregister_host1x;\n\n\treturn 0;\n\nunregister_host1x:\n\thost1x_driver_unregister(&host1x_drm_driver);\n\treturn err;\n}\nmodule_init(host1x_drm_init);\n\nstatic void __exit host1x_drm_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n\thost1x_driver_unregister(&host1x_drm_driver);\n}\nmodule_exit(host1x_drm_exit);\n\nMODULE_AUTHOR(\"Thierry Reding <thierry.reding@avionic-design.de>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra DRM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}