{
  "module_name": "dsi.c",
  "hash_id": "3cf40014a3c8ff6521436e953066617cfae7ce213fb3a263fe30c4c0bd876303",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tegra/dsi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/host1x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_file.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"dc.h\"\n#include \"drm.h\"\n#include \"dsi.h\"\n#include \"mipi-phy.h\"\n#include \"trace.h\"\n\nstruct tegra_dsi_state {\n\tstruct drm_connector_state base;\n\n\tstruct mipi_dphy_timing timing;\n\tunsigned long period;\n\n\tunsigned int vrefresh;\n\tunsigned int lanes;\n\tunsigned long pclk;\n\tunsigned long bclk;\n\n\tenum tegra_dsi_format format;\n\tunsigned int mul;\n\tunsigned int div;\n};\n\nstatic inline struct tegra_dsi_state *\nto_dsi_state(struct drm_connector_state *state)\n{\n\treturn container_of(state, struct tegra_dsi_state, base);\n}\n\nstruct tegra_dsi {\n\tstruct host1x_client client;\n\tstruct tegra_output output;\n\tstruct device *dev;\n\n\tvoid __iomem *regs;\n\n\tstruct reset_control *rst;\n\tstruct clk *clk_parent;\n\tstruct clk *clk_lp;\n\tstruct clk *clk;\n\n\tstruct drm_info_list *debugfs_files;\n\n\tunsigned long flags;\n\tenum mipi_dsi_pixel_format format;\n\tunsigned int lanes;\n\n\tstruct tegra_mipi_device *mipi;\n\tstruct mipi_dsi_host host;\n\n\tstruct regulator *vdd;\n\n\tunsigned int video_fifo_depth;\n\tunsigned int host_fifo_depth;\n\n\t \n\tstruct tegra_dsi *master;\n\tstruct tegra_dsi *slave;\n};\n\nstatic inline struct tegra_dsi *\nhost1x_client_to_dsi(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_dsi, client);\n}\n\nstatic inline struct tegra_dsi *host_to_tegra(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct tegra_dsi, host);\n}\n\nstatic inline struct tegra_dsi *to_dsi(struct tegra_output *output)\n{\n\treturn container_of(output, struct tegra_dsi, output);\n}\n\nstatic struct tegra_dsi_state *tegra_dsi_get_state(struct tegra_dsi *dsi)\n{\n\treturn to_dsi_state(dsi->output.connector.state);\n}\n\nstatic inline u32 tegra_dsi_readl(struct tegra_dsi *dsi, unsigned int offset)\n{\n\tu32 value = readl(dsi->regs + (offset << 2));\n\n\ttrace_dsi_readl(dsi->dev, offset, value);\n\n\treturn value;\n}\n\nstatic inline void tegra_dsi_writel(struct tegra_dsi *dsi, u32 value,\n\t\t\t\t    unsigned int offset)\n{\n\ttrace_dsi_writel(dsi->dev, offset, value);\n\twritel(value, dsi->regs + (offset << 2));\n}\n\n#define DEBUGFS_REG32(_name) { .name = #_name, .offset = _name }\n\nstatic const struct debugfs_reg32 tegra_dsi_regs[] = {\n\tDEBUGFS_REG32(DSI_INCR_SYNCPT),\n\tDEBUGFS_REG32(DSI_INCR_SYNCPT_CONTROL),\n\tDEBUGFS_REG32(DSI_INCR_SYNCPT_ERROR),\n\tDEBUGFS_REG32(DSI_CTXSW),\n\tDEBUGFS_REG32(DSI_RD_DATA),\n\tDEBUGFS_REG32(DSI_WR_DATA),\n\tDEBUGFS_REG32(DSI_POWER_CONTROL),\n\tDEBUGFS_REG32(DSI_INT_ENABLE),\n\tDEBUGFS_REG32(DSI_INT_STATUS),\n\tDEBUGFS_REG32(DSI_INT_MASK),\n\tDEBUGFS_REG32(DSI_HOST_CONTROL),\n\tDEBUGFS_REG32(DSI_CONTROL),\n\tDEBUGFS_REG32(DSI_SOL_DELAY),\n\tDEBUGFS_REG32(DSI_MAX_THRESHOLD),\n\tDEBUGFS_REG32(DSI_TRIGGER),\n\tDEBUGFS_REG32(DSI_TX_CRC),\n\tDEBUGFS_REG32(DSI_STATUS),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_CONTROL),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_0),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_1),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_2),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_3),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_4),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_5),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_6),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_7),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_0_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_0_HI),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_1_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_1_HI),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_2_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_2_HI),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_3_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_3_HI),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_4_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_4_HI),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_5_LO),\n\tDEBUGFS_REG32(DSI_PKT_SEQ_5_HI),\n\tDEBUGFS_REG32(DSI_DCS_CMDS),\n\tDEBUGFS_REG32(DSI_PKT_LEN_0_1),\n\tDEBUGFS_REG32(DSI_PKT_LEN_2_3),\n\tDEBUGFS_REG32(DSI_PKT_LEN_4_5),\n\tDEBUGFS_REG32(DSI_PKT_LEN_6_7),\n\tDEBUGFS_REG32(DSI_PHY_TIMING_0),\n\tDEBUGFS_REG32(DSI_PHY_TIMING_1),\n\tDEBUGFS_REG32(DSI_PHY_TIMING_2),\n\tDEBUGFS_REG32(DSI_BTA_TIMING),\n\tDEBUGFS_REG32(DSI_TIMEOUT_0),\n\tDEBUGFS_REG32(DSI_TIMEOUT_1),\n\tDEBUGFS_REG32(DSI_TO_TALLY),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_0),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_CD),\n\tDEBUGFS_REG32(DSI_PAD_CD_STATUS),\n\tDEBUGFS_REG32(DSI_VIDEO_MODE_CONTROL),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_1),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_2),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_3),\n\tDEBUGFS_REG32(DSI_PAD_CONTROL_4),\n\tDEBUGFS_REG32(DSI_GANGED_MODE_CONTROL),\n\tDEBUGFS_REG32(DSI_GANGED_MODE_START),\n\tDEBUGFS_REG32(DSI_GANGED_MODE_SIZE),\n\tDEBUGFS_REG32(DSI_RAW_DATA_BYTE_COUNT),\n\tDEBUGFS_REG32(DSI_ULTRA_LOW_POWER_CONTROL),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_8),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_9),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_10),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_11),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_12),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_13),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_14),\n\tDEBUGFS_REG32(DSI_INIT_SEQ_DATA_15),\n};\n\nstatic int tegra_dsi_show_regs(struct seq_file *s, void *data)\n{\n\tstruct drm_info_node *node = s->private;\n\tstruct tegra_dsi *dsi = node->info_ent->data;\n\tstruct drm_crtc *crtc = dsi->output.encoder.crtc;\n\tstruct drm_device *drm = node->minor->dev;\n\tunsigned int i;\n\tint err = 0;\n\n\tdrm_modeset_lock_all(drm);\n\n\tif (!crtc || !crtc->state->active) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_dsi_regs); i++) {\n\t\tunsigned int offset = tegra_dsi_regs[i].offset;\n\n\t\tseq_printf(s, \"%-32s %#05x %08x\\n\", tegra_dsi_regs[i].name,\n\t\t\t   offset, tegra_dsi_readl(dsi, offset));\n\t}\n\nunlock:\n\tdrm_modeset_unlock_all(drm);\n\treturn err;\n}\n\nstatic struct drm_info_list debugfs_files[] = {\n\t{ \"regs\", tegra_dsi_show_regs, 0, NULL },\n};\n\nstatic int tegra_dsi_late_register(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tunsigned int i, count = ARRAY_SIZE(debugfs_files);\n\tstruct drm_minor *minor = connector->dev->primary;\n\tstruct dentry *root = connector->debugfs_entry;\n\tstruct tegra_dsi *dsi = to_dsi(output);\n\n\tdsi->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\n\t\t\t\t     GFP_KERNEL);\n\tif (!dsi->debugfs_files)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++)\n\t\tdsi->debugfs_files[i].data = dsi;\n\n\tdrm_debugfs_create_files(dsi->debugfs_files, count, root, minor);\n\n\treturn 0;\n}\n\nstatic void tegra_dsi_early_unregister(struct drm_connector *connector)\n{\n\tstruct tegra_output *output = connector_to_output(connector);\n\tunsigned int count = ARRAY_SIZE(debugfs_files);\n\tstruct tegra_dsi *dsi = to_dsi(output);\n\n\tdrm_debugfs_remove_files(dsi->debugfs_files, count,\n\t\t\t\t connector->dev->primary);\n\tkfree(dsi->debugfs_files);\n\tdsi->debugfs_files = NULL;\n}\n\n#define PKT_ID0(id)\t((((id) & 0x3f) <<  3) | (1 <<  9))\n#define PKT_LEN0(len)\t(((len) & 0x07) <<  0)\n#define PKT_ID1(id)\t((((id) & 0x3f) << 13) | (1 << 19))\n#define PKT_LEN1(len)\t(((len) & 0x07) << 10)\n#define PKT_ID2(id)\t((((id) & 0x3f) << 23) | (1 << 29))\n#define PKT_LEN2(len)\t(((len) & 0x07) << 20)\n\n#define PKT_LP\t\t(1 << 30)\n#define NUM_PKT_SEQ\t12\n\n \nstatic const u32 pkt_seq_video_non_burst_sync_pulses[NUM_PKT_SEQ] = {\n\t[ 0] = PKT_ID0(MIPI_DSI_V_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0) |\n\t       PKT_LP,\n\t[ 1] = 0,\n\t[ 2] = PKT_ID0(MIPI_DSI_V_SYNC_END) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0) |\n\t       PKT_LP,\n\t[ 3] = 0,\n\t[ 4] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0) |\n\t       PKT_LP,\n\t[ 5] = 0,\n\t[ 6] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0),\n\t[ 7] = PKT_ID0(MIPI_DSI_BLANKING_PACKET) | PKT_LEN0(2) |\n\t       PKT_ID1(MIPI_DSI_PACKED_PIXEL_STREAM_24) | PKT_LEN1(3) |\n\t       PKT_ID2(MIPI_DSI_BLANKING_PACKET) | PKT_LEN2(4),\n\t[ 8] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0) |\n\t       PKT_LP,\n\t[ 9] = 0,\n\t[10] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(1) |\n\t       PKT_ID2(MIPI_DSI_H_SYNC_END) | PKT_LEN2(0),\n\t[11] = PKT_ID0(MIPI_DSI_BLANKING_PACKET) | PKT_LEN0(2) |\n\t       PKT_ID1(MIPI_DSI_PACKED_PIXEL_STREAM_24) | PKT_LEN1(3) |\n\t       PKT_ID2(MIPI_DSI_BLANKING_PACKET) | PKT_LEN2(4),\n};\n\n \nstatic const u32 pkt_seq_video_non_burst_sync_events[NUM_PKT_SEQ] = {\n\t[ 0] = PKT_ID0(MIPI_DSI_V_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_END_OF_TRANSMISSION) | PKT_LEN1(7) |\n\t       PKT_LP,\n\t[ 1] = 0,\n\t[ 2] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_END_OF_TRANSMISSION) | PKT_LEN1(7) |\n\t       PKT_LP,\n\t[ 3] = 0,\n\t[ 4] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_END_OF_TRANSMISSION) | PKT_LEN1(7) |\n\t       PKT_LP,\n\t[ 5] = 0,\n\t[ 6] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(2) |\n\t       PKT_ID2(MIPI_DSI_PACKED_PIXEL_STREAM_24) | PKT_LEN2(3),\n\t[ 7] = PKT_ID0(MIPI_DSI_BLANKING_PACKET) | PKT_LEN0(4),\n\t[ 8] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_END_OF_TRANSMISSION) | PKT_LEN1(7) |\n\t       PKT_LP,\n\t[ 9] = 0,\n\t[10] = PKT_ID0(MIPI_DSI_H_SYNC_START) | PKT_LEN0(0) |\n\t       PKT_ID1(MIPI_DSI_BLANKING_PACKET) | PKT_LEN1(2) |\n\t       PKT_ID2(MIPI_DSI_PACKED_PIXEL_STREAM_24) | PKT_LEN2(3),\n\t[11] = PKT_ID0(MIPI_DSI_BLANKING_PACKET) | PKT_LEN0(4),\n};\n\nstatic const u32 pkt_seq_command_mode[NUM_PKT_SEQ] = {\n\t[ 0] = 0,\n\t[ 1] = 0,\n\t[ 2] = 0,\n\t[ 3] = 0,\n\t[ 4] = 0,\n\t[ 5] = 0,\n\t[ 6] = PKT_ID0(MIPI_DSI_DCS_LONG_WRITE) | PKT_LEN0(3) | PKT_LP,\n\t[ 7] = 0,\n\t[ 8] = 0,\n\t[ 9] = 0,\n\t[10] = PKT_ID0(MIPI_DSI_DCS_LONG_WRITE) | PKT_LEN0(5) | PKT_LP,\n\t[11] = 0,\n};\n\nstatic void tegra_dsi_set_phy_timing(struct tegra_dsi *dsi,\n\t\t\t\t     unsigned long period,\n\t\t\t\t     const struct mipi_dphy_timing *timing)\n{\n\tu32 value;\n\n\tvalue = DSI_TIMING_FIELD(timing->hsexit, period, 1) << 24 |\n\t\tDSI_TIMING_FIELD(timing->hstrail, period, 0) << 16 |\n\t\tDSI_TIMING_FIELD(timing->hszero, period, 3) << 8 |\n\t\tDSI_TIMING_FIELD(timing->hsprepare, period, 1);\n\ttegra_dsi_writel(dsi, value, DSI_PHY_TIMING_0);\n\n\tvalue = DSI_TIMING_FIELD(timing->clktrail, period, 1) << 24 |\n\t\tDSI_TIMING_FIELD(timing->clkpost, period, 1) << 16 |\n\t\tDSI_TIMING_FIELD(timing->clkzero, period, 1) << 8 |\n\t\tDSI_TIMING_FIELD(timing->lpx, period, 1);\n\ttegra_dsi_writel(dsi, value, DSI_PHY_TIMING_1);\n\n\tvalue = DSI_TIMING_FIELD(timing->clkprepare, period, 1) << 16 |\n\t\tDSI_TIMING_FIELD(timing->clkpre, period, 1) << 8 |\n\t\tDSI_TIMING_FIELD(0xff * period, period, 0) << 0;\n\ttegra_dsi_writel(dsi, value, DSI_PHY_TIMING_2);\n\n\tvalue = DSI_TIMING_FIELD(timing->taget, period, 1) << 16 |\n\t\tDSI_TIMING_FIELD(timing->tasure, period, 1) << 8 |\n\t\tDSI_TIMING_FIELD(timing->tago, period, 1);\n\ttegra_dsi_writel(dsi, value, DSI_BTA_TIMING);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_set_phy_timing(dsi->slave, period, timing);\n}\n\nstatic int tegra_dsi_get_muldiv(enum mipi_dsi_pixel_format format,\n\t\t\t\tunsigned int *mulp, unsigned int *divp)\n{\n\tswitch (format) {\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\tcase MIPI_DSI_FMT_RGB888:\n\t\t*mulp = 3;\n\t\t*divp = 1;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB565:\n\t\t*mulp = 2;\n\t\t*divp = 1;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB666:\n\t\t*mulp = 9;\n\t\t*divp = 4;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_get_format(enum mipi_dsi_pixel_format format,\n\t\t\t\tenum tegra_dsi_format *fmt)\n{\n\tswitch (format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\t*fmt = TEGRA_DSI_FORMAT_24P;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB666:\n\t\t*fmt = TEGRA_DSI_FORMAT_18NP;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\t*fmt = TEGRA_DSI_FORMAT_18P;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB565:\n\t\t*fmt = TEGRA_DSI_FORMAT_16P;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_dsi_ganged_enable(struct tegra_dsi *dsi, unsigned int start,\n\t\t\t\t    unsigned int size)\n{\n\tu32 value;\n\n\ttegra_dsi_writel(dsi, start, DSI_GANGED_MODE_START);\n\ttegra_dsi_writel(dsi, size << 16 | size, DSI_GANGED_MODE_SIZE);\n\n\tvalue = DSI_GANGED_MODE_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_GANGED_MODE_CONTROL);\n}\n\nstatic void tegra_dsi_enable(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\tvalue |= DSI_POWER_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_POWER_CONTROL);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_enable(dsi->slave);\n}\n\nstatic unsigned int tegra_dsi_get_lanes(struct tegra_dsi *dsi)\n{\n\tif (dsi->master)\n\t\treturn dsi->master->lanes + dsi->lanes;\n\n\tif (dsi->slave)\n\t\treturn dsi->lanes + dsi->slave->lanes;\n\n\treturn dsi->lanes;\n}\n\nstatic void tegra_dsi_configure(struct tegra_dsi *dsi, unsigned int pipe,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tunsigned int hact, hsw, hbp, hfp, i, mul, div;\n\tstruct tegra_dsi_state *state;\n\tconst u32 *pkt_seq;\n\tu32 value;\n\n\t \n\tif (dsi->master)\n\t\tstate = tegra_dsi_get_state(dsi->master);\n\telse\n\t\tstate = tegra_dsi_get_state(dsi);\n\n\tmul = state->mul;\n\tdiv = state->div;\n\n\tif (dsi->flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\tDRM_DEBUG_KMS(\"Non-burst video mode with sync pulses\\n\");\n\t\tpkt_seq = pkt_seq_video_non_burst_sync_pulses;\n\t} else if (dsi->flags & MIPI_DSI_MODE_VIDEO) {\n\t\tDRM_DEBUG_KMS(\"Non-burst video mode with sync events\\n\");\n\t\tpkt_seq = pkt_seq_video_non_burst_sync_events;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"Command mode\\n\");\n\t\tpkt_seq = pkt_seq_command_mode;\n\t}\n\n\tvalue = DSI_CONTROL_CHANNEL(0) |\n\t\tDSI_CONTROL_FORMAT(state->format) |\n\t\tDSI_CONTROL_LANES(dsi->lanes - 1) |\n\t\tDSI_CONTROL_SOURCE(pipe);\n\ttegra_dsi_writel(dsi, value, DSI_CONTROL);\n\n\ttegra_dsi_writel(dsi, dsi->video_fifo_depth, DSI_MAX_THRESHOLD);\n\n\tvalue = DSI_HOST_CONTROL_HS;\n\ttegra_dsi_writel(dsi, value, DSI_HOST_CONTROL);\n\n\tvalue = tegra_dsi_readl(dsi, DSI_CONTROL);\n\n\tif (dsi->flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)\n\t\tvalue |= DSI_CONTROL_HS_CLK_CTRL;\n\n\tvalue &= ~DSI_CONTROL_TX_TRIG(3);\n\n\t \n\tif (dsi->flags & MIPI_DSI_MODE_VIDEO)\n\t\tvalue &= ~DSI_CONTROL_DCS_ENABLE;\n\telse\n\t\tvalue |= DSI_CONTROL_DCS_ENABLE;\n\n\tvalue |= DSI_CONTROL_VIDEO_ENABLE;\n\tvalue &= ~DSI_CONTROL_HOST_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_CONTROL);\n\n\tfor (i = 0; i < NUM_PKT_SEQ; i++)\n\t\ttegra_dsi_writel(dsi, pkt_seq[i], DSI_PKT_SEQ_0_LO + i);\n\n\tif (dsi->flags & MIPI_DSI_MODE_VIDEO) {\n\t\t \n\t\thact = mode->hdisplay * mul / div;\n\n\t\t \n\t\thsw = (mode->hsync_end - mode->hsync_start) * mul / div;\n\n\t\t \n\t\thbp = (mode->htotal - mode->hsync_end) * mul / div;\n\n\t\tif ((dsi->flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) == 0)\n\t\t\thbp += hsw;\n\n\t\t \n\t\thfp = (mode->hsync_start - mode->hdisplay) * mul / div;\n\n\t\t \n\t\thsw -= 10;\n\t\thbp -= 14;\n\t\thfp -= 8;\n\n\t\ttegra_dsi_writel(dsi, hsw << 16 | 0, DSI_PKT_LEN_0_1);\n\t\ttegra_dsi_writel(dsi, hact << 16 | hbp, DSI_PKT_LEN_2_3);\n\t\ttegra_dsi_writel(dsi, hfp, DSI_PKT_LEN_4_5);\n\t\ttegra_dsi_writel(dsi, 0x0f0f << 16, DSI_PKT_LEN_6_7);\n\n\t\t \n\t\ttegra_dsi_writel(dsi, 8 * mul / div, DSI_SOL_DELAY);\n\n\t\t \n\t} else {\n\t\tu16 bytes;\n\n\t\tif (dsi->master || dsi->slave) {\n\t\t\t \n\t\t\tbytes = 1 + (mode->hdisplay / 2) * mul / div;\n\t\t} else {\n\t\t\t \n\t\t\tbytes = 1 + mode->hdisplay * mul / div;\n\t\t}\n\n\t\ttegra_dsi_writel(dsi, 0, DSI_PKT_LEN_0_1);\n\t\ttegra_dsi_writel(dsi, bytes << 16, DSI_PKT_LEN_2_3);\n\t\ttegra_dsi_writel(dsi, bytes << 16, DSI_PKT_LEN_4_5);\n\t\ttegra_dsi_writel(dsi, 0, DSI_PKT_LEN_6_7);\n\n\t\tvalue = MIPI_DCS_WRITE_MEMORY_START << 8 |\n\t\t\tMIPI_DCS_WRITE_MEMORY_CONTINUE;\n\t\ttegra_dsi_writel(dsi, value, DSI_DCS_CMDS);\n\n\t\t \n\t\tif (dsi->master || dsi->slave) {\n\t\t\tunsigned long delay, bclk, bclk_ganged;\n\t\t\tunsigned int lanes = state->lanes;\n\n\t\t\t \n\t\t\tdelay = 4 + 4 + 2;\n\t\t\tdelay = DIV_ROUND_UP(delay * mul, div * lanes);\n\t\t\t \n\t\t\tdelay = delay + 6;\n\n\t\t\tbclk = DIV_ROUND_UP(mode->htotal * mul, div * lanes);\n\t\t\tbclk_ganged = DIV_ROUND_UP(bclk * lanes / 2, lanes);\n\t\t\tvalue = bclk - bclk_ganged + delay + 20;\n\t\t} else {\n\t\t\t \n\t\t\tvalue = 8 * mul / div;\n\t\t}\n\n\t\ttegra_dsi_writel(dsi, value, DSI_SOL_DELAY);\n\t}\n\n\tif (dsi->slave) {\n\t\ttegra_dsi_configure(dsi->slave, pipe, mode);\n\n\t\t \n\t\ttegra_dsi_ganged_enable(dsi, 0, mode->hdisplay / 2);\n\t\ttegra_dsi_ganged_enable(dsi->slave, mode->hdisplay / 2,\n\t\t\t\t\tmode->hdisplay / 2);\n\t}\n}\n\nstatic int tegra_dsi_wait_idle(struct tegra_dsi *dsi, unsigned long timeout)\n{\n\tu32 value;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = tegra_dsi_readl(dsi, DSI_STATUS);\n\t\tif (value & DSI_STATUS_IDLE)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void tegra_dsi_video_disable(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\n\tvalue = tegra_dsi_readl(dsi, DSI_CONTROL);\n\tvalue &= ~DSI_CONTROL_VIDEO_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_CONTROL);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_video_disable(dsi->slave);\n}\n\nstatic void tegra_dsi_ganged_disable(struct tegra_dsi *dsi)\n{\n\ttegra_dsi_writel(dsi, 0, DSI_GANGED_MODE_START);\n\ttegra_dsi_writel(dsi, 0, DSI_GANGED_MODE_SIZE);\n\ttegra_dsi_writel(dsi, 0, DSI_GANGED_MODE_CONTROL);\n}\n\nstatic int tegra_dsi_pad_enable(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\n\tvalue = DSI_PAD_CONTROL_VS1_PULLDN(0) | DSI_PAD_CONTROL_VS1_PDIO(0);\n\ttegra_dsi_writel(dsi, value, DSI_PAD_CONTROL_0);\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_pad_calibrate(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\tint err;\n\n\t \n\ttegra_dsi_writel(dsi, 0, DSI_PAD_CONTROL_0);\n\ttegra_dsi_writel(dsi, 0, DSI_PAD_CONTROL_1);\n\ttegra_dsi_writel(dsi, 0, DSI_PAD_CONTROL_2);\n\ttegra_dsi_writel(dsi, 0, DSI_PAD_CONTROL_3);\n\ttegra_dsi_writel(dsi, 0, DSI_PAD_CONTROL_4);\n\n\t \n\ttegra_dsi_pad_enable(dsi);\n\n\tvalue = DSI_PAD_SLEW_UP(0x7) | DSI_PAD_SLEW_DN(0x7) |\n\t\tDSI_PAD_LP_UP(0x1) | DSI_PAD_LP_DN(0x1) |\n\t\tDSI_PAD_OUT_CLK(0x0);\n\ttegra_dsi_writel(dsi, value, DSI_PAD_CONTROL_2);\n\n\tvalue = DSI_PAD_PREEMP_PD_CLK(0x3) | DSI_PAD_PREEMP_PU_CLK(0x3) |\n\t\tDSI_PAD_PREEMP_PD(0x03) | DSI_PAD_PREEMP_PU(0x3);\n\ttegra_dsi_writel(dsi, value, DSI_PAD_CONTROL_3);\n\n\terr = tegra_mipi_start_calibration(dsi->mipi);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn tegra_mipi_finish_calibration(dsi->mipi);\n}\n\nstatic void tegra_dsi_set_timeout(struct tegra_dsi *dsi, unsigned long bclk,\n\t\t\t\t  unsigned int vrefresh)\n{\n\tunsigned int timeout;\n\tu32 value;\n\n\t \n\ttimeout = (bclk / vrefresh) / 512;\n\tvalue = DSI_TIMEOUT_LRX(0x2000) | DSI_TIMEOUT_HTX(timeout);\n\ttegra_dsi_writel(dsi, value, DSI_TIMEOUT_0);\n\n\t \n\ttimeout = 2 * bclk / 512 * 1000;\n\tvalue = DSI_TIMEOUT_PR(timeout) | DSI_TIMEOUT_TA(0x2000);\n\ttegra_dsi_writel(dsi, value, DSI_TIMEOUT_1);\n\n\tvalue = DSI_TALLY_TA(0) | DSI_TALLY_LRX(0) | DSI_TALLY_HTX(0);\n\ttegra_dsi_writel(dsi, value, DSI_TO_TALLY);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_set_timeout(dsi->slave, bclk, vrefresh);\n}\n\nstatic void tegra_dsi_disable(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\n\tif (dsi->slave) {\n\t\ttegra_dsi_ganged_disable(dsi->slave);\n\t\ttegra_dsi_ganged_disable(dsi);\n\t}\n\n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\tvalue &= ~DSI_POWER_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_POWER_CONTROL);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_disable(dsi->slave);\n\n\tusleep_range(5000, 10000);\n}\n\nstatic void tegra_dsi_soft_reset(struct tegra_dsi *dsi)\n{\n\tu32 value;\n\n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\tvalue &= ~DSI_POWER_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_POWER_CONTROL);\n\n\tusleep_range(300, 1000);\n\n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\tvalue |= DSI_POWER_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_POWER_CONTROL);\n\n\tusleep_range(300, 1000);\n\n\tvalue = tegra_dsi_readl(dsi, DSI_TRIGGER);\n\tif (value)\n\t\ttegra_dsi_writel(dsi, 0, DSI_TRIGGER);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_soft_reset(dsi->slave);\n}\n\nstatic void tegra_dsi_connector_reset(struct drm_connector *connector)\n{\n\tstruct tegra_dsi_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\n\n\tif (!state)\n\t\treturn;\n\n\tif (connector->state) {\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\t\tkfree(connector->state);\n\t}\n\n\t__drm_atomic_helper_connector_reset(connector, &state->base);\n}\n\nstatic struct drm_connector_state *\ntegra_dsi_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct tegra_dsi_state *state = to_dsi_state(connector->state);\n\tstruct tegra_dsi_state *copy;\n\n\tcopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector,\n\t\t\t\t\t\t      &copy->base);\n\n\treturn &copy->base;\n}\n\nstatic const struct drm_connector_funcs tegra_dsi_connector_funcs = {\n\t.reset = tegra_dsi_connector_reset,\n\t.detect = tegra_output_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = tegra_output_connector_destroy,\n\t.atomic_duplicate_state = tegra_dsi_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.late_register = tegra_dsi_late_register,\n\t.early_unregister = tegra_dsi_early_unregister,\n};\n\nstatic enum drm_mode_status\ntegra_dsi_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs tegra_dsi_connector_helper_funcs = {\n\t.get_modes = tegra_output_connector_get_modes,\n\t.mode_valid = tegra_dsi_connector_mode_valid,\n};\n\nstatic void tegra_dsi_unprepare(struct tegra_dsi *dsi)\n{\n\tint err;\n\n\tif (dsi->slave)\n\t\ttegra_dsi_unprepare(dsi->slave);\n\n\terr = tegra_mipi_disable(dsi->mipi);\n\tif (err < 0)\n\t\tdev_err(dsi->dev, \"failed to disable MIPI calibration: %d\\n\",\n\t\t\terr);\n\n\terr = host1x_client_suspend(&dsi->client);\n\tif (err < 0)\n\t\tdev_err(dsi->dev, \"failed to suspend: %d\\n\", err);\n}\n\nstatic void tegra_dsi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_dsi *dsi = to_dsi(output);\n\tu32 value;\n\tint err;\n\n\tif (output->panel)\n\t\tdrm_panel_disable(output->panel);\n\n\ttegra_dsi_video_disable(dsi);\n\n\t \n\tif (dc) {\n\t\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\t\tvalue &= ~DSI_ENABLE;\n\t\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\t\ttegra_dc_commit(dc);\n\t}\n\n\terr = tegra_dsi_wait_idle(dsi, 100);\n\tif (err < 0)\n\t\tdev_dbg(dsi->dev, \"failed to idle DSI: %d\\n\", err);\n\n\ttegra_dsi_soft_reset(dsi);\n\n\tif (output->panel)\n\t\tdrm_panel_unprepare(output->panel);\n\n\ttegra_dsi_disable(dsi);\n\n\ttegra_dsi_unprepare(dsi);\n}\n\nstatic int tegra_dsi_prepare(struct tegra_dsi *dsi)\n{\n\tint err;\n\n\terr = host1x_client_resume(&dsi->client);\n\tif (err < 0) {\n\t\tdev_err(dsi->dev, \"failed to resume: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_mipi_enable(dsi->mipi);\n\tif (err < 0)\n\t\tdev_err(dsi->dev, \"failed to enable MIPI calibration: %d\\n\",\n\t\t\terr);\n\n\terr = tegra_dsi_pad_calibrate(dsi);\n\tif (err < 0)\n\t\tdev_err(dsi->dev, \"MIPI calibration failed: %d\\n\", err);\n\n\tif (dsi->slave)\n\t\ttegra_dsi_prepare(dsi->slave);\n\n\treturn 0;\n}\n\nstatic void tegra_dsi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\n\tstruct tegra_dsi *dsi = to_dsi(output);\n\tstruct tegra_dsi_state *state;\n\tu32 value;\n\tint err;\n\n\t \n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\n\tif (value & DSI_POWER_CONTROL_ENABLE)\n\t\ttegra_dsi_disable(dsi);\n\n\terr = tegra_dsi_prepare(dsi);\n\tif (err < 0) {\n\t\tdev_err(dsi->dev, \"failed to prepare: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tstate = tegra_dsi_get_state(dsi);\n\n\ttegra_dsi_set_timeout(dsi, state->bclk, state->vrefresh);\n\n\t \n\ttegra_dsi_set_phy_timing(dsi, state->period * 8, &state->timing);\n\n\tif (output->panel)\n\t\tdrm_panel_prepare(output->panel);\n\n\ttegra_dsi_configure(dsi, dc->pipe, mode);\n\n\t \n\tvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\n\tvalue |= DSI_ENABLE;\n\ttegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\n\n\ttegra_dc_commit(dc);\n\n\t \n\ttegra_dsi_enable(dsi);\n\n\tif (output->panel)\n\t\tdrm_panel_enable(output->panel);\n}\n\nstatic int\ntegra_dsi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct tegra_output *output = encoder_to_output(encoder);\n\tstruct tegra_dsi_state *state = to_dsi_state(conn_state);\n\tstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\n\tstruct tegra_dsi *dsi = to_dsi(output);\n\tunsigned int scdiv;\n\tunsigned long plld;\n\tint err;\n\n\tstate->pclk = crtc_state->mode.clock * 1000;\n\n\terr = tegra_dsi_get_muldiv(dsi->format, &state->mul, &state->div);\n\tif (err < 0)\n\t\treturn err;\n\n\tstate->lanes = tegra_dsi_get_lanes(dsi);\n\n\terr = tegra_dsi_get_format(dsi->format, &state->format);\n\tif (err < 0)\n\t\treturn err;\n\n\tstate->vrefresh = drm_mode_vrefresh(&crtc_state->mode);\n\n\t \n\tstate->bclk = (state->pclk * state->mul) / (state->div * state->lanes);\n\n\tDRM_DEBUG_KMS(\"mul: %u, div: %u, lanes: %u\\n\", state->mul, state->div,\n\t\t      state->lanes);\n\tDRM_DEBUG_KMS(\"format: %u, vrefresh: %u\\n\", state->format,\n\t\t      state->vrefresh);\n\tDRM_DEBUG_KMS(\"bclk: %lu\\n\", state->bclk);\n\n\t \n\tplld = DIV_ROUND_UP(state->bclk * 8, USEC_PER_SEC) * USEC_PER_SEC;\n\tstate->period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, plld);\n\n\terr = mipi_dphy_timing_get_default(&state->timing, state->period);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mipi_dphy_timing_validate(&state->timing, state->period);\n\tif (err < 0) {\n\t\tdev_err(dsi->dev, \"failed to validate D-PHY timing: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tplld /= 2;\n\n\t \n\tscdiv = ((8 * state->mul) / (state->div * state->lanes)) - 2;\n\n\terr = tegra_dc_state_setup_clock(dc, crtc_state, dsi->clk_parent,\n\t\t\t\t\t plld, scdiv);\n\tif (err < 0) {\n\t\tdev_err(output->dev, \"failed to setup CRTC state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic const struct drm_encoder_helper_funcs tegra_dsi_encoder_helper_funcs = {\n\t.disable = tegra_dsi_encoder_disable,\n\t.enable = tegra_dsi_encoder_enable,\n\t.atomic_check = tegra_dsi_encoder_atomic_check,\n};\n\nstatic int tegra_dsi_init(struct host1x_client *client)\n{\n\tstruct drm_device *drm = dev_get_drvdata(client->host);\n\tstruct tegra_dsi *dsi = host1x_client_to_dsi(client);\n\tint err;\n\n\t \n\tif (!dsi->master) {\n\t\tdsi->output.dev = client->dev;\n\n\t\tdrm_connector_init(drm, &dsi->output.connector,\n\t\t\t\t   &tegra_dsi_connector_funcs,\n\t\t\t\t   DRM_MODE_CONNECTOR_DSI);\n\t\tdrm_connector_helper_add(&dsi->output.connector,\n\t\t\t\t\t &tegra_dsi_connector_helper_funcs);\n\t\tdsi->output.connector.dpms = DRM_MODE_DPMS_OFF;\n\n\t\tdrm_simple_encoder_init(drm, &dsi->output.encoder,\n\t\t\t\t\tDRM_MODE_ENCODER_DSI);\n\t\tdrm_encoder_helper_add(&dsi->output.encoder,\n\t\t\t\t       &tegra_dsi_encoder_helper_funcs);\n\n\t\tdrm_connector_attach_encoder(&dsi->output.connector,\n\t\t\t\t\t\t  &dsi->output.encoder);\n\t\tdrm_connector_register(&dsi->output.connector);\n\n\t\terr = tegra_output_init(drm, &dsi->output);\n\t\tif (err < 0)\n\t\t\tdev_err(dsi->dev, \"failed to initialize output: %d\\n\",\n\t\t\t\terr);\n\n\t\tdsi->output.encoder.possible_crtcs = 0x3;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_exit(struct host1x_client *client)\n{\n\tstruct tegra_dsi *dsi = host1x_client_to_dsi(client);\n\n\ttegra_output_exit(&dsi->output);\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_runtime_suspend(struct host1x_client *client)\n{\n\tstruct tegra_dsi *dsi = host1x_client_to_dsi(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\tif (dsi->rst) {\n\t\terr = reset_control_assert(dsi->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to assert reset: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tclk_disable_unprepare(dsi->clk_lp);\n\tclk_disable_unprepare(dsi->clk);\n\n\tregulator_disable(dsi->vdd);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_runtime_resume(struct host1x_client *client)\n{\n\tstruct tegra_dsi *dsi = host1x_client_to_dsi(client);\n\tstruct device *dev = client->dev;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get runtime PM: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = regulator_enable(dsi->vdd);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable VDD supply: %d\\n\", err);\n\t\tgoto put_rpm;\n\t}\n\n\terr = clk_prepare_enable(dsi->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"cannot enable DSI clock: %d\\n\", err);\n\t\tgoto disable_vdd;\n\t}\n\n\terr = clk_prepare_enable(dsi->clk_lp);\n\tif (err < 0) {\n\t\tdev_err(dev, \"cannot enable low-power clock: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tif (dsi->rst) {\n\t\terr = reset_control_deassert(dsi->rst);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"cannot assert reset: %d\\n\", err);\n\t\t\tgoto disable_clk_lp;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_clk_lp:\n\tclk_disable_unprepare(dsi->clk_lp);\ndisable_clk:\n\tclk_disable_unprepare(dsi->clk);\ndisable_vdd:\n\tregulator_disable(dsi->vdd);\nput_rpm:\n\tpm_runtime_put_sync(dev);\n\treturn err;\n}\n\nstatic const struct host1x_client_ops dsi_client_ops = {\n\t.init = tegra_dsi_init,\n\t.exit = tegra_dsi_exit,\n\t.suspend = tegra_dsi_runtime_suspend,\n\t.resume = tegra_dsi_runtime_resume,\n};\n\nstatic int tegra_dsi_setup_clocks(struct tegra_dsi *dsi)\n{\n\tstruct clk *parent;\n\tint err;\n\n\tparent = clk_get_parent(dsi->clk);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\terr = clk_set_parent(parent, dsi->clk_parent);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const char * const error_report[16] = {\n\t\"SoT Error\",\n\t\"SoT Sync Error\",\n\t\"EoT Sync Error\",\n\t\"Escape Mode Entry Command Error\",\n\t\"Low-Power Transmit Sync Error\",\n\t\"Peripheral Timeout Error\",\n\t\"False Control Error\",\n\t\"Contention Detected\",\n\t\"ECC Error, single-bit\",\n\t\"ECC Error, multi-bit\",\n\t\"Checksum Error\",\n\t\"DSI Data Type Not Recognized\",\n\t\"DSI VC ID Invalid\",\n\t\"Invalid Transmission Length\",\n\t\"Reserved\",\n\t\"DSI Protocol Violation\",\n};\n\nstatic ssize_t tegra_dsi_read_response(struct tegra_dsi *dsi,\n\t\t\t\t       const struct mipi_dsi_msg *msg,\n\t\t\t\t       size_t count)\n{\n\tu8 *rx = msg->rx_buf;\n\tunsigned int i, j, k;\n\tsize_t size = 0;\n\tu16 errors;\n\tu32 value;\n\n\t \n\tvalue = tegra_dsi_readl(dsi, DSI_RD_DATA);\n\n\tswitch (value & 0x3f) {\n\tcase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\n\t\terrors = (value >> 8) & 0xffff;\n\t\tdev_dbg(dsi->dev, \"Acknowledge and error report: %04x\\n\",\n\t\t\terrors);\n\t\tfor (i = 0; i < ARRAY_SIZE(error_report); i++)\n\t\t\tif (errors & BIT(i))\n\t\t\t\tdev_dbg(dsi->dev, \"  %2u: %s\\n\", i,\n\t\t\t\t\terror_report[i]);\n\t\tbreak;\n\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\n\t\trx[0] = (value >> 8) & 0xff;\n\t\tsize = 1;\n\t\tbreak;\n\n\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\n\t\trx[0] = (value >>  8) & 0xff;\n\t\trx[1] = (value >> 16) & 0xff;\n\t\tsize = 2;\n\t\tbreak;\n\n\tcase MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:\n\t\tsize = ((value >> 8) & 0xff00) | ((value >> 8) & 0xff);\n\t\tbreak;\n\n\tcase MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:\n\t\tsize = ((value >> 8) & 0xff00) | ((value >> 8) & 0xff);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dsi->dev, \"unhandled response type: %02x\\n\",\n\t\t\tvalue & 0x3f);\n\t\treturn -EPROTO;\n\t}\n\n\tsize = min(size, msg->rx_len);\n\n\tif (msg->rx_buf && size > 0) {\n\t\tfor (i = 0, j = 0; i < count - 1; i++, j += 4) {\n\t\t\tu8 *rx = msg->rx_buf + j;\n\n\t\t\tvalue = tegra_dsi_readl(dsi, DSI_RD_DATA);\n\n\t\t\tfor (k = 0; k < 4 && (j + k) < msg->rx_len; k++)\n\t\t\t\trx[j + k] = (value >> (k << 3)) & 0xff;\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic int tegra_dsi_transmit(struct tegra_dsi *dsi, unsigned long timeout)\n{\n\ttegra_dsi_writel(dsi, DSI_TRIGGER_HOST, DSI_TRIGGER);\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tu32 value = tegra_dsi_readl(dsi, DSI_TRIGGER);\n\t\tif ((value & DSI_TRIGGER_HOST) == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tDRM_DEBUG_KMS(\"timeout waiting for transmission to complete\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_dsi_wait_for_response(struct tegra_dsi *dsi,\n\t\t\t\t       unsigned long timeout)\n{\n\ttimeout = jiffies + msecs_to_jiffies(250);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tu32 value = tegra_dsi_readl(dsi, DSI_STATUS);\n\t\tu8 count = value & 0x1f;\n\n\t\tif (count > 0)\n\t\t\treturn count;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tDRM_DEBUG_KMS(\"peripheral returned no data\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic void tegra_dsi_writesl(struct tegra_dsi *dsi, unsigned long offset,\n\t\t\t      const void *buffer, size_t size)\n{\n\tconst u8 *buf = buffer;\n\tsize_t i, j;\n\tu32 value;\n\n\tfor (j = 0; j < size; j += 4) {\n\t\tvalue = 0;\n\n\t\tfor (i = 0; i < 4 && j + i < size; i++)\n\t\t\tvalue |= buf[j + i] << (i << 3);\n\n\t\ttegra_dsi_writel(dsi, value, DSI_WR_DATA);\n\t}\n}\n\nstatic ssize_t tegra_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct tegra_dsi *dsi = host_to_tegra(host);\n\tstruct mipi_dsi_packet packet;\n\tconst u8 *header;\n\tsize_t count;\n\tssize_t err;\n\tu32 value;\n\n\terr = mipi_dsi_create_packet(&packet, msg);\n\tif (err < 0)\n\t\treturn err;\n\n\theader = packet.header;\n\n\t \n\tif (packet.size > dsi->video_fifo_depth * 4)\n\t\treturn -ENOSPC;\n\n\t \n\tvalue = tegra_dsi_readl(dsi, DSI_STATUS);\n\tif (value & (DSI_STATUS_UNDERFLOW | DSI_STATUS_OVERFLOW)) {\n\t\tvalue = DSI_HOST_CONTROL_FIFO_RESET;\n\t\ttegra_dsi_writel(dsi, value, DSI_HOST_CONTROL);\n\t\tusleep_range(10, 20);\n\t}\n\n\tvalue = tegra_dsi_readl(dsi, DSI_POWER_CONTROL);\n\tvalue |= DSI_POWER_CONTROL_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_POWER_CONTROL);\n\n\tusleep_range(5000, 10000);\n\n\tvalue = DSI_HOST_CONTROL_CRC_RESET | DSI_HOST_CONTROL_TX_TRIG_HOST |\n\t\tDSI_HOST_CONTROL_CS | DSI_HOST_CONTROL_ECC;\n\n\tif ((msg->flags & MIPI_DSI_MSG_USE_LPM) == 0)\n\t\tvalue |= DSI_HOST_CONTROL_HS;\n\n\t \n\tif (packet.size > dsi->host_fifo_depth * 4)\n\t\tvalue |= DSI_HOST_CONTROL_FIFO_SEL;\n\n\ttegra_dsi_writel(dsi, value, DSI_HOST_CONTROL);\n\n\t \n\tif ((msg->flags & MIPI_DSI_MSG_REQ_ACK) ||\n\t    (msg->rx_buf && msg->rx_len > 0)) {\n\t\tvalue = tegra_dsi_readl(dsi, DSI_HOST_CONTROL);\n\t\tvalue |= DSI_HOST_CONTROL_PKT_BTA;\n\t\ttegra_dsi_writel(dsi, value, DSI_HOST_CONTROL);\n\t}\n\n\tvalue = DSI_CONTROL_LANES(0) | DSI_CONTROL_HOST_ENABLE;\n\ttegra_dsi_writel(dsi, value, DSI_CONTROL);\n\n\t \n\tvalue = header[2] << 16 | header[1] << 8 | header[0];\n\ttegra_dsi_writel(dsi, value, DSI_WR_DATA);\n\n\t \n\tif (packet.payload_length > 0)\n\t\ttegra_dsi_writesl(dsi, DSI_WR_DATA, packet.payload,\n\t\t\t\t  packet.payload_length);\n\n\terr = tegra_dsi_transmit(dsi, 250);\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((msg->flags & MIPI_DSI_MSG_REQ_ACK) ||\n\t    (msg->rx_buf && msg->rx_len > 0)) {\n\t\terr = tegra_dsi_wait_for_response(dsi, 250);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tcount = err;\n\n\t\tvalue = tegra_dsi_readl(dsi, DSI_RD_DATA);\n\t\tswitch (value) {\n\t\tcase 0x84:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase 0x87:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dsi->dev, \"unknown status: %08x\\n\", value);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (count > 1) {\n\t\t\terr = tegra_dsi_read_response(dsi, msg, count);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(dsi->dev,\n\t\t\t\t\t\"failed to parse response: %zd\\n\",\n\t\t\t\t\terr);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tcount = err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tcount = 4 + packet.payload_length;\n\t}\n\n\treturn count;\n}\n\nstatic int tegra_dsi_ganged_setup(struct tegra_dsi *dsi)\n{\n\tstruct clk *parent;\n\tint err;\n\n\t \n\tparent = clk_get_parent(dsi->slave->clk);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\terr = clk_set_parent(parent, dsi->clk_parent);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *device)\n{\n\tstruct tegra_dsi *dsi = host_to_tegra(host);\n\n\tdsi->flags = device->mode_flags;\n\tdsi->format = device->format;\n\tdsi->lanes = device->lanes;\n\n\tif (dsi->slave) {\n\t\tint err;\n\n\t\tdev_dbg(dsi->dev, \"attaching dual-channel device %s\\n\",\n\t\t\tdev_name(&device->dev));\n\n\t\terr = tegra_dsi_ganged_setup(dsi);\n\t\tif (err < 0) {\n\t\t\tdev_err(dsi->dev, \"failed to set up ganged mode: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (!dsi->master) {\n\t\tstruct tegra_output *output = &dsi->output;\n\n\t\toutput->panel = of_drm_find_panel(device->dev.of_node);\n\t\tif (IS_ERR(output->panel))\n\t\t\toutput->panel = NULL;\n\n\t\tif (output->panel && output->connector.dev)\n\t\t\tdrm_helper_hpd_irq_event(output->connector.dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t struct mipi_dsi_device *device)\n{\n\tstruct tegra_dsi *dsi = host_to_tegra(host);\n\tstruct tegra_output *output = &dsi->output;\n\n\tif (output->panel && &device->dev == output->panel->dev) {\n\t\toutput->panel = NULL;\n\n\t\tif (output->connector.dev)\n\t\t\tdrm_helper_hpd_irq_event(output->connector.dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops tegra_dsi_host_ops = {\n\t.attach = tegra_dsi_host_attach,\n\t.detach = tegra_dsi_host_detach,\n\t.transfer = tegra_dsi_host_transfer,\n};\n\nstatic int tegra_dsi_ganged_probe(struct tegra_dsi *dsi)\n{\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(dsi->dev->of_node, \"nvidia,ganged-mode\", 0);\n\tif (np) {\n\t\tstruct platform_device *gangster = of_find_device_by_node(np);\n\n\t\tdsi->slave = platform_get_drvdata(gangster);\n\t\tof_node_put(np);\n\n\t\tif (!dsi->slave) {\n\t\t\tput_device(&gangster->dev);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\n\t\tdsi->slave->master = dsi;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_dsi_probe(struct platform_device *pdev)\n{\n\tstruct tegra_dsi *dsi;\n\tstruct resource *regs;\n\tint err;\n\n\tdsi = devm_kzalloc(&pdev->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->output.dev = dsi->dev = &pdev->dev;\n\tdsi->video_fifo_depth = 1920;\n\tdsi->host_fifo_depth = 64;\n\n\terr = tegra_dsi_ganged_probe(dsi);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_output_probe(&dsi->output);\n\tif (err < 0)\n\t\treturn err;\n\n\tdsi->output.connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\t \n\tdsi->flags = MIPI_DSI_MODE_VIDEO;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->lanes = 4;\n\n\tif (!pdev->dev.pm_domain) {\n\t\tdsi->rst = devm_reset_control_get(&pdev->dev, \"dsi\");\n\t\tif (IS_ERR(dsi->rst))\n\t\t\treturn PTR_ERR(dsi->rst);\n\t}\n\n\tdsi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dsi->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk),\n\t\t\t\t     \"cannot get DSI clock\\n\");\n\n\tdsi->clk_lp = devm_clk_get(&pdev->dev, \"lp\");\n\tif (IS_ERR(dsi->clk_lp))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk_lp),\n\t\t\t\t     \"cannot get low-power clock\\n\");\n\n\tdsi->clk_parent = devm_clk_get(&pdev->dev, \"parent\");\n\tif (IS_ERR(dsi->clk_parent))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk_parent),\n\t\t\t\t     \"cannot get parent clock\\n\");\n\n\tdsi->vdd = devm_regulator_get(&pdev->dev, \"avdd-dsi-csi\");\n\tif (IS_ERR(dsi->vdd))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dsi->vdd),\n\t\t\t\t     \"cannot get VDD supply\\n\");\n\n\terr = tegra_dsi_setup_clocks(dsi);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"cannot setup clocks\\n\");\n\t\treturn err;\n\t}\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tdsi->regs = devm_ioremap_resource(&pdev->dev, regs);\n\tif (IS_ERR(dsi->regs))\n\t\treturn PTR_ERR(dsi->regs);\n\n\tdsi->mipi = tegra_mipi_request(&pdev->dev, pdev->dev.of_node);\n\tif (IS_ERR(dsi->mipi))\n\t\treturn PTR_ERR(dsi->mipi);\n\n\tdsi->host.ops = &tegra_dsi_host_ops;\n\tdsi->host.dev = &pdev->dev;\n\n\terr = mipi_dsi_host_register(&dsi->host);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register DSI host: %d\\n\", err);\n\t\tgoto mipi_free;\n\t}\n\n\tplatform_set_drvdata(pdev, dsi);\n\tpm_runtime_enable(&pdev->dev);\n\n\tINIT_LIST_HEAD(&dsi->client.list);\n\tdsi->client.ops = &dsi_client_ops;\n\tdsi->client.dev = &pdev->dev;\n\n\terr = host1x_client_register(&dsi->client);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register host1x client: %d\\n\",\n\t\t\terr);\n\t\tgoto unregister;\n\t}\n\n\treturn 0;\n\nunregister:\n\tmipi_dsi_host_unregister(&dsi->host);\nmipi_free:\n\ttegra_mipi_free(dsi->mipi);\n\treturn err;\n}\n\nstatic void tegra_dsi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_dsi *dsi = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\thost1x_client_unregister(&dsi->client);\n\n\ttegra_output_remove(&dsi->output);\n\n\tmipi_dsi_host_unregister(&dsi->host);\n\ttegra_mipi_free(dsi->mipi);\n}\n\nstatic const struct of_device_id tegra_dsi_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-dsi\", },\n\t{ .compatible = \"nvidia,tegra132-dsi\", },\n\t{ .compatible = \"nvidia,tegra124-dsi\", },\n\t{ .compatible = \"nvidia,tegra114-dsi\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_dsi_of_match);\n\nstruct platform_driver tegra_dsi_driver = {\n\t.driver = {\n\t\t.name = \"tegra-dsi\",\n\t\t.of_match_table = tegra_dsi_of_match,\n\t},\n\t.probe = tegra_dsi_probe,\n\t.remove_new = tegra_dsi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}