{
  "module_name": "drm_syncobj.c",
  "hash_id": "1b1cdfd21e65c040dca184947344de41594044135109a420ae30d21d1d69a97a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_syncobj.c",
  "human_readable_source": " \n\n \n\n#include <linux/anon_inodes.h>\n#include <linux/dma-fence-unwrap.h>\n#include <linux/eventfd.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/sync_file.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_print.h>\n#include <drm/drm_syncobj.h>\n#include <drm/drm_utils.h>\n\n#include \"drm_internal.h\"\n\nstruct syncobj_wait_entry {\n\tstruct list_head node;\n\tstruct task_struct *task;\n\tstruct dma_fence *fence;\n\tstruct dma_fence_cb fence_cb;\n\tu64    point;\n};\n\nstatic void syncobj_wait_syncobj_func(struct drm_syncobj *syncobj,\n\t\t\t\t      struct syncobj_wait_entry *wait);\n\nstruct syncobj_eventfd_entry {\n\tstruct list_head node;\n\tstruct dma_fence *fence;\n\tstruct dma_fence_cb fence_cb;\n\tstruct drm_syncobj *syncobj;\n\tstruct eventfd_ctx *ev_fd_ctx;\n\tu64 point;\n\tu32 flags;\n};\n\nstatic void\nsyncobj_eventfd_entry_func(struct drm_syncobj *syncobj,\n\t\t\t   struct syncobj_eventfd_entry *entry);\n\n \nstruct drm_syncobj *drm_syncobj_find(struct drm_file *file_private,\n\t\t\t\t     u32 handle)\n{\n\tstruct drm_syncobj *syncobj;\n\n\tspin_lock(&file_private->syncobj_table_lock);\n\n\t \n\tsyncobj = idr_find(&file_private->syncobj_idr, handle);\n\tif (syncobj)\n\t\tdrm_syncobj_get(syncobj);\n\n\tspin_unlock(&file_private->syncobj_table_lock);\n\n\treturn syncobj;\n}\nEXPORT_SYMBOL(drm_syncobj_find);\n\nstatic void drm_syncobj_fence_add_wait(struct drm_syncobj *syncobj,\n\t\t\t\t       struct syncobj_wait_entry *wait)\n{\n\tstruct dma_fence *fence;\n\n\tif (wait->fence)\n\t\treturn;\n\n\tspin_lock(&syncobj->lock);\n\t \n\tfence = dma_fence_get(rcu_dereference_protected(syncobj->fence, 1));\n\tif (!fence || dma_fence_chain_find_seqno(&fence, wait->point)) {\n\t\tdma_fence_put(fence);\n\t\tlist_add_tail(&wait->node, &syncobj->cb_list);\n\t} else if (!fence) {\n\t\twait->fence = dma_fence_get_stub();\n\t} else {\n\t\twait->fence = fence;\n\t}\n\tspin_unlock(&syncobj->lock);\n}\n\nstatic void drm_syncobj_remove_wait(struct drm_syncobj *syncobj,\n\t\t\t\t    struct syncobj_wait_entry *wait)\n{\n\tif (!wait->node.next)\n\t\treturn;\n\n\tspin_lock(&syncobj->lock);\n\tlist_del_init(&wait->node);\n\tspin_unlock(&syncobj->lock);\n}\n\nstatic void\nsyncobj_eventfd_entry_free(struct syncobj_eventfd_entry *entry)\n{\n\teventfd_ctx_put(entry->ev_fd_ctx);\n\tdma_fence_put(entry->fence);\n\t \n\tlist_del(&entry->node);\n\tkfree(entry);\n}\n\nstatic void\ndrm_syncobj_add_eventfd(struct drm_syncobj *syncobj,\n\t\t\tstruct syncobj_eventfd_entry *entry)\n{\n\tspin_lock(&syncobj->lock);\n\tlist_add_tail(&entry->node, &syncobj->ev_fd_list);\n\tsyncobj_eventfd_entry_func(syncobj, entry);\n\tspin_unlock(&syncobj->lock);\n}\n\n \nvoid drm_syncobj_add_point(struct drm_syncobj *syncobj,\n\t\t\t   struct dma_fence_chain *chain,\n\t\t\t   struct dma_fence *fence,\n\t\t\t   uint64_t point)\n{\n\tstruct syncobj_wait_entry *wait_cur, *wait_tmp;\n\tstruct syncobj_eventfd_entry *ev_fd_cur, *ev_fd_tmp;\n\tstruct dma_fence *prev;\n\n\tdma_fence_get(fence);\n\n\tspin_lock(&syncobj->lock);\n\n\tprev = drm_syncobj_fence_get(syncobj);\n\t \n\tif (prev && prev->seqno >= point)\n\t\tDRM_DEBUG(\"You are adding an unorder point to timeline!\\n\");\n\tdma_fence_chain_init(chain, prev, fence, point);\n\trcu_assign_pointer(syncobj->fence, &chain->base);\n\n\tlist_for_each_entry_safe(wait_cur, wait_tmp, &syncobj->cb_list, node)\n\t\tsyncobj_wait_syncobj_func(syncobj, wait_cur);\n\tlist_for_each_entry_safe(ev_fd_cur, ev_fd_tmp, &syncobj->ev_fd_list, node)\n\t\tsyncobj_eventfd_entry_func(syncobj, ev_fd_cur);\n\tspin_unlock(&syncobj->lock);\n\n\t \n\tdma_fence_chain_for_each(fence, prev);\n\tdma_fence_put(prev);\n}\nEXPORT_SYMBOL(drm_syncobj_add_point);\n\n \nvoid drm_syncobj_replace_fence(struct drm_syncobj *syncobj,\n\t\t\t       struct dma_fence *fence)\n{\n\tstruct dma_fence *old_fence;\n\tstruct syncobj_wait_entry *wait_cur, *wait_tmp;\n\tstruct syncobj_eventfd_entry *ev_fd_cur, *ev_fd_tmp;\n\n\tif (fence)\n\t\tdma_fence_get(fence);\n\n\tspin_lock(&syncobj->lock);\n\n\told_fence = rcu_dereference_protected(syncobj->fence,\n\t\t\t\t\t      lockdep_is_held(&syncobj->lock));\n\trcu_assign_pointer(syncobj->fence, fence);\n\n\tif (fence != old_fence) {\n\t\tlist_for_each_entry_safe(wait_cur, wait_tmp, &syncobj->cb_list, node)\n\t\t\tsyncobj_wait_syncobj_func(syncobj, wait_cur);\n\t\tlist_for_each_entry_safe(ev_fd_cur, ev_fd_tmp, &syncobj->ev_fd_list, node)\n\t\t\tsyncobj_eventfd_entry_func(syncobj, ev_fd_cur);\n\t}\n\n\tspin_unlock(&syncobj->lock);\n\n\tdma_fence_put(old_fence);\n}\nEXPORT_SYMBOL(drm_syncobj_replace_fence);\n\n \nstatic int drm_syncobj_assign_null_handle(struct drm_syncobj *syncobj)\n{\n\tstruct dma_fence *fence = dma_fence_allocate_private_stub(ktime_get());\n\n\tif (!fence)\n\t\treturn -ENOMEM;\n\n\tdrm_syncobj_replace_fence(syncobj, fence);\n\tdma_fence_put(fence);\n\treturn 0;\n}\n\n \n#define DRM_SYNCOBJ_WAIT_FOR_SUBMIT_TIMEOUT 5000000000ULL\n \nint drm_syncobj_find_fence(struct drm_file *file_private,\n\t\t\t   u32 handle, u64 point, u64 flags,\n\t\t\t   struct dma_fence **fence)\n{\n\tstruct drm_syncobj *syncobj = drm_syncobj_find(file_private, handle);\n\tstruct syncobj_wait_entry wait;\n\tu64 timeout = nsecs_to_jiffies64(DRM_SYNCOBJ_WAIT_FOR_SUBMIT_TIMEOUT);\n\tint ret;\n\n\tif (!syncobj)\n\t\treturn -ENOENT;\n\n\t \n\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT) {\n\t\tmight_sleep();\n\t\tlockdep_assert_none_held_once();\n\t}\n\n\t*fence = drm_syncobj_fence_get(syncobj);\n\n\tif (*fence) {\n\t\tret = dma_fence_chain_find_seqno(fence, point);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (!*fence)\n\t\t\t\t*fence = dma_fence_get_stub();\n\n\t\t\tgoto out;\n\t\t}\n\t\tdma_fence_put(*fence);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (!(flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT))\n\t\tgoto out;\n\n\tmemset(&wait, 0, sizeof(wait));\n\twait.task = current;\n\twait.point = point;\n\tdrm_syncobj_fence_add_wait(syncobj, &wait);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (wait.fence) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n                if (timeout == 0) {\n                        ret = -ETIME;\n                        break;\n                }\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n                timeout = schedule_timeout(timeout);\n\t} while (1);\n\n\t__set_current_state(TASK_RUNNING);\n\t*fence = wait.fence;\n\n\tif (wait.node.next)\n\t\tdrm_syncobj_remove_wait(syncobj, &wait);\n\nout:\n\tdrm_syncobj_put(syncobj);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_syncobj_find_fence);\n\n \nvoid drm_syncobj_free(struct kref *kref)\n{\n\tstruct drm_syncobj *syncobj = container_of(kref,\n\t\t\t\t\t\t   struct drm_syncobj,\n\t\t\t\t\t\t   refcount);\n\tstruct syncobj_eventfd_entry *ev_fd_cur, *ev_fd_tmp;\n\n\tdrm_syncobj_replace_fence(syncobj, NULL);\n\n\tlist_for_each_entry_safe(ev_fd_cur, ev_fd_tmp, &syncobj->ev_fd_list, node)\n\t\tsyncobj_eventfd_entry_free(ev_fd_cur);\n\n\tkfree(syncobj);\n}\nEXPORT_SYMBOL(drm_syncobj_free);\n\n \nint drm_syncobj_create(struct drm_syncobj **out_syncobj, uint32_t flags,\n\t\t       struct dma_fence *fence)\n{\n\tint ret;\n\tstruct drm_syncobj *syncobj;\n\n\tsyncobj = kzalloc(sizeof(struct drm_syncobj), GFP_KERNEL);\n\tif (!syncobj)\n\t\treturn -ENOMEM;\n\n\tkref_init(&syncobj->refcount);\n\tINIT_LIST_HEAD(&syncobj->cb_list);\n\tINIT_LIST_HEAD(&syncobj->ev_fd_list);\n\tspin_lock_init(&syncobj->lock);\n\n\tif (flags & DRM_SYNCOBJ_CREATE_SIGNALED) {\n\t\tret = drm_syncobj_assign_null_handle(syncobj);\n\t\tif (ret < 0) {\n\t\t\tdrm_syncobj_put(syncobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (fence)\n\t\tdrm_syncobj_replace_fence(syncobj, fence);\n\n\t*out_syncobj = syncobj;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_syncobj_create);\n\n \nint drm_syncobj_get_handle(struct drm_file *file_private,\n\t\t\t   struct drm_syncobj *syncobj, u32 *handle)\n{\n\tint ret;\n\n\t \n\tdrm_syncobj_get(syncobj);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&file_private->syncobj_table_lock);\n\tret = idr_alloc(&file_private->syncobj_idr, syncobj, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&file_private->syncobj_table_lock);\n\n\tidr_preload_end();\n\n\tif (ret < 0) {\n\t\tdrm_syncobj_put(syncobj);\n\t\treturn ret;\n\t}\n\n\t*handle = ret;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_syncobj_get_handle);\n\nstatic int drm_syncobj_create_as_handle(struct drm_file *file_private,\n\t\t\t\t\tu32 *handle, uint32_t flags)\n{\n\tint ret;\n\tstruct drm_syncobj *syncobj;\n\n\tret = drm_syncobj_create(&syncobj, flags, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_syncobj_get_handle(file_private, syncobj, handle);\n\tdrm_syncobj_put(syncobj);\n\treturn ret;\n}\n\nstatic int drm_syncobj_destroy(struct drm_file *file_private,\n\t\t\t       u32 handle)\n{\n\tstruct drm_syncobj *syncobj;\n\n\tspin_lock(&file_private->syncobj_table_lock);\n\tsyncobj = idr_remove(&file_private->syncobj_idr, handle);\n\tspin_unlock(&file_private->syncobj_table_lock);\n\n\tif (!syncobj)\n\t\treturn -EINVAL;\n\n\tdrm_syncobj_put(syncobj);\n\treturn 0;\n}\n\nstatic int drm_syncobj_file_release(struct inode *inode, struct file *file)\n{\n\tstruct drm_syncobj *syncobj = file->private_data;\n\n\tdrm_syncobj_put(syncobj);\n\treturn 0;\n}\n\nstatic const struct file_operations drm_syncobj_file_fops = {\n\t.release = drm_syncobj_file_release,\n};\n\n \nint drm_syncobj_get_fd(struct drm_syncobj *syncobj, int *p_fd)\n{\n\tstruct file *file;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"syncobj_file\",\n\t\t\t\t  &drm_syncobj_file_fops,\n\t\t\t\t  syncobj, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tdrm_syncobj_get(syncobj);\n\tfd_install(fd, file);\n\n\t*p_fd = fd;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_syncobj_get_fd);\n\nstatic int drm_syncobj_handle_to_fd(struct drm_file *file_private,\n\t\t\t\t    u32 handle, int *p_fd)\n{\n\tstruct drm_syncobj *syncobj = drm_syncobj_find(file_private, handle);\n\tint ret;\n\n\tif (!syncobj)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_get_fd(syncobj, p_fd);\n\tdrm_syncobj_put(syncobj);\n\treturn ret;\n}\n\nstatic int drm_syncobj_fd_to_handle(struct drm_file *file_private,\n\t\t\t\t    int fd, u32 *handle)\n{\n\tstruct drm_syncobj *syncobj;\n\tstruct fd f = fdget(fd);\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EINVAL;\n\n\tif (f.file->f_op != &drm_syncobj_file_fops) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsyncobj = f.file->private_data;\n\tdrm_syncobj_get(syncobj);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&file_private->syncobj_table_lock);\n\tret = idr_alloc(&file_private->syncobj_idr, syncobj, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&file_private->syncobj_table_lock);\n\tidr_preload_end();\n\n\tif (ret > 0) {\n\t\t*handle = ret;\n\t\tret = 0;\n\t} else\n\t\tdrm_syncobj_put(syncobj);\n\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int drm_syncobj_import_sync_file_fence(struct drm_file *file_private,\n\t\t\t\t\t      int fd, int handle)\n{\n\tstruct dma_fence *fence = sync_file_get_fence(fd);\n\tstruct drm_syncobj *syncobj;\n\n\tif (!fence)\n\t\treturn -EINVAL;\n\n\tsyncobj = drm_syncobj_find(file_private, handle);\n\tif (!syncobj) {\n\t\tdma_fence_put(fence);\n\t\treturn -ENOENT;\n\t}\n\n\tdrm_syncobj_replace_fence(syncobj, fence);\n\tdma_fence_put(fence);\n\tdrm_syncobj_put(syncobj);\n\treturn 0;\n}\n\nstatic int drm_syncobj_export_sync_file(struct drm_file *file_private,\n\t\t\t\t\tint handle, int *p_fd)\n{\n\tint ret;\n\tstruct dma_fence *fence;\n\tstruct sync_file *sync_file;\n\tint fd = get_unused_fd_flags(O_CLOEXEC);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = drm_syncobj_find_fence(file_private, handle, 0, 0, &fence);\n\tif (ret)\n\t\tgoto err_put_fd;\n\n\tsync_file = sync_file_create(fence);\n\n\tdma_fence_put(fence);\n\n\tif (!sync_file) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_fd;\n\t}\n\n\tfd_install(fd, sync_file->file);\n\n\t*p_fd = fd;\n\treturn 0;\nerr_put_fd:\n\tput_unused_fd(fd);\n\treturn ret;\n}\n \nvoid\ndrm_syncobj_open(struct drm_file *file_private)\n{\n\tidr_init_base(&file_private->syncobj_idr, 1);\n\tspin_lock_init(&file_private->syncobj_table_lock);\n}\n\nstatic int\ndrm_syncobj_release_handle(int id, void *ptr, void *data)\n{\n\tstruct drm_syncobj *syncobj = ptr;\n\n\tdrm_syncobj_put(syncobj);\n\treturn 0;\n}\n\n \nvoid\ndrm_syncobj_release(struct drm_file *file_private)\n{\n\tidr_for_each(&file_private->syncobj_idr,\n\t\t     &drm_syncobj_release_handle, file_private);\n\tidr_destroy(&file_private->syncobj_idr);\n}\n\nint\ndrm_syncobj_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_private)\n{\n\tstruct drm_syncobj_create *args = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (args->flags & ~DRM_SYNCOBJ_CREATE_SIGNALED)\n\t\treturn -EINVAL;\n\n\treturn drm_syncobj_create_as_handle(file_private,\n\t\t\t\t\t    &args->handle, args->flags);\n}\n\nint\ndrm_syncobj_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_private)\n{\n\tstruct drm_syncobj_destroy *args = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (args->pad)\n\t\treturn -EINVAL;\n\treturn drm_syncobj_destroy(file_private, args->handle);\n}\n\nint\ndrm_syncobj_handle_to_fd_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file_private)\n{\n\tstruct drm_syncobj_handle *args = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (args->flags != 0 &&\n\t    args->flags != DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE)\n\t\treturn -EINVAL;\n\n\tif (args->flags & DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE)\n\t\treturn drm_syncobj_export_sync_file(file_private, args->handle,\n\t\t\t\t\t\t    &args->fd);\n\n\treturn drm_syncobj_handle_to_fd(file_private, args->handle,\n\t\t\t\t\t&args->fd);\n}\n\nint\ndrm_syncobj_fd_to_handle_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file_private)\n{\n\tstruct drm_syncobj_handle *args = data;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (args->flags != 0 &&\n\t    args->flags != DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE)\n\t\treturn -EINVAL;\n\n\tif (args->flags & DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE)\n\t\treturn drm_syncobj_import_sync_file_fence(file_private,\n\t\t\t\t\t\t\t  args->fd,\n\t\t\t\t\t\t\t  args->handle);\n\n\treturn drm_syncobj_fd_to_handle(file_private, args->fd,\n\t\t\t\t\t&args->handle);\n}\n\nstatic int drm_syncobj_transfer_to_timeline(struct drm_file *file_private,\n\t\t\t\t\t    struct drm_syncobj_transfer *args)\n{\n\tstruct drm_syncobj *timeline_syncobj = NULL;\n\tstruct dma_fence *fence, *tmp;\n\tstruct dma_fence_chain *chain;\n\tint ret;\n\n\ttimeline_syncobj = drm_syncobj_find(file_private, args->dst_handle);\n\tif (!timeline_syncobj) {\n\t\treturn -ENOENT;\n\t}\n\tret = drm_syncobj_find_fence(file_private, args->src_handle,\n\t\t\t\t     args->src_point, args->flags,\n\t\t\t\t     &tmp);\n\tif (ret)\n\t\tgoto err_put_timeline;\n\n\tfence = dma_fence_unwrap_merge(tmp);\n\tdma_fence_put(tmp);\n\tif (!fence) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_timeline;\n\t}\n\n\tchain = dma_fence_chain_alloc();\n\tif (!chain) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_fence;\n\t}\n\n\tdrm_syncobj_add_point(timeline_syncobj, chain, fence, args->dst_point);\nerr_free_fence:\n\tdma_fence_put(fence);\nerr_put_timeline:\n\tdrm_syncobj_put(timeline_syncobj);\n\n\treturn ret;\n}\n\nstatic int\ndrm_syncobj_transfer_to_binary(struct drm_file *file_private,\n\t\t\t       struct drm_syncobj_transfer *args)\n{\n\tstruct drm_syncobj *binary_syncobj = NULL;\n\tstruct dma_fence *fence;\n\tint ret;\n\n\tbinary_syncobj = drm_syncobj_find(file_private, args->dst_handle);\n\tif (!binary_syncobj)\n\t\treturn -ENOENT;\n\tret = drm_syncobj_find_fence(file_private, args->src_handle,\n\t\t\t\t     args->src_point, args->flags, &fence);\n\tif (ret)\n\t\tgoto err;\n\tdrm_syncobj_replace_fence(binary_syncobj, fence);\n\tdma_fence_put(fence);\nerr:\n\tdrm_syncobj_put(binary_syncobj);\n\n\treturn ret;\n}\nint\ndrm_syncobj_transfer_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_private)\n{\n\tstruct drm_syncobj_transfer *args = data;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (args->dst_point)\n\t\tret = drm_syncobj_transfer_to_timeline(file_private, args);\n\telse\n\t\tret = drm_syncobj_transfer_to_binary(file_private, args);\n\n\treturn ret;\n}\n\nstatic void syncobj_wait_fence_func(struct dma_fence *fence,\n\t\t\t\t    struct dma_fence_cb *cb)\n{\n\tstruct syncobj_wait_entry *wait =\n\t\tcontainer_of(cb, struct syncobj_wait_entry, fence_cb);\n\n\twake_up_process(wait->task);\n}\n\nstatic void syncobj_wait_syncobj_func(struct drm_syncobj *syncobj,\n\t\t\t\t      struct syncobj_wait_entry *wait)\n{\n\tstruct dma_fence *fence;\n\n\t \n\tfence = rcu_dereference_protected(syncobj->fence,\n\t\t\t\t\t  lockdep_is_held(&syncobj->lock));\n\tdma_fence_get(fence);\n\tif (!fence || dma_fence_chain_find_seqno(&fence, wait->point)) {\n\t\tdma_fence_put(fence);\n\t\treturn;\n\t} else if (!fence) {\n\t\twait->fence = dma_fence_get_stub();\n\t} else {\n\t\twait->fence = fence;\n\t}\n\n\twake_up_process(wait->task);\n\tlist_del_init(&wait->node);\n}\n\nstatic signed long drm_syncobj_array_wait_timeout(struct drm_syncobj **syncobjs,\n\t\t\t\t\t\t  void __user *user_points,\n\t\t\t\t\t\t  uint32_t count,\n\t\t\t\t\t\t  uint32_t flags,\n\t\t\t\t\t\t  signed long timeout,\n\t\t\t\t\t\t  uint32_t *idx)\n{\n\tstruct syncobj_wait_entry *entries;\n\tstruct dma_fence *fence;\n\tuint64_t *points;\n\tuint32_t signaled_count, i;\n\n\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT)\n\t\tlockdep_assert_none_held_once();\n\n\tpoints = kmalloc_array(count, sizeof(*points), GFP_KERNEL);\n\tif (points == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!user_points) {\n\t\tmemset(points, 0, count * sizeof(uint64_t));\n\n\t} else if (copy_from_user(points, user_points,\n\t\t\t\t  sizeof(uint64_t) * count)) {\n\t\ttimeout = -EFAULT;\n\t\tgoto err_free_points;\n\t}\n\n\tentries = kcalloc(count, sizeof(*entries), GFP_KERNEL);\n\tif (!entries) {\n\t\ttimeout = -ENOMEM;\n\t\tgoto err_free_points;\n\t}\n\t \n\tsignaled_count = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tentries[i].task = current;\n\t\tentries[i].point = points[i];\n\t\tfence = drm_syncobj_fence_get(syncobjs[i]);\n\t\tif (!fence || dma_fence_chain_find_seqno(&fence, points[i])) {\n\t\t\tdma_fence_put(fence);\n\t\t\tif (flags & (DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT |\n\t\t\t\t     DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ttimeout = -EINVAL;\n\t\t\t\tgoto cleanup_entries;\n\t\t\t}\n\t\t}\n\n\t\tif (fence)\n\t\t\tentries[i].fence = fence;\n\t\telse\n\t\t\tentries[i].fence = dma_fence_get_stub();\n\n\t\tif ((flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE) ||\n\t\t    dma_fence_is_signaled(entries[i].fence)) {\n\t\t\tif (signaled_count == 0 && idx)\n\t\t\t\t*idx = i;\n\t\t\tsignaled_count++;\n\t\t}\n\t}\n\n\tif (signaled_count == count ||\n\t    (signaled_count > 0 &&\n\t     !(flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL)))\n\t\tgoto cleanup_entries;\n\n\t \n\n\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT) {\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tdrm_syncobj_fence_add_wait(syncobjs[i], &entries[i]);\n\t}\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tsignaled_count = 0;\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tfence = entries[i].fence;\n\t\t\tif (!fence)\n\t\t\t\tcontinue;\n\n\t\t\tif ((flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE) ||\n\t\t\t    dma_fence_is_signaled(fence) ||\n\t\t\t    (!entries[i].fence_cb.func &&\n\t\t\t     dma_fence_add_callback(fence,\n\t\t\t\t\t\t    &entries[i].fence_cb,\n\t\t\t\t\t\t    syncobj_wait_fence_func))) {\n\t\t\t\t \n\t\t\t\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL) {\n\t\t\t\t\tsignaled_count++;\n\t\t\t\t} else {\n\t\t\t\t\tif (idx)\n\t\t\t\t\t\t*idx = i;\n\t\t\t\t\tgoto done_waiting;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (signaled_count == count)\n\t\t\tgoto done_waiting;\n\n\t\tif (timeout == 0) {\n\t\t\ttimeout = -ETIME;\n\t\t\tgoto done_waiting;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\ttimeout = -ERESTARTSYS;\n\t\t\tgoto done_waiting;\n\t\t}\n\n\t\ttimeout = schedule_timeout(timeout);\n\t} while (1);\n\ndone_waiting:\n\t__set_current_state(TASK_RUNNING);\n\ncleanup_entries:\n\tfor (i = 0; i < count; ++i) {\n\t\tdrm_syncobj_remove_wait(syncobjs[i], &entries[i]);\n\t\tif (entries[i].fence_cb.func)\n\t\t\tdma_fence_remove_callback(entries[i].fence,\n\t\t\t\t\t\t  &entries[i].fence_cb);\n\t\tdma_fence_put(entries[i].fence);\n\t}\n\tkfree(entries);\n\nerr_free_points:\n\tkfree(points);\n\n\treturn timeout;\n}\n\n \nsigned long drm_timeout_abs_to_jiffies(int64_t timeout_nsec)\n{\n\tktime_t abs_timeout, now;\n\tu64 timeout_ns, timeout_jiffies64;\n\n\t \n\tif (timeout_nsec == 0)\n\t\treturn 0;\n\n\tabs_timeout = ns_to_ktime(timeout_nsec);\n\tnow = ktime_get();\n\n\tif (!ktime_after(abs_timeout, now))\n\t\treturn 0;\n\n\ttimeout_ns = ktime_to_ns(ktime_sub(abs_timeout, now));\n\n\ttimeout_jiffies64 = nsecs_to_jiffies64(timeout_ns);\n\t \n\tif (timeout_jiffies64 >= MAX_SCHEDULE_TIMEOUT - 1)\n\t\treturn MAX_SCHEDULE_TIMEOUT - 1;\n\n\treturn timeout_jiffies64 + 1;\n}\nEXPORT_SYMBOL(drm_timeout_abs_to_jiffies);\n\nstatic int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}\n\nstatic int drm_syncobj_array_find(struct drm_file *file_private,\n\t\t\t\t  void __user *user_handles,\n\t\t\t\t  uint32_t count_handles,\n\t\t\t\t  struct drm_syncobj ***syncobjs_out)\n{\n\tuint32_t i, *handles;\n\tstruct drm_syncobj **syncobjs;\n\tint ret;\n\n\thandles = kmalloc_array(count_handles, sizeof(*handles), GFP_KERNEL);\n\tif (handles == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(handles, user_handles,\n\t\t\t   sizeof(uint32_t) * count_handles)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_handles;\n\t}\n\n\tsyncobjs = kmalloc_array(count_handles, sizeof(*syncobjs), GFP_KERNEL);\n\tif (syncobjs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_handles;\n\t}\n\n\tfor (i = 0; i < count_handles; i++) {\n\t\tsyncobjs[i] = drm_syncobj_find(file_private, handles[i]);\n\t\tif (!syncobjs[i]) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_put_syncobjs;\n\t\t}\n\t}\n\n\tkfree(handles);\n\t*syncobjs_out = syncobjs;\n\treturn 0;\n\nerr_put_syncobjs:\n\twhile (i-- > 0)\n\t\tdrm_syncobj_put(syncobjs[i]);\n\tkfree(syncobjs);\nerr_free_handles:\n\tkfree(handles);\n\n\treturn ret;\n}\n\nstatic void drm_syncobj_array_free(struct drm_syncobj **syncobjs,\n\t\t\t\t   uint32_t count)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdrm_syncobj_put(syncobjs[i]);\n\tkfree(syncobjs);\n}\n\nint\ndrm_syncobj_wait_ioctl(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_private)\n{\n\tstruct drm_syncobj_wait *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->flags & ~(DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL |\n\t\t\t    DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT))\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_syncobj_array_wait(dev, file_private,\n\t\t\t\t     args, NULL, syncobjs, false);\n\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn ret;\n}\n\nint\ndrm_syncobj_timeline_wait_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_private)\n{\n\tstruct drm_syncobj_timeline_wait *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->flags & ~(DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL |\n\t\t\t    DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT |\n\t\t\t    DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE))\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_syncobj_array_wait(dev, file_private,\n\t\t\t\t     NULL, args, syncobjs, true);\n\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn ret;\n}\n\nstatic void syncobj_eventfd_entry_fence_func(struct dma_fence *fence,\n\t\t\t\t\t     struct dma_fence_cb *cb)\n{\n\tstruct syncobj_eventfd_entry *entry =\n\t\tcontainer_of(cb, struct syncobj_eventfd_entry, fence_cb);\n\n\teventfd_signal(entry->ev_fd_ctx, 1);\n\tsyncobj_eventfd_entry_free(entry);\n}\n\nstatic void\nsyncobj_eventfd_entry_func(struct drm_syncobj *syncobj,\n\t\t\t   struct syncobj_eventfd_entry *entry)\n{\n\tint ret;\n\tstruct dma_fence *fence;\n\n\t \n\tfence = dma_fence_get(rcu_dereference_protected(syncobj->fence, 1));\n\tret = dma_fence_chain_find_seqno(&fence, entry->point);\n\tif (ret != 0 || !fence) {\n\t\tdma_fence_put(fence);\n\t\treturn;\n\t}\n\n\tlist_del_init(&entry->node);\n\tentry->fence = fence;\n\n\tif (entry->flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE) {\n\t\teventfd_signal(entry->ev_fd_ctx, 1);\n\t\tsyncobj_eventfd_entry_free(entry);\n\t} else {\n\t\tret = dma_fence_add_callback(fence, &entry->fence_cb,\n\t\t\t\t\t     syncobj_eventfd_entry_fence_func);\n\t\tif (ret == -ENOENT) {\n\t\t\teventfd_signal(entry->ev_fd_ctx, 1);\n\t\t\tsyncobj_eventfd_entry_free(entry);\n\t\t}\n\t}\n}\n\nint\ndrm_syncobj_eventfd_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_private)\n{\n\tstruct drm_syncobj_eventfd *args = data;\n\tstruct drm_syncobj *syncobj;\n\tstruct eventfd_ctx *ev_fd_ctx;\n\tstruct syncobj_eventfd_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->flags & ~DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE)\n\t\treturn -EINVAL;\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tsyncobj = drm_syncobj_find(file_private, args->handle);\n\tif (!syncobj)\n\t\treturn -ENOENT;\n\n\tev_fd_ctx = eventfd_ctx_fdget(args->fd);\n\tif (IS_ERR(ev_fd_ctx))\n\t\treturn PTR_ERR(ev_fd_ctx);\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\teventfd_ctx_put(ev_fd_ctx);\n\t\treturn -ENOMEM;\n\t}\n\tentry->syncobj = syncobj;\n\tentry->ev_fd_ctx = ev_fd_ctx;\n\tentry->point = args->point;\n\tentry->flags = args->flags;\n\n\tdrm_syncobj_add_eventfd(syncobj, entry);\n\tdrm_syncobj_put(syncobj);\n\n\treturn 0;\n}\n\nint\ndrm_syncobj_reset_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_private)\n{\n\tstruct drm_syncobj_array *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tuint32_t i;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < args->count_handles; i++)\n\t\tdrm_syncobj_replace_fence(syncobjs[i], NULL);\n\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn 0;\n}\n\nint\ndrm_syncobj_signal_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_private)\n{\n\tstruct drm_syncobj_array *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tuint32_t i;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < args->count_handles; i++) {\n\t\tret = drm_syncobj_assign_null_handle(syncobjs[i]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn ret;\n}\n\nint\ndrm_syncobj_timeline_signal_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_private)\n{\n\tstruct drm_syncobj_timeline_array *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tstruct dma_fence_chain **chains;\n\tuint64_t *points;\n\tuint32_t i, j;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->flags != 0)\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpoints = kmalloc_array(args->count_handles, sizeof(*points),\n\t\t\t       GFP_KERNEL);\n\tif (!points) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!u64_to_user_ptr(args->points)) {\n\t\tmemset(points, 0, args->count_handles * sizeof(uint64_t));\n\t} else if (copy_from_user(points, u64_to_user_ptr(args->points),\n\t\t\t\t  sizeof(uint64_t) * args->count_handles)) {\n\t\tret = -EFAULT;\n\t\tgoto err_points;\n\t}\n\n\tchains = kmalloc_array(args->count_handles, sizeof(void *), GFP_KERNEL);\n\tif (!chains) {\n\t\tret = -ENOMEM;\n\t\tgoto err_points;\n\t}\n\tfor (i = 0; i < args->count_handles; i++) {\n\t\tchains[i] = dma_fence_chain_alloc();\n\t\tif (!chains[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdma_fence_chain_free(chains[j]);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_chains;\n\t\t}\n\t}\n\n\tfor (i = 0; i < args->count_handles; i++) {\n\t\tstruct dma_fence *fence = dma_fence_get_stub();\n\n\t\tdrm_syncobj_add_point(syncobjs[i], chains[i],\n\t\t\t\t      fence, points[i]);\n\t\tdma_fence_put(fence);\n\t}\nerr_chains:\n\tkfree(chains);\nerr_points:\n\tkfree(points);\nout:\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn ret;\n}\n\nint drm_syncobj_query_ioctl(struct drm_device *dev, void *data,\n\t\t\t    struct drm_file *file_private)\n{\n\tstruct drm_syncobj_timeline_array *args = data;\n\tstruct drm_syncobj **syncobjs;\n\tuint64_t __user *points = u64_to_user_ptr(args->points);\n\tuint32_t i;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_SYNCOBJ_TIMELINE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (args->flags & ~DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED)\n\t\treturn -EINVAL;\n\n\tif (args->count_handles == 0)\n\t\treturn -EINVAL;\n\n\tret = drm_syncobj_array_find(file_private,\n\t\t\t\t     u64_to_user_ptr(args->handles),\n\t\t\t\t     args->count_handles,\n\t\t\t\t     &syncobjs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < args->count_handles; i++) {\n\t\tstruct dma_fence_chain *chain;\n\t\tstruct dma_fence *fence;\n\t\tuint64_t point;\n\n\t\tfence = drm_syncobj_fence_get(syncobjs[i]);\n\t\tchain = to_dma_fence_chain(fence);\n\t\tif (chain) {\n\t\t\tstruct dma_fence *iter, *last_signaled =\n\t\t\t\tdma_fence_get(fence);\n\n\t\t\tif (args->flags &\n\t\t\t    DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED) {\n\t\t\t\tpoint = fence->seqno;\n\t\t\t} else {\n\t\t\t\tdma_fence_chain_for_each(iter, fence) {\n\t\t\t\t\tif (iter->context != fence->context) {\n\t\t\t\t\t\tdma_fence_put(iter);\n\t\t\t\t\t\t \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdma_fence_put(last_signaled);\n\t\t\t\t\tlast_signaled = dma_fence_get(iter);\n\t\t\t\t}\n\t\t\t\tpoint = dma_fence_is_signaled(last_signaled) ?\n\t\t\t\t\tlast_signaled->seqno :\n\t\t\t\t\tto_dma_fence_chain(last_signaled)->prev_seqno;\n\t\t\t}\n\t\t\tdma_fence_put(last_signaled);\n\t\t} else {\n\t\t\tpoint = 0;\n\t\t}\n\t\tdma_fence_put(fence);\n\t\tret = copy_to_user(&points[i], &point, sizeof(uint64_t));\n\t\tret = ret ? -EFAULT : 0;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdrm_syncobj_array_free(syncobjs, args->count_handles);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}