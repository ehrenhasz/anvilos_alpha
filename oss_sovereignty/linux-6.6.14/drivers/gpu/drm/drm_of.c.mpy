{
  "module_name": "drm_of.c",
  "hash_id": "f3ecc2c008908e36d0f74ab9bae0fe4786b66d5b0f68e8cefc5231f849fd9464",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_of.c",
  "human_readable_source": "\n#include <linux/component.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/media-bus-format.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n\n \n\n \nuint32_t drm_of_crtc_port_mask(struct drm_device *dev,\n\t\t\t    struct device_node *port)\n{\n\tunsigned int index = 0;\n\tstruct drm_crtc *tmp;\n\n\tdrm_for_each_crtc(tmp, dev) {\n\t\tif (tmp->port == port)\n\t\t\treturn 1 << index;\n\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_of_crtc_port_mask);\n\n \nuint32_t drm_of_find_possible_crtcs(struct drm_device *dev,\n\t\t\t\t    struct device_node *port)\n{\n\tstruct device_node *remote_port, *ep;\n\tuint32_t possible_crtcs = 0;\n\n\tfor_each_endpoint_of_node(port, ep) {\n\t\tremote_port = of_graph_get_remote_port(ep);\n\t\tif (!remote_port) {\n\t\t\tof_node_put(ep);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpossible_crtcs |= drm_of_crtc_port_mask(dev, remote_port);\n\n\t\tof_node_put(remote_port);\n\t}\n\n\treturn possible_crtcs;\n}\nEXPORT_SYMBOL(drm_of_find_possible_crtcs);\n\n \nvoid drm_of_component_match_add(struct device *master,\n\t\t\t\tstruct component_match **matchptr,\n\t\t\t\tint (*compare)(struct device *, void *),\n\t\t\t\tstruct device_node *node)\n{\n\tof_node_get(node);\n\tcomponent_match_add_release(master, matchptr, component_release_of,\n\t\t\t\t    compare, node);\n}\nEXPORT_SYMBOL_GPL(drm_of_component_match_add);\n\n \nint drm_of_component_probe(struct device *dev,\n\t\t\t   int (*compare_of)(struct device *, void *),\n\t\t\t   const struct component_master_ops *m_ops)\n{\n\tstruct device_node *ep, *port, *remote;\n\tstruct component_match *match = NULL;\n\tint i;\n\n\tif (!dev->of_node)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; ; i++) {\n\t\tport = of_parse_phandle(dev->of_node, \"ports\", i);\n\t\tif (!port)\n\t\t\tbreak;\n\n\t\tif (of_device_is_available(port->parent))\n\t\t\tdrm_of_component_match_add(dev, &match, compare_of,\n\t\t\t\t\t\t   port);\n\n\t\tof_node_put(port);\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(dev, \"missing 'ports' property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!match) {\n\t\tdev_err(dev, \"no available port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; ; i++) {\n\t\tport = of_parse_phandle(dev->of_node, \"ports\", i);\n\t\tif (!port)\n\t\t\tbreak;\n\n\t\tif (!of_device_is_available(port->parent)) {\n\t\t\tof_node_put(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_child_of_node(port, ep) {\n\t\t\tremote = of_graph_get_remote_port_parent(ep);\n\t\t\tif (!remote || !of_device_is_available(remote)) {\n\t\t\t\tof_node_put(remote);\n\t\t\t\tcontinue;\n\t\t\t} else if (!of_device_is_available(remote->parent)) {\n\t\t\t\tdev_warn(dev, \"parent device of %pOF is not available\\n\",\n\t\t\t\t\t remote);\n\t\t\t\tof_node_put(remote);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdrm_of_component_match_add(dev, &match, compare_of,\n\t\t\t\t\t\t   remote);\n\t\t\tof_node_put(remote);\n\t\t}\n\t\tof_node_put(port);\n\t}\n\n\treturn component_master_add_with_match(dev, m_ops, match);\n}\nEXPORT_SYMBOL(drm_of_component_probe);\n\n \nint drm_of_encoder_active_endpoint(struct device_node *node,\n\t\t\t\t   struct drm_encoder *encoder,\n\t\t\t\t   struct of_endpoint *endpoint)\n{\n\tstruct device_node *ep;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct device_node *port;\n\tint ret;\n\n\tif (!node || !crtc)\n\t\treturn -EINVAL;\n\n\tfor_each_endpoint_of_node(node, ep) {\n\t\tport = of_graph_get_remote_port(ep);\n\t\tof_node_put(port);\n\t\tif (port == crtc->port) {\n\t\t\tret = of_graph_parse_endpoint(ep, endpoint);\n\t\t\tof_node_put(ep);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(drm_of_encoder_active_endpoint);\n\n \nint drm_of_find_panel_or_bridge(const struct device_node *np,\n\t\t\t\tint port, int endpoint,\n\t\t\t\tstruct drm_panel **panel,\n\t\t\t\tstruct drm_bridge **bridge)\n{\n\tint ret = -EPROBE_DEFER;\n\tstruct device_node *remote;\n\n\tif (!panel && !bridge)\n\t\treturn -EINVAL;\n\tif (panel)\n\t\t*panel = NULL;\n\n\t \n\tif (!of_graph_is_present(np))\n\t\treturn -ENODEV;\n\n\tremote = of_graph_get_remote_node(np, port, endpoint);\n\tif (!remote)\n\t\treturn -ENODEV;\n\n\tif (panel) {\n\t\t*panel = of_drm_find_panel(remote);\n\t\tif (!IS_ERR(*panel))\n\t\t\tret = 0;\n\t\telse\n\t\t\t*panel = NULL;\n\t}\n\n\t \n\tif (bridge) {\n\t\tif (ret) {\n\t\t\t*bridge = of_drm_find_bridge(remote);\n\t\t\tif (*bridge)\n\t\t\t\tret = 0;\n\t\t} else {\n\t\t\t*bridge = NULL;\n\t\t}\n\n\t}\n\n\tof_node_put(remote);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_of_find_panel_or_bridge);\n\nenum drm_of_lvds_pixels {\n\tDRM_OF_LVDS_EVEN = BIT(0),\n\tDRM_OF_LVDS_ODD = BIT(1),\n};\n\nstatic int drm_of_lvds_get_port_pixels_type(struct device_node *port_node)\n{\n\tbool even_pixels =\n\t\tof_property_read_bool(port_node, \"dual-lvds-even-pixels\");\n\tbool odd_pixels =\n\t\tof_property_read_bool(port_node, \"dual-lvds-odd-pixels\");\n\n\treturn (even_pixels ? DRM_OF_LVDS_EVEN : 0) |\n\t       (odd_pixels ? DRM_OF_LVDS_ODD : 0);\n}\n\nstatic int drm_of_lvds_get_remote_pixels_type(\n\t\t\tconst struct device_node *port_node)\n{\n\tstruct device_node *endpoint = NULL;\n\tint pixels_type = -EPIPE;\n\n\tfor_each_child_of_node(port_node, endpoint) {\n\t\tstruct device_node *remote_port;\n\t\tint current_pt;\n\n\t\tif (!of_node_name_eq(endpoint, \"endpoint\"))\n\t\t\tcontinue;\n\n\t\tremote_port = of_graph_get_remote_port(endpoint);\n\t\tif (!remote_port) {\n\t\t\tof_node_put(endpoint);\n\t\t\treturn -EPIPE;\n\t\t}\n\n\t\tcurrent_pt = drm_of_lvds_get_port_pixels_type(remote_port);\n\t\tof_node_put(remote_port);\n\t\tif (pixels_type < 0)\n\t\t\tpixels_type = current_pt;\n\n\t\t \n\t\tif (!current_pt || pixels_type != current_pt) {\n\t\t\tof_node_put(endpoint);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn pixels_type;\n}\n\n \nint drm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,\n\t\t\t\t\t  const struct device_node *port2)\n{\n\tint remote_p1_pt, remote_p2_pt;\n\n\tif (!port1 || !port2)\n\t\treturn -EINVAL;\n\n\tremote_p1_pt = drm_of_lvds_get_remote_pixels_type(port1);\n\tif (remote_p1_pt < 0)\n\t\treturn remote_p1_pt;\n\n\tremote_p2_pt = drm_of_lvds_get_remote_pixels_type(port2);\n\tif (remote_p2_pt < 0)\n\t\treturn remote_p2_pt;\n\n\t \n\tif (remote_p1_pt + remote_p2_pt != DRM_OF_LVDS_EVEN + DRM_OF_LVDS_ODD)\n\t\treturn -EINVAL;\n\n\treturn remote_p1_pt == DRM_OF_LVDS_EVEN ?\n\t\tDRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS :\n\t\tDRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS;\n}\nEXPORT_SYMBOL_GPL(drm_of_lvds_get_dual_link_pixel_order);\n\n \nint drm_of_lvds_get_data_mapping(const struct device_node *port)\n{\n\tconst char *mapping;\n\tint ret;\n\n\tret = of_property_read_string(port, \"data-mapping\", &mapping);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tif (!strcmp(mapping, \"jeida-18\"))\n\t\treturn MEDIA_BUS_FMT_RGB666_1X7X3_SPWG;\n\tif (!strcmp(mapping, \"jeida-24\"))\n\t\treturn MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA;\n\tif (!strcmp(mapping, \"vesa-24\"))\n\t\treturn MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(drm_of_lvds_get_data_mapping);\n\n \nint drm_of_get_data_lanes_count(const struct device_node *endpoint,\n\t\t\t\tconst unsigned int min, const unsigned int max)\n{\n\tint ret;\n\n\tret = of_property_count_u32_elems(endpoint, \"data-lanes\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret < min || ret > max)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_of_get_data_lanes_count);\n\n \nint drm_of_get_data_lanes_count_ep(const struct device_node *port,\n\t\t\t\t   int port_reg, int reg,\n\t\t\t\t   const unsigned int min,\n\t\t\t\t   const unsigned int max)\n{\n\tstruct device_node *endpoint;\n\tint ret;\n\n\tendpoint = of_graph_get_endpoint_by_regs(port, port_reg, reg);\n\tret = drm_of_get_data_lanes_count(endpoint, min, max);\n\tof_node_put(endpoint);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_of_get_data_lanes_count_ep);\n\n#if IS_ENABLED(CONFIG_DRM_MIPI_DSI)\n\n \nstruct mipi_dsi_host *drm_of_get_dsi_bus(struct device *dev)\n{\n\tstruct mipi_dsi_host *dsi_host;\n\tstruct device_node *endpoint, *dsi_host_node;\n\n\t \n\tendpoint = of_graph_get_next_endpoint(dev->of_node, NULL);\n\tif (!endpoint)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tdsi_host_node = of_graph_get_remote_port_parent(endpoint);\n\tof_node_put(endpoint);\n\tif (!dsi_host_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tdsi_host = of_find_mipi_dsi_host_by_node(dsi_host_node);\n\tof_node_put(dsi_host_node);\n\tif (IS_ERR_OR_NULL(dsi_host))\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn dsi_host;\n}\nEXPORT_SYMBOL_GPL(drm_of_get_dsi_bus);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}