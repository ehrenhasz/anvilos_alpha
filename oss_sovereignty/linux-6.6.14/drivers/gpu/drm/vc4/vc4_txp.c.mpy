{
  "module_name": "vc4_txp.c",
  "hash_id": "af55953921f6fa6575f2ad264336c330329daf0a9a61d17e13c84e463fe2c1c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_txp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_writeback.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n \n#define TXP_DST_PTR\t\t0x00\n\n \n#define TXP_DST_PITCH\t\t0x04\n \n# define TXP_T_TILE_WIDTH_SHIFT\t\t7\n \n# define TXP_LT_TILE_WIDTH_SHIFT\t4\n\n \n#define TXP_DIM\t\t\t0x08\n# define TXP_HEIGHT_SHIFT\t\t16\n# define TXP_HEIGHT_MASK\t\tGENMASK(31, 16)\n# define TXP_WIDTH_SHIFT\t\t0\n# define TXP_WIDTH_MASK\t\t\tGENMASK(15, 0)\n\n#define TXP_DST_CTRL\t\t0x0c\n \n#define TXP_PILOT_SHIFT\t\t\t24\n#define TXP_PILOT_MASK\t\t\tGENMASK(31, 24)\n \n#define TXP_VERSION_SHIFT\t\t22\n#define TXP_VERSION_MASK\t\tGENMASK(23, 22)\n\n \n# define TXP_POWERDOWN\t\t\tBIT(21)\n\n \n# define TXP_ALPHA_ENABLE\t\tBIT(20)\n\n \n# define TXP_BYTE_ENABLE_SHIFT\t\t16\n# define TXP_BYTE_ENABLE_MASK\t\tGENMASK(19, 16)\n\n \n# define TXP_VSTART_AT_EOF\t\tBIT(15)\n\n \n# define TXP_ABORT\t\t\tBIT(14)\n\n# define TXP_DITHER\t\t\tBIT(13)\n\n \n# define TXP_ALPHA_INVERT\t\tBIT(12)\n\n \n# define TXP_FORMAT_SHIFT\t\t8\n# define TXP_FORMAT_MASK\t\tGENMASK(11, 8)\n# define TXP_FORMAT_ABGR4444\t\t0\n# define TXP_FORMAT_ARGB4444\t\t1\n# define TXP_FORMAT_BGRA4444\t\t2\n# define TXP_FORMAT_RGBA4444\t\t3\n# define TXP_FORMAT_BGR565\t\t6\n# define TXP_FORMAT_RGB565\t\t7\n \n# define TXP_FORMAT_BGR888\t\t8\n# define TXP_FORMAT_RGB888\t\t9\n# define TXP_FORMAT_ABGR8888\t\t12\n# define TXP_FORMAT_ARGB8888\t\t13\n# define TXP_FORMAT_BGRA8888\t\t14\n# define TXP_FORMAT_RGBA8888\t\t15\n\n \n# define TXP_LINEAR_UTILE\t\tBIT(7)\n\n \n# define TXP_TRANSPOSE\t\t\tBIT(6)\n\n \n# define TXP_TFORMAT\t\t\tBIT(5)\n\n \n# define TXP_TEST_MODE\t\t\tBIT(4)\n\n \n# define TXP_FIELD\t\t\tBIT(3)\n\n \n# define TXP_EI\t\t\t\tBIT(2)\n\n \n# define TXP_BUSY\t\t\tBIT(1)\n\n \n# define TXP_GO\t\t\t\tBIT(0)\n\n \n#define TXP_PROGRESS\t\t0x10\n\n#define TXP_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(txp->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define TXP_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, txp->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\nstruct vc4_txp {\n\tstruct vc4_crtc\tbase;\n\n\tstruct platform_device *pdev;\n\n\tstruct vc4_encoder encoder;\n\tstruct drm_writeback_connector connector;\n\n\tvoid __iomem *regs;\n};\n\n#define encoder_to_vc4_txp(_encoder)\t\t\t\t\t\\\n\tcontainer_of_const(_encoder, struct vc4_txp, encoder.base)\n\n#define connector_to_vc4_txp(_connector)\t\t\t\t\\\n\tcontainer_of_const(_connector, struct vc4_txp, connector.base)\n\nstatic const struct debugfs_reg32 txp_regs[] = {\n\tVC4_REG32(TXP_DST_PTR),\n\tVC4_REG32(TXP_DST_PITCH),\n\tVC4_REG32(TXP_DIM),\n\tVC4_REG32(TXP_DST_CTRL),\n\tVC4_REG32(TXP_PROGRESS),\n};\n\nstatic int vc4_txp_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\treturn drm_add_modes_noedid(connector, dev->mode_config.max_width,\n\t\t\t\t    dev->mode_config.max_height);\n}\n\nstatic enum drm_mode_status\nvc4_txp_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tint w = mode->hdisplay, h = mode->vdisplay;\n\n\tif (w < mode_config->min_width || w > mode_config->max_width)\n\t\treturn MODE_BAD_HVALUE;\n\n\tif (h < mode_config->min_height || h > mode_config->max_height)\n\t\treturn MODE_BAD_VVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic const u32 drm_fmts[] = {\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_BGR888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_BGRX8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_BGRA8888,\n};\n\nstatic const u32 txp_fmts[] = {\n\tTXP_FORMAT_RGB888,\n\tTXP_FORMAT_BGR888,\n\tTXP_FORMAT_ARGB8888,\n\tTXP_FORMAT_ABGR8888,\n\tTXP_FORMAT_ARGB8888,\n\tTXP_FORMAT_ABGR8888,\n\tTXP_FORMAT_RGBA8888,\n\tTXP_FORMAT_BGRA8888,\n\tTXP_FORMAT_RGBA8888,\n\tTXP_FORMAT_BGRA8888,\n};\n\nstatic void vc4_txp_armed(struct drm_crtc_state *state)\n{\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(state);\n\n\tvc4_state->txp_armed = true;\n}\n\nstatic int vc4_txp_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_framebuffer *fb;\n\tint i;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, conn);\n\tif (!conn_state->writeback_job)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\n\tfb = conn_state->writeback_job->fb;\n\tif (fb->width != crtc_state->mode.hdisplay ||\n\t    fb->height != crtc_state->mode.vdisplay) {\n\t\tDRM_DEBUG_KMS(\"Invalid framebuffer size %ux%u\\n\",\n\t\t\t      fb->width, fb->height);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_fmts); i++) {\n\t\tif (fb->format->format == drm_fmts[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(drm_fmts))\n\t\treturn -EINVAL;\n\n\t \n\tif (fb->pitches[0] & GENMASK(3, 0))\n\t\treturn -EINVAL;\n\n\tvc4_txp_armed(crtc_state);\n\n\treturn 0;\n}\n\nstatic void vc4_txp_connector_atomic_commit(struct drm_connector *conn,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = conn->dev;\n\tstruct drm_connector_state *conn_state = drm_atomic_get_new_connector_state(state,\n\t\t\t\t\t\t\t\t\t\t    conn);\n\tstruct vc4_txp *txp = connector_to_vc4_txp(conn);\n\tstruct drm_gem_dma_object *gem;\n\tstruct drm_display_mode *mode;\n\tstruct drm_framebuffer *fb;\n\tu32 ctrl;\n\tint idx;\n\tint i;\n\n\tif (WARN_ON(!conn_state->writeback_job))\n\t\treturn;\n\n\tmode = &conn_state->crtc->state->adjusted_mode;\n\tfb = conn_state->writeback_job->fb;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_fmts); i++) {\n\t\tif (fb->format->format == drm_fmts[i])\n\t\t\tbreak;\n\t}\n\n\tif (WARN_ON(i == ARRAY_SIZE(drm_fmts)))\n\t\treturn;\n\n\tctrl = TXP_GO | TXP_EI |\n\t       VC4_SET_FIELD(0xf, TXP_BYTE_ENABLE) |\n\t       VC4_SET_FIELD(txp_fmts[i], TXP_FORMAT);\n\n\tif (fb->format->has_alpha)\n\t\tctrl |= TXP_ALPHA_ENABLE;\n\telse\n\t\t \n\t\tctrl |= TXP_ALPHA_INVERT;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\tTXP_WRITE(TXP_DST_PTR, gem->dma_addr + fb->offsets[0]);\n\tTXP_WRITE(TXP_DST_PITCH, fb->pitches[0]);\n\tTXP_WRITE(TXP_DIM,\n\t\t  VC4_SET_FIELD(mode->hdisplay, TXP_WIDTH) |\n\t\t  VC4_SET_FIELD(mode->vdisplay, TXP_HEIGHT));\n\n\tTXP_WRITE(TXP_DST_CTRL, ctrl);\n\n\tdrm_writeback_queue_job(&txp->connector, conn_state);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_connector_helper_funcs vc4_txp_connector_helper_funcs = {\n\t.get_modes = vc4_txp_connector_get_modes,\n\t.mode_valid = vc4_txp_connector_mode_valid,\n\t.atomic_check = vc4_txp_connector_atomic_check,\n\t.atomic_commit = vc4_txp_connector_atomic_commit,\n};\n\nstatic enum drm_connector_status\nvc4_txp_connector_detect(struct drm_connector *connector, bool force)\n{\n\treturn connector_status_connected;\n}\n\nstatic const struct drm_connector_funcs vc4_txp_connector_funcs = {\n\t.detect = vc4_txp_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic void vc4_txp_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_txp *txp = encoder_to_vc4_txp(encoder);\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tif (TXP_READ(TXP_DST_CTRL) & TXP_BUSY) {\n\t\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\t\tTXP_WRITE(TXP_DST_CTRL, TXP_ABORT);\n\n\t\twhile (TXP_READ(TXP_DST_CTRL) & TXP_BUSY &&\n\t\t       time_before(jiffies, timeout))\n\t\t\t;\n\n\t\tWARN_ON(TXP_READ(TXP_DST_CTRL) & TXP_BUSY);\n\t}\n\n\tTXP_WRITE(TXP_DST_CTRL, TXP_POWERDOWN);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic const struct drm_encoder_helper_funcs vc4_txp_encoder_helper_funcs = {\n\t.disable = vc4_txp_encoder_disable,\n};\n\nstatic int vc4_txp_enable_vblank(struct drm_crtc *crtc)\n{\n\treturn 0;\n}\n\nstatic void vc4_txp_disable_vblank(struct drm_crtc *crtc) {}\n\nstatic const struct drm_crtc_funcs vc4_txp_crtc_funcs = {\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= vc4_page_flip,\n\t.reset\t\t\t= vc4_crtc_reset,\n\t.atomic_duplicate_state\t= vc4_crtc_duplicate_state,\n\t.atomic_destroy_state\t= vc4_crtc_destroy_state,\n\t.enable_vblank\t\t= vc4_txp_enable_vblank,\n\t.disable_vblank\t\t= vc4_txp_disable_vblank,\n\t.late_register\t\t= vc4_crtc_late_register,\n};\n\nstatic int vc4_txp_atomic_check(struct drm_crtc *crtc,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tint ret;\n\n\tret = vc4_hvs_atomic_check(crtc, state);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state->no_vblank = true;\n\n\treturn 0;\n}\n\nstatic void vc4_txp_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n\tvc4_hvs_atomic_enable(crtc, state);\n}\n\nstatic void vc4_txp_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\tvc4_hvs_atomic_disable(crtc, state);\n\n\t \n\tif (crtc->state->event) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs vc4_txp_crtc_helper_funcs = {\n\t.atomic_check\t= vc4_txp_atomic_check,\n\t.atomic_begin\t= vc4_hvs_atomic_begin,\n\t.atomic_flush\t= vc4_hvs_atomic_flush,\n\t.atomic_enable\t= vc4_txp_atomic_enable,\n\t.atomic_disable\t= vc4_txp_atomic_disable,\n};\n\nstatic irqreturn_t vc4_txp_interrupt(int irq, void *data)\n{\n\tstruct vc4_txp *txp = data;\n\tstruct vc4_crtc *vc4_crtc = &txp->base;\n\n\t \n\tTXP_WRITE(TXP_DST_CTRL, TXP_READ(TXP_DST_CTRL) & ~TXP_EI);\n\tvc4_crtc_handle_vblank(vc4_crtc);\n\tdrm_writeback_signal_completion(&txp->connector, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nconst struct vc4_crtc_data vc4_txp_crtc_data = {\n\t.name = \"txp\",\n\t.debugfs_name = \"txp_regs\",\n\t.hvs_available_channels = BIT(2),\n\t.hvs_output = 2,\n};\n\nstatic int vc4_txp_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_encoder *vc4_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct vc4_crtc *vc4_crtc;\n\tstruct vc4_txp *txp;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\ttxp = drmm_kzalloc(drm, sizeof(*txp), GFP_KERNEL);\n\tif (!txp)\n\t\treturn -ENOMEM;\n\n\ttxp->pdev = pdev;\n\ttxp->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(txp->regs))\n\t\treturn PTR_ERR(txp->regs);\n\n\tvc4_crtc = &txp->base;\n\tvc4_crtc->regset.base = txp->regs;\n\tvc4_crtc->regset.regs = txp_regs;\n\tvc4_crtc->regset.nregs = ARRAY_SIZE(txp_regs);\n\n\tret = vc4_crtc_init(drm, pdev, vc4_crtc, &vc4_txp_crtc_data,\n\t\t\t    &vc4_txp_crtc_funcs, &vc4_txp_crtc_helper_funcs, true);\n\tif (ret)\n\t\treturn ret;\n\n\tvc4_encoder = &txp->encoder;\n\ttxp->encoder.type = VC4_ENCODER_TYPE_TXP;\n\n\tencoder = &vc4_encoder->base;\n\tencoder->possible_crtcs = drm_crtc_mask(&vc4_crtc->base);\n\n\tdrm_encoder_helper_add(encoder, &vc4_txp_encoder_helper_funcs);\n\n\tret = drmm_encoder_init(drm, encoder, NULL, DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(&txp->connector.base,\n\t\t\t\t &vc4_txp_connector_helper_funcs);\n\tret = drm_writeback_connector_init_with_encoder(drm, &txp->connector,\n\t\t\t\t\t\t\tencoder,\n\t\t\t\t\t\t\t&vc4_txp_connector_funcs,\n\t\t\t\t\t\t\tdrm_fmts, ARRAY_SIZE(drm_fmts));\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, irq, vc4_txp_interrupt, 0,\n\t\t\t       dev_name(dev), txp);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, txp);\n\n\treturn 0;\n}\n\nstatic void vc4_txp_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct vc4_txp *txp = dev_get_drvdata(dev);\n\n\tdrm_connector_cleanup(&txp->connector.base);\n}\n\nstatic const struct component_ops vc4_txp_ops = {\n\t.bind   = vc4_txp_bind,\n\t.unbind = vc4_txp_unbind,\n};\n\nstatic int vc4_txp_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_txp_ops);\n}\n\nstatic void vc4_txp_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_txp_ops);\n}\n\nstatic const struct of_device_id vc4_txp_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-txp\" },\n\t{   },\n};\n\nstruct platform_driver vc4_txp_driver = {\n\t.probe = vc4_txp_probe,\n\t.remove_new = vc4_txp_remove,\n\t.driver = {\n\t\t.name = \"vc4_txp\",\n\t\t.of_match_table = vc4_txp_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}