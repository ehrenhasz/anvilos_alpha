{
  "module_name": "vc4_drv.h",
  "hash_id": "35931670144fb8e5773632c6c2d940baa853ede2d2b04db36c0d13cf2e4c32e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_drv.h",
  "human_readable_source": " \n \n#ifndef _VC4_DRV_H_\n#define _VC4_DRV_H_\n\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/refcount.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mm.h>\n#include <drm/drm_modeset_lock.h>\n\n#include <kunit/test-bug.h>\n\n#include \"uapi/drm/vc4_drm.h\"\n\nstruct drm_device;\nstruct drm_gem_object;\n\nextern const struct drm_driver vc4_drm_driver;\nextern const struct drm_driver vc5_drm_driver;\n\n \nenum vc4_kernel_bo_type {\n\t \n\tVC4_BO_TYPE_KERNEL,\n\tVC4_BO_TYPE_V3D,\n\tVC4_BO_TYPE_V3D_SHADER,\n\tVC4_BO_TYPE_DUMB,\n\tVC4_BO_TYPE_BIN,\n\tVC4_BO_TYPE_RCL,\n\tVC4_BO_TYPE_BCL,\n\tVC4_BO_TYPE_KERNEL_CACHE,\n\tVC4_BO_TYPE_COUNT\n};\n\n \nstruct vc4_perfmon {\n\tstruct vc4_dev *dev;\n\n\t \n\trefcount_t refcnt;\n\n\t \n\tu8 ncounters;\n\n\t \n\tu8 events[DRM_VC4_MAX_PERF_COUNTERS];\n\n\t \n\tu64 counters[];\n};\n\nstruct vc4_dev {\n\tstruct drm_device base;\n\tstruct device *dev;\n\n\tbool is_vc5;\n\n\tunsigned int irq;\n\n\tstruct vc4_hvs *hvs;\n\tstruct vc4_v3d *v3d;\n\n\tstruct vc4_hang_state *hang_state;\n\n\t \n\tstruct vc4_bo_cache {\n\t\t \n\t\tstruct list_head *size_list;\n\t\tuint32_t size_list_size;\n\n\t\t \n\t\tstruct list_head time_list;\n\t\tstruct work_struct time_work;\n\t\tstruct timer_list time_timer;\n\t} bo_cache;\n\n\tu32 num_labels;\n\tstruct vc4_label {\n\t\tconst char *name;\n\t\tu32 num_allocated;\n\t\tu32 size_allocated;\n\t} *bo_labels;\n\n\t \n\tstruct mutex bo_lock;\n\n\t \n\tstruct {\n\t\tstruct list_head list;\n\t\tunsigned int num;\n\t\tsize_t size;\n\t\tunsigned int purged_num;\n\t\tsize_t purged_size;\n\t\tstruct mutex lock;\n\t} purgeable;\n\n\tuint64_t dma_fence_context;\n\n\t \n\tuint64_t emit_seqno;\n\n\t \n\tuint64_t finished_seqno;\n\n\t \n\tstruct list_head bin_job_list;\n\n\t \n\tstruct list_head render_job_list;\n\n\t \n\tstruct list_head job_done_list;\n\t \n\tspinlock_t job_lock;\n\twait_queue_head_t job_wait_queue;\n\tstruct work_struct job_done_work;\n\n\t \n\tstruct vc4_perfmon *active_perfmon;\n\n\t \n\tstruct list_head seqno_cb_list;\n\n\t \n\tstruct vc4_bo *bin_bo;\n\n\t \n\tuint32_t bin_alloc_size;\n\n\t \n\tuint32_t bin_alloc_used;\n\n\t \n\tuint32_t bin_alloc_overflow;\n\n\t \n\tatomic_t underrun;\n\n\tstruct work_struct overflow_mem_work;\n\n\tint power_refcount;\n\n\t \n\tbool load_tracker_enabled;\n\n\t \n\tstruct mutex power_lock;\n\n\tstruct {\n\t\tstruct timer_list timer;\n\t\tstruct work_struct reset_work;\n\t} hangcheck;\n\n\tstruct drm_modeset_lock ctm_state_lock;\n\tstruct drm_private_obj ctm_manager;\n\tstruct drm_private_obj hvs_channels;\n\tstruct drm_private_obj load_tracker;\n\n\t \n\tstruct mutex bin_bo_lock;\n\t \n\tstruct kref bin_bo_kref;\n};\n\n#define to_vc4_dev(_dev)\t\t\t\\\n\tcontainer_of_const(_dev, struct vc4_dev, base)\n\nstruct vc4_bo {\n\tstruct drm_gem_dma_object base;\n\n\t \n\tuint64_t seqno;\n\n\t \n\tuint64_t write_seqno;\n\n\tbool t_format;\n\n\t \n\tstruct list_head unref_head;\n\n\t \n\tunsigned long free_time;\n\n\t \n\tstruct list_head size_head;\n\n\t \n\tstruct vc4_validated_shader_info *validated_shader;\n\n\t \n\tint label;\n\n\t \n\trefcount_t usecnt;\n\n\t \n\tu32 madv;\n\tstruct mutex madv_lock;\n};\n\n#define to_vc4_bo(_bo)\t\t\t\t\t\t\t\\\n\tcontainer_of_const(to_drm_gem_dma_obj(_bo), struct vc4_bo, base)\n\nstruct vc4_fence {\n\tstruct dma_fence base;\n\tstruct drm_device *dev;\n\t \n\tuint64_t seqno;\n};\n\n#define to_vc4_fence(_fence)\t\t\t\t\t\\\n\tcontainer_of_const(_fence, struct vc4_fence, base)\n\nstruct vc4_seqno_cb {\n\tstruct work_struct work;\n\tuint64_t seqno;\n\tvoid (*func)(struct vc4_seqno_cb *cb);\n};\n\nstruct vc4_v3d {\n\tstruct vc4_dev *vc4;\n\tstruct platform_device *pdev;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct debugfs_regset32 regset;\n};\n\nstruct vc4_hvs {\n\tstruct vc4_dev *vc4;\n\tstruct platform_device *pdev;\n\tvoid __iomem *regs;\n\tu32 __iomem *dlist;\n\n\tstruct clk *core_clk;\n\n\tunsigned long max_core_rate;\n\n\t \n\tstruct drm_mm dlist_mm;\n\t \n\tstruct drm_mm lbm_mm;\n\tspinlock_t mm_lock;\n\n\tstruct drm_mm_node mitchell_netravali_filter;\n\n\tstruct debugfs_regset32 regset;\n\n\t \n\tbool vc5_hdmi_enable_hdmi_20;\n\n\t \n\tbool vc5_hdmi_enable_4096by2160;\n};\n\n#define HVS_NUM_CHANNELS 3\n\nstruct vc4_hvs_state {\n\tstruct drm_private_state base;\n\tunsigned long core_clock_rate;\n\n\tstruct {\n\t\tunsigned in_use: 1;\n\t\tunsigned long fifo_load;\n\t\tstruct drm_crtc_commit *pending_commit;\n\t} fifo_state[HVS_NUM_CHANNELS];\n};\n\n#define to_vc4_hvs_state(_state)\t\t\t\t\\\n\tcontainer_of_const(_state, struct vc4_hvs_state, base)\n\nstruct vc4_hvs_state *vc4_hvs_get_global_state(struct drm_atomic_state *state);\nstruct vc4_hvs_state *vc4_hvs_get_old_global_state(const struct drm_atomic_state *state);\nstruct vc4_hvs_state *vc4_hvs_get_new_global_state(const struct drm_atomic_state *state);\n\nstruct vc4_plane {\n\tstruct drm_plane base;\n};\n\n#define to_vc4_plane(_plane)\t\t\t\t\t\\\n\tcontainer_of_const(_plane, struct vc4_plane, base)\n\nenum vc4_scaling_mode {\n\tVC4_SCALING_NONE,\n\tVC4_SCALING_TPZ,\n\tVC4_SCALING_PPF,\n};\n\nstruct vc4_plane_state {\n\tstruct drm_plane_state base;\n\t \n\tu32 *dlist;\n\tu32 dlist_size;  \n\tu32 dlist_count;  \n\n\t \n\tu32 pos0_offset;\n\tu32 pos2_offset;\n\tu32 ptr0_offset;\n\tu32 lbm_offset;\n\n\t \n\tu32 __iomem *hw_dlist;\n\n\t \n\tint crtc_x, crtc_y, crtc_w, crtc_h;\n\t \n\tu32 src_x, src_y;\n\n\tu32 src_w[2], src_h[2];\n\n\t \n\tenum vc4_scaling_mode x_scaling[2], y_scaling[2];\n\tbool is_unity;\n\tbool is_yuv;\n\n\t \n\tu32 offsets[3];\n\n\t \n\tstruct drm_mm_node lbm;\n\n\t \n\tbool needs_bg_fill;\n\n\t \n\tbool dlist_initialized;\n\n\t \n\tu64 hvs_load;\n\n\t \n\tu64 membus_load;\n};\n\n#define to_vc4_plane_state(_state)\t\t\t\t\\\n\tcontainer_of_const(_state, struct vc4_plane_state, base)\n\nenum vc4_encoder_type {\n\tVC4_ENCODER_TYPE_NONE,\n\tVC4_ENCODER_TYPE_HDMI0,\n\tVC4_ENCODER_TYPE_HDMI1,\n\tVC4_ENCODER_TYPE_VEC,\n\tVC4_ENCODER_TYPE_DSI0,\n\tVC4_ENCODER_TYPE_DSI1,\n\tVC4_ENCODER_TYPE_SMI,\n\tVC4_ENCODER_TYPE_DPI,\n\tVC4_ENCODER_TYPE_TXP,\n};\n\nstruct vc4_encoder {\n\tstruct drm_encoder base;\n\tenum vc4_encoder_type type;\n\tu32 clock_select;\n\n\tvoid (*pre_crtc_configure)(struct drm_encoder *encoder, struct drm_atomic_state *state);\n\tvoid (*pre_crtc_enable)(struct drm_encoder *encoder, struct drm_atomic_state *state);\n\tvoid (*post_crtc_enable)(struct drm_encoder *encoder, struct drm_atomic_state *state);\n\n\tvoid (*post_crtc_disable)(struct drm_encoder *encoder, struct drm_atomic_state *state);\n\tvoid (*post_crtc_powerdown)(struct drm_encoder *encoder, struct drm_atomic_state *state);\n};\n\n#define to_vc4_encoder(_encoder)\t\t\t\t\\\n\tcontainer_of_const(_encoder, struct vc4_encoder, base)\n\nstatic inline\nstruct drm_encoder *vc4_find_encoder_by_type(struct drm_device *drm,\n\t\t\t\t\t     enum vc4_encoder_type type)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, drm) {\n\t\tstruct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);\n\n\t\tif (vc4_encoder->type == type)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstruct vc4_crtc_data {\n\tconst char *name;\n\n\tconst char *debugfs_name;\n\n\t \n\tunsigned int hvs_available_channels;\n\n\t \n\tint hvs_output;\n};\n\nextern const struct vc4_crtc_data vc4_txp_crtc_data;\n\nstruct vc4_pv_data {\n\tstruct vc4_crtc_data\tbase;\n\n\t \n\tunsigned int fifo_depth;\n\n\t \n\tu8 pixels_per_clock;\n\n\tenum vc4_encoder_type encoder_types[4];\n};\n\nextern const struct vc4_pv_data bcm2835_pv0_data;\nextern const struct vc4_pv_data bcm2835_pv1_data;\nextern const struct vc4_pv_data bcm2835_pv2_data;\nextern const struct vc4_pv_data bcm2711_pv0_data;\nextern const struct vc4_pv_data bcm2711_pv1_data;\nextern const struct vc4_pv_data bcm2711_pv2_data;\nextern const struct vc4_pv_data bcm2711_pv3_data;\nextern const struct vc4_pv_data bcm2711_pv4_data;\n\nstruct vc4_crtc {\n\tstruct drm_crtc base;\n\tstruct platform_device *pdev;\n\tconst struct vc4_crtc_data *data;\n\tvoid __iomem *regs;\n\n\t \n\tktime_t t_vblank;\n\n\tu8 lut_r[256];\n\tu8 lut_g[256];\n\tu8 lut_b[256];\n\n\tstruct drm_pending_vblank_event *event;\n\n\tstruct debugfs_regset32 regset;\n\n\t \n\tbool feeds_txp;\n\n\t \n\tspinlock_t irq_lock;\n\n\t \n\tunsigned int current_dlist;\n\n\t \n\tunsigned int current_hvs_channel;\n};\n\n#define to_vc4_crtc(_crtc)\t\t\t\t\t\\\n\tcontainer_of_const(_crtc, struct vc4_crtc, base)\n\nstatic inline const struct vc4_crtc_data *\nvc4_crtc_to_vc4_crtc_data(const struct vc4_crtc *crtc)\n{\n\treturn crtc->data;\n}\n\nstatic inline const struct vc4_pv_data *\nvc4_crtc_to_vc4_pv_data(const struct vc4_crtc *crtc)\n{\n\tconst struct vc4_crtc_data *data = vc4_crtc_to_vc4_crtc_data(crtc);\n\n\treturn container_of_const(data, struct vc4_pv_data, base);\n}\n\nstruct drm_encoder *vc4_get_crtc_encoder(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_crtc_state *state);\n\nstruct vc4_crtc_state {\n\tstruct drm_crtc_state base;\n\t \n\tstruct drm_mm_node mm;\n\tbool txp_armed;\n\tunsigned int assigned_channel;\n\n\tstruct {\n\t\tunsigned int left;\n\t\tunsigned int right;\n\t\tunsigned int top;\n\t\tunsigned int bottom;\n\t} margins;\n\n\tunsigned long hvs_load;\n\n\t \n\tbool update_muxing;\n};\n\n#define VC4_HVS_CHANNEL_DISABLED ((unsigned int)-1)\n\n#define to_vc4_crtc_state(_state)\t\t\t\t\\\n\tcontainer_of_const(_state, struct vc4_crtc_state, base)\n\n#define V3D_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(vc4->v3d->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define V3D_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, vc4->v3d->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\n#define HVS_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(hvs->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define HVS_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, hvs->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\n#define VC4_REG32(reg) { .name = #reg, .offset = reg }\n\nstruct vc4_exec_info {\n\tstruct vc4_dev *dev;\n\n\t \n\tuint64_t seqno;\n\n\t \n\tuint64_t bin_dep_seqno;\n\n\tstruct dma_fence *fence;\n\n\t \n\tuint32_t last_ct0ca, last_ct1ca;\n\n\t \n\tstruct drm_vc4_submit_cl *args;\n\n\t \n\tstruct drm_gem_object **bo;\n\tuint32_t bo_count;\n\n\t \n\tstruct drm_gem_dma_object *rcl_write_bo[4];\n\tuint32_t rcl_write_bo_count;\n\n\t \n\tstruct list_head head;\n\n\t \n\tstruct list_head unref_list;\n\n\t \n\tuint32_t bo_index[2];\n\n\t \n\tstruct drm_gem_dma_object *exec_bo;\n\n\t \n\tstruct vc4_shader_state {\n\t\tuint32_t addr;\n\t\t \n\t\tuint32_t max_index;\n\t} *shader_state;\n\n\t \n\tuint32_t shader_state_size;\n\t \n\tuint32_t shader_state_count;\n\n\tbool found_tile_binning_mode_config_packet;\n\tbool found_start_tile_binning_packet;\n\tbool found_increment_semaphore_packet;\n\tbool found_flush;\n\tuint8_t bin_tiles_x, bin_tiles_y;\n\t \n\tuint32_t tile_alloc_offset;\n\t \n\tuint32_t bin_slots;\n\n\t \n\tuint32_t ct0ca, ct0ea;\n\tuint32_t ct1ca, ct1ea;\n\n\t \n\tvoid *bin_u;\n\n\t \n\tvoid *shader_rec_u;\n\tvoid *shader_rec_v;\n\tuint32_t shader_rec_p;\n\tuint32_t shader_rec_size;\n\n\t \n\tvoid *uniforms_u;\n\tvoid *uniforms_v;\n\tuint32_t uniforms_p;\n\tuint32_t uniforms_size;\n\n\t \n\tstruct vc4_perfmon *perfmon;\n\n\t \n\tbool bin_bo_used;\n};\n\n \nstruct vc4_file {\n\tstruct vc4_dev *dev;\n\n\tstruct {\n\t\tstruct idr idr;\n\t\tstruct mutex lock;\n\t} perfmon;\n\n\tbool bin_bo_used;\n};\n\nstatic inline struct vc4_exec_info *\nvc4_first_bin_job(struct vc4_dev *vc4)\n{\n\treturn list_first_entry_or_null(&vc4->bin_job_list,\n\t\t\t\t\tstruct vc4_exec_info, head);\n}\n\nstatic inline struct vc4_exec_info *\nvc4_first_render_job(struct vc4_dev *vc4)\n{\n\treturn list_first_entry_or_null(&vc4->render_job_list,\n\t\t\t\t\tstruct vc4_exec_info, head);\n}\n\nstatic inline struct vc4_exec_info *\nvc4_last_render_job(struct vc4_dev *vc4)\n{\n\tif (list_empty(&vc4->render_job_list))\n\t\treturn NULL;\n\treturn list_last_entry(&vc4->render_job_list,\n\t\t\t       struct vc4_exec_info, head);\n}\n\n \nstruct vc4_texture_sample_info {\n\tbool is_direct;\n\tuint32_t p_offset[4];\n};\n\n \nstruct vc4_validated_shader_info {\n\tuint32_t uniforms_size;\n\tuint32_t uniforms_src_size;\n\tuint32_t num_texture_samples;\n\tstruct vc4_texture_sample_info *texture_samples;\n\n\tuint32_t num_uniform_addr_offsets;\n\tuint32_t *uniform_addr_offsets;\n\n\tbool is_threaded;\n};\n\n \n#define __wait_for(OP, COND, US, Wmin, Wmax) ({ \\\n\tconst ktime_t end__ = ktime_add_ns(ktime_get_raw(), 1000ll * (US)); \\\n\tlong wait__ = (Wmin);  \t\\\n\tint ret__;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tconst bool expired__ = ktime_after(ktime_get_raw(), end__); \\\n\t\tOP;\t\t\t\t\t\t\t\\\n\t\t \t\t\\\n\t\tbarrier();\t\t\t\t\t\t\\\n\t\tif (COND) {\t\t\t\t\t\t\\\n\t\t\tret__ = 0;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (expired__) {\t\t\t\t\t\\\n\t\t\tret__ = -ETIMEDOUT;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tusleep_range(wait__, wait__ * 2);\t\t\t\\\n\t\tif (wait__ < (Wmax))\t\t\t\t\t\\\n\t\t\twait__ <<= 1;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret__;\t\t\t\t\t\t\t\t\\\n})\n\n#define _wait_for(COND, US, Wmin, Wmax)\t__wait_for(, (COND), (US), (Wmin), \\\n\t\t\t\t\t\t   (Wmax))\n#define wait_for(COND, MS)\t\t_wait_for((COND), (MS) * 1000, 10, 1000)\n\n \nstruct drm_gem_object *vc4_create_object(struct drm_device *dev, size_t size);\nstruct vc4_bo *vc4_bo_create(struct drm_device *dev, size_t size,\n\t\t\t     bool from_cache, enum vc4_kernel_bo_type type);\nint vc4_bo_dumb_create(struct drm_file *file_priv,\n\t\t       struct drm_device *dev,\n\t\t       struct drm_mode_create_dumb *args);\nint vc4_create_bo_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv);\nint vc4_create_shader_bo_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file_priv);\nint vc4_mmap_bo_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint vc4_set_tiling_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv);\nint vc4_get_tiling_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv);\nint vc4_get_hang_state_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv);\nint vc4_label_bo_ioctl(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv);\nint vc4_bo_cache_init(struct drm_device *dev);\nint vc4_bo_inc_usecnt(struct vc4_bo *bo);\nvoid vc4_bo_dec_usecnt(struct vc4_bo *bo);\nvoid vc4_bo_add_to_purgeable_pool(struct vc4_bo *bo);\nvoid vc4_bo_remove_from_purgeable_pool(struct vc4_bo *bo);\nint vc4_bo_debugfs_init(struct drm_minor *minor);\n\n \nextern struct platform_driver vc4_crtc_driver;\nint vc4_crtc_disable_at_boot(struct drm_crtc *crtc);\nint __vc4_crtc_init(struct drm_device *drm, struct platform_device *pdev,\n\t\t    struct vc4_crtc *vc4_crtc, const struct vc4_crtc_data *data,\n\t\t    struct drm_plane *primary_plane,\n\t\t    const struct drm_crtc_funcs *crtc_funcs,\n\t\t    const struct drm_crtc_helper_funcs *crtc_helper_funcs,\n\t\t    bool feeds_txp);\nint vc4_crtc_init(struct drm_device *drm, struct platform_device *pdev,\n\t\t  struct vc4_crtc *vc4_crtc, const struct vc4_crtc_data *data,\n\t\t  const struct drm_crtc_funcs *crtc_funcs,\n\t\t  const struct drm_crtc_helper_funcs *crtc_helper_funcs,\n\t\t  bool feeds_txp);\nint vc4_page_flip(struct drm_crtc *crtc,\n\t\t  struct drm_framebuffer *fb,\n\t\t  struct drm_pending_vblank_event *event,\n\t\t  uint32_t flags,\n\t\t  struct drm_modeset_acquire_ctx *ctx);\nint vc4_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t  struct drm_atomic_state *state);\nstruct drm_crtc_state *vc4_crtc_duplicate_state(struct drm_crtc *crtc);\nvoid vc4_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t    struct drm_crtc_state *state);\nvoid vc4_crtc_reset(struct drm_crtc *crtc);\nvoid vc4_crtc_handle_vblank(struct vc4_crtc *crtc);\nvoid vc4_crtc_send_vblank(struct drm_crtc *crtc);\nint vc4_crtc_late_register(struct drm_crtc *crtc);\nvoid vc4_crtc_get_margins(struct drm_crtc_state *state,\n\t\t\t  unsigned int *left, unsigned int *right,\n\t\t\t  unsigned int *top, unsigned int *bottom);\n\n \nvoid vc4_debugfs_init(struct drm_minor *minor);\n#ifdef CONFIG_DEBUG_FS\nvoid vc4_debugfs_add_regset32(struct drm_device *drm,\n\t\t\t      const char *filename,\n\t\t\t      struct debugfs_regset32 *regset);\n#else\n\nstatic inline void vc4_debugfs_add_regset32(struct drm_device *drm,\n\t\t\t\t\t    const char *filename,\n\t\t\t\t\t    struct debugfs_regset32 *regset)\n{}\n#endif\n\n \nvoid __iomem *vc4_ioremap_regs(struct platform_device *dev, int index);\nint vc4_dumb_fixup_args(struct drm_mode_create_dumb *args);\n\n \nextern struct platform_driver vc4_dpi_driver;\n\n \nextern struct platform_driver vc4_dsi_driver;\n\n \nextern const struct dma_fence_ops vc4_fence_ops;\n\n \nint vc4_gem_init(struct drm_device *dev);\nint vc4_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv);\nint vc4_wait_seqno_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv);\nint vc4_wait_bo_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nvoid vc4_submit_next_bin_job(struct drm_device *dev);\nvoid vc4_submit_next_render_job(struct drm_device *dev);\nvoid vc4_move_job_to_render(struct drm_device *dev, struct vc4_exec_info *exec);\nint vc4_wait_for_seqno(struct drm_device *dev, uint64_t seqno,\n\t\t       uint64_t timeout_ns, bool interruptible);\nvoid vc4_job_handle_completed(struct vc4_dev *vc4);\nint vc4_queue_seqno_cb(struct drm_device *dev,\n\t\t       struct vc4_seqno_cb *cb, uint64_t seqno,\n\t\t       void (*func)(struct vc4_seqno_cb *cb));\nint vc4_gem_madvise_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv);\n\n \nextern struct platform_driver vc4_hdmi_driver;\n\n \nextern struct platform_driver vc4_vec_driver;\n\n \nextern struct platform_driver vc4_txp_driver;\n\n \nvoid vc4_irq_enable(struct drm_device *dev);\nvoid vc4_irq_disable(struct drm_device *dev);\nint vc4_irq_install(struct drm_device *dev, int irq);\nvoid vc4_irq_uninstall(struct drm_device *dev);\nvoid vc4_irq_reset(struct drm_device *dev);\n\n \nextern struct platform_driver vc4_hvs_driver;\nstruct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4, struct platform_device *pdev);\nvoid vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int output);\nint vc4_hvs_get_fifo_from_output(struct vc4_hvs *hvs, unsigned int output);\nu8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo);\nint vc4_hvs_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state);\nvoid vc4_hvs_atomic_begin(struct drm_crtc *crtc, struct drm_atomic_state *state);\nvoid vc4_hvs_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *state);\nvoid vc4_hvs_atomic_disable(struct drm_crtc *crtc, struct drm_atomic_state *state);\nvoid vc4_hvs_atomic_flush(struct drm_crtc *crtc, struct drm_atomic_state *state);\nvoid vc4_hvs_dump_state(struct vc4_hvs *hvs);\nvoid vc4_hvs_unmask_underrun(struct vc4_hvs *hvs, int channel);\nvoid vc4_hvs_mask_underrun(struct vc4_hvs *hvs, int channel);\nint vc4_hvs_debugfs_init(struct drm_minor *minor);\n\n \nint vc4_kms_load(struct drm_device *dev);\n\n \nstruct drm_plane *vc4_plane_init(struct drm_device *dev,\n\t\t\t\t enum drm_plane_type type,\n\t\t\t\t uint32_t possible_crtcs);\nint vc4_plane_create_additional_planes(struct drm_device *dev);\nu32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist);\nu32 vc4_plane_dlist_size(const struct drm_plane_state *state);\nvoid vc4_plane_async_set_fb(struct drm_plane *plane,\n\t\t\t    struct drm_framebuffer *fb);\n\n \nextern struct platform_driver vc4_v3d_driver;\nextern const struct of_device_id vc4_v3d_dt_match[];\nint vc4_v3d_get_bin_slot(struct vc4_dev *vc4);\nint vc4_v3d_bin_bo_get(struct vc4_dev *vc4, bool *used);\nvoid vc4_v3d_bin_bo_put(struct vc4_dev *vc4);\nint vc4_v3d_pm_get(struct vc4_dev *vc4);\nvoid vc4_v3d_pm_put(struct vc4_dev *vc4);\nint vc4_v3d_debugfs_init(struct drm_minor *minor);\n\n \nint\nvc4_validate_bin_cl(struct drm_device *dev,\n\t\t    void *validated,\n\t\t    void *unvalidated,\n\t\t    struct vc4_exec_info *exec);\n\nint\nvc4_validate_shader_recs(struct drm_device *dev, struct vc4_exec_info *exec);\n\nstruct drm_gem_dma_object *vc4_use_bo(struct vc4_exec_info *exec,\n\t\t\t\t      uint32_t hindex);\n\nint vc4_get_rcl(struct drm_device *dev, struct vc4_exec_info *exec);\n\nbool vc4_check_tex_size(struct vc4_exec_info *exec,\n\t\t\tstruct drm_gem_dma_object *fbo,\n\t\t\tuint32_t offset, uint8_t tiling_format,\n\t\t\tuint32_t width, uint32_t height, uint8_t cpp);\n\n \nstruct vc4_validated_shader_info *\nvc4_validate_shader(struct drm_gem_dma_object *shader_obj);\n\n \nvoid vc4_perfmon_get(struct vc4_perfmon *perfmon);\nvoid vc4_perfmon_put(struct vc4_perfmon *perfmon);\nvoid vc4_perfmon_start(struct vc4_dev *vc4, struct vc4_perfmon *perfmon);\nvoid vc4_perfmon_stop(struct vc4_dev *vc4, struct vc4_perfmon *perfmon,\n\t\t      bool capture);\nstruct vc4_perfmon *vc4_perfmon_find(struct vc4_file *vc4file, int id);\nvoid vc4_perfmon_open_file(struct vc4_file *vc4file);\nvoid vc4_perfmon_close_file(struct vc4_file *vc4file);\nint vc4_perfmon_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv);\nint vc4_perfmon_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv);\nint vc4_perfmon_get_values_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}