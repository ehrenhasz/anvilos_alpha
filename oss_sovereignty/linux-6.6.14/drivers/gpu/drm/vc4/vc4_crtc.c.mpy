{
  "module_name": "vc4_crtc.c",
  "hash_id": "5a748bda0d5b296a757dcfa16474b7e2c398978ff928bcc3da01402764fc1807",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_crtc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_hdmi.h\"\n#include \"vc4_regs.h\"\n\n#define HVS_FIFO_LATENCY_PIX\t6\n\n#define CRTC_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, vc4_crtc->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\n#define CRTC_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(vc4_crtc->regs + (offset));\t\t\t\t\t\\\n\t})\n\nstatic const struct debugfs_reg32 crtc_regs[] = {\n\tVC4_REG32(PV_CONTROL),\n\tVC4_REG32(PV_V_CONTROL),\n\tVC4_REG32(PV_VSYNCD_EVEN),\n\tVC4_REG32(PV_HORZA),\n\tVC4_REG32(PV_HORZB),\n\tVC4_REG32(PV_VERTA),\n\tVC4_REG32(PV_VERTB),\n\tVC4_REG32(PV_VERTA_EVEN),\n\tVC4_REG32(PV_VERTB_EVEN),\n\tVC4_REG32(PV_INTEN),\n\tVC4_REG32(PV_INTSTAT),\n\tVC4_REG32(PV_STAT),\n\tVC4_REG32(PV_HACT_ACT),\n};\n\nstatic unsigned int\nvc4_crtc_get_cob_allocation(struct vc4_dev *vc4, unsigned int channel)\n{\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tu32 dispbase = HVS_READ(SCALER_DISPBASEX(channel));\n\t \n\tu32 top = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_TOP) & ~3;\n\tu32 base = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_BASE) & ~3;\n\n\treturn top - base + 4;\n}\n\nstatic bool vc4_crtc_get_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t\t  bool in_vblank_irq,\n\t\t\t\t\t  int *vpos, int *hpos,\n\t\t\t\t\t  ktime_t *stime, ktime_t *etime,\n\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct vc4_crtc_state *vc4_crtc_state = to_vc4_crtc_state(crtc->state);\n\tunsigned int cob_size;\n\tu32 val;\n\tint fifo_lines;\n\tint vblank_lines;\n\tbool ret = false;\n\n\t \n\n\t \n\tif (stime)\n\t\t*stime = ktime_get();\n\n\t \n\tval = HVS_READ(SCALER_DISPSTATX(vc4_crtc_state->assigned_channel));\n\n\t \n\tif (etime)\n\t\t*etime = ktime_get();\n\n\t \n\n\t \n\t*vpos = VC4_GET_FIELD(val, SCALER_DISPSTATX_LINE);\n\t*hpos = 0;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\t*vpos /= 2;\n\n\t\t \n\t\tif (vc4_hvs_get_fifo_frame_count(hvs, vc4_crtc_state->assigned_channel) % 2)\n\t\t\t*hpos += mode->crtc_htotal / 2;\n\t}\n\n\tcob_size = vc4_crtc_get_cob_allocation(vc4, vc4_crtc_state->assigned_channel);\n\t \n\tfifo_lines = cob_size / mode->crtc_hdisplay;\n\n\tif (fifo_lines > 0)\n\t\tret = true;\n\n\t \n\tif (*vpos > fifo_lines) {\n\t\t \n\t\t*vpos -= fifo_lines + 1;\n\n\t\treturn ret;\n\t}\n\n\t \n\tvblank_lines = mode->vtotal - mode->vdisplay;\n\n\tif (in_vblank_irq) {\n\t\t \n\t\t*vpos = -vblank_lines;\n\n\t\tif (stime)\n\t\t\t*stime = vc4_crtc->t_vblank;\n\t\tif (etime)\n\t\t\t*etime = vc4_crtc->t_vblank;\n\n\t\t \n\t} else {\n\t\t \n\t\t*vpos = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 vc4_get_fifo_full_level(struct vc4_crtc *vc4_crtc, u32 format)\n{\n\tconst struct vc4_crtc_data *crtc_data = vc4_crtc_to_vc4_crtc_data(vc4_crtc);\n\tconst struct vc4_pv_data *pv_data = vc4_crtc_to_vc4_pv_data(vc4_crtc);\n\tstruct vc4_dev *vc4 = to_vc4_dev(vc4_crtc->base.dev);\n\tu32 fifo_len_bytes = pv_data->fifo_depth;\n\n\t \n\tswitch (format) {\n\tcase PV_CONTROL_FORMAT_DSIV_16:\n\tcase PV_CONTROL_FORMAT_DSIC_16:\n\t\treturn fifo_len_bytes - 2 * HVS_FIFO_LATENCY_PIX;\n\tcase PV_CONTROL_FORMAT_DSIV_18:\n\t\treturn fifo_len_bytes - 14;\n\tcase PV_CONTROL_FORMAT_24:\n\tcase PV_CONTROL_FORMAT_DSIV_24:\n\tdefault:\n\t\t \n\t\tif (crtc_data->hvs_output == 5)\n\t\t\treturn 32;\n\n\t\t \n\t\tif (!vc4->is_vc5)\n\t\t\treturn fifo_len_bytes - 3 * HVS_FIFO_LATENCY_PIX - 1;\n\n\t\treturn fifo_len_bytes - 3 * HVS_FIFO_LATENCY_PIX;\n\t}\n}\n\nstatic u32 vc4_crtc_get_fifo_full_level_bits(struct vc4_crtc *vc4_crtc,\n\t\t\t\t\t     u32 format)\n{\n\tu32 level = vc4_get_fifo_full_level(vc4_crtc, format);\n\tu32 ret = 0;\n\n\tret |= VC4_SET_FIELD((level >> 6),\n\t\t\t     PV5_CONTROL_FIFO_LEVEL_HIGH);\n\n\treturn ret | VC4_SET_FIELD(level & 0x3f,\n\t\t\t\t   PV_CONTROL_FIFO_LEVEL);\n}\n\n \nstruct drm_encoder *vc4_get_crtc_encoder(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_crtc_state *state)\n{\n\tstruct drm_encoder *encoder;\n\n\tWARN_ON(hweight32(state->encoder_mask) > 1);\n\n\tdrm_for_each_encoder_mask(encoder, crtc->dev, state->encoder_mask)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void vc4_crtc_pixelvalve_reset(struct drm_crtc *crtc)\n{\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\t \n\tCRTC_WRITE(PV_CONTROL, CRTC_READ(PV_CONTROL) & ~PV_CONTROL_EN);\n\tCRTC_WRITE(PV_CONTROL, CRTC_READ(PV_CONTROL) | PV_CONTROL_FIFO_CLR);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_crtc_config_pv(struct drm_crtc *crtc, struct drm_encoder *encoder,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tconst struct vc4_pv_data *pv_data = vc4_crtc_to_vc4_pv_data(vc4_crtc);\n\tstruct drm_crtc_state *crtc_state = crtc->state;\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tbool interlace = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\tbool is_hdmi = vc4_encoder->type == VC4_ENCODER_TYPE_HDMI0 ||\n\t\t       vc4_encoder->type == VC4_ENCODER_TYPE_HDMI1;\n\tu32 pixel_rep = ((mode->flags & DRM_MODE_FLAG_DBLCLK) && !is_hdmi) ? 2 : 1;\n\tbool is_dsi = (vc4_encoder->type == VC4_ENCODER_TYPE_DSI0 ||\n\t\t       vc4_encoder->type == VC4_ENCODER_TYPE_DSI1);\n\tbool is_dsi1 = vc4_encoder->type == VC4_ENCODER_TYPE_DSI1;\n\tbool is_vec = vc4_encoder->type == VC4_ENCODER_TYPE_VEC;\n\tu32 format = is_dsi1 ? PV_CONTROL_FORMAT_DSIV_24 : PV_CONTROL_FORMAT_24;\n\tu8 ppc = pv_data->pixels_per_clock;\n\n\tu16 vert_bp = mode->crtc_vtotal - mode->crtc_vsync_end;\n\tu16 vert_sync = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tu16 vert_fp = mode->crtc_vsync_start - mode->crtc_vdisplay;\n\n\tbool debug_dump_regs = false;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\tif (debug_dump_regs) {\n\t\tstruct drm_printer p = drm_info_printer(&vc4_crtc->pdev->dev);\n\t\tdev_info(&vc4_crtc->pdev->dev, \"CRTC %d regs before:\\n\",\n\t\t\t drm_crtc_index(crtc));\n\t\tdrm_print_regset32(&p, &vc4_crtc->regset);\n\t}\n\n\tvc4_crtc_pixelvalve_reset(crtc);\n\n\tCRTC_WRITE(PV_HORZA,\n\t\t   VC4_SET_FIELD((mode->htotal - mode->hsync_end) * pixel_rep / ppc,\n\t\t\t\t PV_HORZA_HBP) |\n\t\t   VC4_SET_FIELD((mode->hsync_end - mode->hsync_start) * pixel_rep / ppc,\n\t\t\t\t PV_HORZA_HSYNC));\n\n\tCRTC_WRITE(PV_HORZB,\n\t\t   VC4_SET_FIELD((mode->hsync_start - mode->hdisplay) * pixel_rep / ppc,\n\t\t\t\t PV_HORZB_HFP) |\n\t\t   VC4_SET_FIELD(mode->hdisplay * pixel_rep / ppc,\n\t\t\t\t PV_HORZB_HACTIVE));\n\n\tif (interlace) {\n\t\tbool odd_field_first = false;\n\t\tu32 field_delay = mode->htotal * pixel_rep / (2 * ppc);\n\t\tu16 vert_bp_even = vert_bp;\n\t\tu16 vert_fp_even = vert_fp;\n\n\t\tif (is_vec) {\n\t\t\t \n\t\t\t++field_delay;\n\t\t\tif (mode->htotal == 858) {\n\t\t\t\t \n\t\t\t\todd_field_first = true;\n\t\t\t}\n\t\t}\n\n\t\tif (odd_field_first)\n\t\t\t++vert_fp_even;\n\t\telse\n\t\t\t++vert_bp;\n\n\t\tCRTC_WRITE(PV_VERTA_EVEN,\n\t\t\t   VC4_SET_FIELD(vert_bp_even, PV_VERTA_VBP) |\n\t\t\t   VC4_SET_FIELD(vert_sync, PV_VERTA_VSYNC));\n\t\tCRTC_WRITE(PV_VERTB_EVEN,\n\t\t\t   VC4_SET_FIELD(vert_fp_even, PV_VERTB_VFP) |\n\t\t\t   VC4_SET_FIELD(mode->crtc_vdisplay, PV_VERTB_VACTIVE));\n\n\t\t \n\t\tCRTC_WRITE(PV_V_CONTROL,\n\t\t\t   PV_VCONTROL_CONTINUOUS |\n\t\t\t   (is_dsi ? PV_VCONTROL_DSI : 0) |\n\t\t\t   PV_VCONTROL_INTERLACE |\n\t\t\t   (odd_field_first\n\t\t\t\t   ? PV_VCONTROL_ODD_FIRST\n\t\t\t\t   : VC4_SET_FIELD(field_delay,\n\t\t\t\t\t\t   PV_VCONTROL_ODD_DELAY)));\n\t\tCRTC_WRITE(PV_VSYNCD_EVEN,\n\t\t\t   (odd_field_first ? field_delay : 0));\n\t} else {\n\t\tCRTC_WRITE(PV_V_CONTROL,\n\t\t\t   PV_VCONTROL_CONTINUOUS |\n\t\t\t   (is_dsi ? PV_VCONTROL_DSI : 0));\n\t\tCRTC_WRITE(PV_VSYNCD_EVEN, 0);\n\t}\n\n\tCRTC_WRITE(PV_VERTA,\n\t\t   VC4_SET_FIELD(vert_bp, PV_VERTA_VBP) |\n\t\t   VC4_SET_FIELD(vert_sync, PV_VERTA_VSYNC));\n\tCRTC_WRITE(PV_VERTB,\n\t\t   VC4_SET_FIELD(vert_fp, PV_VERTB_VFP) |\n\t\t   VC4_SET_FIELD(mode->crtc_vdisplay, PV_VERTB_VACTIVE));\n\n\tif (is_dsi)\n\t\tCRTC_WRITE(PV_HACT_ACT, mode->hdisplay * pixel_rep);\n\n\tif (vc4->is_vc5)\n\t\tCRTC_WRITE(PV_MUX_CFG,\n\t\t\t   VC4_SET_FIELD(PV_MUX_CFG_RGB_PIXEL_MUX_MODE_NO_SWAP,\n\t\t\t\t\t PV_MUX_CFG_RGB_PIXEL_MUX_MODE));\n\n\tCRTC_WRITE(PV_CONTROL, PV_CONTROL_FIFO_CLR |\n\t\t   vc4_crtc_get_fifo_full_level_bits(vc4_crtc, format) |\n\t\t   VC4_SET_FIELD(format, PV_CONTROL_FORMAT) |\n\t\t   VC4_SET_FIELD(pixel_rep - 1, PV_CONTROL_PIXEL_REP) |\n\t\t   PV_CONTROL_CLR_AT_START |\n\t\t   PV_CONTROL_TRIGGER_UNDERFLOW |\n\t\t   PV_CONTROL_WAIT_HSTART |\n\t\t   VC4_SET_FIELD(vc4_encoder->clock_select,\n\t\t\t\t PV_CONTROL_CLK_SELECT));\n\n\tif (debug_dump_regs) {\n\t\tstruct drm_printer p = drm_info_printer(&vc4_crtc->pdev->dev);\n\t\tdev_info(&vc4_crtc->pdev->dev, \"CRTC %d regs after:\\n\",\n\t\t\t drm_crtc_index(crtc));\n\t\tdrm_print_regset32(&p, &vc4_crtc->regset);\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void require_hvs_enabled(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\n\tWARN_ON_ONCE((HVS_READ(SCALER_DISPCTRL) & SCALER_DISPCTRL_ENABLE) !=\n\t\t     SCALER_DISPCTRL_ENABLE);\n}\n\nstatic int vc4_crtc_disable(struct drm_crtc *crtc,\n\t\t\t    struct drm_encoder *encoder,\n\t\t\t    struct drm_atomic_state *state,\n\t\t\t    unsigned int channel)\n{\n\tstruct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tint idx, ret;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn -ENODEV;\n\n\tCRTC_WRITE(PV_V_CONTROL,\n\t\t   CRTC_READ(PV_V_CONTROL) & ~PV_VCONTROL_VIDEN);\n\tret = wait_for(!(CRTC_READ(PV_V_CONTROL) & PV_VCONTROL_VIDEN), 1);\n\tWARN_ONCE(ret, \"Timeout waiting for !PV_VCONTROL_VIDEN\\n\");\n\n\t \n\tmdelay(20);\n\n\tif (vc4_encoder && vc4_encoder->post_crtc_disable)\n\t\tvc4_encoder->post_crtc_disable(encoder, state);\n\n\tvc4_crtc_pixelvalve_reset(crtc);\n\tvc4_hvs_stop_channel(vc4->hvs, channel);\n\n\tif (vc4_encoder && vc4_encoder->post_crtc_powerdown)\n\t\tvc4_encoder->post_crtc_powerdown(encoder, state);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nint vc4_crtc_disable_at_boot(struct drm_crtc *crtc)\n{\n\tstruct drm_device *drm = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tenum vc4_encoder_type encoder_type;\n\tconst struct vc4_pv_data *pv_data;\n\tstruct drm_encoder *encoder;\n\tstruct vc4_hdmi *vc4_hdmi;\n\tunsigned encoder_sel;\n\tint channel;\n\tint ret;\n\n\tif (!(of_device_is_compatible(vc4_crtc->pdev->dev.of_node,\n\t\t\t\t      \"brcm,bcm2711-pixelvalve2\") ||\n\t      of_device_is_compatible(vc4_crtc->pdev->dev.of_node,\n\t\t\t\t      \"brcm,bcm2711-pixelvalve4\")))\n\t\treturn 0;\n\n\tif (!(CRTC_READ(PV_CONTROL) & PV_CONTROL_EN))\n\t\treturn 0;\n\n\tif (!(CRTC_READ(PV_V_CONTROL) & PV_VCONTROL_VIDEN))\n\t\treturn 0;\n\n\tchannel = vc4_hvs_get_fifo_from_output(vc4->hvs, vc4_crtc->data->hvs_output);\n\tif (channel < 0)\n\t\treturn 0;\n\n\tencoder_sel = VC4_GET_FIELD(CRTC_READ(PV_CONTROL), PV_CONTROL_CLK_SELECT);\n\tif (WARN_ON(encoder_sel != 0))\n\t\treturn 0;\n\n\tpv_data = vc4_crtc_to_vc4_pv_data(vc4_crtc);\n\tencoder_type = pv_data->encoder_types[encoder_sel];\n\tencoder = vc4_find_encoder_by_type(drm, encoder_type);\n\tif (WARN_ON(!encoder))\n\t\treturn 0;\n\n\tvc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tret = pm_runtime_resume_and_get(&vc4_hdmi->pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_crtc_disable(crtc, encoder, NULL, channel);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\treturn 0;\n}\n\nvoid vc4_crtc_send_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned long flags;\n\n\tif (!crtc->state || !crtc->state->event)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\tcrtc->state->event = NULL;\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nstatic void vc4_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct vc4_crtc_state *old_vc4_state = to_vc4_crtc_state(old_state);\n\tstruct drm_encoder *encoder = vc4_get_crtc_encoder(crtc, old_state);\n\tstruct drm_device *dev = crtc->dev;\n\n\tdrm_dbg(dev, \"Disabling CRTC %s (%u) connected to Encoder %s (%u)\",\n\t\tcrtc->name, crtc->base.id, encoder->name, encoder->base.id);\n\n\trequire_hvs_enabled(dev);\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\tvc4_crtc_disable(crtc, encoder, state, old_vc4_state->assigned_channel);\n\n\t \n\tvc4_crtc_send_vblank(crtc);\n}\n\nstatic void vc4_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *new_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct drm_encoder *encoder = vc4_get_crtc_encoder(crtc, new_state);\n\tstruct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);\n\tint idx;\n\n\tdrm_dbg(dev, \"Enabling CRTC %s (%u) connected to Encoder %s (%u)\",\n\t\tcrtc->name, crtc->base.id, encoder->name, encoder->base.id);\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\trequire_hvs_enabled(dev);\n\n\t \n\tdrm_crtc_vblank_on(crtc);\n\n\tvc4_hvs_atomic_enable(crtc, state);\n\n\tif (vc4_encoder->pre_crtc_configure)\n\t\tvc4_encoder->pre_crtc_configure(encoder, state);\n\n\tvc4_crtc_config_pv(crtc, encoder, state);\n\n\tCRTC_WRITE(PV_CONTROL, CRTC_READ(PV_CONTROL) | PV_CONTROL_EN);\n\n\tif (vc4_encoder->pre_crtc_enable)\n\t\tvc4_encoder->pre_crtc_enable(encoder, state);\n\n\t \n\tCRTC_WRITE(PV_V_CONTROL,\n\t\t   CRTC_READ(PV_V_CONTROL) | PV_VCONTROL_VIDEN);\n\n\tif (vc4_encoder->post_crtc_enable)\n\t\tvc4_encoder->post_crtc_enable(encoder, state);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic enum drm_mode_status vc4_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\t \n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN) {\n\t\tDRM_DEBUG_KMS(\"[CRTC:%d] Doublescan mode rejected.\\n\",\n\t\t\t      crtc->base.id);\n\t\treturn MODE_NO_DBLESCAN;\n\t}\n\n\treturn MODE_OK;\n}\n\nvoid vc4_crtc_get_margins(struct drm_crtc_state *state,\n\t\t\t  unsigned int *left, unsigned int *right,\n\t\t\t  unsigned int *top, unsigned int *bottom)\n{\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(state);\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\t*left = vc4_state->margins.left;\n\t*right = vc4_state->margins.right;\n\t*top = vc4_state->margins.top;\n\t*bottom = vc4_state->margins.bottom;\n\n\t \n\tfor_each_new_connector_in_state(state->state, conn, conn_state, i) {\n\t\tif (conn_state->crtc != state->crtc)\n\t\t\tcontinue;\n\n\t\t*left = conn_state->tv.margins.left;\n\t\t*right = conn_state->tv.margins.right;\n\t\t*top = conn_state->tv.margins.top;\n\t\t*bottom = conn_state->tv.margins.bottom;\n\t\tbreak;\n\t}\n}\n\nint vc4_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_encoder *encoder;\n\tint ret, i;\n\n\tret = vc4_hvs_atomic_check(crtc, state);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder = vc4_get_crtc_encoder(crtc, crtc_state);\n\tif (encoder) {\n\t\tconst struct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\t\tstruct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);\n\n\t\tif (vc4_encoder->type == VC4_ENCODER_TYPE_HDMI0) {\n\t\t\tvc4_state->hvs_load = max(mode->clock * mode->hdisplay / mode->htotal + 8000,\n\t\t\t\t\t\t  mode->clock * 9 / 10) * 1000;\n\t\t} else {\n\t\t\tvc4_state->hvs_load = mode->clock * 1000;\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(state, conn, conn_state,\n\t\t\t\t\ti) {\n\t\tif (conn_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tvc4_state->margins.left = conn_state->tv.margins.left;\n\t\tvc4_state->margins.right = conn_state->tv.margins.right;\n\t\tvc4_state->margins.top = conn_state->tv.margins.top;\n\t\tvc4_state->margins.bottom = conn_state->tv.margins.bottom;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn -ENODEV;\n\n\tCRTC_WRITE(PV_INTEN, PV_INT_VFP_START);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic void vc4_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\tCRTC_WRITE(PV_INTEN, 0);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_crtc_handle_page_flip(struct vc4_crtc *vc4_crtc)\n{\n\tstruct drm_crtc *crtc = &vc4_crtc->base;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tu32 chan = vc4_crtc->current_hvs_channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tspin_lock(&vc4_crtc->irq_lock);\n\tif (vc4_crtc->event &&\n\t    (vc4_crtc->current_dlist == HVS_READ(SCALER_DISPLACTX(chan)) ||\n\t     vc4_crtc->feeds_txp)) {\n\t\tdrm_crtc_send_vblank_event(crtc, vc4_crtc->event);\n\t\tvc4_crtc->event = NULL;\n\t\tdrm_crtc_vblank_put(crtc);\n\n\t\t \n\t\tvc4_hvs_unmask_underrun(hvs, chan);\n\t}\n\tspin_unlock(&vc4_crtc->irq_lock);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\nvoid vc4_crtc_handle_vblank(struct vc4_crtc *crtc)\n{\n\tcrtc->t_vblank = ktime_get();\n\tdrm_crtc_handle_vblank(&crtc->base);\n\tvc4_crtc_handle_page_flip(crtc);\n}\n\nstatic irqreturn_t vc4_crtc_irq_handler(int irq, void *data)\n{\n\tstruct vc4_crtc *vc4_crtc = data;\n\tu32 stat = CRTC_READ(PV_INTSTAT);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (stat & PV_INT_VFP_START) {\n\t\tCRTC_WRITE(PV_INTSTAT, PV_INT_VFP_START);\n\t\tvc4_crtc_handle_vblank(vc4_crtc);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstruct vc4_async_flip_state {\n\tstruct drm_crtc *crtc;\n\tstruct drm_framebuffer *fb;\n\tstruct drm_framebuffer *old_fb;\n\tstruct drm_pending_vblank_event *event;\n\n\tunion {\n\t\tstruct dma_fence_cb fence;\n\t\tstruct vc4_seqno_cb seqno;\n\t} cb;\n};\n\n \nstatic void\nvc4_async_page_flip_complete(struct vc4_async_flip_state *flip_state)\n{\n\tstruct drm_crtc *crtc = flip_state->crtc;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_plane *plane = crtc->primary;\n\n\tvc4_plane_async_set_fb(plane, flip_state->fb);\n\tif (flip_state->event) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tdrm_crtc_send_vblank_event(crtc, flip_state->event);\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\tdrm_crtc_vblank_put(crtc);\n\tdrm_framebuffer_put(flip_state->fb);\n\n\tif (flip_state->old_fb)\n\t\tdrm_framebuffer_put(flip_state->old_fb);\n\n\tkfree(flip_state);\n}\n\nstatic void vc4_async_page_flip_seqno_complete(struct vc4_seqno_cb *cb)\n{\n\tstruct vc4_async_flip_state *flip_state =\n\t\tcontainer_of(cb, struct vc4_async_flip_state, cb.seqno);\n\tstruct vc4_bo *bo = NULL;\n\n\tif (flip_state->old_fb) {\n\t\tstruct drm_gem_dma_object *dma_bo =\n\t\t\tdrm_fb_dma_get_gem_obj(flip_state->old_fb, 0);\n\t\tbo = to_vc4_bo(&dma_bo->base);\n\t}\n\n\tvc4_async_page_flip_complete(flip_state);\n\n\t \n\tif (bo)\n\t\tvc4_bo_dec_usecnt(bo);\n}\n\nstatic void vc4_async_page_flip_fence_complete(struct dma_fence *fence,\n\t\t\t\t\t       struct dma_fence_cb *cb)\n{\n\tstruct vc4_async_flip_state *flip_state =\n\t\tcontainer_of(cb, struct vc4_async_flip_state, cb.fence);\n\n\tvc4_async_page_flip_complete(flip_state);\n\tdma_fence_put(fence);\n}\n\nstatic int vc4_async_set_fence_cb(struct drm_device *dev,\n\t\t\t\t  struct vc4_async_flip_state *flip_state)\n{\n\tstruct drm_framebuffer *fb = flip_state->fb;\n\tstruct drm_gem_dma_object *dma_bo = drm_fb_dma_get_gem_obj(fb, 0);\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct dma_fence *fence;\n\tint ret;\n\n\tif (!vc4->is_vc5) {\n\t\tstruct vc4_bo *bo = to_vc4_bo(&dma_bo->base);\n\n\t\treturn vc4_queue_seqno_cb(dev, &flip_state->cb.seqno, bo->seqno,\n\t\t\t\t\t  vc4_async_page_flip_seqno_complete);\n\t}\n\n\tret = dma_resv_get_singleton(dma_bo->base.resv, DMA_RESV_USAGE_READ, &fence);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!fence) {\n\t\tvc4_async_page_flip_fence_complete(fence, &flip_state->cb.fence);\n\t\treturn 0;\n\t}\n\n\t \n\tif (dma_fence_add_callback(fence, &flip_state->cb.fence,\n\t\t\t\t   vc4_async_page_flip_fence_complete))\n\t\tvc4_async_page_flip_fence_complete(fence, &flip_state->cb.fence);\n\n\treturn 0;\n}\n\nstatic int\nvc4_async_page_flip_common(struct drm_crtc *crtc,\n\t\t\t   struct drm_framebuffer *fb,\n\t\t\t   struct drm_pending_vblank_event *event,\n\t\t\t   uint32_t flags)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_plane *plane = crtc->primary;\n\tstruct vc4_async_flip_state *flip_state;\n\n\tflip_state = kzalloc(sizeof(*flip_state), GFP_KERNEL);\n\tif (!flip_state)\n\t\treturn -ENOMEM;\n\n\tdrm_framebuffer_get(fb);\n\tflip_state->fb = fb;\n\tflip_state->crtc = crtc;\n\tflip_state->event = event;\n\n\t \n\tflip_state->old_fb = plane->state->fb;\n\tif (flip_state->old_fb)\n\t\tdrm_framebuffer_get(flip_state->old_fb);\n\n\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t \n\tdrm_atomic_set_fb_for_plane(plane->state, fb);\n\n\tvc4_async_set_fence_cb(dev, flip_state);\n\n\t \n\treturn 0;\n}\n\n \nstatic int vc4_async_page_flip(struct drm_crtc *crtc,\n\t\t\t       struct drm_framebuffer *fb,\n\t\t\t       struct drm_pending_vblank_event *event,\n\t\t\t       uint32_t flags)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_gem_dma_object *dma_bo = drm_fb_dma_get_gem_obj(fb, 0);\n\tstruct vc4_bo *bo = to_vc4_bo(&dma_bo->base);\n\tint ret;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\t \n\tret = vc4_bo_inc_usecnt(bo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_async_page_flip_common(crtc, fb, event, flags);\n\tif (ret) {\n\t\tvc4_bo_dec_usecnt(bo);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc5_async_page_flip(struct drm_crtc *crtc,\n\t\t\t       struct drm_framebuffer *fb,\n\t\t\t       struct drm_pending_vblank_event *event,\n\t\t\t       uint32_t flags)\n{\n\treturn vc4_async_page_flip_common(crtc, fb, event, flags);\n}\n\nint vc4_page_flip(struct drm_crtc *crtc,\n\t\t  struct drm_framebuffer *fb,\n\t\t  struct drm_pending_vblank_event *event,\n\t\t  uint32_t flags,\n\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tif (flags & DRM_MODE_PAGE_FLIP_ASYNC) {\n\t\tstruct drm_device *dev = crtc->dev;\n\t\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\t\tif (vc4->is_vc5)\n\t\t\treturn vc5_async_page_flip(crtc, fb, event, flags);\n\t\telse\n\t\t\treturn vc4_async_page_flip(crtc, fb, event, flags);\n\t} else {\n\t\treturn drm_atomic_helper_page_flip(crtc, fb, event, flags, ctx);\n\t}\n}\n\nstruct drm_crtc_state *vc4_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct vc4_crtc_state *vc4_state, *old_vc4_state;\n\n\tvc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);\n\tif (!vc4_state)\n\t\treturn NULL;\n\n\told_vc4_state = to_vc4_crtc_state(crtc->state);\n\tvc4_state->margins = old_vc4_state->margins;\n\tvc4_state->assigned_channel = old_vc4_state->assigned_channel;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &vc4_state->base);\n\treturn &vc4_state->base;\n}\n\nvoid vc4_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t    struct drm_crtc_state *state)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(crtc->dev);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(state);\n\n\tif (drm_mm_node_allocated(&vc4_state->mm)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&vc4->hvs->mm_lock, flags);\n\t\tdrm_mm_remove_node(&vc4_state->mm);\n\t\tspin_unlock_irqrestore(&vc4->hvs->mm_lock, flags);\n\n\t}\n\n\tdrm_atomic_helper_crtc_destroy_state(crtc, state);\n}\n\nvoid vc4_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct vc4_crtc_state *vc4_crtc_state;\n\n\tif (crtc->state)\n\t\tvc4_crtc_destroy_state(crtc, crtc->state);\n\n\tvc4_crtc_state = kzalloc(sizeof(*vc4_crtc_state), GFP_KERNEL);\n\tif (!vc4_crtc_state) {\n\t\tcrtc->state = NULL;\n\t\treturn;\n\t}\n\n\tvc4_crtc_state->assigned_channel = VC4_HVS_CHANNEL_DISABLED;\n\t__drm_atomic_helper_crtc_reset(crtc, &vc4_crtc_state->base);\n}\n\nint vc4_crtc_late_register(struct drm_crtc *crtc)\n{\n\tstruct drm_device *drm = crtc->dev;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tconst struct vc4_crtc_data *crtc_data = vc4_crtc_to_vc4_crtc_data(vc4_crtc);\n\n\tvc4_debugfs_add_regset32(drm, crtc_data->debugfs_name,\n\t\t\t\t &vc4_crtc->regset);\n\n\treturn 0;\n}\n\nstatic const struct drm_crtc_funcs vc4_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = vc4_page_flip,\n\t.set_property = NULL,\n\t.cursor_set = NULL,  \n\t.cursor_move = NULL,  \n\t.reset = vc4_crtc_reset,\n\t.atomic_duplicate_state = vc4_crtc_duplicate_state,\n\t.atomic_destroy_state = vc4_crtc_destroy_state,\n\t.enable_vblank = vc4_enable_vblank,\n\t.disable_vblank = vc4_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.late_register = vc4_crtc_late_register,\n};\n\nstatic const struct drm_crtc_helper_funcs vc4_crtc_helper_funcs = {\n\t.mode_valid = vc4_crtc_mode_valid,\n\t.atomic_check = vc4_crtc_atomic_check,\n\t.atomic_begin = vc4_hvs_atomic_begin,\n\t.atomic_flush = vc4_hvs_atomic_flush,\n\t.atomic_enable = vc4_crtc_atomic_enable,\n\t.atomic_disable = vc4_crtc_atomic_disable,\n\t.get_scanout_position = vc4_crtc_get_scanout_position,\n};\n\nconst struct vc4_pv_data bcm2835_pv0_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-0\",\n\t\t.debugfs_name = \"crtc0_regs\",\n\t\t.hvs_available_channels = BIT(0),\n\t\t.hvs_output = 0,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[PV_CONTROL_CLK_SELECT_DSI] = VC4_ENCODER_TYPE_DSI0,\n\t\t[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_DPI,\n\t},\n};\n\nconst struct vc4_pv_data bcm2835_pv1_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-1\",\n\t\t.debugfs_name = \"crtc1_regs\",\n\t\t.hvs_available_channels = BIT(2),\n\t\t.hvs_output = 2,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[PV_CONTROL_CLK_SELECT_DSI] = VC4_ENCODER_TYPE_DSI1,\n\t\t[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_SMI,\n\t},\n};\n\nconst struct vc4_pv_data bcm2835_pv2_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-2\",\n\t\t.debugfs_name = \"crtc2_regs\",\n\t\t.hvs_available_channels = BIT(1),\n\t\t.hvs_output = 1,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_HDMI0,\n\t\t[PV_CONTROL_CLK_SELECT_VEC] = VC4_ENCODER_TYPE_VEC,\n\t},\n};\n\nconst struct vc4_pv_data bcm2711_pv0_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-0\",\n\t\t.debugfs_name = \"crtc0_regs\",\n\t\t.hvs_available_channels = BIT(0),\n\t\t.hvs_output = 0,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[0] = VC4_ENCODER_TYPE_DSI0,\n\t\t[1] = VC4_ENCODER_TYPE_DPI,\n\t},\n};\n\nconst struct vc4_pv_data bcm2711_pv1_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-1\",\n\t\t.debugfs_name = \"crtc1_regs\",\n\t\t.hvs_available_channels = BIT(0) | BIT(1) | BIT(2),\n\t\t.hvs_output = 3,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[0] = VC4_ENCODER_TYPE_DSI1,\n\t\t[1] = VC4_ENCODER_TYPE_SMI,\n\t},\n};\n\nconst struct vc4_pv_data bcm2711_pv2_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-2\",\n\t\t.debugfs_name = \"crtc2_regs\",\n\t\t.hvs_available_channels = BIT(0) | BIT(1) | BIT(2),\n\t\t.hvs_output = 4,\n\t},\n\t.fifo_depth = 256,\n\t.pixels_per_clock = 2,\n\t.encoder_types = {\n\t\t[0] = VC4_ENCODER_TYPE_HDMI0,\n\t},\n};\n\nconst struct vc4_pv_data bcm2711_pv3_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-3\",\n\t\t.debugfs_name = \"crtc3_regs\",\n\t\t.hvs_available_channels = BIT(1),\n\t\t.hvs_output = 1,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 1,\n\t.encoder_types = {\n\t\t[PV_CONTROL_CLK_SELECT_VEC] = VC4_ENCODER_TYPE_VEC,\n\t},\n};\n\nconst struct vc4_pv_data bcm2711_pv4_data = {\n\t.base = {\n\t\t.name = \"pixelvalve-4\",\n\t\t.debugfs_name = \"crtc4_regs\",\n\t\t.hvs_available_channels = BIT(0) | BIT(1) | BIT(2),\n\t\t.hvs_output = 5,\n\t},\n\t.fifo_depth = 64,\n\t.pixels_per_clock = 2,\n\t.encoder_types = {\n\t\t[0] = VC4_ENCODER_TYPE_HDMI1,\n\t},\n};\n\nstatic const struct of_device_id vc4_crtc_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-pixelvalve0\", .data = &bcm2835_pv0_data },\n\t{ .compatible = \"brcm,bcm2835-pixelvalve1\", .data = &bcm2835_pv1_data },\n\t{ .compatible = \"brcm,bcm2835-pixelvalve2\", .data = &bcm2835_pv2_data },\n\t{ .compatible = \"brcm,bcm2711-pixelvalve0\", .data = &bcm2711_pv0_data },\n\t{ .compatible = \"brcm,bcm2711-pixelvalve1\", .data = &bcm2711_pv1_data },\n\t{ .compatible = \"brcm,bcm2711-pixelvalve2\", .data = &bcm2711_pv2_data },\n\t{ .compatible = \"brcm,bcm2711-pixelvalve3\", .data = &bcm2711_pv3_data },\n\t{ .compatible = \"brcm,bcm2711-pixelvalve4\", .data = &bcm2711_pv4_data },\n\t{}\n};\n\nstatic void vc4_set_crtc_possible_masks(struct drm_device *drm,\n\t\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tconst struct vc4_pv_data *pv_data = vc4_crtc_to_vc4_pv_data(vc4_crtc);\n\tconst enum vc4_encoder_type *encoder_types = pv_data->encoder_types;\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, drm) {\n\t\tstruct vc4_encoder *vc4_encoder;\n\t\tint i;\n\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_VIRTUAL)\n\t\t\tcontinue;\n\n\t\tvc4_encoder = to_vc4_encoder(encoder);\n\t\tfor (i = 0; i < ARRAY_SIZE(pv_data->encoder_types); i++) {\n\t\t\tif (vc4_encoder->type == encoder_types[i]) {\n\t\t\t\tvc4_encoder->clock_select = i;\n\t\t\t\tencoder->possible_crtcs |= drm_crtc_mask(crtc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint __vc4_crtc_init(struct drm_device *drm,\n\t\t    struct platform_device *pdev,\n\t\t    struct vc4_crtc *vc4_crtc,\n\t\t    const struct vc4_crtc_data *data,\n\t\t    struct drm_plane *primary_plane,\n\t\t    const struct drm_crtc_funcs *crtc_funcs,\n\t\t    const struct drm_crtc_helper_funcs *crtc_helper_funcs,\n\t\t    bool feeds_txp)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct drm_crtc *crtc = &vc4_crtc->base;\n\tunsigned int i;\n\tint ret;\n\n\tvc4_crtc->data = data;\n\tvc4_crtc->pdev = pdev;\n\tvc4_crtc->feeds_txp = feeds_txp;\n\tspin_lock_init(&vc4_crtc->irq_lock);\n\tret = drmm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,\n\t\t\t\t\t crtc_funcs, data->name);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(crtc, crtc_helper_funcs);\n\n\tif (!vc4->is_vc5) {\n\t\tdrm_mode_crtc_set_gamma_size(crtc, ARRAY_SIZE(vc4_crtc->lut_r));\n\n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, false, crtc->gamma_size);\n\n\t\t \n\t\tdrm_crtc_enable_color_mgmt(crtc, 0, true, crtc->gamma_size);\n\t}\n\n\tfor (i = 0; i < crtc->gamma_size; i++) {\n\t\tvc4_crtc->lut_r[i] = i;\n\t\tvc4_crtc->lut_g[i] = i;\n\t\tvc4_crtc->lut_b[i] = i;\n\t}\n\n\treturn 0;\n}\n\nint vc4_crtc_init(struct drm_device *drm, struct platform_device *pdev,\n\t\t  struct vc4_crtc *vc4_crtc,\n\t\t  const struct vc4_crtc_data *data,\n\t\t  const struct drm_crtc_funcs *crtc_funcs,\n\t\t  const struct drm_crtc_helper_funcs *crtc_helper_funcs,\n\t\t  bool feeds_txp)\n{\n\tstruct drm_plane *primary_plane;\n\n\t \n\tprimary_plane = vc4_plane_init(drm, DRM_PLANE_TYPE_PRIMARY, 0);\n\tif (IS_ERR(primary_plane)) {\n\t\tdev_err(drm->dev, \"failed to construct primary plane\\n\");\n\t\treturn PTR_ERR(primary_plane);\n\t}\n\n\treturn __vc4_crtc_init(drm, pdev, vc4_crtc, data, primary_plane,\n\t\t\t       crtc_funcs, crtc_helper_funcs, feeds_txp);\n}\n\nstatic int vc4_crtc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tconst struct vc4_pv_data *pv_data;\n\tstruct vc4_crtc *vc4_crtc;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\tvc4_crtc = drmm_kzalloc(drm, sizeof(*vc4_crtc), GFP_KERNEL);\n\tif (!vc4_crtc)\n\t\treturn -ENOMEM;\n\tcrtc = &vc4_crtc->base;\n\n\tpv_data = of_device_get_match_data(dev);\n\tif (!pv_data)\n\t\treturn -ENODEV;\n\n\tvc4_crtc->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(vc4_crtc->regs))\n\t\treturn PTR_ERR(vc4_crtc->regs);\n\n\tvc4_crtc->regset.base = vc4_crtc->regs;\n\tvc4_crtc->regset.regs = crtc_regs;\n\tvc4_crtc->regset.nregs = ARRAY_SIZE(crtc_regs);\n\n\tret = vc4_crtc_init(drm, pdev, vc4_crtc, &pv_data->base,\n\t\t\t    &vc4_crtc_funcs, &vc4_crtc_helper_funcs,\n\t\t\t    false);\n\tif (ret)\n\t\treturn ret;\n\tvc4_set_crtc_possible_masks(drm, crtc);\n\n\tCRTC_WRITE(PV_INTEN, 0);\n\tCRTC_WRITE(PV_INTSTAT, PV_INT_VFP_START);\n\tret = devm_request_irq(dev, platform_get_irq(pdev, 0),\n\t\t\t       vc4_crtc_irq_handler,\n\t\t\t       IRQF_SHARED,\n\t\t\t       \"vc4 crtc\", vc4_crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, vc4_crtc);\n\n\treturn 0;\n}\n\nstatic void vc4_crtc_unbind(struct device *dev, struct device *master,\n\t\t\t    void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct vc4_crtc *vc4_crtc = dev_get_drvdata(dev);\n\n\tCRTC_WRITE(PV_INTEN, 0);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct component_ops vc4_crtc_ops = {\n\t.bind   = vc4_crtc_bind,\n\t.unbind = vc4_crtc_unbind,\n};\n\nstatic int vc4_crtc_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_crtc_ops);\n}\n\nstatic void vc4_crtc_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_crtc_ops);\n}\n\nstruct platform_driver vc4_crtc_driver = {\n\t.probe = vc4_crtc_dev_probe,\n\t.remove_new = vc4_crtc_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_crtc\",\n\t\t.of_match_table = vc4_crtc_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}