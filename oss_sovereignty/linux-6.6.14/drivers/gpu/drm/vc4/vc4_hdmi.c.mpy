{
  "module_name": "vc4_hdmi.c",
  "hash_id": "b764e3bae92e700843a279cf48c90a82f6fb0bb922ff3a3f97b65372dee3b898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_hdmi.c",
  "human_readable_source": "\n \n\n \n\n#include <drm/display/drm_hdmi_helper.h>\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm_runtime.h>\n#include <linux/rational.h>\n#include <linux/reset.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/hdmi-codec.h>\n#include <sound/pcm_drm_eld.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"media/cec.h\"\n#include \"vc4_drv.h\"\n#include \"vc4_hdmi.h\"\n#include \"vc4_hdmi_regs.h\"\n#include \"vc4_regs.h\"\n\n#define VC5_HDMI_HORZA_HFP_SHIFT\t\t16\n#define VC5_HDMI_HORZA_HFP_MASK\t\t\tVC4_MASK(28, 16)\n#define VC5_HDMI_HORZA_VPOS\t\t\tBIT(15)\n#define VC5_HDMI_HORZA_HPOS\t\t\tBIT(14)\n#define VC5_HDMI_HORZA_HAP_SHIFT\t\t0\n#define VC5_HDMI_HORZA_HAP_MASK\t\t\tVC4_MASK(13, 0)\n\n#define VC5_HDMI_HORZB_HBP_SHIFT\t\t16\n#define VC5_HDMI_HORZB_HBP_MASK\t\t\tVC4_MASK(26, 16)\n#define VC5_HDMI_HORZB_HSP_SHIFT\t\t0\n#define VC5_HDMI_HORZB_HSP_MASK\t\t\tVC4_MASK(10, 0)\n\n#define VC5_HDMI_VERTA_VSP_SHIFT\t\t24\n#define VC5_HDMI_VERTA_VSP_MASK\t\t\tVC4_MASK(28, 24)\n#define VC5_HDMI_VERTA_VFP_SHIFT\t\t16\n#define VC5_HDMI_VERTA_VFP_MASK\t\t\tVC4_MASK(22, 16)\n#define VC5_HDMI_VERTA_VAL_SHIFT\t\t0\n#define VC5_HDMI_VERTA_VAL_MASK\t\t\tVC4_MASK(12, 0)\n\n#define VC5_HDMI_VERTB_VSPO_SHIFT\t\t16\n#define VC5_HDMI_VERTB_VSPO_MASK\t\tVC4_MASK(29, 16)\n\n#define VC4_HDMI_MISC_CONTROL_PIXEL_REP_SHIFT\t0\n#define VC4_HDMI_MISC_CONTROL_PIXEL_REP_MASK\tVC4_MASK(3, 0)\n#define VC5_HDMI_MISC_CONTROL_PIXEL_REP_SHIFT\t0\n#define VC5_HDMI_MISC_CONTROL_PIXEL_REP_MASK\tVC4_MASK(3, 0)\n\n#define VC5_HDMI_SCRAMBLER_CTL_ENABLE\t\tBIT(0)\n\n#define VC5_HDMI_DEEP_COLOR_CONFIG_1_INIT_PACK_PHASE_SHIFT\t8\n#define VC5_HDMI_DEEP_COLOR_CONFIG_1_INIT_PACK_PHASE_MASK\tVC4_MASK(10, 8)\n\n#define VC5_HDMI_DEEP_COLOR_CONFIG_1_COLOR_DEPTH_SHIFT\t\t0\n#define VC5_HDMI_DEEP_COLOR_CONFIG_1_COLOR_DEPTH_MASK\t\tVC4_MASK(3, 0)\n\n#define VC5_HDMI_GCP_CONFIG_GCP_ENABLE\t\tBIT(31)\n\n#define VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_1_SHIFT\t8\n#define VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_1_MASK\tVC4_MASK(15, 8)\n\n#define VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_0_MASK\tVC4_MASK(7, 0)\n#define VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_0_SET_AVMUTE\tBIT(0)\n#define VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_0_CLEAR_AVMUTE\tBIT(4)\n\n# define VC4_HD_M_SW_RST\t\t\tBIT(2)\n# define VC4_HD_M_ENABLE\t\t\tBIT(0)\n\n#define HSM_MIN_CLOCK_FREQ\t120000000\n#define CEC_CLOCK_FREQ 40000\n\n#define HDMI_14_MAX_TMDS_CLK   (340 * 1000 * 1000)\n\nstatic const char * const output_format_str[] = {\n\t[VC4_HDMI_OUTPUT_RGB]\t\t= \"RGB\",\n\t[VC4_HDMI_OUTPUT_YUV420]\t= \"YUV 4:2:0\",\n\t[VC4_HDMI_OUTPUT_YUV422]\t= \"YUV 4:2:2\",\n\t[VC4_HDMI_OUTPUT_YUV444]\t= \"YUV 4:4:4\",\n};\n\nstatic const char *vc4_hdmi_output_fmt_str(enum vc4_hdmi_output_format fmt)\n{\n\tif (fmt >= ARRAY_SIZE(output_format_str))\n\t\treturn \"invalid\";\n\n\treturn output_format_str[fmt];\n}\n\nstatic unsigned long long\nvc4_hdmi_encoder_compute_mode_clock(const struct drm_display_mode *mode,\n\t\t\t\t    unsigned int bpc, enum vc4_hdmi_output_format fmt);\n\nstatic bool vc4_hdmi_supports_scrambling(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_display_info *display = &vc4_hdmi->connector.display_info;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tif (!display->is_hdmi)\n\t\treturn false;\n\n\tif (!display->hdmi.scdc.supported ||\n\t    !display->hdmi.scdc.scrambling.supported)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool vc4_hdmi_mode_needs_scrambling(const struct drm_display_mode *mode,\n\t\t\t\t\t   unsigned int bpc,\n\t\t\t\t\t   enum vc4_hdmi_output_format fmt)\n{\n\tunsigned long long clock = vc4_hdmi_encoder_compute_mode_clock(mode, bpc, fmt);\n\n\treturn clock > HDMI_14_MAX_TMDS_CLK;\n}\n\nstatic bool vc4_hdmi_is_full_range(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t   struct vc4_hdmi_connector_state *vc4_state)\n{\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tstruct drm_display_info *display = &vc4_hdmi->connector.display_info;\n\n\tif (vc4_state->broadcast_rgb == VC4_HDMI_BROADCAST_RGB_LIMITED)\n\t\treturn false;\n\telse if (vc4_state->broadcast_rgb == VC4_HDMI_BROADCAST_RGB_FULL)\n\t\treturn true;\n\n\treturn !display->is_hdmi ||\n\t\tdrm_default_rgb_quant_range(mode) == HDMI_QUANTIZATION_RANGE_FULL;\n}\n\nstatic int vc4_hdmi_debugfs_regs(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct vc4_hdmi *vc4_hdmi = entry->file.data;\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn -ENODEV;\n\n\tdrm_print_regset32(&p, &vc4_hdmi->hdmi_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->hd_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->cec_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->csc_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->dvp_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->phy_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->ram_regset);\n\tdrm_print_regset32(&p, &vc4_hdmi->rm_regset);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic void vc4_hdmi_reset(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\t \n\tif (drm && !drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_M_CTL, VC4_HD_M_SW_RST);\n\tudelay(1);\n\tHDMI_WRITE(HDMI_M_CTL, 0);\n\n\tHDMI_WRITE(HDMI_M_CTL, VC4_HD_M_ENABLE);\n\n\tHDMI_WRITE(HDMI_SW_RESET_CONTROL,\n\t\t   VC4_HDMI_SW_RESET_HDMI |\n\t\t   VC4_HDMI_SW_RESET_FORMAT_DETECT);\n\n\tHDMI_WRITE(HDMI_SW_RESET_CONTROL, 0);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (drm)\n\t\tdrm_dev_exit(idx);\n}\n\nstatic void vc5_hdmi_reset(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\t \n\tif (drm && !drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\treset_control_reset(vc4_hdmi->reset);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_DVP_CTL, 0);\n\n\tHDMI_WRITE(HDMI_CLOCK_STOP,\n\t\t   HDMI_READ(HDMI_CLOCK_STOP) | VC4_DVP_HT_CLOCK_STOP_PIXEL);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (drm)\n\t\tdrm_dev_exit(idx);\n}\n\n#ifdef CONFIG_DRM_VC4_HDMI_CEC\nstatic void vc4_hdmi_cec_update_clk_div(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long cec_rate;\n\tunsigned long flags;\n\tu16 clk_cnt;\n\tu32 value;\n\tint idx;\n\n\t \n\tif (drm && !drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tcec_rate = clk_get_rate(vc4_hdmi->cec_clock);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tvalue = HDMI_READ(HDMI_CEC_CNTRL_1);\n\tvalue &= ~VC4_HDMI_CEC_DIV_CLK_CNT_MASK;\n\n\t \n\tclk_cnt = cec_rate / CEC_CLOCK_FREQ;\n\tvalue |= clk_cnt << VC4_HDMI_CEC_DIV_CLK_CNT_SHIFT;\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, value);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (drm)\n\t\tdrm_dev_exit(idx);\n}\n#else\nstatic void vc4_hdmi_cec_update_clk_div(struct vc4_hdmi *vc4_hdmi) {}\n#endif\n\nstatic int reset_pipe(struct drm_crtc *crtc,\n\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tstate = drm_atomic_state_alloc(crtc->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto out;\n\t}\n\n\tcrtc_state->connectors_changed = true;\n\n\tret = drm_atomic_commit(state);\nout:\n\tdrm_atomic_state_put(state);\n\n\treturn ret;\n}\n\nstatic int vc4_hdmi_reset_link(struct drm_connector *connector,\n\t\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *drm;\n\tstruct vc4_hdmi *vc4_hdmi;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tbool scrambling_needed;\n\tu8 config;\n\tint ret;\n\n\tif (!connector)\n\t\treturn 0;\n\n\tdrm = connector->dev;\n\tret = drm_modeset_lock(&drm->mode_config.connection_mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tconn_state = connector->state;\n\tcrtc = conn_state->crtc;\n\tif (!crtc)\n\t\treturn 0;\n\n\tret = drm_modeset_lock(&crtc->mutex, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tcrtc_state = crtc->state;\n\tif (!crtc_state->active)\n\t\treturn 0;\n\n\tvc4_hdmi = connector_to_vc4_hdmi(connector);\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!vc4_hdmi_supports_scrambling(vc4_hdmi)) {\n\t\tmutex_unlock(&vc4_hdmi->mutex);\n\t\treturn 0;\n\t}\n\n\tscrambling_needed = vc4_hdmi_mode_needs_scrambling(&vc4_hdmi->saved_adjusted_mode,\n\t\t\t\t\t\t\t   vc4_hdmi->output_bpc,\n\t\t\t\t\t\t\t   vc4_hdmi->output_format);\n\tif (!scrambling_needed) {\n\t\tmutex_unlock(&vc4_hdmi->mutex);\n\t\treturn 0;\n\t}\n\n\tif (conn_state->commit &&\n\t    !try_wait_for_completion(&conn_state->commit->hw_done)) {\n\t\tmutex_unlock(&vc4_hdmi->mutex);\n\t\treturn 0;\n\t}\n\n\tret = drm_scdc_readb(connector->ddc, SCDC_TMDS_CONFIG, &config);\n\tif (ret < 0) {\n\t\tdrm_err(drm, \"Failed to read TMDS config: %d\\n\", ret);\n\t\tmutex_unlock(&vc4_hdmi->mutex);\n\t\treturn 0;\n\t}\n\n\tif (!!(config & SCDC_SCRAMBLING_ENABLE) == scrambling_needed) {\n\t\tmutex_unlock(&vc4_hdmi->mutex);\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\t \n\treturn reset_pipe(crtc, ctx);\n}\n\nstatic void vc4_hdmi_handle_hotplug(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t    enum drm_connector_status status)\n{\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct edid *edid;\n\tint ret;\n\n\t \n\n\tif (status == connector_status_disconnected) {\n\t\tcec_phys_addr_invalidate(vc4_hdmi->cec_adap);\n\t\treturn;\n\t}\n\n\tedid = drm_get_edid(connector, vc4_hdmi->ddc);\n\tif (!edid)\n\t\treturn;\n\n\tcec_s_phys_addr_from_edid(vc4_hdmi->cec_adap, edid);\n\tkfree(edid);\n\n\tfor (;;) {\n\t\tret = vc4_hdmi_reset_link(connector, ctx);\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(ctx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic int vc4_hdmi_connector_detect_ctx(struct drm_connector *connector,\n\t\t\t\t\t struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t\t bool force)\n{\n\tstruct vc4_hdmi *vc4_hdmi = connector_to_vc4_hdmi(connector);\n\tenum drm_connector_status status = connector_status_disconnected;\n\n\t \n\n\tWARN_ON(pm_runtime_resume_and_get(&vc4_hdmi->pdev->dev));\n\n\tif (vc4_hdmi->hpd_gpio) {\n\t\tif (gpiod_get_value_cansleep(vc4_hdmi->hpd_gpio))\n\t\t\tstatus = connector_status_connected;\n\t} else {\n\t\tif (vc4_hdmi->variant->hp_detect &&\n\t\t    vc4_hdmi->variant->hp_detect(vc4_hdmi))\n\t\t\tstatus = connector_status_connected;\n\t}\n\n\tvc4_hdmi_handle_hotplug(vc4_hdmi, ctx, status);\n\tpm_runtime_put(&vc4_hdmi->pdev->dev);\n\n\treturn status;\n}\n\nstatic int vc4_hdmi_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct vc4_hdmi *vc4_hdmi = connector_to_vc4_hdmi(connector);\n\tstruct vc4_dev *vc4 = to_vc4_dev(connector->dev);\n\tint ret = 0;\n\tstruct edid *edid;\n\n\t \n\n\tedid = drm_get_edid(connector, vc4_hdmi->ddc);\n\tcec_s_phys_addr_from_edid(vc4_hdmi->cec_adap, edid);\n\tif (!edid)\n\t\treturn -ENODEV;\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tret = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\tif (!vc4->hvs->vc5_hdmi_enable_hdmi_20) {\n\t\tstruct drm_device *drm = connector->dev;\n\t\tconst struct drm_display_mode *mode;\n\n\t\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\t\tif (vc4_hdmi_mode_needs_scrambling(mode, 8, VC4_HDMI_OUTPUT_RGB)) {\n\t\t\t\tdrm_warn_once(drm, \"The core clock cannot reach frequencies high enough to support 4k @ 60Hz.\");\n\t\t\t\tdrm_warn_once(drm, \"Please change your config.txt file to add hdmi_enable_4kp60.\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int vc4_hdmi_connector_atomic_check(struct drm_connector *connector,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *old_state =\n\t\tdrm_atomic_get_old_connector_state(state, connector);\n\tstruct vc4_hdmi_connector_state *old_vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(old_state);\n\tstruct drm_connector_state *new_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tstruct vc4_hdmi_connector_state *new_vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(new_state);\n\tstruct drm_crtc *crtc = new_state->crtc;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tif (old_state->tv.margins.left != new_state->tv.margins.left ||\n\t    old_state->tv.margins.right != new_state->tv.margins.right ||\n\t    old_state->tv.margins.top != new_state->tv.margins.top ||\n\t    old_state->tv.margins.bottom != new_state->tv.margins.bottom) {\n\t\tstruct drm_crtc_state *crtc_state;\n\t\tint ret;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\t \n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (old_state->colorspace != new_state->colorspace ||\n\t    old_vc4_state->broadcast_rgb != new_vc4_state->broadcast_rgb ||\n\t    !drm_connector_atomic_hdr_metadata_equal(old_state, new_state)) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_connector_get_property(struct drm_connector *connector,\n\t\t\t\t\t   const struct drm_connector_state *state,\n\t\t\t\t\t   struct drm_property *property,\n\t\t\t\t\t   uint64_t *val)\n{\n\tstruct drm_device *drm = connector->dev;\n\tstruct vc4_hdmi *vc4_hdmi =\n\t\tconnector_to_vc4_hdmi(connector);\n\tconst struct vc4_hdmi_connector_state *vc4_conn_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(state);\n\n\tif (property == vc4_hdmi->broadcast_rgb_property) {\n\t\t*val = vc4_conn_state->broadcast_rgb;\n\t} else {\n\t\tdrm_dbg(drm, \"Unknown property [PROP:%d:%s]\\n\",\n\t\t\tproperty->base.id, property->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_connector_set_property(struct drm_connector *connector,\n\t\t\t\t\t   struct drm_connector_state *state,\n\t\t\t\t\t   struct drm_property *property,\n\t\t\t\t\t   uint64_t val)\n{\n\tstruct drm_device *drm = connector->dev;\n\tstruct vc4_hdmi *vc4_hdmi =\n\t\tconnector_to_vc4_hdmi(connector);\n\tstruct vc4_hdmi_connector_state *vc4_conn_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(state);\n\n\tif (property == vc4_hdmi->broadcast_rgb_property) {\n\t\tvc4_conn_state->broadcast_rgb = val;\n\t\treturn 0;\n\t}\n\n\tdrm_dbg(drm, \"Unknown property [PROP:%d:%s]\\n\",\n\t\tproperty->base.id, property->name);\n\treturn -EINVAL;\n}\n\nstatic void vc4_hdmi_connector_reset(struct drm_connector *connector)\n{\n\tstruct vc4_hdmi_connector_state *old_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(connector->state);\n\tstruct vc4_hdmi_connector_state *new_state =\n\t\tkzalloc(sizeof(*new_state), GFP_KERNEL);\n\n\tif (connector->state)\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\n\tkfree(old_state);\n\t__drm_atomic_helper_connector_reset(connector, &new_state->base);\n\n\tif (!new_state)\n\t\treturn;\n\n\tnew_state->base.max_bpc = 8;\n\tnew_state->base.max_requested_bpc = 8;\n\tnew_state->output_format = VC4_HDMI_OUTPUT_RGB;\n\tnew_state->broadcast_rgb = VC4_HDMI_BROADCAST_RGB_AUTO;\n\tdrm_atomic_helper_connector_tv_margins_reset(connector);\n}\n\nstatic struct drm_connector_state *\nvc4_hdmi_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct drm_connector_state *conn_state = connector->state;\n\tstruct vc4_hdmi_connector_state *vc4_state = conn_state_to_vc4_hdmi_conn_state(conn_state);\n\tstruct vc4_hdmi_connector_state *new_state;\n\n\tnew_state = kzalloc(sizeof(*new_state), GFP_KERNEL);\n\tif (!new_state)\n\t\treturn NULL;\n\n\tnew_state->tmds_char_rate = vc4_state->tmds_char_rate;\n\tnew_state->output_bpc = vc4_state->output_bpc;\n\tnew_state->output_format = vc4_state->output_format;\n\tnew_state->broadcast_rgb = vc4_state->broadcast_rgb;\n\t__drm_atomic_helper_connector_duplicate_state(connector, &new_state->base);\n\n\treturn &new_state->base;\n}\n\nstatic const struct drm_connector_funcs vc4_hdmi_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.reset = vc4_hdmi_connector_reset,\n\t.atomic_duplicate_state = vc4_hdmi_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_get_property = vc4_hdmi_connector_get_property,\n\t.atomic_set_property = vc4_hdmi_connector_set_property,\n};\n\nstatic const struct drm_connector_helper_funcs vc4_hdmi_connector_helper_funcs = {\n\t.detect_ctx = vc4_hdmi_connector_detect_ctx,\n\t.get_modes = vc4_hdmi_connector_get_modes,\n\t.atomic_check = vc4_hdmi_connector_atomic_check,\n};\n\nstatic const struct drm_prop_enum_list broadcast_rgb_names[] = {\n\t{ VC4_HDMI_BROADCAST_RGB_AUTO, \"Automatic\" },\n\t{ VC4_HDMI_BROADCAST_RGB_FULL, \"Full\" },\n\t{ VC4_HDMI_BROADCAST_RGB_LIMITED, \"Limited 16:235\" },\n};\n\nstatic void\nvc4_hdmi_attach_broadcast_rgb_property(struct drm_device *dev,\n\t\t\t\t       struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_property *prop = vc4_hdmi->broadcast_rgb_property;\n\n\tif (!prop) {\n\t\tprop = drm_property_create_enum(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t\t\t\"Broadcast RGB\",\n\t\t\t\t\t\tbroadcast_rgb_names,\n\t\t\t\t\t\tARRAY_SIZE(broadcast_rgb_names));\n\t\tif (!prop)\n\t\t\treturn;\n\n\t\tvc4_hdmi->broadcast_rgb_property = prop;\n\t}\n\n\tdrm_object_attach_property(&vc4_hdmi->connector.base, prop,\n\t\t\t\t   VC4_HDMI_BROADCAST_RGB_AUTO);\n}\n\nstatic int vc4_hdmi_connector_init(struct drm_device *dev,\n\t\t\t\t   struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_encoder *encoder = &vc4_hdmi->encoder.base;\n\tint ret;\n\n\tret = drmm_connector_init(dev, connector,\n\t\t\t\t  &vc4_hdmi_connector_funcs,\n\t\t\t\t  DRM_MODE_CONNECTOR_HDMIA,\n\t\t\t\t  vc4_hdmi->ddc);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &vc4_hdmi_connector_helper_funcs);\n\n\t \n\tif (connector->funcs->reset)\n\t\tconnector->funcs->reset(connector);\n\n\t \n\tret = drm_mode_create_tv_margin_properties(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_mode_create_hdmi_colorspace_property(connector, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_attach_colorspace_property(connector);\n\tdrm_connector_attach_tv_margin_properties(connector);\n\tdrm_connector_attach_max_bpc_property(connector, 8, 12);\n\n\tconnector->polled = (DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t     DRM_CONNECTOR_POLL_DISCONNECT);\n\n\tconnector->interlace_allowed = 1;\n\tconnector->doublescan_allowed = 0;\n\tconnector->stereo_allowed = 1;\n\n\tif (vc4_hdmi->variant->supports_hdr)\n\t\tdrm_connector_attach_hdr_output_metadata_property(connector);\n\n\tvc4_hdmi_attach_broadcast_rgb_property(dev, vc4_hdmi);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_stop_packet(struct drm_encoder *encoder,\n\t\t\t\tenum hdmi_infoframe_type type,\n\t\t\t\tbool poll)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tu32 packet_id = type - 0x80;\n\tunsigned long flags;\n\tint ret = 0;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_RAM_PACKET_CONFIG,\n\t\t   HDMI_READ(HDMI_RAM_PACKET_CONFIG) & ~BIT(packet_id));\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (poll) {\n\t\tret = wait_for(!(HDMI_READ(HDMI_RAM_PACKET_STATUS) &\n\t\t\t\t BIT(packet_id)), 100);\n\t}\n\n\tdrm_dev_exit(idx);\n\treturn ret;\n}\n\nstatic void vc4_hdmi_write_infoframe(struct drm_encoder *encoder,\n\t\t\t\t     union hdmi_infoframe *frame)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tu32 packet_id = frame->any.type - 0x80;\n\tconst struct vc4_hdmi_register *ram_packet_start =\n\t\t&vc4_hdmi->variant->registers[HDMI_RAM_PACKET_START];\n\tu32 packet_reg = ram_packet_start->offset + VC4_HDMI_PACKET_STRIDE * packet_id;\n\tu32 packet_reg_next = ram_packet_start->offset +\n\t\tVC4_HDMI_PACKET_STRIDE * (packet_id + 1);\n\tvoid __iomem *base = __vc4_hdmi_get_field_base(vc4_hdmi,\n\t\t\t\t\t\t       ram_packet_start->reg);\n\tuint8_t buffer[VC4_HDMI_PACKET_STRIDE] = {};\n\tunsigned long flags;\n\tssize_t len, i;\n\tint ret;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tWARN_ONCE(!(HDMI_READ(HDMI_RAM_PACKET_CONFIG) &\n\t\t    VC4_HDMI_RAM_PACKET_ENABLE),\n\t\t  \"Packet RAM has to be on to store the packet.\");\n\n\tlen = hdmi_infoframe_pack(frame, buffer, sizeof(buffer));\n\tif (len < 0)\n\t\tgoto out;\n\n\tret = vc4_hdmi_stop_packet(encoder, frame->any.type, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to wait for infoframe to go idle: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tfor (i = 0; i < len; i += 7) {\n\t\twritel(buffer[i + 0] << 0 |\n\t\t       buffer[i + 1] << 8 |\n\t\t       buffer[i + 2] << 16,\n\t\t       base + packet_reg);\n\t\tpacket_reg += 4;\n\n\t\twritel(buffer[i + 3] << 0 |\n\t\t       buffer[i + 4] << 8 |\n\t\t       buffer[i + 5] << 16 |\n\t\t       buffer[i + 6] << 24,\n\t\t       base + packet_reg);\n\t\tpacket_reg += 4;\n\t}\n\n\t \n\tfor (; packet_reg < packet_reg_next; packet_reg += 4)\n\t\twritel(0, base + packet_reg);\n\n\tHDMI_WRITE(HDMI_RAM_PACKET_CONFIG,\n\t\t   HDMI_READ(HDMI_RAM_PACKET_CONFIG) | BIT(packet_id));\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tret = wait_for((HDMI_READ(HDMI_RAM_PACKET_STATUS) &\n\t\t\tBIT(packet_id)), 100);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to wait for infoframe to start: %d\\n\", ret);\n\nout:\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_avi_infoframe_colorspace(struct hdmi_avi_infoframe *frame,\n\t\t\t\t\t      enum vc4_hdmi_output_format fmt)\n{\n\tswitch (fmt) {\n\tcase VC4_HDMI_OUTPUT_RGB:\n\t\tframe->colorspace = HDMI_COLORSPACE_RGB;\n\t\tbreak;\n\n\tcase VC4_HDMI_OUTPUT_YUV420:\n\t\tframe->colorspace = HDMI_COLORSPACE_YUV420;\n\t\tbreak;\n\n\tcase VC4_HDMI_OUTPUT_YUV422:\n\t\tframe->colorspace = HDMI_COLORSPACE_YUV422;\n\t\tbreak;\n\n\tcase VC4_HDMI_OUTPUT_YUV444:\n\t\tframe->colorspace = HDMI_COLORSPACE_YUV444;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vc4_hdmi_set_avi_infoframe(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_connector_state *cstate = connector->state;\n\tstruct vc4_hdmi_connector_state *vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(cstate);\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tunion hdmi_infoframe frame;\n\tint ret;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\n\t\t\t\t\t\t       connector, mode);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"couldn't fill AVI infoframe\\n\");\n\t\treturn;\n\t}\n\n\tdrm_hdmi_avi_infoframe_quant_range(&frame.avi,\n\t\t\t\t\t   connector, mode,\n\t\t\t\t\t   vc4_hdmi_is_full_range(vc4_hdmi, vc4_state) ?\n\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL :\n\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED);\n\tdrm_hdmi_avi_infoframe_colorimetry(&frame.avi, cstate);\n\tvc4_hdmi_avi_infoframe_colorspace(&frame.avi, vc4_state->output_format);\n\tdrm_hdmi_avi_infoframe_bars(&frame.avi, cstate);\n\n\tvc4_hdmi_write_infoframe(encoder, &frame);\n}\n\nstatic void vc4_hdmi_set_spd_infoframe(struct drm_encoder *encoder)\n{\n\tunion hdmi_infoframe frame;\n\tint ret;\n\n\tret = hdmi_spd_infoframe_init(&frame.spd, \"Broadcom\", \"Videocore\");\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"couldn't fill SPD infoframe\\n\");\n\t\treturn;\n\t}\n\n\tframe.spd.sdi = HDMI_SPD_SDI_PC;\n\n\tvc4_hdmi_write_infoframe(encoder, &frame);\n}\n\nstatic void vc4_hdmi_set_audio_infoframe(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct hdmi_audio_infoframe *audio = &vc4_hdmi->audio.infoframe;\n\tunion hdmi_infoframe frame;\n\n\tmemcpy(&frame.audio, audio, sizeof(*audio));\n\n\tif (vc4_hdmi->packet_ram_enabled)\n\t\tvc4_hdmi_write_infoframe(encoder, &frame);\n}\n\nstatic void vc4_hdmi_set_hdr_infoframe(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_connector_state *conn_state = connector->state;\n\tunion hdmi_infoframe frame;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tif (!vc4_hdmi->variant->supports_hdr)\n\t\treturn;\n\n\tif (!conn_state->hdr_output_metadata)\n\t\treturn;\n\n\tif (drm_hdmi_infoframe_set_hdr_metadata(&frame.drm, conn_state))\n\t\treturn;\n\n\tvc4_hdmi_write_infoframe(encoder, &frame);\n}\n\nstatic void vc4_hdmi_set_infoframes(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tvc4_hdmi_set_avi_infoframe(encoder);\n\tvc4_hdmi_set_spd_infoframe(encoder);\n\t \n\tif (vc4_hdmi->audio.streaming)\n\t\tvc4_hdmi_set_audio_infoframe(encoder);\n\n\tvc4_hdmi_set_hdr_infoframe(encoder);\n}\n\n#define SCRAMBLING_POLLING_DELAY_MS\t1000\n\nstatic void vc4_hdmi_enable_scrambling(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_device *drm = connector->dev;\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tunsigned long flags;\n\tint idx;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tif (!vc4_hdmi_supports_scrambling(vc4_hdmi))\n\t\treturn;\n\n\tif (!vc4_hdmi_mode_needs_scrambling(mode,\n\t\t\t\t\t    vc4_hdmi->output_bpc,\n\t\t\t\t\t    vc4_hdmi->output_format))\n\t\treturn;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tdrm_scdc_set_high_tmds_clock_ratio(connector, true);\n\tdrm_scdc_set_scrambling(connector, true);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_SCRAMBLER_CTL, HDMI_READ(HDMI_SCRAMBLER_CTL) |\n\t\t   VC5_HDMI_SCRAMBLER_CTL_ENABLE);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n\n\tvc4_hdmi->scdc_enabled = true;\n\n\tqueue_delayed_work(system_wq, &vc4_hdmi->scrambling_work,\n\t\t\t   msecs_to_jiffies(SCRAMBLING_POLLING_DELAY_MS));\n}\n\nstatic void vc4_hdmi_disable_scrambling(struct drm_encoder *encoder)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_device *drm = connector->dev;\n\tunsigned long flags;\n\tint idx;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tif (!vc4_hdmi->scdc_enabled)\n\t\treturn;\n\n\tvc4_hdmi->scdc_enabled = false;\n\n\tif (delayed_work_pending(&vc4_hdmi->scrambling_work))\n\t\tcancel_delayed_work_sync(&vc4_hdmi->scrambling_work);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_SCRAMBLER_CTL, HDMI_READ(HDMI_SCRAMBLER_CTL) &\n\t\t   ~VC5_HDMI_SCRAMBLER_CTL_ENABLE);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_scdc_set_scrambling(connector, false);\n\tdrm_scdc_set_high_tmds_clock_ratio(connector, false);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_scrambling_wq(struct work_struct *work)\n{\n\tstruct vc4_hdmi *vc4_hdmi = container_of(to_delayed_work(work),\n\t\t\t\t\t\t struct vc4_hdmi,\n\t\t\t\t\t\t scrambling_work);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\n\tif (drm_scdc_get_scrambling_status(connector))\n\t\treturn;\n\n\tdrm_scdc_set_high_tmds_clock_ratio(connector, true);\n\tdrm_scdc_set_scrambling(connector, true);\n\n\tqueue_delayed_work(system_wq, &vc4_hdmi->scrambling_work,\n\t\t\t   msecs_to_jiffies(SCRAMBLING_POLLING_DELAY_MS));\n}\n\nstatic void vc4_hdmi_encoder_post_crtc_disable(struct drm_encoder *encoder,\n\t\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tvc4_hdmi->packet_ram_enabled = false;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_RAM_PACKET_CONFIG, 0);\n\n\tHDMI_WRITE(HDMI_VID_CTL, HDMI_READ(HDMI_VID_CTL) | VC4_HD_VID_CTL_CLRRGB);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tmdelay(1);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_VID_CTL,\n\t\t   HDMI_READ(HDMI_VID_CTL) & ~VC4_HD_VID_CTL_ENABLE);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tvc4_hdmi_disable_scrambling(encoder);\n\n\tdrm_dev_exit(idx);\n\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic void vc4_hdmi_encoder_post_crtc_powerdown(struct drm_encoder *encoder,\n\t\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint ret;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_VID_CTL,\n\t\t   HDMI_READ(HDMI_VID_CTL) | VC4_HD_VID_CTL_BLANKPIX);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (vc4_hdmi->variant->phy_disable)\n\t\tvc4_hdmi->variant->phy_disable(vc4_hdmi);\n\n\tclk_disable_unprepare(vc4_hdmi->pixel_bvb_clock);\n\tclk_disable_unprepare(vc4_hdmi->pixel_clock);\n\n\tret = pm_runtime_put(&vc4_hdmi->pdev->dev);\n\tif (ret < 0)\n\t\tDRM_ERROR(\"Failed to release power domain: %d\\n\", ret);\n\n\tdrm_dev_exit(idx);\n\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic void vc4_hdmi_csc_setup(struct vc4_hdmi *vc4_hdmi,\n\t\t\t       struct drm_connector_state *state,\n\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct vc4_hdmi_connector_state *vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(state);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tu32 csc_ctl;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tcsc_ctl = VC4_SET_FIELD(VC4_HD_CSC_CTL_ORDER_BGR,\n\t\t\t\tVC4_HD_CSC_CTL_ORDER);\n\n\tif (!vc4_hdmi_is_full_range(vc4_hdmi, vc4_state)) {\n\t\t \n\t\tcsc_ctl |= VC4_HD_CSC_CTL_ENABLE;\n\t\tcsc_ctl |= VC4_HD_CSC_CTL_RGB2YCC;\n\t\tcsc_ctl |= VC4_SET_FIELD(VC4_HD_CSC_CTL_MODE_CUSTOM,\n\t\t\t\t\t VC4_HD_CSC_CTL_MODE);\n\n\t\tHDMI_WRITE(HDMI_CSC_12_11, (0x000 << 16) | 0x000);\n\t\tHDMI_WRITE(HDMI_CSC_14_13, (0x100 << 16) | 0x6e0);\n\t\tHDMI_WRITE(HDMI_CSC_22_21, (0x6e0 << 16) | 0x000);\n\t\tHDMI_WRITE(HDMI_CSC_24_23, (0x100 << 16) | 0x000);\n\t\tHDMI_WRITE(HDMI_CSC_32_31, (0x000 << 16) | 0x6e0);\n\t\tHDMI_WRITE(HDMI_CSC_34_33, (0x100 << 16) | 0x000);\n\t}\n\n\t \n\tHDMI_WRITE(HDMI_CSC_CTL, csc_ctl);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n}\n\n \nstatic const u16 vc5_hdmi_csc_full_rgb_to_rgb[2][3][4] = {\n\t{\n\t\t \n\t\t{ 0x2000, 0x0000, 0x0000, 0x0000 },\n\t\t{ 0x0000, 0x2000, 0x0000, 0x0000 },\n\t\t{ 0x0000, 0x0000, 0x2000, 0x0000 },\n\t},\n\t{\n\t\t \n\t\t{ 0x1b80, 0x0000, 0x0000, 0x0400 },\n\t\t{ 0x0000, 0x1b80, 0x0000, 0x0400 },\n\t\t{ 0x0000, 0x0000, 0x1b80, 0x0400 },\n\t},\n};\n\n \nstatic const u16 vc5_hdmi_csc_full_rgb_to_yuv_bt601[2][3][4] = {\n\t{\n\t\t \n\t\t{ 0x0991, 0x12c9, 0x03a6, 0x0000 },\n\t\t{ 0xfa9b, 0xf567, 0x1000, 0x2000 },\n\t\t{ 0x1000, 0xf29b, 0xfd67, 0x2000 },\n\t},\n\t{\n\t\t \n\t\t{ 0x082f, 0x1012, 0x031f, 0x0400 },\n\t\t{ 0xfb48, 0xf6ba, 0x0e00, 0x2000 },\n\t\t{ 0x0e00, 0xf448, 0xfdba, 0x2000 },\n\t},\n};\n\n \nstatic const u16 vc5_hdmi_csc_full_rgb_to_yuv_bt709[2][3][4] = {\n\t{\n\t\t \n\t\t{ 0x06ce, 0x16e3, 0x024f, 0x0000 },\n\t\t{ 0xfc56, 0xf3ac, 0x1000, 0x2000 },\n\t\t{ 0x1000, 0xf179, 0xfe89, 0x2000 },\n\t},\n\t{\n\t\t \n\t\t{ 0x05d2, 0x1394, 0x01fa, 0x0400 },\n\t\t{ 0xfccc, 0xf536, 0x0e00, 0x2000 },\n\t\t{ 0x0e00, 0xf34a, 0xfeb8, 0x2000 },\n\t},\n};\n\n \nstatic const u16 vc5_hdmi_csc_full_rgb_to_yuv_bt2020[2][3][4] = {\n\t{\n\t\t \n\t\t{ 0x0868, 0x15b2, 0x01e6, 0x0000 },\n\t\t{ 0xfb89, 0xf479, 0x1000, 0x2000 },\n\t\t{ 0x1000, 0xf14a, 0xfeb8, 0x2000 },\n\t},\n\t{\n\t\t \n\t\t{ 0x082f, 0x1012, 0x031f, 0x0400 },\n\t\t{ 0xfb48, 0xf6ba, 0x0e00, 0x2000 },\n\t\t{ 0x0e00, 0xf448, 0xfdba, 0x2000 },\n\t},\n};\n\nstatic void vc5_hdmi_set_csc_coeffs(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t    const u16 coeffs[3][4])\n{\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\tHDMI_WRITE(HDMI_CSC_12_11, (coeffs[0][1] << 16) | coeffs[0][0]);\n\tHDMI_WRITE(HDMI_CSC_14_13, (coeffs[0][3] << 16) | coeffs[0][2]);\n\tHDMI_WRITE(HDMI_CSC_22_21, (coeffs[1][1] << 16) | coeffs[1][0]);\n\tHDMI_WRITE(HDMI_CSC_24_23, (coeffs[1][3] << 16) | coeffs[1][2]);\n\tHDMI_WRITE(HDMI_CSC_32_31, (coeffs[2][1] << 16) | coeffs[2][0]);\n\tHDMI_WRITE(HDMI_CSC_34_33, (coeffs[2][3] << 16) | coeffs[2][2]);\n}\n\nstatic void vc5_hdmi_set_csc_coeffs_swap(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t\t const u16 coeffs[3][4])\n{\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\t \n\tHDMI_WRITE(HDMI_CSC_12_11, (coeffs[1][1] << 16) | coeffs[1][0]);\n\tHDMI_WRITE(HDMI_CSC_14_13, (coeffs[1][3] << 16) | coeffs[1][2]);\n\tHDMI_WRITE(HDMI_CSC_22_21, (coeffs[2][1] << 16) | coeffs[2][0]);\n\tHDMI_WRITE(HDMI_CSC_24_23, (coeffs[2][3] << 16) | coeffs[2][2]);\n\tHDMI_WRITE(HDMI_CSC_32_31, (coeffs[0][1] << 16) | coeffs[0][0]);\n\tHDMI_WRITE(HDMI_CSC_34_33, (coeffs[0][3] << 16) | coeffs[0][2]);\n}\n\nstatic const u16\n(*vc5_hdmi_find_yuv_csc_coeffs(struct vc4_hdmi *vc4_hdmi, u32 colorspace, bool limited))[4]\n{\n\tswitch (colorspace) {\n\tcase DRM_MODE_COLORIMETRY_SMPTE_170M_YCC:\n\tcase DRM_MODE_COLORIMETRY_XVYCC_601:\n\tcase DRM_MODE_COLORIMETRY_SYCC_601:\n\tcase DRM_MODE_COLORIMETRY_OPYCC_601:\n\tcase DRM_MODE_COLORIMETRY_BT601_YCC:\n\t\treturn vc5_hdmi_csc_full_rgb_to_yuv_bt601[limited];\n\n\tdefault:\n\tcase DRM_MODE_COLORIMETRY_NO_DATA:\n\tcase DRM_MODE_COLORIMETRY_BT709_YCC:\n\tcase DRM_MODE_COLORIMETRY_XVYCC_709:\n\tcase DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED:\n\tcase DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT:\n\t\treturn vc5_hdmi_csc_full_rgb_to_yuv_bt709[limited];\n\n\tcase DRM_MODE_COLORIMETRY_BT2020_CYCC:\n\tcase DRM_MODE_COLORIMETRY_BT2020_YCC:\n\tcase DRM_MODE_COLORIMETRY_BT2020_RGB:\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65:\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER:\n\t\treturn vc5_hdmi_csc_full_rgb_to_yuv_bt2020[limited];\n\t}\n}\n\nstatic void vc5_hdmi_csc_setup(struct vc4_hdmi *vc4_hdmi,\n\t\t\t       struct drm_connector_state *state,\n\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tstruct vc4_hdmi_connector_state *vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(state);\n\tunsigned int lim_range = vc4_hdmi_is_full_range(vc4_hdmi, vc4_state) ? 0 : 1;\n\tunsigned long flags;\n\tconst u16 (*csc)[4];\n\tu32 if_cfg = 0;\n\tu32 if_xbar = 0x543210;\n\tu32 csc_chan_ctl = 0;\n\tu32 csc_ctl = VC5_MT_CP_CSC_CTL_ENABLE | VC4_SET_FIELD(VC4_HD_CSC_CTL_MODE_CUSTOM,\n\t\t\t\t\t\t\t       VC5_MT_CP_CSC_CTL_MODE);\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tswitch (vc4_state->output_format) {\n\tcase VC4_HDMI_OUTPUT_YUV444:\n\t\tcsc = vc5_hdmi_find_yuv_csc_coeffs(vc4_hdmi, state->colorspace, !!lim_range);\n\n\t\tvc5_hdmi_set_csc_coeffs_swap(vc4_hdmi, csc);\n\t\tbreak;\n\n\tcase VC4_HDMI_OUTPUT_YUV422:\n\t\tcsc = vc5_hdmi_find_yuv_csc_coeffs(vc4_hdmi, state->colorspace, !!lim_range);\n\n\t\tcsc_ctl |= VC4_SET_FIELD(VC5_MT_CP_CSC_CTL_FILTER_MODE_444_TO_422_STANDARD,\n\t\t\t\t\t VC5_MT_CP_CSC_CTL_FILTER_MODE_444_TO_422) |\n\t\t\tVC5_MT_CP_CSC_CTL_USE_444_TO_422 |\n\t\t\tVC5_MT_CP_CSC_CTL_USE_RNG_SUPPRESSION;\n\n\t\tcsc_chan_ctl |= VC4_SET_FIELD(VC5_MT_CP_CHANNEL_CTL_OUTPUT_REMAP_LEGACY_STYLE,\n\t\t\t\t\t      VC5_MT_CP_CHANNEL_CTL_OUTPUT_REMAP);\n\n\t\tif_cfg |= VC4_SET_FIELD(VC5_DVP_HT_VEC_INTERFACE_CFG_SEL_422_FORMAT_422_LEGACY,\n\t\t\t\t\tVC5_DVP_HT_VEC_INTERFACE_CFG_SEL_422);\n\n\t\tvc5_hdmi_set_csc_coeffs(vc4_hdmi, csc);\n\t\tbreak;\n\n\tcase VC4_HDMI_OUTPUT_RGB:\n\t\tif_xbar = 0x354021;\n\n\t\tvc5_hdmi_set_csc_coeffs(vc4_hdmi, vc5_hdmi_csc_full_rgb_to_rgb[lim_range]);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tHDMI_WRITE(HDMI_VEC_INTERFACE_CFG, if_cfg);\n\tHDMI_WRITE(HDMI_VEC_INTERFACE_XBAR, if_xbar);\n\tHDMI_WRITE(HDMI_CSC_CHANNEL_CTL, csc_chan_ctl);\n\tHDMI_WRITE(HDMI_CSC_CTL, csc_ctl);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_set_timings(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t struct drm_connector_state *state,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tbool hsync_pos = mode->flags & DRM_MODE_FLAG_PHSYNC;\n\tbool vsync_pos = mode->flags & DRM_MODE_FLAG_PVSYNC;\n\tbool interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\tu32 pixel_rep = (mode->flags & DRM_MODE_FLAG_DBLCLK) ? 2 : 1;\n\tu32 verta = (VC4_SET_FIELD(mode->crtc_vsync_end - mode->crtc_vsync_start,\n\t\t\t\t   VC4_HDMI_VERTA_VSP) |\n\t\t     VC4_SET_FIELD(mode->crtc_vsync_start - mode->crtc_vdisplay,\n\t\t\t\t   VC4_HDMI_VERTA_VFP) |\n\t\t     VC4_SET_FIELD(mode->crtc_vdisplay, VC4_HDMI_VERTA_VAL));\n\tu32 vertb = (VC4_SET_FIELD(0, VC4_HDMI_VERTB_VSPO) |\n\t\t     VC4_SET_FIELD(mode->crtc_vtotal - mode->crtc_vsync_end +\n\t\t\t\t   interlaced,\n\t\t\t\t   VC4_HDMI_VERTB_VBP));\n\tu32 vertb_even = (VC4_SET_FIELD(0, VC4_HDMI_VERTB_VSPO) |\n\t\t\t  VC4_SET_FIELD(mode->crtc_vtotal -\n\t\t\t\t\tmode->crtc_vsync_end,\n\t\t\t\t\tVC4_HDMI_VERTB_VBP));\n\tunsigned long flags;\n\tu32 reg;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_HORZA,\n\t\t   (vsync_pos ? VC4_HDMI_HORZA_VPOS : 0) |\n\t\t   (hsync_pos ? VC4_HDMI_HORZA_HPOS : 0) |\n\t\t   VC4_SET_FIELD(mode->hdisplay * pixel_rep,\n\t\t\t\t VC4_HDMI_HORZA_HAP));\n\n\tHDMI_WRITE(HDMI_HORZB,\n\t\t   VC4_SET_FIELD((mode->htotal -\n\t\t\t\t  mode->hsync_end) * pixel_rep,\n\t\t\t\t VC4_HDMI_HORZB_HBP) |\n\t\t   VC4_SET_FIELD((mode->hsync_end -\n\t\t\t\t  mode->hsync_start) * pixel_rep,\n\t\t\t\t VC4_HDMI_HORZB_HSP) |\n\t\t   VC4_SET_FIELD((mode->hsync_start -\n\t\t\t\t  mode->hdisplay) * pixel_rep,\n\t\t\t\t VC4_HDMI_HORZB_HFP));\n\n\tHDMI_WRITE(HDMI_VERTA0, verta);\n\tHDMI_WRITE(HDMI_VERTA1, verta);\n\n\tHDMI_WRITE(HDMI_VERTB0, vertb_even);\n\tHDMI_WRITE(HDMI_VERTB1, vertb);\n\n\treg = HDMI_READ(HDMI_MISC_CONTROL);\n\treg &= ~VC4_HDMI_MISC_CONTROL_PIXEL_REP_MASK;\n\treg |= VC4_SET_FIELD(pixel_rep - 1, VC4_HDMI_MISC_CONTROL_PIXEL_REP);\n\tHDMI_WRITE(HDMI_MISC_CONTROL, reg);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc5_hdmi_set_timings(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t struct drm_connector_state *state,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tconst struct vc4_hdmi_connector_state *vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(state);\n\tbool hsync_pos = mode->flags & DRM_MODE_FLAG_PHSYNC;\n\tbool vsync_pos = mode->flags & DRM_MODE_FLAG_PVSYNC;\n\tbool interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\tu32 pixel_rep = (mode->flags & DRM_MODE_FLAG_DBLCLK) ? 2 : 1;\n\tu32 verta = (VC4_SET_FIELD(mode->crtc_vsync_end - mode->crtc_vsync_start,\n\t\t\t\t   VC5_HDMI_VERTA_VSP) |\n\t\t     VC4_SET_FIELD(mode->crtc_vsync_start - mode->crtc_vdisplay,\n\t\t\t\t   VC5_HDMI_VERTA_VFP) |\n\t\t     VC4_SET_FIELD(mode->crtc_vdisplay, VC5_HDMI_VERTA_VAL));\n\tu32 vertb = (VC4_SET_FIELD(mode->htotal >> (2 - pixel_rep),\n\t\t\t\t   VC5_HDMI_VERTB_VSPO) |\n\t\t     VC4_SET_FIELD(mode->crtc_vtotal - mode->crtc_vsync_end +\n\t\t\t\t   interlaced,\n\t\t\t\t   VC4_HDMI_VERTB_VBP));\n\tu32 vertb_even = (VC4_SET_FIELD(0, VC5_HDMI_VERTB_VSPO) |\n\t\t\t  VC4_SET_FIELD(mode->crtc_vtotal -\n\t\t\t\t\tmode->crtc_vsync_end,\n\t\t\t\t\tVC4_HDMI_VERTB_VBP));\n\tunsigned long flags;\n\tunsigned char gcp;\n\tu32 reg;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_HORZA,\n\t\t   (vsync_pos ? VC5_HDMI_HORZA_VPOS : 0) |\n\t\t   (hsync_pos ? VC5_HDMI_HORZA_HPOS : 0) |\n\t\t   VC4_SET_FIELD(mode->hdisplay * pixel_rep,\n\t\t\t\t VC5_HDMI_HORZA_HAP) |\n\t\t   VC4_SET_FIELD((mode->hsync_start -\n\t\t\t\t  mode->hdisplay) * pixel_rep,\n\t\t\t\t VC5_HDMI_HORZA_HFP));\n\n\tHDMI_WRITE(HDMI_HORZB,\n\t\t   VC4_SET_FIELD((mode->htotal -\n\t\t\t\t  mode->hsync_end) * pixel_rep,\n\t\t\t\t VC5_HDMI_HORZB_HBP) |\n\t\t   VC4_SET_FIELD((mode->hsync_end -\n\t\t\t\t  mode->hsync_start) * pixel_rep,\n\t\t\t\t VC5_HDMI_HORZB_HSP));\n\n\tHDMI_WRITE(HDMI_VERTA0, verta);\n\tHDMI_WRITE(HDMI_VERTA1, verta);\n\n\tHDMI_WRITE(HDMI_VERTB0, vertb_even);\n\tHDMI_WRITE(HDMI_VERTB1, vertb);\n\n\tswitch (vc4_state->output_bpc) {\n\tcase 12:\n\t\tgcp = 6;\n\t\tbreak;\n\tcase 10:\n\t\tgcp = 5;\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\tgcp = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (vc4_state->output_format == VC4_HDMI_OUTPUT_YUV422) {\n\t\tgcp = 0;\n\t}\n\n\treg = HDMI_READ(HDMI_DEEP_COLOR_CONFIG_1);\n\treg &= ~(VC5_HDMI_DEEP_COLOR_CONFIG_1_INIT_PACK_PHASE_MASK |\n\t\t VC5_HDMI_DEEP_COLOR_CONFIG_1_COLOR_DEPTH_MASK);\n\treg |= VC4_SET_FIELD(2, VC5_HDMI_DEEP_COLOR_CONFIG_1_INIT_PACK_PHASE) |\n\t       VC4_SET_FIELD(gcp, VC5_HDMI_DEEP_COLOR_CONFIG_1_COLOR_DEPTH);\n\tHDMI_WRITE(HDMI_DEEP_COLOR_CONFIG_1, reg);\n\n\treg = HDMI_READ(HDMI_GCP_WORD_1);\n\treg &= ~VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_1_MASK;\n\treg |= VC4_SET_FIELD(gcp, VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_1);\n\treg &= ~VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_0_MASK;\n\treg |= VC5_HDMI_GCP_WORD_1_GCP_SUBPACKET_BYTE_0_CLEAR_AVMUTE;\n\tHDMI_WRITE(HDMI_GCP_WORD_1, reg);\n\n\treg = HDMI_READ(HDMI_GCP_CONFIG);\n\treg |= VC5_HDMI_GCP_CONFIG_GCP_ENABLE;\n\tHDMI_WRITE(HDMI_GCP_CONFIG, reg);\n\n\treg = HDMI_READ(HDMI_MISC_CONTROL);\n\treg &= ~VC5_HDMI_MISC_CONTROL_PIXEL_REP_MASK;\n\treg |= VC4_SET_FIELD(pixel_rep - 1, VC5_HDMI_MISC_CONTROL_PIXEL_REP);\n\tHDMI_WRITE(HDMI_MISC_CONTROL, reg);\n\n\tHDMI_WRITE(HDMI_CLOCK_STOP, 0);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_recenter_fifo(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tu32 drift;\n\tint ret;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tdrift = HDMI_READ(HDMI_FIFO_CTL);\n\tdrift &= VC4_HDMI_FIFO_VALID_WRITE_MASK;\n\n\tHDMI_WRITE(HDMI_FIFO_CTL,\n\t\t   drift & ~VC4_HDMI_FIFO_CTL_RECENTER);\n\tHDMI_WRITE(HDMI_FIFO_CTL,\n\t\t   drift | VC4_HDMI_FIFO_CTL_RECENTER);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tusleep_range(1000, 1100);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_FIFO_CTL,\n\t\t   drift & ~VC4_HDMI_FIFO_CTL_RECENTER);\n\tHDMI_WRITE(HDMI_FIFO_CTL,\n\t\t   drift | VC4_HDMI_FIFO_CTL_RECENTER);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tret = wait_for(HDMI_READ(HDMI_FIFO_CTL) &\n\t\t       VC4_HDMI_FIFO_CTL_RECENTER_DONE, 1);\n\tWARN_ONCE(ret, \"Timeout waiting for \"\n\t\t  \"VC4_HDMI_FIFO_CTL_RECENTER_DONE\");\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_encoder_pre_crtc_configure(struct drm_encoder *encoder,\n\t\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_connector_state *conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tstruct vc4_hdmi_connector_state *vc4_conn_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(conn_state);\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tunsigned long tmds_char_rate = vc4_conn_state->tmds_char_rate;\n\tunsigned long bvb_rate, hsm_rate;\n\tunsigned long flags;\n\tint ret;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(&vc4_hdmi->pdev->dev);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to retain power domain: %d\\n\", ret);\n\t\tgoto err_dev_exit;\n\t}\n\n\t \n\thsm_rate = max_t(unsigned long,\n\t\t\t HSM_MIN_CLOCK_FREQ,\n\t\t\t (tmds_char_rate / 100) * 101);\n\tret = clk_set_min_rate(vc4_hdmi->hsm_clock, hsm_rate);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to set HSM clock rate: %d\\n\", ret);\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\tret = clk_set_rate(vc4_hdmi->pixel_clock, tmds_char_rate);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to set pixel clock rate: %d\\n\", ret);\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\tret = clk_prepare_enable(vc4_hdmi->pixel_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on pixel clock: %d\\n\", ret);\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\n\tvc4_hdmi_cec_update_clk_div(vc4_hdmi);\n\n\tif (tmds_char_rate > 297000000)\n\t\tbvb_rate = 300000000;\n\telse if (tmds_char_rate > 148500000)\n\t\tbvb_rate = 150000000;\n\telse\n\t\tbvb_rate = 75000000;\n\n\tret = clk_set_min_rate(vc4_hdmi->pixel_bvb_clock, bvb_rate);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to set pixel bvb clock rate: %d\\n\", ret);\n\t\tgoto err_disable_pixel_clock;\n\t}\n\n\tret = clk_prepare_enable(vc4_hdmi->pixel_bvb_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on pixel bvb clock: %d\\n\", ret);\n\t\tgoto err_disable_pixel_clock;\n\t}\n\n\tif (vc4_hdmi->variant->phy_init)\n\t\tvc4_hdmi->variant->phy_init(vc4_hdmi, vc4_conn_state);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_SCHEDULER_CONTROL,\n\t\t   HDMI_READ(HDMI_SCHEDULER_CONTROL) |\n\t\t   VC4_HDMI_SCHEDULER_CONTROL_MANUAL_FORMAT |\n\t\t   VC4_HDMI_SCHEDULER_CONTROL_IGNORE_VSYNC_PREDICTS);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (vc4_hdmi->variant->set_timings)\n\t\tvc4_hdmi->variant->set_timings(vc4_hdmi, conn_state, mode);\n\n\tdrm_dev_exit(idx);\n\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\treturn;\n\nerr_disable_pixel_clock:\n\tclk_disable_unprepare(vc4_hdmi->pixel_clock);\nerr_put_runtime_pm:\n\tpm_runtime_put(&vc4_hdmi->pdev->dev);\nerr_dev_exit:\n\tdrm_dev_exit(idx);\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n\treturn;\n}\n\nstatic void vc4_hdmi_encoder_pre_crtc_enable(struct drm_encoder *encoder,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tstruct drm_connector_state *conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tunsigned long flags;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tif (vc4_hdmi->variant->csc_setup)\n\t\tvc4_hdmi->variant->csc_setup(vc4_hdmi, conn_state, mode);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_FIFO_CTL, VC4_HDMI_FIFO_CTL_MASTER_SLAVE_N);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic void vc4_hdmi_encoder_post_crtc_enable(struct drm_encoder *encoder,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tstruct drm_display_info *display = &vc4_hdmi->connector.display_info;\n\tbool hsync_pos = mode->flags & DRM_MODE_FLAG_PHSYNC;\n\tbool vsync_pos = mode->flags & DRM_MODE_FLAG_PVSYNC;\n\tunsigned long flags;\n\tint ret;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_VID_CTL,\n\t\t   VC4_HD_VID_CTL_ENABLE |\n\t\t   VC4_HD_VID_CTL_CLRRGB |\n\t\t   VC4_HD_VID_CTL_UNDERFLOW_ENABLE |\n\t\t   VC4_HD_VID_CTL_FRAME_COUNTER_RESET |\n\t\t   (vsync_pos ? 0 : VC4_HD_VID_CTL_VSYNC_LOW) |\n\t\t   (hsync_pos ? 0 : VC4_HD_VID_CTL_HSYNC_LOW));\n\n\tHDMI_WRITE(HDMI_VID_CTL,\n\t\t   HDMI_READ(HDMI_VID_CTL) & ~VC4_HD_VID_CTL_BLANKPIX);\n\n\tif (display->is_hdmi) {\n\t\tHDMI_WRITE(HDMI_SCHEDULER_CONTROL,\n\t\t\t   HDMI_READ(HDMI_SCHEDULER_CONTROL) |\n\t\t\t   VC4_HDMI_SCHEDULER_CONTROL_MODE_HDMI);\n\n\t\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\t\tret = wait_for(HDMI_READ(HDMI_SCHEDULER_CONTROL) &\n\t\t\t       VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE, 1000);\n\t\tWARN_ONCE(ret, \"Timeout waiting for \"\n\t\t\t  \"VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE\\n\");\n\t} else {\n\t\tHDMI_WRITE(HDMI_RAM_PACKET_CONFIG,\n\t\t\t   HDMI_READ(HDMI_RAM_PACKET_CONFIG) &\n\t\t\t   ~(VC4_HDMI_RAM_PACKET_ENABLE));\n\t\tHDMI_WRITE(HDMI_SCHEDULER_CONTROL,\n\t\t\t   HDMI_READ(HDMI_SCHEDULER_CONTROL) &\n\t\t\t   ~VC4_HDMI_SCHEDULER_CONTROL_MODE_HDMI);\n\n\t\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\t\tret = wait_for(!(HDMI_READ(HDMI_SCHEDULER_CONTROL) &\n\t\t\t\t VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE), 1000);\n\t\tWARN_ONCE(ret, \"Timeout waiting for \"\n\t\t\t  \"!VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE\\n\");\n\t}\n\n\tif (display->is_hdmi) {\n\t\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\t\tWARN_ON(!(HDMI_READ(HDMI_SCHEDULER_CONTROL) &\n\t\t\t  VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE));\n\n\t\tHDMI_WRITE(HDMI_RAM_PACKET_CONFIG,\n\t\t\t   VC4_HDMI_RAM_PACKET_ENABLE);\n\n\t\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\t\tvc4_hdmi->packet_ram_enabled = true;\n\n\t\tvc4_hdmi_set_infoframes(encoder);\n\t}\n\n\tvc4_hdmi_recenter_fifo(vc4_hdmi);\n\tvc4_hdmi_enable_scrambling(encoder);\n\n\tdrm_dev_exit(idx);\n\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic void vc4_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct vc4_hdmi_connector_state *vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(conn_state);\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\tdrm_mode_copy(&vc4_hdmi->saved_adjusted_mode,\n\t\t      &crtc_state->adjusted_mode);\n\tvc4_hdmi->output_bpc = vc4_state->output_bpc;\n\tvc4_hdmi->output_format = vc4_state->output_format;\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic bool\nvc4_hdmi_sink_supports_format_bpc(const struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t  const struct drm_display_info *info,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  unsigned int format, unsigned int bpc)\n{\n\tstruct drm_device *dev = vc4_hdmi->connector.dev;\n\tu8 vic = drm_match_cea_mode(mode);\n\n\tif (vic == 1 && bpc != 8) {\n\t\tdrm_dbg(dev, \"VIC1 requires a bpc of 8, got %u\\n\", bpc);\n\t\treturn false;\n\t}\n\n\tif (!info->is_hdmi &&\n\t    (format != VC4_HDMI_OUTPUT_RGB || bpc != 8)) {\n\t\tdrm_dbg(dev, \"DVI Monitors require an RGB output at 8 bpc\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (format) {\n\tcase VC4_HDMI_OUTPUT_RGB:\n\t\tdrm_dbg(dev, \"RGB Format, checking the constraints.\\n\");\n\n\t\tif (!(info->color_formats & DRM_COLOR_FORMAT_RGB444))\n\t\t\treturn false;\n\n\t\tif (bpc == 10 && !(info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30)) {\n\t\t\tdrm_dbg(dev, \"10 BPC but sink doesn't support Deep Color 30.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bpc == 12 && !(info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_36)) {\n\t\t\tdrm_dbg(dev, \"12 BPC but sink doesn't support Deep Color 36.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdrm_dbg(dev, \"RGB format supported in that configuration.\\n\");\n\n\t\treturn true;\n\n\tcase VC4_HDMI_OUTPUT_YUV422:\n\t\tdrm_dbg(dev, \"YUV422 format, checking the constraints.\\n\");\n\n\t\tif (!(info->color_formats & DRM_COLOR_FORMAT_YCBCR422)) {\n\t\t\tdrm_dbg(dev, \"Sink doesn't support YUV422.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bpc != 12) {\n\t\t\tdrm_dbg(dev, \"YUV422 only supports 12 bpc.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdrm_dbg(dev, \"YUV422 format supported in that configuration.\\n\");\n\n\t\treturn true;\n\n\tcase VC4_HDMI_OUTPUT_YUV444:\n\t\tdrm_dbg(dev, \"YUV444 format, checking the constraints.\\n\");\n\n\t\tif (!(info->color_formats & DRM_COLOR_FORMAT_YCBCR444)) {\n\t\t\tdrm_dbg(dev, \"Sink doesn't support YUV444.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bpc == 10 && !(info->edid_hdmi_ycbcr444_dc_modes & DRM_EDID_HDMI_DC_30)) {\n\t\t\tdrm_dbg(dev, \"10 BPC but sink doesn't support Deep Color 30.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bpc == 12 && !(info->edid_hdmi_ycbcr444_dc_modes & DRM_EDID_HDMI_DC_36)) {\n\t\t\tdrm_dbg(dev, \"12 BPC but sink doesn't support Deep Color 36.\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdrm_dbg(dev, \"YUV444 format supported in that configuration.\\n\");\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic enum drm_mode_status\nvc4_hdmi_encoder_clock_valid(const struct vc4_hdmi *vc4_hdmi,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     unsigned long long clock)\n{\n\tconst struct drm_connector *connector = &vc4_hdmi->connector;\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct vc4_dev *vc4 = to_vc4_dev(connector->dev);\n\n\tif (clock > vc4_hdmi->variant->max_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (!vc4->hvs->vc5_hdmi_enable_hdmi_20 && clock > HDMI_14_MAX_TMDS_CLK)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\tif (!vc4->hvs->vc5_hdmi_enable_4096by2160 &&\n\t    mode->hdisplay > 3840 && mode->vdisplay >= 2160 &&\n\t    drm_mode_vrefresh(mode) >= 50)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (info->max_tmds_clock && clock > (info->max_tmds_clock * 1000))\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic unsigned long long\nvc4_hdmi_encoder_compute_mode_clock(const struct drm_display_mode *mode,\n\t\t\t\t    unsigned int bpc,\n\t\t\t\t    enum vc4_hdmi_output_format fmt)\n{\n\tunsigned long long clock = mode->clock * 1000ULL;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tclock = clock * 2;\n\n\tif (fmt == VC4_HDMI_OUTPUT_YUV422)\n\t\tbpc = 8;\n\n\tclock = clock * bpc;\n\tdo_div(clock, 8);\n\n\treturn clock;\n}\n\nstatic int\nvc4_hdmi_encoder_compute_clock(const struct vc4_hdmi *vc4_hdmi,\n\t\t\t       struct vc4_hdmi_connector_state *vc4_state,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       unsigned int bpc, unsigned int fmt)\n{\n\tunsigned long long clock;\n\n\tclock = vc4_hdmi_encoder_compute_mode_clock(mode, bpc, fmt);\n\tif (vc4_hdmi_encoder_clock_valid(vc4_hdmi, mode, clock) != MODE_OK)\n\t\treturn -EINVAL;\n\n\tvc4_state->tmds_char_rate = clock;\n\n\treturn 0;\n}\n\nstatic int\nvc4_hdmi_encoder_compute_format(const struct vc4_hdmi *vc4_hdmi,\n\t\t\t\tstruct vc4_hdmi_connector_state *vc4_state,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tunsigned int bpc)\n{\n\tstruct drm_device *dev = vc4_hdmi->connector.dev;\n\tconst struct drm_connector *connector = &vc4_hdmi->connector;\n\tconst struct drm_display_info *info = &connector->display_info;\n\tunsigned int format;\n\n\tdrm_dbg(dev, \"Trying with an RGB output\\n\");\n\n\tformat = VC4_HDMI_OUTPUT_RGB;\n\tif (vc4_hdmi_sink_supports_format_bpc(vc4_hdmi, info, mode, format, bpc)) {\n\t\tint ret;\n\n\t\tret = vc4_hdmi_encoder_compute_clock(vc4_hdmi, vc4_state,\n\t\t\t\t\t\t     mode, bpc, format);\n\t\tif (!ret) {\n\t\t\tvc4_state->output_format = format;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdrm_dbg(dev, \"Failed, Trying with an YUV422 output\\n\");\n\n\tformat = VC4_HDMI_OUTPUT_YUV422;\n\tif (vc4_hdmi_sink_supports_format_bpc(vc4_hdmi, info, mode, format, bpc)) {\n\t\tint ret;\n\n\t\tret = vc4_hdmi_encoder_compute_clock(vc4_hdmi, vc4_state,\n\t\t\t\t\t\t     mode, bpc, format);\n\t\tif (!ret) {\n\t\t\tvc4_state->output_format = format;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdrm_dbg(dev, \"Failed. No Format Supported for that bpc count.\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int\nvc4_hdmi_encoder_compute_config(const struct vc4_hdmi *vc4_hdmi,\n\t\t\t\tstruct vc4_hdmi_connector_state *vc4_state,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = vc4_hdmi->connector.dev;\n\tstruct drm_connector_state *conn_state = &vc4_state->base;\n\tunsigned int max_bpc = clamp_t(unsigned int, conn_state->max_bpc, 8, 12);\n\tunsigned int bpc;\n\tint ret;\n\n\tfor (bpc = max_bpc; bpc >= 8; bpc -= 2) {\n\t\tdrm_dbg(dev, \"Trying with a %d bpc output\\n\", bpc);\n\n\t\tret = vc4_hdmi_encoder_compute_format(vc4_hdmi, vc4_state,\n\t\t\t\t\t\t      mode, bpc);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tvc4_state->output_bpc = bpc;\n\n\t\tdrm_dbg(dev,\n\t\t\t\"Mode %ux%u @ %uHz: Found configuration: bpc: %u, fmt: %s, clock: %llu\\n\",\n\t\t\tmode->hdisplay, mode->vdisplay, drm_mode_vrefresh(mode),\n\t\t\tvc4_state->output_bpc,\n\t\t\tvc4_hdmi_output_fmt_str(vc4_state->output_format),\n\t\t\tvc4_state->tmds_char_rate);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define WIFI_2_4GHz_CH1_MIN_FREQ\t2400000000ULL\n#define WIFI_2_4GHz_CH1_MAX_FREQ\t2422000000ULL\n\nstatic int vc4_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(conn_state->state, connector);\n\tstruct vc4_hdmi_connector_state *old_vc4_state =\n\t\tconn_state_to_vc4_hdmi_conn_state(old_conn_state);\n\tstruct vc4_hdmi_connector_state *vc4_state = conn_state_to_vc4_hdmi_conn_state(conn_state);\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tunsigned long long tmds_char_rate = mode->clock * 1000;\n\tunsigned long long tmds_bit_rate;\n\tint ret;\n\n\tif (vc4_hdmi->variant->unsupported_odd_h_timings) {\n\t\tif (mode->flags & DRM_MODE_FLAG_DBLCLK) {\n\t\t\t \n\t\t\tif ((mode->hsync_start - mode->hdisplay) & 1)\n\t\t\t\tmode->hsync_start--;\n\t\t\tif ((mode->hsync_end - mode->hsync_start) & 1)\n\t\t\t\tmode->hsync_end--;\n\t\t}\n\n\t\t \n\t\tif ((mode->hdisplay % 2) || (mode->hsync_start % 2) ||\n\t\t    (mode->hsync_end % 2) || (mode->htotal % 2))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmds_bit_rate = tmds_char_rate * 10;\n\tif (vc4_hdmi->disable_wifi_frequencies &&\n\t    (tmds_bit_rate >= WIFI_2_4GHz_CH1_MIN_FREQ &&\n\t     tmds_bit_rate <= WIFI_2_4GHz_CH1_MAX_FREQ)) {\n\t\tmode->clock = 238560;\n\t\ttmds_char_rate = mode->clock * 1000;\n\t}\n\n\tret = vc4_hdmi_encoder_compute_config(vc4_hdmi, vc4_state, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (vc4_state->output_bpc != old_vc4_state->output_bpc ||\n\t    vc4_state->output_format != old_vc4_state->output_format)\n\t\tcrtc_state->mode_changed = true;\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\nvc4_hdmi_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\n\tif (vc4_hdmi->variant->unsupported_odd_h_timings &&\n\t    !(mode->flags & DRM_MODE_FLAG_DBLCLK) &&\n\t    ((mode->hdisplay % 2) || (mode->hsync_start % 2) ||\n\t     (mode->hsync_end % 2) || (mode->htotal % 2)))\n\t\treturn MODE_H_ILLEGAL;\n\n\treturn vc4_hdmi_encoder_clock_valid(vc4_hdmi, mode, mode->clock * 1000);\n}\n\nstatic const struct drm_encoder_helper_funcs vc4_hdmi_encoder_helper_funcs = {\n\t.atomic_check = vc4_hdmi_encoder_atomic_check,\n\t.atomic_mode_set = vc4_hdmi_encoder_atomic_mode_set,\n\t.mode_valid = vc4_hdmi_encoder_mode_valid,\n};\n\nstatic int vc4_hdmi_late_register(struct drm_encoder *encoder)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);\n\tconst struct vc4_hdmi_variant *variant = vc4_hdmi->variant;\n\n\tdrm_debugfs_add_file(drm, variant->debugfs_name,\n\t\t\t     vc4_hdmi_debugfs_regs, vc4_hdmi);\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs vc4_hdmi_encoder_funcs = {\n\t.late_register = vc4_hdmi_late_register,\n};\n\nstatic u32 vc4_hdmi_channel_map(struct vc4_hdmi *vc4_hdmi, u32 channel_mask)\n{\n\tint i;\n\tu32 channel_map = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (channel_mask & BIT(i))\n\t\t\tchannel_map |= i << (3 * i);\n\t}\n\treturn channel_map;\n}\n\nstatic u32 vc5_hdmi_channel_map(struct vc4_hdmi *vc4_hdmi, u32 channel_mask)\n{\n\tint i;\n\tu32 channel_map = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (channel_mask & BIT(i))\n\t\t\tchannel_map |= i << (4 * i);\n\t}\n\treturn channel_map;\n}\n\nstatic bool vc5_hdmi_hp_detect(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tu32 hotplug;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn false;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\thotplug = HDMI_READ(HDMI_HOTPLUG);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n\n\treturn !!(hotplug & VC4_HDMI_HOTPLUG_CONNECTED);\n}\n\n \nstatic void vc4_hdmi_audio_set_mai_clock(struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t\t unsigned int samplerate)\n{\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tu32 hsm_clock;\n\tunsigned long flags;\n\tunsigned long n, m;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\thsm_clock = clk_get_rate(vc4_hdmi->audio_clock);\n\trational_best_approximation(hsm_clock, samplerate,\n\t\t\t\t    VC4_HD_MAI_SMP_N_MASK >>\n\t\t\t\t    VC4_HD_MAI_SMP_N_SHIFT,\n\t\t\t\t    (VC4_HD_MAI_SMP_M_MASK >>\n\t\t\t\t     VC4_HD_MAI_SMP_M_SHIFT) + 1,\n\t\t\t\t    &n, &m);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_MAI_SMP,\n\t\t   VC4_SET_FIELD(n, VC4_HD_MAI_SMP_N) |\n\t\t   VC4_SET_FIELD(m - 1, VC4_HD_MAI_SMP_M));\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hdmi_set_n_cts(struct vc4_hdmi *vc4_hdmi, unsigned int samplerate)\n{\n\tconst struct drm_display_mode *mode = &vc4_hdmi->saved_adjusted_mode;\n\tu32 n, cts;\n\tu64 tmp;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\tn = 128 * samplerate / 1000;\n\ttmp = (u64)(mode->clock * 1000) * n;\n\tdo_div(tmp, 128 * samplerate);\n\tcts = tmp;\n\n\tHDMI_WRITE(HDMI_CRP_CFG,\n\t\t   VC4_HDMI_CRP_CFG_EXTERNAL_CTS_EN |\n\t\t   VC4_SET_FIELD(n, VC4_HDMI_CRP_CFG_N));\n\n\t \n\tHDMI_WRITE(HDMI_CTS_0, cts);\n\tHDMI_WRITE(HDMI_CTS_1, cts);\n}\n\nstatic inline struct vc4_hdmi *dai_to_hdmi(struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);\n\n\treturn snd_soc_card_get_drvdata(card);\n}\n\nstatic bool vc4_hdmi_audio_can_stream(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_display_info *display = &vc4_hdmi->connector.display_info;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\t \n\tif (!display->is_hdmi)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int vc4_hdmi_audio_startup(struct device *dev, void *data)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint ret = 0;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!vc4_hdmi_audio_can_stream(vc4_hdmi)) {\n\t\tret = -ENODEV;\n\t\tgoto out_dev_exit;\n\t}\n\n\tvc4_hdmi->audio.streaming = true;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_MAI_CTL,\n\t\t   VC4_HD_MAI_CTL_RESET |\n\t\t   VC4_HD_MAI_CTL_FLUSH |\n\t\t   VC4_HD_MAI_CTL_DLATE |\n\t\t   VC4_HD_MAI_CTL_ERRORE |\n\t\t   VC4_HD_MAI_CTL_ERRORF);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (vc4_hdmi->variant->phy_rng_enable)\n\t\tvc4_hdmi->variant->phy_rng_enable(vc4_hdmi);\n\nout_dev_exit:\n\tdrm_dev_exit(idx);\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\treturn ret;\n}\n\nstatic void vc4_hdmi_audio_reset(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_encoder *encoder = &vc4_hdmi->encoder.base;\n\tstruct device *dev = &vc4_hdmi->pdev->dev;\n\tunsigned long flags;\n\tint ret;\n\n\tlockdep_assert_held(&vc4_hdmi->mutex);\n\n\tvc4_hdmi->audio.streaming = false;\n\tret = vc4_hdmi_stop_packet(encoder, HDMI_INFOFRAME_TYPE_AUDIO, false);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to stop audio infoframe: %d\\n\", ret);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_MAI_CTL, VC4_HD_MAI_CTL_RESET);\n\tHDMI_WRITE(HDMI_MAI_CTL, VC4_HD_MAI_CTL_ERRORF);\n\tHDMI_WRITE(HDMI_MAI_CTL, VC4_HD_MAI_CTL_FLUSH);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n}\n\nstatic void vc4_hdmi_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tHDMI_WRITE(HDMI_MAI_CTL,\n\t\t   VC4_HD_MAI_CTL_DLATE |\n\t\t   VC4_HD_MAI_CTL_ERRORE |\n\t\t   VC4_HD_MAI_CTL_ERRORF);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tif (vc4_hdmi->variant->phy_rng_disable)\n\t\tvc4_hdmi->variant->phy_rng_disable(vc4_hdmi);\n\n\tvc4_hdmi->audio.streaming = false;\n\tvc4_hdmi_audio_reset(vc4_hdmi);\n\n\tdrm_dev_exit(idx);\n\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n}\n\nstatic int sample_rate_to_mai_fmt(int samplerate)\n{\n\tswitch (samplerate) {\n\tcase 8000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_8000;\n\tcase 11025:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_11025;\n\tcase 12000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_12000;\n\tcase 16000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_16000;\n\tcase 22050:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_22050;\n\tcase 24000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_24000;\n\tcase 32000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_32000;\n\tcase 44100:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_44100;\n\tcase 48000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_48000;\n\tcase 64000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_64000;\n\tcase 88200:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_88200;\n\tcase 96000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_96000;\n\tcase 128000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_128000;\n\tcase 176400:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_176400;\n\tcase 192000:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_192000;\n\tdefault:\n\t\treturn VC4_HDMI_MAI_SAMPLE_RATE_NOT_INDICATED;\n\t}\n}\n\n \nstatic int vc4_hdmi_audio_prepare(struct device *dev, void *data,\n\t\t\t\t  struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t  struct hdmi_codec_params *params)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tstruct drm_encoder *encoder = &vc4_hdmi->encoder.base;\n\tunsigned int sample_rate = params->sample_rate;\n\tunsigned int channels = params->channels;\n\tunsigned long flags;\n\tu32 audio_packet_config, channel_mask;\n\tu32 channel_map;\n\tu32 mai_audio_format;\n\tu32 mai_sample_rate;\n\tint ret = 0;\n\tint idx;\n\n\tdev_dbg(dev, \"%s: %u Hz, %d bit, %d channels\\n\", __func__,\n\t\tsample_rate, params->sample_width, channels);\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tif (!drm_dev_enter(drm, &idx)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!vc4_hdmi_audio_can_stream(vc4_hdmi)) {\n\t\tret = -EINVAL;\n\t\tgoto out_dev_exit;\n\t}\n\n\tvc4_hdmi_audio_set_mai_clock(vc4_hdmi, sample_rate);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_MAI_CTL,\n\t\t   VC4_SET_FIELD(channels, VC4_HD_MAI_CTL_CHNUM) |\n\t\t   VC4_HD_MAI_CTL_WHOLSMP |\n\t\t   VC4_HD_MAI_CTL_CHALIGN |\n\t\t   VC4_HD_MAI_CTL_ENABLE);\n\n\tmai_sample_rate = sample_rate_to_mai_fmt(sample_rate);\n\tif (params->iec.status[0] & IEC958_AES0_NONAUDIO &&\n\t    params->channels == 8)\n\t\tmai_audio_format = VC4_HDMI_MAI_FORMAT_HBR;\n\telse\n\t\tmai_audio_format = VC4_HDMI_MAI_FORMAT_PCM;\n\tHDMI_WRITE(HDMI_MAI_FMT,\n\t\t   VC4_SET_FIELD(mai_sample_rate,\n\t\t\t\t VC4_HDMI_MAI_FORMAT_SAMPLE_RATE) |\n\t\t   VC4_SET_FIELD(mai_audio_format,\n\t\t\t\t VC4_HDMI_MAI_FORMAT_AUDIO_FORMAT));\n\n\t \n\taudio_packet_config =\n\t\tVC4_HDMI_AUDIO_PACKET_ZERO_DATA_ON_SAMPLE_FLAT |\n\t\tVC4_HDMI_AUDIO_PACKET_ZERO_DATA_ON_INACTIVE_CHANNELS |\n\t\tVC4_SET_FIELD(0x8, VC4_HDMI_AUDIO_PACKET_B_FRAME_IDENTIFIER);\n\n\tchannel_mask = GENMASK(channels - 1, 0);\n\taudio_packet_config |= VC4_SET_FIELD(channel_mask,\n\t\t\t\t\t     VC4_HDMI_AUDIO_PACKET_CEA_MASK);\n\n\t \n\tHDMI_WRITE(HDMI_MAI_THR,\n\t\t   VC4_SET_FIELD(0x08, VC4_HD_MAI_THR_PANICHIGH) |\n\t\t   VC4_SET_FIELD(0x08, VC4_HD_MAI_THR_PANICLOW) |\n\t\t   VC4_SET_FIELD(0x06, VC4_HD_MAI_THR_DREQHIGH) |\n\t\t   VC4_SET_FIELD(0x08, VC4_HD_MAI_THR_DREQLOW));\n\n\tHDMI_WRITE(HDMI_MAI_CONFIG,\n\t\t   VC4_HDMI_MAI_CONFIG_BIT_REVERSE |\n\t\t   VC4_HDMI_MAI_CONFIG_FORMAT_REVERSE |\n\t\t   VC4_SET_FIELD(channel_mask, VC4_HDMI_MAI_CHANNEL_MASK));\n\n\tchannel_map = vc4_hdmi->variant->channel_map(vc4_hdmi, channel_mask);\n\tHDMI_WRITE(HDMI_MAI_CHANNEL_MAP, channel_map);\n\tHDMI_WRITE(HDMI_AUDIO_PACKET_CONFIG, audio_packet_config);\n\n\tvc4_hdmi_set_n_cts(vc4_hdmi, sample_rate);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tmemcpy(&vc4_hdmi->audio.infoframe, &params->cea, sizeof(params->cea));\n\tvc4_hdmi_set_audio_infoframe(encoder);\n\nout_dev_exit:\n\tdrm_dev_exit(idx);\nout:\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver vc4_hdmi_audio_cpu_dai_comp = {\n\t.name = \"vc4-hdmi-cpu-dai-component\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic int vc4_hdmi_audio_cpu_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dai_to_hdmi(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &vc4_hdmi->audio.dma_data, NULL);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops vc4_snd_dai_ops = {\n\t.probe  = vc4_hdmi_audio_cpu_dai_probe,\n};\n\nstatic struct snd_soc_dai_driver vc4_hdmi_audio_cpu_dai_drv = {\n\t.name = \"vc4-hdmi-cpu-dai\",\n\t.ops = &vc4_snd_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\t SNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t},\n};\n\nstatic const struct snd_dmaengine_pcm_config pcm_conf = {\n\t.chan_names[SNDRV_PCM_STREAM_PLAYBACK] = \"audio-rx\",\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\nstatic int vc4_hdmi_audio_get_eld(struct device *dev, void *data,\n\t\t\t\t  uint8_t *buf, size_t len)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\tmemcpy(buf, connector->eld, min(sizeof(connector->eld), len));\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops vc4_hdmi_codec_ops = {\n\t.get_eld = vc4_hdmi_audio_get_eld,\n\t.prepare = vc4_hdmi_audio_prepare,\n\t.audio_shutdown = vc4_hdmi_audio_shutdown,\n\t.audio_startup = vc4_hdmi_audio_startup,\n};\n\nstatic struct hdmi_codec_pdata vc4_hdmi_codec_pdata = {\n\t.ops = &vc4_hdmi_codec_ops,\n\t.max_i2s_channels = 8,\n\t.i2s = 1,\n};\n\nstatic void vc4_hdmi_audio_codec_release(void *ptr)\n{\n\tstruct vc4_hdmi *vc4_hdmi = ptr;\n\n\tplatform_device_unregister(vc4_hdmi->audio.codec_pdev);\n\tvc4_hdmi->audio.codec_pdev = NULL;\n}\n\nstatic int vc4_hdmi_audio_init(struct vc4_hdmi *vc4_hdmi)\n{\n\tconst struct vc4_hdmi_register *mai_data =\n\t\t&vc4_hdmi->variant->registers[HDMI_MAI_DATA];\n\tstruct snd_soc_dai_link *dai_link = &vc4_hdmi->audio.link;\n\tstruct snd_soc_card *card = &vc4_hdmi->audio.card;\n\tstruct device *dev = &vc4_hdmi->pdev->dev;\n\tstruct platform_device *codec_pdev;\n\tconst __be32 *addr;\n\tint index, len;\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(offsetof(struct vc4_hdmi_audio, card) != 0);\n\tBUILD_BUG_ON(offsetof(struct vc4_hdmi, audio) != 0);\n\n\tif (!of_find_property(dev->of_node, \"dmas\", &len) || !len) {\n\t\tdev_warn(dev,\n\t\t\t \"'dmas' DT property is missing or empty, no HDMI audio\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mai_data->reg != VC4_HD) {\n\t\tWARN_ONCE(true, \"MAI isn't in the HD block\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tindex = of_property_match_string(dev->of_node, \"reg-names\", \"hd\");\n\t \n\tif (index < 0)\n\t\tindex = 1;\n\n\taddr = of_get_address(dev->of_node, index, NULL, NULL);\n\n\tvc4_hdmi->audio.dma_data.addr = be32_to_cpup(addr) + mai_data->offset;\n\tvc4_hdmi->audio.dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tvc4_hdmi->audio.dma_data.maxburst = 2;\n\n\t \n\tret = devm_snd_dmaengine_pcm_register(dev, &pcm_conf, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register PCM component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &vc4_hdmi_audio_cpu_dai_comp,\n\t\t\t\t\t      &vc4_hdmi_audio_cpu_dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register CPU DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcodec_pdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t   PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t   &vc4_hdmi_codec_pdata,\n\t\t\t\t\t\t   sizeof(vc4_hdmi_codec_pdata));\n\tif (IS_ERR(codec_pdev)) {\n\t\tdev_err(dev, \"Couldn't register the HDMI codec: %ld\\n\", PTR_ERR(codec_pdev));\n\t\treturn PTR_ERR(codec_pdev);\n\t}\n\tvc4_hdmi->audio.codec_pdev = codec_pdev;\n\n\tret = devm_add_action_or_reset(dev, vc4_hdmi_audio_codec_release, vc4_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\tdai_link->cpus\t\t= &vc4_hdmi->audio.cpu;\n\tdai_link->codecs\t= &vc4_hdmi->audio.codec;\n\tdai_link->platforms\t= &vc4_hdmi->audio.platform;\n\n\tdai_link->num_cpus\t= 1;\n\tdai_link->num_codecs\t= 1;\n\tdai_link->num_platforms\t= 1;\n\n\tdai_link->name = \"MAI\";\n\tdai_link->stream_name = \"MAI PCM\";\n\tdai_link->codecs->dai_name = \"i2s-hifi\";\n\tdai_link->cpus->dai_name = dev_name(dev);\n\tdai_link->codecs->name = dev_name(&codec_pdev->dev);\n\tdai_link->platforms->name = dev_name(dev);\n\n\tcard->dai_link = dai_link;\n\tcard->num_links = 1;\n\tcard->name = vc4_hdmi->variant->card_name;\n\tcard->driver_name = \"vc4-hdmi\";\n\tcard->dev = dev;\n\tcard->owner = THIS_MODULE;\n\n\t \n\tsnd_soc_card_set_drvdata(card, vc4_hdmi);\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret)\n\t\tdev_err_probe(dev, ret, \"Could not register sound card\\n\");\n\n\treturn ret;\n\n}\n\nstatic irqreturn_t vc4_hdmi_hpd_irq_thread(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct drm_device *dev = connector->dev;\n\n\tif (dev && dev->registered)\n\t\tdrm_connector_helper_hpd_irq_event(connector);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vc4_hdmi_hotplug_init(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct drm_connector *connector = &vc4_hdmi->connector;\n\tstruct platform_device *pdev = vc4_hdmi->pdev;\n\tint ret;\n\n\tif (vc4_hdmi->variant->external_irq_controller) {\n\t\tunsigned int hpd_con = platform_get_irq_byname(pdev, \"hpd-connected\");\n\t\tunsigned int hpd_rm = platform_get_irq_byname(pdev, \"hpd-removed\");\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, hpd_con,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tvc4_hdmi_hpd_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\t\"vc4 hdmi hpd connected\", vc4_hdmi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, hpd_rm,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tvc4_hdmi_hpd_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\t\"vc4 hdmi hpd disconnected\", vc4_hdmi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DRM_VC4_HDMI_CEC\nstatic irqreturn_t vc4_cec_irq_handler_rx_thread(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\n\tif (vc4_hdmi->cec_rx_msg.len)\n\t\tcec_received_msg(vc4_hdmi->cec_adap,\n\t\t\t\t &vc4_hdmi->cec_rx_msg);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_tx_thread(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\n\tif (vc4_hdmi->cec_tx_ok) {\n\t\tcec_transmit_done(vc4_hdmi->cec_adap, CEC_TX_STATUS_OK,\n\t\t\t\t  0, 0, 0, 0);\n\t} else {\n\t\t \n\t\tcec_transmit_done(vc4_hdmi->cec_adap, CEC_TX_STATUS_NACK,\n\t\t\t\t  0, 2, 0, 0);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_thread(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\tirqreturn_t ret;\n\n\tif (vc4_hdmi->cec_irq_was_rx)\n\t\tret = vc4_cec_irq_handler_rx_thread(irq, priv);\n\telse\n\t\tret = vc4_cec_irq_handler_tx_thread(irq, priv);\n\n\treturn ret;\n}\n\nstatic void vc4_cec_read_msg(struct vc4_hdmi *vc4_hdmi, u32 cntrl1)\n{\n\tstruct drm_device *dev = vc4_hdmi->connector.dev;\n\tstruct cec_msg *msg = &vc4_hdmi->cec_rx_msg;\n\tunsigned int i;\n\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\tmsg->len = 1 + ((cntrl1 & VC4_HDMI_CEC_REC_WRD_CNT_MASK) >>\n\t\t\t\t\tVC4_HDMI_CEC_REC_WRD_CNT_SHIFT);\n\n\tif (msg->len > 16) {\n\t\tdrm_err(dev, \"Attempting to read too much data (%d)\\n\", msg->len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < msg->len; i += 4) {\n\t\tu32 val = HDMI_READ(HDMI_CEC_RX_DATA_1 + (i >> 2));\n\n\t\tmsg->msg[i] = val & 0xff;\n\t\tmsg->msg[i + 1] = (val >> 8) & 0xff;\n\t\tmsg->msg[i + 2] = (val >> 16) & 0xff;\n\t\tmsg->msg[i + 3] = (val >> 24) & 0xff;\n\t}\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_tx_bare_locked(struct vc4_hdmi *vc4_hdmi)\n{\n\tu32 cntrl1;\n\n\t \n\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\tcntrl1 = HDMI_READ(HDMI_CEC_CNTRL_1);\n\tvc4_hdmi->cec_tx_ok = cntrl1 & VC4_HDMI_CEC_TX_STATUS_GOOD;\n\tcntrl1 &= ~VC4_HDMI_CEC_START_XMIT_BEGIN;\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, cntrl1);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_tx_bare(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\tirqreturn_t ret;\n\n\tspin_lock(&vc4_hdmi->hw_lock);\n\tret = vc4_cec_irq_handler_tx_bare_locked(vc4_hdmi);\n\tspin_unlock(&vc4_hdmi->hw_lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_rx_bare_locked(struct vc4_hdmi *vc4_hdmi)\n{\n\tu32 cntrl1;\n\n\tlockdep_assert_held(&vc4_hdmi->hw_lock);\n\n\t \n\n\tvc4_hdmi->cec_rx_msg.len = 0;\n\tcntrl1 = HDMI_READ(HDMI_CEC_CNTRL_1);\n\tvc4_cec_read_msg(vc4_hdmi, cntrl1);\n\tcntrl1 |= VC4_HDMI_CEC_CLEAR_RECEIVE_OFF;\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, cntrl1);\n\tcntrl1 &= ~VC4_HDMI_CEC_CLEAR_RECEIVE_OFF;\n\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, cntrl1);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler_rx_bare(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\tirqreturn_t ret;\n\n\tspin_lock(&vc4_hdmi->hw_lock);\n\tret = vc4_cec_irq_handler_rx_bare_locked(vc4_hdmi);\n\tspin_unlock(&vc4_hdmi->hw_lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t vc4_cec_irq_handler(int irq, void *priv)\n{\n\tstruct vc4_hdmi *vc4_hdmi = priv;\n\tu32 stat = HDMI_READ(HDMI_CEC_CPU_STATUS);\n\tirqreturn_t ret;\n\tu32 cntrl5;\n\n\t \n\n\tif (!(stat & VC4_HDMI_CPU_CEC))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&vc4_hdmi->hw_lock);\n\tcntrl5 = HDMI_READ(HDMI_CEC_CNTRL_5);\n\tvc4_hdmi->cec_irq_was_rx = cntrl5 & VC4_HDMI_CEC_RX_CEC_INT;\n\tif (vc4_hdmi->cec_irq_was_rx)\n\t\tret = vc4_cec_irq_handler_rx_bare_locked(vc4_hdmi);\n\telse\n\t\tret = vc4_cec_irq_handler_tx_bare_locked(vc4_hdmi);\n\n\tHDMI_WRITE(HDMI_CEC_CPU_CLEAR, VC4_HDMI_CPU_CEC);\n\tspin_unlock(&vc4_hdmi->hw_lock);\n\n\treturn ret;\n}\n\nstatic int vc4_hdmi_cec_enable(struct cec_adapter *adap)\n{\n\tstruct vc4_hdmi *vc4_hdmi = cec_get_drvdata(adap);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\t \n\tconst u32 usecs = 1000000 / CEC_CLOCK_FREQ;\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\t \n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(&vc4_hdmi->pdev->dev);\n\tif (ret) {\n\t\tdrm_dev_exit(idx);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tval = HDMI_READ(HDMI_CEC_CNTRL_5);\n\tval &= ~(VC4_HDMI_CEC_TX_SW_RESET | VC4_HDMI_CEC_RX_SW_RESET |\n\t\t VC4_HDMI_CEC_CNT_TO_4700_US_MASK |\n\t\t VC4_HDMI_CEC_CNT_TO_4500_US_MASK);\n\tval |= ((4700 / usecs) << VC4_HDMI_CEC_CNT_TO_4700_US_SHIFT) |\n\t       ((4500 / usecs) << VC4_HDMI_CEC_CNT_TO_4500_US_SHIFT);\n\n\tHDMI_WRITE(HDMI_CEC_CNTRL_5, val |\n\t\t   VC4_HDMI_CEC_TX_SW_RESET | VC4_HDMI_CEC_RX_SW_RESET);\n\tHDMI_WRITE(HDMI_CEC_CNTRL_5, val);\n\tHDMI_WRITE(HDMI_CEC_CNTRL_2,\n\t\t   ((1500 / usecs) << VC4_HDMI_CEC_CNT_TO_1500_US_SHIFT) |\n\t\t   ((1300 / usecs) << VC4_HDMI_CEC_CNT_TO_1300_US_SHIFT) |\n\t\t   ((800 / usecs) << VC4_HDMI_CEC_CNT_TO_800_US_SHIFT) |\n\t\t   ((600 / usecs) << VC4_HDMI_CEC_CNT_TO_600_US_SHIFT) |\n\t\t   ((400 / usecs) << VC4_HDMI_CEC_CNT_TO_400_US_SHIFT));\n\tHDMI_WRITE(HDMI_CEC_CNTRL_3,\n\t\t   ((2750 / usecs) << VC4_HDMI_CEC_CNT_TO_2750_US_SHIFT) |\n\t\t   ((2400 / usecs) << VC4_HDMI_CEC_CNT_TO_2400_US_SHIFT) |\n\t\t   ((2050 / usecs) << VC4_HDMI_CEC_CNT_TO_2050_US_SHIFT) |\n\t\t   ((1700 / usecs) << VC4_HDMI_CEC_CNT_TO_1700_US_SHIFT));\n\tHDMI_WRITE(HDMI_CEC_CNTRL_4,\n\t\t   ((4300 / usecs) << VC4_HDMI_CEC_CNT_TO_4300_US_SHIFT) |\n\t\t   ((3900 / usecs) << VC4_HDMI_CEC_CNT_TO_3900_US_SHIFT) |\n\t\t   ((3600 / usecs) << VC4_HDMI_CEC_CNT_TO_3600_US_SHIFT) |\n\t\t   ((3500 / usecs) << VC4_HDMI_CEC_CNT_TO_3500_US_SHIFT));\n\n\tif (!vc4_hdmi->variant->external_irq_controller)\n\t\tHDMI_WRITE(HDMI_CEC_CPU_MASK_CLEAR, VC4_HDMI_CPU_CEC);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tmutex_unlock(&vc4_hdmi->mutex);\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_cec_disable(struct cec_adapter *adap)\n{\n\tstruct vc4_hdmi *vc4_hdmi = cec_get_drvdata(adap);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\t \n\t\treturn 0;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tif (!vc4_hdmi->variant->external_irq_controller)\n\t\tHDMI_WRITE(HDMI_CEC_CPU_MASK_SET, VC4_HDMI_CPU_CEC);\n\n\tHDMI_WRITE(HDMI_CEC_CNTRL_5, HDMI_READ(HDMI_CEC_CNTRL_5) |\n\t\t   VC4_HDMI_CEC_TX_SW_RESET | VC4_HDMI_CEC_RX_SW_RESET);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\tpm_runtime_put(&vc4_hdmi->pdev->dev);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tif (enable)\n\t\treturn vc4_hdmi_cec_enable(adap);\n\telse\n\t\treturn vc4_hdmi_cec_disable(adap);\n}\n\nstatic int vc4_hdmi_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct vc4_hdmi *vc4_hdmi = cec_get_drvdata(adap);\n\tstruct drm_device *drm = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\t \n\t\treturn 0;\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1,\n\t\t   (HDMI_READ(HDMI_CEC_CNTRL_1) & ~VC4_HDMI_CEC_ADDR_MASK) |\n\t\t   (log_addr & 0xf) << VC4_HDMI_CEC_ADDR_SHIFT);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\tmutex_unlock(&vc4_hdmi->mutex);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t      u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct vc4_hdmi *vc4_hdmi = cec_get_drvdata(adap);\n\tstruct drm_device *dev = vc4_hdmi->connector.dev;\n\tunsigned long flags;\n\tu32 val;\n\tunsigned int i;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn -ENODEV;\n\n\tif (msg->len > 16) {\n\t\tdrm_err(dev, \"Attempting to transmit too much data (%d)\\n\", msg->len);\n\t\tdrm_dev_exit(idx);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&vc4_hdmi->mutex);\n\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\n\tfor (i = 0; i < msg->len; i += 4)\n\t\tHDMI_WRITE(HDMI_CEC_TX_DATA_1 + (i >> 2),\n\t\t\t   (msg->msg[i]) |\n\t\t\t   (msg->msg[i + 1] << 8) |\n\t\t\t   (msg->msg[i + 2] << 16) |\n\t\t\t   (msg->msg[i + 3] << 24));\n\n\tval = HDMI_READ(HDMI_CEC_CNTRL_1);\n\tval &= ~VC4_HDMI_CEC_START_XMIT_BEGIN;\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, val);\n\tval &= ~VC4_HDMI_CEC_MESSAGE_LENGTH_MASK;\n\tval |= (msg->len - 1) << VC4_HDMI_CEC_MESSAGE_LENGTH_SHIFT;\n\tval |= VC4_HDMI_CEC_START_XMIT_BEGIN;\n\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, val);\n\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\tmutex_unlock(&vc4_hdmi->mutex);\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops vc4_hdmi_cec_adap_ops = {\n\t.adap_enable = vc4_hdmi_cec_adap_enable,\n\t.adap_log_addr = vc4_hdmi_cec_adap_log_addr,\n\t.adap_transmit = vc4_hdmi_cec_adap_transmit,\n};\n\nstatic void vc4_hdmi_cec_release(void *ptr)\n{\n\tstruct vc4_hdmi *vc4_hdmi = ptr;\n\n\tcec_unregister_adapter(vc4_hdmi->cec_adap);\n\tvc4_hdmi->cec_adap = NULL;\n}\n\nstatic int vc4_hdmi_cec_init(struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct cec_connector_info conn_info;\n\tstruct platform_device *pdev = vc4_hdmi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (!of_property_present(dev->of_node, \"interrupts\")) {\n\t\tdev_warn(dev, \"'interrupts' DT property is missing, no CEC\\n\");\n\t\treturn 0;\n\t}\n\n\tvc4_hdmi->cec_adap = cec_allocate_adapter(&vc4_hdmi_cec_adap_ops,\n\t\t\t\t\t\t  vc4_hdmi,\n\t\t\t\t\t\t  vc4_hdmi->variant->card_name,\n\t\t\t\t\t\t  CEC_CAP_DEFAULTS |\n\t\t\t\t\t\t  CEC_CAP_CONNECTOR_INFO, 1);\n\tret = PTR_ERR_OR_ZERO(vc4_hdmi->cec_adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcec_fill_conn_info_from_drm(&conn_info, &vc4_hdmi->connector);\n\tcec_s_conn_info(vc4_hdmi->cec_adap, &conn_info);\n\n\tif (vc4_hdmi->variant->external_irq_controller) {\n\t\tret = devm_request_threaded_irq(dev, platform_get_irq_byname(pdev, \"cec-rx\"),\n\t\t\t\t\t\tvc4_cec_irq_handler_rx_bare,\n\t\t\t\t\t\tvc4_cec_irq_handler_rx_thread, 0,\n\t\t\t\t\t\t\"vc4 hdmi cec rx\", vc4_hdmi);\n\t\tif (ret)\n\t\t\tgoto err_delete_cec_adap;\n\n\t\tret = devm_request_threaded_irq(dev, platform_get_irq_byname(pdev, \"cec-tx\"),\n\t\t\t\t\t\tvc4_cec_irq_handler_tx_bare,\n\t\t\t\t\t\tvc4_cec_irq_handler_tx_thread, 0,\n\t\t\t\t\t\t\"vc4 hdmi cec tx\", vc4_hdmi);\n\t\tif (ret)\n\t\t\tgoto err_delete_cec_adap;\n\t} else {\n\t\tret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0),\n\t\t\t\t\t\tvc4_cec_irq_handler,\n\t\t\t\t\t\tvc4_cec_irq_handler_thread, 0,\n\t\t\t\t\t\t\"vc4 hdmi cec\", vc4_hdmi);\n\t\tif (ret)\n\t\t\tgoto err_delete_cec_adap;\n\t}\n\n\tret = cec_register_adapter(vc4_hdmi->cec_adap, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_delete_cec_adap;\n\n\t \n\tret = devm_add_action_or_reset(dev, vc4_hdmi_cec_release, vc4_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n\nerr_delete_cec_adap:\n\tcec_delete_adapter(vc4_hdmi->cec_adap);\n\n\treturn ret;\n}\n#else\nstatic int vc4_hdmi_cec_init(struct vc4_hdmi *vc4_hdmi)\n{\n\treturn 0;\n}\n#endif\n\nstatic void vc4_hdmi_free_regset(struct drm_device *drm, void *ptr)\n{\n\tstruct debugfs_reg32 *regs = ptr;\n\n\tkfree(regs);\n}\n\nstatic int vc4_hdmi_build_regset(struct drm_device *drm,\n\t\t\t\t struct vc4_hdmi *vc4_hdmi,\n\t\t\t\t struct debugfs_regset32 *regset,\n\t\t\t\t enum vc4_hdmi_regs reg)\n{\n\tconst struct vc4_hdmi_variant *variant = vc4_hdmi->variant;\n\tstruct debugfs_reg32 *regs, *new_regs;\n\tunsigned int count = 0;\n\tunsigned int i;\n\tint ret;\n\n\tregs = kcalloc(variant->num_registers, sizeof(*regs),\n\t\t       GFP_KERNEL);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < variant->num_registers; i++) {\n\t\tconst struct vc4_hdmi_register *field =\t&variant->registers[i];\n\n\t\tif (field->reg != reg)\n\t\t\tcontinue;\n\n\t\tregs[count].name = field->name;\n\t\tregs[count].offset = field->offset;\n\t\tcount++;\n\t}\n\n\tnew_regs = krealloc(regs, count * sizeof(*regs), GFP_KERNEL);\n\tif (!new_regs)\n\t\treturn -ENOMEM;\n\n\tregset->base = __vc4_hdmi_get_field_base(vc4_hdmi, reg);\n\tregset->regs = new_regs;\n\tregset->nregs = count;\n\n\tret = drmm_add_action_or_reset(drm, vc4_hdmi_free_regset, new_regs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_init_resources(struct drm_device *drm,\n\t\t\t\t   struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct platform_device *pdev = vc4_hdmi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tvc4_hdmi->hdmicore_regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(vc4_hdmi->hdmicore_regs))\n\t\treturn PTR_ERR(vc4_hdmi->hdmicore_regs);\n\n\tvc4_hdmi->hd_regs = vc4_ioremap_regs(pdev, 1);\n\tif (IS_ERR(vc4_hdmi->hd_regs))\n\t\treturn PTR_ERR(vc4_hdmi->hd_regs);\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->hd_regset, VC4_HD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->hdmi_regset, VC4_HDMI);\n\tif (ret)\n\t\treturn ret;\n\n\tvc4_hdmi->pixel_clock = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(vc4_hdmi->pixel_clock)) {\n\t\tret = PTR_ERR(vc4_hdmi->pixel_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get pixel clock\\n\");\n\t\treturn ret;\n\t}\n\n\tvc4_hdmi->hsm_clock = devm_clk_get(dev, \"hdmi\");\n\tif (IS_ERR(vc4_hdmi->hsm_clock)) {\n\t\tDRM_ERROR(\"Failed to get HDMI state machine clock\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->hsm_clock);\n\t}\n\tvc4_hdmi->audio_clock = vc4_hdmi->hsm_clock;\n\tvc4_hdmi->cec_clock = vc4_hdmi->hsm_clock;\n\n\treturn 0;\n}\n\nstatic int vc5_hdmi_init_resources(struct drm_device *drm,\n\t\t\t\t   struct vc4_hdmi *vc4_hdmi)\n{\n\tstruct platform_device *pdev = vc4_hdmi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hdmi\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->hdmicore_regs = devm_ioremap(dev, res->start,\n\t\t\t\t\t       resource_size(res));\n\tif (!vc4_hdmi->hdmicore_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"hd\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->hd_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->hd_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cec\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->cec_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->cec_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"csc\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->csc_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->csc_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dvp\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->dvp_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->dvp_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"phy\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->phy_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->phy_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"packet\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->ram_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->ram_regs)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"rm\");\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tvc4_hdmi->rm_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!vc4_hdmi->rm_regs)\n\t\treturn -ENOMEM;\n\n\tvc4_hdmi->hsm_clock = devm_clk_get(dev, \"hdmi\");\n\tif (IS_ERR(vc4_hdmi->hsm_clock)) {\n\t\tDRM_ERROR(\"Failed to get HDMI state machine clock\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->hsm_clock);\n\t}\n\n\tvc4_hdmi->pixel_bvb_clock = devm_clk_get(dev, \"bvb\");\n\tif (IS_ERR(vc4_hdmi->pixel_bvb_clock)) {\n\t\tDRM_ERROR(\"Failed to get pixel bvb clock\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->pixel_bvb_clock);\n\t}\n\n\tvc4_hdmi->audio_clock = devm_clk_get(dev, \"audio\");\n\tif (IS_ERR(vc4_hdmi->audio_clock)) {\n\t\tDRM_ERROR(\"Failed to get audio clock\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->audio_clock);\n\t}\n\n\tvc4_hdmi->cec_clock = devm_clk_get(dev, \"cec\");\n\tif (IS_ERR(vc4_hdmi->cec_clock)) {\n\t\tDRM_ERROR(\"Failed to get CEC clock\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->cec_clock);\n\t}\n\n\tvc4_hdmi->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(vc4_hdmi->reset)) {\n\t\tDRM_ERROR(\"Failed to get HDMI reset line\\n\");\n\t\treturn PTR_ERR(vc4_hdmi->reset);\n\t}\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->hdmi_regset, VC4_HDMI);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->hd_regset, VC4_HD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->cec_regset, VC5_CEC);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->csc_regset, VC5_CSC);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->dvp_regset, VC5_DVP);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->phy_regset, VC5_PHY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->ram_regset, VC5_RAM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_hdmi_build_regset(drm, vc4_hdmi, &vc4_hdmi->rm_regset, VC5_RM);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_runtime_suspend(struct device *dev)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(vc4_hdmi->hsm_clock);\n\n\treturn 0;\n}\n\nstatic int vc4_hdmi_runtime_resume(struct device *dev)\n{\n\tstruct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);\n\tunsigned long __maybe_unused flags;\n\tu32 __maybe_unused value;\n\tunsigned long rate;\n\tint ret;\n\n\tret = clk_prepare_enable(vc4_hdmi->hsm_clock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trate = clk_get_rate(vc4_hdmi->hsm_clock);\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk;\n\t}\n\n\tif (vc4_hdmi->variant->reset)\n\t\tvc4_hdmi->variant->reset(vc4_hdmi);\n\n#ifdef CONFIG_DRM_VC4_HDMI_CEC\n\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\tvalue = HDMI_READ(HDMI_CEC_CNTRL_1);\n\t \n\tvalue |= VC4_HDMI_CEC_ADDR_MASK;\n\tHDMI_WRITE(HDMI_CEC_CNTRL_1, value);\n\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\n\tvc4_hdmi_cec_update_clk_div(vc4_hdmi);\n\n\tif (!vc4_hdmi->variant->external_irq_controller) {\n\t\tspin_lock_irqsave(&vc4_hdmi->hw_lock, flags);\n\t\tHDMI_WRITE(HDMI_CEC_CPU_MASK_SET, 0xffffffff);\n\t\tspin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);\n\t}\n#endif\n\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(vc4_hdmi->hsm_clock);\n\treturn ret;\n}\n\nstatic void vc4_hdmi_put_ddc_device(void *ptr)\n{\n\tstruct vc4_hdmi *vc4_hdmi = ptr;\n\n\tput_device(&vc4_hdmi->ddc->dev);\n}\n\nstatic int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)\n{\n\tconst struct vc4_hdmi_variant *variant = of_device_get_match_data(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_hdmi *vc4_hdmi;\n\tstruct drm_encoder *encoder;\n\tstruct device_node *ddc_node;\n\tint ret;\n\n\tvc4_hdmi = drmm_kzalloc(drm, sizeof(*vc4_hdmi), GFP_KERNEL);\n\tif (!vc4_hdmi)\n\t\treturn -ENOMEM;\n\n\tret = drmm_mutex_init(drm, &vc4_hdmi->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&vc4_hdmi->hw_lock);\n\tINIT_DELAYED_WORK(&vc4_hdmi->scrambling_work, vc4_hdmi_scrambling_wq);\n\n\tdev_set_drvdata(dev, vc4_hdmi);\n\tencoder = &vc4_hdmi->encoder.base;\n\tvc4_hdmi->encoder.type = variant->encoder_type;\n\tvc4_hdmi->encoder.pre_crtc_configure = vc4_hdmi_encoder_pre_crtc_configure;\n\tvc4_hdmi->encoder.pre_crtc_enable = vc4_hdmi_encoder_pre_crtc_enable;\n\tvc4_hdmi->encoder.post_crtc_enable = vc4_hdmi_encoder_post_crtc_enable;\n\tvc4_hdmi->encoder.post_crtc_disable = vc4_hdmi_encoder_post_crtc_disable;\n\tvc4_hdmi->encoder.post_crtc_powerdown = vc4_hdmi_encoder_post_crtc_powerdown;\n\tvc4_hdmi->pdev = pdev;\n\tvc4_hdmi->variant = variant;\n\n\t \n\tif (variant->max_pixel_clock > HDMI_14_MAX_TMDS_CLK)\n\t\tvc4_hdmi->scdc_enabled = true;\n\n\tret = variant->init_resources(drm, vc4_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\tddc_node = of_parse_phandle(dev->of_node, \"ddc\", 0);\n\tif (!ddc_node) {\n\t\tDRM_ERROR(\"Failed to find ddc node in device tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tvc4_hdmi->ddc = of_find_i2c_adapter_by_node(ddc_node);\n\tof_node_put(ddc_node);\n\tif (!vc4_hdmi->ddc) {\n\t\tDRM_DEBUG(\"Failed to get ddc i2c adapter by node\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tret = devm_add_action_or_reset(dev, vc4_hdmi_put_ddc_device, vc4_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvc4_hdmi->hpd_gpio = devm_gpiod_get_optional(dev, \"hpd\", GPIOD_IN);\n\tif (IS_ERR(vc4_hdmi->hpd_gpio)) {\n\t\treturn PTR_ERR(vc4_hdmi->hpd_gpio);\n\t}\n\n\tvc4_hdmi->disable_wifi_frequencies =\n\t\tof_property_read_bool(dev->of_node, \"wifi-2.4ghz-coexistence\");\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((of_device_is_compatible(dev->of_node, \"brcm,bcm2711-hdmi0\") ||\n\t     of_device_is_compatible(dev->of_node, \"brcm,bcm2711-hdmi1\")) &&\n\t    HDMI_READ(HDMI_VID_CTL) & VC4_HD_VID_CTL_ENABLE) {\n\t\tclk_prepare_enable(vc4_hdmi->pixel_clock);\n\t\tclk_prepare_enable(vc4_hdmi->hsm_clock);\n\t\tclk_prepare_enable(vc4_hdmi->pixel_bvb_clock);\n\t}\n\n\tret = drmm_encoder_init(drm, encoder,\n\t\t\t\t&vc4_hdmi_encoder_funcs,\n\t\t\t\tDRM_MODE_ENCODER_TMDS,\n\t\t\t\tNULL);\n\tif (ret)\n\t\tgoto err_put_runtime_pm;\n\n\tdrm_encoder_helper_add(encoder, &vc4_hdmi_encoder_helper_funcs);\n\n\tret = vc4_hdmi_connector_init(drm, vc4_hdmi);\n\tif (ret)\n\t\tgoto err_put_runtime_pm;\n\n\tret = vc4_hdmi_hotplug_init(vc4_hdmi);\n\tif (ret)\n\t\tgoto err_put_runtime_pm;\n\n\tret = vc4_hdmi_cec_init(vc4_hdmi);\n\tif (ret)\n\t\tgoto err_put_runtime_pm;\n\n\tret = vc4_hdmi_audio_init(vc4_hdmi);\n\tif (ret)\n\t\tgoto err_put_runtime_pm;\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n\nerr_put_runtime_pm:\n\tpm_runtime_put_sync(dev);\n\n\treturn ret;\n}\n\nstatic const struct component_ops vc4_hdmi_ops = {\n\t.bind   = vc4_hdmi_bind,\n};\n\nstatic int vc4_hdmi_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_hdmi_ops);\n}\n\nstatic void vc4_hdmi_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_hdmi_ops);\n}\n\nstatic const struct vc4_hdmi_variant bcm2835_variant = {\n\t.encoder_type\t\t= VC4_ENCODER_TYPE_HDMI0,\n\t.debugfs_name\t\t= \"hdmi_regs\",\n\t.card_name\t\t= \"vc4-hdmi\",\n\t.max_pixel_clock\t= 162000000,\n\t.registers\t\t= vc4_hdmi_fields,\n\t.num_registers\t\t= ARRAY_SIZE(vc4_hdmi_fields),\n\n\t.init_resources\t\t= vc4_hdmi_init_resources,\n\t.csc_setup\t\t= vc4_hdmi_csc_setup,\n\t.reset\t\t\t= vc4_hdmi_reset,\n\t.set_timings\t\t= vc4_hdmi_set_timings,\n\t.phy_init\t\t= vc4_hdmi_phy_init,\n\t.phy_disable\t\t= vc4_hdmi_phy_disable,\n\t.phy_rng_enable\t\t= vc4_hdmi_phy_rng_enable,\n\t.phy_rng_disable\t= vc4_hdmi_phy_rng_disable,\n\t.channel_map\t\t= vc4_hdmi_channel_map,\n\t.supports_hdr\t\t= false,\n};\n\nstatic const struct vc4_hdmi_variant bcm2711_hdmi0_variant = {\n\t.encoder_type\t\t= VC4_ENCODER_TYPE_HDMI0,\n\t.debugfs_name\t\t= \"hdmi0_regs\",\n\t.card_name\t\t= \"vc4-hdmi-0\",\n\t.max_pixel_clock\t= 600000000,\n\t.registers\t\t= vc5_hdmi_hdmi0_fields,\n\t.num_registers\t\t= ARRAY_SIZE(vc5_hdmi_hdmi0_fields),\n\t.phy_lane_mapping\t= {\n\t\tPHY_LANE_0,\n\t\tPHY_LANE_1,\n\t\tPHY_LANE_2,\n\t\tPHY_LANE_CK,\n\t},\n\t.unsupported_odd_h_timings\t= true,\n\t.external_irq_controller\t= true,\n\n\t.init_resources\t\t= vc5_hdmi_init_resources,\n\t.csc_setup\t\t= vc5_hdmi_csc_setup,\n\t.reset\t\t\t= vc5_hdmi_reset,\n\t.set_timings\t\t= vc5_hdmi_set_timings,\n\t.phy_init\t\t= vc5_hdmi_phy_init,\n\t.phy_disable\t\t= vc5_hdmi_phy_disable,\n\t.phy_rng_enable\t\t= vc5_hdmi_phy_rng_enable,\n\t.phy_rng_disable\t= vc5_hdmi_phy_rng_disable,\n\t.channel_map\t\t= vc5_hdmi_channel_map,\n\t.supports_hdr\t\t= true,\n\t.hp_detect\t\t= vc5_hdmi_hp_detect,\n};\n\nstatic const struct vc4_hdmi_variant bcm2711_hdmi1_variant = {\n\t.encoder_type\t\t= VC4_ENCODER_TYPE_HDMI1,\n\t.debugfs_name\t\t= \"hdmi1_regs\",\n\t.card_name\t\t= \"vc4-hdmi-1\",\n\t.max_pixel_clock\t= HDMI_14_MAX_TMDS_CLK,\n\t.registers\t\t= vc5_hdmi_hdmi1_fields,\n\t.num_registers\t\t= ARRAY_SIZE(vc5_hdmi_hdmi1_fields),\n\t.phy_lane_mapping\t= {\n\t\tPHY_LANE_1,\n\t\tPHY_LANE_0,\n\t\tPHY_LANE_CK,\n\t\tPHY_LANE_2,\n\t},\n\t.unsupported_odd_h_timings\t= true,\n\t.external_irq_controller\t= true,\n\n\t.init_resources\t\t= vc5_hdmi_init_resources,\n\t.csc_setup\t\t= vc5_hdmi_csc_setup,\n\t.reset\t\t\t= vc5_hdmi_reset,\n\t.set_timings\t\t= vc5_hdmi_set_timings,\n\t.phy_init\t\t= vc5_hdmi_phy_init,\n\t.phy_disable\t\t= vc5_hdmi_phy_disable,\n\t.phy_rng_enable\t\t= vc5_hdmi_phy_rng_enable,\n\t.phy_rng_disable\t= vc5_hdmi_phy_rng_disable,\n\t.channel_map\t\t= vc5_hdmi_channel_map,\n\t.supports_hdr\t\t= true,\n\t.hp_detect\t\t= vc5_hdmi_hp_detect,\n};\n\nstatic const struct of_device_id vc4_hdmi_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-hdmi\", .data = &bcm2835_variant },\n\t{ .compatible = \"brcm,bcm2711-hdmi0\", .data = &bcm2711_hdmi0_variant },\n\t{ .compatible = \"brcm,bcm2711-hdmi1\", .data = &bcm2711_hdmi1_variant },\n\t{}\n};\n\nstatic const struct dev_pm_ops vc4_hdmi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(vc4_hdmi_runtime_suspend,\n\t\t\t   vc4_hdmi_runtime_resume,\n\t\t\t   NULL)\n};\n\nstruct platform_driver vc4_hdmi_driver = {\n\t.probe = vc4_hdmi_dev_probe,\n\t.remove_new = vc4_hdmi_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_hdmi\",\n\t\t.of_match_table = vc4_hdmi_dt_match,\n\t\t.pm = &vc4_hdmi_pm_ops,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}