{
  "module_name": "vc4_drv.c",
  "hash_id": "8c8104da1ee7914ea2451e754d51bba8969eb07b613d9a1cc0953ded06b57f3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_vblank.h>\n\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#include \"uapi/drm/vc4_drm.h\"\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n#define DRIVER_NAME \"vc4\"\n#define DRIVER_DESC \"Broadcom VC4 graphics\"\n#define DRIVER_DATE \"20140616\"\n#define DRIVER_MAJOR 0\n#define DRIVER_MINOR 0\n#define DRIVER_PATCHLEVEL 0\n\n \nvoid __iomem *vc4_ioremap_regs(struct platform_device *pdev, int index)\n{\n\tvoid __iomem *map;\n\n\tmap = devm_platform_ioremap_resource(pdev, index);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\treturn map;\n}\n\nint vc4_dumb_fixup_args(struct drm_mode_create_dumb *args)\n{\n\tint min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\n\tif (args->pitch < min_pitch)\n\t\targs->pitch = min_pitch;\n\n\tif (args->size < args->pitch * args->height)\n\t\targs->size = args->pitch * args->height;\n\n\treturn 0;\n}\n\nstatic int vc5_dumb_create(struct drm_file *file_priv,\n\t\t\t   struct drm_device *dev,\n\t\t\t   struct drm_mode_create_dumb *args)\n{\n\tint ret;\n\n\tret = vc4_dumb_fixup_args(args);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_gem_dma_dumb_create_internal(file_priv, dev, args);\n}\n\nstatic int vc4_get_param_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file_priv)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_vc4_get_param *args = data;\n\tint ret;\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (!vc4->v3d)\n\t\treturn -ENODEV;\n\n\tswitch (args->param) {\n\tcase DRM_VC4_PARAM_V3D_IDENT0:\n\t\tret = vc4_v3d_pm_get(vc4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\targs->value = V3D_READ(V3D_IDENT0);\n\t\tvc4_v3d_pm_put(vc4);\n\t\tbreak;\n\tcase DRM_VC4_PARAM_V3D_IDENT1:\n\t\tret = vc4_v3d_pm_get(vc4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\targs->value = V3D_READ(V3D_IDENT1);\n\t\tvc4_v3d_pm_put(vc4);\n\t\tbreak;\n\tcase DRM_VC4_PARAM_V3D_IDENT2:\n\t\tret = vc4_v3d_pm_get(vc4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\targs->value = V3D_READ(V3D_IDENT2);\n\t\tvc4_v3d_pm_put(vc4);\n\t\tbreak;\n\tcase DRM_VC4_PARAM_SUPPORTS_BRANCHES:\n\tcase DRM_VC4_PARAM_SUPPORTS_ETC1:\n\tcase DRM_VC4_PARAM_SUPPORTS_THREADED_FS:\n\tcase DRM_VC4_PARAM_SUPPORTS_FIXED_RCL_ORDER:\n\tcase DRM_VC4_PARAM_SUPPORTS_MADVISE:\n\tcase DRM_VC4_PARAM_SUPPORTS_PERFMON:\n\t\targs->value = true;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"Unknown parameter %d\\n\", args->param);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_file *vc4file;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tvc4file = kzalloc(sizeof(*vc4file), GFP_KERNEL);\n\tif (!vc4file)\n\t\treturn -ENOMEM;\n\tvc4file->dev = vc4;\n\n\tvc4_perfmon_open_file(vc4file);\n\tfile->driver_priv = vc4file;\n\treturn 0;\n}\n\nstatic void vc4_close(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_file *vc4file = file->driver_priv;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (vc4file->bin_bo_used)\n\t\tvc4_v3d_bin_bo_put(vc4);\n\n\tvc4_perfmon_close_file(vc4file);\n\tkfree(vc4file);\n}\n\nDEFINE_DRM_GEM_FOPS(vc4_drm_fops);\n\nstatic const struct drm_ioctl_desc vc4_drm_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(VC4_SUBMIT_CL, vc4_submit_cl_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_WAIT_SEQNO, vc4_wait_seqno_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_WAIT_BO, vc4_wait_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_CREATE_BO, vc4_create_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_MMAP_BO, vc4_mmap_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_CREATE_SHADER_BO, vc4_create_shader_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_GET_HANG_STATE, vc4_get_hang_state_ioctl,\n\t\t\t  DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(VC4_GET_PARAM, vc4_get_param_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_SET_TILING, vc4_set_tiling_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_GET_TILING, vc4_get_tiling_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_LABEL_BO, vc4_label_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_GEM_MADVISE, vc4_gem_madvise_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_PERFMON_CREATE, vc4_perfmon_create_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_PERFMON_DESTROY, vc4_perfmon_destroy_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(VC4_PERFMON_GET_VALUES, vc4_perfmon_get_values_ioctl, DRM_RENDER_ALLOW),\n};\n\nconst struct drm_driver vc4_drm_driver = {\n\t.driver_features = (DRIVER_MODESET |\n\t\t\t    DRIVER_ATOMIC |\n\t\t\t    DRIVER_GEM |\n\t\t\t    DRIVER_RENDER |\n\t\t\t    DRIVER_SYNCOBJ),\n\t.open = vc4_open,\n\t.postclose = vc4_close,\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = vc4_debugfs_init,\n#endif\n\n\t.gem_create_object = vc4_create_object,\n\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc4_bo_dumb_create),\n\n\t.ioctls = vc4_drm_ioctls,\n\t.num_ioctls = ARRAY_SIZE(vc4_drm_ioctls),\n\t.fops = &vc4_drm_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nconst struct drm_driver vc5_drm_driver = {\n\t.driver_features = (DRIVER_MODESET |\n\t\t\t    DRIVER_ATOMIC |\n\t\t\t    DRIVER_GEM),\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = vc4_debugfs_init,\n#endif\n\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc5_dumb_create),\n\n\t.fops = &vc4_drm_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nstatic void vc4_match_add_drivers(struct device *dev,\n\t\t\t\t  struct component_match **match,\n\t\t\t\t  struct platform_driver *const *drivers,\n\t\t\t\t  int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct device_driver *drv = &drivers[i]->driver;\n\t\tstruct device *p = NULL, *d;\n\n\t\twhile ((d = platform_find_device_by_driver(p, drv))) {\n\t\t\tput_device(p);\n\t\t\tcomponent_match_add(dev, match, component_compare_dev, d);\n\t\t\tp = d;\n\t\t}\n\t\tput_device(p);\n\t}\n}\n\nstatic void vc4_component_unbind_all(void *ptr)\n{\n\tstruct vc4_dev *vc4 = ptr;\n\n\tcomponent_unbind_all(vc4->dev, &vc4->base);\n}\n\nstatic const struct of_device_id vc4_dma_range_matches[] = {\n\t{ .compatible = \"brcm,bcm2711-hvs\" },\n\t{ .compatible = \"brcm,bcm2835-hvs\" },\n\t{ .compatible = \"brcm,bcm2835-v3d\" },\n\t{ .compatible = \"brcm,cygnus-v3d\" },\n\t{ .compatible = \"brcm,vc4-v3d\" },\n\t{}\n};\n\nstatic int vc4_drm_bind(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct drm_driver *driver;\n\tstruct rpi_firmware *firmware = NULL;\n\tstruct drm_device *drm;\n\tstruct vc4_dev *vc4;\n\tstruct device_node *node;\n\tstruct drm_crtc *crtc;\n\tbool is_vc5;\n\tint ret = 0;\n\n\tdev->coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tis_vc5 = of_device_is_compatible(dev->of_node, \"brcm,bcm2711-vc5\");\n\tif (is_vc5)\n\t\tdriver = &vc5_drm_driver;\n\telse\n\t\tdriver = &vc4_drm_driver;\n\n\tnode = of_find_matching_node_and_match(NULL, vc4_dma_range_matches,\n\t\t\t\t\t       NULL);\n\tif (node) {\n\t\tret = of_dma_configure(dev, node, true);\n\t\tof_node_put(node);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvc4 = devm_drm_dev_alloc(dev, driver, struct vc4_dev, base);\n\tif (IS_ERR(vc4))\n\t\treturn PTR_ERR(vc4);\n\tvc4->is_vc5 = is_vc5;\n\tvc4->dev = dev;\n\n\tdrm = &vc4->base;\n\tplatform_set_drvdata(pdev, drm);\n\n\tif (!is_vc5) {\n\t\tret = drmm_mutex_init(drm, &vc4->bin_bo_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vc4_bo_cache_init(drm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_vc5) {\n\t\tret = vc4_gem_init(drm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnode = of_find_compatible_node(NULL, NULL, \"raspberrypi,bcm2835-firmware\");\n\tif (node) {\n\t\tfirmware = rpi_firmware_get(node);\n\t\tof_node_put(node);\n\n\t\tif (!firmware)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tret = drm_aperture_remove_framebuffers(driver);\n\tif (ret)\n\t\treturn ret;\n\n\tif (firmware) {\n\t\tret = rpi_firmware_property(firmware,\n\t\t\t\t\t    RPI_FIRMWARE_NOTIFY_DISPLAY_DONE,\n\t\t\t\t\t    NULL, 0);\n\t\tif (ret)\n\t\t\tdrm_warn(drm, \"Couldn't stop firmware display driver: %d\\n\", ret);\n\n\t\trpi_firmware_put(firmware);\n\t}\n\n\tret = component_bind_all(dev, drm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, vc4_component_unbind_all, vc4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_plane_create_additional_planes(drm);\n\tif (ret)\n\t\tgoto unbind_all;\n\n\tret = vc4_kms_load(drm);\n\tif (ret < 0)\n\t\tgoto unbind_all;\n\n\tdrm_for_each_crtc(crtc, drm)\n\t\tvc4_crtc_disable_at_boot(crtc);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto unbind_all;\n\n\tdrm_fbdev_dma_setup(drm, 16);\n\n\treturn 0;\n\nunbind_all:\n\treturn ret;\n}\n\nstatic void vc4_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_dev_unplug(drm);\n\tdrm_atomic_helper_shutdown(drm);\n}\n\nstatic const struct component_master_ops vc4_drm_ops = {\n\t.bind = vc4_drm_bind,\n\t.unbind = vc4_drm_unbind,\n};\n\n \nstatic struct platform_driver *const component_drivers[] = {\n\t&vc4_hvs_driver,\n\t&vc4_hdmi_driver,\n\t&vc4_vec_driver,\n\t&vc4_dpi_driver,\n\t&vc4_dsi_driver,\n\t&vc4_txp_driver,\n\t&vc4_crtc_driver,\n\t&vc4_v3d_driver,\n};\n\nstatic int vc4_platform_drm_probe(struct platform_device *pdev)\n{\n\tstruct component_match *match = NULL;\n\tstruct device *dev = &pdev->dev;\n\n\tvc4_match_add_drivers(dev, &match,\n\t\t\t      component_drivers, ARRAY_SIZE(component_drivers));\n\n\treturn component_master_add_with_match(dev, &vc4_drm_ops, match);\n}\n\nstatic void vc4_platform_drm_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &vc4_drm_ops);\n}\n\nstatic const struct of_device_id vc4_of_match[] = {\n\t{ .compatible = \"brcm,bcm2711-vc5\", },\n\t{ .compatible = \"brcm,bcm2835-vc4\", },\n\t{ .compatible = \"brcm,cygnus-vc4\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, vc4_of_match);\n\nstatic struct platform_driver vc4_platform_driver = {\n\t.probe\t\t= vc4_platform_drm_probe,\n\t.remove_new\t= vc4_platform_drm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vc4-drm\",\n\t\t.of_match_table = vc4_of_match,\n\t},\n};\n\nstatic int __init vc4_drm_register(void)\n{\n\tint ret;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tret = platform_register_drivers(component_drivers,\n\t\t\t\t\tARRAY_SIZE(component_drivers));\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&vc4_platform_driver);\n\tif (ret)\n\t\tplatform_unregister_drivers(component_drivers,\n\t\t\t\t\t    ARRAY_SIZE(component_drivers));\n\n\treturn ret;\n}\n\nstatic void __exit vc4_drm_unregister(void)\n{\n\tplatform_unregister_drivers(component_drivers,\n\t\t\t\t    ARRAY_SIZE(component_drivers));\n\tplatform_driver_unregister(&vc4_platform_driver);\n}\n\nmodule_init(vc4_drm_register);\nmodule_exit(vc4_drm_unregister);\n\nMODULE_ALIAS(\"platform:vc4-drm\");\nMODULE_SOFTDEP(\"pre: snd-soc-hdmi-codec\");\nMODULE_DESCRIPTION(\"Broadcom VC4 DRM Driver\");\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}