{
  "module_name": "vc4_validate.c",
  "hash_id": "1f7ce09c4703fe2bec8c46c0790e8024513042bbdf79a21a710eb4a75781675a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_validate.c",
  "human_readable_source": " \n\n \n\n#include \"uapi/drm/vc4_drm.h\"\n#include \"vc4_drv.h\"\n#include \"vc4_packet.h\"\n\n#define VALIDATE_ARGS \\\n\tstruct vc4_exec_info *exec,\t\t\t\\\n\tvoid *validated,\t\t\t\t\\\n\tvoid *untrusted\n\n \nstatic uint32_t\nutile_width(int cpp)\n{\n\tswitch (cpp) {\n\tcase 1:\n\tcase 2:\n\t\treturn 8;\n\tcase 4:\n\t\treturn 4;\n\tcase 8:\n\t\treturn 2;\n\tdefault:\n\t\tDRM_ERROR(\"unknown cpp: %d\\n\", cpp);\n\t\treturn 1;\n\t}\n}\n\n \nstatic uint32_t\nutile_height(int cpp)\n{\n\tswitch (cpp) {\n\tcase 1:\n\t\treturn 8;\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\treturn 4;\n\tdefault:\n\t\tDRM_ERROR(\"unknown cpp: %d\\n\", cpp);\n\t\treturn 1;\n\t}\n}\n\n \nstatic bool\nsize_is_lt(uint32_t width, uint32_t height, int cpp)\n{\n\treturn (width <= 4 * utile_width(cpp) ||\n\t\theight <= 4 * utile_height(cpp));\n}\n\nstruct drm_gem_dma_object *\nvc4_use_bo(struct vc4_exec_info *exec, uint32_t hindex)\n{\n\tstruct vc4_dev *vc4 = exec->dev;\n\tstruct drm_gem_dma_object *obj;\n\tstruct vc4_bo *bo;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn NULL;\n\n\tif (hindex >= exec->bo_count) {\n\t\tDRM_DEBUG(\"BO index %d greater than BO count %d\\n\",\n\t\t\t  hindex, exec->bo_count);\n\t\treturn NULL;\n\t}\n\tobj = to_drm_gem_dma_obj(exec->bo[hindex]);\n\tbo = to_vc4_bo(&obj->base);\n\n\tif (bo->validated_shader) {\n\t\tDRM_DEBUG(\"Trying to use shader BO as something other than \"\n\t\t\t  \"a shader\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn obj;\n}\n\nstatic struct drm_gem_dma_object *\nvc4_use_handle(struct vc4_exec_info *exec, uint32_t gem_handles_packet_index)\n{\n\treturn vc4_use_bo(exec, exec->bo_index[gem_handles_packet_index]);\n}\n\nstatic bool\nvalidate_bin_pos(struct vc4_exec_info *exec, void *untrusted, uint32_t pos)\n{\n\t \n\treturn (untrusted - 1 == exec->bin_u + pos);\n}\n\nstatic uint32_t\ngl_shader_rec_size(uint32_t pointer_bits)\n{\n\tuint32_t attribute_count = pointer_bits & 7;\n\tbool extended = pointer_bits & 8;\n\n\tif (attribute_count == 0)\n\t\tattribute_count = 8;\n\n\tif (extended)\n\t\treturn 100 + attribute_count * 4;\n\telse\n\t\treturn 36 + attribute_count * 8;\n}\n\nbool\nvc4_check_tex_size(struct vc4_exec_info *exec, struct drm_gem_dma_object *fbo,\n\t\t   uint32_t offset, uint8_t tiling_format,\n\t\t   uint32_t width, uint32_t height, uint8_t cpp)\n{\n\tstruct vc4_dev *vc4 = exec->dev;\n\tuint32_t aligned_width, aligned_height, stride, size;\n\tuint32_t utile_w = utile_width(cpp);\n\tuint32_t utile_h = utile_height(cpp);\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn false;\n\n\t \n\tif (width > 4096 || height > 4096) {\n\t\tDRM_DEBUG(\"Surface dimensions (%d,%d) too large\",\n\t\t\t  width, height);\n\t\treturn false;\n\t}\n\n\tswitch (tiling_format) {\n\tcase VC4_TILING_FORMAT_LINEAR:\n\t\taligned_width = round_up(width, utile_w);\n\t\taligned_height = height;\n\t\tbreak;\n\tcase VC4_TILING_FORMAT_T:\n\t\taligned_width = round_up(width, utile_w * 8);\n\t\taligned_height = round_up(height, utile_h * 8);\n\t\tbreak;\n\tcase VC4_TILING_FORMAT_LT:\n\t\taligned_width = round_up(width, utile_w);\n\t\taligned_height = round_up(height, utile_h);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"buffer tiling %d unsupported\\n\", tiling_format);\n\t\treturn false;\n\t}\n\n\tstride = aligned_width * cpp;\n\tsize = stride * aligned_height;\n\n\tif (size + offset < size ||\n\t    size + offset > fbo->base.size) {\n\t\tDRM_DEBUG(\"Overflow in %dx%d (%dx%d) fbo size (%d + %d > %zd)\\n\",\n\t\t\t  width, height,\n\t\t\t  aligned_width, aligned_height,\n\t\t\t  size, offset, fbo->base.size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nvalidate_flush(VALIDATE_ARGS)\n{\n\tif (!validate_bin_pos(exec, untrusted, exec->args->bin_cl_size - 1)) {\n\t\tDRM_DEBUG(\"Bin CL must end with VC4_PACKET_FLUSH\\n\");\n\t\treturn -EINVAL;\n\t}\n\texec->found_flush = true;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_start_tile_binning(VALIDATE_ARGS)\n{\n\tif (exec->found_start_tile_binning_packet) {\n\t\tDRM_DEBUG(\"Duplicate VC4_PACKET_START_TILE_BINNING\\n\");\n\t\treturn -EINVAL;\n\t}\n\texec->found_start_tile_binning_packet = true;\n\n\tif (!exec->found_tile_binning_mode_config_packet) {\n\t\tDRM_DEBUG(\"missing VC4_PACKET_TILE_BINNING_MODE_CONFIG\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvalidate_increment_semaphore(VALIDATE_ARGS)\n{\n\tif (!validate_bin_pos(exec, untrusted, exec->args->bin_cl_size - 2)) {\n\t\tDRM_DEBUG(\"Bin CL must end with \"\n\t\t\t  \"VC4_PACKET_INCREMENT_SEMAPHORE\\n\");\n\t\treturn -EINVAL;\n\t}\n\texec->found_increment_semaphore_packet = true;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_indexed_prim_list(VALIDATE_ARGS)\n{\n\tstruct drm_gem_dma_object *ib;\n\tuint32_t length = *(uint32_t *)(untrusted + 1);\n\tuint32_t offset = *(uint32_t *)(untrusted + 5);\n\tuint32_t max_index = *(uint32_t *)(untrusted + 9);\n\tuint32_t index_size = (*(uint8_t *)(untrusted + 0) >> 4) ? 2 : 1;\n\tstruct vc4_shader_state *shader_state;\n\n\t \n\tif (exec->shader_state_count == 0) {\n\t\tDRM_DEBUG(\"shader state must precede primitives\\n\");\n\t\treturn -EINVAL;\n\t}\n\tshader_state = &exec->shader_state[exec->shader_state_count - 1];\n\n\tif (max_index > shader_state->max_index)\n\t\tshader_state->max_index = max_index;\n\n\tib = vc4_use_handle(exec, 0);\n\tif (!ib)\n\t\treturn -EINVAL;\n\n\texec->bin_dep_seqno = max(exec->bin_dep_seqno,\n\t\t\t\t  to_vc4_bo(&ib->base)->write_seqno);\n\n\tif (offset > ib->base.size ||\n\t    (ib->base.size - offset) / index_size < length) {\n\t\tDRM_DEBUG(\"IB access overflow (%d + %d*%d > %zd)\\n\",\n\t\t\t  offset, length, index_size, ib->base.size);\n\t\treturn -EINVAL;\n\t}\n\n\t*(uint32_t *)(validated + 5) = ib->dma_addr + offset;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_gl_array_primitive(VALIDATE_ARGS)\n{\n\tuint32_t length = *(uint32_t *)(untrusted + 1);\n\tuint32_t base_index = *(uint32_t *)(untrusted + 5);\n\tuint32_t max_index;\n\tstruct vc4_shader_state *shader_state;\n\n\t \n\tif (exec->shader_state_count == 0) {\n\t\tDRM_DEBUG(\"shader state must precede primitives\\n\");\n\t\treturn -EINVAL;\n\t}\n\tshader_state = &exec->shader_state[exec->shader_state_count - 1];\n\n\tif (length + base_index < length) {\n\t\tDRM_DEBUG(\"primitive vertex count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmax_index = length + base_index - 1;\n\n\tif (max_index > shader_state->max_index)\n\t\tshader_state->max_index = max_index;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_gl_shader_state(VALIDATE_ARGS)\n{\n\tuint32_t i = exec->shader_state_count++;\n\n\tif (i >= exec->shader_state_size) {\n\t\tDRM_DEBUG(\"More requests for shader states than declared\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\texec->shader_state[i].addr = *(uint32_t *)untrusted;\n\texec->shader_state[i].max_index = 0;\n\n\tif (exec->shader_state[i].addr & ~0xf) {\n\t\tDRM_DEBUG(\"high bits set in GL shader rec reference\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*(uint32_t *)validated = (exec->shader_rec_p +\n\t\t\t\t  exec->shader_state[i].addr);\n\n\texec->shader_rec_p +=\n\t\troundup(gl_shader_rec_size(exec->shader_state[i].addr), 16);\n\n\treturn 0;\n}\n\nstatic int\nvalidate_tile_binning_config(VALIDATE_ARGS)\n{\n\tstruct drm_device *dev = exec->exec_bo->base.dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tuint8_t flags;\n\tuint32_t tile_state_size;\n\tuint32_t tile_count, bin_addr;\n\tint bin_slot;\n\n\tif (exec->found_tile_binning_mode_config_packet) {\n\t\tDRM_DEBUG(\"Duplicate VC4_PACKET_TILE_BINNING_MODE_CONFIG\\n\");\n\t\treturn -EINVAL;\n\t}\n\texec->found_tile_binning_mode_config_packet = true;\n\n\texec->bin_tiles_x = *(uint8_t *)(untrusted + 12);\n\texec->bin_tiles_y = *(uint8_t *)(untrusted + 13);\n\ttile_count = exec->bin_tiles_x * exec->bin_tiles_y;\n\tflags = *(uint8_t *)(untrusted + 14);\n\n\tif (exec->bin_tiles_x == 0 ||\n\t    exec->bin_tiles_y == 0) {\n\t\tDRM_DEBUG(\"Tile binning config of %dx%d too small\\n\",\n\t\t\t  exec->bin_tiles_x, exec->bin_tiles_y);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & (VC4_BIN_CONFIG_DB_NON_MS |\n\t\t     VC4_BIN_CONFIG_TILE_BUFFER_64BIT)) {\n\t\tDRM_DEBUG(\"unsupported binning config flags 0x%02x\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\tbin_slot = vc4_v3d_get_bin_slot(vc4);\n\tif (bin_slot < 0) {\n\t\tif (bin_slot != -EINTR && bin_slot != -ERESTARTSYS) {\n\t\t\tDRM_ERROR(\"Failed to allocate binner memory: %d\\n\",\n\t\t\t\t  bin_slot);\n\t\t}\n\t\treturn bin_slot;\n\t}\n\n\t \n\texec->bin_slots |= BIT(bin_slot);\n\tbin_addr = vc4->bin_bo->base.dma_addr + bin_slot * vc4->bin_alloc_size;\n\n\t \n\ttile_state_size = 48 * tile_count;\n\n\t \n\texec->tile_alloc_offset = bin_addr + roundup(tile_state_size, 4096);\n\n\t*(uint8_t *)(validated + 14) =\n\t\t((flags & ~(VC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE_MASK |\n\t\t\t    VC4_BIN_CONFIG_ALLOC_BLOCK_SIZE_MASK)) |\n\t\t VC4_BIN_CONFIG_AUTO_INIT_TSDA |\n\t\t VC4_SET_FIELD(VC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE_32,\n\t\t\t       VC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE) |\n\t\t VC4_SET_FIELD(VC4_BIN_CONFIG_ALLOC_BLOCK_SIZE_128,\n\t\t\t       VC4_BIN_CONFIG_ALLOC_BLOCK_SIZE));\n\n\t \n\t*(uint32_t *)(validated + 0) = exec->tile_alloc_offset;\n\t \n\t*(uint32_t *)(validated + 4) = (bin_addr + vc4->bin_alloc_size -\n\t\t\t\t\texec->tile_alloc_offset);\n\t \n\t*(uint32_t *)(validated + 8) = bin_addr;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_gem_handles(VALIDATE_ARGS)\n{\n\tmemcpy(exec->bo_index, untrusted, sizeof(exec->bo_index));\n\treturn 0;\n}\n\n#define VC4_DEFINE_PACKET(packet, func) \\\n\t[packet] = { packet ## _SIZE, #packet, func }\n\nstatic const struct cmd_info {\n\tuint16_t len;\n\tconst char *name;\n\tint (*func)(struct vc4_exec_info *exec, void *validated,\n\t\t    void *untrusted);\n} cmd_info[] = {\n\tVC4_DEFINE_PACKET(VC4_PACKET_HALT, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_NOP, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_FLUSH, validate_flush),\n\tVC4_DEFINE_PACKET(VC4_PACKET_FLUSH_ALL, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_START_TILE_BINNING,\n\t\t\t  validate_start_tile_binning),\n\tVC4_DEFINE_PACKET(VC4_PACKET_INCREMENT_SEMAPHORE,\n\t\t\t  validate_increment_semaphore),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_GL_INDEXED_PRIMITIVE,\n\t\t\t  validate_indexed_prim_list),\n\tVC4_DEFINE_PACKET(VC4_PACKET_GL_ARRAY_PRIMITIVE,\n\t\t\t  validate_gl_array_primitive),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_PRIMITIVE_LIST_FORMAT, NULL),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_GL_SHADER_STATE, validate_gl_shader_state),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_CONFIGURATION_BITS, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_FLAT_SHADE_FLAGS, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_POINT_SIZE, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_LINE_WIDTH, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_RHT_X_BOUNDARY, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_DEPTH_OFFSET, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_CLIP_WINDOW, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_VIEWPORT_OFFSET, NULL),\n\tVC4_DEFINE_PACKET(VC4_PACKET_CLIPPER_XY_SCALING, NULL),\n\t \n\tVC4_DEFINE_PACKET(VC4_PACKET_CLIPPER_Z_SCALING, NULL),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_TILE_BINNING_MODE_CONFIG,\n\t\t\t  validate_tile_binning_config),\n\n\tVC4_DEFINE_PACKET(VC4_PACKET_GEM_HANDLES, validate_gem_handles),\n};\n\nint\nvc4_validate_bin_cl(struct drm_device *dev,\n\t\t    void *validated,\n\t\t    void *unvalidated,\n\t\t    struct vc4_exec_info *exec)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tuint32_t len = exec->args->bin_cl_size;\n\tuint32_t dst_offset = 0;\n\tuint32_t src_offset = 0;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\twhile (src_offset < len) {\n\t\tvoid *dst_pkt = validated + dst_offset;\n\t\tvoid *src_pkt = unvalidated + src_offset;\n\t\tu8 cmd = *(uint8_t *)src_pkt;\n\t\tconst struct cmd_info *info;\n\n\t\tif (cmd >= ARRAY_SIZE(cmd_info)) {\n\t\t\tDRM_DEBUG(\"0x%08x: packet %d out of bounds\\n\",\n\t\t\t\t  src_offset, cmd);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo = &cmd_info[cmd];\n\t\tif (!info->name) {\n\t\t\tDRM_DEBUG(\"0x%08x: packet %d invalid\\n\",\n\t\t\t\t  src_offset, cmd);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (src_offset + info->len > len) {\n\t\t\tDRM_DEBUG(\"0x%08x: packet %d (%s) length 0x%08x \"\n\t\t\t\t  \"exceeds bounds (0x%08x)\\n\",\n\t\t\t\t  src_offset, cmd, info->name, info->len,\n\t\t\t\t  src_offset + len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cmd != VC4_PACKET_GEM_HANDLES)\n\t\t\tmemcpy(dst_pkt, src_pkt, info->len);\n\n\t\tif (info->func && info->func(exec,\n\t\t\t\t\t     dst_pkt + 1,\n\t\t\t\t\t     src_pkt + 1)) {\n\t\t\tDRM_DEBUG(\"0x%08x: packet %d (%s) failed to validate\\n\",\n\t\t\t\t  src_offset, cmd, info->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsrc_offset += info->len;\n\t\t \n\t\tif (cmd != VC4_PACKET_GEM_HANDLES)\n\t\t\tdst_offset += info->len;\n\n\t\t \n\t\tif (cmd == VC4_PACKET_HALT)\n\t\t\tbreak;\n\t}\n\n\texec->ct0ea = exec->ct0ca + dst_offset;\n\n\tif (!exec->found_start_tile_binning_packet) {\n\t\tDRM_DEBUG(\"Bin CL missing VC4_PACKET_START_TILE_BINNING\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!exec->found_increment_semaphore_packet || !exec->found_flush) {\n\t\tDRM_DEBUG(\"Bin CL missing VC4_PACKET_INCREMENT_SEMAPHORE + \"\n\t\t\t  \"VC4_PACKET_FLUSH\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nreloc_tex(struct vc4_exec_info *exec,\n\t  void *uniform_data_u,\n\t  struct vc4_texture_sample_info *sample,\n\t  uint32_t texture_handle_index, bool is_cs)\n{\n\tstruct drm_gem_dma_object *tex;\n\tuint32_t p0 = *(uint32_t *)(uniform_data_u + sample->p_offset[0]);\n\tuint32_t p1 = *(uint32_t *)(uniform_data_u + sample->p_offset[1]);\n\tuint32_t p2 = (sample->p_offset[2] != ~0 ?\n\t\t       *(uint32_t *)(uniform_data_u + sample->p_offset[2]) : 0);\n\tuint32_t p3 = (sample->p_offset[3] != ~0 ?\n\t\t       *(uint32_t *)(uniform_data_u + sample->p_offset[3]) : 0);\n\tuint32_t *validated_p0 = exec->uniforms_v + sample->p_offset[0];\n\tuint32_t offset = p0 & VC4_TEX_P0_OFFSET_MASK;\n\tuint32_t miplevels = VC4_GET_FIELD(p0, VC4_TEX_P0_MIPLVLS);\n\tuint32_t width = VC4_GET_FIELD(p1, VC4_TEX_P1_WIDTH);\n\tuint32_t height = VC4_GET_FIELD(p1, VC4_TEX_P1_HEIGHT);\n\tuint32_t cpp, tiling_format, utile_w, utile_h;\n\tuint32_t i;\n\tuint32_t cube_map_stride = 0;\n\tenum vc4_texture_data_type type;\n\n\ttex = vc4_use_bo(exec, texture_handle_index);\n\tif (!tex)\n\t\treturn false;\n\n\tif (sample->is_direct) {\n\t\tuint32_t remaining_size = tex->base.size - p0;\n\n\t\tif (p0 > tex->base.size - 4) {\n\t\t\tDRM_DEBUG(\"UBO offset greater than UBO size\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (p1 > remaining_size - 4) {\n\t\t\tDRM_DEBUG(\"UBO clamp would allow reads \"\n\t\t\t\t  \"outside of UBO\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\t*validated_p0 = tex->dma_addr + p0;\n\t\treturn true;\n\t}\n\n\tif (width == 0)\n\t\twidth = 2048;\n\tif (height == 0)\n\t\theight = 2048;\n\n\tif (p0 & VC4_TEX_P0_CMMODE_MASK) {\n\t\tif (VC4_GET_FIELD(p2, VC4_TEX_P2_PTYPE) ==\n\t\t    VC4_TEX_P2_PTYPE_CUBE_MAP_STRIDE)\n\t\t\tcube_map_stride = p2 & VC4_TEX_P2_CMST_MASK;\n\t\tif (VC4_GET_FIELD(p3, VC4_TEX_P2_PTYPE) ==\n\t\t    VC4_TEX_P2_PTYPE_CUBE_MAP_STRIDE) {\n\t\t\tif (cube_map_stride) {\n\t\t\t\tDRM_DEBUG(\"Cube map stride set twice\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tcube_map_stride = p3 & VC4_TEX_P2_CMST_MASK;\n\t\t}\n\t\tif (!cube_map_stride) {\n\t\t\tDRM_DEBUG(\"Cube map stride not set\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ttype = (VC4_GET_FIELD(p0, VC4_TEX_P0_TYPE) |\n\t\t(VC4_GET_FIELD(p1, VC4_TEX_P1_TYPE4) << 4));\n\n\tswitch (type) {\n\tcase VC4_TEXTURE_TYPE_RGBA8888:\n\tcase VC4_TEXTURE_TYPE_RGBX8888:\n\tcase VC4_TEXTURE_TYPE_RGBA32R:\n\t\tcpp = 4;\n\t\tbreak;\n\tcase VC4_TEXTURE_TYPE_RGBA4444:\n\tcase VC4_TEXTURE_TYPE_RGBA5551:\n\tcase VC4_TEXTURE_TYPE_RGB565:\n\tcase VC4_TEXTURE_TYPE_LUMALPHA:\n\tcase VC4_TEXTURE_TYPE_S16F:\n\tcase VC4_TEXTURE_TYPE_S16:\n\t\tcpp = 2;\n\t\tbreak;\n\tcase VC4_TEXTURE_TYPE_LUMINANCE:\n\tcase VC4_TEXTURE_TYPE_ALPHA:\n\tcase VC4_TEXTURE_TYPE_S8:\n\t\tcpp = 1;\n\t\tbreak;\n\tcase VC4_TEXTURE_TYPE_ETC1:\n\t\t \n\t\tcpp = 8;\n\t\twidth = (width + 3) >> 2;\n\t\theight = (height + 3) >> 2;\n\t\tbreak;\n\tcase VC4_TEXTURE_TYPE_BW1:\n\tcase VC4_TEXTURE_TYPE_A4:\n\tcase VC4_TEXTURE_TYPE_A1:\n\tcase VC4_TEXTURE_TYPE_RGBA64:\n\tcase VC4_TEXTURE_TYPE_YUV422R:\n\tdefault:\n\t\tDRM_DEBUG(\"Texture format %d unsupported\\n\", type);\n\t\tgoto fail;\n\t}\n\tutile_w = utile_width(cpp);\n\tutile_h = utile_height(cpp);\n\n\tif (type == VC4_TEXTURE_TYPE_RGBA32R) {\n\t\ttiling_format = VC4_TILING_FORMAT_LINEAR;\n\t} else {\n\t\tif (size_is_lt(width, height, cpp))\n\t\t\ttiling_format = VC4_TILING_FORMAT_LT;\n\t\telse\n\t\t\ttiling_format = VC4_TILING_FORMAT_T;\n\t}\n\n\tif (!vc4_check_tex_size(exec, tex, offset + cube_map_stride * 5,\n\t\t\t\ttiling_format, width, height, cpp)) {\n\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 1; i <= miplevels; i++) {\n\t\tuint32_t level_width = max(width >> i, 1u);\n\t\tuint32_t level_height = max(height >> i, 1u);\n\t\tuint32_t aligned_width, aligned_height;\n\t\tuint32_t level_size;\n\n\t\t \n\t\tif (tiling_format == VC4_TILING_FORMAT_T &&\n\t\t    size_is_lt(level_width, level_height, cpp)) {\n\t\t\ttiling_format = VC4_TILING_FORMAT_LT;\n\t\t}\n\n\t\tswitch (tiling_format) {\n\t\tcase VC4_TILING_FORMAT_T:\n\t\t\taligned_width = round_up(level_width, utile_w * 8);\n\t\t\taligned_height = round_up(level_height, utile_h * 8);\n\t\t\tbreak;\n\t\tcase VC4_TILING_FORMAT_LT:\n\t\t\taligned_width = round_up(level_width, utile_w);\n\t\t\taligned_height = round_up(level_height, utile_h);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taligned_width = round_up(level_width, utile_w);\n\t\t\taligned_height = level_height;\n\t\t\tbreak;\n\t\t}\n\n\t\tlevel_size = aligned_width * cpp * aligned_height;\n\n\t\tif (offset < level_size) {\n\t\t\tDRM_DEBUG(\"Level %d (%dx%d -> %dx%d) size %db \"\n\t\t\t\t  \"overflowed buffer bounds (offset %d)\\n\",\n\t\t\t\t  i, level_width, level_height,\n\t\t\t\t  aligned_width, aligned_height,\n\t\t\t\t  level_size, offset);\n\t\t\tgoto fail;\n\t\t}\n\n\t\toffset -= level_size;\n\t}\n\n\t*validated_p0 = tex->dma_addr + p0;\n\n\tif (is_cs) {\n\t\texec->bin_dep_seqno = max(exec->bin_dep_seqno,\n\t\t\t\t\t  to_vc4_bo(&tex->base)->write_seqno);\n\t}\n\n\treturn true;\n fail:\n\tDRM_INFO(\"Texture p0 at %d: 0x%08x\\n\", sample->p_offset[0], p0);\n\tDRM_INFO(\"Texture p1 at %d: 0x%08x\\n\", sample->p_offset[1], p1);\n\tDRM_INFO(\"Texture p2 at %d: 0x%08x\\n\", sample->p_offset[2], p2);\n\tDRM_INFO(\"Texture p3 at %d: 0x%08x\\n\", sample->p_offset[3], p3);\n\treturn false;\n}\n\nstatic int\nvalidate_gl_shader_rec(struct drm_device *dev,\n\t\t       struct vc4_exec_info *exec,\n\t\t       struct vc4_shader_state *state)\n{\n\tuint32_t *src_handles;\n\tvoid *pkt_u, *pkt_v;\n\tstatic const uint32_t shader_reloc_offsets[] = {\n\t\t4,  \n\t\t16,  \n\t\t28,  \n\t};\n\tuint32_t shader_reloc_count = ARRAY_SIZE(shader_reloc_offsets);\n\tstruct drm_gem_dma_object *bo[ARRAY_SIZE(shader_reloc_offsets) + 8];\n\tuint32_t nr_attributes, nr_relocs, packet_size;\n\tint i;\n\n\tnr_attributes = state->addr & 0x7;\n\tif (nr_attributes == 0)\n\t\tnr_attributes = 8;\n\tpacket_size = gl_shader_rec_size(state->addr);\n\n\tnr_relocs = ARRAY_SIZE(shader_reloc_offsets) + nr_attributes;\n\tif (nr_relocs * 4 > exec->shader_rec_size) {\n\t\tDRM_DEBUG(\"overflowed shader recs reading %d handles \"\n\t\t\t  \"from %d bytes left\\n\",\n\t\t\t  nr_relocs, exec->shader_rec_size);\n\t\treturn -EINVAL;\n\t}\n\tsrc_handles = exec->shader_rec_u;\n\texec->shader_rec_u += nr_relocs * 4;\n\texec->shader_rec_size -= nr_relocs * 4;\n\n\tif (packet_size > exec->shader_rec_size) {\n\t\tDRM_DEBUG(\"overflowed shader recs copying %db packet \"\n\t\t\t  \"from %d bytes left\\n\",\n\t\t\t  packet_size, exec->shader_rec_size);\n\t\treturn -EINVAL;\n\t}\n\tpkt_u = exec->shader_rec_u;\n\tpkt_v = exec->shader_rec_v;\n\tmemcpy(pkt_v, pkt_u, packet_size);\n\texec->shader_rec_u += packet_size;\n\t \n\tBUG_ON(roundup(packet_size, 16) - packet_size > nr_relocs * 4);\n\texec->shader_rec_v += roundup(packet_size, 16);\n\texec->shader_rec_size -= packet_size;\n\n\tfor (i = 0; i < shader_reloc_count; i++) {\n\t\tif (src_handles[i] > exec->bo_count) {\n\t\t\tDRM_DEBUG(\"Shader handle %d too big\\n\", src_handles[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbo[i] = to_drm_gem_dma_obj(exec->bo[src_handles[i]]);\n\t\tif (!bo[i])\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = shader_reloc_count; i < nr_relocs; i++) {\n\t\tbo[i] = vc4_use_bo(exec, src_handles[i]);\n\t\tif (!bo[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (((*(uint16_t *)pkt_u & VC4_SHADER_FLAG_FS_SINGLE_THREAD) == 0) !=\n\t    to_vc4_bo(&bo[0]->base)->validated_shader->is_threaded) {\n\t\tDRM_DEBUG(\"Thread mode of CL and FS do not match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (to_vc4_bo(&bo[1]->base)->validated_shader->is_threaded ||\n\t    to_vc4_bo(&bo[2]->base)->validated_shader->is_threaded) {\n\t\tDRM_DEBUG(\"cs and vs cannot be threaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < shader_reloc_count; i++) {\n\t\tstruct vc4_validated_shader_info *validated_shader;\n\t\tuint32_t o = shader_reloc_offsets[i];\n\t\tuint32_t src_offset = *(uint32_t *)(pkt_u + o);\n\t\tuint32_t *texture_handles_u;\n\t\tvoid *uniform_data_u;\n\t\tuint32_t tex, uni;\n\n\t\t*(uint32_t *)(pkt_v + o) = bo[i]->dma_addr + src_offset;\n\n\t\tif (src_offset != 0) {\n\t\t\tDRM_DEBUG(\"Shaders must be at offset 0 of \"\n\t\t\t\t  \"the BO.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvalidated_shader = to_vc4_bo(&bo[i]->base)->validated_shader;\n\t\tif (!validated_shader)\n\t\t\treturn -EINVAL;\n\n\t\tif (validated_shader->uniforms_src_size >\n\t\t    exec->uniforms_size) {\n\t\t\tDRM_DEBUG(\"Uniforms src buffer overflow\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttexture_handles_u = exec->uniforms_u;\n\t\tuniform_data_u = (texture_handles_u +\n\t\t\t\t  validated_shader->num_texture_samples);\n\n\t\tmemcpy(exec->uniforms_v, uniform_data_u,\n\t\t       validated_shader->uniforms_size);\n\n\t\tfor (tex = 0;\n\t\t     tex < validated_shader->num_texture_samples;\n\t\t     tex++) {\n\t\t\tif (!reloc_tex(exec,\n\t\t\t\t       uniform_data_u,\n\t\t\t\t       &validated_shader->texture_samples[tex],\n\t\t\t\t       texture_handles_u[tex],\n\t\t\t\t       i == 2)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (uni = 0;\n\t\t     uni < validated_shader->num_uniform_addr_offsets;\n\t\t     uni++) {\n\t\t\tuint32_t o = validated_shader->uniform_addr_offsets[uni];\n\t\t\t((uint32_t *)exec->uniforms_v)[o] = exec->uniforms_p;\n\t\t}\n\n\t\t*(uint32_t *)(pkt_v + o + 4) = exec->uniforms_p;\n\n\t\texec->uniforms_u += validated_shader->uniforms_src_size;\n\t\texec->uniforms_v += validated_shader->uniforms_size;\n\t\texec->uniforms_p += validated_shader->uniforms_size;\n\t}\n\n\tfor (i = 0; i < nr_attributes; i++) {\n\t\tstruct drm_gem_dma_object *vbo =\n\t\t\tbo[ARRAY_SIZE(shader_reloc_offsets) + i];\n\t\tuint32_t o = 36 + i * 8;\n\t\tuint32_t offset = *(uint32_t *)(pkt_u + o + 0);\n\t\tuint32_t attr_size = *(uint8_t *)(pkt_u + o + 4) + 1;\n\t\tuint32_t stride = *(uint8_t *)(pkt_u + o + 5);\n\t\tuint32_t max_index;\n\n\t\texec->bin_dep_seqno = max(exec->bin_dep_seqno,\n\t\t\t\t\t  to_vc4_bo(&vbo->base)->write_seqno);\n\n\t\tif (state->addr & 0x8)\n\t\t\tstride |= (*(uint32_t *)(pkt_u + 100 + i * 4)) & ~0xff;\n\n\t\tif (vbo->base.size < offset ||\n\t\t    vbo->base.size - offset < attr_size) {\n\t\t\tDRM_DEBUG(\"BO offset overflow (%d + %d > %zu)\\n\",\n\t\t\t\t  offset, attr_size, vbo->base.size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (stride != 0) {\n\t\t\tmax_index = ((vbo->base.size - offset - attr_size) /\n\t\t\t\t     stride);\n\t\t\tif (state->max_index > max_index) {\n\t\t\t\tDRM_DEBUG(\"primitives use index %d out of \"\n\t\t\t\t\t  \"supplied %d\\n\",\n\t\t\t\t\t  state->max_index, max_index);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t*(uint32_t *)(pkt_v + o) = vbo->dma_addr + offset;\n\t}\n\n\treturn 0;\n}\n\nint\nvc4_validate_shader_recs(struct drm_device *dev,\n\t\t\t struct vc4_exec_info *exec)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tuint32_t i;\n\tint ret = 0;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < exec->shader_state_count; i++) {\n\t\tret = validate_gl_shader_rec(dev, exec, &exec->shader_state[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}