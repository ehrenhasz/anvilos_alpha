{
  "module_name": "vc4_render_cl.c",
  "hash_id": "3b43fe8c32dff6bcf6969bf4fca7d6c0b6d1d3ffd8640d868d59aa7ae855538f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_render_cl.c",
  "human_readable_source": " \n\n \n\n#include \"uapi/drm/vc4_drm.h\"\n#include \"vc4_drv.h\"\n#include \"vc4_packet.h\"\n\nstruct vc4_rcl_setup {\n\tstruct drm_gem_dma_object *color_read;\n\tstruct drm_gem_dma_object *color_write;\n\tstruct drm_gem_dma_object *zs_read;\n\tstruct drm_gem_dma_object *zs_write;\n\tstruct drm_gem_dma_object *msaa_color_write;\n\tstruct drm_gem_dma_object *msaa_zs_write;\n\n\tstruct drm_gem_dma_object *rcl;\n\tu32 next_offset;\n\n\tu32 next_write_bo_index;\n};\n\nstatic inline void rcl_u8(struct vc4_rcl_setup *setup, u8 val)\n{\n\t*(u8 *)(setup->rcl->vaddr + setup->next_offset) = val;\n\tsetup->next_offset += 1;\n}\n\nstatic inline void rcl_u16(struct vc4_rcl_setup *setup, u16 val)\n{\n\t*(u16 *)(setup->rcl->vaddr + setup->next_offset) = val;\n\tsetup->next_offset += 2;\n}\n\nstatic inline void rcl_u32(struct vc4_rcl_setup *setup, u32 val)\n{\n\t*(u32 *)(setup->rcl->vaddr + setup->next_offset) = val;\n\tsetup->next_offset += 4;\n}\n\n \nstatic void vc4_store_before_load(struct vc4_rcl_setup *setup)\n{\n\trcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\n\trcl_u16(setup,\n\t\tVC4_SET_FIELD(VC4_LOADSTORE_TILE_BUFFER_NONE,\n\t\t\t      VC4_LOADSTORE_TILE_BUFFER_BUFFER) |\n\t\tVC4_STORE_TILE_BUFFER_DISABLE_COLOR_CLEAR |\n\t\tVC4_STORE_TILE_BUFFER_DISABLE_ZS_CLEAR |\n\t\tVC4_STORE_TILE_BUFFER_DISABLE_VG_MASK_CLEAR);\n\trcl_u32(setup, 0);  \n}\n\n \nstatic uint32_t vc4_full_res_offset(struct vc4_exec_info *exec,\n\t\t\t\t    struct drm_gem_dma_object *bo,\n\t\t\t\t    struct drm_vc4_submit_rcl_surface *surf,\n\t\t\t\t    uint8_t x, uint8_t y)\n{\n\treturn bo->dma_addr + surf->offset + VC4_TILE_BUFFER_SIZE *\n\t\t(DIV_ROUND_UP(exec->args->width, 32) * y + x);\n}\n\n \nstatic void vc4_tile_coordinates(struct vc4_rcl_setup *setup,\n\t\t\t\t uint32_t x, uint32_t y)\n{\n\trcl_u8(setup, VC4_PACKET_TILE_COORDINATES);\n\trcl_u8(setup, x);\n\trcl_u8(setup, y);\n}\n\nstatic void emit_tile(struct vc4_exec_info *exec,\n\t\t      struct vc4_rcl_setup *setup,\n\t\t      uint8_t x, uint8_t y, bool first, bool last)\n{\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tbool has_bin = args->bin_cl_size != 0;\n\n\t \n\tif (setup->color_read) {\n\t\tif (args->color_read.flags &\n\t\t    VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\t\trcl_u8(setup, VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER);\n\t\t\trcl_u32(setup,\n\t\t\t\tvc4_full_res_offset(exec, setup->color_read,\n\t\t\t\t\t\t    &args->color_read, x, y) |\n\t\t\t\tVC4_LOADSTORE_FULL_RES_DISABLE_ZS);\n\t\t} else {\n\t\t\trcl_u8(setup, VC4_PACKET_LOAD_TILE_BUFFER_GENERAL);\n\t\t\trcl_u16(setup, args->color_read.bits);\n\t\t\trcl_u32(setup, setup->color_read->dma_addr +\n\t\t\t\targs->color_read.offset);\n\t\t}\n\t}\n\n\tif (setup->zs_read) {\n\t\tif (setup->color_read) {\n\t\t\t \n\t\t\tvc4_tile_coordinates(setup, x, y);\n\t\t\tvc4_store_before_load(setup);\n\t\t}\n\n\t\tif (args->zs_read.flags &\n\t\t    VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\t\trcl_u8(setup, VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER);\n\t\t\trcl_u32(setup,\n\t\t\t\tvc4_full_res_offset(exec, setup->zs_read,\n\t\t\t\t\t\t    &args->zs_read, x, y) |\n\t\t\t\tVC4_LOADSTORE_FULL_RES_DISABLE_COLOR);\n\t\t} else {\n\t\t\trcl_u8(setup, VC4_PACKET_LOAD_TILE_BUFFER_GENERAL);\n\t\t\trcl_u16(setup, args->zs_read.bits);\n\t\t\trcl_u32(setup, setup->zs_read->dma_addr +\n\t\t\t\targs->zs_read.offset);\n\t\t}\n\t}\n\n\t \n\tvc4_tile_coordinates(setup, x, y);\n\n\t \n\tif (first && has_bin)\n\t\trcl_u8(setup, VC4_PACKET_WAIT_ON_SEMAPHORE);\n\n\tif (has_bin) {\n\t\trcl_u8(setup, VC4_PACKET_BRANCH_TO_SUB_LIST);\n\t\trcl_u32(setup, (exec->tile_alloc_offset +\n\t\t\t\t(y * exec->bin_tiles_x + x) * 32));\n\t}\n\n\tif (setup->msaa_color_write) {\n\t\tbool last_tile_write = (!setup->msaa_zs_write &&\n\t\t\t\t\t!setup->zs_write &&\n\t\t\t\t\t!setup->color_write);\n\t\tuint32_t bits = VC4_LOADSTORE_FULL_RES_DISABLE_ZS;\n\n\t\tif (!last_tile_write)\n\t\t\tbits |= VC4_LOADSTORE_FULL_RES_DISABLE_CLEAR_ALL;\n\t\telse if (last)\n\t\t\tbits |= VC4_LOADSTORE_FULL_RES_EOF;\n\t\trcl_u8(setup, VC4_PACKET_STORE_FULL_RES_TILE_BUFFER);\n\t\trcl_u32(setup,\n\t\t\tvc4_full_res_offset(exec, setup->msaa_color_write,\n\t\t\t\t\t    &args->msaa_color_write, x, y) |\n\t\t\tbits);\n\t}\n\n\tif (setup->msaa_zs_write) {\n\t\tbool last_tile_write = (!setup->zs_write &&\n\t\t\t\t\t!setup->color_write);\n\t\tuint32_t bits = VC4_LOADSTORE_FULL_RES_DISABLE_COLOR;\n\n\t\tif (setup->msaa_color_write)\n\t\t\tvc4_tile_coordinates(setup, x, y);\n\t\tif (!last_tile_write)\n\t\t\tbits |= VC4_LOADSTORE_FULL_RES_DISABLE_CLEAR_ALL;\n\t\telse if (last)\n\t\t\tbits |= VC4_LOADSTORE_FULL_RES_EOF;\n\t\trcl_u8(setup, VC4_PACKET_STORE_FULL_RES_TILE_BUFFER);\n\t\trcl_u32(setup,\n\t\t\tvc4_full_res_offset(exec, setup->msaa_zs_write,\n\t\t\t\t\t    &args->msaa_zs_write, x, y) |\n\t\t\tbits);\n\t}\n\n\tif (setup->zs_write) {\n\t\tbool last_tile_write = !setup->color_write;\n\n\t\tif (setup->msaa_color_write || setup->msaa_zs_write)\n\t\t\tvc4_tile_coordinates(setup, x, y);\n\n\t\trcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\n\t\trcl_u16(setup, args->zs_write.bits |\n\t\t\t(last_tile_write ?\n\t\t\t 0 : VC4_STORE_TILE_BUFFER_DISABLE_COLOR_CLEAR));\n\t\trcl_u32(setup,\n\t\t\t(setup->zs_write->dma_addr + args->zs_write.offset) |\n\t\t\t((last && last_tile_write) ?\n\t\t\t VC4_LOADSTORE_TILE_BUFFER_EOF : 0));\n\t}\n\n\tif (setup->color_write) {\n\t\tif (setup->msaa_color_write || setup->msaa_zs_write ||\n\t\t    setup->zs_write) {\n\t\t\tvc4_tile_coordinates(setup, x, y);\n\t\t}\n\n\t\tif (last)\n\t\t\trcl_u8(setup, VC4_PACKET_STORE_MS_TILE_BUFFER_AND_EOF);\n\t\telse\n\t\t\trcl_u8(setup, VC4_PACKET_STORE_MS_TILE_BUFFER);\n\t}\n}\n\nstatic int vc4_create_rcl_bo(struct drm_device *dev, struct vc4_exec_info *exec,\n\t\t\t     struct vc4_rcl_setup *setup)\n{\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tbool has_bin = args->bin_cl_size != 0;\n\tuint8_t min_x_tile = args->min_x_tile;\n\tuint8_t min_y_tile = args->min_y_tile;\n\tuint8_t max_x_tile = args->max_x_tile;\n\tuint8_t max_y_tile = args->max_y_tile;\n\tuint8_t xtiles = max_x_tile - min_x_tile + 1;\n\tuint8_t ytiles = max_y_tile - min_y_tile + 1;\n\tuint8_t xi, yi;\n\tuint32_t size, loop_body_size;\n\tbool positive_x = true;\n\tbool positive_y = true;\n\n\tif (args->flags & VC4_SUBMIT_CL_FIXED_RCL_ORDER) {\n\t\tif (!(args->flags & VC4_SUBMIT_CL_RCL_ORDER_INCREASING_X))\n\t\t\tpositive_x = false;\n\t\tif (!(args->flags & VC4_SUBMIT_CL_RCL_ORDER_INCREASING_Y))\n\t\t\tpositive_y = false;\n\t}\n\n\tsize = VC4_PACKET_TILE_RENDERING_MODE_CONFIG_SIZE;\n\tloop_body_size = VC4_PACKET_TILE_COORDINATES_SIZE;\n\n\tif (args->flags & VC4_SUBMIT_CL_USE_CLEAR_COLOR) {\n\t\tsize += VC4_PACKET_CLEAR_COLORS_SIZE +\n\t\t\tVC4_PACKET_TILE_COORDINATES_SIZE +\n\t\t\tVC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\n\t}\n\n\tif (setup->color_read) {\n\t\tif (args->color_read.flags &\n\t\t    VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\t\tloop_body_size += VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER_SIZE;\n\t\t} else {\n\t\t\tloop_body_size += VC4_PACKET_LOAD_TILE_BUFFER_GENERAL_SIZE;\n\t\t}\n\t}\n\tif (setup->zs_read) {\n\t\tif (setup->color_read) {\n\t\t\tloop_body_size += VC4_PACKET_TILE_COORDINATES_SIZE;\n\t\t\tloop_body_size += VC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\n\t\t}\n\n\t\tif (args->zs_read.flags &\n\t\t    VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\t\tloop_body_size += VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER_SIZE;\n\t\t} else {\n\t\t\tloop_body_size += VC4_PACKET_LOAD_TILE_BUFFER_GENERAL_SIZE;\n\t\t}\n\t}\n\n\tif (has_bin) {\n\t\tsize += VC4_PACKET_WAIT_ON_SEMAPHORE_SIZE;\n\t\tloop_body_size += VC4_PACKET_BRANCH_TO_SUB_LIST_SIZE;\n\t}\n\n\tif (setup->msaa_color_write)\n\t\tloop_body_size += VC4_PACKET_STORE_FULL_RES_TILE_BUFFER_SIZE;\n\tif (setup->msaa_zs_write)\n\t\tloop_body_size += VC4_PACKET_STORE_FULL_RES_TILE_BUFFER_SIZE;\n\n\tif (setup->zs_write)\n\t\tloop_body_size += VC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\n\tif (setup->color_write)\n\t\tloop_body_size += VC4_PACKET_STORE_MS_TILE_BUFFER_SIZE;\n\n\t \n\tloop_body_size += VC4_PACKET_TILE_COORDINATES_SIZE *\n\t\t((setup->msaa_color_write != NULL) +\n\t\t (setup->msaa_zs_write != NULL) +\n\t\t (setup->color_write != NULL) +\n\t\t (setup->zs_write != NULL) - 1);\n\n\tsize += xtiles * ytiles * loop_body_size;\n\n\tsetup->rcl = &vc4_bo_create(dev, size, true, VC4_BO_TYPE_RCL)->base;\n\tif (IS_ERR(setup->rcl))\n\t\treturn PTR_ERR(setup->rcl);\n\tlist_add_tail(&to_vc4_bo(&setup->rcl->base)->unref_head,\n\t\t      &exec->unref_list);\n\n\t \n\tif (args->flags & VC4_SUBMIT_CL_USE_CLEAR_COLOR) {\n\t\trcl_u8(setup, VC4_PACKET_CLEAR_COLORS);\n\t\trcl_u32(setup, args->clear_color[0]);\n\t\trcl_u32(setup, args->clear_color[1]);\n\t\trcl_u32(setup, args->clear_z);\n\t\trcl_u8(setup, args->clear_s);\n\n\t\tvc4_tile_coordinates(setup, 0, 0);\n\n\t\trcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\n\t\trcl_u16(setup, VC4_LOADSTORE_TILE_BUFFER_NONE);\n\t\trcl_u32(setup, 0);  \n\t}\n\n\trcl_u8(setup, VC4_PACKET_TILE_RENDERING_MODE_CONFIG);\n\trcl_u32(setup,\n\t\t(setup->color_write ? (setup->color_write->dma_addr +\n\t\t\t\t       args->color_write.offset) :\n\t\t 0));\n\trcl_u16(setup, args->width);\n\trcl_u16(setup, args->height);\n\trcl_u16(setup, args->color_write.bits);\n\n\tfor (yi = 0; yi < ytiles; yi++) {\n\t\tint y = positive_y ? min_y_tile + yi : max_y_tile - yi;\n\t\tfor (xi = 0; xi < xtiles; xi++) {\n\t\t\tint x = positive_x ? min_x_tile + xi : max_x_tile - xi;\n\t\t\tbool first = (xi == 0 && yi == 0);\n\t\t\tbool last = (xi == xtiles - 1 && yi == ytiles - 1);\n\n\t\t\temit_tile(exec, setup, x, y, first, last);\n\t\t}\n\t}\n\n\tBUG_ON(setup->next_offset != size);\n\texec->ct1ca = setup->rcl->dma_addr;\n\texec->ct1ea = setup->rcl->dma_addr + setup->next_offset;\n\n\treturn 0;\n}\n\nstatic int vc4_full_res_bounds_check(struct vc4_exec_info *exec,\n\t\t\t\t     struct drm_gem_dma_object *obj,\n\t\t\t\t     struct drm_vc4_submit_rcl_surface *surf)\n{\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tu32 render_tiles_stride = DIV_ROUND_UP(exec->args->width, 32);\n\n\tif (surf->offset > obj->base.size) {\n\t\tDRM_DEBUG(\"surface offset %d > BO size %zd\\n\",\n\t\t\t  surf->offset, obj->base.size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((obj->base.size - surf->offset) / VC4_TILE_BUFFER_SIZE <\n\t    render_tiles_stride * args->max_y_tile + args->max_x_tile) {\n\t\tDRM_DEBUG(\"MSAA tile %d, %d out of bounds \"\n\t\t\t  \"(bo size %zd, offset %d).\\n\",\n\t\t\t  args->max_x_tile, args->max_y_tile,\n\t\t\t  obj->base.size,\n\t\t\t  surf->offset);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_rcl_msaa_surface_setup(struct vc4_exec_info *exec,\n\t\t\t\t      struct drm_gem_dma_object **obj,\n\t\t\t\t      struct drm_vc4_submit_rcl_surface *surf)\n{\n\tif (surf->flags != 0 || surf->bits != 0) {\n\t\tDRM_DEBUG(\"MSAA surface had nonzero flags/bits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (surf->hindex == ~0)\n\t\treturn 0;\n\n\t*obj = vc4_use_bo(exec, surf->hindex);\n\tif (!*obj)\n\t\treturn -EINVAL;\n\n\texec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\n\n\tif (surf->offset & 0xf) {\n\t\tDRM_DEBUG(\"MSAA write must be 16b aligned.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vc4_full_res_bounds_check(exec, *obj, surf);\n}\n\nstatic int vc4_rcl_surface_setup(struct vc4_exec_info *exec,\n\t\t\t\t struct drm_gem_dma_object **obj,\n\t\t\t\t struct drm_vc4_submit_rcl_surface *surf,\n\t\t\t\t bool is_write)\n{\n\tuint8_t tiling = VC4_GET_FIELD(surf->bits,\n\t\t\t\t       VC4_LOADSTORE_TILE_BUFFER_TILING);\n\tuint8_t buffer = VC4_GET_FIELD(surf->bits,\n\t\t\t\t       VC4_LOADSTORE_TILE_BUFFER_BUFFER);\n\tuint8_t format = VC4_GET_FIELD(surf->bits,\n\t\t\t\t       VC4_LOADSTORE_TILE_BUFFER_FORMAT);\n\tint cpp;\n\tint ret;\n\n\tif (surf->flags & ~VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\tDRM_DEBUG(\"Extra flags set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (surf->hindex == ~0)\n\t\treturn 0;\n\n\t*obj = vc4_use_bo(exec, surf->hindex);\n\tif (!*obj)\n\t\treturn -EINVAL;\n\n\tif (is_write)\n\t\texec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\n\n\tif (surf->flags & VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\n\t\tif (surf == &exec->args->zs_write) {\n\t\t\tDRM_DEBUG(\"general zs write may not be a full-res.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (surf->bits != 0) {\n\t\t\tDRM_DEBUG(\"load/store general bits set with \"\n\t\t\t\t  \"full res load/store.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = vc4_full_res_bounds_check(exec, *obj, surf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\t}\n\n\tif (surf->bits & ~(VC4_LOADSTORE_TILE_BUFFER_TILING_MASK |\n\t\t\t   VC4_LOADSTORE_TILE_BUFFER_BUFFER_MASK |\n\t\t\t   VC4_LOADSTORE_TILE_BUFFER_FORMAT_MASK)) {\n\t\tDRM_DEBUG(\"Unknown bits in load/store: 0x%04x\\n\",\n\t\t\t  surf->bits);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tiling > VC4_TILING_FORMAT_LT) {\n\t\tDRM_DEBUG(\"Bad tiling format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer == VC4_LOADSTORE_TILE_BUFFER_ZS) {\n\t\tif (format != 0) {\n\t\t\tDRM_DEBUG(\"No color format should be set for ZS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcpp = 4;\n\t} else if (buffer == VC4_LOADSTORE_TILE_BUFFER_COLOR) {\n\t\tswitch (format) {\n\t\tcase VC4_LOADSTORE_TILE_BUFFER_BGR565:\n\t\tcase VC4_LOADSTORE_TILE_BUFFER_BGR565_DITHER:\n\t\t\tcpp = 2;\n\t\t\tbreak;\n\t\tcase VC4_LOADSTORE_TILE_BUFFER_RGBA8888:\n\t\t\tcpp = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Bad tile buffer format\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tDRM_DEBUG(\"Bad load/store buffer %d.\\n\", buffer);\n\t\treturn -EINVAL;\n\t}\n\n\tif (surf->offset & 0xf) {\n\t\tDRM_DEBUG(\"load/store buffer must be 16b aligned.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vc4_check_tex_size(exec, *obj, surf->offset, tiling,\n\t\t\t\texec->args->width, exec->args->height, cpp)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvc4_rcl_render_config_surface_setup(struct vc4_exec_info *exec,\n\t\t\t\t    struct vc4_rcl_setup *setup,\n\t\t\t\t    struct drm_gem_dma_object **obj,\n\t\t\t\t    struct drm_vc4_submit_rcl_surface *surf)\n{\n\tuint8_t tiling = VC4_GET_FIELD(surf->bits,\n\t\t\t\t       VC4_RENDER_CONFIG_MEMORY_FORMAT);\n\tuint8_t format = VC4_GET_FIELD(surf->bits,\n\t\t\t\t       VC4_RENDER_CONFIG_FORMAT);\n\tint cpp;\n\n\tif (surf->flags != 0) {\n\t\tDRM_DEBUG(\"No flags supported on render config.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (surf->bits & ~(VC4_RENDER_CONFIG_MEMORY_FORMAT_MASK |\n\t\t\t   VC4_RENDER_CONFIG_FORMAT_MASK |\n\t\t\t   VC4_RENDER_CONFIG_MS_MODE_4X |\n\t\t\t   VC4_RENDER_CONFIG_DECIMATE_MODE_4X)) {\n\t\tDRM_DEBUG(\"Unknown bits in render config: 0x%04x\\n\",\n\t\t\t  surf->bits);\n\t\treturn -EINVAL;\n\t}\n\n\tif (surf->hindex == ~0)\n\t\treturn 0;\n\n\t*obj = vc4_use_bo(exec, surf->hindex);\n\tif (!*obj)\n\t\treturn -EINVAL;\n\n\texec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\n\n\tif (tiling > VC4_TILING_FORMAT_LT) {\n\t\tDRM_DEBUG(\"Bad tiling format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format) {\n\tcase VC4_RENDER_CONFIG_FORMAT_BGR565_DITHERED:\n\tcase VC4_RENDER_CONFIG_FORMAT_BGR565:\n\t\tcpp = 2;\n\t\tbreak;\n\tcase VC4_RENDER_CONFIG_FORMAT_RGBA8888:\n\t\tcpp = 4;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"Bad tile buffer format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vc4_check_tex_size(exec, *obj, surf->offset, tiling,\n\t\t\t\texec->args->width, exec->args->height, cpp)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vc4_get_rcl(struct drm_device *dev, struct vc4_exec_info *exec)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_rcl_setup setup = {0};\n\tstruct drm_vc4_submit_cl *args = exec->args;\n\tbool has_bin = args->bin_cl_size != 0;\n\tint ret;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (args->min_x_tile > args->max_x_tile ||\n\t    args->min_y_tile > args->max_y_tile) {\n\t\tDRM_DEBUG(\"Bad render tile set (%d,%d)-(%d,%d)\\n\",\n\t\t\t  args->min_x_tile, args->min_y_tile,\n\t\t\t  args->max_x_tile, args->max_y_tile);\n\t\treturn -EINVAL;\n\t}\n\n\tif (has_bin &&\n\t    (args->max_x_tile > exec->bin_tiles_x ||\n\t     args->max_y_tile > exec->bin_tiles_y)) {\n\t\tDRM_DEBUG(\"Render tiles (%d,%d) outside of bin config \"\n\t\t\t  \"(%d,%d)\\n\",\n\t\t\t  args->max_x_tile, args->max_y_tile,\n\t\t\t  exec->bin_tiles_x, exec->bin_tiles_y);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vc4_rcl_render_config_surface_setup(exec, &setup,\n\t\t\t\t\t\t  &setup.color_write,\n\t\t\t\t\t\t  &args->color_write);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_rcl_surface_setup(exec, &setup.color_read, &args->color_read,\n\t\t\t\t    false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_rcl_surface_setup(exec, &setup.zs_read, &args->zs_read,\n\t\t\t\t    false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_rcl_surface_setup(exec, &setup.zs_write, &args->zs_write,\n\t\t\t\t    true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_rcl_msaa_surface_setup(exec, &setup.msaa_color_write,\n\t\t\t\t\t &args->msaa_color_write);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vc4_rcl_msaa_surface_setup(exec, &setup.msaa_zs_write,\n\t\t\t\t\t &args->msaa_zs_write);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!setup.color_write && !setup.zs_write &&\n\t    !setup.msaa_color_write && !setup.msaa_zs_write) {\n\t\tDRM_DEBUG(\"RCL requires color or Z/S write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vc4_create_rcl_bo(dev, exec, &setup);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}