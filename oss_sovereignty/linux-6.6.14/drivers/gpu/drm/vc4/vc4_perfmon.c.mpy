{
  "module_name": "vc4_perfmon.c",
  "hash_id": "cc8cb59ab56549a493c89b289818c5b2ab38b60c95b8b0d9070e7e766fac8d33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_perfmon.c",
  "human_readable_source": "\n \n\n \n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n#define VC4_PERFMONID_MIN\t1\n#define VC4_PERFMONID_MAX\tU32_MAX\n\nvoid vc4_perfmon_get(struct vc4_perfmon *perfmon)\n{\n\tstruct vc4_dev *vc4;\n\n\tif (!perfmon)\n\t\treturn;\n\n\tvc4 = perfmon->dev;\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\trefcount_inc(&perfmon->refcnt);\n}\n\nvoid vc4_perfmon_put(struct vc4_perfmon *perfmon)\n{\n\tstruct vc4_dev *vc4;\n\n\tif (!perfmon)\n\t\treturn;\n\n\tvc4 = perfmon->dev;\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (refcount_dec_and_test(&perfmon->refcnt))\n\t\tkfree(perfmon);\n}\n\nvoid vc4_perfmon_start(struct vc4_dev *vc4, struct vc4_perfmon *perfmon)\n{\n\tunsigned int i;\n\tu32 mask;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!perfmon || vc4->active_perfmon))\n\t\treturn;\n\n\tfor (i = 0; i < perfmon->ncounters; i++)\n\t\tV3D_WRITE(V3D_PCTRS(i), perfmon->events[i]);\n\n\tmask = GENMASK(perfmon->ncounters - 1, 0);\n\tV3D_WRITE(V3D_PCTRC, mask);\n\tV3D_WRITE(V3D_PCTRE, V3D_PCTRE_EN | mask);\n\tvc4->active_perfmon = perfmon;\n}\n\nvoid vc4_perfmon_stop(struct vc4_dev *vc4, struct vc4_perfmon *perfmon,\n\t\t      bool capture)\n{\n\tunsigned int i;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!vc4->active_perfmon ||\n\t\t\t perfmon != vc4->active_perfmon))\n\t\treturn;\n\n\tif (capture) {\n\t\tfor (i = 0; i < perfmon->ncounters; i++)\n\t\t\tperfmon->counters[i] += V3D_READ(V3D_PCTR(i));\n\t}\n\n\tV3D_WRITE(V3D_PCTRE, 0);\n\tvc4->active_perfmon = NULL;\n}\n\nstruct vc4_perfmon *vc4_perfmon_find(struct vc4_file *vc4file, int id)\n{\n\tstruct vc4_dev *vc4 = vc4file->dev;\n\tstruct vc4_perfmon *perfmon;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn NULL;\n\n\tmutex_lock(&vc4file->perfmon.lock);\n\tperfmon = idr_find(&vc4file->perfmon.idr, id);\n\tvc4_perfmon_get(perfmon);\n\tmutex_unlock(&vc4file->perfmon.lock);\n\n\treturn perfmon;\n}\n\nvoid vc4_perfmon_open_file(struct vc4_file *vc4file)\n{\n\tstruct vc4_dev *vc4 = vc4file->dev;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tmutex_init(&vc4file->perfmon.lock);\n\tidr_init_base(&vc4file->perfmon.idr, VC4_PERFMONID_MIN);\n\tvc4file->dev = vc4;\n}\n\nstatic int vc4_perfmon_idr_del(int id, void *elem, void *data)\n{\n\tstruct vc4_perfmon *perfmon = elem;\n\n\tvc4_perfmon_put(perfmon);\n\n\treturn 0;\n}\n\nvoid vc4_perfmon_close_file(struct vc4_file *vc4file)\n{\n\tstruct vc4_dev *vc4 = vc4file->dev;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tmutex_lock(&vc4file->perfmon.lock);\n\tidr_for_each(&vc4file->perfmon.idr, vc4_perfmon_idr_del, NULL);\n\tidr_destroy(&vc4file->perfmon.idr);\n\tmutex_unlock(&vc4file->perfmon.lock);\n\tmutex_destroy(&vc4file->perfmon.lock);\n}\n\nint vc4_perfmon_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_file *vc4file = file_priv->driver_priv;\n\tstruct drm_vc4_perfmon_create *req = data;\n\tstruct vc4_perfmon *perfmon;\n\tunsigned int i;\n\tint ret;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (!vc4->v3d) {\n\t\tDRM_DEBUG(\"Creating perfmon no VC4 V3D probed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (req->ncounters > DRM_VC4_MAX_PERF_COUNTERS ||\n\t    !req->ncounters)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < req->ncounters; i++) {\n\t\tif (req->events[i] >= VC4_PERFCNT_NUM_EVENTS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tperfmon = kzalloc(struct_size(perfmon, counters, req->ncounters),\n\t\t\t  GFP_KERNEL);\n\tif (!perfmon)\n\t\treturn -ENOMEM;\n\tperfmon->dev = vc4;\n\n\tfor (i = 0; i < req->ncounters; i++)\n\t\tperfmon->events[i] = req->events[i];\n\n\tperfmon->ncounters = req->ncounters;\n\n\trefcount_set(&perfmon->refcnt, 1);\n\n\tmutex_lock(&vc4file->perfmon.lock);\n\tret = idr_alloc(&vc4file->perfmon.idr, perfmon, VC4_PERFMONID_MIN,\n\t\t\tVC4_PERFMONID_MAX, GFP_KERNEL);\n\tmutex_unlock(&vc4file->perfmon.lock);\n\n\tif (ret < 0) {\n\t\tkfree(perfmon);\n\t\treturn ret;\n\t}\n\n\treq->id = ret;\n\treturn 0;\n}\n\nint vc4_perfmon_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_file *vc4file = file_priv->driver_priv;\n\tstruct drm_vc4_perfmon_destroy *req = data;\n\tstruct vc4_perfmon *perfmon;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (!vc4->v3d) {\n\t\tDRM_DEBUG(\"Destroying perfmon no VC4 V3D probed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&vc4file->perfmon.lock);\n\tperfmon = idr_remove(&vc4file->perfmon.idr, req->id);\n\tmutex_unlock(&vc4file->perfmon.lock);\n\n\tif (!perfmon)\n\t\treturn -EINVAL;\n\n\tvc4_perfmon_put(perfmon);\n\treturn 0;\n}\n\nint vc4_perfmon_get_values_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_file *vc4file = file_priv->driver_priv;\n\tstruct drm_vc4_perfmon_get_values *req = data;\n\tstruct vc4_perfmon *perfmon;\n\tint ret;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (!vc4->v3d) {\n\t\tDRM_DEBUG(\"Getting perfmon no VC4 V3D probed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&vc4file->perfmon.lock);\n\tperfmon = idr_find(&vc4file->perfmon.idr, req->id);\n\tvc4_perfmon_get(perfmon);\n\tmutex_unlock(&vc4file->perfmon.lock);\n\n\tif (!perfmon)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(u64_to_user_ptr(req->values_ptr), perfmon->counters,\n\t\t\t perfmon->ncounters * sizeof(u64)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n\n\tvc4_perfmon_put(perfmon);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}