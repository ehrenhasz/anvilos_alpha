{
  "module_name": "vc4_dpi.c",
  "hash_id": "2c661d1004c2e09b541383b616be6e50dc9dec0e651bb689170721d705c4e6e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_dpi.c",
  "human_readable_source": "\n \n\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/media-bus-format.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n#define DPI_C\t\t\t0x00\n# define DPI_OUTPUT_ENABLE_MODE\t\tBIT(16)\n\n \n# define DPI_ORDER_MASK\t\t\tVC4_MASK(15, 14)\n# define DPI_ORDER_SHIFT\t\t14\n# define DPI_ORDER_RGB\t\t\t0\n# define DPI_ORDER_BGR\t\t\t1\n# define DPI_ORDER_GRB\t\t\t2\n# define DPI_ORDER_BRG\t\t\t3\n\n \n# define DPI_FORMAT_MASK\t\tVC4_MASK(13, 11)\n# define DPI_FORMAT_SHIFT\t\t11\n \n# define DPI_FORMAT_9BIT_666_RGB\t0\n \n# define DPI_FORMAT_16BIT_565_RGB_1\t1\n \n# define DPI_FORMAT_16BIT_565_RGB_2\t2\n \n# define DPI_FORMAT_16BIT_565_RGB_3\t3\n \n# define DPI_FORMAT_18BIT_666_RGB_1\t4\n \n# define DPI_FORMAT_18BIT_666_RGB_2\t5\n \n# define DPI_FORMAT_24BIT_888_RGB\t6\n\n \n# define DPI_PIXEL_CLK_INVERT\t\tBIT(10)\n# define DPI_HSYNC_INVERT\t\tBIT(9)\n# define DPI_VSYNC_INVERT\t\tBIT(8)\n# define DPI_OUTPUT_ENABLE_INVERT\tBIT(7)\n\n \n# define DPI_HSYNC_NEGATE\t\tBIT(6)\n# define DPI_VSYNC_NEGATE\t\tBIT(5)\n# define DPI_OUTPUT_ENABLE_NEGATE\tBIT(4)\n\n \n# define DPI_HSYNC_DISABLE\t\tBIT(3)\n# define DPI_VSYNC_DISABLE\t\tBIT(2)\n# define DPI_OUTPUT_ENABLE_DISABLE\tBIT(1)\n\n \n# define DPI_ENABLE\t\t\tBIT(0)\n\n \n#define DPI_ID\t\t\t0x04\n# define DPI_ID_VALUE\t\t0x00647069\n\n \nstruct vc4_dpi {\n\tstruct vc4_encoder encoder;\n\n\tstruct platform_device *pdev;\n\n\tvoid __iomem *regs;\n\n\tstruct clk *pixel_clock;\n\tstruct clk *core_clock;\n\n\tstruct debugfs_regset32 regset;\n};\n\n#define to_vc4_dpi(_encoder)\t\t\t\t\t\t\\\n\tcontainer_of_const(_encoder, struct vc4_dpi, encoder.base)\n\n#define DPI_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(dpi->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define DPI_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, dpi->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\nstatic const struct debugfs_reg32 dpi_regs[] = {\n\tVC4_REG32(DPI_C),\n\tVC4_REG32(DPI_ID),\n};\n\nstatic void vc4_dpi_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct vc4_dpi *dpi = to_vc4_dpi(encoder);\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\tclk_disable_unprepare(dpi->pixel_clock);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_dpi_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_display_mode *mode = &encoder->crtc->mode;\n\tstruct vc4_dpi *dpi = to_vc4_dpi(encoder);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector = NULL, *connector_scan;\n\tu32 dpi_c = DPI_ENABLE;\n\tint idx;\n\tint ret;\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector_scan, &conn_iter) {\n\t\tif (connector_scan->encoder == encoder) {\n\t\t\tconnector = connector_scan;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_18BIT_666_RGB_1, DPI_FORMAT);\n\n\tif (connector) {\n\t\tif (connector->display_info.num_bus_formats) {\n\t\t\tu32 bus_format = connector->display_info.bus_formats[0];\n\n\t\t\tdpi_c &= ~DPI_FORMAT_MASK;\n\n\t\t\tswitch (bus_format) {\n\t\t\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_24BIT_888_RGB,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_24BIT_888_RGB,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_ORDER_BGR,\n\t\t\t\t\t\t       DPI_ORDER);\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_BGR666_1X24_CPADHI:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_ORDER_BGR, DPI_ORDER);\n\t\t\t\tfallthrough;\n\t\t\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_18BIT_666_RGB_2,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_BGR666_1X18:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_ORDER_BGR, DPI_ORDER);\n\t\t\t\tfallthrough;\n\t\t\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_18BIT_666_RGB_1,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_16BIT_565_RGB_1,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_RGB565_1X24_CPADHI:\n\t\t\t\tdpi_c |= VC4_SET_FIELD(DPI_FORMAT_16BIT_565_RGB_2,\n\t\t\t\t\t\t       DPI_FORMAT);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown media bus format %d\\n\",\n\t\t\t\t\t  bus_format);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (connector->display_info.bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\t\tdpi_c |= DPI_PIXEL_CLK_INVERT;\n\n\t\tif (connector->display_info.bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\t\tdpi_c |= DPI_OUTPUT_ENABLE_INVERT;\n\t}\n\n\tif (mode->flags & DRM_MODE_FLAG_CSYNC) {\n\t\tif (mode->flags & DRM_MODE_FLAG_NCSYNC)\n\t\t\tdpi_c |= DPI_OUTPUT_ENABLE_INVERT;\n\t} else {\n\t\tdpi_c |= DPI_OUTPUT_ENABLE_MODE;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\t\tdpi_c |= DPI_HSYNC_INVERT;\n\t\telse if (!(mode->flags & DRM_MODE_FLAG_PHSYNC))\n\t\t\tdpi_c |= DPI_HSYNC_DISABLE;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tdpi_c |= DPI_VSYNC_INVERT;\n\t\telse if (!(mode->flags & DRM_MODE_FLAG_PVSYNC))\n\t\t\tdpi_c |= DPI_VSYNC_DISABLE;\n\t}\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\tDPI_WRITE(DPI_C, dpi_c);\n\n\tret = clk_set_rate(dpi->pixel_clock, mode->clock * 1000);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to set clock rate: %d\\n\", ret);\n\n\tret = clk_prepare_enable(dpi->pixel_clock);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to set clock rate: %d\\n\", ret);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic enum drm_mode_status vc4_dpi_encoder_mode_valid(struct drm_encoder *encoder,\n\t\t\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_encoder_helper_funcs vc4_dpi_encoder_helper_funcs = {\n\t.disable = vc4_dpi_encoder_disable,\n\t.enable = vc4_dpi_encoder_enable,\n\t.mode_valid = vc4_dpi_encoder_mode_valid,\n};\n\nstatic int vc4_dpi_late_register(struct drm_encoder *encoder)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_dpi *dpi = to_vc4_dpi(encoder);\n\n\tvc4_debugfs_add_regset32(drm, \"dpi_regs\", &dpi->regset);\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs vc4_dpi_encoder_funcs = {\n\t.late_register = vc4_dpi_late_register,\n};\n\nstatic const struct of_device_id vc4_dpi_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-dpi\", .data = NULL },\n\t{}\n};\n\n \nstatic int vc4_dpi_init_bridge(struct vc4_dpi *dpi)\n{\n\tstruct drm_device *drm = dpi->encoder.base.dev;\n\tstruct device *dev = &dpi->pdev->dev;\n\tstruct drm_bridge *bridge;\n\n\tbridge = drmm_of_get_bridge(drm, dev->of_node, 0, 0);\n\tif (IS_ERR(bridge)) {\n\t\t \n\t\tif (PTR_ERR(bridge) == -ENODEV)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\treturn drm_bridge_attach(&dpi->encoder.base, bridge, NULL, 0);\n}\n\nstatic void vc4_dpi_disable_clock(void *ptr)\n{\n\tstruct vc4_dpi *dpi = ptr;\n\n\tclk_disable_unprepare(dpi->core_clock);\n}\n\nstatic int vc4_dpi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dpi *dpi;\n\tint ret;\n\n\tdpi = drmm_kzalloc(drm, sizeof(*dpi), GFP_KERNEL);\n\tif (!dpi)\n\t\treturn -ENOMEM;\n\n\tdpi->encoder.type = VC4_ENCODER_TYPE_DPI;\n\tdpi->pdev = pdev;\n\tdpi->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(dpi->regs))\n\t\treturn PTR_ERR(dpi->regs);\n\tdpi->regset.base = dpi->regs;\n\tdpi->regset.regs = dpi_regs;\n\tdpi->regset.nregs = ARRAY_SIZE(dpi_regs);\n\n\tif (DPI_READ(DPI_ID) != DPI_ID_VALUE) {\n\t\tdev_err(dev, \"Port returned 0x%08x for ID instead of 0x%08x\\n\",\n\t\t\tDPI_READ(DPI_ID), DPI_ID_VALUE);\n\t\treturn -ENODEV;\n\t}\n\n\tdpi->core_clock = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(dpi->core_clock)) {\n\t\tret = PTR_ERR(dpi->core_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get core clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdpi->pixel_clock = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(dpi->pixel_clock)) {\n\t\tret = PTR_ERR(dpi->pixel_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get pixel clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dpi->core_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on core clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, vc4_dpi_disable_clock, dpi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_encoder_init(drm, &dpi->encoder.base,\n\t\t\t\t&vc4_dpi_encoder_funcs,\n\t\t\t\tDRM_MODE_ENCODER_DPI,\n\t\t\t\tNULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_encoder_helper_add(&dpi->encoder.base, &vc4_dpi_encoder_helper_funcs);\n\n\tret = vc4_dpi_init_bridge(dpi);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, dpi);\n\n\treturn 0;\n}\n\nstatic const struct component_ops vc4_dpi_ops = {\n\t.bind   = vc4_dpi_bind,\n};\n\nstatic int vc4_dpi_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_dpi_ops);\n}\n\nstatic void vc4_dpi_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_dpi_ops);\n}\n\nstruct platform_driver vc4_dpi_driver = {\n\t.probe = vc4_dpi_dev_probe,\n\t.remove_new = vc4_dpi_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_dpi\",\n\t\t.of_match_table = vc4_dpi_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}