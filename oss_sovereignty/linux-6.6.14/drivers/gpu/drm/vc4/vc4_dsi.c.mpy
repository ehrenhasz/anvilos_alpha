{
  "module_name": "vc4_dsi.c",
  "hash_id": "a0578e640f56a68a0faf5c6073d5bc0005e8a80de2754490e849b52ee8f13708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_dsi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/component.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n#define DSI_CMD_FIFO_DEPTH  16\n#define DSI_PIX_FIFO_DEPTH 256\n#define DSI_PIX_FIFO_WIDTH   4\n\n#define DSI0_CTRL\t\t0x00\n\n \n#define DSI0_TXPKT1C\t\t0x04  \n#define DSI1_TXPKT1C\t\t0x04\n# define DSI_TXPKT1C_TRIG_CMD_MASK\tVC4_MASK(31, 24)\n# define DSI_TXPKT1C_TRIG_CMD_SHIFT\t24\n# define DSI_TXPKT1C_CMD_REPEAT_MASK\tVC4_MASK(23, 10)\n# define DSI_TXPKT1C_CMD_REPEAT_SHIFT\t10\n\n# define DSI_TXPKT1C_DISPLAY_NO_MASK\tVC4_MASK(9, 8)\n# define DSI_TXPKT1C_DISPLAY_NO_SHIFT\t8\n \n# define DSI_TXPKT1C_DISPLAY_NO_SHORT\t\t0\n \n# define DSI_TXPKT1C_DISPLAY_NO_PRIMARY\t\t1\n \n# define DSI_TXPKT1C_DISPLAY_NO_SECONDARY\t2\n\n# define DSI_TXPKT1C_CMD_TX_TIME_MASK\tVC4_MASK(7, 6)\n# define DSI_TXPKT1C_CMD_TX_TIME_SHIFT\t6\n\n# define DSI_TXPKT1C_CMD_CTRL_MASK\tVC4_MASK(5, 4)\n# define DSI_TXPKT1C_CMD_CTRL_SHIFT\t4\n \n# define DSI_TXPKT1C_CMD_CTRL_TX\t0\n \n# define DSI_TXPKT1C_CMD_CTRL_RX\t1\n \n# define DSI_TXPKT1C_CMD_CTRL_TRIG\t2\n \n# define DSI_TXPKT1C_CMD_CTRL_BTA\t3\n\n# define DSI_TXPKT1C_CMD_MODE_LP\tBIT(3)\n# define DSI_TXPKT1C_CMD_TYPE_LONG\tBIT(2)\n# define DSI_TXPKT1C_CMD_TE_EN\t\tBIT(1)\n# define DSI_TXPKT1C_CMD_EN\t\tBIT(0)\n\n \n#define DSI0_TXPKT1H\t\t0x08  \n#define DSI1_TXPKT1H\t\t0x08\n# define DSI_TXPKT1H_BC_CMDFIFO_MASK\tVC4_MASK(31, 24)\n# define DSI_TXPKT1H_BC_CMDFIFO_SHIFT\t24\n# define DSI_TXPKT1H_BC_PARAM_MASK\tVC4_MASK(23, 8)\n# define DSI_TXPKT1H_BC_PARAM_SHIFT\t8\n# define DSI_TXPKT1H_BC_DT_MASK\t\tVC4_MASK(7, 0)\n# define DSI_TXPKT1H_BC_DT_SHIFT\t0\n\n#define DSI0_RXPKT1H\t\t0x0c  \n#define DSI1_RXPKT1H\t\t0x14\n# define DSI_RXPKT1H_CRC_ERR\t\tBIT(31)\n# define DSI_RXPKT1H_DET_ERR\t\tBIT(30)\n# define DSI_RXPKT1H_ECC_ERR\t\tBIT(29)\n# define DSI_RXPKT1H_COR_ERR\t\tBIT(28)\n# define DSI_RXPKT1H_INCOMP_PKT\t\tBIT(25)\n# define DSI_RXPKT1H_PKT_TYPE_LONG\tBIT(24)\n \n# define DSI_RXPKT1H_BC_PARAM_MASK\tVC4_MASK(23, 8)\n# define DSI_RXPKT1H_BC_PARAM_SHIFT\t8\n \n# define DSI_RXPKT1H_SHORT_1_MASK\tVC4_MASK(23, 16)\n# define DSI_RXPKT1H_SHORT_1_SHIFT\t16\n# define DSI_RXPKT1H_SHORT_0_MASK\tVC4_MASK(15, 8)\n# define DSI_RXPKT1H_SHORT_0_SHIFT\t8\n# define DSI_RXPKT1H_DT_LP_CMD_MASK\tVC4_MASK(7, 0)\n# define DSI_RXPKT1H_DT_LP_CMD_SHIFT\t0\n\n#define DSI0_RXPKT2H\t\t0x10  \n#define DSI1_RXPKT2H\t\t0x18\n# define DSI_RXPKT1H_DET_ERR\t\tBIT(30)\n# define DSI_RXPKT1H_ECC_ERR\t\tBIT(29)\n# define DSI_RXPKT1H_COR_ERR\t\tBIT(28)\n# define DSI_RXPKT1H_INCOMP_PKT\t\tBIT(25)\n# define DSI_RXPKT1H_BC_PARAM_MASK\tVC4_MASK(23, 8)\n# define DSI_RXPKT1H_BC_PARAM_SHIFT\t8\n# define DSI_RXPKT1H_DT_MASK\t\tVC4_MASK(7, 0)\n# define DSI_RXPKT1H_DT_SHIFT\t\t0\n\n#define DSI0_TXPKT_CMD_FIFO\t0x14  \n#define DSI1_TXPKT_CMD_FIFO\t0x1c\n\n#define DSI0_DISP0_CTRL\t\t0x18\n# define DSI_DISP0_PIX_CLK_DIV_MASK\tVC4_MASK(21, 13)\n# define DSI_DISP0_PIX_CLK_DIV_SHIFT\t13\n# define DSI_DISP0_LP_STOP_CTRL_MASK\tVC4_MASK(12, 11)\n# define DSI_DISP0_LP_STOP_CTRL_SHIFT\t11\n# define DSI_DISP0_LP_STOP_DISABLE\t0\n# define DSI_DISP0_LP_STOP_PERLINE\t1\n# define DSI_DISP0_LP_STOP_PERFRAME\t2\n\n \n# define DSI_DISP_HACTIVE_NULL\t\tBIT(10)\n \n# define DSI_DISP_VBLP_CTRL\t\tBIT(9)\n \n# define DSI_DISP_HFP_CTRL\t\tBIT(8)\n \n# define DSI_DISP_HBP_CTRL\t\tBIT(7)\n# define DSI_DISP0_CHANNEL_MASK\t\tVC4_MASK(6, 5)\n# define DSI_DISP0_CHANNEL_SHIFT\t5\n \n# define DSI_DISP0_ST_END\t\tBIT(4)\n# define DSI_DISP0_PFORMAT_MASK\t\tVC4_MASK(3, 2)\n# define DSI_DISP0_PFORMAT_SHIFT\t2\n# define DSI_PFORMAT_RGB565\t\t0\n# define DSI_PFORMAT_RGB666_PACKED\t1\n# define DSI_PFORMAT_RGB666\t\t2\n# define DSI_PFORMAT_RGB888\t\t3\n \n# define DSI_DISP0_COMMAND_MODE\t\tBIT(1)\n# define DSI_DISP0_ENABLE\t\tBIT(0)\n\n#define DSI0_DISP1_CTRL\t\t0x1c\n#define DSI1_DISP1_CTRL\t\t0x2c\n \n# define DSI_DISP1_PFORMAT_MASK\t\tVC4_MASK(2, 1)\n# define DSI_DISP1_PFORMAT_SHIFT\t1\n# define DSI_DISP1_PFORMAT_16BIT\t0\n# define DSI_DISP1_PFORMAT_24BIT\t1\n# define DSI_DISP1_PFORMAT_32BIT_LE\t2\n# define DSI_DISP1_PFORMAT_32BIT_BE\t3\n\n \n# define DSI_DISP1_ENABLE\t\tBIT(0)\n\n#define DSI0_TXPKT_PIX_FIFO\t\t0x20  \n\n#define DSI0_INT_STAT\t\t\t0x24\n#define DSI0_INT_EN\t\t\t0x28\n# define DSI0_INT_FIFO_ERR\t\tBIT(25)\n# define DSI0_INT_CMDC_DONE_MASK\tVC4_MASK(24, 23)\n# define DSI0_INT_CMDC_DONE_SHIFT\t23\n#  define DSI0_INT_CMDC_DONE_NO_REPEAT\t\t1\n#  define DSI0_INT_CMDC_DONE_REPEAT\t\t3\n# define DSI0_INT_PHY_DIR_RTF\t\tBIT(22)\n# define DSI0_INT_PHY_D1_ULPS\t\tBIT(21)\n# define DSI0_INT_PHY_D1_STOP\t\tBIT(20)\n# define DSI0_INT_PHY_RXLPDT\t\tBIT(19)\n# define DSI0_INT_PHY_RXTRIG\t\tBIT(18)\n# define DSI0_INT_PHY_D0_ULPS\t\tBIT(17)\n# define DSI0_INT_PHY_D0_LPDT\t\tBIT(16)\n# define DSI0_INT_PHY_D0_FTR\t\tBIT(15)\n# define DSI0_INT_PHY_D0_STOP\t\tBIT(14)\n \n# define DSI0_INT_PHY_CLK_ULPS\t\tBIT(13)\n# define DSI0_INT_PHY_CLK_HS\t\tBIT(12)\n# define DSI0_INT_PHY_CLK_FTR\t\tBIT(11)\n \n# define DSI0_INT_PR_TO\t\t\tBIT(10)\n# define DSI0_INT_TA_TO\t\t\tBIT(9)\n# define DSI0_INT_LPRX_TO\t\tBIT(8)\n# define DSI0_INT_HSTX_TO\t\tBIT(7)\n \n# define DSI0_INT_ERR_CONT_LP1\t\tBIT(6)\n# define DSI0_INT_ERR_CONT_LP0\t\tBIT(5)\n \n# define DSI0_INT_ERR_CONTROL\t\tBIT(4)\n# define DSI0_INT_ERR_SYNC_ESC\t\tBIT(3)\n# define DSI0_INT_RX2_PKT\t\tBIT(2)\n# define DSI0_INT_RX1_PKT\t\tBIT(1)\n# define DSI0_INT_CMD_PKT\t\tBIT(0)\n\n#define DSI0_INTERRUPTS_ALWAYS_ENABLED\t(DSI0_INT_ERR_SYNC_ESC | \\\n\t\t\t\t\t DSI0_INT_ERR_CONTROL |\t \\\n\t\t\t\t\t DSI0_INT_ERR_CONT_LP0 | \\\n\t\t\t\t\t DSI0_INT_ERR_CONT_LP1 | \\\n\t\t\t\t\t DSI0_INT_HSTX_TO |\t \\\n\t\t\t\t\t DSI0_INT_LPRX_TO |\t \\\n\t\t\t\t\t DSI0_INT_TA_TO |\t \\\n\t\t\t\t\t DSI0_INT_PR_TO)\n\n# define DSI1_INT_PHY_D3_ULPS\t\tBIT(30)\n# define DSI1_INT_PHY_D3_STOP\t\tBIT(29)\n# define DSI1_INT_PHY_D2_ULPS\t\tBIT(28)\n# define DSI1_INT_PHY_D2_STOP\t\tBIT(27)\n# define DSI1_INT_PHY_D1_ULPS\t\tBIT(26)\n# define DSI1_INT_PHY_D1_STOP\t\tBIT(25)\n# define DSI1_INT_PHY_D0_ULPS\t\tBIT(24)\n# define DSI1_INT_PHY_D0_STOP\t\tBIT(23)\n# define DSI1_INT_FIFO_ERR\t\tBIT(22)\n# define DSI1_INT_PHY_DIR_RTF\t\tBIT(21)\n# define DSI1_INT_PHY_RXLPDT\t\tBIT(20)\n# define DSI1_INT_PHY_RXTRIG\t\tBIT(19)\n# define DSI1_INT_PHY_D0_LPDT\t\tBIT(18)\n# define DSI1_INT_PHY_DIR_FTR\t\tBIT(17)\n\n \n# define DSI1_INT_PHY_CLOCK_ULPS\tBIT(16)\n# define DSI1_INT_PHY_CLOCK_HS\t\tBIT(15)\n# define DSI1_INT_PHY_CLOCK_STOP\tBIT(14)\n\n \n# define DSI1_INT_PR_TO\t\t\tBIT(13)\n# define DSI1_INT_TA_TO\t\t\tBIT(12)\n# define DSI1_INT_LPRX_TO\t\tBIT(11)\n# define DSI1_INT_HSTX_TO\t\tBIT(10)\n\n \n# define DSI1_INT_ERR_CONT_LP1\t\tBIT(9)\n# define DSI1_INT_ERR_CONT_LP0\t\tBIT(8)\n\n \n# define DSI1_INT_ERR_CONTROL\t\tBIT(7)\n \n\n# define DSI1_INT_ERR_SYNC_ESC\t\tBIT(6)\n \n# define DSI1_INT_RXPKT2\t\tBIT(5)\n \n# define DSI1_INT_RXPKT1\t\tBIT(4)\n# define DSI1_INT_TXPKT2_DONE\t\tBIT(3)\n# define DSI1_INT_TXPKT2_END\t\tBIT(2)\n \n# define DSI1_INT_TXPKT1_DONE\t\tBIT(1)\n \n# define DSI1_INT_TXPKT1_END\t\tBIT(0)\n\n#define DSI1_INTERRUPTS_ALWAYS_ENABLED\t(DSI1_INT_ERR_SYNC_ESC | \\\n\t\t\t\t\t DSI1_INT_ERR_CONTROL |\t \\\n\t\t\t\t\t DSI1_INT_ERR_CONT_LP0 | \\\n\t\t\t\t\t DSI1_INT_ERR_CONT_LP1 | \\\n\t\t\t\t\t DSI1_INT_HSTX_TO |\t \\\n\t\t\t\t\t DSI1_INT_LPRX_TO |\t \\\n\t\t\t\t\t DSI1_INT_TA_TO |\t \\\n\t\t\t\t\t DSI1_INT_PR_TO)\n\n#define DSI0_STAT\t\t0x2c\n#define DSI0_HSTX_TO_CNT\t0x30\n#define DSI0_LPRX_TO_CNT\t0x34\n#define DSI0_TA_TO_CNT\t\t0x38\n#define DSI0_PR_TO_CNT\t\t0x3c\n#define DSI0_PHYC\t\t0x40\n# define DSI1_PHYC_ESC_CLK_LPDT_MASK\tVC4_MASK(25, 20)\n# define DSI1_PHYC_ESC_CLK_LPDT_SHIFT\t20\n# define DSI1_PHYC_HS_CLK_CONTINUOUS\tBIT(18)\n# define DSI0_PHYC_ESC_CLK_LPDT_MASK\tVC4_MASK(17, 12)\n# define DSI0_PHYC_ESC_CLK_LPDT_SHIFT\t12\n# define DSI1_PHYC_CLANE_ULPS\t\tBIT(17)\n# define DSI1_PHYC_CLANE_ENABLE\t\tBIT(16)\n# define DSI_PHYC_DLANE3_ULPS\t\tBIT(13)\n# define DSI_PHYC_DLANE3_ENABLE\t\tBIT(12)\n# define DSI0_PHYC_HS_CLK_CONTINUOUS\tBIT(10)\n# define DSI0_PHYC_CLANE_ULPS\t\tBIT(9)\n# define DSI_PHYC_DLANE2_ULPS\t\tBIT(9)\n# define DSI0_PHYC_CLANE_ENABLE\t\tBIT(8)\n# define DSI_PHYC_DLANE2_ENABLE\t\tBIT(8)\n# define DSI_PHYC_DLANE1_ULPS\t\tBIT(5)\n# define DSI_PHYC_DLANE1_ENABLE\t\tBIT(4)\n# define DSI_PHYC_DLANE0_FORCE_STOP\tBIT(2)\n# define DSI_PHYC_DLANE0_ULPS\t\tBIT(1)\n# define DSI_PHYC_DLANE0_ENABLE\t\tBIT(0)\n\n#define DSI0_HS_CLT0\t\t0x44\n#define DSI0_HS_CLT1\t\t0x48\n#define DSI0_HS_CLT2\t\t0x4c\n#define DSI0_HS_DLT3\t\t0x50\n#define DSI0_HS_DLT4\t\t0x54\n#define DSI0_HS_DLT5\t\t0x58\n#define DSI0_HS_DLT6\t\t0x5c\n#define DSI0_HS_DLT7\t\t0x60\n\n#define DSI0_PHY_AFEC0\t\t0x64\n# define DSI0_PHY_AFEC0_DDR2CLK_EN\t\tBIT(26)\n# define DSI0_PHY_AFEC0_DDRCLK_EN\t\tBIT(25)\n# define DSI0_PHY_AFEC0_LATCH_ULPS\t\tBIT(24)\n# define DSI1_PHY_AFEC0_IDR_DLANE3_MASK\t\tVC4_MASK(31, 29)\n# define DSI1_PHY_AFEC0_IDR_DLANE3_SHIFT\t29\n# define DSI1_PHY_AFEC0_IDR_DLANE2_MASK\t\tVC4_MASK(28, 26)\n# define DSI1_PHY_AFEC0_IDR_DLANE2_SHIFT\t26\n# define DSI1_PHY_AFEC0_IDR_DLANE1_MASK\t\tVC4_MASK(27, 23)\n# define DSI1_PHY_AFEC0_IDR_DLANE1_SHIFT\t23\n# define DSI1_PHY_AFEC0_IDR_DLANE0_MASK\t\tVC4_MASK(22, 20)\n# define DSI1_PHY_AFEC0_IDR_DLANE0_SHIFT\t20\n# define DSI1_PHY_AFEC0_IDR_CLANE_MASK\t\tVC4_MASK(19, 17)\n# define DSI1_PHY_AFEC0_IDR_CLANE_SHIFT\t\t17\n# define DSI0_PHY_AFEC0_ACTRL_DLANE1_MASK\tVC4_MASK(23, 20)\n# define DSI0_PHY_AFEC0_ACTRL_DLANE1_SHIFT\t20\n# define DSI0_PHY_AFEC0_ACTRL_DLANE0_MASK\tVC4_MASK(19, 16)\n# define DSI0_PHY_AFEC0_ACTRL_DLANE0_SHIFT\t16\n# define DSI0_PHY_AFEC0_ACTRL_CLANE_MASK\tVC4_MASK(15, 12)\n# define DSI0_PHY_AFEC0_ACTRL_CLANE_SHIFT\t12\n# define DSI1_PHY_AFEC0_DDR2CLK_EN\t\tBIT(16)\n# define DSI1_PHY_AFEC0_DDRCLK_EN\t\tBIT(15)\n# define DSI1_PHY_AFEC0_LATCH_ULPS\t\tBIT(14)\n# define DSI1_PHY_AFEC0_RESET\t\t\tBIT(13)\n# define DSI1_PHY_AFEC0_PD\t\t\tBIT(12)\n# define DSI0_PHY_AFEC0_RESET\t\t\tBIT(11)\n# define DSI1_PHY_AFEC0_PD_BG\t\t\tBIT(11)\n# define DSI0_PHY_AFEC0_PD\t\t\tBIT(10)\n# define DSI1_PHY_AFEC0_PD_DLANE1\t\tBIT(10)\n# define DSI0_PHY_AFEC0_PD_BG\t\t\tBIT(9)\n# define DSI1_PHY_AFEC0_PD_DLANE2\t\tBIT(9)\n# define DSI0_PHY_AFEC0_PD_DLANE1\t\tBIT(8)\n# define DSI1_PHY_AFEC0_PD_DLANE3\t\tBIT(8)\n# define DSI_PHY_AFEC0_PTATADJ_MASK\t\tVC4_MASK(7, 4)\n# define DSI_PHY_AFEC0_PTATADJ_SHIFT\t\t4\n# define DSI_PHY_AFEC0_CTATADJ_MASK\t\tVC4_MASK(3, 0)\n# define DSI_PHY_AFEC0_CTATADJ_SHIFT\t\t0\n\n#define DSI0_PHY_AFEC1\t\t0x68\n# define DSI0_PHY_AFEC1_IDR_DLANE1_MASK\t\tVC4_MASK(10, 8)\n# define DSI0_PHY_AFEC1_IDR_DLANE1_SHIFT\t8\n# define DSI0_PHY_AFEC1_IDR_DLANE0_MASK\t\tVC4_MASK(6, 4)\n# define DSI0_PHY_AFEC1_IDR_DLANE0_SHIFT\t4\n# define DSI0_PHY_AFEC1_IDR_CLANE_MASK\t\tVC4_MASK(2, 0)\n# define DSI0_PHY_AFEC1_IDR_CLANE_SHIFT\t\t0\n\n#define DSI0_TST_SEL\t\t0x6c\n#define DSI0_TST_MON\t\t0x70\n#define DSI0_ID\t\t\t0x74\n# define DSI_ID_VALUE\t\t0x00647369\n\n#define DSI1_CTRL\t\t0x00\n# define DSI_CTRL_HS_CLKC_MASK\t\tVC4_MASK(15, 14)\n# define DSI_CTRL_HS_CLKC_SHIFT\t\t14\n# define DSI_CTRL_HS_CLKC_BYTE\t\t0\n# define DSI_CTRL_HS_CLKC_DDR2\t\t1\n# define DSI_CTRL_HS_CLKC_DDR\t\t2\n\n# define DSI_CTRL_RX_LPDT_EOT_DISABLE\tBIT(13)\n# define DSI_CTRL_LPDT_EOT_DISABLE\tBIT(12)\n# define DSI_CTRL_HSDT_EOT_DISABLE\tBIT(11)\n# define DSI_CTRL_SOFT_RESET_CFG\tBIT(10)\n# define DSI_CTRL_CAL_BYTE\t\tBIT(9)\n# define DSI_CTRL_INV_BYTE\t\tBIT(8)\n# define DSI_CTRL_CLR_LDF\t\tBIT(7)\n# define DSI0_CTRL_CLR_PBCF\t\tBIT(6)\n# define DSI1_CTRL_CLR_RXF\t\tBIT(6)\n# define DSI0_CTRL_CLR_CPBCF\t\tBIT(5)\n# define DSI1_CTRL_CLR_PDF\t\tBIT(5)\n# define DSI0_CTRL_CLR_PDF\t\tBIT(4)\n# define DSI1_CTRL_CLR_CDF\t\tBIT(4)\n# define DSI0_CTRL_CLR_CDF\t\tBIT(3)\n# define DSI0_CTRL_CTRL2\t\tBIT(2)\n# define DSI1_CTRL_DISABLE_DISP_CRCC\tBIT(2)\n# define DSI0_CTRL_CTRL1\t\tBIT(1)\n# define DSI1_CTRL_DISABLE_DISP_ECCC\tBIT(1)\n# define DSI0_CTRL_CTRL0\t\tBIT(0)\n# define DSI1_CTRL_EN\t\t\tBIT(0)\n# define DSI0_CTRL_RESET_FIFOS\t\t(DSI_CTRL_CLR_LDF | \\\n\t\t\t\t\t DSI0_CTRL_CLR_PBCF | \\\n\t\t\t\t\t DSI0_CTRL_CLR_CPBCF |\t\\\n\t\t\t\t\t DSI0_CTRL_CLR_PDF | \\\n\t\t\t\t\t DSI0_CTRL_CLR_CDF)\n# define DSI1_CTRL_RESET_FIFOS\t\t(DSI_CTRL_CLR_LDF | \\\n\t\t\t\t\t DSI1_CTRL_CLR_RXF | \\\n\t\t\t\t\t DSI1_CTRL_CLR_PDF | \\\n\t\t\t\t\t DSI1_CTRL_CLR_CDF)\n\n#define DSI1_TXPKT2C\t\t0x0c\n#define DSI1_TXPKT2H\t\t0x10\n#define DSI1_TXPKT_PIX_FIFO\t0x20\n#define DSI1_RXPKT_FIFO\t\t0x24\n#define DSI1_DISP0_CTRL\t\t0x28\n#define DSI1_INT_STAT\t\t0x30\n#define DSI1_INT_EN\t\t0x34\n \n#define DSI1_STAT\t\t0x38\n# define DSI1_STAT_PHY_D3_ULPS\t\tBIT(31)\n# define DSI1_STAT_PHY_D3_STOP\t\tBIT(30)\n# define DSI1_STAT_PHY_D2_ULPS\t\tBIT(29)\n# define DSI1_STAT_PHY_D2_STOP\t\tBIT(28)\n# define DSI1_STAT_PHY_D1_ULPS\t\tBIT(27)\n# define DSI1_STAT_PHY_D1_STOP\t\tBIT(26)\n# define DSI1_STAT_PHY_D0_ULPS\t\tBIT(25)\n# define DSI1_STAT_PHY_D0_STOP\t\tBIT(24)\n# define DSI1_STAT_FIFO_ERR\t\tBIT(23)\n# define DSI1_STAT_PHY_RXLPDT\t\tBIT(22)\n# define DSI1_STAT_PHY_RXTRIG\t\tBIT(21)\n# define DSI1_STAT_PHY_D0_LPDT\t\tBIT(20)\n \n# define DSI1_STAT_PHY_DIR\t\tBIT(19)\n# define DSI1_STAT_PHY_CLOCK_ULPS\tBIT(18)\n# define DSI1_STAT_PHY_CLOCK_HS\t\tBIT(17)\n# define DSI1_STAT_PHY_CLOCK_STOP\tBIT(16)\n# define DSI1_STAT_PR_TO\t\tBIT(15)\n# define DSI1_STAT_TA_TO\t\tBIT(14)\n# define DSI1_STAT_LPRX_TO\t\tBIT(13)\n# define DSI1_STAT_HSTX_TO\t\tBIT(12)\n# define DSI1_STAT_ERR_CONT_LP1\t\tBIT(11)\n# define DSI1_STAT_ERR_CONT_LP0\t\tBIT(10)\n# define DSI1_STAT_ERR_CONTROL\t\tBIT(9)\n# define DSI1_STAT_ERR_SYNC_ESC\t\tBIT(8)\n# define DSI1_STAT_RXPKT2\t\tBIT(7)\n# define DSI1_STAT_RXPKT1\t\tBIT(6)\n# define DSI1_STAT_TXPKT2_BUSY\t\tBIT(5)\n# define DSI1_STAT_TXPKT2_DONE\t\tBIT(4)\n# define DSI1_STAT_TXPKT2_END\t\tBIT(3)\n# define DSI1_STAT_TXPKT1_BUSY\t\tBIT(2)\n# define DSI1_STAT_TXPKT1_DONE\t\tBIT(1)\n# define DSI1_STAT_TXPKT1_END\t\tBIT(0)\n\n#define DSI1_HSTX_TO_CNT\t0x3c\n#define DSI1_LPRX_TO_CNT\t0x40\n#define DSI1_TA_TO_CNT\t\t0x44\n#define DSI1_PR_TO_CNT\t\t0x48\n#define DSI1_PHYC\t\t0x4c\n\n#define DSI1_HS_CLT0\t\t0x50\n# define DSI_HS_CLT0_CZERO_MASK\t\tVC4_MASK(26, 18)\n# define DSI_HS_CLT0_CZERO_SHIFT\t18\n# define DSI_HS_CLT0_CPRE_MASK\t\tVC4_MASK(17, 9)\n# define DSI_HS_CLT0_CPRE_SHIFT\t\t9\n# define DSI_HS_CLT0_CPREP_MASK\t\tVC4_MASK(8, 0)\n# define DSI_HS_CLT0_CPREP_SHIFT\t0\n\n#define DSI1_HS_CLT1\t\t0x54\n# define DSI_HS_CLT1_CTRAIL_MASK\tVC4_MASK(17, 9)\n# define DSI_HS_CLT1_CTRAIL_SHIFT\t9\n# define DSI_HS_CLT1_CPOST_MASK\t\tVC4_MASK(8, 0)\n# define DSI_HS_CLT1_CPOST_SHIFT\t0\n\n#define DSI1_HS_CLT2\t\t0x58\n# define DSI_HS_CLT2_WUP_MASK\t\tVC4_MASK(23, 0)\n# define DSI_HS_CLT2_WUP_SHIFT\t\t0\n\n#define DSI1_HS_DLT3\t\t0x5c\n# define DSI_HS_DLT3_EXIT_MASK\t\tVC4_MASK(26, 18)\n# define DSI_HS_DLT3_EXIT_SHIFT\t\t18\n# define DSI_HS_DLT3_ZERO_MASK\t\tVC4_MASK(17, 9)\n# define DSI_HS_DLT3_ZERO_SHIFT\t\t9\n# define DSI_HS_DLT3_PRE_MASK\t\tVC4_MASK(8, 0)\n# define DSI_HS_DLT3_PRE_SHIFT\t\t0\n\n#define DSI1_HS_DLT4\t\t0x60\n# define DSI_HS_DLT4_ANLAT_MASK\t\tVC4_MASK(22, 18)\n# define DSI_HS_DLT4_ANLAT_SHIFT\t18\n# define DSI_HS_DLT4_TRAIL_MASK\t\tVC4_MASK(17, 9)\n# define DSI_HS_DLT4_TRAIL_SHIFT\t9\n# define DSI_HS_DLT4_LPX_MASK\t\tVC4_MASK(8, 0)\n# define DSI_HS_DLT4_LPX_SHIFT\t\t0\n\n#define DSI1_HS_DLT5\t\t0x64\n# define DSI_HS_DLT5_INIT_MASK\t\tVC4_MASK(23, 0)\n# define DSI_HS_DLT5_INIT_SHIFT\t\t0\n\n#define DSI1_HS_DLT6\t\t0x68\n# define DSI_HS_DLT6_TA_GET_MASK\tVC4_MASK(31, 24)\n# define DSI_HS_DLT6_TA_GET_SHIFT\t24\n# define DSI_HS_DLT6_TA_SURE_MASK\tVC4_MASK(23, 16)\n# define DSI_HS_DLT6_TA_SURE_SHIFT\t16\n# define DSI_HS_DLT6_TA_GO_MASK\t\tVC4_MASK(15, 8)\n# define DSI_HS_DLT6_TA_GO_SHIFT\t8\n# define DSI_HS_DLT6_LP_LPX_MASK\tVC4_MASK(7, 0)\n# define DSI_HS_DLT6_LP_LPX_SHIFT\t0\n\n#define DSI1_HS_DLT7\t\t0x6c\n# define DSI_HS_DLT7_LP_WUP_MASK\tVC4_MASK(23, 0)\n# define DSI_HS_DLT7_LP_WUP_SHIFT\t0\n\n#define DSI1_PHY_AFEC0\t\t0x70\n\n#define DSI1_PHY_AFEC1\t\t0x74\n# define DSI1_PHY_AFEC1_ACTRL_DLANE3_MASK\tVC4_MASK(19, 16)\n# define DSI1_PHY_AFEC1_ACTRL_DLANE3_SHIFT\t16\n# define DSI1_PHY_AFEC1_ACTRL_DLANE2_MASK\tVC4_MASK(15, 12)\n# define DSI1_PHY_AFEC1_ACTRL_DLANE2_SHIFT\t12\n# define DSI1_PHY_AFEC1_ACTRL_DLANE1_MASK\tVC4_MASK(11, 8)\n# define DSI1_PHY_AFEC1_ACTRL_DLANE1_SHIFT\t8\n# define DSI1_PHY_AFEC1_ACTRL_DLANE0_MASK\tVC4_MASK(7, 4)\n# define DSI1_PHY_AFEC1_ACTRL_DLANE0_SHIFT\t4\n# define DSI1_PHY_AFEC1_ACTRL_CLANE_MASK\tVC4_MASK(3, 0)\n# define DSI1_PHY_AFEC1_ACTRL_CLANE_SHIFT\t0\n\n#define DSI1_TST_SEL\t\t0x78\n#define DSI1_TST_MON\t\t0x7c\n#define DSI1_PHY_TST1\t\t0x80\n#define DSI1_PHY_TST2\t\t0x84\n#define DSI1_PHY_FIFO_STAT\t0x88\n \n#define DSI1_ID\t\t\t0x8c\n\nstruct vc4_dsi_variant {\n\t \n\tunsigned int port;\n\n\tbool broken_axi_workaround;\n\n\tconst char *debugfs_name;\n\tconst struct debugfs_reg32 *regs;\n\tsize_t nregs;\n\n};\n\n \nstruct vc4_dsi {\n\tstruct vc4_encoder encoder;\n\tstruct mipi_dsi_host dsi_host;\n\n\tstruct kref kref;\n\n\tstruct platform_device *pdev;\n\n\tstruct drm_bridge *out_bridge;\n\tstruct drm_bridge bridge;\n\n\tvoid __iomem *regs;\n\n\tstruct dma_chan *reg_dma_chan;\n\tdma_addr_t reg_dma_paddr;\n\tu32 *reg_dma_mem;\n\tdma_addr_t reg_paddr;\n\n\tconst struct vc4_dsi_variant *variant;\n\n\t \n\tu32 channel;\n\tu32 lanes;\n\tu32 format;\n\tu32 divider;\n\tu32 mode_flags;\n\n\t \n\tstruct clk *escape_clock;\n\n\t \n\tstruct clk *pll_phy_clock;\n\n\t \n\tstruct clk_fixed_factor phy_clocks[3];\n\n\tstruct clk_hw_onecell_data *clk_onecell;\n\n\t \n\tstruct clk *pixel_clock;\n\n\tstruct completion xfer_completion;\n\tint xfer_result;\n\n\tstruct debugfs_regset32 regset;\n};\n\n#define host_to_dsi(host)\t\t\t\t\t\\\n\tcontainer_of_const(host, struct vc4_dsi, dsi_host)\n\n#define to_vc4_dsi(_encoder)\t\t\t\t\t\\\n\tcontainer_of_const(_encoder, struct vc4_dsi, encoder.base)\n\n#define bridge_to_vc4_dsi(_bridge)\t\t\t\t\\\n\tcontainer_of_const(_bridge, struct vc4_dsi, bridge)\n\nstatic inline void\ndsi_dma_workaround_write(struct vc4_dsi *dsi, u32 offset, u32 val)\n{\n\tstruct dma_chan *chan = dsi->reg_dma_chan;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\n\n\t \n\tif (!chan) {\n\t\twritel(val, dsi->regs + offset);\n\t\treturn;\n\t}\n\n\t*dsi->reg_dma_mem = val;\n\n\ttx = chan->device->device_prep_dma_memcpy(chan,\n\t\t\t\t\t\t  dsi->reg_paddr + offset,\n\t\t\t\t\t\t  dsi->reg_dma_paddr,\n\t\t\t\t\t\t  4, 0);\n\tif (!tx) {\n\t\tDRM_ERROR(\"Failed to set up DMA register write\\n\");\n\t\treturn;\n\t}\n\n\tcookie = tx->tx_submit(tx);\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to submit DMA: %d\\n\", ret);\n\t\treturn;\n\t}\n\tret = dma_sync_wait(chan, cookie);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to wait for DMA: %d\\n\", ret);\n}\n\n#define DSI_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(dsi->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define DSI_WRITE(offset, val) dsi_dma_workaround_write(dsi, offset, val)\n#define DSI_PORT_READ(offset) \\\n\tDSI_READ(dsi->variant->port ? DSI1_##offset : DSI0_##offset)\n#define DSI_PORT_WRITE(offset, val) \\\n\tDSI_WRITE(dsi->variant->port ? DSI1_##offset : DSI0_##offset, val)\n#define DSI_PORT_BIT(bit) (dsi->variant->port ? DSI1_##bit : DSI0_##bit)\n\nstatic const struct debugfs_reg32 dsi0_regs[] = {\n\tVC4_REG32(DSI0_CTRL),\n\tVC4_REG32(DSI0_STAT),\n\tVC4_REG32(DSI0_HSTX_TO_CNT),\n\tVC4_REG32(DSI0_LPRX_TO_CNT),\n\tVC4_REG32(DSI0_TA_TO_CNT),\n\tVC4_REG32(DSI0_PR_TO_CNT),\n\tVC4_REG32(DSI0_DISP0_CTRL),\n\tVC4_REG32(DSI0_DISP1_CTRL),\n\tVC4_REG32(DSI0_INT_STAT),\n\tVC4_REG32(DSI0_INT_EN),\n\tVC4_REG32(DSI0_PHYC),\n\tVC4_REG32(DSI0_HS_CLT0),\n\tVC4_REG32(DSI0_HS_CLT1),\n\tVC4_REG32(DSI0_HS_CLT2),\n\tVC4_REG32(DSI0_HS_DLT3),\n\tVC4_REG32(DSI0_HS_DLT4),\n\tVC4_REG32(DSI0_HS_DLT5),\n\tVC4_REG32(DSI0_HS_DLT6),\n\tVC4_REG32(DSI0_HS_DLT7),\n\tVC4_REG32(DSI0_PHY_AFEC0),\n\tVC4_REG32(DSI0_PHY_AFEC1),\n\tVC4_REG32(DSI0_ID),\n};\n\nstatic const struct debugfs_reg32 dsi1_regs[] = {\n\tVC4_REG32(DSI1_CTRL),\n\tVC4_REG32(DSI1_STAT),\n\tVC4_REG32(DSI1_HSTX_TO_CNT),\n\tVC4_REG32(DSI1_LPRX_TO_CNT),\n\tVC4_REG32(DSI1_TA_TO_CNT),\n\tVC4_REG32(DSI1_PR_TO_CNT),\n\tVC4_REG32(DSI1_DISP0_CTRL),\n\tVC4_REG32(DSI1_DISP1_CTRL),\n\tVC4_REG32(DSI1_INT_STAT),\n\tVC4_REG32(DSI1_INT_EN),\n\tVC4_REG32(DSI1_PHYC),\n\tVC4_REG32(DSI1_HS_CLT0),\n\tVC4_REG32(DSI1_HS_CLT1),\n\tVC4_REG32(DSI1_HS_CLT2),\n\tVC4_REG32(DSI1_HS_DLT3),\n\tVC4_REG32(DSI1_HS_DLT4),\n\tVC4_REG32(DSI1_HS_DLT5),\n\tVC4_REG32(DSI1_HS_DLT6),\n\tVC4_REG32(DSI1_HS_DLT7),\n\tVC4_REG32(DSI1_PHY_AFEC0),\n\tVC4_REG32(DSI1_PHY_AFEC1),\n\tVC4_REG32(DSI1_ID),\n};\n\nstatic void vc4_dsi_latch_ulps(struct vc4_dsi *dsi, bool latch)\n{\n\tu32 afec0 = DSI_PORT_READ(PHY_AFEC0);\n\n\tif (latch)\n\t\tafec0 |= DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS);\n\telse\n\t\tafec0 &= ~DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS);\n\n\tDSI_PORT_WRITE(PHY_AFEC0, afec0);\n}\n\n \nstatic void vc4_dsi_ulps(struct vc4_dsi *dsi, bool ulps)\n{\n\tbool non_continuous = dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\tu32 phyc_ulps = ((non_continuous ? DSI_PORT_BIT(PHYC_CLANE_ULPS) : 0) |\n\t\t\t DSI_PHYC_DLANE0_ULPS |\n\t\t\t (dsi->lanes > 1 ? DSI_PHYC_DLANE1_ULPS : 0) |\n\t\t\t (dsi->lanes > 2 ? DSI_PHYC_DLANE2_ULPS : 0) |\n\t\t\t (dsi->lanes > 3 ? DSI_PHYC_DLANE3_ULPS : 0));\n\tu32 stat_ulps = ((non_continuous ? DSI1_STAT_PHY_CLOCK_ULPS : 0) |\n\t\t\t DSI1_STAT_PHY_D0_ULPS |\n\t\t\t (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_ULPS : 0) |\n\t\t\t (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_ULPS : 0) |\n\t\t\t (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_ULPS : 0));\n\tu32 stat_stop = ((non_continuous ? DSI1_STAT_PHY_CLOCK_STOP : 0) |\n\t\t\t DSI1_STAT_PHY_D0_STOP |\n\t\t\t (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_STOP : 0) |\n\t\t\t (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_STOP : 0) |\n\t\t\t (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_STOP : 0));\n\tint ret;\n\tbool ulps_currently_enabled = (DSI_PORT_READ(PHY_AFEC0) &\n\t\t\t\t       DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS));\n\n\tif (ulps == ulps_currently_enabled)\n\t\treturn;\n\n\tDSI_PORT_WRITE(STAT, stat_ulps);\n\tDSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) | phyc_ulps);\n\tret = wait_for((DSI_PORT_READ(STAT) & stat_ulps) == stat_ulps, 200);\n\tif (ret) {\n\t\tdev_warn(&dsi->pdev->dev,\n\t\t\t \"Timeout waiting for DSI ULPS entry: STAT 0x%08x\",\n\t\t\t DSI_PORT_READ(STAT));\n\t\tDSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);\n\t\tvc4_dsi_latch_ulps(dsi, false);\n\t\treturn;\n\t}\n\n\t \n\tvc4_dsi_latch_ulps(dsi, ulps);\n\n\tDSI_PORT_WRITE(STAT, stat_stop);\n\tDSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);\n\tret = wait_for((DSI_PORT_READ(STAT) & stat_stop) == stat_stop, 200);\n\tif (ret) {\n\t\tdev_warn(&dsi->pdev->dev,\n\t\t\t \"Timeout waiting for DSI STOP entry: STAT 0x%08x\",\n\t\t\t DSI_PORT_READ(STAT));\n\t\tDSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);\n\t\treturn;\n\t}\n}\n\nstatic u32\ndsi_hs_timing(u32 ui_ns, u32 ns, u32 ui)\n{\n\t \n\treturn roundup(ui + DIV_ROUND_UP(ns, ui_ns), 8);\n}\n\n \n#define ESC_TIME_NS 10\n\nstatic u32\ndsi_esc_timing(u32 ns)\n{\n\treturn DIV_ROUND_UP(ns, ESC_TIME_NS);\n}\n\nstatic void vc4_dsi_bridge_disable(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *state)\n{\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\tu32 disp0_ctrl;\n\n\tdisp0_ctrl = DSI_PORT_READ(DISP0_CTRL);\n\tdisp0_ctrl &= ~DSI_DISP0_ENABLE;\n\tDSI_PORT_WRITE(DISP0_CTRL, disp0_ctrl);\n}\n\nstatic void vc4_dsi_bridge_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *state)\n{\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\tstruct device *dev = &dsi->pdev->dev;\n\n\tclk_disable_unprepare(dsi->pll_phy_clock);\n\tclk_disable_unprepare(dsi->escape_clock);\n\tclk_disable_unprepare(dsi->pixel_clock);\n\n\tpm_runtime_put(dev);\n}\n\n \nstatic bool vc4_dsi_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\tstruct clk *phy_parent = clk_get_parent(dsi->pll_phy_clock);\n\tunsigned long parent_rate = clk_get_rate(phy_parent);\n\tunsigned long pixel_clock_hz = mode->clock * 1000;\n\tunsigned long pll_clock = pixel_clock_hz * dsi->divider;\n\tint divider;\n\n\t \n\tfor (divider = 1; divider < 255; divider++) {\n\t\tif (parent_rate / (divider + 1) < pll_clock)\n\t\t\tbreak;\n\t}\n\n\t \n\tpll_clock = parent_rate / divider;\n\tpixel_clock_hz = pll_clock / dsi->divider;\n\n\tadjusted_mode->clock = pixel_clock_hz / 1000;\n\n\t \n\tadjusted_mode->htotal = adjusted_mode->clock * mode->htotal /\n\t\t\t\tmode->clock;\n\tadjusted_mode->hsync_end += adjusted_mode->htotal - mode->htotal;\n\tadjusted_mode->hsync_start += adjusted_mode->htotal - mode->htotal;\n\n\treturn true;\n}\n\nstatic void vc4_dsi_bridge_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *old_state)\n{\n\tstruct drm_atomic_state *state = old_state->base.state;\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\tconst struct drm_crtc_state *crtc_state;\n\tstruct device *dev = &dsi->pdev->dev;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tbool debug_dump_regs = false;\n\tunsigned long hs_clock;\n\tstruct drm_crtc *crtc;\n\tu32 ui_ns;\n\t \n\tu32 lpx = dsi_esc_timing(60);\n\tunsigned long pixel_clock_hz;\n\tunsigned long dsip_clock;\n\tunsigned long phy_clock;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to runtime PM enable on DSI%d\\n\", dsi->variant->port);\n\t\treturn;\n\t}\n\n\tif (debug_dump_regs) {\n\t\tstruct drm_printer p = drm_info_printer(&dsi->pdev->dev);\n\t\tdev_info(&dsi->pdev->dev, \"DSI regs before:\\n\");\n\t\tdrm_print_regset32(&p, &dsi->regset);\n\t}\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tmode = &crtc_state->adjusted_mode;\n\n\tpixel_clock_hz = mode->clock * 1000;\n\n\t \n\tphy_clock = (pixel_clock_hz + 1000) * dsi->divider;\n\tret = clk_set_rate(dsi->pll_phy_clock, phy_clock);\n\tif (ret) {\n\t\tdev_err(&dsi->pdev->dev,\n\t\t\t\"Failed to set phy clock to %ld: %d\\n\", phy_clock, ret);\n\t}\n\n\t \n\tDSI_PORT_WRITE(CTRL,\n\t\t       DSI_CTRL_SOFT_RESET_CFG |\n\t\t       DSI_PORT_BIT(CTRL_RESET_FIFOS));\n\n\tDSI_PORT_WRITE(CTRL,\n\t\t       DSI_CTRL_HSDT_EOT_DISABLE |\n\t\t       DSI_CTRL_RX_LPDT_EOT_DISABLE);\n\n\t \n\tDSI_PORT_WRITE(STAT, DSI_PORT_READ(STAT));\n\n\t \n\tif (dsi->variant->port == 0) {\n\t\tu32 afec0 = (VC4_SET_FIELD(7, DSI_PHY_AFEC0_PTATADJ) |\n\t\t\t     VC4_SET_FIELD(7, DSI_PHY_AFEC0_CTATADJ));\n\n\t\tif (dsi->lanes < 2)\n\t\t\tafec0 |= DSI0_PHY_AFEC0_PD_DLANE1;\n\n\t\tif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO))\n\t\t\tafec0 |= DSI0_PHY_AFEC0_RESET;\n\n\t\tDSI_PORT_WRITE(PHY_AFEC0, afec0);\n\n\t\t \n\t\tmdelay(1);\n\n\t\tDSI_PORT_WRITE(PHY_AFEC1,\n\t\t\t       VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_DLANE1) |\n\t\t\t       VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_DLANE0) |\n\t\t\t       VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_CLANE));\n\t} else {\n\t\tu32 afec0 = (VC4_SET_FIELD(7, DSI_PHY_AFEC0_PTATADJ) |\n\t\t\t     VC4_SET_FIELD(7, DSI_PHY_AFEC0_CTATADJ) |\n\t\t\t     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_CLANE) |\n\t\t\t     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE0) |\n\t\t\t     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE1) |\n\t\t\t     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE2) |\n\t\t\t     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE3));\n\n\t\tif (dsi->lanes < 4)\n\t\t\tafec0 |= DSI1_PHY_AFEC0_PD_DLANE3;\n\t\tif (dsi->lanes < 3)\n\t\t\tafec0 |= DSI1_PHY_AFEC0_PD_DLANE2;\n\t\tif (dsi->lanes < 2)\n\t\t\tafec0 |= DSI1_PHY_AFEC0_PD_DLANE1;\n\n\t\tafec0 |= DSI1_PHY_AFEC0_RESET;\n\n\t\tDSI_PORT_WRITE(PHY_AFEC0, afec0);\n\n\t\tDSI_PORT_WRITE(PHY_AFEC1, 0);\n\n\t\t \n\t\tmdelay(1);\n\t}\n\n\tret = clk_prepare_enable(dsi->escape_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on DSI escape clock: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = clk_prepare_enable(dsi->pll_phy_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on DSI PLL: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ths_clock = clk_get_rate(dsi->pll_phy_clock);\n\n\t \n\tdsip_clock = phy_clock / 8;\n\tret = clk_set_rate(dsi->pixel_clock, dsip_clock);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set pixel clock to %ldHz: %d\\n\",\n\t\t\tdsip_clock, ret);\n\t}\n\n\tret = clk_prepare_enable(dsi->pixel_clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on DSI pixel clock: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tui_ns = DIV_ROUND_UP(500000000, hs_clock);\n\n\tDSI_PORT_WRITE(HS_CLT0,\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 262, 0),\n\t\t\t\t     DSI_HS_CLT0_CZERO) |\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 0, 8),\n\t\t\t\t     DSI_HS_CLT0_CPRE) |\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 38, 0),\n\t\t\t\t     DSI_HS_CLT0_CPREP));\n\n\tDSI_PORT_WRITE(HS_CLT1,\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 60, 0),\n\t\t\t\t     DSI_HS_CLT1_CTRAIL) |\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 60, 52),\n\t\t\t\t     DSI_HS_CLT1_CPOST));\n\n\tDSI_PORT_WRITE(HS_CLT2,\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 1000000, 0),\n\t\t\t\t     DSI_HS_CLT2_WUP));\n\n\tDSI_PORT_WRITE(HS_DLT3,\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 100, 0),\n\t\t\t\t     DSI_HS_DLT3_EXIT) |\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 105, 6),\n\t\t\t\t     DSI_HS_DLT3_ZERO) |\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 40, 4),\n\t\t\t\t     DSI_HS_DLT3_PRE));\n\n\tDSI_PORT_WRITE(HS_DLT4,\n\t\t       VC4_SET_FIELD(dsi_hs_timing(ui_ns, lpx * ESC_TIME_NS, 0),\n\t\t\t\t     DSI_HS_DLT4_LPX) |\n\t\t       VC4_SET_FIELD(max(dsi_hs_timing(ui_ns, 0, 8),\n\t\t\t\t\t dsi_hs_timing(ui_ns, 60, 4)),\n\t\t\t\t     DSI_HS_DLT4_TRAIL) |\n\t\t       VC4_SET_FIELD(0, DSI_HS_DLT4_ANLAT));\n\n\t \n\tDSI_PORT_WRITE(HS_DLT5, VC4_SET_FIELD(dsi_hs_timing(ui_ns,\n\t\t\t\t\t\t\t    5 * 1000 * 1000, 0),\n\t\t\t\t\t      DSI_HS_DLT5_INIT));\n\n\tDSI_PORT_WRITE(HS_DLT6,\n\t\t       VC4_SET_FIELD(lpx * 5, DSI_HS_DLT6_TA_GET) |\n\t\t       VC4_SET_FIELD(lpx, DSI_HS_DLT6_TA_SURE) |\n\t\t       VC4_SET_FIELD(lpx * 4, DSI_HS_DLT6_TA_GO) |\n\t\t       VC4_SET_FIELD(lpx, DSI_HS_DLT6_LP_LPX));\n\n\tDSI_PORT_WRITE(HS_DLT7,\n\t\t       VC4_SET_FIELD(dsi_esc_timing(1000000),\n\t\t\t\t     DSI_HS_DLT7_LP_WUP));\n\n\tDSI_PORT_WRITE(PHYC,\n\t\t       DSI_PHYC_DLANE0_ENABLE |\n\t\t       (dsi->lanes >= 2 ? DSI_PHYC_DLANE1_ENABLE : 0) |\n\t\t       (dsi->lanes >= 3 ? DSI_PHYC_DLANE2_ENABLE : 0) |\n\t\t       (dsi->lanes >= 4 ? DSI_PHYC_DLANE3_ENABLE : 0) |\n\t\t       DSI_PORT_BIT(PHYC_CLANE_ENABLE) |\n\t\t       ((dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) ?\n\t\t\t0 : DSI_PORT_BIT(PHYC_HS_CLK_CONTINUOUS)) |\n\t\t       (dsi->variant->port == 0 ?\n\t\t\tVC4_SET_FIELD(lpx - 1, DSI0_PHYC_ESC_CLK_LPDT) :\n\t\t\tVC4_SET_FIELD(lpx - 1, DSI1_PHYC_ESC_CLK_LPDT)));\n\n\tDSI_PORT_WRITE(CTRL,\n\t\t       DSI_PORT_READ(CTRL) |\n\t\t       DSI_CTRL_CAL_BYTE);\n\n\t \n\tDSI_PORT_WRITE(HSTX_TO_CNT, 0);\n\t \n\tDSI_PORT_WRITE(LPRX_TO_CNT, 0xffffff);\n\t \n\tDSI_PORT_WRITE(TA_TO_CNT, 100000);\n\t \n\tDSI_PORT_WRITE(PR_TO_CNT, 100000);\n\n\t \n\tDSI_PORT_WRITE(DISP1_CTRL,\n\t\t       VC4_SET_FIELD(DSI_DISP1_PFORMAT_32BIT_LE,\n\t\t\t\t     DSI_DISP1_PFORMAT) |\n\t\t       DSI_DISP1_ENABLE);\n\n\t \n\tif (dsi->variant->port == 0)\n\t\tDSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI0_CTRL_CTRL0);\n\telse\n\t\tDSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI1_CTRL_EN);\n\n\t \n\tDSI_PORT_WRITE(PHY_AFEC0,\n\t\t       DSI_PORT_READ(PHY_AFEC0) &\n\t\t       ~DSI_PORT_BIT(PHY_AFEC0_RESET));\n\n\tvc4_dsi_ulps(dsi, false);\n\n\tif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tDSI_PORT_WRITE(DISP0_CTRL,\n\t\t\t       VC4_SET_FIELD(dsi->divider,\n\t\t\t\t\t     DSI_DISP0_PIX_CLK_DIV) |\n\t\t\t       VC4_SET_FIELD(dsi->format, DSI_DISP0_PFORMAT) |\n\t\t\t       VC4_SET_FIELD(DSI_DISP0_LP_STOP_PERFRAME,\n\t\t\t\t\t     DSI_DISP0_LP_STOP_CTRL) |\n\t\t\t       DSI_DISP0_ST_END);\n\t} else {\n\t\tDSI_PORT_WRITE(DISP0_CTRL,\n\t\t\t       DSI_DISP0_COMMAND_MODE);\n\t}\n}\n\nstatic void vc4_dsi_bridge_enable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_state)\n{\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\tbool debug_dump_regs = false;\n\tu32 disp0_ctrl;\n\n\tdisp0_ctrl = DSI_PORT_READ(DISP0_CTRL);\n\tdisp0_ctrl |= DSI_DISP0_ENABLE;\n\tDSI_PORT_WRITE(DISP0_CTRL, disp0_ctrl);\n\n\tif (debug_dump_regs) {\n\t\tstruct drm_printer p = drm_info_printer(&dsi->pdev->dev);\n\t\tdev_info(&dsi->pdev->dev, \"DSI regs after:\\n\");\n\t\tdrm_print_regset32(&p, &dsi->regset);\n\t}\n}\n\nstatic int vc4_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);\n\n\t \n\treturn drm_bridge_attach(bridge->encoder, dsi->out_bridge,\n\t\t\t\t &dsi->bridge, flags);\n}\n\nstatic ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tstruct vc4_dsi *dsi = host_to_dsi(host);\n\tstruct mipi_dsi_packet packet;\n\tu32 pkth = 0, pktc = 0;\n\tint i, ret;\n\tbool is_long = mipi_dsi_packet_format_is_long(msg->type);\n\tu32 cmd_fifo_len = 0, pix_fifo_len = 0;\n\n\tmipi_dsi_create_packet(&packet, msg);\n\n\tpkth |= VC4_SET_FIELD(packet.header[0], DSI_TXPKT1H_BC_DT);\n\tpkth |= VC4_SET_FIELD(packet.header[1] |\n\t\t\t      (packet.header[2] << 8),\n\t\t\t      DSI_TXPKT1H_BC_PARAM);\n\tif (is_long) {\n\t\t \n\t\tif (packet.payload_length <= 16) {\n\t\t\tcmd_fifo_len = packet.payload_length;\n\t\t\tpix_fifo_len = 0;\n\t\t} else {\n\t\t\tcmd_fifo_len = (packet.payload_length %\n\t\t\t\t\tDSI_PIX_FIFO_WIDTH);\n\t\t\tpix_fifo_len = ((packet.payload_length - cmd_fifo_len) /\n\t\t\t\t\tDSI_PIX_FIFO_WIDTH);\n\t\t}\n\n\t\tWARN_ON_ONCE(pix_fifo_len >= DSI_PIX_FIFO_DEPTH);\n\n\t\tpkth |= VC4_SET_FIELD(cmd_fifo_len, DSI_TXPKT1H_BC_CMDFIFO);\n\t}\n\n\tif (msg->rx_len) {\n\t\tpktc |= VC4_SET_FIELD(DSI_TXPKT1C_CMD_CTRL_RX,\n\t\t\t\t      DSI_TXPKT1C_CMD_CTRL);\n\t} else {\n\t\tpktc |= VC4_SET_FIELD(DSI_TXPKT1C_CMD_CTRL_TX,\n\t\t\t\t      DSI_TXPKT1C_CMD_CTRL);\n\t}\n\n\tfor (i = 0; i < cmd_fifo_len; i++)\n\t\tDSI_PORT_WRITE(TXPKT_CMD_FIFO, packet.payload[i]);\n\tfor (i = 0; i < pix_fifo_len; i++) {\n\t\tconst u8 *pix = packet.payload + cmd_fifo_len + i * 4;\n\n\t\tDSI_PORT_WRITE(TXPKT_PIX_FIFO,\n\t\t\t       pix[0] |\n\t\t\t       pix[1] << 8 |\n\t\t\t       pix[2] << 16 |\n\t\t\t       pix[3] << 24);\n\t}\n\n\tif (msg->flags & MIPI_DSI_MSG_USE_LPM)\n\t\tpktc |= DSI_TXPKT1C_CMD_MODE_LP;\n\tif (is_long)\n\t\tpktc |= DSI_TXPKT1C_CMD_TYPE_LONG;\n\n\t \n\tpktc |= VC4_SET_FIELD(1, DSI_TXPKT1C_CMD_REPEAT);\n\n\tpktc |= DSI_TXPKT1C_CMD_EN;\n\tif (pix_fifo_len) {\n\t\tpktc |= VC4_SET_FIELD(DSI_TXPKT1C_DISPLAY_NO_SECONDARY,\n\t\t\t\t      DSI_TXPKT1C_DISPLAY_NO);\n\t} else {\n\t\tpktc |= VC4_SET_FIELD(DSI_TXPKT1C_DISPLAY_NO_SHORT,\n\t\t\t\t      DSI_TXPKT1C_DISPLAY_NO);\n\t}\n\n\t \n\tdsi->xfer_result = 0;\n\treinit_completion(&dsi->xfer_completion);\n\tif (dsi->variant->port == 0) {\n\t\tDSI_PORT_WRITE(INT_STAT,\n\t\t\t       DSI0_INT_CMDC_DONE_MASK | DSI1_INT_PHY_DIR_RTF);\n\t\tif (msg->rx_len) {\n\t\t\tDSI_PORT_WRITE(INT_EN, (DSI0_INTERRUPTS_ALWAYS_ENABLED |\n\t\t\t\t\t\tDSI0_INT_PHY_DIR_RTF));\n\t\t} else {\n\t\t\tDSI_PORT_WRITE(INT_EN,\n\t\t\t\t       (DSI0_INTERRUPTS_ALWAYS_ENABLED |\n\t\t\t\t\tVC4_SET_FIELD(DSI0_INT_CMDC_DONE_NO_REPEAT,\n\t\t\t\t\t\t      DSI0_INT_CMDC_DONE)));\n\t\t}\n\t} else {\n\t\tDSI_PORT_WRITE(INT_STAT,\n\t\t\t       DSI1_INT_TXPKT1_DONE | DSI1_INT_PHY_DIR_RTF);\n\t\tif (msg->rx_len) {\n\t\t\tDSI_PORT_WRITE(INT_EN, (DSI1_INTERRUPTS_ALWAYS_ENABLED |\n\t\t\t\t\t\tDSI1_INT_PHY_DIR_RTF));\n\t\t} else {\n\t\t\tDSI_PORT_WRITE(INT_EN, (DSI1_INTERRUPTS_ALWAYS_ENABLED |\n\t\t\t\t\t\tDSI1_INT_TXPKT1_DONE));\n\t\t}\n\t}\n\n\t \n\tDSI_PORT_WRITE(TXPKT1H, pkth);\n\tDSI_PORT_WRITE(TXPKT1C, pktc);\n\n\tif (!wait_for_completion_timeout(&dsi->xfer_completion,\n\t\t\t\t\t msecs_to_jiffies(1000))) {\n\t\tdev_err(&dsi->pdev->dev, \"transfer interrupt wait timeout\");\n\t\tdev_err(&dsi->pdev->dev, \"instat: 0x%08x\\n\",\n\t\t\tDSI_PORT_READ(INT_STAT));\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = dsi->xfer_result;\n\t}\n\n\tDSI_PORT_WRITE(INT_EN, DSI_PORT_BIT(INTERRUPTS_ALWAYS_ENABLED));\n\n\tif (ret)\n\t\tgoto reset_fifo_and_return;\n\n\tif (ret == 0 && msg->rx_len) {\n\t\tu32 rxpkt1h = DSI_PORT_READ(RXPKT1H);\n\t\tu8 *msg_rx = msg->rx_buf;\n\n\t\tif (rxpkt1h & DSI_RXPKT1H_PKT_TYPE_LONG) {\n\t\t\tu32 rxlen = VC4_GET_FIELD(rxpkt1h,\n\t\t\t\t\t\t  DSI_RXPKT1H_BC_PARAM);\n\n\t\t\tif (rxlen != msg->rx_len) {\n\t\t\t\tDRM_ERROR(\"DSI returned %db, expecting %db\\n\",\n\t\t\t\t\t  rxlen, (int)msg->rx_len);\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto reset_fifo_and_return;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < msg->rx_len; i++)\n\t\t\t\tmsg_rx[i] = DSI_READ(DSI1_RXPKT_FIFO);\n\t\t} else {\n\t\t\t \n\n\t\t\tmsg_rx[0] = VC4_GET_FIELD(rxpkt1h,\n\t\t\t\t\t\t  DSI_RXPKT1H_SHORT_0);\n\t\t\tif (msg->rx_len > 1) {\n\t\t\t\tmsg_rx[1] = VC4_GET_FIELD(rxpkt1h,\n\t\t\t\t\t\t\t  DSI_RXPKT1H_SHORT_1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n\nreset_fifo_and_return:\n\tDRM_ERROR(\"DSI transfer failed, resetting: %d\\n\", ret);\n\n\tDSI_PORT_WRITE(TXPKT1C, DSI_PORT_READ(TXPKT1C) & ~DSI_TXPKT1C_CMD_EN);\n\tudelay(1);\n\tDSI_PORT_WRITE(CTRL,\n\t\t       DSI_PORT_READ(CTRL) |\n\t\t       DSI_PORT_BIT(CTRL_RESET_FIFOS));\n\n\tDSI_PORT_WRITE(TXPKT1C, 0);\n\tDSI_PORT_WRITE(INT_EN, DSI_PORT_BIT(INTERRUPTS_ALWAYS_ENABLED));\n\treturn ret;\n}\n\nstatic const struct component_ops vc4_dsi_ops;\nstatic int vc4_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *device)\n{\n\tstruct vc4_dsi *dsi = host_to_dsi(host);\n\tint ret;\n\n\tdsi->lanes = device->lanes;\n\tdsi->channel = device->channel;\n\tdsi->mode_flags = device->mode_flags;\n\n\tswitch (device->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tdsi->format = DSI_PFORMAT_RGB888;\n\t\tdsi->divider = 24 / dsi->lanes;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tdsi->format = DSI_PFORMAT_RGB666;\n\t\tdsi->divider = 24 / dsi->lanes;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tdsi->format = DSI_PFORMAT_RGB666_PACKED;\n\t\tdsi->divider = 18 / dsi->lanes;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tdsi->format = DSI_PFORMAT_RGB565;\n\t\tdsi->divider = 16 / dsi->lanes;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dsi->pdev->dev, \"Unknown DSI format: %d.\\n\",\n\t\t\tdsi->format);\n\t\treturn 0;\n\t}\n\n\tif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO)) {\n\t\tdev_err(&dsi->pdev->dev,\n\t\t\t\"Only VIDEO mode panels supported currently.\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_bridge_add(&dsi->bridge);\n\n\tret = component_add(&dsi->pdev->dev, &vc4_dsi_ops);\n\tif (ret) {\n\t\tdrm_bridge_remove(&dsi->bridge);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t       struct mipi_dsi_device *device)\n{\n\tstruct vc4_dsi *dsi = host_to_dsi(host);\n\n\tcomponent_del(&dsi->pdev->dev, &vc4_dsi_ops);\n\tdrm_bridge_remove(&dsi->bridge);\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops vc4_dsi_host_ops = {\n\t.attach = vc4_dsi_host_attach,\n\t.detach = vc4_dsi_host_detach,\n\t.transfer = vc4_dsi_host_transfer,\n};\n\nstatic const struct drm_bridge_funcs vc4_dsi_bridge_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_pre_enable = vc4_dsi_bridge_pre_enable,\n\t.atomic_enable = vc4_dsi_bridge_enable,\n\t.atomic_disable = vc4_dsi_bridge_disable,\n\t.atomic_post_disable = vc4_dsi_bridge_post_disable,\n\t.attach = vc4_dsi_bridge_attach,\n\t.mode_fixup = vc4_dsi_bridge_mode_fixup,\n};\n\nstatic int vc4_dsi_late_register(struct drm_encoder *encoder)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_dsi *dsi = to_vc4_dsi(encoder);\n\n\tvc4_debugfs_add_regset32(drm, dsi->variant->debugfs_name, &dsi->regset);\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs vc4_dsi_encoder_funcs = {\n\t.late_register = vc4_dsi_late_register,\n};\n\nstatic const struct vc4_dsi_variant bcm2711_dsi1_variant = {\n\t.port\t\t\t= 1,\n\t.debugfs_name\t\t= \"dsi1_regs\",\n\t.regs\t\t\t= dsi1_regs,\n\t.nregs\t\t\t= ARRAY_SIZE(dsi1_regs),\n};\n\nstatic const struct vc4_dsi_variant bcm2835_dsi0_variant = {\n\t.port\t\t\t= 0,\n\t.debugfs_name\t\t= \"dsi0_regs\",\n\t.regs\t\t\t= dsi0_regs,\n\t.nregs\t\t\t= ARRAY_SIZE(dsi0_regs),\n};\n\nstatic const struct vc4_dsi_variant bcm2835_dsi1_variant = {\n\t.port\t\t\t= 1,\n\t.broken_axi_workaround\t= true,\n\t.debugfs_name\t\t= \"dsi1_regs\",\n\t.regs\t\t\t= dsi1_regs,\n\t.nregs\t\t\t= ARRAY_SIZE(dsi1_regs),\n};\n\nstatic const struct of_device_id vc4_dsi_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2711-dsi1\", &bcm2711_dsi1_variant },\n\t{ .compatible = \"brcm,bcm2835-dsi0\", &bcm2835_dsi0_variant },\n\t{ .compatible = \"brcm,bcm2835-dsi1\", &bcm2835_dsi1_variant },\n\t{}\n};\n\nstatic void dsi_handle_error(struct vc4_dsi *dsi,\n\t\t\t     irqreturn_t *ret, u32 stat, u32 bit,\n\t\t\t     const char *type)\n{\n\tif (!(stat & bit))\n\t\treturn;\n\n\tDRM_ERROR(\"DSI%d: %s error\\n\", dsi->variant->port, type);\n\t*ret = IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t vc4_dsi_irq_defer_to_thread_handler(int irq, void *data)\n{\n\tstruct vc4_dsi *dsi = data;\n\tu32 stat = DSI_PORT_READ(INT_STAT);\n\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t vc4_dsi_irq_handler(int irq, void *data)\n{\n\tstruct vc4_dsi *dsi = data;\n\tu32 stat = DSI_PORT_READ(INT_STAT);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tDSI_PORT_WRITE(INT_STAT, stat);\n\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_ERR_SYNC_ESC), \"LPDT sync\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_ERR_CONTROL), \"data lane 0 sequence\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_ERR_CONT_LP0), \"LP0 contention\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_ERR_CONT_LP1), \"LP1 contention\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_HSTX_TO), \"HSTX timeout\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_LPRX_TO), \"LPRX timeout\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_TA_TO), \"turnaround timeout\");\n\tdsi_handle_error(dsi, &ret, stat,\n\t\t\t DSI_PORT_BIT(INT_PR_TO), \"peripheral reset timeout\");\n\n\tif (stat & ((dsi->variant->port ? DSI1_INT_TXPKT1_DONE :\n\t\t\t\t\t  DSI0_INT_CMDC_DONE_MASK) |\n\t\t    DSI_PORT_BIT(INT_PHY_DIR_RTF))) {\n\t\tcomplete(&dsi->xfer_completion);\n\t\tret = IRQ_HANDLED;\n\t} else if (stat & DSI_PORT_BIT(INT_HSTX_TO)) {\n\t\tcomplete(&dsi->xfer_completion);\n\t\tdsi->xfer_result = -ETIMEDOUT;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nvc4_dsi_init_phy_clocks(struct vc4_dsi *dsi)\n{\n\tstruct device *dev = &dsi->pdev->dev;\n\tconst char *parent_name = __clk_get_name(dsi->pll_phy_clock);\n\tstatic const struct {\n\t\tconst char *name;\n\t\tint div;\n\t} phy_clocks[] = {\n\t\t{ \"byte\", 8 },\n\t\t{ \"ddr2\", 4 },\n\t\t{ \"ddr\", 2 },\n\t};\n\tint i;\n\n\tdsi->clk_onecell = devm_kzalloc(dev,\n\t\t\t\t\tsizeof(*dsi->clk_onecell) +\n\t\t\t\t\tARRAY_SIZE(phy_clocks) *\n\t\t\t\t\tsizeof(struct clk_hw *),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!dsi->clk_onecell)\n\t\treturn -ENOMEM;\n\tdsi->clk_onecell->num = ARRAY_SIZE(phy_clocks);\n\n\tfor (i = 0; i < ARRAY_SIZE(phy_clocks); i++) {\n\t\tstruct clk_fixed_factor *fix = &dsi->phy_clocks[i];\n\t\tstruct clk_init_data init;\n\t\tchar clk_name[16];\n\t\tint ret;\n\n\t\tsnprintf(clk_name, sizeof(clk_name),\n\t\t\t \"dsi%u_%s\", dsi->variant->port, phy_clocks[i].name);\n\n\t\t \n\t\tfix->mult = 1;\n\t\tfix->div = phy_clocks[i].div;\n\t\tfix->hw.init = &init;\n\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.parent_names = &parent_name;\n\t\tinit.num_parents = 1;\n\t\tinit.name = clk_name;\n\t\tinit.ops = &clk_fixed_factor_ops;\n\n\t\tret = devm_clk_hw_register(dev, &fix->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdsi->clk_onecell->hws[i] = &fix->hw;\n\t}\n\n\treturn of_clk_add_hw_provider(dev->of_node,\n\t\t\t\t      of_clk_hw_onecell_get,\n\t\t\t\t      dsi->clk_onecell);\n}\n\nstatic void vc4_dsi_dma_mem_release(void *ptr)\n{\n\tstruct vc4_dsi *dsi = ptr;\n\tstruct device *dev = &dsi->pdev->dev;\n\n\tdma_free_coherent(dev, 4, dsi->reg_dma_mem, dsi->reg_dma_paddr);\n\tdsi->reg_dma_mem = NULL;\n}\n\nstatic void vc4_dsi_dma_chan_release(void *ptr)\n{\n\tstruct vc4_dsi *dsi = ptr;\n\n\tdma_release_channel(dsi->reg_dma_chan);\n\tdsi->reg_dma_chan = NULL;\n}\n\nstatic void vc4_dsi_release(struct kref *kref)\n{\n\tstruct vc4_dsi *dsi =\n\t\tcontainer_of(kref, struct vc4_dsi, kref);\n\n\tkfree(dsi);\n}\n\nstatic void vc4_dsi_get(struct vc4_dsi *dsi)\n{\n\tkref_get(&dsi->kref);\n}\n\nstatic void vc4_dsi_put(struct vc4_dsi *dsi)\n{\n\tkref_put(&dsi->kref, &vc4_dsi_release);\n}\n\nstatic void vc4_dsi_release_action(struct drm_device *drm, void *ptr)\n{\n\tstruct vc4_dsi *dsi = ptr;\n\n\tvc4_dsi_put(dsi);\n}\n\nstatic int vc4_dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dsi *dsi = dev_get_drvdata(dev);\n\tstruct drm_encoder *encoder = &dsi->encoder.base;\n\tint ret;\n\n\tvc4_dsi_get(dsi);\n\n\tret = drmm_add_action_or_reset(drm, vc4_dsi_release_action, dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tdsi->variant = of_device_get_match_data(dev);\n\n\tdsi->encoder.type = dsi->variant->port ?\n\t\tVC4_ENCODER_TYPE_DSI1 : VC4_ENCODER_TYPE_DSI0;\n\n\tdsi->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(dsi->regs))\n\t\treturn PTR_ERR(dsi->regs);\n\n\tdsi->regset.base = dsi->regs;\n\tdsi->regset.regs = dsi->variant->regs;\n\tdsi->regset.nregs = dsi->variant->nregs;\n\n\tif (DSI_PORT_READ(ID) != DSI_ID_VALUE) {\n\t\tdev_err(dev, \"Port returned 0x%08x for ID instead of 0x%08x\\n\",\n\t\t\tDSI_PORT_READ(ID), DSI_ID_VALUE);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (dsi->variant->broken_axi_workaround) {\n\t\tdma_cap_mask_t dma_mask;\n\n\t\tdsi->reg_dma_mem = dma_alloc_coherent(dev, 4,\n\t\t\t\t\t\t      &dsi->reg_dma_paddr,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!dsi->reg_dma_mem) {\n\t\t\tDRM_ERROR(\"Failed to get DMA memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, vc4_dsi_dma_mem_release, dsi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdma_cap_zero(dma_mask);\n\t\tdma_cap_set(DMA_MEMCPY, dma_mask);\n\n\t\tdsi->reg_dma_chan = dma_request_chan_by_mask(&dma_mask);\n\t\tif (IS_ERR(dsi->reg_dma_chan)) {\n\t\t\tret = PTR_ERR(dsi->reg_dma_chan);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tDRM_ERROR(\"Failed to get DMA channel: %d\\n\",\n\t\t\t\t\t  ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, vc4_dsi_dma_chan_release, dsi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tdsi->reg_paddr = be32_to_cpup(of_get_address(dev->of_node,\n\t\t\t\t\t\t\t     0, NULL, NULL));\n\t}\n\n\tinit_completion(&dsi->xfer_completion);\n\t \n\tDSI_PORT_WRITE(INT_EN, DSI1_INTERRUPTS_ALWAYS_ENABLED);\n\t \n\tDSI_PORT_WRITE(INT_STAT, DSI_PORT_READ(INT_STAT));\n\n\tif (dsi->reg_dma_mem)\n\t\tret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0),\n\t\t\t\t\t\tvc4_dsi_irq_defer_to_thread_handler,\n\t\t\t\t\t\tvc4_dsi_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"vc4 dsi\", dsi);\n\telse\n\t\tret = devm_request_irq(dev, platform_get_irq(pdev, 0),\n\t\t\t\t       vc4_dsi_irq_handler, 0, \"vc4 dsi\", dsi);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get interrupt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->escape_clock = devm_clk_get(dev, \"escape\");\n\tif (IS_ERR(dsi->escape_clock)) {\n\t\tret = PTR_ERR(dsi->escape_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get escape clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->pll_phy_clock = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(dsi->pll_phy_clock)) {\n\t\tret = PTR_ERR(dsi->pll_phy_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get phy clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->pixel_clock = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(dsi->pixel_clock)) {\n\t\tret = PTR_ERR(dsi->pixel_clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get pixel clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdsi->out_bridge = drmm_of_get_bridge(drm, dev->of_node, 0, 0);\n\tif (IS_ERR(dsi->out_bridge))\n\t\treturn PTR_ERR(dsi->out_bridge);\n\n\t \n\tret = clk_set_rate(dsi->escape_clock, 100 * 1000000);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set esc clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = vc4_dsi_init_phy_clocks(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_encoder_init(drm, encoder,\n\t\t\t\t&vc4_dsi_encoder_funcs,\n\t\t\t\tDRM_MODE_ENCODER_DSI,\n\t\t\t\tNULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_bridge_attach(encoder, &dsi->bridge, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct component_ops vc4_dsi_ops = {\n\t.bind   = vc4_dsi_bind,\n};\n\nstatic int vc4_dsi_dev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vc4_dsi *dsi;\n\n\tdsi = kzalloc(sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, dsi);\n\n\tkref_init(&dsi->kref);\n\n\tdsi->pdev = pdev;\n\tdsi->bridge.funcs = &vc4_dsi_bridge_funcs;\n#ifdef CONFIG_OF\n\tdsi->bridge.of_node = dev->of_node;\n#endif\n\tdsi->bridge.type = DRM_MODE_CONNECTOR_DSI;\n\tdsi->dsi_host.ops = &vc4_dsi_host_ops;\n\tdsi->dsi_host.dev = dev;\n\tmipi_dsi_host_register(&dsi->dsi_host);\n\n\treturn 0;\n}\n\nstatic void vc4_dsi_dev_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vc4_dsi *dsi = dev_get_drvdata(dev);\n\n\tmipi_dsi_host_unregister(&dsi->dsi_host);\n\tvc4_dsi_put(dsi);\n}\n\nstruct platform_driver vc4_dsi_driver = {\n\t.probe = vc4_dsi_dev_probe,\n\t.remove_new = vc4_dsi_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_dsi\",\n\t\t.of_match_table = vc4_dsi_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}