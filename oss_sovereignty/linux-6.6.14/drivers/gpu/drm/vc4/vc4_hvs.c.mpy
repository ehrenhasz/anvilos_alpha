{
  "module_name": "vc4_hvs.c",
  "hash_id": "f2f17e3161f4d5b88c7fd74f3656841e6de0b7bf10033284a335d9aed2062455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_hvs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_vblank.h>\n\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\nstatic const struct debugfs_reg32 hvs_regs[] = {\n\tVC4_REG32(SCALER_DISPCTRL),\n\tVC4_REG32(SCALER_DISPSTAT),\n\tVC4_REG32(SCALER_DISPID),\n\tVC4_REG32(SCALER_DISPECTRL),\n\tVC4_REG32(SCALER_DISPPROF),\n\tVC4_REG32(SCALER_DISPDITHER),\n\tVC4_REG32(SCALER_DISPEOLN),\n\tVC4_REG32(SCALER_DISPLIST0),\n\tVC4_REG32(SCALER_DISPLIST1),\n\tVC4_REG32(SCALER_DISPLIST2),\n\tVC4_REG32(SCALER_DISPLSTAT),\n\tVC4_REG32(SCALER_DISPLACT0),\n\tVC4_REG32(SCALER_DISPLACT1),\n\tVC4_REG32(SCALER_DISPLACT2),\n\tVC4_REG32(SCALER_DISPCTRL0),\n\tVC4_REG32(SCALER_DISPBKGND0),\n\tVC4_REG32(SCALER_DISPSTAT0),\n\tVC4_REG32(SCALER_DISPBASE0),\n\tVC4_REG32(SCALER_DISPCTRL1),\n\tVC4_REG32(SCALER_DISPBKGND1),\n\tVC4_REG32(SCALER_DISPSTAT1),\n\tVC4_REG32(SCALER_DISPBASE1),\n\tVC4_REG32(SCALER_DISPCTRL2),\n\tVC4_REG32(SCALER_DISPBKGND2),\n\tVC4_REG32(SCALER_DISPSTAT2),\n\tVC4_REG32(SCALER_DISPBASE2),\n\tVC4_REG32(SCALER_DISPALPHA2),\n\tVC4_REG32(SCALER_OLEDOFFS),\n\tVC4_REG32(SCALER_OLEDCOEF0),\n\tVC4_REG32(SCALER_OLEDCOEF1),\n\tVC4_REG32(SCALER_OLEDCOEF2),\n};\n\nvoid vc4_hvs_dump_state(struct vc4_hvs *hvs)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tstruct drm_printer p = drm_info_printer(&hvs->pdev->dev);\n\tint idx, i;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tdrm_print_regset32(&p, &hvs->regset);\n\n\tDRM_INFO(\"HVS ctx:\\n\");\n\tfor (i = 0; i < 64; i += 4) {\n\t\tDRM_INFO(\"0x%08x (%s): 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t i * 4, i < HVS_BOOTLOADER_DLIST_END ? \"B\" : \"D\",\n\t\t\t readl((u32 __iomem *)hvs->dlist + i + 0),\n\t\t\t readl((u32 __iomem *)hvs->dlist + i + 1),\n\t\t\t readl((u32 __iomem *)hvs->dlist + i + 2),\n\t\t\t readl((u32 __iomem *)hvs->dlist + i + 3));\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nstatic int vc4_hvs_debugfs_underrun(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tdrm_printf(&p, \"%d\\n\", atomic_read(&vc4->underrun));\n\n\treturn 0;\n}\n\nstatic int vc4_hvs_debugfs_dlist(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tunsigned int next_entry_start = 0;\n\tunsigned int i, j;\n\tu32 dlist_word, dispstat;\n\n\tfor (i = 0; i < SCALER_CHANNELS_COUNT; i++) {\n\t\tdispstat = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTATX(i)),\n\t\t\t\t\t SCALER_DISPSTATX_MODE);\n\t\tif (dispstat == SCALER_DISPSTATX_MODE_DISABLED ||\n\t\t    dispstat == SCALER_DISPSTATX_MODE_EOF) {\n\t\t\tdrm_printf(&p, \"HVS chan %u disabled\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_printf(&p, \"HVS chan %u:\\n\", i);\n\n\t\tfor (j = HVS_READ(SCALER_DISPLISTX(i)); j < 256; j++) {\n\t\t\tdlist_word = readl((u32 __iomem *)vc4->hvs->dlist + j);\n\t\t\tdrm_printf(&p, \"dlist: %02d: 0x%08x\\n\", j,\n\t\t\t\t   dlist_word);\n\t\t\tif (!next_entry_start ||\n\t\t\t    next_entry_start == j) {\n\t\t\t\tif (dlist_word & SCALER_CTL0_END)\n\t\t\t\t\tbreak;\n\t\t\t\tnext_entry_start = j +\n\t\t\t\t\tVC4_GET_FIELD(dlist_word,\n\t\t\t\t\t\t      SCALER_CTL0_SIZE);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define VC4_INT_TO_COEFF(coeff) (coeff & 0x1ff)\n#define VC4_PPF_FILTER_WORD(c0, c1, c2)\t\t\t\t\\\n\t((((c0) & 0x1ff) << 0) |\t\t\t\t\\\n\t (((c1) & 0x1ff) << 9) |\t\t\t\t\\\n\t (((c2) & 0x1ff) << 18))\n\n \n#define VC4_LINEAR_PHASE_KERNEL(c0, c1, c2, c3, c4, c5, c6, c7, c8,\t\\\n\t\t\t\tc9, c10, c11, c12, c13, c14, c15)\t\\\n\t{VC4_PPF_FILTER_WORD(c0, c1, c2),\t\t\t\t\\\n\t VC4_PPF_FILTER_WORD(c3, c4, c5),\t\t\t\t\\\n\t VC4_PPF_FILTER_WORD(c6, c7, c8),\t\t\t\t\\\n\t VC4_PPF_FILTER_WORD(c9, c10, c11),\t\t\t\t\\\n\t VC4_PPF_FILTER_WORD(c12, c13, c14),\t\t\t\t\\\n\t VC4_PPF_FILTER_WORD(c15, c15, 0)}\n\n#define VC4_LINEAR_PHASE_KERNEL_DWORDS 6\n#define VC4_KERNEL_DWORDS (VC4_LINEAR_PHASE_KERNEL_DWORDS * 2 - 1)\n\n \nstatic const u32 mitchell_netravali_1_3_1_3_kernel[] =\n\tVC4_LINEAR_PHASE_KERNEL(0, -2, -6, -8, -10, -8, -3, 2, 18,\n\t\t\t\t50, 82, 119, 155, 187, 213, 227);\n\nstatic int vc4_hvs_upload_linear_kernel(struct vc4_hvs *hvs,\n\t\t\t\t\tstruct drm_mm_node *space,\n\t\t\t\t\tconst u32 *kernel)\n{\n\tint ret, i;\n\tu32 __iomem *dst_kernel;\n\n\t \n\n\tret = drm_mm_insert_node(&hvs->dlist_mm, space, VC4_KERNEL_DWORDS);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to allocate space for filter kernel: %d\\n\",\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tdst_kernel = hvs->dlist + space->start;\n\n\tfor (i = 0; i < VC4_KERNEL_DWORDS; i++) {\n\t\tif (i < VC4_LINEAR_PHASE_KERNEL_DWORDS)\n\t\t\twritel(kernel[i], &dst_kernel[i]);\n\t\telse {\n\t\t\twritel(kernel[VC4_KERNEL_DWORDS - i - 1],\n\t\t\t       &dst_kernel[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vc4_hvs_lut_load(struct vc4_hvs *hvs,\n\t\t\t     struct vc4_crtc *vc4_crtc)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tstruct drm_crtc *crtc = &vc4_crtc->base;\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);\n\tint idx;\n\tu32 i;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\t \n\tHVS_WRITE(SCALER_GAMADDR,\n\t\t  SCALER_GAMADDR_AUTOINC |\n\t\t  (vc4_state->assigned_channel * 3 * crtc->gamma_size));\n\n\tfor (i = 0; i < crtc->gamma_size; i++)\n\t\tHVS_WRITE(SCALER_GAMDATA, vc4_crtc->lut_r[i]);\n\tfor (i = 0; i < crtc->gamma_size; i++)\n\t\tHVS_WRITE(SCALER_GAMDATA, vc4_crtc->lut_g[i]);\n\tfor (i = 0; i < crtc->gamma_size; i++)\n\t\tHVS_WRITE(SCALER_GAMDATA, vc4_crtc->lut_b[i]);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hvs_update_gamma_lut(struct vc4_hvs *hvs,\n\t\t\t\t     struct vc4_crtc *vc4_crtc)\n{\n\tstruct drm_crtc_state *crtc_state = vc4_crtc->base.state;\n\tstruct drm_color_lut *lut = crtc_state->gamma_lut->data;\n\tu32 length = drm_color_lut_size(crtc_state->gamma_lut);\n\tu32 i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tvc4_crtc->lut_r[i] = drm_color_lut_extract(lut[i].red, 8);\n\t\tvc4_crtc->lut_g[i] = drm_color_lut_extract(lut[i].green, 8);\n\t\tvc4_crtc->lut_b[i] = drm_color_lut_extract(lut[i].blue, 8);\n\t}\n\n\tvc4_hvs_lut_load(hvs, vc4_crtc);\n}\n\nu8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tu8 field = 0;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn 0;\n\n\tswitch (fifo) {\n\tcase 0:\n\t\tfield = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),\n\t\t\t\t      SCALER_DISPSTAT1_FRCNT0);\n\t\tbreak;\n\tcase 1:\n\t\tfield = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),\n\t\t\t\t      SCALER_DISPSTAT1_FRCNT1);\n\t\tbreak;\n\tcase 2:\n\t\tfield = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT2),\n\t\t\t\t      SCALER_DISPSTAT2_FRCNT2);\n\t\tbreak;\n\t}\n\n\tdrm_dev_exit(idx);\n\treturn field;\n}\n\nint vc4_hvs_get_fifo_from_output(struct vc4_hvs *hvs, unsigned int output)\n{\n\tstruct vc4_dev *vc4 = hvs->vc4;\n\tu32 reg;\n\tint ret;\n\n\tif (!vc4->is_vc5)\n\t\treturn output;\n\n\t \n\n\tswitch (output) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase 1:\n\t\treturn 1;\n\n\tcase 2:\n\t\treg = HVS_READ(SCALER_DISPECTRL);\n\t\tret = FIELD_GET(SCALER_DISPECTRL_DSP2_MUX_MASK, reg);\n\t\tif (ret == 0)\n\t\t\treturn 2;\n\n\t\treturn 0;\n\n\tcase 3:\n\t\treg = HVS_READ(SCALER_DISPCTRL);\n\t\tret = FIELD_GET(SCALER_DISPCTRL_DSP3_MUX_MASK, reg);\n\t\tif (ret == 3)\n\t\t\treturn -EPIPE;\n\n\t\treturn ret;\n\n\tcase 4:\n\t\treg = HVS_READ(SCALER_DISPEOLN);\n\t\tret = FIELD_GET(SCALER_DISPEOLN_DSP4_MUX_MASK, reg);\n\t\tif (ret == 3)\n\t\t\treturn -EPIPE;\n\n\t\treturn ret;\n\n\tcase 5:\n\t\treg = HVS_READ(SCALER_DISPDITHER);\n\t\tret = FIELD_GET(SCALER_DISPDITHER_DSP5_MUX_MASK, reg);\n\t\tif (ret == 3)\n\t\t\treturn -EPIPE;\n\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n}\n\nstatic int vc4_hvs_init_channel(struct vc4_hvs *hvs, struct drm_crtc *crtc,\n\t\t\t\tstruct drm_display_mode *mode, bool oneshot)\n{\n\tstruct vc4_dev *vc4 = hvs->vc4;\n\tstruct drm_device *drm = &vc4->base;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct vc4_crtc_state *vc4_crtc_state = to_vc4_crtc_state(crtc->state);\n\tunsigned int chan = vc4_crtc_state->assigned_channel;\n\tbool interlace = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\tu32 dispbkgndx;\n\tu32 dispctrl;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn -ENODEV;\n\n\tHVS_WRITE(SCALER_DISPCTRLX(chan), 0);\n\tHVS_WRITE(SCALER_DISPCTRLX(chan), SCALER_DISPCTRLX_RESET);\n\tHVS_WRITE(SCALER_DISPCTRLX(chan), 0);\n\n\t \n\tdispctrl = SCALER_DISPCTRLX_ENABLE;\n\tdispbkgndx = HVS_READ(SCALER_DISPBKGNDX(chan));\n\n\tif (!vc4->is_vc5) {\n\t\tdispctrl |= VC4_SET_FIELD(mode->hdisplay,\n\t\t\t\t\t  SCALER_DISPCTRLX_WIDTH) |\n\t\t\t    VC4_SET_FIELD(mode->vdisplay,\n\t\t\t\t\t  SCALER_DISPCTRLX_HEIGHT) |\n\t\t\t    (oneshot ? SCALER_DISPCTRLX_ONESHOT : 0);\n\t\tdispbkgndx |= SCALER_DISPBKGND_AUTOHS;\n\t} else {\n\t\tdispctrl |= VC4_SET_FIELD(mode->hdisplay,\n\t\t\t\t\t  SCALER5_DISPCTRLX_WIDTH) |\n\t\t\t    VC4_SET_FIELD(mode->vdisplay,\n\t\t\t\t\t  SCALER5_DISPCTRLX_HEIGHT) |\n\t\t\t    (oneshot ? SCALER5_DISPCTRLX_ONESHOT : 0);\n\t\tdispbkgndx &= ~SCALER5_DISPBKGND_BCK2BCK;\n\t}\n\n\tHVS_WRITE(SCALER_DISPCTRLX(chan), dispctrl);\n\n\tdispbkgndx &= ~SCALER_DISPBKGND_GAMMA;\n\tdispbkgndx &= ~SCALER_DISPBKGND_INTERLACE;\n\n\tHVS_WRITE(SCALER_DISPBKGNDX(chan), dispbkgndx |\n\t\t  ((!vc4->is_vc5) ? SCALER_DISPBKGND_GAMMA : 0) |\n\t\t  (interlace ? SCALER_DISPBKGND_INTERLACE : 0));\n\n\t \n\tvc4_hvs_lut_load(hvs, vc4_crtc);\n\n\tdrm_dev_exit(idx);\n\n\treturn 0;\n}\n\nvoid vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tif (HVS_READ(SCALER_DISPCTRLX(chan)) & SCALER_DISPCTRLX_ENABLE)\n\t\tgoto out;\n\n\tHVS_WRITE(SCALER_DISPCTRLX(chan),\n\t\t  HVS_READ(SCALER_DISPCTRLX(chan)) | SCALER_DISPCTRLX_RESET);\n\tHVS_WRITE(SCALER_DISPCTRLX(chan),\n\t\t  HVS_READ(SCALER_DISPCTRLX(chan)) & ~SCALER_DISPCTRLX_ENABLE);\n\n\t \n\tWARN_ON_ONCE(HVS_READ(SCALER_DISPCTRLX(chan)) & SCALER_DISPCTRLX_RESET);\n\n\tWARN_ON_ONCE(VC4_GET_FIELD(HVS_READ(SCALER_DISPSTATX(chan)),\n\t\t\t\t   SCALER_DISPSTATX_MODE) !=\n\t\t     SCALER_DISPSTATX_MODE_DISABLED);\n\n\tWARN_ON_ONCE((HVS_READ(SCALER_DISPSTATX(chan)) &\n\t\t      (SCALER_DISPSTATX_FULL | SCALER_DISPSTATX_EMPTY)) !=\n\t\t     SCALER_DISPSTATX_EMPTY);\n\nout:\n\tdrm_dev_exit(idx);\n}\n\nint vc4_hvs_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_plane *plane;\n\tunsigned long flags;\n\tconst struct drm_plane_state *plane_state;\n\tu32 dlist_count = 0;\n\tint ret;\n\n\t \n\tif (hweight32(crtc_state->connector_mask) > 1)\n\t\treturn -EINVAL;\n\n\tdrm_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state)\n\t\tdlist_count += vc4_plane_dlist_size(plane_state);\n\n\tdlist_count++;  \n\n\tspin_lock_irqsave(&vc4->hvs->mm_lock, flags);\n\tret = drm_mm_insert_node(&vc4->hvs->dlist_mm, &vc4_state->mm,\n\t\t\t\t dlist_count);\n\tspin_unlock_irqrestore(&vc4->hvs->mm_lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void vc4_hvs_install_dlist(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx))\n\t\treturn;\n\n\tHVS_WRITE(SCALER_DISPLISTX(vc4_state->assigned_channel),\n\t\t  vc4_state->mm.start);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hvs_update_dlist(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);\n\tunsigned long flags;\n\n\tif (crtc->state->event) {\n\t\tcrtc->state->event->pipe = drm_crtc_index(crtc);\n\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t\tif (!vc4_crtc->feeds_txp || vc4_state->txp_armed) {\n\t\t\tvc4_crtc->event = crtc->state->event;\n\t\t\tcrtc->state->event = NULL;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\tspin_lock_irqsave(&vc4_crtc->irq_lock, flags);\n\tvc4_crtc->current_dlist = vc4_state->mm.start;\n\tspin_unlock_irqrestore(&vc4_crtc->irq_lock, flags);\n}\n\nvoid vc4_hvs_atomic_begin(struct drm_crtc *crtc,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vc4_crtc->irq_lock, flags);\n\tvc4_crtc->current_hvs_channel = vc4_state->assigned_channel;\n\tspin_unlock_irqrestore(&vc4_crtc->irq_lock, flags);\n}\n\nvoid vc4_hvs_atomic_enable(struct drm_crtc *crtc,\n\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tbool oneshot = vc4_crtc->feeds_txp;\n\n\tvc4_hvs_install_dlist(crtc);\n\tvc4_hvs_update_dlist(crtc);\n\tvc4_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);\n}\n\nvoid vc4_hvs_atomic_disable(struct drm_crtc *crtc,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state, crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(old_state);\n\tunsigned int chan = vc4_state->assigned_channel;\n\n\tvc4_hvs_stop_channel(vc4->hvs, chan);\n}\n\nvoid vc4_hvs_atomic_flush(struct drm_crtc *crtc,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tstruct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);\n\tstruct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);\n\tunsigned int channel = vc4_state->assigned_channel;\n\tstruct drm_plane *plane;\n\tstruct vc4_plane_state *vc4_plane_state;\n\tbool debug_dump_regs = false;\n\tbool enable_bg_fill = false;\n\tu32 __iomem *dlist_start = vc4->hvs->dlist + vc4_state->mm.start;\n\tu32 __iomem *dlist_next = dlist_start;\n\tunsigned int zpos = 0;\n\tbool found = false;\n\tint idx;\n\n\tif (!drm_dev_enter(dev, &idx)) {\n\t\tvc4_crtc_send_vblank(crtc);\n\t\treturn;\n\t}\n\n\tif (vc4_state->assigned_channel == VC4_HVS_CHANNEL_DISABLED)\n\t\treturn;\n\n\tif (debug_dump_regs) {\n\t\tDRM_INFO(\"CRTC %d HVS before:\\n\", drm_crtc_index(crtc));\n\t\tvc4_hvs_dump_state(hvs);\n\t}\n\n\t \n\tdo {\n\t\tfound = false;\n\n\t\tdrm_atomic_crtc_for_each_plane(plane, crtc) {\n\t\t\tif (plane->state->normalized_zpos != zpos)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (dlist_next == dlist_start) {\n\t\t\t\t \n\t\t\t\tvc4_plane_state = to_vc4_plane_state(plane->state);\n\t\t\t\tenable_bg_fill = vc4_plane_state->needs_bg_fill;\n\t\t\t}\n\n\t\t\tdlist_next += vc4_plane_write_dlist(plane, dlist_next);\n\n\t\t\tfound = true;\n\t\t}\n\n\t\tzpos++;\n\t} while (found);\n\n\twritel(SCALER_CTL0_END, dlist_next);\n\tdlist_next++;\n\n\tWARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm.size);\n\n\tif (enable_bg_fill)\n\t\t \n\t\tHVS_WRITE(SCALER_DISPBKGNDX(channel),\n\t\t\t  HVS_READ(SCALER_DISPBKGNDX(channel)) |\n\t\t\t  SCALER_DISPBKGND_FILL);\n\n\t \n\tif (crtc->state->active && old_state->active) {\n\t\tvc4_hvs_install_dlist(crtc);\n\t\tvc4_hvs_update_dlist(crtc);\n\t}\n\n\tif (crtc->state->color_mgmt_changed) {\n\t\tu32 dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(channel));\n\n\t\tif (crtc->state->gamma_lut) {\n\t\t\tvc4_hvs_update_gamma_lut(hvs, vc4_crtc);\n\t\t\tdispbkgndx |= SCALER_DISPBKGND_GAMMA;\n\t\t} else {\n\t\t\t \n\t\t\tdispbkgndx &= ~SCALER_DISPBKGND_GAMMA;\n\t\t}\n\t\tHVS_WRITE(SCALER_DISPBKGNDX(channel), dispbkgndx);\n\t}\n\n\tif (debug_dump_regs) {\n\t\tDRM_INFO(\"CRTC %d HVS after:\\n\", drm_crtc_index(crtc));\n\t\tvc4_hvs_dump_state(hvs);\n\t}\n\n\tdrm_dev_exit(idx);\n}\n\nvoid vc4_hvs_mask_underrun(struct vc4_hvs *hvs, int channel)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tu32 dispctrl;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tdispctrl = HVS_READ(SCALER_DISPCTRL);\n\tdispctrl &= ~(hvs->vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :\n\t\t\t\t\t SCALER_DISPCTRL_DSPEISLUR(channel));\n\n\tHVS_WRITE(SCALER_DISPCTRL, dispctrl);\n\n\tdrm_dev_exit(idx);\n}\n\nvoid vc4_hvs_unmask_underrun(struct vc4_hvs *hvs, int channel)\n{\n\tstruct drm_device *drm = &hvs->vc4->base;\n\tu32 dispctrl;\n\tint idx;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tdispctrl = HVS_READ(SCALER_DISPCTRL);\n\tdispctrl |= (hvs->vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :\n\t\t\t\t\tSCALER_DISPCTRL_DSPEISLUR(channel));\n\n\tHVS_WRITE(SCALER_DISPSTAT,\n\t\t  SCALER_DISPSTAT_EUFLOW(channel));\n\tHVS_WRITE(SCALER_DISPCTRL, dispctrl);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_hvs_report_underrun(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\tatomic_inc(&vc4->underrun);\n\tDRM_DEV_ERROR(dev->dev, \"HVS underrun\\n\");\n}\n\nstatic irqreturn_t vc4_hvs_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *dev = data;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tirqreturn_t irqret = IRQ_NONE;\n\tint channel;\n\tu32 control;\n\tu32 status;\n\tu32 dspeislur;\n\n\t \n\n\tstatus = HVS_READ(SCALER_DISPSTAT);\n\tcontrol = HVS_READ(SCALER_DISPCTRL);\n\n\tfor (channel = 0; channel < SCALER_CHANNELS_COUNT; channel++) {\n\t\tdspeislur = vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :\n\t\t\t\t\t  SCALER_DISPCTRL_DSPEISLUR(channel);\n\t\t \n\t\tif (status & SCALER_DISPSTAT_EUFLOW(channel) &&\n\t\t    control & dspeislur) {\n\t\t\tvc4_hvs_mask_underrun(hvs, channel);\n\t\t\tvc4_hvs_report_underrun(dev);\n\n\t\t\tirqret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tHVS_WRITE(SCALER_DISPSTAT, SCALER_DISPSTAT_IRQMASK(0) |\n\t\t\t\t   SCALER_DISPSTAT_IRQMASK(1) |\n\t\t\t\t   SCALER_DISPSTAT_IRQMASK(2));\n\n\treturn irqret;\n}\n\nint vc4_hvs_debugfs_init(struct drm_minor *minor)\n{\n\tstruct drm_device *drm = minor->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\n\tif (!vc4->hvs)\n\t\treturn -ENODEV;\n\n\tif (!vc4->is_vc5)\n\t\tdebugfs_create_bool(\"hvs_load_tracker\", S_IRUGO | S_IWUSR,\n\t\t\t\t    minor->debugfs_root,\n\t\t\t\t    &vc4->load_tracker_enabled);\n\n\tdrm_debugfs_add_file(drm, \"hvs_dlists\", vc4_hvs_debugfs_dlist, NULL);\n\n\tdrm_debugfs_add_file(drm, \"hvs_underrun\", vc4_hvs_debugfs_underrun, NULL);\n\n\tvc4_debugfs_add_regset32(drm, \"hvs_regs\", &hvs->regset);\n\n\treturn 0;\n}\n\nstruct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4, struct platform_device *pdev)\n{\n\tstruct drm_device *drm = &vc4->base;\n\tstruct vc4_hvs *hvs;\n\n\thvs = drmm_kzalloc(drm, sizeof(*hvs), GFP_KERNEL);\n\tif (!hvs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thvs->vc4 = vc4;\n\thvs->pdev = pdev;\n\n\tspin_lock_init(&hvs->mm_lock);\n\n\t \n\tdrm_mm_init(&hvs->dlist_mm,\n\t\t    HVS_BOOTLOADER_DLIST_END,\n\t\t    (SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END);\n\n\t \n\tif (!vc4->is_vc5)\n\t\t \n\t\tdrm_mm_init(&hvs->lbm_mm, 0, 48 * 1024);\n\telse\n\t\t \n\t\tdrm_mm_init(&hvs->lbm_mm, 0, 60 * 1024);\n\n\tvc4->hvs = hvs;\n\n\treturn hvs;\n}\n\nstatic int vc4_hvs_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_hvs *hvs = NULL;\n\tint ret;\n\tu32 dispctrl;\n\tu32 reg, top;\n\n\thvs = __vc4_hvs_alloc(vc4, NULL);\n\tif (IS_ERR(hvs))\n\t\treturn PTR_ERR(hvs);\n\n\thvs->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(hvs->regs))\n\t\treturn PTR_ERR(hvs->regs);\n\n\thvs->regset.base = hvs->regs;\n\thvs->regset.regs = hvs_regs;\n\thvs->regset.nregs = ARRAY_SIZE(hvs_regs);\n\n\tif (vc4->is_vc5) {\n\t\tstruct rpi_firmware *firmware;\n\t\tstruct device_node *node;\n\t\tunsigned int max_rate;\n\n\t\tnode = rpi_firmware_find_node();\n\t\tif (!node)\n\t\t\treturn -EINVAL;\n\n\t\tfirmware = rpi_firmware_get(node);\n\t\tof_node_put(node);\n\t\tif (!firmware)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\thvs->core_clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(hvs->core_clk)) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get core clock\\n\");\n\t\t\treturn PTR_ERR(hvs->core_clk);\n\t\t}\n\n\t\tmax_rate = rpi_firmware_clk_get_max_rate(firmware,\n\t\t\t\t\t\t\t RPI_FIRMWARE_CORE_CLK_ID);\n\t\trpi_firmware_put(firmware);\n\t\tif (max_rate >= 550000000)\n\t\t\thvs->vc5_hdmi_enable_hdmi_20 = true;\n\n\t\tif (max_rate >= 600000000)\n\t\t\thvs->vc5_hdmi_enable_4096by2160 = true;\n\n\t\thvs->max_core_rate = max_rate;\n\n\t\tret = clk_prepare_enable(hvs->core_clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't enable the core clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!vc4->is_vc5)\n\t\thvs->dlist = hvs->regs + SCALER_DLIST_START;\n\telse\n\t\thvs->dlist = hvs->regs + SCALER5_DLIST_START;\n\n\t \n\tret = vc4_hvs_upload_linear_kernel(hvs,\n\t\t\t\t\t   &hvs->mitchell_netravali_filter,\n\t\t\t\t\t   mitchell_netravali_1_3_1_3_kernel);\n\tif (ret)\n\t\treturn ret;\n\n\treg = HVS_READ(SCALER_DISPECTRL);\n\treg &= ~SCALER_DISPECTRL_DSP2_MUX_MASK;\n\tHVS_WRITE(SCALER_DISPECTRL,\n\t\t  reg | VC4_SET_FIELD(0, SCALER_DISPECTRL_DSP2_MUX));\n\n\treg = HVS_READ(SCALER_DISPCTRL);\n\treg &= ~SCALER_DISPCTRL_DSP3_MUX_MASK;\n\tHVS_WRITE(SCALER_DISPCTRL,\n\t\t  reg | VC4_SET_FIELD(3, SCALER_DISPCTRL_DSP3_MUX));\n\n\treg = HVS_READ(SCALER_DISPEOLN);\n\treg &= ~SCALER_DISPEOLN_DSP4_MUX_MASK;\n\tHVS_WRITE(SCALER_DISPEOLN,\n\t\t  reg | VC4_SET_FIELD(3, SCALER_DISPEOLN_DSP4_MUX));\n\n\treg = HVS_READ(SCALER_DISPDITHER);\n\treg &= ~SCALER_DISPDITHER_DSP5_MUX_MASK;\n\tHVS_WRITE(SCALER_DISPDITHER,\n\t\t  reg | VC4_SET_FIELD(3, SCALER_DISPDITHER_DSP5_MUX));\n\n\tdispctrl = HVS_READ(SCALER_DISPCTRL);\n\n\tdispctrl |= SCALER_DISPCTRL_ENABLE;\n\tdispctrl |= SCALER_DISPCTRL_DISPEIRQ(0) |\n\t\t    SCALER_DISPCTRL_DISPEIRQ(1) |\n\t\t    SCALER_DISPCTRL_DISPEIRQ(2);\n\n\tif (!vc4->is_vc5)\n\t\tdispctrl &= ~(SCALER_DISPCTRL_DMAEIRQ |\n\t\t\t      SCALER_DISPCTRL_SLVWREIRQ |\n\t\t\t      SCALER_DISPCTRL_SLVRDEIRQ |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOF(0) |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOF(1) |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOF(2) |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOLN(0) |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOLN(1) |\n\t\t\t      SCALER_DISPCTRL_DSPEIEOLN(2) |\n\t\t\t      SCALER_DISPCTRL_DSPEISLUR(0) |\n\t\t\t      SCALER_DISPCTRL_DSPEISLUR(1) |\n\t\t\t      SCALER_DISPCTRL_DSPEISLUR(2) |\n\t\t\t      SCALER_DISPCTRL_SCLEIRQ);\n\telse\n\t\tdispctrl &= ~(SCALER_DISPCTRL_DMAEIRQ |\n\t\t\t      SCALER5_DISPCTRL_SLVEIRQ |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOF(0) |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOF(1) |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOF(2) |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOLN(0) |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOLN(1) |\n\t\t\t      SCALER5_DISPCTRL_DSPEIEOLN(2) |\n\t\t\t      SCALER5_DISPCTRL_DSPEISLUR(0) |\n\t\t\t      SCALER5_DISPCTRL_DSPEISLUR(1) |\n\t\t\t      SCALER5_DISPCTRL_DSPEISLUR(2) |\n\t\t\t      SCALER_DISPCTRL_SCLEIRQ);\n\n\n\t \n\tdispctrl &= ~(SCALER_DISPCTRL_PANIC0_MASK |\n\t\t      SCALER_DISPCTRL_PANIC1_MASK |\n\t\t      SCALER_DISPCTRL_PANIC2_MASK);\n\tdispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC0);\n\tdispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC1);\n\tdispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC2);\n\n\tHVS_WRITE(SCALER_DISPCTRL, dispctrl);\n\n\t \n\tif (!vc4->is_vc5) {\n\t\t \n\t\t#define VC4_COB_SIZE\t\t20736\n\t\t#define VC4_COB_LINE_WIDTH\t2048\n\t\t#define VC4_COB_NUM_LINES\t3\n\t\treg = 0;\n\t\ttop = VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;\n\t\treg |= (top - 1) << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE2, reg);\n\t\treg = top;\n\t\ttop += VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;\n\t\treg |= (top - 1) << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE1, reg);\n\t\treg = top;\n\t\ttop = VC4_COB_SIZE;\n\t\treg |= (top - 1) << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE0, reg);\n\t} else {\n\t\t \n\t\t#define VC5_COB_SIZE\t\t44416\n\t\t#define VC5_COB_LINE_WIDTH\t4096\n\t\t#define VC5_COB_NUM_LINES\t3\n\t\treg = 0;\n\t\ttop = VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;\n\t\treg |= top << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE2, reg);\n\t\ttop += 16;\n\t\treg = top;\n\t\ttop += VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;\n\t\treg |= top << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE1, reg);\n\t\ttop += 16;\n\t\treg = top;\n\t\ttop = VC5_COB_SIZE;\n\t\treg |= top << 16;\n\t\tHVS_WRITE(SCALER_DISPBASE0, reg);\n\t}\n\n\tret = devm_request_irq(dev, platform_get_irq(pdev, 0),\n\t\t\t       vc4_hvs_irq_handler, 0, \"vc4 hvs\", drm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void vc4_hvs_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_hvs *hvs = vc4->hvs;\n\tstruct drm_mm_node *node, *next;\n\n\tif (drm_mm_node_allocated(&vc4->hvs->mitchell_netravali_filter))\n\t\tdrm_mm_remove_node(&vc4->hvs->mitchell_netravali_filter);\n\n\tdrm_mm_for_each_node_safe(node, next, &vc4->hvs->dlist_mm)\n\t\tdrm_mm_remove_node(node);\n\n\tdrm_mm_takedown(&vc4->hvs->dlist_mm);\n\n\tdrm_mm_for_each_node_safe(node, next, &vc4->hvs->lbm_mm)\n\t\tdrm_mm_remove_node(node);\n\tdrm_mm_takedown(&vc4->hvs->lbm_mm);\n\n\tclk_disable_unprepare(hvs->core_clk);\n\n\tvc4->hvs = NULL;\n}\n\nstatic const struct component_ops vc4_hvs_ops = {\n\t.bind   = vc4_hvs_bind,\n\t.unbind = vc4_hvs_unbind,\n};\n\nstatic int vc4_hvs_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_hvs_ops);\n}\n\nstatic void vc4_hvs_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_hvs_ops);\n}\n\nstatic const struct of_device_id vc4_hvs_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2711-hvs\" },\n\t{ .compatible = \"brcm,bcm2835-hvs\" },\n\t{}\n};\n\nstruct platform_driver vc4_hvs_driver = {\n\t.probe = vc4_hvs_dev_probe,\n\t.remove_new = vc4_hvs_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_hvs\",\n\t\t.of_match_table = vc4_hvs_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}