{
  "module_name": "vc4_plane.c",
  "hash_id": "f71f150ed9f7db4f935b3a3093fbf6ea009179287d2c065768e80966170ece2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_plane.c",
  "human_readable_source": "\n \n\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n\n#include \"uapi/drm/vc4_drm.h\"\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\nstatic const struct hvs_format {\n\tu32 drm;  \n\tu32 hvs;  \n\tu32 pixel_order;\n\tu32 pixel_order_hvs5;\n\tbool hvs5_only;\n} hvs_formats[] = {\n\t{\n\t\t.drm = DRM_FORMAT_XRGB8888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA8888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ARGB8888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA8888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ABGR8888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA8888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ARGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XBGR8888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA8888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ARGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_RGB565,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB565,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XRGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XRGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_BGR565,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB565,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XBGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XBGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ARGB1555,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA5551,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XRGB1555,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA5551,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_RGB888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XRGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XRGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_BGR888,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB888,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XBGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XBGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_YUV422,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV422_3PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCBCR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCBCR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_YVU422,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV422_3PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCRCB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCRCB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_YUV420,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV420_3PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCBCR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCBCR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_YVU420,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV420_3PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCRCB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCRCB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_NV12,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV420_2PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCBCR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCBCR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_NV21,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV420_2PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCRCB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCRCB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_NV16,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV422_2PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCBCR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCBCR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_NV61,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV422_2PLANE,\n\t\t.pixel_order = HVS_PIXEL_ORDER_XYCRCB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCRCB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_P030,\n\t\t.hvs = HVS_PIXEL_FORMAT_YCBCR_10BIT,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_XYCBCR,\n\t\t.hvs5_only = true,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XRGB2101010,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA1010102,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t\t.hvs5_only = true,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ARGB2101010,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA1010102,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t\t.hvs5_only = true,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ABGR2101010,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA1010102,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t\t.hvs5_only = true,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XBGR2101010,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA1010102,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t\t.hvs5_only = true,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_RGB332,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB332,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ARGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_BGR233,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGB332,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XRGB4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ARGB4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ABGR,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ARGB,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_XBGR4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ARGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_ABGR4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_ARGB,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_ABGR,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_BGRX4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_RGBA,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_BGRA,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_BGRA4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_RGBA,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_BGRA,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_RGBX4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_BGRA,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_RGBA,\n\t},\n\t{\n\t\t.drm = DRM_FORMAT_RGBA4444,\n\t\t.hvs = HVS_PIXEL_FORMAT_RGBA4444,\n\t\t.pixel_order = HVS_PIXEL_ORDER_BGRA,\n\t\t.pixel_order_hvs5 = HVS_PIXEL_ORDER_RGBA,\n\t},\n};\n\nstatic const struct hvs_format *vc4_get_hvs_format(u32 drm_format)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hvs_formats); i++) {\n\t\tif (hvs_formats[i].drm == drm_format)\n\t\t\treturn &hvs_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic enum vc4_scaling_mode vc4_get_scaling_mode(u32 src, u32 dst)\n{\n\tif (dst == src)\n\t\treturn VC4_SCALING_NONE;\n\tif (3 * dst >= 2 * src)\n\t\treturn VC4_SCALING_PPF;\n\telse\n\t\treturn VC4_SCALING_TPZ;\n}\n\nstatic bool plane_enabled(struct drm_plane_state *state)\n{\n\treturn state->fb && !WARN_ON(!state->crtc);\n}\n\nstatic struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct vc4_plane_state *vc4_state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tvc4_state = kmemdup(plane->state, sizeof(*vc4_state), GFP_KERNEL);\n\tif (!vc4_state)\n\t\treturn NULL;\n\n\tmemset(&vc4_state->lbm, 0, sizeof(vc4_state->lbm));\n\tvc4_state->dlist_initialized = 0;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &vc4_state->base);\n\n\tif (vc4_state->dlist) {\n\t\tvc4_state->dlist = kmemdup(vc4_state->dlist,\n\t\t\t\t\t   vc4_state->dlist_count * 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!vc4_state->dlist) {\n\t\t\tkfree(vc4_state);\n\t\t\treturn NULL;\n\t\t}\n\t\tvc4_state->dlist_size = vc4_state->dlist_count;\n\t}\n\n\treturn &vc4_state->base;\n}\n\nstatic void vc4_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t    struct drm_plane_state *state)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(plane->dev);\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\n\tif (drm_mm_node_allocated(&vc4_state->lbm)) {\n\t\tunsigned long irqflags;\n\n\t\tspin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);\n\t\tdrm_mm_remove_node(&vc4_state->lbm);\n\t\tspin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);\n\t}\n\n\tkfree(vc4_state->dlist);\n\t__drm_atomic_helper_plane_destroy_state(&vc4_state->base);\n\tkfree(state);\n}\n\n \nstatic void vc4_plane_reset(struct drm_plane *plane)\n{\n\tstruct vc4_plane_state *vc4_state;\n\n\tWARN_ON(plane->state);\n\n\tvc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);\n\tif (!vc4_state)\n\t\treturn;\n\n\t__drm_atomic_helper_plane_reset(plane, &vc4_state->base);\n}\n\nstatic void vc4_dlist_counter_increment(struct vc4_plane_state *vc4_state)\n{\n\tif (vc4_state->dlist_count == vc4_state->dlist_size) {\n\t\tu32 new_size = max(4u, vc4_state->dlist_count * 2);\n\t\tu32 *new_dlist = kmalloc_array(new_size, 4, GFP_KERNEL);\n\n\t\tif (!new_dlist)\n\t\t\treturn;\n\t\tmemcpy(new_dlist, vc4_state->dlist, vc4_state->dlist_count * 4);\n\n\t\tkfree(vc4_state->dlist);\n\t\tvc4_state->dlist = new_dlist;\n\t\tvc4_state->dlist_size = new_size;\n\t}\n\n\tvc4_state->dlist_count++;\n}\n\nstatic void vc4_dlist_write(struct vc4_plane_state *vc4_state, u32 val)\n{\n\tunsigned int idx = vc4_state->dlist_count;\n\n\tvc4_dlist_counter_increment(vc4_state);\n\tvc4_state->dlist[idx] = val;\n}\n\n \nstatic u32 vc4_get_scl_field(struct drm_plane_state *state, int plane)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\n\tswitch (vc4_state->x_scaling[plane] << 2 | vc4_state->y_scaling[plane]) {\n\tcase VC4_SCALING_PPF << 2 | VC4_SCALING_PPF:\n\t\treturn SCALER_CTL0_SCL_H_PPF_V_PPF;\n\tcase VC4_SCALING_TPZ << 2 | VC4_SCALING_PPF:\n\t\treturn SCALER_CTL0_SCL_H_TPZ_V_PPF;\n\tcase VC4_SCALING_PPF << 2 | VC4_SCALING_TPZ:\n\t\treturn SCALER_CTL0_SCL_H_PPF_V_TPZ;\n\tcase VC4_SCALING_TPZ << 2 | VC4_SCALING_TPZ:\n\t\treturn SCALER_CTL0_SCL_H_TPZ_V_TPZ;\n\tcase VC4_SCALING_PPF << 2 | VC4_SCALING_NONE:\n\t\treturn SCALER_CTL0_SCL_H_PPF_V_NONE;\n\tcase VC4_SCALING_NONE << 2 | VC4_SCALING_PPF:\n\t\treturn SCALER_CTL0_SCL_H_NONE_V_PPF;\n\tcase VC4_SCALING_NONE << 2 | VC4_SCALING_TPZ:\n\t\treturn SCALER_CTL0_SCL_H_NONE_V_TPZ;\n\tcase VC4_SCALING_TPZ << 2 | VC4_SCALING_NONE:\n\t\treturn SCALER_CTL0_SCL_H_TPZ_V_NONE;\n\tdefault:\n\tcase VC4_SCALING_NONE << 2 | VC4_SCALING_NONE:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic int vc4_plane_margins_adj(struct drm_plane_state *pstate)\n{\n\tstruct vc4_plane_state *vc4_pstate = to_vc4_plane_state(pstate);\n\tunsigned int left, right, top, bottom, adjhdisplay, adjvdisplay;\n\tstruct drm_crtc_state *crtc_state;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(pstate->state,\n\t\t\t\t\t\t   pstate->crtc);\n\n\tvc4_crtc_get_margins(crtc_state, &left, &right, &top, &bottom);\n\tif (!left && !right && !top && !bottom)\n\t\treturn 0;\n\n\tif (left + right >= crtc_state->mode.hdisplay ||\n\t    top + bottom >= crtc_state->mode.vdisplay)\n\t\treturn -EINVAL;\n\n\tadjhdisplay = crtc_state->mode.hdisplay - (left + right);\n\tvc4_pstate->crtc_x = DIV_ROUND_CLOSEST(vc4_pstate->crtc_x *\n\t\t\t\t\t       adjhdisplay,\n\t\t\t\t\t       crtc_state->mode.hdisplay);\n\tvc4_pstate->crtc_x += left;\n\tif (vc4_pstate->crtc_x > crtc_state->mode.hdisplay - right)\n\t\tvc4_pstate->crtc_x = crtc_state->mode.hdisplay - right;\n\n\tadjvdisplay = crtc_state->mode.vdisplay - (top + bottom);\n\tvc4_pstate->crtc_y = DIV_ROUND_CLOSEST(vc4_pstate->crtc_y *\n\t\t\t\t\t       adjvdisplay,\n\t\t\t\t\t       crtc_state->mode.vdisplay);\n\tvc4_pstate->crtc_y += top;\n\tif (vc4_pstate->crtc_y > crtc_state->mode.vdisplay - bottom)\n\t\tvc4_pstate->crtc_y = crtc_state->mode.vdisplay - bottom;\n\n\tvc4_pstate->crtc_w = DIV_ROUND_CLOSEST(vc4_pstate->crtc_w *\n\t\t\t\t\t       adjhdisplay,\n\t\t\t\t\t       crtc_state->mode.hdisplay);\n\tvc4_pstate->crtc_h = DIV_ROUND_CLOSEST(vc4_pstate->crtc_h *\n\t\t\t\t\t       adjvdisplay,\n\t\t\t\t\t       crtc_state->mode.vdisplay);\n\n\tif (!vc4_pstate->crtc_w || !vc4_pstate->crtc_h)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vc4_plane_setup_clipping_and_scaling(struct drm_plane_state *state)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *bo;\n\tint num_planes = fb->format->num_planes;\n\tstruct drm_crtc_state *crtc_state;\n\tu32 h_subsample = fb->format->hsub;\n\tu32 v_subsample = fb->format->vsub;\n\tint i, ret;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state->state,\n\t\t\t\t\t\t\tstate->crtc);\n\tif (!crtc_state) {\n\t\tDRM_DEBUG_KMS(\"Invalid crtc state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_atomic_helper_check_plane_state(state, crtc_state, 1,\n\t\t\t\t\t\t  INT_MAX, true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tbo = drm_fb_dma_get_gem_obj(fb, i);\n\t\tvc4_state->offsets[i] = bo->dma_addr + fb->offsets[i];\n\t}\n\n\t \n\tvc4_state->src_x = DIV_ROUND_CLOSEST(state->src.x1, 1 << 16);\n\tvc4_state->src_y = DIV_ROUND_CLOSEST(state->src.y1, 1 << 16);\n\tvc4_state->src_w[0] = DIV_ROUND_CLOSEST(state->src.x2, 1 << 16) - vc4_state->src_x;\n\tvc4_state->src_h[0] = DIV_ROUND_CLOSEST(state->src.y2, 1 << 16) - vc4_state->src_y;\n\n\tvc4_state->crtc_x = state->dst.x1;\n\tvc4_state->crtc_y = state->dst.y1;\n\tvc4_state->crtc_w = state->dst.x2 - state->dst.x1;\n\tvc4_state->crtc_h = state->dst.y2 - state->dst.y1;\n\n\tret = vc4_plane_margins_adj(state);\n\tif (ret)\n\t\treturn ret;\n\n\tvc4_state->x_scaling[0] = vc4_get_scaling_mode(vc4_state->src_w[0],\n\t\t\t\t\t\t       vc4_state->crtc_w);\n\tvc4_state->y_scaling[0] = vc4_get_scaling_mode(vc4_state->src_h[0],\n\t\t\t\t\t\t       vc4_state->crtc_h);\n\n\tvc4_state->is_unity = (vc4_state->x_scaling[0] == VC4_SCALING_NONE &&\n\t\t\t       vc4_state->y_scaling[0] == VC4_SCALING_NONE);\n\n\tif (num_planes > 1) {\n\t\tvc4_state->is_yuv = true;\n\n\t\tvc4_state->src_w[1] = vc4_state->src_w[0] / h_subsample;\n\t\tvc4_state->src_h[1] = vc4_state->src_h[0] / v_subsample;\n\n\t\tvc4_state->x_scaling[1] =\n\t\t\tvc4_get_scaling_mode(vc4_state->src_w[1],\n\t\t\t\t\t     vc4_state->crtc_w);\n\t\tvc4_state->y_scaling[1] =\n\t\t\tvc4_get_scaling_mode(vc4_state->src_h[1],\n\t\t\t\t\t     vc4_state->crtc_h);\n\n\t\t \n\t\tif (vc4_state->x_scaling[1] == VC4_SCALING_NONE)\n\t\t\tvc4_state->x_scaling[1] = VC4_SCALING_PPF;\n\t} else {\n\t\tvc4_state->is_yuv = false;\n\t\tvc4_state->x_scaling[1] = VC4_SCALING_NONE;\n\t\tvc4_state->y_scaling[1] = VC4_SCALING_NONE;\n\t}\n\n\treturn 0;\n}\n\nstatic void vc4_write_tpz(struct vc4_plane_state *vc4_state, u32 src, u32 dst)\n{\n\tu32 scale, recip;\n\n\tscale = (1 << 16) * src / dst;\n\n\t \n\trecip = ~0 / scale;\n\n\tvc4_dlist_write(vc4_state,\n\t\t\tVC4_SET_FIELD(scale, SCALER_TPZ0_SCALE) |\n\t\t\tVC4_SET_FIELD(0, SCALER_TPZ0_IPHASE));\n\tvc4_dlist_write(vc4_state,\n\t\t\tVC4_SET_FIELD(recip, SCALER_TPZ1_RECIP));\n}\n\nstatic void vc4_write_ppf(struct vc4_plane_state *vc4_state, u32 src, u32 dst)\n{\n\tu32 scale = (1 << 16) * src / dst;\n\n\tvc4_dlist_write(vc4_state,\n\t\t\tSCALER_PPF_AGC |\n\t\t\tVC4_SET_FIELD(scale, SCALER_PPF_SCALE) |\n\t\t\tVC4_SET_FIELD(0, SCALER_PPF_IPHASE));\n}\n\nstatic u32 vc4_lbm_size(struct drm_plane_state *state)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\tstruct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);\n\tu32 pix_per_line;\n\tu32 lbm;\n\n\t \n\tif (vc4_state->y_scaling[0] == VC4_SCALING_NONE &&\n\t    vc4_state->y_scaling[1] == VC4_SCALING_NONE)\n\t\treturn 0;\n\n\t \n\tif (vc4_state->x_scaling[0] == VC4_SCALING_TPZ)\n\t\tpix_per_line = vc4_state->crtc_w;\n\telse\n\t\tpix_per_line = vc4_state->src_w[0];\n\n\tif (!vc4_state->is_yuv) {\n\t\tif (vc4_state->y_scaling[0] == VC4_SCALING_TPZ)\n\t\t\tlbm = pix_per_line * 8;\n\t\telse {\n\t\t\t \n\t\t\tlbm = pix_per_line * 16;\n\t\t}\n\t} else {\n\t\t \n\t\tlbm = pix_per_line * 16;\n\t}\n\n\t \n\tlbm = roundup(lbm, vc4->is_vc5 ? 128 : 64);\n\n\t \n\tlbm /= vc4->is_vc5 ? 4 : 2;\n\n\treturn lbm;\n}\n\nstatic void vc4_write_scaling_parameters(struct drm_plane_state *state,\n\t\t\t\t\t int channel)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\n\t \n\tif (vc4_state->x_scaling[channel] == VC4_SCALING_PPF) {\n\t\tvc4_write_ppf(vc4_state,\n\t\t\t      vc4_state->src_w[channel], vc4_state->crtc_w);\n\t}\n\n\t \n\tif (vc4_state->y_scaling[channel] == VC4_SCALING_PPF) {\n\t\tvc4_write_ppf(vc4_state,\n\t\t\t      vc4_state->src_h[channel], vc4_state->crtc_h);\n\t\tvc4_dlist_write(vc4_state, 0xc0c0c0c0);\n\t}\n\n\t \n\tif (vc4_state->x_scaling[channel] == VC4_SCALING_TPZ) {\n\t\tvc4_write_tpz(vc4_state,\n\t\t\t      vc4_state->src_w[channel], vc4_state->crtc_w);\n\t}\n\n\t \n\tif (vc4_state->y_scaling[channel] == VC4_SCALING_TPZ) {\n\t\tvc4_write_tpz(vc4_state,\n\t\t\t      vc4_state->src_h[channel], vc4_state->crtc_h);\n\t\tvc4_dlist_write(vc4_state, 0xc0c0c0c0);\n\t}\n}\n\nstatic void vc4_plane_calc_load(struct drm_plane_state *state)\n{\n\tunsigned int hvs_load_shift, vrefresh, i;\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct vc4_plane_state *vc4_state;\n\tstruct drm_crtc_state *crtc_state;\n\tunsigned int vscale_factor;\n\n\tvc4_state = to_vc4_plane_state(state);\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state->state,\n\t\t\t\t\t\t\tstate->crtc);\n\tvrefresh = drm_mode_vrefresh(&crtc_state->adjusted_mode);\n\n\t \n\tif (vc4_state->x_scaling[0] != VC4_SCALING_NONE ||\n\t    vc4_state->x_scaling[1] != VC4_SCALING_NONE ||\n\t    vc4_state->y_scaling[0] != VC4_SCALING_NONE ||\n\t    vc4_state->y_scaling[1] != VC4_SCALING_NONE)\n\t\thvs_load_shift = 1;\n\telse\n\t\thvs_load_shift = 2;\n\n\tvc4_state->membus_load = 0;\n\tvc4_state->hvs_load = 0;\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\t \n\t\tvscale_factor = DIV_ROUND_UP(vc4_state->src_h[i],\n\t\t\t\t\t     vc4_state->crtc_h);\n\t\tvc4_state->membus_load += vc4_state->src_w[i] *\n\t\t\t\t\t  vc4_state->src_h[i] * vscale_factor *\n\t\t\t\t\t  fb->format->cpp[i];\n\t\tvc4_state->hvs_load += vc4_state->crtc_h * vc4_state->crtc_w;\n\t}\n\n\tvc4_state->hvs_load *= vrefresh;\n\tvc4_state->hvs_load >>= hvs_load_shift;\n\tvc4_state->membus_load *= vrefresh;\n}\n\nstatic int vc4_plane_allocate_lbm(struct drm_plane_state *state)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\tunsigned long irqflags;\n\tu32 lbm_size;\n\n\tlbm_size = vc4_lbm_size(state);\n\tif (!lbm_size)\n\t\treturn 0;\n\n\tif (WARN_ON(!vc4_state->lbm_offset))\n\t\treturn -EINVAL;\n\n\t \n\tif (!drm_mm_node_allocated(&vc4_state->lbm)) {\n\t\tint ret;\n\n\t\tspin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);\n\t\tret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,\n\t\t\t\t\t\t &vc4_state->lbm,\n\t\t\t\t\t\t lbm_size,\n\t\t\t\t\t\t vc4->is_vc5 ? 64 : 32,\n\t\t\t\t\t\t 0, 0);\n\t\tspin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tWARN_ON_ONCE(lbm_size != vc4_state->lbm.size);\n\t}\n\n\tvc4_state->dlist[vc4_state->lbm_offset] = vc4_state->lbm.start;\n\n\treturn 0;\n}\n\n \nstatic const u32 colorspace_coeffs[2][DRM_COLOR_ENCODING_MAX][3] = {\n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\tSCALER_CSC0_ITR_R_601_5,\n\t\t\tSCALER_CSC1_ITR_R_601_5,\n\t\t\tSCALER_CSC2_ITR_R_601_5,\n\t\t}, {\n\t\t\t \n\t\t\tSCALER_CSC0_ITR_R_709_3,\n\t\t\tSCALER_CSC1_ITR_R_709_3,\n\t\t\tSCALER_CSC2_ITR_R_709_3,\n\t\t}, {\n\t\t\t \n\t\t\tSCALER_CSC0_ITR_R_2020,\n\t\t\tSCALER_CSC1_ITR_R_2020,\n\t\t\tSCALER_CSC2_ITR_R_2020,\n\t\t}\n\t}, {\n\t\t \n\t\t{\n\t\t\t \n\t\t\tSCALER_CSC0_JPEG_JFIF,\n\t\t\tSCALER_CSC1_JPEG_JFIF,\n\t\t\tSCALER_CSC2_JPEG_JFIF,\n\t\t}, {\n\t\t\t \n\t\t\tSCALER_CSC0_ITR_R_709_3_FR,\n\t\t\tSCALER_CSC1_ITR_R_709_3_FR,\n\t\t\tSCALER_CSC2_ITR_R_709_3_FR,\n\t\t}, {\n\t\t\t \n\t\t\tSCALER_CSC0_ITR_R_2020_FR,\n\t\t\tSCALER_CSC1_ITR_R_2020_FR,\n\t\t\tSCALER_CSC2_ITR_R_2020_FR,\n\t\t}\n\t}\n};\n\nstatic u32 vc4_hvs4_get_alpha_blend_mode(struct drm_plane_state *state)\n{\n\tif (!state->fb->format->has_alpha)\n\t\treturn VC4_SET_FIELD(SCALER_POS2_ALPHA_MODE_FIXED,\n\t\t\t\t     SCALER_POS2_ALPHA_MODE);\n\n\tswitch (state->pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn VC4_SET_FIELD(SCALER_POS2_ALPHA_MODE_FIXED,\n\t\t\t\t     SCALER_POS2_ALPHA_MODE);\n\tdefault:\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn VC4_SET_FIELD(SCALER_POS2_ALPHA_MODE_PIPELINE,\n\t\t\t\t     SCALER_POS2_ALPHA_MODE) |\n\t\t\tSCALER_POS2_ALPHA_PREMULT;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn VC4_SET_FIELD(SCALER_POS2_ALPHA_MODE_PIPELINE,\n\t\t\t\t     SCALER_POS2_ALPHA_MODE);\n\t}\n}\n\nstatic u32 vc4_hvs5_get_alpha_blend_mode(struct drm_plane_state *state)\n{\n\tif (!state->fb->format->has_alpha)\n\t\treturn VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,\n\t\t\t\t     SCALER5_CTL2_ALPHA_MODE);\n\n\tswitch (state->pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,\n\t\t\t\t     SCALER5_CTL2_ALPHA_MODE);\n\tdefault:\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,\n\t\t\t\t     SCALER5_CTL2_ALPHA_MODE) |\n\t\t\tSCALER5_CTL2_ALPHA_PREMULT;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,\n\t\t\t\t     SCALER5_CTL2_ALPHA_MODE);\n\t}\n}\n\n \nstatic int vc4_plane_mode_set(struct drm_plane *plane,\n\t\t\t      struct drm_plane_state *state)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(plane->dev);\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\tstruct drm_framebuffer *fb = state->fb;\n\tu32 ctl0_offset = vc4_state->dlist_count;\n\tconst struct hvs_format *format = vc4_get_hvs_format(fb->format->format);\n\tu64 base_format_mod = fourcc_mod_broadcom_mod(fb->modifier);\n\tint num_planes = fb->format->num_planes;\n\tu32 h_subsample = fb->format->hsub;\n\tu32 v_subsample = fb->format->vsub;\n\tbool mix_plane_alpha;\n\tbool covers_screen;\n\tu32 scl0, scl1, pitch0;\n\tu32 tiling, src_y;\n\tu32 hvs_format = format->hvs;\n\tunsigned int rotation;\n\tint ret, i;\n\n\tif (vc4_state->dlist_initialized)\n\t\treturn 0;\n\n\tret = vc4_plane_setup_clipping_and_scaling(state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (num_planes == 1) {\n\t\tscl0 = vc4_get_scl_field(state, 0);\n\t\tscl1 = scl0;\n\t} else {\n\t\tscl0 = vc4_get_scl_field(state, 1);\n\t\tscl1 = vc4_get_scl_field(state, 0);\n\t}\n\n\trotation = drm_rotation_simplify(state->rotation,\n\t\t\t\t\t DRM_MODE_ROTATE_0 |\n\t\t\t\t\t DRM_MODE_REFLECT_X |\n\t\t\t\t\t DRM_MODE_REFLECT_Y);\n\n\t \n\tsrc_y = vc4_state->src_y;\n\tif (rotation & DRM_MODE_REFLECT_Y)\n\t\tsrc_y += vc4_state->src_h[0] - 1;\n\n\tswitch (base_format_mod) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\ttiling = SCALER_CTL0_TILING_LINEAR;\n\t\tpitch0 = VC4_SET_FIELD(fb->pitches[0], SCALER_SRC_PITCH);\n\n\t\t \n\t\tfor (i = 0; i < num_planes; i++) {\n\t\t\tvc4_state->offsets[i] += src_y /\n\t\t\t\t\t\t (i ? v_subsample : 1) *\n\t\t\t\t\t\t fb->pitches[i];\n\n\t\t\tvc4_state->offsets[i] += vc4_state->src_x /\n\t\t\t\t\t\t (i ? h_subsample : 1) *\n\t\t\t\t\t\t fb->format->cpp[i];\n\t\t}\n\n\t\tbreak;\n\n\tcase DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED: {\n\t\tu32 tile_size_shift = 12;  \n\t\t \n\t\tu32 tile_w_shift = fb->format->cpp[0] == 2 ? 6 : 5;\n\t\tu32 tile_h_shift = 5;  \n\t\tu32 tile_w_mask = (1 << tile_w_shift) - 1;\n\t\t \n\t\tu32 tile_h_mask = (2 << tile_h_shift) - 1;\n\t\t \n\t\tu32 tiles_w = fb->pitches[0] >> (tile_size_shift - tile_h_shift);\n\t\tu32 tiles_l = vc4_state->src_x >> tile_w_shift;\n\t\tu32 tiles_r = tiles_w - tiles_l;\n\t\tu32 tiles_t = src_y >> tile_h_shift;\n\t\t \n\t\tu32 tile_y = (src_y >> 4) & 1;\n\t\tu32 subtile_y = (src_y >> 2) & 3;\n\t\tu32 utile_y = src_y & 3;\n\t\tu32 x_off = vc4_state->src_x & tile_w_mask;\n\t\tu32 y_off = src_y & tile_h_mask;\n\n\t\t \n\t\tif (rotation & DRM_MODE_REFLECT_Y) {\n\t\t\ty_off = tile_h_mask - y_off;\n\t\t\tpitch0 = SCALER_PITCH0_TILE_LINE_DIR;\n\t\t} else {\n\t\t\tpitch0 = 0;\n\t\t}\n\n\t\ttiling = SCALER_CTL0_TILING_256B_OR_T;\n\t\tpitch0 |= (VC4_SET_FIELD(x_off, SCALER_PITCH0_SINK_PIX) |\n\t\t\t   VC4_SET_FIELD(y_off, SCALER_PITCH0_TILE_Y_OFFSET) |\n\t\t\t   VC4_SET_FIELD(tiles_l, SCALER_PITCH0_TILE_WIDTH_L) |\n\t\t\t   VC4_SET_FIELD(tiles_r, SCALER_PITCH0_TILE_WIDTH_R));\n\t\tvc4_state->offsets[0] += tiles_t * (tiles_w << tile_size_shift);\n\t\tvc4_state->offsets[0] += subtile_y << 8;\n\t\tvc4_state->offsets[0] += utile_y << 4;\n\n\t\t \n\t\tif (tiles_t & 1) {\n\t\t\tpitch0 |= SCALER_PITCH0_TILE_INITIAL_LINE_DIR;\n\t\t\tvc4_state->offsets[0] += (tiles_w - tiles_l) <<\n\t\t\t\t\t\t tile_size_shift;\n\t\t\tvc4_state->offsets[0] -= (1 + !tile_y) << 10;\n\t\t} else {\n\t\t\tvc4_state->offsets[0] += tiles_l << tile_size_shift;\n\t\t\tvc4_state->offsets[0] += tile_y << 10;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase DRM_FORMAT_MOD_BROADCOM_SAND64:\n\tcase DRM_FORMAT_MOD_BROADCOM_SAND128:\n\tcase DRM_FORMAT_MOD_BROADCOM_SAND256: {\n\t\tuint32_t param = fourcc_mod_broadcom_param(fb->modifier);\n\n\t\tif (param > SCALER_TILE_HEIGHT_MASK) {\n\t\t\tDRM_DEBUG_KMS(\"SAND height too large (%d)\\n\",\n\t\t\t\t      param);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (fb->format->format == DRM_FORMAT_P030) {\n\t\t\thvs_format = HVS_PIXEL_FORMAT_YCBCR_10BIT;\n\t\t\ttiling = SCALER_CTL0_TILING_128B;\n\t\t} else {\n\t\t\thvs_format = HVS_PIXEL_FORMAT_H264;\n\n\t\t\tswitch (base_format_mod) {\n\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND64:\n\t\t\t\ttiling = SCALER_CTL0_TILING_64B;\n\t\t\t\tbreak;\n\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND128:\n\t\t\t\ttiling = SCALER_CTL0_TILING_128B;\n\t\t\t\tbreak;\n\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND256:\n\t\t\t\ttiling = SCALER_CTL0_TILING_256B_OR_T;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < num_planes; i++) {\n\t\t\tu32 tile_w, tile, x_off, pix_per_tile;\n\n\t\t\tif (fb->format->format == DRM_FORMAT_P030) {\n\t\t\t\t \n\t\t\t\tu32 remaining_pixels = vc4_state->src_x % 96;\n\t\t\t\tu32 aligned = remaining_pixels / 12;\n\t\t\t\tu32 last_bits = remaining_pixels % 12;\n\n\t\t\t\tx_off = aligned * 16 + last_bits;\n\t\t\t\ttile_w = 128;\n\t\t\t\tpix_per_tile = 96;\n\t\t\t} else {\n\t\t\t\tswitch (base_format_mod) {\n\t\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND64:\n\t\t\t\t\ttile_w = 64;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND128:\n\t\t\t\t\ttile_w = 128;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND256:\n\t\t\t\t\ttile_w = 256;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tpix_per_tile = tile_w / fb->format->cpp[0];\n\t\t\t\tx_off = (vc4_state->src_x % pix_per_tile) /\n\t\t\t\t\t(i ? h_subsample : 1) *\n\t\t\t\t\tfb->format->cpp[i];\n\t\t\t}\n\n\t\t\ttile = vc4_state->src_x / pix_per_tile;\n\n\t\t\tvc4_state->offsets[i] += param * tile_w * tile;\n\t\t\tvc4_state->offsets[i] += src_y /\n\t\t\t\t\t\t (i ? v_subsample : 1) *\n\t\t\t\t\t\t tile_w;\n\t\t\tvc4_state->offsets[i] += x_off & ~(i ? 1 : 0);\n\t\t}\n\n\t\tpitch0 = VC4_SET_FIELD(param, SCALER_TILE_HEIGHT);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Unsupported FB tiling flag 0x%16llx\",\n\t\t\t      (long long)fb->modifier);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmix_plane_alpha = state->alpha != DRM_BLEND_ALPHA_OPAQUE &&\n\t\t\t  fb->format->has_alpha;\n\n\tif (!vc4->is_vc5) {\n\t \n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\tSCALER_CTL0_VALID |\n\t\t\t\t(rotation & DRM_MODE_REFLECT_X ? SCALER_CTL0_HFLIP : 0) |\n\t\t\t\t(rotation & DRM_MODE_REFLECT_Y ? SCALER_CTL0_VFLIP : 0) |\n\t\t\t\tVC4_SET_FIELD(SCALER_CTL0_RGBA_EXPAND_ROUND, SCALER_CTL0_RGBA_EXPAND) |\n\t\t\t\t(format->pixel_order << SCALER_CTL0_ORDER_SHIFT) |\n\t\t\t\t(hvs_format << SCALER_CTL0_PIXEL_FORMAT_SHIFT) |\n\t\t\t\tVC4_SET_FIELD(tiling, SCALER_CTL0_TILING) |\n\t\t\t\t(vc4_state->is_unity ? SCALER_CTL0_UNITY : 0) |\n\t\t\t\tVC4_SET_FIELD(scl0, SCALER_CTL0_SCL0) |\n\t\t\t\tVC4_SET_FIELD(scl1, SCALER_CTL0_SCL1));\n\n\t\t \n\t\tvc4_state->pos0_offset = vc4_state->dlist_count;\n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\tVC4_SET_FIELD(state->alpha >> 8, SCALER_POS0_FIXED_ALPHA) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_x, SCALER_POS0_START_X) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_y, SCALER_POS0_START_Y));\n\n\t\t \n\t\tif (!vc4_state->is_unity) {\n\t\t\tvc4_dlist_write(vc4_state,\n\t\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_w,\n\t\t\t\t\t\t      SCALER_POS1_SCL_WIDTH) |\n\t\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_h,\n\t\t\t\t\t\t      SCALER_POS1_SCL_HEIGHT));\n\t\t}\n\n\t\t \n\t\tvc4_state->pos2_offset = vc4_state->dlist_count;\n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\t(mix_plane_alpha ? SCALER_POS2_ALPHA_MIX : 0) |\n\t\t\t\tvc4_hvs4_get_alpha_blend_mode(state) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->src_w[0],\n\t\t\t\t\t      SCALER_POS2_WIDTH) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->src_h[0],\n\t\t\t\t\t      SCALER_POS2_HEIGHT));\n\n\t\t \n\t\tvc4_dlist_write(vc4_state, 0xc0c0c0c0);\n\n\t} else {\n\t\t \n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\tSCALER_CTL0_VALID |\n\t\t\t\t(format->pixel_order_hvs5 << SCALER_CTL0_ORDER_SHIFT) |\n\t\t\t\t(hvs_format << SCALER_CTL0_PIXEL_FORMAT_SHIFT) |\n\t\t\t\tVC4_SET_FIELD(tiling, SCALER_CTL0_TILING) |\n\t\t\t\t(vc4_state->is_unity ?\n\t\t\t\t\t\tSCALER5_CTL0_UNITY : 0) |\n\t\t\t\tVC4_SET_FIELD(scl0, SCALER_CTL0_SCL0) |\n\t\t\t\tVC4_SET_FIELD(scl1, SCALER_CTL0_SCL1) |\n\t\t\t\tSCALER5_CTL0_ALPHA_EXPAND |\n\t\t\t\tSCALER5_CTL0_RGB_EXPAND);\n\n\t\t \n\t\tvc4_state->pos0_offset = vc4_state->dlist_count;\n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\t(rotation & DRM_MODE_REFLECT_Y ?\n\t\t\t\t\t\tSCALER5_POS0_VFLIP : 0) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_x,\n\t\t\t\t\t      SCALER_POS0_START_X) |\n\t\t\t\t(rotation & DRM_MODE_REFLECT_X ?\n\t\t\t\t\t      SCALER5_POS0_HFLIP : 0) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_y,\n\t\t\t\t\t      SCALER5_POS0_START_Y)\n\t\t\t       );\n\n\t\t \n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\tVC4_SET_FIELD(state->alpha >> 4,\n\t\t\t\t\t      SCALER5_CTL2_ALPHA) |\n\t\t\t\tvc4_hvs5_get_alpha_blend_mode(state) |\n\t\t\t\t(mix_plane_alpha ?\n\t\t\t\t\tSCALER5_CTL2_ALPHA_MIX : 0)\n\t\t\t       );\n\n\t\t \n\t\tif (!vc4_state->is_unity) {\n\t\t\tvc4_dlist_write(vc4_state,\n\t\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_w,\n\t\t\t\t\t\t      SCALER5_POS1_SCL_WIDTH) |\n\t\t\t\t\tVC4_SET_FIELD(vc4_state->crtc_h,\n\t\t\t\t\t\t      SCALER5_POS1_SCL_HEIGHT));\n\t\t}\n\n\t\t \n\t\tvc4_state->pos2_offset = vc4_state->dlist_count;\n\t\tvc4_dlist_write(vc4_state,\n\t\t\t\tVC4_SET_FIELD(vc4_state->src_w[0],\n\t\t\t\t\t      SCALER5_POS2_WIDTH) |\n\t\t\t\tVC4_SET_FIELD(vc4_state->src_h[0],\n\t\t\t\t\t      SCALER5_POS2_HEIGHT));\n\n\t\t \n\t\tvc4_dlist_write(vc4_state, 0xc0c0c0c0);\n\t}\n\n\n\t \n\tvc4_state->ptr0_offset = vc4_state->dlist_count;\n\tfor (i = 0; i < num_planes; i++)\n\t\tvc4_dlist_write(vc4_state, vc4_state->offsets[i]);\n\n\t \n\tfor (i = 0; i < num_planes; i++)\n\t\tvc4_dlist_write(vc4_state, 0xc0c0c0c0);\n\n\t \n\tvc4_dlist_write(vc4_state, pitch0);\n\n\t \n\tfor (i = 1; i < num_planes; i++) {\n\t\tif (hvs_format != HVS_PIXEL_FORMAT_H264 &&\n\t\t    hvs_format != HVS_PIXEL_FORMAT_YCBCR_10BIT) {\n\t\t\tvc4_dlist_write(vc4_state,\n\t\t\t\t\tVC4_SET_FIELD(fb->pitches[i],\n\t\t\t\t\t\t      SCALER_SRC_PITCH));\n\t\t} else {\n\t\t\tvc4_dlist_write(vc4_state, pitch0);\n\t\t}\n\t}\n\n\t \n\tif (vc4_state->is_yuv) {\n\t\tenum drm_color_encoding color_encoding = state->color_encoding;\n\t\tenum drm_color_range color_range = state->color_range;\n\t\tconst u32 *ccm;\n\n\t\tif (color_encoding >= DRM_COLOR_ENCODING_MAX)\n\t\t\tcolor_encoding = DRM_COLOR_YCBCR_BT601;\n\t\tif (color_range >= DRM_COLOR_RANGE_MAX)\n\t\t\tcolor_range = DRM_COLOR_YCBCR_LIMITED_RANGE;\n\n\t\tccm = colorspace_coeffs[color_range][color_encoding];\n\n\t\tvc4_dlist_write(vc4_state, ccm[0]);\n\t\tvc4_dlist_write(vc4_state, ccm[1]);\n\t\tvc4_dlist_write(vc4_state, ccm[2]);\n\t}\n\n\tvc4_state->lbm_offset = 0;\n\n\tif (vc4_state->x_scaling[0] != VC4_SCALING_NONE ||\n\t    vc4_state->x_scaling[1] != VC4_SCALING_NONE ||\n\t    vc4_state->y_scaling[0] != VC4_SCALING_NONE ||\n\t    vc4_state->y_scaling[1] != VC4_SCALING_NONE) {\n\t\t \n\t\tif (vc4_state->y_scaling[0] != VC4_SCALING_NONE ||\n\t\t    vc4_state->y_scaling[1] != VC4_SCALING_NONE) {\n\t\t\tvc4_state->lbm_offset = vc4_state->dlist_count;\n\t\t\tvc4_dlist_counter_increment(vc4_state);\n\t\t}\n\n\t\tif (num_planes > 1) {\n\t\t\t \n\t\t\tvc4_write_scaling_parameters(state, 1);\n\t\t}\n\t\tvc4_write_scaling_parameters(state, 0);\n\n\t\t \n\t\tif (vc4_state->x_scaling[0] == VC4_SCALING_PPF ||\n\t\t    vc4_state->y_scaling[0] == VC4_SCALING_PPF ||\n\t\t    vc4_state->x_scaling[1] == VC4_SCALING_PPF ||\n\t\t    vc4_state->y_scaling[1] == VC4_SCALING_PPF) {\n\t\t\tu32 kernel = VC4_SET_FIELD(vc4->hvs->mitchell_netravali_filter.start,\n\t\t\t\t\t\t   SCALER_PPF_KERNEL_OFFSET);\n\n\t\t\t \n\t\t\tvc4_dlist_write(vc4_state, kernel);\n\t\t\t \n\t\t\tvc4_dlist_write(vc4_state, kernel);\n\t\t\t \n\t\t\tvc4_dlist_write(vc4_state, kernel);\n\t\t\t \n\t\t\tvc4_dlist_write(vc4_state, kernel);\n\t\t}\n\t}\n\n\tvc4_state->dlist[ctl0_offset] |=\n\t\tVC4_SET_FIELD(vc4_state->dlist_count, SCALER_CTL0_SIZE);\n\n\t \n\tcovers_screen = vc4_state->crtc_x == 0 && vc4_state->crtc_y == 0 &&\n\t\t\tvc4_state->crtc_w == state->crtc->mode.hdisplay &&\n\t\t\tvc4_state->crtc_h == state->crtc->mode.vdisplay;\n\t \n\tvc4_state->needs_bg_fill = fb->format->has_alpha || !covers_screen ||\n\t\t\t\t   state->alpha != DRM_BLEND_ALPHA_OPAQUE;\n\n\t \n\tvc4_state->dlist_initialized = 1;\n\n\tvc4_plane_calc_load(state);\n\n\treturn 0;\n}\n\n \nstatic int vc4_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(new_plane_state);\n\tint ret;\n\n\tvc4_state->dlist_count = 0;\n\n\tif (!plane_enabled(new_plane_state))\n\t\treturn 0;\n\n\tret = vc4_plane_mode_set(plane, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vc4_plane_allocate_lbm(new_plane_state);\n}\n\nstatic void vc4_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\t \n}\n\nu32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(plane->state);\n\tint i;\n\tint idx;\n\n\tif (!drm_dev_enter(plane->dev, &idx))\n\t\tgoto out;\n\n\tvc4_state->hw_dlist = dlist;\n\n\t \n\tfor (i = 0; i < vc4_state->dlist_count; i++)\n\t\twritel(vc4_state->dlist[i], &dlist[i]);\n\n\tdrm_dev_exit(idx);\n\nout:\n\treturn vc4_state->dlist_count;\n}\n\nu32 vc4_plane_dlist_size(const struct drm_plane_state *state)\n{\n\tconst struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);\n\n\treturn vc4_state->dlist_count;\n}\n\n \nvoid vc4_plane_async_set_fb(struct drm_plane *plane, struct drm_framebuffer *fb)\n{\n\tstruct vc4_plane_state *vc4_state = to_vc4_plane_state(plane->state);\n\tstruct drm_gem_dma_object *bo = drm_fb_dma_get_gem_obj(fb, 0);\n\tuint32_t addr;\n\tint idx;\n\n\tif (!drm_dev_enter(plane->dev, &idx))\n\t\treturn;\n\n\t \n\tWARN_ON_ONCE(plane->state->crtc_x < 0 || plane->state->crtc_y < 0);\n\taddr = bo->dma_addr + fb->offsets[0];\n\n\t \n\twritel(addr, &vc4_state->hw_dlist[vc4_state->ptr0_offset]);\n\n\t \n\tvc4_state->dlist[vc4_state->ptr0_offset] = addr;\n\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct vc4_plane_state *vc4_state, *new_vc4_state;\n\tint idx;\n\n\tif (!drm_dev_enter(plane->dev, &idx))\n\t\treturn;\n\n\tswap(plane->state->fb, new_plane_state->fb);\n\tplane->state->crtc_x = new_plane_state->crtc_x;\n\tplane->state->crtc_y = new_plane_state->crtc_y;\n\tplane->state->crtc_w = new_plane_state->crtc_w;\n\tplane->state->crtc_h = new_plane_state->crtc_h;\n\tplane->state->src_x = new_plane_state->src_x;\n\tplane->state->src_y = new_plane_state->src_y;\n\tplane->state->src_w = new_plane_state->src_w;\n\tplane->state->src_h = new_plane_state->src_h;\n\tplane->state->alpha = new_plane_state->alpha;\n\tplane->state->pixel_blend_mode = new_plane_state->pixel_blend_mode;\n\tplane->state->rotation = new_plane_state->rotation;\n\tplane->state->zpos = new_plane_state->zpos;\n\tplane->state->normalized_zpos = new_plane_state->normalized_zpos;\n\tplane->state->color_encoding = new_plane_state->color_encoding;\n\tplane->state->color_range = new_plane_state->color_range;\n\tplane->state->src = new_plane_state->src;\n\tplane->state->dst = new_plane_state->dst;\n\tplane->state->visible = new_plane_state->visible;\n\n\tnew_vc4_state = to_vc4_plane_state(new_plane_state);\n\tvc4_state = to_vc4_plane_state(plane->state);\n\n\tvc4_state->crtc_x = new_vc4_state->crtc_x;\n\tvc4_state->crtc_y = new_vc4_state->crtc_y;\n\tvc4_state->crtc_h = new_vc4_state->crtc_h;\n\tvc4_state->crtc_w = new_vc4_state->crtc_w;\n\tvc4_state->src_x = new_vc4_state->src_x;\n\tvc4_state->src_y = new_vc4_state->src_y;\n\tmemcpy(vc4_state->src_w, new_vc4_state->src_w,\n\t       sizeof(vc4_state->src_w));\n\tmemcpy(vc4_state->src_h, new_vc4_state->src_h,\n\t       sizeof(vc4_state->src_h));\n\tmemcpy(vc4_state->x_scaling, new_vc4_state->x_scaling,\n\t       sizeof(vc4_state->x_scaling));\n\tmemcpy(vc4_state->y_scaling, new_vc4_state->y_scaling,\n\t       sizeof(vc4_state->y_scaling));\n\tvc4_state->is_unity = new_vc4_state->is_unity;\n\tvc4_state->is_yuv = new_vc4_state->is_yuv;\n\tmemcpy(vc4_state->offsets, new_vc4_state->offsets,\n\t       sizeof(vc4_state->offsets));\n\tvc4_state->needs_bg_fill = new_vc4_state->needs_bg_fill;\n\n\t \n\tvc4_state->dlist[vc4_state->pos0_offset] =\n\t\tnew_vc4_state->dlist[vc4_state->pos0_offset];\n\tvc4_state->dlist[vc4_state->pos2_offset] =\n\t\tnew_vc4_state->dlist[vc4_state->pos2_offset];\n\tvc4_state->dlist[vc4_state->ptr0_offset] =\n\t\tnew_vc4_state->dlist[vc4_state->ptr0_offset];\n\n\t \n\twritel(vc4_state->dlist[vc4_state->pos0_offset],\n\t       &vc4_state->hw_dlist[vc4_state->pos0_offset]);\n\twritel(vc4_state->dlist[vc4_state->pos2_offset],\n\t       &vc4_state->hw_dlist[vc4_state->pos2_offset]);\n\twritel(vc4_state->dlist[vc4_state->ptr0_offset],\n\t       &vc4_state->hw_dlist[vc4_state->ptr0_offset]);\n\n\tdrm_dev_exit(idx);\n}\n\nstatic int vc4_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct vc4_plane_state *old_vc4_state, *new_vc4_state;\n\tint ret;\n\tu32 i;\n\n\tret = vc4_plane_mode_set(plane, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\told_vc4_state = to_vc4_plane_state(plane->state);\n\tnew_vc4_state = to_vc4_plane_state(new_plane_state);\n\n\tif (!new_vc4_state->hw_dlist)\n\t\treturn -EINVAL;\n\n\tif (old_vc4_state->dlist_count != new_vc4_state->dlist_count ||\n\t    old_vc4_state->pos0_offset != new_vc4_state->pos0_offset ||\n\t    old_vc4_state->pos2_offset != new_vc4_state->pos2_offset ||\n\t    old_vc4_state->ptr0_offset != new_vc4_state->ptr0_offset ||\n\t    vc4_lbm_size(plane->state) != vc4_lbm_size(new_plane_state))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < new_vc4_state->dlist_count; i++) {\n\t\tif (i == new_vc4_state->pos0_offset ||\n\t\t    i == new_vc4_state->pos2_offset ||\n\t\t    i == new_vc4_state->ptr0_offset ||\n\t\t    (new_vc4_state->lbm_offset &&\n\t\t     i == new_vc4_state->lbm_offset))\n\t\t\tcontinue;\n\n\t\tif (new_vc4_state->dlist[i] != old_vc4_state->dlist[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc4_prepare_fb(struct drm_plane *plane,\n\t\t\t  struct drm_plane_state *state)\n{\n\tstruct vc4_bo *bo;\n\n\tif (!state->fb)\n\t\treturn 0;\n\n\tbo = to_vc4_bo(&drm_fb_dma_get_gem_obj(state->fb, 0)->base);\n\n\tdrm_gem_plane_helper_prepare_fb(plane, state);\n\n\tif (plane->state->fb == state->fb)\n\t\treturn 0;\n\n\treturn vc4_bo_inc_usecnt(bo);\n}\n\nstatic void vc4_cleanup_fb(struct drm_plane *plane,\n\t\t\t   struct drm_plane_state *state)\n{\n\tstruct vc4_bo *bo;\n\n\tif (plane->state->fb == state->fb || !state->fb)\n\t\treturn;\n\n\tbo = to_vc4_bo(&drm_fb_dma_get_gem_obj(state->fb, 0)->base);\n\tvc4_bo_dec_usecnt(bo);\n}\n\nstatic const struct drm_plane_helper_funcs vc4_plane_helper_funcs = {\n\t.atomic_check = vc4_plane_atomic_check,\n\t.atomic_update = vc4_plane_atomic_update,\n\t.prepare_fb = vc4_prepare_fb,\n\t.cleanup_fb = vc4_cleanup_fb,\n\t.atomic_async_check = vc4_plane_atomic_async_check,\n\t.atomic_async_update = vc4_plane_atomic_async_update,\n};\n\nstatic const struct drm_plane_helper_funcs vc5_plane_helper_funcs = {\n\t.atomic_check = vc4_plane_atomic_check,\n\t.atomic_update = vc4_plane_atomic_update,\n\t.atomic_async_check = vc4_plane_atomic_async_check,\n\t.atomic_async_update = vc4_plane_atomic_async_update,\n};\n\nstatic bool vc4_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t     uint32_t format,\n\t\t\t\t     uint64_t modifier)\n{\n\t \n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_BGR565:\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\t\tswitch (fourcc_mod_broadcom_mod(modifier)) {\n\t\tcase DRM_FORMAT_MOD_LINEAR:\n\t\tcase DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\tswitch (fourcc_mod_broadcom_mod(modifier)) {\n\t\tcase DRM_FORMAT_MOD_LINEAR:\n\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND64:\n\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND128:\n\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND256:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tcase DRM_FORMAT_P030:\n\t\tswitch (fourcc_mod_broadcom_mod(modifier)) {\n\t\tcase DRM_FORMAT_MOD_BROADCOM_SAND128:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tcase DRM_FORMAT_RGBX1010102:\n\tcase DRM_FORMAT_BGRX1010102:\n\tcase DRM_FORMAT_RGBA1010102:\n\tcase DRM_FORMAT_BGRA1010102:\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XBGR4444:\n\tcase DRM_FORMAT_ABGR4444:\n\tcase DRM_FORMAT_RGBX4444:\n\tcase DRM_FORMAT_RGBA4444:\n\tcase DRM_FORMAT_BGRX4444:\n\tcase DRM_FORMAT_BGRA4444:\n\tcase DRM_FORMAT_RGB332:\n\tcase DRM_FORMAT_BGR233:\n\tcase DRM_FORMAT_YUV422:\n\tcase DRM_FORMAT_YVU422:\n\tcase DRM_FORMAT_YUV420:\n\tcase DRM_FORMAT_YVU420:\n\tcase DRM_FORMAT_NV16:\n\tcase DRM_FORMAT_NV61:\n\tdefault:\n\t\treturn (modifier == DRM_FORMAT_MOD_LINEAR);\n\t}\n}\n\nstatic const struct drm_plane_funcs vc4_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = vc4_plane_reset,\n\t.atomic_duplicate_state = vc4_plane_duplicate_state,\n\t.atomic_destroy_state = vc4_plane_destroy_state,\n\t.format_mod_supported = vc4_format_mod_supported,\n};\n\nstruct drm_plane *vc4_plane_init(struct drm_device *dev,\n\t\t\t\t enum drm_plane_type type,\n\t\t\t\t uint32_t possible_crtcs)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_plane *plane;\n\tstruct vc4_plane *vc4_plane;\n\tu32 formats[ARRAY_SIZE(hvs_formats)];\n\tint num_formats = 0;\n\tunsigned i;\n\tstatic const uint64_t modifiers[] = {\n\t\tDRM_FORMAT_MOD_BROADCOM_VC4_T_TILED,\n\t\tDRM_FORMAT_MOD_BROADCOM_SAND128,\n\t\tDRM_FORMAT_MOD_BROADCOM_SAND64,\n\t\tDRM_FORMAT_MOD_BROADCOM_SAND256,\n\t\tDRM_FORMAT_MOD_LINEAR,\n\t\tDRM_FORMAT_MOD_INVALID\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(hvs_formats); i++) {\n\t\tif (!hvs_formats[i].hvs5_only || vc4->is_vc5) {\n\t\t\tformats[num_formats] = hvs_formats[i].drm;\n\t\t\tnum_formats++;\n\t\t}\n\t}\n\n\tvc4_plane = drmm_universal_plane_alloc(dev, struct vc4_plane, base,\n\t\t\t\t\t       possible_crtcs,\n\t\t\t\t\t       &vc4_plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       modifiers, type, NULL);\n\tif (IS_ERR(vc4_plane))\n\t\treturn ERR_CAST(vc4_plane);\n\tplane = &vc4_plane->base;\n\n\tif (vc4->is_vc5)\n\t\tdrm_plane_helper_add(plane, &vc5_plane_helper_funcs);\n\telse\n\t\tdrm_plane_helper_add(plane, &vc4_plane_helper_funcs);\n\n\tdrm_plane_create_alpha_property(plane);\n\tdrm_plane_create_blend_mode_property(plane,\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_COVERAGE));\n\tdrm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,\n\t\t\t\t\t   DRM_MODE_ROTATE_0 |\n\t\t\t\t\t   DRM_MODE_ROTATE_180 |\n\t\t\t\t\t   DRM_MODE_REFLECT_X |\n\t\t\t\t\t   DRM_MODE_REFLECT_Y);\n\n\tdrm_plane_create_color_properties(plane,\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT709) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT2020),\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\t  DRM_COLOR_YCBCR_BT709,\n\t\t\t\t\t  DRM_COLOR_YCBCR_LIMITED_RANGE);\n\n\tif (type == DRM_PLANE_TYPE_PRIMARY)\n\t\tdrm_plane_create_zpos_immutable_property(plane, 0);\n\n\treturn plane;\n}\n\n#define VC4_NUM_OVERLAY_PLANES\t16\n\nint vc4_plane_create_additional_planes(struct drm_device *drm)\n{\n\tstruct drm_plane *cursor_plane;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < VC4_NUM_OVERLAY_PLANES; i++) {\n\t\tstruct drm_plane *plane =\n\t\t\tvc4_plane_init(drm, DRM_PLANE_TYPE_OVERLAY,\n\t\t\t\t       GENMASK(drm->mode_config.num_crtc - 1, 0));\n\n\t\tif (IS_ERR(plane))\n\t\t\tcontinue;\n\n\t\t \n\t\tdrm_plane_create_zpos_property(plane, i + 1, 1,\n\t\t\t\t\t       VC4_NUM_OVERLAY_PLANES + 1);\n\t}\n\n\tdrm_for_each_crtc(crtc, drm) {\n\t\t \n\t\tcursor_plane = vc4_plane_init(drm, DRM_PLANE_TYPE_CURSOR,\n\t\t\t\t\t      drm_crtc_mask(crtc));\n\t\tif (!IS_ERR(cursor_plane)) {\n\t\t\tcrtc->cursor = cursor_plane;\n\n\t\t\tdrm_plane_create_zpos_property(cursor_plane,\n\t\t\t\t\t\t       VC4_NUM_OVERLAY_PLANES + 1,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       VC4_NUM_OVERLAY_PLANES + 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}