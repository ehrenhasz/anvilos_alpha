{
  "module_name": "vc4_vec.c",
  "hash_id": "60afb12b55cd718be277c17ff17e36bb21bdd5b87142010e146725c826b4d11d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_vec.c",
  "human_readable_source": "\n \n\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\n \n#define VEC_WSE_RESET\t\t\t0xc0\n\n#define VEC_WSE_CONTROL\t\t\t0xc4\n#define VEC_WSE_WSS_ENABLE\t\tBIT(7)\n\n#define VEC_WSE_WSS_DATA\t\t0xc8\n#define VEC_WSE_VPS_DATA1\t\t0xcc\n#define VEC_WSE_VPS_CONTROL\t\t0xd0\n\n \n#define VEC_REVID\t\t\t0x100\n\n#define VEC_CONFIG0\t\t\t0x104\n#define VEC_CONFIG0_YDEL_MASK\t\tGENMASK(28, 26)\n#define VEC_CONFIG0_YDEL(x)\t\t((x) << 26)\n#define VEC_CONFIG0_CDEL_MASK\t\tGENMASK(25, 24)\n#define VEC_CONFIG0_CDEL(x)\t\t((x) << 24)\n#define VEC_CONFIG0_SECAM_STD\t\tBIT(21)\n#define VEC_CONFIG0_PBPR_FIL\t\tBIT(18)\n#define VEC_CONFIG0_CHROMA_GAIN_MASK\tGENMASK(17, 16)\n#define VEC_CONFIG0_CHROMA_GAIN_UNITY\t(0 << 16)\n#define VEC_CONFIG0_CHROMA_GAIN_1_32\t(1 << 16)\n#define VEC_CONFIG0_CHROMA_GAIN_1_16\t(2 << 16)\n#define VEC_CONFIG0_CHROMA_GAIN_1_8\t(3 << 16)\n#define VEC_CONFIG0_CBURST_GAIN_MASK\tGENMASK(14, 13)\n#define VEC_CONFIG0_CBURST_GAIN_UNITY\t(0 << 13)\n#define VEC_CONFIG0_CBURST_GAIN_1_128\t(1 << 13)\n#define VEC_CONFIG0_CBURST_GAIN_1_64\t(2 << 13)\n#define VEC_CONFIG0_CBURST_GAIN_1_32\t(3 << 13)\n#define VEC_CONFIG0_CHRBW1\t\tBIT(11)\n#define VEC_CONFIG0_CHRBW0\t\tBIT(10)\n#define VEC_CONFIG0_SYNCDIS\t\tBIT(9)\n#define VEC_CONFIG0_BURDIS\t\tBIT(8)\n#define VEC_CONFIG0_CHRDIS\t\tBIT(7)\n#define VEC_CONFIG0_PDEN\t\tBIT(6)\n#define VEC_CONFIG0_YCDELAY\t\tBIT(4)\n#define VEC_CONFIG0_RAMPEN\t\tBIT(2)\n#define VEC_CONFIG0_YCDIS\t\tBIT(2)\n#define VEC_CONFIG0_STD_MASK\t\tGENMASK(1, 0)\n#define VEC_CONFIG0_NTSC_STD\t\t0\n#define VEC_CONFIG0_PAL_BDGHI_STD\t1\n#define VEC_CONFIG0_PAL_M_STD\t\t2\n#define VEC_CONFIG0_PAL_N_STD\t\t3\n\n#define VEC_SCHPH\t\t\t0x108\n#define VEC_SOFT_RESET\t\t\t0x10c\n#define VEC_CLMP0_START\t\t\t0x144\n#define VEC_CLMP0_END\t\t\t0x148\n\n \n#define VEC_FREQ3_2\t\t\t0x180\n#define VEC_FREQ1_0\t\t\t0x184\n\n#define VEC_CONFIG1\t\t\t0x188\n#define VEC_CONFIG_VEC_RESYNC_OFF\tBIT(18)\n#define VEC_CONFIG_RGB219\t\tBIT(17)\n#define VEC_CONFIG_CBAR_EN\t\tBIT(16)\n#define VEC_CONFIG_TC_OBB\t\tBIT(15)\n#define VEC_CONFIG1_OUTPUT_MODE_MASK\tGENMASK(12, 10)\n#define VEC_CONFIG1_C_Y_CVBS\t\t(0 << 10)\n#define VEC_CONFIG1_CVBS_Y_C\t\t(1 << 10)\n#define VEC_CONFIG1_PR_Y_PB\t\t(2 << 10)\n#define VEC_CONFIG1_RGB\t\t\t(4 << 10)\n#define VEC_CONFIG1_Y_C_CVBS\t\t(5 << 10)\n#define VEC_CONFIG1_C_CVBS_Y\t\t(6 << 10)\n#define VEC_CONFIG1_C_CVBS_CVBS\t\t(7 << 10)\n#define VEC_CONFIG1_DIS_CHR\t\tBIT(9)\n#define VEC_CONFIG1_DIS_LUMA\t\tBIT(8)\n#define VEC_CONFIG1_YCBCR_IN\t\tBIT(6)\n#define VEC_CONFIG1_DITHER_TYPE_LFSR\t0\n#define VEC_CONFIG1_DITHER_TYPE_COUNTER\tBIT(5)\n#define VEC_CONFIG1_DITHER_EN\t\tBIT(4)\n#define VEC_CONFIG1_CYDELAY\t\tBIT(3)\n#define VEC_CONFIG1_LUMADIS\t\tBIT(2)\n#define VEC_CONFIG1_COMPDIS\t\tBIT(1)\n#define VEC_CONFIG1_CUSTOM_FREQ\t\tBIT(0)\n\n#define VEC_CONFIG2\t\t\t0x18c\n#define VEC_CONFIG2_PROG_SCAN\t\tBIT(15)\n#define VEC_CONFIG2_SYNC_ADJ_MASK\tGENMASK(14, 12)\n#define VEC_CONFIG2_SYNC_ADJ(x)\t\t(((x) / 2) << 12)\n#define VEC_CONFIG2_PBPR_EN\t\tBIT(10)\n#define VEC_CONFIG2_UV_DIG_DIS\t\tBIT(6)\n#define VEC_CONFIG2_RGB_DIG_DIS\t\tBIT(5)\n#define VEC_CONFIG2_TMUX_MASK\t\tGENMASK(3, 2)\n#define VEC_CONFIG2_TMUX_DRIVE0\t\t(0 << 2)\n#define VEC_CONFIG2_TMUX_RG_COMP\t(1 << 2)\n#define VEC_CONFIG2_TMUX_UV_YC\t\t(2 << 2)\n#define VEC_CONFIG2_TMUX_SYNC_YC\t(3 << 2)\n\n#define VEC_INTERRUPT_CONTROL\t\t0x190\n#define VEC_INTERRUPT_STATUS\t\t0x194\n\n \n#define VEC_FCW_SECAM_B\t\t\t0x198\n#define VEC_SECAM_GAIN_VAL\t\t0x19c\n\n#define VEC_CONFIG3\t\t\t0x1a0\n#define VEC_CONFIG3_HORIZ_LEN_STD\t(0 << 0)\n#define VEC_CONFIG3_HORIZ_LEN_MPEG1_SIF\t(1 << 0)\n#define VEC_CONFIG3_SHAPE_NON_LINEAR\tBIT(1)\n\n#define VEC_STATUS0\t\t\t0x200\n#define VEC_MASK0\t\t\t0x204\n\n#define VEC_CFG\t\t\t\t0x208\n#define VEC_CFG_SG_MODE_MASK\t\tGENMASK(6, 5)\n#define VEC_CFG_SG_MODE(x)\t\t((x) << 5)\n#define VEC_CFG_SG_EN\t\t\tBIT(4)\n#define VEC_CFG_VEC_EN\t\t\tBIT(3)\n#define VEC_CFG_MB_EN\t\t\tBIT(2)\n#define VEC_CFG_ENABLE\t\t\tBIT(1)\n#define VEC_CFG_TB_EN\t\t\tBIT(0)\n\n#define VEC_DAC_TEST\t\t\t0x20c\n\n#define VEC_DAC_CONFIG\t\t\t0x210\n#define VEC_DAC_CONFIG_LDO_BIAS_CTRL(x)\t((x) << 24)\n#define VEC_DAC_CONFIG_DRIVER_CTRL(x)\t((x) << 16)\n#define VEC_DAC_CONFIG_DAC_CTRL(x)\t(x)\n\n#define VEC_DAC_MISC\t\t\t0x214\n#define VEC_DAC_MISC_VCD_CTRL_MASK\tGENMASK(31, 16)\n#define VEC_DAC_MISC_VCD_CTRL(x)\t((x) << 16)\n#define VEC_DAC_MISC_VID_ACT\t\tBIT(8)\n#define VEC_DAC_MISC_VCD_PWRDN\t\tBIT(6)\n#define VEC_DAC_MISC_BIAS_PWRDN\t\tBIT(5)\n#define VEC_DAC_MISC_DAC_PWRDN\t\tBIT(2)\n#define VEC_DAC_MISC_LDO_PWRDN\t\tBIT(1)\n#define VEC_DAC_MISC_DAC_RST_N\t\tBIT(0)\n\n\nstruct vc4_vec_variant {\n\tu32 dac_config;\n};\n\n \nstruct vc4_vec {\n\tstruct vc4_encoder encoder;\n\tstruct drm_connector connector;\n\n\tstruct platform_device *pdev;\n\tconst struct vc4_vec_variant *variant;\n\n\tvoid __iomem *regs;\n\n\tstruct clk *clock;\n\n\tstruct drm_property *legacy_tv_mode_property;\n\n\tstruct debugfs_regset32 regset;\n};\n\n#define VEC_READ(offset)\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\treadl(vec->regs + (offset));\t\t\t\t\t\t\\\n\t})\n\n#define VEC_WRITE(offset, val)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tkunit_fail_current_test(\"Accessing a register in a unit test!\\n\");\t\\\n\t\twritel(val, vec->regs + (offset));\t\t\t\t\t\\\n\t} while (0)\n\n#define encoder_to_vc4_vec(_encoder)\t\t\t\t\t\\\n\tcontainer_of_const(_encoder, struct vc4_vec, encoder.base)\n\n#define connector_to_vc4_vec(_connector)\t\t\t\t\\\n\tcontainer_of_const(_connector, struct vc4_vec, connector)\n\nenum vc4_vec_tv_mode_id {\n\tVC4_VEC_TV_MODE_NTSC,\n\tVC4_VEC_TV_MODE_NTSC_J,\n\tVC4_VEC_TV_MODE_PAL,\n\tVC4_VEC_TV_MODE_PAL_M,\n\tVC4_VEC_TV_MODE_NTSC_443,\n\tVC4_VEC_TV_MODE_PAL_60,\n\tVC4_VEC_TV_MODE_PAL_N,\n\tVC4_VEC_TV_MODE_SECAM,\n};\n\nstruct vc4_vec_tv_mode {\n\tunsigned int mode;\n\tu16 expected_htotal;\n\tu32 config0;\n\tu32 config1;\n\tu32 custom_freq;\n};\n\nstatic const struct debugfs_reg32 vec_regs[] = {\n\tVC4_REG32(VEC_WSE_CONTROL),\n\tVC4_REG32(VEC_WSE_WSS_DATA),\n\tVC4_REG32(VEC_WSE_VPS_DATA1),\n\tVC4_REG32(VEC_WSE_VPS_CONTROL),\n\tVC4_REG32(VEC_REVID),\n\tVC4_REG32(VEC_CONFIG0),\n\tVC4_REG32(VEC_SCHPH),\n\tVC4_REG32(VEC_CLMP0_START),\n\tVC4_REG32(VEC_CLMP0_END),\n\tVC4_REG32(VEC_FREQ3_2),\n\tVC4_REG32(VEC_FREQ1_0),\n\tVC4_REG32(VEC_CONFIG1),\n\tVC4_REG32(VEC_CONFIG2),\n\tVC4_REG32(VEC_INTERRUPT_CONTROL),\n\tVC4_REG32(VEC_INTERRUPT_STATUS),\n\tVC4_REG32(VEC_FCW_SECAM_B),\n\tVC4_REG32(VEC_SECAM_GAIN_VAL),\n\tVC4_REG32(VEC_CONFIG3),\n\tVC4_REG32(VEC_STATUS0),\n\tVC4_REG32(VEC_MASK0),\n\tVC4_REG32(VEC_CFG),\n\tVC4_REG32(VEC_DAC_TEST),\n\tVC4_REG32(VEC_DAC_CONFIG),\n\tVC4_REG32(VEC_DAC_MISC),\n};\n\nstatic const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_NTSC,\n\t\t.expected_htotal = 858,\n\t\t.config0 = VEC_CONFIG0_NTSC_STD | VEC_CONFIG0_PDEN,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_NTSC_443,\n\t\t.expected_htotal = 858,\n\t\t.config0 = VEC_CONFIG0_NTSC_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ,\n\t\t.custom_freq = 0x2a098acb,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_NTSC_J,\n\t\t.expected_htotal = 858,\n\t\t.config0 = VEC_CONFIG0_NTSC_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_PAL,\n\t\t.expected_htotal = 864,\n\t\t.config0 = VEC_CONFIG0_PAL_BDGHI_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t},\n\t{\n\t\t \n\t\t.mode = DRM_MODE_TV_MODE_PAL,\n\t\t.expected_htotal = 858,\n\t\t.config0 = VEC_CONFIG0_PAL_M_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ,\n\t\t.custom_freq = 0x2a098acb,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_PAL_M,\n\t\t.expected_htotal = 858,\n\t\t.config0 = VEC_CONFIG0_PAL_M_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_PAL_N,\n\t\t.expected_htotal = 864,\n\t\t.config0 = VEC_CONFIG0_PAL_N_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t},\n\t{\n\t\t.mode = DRM_MODE_TV_MODE_SECAM,\n\t\t.expected_htotal = 864,\n\t\t.config0 = VEC_CONFIG0_SECAM_STD,\n\t\t.config1 = VEC_CONFIG1_C_CVBS_CVBS,\n\t\t.custom_freq = 0x29c71c72,\n\t},\n};\n\nstatic inline const struct vc4_vec_tv_mode *\nvc4_vec_tv_mode_lookup(unsigned int mode, u16 htotal)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vc4_vec_tv_modes); i++) {\n\t\tconst struct vc4_vec_tv_mode *tv_mode = &vc4_vec_tv_modes[i];\n\n\t\tif (tv_mode->mode == mode &&\n\t\t    tv_mode->expected_htotal == htotal)\n\t\t\treturn tv_mode;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct drm_prop_enum_list legacy_tv_mode_names[] = {\n\t{ VC4_VEC_TV_MODE_NTSC, \"NTSC\", },\n\t{ VC4_VEC_TV_MODE_NTSC_443, \"NTSC-443\", },\n\t{ VC4_VEC_TV_MODE_NTSC_J, \"NTSC-J\", },\n\t{ VC4_VEC_TV_MODE_PAL, \"PAL\", },\n\t{ VC4_VEC_TV_MODE_PAL_60, \"PAL-60\", },\n\t{ VC4_VEC_TV_MODE_PAL_M, \"PAL-M\", },\n\t{ VC4_VEC_TV_MODE_PAL_N, \"PAL-N\", },\n\t{ VC4_VEC_TV_MODE_SECAM, \"SECAM\", },\n};\n\nstatic enum drm_connector_status\nvc4_vec_connector_detect(struct drm_connector *connector, bool force)\n{\n\treturn connector_status_unknown;\n}\n\nstatic void vc4_vec_connector_reset(struct drm_connector *connector)\n{\n\tdrm_atomic_helper_connector_reset(connector);\n\tdrm_atomic_helper_connector_tv_reset(connector);\n}\n\nstatic int\nvc4_vec_connector_set_property(struct drm_connector *connector,\n\t\t\t       struct drm_connector_state *state,\n\t\t\t       struct drm_property *property,\n\t\t\t       uint64_t val)\n{\n\tstruct vc4_vec *vec = connector_to_vc4_vec(connector);\n\n\tif (property != vec->legacy_tv_mode_property)\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase VC4_VEC_TV_MODE_NTSC:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_NTSC;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_NTSC_443:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_NTSC_443;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_NTSC_J:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_NTSC_J;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_PAL:\n\tcase VC4_VEC_TV_MODE_PAL_60:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_PAL;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_PAL_M:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_PAL_M;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_PAL_N:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_PAL_N;\n\t\tbreak;\n\n\tcase VC4_VEC_TV_MODE_SECAM:\n\t\tstate->tv.mode = DRM_MODE_TV_MODE_SECAM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvc4_vec_connector_get_property(struct drm_connector *connector,\n\t\t\t       const struct drm_connector_state *state,\n\t\t\t       struct drm_property *property,\n\t\t\t       uint64_t *val)\n{\n\tstruct vc4_vec *vec = connector_to_vc4_vec(connector);\n\n\tif (property != vec->legacy_tv_mode_property)\n\t\treturn -EINVAL;\n\n\tswitch (state->tv.mode) {\n\tcase DRM_MODE_TV_MODE_NTSC:\n\t\t*val = VC4_VEC_TV_MODE_NTSC;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_NTSC_443:\n\t\t*val = VC4_VEC_TV_MODE_NTSC_443;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_NTSC_J:\n\t\t*val = VC4_VEC_TV_MODE_NTSC_J;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_PAL:\n\t\t*val = VC4_VEC_TV_MODE_PAL;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_PAL_M:\n\t\t*val = VC4_VEC_TV_MODE_PAL_M;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_PAL_N:\n\t\t*val = VC4_VEC_TV_MODE_PAL_N;\n\t\tbreak;\n\n\tcase DRM_MODE_TV_MODE_SECAM:\n\t\t*val = VC4_VEC_TV_MODE_SECAM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs vc4_vec_connector_funcs = {\n\t.detect = vc4_vec_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.reset = vc4_vec_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_get_property = vc4_vec_connector_get_property,\n\t.atomic_set_property = vc4_vec_connector_set_property,\n};\n\nstatic const struct drm_connector_helper_funcs vc4_vec_connector_helper_funcs = {\n\t.atomic_check = drm_atomic_helper_connector_tv_check,\n\t.get_modes = drm_connector_helper_tv_get_modes,\n};\n\nstatic int vc4_vec_connector_init(struct drm_device *dev, struct vc4_vec *vec)\n{\n\tstruct drm_connector *connector = &vec->connector;\n\tstruct drm_property *prop;\n\tint ret;\n\n\tconnector->interlace_allowed = true;\n\n\tret = drmm_connector_init(dev, connector, &vc4_vec_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_Composite, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &vc4_vec_connector_helper_funcs);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   dev->mode_config.tv_mode_property,\n\t\t\t\t   DRM_MODE_TV_MODE_NTSC);\n\n\tprop = drm_property_create_enum(dev, 0, \"mode\",\n\t\t\t\t\tlegacy_tv_mode_names,\n\t\t\t\t\tARRAY_SIZE(legacy_tv_mode_names));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\tvec->legacy_tv_mode_property = prop;\n\n\tdrm_object_attach_property(&connector->base, prop, VC4_VEC_TV_MODE_NTSC);\n\n\tdrm_connector_attach_encoder(connector, &vec->encoder.base);\n\n\treturn 0;\n}\n\nstatic void vc4_vec_encoder_disable(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_vec *vec = encoder_to_vc4_vec(encoder);\n\tint idx, ret;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\tVEC_WRITE(VEC_CFG, 0);\n\tVEC_WRITE(VEC_DAC_MISC,\n\t\t  VEC_DAC_MISC_VCD_PWRDN |\n\t\t  VEC_DAC_MISC_BIAS_PWRDN |\n\t\t  VEC_DAC_MISC_DAC_PWRDN |\n\t\t  VEC_DAC_MISC_LDO_PWRDN);\n\n\tclk_disable_unprepare(vec->clock);\n\n\tret = pm_runtime_put(&vec->pdev->dev);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to release power domain: %d\\n\", ret);\n\t\tgoto err_dev_exit;\n\t}\n\n\tdrm_dev_exit(idx);\n\treturn;\n\nerr_dev_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic void vc4_vec_encoder_enable(struct drm_encoder *encoder,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_vec *vec = encoder_to_vc4_vec(encoder);\n\tstruct drm_connector *connector = &vec->connector;\n\tstruct drm_connector_state *conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\tstruct drm_display_mode *adjusted_mode =\n\t\t&encoder->crtc->state->adjusted_mode;\n\tconst struct vc4_vec_tv_mode *tv_mode;\n\tint idx, ret;\n\n\tif (!drm_dev_enter(drm, &idx))\n\t\treturn;\n\n\ttv_mode = vc4_vec_tv_mode_lookup(conn_state->tv.mode,\n\t\t\t\t\t adjusted_mode->htotal);\n\tif (!tv_mode)\n\t\tgoto err_dev_exit;\n\n\tret = pm_runtime_resume_and_get(&vec->pdev->dev);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to retain power domain: %d\\n\", ret);\n\t\tgoto err_dev_exit;\n\t}\n\n\t \n\tret = clk_set_rate(vec->clock, 108000000);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to set clock rate: %d\\n\", ret);\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\tret = clk_prepare_enable(vec->clock);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to turn on core clock: %d\\n\", ret);\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\t \n\tVEC_WRITE(VEC_WSE_RESET, 1);\n\tVEC_WRITE(VEC_SOFT_RESET, 1);\n\n\t \n\tVEC_WRITE(VEC_WSE_CONTROL, 0);\n\n\t \n\n\t \n\tVEC_WRITE(VEC_SCHPH, 0x28);\n\n\t \n\tVEC_WRITE(VEC_CLMP0_START, 0xac);\n\tVEC_WRITE(VEC_CLMP0_END, 0xec);\n\tVEC_WRITE(VEC_CONFIG2,\n\t\t  VEC_CONFIG2_UV_DIG_DIS |\n\t\t  VEC_CONFIG2_RGB_DIG_DIS |\n\t\t  ((adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) ? 0 : VEC_CONFIG2_PROG_SCAN));\n\tVEC_WRITE(VEC_CONFIG3, VEC_CONFIG3_HORIZ_LEN_STD);\n\tVEC_WRITE(VEC_DAC_CONFIG, vec->variant->dac_config);\n\n\t \n\tVEC_WRITE(VEC_MASK0, 0);\n\n\tVEC_WRITE(VEC_CONFIG0, tv_mode->config0);\n\tVEC_WRITE(VEC_CONFIG1, tv_mode->config1);\n\n\tif (tv_mode->custom_freq) {\n\t\tVEC_WRITE(VEC_FREQ3_2,\n\t\t\t  (tv_mode->custom_freq >> 16) & 0xffff);\n\t\tVEC_WRITE(VEC_FREQ1_0,\n\t\t\t  tv_mode->custom_freq & 0xffff);\n\t}\n\n\tVEC_WRITE(VEC_DAC_MISC,\n\t\t  VEC_DAC_MISC_VID_ACT | VEC_DAC_MISC_DAC_RST_N);\n\tVEC_WRITE(VEC_CFG, VEC_CFG_VEC_EN);\n\n\tdrm_dev_exit(idx);\n\treturn;\n\nerr_put_runtime_pm:\n\tpm_runtime_put(&vec->pdev->dev);\nerr_dev_exit:\n\tdrm_dev_exit(idx);\n}\n\nstatic int vc4_vec_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tconst struct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tconst struct vc4_vec_tv_mode *tv_mode;\n\n\ttv_mode = vc4_vec_tv_mode_lookup(conn_state->tv.mode, mode->htotal);\n\tif (!tv_mode)\n\t\treturn -EINVAL;\n\n\tif (mode->crtc_hdisplay % 4)\n\t\treturn -EINVAL;\n\n\tif (!(mode->crtc_hsync_end - mode->crtc_hsync_start))\n\t\treturn -EINVAL;\n\n\tswitch (mode->htotal) {\n\t \n\tcase 858:\n\t\tif (mode->crtc_vtotal > 262)\n\t\t\treturn -EINVAL;\n\n\t\tif (mode->crtc_vdisplay < 1 || mode->crtc_vdisplay > 253)\n\t\t\treturn -EINVAL;\n\n\t\tif (!(mode->crtc_vsync_start - mode->crtc_vdisplay))\n\t\t\treturn -EINVAL;\n\n\t\tif ((mode->crtc_vsync_end - mode->crtc_vsync_start) != 3)\n\t\t\treturn -EINVAL;\n\n\t\tif ((mode->crtc_vtotal - mode->crtc_vsync_end) < 4)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\t \n\tcase 864:\n\t\tif (mode->crtc_vtotal > 312)\n\t\t\treturn -EINVAL;\n\n\t\tif (mode->crtc_vdisplay < 1 || mode->crtc_vdisplay > 305)\n\t\t\treturn -EINVAL;\n\n\t\tif (!(mode->crtc_vsync_start - mode->crtc_vdisplay))\n\t\t\treturn -EINVAL;\n\n\t\tif ((mode->crtc_vsync_end - mode->crtc_vsync_start) != 3)\n\t\t\treturn -EINVAL;\n\n\t\tif ((mode->crtc_vtotal - mode->crtc_vsync_end) < 2)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs vc4_vec_encoder_helper_funcs = {\n\t.atomic_check = vc4_vec_encoder_atomic_check,\n\t.atomic_disable = vc4_vec_encoder_disable,\n\t.atomic_enable = vc4_vec_encoder_enable,\n};\n\nstatic int vc4_vec_late_register(struct drm_encoder *encoder)\n{\n\tstruct drm_device *drm = encoder->dev;\n\tstruct vc4_vec *vec = encoder_to_vc4_vec(encoder);\n\n\tvc4_debugfs_add_regset32(drm, \"vec_regs\", &vec->regset);\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_funcs vc4_vec_encoder_funcs = {\n\t.late_register = vc4_vec_late_register,\n};\n\nstatic const struct vc4_vec_variant bcm2835_vec_variant = {\n\t.dac_config = VEC_DAC_CONFIG_DAC_CTRL(0xc) |\n\t\t      VEC_DAC_CONFIG_DRIVER_CTRL(0xc) |\n\t\t      VEC_DAC_CONFIG_LDO_BIAS_CTRL(0x46)\n};\n\nstatic const struct vc4_vec_variant bcm2711_vec_variant = {\n\t.dac_config = VEC_DAC_CONFIG_DAC_CTRL(0x0) |\n\t\t      VEC_DAC_CONFIG_DRIVER_CTRL(0x80) |\n\t\t      VEC_DAC_CONFIG_LDO_BIAS_CTRL(0x61)\n};\n\nstatic const struct of_device_id vc4_vec_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-vec\", .data = &bcm2835_vec_variant },\n\t{ .compatible = \"brcm,bcm2711-vec\", .data = &bcm2711_vec_variant },\n\t{   },\n};\n\nstatic int vc4_vec_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_vec *vec;\n\tint ret;\n\n\tret = drm_mode_create_tv_properties(drm,\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_NTSC) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_NTSC_443) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_NTSC_J) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_PAL) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_PAL_M) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_PAL_N) |\n\t\t\t\t\t    BIT(DRM_MODE_TV_MODE_SECAM));\n\tif (ret)\n\t\treturn ret;\n\n\tvec = drmm_kzalloc(drm, sizeof(*vec), GFP_KERNEL);\n\tif (!vec)\n\t\treturn -ENOMEM;\n\n\tvec->encoder.type = VC4_ENCODER_TYPE_VEC;\n\tvec->pdev = pdev;\n\tvec->variant = (const struct vc4_vec_variant *)\n\t\tof_device_get_match_data(dev);\n\tvec->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(vec->regs))\n\t\treturn PTR_ERR(vec->regs);\n\tvec->regset.base = vec->regs;\n\tvec->regset.regs = vec_regs;\n\tvec->regset.nregs = ARRAY_SIZE(vec_regs);\n\n\tvec->clock = devm_clk_get(dev, NULL);\n\tif (IS_ERR(vec->clock)) {\n\t\tret = PTR_ERR(vec->clock);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drmm_encoder_init(drm, &vec->encoder.base,\n\t\t\t\t&vc4_vec_encoder_funcs,\n\t\t\t\tDRM_MODE_ENCODER_TVDAC,\n\t\t\t\tNULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_encoder_helper_add(&vec->encoder.base, &vc4_vec_encoder_helper_funcs);\n\n\tret = vc4_vec_connector_init(drm, vec);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, vec);\n\n\treturn 0;\n}\n\nstatic const struct component_ops vc4_vec_ops = {\n\t.bind   = vc4_vec_bind,\n};\n\nstatic int vc4_vec_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_vec_ops);\n}\n\nstatic void vc4_vec_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_vec_ops);\n}\n\nstruct platform_driver vc4_vec_driver = {\n\t.probe = vc4_vec_dev_probe,\n\t.remove_new = vc4_vec_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_vec\",\n\t\t.of_match_table = vc4_vec_dt_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}