{
  "module_name": "vc4_v3d.c",
  "hash_id": "4cae413df32fb2543437c82426dd0fa70882978158c46d57abd8507256b08e6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_v3d.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n\nstatic const struct debugfs_reg32 v3d_regs[] = {\n\tVC4_REG32(V3D_IDENT0),\n\tVC4_REG32(V3D_IDENT1),\n\tVC4_REG32(V3D_IDENT2),\n\tVC4_REG32(V3D_SCRATCH),\n\tVC4_REG32(V3D_L2CACTL),\n\tVC4_REG32(V3D_SLCACTL),\n\tVC4_REG32(V3D_INTCTL),\n\tVC4_REG32(V3D_INTENA),\n\tVC4_REG32(V3D_INTDIS),\n\tVC4_REG32(V3D_CT0CS),\n\tVC4_REG32(V3D_CT1CS),\n\tVC4_REG32(V3D_CT0EA),\n\tVC4_REG32(V3D_CT1EA),\n\tVC4_REG32(V3D_CT0CA),\n\tVC4_REG32(V3D_CT1CA),\n\tVC4_REG32(V3D_CT00RA0),\n\tVC4_REG32(V3D_CT01RA0),\n\tVC4_REG32(V3D_CT0LC),\n\tVC4_REG32(V3D_CT1LC),\n\tVC4_REG32(V3D_CT0PC),\n\tVC4_REG32(V3D_CT1PC),\n\tVC4_REG32(V3D_PCS),\n\tVC4_REG32(V3D_BFC),\n\tVC4_REG32(V3D_RFC),\n\tVC4_REG32(V3D_BPCA),\n\tVC4_REG32(V3D_BPCS),\n\tVC4_REG32(V3D_BPOA),\n\tVC4_REG32(V3D_BPOS),\n\tVC4_REG32(V3D_BXCF),\n\tVC4_REG32(V3D_SQRSV0),\n\tVC4_REG32(V3D_SQRSV1),\n\tVC4_REG32(V3D_SQCNTL),\n\tVC4_REG32(V3D_SRQPC),\n\tVC4_REG32(V3D_SRQUA),\n\tVC4_REG32(V3D_SRQUL),\n\tVC4_REG32(V3D_SRQCS),\n\tVC4_REG32(V3D_VPACNTL),\n\tVC4_REG32(V3D_VPMBASE),\n\tVC4_REG32(V3D_PCTRC),\n\tVC4_REG32(V3D_PCTRE),\n\tVC4_REG32(V3D_PCTR(0)),\n\tVC4_REG32(V3D_PCTRS(0)),\n\tVC4_REG32(V3D_PCTR(1)),\n\tVC4_REG32(V3D_PCTRS(1)),\n\tVC4_REG32(V3D_PCTR(2)),\n\tVC4_REG32(V3D_PCTRS(2)),\n\tVC4_REG32(V3D_PCTR(3)),\n\tVC4_REG32(V3D_PCTRS(3)),\n\tVC4_REG32(V3D_PCTR(4)),\n\tVC4_REG32(V3D_PCTRS(4)),\n\tVC4_REG32(V3D_PCTR(5)),\n\tVC4_REG32(V3D_PCTRS(5)),\n\tVC4_REG32(V3D_PCTR(6)),\n\tVC4_REG32(V3D_PCTRS(6)),\n\tVC4_REG32(V3D_PCTR(7)),\n\tVC4_REG32(V3D_PCTRS(7)),\n\tVC4_REG32(V3D_PCTR(8)),\n\tVC4_REG32(V3D_PCTRS(8)),\n\tVC4_REG32(V3D_PCTR(9)),\n\tVC4_REG32(V3D_PCTRS(9)),\n\tVC4_REG32(V3D_PCTR(10)),\n\tVC4_REG32(V3D_PCTRS(10)),\n\tVC4_REG32(V3D_PCTR(11)),\n\tVC4_REG32(V3D_PCTRS(11)),\n\tVC4_REG32(V3D_PCTR(12)),\n\tVC4_REG32(V3D_PCTRS(12)),\n\tVC4_REG32(V3D_PCTR(13)),\n\tVC4_REG32(V3D_PCTRS(13)),\n\tVC4_REG32(V3D_PCTR(14)),\n\tVC4_REG32(V3D_PCTRS(14)),\n\tVC4_REG32(V3D_PCTR(15)),\n\tVC4_REG32(V3D_PCTRS(15)),\n\tVC4_REG32(V3D_DBGE),\n\tVC4_REG32(V3D_FDBGO),\n\tVC4_REG32(V3D_FDBGB),\n\tVC4_REG32(V3D_FDBGR),\n\tVC4_REG32(V3D_FDBGS),\n\tVC4_REG32(V3D_ERRSTAT),\n};\n\nstatic int vc4_v3d_debugfs_ident(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tint ret = vc4_v3d_pm_get(vc4);\n\n\tif (ret == 0) {\n\t\tuint32_t ident1 = V3D_READ(V3D_IDENT1);\n\t\tuint32_t nslc = VC4_GET_FIELD(ident1, V3D_IDENT1_NSLC);\n\t\tuint32_t tups = VC4_GET_FIELD(ident1, V3D_IDENT1_TUPS);\n\t\tuint32_t qups = VC4_GET_FIELD(ident1, V3D_IDENT1_QUPS);\n\n\t\tseq_printf(m, \"Revision:   %d\\n\",\n\t\t\t   VC4_GET_FIELD(ident1, V3D_IDENT1_REV));\n\t\tseq_printf(m, \"Slices:     %d\\n\", nslc);\n\t\tseq_printf(m, \"TMUs:       %d\\n\", nslc * tups);\n\t\tseq_printf(m, \"QPUs:       %d\\n\", nslc * qups);\n\t\tseq_printf(m, \"Semaphores: %d\\n\",\n\t\t\t   VC4_GET_FIELD(ident1, V3D_IDENT1_NSEM));\n\t\tvc4_v3d_pm_put(vc4);\n\t}\n\n\treturn 0;\n}\n\n \nint\nvc4_v3d_pm_get(struct vc4_dev *vc4)\n{\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&vc4->power_lock);\n\tif (vc4->power_refcount++ == 0) {\n\t\tint ret = pm_runtime_get_sync(&vc4->v3d->pdev->dev);\n\n\t\tif (ret < 0) {\n\t\t\tvc4->power_refcount--;\n\t\t\tmutex_unlock(&vc4->power_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&vc4->power_lock);\n\n\treturn 0;\n}\n\nvoid\nvc4_v3d_pm_put(struct vc4_dev *vc4)\n{\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tmutex_lock(&vc4->power_lock);\n\tif (--vc4->power_refcount == 0) {\n\t\tpm_runtime_mark_last_busy(&vc4->v3d->pdev->dev);\n\t\tpm_runtime_put_autosuspend(&vc4->v3d->pdev->dev);\n\t}\n\tmutex_unlock(&vc4->power_lock);\n}\n\nstatic void vc4_v3d_init_hw(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\t \n\tV3D_WRITE(V3D_VPMBASE, 0);\n}\n\nint vc4_v3d_get_bin_slot(struct vc4_dev *vc4)\n{\n\tstruct drm_device *dev = &vc4->base;\n\tunsigned long irqflags;\n\tint slot;\n\tuint64_t seqno = 0;\n\tstruct vc4_exec_info *exec;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\ntry_again:\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\tslot = ffs(~vc4->bin_alloc_used);\n\tif (slot != 0) {\n\t\t \n\t\tslot--;\n\t\tvc4->bin_alloc_used |= BIT(slot);\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\treturn slot;\n\t}\n\n\t \n\texec = vc4_last_render_job(vc4);\n\tif (exec)\n\t\tseqno = exec->seqno;\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\n\tif (seqno) {\n\t\tint ret = vc4_wait_for_seqno(dev, seqno, ~0ull, true);\n\n\t\tif (ret == 0)\n\t\t\tgoto try_again;\n\n\t\treturn ret;\n\t}\n\n\treturn -ENOMEM;\n}\n\n \nstatic int bin_bo_alloc(struct vc4_dev *vc4)\n{\n\tstruct vc4_v3d *v3d = vc4->v3d;\n\tuint32_t size = 16 * 1024 * 1024;\n\tint ret = 0;\n\tstruct list_head list;\n\n\tif (!v3d)\n\t\treturn -ENODEV;\n\n\t \n\tINIT_LIST_HEAD(&list);\n\n\twhile (true) {\n\t\tstruct vc4_bo *bo = vc4_bo_create(&vc4->base, size, true,\n\t\t\t\t\t\t  VC4_BO_TYPE_BIN);\n\n\t\tif (IS_ERR(bo)) {\n\t\t\tret = PTR_ERR(bo);\n\n\t\t\tdev_err(&v3d->pdev->dev,\n\t\t\t\t\"Failed to allocate memory for tile binning: \"\n\t\t\t\t\"%d. You may need to enable DMA or give it \"\n\t\t\t\t\"more memory.\",\n\t\t\t\tret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((bo->base.dma_addr & 0xf0000000) ==\n\t\t    ((bo->base.dma_addr + bo->base.base.size - 1) & 0xf0000000)) {\n\t\t\tvc4->bin_bo = bo;\n\n\t\t\t \n\t\t\tvc4->bin_alloc_size = 512 * 1024;\n\t\t\tvc4->bin_alloc_used = 0;\n\t\t\tvc4->bin_alloc_overflow = 0;\n\t\t\tWARN_ON_ONCE(sizeof(vc4->bin_alloc_used) * 8 !=\n\t\t\t\t     bo->base.base.size / vc4->bin_alloc_size);\n\n\t\t\tkref_init(&vc4->bin_bo_kref);\n\n\t\t\t \n\t\t\tV3D_WRITE(V3D_INTENA, V3D_INT_OUTOMEM);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlist_add(&bo->unref_head, &list);\n\t}\n\n\t \n\twhile (!list_empty(&list)) {\n\t\tstruct vc4_bo *bo = list_last_entry(&list,\n\t\t\t\t\t\t    struct vc4_bo, unref_head);\n\n\t\tlist_del(&bo->unref_head);\n\t\tdrm_gem_object_put(&bo->base.base);\n\t}\n\n\treturn ret;\n}\n\nint vc4_v3d_bin_bo_get(struct vc4_dev *vc4, bool *used)\n{\n\tint ret = 0;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&vc4->bin_bo_lock);\n\n\tif (used && *used)\n\t\tgoto complete;\n\n\tif (vc4->bin_bo)\n\t\tkref_get(&vc4->bin_bo_kref);\n\telse\n\t\tret = bin_bo_alloc(vc4);\n\n\tif (ret == 0 && used)\n\t\t*used = true;\n\ncomplete:\n\tmutex_unlock(&vc4->bin_bo_lock);\n\n\treturn ret;\n}\n\nstatic void bin_bo_release(struct kref *ref)\n{\n\tstruct vc4_dev *vc4 = container_of(ref, struct vc4_dev, bin_bo_kref);\n\n\tif (WARN_ON_ONCE(!vc4->bin_bo))\n\t\treturn;\n\n\tdrm_gem_object_put(&vc4->bin_bo->base.base);\n\tvc4->bin_bo = NULL;\n}\n\nvoid vc4_v3d_bin_bo_put(struct vc4_dev *vc4)\n{\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tmutex_lock(&vc4->bin_bo_lock);\n\tkref_put(&vc4->bin_bo_kref, bin_bo_release);\n\tmutex_unlock(&vc4->bin_bo_lock);\n}\n\n#ifdef CONFIG_PM\nstatic int vc4_v3d_runtime_suspend(struct device *dev)\n{\n\tstruct vc4_v3d *v3d = dev_get_drvdata(dev);\n\tstruct vc4_dev *vc4 = v3d->vc4;\n\n\tvc4_irq_disable(&vc4->base);\n\n\tclk_disable_unprepare(v3d->clk);\n\n\treturn 0;\n}\n\nstatic int vc4_v3d_runtime_resume(struct device *dev)\n{\n\tstruct vc4_v3d *v3d = dev_get_drvdata(dev);\n\tstruct vc4_dev *vc4 = v3d->vc4;\n\tint ret;\n\n\tret = clk_prepare_enable(v3d->clk);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tvc4_v3d_init_hw(&vc4->base);\n\n\tvc4_irq_enable(&vc4->base);\n\n\treturn 0;\n}\n#endif\n\nint vc4_v3d_debugfs_init(struct drm_minor *minor)\n{\n\tstruct drm_device *drm = minor->dev;\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_v3d *v3d = vc4->v3d;\n\n\tif (!vc4->v3d)\n\t\treturn -ENODEV;\n\n\tdrm_debugfs_add_file(drm, \"v3d_ident\", vc4_v3d_debugfs_ident, NULL);\n\n\tvc4_debugfs_add_regset32(drm, \"v3d_regs\", &v3d->regset);\n\n\treturn 0;\n}\n\nstatic int vc4_v3d_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\tstruct vc4_v3d *v3d = NULL;\n\tint ret;\n\n\tv3d = devm_kzalloc(&pdev->dev, sizeof(*v3d), GFP_KERNEL);\n\tif (!v3d)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, v3d);\n\n\tv3d->pdev = pdev;\n\n\tv3d->regs = vc4_ioremap_regs(pdev, 0);\n\tif (IS_ERR(v3d->regs))\n\t\treturn PTR_ERR(v3d->regs);\n\tv3d->regset.base = v3d->regs;\n\tv3d->regset.regs = v3d_regs;\n\tv3d->regset.nregs = ARRAY_SIZE(v3d_regs);\n\n\tvc4->v3d = v3d;\n\tv3d->vc4 = vc4;\n\n\tv3d->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(v3d->clk)) {\n\t\tint ret = PTR_ERR(v3d->clk);\n\n\t\tif (ret == -ENOENT) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tv3d->clk = NULL;\n\t\t} else {\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get V3D clock: %d\\n\",\n\t\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tvc4->irq = ret;\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (V3D_READ(V3D_IDENT0) != V3D_EXPECTED_IDENT0) {\n\t\tDRM_ERROR(\"V3D_IDENT0 read 0x%08x instead of 0x%08x\\n\",\n\t\t\t  V3D_READ(V3D_IDENT0), V3D_EXPECTED_IDENT0);\n\t\tret = -EINVAL;\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\t \n\tV3D_WRITE(V3D_BPOA, 0);\n\tV3D_WRITE(V3D_BPOS, 0);\n\n\tret = vc4_irq_install(drm, vc4->irq);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to install IRQ handler\\n\");\n\t\tgoto err_put_runtime_pm;\n\t}\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 40);  \n\n\treturn 0;\n\nerr_put_runtime_pm:\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic void vc4_v3d_unbind(struct device *dev, struct device *master,\n\t\t\t   void *data)\n{\n\tstruct drm_device *drm = dev_get_drvdata(master);\n\tstruct vc4_dev *vc4 = to_vc4_dev(drm);\n\n\tvc4_irq_uninstall(drm);\n\n\t \n\tV3D_WRITE(V3D_BPOA, 0);\n\tV3D_WRITE(V3D_BPOS, 0);\n\n\tvc4->v3d = NULL;\n}\n\nstatic const struct dev_pm_ops vc4_v3d_pm_ops = {\n\tSET_RUNTIME_PM_OPS(vc4_v3d_runtime_suspend, vc4_v3d_runtime_resume, NULL)\n};\n\nstatic const struct component_ops vc4_v3d_ops = {\n\t.bind   = vc4_v3d_bind,\n\t.unbind = vc4_v3d_unbind,\n};\n\nstatic int vc4_v3d_dev_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &vc4_v3d_ops);\n}\n\nstatic void vc4_v3d_dev_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &vc4_v3d_ops);\n}\n\nconst struct of_device_id vc4_v3d_dt_match[] = {\n\t{ .compatible = \"brcm,bcm2835-v3d\" },\n\t{ .compatible = \"brcm,cygnus-v3d\" },\n\t{ .compatible = \"brcm,vc4-v3d\" },\n\t{}\n};\n\nstruct platform_driver vc4_v3d_driver = {\n\t.probe = vc4_v3d_dev_probe,\n\t.remove_new = vc4_v3d_dev_remove,\n\t.driver = {\n\t\t.name = \"vc4_v3d\",\n\t\t.of_match_table = vc4_v3d_dt_match,\n\t\t.pm = &vc4_v3d_pm_ops,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}