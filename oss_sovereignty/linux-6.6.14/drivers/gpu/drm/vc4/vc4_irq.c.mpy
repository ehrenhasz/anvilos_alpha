{
  "module_name": "vc4_irq.c",
  "hash_id": "165e5bfde83bdd61cfcc87cc870e38e392d9c4f8f7622ebda03d4d6046c52245",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vc4/vc4_irq.c",
  "human_readable_source": " \n\n \n\n#include <linux/platform_device.h>\n\n#include <drm/drm_drv.h>\n\n#include \"vc4_drv.h\"\n#include \"vc4_regs.h\"\n#include \"vc4_trace.h\"\n\n#define V3D_DRIVER_IRQS (V3D_INT_OUTOMEM | \\\n\t\t\t V3D_INT_FLDONE | \\\n\t\t\t V3D_INT_FRDONE)\n\nstatic void\nvc4_overflow_mem_work(struct work_struct *work)\n{\n\tstruct vc4_dev *vc4 =\n\t\tcontainer_of(work, struct vc4_dev, overflow_mem_work);\n\tstruct vc4_bo *bo;\n\tint bin_bo_slot;\n\tstruct vc4_exec_info *exec;\n\tunsigned long irqflags;\n\n\tmutex_lock(&vc4->bin_bo_lock);\n\n\tif (!vc4->bin_bo)\n\t\tgoto complete;\n\n\tbo = vc4->bin_bo;\n\n\tbin_bo_slot = vc4_v3d_get_bin_slot(vc4);\n\tif (bin_bo_slot < 0) {\n\t\tDRM_ERROR(\"Couldn't allocate binner overflow mem\\n\");\n\t\tgoto complete;\n\t}\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\n\tif (vc4->bin_alloc_overflow) {\n\t\t \n\t\texec = vc4_first_bin_job(vc4);\n\t\tif (!exec)\n\t\t\texec = vc4_last_render_job(vc4);\n\t\tif (exec) {\n\t\t\texec->bin_slots |= vc4->bin_alloc_overflow;\n\t\t} else {\n\t\t\t \n\t\t\tvc4->bin_alloc_used &= ~vc4->bin_alloc_overflow;\n\t\t}\n\t}\n\tvc4->bin_alloc_overflow = BIT(bin_bo_slot);\n\n\tV3D_WRITE(V3D_BPOA, bo->base.dma_addr + bin_bo_slot * vc4->bin_alloc_size);\n\tV3D_WRITE(V3D_BPOS, bo->base.base.size);\n\tV3D_WRITE(V3D_INTCTL, V3D_INT_OUTOMEM);\n\tV3D_WRITE(V3D_INTENA, V3D_INT_OUTOMEM);\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\ncomplete:\n\tmutex_unlock(&vc4->bin_bo_lock);\n}\n\nstatic void\nvc4_irq_finish_bin_job(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_exec_info *next, *exec = vc4_first_bin_job(vc4);\n\n\tif (!exec)\n\t\treturn;\n\n\ttrace_vc4_bcl_end_irq(dev, exec->seqno);\n\n\tvc4_move_job_to_render(dev, exec);\n\tnext = vc4_first_bin_job(vc4);\n\n\t \n\tif (next && next->perfmon == exec->perfmon)\n\t\tvc4_submit_next_bin_job(dev);\n}\n\nstatic void\nvc4_cancel_bin_job(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_exec_info *exec = vc4_first_bin_job(vc4);\n\n\tif (!exec)\n\t\treturn;\n\n\t \n\tif (exec->perfmon)\n\t\tvc4_perfmon_stop(vc4, exec->perfmon, false);\n\n\tlist_move_tail(&exec->head, &vc4->bin_job_list);\n\tvc4_submit_next_bin_job(dev);\n}\n\nstatic void\nvc4_irq_finish_render_job(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct vc4_exec_info *exec = vc4_first_render_job(vc4);\n\tstruct vc4_exec_info *nextbin, *nextrender;\n\n\tif (!exec)\n\t\treturn;\n\n\ttrace_vc4_rcl_end_irq(dev, exec->seqno);\n\n\tvc4->finished_seqno++;\n\tlist_move_tail(&exec->head, &vc4->job_done_list);\n\n\tnextbin = vc4_first_bin_job(vc4);\n\tnextrender = vc4_first_render_job(vc4);\n\n\t \n\tif (exec->perfmon && !nextrender &&\n\t    (!nextbin || nextbin->perfmon != exec->perfmon))\n\t\tvc4_perfmon_stop(vc4, exec->perfmon, true);\n\n\t \n\tif (nextrender)\n\t\tvc4_submit_next_render_job(dev);\n\telse if (nextbin && nextbin->perfmon != exec->perfmon)\n\t\tvc4_submit_next_bin_job(dev);\n\n\tif (exec->fence) {\n\t\tdma_fence_signal_locked(exec->fence);\n\t\tdma_fence_put(exec->fence);\n\t\texec->fence = NULL;\n\t}\n\n\twake_up_all(&vc4->job_wait_queue);\n\tschedule_work(&vc4->job_done_work);\n}\n\nstatic irqreturn_t\nvc4_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tuint32_t intctl;\n\tirqreturn_t status = IRQ_NONE;\n\n\tbarrier();\n\tintctl = V3D_READ(V3D_INTCTL);\n\n\t \n\tV3D_WRITE(V3D_INTCTL, intctl);\n\n\tif (intctl & V3D_INT_OUTOMEM) {\n\t\t \n\t\tV3D_WRITE(V3D_INTDIS, V3D_INT_OUTOMEM);\n\t\tschedule_work(&vc4->overflow_mem_work);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intctl & V3D_INT_FLDONE) {\n\t\tspin_lock(&vc4->job_lock);\n\t\tvc4_irq_finish_bin_job(dev);\n\t\tspin_unlock(&vc4->job_lock);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intctl & V3D_INT_FRDONE) {\n\t\tspin_lock(&vc4->job_lock);\n\t\tvc4_irq_finish_render_job(dev);\n\t\tspin_unlock(&vc4->job_lock);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\treturn status;\n}\n\nstatic void\nvc4_irq_prepare(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\tif (!vc4->v3d)\n\t\treturn;\n\n\tinit_waitqueue_head(&vc4->job_wait_queue);\n\tINIT_WORK(&vc4->overflow_mem_work, vc4_overflow_mem_work);\n\n\t \n\tV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\n}\n\nvoid\nvc4_irq_enable(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (!vc4->v3d)\n\t\treturn;\n\n\t \n\tV3D_WRITE(V3D_INTENA, V3D_INT_FLDONE | V3D_INT_FRDONE);\n}\n\nvoid\nvc4_irq_disable(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tif (!vc4->v3d)\n\t\treturn;\n\n\t \n\tV3D_WRITE(V3D_INTDIS, V3D_DRIVER_IRQS);\n\n\t \n\tV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\n\n\t \n\tsynchronize_irq(vc4->irq);\n\n\tcancel_work_sync(&vc4->overflow_mem_work);\n}\n\nint vc4_irq_install(struct drm_device *dev, int irq)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tint ret;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn -ENODEV;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tvc4_irq_prepare(dev);\n\n\tret = request_irq(irq, vc4_irq, 0, dev->driver->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tvc4_irq_enable(dev);\n\n\treturn 0;\n}\n\nvoid vc4_irq_uninstall(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\tvc4_irq_disable(dev);\n\tfree_irq(vc4->irq, dev);\n}\n\n \nvoid vc4_irq_reset(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tunsigned long irqflags;\n\n\tif (WARN_ON_ONCE(vc4->is_vc5))\n\t\treturn;\n\n\t \n\tV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\n\n\t \n\tV3D_WRITE(V3D_INTENA, V3D_DRIVER_IRQS);\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\tvc4_cancel_bin_job(dev);\n\tvc4_irq_finish_render_job(dev);\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}